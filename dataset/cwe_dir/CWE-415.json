[
    {
        "cve_id": "CVE-2022-33033",
        "func_name": "LibreDWG/libredwg/decode_preR13",
        "description": "LibreDWG v0.12.4.4608 was discovered to contain a double-free via the function dwg_read_file at dwg.c.",
        "git_url": "https://github.com/LibreDWG/libredwg/commit/e2dad9a9a06dd9f86ecb17f165568e83e32e7d13",
        "commit_title": "decode_r11: protect from fatal r11 section errors",
        "commit_text": " Fixes GH #493  with illegal (fuzzed) input",
        "func_before": "int\ndecode_preR13 (Bit_Chain *restrict dat, Dwg_Data *restrict dwg)\n{\n  BITCODE_RL entities_start = 0, entities_end = 0;\n  BITCODE_RL blocks_start = 0, blocks_size = 0, blocks_end = 0;\n  BITCODE_RL rl1, rl2, blocks_max = 0xFFFFFFFF, num_entities;\n  BITCODE_RS rs2;\n  Dwg_Object *obj = NULL;\n  int tbl_id;\n  int error = 0;\n  int num_sections = 5;\n\n  loglevel = dat->opts & DWG_OPTS_LOGLEVEL;\n#ifndef USE_WRITE\n  fprintf(stderr, \"Cannot create pre-R13 documents with --disable-write\\n\");\n  return DWG_ERR_INTERNALERROR;\n#else\n  {\n    int i;\n    Dwg_Header *_obj = (Dwg_Header *)&dwg->header;\n    Bit_Chain *hdl_dat = dat;\n    dat->byte = 0x06;\n    // clang-format off\n    #include \"header.spec\"\n    // clang-format on\n  }\n  LOG_TRACE (\"@0x%lx\\n\", dat->byte); // 0x14\n\n  // setup all the new control objects\n  error |= dwg_add_Document (dwg, 0);\n\n  // 5 tables + header + block. VIEW = 6\n  if (dwg->header.numheader_vars > 158) // r10\n    num_sections += 3;\n  if (dwg->header.numheader_vars > 160) // r11\n    num_sections += 2;\n  dwg->header.section = (Dwg_Section *)calloc (sizeof (Dwg_Section),\n                                               num_sections + 2);\n  if (!dwg->header.section)\n    {\n      LOG_ERROR (\"Out of memory\");\n      return DWG_ERR_OUTOFMEM;\n    }\n  dwg->header.numsections = num_sections;\n  PRE (R_2_0b) {\n    bit_read_RC (dat); // the 6th zero\n    LOG_TRACE (\"zero[6]: 0 [RC 0]\\n\");\n  }\n  SINCE (R_2_0b) {\n    entities_start = bit_read_RL (dat);\n    LOG_TRACE (\"entities_start: \" FORMAT_RL \" (\" FORMAT_RLx \") [RL]\\n\", entities_start, entities_start);\n    entities_end = bit_read_RL (dat);\n    LOG_TRACE (\"entities_end: \" FORMAT_RL \" (\" FORMAT_RLx \") [RL]\\n\", entities_end, entities_end);\n    blocks_start = bit_read_RL (dat);\n    LOG_TRACE (\"blocks_start: \" FORMAT_RL \" (\" FORMAT_RLx \") [RL]\\n\", blocks_start, blocks_start);\n    blocks_size = bit_read_RL (dat);\n    if (blocks_size >= 0x40000000) {\n      LOG_TRACE (\"blocks_size: 0x40000000 | \" FORMAT_RL \" [RLx]\\n\", blocks_size & 0x3fffffff);\n    }\n    else {\n      LOG_TRACE (\"blocks_size: \" FORMAT_RL \" [RL]\\n\", blocks_size);\n    }\n    blocks_end = bit_read_RL (dat);\n    LOG_TRACE (\"blocks_end: \" FORMAT_RL \" (\" FORMAT_RLx \") [RL]\\n\", blocks_end, blocks_end);\n    blocks_max = bit_read_RL (dat); // 0x80000000\n    LOG_TRACE (\"blocks_max: \" FORMAT_RLx \" [RLx]\\n\", blocks_max);\n    tbl_id = 0;\n    dwg->header.section[0].number = 0;\n    dwg->header.section[0].type = (Dwg_Section_Type)SECTION_HEADER_R11;\n    strcpy (dwg->header.section[0].name, \"HEADER\");\n\n    // The 5 tables (num_sections always 5): 3 RS + 1 RL address\n    LOG_INFO (\"==========================================\\n\")\n    if (decode_preR13_section_hdr (\"BLOCK\", SECTION_BLOCK, dat, dwg)\n        || decode_preR13_section_hdr (\"LAYER\", SECTION_LAYER, dat, dwg)\n        || decode_preR13_section_hdr (\"STYLE\", SECTION_STYLE, dat, dwg)\n        || decode_preR13_section_hdr (\"LTYPE\", SECTION_LTYPE, dat, dwg)\n        || decode_preR13_section_hdr (\"VIEW\", SECTION_VIEW, dat, dwg))\n      return DWG_ERR_INVALIDDWG;\n  }\n  LOG_TRACE (\"@0x%lx\\n\", dat->byte); // 0x5e\n  if (dat->size < 0x1f0) // AC1.50 0x1f9 74 vars\n    {\n      LOG_ERROR (\"DWG too small %zu\", (size_t)dat->size)\n      return DWG_ERR_INVALIDDWG;\n    }\n\n  LOG_INFO (\"==========================================\\n\")\n  error |= decode_preR13_header_variables (dat, dwg);\n  LOG_TRACE (\"@0x%lx\\n\", dat->byte);\n  if (error >= DWG_ERR_CRITICAL)\n    return error;\n  if (dat->byte + 2 >= dat->size)\n    {\n      LOG_ERROR (\"post HEADER overflow\")\n      return error | DWG_ERR_CRITICAL;\n    }\n  SINCE (R_11)\n  {\n    // crc16 + DWG_SENTINEL_R11_HEADER_END\n    BITCODE_RS crc, crcc;\n    BITCODE_TF r11_sentinel;\n    crcc = bit_calc_CRC (0xC0C1, &dat->chain[0], dat->byte); // from 0 to now\n    crc = bit_read_RS (dat);\n    LOG_TRACE (\"crc: %04X [RSx] from 0-0x%lx\\n\", crc, dat->byte - 2);\n    if (crc != crcc)\n      {\n        LOG_ERROR (\"Header CRC mismatch %04X <=> %04X\", crc, crcc);\n        error |= DWG_ERR_WRONGCRC;\n      }\n    r11_sentinel = bit_read_TF (dat, 16);\n    if (!r11_sentinel)\n      return error | DWG_ERR_INVALIDDWG;\n    LOG_TRACE (\"r11_sentinel: \");\n    LOG_TRACE_TF (r11_sentinel, 16) // == C46E6854F86E3330633EC1852ADC9401\n    if (memcmp (r11_sentinel, dwg_sentinel (DWG_SENTINEL_R11_HEADER_END), 16))\n      {\n        LOG_ERROR (\"DWG_SENTINEL_R11_HEADER_END mismatch\");\n        error |= DWG_ERR_WRONGCRC;\n      }\n    free (r11_sentinel);\n    }\n\n  PRE (R_10)\n    num_entities = dwg->header_vars.numentities;\n  else\n    num_entities = 0;\n  PRE (R_2_0b) {\n    entities_start = dat->byte;\n    entities_end = dwg->header_vars.dwg_size;\n  }\n\n  // additional tables mixed-in since r10\n  if (dwg->header.numheader_vars > 158) // r10\n    {\n      dat->byte = 0x3ef;\n      LOG_TRACE (\"@0x%lx\\n\", dat->byte);\n      decode_preR13_section_hdr (\"UCS\", SECTION_UCS, dat, dwg);\n      dat->byte = 0x500;\n      LOG_TRACE (\"@0x%lx\\n\", dat->byte);\n      decode_preR13_section_hdr (\"VPORT\", SECTION_VPORT, dat, dwg);\n      dat->byte = 0x512;\n      LOG_TRACE (\"@0x%lx\\n\", dat->byte);\n      decode_preR13_section_hdr (\"APPID\", SECTION_APPID, dat, dwg);\n      dat->byte = entities_start;\n    }\n  if (dwg->header.numheader_vars > 160) // r11\n    {\n      dat->byte = 0x522;\n      LOG_TRACE (\"@0x%lx\\n\", dat->byte);\n      decode_preR13_section_hdr (\"DIMSTYLE\", SECTION_DIMSTYLE, dat, dwg);\n      dat->byte = 0x69f;\n      LOG_TRACE (\"@0x%lx\\n\", dat->byte);\n      decode_preR13_section_hdr (\"VX\", SECTION_VX, dat, dwg);\n      dat->byte = entities_start;\n    }\n\n  // entities\n  if (dat->byte != entities_start)\n    {\n      LOG_WARN (\"@0x%lx => entities_start 0x%x\", dat->byte, entities_start);\n      if (dat->byte < entities_start)\n        {\n          _DEBUG_HERE (dat->byte - entities_start)\n        }\n      dat->byte = entities_start;\n    }\n  error |= decode_preR13_entities (entities_start, entities_end, num_entities,\n                                   entities_end - entities_start, 0, dat, dwg);\n  if (error >= DWG_ERR_CRITICAL)\n    return error;\n  if (dat->byte != entities_end)\n    {\n      LOG_WARN (\"@0x%lx => entities_end 0x%x\", dat->byte, entities_end);\n      dat->byte = entities_end;\n    }\n  PRE (R_2_0b) {\n    // this has usually some slack at the end.\n    return error;\n  }\n  LOG_INFO (\"==========================================\\n\")\n  //dat->byte += 20; /* crc + sentinel? 20 byte */\n  if (!dwg->next_hdl)\n    dwg_set_next_hdl (dwg, 0x22);\n  error |= decode_preR13_section (SECTION_BLOCK, dat, dwg);\n  error |= decode_preR13_section (SECTION_LAYER, dat, dwg);\n  error |= decode_preR13_section (SECTION_STYLE, dat, dwg);\n  error |= decode_preR13_section (SECTION_LTYPE, dat, dwg);\n  error |= decode_preR13_section (SECTION_VIEW, dat, dwg);\n#if 1\n  if (num_sections > 5) // r10\n    {\n      error |= decode_preR13_section (SECTION_UCS, dat, dwg);\n      error |= decode_preR13_section (SECTION_VPORT, dat, dwg);\n      error |= decode_preR13_section (SECTION_APPID, dat, dwg);\n    }\n  if (num_sections > 8) // r11\n    {\n      error |= decode_preR13_section (SECTION_DIMSTYLE, dat, dwg);\n      error |= decode_preR13_section (SECTION_VX, dat, dwg);\n    }\n#endif\n  if (error >= DWG_ERR_CRITICAL)\n    return error;\n\n  // block entities\n  if (dat->byte != blocks_start)\n    {\n      BITCODE_TF unknown;\n      int len = blocks_start - dat->byte;\n      LOG_WARN (\"\\n@0x%lx => blocks_start 0x%x\", dat->byte, blocks_start);\n      if (dat->byte < blocks_start)\n        {\n          unknown = bit_read_TF (dat, len);\n          LOG_TRACE (\"unknown (%d):\", len);\n          LOG_TRACE_TF (unknown, len);\n          free (unknown);\n        }\n      dat->byte = blocks_start;\n    }\n  num_entities = 0;\n  VERSION (R_11)\n    blocks_end -= 32; // ??\n  error |= decode_preR13_entities (blocks_start, blocks_end,\n                                   num_entities, blocks_size & 0x3FFFFFFF,\n                                   blocks_max, dat, dwg);\n  if (error >= DWG_ERR_CRITICAL)\n    return error;\n\n  PRE (R_11) {\n    return error;\n  }\n  // only since r11 (AC1009)\n  LOG_TRACE (\"AUXHEADER: @0x%lx\\n\", dat->byte);\n  // 36 byte: 9x long\n  rl1 = bit_read_RL (dat);\n  rl2 = bit_read_RL (dat);\n  LOG_TRACE (\"?2long: 0x%x 0x%x %f\\n\", rl1, rl2,\n             (double)dat->chain[dat->byte - 8]);\n  rl1 = bit_read_RL (dat);\n  rl2 = bit_read_RL (dat);\n  LOG_TRACE (\"?2long: 0x%x 0x%x %f\\n\", rl1, rl2,\n             (double)dat->chain[dat->byte - 8]);\n  rl1 = bit_read_RL (dat);\n  rl2 = bit_read_RL (dat);\n  LOG_TRACE (\"?2long: 0x%x 0x%x %f\\n\", rl1, rl2,\n             (double)dat->chain[dat->byte - 8]);\n  rl1 = bit_read_RL (dat);\n  rl2 = bit_read_RL (dat);\n  LOG_TRACE (\"?2long: 0x%x 0x%x %f\\n\", rl1, rl2,\n             (double)dat->chain[dat->byte - 8]);\n  rl1 = bit_read_RL (dat);\n  LOG_TRACE (\"?1long: 0x%x\\n\", rl1);\n\n  LOG_TRACE (\"@0x%lx: 4 block ptrs chk\\n\", dat->byte);\n  if ((rl1 = bit_read_RL (dat)) != entities_start)\n    {\n      LOG_WARN (\"entities_start %x/%x\", rl1, entities_start);\n    }\n  if ((rl1 = bit_read_RL (dat)) != entities_end)\n    {\n      LOG_WARN (\"entities_end %x/%x\", rl1, entities_end);\n    }\n  if ((rl1 = bit_read_RL (dat)) != blocks_start)\n    {\n      LOG_WARN (\"blocks_start %x/%x\", rl1, blocks_start);\n    }\n  if ((rl1 = bit_read_RL (dat)) != blocks_end)\n    {\n      LOG_WARN (\"blocks_end %x/%x\", rl1, blocks_end);\n    }\n  // 12 byte\n  LOG_TRACE (\"@0x%lx\\n\", dat->byte);\n  rl1 = bit_read_RL (dat);\n  rl2 = bit_read_RL (dat);\n  LOG_TRACE (\"?2long: 0x%x 0x%x\\n\", rl1, rl2);\n  rl1 = bit_read_RL (dat);\n  LOG_TRACE (\"?1long: 0x%x\\n\", rl1);\n\n  rl1 = blocks_end + 36 + 4 * 4 + 12; // ??\n  DEBUG_HERE\n  UNKNOWN_UNTIL (rl1);\n  LOG_TRACE (\"@0x%lx\\n\", dat->byte);\n  decode_preR13_section_chk (SECTION_BLOCK, dat, dwg);\n  decode_preR13_section_chk (SECTION_LAYER, dat, dwg);\n  decode_preR13_section_chk (SECTION_STYLE, dat, dwg);\n  decode_preR13_section_chk (SECTION_LTYPE, dat, dwg);\n  decode_preR13_section_chk (SECTION_VIEW, dat, dwg);\n  if (num_sections > 5) // dead code?\n    {\n      decode_preR13_section_chk (SECTION_UCS, dat, dwg);\n      decode_preR13_section_chk (SECTION_VPORT, dat, dwg);\n      decode_preR13_section_chk (SECTION_APPID, dat, dwg);\n      decode_preR13_section_chk (SECTION_DIMSTYLE, dat, dwg);\n      decode_preR13_section_chk (SECTION_VX, dat, dwg);\n    }\n  rl1 = bit_read_RL (dat);\n  LOG_TRACE (\"long 0x%x\\n\", rl1); // address\n  if (dat->byte < dat->size)\n    {\n      int len = dat->size - dat->byte;\n      BITCODE_TF unknown = bit_read_TF (dat, len);\n      LOG_TRACE (\"unknown (%d):\", len);\n      LOG_TRACE_TF (unknown, len);\n      free (unknown);\n    }\n  if (dwg->dirty_refs)\n    dwg_resolve_objectrefs_silent (dwg);\n  return 0;\n#endif // USE_WRITE\n}",
        "func": "int\ndecode_preR13 (Bit_Chain *restrict dat, Dwg_Data *restrict dwg)\n{\n  BITCODE_RL entities_start = 0, entities_end = 0;\n  BITCODE_RL blocks_start = 0, blocks_size = 0, blocks_end = 0;\n  BITCODE_RL rl1, rl2, blocks_max = 0xFFFFFFFF, num_entities;\n  BITCODE_RS rs2;\n  Dwg_Object *obj = NULL;\n  int tbl_id;\n  int error = 0;\n  int num_sections = 5;\n\n  loglevel = dat->opts & DWG_OPTS_LOGLEVEL;\n#ifndef USE_WRITE\n  fprintf(stderr, \"Cannot create pre-R13 documents with --disable-write\\n\");\n  return DWG_ERR_INTERNALERROR;\n#else\n  {\n    int i;\n    Dwg_Header *_obj = (Dwg_Header *)&dwg->header;\n    Bit_Chain *hdl_dat = dat;\n    dat->byte = 0x06;\n    // clang-format off\n    #include \"header.spec\"\n    // clang-format on\n  }\n  LOG_TRACE (\"@0x%lx\\n\", dat->byte); // 0x14\n\n  // setup all the new control objects\n  error |= dwg_add_Document (dwg, 0);\n\n  // 5 tables + header + block. VIEW = 6\n  if (dwg->header.numheader_vars > 158) // r10\n    num_sections += 3;\n  if (dwg->header.numheader_vars > 160) // r11\n    num_sections += 2;\n  dwg->header.section = (Dwg_Section *)calloc (sizeof (Dwg_Section),\n                                               num_sections + 2);\n  if (!dwg->header.section)\n    {\n      LOG_ERROR (\"Out of memory\");\n      return DWG_ERR_OUTOFMEM;\n    }\n  dwg->header.numsections = num_sections;\n  PRE (R_2_0b) {\n    bit_read_RC (dat); // the 6th zero\n    LOG_TRACE (\"zero[6]: 0 [RC 0]\\n\");\n  }\n  SINCE (R_2_0b) {\n    entities_start = bit_read_RL (dat);\n    LOG_TRACE (\"entities_start: \" FORMAT_RL \" (\" FORMAT_RLx \") [RL]\\n\", entities_start, entities_start);\n    entities_end = bit_read_RL (dat);\n    LOG_TRACE (\"entities_end: \" FORMAT_RL \" (\" FORMAT_RLx \") [RL]\\n\", entities_end, entities_end);\n    blocks_start = bit_read_RL (dat);\n    LOG_TRACE (\"blocks_start: \" FORMAT_RL \" (\" FORMAT_RLx \") [RL]\\n\", blocks_start, blocks_start);\n    blocks_size = bit_read_RL (dat);\n    if (blocks_size >= 0x40000000) {\n      LOG_TRACE (\"blocks_size: 0x40000000 | \" FORMAT_RL \" [RLx]\\n\", blocks_size & 0x3fffffff);\n    }\n    else {\n      LOG_TRACE (\"blocks_size: \" FORMAT_RL \" [RL]\\n\", blocks_size);\n    }\n    blocks_end = bit_read_RL (dat);\n    LOG_TRACE (\"blocks_end: \" FORMAT_RL \" (\" FORMAT_RLx \") [RL]\\n\", blocks_end, blocks_end);\n    blocks_max = bit_read_RL (dat); // 0x80000000\n    LOG_TRACE (\"blocks_max: \" FORMAT_RLx \" [RLx]\\n\", blocks_max);\n    tbl_id = 0;\n    dwg->header.section[0].number = 0;\n    dwg->header.section[0].type = (Dwg_Section_Type)SECTION_HEADER_R11;\n    strcpy (dwg->header.section[0].name, \"HEADER\");\n\n    // The 5 tables (num_sections always 5): 3 RS + 1 RL address\n    LOG_INFO (\"==========================================\\n\")\n    if (decode_preR13_section_hdr (\"BLOCK\", SECTION_BLOCK, dat, dwg)\n        || decode_preR13_section_hdr (\"LAYER\", SECTION_LAYER, dat, dwg)\n        || decode_preR13_section_hdr (\"STYLE\", SECTION_STYLE, dat, dwg)\n        || decode_preR13_section_hdr (\"LTYPE\", SECTION_LTYPE, dat, dwg)\n        || decode_preR13_section_hdr (\"VIEW\", SECTION_VIEW, dat, dwg))\n      return DWG_ERR_SECTIONNOTFOUND;\n  }\n  LOG_TRACE (\"@0x%lx\\n\", dat->byte); // 0x5e\n  if (dat->size < 0x1f0) // AC1.50 0x1f9 74 vars\n    {\n      LOG_ERROR (\"DWG too small %zu\", (size_t)dat->size)\n      return DWG_ERR_INVALIDDWG;\n    }\n\n  LOG_INFO (\"==========================================\\n\")\n  error |= decode_preR13_header_variables (dat, dwg);\n  LOG_TRACE (\"@0x%lx\\n\", dat->byte);\n  if (error >= DWG_ERR_CRITICAL)\n    return error;\n  if (dat->byte + 2 >= dat->size)\n    {\n      LOG_ERROR (\"post HEADER overflow\")\n      return error | DWG_ERR_CRITICAL;\n    }\n  SINCE (R_11)\n  {\n    // crc16 + DWG_SENTINEL_R11_HEADER_END\n    BITCODE_RS crc, crcc;\n    BITCODE_TF r11_sentinel;\n    crcc = bit_calc_CRC (0xC0C1, &dat->chain[0], dat->byte); // from 0 to now\n    crc = bit_read_RS (dat);\n    LOG_TRACE (\"crc: %04X [RSx] from 0-0x%lx\\n\", crc, dat->byte - 2);\n    if (crc != crcc)\n      {\n        LOG_ERROR (\"Header CRC mismatch %04X <=> %04X\", crc, crcc);\n        error |= DWG_ERR_WRONGCRC;\n      }\n    r11_sentinel = bit_read_TF (dat, 16);\n    if (!r11_sentinel)\n      return error | DWG_ERR_INVALIDDWG;\n    LOG_TRACE (\"r11_sentinel: \");\n    LOG_TRACE_TF (r11_sentinel, 16) // == C46E6854F86E3330633EC1852ADC9401\n    if (memcmp (r11_sentinel, dwg_sentinel (DWG_SENTINEL_R11_HEADER_END), 16))\n      {\n        LOG_ERROR (\"DWG_SENTINEL_R11_HEADER_END mismatch\");\n        error |= DWG_ERR_WRONGCRC;\n      }\n    free (r11_sentinel);\n    }\n\n  PRE (R_10)\n    num_entities = dwg->header_vars.numentities;\n  else\n    num_entities = 0;\n  PRE (R_2_0b) {\n    entities_start = dat->byte;\n    entities_end = dwg->header_vars.dwg_size;\n  }\n\n  // additional tables mixed-in since r10\n  if (dwg->header.numheader_vars > 158) // r10\n    {\n      dat->byte = 0x3ef;\n      LOG_TRACE (\"@0x%lx\\n\", dat->byte);\n      if (!decode_preR13_section_hdr (\"UCS\", SECTION_UCS, dat, dwg))\n        return DWG_ERR_SECTIONNOTFOUND;\n      dat->byte = 0x500;\n      LOG_TRACE (\"@0x%lx\\n\", dat->byte);\n      if (!decode_preR13_section_hdr (\"VPORT\", SECTION_VPORT, dat, dwg))\n        return DWG_ERR_SECTIONNOTFOUND;\n      dat->byte = 0x512;\n      LOG_TRACE (\"@0x%lx\\n\", dat->byte);\n      if (!decode_preR13_section_hdr (\"APPID\", SECTION_APPID, dat, dwg))\n        return DWG_ERR_SECTIONNOTFOUND;\n      dat->byte = entities_start;\n    }\n  if (dwg->header.numheader_vars > 160) // r11\n    {\n      dat->byte = 0x522;\n      LOG_TRACE (\"@0x%lx\\n\", dat->byte);\n      if (!decode_preR13_section_hdr (\"DIMSTYLE\", SECTION_DIMSTYLE, dat, dwg))\n        return DWG_ERR_SECTIONNOTFOUND;\n      dat->byte = 0x69f;\n      LOG_TRACE (\"@0x%lx\\n\", dat->byte);\n      if (!decode_preR13_section_hdr (\"VX\", SECTION_VX, dat, dwg))\n        return DWG_ERR_SECTIONNOTFOUND;\n      dat->byte = entities_start;\n    }\n\n  // entities\n  if (dat->byte != entities_start)\n    {\n      LOG_WARN (\"@0x%lx => entities_start 0x%x\", dat->byte, entities_start);\n      if (dat->byte < entities_start)\n        {\n          _DEBUG_HERE (dat->byte - entities_start)\n        }\n      dat->byte = entities_start;\n    }\n  error |= decode_preR13_entities (entities_start, entities_end, num_entities,\n                                   entities_end - entities_start, 0, dat, dwg);\n  if (error >= DWG_ERR_CRITICAL)\n    return error;\n  if (dat->byte != entities_end)\n    {\n      LOG_WARN (\"@0x%lx => entities_end 0x%x\", dat->byte, entities_end);\n      dat->byte = entities_end;\n    }\n  PRE (R_2_0b) {\n    // this has usually some slack at the end.\n    return error;\n  }\n  LOG_INFO (\"==========================================\\n\")\n  //dat->byte += 20; /* crc + sentinel? 20 byte */\n  if (!dwg->next_hdl)\n    dwg_set_next_hdl (dwg, 0x22);\n  if (decode_preR13_section (SECTION_BLOCK, dat, dwg)\n       || decode_preR13_section (SECTION_LAYER, dat, dwg)\n       || decode_preR13_section (SECTION_STYLE, dat, dwg)\n       || decode_preR13_section (SECTION_LTYPE, dat, dwg)\n       ||decode_preR13_section (SECTION_VIEW, dat, dwg))\n    return DWG_ERR_SECTIONNOTFOUND;\n#if 1\n  if (num_sections > 5) // r10\n    {\n      if (decode_preR13_section (SECTION_UCS, dat, dwg)\n          || decode_preR13_section (SECTION_VPORT, dat, dwg)\n          || decode_preR13_section (SECTION_APPID, dat, dwg))\n        return DWG_ERR_SECTIONNOTFOUND;\n    }\n  if (num_sections > 8) // r11\n    {\n      if (decode_preR13_section (SECTION_DIMSTYLE, dat, dwg)\n          || decode_preR13_section (SECTION_VX, dat, dwg))\n        return DWG_ERR_SECTIONNOTFOUND;\n    }\n#endif\n  if (error >= DWG_ERR_CRITICAL)\n    return error;\n\n  // block entities\n  if (dat->byte != blocks_start)\n    {\n      BITCODE_TF unknown;\n      int len = blocks_start - dat->byte;\n      LOG_WARN (\"\\n@0x%lx => blocks_start 0x%x\", dat->byte, blocks_start);\n      if (dat->byte < blocks_start)\n        {\n          unknown = bit_read_TF (dat, len);\n          LOG_TRACE (\"unknown (%d):\", len);\n          LOG_TRACE_TF (unknown, len);\n          free (unknown);\n        }\n      dat->byte = blocks_start;\n    }\n  num_entities = 0;\n  VERSION (R_11)\n    blocks_end -= 32; // ??\n  error |= decode_preR13_entities (blocks_start, blocks_end,\n                                   num_entities, blocks_size & 0x3FFFFFFF,\n                                   blocks_max, dat, dwg);\n  if (error >= DWG_ERR_CRITICAL)\n    return error;\n\n  PRE (R_11) {\n    return error;\n  }\n  // only since r11 (AC1009)\n  LOG_TRACE (\"AUXHEADER: @0x%lx\\n\", dat->byte);\n  // 36 byte: 9x long\n  rl1 = bit_read_RL (dat);\n  rl2 = bit_read_RL (dat);\n  LOG_TRACE (\"?2long: 0x%x 0x%x %f\\n\", rl1, rl2,\n             (double)dat->chain[dat->byte - 8]);\n  rl1 = bit_read_RL (dat);\n  rl2 = bit_read_RL (dat);\n  LOG_TRACE (\"?2long: 0x%x 0x%x %f\\n\", rl1, rl2,\n             (double)dat->chain[dat->byte - 8]);\n  rl1 = bit_read_RL (dat);\n  rl2 = bit_read_RL (dat);\n  LOG_TRACE (\"?2long: 0x%x 0x%x %f\\n\", rl1, rl2,\n             (double)dat->chain[dat->byte - 8]);\n  rl1 = bit_read_RL (dat);\n  rl2 = bit_read_RL (dat);\n  LOG_TRACE (\"?2long: 0x%x 0x%x %f\\n\", rl1, rl2,\n             (double)dat->chain[dat->byte - 8]);\n  rl1 = bit_read_RL (dat);\n  LOG_TRACE (\"?1long: 0x%x\\n\", rl1);\n\n  LOG_TRACE (\"@0x%lx: 4 block ptrs chk\\n\", dat->byte);\n  if ((rl1 = bit_read_RL (dat)) != entities_start)\n    {\n      LOG_WARN (\"entities_start %x/%x\", rl1, entities_start);\n    }\n  if ((rl1 = bit_read_RL (dat)) != entities_end)\n    {\n      LOG_WARN (\"entities_end %x/%x\", rl1, entities_end);\n    }\n  if ((rl1 = bit_read_RL (dat)) != blocks_start)\n    {\n      LOG_WARN (\"blocks_start %x/%x\", rl1, blocks_start);\n    }\n  if ((rl1 = bit_read_RL (dat)) != blocks_end)\n    {\n      LOG_WARN (\"blocks_end %x/%x\", rl1, blocks_end);\n    }\n  // 12 byte\n  LOG_TRACE (\"@0x%lx\\n\", dat->byte);\n  rl1 = bit_read_RL (dat);\n  rl2 = bit_read_RL (dat);\n  LOG_TRACE (\"?2long: 0x%x 0x%x\\n\", rl1, rl2);\n  rl1 = bit_read_RL (dat);\n  LOG_TRACE (\"?1long: 0x%x\\n\", rl1);\n\n  rl1 = blocks_end + 36 + 4 * 4 + 12; // ??\n  DEBUG_HERE\n  UNKNOWN_UNTIL (rl1);\n  LOG_TRACE (\"@0x%lx\\n\", dat->byte);\n  decode_preR13_section_chk (SECTION_BLOCK, dat, dwg);\n  decode_preR13_section_chk (SECTION_LAYER, dat, dwg);\n  decode_preR13_section_chk (SECTION_STYLE, dat, dwg);\n  decode_preR13_section_chk (SECTION_LTYPE, dat, dwg);\n  decode_preR13_section_chk (SECTION_VIEW, dat, dwg);\n  if (num_sections > 5) // dead code?\n    {\n      decode_preR13_section_chk (SECTION_UCS, dat, dwg);\n      decode_preR13_section_chk (SECTION_VPORT, dat, dwg);\n      decode_preR13_section_chk (SECTION_APPID, dat, dwg);\n      decode_preR13_section_chk (SECTION_DIMSTYLE, dat, dwg);\n      decode_preR13_section_chk (SECTION_VX, dat, dwg);\n    }\n  rl1 = bit_read_RL (dat);\n  LOG_TRACE (\"long 0x%x\\n\", rl1); // address\n  if (dat->byte < dat->size)\n    {\n      int len = dat->size - dat->byte;\n      BITCODE_TF unknown = bit_read_TF (dat, len);\n      LOG_TRACE (\"unknown (%d):\", len);\n      LOG_TRACE_TF (unknown, len);\n      free (unknown);\n    }\n  if (dwg->dirty_refs)\n    dwg_resolve_objectrefs_silent (dwg);\n  return 0;\n#endif // USE_WRITE\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -76,7 +76,7 @@\n         || decode_preR13_section_hdr (\"STYLE\", SECTION_STYLE, dat, dwg)\n         || decode_preR13_section_hdr (\"LTYPE\", SECTION_LTYPE, dat, dwg)\n         || decode_preR13_section_hdr (\"VIEW\", SECTION_VIEW, dat, dwg))\n-      return DWG_ERR_INVALIDDWG;\n+      return DWG_ERR_SECTIONNOTFOUND;\n   }\n   LOG_TRACE (\"@0x%lx\\n\", dat->byte); // 0x5e\n   if (dat->size < 0x1f0) // AC1.50 0x1f9 74 vars\n@@ -135,23 +135,28 @@\n     {\n       dat->byte = 0x3ef;\n       LOG_TRACE (\"@0x%lx\\n\", dat->byte);\n-      decode_preR13_section_hdr (\"UCS\", SECTION_UCS, dat, dwg);\n+      if (!decode_preR13_section_hdr (\"UCS\", SECTION_UCS, dat, dwg))\n+        return DWG_ERR_SECTIONNOTFOUND;\n       dat->byte = 0x500;\n       LOG_TRACE (\"@0x%lx\\n\", dat->byte);\n-      decode_preR13_section_hdr (\"VPORT\", SECTION_VPORT, dat, dwg);\n+      if (!decode_preR13_section_hdr (\"VPORT\", SECTION_VPORT, dat, dwg))\n+        return DWG_ERR_SECTIONNOTFOUND;\n       dat->byte = 0x512;\n       LOG_TRACE (\"@0x%lx\\n\", dat->byte);\n-      decode_preR13_section_hdr (\"APPID\", SECTION_APPID, dat, dwg);\n+      if (!decode_preR13_section_hdr (\"APPID\", SECTION_APPID, dat, dwg))\n+        return DWG_ERR_SECTIONNOTFOUND;\n       dat->byte = entities_start;\n     }\n   if (dwg->header.numheader_vars > 160) // r11\n     {\n       dat->byte = 0x522;\n       LOG_TRACE (\"@0x%lx\\n\", dat->byte);\n-      decode_preR13_section_hdr (\"DIMSTYLE\", SECTION_DIMSTYLE, dat, dwg);\n+      if (!decode_preR13_section_hdr (\"DIMSTYLE\", SECTION_DIMSTYLE, dat, dwg))\n+        return DWG_ERR_SECTIONNOTFOUND;\n       dat->byte = 0x69f;\n       LOG_TRACE (\"@0x%lx\\n\", dat->byte);\n-      decode_preR13_section_hdr (\"VX\", SECTION_VX, dat, dwg);\n+      if (!decode_preR13_section_hdr (\"VX\", SECTION_VX, dat, dwg))\n+        return DWG_ERR_SECTIONNOTFOUND;\n       dat->byte = entities_start;\n     }\n \n@@ -182,22 +187,25 @@\n   //dat->byte += 20; /* crc + sentinel? 20 byte */\n   if (!dwg->next_hdl)\n     dwg_set_next_hdl (dwg, 0x22);\n-  error |= decode_preR13_section (SECTION_BLOCK, dat, dwg);\n-  error |= decode_preR13_section (SECTION_LAYER, dat, dwg);\n-  error |= decode_preR13_section (SECTION_STYLE, dat, dwg);\n-  error |= decode_preR13_section (SECTION_LTYPE, dat, dwg);\n-  error |= decode_preR13_section (SECTION_VIEW, dat, dwg);\n+  if (decode_preR13_section (SECTION_BLOCK, dat, dwg)\n+       || decode_preR13_section (SECTION_LAYER, dat, dwg)\n+       || decode_preR13_section (SECTION_STYLE, dat, dwg)\n+       || decode_preR13_section (SECTION_LTYPE, dat, dwg)\n+       ||decode_preR13_section (SECTION_VIEW, dat, dwg))\n+    return DWG_ERR_SECTIONNOTFOUND;\n #if 1\n   if (num_sections > 5) // r10\n     {\n-      error |= decode_preR13_section (SECTION_UCS, dat, dwg);\n-      error |= decode_preR13_section (SECTION_VPORT, dat, dwg);\n-      error |= decode_preR13_section (SECTION_APPID, dat, dwg);\n+      if (decode_preR13_section (SECTION_UCS, dat, dwg)\n+          || decode_preR13_section (SECTION_VPORT, dat, dwg)\n+          || decode_preR13_section (SECTION_APPID, dat, dwg))\n+        return DWG_ERR_SECTIONNOTFOUND;\n     }\n   if (num_sections > 8) // r11\n     {\n-      error |= decode_preR13_section (SECTION_DIMSTYLE, dat, dwg);\n-      error |= decode_preR13_section (SECTION_VX, dat, dwg);\n+      if (decode_preR13_section (SECTION_DIMSTYLE, dat, dwg)\n+          || decode_preR13_section (SECTION_VX, dat, dwg))\n+        return DWG_ERR_SECTIONNOTFOUND;\n     }\n #endif\n   if (error >= DWG_ERR_CRITICAL)",
        "diff_line_info": {
            "deleted_lines": [
                "      return DWG_ERR_INVALIDDWG;",
                "      decode_preR13_section_hdr (\"UCS\", SECTION_UCS, dat, dwg);",
                "      decode_preR13_section_hdr (\"VPORT\", SECTION_VPORT, dat, dwg);",
                "      decode_preR13_section_hdr (\"APPID\", SECTION_APPID, dat, dwg);",
                "      decode_preR13_section_hdr (\"DIMSTYLE\", SECTION_DIMSTYLE, dat, dwg);",
                "      decode_preR13_section_hdr (\"VX\", SECTION_VX, dat, dwg);",
                "  error |= decode_preR13_section (SECTION_BLOCK, dat, dwg);",
                "  error |= decode_preR13_section (SECTION_LAYER, dat, dwg);",
                "  error |= decode_preR13_section (SECTION_STYLE, dat, dwg);",
                "  error |= decode_preR13_section (SECTION_LTYPE, dat, dwg);",
                "  error |= decode_preR13_section (SECTION_VIEW, dat, dwg);",
                "      error |= decode_preR13_section (SECTION_UCS, dat, dwg);",
                "      error |= decode_preR13_section (SECTION_VPORT, dat, dwg);",
                "      error |= decode_preR13_section (SECTION_APPID, dat, dwg);",
                "      error |= decode_preR13_section (SECTION_DIMSTYLE, dat, dwg);",
                "      error |= decode_preR13_section (SECTION_VX, dat, dwg);"
            ],
            "added_lines": [
                "      return DWG_ERR_SECTIONNOTFOUND;",
                "      if (!decode_preR13_section_hdr (\"UCS\", SECTION_UCS, dat, dwg))",
                "        return DWG_ERR_SECTIONNOTFOUND;",
                "      if (!decode_preR13_section_hdr (\"VPORT\", SECTION_VPORT, dat, dwg))",
                "        return DWG_ERR_SECTIONNOTFOUND;",
                "      if (!decode_preR13_section_hdr (\"APPID\", SECTION_APPID, dat, dwg))",
                "        return DWG_ERR_SECTIONNOTFOUND;",
                "      if (!decode_preR13_section_hdr (\"DIMSTYLE\", SECTION_DIMSTYLE, dat, dwg))",
                "        return DWG_ERR_SECTIONNOTFOUND;",
                "      if (!decode_preR13_section_hdr (\"VX\", SECTION_VX, dat, dwg))",
                "        return DWG_ERR_SECTIONNOTFOUND;",
                "  if (decode_preR13_section (SECTION_BLOCK, dat, dwg)",
                "       || decode_preR13_section (SECTION_LAYER, dat, dwg)",
                "       || decode_preR13_section (SECTION_STYLE, dat, dwg)",
                "       || decode_preR13_section (SECTION_LTYPE, dat, dwg)",
                "       ||decode_preR13_section (SECTION_VIEW, dat, dwg))",
                "    return DWG_ERR_SECTIONNOTFOUND;",
                "      if (decode_preR13_section (SECTION_UCS, dat, dwg)",
                "          || decode_preR13_section (SECTION_VPORT, dat, dwg)",
                "          || decode_preR13_section (SECTION_APPID, dat, dwg))",
                "        return DWG_ERR_SECTIONNOTFOUND;",
                "      if (decode_preR13_section (SECTION_DIMSTYLE, dat, dwg)",
                "          || decode_preR13_section (SECTION_VX, dat, dwg))",
                "        return DWG_ERR_SECTIONNOTFOUND;"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-34494",
        "func_name": "torvalds/linux/rpmsg_virtio_add_ctrl_dev",
        "description": "rpmsg_virtio_add_ctrl_dev in drivers/rpmsg/virtio_rpmsg_bus.c in the Linux kernel before 5.18.4 has a double free.",
        "git_url": "https://github.com/torvalds/linux/commit/1680939e9ecf7764fba8689cfb3429c2fe2bb23c",
        "commit_title": "rpmsg: virtio: Fix possible double free in rpmsg_virtio_add_ctrl_dev()",
        "commit_text": " vch will be free in virtio_rpmsg_release_device() when rpmsg_ctrldev_register_device() fails. There is no need to call kfree() again.  Link: https://lore.kernel.org/r/20220426060536.15594-3-hbh25y@gmail.com",
        "func_before": "static struct rpmsg_device *rpmsg_virtio_add_ctrl_dev(struct virtio_device *vdev)\n{\n\tstruct virtproc_info *vrp = vdev->priv;\n\tstruct virtio_rpmsg_channel *vch;\n\tstruct rpmsg_device *rpdev_ctrl;\n\tint err = 0;\n\n\tvch = kzalloc(sizeof(*vch), GFP_KERNEL);\n\tif (!vch)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/* Link the channel to the vrp */\n\tvch->vrp = vrp;\n\n\t/* Assign public information to the rpmsg_device */\n\trpdev_ctrl = &vch->rpdev;\n\trpdev_ctrl->ops = &virtio_rpmsg_ops;\n\n\trpdev_ctrl->dev.parent = &vrp->vdev->dev;\n\trpdev_ctrl->dev.release = virtio_rpmsg_release_device;\n\trpdev_ctrl->little_endian = virtio_is_little_endian(vrp->vdev);\n\n\terr = rpmsg_ctrldev_register_device(rpdev_ctrl);\n\tif (err) {\n\t\tkfree(vch);\n\t\treturn ERR_PTR(err);\n\t}\n\n\treturn rpdev_ctrl;\n}",
        "func": "static struct rpmsg_device *rpmsg_virtio_add_ctrl_dev(struct virtio_device *vdev)\n{\n\tstruct virtproc_info *vrp = vdev->priv;\n\tstruct virtio_rpmsg_channel *vch;\n\tstruct rpmsg_device *rpdev_ctrl;\n\tint err = 0;\n\n\tvch = kzalloc(sizeof(*vch), GFP_KERNEL);\n\tif (!vch)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\t/* Link the channel to the vrp */\n\tvch->vrp = vrp;\n\n\t/* Assign public information to the rpmsg_device */\n\trpdev_ctrl = &vch->rpdev;\n\trpdev_ctrl->ops = &virtio_rpmsg_ops;\n\n\trpdev_ctrl->dev.parent = &vrp->vdev->dev;\n\trpdev_ctrl->dev.release = virtio_rpmsg_release_device;\n\trpdev_ctrl->little_endian = virtio_is_little_endian(vrp->vdev);\n\n\terr = rpmsg_ctrldev_register_device(rpdev_ctrl);\n\tif (err) {\n\t\t/* vch will be free in virtio_rpmsg_release_device() */\n\t\treturn ERR_PTR(err);\n\t}\n\n\treturn rpdev_ctrl;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -22,7 +22,7 @@\n \n \terr = rpmsg_ctrldev_register_device(rpdev_ctrl);\n \tif (err) {\n-\t\tkfree(vch);\n+\t\t/* vch will be free in virtio_rpmsg_release_device() */\n \t\treturn ERR_PTR(err);\n \t}\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tkfree(vch);"
            ],
            "added_lines": [
                "\t\t/* vch will be free in virtio_rpmsg_release_device() */"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-34495",
        "func_name": "torvalds/linux/rpmsg_probe",
        "description": "rpmsg_probe in drivers/rpmsg/virtio_rpmsg_bus.c in the Linux kernel before 5.18.4 has a double free.",
        "git_url": "https://github.com/torvalds/linux/commit/c2eecefec5df1306eafce28ccdf1ca159a552ecc",
        "commit_title": "rpmsg: virtio: Fix possible double free in rpmsg_probe()",
        "commit_text": " vch will be free in virtio_rpmsg_release_device() when rpmsg_ns_register_device() fails. There is no need to call kfree() again.  Fix this by changing error path from free_vch to free_ctrldev.  Link: https://lore.kernel.org/r/20220426060536.15594-2-hbh25y@gmail.com",
        "func_before": "static int rpmsg_probe(struct virtio_device *vdev)\n{\n\tvq_callback_t *vq_cbs[] = { rpmsg_recv_done, rpmsg_xmit_done };\n\tstatic const char * const names[] = { \"input\", \"output\" };\n\tstruct virtqueue *vqs[2];\n\tstruct virtproc_info *vrp;\n\tstruct virtio_rpmsg_channel *vch = NULL;\n\tstruct rpmsg_device *rpdev_ns, *rpdev_ctrl;\n\tvoid *bufs_va;\n\tint err = 0, i;\n\tsize_t total_buf_space;\n\tbool notify;\n\n\tvrp = kzalloc(sizeof(*vrp), GFP_KERNEL);\n\tif (!vrp)\n\t\treturn -ENOMEM;\n\n\tvrp->vdev = vdev;\n\n\tidr_init(&vrp->endpoints);\n\tmutex_init(&vrp->endpoints_lock);\n\tmutex_init(&vrp->tx_lock);\n\tinit_waitqueue_head(&vrp->sendq);\n\n\t/* We expect two virtqueues, rx and tx (and in this order) */\n\terr = virtio_find_vqs(vdev, 2, vqs, vq_cbs, names, NULL);\n\tif (err)\n\t\tgoto free_vrp;\n\n\tvrp->rvq = vqs[0];\n\tvrp->svq = vqs[1];\n\n\t/* we expect symmetric tx/rx vrings */\n\tWARN_ON(virtqueue_get_vring_size(vrp->rvq) !=\n\t\tvirtqueue_get_vring_size(vrp->svq));\n\n\t/* we need less buffers if vrings are small */\n\tif (virtqueue_get_vring_size(vrp->rvq) < MAX_RPMSG_NUM_BUFS / 2)\n\t\tvrp->num_bufs = virtqueue_get_vring_size(vrp->rvq) * 2;\n\telse\n\t\tvrp->num_bufs = MAX_RPMSG_NUM_BUFS;\n\n\tvrp->buf_size = MAX_RPMSG_BUF_SIZE;\n\n\ttotal_buf_space = vrp->num_bufs * vrp->buf_size;\n\n\t/* allocate coherent memory for the buffers */\n\tbufs_va = dma_alloc_coherent(vdev->dev.parent,\n\t\t\t\t     total_buf_space, &vrp->bufs_dma,\n\t\t\t\t     GFP_KERNEL);\n\tif (!bufs_va) {\n\t\terr = -ENOMEM;\n\t\tgoto vqs_del;\n\t}\n\n\tdev_dbg(&vdev->dev, \"buffers: va %pK, dma %pad\\n\",\n\t\tbufs_va, &vrp->bufs_dma);\n\n\t/* half of the buffers is dedicated for RX */\n\tvrp->rbufs = bufs_va;\n\n\t/* and half is dedicated for TX */\n\tvrp->sbufs = bufs_va + total_buf_space / 2;\n\n\t/* set up the receive buffers */\n\tfor (i = 0; i < vrp->num_bufs / 2; i++) {\n\t\tstruct scatterlist sg;\n\t\tvoid *cpu_addr = vrp->rbufs + i * vrp->buf_size;\n\n\t\trpmsg_sg_init(&sg, cpu_addr, vrp->buf_size);\n\n\t\terr = virtqueue_add_inbuf(vrp->rvq, &sg, 1, cpu_addr,\n\t\t\t\t\t  GFP_KERNEL);\n\t\tWARN_ON(err); /* sanity check; this can't really happen */\n\t}\n\n\t/* suppress \"tx-complete\" interrupts */\n\tvirtqueue_disable_cb(vrp->svq);\n\n\tvdev->priv = vrp;\n\n\trpdev_ctrl = rpmsg_virtio_add_ctrl_dev(vdev);\n\tif (IS_ERR(rpdev_ctrl)) {\n\t\terr = PTR_ERR(rpdev_ctrl);\n\t\tgoto free_coherent;\n\t}\n\n\t/* if supported by the remote processor, enable the name service */\n\tif (virtio_has_feature(vdev, VIRTIO_RPMSG_F_NS)) {\n\t\tvch = kzalloc(sizeof(*vch), GFP_KERNEL);\n\t\tif (!vch) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto free_ctrldev;\n\t\t}\n\n\t\t/* Link the channel to our vrp */\n\t\tvch->vrp = vrp;\n\n\t\t/* Assign public information to the rpmsg_device */\n\t\trpdev_ns = &vch->rpdev;\n\t\trpdev_ns->ops = &virtio_rpmsg_ops;\n\t\trpdev_ns->little_endian = virtio_is_little_endian(vrp->vdev);\n\n\t\trpdev_ns->dev.parent = &vrp->vdev->dev;\n\t\trpdev_ns->dev.release = virtio_rpmsg_release_device;\n\n\t\terr = rpmsg_ns_register_device(rpdev_ns);\n\t\tif (err)\n\t\t\tgoto free_vch;\n\t}\n\n\t/*\n\t * Prepare to kick but don't notify yet - we can't do this before\n\t * device is ready.\n\t */\n\tnotify = virtqueue_kick_prepare(vrp->rvq);\n\n\t/* From this point on, we can notify and get callbacks. */\n\tvirtio_device_ready(vdev);\n\n\t/* tell the remote processor it can start sending messages */\n\t/*\n\t * this might be concurrent with callbacks, but we are only\n\t * doing notify, not a full kick here, so that's ok.\n\t */\n\tif (notify)\n\t\tvirtqueue_notify(vrp->rvq);\n\n\tdev_info(&vdev->dev, \"rpmsg host is online\\n\");\n\n\treturn 0;\n\nfree_vch:\n\tkfree(vch);\nfree_ctrldev:\n\trpmsg_virtio_del_ctrl_dev(rpdev_ctrl);\nfree_coherent:\n\tdma_free_coherent(vdev->dev.parent, total_buf_space,\n\t\t\t  bufs_va, vrp->bufs_dma);\nvqs_del:\n\tvdev->config->del_vqs(vrp->vdev);\nfree_vrp:\n\tkfree(vrp);\n\treturn err;\n}",
        "func": "static int rpmsg_probe(struct virtio_device *vdev)\n{\n\tvq_callback_t *vq_cbs[] = { rpmsg_recv_done, rpmsg_xmit_done };\n\tstatic const char * const names[] = { \"input\", \"output\" };\n\tstruct virtqueue *vqs[2];\n\tstruct virtproc_info *vrp;\n\tstruct virtio_rpmsg_channel *vch = NULL;\n\tstruct rpmsg_device *rpdev_ns, *rpdev_ctrl;\n\tvoid *bufs_va;\n\tint err = 0, i;\n\tsize_t total_buf_space;\n\tbool notify;\n\n\tvrp = kzalloc(sizeof(*vrp), GFP_KERNEL);\n\tif (!vrp)\n\t\treturn -ENOMEM;\n\n\tvrp->vdev = vdev;\n\n\tidr_init(&vrp->endpoints);\n\tmutex_init(&vrp->endpoints_lock);\n\tmutex_init(&vrp->tx_lock);\n\tinit_waitqueue_head(&vrp->sendq);\n\n\t/* We expect two virtqueues, rx and tx (and in this order) */\n\terr = virtio_find_vqs(vdev, 2, vqs, vq_cbs, names, NULL);\n\tif (err)\n\t\tgoto free_vrp;\n\n\tvrp->rvq = vqs[0];\n\tvrp->svq = vqs[1];\n\n\t/* we expect symmetric tx/rx vrings */\n\tWARN_ON(virtqueue_get_vring_size(vrp->rvq) !=\n\t\tvirtqueue_get_vring_size(vrp->svq));\n\n\t/* we need less buffers if vrings are small */\n\tif (virtqueue_get_vring_size(vrp->rvq) < MAX_RPMSG_NUM_BUFS / 2)\n\t\tvrp->num_bufs = virtqueue_get_vring_size(vrp->rvq) * 2;\n\telse\n\t\tvrp->num_bufs = MAX_RPMSG_NUM_BUFS;\n\n\tvrp->buf_size = MAX_RPMSG_BUF_SIZE;\n\n\ttotal_buf_space = vrp->num_bufs * vrp->buf_size;\n\n\t/* allocate coherent memory for the buffers */\n\tbufs_va = dma_alloc_coherent(vdev->dev.parent,\n\t\t\t\t     total_buf_space, &vrp->bufs_dma,\n\t\t\t\t     GFP_KERNEL);\n\tif (!bufs_va) {\n\t\terr = -ENOMEM;\n\t\tgoto vqs_del;\n\t}\n\n\tdev_dbg(&vdev->dev, \"buffers: va %pK, dma %pad\\n\",\n\t\tbufs_va, &vrp->bufs_dma);\n\n\t/* half of the buffers is dedicated for RX */\n\tvrp->rbufs = bufs_va;\n\n\t/* and half is dedicated for TX */\n\tvrp->sbufs = bufs_va + total_buf_space / 2;\n\n\t/* set up the receive buffers */\n\tfor (i = 0; i < vrp->num_bufs / 2; i++) {\n\t\tstruct scatterlist sg;\n\t\tvoid *cpu_addr = vrp->rbufs + i * vrp->buf_size;\n\n\t\trpmsg_sg_init(&sg, cpu_addr, vrp->buf_size);\n\n\t\terr = virtqueue_add_inbuf(vrp->rvq, &sg, 1, cpu_addr,\n\t\t\t\t\t  GFP_KERNEL);\n\t\tWARN_ON(err); /* sanity check; this can't really happen */\n\t}\n\n\t/* suppress \"tx-complete\" interrupts */\n\tvirtqueue_disable_cb(vrp->svq);\n\n\tvdev->priv = vrp;\n\n\trpdev_ctrl = rpmsg_virtio_add_ctrl_dev(vdev);\n\tif (IS_ERR(rpdev_ctrl)) {\n\t\terr = PTR_ERR(rpdev_ctrl);\n\t\tgoto free_coherent;\n\t}\n\n\t/* if supported by the remote processor, enable the name service */\n\tif (virtio_has_feature(vdev, VIRTIO_RPMSG_F_NS)) {\n\t\tvch = kzalloc(sizeof(*vch), GFP_KERNEL);\n\t\tif (!vch) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto free_ctrldev;\n\t\t}\n\n\t\t/* Link the channel to our vrp */\n\t\tvch->vrp = vrp;\n\n\t\t/* Assign public information to the rpmsg_device */\n\t\trpdev_ns = &vch->rpdev;\n\t\trpdev_ns->ops = &virtio_rpmsg_ops;\n\t\trpdev_ns->little_endian = virtio_is_little_endian(vrp->vdev);\n\n\t\trpdev_ns->dev.parent = &vrp->vdev->dev;\n\t\trpdev_ns->dev.release = virtio_rpmsg_release_device;\n\n\t\terr = rpmsg_ns_register_device(rpdev_ns);\n\t\tif (err)\n\t\t\t/* vch will be free in virtio_rpmsg_release_device() */\n\t\t\tgoto free_ctrldev;\n\t}\n\n\t/*\n\t * Prepare to kick but don't notify yet - we can't do this before\n\t * device is ready.\n\t */\n\tnotify = virtqueue_kick_prepare(vrp->rvq);\n\n\t/* From this point on, we can notify and get callbacks. */\n\tvirtio_device_ready(vdev);\n\n\t/* tell the remote processor it can start sending messages */\n\t/*\n\t * this might be concurrent with callbacks, but we are only\n\t * doing notify, not a full kick here, so that's ok.\n\t */\n\tif (notify)\n\t\tvirtqueue_notify(vrp->rvq);\n\n\tdev_info(&vdev->dev, \"rpmsg host is online\\n\");\n\n\treturn 0;\n\nfree_ctrldev:\n\trpmsg_virtio_del_ctrl_dev(rpdev_ctrl);\nfree_coherent:\n\tdma_free_coherent(vdev->dev.parent, total_buf_space,\n\t\t\t  bufs_va, vrp->bufs_dma);\nvqs_del:\n\tvdev->config->del_vqs(vrp->vdev);\nfree_vrp:\n\tkfree(vrp);\n\treturn err;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -106,7 +106,8 @@\n \n \t\terr = rpmsg_ns_register_device(rpdev_ns);\n \t\tif (err)\n-\t\t\tgoto free_vch;\n+\t\t\t/* vch will be free in virtio_rpmsg_release_device() */\n+\t\t\tgoto free_ctrldev;\n \t}\n \n \t/*\n@@ -130,8 +131,6 @@\n \n \treturn 0;\n \n-free_vch:\n-\tkfree(vch);\n free_ctrldev:\n \trpmsg_virtio_del_ctrl_dev(rpdev_ctrl);\n free_coherent:",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\tgoto free_vch;",
                "free_vch:",
                "\tkfree(vch);"
            ],
            "added_lines": [
                "\t\t\t/* vch will be free in virtio_rpmsg_release_device() */",
                "\t\t\tgoto free_ctrldev;"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-41687",
        "func_name": "DCMTK/dcmtk/parsePresentationContext",
        "description": "DCMTK through 3.6.6 does not handle memory free properly. The program malloc a heap memory for parsing data, but does not free it when error in parsing. Sending specific requests to the dcmqrdb program incur the memory leak. An attacker can use it to launch a DoS attack.",
        "git_url": "https://github.com/DCMTK/dcmtk/commit/a9697dfeb672b0b9412c00c7d36d801e27ec85cb",
        "commit_title": "Fixed poss. NULL pointer dereference/double free.",
        "commit_text": " Thanks to Jinsheng Ba <bajinsheng@u.nus.edu> for the report and some patches.",
        "func_before": "static OFCondition\nparsePresentationContext(unsigned char type,\n                  PRV_PRESENTATIONCONTEXTITEM * context, unsigned char *buf,\n                         unsigned long *itemLength, unsigned long availData)\n{\n    unsigned long\n        length;\n    unsigned long\n        presentationLength;\n    OFCondition cond = EC_Normal;\n    DUL_SUBITEM\n        * subItem;\n\n    // We need at least 8 bytes, anything smaller would be reading past the end\n    if (availData < 8)\n        return makeLengthError(\"presentation context\", availData, 8);\n\n    if ((context->transferSyntaxList = LST_Create()) == NULL) return EC_MemoryExhausted;\n\n    *itemLength = 0;\n    context->type = *buf++;\n    context->rsv1 = *buf++;\n    EXTRACT_SHORT_BIG(buf, context->length);\n    buf += 2;\n    context->contextID = *buf++;\n    context->rsv2 = *buf++;\n    context->result = *buf++;\n    context->rsv3 = *buf++;\n\n    length = context->length;\n    *itemLength = 2 + 2 + length;\n\n    // Does the length field claim to be larger than the containing PDU?\n    if (availData - 4 < length || length < 4)\n        return makeLengthError(\"presentation context\", availData, 4, length);\n\n    DCMNET_TRACE(\"Parsing Presentation Context: (\"\n            << STD_NAMESPACE hex << STD_NAMESPACE setfill('0') << STD_NAMESPACE setw(2) << (unsigned int)context->type\n            << STD_NAMESPACE dec << \"), Length: \" << (unsigned long)context->length << OFendl\n            << \"Presentation Context ID: \"\n            << STD_NAMESPACE hex << STD_NAMESPACE setfill('0') << STD_NAMESPACE setw(2) << (unsigned int)context->contextID\n            << STD_NAMESPACE dec);\n    presentationLength = length - 4;\n    if (!((type == DUL_TYPEPRESENTATIONCONTEXTAC) &&\n          (context->result != DUL_PRESENTATION_ACCEPT))) {\n        while (presentationLength > 0) {\n            DCMNET_TRACE(\"Parsing remaining \" << presentationLength << \" bytes of Presentation Context\" << OFendl\n                    << \"Next item type: \"\n                    << STD_NAMESPACE hex << STD_NAMESPACE setfill('0') << STD_NAMESPACE setw(2) << (unsigned int)*buf);\n            switch (*buf) {\n            case DUL_TYPEABSTRACTSYNTAX:\n                cond = parseSubItem(&context->abstractSyntax, buf, &length, presentationLength);\n                if (cond.bad())\n                    return cond;\n\n                buf += length;\n                if (!OFStandard::safeSubtract(presentationLength, length, presentationLength))\n                  return makeUnderflowError(\"Abstract Syntax\", presentationLength, length);\n                DCMNET_TRACE(\"Successfully parsed Abstract Syntax\");\n                break;\n            case DUL_TYPETRANSFERSYNTAX:\n                subItem = (DUL_SUBITEM*)malloc(sizeof(DUL_SUBITEM));\n                if (subItem == NULL) return EC_MemoryExhausted;\n                cond = parseSubItem(subItem, buf, &length, presentationLength);\n                if (cond.bad()) return cond;\n                LST_Enqueue(&context->transferSyntaxList, (LST_NODE*)subItem);\n                buf += length;\n                if (!OFStandard::safeSubtract(presentationLength, length, presentationLength))\n                  return makeUnderflowError(\"Transfer Syntax\", presentationLength, length);\n                DCMNET_TRACE(\"Successfully parsed Transfer Syntax\");\n                break;\n            default:\n                cond = parseDummy(buf, &length, presentationLength);\n                if (cond.bad())\n                    return cond;\n                buf += length;\n                if (!OFStandard::safeSubtract(presentationLength, length, presentationLength))\n                  return makeUnderflowError(\"unknown presentation context type\", presentationLength, length);\n                break;\n            }\n        }\n    }\n    return EC_Normal;\n}",
        "func": "static OFCondition\nparsePresentationContext(unsigned char type,\n                  PRV_PRESENTATIONCONTEXTITEM * context, unsigned char *buf,\n                         unsigned long *itemLength, unsigned long availData)\n{\n    unsigned long\n        length;\n    unsigned long\n        presentationLength;\n    OFCondition cond = EC_Normal;\n    DUL_SUBITEM\n        * subItem;\n\n    // We need at least 8 bytes, anything smaller would be reading past the end\n    if (availData < 8)\n        return makeLengthError(\"presentation context\", availData, 8);\n\n    if ((context->transferSyntaxList = LST_Create()) == NULL) return EC_MemoryExhausted;\n\n    *itemLength = 0;\n    context->type = *buf++;\n    context->rsv1 = *buf++;\n    EXTRACT_SHORT_BIG(buf, context->length);\n    buf += 2;\n    context->contextID = *buf++;\n    context->rsv2 = *buf++;\n    context->result = *buf++;\n    context->rsv3 = *buf++;\n\n    length = context->length;\n    *itemLength = 2 + 2 + length;\n\n    // Does the length field claim to be larger than the containing PDU?\n    if (availData - 4 < length || length < 4)\n        return makeLengthError(\"presentation context\", availData, 4, length);\n\n    DCMNET_TRACE(\"Parsing Presentation Context: (\"\n            << STD_NAMESPACE hex << STD_NAMESPACE setfill('0') << STD_NAMESPACE setw(2) << (unsigned int)context->type\n            << STD_NAMESPACE dec << \"), Length: \" << (unsigned long)context->length << OFendl\n            << \"Presentation Context ID: \"\n            << STD_NAMESPACE hex << STD_NAMESPACE setfill('0') << STD_NAMESPACE setw(2) << (unsigned int)context->contextID\n            << STD_NAMESPACE dec);\n    presentationLength = length - 4;\n    if (!((type == DUL_TYPEPRESENTATIONCONTEXTAC) &&\n          (context->result != DUL_PRESENTATION_ACCEPT))) {\n        while (presentationLength > 0) {\n            DCMNET_TRACE(\"Parsing remaining \" << presentationLength << \" bytes of Presentation Context\" << OFendl\n                    << \"Next item type: \"\n                    << STD_NAMESPACE hex << STD_NAMESPACE setfill('0') << STD_NAMESPACE setw(2) << (unsigned int)*buf);\n            switch (*buf) {\n            case DUL_TYPEABSTRACTSYNTAX:\n                cond = parseSubItem(&context->abstractSyntax, buf, &length, presentationLength);\n                if (cond.bad())\n                    return cond;\n\n                buf += length;\n                if (!OFStandard::safeSubtract(presentationLength, length, presentationLength))\n                  return makeUnderflowError(\"Abstract Syntax\", presentationLength, length);\n                DCMNET_TRACE(\"Successfully parsed Abstract Syntax\");\n                break;\n            case DUL_TYPETRANSFERSYNTAX:\n                subItem = (DUL_SUBITEM*)malloc(sizeof(DUL_SUBITEM));\n                if (subItem == NULL) return EC_MemoryExhausted;\n                cond = parseSubItem(subItem, buf, &length, presentationLength);\n                if (cond.bad())\n                {\n                    free(subItem);\n                    return cond;\n                }\n                LST_Enqueue(&context->transferSyntaxList, (LST_NODE*)subItem);\n                buf += length;\n                if (!OFStandard::safeSubtract(presentationLength, length, presentationLength))\n                  return makeUnderflowError(\"Transfer Syntax\", presentationLength, length);\n                DCMNET_TRACE(\"Successfully parsed Transfer Syntax\");\n                break;\n            default:\n                cond = parseDummy(buf, &length, presentationLength);\n                if (cond.bad())\n                    return cond;\n                buf += length;\n                if (!OFStandard::safeSubtract(presentationLength, length, presentationLength))\n                  return makeUnderflowError(\"unknown presentation context type\", presentationLength, length);\n                break;\n            }\n        }\n    }\n    return EC_Normal;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -62,7 +62,11 @@\n                 subItem = (DUL_SUBITEM*)malloc(sizeof(DUL_SUBITEM));\n                 if (subItem == NULL) return EC_MemoryExhausted;\n                 cond = parseSubItem(subItem, buf, &length, presentationLength);\n-                if (cond.bad()) return cond;\n+                if (cond.bad())\n+                {\n+                    free(subItem);\n+                    return cond;\n+                }\n                 LST_Enqueue(&context->transferSyntaxList, (LST_NODE*)subItem);\n                 buf += length;\n                 if (!OFStandard::safeSubtract(presentationLength, length, presentationLength))",
        "diff_line_info": {
            "deleted_lines": [
                "                if (cond.bad()) return cond;"
            ],
            "added_lines": [
                "                if (cond.bad())",
                "                {",
                "                    free(subItem);",
                "                    return cond;",
                "                }"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-41687",
        "func_name": "DCMTK/dcmtk/parseUserInfo",
        "description": "DCMTK through 3.6.6 does not handle memory free properly. The program malloc a heap memory for parsing data, but does not free it when error in parsing. Sending specific requests to the dcmqrdb program incur the memory leak. An attacker can use it to launch a DoS attack.",
        "git_url": "https://github.com/DCMTK/dcmtk/commit/a9697dfeb672b0b9412c00c7d36d801e27ec85cb",
        "commit_title": "Fixed poss. NULL pointer dereference/double free.",
        "commit_text": " Thanks to Jinsheng Ba <bajinsheng@u.nus.edu> for the report and some patches.",
        "func_before": "static OFCondition\nparseUserInfo(DUL_USERINFO * userInfo,\n              unsigned char *buf,\n              unsigned long *itemLength,\n              unsigned char typeRQorAC,\n              unsigned long availData /* bytes left for in this PDU */)\n{\n    unsigned short userLength;\n    unsigned long length;\n    OFCondition cond = EC_Normal;\n    PRV_SCUSCPROLE *role;\n    SOPClassExtendedNegotiationSubItem *extNeg = NULL;\n    UserIdentityNegotiationSubItem *usrIdent = NULL;\n\n    // minimum allowed size is 4 byte (case where the length of the user data is 0),\n    // else we read past the buffer end\n    if (availData < 4)\n        return makeLengthError(\"user info\", availData, 4);\n\n    // skip item type (50H) field\n    userInfo->type = *buf++;\n    // skip unused (\"reserved\") field\n    userInfo->rsv1 = *buf++;\n    // get and remember announced length of user data\n    EXTRACT_SHORT_BIG(buf, userInfo->length);\n    // .. and skip over the two length field bytes\n    buf += 2;\n\n    // userLength contains announced length of full user item structure,\n    // will be used here to count down the available data later\n    userLength = userInfo->length;\n    // itemLength contains full length of the user item including the 4 bytes extra header (type, reserved + 2 for length)\n    *itemLength = userLength + 4;\n\n    // does this item claim to be larger than the available data?\n    if (availData < *itemLength)\n        return makeLengthError(\"user info\", availData, 0, userLength);\n\n    DCMNET_TRACE(\"Parsing user info field (\"\n            << STD_NAMESPACE hex << STD_NAMESPACE setfill('0') << STD_NAMESPACE setw(2) << (unsigned int)userInfo->type\n            << STD_NAMESPACE dec << \"), Length: \" << (unsigned long)userInfo->length);\n    // parse through different types of user items as long as we have data\n    while (userLength > 0) {\n        DCMNET_TRACE(\"Parsing remaining \" << (long)userLength << \" bytes of User Information\" << OFendl\n                << \"Next item type: \"\n                << STD_NAMESPACE hex << STD_NAMESPACE setfill('0') << STD_NAMESPACE setw(2) << (unsigned int)*buf);\n        switch (*buf) {\n        case DUL_TYPEMAXLENGTH:\n            cond = parseMaxPDU(&userInfo->maxLength, buf, &length, userLength);\n            if (cond.bad())\n                return cond;\n            buf += length;\n            if (!OFStandard::safeSubtract(userLength, OFstatic_cast(short unsigned int, length), userLength))\n              return makeLengthError(\"maximum length sub-item\", userLength, length);\n            DCMNET_TRACE(\"Successfully parsed Maximum PDU Length\");\n            break;\n        case DUL_TYPEIMPLEMENTATIONCLASSUID:\n            cond = parseSubItem(&userInfo->implementationClassUID,\n                                buf, &length, userLength);\n            if (cond.bad())\n                return cond;\n            buf += length;\n            if (!OFStandard::safeSubtract(userLength, OFstatic_cast(short unsigned int, length), userLength))\n              return makeLengthError(\"Implementation Class UID sub-item\", userLength, length);\n            break;\n\n        case DUL_TYPEASYNCOPERATIONS:\n            cond = parseDummy(buf, &length, userLength);\n            if (cond.bad())\n                return cond;\n            buf += length;\n            if (!OFStandard::safeSubtract(userLength, OFstatic_cast(short unsigned int, length), userLength))\n              return makeLengthError(\"asynchronous operation user item type\", userLength, length);\n            break;\n        case DUL_TYPESCUSCPROLE:\n            role = (PRV_SCUSCPROLE*)malloc(sizeof(PRV_SCUSCPROLE));\n            if (role == NULL) return EC_MemoryExhausted;\n            cond = parseSCUSCPRole(role, buf, &length, userLength);\n            if (cond.bad()) return cond;\n            LST_Enqueue(&userInfo->SCUSCPRoleList, (LST_NODE*)role);\n            buf += length;\n            if (!OFStandard::safeSubtract(userLength, OFstatic_cast(short unsigned int, length), userLength))\n              return makeLengthError(\"SCP/SCU Role Selection sub-item\", userLength, length);\n            break;\n        case DUL_TYPEIMPLEMENTATIONVERSIONNAME:\n            cond = parseSubItem(&userInfo->implementationVersionName,\n                                buf, &length, userLength);\n            if (cond.bad()) return cond;\n            buf += length;\n            if (!OFStandard::safeSubtract(userLength, OFstatic_cast(short unsigned int, length), userLength))\n              return makeLengthError(\"Implementation Version Name structure\", userLength, length);\n            break;\n\n        case DUL_TYPESOPCLASSEXTENDEDNEGOTIATION:\n            /* parse an extended negotiation sub-item */\n            extNeg = new SOPClassExtendedNegotiationSubItem;\n            if (extNeg == NULL)  return EC_MemoryExhausted;\n            cond = parseExtNeg(extNeg, buf, &length, userLength);\n            if (cond.bad()) return cond;\n            if (userInfo->extNegList == NULL)\n            {\n                userInfo->extNegList = new SOPClassExtendedNegotiationSubItemList;\n                if (userInfo->extNegList == NULL)  return EC_MemoryExhausted;\n            }\n            userInfo->extNegList->push_back(extNeg);\n            buf += length;\n            if (!OFStandard::safeSubtract(userLength, OFstatic_cast(short unsigned int, length), userLength))\n              return makeLengthError(\"SOP Class Extended Negotiation sub-item\", userLength, length);\n            break;\n\n        case DUL_TYPENEGOTIATIONOFUSERIDENTITY_REQ:\n        case DUL_TYPENEGOTIATIONOFUSERIDENTITY_ACK:\n          if (typeRQorAC == DUL_TYPEASSOCIATERQ)\n            usrIdent = new UserIdentityNegotiationSubItemRQ();\n          else // assume DUL_TYPEASSOCIATEAC\n            usrIdent = new UserIdentityNegotiationSubItemAC();\n          if (usrIdent == NULL) return EC_MemoryExhausted;\n          cond = usrIdent->parseFromBuffer(buf, length /*return value*/, userLength);\n          if (cond.bad())\n          {\n            delete usrIdent;\n            return cond;\n          }\n          userInfo->usrIdent = usrIdent;\n          buf += length;\n          if (!OFStandard::safeSubtract(userLength, OFstatic_cast(short unsigned int, length), userLength))\n            return makeLengthError(\"User Identity sub-item\", userLength, length);\n          break;\n        default:\n            // we hit an unknown user item that is not defined in the standard\n            // or still unknown to DCMTK\n            cond = parseDummy(buf, &length /* returns bytes \"handled\" by parseDummy */, userLength /* data available in bytes for user item */);\n            if (cond.bad())\n              return cond;\n            // skip the bytes read\n            buf += length;\n            // subtract bytes of parsed data from available data bytes\n            if (OFstatic_cast(unsigned short, length) != length\n                || !OFStandard::safeSubtract(userLength, OFstatic_cast(unsigned short, length), userLength))\n              return makeUnderflowError(\"unknown user item\", userLength, length);\n            break;\n        }\n    }\n\n    return EC_Normal;\n}",
        "func": "static OFCondition\nparseUserInfo(DUL_USERINFO * userInfo,\n              unsigned char *buf,\n              unsigned long *itemLength,\n              unsigned char typeRQorAC,\n              unsigned long availData /* bytes left for in this PDU */)\n{\n    unsigned short userLength;\n    unsigned long length;\n    OFCondition cond = EC_Normal;\n    PRV_SCUSCPROLE *role;\n    SOPClassExtendedNegotiationSubItem *extNeg = NULL;\n    UserIdentityNegotiationSubItem *usrIdent = NULL;\n\n    // minimum allowed size is 4 byte (case where the length of the user data is 0),\n    // else we read past the buffer end\n    if (availData < 4)\n        return makeLengthError(\"user info\", availData, 4);\n\n    // skip item type (50H) field\n    userInfo->type = *buf++;\n    // skip unused (\"reserved\") field\n    userInfo->rsv1 = *buf++;\n    // get and remember announced length of user data\n    EXTRACT_SHORT_BIG(buf, userInfo->length);\n    // .. and skip over the two length field bytes\n    buf += 2;\n\n    // userLength contains announced length of full user item structure,\n    // will be used here to count down the available data later\n    userLength = userInfo->length;\n    // itemLength contains full length of the user item including the 4 bytes extra header (type, reserved + 2 for length)\n    *itemLength = userLength + 4;\n\n    // does this item claim to be larger than the available data?\n    if (availData < *itemLength)\n        return makeLengthError(\"user info\", availData, 0, userLength);\n\n    DCMNET_TRACE(\"Parsing user info field (\"\n            << STD_NAMESPACE hex << STD_NAMESPACE setfill('0') << STD_NAMESPACE setw(2) << (unsigned int)userInfo->type\n            << STD_NAMESPACE dec << \"), Length: \" << (unsigned long)userInfo->length);\n    // parse through different types of user items as long as we have data\n    while (userLength > 0) {\n        DCMNET_TRACE(\"Parsing remaining \" << (long)userLength << \" bytes of User Information\" << OFendl\n                << \"Next item type: \"\n                << STD_NAMESPACE hex << STD_NAMESPACE setfill('0') << STD_NAMESPACE setw(2) << (unsigned int)*buf);\n        switch (*buf) {\n        case DUL_TYPEMAXLENGTH:\n            cond = parseMaxPDU(&userInfo->maxLength, buf, &length, userLength);\n            if (cond.bad())\n                return cond;\n            buf += length;\n            if (!OFStandard::safeSubtract(userLength, OFstatic_cast(short unsigned int, length), userLength))\n              return makeLengthError(\"maximum length sub-item\", userLength, length);\n            DCMNET_TRACE(\"Successfully parsed Maximum PDU Length\");\n            break;\n        case DUL_TYPEIMPLEMENTATIONCLASSUID:\n            cond = parseSubItem(&userInfo->implementationClassUID,\n                                buf, &length, userLength);\n            if (cond.bad())\n                return cond;\n            buf += length;\n            if (!OFStandard::safeSubtract(userLength, OFstatic_cast(short unsigned int, length), userLength))\n              return makeLengthError(\"Implementation Class UID sub-item\", userLength, length);\n            break;\n\n        case DUL_TYPEASYNCOPERATIONS:\n            cond = parseDummy(buf, &length, userLength);\n            if (cond.bad())\n                return cond;\n            buf += length;\n            if (!OFStandard::safeSubtract(userLength, OFstatic_cast(short unsigned int, length), userLength))\n              return makeLengthError(\"asynchronous operation user item type\", userLength, length);\n            break;\n        case DUL_TYPESCUSCPROLE:\n            role = (PRV_SCUSCPROLE*)malloc(sizeof(PRV_SCUSCPROLE));\n            if (role == NULL) return EC_MemoryExhausted;\n            cond = parseSCUSCPRole(role, buf, &length, userLength);\n            if (cond.bad())\n            {\n                free(role);\n                return cond;\n            }\n            LST_Enqueue(&userInfo->SCUSCPRoleList, (LST_NODE*)role);\n            buf += length;\n            if (!OFStandard::safeSubtract(userLength, OFstatic_cast(short unsigned int, length), userLength))\n              return makeLengthError(\"SCP/SCU Role Selection sub-item\", userLength, length);\n            break;\n        case DUL_TYPEIMPLEMENTATIONVERSIONNAME:\n            cond = parseSubItem(&userInfo->implementationVersionName,\n                                buf, &length, userLength);\n            if (cond.bad()) return cond;\n            buf += length;\n            if (!OFStandard::safeSubtract(userLength, OFstatic_cast(short unsigned int, length), userLength))\n              return makeLengthError(\"Implementation Version Name structure\", userLength, length);\n            break;\n\n        case DUL_TYPESOPCLASSEXTENDEDNEGOTIATION:\n            /* parse an extended negotiation sub-item */\n            extNeg = new SOPClassExtendedNegotiationSubItem;\n            if (extNeg == NULL)  return EC_MemoryExhausted;\n            cond = parseExtNeg(extNeg, buf, &length, userLength);\n            if (cond.bad()) return cond;\n            if (userInfo->extNegList == NULL)\n            {\n                userInfo->extNegList = new SOPClassExtendedNegotiationSubItemList;\n                if (userInfo->extNegList == NULL)  return EC_MemoryExhausted;\n            }\n            userInfo->extNegList->push_back(extNeg);\n            buf += length;\n            if (!OFStandard::safeSubtract(userLength, OFstatic_cast(short unsigned int, length), userLength))\n              return makeLengthError(\"SOP Class Extended Negotiation sub-item\", userLength, length);\n            break;\n\n        case DUL_TYPENEGOTIATIONOFUSERIDENTITY_REQ:\n        case DUL_TYPENEGOTIATIONOFUSERIDENTITY_ACK:\n          if (typeRQorAC == DUL_TYPEASSOCIATERQ)\n            usrIdent = new UserIdentityNegotiationSubItemRQ();\n          else // assume DUL_TYPEASSOCIATEAC\n            usrIdent = new UserIdentityNegotiationSubItemAC();\n          if (usrIdent == NULL) return EC_MemoryExhausted;\n          cond = usrIdent->parseFromBuffer(buf, length /*return value*/, userLength);\n          if (cond.bad())\n          {\n            delete usrIdent;\n            return cond;\n          }\n          userInfo->usrIdent = usrIdent;\n          buf += length;\n          if (!OFStandard::safeSubtract(userLength, OFstatic_cast(short unsigned int, length), userLength))\n            return makeLengthError(\"User Identity sub-item\", userLength, length);\n          break;\n        default:\n            // we hit an unknown user item that is not defined in the standard\n            // or still unknown to DCMTK\n            cond = parseDummy(buf, &length /* returns bytes \"handled\" by parseDummy */, userLength /* data available in bytes for user item */);\n            if (cond.bad())\n              return cond;\n            // skip the bytes read\n            buf += length;\n            // subtract bytes of parsed data from available data bytes\n            if (OFstatic_cast(unsigned short, length) != length\n                || !OFStandard::safeSubtract(userLength, OFstatic_cast(unsigned short, length), userLength))\n              return makeUnderflowError(\"unknown user item\", userLength, length);\n            break;\n        }\n    }\n\n    return EC_Normal;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -76,7 +76,11 @@\n             role = (PRV_SCUSCPROLE*)malloc(sizeof(PRV_SCUSCPROLE));\n             if (role == NULL) return EC_MemoryExhausted;\n             cond = parseSCUSCPRole(role, buf, &length, userLength);\n-            if (cond.bad()) return cond;\n+            if (cond.bad())\n+            {\n+                free(role);\n+                return cond;\n+            }\n             LST_Enqueue(&userInfo->SCUSCPRoleList, (LST_NODE*)role);\n             buf += length;\n             if (!OFStandard::safeSubtract(userLength, OFstatic_cast(short unsigned int, length), userLength))",
        "diff_line_info": {
            "deleted_lines": [
                "            if (cond.bad()) return cond;"
            ],
            "added_lines": [
                "            if (cond.bad())",
                "            {",
                "                free(role);",
                "                return cond;",
                "            }"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-41687",
        "func_name": "DCMTK/dcmtk/parseAssociate",
        "description": "DCMTK through 3.6.6 does not handle memory free properly. The program malloc a heap memory for parsing data, but does not free it when error in parsing. Sending specific requests to the dcmqrdb program incur the memory leak. An attacker can use it to launch a DoS attack.",
        "git_url": "https://github.com/DCMTK/dcmtk/commit/a9697dfeb672b0b9412c00c7d36d801e27ec85cb",
        "commit_title": "Fixed poss. NULL pointer dereference/double free.",
        "commit_text": " Thanks to Jinsheng Ba <bajinsheng@u.nus.edu> for the report and some patches.",
        "func_before": "OFCondition\nparseAssociate(unsigned char *buf, unsigned long pduLength,\n               PRV_ASSOCIATEPDU * assoc)\n{\n    OFCondition cond = EC_Normal;\n    unsigned char\n        type;\n    unsigned long\n        itemLength;\n    PRV_PRESENTATIONCONTEXTITEM\n        * context;\n\n    (void) memset(assoc, 0, sizeof(*assoc));\n    if ((assoc->presentationContextList = LST_Create()) == NULL) return EC_MemoryExhausted;\n    if ((assoc->userInfo.SCUSCPRoleList = LST_Create()) == NULL) return EC_MemoryExhausted;\n\n    // Check if the PDU actually is long enough for the fields we read\n    if (pduLength < 2 + 2 + 16 + 16 + 32)\n        return makeLengthError(\"associate PDU\", pduLength, 2 + 2 + 16 + 16 + 32);\n\n    assoc->type = *buf++;\n    assoc->rsv1 = *buf++;\n    EXTRACT_LONG_BIG(buf, assoc->length);\n    buf += 4;\n\n    EXTRACT_SHORT_BIG(buf, assoc->protocol);\n    buf += 2;\n    pduLength -= 2;\n    if ((assoc->protocol & DUL_PROTOCOL) == 0)\n    {\n        char buffer[256];\n        sprintf(buffer, \"DUL Unsupported peer protocol %04x; expected %04x in %s\", assoc->protocol, DUL_PROTOCOL, \"parseAssociate\");\n        return makeDcmnetCondition(DULC_UNSUPPORTEDPEERPROTOCOL, OF_error, buffer);\n    }\n    assoc->rsv2[0] = *buf++;\n    pduLength--;\n    assoc->rsv2[1] = *buf++;\n    pduLength--;\n    (void) strncpy(assoc->calledAPTitle, (char *) buf, 16);\n    assoc->calledAPTitle[16] = '\\0';\n    trim_trailing_spaces(assoc->calledAPTitle);\n\n    buf += 16;\n    pduLength -= 16;\n    (void) strncpy(assoc->callingAPTitle, (char *) buf, 16);\n    assoc->callingAPTitle[16] = '\\0';\n    trim_trailing_spaces(assoc->callingAPTitle);\n    buf += 16;\n    pduLength -= 16;\n    (void) memcpy(assoc->rsv3, buf, 32);\n    buf += 32;\n    pduLength -= 32;\n\n    if (DCM_dcmnetLogger.isEnabledFor(OFLogger::DEBUG_LOG_LEVEL)) {\n        const char *s;\n        DCMNET_DEBUG(\"Parsing an A-ASSOCIATE PDU\");\n        if (assoc->type == DUL_TYPEASSOCIATERQ)\n            s = \"A-ASSOCIATE RQ\";\n        else if (assoc->type == DUL_TYPEASSOCIATEAC)\n            s = \"A-ASSOCIATE AC\";\n        else\n            s = \"Unknown: Programming bug in parseAssociate\";\n\n/*      If we hit the \"Unknown type\", there is a programming bug somewhere.\n**      This function is only supposed to parse A-ASSOCIATE PDUs and\n**      expects its input to have been properly screened.\n*/\n        DCMNET_TRACE(\"PDU type: \"\n            << STD_NAMESPACE hex << ((unsigned int)assoc->type)\n            << STD_NAMESPACE dec << \" (\" << s << \"), PDU Length: \" << assoc->length << OFendl\n            << \"DICOM Protocol: \"\n            << STD_NAMESPACE hex << assoc->protocol\n            << STD_NAMESPACE dec << OFendl\n            << \"Called AP Title:  \" << assoc->calledAPTitle << OFendl\n            << \"Calling AP Title: \" << assoc->callingAPTitle);\n    }\n    while ((cond.good()) && (pduLength > 0))\n    {\n        type = *buf;\n        DCMNET_TRACE(\"Parsing remaining \" << pduLength << \" bytes of A-ASSOCIATE PDU\" << OFendl\n                << \"Next item type: \"\n                << STD_NAMESPACE hex << STD_NAMESPACE setfill('0') << STD_NAMESPACE setw(2) << ((unsigned int)type));\n        switch (type) {\n        case DUL_TYPEAPPLICATIONCONTEXT:\n            cond = parseSubItem(&assoc->applicationContext,\n                                buf, &itemLength, pduLength);\n            if (cond.good())\n            {\n                buf += itemLength;\n                if (!OFStandard::safeSubtract(pduLength, itemLength, pduLength))\n                  return makeUnderflowError(\"Application Context item\", pduLength, itemLength);\n                DCMNET_TRACE(\"Successfully parsed Application Context\");\n            }\n            break;\n        case DUL_TYPEPRESENTATIONCONTEXTRQ:\n        case DUL_TYPEPRESENTATIONCONTEXTAC:\n            context = (PRV_PRESENTATIONCONTEXTITEM*)malloc(sizeof(PRV_PRESENTATIONCONTEXTITEM));\n            if (context == NULL) return EC_MemoryExhausted;\n            (void) memset(context, 0, sizeof(*context));\n            cond = parsePresentationContext(type, context, buf, &itemLength, pduLength);\n            if (cond.bad()) return cond;\n            buf += itemLength;\n            if (!OFStandard::safeSubtract(pduLength, itemLength, pduLength))\n              return makeUnderflowError(\"Presentation Context item\", pduLength, itemLength);\n            LST_Enqueue(&assoc->presentationContextList, (LST_NODE*)context);\n            DCMNET_TRACE(\"Successfully parsed Presentation Context\");\n            break;\n        case DUL_TYPEUSERINFO:\n            // parse user info, which can contain several sub-items like User\n            // Identity Negotiation or SOP Class Extended Negotiation\n            cond = parseUserInfo(&assoc->userInfo, buf, &itemLength, assoc->type, pduLength);\n            if (cond.bad())\n                return cond;\n            buf += itemLength;\n            if (!OFStandard::safeSubtract(pduLength, itemLength, pduLength))\n              return makeUnderflowError(\"User Information item\", pduLength, itemLength);\n            DCMNET_TRACE(\"Successfully parsed User Information\");\n            break;\n        default:\n            cond = parseDummy(buf, &itemLength, pduLength);\n            if (cond.bad())\n                return cond;\n            buf += itemLength;\n            if (!OFStandard::safeSubtract(pduLength, itemLength, pduLength))\n              return makeUnderflowError(\"unknown item type\", pduLength, itemLength);\n            break;\n        }\n    }\n    return cond;\n}",
        "func": "OFCondition\nparseAssociate(unsigned char *buf, unsigned long pduLength,\n               PRV_ASSOCIATEPDU * assoc)\n{\n    OFCondition cond = EC_Normal;\n    unsigned char\n        type;\n    unsigned long\n        itemLength;\n    PRV_PRESENTATIONCONTEXTITEM\n        * context;\n\n    (void) memset(assoc, 0, sizeof(*assoc));\n    // Check if the PDU actually is long enough for the fields we read\n    if (pduLength < 2 + 2 + 16 + 16 + 32)\n        return makeLengthError(\"associate PDU\", pduLength, 2 + 2 + 16 + 16 + 32);\n\n    assoc->type = *buf++;\n    assoc->rsv1 = *buf++;\n    EXTRACT_LONG_BIG(buf, assoc->length);\n    buf += 4;\n\n    EXTRACT_SHORT_BIG(buf, assoc->protocol);\n    buf += 2;\n    pduLength -= 2;\n    if ((assoc->protocol & DUL_PROTOCOL) == 0)\n    {\n        char buffer[256];\n        sprintf(buffer, \"DUL Unsupported peer protocol %04x; expected %04x in %s\", assoc->protocol, DUL_PROTOCOL, \"parseAssociate\");\n        return makeDcmnetCondition(DULC_UNSUPPORTEDPEERPROTOCOL, OF_error, buffer);\n    }\n    assoc->rsv2[0] = *buf++;\n    pduLength--;\n    assoc->rsv2[1] = *buf++;\n    pduLength--;\n    (void) strncpy(assoc->calledAPTitle, (char *) buf, 16);\n    assoc->calledAPTitle[16] = '\\0';\n    trim_trailing_spaces(assoc->calledAPTitle);\n\n    buf += 16;\n    pduLength -= 16;\n    (void) strncpy(assoc->callingAPTitle, (char *) buf, 16);\n    assoc->callingAPTitle[16] = '\\0';\n    trim_trailing_spaces(assoc->callingAPTitle);\n    buf += 16;\n    pduLength -= 16;\n    (void) memcpy(assoc->rsv3, buf, 32);\n    buf += 32;\n    pduLength -= 32;\n\n    if (DCM_dcmnetLogger.isEnabledFor(OFLogger::DEBUG_LOG_LEVEL)) {\n        const char *s;\n        DCMNET_DEBUG(\"Parsing an A-ASSOCIATE PDU\");\n        if (assoc->type == DUL_TYPEASSOCIATERQ)\n            s = \"A-ASSOCIATE RQ\";\n        else if (assoc->type == DUL_TYPEASSOCIATEAC)\n            s = \"A-ASSOCIATE AC\";\n        else\n            s = \"Unknown: Programming bug in parseAssociate\";\n\n/*      If we hit the \"Unknown type\", there is a programming bug somewhere.\n**      This function is only supposed to parse A-ASSOCIATE PDUs and\n**      expects its input to have been properly screened.\n*/\n        DCMNET_TRACE(\"PDU type: \"\n            << STD_NAMESPACE hex << ((unsigned int)assoc->type)\n            << STD_NAMESPACE dec << \" (\" << s << \"), PDU Length: \" << assoc->length << OFendl\n            << \"DICOM Protocol: \"\n            << STD_NAMESPACE hex << assoc->protocol\n            << STD_NAMESPACE dec << OFendl\n            << \"Called AP Title:  \" << assoc->calledAPTitle << OFendl\n            << \"Calling AP Title: \" << assoc->callingAPTitle);\n    }\n    if ((assoc->presentationContextList = LST_Create()) == NULL) return EC_MemoryExhausted;\n    if ((assoc->userInfo.SCUSCPRoleList = LST_Create()) == NULL) return EC_MemoryExhausted;\n    while ((cond.good()) && (pduLength > 0))\n    {\n        type = *buf;\n        DCMNET_TRACE(\"Parsing remaining \" << pduLength << \" bytes of A-ASSOCIATE PDU\" << OFendl\n                << \"Next item type: \"\n                << STD_NAMESPACE hex << STD_NAMESPACE setfill('0') << STD_NAMESPACE setw(2) << ((unsigned int)type));\n        switch (type) {\n        case DUL_TYPEAPPLICATIONCONTEXT:\n            cond = parseSubItem(&assoc->applicationContext,\n                                buf, &itemLength, pduLength);\n            if (cond.good())\n            {\n                buf += itemLength;\n                if (!OFStandard::safeSubtract(pduLength, itemLength, pduLength))\n                {\n                    cond = makeUnderflowError(\"Application Context item\", pduLength, itemLength);\n                }\n                else\n                {\n                    DCMNET_TRACE(\"Successfully parsed Application Context\");\n                }\n            }\n            break;\n        case DUL_TYPEPRESENTATIONCONTEXTRQ:\n        case DUL_TYPEPRESENTATIONCONTEXTAC:\n            context = (PRV_PRESENTATIONCONTEXTITEM*)malloc(sizeof(PRV_PRESENTATIONCONTEXTITEM));\n            if (context != NULL)\n            {\n                (void) memset(context, 0, sizeof(*context));\n                cond = parsePresentationContext(type, context, buf, &itemLength, pduLength);\n                if (cond.bad())\n                {\n                    free(context);\n                }\n                else\n                {\n                    buf += itemLength;\n                    if (!OFStandard::safeSubtract(pduLength, itemLength, pduLength))\n                    {\n                        cond =  makeUnderflowError(\"Presentation Context item\", pduLength, itemLength);\n                    }\n                    else\n                    {\n                        LST_Enqueue(&assoc->presentationContextList, (LST_NODE*)context);\n                        DCMNET_TRACE(\"Successfully parsed Presentation Context\");\n                    }\n                }\n            }\n            else\n            {\n                cond = EC_MemoryExhausted;\n            }\n            break;\n        case DUL_TYPEUSERINFO:\n            // parse user info, which can contain several sub-items like User\n            // Identity Negotiation or SOP Class Extended Negotiation\n            cond = parseUserInfo(&assoc->userInfo, buf, &itemLength, assoc->type, pduLength);\n            if (cond.good())\n            {\n                buf += itemLength;\n                if (!OFStandard::safeSubtract(pduLength, itemLength, pduLength))\n                {\n                    cond = makeUnderflowError(\"User Information item\", pduLength, itemLength);\n                }\n                else\n                {\n                    DCMNET_TRACE(\"Successfully parsed User Information\");\n                }\n            }\n            break;\n        default:\n            cond = parseDummy(buf, &itemLength, pduLength);\n            if (cond.good())\n            {\n                buf += itemLength;\n                if (!OFStandard::safeSubtract(pduLength, itemLength, pduLength))\n                {\n                    cond = makeUnderflowError(\"unknown item type\", pduLength, itemLength);\n                }\n            }\n            break;\n        }\n    }\n    if (cond.bad())\n    {\n      destroyPresentationContextList(&assoc->presentationContextList);\n      destroyUserInformationLists(&assoc->userInfo);\n    }\n    return cond;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -11,9 +11,6 @@\n         * context;\n \n     (void) memset(assoc, 0, sizeof(*assoc));\n-    if ((assoc->presentationContextList = LST_Create()) == NULL) return EC_MemoryExhausted;\n-    if ((assoc->userInfo.SCUSCPRoleList = LST_Create()) == NULL) return EC_MemoryExhausted;\n-\n     // Check if the PDU actually is long enough for the fields we read\n     if (pduLength < 2 + 2 + 16 + 16 + 32)\n         return makeLengthError(\"associate PDU\", pduLength, 2 + 2 + 16 + 16 + 32);\n@@ -74,6 +71,8 @@\n             << \"Called AP Title:  \" << assoc->calledAPTitle << OFendl\n             << \"Calling AP Title: \" << assoc->callingAPTitle);\n     }\n+    if ((assoc->presentationContextList = LST_Create()) == NULL) return EC_MemoryExhausted;\n+    if ((assoc->userInfo.SCUSCPRoleList = LST_Create()) == NULL) return EC_MemoryExhausted;\n     while ((cond.good()) && (pduLength > 0))\n     {\n         type = *buf;\n@@ -88,43 +87,79 @@\n             {\n                 buf += itemLength;\n                 if (!OFStandard::safeSubtract(pduLength, itemLength, pduLength))\n-                  return makeUnderflowError(\"Application Context item\", pduLength, itemLength);\n-                DCMNET_TRACE(\"Successfully parsed Application Context\");\n+                {\n+                    cond = makeUnderflowError(\"Application Context item\", pduLength, itemLength);\n+                }\n+                else\n+                {\n+                    DCMNET_TRACE(\"Successfully parsed Application Context\");\n+                }\n             }\n             break;\n         case DUL_TYPEPRESENTATIONCONTEXTRQ:\n         case DUL_TYPEPRESENTATIONCONTEXTAC:\n             context = (PRV_PRESENTATIONCONTEXTITEM*)malloc(sizeof(PRV_PRESENTATIONCONTEXTITEM));\n-            if (context == NULL) return EC_MemoryExhausted;\n-            (void) memset(context, 0, sizeof(*context));\n-            cond = parsePresentationContext(type, context, buf, &itemLength, pduLength);\n-            if (cond.bad()) return cond;\n-            buf += itemLength;\n-            if (!OFStandard::safeSubtract(pduLength, itemLength, pduLength))\n-              return makeUnderflowError(\"Presentation Context item\", pduLength, itemLength);\n-            LST_Enqueue(&assoc->presentationContextList, (LST_NODE*)context);\n-            DCMNET_TRACE(\"Successfully parsed Presentation Context\");\n+            if (context != NULL)\n+            {\n+                (void) memset(context, 0, sizeof(*context));\n+                cond = parsePresentationContext(type, context, buf, &itemLength, pduLength);\n+                if (cond.bad())\n+                {\n+                    free(context);\n+                }\n+                else\n+                {\n+                    buf += itemLength;\n+                    if (!OFStandard::safeSubtract(pduLength, itemLength, pduLength))\n+                    {\n+                        cond =  makeUnderflowError(\"Presentation Context item\", pduLength, itemLength);\n+                    }\n+                    else\n+                    {\n+                        LST_Enqueue(&assoc->presentationContextList, (LST_NODE*)context);\n+                        DCMNET_TRACE(\"Successfully parsed Presentation Context\");\n+                    }\n+                }\n+            }\n+            else\n+            {\n+                cond = EC_MemoryExhausted;\n+            }\n             break;\n         case DUL_TYPEUSERINFO:\n             // parse user info, which can contain several sub-items like User\n             // Identity Negotiation or SOP Class Extended Negotiation\n             cond = parseUserInfo(&assoc->userInfo, buf, &itemLength, assoc->type, pduLength);\n-            if (cond.bad())\n-                return cond;\n-            buf += itemLength;\n-            if (!OFStandard::safeSubtract(pduLength, itemLength, pduLength))\n-              return makeUnderflowError(\"User Information item\", pduLength, itemLength);\n-            DCMNET_TRACE(\"Successfully parsed User Information\");\n+            if (cond.good())\n+            {\n+                buf += itemLength;\n+                if (!OFStandard::safeSubtract(pduLength, itemLength, pduLength))\n+                {\n+                    cond = makeUnderflowError(\"User Information item\", pduLength, itemLength);\n+                }\n+                else\n+                {\n+                    DCMNET_TRACE(\"Successfully parsed User Information\");\n+                }\n+            }\n             break;\n         default:\n             cond = parseDummy(buf, &itemLength, pduLength);\n-            if (cond.bad())\n-                return cond;\n-            buf += itemLength;\n-            if (!OFStandard::safeSubtract(pduLength, itemLength, pduLength))\n-              return makeUnderflowError(\"unknown item type\", pduLength, itemLength);\n+            if (cond.good())\n+            {\n+                buf += itemLength;\n+                if (!OFStandard::safeSubtract(pduLength, itemLength, pduLength))\n+                {\n+                    cond = makeUnderflowError(\"unknown item type\", pduLength, itemLength);\n+                }\n+            }\n             break;\n         }\n     }\n+    if (cond.bad())\n+    {\n+      destroyPresentationContextList(&assoc->presentationContextList);\n+      destroyUserInformationLists(&assoc->userInfo);\n+    }\n     return cond;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    if ((assoc->presentationContextList = LST_Create()) == NULL) return EC_MemoryExhausted;",
                "    if ((assoc->userInfo.SCUSCPRoleList = LST_Create()) == NULL) return EC_MemoryExhausted;",
                "",
                "                  return makeUnderflowError(\"Application Context item\", pduLength, itemLength);",
                "                DCMNET_TRACE(\"Successfully parsed Application Context\");",
                "            if (context == NULL) return EC_MemoryExhausted;",
                "            (void) memset(context, 0, sizeof(*context));",
                "            cond = parsePresentationContext(type, context, buf, &itemLength, pduLength);",
                "            if (cond.bad()) return cond;",
                "            buf += itemLength;",
                "            if (!OFStandard::safeSubtract(pduLength, itemLength, pduLength))",
                "              return makeUnderflowError(\"Presentation Context item\", pduLength, itemLength);",
                "            LST_Enqueue(&assoc->presentationContextList, (LST_NODE*)context);",
                "            DCMNET_TRACE(\"Successfully parsed Presentation Context\");",
                "            if (cond.bad())",
                "                return cond;",
                "            buf += itemLength;",
                "            if (!OFStandard::safeSubtract(pduLength, itemLength, pduLength))",
                "              return makeUnderflowError(\"User Information item\", pduLength, itemLength);",
                "            DCMNET_TRACE(\"Successfully parsed User Information\");",
                "            if (cond.bad())",
                "                return cond;",
                "            buf += itemLength;",
                "            if (!OFStandard::safeSubtract(pduLength, itemLength, pduLength))",
                "              return makeUnderflowError(\"unknown item type\", pduLength, itemLength);"
            ],
            "added_lines": [
                "    if ((assoc->presentationContextList = LST_Create()) == NULL) return EC_MemoryExhausted;",
                "    if ((assoc->userInfo.SCUSCPRoleList = LST_Create()) == NULL) return EC_MemoryExhausted;",
                "                {",
                "                    cond = makeUnderflowError(\"Application Context item\", pduLength, itemLength);",
                "                }",
                "                else",
                "                {",
                "                    DCMNET_TRACE(\"Successfully parsed Application Context\");",
                "                }",
                "            if (context != NULL)",
                "            {",
                "                (void) memset(context, 0, sizeof(*context));",
                "                cond = parsePresentationContext(type, context, buf, &itemLength, pduLength);",
                "                if (cond.bad())",
                "                {",
                "                    free(context);",
                "                }",
                "                else",
                "                {",
                "                    buf += itemLength;",
                "                    if (!OFStandard::safeSubtract(pduLength, itemLength, pduLength))",
                "                    {",
                "                        cond =  makeUnderflowError(\"Presentation Context item\", pduLength, itemLength);",
                "                    }",
                "                    else",
                "                    {",
                "                        LST_Enqueue(&assoc->presentationContextList, (LST_NODE*)context);",
                "                        DCMNET_TRACE(\"Successfully parsed Presentation Context\");",
                "                    }",
                "                }",
                "            }",
                "            else",
                "            {",
                "                cond = EC_MemoryExhausted;",
                "            }",
                "            if (cond.good())",
                "            {",
                "                buf += itemLength;",
                "                if (!OFStandard::safeSubtract(pduLength, itemLength, pduLength))",
                "                {",
                "                    cond = makeUnderflowError(\"User Information item\", pduLength, itemLength);",
                "                }",
                "                else",
                "                {",
                "                    DCMNET_TRACE(\"Successfully parsed User Information\");",
                "                }",
                "            }",
                "            if (cond.good())",
                "            {",
                "                buf += itemLength;",
                "                if (!OFStandard::safeSubtract(pduLength, itemLength, pduLength))",
                "                {",
                "                    cond = makeUnderflowError(\"unknown item type\", pduLength, itemLength);",
                "                }",
                "            }",
                "    if (cond.bad())",
                "    {",
                "      destroyPresentationContextList(&assoc->presentationContextList);",
                "      destroyUserInformationLists(&assoc->userInfo);",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-41687",
        "func_name": "DCMTK/dcmtk/ASC_destroyAssociation",
        "description": "DCMTK through 3.6.6 does not handle memory free properly. The program malloc a heap memory for parsing data, but does not free it when error in parsing. Sending specific requests to the dcmqrdb program incur the memory leak. An attacker can use it to launch a DoS attack.",
        "git_url": "https://github.com/DCMTK/dcmtk/commit/a9697dfeb672b0b9412c00c7d36d801e27ec85cb",
        "commit_title": "Fixed poss. NULL pointer dereference/double free.",
        "commit_text": " Thanks to Jinsheng Ba <bajinsheng@u.nus.edu> for the report and some patches.",
        "func_before": "OFCondition\nASC_destroyAssociation(T_ASC_Association ** association)\n{\n    OFCondition cond = EC_Normal;\n\n    /* don't worry if already destroyed */\n    if (association == NULL) return EC_Normal;\n    if (*association == NULL) return EC_Normal;\n\n    if ((*association)->DULassociation != NULL) {\n        ASC_dropAssociation(*association);\n    }\n\n    if ((*association)->params != NULL) {\n        cond = ASC_destroyAssociationParameters(&(*association)->params);\n        if (cond.bad()) return cond;\n    }\n\n    if ((*association)->sendPDVBuffer != NULL)\n        free((*association)->sendPDVBuffer);\n\n    free(*association);\n    *association = NULL;\n\n    return EC_Normal;\n}",
        "func": "OFCondition\nASC_destroyAssociation(T_ASC_Association ** association)\n{\n    OFCondition cond = EC_Normal;\n\n    /* don't worry if already destroyed */\n    if (association == NULL) return EC_Normal;\n    if (*association == NULL) return EC_Normal;\n\n    if ((*association)->DULassociation != NULL) {\n        ASC_dropAssociation(*association);\n    }\n\n    if ((*association)->params != NULL) {\n        ASC_destroyAssociationParameters(&(*association)->params);\n    }\n\n    if ((*association)->sendPDVBuffer != NULL)\n        free((*association)->sendPDVBuffer);\n\n    free(*association);\n    *association = NULL;\n\n    return EC_Normal;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -12,8 +12,7 @@\n     }\n \n     if ((*association)->params != NULL) {\n-        cond = ASC_destroyAssociationParameters(&(*association)->params);\n-        if (cond.bad()) return cond;\n+        ASC_destroyAssociationParameters(&(*association)->params);\n     }\n \n     if ((*association)->sendPDVBuffer != NULL)",
        "diff_line_info": {
            "deleted_lines": [
                "        cond = ASC_destroyAssociationParameters(&(*association)->params);",
                "        if (cond.bad()) return cond;"
            ],
            "added_lines": [
                "        ASC_destroyAssociationParameters(&(*association)->params);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-12865",
        "func_name": "radareorg/radare2/cmd_mount",
        "description": "In radare2 through 3.5.1, cmd_mount in libr/core/cmd_mount.c has a double free for the ms command.",
        "git_url": "https://github.com/radareorg/radare2/commit/40453029179d230cf02ffed205f2d63e33981b8f",
        "commit_title": "Fix #14334 - Double-free in ms command",
        "commit_text": "",
        "func_before": "static int cmd_mount(void *data, const char *_input) {\n\tut64 off = 0;\n\tchar *input, *oinput, *ptr, *ptr2;\n\tRList *list;\n\tRListIter *iter;\n\tRFSFile *file;\n\tRFSRoot *root;\n\tRFSPlugin *plug;\n\tRFSPartition *part;\n\tRCore *core = (RCore *)data;\n\n\tif (!strncmp (\"kdir\", _input, 4)) {\n\t\treturn cmd_mkdir (data, _input);\n\t}\n\tif (!strncmp (\"v\", _input, 1)) {\n\t\treturn cmd_mv (data, _input);\n\t}\n\tinput = oinput = strdup (_input);\n\n\tswitch (*input) {\n\tcase ' ':\n\t\tinput = (char *)r_str_trim_ro (input + 1);\n\t\tptr = strchr (input, ' ');\n\t\tif (ptr) {\n\t\t\t*ptr = 0;\n\t\t\tptr = (char *)r_str_trim_ro (ptr + 1);\n\t\t\tptr2 = strchr (ptr, ' ');\n\t\t\tif (ptr2) {\n\t\t\t\t*ptr2 = 0;\n\t\t\t\toff = r_num_math (core->num, ptr2+1);\n\t\t\t}\n\t\t\tinput = (char *)r_str_trim_ro (input);\n\t\t\tptr = (char*)r_str_trim_ro (ptr);\n\t\t\tif (!r_fs_mount (core->fs, input, ptr, off)) {\n\t\t\t\tif (!r_fs_mount (core->fs, ptr, input, off)) {\n\t\t\t\t\teprintf (\"Cannot mount %s\\n\", input);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (!(ptr = r_fs_name (core->fs, core->offset))) {\n\t\t\t\teprintf (\"Unknown filesystem type\\n\");\n\t\t\t}\n\t\t\tif (!r_fs_mount (core->fs, ptr, input, core->offset)) {\n\t\t\t\teprintf (\"Cannot mount %s\\n\", input);\n\t\t\t}\n\t\t\tfree (ptr);\n\t\t}\n\t\tbreak;\n\tcase '-':\n\t\tr_fs_umount (core->fs, input+1);\n\t\tbreak;\n\tcase 'j':\n\t\t{\n\t\t\tPJ *pj = pj_new ();\n\t\t\tpj_o (pj);\n\t\t\tpj_k (pj, \"mountpoints\");\n\t\t\tpj_a (pj);\n\t\t\tr_list_foreach (core->fs->roots, iter, root) {\n\t\t\t\tpj_o (pj);\n\t\t\t\tpj_ks (pj, \"path\", root->path);\n\t\t\t\tpj_ks (pj, \"plugin\", root->p->name);\n\t\t\t\tpj_kn (pj, \"offset\", root->delta);\n\t\t\t\tpj_end (pj);\n\t\t\t}\n\t\t\tpj_end (pj);\n//\n\t\t\tpj_k (pj, \"plugins\");\n\t\t\tpj_a (pj);\n\t\t\tr_list_foreach (core->fs->plugins, iter, plug) {\n\t\t\t\tpj_o (pj);\n\t\t\t\tpj_ks (pj, \"name\", plug->name);\n\t\t\t\tpj_ks (pj, \"description\", plug->desc);\n\t\t\t\tpj_end (pj);\n\t\t\t}\n\n\t\t\tpj_end (pj);\n\t\t\tpj_end (pj);\n\t\t\tr_cons_printf (\"%s\\n\", pj_string (pj));\n\t\t\tpj_free (pj);\n\t\t}\n\t\tbreak;\n\tcase '*':\n\t\tr_list_foreach (core->fs->roots, iter, root) {\n\t\t\tr_cons_printf (\"m %s %s 0x%\"PFMT64x\"\\n\",\n\t\t\t\troot-> path, root->p->name, root->delta);\n\t\t}\n\t\tbreak;\n\tcase '\\0':\n\t\tr_list_foreach (core->fs->roots, iter, root) {\n\t\t\tr_cons_printf (\"%s\\t0x%\"PFMT64x\"\\t%s\\n\",\n\t\t\t\troot->p->name, root->delta, root->path);\n\t\t}\n\t\tbreak;\n\tcase 'L': // \"mL\" list of plugins\n\t\tr_list_foreach (core->fs->plugins, iter, plug) {\n\t\t\tr_cons_printf (\"%10s  %s\\n\", plug->name, plug->desc);\n\t\t}\n\t\tbreak;\n\tcase 'l': // \"ml\"\n\tcase 'd': // \"md\" // should be deprecated. ls is better than dir :P\n\t\tcmd_mount_ls (core, input + 1);\n\t\tbreak;\n\tcase 'p':\n\t\tinput++;\n\t\tif (*input == ' ') {\n\t\t\tinput++;\n\t\t}\n\t\tptr = strchr (input, ' ');\n\t\tif (ptr) {\n\t\t\t*ptr = 0;\n\t\t\toff = r_num_math (core->num, ptr+1);\n\t\t}\n\t\tlist = r_fs_partitions (core->fs, input, off);\n\t\tif (list) {\n\t\t\tr_list_foreach (list, iter, part) {\n\t\t\t\tr_cons_printf (\"%d %02x 0x%010\"PFMT64x\" 0x%010\"PFMT64x\"\\n\",\n\t\t\t\t\tpart->number, part->type,\n\t\t\t\t\tpart->start, part->start+part->length);\n\t\t\t}\n\t\t\tr_list_free (list);\n\t\t} else {\n\t\t\teprintf (\"Cannot read partition\\n\");\n\t\t}\n\t\tbreak;\n\tcase 'o': //\"mo\"\n\t\tinput++;\n\t\tif (input[0]==' ') {\n\t\t\tinput++;\n\t\t}\n\t\tfile = r_fs_open (core->fs, input, false);\n\t\tif (file) {\n\t\t\tr_fs_read (core->fs, file, 0, file->size);\n\t\t\tchar *uri = r_str_newf (\"malloc://%d\", file->size);\n\t\t\tRIODesc *fd = r_io_open (core->io, uri, R_PERM_RW, 0);\n\t\t\tif (fd) {\n\t\t\t\tr_io_desc_write (fd, file->data, file->size);\n\t\t\t}\n\t\t} else {\n\t\t\teprintf (\"Cannot open file\\n\");\n\t\t}\n\t\tbreak;\n\tcase 'i':\n\t\tinput++;\n\t\tif (input[0]==' ') {\n\t\t\tinput++;\n\t\t}\n\t\tfile = r_fs_open (core->fs, input, false);\n\t\tif (file) {\n\t\t\t// XXX: dump to file or just pipe?\n\t\t\tr_fs_read (core->fs, file, 0, file->size);\n\t\t\tr_cons_printf (\"f file %d 0x%08\"PFMT64x\"\\n\", file->size, file->off);\n\t\t\tr_fs_close (core->fs, file);\n\t\t} else {\n\t\t\teprintf (\"Cannot open file\\n\");\n\t\t}\n\t\tbreak;\n\tcase 'c': // \"mc\"\n\t\tinput++;\n\t\tif (*input == ' ') {\n\t\t\tinput++;\n\t\t}\n\t\tptr = strchr (input, ' ');\n\t\tif (ptr) {\n\t\t\t*ptr++ = 0;\n\t\t} else {\n\t\t\tptr = \"./\";\n\t\t}\n\t\tfile = r_fs_open (core->fs, input, false);\n\t\tif (file) {\n\t\t\tr_fs_read (core->fs, file, 0, file->size);\n\t\t\tr_cons_memcat ((const char *)file->data, file->size);\n\t\t\tr_fs_close (core->fs, file);\n\t\t\tr_cons_memcat (\"\\n\", 1);\n\t\t} else if (!r_fs_dir_dump (core->fs, input, ptr)) {\n\t\t\teprintf (\"Cannot open file\\n\");\n\t\t}\n\t\tbreak;\n\tcase 'g': // \"mg\"\n\t\tinput++;\n\t\tif (*input == ' ') {\n\t\t\tinput++;\n\t\t}\n\t\tptr = strchr (input, ' ');\n\t\tif (ptr) {\n\t\t\t*ptr++ = 0;\n\t\t} else {\n\t\t\tptr = \"./\";\n\t\t}\n\t\tfile = r_fs_open (core->fs, input, false);\n\t\tif (file) {\n\t\t\tchar *localFile = strdup (input);\n\t\t\tchar *slash = (char *)r_str_rchr (localFile, NULL, '/');\n\t\t\tif (slash) {\n\t\t\t\tmemmove (localFile, slash + 1, strlen (slash));\n\t\t\t}\n\t\t\tr_fs_read (core->fs, file, 0, file->size);\n\t\t\tr_file_dump (localFile, file->data, file->size, false);\n\t\t\tr_fs_close (core->fs, file);\n\t\t\teprintf (\"File '%s' created.\\n\", localFile);\n\t\t\tfree (localFile);\n\t\t} else if (!r_fs_dir_dump (core->fs, input, ptr)) {\n\t\t\teprintf (\"Cannot open file\\n\");\n\t\t}\n\t\tbreak;\n\tcase 'f':\n\t\tinput++;\n\t\tswitch (*input) {\n\t\tcase '?':\n\t\t\tr_cons_printf (\n\t\t\t\"Usage: mf[no] [...]\\n\"\n\t\t\t\" mfn /foo *.c       ; search files by name in /foo path\\n\"\n\t\t\t\" mfo /foo 0x5e91    ; search files by offset in /foo path\\n\"\n\t\t\t);\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tinput++;\n\t\t\tif (*input == ' ')\n\t\t\t\tinput++;\n\t\t\tptr = strchr (input, ' ');\n\t\t\tif (ptr) {\n\t\t\t\t*ptr++ = 0;\n\t\t\t\tlist = r_fs_find_name (core->fs, input, ptr);\n\t\t\t\tr_list_foreach (list, iter, ptr) {\n\t\t\t\t\tr_str_trim_path (ptr);\n\t\t\t\t\tprintf (\"%s\\n\", ptr);\n\t\t\t\t}\n\t\t\t\t//XXX: r_list_purge (list);\n\t\t\t} else eprintf (\"Unknown store path\\n\");\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\tinput++;\n\t\t\tif (*input == ' ')\n\t\t\t\tinput++;\n\t\t\tptr = strchr (input, ' ');\n\t\t\tif (ptr) {\n\t\t\t\t*ptr++ = 0;\n\t\t\t\tut64 off = r_num_math (core->num, ptr);\n\t\t\t\tlist = r_fs_find_off (core->fs, input, off);\n\t\t\t\tr_list_foreach (list, iter, ptr) {\n\t\t\t\t\tr_str_trim_path (ptr);\n\t\t\t\t\tprintf (\"%s\\n\", ptr);\n\t\t\t\t}\n\t\t\t\t//XXX: r_list_purge (list);\n\t\t\t} else eprintf (\"Unknown store path\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 's': // \"ms\"\n\t\tif (core->http_up) {\n\t\t\tfree (oinput);\n\t\t\treturn false;\n\t\t}\n\t\tinput++;\n\t\tif (input[0] == ' ') {\n\t\t\tinput++;\n\t\t}\n\t\tr_cons_set_raw (false);\n\t\t{\n\t\t\tRFSShell shell = {\n\t\t\t\t.cwd = &cwd,\n\t\t\t\t.set_prompt = r_line_set_prompt,\n\t\t\t\t.readline = r_line_readline,\n\t\t\t\t.hist_add = r_line_hist_add\n\t\t\t};\n\t\t\tRLine *rli = r_line_singleton ();\n\t\t\tRLineCompletion c;\n\t\t\tmemcpy (&c, &rli->completion, sizeof (c));\n\t\t\tr_pvector_init (&rli->completion.args, free);  // UGLY HACK\n\t\t\trli->completion.run = ms_autocomplete;\n\t\t\trli->completion.run_user = rli->user;\n\t\t\tr_line_completion_set (&rli->completion, ms_argc, ms_argv);\n\t\t\tr_fs_shell_prompt (&shell, core->fs, input);\n\t\t\tfree (cwd);\n\t\t\tr_pvector_clear (&rli->completion.args);\n\t\t\tmemcpy (&rli->completion, &c, sizeof (c));\n\t\t}\n\t\tbreak;\n\tcase 'w':\n\t\tif (input[1] == ' ') {\n\t\t\tchar *args = r_str_trim_dup (input + 1);\n\t\t\tchar *arg = strchr (args, ' ');\n\t\t\tif (arg) {\n\t\t\t\tdata = arg + 1;\n\t\t\t} else {\n\t\t\t\tdata = \"\";\n\t\t\t\t// touch and truncate\n\t\t\t}\n\t\t\tRFSFile *f = r_fs_open (core->fs, args, true);\n\t\t\tif (f) {\n\t\t\t\tr_fs_write (core->fs, f, 0, (const ut8 *)data, strlen (data));\n\t\t\t\tr_fs_close (core->fs, f);\n\t\t\t\tr_fs_file_free (f);\n\t\t\t\tfree (args);\n\t\t\t}\n\t\t} else {\n\t\t\teprintf (\"Usage: mw [file] ([data])\\n\");\n\t\t}\n\t\tbreak;\n\tcase 'y':\n\t\teprintf (\"TODO\\n\");\n\t\tbreak;\n\tcase '?':\n\t\tr_core_cmd_help (core, help_msg_m);\n\t\tbreak;\n\t}\n\tfree (oinput);\n\treturn 0;\n}",
        "func": "static int cmd_mount(void *data, const char *_input) {\n\tut64 off = 0;\n\tchar *input, *oinput, *ptr, *ptr2;\n\tRList *list;\n\tRListIter *iter;\n\tRFSFile *file;\n\tRFSRoot *root;\n\tRFSPlugin *plug;\n\tRFSPartition *part;\n\tRCore *core = (RCore *)data;\n\n\tif (!strncmp (\"kdir\", _input, 4)) {\n\t\treturn cmd_mkdir (data, _input);\n\t}\n\tif (!strncmp (\"v\", _input, 1)) {\n\t\treturn cmd_mv (data, _input);\n\t}\n\tinput = oinput = strdup (_input);\n\n\tswitch (*input) {\n\tcase ' ':\n\t\tinput = (char *)r_str_trim_ro (input + 1);\n\t\tptr = strchr (input, ' ');\n\t\tif (ptr) {\n\t\t\t*ptr = 0;\n\t\t\tptr = (char *)r_str_trim_ro (ptr + 1);\n\t\t\tptr2 = strchr (ptr, ' ');\n\t\t\tif (ptr2) {\n\t\t\t\t*ptr2 = 0;\n\t\t\t\toff = r_num_math (core->num, ptr2+1);\n\t\t\t}\n\t\t\tinput = (char *)r_str_trim_ro (input);\n\t\t\tptr = (char*)r_str_trim_ro (ptr);\n\t\t\tif (!r_fs_mount (core->fs, input, ptr, off)) {\n\t\t\t\tif (!r_fs_mount (core->fs, ptr, input, off)) {\n\t\t\t\t\teprintf (\"Cannot mount %s\\n\", input);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (!(ptr = r_fs_name (core->fs, core->offset))) {\n\t\t\t\teprintf (\"Unknown filesystem type\\n\");\n\t\t\t}\n\t\t\tif (!r_fs_mount (core->fs, ptr, input, core->offset)) {\n\t\t\t\teprintf (\"Cannot mount %s\\n\", input);\n\t\t\t}\n\t\t\tfree (ptr);\n\t\t}\n\t\tbreak;\n\tcase '-':\n\t\tr_fs_umount (core->fs, input+1);\n\t\tbreak;\n\tcase 'j':\n\t\t{\n\t\t\tPJ *pj = pj_new ();\n\t\t\tpj_o (pj);\n\t\t\tpj_k (pj, \"mountpoints\");\n\t\t\tpj_a (pj);\n\t\t\tr_list_foreach (core->fs->roots, iter, root) {\n\t\t\t\tpj_o (pj);\n\t\t\t\tpj_ks (pj, \"path\", root->path);\n\t\t\t\tpj_ks (pj, \"plugin\", root->p->name);\n\t\t\t\tpj_kn (pj, \"offset\", root->delta);\n\t\t\t\tpj_end (pj);\n\t\t\t}\n\t\t\tpj_end (pj);\n//\n\t\t\tpj_k (pj, \"plugins\");\n\t\t\tpj_a (pj);\n\t\t\tr_list_foreach (core->fs->plugins, iter, plug) {\n\t\t\t\tpj_o (pj);\n\t\t\t\tpj_ks (pj, \"name\", plug->name);\n\t\t\t\tpj_ks (pj, \"description\", plug->desc);\n\t\t\t\tpj_end (pj);\n\t\t\t}\n\n\t\t\tpj_end (pj);\n\t\t\tpj_end (pj);\n\t\t\tr_cons_printf (\"%s\\n\", pj_string (pj));\n\t\t\tpj_free (pj);\n\t\t}\n\t\tbreak;\n\tcase '*':\n\t\tr_list_foreach (core->fs->roots, iter, root) {\n\t\t\tr_cons_printf (\"m %s %s 0x%\"PFMT64x\"\\n\",\n\t\t\t\troot-> path, root->p->name, root->delta);\n\t\t}\n\t\tbreak;\n\tcase '\\0':\n\t\tr_list_foreach (core->fs->roots, iter, root) {\n\t\t\tr_cons_printf (\"%s\\t0x%\"PFMT64x\"\\t%s\\n\",\n\t\t\t\troot->p->name, root->delta, root->path);\n\t\t}\n\t\tbreak;\n\tcase 'L': // \"mL\" list of plugins\n\t\tr_list_foreach (core->fs->plugins, iter, plug) {\n\t\t\tr_cons_printf (\"%10s  %s\\n\", plug->name, plug->desc);\n\t\t}\n\t\tbreak;\n\tcase 'l': // \"ml\"\n\tcase 'd': // \"md\" // should be deprecated. ls is better than dir :P\n\t\tcmd_mount_ls (core, input + 1);\n\t\tbreak;\n\tcase 'p':\n\t\tinput++;\n\t\tif (*input == ' ') {\n\t\t\tinput++;\n\t\t}\n\t\tptr = strchr (input, ' ');\n\t\tif (ptr) {\n\t\t\t*ptr = 0;\n\t\t\toff = r_num_math (core->num, ptr+1);\n\t\t}\n\t\tlist = r_fs_partitions (core->fs, input, off);\n\t\tif (list) {\n\t\t\tr_list_foreach (list, iter, part) {\n\t\t\t\tr_cons_printf (\"%d %02x 0x%010\"PFMT64x\" 0x%010\"PFMT64x\"\\n\",\n\t\t\t\t\tpart->number, part->type,\n\t\t\t\t\tpart->start, part->start+part->length);\n\t\t\t}\n\t\t\tr_list_free (list);\n\t\t} else {\n\t\t\teprintf (\"Cannot read partition\\n\");\n\t\t}\n\t\tbreak;\n\tcase 'o': //\"mo\"\n\t\tinput++;\n\t\tif (input[0]==' ') {\n\t\t\tinput++;\n\t\t}\n\t\tfile = r_fs_open (core->fs, input, false);\n\t\tif (file) {\n\t\t\tr_fs_read (core->fs, file, 0, file->size);\n\t\t\tchar *uri = r_str_newf (\"malloc://%d\", file->size);\n\t\t\tRIODesc *fd = r_io_open (core->io, uri, R_PERM_RW, 0);\n\t\t\tif (fd) {\n\t\t\t\tr_io_desc_write (fd, file->data, file->size);\n\t\t\t}\n\t\t} else {\n\t\t\teprintf (\"Cannot open file\\n\");\n\t\t}\n\t\tbreak;\n\tcase 'i':\n\t\tinput++;\n\t\tif (input[0]==' ') {\n\t\t\tinput++;\n\t\t}\n\t\tfile = r_fs_open (core->fs, input, false);\n\t\tif (file) {\n\t\t\t// XXX: dump to file or just pipe?\n\t\t\tr_fs_read (core->fs, file, 0, file->size);\n\t\t\tr_cons_printf (\"f file %d 0x%08\"PFMT64x\"\\n\", file->size, file->off);\n\t\t\tr_fs_close (core->fs, file);\n\t\t} else {\n\t\t\teprintf (\"Cannot open file\\n\");\n\t\t}\n\t\tbreak;\n\tcase 'c': // \"mc\"\n\t\tinput++;\n\t\tif (*input == ' ') {\n\t\t\tinput++;\n\t\t}\n\t\tptr = strchr (input, ' ');\n\t\tif (ptr) {\n\t\t\t*ptr++ = 0;\n\t\t} else {\n\t\t\tptr = \"./\";\n\t\t}\n\t\tfile = r_fs_open (core->fs, input, false);\n\t\tif (file) {\n\t\t\tr_fs_read (core->fs, file, 0, file->size);\n\t\t\tr_cons_memcat ((const char *)file->data, file->size);\n\t\t\tr_fs_close (core->fs, file);\n\t\t\tr_cons_memcat (\"\\n\", 1);\n\t\t} else if (!r_fs_dir_dump (core->fs, input, ptr)) {\n\t\t\teprintf (\"Cannot open file\\n\");\n\t\t}\n\t\tbreak;\n\tcase 'g': // \"mg\"\n\t\tinput++;\n\t\tif (*input == ' ') {\n\t\t\tinput++;\n\t\t}\n\t\tptr = strchr (input, ' ');\n\t\tif (ptr) {\n\t\t\t*ptr++ = 0;\n\t\t} else {\n\t\t\tptr = \"./\";\n\t\t}\n\t\tfile = r_fs_open (core->fs, input, false);\n\t\tif (file) {\n\t\t\tchar *localFile = strdup (input);\n\t\t\tchar *slash = (char *)r_str_rchr (localFile, NULL, '/');\n\t\t\tif (slash) {\n\t\t\t\tmemmove (localFile, slash + 1, strlen (slash));\n\t\t\t}\n\t\t\tr_fs_read (core->fs, file, 0, file->size);\n\t\t\tr_file_dump (localFile, file->data, file->size, false);\n\t\t\tr_fs_close (core->fs, file);\n\t\t\teprintf (\"File '%s' created.\\n\", localFile);\n\t\t\tfree (localFile);\n\t\t} else if (!r_fs_dir_dump (core->fs, input, ptr)) {\n\t\t\teprintf (\"Cannot open file\\n\");\n\t\t}\n\t\tbreak;\n\tcase 'f':\n\t\tinput++;\n\t\tswitch (*input) {\n\t\tcase '?':\n\t\t\tr_cons_printf (\n\t\t\t\"Usage: mf[no] [...]\\n\"\n\t\t\t\" mfn /foo *.c       ; search files by name in /foo path\\n\"\n\t\t\t\" mfo /foo 0x5e91    ; search files by offset in /foo path\\n\"\n\t\t\t);\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\tinput++;\n\t\t\tif (*input == ' ')\n\t\t\t\tinput++;\n\t\t\tptr = strchr (input, ' ');\n\t\t\tif (ptr) {\n\t\t\t\t*ptr++ = 0;\n\t\t\t\tlist = r_fs_find_name (core->fs, input, ptr);\n\t\t\t\tr_list_foreach (list, iter, ptr) {\n\t\t\t\t\tr_str_trim_path (ptr);\n\t\t\t\t\tprintf (\"%s\\n\", ptr);\n\t\t\t\t}\n\t\t\t\t//XXX: r_list_purge (list);\n\t\t\t} else eprintf (\"Unknown store path\\n\");\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\tinput++;\n\t\t\tif (*input == ' ')\n\t\t\t\tinput++;\n\t\t\tptr = strchr (input, ' ');\n\t\t\tif (ptr) {\n\t\t\t\t*ptr++ = 0;\n\t\t\t\tut64 off = r_num_math (core->num, ptr);\n\t\t\t\tlist = r_fs_find_off (core->fs, input, off);\n\t\t\t\tr_list_foreach (list, iter, ptr) {\n\t\t\t\t\tr_str_trim_path (ptr);\n\t\t\t\t\tprintf (\"%s\\n\", ptr);\n\t\t\t\t}\n\t\t\t\t//XXX: r_list_purge (list);\n\t\t\t} else eprintf (\"Unknown store path\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 's': // \"ms\"\n\t\tif (core->http_up) {\n\t\t\tfree (oinput);\n\t\t\treturn false;\n\t\t}\n\t\tinput++;\n\t\tif (input[0] == ' ') {\n\t\t\tinput++;\n\t\t}\n\t\tr_cons_set_raw (false);\n\t\t{\n\t\t\tRFSShell shell = {\n\t\t\t\t.cwd = &cwd,\n\t\t\t\t.set_prompt = r_line_set_prompt,\n\t\t\t\t.readline = r_line_readline,\n\t\t\t\t.hist_add = r_line_hist_add\n\t\t\t};\n\t\t\tRLine *rli = r_line_singleton ();\n\t\t\tRLineCompletion c;\n\t\t\tmemcpy (&c, &rli->completion, sizeof (c));\n\t\t\tr_pvector_init (&rli->completion.args, free);  // UGLY HACK\n\t\t\trli->completion.run = ms_autocomplete;\n\t\t\trli->completion.run_user = rli->user;\n\t\t\tr_line_completion_set (&rli->completion, ms_argc, ms_argv);\n\t\t\tr_fs_shell_prompt (&shell, core->fs, input);\n\t\t\tR_FREE (cwd);\n\t\t\tr_pvector_clear (&rli->completion.args);\n\t\t\tmemcpy (&rli->completion, &c, sizeof (c));\n\t\t}\n\t\tbreak;\n\tcase 'w':\n\t\tif (input[1] == ' ') {\n\t\t\tchar *args = r_str_trim_dup (input + 1);\n\t\t\tchar *arg = strchr (args, ' ');\n\t\t\tif (arg) {\n\t\t\t\tdata = arg + 1;\n\t\t\t} else {\n\t\t\t\tdata = \"\";\n\t\t\t\t// touch and truncate\n\t\t\t}\n\t\t\tRFSFile *f = r_fs_open (core->fs, args, true);\n\t\t\tif (f) {\n\t\t\t\tr_fs_write (core->fs, f, 0, (const ut8 *)data, strlen (data));\n\t\t\t\tr_fs_close (core->fs, f);\n\t\t\t\tr_fs_file_free (f);\n\t\t\t\tfree (args);\n\t\t\t}\n\t\t} else {\n\t\t\teprintf (\"Usage: mw [file] ([data])\\n\");\n\t\t}\n\t\tbreak;\n\tcase 'y':\n\t\teprintf (\"TODO\\n\");\n\t\tbreak;\n\tcase '?':\n\t\tr_core_cmd_help (core, help_msg_m);\n\t\tbreak;\n\t}\n\tfree (oinput);\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -270,7 +270,7 @@\n \t\t\trli->completion.run_user = rli->user;\n \t\t\tr_line_completion_set (&rli->completion, ms_argc, ms_argv);\n \t\t\tr_fs_shell_prompt (&shell, core->fs, input);\n-\t\t\tfree (cwd);\n+\t\t\tR_FREE (cwd);\n \t\t\tr_pvector_clear (&rli->completion.args);\n \t\t\tmemcpy (&rli->completion, &c, sizeof (c));\n \t\t}",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\tfree (cwd);"
            ],
            "added_lines": [
                "\t\t\tR_FREE (cwd);"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-20961",
        "func_name": "torvalds/linux/free_ep_req",
        "description": "In the Linux kernel before 4.16.4, a double free vulnerability in the f_midi_set_alt function of drivers/usb/gadget/function/f_midi.c in the f_midi driver may allow attackers to cause a denial of service or possibly have unspecified other impact.",
        "git_url": "https://github.com/torvalds/linux/commit/7fafcfdf6377b18b2a726ea554d6e593ba44349f",
        "commit_title": "USB: gadget: f_midi: fixing a possible double-free in f_midi",
        "commit_text": " It looks like there is a possibility of a double-free vulnerability on an error path of the f_midi_set_alt function in the f_midi driver. If the path is feasible then free_ep_req gets called twice:           req->complete = f_midi_complete;          err = usb_ep_queue(midi->out_ep, req, GFP_ATOMIC);             => ...              usb_gadget_giveback_request                =>                  f_midi_complete (CALLBACK)                    (inside f_midi_complete, for various cases of status)                    free_ep_req(ep, req); // first kfree          if (err) {                  ERROR(midi, \"%s: couldn't enqueue request: %d\\n\",                              midi->out_ep->name, err);                  free_ep_req(midi->out_ep, req); // second kfree                  return err;          }  The double-free possibility was introduced with commit ad0d1a058eac (\"usb: gadget: f_midi: fix leak on failed to enqueue out requests\").  Found by MOXCAFE tool.  Cc: stable <stable@vger.kernel.org>",
        "func_before": "static inline void free_ep_req(struct usb_ep *ep, struct usb_request *req)\n{\n\tkfree(req->buf);\n\tusb_ep_free_request(ep, req);\n}",
        "func": "static inline void free_ep_req(struct usb_ep *ep, struct usb_request *req)\n{\n\tWARN_ON(req->buf == NULL);\n\tkfree(req->buf);\n\treq->buf = NULL;\n\tusb_ep_free_request(ep, req);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,7 @@\n static inline void free_ep_req(struct usb_ep *ep, struct usb_request *req)\n {\n+\tWARN_ON(req->buf == NULL);\n \tkfree(req->buf);\n+\treq->buf = NULL;\n \tusb_ep_free_request(ep, req);\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tWARN_ON(req->buf == NULL);",
                "\treq->buf = NULL;"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-20961",
        "func_name": "torvalds/linux/f_midi_set_alt",
        "description": "In the Linux kernel before 4.16.4, a double free vulnerability in the f_midi_set_alt function of drivers/usb/gadget/function/f_midi.c in the f_midi driver may allow attackers to cause a denial of service or possibly have unspecified other impact.",
        "git_url": "https://github.com/torvalds/linux/commit/7fafcfdf6377b18b2a726ea554d6e593ba44349f",
        "commit_title": "USB: gadget: f_midi: fixing a possible double-free in f_midi",
        "commit_text": " It looks like there is a possibility of a double-free vulnerability on an error path of the f_midi_set_alt function in the f_midi driver. If the path is feasible then free_ep_req gets called twice:           req->complete = f_midi_complete;          err = usb_ep_queue(midi->out_ep, req, GFP_ATOMIC);             => ...              usb_gadget_giveback_request                =>                  f_midi_complete (CALLBACK)                    (inside f_midi_complete, for various cases of status)                    free_ep_req(ep, req); // first kfree          if (err) {                  ERROR(midi, \"%s: couldn't enqueue request: %d\\n\",                              midi->out_ep->name, err);                  free_ep_req(midi->out_ep, req); // second kfree                  return err;          }  The double-free possibility was introduced with commit ad0d1a058eac (\"usb: gadget: f_midi: fix leak on failed to enqueue out requests\").  Found by MOXCAFE tool.  Cc: stable <stable@vger.kernel.org>",
        "func_before": "static int f_midi_set_alt(struct usb_function *f, unsigned intf, unsigned alt)\n{\n\tstruct f_midi *midi = func_to_midi(f);\n\tunsigned i;\n\tint err;\n\n\t/* we only set alt for MIDIStreaming interface */\n\tif (intf != midi->ms_id)\n\t\treturn 0;\n\n\terr = f_midi_start_ep(midi, f, midi->in_ep);\n\tif (err)\n\t\treturn err;\n\n\terr = f_midi_start_ep(midi, f, midi->out_ep);\n\tif (err)\n\t\treturn err;\n\n\t/* pre-allocate write usb requests to use on f_midi_transmit. */\n\twhile (kfifo_avail(&midi->in_req_fifo)) {\n\t\tstruct usb_request *req =\n\t\t\tmidi_alloc_ep_req(midi->in_ep, midi->buflen);\n\n\t\tif (req == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\treq->length = 0;\n\t\treq->complete = f_midi_complete;\n\n\t\tkfifo_put(&midi->in_req_fifo, req);\n\t}\n\n\t/* allocate a bunch of read buffers and queue them all at once. */\n\tfor (i = 0; i < midi->qlen && err == 0; i++) {\n\t\tstruct usb_request *req =\n\t\t\tmidi_alloc_ep_req(midi->out_ep, midi->buflen);\n\n\t\tif (req == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\treq->complete = f_midi_complete;\n\t\terr = usb_ep_queue(midi->out_ep, req, GFP_ATOMIC);\n\t\tif (err) {\n\t\t\tERROR(midi, \"%s: couldn't enqueue request: %d\\n\",\n\t\t\t\t    midi->out_ep->name, err);\n\t\t\tfree_ep_req(midi->out_ep, req);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}",
        "func": "static int f_midi_set_alt(struct usb_function *f, unsigned intf, unsigned alt)\n{\n\tstruct f_midi *midi = func_to_midi(f);\n\tunsigned i;\n\tint err;\n\n\t/* we only set alt for MIDIStreaming interface */\n\tif (intf != midi->ms_id)\n\t\treturn 0;\n\n\terr = f_midi_start_ep(midi, f, midi->in_ep);\n\tif (err)\n\t\treturn err;\n\n\terr = f_midi_start_ep(midi, f, midi->out_ep);\n\tif (err)\n\t\treturn err;\n\n\t/* pre-allocate write usb requests to use on f_midi_transmit. */\n\twhile (kfifo_avail(&midi->in_req_fifo)) {\n\t\tstruct usb_request *req =\n\t\t\tmidi_alloc_ep_req(midi->in_ep, midi->buflen);\n\n\t\tif (req == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\treq->length = 0;\n\t\treq->complete = f_midi_complete;\n\n\t\tkfifo_put(&midi->in_req_fifo, req);\n\t}\n\n\t/* allocate a bunch of read buffers and queue them all at once. */\n\tfor (i = 0; i < midi->qlen && err == 0; i++) {\n\t\tstruct usb_request *req =\n\t\t\tmidi_alloc_ep_req(midi->out_ep, midi->buflen);\n\n\t\tif (req == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\treq->complete = f_midi_complete;\n\t\terr = usb_ep_queue(midi->out_ep, req, GFP_ATOMIC);\n\t\tif (err) {\n\t\t\tERROR(midi, \"%s: couldn't enqueue request: %d\\n\",\n\t\t\t\t    midi->out_ep->name, err);\n\t\t\tif (req->buf != NULL)\n\t\t\t\tfree_ep_req(midi->out_ep, req);\n\t\t\treturn err;\n\t\t}\n\t}\n\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -43,7 +43,8 @@\n \t\tif (err) {\n \t\t\tERROR(midi, \"%s: couldn't enqueue request: %d\\n\",\n \t\t\t\t    midi->out_ep->name, err);\n-\t\t\tfree_ep_req(midi->out_ep, req);\n+\t\t\tif (req->buf != NULL)\n+\t\t\t\tfree_ep_req(midi->out_ep, req);\n \t\t\treturn err;\n \t\t}\n \t}",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\tfree_ep_req(midi->out_ep, req);"
            ],
            "added_lines": [
                "\t\t\tif (req->buf != NULL)",
                "\t\t\t\tfree_ep_req(midi->out_ep, req);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-15151",
        "func_name": "adplug/Cu6mPlayer::load",
        "description": "AdPlug 2.3.1 has a double free in the Cu6mPlayer class in u6m.h.",
        "git_url": "https://github.com/adplug/adplug/commit/e8814f46ec2285a32eed47cbaea691030da67637",
        "commit_title": "Fix double free in Cu6mPlayer::~Cu6mPlayer() (issue #91)",
        "commit_text": " Leave deallocation of song_data to destructor when decompression fails, just like on success.  This fixes CVE-2019-15151.  Even though load() is apparently not supposed to be called twice (and bad things happen in many players if you do), let's also avoid leaking song_data's memory in that case. ",
        "func_before": "bool Cu6mPlayer::load(const std::string &filename, const CFileProvider &fp)\n{\n  // file validation section\n  // this section only checks a few *necessary* conditions\n  unsigned long filesize, decompressed_filesize;\n  binistream *f;\n\n  f = fp.open(filename); if(!f) return false;\n  filesize = fp.filesize(f);\n\n  if (filesize >= 6)\n    {\n      // check if the file has a valid pseudo-header\n      unsigned char pseudo_header[6];\n      f->readString((char *)pseudo_header, 6);\n      decompressed_filesize = pseudo_header[0] + (pseudo_header[1] << 8);\n\n      if (!( (pseudo_header[2]==0) && (pseudo_header[3]==0) &&\n\t     (pseudo_header[4] + ((pseudo_header[5] & 0x1)<<8) == 0x100) &&\n\t     (decompressed_filesize > (filesize-4)) ))\n        {\n\t  fp.close(f);\n\t  return(false);\n        }\n    }\n  else\n    {\n      fp.close(f);\n      return(false);\n    }\n\n  // load section\n  song_data = new unsigned char[decompressed_filesize];\n  unsigned char* compressed_song_data = new unsigned char[filesize-3];\n\n  f->seek(4);\n  f->readString((char *)compressed_song_data, filesize - 4);\n  fp.close(f);\n\n  // attempt to decompress the song data\n  // if unsuccessful, deallocate song_data[] on the spot, and return(false)\n  data_block source, destination;\n  source.size = filesize-4;\n  source.data = compressed_song_data;\n  destination.size = decompressed_filesize;\n  destination.data = song_data;\n\t\n  if (!lzw_decompress(source,destination))\n    {\n      delete[] compressed_song_data;\n      delete[] song_data;\n      return(false);\n    }\n\n  // deallocation section\n  delete[] compressed_song_data;\n\n  rewind(0);\n  return (true);\n}",
        "func": "bool Cu6mPlayer::load(const std::string &filename, const CFileProvider &fp)\n{\n  // file validation section\n  // this section only checks a few *necessary* conditions\n  unsigned long filesize, decompressed_filesize;\n  binistream *f;\n\n  f = fp.open(filename); if(!f) return false;\n  filesize = fp.filesize(f);\n\n  if (filesize >= 6)\n    {\n      // check if the file has a valid pseudo-header\n      unsigned char pseudo_header[6];\n      f->readString((char *)pseudo_header, 6);\n      decompressed_filesize = pseudo_header[0] + (pseudo_header[1] << 8);\n\n      if (!( (pseudo_header[2]==0) && (pseudo_header[3]==0) &&\n\t     (pseudo_header[4] + ((pseudo_header[5] & 0x1)<<8) == 0x100) &&\n\t     (decompressed_filesize > (filesize-4)) ))\n        {\n\t  fp.close(f);\n\t  return(false);\n        }\n    }\n  else\n    {\n      fp.close(f);\n      return(false);\n    }\n\n  // load section\n  delete[] song_data;\n  song_data = new unsigned char[decompressed_filesize];\n  unsigned char* compressed_song_data = new unsigned char[filesize-3];\n\n  f->seek(4);\n  f->readString((char *)compressed_song_data, filesize - 4);\n  fp.close(f);\n\n  // attempt to decompress the song data\n  data_block source, destination;\n  source.size = filesize-4;\n  source.data = compressed_song_data;\n  destination.size = decompressed_filesize;\n  destination.data = song_data;\n\t\n  if (!lzw_decompress(source,destination))\n    {\n      delete[] compressed_song_data;\n      return(false);\n    }\n\n  // deallocation section\n  delete[] compressed_song_data;\n\n  rewind(0);\n  return (true);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -30,6 +30,7 @@\n     }\n \n   // load section\n+  delete[] song_data;\n   song_data = new unsigned char[decompressed_filesize];\n   unsigned char* compressed_song_data = new unsigned char[filesize-3];\n \n@@ -38,7 +39,6 @@\n   fp.close(f);\n \n   // attempt to decompress the song data\n-  // if unsuccessful, deallocate song_data[] on the spot, and return(false)\n   data_block source, destination;\n   source.size = filesize-4;\n   source.data = compressed_song_data;\n@@ -48,7 +48,6 @@\n   if (!lzw_decompress(source,destination))\n     {\n       delete[] compressed_song_data;\n-      delete[] song_data;\n       return(false);\n     }\n ",
        "diff_line_info": {
            "deleted_lines": [
                "  // if unsuccessful, deallocate song_data[] on the spot, and return(false)",
                "      delete[] song_data;"
            ],
            "added_lines": [
                "  delete[] song_data;"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-15212",
        "func_name": "torvalds/linux/probe_rio",
        "description": "An issue was discovered in the Linux kernel before 5.1.8. There is a double-free caused by a malicious USB device in the drivers/usb/misc/rio500.c driver.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=3864d33943b4a76c6e64616280e98d2410b1190f",
        "commit_title": "This driver is using a global variable. It cannot handle more than",
        "commit_text": "one device at a time. The issue has been existing since the dawn of the driver.  Cc: stable <stable@vger.kernel.org> ",
        "func_before": "static int probe_rio(struct usb_interface *intf,\n\t\t     const struct usb_device_id *id)\n{\n\tstruct usb_device *dev = interface_to_usbdev(intf);\n\tstruct rio_usb_data *rio = &rio_instance;\n\tint retval;\n\n\tdev_info(&intf->dev, \"USB Rio found at address %d\\n\", dev->devnum);\n\n\tretval = usb_register_dev(intf, &usb_rio_class);\n\tif (retval) {\n\t\tdev_err(&dev->dev,\n\t\t\t\"Not able to get a minor for this device.\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\trio->rio_dev = dev;\n\n\tif (!(rio->obuf = kmalloc(OBUF_SIZE, GFP_KERNEL))) {\n\t\tdev_err(&dev->dev,\n\t\t\t\"probe_rio: Not enough memory for the output buffer\\n\");\n\t\tusb_deregister_dev(intf, &usb_rio_class);\n\t\treturn -ENOMEM;\n\t}\n\tdev_dbg(&intf->dev, \"obuf address:%p\\n\", rio->obuf);\n\n\tif (!(rio->ibuf = kmalloc(IBUF_SIZE, GFP_KERNEL))) {\n\t\tdev_err(&dev->dev,\n\t\t\t\"probe_rio: Not enough memory for the input buffer\\n\");\n\t\tusb_deregister_dev(intf, &usb_rio_class);\n\t\tkfree(rio->obuf);\n\t\treturn -ENOMEM;\n\t}\n\tdev_dbg(&intf->dev, \"ibuf address:%p\\n\", rio->ibuf);\n\n\tmutex_init(&(rio->lock));\n\n\tusb_set_intfdata (intf, rio);\n\trio->present = 1;\n\n\treturn 0;\n}",
        "func": "static int probe_rio(struct usb_interface *intf,\n\t\t     const struct usb_device_id *id)\n{\n\tstruct usb_device *dev = interface_to_usbdev(intf);\n\tstruct rio_usb_data *rio = &rio_instance;\n\tint retval = 0;\n\n\tmutex_lock(&rio500_mutex);\n\tif (rio->present) {\n\t\tdev_info(&intf->dev, \"Second USB Rio at address %d refused\\n\", dev->devnum);\n\t\tretval = -EBUSY;\n\t\tgoto bail_out;\n\t} else {\n\t\tdev_info(&intf->dev, \"USB Rio found at address %d\\n\", dev->devnum);\n\t}\n\n\tretval = usb_register_dev(intf, &usb_rio_class);\n\tif (retval) {\n\t\tdev_err(&dev->dev,\n\t\t\t\"Not able to get a minor for this device.\\n\");\n\t\tretval = -ENOMEM;\n\t\tgoto bail_out;\n\t}\n\n\trio->rio_dev = dev;\n\n\tif (!(rio->obuf = kmalloc(OBUF_SIZE, GFP_KERNEL))) {\n\t\tdev_err(&dev->dev,\n\t\t\t\"probe_rio: Not enough memory for the output buffer\\n\");\n\t\tusb_deregister_dev(intf, &usb_rio_class);\n\t\tretval = -ENOMEM;\n\t\tgoto bail_out;\n\t}\n\tdev_dbg(&intf->dev, \"obuf address:%p\\n\", rio->obuf);\n\n\tif (!(rio->ibuf = kmalloc(IBUF_SIZE, GFP_KERNEL))) {\n\t\tdev_err(&dev->dev,\n\t\t\t\"probe_rio: Not enough memory for the input buffer\\n\");\n\t\tusb_deregister_dev(intf, &usb_rio_class);\n\t\tkfree(rio->obuf);\n\t\tretval = -ENOMEM;\n\t\tgoto bail_out;\n\t}\n\tdev_dbg(&intf->dev, \"ibuf address:%p\\n\", rio->ibuf);\n\n\tmutex_init(&(rio->lock));\n\n\tusb_set_intfdata (intf, rio);\n\trio->present = 1;\nbail_out:\n\tmutex_unlock(&rio500_mutex);\n\n\treturn retval;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,15 +3,23 @@\n {\n \tstruct usb_device *dev = interface_to_usbdev(intf);\n \tstruct rio_usb_data *rio = &rio_instance;\n-\tint retval;\n+\tint retval = 0;\n \n-\tdev_info(&intf->dev, \"USB Rio found at address %d\\n\", dev->devnum);\n+\tmutex_lock(&rio500_mutex);\n+\tif (rio->present) {\n+\t\tdev_info(&intf->dev, \"Second USB Rio at address %d refused\\n\", dev->devnum);\n+\t\tretval = -EBUSY;\n+\t\tgoto bail_out;\n+\t} else {\n+\t\tdev_info(&intf->dev, \"USB Rio found at address %d\\n\", dev->devnum);\n+\t}\n \n \tretval = usb_register_dev(intf, &usb_rio_class);\n \tif (retval) {\n \t\tdev_err(&dev->dev,\n \t\t\t\"Not able to get a minor for this device.\\n\");\n-\t\treturn -ENOMEM;\n+\t\tretval = -ENOMEM;\n+\t\tgoto bail_out;\n \t}\n \n \trio->rio_dev = dev;\n@@ -20,7 +28,8 @@\n \t\tdev_err(&dev->dev,\n \t\t\t\"probe_rio: Not enough memory for the output buffer\\n\");\n \t\tusb_deregister_dev(intf, &usb_rio_class);\n-\t\treturn -ENOMEM;\n+\t\tretval = -ENOMEM;\n+\t\tgoto bail_out;\n \t}\n \tdev_dbg(&intf->dev, \"obuf address:%p\\n\", rio->obuf);\n \n@@ -29,7 +38,8 @@\n \t\t\t\"probe_rio: Not enough memory for the input buffer\\n\");\n \t\tusb_deregister_dev(intf, &usb_rio_class);\n \t\tkfree(rio->obuf);\n-\t\treturn -ENOMEM;\n+\t\tretval = -ENOMEM;\n+\t\tgoto bail_out;\n \t}\n \tdev_dbg(&intf->dev, \"ibuf address:%p\\n\", rio->ibuf);\n \n@@ -37,6 +47,8 @@\n \n \tusb_set_intfdata (intf, rio);\n \trio->present = 1;\n+bail_out:\n+\tmutex_unlock(&rio500_mutex);\n \n-\treturn 0;\n+\treturn retval;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tint retval;",
                "\tdev_info(&intf->dev, \"USB Rio found at address %d\\n\", dev->devnum);",
                "\t\treturn -ENOMEM;",
                "\t\treturn -ENOMEM;",
                "\t\treturn -ENOMEM;",
                "\treturn 0;"
            ],
            "added_lines": [
                "\tint retval = 0;",
                "\tmutex_lock(&rio500_mutex);",
                "\tif (rio->present) {",
                "\t\tdev_info(&intf->dev, \"Second USB Rio at address %d refused\\n\", dev->devnum);",
                "\t\tretval = -EBUSY;",
                "\t\tgoto bail_out;",
                "\t} else {",
                "\t\tdev_info(&intf->dev, \"USB Rio found at address %d\\n\", dev->devnum);",
                "\t}",
                "\t\tretval = -ENOMEM;",
                "\t\tgoto bail_out;",
                "\t\tretval = -ENOMEM;",
                "\t\tgoto bail_out;",
                "\t\tretval = -ENOMEM;",
                "\t\tgoto bail_out;",
                "bail_out:",
                "\tmutex_unlock(&rio500_mutex);",
                "\treturn retval;"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-18594",
        "func_name": "nmap/do_session_handshake",
        "description": "nse_libssh2.cc in Nmap 7.70 is subject to a denial of service condition due to a double free when an SSH connection fails, as demonstrated by a leading \\n character to ssh-brute.nse or ssh-auth-methods.nse.",
        "git_url": "https://github.com/nmap/nmap/commit/350bbe0597d37ad67abe5fef8fba984707b4e9ad",
        "commit_title": "Avoid a crash (double-free) when SSH connection fails",
        "commit_text": "",
        "func_before": "static int do_session_handshake (lua_State *L, int status, lua_KContext ctx) {\n    int rc;\n    struct ssh_userdata *sshu = NULL;\n\n    assert(lua_gettop(L) == 4);\n    sshu = (struct ssh_userdata *) nseU_checkudata(L, 3, SSH2_UDATA, \"ssh2\");\n\n    while ((rc = libssh2_session_handshake(sshu->session, sshu->sp[0])) == LIBSSH2_ERROR_EAGAIN) {\n        luaL_getmetafield(L, 3, \"filter\");\n        lua_pushvalue(L, 3);\n\n        assert(lua_status(L) == LUA_OK);\n        lua_callk(L, 1, 0, 0, do_session_handshake);\n    }\n\n    if (rc) {\n        libssh2_session_free(sshu->session);\n        return luaL_error(L, \"Unable to complete libssh2 handshake.\");\n    }\n\n    // lua_pushvalue(L, 3);\n    lua_settop(L, 3);\n\n    return 1;\n}",
        "func": "static int do_session_handshake (lua_State *L, int status, lua_KContext ctx) {\n    int rc;\n    struct ssh_userdata *sshu = NULL;\n\n    assert(lua_gettop(L) == 4);\n    sshu = (struct ssh_userdata *) nseU_checkudata(L, 3, SSH2_UDATA, \"ssh2\");\n\n    while ((rc = libssh2_session_handshake(sshu->session, sshu->sp[0])) == LIBSSH2_ERROR_EAGAIN) {\n        luaL_getmetafield(L, 3, \"filter\");\n        lua_pushvalue(L, 3);\n\n        assert(lua_status(L) == LUA_OK);\n        lua_callk(L, 1, 0, 0, do_session_handshake);\n    }\n\n    if (rc) {\n        libssh2_session_free(sshu->session);\n        sshu->session = NULL;\n        return luaL_error(L, \"Unable to complete libssh2 handshake.\");\n    }\n\n    // lua_pushvalue(L, 3);\n    lua_settop(L, 3);\n\n    return 1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -15,6 +15,7 @@\n \n     if (rc) {\n         libssh2_session_free(sshu->session);\n+        sshu->session = NULL;\n         return luaL_error(L, \"Unable to complete libssh2 handshake.\");\n     }\n ",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "        sshu->session = NULL;"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-18595",
        "func_name": "torvalds/linux/allocate_trace_buffer",
        "description": "An issue was discovered in the Linux kernel before 4.14.11. A double free may be caused by the function allocate_trace_buffer in the file kernel/trace/trace.c.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=4397f04575c44e1440ec2e49b6302785c95fd2f8",
        "commit_title": "Jing Xia and Chunyan Zhang reported that on failing to allocate part of the",
        "commit_text": "tracing buffer, memory is freed, but the pointers that point to them are not initialized back to NULL, and later paths may try to free the freed memory again. Jing and Chunyan fixed one of the locations that does this, but missed a spot.  Link: http://lkml.kernel.org/r/20171226071253.8968-1-chunyan.zhang@spreadtrum.com  Cc: stable@vger.kernel.org ",
        "func_before": "static int\nallocate_trace_buffer(struct trace_array *tr, struct trace_buffer *buf, int size)\n{\n\tenum ring_buffer_flags rb_flags;\n\n\trb_flags = tr->trace_flags & TRACE_ITER_OVERWRITE ? RB_FL_OVERWRITE : 0;\n\n\tbuf->tr = tr;\n\n\tbuf->buffer = ring_buffer_alloc(size, rb_flags);\n\tif (!buf->buffer)\n\t\treturn -ENOMEM;\n\n\tbuf->data = alloc_percpu(struct trace_array_cpu);\n\tif (!buf->data) {\n\t\tring_buffer_free(buf->buffer);\n\t\treturn -ENOMEM;\n\t}\n\n\t/* Allocate the first page for all buffers */\n\tset_buffer_entries(&tr->trace_buffer,\n\t\t\t   ring_buffer_size(tr->trace_buffer.buffer, 0));\n\n\treturn 0;\n}",
        "func": "static int\nallocate_trace_buffer(struct trace_array *tr, struct trace_buffer *buf, int size)\n{\n\tenum ring_buffer_flags rb_flags;\n\n\trb_flags = tr->trace_flags & TRACE_ITER_OVERWRITE ? RB_FL_OVERWRITE : 0;\n\n\tbuf->tr = tr;\n\n\tbuf->buffer = ring_buffer_alloc(size, rb_flags);\n\tif (!buf->buffer)\n\t\treturn -ENOMEM;\n\n\tbuf->data = alloc_percpu(struct trace_array_cpu);\n\tif (!buf->data) {\n\t\tring_buffer_free(buf->buffer);\n\t\tbuf->buffer = NULL;\n\t\treturn -ENOMEM;\n\t}\n\n\t/* Allocate the first page for all buffers */\n\tset_buffer_entries(&tr->trace_buffer,\n\t\t\t   ring_buffer_size(tr->trace_buffer.buffer, 0));\n\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -14,6 +14,7 @@\n \tbuf->data = alloc_percpu(struct trace_array_cpu);\n \tif (!buf->data) {\n \t\tring_buffer_free(buf->buffer);\n+\t\tbuf->buffer = NULL;\n \t\treturn -ENOMEM;\n \t}\n ",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\tbuf->buffer = NULL;"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-11932",
        "func_name": "koral--/android-gif-drawable/DDGifSlurp",
        "description": "A double free vulnerability in the DDGifSlurp function in decoding.c in the android-gif-drawable library before version 1.2.18, as used in WhatsApp for Android before version 2.19.244 and many other Android applications, allows remote attackers to execute arbitrary code or cause a denial of service when the library is used to parse a specially crafted GIF image.",
        "git_url": "https://github.com/koral--/android-gif-drawable/commit/4944c92761e0a14f04868cbcf4f4e86fd4b7a4a9",
        "commit_title": "Do not realloc array if new raster size is 0.",
        "commit_text": " if realloc() is called with 0 size it may return NULL and this will be incorrectly handled as not enough memory and (also) rasterBits will be freed by realloc but we will not update it.",
        "func_before": "void DDGifSlurp(GifInfo *info, bool decode, bool exitAfterFrame) {\n\tGifRecordType RecordType;\n\tGifByteType *ExtData;\n\tint ExtFunction;\n\tGifFileType *gifFilePtr;\n\tgifFilePtr = info->gifFilePtr;\n\tuint_fast32_t lastAllocatedGCBIndex = 0;\n\tdo {\n\t\tif (DGifGetRecordType(gifFilePtr, &RecordType) == GIF_ERROR) {\n\t\t\tbreak;\n\t\t}\n\t\tbool isInitialPass = !decode && !exitAfterFrame;\n\t\tswitch (RecordType) {\n\t\t\tcase IMAGE_DESC_RECORD_TYPE:\n\n\t\t\t\tif (DGifGetImageDesc(gifFilePtr, isInitialPass) == GIF_ERROR) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (isInitialPass) {\n\t\t\t\t\tint_fast32_t widthOverflow = gifFilePtr->Image.Width - gifFilePtr->SWidth;\n\t\t\t\t\tint_fast32_t heightOverflow = gifFilePtr->Image.Height - gifFilePtr->SHeight;\n\t\t\t\t\tif (widthOverflow > 0 || heightOverflow > 0) {\n\t\t\t\t\t\tgifFilePtr->SWidth += widthOverflow;\n\t\t\t\t\t\tgifFilePtr->SHeight += heightOverflow;\n\t\t\t\t\t}\n\t\t\t\t\tSavedImage *sp = &gifFilePtr->SavedImages[gifFilePtr->ImageCount - 1];\n\t\t\t\t\tint_fast32_t topOverflow = gifFilePtr->Image.Top + gifFilePtr->Image.Height - gifFilePtr->SHeight;\n\t\t\t\t\tif (topOverflow > 0) {\n\t\t\t\t\t\tsp->ImageDesc.Top -= topOverflow;\n\t\t\t\t\t}\n\n\t\t\t\t\tint_fast32_t leftOverflow = gifFilePtr->Image.Left + gifFilePtr->Image.Width - gifFilePtr->SWidth;\n\t\t\t\t\tif (leftOverflow > 0) {\n\t\t\t\t\t\tsp->ImageDesc.Left -= leftOverflow;\n\t\t\t\t\t}\n\t\t\t\t\tif (!updateGCB(info, &lastAllocatedGCBIndex)) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (decode) {\n\t\t\t\t\tint_fast32_t widthOverflow = gifFilePtr->Image.Width - info->originalWidth;\n\t\t\t\t\tint_fast32_t heightOverflow = gifFilePtr->Image.Height - info->originalHeight;\n\t\t\t\t\tconst uint_fast32_t newRasterSize = gifFilePtr->Image.Width * gifFilePtr->Image.Height;\n\t\t\t\t\tif (newRasterSize > info->rasterSize || widthOverflow > 0 || heightOverflow > 0) {\n\t\t\t\t\t\tvoid *tmpRasterBits = reallocarray(info->rasterBits, newRasterSize, sizeof(GifPixelType));\n\t\t\t\t\t\tif (tmpRasterBits == NULL) {\n\t\t\t\t\t\t\tgifFilePtr->Error = D_GIF_ERR_NOT_ENOUGH_MEM;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tinfo->rasterBits = tmpRasterBits;\n\t\t\t\t\t\tinfo->rasterSize = newRasterSize;\n\t\t\t\t\t}\n\t\t\t\t\tif (gifFilePtr->Image.Interlace) {\n\t\t\t\t\t\tuint_fast16_t i, j;\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * The way an interlaced image should be read -\n\t\t\t\t\t\t * offsets and jumps...\n\t\t\t\t\t\t */\n\t\t\t\t\t\tuint_fast8_t InterlacedOffset[] = {0, 4, 2, 1};\n\t\t\t\t\t\tuint_fast8_t InterlacedJumps[] = {8, 8, 4, 2};\n\t\t\t\t\t\t/* Need to perform 4 passes on the image */\n\t\t\t\t\t\tfor (i = 0; i < 4; i++)\n\t\t\t\t\t\t\tfor (j = InterlacedOffset[i]; j < gifFilePtr->Image.Height; j += InterlacedJumps[i]) {\n\t\t\t\t\t\t\t\tif (DGifGetLine(gifFilePtr, info->rasterBits + j * gifFilePtr->Image.Width, gifFilePtr->Image.Width) == GIF_ERROR)\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (DGifGetLine(gifFilePtr, info->rasterBits, gifFilePtr->Image.Width * gifFilePtr->Image.Height) == GIF_ERROR) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (info->sampleSize > 1) {\n\t\t\t\t\t\tunsigned char *dst = info->rasterBits;\n\t\t\t\t\t\tunsigned char *src = info->rasterBits;\n\t\t\t\t\t\tunsigned char *const srcEndImage = info->rasterBits + gifFilePtr->Image.Width * gifFilePtr->Image.Height;\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\tunsigned char *srcNextLineStart = src + gifFilePtr->Image.Width * info->sampleSize;\n\t\t\t\t\t\t\tunsigned char *const srcEndLine = src + gifFilePtr->Image.Width;\n\t\t\t\t\t\t\tunsigned char *dstEndLine = dst + gifFilePtr->Image.Width / info->sampleSize;\n\t\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\t\t*dst = *src;\n\t\t\t\t\t\t\t\tdst++;\n\t\t\t\t\t\t\t\tsrc += info->sampleSize;\n\t\t\t\t\t\t\t} while (src < srcEndLine);\n\t\t\t\t\t\t\tdst = dstEndLine;\n\t\t\t\t\t\t\tsrc = srcNextLineStart;\n\t\t\t\t\t\t} while (src < srcEndImage);\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t} else {\n\t\t\t\t\tdo {\n\t\t\t\t\t\tif (DGifGetCodeNext(gifFilePtr, &ExtData) == GIF_ERROR) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t} while (ExtData != NULL);\n\t\t\t\t\tif (exitAfterFrame) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase EXTENSION_RECORD_TYPE:\n\t\t\t\tif (DGifGetExtension(gifFilePtr, &ExtFunction, &ExtData) == GIF_ERROR) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (isInitialPass) {\n\t\t\t\t\tupdateGCB(info, &lastAllocatedGCBIndex);\n\t\t\t\t\tif (readExtensions(ExtFunction, ExtData, info) == GIF_ERROR) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twhile (ExtData != NULL) {\n\t\t\t\t\tif (DGifGetExtensionNext(gifFilePtr, &ExtData) == GIF_ERROR) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (isInitialPass && readExtensions(ExtFunction, ExtData, info) == GIF_ERROR) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase TERMINATE_RECORD_TYPE:\n\t\t\t\tbreak;\n\n\t\t\tdefault: /* Should be trapped by DGifGetRecordType */\n\t\t\t\tbreak;\n\t\t}\n\t} while (RecordType != TERMINATE_RECORD_TYPE);\n\n\tinfo->rewindFunction(info);\n}",
        "func": "void DDGifSlurp(GifInfo *info, bool decode, bool exitAfterFrame) {\n\tGifRecordType RecordType;\n\tGifByteType *ExtData;\n\tint ExtFunction;\n\tGifFileType *gifFilePtr;\n\tgifFilePtr = info->gifFilePtr;\n\tuint_fast32_t lastAllocatedGCBIndex = 0;\n\tdo {\n\t\tif (DGifGetRecordType(gifFilePtr, &RecordType) == GIF_ERROR) {\n\t\t\tbreak;\n\t\t}\n\t\tbool isInitialPass = !decode && !exitAfterFrame;\n\t\tswitch (RecordType) {\n\t\t\tcase IMAGE_DESC_RECORD_TYPE:\n\n\t\t\t\tif (DGifGetImageDesc(gifFilePtr, isInitialPass) == GIF_ERROR) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (isInitialPass) {\n\t\t\t\t\tint_fast32_t widthOverflow = gifFilePtr->Image.Width - gifFilePtr->SWidth;\n\t\t\t\t\tint_fast32_t heightOverflow = gifFilePtr->Image.Height - gifFilePtr->SHeight;\n\t\t\t\t\tif (widthOverflow > 0 || heightOverflow > 0) {\n\t\t\t\t\t\tgifFilePtr->SWidth += widthOverflow;\n\t\t\t\t\t\tgifFilePtr->SHeight += heightOverflow;\n\t\t\t\t\t}\n\t\t\t\t\tSavedImage *sp = &gifFilePtr->SavedImages[gifFilePtr->ImageCount - 1];\n\t\t\t\t\tint_fast32_t topOverflow = gifFilePtr->Image.Top + gifFilePtr->Image.Height - gifFilePtr->SHeight;\n\t\t\t\t\tif (topOverflow > 0) {\n\t\t\t\t\t\tsp->ImageDesc.Top -= topOverflow;\n\t\t\t\t\t}\n\n\t\t\t\t\tint_fast32_t leftOverflow = gifFilePtr->Image.Left + gifFilePtr->Image.Width - gifFilePtr->SWidth;\n\t\t\t\t\tif (leftOverflow > 0) {\n\t\t\t\t\t\tsp->ImageDesc.Left -= leftOverflow;\n\t\t\t\t\t}\n\t\t\t\t\tif (!updateGCB(info, &lastAllocatedGCBIndex)) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (decode) {\n\t\t\t\t\tconst uint_fast32_t newRasterSize = gifFilePtr->Image.Width * gifFilePtr->Image.Height;\n\t\t\t\t\tif (newRasterSize == 0) {\n\t\t\t\t\t\tfree(info->rasterBits);\n\t\t\t\t\t\tinfo->rasterBits = NULL;\n\t\t\t\t\t\tinfo->rasterSize = newRasterSize;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tconst int_fast32_t widthOverflow = gifFilePtr->Image.Width - info->originalWidth;\n\t\t\t\t\tconst int_fast32_t heightOverflow = gifFilePtr->Image.Height - info->originalHeight;\n\t\t\t\t\tif (newRasterSize > info->rasterSize || widthOverflow > 0 || heightOverflow > 0) {\n\t\t\t\t\t\tvoid *tmpRasterBits = reallocarray(info->rasterBits, newRasterSize, sizeof(GifPixelType));\n\t\t\t\t\t\tif (tmpRasterBits == NULL) {\n\t\t\t\t\t\t\tgifFilePtr->Error = D_GIF_ERR_NOT_ENOUGH_MEM;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tinfo->rasterBits = tmpRasterBits;\n\t\t\t\t\t\tinfo->rasterSize = newRasterSize;\n\t\t\t\t\t}\n\t\t\t\t\tif (gifFilePtr->Image.Interlace) {\n\t\t\t\t\t\tuint_fast16_t i, j;\n\t\t\t\t\t\t/*\n\t\t\t\t\t\t * The way an interlaced image should be read -\n\t\t\t\t\t\t * offsets and jumps...\n\t\t\t\t\t\t */\n\t\t\t\t\t\tuint_fast8_t InterlacedOffset[] = {0, 4, 2, 1};\n\t\t\t\t\t\tuint_fast8_t InterlacedJumps[] = {8, 8, 4, 2};\n\t\t\t\t\t\t/* Need to perform 4 passes on the image */\n\t\t\t\t\t\tfor (i = 0; i < 4; i++)\n\t\t\t\t\t\t\tfor (j = InterlacedOffset[i]; j < gifFilePtr->Image.Height; j += InterlacedJumps[i]) {\n\t\t\t\t\t\t\t\tif (DGifGetLine(gifFilePtr, info->rasterBits + j * gifFilePtr->Image.Width, gifFilePtr->Image.Width) == GIF_ERROR)\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (DGifGetLine(gifFilePtr, info->rasterBits, gifFilePtr->Image.Width * gifFilePtr->Image.Height) == GIF_ERROR) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (info->sampleSize > 1) {\n\t\t\t\t\t\tunsigned char *dst = info->rasterBits;\n\t\t\t\t\t\tunsigned char *src = info->rasterBits;\n\t\t\t\t\t\tunsigned char *const srcEndImage = info->rasterBits + gifFilePtr->Image.Width * gifFilePtr->Image.Height;\n\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\tunsigned char *srcNextLineStart = src + gifFilePtr->Image.Width * info->sampleSize;\n\t\t\t\t\t\t\tunsigned char *const srcEndLine = src + gifFilePtr->Image.Width;\n\t\t\t\t\t\t\tunsigned char *dstEndLine = dst + gifFilePtr->Image.Width / info->sampleSize;\n\t\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\t\t*dst = *src;\n\t\t\t\t\t\t\t\tdst++;\n\t\t\t\t\t\t\t\tsrc += info->sampleSize;\n\t\t\t\t\t\t\t} while (src < srcEndLine);\n\t\t\t\t\t\t\tdst = dstEndLine;\n\t\t\t\t\t\t\tsrc = srcNextLineStart;\n\t\t\t\t\t\t} while (src < srcEndImage);\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t} else {\n\t\t\t\t\tdo {\n\t\t\t\t\t\tif (DGifGetCodeNext(gifFilePtr, &ExtData) == GIF_ERROR) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t} while (ExtData != NULL);\n\t\t\t\t\tif (exitAfterFrame) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase EXTENSION_RECORD_TYPE:\n\t\t\t\tif (DGifGetExtension(gifFilePtr, &ExtFunction, &ExtData) == GIF_ERROR) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (isInitialPass) {\n\t\t\t\t\tupdateGCB(info, &lastAllocatedGCBIndex);\n\t\t\t\t\tif (readExtensions(ExtFunction, ExtData, info) == GIF_ERROR) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twhile (ExtData != NULL) {\n\t\t\t\t\tif (DGifGetExtensionNext(gifFilePtr, &ExtData) == GIF_ERROR) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (isInitialPass && readExtensions(ExtFunction, ExtData, info) == GIF_ERROR) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase TERMINATE_RECORD_TYPE:\n\t\t\t\tbreak;\n\n\t\t\tdefault: /* Should be trapped by DGifGetRecordType */\n\t\t\t\tbreak;\n\t\t}\n\t} while (RecordType != TERMINATE_RECORD_TYPE);\n\n\tinfo->rewindFunction(info);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -40,9 +40,15 @@\n \t\t\t\t}\n \n \t\t\t\tif (decode) {\n-\t\t\t\t\tint_fast32_t widthOverflow = gifFilePtr->Image.Width - info->originalWidth;\n-\t\t\t\t\tint_fast32_t heightOverflow = gifFilePtr->Image.Height - info->originalHeight;\n \t\t\t\t\tconst uint_fast32_t newRasterSize = gifFilePtr->Image.Width * gifFilePtr->Image.Height;\n+\t\t\t\t\tif (newRasterSize == 0) {\n+\t\t\t\t\t\tfree(info->rasterBits);\n+\t\t\t\t\t\tinfo->rasterBits = NULL;\n+\t\t\t\t\t\tinfo->rasterSize = newRasterSize;\n+\t\t\t\t\t\treturn;\n+\t\t\t\t\t}\n+\t\t\t\t\tconst int_fast32_t widthOverflow = gifFilePtr->Image.Width - info->originalWidth;\n+\t\t\t\t\tconst int_fast32_t heightOverflow = gifFilePtr->Image.Height - info->originalHeight;\n \t\t\t\t\tif (newRasterSize > info->rasterSize || widthOverflow > 0 || heightOverflow > 0) {\n \t\t\t\t\t\tvoid *tmpRasterBits = reallocarray(info->rasterBits, newRasterSize, sizeof(GifPixelType));\n \t\t\t\t\t\tif (tmpRasterBits == NULL) {",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\t\t\tint_fast32_t widthOverflow = gifFilePtr->Image.Width - info->originalWidth;",
                "\t\t\t\t\tint_fast32_t heightOverflow = gifFilePtr->Image.Height - info->originalHeight;"
            ],
            "added_lines": [
                "\t\t\t\t\tif (newRasterSize == 0) {",
                "\t\t\t\t\t\tfree(info->rasterBits);",
                "\t\t\t\t\t\tinfo->rasterBits = NULL;",
                "\t\t\t\t\t\tinfo->rasterSize = newRasterSize;",
                "\t\t\t\t\t\treturn;",
                "\t\t\t\t\t}",
                "\t\t\t\t\tconst int_fast32_t widthOverflow = gifFilePtr->Image.Width - info->originalWidth;",
                "\t\t\t\t\tconst int_fast32_t heightOverflow = gifFilePtr->Image.Height - info->originalHeight;"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-17545",
        "func_name": "OSGeo/gdal/OGRExpatRealloc",
        "description": "GDAL through 3.0.1 has a poolDestroy double free in OGRExpatRealloc in ogr/ogr_expat.cpp when the 10MB threshold is exceeded.",
        "git_url": "https://github.com/OSGeo/gdal/commit/148115fcc40f1651a5d15fa34c9a8c528e7147bb",
        "commit_title": "OGRExpatRealloc(): fix double-free when size to allocate is above the default 10MB threshold. Fixes https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=16178. Credit to OSS Fuzz",
        "commit_text": "",
        "func_before": "static void* OGRExpatRealloc( void *ptr, size_t size )\n{\n    if( CanAlloc(size) )\n        return realloc(ptr, size);\n\n    free(ptr);\n    return nullptr;\n}",
        "func": "static void* OGRExpatRealloc( void *ptr, size_t size )\n{\n    if( CanAlloc(size) )\n        return realloc(ptr, size);\n\n    return nullptr;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,6 +3,5 @@\n     if( CanAlloc(size) )\n         return realloc(ptr, size);\n \n-    free(ptr);\n     return nullptr;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    free(ptr);"
            ],
            "added_lines": []
        }
    },
    {
        "cve_id": "CVE-2017-6353",
        "func_name": "torvalds/linux/sctp_wait_for_sndbuf",
        "description": "net/sctp/socket.c in the Linux kernel through 4.10.1 does not properly restrict association peel-off operations during certain wait states, which allows local users to cause a denial of service (invalid unlock and double free) via a multithreaded application.  NOTE: this vulnerability exists because of an incorrect fix for CVE-2017-5986.",
        "git_url": "https://github.com/torvalds/linux/commit/dfcb9f4f99f1e9a49e43398a7bfbf56927544af1",
        "commit_title": "sctp: deny peeloff operation on asocs with threads sleeping on it",
        "commit_text": " commit 2dcab5984841 (\"sctp: avoid BUG_ON on sctp_wait_for_sndbuf\") attempted to avoid a BUG_ON call when the association being used for a sendmsg() is blocked waiting for more sndbuf and another thread did a peeloff operation on such asoc, moving it to another socket.  As Ben Hutchings noticed, then in such case it would return without locking back the socket and would cause two unlocks in a row.  Further analysis also revealed that it could allow a double free if the application managed to peeloff the asoc that is created during the sendmsg call, because then sctp_sendmsg() would try to free the asoc that was created only for that call.  This patch takes another approach. It will deny the peeloff operation if there is a thread sleeping on the asoc, so this situation doesn't exist anymore. This avoids the issues described above and also honors the syscalls that are already being handled (it can be multiple sendmsg calls).  Joint work with Xin Long.  Cc: Alexander Popov <alex.popov@linux.com> Cc: Ben Hutchings <ben@decadent.org.uk>",
        "func_before": "static int sctp_wait_for_sndbuf(struct sctp_association *asoc, long *timeo_p,\n\t\t\t\tsize_t msg_len)\n{\n\tstruct sock *sk = asoc->base.sk;\n\tint err = 0;\n\tlong current_timeo = *timeo_p;\n\tDEFINE_WAIT(wait);\n\n\tpr_debug(\"%s: asoc:%p, timeo:%ld, msg_len:%zu\\n\", __func__, asoc,\n\t\t *timeo_p, msg_len);\n\n\t/* Increment the association's refcnt.  */\n\tsctp_association_hold(asoc);\n\n\t/* Wait on the association specific sndbuf space. */\n\tfor (;;) {\n\t\tprepare_to_wait_exclusive(&asoc->wait, &wait,\n\t\t\t\t\t  TASK_INTERRUPTIBLE);\n\t\tif (!*timeo_p)\n\t\t\tgoto do_nonblock;\n\t\tif (sk->sk_err || asoc->state >= SCTP_STATE_SHUTDOWN_PENDING ||\n\t\t    asoc->base.dead)\n\t\t\tgoto do_error;\n\t\tif (signal_pending(current))\n\t\t\tgoto do_interrupted;\n\t\tif (msg_len <= sctp_wspace(asoc))\n\t\t\tbreak;\n\n\t\t/* Let another process have a go.  Since we are going\n\t\t * to sleep anyway.\n\t\t */\n\t\trelease_sock(sk);\n\t\tcurrent_timeo = schedule_timeout(current_timeo);\n\t\tif (sk != asoc->base.sk)\n\t\t\tgoto do_error;\n\t\tlock_sock(sk);\n\n\t\t*timeo_p = current_timeo;\n\t}\n\nout:\n\tfinish_wait(&asoc->wait, &wait);\n\n\t/* Release the association's refcnt.  */\n\tsctp_association_put(asoc);\n\n\treturn err;\n\ndo_error:\n\terr = -EPIPE;\n\tgoto out;\n\ndo_interrupted:\n\terr = sock_intr_errno(*timeo_p);\n\tgoto out;\n\ndo_nonblock:\n\terr = -EAGAIN;\n\tgoto out;\n}",
        "func": "static int sctp_wait_for_sndbuf(struct sctp_association *asoc, long *timeo_p,\n\t\t\t\tsize_t msg_len)\n{\n\tstruct sock *sk = asoc->base.sk;\n\tint err = 0;\n\tlong current_timeo = *timeo_p;\n\tDEFINE_WAIT(wait);\n\n\tpr_debug(\"%s: asoc:%p, timeo:%ld, msg_len:%zu\\n\", __func__, asoc,\n\t\t *timeo_p, msg_len);\n\n\t/* Increment the association's refcnt.  */\n\tsctp_association_hold(asoc);\n\n\t/* Wait on the association specific sndbuf space. */\n\tfor (;;) {\n\t\tprepare_to_wait_exclusive(&asoc->wait, &wait,\n\t\t\t\t\t  TASK_INTERRUPTIBLE);\n\t\tif (!*timeo_p)\n\t\t\tgoto do_nonblock;\n\t\tif (sk->sk_err || asoc->state >= SCTP_STATE_SHUTDOWN_PENDING ||\n\t\t    asoc->base.dead)\n\t\t\tgoto do_error;\n\t\tif (signal_pending(current))\n\t\t\tgoto do_interrupted;\n\t\tif (msg_len <= sctp_wspace(asoc))\n\t\t\tbreak;\n\n\t\t/* Let another process have a go.  Since we are going\n\t\t * to sleep anyway.\n\t\t */\n\t\trelease_sock(sk);\n\t\tcurrent_timeo = schedule_timeout(current_timeo);\n\t\tlock_sock(sk);\n\n\t\t*timeo_p = current_timeo;\n\t}\n\nout:\n\tfinish_wait(&asoc->wait, &wait);\n\n\t/* Release the association's refcnt.  */\n\tsctp_association_put(asoc);\n\n\treturn err;\n\ndo_error:\n\terr = -EPIPE;\n\tgoto out;\n\ndo_interrupted:\n\terr = sock_intr_errno(*timeo_p);\n\tgoto out;\n\ndo_nonblock:\n\terr = -EAGAIN;\n\tgoto out;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -31,8 +31,6 @@\n \t\t */\n \t\trelease_sock(sk);\n \t\tcurrent_timeo = schedule_timeout(current_timeo);\n-\t\tif (sk != asoc->base.sk)\n-\t\t\tgoto do_error;\n \t\tlock_sock(sk);\n \n \t\t*timeo_p = current_timeo;",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tif (sk != asoc->base.sk)",
                "\t\t\tgoto do_error;"
            ],
            "added_lines": []
        }
    },
    {
        "cve_id": "CVE-2017-6353",
        "func_name": "torvalds/linux/sctp_do_peeloff",
        "description": "net/sctp/socket.c in the Linux kernel through 4.10.1 does not properly restrict association peel-off operations during certain wait states, which allows local users to cause a denial of service (invalid unlock and double free) via a multithreaded application.  NOTE: this vulnerability exists because of an incorrect fix for CVE-2017-5986.",
        "git_url": "https://github.com/torvalds/linux/commit/dfcb9f4f99f1e9a49e43398a7bfbf56927544af1",
        "commit_title": "sctp: deny peeloff operation on asocs with threads sleeping on it",
        "commit_text": " commit 2dcab5984841 (\"sctp: avoid BUG_ON on sctp_wait_for_sndbuf\") attempted to avoid a BUG_ON call when the association being used for a sendmsg() is blocked waiting for more sndbuf and another thread did a peeloff operation on such asoc, moving it to another socket.  As Ben Hutchings noticed, then in such case it would return without locking back the socket and would cause two unlocks in a row.  Further analysis also revealed that it could allow a double free if the application managed to peeloff the asoc that is created during the sendmsg call, because then sctp_sendmsg() would try to free the asoc that was created only for that call.  This patch takes another approach. It will deny the peeloff operation if there is a thread sleeping on the asoc, so this situation doesn't exist anymore. This avoids the issues described above and also honors the syscalls that are already being handled (it can be multiple sendmsg calls).  Joint work with Xin Long.  Cc: Alexander Popov <alex.popov@linux.com> Cc: Ben Hutchings <ben@decadent.org.uk>",
        "func_before": "int sctp_do_peeloff(struct sock *sk, sctp_assoc_t id, struct socket **sockp)\n{\n\tstruct sctp_association *asoc = sctp_id2assoc(sk, id);\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tstruct socket *sock;\n\tint err = 0;\n\n\tif (!asoc)\n\t\treturn -EINVAL;\n\n\t/* An association cannot be branched off from an already peeled-off\n\t * socket, nor is this supported for tcp style sockets.\n\t */\n\tif (!sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\t/* Create a new socket.  */\n\terr = sock_create(sk->sk_family, SOCK_SEQPACKET, IPPROTO_SCTP, &sock);\n\tif (err < 0)\n\t\treturn err;\n\n\tsctp_copy_sock(sock->sk, sk, asoc);\n\n\t/* Make peeled-off sockets more like 1-1 accepted sockets.\n\t * Set the daddr and initialize id to something more random\n\t */\n\tsp->pf->to_sk_daddr(&asoc->peer.primary_addr, sk);\n\n\t/* Populate the fields of the newsk from the oldsk and migrate the\n\t * asoc to the newsk.\n\t */\n\tsctp_sock_migrate(sk, sock->sk, asoc, SCTP_SOCKET_UDP_HIGH_BANDWIDTH);\n\n\t*sockp = sock;\n\n\treturn err;\n}",
        "func": "int sctp_do_peeloff(struct sock *sk, sctp_assoc_t id, struct socket **sockp)\n{\n\tstruct sctp_association *asoc = sctp_id2assoc(sk, id);\n\tstruct sctp_sock *sp = sctp_sk(sk);\n\tstruct socket *sock;\n\tint err = 0;\n\n\tif (!asoc)\n\t\treturn -EINVAL;\n\n\t/* If there is a thread waiting on more sndbuf space for\n\t * sending on this asoc, it cannot be peeled.\n\t */\n\tif (waitqueue_active(&asoc->wait))\n\t\treturn -EBUSY;\n\n\t/* An association cannot be branched off from an already peeled-off\n\t * socket, nor is this supported for tcp style sockets.\n\t */\n\tif (!sctp_style(sk, UDP))\n\t\treturn -EINVAL;\n\n\t/* Create a new socket.  */\n\terr = sock_create(sk->sk_family, SOCK_SEQPACKET, IPPROTO_SCTP, &sock);\n\tif (err < 0)\n\t\treturn err;\n\n\tsctp_copy_sock(sock->sk, sk, asoc);\n\n\t/* Make peeled-off sockets more like 1-1 accepted sockets.\n\t * Set the daddr and initialize id to something more random\n\t */\n\tsp->pf->to_sk_daddr(&asoc->peer.primary_addr, sk);\n\n\t/* Populate the fields of the newsk from the oldsk and migrate the\n\t * asoc to the newsk.\n\t */\n\tsctp_sock_migrate(sk, sock->sk, asoc, SCTP_SOCKET_UDP_HIGH_BANDWIDTH);\n\n\t*sockp = sock;\n\n\treturn err;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -7,6 +7,12 @@\n \n \tif (!asoc)\n \t\treturn -EINVAL;\n+\n+\t/* If there is a thread waiting on more sndbuf space for\n+\t * sending on this asoc, it cannot be peeled.\n+\t */\n+\tif (waitqueue_active(&asoc->wait))\n+\t\treturn -EBUSY;\n \n \t/* An association cannot be branched off from an already peeled-off\n \t * socket, nor is this supported for tcp style sockets.",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "\t/* If there is a thread waiting on more sndbuf space for",
                "\t * sending on this asoc, it cannot be peeled.",
                "\t */",
                "\tif (waitqueue_active(&asoc->wait))",
                "\t\treturn -EBUSY;"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-27794",
        "func_name": "radareorg/radare2/r_core_fini",
        "description": "A double free issue was discovered in radare2 in cmd_info.c:cmd_info(). Successful exploitation could lead to modification of unexpected memory locations and potentially causing a crash.",
        "git_url": "https://github.com/radareorg/radare2/commit/cb8b683758edddae2d2f62e8e63a738c39f92683",
        "commit_title": "Fix #16303 - c->table_query double free (#16318)",
        "commit_text": "",
        "func_before": "R_API void r_core_fini(RCore *c) {\n\tif (!c) {\n\t\treturn;\n\t}\n\tr_core_task_break_all (&c->tasks);\n\tr_core_task_join (&c->tasks, NULL, -1);\n\tr_core_wait (c);\n\t/* TODO: it leaks as shit */\n\t//update_sdb (c);\n\t// avoid double free\n\tr_list_free (c->ropchain);\n\tr_event_free (c->ev);\n\tfree (c->cmdlog);\n\tfree (c->lastsearch);\n\tR_FREE (c->cons->pager);\n\tfree (c->cmdqueue);\n\tfree (c->lastcmd);\n\tfree (c->stkcmd);\n\tr_list_free (c->visual.tabs);\n\tfree (c->block);\n\tr_core_autocomplete_free (c->autocomplete);\n\n\tr_list_free (c->gadgets);\n\tr_list_free (c->undos);\n\tr_num_free (c->num);\n\t// TODO: sync or not? sdb_sync (c->sdb);\n\t// TODO: sync all dbs?\n\t//r_core_file_free (c->file);\n\t//c->file = NULL;\n\tfree (c->table_query);\n\tr_list_free (c->files);\n\tr_list_free (c->watchers);\n\tr_list_free (c->scriptstack);\n\tr_core_task_scheduler_fini (&c->tasks);\n\tc->rcmd = r_cmd_free (c->rcmd);\n\tr_list_free (c->cmd_descriptors);\n\tc->anal = r_anal_free (c->anal);\n\tr_asm_free (c->assembler);\n\tc->assembler = NULL;\n\tc->print = r_print_free (c->print);\n\tc->bin = (r_bin_free (c->bin), NULL);\n\tc->lang = (r_lang_free (c->lang), NULL);\n\tc->dbg = (r_debug_free (c->dbg), NULL);\n\tr_io_free (c->io);\n\tr_config_free (c->config);\n\t/* after r_config_free, the value of I.teefile is trashed */\n\t/* rconfig doesnt knows how to deinitialize vars, so we\n\tshould probably need to add a r_config_free_payload callback */\n\tr_cons_free ();\n\tr_cons_singleton ()->teefile = NULL; // HACK\n\tr_search_free (c->search);\n\tr_flag_free (c->flags);\n\tr_fs_free (c->fs);\n\tr_egg_free (c->egg);\n\tr_lib_free (c->lib);\n\tr_buf_free (c->yank_buf);\n\tr_agraph_free (c->graph);\n\tfree (c->asmqjmps);\n\tsdb_free (c->sdb);\n\tr_core_log_free (c->log);\n\tr_parse_free (c->parser);\n\tfree (c->times);\n}",
        "func": "R_API void r_core_fini(RCore *c) {\n\tif (!c) {\n\t\treturn;\n\t}\n\tr_core_task_break_all (&c->tasks);\n\tr_core_task_join (&c->tasks, NULL, -1);\n\tr_core_wait (c);\n\t/* TODO: it leaks as shit */\n\t//update_sdb (c);\n\t// avoid double free\n\tr_list_free (c->ropchain);\n\tr_event_free (c->ev);\n\tfree (c->cmdlog);\n\tfree (c->lastsearch);\n\tR_FREE (c->cons->pager);\n\tfree (c->cmdqueue);\n\tfree (c->lastcmd);\n\tfree (c->stkcmd);\n\tr_list_free (c->visual.tabs);\n\tfree (c->block);\n\tr_core_autocomplete_free (c->autocomplete);\n\n\tr_list_free (c->gadgets);\n\tr_list_free (c->undos);\n\tr_num_free (c->num);\n\t// TODO: sync or not? sdb_sync (c->sdb);\n\t// TODO: sync all dbs?\n\t//r_core_file_free (c->file);\n\t//c->file = NULL;\n\tR_FREE (c->table_query);\n\tr_list_free (c->files);\n\tr_list_free (c->watchers);\n\tr_list_free (c->scriptstack);\n\tr_core_task_scheduler_fini (&c->tasks);\n\tc->rcmd = r_cmd_free (c->rcmd);\n\tr_list_free (c->cmd_descriptors);\n\tc->anal = r_anal_free (c->anal);\n\tr_asm_free (c->assembler);\n\tc->assembler = NULL;\n\tc->print = r_print_free (c->print);\n\tc->bin = (r_bin_free (c->bin), NULL);\n\tc->lang = (r_lang_free (c->lang), NULL);\n\tc->dbg = (r_debug_free (c->dbg), NULL);\n\tr_io_free (c->io);\n\tr_config_free (c->config);\n\t/* after r_config_free, the value of I.teefile is trashed */\n\t/* rconfig doesnt knows how to deinitialize vars, so we\n\tshould probably need to add a r_config_free_payload callback */\n\tr_cons_free ();\n\tr_cons_singleton ()->teefile = NULL; // HACK\n\tr_search_free (c->search);\n\tr_flag_free (c->flags);\n\tr_fs_free (c->fs);\n\tr_egg_free (c->egg);\n\tr_lib_free (c->lib);\n\tr_buf_free (c->yank_buf);\n\tr_agraph_free (c->graph);\n\tfree (c->asmqjmps);\n\tsdb_free (c->sdb);\n\tr_core_log_free (c->log);\n\tr_parse_free (c->parser);\n\tfree (c->times);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -27,7 +27,7 @@\n \t// TODO: sync all dbs?\n \t//r_core_file_free (c->file);\n \t//c->file = NULL;\n-\tfree (c->table_query);\n+\tR_FREE (c->table_query);\n \tr_list_free (c->files);\n \tr_list_free (c->watchers);\n \tr_list_free (c->scriptstack);",
        "diff_line_info": {
            "deleted_lines": [
                "\tfree (c->table_query);"
            ],
            "added_lines": [
                "\tR_FREE (c->table_query);"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-2953",
        "func_name": "libtiff/process_command_opts",
        "description": "LibTIFF 4.4.0 has an out-of-bounds read in extractImageSection in tools/tiffcrop.c:6905, allowing attackers to cause a denial-of-service via a crafted tiff file. For users that compile libtiff from sources, the fix is available with commit 48d6ece8.",
        "git_url": "https://gitlab.com/libtiff/libtiff/-/commit/8fe3735942ea1d90d8cef843b55b3efe8ab6feaf",
        "commit_title": "According to Richard Nolde https://gitlab.com/libtiff/libtiff/-/issues/401#note_877637400 the tiffcrop option -S is also mutually exclusive to the other crop options (-X|-Y), -Z and -z.",
        "commit_text": " This is now checked and ends tiffcrop if those arguments are not mutually exclusive.  This MR will fix the following tiffcrop issues: #349, #414, #422, #423, #424 ",
        "func_before": "void  process_command_opts (int argc, char *argv[], char *mp, char *mode, uint32_t *dirnum,\n                            uint16_t *defconfig, uint16_t *deffillorder, uint32_t *deftilewidth,\n                            uint32_t *deftilelength, uint32_t *defrowsperstrip,\n                            struct crop_mask *crop_data, struct pagedef *page,\n                            struct dump_opts *dump,\n                            unsigned int     *imagelist, unsigned int   *image_count )\n    {\n    int   c, good_args = 0;\n    char *opt_offset   = NULL;    /* Position in string of value sought */\n    char *opt_ptr      = NULL;    /* Pointer to next token in option set */\n    char *sep          = NULL;    /* Pointer to a token separator */\n    unsigned int  i, j, start, end;\n#if !HAVE_DECL_OPTARG\n    extern int   optind;\n    extern char* optarg;\n#endif\n\n    *mp++ = 'w';\n    *mp = '\\0';\n    while ((c = getopt(argc, argv,\n       \"ac:d:e:f:hik:l:m:p:r:stvw:z:BCD:E:F:H:I:J:K:LMN:O:P:R:S:U:V:X:Y:Z:\")) != -1)\n      {\n    good_args++;\n    switch (c) {\n      case 'a': mode[0] = 'a';\t/* append to output */\n\t\tbreak;\n      case 'c':\tif (!processCompressOptions(optarg)) /* compression scheme */\n\t\t  {\n\t\t  TIFFError (\"Unknown compression option\", \"%s\", optarg);\n                  TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                  exit (EXIT_FAILURE);\n                  }\n\t\tbreak;\n      case 'd':\tstart = strtoul(optarg, NULL, 0); /* initial IFD offset */\n\t        if (start == 0)\n                  {\n\t\t  TIFFError (\"\",\"Directory offset must be greater than zero\");\n\t\t  TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                  exit (EXIT_FAILURE);\n\t\t  }\n\t        *dirnum = start - 1;\n\t\tbreak;\n      case 'e': switch (tolower((int) optarg[0])) /* image export modes*/\n                  {\n\t\t  case 'c': crop_data->exp_mode = ONE_FILE_COMPOSITE;\n \t\t            crop_data->img_mode = COMPOSITE_IMAGES;\n\t\t            break; /* Composite */\n\t\t  case 'd': crop_data->exp_mode = ONE_FILE_SEPARATED;\n \t\t            crop_data->img_mode = SEPARATED_IMAGES;\n\t\t            break; /* Divided */\n\t\t  case 'i': crop_data->exp_mode = FILE_PER_IMAGE_COMPOSITE;\n \t\t            crop_data->img_mode = COMPOSITE_IMAGES;\n\t\t            break; /* Image */\n\t\t  case 'm': crop_data->exp_mode = FILE_PER_IMAGE_SEPARATED;\n \t\t            crop_data->img_mode = SEPARATED_IMAGES;\n\t\t            break; /* Multiple */\n\t\t  case 's': crop_data->exp_mode = FILE_PER_SELECTION;\n \t\t            crop_data->img_mode = SEPARATED_IMAGES;\n\t\t            break; /* Sections */\n\t\t  default:  TIFFError (\"Unknown export mode\",\"%s\", optarg);\n                            TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                            exit (EXIT_FAILURE);\n                  }\n\t        break;\n      case 'f':\tif (streq(optarg, \"lsb2msb\"))\t   /* fill order */\n\t\t  *deffillorder = FILLORDER_LSB2MSB;\n\t\telse if (streq(optarg, \"msb2lsb\"))\n\t\t  *deffillorder = FILLORDER_MSB2LSB;\n\t\telse\n\t\t  {\n\t\t  TIFFError (\"Unknown fill order\", \"%s\", optarg);\n                  TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                  exit (EXIT_FAILURE);\n                  }\n\t\tbreak;\n      case 'h':\tusage(EXIT_SUCCESS);\n\t\tbreak;\n      case 'i':\tignore = TRUE;\t\t/* ignore errors */\n\t\tbreak;\n      case 'k':\tmaxMalloc = (tmsize_t)strtoul(optarg, NULL, 0) << 20;\n\t\tbreak;\n      case 'l':\touttiled = TRUE;\t /* tile length */\n\t\t*deftilelength = atoi(optarg);\n\t\tbreak;\n      case 'p': /* planar configuration */\n\t\tif (streq(optarg, \"separate\"))\n\t\t  *defconfig = PLANARCONFIG_SEPARATE;\n\t\telse if (streq(optarg, \"contig\"))\n\t\t  *defconfig = PLANARCONFIG_CONTIG;\n\t\telse\n\t\t  {\n\t\t  TIFFError (\"Unknown planar configuration\", \"%s\", optarg);\n                  TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                  exit (EXIT_FAILURE);\n                  }\n\t\tbreak;\n      case 'r':\t/* rows/strip */\n\t\t*defrowsperstrip = atol(optarg);\n\t\tbreak;\n      case 's':\t/* generate stripped output */\n\t\touttiled = FALSE;\n\t\tbreak;\n      case 't':\t/* generate tiled output */\n\t\touttiled = TRUE;\n\t\tbreak;\n      case 'v': printf(\"Library Release: %s\\n\", TIFFGetVersion());\n                printf(\"Tiffcrop version: %s, last updated: %s\\n\",\n\t\t\t   tiffcrop_version_id, tiffcrop_rev_date);\n\t        printf(\"Tiffcp code: Copyright (c) 1988-1997 Sam Leffler\\n\");\n\t\tprintf(\"           : Copyright (c) 1991-1997 Silicon Graphics, Inc\\n\");\n                printf(\"Tiffcrop additions: Copyright (c) 2007-2010 Richard Nolde\\n\");\n\t        exit (EXIT_SUCCESS);\n\t\tbreak;\n      case 'w':\t/* tile width */\n\t\touttiled = TRUE;\n\t\t*deftilewidth = atoi(optarg);\n\t\tbreak;\n      case 'z': /* regions of an image specified as x1,y1,x2,y2:x3,y3,x4,y4 etc */\n\t        crop_data->crop_mode |= CROP_REGIONS;\n\t\tfor (i = 0, opt_ptr = strtok (optarg, \":\");\n                   ((opt_ptr != NULL) &&  (i < MAX_REGIONS));\n                    (opt_ptr = strtok (NULL, \":\")), i++)\n                    {\n\t\t    crop_data->regions++;\n                    if (sscanf(opt_ptr, \"%lf,%lf,%lf,%lf\",\n\t\t\t       &crop_data->corners[i].X1, &crop_data->corners[i].Y1,\n\t\t\t       &crop_data->corners[i].X2, &crop_data->corners[i].Y2) != 4)\n                      {\n                      TIFFError (\"Unable to parse coordinates for region\", \"%u %s\", i, optarg);\n\t\t      TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                      exit (EXIT_FAILURE);\n\t\t      }\n                    }\n                /*  check for remaining elements over MAX_REGIONS */\n                if ((opt_ptr != NULL) && (i >= MAX_REGIONS))\n                  {\n\t\t  TIFFError (\"Region list exceeds limit of\", \"%d regions %s\", MAX_REGIONS, optarg);\n\t\t  TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                  exit (EXIT_FAILURE);;\n                  }\n\t\tbreak;\n      /* options for file open modes */\n      case 'B': *mp++ = 'b'; *mp = '\\0';\n\t\tbreak;\n      case 'L': *mp++ = 'l'; *mp = '\\0';\n\t\tbreak;\n      case 'M': *mp++ = 'm'; *mp = '\\0';\n\t\tbreak;\n      case 'C': *mp++ = 'c'; *mp = '\\0';\n\t\tbreak;\n      /* options for Debugging / data dump */\n      case 'D': for (i = 0, opt_ptr = strtok (optarg, \",\");\n                    (opt_ptr != NULL);\n                    (opt_ptr = strtok (NULL, \",\")), i++)\n                    {\n\t\t    opt_offset = strpbrk(opt_ptr, \":=\");\n                    if (opt_offset == NULL)\n                      {\n                      TIFFError(\"Invalid dump option\", \"%s\", optarg);\n                      TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                      exit (EXIT_FAILURE);\n\t\t      }\n                      \n                    *opt_offset = '\\0';\n                    /* convert option to lowercase */\n                    end = strlen (opt_ptr);\n                    for (i = 0; i < end; i++)\n                      *(opt_ptr + i) = tolower((int) *(opt_ptr + i));\n                    /* Look for dump format specification */\n                    if (strncmp(opt_ptr, \"for\", 3) == 0)\n                      {\n\t\t      /* convert value to lowercase */\n                      end = strlen (opt_offset + 1);\n                      for (i = 1; i <= end; i++)\n                        *(opt_offset + i) = tolower((int) *(opt_offset + i));\n                      /* check dump format value */\n\t\t      if (strncmp (opt_offset + 1, \"txt\", 3) == 0)\n                        {\n                        dump->format = DUMP_TEXT;\n                        strcpy (dump->mode, \"w\");\n                        }\n                      else\n                        {\n\t\t        if (strncmp(opt_offset + 1, \"raw\", 3) == 0)\n                          {\n                          dump->format = DUMP_RAW;\n                          strcpy (dump->mode, \"wb\");\n                          }\n                        else\n                          {\n                          TIFFError(\"parse_command_opts\", \"Unknown dump format %s\", opt_offset + 1);\n                          TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                          exit (EXIT_FAILURE);\n\t\t          }\n\t\t\t}\n                      }\n\t\t    else\n                      { /* Look for dump level specification */\n                      if (strncmp (opt_ptr, \"lev\", 3) == 0)\n                        dump->level = atoi(opt_offset + 1);\n                        /* Look for input data dump file name */\n                      if (strncmp (opt_ptr, \"in\", 2) == 0)\n\t\t        {\n                        strncpy (dump->infilename, opt_offset + 1, PATH_MAX - 20);\n                        dump->infilename[PATH_MAX - 20] = '\\0';\n                        }\n                        /* Look for output data dump file name */\n                      if (strncmp (opt_ptr, \"out\", 3) == 0)\n\t\t\t{\n                        strncpy (dump->outfilename, opt_offset + 1, PATH_MAX - 20);\n                        dump->outfilename[PATH_MAX - 20] = '\\0';\n                        }\n                      if (strncmp (opt_ptr, \"deb\", 3) == 0)\n\t\t\tdump->debug = atoi(opt_offset + 1);\n\t\t      }\n                    }\n\t        if ((strlen(dump->infilename)) || (strlen(dump->outfilename)))\n                  {\n\t\t  if (dump->level == 1)\n                    TIFFError(\"\",\"Defaulting to dump level 1, no data.\");\n\t          if (dump->format == DUMP_NONE)\n                    {\n\t\t    TIFFError(\"\", \"You must specify a dump format for dump files\");\n\t\t    TIFFError (\"For valid options type\", \"tiffcrop -h\");\n\t\t    exit (EXIT_FAILURE);\n\t\t    }\n                  }\n\t        break;\n\n      /* image manipulation routine options */\n      case 'm': /* margins to exclude from selection, uppercase M was already used */\n\t\t/* order of values must be TOP, LEFT, BOTTOM, RIGHT */\n\t\tcrop_data->crop_mode |= CROP_MARGINS;\n                for (i = 0, opt_ptr = strtok (optarg, \",:\");\n                    ((opt_ptr != NULL) &&  (i < 4));\n                     (opt_ptr = strtok (NULL, \",:\")), i++)\n                    {\n\t\t    crop_data->margins[i] = atof(opt_ptr);\n                    }\n\t\tbreak;\n      case 'E':\t/* edge reference */\n\t\tswitch (tolower((int) optarg[0]))\n                  {\n\t\t  case 't': crop_data->edge_ref = EDGE_TOP;\n                            break;\n                  case 'b': crop_data->edge_ref = EDGE_BOTTOM;\n                             break;\n                  case 'l': crop_data->edge_ref = EDGE_LEFT;\n                            break;\n                  case 'r': crop_data->edge_ref = EDGE_RIGHT;\n                            break;\n\t\t  default:  TIFFError (\"Edge reference must be top, bottom, left, or right\", \"%s\", optarg);\n\t\t\t    TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                            exit (EXIT_FAILURE);\n\t\t  }\n\t\tbreak;\n      case 'F': /* flip eg mirror image or cropped segment, M was already used */\n\t\tcrop_data->crop_mode |= CROP_MIRROR;\n\t\tswitch (tolower((int) optarg[0]))\n                  {\n\t\t  case  'h': crop_data->mirror = MIRROR_HORIZ;\n                             break;\n                  case  'v': crop_data->mirror = MIRROR_VERT;\n                             break;\n                  case  'b': crop_data->mirror = MIRROR_BOTH;\n                             break;\n\t\t  default:   TIFFError (\"Flip mode must be horiz, vert, or both\", \"%s\", optarg);\n\t\t\t     TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                             exit (EXIT_FAILURE);\n\t\t  }\n\t\tbreak;\n      case 'H': /* set horizontal resolution to new value */\n\t\tpage->hres = atof (optarg);\n                page->mode |= PAGE_MODE_RESOLUTION;\n\t\tbreak;\n      case 'I': /* invert the color space, eg black to white */\n\t\tcrop_data->crop_mode |= CROP_INVERT;\n                /* The PHOTOMETIC_INTERPRETATION tag may be updated */\n                if (streq(optarg, \"black\"))\n                  {\n\t\t  crop_data->photometric = PHOTOMETRIC_MINISBLACK;\n\t\t  continue;\n                  }\n                if (streq(optarg, \"white\"))\n                  {\n\t\t  crop_data->photometric = PHOTOMETRIC_MINISWHITE;\n                  continue;\n                  }\n                if (streq(optarg, \"data\")) \n                  {\n\t\t  crop_data->photometric = INVERT_DATA_ONLY;\n                  continue;\n                  }\n                if (streq(optarg, \"both\"))\n                  {\n\t\t  crop_data->photometric = INVERT_DATA_AND_TAG;\n                  continue;\n                  }\n\n\t\tTIFFError(\"Missing or unknown option for inverting PHOTOMETRIC_INTERPRETATION\", \"%s\", optarg);\n\t\tTIFFError (\"For valid options type\", \"tiffcrop -h\");\n                exit (EXIT_FAILURE);\n\t\tbreak;\n      case 'J': /* horizontal margin for sectioned output pages */\n\t\tpage->hmargin = atof(optarg);\n                page->mode |= PAGE_MODE_MARGINS;\n\t\tbreak;\n      case 'K': /* vertical margin for sectioned output pages*/\n                page->vmargin = atof(optarg);\n                page->mode |= PAGE_MODE_MARGINS;\n\t\tbreak;\n      case 'N':\t/* list of images to process */\n                for (i = 0, opt_ptr = strtok (optarg, \",\");\n                    ((opt_ptr != NULL) &&  (i < MAX_IMAGES));\n                     (opt_ptr = strtok (NULL, \",\")))\n                     { /* We do not know how many images are in file yet \n\t\t\t* so we build a list to include the maximum allowed\n                        * and follow it until we hit the end of the file.\n                        * Image count is not accurate for odd, even, last\n                        * so page numbers won't be valid either.\n                        */\n\t\t     if (streq(opt_ptr, \"odd\"))\n                       {\n\t\t       for (j = 1; j <= MAX_IMAGES; j += 2)\n\t\t\t imagelist[i++] = j;\n                       *image_count = (MAX_IMAGES - 1) / 2;\n                       break;\n\t\t       }\n\t\t     else\n                       {\n\t\t       if (streq(opt_ptr, \"even\"))\n                         {\n\t\t\t for (j = 2; j <= MAX_IMAGES; j += 2)\n\t\t\t   imagelist[i++] = j;\n                         *image_count = MAX_IMAGES / 2;\n                         break;\n\t\t\t }\n\t\t       else\n                         {\n\t\t\t if (streq(opt_ptr, \"last\"))\n\t\t\t   imagelist[i++] = MAX_IMAGES;\n\t\t\t else  /* single value between commas */\n\t\t\t   {\n\t\t\t   sep = strpbrk(opt_ptr, \":-\");\n\t\t\t   if (!sep)\n\t\t\t     imagelist[i++] = atoi(opt_ptr);\n                           else\n                             {\n\t\t\t     *sep = '\\0';\n                             start = atoi (opt_ptr);\n                             if (!strcmp((sep + 1), \"last\"))\n\t\t\t       end = MAX_IMAGES;\n                             else\n                               end = atoi (sep + 1);\n                             for (j = start; j <= end && j - start + i < MAX_IMAGES; j++)\n\t\t\t       imagelist[i++] = j;\n\t\t\t     }\n\t\t\t   }\n\t\t\t }\n\t\t      }\n\t\t    }\n                *image_count = i;\n\t\tbreak;\n      case 'O': /* page orientation */ \n\t\tswitch (tolower((int) optarg[0]))\n                  {\n\t\t  case  'a': page->orient = ORIENTATION_AUTO;\n                             break;\n\t\t  case  'p': page->orient = ORIENTATION_PORTRAIT;\n                             break;\n\t\t  case  'l': page->orient = ORIENTATION_LANDSCAPE;\n                             break;\n\t\t  default:  TIFFError (\"Orientation must be portrait, landscape, or auto.\", \"%s\", optarg);\n\t\t\t    TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                            exit (EXIT_FAILURE);\n\t\t  }\n\t\tbreak;\n      case 'P': /* page size selection */ \n\t        if (sscanf(optarg, \"%lfx%lf\", &page->width, &page->length) == 2)\n                  {\n                  strcpy (page->name, \"Custom\"); \n                  page->mode |= PAGE_MODE_PAPERSIZE;\n                  break;\n                  }\n                if (get_page_geometry (optarg, page))\n                  {\n\t\t  if (!strcmp(optarg, \"list\"))\n                    {\n\t\t    TIFFError(\"\", \"Name            Width   Length (in inches)\");\n                    for (i = 0; i < MAX_PAPERNAMES - 1; i++)\n                      TIFFError (\"\", \"%-15.15s %5.2f   %5.2f\", \n\t\t\t       PaperTable[i].name, PaperTable[i].width, \n                               PaperTable[i].length);\n\t\t    exit (EXIT_FAILURE);\n                    }\n     \n\t\t  TIFFError (\"Invalid paper size\", \"%s\", optarg);\n                  TIFFError (\"\", \"Select one of:\");\n\t\t  TIFFError(\"\", \"Name            Width   Length (in inches)\");\n                  for (i = 0; i < MAX_PAPERNAMES - 1; i++)\n                    TIFFError (\"\", \"%-15.15s %5.2f   %5.2f\", \n\t\t\t       PaperTable[i].name, PaperTable[i].width, \n                               PaperTable[i].length);\n\t\t  exit (EXIT_FAILURE);\n\t\t  }\n\t\telse\n                  {\n                  page->mode |= PAGE_MODE_PAPERSIZE;\n\t\t  }\n\t\tbreak;\n      case 'R': /* rotate image or cropped segment */\n\t\tcrop_data->crop_mode |= CROP_ROTATE;\n\t\tswitch (strtoul(optarg, NULL, 0))\n                  {\n\t\t  case  90:  crop_data->rotation = (uint16_t)90;\n                             break;\n                  case  180: crop_data->rotation = (uint16_t)180;\n                             break;\n                  case  270: crop_data->rotation = (uint16_t)270;\n                             break;\n\t\t  default:   TIFFError (\"Rotation must be 90, 180, or 270 degrees clockwise\", \"%s\", optarg);\n\t\t\t     TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                             exit (EXIT_FAILURE);\n\t\t  }\n\t\tbreak;\n      case 'S':\t/* subdivide into Cols:Rows sections, eg 3:2 would be 3 across and 2 down */\n\t\tsep = strpbrk(optarg, \",:\");\n\t\tif (sep)\n                  {\n                  *sep = '\\0';\n                  page->cols = atoi(optarg);\n                  page->rows = atoi(sep +1);\n\t\t  }\n                else\n                  {\n                  page->cols = atoi(optarg);\n                  page->rows = atoi(optarg);\n\t\t  }\n                if ((page->cols * page->rows) > MAX_SECTIONS)\n                  {\n\t\t  TIFFError (\"Limit for subdivisions, ie rows x columns, exceeded\", \"%d\", MAX_SECTIONS);\n\t\t  exit (EXIT_FAILURE);\n                  }\n                page->mode |= PAGE_MODE_ROWSCOLS;\n\t\tbreak;\n      case 'U':\t/* units for measurements and offsets */\n\t\tif (streq(optarg, \"in\"))\n                  {\n\t\t  crop_data->res_unit = RESUNIT_INCH;\n\t\t  page->res_unit = RESUNIT_INCH;\n\t\t  }\n\t\telse if (streq(optarg, \"cm\"))\n\t\t  {\n\t\t  crop_data->res_unit = RESUNIT_CENTIMETER;\n\t\t  page->res_unit = RESUNIT_CENTIMETER;\n\t\t  }\n\t\telse if (streq(optarg, \"px\"))\n\t\t  {\n\t\t  crop_data->res_unit = RESUNIT_NONE;\n\t\t  page->res_unit = RESUNIT_NONE;\n\t\t  }\n\t\telse\n                  {\n\t\t  TIFFError (\"Illegal unit of measure\",\"%s\", optarg);\n\t\t  TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                  exit (EXIT_FAILURE);\n\t\t  }\n\t\tbreak;\n      case 'V': /* set vertical resolution to new value */\n\t\tpage->vres = atof (optarg);\n                page->mode |= PAGE_MODE_RESOLUTION;\n\t\tbreak;\n      case 'X':\t/* selection width */\n\t\tcrop_data->crop_mode |= CROP_WIDTH;\n\t\tcrop_data->width = atof(optarg);\n\t\tbreak;\n      case 'Y':\t/* selection length */\n\t\tcrop_data->crop_mode |= CROP_LENGTH;\n\t\tcrop_data->length = atof(optarg);\n\t\tbreak;\n      case 'Z': /* zones of an image X:Y read as zone X of Y */\n\t\tcrop_data->crop_mode |= CROP_ZONES;\n\t\tfor (i = 0, opt_ptr = strtok (optarg, \",\");\n                   ((opt_ptr != NULL) &&  (i < MAX_REGIONS));\n                    (opt_ptr = strtok (NULL, \",\")), i++)\n                    {\n\t\t    crop_data->zones++;\n\t\t    opt_offset = strchr(opt_ptr, ':');\n\t\t    if (!opt_offset) {\n\t\t\tTIFFError(\"Wrong parameter syntax for -Z\", \"tiffcrop -h\");\n\t\t\texit(EXIT_FAILURE);\n\t\t    }\n                    *opt_offset = '\\0';\n                    crop_data->zonelist[i].position = atoi(opt_ptr);\n                    crop_data->zonelist[i].total    = atoi(opt_offset + 1);\n                    }\n                /*  check for remaining elements over MAX_REGIONS */\n                if ((opt_ptr != NULL) && (i >= MAX_REGIONS))\n                  {\n\t\t  TIFFError(\"Zone list exceeds region limit\", \"%d\",  MAX_REGIONS);\n\t\t  exit (EXIT_FAILURE);\n                  }\n\t\tbreak;\n    case '?':\tTIFFError (\"For valid options type\", \"tiffcrop -h\");\n                exit (EXIT_FAILURE);\n\t\t/*NOTREACHED*/\n      }\n    }\n    /*-- Check for not allowed combinations (e.g. -X, -Y and -Z and -z are mutually exclusive) --*/\n    char XY, Z, R;\n    XY = ((crop_data->crop_mode & CROP_WIDTH) || (crop_data->crop_mode & CROP_LENGTH));\n    Z = (crop_data->crop_mode & CROP_ZONES);\n    R = (crop_data->crop_mode & CROP_REGIONS);\n    if ((XY && Z) || (XY && R) || (Z && R)) {\n        TIFFError(\"tiffcrop input error\", \"The crop options(-X|-Y), -Z and -z are mutually exclusive.->Exit\");\n        exit(EXIT_FAILURE);\n    }\n  }",
        "func": "void  process_command_opts (int argc, char *argv[], char *mp, char *mode, uint32_t *dirnum,\n                            uint16_t *defconfig, uint16_t *deffillorder, uint32_t *deftilewidth,\n                            uint32_t *deftilelength, uint32_t *defrowsperstrip,\n                            struct crop_mask *crop_data, struct pagedef *page,\n                            struct dump_opts *dump,\n                            unsigned int     *imagelist, unsigned int   *image_count )\n    {\n    int   c, good_args = 0;\n    char *opt_offset   = NULL;    /* Position in string of value sought */\n    char *opt_ptr      = NULL;    /* Pointer to next token in option set */\n    char *sep          = NULL;    /* Pointer to a token separator */\n    unsigned int  i, j, start, end;\n#if !HAVE_DECL_OPTARG\n    extern int   optind;\n    extern char* optarg;\n#endif\n\n    *mp++ = 'w';\n    *mp = '\\0';\n    while ((c = getopt(argc, argv,\n       \"ac:d:e:f:hik:l:m:p:r:stvw:z:BCD:E:F:H:I:J:K:LMN:O:P:R:S:U:V:X:Y:Z:\")) != -1)\n      {\n    good_args++;\n    switch (c) {\n      case 'a': mode[0] = 'a';\t/* append to output */\n\t\tbreak;\n      case 'c':\tif (!processCompressOptions(optarg)) /* compression scheme */\n\t\t  {\n\t\t  TIFFError (\"Unknown compression option\", \"%s\", optarg);\n                  TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                  exit (EXIT_FAILURE);\n                  }\n\t\tbreak;\n      case 'd':\tstart = strtoul(optarg, NULL, 0); /* initial IFD offset */\n\t        if (start == 0)\n                  {\n\t\t  TIFFError (\"\",\"Directory offset must be greater than zero\");\n\t\t  TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                  exit (EXIT_FAILURE);\n\t\t  }\n\t        *dirnum = start - 1;\n\t\tbreak;\n      case 'e': switch (tolower((int) optarg[0])) /* image export modes*/\n                  {\n\t\t  case 'c': crop_data->exp_mode = ONE_FILE_COMPOSITE;\n \t\t            crop_data->img_mode = COMPOSITE_IMAGES;\n\t\t            break; /* Composite */\n\t\t  case 'd': crop_data->exp_mode = ONE_FILE_SEPARATED;\n \t\t            crop_data->img_mode = SEPARATED_IMAGES;\n\t\t            break; /* Divided */\n\t\t  case 'i': crop_data->exp_mode = FILE_PER_IMAGE_COMPOSITE;\n \t\t            crop_data->img_mode = COMPOSITE_IMAGES;\n\t\t            break; /* Image */\n\t\t  case 'm': crop_data->exp_mode = FILE_PER_IMAGE_SEPARATED;\n \t\t            crop_data->img_mode = SEPARATED_IMAGES;\n\t\t            break; /* Multiple */\n\t\t  case 's': crop_data->exp_mode = FILE_PER_SELECTION;\n \t\t            crop_data->img_mode = SEPARATED_IMAGES;\n\t\t            break; /* Sections */\n\t\t  default:  TIFFError (\"Unknown export mode\",\"%s\", optarg);\n                            TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                            exit (EXIT_FAILURE);\n                  }\n\t        break;\n      case 'f':\tif (streq(optarg, \"lsb2msb\"))\t   /* fill order */\n\t\t  *deffillorder = FILLORDER_LSB2MSB;\n\t\telse if (streq(optarg, \"msb2lsb\"))\n\t\t  *deffillorder = FILLORDER_MSB2LSB;\n\t\telse\n\t\t  {\n\t\t  TIFFError (\"Unknown fill order\", \"%s\", optarg);\n                  TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                  exit (EXIT_FAILURE);\n                  }\n\t\tbreak;\n      case 'h':\tusage(EXIT_SUCCESS);\n\t\tbreak;\n      case 'i':\tignore = TRUE;\t\t/* ignore errors */\n\t\tbreak;\n      case 'k':\tmaxMalloc = (tmsize_t)strtoul(optarg, NULL, 0) << 20;\n\t\tbreak;\n      case 'l':\touttiled = TRUE;\t /* tile length */\n\t\t*deftilelength = atoi(optarg);\n\t\tbreak;\n      case 'p': /* planar configuration */\n\t\tif (streq(optarg, \"separate\"))\n\t\t  *defconfig = PLANARCONFIG_SEPARATE;\n\t\telse if (streq(optarg, \"contig\"))\n\t\t  *defconfig = PLANARCONFIG_CONTIG;\n\t\telse\n\t\t  {\n\t\t  TIFFError (\"Unknown planar configuration\", \"%s\", optarg);\n                  TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                  exit (EXIT_FAILURE);\n                  }\n\t\tbreak;\n      case 'r':\t/* rows/strip */\n\t\t*defrowsperstrip = atol(optarg);\n\t\tbreak;\n      case 's':\t/* generate stripped output */\n\t\touttiled = FALSE;\n\t\tbreak;\n      case 't':\t/* generate tiled output */\n\t\touttiled = TRUE;\n\t\tbreak;\n      case 'v': printf(\"Library Release: %s\\n\", TIFFGetVersion());\n                printf(\"Tiffcrop version: %s, last updated: %s\\n\",\n\t\t\t   tiffcrop_version_id, tiffcrop_rev_date);\n\t        printf(\"Tiffcp code: Copyright (c) 1988-1997 Sam Leffler\\n\");\n\t\tprintf(\"           : Copyright (c) 1991-1997 Silicon Graphics, Inc\\n\");\n                printf(\"Tiffcrop additions: Copyright (c) 2007-2010 Richard Nolde\\n\");\n\t        exit (EXIT_SUCCESS);\n\t\tbreak;\n      case 'w':\t/* tile width */\n\t\touttiled = TRUE;\n\t\t*deftilewidth = atoi(optarg);\n\t\tbreak;\n      case 'z': /* regions of an image specified as x1,y1,x2,y2:x3,y3,x4,y4 etc */\n\t        crop_data->crop_mode |= CROP_REGIONS;\n\t\tfor (i = 0, opt_ptr = strtok (optarg, \":\");\n                   ((opt_ptr != NULL) &&  (i < MAX_REGIONS));\n                    (opt_ptr = strtok (NULL, \":\")), i++)\n                    {\n\t\t    crop_data->regions++;\n                    if (sscanf(opt_ptr, \"%lf,%lf,%lf,%lf\",\n\t\t\t       &crop_data->corners[i].X1, &crop_data->corners[i].Y1,\n\t\t\t       &crop_data->corners[i].X2, &crop_data->corners[i].Y2) != 4)\n                      {\n                      TIFFError (\"Unable to parse coordinates for region\", \"%u %s\", i, optarg);\n\t\t      TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                      exit (EXIT_FAILURE);\n\t\t      }\n                    }\n                /*  check for remaining elements over MAX_REGIONS */\n                if ((opt_ptr != NULL) && (i >= MAX_REGIONS))\n                  {\n\t\t  TIFFError (\"Region list exceeds limit of\", \"%d regions %s\", MAX_REGIONS, optarg);\n\t\t  TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                  exit (EXIT_FAILURE);;\n                  }\n\t\tbreak;\n      /* options for file open modes */\n      case 'B': *mp++ = 'b'; *mp = '\\0';\n\t\tbreak;\n      case 'L': *mp++ = 'l'; *mp = '\\0';\n\t\tbreak;\n      case 'M': *mp++ = 'm'; *mp = '\\0';\n\t\tbreak;\n      case 'C': *mp++ = 'c'; *mp = '\\0';\n\t\tbreak;\n      /* options for Debugging / data dump */\n      case 'D': for (i = 0, opt_ptr = strtok (optarg, \",\");\n                    (opt_ptr != NULL);\n                    (opt_ptr = strtok (NULL, \",\")), i++)\n                    {\n\t\t    opt_offset = strpbrk(opt_ptr, \":=\");\n                    if (opt_offset == NULL)\n                      {\n                      TIFFError(\"Invalid dump option\", \"%s\", optarg);\n                      TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                      exit (EXIT_FAILURE);\n\t\t      }\n                      \n                    *opt_offset = '\\0';\n                    /* convert option to lowercase */\n                    end = strlen (opt_ptr);\n                    for (i = 0; i < end; i++)\n                      *(opt_ptr + i) = tolower((int) *(opt_ptr + i));\n                    /* Look for dump format specification */\n                    if (strncmp(opt_ptr, \"for\", 3) == 0)\n                      {\n\t\t      /* convert value to lowercase */\n                      end = strlen (opt_offset + 1);\n                      for (i = 1; i <= end; i++)\n                        *(opt_offset + i) = tolower((int) *(opt_offset + i));\n                      /* check dump format value */\n\t\t      if (strncmp (opt_offset + 1, \"txt\", 3) == 0)\n                        {\n                        dump->format = DUMP_TEXT;\n                        strcpy (dump->mode, \"w\");\n                        }\n                      else\n                        {\n\t\t        if (strncmp(opt_offset + 1, \"raw\", 3) == 0)\n                          {\n                          dump->format = DUMP_RAW;\n                          strcpy (dump->mode, \"wb\");\n                          }\n                        else\n                          {\n                          TIFFError(\"parse_command_opts\", \"Unknown dump format %s\", opt_offset + 1);\n                          TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                          exit (EXIT_FAILURE);\n\t\t          }\n\t\t\t}\n                      }\n\t\t    else\n                      { /* Look for dump level specification */\n                      if (strncmp (opt_ptr, \"lev\", 3) == 0)\n                        dump->level = atoi(opt_offset + 1);\n                        /* Look for input data dump file name */\n                      if (strncmp (opt_ptr, \"in\", 2) == 0)\n\t\t        {\n                        strncpy (dump->infilename, opt_offset + 1, PATH_MAX - 20);\n                        dump->infilename[PATH_MAX - 20] = '\\0';\n                        }\n                        /* Look for output data dump file name */\n                      if (strncmp (opt_ptr, \"out\", 3) == 0)\n\t\t\t{\n                        strncpy (dump->outfilename, opt_offset + 1, PATH_MAX - 20);\n                        dump->outfilename[PATH_MAX - 20] = '\\0';\n                        }\n                      if (strncmp (opt_ptr, \"deb\", 3) == 0)\n\t\t\tdump->debug = atoi(opt_offset + 1);\n\t\t      }\n                    }\n\t        if ((strlen(dump->infilename)) || (strlen(dump->outfilename)))\n                  {\n\t\t  if (dump->level == 1)\n                    TIFFError(\"\",\"Defaulting to dump level 1, no data.\");\n\t          if (dump->format == DUMP_NONE)\n                    {\n\t\t    TIFFError(\"\", \"You must specify a dump format for dump files\");\n\t\t    TIFFError (\"For valid options type\", \"tiffcrop -h\");\n\t\t    exit (EXIT_FAILURE);\n\t\t    }\n                  }\n\t        break;\n\n      /* image manipulation routine options */\n      case 'm': /* margins to exclude from selection, uppercase M was already used */\n\t\t/* order of values must be TOP, LEFT, BOTTOM, RIGHT */\n\t\tcrop_data->crop_mode |= CROP_MARGINS;\n                for (i = 0, opt_ptr = strtok (optarg, \",:\");\n                    ((opt_ptr != NULL) &&  (i < 4));\n                     (opt_ptr = strtok (NULL, \",:\")), i++)\n                    {\n\t\t    crop_data->margins[i] = atof(opt_ptr);\n                    }\n\t\tbreak;\n      case 'E':\t/* edge reference */\n\t\tswitch (tolower((int) optarg[0]))\n                  {\n\t\t  case 't': crop_data->edge_ref = EDGE_TOP;\n                            break;\n                  case 'b': crop_data->edge_ref = EDGE_BOTTOM;\n                             break;\n                  case 'l': crop_data->edge_ref = EDGE_LEFT;\n                            break;\n                  case 'r': crop_data->edge_ref = EDGE_RIGHT;\n                            break;\n\t\t  default:  TIFFError (\"Edge reference must be top, bottom, left, or right\", \"%s\", optarg);\n\t\t\t    TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                            exit (EXIT_FAILURE);\n\t\t  }\n\t\tbreak;\n      case 'F': /* flip eg mirror image or cropped segment, M was already used */\n\t\tcrop_data->crop_mode |= CROP_MIRROR;\n\t\tswitch (tolower((int) optarg[0]))\n                  {\n\t\t  case  'h': crop_data->mirror = MIRROR_HORIZ;\n                             break;\n                  case  'v': crop_data->mirror = MIRROR_VERT;\n                             break;\n                  case  'b': crop_data->mirror = MIRROR_BOTH;\n                             break;\n\t\t  default:   TIFFError (\"Flip mode must be horiz, vert, or both\", \"%s\", optarg);\n\t\t\t     TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                             exit (EXIT_FAILURE);\n\t\t  }\n\t\tbreak;\n      case 'H': /* set horizontal resolution to new value */\n\t\tpage->hres = atof (optarg);\n                page->mode |= PAGE_MODE_RESOLUTION;\n\t\tbreak;\n      case 'I': /* invert the color space, eg black to white */\n\t\tcrop_data->crop_mode |= CROP_INVERT;\n                /* The PHOTOMETIC_INTERPRETATION tag may be updated */\n                if (streq(optarg, \"black\"))\n                  {\n\t\t  crop_data->photometric = PHOTOMETRIC_MINISBLACK;\n\t\t  continue;\n                  }\n                if (streq(optarg, \"white\"))\n                  {\n\t\t  crop_data->photometric = PHOTOMETRIC_MINISWHITE;\n                  continue;\n                  }\n                if (streq(optarg, \"data\")) \n                  {\n\t\t  crop_data->photometric = INVERT_DATA_ONLY;\n                  continue;\n                  }\n                if (streq(optarg, \"both\"))\n                  {\n\t\t  crop_data->photometric = INVERT_DATA_AND_TAG;\n                  continue;\n                  }\n\n\t\tTIFFError(\"Missing or unknown option for inverting PHOTOMETRIC_INTERPRETATION\", \"%s\", optarg);\n\t\tTIFFError (\"For valid options type\", \"tiffcrop -h\");\n                exit (EXIT_FAILURE);\n\t\tbreak;\n      case 'J': /* horizontal margin for sectioned output pages */\n\t\tpage->hmargin = atof(optarg);\n                page->mode |= PAGE_MODE_MARGINS;\n\t\tbreak;\n      case 'K': /* vertical margin for sectioned output pages*/\n                page->vmargin = atof(optarg);\n                page->mode |= PAGE_MODE_MARGINS;\n\t\tbreak;\n      case 'N':\t/* list of images to process */\n                for (i = 0, opt_ptr = strtok (optarg, \",\");\n                    ((opt_ptr != NULL) &&  (i < MAX_IMAGES));\n                     (opt_ptr = strtok (NULL, \",\")))\n                     { /* We do not know how many images are in file yet \n\t\t\t* so we build a list to include the maximum allowed\n                        * and follow it until we hit the end of the file.\n                        * Image count is not accurate for odd, even, last\n                        * so page numbers won't be valid either.\n                        */\n\t\t     if (streq(opt_ptr, \"odd\"))\n                       {\n\t\t       for (j = 1; j <= MAX_IMAGES; j += 2)\n\t\t\t imagelist[i++] = j;\n                       *image_count = (MAX_IMAGES - 1) / 2;\n                       break;\n\t\t       }\n\t\t     else\n                       {\n\t\t       if (streq(opt_ptr, \"even\"))\n                         {\n\t\t\t for (j = 2; j <= MAX_IMAGES; j += 2)\n\t\t\t   imagelist[i++] = j;\n                         *image_count = MAX_IMAGES / 2;\n                         break;\n\t\t\t }\n\t\t       else\n                         {\n\t\t\t if (streq(opt_ptr, \"last\"))\n\t\t\t   imagelist[i++] = MAX_IMAGES;\n\t\t\t else  /* single value between commas */\n\t\t\t   {\n\t\t\t   sep = strpbrk(opt_ptr, \":-\");\n\t\t\t   if (!sep)\n\t\t\t     imagelist[i++] = atoi(opt_ptr);\n                           else\n                             {\n\t\t\t     *sep = '\\0';\n                             start = atoi (opt_ptr);\n                             if (!strcmp((sep + 1), \"last\"))\n\t\t\t       end = MAX_IMAGES;\n                             else\n                               end = atoi (sep + 1);\n                             for (j = start; j <= end && j - start + i < MAX_IMAGES; j++)\n\t\t\t       imagelist[i++] = j;\n\t\t\t     }\n\t\t\t   }\n\t\t\t }\n\t\t      }\n\t\t    }\n                *image_count = i;\n\t\tbreak;\n      case 'O': /* page orientation */ \n\t\tswitch (tolower((int) optarg[0]))\n                  {\n\t\t  case  'a': page->orient = ORIENTATION_AUTO;\n                             break;\n\t\t  case  'p': page->orient = ORIENTATION_PORTRAIT;\n                             break;\n\t\t  case  'l': page->orient = ORIENTATION_LANDSCAPE;\n                             break;\n\t\t  default:  TIFFError (\"Orientation must be portrait, landscape, or auto.\", \"%s\", optarg);\n\t\t\t    TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                            exit (EXIT_FAILURE);\n\t\t  }\n\t\tbreak;\n      case 'P': /* page size selection */ \n\t        if (sscanf(optarg, \"%lfx%lf\", &page->width, &page->length) == 2)\n                  {\n                  strcpy (page->name, \"Custom\"); \n                  page->mode |= PAGE_MODE_PAPERSIZE;\n                  break;\n                  }\n                if (get_page_geometry (optarg, page))\n                  {\n\t\t  if (!strcmp(optarg, \"list\"))\n                    {\n\t\t    TIFFError(\"\", \"Name            Width   Length (in inches)\");\n                    for (i = 0; i < MAX_PAPERNAMES - 1; i++)\n                      TIFFError (\"\", \"%-15.15s %5.2f   %5.2f\", \n\t\t\t       PaperTable[i].name, PaperTable[i].width, \n                               PaperTable[i].length);\n\t\t    exit (EXIT_FAILURE);\n                    }\n     \n\t\t  TIFFError (\"Invalid paper size\", \"%s\", optarg);\n                  TIFFError (\"\", \"Select one of:\");\n\t\t  TIFFError(\"\", \"Name            Width   Length (in inches)\");\n                  for (i = 0; i < MAX_PAPERNAMES - 1; i++)\n                    TIFFError (\"\", \"%-15.15s %5.2f   %5.2f\", \n\t\t\t       PaperTable[i].name, PaperTable[i].width, \n                               PaperTable[i].length);\n\t\t  exit (EXIT_FAILURE);\n\t\t  }\n\t\telse\n                  {\n                  page->mode |= PAGE_MODE_PAPERSIZE;\n\t\t  }\n\t\tbreak;\n      case 'R': /* rotate image or cropped segment */\n\t\tcrop_data->crop_mode |= CROP_ROTATE;\n\t\tswitch (strtoul(optarg, NULL, 0))\n                  {\n\t\t  case  90:  crop_data->rotation = (uint16_t)90;\n                             break;\n                  case  180: crop_data->rotation = (uint16_t)180;\n                             break;\n                  case  270: crop_data->rotation = (uint16_t)270;\n                             break;\n\t\t  default:   TIFFError (\"Rotation must be 90, 180, or 270 degrees clockwise\", \"%s\", optarg);\n\t\t\t     TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                             exit (EXIT_FAILURE);\n\t\t  }\n\t\tbreak;\n      case 'S':\t/* subdivide into Cols:Rows sections, eg 3:2 would be 3 across and 2 down */\n\t\tsep = strpbrk(optarg, \",:\");\n\t\tif (sep)\n                  {\n                  *sep = '\\0';\n                  page->cols = atoi(optarg);\n                  page->rows = atoi(sep +1);\n\t\t  }\n                else\n                  {\n                  page->cols = atoi(optarg);\n                  page->rows = atoi(optarg);\n\t\t  }\n                if ((page->cols * page->rows) > MAX_SECTIONS)\n                  {\n\t\t  TIFFError (\"Limit for subdivisions, ie rows x columns, exceeded\", \"%d\", MAX_SECTIONS);\n\t\t  exit (EXIT_FAILURE);\n                  }\n                page->mode |= PAGE_MODE_ROWSCOLS;\n\t\tbreak;\n      case 'U':\t/* units for measurements and offsets */\n\t\tif (streq(optarg, \"in\"))\n                  {\n\t\t  crop_data->res_unit = RESUNIT_INCH;\n\t\t  page->res_unit = RESUNIT_INCH;\n\t\t  }\n\t\telse if (streq(optarg, \"cm\"))\n\t\t  {\n\t\t  crop_data->res_unit = RESUNIT_CENTIMETER;\n\t\t  page->res_unit = RESUNIT_CENTIMETER;\n\t\t  }\n\t\telse if (streq(optarg, \"px\"))\n\t\t  {\n\t\t  crop_data->res_unit = RESUNIT_NONE;\n\t\t  page->res_unit = RESUNIT_NONE;\n\t\t  }\n\t\telse\n                  {\n\t\t  TIFFError (\"Illegal unit of measure\",\"%s\", optarg);\n\t\t  TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                  exit (EXIT_FAILURE);\n\t\t  }\n\t\tbreak;\n      case 'V': /* set vertical resolution to new value */\n\t\tpage->vres = atof (optarg);\n                page->mode |= PAGE_MODE_RESOLUTION;\n\t\tbreak;\n      case 'X':\t/* selection width */\n\t\tcrop_data->crop_mode |= CROP_WIDTH;\n\t\tcrop_data->width = atof(optarg);\n\t\tbreak;\n      case 'Y':\t/* selection length */\n\t\tcrop_data->crop_mode |= CROP_LENGTH;\n\t\tcrop_data->length = atof(optarg);\n\t\tbreak;\n      case 'Z': /* zones of an image X:Y read as zone X of Y */\n\t\tcrop_data->crop_mode |= CROP_ZONES;\n\t\tfor (i = 0, opt_ptr = strtok (optarg, \",\");\n                   ((opt_ptr != NULL) &&  (i < MAX_REGIONS));\n                    (opt_ptr = strtok (NULL, \",\")), i++)\n                    {\n\t\t    crop_data->zones++;\n\t\t    opt_offset = strchr(opt_ptr, ':');\n\t\t    if (!opt_offset) {\n\t\t\tTIFFError(\"Wrong parameter syntax for -Z\", \"tiffcrop -h\");\n\t\t\texit(EXIT_FAILURE);\n\t\t    }\n                    *opt_offset = '\\0';\n                    crop_data->zonelist[i].position = atoi(opt_ptr);\n                    crop_data->zonelist[i].total    = atoi(opt_offset + 1);\n                    }\n                /*  check for remaining elements over MAX_REGIONS */\n                if ((opt_ptr != NULL) && (i >= MAX_REGIONS))\n                  {\n\t\t  TIFFError(\"Zone list exceeds region limit\", \"%d\",  MAX_REGIONS);\n\t\t  exit (EXIT_FAILURE);\n                  }\n\t\tbreak;\n    case '?':\tTIFFError (\"For valid options type\", \"tiffcrop -h\");\n                exit (EXIT_FAILURE);\n\t\t/*NOTREACHED*/\n      }\n    }\n    /*-- Check for not allowed combinations (e.g. -X, -Y and -Z, -z and -S are mutually exclusive) --*/\n    char XY, Z, R, S;\n    XY = ((crop_data->crop_mode & CROP_WIDTH) || (crop_data->crop_mode & CROP_LENGTH));\n    Z = (crop_data->crop_mode & CROP_ZONES);\n    R = (crop_data->crop_mode & CROP_REGIONS);\n    S = (page->mode & PAGE_MODE_ROWSCOLS);\n    if ((XY && Z) || (XY && R) || (XY && S) || (Z && R) || (Z && S) || (R && S)) {\n        TIFFError(\"tiffcrop input error\", \"The crop options(-X|-Y), -Z, -z and -S are mutually exclusive.->Exit\");\n        exit(EXIT_FAILURE);\n    }\n  }",
        "diff_func": "--- func_before\n+++ func_after\n@@ -506,13 +506,14 @@\n \t\t/*NOTREACHED*/\n       }\n     }\n-    /*-- Check for not allowed combinations (e.g. -X, -Y and -Z and -z are mutually exclusive) --*/\n-    char XY, Z, R;\n+    /*-- Check for not allowed combinations (e.g. -X, -Y and -Z, -z and -S are mutually exclusive) --*/\n+    char XY, Z, R, S;\n     XY = ((crop_data->crop_mode & CROP_WIDTH) || (crop_data->crop_mode & CROP_LENGTH));\n     Z = (crop_data->crop_mode & CROP_ZONES);\n     R = (crop_data->crop_mode & CROP_REGIONS);\n-    if ((XY && Z) || (XY && R) || (Z && R)) {\n-        TIFFError(\"tiffcrop input error\", \"The crop options(-X|-Y), -Z and -z are mutually exclusive.->Exit\");\n+    S = (page->mode & PAGE_MODE_ROWSCOLS);\n+    if ((XY && Z) || (XY && R) || (XY && S) || (Z && R) || (Z && S) || (R && S)) {\n+        TIFFError(\"tiffcrop input error\", \"The crop options(-X|-Y), -Z, -z and -S are mutually exclusive.->Exit\");\n         exit(EXIT_FAILURE);\n     }\n   }",
        "diff_line_info": {
            "deleted_lines": [
                "    /*-- Check for not allowed combinations (e.g. -X, -Y and -Z and -z are mutually exclusive) --*/",
                "    char XY, Z, R;",
                "    if ((XY && Z) || (XY && R) || (Z && R)) {",
                "        TIFFError(\"tiffcrop input error\", \"The crop options(-X|-Y), -Z and -z are mutually exclusive.->Exit\");"
            ],
            "added_lines": [
                "    /*-- Check for not allowed combinations (e.g. -X, -Y and -Z, -z and -S are mutually exclusive) --*/",
                "    char XY, Z, R, S;",
                "    S = (page->mode & PAGE_MODE_ROWSCOLS);",
                "    if ((XY && Z) || (XY && R) || (XY && S) || (Z && R) || (Z && S) || (R && S)) {",
                "        TIFFError(\"tiffcrop input error\", \"The crop options(-X|-Y), -Z, -z and -S are mutually exclusive.->Exit\");"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-2953",
        "func_name": "libtiff/process_command_opts",
        "description": "LibTIFF 4.4.0 has an out-of-bounds read in extractImageSection in tools/tiffcrop.c:6905, allowing attackers to cause a denial-of-service via a crafted tiff file. For users that compile libtiff from sources, the fix is available with commit 48d6ece8.",
        "git_url": "https://gitlab.com/libtiff/libtiff/-/commit/bad48e90b410df32172006c7876da449ba62cdba",
        "commit_title": "tiffcrop -S option: Make decision simpler.",
        "commit_text": "",
        "func_before": "void  process_command_opts (int argc, char *argv[], char *mp, char *mode, uint32_t *dirnum,\n                            uint16_t *defconfig, uint16_t *deffillorder, uint32_t *deftilewidth,\n                            uint32_t *deftilelength, uint32_t *defrowsperstrip,\n                            struct crop_mask *crop_data, struct pagedef *page,\n                            struct dump_opts *dump,\n                            unsigned int     *imagelist, unsigned int   *image_count )\n    {\n    int   c, good_args = 0;\n    char *opt_offset   = NULL;    /* Position in string of value sought */\n    char *opt_ptr      = NULL;    /* Pointer to next token in option set */\n    char *sep          = NULL;    /* Pointer to a token separator */\n    unsigned int  i, j, start, end;\n#if !HAVE_DECL_OPTARG\n    extern int   optind;\n    extern char* optarg;\n#endif\n\n    *mp++ = 'w';\n    *mp = '\\0';\n    while ((c = getopt(argc, argv,\n       \"ac:d:e:f:hik:l:m:p:r:stvw:z:BCD:E:F:H:I:J:K:LMN:O:P:R:S:U:V:X:Y:Z:\")) != -1)\n      {\n    good_args++;\n    switch (c) {\n      case 'a': mode[0] = 'a';\t/* append to output */\n\t\tbreak;\n      case 'c':\tif (!processCompressOptions(optarg)) /* compression scheme */\n\t\t  {\n\t\t  TIFFError (\"Unknown compression option\", \"%s\", optarg);\n                  TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                  exit (EXIT_FAILURE);\n                  }\n\t\tbreak;\n      case 'd':\tstart = strtoul(optarg, NULL, 0); /* initial IFD offset */\n\t        if (start == 0)\n                  {\n\t\t  TIFFError (\"\",\"Directory offset must be greater than zero\");\n\t\t  TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                  exit (EXIT_FAILURE);\n\t\t  }\n\t        *dirnum = start - 1;\n\t\tbreak;\n      case 'e': switch (tolower((int) optarg[0])) /* image export modes*/\n                  {\n\t\t  case 'c': crop_data->exp_mode = ONE_FILE_COMPOSITE;\n \t\t            crop_data->img_mode = COMPOSITE_IMAGES;\n\t\t            break; /* Composite */\n\t\t  case 'd': crop_data->exp_mode = ONE_FILE_SEPARATED;\n \t\t            crop_data->img_mode = SEPARATED_IMAGES;\n\t\t            break; /* Divided */\n\t\t  case 'i': crop_data->exp_mode = FILE_PER_IMAGE_COMPOSITE;\n \t\t            crop_data->img_mode = COMPOSITE_IMAGES;\n\t\t            break; /* Image */\n\t\t  case 'm': crop_data->exp_mode = FILE_PER_IMAGE_SEPARATED;\n \t\t            crop_data->img_mode = SEPARATED_IMAGES;\n\t\t            break; /* Multiple */\n\t\t  case 's': crop_data->exp_mode = FILE_PER_SELECTION;\n \t\t            crop_data->img_mode = SEPARATED_IMAGES;\n\t\t            break; /* Sections */\n\t\t  default:  TIFFError (\"Unknown export mode\",\"%s\", optarg);\n                            TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                            exit (EXIT_FAILURE);\n                  }\n\t        break;\n      case 'f':\tif (streq(optarg, \"lsb2msb\"))\t   /* fill order */\n\t\t  *deffillorder = FILLORDER_LSB2MSB;\n\t\telse if (streq(optarg, \"msb2lsb\"))\n\t\t  *deffillorder = FILLORDER_MSB2LSB;\n\t\telse\n\t\t  {\n\t\t  TIFFError (\"Unknown fill order\", \"%s\", optarg);\n                  TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                  exit (EXIT_FAILURE);\n                  }\n\t\tbreak;\n      case 'h':\tusage(EXIT_SUCCESS);\n\t\tbreak;\n      case 'i':\tignore = TRUE;\t\t/* ignore errors */\n\t\tbreak;\n      case 'k':\tmaxMalloc = (tmsize_t)strtoul(optarg, NULL, 0) << 20;\n\t\tbreak;\n      case 'l':\touttiled = TRUE;\t /* tile length */\n\t\t*deftilelength = atoi(optarg);\n\t\tbreak;\n      case 'p': /* planar configuration */\n\t\tif (streq(optarg, \"separate\"))\n\t\t  *defconfig = PLANARCONFIG_SEPARATE;\n\t\telse if (streq(optarg, \"contig\"))\n\t\t  *defconfig = PLANARCONFIG_CONTIG;\n\t\telse\n\t\t  {\n\t\t  TIFFError (\"Unknown planar configuration\", \"%s\", optarg);\n                  TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                  exit (EXIT_FAILURE);\n                  }\n\t\tbreak;\n      case 'r':\t/* rows/strip */\n\t\t*defrowsperstrip = atol(optarg);\n\t\tbreak;\n      case 's':\t/* generate stripped output */\n\t\touttiled = FALSE;\n\t\tbreak;\n      case 't':\t/* generate tiled output */\n\t\touttiled = TRUE;\n\t\tbreak;\n      case 'v': printf(\"Library Release: %s\\n\", TIFFGetVersion());\n                printf(\"Tiffcrop version: %s, last updated: %s\\n\",\n\t\t\t   tiffcrop_version_id, tiffcrop_rev_date);\n\t        printf(\"Tiffcp code: Copyright (c) 1988-1997 Sam Leffler\\n\");\n\t\tprintf(\"           : Copyright (c) 1991-1997 Silicon Graphics, Inc\\n\");\n                printf(\"Tiffcrop additions: Copyright (c) 2007-2010 Richard Nolde\\n\");\n\t        exit (EXIT_SUCCESS);\n\t\tbreak;\n      case 'w':\t/* tile width */\n\t\touttiled = TRUE;\n\t\t*deftilewidth = atoi(optarg);\n\t\tbreak;\n      case 'z': /* regions of an image specified as x1,y1,x2,y2:x3,y3,x4,y4 etc */\n\t        crop_data->crop_mode |= CROP_REGIONS;\n\t\tfor (i = 0, opt_ptr = strtok (optarg, \":\");\n                   ((opt_ptr != NULL) &&  (i < MAX_REGIONS));\n                    (opt_ptr = strtok (NULL, \":\")), i++)\n                    {\n\t\t    crop_data->regions++;\n                    if (sscanf(opt_ptr, \"%lf,%lf,%lf,%lf\",\n\t\t\t       &crop_data->corners[i].X1, &crop_data->corners[i].Y1,\n\t\t\t       &crop_data->corners[i].X2, &crop_data->corners[i].Y2) != 4)\n                      {\n                      TIFFError (\"Unable to parse coordinates for region\", \"%u %s\", i, optarg);\n\t\t      TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                      exit (EXIT_FAILURE);\n\t\t      }\n                    }\n                /*  check for remaining elements over MAX_REGIONS */\n                if ((opt_ptr != NULL) && (i >= MAX_REGIONS))\n                  {\n\t\t  TIFFError (\"Region list exceeds limit of\", \"%d regions %s\", MAX_REGIONS, optarg);\n\t\t  TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                  exit (EXIT_FAILURE);;\n                  }\n\t\tbreak;\n      /* options for file open modes */\n      case 'B': *mp++ = 'b'; *mp = '\\0';\n\t\tbreak;\n      case 'L': *mp++ = 'l'; *mp = '\\0';\n\t\tbreak;\n      case 'M': *mp++ = 'm'; *mp = '\\0';\n\t\tbreak;\n      case 'C': *mp++ = 'c'; *mp = '\\0';\n\t\tbreak;\n      /* options for Debugging / data dump */\n      case 'D': for (i = 0, opt_ptr = strtok (optarg, \",\");\n                    (opt_ptr != NULL);\n                    (opt_ptr = strtok (NULL, \",\")), i++)\n                    {\n\t\t    opt_offset = strpbrk(opt_ptr, \":=\");\n                    if (opt_offset == NULL)\n                      {\n                      TIFFError(\"Invalid dump option\", \"%s\", optarg);\n                      TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                      exit (EXIT_FAILURE);\n\t\t      }\n                      \n                    *opt_offset = '\\0';\n                    /* convert option to lowercase */\n                    end = strlen (opt_ptr);\n                    for (i = 0; i < end; i++)\n                      *(opt_ptr + i) = tolower((int) *(opt_ptr + i));\n                    /* Look for dump format specification */\n                    if (strncmp(opt_ptr, \"for\", 3) == 0)\n                      {\n\t\t      /* convert value to lowercase */\n                      end = strlen (opt_offset + 1);\n                      for (i = 1; i <= end; i++)\n                        *(opt_offset + i) = tolower((int) *(opt_offset + i));\n                      /* check dump format value */\n\t\t      if (strncmp (opt_offset + 1, \"txt\", 3) == 0)\n                        {\n                        dump->format = DUMP_TEXT;\n                        strcpy (dump->mode, \"w\");\n                        }\n                      else\n                        {\n\t\t        if (strncmp(opt_offset + 1, \"raw\", 3) == 0)\n                          {\n                          dump->format = DUMP_RAW;\n                          strcpy (dump->mode, \"wb\");\n                          }\n                        else\n                          {\n                          TIFFError(\"parse_command_opts\", \"Unknown dump format %s\", opt_offset + 1);\n                          TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                          exit (EXIT_FAILURE);\n\t\t          }\n\t\t\t}\n                      }\n\t\t    else\n                      { /* Look for dump level specification */\n                      if (strncmp (opt_ptr, \"lev\", 3) == 0)\n                        dump->level = atoi(opt_offset + 1);\n                        /* Look for input data dump file name */\n                      if (strncmp (opt_ptr, \"in\", 2) == 0)\n\t\t        {\n                        strncpy (dump->infilename, opt_offset + 1, PATH_MAX - 20);\n                        dump->infilename[PATH_MAX - 20] = '\\0';\n                        }\n                        /* Look for output data dump file name */\n                      if (strncmp (opt_ptr, \"out\", 3) == 0)\n\t\t\t{\n                        strncpy (dump->outfilename, opt_offset + 1, PATH_MAX - 20);\n                        dump->outfilename[PATH_MAX - 20] = '\\0';\n                        }\n                      if (strncmp (opt_ptr, \"deb\", 3) == 0)\n\t\t\tdump->debug = atoi(opt_offset + 1);\n\t\t      }\n                    }\n\t        if ((strlen(dump->infilename)) || (strlen(dump->outfilename)))\n                  {\n\t\t  if (dump->level == 1)\n                    TIFFError(\"\",\"Defaulting to dump level 1, no data.\");\n\t          if (dump->format == DUMP_NONE)\n                    {\n\t\t    TIFFError(\"\", \"You must specify a dump format for dump files\");\n\t\t    TIFFError (\"For valid options type\", \"tiffcrop -h\");\n\t\t    exit (EXIT_FAILURE);\n\t\t    }\n                  }\n\t        break;\n\n      /* image manipulation routine options */\n      case 'm': /* margins to exclude from selection, uppercase M was already used */\n\t\t/* order of values must be TOP, LEFT, BOTTOM, RIGHT */\n\t\tcrop_data->crop_mode |= CROP_MARGINS;\n                for (i = 0, opt_ptr = strtok (optarg, \",:\");\n                    ((opt_ptr != NULL) &&  (i < 4));\n                     (opt_ptr = strtok (NULL, \",:\")), i++)\n                    {\n\t\t    crop_data->margins[i] = atof(opt_ptr);\n                    }\n\t\tbreak;\n      case 'E':\t/* edge reference */\n\t\tswitch (tolower((int) optarg[0]))\n                  {\n\t\t  case 't': crop_data->edge_ref = EDGE_TOP;\n                            break;\n                  case 'b': crop_data->edge_ref = EDGE_BOTTOM;\n                             break;\n                  case 'l': crop_data->edge_ref = EDGE_LEFT;\n                            break;\n                  case 'r': crop_data->edge_ref = EDGE_RIGHT;\n                            break;\n\t\t  default:  TIFFError (\"Edge reference must be top, bottom, left, or right\", \"%s\", optarg);\n\t\t\t    TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                            exit (EXIT_FAILURE);\n\t\t  }\n\t\tbreak;\n      case 'F': /* flip eg mirror image or cropped segment, M was already used */\n\t\tcrop_data->crop_mode |= CROP_MIRROR;\n\t\tswitch (tolower((int) optarg[0]))\n                  {\n\t\t  case  'h': crop_data->mirror = MIRROR_HORIZ;\n                             break;\n                  case  'v': crop_data->mirror = MIRROR_VERT;\n                             break;\n                  case  'b': crop_data->mirror = MIRROR_BOTH;\n                             break;\n\t\t  default:   TIFFError (\"Flip mode must be horiz, vert, or both\", \"%s\", optarg);\n\t\t\t     TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                             exit (EXIT_FAILURE);\n\t\t  }\n\t\tbreak;\n      case 'H': /* set horizontal resolution to new value */\n\t\tpage->hres = atof (optarg);\n                page->mode |= PAGE_MODE_RESOLUTION;\n\t\tbreak;\n      case 'I': /* invert the color space, eg black to white */\n\t\tcrop_data->crop_mode |= CROP_INVERT;\n                /* The PHOTOMETIC_INTERPRETATION tag may be updated */\n                if (streq(optarg, \"black\"))\n                  {\n\t\t  crop_data->photometric = PHOTOMETRIC_MINISBLACK;\n\t\t  continue;\n                  }\n                if (streq(optarg, \"white\"))\n                  {\n\t\t  crop_data->photometric = PHOTOMETRIC_MINISWHITE;\n                  continue;\n                  }\n                if (streq(optarg, \"data\")) \n                  {\n\t\t  crop_data->photometric = INVERT_DATA_ONLY;\n                  continue;\n                  }\n                if (streq(optarg, \"both\"))\n                  {\n\t\t  crop_data->photometric = INVERT_DATA_AND_TAG;\n                  continue;\n                  }\n\n\t\tTIFFError(\"Missing or unknown option for inverting PHOTOMETRIC_INTERPRETATION\", \"%s\", optarg);\n\t\tTIFFError (\"For valid options type\", \"tiffcrop -h\");\n                exit (EXIT_FAILURE);\n\t\tbreak;\n      case 'J': /* horizontal margin for sectioned output pages */\n\t\tpage->hmargin = atof(optarg);\n                page->mode |= PAGE_MODE_MARGINS;\n\t\tbreak;\n      case 'K': /* vertical margin for sectioned output pages*/\n                page->vmargin = atof(optarg);\n                page->mode |= PAGE_MODE_MARGINS;\n\t\tbreak;\n      case 'N':\t/* list of images to process */\n                for (i = 0, opt_ptr = strtok (optarg, \",\");\n                    ((opt_ptr != NULL) &&  (i < MAX_IMAGES));\n                     (opt_ptr = strtok (NULL, \",\")))\n                     { /* We do not know how many images are in file yet \n\t\t\t* so we build a list to include the maximum allowed\n                        * and follow it until we hit the end of the file.\n                        * Image count is not accurate for odd, even, last\n                        * so page numbers won't be valid either.\n                        */\n\t\t     if (streq(opt_ptr, \"odd\"))\n                       {\n\t\t       for (j = 1; j <= MAX_IMAGES; j += 2)\n\t\t\t imagelist[i++] = j;\n                       *image_count = (MAX_IMAGES - 1) / 2;\n                       break;\n\t\t       }\n\t\t     else\n                       {\n\t\t       if (streq(opt_ptr, \"even\"))\n                         {\n\t\t\t for (j = 2; j <= MAX_IMAGES; j += 2)\n\t\t\t   imagelist[i++] = j;\n                         *image_count = MAX_IMAGES / 2;\n                         break;\n\t\t\t }\n\t\t       else\n                         {\n\t\t\t if (streq(opt_ptr, \"last\"))\n\t\t\t   imagelist[i++] = MAX_IMAGES;\n\t\t\t else  /* single value between commas */\n\t\t\t   {\n\t\t\t   sep = strpbrk(opt_ptr, \":-\");\n\t\t\t   if (!sep)\n\t\t\t     imagelist[i++] = atoi(opt_ptr);\n                           else\n                             {\n\t\t\t     *sep = '\\0';\n                             start = atoi (opt_ptr);\n                             if (!strcmp((sep + 1), \"last\"))\n\t\t\t       end = MAX_IMAGES;\n                             else\n                               end = atoi (sep + 1);\n                             for (j = start; j <= end && j - start + i < MAX_IMAGES; j++)\n\t\t\t       imagelist[i++] = j;\n\t\t\t     }\n\t\t\t   }\n\t\t\t }\n\t\t      }\n\t\t    }\n                *image_count = i;\n\t\tbreak;\n      case 'O': /* page orientation */ \n\t\tswitch (tolower((int) optarg[0]))\n                  {\n\t\t  case  'a': page->orient = ORIENTATION_AUTO;\n                             break;\n\t\t  case  'p': page->orient = ORIENTATION_PORTRAIT;\n                             break;\n\t\t  case  'l': page->orient = ORIENTATION_LANDSCAPE;\n                             break;\n\t\t  default:  TIFFError (\"Orientation must be portrait, landscape, or auto.\", \"%s\", optarg);\n\t\t\t    TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                            exit (EXIT_FAILURE);\n\t\t  }\n\t\tbreak;\n      case 'P': /* page size selection */ \n\t        if (sscanf(optarg, \"%lfx%lf\", &page->width, &page->length) == 2)\n                  {\n                  strcpy (page->name, \"Custom\"); \n                  page->mode |= PAGE_MODE_PAPERSIZE;\n                  break;\n                  }\n                if (get_page_geometry (optarg, page))\n                  {\n\t\t  if (!strcmp(optarg, \"list\"))\n                    {\n\t\t    TIFFError(\"\", \"Name            Width   Length (in inches)\");\n                    for (i = 0; i < MAX_PAPERNAMES - 1; i++)\n                      TIFFError (\"\", \"%-15.15s %5.2f   %5.2f\", \n\t\t\t       PaperTable[i].name, PaperTable[i].width, \n                               PaperTable[i].length);\n\t\t    exit (EXIT_FAILURE);\n                    }\n     \n\t\t  TIFFError (\"Invalid paper size\", \"%s\", optarg);\n                  TIFFError (\"\", \"Select one of:\");\n\t\t  TIFFError(\"\", \"Name            Width   Length (in inches)\");\n                  for (i = 0; i < MAX_PAPERNAMES - 1; i++)\n                    TIFFError (\"\", \"%-15.15s %5.2f   %5.2f\", \n\t\t\t       PaperTable[i].name, PaperTable[i].width, \n                               PaperTable[i].length);\n\t\t  exit (EXIT_FAILURE);\n\t\t  }\n\t\telse\n                  {\n                  page->mode |= PAGE_MODE_PAPERSIZE;\n\t\t  }\n\t\tbreak;\n      case 'R': /* rotate image or cropped segment */\n\t\tcrop_data->crop_mode |= CROP_ROTATE;\n\t\tswitch (strtoul(optarg, NULL, 0))\n                  {\n\t\t  case  90:  crop_data->rotation = (uint16_t)90;\n                             break;\n                  case  180: crop_data->rotation = (uint16_t)180;\n                             break;\n                  case  270: crop_data->rotation = (uint16_t)270;\n                             break;\n\t\t  default:   TIFFError (\"Rotation must be 90, 180, or 270 degrees clockwise\", \"%s\", optarg);\n\t\t\t     TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                             exit (EXIT_FAILURE);\n\t\t  }\n\t\tbreak;\n      case 'S':\t/* subdivide into Cols:Rows sections, eg 3:2 would be 3 across and 2 down */\n\t\tsep = strpbrk(optarg, \",:\");\n\t\tif (sep)\n                  {\n                  *sep = '\\0';\n                  page->cols = atoi(optarg);\n                  page->rows = atoi(sep +1);\n\t\t  }\n                else\n                  {\n                  page->cols = atoi(optarg);\n                  page->rows = atoi(optarg);\n\t\t  }\n                if ((page->cols * page->rows) > MAX_SECTIONS)\n                  {\n\t\t  TIFFError (\"Limit for subdivisions, ie rows x columns, exceeded\", \"%d\", MAX_SECTIONS);\n\t\t  exit (EXIT_FAILURE);\n                  }\n                page->mode |= PAGE_MODE_ROWSCOLS;\n\t\tbreak;\n      case 'U':\t/* units for measurements and offsets */\n\t\tif (streq(optarg, \"in\"))\n                  {\n\t\t  crop_data->res_unit = RESUNIT_INCH;\n\t\t  page->res_unit = RESUNIT_INCH;\n\t\t  }\n\t\telse if (streq(optarg, \"cm\"))\n\t\t  {\n\t\t  crop_data->res_unit = RESUNIT_CENTIMETER;\n\t\t  page->res_unit = RESUNIT_CENTIMETER;\n\t\t  }\n\t\telse if (streq(optarg, \"px\"))\n\t\t  {\n\t\t  crop_data->res_unit = RESUNIT_NONE;\n\t\t  page->res_unit = RESUNIT_NONE;\n\t\t  }\n\t\telse\n                  {\n\t\t  TIFFError (\"Illegal unit of measure\",\"%s\", optarg);\n\t\t  TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                  exit (EXIT_FAILURE);\n\t\t  }\n\t\tbreak;\n      case 'V': /* set vertical resolution to new value */\n\t\tpage->vres = atof (optarg);\n                page->mode |= PAGE_MODE_RESOLUTION;\n\t\tbreak;\n      case 'X':\t/* selection width */\n\t\tcrop_data->crop_mode |= CROP_WIDTH;\n\t\tcrop_data->width = atof(optarg);\n\t\tbreak;\n      case 'Y':\t/* selection length */\n\t\tcrop_data->crop_mode |= CROP_LENGTH;\n\t\tcrop_data->length = atof(optarg);\n\t\tbreak;\n      case 'Z': /* zones of an image X:Y read as zone X of Y */\n\t\tcrop_data->crop_mode |= CROP_ZONES;\n\t\tfor (i = 0, opt_ptr = strtok (optarg, \",\");\n                   ((opt_ptr != NULL) &&  (i < MAX_REGIONS));\n                    (opt_ptr = strtok (NULL, \",\")), i++)\n                    {\n\t\t    crop_data->zones++;\n\t\t    opt_offset = strchr(opt_ptr, ':');\n\t\t    if (!opt_offset) {\n\t\t\tTIFFError(\"Wrong parameter syntax for -Z\", \"tiffcrop -h\");\n\t\t\texit(EXIT_FAILURE);\n\t\t    }\n                    *opt_offset = '\\0';\n                    crop_data->zonelist[i].position = atoi(opt_ptr);\n                    crop_data->zonelist[i].total    = atoi(opt_offset + 1);\n                    }\n                /*  check for remaining elements over MAX_REGIONS */\n                if ((opt_ptr != NULL) && (i >= MAX_REGIONS))\n                  {\n\t\t  TIFFError(\"Zone list exceeds region limit\", \"%d\",  MAX_REGIONS);\n\t\t  exit (EXIT_FAILURE);\n                  }\n\t\tbreak;\n    case '?':\tTIFFError (\"For valid options type\", \"tiffcrop -h\");\n                exit (EXIT_FAILURE);\n\t\t/*NOTREACHED*/\n      }\n    }\n    /*-- Check for not allowed combinations (e.g. -X, -Y and -Z, -z and -S are mutually exclusive) --*/\n    char XY, Z, R, S;\n    XY = ((crop_data->crop_mode & CROP_WIDTH) || (crop_data->crop_mode & CROP_LENGTH));\n    Z = (crop_data->crop_mode & CROP_ZONES);\n    R = (crop_data->crop_mode & CROP_REGIONS);\n    S = (page->mode & PAGE_MODE_ROWSCOLS);\n    if ((XY && Z) || (XY && R) || (XY && S) || (Z && R) || (Z && S) || (R && S)) {\n        TIFFError(\"tiffcrop input error\", \"The crop options(-X|-Y), -Z, -z and -S are mutually exclusive.->Exit\");\n        exit(EXIT_FAILURE);\n    }\n  }",
        "func": "void  process_command_opts (int argc, char *argv[], char *mp, char *mode, uint32_t *dirnum,\n                            uint16_t *defconfig, uint16_t *deffillorder, uint32_t *deftilewidth,\n                            uint32_t *deftilelength, uint32_t *defrowsperstrip,\n                            struct crop_mask *crop_data, struct pagedef *page,\n                            struct dump_opts *dump,\n                            unsigned int     *imagelist, unsigned int   *image_count )\n    {\n    int   c, good_args = 0;\n    char *opt_offset   = NULL;    /* Position in string of value sought */\n    char *opt_ptr      = NULL;    /* Pointer to next token in option set */\n    char *sep          = NULL;    /* Pointer to a token separator */\n    unsigned int  i, j, start, end;\n#if !HAVE_DECL_OPTARG\n    extern int   optind;\n    extern char* optarg;\n#endif\n\n    *mp++ = 'w';\n    *mp = '\\0';\n    while ((c = getopt(argc, argv,\n       \"ac:d:e:f:hik:l:m:p:r:stvw:z:BCD:E:F:H:I:J:K:LMN:O:P:R:S:U:V:X:Y:Z:\")) != -1)\n      {\n    good_args++;\n    switch (c) {\n      case 'a': mode[0] = 'a';\t/* append to output */\n\t\tbreak;\n      case 'c':\tif (!processCompressOptions(optarg)) /* compression scheme */\n\t\t  {\n\t\t  TIFFError (\"Unknown compression option\", \"%s\", optarg);\n                  TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                  exit (EXIT_FAILURE);\n                  }\n\t\tbreak;\n      case 'd':\tstart = strtoul(optarg, NULL, 0); /* initial IFD offset */\n\t        if (start == 0)\n                  {\n\t\t  TIFFError (\"\",\"Directory offset must be greater than zero\");\n\t\t  TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                  exit (EXIT_FAILURE);\n\t\t  }\n\t        *dirnum = start - 1;\n\t\tbreak;\n      case 'e': switch (tolower((int) optarg[0])) /* image export modes*/\n                  {\n\t\t  case 'c': crop_data->exp_mode = ONE_FILE_COMPOSITE;\n \t\t            crop_data->img_mode = COMPOSITE_IMAGES;\n\t\t            break; /* Composite */\n\t\t  case 'd': crop_data->exp_mode = ONE_FILE_SEPARATED;\n \t\t            crop_data->img_mode = SEPARATED_IMAGES;\n\t\t            break; /* Divided */\n\t\t  case 'i': crop_data->exp_mode = FILE_PER_IMAGE_COMPOSITE;\n \t\t            crop_data->img_mode = COMPOSITE_IMAGES;\n\t\t            break; /* Image */\n\t\t  case 'm': crop_data->exp_mode = FILE_PER_IMAGE_SEPARATED;\n \t\t            crop_data->img_mode = SEPARATED_IMAGES;\n\t\t            break; /* Multiple */\n\t\t  case 's': crop_data->exp_mode = FILE_PER_SELECTION;\n \t\t            crop_data->img_mode = SEPARATED_IMAGES;\n\t\t            break; /* Sections */\n\t\t  default:  TIFFError (\"Unknown export mode\",\"%s\", optarg);\n                            TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                            exit (EXIT_FAILURE);\n                  }\n\t        break;\n      case 'f':\tif (streq(optarg, \"lsb2msb\"))\t   /* fill order */\n\t\t  *deffillorder = FILLORDER_LSB2MSB;\n\t\telse if (streq(optarg, \"msb2lsb\"))\n\t\t  *deffillorder = FILLORDER_MSB2LSB;\n\t\telse\n\t\t  {\n\t\t  TIFFError (\"Unknown fill order\", \"%s\", optarg);\n                  TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                  exit (EXIT_FAILURE);\n                  }\n\t\tbreak;\n      case 'h':\tusage(EXIT_SUCCESS);\n\t\tbreak;\n      case 'i':\tignore = TRUE;\t\t/* ignore errors */\n\t\tbreak;\n      case 'k':\tmaxMalloc = (tmsize_t)strtoul(optarg, NULL, 0) << 20;\n\t\tbreak;\n      case 'l':\touttiled = TRUE;\t /* tile length */\n\t\t*deftilelength = atoi(optarg);\n\t\tbreak;\n      case 'p': /* planar configuration */\n\t\tif (streq(optarg, \"separate\"))\n\t\t  *defconfig = PLANARCONFIG_SEPARATE;\n\t\telse if (streq(optarg, \"contig\"))\n\t\t  *defconfig = PLANARCONFIG_CONTIG;\n\t\telse\n\t\t  {\n\t\t  TIFFError (\"Unknown planar configuration\", \"%s\", optarg);\n                  TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                  exit (EXIT_FAILURE);\n                  }\n\t\tbreak;\n      case 'r':\t/* rows/strip */\n\t\t*defrowsperstrip = atol(optarg);\n\t\tbreak;\n      case 's':\t/* generate stripped output */\n\t\touttiled = FALSE;\n\t\tbreak;\n      case 't':\t/* generate tiled output */\n\t\touttiled = TRUE;\n\t\tbreak;\n      case 'v': printf(\"Library Release: %s\\n\", TIFFGetVersion());\n                printf(\"Tiffcrop version: %s, last updated: %s\\n\",\n\t\t\t   tiffcrop_version_id, tiffcrop_rev_date);\n\t        printf(\"Tiffcp code: Copyright (c) 1988-1997 Sam Leffler\\n\");\n\t\tprintf(\"           : Copyright (c) 1991-1997 Silicon Graphics, Inc\\n\");\n                printf(\"Tiffcrop additions: Copyright (c) 2007-2010 Richard Nolde\\n\");\n\t        exit (EXIT_SUCCESS);\n\t\tbreak;\n      case 'w':\t/* tile width */\n\t\touttiled = TRUE;\n\t\t*deftilewidth = atoi(optarg);\n\t\tbreak;\n      case 'z': /* regions of an image specified as x1,y1,x2,y2:x3,y3,x4,y4 etc */\n\t        crop_data->crop_mode |= CROP_REGIONS;\n\t\tfor (i = 0, opt_ptr = strtok (optarg, \":\");\n                   ((opt_ptr != NULL) &&  (i < MAX_REGIONS));\n                    (opt_ptr = strtok (NULL, \":\")), i++)\n                    {\n\t\t    crop_data->regions++;\n                    if (sscanf(opt_ptr, \"%lf,%lf,%lf,%lf\",\n\t\t\t       &crop_data->corners[i].X1, &crop_data->corners[i].Y1,\n\t\t\t       &crop_data->corners[i].X2, &crop_data->corners[i].Y2) != 4)\n                      {\n                      TIFFError (\"Unable to parse coordinates for region\", \"%u %s\", i, optarg);\n\t\t      TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                      exit (EXIT_FAILURE);\n\t\t      }\n                    }\n                /*  check for remaining elements over MAX_REGIONS */\n                if ((opt_ptr != NULL) && (i >= MAX_REGIONS))\n                  {\n\t\t  TIFFError (\"Region list exceeds limit of\", \"%d regions %s\", MAX_REGIONS, optarg);\n\t\t  TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                  exit (EXIT_FAILURE);;\n                  }\n\t\tbreak;\n      /* options for file open modes */\n      case 'B': *mp++ = 'b'; *mp = '\\0';\n\t\tbreak;\n      case 'L': *mp++ = 'l'; *mp = '\\0';\n\t\tbreak;\n      case 'M': *mp++ = 'm'; *mp = '\\0';\n\t\tbreak;\n      case 'C': *mp++ = 'c'; *mp = '\\0';\n\t\tbreak;\n      /* options for Debugging / data dump */\n      case 'D': for (i = 0, opt_ptr = strtok (optarg, \",\");\n                    (opt_ptr != NULL);\n                    (opt_ptr = strtok (NULL, \",\")), i++)\n                    {\n\t\t    opt_offset = strpbrk(opt_ptr, \":=\");\n                    if (opt_offset == NULL)\n                      {\n                      TIFFError(\"Invalid dump option\", \"%s\", optarg);\n                      TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                      exit (EXIT_FAILURE);\n\t\t      }\n                      \n                    *opt_offset = '\\0';\n                    /* convert option to lowercase */\n                    end = strlen (opt_ptr);\n                    for (i = 0; i < end; i++)\n                      *(opt_ptr + i) = tolower((int) *(opt_ptr + i));\n                    /* Look for dump format specification */\n                    if (strncmp(opt_ptr, \"for\", 3) == 0)\n                      {\n\t\t      /* convert value to lowercase */\n                      end = strlen (opt_offset + 1);\n                      for (i = 1; i <= end; i++)\n                        *(opt_offset + i) = tolower((int) *(opt_offset + i));\n                      /* check dump format value */\n\t\t      if (strncmp (opt_offset + 1, \"txt\", 3) == 0)\n                        {\n                        dump->format = DUMP_TEXT;\n                        strcpy (dump->mode, \"w\");\n                        }\n                      else\n                        {\n\t\t        if (strncmp(opt_offset + 1, \"raw\", 3) == 0)\n                          {\n                          dump->format = DUMP_RAW;\n                          strcpy (dump->mode, \"wb\");\n                          }\n                        else\n                          {\n                          TIFFError(\"parse_command_opts\", \"Unknown dump format %s\", opt_offset + 1);\n                          TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                          exit (EXIT_FAILURE);\n\t\t          }\n\t\t\t}\n                      }\n\t\t    else\n                      { /* Look for dump level specification */\n                      if (strncmp (opt_ptr, \"lev\", 3) == 0)\n                        dump->level = atoi(opt_offset + 1);\n                        /* Look for input data dump file name */\n                      if (strncmp (opt_ptr, \"in\", 2) == 0)\n\t\t        {\n                        strncpy (dump->infilename, opt_offset + 1, PATH_MAX - 20);\n                        dump->infilename[PATH_MAX - 20] = '\\0';\n                        }\n                        /* Look for output data dump file name */\n                      if (strncmp (opt_ptr, \"out\", 3) == 0)\n\t\t\t{\n                        strncpy (dump->outfilename, opt_offset + 1, PATH_MAX - 20);\n                        dump->outfilename[PATH_MAX - 20] = '\\0';\n                        }\n                      if (strncmp (opt_ptr, \"deb\", 3) == 0)\n\t\t\tdump->debug = atoi(opt_offset + 1);\n\t\t      }\n                    }\n\t        if ((strlen(dump->infilename)) || (strlen(dump->outfilename)))\n                  {\n\t\t  if (dump->level == 1)\n                    TIFFError(\"\",\"Defaulting to dump level 1, no data.\");\n\t          if (dump->format == DUMP_NONE)\n                    {\n\t\t    TIFFError(\"\", \"You must specify a dump format for dump files\");\n\t\t    TIFFError (\"For valid options type\", \"tiffcrop -h\");\n\t\t    exit (EXIT_FAILURE);\n\t\t    }\n                  }\n\t        break;\n\n      /* image manipulation routine options */\n      case 'm': /* margins to exclude from selection, uppercase M was already used */\n\t\t/* order of values must be TOP, LEFT, BOTTOM, RIGHT */\n\t\tcrop_data->crop_mode |= CROP_MARGINS;\n                for (i = 0, opt_ptr = strtok (optarg, \",:\");\n                    ((opt_ptr != NULL) &&  (i < 4));\n                     (opt_ptr = strtok (NULL, \",:\")), i++)\n                    {\n\t\t    crop_data->margins[i] = atof(opt_ptr);\n                    }\n\t\tbreak;\n      case 'E':\t/* edge reference */\n\t\tswitch (tolower((int) optarg[0]))\n                  {\n\t\t  case 't': crop_data->edge_ref = EDGE_TOP;\n                            break;\n                  case 'b': crop_data->edge_ref = EDGE_BOTTOM;\n                             break;\n                  case 'l': crop_data->edge_ref = EDGE_LEFT;\n                            break;\n                  case 'r': crop_data->edge_ref = EDGE_RIGHT;\n                            break;\n\t\t  default:  TIFFError (\"Edge reference must be top, bottom, left, or right\", \"%s\", optarg);\n\t\t\t    TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                            exit (EXIT_FAILURE);\n\t\t  }\n\t\tbreak;\n      case 'F': /* flip eg mirror image or cropped segment, M was already used */\n\t\tcrop_data->crop_mode |= CROP_MIRROR;\n\t\tswitch (tolower((int) optarg[0]))\n                  {\n\t\t  case  'h': crop_data->mirror = MIRROR_HORIZ;\n                             break;\n                  case  'v': crop_data->mirror = MIRROR_VERT;\n                             break;\n                  case  'b': crop_data->mirror = MIRROR_BOTH;\n                             break;\n\t\t  default:   TIFFError (\"Flip mode must be horiz, vert, or both\", \"%s\", optarg);\n\t\t\t     TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                             exit (EXIT_FAILURE);\n\t\t  }\n\t\tbreak;\n      case 'H': /* set horizontal resolution to new value */\n\t\tpage->hres = atof (optarg);\n                page->mode |= PAGE_MODE_RESOLUTION;\n\t\tbreak;\n      case 'I': /* invert the color space, eg black to white */\n\t\tcrop_data->crop_mode |= CROP_INVERT;\n                /* The PHOTOMETIC_INTERPRETATION tag may be updated */\n                if (streq(optarg, \"black\"))\n                  {\n\t\t  crop_data->photometric = PHOTOMETRIC_MINISBLACK;\n\t\t  continue;\n                  }\n                if (streq(optarg, \"white\"))\n                  {\n\t\t  crop_data->photometric = PHOTOMETRIC_MINISWHITE;\n                  continue;\n                  }\n                if (streq(optarg, \"data\")) \n                  {\n\t\t  crop_data->photometric = INVERT_DATA_ONLY;\n                  continue;\n                  }\n                if (streq(optarg, \"both\"))\n                  {\n\t\t  crop_data->photometric = INVERT_DATA_AND_TAG;\n                  continue;\n                  }\n\n\t\tTIFFError(\"Missing or unknown option for inverting PHOTOMETRIC_INTERPRETATION\", \"%s\", optarg);\n\t\tTIFFError (\"For valid options type\", \"tiffcrop -h\");\n                exit (EXIT_FAILURE);\n\t\tbreak;\n      case 'J': /* horizontal margin for sectioned output pages */\n\t\tpage->hmargin = atof(optarg);\n                page->mode |= PAGE_MODE_MARGINS;\n\t\tbreak;\n      case 'K': /* vertical margin for sectioned output pages*/\n                page->vmargin = atof(optarg);\n                page->mode |= PAGE_MODE_MARGINS;\n\t\tbreak;\n      case 'N':\t/* list of images to process */\n                for (i = 0, opt_ptr = strtok (optarg, \",\");\n                    ((opt_ptr != NULL) &&  (i < MAX_IMAGES));\n                     (opt_ptr = strtok (NULL, \",\")))\n                     { /* We do not know how many images are in file yet \n\t\t\t* so we build a list to include the maximum allowed\n                        * and follow it until we hit the end of the file.\n                        * Image count is not accurate for odd, even, last\n                        * so page numbers won't be valid either.\n                        */\n\t\t     if (streq(opt_ptr, \"odd\"))\n                       {\n\t\t       for (j = 1; j <= MAX_IMAGES; j += 2)\n\t\t\t imagelist[i++] = j;\n                       *image_count = (MAX_IMAGES - 1) / 2;\n                       break;\n\t\t       }\n\t\t     else\n                       {\n\t\t       if (streq(opt_ptr, \"even\"))\n                         {\n\t\t\t for (j = 2; j <= MAX_IMAGES; j += 2)\n\t\t\t   imagelist[i++] = j;\n                         *image_count = MAX_IMAGES / 2;\n                         break;\n\t\t\t }\n\t\t       else\n                         {\n\t\t\t if (streq(opt_ptr, \"last\"))\n\t\t\t   imagelist[i++] = MAX_IMAGES;\n\t\t\t else  /* single value between commas */\n\t\t\t   {\n\t\t\t   sep = strpbrk(opt_ptr, \":-\");\n\t\t\t   if (!sep)\n\t\t\t     imagelist[i++] = atoi(opt_ptr);\n                           else\n                             {\n\t\t\t     *sep = '\\0';\n                             start = atoi (opt_ptr);\n                             if (!strcmp((sep + 1), \"last\"))\n\t\t\t       end = MAX_IMAGES;\n                             else\n                               end = atoi (sep + 1);\n                             for (j = start; j <= end && j - start + i < MAX_IMAGES; j++)\n\t\t\t       imagelist[i++] = j;\n\t\t\t     }\n\t\t\t   }\n\t\t\t }\n\t\t      }\n\t\t    }\n                *image_count = i;\n\t\tbreak;\n      case 'O': /* page orientation */ \n\t\tswitch (tolower((int) optarg[0]))\n                  {\n\t\t  case  'a': page->orient = ORIENTATION_AUTO;\n                             break;\n\t\t  case  'p': page->orient = ORIENTATION_PORTRAIT;\n                             break;\n\t\t  case  'l': page->orient = ORIENTATION_LANDSCAPE;\n                             break;\n\t\t  default:  TIFFError (\"Orientation must be portrait, landscape, or auto.\", \"%s\", optarg);\n\t\t\t    TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                            exit (EXIT_FAILURE);\n\t\t  }\n\t\tbreak;\n      case 'P': /* page size selection */ \n\t        if (sscanf(optarg, \"%lfx%lf\", &page->width, &page->length) == 2)\n                  {\n                  strcpy (page->name, \"Custom\"); \n                  page->mode |= PAGE_MODE_PAPERSIZE;\n                  break;\n                  }\n                if (get_page_geometry (optarg, page))\n                  {\n\t\t  if (!strcmp(optarg, \"list\"))\n                    {\n\t\t    TIFFError(\"\", \"Name            Width   Length (in inches)\");\n                    for (i = 0; i < MAX_PAPERNAMES - 1; i++)\n                      TIFFError (\"\", \"%-15.15s %5.2f   %5.2f\", \n\t\t\t       PaperTable[i].name, PaperTable[i].width, \n                               PaperTable[i].length);\n\t\t    exit (EXIT_FAILURE);\n                    }\n     \n\t\t  TIFFError (\"Invalid paper size\", \"%s\", optarg);\n                  TIFFError (\"\", \"Select one of:\");\n\t\t  TIFFError(\"\", \"Name            Width   Length (in inches)\");\n                  for (i = 0; i < MAX_PAPERNAMES - 1; i++)\n                    TIFFError (\"\", \"%-15.15s %5.2f   %5.2f\", \n\t\t\t       PaperTable[i].name, PaperTable[i].width, \n                               PaperTable[i].length);\n\t\t  exit (EXIT_FAILURE);\n\t\t  }\n\t\telse\n                  {\n                  page->mode |= PAGE_MODE_PAPERSIZE;\n\t\t  }\n\t\tbreak;\n      case 'R': /* rotate image or cropped segment */\n\t\tcrop_data->crop_mode |= CROP_ROTATE;\n\t\tswitch (strtoul(optarg, NULL, 0))\n                  {\n\t\t  case  90:  crop_data->rotation = (uint16_t)90;\n                             break;\n                  case  180: crop_data->rotation = (uint16_t)180;\n                             break;\n                  case  270: crop_data->rotation = (uint16_t)270;\n                             break;\n\t\t  default:   TIFFError (\"Rotation must be 90, 180, or 270 degrees clockwise\", \"%s\", optarg);\n\t\t\t     TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                             exit (EXIT_FAILURE);\n\t\t  }\n\t\tbreak;\n      case 'S':\t/* subdivide into Cols:Rows sections, eg 3:2 would be 3 across and 2 down */\n\t\tsep = strpbrk(optarg, \",:\");\n\t\tif (sep)\n                  {\n                  *sep = '\\0';\n                  page->cols = atoi(optarg);\n                  page->rows = atoi(sep +1);\n\t\t  }\n                else\n                  {\n                  page->cols = atoi(optarg);\n                  page->rows = atoi(optarg);\n\t\t  }\n                if ((page->cols * page->rows) > MAX_SECTIONS)\n                  {\n\t\t  TIFFError (\"Limit for subdivisions, ie rows x columns, exceeded\", \"%d\", MAX_SECTIONS);\n\t\t  exit (EXIT_FAILURE);\n                  }\n                page->mode |= PAGE_MODE_ROWSCOLS;\n\t\tbreak;\n      case 'U':\t/* units for measurements and offsets */\n\t\tif (streq(optarg, \"in\"))\n                  {\n\t\t  crop_data->res_unit = RESUNIT_INCH;\n\t\t  page->res_unit = RESUNIT_INCH;\n\t\t  }\n\t\telse if (streq(optarg, \"cm\"))\n\t\t  {\n\t\t  crop_data->res_unit = RESUNIT_CENTIMETER;\n\t\t  page->res_unit = RESUNIT_CENTIMETER;\n\t\t  }\n\t\telse if (streq(optarg, \"px\"))\n\t\t  {\n\t\t  crop_data->res_unit = RESUNIT_NONE;\n\t\t  page->res_unit = RESUNIT_NONE;\n\t\t  }\n\t\telse\n                  {\n\t\t  TIFFError (\"Illegal unit of measure\",\"%s\", optarg);\n\t\t  TIFFError (\"For valid options type\", \"tiffcrop -h\");\n                  exit (EXIT_FAILURE);\n\t\t  }\n\t\tbreak;\n      case 'V': /* set vertical resolution to new value */\n\t\tpage->vres = atof (optarg);\n                page->mode |= PAGE_MODE_RESOLUTION;\n\t\tbreak;\n      case 'X':\t/* selection width */\n\t\tcrop_data->crop_mode |= CROP_WIDTH;\n\t\tcrop_data->width = atof(optarg);\n\t\tbreak;\n      case 'Y':\t/* selection length */\n\t\tcrop_data->crop_mode |= CROP_LENGTH;\n\t\tcrop_data->length = atof(optarg);\n\t\tbreak;\n      case 'Z': /* zones of an image X:Y read as zone X of Y */\n\t\tcrop_data->crop_mode |= CROP_ZONES;\n\t\tfor (i = 0, opt_ptr = strtok (optarg, \",\");\n                   ((opt_ptr != NULL) &&  (i < MAX_REGIONS));\n                    (opt_ptr = strtok (NULL, \",\")), i++)\n                    {\n\t\t    crop_data->zones++;\n\t\t    opt_offset = strchr(opt_ptr, ':');\n\t\t    if (!opt_offset) {\n\t\t\tTIFFError(\"Wrong parameter syntax for -Z\", \"tiffcrop -h\");\n\t\t\texit(EXIT_FAILURE);\n\t\t    }\n                    *opt_offset = '\\0';\n                    crop_data->zonelist[i].position = atoi(opt_ptr);\n                    crop_data->zonelist[i].total    = atoi(opt_offset + 1);\n                    }\n                /*  check for remaining elements over MAX_REGIONS */\n                if ((opt_ptr != NULL) && (i >= MAX_REGIONS))\n                  {\n\t\t  TIFFError(\"Zone list exceeds region limit\", \"%d\",  MAX_REGIONS);\n\t\t  exit (EXIT_FAILURE);\n                  }\n\t\tbreak;\n    case '?':\tTIFFError (\"For valid options type\", \"tiffcrop -h\");\n                exit (EXIT_FAILURE);\n\t\t/*NOTREACHED*/\n      }\n    }\n    /*-- Check for not allowed combinations (e.g. -X, -Y and -Z, -z and -S are mutually exclusive) --*/\n    char XY, Z, R, S;\n    XY = ((crop_data->crop_mode & CROP_WIDTH) || (crop_data->crop_mode & CROP_LENGTH)) ? 1 : 0;\n    Z = (crop_data->crop_mode & CROP_ZONES) ? 1 : 0;\n    R = (crop_data->crop_mode & CROP_REGIONS) ? 1 : 0;\n    S = (page->mode & PAGE_MODE_ROWSCOLS) ? 1 : 0;\n    if (XY + Z + R + S > 1) {\n        TIFFError(\"tiffcrop input error\", \"The crop options(-X|-Y), -Z, -z and -S are mutually exclusive.->Exit\");\n        exit(EXIT_FAILURE);\n    }\n  }",
        "diff_func": "--- func_before\n+++ func_after\n@@ -508,11 +508,11 @@\n     }\n     /*-- Check for not allowed combinations (e.g. -X, -Y and -Z, -z and -S are mutually exclusive) --*/\n     char XY, Z, R, S;\n-    XY = ((crop_data->crop_mode & CROP_WIDTH) || (crop_data->crop_mode & CROP_LENGTH));\n-    Z = (crop_data->crop_mode & CROP_ZONES);\n-    R = (crop_data->crop_mode & CROP_REGIONS);\n-    S = (page->mode & PAGE_MODE_ROWSCOLS);\n-    if ((XY && Z) || (XY && R) || (XY && S) || (Z && R) || (Z && S) || (R && S)) {\n+    XY = ((crop_data->crop_mode & CROP_WIDTH) || (crop_data->crop_mode & CROP_LENGTH)) ? 1 : 0;\n+    Z = (crop_data->crop_mode & CROP_ZONES) ? 1 : 0;\n+    R = (crop_data->crop_mode & CROP_REGIONS) ? 1 : 0;\n+    S = (page->mode & PAGE_MODE_ROWSCOLS) ? 1 : 0;\n+    if (XY + Z + R + S > 1) {\n         TIFFError(\"tiffcrop input error\", \"The crop options(-X|-Y), -Z, -z and -S are mutually exclusive.->Exit\");\n         exit(EXIT_FAILURE);\n     }",
        "diff_line_info": {
            "deleted_lines": [
                "    XY = ((crop_data->crop_mode & CROP_WIDTH) || (crop_data->crop_mode & CROP_LENGTH));",
                "    Z = (crop_data->crop_mode & CROP_ZONES);",
                "    R = (crop_data->crop_mode & CROP_REGIONS);",
                "    S = (page->mode & PAGE_MODE_ROWSCOLS);",
                "    if ((XY && Z) || (XY && R) || (XY && S) || (Z && R) || (Z && S) || (R && S)) {"
            ],
            "added_lines": [
                "    XY = ((crop_data->crop_mode & CROP_WIDTH) || (crop_data->crop_mode & CROP_LENGTH)) ? 1 : 0;",
                "    Z = (crop_data->crop_mode & CROP_ZONES) ? 1 : 0;",
                "    R = (crop_data->crop_mode & CROP_REGIONS) ? 1 : 0;",
                "    S = (page->mode & PAGE_MODE_ROWSCOLS) ? 1 : 0;",
                "    if (XY + Z + R + S > 1) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-36043",
        "func_name": "rizinorg/rizin/relocs",
        "description": "Rizin is a UNIX-like reverse engineering framework and command-line toolset. Versions 0.4.0 and prior are vulnerable to a double free in bobj.c:rz_bin_reloc_storage_free() when freeing relocations generated from qnx binary plugin. A user opening a malicious qnx binary could be affected by this vulnerability, allowing an attacker to execute code on the user's machine. Commit number a3d50c1ea185f3f642f2d8180715f82d98840784 contains a patch for this issue.",
        "git_url": "https://github.com/rizinorg/rizin/commit/a3d50c1ea185f3f642f2d8180715f82d98840784",
        "commit_title": "fix #2964 - double-free in bin_qnx.c",
        "commit_text": "",
        "func_before": "static RzList *relocs(RzBinFile *bf) {\n\trz_return_val_if_fail(bf && bf->o, NULL);\n\tQnxObj *qo = bf->o->bin_obj;\n\treturn rz_list_clone(qo->fixups);\n}",
        "func": "static RzList *relocs(RzBinFile *bf) {\n\trz_return_val_if_fail(bf && bf->o, NULL);\n\tQnxObj *qo = bf->o->bin_obj;\n\tRzBinReloc *reloc = NULL;\n\tRzListIter *it = NULL;\n\tRzList *relocs = rz_list_newf(free);\n\tif (!relocs) {\n\t\treturn NULL;\n\t}\n\n\trz_list_foreach (qo->fixups, it, reloc) {\n\t\tRzBinReloc *copy = RZ_NEW0(RzBinReloc);\n\t\tcopy->vaddr = reloc->vaddr;\n\t\tcopy->paddr = reloc->paddr;\n\t\tcopy->type = reloc->type;\n\t\trz_list_append(relocs, copy);\n\t}\n\treturn relocs;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,19 @@\n static RzList *relocs(RzBinFile *bf) {\n \trz_return_val_if_fail(bf && bf->o, NULL);\n \tQnxObj *qo = bf->o->bin_obj;\n-\treturn rz_list_clone(qo->fixups);\n+\tRzBinReloc *reloc = NULL;\n+\tRzListIter *it = NULL;\n+\tRzList *relocs = rz_list_newf(free);\n+\tif (!relocs) {\n+\t\treturn NULL;\n+\t}\n+\n+\trz_list_foreach (qo->fixups, it, reloc) {\n+\t\tRzBinReloc *copy = RZ_NEW0(RzBinReloc);\n+\t\tcopy->vaddr = reloc->vaddr;\n+\t\tcopy->paddr = reloc->paddr;\n+\t\tcopy->type = reloc->type;\n+\t\trz_list_append(relocs, copy);\n+\t}\n+\treturn relocs;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\treturn rz_list_clone(qo->fixups);"
            ],
            "added_lines": [
                "\tRzBinReloc *reloc = NULL;",
                "\tRzListIter *it = NULL;",
                "\tRzList *relocs = rz_list_newf(free);",
                "\tif (!relocs) {",
                "\t\treturn NULL;",
                "\t}",
                "",
                "\trz_list_foreach (qo->fixups, it, reloc) {",
                "\t\tRzBinReloc *copy = RZ_NEW0(RzBinReloc);",
                "\t\tcopy->vaddr = reloc->vaddr;",
                "\t\tcopy->paddr = reloc->paddr;",
                "\t\tcopy->type = reloc->type;",
                "\t\trz_list_append(relocs, copy);",
                "\t}",
                "\treturn relocs;"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-0699",
        "func_name": "OSGeo/shapelib/split",
        "description": "A double-free condition exists in contrib/shpsort.c of shapelib 1.5.0 and older releases. This issue may allow an attacker to cause a denial of service or have other unspecified impact via control over malloc.",
        "git_url": "https://github.com/OSGeo/shapelib/commit/c75b9281a5b9452d92e1682bdfe6019a13ed819f",
        "commit_title": "Remove double free() in contrib/shpsrt, issue #39",
        "commit_text": " This fixes issue #39",
        "func_before": "static char ** split(const char *arg, const char *delim) {\n  char *copy = dupstr(arg);\n  char **result = NULL;\n  int i = 0;\n\n  for (char *cptr = strtok(copy, delim); cptr; cptr = strtok(NULL, delim)) {\n    char **tmp = realloc (result, sizeof *result * (i + 1));\n    if (!tmp && result) {\n      while (i > 0) {\n\tfree(result[--i]);\n      }\n      free(result);\n      free(copy);\n      return NULL;\n    }\n    result = tmp;\n    result[i++] = dupstr(cptr);\n  }\n\n  free(copy);\n\n  if (i) {\n    char **tmp = realloc(result, sizeof *result * (i + 1));\n    if (!tmp) {\n      while (i > 0) {\n\tfree(result[--i]);\n      }\n      free(result);\n      free(copy);\n      return NULL;\n    }\n    result = tmp;\n    result[i++] = NULL;\n  }\n\n  return result;\n}",
        "func": "static char ** split(const char *arg, const char *delim) {\n  char *copy = dupstr(arg);\n  char **result = NULL;\n  int i = 0;\n\n  for (char *cptr = strtok(copy, delim); cptr; cptr = strtok(NULL, delim)) {\n    char **tmp = realloc (result, sizeof *result * (i + 1));\n    if (!tmp && result) {\n      while (i > 0) {\n\tfree(result[--i]);\n      }\n      free(result);\n      free(copy);\n      return NULL;\n    }\n    result = tmp;\n    result[i++] = dupstr(cptr);\n  }\n\n  free(copy);\n\n  if (i) {\n    char **tmp = realloc(result, sizeof *result * (i + 1));\n    if (!tmp) {\n      while (i > 0) {\n\tfree(result[--i]);\n      }\n      free(result);\n      return NULL;\n    }\n    result = tmp;\n    result[i++] = NULL;\n  }\n\n  return result;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -26,7 +26,6 @@\n \tfree(result[--i]);\n       }\n       free(result);\n-      free(copy);\n       return NULL;\n     }\n     result = tmp;",
        "diff_line_info": {
            "deleted_lines": [
                "      free(copy);"
            ],
            "added_lines": []
        }
    },
    {
        "cve_id": "CVE-2022-3595",
        "func_name": "torvalds/linux/sess_free_buffer",
        "description": "A vulnerability was found in Linux Kernel. It has been rated as problematic. Affected by this issue is the function sess_free_buffer of the file fs/cifs/sess.c of the component CIFS Handler. The manipulation leads to double free. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-211364.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?h=b854b4ee66437e6e1622fda90529c814978cb4ca",
        "commit_title": "The crash occurred because we were calling memzero_explicit() on an",
        "commit_text": "already freed sess_data::iov[1] (ntlmsspblob) in sess_free_buffer().  Fix this by not calling memzero_explicit() on sess_data::iov[1] as it's already by handled by callers.  ",
        "func_before": "static void\nsess_free_buffer(struct sess_data *sess_data)\n{\n\tint i;\n\n\t/* zero the session data before freeing, as it might contain sensitive info (keys, etc) */\n\tfor (i = 0; i < 3; i++)\n\t\tif (sess_data->iov[i].iov_base)\n\t\t\tmemzero_explicit(sess_data->iov[i].iov_base, sess_data->iov[i].iov_len);\n\n\tfree_rsp_buf(sess_data->buf0_type, sess_data->iov[0].iov_base);\n\tsess_data->buf0_type = CIFS_NO_BUFFER;\n\tkfree(sess_data->iov[2].iov_base);\n}",
        "func": "static void\nsess_free_buffer(struct sess_data *sess_data)\n{\n\tstruct kvec *iov = sess_data->iov;\n\n\t/*\n\t * Zero the session data before freeing, as it might contain sensitive info (keys, etc).\n\t * Note that iov[1] is already freed by caller.\n\t */\n\tif (sess_data->buf0_type != CIFS_NO_BUFFER && iov[0].iov_base)\n\t\tmemzero_explicit(iov[0].iov_base, iov[0].iov_len);\n\n\tfree_rsp_buf(sess_data->buf0_type, iov[0].iov_base);\n\tsess_data->buf0_type = CIFS_NO_BUFFER;\n\tkfree_sensitive(iov[2].iov_base);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,14 +1,16 @@\n static void\n sess_free_buffer(struct sess_data *sess_data)\n {\n-\tint i;\n+\tstruct kvec *iov = sess_data->iov;\n \n-\t/* zero the session data before freeing, as it might contain sensitive info (keys, etc) */\n-\tfor (i = 0; i < 3; i++)\n-\t\tif (sess_data->iov[i].iov_base)\n-\t\t\tmemzero_explicit(sess_data->iov[i].iov_base, sess_data->iov[i].iov_len);\n+\t/*\n+\t * Zero the session data before freeing, as it might contain sensitive info (keys, etc).\n+\t * Note that iov[1] is already freed by caller.\n+\t */\n+\tif (sess_data->buf0_type != CIFS_NO_BUFFER && iov[0].iov_base)\n+\t\tmemzero_explicit(iov[0].iov_base, iov[0].iov_len);\n \n-\tfree_rsp_buf(sess_data->buf0_type, sess_data->iov[0].iov_base);\n+\tfree_rsp_buf(sess_data->buf0_type, iov[0].iov_base);\n \tsess_data->buf0_type = CIFS_NO_BUFFER;\n-\tkfree(sess_data->iov[2].iov_base);\n+\tkfree_sensitive(iov[2].iov_base);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tint i;",
                "\t/* zero the session data before freeing, as it might contain sensitive info (keys, etc) */",
                "\tfor (i = 0; i < 3; i++)",
                "\t\tif (sess_data->iov[i].iov_base)",
                "\t\t\tmemzero_explicit(sess_data->iov[i].iov_base, sess_data->iov[i].iov_len);",
                "\tfree_rsp_buf(sess_data->buf0_type, sess_data->iov[0].iov_base);",
                "\tkfree(sess_data->iov[2].iov_base);"
            ],
            "added_lines": [
                "\tstruct kvec *iov = sess_data->iov;",
                "\t/*",
                "\t * Zero the session data before freeing, as it might contain sensitive info (keys, etc).",
                "\t * Note that iov[1] is already freed by caller.",
                "\t */",
                "\tif (sess_data->buf0_type != CIFS_NO_BUFFER && iov[0].iov_base)",
                "\t\tmemzero_explicit(iov[0].iov_base, iov[0].iov_len);",
                "\tfree_rsp_buf(sess_data->buf0_type, iov[0].iov_base);",
                "\tkfree_sensitive(iov[2].iov_base);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-39432",
        "func_name": "DIPlib/diplib/ImageIsJPEG",
        "description": "diplib v3.0.0 is vulnerable to Double Free.",
        "git_url": "https://github.com/DIPlib/diplib/commit/8b9a2670ce66ff2fd5addf592f7825e1f5adb5b5",
        "commit_title": "Fixed error handling in `dip::ImageReadJPEG()`, `dip::ImageWriteJPEG()`, etc. Fixes #80.",
        "commit_text": "",
        "func_before": "bool ImageIsJPEG( String const& filename ) {\n   try {\n      JpegInput jpeg( filename );\n   } catch( ... ) {\n      return false;\n   }\n   return true;\n}",
        "func": "bool ImageIsJPEG( String const& filename ) {\n   try {\n      DIP__DECLARE_JPEG_EXIT( \"Error reading JPEG file\" );\n      JpegInput jpeg( filename, setjmp_buffer );\n   } catch( ... ) {\n      return false;\n   }\n   return true;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,7 @@\n bool ImageIsJPEG( String const& filename ) {\n    try {\n-      JpegInput jpeg( filename );\n+      DIP__DECLARE_JPEG_EXIT( \"Error reading JPEG file\" );\n+      JpegInput jpeg( filename, setjmp_buffer );\n    } catch( ... ) {\n       return false;\n    }",
        "diff_line_info": {
            "deleted_lines": [
                "      JpegInput jpeg( filename );"
            ],
            "added_lines": [
                "      DIP__DECLARE_JPEG_EXIT( \"Error reading JPEG file\" );",
                "      JpegInput jpeg( filename, setjmp_buffer );"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-39432",
        "func_name": "DIPlib/diplib/ImageReadJPEGInfo",
        "description": "diplib v3.0.0 is vulnerable to Double Free.",
        "git_url": "https://github.com/DIPlib/diplib/commit/8b9a2670ce66ff2fd5addf592f7825e1f5adb5b5",
        "commit_title": "Fixed error handling in `dip::ImageReadJPEG()`, `dip::ImageWriteJPEG()`, etc. Fixes #80.",
        "commit_text": "",
        "func_before": "FileInformation ImageReadJPEGInfo( String const& filename ) {\n   JpegInput jpeg( filename );\n   FileInformation info = GetJPEGInfo( jpeg );\n   return info;\n}",
        "func": "FileInformation ImageReadJPEGInfo( String const& filename ) {\n   DIP__DECLARE_JPEG_EXIT( \"Error reading JPEG file\" );\n   JpegInput jpeg( filename, setjmp_buffer );\n   FileInformation info = GetJPEGInfo( jpeg );\n   return info;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,6 @@\n FileInformation ImageReadJPEGInfo( String const& filename ) {\n-   JpegInput jpeg( filename );\n+   DIP__DECLARE_JPEG_EXIT( \"Error reading JPEG file\" );\n+   JpegInput jpeg( filename, setjmp_buffer );\n    FileInformation info = GetJPEGInfo( jpeg );\n    return info;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "   JpegInput jpeg( filename );"
            ],
            "added_lines": [
                "   DIP__DECLARE_JPEG_EXIT( \"Error reading JPEG file\" );",
                "   JpegInput jpeg( filename, setjmp_buffer );"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-39432",
        "func_name": "DIPlib/diplib/ImageWriteJPEG",
        "description": "diplib v3.0.0 is vulnerable to Double Free.",
        "git_url": "https://github.com/DIPlib/diplib/commit/8b9a2670ce66ff2fd5addf592f7825e1f5adb5b5",
        "commit_title": "Fixed error handling in `dip::ImageReadJPEG()`, `dip::ImageWriteJPEG()`, etc. Fixes #80.",
        "commit_text": "",
        "func_before": "void ImageWriteJPEG(\n      Image const& image,\n      String const& filename,\n      dip::uint jpegLevel\n) {\n   DIP_THROW_IF( !image.IsForged(), E::IMAGE_NOT_FORGED );\n   DIP_THROW_IF( image.Dimensionality() != 2, E::DIMENSIONALITY_NOT_SUPPORTED );\n   jpegLevel = clamp< dip::uint >( jpegLevel, 1, 100 );\n\n   // Open the file\n   JpegOutput jpeg( filename );\n\n   // Set image properties\n   int nchan = static_cast< int >( image.TensorElements() );\n   jpeg.cinfo().image_width = static_cast< JDIMENSION >( image.Size( 0 ));\n   jpeg.cinfo().image_height = static_cast< JDIMENSION >( image.Size( 1 ));\n   jpeg.cinfo().input_components = nchan;\n   jpeg.cinfo().in_color_space = nchan > 1 ? JCS_RGB : JCS_GRAYSCALE;\n   jpeg_set_defaults( jpeg.cinfoptr() );\n   jpeg_set_quality( jpeg.cinfoptr(), static_cast< int >( jpegLevel ), FALSE );\n   jpeg.cinfo().density_unit = 2; // dots per cm\n   jpeg.cinfo().X_density = static_cast< UINT16 >( 0.01 / image.PixelSize( 0 ).RemovePrefix().magnitude ); // let's assume it's meter\n   jpeg.cinfo().Y_density = static_cast< UINT16 >( 0.01 / image.PixelSize( 1 ).RemovePrefix().magnitude );\n\n   // Convert the image to uint8 if necessary\n   Image image_u8 = image.QuickCopy();\n   image_u8.Convert( DT_UINT8 );\n\n   // Write data\n   jpeg_start_compress( jpeg.cinfoptr(), TRUE );\n   std::vector< JSAMPLE > buffer( image.Size( 0 ) * static_cast< dip::uint >( nchan ));\n   dip::uint8* imagedata = static_cast< dip::uint8* >( image_u8.Origin() );\n   auto stride = image_u8.Strides();\n   auto tStride = image_u8.TensorStride();\n   for( dip::uint ii = 0; ii < image.Size( 1 ); ++ii ) {\n      JSAMPLE* outdata = buffer.data();\n      dip::uint8* indata = imagedata;\n      for( dip::uint jj = 0; jj < image.Size( 0 ); ++jj ) {\n         for( int kk = 0; kk < nchan; ++kk ) {\n            *outdata = *( indata + kk * tStride );\n            ++outdata;\n         }\n         indata += stride[ 0 ];\n      }\n      outdata = buffer.data();\n      jpeg_write_scanlines( jpeg.cinfoptr(), &outdata, 1 );\n      imagedata += stride[ 1 ];\n   }\n   jpeg_finish_compress( jpeg.cinfoptr());\n}",
        "func": "void ImageWriteJPEG(\n      Image const& image,\n      String const& filename,\n      dip::uint jpegLevel\n) {\n   DIP_THROW_IF( !image.IsForged(), E::IMAGE_NOT_FORGED );\n   DIP_THROW_IF( image.Dimensionality() != 2, E::DIMENSIONALITY_NOT_SUPPORTED );\n\n   // Open the file\n   DIP__DECLARE_JPEG_EXIT( \"Error writing JPEG file\" );\n   JpegOutput jpeg( filename, setjmp_buffer );\n\n   // Set image properties\n   int nchan = static_cast< int >( image.TensorElements() );\n   jpeg.cinfo().image_width = static_cast< JDIMENSION >( image.Size( 0 ));\n   jpeg.cinfo().image_height = static_cast< JDIMENSION >( image.Size( 1 ));\n   jpeg.cinfo().input_components = nchan;\n   jpeg.cinfo().in_color_space = nchan > 1 ? JCS_RGB : JCS_GRAYSCALE;\n   jpeg_set_defaults( jpeg.cinfoptr() );\n   jpeg_set_quality( jpeg.cinfoptr(), static_cast< int >( clamp< dip::uint >( jpegLevel, 1, 100 )), FALSE );\n   jpeg.cinfo().density_unit = 2; // dots per cm\n   jpeg.cinfo().X_density = static_cast< UINT16 >( 0.01 / image.PixelSize( 0 ).RemovePrefix().magnitude ); // let's assume it's meter\n   jpeg.cinfo().Y_density = static_cast< UINT16 >( 0.01 / image.PixelSize( 1 ).RemovePrefix().magnitude );\n\n   // Convert the image to uint8 if necessary\n   Image image_u8 = image.QuickCopy();\n   image_u8.Convert( DT_UINT8 );\n\n   // Write data\n   jpeg_start_compress( jpeg.cinfoptr(), TRUE );\n   std::vector< JSAMPLE > buffer( image.Size( 0 ) * static_cast< dip::uint >( nchan ));\n   dip::uint8* imagedata = static_cast< dip::uint8* >( image_u8.Origin() );\n   auto stride = image_u8.Strides();\n   auto tStride = image_u8.TensorStride();\n   for( dip::uint ii = 0; ii < image.Size( 1 ); ++ii ) {\n      JSAMPLE* outdata = buffer.data();\n      dip::uint8* indata = imagedata;\n      for( dip::uint jj = 0; jj < image.Size( 0 ); ++jj ) {\n         for( int kk = 0; kk < nchan; ++kk ) {\n            *outdata = *( indata + kk * tStride );\n            ++outdata;\n         }\n         indata += stride[ 0 ];\n      }\n      outdata = buffer.data();\n      jpeg_write_scanlines( jpeg.cinfoptr(), &outdata, 1 );\n      imagedata += stride[ 1 ];\n   }\n   jpeg_finish_compress( jpeg.cinfoptr());\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,10 +5,10 @@\n ) {\n    DIP_THROW_IF( !image.IsForged(), E::IMAGE_NOT_FORGED );\n    DIP_THROW_IF( image.Dimensionality() != 2, E::DIMENSIONALITY_NOT_SUPPORTED );\n-   jpegLevel = clamp< dip::uint >( jpegLevel, 1, 100 );\n \n    // Open the file\n-   JpegOutput jpeg( filename );\n+   DIP__DECLARE_JPEG_EXIT( \"Error writing JPEG file\" );\n+   JpegOutput jpeg( filename, setjmp_buffer );\n \n    // Set image properties\n    int nchan = static_cast< int >( image.TensorElements() );\n@@ -17,7 +17,7 @@\n    jpeg.cinfo().input_components = nchan;\n    jpeg.cinfo().in_color_space = nchan > 1 ? JCS_RGB : JCS_GRAYSCALE;\n    jpeg_set_defaults( jpeg.cinfoptr() );\n-   jpeg_set_quality( jpeg.cinfoptr(), static_cast< int >( jpegLevel ), FALSE );\n+   jpeg_set_quality( jpeg.cinfoptr(), static_cast< int >( clamp< dip::uint >( jpegLevel, 1, 100 )), FALSE );\n    jpeg.cinfo().density_unit = 2; // dots per cm\n    jpeg.cinfo().X_density = static_cast< UINT16 >( 0.01 / image.PixelSize( 0 ).RemovePrefix().magnitude ); // let's assume it's meter\n    jpeg.cinfo().Y_density = static_cast< UINT16 >( 0.01 / image.PixelSize( 1 ).RemovePrefix().magnitude );",
        "diff_line_info": {
            "deleted_lines": [
                "   jpegLevel = clamp< dip::uint >( jpegLevel, 1, 100 );",
                "   JpegOutput jpeg( filename );",
                "   jpeg_set_quality( jpeg.cinfoptr(), static_cast< int >( jpegLevel ), FALSE );"
            ],
            "added_lines": [
                "   DIP__DECLARE_JPEG_EXIT( \"Error writing JPEG file\" );",
                "   JpegOutput jpeg( filename, setjmp_buffer );",
                "   jpeg_set_quality( jpeg.cinfoptr(), static_cast< int >( clamp< dip::uint >( jpegLevel, 1, 100 )), FALSE );"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-39432",
        "func_name": "DIPlib/diplib/my_output_message",
        "description": "diplib v3.0.0 is vulnerable to Double Free.",
        "git_url": "https://github.com/DIPlib/diplib/commit/8b9a2670ce66ff2fd5addf592f7825e1f5adb5b5",
        "commit_title": "Fixed error handling in `dip::ImageReadJPEG()`, `dip::ImageWriteJPEG()`, etc. Fixes #80.",
        "commit_text": "",
        "func_before": "void my_output_message( j_common_ptr ) {}",
        "func": "static void my_output_message( j_common_ptr ) {}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1 +1 @@\n-void my_output_message( j_common_ptr ) {}\n+static void my_output_message( j_common_ptr ) {}",
        "diff_line_info": {
            "deleted_lines": [
                "void my_output_message( j_common_ptr ) {}"
            ],
            "added_lines": [
                "static void my_output_message( j_common_ptr ) {}"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-39432",
        "func_name": "DIPlib/diplib/ImageReadJPEG",
        "description": "diplib v3.0.0 is vulnerable to Double Free.",
        "git_url": "https://github.com/DIPlib/diplib/commit/8b9a2670ce66ff2fd5addf592f7825e1f5adb5b5",
        "commit_title": "Fixed error handling in `dip::ImageReadJPEG()`, `dip::ImageWriteJPEG()`, etc. Fixes #80.",
        "commit_text": "",
        "func_before": "FileInformation ImageReadJPEG(\n      Image& out,\n      String const& filename\n) {\n   // Open the file\n   JpegInput jpeg( filename );\n\n   // Get info\n   FileInformation info = GetJPEGInfo( jpeg );\n\n   // Allocate image\n   int nchan = jpeg.cinfo().num_components;\n   jpeg.cinfo().out_color_space = nchan > 1 ? JCS_RGB : JCS_GRAYSCALE;\n   out.ReForge( info.sizes, info.tensorElements, DT_UINT8, Option::AcceptDataTypeChange::DONT_ALLOW );\n   out.SetPixelSize( info.pixelSize );\n   out.SetColorSpace( info.colorSpace );\n\n   // Read data\n   jpeg_start_decompress( jpeg.cinfoptr() );\n   std::vector< JSAMPLE > buffer( info.sizes[ 0 ] * static_cast< unsigned >( nchan )); // casting to unsigned rather than dip::uint to shut up GCC warning.\n   dip::uint8* imagedata = static_cast< dip::uint8* >( out.Origin() );\n   auto stride = out.Strides();\n   auto tStride = out.TensorStride();\n   for( dip::uint ii = 0; ii < info.sizes[ 1 ]; ++ii ) {\n      JSAMPLE* indata = buffer.data();\n      jpeg_read_scanlines( jpeg.cinfoptr(), &indata, 1 );\n      dip::uint8* outdata = imagedata;\n      if( nchan > 1 ) {\n         for( dip::uint jj = 0; jj < info.sizes[ 0 ]; ++jj ) {\n            for( int kk = 0; kk < nchan; ++kk ) {\n               *( outdata + kk * tStride ) = *indata;\n               ++indata;\n            }\n            outdata += stride[ 0 ];\n         }\n      } else {\n         for( dip::uint jj = 0; jj < info.sizes[ 0 ]; ++jj ) {\n            *outdata = *indata;\n            ++indata;\n            outdata += stride[ 0 ];\n         }\n      }\n      imagedata += stride[ 1 ];\n   }\n   jpeg_finish_decompress( jpeg.cinfoptr() );\n\n   return info;\n}",
        "func": "FileInformation ImageReadJPEG(\n      Image& out,\n      String const& filename\n) {\n   // Open the file\n   DIP__DECLARE_JPEG_EXIT( \"Error reading JPEG file\" );\n   JpegInput jpeg( filename, setjmp_buffer );\n\n   // Get info\n   FileInformation info = GetJPEGInfo( jpeg );\n\n   // Allocate image\n   int nchan = jpeg.cinfo().num_components;\n   jpeg.cinfo().out_color_space = nchan > 1 ? JCS_RGB : JCS_GRAYSCALE;\n   out.ReForge( info.sizes, info.tensorElements, DT_UINT8, Option::AcceptDataTypeChange::DONT_ALLOW );\n   out.SetPixelSize( info.pixelSize );\n   out.SetColorSpace( info.colorSpace );\n\n   // Read data\n   jpeg_start_decompress( jpeg.cinfoptr() );\n   std::vector< JSAMPLE > buffer( info.sizes[ 0 ] * static_cast< unsigned >( nchan )); // casting to unsigned rather than dip::uint to shut up GCC warning.\n   dip::uint8* imagedata = static_cast< dip::uint8* >( out.Origin() );\n   auto stride = out.Strides();\n   auto tStride = out.TensorStride();\n   for( dip::uint ii = 0; ii < info.sizes[ 1 ]; ++ii ) {\n      JSAMPLE* indata = buffer.data();\n      jpeg_read_scanlines( jpeg.cinfoptr(), &indata, 1 );\n      dip::uint8* outdata = imagedata;\n      if( nchan > 1 ) {\n         for( dip::uint jj = 0; jj < info.sizes[ 0 ]; ++jj ) {\n            for( int kk = 0; kk < nchan; ++kk ) {\n               *( outdata + kk * tStride ) = *indata;\n               ++indata;\n            }\n            outdata += stride[ 0 ];\n         }\n      } else {\n         for( dip::uint jj = 0; jj < info.sizes[ 0 ]; ++jj ) {\n            *outdata = *indata;\n            ++indata;\n            outdata += stride[ 0 ];\n         }\n      }\n      imagedata += stride[ 1 ];\n   }\n   jpeg_finish_decompress( jpeg.cinfoptr() );\n\n   return info;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,7 +3,8 @@\n       String const& filename\n ) {\n    // Open the file\n-   JpegInput jpeg( filename );\n+   DIP__DECLARE_JPEG_EXIT( \"Error reading JPEG file\" );\n+   JpegInput jpeg( filename, setjmp_buffer );\n \n    // Get info\n    FileInformation info = GetJPEGInfo( jpeg );",
        "diff_line_info": {
            "deleted_lines": [
                "   JpegInput jpeg( filename );"
            ],
            "added_lines": [
                "   DIP__DECLARE_JPEG_EXIT( \"Error reading JPEG file\" );",
                "   JpegInput jpeg( filename, setjmp_buffer );"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-39432",
        "func_name": "DIPlib/diplib/my_error_exit",
        "description": "diplib v3.0.0 is vulnerable to Double Free.",
        "git_url": "https://github.com/DIPlib/diplib/commit/8b9a2670ce66ff2fd5addf592f7825e1f5adb5b5",
        "commit_title": "Fixed error handling in `dip::ImageReadJPEG()`, `dip::ImageWriteJPEG()`, etc. Fixes #80.",
        "commit_text": "",
        "func_before": "void my_error_exit( j_common_ptr cinfo ) {\n   // cinfo->err really points to a my_error_mgr struct, so coerce pointer\n   my_error_ptr myerr = reinterpret_cast<my_error_ptr>(cinfo->err);\n   // Return control to the setjmp point\n   longjmp( myerr->setjmp_buffer, 1 );\n}",
        "func": "static void my_error_exit( j_common_ptr cinfo ) {\n   // cinfo->err really points to a my_error_mgr struct, so coerce pointer\n   my_error_ptr myerr = reinterpret_cast<my_error_ptr>( cinfo->err );\n   // Return control to the setjmp point\n   longjmp( myerr->setjmp_buffer, 1 );\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,6 @@\n-void my_error_exit( j_common_ptr cinfo ) {\n+static void my_error_exit( j_common_ptr cinfo ) {\n    // cinfo->err really points to a my_error_mgr struct, so coerce pointer\n-   my_error_ptr myerr = reinterpret_cast<my_error_ptr>(cinfo->err);\n+   my_error_ptr myerr = reinterpret_cast<my_error_ptr>( cinfo->err );\n    // Return control to the setjmp point\n    longjmp( myerr->setjmp_buffer, 1 );\n }",
        "diff_line_info": {
            "deleted_lines": [
                "void my_error_exit( j_common_ptr cinfo ) {",
                "   my_error_ptr myerr = reinterpret_cast<my_error_ptr>(cinfo->err);"
            ],
            "added_lines": [
                "static void my_error_exit( j_common_ptr cinfo ) {",
                "   my_error_ptr myerr = reinterpret_cast<my_error_ptr>( cinfo->err );"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-15364",
        "func_name": "evan/ccsv/foreach",
        "description": "The foreach function in ext/ccsv.c in Ccsv 1.1.0 allows remote attackers to cause a denial of service (double free and application crash) or possibly have unspecified other impact via a crafted file.",
        "git_url": "https://github.com/evan/ccsv/commit/24e0b9b94c44a15b23475e821366239d53764dbd",
        "commit_title": "proposed non elegant fix for double free vulnerability",
        "commit_text": "",
        "func_before": "static VALUE foreach(int argc, VALUE* argv, VALUE self) {\n  char *DELIM=DEF_DELIM;\n  char *line = NULL;\n  char *line2 =NULL, *new_line=NULL;\n  size_t len = 0, len2=0, i, pairs_count;\n  char *token,*start,*nobackslash,*t2;\n  size_t idx,count,searchfield,flag,array_length,range_i;\n  long check;\n  int  was_read;\n  FILE *file;\n  ID min_method, max_method;\n  VALUE min_val, max_val;\n  VALUE tmp_value, rest_args, filename;\n  ID    array_length_method; /*----------------------------------------*/\n  struct pair_st pairs[MAX_INTERVALS];\n\n  VALUE ary;\n\n  rb_scan_args(argc,argv,\"1*\", &filename, &rest_args);\n\n/*  if (argc == 0) {  // there should only be 1 or 2 arguments\n    rb_raise(rb_eArgError, \"wrong number of arguments\");\n  }\n\n  file = fopen(StringValueCStr(argv[0]), \"r\");\n  if (file == NULL)\n    rb_raise(rb_eRuntimeError, \"File not found\");\n*/\n  file = fopen(StringValueCStr(filename), \"r\");\n  if(file==NULL){\n    rb_raise(rb_eRuntimeError, \"File not found\");\n  }\n\n  if (argc >1 ) { /* delimiter */\n    tmp_value=rb_ary_entry(rest_args,0);\n    DELIM=StringValueCStr(tmp_value);;\n  }\n\n  if (argc >2 ) { /* search index */\n    tmp_value=rb_ary_entry(rest_args,1);\n    searchfield=NUM2INT(tmp_value);\n  }\n  else{\n    searchfield=-1;\n  }\n\n  array_length_method=rb_funcall(rest_args,rb_intern(\"length\"), 0);\n  array_length=NUM2INT(array_length_method);\n\n  min_method = rb_intern(\"first\");\n  max_method = rb_intern(\"last\");\n  /*------------test_id    = rb_intern(\"class\");*/\n  range_i=0;\n  for(idx=2;idx<array_length;++idx){\n    min_val=rb_funcall(rb_ary_entry(rest_args,idx),rb_intern(\"length\"), 0);\n    len2=NUM2INT(min_val);\n    for(i=0;i<len2;++i){\n      VALUE e=rb_ary_entry(rb_ary_entry(rest_args,idx),i);\n      if(range_i>MAX_INTERVALS)\n        rb_raise(rb_eRuntimeError, \"Too much ranges passed\");\n      if(TYPE(e) == T_NIL){\n        pairs[range_i].low=LONG_MIN;\n        pairs[range_i].high=LONG_MAX;\n\n        continue; /* just skip nil */\n      }\n      if (! (rb_respond_to(e, min_method) & rb_respond_to(e, max_method)))\n        rb_raise(rb_eRuntimeError, \"Not range passed to Ccsv.foreach\");\n\n      min_val=rb_funcall(e, min_method, 0);\n      max_val=rb_funcall(e, max_method, 0);\n      pairs[range_i].low=NUM2LONG(min_val);\n      pairs[range_i].high=NUM2LONG(max_val);\n      range_i++;\n    }\n  }\n  pairs_count=range_i;\n\n  /* main loop lines reading */\n\n  while ((was_read=getline(&line, &len, file)) != -1) {\n\n    if(was_read<1)\n      continue;\n\n    len=was_read-1;\n    /* try to join escaped lines */\n    for(;;) {\n      /* check for backslashed newline */\n      if(line[len]!=EOL)\n        break;\n      if(line[len]==CR){\n        len-=1;\n      }\n      //rb_warn(\"NONLAST (%c,%c)\",line[len],line[len]);\n      count=0;\n      t2=line+len-1;\n      while((t2>=line) && (*t2=='\\\\'))\n        {++count;--t2;}\n      if(count%2 ==1){ /* backslashed! skip */\n        /* get another line... */\n        line2=NULL;\n        len2=0;\n        if((was_read=getline(&line2, &len2, file)) != -1) {\n          len2=was_read;\n          if(new_line)\n            free(new_line); //!!!!\n          new_line=malloc(len+len2+1);\n          strcpy(new_line,line);\n          new_line[len-1]='\\n';\n          strcpy(new_line+len,line2);\n          line=new_line;\n          //nobackslash=len+1;\n          start=new_line;\n          len+=len2-1;\n          nobackslash=start;\n          free(line);\n          free(line2);\n          continue;\n        }\n      }\n      break;\n    }\n    /* chomp! */\n    if(line[len]==EOL){\n      if(line[len-1]==CR)\n        len-=1;\n      line[len]='\\0';\n    }\n    /* skip empty line */\n    if(len<2)\n      continue;\n\n    ary = rb_ary_new();\n    start=line;\n    nobackslash=line;\n    \n    idx = 0;\n    flag=1;\n\n    while (nobackslash != NULL) {\n\n      /* get full field */\n      while(token=strstr(nobackslash, DELIM)){\n        count=0;\n        t2=token-1;\n        while((t2>=line) && (*t2=='\\\\'))\n          {++count;--t2;}\n        if(count%2 ==1){ /* backslashed! skip */\n          nobackslash=token;\n          continue;\n        }\n        break;\n      }\n\n      if(token)\n        *token='\\0';\n      else\n        token=start+strlen(start);\n\n      if(searchfield==idx){\n        flag=0;\n        /* do check! */\n        sscanf(start,\"%ld\",&check);\n        for(i=0;i<pairs_count;++i){\n          /*rb_warn(\"check %ld: [%ld .. %ld]\",check,pairs[i].low,pairs[i].high);*/\n          if(pairs[i].low<check && pairs[i].high>check){\n            /*rb_warn(\"check passed\");*/\n            flag=1; /* yahooo! */\n            break;\n          }\n        }\n      }\n\n      /* not in ranges! */\n      if(flag==0)\n        break;\n\n      rb_ary_store(ary, idx, rb_str_new(start, token-start));\n      idx++;\n      nobackslash=start=token+strlen(DELIM);\n      while(token=strstr(nobackslash, DELIM)){\n        count=0;\n        t2=token-1;\n        while((t2>=line) && (*t2=='\\\\'))\n          {++count;--t2;}\n        if(count%2 ==1){ /* backslashed! skip */\n          nobackslash=token+strlen(DELIM);\n          continue;\n        }\n        break;\n      }\n      nobackslash=token;\n    }\n    if(flag==0)\n      continue;\n\n    /* last item */\n    rb_ary_store(ary, idx, rb_str_new(start, strlen(start)));\n    /* OBJ_FREEZE(ary); */\n\n    rb_yield(ary);\n    /* FL_UNSET((ary), FL_FREEZE); */\n\n    /* for(idx = 0; idx < RARRAY_LEN(ary); idx ++) {\n      rb_ary_store(ary, idx, Qnil);\n    } */\n\n  }\n  fclose(file);\n  free(line);\n\n  return Qnil;\n}",
        "func": "static VALUE foreach(int argc, VALUE* argv, VALUE self) {\n  char *DELIM=DEF_DELIM;\n  char *line = NULL;\n  char *line2 =NULL, *new_line=NULL;\n  size_t len = 0, len2=0, i, pairs_count;\n  char *token,*start,*nobackslash,*t2;\n  size_t idx,count,searchfield,flag,array_length,range_i;\n  long check;\n  int  was_read, backslashed;\n  FILE *file;\n  ID min_method, max_method;\n  VALUE min_val, max_val;\n  VALUE tmp_value, rest_args, filename;\n  ID    array_length_method; /*----------------------------------------*/\n  struct pair_st pairs[MAX_INTERVALS];\n\n  VALUE ary;\n\n  rb_scan_args(argc,argv,\"1*\", &filename, &rest_args);\n\n/*  if (argc == 0) {  // there should only be 1 or 2 arguments\n    rb_raise(rb_eArgError, \"wrong number of arguments\");\n  }\n\n  file = fopen(StringValueCStr(argv[0]), \"r\");\n  if (file == NULL)\n    rb_raise(rb_eRuntimeError, \"File not found\");\n*/\n  file = fopen(StringValueCStr(filename), \"r\");\n  if(file==NULL){\n    rb_raise(rb_eRuntimeError, \"File not found\");\n  }\n\n  if (argc >1 ) { /* delimiter */\n    tmp_value=rb_ary_entry(rest_args,0);\n    DELIM=StringValueCStr(tmp_value);;\n  }\n\n  if (argc >2 ) { /* search index */\n    tmp_value=rb_ary_entry(rest_args,1);\n    searchfield=NUM2INT(tmp_value);\n  }\n  else{\n    searchfield=-1;\n  }\n\n  array_length_method=rb_funcall(rest_args,rb_intern(\"length\"), 0);\n  array_length=NUM2INT(array_length_method);\n\n  min_method = rb_intern(\"first\");\n  max_method = rb_intern(\"last\");\n  /*------------test_id    = rb_intern(\"class\");*/\n  range_i=0;\n  for(idx=2;idx<array_length;++idx){\n    min_val=rb_funcall(rb_ary_entry(rest_args,idx),rb_intern(\"length\"), 0);\n    len2=NUM2INT(min_val);\n    for(i=0;i<len2;++i){\n      VALUE e=rb_ary_entry(rb_ary_entry(rest_args,idx),i);\n      if(range_i>MAX_INTERVALS)\n        rb_raise(rb_eRuntimeError, \"Too much ranges passed\");\n      if(TYPE(e) == T_NIL){\n        pairs[range_i].low=LONG_MIN;\n        pairs[range_i].high=LONG_MAX;\n\n        continue; /* just skip nil */\n      }\n      if (! (rb_respond_to(e, min_method) & rb_respond_to(e, max_method)))\n        rb_raise(rb_eRuntimeError, \"Not range passed to Ccsv.foreach\");\n\n      min_val=rb_funcall(e, min_method, 0);\n      max_val=rb_funcall(e, max_method, 0);\n      pairs[range_i].low=NUM2LONG(min_val);\n      pairs[range_i].high=NUM2LONG(max_val);\n      range_i++;\n    }\n  }\n  pairs_count=range_i;\n\n  /* main loop lines reading */\n\n  while ((was_read=getline(&line, &len, file)) != -1) {\n\n    if(was_read<1)\n      continue;\n\n    backslashed = 0;\n    len=was_read-1;\n    /* try to join escaped lines */\n    for(;;) {\n      /* check for backslashed newline */\n      if(line[len]!=EOL)\n        break;\n      if(line[len]==CR){\n        len-=1;\n      }\n      //rb_warn(\"NONLAST (%c,%c)\",line[len],line[len]);\n      count=0;\n      t2=line+len-1;\n      while((t2>=line) && (*t2=='\\\\'))\n        {++count;--t2;}\n      if(count%2 ==1){ /* backslashed! skip */\n        /* get another line... */\n        line2=NULL;\n        len2=0;\n        if((was_read=getline(&line2, &len2, file)) != -1) {\n          len2=was_read;\n          if(new_line)\n            free(new_line); //!!!!\n          new_line=malloc(len+len2+1);\n          strcpy(new_line,line);\n          new_line[len-1]='\\n';\n          strcpy(new_line+len,line2);\n          line=new_line;\n          //nobackslash=len+1;\n          start=new_line;\n          len+=len2-1;\n          nobackslash=start;\n          backslashed = 1;\n          free(line);\n          free(line2);\n          continue;\n        }\n      }\n      break;\n    }\n    /* chomp! */\n    if(line[len]==EOL){\n      if(line[len-1]==CR)\n        len-=1;\n      line[len]='\\0';\n    }\n    /* skip empty line */\n    if(len<2)\n      continue;\n\n    ary = rb_ary_new();\n    start=line;\n    nobackslash=line;\n\n    idx = 0;\n    flag=1;\n\n    while (nobackslash != NULL) {\n\n      /* get full field */\n      while(token=strstr(nobackslash, DELIM)){\n        count=0;\n        t2=token-1;\n        while((t2>=line) && (*t2=='\\\\'))\n          {++count;--t2;}\n        if(count%2 ==1){ /* backslashed! skip */\n          nobackslash=token;\n          continue;\n        }\n        break;\n      }\n\n      if(token)\n        *token='\\0';\n      else\n        token=start+strlen(start);\n\n      if(searchfield==idx){\n        flag=0;\n        /* do check! */\n        sscanf(start,\"%ld\",&check);\n        for(i=0;i<pairs_count;++i){\n          /*rb_warn(\"check %ld: [%ld .. %ld]\",check,pairs[i].low,pairs[i].high);*/\n          if(pairs[i].low<check && pairs[i].high>check){\n            /*rb_warn(\"check passed\");*/\n            flag=1; /* yahooo! */\n            break;\n          }\n        }\n      }\n\n      /* not in ranges! */\n      if(flag==0)\n        break;\n\n      rb_ary_store(ary, idx, rb_str_new(start, token-start));\n      idx++;\n      nobackslash=start=token+strlen(DELIM);\n      while(token=strstr(nobackslash, DELIM)){\n        count=0;\n        t2=token-1;\n        while((t2>=line) && (*t2=='\\\\'))\n          {++count;--t2;}\n        if(count%2 ==1){ /* backslashed! skip */\n          nobackslash=token+strlen(DELIM);\n          continue;\n        }\n        break;\n      }\n      nobackslash=token;\n    }\n    if(flag==0)\n      continue;\n\n    /* last item */\n    rb_ary_store(ary, idx, rb_str_new(start, strlen(start)));\n    /* OBJ_FREEZE(ary); */\n\n    rb_yield(ary);\n    /* FL_UNSET((ary), FL_FREEZE); */\n\n    /* for(idx = 0; idx < RARRAY_LEN(ary); idx ++) {\n      rb_ary_store(ary, idx, Qnil);\n    } */\n\n  }\n  fclose(file);\n  if(!backslashed)\n    free(line);\n\n  return Qnil;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,7 +6,7 @@\n   char *token,*start,*nobackslash,*t2;\n   size_t idx,count,searchfield,flag,array_length,range_i;\n   long check;\n-  int  was_read;\n+  int  was_read, backslashed;\n   FILE *file;\n   ID min_method, max_method;\n   VALUE min_val, max_val;\n@@ -83,6 +83,7 @@\n     if(was_read<1)\n       continue;\n \n+    backslashed = 0;\n     len=was_read-1;\n     /* try to join escaped lines */\n     for(;;) {\n@@ -114,6 +115,7 @@\n           start=new_line;\n           len+=len2-1;\n           nobackslash=start;\n+          backslashed = 1;\n           free(line);\n           free(line2);\n           continue;\n@@ -134,7 +136,7 @@\n     ary = rb_ary_new();\n     start=line;\n     nobackslash=line;\n-    \n+\n     idx = 0;\n     flag=1;\n \n@@ -208,7 +210,8 @@\n \n   }\n   fclose(file);\n-  free(line);\n+  if(!backslashed)\n+    free(line);\n \n   return Qnil;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "  int  was_read;",
                "    ",
                "  free(line);"
            ],
            "added_lines": [
                "  int  was_read, backslashed;",
                "    backslashed = 0;",
                "          backslashed = 1;",
                "",
                "  if(!backslashed)",
                "    free(line);"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-11462",
        "func_name": "krb5/gss_verify_mic_iov",
        "description": "Double free vulnerability in MIT Kerberos 5 (aka krb5) allows attackers to have unspecified impact via vectors involving automatic deletion of security contexts on error.",
        "git_url": "https://github.com/krb5/krb5/commit/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf",
        "commit_title": "Preserve GSS context on init/accept failure",
        "commit_text": " After gss_init_sec_context() or gss_accept_sec_context() has created a context, don't delete the mechglue context on failures from subsequent calls, even if the mechanism deletes the mech-specific context (which is allowed by RFC 2744 but not preferred).  Check for union contexts with no mechanism context in each GSS function which accepts a gss_ctx_id_t.  CVE-2017-11462:  RFC 2744 permits a GSS-API implementation to delete an existing security context on a second or subsequent call to gss_init_sec_context() or gss_accept_sec_context() if the call results in an error.  This API behavior has been found to be dangerous, leading to the possibility of memory errors in some callers.  For safety, GSS-API implementations should instead preserve existing security contexts on error until the caller deletes them.  All versions of MIT krb5 prior to this change may delete acceptor contexts on error.  Versions 1.13.4 through 1.13.7, 1.14.1 through 1.14.5, and 1.15 through 1.15.1 may also delete initiator contexts on error.  ticket: 8598 (new) target_version: 1.15-next target_version: 1.14-next tags: pullup",
        "func_before": "OM_uint32 KRB5_CALLCONV\ngss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n\t\t   gss_qop_t *qop_state, gss_iov_buffer_desc *iov,\n\t\t   int iov_count)\n{\n    OM_uint32 status;\n    gss_union_ctx_id_t ctx;\n    gss_mechanism mech;\n\n    status = val_unwrap_iov_args(minor_status, context_handle, NULL,\n\t\t\t\t qop_state, iov, iov_count);\n    if (status != GSS_S_COMPLETE)\n\treturn status;\n\n    /* Select the approprate underlying mechanism routine and call it. */\n    ctx = (gss_union_ctx_id_t)context_handle;\n    mech = gssint_get_mechanism(ctx->mech_type);\n    if (mech == NULL)\n\treturn GSS_S_BAD_MECH;\n    if (mech->gss_verify_mic_iov == NULL)\n\treturn GSS_S_UNAVAILABLE;\n    status = mech->gss_verify_mic_iov(minor_status, ctx->internal_ctx_id,\n\t\t\t\t      qop_state, iov, iov_count);\n    if (status != GSS_S_COMPLETE)\n\tmap_error(minor_status, mech);\n    return status;\n}",
        "func": "OM_uint32 KRB5_CALLCONV\ngss_verify_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n\t\t   gss_qop_t *qop_state, gss_iov_buffer_desc *iov,\n\t\t   int iov_count)\n{\n    OM_uint32 status;\n    gss_union_ctx_id_t ctx;\n    gss_mechanism mech;\n\n    status = val_unwrap_iov_args(minor_status, context_handle, NULL,\n\t\t\t\t qop_state, iov, iov_count);\n    if (status != GSS_S_COMPLETE)\n\treturn status;\n\n    /* Select the approprate underlying mechanism routine and call it. */\n    ctx = (gss_union_ctx_id_t)context_handle;\n    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n\treturn GSS_S_NO_CONTEXT;\n    mech = gssint_get_mechanism(ctx->mech_type);\n    if (mech == NULL)\n\treturn GSS_S_BAD_MECH;\n    if (mech->gss_verify_mic_iov == NULL)\n\treturn GSS_S_UNAVAILABLE;\n    status = mech->gss_verify_mic_iov(minor_status, ctx->internal_ctx_id,\n\t\t\t\t      qop_state, iov, iov_count);\n    if (status != GSS_S_COMPLETE)\n\tmap_error(minor_status, mech);\n    return status;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -14,6 +14,8 @@\n \n     /* Select the approprate underlying mechanism routine and call it. */\n     ctx = (gss_union_ctx_id_t)context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism(ctx->mech_type);\n     if (mech == NULL)\n \treturn GSS_S_BAD_MECH;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)",
                "\treturn GSS_S_NO_CONTEXT;"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-11462",
        "func_name": "krb5/gss_wrap",
        "description": "Double free vulnerability in MIT Kerberos 5 (aka krb5) allows attackers to have unspecified impact via vectors involving automatic deletion of security contexts on error.",
        "git_url": "https://github.com/krb5/krb5/commit/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf",
        "commit_title": "Preserve GSS context on init/accept failure",
        "commit_text": " After gss_init_sec_context() or gss_accept_sec_context() has created a context, don't delete the mechglue context on failures from subsequent calls, even if the mechanism deletes the mech-specific context (which is allowed by RFC 2744 but not preferred).  Check for union contexts with no mechanism context in each GSS function which accepts a gss_ctx_id_t.  CVE-2017-11462:  RFC 2744 permits a GSS-API implementation to delete an existing security context on a second or subsequent call to gss_init_sec_context() or gss_accept_sec_context() if the call results in an error.  This API behavior has been found to be dangerous, leading to the possibility of memory errors in some callers.  For safety, GSS-API implementations should instead preserve existing security contexts on error until the caller deletes them.  All versions of MIT krb5 prior to this change may delete acceptor contexts on error.  Versions 1.13.4 through 1.13.7, 1.14.1 through 1.14.5, and 1.15 through 1.15.1 may also delete initiator contexts on error.  ticket: 8598 (new) target_version: 1.15-next target_version: 1.14-next tags: pullup",
        "func_before": "OM_uint32 KRB5_CALLCONV\ngss_wrap( OM_uint32 *minor_status,\n          gss_ctx_id_t context_handle,\n          int conf_req_flag,\n          gss_qop_t qop_req,\n          gss_buffer_t input_message_buffer,\n          int *conf_state,\n          gss_buffer_t output_message_buffer)\n{\n\n    /* EXPORT DELETE START */\n\n    OM_uint32           status;\n    gss_union_ctx_id_t  ctx;\n    gss_mechanism       mech;\n\n    status = val_wrap_args(minor_status, context_handle,\n                           conf_req_flag, qop_req,\n                           input_message_buffer, conf_state,\n                           output_message_buffer);\n    if (status != GSS_S_COMPLETE)\n        return (status);\n\n    /*\n     * select the approprate underlying mechanism routine and\n     * call it.\n     */\n\n    ctx = (gss_union_ctx_id_t) context_handle;\n    mech = gssint_get_mechanism (ctx->mech_type);\n\n    if (mech) {\n        if (mech->gss_wrap) {\n            status = mech->gss_wrap(minor_status,\n                                    ctx->internal_ctx_id,\n                                    conf_req_flag,\n                                    qop_req,\n                                    input_message_buffer,\n                                    conf_state,\n                                    output_message_buffer);\n            if (status != GSS_S_COMPLETE)\n                map_error(minor_status, mech);\n        } else if (mech->gss_wrap_aead ||\n                   (mech->gss_wrap_iov && mech->gss_wrap_iov_length)) {\n            status = gssint_wrap_aead(mech,\n                                      minor_status,\n                                      ctx,\n                                      conf_req_flag,\n                                      (gss_qop_t)qop_req,\n                                      GSS_C_NO_BUFFER,\n                                      input_message_buffer,\n                                      conf_state,\n                                      output_message_buffer);\n        } else\n            status = GSS_S_UNAVAILABLE;\n\n        return(status);\n    }\n    /* EXPORT DELETE END */\n\n    return (GSS_S_BAD_MECH);\n}",
        "func": "OM_uint32 KRB5_CALLCONV\ngss_wrap( OM_uint32 *minor_status,\n          gss_ctx_id_t context_handle,\n          int conf_req_flag,\n          gss_qop_t qop_req,\n          gss_buffer_t input_message_buffer,\n          int *conf_state,\n          gss_buffer_t output_message_buffer)\n{\n\n    /* EXPORT DELETE START */\n\n    OM_uint32           status;\n    gss_union_ctx_id_t  ctx;\n    gss_mechanism       mech;\n\n    status = val_wrap_args(minor_status, context_handle,\n                           conf_req_flag, qop_req,\n                           input_message_buffer, conf_state,\n                           output_message_buffer);\n    if (status != GSS_S_COMPLETE)\n        return (status);\n\n    /*\n     * select the approprate underlying mechanism routine and\n     * call it.\n     */\n\n    ctx = (gss_union_ctx_id_t) context_handle;\n    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n        return (GSS_S_NO_CONTEXT);\n    mech = gssint_get_mechanism (ctx->mech_type);\n\n    if (mech) {\n        if (mech->gss_wrap) {\n            status = mech->gss_wrap(minor_status,\n                                    ctx->internal_ctx_id,\n                                    conf_req_flag,\n                                    qop_req,\n                                    input_message_buffer,\n                                    conf_state,\n                                    output_message_buffer);\n            if (status != GSS_S_COMPLETE)\n                map_error(minor_status, mech);\n        } else if (mech->gss_wrap_aead ||\n                   (mech->gss_wrap_iov && mech->gss_wrap_iov_length)) {\n            status = gssint_wrap_aead(mech,\n                                      minor_status,\n                                      ctx,\n                                      conf_req_flag,\n                                      (gss_qop_t)qop_req,\n                                      GSS_C_NO_BUFFER,\n                                      input_message_buffer,\n                                      conf_state,\n                                      output_message_buffer);\n        } else\n            status = GSS_S_UNAVAILABLE;\n\n        return(status);\n    }\n    /* EXPORT DELETE END */\n\n    return (GSS_S_BAD_MECH);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -27,6 +27,8 @@\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+        return (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech) {",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)",
                "        return (GSS_S_NO_CONTEXT);"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-11462",
        "func_name": "krb5/gss_wrap_size_limit",
        "description": "Double free vulnerability in MIT Kerberos 5 (aka krb5) allows attackers to have unspecified impact via vectors involving automatic deletion of security contexts on error.",
        "git_url": "https://github.com/krb5/krb5/commit/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf",
        "commit_title": "Preserve GSS context on init/accept failure",
        "commit_text": " After gss_init_sec_context() or gss_accept_sec_context() has created a context, don't delete the mechglue context on failures from subsequent calls, even if the mechanism deletes the mech-specific context (which is allowed by RFC 2744 but not preferred).  Check for union contexts with no mechanism context in each GSS function which accepts a gss_ctx_id_t.  CVE-2017-11462:  RFC 2744 permits a GSS-API implementation to delete an existing security context on a second or subsequent call to gss_init_sec_context() or gss_accept_sec_context() if the call results in an error.  This API behavior has been found to be dangerous, leading to the possibility of memory errors in some callers.  For safety, GSS-API implementations should instead preserve existing security contexts on error until the caller deletes them.  All versions of MIT krb5 prior to this change may delete acceptor contexts on error.  Versions 1.13.4 through 1.13.7, 1.14.1 through 1.14.5, and 1.15 through 1.15.1 may also delete initiator contexts on error.  ticket: 8598 (new) target_version: 1.15-next target_version: 1.14-next tags: pullup",
        "func_before": "OM_uint32 KRB5_CALLCONV\ngss_wrap_size_limit(OM_uint32  *minor_status,\n                    gss_ctx_id_t context_handle,\n                    int conf_req_flag,\n                    gss_qop_t qop_req, OM_uint32 req_output_size, OM_uint32 *max_input_size)\n{\n    gss_union_ctx_id_t  ctx;\n    gss_mechanism       mech;\n    OM_uint32           major_status;\n\n    if (minor_status == NULL)\n        return (GSS_S_CALL_INACCESSIBLE_WRITE);\n    *minor_status = 0;\n\n    if (context_handle == GSS_C_NO_CONTEXT)\n        return (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);\n\n    if (max_input_size == NULL)\n        return (GSS_S_CALL_INACCESSIBLE_WRITE);\n\n    /*\n     * select the approprate underlying mechanism routine and\n     * call it.\n     */\n\n    ctx = (gss_union_ctx_id_t) context_handle;\n    mech = gssint_get_mechanism (ctx->mech_type);\n\n    if (!mech)\n        return (GSS_S_BAD_MECH);\n\n    if (mech->gss_wrap_size_limit)\n        major_status = mech->gss_wrap_size_limit(minor_status,\n                                                 ctx->internal_ctx_id,\n                                                 conf_req_flag, qop_req,\n                                                 req_output_size, max_input_size);\n    else if (mech->gss_wrap_iov_length)\n        major_status = gssint_wrap_size_limit_iov_shim(mech, minor_status,\n                                                       ctx->internal_ctx_id,\n                                                       conf_req_flag, qop_req,\n                                                       req_output_size, max_input_size);\n    else\n        major_status = GSS_S_UNAVAILABLE;\n    if (major_status != GSS_S_COMPLETE)\n        map_error(minor_status, mech);\n    return major_status;\n}",
        "func": "OM_uint32 KRB5_CALLCONV\ngss_wrap_size_limit(OM_uint32  *minor_status,\n                    gss_ctx_id_t context_handle,\n                    int conf_req_flag,\n                    gss_qop_t qop_req, OM_uint32 req_output_size, OM_uint32 *max_input_size)\n{\n    gss_union_ctx_id_t  ctx;\n    gss_mechanism       mech;\n    OM_uint32           major_status;\n\n    if (minor_status == NULL)\n        return (GSS_S_CALL_INACCESSIBLE_WRITE);\n    *minor_status = 0;\n\n    if (context_handle == GSS_C_NO_CONTEXT)\n        return (GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT);\n\n    if (max_input_size == NULL)\n        return (GSS_S_CALL_INACCESSIBLE_WRITE);\n\n    /*\n     * select the approprate underlying mechanism routine and\n     * call it.\n     */\n\n    ctx = (gss_union_ctx_id_t) context_handle;\n    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n        return (GSS_S_NO_CONTEXT);\n    mech = gssint_get_mechanism (ctx->mech_type);\n\n    if (!mech)\n        return (GSS_S_BAD_MECH);\n\n    if (mech->gss_wrap_size_limit)\n        major_status = mech->gss_wrap_size_limit(minor_status,\n                                                 ctx->internal_ctx_id,\n                                                 conf_req_flag, qop_req,\n                                                 req_output_size, max_input_size);\n    else if (mech->gss_wrap_iov_length)\n        major_status = gssint_wrap_size_limit_iov_shim(mech, minor_status,\n                                                       ctx->internal_ctx_id,\n                                                       conf_req_flag, qop_req,\n                                                       req_output_size, max_input_size);\n    else\n        major_status = GSS_S_UNAVAILABLE;\n    if (major_status != GSS_S_COMPLETE)\n        map_error(minor_status, mech);\n    return major_status;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -24,6 +24,8 @@\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+        return (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (!mech)",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)",
                "        return (GSS_S_NO_CONTEXT);"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-11462",
        "func_name": "krb5/gss_get_mic_iov_length",
        "description": "Double free vulnerability in MIT Kerberos 5 (aka krb5) allows attackers to have unspecified impact via vectors involving automatic deletion of security contexts on error.",
        "git_url": "https://github.com/krb5/krb5/commit/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf",
        "commit_title": "Preserve GSS context on init/accept failure",
        "commit_text": " After gss_init_sec_context() or gss_accept_sec_context() has created a context, don't delete the mechglue context on failures from subsequent calls, even if the mechanism deletes the mech-specific context (which is allowed by RFC 2744 but not preferred).  Check for union contexts with no mechanism context in each GSS function which accepts a gss_ctx_id_t.  CVE-2017-11462:  RFC 2744 permits a GSS-API implementation to delete an existing security context on a second or subsequent call to gss_init_sec_context() or gss_accept_sec_context() if the call results in an error.  This API behavior has been found to be dangerous, leading to the possibility of memory errors in some callers.  For safety, GSS-API implementations should instead preserve existing security contexts on error until the caller deletes them.  All versions of MIT krb5 prior to this change may delete acceptor contexts on error.  Versions 1.13.4 through 1.13.7, 1.14.1 through 1.14.5, and 1.15 through 1.15.1 may also delete initiator contexts on error.  ticket: 8598 (new) target_version: 1.15-next target_version: 1.14-next tags: pullup",
        "func_before": "OM_uint32 KRB5_CALLCONV\ngss_get_mic_iov_length(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n\t\t       gss_qop_t qop_req, gss_iov_buffer_desc *iov,\n\t\t       int iov_count)\n{\n    OM_uint32 status;\n    gss_union_ctx_id_t ctx;\n    gss_mechanism mech;\n\n    status = val_wrap_iov_args(minor_status, context_handle, 0, qop_req, NULL,\n\t\t\t       iov, iov_count);\n    if (status != GSS_S_COMPLETE)\n\treturn status;\n\n    /* Select the approprate underlying mechanism routine and call it. */\n    ctx = (gss_union_ctx_id_t)context_handle;\n    mech = gssint_get_mechanism(ctx->mech_type);\n    if (mech == NULL)\n\treturn GSS_S_BAD_MECH;\n    if (mech->gss_get_mic_iov_length == NULL)\n\treturn GSS_S_UNAVAILABLE;\n    status = mech->gss_get_mic_iov_length(minor_status, ctx->internal_ctx_id,\n\t\t\t\t\t  qop_req, iov, iov_count);\n    if (status != GSS_S_COMPLETE)\n\tmap_error(minor_status, mech);\n    return status;\n}",
        "func": "OM_uint32 KRB5_CALLCONV\ngss_get_mic_iov_length(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n\t\t       gss_qop_t qop_req, gss_iov_buffer_desc *iov,\n\t\t       int iov_count)\n{\n    OM_uint32 status;\n    gss_union_ctx_id_t ctx;\n    gss_mechanism mech;\n\n    status = val_wrap_iov_args(minor_status, context_handle, 0, qop_req, NULL,\n\t\t\t       iov, iov_count);\n    if (status != GSS_S_COMPLETE)\n\treturn status;\n\n    /* Select the approprate underlying mechanism routine and call it. */\n    ctx = (gss_union_ctx_id_t)context_handle;\n    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n\treturn GSS_S_NO_CONTEXT;\n    mech = gssint_get_mechanism(ctx->mech_type);\n    if (mech == NULL)\n\treturn GSS_S_BAD_MECH;\n    if (mech->gss_get_mic_iov_length == NULL)\n\treturn GSS_S_UNAVAILABLE;\n    status = mech->gss_get_mic_iov_length(minor_status, ctx->internal_ctx_id,\n\t\t\t\t\t  qop_req, iov, iov_count);\n    if (status != GSS_S_COMPLETE)\n\tmap_error(minor_status, mech);\n    return status;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -14,6 +14,8 @@\n \n     /* Select the approprate underlying mechanism routine and call it. */\n     ctx = (gss_union_ctx_id_t)context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism(ctx->mech_type);\n     if (mech == NULL)\n \treturn GSS_S_BAD_MECH;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)",
                "\treturn GSS_S_NO_CONTEXT;"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-11462",
        "func_name": "krb5/gss_get_mic_iov",
        "description": "Double free vulnerability in MIT Kerberos 5 (aka krb5) allows attackers to have unspecified impact via vectors involving automatic deletion of security contexts on error.",
        "git_url": "https://github.com/krb5/krb5/commit/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf",
        "commit_title": "Preserve GSS context on init/accept failure",
        "commit_text": " After gss_init_sec_context() or gss_accept_sec_context() has created a context, don't delete the mechglue context on failures from subsequent calls, even if the mechanism deletes the mech-specific context (which is allowed by RFC 2744 but not preferred).  Check for union contexts with no mechanism context in each GSS function which accepts a gss_ctx_id_t.  CVE-2017-11462:  RFC 2744 permits a GSS-API implementation to delete an existing security context on a second or subsequent call to gss_init_sec_context() or gss_accept_sec_context() if the call results in an error.  This API behavior has been found to be dangerous, leading to the possibility of memory errors in some callers.  For safety, GSS-API implementations should instead preserve existing security contexts on error until the caller deletes them.  All versions of MIT krb5 prior to this change may delete acceptor contexts on error.  Versions 1.13.4 through 1.13.7, 1.14.1 through 1.14.5, and 1.15 through 1.15.1 may also delete initiator contexts on error.  ticket: 8598 (new) target_version: 1.15-next target_version: 1.14-next tags: pullup",
        "func_before": "OM_uint32 KRB5_CALLCONV\ngss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n\t\tgss_qop_t qop_req, gss_iov_buffer_desc *iov, int iov_count)\n{\n    OM_uint32 status;\n    gss_union_ctx_id_t ctx;\n    gss_mechanism mech;\n\n    status = val_wrap_iov_args(minor_status, context_handle, 0, qop_req, NULL,\n\t\t\t       iov, iov_count);\n    if (status != GSS_S_COMPLETE)\n\treturn status;\n\n    /* Select the approprate underlying mechanism routine and call it. */\n    ctx = (gss_union_ctx_id_t)context_handle;\n    mech = gssint_get_mechanism(ctx->mech_type);\n    if (mech == NULL)\n\treturn GSS_S_BAD_MECH;\n    if (mech->gss_get_mic_iov == NULL)\n\treturn GSS_S_UNAVAILABLE;\n    status = mech->gss_get_mic_iov(minor_status, ctx->internal_ctx_id, qop_req,\n\t\t\t\t   iov, iov_count);\n    if (status != GSS_S_COMPLETE)\n\tmap_error(minor_status, mech);\n    return status;\n}",
        "func": "OM_uint32 KRB5_CALLCONV\ngss_get_mic_iov(OM_uint32 *minor_status, gss_ctx_id_t context_handle,\n\t\tgss_qop_t qop_req, gss_iov_buffer_desc *iov, int iov_count)\n{\n    OM_uint32 status;\n    gss_union_ctx_id_t ctx;\n    gss_mechanism mech;\n\n    status = val_wrap_iov_args(minor_status, context_handle, 0, qop_req, NULL,\n\t\t\t       iov, iov_count);\n    if (status != GSS_S_COMPLETE)\n\treturn status;\n\n    /* Select the approprate underlying mechanism routine and call it. */\n    ctx = (gss_union_ctx_id_t)context_handle;\n    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n\treturn GSS_S_NO_CONTEXT;\n    mech = gssint_get_mechanism(ctx->mech_type);\n    if (mech == NULL)\n\treturn GSS_S_BAD_MECH;\n    if (mech->gss_get_mic_iov == NULL)\n\treturn GSS_S_UNAVAILABLE;\n    status = mech->gss_get_mic_iov(minor_status, ctx->internal_ctx_id, qop_req,\n\t\t\t\t   iov, iov_count);\n    if (status != GSS_S_COMPLETE)\n\tmap_error(minor_status, mech);\n    return status;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -13,6 +13,8 @@\n \n     /* Select the approprate underlying mechanism routine and call it. */\n     ctx = (gss_union_ctx_id_t)context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism(ctx->mech_type);\n     if (mech == NULL)\n \treturn GSS_S_BAD_MECH;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)",
                "\treturn GSS_S_NO_CONTEXT;"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-11462",
        "func_name": "krb5/gss_complete_auth_token",
        "description": "Double free vulnerability in MIT Kerberos 5 (aka krb5) allows attackers to have unspecified impact via vectors involving automatic deletion of security contexts on error.",
        "git_url": "https://github.com/krb5/krb5/commit/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf",
        "commit_title": "Preserve GSS context on init/accept failure",
        "commit_text": " After gss_init_sec_context() or gss_accept_sec_context() has created a context, don't delete the mechglue context on failures from subsequent calls, even if the mechanism deletes the mech-specific context (which is allowed by RFC 2744 but not preferred).  Check for union contexts with no mechanism context in each GSS function which accepts a gss_ctx_id_t.  CVE-2017-11462:  RFC 2744 permits a GSS-API implementation to delete an existing security context on a second or subsequent call to gss_init_sec_context() or gss_accept_sec_context() if the call results in an error.  This API behavior has been found to be dangerous, leading to the possibility of memory errors in some callers.  For safety, GSS-API implementations should instead preserve existing security contexts on error until the caller deletes them.  All versions of MIT krb5 prior to this change may delete acceptor contexts on error.  Versions 1.13.4 through 1.13.7, 1.14.1 through 1.14.5, and 1.15 through 1.15.1 may also delete initiator contexts on error.  ticket: 8598 (new) target_version: 1.15-next target_version: 1.14-next tags: pullup",
        "func_before": "OM_uint32 KRB5_CALLCONV\ngss_complete_auth_token (OM_uint32 *minor_status,\n\t                 const gss_ctx_id_t context_handle,\n\t                 gss_buffer_t input_message_buffer)\n{\n    OM_uint32\t\tstatus;\n    gss_union_ctx_id_t\tctx;\n    gss_mechanism\tmech;\n\n    if (context_handle == GSS_C_NO_CONTEXT)\n\treturn GSS_S_NO_CONTEXT;\n\n    /*\n     * select the approprate underlying mechanism routine and\n     * call it.\n     */\n\n    ctx = (gss_union_ctx_id_t) context_handle;\n    mech = gssint_get_mechanism (ctx->mech_type);\n\n    if (mech != NULL) {\n\tif (mech->gss_complete_auth_token != NULL) {\n\t    status = mech->gss_complete_auth_token(minor_status,\n\t\t\t\t\t\t   ctx->internal_ctx_id,\n\t\t\t\t\t\t   input_message_buffer);\n\t    if (status != GSS_S_COMPLETE)\n\t\tmap_error(minor_status, mech);\n\t} else\n\t    status = GSS_S_COMPLETE;\n    } else\n\tstatus = GSS_S_BAD_MECH;\n\n    return status;\n}",
        "func": "OM_uint32 KRB5_CALLCONV\ngss_complete_auth_token (OM_uint32 *minor_status,\n\t                 const gss_ctx_id_t context_handle,\n\t                 gss_buffer_t input_message_buffer)\n{\n    OM_uint32\t\tstatus;\n    gss_union_ctx_id_t\tctx;\n    gss_mechanism\tmech;\n\n    if (context_handle == GSS_C_NO_CONTEXT)\n\treturn GSS_S_NO_CONTEXT;\n\n    /*\n     * select the approprate underlying mechanism routine and\n     * call it.\n     */\n\n    ctx = (gss_union_ctx_id_t) context_handle;\n    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n\treturn GSS_S_NO_CONTEXT;\n    mech = gssint_get_mechanism (ctx->mech_type);\n\n    if (mech != NULL) {\n\tif (mech->gss_complete_auth_token != NULL) {\n\t    status = mech->gss_complete_auth_token(minor_status,\n\t\t\t\t\t\t   ctx->internal_ctx_id,\n\t\t\t\t\t\t   input_message_buffer);\n\t    if (status != GSS_S_COMPLETE)\n\t\tmap_error(minor_status, mech);\n\t} else\n\t    status = GSS_S_COMPLETE;\n    } else\n\tstatus = GSS_S_BAD_MECH;\n\n    return status;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -16,6 +16,8 @@\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech != NULL) {",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)",
                "\treturn GSS_S_NO_CONTEXT;"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-11462",
        "func_name": "krb5/gss_inquire_context",
        "description": "Double free vulnerability in MIT Kerberos 5 (aka krb5) allows attackers to have unspecified impact via vectors involving automatic deletion of security contexts on error.",
        "git_url": "https://github.com/krb5/krb5/commit/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf",
        "commit_title": "Preserve GSS context on init/accept failure",
        "commit_text": " After gss_init_sec_context() or gss_accept_sec_context() has created a context, don't delete the mechglue context on failures from subsequent calls, even if the mechanism deletes the mech-specific context (which is allowed by RFC 2744 but not preferred).  Check for union contexts with no mechanism context in each GSS function which accepts a gss_ctx_id_t.  CVE-2017-11462:  RFC 2744 permits a GSS-API implementation to delete an existing security context on a second or subsequent call to gss_init_sec_context() or gss_accept_sec_context() if the call results in an error.  This API behavior has been found to be dangerous, leading to the possibility of memory errors in some callers.  For safety, GSS-API implementations should instead preserve existing security contexts on error until the caller deletes them.  All versions of MIT krb5 prior to this change may delete acceptor contexts on error.  Versions 1.13.4 through 1.13.7, 1.14.1 through 1.14.5, and 1.15 through 1.15.1 may also delete initiator contexts on error.  ticket: 8598 (new) target_version: 1.15-next target_version: 1.14-next tags: pullup",
        "func_before": "OM_uint32 KRB5_CALLCONV\ngss_inquire_context(\n\t    OM_uint32 *minor_status,\n\t    gss_ctx_id_t context_handle,\n\t    gss_name_t *src_name,\n\t    gss_name_t *targ_name,\n\t    OM_uint32 *lifetime_rec,\n\t    gss_OID *mech_type,\n\t    OM_uint32 *ctx_flags,\n\t    int *locally_initiated,\n\t    int *opened)\n{\n    gss_union_ctx_id_t\tctx;\n    gss_mechanism\tmech;\n    OM_uint32\t\tstatus, temp_minor;\n    gss_OID\t\tactual_mech;\n    gss_name_t localTargName = NULL, localSourceName = NULL;\n\n    status = val_inq_ctx_args(minor_status,\n\t\t\t      context_handle,\n\t\t\t      src_name, targ_name,\n\t\t\t      lifetime_rec,\n\t\t\t      mech_type, ctx_flags,\n\t\t\t      locally_initiated, opened);\n    if (status != GSS_S_COMPLETE)\n\treturn (status);\n\n    /*\n     * select the approprate underlying mechanism routine and\n     * call it.\n     */\n\n    ctx = (gss_union_ctx_id_t) context_handle;\n    mech = gssint_get_mechanism (ctx->mech_type);\n\n    if (!mech || !mech->gss_inquire_context || !mech->gss_display_name ||\n\t!mech->gss_release_name) {\n\treturn (GSS_S_UNAVAILABLE);\n    }\n\n    status = mech->gss_inquire_context(\n\t\t\tminor_status,\n\t\t\tctx->internal_ctx_id,\n\t\t\t(src_name ? &localSourceName : NULL),\n\t\t\t(targ_name ? &localTargName : NULL),\n\t\t\tlifetime_rec,\n\t\t\t&actual_mech,\n\t\t\tctx_flags,\n\t\t\tlocally_initiated,\n\t\t\topened);\n\n    if (status != GSS_S_COMPLETE) {\n\tmap_error(minor_status, mech);\n\treturn status;\n    }\n\n    /* need to convert names */\n\n    if (src_name) {\n\tif (localSourceName) {\n\t    status = gssint_convert_name_to_union_name(minor_status, mech,\n\t\t\t\t\t\t      localSourceName, src_name);\n\n\t    if (status != GSS_S_COMPLETE) {\n\t\tif (localTargName)\n\t\t    mech->gss_release_name(&temp_minor, &localTargName);\n\t\treturn (status);\n\t    }\n\t} else {\n\t    *src_name = GSS_C_NO_NAME;\n\t}\n    }\n\n    if (targ_name) {\n        if (localTargName) {\n\t    status = gssint_convert_name_to_union_name(minor_status, mech,\n\t\t\t\t\t\t      localTargName, targ_name);\n\n\t    if (status != GSS_S_COMPLETE) {\n\t\tif (src_name)\n\t\t    (void) gss_release_name(&temp_minor, src_name);\n\n\t\treturn (status);\n\t    }\n        }\n        else {\n            *targ_name = GSS_C_NO_NAME;\n        }\n    }\n\n    if (mech_type)\n\t*mech_type = gssint_get_public_oid(actual_mech);\n\n    return(GSS_S_COMPLETE);\n}",
        "func": "OM_uint32 KRB5_CALLCONV\ngss_inquire_context(\n\t    OM_uint32 *minor_status,\n\t    gss_ctx_id_t context_handle,\n\t    gss_name_t *src_name,\n\t    gss_name_t *targ_name,\n\t    OM_uint32 *lifetime_rec,\n\t    gss_OID *mech_type,\n\t    OM_uint32 *ctx_flags,\n\t    int *locally_initiated,\n\t    int *opened)\n{\n    gss_union_ctx_id_t\tctx;\n    gss_mechanism\tmech;\n    OM_uint32\t\tstatus, temp_minor;\n    gss_OID\t\tactual_mech;\n    gss_name_t localTargName = NULL, localSourceName = NULL;\n\n    status = val_inq_ctx_args(minor_status,\n\t\t\t      context_handle,\n\t\t\t      src_name, targ_name,\n\t\t\t      lifetime_rec,\n\t\t\t      mech_type, ctx_flags,\n\t\t\t      locally_initiated, opened);\n    if (status != GSS_S_COMPLETE)\n\treturn (status);\n\n    /*\n     * select the approprate underlying mechanism routine and\n     * call it.\n     */\n\n    ctx = (gss_union_ctx_id_t) context_handle;\n    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n\treturn (GSS_S_NO_CONTEXT);\n    mech = gssint_get_mechanism (ctx->mech_type);\n\n    if (!mech || !mech->gss_inquire_context || !mech->gss_display_name ||\n\t!mech->gss_release_name) {\n\treturn (GSS_S_UNAVAILABLE);\n    }\n\n    status = mech->gss_inquire_context(\n\t\t\tminor_status,\n\t\t\tctx->internal_ctx_id,\n\t\t\t(src_name ? &localSourceName : NULL),\n\t\t\t(targ_name ? &localTargName : NULL),\n\t\t\tlifetime_rec,\n\t\t\t&actual_mech,\n\t\t\tctx_flags,\n\t\t\tlocally_initiated,\n\t\t\topened);\n\n    if (status != GSS_S_COMPLETE) {\n\tmap_error(minor_status, mech);\n\treturn status;\n    }\n\n    /* need to convert names */\n\n    if (src_name) {\n\tif (localSourceName) {\n\t    status = gssint_convert_name_to_union_name(minor_status, mech,\n\t\t\t\t\t\t      localSourceName, src_name);\n\n\t    if (status != GSS_S_COMPLETE) {\n\t\tif (localTargName)\n\t\t    mech->gss_release_name(&temp_minor, &localTargName);\n\t\treturn (status);\n\t    }\n\t} else {\n\t    *src_name = GSS_C_NO_NAME;\n\t}\n    }\n\n    if (targ_name) {\n        if (localTargName) {\n\t    status = gssint_convert_name_to_union_name(minor_status, mech,\n\t\t\t\t\t\t      localTargName, targ_name);\n\n\t    if (status != GSS_S_COMPLETE) {\n\t\tif (src_name)\n\t\t    (void) gss_release_name(&temp_minor, src_name);\n\n\t\treturn (status);\n\t    }\n        }\n        else {\n            *targ_name = GSS_C_NO_NAME;\n        }\n    }\n\n    if (mech_type)\n\t*mech_type = gssint_get_public_oid(actual_mech);\n\n    return(GSS_S_COMPLETE);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -31,6 +31,8 @@\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn (GSS_S_NO_CONTEXT);\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (!mech || !mech->gss_inquire_context || !mech->gss_display_name ||",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)",
                "\treturn (GSS_S_NO_CONTEXT);"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-11462",
        "func_name": "krb5/gss_pseudo_random",
        "description": "Double free vulnerability in MIT Kerberos 5 (aka krb5) allows attackers to have unspecified impact via vectors involving automatic deletion of security contexts on error.",
        "git_url": "https://github.com/krb5/krb5/commit/56f7b1bc95a2a3eeb420e069e7655fb181ade5cf",
        "commit_title": "Preserve GSS context on init/accept failure",
        "commit_text": " After gss_init_sec_context() or gss_accept_sec_context() has created a context, don't delete the mechglue context on failures from subsequent calls, even if the mechanism deletes the mech-specific context (which is allowed by RFC 2744 but not preferred).  Check for union contexts with no mechanism context in each GSS function which accepts a gss_ctx_id_t.  CVE-2017-11462:  RFC 2744 permits a GSS-API implementation to delete an existing security context on a second or subsequent call to gss_init_sec_context() or gss_accept_sec_context() if the call results in an error.  This API behavior has been found to be dangerous, leading to the possibility of memory errors in some callers.  For safety, GSS-API implementations should instead preserve existing security contexts on error until the caller deletes them.  All versions of MIT krb5 prior to this change may delete acceptor contexts on error.  Versions 1.13.4 through 1.13.7, 1.14.1 through 1.14.5, and 1.15 through 1.15.1 may also delete initiator contexts on error.  ticket: 8598 (new) target_version: 1.15-next target_version: 1.14-next tags: pullup",
        "func_before": "OM_uint32 KRB5_CALLCONV\ngss_pseudo_random (OM_uint32 *minor_status,\n\t           gss_ctx_id_t context_handle,\n\t           int prf_key,\n\t           const gss_buffer_t prf_in,\n\t           ssize_t desired_output_len,\n\t           gss_buffer_t prf_out)\n{\n    OM_uint32\t\tstatus;\n    gss_union_ctx_id_t\tctx;\n    gss_mechanism\tmech;\n\n    if (minor_status == NULL)\n\treturn GSS_S_CALL_INACCESSIBLE_WRITE;\n\n    if (context_handle == GSS_C_NO_CONTEXT)\n\treturn GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT;\n\n    if (prf_in == GSS_C_NO_BUFFER)\n\treturn GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT;\n\n    if (prf_out == GSS_C_NO_BUFFER)\n\treturn GSS_S_CALL_INACCESSIBLE_WRITE | GSS_S_NO_CONTEXT;\n\n    prf_out->length = 0;\n    prf_out->value = NULL;\n\n    /*\n     * select the approprate underlying mechanism routine and\n     * call it.\n     */\n\n    ctx = (gss_union_ctx_id_t) context_handle;\n    mech = gssint_get_mechanism (ctx->mech_type);\n\n    if (mech != NULL) {\n\tif (mech->gss_pseudo_random != NULL) {\n\t    status = mech->gss_pseudo_random(minor_status,\n\t\t\t\t\t     ctx->internal_ctx_id,\n\t\t\t\t\t     prf_key,\n\t\t\t\t\t     prf_in,\n\t\t\t\t\t     desired_output_len,\n\t\t\t\t\t     prf_out);\n\t    if (status != GSS_S_COMPLETE)\n\t\tmap_error(minor_status, mech);\n\t} else\n\t    status = GSS_S_UNAVAILABLE;\n\n\treturn status;\n    }\n\n    return GSS_S_BAD_MECH;\n}",
        "func": "OM_uint32 KRB5_CALLCONV\ngss_pseudo_random (OM_uint32 *minor_status,\n\t           gss_ctx_id_t context_handle,\n\t           int prf_key,\n\t           const gss_buffer_t prf_in,\n\t           ssize_t desired_output_len,\n\t           gss_buffer_t prf_out)\n{\n    OM_uint32\t\tstatus;\n    gss_union_ctx_id_t\tctx;\n    gss_mechanism\tmech;\n\n    if (minor_status == NULL)\n\treturn GSS_S_CALL_INACCESSIBLE_WRITE;\n\n    if (context_handle == GSS_C_NO_CONTEXT)\n\treturn GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT;\n\n    if (prf_in == GSS_C_NO_BUFFER)\n\treturn GSS_S_CALL_INACCESSIBLE_READ | GSS_S_NO_CONTEXT;\n\n    if (prf_out == GSS_C_NO_BUFFER)\n\treturn GSS_S_CALL_INACCESSIBLE_WRITE | GSS_S_NO_CONTEXT;\n\n    prf_out->length = 0;\n    prf_out->value = NULL;\n\n    /*\n     * select the approprate underlying mechanism routine and\n     * call it.\n     */\n\n    ctx = (gss_union_ctx_id_t) context_handle;\n    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n\treturn GSS_S_NO_CONTEXT;\n    mech = gssint_get_mechanism (ctx->mech_type);\n\n    if (mech != NULL) {\n\tif (mech->gss_pseudo_random != NULL) {\n\t    status = mech->gss_pseudo_random(minor_status,\n\t\t\t\t\t     ctx->internal_ctx_id,\n\t\t\t\t\t     prf_key,\n\t\t\t\t\t     prf_in,\n\t\t\t\t\t     desired_output_len,\n\t\t\t\t\t     prf_out);\n\t    if (status != GSS_S_COMPLETE)\n\t\tmap_error(minor_status, mech);\n\t} else\n\t    status = GSS_S_UNAVAILABLE;\n\n\treturn status;\n    }\n\n    return GSS_S_BAD_MECH;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -31,6 +31,8 @@\n      */\n \n     ctx = (gss_union_ctx_id_t) context_handle;\n+    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)\n+\treturn GSS_S_NO_CONTEXT;\n     mech = gssint_get_mechanism (ctx->mech_type);\n \n     if (mech != NULL) {",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    if (ctx->internal_ctx_id == GSS_C_NO_CONTEXT)",
                "\treturn GSS_S_NO_CONTEXT;"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-6912",
        "func_name": "libgd/gdImageWebpEx",
        "description": "Double free vulnerability in the gdImageWebPtr function in the GD Graphics Library (aka libgd) before 2.2.4 allows remote attackers to have unspecified impact via large width and height values.",
        "git_url": "https://github.com/libgd/libgd/commit/a49feeae76d41959d85ee733925a4cf40bac61b2",
        "commit_title": "Fix double-free in gdImageWebPtr()",
        "commit_text": " The issue is that gdImageWebpCtx() (which is called by gdImageWebpPtr() and the other WebP output functions to do the real work) does not return whether it succeeded or failed, so this is not checked in gdImageWebpPtr() and the function wrongly assumes everything is okay, which is not, in this case, because there is a size limitation for WebP, namely that the width and height must by less than 16383.  We can't change the signature of gdImageWebpCtx() for API compatibility reasons, so we introduce the static helper _gdImageWebpCtx() which returns success respective failure, so gdImageWebpPtr() and gdImageWebpPtrEx() can check the return value. We leave it solely to libwebp for now to report warnings regarding the failing write.  This issue had been reported by Ibrahim El-Sayed to security@libgd.org.  CVE-2016-6912",
        "func_before": "BGD_DECLARE(void) gdImageWebpEx (gdImagePtr im, FILE * outFile, int quality)\n{\n\tgdIOCtx *out = gdNewFileCtx(outFile);\n\tif (out == NULL) {\n\t\treturn;\n\t}\n\tgdImageWebpCtx(im, out, quality);\n\tout->gd_free(out);\n}",
        "func": "BGD_DECLARE(void) gdImageWebpEx (gdImagePtr im, FILE * outFile, int quality)\n{\n\tgdIOCtx *out = gdNewFileCtx(outFile);\n\tif (out == NULL) {\n\t\treturn;\n\t}\n\t_gdImageWebpCtx(im, out, quality);\n\tout->gd_free(out);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,6 +4,6 @@\n \tif (out == NULL) {\n \t\treturn;\n \t}\n-\tgdImageWebpCtx(im, out, quality);\n+\t_gdImageWebpCtx(im, out, quality);\n \tout->gd_free(out);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tgdImageWebpCtx(im, out, quality);"
            ],
            "added_lines": [
                "\t_gdImageWebpCtx(im, out, quality);"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-6912",
        "func_name": "libgd/gdImageWebp",
        "description": "Double free vulnerability in the gdImageWebPtr function in the GD Graphics Library (aka libgd) before 2.2.4 allows remote attackers to have unspecified impact via large width and height values.",
        "git_url": "https://github.com/libgd/libgd/commit/a49feeae76d41959d85ee733925a4cf40bac61b2",
        "commit_title": "Fix double-free in gdImageWebPtr()",
        "commit_text": " The issue is that gdImageWebpCtx() (which is called by gdImageWebpPtr() and the other WebP output functions to do the real work) does not return whether it succeeded or failed, so this is not checked in gdImageWebpPtr() and the function wrongly assumes everything is okay, which is not, in this case, because there is a size limitation for WebP, namely that the width and height must by less than 16383.  We can't change the signature of gdImageWebpCtx() for API compatibility reasons, so we introduce the static helper _gdImageWebpCtx() which returns success respective failure, so gdImageWebpPtr() and gdImageWebpPtrEx() can check the return value. We leave it solely to libwebp for now to report warnings regarding the failing write.  This issue had been reported by Ibrahim El-Sayed to security@libgd.org.  CVE-2016-6912",
        "func_before": "BGD_DECLARE(void) gdImageWebp (gdImagePtr im, FILE * outFile)\n{\n\tgdIOCtx *out = gdNewFileCtx(outFile);\n\tif (out == NULL) {\n\t\treturn;\n\t}\n\tgdImageWebpCtx(im, out, -1);\n\tout->gd_free(out);\n}",
        "func": "BGD_DECLARE(void) gdImageWebp (gdImagePtr im, FILE * outFile)\n{\n\tgdIOCtx *out = gdNewFileCtx(outFile);\n\tif (out == NULL) {\n\t\treturn;\n\t}\n\t_gdImageWebpCtx(im, out, -1);\n\tout->gd_free(out);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,6 +4,6 @@\n \tif (out == NULL) {\n \t\treturn;\n \t}\n-\tgdImageWebpCtx(im, out, -1);\n+\t_gdImageWebpCtx(im, out, -1);\n \tout->gd_free(out);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tgdImageWebpCtx(im, out, -1);"
            ],
            "added_lines": [
                "\t_gdImageWebpCtx(im, out, -1);"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-6912",
        "func_name": "libgd/gdImageWebpCtx",
        "description": "Double free vulnerability in the gdImageWebPtr function in the GD Graphics Library (aka libgd) before 2.2.4 allows remote attackers to have unspecified impact via large width and height values.",
        "git_url": "https://github.com/libgd/libgd/commit/a49feeae76d41959d85ee733925a4cf40bac61b2",
        "commit_title": "Fix double-free in gdImageWebPtr()",
        "commit_text": " The issue is that gdImageWebpCtx() (which is called by gdImageWebpPtr() and the other WebP output functions to do the real work) does not return whether it succeeded or failed, so this is not checked in gdImageWebpPtr() and the function wrongly assumes everything is okay, which is not, in this case, because there is a size limitation for WebP, namely that the width and height must by less than 16383.  We can't change the signature of gdImageWebpCtx() for API compatibility reasons, so we introduce the static helper _gdImageWebpCtx() which returns success respective failure, so gdImageWebpPtr() and gdImageWebpPtrEx() can check the return value. We leave it solely to libwebp for now to report warnings regarding the failing write.  This issue had been reported by Ibrahim El-Sayed to security@libgd.org.  CVE-2016-6912",
        "func_before": "BGD_DECLARE(void) gdImageWebpCtx (gdImagePtr im, gdIOCtx * outfile, int quality)\n{\n\tuint8_t *argb;\n\tint x, y;\n\tuint8_t *p;\n\tuint8_t *out;\n\tsize_t out_size;\n\n\tif (im == NULL) {\n\t\treturn;\n\t}\n\n\tif (!gdImageTrueColor(im)) {\n\t\tgd_error(\"Paletter image not supported by webp\");\n\t\treturn;\n\t}\n\n\tif (quality == -1) {\n\t\tquality = 80;\n\t}\n\n\tif (overflow2(gdImageSX(im), 4)) {\n\t\treturn;\n\t}\n\n\tif (overflow2(gdImageSX(im) * 4, gdImageSY(im))) {\n\t\treturn;\n\t}\n\n\targb = (uint8_t *)gdMalloc(gdImageSX(im) * 4 * gdImageSY(im));\n\tif (!argb) {\n\t\treturn;\n\t}\n\tp = argb;\n\tfor (y = 0; y < gdImageSY(im); y++) {\n\t\tfor (x = 0; x < gdImageSX(im); x++) {\n\t\t\tregister int c;\n\t\t\tregister char a;\n\t\t\tc = im->tpixels[y][x];\n\t\t\ta = gdTrueColorGetAlpha(c);\n\t\t\tif (a == 127) {\n\t\t\t\ta = 0;\n\t\t\t} else {\n\t\t\t\ta = 255 - ((a << 1) + (a >> 6));\n\t\t\t}\n\t\t\t*(p++) = gdTrueColorGetRed(c);\n\t\t\t*(p++) = gdTrueColorGetGreen(c);\n\t\t\t*(p++) = gdTrueColorGetBlue(c); \n\t\t\t*(p++) = a;\n\t\t}\n\t}\n\tout_size = WebPEncodeRGBA(argb, gdImageSX(im), gdImageSY(im), gdImageSX(im) * 4, quality, &out);\n\tif (out_size == 0) {\n\t\tgd_error(\"gd-webp encoding failed\");\n\t\tgoto freeargb;\n\t}\n\tgdPutBuf(out, out_size, outfile);\n\tfree(out);\n\nfreeargb:\n\tgdFree(argb);\n}",
        "func": "BGD_DECLARE(void) gdImageWebpCtx (gdImagePtr im, gdIOCtx * outfile, int quality)\n{\n\t_gdImageWebpCtx(im, outfile, quality);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,62 +1,4 @@\n BGD_DECLARE(void) gdImageWebpCtx (gdImagePtr im, gdIOCtx * outfile, int quality)\n {\n-\tuint8_t *argb;\n-\tint x, y;\n-\tuint8_t *p;\n-\tuint8_t *out;\n-\tsize_t out_size;\n-\n-\tif (im == NULL) {\n-\t\treturn;\n-\t}\n-\n-\tif (!gdImageTrueColor(im)) {\n-\t\tgd_error(\"Paletter image not supported by webp\");\n-\t\treturn;\n-\t}\n-\n-\tif (quality == -1) {\n-\t\tquality = 80;\n-\t}\n-\n-\tif (overflow2(gdImageSX(im), 4)) {\n-\t\treturn;\n-\t}\n-\n-\tif (overflow2(gdImageSX(im) * 4, gdImageSY(im))) {\n-\t\treturn;\n-\t}\n-\n-\targb = (uint8_t *)gdMalloc(gdImageSX(im) * 4 * gdImageSY(im));\n-\tif (!argb) {\n-\t\treturn;\n-\t}\n-\tp = argb;\n-\tfor (y = 0; y < gdImageSY(im); y++) {\n-\t\tfor (x = 0; x < gdImageSX(im); x++) {\n-\t\t\tregister int c;\n-\t\t\tregister char a;\n-\t\t\tc = im->tpixels[y][x];\n-\t\t\ta = gdTrueColorGetAlpha(c);\n-\t\t\tif (a == 127) {\n-\t\t\t\ta = 0;\n-\t\t\t} else {\n-\t\t\t\ta = 255 - ((a << 1) + (a >> 6));\n-\t\t\t}\n-\t\t\t*(p++) = gdTrueColorGetRed(c);\n-\t\t\t*(p++) = gdTrueColorGetGreen(c);\n-\t\t\t*(p++) = gdTrueColorGetBlue(c); \n-\t\t\t*(p++) = a;\n-\t\t}\n-\t}\n-\tout_size = WebPEncodeRGBA(argb, gdImageSX(im), gdImageSY(im), gdImageSX(im) * 4, quality, &out);\n-\tif (out_size == 0) {\n-\t\tgd_error(\"gd-webp encoding failed\");\n-\t\tgoto freeargb;\n-\t}\n-\tgdPutBuf(out, out_size, outfile);\n-\tfree(out);\n-\n-freeargb:\n-\tgdFree(argb);\n+\t_gdImageWebpCtx(im, outfile, quality);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tuint8_t *argb;",
                "\tint x, y;",
                "\tuint8_t *p;",
                "\tuint8_t *out;",
                "\tsize_t out_size;",
                "",
                "\tif (im == NULL) {",
                "\t\treturn;",
                "\t}",
                "",
                "\tif (!gdImageTrueColor(im)) {",
                "\t\tgd_error(\"Paletter image not supported by webp\");",
                "\t\treturn;",
                "\t}",
                "",
                "\tif (quality == -1) {",
                "\t\tquality = 80;",
                "\t}",
                "",
                "\tif (overflow2(gdImageSX(im), 4)) {",
                "\t\treturn;",
                "\t}",
                "",
                "\tif (overflow2(gdImageSX(im) * 4, gdImageSY(im))) {",
                "\t\treturn;",
                "\t}",
                "",
                "\targb = (uint8_t *)gdMalloc(gdImageSX(im) * 4 * gdImageSY(im));",
                "\tif (!argb) {",
                "\t\treturn;",
                "\t}",
                "\tp = argb;",
                "\tfor (y = 0; y < gdImageSY(im); y++) {",
                "\t\tfor (x = 0; x < gdImageSX(im); x++) {",
                "\t\t\tregister int c;",
                "\t\t\tregister char a;",
                "\t\t\tc = im->tpixels[y][x];",
                "\t\t\ta = gdTrueColorGetAlpha(c);",
                "\t\t\tif (a == 127) {",
                "\t\t\t\ta = 0;",
                "\t\t\t} else {",
                "\t\t\t\ta = 255 - ((a << 1) + (a >> 6));",
                "\t\t\t}",
                "\t\t\t*(p++) = gdTrueColorGetRed(c);",
                "\t\t\t*(p++) = gdTrueColorGetGreen(c);",
                "\t\t\t*(p++) = gdTrueColorGetBlue(c); ",
                "\t\t\t*(p++) = a;",
                "\t\t}",
                "\t}",
                "\tout_size = WebPEncodeRGBA(argb, gdImageSX(im), gdImageSY(im), gdImageSX(im) * 4, quality, &out);",
                "\tif (out_size == 0) {",
                "\t\tgd_error(\"gd-webp encoding failed\");",
                "\t\tgoto freeargb;",
                "\t}",
                "\tgdPutBuf(out, out_size, outfile);",
                "\tfree(out);",
                "",
                "freeargb:",
                "\tgdFree(argb);"
            ],
            "added_lines": [
                "\t_gdImageWebpCtx(im, outfile, quality);"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-6912",
        "func_name": "libgd/gdImageWebpPtr",
        "description": "Double free vulnerability in the gdImageWebPtr function in the GD Graphics Library (aka libgd) before 2.2.4 allows remote attackers to have unspecified impact via large width and height values.",
        "git_url": "https://github.com/libgd/libgd/commit/a49feeae76d41959d85ee733925a4cf40bac61b2",
        "commit_title": "Fix double-free in gdImageWebPtr()",
        "commit_text": " The issue is that gdImageWebpCtx() (which is called by gdImageWebpPtr() and the other WebP output functions to do the real work) does not return whether it succeeded or failed, so this is not checked in gdImageWebpPtr() and the function wrongly assumes everything is okay, which is not, in this case, because there is a size limitation for WebP, namely that the width and height must by less than 16383.  We can't change the signature of gdImageWebpCtx() for API compatibility reasons, so we introduce the static helper _gdImageWebpCtx() which returns success respective failure, so gdImageWebpPtr() and gdImageWebpPtrEx() can check the return value. We leave it solely to libwebp for now to report warnings regarding the failing write.  This issue had been reported by Ibrahim El-Sayed to security@libgd.org.  CVE-2016-6912",
        "func_before": "BGD_DECLARE(void *) gdImageWebpPtr (gdImagePtr im, int *size)\n{\n\tvoid *rv;\n\tgdIOCtx *out = gdNewDynamicCtx(2048, NULL);\n\tif (out == NULL) {\n\t\treturn NULL;\n\t}\n\tgdImageWebpCtx(im, out, -1);\n\trv = gdDPExtractData(out, size);\n\tout->gd_free(out);\n\n\treturn rv;\n}",
        "func": "BGD_DECLARE(void *) gdImageWebpPtr (gdImagePtr im, int *size)\n{\n\tvoid *rv;\n\tgdIOCtx *out = gdNewDynamicCtx(2048, NULL);\n\tif (out == NULL) {\n\t\treturn NULL;\n\t}\n\tif (_gdImageWebpCtx(im, out, -1)) {\n\t\trv = NULL;\n\t} else {\n\t\trv = gdDPExtractData(out, size);\n\t}\n\tout->gd_free(out);\n\n\treturn rv;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,8 +5,11 @@\n \tif (out == NULL) {\n \t\treturn NULL;\n \t}\n-\tgdImageWebpCtx(im, out, -1);\n-\trv = gdDPExtractData(out, size);\n+\tif (_gdImageWebpCtx(im, out, -1)) {\n+\t\trv = NULL;\n+\t} else {\n+\t\trv = gdDPExtractData(out, size);\n+\t}\n \tout->gd_free(out);\n \n \treturn rv;",
        "diff_line_info": {
            "deleted_lines": [
                "\tgdImageWebpCtx(im, out, -1);",
                "\trv = gdDPExtractData(out, size);"
            ],
            "added_lines": [
                "\tif (_gdImageWebpCtx(im, out, -1)) {",
                "\t\trv = NULL;",
                "\t} else {",
                "\t\trv = gdDPExtractData(out, size);",
                "\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-6912",
        "func_name": "libgd/gdImageWebpPtrEx",
        "description": "Double free vulnerability in the gdImageWebPtr function in the GD Graphics Library (aka libgd) before 2.2.4 allows remote attackers to have unspecified impact via large width and height values.",
        "git_url": "https://github.com/libgd/libgd/commit/a49feeae76d41959d85ee733925a4cf40bac61b2",
        "commit_title": "Fix double-free in gdImageWebPtr()",
        "commit_text": " The issue is that gdImageWebpCtx() (which is called by gdImageWebpPtr() and the other WebP output functions to do the real work) does not return whether it succeeded or failed, so this is not checked in gdImageWebpPtr() and the function wrongly assumes everything is okay, which is not, in this case, because there is a size limitation for WebP, namely that the width and height must by less than 16383.  We can't change the signature of gdImageWebpCtx() for API compatibility reasons, so we introduce the static helper _gdImageWebpCtx() which returns success respective failure, so gdImageWebpPtr() and gdImageWebpPtrEx() can check the return value. We leave it solely to libwebp for now to report warnings regarding the failing write.  This issue had been reported by Ibrahim El-Sayed to security@libgd.org.  CVE-2016-6912",
        "func_before": "BGD_DECLARE(void *) gdImageWebpPtrEx (gdImagePtr im, int *size, int quality)\n{\n\tvoid *rv;\n\tgdIOCtx *out = gdNewDynamicCtx(2048, NULL);\n\tif (out == NULL) {\n\t\treturn NULL;\n\t}\n\tgdImageWebpCtx(im, out, quality);\n\trv = gdDPExtractData(out, size);\n\tout->gd_free(out);\n\treturn rv;\n}",
        "func": "BGD_DECLARE(void *) gdImageWebpPtrEx (gdImagePtr im, int *size, int quality)\n{\n\tvoid *rv;\n\tgdIOCtx *out = gdNewDynamicCtx(2048, NULL);\n\tif (out == NULL) {\n\t\treturn NULL;\n\t}\n\tif (_gdImageWebpCtx(im, out, quality)) {\n        rv = NULL;\n    } else {\n        rv = gdDPExtractData(out, size);\n    }\n\tout->gd_free(out);\n\treturn rv;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,8 +5,11 @@\n \tif (out == NULL) {\n \t\treturn NULL;\n \t}\n-\tgdImageWebpCtx(im, out, quality);\n-\trv = gdDPExtractData(out, size);\n+\tif (_gdImageWebpCtx(im, out, quality)) {\n+        rv = NULL;\n+    } else {\n+        rv = gdDPExtractData(out, size);\n+    }\n \tout->gd_free(out);\n \treturn rv;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tgdImageWebpCtx(im, out, quality);",
                "\trv = gdDPExtractData(out, size);"
            ],
            "added_lines": [
                "\tif (_gdImageWebpCtx(im, out, quality)) {",
                "        rv = NULL;",
                "    } else {",
                "        rv = gdDPExtractData(out, size);",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-17498",
        "func_name": "wireshark/decompress_lz4",
        "description": "In Wireshark 3.2.0 to 3.2.5, the Kafka protocol dissector could crash. This was addressed in epan/dissectors/packet-kafka.c by avoiding a double free during LZ4 decompression.",
        "git_url": "https://github.com/wireshark/wireshark/commit/76afda963de4f0b9be24f2d8e873990a5cbf221b",
        "commit_title": "kafka: lz4: free the composite tvb only once",
        "commit_text": " Try to clean up the composite tvb handling during lz4 decompression.  If we detect an error straight away before doing any lz4 decompression, we don't allocate a composite tvb at all. The comments in the tvb code say explicitly that we must not call tvb_new_composite() without adding at least one piece of data.  If we start decompressing and run into problems after creating the composite tvb and linking it to the packet's main tvb, we must not free the composite tvb manually. The epan library will do this for us when dissection of the packet is finished.  While at it, make sure that we always finalize the composite tvb if we allocated it and added data to it.  Bug: 16672 (cherry picked from commit 79576219c92e252c0700cdbe729bfb0fe6c72bd9)",
        "func_before": "static int\ndecompress_lz4(tvbuff_t *tvb, packet_info *pinfo, int offset, guint32 length, tvbuff_t **decompressed_tvb, int *decompressed_offset)\n{\n    LZ4F_decompressionContext_t lz4_ctxt = NULL;\n    LZ4F_frameInfo_t lz4_info;\n    LZ4F_errorCode_t rc = 0;\n    size_t src_offset = 0, src_size = 0, dst_size = 0;\n    guchar *decompressed_buffer = NULL;\n    tvbuff_t *composite_tvb = tvb_new_composite();\n\n    int ret = 0;\n\n    /* Prepare compressed data buffer */\n    guint8 *data = (guint8*)tvb_memdup(wmem_packet_scope(), tvb, offset, length);\n    /* Override header checksum to workaround buggy Kafka implementations */\n    if (length > 7) {\n        guint32 hdr_end = 6;\n        if (data[4] & 0x08) {\n            hdr_end += 8;\n        }\n        if (hdr_end < length) {\n            data[hdr_end] = (XXH32(&data[4], hdr_end - 4, 0) >> 8) & 0xff;\n        }\n    }\n\n    /* Allocate output buffer */\n    rc = LZ4F_createDecompressionContext(&lz4_ctxt, LZ4F_VERSION);\n    if (LZ4F_isError(rc)) {\n        goto end;\n    }\n\n    src_offset = length;\n    rc = LZ4F_getFrameInfo(lz4_ctxt, &lz4_info, data, &src_offset);\n    if (LZ4F_isError(rc)) {\n        goto end;\n    }\n\n    switch (lz4_info.blockSizeID) {\n        case LZ4F_max64KB:\n            dst_size = 1 << 16;\n            break;\n        case LZ4F_max256KB:\n            dst_size = 1 << 18;\n            break;\n        case LZ4F_max1MB:\n            dst_size = 1 << 20;\n            break;\n        case LZ4F_max4MB:\n            dst_size = 1 << 22;\n            break;\n        default:\n            goto end;\n    }\n\n    if (lz4_info.contentSize && lz4_info.contentSize < dst_size) {\n        dst_size = (size_t)lz4_info.contentSize;\n    }\n\n    do {\n        src_size = length - src_offset; // set the number of available octets\n        if (src_size == 0) {\n            goto end;\n        }\n        decompressed_buffer = (guchar*)wmem_alloc(pinfo->pool, dst_size);\n        rc = LZ4F_decompress(lz4_ctxt, decompressed_buffer, &dst_size,\n                              &data[src_offset], &src_size, NULL);\n        if (LZ4F_isError(rc)) {\n            goto end;\n        }\n        if (dst_size == 0) {\n            goto end;\n        }\n        tvb_composite_append(composite_tvb,\n                             tvb_new_child_real_data(tvb, (guint8*)decompressed_buffer, (guint)dst_size, (gint)dst_size));\n        src_offset += src_size; // bump up the offset for the next iteration\n    } while (rc > 0);\n\n    tvb_composite_finalize(composite_tvb);\n    *decompressed_tvb = composite_tvb;\n    *decompressed_offset = 0;\n    composite_tvb = NULL;\n    ret = 1;\nend:\n    LZ4F_freeDecompressionContext(lz4_ctxt);\n    if (composite_tvb != NULL) {\n        tvb_free_chain(composite_tvb);\n    }\n    if (ret == 0) {\n        col_append_str(pinfo->cinfo, COL_INFO, \" [lz4 decompression failed]\");\n    }\n    return ret;\n}",
        "func": "static int\ndecompress_lz4(tvbuff_t *tvb, packet_info *pinfo, int offset, guint32 length, tvbuff_t **decompressed_tvb, int *decompressed_offset)\n{\n    LZ4F_decompressionContext_t lz4_ctxt = NULL;\n    LZ4F_frameInfo_t lz4_info;\n    LZ4F_errorCode_t rc = 0;\n    size_t src_offset = 0, src_size = 0, dst_size = 0;\n    guchar *decompressed_buffer = NULL;\n    tvbuff_t *composite_tvb = NULL;\n\n    int ret = 0;\n\n    /* Prepare compressed data buffer */\n    guint8 *data = (guint8*)tvb_memdup(wmem_packet_scope(), tvb, offset, length);\n    /* Override header checksum to workaround buggy Kafka implementations */\n    if (length > 7) {\n        guint32 hdr_end = 6;\n        if (data[4] & 0x08) {\n            hdr_end += 8;\n        }\n        if (hdr_end < length) {\n            data[hdr_end] = (XXH32(&data[4], hdr_end - 4, 0) >> 8) & 0xff;\n        }\n    }\n\n    /* Allocate output buffer */\n    rc = LZ4F_createDecompressionContext(&lz4_ctxt, LZ4F_VERSION);\n    if (LZ4F_isError(rc)) {\n        goto end;\n    }\n\n    src_offset = length;\n    rc = LZ4F_getFrameInfo(lz4_ctxt, &lz4_info, data, &src_offset);\n    if (LZ4F_isError(rc)) {\n        goto end;\n    }\n\n    switch (lz4_info.blockSizeID) {\n        case LZ4F_max64KB:\n            dst_size = 1 << 16;\n            break;\n        case LZ4F_max256KB:\n            dst_size = 1 << 18;\n            break;\n        case LZ4F_max1MB:\n            dst_size = 1 << 20;\n            break;\n        case LZ4F_max4MB:\n            dst_size = 1 << 22;\n            break;\n        default:\n            goto end;\n    }\n\n    if (lz4_info.contentSize && lz4_info.contentSize < dst_size) {\n        dst_size = (size_t)lz4_info.contentSize;\n    }\n\n    do {\n        src_size = length - src_offset; // set the number of available octets\n        if (src_size == 0) {\n            goto end;\n        }\n        decompressed_buffer = (guchar*)wmem_alloc(pinfo->pool, dst_size);\n        rc = LZ4F_decompress(lz4_ctxt, decompressed_buffer, &dst_size,\n                              &data[src_offset], &src_size, NULL);\n        if (LZ4F_isError(rc)) {\n            goto end;\n        }\n        if (dst_size == 0) {\n            goto end;\n        }\n        if (!composite_tvb) {\n            composite_tvb = tvb_new_composite();\n        }\n        tvb_composite_append(composite_tvb,\n                             tvb_new_child_real_data(tvb, (guint8*)decompressed_buffer, (guint)dst_size, (gint)dst_size));\n        src_offset += src_size; // bump up the offset for the next iteration\n    } while (rc > 0);\n\n    ret = 1;\nend:\n    if (composite_tvb) {\n        tvb_composite_finalize(composite_tvb);\n    }\n    LZ4F_freeDecompressionContext(lz4_ctxt);\n    if (ret == 1) {\n        *decompressed_tvb = composite_tvb;\n        *decompressed_offset = 0;\n    }\n    else {\n        col_append_str(pinfo->cinfo, COL_INFO, \" [lz4 decompression failed]\");\n    }\n    return ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,7 +6,7 @@\n     LZ4F_errorCode_t rc = 0;\n     size_t src_offset = 0, src_size = 0, dst_size = 0;\n     guchar *decompressed_buffer = NULL;\n-    tvbuff_t *composite_tvb = tvb_new_composite();\n+    tvbuff_t *composite_tvb = NULL;\n \n     int ret = 0;\n \n@@ -70,22 +70,25 @@\n         if (dst_size == 0) {\n             goto end;\n         }\n+        if (!composite_tvb) {\n+            composite_tvb = tvb_new_composite();\n+        }\n         tvb_composite_append(composite_tvb,\n                              tvb_new_child_real_data(tvb, (guint8*)decompressed_buffer, (guint)dst_size, (gint)dst_size));\n         src_offset += src_size; // bump up the offset for the next iteration\n     } while (rc > 0);\n \n-    tvb_composite_finalize(composite_tvb);\n-    *decompressed_tvb = composite_tvb;\n-    *decompressed_offset = 0;\n-    composite_tvb = NULL;\n     ret = 1;\n end:\n+    if (composite_tvb) {\n+        tvb_composite_finalize(composite_tvb);\n+    }\n     LZ4F_freeDecompressionContext(lz4_ctxt);\n-    if (composite_tvb != NULL) {\n-        tvb_free_chain(composite_tvb);\n+    if (ret == 1) {\n+        *decompressed_tvb = composite_tvb;\n+        *decompressed_offset = 0;\n     }\n-    if (ret == 0) {\n+    else {\n         col_append_str(pinfo->cinfo, COL_INFO, \" [lz4 decompression failed]\");\n     }\n     return ret;",
        "diff_line_info": {
            "deleted_lines": [
                "    tvbuff_t *composite_tvb = tvb_new_composite();",
                "    tvb_composite_finalize(composite_tvb);",
                "    *decompressed_tvb = composite_tvb;",
                "    *decompressed_offset = 0;",
                "    composite_tvb = NULL;",
                "    if (composite_tvb != NULL) {",
                "        tvb_free_chain(composite_tvb);",
                "    if (ret == 0) {"
            ],
            "added_lines": [
                "    tvbuff_t *composite_tvb = NULL;",
                "        if (!composite_tvb) {",
                "            composite_tvb = tvb_new_composite();",
                "        }",
                "    if (composite_tvb) {",
                "        tvb_composite_finalize(composite_tvb);",
                "    }",
                "    if (ret == 1) {",
                "        *decompressed_tvb = composite_tvb;",
                "        *decompressed_offset = 0;",
                "    else {"
            ]
        }
    },
    {
        "cve_id": "CVE-2014-4343",
        "func_name": "krb5/init_ctx_reselect",
        "description": "Double free vulnerability in the init_ctx_reselect function in the SPNEGO initiator in lib/gssapi/spnego/spnego_mech.c in MIT Kerberos 5 (aka krb5) 1.10.x through 1.12.x before 1.12.2 allows remote attackers to cause a denial of service (memory corruption) or possibly execute arbitrary code via network traffic that appears to come from an intended acceptor, but specifies a security mechanism different from the one proposed by the initiator.",
        "git_url": "https://github.com/krb5/krb5/commit/f18ddf5d82de0ab7591a36e465bc24225776940f",
        "commit_title": "Fix double-free in SPNEGO [CVE-2014-4343]",
        "commit_text": " In commit cd7d6b08 (\"Verify acceptor's mech in SPNEGO initiator\") the pointer sc->internal_mech became an alias into sc->mech_set->elements, which should be considered constant for the duration of the SPNEGO context.  So don't free it.  CVE-2014-4343:  In MIT krb5 releases 1.10 and newer, an unauthenticated remote attacker with the ability to spoof packets appearing to be from a GSSAPI acceptor can cause a double-free condition in GSSAPI initiators (clients) which are using the SPNEGO mechanism, by returning a different underlying mechanism than was proposed by the initiator.  At this stage of the negotiation, the acceptor is unauthenticated, and the acceptor's response could be spoofed by an attacker with the ability to inject traffic to the initiator.  Historically, some double-free vulnerabilities can be translated into remote code execution, though the necessary exploits must be tailored to the individual application and are usually quite complicated. Double-frees can also be exploited to cause an application crash, for a denial of service.  However, most GSSAPI client applications are not vulnerable, as the SPNEGO mechanism is not used by default (when GSS_C_NO_OID is passed as the mech_type argument to gss_init_sec_context()).  The most common use of SPNEGO is for HTTP-Negotiate, used in web browsers and other web clients.  Most such clients are believed to not offer HTTP-Negotiate by default, instead requiring a whitelist of sites for which it may be used to be configured.  If the whitelist is configured to only allow HTTP-Negotiate over TLS connections (\"https://\"), a successful attacker must also spoof the web server's SSL certificate, due to the way the WWW-Authenticate header is sent in a 401 (Unauthorized) response message.  Unfortunately, many instructions for enabling HTTP-Negotiate in common web browsers do not include a TLS requirement.      CVSSv2 Vector: AV:N/AC:H/Au:N/C:C/I:C/A:C/E:POC/RL:OF/RC:C  [kaduk@mit.edu: CVE summary and CVSSv2 vector]  ticket: 7969 (new) target_version: 1.12.2 tags: pullup",
        "func_before": "static OM_uint32\ninit_ctx_reselect(OM_uint32 *minor_status, spnego_gss_ctx_id_t sc,\n\t\t  OM_uint32 acc_negState, gss_OID supportedMech,\n\t\t  gss_buffer_t *responseToken, gss_buffer_t *mechListMIC,\n\t\t  OM_uint32 *negState, send_token_flag *tokflag)\n{\n\tOM_uint32 tmpmin;\n\tsize_t i;\n\n\tgeneric_gss_release_oid(&tmpmin, &sc->internal_mech);\n\tgss_delete_sec_context(&tmpmin, &sc->ctx_handle,\n\t\t\t       GSS_C_NO_BUFFER);\n\n\t/* Find supportedMech in sc->mech_set. */\n\tfor (i = 0; i < sc->mech_set->count; i++) {\n\t\tif (g_OID_equal(supportedMech, &sc->mech_set->elements[i]))\n\t\t\tbreak;\n\t}\n\tif (i == sc->mech_set->count)\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\tsc->internal_mech = &sc->mech_set->elements[i];\n\n\t/*\n\t * Windows 2003 and earlier don't correctly send a\n\t * negState of request-mic when counter-proposing a\n\t * mechanism.  They probably don't handle mechListMICs\n\t * properly either.\n\t */\n\tif (acc_negState != REQUEST_MIC)\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\n\tsc->mech_complete = 0;\n\tsc->mic_reqd = 1;\n\t*negState = REQUEST_MIC;\n\t*tokflag = CONT_TOKEN_SEND;\n\treturn GSS_S_CONTINUE_NEEDED;\n}",
        "func": "static OM_uint32\ninit_ctx_reselect(OM_uint32 *minor_status, spnego_gss_ctx_id_t sc,\n\t\t  OM_uint32 acc_negState, gss_OID supportedMech,\n\t\t  gss_buffer_t *responseToken, gss_buffer_t *mechListMIC,\n\t\t  OM_uint32 *negState, send_token_flag *tokflag)\n{\n\tOM_uint32 tmpmin;\n\tsize_t i;\n\n\tgss_delete_sec_context(&tmpmin, &sc->ctx_handle,\n\t\t\t       GSS_C_NO_BUFFER);\n\n\t/* Find supportedMech in sc->mech_set. */\n\tfor (i = 0; i < sc->mech_set->count; i++) {\n\t\tif (g_OID_equal(supportedMech, &sc->mech_set->elements[i]))\n\t\t\tbreak;\n\t}\n\tif (i == sc->mech_set->count)\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\tsc->internal_mech = &sc->mech_set->elements[i];\n\n\t/*\n\t * Windows 2003 and earlier don't correctly send a\n\t * negState of request-mic when counter-proposing a\n\t * mechanism.  They probably don't handle mechListMICs\n\t * properly either.\n\t */\n\tif (acc_negState != REQUEST_MIC)\n\t\treturn GSS_S_DEFECTIVE_TOKEN;\n\n\tsc->mech_complete = 0;\n\tsc->mic_reqd = 1;\n\t*negState = REQUEST_MIC;\n\t*tokflag = CONT_TOKEN_SEND;\n\treturn GSS_S_CONTINUE_NEEDED;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -7,7 +7,6 @@\n \tOM_uint32 tmpmin;\n \tsize_t i;\n \n-\tgeneric_gss_release_oid(&tmpmin, &sc->internal_mech);\n \tgss_delete_sec_context(&tmpmin, &sc->ctx_handle,\n \t\t\t       GSS_C_NO_BUFFER);\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\tgeneric_gss_release_oid(&tmpmin, &sc->internal_mech);"
            ],
            "added_lines": []
        }
    },
    {
        "cve_id": "CVE-2020-36401",
        "func_name": "mruby/mrb_realloc",
        "description": "mruby 2.1.2 has a double free in mrb_default_allocf (called from mrb_free and obj_free).",
        "git_url": "https://github.com/mruby/mruby/commit/97319697c8f9f6ff27b32589947e1918e3015503",
        "commit_title": "Cancel 9cdf439",
        "commit_text": " Should not free the pointer in `realloc` since it can cause use-after-free problem.",
        "func_before": "MRB_API void*\nmrb_realloc(mrb_state *mrb, void *p, size_t len)\n{\n  void *p2;\n\n  p2 = mrb_realloc_simple(mrb, p, len);\n  if (len == 0) return p2;\n  if (p2 == NULL) {\n    mrb_free(mrb, p);\n    mrb->gc.out_of_memory = TRUE;\n    mrb_raise_nomemory(mrb);\n  }\n  else {\n    mrb->gc.out_of_memory = FALSE;\n  }\n\n  return p2;\n}",
        "func": "MRB_API void*\nmrb_realloc(mrb_state *mrb, void *p, size_t len)\n{\n  void *p2;\n\n  p2 = mrb_realloc_simple(mrb, p, len);\n  if (len == 0) return p2;\n  if (p2 == NULL) {\n    mrb->gc.out_of_memory = TRUE;\n    mrb_raise_nomemory(mrb);\n  }\n  else {\n    mrb->gc.out_of_memory = FALSE;\n  }\n\n  return p2;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,7 +6,6 @@\n   p2 = mrb_realloc_simple(mrb, p, len);\n   if (len == 0) return p2;\n   if (p2 == NULL) {\n-    mrb_free(mrb, p);\n     mrb->gc.out_of_memory = TRUE;\n     mrb_raise_nomemory(mrb);\n   }",
        "diff_line_info": {
            "deleted_lines": [
                "    mrb_free(mrb, p);"
            ],
            "added_lines": []
        }
    },
    {
        "cve_id": "CVE-2021-36088",
        "func_name": "fluent/fluent-bit/flb_parser_json_do",
        "description": "Fluent Bit (aka fluent-bit) 1.7.0 through 1.7,4 has a double free in flb_free (called from flb_parser_json_do and flb_parser_do).",
        "git_url": "https://github.com/fluent/fluent-bit/commit/22346a74c07ceb90296be872be2d53eb92252a54",
        "commit_title": "parser: json: fix double-free (#3453)",
        "commit_text": "",
        "func_before": "int flb_parser_json_do(struct flb_parser *parser,\n                       const char *in_buf, size_t in_size,\n                       void **out_buf, size_t *out_size,\n                       struct flb_time *out_time)\n{\n    int i;\n    int skip;\n    int ret;\n    int slen;\n    int root_type;\n    int records;\n    double tmfrac = 0;\n    char *mp_buf = NULL;\n    char *time_key;\n    char *tmp_out_buf = NULL;\n    char tmp[255];\n    size_t tmp_out_size = 0;\n    size_t off = 0;\n    size_t map_size;\n    size_t mp_size;\n    size_t len;\n    msgpack_sbuffer mp_sbuf;\n    msgpack_packer  mp_pck;\n    msgpack_unpacked result;\n    msgpack_object map;\n    msgpack_object *k = NULL;\n    msgpack_object *v = NULL;\n    time_t time_lookup;\n    struct tm tm = {0};\n    struct flb_time *t;\n\n    /* Convert incoming in_buf JSON message to message pack format */\n    ret = flb_pack_json_recs(in_buf, in_size, &mp_buf, &mp_size, &root_type,\n                             &records);\n    if (ret != 0) {\n        return -1;\n    }\n\n    if (records != 1) {\n        flb_free(mp_buf);\n        return -1;\n    }\n\n    /* Make sure object is a map */\n    msgpack_unpacked_init(&result);\n    if (msgpack_unpack_next(&result, mp_buf, mp_size, &off) == MSGPACK_UNPACK_SUCCESS) {\n        map = result.data;\n        if (map.type != MSGPACK_OBJECT_MAP) {\n            flb_free(mp_buf);\n            msgpack_unpacked_destroy(&result);\n            return -1;\n        }\n    }\n    else {\n        if (mp_size > 0) {\n            flb_free(mp_buf);\n        }\n        msgpack_unpacked_destroy(&result);\n        return -1;\n    }\n\n    /* Export results (might change later) */\n    tmp_out_buf = mp_buf;\n    tmp_out_size = mp_size;\n\n    /* Do we have some decoders set ? */\n    if (parser->decoders) {\n        ret = flb_parser_decoder_do(parser->decoders,\n                                    mp_buf, mp_size,\n                                    &tmp_out_buf, &tmp_out_size);\n        if (ret == 0) {\n            /* re-process the unpack context */\n            off = 0;\n            msgpack_unpacked_destroy(&result);\n            msgpack_unpacked_init(&result);\n            msgpack_unpack_next(&result, tmp_out_buf, tmp_out_size, &off);\n            map = result.data;\n        }\n    }\n\n    /* Set the possible outgoing buffer */\n    *out_buf = tmp_out_buf;\n    *out_size = tmp_out_size;\n    if (mp_buf != tmp_out_buf) {\n        flb_free(mp_buf);\n    }\n\n    /* Do time resolution ? */\n    if (!parser->time_fmt) {\n        msgpack_unpacked_destroy(&result);\n        return *out_size;\n    }\n\n    if (parser->time_key) {\n        time_key = parser->time_key;\n    }\n    else {\n        time_key = \"time\";\n    }\n    slen = strlen(time_key);\n\n    /* Lookup time field */\n    map_size = map.via.map.size;\n    skip = map_size;\n    for (i = 0; i < map_size; i++) {\n        k = &map.via.map.ptr[i].key;\n        v = &map.via.map.ptr[i].val;\n\n        if (k->via.str.size != slen) {\n            continue;\n        }\n\n        /* Ensure the pointer we are about to read is not NULL */\n        if (k->via.str.ptr == NULL) {\n            flb_free(mp_buf);\n            *out_buf = NULL;\n            msgpack_unpacked_destroy(&result);\n            return -1;\n        }\n\n        if (strncmp(k->via.str.ptr, time_key, k->via.str.size) == 0) {\n            /* We found the key, break the loop and keep the index */\n            if (parser->time_keep == FLB_FALSE) {\n                skip = i;\n                break;\n            }\n            else {\n                skip = -1;\n            }\n            break;\n        }\n\n        k = NULL;\n        v = NULL;\n    }\n\n    /* No time_key field found */\n    if (i >= map_size || !k || !v) {\n        msgpack_unpacked_destroy(&result);\n        return *out_size;\n    }\n\n    /* Ensure we have an accurate type */\n    if (v->type != MSGPACK_OBJECT_STR) {\n        msgpack_unpacked_destroy(&result);\n        return *out_size;\n    }\n\n    /* Lookup time */\n    ret = flb_parser_time_lookup(v->via.str.ptr, v->via.str.size,\n                                 0, parser, &tm, &tmfrac);\n    if (ret == -1) {\n        len = v->via.str.size;\n        if (len > sizeof(tmp) - 1) {\n            len = sizeof(tmp) - 1;\n        }\n        memcpy(tmp, v->via.str.ptr, len);\n        tmp[len] = '\\0';\n        flb_warn(\"[parser:%s] invalid time format %s for '%s'\",\n                 parser->name, parser->time_fmt_full, tmp);\n        time_lookup = 0;\n    }\n    else {\n        time_lookup = flb_parser_tm2time(&tm);\n    }\n\n    /* Compose a new map without the time_key field */\n    msgpack_sbuffer_init(&mp_sbuf);\n    msgpack_packer_init(&mp_pck, &mp_sbuf, msgpack_sbuffer_write);\n\n    if (parser->time_keep == FLB_FALSE) {\n        msgpack_pack_map(&mp_pck, map_size - 1);\n    }\n    else {\n        msgpack_pack_map(&mp_pck, map_size);\n    }\n\n    for (i = 0; i < map_size; i++) {\n        if (i == skip) {\n            continue;\n        }\n        msgpack_pack_object(&mp_pck, map.via.map.ptr[i].key);\n        msgpack_pack_object(&mp_pck, map.via.map.ptr[i].val);\n    }\n\n    /* Export the proper buffer */\n    flb_free(tmp_out_buf);\n    *out_buf = mp_sbuf.data;\n    *out_size = mp_sbuf.size;\n\n    t = out_time;\n    t->tm.tv_sec  = time_lookup;\n    t->tm.tv_nsec = (tmfrac * 1000000000);\n\n    msgpack_unpacked_destroy(&result);\n    return *out_size;\n}",
        "func": "int flb_parser_json_do(struct flb_parser *parser,\n                       const char *in_buf, size_t in_size,\n                       void **out_buf, size_t *out_size,\n                       struct flb_time *out_time)\n{\n    int i;\n    int skip;\n    int ret;\n    int slen;\n    int root_type;\n    int records;\n    double tmfrac = 0;\n    char *mp_buf = NULL;\n    char *time_key;\n    char *tmp_out_buf = NULL;\n    char tmp[255];\n    size_t tmp_out_size = 0;\n    size_t off = 0;\n    size_t map_size;\n    size_t mp_size;\n    size_t len;\n    msgpack_sbuffer mp_sbuf;\n    msgpack_packer  mp_pck;\n    msgpack_unpacked result;\n    msgpack_object map;\n    msgpack_object *k = NULL;\n    msgpack_object *v = NULL;\n    time_t time_lookup;\n    struct tm tm = {0};\n    struct flb_time *t;\n\n    /* Convert incoming in_buf JSON message to message pack format */\n    ret = flb_pack_json_recs(in_buf, in_size, &mp_buf, &mp_size, &root_type,\n                             &records);\n    if (ret != 0) {\n        return -1;\n    }\n\n    if (records != 1) {\n        flb_free(mp_buf);\n        return -1;\n    }\n\n    /* Make sure object is a map */\n    msgpack_unpacked_init(&result);\n    if (msgpack_unpack_next(&result, mp_buf, mp_size, &off) == MSGPACK_UNPACK_SUCCESS) {\n        map = result.data;\n        if (map.type != MSGPACK_OBJECT_MAP) {\n            flb_free(mp_buf);\n            msgpack_unpacked_destroy(&result);\n            return -1;\n        }\n    }\n    else {\n        if (mp_size > 0) {\n            flb_free(mp_buf);\n        }\n        msgpack_unpacked_destroy(&result);\n        return -1;\n    }\n\n    /* Export results (might change later) */\n    tmp_out_buf = mp_buf;\n    tmp_out_size = mp_size;\n\n    /* Do we have some decoders set ? */\n    if (parser->decoders) {\n        ret = flb_parser_decoder_do(parser->decoders,\n                                    mp_buf, mp_size,\n                                    &tmp_out_buf, &tmp_out_size);\n        if (ret == 0) {\n            /* re-process the unpack context */\n            off = 0;\n            msgpack_unpacked_destroy(&result);\n            msgpack_unpacked_init(&result);\n            msgpack_unpack_next(&result, tmp_out_buf, tmp_out_size, &off);\n            map = result.data;\n        }\n    }\n\n    /* Set the possible outgoing buffer */\n    *out_buf = tmp_out_buf;\n    *out_size = tmp_out_size;\n    if (mp_buf != tmp_out_buf) {\n        flb_free(mp_buf);\n        mp_buf = NULL;\n    }\n\n    /* Do time resolution ? */\n    if (!parser->time_fmt) {\n        msgpack_unpacked_destroy(&result);\n        return *out_size;\n    }\n\n    if (parser->time_key) {\n        time_key = parser->time_key;\n    }\n    else {\n        time_key = \"time\";\n    }\n    slen = strlen(time_key);\n\n    /* Lookup time field */\n    map_size = map.via.map.size;\n    skip = map_size;\n    for (i = 0; i < map_size; i++) {\n        k = &map.via.map.ptr[i].key;\n        v = &map.via.map.ptr[i].val;\n\n        if (k->via.str.size != slen) {\n            continue;\n        }\n\n        /* Ensure the pointer we are about to read is not NULL */\n        if (k->via.str.ptr == NULL) {\n            flb_free(mp_buf);\n            flb_free(tmp_out_buf);\n            *out_buf = NULL;\n            msgpack_unpacked_destroy(&result);\n            return -1;\n        }\n\n        if (strncmp(k->via.str.ptr, time_key, k->via.str.size) == 0) {\n            /* We found the key, break the loop and keep the index */\n            if (parser->time_keep == FLB_FALSE) {\n                skip = i;\n                break;\n            }\n            else {\n                skip = -1;\n            }\n            break;\n        }\n\n        k = NULL;\n        v = NULL;\n    }\n\n    /* No time_key field found */\n    if (i >= map_size || !k || !v) {\n        msgpack_unpacked_destroy(&result);\n        return *out_size;\n    }\n\n    /* Ensure we have an accurate type */\n    if (v->type != MSGPACK_OBJECT_STR) {\n        msgpack_unpacked_destroy(&result);\n        return *out_size;\n    }\n\n    /* Lookup time */\n    ret = flb_parser_time_lookup(v->via.str.ptr, v->via.str.size,\n                                 0, parser, &tm, &tmfrac);\n    if (ret == -1) {\n        len = v->via.str.size;\n        if (len > sizeof(tmp) - 1) {\n            len = sizeof(tmp) - 1;\n        }\n        memcpy(tmp, v->via.str.ptr, len);\n        tmp[len] = '\\0';\n        flb_warn(\"[parser:%s] invalid time format %s for '%s'\",\n                 parser->name, parser->time_fmt_full, tmp);\n        time_lookup = 0;\n    }\n    else {\n        time_lookup = flb_parser_tm2time(&tm);\n    }\n\n    /* Compose a new map without the time_key field */\n    msgpack_sbuffer_init(&mp_sbuf);\n    msgpack_packer_init(&mp_pck, &mp_sbuf, msgpack_sbuffer_write);\n\n    if (parser->time_keep == FLB_FALSE) {\n        msgpack_pack_map(&mp_pck, map_size - 1);\n    }\n    else {\n        msgpack_pack_map(&mp_pck, map_size);\n    }\n\n    for (i = 0; i < map_size; i++) {\n        if (i == skip) {\n            continue;\n        }\n        msgpack_pack_object(&mp_pck, map.via.map.ptr[i].key);\n        msgpack_pack_object(&mp_pck, map.via.map.ptr[i].val);\n    }\n\n    /* Export the proper buffer */\n    flb_free(tmp_out_buf);\n    *out_buf = mp_sbuf.data;\n    *out_size = mp_sbuf.size;\n\n    t = out_time;\n    t->tm.tv_sec  = time_lookup;\n    t->tm.tv_nsec = (tmfrac * 1000000000);\n\n    msgpack_unpacked_destroy(&result);\n    return *out_size;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -83,6 +83,7 @@\n     *out_size = tmp_out_size;\n     if (mp_buf != tmp_out_buf) {\n         flb_free(mp_buf);\n+        mp_buf = NULL;\n     }\n \n     /* Do time resolution ? */\n@@ -113,6 +114,7 @@\n         /* Ensure the pointer we are about to read is not NULL */\n         if (k->via.str.ptr == NULL) {\n             flb_free(mp_buf);\n+            flb_free(tmp_out_buf);\n             *out_buf = NULL;\n             msgpack_unpacked_destroy(&result);\n             return -1;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "        mp_buf = NULL;",
                "            flb_free(tmp_out_buf);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-37159",
        "func_name": "torvalds/linux/hso_create_net_device",
        "description": "hso_free_net_device in drivers/net/usb/hso.c in the Linux kernel through 5.13.4 calls unregister_netdev without checking for the NETREG_REGISTERED state, leading to a use-after-free and a double free.",
        "git_url": "https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?h=a6ecfb39ba9d7316057cea823b196b734f6b18ca",
        "commit_title": "The current error handling code of hso_create_net_device is",
        "commit_text": "hso_free_net_device, no matter which errors lead to. For example, WARNING in hso_free_net_device [1].  Fix this by refactoring the error handling code of hso_create_net_device by handling different errors by different code.  [1] https://syzkaller.appspot.com/bug?id=66eff8d49af1b28370ad342787413e35bbe76efe  ",
        "func_before": "static struct hso_device *hso_create_net_device(struct usb_interface *interface,\n\t\t\t\t\t\tint port_spec)\n{\n\tint result, i;\n\tstruct net_device *net;\n\tstruct hso_net *hso_net;\n\tstruct hso_device *hso_dev;\n\n\thso_dev = hso_create_device(interface, port_spec);\n\tif (!hso_dev)\n\t\treturn NULL;\n\n\t/* allocate our network device, then we can put in our private data */\n\t/* call hso_net_init to do the basic initialization */\n\tnet = alloc_netdev(sizeof(struct hso_net), \"hso%d\", NET_NAME_UNKNOWN,\n\t\t\t   hso_net_init);\n\tif (!net) {\n\t\tdev_err(&interface->dev, \"Unable to create ethernet device\\n\");\n\t\tgoto exit;\n\t}\n\n\thso_net = netdev_priv(net);\n\n\thso_dev->port_data.dev_net = hso_net;\n\thso_net->net = net;\n\thso_net->parent = hso_dev;\n\n\thso_net->in_endp = hso_get_ep(interface, USB_ENDPOINT_XFER_BULK,\n\t\t\t\t      USB_DIR_IN);\n\tif (!hso_net->in_endp) {\n\t\tdev_err(&interface->dev, \"Can't find BULK IN endpoint\\n\");\n\t\tgoto exit;\n\t}\n\thso_net->out_endp = hso_get_ep(interface, USB_ENDPOINT_XFER_BULK,\n\t\t\t\t       USB_DIR_OUT);\n\tif (!hso_net->out_endp) {\n\t\tdev_err(&interface->dev, \"Can't find BULK OUT endpoint\\n\");\n\t\tgoto exit;\n\t}\n\tSET_NETDEV_DEV(net, &interface->dev);\n\tSET_NETDEV_DEVTYPE(net, &hso_type);\n\n\t/* start allocating */\n\tfor (i = 0; i < MUX_BULK_RX_BUF_COUNT; i++) {\n\t\thso_net->mux_bulk_rx_urb_pool[i] = usb_alloc_urb(0, GFP_KERNEL);\n\t\tif (!hso_net->mux_bulk_rx_urb_pool[i])\n\t\t\tgoto exit;\n\t\thso_net->mux_bulk_rx_buf_pool[i] = kzalloc(MUX_BULK_RX_BUF_SIZE,\n\t\t\t\t\t\t\t   GFP_KERNEL);\n\t\tif (!hso_net->mux_bulk_rx_buf_pool[i])\n\t\t\tgoto exit;\n\t}\n\thso_net->mux_bulk_tx_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!hso_net->mux_bulk_tx_urb)\n\t\tgoto exit;\n\thso_net->mux_bulk_tx_buf = kzalloc(MUX_BULK_TX_BUF_SIZE, GFP_KERNEL);\n\tif (!hso_net->mux_bulk_tx_buf)\n\t\tgoto exit;\n\n\tadd_net_device(hso_dev);\n\n\t/* registering our net device */\n\tresult = register_netdev(net);\n\tif (result) {\n\t\tdev_err(&interface->dev, \"Failed to register device\\n\");\n\t\tgoto exit;\n\t}\n\n\thso_log_port(hso_dev);\n\n\thso_create_rfkill(hso_dev, interface);\n\n\treturn hso_dev;\nexit:\n\thso_free_net_device(hso_dev, true);\n\treturn NULL;\n}",
        "func": "static struct hso_device *hso_create_net_device(struct usb_interface *interface,\n\t\t\t\t\t\tint port_spec)\n{\n\tint result, i;\n\tstruct net_device *net;\n\tstruct hso_net *hso_net;\n\tstruct hso_device *hso_dev;\n\n\thso_dev = hso_create_device(interface, port_spec);\n\tif (!hso_dev)\n\t\treturn NULL;\n\n\t/* allocate our network device, then we can put in our private data */\n\t/* call hso_net_init to do the basic initialization */\n\tnet = alloc_netdev(sizeof(struct hso_net), \"hso%d\", NET_NAME_UNKNOWN,\n\t\t\t   hso_net_init);\n\tif (!net) {\n\t\tdev_err(&interface->dev, \"Unable to create ethernet device\\n\");\n\t\tgoto err_hso_dev;\n\t}\n\n\thso_net = netdev_priv(net);\n\n\thso_dev->port_data.dev_net = hso_net;\n\thso_net->net = net;\n\thso_net->parent = hso_dev;\n\n\thso_net->in_endp = hso_get_ep(interface, USB_ENDPOINT_XFER_BULK,\n\t\t\t\t      USB_DIR_IN);\n\tif (!hso_net->in_endp) {\n\t\tdev_err(&interface->dev, \"Can't find BULK IN endpoint\\n\");\n\t\tgoto err_net;\n\t}\n\thso_net->out_endp = hso_get_ep(interface, USB_ENDPOINT_XFER_BULK,\n\t\t\t\t       USB_DIR_OUT);\n\tif (!hso_net->out_endp) {\n\t\tdev_err(&interface->dev, \"Can't find BULK OUT endpoint\\n\");\n\t\tgoto err_net;\n\t}\n\tSET_NETDEV_DEV(net, &interface->dev);\n\tSET_NETDEV_DEVTYPE(net, &hso_type);\n\n\t/* start allocating */\n\tfor (i = 0; i < MUX_BULK_RX_BUF_COUNT; i++) {\n\t\thso_net->mux_bulk_rx_urb_pool[i] = usb_alloc_urb(0, GFP_KERNEL);\n\t\tif (!hso_net->mux_bulk_rx_urb_pool[i])\n\t\t\tgoto err_mux_bulk_rx;\n\t\thso_net->mux_bulk_rx_buf_pool[i] = kzalloc(MUX_BULK_RX_BUF_SIZE,\n\t\t\t\t\t\t\t   GFP_KERNEL);\n\t\tif (!hso_net->mux_bulk_rx_buf_pool[i])\n\t\t\tgoto err_mux_bulk_rx;\n\t}\n\thso_net->mux_bulk_tx_urb = usb_alloc_urb(0, GFP_KERNEL);\n\tif (!hso_net->mux_bulk_tx_urb)\n\t\tgoto err_mux_bulk_rx;\n\thso_net->mux_bulk_tx_buf = kzalloc(MUX_BULK_TX_BUF_SIZE, GFP_KERNEL);\n\tif (!hso_net->mux_bulk_tx_buf)\n\t\tgoto err_free_tx_urb;\n\n\tadd_net_device(hso_dev);\n\n\t/* registering our net device */\n\tresult = register_netdev(net);\n\tif (result) {\n\t\tdev_err(&interface->dev, \"Failed to register device\\n\");\n\t\tgoto err_free_tx_buf;\n\t}\n\n\thso_log_port(hso_dev);\n\n\thso_create_rfkill(hso_dev, interface);\n\n\treturn hso_dev;\n\nerr_free_tx_buf:\n\tremove_net_device(hso_dev);\n\tkfree(hso_net->mux_bulk_tx_buf);\nerr_free_tx_urb:\n\tusb_free_urb(hso_net->mux_bulk_tx_urb);\nerr_mux_bulk_rx:\n\tfor (i = 0; i < MUX_BULK_RX_BUF_COUNT; i++) {\n\t\tusb_free_urb(hso_net->mux_bulk_rx_urb_pool[i]);\n\t\tkfree(hso_net->mux_bulk_rx_buf_pool[i]);\n\t}\nerr_net:\n\tfree_netdev(net);\nerr_hso_dev:\n\tkfree(hso_dev);\n\treturn NULL;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -16,7 +16,7 @@\n \t\t\t   hso_net_init);\n \tif (!net) {\n \t\tdev_err(&interface->dev, \"Unable to create ethernet device\\n\");\n-\t\tgoto exit;\n+\t\tgoto err_hso_dev;\n \t}\n \n \thso_net = netdev_priv(net);\n@@ -29,13 +29,13 @@\n \t\t\t\t      USB_DIR_IN);\n \tif (!hso_net->in_endp) {\n \t\tdev_err(&interface->dev, \"Can't find BULK IN endpoint\\n\");\n-\t\tgoto exit;\n+\t\tgoto err_net;\n \t}\n \thso_net->out_endp = hso_get_ep(interface, USB_ENDPOINT_XFER_BULK,\n \t\t\t\t       USB_DIR_OUT);\n \tif (!hso_net->out_endp) {\n \t\tdev_err(&interface->dev, \"Can't find BULK OUT endpoint\\n\");\n-\t\tgoto exit;\n+\t\tgoto err_net;\n \t}\n \tSET_NETDEV_DEV(net, &interface->dev);\n \tSET_NETDEV_DEVTYPE(net, &hso_type);\n@@ -44,18 +44,18 @@\n \tfor (i = 0; i < MUX_BULK_RX_BUF_COUNT; i++) {\n \t\thso_net->mux_bulk_rx_urb_pool[i] = usb_alloc_urb(0, GFP_KERNEL);\n \t\tif (!hso_net->mux_bulk_rx_urb_pool[i])\n-\t\t\tgoto exit;\n+\t\t\tgoto err_mux_bulk_rx;\n \t\thso_net->mux_bulk_rx_buf_pool[i] = kzalloc(MUX_BULK_RX_BUF_SIZE,\n \t\t\t\t\t\t\t   GFP_KERNEL);\n \t\tif (!hso_net->mux_bulk_rx_buf_pool[i])\n-\t\t\tgoto exit;\n+\t\t\tgoto err_mux_bulk_rx;\n \t}\n \thso_net->mux_bulk_tx_urb = usb_alloc_urb(0, GFP_KERNEL);\n \tif (!hso_net->mux_bulk_tx_urb)\n-\t\tgoto exit;\n+\t\tgoto err_mux_bulk_rx;\n \thso_net->mux_bulk_tx_buf = kzalloc(MUX_BULK_TX_BUF_SIZE, GFP_KERNEL);\n \tif (!hso_net->mux_bulk_tx_buf)\n-\t\tgoto exit;\n+\t\tgoto err_free_tx_urb;\n \n \tadd_net_device(hso_dev);\n \n@@ -63,7 +63,7 @@\n \tresult = register_netdev(net);\n \tif (result) {\n \t\tdev_err(&interface->dev, \"Failed to register device\\n\");\n-\t\tgoto exit;\n+\t\tgoto err_free_tx_buf;\n \t}\n \n \thso_log_port(hso_dev);\n@@ -71,7 +71,20 @@\n \thso_create_rfkill(hso_dev, interface);\n \n \treturn hso_dev;\n-exit:\n-\thso_free_net_device(hso_dev, true);\n+\n+err_free_tx_buf:\n+\tremove_net_device(hso_dev);\n+\tkfree(hso_net->mux_bulk_tx_buf);\n+err_free_tx_urb:\n+\tusb_free_urb(hso_net->mux_bulk_tx_urb);\n+err_mux_bulk_rx:\n+\tfor (i = 0; i < MUX_BULK_RX_BUF_COUNT; i++) {\n+\t\tusb_free_urb(hso_net->mux_bulk_rx_urb_pool[i]);\n+\t\tkfree(hso_net->mux_bulk_rx_buf_pool[i]);\n+\t}\n+err_net:\n+\tfree_netdev(net);\n+err_hso_dev:\n+\tkfree(hso_dev);\n \treturn NULL;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tgoto exit;",
                "\t\tgoto exit;",
                "\t\tgoto exit;",
                "\t\t\tgoto exit;",
                "\t\t\tgoto exit;",
                "\t\tgoto exit;",
                "\t\tgoto exit;",
                "\t\tgoto exit;",
                "exit:",
                "\thso_free_net_device(hso_dev, true);"
            ],
            "added_lines": [
                "\t\tgoto err_hso_dev;",
                "\t\tgoto err_net;",
                "\t\tgoto err_net;",
                "\t\t\tgoto err_mux_bulk_rx;",
                "\t\t\tgoto err_mux_bulk_rx;",
                "\t\tgoto err_mux_bulk_rx;",
                "\t\tgoto err_free_tx_urb;",
                "\t\tgoto err_free_tx_buf;",
                "",
                "err_free_tx_buf:",
                "\tremove_net_device(hso_dev);",
                "\tkfree(hso_net->mux_bulk_tx_buf);",
                "err_free_tx_urb:",
                "\tusb_free_urb(hso_net->mux_bulk_tx_urb);",
                "err_mux_bulk_rx:",
                "\tfor (i = 0; i < MUX_BULK_RX_BUF_COUNT; i++) {",
                "\t\tusb_free_urb(hso_net->mux_bulk_rx_urb_pool[i]);",
                "\t\tkfree(hso_net->mux_bulk_rx_buf_pool[i]);",
                "\t}",
                "err_net:",
                "\tfree_netdev(net);",
                "err_hso_dev:",
                "\tkfree(hso_dev);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-37159",
        "func_name": "torvalds/linux/hso_free_net_device",
        "description": "hso_free_net_device in drivers/net/usb/hso.c in the Linux kernel through 5.13.4 calls unregister_netdev without checking for the NETREG_REGISTERED state, leading to a use-after-free and a double free.",
        "git_url": "https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?h=dcb713d53e2eadf42b878c12a471e74dc6ed3145",
        "commit_title": "There are two invocation sites of hso_free_net_device. After",
        "commit_text": "refactoring hso_create_net_device, this parameter is useless. Remove the bailout in the hso_free_net_device and change the invocation sites of this function.  ",
        "func_before": "static void hso_free_net_device(struct hso_device *hso_dev, bool bailout)\n{\n\tint i;\n\tstruct hso_net *hso_net = dev2net(hso_dev);\n\n\tif (!hso_net)\n\t\treturn;\n\n\tremove_net_device(hso_net->parent);\n\n\tif (hso_net->net)\n\t\tunregister_netdev(hso_net->net);\n\n\t/* start freeing */\n\tfor (i = 0; i < MUX_BULK_RX_BUF_COUNT; i++) {\n\t\tusb_free_urb(hso_net->mux_bulk_rx_urb_pool[i]);\n\t\tkfree(hso_net->mux_bulk_rx_buf_pool[i]);\n\t\thso_net->mux_bulk_rx_buf_pool[i] = NULL;\n\t}\n\tusb_free_urb(hso_net->mux_bulk_tx_urb);\n\tkfree(hso_net->mux_bulk_tx_buf);\n\thso_net->mux_bulk_tx_buf = NULL;\n\n\tif (hso_net->net && !bailout)\n\t\tfree_netdev(hso_net->net);\n\n\tkfree(hso_dev);\n}",
        "func": "static void hso_free_net_device(struct hso_device *hso_dev)\n{\n\tint i;\n\tstruct hso_net *hso_net = dev2net(hso_dev);\n\n\tif (!hso_net)\n\t\treturn;\n\n\tremove_net_device(hso_net->parent);\n\n\tif (hso_net->net)\n\t\tunregister_netdev(hso_net->net);\n\n\t/* start freeing */\n\tfor (i = 0; i < MUX_BULK_RX_BUF_COUNT; i++) {\n\t\tusb_free_urb(hso_net->mux_bulk_rx_urb_pool[i]);\n\t\tkfree(hso_net->mux_bulk_rx_buf_pool[i]);\n\t\thso_net->mux_bulk_rx_buf_pool[i] = NULL;\n\t}\n\tusb_free_urb(hso_net->mux_bulk_tx_urb);\n\tkfree(hso_net->mux_bulk_tx_buf);\n\thso_net->mux_bulk_tx_buf = NULL;\n\n\tif (hso_net->net)\n\t\tfree_netdev(hso_net->net);\n\n\tkfree(hso_dev);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,4 @@\n-static void hso_free_net_device(struct hso_device *hso_dev, bool bailout)\n+static void hso_free_net_device(struct hso_device *hso_dev)\n {\n \tint i;\n \tstruct hso_net *hso_net = dev2net(hso_dev);\n@@ -21,7 +21,7 @@\n \tkfree(hso_net->mux_bulk_tx_buf);\n \thso_net->mux_bulk_tx_buf = NULL;\n \n-\tif (hso_net->net && !bailout)\n+\tif (hso_net->net)\n \t\tfree_netdev(hso_net->net);\n \n \tkfree(hso_dev);",
        "diff_line_info": {
            "deleted_lines": [
                "static void hso_free_net_device(struct hso_device *hso_dev, bool bailout)",
                "\tif (hso_net->net && !bailout)"
            ],
            "added_lines": [
                "static void hso_free_net_device(struct hso_device *hso_dev)",
                "\tif (hso_net->net)"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-37159",
        "func_name": "torvalds/linux/hso_free_interface",
        "description": "hso_free_net_device in drivers/net/usb/hso.c in the Linux kernel through 5.13.4 calls unregister_netdev without checking for the NETREG_REGISTERED state, leading to a use-after-free and a double free.",
        "git_url": "https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?h=dcb713d53e2eadf42b878c12a471e74dc6ed3145",
        "commit_title": "There are two invocation sites of hso_free_net_device. After",
        "commit_text": "refactoring hso_create_net_device, this parameter is useless. Remove the bailout in the hso_free_net_device and change the invocation sites of this function.  ",
        "func_before": "static void hso_free_interface(struct usb_interface *interface)\n{\n\tstruct hso_serial *serial;\n\tint i;\n\n\tfor (i = 0; i < HSO_SERIAL_TTY_MINORS; i++) {\n\t\tif (serial_table[i] &&\n\t\t    (serial_table[i]->interface == interface)) {\n\t\t\tserial = dev2ser(serial_table[i]);\n\t\t\ttty_port_tty_hangup(&serial->port, false);\n\t\t\tmutex_lock(&serial->parent->mutex);\n\t\t\tserial->parent->usb_gone = 1;\n\t\t\tmutex_unlock(&serial->parent->mutex);\n\t\t\tcancel_work_sync(&serial_table[i]->async_put_intf);\n\t\t\tcancel_work_sync(&serial_table[i]->async_get_intf);\n\t\t\thso_serial_tty_unregister(serial);\n\t\t\tkref_put(&serial->parent->ref, hso_serial_ref_free);\n\t\t}\n\t}\n\n\tfor (i = 0; i < HSO_MAX_NET_DEVICES; i++) {\n\t\tif (network_table[i] &&\n\t\t    (network_table[i]->interface == interface)) {\n\t\t\tstruct rfkill *rfk = dev2net(network_table[i])->rfkill;\n\t\t\t/* hso_stop_net_device doesn't stop the net queue since\n\t\t\t * traffic needs to start it again when suspended */\n\t\t\tnetif_stop_queue(dev2net(network_table[i])->net);\n\t\t\thso_stop_net_device(network_table[i]);\n\t\t\tcancel_work_sync(&network_table[i]->async_put_intf);\n\t\t\tcancel_work_sync(&network_table[i]->async_get_intf);\n\t\t\tif (rfk) {\n\t\t\t\trfkill_unregister(rfk);\n\t\t\t\trfkill_destroy(rfk);\n\t\t\t}\n\t\t\thso_free_net_device(network_table[i], false);\n\t\t}\n\t}\n}",
        "func": "static void hso_free_interface(struct usb_interface *interface)\n{\n\tstruct hso_serial *serial;\n\tint i;\n\n\tfor (i = 0; i < HSO_SERIAL_TTY_MINORS; i++) {\n\t\tif (serial_table[i] &&\n\t\t    (serial_table[i]->interface == interface)) {\n\t\t\tserial = dev2ser(serial_table[i]);\n\t\t\ttty_port_tty_hangup(&serial->port, false);\n\t\t\tmutex_lock(&serial->parent->mutex);\n\t\t\tserial->parent->usb_gone = 1;\n\t\t\tmutex_unlock(&serial->parent->mutex);\n\t\t\tcancel_work_sync(&serial_table[i]->async_put_intf);\n\t\t\tcancel_work_sync(&serial_table[i]->async_get_intf);\n\t\t\thso_serial_tty_unregister(serial);\n\t\t\tkref_put(&serial->parent->ref, hso_serial_ref_free);\n\t\t}\n\t}\n\n\tfor (i = 0; i < HSO_MAX_NET_DEVICES; i++) {\n\t\tif (network_table[i] &&\n\t\t    (network_table[i]->interface == interface)) {\n\t\t\tstruct rfkill *rfk = dev2net(network_table[i])->rfkill;\n\t\t\t/* hso_stop_net_device doesn't stop the net queue since\n\t\t\t * traffic needs to start it again when suspended */\n\t\t\tnetif_stop_queue(dev2net(network_table[i])->net);\n\t\t\thso_stop_net_device(network_table[i]);\n\t\t\tcancel_work_sync(&network_table[i]->async_put_intf);\n\t\t\tcancel_work_sync(&network_table[i]->async_get_intf);\n\t\t\tif (rfk) {\n\t\t\t\trfkill_unregister(rfk);\n\t\t\t\trfkill_destroy(rfk);\n\t\t\t}\n\t\t\thso_free_net_device(network_table[i]);\n\t\t}\n\t}\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -32,7 +32,7 @@\n \t\t\t\trfkill_unregister(rfk);\n \t\t\t\trfkill_destroy(rfk);\n \t\t\t}\n-\t\t\thso_free_net_device(network_table[i], false);\n+\t\t\thso_free_net_device(network_table[i]);\n \t\t}\n \t}\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\thso_free_net_device(network_table[i], false);"
            ],
            "added_lines": [
                "\t\t\thso_free_net_device(network_table[i]);"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-36434",
        "func_name": "FillZpp/sys-info-rs/get_disk_info",
        "description": "An issue was discovered in the sys-info crate before 0.8.0 for Rust. sys_info::disk_info calls can trigger a double free.",
        "git_url": "https://github.com/FillZpp/sys-info-rs/commit/4fda8b6a5ffbea03d05fcfc0a89594e6ca495fc7",
        "commit_title": "Make Disk Info Thread-Safe on Linux",
        "commit_text": "",
        "func_before": "DiskInfo get_disk_info(void) {\n\tFILE *mounts;\n\tchar procline[1024];\n\tchar *mount, *device, *type, *mode, *other;\n\tfloat thispct, max=0.0;\n\tdouble dtotal=0.0, dfree=0.0;\n\tDiskInfo di;\n\t\n\tdi.total = 0;\n\tdi.free = 0;\n\n\tmounts = fopen(MOUNTS,\"r\");\n\tif (!mounts) {\n\t\treturn di;\n\t}\n\twhile ( fgets(procline, sizeof(procline), mounts) ) {\n\t\tdevice = procline;\n\t\tmount = index(procline, ' ');\n\t\tif (mount == NULL) continue;\n\t\t*mount++ = '\\0';\n\t\ttype = index(mount, ' ');\n\t\tif (type == NULL) continue;\n\t\t*type++ = '\\0';\n\t\tmode = index(type, ' ');\n\t\tif (mode == NULL) continue;\n\t\t*mode++ = '\\0';\n\t\tother = index(mode, ' ');\n\t\tif (other != NULL) *other = '\\0';\n\t\tif (!strncmp(mode, \"ro\", 2)) continue;\n\t\tif (remote_mount(device, type)) continue;\n\t\tif (strncmp(device, \"/dev/\", 5) != 0 &&\n\t\t    strncmp(device, \"/dev2/\", 6) != 0) continue;\n\t\tthispct = device_space(mount, device, &dtotal, &dfree);\n\t\tif (!max || max<thispct)\n\t\t\tmax = thispct;\n\t}\n\tfclose(mounts);\n\n\tDFcleanup();\n\tdi.total = dtotal / 1000;\n\tdi.free = dfree / 1000;\n\t\n\treturn di;\n}",
        "func": "DiskInfo get_disk_info(void) {\n\tFILE *mounts;\n\tchar procline[1024];\n\tstruct nlist *DFhashvector[DFHASHSIZE] = {0};\n\tchar *mount, *device, *type, *mode, *other;\n\tfloat thispct, max=0.0;\n\tdouble dtotal=0.0, dfree=0.0;\n\tDiskInfo di;\n\t\n\tdi.total = 0;\n\tdi.free = 0;\n\n\tmounts = fopen(MOUNTS,\"r\");\n\tif (!mounts) {\n\t\treturn di;\n\t}\n\twhile ( fgets(procline, sizeof(procline), mounts) ) {\n\t\tdevice = procline;\n\t\tmount = index(procline, ' ');\n\t\tif (mount == NULL) continue;\n\t\t*mount++ = '\\0';\n\t\ttype = index(mount, ' ');\n\t\tif (type == NULL) continue;\n\t\t*type++ = '\\0';\n\t\tmode = index(type, ' ');\n\t\tif (mode == NULL) continue;\n\t\t*mode++ = '\\0';\n\t\tother = index(mode, ' ');\n\t\tif (other != NULL) *other = '\\0';\n\t\tif (!strncmp(mode, \"ro\", 2)) continue;\n\t\tif (remote_mount(device, type)) continue;\n\t\tif (strncmp(device, \"/dev/\", 5) != 0 &&\n\t\t    strncmp(device, \"/dev2/\", 6) != 0) continue;\n\t\tthispct = device_space(DFhashvector, mount, device, &dtotal, &dfree);\n\t\tif (!max || max<thispct)\n\t\t\tmax = thispct;\n\t}\n\tfclose(mounts);\n\n\tDFcleanup(DFhashvector);\n\tdi.total = dtotal / 1000;\n\tdi.free = dfree / 1000;\n\t\n\treturn di;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,7 @@\n DiskInfo get_disk_info(void) {\n \tFILE *mounts;\n \tchar procline[1024];\n+\tstruct nlist *DFhashvector[DFHASHSIZE] = {0};\n \tchar *mount, *device, *type, *mode, *other;\n \tfloat thispct, max=0.0;\n \tdouble dtotal=0.0, dfree=0.0;\n@@ -30,13 +31,13 @@\n \t\tif (remote_mount(device, type)) continue;\n \t\tif (strncmp(device, \"/dev/\", 5) != 0 &&\n \t\t    strncmp(device, \"/dev2/\", 6) != 0) continue;\n-\t\tthispct = device_space(mount, device, &dtotal, &dfree);\n+\t\tthispct = device_space(DFhashvector, mount, device, &dtotal, &dfree);\n \t\tif (!max || max<thispct)\n \t\t\tmax = thispct;\n \t}\n \tfclose(mounts);\n \n-\tDFcleanup();\n+\tDFcleanup(DFhashvector);\n \tdi.total = dtotal / 1000;\n \tdi.free = dfree / 1000;\n \t",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tthispct = device_space(mount, device, &dtotal, &dfree);",
                "\tDFcleanup();"
            ],
            "added_lines": [
                "\tstruct nlist *DFhashvector[DFHASHSIZE] = {0};",
                "\t\tthispct = device_space(DFhashvector, mount, device, &dtotal, &dfree);",
                "\tDFcleanup(DFhashvector);"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-36434",
        "func_name": "FillZpp/sys-info-rs/device_space",
        "description": "An issue was discovered in the sys-info crate before 0.8.0 for Rust. sys_info::disk_info calls can trigger a double free.",
        "git_url": "https://github.com/FillZpp/sys-info-rs/commit/4fda8b6a5ffbea03d05fcfc0a89594e6ca495fc7",
        "commit_title": "Make Disk Info Thread-Safe on Linux",
        "commit_text": "",
        "func_before": "float device_space(char *mount, char *device, double *total_size, double *total_free)\n{\n\tstruct statvfs svfs;\n\tdouble blocksize;\n\tdouble free;\n\tdouble size;\n\t/* The percent used: used/total * 100 */\n\tfloat pct=0.0;\n\n\t/* Avoid multiply-mounted disks - not done in df. */\n\tif (seen_before(device)) return pct;\n\n\tif (statvfs(mount, &svfs)) {\n\t\t/* Ignore funky devices... */\n\t\treturn pct;\n\t}\n\n\tfree = svfs.f_bavail;\n\tsize  = svfs.f_blocks;\n\tblocksize = svfs.f_bsize;\n\t/* Keep running sum of total used, free local disk space. */\n\t*total_size += size * blocksize;\n\t*total_free += free * blocksize;\n\t/* The percentage of space used on this partition. */\n\tpct = size ? ((size - free) / (float) size) * 100 : 0.0;\n\treturn pct;\n}",
        "func": "float device_space(struct nlist **DFhashvector, char *mount, char *device, double *total_size, double *total_free)\n{\n\tstruct statvfs svfs;\n\tdouble blocksize;\n\tdouble free;\n\tdouble size;\n\t/* The percent used: used/total * 100 */\n\tfloat pct=0.0;\n\n\t/* Avoid multiply-mounted disks - not done in df. */\n\tif (seen_before(DFhashvector, device)) return pct;\n\n\tif (statvfs(mount, &svfs)) {\n\t\t/* Ignore funky devices... */\n\t\treturn pct;\n\t}\n\n\tfree = svfs.f_bavail;\n\tsize  = svfs.f_blocks;\n\tblocksize = svfs.f_bsize;\n\t/* Keep running sum of total used, free local disk space. */\n\t*total_size += size * blocksize;\n\t*total_free += free * blocksize;\n\t/* The percentage of space used on this partition. */\n\tpct = size ? ((size - free) / (float) size) * 100 : 0.0;\n\treturn pct;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,4 @@\n-float device_space(char *mount, char *device, double *total_size, double *total_free)\n+float device_space(struct nlist **DFhashvector, char *mount, char *device, double *total_size, double *total_free)\n {\n \tstruct statvfs svfs;\n \tdouble blocksize;\n@@ -8,7 +8,7 @@\n \tfloat pct=0.0;\n \n \t/* Avoid multiply-mounted disks - not done in df. */\n-\tif (seen_before(device)) return pct;\n+\tif (seen_before(DFhashvector, device)) return pct;\n \n \tif (statvfs(mount, &svfs)) {\n \t\t/* Ignore funky devices... */",
        "diff_line_info": {
            "deleted_lines": [
                "float device_space(char *mount, char *device, double *total_size, double *total_free)",
                "\tif (seen_before(device)) return pct;"
            ],
            "added_lines": [
                "float device_space(struct nlist **DFhashvector, char *mount, char *device, double *total_size, double *total_free)",
                "\tif (seen_before(DFhashvector, device)) return pct;"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-36434",
        "func_name": "FillZpp/sys-info-rs/seen_before",
        "description": "An issue was discovered in the sys-info crate before 0.8.0 for Rust. sys_info::disk_info calls can trigger a double free.",
        "git_url": "https://github.com/FillZpp/sys-info-rs/commit/4fda8b6a5ffbea03d05fcfc0a89594e6ca495fc7",
        "commit_title": "Make Disk Info Thread-Safe on Linux",
        "commit_text": "",
        "func_before": "struct nlist * seen_before(const char *name)\n{\n\tstruct nlist *found=0, *np;\n\tunsigned int hashval;\n\n\t/* lookup */\n\thashval=DFhash(name);\n\tfor (np=DFhashvector[hashval]; np; np=np->next) {\n\t\tif (!strcmp(name,np->name)) {\n\t\t\tfound=np;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!found) {    /* not found */\n\t\tnp = (struct nlist *) malloc(sizeof(*np));\n\t\tif (!np || !(np->name = (char *) strdup(name)))\n\t\t\treturn NULL;\n\t\tnp->next = DFhashvector[hashval];\n\t\tDFhashvector[hashval] = np;\n\t\treturn NULL;\n\t}\n\telse /* found name */\n\t\treturn found;\n}",
        "func": "struct nlist * seen_before(struct nlist **DFhashvector, const char *name)\n{\n\tstruct nlist *found=0, *np;\n\tunsigned int hashval;\n\n\t/* lookup */\n\thashval=DFhash(name);\n\tfor (np=DFhashvector[hashval]; np; np=np->next) {\n\t\tif (!strcmp(name,np->name)) {\n\t\t\tfound=np;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!found) {    /* not found */\n\t\tnp = (struct nlist *) malloc(sizeof(*np));\n\t\tif (!np || !(np->name = (char *) strdup(name)))\n\t\t\treturn NULL;\n\t\tnp->next = DFhashvector[hashval];\n\t\tDFhashvector[hashval] = np;\n\t\treturn NULL;\n\t}\n\telse /* found name */\n\t\treturn found;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,4 @@\n-struct nlist * seen_before(const char *name)\n+struct nlist * seen_before(struct nlist **DFhashvector, const char *name)\n {\n \tstruct nlist *found=0, *np;\n \tunsigned int hashval;",
        "diff_line_info": {
            "deleted_lines": [
                "struct nlist * seen_before(const char *name)"
            ],
            "added_lines": [
                "struct nlist * seen_before(struct nlist **DFhashvector, const char *name)"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-36434",
        "func_name": "FillZpp/sys-info-rs/DFcleanup",
        "description": "An issue was discovered in the sys-info crate before 0.8.0 for Rust. sys_info::disk_info calls can trigger a double free.",
        "git_url": "https://github.com/FillZpp/sys-info-rs/commit/4fda8b6a5ffbea03d05fcfc0a89594e6ca495fc7",
        "commit_title": "Make Disk Info Thread-Safe on Linux",
        "commit_text": "",
        "func_before": "void DFcleanup()\n{\n\tstruct nlist *np, *next;\n\tint i;\n\tfor (i=0; i<DFHASHSIZE; i++) {\n\t\t/* Non-standard for loop. Note the last clause happens at the end of the loop. */\n\t\tfor (np = DFhashvector[i]; np; np=next) {\n\t\t\tnext=np->next;\n\t\t\tfree(np->name);\n\t\t\tfree(np);\n\t\t}\n\t\tDFhashvector[i] = 0;\n\t}\n}",
        "func": "void DFcleanup(struct nlist **DFhashvector)\n{\n\tstruct nlist *np, *next;\n\tint i;\n\tfor (i=0; i<DFHASHSIZE; i++) {\n\t\t/* Non-standard for loop. Note the last clause happens at the end of the loop. */\n\t\tfor (np = DFhashvector[i]; np; np=next) {\n\t\t\tnext=np->next;\n\t\t\tfree(np->name);\n\t\t\tfree(np);\n\t\t}\n\t\tDFhashvector[i] = 0;\n\t}\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,4 @@\n-void DFcleanup()\n+void DFcleanup(struct nlist **DFhashvector)\n {\n \tstruct nlist *np, *next;\n \tint i;",
        "diff_line_info": {
            "deleted_lines": [
                "void DFcleanup()"
            ],
            "added_lines": [
                "void DFcleanup(struct nlist **DFhashvector)"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-16820",
        "func_name": "collectd/csnmp_read_table",
        "description": "The csnmp_read_table function in snmp.c in the SNMP plugin in collectd before 5.6.3 is susceptible to a double free in a certain error case, which could lead to a crash (or potentially have other impact).",
        "git_url": "https://github.com/collectd/collectd/commit/d16c24542b2f96a194d43a73c2e5778822b9cb47",
        "commit_title": "snmp plugin: Fix double free of request PDU",
        "commit_text": " snmp_sess_synch_response() always frees request PDU, in both case of request error and success. If error condition occurs inside of `while (status == 0)` loop, double free of `req` happens.  Issue: #2291",
        "func_before": "static int csnmp_read_table(host_definition_t *host, data_definition_t *data) {\n  struct snmp_pdu *req;\n  struct snmp_pdu *res = NULL;\n  struct variable_list *vb;\n\n  const data_set_t *ds;\n\n  size_t oid_list_len = data->values_len + 1;\n  /* Holds the last OID returned by the device. We use this in the GETNEXT\n   * request to proceed. */\n  oid_t oid_list[oid_list_len];\n  /* Set to false when an OID has left its subtree so we don't re-request it\n   * again. */\n  _Bool oid_list_todo[oid_list_len];\n\n  int status;\n  size_t i;\n\n  /* `value_list_head' and `value_list_tail' implement a linked list for each\n   * value. `instance_list_head' and `instance_list_tail' implement a linked\n   * list of\n   * instance names. This is used to jump gaps in the table. */\n  csnmp_list_instances_t *instance_list_head;\n  csnmp_list_instances_t *instance_list_tail;\n  csnmp_table_values_t **value_list_head;\n  csnmp_table_values_t **value_list_tail;\n\n  DEBUG(\"snmp plugin: csnmp_read_table (host = %s, data = %s)\", host->name,\n        data->name);\n\n  if (host->sess_handle == NULL) {\n    DEBUG(\"snmp plugin: csnmp_read_table: host->sess_handle == NULL\");\n    return (-1);\n  }\n\n  ds = plugin_get_ds(data->type);\n  if (!ds) {\n    ERROR(\"snmp plugin: DataSet `%s' not defined.\", data->type);\n    return (-1);\n  }\n\n  if (ds->ds_num != data->values_len) {\n    ERROR(\"snmp plugin: DataSet `%s' requires %zu values, but config talks \"\n          \"about %zu\",\n          data->type, ds->ds_num, data->values_len);\n    return (-1);\n  }\n  assert(data->values_len > 0);\n\n  /* We need a copy of all the OIDs, because GETNEXT will destroy them. */\n  memcpy(oid_list, data->values, data->values_len * sizeof(oid_t));\n  if (data->instance.oid.oid_len > 0)\n    memcpy(oid_list + data->values_len, &data->instance.oid, sizeof(oid_t));\n  else /* no InstanceFrom option specified. */\n    oid_list_len--;\n\n  for (i = 0; i < oid_list_len; i++)\n    oid_list_todo[i] = 1;\n\n  /* We're going to construct n linked lists, one for each \"value\".\n   * value_list_head will contain pointers to the heads of these linked lists,\n   * value_list_tail will contain pointers to the tail of the lists. */\n  value_list_head = calloc(data->values_len, sizeof(*value_list_head));\n  value_list_tail = calloc(data->values_len, sizeof(*value_list_tail));\n  if ((value_list_head == NULL) || (value_list_tail == NULL)) {\n    ERROR(\"snmp plugin: csnmp_read_table: calloc failed.\");\n    sfree(value_list_head);\n    sfree(value_list_tail);\n    return (-1);\n  }\n\n  instance_list_head = NULL;\n  instance_list_tail = NULL;\n\n  status = 0;\n  while (status == 0) {\n    int oid_list_todo_num;\n\n    req = snmp_pdu_create(SNMP_MSG_GETNEXT);\n    if (req == NULL) {\n      ERROR(\"snmp plugin: snmp_pdu_create failed.\");\n      status = -1;\n      break;\n    }\n\n    oid_list_todo_num = 0;\n    for (i = 0; i < oid_list_len; i++) {\n      /* Do not rerequest already finished OIDs */\n      if (!oid_list_todo[i])\n        continue;\n      oid_list_todo_num++;\n      snmp_add_null_var(req, oid_list[i].oid, oid_list[i].oid_len);\n    }\n\n    if (oid_list_todo_num == 0) {\n      /* The request is still empty - so we are finished */\n      DEBUG(\"snmp plugin: all variables have left their subtree\");\n      status = 0;\n      break;\n    }\n\n    res = NULL;\n    status = snmp_sess_synch_response(host->sess_handle, req, &res);\n    if ((status != STAT_SUCCESS) || (res == NULL)) {\n      char *errstr = NULL;\n\n      snmp_sess_error(host->sess_handle, NULL, NULL, &errstr);\n\n      c_complain(LOG_ERR, &host->complaint,\n                 \"snmp plugin: host %s: snmp_sess_synch_response failed: %s\",\n                 host->name, (errstr == NULL) ? \"Unknown problem\" : errstr);\n\n      if (res != NULL)\n        snmp_free_pdu(res);\n      res = NULL;\n\n      /* snmp_synch_response already freed our PDU */\n      req = NULL;\n      sfree(errstr);\n      csnmp_host_close_session(host);\n\n      status = -1;\n      break;\n    }\n\n    status = 0;\n    assert(res != NULL);\n    c_release(LOG_INFO, &host->complaint,\n              \"snmp plugin: host %s: snmp_sess_synch_response successful.\",\n              host->name);\n\n    vb = res->variables;\n    if (vb == NULL) {\n      status = -1;\n      break;\n    }\n\n    for (vb = res->variables, i = 0; (vb != NULL);\n         vb = vb->next_variable, i++) {\n      /* Calculate value index from todo list */\n      while ((i < oid_list_len) && !oid_list_todo[i])\n        i++;\n\n      /* An instance is configured and the res variable we process is the\n       * instance value (last index) */\n      if ((data->instance.oid.oid_len > 0) && (i == data->values_len)) {\n        if ((vb->type == SNMP_ENDOFMIBVIEW) ||\n            (snmp_oid_ncompare(\n                 data->instance.oid.oid, data->instance.oid.oid_len, vb->name,\n                 vb->name_length, data->instance.oid.oid_len) != 0)) {\n          DEBUG(\"snmp plugin: host = %s; data = %s; Instance left its subtree.\",\n                host->name, data->name);\n          oid_list_todo[i] = 0;\n          continue;\n        }\n\n        /* Allocate a new `csnmp_list_instances_t', insert the instance name and\n         * add it to the list */\n        if (csnmp_instance_list_add(&instance_list_head, &instance_list_tail,\n                                    res, host, data) != 0) {\n          ERROR(\"snmp plugin: host %s: csnmp_instance_list_add failed.\",\n                host->name);\n          status = -1;\n          break;\n        }\n      } else /* The variable we are processing is a normal value */\n      {\n        csnmp_table_values_t *vt;\n        oid_t vb_name;\n        oid_t suffix;\n        int ret;\n\n        csnmp_oid_init(&vb_name, vb->name, vb->name_length);\n\n        /* Calculate the current suffix. This is later used to check that the\n         * suffix is increasing. This also checks if we left the subtree */\n        ret = csnmp_oid_suffix(&suffix, &vb_name, data->values + i);\n        if (ret != 0) {\n          DEBUG(\"snmp plugin: host = %s; data = %s; i = %zu; \"\n                \"Value probably left its subtree.\",\n                host->name, data->name, i);\n          oid_list_todo[i] = 0;\n          continue;\n        }\n\n        /* Make sure the OIDs returned by the agent are increasing. Otherwise\n         * our\n         * table matching algorithm will get confused. */\n        if ((value_list_tail[i] != NULL) &&\n            (csnmp_oid_compare(&suffix, &value_list_tail[i]->suffix) <= 0)) {\n          DEBUG(\"snmp plugin: host = %s; data = %s; i = %zu; \"\n                \"Suffix is not increasing.\",\n                host->name, data->name, i);\n          oid_list_todo[i] = 0;\n          continue;\n        }\n\n        vt = calloc(1, sizeof(*vt));\n        if (vt == NULL) {\n          ERROR(\"snmp plugin: calloc failed.\");\n          status = -1;\n          break;\n        }\n\n        vt->value =\n            csnmp_value_list_to_value(vb, ds->ds[i].type, data->scale,\n                                      data->shift, host->name, data->name);\n        memcpy(&vt->suffix, &suffix, sizeof(vt->suffix));\n        vt->next = NULL;\n\n        if (value_list_tail[i] == NULL)\n          value_list_head[i] = vt;\n        else\n          value_list_tail[i]->next = vt;\n        value_list_tail[i] = vt;\n      }\n\n      /* Copy OID to oid_list[i] */\n      memcpy(oid_list[i].oid, vb->name, sizeof(oid) * vb->name_length);\n      oid_list[i].oid_len = vb->name_length;\n\n    } /* for (vb = res->variables ...) */\n\n    if (res != NULL)\n      snmp_free_pdu(res);\n    res = NULL;\n  } /* while (status == 0) */\n\n  if (res != NULL)\n    snmp_free_pdu(res);\n  res = NULL;\n\n  if (req != NULL)\n    snmp_free_pdu(req);\n  req = NULL;\n\n  if (status == 0)\n    csnmp_dispatch_table(host, data, instance_list_head, value_list_head);\n\n  /* Free all allocated variables here */\n  while (instance_list_head != NULL) {\n    csnmp_list_instances_t *next = instance_list_head->next;\n    sfree(instance_list_head);\n    instance_list_head = next;\n  }\n\n  for (i = 0; i < data->values_len; i++) {\n    while (value_list_head[i] != NULL) {\n      csnmp_table_values_t *next = value_list_head[i]->next;\n      sfree(value_list_head[i]);\n      value_list_head[i] = next;\n    }\n  }\n\n  sfree(value_list_head);\n  sfree(value_list_tail);\n\n  return (0);\n}",
        "func": "static int csnmp_read_table(host_definition_t *host, data_definition_t *data) {\n  struct snmp_pdu *req;\n  struct snmp_pdu *res = NULL;\n  struct variable_list *vb;\n\n  const data_set_t *ds;\n\n  size_t oid_list_len = data->values_len + 1;\n  /* Holds the last OID returned by the device. We use this in the GETNEXT\n   * request to proceed. */\n  oid_t oid_list[oid_list_len];\n  /* Set to false when an OID has left its subtree so we don't re-request it\n   * again. */\n  _Bool oid_list_todo[oid_list_len];\n\n  int status;\n  size_t i;\n\n  /* `value_list_head' and `value_list_tail' implement a linked list for each\n   * value. `instance_list_head' and `instance_list_tail' implement a linked\n   * list of\n   * instance names. This is used to jump gaps in the table. */\n  csnmp_list_instances_t *instance_list_head;\n  csnmp_list_instances_t *instance_list_tail;\n  csnmp_table_values_t **value_list_head;\n  csnmp_table_values_t **value_list_tail;\n\n  DEBUG(\"snmp plugin: csnmp_read_table (host = %s, data = %s)\", host->name,\n        data->name);\n\n  if (host->sess_handle == NULL) {\n    DEBUG(\"snmp plugin: csnmp_read_table: host->sess_handle == NULL\");\n    return (-1);\n  }\n\n  ds = plugin_get_ds(data->type);\n  if (!ds) {\n    ERROR(\"snmp plugin: DataSet `%s' not defined.\", data->type);\n    return (-1);\n  }\n\n  if (ds->ds_num != data->values_len) {\n    ERROR(\"snmp plugin: DataSet `%s' requires %zu values, but config talks \"\n          \"about %zu\",\n          data->type, ds->ds_num, data->values_len);\n    return (-1);\n  }\n  assert(data->values_len > 0);\n\n  /* We need a copy of all the OIDs, because GETNEXT will destroy them. */\n  memcpy(oid_list, data->values, data->values_len * sizeof(oid_t));\n  if (data->instance.oid.oid_len > 0)\n    memcpy(oid_list + data->values_len, &data->instance.oid, sizeof(oid_t));\n  else /* no InstanceFrom option specified. */\n    oid_list_len--;\n\n  for (i = 0; i < oid_list_len; i++)\n    oid_list_todo[i] = 1;\n\n  /* We're going to construct n linked lists, one for each \"value\".\n   * value_list_head will contain pointers to the heads of these linked lists,\n   * value_list_tail will contain pointers to the tail of the lists. */\n  value_list_head = calloc(data->values_len, sizeof(*value_list_head));\n  value_list_tail = calloc(data->values_len, sizeof(*value_list_tail));\n  if ((value_list_head == NULL) || (value_list_tail == NULL)) {\n    ERROR(\"snmp plugin: csnmp_read_table: calloc failed.\");\n    sfree(value_list_head);\n    sfree(value_list_tail);\n    return (-1);\n  }\n\n  instance_list_head = NULL;\n  instance_list_tail = NULL;\n\n  status = 0;\n  while (status == 0) {\n    int oid_list_todo_num;\n\n    req = snmp_pdu_create(SNMP_MSG_GETNEXT);\n    if (req == NULL) {\n      ERROR(\"snmp plugin: snmp_pdu_create failed.\");\n      status = -1;\n      break;\n    }\n\n    oid_list_todo_num = 0;\n    for (i = 0; i < oid_list_len; i++) {\n      /* Do not rerequest already finished OIDs */\n      if (!oid_list_todo[i])\n        continue;\n      oid_list_todo_num++;\n      snmp_add_null_var(req, oid_list[i].oid, oid_list[i].oid_len);\n    }\n\n    if (oid_list_todo_num == 0) {\n      /* The request is still empty - so we are finished */\n      DEBUG(\"snmp plugin: all variables have left their subtree\");\n      snmp_free_pdu(req);\n      status = 0;\n      break;\n    }\n\n    res = NULL;\n    /* snmp_sess_synch_response always frees our req PDU */\n    status = snmp_sess_synch_response(host->sess_handle, req, &res);\n    if ((status != STAT_SUCCESS) || (res == NULL)) {\n      char *errstr = NULL;\n\n      snmp_sess_error(host->sess_handle, NULL, NULL, &errstr);\n\n      c_complain(LOG_ERR, &host->complaint,\n                 \"snmp plugin: host %s: snmp_sess_synch_response failed: %s\",\n                 host->name, (errstr == NULL) ? \"Unknown problem\" : errstr);\n\n      if (res != NULL)\n        snmp_free_pdu(res);\n      res = NULL;\n\n      sfree(errstr);\n      csnmp_host_close_session(host);\n\n      status = -1;\n      break;\n    }\n\n    status = 0;\n    assert(res != NULL);\n    c_release(LOG_INFO, &host->complaint,\n              \"snmp plugin: host %s: snmp_sess_synch_response successful.\",\n              host->name);\n\n    vb = res->variables;\n    if (vb == NULL) {\n      status = -1;\n      break;\n    }\n\n    for (vb = res->variables, i = 0; (vb != NULL);\n         vb = vb->next_variable, i++) {\n      /* Calculate value index from todo list */\n      while ((i < oid_list_len) && !oid_list_todo[i])\n        i++;\n\n      /* An instance is configured and the res variable we process is the\n       * instance value (last index) */\n      if ((data->instance.oid.oid_len > 0) && (i == data->values_len)) {\n        if ((vb->type == SNMP_ENDOFMIBVIEW) ||\n            (snmp_oid_ncompare(\n                 data->instance.oid.oid, data->instance.oid.oid_len, vb->name,\n                 vb->name_length, data->instance.oid.oid_len) != 0)) {\n          DEBUG(\"snmp plugin: host = %s; data = %s; Instance left its subtree.\",\n                host->name, data->name);\n          oid_list_todo[i] = 0;\n          continue;\n        }\n\n        /* Allocate a new `csnmp_list_instances_t', insert the instance name and\n         * add it to the list */\n        if (csnmp_instance_list_add(&instance_list_head, &instance_list_tail,\n                                    res, host, data) != 0) {\n          ERROR(\"snmp plugin: host %s: csnmp_instance_list_add failed.\",\n                host->name);\n          status = -1;\n          break;\n        }\n      } else /* The variable we are processing is a normal value */\n      {\n        csnmp_table_values_t *vt;\n        oid_t vb_name;\n        oid_t suffix;\n        int ret;\n\n        csnmp_oid_init(&vb_name, vb->name, vb->name_length);\n\n        /* Calculate the current suffix. This is later used to check that the\n         * suffix is increasing. This also checks if we left the subtree */\n        ret = csnmp_oid_suffix(&suffix, &vb_name, data->values + i);\n        if (ret != 0) {\n          DEBUG(\"snmp plugin: host = %s; data = %s; i = %zu; \"\n                \"Value probably left its subtree.\",\n                host->name, data->name, i);\n          oid_list_todo[i] = 0;\n          continue;\n        }\n\n        /* Make sure the OIDs returned by the agent are increasing. Otherwise\n         * our\n         * table matching algorithm will get confused. */\n        if ((value_list_tail[i] != NULL) &&\n            (csnmp_oid_compare(&suffix, &value_list_tail[i]->suffix) <= 0)) {\n          DEBUG(\"snmp plugin: host = %s; data = %s; i = %zu; \"\n                \"Suffix is not increasing.\",\n                host->name, data->name, i);\n          oid_list_todo[i] = 0;\n          continue;\n        }\n\n        vt = calloc(1, sizeof(*vt));\n        if (vt == NULL) {\n          ERROR(\"snmp plugin: calloc failed.\");\n          status = -1;\n          break;\n        }\n\n        vt->value =\n            csnmp_value_list_to_value(vb, ds->ds[i].type, data->scale,\n                                      data->shift, host->name, data->name);\n        memcpy(&vt->suffix, &suffix, sizeof(vt->suffix));\n        vt->next = NULL;\n\n        if (value_list_tail[i] == NULL)\n          value_list_head[i] = vt;\n        else\n          value_list_tail[i]->next = vt;\n        value_list_tail[i] = vt;\n      }\n\n      /* Copy OID to oid_list[i] */\n      memcpy(oid_list[i].oid, vb->name, sizeof(oid) * vb->name_length);\n      oid_list[i].oid_len = vb->name_length;\n\n    } /* for (vb = res->variables ...) */\n\n    if (res != NULL)\n      snmp_free_pdu(res);\n    res = NULL;\n  } /* while (status == 0) */\n\n  if (res != NULL)\n    snmp_free_pdu(res);\n  res = NULL;\n\n\n  if (status == 0)\n    csnmp_dispatch_table(host, data, instance_list_head, value_list_head);\n\n  /* Free all allocated variables here */\n  while (instance_list_head != NULL) {\n    csnmp_list_instances_t *next = instance_list_head->next;\n    sfree(instance_list_head);\n    instance_list_head = next;\n  }\n\n  for (i = 0; i < data->values_len; i++) {\n    while (value_list_head[i] != NULL) {\n      csnmp_table_values_t *next = value_list_head[i]->next;\n      sfree(value_list_head[i]);\n      value_list_head[i] = next;\n    }\n  }\n\n  sfree(value_list_head);\n  sfree(value_list_tail);\n\n  return (0);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -95,11 +95,13 @@\n     if (oid_list_todo_num == 0) {\n       /* The request is still empty - so we are finished */\n       DEBUG(\"snmp plugin: all variables have left their subtree\");\n+      snmp_free_pdu(req);\n       status = 0;\n       break;\n     }\n \n     res = NULL;\n+    /* snmp_sess_synch_response always frees our req PDU */\n     status = snmp_sess_synch_response(host->sess_handle, req, &res);\n     if ((status != STAT_SUCCESS) || (res == NULL)) {\n       char *errstr = NULL;\n@@ -114,8 +116,6 @@\n         snmp_free_pdu(res);\n       res = NULL;\n \n-      /* snmp_synch_response already freed our PDU */\n-      req = NULL;\n       sfree(errstr);\n       csnmp_host_close_session(host);\n \n@@ -230,9 +230,6 @@\n     snmp_free_pdu(res);\n   res = NULL;\n \n-  if (req != NULL)\n-    snmp_free_pdu(req);\n-  req = NULL;\n \n   if (status == 0)\n     csnmp_dispatch_table(host, data, instance_list_head, value_list_head);",
        "diff_line_info": {
            "deleted_lines": [
                "      /* snmp_synch_response already freed our PDU */",
                "      req = NULL;",
                "  if (req != NULL)",
                "    snmp_free_pdu(req);",
                "  req = NULL;"
            ],
            "added_lines": [
                "      snmp_free_pdu(req);",
                "    /* snmp_sess_synch_response always frees our req PDU */"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-18120",
        "func_name": "kohler/gifsicle/read_gif",
        "description": "A double-free bug in the read_gif function in gifread.c in gifsicle 1.90 allows a remote attacker to cause a denial-of-service attack or unspecified other impact via a maliciously crafted file, because last_name is mishandled, a different vulnerability than CVE-2017-1000421.",
        "git_url": "https://github.com/kohler/gifsicle/commit/118a46090c50829dc543179019e6140e1235f909",
        "commit_title": "gif_read: Set last_name = NULL unconditionally.",
        "commit_text": " With a non-malicious GIF, last_name is set to NULL when a name extension is followed by an image. Reported in #117, via Debian, via a KAIST fuzzing program.",
        "func_before": "static Gif_Stream *\nread_gif(Gif_Reader *grr, int read_flags,\n\t const char* landmark, Gif_ReadErrorHandler handler)\n{\n  Gif_Stream *gfs;\n  Gif_Image *gfi;\n  Gif_Context gfc;\n  int unknown_block_type = 0;\n\n  if (gifgetc(grr) != 'G' ||\n      gifgetc(grr) != 'I' ||\n      gifgetc(grr) != 'F')\n    return 0;\n  (void)gifgetc(grr);\n  (void)gifgetc(grr);\n  (void)gifgetc(grr);\n\n  gfs = Gif_NewStream();\n  gfi = Gif_NewImage();\n\n  gfc.stream = gfs;\n  gfc.prefix = Gif_NewArray(Gif_Code, GIF_MAX_CODE);\n  gfc.suffix = Gif_NewArray(uint8_t, GIF_MAX_CODE);\n  gfc.length = Gif_NewArray(uint16_t, GIF_MAX_CODE);\n  gfc.handler = handler;\n  gfc.gfi = gfi;\n  gfc.errors[0] = gfc.errors[1] = 0;\n\n  if (!gfs || !gfi || !gfc.prefix || !gfc.suffix || !gfc.length)\n    goto done;\n  gfs->landmark = landmark;\n\n  GIF_DEBUG((\"\\nGIF \"));\n  if (!read_logical_screen_descriptor(gfs, grr))\n    goto done;\n  GIF_DEBUG((\"logscrdesc \"));\n\n  while (!gifeof(grr)) {\n\n    uint8_t block = gifgetbyte(grr);\n\n    switch (block) {\n\n     case ',': /* image block */\n      GIF_DEBUG((\"imageread %d \", gfs->nimages));\n\n      gfi->identifier = last_name;\n      last_name = 0;\n      if (!Gif_AddImage(gfs, gfi))\n          goto done;\n      else if (!read_image(grr, &gfc, gfi, read_flags)) {\n          Gif_RemoveImage(gfs, gfs->nimages - 1);\n          gfi = 0;\n          goto done;\n      }\n\n      gfc.gfi = gfi = Gif_NewImage();\n      if (!gfi)\n          goto done;\n      break;\n\n     case ';': /* terminator */\n      GIF_DEBUG((\"term\\n\"));\n      goto done;\n\n     case '!': /* extension */\n      block = gifgetbyte(grr);\n      GIF_DEBUG((\"ext(0x%02X) \", block));\n      switch (block) {\n\n       case 0xF9:\n\tread_graphic_control_extension(&gfc, gfi, grr);\n\tbreak;\n\n       case 0xCE:\n\tlast_name = suck_data(last_name, 0, grr);\n\tbreak;\n\n       case 0xFE:\n\tif (!read_comment_extension(gfi, grr)) goto done;\n\tbreak;\n\n       case 0xFF:\n\tread_application_extension(&gfc, grr);\n\tbreak;\n\n       default:\n        read_unknown_extension(&gfc, grr, block, 0, 0);\n\tbreak;\n\n      }\n      break;\n\n     default:\n       if (!unknown_block_type) {\n\t char buf[256];\n\t sprintf(buf, \"unknown block type %d at file offset %u\", block, grr->pos - 1);\n\t gif_read_error(&gfc, 1, buf);\n\t unknown_block_type = 1;\n       }\n       break;\n\n    }\n\n  }\n\n done:\n\n  /* Move comments and extensions after last image into stream. */\n  if (gfs && gfi) {\n      Gif_Extension* gfex;\n      gfs->end_comment = gfi->comment;\n      gfi->comment = 0;\n      gfs->end_extension_list = gfi->extension_list;\n      gfi->extension_list = 0;\n      for (gfex = gfs->end_extension_list; gfex; gfex = gfex->next)\n          gfex->image = NULL;\n  }\n\n  Gif_DeleteImage(gfi);\n  Gif_DeleteArray(last_name);\n  Gif_DeleteArray(gfc.prefix);\n  Gif_DeleteArray(gfc.suffix);\n  Gif_DeleteArray(gfc.length);\n  gfc.gfi = 0;\n\n  if (gfs)\n    gfs->errors = gfc.errors[1];\n  if (gfs && gfc.errors[1] == 0\n      && !(read_flags & GIF_READ_TRAILING_GARBAGE_OK)\n      && !grr->eofer(grr))\n      gif_read_error(&gfc, 0, \"trailing garbage after GIF ignored\");\n  /* finally, export last message */\n  gif_read_error(&gfc, -1, 0);\n\n  return gfs;\n}",
        "func": "static Gif_Stream *\nread_gif(Gif_Reader *grr, int read_flags,\n\t const char* landmark, Gif_ReadErrorHandler handler)\n{\n  Gif_Stream *gfs;\n  Gif_Image *gfi;\n  Gif_Context gfc;\n  int unknown_block_type = 0;\n\n  if (gifgetc(grr) != 'G' ||\n      gifgetc(grr) != 'I' ||\n      gifgetc(grr) != 'F')\n    return 0;\n  (void)gifgetc(grr);\n  (void)gifgetc(grr);\n  (void)gifgetc(grr);\n\n  gfs = Gif_NewStream();\n  gfi = Gif_NewImage();\n\n  gfc.stream = gfs;\n  gfc.prefix = Gif_NewArray(Gif_Code, GIF_MAX_CODE);\n  gfc.suffix = Gif_NewArray(uint8_t, GIF_MAX_CODE);\n  gfc.length = Gif_NewArray(uint16_t, GIF_MAX_CODE);\n  gfc.handler = handler;\n  gfc.gfi = gfi;\n  gfc.errors[0] = gfc.errors[1] = 0;\n\n  if (!gfs || !gfi || !gfc.prefix || !gfc.suffix || !gfc.length)\n    goto done;\n  gfs->landmark = landmark;\n\n  GIF_DEBUG((\"\\nGIF \"));\n  if (!read_logical_screen_descriptor(gfs, grr))\n    goto done;\n  GIF_DEBUG((\"logscrdesc \"));\n\n  while (!gifeof(grr)) {\n\n    uint8_t block = gifgetbyte(grr);\n\n    switch (block) {\n\n     case ',': /* image block */\n      GIF_DEBUG((\"imageread %d \", gfs->nimages));\n\n      gfi->identifier = last_name;\n      last_name = 0;\n      if (!Gif_AddImage(gfs, gfi))\n          goto done;\n      else if (!read_image(grr, &gfc, gfi, read_flags)) {\n          Gif_RemoveImage(gfs, gfs->nimages - 1);\n          gfi = 0;\n          goto done;\n      }\n\n      gfc.gfi = gfi = Gif_NewImage();\n      if (!gfi)\n          goto done;\n      break;\n\n     case ';': /* terminator */\n      GIF_DEBUG((\"term\\n\"));\n      goto done;\n\n     case '!': /* extension */\n      block = gifgetbyte(grr);\n      GIF_DEBUG((\"ext(0x%02X) \", block));\n      switch (block) {\n\n       case 0xF9:\n\tread_graphic_control_extension(&gfc, gfi, grr);\n\tbreak;\n\n       case 0xCE:\n\tlast_name = suck_data(last_name, 0, grr);\n\tbreak;\n\n       case 0xFE:\n\tif (!read_comment_extension(gfi, grr)) goto done;\n\tbreak;\n\n       case 0xFF:\n\tread_application_extension(&gfc, grr);\n\tbreak;\n\n       default:\n        read_unknown_extension(&gfc, grr, block, 0, 0);\n\tbreak;\n\n      }\n      break;\n\n     default:\n       if (!unknown_block_type) {\n\t char buf[256];\n\t sprintf(buf, \"unknown block type %d at file offset %u\", block, grr->pos - 1);\n\t gif_read_error(&gfc, 1, buf);\n\t unknown_block_type = 1;\n       }\n       break;\n\n    }\n\n  }\n\n done:\n\n  /* Move comments and extensions after last image into stream. */\n  if (gfs && gfi) {\n      Gif_Extension* gfex;\n      gfs->end_comment = gfi->comment;\n      gfi->comment = 0;\n      gfs->end_extension_list = gfi->extension_list;\n      gfi->extension_list = 0;\n      for (gfex = gfs->end_extension_list; gfex; gfex = gfex->next)\n          gfex->image = NULL;\n  }\n\n  Gif_DeleteImage(gfi);\n  Gif_DeleteArray(last_name);\n  Gif_DeleteArray(gfc.prefix);\n  Gif_DeleteArray(gfc.suffix);\n  Gif_DeleteArray(gfc.length);\n  gfc.gfi = 0;\n  last_name = 0;\n\n  if (gfs)\n    gfs->errors = gfc.errors[1];\n  if (gfs && gfc.errors[1] == 0\n      && !(read_flags & GIF_READ_TRAILING_GARBAGE_OK)\n      && !grr->eofer(grr))\n      gif_read_error(&gfc, 0, \"trailing garbage after GIF ignored\");\n  /* finally, export last message */\n  gif_read_error(&gfc, -1, 0);\n\n  return gfs;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -123,6 +123,7 @@\n   Gif_DeleteArray(gfc.suffix);\n   Gif_DeleteArray(gfc.length);\n   gfc.gfi = 0;\n+  last_name = 0;\n \n   if (gfs)\n     gfs->errors = gfc.errors[1];",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "  last_name = 0;"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-18174",
        "func_name": "torvalds/linux/amd_gpio_remove",
        "description": "In the Linux kernel before 4.7, the amd_gpio_remove function in drivers/pinctrl/pinctrl-amd.c calls the pinctrl_unregister function, leading to a double free.",
        "git_url": "https://github.com/torvalds/linux/commit/8dca4a41f1ad65043a78c2338d9725f859c8d2c3",
        "commit_title": "pinctrl/amd: Drop pinctrl_unregister for devm_ registered device",
        "commit_text": " It's not necessary to unregister pin controller device registered with devm_pinctrl_register() and using pinctrl_unregister() leads to a double free. ",
        "func_before": "static int amd_gpio_remove(struct platform_device *pdev)\n{\n\tstruct amd_gpio *gpio_dev;\n\n\tgpio_dev = platform_get_drvdata(pdev);\n\n\tgpiochip_remove(&gpio_dev->gc);\n\tpinctrl_unregister(gpio_dev->pctrl);\n\n\treturn 0;\n}",
        "func": "static int amd_gpio_remove(struct platform_device *pdev)\n{\n\tstruct amd_gpio *gpio_dev;\n\n\tgpio_dev = platform_get_drvdata(pdev);\n\n\tgpiochip_remove(&gpio_dev->gc);\n\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,7 +5,6 @@\n \tgpio_dev = platform_get_drvdata(pdev);\n \n \tgpiochip_remove(&gpio_dev->gc);\n-\tpinctrl_unregister(gpio_dev->pctrl);\n \n \treturn 0;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tpinctrl_unregister(gpio_dev->pctrl);"
            ],
            "added_lines": []
        }
    },
    {
        "cve_id": "CVE-2017-18174",
        "func_name": "torvalds/linux/amd_gpio_remove",
        "description": "In the Linux kernel before 4.7, the amd_gpio_remove function in drivers/pinctrl/pinctrl-amd.c calls the pinctrl_unregister function, leading to a double free.",
        "git_url": "https://github.com/torvalds/linux/commit/251e22abde21833b3d29577e4d8c7aaccd650eee",
        "commit_title": "pinctrl: amd: Use devm_pinctrl_register() for pinctrl registration",
        "commit_text": " Use devm_pinctrl_register() for pin control registration and clean error path. ",
        "func_before": "static int amd_gpio_remove(struct platform_device *pdev)\n{\n\tstruct amd_gpio *gpio_dev;\n\n\tgpio_dev = platform_get_drvdata(pdev);\n\n\tgpiochip_remove(&gpio_dev->gc);\n\tpinctrl_unregister(gpio_dev->pctrl);\n\n\treturn 0;\n}",
        "func": "static int amd_gpio_remove(struct platform_device *pdev)\n{\n\tstruct amd_gpio *gpio_dev;\n\n\tgpio_dev = platform_get_drvdata(pdev);\n\n\tgpiochip_remove(&gpio_dev->gc);\n\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,7 +5,6 @@\n \tgpio_dev = platform_get_drvdata(pdev);\n \n \tgpiochip_remove(&gpio_dev->gc);\n-\tpinctrl_unregister(gpio_dev->pctrl);\n \n \treturn 0;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tpinctrl_unregister(gpio_dev->pctrl);"
            ],
            "added_lines": []
        }
    },
    {
        "cve_id": "CVE-2017-18174",
        "func_name": "torvalds/linux/amd_gpio_probe",
        "description": "In the Linux kernel before 4.7, the amd_gpio_remove function in drivers/pinctrl/pinctrl-amd.c calls the pinctrl_unregister function, leading to a double free.",
        "git_url": "https://github.com/torvalds/linux/commit/251e22abde21833b3d29577e4d8c7aaccd650eee",
        "commit_title": "pinctrl: amd: Use devm_pinctrl_register() for pinctrl registration",
        "commit_text": " Use devm_pinctrl_register() for pin control registration and clean error path. ",
        "func_before": "static int amd_gpio_probe(struct platform_device *pdev)\n{\n\tint ret = 0;\n\tint irq_base;\n\tstruct resource *res;\n\tstruct amd_gpio *gpio_dev;\n\n\tgpio_dev = devm_kzalloc(&pdev->dev,\n\t\t\t\tsizeof(struct amd_gpio), GFP_KERNEL);\n\tif (!gpio_dev)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&gpio_dev->lock);\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res) {\n\t\tdev_err(&pdev->dev, \"Failed to get gpio io resource.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tgpio_dev->base = devm_ioremap_nocache(&pdev->dev, res->start,\n\t\t\t\t\t\tresource_size(res));\n\tif (!gpio_dev->base)\n\t\treturn -ENOMEM;\n\n\tirq_base = platform_get_irq(pdev, 0);\n\tif (irq_base < 0) {\n\t\tdev_err(&pdev->dev, \"Failed to get gpio IRQ.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tgpio_dev->pdev = pdev;\n\tgpio_dev->gc.direction_input\t= amd_gpio_direction_input;\n\tgpio_dev->gc.direction_output\t= amd_gpio_direction_output;\n\tgpio_dev->gc.get\t\t\t= amd_gpio_get_value;\n\tgpio_dev->gc.set\t\t\t= amd_gpio_set_value;\n\tgpio_dev->gc.set_debounce\t= amd_gpio_set_debounce;\n\tgpio_dev->gc.dbg_show\t\t= amd_gpio_dbg_show;\n\n\tgpio_dev->gc.base\t\t\t= 0;\n\tgpio_dev->gc.label\t\t\t= pdev->name;\n\tgpio_dev->gc.owner\t\t\t= THIS_MODULE;\n\tgpio_dev->gc.parent\t\t\t= &pdev->dev;\n\tgpio_dev->gc.ngpio\t\t\t= TOTAL_NUMBER_OF_PINS;\n#if defined(CONFIG_OF_GPIO)\n\tgpio_dev->gc.of_node\t\t\t= pdev->dev.of_node;\n#endif\n\n\tgpio_dev->groups = kerncz_groups;\n\tgpio_dev->ngroups = ARRAY_SIZE(kerncz_groups);\n\n\tamd_pinctrl_desc.name = dev_name(&pdev->dev);\n\tgpio_dev->pctrl = pinctrl_register(&amd_pinctrl_desc,\n\t\t\t\t\t&pdev->dev, gpio_dev);\n\tif (IS_ERR(gpio_dev->pctrl)) {\n\t\tdev_err(&pdev->dev, \"Couldn't register pinctrl driver\\n\");\n\t\treturn PTR_ERR(gpio_dev->pctrl);\n\t}\n\n\tret = gpiochip_add_data(&gpio_dev->gc, gpio_dev);\n\tif (ret)\n\t\tgoto out1;\n\n\tret = gpiochip_add_pin_range(&gpio_dev->gc, dev_name(&pdev->dev),\n\t\t\t\t0, 0, TOTAL_NUMBER_OF_PINS);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to add pin range\\n\");\n\t\tgoto out2;\n\t}\n\n\tret = gpiochip_irqchip_add(&gpio_dev->gc,\n\t\t\t\t&amd_gpio_irqchip,\n\t\t\t\t0,\n\t\t\t\thandle_simple_irq,\n\t\t\t\tIRQ_TYPE_NONE);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"could not add irqchip\\n\");\n\t\tret = -ENODEV;\n\t\tgoto out2;\n\t}\n\n\tgpiochip_set_chained_irqchip(&gpio_dev->gc,\n\t\t\t\t &amd_gpio_irqchip,\n\t\t\t\t irq_base,\n\t\t\t\t amd_gpio_irq_handler);\n\n\tplatform_set_drvdata(pdev, gpio_dev);\n\n\tdev_dbg(&pdev->dev, \"amd gpio driver loaded\\n\");\n\treturn ret;\n\nout2:\n\tgpiochip_remove(&gpio_dev->gc);\n\nout1:\n\tpinctrl_unregister(gpio_dev->pctrl);\n\treturn ret;\n}",
        "func": "static int amd_gpio_probe(struct platform_device *pdev)\n{\n\tint ret = 0;\n\tint irq_base;\n\tstruct resource *res;\n\tstruct amd_gpio *gpio_dev;\n\n\tgpio_dev = devm_kzalloc(&pdev->dev,\n\t\t\t\tsizeof(struct amd_gpio), GFP_KERNEL);\n\tif (!gpio_dev)\n\t\treturn -ENOMEM;\n\n\tspin_lock_init(&gpio_dev->lock);\n\n\tres = platform_get_resource(pdev, IORESOURCE_MEM, 0);\n\tif (!res) {\n\t\tdev_err(&pdev->dev, \"Failed to get gpio io resource.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tgpio_dev->base = devm_ioremap_nocache(&pdev->dev, res->start,\n\t\t\t\t\t\tresource_size(res));\n\tif (!gpio_dev->base)\n\t\treturn -ENOMEM;\n\n\tirq_base = platform_get_irq(pdev, 0);\n\tif (irq_base < 0) {\n\t\tdev_err(&pdev->dev, \"Failed to get gpio IRQ.\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tgpio_dev->pdev = pdev;\n\tgpio_dev->gc.direction_input\t= amd_gpio_direction_input;\n\tgpio_dev->gc.direction_output\t= amd_gpio_direction_output;\n\tgpio_dev->gc.get\t\t\t= amd_gpio_get_value;\n\tgpio_dev->gc.set\t\t\t= amd_gpio_set_value;\n\tgpio_dev->gc.set_debounce\t= amd_gpio_set_debounce;\n\tgpio_dev->gc.dbg_show\t\t= amd_gpio_dbg_show;\n\n\tgpio_dev->gc.base\t\t\t= 0;\n\tgpio_dev->gc.label\t\t\t= pdev->name;\n\tgpio_dev->gc.owner\t\t\t= THIS_MODULE;\n\tgpio_dev->gc.parent\t\t\t= &pdev->dev;\n\tgpio_dev->gc.ngpio\t\t\t= TOTAL_NUMBER_OF_PINS;\n#if defined(CONFIG_OF_GPIO)\n\tgpio_dev->gc.of_node\t\t\t= pdev->dev.of_node;\n#endif\n\n\tgpio_dev->groups = kerncz_groups;\n\tgpio_dev->ngroups = ARRAY_SIZE(kerncz_groups);\n\n\tamd_pinctrl_desc.name = dev_name(&pdev->dev);\n\tgpio_dev->pctrl = devm_pinctrl_register(&pdev->dev, &amd_pinctrl_desc,\n\t\t\t\t\t\tgpio_dev);\n\tif (IS_ERR(gpio_dev->pctrl)) {\n\t\tdev_err(&pdev->dev, \"Couldn't register pinctrl driver\\n\");\n\t\treturn PTR_ERR(gpio_dev->pctrl);\n\t}\n\n\tret = gpiochip_add_data(&gpio_dev->gc, gpio_dev);\n\tif (ret)\n\t\treturn ret;\n\n\tret = gpiochip_add_pin_range(&gpio_dev->gc, dev_name(&pdev->dev),\n\t\t\t\t0, 0, TOTAL_NUMBER_OF_PINS);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"Failed to add pin range\\n\");\n\t\tgoto out2;\n\t}\n\n\tret = gpiochip_irqchip_add(&gpio_dev->gc,\n\t\t\t\t&amd_gpio_irqchip,\n\t\t\t\t0,\n\t\t\t\thandle_simple_irq,\n\t\t\t\tIRQ_TYPE_NONE);\n\tif (ret) {\n\t\tdev_err(&pdev->dev, \"could not add irqchip\\n\");\n\t\tret = -ENODEV;\n\t\tgoto out2;\n\t}\n\n\tgpiochip_set_chained_irqchip(&gpio_dev->gc,\n\t\t\t\t &amd_gpio_irqchip,\n\t\t\t\t irq_base,\n\t\t\t\t amd_gpio_irq_handler);\n\n\tplatform_set_drvdata(pdev, gpio_dev);\n\n\tdev_dbg(&pdev->dev, \"amd gpio driver loaded\\n\");\n\treturn ret;\n\nout2:\n\tgpiochip_remove(&gpio_dev->gc);\n\n\treturn ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -50,8 +50,8 @@\n \tgpio_dev->ngroups = ARRAY_SIZE(kerncz_groups);\n \n \tamd_pinctrl_desc.name = dev_name(&pdev->dev);\n-\tgpio_dev->pctrl = pinctrl_register(&amd_pinctrl_desc,\n-\t\t\t\t\t&pdev->dev, gpio_dev);\n+\tgpio_dev->pctrl = devm_pinctrl_register(&pdev->dev, &amd_pinctrl_desc,\n+\t\t\t\t\t\tgpio_dev);\n \tif (IS_ERR(gpio_dev->pctrl)) {\n \t\tdev_err(&pdev->dev, \"Couldn't register pinctrl driver\\n\");\n \t\treturn PTR_ERR(gpio_dev->pctrl);\n@@ -59,7 +59,7 @@\n \n \tret = gpiochip_add_data(&gpio_dev->gc, gpio_dev);\n \tif (ret)\n-\t\tgoto out1;\n+\t\treturn ret;\n \n \tret = gpiochip_add_pin_range(&gpio_dev->gc, dev_name(&pdev->dev),\n \t\t\t\t0, 0, TOTAL_NUMBER_OF_PINS);\n@@ -92,7 +92,5 @@\n out2:\n \tgpiochip_remove(&gpio_dev->gc);\n \n-out1:\n-\tpinctrl_unregister(gpio_dev->pctrl);\n \treturn ret;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tgpio_dev->pctrl = pinctrl_register(&amd_pinctrl_desc,",
                "\t\t\t\t\t&pdev->dev, gpio_dev);",
                "\t\tgoto out1;",
                "out1:",
                "\tpinctrl_unregister(gpio_dev->pctrl);"
            ],
            "added_lines": [
                "\tgpio_dev->pctrl = devm_pinctrl_register(&pdev->dev, &amd_pinctrl_desc,",
                "\t\t\t\t\t\tgpio_dev);",
                "\t\treturn ret;"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-25136",
        "func_name": "openssh/openssh-portable/compat_kex_proposal",
        "description": "OpenSSH server (sshd) 9.1 introduced a double-free vulnerability during options.kex_algorithms handling. This is fixed in OpenSSH 9.2. The double free can be leveraged, by an unauthenticated remote attacker in the default configuration, to jump to any location in the sshd address space. One third-party report states \"remote code execution is theoretically possible.\"",
        "git_url": "https://github.com/openssh/openssh-portable/commit/486c4dc3b83b4b67d663fb0fa62bc24138ec3946",
        "commit_title": "upstream: Always return allocated strings from the kex filtering so",
        "commit_text": " that we can free them later.  Fix one leak in compat_kex_proposal.  Based on github PR#324 from ZoltanFridrich with some simplications by me. ok djm@  OpenBSD-Commit-ID: 9171616da3307612d0ede086fd511142f91246e4",
        "func_before": "char *\ncompat_kex_proposal(struct ssh *ssh, char *p)\n{\n\tif ((ssh->compat & (SSH_BUG_CURVE25519PAD|SSH_OLD_DHGEX)) == 0)\n\t\treturn p;\n\tdebug2_f(\"original KEX proposal: %s\", p);\n\tif ((ssh->compat & SSH_BUG_CURVE25519PAD) != 0)\n\t\tif ((p = match_filter_denylist(p,\n\t\t    \"curve25519-sha256@libssh.org\")) == NULL)\n\t\t\tfatal(\"match_filter_denylist failed\");\n\tif ((ssh->compat & SSH_OLD_DHGEX) != 0) {\n\t\tif ((p = match_filter_denylist(p,\n\t\t    \"diffie-hellman-group-exchange-sha256,\"\n\t\t    \"diffie-hellman-group-exchange-sha1\")) == NULL)\n\t\t\tfatal(\"match_filter_denylist failed\");\n\t}\n\tdebug2_f(\"compat KEX proposal: %s\", p);\n\tif (*p == '\\0')\n\t\tfatal(\"No supported key exchange algorithms found\");\n\treturn p;\n}",
        "func": "char *\ncompat_kex_proposal(struct ssh *ssh, char *p)\n{\n\tchar *cp = NULL;\n\n\tif ((ssh->compat & (SSH_BUG_CURVE25519PAD|SSH_OLD_DHGEX)) == 0)\n\t\treturn xstrdup(p);\n\tdebug2_f(\"original KEX proposal: %s\", p);\n\tif ((ssh->compat & SSH_BUG_CURVE25519PAD) != 0)\n\t\tif ((p = match_filter_denylist(p,\n\t\t    \"curve25519-sha256@libssh.org\")) == NULL)\n\t\t\tfatal(\"match_filter_denylist failed\");\n\tif ((ssh->compat & SSH_OLD_DHGEX) != 0) {\n\t\tcp = p;\n\t\tif ((p = match_filter_denylist(p,\n\t\t    \"diffie-hellman-group-exchange-sha256,\"\n\t\t    \"diffie-hellman-group-exchange-sha1\")) == NULL)\n\t\t\tfatal(\"match_filter_denylist failed\");\n\t\tfree(cp);\n\t}\n\tdebug2_f(\"compat KEX proposal: %s\", p);\n\tif (*p == '\\0')\n\t\tfatal(\"No supported key exchange algorithms found\");\n\treturn p;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,18 +1,22 @@\n char *\n compat_kex_proposal(struct ssh *ssh, char *p)\n {\n+\tchar *cp = NULL;\n+\n \tif ((ssh->compat & (SSH_BUG_CURVE25519PAD|SSH_OLD_DHGEX)) == 0)\n-\t\treturn p;\n+\t\treturn xstrdup(p);\n \tdebug2_f(\"original KEX proposal: %s\", p);\n \tif ((ssh->compat & SSH_BUG_CURVE25519PAD) != 0)\n \t\tif ((p = match_filter_denylist(p,\n \t\t    \"curve25519-sha256@libssh.org\")) == NULL)\n \t\t\tfatal(\"match_filter_denylist failed\");\n \tif ((ssh->compat & SSH_OLD_DHGEX) != 0) {\n+\t\tcp = p;\n \t\tif ((p = match_filter_denylist(p,\n \t\t    \"diffie-hellman-group-exchange-sha256,\"\n \t\t    \"diffie-hellman-group-exchange-sha1\")) == NULL)\n \t\t\tfatal(\"match_filter_denylist failed\");\n+\t\tfree(cp);\n \t}\n \tdebug2_f(\"compat KEX proposal: %s\", p);\n \tif (*p == '\\0')",
        "diff_line_info": {
            "deleted_lines": [
                "\t\treturn p;"
            ],
            "added_lines": [
                "\tchar *cp = NULL;",
                "",
                "\t\treturn xstrdup(p);",
                "\t\tcp = p;",
                "\t\tfree(cp);"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-25136",
        "func_name": "openssh/openssh-portable/compat_pkalg_proposal",
        "description": "OpenSSH server (sshd) 9.1 introduced a double-free vulnerability during options.kex_algorithms handling. This is fixed in OpenSSH 9.2. The double free can be leveraged, by an unauthenticated remote attacker in the default configuration, to jump to any location in the sshd address space. One third-party report states \"remote code execution is theoretically possible.\"",
        "git_url": "https://github.com/openssh/openssh-portable/commit/486c4dc3b83b4b67d663fb0fa62bc24138ec3946",
        "commit_title": "upstream: Always return allocated strings from the kex filtering so",
        "commit_text": " that we can free them later.  Fix one leak in compat_kex_proposal.  Based on github PR#324 from ZoltanFridrich with some simplications by me. ok djm@  OpenBSD-Commit-ID: 9171616da3307612d0ede086fd511142f91246e4",
        "func_before": "char *\ncompat_pkalg_proposal(struct ssh *ssh, char *pkalg_prop)\n{\n\tif (!(ssh->compat & SSH_BUG_RSASIGMD5))\n\t\treturn pkalg_prop;\n\tdebug2_f(\"original public key proposal: %s\", pkalg_prop);\n\tif ((pkalg_prop = match_filter_denylist(pkalg_prop, \"ssh-rsa\")) == NULL)\n\t\tfatal(\"match_filter_denylist failed\");\n\tdebug2_f(\"compat public key proposal: %s\", pkalg_prop);\n\tif (*pkalg_prop == '\\0')\n\t\tfatal(\"No supported PK algorithms found\");\n\treturn pkalg_prop;\n}",
        "func": "char *\ncompat_pkalg_proposal(struct ssh *ssh, char *pkalg_prop)\n{\n\tif (!(ssh->compat & SSH_BUG_RSASIGMD5))\n\t\treturn xstrdup(pkalg_prop);\n\tdebug2_f(\"original public key proposal: %s\", pkalg_prop);\n\tif ((pkalg_prop = match_filter_denylist(pkalg_prop, \"ssh-rsa\")) == NULL)\n\t\tfatal(\"match_filter_denylist failed\");\n\tdebug2_f(\"compat public key proposal: %s\", pkalg_prop);\n\tif (*pkalg_prop == '\\0')\n\t\tfatal(\"No supported PK algorithms found\");\n\treturn pkalg_prop;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,7 +2,7 @@\n compat_pkalg_proposal(struct ssh *ssh, char *pkalg_prop)\n {\n \tif (!(ssh->compat & SSH_BUG_RSASIGMD5))\n-\t\treturn pkalg_prop;\n+\t\treturn xstrdup(pkalg_prop);\n \tdebug2_f(\"original public key proposal: %s\", pkalg_prop);\n \tif ((pkalg_prop = match_filter_denylist(pkalg_prop, \"ssh-rsa\")) == NULL)\n \t\tfatal(\"match_filter_denylist failed\");",
        "diff_line_info": {
            "deleted_lines": [
                "\t\treturn pkalg_prop;"
            ],
            "added_lines": [
                "\t\treturn xstrdup(pkalg_prop);"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-25136",
        "func_name": "openssh/openssh-portable/compat_cipher_proposal",
        "description": "OpenSSH server (sshd) 9.1 introduced a double-free vulnerability during options.kex_algorithms handling. This is fixed in OpenSSH 9.2. The double free can be leveraged, by an unauthenticated remote attacker in the default configuration, to jump to any location in the sshd address space. One third-party report states \"remote code execution is theoretically possible.\"",
        "git_url": "https://github.com/openssh/openssh-portable/commit/486c4dc3b83b4b67d663fb0fa62bc24138ec3946",
        "commit_title": "upstream: Always return allocated strings from the kex filtering so",
        "commit_text": " that we can free them later.  Fix one leak in compat_kex_proposal.  Based on github PR#324 from ZoltanFridrich with some simplications by me. ok djm@  OpenBSD-Commit-ID: 9171616da3307612d0ede086fd511142f91246e4",
        "func_before": "char *\ncompat_cipher_proposal(struct ssh *ssh, char *cipher_prop)\n{\n\tif (!(ssh->compat & SSH_BUG_BIGENDIANAES))\n\t\treturn cipher_prop;\n\tdebug2_f(\"original cipher proposal: %s\", cipher_prop);\n\tif ((cipher_prop = match_filter_denylist(cipher_prop, \"aes*\")) == NULL)\n\t\tfatal(\"match_filter_denylist failed\");\n\tdebug2_f(\"compat cipher proposal: %s\", cipher_prop);\n\tif (*cipher_prop == '\\0')\n\t\tfatal(\"No supported ciphers found\");\n\treturn cipher_prop;\n}",
        "func": "char *\ncompat_cipher_proposal(struct ssh *ssh, char *cipher_prop)\n{\n\tif (!(ssh->compat & SSH_BUG_BIGENDIANAES))\n\t\treturn xstrdup(cipher_prop);\n\tdebug2_f(\"original cipher proposal: %s\", cipher_prop);\n\tif ((cipher_prop = match_filter_denylist(cipher_prop, \"aes*\")) == NULL)\n\t\tfatal(\"match_filter_denylist failed\");\n\tdebug2_f(\"compat cipher proposal: %s\", cipher_prop);\n\tif (*cipher_prop == '\\0')\n\t\tfatal(\"No supported ciphers found\");\n\treturn cipher_prop;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,7 +2,7 @@\n compat_cipher_proposal(struct ssh *ssh, char *cipher_prop)\n {\n \tif (!(ssh->compat & SSH_BUG_BIGENDIANAES))\n-\t\treturn cipher_prop;\n+\t\treturn xstrdup(cipher_prop);\n \tdebug2_f(\"original cipher proposal: %s\", cipher_prop);\n \tif ((cipher_prop = match_filter_denylist(cipher_prop, \"aes*\")) == NULL)\n \t\tfatal(\"match_filter_denylist failed\");",
        "diff_line_info": {
            "deleted_lines": [
                "\t\treturn cipher_prop;"
            ],
            "added_lines": [
                "\t\treturn xstrdup(cipher_prop);"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-4450",
        "func_name": "openssl/PEM_read_bio_ex",
        "description": "The function PEM_read_bio_ex() reads a PEM file from a BIO and parses and\ndecodes the \"name\" (e.g. \"CERTIFICATE\"), any header data and the payload data.\nIf the function succeeds then the \"name_out\", \"header\" and \"data\" arguments are\npopulated with pointers to buffers containing the relevant decoded data. The\ncaller is responsible for freeing those buffers. It is possible to construct a\nPEM file that results in 0 bytes of payload data. In this case PEM_read_bio_ex()\nwill return a failure code but will populate the header argument with a pointer\nto a buffer that has already been freed. If the caller also frees this buffer\nthen a double free will occur. This will most likely lead to a crash. This\ncould be exploited by an attacker who has the ability to supply malicious PEM\nfiles for parsing to achieve a denial of service attack.\n\nThe functions PEM_read_bio() and PEM_read() are simple wrappers around\nPEM_read_bio_ex() and therefore these functions are also directly affected.\n\nThese functions are also called indirectly by a number of other OpenSSL\nfunctions including PEM_X509_INFO_read_bio_ex() and\nSSL_CTX_use_serverinfo_file() which are also vulnerable. Some OpenSSL internal\nuses of these functions are not vulnerable because the caller does not free the\nheader argument if PEM_read_bio_ex() returns a failure code. These locations\ninclude the PEM_read_bio_TYPE() functions as well as the decoders introduced in\nOpenSSL 3.0.\n\nThe OpenSSL asn1parse command line application is also impacted by this issue.\n\n\n",
        "git_url": "https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=bbcf509bd046b34cca19c766bbddc31683d0858b",
        "commit_title": "",
        "commit_text": "Avoid dangling ptrs in header and data params for PEM_read_bio_ex  In the event of a failure in PEM_read_bio_ex() we free the buffers we allocated for the header and data buffers. However we were not clearing the ptrs stored in *header and *data. Since, on success, the caller is responsible for freeing these ptrs this can potentially lead to a double free if the caller frees them even on failure.  Thanks to Dawei Wang for reporting this issue.  Based on a proposed patch by Kurt Roeckx.  CVE-2022-4450  ",
        "func_before": "int PEM_read_bio_ex(BIO *bp, char **name_out, char **header,\n                    unsigned char **data, long *len_out, unsigned int flags)\n{\n    EVP_ENCODE_CTX *ctx = NULL;\n    const BIO_METHOD *bmeth;\n    BIO *headerB = NULL, *dataB = NULL;\n    char *name = NULL;\n    int len, taillen, headerlen, ret = 0;\n    BUF_MEM * buf_mem;\n\n    *len_out = 0;\n    *name_out = *header = NULL;\n    *data = NULL;\n    if ((flags & PEM_FLAG_EAY_COMPATIBLE) && (flags & PEM_FLAG_ONLY_B64)) {\n        /* These two are mutually incompatible; bail out. */\n        PEMerr(PEM_F_PEM_READ_BIO_EX, ERR_R_PASSED_INVALID_ARGUMENT);\n        goto end;\n    }\n    bmeth = (flags & PEM_FLAG_SECURE) ? BIO_s_secmem() : BIO_s_mem();\n\n    headerB = BIO_new(bmeth);\n    dataB = BIO_new(bmeth);\n    if (headerB == NULL || dataB == NULL) {\n        PEMerr(PEM_F_PEM_READ_BIO_EX, ERR_R_MALLOC_FAILURE);\n        goto end;\n    }\n\n    if (!get_name(bp, &name, flags))\n        goto end;\n    if (!get_header_and_data(bp, &headerB, &dataB, name, flags))\n        goto end;\n\n    BIO_get_mem_ptr(dataB, &buf_mem);\n    len = buf_mem->length;\n\n    /* There was no data in the PEM file */\n    if (len == 0)\n        goto end;\n\n    ctx = EVP_ENCODE_CTX_new();\n    if (ctx == NULL) {\n        PEMerr(PEM_F_PEM_READ_BIO_EX, ERR_R_MALLOC_FAILURE);\n        goto end;\n    }\n\n    EVP_DecodeInit(ctx);\n    if (EVP_DecodeUpdate(ctx, (unsigned char*)buf_mem->data, &len,\n                         (unsigned char*)buf_mem->data, len) < 0\n            || EVP_DecodeFinal(ctx, (unsigned char*)&(buf_mem->data[len]),\n                               &taillen) < 0) {\n        PEMerr(PEM_F_PEM_READ_BIO_EX, PEM_R_BAD_BASE64_DECODE);\n        goto end;\n    }\n    len += taillen;\n    buf_mem->length = len;\n\n    headerlen = BIO_get_mem_data(headerB, NULL);\n    *header = pem_malloc(headerlen + 1, flags);\n    *data = pem_malloc(len, flags);\n    if (*header == NULL || *data == NULL) {\n        pem_free(*header, flags, 0);\n        pem_free(*data, flags, 0);\n        goto end;\n    }\n    BIO_read(headerB, *header, headerlen);\n    (*header)[headerlen] = '\\0';\n    BIO_read(dataB, *data, len);\n    *len_out = len;\n    *name_out = name;\n    name = NULL;\n    ret = 1;\n\nend:\n    EVP_ENCODE_CTX_free(ctx);\n    pem_free(name, flags, 0);\n    BIO_free(headerB);\n    BIO_free(dataB);\n    return ret;\n}",
        "func": "int PEM_read_bio_ex(BIO *bp, char **name_out, char **header,\n                    unsigned char **data, long *len_out, unsigned int flags)\n{\n    EVP_ENCODE_CTX *ctx = NULL;\n    const BIO_METHOD *bmeth;\n    BIO *headerB = NULL, *dataB = NULL;\n    char *name = NULL;\n    int len, taillen, headerlen, ret = 0;\n    BUF_MEM * buf_mem;\n\n    *len_out = 0;\n    *name_out = *header = NULL;\n    *data = NULL;\n    if ((flags & PEM_FLAG_EAY_COMPATIBLE) && (flags & PEM_FLAG_ONLY_B64)) {\n        /* These two are mutually incompatible; bail out. */\n        PEMerr(PEM_F_PEM_READ_BIO_EX, ERR_R_PASSED_INVALID_ARGUMENT);\n        goto end;\n    }\n    bmeth = (flags & PEM_FLAG_SECURE) ? BIO_s_secmem() : BIO_s_mem();\n\n    headerB = BIO_new(bmeth);\n    dataB = BIO_new(bmeth);\n    if (headerB == NULL || dataB == NULL) {\n        PEMerr(PEM_F_PEM_READ_BIO_EX, ERR_R_MALLOC_FAILURE);\n        goto end;\n    }\n\n    if (!get_name(bp, &name, flags))\n        goto end;\n    if (!get_header_and_data(bp, &headerB, &dataB, name, flags))\n        goto end;\n\n    BIO_get_mem_ptr(dataB, &buf_mem);\n    len = buf_mem->length;\n\n    /* There was no data in the PEM file */\n    if (len == 0)\n        goto end;\n\n    ctx = EVP_ENCODE_CTX_new();\n    if (ctx == NULL) {\n        PEMerr(PEM_F_PEM_READ_BIO_EX, ERR_R_MALLOC_FAILURE);\n        goto end;\n    }\n\n    EVP_DecodeInit(ctx);\n    if (EVP_DecodeUpdate(ctx, (unsigned char*)buf_mem->data, &len,\n                         (unsigned char*)buf_mem->data, len) < 0\n            || EVP_DecodeFinal(ctx, (unsigned char*)&(buf_mem->data[len]),\n                               &taillen) < 0) {\n        PEMerr(PEM_F_PEM_READ_BIO_EX, PEM_R_BAD_BASE64_DECODE);\n        goto end;\n    }\n    len += taillen;\n    buf_mem->length = len;\n\n    headerlen = BIO_get_mem_data(headerB, NULL);\n    *header = pem_malloc(headerlen + 1, flags);\n    *data = pem_malloc(len, flags);\n    if (*header == NULL || *data == NULL) {\n        pem_free(*header, flags, 0);\n        *header = NULL;\n        pem_free(*data, flags, 0);\n        *data = NULL;\n        goto end;\n    }\n    BIO_read(headerB, *header, headerlen);\n    (*header)[headerlen] = '\\0';\n    BIO_read(dataB, *data, len);\n    *len_out = len;\n    *name_out = name;\n    name = NULL;\n    ret = 1;\n\nend:\n    EVP_ENCODE_CTX_free(ctx);\n    pem_free(name, flags, 0);\n    BIO_free(headerB);\n    BIO_free(dataB);\n    return ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -59,7 +59,9 @@\n     *data = pem_malloc(len, flags);\n     if (*header == NULL || *data == NULL) {\n         pem_free(*header, flags, 0);\n+        *header = NULL;\n         pem_free(*data, flags, 0);\n+        *data = NULL;\n         goto end;\n     }\n     BIO_read(headerB, *header, headerlen);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "        *header = NULL;",
                "        *data = NULL;"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-33304",
        "func_name": "virtualsquare/picotcp/pico_fragments_reassemble",
        "description": "Double Free vulnerability in virtualsquare picoTCP v1.7.0 and picoTCP-NG v2.1 in modules/pico_fragments.c in function pico_fragments_reassemble, allows attackers to execute arbitrary code.",
        "git_url": "https://github.com/virtualsquare/picotcp/commit/7c195747d88a37b4059f5ad9df4bfbb6f1179e08",
        "commit_title": "Fix double free in pico_fragments_reassemble()",
        "commit_text": "",
        "func_before": "static int pico_fragments_reassemble(struct pico_tree *tree, unsigned int len, uint8_t proto, uint8_t net)\n{\n    struct pico_tree_node *index, *tmp;\n    struct pico_frame *f;\n    uint16_t header_length = 0;\n    unsigned int bookmark = 0;\n    struct pico_frame *full = NULL;\n    struct pico_frame *first = NULL;\n\n    if (!tree)\n    {\n        frag_dbg(\"Cannot reassemble packet, no tree supplied!\\n\");\n        return -1;\n    }\n\n    first = pico_tree_first(tree);\n\n    if (!first)\n    {\n        frag_dbg(\"Cannot reassemble packet, empty tree supplied!\\n\");\n        return -2;\n    }\n\n    header_length = pico_fragments_get_header_length(net);\n\n    if (!header_length)\n    {\n        return -3;\n    }\n\n    full = pico_frame_alloc((uint16_t)(header_length + len));\n    if (full) {\n        full->net_hdr = full->buffer;\n        full->net_len = header_length;\n        memcpy(full->net_hdr, first->net_hdr, full->net_len);\n        full->transport_hdr = full->net_hdr + full->net_len;\n        full->transport_len = (uint16_t)len;\n        full->dev = first->dev;\n        pico_tree_foreach_safe(index, tree, tmp) {\n            f = index->keyValue;\n            memcpy(full->transport_hdr + bookmark, f->transport_hdr, f->transport_len);\n            bookmark += f->transport_len;\n            pico_tree_delete(tree, f);\n            pico_frame_discard(f);\n        }\n        if (pico_transport_receive(full, proto) == -1)\n        {\n            pico_frame_discard(full);\n        }\n        return 0;\n    }\n\n    return 1;\n}",
        "func": "static int pico_fragments_reassemble(struct pico_tree *tree, unsigned int len, uint8_t proto, uint8_t net)\n{\n    struct pico_tree_node *index, *tmp;\n    struct pico_frame *f;\n    uint16_t header_length = 0;\n    unsigned int bookmark = 0;\n    struct pico_frame *full = NULL;\n    struct pico_frame *first = NULL;\n\n    if (!tree)\n    {\n        frag_dbg(\"Cannot reassemble packet, no tree supplied!\\n\");\n        return -1;\n    }\n\n    first = pico_tree_first(tree);\n\n    if (!first)\n    {\n        frag_dbg(\"Cannot reassemble packet, empty tree supplied!\\n\");\n        return -2;\n    }\n\n    header_length = pico_fragments_get_header_length(net);\n\n    if (!header_length)\n    {\n        return -3;\n    }\n\n    full = pico_frame_alloc((uint16_t)(header_length + len));\n    if (full) {\n        full->net_hdr = full->buffer;\n        full->net_len = header_length;\n        memcpy(full->net_hdr, first->net_hdr, full->net_len);\n        full->transport_hdr = full->net_hdr + full->net_len;\n        full->transport_len = (uint16_t)len;\n        full->dev = first->dev;\n        pico_tree_foreach_safe(index, tree, tmp) {\n            f = index->keyValue;\n            memcpy(full->transport_hdr + bookmark, f->transport_hdr, f->transport_len);\n            bookmark += f->transport_len;\n            pico_tree_delete(tree, f);\n            pico_frame_discard(f);\n        }\n        pico_transport_receive(full, proto);\n        return 0;\n    }\n    return 1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -43,12 +43,8 @@\n             pico_tree_delete(tree, f);\n             pico_frame_discard(f);\n         }\n-        if (pico_transport_receive(full, proto) == -1)\n-        {\n-            pico_frame_discard(full);\n-        }\n+        pico_transport_receive(full, proto);\n         return 0;\n     }\n-\n     return 1;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "        if (pico_transport_receive(full, proto) == -1)",
                "        {",
                "            pico_frame_discard(full);",
                "        }",
                ""
            ],
            "added_lines": [
                "        pico_transport_receive(full, proto);"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-26545",
        "func_name": "torvalds/linux/mpls_dev_sysctl_register",
        "description": "In the Linux kernel before 6.1.13, there is a double free in net/mpls/af_mpls.c upon an allocation failure (for registering the sysctl table under a new location) during the renaming of a device.",
        "git_url": "https://github.com/torvalds/linux/commit/fda6c89fe3d9aca073495a664e1d5aea28cd4377",
        "commit_title": "net: mpls: fix stale pointer if allocation fails during device rename",
        "commit_text": " lianhui reports that when MPLS fails to register the sysctl table under new location (during device rename) the old pointers won't get overwritten and may be freed again (double free).  Handle this gracefully. The best option would be unregistering the MPLS from the device completely on failure, but unfortunately mpls_ifdown() can fail. So failing fully is also unreliable.  Another option is to register the new table first then only remove old one if the new one succeeds. That requires more code, changes order of notifications and two tables may be visible at the same time.  sysctl point is not used in the rest of the code - set to NULL on failures and skip unregister if already NULL. ",
        "func_before": "static int mpls_dev_sysctl_register(struct net_device *dev,\n\t\t\t\t    struct mpls_dev *mdev)\n{\n\tchar path[sizeof(\"net/mpls/conf/\") + IFNAMSIZ];\n\tstruct net *net = dev_net(dev);\n\tstruct ctl_table *table;\n\tint i;\n\n\ttable = kmemdup(&mpls_dev_table, sizeof(mpls_dev_table), GFP_KERNEL);\n\tif (!table)\n\t\tgoto out;\n\n\t/* Table data contains only offsets relative to the base of\n\t * the mdev at this point, so make them absolute.\n\t */\n\tfor (i = 0; i < ARRAY_SIZE(mpls_dev_table); i++) {\n\t\ttable[i].data = (char *)mdev + (uintptr_t)table[i].data;\n\t\ttable[i].extra1 = mdev;\n\t\ttable[i].extra2 = net;\n\t}\n\n\tsnprintf(path, sizeof(path), \"net/mpls/conf/%s\", dev->name);\n\n\tmdev->sysctl = register_net_sysctl(net, path, table);\n\tif (!mdev->sysctl)\n\t\tgoto free;\n\n\tmpls_netconf_notify_devconf(net, RTM_NEWNETCONF, NETCONFA_ALL, mdev);\n\treturn 0;\n\nfree:\n\tkfree(table);\nout:\n\treturn -ENOBUFS;\n}",
        "func": "static int mpls_dev_sysctl_register(struct net_device *dev,\n\t\t\t\t    struct mpls_dev *mdev)\n{\n\tchar path[sizeof(\"net/mpls/conf/\") + IFNAMSIZ];\n\tstruct net *net = dev_net(dev);\n\tstruct ctl_table *table;\n\tint i;\n\n\ttable = kmemdup(&mpls_dev_table, sizeof(mpls_dev_table), GFP_KERNEL);\n\tif (!table)\n\t\tgoto out;\n\n\t/* Table data contains only offsets relative to the base of\n\t * the mdev at this point, so make them absolute.\n\t */\n\tfor (i = 0; i < ARRAY_SIZE(mpls_dev_table); i++) {\n\t\ttable[i].data = (char *)mdev + (uintptr_t)table[i].data;\n\t\ttable[i].extra1 = mdev;\n\t\ttable[i].extra2 = net;\n\t}\n\n\tsnprintf(path, sizeof(path), \"net/mpls/conf/%s\", dev->name);\n\n\tmdev->sysctl = register_net_sysctl(net, path, table);\n\tif (!mdev->sysctl)\n\t\tgoto free;\n\n\tmpls_netconf_notify_devconf(net, RTM_NEWNETCONF, NETCONFA_ALL, mdev);\n\treturn 0;\n\nfree:\n\tkfree(table);\nout:\n\tmdev->sysctl = NULL;\n\treturn -ENOBUFS;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -31,5 +31,6 @@\n free:\n \tkfree(table);\n out:\n+\tmdev->sysctl = NULL;\n \treturn -ENOBUFS;\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tmdev->sysctl = NULL;"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-26545",
        "func_name": "torvalds/linux/mpls_dev_sysctl_unregister",
        "description": "In the Linux kernel before 6.1.13, there is a double free in net/mpls/af_mpls.c upon an allocation failure (for registering the sysctl table under a new location) during the renaming of a device.",
        "git_url": "https://github.com/torvalds/linux/commit/fda6c89fe3d9aca073495a664e1d5aea28cd4377",
        "commit_title": "net: mpls: fix stale pointer if allocation fails during device rename",
        "commit_text": " lianhui reports that when MPLS fails to register the sysctl table under new location (during device rename) the old pointers won't get overwritten and may be freed again (double free).  Handle this gracefully. The best option would be unregistering the MPLS from the device completely on failure, but unfortunately mpls_ifdown() can fail. So failing fully is also unreliable.  Another option is to register the new table first then only remove old one if the new one succeeds. That requires more code, changes order of notifications and two tables may be visible at the same time.  sysctl point is not used in the rest of the code - set to NULL on failures and skip unregister if already NULL. ",
        "func_before": "static void mpls_dev_sysctl_unregister(struct net_device *dev,\n\t\t\t\t       struct mpls_dev *mdev)\n{\n\tstruct net *net = dev_net(dev);\n\tstruct ctl_table *table;\n\n\ttable = mdev->sysctl->ctl_table_arg;\n\tunregister_net_sysctl_table(mdev->sysctl);\n\tkfree(table);\n\n\tmpls_netconf_notify_devconf(net, RTM_DELNETCONF, 0, mdev);\n}",
        "func": "static void mpls_dev_sysctl_unregister(struct net_device *dev,\n\t\t\t\t       struct mpls_dev *mdev)\n{\n\tstruct net *net = dev_net(dev);\n\tstruct ctl_table *table;\n\n\tif (!mdev->sysctl)\n\t\treturn;\n\n\ttable = mdev->sysctl->ctl_table_arg;\n\tunregister_net_sysctl_table(mdev->sysctl);\n\tkfree(table);\n\n\tmpls_netconf_notify_devconf(net, RTM_DELNETCONF, 0, mdev);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,6 +3,9 @@\n {\n \tstruct net *net = dev_net(dev);\n \tstruct ctl_table *table;\n+\n+\tif (!mdev->sysctl)\n+\t\treturn;\n \n \ttable = mdev->sysctl->ctl_table_arg;\n \tunregister_net_sysctl_table(mdev->sysctl);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "\tif (!mdev->sysctl)",
                "\t\treturn;"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-23191",
        "func_name": "michaelrsweet/htmldoc/image_load_jpeg",
        "description": "A security issue was found in htmldoc v1.9.12 and before. A NULL pointer dereference in the function image_load_jpeg() in image.cxx may result in denial of service.",
        "git_url": "https://github.com/michaelrsweet/htmldoc/commit/369b2ea1fd0d0537ba707f20a2f047b6afd2fbdc",
        "commit_title": "Fix JPEG error handling (Issue #415)",
        "commit_text": "",
        "func_before": "static int\t\t\t/* O - 0 = success, -1 = fail */\nimage_load_jpeg(image_t *img,\t/* I - Image pointer */\n                FILE    *fp,\t/* I - File to load from */\n                int     gray,\t/* I - 0 = color, 1 = grayscale */\n                int     load_data)/* I - 1 = load image data, 0 = just info */\n{\n  struct jpeg_decompress_struct\tcinfo;\t\t/* Decompressor info */\n  struct jpeg_error_mgr\t\tjerr;\t\t/* Error handler info */\n  JSAMPROW\t\t\trow;\t\t/* Sample row pointer */\n\n\n  jpeg_std_error(&jerr);\n  jerr.error_exit = jpeg_error_handler;\n\n  cinfo.err = &jerr;\n  jpeg_create_decompress(&cinfo);\n  jpeg_stdio_src(&cinfo, fp);\n  jpeg_read_header(&cinfo, (boolean)1);\n\n  cinfo.quantize_colors = FALSE;\n\n  if (gray || cinfo.num_components == 1)\n  {\n    cinfo.out_color_space      = JCS_GRAYSCALE;\n    cinfo.out_color_components = 1;\n    cinfo.output_components    = 1;\n  }\n  else if (cinfo.num_components != 3)\n  {\n    jpeg_destroy_decompress(&cinfo);\n\n    progress_error(HD_ERROR_BAD_FORMAT,\n                   \"CMYK JPEG files are not supported! (%s)\",\n\t\t   file_rlookup(img->filename));\n    return (-1);\n  }\n  else\n  {\n    cinfo.out_color_space      = JCS_RGB;\n    cinfo.out_color_components = 3;\n    cinfo.output_components    = 3;\n  }\n\n  jpeg_calc_output_dimensions(&cinfo);\n\n  img->width  = (int)cinfo.output_width;\n  img->height = (int)cinfo.output_height;\n  img->depth  = (int)cinfo.output_components;\n\n  if (!load_data)\n  {\n    jpeg_destroy_decompress(&cinfo);\n    return (0);\n  }\n\n  img->pixels = (uchar *)malloc((size_t)(img->width * img->height * img->depth));\n\n  if (img->pixels == NULL)\n  {\n    jpeg_destroy_decompress(&cinfo);\n    return (-1);\n  }\n\n  jpeg_start_decompress(&cinfo);\n\n  while (cinfo.output_scanline < cinfo.output_height)\n  {\n    row = (JSAMPROW)(img->pixels + (size_t)cinfo.output_scanline * (size_t)cinfo.output_width * (size_t)cinfo.output_components);\n    jpeg_read_scanlines(&cinfo, &row, (JDIMENSION)1);\n  }\n\n  jpeg_finish_decompress(&cinfo);\n  jpeg_destroy_decompress(&cinfo);\n\n  return (0);\n}",
        "func": "static int\t\t\t/* O - 0 = success, -1 = fail */\nimage_load_jpeg(image_t *img,\t/* I - Image pointer */\n                FILE    *fp,\t/* I - File to load from */\n                int     gray,\t/* I - 0 = color, 1 = grayscale */\n                int     load_data)/* I - 1 = load image data, 0 = just info */\n{\n  struct jpeg_decompress_struct\tcinfo;\t\t/* Decompressor info */\n  hd_jpeg_err_t\t\t\tjerr;\t\t// JPEG error handler\nJSAMPROW\t\t\trow;\t\t/* Sample row pointer */\n\n\n  jpeg_std_error(&jerr.jerr);\n  jerr.jerr.error_exit = jpeg_error_handler;\n\n  if (setjmp(jerr.retbuf))\n  {\n    progress_error(HD_ERROR_BAD_FORMAT, \"%s (%s)\", jerr.message,  file_rlookup(img->filename));\n    jpeg_destroy_decompress(&cinfo);\n    return (-1);\n  }\n\n  cinfo.err = (struct jpeg_error_mgr *)&jerr;\n  jpeg_create_decompress(&cinfo);\n  jpeg_stdio_src(&cinfo, fp);\n  jpeg_read_header(&cinfo, (boolean)1);\n\n  cinfo.quantize_colors = FALSE;\n\n  if (gray || cinfo.num_components == 1)\n  {\n    cinfo.out_color_space      = JCS_GRAYSCALE;\n    cinfo.out_color_components = 1;\n    cinfo.output_components    = 1;\n  }\n  else if (cinfo.num_components != 3)\n  {\n    jpeg_destroy_decompress(&cinfo);\n\n    progress_error(HD_ERROR_BAD_FORMAT,\n                   \"CMYK JPEG files are not supported! (%s)\",\n\t\t   file_rlookup(img->filename));\n    return (-1);\n  }\n  else\n  {\n    cinfo.out_color_space      = JCS_RGB;\n    cinfo.out_color_components = 3;\n    cinfo.output_components    = 3;\n  }\n\n  jpeg_calc_output_dimensions(&cinfo);\n\n  img->width  = (int)cinfo.output_width;\n  img->height = (int)cinfo.output_height;\n  img->depth  = (int)cinfo.output_components;\n\n  if (!load_data)\n  {\n    jpeg_destroy_decompress(&cinfo);\n    return (0);\n  }\n\n  img->pixels = (uchar *)malloc((size_t)(img->width * img->height * img->depth));\n\n  if (img->pixels == NULL)\n  {\n    jpeg_destroy_decompress(&cinfo);\n    return (-1);\n  }\n\n  jpeg_start_decompress(&cinfo);\n\n  while (cinfo.output_scanline < cinfo.output_height)\n  {\n    row = (JSAMPROW)(img->pixels + (size_t)cinfo.output_scanline * (size_t)cinfo.output_width * (size_t)cinfo.output_components);\n    jpeg_read_scanlines(&cinfo, &row, (JDIMENSION)1);\n  }\n\n  jpeg_finish_decompress(&cinfo);\n  jpeg_destroy_decompress(&cinfo);\n\n  return (0);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,14 +5,21 @@\n                 int     load_data)/* I - 1 = load image data, 0 = just info */\n {\n   struct jpeg_decompress_struct\tcinfo;\t\t/* Decompressor info */\n-  struct jpeg_error_mgr\t\tjerr;\t\t/* Error handler info */\n-  JSAMPROW\t\t\trow;\t\t/* Sample row pointer */\n+  hd_jpeg_err_t\t\t\tjerr;\t\t// JPEG error handler\n+JSAMPROW\t\t\trow;\t\t/* Sample row pointer */\n \n \n-  jpeg_std_error(&jerr);\n-  jerr.error_exit = jpeg_error_handler;\n+  jpeg_std_error(&jerr.jerr);\n+  jerr.jerr.error_exit = jpeg_error_handler;\n \n-  cinfo.err = &jerr;\n+  if (setjmp(jerr.retbuf))\n+  {\n+    progress_error(HD_ERROR_BAD_FORMAT, \"%s (%s)\", jerr.message,  file_rlookup(img->filename));\n+    jpeg_destroy_decompress(&cinfo);\n+    return (-1);\n+  }\n+\n+  cinfo.err = (struct jpeg_error_mgr *)&jerr;\n   jpeg_create_decompress(&cinfo);\n   jpeg_stdio_src(&cinfo, fp);\n   jpeg_read_header(&cinfo, (boolean)1);",
        "diff_line_info": {
            "deleted_lines": [
                "  struct jpeg_error_mgr\t\tjerr;\t\t/* Error handler info */",
                "  JSAMPROW\t\t\trow;\t\t/* Sample row pointer */",
                "  jpeg_std_error(&jerr);",
                "  jerr.error_exit = jpeg_error_handler;",
                "  cinfo.err = &jerr;"
            ],
            "added_lines": [
                "  hd_jpeg_err_t\t\t\tjerr;\t\t// JPEG error handler",
                "JSAMPROW\t\t\trow;\t\t/* Sample row pointer */",
                "  jpeg_std_error(&jerr.jerr);",
                "  jerr.jerr.error_exit = jpeg_error_handler;",
                "  if (setjmp(jerr.retbuf))",
                "  {",
                "    progress_error(HD_ERROR_BAD_FORMAT, \"%s (%s)\", jerr.message,  file_rlookup(img->filename));",
                "    jpeg_destroy_decompress(&cinfo);",
                "    return (-1);",
                "  }",
                "",
                "  cinfo.err = (struct jpeg_error_mgr *)&jerr;"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-23191",
        "func_name": "michaelrsweet/htmldoc/jpeg_error_handler",
        "description": "A security issue was found in htmldoc v1.9.12 and before. A NULL pointer dereference in the function image_load_jpeg() in image.cxx may result in denial of service.",
        "git_url": "https://github.com/michaelrsweet/htmldoc/commit/369b2ea1fd0d0537ba707f20a2f047b6afd2fbdc",
        "commit_title": "Fix JPEG error handling (Issue #415)",
        "commit_text": "",
        "func_before": "static void\njpeg_error_handler(j_common_ptr)\n{\n  return;\n}",
        "func": "static void\njpeg_error_handler(j_common_ptr p)\t// Common JPEG data\n{\n  hd_jpeg_err_t\t*jerr = (hd_jpeg_err_t *)p->err;\n\t\t\t\t\t// JPEG error handler\n\n\n  // Save the error message in the string buffer...\n  (jerr->jerr.format_message)(p, jerr->message);\n\n  // Return to the point we called setjmp()...\n  longjmp(jerr->retbuf, 1);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,13 @@\n static void\n-jpeg_error_handler(j_common_ptr)\n+jpeg_error_handler(j_common_ptr p)\t// Common JPEG data\n {\n-  return;\n+  hd_jpeg_err_t\t*jerr = (hd_jpeg_err_t *)p->err;\n+\t\t\t\t\t// JPEG error handler\n+\n+\n+  // Save the error message in the string buffer...\n+  (jerr->jerr.format_message)(p, jerr->message);\n+\n+  // Return to the point we called setjmp()...\n+  longjmp(jerr->retbuf, 1);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "jpeg_error_handler(j_common_ptr)",
                "  return;"
            ],
            "added_lines": [
                "jpeg_error_handler(j_common_ptr p)\t// Common JPEG data",
                "  hd_jpeg_err_t\t*jerr = (hd_jpeg_err_t *)p->err;",
                "\t\t\t\t\t// JPEG error handler",
                "",
                "",
                "  // Save the error message in the string buffer...",
                "  (jerr->jerr.format_message)(p, jerr->message);",
                "",
                "  // Return to the point we called setjmp()...",
                "  longjmp(jerr->retbuf, 1);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-23191",
        "func_name": "michaelrsweet/htmldoc/write_trailer",
        "description": "A security issue was found in htmldoc v1.9.12 and before. A NULL pointer dereference in the function image_load_jpeg() in image.cxx may result in denial of service.",
        "git_url": "https://github.com/michaelrsweet/htmldoc/commit/369b2ea1fd0d0537ba707f20a2f047b6afd2fbdc",
        "commit_title": "Fix JPEG error handling (Issue #415)",
        "commit_text": "",
        "func_before": "static void\nwrite_trailer(FILE  *out,\t\t/* I - Output file */\n              int   num_file_pages,\t/* I - Number of pages in file */\n\t      uchar *lang)\t\t/* I - Language */\n{\n  int\t\ti, j, k,\t\t/* Looping vars */\n\t\ttype,\t\t\t/* Type of number */\n\t\toffset,\t\t\t/* Offset to xref table in PDF file */\n\t\tstart;\t\t\t/* Start page number */\n  page_t\t*page;\t\t\t/* Start page of chapter */\n  char\t\tprefix[64],\t\t/* Prefix string */\n\t\t*prefptr;\t\t/* Pointer into prefix string */\n  static const char *modes[] =\t\t/* Page modes */\n\t\t{\n\t\t  \"UseNone\",\n\t\t  \"UseOutlines\",\n\t\t  \"FullScreen\"\n\t\t};\n  static const char *layouts[] =\t/* Page layouts */\n\t\t{\n\t\t  \"SinglePage\",\n\t\t  \"OneColumn\",\n\t\t  \"TwoColumnLeft\",\n\t\t  \"TwoColumnRight\"\n\t\t};\n\n\n  if (PSLevel > 0)\n  {\n   /*\n    * PostScript...\n    */\n\n    fputs(\"%%Trailer\\n\", out);\n    if (num_file_pages > 0)\n      fprintf(out, \"%%%%Pages: %d\\n\", num_file_pages);\n\n    fputs(\"%%EOF\\n\", out);\n  }\n  else\n  {\n   /*\n    * PDF...\n    */\n\n    root_object = pdf_start_object(out);\n\n    fputs(\"/Type/Catalog\", out);\n    fprintf(out, \"/Pages %d 0 R\", pages_object);\n\n    if (PDFVersion >= 12)\n    {\n      if (names_object)\n        fprintf(out, \"/Names %d 0 R\", names_object);\n\n      fprintf(out, \"/PageLayout/%s\", layouts[PDFPageLayout]);\n    }\n\n    if (lang)\n      fprintf(out, \"/Lang(%s)\", (char *)lang);\n\n    if (outline_object > 0)\n      fprintf(out, \"/Outlines %d 0 R\", outline_object);\n\n    switch (PDFFirstPage)\n    {\n      case PDF_PAGE_1 :\n          if (TitlePage)\n\t  {\n            fprintf(out, \"/OpenAction[%d 0 R/XYZ null null 0]\",\n                    pages_object + 1);\n            break;\n\t  }\n          break;\n      case PDF_TOC :\n          if (TocLevels > 0)\n\t  {\n            fprintf(out, \"/OpenAction[%d 0 R/XYZ null null 0]\",\n                    pages_object + 2 * chapter_outstarts[0] + 1);\n\t    break;\n\t  }\n          break;\n      case PDF_CHAPTER_1 :\n          fprintf(out, \"/OpenAction[%d 0 R/XYZ null null 0]\",\n                  pages_object + 2 * chapter_outstarts[1] + 1);\n          break;\n    }\n\n    fprintf(out, \"/PageMode/%s\", modes[PDFPageMode]);\n\n    if (PDFVersion > 12 && NumberUp == 1)\n    {\n      // Output the PageLabels tree...\n      fputs(\"/PageLabels<</Nums[\", out);\n\n      for (i = 0; i < chapter_starts[1]; i ++)\n      {\n        fprintf(out, \"%d<</P\", i);\n        if (i & 1)\n\t  write_string(out, (uchar *)\"eltit\", 0);\n\telse\n\t  write_string(out, (uchar *)\"title\", 0);\n\tfputs(\">>\", out);\n      }\n\n      if (TocLevels > 0 && OutputType == OUTPUT_BOOK)\n      {\n        type = 'r';\n\n        for (j = 0; j < 3; j ++)\n\t  if ((TocHeader[j] && strstr(TocHeader[j], \"$PAGE(1)\")) ||\n\t      (TocFooter[j] && strstr(TocFooter[j], \"$PAGE(1)\")))\n\t    type = 'D';\n\t  else if ((TocHeader[j] && strstr(TocHeader[j], \"$PAGE(I)\")) ||\n\t           (TocFooter[j] && strstr(TocFooter[j], \"$PAGE(I)\")))\n\t    type = 'R';\n\t  else if ((TocHeader[j] && strstr(TocHeader[j], \"$PAGE(a)\")) ||\n\t           (TocFooter[j] && strstr(TocFooter[j], \"$PAGE(a)\")))\n\t    type = 'a';\n\t  else if ((TocHeader[j] && strstr(TocHeader[j], \"$PAGE(A)\")) ||\n\t           (TocFooter[j] && strstr(TocFooter[j], \"$PAGE(A)\")))\n\t    type = 'A';\n\n        fprintf(out, \"%d<</S/%c>>\", i, type);\n\n        i += chapter_ends[0] - chapter_starts[0] + 1;\n      }\n\n      for (j = 1; j <= TocDocCount; j ++)\n      {\n        page  = pages + chapter_starts[j];\n\tstart = chapter_starts[j] - chapter_starts[1] + 1;\n\ttype  = 'D';\n\n        prefix[0] = '\\0';\n\n\tfor (k = 0; k < 3; k ++)\n\t{\n\t  if (page->header[k] && strstr((char *)page->header[k], \"PAGE\"))\n\t    strlcpy(prefix, (char *)page->header[k], sizeof(prefix));\n\t  else if (page->footer[k] && strstr((char *)page->footer[k], \"PAGE\"))\n\t    strlcpy(prefix, (char *)page->footer[k], sizeof(prefix));\n\n\t  if ((page->header[k] && strstr((char *)page->header[k], \"PAGE(i)\")) ||\n\t      (page->footer[k] && strstr((char *)page->footer[k], \"PAGE(i)\")))\n\t    type = 'r';\n\t  else if ((page->header[k] && strstr((char *)page->header[k], \"PAGE(I)\")) ||\n\t           (page->footer[k] && strstr((char *)page->footer[k], \"PAGE(I)\")))\n\t    type = 'R';\n\t  else if ((page->header[k] && strstr((char *)page->header[k], \"PAGE(a)\")) ||\n\t           (page->footer[k] && strstr((char *)page->footer[k], \"PAGE(a)\")))\n\t    type = 'a';\n\t  else if ((page->header[k] && strstr((char *)page->header[k], \"PAGE(A)\")) ||\n\t           (page->footer[k] && strstr((char *)page->footer[k], \"PAGE(A)\")))\n\t    type = 'A';\n\n\t  if ((page->header[k] && strstr((char *)page->header[k], \"$CHAPTERPAGE\")) ||\n\t      (page->footer[k] && strstr((char *)page->footer[k], \"$CHAPTERPAGE\")))\n\t    start = 1;\n        }\n\n        if ((prefptr = strstr(prefix, \"$PAGE\")) == NULL)\n\t  prefptr = strstr(prefix, \"$CHAPTERPAGE\");\n\tfprintf(out, \"%d<</S/%c/St %d\", i, type, start);\n\tif (prefptr)\n\t{\n\t  *prefptr = '\\0';\n\t  fputs(\"/P\", out);\n\t  write_string(out, (uchar *)prefix, 0);\n\t}\n\tfputs(\">>\", out);\n\n        i += chapter_ends[j] - chapter_starts[j] + 1;\n      }\n\n      fputs(\"]>>\", out);\n    }\n\n    pdf_end_object(out);\n\n    offset = ftell(out);\n\n    fputs(\"xref\\n\", out);\n    fprintf(out, \"0 %d \\n\", (int)num_objects + 1);\n    fputs(\"0000000000 65535 f \\n\", out);\n    for (i = 1; i <= (int)num_objects; i ++)\n      fprintf(out, \"%010d 00000 n \\n\", objects[i]);\n\n    fputs(\"trailer\\n\", out);\n    fputs(\"<<\", out);\n    fprintf(out, \"/Size %d\", (int)num_objects + 1);\n    fprintf(out, \"/Root %d 0 R\", root_object);\n    fprintf(out, \"/Info %d 0 R\", info_object);\n    fputs(\"/ID[<\", out);\n    for (i = 0; i < 16; i ++)\n      fprintf(out, \"%02x\", file_id[i]);\n    fputs(\"><\", out);\n    for (i = 0; i < 16; i ++)\n      fprintf(out, \"%02x\", file_id[i]);\n    fputs(\">]\", out);\n\n    if (Encryption)\n      fprintf(out, \"/Encrypt %d 0 R\", encrypt_object);\n\n    fputs(\">>\\n\", out);\n    fputs(\"startxref\\n\", out);\n    fprintf(out, \"%d\\n\", offset);\n    fputs(\"%%EOF\\n\", out);\n  }\n}",
        "func": "static void\nwrite_trailer(FILE  *out,\t\t/* I - Output file */\n              int   num_file_pages,\t/* I - Number of pages in file */\n\t      uchar *lang)\t\t/* I - Language */\n{\n  int\t\ti, j, k,\t\t/* Looping vars */\n\t\ttype,\t\t\t/* Type of number */\n\t\toffset,\t\t\t/* Offset to xref table in PDF file */\n\t\tstart;\t\t\t/* Start page number */\n  page_t\t*page;\t\t\t/* Start page of chapter */\n  char\t\tprefix[64],\t\t/* Prefix string */\n\t\t*prefptr;\t\t/* Pointer into prefix string */\n  static const char *modes[] =\t\t/* Page modes */\n\t\t{\n\t\t  \"UseNone\",\n\t\t  \"UseOutlines\",\n\t\t  \"FullScreen\"\n\t\t};\n  static const char *layouts[] =\t/* Page layouts */\n\t\t{\n\t\t  \"SinglePage\",\n\t\t  \"OneColumn\",\n\t\t  \"TwoColumnLeft\",\n\t\t  \"TwoColumnRight\"\n\t\t};\n\n\n  if (PSLevel > 0)\n  {\n   /*\n    * PostScript...\n    */\n\n    fputs(\"%%Trailer\\n\", out);\n    if (num_file_pages > 0)\n      fprintf(out, \"%%%%Pages: %d\\n\", num_file_pages);\n\n    fputs(\"%%EOF\\n\", out);\n  }\n  else\n  {\n   /*\n    * PDF...\n    */\n\n    root_object = pdf_start_object(out);\n\n    fputs(\"/Type/Catalog\", out);\n    fprintf(out, \"/Pages %d 0 R\", pages_object);\n\n    if (PDFVersion >= 12)\n    {\n      if (names_object)\n        fprintf(out, \"/Names %d 0 R\", names_object);\n\n      fprintf(out, \"/PageLayout/%s\", layouts[PDFPageLayout]);\n    }\n\n    if (lang)\n      fprintf(out, \"/Lang(%s)\", (char *)lang);\n\n    if (outline_object > 0)\n      fprintf(out, \"/Outlines %d 0 R\", outline_object);\n\n    switch (PDFFirstPage)\n    {\n      case PDF_PAGE_1 :\n          if (TitlePage)\n\t  {\n            fprintf(out, \"/OpenAction[%d 0 R/XYZ null null 0]\",\n                    pages_object + 1);\n            break;\n\t  }\n          break;\n      case PDF_TOC :\n          if (TocLevels > 0)\n\t  {\n            fprintf(out, \"/OpenAction[%d 0 R/XYZ null null 0]\",\n                    pages_object + 2 * chapter_outstarts[0] + 1);\n\t    break;\n\t  }\n          break;\n      case PDF_CHAPTER_1 :\n          fprintf(out, \"/OpenAction[%d 0 R/XYZ null null 0]\",\n                  pages_object + 2 * chapter_outstarts[1] + 1);\n          break;\n    }\n\n    fprintf(out, \"/PageMode/%s\", modes[PDFPageMode]);\n\n    if (PDFVersion > 12 && NumberUp == 1)\n    {\n      // Output the PageLabels tree...\n      fputs(\"/PageLabels<</Nums[\", out);\n\n      for (i = 0; i < chapter_starts[1]; i ++)\n      {\n        fprintf(out, \"%d<</P\", i);\n        if (i & 1)\n\t  write_string(out, (uchar *)\"eltit\", 0);\n\telse\n\t  write_string(out, (uchar *)\"title\", 0);\n\tfputs(\">>\", out);\n      }\n\n      if (TocLevels > 0 && OutputType == OUTPUT_BOOK)\n      {\n        type = 'r';\n\n        for (j = 0; j < 3; j ++)\n\t  if ((TocHeader[j] && strstr(TocHeader[j], \"$PAGE(1)\")) ||\n\t      (TocFooter[j] && strstr(TocFooter[j], \"$PAGE(1)\")))\n\t    type = 'D';\n\t  else if ((TocHeader[j] && strstr(TocHeader[j], \"$PAGE(I)\")) ||\n\t           (TocFooter[j] && strstr(TocFooter[j], \"$PAGE(I)\")))\n\t    type = 'R';\n\t  else if ((TocHeader[j] && strstr(TocHeader[j], \"$PAGE(a)\")) ||\n\t           (TocFooter[j] && strstr(TocFooter[j], \"$PAGE(a)\")))\n\t    type = 'a';\n\t  else if ((TocHeader[j] && strstr(TocHeader[j], \"$PAGE(A)\")) ||\n\t           (TocFooter[j] && strstr(TocFooter[j], \"$PAGE(A)\")))\n\t    type = 'A';\n\n        fprintf(out, \"%d<</S/%c>>\", i, type);\n\n        i += chapter_ends[0] - chapter_starts[0] + 1;\n      }\n\n      for (j = 1; j <= TocDocCount; j ++)\n      {\n        if (chapter_starts[j] < 0)\n          continue;\n\n        page  = pages + chapter_starts[j];\n\tstart = chapter_starts[j] - chapter_starts[1] + 1;\n\ttype  = 'D';\n\n        prefix[0] = '\\0';\n\n\tfor (k = 0; k < 3; k ++)\n\t{\n\t  if (page->header[k] && strstr((char *)page->header[k], \"PAGE\"))\n\t    strlcpy(prefix, (char *)page->header[k], sizeof(prefix));\n\t  else if (page->footer[k] && strstr((char *)page->footer[k], \"PAGE\"))\n\t    strlcpy(prefix, (char *)page->footer[k], sizeof(prefix));\n\n\t  if ((page->header[k] && strstr((char *)page->header[k], \"PAGE(i)\")) ||\n\t      (page->footer[k] && strstr((char *)page->footer[k], \"PAGE(i)\")))\n\t    type = 'r';\n\t  else if ((page->header[k] && strstr((char *)page->header[k], \"PAGE(I)\")) ||\n\t           (page->footer[k] && strstr((char *)page->footer[k], \"PAGE(I)\")))\n\t    type = 'R';\n\t  else if ((page->header[k] && strstr((char *)page->header[k], \"PAGE(a)\")) ||\n\t           (page->footer[k] && strstr((char *)page->footer[k], \"PAGE(a)\")))\n\t    type = 'a';\n\t  else if ((page->header[k] && strstr((char *)page->header[k], \"PAGE(A)\")) ||\n\t           (page->footer[k] && strstr((char *)page->footer[k], \"PAGE(A)\")))\n\t    type = 'A';\n\n\t  if ((page->header[k] && strstr((char *)page->header[k], \"$CHAPTERPAGE\")) ||\n\t      (page->footer[k] && strstr((char *)page->footer[k], \"$CHAPTERPAGE\")))\n\t    start = 1;\n        }\n\n        if ((prefptr = strstr(prefix, \"$PAGE\")) == NULL)\n\t  prefptr = strstr(prefix, \"$CHAPTERPAGE\");\n\tfprintf(out, \"%d<</S/%c/St %d\", i, type, start);\n\tif (prefptr)\n\t{\n\t  *prefptr = '\\0';\n\t  fputs(\"/P\", out);\n\t  write_string(out, (uchar *)prefix, 0);\n\t}\n\tfputs(\">>\", out);\n\n        i += chapter_ends[j] - chapter_starts[j] + 1;\n      }\n\n      fputs(\"]>>\", out);\n    }\n\n    pdf_end_object(out);\n\n    offset = ftell(out);\n\n    fputs(\"xref\\n\", out);\n    fprintf(out, \"0 %d \\n\", (int)num_objects + 1);\n    fputs(\"0000000000 65535 f \\n\", out);\n    for (i = 1; i <= (int)num_objects; i ++)\n      fprintf(out, \"%010d 00000 n \\n\", objects[i]);\n\n    fputs(\"trailer\\n\", out);\n    fputs(\"<<\", out);\n    fprintf(out, \"/Size %d\", (int)num_objects + 1);\n    fprintf(out, \"/Root %d 0 R\", root_object);\n    fprintf(out, \"/Info %d 0 R\", info_object);\n    fputs(\"/ID[<\", out);\n    for (i = 0; i < 16; i ++)\n      fprintf(out, \"%02x\", file_id[i]);\n    fputs(\"><\", out);\n    for (i = 0; i < 16; i ++)\n      fprintf(out, \"%02x\", file_id[i]);\n    fputs(\">]\", out);\n\n    if (Encryption)\n      fprintf(out, \"/Encrypt %d 0 R\", encrypt_object);\n\n    fputs(\">>\\n\", out);\n    fputs(\"startxref\\n\", out);\n    fprintf(out, \"%d\\n\", offset);\n    fputs(\"%%EOF\\n\", out);\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -128,6 +128,9 @@\n \n       for (j = 1; j <= TocDocCount; j ++)\n       {\n+        if (chapter_starts[j] < 0)\n+          continue;\n+\n         page  = pages + chapter_starts[j];\n \tstart = chapter_starts[j] - chapter_starts[1] + 1;\n \ttype  = 'D';",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "        if (chapter_starts[j] < 0)",
                "          continue;",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2021-23191",
        "func_name": "michaelrsweet/htmldoc/pspdf_prepare_page",
        "description": "A security issue was found in htmldoc v1.9.12 and before. A NULL pointer dereference in the function image_load_jpeg() in image.cxx may result in denial of service.",
        "git_url": "https://github.com/michaelrsweet/htmldoc/commit/369b2ea1fd0d0537ba707f20a2f047b6afd2fbdc",
        "commit_title": "Fix JPEG error handling (Issue #415)",
        "commit_text": "",
        "func_before": "static void\npspdf_prepare_page(int page)\t\t/* I - Page number */\n{\n  int\tprint_page;\t\t\t/* Printed page # */\n  char\tpage_text[64];\t\t\t/* Page number text */\n  int\ttop;\t\t\t\t/* Top of page */\n\n\n  DEBUG_printf((\"pspdf_prepare_page(%d)\\n\", page));\n\n /*\n  * Make a page number; use roman numerals for the table of contents\n  * and arabic numbers for all others...\n  */\n\n  if (chapter == 0 && OutputType == OUTPUT_BOOK)\n  {\n    print_page = page - chapter_starts[0] + 1;\n    strlcpy(page_text, format_number(print_page, 'i'), sizeof(page_text));\n  }\n  else if (chapter < 0)\n  {\n    print_page = 0;\n    // Safe because page_text is more than 6 chars\n    strlcpy(page_text, (page & 1) ? (char *)\"eltit\" : (char *)\"title\", sizeof(page_text));\n  }\n  else\n  {\n    print_page = page - chapter_starts[1] + 1;\n    strlcpy(page_text, format_number(print_page, '1'), sizeof(page_text));\n  }\n\n  DEBUG_printf((\"BEFORE page %d page_text is \\\"%s\\\"...\\n\", page, page_text));\n\n  DEBUG_printf((\"    header[0] = \\\"%s\\\"\\n\", pages[page].header[0]));\n  DEBUG_printf((\"    header[1] = \\\"%s\\\"\\n\", pages[page].header[1]));\n  DEBUG_printf((\"    header[2] = \\\"%s\\\"\\n\", pages[page].header[2]));\n\n /*\n  * Add page headings...\n  */\n\n  if (pages[page].landscape)\n  {\n    PagePrintWidth  = pages[page].length - pages[page].right - pages[page].left;\n    PagePrintLength = pages[page].width - pages[page].top - pages[page].bottom;\n  }\n  else\n  {\n    PagePrintWidth  = pages[page].width - pages[page].right - pages[page].left;\n    PagePrintLength = pages[page].length - pages[page].top - pages[page].bottom;\n  }\n\n  top = (int)(PagePrintLength - HeadFootSize);\n\n  if (chapter == 0)\n  {\n   /*\n    * Add table-of-contents header & footer...\n    */\n\n    pspdf_prepare_heading(page, print_page, pages[page].header, top,\n                          page_text, sizeof(page_text));\n    pspdf_prepare_heading(page, print_page, pages[page].footer, 0,\n                          page_text, sizeof(page_text));\n  }\n  else if (chapter > 0 && !title_page)\n  {\n   /*\n    * Add chapter header & footer...\n    */\n\n    if (page > chapter_starts[chapter] || OutputType != OUTPUT_BOOK)\n      pspdf_prepare_heading(page, print_page, pages[page].header, top,\n                            page_text, sizeof(page_text));\n    else\n      pspdf_prepare_heading(page, print_page, pages[page].header1, top,\n                            page_text, sizeof(page_text));\n    pspdf_prepare_heading(page, print_page, pages[page].footer, 0,\n                          page_text, sizeof(page_text));\n  }\n\n /*\n  * Copy the page number for the TOC...\n  */\n\n  strlcpy(pages[page].page_text, page_text, sizeof(pages[page].page_text));\n\n  DEBUG_printf((\"AFTER page %d page_text is \\\"%s\\\"...\\n\", page, page_text));\n}",
        "func": "static void\npspdf_prepare_page(int page)\t\t/* I - Page number */\n{\n  int\tprint_page;\t\t\t/* Printed page # */\n  char\tpage_text[64];\t\t\t/* Page number text */\n  int\ttop;\t\t\t\t/* Top of page */\n\n\n  DEBUG_printf((\"pspdf_prepare_page(%d)\\n\", page));\n  if (page < 0 || page >= num_pages)\n    return;\n\n /*\n  * Make a page number; use roman numerals for the table of contents\n  * and arabic numbers for all others...\n  */\n\n  if (chapter == 0 && OutputType == OUTPUT_BOOK)\n  {\n    print_page = page - chapter_starts[0] + 1;\n    strlcpy(page_text, format_number(print_page, 'i'), sizeof(page_text));\n  }\n  else if (chapter < 0)\n  {\n    print_page = 0;\n    // Safe because page_text is more than 6 chars\n    strlcpy(page_text, (page & 1) ? (char *)\"eltit\" : (char *)\"title\", sizeof(page_text));\n  }\n  else\n  {\n    print_page = page - chapter_starts[1] + 1;\n    strlcpy(page_text, format_number(print_page, '1'), sizeof(page_text));\n  }\n\n  DEBUG_printf((\"BEFORE page %d page_text is \\\"%s\\\"...\\n\", page, page_text));\n\n  DEBUG_printf((\"    header[0] = \\\"%s\\\"\\n\", pages[page].header[0]));\n  DEBUG_printf((\"    header[1] = \\\"%s\\\"\\n\", pages[page].header[1]));\n  DEBUG_printf((\"    header[2] = \\\"%s\\\"\\n\", pages[page].header[2]));\n\n /*\n  * Add page headings...\n  */\n\n  if (pages[page].landscape)\n  {\n    PagePrintWidth  = pages[page].length - pages[page].right - pages[page].left;\n    PagePrintLength = pages[page].width - pages[page].top - pages[page].bottom;\n  }\n  else\n  {\n    PagePrintWidth  = pages[page].width - pages[page].right - pages[page].left;\n    PagePrintLength = pages[page].length - pages[page].top - pages[page].bottom;\n  }\n\n  top = (int)(PagePrintLength - HeadFootSize);\n\n  if (chapter == 0)\n  {\n   /*\n    * Add table-of-contents header & footer...\n    */\n\n    pspdf_prepare_heading(page, print_page, pages[page].header, top,\n                          page_text, sizeof(page_text));\n    pspdf_prepare_heading(page, print_page, pages[page].footer, 0,\n                          page_text, sizeof(page_text));\n  }\n  else if (chapter > 0 && !title_page)\n  {\n   /*\n    * Add chapter header & footer...\n    */\n\n    if (page > chapter_starts[chapter] || OutputType != OUTPUT_BOOK)\n      pspdf_prepare_heading(page, print_page, pages[page].header, top,\n                            page_text, sizeof(page_text));\n    else\n      pspdf_prepare_heading(page, print_page, pages[page].header1, top,\n                            page_text, sizeof(page_text));\n    pspdf_prepare_heading(page, print_page, pages[page].footer, 0,\n                          page_text, sizeof(page_text));\n  }\n\n /*\n  * Copy the page number for the TOC...\n  */\n\n  strlcpy(pages[page].page_text, page_text, sizeof(pages[page].page_text));\n\n  DEBUG_printf((\"AFTER page %d page_text is \\\"%s\\\"...\\n\", page, page_text));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -7,6 +7,8 @@\n \n \n   DEBUG_printf((\"pspdf_prepare_page(%d)\\n\", page));\n+  if (page < 0 || page >= num_pages)\n+    return;\n \n  /*\n   * Make a page number; use roman numerals for the table of contents",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "  if (page < 0 || page >= num_pages)",
                "    return;"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-23191",
        "func_name": "michaelrsweet/htmldoc/file_rlookup",
        "description": "A security issue was found in htmldoc v1.9.12 and before. A NULL pointer dereference in the function image_load_jpeg() in image.cxx may result in denial of service.",
        "git_url": "https://github.com/michaelrsweet/htmldoc/commit/369b2ea1fd0d0537ba707f20a2f047b6afd2fbdc",
        "commit_title": "Fix JPEG error handling (Issue #415)",
        "commit_text": "",
        "func_before": "const char *\t\t\t\t/* O - URL or filename */\nfile_rlookup(const char *filename)\t/* I - Filename */\n{\n  int\t\ti;\t\t\t/* Looping var */\n  cache_t\t*wc;\t\t\t/* Current cache file */\n\n\n  for (i = web_files, wc = web_cache; i > 0; i --, wc ++)\n    if (!strcmp(wc->name, filename))\n      return (wc->url);\n\n  return (filename);\n}",
        "func": "const char *\t\t\t\t/* O - URL or filename */\nfile_rlookup(const char *filename)\t/* I - Filename */\n{\n  int\t\ti;\t\t\t/* Looping var */\n  cache_t\t*wc;\t\t\t/* Current cache file */\n\n\n  for (i = web_files, wc = web_cache; i > 0; i --, wc ++)\n  {\n    if (!strcmp(wc->name, filename))\n    {\n      if (!strncmp(wc->url, \"data:\", 5))\n        return (\"data URL\");\n      else\n        return (wc->url);\n    }\n  }\n\n  return (filename);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,8 +6,15 @@\n \n \n   for (i = web_files, wc = web_cache; i > 0; i --, wc ++)\n+  {\n     if (!strcmp(wc->name, filename))\n-      return (wc->url);\n+    {\n+      if (!strncmp(wc->url, \"data:\", 5))\n+        return (\"data URL\");\n+      else\n+        return (wc->url);\n+    }\n+  }\n \n   return (filename);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "      return (wc->url);"
            ],
            "added_lines": [
                "  {",
                "    {",
                "      if (!strncmp(wc->url, \"data:\", 5))",
                "        return (\"data URL\");",
                "      else",
                "        return (wc->url);",
                "    }",
                "  }"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-28388",
        "func_name": "torvalds/linux/usb_8dev_start_xmit",
        "description": "usb_8dev_start_xmit in drivers/net/can/usb/usb_8dev.c in the Linux kernel through 5.17.1 has a double free.",
        "git_url": "https://github.com/torvalds/linux/commit/3d3925ff6433f98992685a9679613a2cc97f3ce2",
        "commit_title": "can: usb_8dev: usb_8dev_start_xmit(): fix double dev_kfree_skb() in error path",
        "commit_text": " There is no need to call dev_kfree_skb() when usb_submit_urb() fails because can_put_echo_skb() deletes original skb and can_free_echo_skb() deletes the cloned skb.  Link: https://lore.kernel.org/all/20220311080614.45229-1-hbh25y@gmail.com Cc: stable@vger.kernel.org",
        "func_before": "static netdev_tx_t usb_8dev_start_xmit(struct sk_buff *skb,\n\t\t\t\t      struct net_device *netdev)\n{\n\tstruct usb_8dev_priv *priv = netdev_priv(netdev);\n\tstruct net_device_stats *stats = &netdev->stats;\n\tstruct can_frame *cf = (struct can_frame *) skb->data;\n\tstruct usb_8dev_tx_msg *msg;\n\tstruct urb *urb;\n\tstruct usb_8dev_tx_urb_context *context = NULL;\n\tu8 *buf;\n\tint i, err;\n\tsize_t size = sizeof(struct usb_8dev_tx_msg);\n\n\tif (can_dropped_invalid_skb(netdev, skb))\n\t\treturn NETDEV_TX_OK;\n\n\t/* create a URB, and a buffer for it, and copy the data to the URB */\n\turb = usb_alloc_urb(0, GFP_ATOMIC);\n\tif (!urb)\n\t\tgoto nomem;\n\n\tbuf = usb_alloc_coherent(priv->udev, size, GFP_ATOMIC,\n\t\t\t\t &urb->transfer_dma);\n\tif (!buf) {\n\t\tnetdev_err(netdev, \"No memory left for USB buffer\\n\");\n\t\tgoto nomembuf;\n\t}\n\n\tmemset(buf, 0, size);\n\n\tmsg = (struct usb_8dev_tx_msg *)buf;\n\tmsg->begin = USB_8DEV_DATA_START;\n\tmsg->flags = 0x00;\n\n\tif (cf->can_id & CAN_RTR_FLAG)\n\t\tmsg->flags |= USB_8DEV_RTR;\n\n\tif (cf->can_id & CAN_EFF_FLAG)\n\t\tmsg->flags |= USB_8DEV_EXTID;\n\n\tmsg->id = cpu_to_be32(cf->can_id & CAN_ERR_MASK);\n\tmsg->dlc = can_get_cc_dlc(cf, priv->can.ctrlmode);\n\tmemcpy(msg->data, cf->data, cf->len);\n\tmsg->end = USB_8DEV_DATA_END;\n\n\tfor (i = 0; i < MAX_TX_URBS; i++) {\n\t\tif (priv->tx_contexts[i].echo_index == MAX_TX_URBS) {\n\t\t\tcontext = &priv->tx_contexts[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* May never happen! When this happens we'd more URBs in flight as\n\t * allowed (MAX_TX_URBS).\n\t */\n\tif (!context)\n\t\tgoto nofreecontext;\n\n\tcontext->priv = priv;\n\tcontext->echo_index = i;\n\n\tusb_fill_bulk_urb(urb, priv->udev,\n\t\t\t  usb_sndbulkpipe(priv->udev, USB_8DEV_ENDP_DATA_TX),\n\t\t\t  buf, size, usb_8dev_write_bulk_callback, context);\n\turb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\tusb_anchor_urb(urb, &priv->tx_submitted);\n\n\tcan_put_echo_skb(skb, netdev, context->echo_index, 0);\n\n\tatomic_inc(&priv->active_tx_urbs);\n\n\terr = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (unlikely(err))\n\t\tgoto failed;\n\telse if (atomic_read(&priv->active_tx_urbs) >= MAX_TX_URBS)\n\t\t/* Slow down tx path */\n\t\tnetif_stop_queue(netdev);\n\n\t/* Release our reference to this URB, the USB core will eventually free\n\t * it entirely.\n\t */\n\tusb_free_urb(urb);\n\n\treturn NETDEV_TX_OK;\n\nnofreecontext:\n\tusb_free_coherent(priv->udev, size, buf, urb->transfer_dma);\n\tusb_free_urb(urb);\n\n\tnetdev_warn(netdev, \"couldn't find free context\");\n\n\treturn NETDEV_TX_BUSY;\n\nfailed:\n\tcan_free_echo_skb(netdev, context->echo_index, NULL);\n\n\tusb_unanchor_urb(urb);\n\tusb_free_coherent(priv->udev, size, buf, urb->transfer_dma);\n\n\tatomic_dec(&priv->active_tx_urbs);\n\n\tif (err == -ENODEV)\n\t\tnetif_device_detach(netdev);\n\telse\n\t\tnetdev_warn(netdev, \"failed tx_urb %d\\n\", err);\n\nnomembuf:\n\tusb_free_urb(urb);\n\nnomem:\n\tdev_kfree_skb(skb);\n\tstats->tx_dropped++;\n\n\treturn NETDEV_TX_OK;\n}",
        "func": "static netdev_tx_t usb_8dev_start_xmit(struct sk_buff *skb,\n\t\t\t\t      struct net_device *netdev)\n{\n\tstruct usb_8dev_priv *priv = netdev_priv(netdev);\n\tstruct net_device_stats *stats = &netdev->stats;\n\tstruct can_frame *cf = (struct can_frame *) skb->data;\n\tstruct usb_8dev_tx_msg *msg;\n\tstruct urb *urb;\n\tstruct usb_8dev_tx_urb_context *context = NULL;\n\tu8 *buf;\n\tint i, err;\n\tsize_t size = sizeof(struct usb_8dev_tx_msg);\n\n\tif (can_dropped_invalid_skb(netdev, skb))\n\t\treturn NETDEV_TX_OK;\n\n\t/* create a URB, and a buffer for it, and copy the data to the URB */\n\turb = usb_alloc_urb(0, GFP_ATOMIC);\n\tif (!urb)\n\t\tgoto nomem;\n\n\tbuf = usb_alloc_coherent(priv->udev, size, GFP_ATOMIC,\n\t\t\t\t &urb->transfer_dma);\n\tif (!buf) {\n\t\tnetdev_err(netdev, \"No memory left for USB buffer\\n\");\n\t\tgoto nomembuf;\n\t}\n\n\tmemset(buf, 0, size);\n\n\tmsg = (struct usb_8dev_tx_msg *)buf;\n\tmsg->begin = USB_8DEV_DATA_START;\n\tmsg->flags = 0x00;\n\n\tif (cf->can_id & CAN_RTR_FLAG)\n\t\tmsg->flags |= USB_8DEV_RTR;\n\n\tif (cf->can_id & CAN_EFF_FLAG)\n\t\tmsg->flags |= USB_8DEV_EXTID;\n\n\tmsg->id = cpu_to_be32(cf->can_id & CAN_ERR_MASK);\n\tmsg->dlc = can_get_cc_dlc(cf, priv->can.ctrlmode);\n\tmemcpy(msg->data, cf->data, cf->len);\n\tmsg->end = USB_8DEV_DATA_END;\n\n\tfor (i = 0; i < MAX_TX_URBS; i++) {\n\t\tif (priv->tx_contexts[i].echo_index == MAX_TX_URBS) {\n\t\t\tcontext = &priv->tx_contexts[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* May never happen! When this happens we'd more URBs in flight as\n\t * allowed (MAX_TX_URBS).\n\t */\n\tif (!context)\n\t\tgoto nofreecontext;\n\n\tcontext->priv = priv;\n\tcontext->echo_index = i;\n\n\tusb_fill_bulk_urb(urb, priv->udev,\n\t\t\t  usb_sndbulkpipe(priv->udev, USB_8DEV_ENDP_DATA_TX),\n\t\t\t  buf, size, usb_8dev_write_bulk_callback, context);\n\turb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\tusb_anchor_urb(urb, &priv->tx_submitted);\n\n\tcan_put_echo_skb(skb, netdev, context->echo_index, 0);\n\n\tatomic_inc(&priv->active_tx_urbs);\n\n\terr = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (unlikely(err)) {\n\t\tcan_free_echo_skb(netdev, context->echo_index, NULL);\n\n\t\tusb_unanchor_urb(urb);\n\t\tusb_free_coherent(priv->udev, size, buf, urb->transfer_dma);\n\n\t\tatomic_dec(&priv->active_tx_urbs);\n\n\t\tif (err == -ENODEV)\n\t\t\tnetif_device_detach(netdev);\n\t\telse\n\t\t\tnetdev_warn(netdev, \"failed tx_urb %d\\n\", err);\n\t\tstats->tx_dropped++;\n\t} else if (atomic_read(&priv->active_tx_urbs) >= MAX_TX_URBS)\n\t\t/* Slow down tx path */\n\t\tnetif_stop_queue(netdev);\n\n\t/* Release our reference to this URB, the USB core will eventually free\n\t * it entirely.\n\t */\n\tusb_free_urb(urb);\n\n\treturn NETDEV_TX_OK;\n\nnofreecontext:\n\tusb_free_coherent(priv->udev, size, buf, urb->transfer_dma);\n\tusb_free_urb(urb);\n\n\tnetdev_warn(netdev, \"couldn't find free context\");\n\n\treturn NETDEV_TX_BUSY;\n\nnomembuf:\n\tusb_free_urb(urb);\n\nnomem:\n\tdev_kfree_skb(skb);\n\tstats->tx_dropped++;\n\n\treturn NETDEV_TX_OK;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -70,9 +70,20 @@\n \tatomic_inc(&priv->active_tx_urbs);\n \n \terr = usb_submit_urb(urb, GFP_ATOMIC);\n-\tif (unlikely(err))\n-\t\tgoto failed;\n-\telse if (atomic_read(&priv->active_tx_urbs) >= MAX_TX_URBS)\n+\tif (unlikely(err)) {\n+\t\tcan_free_echo_skb(netdev, context->echo_index, NULL);\n+\n+\t\tusb_unanchor_urb(urb);\n+\t\tusb_free_coherent(priv->udev, size, buf, urb->transfer_dma);\n+\n+\t\tatomic_dec(&priv->active_tx_urbs);\n+\n+\t\tif (err == -ENODEV)\n+\t\t\tnetif_device_detach(netdev);\n+\t\telse\n+\t\t\tnetdev_warn(netdev, \"failed tx_urb %d\\n\", err);\n+\t\tstats->tx_dropped++;\n+\t} else if (atomic_read(&priv->active_tx_urbs) >= MAX_TX_URBS)\n \t\t/* Slow down tx path */\n \t\tnetif_stop_queue(netdev);\n \n@@ -91,19 +102,6 @@\n \n \treturn NETDEV_TX_BUSY;\n \n-failed:\n-\tcan_free_echo_skb(netdev, context->echo_index, NULL);\n-\n-\tusb_unanchor_urb(urb);\n-\tusb_free_coherent(priv->udev, size, buf, urb->transfer_dma);\n-\n-\tatomic_dec(&priv->active_tx_urbs);\n-\n-\tif (err == -ENODEV)\n-\t\tnetif_device_detach(netdev);\n-\telse\n-\t\tnetdev_warn(netdev, \"failed tx_urb %d\\n\", err);\n-\n nomembuf:\n \tusb_free_urb(urb);\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (unlikely(err))",
                "\t\tgoto failed;",
                "\telse if (atomic_read(&priv->active_tx_urbs) >= MAX_TX_URBS)",
                "failed:",
                "\tcan_free_echo_skb(netdev, context->echo_index, NULL);",
                "",
                "\tusb_unanchor_urb(urb);",
                "\tusb_free_coherent(priv->udev, size, buf, urb->transfer_dma);",
                "",
                "\tatomic_dec(&priv->active_tx_urbs);",
                "",
                "\tif (err == -ENODEV)",
                "\t\tnetif_device_detach(netdev);",
                "\telse",
                "\t\tnetdev_warn(netdev, \"failed tx_urb %d\\n\", err);",
                ""
            ],
            "added_lines": [
                "\tif (unlikely(err)) {",
                "\t\tcan_free_echo_skb(netdev, context->echo_index, NULL);",
                "",
                "\t\tusb_unanchor_urb(urb);",
                "\t\tusb_free_coherent(priv->udev, size, buf, urb->transfer_dma);",
                "",
                "\t\tatomic_dec(&priv->active_tx_urbs);",
                "",
                "\t\tif (err == -ENODEV)",
                "\t\t\tnetif_device_detach(netdev);",
                "\t\telse",
                "\t\t\tnetdev_warn(netdev, \"failed tx_urb %d\\n\", err);",
                "\t\tstats->tx_dropped++;",
                "\t} else if (atomic_read(&priv->active_tx_urbs) >= MAX_TX_URBS)"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-28389",
        "func_name": "torvalds/linux/mcba_usb_start_xmit",
        "description": "mcba_usb_start_xmit in drivers/net/can/usb/mcba_usb.c in the Linux kernel through 5.17.1 has a double free.",
        "git_url": "https://github.com/torvalds/linux/commit/04c9b00ba83594a29813d6b1fb8fdc93a3915174",
        "commit_title": "can: mcba_usb: mcba_usb_start_xmit(): fix double dev_kfree_skb in error path",
        "commit_text": " There is no need to call dev_kfree_skb() when usb_submit_urb() fails because can_put_echo_skb() deletes original skb and can_free_echo_skb() deletes the cloned skb.  Link: https://lore.kernel.org/all/20220311080208.45047-1-hbh25y@gmail.com",
        "func_before": "static netdev_tx_t mcba_usb_start_xmit(struct sk_buff *skb,\n\t\t\t\t       struct net_device *netdev)\n{\n\tstruct mcba_priv *priv = netdev_priv(netdev);\n\tstruct can_frame *cf = (struct can_frame *)skb->data;\n\tstruct mcba_usb_ctx *ctx = NULL;\n\tstruct net_device_stats *stats = &priv->netdev->stats;\n\tu16 sid;\n\tint err;\n\tstruct mcba_usb_msg_can usb_msg = {\n\t\t.cmd_id = MBCA_CMD_TRANSMIT_MESSAGE_EV\n\t};\n\n\tif (can_dropped_invalid_skb(netdev, skb))\n\t\treturn NETDEV_TX_OK;\n\n\tctx = mcba_usb_get_free_ctx(priv, cf);\n\tif (!ctx)\n\t\treturn NETDEV_TX_BUSY;\n\n\tif (cf->can_id & CAN_EFF_FLAG) {\n\t\t/* SIDH    | SIDL                 | EIDH   | EIDL\n\t\t * 28 - 21 | 20 19 18 x x x 17 16 | 15 - 8 | 7 - 0\n\t\t */\n\t\tsid = MCBA_SIDL_EXID_MASK;\n\t\t/* store 28-18 bits */\n\t\tsid |= (cf->can_id & 0x1ffc0000) >> 13;\n\t\t/* store 17-16 bits */\n\t\tsid |= (cf->can_id & 0x30000) >> 16;\n\t\tput_unaligned_be16(sid, &usb_msg.sid);\n\n\t\t/* store 15-0 bits */\n\t\tput_unaligned_be16(cf->can_id & 0xffff, &usb_msg.eid);\n\t} else {\n\t\t/* SIDH   | SIDL\n\t\t * 10 - 3 | 2 1 0 x x x x x\n\t\t */\n\t\tput_unaligned_be16((cf->can_id & CAN_SFF_MASK) << 5,\n\t\t\t\t   &usb_msg.sid);\n\t\tusb_msg.eid = 0;\n\t}\n\n\tusb_msg.dlc = cf->len;\n\n\tmemcpy(usb_msg.data, cf->data, usb_msg.dlc);\n\n\tif (cf->can_id & CAN_RTR_FLAG)\n\t\tusb_msg.dlc |= MCBA_DLC_RTR_MASK;\n\n\tcan_put_echo_skb(skb, priv->netdev, ctx->ndx, 0);\n\n\terr = mcba_usb_xmit(priv, (struct mcba_usb_msg *)&usb_msg, ctx);\n\tif (err)\n\t\tgoto xmit_failed;\n\n\treturn NETDEV_TX_OK;\n\nxmit_failed:\n\tcan_free_echo_skb(priv->netdev, ctx->ndx, NULL);\n\tmcba_usb_free_ctx(ctx);\n\tdev_kfree_skb(skb);\n\tstats->tx_dropped++;\n\n\treturn NETDEV_TX_OK;\n}",
        "func": "static netdev_tx_t mcba_usb_start_xmit(struct sk_buff *skb,\n\t\t\t\t       struct net_device *netdev)\n{\n\tstruct mcba_priv *priv = netdev_priv(netdev);\n\tstruct can_frame *cf = (struct can_frame *)skb->data;\n\tstruct mcba_usb_ctx *ctx = NULL;\n\tstruct net_device_stats *stats = &priv->netdev->stats;\n\tu16 sid;\n\tint err;\n\tstruct mcba_usb_msg_can usb_msg = {\n\t\t.cmd_id = MBCA_CMD_TRANSMIT_MESSAGE_EV\n\t};\n\n\tif (can_dropped_invalid_skb(netdev, skb))\n\t\treturn NETDEV_TX_OK;\n\n\tctx = mcba_usb_get_free_ctx(priv, cf);\n\tif (!ctx)\n\t\treturn NETDEV_TX_BUSY;\n\n\tif (cf->can_id & CAN_EFF_FLAG) {\n\t\t/* SIDH    | SIDL                 | EIDH   | EIDL\n\t\t * 28 - 21 | 20 19 18 x x x 17 16 | 15 - 8 | 7 - 0\n\t\t */\n\t\tsid = MCBA_SIDL_EXID_MASK;\n\t\t/* store 28-18 bits */\n\t\tsid |= (cf->can_id & 0x1ffc0000) >> 13;\n\t\t/* store 17-16 bits */\n\t\tsid |= (cf->can_id & 0x30000) >> 16;\n\t\tput_unaligned_be16(sid, &usb_msg.sid);\n\n\t\t/* store 15-0 bits */\n\t\tput_unaligned_be16(cf->can_id & 0xffff, &usb_msg.eid);\n\t} else {\n\t\t/* SIDH   | SIDL\n\t\t * 10 - 3 | 2 1 0 x x x x x\n\t\t */\n\t\tput_unaligned_be16((cf->can_id & CAN_SFF_MASK) << 5,\n\t\t\t\t   &usb_msg.sid);\n\t\tusb_msg.eid = 0;\n\t}\n\n\tusb_msg.dlc = cf->len;\n\n\tmemcpy(usb_msg.data, cf->data, usb_msg.dlc);\n\n\tif (cf->can_id & CAN_RTR_FLAG)\n\t\tusb_msg.dlc |= MCBA_DLC_RTR_MASK;\n\n\tcan_put_echo_skb(skb, priv->netdev, ctx->ndx, 0);\n\n\terr = mcba_usb_xmit(priv, (struct mcba_usb_msg *)&usb_msg, ctx);\n\tif (err)\n\t\tgoto xmit_failed;\n\n\treturn NETDEV_TX_OK;\n\nxmit_failed:\n\tcan_free_echo_skb(priv->netdev, ctx->ndx, NULL);\n\tmcba_usb_free_ctx(ctx);\n\tstats->tx_dropped++;\n\n\treturn NETDEV_TX_OK;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -58,7 +58,6 @@\n xmit_failed:\n \tcan_free_echo_skb(priv->netdev, ctx->ndx, NULL);\n \tmcba_usb_free_ctx(ctx);\n-\tdev_kfree_skb(skb);\n \tstats->tx_dropped++;\n \n \treturn NETDEV_TX_OK;",
        "diff_line_info": {
            "deleted_lines": [
                "\tdev_kfree_skb(skb);"
            ],
            "added_lines": []
        }
    },
    {
        "cve_id": "CVE-2022-28390",
        "func_name": "torvalds/linux/ems_usb_start_xmit",
        "description": "ems_usb_start_xmit in drivers/net/can/usb/ems_usb.c in the Linux kernel through 5.17.1 has a double free.",
        "git_url": "https://github.com/torvalds/linux/commit/c70222752228a62135cee3409dccefd494a24646",
        "commit_title": "can: ems_usb: ems_usb_start_xmit(): fix double dev_kfree_skb() in error path",
        "commit_text": " There is no need to call dev_kfree_skb() when usb_submit_urb() fails beacause can_put_echo_skb() deletes the original skb and can_free_echo_skb() deletes the cloned skb.  Link: https://lore.kernel.org/all/20220228083639.38183-1-hbh25y@gmail.com Cc: stable@vger.kernel.org Cc: Sebastian Haas <haas@ems-wuensche.com>",
        "func_before": "static netdev_tx_t ems_usb_start_xmit(struct sk_buff *skb, struct net_device *netdev)\n{\n\tstruct ems_usb *dev = netdev_priv(netdev);\n\tstruct ems_tx_urb_context *context = NULL;\n\tstruct net_device_stats *stats = &netdev->stats;\n\tstruct can_frame *cf = (struct can_frame *)skb->data;\n\tstruct ems_cpc_msg *msg;\n\tstruct urb *urb;\n\tu8 *buf;\n\tint i, err;\n\tsize_t size = CPC_HEADER_SIZE + CPC_MSG_HEADER_LEN\n\t\t\t+ sizeof(struct cpc_can_msg);\n\n\tif (can_dropped_invalid_skb(netdev, skb))\n\t\treturn NETDEV_TX_OK;\n\n\t/* create a URB, and a buffer for it, and copy the data to the URB */\n\turb = usb_alloc_urb(0, GFP_ATOMIC);\n\tif (!urb)\n\t\tgoto nomem;\n\n\tbuf = usb_alloc_coherent(dev->udev, size, GFP_ATOMIC, &urb->transfer_dma);\n\tif (!buf) {\n\t\tnetdev_err(netdev, \"No memory left for USB buffer\\n\");\n\t\tusb_free_urb(urb);\n\t\tgoto nomem;\n\t}\n\n\tmsg = (struct ems_cpc_msg *)&buf[CPC_HEADER_SIZE];\n\n\tmsg->msg.can_msg.id = cpu_to_le32(cf->can_id & CAN_ERR_MASK);\n\tmsg->msg.can_msg.length = cf->len;\n\n\tif (cf->can_id & CAN_RTR_FLAG) {\n\t\tmsg->type = cf->can_id & CAN_EFF_FLAG ?\n\t\t\tCPC_CMD_TYPE_EXT_RTR_FRAME : CPC_CMD_TYPE_RTR_FRAME;\n\n\t\tmsg->length = CPC_CAN_MSG_MIN_SIZE;\n\t} else {\n\t\tmsg->type = cf->can_id & CAN_EFF_FLAG ?\n\t\t\tCPC_CMD_TYPE_EXT_CAN_FRAME : CPC_CMD_TYPE_CAN_FRAME;\n\n\t\tfor (i = 0; i < cf->len; i++)\n\t\t\tmsg->msg.can_msg.msg[i] = cf->data[i];\n\n\t\tmsg->length = CPC_CAN_MSG_MIN_SIZE + cf->len;\n\t}\n\n\tfor (i = 0; i < MAX_TX_URBS; i++) {\n\t\tif (dev->tx_contexts[i].echo_index == MAX_TX_URBS) {\n\t\t\tcontext = &dev->tx_contexts[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * May never happen! When this happens we'd more URBs in flight as\n\t * allowed (MAX_TX_URBS).\n\t */\n\tif (!context) {\n\t\tusb_free_coherent(dev->udev, size, buf, urb->transfer_dma);\n\t\tusb_free_urb(urb);\n\n\t\tnetdev_warn(netdev, \"couldn't find free context\\n\");\n\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\n\tcontext->dev = dev;\n\tcontext->echo_index = i;\n\n\tusb_fill_bulk_urb(urb, dev->udev, usb_sndbulkpipe(dev->udev, 2), buf,\n\t\t\t  size, ems_usb_write_bulk_callback, context);\n\turb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\tusb_anchor_urb(urb, &dev->tx_submitted);\n\n\tcan_put_echo_skb(skb, netdev, context->echo_index, 0);\n\n\tatomic_inc(&dev->active_tx_urbs);\n\n\terr = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (unlikely(err)) {\n\t\tcan_free_echo_skb(netdev, context->echo_index, NULL);\n\n\t\tusb_unanchor_urb(urb);\n\t\tusb_free_coherent(dev->udev, size, buf, urb->transfer_dma);\n\t\tdev_kfree_skb(skb);\n\n\t\tatomic_dec(&dev->active_tx_urbs);\n\n\t\tif (err == -ENODEV) {\n\t\t\tnetif_device_detach(netdev);\n\t\t} else {\n\t\t\tnetdev_warn(netdev, \"failed tx_urb %d\\n\", err);\n\n\t\t\tstats->tx_dropped++;\n\t\t}\n\t} else {\n\t\tnetif_trans_update(netdev);\n\n\t\t/* Slow down tx path */\n\t\tif (atomic_read(&dev->active_tx_urbs) >= MAX_TX_URBS ||\n\t\t    dev->free_slots < CPC_TX_QUEUE_TRIGGER_LOW) {\n\t\t\tnetif_stop_queue(netdev);\n\t\t}\n\t}\n\n\t/*\n\t * Release our reference to this URB, the USB core will eventually free\n\t * it entirely.\n\t */\n\tusb_free_urb(urb);\n\n\treturn NETDEV_TX_OK;\n\nnomem:\n\tdev_kfree_skb(skb);\n\tstats->tx_dropped++;\n\n\treturn NETDEV_TX_OK;\n}",
        "func": "static netdev_tx_t ems_usb_start_xmit(struct sk_buff *skb, struct net_device *netdev)\n{\n\tstruct ems_usb *dev = netdev_priv(netdev);\n\tstruct ems_tx_urb_context *context = NULL;\n\tstruct net_device_stats *stats = &netdev->stats;\n\tstruct can_frame *cf = (struct can_frame *)skb->data;\n\tstruct ems_cpc_msg *msg;\n\tstruct urb *urb;\n\tu8 *buf;\n\tint i, err;\n\tsize_t size = CPC_HEADER_SIZE + CPC_MSG_HEADER_LEN\n\t\t\t+ sizeof(struct cpc_can_msg);\n\n\tif (can_dropped_invalid_skb(netdev, skb))\n\t\treturn NETDEV_TX_OK;\n\n\t/* create a URB, and a buffer for it, and copy the data to the URB */\n\turb = usb_alloc_urb(0, GFP_ATOMIC);\n\tif (!urb)\n\t\tgoto nomem;\n\n\tbuf = usb_alloc_coherent(dev->udev, size, GFP_ATOMIC, &urb->transfer_dma);\n\tif (!buf) {\n\t\tnetdev_err(netdev, \"No memory left for USB buffer\\n\");\n\t\tusb_free_urb(urb);\n\t\tgoto nomem;\n\t}\n\n\tmsg = (struct ems_cpc_msg *)&buf[CPC_HEADER_SIZE];\n\n\tmsg->msg.can_msg.id = cpu_to_le32(cf->can_id & CAN_ERR_MASK);\n\tmsg->msg.can_msg.length = cf->len;\n\n\tif (cf->can_id & CAN_RTR_FLAG) {\n\t\tmsg->type = cf->can_id & CAN_EFF_FLAG ?\n\t\t\tCPC_CMD_TYPE_EXT_RTR_FRAME : CPC_CMD_TYPE_RTR_FRAME;\n\n\t\tmsg->length = CPC_CAN_MSG_MIN_SIZE;\n\t} else {\n\t\tmsg->type = cf->can_id & CAN_EFF_FLAG ?\n\t\t\tCPC_CMD_TYPE_EXT_CAN_FRAME : CPC_CMD_TYPE_CAN_FRAME;\n\n\t\tfor (i = 0; i < cf->len; i++)\n\t\t\tmsg->msg.can_msg.msg[i] = cf->data[i];\n\n\t\tmsg->length = CPC_CAN_MSG_MIN_SIZE + cf->len;\n\t}\n\n\tfor (i = 0; i < MAX_TX_URBS; i++) {\n\t\tif (dev->tx_contexts[i].echo_index == MAX_TX_URBS) {\n\t\t\tcontext = &dev->tx_contexts[i];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * May never happen! When this happens we'd more URBs in flight as\n\t * allowed (MAX_TX_URBS).\n\t */\n\tif (!context) {\n\t\tusb_free_coherent(dev->udev, size, buf, urb->transfer_dma);\n\t\tusb_free_urb(urb);\n\n\t\tnetdev_warn(netdev, \"couldn't find free context\\n\");\n\n\t\treturn NETDEV_TX_BUSY;\n\t}\n\n\tcontext->dev = dev;\n\tcontext->echo_index = i;\n\n\tusb_fill_bulk_urb(urb, dev->udev, usb_sndbulkpipe(dev->udev, 2), buf,\n\t\t\t  size, ems_usb_write_bulk_callback, context);\n\turb->transfer_flags |= URB_NO_TRANSFER_DMA_MAP;\n\tusb_anchor_urb(urb, &dev->tx_submitted);\n\n\tcan_put_echo_skb(skb, netdev, context->echo_index, 0);\n\n\tatomic_inc(&dev->active_tx_urbs);\n\n\terr = usb_submit_urb(urb, GFP_ATOMIC);\n\tif (unlikely(err)) {\n\t\tcan_free_echo_skb(netdev, context->echo_index, NULL);\n\n\t\tusb_unanchor_urb(urb);\n\t\tusb_free_coherent(dev->udev, size, buf, urb->transfer_dma);\n\n\t\tatomic_dec(&dev->active_tx_urbs);\n\n\t\tif (err == -ENODEV) {\n\t\t\tnetif_device_detach(netdev);\n\t\t} else {\n\t\t\tnetdev_warn(netdev, \"failed tx_urb %d\\n\", err);\n\n\t\t\tstats->tx_dropped++;\n\t\t}\n\t} else {\n\t\tnetif_trans_update(netdev);\n\n\t\t/* Slow down tx path */\n\t\tif (atomic_read(&dev->active_tx_urbs) >= MAX_TX_URBS ||\n\t\t    dev->free_slots < CPC_TX_QUEUE_TRIGGER_LOW) {\n\t\t\tnetif_stop_queue(netdev);\n\t\t}\n\t}\n\n\t/*\n\t * Release our reference to this URB, the USB core will eventually free\n\t * it entirely.\n\t */\n\tusb_free_urb(urb);\n\n\treturn NETDEV_TX_OK;\n\nnomem:\n\tdev_kfree_skb(skb);\n\tstats->tx_dropped++;\n\n\treturn NETDEV_TX_OK;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -84,7 +84,6 @@\n \n \t\tusb_unanchor_urb(urb);\n \t\tusb_free_coherent(dev->udev, size, buf, urb->transfer_dma);\n-\t\tdev_kfree_skb(skb);\n \n \t\tatomic_dec(&dev->active_tx_urbs);\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tdev_kfree_skb(skb);"
            ],
            "added_lines": []
        }
    },
    {
        "cve_id": "CVE-2022-27416",
        "func_name": "appneta/tcpreplay/dlt_jnpr_ether_post_init",
        "description": "Tcpreplay v4.4.1 was discovered to contain a double-free via __interceptor_free.",
        "git_url": "https://github.com/appneta/tcpreplay/commit/45cb2ac23213861749d82ad3524f46e347d308a3",
        "commit_title": "Bug #702 prevent double init in Juniper DLT",
        "commit_text": "",
        "func_before": "int \ndlt_jnpr_ether_post_init(tcpeditdlt_t *ctx)\n{\n    jnpr_ether_config_t *config;\n    \n    /* do nothing if we're not the decoder */\n    if (ctx->decoder->dlt != dlt_value)\n        return TCPEDIT_OK;\n    \n    /* init our subcontext & decoder of en10mb */\n    config = (jnpr_ether_config_t *)ctx->encoder->config;\n    config->subctx = tcpedit_dlt_init(ctx->tcpedit, DLT_EN10MB);\n        \n    return TCPEDIT_OK;\n}",
        "func": "int \ndlt_jnpr_ether_post_init(tcpeditdlt_t *ctx)\n{\n    jnpr_ether_config_t *config;\n    \n    /* do nothing if we're not the decoder */\n    if (ctx->decoder->dlt != dlt_value)\n        return TCPEDIT_OK;\n    \n    /* init our subcontext & decoder of en10mb */\n    config = (jnpr_ether_config_t *)ctx->encoder->config;\n    if (config->subctx == NULL)\n        config->subctx = tcpedit_dlt_init(ctx->tcpedit, DLT_EN10MB);\n        \n    return TCPEDIT_OK;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -9,7 +9,8 @@\n     \n     /* init our subcontext & decoder of en10mb */\n     config = (jnpr_ether_config_t *)ctx->encoder->config;\n-    config->subctx = tcpedit_dlt_init(ctx->tcpedit, DLT_EN10MB);\n+    if (config->subctx == NULL)\n+        config->subctx = tcpedit_dlt_init(ctx->tcpedit, DLT_EN10MB);\n         \n     return TCPEDIT_OK;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    config->subctx = tcpedit_dlt_init(ctx->tcpedit, DLT_EN10MB);"
            ],
            "added_lines": [
                "    if (config->subctx == NULL)",
                "        config->subctx = tcpedit_dlt_init(ctx->tcpedit, DLT_EN10MB);"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-27416",
        "func_name": "appneta/tcpreplay/dlt_jnpr_ether_cleanup",
        "description": "Tcpreplay v4.4.1 was discovered to contain a double-free via __interceptor_free.",
        "git_url": "https://github.com/appneta/tcpreplay/commit/9297ac29af91324e3f94580b8ffc2a40a4d59e98",
        "commit_title": "Bug #702 fix double free in Juniper DLT",
        "commit_text": "",
        "func_before": "int \ndlt_jnpr_ether_cleanup(tcpeditdlt_t *ctx)\n{\n    tcpeditdlt_plugin_t *plugin;\n    \n    assert(ctx);\n\n    if ((plugin = tcpedit_dlt_getplugin(ctx, dlt_value)) == NULL) {\n        tcpedit_seterr(ctx->tcpedit, \"Unable to cleanup unregistered plugin %s\", dlt_name);\n        return TCPEDIT_ERROR;\n    }\n\n    safe_free(plugin->name);\n    plugin->name = NULL;\n    if (plugin->config != NULL) {\n        /* clean up the en10mb plugin */\n        jnpr_ether_config_t *config;\n\n        config = (jnpr_ether_config_t *)ctx->encoder->config;\n        tcpedit_dlt_cleanup(config->subctx);\n        safe_free(config->subctx);\n        safe_free(plugin->config);\n        plugin->config = NULL;\n        plugin->config_size = 0;\n    }\n\n    return TCPEDIT_OK; /* success */\n}",
        "func": "int \ndlt_jnpr_ether_cleanup(tcpeditdlt_t *ctx)\n{\n    tcpeditdlt_plugin_t *plugin;\n    \n    assert(ctx);\n\n    if ((plugin = tcpedit_dlt_getplugin(ctx, dlt_value)) == NULL) {\n        tcpedit_seterr(ctx->tcpedit, \"Unable to cleanup unregistered plugin %s\", dlt_name);\n        return TCPEDIT_ERROR;\n    }\n\n    safe_free(plugin->name);\n    plugin->name = NULL;\n    if (plugin->config != NULL) {\n        /* clean up the en10mb plugin */\n        jnpr_ether_config_t *config;\n\n        config = (jnpr_ether_config_t *)ctx->encoder->config;\n        tcpedit_dlt_cleanup(config->subctx);\n        safe_free(plugin->config);\n        plugin->config = NULL;\n        plugin->config_size = 0;\n    }\n\n    return TCPEDIT_OK; /* success */\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -18,7 +18,6 @@\n \n         config = (jnpr_ether_config_t *)ctx->encoder->config;\n         tcpedit_dlt_cleanup(config->subctx);\n-        safe_free(config->subctx);\n         safe_free(plugin->config);\n         plugin->config = NULL;\n         plugin->config_size = 0;",
        "diff_line_info": {
            "deleted_lines": [
                "        safe_free(config->subctx);"
            ],
            "added_lines": []
        }
    },
    {
        "cve_id": "CVE-2022-29156",
        "func_name": "torvalds/linux/free_clt",
        "description": "drivers/infiniband/ulp/rtrs/rtrs-clt.c in the Linux kernel before 5.16.12 has a double free related to rtrs_clt_dev_release.",
        "git_url": "https://github.com/torvalds/linux/commit/8700af2cc18c919b2a83e74e0479038fd113c15d",
        "commit_title": "RDMA/rtrs-clt: Fix possible double free in error case",
        "commit_text": " Callback function rtrs_clt_dev_release() for put_device() calls kfree(clt) to free memory. We shouldn't call kfree(clt) again, and we can't use the clt after kfree too.  Replace device_register() with device_initialize() and device_add() so that dev_set_name can() be used appropriately.  Move mutex_destroy() to the release function so it can be called in the alloc_clt err path.  Link: https://lore.kernel.org/r/20220217030929.323849-1-haris.iqbal@ionos.com",
        "func_before": "static void free_clt(struct rtrs_clt_sess *clt)\n{\n\tfree_permits(clt);\n\tfree_percpu(clt->pcpu_path);\n\tmutex_destroy(&clt->paths_ev_mutex);\n\tmutex_destroy(&clt->paths_mutex);\n\t/* release callback will free clt in last put */\n\tdevice_unregister(&clt->dev);\n}",
        "func": "static void free_clt(struct rtrs_clt_sess *clt)\n{\n\tfree_permits(clt);\n\tfree_percpu(clt->pcpu_path);\n\n\t/*\n\t * release callback will free clt and destroy mutexes in last put\n\t */\n\tdevice_unregister(&clt->dev);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,8 +2,9 @@\n {\n \tfree_permits(clt);\n \tfree_percpu(clt->pcpu_path);\n-\tmutex_destroy(&clt->paths_ev_mutex);\n-\tmutex_destroy(&clt->paths_mutex);\n-\t/* release callback will free clt in last put */\n+\n+\t/*\n+\t * release callback will free clt and destroy mutexes in last put\n+\t */\n \tdevice_unregister(&clt->dev);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tmutex_destroy(&clt->paths_ev_mutex);",
                "\tmutex_destroy(&clt->paths_mutex);",
                "\t/* release callback will free clt in last put */"
            ],
            "added_lines": [
                "",
                "\t/*",
                "\t * release callback will free clt and destroy mutexes in last put",
                "\t */"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-29156",
        "func_name": "torvalds/linux/alloc_clt",
        "description": "drivers/infiniband/ulp/rtrs/rtrs-clt.c in the Linux kernel before 5.16.12 has a double free related to rtrs_clt_dev_release.",
        "git_url": "https://github.com/torvalds/linux/commit/8700af2cc18c919b2a83e74e0479038fd113c15d",
        "commit_title": "RDMA/rtrs-clt: Fix possible double free in error case",
        "commit_text": " Callback function rtrs_clt_dev_release() for put_device() calls kfree(clt) to free memory. We shouldn't call kfree(clt) again, and we can't use the clt after kfree too.  Replace device_register() with device_initialize() and device_add() so that dev_set_name can() be used appropriately.  Move mutex_destroy() to the release function so it can be called in the alloc_clt err path.  Link: https://lore.kernel.org/r/20220217030929.323849-1-haris.iqbal@ionos.com",
        "func_before": "static struct rtrs_clt_sess *alloc_clt(const char *sessname, size_t paths_num,\n\t\t\t\t  u16 port, size_t pdu_sz, void *priv,\n\t\t\t\t  void\t(*link_ev)(void *priv,\n\t\t\t\t\t\t   enum rtrs_clt_link_ev ev),\n\t\t\t\t  unsigned int reconnect_delay_sec,\n\t\t\t\t  unsigned int max_reconnect_attempts)\n{\n\tstruct rtrs_clt_sess *clt;\n\tint err;\n\n\tif (!paths_num || paths_num > MAX_PATHS_NUM)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (strlen(sessname) >= sizeof(clt->sessname))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tclt = kzalloc(sizeof(*clt), GFP_KERNEL);\n\tif (!clt)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tclt->pcpu_path = alloc_percpu(typeof(*clt->pcpu_path));\n\tif (!clt->pcpu_path) {\n\t\tkfree(clt);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tuuid_gen(&clt->paths_uuid);\n\tINIT_LIST_HEAD_RCU(&clt->paths_list);\n\tclt->paths_num = paths_num;\n\tclt->paths_up = MAX_PATHS_NUM;\n\tclt->port = port;\n\tclt->pdu_sz = pdu_sz;\n\tclt->max_segments = RTRS_MAX_SEGMENTS;\n\tclt->reconnect_delay_sec = reconnect_delay_sec;\n\tclt->max_reconnect_attempts = max_reconnect_attempts;\n\tclt->priv = priv;\n\tclt->link_ev = link_ev;\n\tclt->mp_policy = MP_POLICY_MIN_INFLIGHT;\n\tstrscpy(clt->sessname, sessname, sizeof(clt->sessname));\n\tinit_waitqueue_head(&clt->permits_wait);\n\tmutex_init(&clt->paths_ev_mutex);\n\tmutex_init(&clt->paths_mutex);\n\n\tclt->dev.class = rtrs_clt_dev_class;\n\tclt->dev.release = rtrs_clt_dev_release;\n\terr = dev_set_name(&clt->dev, \"%s\", sessname);\n\tif (err)\n\t\tgoto err;\n\t/*\n\t * Suppress user space notification until\n\t * sysfs files are created\n\t */\n\tdev_set_uevent_suppress(&clt->dev, true);\n\terr = device_register(&clt->dev);\n\tif (err) {\n\t\tput_device(&clt->dev);\n\t\tgoto err;\n\t}\n\n\tclt->kobj_paths = kobject_create_and_add(\"paths\", &clt->dev.kobj);\n\tif (!clt->kobj_paths) {\n\t\terr = -ENOMEM;\n\t\tgoto err_dev;\n\t}\n\terr = rtrs_clt_create_sysfs_root_files(clt);\n\tif (err) {\n\t\tkobject_del(clt->kobj_paths);\n\t\tkobject_put(clt->kobj_paths);\n\t\tgoto err_dev;\n\t}\n\tdev_set_uevent_suppress(&clt->dev, false);\n\tkobject_uevent(&clt->dev.kobj, KOBJ_ADD);\n\n\treturn clt;\nerr_dev:\n\tdevice_unregister(&clt->dev);\nerr:\n\tfree_percpu(clt->pcpu_path);\n\tkfree(clt);\n\treturn ERR_PTR(err);\n}",
        "func": "static struct rtrs_clt_sess *alloc_clt(const char *sessname, size_t paths_num,\n\t\t\t\t  u16 port, size_t pdu_sz, void *priv,\n\t\t\t\t  void\t(*link_ev)(void *priv,\n\t\t\t\t\t\t   enum rtrs_clt_link_ev ev),\n\t\t\t\t  unsigned int reconnect_delay_sec,\n\t\t\t\t  unsigned int max_reconnect_attempts)\n{\n\tstruct rtrs_clt_sess *clt;\n\tint err;\n\n\tif (!paths_num || paths_num > MAX_PATHS_NUM)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (strlen(sessname) >= sizeof(clt->sessname))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tclt = kzalloc(sizeof(*clt), GFP_KERNEL);\n\tif (!clt)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tclt->pcpu_path = alloc_percpu(typeof(*clt->pcpu_path));\n\tif (!clt->pcpu_path) {\n\t\tkfree(clt);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tclt->dev.class = rtrs_clt_dev_class;\n\tclt->dev.release = rtrs_clt_dev_release;\n\tuuid_gen(&clt->paths_uuid);\n\tINIT_LIST_HEAD_RCU(&clt->paths_list);\n\tclt->paths_num = paths_num;\n\tclt->paths_up = MAX_PATHS_NUM;\n\tclt->port = port;\n\tclt->pdu_sz = pdu_sz;\n\tclt->max_segments = RTRS_MAX_SEGMENTS;\n\tclt->reconnect_delay_sec = reconnect_delay_sec;\n\tclt->max_reconnect_attempts = max_reconnect_attempts;\n\tclt->priv = priv;\n\tclt->link_ev = link_ev;\n\tclt->mp_policy = MP_POLICY_MIN_INFLIGHT;\n\tstrscpy(clt->sessname, sessname, sizeof(clt->sessname));\n\tinit_waitqueue_head(&clt->permits_wait);\n\tmutex_init(&clt->paths_ev_mutex);\n\tmutex_init(&clt->paths_mutex);\n\tdevice_initialize(&clt->dev);\n\n\terr = dev_set_name(&clt->dev, \"%s\", sessname);\n\tif (err)\n\t\tgoto err_put;\n\n\t/*\n\t * Suppress user space notification until\n\t * sysfs files are created\n\t */\n\tdev_set_uevent_suppress(&clt->dev, true);\n\terr = device_add(&clt->dev);\n\tif (err)\n\t\tgoto err_put;\n\n\tclt->kobj_paths = kobject_create_and_add(\"paths\", &clt->dev.kobj);\n\tif (!clt->kobj_paths) {\n\t\terr = -ENOMEM;\n\t\tgoto err_del;\n\t}\n\terr = rtrs_clt_create_sysfs_root_files(clt);\n\tif (err) {\n\t\tkobject_del(clt->kobj_paths);\n\t\tkobject_put(clt->kobj_paths);\n\t\tgoto err_del;\n\t}\n\tdev_set_uevent_suppress(&clt->dev, false);\n\tkobject_uevent(&clt->dev.kobj, KOBJ_ADD);\n\n\treturn clt;\nerr_del:\n\tdevice_del(&clt->dev);\nerr_put:\n\tfree_percpu(clt->pcpu_path);\n\tput_device(&clt->dev);\n\treturn ERR_PTR(err);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -24,6 +24,8 @@\n \t\treturn ERR_PTR(-ENOMEM);\n \t}\n \n+\tclt->dev.class = rtrs_clt_dev_class;\n+\tclt->dev.release = rtrs_clt_dev_release;\n \tuuid_gen(&clt->paths_uuid);\n \tINIT_LIST_HEAD_RCU(&clt->paths_list);\n \tclt->paths_num = paths_num;\n@@ -40,42 +42,40 @@\n \tinit_waitqueue_head(&clt->permits_wait);\n \tmutex_init(&clt->paths_ev_mutex);\n \tmutex_init(&clt->paths_mutex);\n+\tdevice_initialize(&clt->dev);\n \n-\tclt->dev.class = rtrs_clt_dev_class;\n-\tclt->dev.release = rtrs_clt_dev_release;\n \terr = dev_set_name(&clt->dev, \"%s\", sessname);\n \tif (err)\n-\t\tgoto err;\n+\t\tgoto err_put;\n+\n \t/*\n \t * Suppress user space notification until\n \t * sysfs files are created\n \t */\n \tdev_set_uevent_suppress(&clt->dev, true);\n-\terr = device_register(&clt->dev);\n-\tif (err) {\n-\t\tput_device(&clt->dev);\n-\t\tgoto err;\n-\t}\n+\terr = device_add(&clt->dev);\n+\tif (err)\n+\t\tgoto err_put;\n \n \tclt->kobj_paths = kobject_create_and_add(\"paths\", &clt->dev.kobj);\n \tif (!clt->kobj_paths) {\n \t\terr = -ENOMEM;\n-\t\tgoto err_dev;\n+\t\tgoto err_del;\n \t}\n \terr = rtrs_clt_create_sysfs_root_files(clt);\n \tif (err) {\n \t\tkobject_del(clt->kobj_paths);\n \t\tkobject_put(clt->kobj_paths);\n-\t\tgoto err_dev;\n+\t\tgoto err_del;\n \t}\n \tdev_set_uevent_suppress(&clt->dev, false);\n \tkobject_uevent(&clt->dev.kobj, KOBJ_ADD);\n \n \treturn clt;\n-err_dev:\n-\tdevice_unregister(&clt->dev);\n-err:\n+err_del:\n+\tdevice_del(&clt->dev);\n+err_put:\n \tfree_percpu(clt->pcpu_path);\n-\tkfree(clt);\n+\tput_device(&clt->dev);\n \treturn ERR_PTR(err);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tclt->dev.class = rtrs_clt_dev_class;",
                "\tclt->dev.release = rtrs_clt_dev_release;",
                "\t\tgoto err;",
                "\terr = device_register(&clt->dev);",
                "\tif (err) {",
                "\t\tput_device(&clt->dev);",
                "\t\tgoto err;",
                "\t}",
                "\t\tgoto err_dev;",
                "\t\tgoto err_dev;",
                "err_dev:",
                "\tdevice_unregister(&clt->dev);",
                "err:",
                "\tkfree(clt);"
            ],
            "added_lines": [
                "\tclt->dev.class = rtrs_clt_dev_class;",
                "\tclt->dev.release = rtrs_clt_dev_release;",
                "\tdevice_initialize(&clt->dev);",
                "\t\tgoto err_put;",
                "",
                "\terr = device_add(&clt->dev);",
                "\tif (err)",
                "\t\tgoto err_put;",
                "\t\tgoto err_del;",
                "\t\tgoto err_del;",
                "err_del:",
                "\tdevice_del(&clt->dev);",
                "err_put:",
                "\tput_device(&clt->dev);"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-29156",
        "func_name": "torvalds/linux/rtrs_clt_dev_release",
        "description": "drivers/infiniband/ulp/rtrs/rtrs-clt.c in the Linux kernel before 5.16.12 has a double free related to rtrs_clt_dev_release.",
        "git_url": "https://github.com/torvalds/linux/commit/8700af2cc18c919b2a83e74e0479038fd113c15d",
        "commit_title": "RDMA/rtrs-clt: Fix possible double free in error case",
        "commit_text": " Callback function rtrs_clt_dev_release() for put_device() calls kfree(clt) to free memory. We shouldn't call kfree(clt) again, and we can't use the clt after kfree too.  Replace device_register() with device_initialize() and device_add() so that dev_set_name can() be used appropriately.  Move mutex_destroy() to the release function so it can be called in the alloc_clt err path.  Link: https://lore.kernel.org/r/20220217030929.323849-1-haris.iqbal@ionos.com",
        "func_before": "static void rtrs_clt_dev_release(struct device *dev)\n{\n\tstruct rtrs_clt_sess *clt = container_of(dev, struct rtrs_clt_sess,\n\t\t\t\t\t\t dev);\n\n\tkfree(clt);\n}",
        "func": "static void rtrs_clt_dev_release(struct device *dev)\n{\n\tstruct rtrs_clt_sess *clt = container_of(dev, struct rtrs_clt_sess,\n\t\t\t\t\t\t dev);\n\n\tmutex_destroy(&clt->paths_ev_mutex);\n\tmutex_destroy(&clt->paths_mutex);\n\tkfree(clt);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,5 +3,7 @@\n \tstruct rtrs_clt_sess *clt = container_of(dev, struct rtrs_clt_sess,\n \t\t\t\t\t\t dev);\n \n+\tmutex_destroy(&clt->paths_ev_mutex);\n+\tmutex_destroy(&clt->paths_mutex);\n \tkfree(clt);\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tmutex_destroy(&clt->paths_ev_mutex);",
                "\tmutex_destroy(&clt->paths_mutex);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-42778",
        "func_name": "OpenSC/idprime_get_token_name",
        "description": "A heap double free issue was found in Opensc before version 0.22.0 in sc_pkcs15_free_tokeninfo.",
        "git_url": "https://github.com/OpenSC/OpenSC/commit/f015746d22d249642c19674298a18ad824db0ed7",
        "commit_title": "idprime: Use temporary variable instead of messing up the passed one",
        "commit_text": " Thanks oss-fuzz  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=28185",
        "func_before": "static int idprime_get_token_name(sc_card_t* card, char** tname)\n{\n\tidprime_private_data_t * priv = card->drv_data;\n\tsc_path_t tinfo_path = {\"\\x00\\x00\", 2, 0, 0, SC_PATH_TYPE_PATH, {\"\", 0}};\n\tsc_file_t *file = NULL;\n\tu8 buf[2];\n\tint r;\n\n\tLOG_FUNC_CALLED(card->ctx);\n\n\tif (tname == NULL) {\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_INVALID_ARGUMENTS);\n\t}\n\n\tif (!priv->tinfo_present) {\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_NOT_SUPPORTED);\n\t}\n\n\tmemcpy(tinfo_path.value, priv->tinfo_df, 2);\n\tr = iso_ops->select_file(card, &tinfo_path, &file);\n\tif (r != SC_SUCCESS || file->size == 0) {\n\t\tsc_file_free(file);\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_NOT_SUPPORTED);\n\t}\n\n\t/* First two bytes lists 0x01, the second indicates length */\n\tr = iso_ops->read_binary(card, 0, buf, 2, 0);\n\tif (r < 2 || buf[1] > file->size) { /* make sure we do not overrun */\n\t\tsc_file_free(file);\n\t\tLOG_FUNC_RETURN(card->ctx, r);\n\t}\n\tsc_file_free(file);\n\n\t*tname = malloc(buf[1]);\n\tif (*tname == NULL) {\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);\n\t}\n\n\tr = iso_ops->read_binary(card, 2, (unsigned char *)*tname, buf[1], 0);\n\tif (r < 1) {\n\t\tfree(*tname);\n\t\tLOG_FUNC_RETURN(card->ctx, r);\n\t}\n\n\tif ((*tname)[r-1] != '\\0') {\n\t\t(*tname)[r-1] = '\\0';\n\t}\n\tLOG_FUNC_RETURN(card->ctx, SC_SUCCESS);\n}",
        "func": "static int idprime_get_token_name(sc_card_t* card, char** tname)\n{\n\tidprime_private_data_t * priv = card->drv_data;\n\tsc_path_t tinfo_path = {\"\\x00\\x00\", 2, 0, 0, SC_PATH_TYPE_PATH, {\"\", 0}};\n\tsc_file_t *file = NULL;\n\tu8 buf[2];\n\tchar *name;\n\tint r;\n\n\tLOG_FUNC_CALLED(card->ctx);\n\n\tif (tname == NULL) {\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_INVALID_ARGUMENTS);\n\t}\n\n\tif (!priv->tinfo_present) {\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_NOT_SUPPORTED);\n\t}\n\n\tmemcpy(tinfo_path.value, priv->tinfo_df, 2);\n\tr = iso_ops->select_file(card, &tinfo_path, &file);\n\tif (r != SC_SUCCESS || file->size == 0) {\n\t\tsc_file_free(file);\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_NOT_SUPPORTED);\n\t}\n\n\t/* First two bytes lists 0x01, the second indicates length */\n\tr = iso_ops->read_binary(card, 0, buf, 2, 0);\n\tif (r < 2 || buf[1] > file->size) { /* make sure we do not overrun */\n\t\tsc_file_free(file);\n\t\tLOG_FUNC_RETURN(card->ctx, r);\n\t}\n\tsc_file_free(file);\n\n\tname = malloc(buf[1]);\n\tif (name == NULL) {\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);\n\t}\n\n\tr = iso_ops->read_binary(card, 2, (unsigned char *)name, buf[1], 0);\n\tif (r < 1) {\n\t\tfree(name);\n\t\tLOG_FUNC_RETURN(card->ctx, r);\n\t}\n\n\tif (name[r-1] != '\\0') {\n\t\tname[r-1] = '\\0';\n\t}\n\t*tname = name;\n\n\tLOG_FUNC_RETURN(card->ctx, SC_SUCCESS);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,6 +4,7 @@\n \tsc_path_t tinfo_path = {\"\\x00\\x00\", 2, 0, 0, SC_PATH_TYPE_PATH, {\"\", 0}};\n \tsc_file_t *file = NULL;\n \tu8 buf[2];\n+\tchar *name;\n \tint r;\n \n \tLOG_FUNC_CALLED(card->ctx);\n@@ -31,19 +32,21 @@\n \t}\n \tsc_file_free(file);\n \n-\t*tname = malloc(buf[1]);\n-\tif (*tname == NULL) {\n+\tname = malloc(buf[1]);\n+\tif (name == NULL) {\n \t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);\n \t}\n \n-\tr = iso_ops->read_binary(card, 2, (unsigned char *)*tname, buf[1], 0);\n+\tr = iso_ops->read_binary(card, 2, (unsigned char *)name, buf[1], 0);\n \tif (r < 1) {\n-\t\tfree(*tname);\n+\t\tfree(name);\n \t\tLOG_FUNC_RETURN(card->ctx, r);\n \t}\n \n-\tif ((*tname)[r-1] != '\\0') {\n-\t\t(*tname)[r-1] = '\\0';\n+\tif (name[r-1] != '\\0') {\n+\t\tname[r-1] = '\\0';\n \t}\n+\t*tname = name;\n+\n \tLOG_FUNC_RETURN(card->ctx, SC_SUCCESS);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\t*tname = malloc(buf[1]);",
                "\tif (*tname == NULL) {",
                "\tr = iso_ops->read_binary(card, 2, (unsigned char *)*tname, buf[1], 0);",
                "\t\tfree(*tname);",
                "\tif ((*tname)[r-1] != '\\0') {",
                "\t\t(*tname)[r-1] = '\\0';"
            ],
            "added_lines": [
                "\tchar *name;",
                "\tname = malloc(buf[1]);",
                "\tif (name == NULL) {",
                "\tr = iso_ops->read_binary(card, 2, (unsigned char *)name, buf[1], 0);",
                "\t\tfree(name);",
                "\tif (name[r-1] != '\\0') {",
                "\t\tname[r-1] = '\\0';",
                "\t*tname = name;",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2022-28738",
        "func_name": "ruby/onig_reg_resize",
        "description": "A double free was found in the Regexp compiler in Ruby 3.x before 3.0.4 and 3.1.x before 3.1.2. If a victim attempts to create a Regexp from untrusted user input, an attacker may be able to write to unexpected memory locations.",
        "git_url": "https://github.com/ruby/ruby/commit/73f45e5e96ccc13a131f7c0122cf8600ce5b930f",
        "commit_title": "Just free compiled pattern if no space is used",
        "commit_text": "",
        "func_before": "static void\nonig_reg_resize(regex_t *reg)\n{\n  resize:\n    if (reg->alloc > reg->used) {\n      unsigned char *new_ptr = xrealloc(reg->p, reg->used);\n      // Skip the right size optimization if memory allocation fails\n      if (new_ptr) {\n        reg->alloc = reg->used;\n        reg->p = new_ptr;\n      }\n    }\n    if (reg->chain) {\n      reg = reg->chain;\n      goto resize;\n    }\n}",
        "func": "static void\nonig_reg_resize(regex_t *reg)\n{\n  do {\n    if (!reg->used) {\n      xfree(reg->p);\n      reg->alloc = 0;\n      reg->p = 0;\n    }\n    else if (reg->alloc > reg->used) {\n      unsigned char *new_ptr = xrealloc(reg->p, reg->used);\n      // Skip the right size optimization if memory allocation fails\n      if (new_ptr) {\n        reg->alloc = reg->used;\n        reg->p = new_ptr;\n      }\n    }\n  } while ((reg = reg->chain) != 0);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,8 +1,13 @@\n static void\n onig_reg_resize(regex_t *reg)\n {\n-  resize:\n-    if (reg->alloc > reg->used) {\n+  do {\n+    if (!reg->used) {\n+      xfree(reg->p);\n+      reg->alloc = 0;\n+      reg->p = 0;\n+    }\n+    else if (reg->alloc > reg->used) {\n       unsigned char *new_ptr = xrealloc(reg->p, reg->used);\n       // Skip the right size optimization if memory allocation fails\n       if (new_ptr) {\n@@ -10,8 +15,5 @@\n         reg->p = new_ptr;\n       }\n     }\n-    if (reg->chain) {\n-      reg = reg->chain;\n-      goto resize;\n-    }\n+  } while ((reg = reg->chain) != 0);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "  resize:",
                "    if (reg->alloc > reg->used) {",
                "    if (reg->chain) {",
                "      reg = reg->chain;",
                "      goto resize;",
                "    }"
            ],
            "added_lines": [
                "  do {",
                "    if (!reg->used) {",
                "      xfree(reg->p);",
                "      reg->alloc = 0;",
                "      reg->p = 0;",
                "    }",
                "    else if (reg->alloc > reg->used) {",
                "  } while ((reg = reg->chain) != 0);"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-7480",
        "func_name": "torvalds/linux/blkcg_init_queue",
        "description": "The blkcg_init_queue function in block/blk-cgroup.c in the Linux kernel before 4.11 allows local users to cause a denial of service (double free) or possibly have unspecified other impact by triggering a creation failure.",
        "git_url": "https://github.com/torvalds/linux/commit/9b54d816e00425c3a517514e0d677bb3cec49258",
        "commit_title": "blkcg: fix double free of new_blkg in blkcg_init_queue",
        "commit_text": " If blkg_create fails, new_blkg passed as an argument will be freed by blkg_create, so there is no need to free it again. ",
        "func_before": "int blkcg_init_queue(struct request_queue *q)\n{\n\tstruct blkcg_gq *new_blkg, *blkg;\n\tbool preloaded;\n\tint ret;\n\n\tnew_blkg = blkg_alloc(&blkcg_root, q, GFP_KERNEL);\n\tif (!new_blkg)\n\t\treturn -ENOMEM;\n\n\tpreloaded = !radix_tree_preload(GFP_KERNEL);\n\n\t/*\n\t * Make sure the root blkg exists and count the existing blkgs.  As\n\t * @q is bypassing at this point, blkg_lookup_create() can't be\n\t * used.  Open code insertion.\n\t */\n\trcu_read_lock();\n\tspin_lock_irq(q->queue_lock);\n\tblkg = blkg_create(&blkcg_root, q, new_blkg);\n\tspin_unlock_irq(q->queue_lock);\n\trcu_read_unlock();\n\n\tif (preloaded)\n\t\tradix_tree_preload_end();\n\n\tif (IS_ERR(blkg)) {\n\t\tblkg_free(new_blkg);\n\t\treturn PTR_ERR(blkg);\n\t}\n\n\tq->root_blkg = blkg;\n\tq->root_rl.blkg = blkg;\n\n\tret = blk_throtl_init(q);\n\tif (ret) {\n\t\tspin_lock_irq(q->queue_lock);\n\t\tblkg_destroy_all(q);\n\t\tspin_unlock_irq(q->queue_lock);\n\t}\n\treturn ret;\n}",
        "func": "int blkcg_init_queue(struct request_queue *q)\n{\n\tstruct blkcg_gq *new_blkg, *blkg;\n\tbool preloaded;\n\tint ret;\n\n\tnew_blkg = blkg_alloc(&blkcg_root, q, GFP_KERNEL);\n\tif (!new_blkg)\n\t\treturn -ENOMEM;\n\n\tpreloaded = !radix_tree_preload(GFP_KERNEL);\n\n\t/*\n\t * Make sure the root blkg exists and count the existing blkgs.  As\n\t * @q is bypassing at this point, blkg_lookup_create() can't be\n\t * used.  Open code insertion.\n\t */\n\trcu_read_lock();\n\tspin_lock_irq(q->queue_lock);\n\tblkg = blkg_create(&blkcg_root, q, new_blkg);\n\tspin_unlock_irq(q->queue_lock);\n\trcu_read_unlock();\n\n\tif (preloaded)\n\t\tradix_tree_preload_end();\n\n\tif (IS_ERR(blkg))\n\t\treturn PTR_ERR(blkg);\n\n\tq->root_blkg = blkg;\n\tq->root_rl.blkg = blkg;\n\n\tret = blk_throtl_init(q);\n\tif (ret) {\n\t\tspin_lock_irq(q->queue_lock);\n\t\tblkg_destroy_all(q);\n\t\tspin_unlock_irq(q->queue_lock);\n\t}\n\treturn ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -24,10 +24,8 @@\n \tif (preloaded)\n \t\tradix_tree_preload_end();\n \n-\tif (IS_ERR(blkg)) {\n-\t\tblkg_free(new_blkg);\n+\tif (IS_ERR(blkg))\n \t\treturn PTR_ERR(blkg);\n-\t}\n \n \tq->root_blkg = blkg;\n \tq->root_rl.blkg = blkg;",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (IS_ERR(blkg)) {",
                "\t\tblkg_free(new_blkg);",
                "\t}"
            ],
            "added_lines": [
                "\tif (IS_ERR(blkg))"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-18201",
        "func_name": "libcdio/get_cdtext_generic",
        "description": "An issue was discovered in GNU libcdio before 2.0.0. There is a double free in get_cdtext_generic() in lib/driver/_cdio_generic.c.",
        "git_url": "https://git.savannah.gnu.org/cgit/libcdio.git/commit/?id=f6f9c48fb40b8a1e8218799724b0b61a7161eb1d",
        "commit_title": "",
        "commit_text": "",
        "func_before": "cdtext_t *\nget_cdtext_generic (void *p_user_data)\n{\n  generic_img_private_t *p_env = p_user_data;\n  uint8_t *p_cdtext_data = NULL;\n  size_t  len;\n\n  if (!p_env) return NULL;\n\n  if (p_env->b_cdtext_error) return NULL;\n\n  if (NULL == p_env->cdtext) {\n    p_cdtext_data = read_cdtext_generic (p_env);\n\n    if (NULL != p_cdtext_data) {\n      len = CDIO_MMC_GET_LEN16(p_cdtext_data)-2;\n      p_env->cdtext = cdtext_init();\n\n      if(len <= 0 || 0 != cdtext_data_init (p_env->cdtext, &p_cdtext_data[4], len)) {\n        p_env->b_cdtext_error = true;\n        cdtext_destroy (p_env->cdtext);\n        free(p_env->cdtext);\n        p_env->cdtext = NULL;\n      }\n\n      free(p_cdtext_data);\n    }\n  }\n\n  return p_env->cdtext;\n}",
        "func": "cdtext_t *\nget_cdtext_generic (void *p_user_data)\n{\n  generic_img_private_t *p_env = p_user_data;\n  uint8_t *p_cdtext_data = NULL;\n  size_t  len;\n\n  if (!p_env) return NULL;\n\n  if (p_env->b_cdtext_error) return NULL;\n\n  if (NULL == p_env->cdtext) {\n    p_cdtext_data = read_cdtext_generic (p_env);\n\n    if (NULL != p_cdtext_data) {\n      len = CDIO_MMC_GET_LEN16(p_cdtext_data)-2;\n      p_env->cdtext = cdtext_init();\n\n      if(len <= 0 || 0 != cdtext_data_init (p_env->cdtext, &p_cdtext_data[4], len)) {\n        p_env->b_cdtext_error = true;\n        free(p_env->cdtext);\n        p_env->cdtext = NULL;\n      }\n\n      free(p_cdtext_data);\n    }\n  }\n\n  return p_env->cdtext;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -18,7 +18,6 @@\n \n       if(len <= 0 || 0 != cdtext_data_init (p_env->cdtext, &p_cdtext_data[4], len)) {\n         p_env->b_cdtext_error = true;\n-        cdtext_destroy (p_env->cdtext);\n         free(p_env->cdtext);\n         p_env->cdtext = NULL;\n       }",
        "diff_line_info": {
            "deleted_lines": [
                "        cdtext_destroy (p_env->cdtext);"
            ],
            "added_lines": []
        }
    },
    {
        "cve_id": "CVE-2016-5768",
        "func_name": "php/php-src/php_mbregex_compile_pattern",
        "description": "Double free vulnerability in the _php_mb_regex_ereg_replace_exec function in php_mbregex.c in the mbstring extension in PHP before 5.5.37, 5.6.x before 5.6.23, and 7.x before 7.0.8 allows remote attackers to execute arbitrary code or cause a denial of service (application crash) by leveraging a callback exception.",
        "git_url": "https://github.com/php/php-src/commit/5b597a2e5b28e2d5a52fc1be13f425f08f47cb62",
        "commit_title": "Fix bug #72402: _php_mb_regex_ereg_replace_exec - double free",
        "commit_text": "",
        "func_before": "static php_mb_regex_t *php_mbregex_compile_pattern(const char *pattern, int patlen, OnigOptionType options, OnigEncoding enc, OnigSyntaxType *syntax TSRMLS_DC)\n{\n\tint err_code = 0;\n\tint found = 0;\n\tphp_mb_regex_t *retval = NULL, **rc = NULL;\n\tOnigErrorInfo err_info;\n\tOnigUChar err_str[ONIG_MAX_ERROR_MESSAGE_LEN];\n\n\tfound = zend_hash_find(&MBREX(ht_rc), (char *)pattern, patlen+1, (void **) &rc);\n\tif (found == FAILURE || (*rc)->options != options || (*rc)->enc != enc || (*rc)->syntax != syntax) {\n\t\tif ((err_code = onig_new(&retval, (OnigUChar *)pattern, (OnigUChar *)(pattern + patlen), options, enc, syntax, &err_info)) != ONIG_NORMAL) {\n\t\t\tonig_error_code_to_str(err_str, err_code, err_info);\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"mbregex compile err: %s\", err_str);\n\t\t\tretval = NULL;\n\t\t\tgoto out;\n\t\t}\n\t\tzend_hash_update(&MBREX(ht_rc), (char *) pattern, patlen + 1, (void *) &retval, sizeof(retval), NULL);\n\t} else if (found == SUCCESS) {\n\t\tretval = *rc;\n\t}\nout:\n\treturn retval; \n}",
        "func": "static php_mb_regex_t *php_mbregex_compile_pattern(const char *pattern, int patlen, OnigOptionType options, OnigEncoding enc, OnigSyntaxType *syntax TSRMLS_DC)\n{\n\tint err_code = 0;\n\tint found = 0;\n\tphp_mb_regex_t *retval = NULL, **rc = NULL;\n\tOnigErrorInfo err_info;\n\tOnigUChar err_str[ONIG_MAX_ERROR_MESSAGE_LEN];\n\n\tfound = zend_hash_find(&MBREX(ht_rc), (char *)pattern, patlen+1, (void **) &rc);\n\tif (found == FAILURE || (*rc)->options != options || (*rc)->enc != enc || (*rc)->syntax != syntax) {\n\t\tif ((err_code = onig_new(&retval, (OnigUChar *)pattern, (OnigUChar *)(pattern + patlen), options, enc, syntax, &err_info)) != ONIG_NORMAL) {\n\t\t\tonig_error_code_to_str(err_str, err_code, err_info);\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"mbregex compile err: %s\", err_str);\n\t\t\tretval = NULL;\n\t\t\tgoto out;\n\t\t}\n\t\tzend_hash_update(&MBREX(ht_rc), (char *) pattern, patlen + 1, (void *) &retval, sizeof(retval), NULL);\n\t} else if (found == SUCCESS) {\n\t\tretval = *rc;\n\t}\nout:\n\treturn retval;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -19,5 +19,5 @@\n \t\tretval = *rc;\n \t}\n out:\n-\treturn retval; \n+\treturn retval;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\treturn retval; "
            ],
            "added_lines": [
                "\treturn retval;"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-5768",
        "func_name": "php/php-src/_php_mb_regex_ereg_replace_exec",
        "description": "Double free vulnerability in the _php_mb_regex_ereg_replace_exec function in php_mbregex.c in the mbstring extension in PHP before 5.5.37, 5.6.x before 5.6.23, and 7.x before 7.0.8 allows remote attackers to execute arbitrary code or cause a denial of service (application crash) by leveraging a callback exception.",
        "git_url": "https://github.com/php/php-src/commit/5b597a2e5b28e2d5a52fc1be13f425f08f47cb62",
        "commit_title": "Fix bug #72402: _php_mb_regex_ereg_replace_exec - double free",
        "commit_text": "",
        "func_before": "static void _php_mb_regex_ereg_replace_exec(INTERNAL_FUNCTION_PARAMETERS, OnigOptionType options, int is_callable)\n{\n\tzval **arg_pattern_zval;\n\n\tchar *arg_pattern;\n\tint arg_pattern_len;\n\n\tchar *replace;\n\tint replace_len;\n\n\tzend_fcall_info arg_replace_fci;\n\tzend_fcall_info_cache arg_replace_fci_cache;\n\n\tchar *string;\n\tint string_len;\n\n\tchar *p;\n\tphp_mb_regex_t *re;\n\tOnigSyntaxType *syntax;\n\tOnigRegion *regs = NULL;\n\tsmart_str out_buf = { 0 };\n\tsmart_str eval_buf = { 0 };\n\tsmart_str *pbuf;\n\tint i, err, eval, n;\n\tOnigUChar *pos;\n\tOnigUChar *string_lim;\n\tchar *description = NULL;\n\tchar pat_buf[2];\n\n\tconst mbfl_encoding *enc;\n\n\t{\n\t\tconst char *current_enc_name;\n\t\tcurrent_enc_name = _php_mb_regex_mbctype2name(MBREX(current_mbctype));\n\t\tif (current_enc_name == NULL ||\n\t\t\t(enc = mbfl_name2encoding(current_enc_name)) == NULL) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unknown error\");\n\t\t\tRETURN_FALSE;\n\t\t}\n\t}\n\teval = 0;\n\t{\n\t\tchar *option_str = NULL;\n\t\tint option_str_len = 0;\n\n\t\tif (!is_callable) {\n\t\t\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"Zss|s\",\n\t\t\t\t\t\t&arg_pattern_zval,\n\t\t\t\t\t\t&replace, &replace_len,\n\t\t\t\t\t\t&string, &string_len,\n\t\t\t\t\t\t&option_str, &option_str_len) == FAILURE) {\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t} else {\n\t\t\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"Zfs|s\",\n\t\t\t\t\t\t&arg_pattern_zval,\n\t\t\t\t\t\t&arg_replace_fci, &arg_replace_fci_cache,\n\t\t\t\t\t\t&string, &string_len,\n\t\t\t\t\t\t&option_str, &option_str_len) == FAILURE) {\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t}\n\n\t\tif (option_str != NULL) {\n\t\t\t_php_mb_regex_init_options(option_str, option_str_len, &options, &syntax, &eval);\n\t\t} else {\n\t\t\toptions |= MBREX(regex_default_options);\n\t\t\tsyntax = MBREX(regex_default_syntax);\n\t\t}\n\t}\n\tif (Z_TYPE_PP(arg_pattern_zval) == IS_STRING) {\n\t\targ_pattern = Z_STRVAL_PP(arg_pattern_zval);\n\t\targ_pattern_len = Z_STRLEN_PP(arg_pattern_zval);\n\t} else {\n\t\t/* FIXME: this code is not multibyte aware! */\n\t\tconvert_to_long_ex(arg_pattern_zval);\n\t\tpat_buf[0] = (char)Z_LVAL_PP(arg_pattern_zval);\t\n\t\tpat_buf[1] = '\\0';\n\n\t\targ_pattern = pat_buf;\n\t\targ_pattern_len = 1;\t\n\t}\n\t/* create regex pattern buffer */\n\tre = php_mbregex_compile_pattern(arg_pattern, arg_pattern_len, options, MBREX(current_mbctype), syntax TSRMLS_CC);\n\tif (re == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (eval || is_callable) {\n\t\tpbuf = &eval_buf;\n\t\tdescription = zend_make_compiled_string_description(\"mbregex replace\" TSRMLS_CC);\n\t} else {\n\t\tpbuf = &out_buf;\n\t\tdescription = NULL;\n\t}\n\n\tif (is_callable) {\n\t\tif (eval) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Option 'e' cannot be used with replacement callback\");\n\t\t\tRETURN_FALSE;\n\t\t}\n\t}\n\n\t/* do the actual work */\n\terr = 0;\n\tpos = (OnigUChar *)string;\n\tstring_lim = (OnigUChar*)(string + string_len);\n\tregs = onig_region_new();\n\twhile (err >= 0) {\n\t\terr = onig_search(re, (OnigUChar *)string, (OnigUChar *)string_lim, pos, (OnigUChar *)string_lim, regs, 0);\n\t\tif (err <= -2) {\n\t\t\tOnigUChar err_str[ONIG_MAX_ERROR_MESSAGE_LEN];\n\t\t\tonig_error_code_to_str(err_str, err);\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"mbregex search failure in php_mbereg_replace_exec(): %s\", err_str);\n\t\t\tbreak;\n\t\t}\n\t\tif (err >= 0) {\n#if moriyoshi_0\n\t\t\tif (regs->beg[0] == regs->end[0]) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Empty regular expression\");\n\t\t\t\tbreak;\n\t\t\t}\n#endif\n\t\t\t/* copy the part of the string before the match */\n\t\t\tsmart_str_appendl(&out_buf, pos, (size_t)((OnigUChar *)(string + regs->beg[0]) - pos));\n\n\t\t\tif (!is_callable) {\n\t\t\t\t/* copy replacement and backrefs */\n\t\t\t\ti = 0;\n\t\t\t\tp = replace;\n\t\t\t\twhile (i < replace_len) {\n\t\t\t\t\tint fwd = (int) php_mb_mbchar_bytes_ex(p, enc);\n\t\t\t\t\tn = -1;\n\t\t\t\t\tif ((replace_len - i) >= 2 && fwd == 1 &&\n\t\t\t\t\tp[0] == '\\\\' && p[1] >= '0' && p[1] <= '9') {\n\t\t\t\t\t\tn = p[1] - '0';\n\t\t\t\t\t}\n\t\t\t\t\tif (n >= 0 && n < regs->num_regs) {\n\t\t\t\t\t\tif (regs->beg[n] >= 0 && regs->beg[n] < regs->end[n] && regs->end[n] <= string_len) {\n\t\t\t\t\t\t\tsmart_str_appendl(pbuf, string + regs->beg[n], regs->end[n] - regs->beg[n]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tp += 2;\n\t\t\t\t\t\ti += 2;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsmart_str_appendl(pbuf, p, fwd);\n\t\t\t\t\t\tp += fwd;\n\t\t\t\t\t\ti += fwd;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\t\n\t\t\tif (eval) {\n\t\t\t\tzval v;\n\t\t\t\t/* null terminate buffer */\n\t\t\t\tsmart_str_0(&eval_buf);\n\t\t\t\t/* do eval */\n\t\t\t\tif (zend_eval_stringl(eval_buf.c, eval_buf.len, &v, description TSRMLS_CC) == FAILURE) {\n\t\t\t\t\tefree(description);\n\t\t\t\t\tphp_error_docref(NULL TSRMLS_CC,E_ERROR, \"Failed evaluating code: %s%s\", PHP_EOL, eval_buf.c);\n\t\t\t\t\t/* zend_error() does not return in this case */\n\t\t\t\t}\n\n\t\t\t\t/* result of eval */\n\t\t\t\tconvert_to_string(&v);\n\t\t\t\tsmart_str_appendl(&out_buf, Z_STRVAL(v), Z_STRLEN(v));\n\t\t\t\t/* Clean up */\n\t\t\t\teval_buf.len = 0;\n\t\t\t\tzval_dtor(&v);\n\t\t\t} else if (is_callable) {\n\t\t\t\tzval *retval_ptr;\n\t\t\t\tzval **args[1];\n\t\t\t\tzval *subpats;\n\t\t\t\tint i;\n\t\t\t\t\n\t\t\t\tMAKE_STD_ZVAL(subpats);\n\t\t\t\tarray_init(subpats);\n\t\t\t\t\n\t\t\t\tfor (i = 0; i < regs->num_regs; i++) {\n\t\t\t\t\tadd_next_index_stringl(subpats, string + regs->beg[i], regs->end[i] - regs->beg[i], 1);\n\t\t\t\t}\t\t\t\t\n\t\t\t\t\n\t\t\t\targs[0] = &subpats;\n\t\t\t\t/* null terminate buffer */\n\t\t\t\tsmart_str_0(&eval_buf);\n\t\t\t\t\n\t\t\t\targ_replace_fci.param_count = 1;\n\t\t\t\targ_replace_fci.params = args;\n\t\t\t\targ_replace_fci.retval_ptr_ptr = &retval_ptr;\n\t\t\t\tif (zend_call_function(&arg_replace_fci, &arg_replace_fci_cache TSRMLS_CC) == SUCCESS && arg_replace_fci.retval_ptr_ptr) {\n\t\t\t\t\tconvert_to_string_ex(&retval_ptr);\n\t\t\t\t\tsmart_str_appendl(&out_buf, Z_STRVAL_P(retval_ptr), Z_STRLEN_P(retval_ptr));\n\t\t\t\t\teval_buf.len = 0;\n\t\t\t\t\tzval_ptr_dtor(&retval_ptr);\n\t\t\t\t} else {\n\t\t\t\t\tefree(description);\n\t\t\t\t\tif (!EG(exception)) {\n\t\t\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unable to call custom replacement function\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tzval_ptr_dtor(&subpats);\n\t\t\t}\n\n\t\t\tn = regs->end[0];\n\t\t\tif ((pos - (OnigUChar *)string) < n) {\n\t\t\t\tpos = (OnigUChar *)string + n;\n\t\t\t} else {\n\t\t\t\tif (pos < string_lim) {\n\t\t\t\t\tsmart_str_appendl(&out_buf, pos, 1); \n\t\t\t\t}\n\t\t\t\tpos++;\n\t\t\t}\n\t\t} else { /* nomatch */\n\t\t\t/* stick that last bit of string on our output */\n\t\t\tif (string_lim - pos > 0) {\n\t\t\t\tsmart_str_appendl(&out_buf, pos, string_lim - pos);\n\t\t\t}\n\t\t}\n\t\tonig_region_free(regs, 0);\n\t}\n\n\tif (description) {\n\t\tefree(description);\n\t}\n\tif (regs != NULL) {\n\t\tonig_region_free(regs, 1);\n\t}\n\tsmart_str_free(&eval_buf);\n\n\tif (err <= -2) {\n\t\tsmart_str_free(&out_buf);\t\n\t\tRETVAL_FALSE;\n\t} else {\n\t\tsmart_str_appendc(&out_buf, '\\0');\n\t\tRETVAL_STRINGL((char *)out_buf.c, out_buf.len - 1, 0);\n\t}\n}",
        "func": "static void _php_mb_regex_ereg_replace_exec(INTERNAL_FUNCTION_PARAMETERS, OnigOptionType options, int is_callable)\n{\n\tzval **arg_pattern_zval;\n\n\tchar *arg_pattern;\n\tint arg_pattern_len;\n\n\tchar *replace;\n\tint replace_len;\n\n\tzend_fcall_info arg_replace_fci;\n\tzend_fcall_info_cache arg_replace_fci_cache;\n\n\tchar *string;\n\tint string_len;\n\n\tchar *p;\n\tphp_mb_regex_t *re;\n\tOnigSyntaxType *syntax;\n\tOnigRegion *regs = NULL;\n\tsmart_str out_buf = { 0 };\n\tsmart_str eval_buf = { 0 };\n\tsmart_str *pbuf;\n\tint i, err, eval, n;\n\tOnigUChar *pos;\n\tOnigUChar *string_lim;\n\tchar *description = NULL;\n\tchar pat_buf[2];\n\n\tconst mbfl_encoding *enc;\n\n\t{\n\t\tconst char *current_enc_name;\n\t\tcurrent_enc_name = _php_mb_regex_mbctype2name(MBREX(current_mbctype));\n\t\tif (current_enc_name == NULL ||\n\t\t\t(enc = mbfl_name2encoding(current_enc_name)) == NULL) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unknown error\");\n\t\t\tRETURN_FALSE;\n\t\t}\n\t}\n\teval = 0;\n\t{\n\t\tchar *option_str = NULL;\n\t\tint option_str_len = 0;\n\n\t\tif (!is_callable) {\n\t\t\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"Zss|s\",\n\t\t\t\t\t\t&arg_pattern_zval,\n\t\t\t\t\t\t&replace, &replace_len,\n\t\t\t\t\t\t&string, &string_len,\n\t\t\t\t\t\t&option_str, &option_str_len) == FAILURE) {\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t} else {\n\t\t\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"Zfs|s\",\n\t\t\t\t\t\t&arg_pattern_zval,\n\t\t\t\t\t\t&arg_replace_fci, &arg_replace_fci_cache,\n\t\t\t\t\t\t&string, &string_len,\n\t\t\t\t\t\t&option_str, &option_str_len) == FAILURE) {\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t}\n\n\t\tif (option_str != NULL) {\n\t\t\t_php_mb_regex_init_options(option_str, option_str_len, &options, &syntax, &eval);\n\t\t} else {\n\t\t\toptions |= MBREX(regex_default_options);\n\t\t\tsyntax = MBREX(regex_default_syntax);\n\t\t}\n\t}\n\tif (Z_TYPE_PP(arg_pattern_zval) == IS_STRING) {\n\t\targ_pattern = Z_STRVAL_PP(arg_pattern_zval);\n\t\targ_pattern_len = Z_STRLEN_PP(arg_pattern_zval);\n\t} else {\n\t\t/* FIXME: this code is not multibyte aware! */\n\t\tconvert_to_long_ex(arg_pattern_zval);\n\t\tpat_buf[0] = (char)Z_LVAL_PP(arg_pattern_zval);\n\t\tpat_buf[1] = '\\0';\n\n\t\targ_pattern = pat_buf;\n\t\targ_pattern_len = 1;\n\t}\n\t/* create regex pattern buffer */\n\tre = php_mbregex_compile_pattern(arg_pattern, arg_pattern_len, options, MBREX(current_mbctype), syntax TSRMLS_CC);\n\tif (re == NULL) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (eval || is_callable) {\n\t\tpbuf = &eval_buf;\n\t\tdescription = zend_make_compiled_string_description(\"mbregex replace\" TSRMLS_CC);\n\t} else {\n\t\tpbuf = &out_buf;\n\t\tdescription = NULL;\n\t}\n\n\tif (is_callable) {\n\t\tif (eval) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Option 'e' cannot be used with replacement callback\");\n\t\t\tRETURN_FALSE;\n\t\t}\n\t}\n\n\t/* do the actual work */\n\terr = 0;\n\tpos = (OnigUChar *)string;\n\tstring_lim = (OnigUChar*)(string + string_len);\n\tregs = onig_region_new();\n\twhile (err >= 0) {\n\t\terr = onig_search(re, (OnigUChar *)string, (OnigUChar *)string_lim, pos, (OnigUChar *)string_lim, regs, 0);\n\t\tif (err <= -2) {\n\t\t\tOnigUChar err_str[ONIG_MAX_ERROR_MESSAGE_LEN];\n\t\t\tonig_error_code_to_str(err_str, err);\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"mbregex search failure in php_mbereg_replace_exec(): %s\", err_str);\n\t\t\tbreak;\n\t\t}\n\t\tif (err >= 0) {\n#if moriyoshi_0\n\t\t\tif (regs->beg[0] == regs->end[0]) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Empty regular expression\");\n\t\t\t\tbreak;\n\t\t\t}\n#endif\n\t\t\t/* copy the part of the string before the match */\n\t\t\tsmart_str_appendl(&out_buf, pos, (size_t)((OnigUChar *)(string + regs->beg[0]) - pos));\n\n\t\t\tif (!is_callable) {\n\t\t\t\t/* copy replacement and backrefs */\n\t\t\t\ti = 0;\n\t\t\t\tp = replace;\n\t\t\t\twhile (i < replace_len) {\n\t\t\t\t\tint fwd = (int) php_mb_mbchar_bytes_ex(p, enc);\n\t\t\t\t\tn = -1;\n\t\t\t\t\tif ((replace_len - i) >= 2 && fwd == 1 &&\n\t\t\t\t\tp[0] == '\\\\' && p[1] >= '0' && p[1] <= '9') {\n\t\t\t\t\t\tn = p[1] - '0';\n\t\t\t\t\t}\n\t\t\t\t\tif (n >= 0 && n < regs->num_regs) {\n\t\t\t\t\t\tif (regs->beg[n] >= 0 && regs->beg[n] < regs->end[n] && regs->end[n] <= string_len) {\n\t\t\t\t\t\t\tsmart_str_appendl(pbuf, string + regs->beg[n], regs->end[n] - regs->beg[n]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tp += 2;\n\t\t\t\t\t\ti += 2;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsmart_str_appendl(pbuf, p, fwd);\n\t\t\t\t\t\tp += fwd;\n\t\t\t\t\t\ti += fwd;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (eval) {\n\t\t\t\tzval v;\n\t\t\t\t/* null terminate buffer */\n\t\t\t\tsmart_str_0(&eval_buf);\n\t\t\t\t/* do eval */\n\t\t\t\tif (zend_eval_stringl(eval_buf.c, eval_buf.len, &v, description TSRMLS_CC) == FAILURE) {\n\t\t\t\t\tefree(description);\n\t\t\t\t\tphp_error_docref(NULL TSRMLS_CC,E_ERROR, \"Failed evaluating code: %s%s\", PHP_EOL, eval_buf.c);\n\t\t\t\t\t/* zend_error() does not return in this case */\n\t\t\t\t}\n\n\t\t\t\t/* result of eval */\n\t\t\t\tconvert_to_string(&v);\n\t\t\t\tsmart_str_appendl(&out_buf, Z_STRVAL(v), Z_STRLEN(v));\n\t\t\t\t/* Clean up */\n\t\t\t\teval_buf.len = 0;\n\t\t\t\tzval_dtor(&v);\n\t\t\t} else if (is_callable) {\n\t\t\t\tzval *retval_ptr = NULL;\n\t\t\t\tzval **args[1];\n\t\t\t\tzval *subpats;\n\t\t\t\tint i;\n\n\t\t\t\tMAKE_STD_ZVAL(subpats);\n\t\t\t\tarray_init(subpats);\n\n\t\t\t\tfor (i = 0; i < regs->num_regs; i++) {\n\t\t\t\t\tadd_next_index_stringl(subpats, string + regs->beg[i], regs->end[i] - regs->beg[i], 1);\n\t\t\t\t}\n\n\t\t\t\targs[0] = &subpats;\n\t\t\t\t/* null terminate buffer */\n\t\t\t\tsmart_str_0(&eval_buf);\n\n\t\t\t\targ_replace_fci.param_count = 1;\n\t\t\t\targ_replace_fci.params = args;\n\t\t\t\targ_replace_fci.retval_ptr_ptr = &retval_ptr;\n\t\t\t\tif (zend_call_function(&arg_replace_fci, &arg_replace_fci_cache TSRMLS_CC) == SUCCESS && arg_replace_fci.retval_ptr_ptr && retval_ptr) {\n\t\t\t\t\tconvert_to_string_ex(&retval_ptr);\n\t\t\t\t\tsmart_str_appendl(&out_buf, Z_STRVAL_P(retval_ptr), Z_STRLEN_P(retval_ptr));\n\t\t\t\t\teval_buf.len = 0;\n\t\t\t\t\tzval_ptr_dtor(&retval_ptr);\n\t\t\t\t} else {\n\t\t\t\t\tif (!EG(exception)) {\n\t\t\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unable to call custom replacement function\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tzval_ptr_dtor(&subpats);\n\t\t\t}\n\n\t\t\tn = regs->end[0];\n\t\t\tif ((pos - (OnigUChar *)string) < n) {\n\t\t\t\tpos = (OnigUChar *)string + n;\n\t\t\t} else {\n\t\t\t\tif (pos < string_lim) {\n\t\t\t\t\tsmart_str_appendl(&out_buf, pos, 1);\n\t\t\t\t}\n\t\t\t\tpos++;\n\t\t\t}\n\t\t} else { /* nomatch */\n\t\t\t/* stick that last bit of string on our output */\n\t\t\tif (string_lim - pos > 0) {\n\t\t\t\tsmart_str_appendl(&out_buf, pos, string_lim - pos);\n\t\t\t}\n\t\t}\n\t\tonig_region_free(regs, 0);\n\t}\n\n\tif (description) {\n\t\tefree(description);\n\t}\n\tif (regs != NULL) {\n\t\tonig_region_free(regs, 1);\n\t}\n\tsmart_str_free(&eval_buf);\n\n\tif (err <= -2) {\n\t\tsmart_str_free(&out_buf);\n\t\tRETVAL_FALSE;\n\t} else {\n\t\tsmart_str_appendc(&out_buf, '\\0');\n\t\tRETVAL_STRINGL((char *)out_buf.c, out_buf.len - 1, 0);\n\t}\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -74,11 +74,11 @@\n \t} else {\n \t\t/* FIXME: this code is not multibyte aware! */\n \t\tconvert_to_long_ex(arg_pattern_zval);\n-\t\tpat_buf[0] = (char)Z_LVAL_PP(arg_pattern_zval);\t\n+\t\tpat_buf[0] = (char)Z_LVAL_PP(arg_pattern_zval);\n \t\tpat_buf[1] = '\\0';\n \n \t\targ_pattern = pat_buf;\n-\t\targ_pattern_len = 1;\t\n+\t\targ_pattern_len = 1;\n \t}\n \t/* create regex pattern buffer */\n \tre = php_mbregex_compile_pattern(arg_pattern, arg_pattern_len, options, MBREX(current_mbctype), syntax TSRMLS_CC);\n@@ -148,7 +148,7 @@\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n-\t\t\t\t\n+\n \t\t\tif (eval) {\n \t\t\t\tzval v;\n \t\t\t\t/* null terminate buffer */\n@@ -167,32 +167,31 @@\n \t\t\t\teval_buf.len = 0;\n \t\t\t\tzval_dtor(&v);\n \t\t\t} else if (is_callable) {\n-\t\t\t\tzval *retval_ptr;\n+\t\t\t\tzval *retval_ptr = NULL;\n \t\t\t\tzval **args[1];\n \t\t\t\tzval *subpats;\n \t\t\t\tint i;\n-\t\t\t\t\n+\n \t\t\t\tMAKE_STD_ZVAL(subpats);\n \t\t\t\tarray_init(subpats);\n-\t\t\t\t\n+\n \t\t\t\tfor (i = 0; i < regs->num_regs; i++) {\n \t\t\t\t\tadd_next_index_stringl(subpats, string + regs->beg[i], regs->end[i] - regs->beg[i], 1);\n-\t\t\t\t}\t\t\t\t\n-\t\t\t\t\n+\t\t\t\t}\n+\n \t\t\t\targs[0] = &subpats;\n \t\t\t\t/* null terminate buffer */\n \t\t\t\tsmart_str_0(&eval_buf);\n-\t\t\t\t\n+\n \t\t\t\targ_replace_fci.param_count = 1;\n \t\t\t\targ_replace_fci.params = args;\n \t\t\t\targ_replace_fci.retval_ptr_ptr = &retval_ptr;\n-\t\t\t\tif (zend_call_function(&arg_replace_fci, &arg_replace_fci_cache TSRMLS_CC) == SUCCESS && arg_replace_fci.retval_ptr_ptr) {\n+\t\t\t\tif (zend_call_function(&arg_replace_fci, &arg_replace_fci_cache TSRMLS_CC) == SUCCESS && arg_replace_fci.retval_ptr_ptr && retval_ptr) {\n \t\t\t\t\tconvert_to_string_ex(&retval_ptr);\n \t\t\t\t\tsmart_str_appendl(&out_buf, Z_STRVAL_P(retval_ptr), Z_STRLEN_P(retval_ptr));\n \t\t\t\t\teval_buf.len = 0;\n \t\t\t\t\tzval_ptr_dtor(&retval_ptr);\n \t\t\t\t} else {\n-\t\t\t\t\tefree(description);\n \t\t\t\t\tif (!EG(exception)) {\n \t\t\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unable to call custom replacement function\");\n \t\t\t\t\t}\n@@ -205,7 +204,7 @@\n \t\t\t\tpos = (OnigUChar *)string + n;\n \t\t\t} else {\n \t\t\t\tif (pos < string_lim) {\n-\t\t\t\t\tsmart_str_appendl(&out_buf, pos, 1); \n+\t\t\t\t\tsmart_str_appendl(&out_buf, pos, 1);\n \t\t\t\t}\n \t\t\t\tpos++;\n \t\t\t}\n@@ -227,7 +226,7 @@\n \tsmart_str_free(&eval_buf);\n \n \tif (err <= -2) {\n-\t\tsmart_str_free(&out_buf);\t\n+\t\tsmart_str_free(&out_buf);\n \t\tRETVAL_FALSE;\n \t} else {\n \t\tsmart_str_appendc(&out_buf, '\\0');",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tpat_buf[0] = (char)Z_LVAL_PP(arg_pattern_zval);\t",
                "\t\targ_pattern_len = 1;\t",
                "\t\t\t\t",
                "\t\t\t\tzval *retval_ptr;",
                "\t\t\t\t",
                "\t\t\t\t",
                "\t\t\t\t}\t\t\t\t",
                "\t\t\t\t",
                "\t\t\t\t",
                "\t\t\t\tif (zend_call_function(&arg_replace_fci, &arg_replace_fci_cache TSRMLS_CC) == SUCCESS && arg_replace_fci.retval_ptr_ptr) {",
                "\t\t\t\t\tefree(description);",
                "\t\t\t\t\tsmart_str_appendl(&out_buf, pos, 1); ",
                "\t\tsmart_str_free(&out_buf);\t"
            ],
            "added_lines": [
                "\t\tpat_buf[0] = (char)Z_LVAL_PP(arg_pattern_zval);",
                "\t\targ_pattern_len = 1;",
                "",
                "\t\t\t\tzval *retval_ptr = NULL;",
                "",
                "",
                "\t\t\t\t}",
                "",
                "",
                "\t\t\t\tif (zend_call_function(&arg_replace_fci, &arg_replace_fci_cache TSRMLS_CC) == SUCCESS && arg_replace_fci.retval_ptr_ptr && retval_ptr) {",
                "\t\t\t\t\tsmart_str_appendl(&out_buf, pos, 1);",
                "\t\tsmart_str_free(&out_buf);"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-5768",
        "func_name": "php/php-src/_php_mb_regex_get_option_string",
        "description": "Double free vulnerability in the _php_mb_regex_ereg_replace_exec function in php_mbregex.c in the mbstring extension in PHP before 5.5.37, 5.6.x before 5.6.23, and 7.x before 7.0.8 allows remote attackers to execute arbitrary code or cause a denial of service (application crash) by leveraging a callback exception.",
        "git_url": "https://github.com/php/php-src/commit/5b597a2e5b28e2d5a52fc1be13f425f08f47cb62",
        "commit_title": "Fix bug #72402: _php_mb_regex_ereg_replace_exec - double free",
        "commit_text": "",
        "func_before": "static size_t _php_mb_regex_get_option_string(char *str, size_t len, OnigOptionType option, OnigSyntaxType *syntax)\n{\n\tsize_t len_left = len;\n\tsize_t len_req = 0;\n\tchar *p = str;\n\tchar c;\n\n\tif ((option & ONIG_OPTION_IGNORECASE) != 0) {\n\t\tif (len_left > 0) {\n\t\t\t--len_left;\n\t\t\t*(p++) = 'i';\n\t\t}\n\t\t++len_req;\t\n\t}\n\n\tif ((option & ONIG_OPTION_EXTEND) != 0) {\n\t\tif (len_left > 0) {\n\t\t\t--len_left;\n\t\t\t*(p++) = 'x';\n\t\t}\n\t\t++len_req;\t\n\t}\n\n\tif ((option & (ONIG_OPTION_MULTILINE | ONIG_OPTION_SINGLELINE)) ==\n\t\t\t(ONIG_OPTION_MULTILINE | ONIG_OPTION_SINGLELINE)) {\n\t\tif (len_left > 0) {\n\t\t\t--len_left;\n\t\t\t*(p++) = 'p';\n\t\t}\n\t\t++len_req;\t\n\t} else {\n\t\tif ((option & ONIG_OPTION_MULTILINE) != 0) {\n\t\t\tif (len_left > 0) {\n\t\t\t\t--len_left;\n\t\t\t\t*(p++) = 'm';\n\t\t\t}\n\t\t\t++len_req;\t\n\t\t}\n\n\t\tif ((option & ONIG_OPTION_SINGLELINE) != 0) {\n\t\t\tif (len_left > 0) {\n\t\t\t\t--len_left;\n\t\t\t\t*(p++) = 's';\n\t\t\t}\n\t\t\t++len_req;\t\n\t\t}\n\t}\t\n\tif ((option & ONIG_OPTION_FIND_LONGEST) != 0) {\n\t\tif (len_left > 0) {\n\t\t\t--len_left;\n\t\t\t*(p++) = 'l';\n\t\t}\n\t\t++len_req;\t\n\t}\n\tif ((option & ONIG_OPTION_FIND_NOT_EMPTY) != 0) {\n\t\tif (len_left > 0) {\n\t\t\t--len_left;\n\t\t\t*(p++) = 'n';\n\t\t}\n\t\t++len_req;\t\n\t}\n\n\tc = 0;\n\n\tif (syntax == ONIG_SYNTAX_JAVA) {\n\t\tc = 'j';\n\t} else if (syntax == ONIG_SYNTAX_GNU_REGEX) {\n\t\tc = 'u';\n\t} else if (syntax == ONIG_SYNTAX_GREP) {\n\t\tc = 'g';\n\t} else if (syntax == ONIG_SYNTAX_EMACS) {\n\t\tc = 'c';\n\t} else if (syntax == ONIG_SYNTAX_RUBY) {\n\t\tc = 'r';\n\t} else if (syntax == ONIG_SYNTAX_PERL) {\n\t\tc = 'z';\n\t} else if (syntax == ONIG_SYNTAX_POSIX_BASIC) {\n\t\tc = 'b';\n\t} else if (syntax == ONIG_SYNTAX_POSIX_EXTENDED) {\n\t\tc = 'd';\n\t}\n\n\tif (c != 0) {\n\t\tif (len_left > 0) {\n\t\t\t--len_left;\n\t\t\t*(p++) = c;\n\t\t}\n\t\t++len_req;\n\t}\n\n\n\tif (len_left > 0) {\n\t\t--len_left;\n\t\t*(p++) = '\\0';\n\t}\n\t++len_req;\t\n\tif (len < len_req) {\n\t\treturn len_req;\n\t}\n\n\treturn 0;\n}",
        "func": "static size_t _php_mb_regex_get_option_string(char *str, size_t len, OnigOptionType option, OnigSyntaxType *syntax)\n{\n\tsize_t len_left = len;\n\tsize_t len_req = 0;\n\tchar *p = str;\n\tchar c;\n\n\tif ((option & ONIG_OPTION_IGNORECASE) != 0) {\n\t\tif (len_left > 0) {\n\t\t\t--len_left;\n\t\t\t*(p++) = 'i';\n\t\t}\n\t\t++len_req;\n\t}\n\n\tif ((option & ONIG_OPTION_EXTEND) != 0) {\n\t\tif (len_left > 0) {\n\t\t\t--len_left;\n\t\t\t*(p++) = 'x';\n\t\t}\n\t\t++len_req;\n\t}\n\n\tif ((option & (ONIG_OPTION_MULTILINE | ONIG_OPTION_SINGLELINE)) ==\n\t\t\t(ONIG_OPTION_MULTILINE | ONIG_OPTION_SINGLELINE)) {\n\t\tif (len_left > 0) {\n\t\t\t--len_left;\n\t\t\t*(p++) = 'p';\n\t\t}\n\t\t++len_req;\n\t} else {\n\t\tif ((option & ONIG_OPTION_MULTILINE) != 0) {\n\t\t\tif (len_left > 0) {\n\t\t\t\t--len_left;\n\t\t\t\t*(p++) = 'm';\n\t\t\t}\n\t\t\t++len_req;\n\t\t}\n\n\t\tif ((option & ONIG_OPTION_SINGLELINE) != 0) {\n\t\t\tif (len_left > 0) {\n\t\t\t\t--len_left;\n\t\t\t\t*(p++) = 's';\n\t\t\t}\n\t\t\t++len_req;\n\t\t}\n\t}\n\tif ((option & ONIG_OPTION_FIND_LONGEST) != 0) {\n\t\tif (len_left > 0) {\n\t\t\t--len_left;\n\t\t\t*(p++) = 'l';\n\t\t}\n\t\t++len_req;\n\t}\n\tif ((option & ONIG_OPTION_FIND_NOT_EMPTY) != 0) {\n\t\tif (len_left > 0) {\n\t\t\t--len_left;\n\t\t\t*(p++) = 'n';\n\t\t}\n\t\t++len_req;\n\t}\n\n\tc = 0;\n\n\tif (syntax == ONIG_SYNTAX_JAVA) {\n\t\tc = 'j';\n\t} else if (syntax == ONIG_SYNTAX_GNU_REGEX) {\n\t\tc = 'u';\n\t} else if (syntax == ONIG_SYNTAX_GREP) {\n\t\tc = 'g';\n\t} else if (syntax == ONIG_SYNTAX_EMACS) {\n\t\tc = 'c';\n\t} else if (syntax == ONIG_SYNTAX_RUBY) {\n\t\tc = 'r';\n\t} else if (syntax == ONIG_SYNTAX_PERL) {\n\t\tc = 'z';\n\t} else if (syntax == ONIG_SYNTAX_POSIX_BASIC) {\n\t\tc = 'b';\n\t} else if (syntax == ONIG_SYNTAX_POSIX_EXTENDED) {\n\t\tc = 'd';\n\t}\n\n\tif (c != 0) {\n\t\tif (len_left > 0) {\n\t\t\t--len_left;\n\t\t\t*(p++) = c;\n\t\t}\n\t\t++len_req;\n\t}\n\n\n\tif (len_left > 0) {\n\t\t--len_left;\n\t\t*(p++) = '\\0';\n\t}\n\t++len_req;\n\tif (len < len_req) {\n\t\treturn len_req;\n\t}\n\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -10,7 +10,7 @@\n \t\t\t--len_left;\n \t\t\t*(p++) = 'i';\n \t\t}\n-\t\t++len_req;\t\n+\t\t++len_req;\n \t}\n \n \tif ((option & ONIG_OPTION_EXTEND) != 0) {\n@@ -18,7 +18,7 @@\n \t\t\t--len_left;\n \t\t\t*(p++) = 'x';\n \t\t}\n-\t\t++len_req;\t\n+\t\t++len_req;\n \t}\n \n \tif ((option & (ONIG_OPTION_MULTILINE | ONIG_OPTION_SINGLELINE)) ==\n@@ -27,14 +27,14 @@\n \t\t\t--len_left;\n \t\t\t*(p++) = 'p';\n \t\t}\n-\t\t++len_req;\t\n+\t\t++len_req;\n \t} else {\n \t\tif ((option & ONIG_OPTION_MULTILINE) != 0) {\n \t\t\tif (len_left > 0) {\n \t\t\t\t--len_left;\n \t\t\t\t*(p++) = 'm';\n \t\t\t}\n-\t\t\t++len_req;\t\n+\t\t\t++len_req;\n \t\t}\n \n \t\tif ((option & ONIG_OPTION_SINGLELINE) != 0) {\n@@ -42,22 +42,22 @@\n \t\t\t\t--len_left;\n \t\t\t\t*(p++) = 's';\n \t\t\t}\n-\t\t\t++len_req;\t\n+\t\t\t++len_req;\n \t\t}\n-\t}\t\n+\t}\n \tif ((option & ONIG_OPTION_FIND_LONGEST) != 0) {\n \t\tif (len_left > 0) {\n \t\t\t--len_left;\n \t\t\t*(p++) = 'l';\n \t\t}\n-\t\t++len_req;\t\n+\t\t++len_req;\n \t}\n \tif ((option & ONIG_OPTION_FIND_NOT_EMPTY) != 0) {\n \t\tif (len_left > 0) {\n \t\t\t--len_left;\n \t\t\t*(p++) = 'n';\n \t\t}\n-\t\t++len_req;\t\n+\t\t++len_req;\n \t}\n \n \tc = 0;\n@@ -93,7 +93,7 @@\n \t\t--len_left;\n \t\t*(p++) = '\\0';\n \t}\n-\t++len_req;\t\n+\t++len_req;\n \tif (len < len_req) {\n \t\treturn len_req;\n \t}",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t++len_req;\t",
                "\t\t++len_req;\t",
                "\t\t++len_req;\t",
                "\t\t\t++len_req;\t",
                "\t\t\t++len_req;\t",
                "\t}\t",
                "\t\t++len_req;\t",
                "\t\t++len_req;\t",
                "\t++len_req;\t"
            ],
            "added_lines": [
                "\t\t++len_req;",
                "\t\t++len_req;",
                "\t\t++len_req;",
                "\t\t\t++len_req;",
                "\t\t\t++len_req;",
                "\t}",
                "\t\t++len_req;",
                "\t\t++len_req;",
                "\t++len_req;"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-5768",
        "func_name": "php/php-src/php_mb_regex_free_cache",
        "description": "Double free vulnerability in the _php_mb_regex_ereg_replace_exec function in php_mbregex.c in the mbstring extension in PHP before 5.5.37, 5.6.x before 5.6.23, and 7.x before 7.0.8 allows remote attackers to execute arbitrary code or cause a denial of service (application crash) by leveraging a callback exception.",
        "git_url": "https://github.com/php/php-src/commit/5b597a2e5b28e2d5a52fc1be13f425f08f47cb62",
        "commit_title": "Fix bug #72402: _php_mb_regex_ereg_replace_exec - double free",
        "commit_text": "",
        "func_before": "static void php_mb_regex_free_cache(php_mb_regex_t **pre) \n{\n\tonig_free(*pre);\n}",
        "func": "static void php_mb_regex_free_cache(php_mb_regex_t **pre)\n{\n\tonig_free(*pre);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,4 @@\n-static void php_mb_regex_free_cache(php_mb_regex_t **pre) \n+static void php_mb_regex_free_cache(php_mb_regex_t **pre)\n {\n \tonig_free(*pre);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "static void php_mb_regex_free_cache(php_mb_regex_t **pre) "
            ],
            "added_lines": [
                "static void php_mb_regex_free_cache(php_mb_regex_t **pre)"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-5768",
        "func_name": "php/php-src/_php_mb_regex_init_options",
        "description": "Double free vulnerability in the _php_mb_regex_ereg_replace_exec function in php_mbregex.c in the mbstring extension in PHP before 5.5.37, 5.6.x before 5.6.23, and 7.x before 7.0.8 allows remote attackers to execute arbitrary code or cause a denial of service (application crash) by leveraging a callback exception.",
        "git_url": "https://github.com/php/php-src/commit/5b597a2e5b28e2d5a52fc1be13f425f08f47cb62",
        "commit_title": "Fix bug #72402: _php_mb_regex_ereg_replace_exec - double free",
        "commit_text": "",
        "func_before": "static void\n_php_mb_regex_init_options(const char *parg, int narg, OnigOptionType *option, OnigSyntaxType **syntax, int *eval) \n{\n\tint n;\n\tchar c;\n\tint optm = 0; \n\n\t*syntax = ONIG_SYNTAX_RUBY;\n\n\tif (parg != NULL) {\n\t\tn = 0;\n\t\twhile(n < narg) {\n\t\t\tc = parg[n++];\n\t\t\tswitch (c) {\n\t\t\t\tcase 'i':\n\t\t\t\t\toptm |= ONIG_OPTION_IGNORECASE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'x':\n\t\t\t\t\toptm |= ONIG_OPTION_EXTEND;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'm':\n\t\t\t\t\toptm |= ONIG_OPTION_MULTILINE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 's':\n\t\t\t\t\toptm |= ONIG_OPTION_SINGLELINE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'p':\n\t\t\t\t\toptm |= ONIG_OPTION_MULTILINE | ONIG_OPTION_SINGLELINE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'l':\n\t\t\t\t\toptm |= ONIG_OPTION_FIND_LONGEST;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'n':\n\t\t\t\t\toptm |= ONIG_OPTION_FIND_NOT_EMPTY;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'j':\n\t\t\t\t\t*syntax = ONIG_SYNTAX_JAVA;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'u':\n\t\t\t\t\t*syntax = ONIG_SYNTAX_GNU_REGEX;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'g':\n\t\t\t\t\t*syntax = ONIG_SYNTAX_GREP;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'c':\n\t\t\t\t\t*syntax = ONIG_SYNTAX_EMACS;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'r':\n\t\t\t\t\t*syntax = ONIG_SYNTAX_RUBY;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'z':\n\t\t\t\t\t*syntax = ONIG_SYNTAX_PERL;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'b':\n\t\t\t\t\t*syntax = ONIG_SYNTAX_POSIX_BASIC;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'd':\n\t\t\t\t\t*syntax = ONIG_SYNTAX_POSIX_EXTENDED;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'e':\n\t\t\t\t\tif (eval != NULL) *eval = 1; \n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (option != NULL) *option|=optm; \n\t}\n}",
        "func": "static void\n_php_mb_regex_init_options(const char *parg, int narg, OnigOptionType *option, OnigSyntaxType **syntax, int *eval)\n{\n\tint n;\n\tchar c;\n\tint optm = 0;\n\n\t*syntax = ONIG_SYNTAX_RUBY;\n\n\tif (parg != NULL) {\n\t\tn = 0;\n\t\twhile(n < narg) {\n\t\t\tc = parg[n++];\n\t\t\tswitch (c) {\n\t\t\t\tcase 'i':\n\t\t\t\t\toptm |= ONIG_OPTION_IGNORECASE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'x':\n\t\t\t\t\toptm |= ONIG_OPTION_EXTEND;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'm':\n\t\t\t\t\toptm |= ONIG_OPTION_MULTILINE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 's':\n\t\t\t\t\toptm |= ONIG_OPTION_SINGLELINE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'p':\n\t\t\t\t\toptm |= ONIG_OPTION_MULTILINE | ONIG_OPTION_SINGLELINE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'l':\n\t\t\t\t\toptm |= ONIG_OPTION_FIND_LONGEST;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'n':\n\t\t\t\t\toptm |= ONIG_OPTION_FIND_NOT_EMPTY;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'j':\n\t\t\t\t\t*syntax = ONIG_SYNTAX_JAVA;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'u':\n\t\t\t\t\t*syntax = ONIG_SYNTAX_GNU_REGEX;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'g':\n\t\t\t\t\t*syntax = ONIG_SYNTAX_GREP;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'c':\n\t\t\t\t\t*syntax = ONIG_SYNTAX_EMACS;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'r':\n\t\t\t\t\t*syntax = ONIG_SYNTAX_RUBY;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'z':\n\t\t\t\t\t*syntax = ONIG_SYNTAX_PERL;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'b':\n\t\t\t\t\t*syntax = ONIG_SYNTAX_POSIX_BASIC;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'd':\n\t\t\t\t\t*syntax = ONIG_SYNTAX_POSIX_EXTENDED;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'e':\n\t\t\t\t\tif (eval != NULL) *eval = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (option != NULL) *option|=optm;\n\t}\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,9 +1,9 @@\n static void\n-_php_mb_regex_init_options(const char *parg, int narg, OnigOptionType *option, OnigSyntaxType **syntax, int *eval) \n+_php_mb_regex_init_options(const char *parg, int narg, OnigOptionType *option, OnigSyntaxType **syntax, int *eval)\n {\n \tint n;\n \tchar c;\n-\tint optm = 0; \n+\tint optm = 0;\n \n \t*syntax = ONIG_SYNTAX_RUBY;\n \n@@ -58,12 +58,12 @@\n \t\t\t\t\t*syntax = ONIG_SYNTAX_POSIX_EXTENDED;\n \t\t\t\t\tbreak;\n \t\t\t\tcase 'e':\n-\t\t\t\t\tif (eval != NULL) *eval = 1; \n+\t\t\t\t\tif (eval != NULL) *eval = 1;\n \t\t\t\t\tbreak;\n \t\t\t\tdefault:\n \t\t\t\t\tbreak;\n \t\t\t}\n \t\t}\n-\t\tif (option != NULL) *option|=optm; \n+\t\tif (option != NULL) *option|=optm;\n \t}\n }",
        "diff_line_info": {
            "deleted_lines": [
                "_php_mb_regex_init_options(const char *parg, int narg, OnigOptionType *option, OnigSyntaxType **syntax, int *eval) ",
                "\tint optm = 0; ",
                "\t\t\t\t\tif (eval != NULL) *eval = 1; ",
                "\t\tif (option != NULL) *option|=optm; "
            ],
            "added_lines": [
                "_php_mb_regex_init_options(const char *parg, int narg, OnigOptionType *option, OnigSyntaxType **syntax, int *eval)",
                "\tint optm = 0;",
                "\t\t\t\t\tif (eval != NULL) *eval = 1;",
                "\t\tif (option != NULL) *option|=optm;"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-5768",
        "func_name": "php/php-src/_php_mb_regex_set_options",
        "description": "Double free vulnerability in the _php_mb_regex_ereg_replace_exec function in php_mbregex.c in the mbstring extension in PHP before 5.5.37, 5.6.x before 5.6.23, and 7.x before 7.0.8 allows remote attackers to execute arbitrary code or cause a denial of service (application crash) by leveraging a callback exception.",
        "git_url": "https://github.com/php/php-src/commit/5b597a2e5b28e2d5a52fc1be13f425f08f47cb62",
        "commit_title": "Fix bug #72402: _php_mb_regex_ereg_replace_exec - double free",
        "commit_text": "",
        "func_before": "static void _php_mb_regex_set_options(OnigOptionType options, OnigSyntaxType *syntax, OnigOptionType *prev_options, OnigSyntaxType **prev_syntax TSRMLS_DC) \n{\n\tif (prev_options != NULL) {\n\t\t*prev_options = MBREX(regex_default_options);\n\t}\n\tif (prev_syntax != NULL) {\n\t\t*prev_syntax = MBREX(regex_default_syntax);\n\t}\n\tMBREX(regex_default_options) = options;\n\tMBREX(regex_default_syntax) = syntax;\n}",
        "func": "static void _php_mb_regex_set_options(OnigOptionType options, OnigSyntaxType *syntax, OnigOptionType *prev_options, OnigSyntaxType **prev_syntax TSRMLS_DC)\n{\n\tif (prev_options != NULL) {\n\t\t*prev_options = MBREX(regex_default_options);\n\t}\n\tif (prev_syntax != NULL) {\n\t\t*prev_syntax = MBREX(regex_default_syntax);\n\t}\n\tMBREX(regex_default_options) = options;\n\tMBREX(regex_default_syntax) = syntax;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,4 @@\n-static void _php_mb_regex_set_options(OnigOptionType options, OnigSyntaxType *syntax, OnigOptionType *prev_options, OnigSyntaxType **prev_syntax TSRMLS_DC) \n+static void _php_mb_regex_set_options(OnigOptionType options, OnigSyntaxType *syntax, OnigOptionType *prev_options, OnigSyntaxType **prev_syntax TSRMLS_DC)\n {\n \tif (prev_options != NULL) {\n \t\t*prev_options = MBREX(regex_default_options);",
        "diff_line_info": {
            "deleted_lines": [
                "static void _php_mb_regex_set_options(OnigOptionType options, OnigSyntaxType *syntax, OnigOptionType *prev_options, OnigSyntaxType **prev_syntax TSRMLS_DC) "
            ],
            "added_lines": [
                "static void _php_mb_regex_set_options(OnigOptionType options, OnigSyntaxType *syntax, OnigOptionType *prev_options, OnigSyntaxType **prev_syntax TSRMLS_DC)"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-5768",
        "func_name": "php/php-src/_php_mb_regex_globals_dtor",
        "description": "Double free vulnerability in the _php_mb_regex_ereg_replace_exec function in php_mbregex.c in the mbstring extension in PHP before 5.5.37, 5.6.x before 5.6.23, and 7.x before 7.0.8 allows remote attackers to execute arbitrary code or cause a denial of service (application crash) by leveraging a callback exception.",
        "git_url": "https://github.com/php/php-src/commit/5b597a2e5b28e2d5a52fc1be13f425f08f47cb62",
        "commit_title": "Fix bug #72402: _php_mb_regex_ereg_replace_exec - double free",
        "commit_text": "",
        "func_before": "static void _php_mb_regex_globals_dtor(zend_mb_regex_globals *pglobals TSRMLS_DC) \n{\n\tzend_hash_destroy(&pglobals->ht_rc);\n}",
        "func": "static void _php_mb_regex_globals_dtor(zend_mb_regex_globals *pglobals TSRMLS_DC)\n{\n\tzend_hash_destroy(&pglobals->ht_rc);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,4 @@\n-static void _php_mb_regex_globals_dtor(zend_mb_regex_globals *pglobals TSRMLS_DC) \n+static void _php_mb_regex_globals_dtor(zend_mb_regex_globals *pglobals TSRMLS_DC)\n {\n \tzend_hash_destroy(&pglobals->ht_rc);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "static void _php_mb_regex_globals_dtor(zend_mb_regex_globals *pglobals TSRMLS_DC) "
            ],
            "added_lines": [
                "static void _php_mb_regex_globals_dtor(zend_mb_regex_globals *pglobals TSRMLS_DC)"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-5772",
        "func_name": "php/php-src/php_wddx_process_data",
        "description": "Double free vulnerability in the php_wddx_process_data function in wddx.c in the WDDX extension in PHP before 5.5.37, 5.6.x before 5.6.23, and 7.x before 7.0.8 allows remote attackers to cause a denial of service (application crash) or possibly execute arbitrary code via crafted XML data that is mishandled in a wddx_deserialize call.",
        "git_url": "https://github.com/php/php-src/commit/a44c89e8af7c2410f4bfc5e097be2a5d0639a60c",
        "commit_title": "Fix bug #72340: Double Free Courruption in wddx_deserialize",
        "commit_text": "",
        "func_before": "static void php_wddx_process_data(void *user_data, const XML_Char *s, int len)\n{\n\tst_entry *ent;\n\twddx_stack *stack = (wddx_stack *)user_data;\n\tTSRMLS_FETCH();\n\n\tif (!wddx_stack_is_empty(stack) && !stack->done) {\n\t\twddx_stack_top(stack, (void**)&ent);\n\t\tswitch (ent->type) {\n\t\t\tcase ST_STRING:\n\t\t\t\tif (Z_STRLEN_P(ent->data) == 0) {\n\t\t\t\t\tSTR_FREE(Z_STRVAL_P(ent->data));\n\t\t\t\t\tZ_STRVAL_P(ent->data) = estrndup(s, len);\n\t\t\t\t\tZ_STRLEN_P(ent->data) = len;\n\t\t\t\t} else {\n\t\t\t\t\tZ_STRVAL_P(ent->data) = erealloc(Z_STRVAL_P(ent->data), Z_STRLEN_P(ent->data) + len + 1);\n\t\t\t\t\tmemcpy(Z_STRVAL_P(ent->data) + Z_STRLEN_P(ent->data), s, len);\n\t\t\t\t\tZ_STRLEN_P(ent->data) += len;\n\t\t\t\t\tZ_STRVAL_P(ent->data)[Z_STRLEN_P(ent->data)] = '\\0';\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase ST_BINARY:\n\t\t\t\tif (Z_STRLEN_P(ent->data) == 0) {\n\t\t\t\t\tSTR_FREE(Z_STRVAL_P(ent->data));\n\t\t\t\t\tZ_STRVAL_P(ent->data) = estrndup(s, len + 1);\n\t\t\t\t} else {\n\t\t\t\t\tZ_STRVAL_P(ent->data) = erealloc(Z_STRVAL_P(ent->data), Z_STRLEN_P(ent->data) + len + 1);\n\t\t\t\t\tmemcpy(Z_STRVAL_P(ent->data) + Z_STRLEN_P(ent->data), s, len);\n\t\t\t\t}\n\t\t\t\tZ_STRLEN_P(ent->data) += len;\n\t\t\t\tZ_STRVAL_P(ent->data)[Z_STRLEN_P(ent->data)] = '\\0';\n\t\t\t\tbreak;\n\n\t\t\tcase ST_NUMBER:\n\t\t\t\tZ_TYPE_P(ent->data) = IS_STRING;\n\t\t\t\tZ_STRLEN_P(ent->data) = len;\n\t\t\t\tZ_STRVAL_P(ent->data) = estrndup(s, len);\n\t\t\t\tconvert_scalar_to_number(ent->data TSRMLS_CC);\n\t\t\t\tbreak;\n\n\t\t\tcase ST_BOOLEAN:\n\t\t\t\tif (!strcmp(s, \"true\")) {\n\t\t\t\t\tZ_LVAL_P(ent->data) = 1;\n\t\t\t\t} else if (!strcmp(s, \"false\")) {\n\t\t\t\t\tZ_LVAL_P(ent->data) = 0;\n\t\t\t\t} else {\n\t\t\t\t\tzval_ptr_dtor(&ent->data);\n\t\t\t\t\tif (ent->varname) {\n\t\t\t\t\t\tefree(ent->varname);\n\t\t\t\t\t}\n\t\t\t\t\tent->data = NULL;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase ST_DATETIME: {\n\t\t\t\tchar *tmp;\n\n\t\t\t\ttmp = emalloc(len + 1);\n\t\t\t\tmemcpy(tmp, s, len);\n\t\t\t\ttmp[len] = '\\0';\n\n\t\t\t\tZ_LVAL_P(ent->data) = php_parse_date(tmp, NULL);\n\t\t\t\t/* date out of range < 1969 or > 2038 */\n\t\t\t\tif (Z_LVAL_P(ent->data) == -1) {\n\t\t\t\t\tZ_TYPE_P(ent->data) = IS_STRING;\n\t\t\t\t\tZ_STRLEN_P(ent->data) = len;\n\t\t\t\t\tZ_STRVAL_P(ent->data) = estrndup(s, len);\n\t\t\t\t}\n\t\t\t\tefree(tmp);\n\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t}\n}",
        "func": "static void php_wddx_process_data(void *user_data, const XML_Char *s, int len)\n{\n\tst_entry *ent;\n\twddx_stack *stack = (wddx_stack *)user_data;\n\tTSRMLS_FETCH();\n\n\tif (!wddx_stack_is_empty(stack) && !stack->done) {\n\t\twddx_stack_top(stack, (void**)&ent);\n\t\tswitch (ent->type) {\n\t\t\tcase ST_STRING:\n\t\t\t\tif (Z_STRLEN_P(ent->data) == 0) {\n\t\t\t\t\tSTR_FREE(Z_STRVAL_P(ent->data));\n\t\t\t\t\tZ_STRVAL_P(ent->data) = estrndup(s, len);\n\t\t\t\t\tZ_STRLEN_P(ent->data) = len;\n\t\t\t\t} else {\n\t\t\t\t\tZ_STRVAL_P(ent->data) = erealloc(Z_STRVAL_P(ent->data), Z_STRLEN_P(ent->data) + len + 1);\n\t\t\t\t\tmemcpy(Z_STRVAL_P(ent->data) + Z_STRLEN_P(ent->data), s, len);\n\t\t\t\t\tZ_STRLEN_P(ent->data) += len;\n\t\t\t\t\tZ_STRVAL_P(ent->data)[Z_STRLEN_P(ent->data)] = '\\0';\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase ST_BINARY:\n\t\t\t\tif (Z_STRLEN_P(ent->data) == 0) {\n\t\t\t\t\tSTR_FREE(Z_STRVAL_P(ent->data));\n\t\t\t\t\tZ_STRVAL_P(ent->data) = estrndup(s, len + 1);\n\t\t\t\t} else {\n\t\t\t\t\tZ_STRVAL_P(ent->data) = erealloc(Z_STRVAL_P(ent->data), Z_STRLEN_P(ent->data) + len + 1);\n\t\t\t\t\tmemcpy(Z_STRVAL_P(ent->data) + Z_STRLEN_P(ent->data), s, len);\n\t\t\t\t}\n\t\t\t\tZ_STRLEN_P(ent->data) += len;\n\t\t\t\tZ_STRVAL_P(ent->data)[Z_STRLEN_P(ent->data)] = '\\0';\n\t\t\t\tbreak;\n\n\t\t\tcase ST_NUMBER:\n\t\t\t\tZ_TYPE_P(ent->data) = IS_STRING;\n\t\t\t\tZ_STRLEN_P(ent->data) = len;\n\t\t\t\tZ_STRVAL_P(ent->data) = estrndup(s, len);\n\t\t\t\tconvert_scalar_to_number(ent->data TSRMLS_CC);\n\t\t\t\tbreak;\n\n\t\t\tcase ST_BOOLEAN:\n\t\t\t\tif(!ent->data) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!strcmp(s, \"true\")) {\n\t\t\t\t\tZ_LVAL_P(ent->data) = 1;\n\t\t\t\t} else if (!strcmp(s, \"false\")) {\n\t\t\t\t\tZ_LVAL_P(ent->data) = 0;\n\t\t\t\t} else {\n\t\t\t\t\tzval_ptr_dtor(&ent->data);\n\t\t\t\t\tif (ent->varname) {\n\t\t\t\t\t\tefree(ent->varname);\n\t\t\t\t\t\tent->varname = NULL;\n\t\t\t\t\t}\n\t\t\t\t\tent->data = NULL;\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase ST_DATETIME: {\n\t\t\t\tchar *tmp;\n\n\t\t\t\ttmp = emalloc(len + 1);\n\t\t\t\tmemcpy(tmp, s, len);\n\t\t\t\ttmp[len] = '\\0';\n\n\t\t\t\tZ_LVAL_P(ent->data) = php_parse_date(tmp, NULL);\n\t\t\t\t/* date out of range < 1969 or > 2038 */\n\t\t\t\tif (Z_LVAL_P(ent->data) == -1) {\n\t\t\t\t\tZ_TYPE_P(ent->data) = IS_STRING;\n\t\t\t\t\tZ_STRLEN_P(ent->data) = len;\n\t\t\t\t\tZ_STRVAL_P(ent->data) = estrndup(s, len);\n\t\t\t\t}\n\t\t\t\tefree(tmp);\n\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t}\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -40,6 +40,9 @@\n \t\t\t\tbreak;\n \n \t\t\tcase ST_BOOLEAN:\n+\t\t\t\tif(!ent->data) {\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n \t\t\t\tif (!strcmp(s, \"true\")) {\n \t\t\t\t\tZ_LVAL_P(ent->data) = 1;\n \t\t\t\t} else if (!strcmp(s, \"false\")) {\n@@ -48,6 +51,7 @@\n \t\t\t\t\tzval_ptr_dtor(&ent->data);\n \t\t\t\t\tif (ent->varname) {\n \t\t\t\t\t\tefree(ent->varname);\n+\t\t\t\t\t\tent->varname = NULL;\n \t\t\t\t\t}\n \t\t\t\t\tent->data = NULL;\n \t\t\t\t}",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\t\t\tif(!ent->data) {",
                "\t\t\t\t\tbreak;",
                "\t\t\t\t}",
                "\t\t\t\t\t\tent->varname = NULL;"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-5384",
        "func_name": "fontconfig/FcDirCacheMapFd",
        "description": "fontconfig before 2.12.1 does not validate offsets, which allows local users to trigger arbitrary free calls and consequently conduct double free attacks and execute arbitrary code via a crafted cache file.",
        "git_url": "https://cgit.freedesktop.org/fontconfig/commit/?id=7a4a5bd7897d216f0794ca9dbce0a4a5c9d14940",
        "commit_title": "The cache files are insufficiently validated. Even though the magic",
        "commit_text": "number at the beginning of the file as well as time stamps are checked, it is not verified if contained offsets are in legal ranges or are even pointers.  The lack of validation allows an attacker to trigger arbitrary free() calls, which in turn allows double free attacks and therefore arbitrary code execution. Due to the conversion from offsets into pointers through macros, this even allows to circumvent ASLR protections.  This attack vector allows privilege escalation when used with setuid binaries like fbterm. A user can create ~/.fonts or any other system-defined user-private font directory, run fc-cache and adjust cache files in ~/.cache/fontconfig. The execution of setuid binaries will scan these files and therefore are prone to attacks.  If it's not about code execution, an endless loop can be created by letting linked lists become circular linked lists.  This patch verifies that:  - The file is not larger than the maximum addressable space, which   basically only affects 32 bit systems. This allows out of boundary   access into unallocated memory. - Offsets are always positive or zero - Offsets do not point outside file boundaries - No pointers are allowed in cache files, every \"pointer or offset\"   field must be an offset or NULL - Iterating linked lists must not take longer than the amount of elements   specified. A violation of this rule can break a possible endless loop.  If one or more of these points are violated, the cache is recreated. This is current behaviour.  Even though this patch fixes many issues, the use of mmap() shall be forbidden in setuid binaries. It is impossible to guarantee with these checks that a malicious user does not change cache files after verification. This should be handled in a different patch.  ",
        "func_before": "static FcCache *\nFcDirCacheMapFd (FcConfig *config, int fd, struct stat *fd_stat, struct stat *dir_stat)\n{\n    FcCache\t*cache;\n    FcBool\tallocated = FcFalse;\n\n    if (fd_stat->st_size < (int) sizeof (FcCache))\n\treturn NULL;\n    cache = FcCacheFindByStat (fd_stat);\n    if (cache)\n    {\n\tif (FcCacheTimeValid (config, cache, dir_stat))\n\t    return cache;\n\tFcDirCacheUnload (cache);\n\tcache = NULL;\n    }\n\n    /*\n     * Large cache files are mmap'ed, smaller cache files are read. This\n     * balances the system cost of mmap against per-process memory usage.\n     */\n    if (FcCacheIsMmapSafe (fd) && fd_stat->st_size >= FC_CACHE_MIN_MMAP)\n    {\n#if defined(HAVE_MMAP) || defined(__CYGWIN__)\n\tcache = mmap (0, fd_stat->st_size, PROT_READ, MAP_SHARED, fd, 0);\n#if (HAVE_POSIX_FADVISE) && defined(POSIX_FADV_WILLNEED)\n\tposix_fadvise (fd, 0, fd_stat->st_size, POSIX_FADV_WILLNEED);\n#endif\n\tif (cache == MAP_FAILED)\n\t    cache = NULL;\n#elif defined(_WIN32)\n\t{\n\t    HANDLE hFileMap;\n\n\t    cache = NULL;\n\t    hFileMap = CreateFileMapping((HANDLE) _get_osfhandle(fd), NULL,\n\t\t\t\t\t PAGE_READONLY, 0, 0, NULL);\n\t    if (hFileMap != NULL)\n\t    {\n\t\tcache = MapViewOfFile (hFileMap, FILE_MAP_READ, 0, 0,\n\t\t\t\t       fd_stat->st_size);\n\t\tCloseHandle (hFileMap);\n\t    }\n\t}\n#endif\n    }\n    if (!cache)\n    {\n\tcache = malloc (fd_stat->st_size);\n\tif (!cache)\n\t    return NULL;\n\n\tif (read (fd, cache, fd_stat->st_size) != fd_stat->st_size)\n\t{\n\t    free (cache);\n\t    return NULL;\n\t}\n\tallocated = FcTrue;\n    }\n    if (cache->magic != FC_CACHE_MAGIC_MMAP ||\n\tcache->version < FC_CACHE_VERSION_NUMBER ||\n\tcache->size != (intptr_t) fd_stat->st_size ||\n\t!FcCacheTimeValid (config, cache, dir_stat) ||\n\t!FcCacheInsert (cache, fd_stat))\n    {\n\tif (allocated)\n\t    free (cache);\n\telse\n\t{\n#if defined(HAVE_MMAP) || defined(__CYGWIN__)\n\t    munmap (cache, fd_stat->st_size);\n#elif defined(_WIN32)\n\t    UnmapViewOfFile (cache);\n#endif\n\t}\n\treturn NULL;\n    }\n\n    /* Mark allocated caches so they're freed rather than unmapped */\n    if (allocated)\n\tcache->magic = FC_CACHE_MAGIC_ALLOC;\n\t\n    return cache;\n}",
        "func": "static FcCache *\nFcDirCacheMapFd (FcConfig *config, int fd, struct stat *fd_stat, struct stat *dir_stat)\n{\n    FcCache\t*cache;\n    FcBool\tallocated = FcFalse;\n\n    if (fd_stat->st_size > INTPTR_MAX ||\n        fd_stat->st_size < (int) sizeof (FcCache))\n\treturn NULL;\n    cache = FcCacheFindByStat (fd_stat);\n    if (cache)\n    {\n\tif (FcCacheTimeValid (config, cache, dir_stat))\n\t    return cache;\n\tFcDirCacheUnload (cache);\n\tcache = NULL;\n    }\n\n    /*\n     * Large cache files are mmap'ed, smaller cache files are read. This\n     * balances the system cost of mmap against per-process memory usage.\n     */\n    if (FcCacheIsMmapSafe (fd) && fd_stat->st_size >= FC_CACHE_MIN_MMAP)\n    {\n#if defined(HAVE_MMAP) || defined(__CYGWIN__)\n\tcache = mmap (0, fd_stat->st_size, PROT_READ, MAP_SHARED, fd, 0);\n#if (HAVE_POSIX_FADVISE) && defined(POSIX_FADV_WILLNEED)\n\tposix_fadvise (fd, 0, fd_stat->st_size, POSIX_FADV_WILLNEED);\n#endif\n\tif (cache == MAP_FAILED)\n\t    cache = NULL;\n#elif defined(_WIN32)\n\t{\n\t    HANDLE hFileMap;\n\n\t    cache = NULL;\n\t    hFileMap = CreateFileMapping((HANDLE) _get_osfhandle(fd), NULL,\n\t\t\t\t\t PAGE_READONLY, 0, 0, NULL);\n\t    if (hFileMap != NULL)\n\t    {\n\t\tcache = MapViewOfFile (hFileMap, FILE_MAP_READ, 0, 0,\n\t\t\t\t       fd_stat->st_size);\n\t\tCloseHandle (hFileMap);\n\t    }\n\t}\n#endif\n    }\n    if (!cache)\n    {\n\tcache = malloc (fd_stat->st_size);\n\tif (!cache)\n\t    return NULL;\n\n\tif (read (fd, cache, fd_stat->st_size) != fd_stat->st_size)\n\t{\n\t    free (cache);\n\t    return NULL;\n\t}\n\tallocated = FcTrue;\n    }\n    if (cache->magic != FC_CACHE_MAGIC_MMAP ||\n\tcache->version < FC_CACHE_VERSION_NUMBER ||\n\tcache->size != (intptr_t) fd_stat->st_size ||\n        !FcCacheOffsetsValid (cache) ||\n\t!FcCacheTimeValid (config, cache, dir_stat) ||\n\t!FcCacheInsert (cache, fd_stat))\n    {\n\tif (allocated)\n\t    free (cache);\n\telse\n\t{\n#if defined(HAVE_MMAP) || defined(__CYGWIN__)\n\t    munmap (cache, fd_stat->st_size);\n#elif defined(_WIN32)\n\t    UnmapViewOfFile (cache);\n#endif\n\t}\n\treturn NULL;\n    }\n\n    /* Mark allocated caches so they're freed rather than unmapped */\n    if (allocated)\n\tcache->magic = FC_CACHE_MAGIC_ALLOC;\n\t\n    return cache;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,7 +4,8 @@\n     FcCache\t*cache;\n     FcBool\tallocated = FcFalse;\n \n-    if (fd_stat->st_size < (int) sizeof (FcCache))\n+    if (fd_stat->st_size > INTPTR_MAX ||\n+        fd_stat->st_size < (int) sizeof (FcCache))\n \treturn NULL;\n     cache = FcCacheFindByStat (fd_stat);\n     if (cache)\n@@ -60,6 +61,7 @@\n     if (cache->magic != FC_CACHE_MAGIC_MMAP ||\n \tcache->version < FC_CACHE_VERSION_NUMBER ||\n \tcache->size != (intptr_t) fd_stat->st_size ||\n+        !FcCacheOffsetsValid (cache) ||\n \t!FcCacheTimeValid (config, cache, dir_stat) ||\n \t!FcCacheInsert (cache, fd_stat))\n     {",
        "diff_line_info": {
            "deleted_lines": [
                "    if (fd_stat->st_size < (int) sizeof (FcCache))"
            ],
            "added_lines": [
                "    if (fd_stat->st_size > INTPTR_MAX ||",
                "        fd_stat->st_size < (int) sizeof (FcCache))",
                "        !FcCacheOffsetsValid (cache) ||"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-8962",
        "func_name": "torvalds/linux/sg_common_write",
        "description": "Double free vulnerability in the sg_common_write function in drivers/scsi/sg.c in the Linux kernel before 4.4 allows local users to gain privileges or cause a denial of service (memory corruption and system crash) by detaching a device during an SG_IO ioctl call.",
        "git_url": "https://github.com/torvalds/linux/commit/f3951a3709ff50990bf3e188c27d346792103432",
        "commit_title": "sg: Fix double-free when drives detach during SG_IO",
        "commit_text": " In sg_common_write(), we free the block request and return -ENODEV if the device is detached in the middle of the SG_IO ioctl().  Unfortunately, sg_finish_rem_req() also tries to free srp->rq, so we end up freeing rq->cmd in the already free rq object, and then free the object itself out from under the current user.  This ends up corrupting random memory via the list_head on the rq object. The most common crash trace I saw is this:    ------------[ cut here ]------------   kernel BUG at block/blk-core.c:1420!   Call Trace:   [<ffffffff81281eab>] blk_put_request+0x5b/0x80   [<ffffffffa0069e5b>] sg_finish_rem_req+0x6b/0x120 [sg]   [<ffffffffa006bcb9>] sg_common_write.isra.14+0x459/0x5a0 [sg]   [<ffffffff8125b328>] ? selinux_file_alloc_security+0x48/0x70   [<ffffffffa006bf95>] sg_new_write.isra.17+0x195/0x2d0 [sg]   [<ffffffffa006cef4>] sg_ioctl+0x644/0xdb0 [sg]   [<ffffffff81170f80>] do_vfs_ioctl+0x90/0x520   [<ffffffff81258967>] ? file_has_perm+0x97/0xb0   [<ffffffff811714a1>] SyS_ioctl+0x91/0xb0   [<ffffffff81602afb>] tracesys+0xdd/0xe2     RIP [<ffffffff81281e04>] __blk_put_request+0x154/0x1a0  The solution is straightforward: just set srp->rq to NULL in the failure branch so that sg_finish_rem_req() doesn't attempt to re-free it.  Additionally, since sg_rq_end_io() will never be called on the object when this happens, we need to free memory backing ->cmd if it isn't embedded in the object itself.  KASAN was extremely helpful in finding the root cause of this bug. ",
        "func_before": "static int\nsg_common_write(Sg_fd * sfp, Sg_request * srp,\n\t\tunsigned char *cmnd, int timeout, int blocking)\n{\n\tint k, at_head;\n\tSg_device *sdp = sfp->parentdp;\n\tsg_io_hdr_t *hp = &srp->header;\n\n\tsrp->data.cmd_opcode = cmnd[0];\t/* hold opcode of command */\n\thp->status = 0;\n\thp->masked_status = 0;\n\thp->msg_status = 0;\n\thp->info = 0;\n\thp->host_status = 0;\n\thp->driver_status = 0;\n\thp->resid = 0;\n\tSCSI_LOG_TIMEOUT(4, sg_printk(KERN_INFO, sfp->parentdp,\n\t\t\t\"sg_common_write:  scsi opcode=0x%02x, cmd_size=%d\\n\",\n\t\t\t(int) cmnd[0], (int) hp->cmd_len));\n\n\tk = sg_start_req(srp, cmnd);\n\tif (k) {\n\t\tSCSI_LOG_TIMEOUT(1, sg_printk(KERN_INFO, sfp->parentdp,\n\t\t\t\"sg_common_write: start_req err=%d\\n\", k));\n\t\tsg_finish_rem_req(srp);\n\t\treturn k;\t/* probably out of space --> ENOMEM */\n\t}\n\tif (atomic_read(&sdp->detaching)) {\n\t\tif (srp->bio)\n\t\t\tblk_end_request_all(srp->rq, -EIO);\n\t\tsg_finish_rem_req(srp);\n\t\treturn -ENODEV;\n\t}\n\n\thp->duration = jiffies_to_msecs(jiffies);\n\tif (hp->interface_id != '\\0' &&\t/* v3 (or later) interface */\n\t    (SG_FLAG_Q_AT_TAIL & hp->flags))\n\t\tat_head = 0;\n\telse\n\t\tat_head = 1;\n\n\tsrp->rq->timeout = timeout;\n\tkref_get(&sfp->f_ref); /* sg_rq_end_io() does kref_put(). */\n\tblk_execute_rq_nowait(sdp->device->request_queue, sdp->disk,\n\t\t\t      srp->rq, at_head, sg_rq_end_io);\n\treturn 0;\n}",
        "func": "static int\nsg_common_write(Sg_fd * sfp, Sg_request * srp,\n\t\tunsigned char *cmnd, int timeout, int blocking)\n{\n\tint k, at_head;\n\tSg_device *sdp = sfp->parentdp;\n\tsg_io_hdr_t *hp = &srp->header;\n\n\tsrp->data.cmd_opcode = cmnd[0];\t/* hold opcode of command */\n\thp->status = 0;\n\thp->masked_status = 0;\n\thp->msg_status = 0;\n\thp->info = 0;\n\thp->host_status = 0;\n\thp->driver_status = 0;\n\thp->resid = 0;\n\tSCSI_LOG_TIMEOUT(4, sg_printk(KERN_INFO, sfp->parentdp,\n\t\t\t\"sg_common_write:  scsi opcode=0x%02x, cmd_size=%d\\n\",\n\t\t\t(int) cmnd[0], (int) hp->cmd_len));\n\n\tk = sg_start_req(srp, cmnd);\n\tif (k) {\n\t\tSCSI_LOG_TIMEOUT(1, sg_printk(KERN_INFO, sfp->parentdp,\n\t\t\t\"sg_common_write: start_req err=%d\\n\", k));\n\t\tsg_finish_rem_req(srp);\n\t\treturn k;\t/* probably out of space --> ENOMEM */\n\t}\n\tif (atomic_read(&sdp->detaching)) {\n\t\tif (srp->bio) {\n\t\t\tif (srp->rq->cmd != srp->rq->__cmd)\n\t\t\t\tkfree(srp->rq->cmd);\n\n\t\t\tblk_end_request_all(srp->rq, -EIO);\n\t\t\tsrp->rq = NULL;\n\t\t}\n\n\t\tsg_finish_rem_req(srp);\n\t\treturn -ENODEV;\n\t}\n\n\thp->duration = jiffies_to_msecs(jiffies);\n\tif (hp->interface_id != '\\0' &&\t/* v3 (or later) interface */\n\t    (SG_FLAG_Q_AT_TAIL & hp->flags))\n\t\tat_head = 0;\n\telse\n\t\tat_head = 1;\n\n\tsrp->rq->timeout = timeout;\n\tkref_get(&sfp->f_ref); /* sg_rq_end_io() does kref_put(). */\n\tblk_execute_rq_nowait(sdp->device->request_queue, sdp->disk,\n\t\t\t      srp->rq, at_head, sg_rq_end_io);\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -26,8 +26,14 @@\n \t\treturn k;\t/* probably out of space --> ENOMEM */\n \t}\n \tif (atomic_read(&sdp->detaching)) {\n-\t\tif (srp->bio)\n+\t\tif (srp->bio) {\n+\t\t\tif (srp->rq->cmd != srp->rq->__cmd)\n+\t\t\t\tkfree(srp->rq->cmd);\n+\n \t\t\tblk_end_request_all(srp->rq, -EIO);\n+\t\t\tsrp->rq = NULL;\n+\t\t}\n+\n \t\tsg_finish_rem_req(srp);\n \t\treturn -ENODEV;\n \t}",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tif (srp->bio)"
            ],
            "added_lines": [
                "\t\tif (srp->bio) {",
                "\t\t\tif (srp->rq->cmd != srp->rq->__cmd)",
                "\t\t\t\tkfree(srp->rq->cmd);",
                "",
                "\t\t\tsrp->rq = NULL;",
                "\t\t}",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2016-9806",
        "func_name": "torvalds/linux/netlink_dump",
        "description": "Race condition in the netlink_dump function in net/netlink/af_netlink.c in the Linux kernel before 4.6.3 allows local users to cause a denial of service (double free) or possibly have unspecified other impact via a crafted application that makes sendmsg system calls, leading to a free operation associated with a new dump that started earlier than anticipated.",
        "git_url": "https://github.com/torvalds/linux/commit/92964c79b357efd980812c4de5c1fd2ec8bb5520",
        "commit_title": "netlink: Fix dump skb leak/double free",
        "commit_text": " When we free cb->skb after a dump, we do it after releasing the lock.  This means that a new dump could have started in the time being and we'll end up freeing their skb instead of ours.  This patch saves the skb and module before we unlock so we free the right memory. ",
        "func_before": "static int netlink_dump(struct sock *sk)\n{\n\tstruct netlink_sock *nlk = nlk_sk(sk);\n\tstruct netlink_callback *cb;\n\tstruct sk_buff *skb = NULL;\n\tstruct nlmsghdr *nlh;\n\tint len, err = -ENOBUFS;\n\tint alloc_min_size;\n\tint alloc_size;\n\n\tmutex_lock(nlk->cb_mutex);\n\tif (!nlk->cb_running) {\n\t\terr = -EINVAL;\n\t\tgoto errout_skb;\n\t}\n\n\tif (atomic_read(&sk->sk_rmem_alloc) >= sk->sk_rcvbuf)\n\t\tgoto errout_skb;\n\n\t/* NLMSG_GOODSIZE is small to avoid high order allocations being\n\t * required, but it makes sense to _attempt_ a 16K bytes allocation\n\t * to reduce number of system calls on dump operations, if user\n\t * ever provided a big enough buffer.\n\t */\n\tcb = &nlk->cb;\n\talloc_min_size = max_t(int, cb->min_dump_alloc, NLMSG_GOODSIZE);\n\n\tif (alloc_min_size < nlk->max_recvmsg_len) {\n\t\talloc_size = nlk->max_recvmsg_len;\n\t\tskb = alloc_skb(alloc_size, GFP_KERNEL |\n\t\t\t\t\t    __GFP_NOWARN | __GFP_NORETRY);\n\t}\n\tif (!skb) {\n\t\talloc_size = alloc_min_size;\n\t\tskb = alloc_skb(alloc_size, GFP_KERNEL);\n\t}\n\tif (!skb)\n\t\tgoto errout_skb;\n\n\t/* Trim skb to allocated size. User is expected to provide buffer as\n\t * large as max(min_dump_alloc, 16KiB (mac_recvmsg_len capped at\n\t * netlink_recvmsg())). dump will pack as many smaller messages as\n\t * could fit within the allocated skb. skb is typically allocated\n\t * with larger space than required (could be as much as near 2x the\n\t * requested size with align to next power of 2 approach). Allowing\n\t * dump to use the excess space makes it difficult for a user to have a\n\t * reasonable static buffer based on the expected largest dump of a\n\t * single netdev. The outcome is MSG_TRUNC error.\n\t */\n\tskb_reserve(skb, skb_tailroom(skb) - alloc_size);\n\tnetlink_skb_set_owner_r(skb, sk);\n\n\tlen = cb->dump(skb, cb);\n\n\tif (len > 0) {\n\t\tmutex_unlock(nlk->cb_mutex);\n\n\t\tif (sk_filter(sk, skb))\n\t\t\tkfree_skb(skb);\n\t\telse\n\t\t\t__netlink_sendskb(sk, skb);\n\t\treturn 0;\n\t}\n\n\tnlh = nlmsg_put_answer(skb, cb, NLMSG_DONE, sizeof(len), NLM_F_MULTI);\n\tif (!nlh)\n\t\tgoto errout_skb;\n\n\tnl_dump_check_consistent(cb, nlh);\n\n\tmemcpy(nlmsg_data(nlh), &len, sizeof(len));\n\n\tif (sk_filter(sk, skb))\n\t\tkfree_skb(skb);\n\telse\n\t\t__netlink_sendskb(sk, skb);\n\n\tif (cb->done)\n\t\tcb->done(cb);\n\n\tnlk->cb_running = false;\n\tmutex_unlock(nlk->cb_mutex);\n\tmodule_put(cb->module);\n\tconsume_skb(cb->skb);\n\treturn 0;\n\nerrout_skb:\n\tmutex_unlock(nlk->cb_mutex);\n\tkfree_skb(skb);\n\treturn err;\n}",
        "func": "static int netlink_dump(struct sock *sk)\n{\n\tstruct netlink_sock *nlk = nlk_sk(sk);\n\tstruct netlink_callback *cb;\n\tstruct sk_buff *skb = NULL;\n\tstruct nlmsghdr *nlh;\n\tstruct module *module;\n\tint len, err = -ENOBUFS;\n\tint alloc_min_size;\n\tint alloc_size;\n\n\tmutex_lock(nlk->cb_mutex);\n\tif (!nlk->cb_running) {\n\t\terr = -EINVAL;\n\t\tgoto errout_skb;\n\t}\n\n\tif (atomic_read(&sk->sk_rmem_alloc) >= sk->sk_rcvbuf)\n\t\tgoto errout_skb;\n\n\t/* NLMSG_GOODSIZE is small to avoid high order allocations being\n\t * required, but it makes sense to _attempt_ a 16K bytes allocation\n\t * to reduce number of system calls on dump operations, if user\n\t * ever provided a big enough buffer.\n\t */\n\tcb = &nlk->cb;\n\talloc_min_size = max_t(int, cb->min_dump_alloc, NLMSG_GOODSIZE);\n\n\tif (alloc_min_size < nlk->max_recvmsg_len) {\n\t\talloc_size = nlk->max_recvmsg_len;\n\t\tskb = alloc_skb(alloc_size, GFP_KERNEL |\n\t\t\t\t\t    __GFP_NOWARN | __GFP_NORETRY);\n\t}\n\tif (!skb) {\n\t\talloc_size = alloc_min_size;\n\t\tskb = alloc_skb(alloc_size, GFP_KERNEL);\n\t}\n\tif (!skb)\n\t\tgoto errout_skb;\n\n\t/* Trim skb to allocated size. User is expected to provide buffer as\n\t * large as max(min_dump_alloc, 16KiB (mac_recvmsg_len capped at\n\t * netlink_recvmsg())). dump will pack as many smaller messages as\n\t * could fit within the allocated skb. skb is typically allocated\n\t * with larger space than required (could be as much as near 2x the\n\t * requested size with align to next power of 2 approach). Allowing\n\t * dump to use the excess space makes it difficult for a user to have a\n\t * reasonable static buffer based on the expected largest dump of a\n\t * single netdev. The outcome is MSG_TRUNC error.\n\t */\n\tskb_reserve(skb, skb_tailroom(skb) - alloc_size);\n\tnetlink_skb_set_owner_r(skb, sk);\n\n\tlen = cb->dump(skb, cb);\n\n\tif (len > 0) {\n\t\tmutex_unlock(nlk->cb_mutex);\n\n\t\tif (sk_filter(sk, skb))\n\t\t\tkfree_skb(skb);\n\t\telse\n\t\t\t__netlink_sendskb(sk, skb);\n\t\treturn 0;\n\t}\n\n\tnlh = nlmsg_put_answer(skb, cb, NLMSG_DONE, sizeof(len), NLM_F_MULTI);\n\tif (!nlh)\n\t\tgoto errout_skb;\n\n\tnl_dump_check_consistent(cb, nlh);\n\n\tmemcpy(nlmsg_data(nlh), &len, sizeof(len));\n\n\tif (sk_filter(sk, skb))\n\t\tkfree_skb(skb);\n\telse\n\t\t__netlink_sendskb(sk, skb);\n\n\tif (cb->done)\n\t\tcb->done(cb);\n\n\tnlk->cb_running = false;\n\tmodule = cb->module;\n\tskb = cb->skb;\n\tmutex_unlock(nlk->cb_mutex);\n\tmodule_put(module);\n\tconsume_skb(skb);\n\treturn 0;\n\nerrout_skb:\n\tmutex_unlock(nlk->cb_mutex);\n\tkfree_skb(skb);\n\treturn err;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,6 +4,7 @@\n \tstruct netlink_callback *cb;\n \tstruct sk_buff *skb = NULL;\n \tstruct nlmsghdr *nlh;\n+\tstruct module *module;\n \tint len, err = -ENOBUFS;\n \tint alloc_min_size;\n \tint alloc_size;\n@@ -79,9 +80,11 @@\n \t\tcb->done(cb);\n \n \tnlk->cb_running = false;\n+\tmodule = cb->module;\n+\tskb = cb->skb;\n \tmutex_unlock(nlk->cb_mutex);\n-\tmodule_put(cb->module);\n-\tconsume_skb(cb->skb);\n+\tmodule_put(module);\n+\tconsume_skb(skb);\n \treturn 0;\n \n errout_skb:",
        "diff_line_info": {
            "deleted_lines": [
                "\tmodule_put(cb->module);",
                "\tconsume_skb(cb->skb);"
            ],
            "added_lines": [
                "\tstruct module *module;",
                "\tmodule = cb->module;",
                "\tskb = cb->skb;",
                "\tmodule_put(module);",
                "\tconsume_skb(skb);"
            ]
        }
    },
    {
        "cve_id": "CVE-2010-3080",
        "func_name": "torvalds/linux/delete_port",
        "description": "Double free vulnerability in the snd_seq_oss_open function in sound/core/seq/oss/seq_oss_init.c in the Linux kernel before 2.6.36-rc4 might allow local users to cause a denial of service or possibly have unspecified other impact via an unsuccessful attempt to open the /dev/sequencer device.",
        "git_url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux.git;a=commit;h=27f7ad53829f79e799a253285318bff79ece15bd",
        "commit_title": "The error handling in snd_seq_oss_open() has several bad codes that",
        "commit_text": "do dereferecing released pointers and double-free of kmalloc'ed data. The object dp is release in free_devinfo() that is called via private_free callback.  The rest shouldn't touch this object any more.  The patch changes delete_port() to call kfree() in any case, and gets rid of unnecessary calls of destructors in snd_seq_oss_open().  Fixes CVE-2010-3080.  Reported-and-tested-by: Tavis Ormandy <taviso@cmpxchg8b.com> Cc: <stable@kernel.org> ",
        "func_before": "static int\ndelete_port(struct seq_oss_devinfo *dp)\n{\n\tif (dp->port < 0)\n\t\treturn 0;\n\n\tdebug_printk((\"delete_port %i\\n\", dp->port));\n\treturn snd_seq_event_port_detach(dp->cseq, dp->port);\n}",
        "func": "static int\ndelete_port(struct seq_oss_devinfo *dp)\n{\n\tif (dp->port < 0) {\n\t\tkfree(dp);\n\t\treturn 0;\n\t}\n\n\tdebug_printk((\"delete_port %i\\n\", dp->port));\n\treturn snd_seq_event_port_detach(dp->cseq, dp->port);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,8 +1,10 @@\n static int\n delete_port(struct seq_oss_devinfo *dp)\n {\n-\tif (dp->port < 0)\n+\tif (dp->port < 0) {\n+\t\tkfree(dp);\n \t\treturn 0;\n+\t}\n \n \tdebug_printk((\"delete_port %i\\n\", dp->port));\n \treturn snd_seq_event_port_detach(dp->cseq, dp->port);",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (dp->port < 0)"
            ],
            "added_lines": [
                "\tif (dp->port < 0) {",
                "\t\tkfree(dp);",
                "\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2010-3080",
        "func_name": "torvalds/linux/snd_seq_oss_open",
        "description": "Double free vulnerability in the snd_seq_oss_open function in sound/core/seq/oss/seq_oss_init.c in the Linux kernel before 2.6.36-rc4 might allow local users to cause a denial of service or possibly have unspecified other impact via an unsuccessful attempt to open the /dev/sequencer device.",
        "git_url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux.git;a=commit;h=27f7ad53829f79e799a253285318bff79ece15bd",
        "commit_title": "The error handling in snd_seq_oss_open() has several bad codes that",
        "commit_text": "do dereferecing released pointers and double-free of kmalloc'ed data. The object dp is release in free_devinfo() that is called via private_free callback.  The rest shouldn't touch this object any more.  The patch changes delete_port() to call kfree() in any case, and gets rid of unnecessary calls of destructors in snd_seq_oss_open().  Fixes CVE-2010-3080.  Reported-and-tested-by: Tavis Ormandy <taviso@cmpxchg8b.com> Cc: <stable@kernel.org> ",
        "func_before": "int\nsnd_seq_oss_open(struct file *file, int level)\n{\n\tint i, rc;\n\tstruct seq_oss_devinfo *dp;\n\n\tdp = kzalloc(sizeof(*dp), GFP_KERNEL);\n\tif (!dp) {\n\t\tsnd_printk(KERN_ERR \"can't malloc device info\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tdebug_printk((\"oss_open: dp = %p\\n\", dp));\n\n\tdp->cseq = system_client;\n\tdp->port = -1;\n\tdp->queue = -1;\n\n\tfor (i = 0; i < SNDRV_SEQ_OSS_MAX_CLIENTS; i++) {\n\t\tif (client_table[i] == NULL)\n\t\t\tbreak;\n\t}\n\n\tdp->index = i;\n\tif (i >= SNDRV_SEQ_OSS_MAX_CLIENTS) {\n\t\tsnd_printk(KERN_ERR \"too many applications\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto _error;\n\t}\n\n\t/* look up synth and midi devices */\n\tsnd_seq_oss_synth_setup(dp);\n\tsnd_seq_oss_midi_setup(dp);\n\n\tif (dp->synth_opened == 0 && dp->max_mididev == 0) {\n\t\t/* snd_printk(KERN_ERR \"no device found\\n\"); */\n\t\trc = -ENODEV;\n\t\tgoto _error;\n\t}\n\n\t/* create port */\n\tdebug_printk((\"create new port\\n\"));\n\trc = create_port(dp);\n\tif (rc < 0) {\n\t\tsnd_printk(KERN_ERR \"can't create port\\n\");\n\t\tgoto _error;\n\t}\n\n\t/* allocate queue */\n\tdebug_printk((\"allocate queue\\n\"));\n\trc = alloc_seq_queue(dp);\n\tif (rc < 0)\n\t\tgoto _error;\n\n\t/* set address */\n\tdp->addr.client = dp->cseq;\n\tdp->addr.port = dp->port;\n\t/*dp->addr.queue = dp->queue;*/\n\t/*dp->addr.channel = 0;*/\n\n\tdp->seq_mode = level;\n\n\t/* set up file mode */\n\tdp->file_mode = translate_mode(file);\n\n\t/* initialize read queue */\n\tdebug_printk((\"initialize read queue\\n\"));\n\tif (is_read_mode(dp->file_mode)) {\n\t\tdp->readq = snd_seq_oss_readq_new(dp, maxqlen);\n\t\tif (!dp->readq) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto _error;\n\t\t}\n\t}\n\n\t/* initialize write queue */\n\tdebug_printk((\"initialize write queue\\n\"));\n\tif (is_write_mode(dp->file_mode)) {\n\t\tdp->writeq = snd_seq_oss_writeq_new(dp, maxqlen);\n\t\tif (!dp->writeq) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto _error;\n\t\t}\n\t}\n\n\t/* initialize timer */\n\tdebug_printk((\"initialize timer\\n\"));\n\tdp->timer = snd_seq_oss_timer_new(dp);\n\tif (!dp->timer) {\n\t\tsnd_printk(KERN_ERR \"can't alloc timer\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto _error;\n\t}\n\tdebug_printk((\"timer initialized\\n\"));\n\n\t/* set private data pointer */\n\tfile->private_data = dp;\n\n\t/* set up for mode2 */\n\tif (level == SNDRV_SEQ_OSS_MODE_MUSIC)\n\t\tsnd_seq_oss_synth_setup_midi(dp);\n\telse if (is_read_mode(dp->file_mode))\n\t\tsnd_seq_oss_midi_open_all(dp, SNDRV_SEQ_OSS_FILE_READ);\n\n\tclient_table[dp->index] = dp;\n\tnum_clients++;\n\n\tdebug_printk((\"open done\\n\"));\n\treturn 0;\n\n _error:\n\tsnd_seq_oss_writeq_delete(dp->writeq);\n\tsnd_seq_oss_readq_delete(dp->readq);\n\tsnd_seq_oss_synth_cleanup(dp);\n\tsnd_seq_oss_midi_cleanup(dp);\n\tdelete_port(dp);\n\tdelete_seq_queue(dp->queue);\n\tkfree(dp);\n\n\treturn rc;\n}",
        "func": "int\nsnd_seq_oss_open(struct file *file, int level)\n{\n\tint i, rc;\n\tstruct seq_oss_devinfo *dp;\n\n\tdp = kzalloc(sizeof(*dp), GFP_KERNEL);\n\tif (!dp) {\n\t\tsnd_printk(KERN_ERR \"can't malloc device info\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tdebug_printk((\"oss_open: dp = %p\\n\", dp));\n\n\tdp->cseq = system_client;\n\tdp->port = -1;\n\tdp->queue = -1;\n\n\tfor (i = 0; i < SNDRV_SEQ_OSS_MAX_CLIENTS; i++) {\n\t\tif (client_table[i] == NULL)\n\t\t\tbreak;\n\t}\n\n\tdp->index = i;\n\tif (i >= SNDRV_SEQ_OSS_MAX_CLIENTS) {\n\t\tsnd_printk(KERN_ERR \"too many applications\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto _error;\n\t}\n\n\t/* look up synth and midi devices */\n\tsnd_seq_oss_synth_setup(dp);\n\tsnd_seq_oss_midi_setup(dp);\n\n\tif (dp->synth_opened == 0 && dp->max_mididev == 0) {\n\t\t/* snd_printk(KERN_ERR \"no device found\\n\"); */\n\t\trc = -ENODEV;\n\t\tgoto _error;\n\t}\n\n\t/* create port */\n\tdebug_printk((\"create new port\\n\"));\n\trc = create_port(dp);\n\tif (rc < 0) {\n\t\tsnd_printk(KERN_ERR \"can't create port\\n\");\n\t\tgoto _error;\n\t}\n\n\t/* allocate queue */\n\tdebug_printk((\"allocate queue\\n\"));\n\trc = alloc_seq_queue(dp);\n\tif (rc < 0)\n\t\tgoto _error;\n\n\t/* set address */\n\tdp->addr.client = dp->cseq;\n\tdp->addr.port = dp->port;\n\t/*dp->addr.queue = dp->queue;*/\n\t/*dp->addr.channel = 0;*/\n\n\tdp->seq_mode = level;\n\n\t/* set up file mode */\n\tdp->file_mode = translate_mode(file);\n\n\t/* initialize read queue */\n\tdebug_printk((\"initialize read queue\\n\"));\n\tif (is_read_mode(dp->file_mode)) {\n\t\tdp->readq = snd_seq_oss_readq_new(dp, maxqlen);\n\t\tif (!dp->readq) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto _error;\n\t\t}\n\t}\n\n\t/* initialize write queue */\n\tdebug_printk((\"initialize write queue\\n\"));\n\tif (is_write_mode(dp->file_mode)) {\n\t\tdp->writeq = snd_seq_oss_writeq_new(dp, maxqlen);\n\t\tif (!dp->writeq) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto _error;\n\t\t}\n\t}\n\n\t/* initialize timer */\n\tdebug_printk((\"initialize timer\\n\"));\n\tdp->timer = snd_seq_oss_timer_new(dp);\n\tif (!dp->timer) {\n\t\tsnd_printk(KERN_ERR \"can't alloc timer\\n\");\n\t\trc = -ENOMEM;\n\t\tgoto _error;\n\t}\n\tdebug_printk((\"timer initialized\\n\"));\n\n\t/* set private data pointer */\n\tfile->private_data = dp;\n\n\t/* set up for mode2 */\n\tif (level == SNDRV_SEQ_OSS_MODE_MUSIC)\n\t\tsnd_seq_oss_synth_setup_midi(dp);\n\telse if (is_read_mode(dp->file_mode))\n\t\tsnd_seq_oss_midi_open_all(dp, SNDRV_SEQ_OSS_FILE_READ);\n\n\tclient_table[dp->index] = dp;\n\tnum_clients++;\n\n\tdebug_printk((\"open done\\n\"));\n\treturn 0;\n\n _error:\n\tsnd_seq_oss_synth_cleanup(dp);\n\tsnd_seq_oss_midi_cleanup(dp);\n\tdelete_seq_queue(dp->queue);\n\tdelete_port(dp);\n\n\treturn rc;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -108,13 +108,10 @@\n \treturn 0;\n \n  _error:\n-\tsnd_seq_oss_writeq_delete(dp->writeq);\n-\tsnd_seq_oss_readq_delete(dp->readq);\n \tsnd_seq_oss_synth_cleanup(dp);\n \tsnd_seq_oss_midi_cleanup(dp);\n+\tdelete_seq_queue(dp->queue);\n \tdelete_port(dp);\n-\tdelete_seq_queue(dp->queue);\n-\tkfree(dp);\n \n \treturn rc;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tsnd_seq_oss_writeq_delete(dp->writeq);",
                "\tsnd_seq_oss_readq_delete(dp->readq);",
                "\tdelete_seq_queue(dp->queue);",
                "\tkfree(dp);"
            ],
            "added_lines": [
                "\tdelete_seq_queue(dp->queue);"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-8894",
        "func_name": "ImageMagick/ReadTGAImage",
        "description": "Double free vulnerability in coders/tga.c in ImageMagick 7.0.0 and later allows remote attackers to cause a denial of service (application crash) via a crafted tga file.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/4f68e9661518463fca523c9726bb5d940a2aa6d8",
        "commit_title": "https://bugs.launchpad.net/ubuntu/+source/imagemagick/+bug/1490362",
        "commit_text": "",
        "func_before": "static Image *ReadTGAImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  PixelInfo\n    pixel;\n\n  Quantum\n    index;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    i,\n    x;\n\n  size_t\n    base,\n    flag,\n    offset,\n    real,\n    skip;\n\n  ssize_t\n    count,\n    y;\n\n  TGAInfo\n    tga_info;\n\n  unsigned char\n    j,\n    k,\n    pixels[4],\n    runlength;\n\n  unsigned int\n    alpha_bits;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read TGA header information.\n  */\n  count=ReadBlob(image,1,&tga_info.id_length);\n  tga_info.colormap_type=(unsigned char) ReadBlobByte(image);\n  tga_info.image_type=(TGAImageType) ReadBlobByte(image);\n  if ((count != 1) ||\n      ((tga_info.image_type != TGAColormap) &&\n       (tga_info.image_type != TGARGB) &&\n       (tga_info.image_type != TGAMonochrome) &&\n       (tga_info.image_type != TGARLEColormap) &&\n       (tga_info.image_type != TGARLERGB) &&\n       (tga_info.image_type != TGARLEMonochrome)) ||\n      (((tga_info.image_type == TGAColormap) ||\n       (tga_info.image_type == TGARLEColormap)) &&\n       (tga_info.colormap_type == 0)))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  tga_info.colormap_index=ReadBlobLSBShort(image);\n  tga_info.colormap_length=ReadBlobLSBShort(image);\n  tga_info.colormap_size=(unsigned char) ReadBlobByte(image);\n  tga_info.x_origin=ReadBlobLSBShort(image);\n  tga_info.y_origin=ReadBlobLSBShort(image);\n  tga_info.width=(unsigned short) ReadBlobLSBShort(image);\n  tga_info.height=(unsigned short) ReadBlobLSBShort(image);\n  tga_info.bits_per_pixel=(unsigned char) ReadBlobByte(image);\n  tga_info.attributes=(unsigned char) ReadBlobByte(image);\n  if (EOFBlob(image) != MagickFalse)\n    ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n  if ((((tga_info.bits_per_pixel <= 1) || (tga_info.bits_per_pixel >= 17)) &&\n       (tga_info.bits_per_pixel != 24) && (tga_info.bits_per_pixel != 32)))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  /*\n    Initialize image structure.\n  */\n  image->columns=tga_info.width;\n  image->rows=tga_info.height;\n  alpha_bits=(tga_info.attributes & 0x0FU);\n  image->alpha_trait=(alpha_bits > 0) || (tga_info.bits_per_pixel == 32) ||\n    (tga_info.colormap_size == 32) ?  BlendPixelTrait : UndefinedPixelTrait;\n  if ((tga_info.image_type != TGAColormap) &&\n      (tga_info.image_type != TGARLEColormap))\n    image->depth=(size_t) ((tga_info.bits_per_pixel <= 8) ? 8 :\n      (tga_info.bits_per_pixel <= 16) ? 5 :\n      (tga_info.bits_per_pixel == 24) ? 8 :\n      (tga_info.bits_per_pixel == 32) ? 8 : 8);\n  else\n    image->depth=(size_t) ((tga_info.colormap_size <= 8) ? 8 :\n      (tga_info.colormap_size <= 16) ? 5 :\n      (tga_info.colormap_size == 24) ? 8 :\n      (tga_info.colormap_size == 32) ? 8 : 8);\n  if ((tga_info.image_type == TGAColormap) ||\n      (tga_info.image_type == TGAMonochrome) ||\n      (tga_info.image_type == TGARLEColormap) ||\n      (tga_info.image_type == TGARLEMonochrome))\n    image->storage_class=PseudoClass;\n  image->compression=NoCompression;\n  if ((tga_info.image_type == TGARLEColormap) ||\n      (tga_info.image_type == TGARLEMonochrome) ||\n      (tga_info.image_type == TGARLERGB))\n    image->compression=RLECompression;\n  if (image->storage_class == PseudoClass)\n    {\n      if (tga_info.colormap_type != 0)\n        image->colors=tga_info.colormap_index+tga_info.colormap_length;\n      else\n        {\n          size_t\n            one;\n\n          one=1;\n          image->colors=one << tga_info.bits_per_pixel;\n          if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        }\n    }\n  if (tga_info.id_length != 0)\n    {\n      char\n        *comment;\n\n      size_t\n        length;\n\n      /*\n        TGA image comment.\n      */\n      length=(size_t) tga_info.id_length;\n      comment=(char *) NULL;\n      if (~length >= (MagickPathExtent-1))\n        comment=(char *) AcquireQuantumMemory(length+MagickPathExtent,\n          sizeof(*comment));\n      if (comment == (char *) NULL)\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      count=ReadBlob(image,tga_info.id_length,(unsigned char *) comment);\n      comment[tga_info.id_length]='\\0';\n      (void) SetImageProperty(image,\"comment\",comment,exception);\n      comment=DestroyString(comment);\n    }\n  if (image_info->ping != MagickFalse)\n    {\n      (void) CloseBlob(image);\n      return(image);\n    }\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  (void) ResetMagickMemory(&pixel,0,sizeof(pixel));\n  pixel.alpha=(MagickRealType) OpaqueAlpha;\n  if (tga_info.colormap_type != 0)\n    {\n      /*\n        Read TGA raster colormap.\n      */\n      if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      for (i=0; i < (ssize_t) tga_info.colormap_index; i++)\n        image->colormap[i]=pixel;\n      for ( ; i < (ssize_t) image->colors; i++)\n      {\n        switch (tga_info.colormap_size)\n        {\n          case 8:\n          default:\n          {\n            /*\n              Gray scale.\n            */\n            pixel.red=(MagickRealType) ScaleCharToQuantum((unsigned char)\n              ReadBlobByte(image));\n            pixel.green=pixel.red;\n            pixel.blue=pixel.red;\n            break;\n          }\n          case 15:\n          case 16:\n          {\n            QuantumAny\n              range;\n\n            /*\n              5 bits each of red green and blue.\n            */\n            j=(unsigned char) ReadBlobByte(image);\n            k=(unsigned char) ReadBlobByte(image);\n            range=GetQuantumRange(5UL);\n            pixel.red=(MagickRealType) ScaleAnyToQuantum(1UL*(k & 0x7c) >> 2,\n              range);\n            pixel.green=(MagickRealType) ScaleAnyToQuantum((1UL*(k & 0x03)\n              << 3)+(1UL*(j & 0xe0) >> 5),range);\n            pixel.blue=(MagickRealType) ScaleAnyToQuantum(1UL*(j & 0x1f),range);\n            break;\n          }\n          case 24:\n          {\n            /*\n              8 bits each of blue, green and red.\n            */\n            pixel.blue=(MagickRealType) ScaleCharToQuantum((unsigned char)\n              ReadBlobByte(image));\n            pixel.green=(MagickRealType) ScaleCharToQuantum((unsigned char)\n              ReadBlobByte(image));\n            pixel.red=(MagickRealType) ScaleCharToQuantum((unsigned char)\n              ReadBlobByte(image));\n            break;\n          }\n          case 32:\n          {\n            /*\n              8 bits each of blue, green, red, and alpha.\n            */\n            pixel.blue=(MagickRealType) ScaleCharToQuantum((unsigned char)\n              ReadBlobByte(image));\n            pixel.green=(MagickRealType) ScaleCharToQuantum((unsigned char)\n              ReadBlobByte(image));\n            pixel.red=(MagickRealType) ScaleCharToQuantum((unsigned char)\n              ReadBlobByte(image));\n            pixel.alpha=(MagickRealType) ScaleCharToQuantum((unsigned char)\n              ReadBlobByte(image));\n            break;\n          }\n        }\n        image->colormap[i]=pixel;\n      }\n    }\n  /*\n    Convert TGA pixels to pixel packets.\n  */\n  base=0;\n  flag=0;\n  skip=MagickFalse;\n  real=0;\n  index=0;\n  runlength=0;\n  offset=0;\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    real=offset;\n    if (((unsigned char) (tga_info.attributes & 0x20) >> 5) == 0)\n      real=image->rows-real-1;\n    q=QueueAuthenticPixels(image,0,(ssize_t) real,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      break;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      if ((tga_info.image_type == TGARLEColormap) ||\n          (tga_info.image_type == TGARLERGB) ||\n          (tga_info.image_type == TGARLEMonochrome))\n        {\n          if (runlength != 0)\n            {\n              runlength--;\n              skip=flag != 0;\n            }\n          else\n            {\n              count=ReadBlob(image,1,&runlength);\n              if (count != 1)\n                ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n              flag=runlength & 0x80;\n              if (flag != 0)\n                runlength-=128;\n              skip=MagickFalse;\n            }\n        }\n      if (skip == MagickFalse)\n        switch (tga_info.bits_per_pixel)\n        {\n          case 8:\n          default:\n          {\n            /*\n              Gray scale.\n            */\n            index=(Quantum) ReadBlobByte(image);\n            if (tga_info.colormap_type != 0)\n              pixel=image->colormap[(ssize_t) ConstrainColormapIndex(image,\n                (ssize_t) index,exception)];\n            else\n              {\n                pixel.red=(MagickRealType) ScaleCharToQuantum((unsigned char)\n                  index);\n                pixel.green=(MagickRealType) ScaleCharToQuantum((unsigned char)\n                  index);\n                pixel.blue=(MagickRealType) ScaleCharToQuantum((unsigned char)\n                  index);\n              }\n            break;\n          }\n          case 15:\n          case 16:\n          {\n            QuantumAny\n              range;\n\n            /*\n              5 bits each of RGB.\n            */\n            if (ReadBlob(image,2,pixels) != 2)\n              ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n            j=pixels[0];\n            k=pixels[1];\n            range=GetQuantumRange(5UL);\n            pixel.red=(MagickRealType) ScaleAnyToQuantum(1UL*(k & 0x7c) >> 2,\n              range);\n            pixel.green=(MagickRealType) ScaleAnyToQuantum((1UL*\n              (k & 0x03) << 3)+(1UL*(j & 0xe0) >> 5),range);\n            pixel.blue=(MagickRealType) ScaleAnyToQuantum(1UL*(j & 0x1f),range);\n            if (image->alpha_trait != UndefinedPixelTrait)\n              pixel.alpha=(MagickRealType) ((k & 0x80) == 0 ? (Quantum)\n                TransparentAlpha : (Quantum) OpaqueAlpha);\n            if (image->storage_class == PseudoClass)\n              index=(Quantum) ConstrainColormapIndex(image,((ssize_t) (k << 8))+\n                j,exception);\n            break;\n          }\n          case 24:\n          {\n            /*\n              BGR pixels.\n            */\n            if (ReadBlob(image,3,pixels) != 3)\n              ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n            pixel.blue=(MagickRealType) ScaleCharToQuantum(pixels[0]);\n            pixel.green=(MagickRealType) ScaleCharToQuantum(pixels[1]);\n            pixel.red=(MagickRealType) ScaleCharToQuantum(pixels[2]);\n            break;\n          }\n          case 32:\n          {\n            /*\n              BGRA pixels.\n            */\n            if (ReadBlob(image,4,pixels) != 4)\n              ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n            pixel.blue=(MagickRealType) ScaleCharToQuantum(pixels[0]);\n            pixel.green=(MagickRealType) ScaleCharToQuantum(pixels[1]);\n            pixel.red=(MagickRealType) ScaleCharToQuantum(pixels[2]);\n            pixel.alpha=(MagickRealType) ScaleCharToQuantum(pixels[3]);\n            break;\n          }\n        }\n      if (status == MagickFalse)\n        ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n      if (image->storage_class == PseudoClass)\n        SetPixelIndex(image,index,q);\n      SetPixelRed(image,ClampToQuantum(pixel.red),q);\n      SetPixelGreen(image,ClampToQuantum(pixel.green),q);\n      SetPixelBlue(image,ClampToQuantum(pixel.blue),q);\n      if (image->alpha_trait != UndefinedPixelTrait)\n        SetPixelAlpha(image,ClampToQuantum(pixel.alpha),q);\n      q+=GetPixelChannels(image);\n    }\n    /*\n      if (((unsigned char) (tga_info.attributes & 0xc0) >> 6) == 4)\n        offset+=4;\n      else\n    */\n      if (((unsigned char) (tga_info.attributes & 0xc0) >> 6) == 2)\n        offset+=2;\n      else\n        offset++;\n    if (offset >= image->rows)\n      {\n        base++;\n        offset=base;\n      }\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n    if (image->previous == (Image *) NULL)\n      {\n        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n          image->rows);\n        if (status == MagickFalse)\n          break;\n      }\n  }\n  if (EOFBlob(image) != MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
        "func": "static Image *ReadTGAImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  PixelInfo\n    pixel;\n\n  Quantum\n    index;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    i,\n    x;\n\n  size_t\n    base,\n    flag,\n    offset,\n    real,\n    skip;\n\n  ssize_t\n    count,\n    y;\n\n  TGAInfo\n    tga_info;\n\n  unsigned char\n    j,\n    k,\n    pixels[4],\n    runlength;\n\n  unsigned int\n    alpha_bits;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read TGA header information.\n  */\n  count=ReadBlob(image,1,&tga_info.id_length);\n  tga_info.colormap_type=(unsigned char) ReadBlobByte(image);\n  tga_info.image_type=(TGAImageType) ReadBlobByte(image);\n  if ((count != 1) ||\n      ((tga_info.image_type != TGAColormap) &&\n       (tga_info.image_type != TGARGB) &&\n       (tga_info.image_type != TGAMonochrome) &&\n       (tga_info.image_type != TGARLEColormap) &&\n       (tga_info.image_type != TGARLERGB) &&\n       (tga_info.image_type != TGARLEMonochrome)) ||\n      (((tga_info.image_type == TGAColormap) ||\n       (tga_info.image_type == TGARLEColormap)) &&\n       (tga_info.colormap_type == 0)))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  tga_info.colormap_index=ReadBlobLSBShort(image);\n  tga_info.colormap_length=ReadBlobLSBShort(image);\n  tga_info.colormap_size=(unsigned char) ReadBlobByte(image);\n  tga_info.x_origin=ReadBlobLSBShort(image);\n  tga_info.y_origin=ReadBlobLSBShort(image);\n  tga_info.width=(unsigned short) ReadBlobLSBShort(image);\n  tga_info.height=(unsigned short) ReadBlobLSBShort(image);\n  tga_info.bits_per_pixel=(unsigned char) ReadBlobByte(image);\n  tga_info.attributes=(unsigned char) ReadBlobByte(image);\n  if (EOFBlob(image) != MagickFalse)\n    ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n  if ((((tga_info.bits_per_pixel <= 1) || (tga_info.bits_per_pixel >= 17)) &&\n       (tga_info.bits_per_pixel != 24) && (tga_info.bits_per_pixel != 32)))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  /*\n    Initialize image structure.\n  */\n  image->columns=tga_info.width;\n  image->rows=tga_info.height;\n  alpha_bits=(tga_info.attributes & 0x0FU);\n  image->alpha_trait=(alpha_bits > 0) || (tga_info.bits_per_pixel == 32) ||\n    (tga_info.colormap_size == 32) ?  BlendPixelTrait : UndefinedPixelTrait;\n  if ((tga_info.image_type != TGAColormap) &&\n      (tga_info.image_type != TGARLEColormap))\n    image->depth=(size_t) ((tga_info.bits_per_pixel <= 8) ? 8 :\n      (tga_info.bits_per_pixel <= 16) ? 5 :\n      (tga_info.bits_per_pixel == 24) ? 8 :\n      (tga_info.bits_per_pixel == 32) ? 8 : 8);\n  else\n    image->depth=(size_t) ((tga_info.colormap_size <= 8) ? 8 :\n      (tga_info.colormap_size <= 16) ? 5 :\n      (tga_info.colormap_size == 24) ? 8 :\n      (tga_info.colormap_size == 32) ? 8 : 8);\n  if ((tga_info.image_type == TGAColormap) ||\n      (tga_info.image_type == TGAMonochrome) ||\n      (tga_info.image_type == TGARLEColormap) ||\n      (tga_info.image_type == TGARLEMonochrome))\n    image->storage_class=PseudoClass;\n  image->compression=NoCompression;\n  if ((tga_info.image_type == TGARLEColormap) ||\n      (tga_info.image_type == TGARLEMonochrome) ||\n      (tga_info.image_type == TGARLERGB))\n    image->compression=RLECompression;\n  if (image->storage_class == PseudoClass)\n    {\n      if (tga_info.colormap_type != 0)\n        image->colors=tga_info.colormap_index+tga_info.colormap_length;\n      else\n        {\n          size_t\n            one;\n\n          one=1;\n          image->colors=one << tga_info.bits_per_pixel;\n          if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n            ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        }\n    }\n  if (tga_info.id_length != 0)\n    {\n      char\n        *comment;\n\n      size_t\n        length;\n\n      /*\n        TGA image comment.\n      */\n      length=(size_t) tga_info.id_length;\n      comment=(char *) NULL;\n      if (~length >= (MagickPathExtent-1))\n        comment=(char *) AcquireQuantumMemory(length+MagickPathExtent,\n          sizeof(*comment));\n      if (comment == (char *) NULL)\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      count=ReadBlob(image,tga_info.id_length,(unsigned char *) comment);\n      comment[tga_info.id_length]='\\0';\n      (void) SetImageProperty(image,\"comment\",comment,exception);\n      comment=DestroyString(comment);\n    }\n  if (image_info->ping != MagickFalse)\n    {\n      (void) CloseBlob(image);\n      return(image);\n    }\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  (void) ResetMagickMemory(&pixel,0,sizeof(pixel));\n  pixel.alpha=(MagickRealType) OpaqueAlpha;\n  if (tga_info.colormap_type != 0)\n    {\n      /*\n        Read TGA raster colormap.\n      */\n      if (image->colors < tga_info.colormap_index)\n        image->colors=tga_info.colormap_index;\n      if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n        ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n      for (i=0; i < (ssize_t) tga_info.colormap_index; i++)\n        image->colormap[i]=pixel;\n      for ( ; i < (ssize_t) image->colors; i++)\n      {\n        switch (tga_info.colormap_size)\n        {\n          case 8:\n          default:\n          {\n            /*\n              Gray scale.\n            */\n            pixel.red=(MagickRealType) ScaleCharToQuantum((unsigned char)\n              ReadBlobByte(image));\n            pixel.green=pixel.red;\n            pixel.blue=pixel.red;\n            break;\n          }\n          case 15:\n          case 16:\n          {\n            QuantumAny\n              range;\n\n            /*\n              5 bits each of red green and blue.\n            */\n            j=(unsigned char) ReadBlobByte(image);\n            k=(unsigned char) ReadBlobByte(image);\n            range=GetQuantumRange(5UL);\n            pixel.red=(MagickRealType) ScaleAnyToQuantum(1UL*(k & 0x7c) >> 2,\n              range);\n            pixel.green=(MagickRealType) ScaleAnyToQuantum((1UL*(k & 0x03)\n              << 3)+(1UL*(j & 0xe0) >> 5),range);\n            pixel.blue=(MagickRealType) ScaleAnyToQuantum(1UL*(j & 0x1f),range);\n            break;\n          }\n          case 24:\n          {\n            /*\n              8 bits each of blue, green and red.\n            */\n            pixel.blue=(MagickRealType) ScaleCharToQuantum((unsigned char)\n              ReadBlobByte(image));\n            pixel.green=(MagickRealType) ScaleCharToQuantum((unsigned char)\n              ReadBlobByte(image));\n            pixel.red=(MagickRealType) ScaleCharToQuantum((unsigned char)\n              ReadBlobByte(image));\n            break;\n          }\n          case 32:\n          {\n            /*\n              8 bits each of blue, green, red, and alpha.\n            */\n            pixel.blue=(MagickRealType) ScaleCharToQuantum((unsigned char)\n              ReadBlobByte(image));\n            pixel.green=(MagickRealType) ScaleCharToQuantum((unsigned char)\n              ReadBlobByte(image));\n            pixel.red=(MagickRealType) ScaleCharToQuantum((unsigned char)\n              ReadBlobByte(image));\n            pixel.alpha=(MagickRealType) ScaleCharToQuantum((unsigned char)\n              ReadBlobByte(image));\n            break;\n          }\n        }\n        image->colormap[i]=pixel;\n      }\n    }\n  /*\n    Convert TGA pixels to pixel packets.\n  */\n  base=0;\n  flag=0;\n  skip=MagickFalse;\n  real=0;\n  index=0;\n  runlength=0;\n  offset=0;\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    real=offset;\n    if (((unsigned char) (tga_info.attributes & 0x20) >> 5) == 0)\n      real=image->rows-real-1;\n    q=QueueAuthenticPixels(image,0,(ssize_t) real,image->columns,1,exception);\n    if (q == (Quantum *) NULL)\n      break;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      if ((tga_info.image_type == TGARLEColormap) ||\n          (tga_info.image_type == TGARLERGB) ||\n          (tga_info.image_type == TGARLEMonochrome))\n        {\n          if (runlength != 0)\n            {\n              runlength--;\n              skip=flag != 0;\n            }\n          else\n            {\n              count=ReadBlob(image,1,&runlength);\n              if (count != 1)\n                ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n              flag=runlength & 0x80;\n              if (flag != 0)\n                runlength-=128;\n              skip=MagickFalse;\n            }\n        }\n      if (skip == MagickFalse)\n        switch (tga_info.bits_per_pixel)\n        {\n          case 8:\n          default:\n          {\n            /*\n              Gray scale.\n            */\n            index=(Quantum) ReadBlobByte(image);\n            if (tga_info.colormap_type != 0)\n              pixel=image->colormap[(ssize_t) ConstrainColormapIndex(image,\n                (ssize_t) index,exception)];\n            else\n              {\n                pixel.red=(MagickRealType) ScaleCharToQuantum((unsigned char)\n                  index);\n                pixel.green=(MagickRealType) ScaleCharToQuantum((unsigned char)\n                  index);\n                pixel.blue=(MagickRealType) ScaleCharToQuantum((unsigned char)\n                  index);\n              }\n            break;\n          }\n          case 15:\n          case 16:\n          {\n            QuantumAny\n              range;\n\n            /*\n              5 bits each of RGB.\n            */\n            if (ReadBlob(image,2,pixels) != 2)\n              ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n            j=pixels[0];\n            k=pixels[1];\n            range=GetQuantumRange(5UL);\n            pixel.red=(MagickRealType) ScaleAnyToQuantum(1UL*(k & 0x7c) >> 2,\n              range);\n            pixel.green=(MagickRealType) ScaleAnyToQuantum((1UL*\n              (k & 0x03) << 3)+(1UL*(j & 0xe0) >> 5),range);\n            pixel.blue=(MagickRealType) ScaleAnyToQuantum(1UL*(j & 0x1f),range);\n            if (image->alpha_trait != UndefinedPixelTrait)\n              pixel.alpha=(MagickRealType) ((k & 0x80) == 0 ? (Quantum)\n                TransparentAlpha : (Quantum) OpaqueAlpha);\n            if (image->storage_class == PseudoClass)\n              index=(Quantum) ConstrainColormapIndex(image,((ssize_t) (k << 8))+\n                j,exception);\n            break;\n          }\n          case 24:\n          {\n            /*\n              BGR pixels.\n            */\n            if (ReadBlob(image,3,pixels) != 3)\n              ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n            pixel.blue=(MagickRealType) ScaleCharToQuantum(pixels[0]);\n            pixel.green=(MagickRealType) ScaleCharToQuantum(pixels[1]);\n            pixel.red=(MagickRealType) ScaleCharToQuantum(pixels[2]);\n            break;\n          }\n          case 32:\n          {\n            /*\n              BGRA pixels.\n            */\n            if (ReadBlob(image,4,pixels) != 4)\n              ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n            pixel.blue=(MagickRealType) ScaleCharToQuantum(pixels[0]);\n            pixel.green=(MagickRealType) ScaleCharToQuantum(pixels[1]);\n            pixel.red=(MagickRealType) ScaleCharToQuantum(pixels[2]);\n            pixel.alpha=(MagickRealType) ScaleCharToQuantum(pixels[3]);\n            break;\n          }\n        }\n      if (status == MagickFalse)\n        ThrowReaderException(CorruptImageError,\"UnableToReadImageData\");\n      if (image->storage_class == PseudoClass)\n        SetPixelIndex(image,index,q);\n      SetPixelRed(image,ClampToQuantum(pixel.red),q);\n      SetPixelGreen(image,ClampToQuantum(pixel.green),q);\n      SetPixelBlue(image,ClampToQuantum(pixel.blue),q);\n      if (image->alpha_trait != UndefinedPixelTrait)\n        SetPixelAlpha(image,ClampToQuantum(pixel.alpha),q);\n      q+=GetPixelChannels(image);\n    }\n    /*\n      if (((unsigned char) (tga_info.attributes & 0xc0) >> 6) == 4)\n        offset+=4;\n      else\n    */\n      if (((unsigned char) (tga_info.attributes & 0xc0) >> 6) == 2)\n        offset+=2;\n      else\n        offset++;\n    if (offset >= image->rows)\n      {\n        base++;\n        offset=base;\n      }\n    if (SyncAuthenticPixels(image,exception) == MagickFalse)\n      break;\n    if (image->previous == (Image *) NULL)\n      {\n        status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n          image->rows);\n        if (status == MagickFalse)\n          break;\n      }\n  }\n  if (EOFBlob(image) != MagickFalse)\n    ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n      image->filename);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -173,6 +173,8 @@\n       /*\n         Read TGA raster colormap.\n       */\n+      if (image->colors < tga_info.colormap_index)\n+        image->colors=tga_info.colormap_index;\n       if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n         ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n       for (i=0; i < (ssize_t) tga_info.colormap_index; i++)",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "      if (image->colors < tga_info.colormap_index)",
                "        image->colors=tga_info.colormap_index;"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-5506",
        "func_name": "ImageMagick/SyncExifProfile",
        "description": "Double free vulnerability in magick/profile.c in ImageMagick allows remote attackers to have unspecified impact via a crafted file.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/9a069e0f2e027ec5138f998023cf9cb62c04889f",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/354",
        "commit_text": "",
        "func_before": "MagickBooleanType SyncExifProfile(Image *image,StringInfo *profile)\n{\n#define MaxDirectoryStack  16\n#define EXIF_DELIMITER  \"\\n\"\n#define EXIF_NUM_FORMATS  12\n#define TAG_EXIF_OFFSET  0x8769\n#define TAG_INTEROP_OFFSET  0xa005\n\n  typedef struct _DirectoryInfo\n  {\n    unsigned char\n      *directory;\n\n    size_t\n      entry;\n  } DirectoryInfo;\n\n  DirectoryInfo\n    directory_stack[MaxDirectoryStack];\n\n  EndianType\n    endian;\n\n  size_t\n    entry,\n    length,\n    number_entries;\n\n  ssize_t\n    id,\n    level,\n    offset;\n\n  static int\n    format_bytes[] = {0, 1, 1, 2, 4, 8, 1, 1, 2, 4, 8, 4, 8};\n\n  unsigned char\n    *directory,\n    *exif;\n\n  /*\n    Set EXIF resolution tag.\n  */\n  length=GetStringInfoLength(profile);\n  exif=GetStringInfoDatum(profile);\n  if (length < 16)\n    return(MagickFalse);\n  id=(ssize_t) ReadProfileShort(LSBEndian,exif);\n  if ((id != 0x4949) && (id != 0x4D4D))\n    {\n      while (length != 0)\n      {\n        if (ReadProfileByte(&exif,&length) != 0x45)\n          continue;\n        if (ReadProfileByte(&exif,&length) != 0x78)\n          continue;\n        if (ReadProfileByte(&exif,&length) != 0x69)\n          continue;\n        if (ReadProfileByte(&exif,&length) != 0x66)\n          continue;\n        if (ReadProfileByte(&exif,&length) != 0x00)\n          continue;\n        if (ReadProfileByte(&exif,&length) != 0x00)\n          continue;\n        break;\n      }\n      if (length < 16)\n        return(MagickFalse);\n      id=(ssize_t) ReadProfileShort(LSBEndian,exif);\n    }\n  endian=LSBEndian;\n  if (id == 0x4949)\n    endian=LSBEndian;\n  else\n    if (id == 0x4D4D)\n      endian=MSBEndian;\n    else\n      return(MagickFalse);\n  if (ReadProfileShort(endian,exif+2) != 0x002a)\n    return(MagickFalse);\n  /*\n    This the offset to the first IFD.\n  */\n  offset=(ssize_t) ReadProfileLong(endian,exif+4);\n  if ((offset < 0) || (size_t) offset >= length)\n    return(MagickFalse);\n  directory=exif+offset;\n  level=0;\n  entry=0;\n  do\n  {\n    if (level > 0)\n      {\n        level--;\n        directory=directory_stack[level].directory;\n        entry=directory_stack[level].entry;\n      }\n    if ((directory < exif) || (directory > (exif+length-2)))\n      break;\n    /*\n      Determine how many entries there are in the current IFD.\n    */\n    number_entries=ReadProfileShort(endian,directory);\n    for ( ; entry < number_entries; entry++)\n    {\n      int\n        components;\n\n      register unsigned char\n        *p,\n        *q;\n\n      size_t\n        number_bytes;\n\n      ssize_t\n        format,\n        tag_value;\n\n      q=(unsigned char *) (directory+2+(12*entry));\n      if (q > (exif+length-12))\n        break;  /* corrupt EXIF */\n      tag_value=(ssize_t) ReadProfileShort(endian,q);\n      format=(ssize_t) ReadProfileShort(endian,q+2);\n      if ((format < 0) || ((format-1) >= EXIF_NUM_FORMATS))\n        break;\n      components=(ssize_t) ReadProfileLong(endian,q+4);\n      if (components < 0)\n        break;  /* corrupt EXIF */\n      number_bytes=(size_t) components*format_bytes[format];\n      if ((ssize_t) number_bytes < components)\n        break;  /* prevent overflow */\n      if (number_bytes <= 4)\n        p=q+8;\n      else\n        {\n          /*\n            The directory entry contains an offset.\n          */\n          offset=(ssize_t)  ReadProfileLong(endian,q+8);\n          if ((size_t) (offset+number_bytes) > length)\n            continue;\n          if (~length < number_bytes)\n            continue;  /* prevent overflow */\n          p=(unsigned char *) (exif+offset);\n        }\n      switch (tag_value)\n      {\n        case 0x011a:\n        {\n          (void) WriteProfileLong(endian,(size_t) (image->resolution.x+0.5),p);\n          (void) WriteProfileLong(endian,1UL,p+4);\n          break;\n        }\n        case 0x011b:\n        {\n          (void) WriteProfileLong(endian,(size_t) (image->resolution.y+0.5),p);\n          (void) WriteProfileLong(endian,1UL,p+4);\n          break;\n        }\n        case 0x0112:\n        {\n          if (number_bytes == 4)\n            {\n              (void) WriteProfileLong(endian,(size_t) image->orientation,p);\n              break;\n            }\n          (void) WriteProfileShort(endian,(unsigned short) image->orientation,\n            p);\n          break;\n        }\n        case 0x0128:\n        {\n          if (number_bytes == 4)\n            {\n              (void) WriteProfileLong(endian,(size_t) (image->units+1),p);\n              break;\n            }\n          (void) WriteProfileShort(endian,(unsigned short) (image->units+1),p);\n          break;\n        }\n        default:\n          break;\n      }\n      if ((tag_value == TAG_EXIF_OFFSET) || (tag_value == TAG_INTEROP_OFFSET))\n        {\n          offset=(ssize_t)  ReadProfileLong(endian,p);\n          if (((size_t) offset < length) && (level < (MaxDirectoryStack-2)))\n            {\n              directory_stack[level].directory=directory;\n              entry++;\n              directory_stack[level].entry=entry;\n              level++;\n              directory_stack[level].directory=exif+offset;\n              directory_stack[level].entry=0;\n              level++;\n              if ((directory+2+(12*number_entries)) > (exif+length))\n                break;\n              offset=(ssize_t)  ReadProfileLong(endian,directory+2+(12*\n                number_entries));\n              if ((offset != 0) && ((size_t) offset < length) &&\n                  (level < (MaxDirectoryStack-2)))\n                {\n                  directory_stack[level].directory=exif+offset;\n                  directory_stack[level].entry=0;\n                  level++;\n                }\n            }\n          break;\n        }\n    }\n  } while (level > 0);\n  return(MagickTrue);\n}",
        "func": "MagickBooleanType SyncExifProfile(Image *image,StringInfo *profile)\n{\n#define MaxDirectoryStack  16\n#define EXIF_DELIMITER  \"\\n\"\n#define EXIF_NUM_FORMATS  12\n#define TAG_EXIF_OFFSET  0x8769\n#define TAG_INTEROP_OFFSET  0xa005\n\n  typedef struct _DirectoryInfo\n  {\n    unsigned char\n      *directory;\n\n    size_t\n      entry;\n  } DirectoryInfo;\n\n  DirectoryInfo\n    directory_stack[MaxDirectoryStack];\n\n  EndianType\n    endian;\n\n  size_t\n    entry,\n    length,\n    number_entries;\n\n  ssize_t\n    id,\n    level,\n    offset;\n\n  static int\n    format_bytes[] = {0, 1, 1, 2, 4, 8, 1, 1, 2, 4, 8, 4, 8};\n\n  unsigned char\n    *directory,\n    *exif;\n\n  /*\n    Set EXIF resolution tag.\n  */\n  length=GetStringInfoLength(profile);\n  exif=GetStringInfoDatum(profile);\n  if (length < 16)\n    return(MagickFalse);\n  id=(ssize_t) ReadProfileShort(LSBEndian,exif);\n  if ((id != 0x4949) && (id != 0x4D4D))\n    {\n      while (length != 0)\n      {\n        if (ReadProfileByte(&exif,&length) != 0x45)\n          continue;\n        if (ReadProfileByte(&exif,&length) != 0x78)\n          continue;\n        if (ReadProfileByte(&exif,&length) != 0x69)\n          continue;\n        if (ReadProfileByte(&exif,&length) != 0x66)\n          continue;\n        if (ReadProfileByte(&exif,&length) != 0x00)\n          continue;\n        if (ReadProfileByte(&exif,&length) != 0x00)\n          continue;\n        break;\n      }\n      if (length < 16)\n        return(MagickFalse);\n      id=(ssize_t) ReadProfileShort(LSBEndian,exif);\n    }\n  endian=LSBEndian;\n  if (id == 0x4949)\n    endian=LSBEndian;\n  else\n    if (id == 0x4D4D)\n      endian=MSBEndian;\n    else\n      return(MagickFalse);\n  if (ReadProfileShort(endian,exif+2) != 0x002a)\n    return(MagickFalse);\n  /*\n    This the offset to the first IFD.\n  */\n  offset=(ssize_t) ReadProfileLong(endian,exif+4);\n  if ((offset < 0) || (size_t) offset >= length)\n    return(MagickFalse);\n  directory=exif+offset;\n  level=0;\n  entry=0;\n  do\n  {\n    if (level > 0)\n      {\n        level--;\n        directory=directory_stack[level].directory;\n        entry=directory_stack[level].entry;\n      }\n    if ((directory < exif) || (directory > (exif+length-2)))\n      break;\n    /*\n      Determine how many entries there are in the current IFD.\n    */\n    number_entries=ReadProfileShort(endian,directory);\n    for ( ; entry < number_entries; entry++)\n    {\n      int\n        components;\n\n      register unsigned char\n        *p,\n        *q;\n\n      size_t\n        number_bytes;\n\n      ssize_t\n        format,\n        tag_value;\n\n      q=(unsigned char *) (directory+2+(12*entry));\n      if (q > (exif+length-12))\n        break;  /* corrupt EXIF */\n      tag_value=(ssize_t) ReadProfileShort(endian,q);\n      format=(ssize_t) ReadProfileShort(endian,q+2);\n      if ((format < 0) || ((format-1) >= EXIF_NUM_FORMATS))\n        break;\n      components=(ssize_t) ReadProfileLong(endian,q+4);\n      if (components < 0)\n        break;  /* corrupt EXIF */\n      number_bytes=(size_t) components*format_bytes[format];\n      if ((ssize_t) number_bytes < components)\n        break;  /* prevent overflow */\n      if (number_bytes <= 4)\n        p=q+8;\n      else\n        {\n          /*\n            The directory entry contains an offset.\n          */\n          offset=(ssize_t)  ReadProfileLong(endian,q+8);\n          if ((offset < 0) || ((size_t) (offset+number_bytes) > length))\n            continue;\n          if (~length < number_bytes)\n            continue;  /* prevent overflow */\n          p=(unsigned char *) (exif+offset);\n        }\n      switch (tag_value)\n      {\n        case 0x011a:\n        {\n          (void) WriteProfileLong(endian,(size_t) (image->resolution.x+0.5),p);\n          (void) WriteProfileLong(endian,1UL,p+4);\n          break;\n        }\n        case 0x011b:\n        {\n          (void) WriteProfileLong(endian,(size_t) (image->resolution.y+0.5),p);\n          (void) WriteProfileLong(endian,1UL,p+4);\n          break;\n        }\n        case 0x0112:\n        {\n          if (number_bytes == 4)\n            {\n              (void) WriteProfileLong(endian,(size_t) image->orientation,p);\n              break;\n            }\n          (void) WriteProfileShort(endian,(unsigned short) image->orientation,\n            p);\n          break;\n        }\n        case 0x0128:\n        {\n          if (number_bytes == 4)\n            {\n              (void) WriteProfileLong(endian,(size_t) (image->units+1),p);\n              break;\n            }\n          (void) WriteProfileShort(endian,(unsigned short) (image->units+1),p);\n          break;\n        }\n        default:\n          break;\n      }\n      if ((tag_value == TAG_EXIF_OFFSET) || (tag_value == TAG_INTEROP_OFFSET))\n        {\n          offset=(ssize_t)  ReadProfileLong(endian,p);\n          if (((size_t) offset < length) && (level < (MaxDirectoryStack-2)))\n            {\n              directory_stack[level].directory=directory;\n              entry++;\n              directory_stack[level].entry=entry;\n              level++;\n              directory_stack[level].directory=exif+offset;\n              directory_stack[level].entry=0;\n              level++;\n              if ((directory+2+(12*number_entries)) > (exif+length))\n                break;\n              offset=(ssize_t)  ReadProfileLong(endian,directory+2+(12*\n                number_entries));\n              if ((offset != 0) && ((size_t) offset < length) &&\n                  (level < (MaxDirectoryStack-2)))\n                {\n                  directory_stack[level].directory=exif+offset;\n                  directory_stack[level].entry=0;\n                  level++;\n                }\n            }\n          break;\n        }\n    }\n  } while (level > 0);\n  return(MagickTrue);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -138,7 +138,7 @@\n             The directory entry contains an offset.\n           */\n           offset=(ssize_t)  ReadProfileLong(endian,q+8);\n-          if ((size_t) (offset+number_bytes) > length)\n+          if ((offset < 0) || ((size_t) (offset+number_bytes) > length))\n             continue;\n           if (~length < number_bytes)\n             continue;  /* prevent overflow */",
        "diff_line_info": {
            "deleted_lines": [
                "          if ((size_t) (offset+number_bytes) > length)"
            ],
            "added_lines": [
                "          if ((offset < 0) || ((size_t) (offset+number_bytes) > length))"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-7393",
        "func_name": "TigerVNC/tigervnc/VNCSConnectionST::fence",
        "description": "In TigerVNC 1.7.1 (VNCSConnectionST.cxx VNCSConnectionST::fence), an authenticated client can cause a double free, leading to denial of service or potentially code execution.",
        "git_url": "https://github.com/TigerVNC/tigervnc/commit/f3afa24da144409a3c3a0e35913112583d987671",
        "commit_title": "Prevent double free by crafted fences.",
        "commit_text": " If client sent fence with some data, followed by fence with no data (length 0), the original fence data were freed, but the pointer kept pointing at them. Sending one more fence would attempt to free them again.",
        "func_before": "void VNCSConnectionST::fence(rdr::U32 flags, unsigned len, const char data[])\n{\n  if (flags & fenceFlagRequest) {\n    if (flags & fenceFlagSyncNext) {\n      pendingSyncFence = true;\n\n      fenceFlags = flags & (fenceFlagBlockBefore | fenceFlagBlockAfter | fenceFlagSyncNext);\n      fenceDataLen = len;\n      delete [] fenceData;\n      if (len > 0) {\n        fenceData = new char[len];\n        memcpy(fenceData, data, len);\n      }\n\n      return;\n    }\n\n    // We handle everything synchronously so we trivially honor these modes\n    flags = flags & (fenceFlagBlockBefore | fenceFlagBlockAfter);\n\n    writer()->writeFence(flags, len, data);\n    return;\n  }\n\n  struct RTTInfo rttInfo;\n\n  switch (len) {\n  case 0:\n    // Initial dummy fence;\n    break;\n  case sizeof(struct RTTInfo):\n    memcpy(&rttInfo, data, sizeof(struct RTTInfo));\n    handleRTTPong(rttInfo);\n    break;\n  default:\n    vlog.error(\"Fence response of unexpected size received\");\n  }\n}",
        "func": "void VNCSConnectionST::fence(rdr::U32 flags, unsigned len, const char data[])\n{\n  if (flags & fenceFlagRequest) {\n    if (flags & fenceFlagSyncNext) {\n      pendingSyncFence = true;\n\n      fenceFlags = flags & (fenceFlagBlockBefore | fenceFlagBlockAfter | fenceFlagSyncNext);\n      fenceDataLen = len;\n      delete [] fenceData;\n      fenceData = NULL;\n      if (len > 0) {\n        fenceData = new char[len];\n        memcpy(fenceData, data, len);\n      }\n\n      return;\n    }\n\n    // We handle everything synchronously so we trivially honor these modes\n    flags = flags & (fenceFlagBlockBefore | fenceFlagBlockAfter);\n\n    writer()->writeFence(flags, len, data);\n    return;\n  }\n\n  struct RTTInfo rttInfo;\n\n  switch (len) {\n  case 0:\n    // Initial dummy fence;\n    break;\n  case sizeof(struct RTTInfo):\n    memcpy(&rttInfo, data, sizeof(struct RTTInfo));\n    handleRTTPong(rttInfo);\n    break;\n  default:\n    vlog.error(\"Fence response of unexpected size received\");\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -7,6 +7,7 @@\n       fenceFlags = flags & (fenceFlagBlockBefore | fenceFlagBlockAfter | fenceFlagSyncNext);\n       fenceDataLen = len;\n       delete [] fenceData;\n+      fenceData = NULL;\n       if (len > 0) {\n         fenceData = new char[len];\n         memcpy(fenceData, data, len);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "      fenceData = NULL;"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-7393",
        "func_name": "TigerVNC/tigervnc/SMsgWriter::writeFence",
        "description": "In TigerVNC 1.7.1 (VNCSConnectionST.cxx VNCSConnectionST::fence), an authenticated client can cause a double free, leading to denial of service or potentially code execution.",
        "git_url": "https://github.com/TigerVNC/tigervnc/commit/f3afa24da144409a3c3a0e35913112583d987671",
        "commit_title": "Prevent double free by crafted fences.",
        "commit_text": " If client sent fence with some data, followed by fence with no data (length 0), the original fence data were freed, but the pointer kept pointing at them. Sending one more fence would attempt to free them again.",
        "func_before": "void SMsgWriter::writeFence(rdr::U32 flags, unsigned len, const char data[])\n{\n  if (!cp->supportsFence)\n    throw Exception(\"Client does not support fences\");\n  if (len > 64)\n    throw Exception(\"Too large fence payload\");\n  if ((flags & ~fenceFlagsSupported) != 0)\n    throw Exception(\"Unknown fence flags\");\n\n  startMsg(msgTypeServerFence);\n  os->pad(3);\n\n  os->writeU32(flags);\n\n  os->writeU8(len);\n  os->writeBytes(data, len);\n\n  endMsg();\n}",
        "func": "void SMsgWriter::writeFence(rdr::U32 flags, unsigned len, const char data[])\n{\n  if (!cp->supportsFence)\n    throw Exception(\"Client does not support fences\");\n  if (len > 64)\n    throw Exception(\"Too large fence payload\");\n  if ((flags & ~fenceFlagsSupported) != 0)\n    throw Exception(\"Unknown fence flags\");\n\n  startMsg(msgTypeServerFence);\n  os->pad(3);\n\n  os->writeU32(flags);\n\n  os->writeU8(len);\n\n  if (len > 0)\n    os->writeBytes(data, len);\n\n  endMsg();\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -13,7 +13,9 @@\n   os->writeU32(flags);\n \n   os->writeU8(len);\n-  os->writeBytes(data, len);\n+\n+  if (len > 0)\n+    os->writeBytes(data, len);\n \n   endMsg();\n }",
        "diff_line_info": {
            "deleted_lines": [
                "  os->writeBytes(data, len);"
            ],
            "added_lines": [
                "",
                "  if (len > 0)",
                "    os->writeBytes(data, len);"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-8890",
        "func_name": "torvalds/linux/inet_csk_clone_lock",
        "description": "The inet_csk_clone_lock function in net/ipv4/inet_connection_sock.c in the Linux kernel through 4.10.15 allows attackers to cause a denial of service (double free) or possibly have unspecified other impact by leveraging use of the accept system call.",
        "git_url": "https://github.com/torvalds/linux/commit/657831ffc38e30092a2d5f03d385d710eb88b09a",
        "commit_title": "dccp/tcp: do not inherit mc_list from parent",
        "commit_text": " syzkaller found a way to trigger double frees from ip_mc_drop_socket()  It turns out that leave a copy of parent mc_list at accept() time, which is very bad.  Very similar to commit 8b485ce69876 (\"tcp: do not inherit fastopen_req from parent\")  Initial report from Pray3r, completed by Andrey one. Thanks a lot to them ! ",
        "func_before": "struct sock *inet_csk_clone_lock(const struct sock *sk,\n\t\t\t\t const struct request_sock *req,\n\t\t\t\t const gfp_t priority)\n{\n\tstruct sock *newsk = sk_clone_lock(sk, priority);\n\n\tif (newsk) {\n\t\tstruct inet_connection_sock *newicsk = inet_csk(newsk);\n\n\t\tnewsk->sk_state = TCP_SYN_RECV;\n\t\tnewicsk->icsk_bind_hash = NULL;\n\n\t\tinet_sk(newsk)->inet_dport = inet_rsk(req)->ir_rmt_port;\n\t\tinet_sk(newsk)->inet_num = inet_rsk(req)->ir_num;\n\t\tinet_sk(newsk)->inet_sport = htons(inet_rsk(req)->ir_num);\n\t\tnewsk->sk_write_space = sk_stream_write_space;\n\n\t\t/* listeners have SOCK_RCU_FREE, not the children */\n\t\tsock_reset_flag(newsk, SOCK_RCU_FREE);\n\n\t\tnewsk->sk_mark = inet_rsk(req)->ir_mark;\n\t\tatomic64_set(&newsk->sk_cookie,\n\t\t\t     atomic64_read(&inet_rsk(req)->ir_cookie));\n\n\t\tnewicsk->icsk_retransmits = 0;\n\t\tnewicsk->icsk_backoff\t  = 0;\n\t\tnewicsk->icsk_probes_out  = 0;\n\n\t\t/* Deinitialize accept_queue to trap illegal accesses. */\n\t\tmemset(&newicsk->icsk_accept_queue, 0, sizeof(newicsk->icsk_accept_queue));\n\n\t\tsecurity_inet_csk_clone(newsk, req);\n\t}\n\treturn newsk;\n}",
        "func": "struct sock *inet_csk_clone_lock(const struct sock *sk,\n\t\t\t\t const struct request_sock *req,\n\t\t\t\t const gfp_t priority)\n{\n\tstruct sock *newsk = sk_clone_lock(sk, priority);\n\n\tif (newsk) {\n\t\tstruct inet_connection_sock *newicsk = inet_csk(newsk);\n\n\t\tnewsk->sk_state = TCP_SYN_RECV;\n\t\tnewicsk->icsk_bind_hash = NULL;\n\n\t\tinet_sk(newsk)->inet_dport = inet_rsk(req)->ir_rmt_port;\n\t\tinet_sk(newsk)->inet_num = inet_rsk(req)->ir_num;\n\t\tinet_sk(newsk)->inet_sport = htons(inet_rsk(req)->ir_num);\n\t\tnewsk->sk_write_space = sk_stream_write_space;\n\n\t\t/* listeners have SOCK_RCU_FREE, not the children */\n\t\tsock_reset_flag(newsk, SOCK_RCU_FREE);\n\n\t\tinet_sk(newsk)->mc_list = NULL;\n\n\t\tnewsk->sk_mark = inet_rsk(req)->ir_mark;\n\t\tatomic64_set(&newsk->sk_cookie,\n\t\t\t     atomic64_read(&inet_rsk(req)->ir_cookie));\n\n\t\tnewicsk->icsk_retransmits = 0;\n\t\tnewicsk->icsk_backoff\t  = 0;\n\t\tnewicsk->icsk_probes_out  = 0;\n\n\t\t/* Deinitialize accept_queue to trap illegal accesses. */\n\t\tmemset(&newicsk->icsk_accept_queue, 0, sizeof(newicsk->icsk_accept_queue));\n\n\t\tsecurity_inet_csk_clone(newsk, req);\n\t}\n\treturn newsk;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -18,6 +18,8 @@\n \t\t/* listeners have SOCK_RCU_FREE, not the children */\n \t\tsock_reset_flag(newsk, SOCK_RCU_FREE);\n \n+\t\tinet_sk(newsk)->mc_list = NULL;\n+\n \t\tnewsk->sk_mark = inet_rsk(req)->ir_mark;\n \t\tatomic64_set(&newsk->sk_cookie,\n \t\t\t     atomic64_read(&inet_rsk(req)->ir_cookie));",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\tinet_sk(newsk)->mc_list = NULL;",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2017-10913",
        "func_name": "xen-project/xen/__gnttab_unmap_common_complete",
        "description": "The grant-table feature in Xen through 4.8.x provides false mapping information in certain cases of concurrent unmap calls, which allows backend attackers to obtain sensitive information or gain privileges, aka XSA-218 bug 1.",
        "git_url": "https://github.com/xen-project/xen/commit/b7f6cbb9d43f7384e1f38f8764b9a48216c8a525",
        "commit_title": "gnttab: Avoid potential double-put of maptrack entry",
        "commit_text": " Each grant mapping for a particular domain is tracked by an in-Xen \"maptrack\" entry.  This entry is is referenced by a \"handle\", which is given to the guest when it calls gnttab_map_grant_ref().  There are two types of mapping a particular handle can refer to: GNTMAP_host_map and GNTMAP_device_map.  A given gnttab_unmap_grant_ref() call can remove either only one or both of these entries.  When a particular handle has no entries left, it must be freed.  gnttab_unmap_grant_ref() loops through its grant unmap request list twice.  It first removes entries from any host pagetables and (if appropraite) iommus; then it does a single domain TLB flush; then it does the clean-up, including telling the granter that entries are no longer being used (if appropriate).  At the moment, it's during the first pass that the maptrack flags are cleared, but the second pass that the maptrack entry is freed.  Unfortunately this allows the following race, which results in a double-free:   A: (pass 1) clear host_map  B: (pass 1) clear device_map  A: (pass 2) See that maptrack entry has no mappings, free it  B: (pass 2) See that maptrack entry has no mappings, free it #  Unfortunately, unlike the active entry pinning update, we can't simply move the maptrack flag changes to the second half, because the maptrack flags are used to determine if iommu entries need to be added: a domain's iommu must never have fewer permissions than the maptrack flags indicate, or a subsequent map_grant_ref() might fail to add the necessary iommu entries.  Instead, free the maptrack entry in the first pass if there are no further mappings.  This is part of XSA-218. ",
        "func_before": "static void\n__gnttab_unmap_common_complete(struct gnttab_unmap_common *op)\n{\n    struct domain *ld, *rd = op->rd;\n    struct grant_table *rgt;\n    struct active_grant_entry *act;\n    grant_entry_header_t *sha;\n    struct page_info *pg;\n    uint16_t *status;\n    bool_t put_handle = 0;\n\n    if ( rd == NULL )\n    { \n        /*\n         * Suggests that __gntab_unmap_common failed in\n         * rcu_lock_domain_by_id() or earlier, and so we have nothing\n         * to complete\n         */\n        return;\n    }\n\n    ld = current->domain;\n\n    rcu_lock_domain(rd);\n    rgt = rd->grant_table;\n\n    grant_read_lock(rgt);\n    if ( rgt->gt_version == 0 )\n        goto unlock_out;\n\n    act = active_entry_acquire(rgt, op->map->ref);\n    sha = shared_entry_header(rgt, op->map->ref);\n\n    if ( rgt->gt_version == 1 )\n        status = &sha->flags;\n    else\n        status = &status_entry(rgt, op->map->ref);\n\n    if ( unlikely(op->frame != act->frame) ) \n    {\n        /*\n         * Suggests that __gntab_unmap_common failed early and so\n         * nothing further to do\n         */\n        goto act_release_out;\n    }\n\n    pg = mfn_to_page(op->frame);\n\n    if ( op->flags & GNTMAP_device_map ) \n    {\n        if ( !is_iomem_page(_mfn(act->frame)) )\n        {\n            if ( op->flags & GNTMAP_readonly )\n                put_page(pg);\n            else\n                put_page_and_type(pg);\n        }\n\n        ASSERT(act->pin & (GNTPIN_devw_mask | GNTPIN_devr_mask));\n        if ( op->flags & GNTMAP_readonly )\n            act->pin -= GNTPIN_devr_inc;\n        else\n            act->pin -= GNTPIN_devw_inc;\n    }\n\n    if ( (op->host_addr != 0) && (op->flags & GNTMAP_host_map) )\n    {\n        if ( op->status != 0 ) \n        {\n            /*\n             * Suggests that __gntab_unmap_common failed in\n             * replace_grant_host_mapping() or IOMMU handling, so nothing\n             * further to do (short of re-establishing the mapping in the\n             * latter case).\n             */\n            goto act_release_out;\n        }\n\n        if ( !is_iomem_page(_mfn(op->frame)) )\n        {\n            if ( gnttab_host_mapping_get_page_type(op, ld, rd) )\n                put_page_type(pg);\n            put_page(pg);\n        }\n\n        ASSERT(act->pin & (GNTPIN_hstw_mask | GNTPIN_hstr_mask));\n        if ( op->flags & GNTMAP_readonly )\n            act->pin -= GNTPIN_hstr_inc;\n        else\n            act->pin -= GNTPIN_hstw_inc;\n    }\n\n    if ( (op->map->flags & (GNTMAP_device_map|GNTMAP_host_map)) == 0 )\n        put_handle = 1;\n\n    if ( ((act->pin & (GNTPIN_devw_mask|GNTPIN_hstw_mask)) == 0) &&\n         !(op->flags & GNTMAP_readonly) )\n        gnttab_clear_flag(_GTF_writing, status);\n\n    if ( act->pin == 0 )\n        gnttab_clear_flag(_GTF_reading, status);\n\n act_release_out:\n    active_entry_release(act);\n unlock_out:\n    grant_read_unlock(rgt);\n\n    if ( put_handle )\n    {\n        op->map->flags = 0;\n        put_maptrack_handle(ld->grant_table, op->handle);\n    }\n    rcu_unlock_domain(rd);\n}",
        "func": "static void\n__gnttab_unmap_common_complete(struct gnttab_unmap_common *op)\n{\n    struct domain *ld, *rd = op->rd;\n    struct grant_table *rgt;\n    struct active_grant_entry *act;\n    grant_entry_header_t *sha;\n    struct page_info *pg;\n    uint16_t *status;\n\n    if ( rd == NULL )\n    { \n        /*\n         * Suggests that __gntab_unmap_common failed in\n         * rcu_lock_domain_by_id() or earlier, and so we have nothing\n         * to complete\n         */\n        return;\n    }\n\n    ld = current->domain;\n\n    rcu_lock_domain(rd);\n    rgt = rd->grant_table;\n\n    grant_read_lock(rgt);\n    if ( rgt->gt_version == 0 )\n        goto unlock_out;\n\n    act = active_entry_acquire(rgt, op->ref);\n    sha = shared_entry_header(rgt, op->ref);\n\n    if ( rgt->gt_version == 1 )\n        status = &sha->flags;\n    else\n        status = &status_entry(rgt, op->ref);\n\n    if ( unlikely(op->frame != act->frame) ) \n    {\n        /*\n         * Suggests that __gntab_unmap_common failed early and so\n         * nothing further to do\n         */\n        goto act_release_out;\n    }\n\n    pg = mfn_to_page(op->frame);\n\n    if ( op->flags & GNTMAP_device_map ) \n    {\n        if ( !is_iomem_page(_mfn(act->frame)) )\n        {\n            if ( op->flags & GNTMAP_readonly )\n                put_page(pg);\n            else\n                put_page_and_type(pg);\n        }\n\n        ASSERT(act->pin & (GNTPIN_devw_mask | GNTPIN_devr_mask));\n        if ( op->flags & GNTMAP_readonly )\n            act->pin -= GNTPIN_devr_inc;\n        else\n            act->pin -= GNTPIN_devw_inc;\n    }\n\n    if ( (op->host_addr != 0) && (op->flags & GNTMAP_host_map) )\n    {\n        if ( op->status != 0 ) \n        {\n            /*\n             * Suggests that __gntab_unmap_common failed in\n             * replace_grant_host_mapping() or IOMMU handling, so nothing\n             * further to do (short of re-establishing the mapping in the\n             * latter case).\n             */\n            goto act_release_out;\n        }\n\n        if ( !is_iomem_page(_mfn(op->frame)) )\n        {\n            if ( gnttab_host_mapping_get_page_type(op, ld, rd) )\n                put_page_type(pg);\n            put_page(pg);\n        }\n\n        ASSERT(act->pin & (GNTPIN_hstw_mask | GNTPIN_hstr_mask));\n        if ( op->flags & GNTMAP_readonly )\n            act->pin -= GNTPIN_hstr_inc;\n        else\n            act->pin -= GNTPIN_hstw_inc;\n    }\n\n    if ( ((act->pin & (GNTPIN_devw_mask|GNTPIN_hstw_mask)) == 0) &&\n         !(op->flags & GNTMAP_readonly) )\n        gnttab_clear_flag(_GTF_writing, status);\n\n    if ( act->pin == 0 )\n        gnttab_clear_flag(_GTF_reading, status);\n\n act_release_out:\n    active_entry_release(act);\n unlock_out:\n    grant_read_unlock(rgt);\n\n    rcu_unlock_domain(rd);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -7,7 +7,6 @@\n     grant_entry_header_t *sha;\n     struct page_info *pg;\n     uint16_t *status;\n-    bool_t put_handle = 0;\n \n     if ( rd == NULL )\n     { \n@@ -28,13 +27,13 @@\n     if ( rgt->gt_version == 0 )\n         goto unlock_out;\n \n-    act = active_entry_acquire(rgt, op->map->ref);\n-    sha = shared_entry_header(rgt, op->map->ref);\n+    act = active_entry_acquire(rgt, op->ref);\n+    sha = shared_entry_header(rgt, op->ref);\n \n     if ( rgt->gt_version == 1 )\n         status = &sha->flags;\n     else\n-        status = &status_entry(rgt, op->map->ref);\n+        status = &status_entry(rgt, op->ref);\n \n     if ( unlikely(op->frame != act->frame) ) \n     {\n@@ -91,9 +90,6 @@\n             act->pin -= GNTPIN_hstw_inc;\n     }\n \n-    if ( (op->map->flags & (GNTMAP_device_map|GNTMAP_host_map)) == 0 )\n-        put_handle = 1;\n-\n     if ( ((act->pin & (GNTPIN_devw_mask|GNTPIN_hstw_mask)) == 0) &&\n          !(op->flags & GNTMAP_readonly) )\n         gnttab_clear_flag(_GTF_writing, status);\n@@ -106,10 +102,5 @@\n  unlock_out:\n     grant_read_unlock(rgt);\n \n-    if ( put_handle )\n-    {\n-        op->map->flags = 0;\n-        put_maptrack_handle(ld->grant_table, op->handle);\n-    }\n     rcu_unlock_domain(rd);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    bool_t put_handle = 0;",
                "    act = active_entry_acquire(rgt, op->map->ref);",
                "    sha = shared_entry_header(rgt, op->map->ref);",
                "        status = &status_entry(rgt, op->map->ref);",
                "    if ( (op->map->flags & (GNTMAP_device_map|GNTMAP_host_map)) == 0 )",
                "        put_handle = 1;",
                "",
                "    if ( put_handle )",
                "    {",
                "        op->map->flags = 0;",
                "        put_maptrack_handle(ld->grant_table, op->handle);",
                "    }"
            ],
            "added_lines": [
                "    act = active_entry_acquire(rgt, op->ref);",
                "    sha = shared_entry_header(rgt, op->ref);",
                "        status = &status_entry(rgt, op->ref);"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-10913",
        "func_name": "xen-project/xen/__gnttab_unmap_common",
        "description": "The grant-table feature in Xen through 4.8.x provides false mapping information in certain cases of concurrent unmap calls, which allows backend attackers to obtain sensitive information or gain privileges, aka XSA-218 bug 1.",
        "git_url": "https://github.com/xen-project/xen/commit/b7f6cbb9d43f7384e1f38f8764b9a48216c8a525",
        "commit_title": "gnttab: Avoid potential double-put of maptrack entry",
        "commit_text": " Each grant mapping for a particular domain is tracked by an in-Xen \"maptrack\" entry.  This entry is is referenced by a \"handle\", which is given to the guest when it calls gnttab_map_grant_ref().  There are two types of mapping a particular handle can refer to: GNTMAP_host_map and GNTMAP_device_map.  A given gnttab_unmap_grant_ref() call can remove either only one or both of these entries.  When a particular handle has no entries left, it must be freed.  gnttab_unmap_grant_ref() loops through its grant unmap request list twice.  It first removes entries from any host pagetables and (if appropraite) iommus; then it does a single domain TLB flush; then it does the clean-up, including telling the granter that entries are no longer being used (if appropriate).  At the moment, it's during the first pass that the maptrack flags are cleared, but the second pass that the maptrack entry is freed.  Unfortunately this allows the following race, which results in a double-free:   A: (pass 1) clear host_map  B: (pass 1) clear device_map  A: (pass 2) See that maptrack entry has no mappings, free it  B: (pass 2) See that maptrack entry has no mappings, free it #  Unfortunately, unlike the active entry pinning update, we can't simply move the maptrack flag changes to the second half, because the maptrack flags are used to determine if iommu entries need to be added: a domain's iommu must never have fewer permissions than the maptrack flags indicate, or a subsequent map_grant_ref() might fail to add the necessary iommu entries.  Instead, free the maptrack entry in the first pass if there are no further mappings.  This is part of XSA-218. ",
        "func_before": "static void\n__gnttab_unmap_common(\n    struct gnttab_unmap_common *op)\n{\n    domid_t          dom;\n    struct domain   *ld, *rd;\n    struct grant_table *lgt, *rgt;\n    struct active_grant_entry *act;\n    s16              rc = 0;\n\n    ld = current->domain;\n    lgt = ld->grant_table;\n\n    op->frame = (unsigned long)(op->dev_bus_addr >> PAGE_SHIFT);\n\n    if ( unlikely(op->handle >= lgt->maptrack_limit) )\n    {\n        gdprintk(XENLOG_INFO, \"Bad handle %#x\\n\", op->handle);\n        op->status = GNTST_bad_handle;\n        return;\n    }\n\n    op->map = &maptrack_entry(lgt, op->handle);\n\n    grant_read_lock(lgt);\n\n    if ( unlikely(!read_atomic(&op->map->flags)) )\n    {\n        grant_read_unlock(lgt);\n        gdprintk(XENLOG_INFO, \"Zero flags for handle %#x\\n\", op->handle);\n        op->status = GNTST_bad_handle;\n        return;\n    }\n\n    dom = op->map->domid;\n    grant_read_unlock(lgt);\n\n    if ( unlikely((rd = rcu_lock_domain_by_id(dom)) == NULL) )\n    {\n        /* This can happen when a grant is implicitly unmapped. */\n        gdprintk(XENLOG_INFO, \"Could not find domain %d\\n\", dom);\n        domain_crash(ld); /* naughty... */\n        return;\n    }\n\n    rc = xsm_grant_unmapref(XSM_HOOK, ld, rd);\n    if ( rc )\n    {\n        rcu_unlock_domain(rd);\n        op->status = GNTST_permission_denied;\n        return;\n    }\n\n    TRACE_1D(TRC_MEM_PAGE_GRANT_UNMAP, dom);\n\n    rgt = rd->grant_table;\n\n    grant_read_lock(rgt);\n\n    op->flags = read_atomic(&op->map->flags);\n    if ( unlikely(!op->flags) || unlikely(op->map->domid != dom) )\n    {\n        gdprintk(XENLOG_WARNING, \"Unstable handle %#x\\n\", op->handle);\n        rc = GNTST_bad_handle;\n        goto unmap_out;\n    }\n\n    op->rd = rd;\n    act = active_entry_acquire(rgt, op->map->ref);\n\n    if ( op->frame == 0 )\n    {\n        op->frame = act->frame;\n    }\n    else\n    {\n        if ( unlikely(op->frame != act->frame) )\n            PIN_FAIL(act_release_out, GNTST_general_error,\n                     \"Bad frame number doesn't match gntref. (%lx != %lx)\\n\",\n                     op->frame, act->frame);\n\n        op->map->flags &= ~GNTMAP_device_map;\n    }\n\n    if ( (op->host_addr != 0) && (op->flags & GNTMAP_host_map) )\n    {\n        if ( (rc = replace_grant_host_mapping(op->host_addr,\n                                              op->frame, op->new_addr, \n                                              op->flags)) < 0 )\n            goto act_release_out;\n\n        op->map->flags &= ~GNTMAP_host_map;\n    }\n\n act_release_out:\n    active_entry_release(act);\n unmap_out:\n    grant_read_unlock(rgt);\n\n    if ( rc == GNTST_okay && gnttab_need_iommu_mapping(ld) )\n    {\n        unsigned int kind;\n        int err = 0;\n\n        double_gt_lock(lgt, rgt);\n\n        kind = mapkind(lgt, rd, op->frame);\n        if ( !kind )\n            err = iommu_unmap_page(ld, op->frame);\n        else if ( !(kind & MAPKIND_WRITE) )\n            err = iommu_map_page(ld, op->frame, op->frame, IOMMUF_readable);\n\n        double_gt_unlock(lgt, rgt);\n\n        if ( err )\n            rc = GNTST_general_error;\n    }\n\n    /* If just unmapped a writable mapping, mark as dirtied */\n    if ( rc == GNTST_okay && !(op->flags & GNTMAP_readonly) )\n         gnttab_mark_dirty(rd, op->frame);\n\n    op->status = rc;\n    rcu_unlock_domain(rd);\n}",
        "func": "static void\n__gnttab_unmap_common(\n    struct gnttab_unmap_common *op)\n{\n    domid_t          dom;\n    struct domain   *ld, *rd;\n    struct grant_table *lgt, *rgt;\n    struct active_grant_entry *act;\n    s16              rc = 0;\n    struct grant_mapping *map;\n    bool put_handle = false;\n\n    ld = current->domain;\n    lgt = ld->grant_table;\n\n    op->frame = (unsigned long)(op->dev_bus_addr >> PAGE_SHIFT);\n\n    if ( unlikely(op->handle >= lgt->maptrack_limit) )\n    {\n        gdprintk(XENLOG_INFO, \"Bad handle %#x\\n\", op->handle);\n        op->status = GNTST_bad_handle;\n        return;\n    }\n\n    map = &maptrack_entry(lgt, op->handle);\n\n    grant_read_lock(lgt);\n\n    if ( unlikely(!read_atomic(&map->flags)) )\n    {\n        grant_read_unlock(lgt);\n        gdprintk(XENLOG_INFO, \"Zero flags for handle %#x\\n\", op->handle);\n        op->status = GNTST_bad_handle;\n        return;\n    }\n\n    dom = map->domid;\n    grant_read_unlock(lgt);\n\n    if ( unlikely((rd = rcu_lock_domain_by_id(dom)) == NULL) )\n    {\n        /* This can happen when a grant is implicitly unmapped. */\n        gdprintk(XENLOG_INFO, \"Could not find domain %d\\n\", dom);\n        domain_crash(ld); /* naughty... */\n        return;\n    }\n\n    rc = xsm_grant_unmapref(XSM_HOOK, ld, rd);\n    if ( rc )\n    {\n        rcu_unlock_domain(rd);\n        op->status = GNTST_permission_denied;\n        return;\n    }\n\n    TRACE_1D(TRC_MEM_PAGE_GRANT_UNMAP, dom);\n\n    rgt = rd->grant_table;\n\n    grant_read_lock(rgt);\n\n    op->rd = rd;\n    op->ref = map->ref;\n\n    /*\n     * We can't assume there was no racing unmap for this maptrack entry,\n     * and hence we can't assume map->ref is valid for rd. While the checks\n     * below (with the active entry lock held) will reject any such racing\n     * requests, we still need to make sure we don't attempt to acquire an\n     * invalid lock.\n     */\n    smp_rmb();\n    if ( unlikely(op->ref >= nr_grant_entries(rgt)) )\n    {\n        gdprintk(XENLOG_WARNING, \"Unstable handle %#x\\n\", op->handle);\n        rc = GNTST_bad_handle;\n        goto unlock_out;\n    }\n\n    act = active_entry_acquire(rgt, op->ref);\n\n    /*\n     * Note that we (ab)use the active entry lock here to protect against\n     * multiple unmaps of the same mapping here. We don't want to hold lgt's\n     * lock, and we only hold rgt's lock for reading (but the latter wouldn't\n     * be the right one anyway). Hence the easiest is to rely on a lock we\n     * hold anyway; see docs/misc/grant-tables.txt's \"Locking\" section.\n     */\n\n    op->flags = read_atomic(&map->flags);\n    smp_rmb();\n    if ( unlikely(!op->flags) || unlikely(map->domid != dom) ||\n         unlikely(map->ref != op->ref) )\n    {\n        gdprintk(XENLOG_WARNING, \"Unstable handle %#x\\n\", op->handle);\n        rc = GNTST_bad_handle;\n        goto act_release_out;\n    }\n\n    if ( op->frame == 0 )\n    {\n        op->frame = act->frame;\n    }\n    else\n    {\n        if ( unlikely(op->frame != act->frame) )\n            PIN_FAIL(act_release_out, GNTST_general_error,\n                     \"Bad frame number doesn't match gntref. (%lx != %lx)\\n\",\n                     op->frame, act->frame);\n\n        map->flags &= ~GNTMAP_device_map;\n    }\n\n    if ( (op->host_addr != 0) && (op->flags & GNTMAP_host_map) )\n    {\n        if ( (rc = replace_grant_host_mapping(op->host_addr,\n                                              op->frame, op->new_addr, \n                                              op->flags)) < 0 )\n            goto act_release_out;\n\n        map->flags &= ~GNTMAP_host_map;\n    }\n\n    if ( !(map->flags & (GNTMAP_device_map|GNTMAP_host_map)) )\n    {\n        map->flags = 0;\n        put_handle = true;\n    }\n\n act_release_out:\n    active_entry_release(act);\n unlock_out:\n    grant_read_unlock(rgt);\n\n    if ( put_handle )\n        put_maptrack_handle(lgt, op->handle);\n\n    if ( rc == GNTST_okay && gnttab_need_iommu_mapping(ld) )\n    {\n        unsigned int kind;\n        int err = 0;\n\n        double_gt_lock(lgt, rgt);\n\n        kind = mapkind(lgt, rd, op->frame);\n        if ( !kind )\n            err = iommu_unmap_page(ld, op->frame);\n        else if ( !(kind & MAPKIND_WRITE) )\n            err = iommu_map_page(ld, op->frame, op->frame, IOMMUF_readable);\n\n        double_gt_unlock(lgt, rgt);\n\n        if ( err )\n            rc = GNTST_general_error;\n    }\n\n    /* If just unmapped a writable mapping, mark as dirtied */\n    if ( rc == GNTST_okay && !(op->flags & GNTMAP_readonly) )\n         gnttab_mark_dirty(rd, op->frame);\n\n    op->status = rc;\n    rcu_unlock_domain(rd);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -7,6 +7,8 @@\n     struct grant_table *lgt, *rgt;\n     struct active_grant_entry *act;\n     s16              rc = 0;\n+    struct grant_mapping *map;\n+    bool put_handle = false;\n \n     ld = current->domain;\n     lgt = ld->grant_table;\n@@ -20,11 +22,11 @@\n         return;\n     }\n \n-    op->map = &maptrack_entry(lgt, op->handle);\n+    map = &maptrack_entry(lgt, op->handle);\n \n     grant_read_lock(lgt);\n \n-    if ( unlikely(!read_atomic(&op->map->flags)) )\n+    if ( unlikely(!read_atomic(&map->flags)) )\n     {\n         grant_read_unlock(lgt);\n         gdprintk(XENLOG_INFO, \"Zero flags for handle %#x\\n\", op->handle);\n@@ -32,7 +34,7 @@\n         return;\n     }\n \n-    dom = op->map->domid;\n+    dom = map->domid;\n     grant_read_unlock(lgt);\n \n     if ( unlikely((rd = rcu_lock_domain_by_id(dom)) == NULL) )\n@@ -57,16 +59,43 @@\n \n     grant_read_lock(rgt);\n \n-    op->flags = read_atomic(&op->map->flags);\n-    if ( unlikely(!op->flags) || unlikely(op->map->domid != dom) )\n+    op->rd = rd;\n+    op->ref = map->ref;\n+\n+    /*\n+     * We can't assume there was no racing unmap for this maptrack entry,\n+     * and hence we can't assume map->ref is valid for rd. While the checks\n+     * below (with the active entry lock held) will reject any such racing\n+     * requests, we still need to make sure we don't attempt to acquire an\n+     * invalid lock.\n+     */\n+    smp_rmb();\n+    if ( unlikely(op->ref >= nr_grant_entries(rgt)) )\n     {\n         gdprintk(XENLOG_WARNING, \"Unstable handle %#x\\n\", op->handle);\n         rc = GNTST_bad_handle;\n-        goto unmap_out;\n+        goto unlock_out;\n     }\n \n-    op->rd = rd;\n-    act = active_entry_acquire(rgt, op->map->ref);\n+    act = active_entry_acquire(rgt, op->ref);\n+\n+    /*\n+     * Note that we (ab)use the active entry lock here to protect against\n+     * multiple unmaps of the same mapping here. We don't want to hold lgt's\n+     * lock, and we only hold rgt's lock for reading (but the latter wouldn't\n+     * be the right one anyway). Hence the easiest is to rely on a lock we\n+     * hold anyway; see docs/misc/grant-tables.txt's \"Locking\" section.\n+     */\n+\n+    op->flags = read_atomic(&map->flags);\n+    smp_rmb();\n+    if ( unlikely(!op->flags) || unlikely(map->domid != dom) ||\n+         unlikely(map->ref != op->ref) )\n+    {\n+        gdprintk(XENLOG_WARNING, \"Unstable handle %#x\\n\", op->handle);\n+        rc = GNTST_bad_handle;\n+        goto act_release_out;\n+    }\n \n     if ( op->frame == 0 )\n     {\n@@ -79,7 +108,7 @@\n                      \"Bad frame number doesn't match gntref. (%lx != %lx)\\n\",\n                      op->frame, act->frame);\n \n-        op->map->flags &= ~GNTMAP_device_map;\n+        map->flags &= ~GNTMAP_device_map;\n     }\n \n     if ( (op->host_addr != 0) && (op->flags & GNTMAP_host_map) )\n@@ -89,13 +118,22 @@\n                                               op->flags)) < 0 )\n             goto act_release_out;\n \n-        op->map->flags &= ~GNTMAP_host_map;\n+        map->flags &= ~GNTMAP_host_map;\n+    }\n+\n+    if ( !(map->flags & (GNTMAP_device_map|GNTMAP_host_map)) )\n+    {\n+        map->flags = 0;\n+        put_handle = true;\n     }\n \n  act_release_out:\n     active_entry_release(act);\n- unmap_out:\n+ unlock_out:\n     grant_read_unlock(rgt);\n+\n+    if ( put_handle )\n+        put_maptrack_handle(lgt, op->handle);\n \n     if ( rc == GNTST_okay && gnttab_need_iommu_mapping(ld) )\n     {",
        "diff_line_info": {
            "deleted_lines": [
                "    op->map = &maptrack_entry(lgt, op->handle);",
                "    if ( unlikely(!read_atomic(&op->map->flags)) )",
                "    dom = op->map->domid;",
                "    op->flags = read_atomic(&op->map->flags);",
                "    if ( unlikely(!op->flags) || unlikely(op->map->domid != dom) )",
                "        goto unmap_out;",
                "    op->rd = rd;",
                "    act = active_entry_acquire(rgt, op->map->ref);",
                "        op->map->flags &= ~GNTMAP_device_map;",
                "        op->map->flags &= ~GNTMAP_host_map;",
                " unmap_out:"
            ],
            "added_lines": [
                "    struct grant_mapping *map;",
                "    bool put_handle = false;",
                "    map = &maptrack_entry(lgt, op->handle);",
                "    if ( unlikely(!read_atomic(&map->flags)) )",
                "    dom = map->domid;",
                "    op->rd = rd;",
                "    op->ref = map->ref;",
                "",
                "    /*",
                "     * We can't assume there was no racing unmap for this maptrack entry,",
                "     * and hence we can't assume map->ref is valid for rd. While the checks",
                "     * below (with the active entry lock held) will reject any such racing",
                "     * requests, we still need to make sure we don't attempt to acquire an",
                "     * invalid lock.",
                "     */",
                "    smp_rmb();",
                "    if ( unlikely(op->ref >= nr_grant_entries(rgt)) )",
                "        goto unlock_out;",
                "    act = active_entry_acquire(rgt, op->ref);",
                "",
                "    /*",
                "     * Note that we (ab)use the active entry lock here to protect against",
                "     * multiple unmaps of the same mapping here. We don't want to hold lgt's",
                "     * lock, and we only hold rgt's lock for reading (but the latter wouldn't",
                "     * be the right one anyway). Hence the easiest is to rely on a lock we",
                "     * hold anyway; see docs/misc/grant-tables.txt's \"Locking\" section.",
                "     */",
                "",
                "    op->flags = read_atomic(&map->flags);",
                "    smp_rmb();",
                "    if ( unlikely(!op->flags) || unlikely(map->domid != dom) ||",
                "         unlikely(map->ref != op->ref) )",
                "    {",
                "        gdprintk(XENLOG_WARNING, \"Unstable handle %#x\\n\", op->handle);",
                "        rc = GNTST_bad_handle;",
                "        goto act_release_out;",
                "    }",
                "        map->flags &= ~GNTMAP_device_map;",
                "        map->flags &= ~GNTMAP_host_map;",
                "    }",
                "",
                "    if ( !(map->flags & (GNTMAP_device_map|GNTMAP_host_map)) )",
                "    {",
                "        map->flags = 0;",
                "        put_handle = true;",
                " unlock_out:",
                "",
                "    if ( put_handle )",
                "        put_maptrack_handle(lgt, op->handle);"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-10913",
        "func_name": "xen-project/xen/mapkind",
        "description": "The grant-table feature in Xen through 4.8.x provides false mapping information in certain cases of concurrent unmap calls, which allows backend attackers to obtain sensitive information or gain privileges, aka XSA-218 bug 1.",
        "git_url": "https://github.com/xen-project/xen/commit/4b78efa91c8ae3c42e14b8eaeaad773c5eb3b71a",
        "commit_title": "gnttab: correct maptrack table accesses",
        "commit_text": " In order to observe a consistent (limit,pointer-table) pair, the reader needs to either hold the maptrack lock (in line with documentation) or both sides need to order their accesses suitably (the writer side barrier was removed by commit dff515dfea [\"gnttab: use per-VCPU maptrack free lists\"], and a read side barrier has never been there).  Make the writer publish a new table page before limit (for bounds checks to work), and new list head last (for racing maptrack_entry() invocations to work). At the same time add read barriers to lockless readers.  Additionally get_maptrack_handle() must not assume ->maptrack_head to not change behind its back: Another handle may be put (updating only ->maptrack_tail) and then got or stolen (updating ->maptrack_head).  This is part of XSA-218. ",
        "func_before": "static unsigned int mapkind(\n    struct grant_table *lgt, const struct domain *rd, unsigned long mfn)\n{\n    struct grant_mapping *map;\n    grant_handle_t handle;\n    unsigned int kind = 0;\n\n    /*\n     * Must have the local domain's grant table write lock when\n     * iterating over its maptrack entries.\n     */\n    ASSERT(percpu_rw_is_write_locked(&lgt->lock));\n    /*\n     * Must have the remote domain's grant table write lock while\n     * counting its active entries.\n     */\n    ASSERT(percpu_rw_is_write_locked(&rd->grant_table->lock));\n\n    for ( handle = 0; !(kind & MAPKIND_WRITE) &&\n                      handle < lgt->maptrack_limit; handle++ )\n    {\n        map = &maptrack_entry(lgt, handle);\n        if ( !(map->flags & (GNTMAP_device_map|GNTMAP_host_map)) ||\n             map->domid != rd->domain_id )\n            continue;\n        if ( _active_entry(rd->grant_table, map->ref).frame == mfn )\n            kind |= map->flags & GNTMAP_readonly ?\n                    MAPKIND_READ : MAPKIND_WRITE;\n    }\n\n    return kind;\n}",
        "func": "static unsigned int mapkind(\n    struct grant_table *lgt, const struct domain *rd, unsigned long mfn)\n{\n    struct grant_mapping *map;\n    grant_handle_t handle;\n    unsigned int kind = 0;\n\n    /*\n     * Must have the local domain's grant table write lock when\n     * iterating over its maptrack entries.\n     */\n    ASSERT(percpu_rw_is_write_locked(&lgt->lock));\n    /*\n     * Must have the remote domain's grant table write lock while\n     * counting its active entries.\n     */\n    ASSERT(percpu_rw_is_write_locked(&rd->grant_table->lock));\n\n    for ( handle = 0; !(kind & MAPKIND_WRITE) &&\n                      handle < lgt->maptrack_limit; handle++ )\n    {\n        smp_rmb();\n        map = &maptrack_entry(lgt, handle);\n        if ( !(map->flags & (GNTMAP_device_map|GNTMAP_host_map)) ||\n             map->domid != rd->domain_id )\n            continue;\n        if ( _active_entry(rd->grant_table, map->ref).frame == mfn )\n            kind |= map->flags & GNTMAP_readonly ?\n                    MAPKIND_READ : MAPKIND_WRITE;\n    }\n\n    return kind;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -19,6 +19,7 @@\n     for ( handle = 0; !(kind & MAPKIND_WRITE) &&\n                       handle < lgt->maptrack_limit; handle++ )\n     {\n+        smp_rmb();\n         map = &maptrack_entry(lgt, handle);\n         if ( !(map->flags & (GNTMAP_device_map|GNTMAP_host_map)) ||\n              map->domid != rd->domain_id )",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "        smp_rmb();"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-10913",
        "func_name": "xen-project/xen/__gnttab_unmap_common",
        "description": "The grant-table feature in Xen through 4.8.x provides false mapping information in certain cases of concurrent unmap calls, which allows backend attackers to obtain sensitive information or gain privileges, aka XSA-218 bug 1.",
        "git_url": "https://github.com/xen-project/xen/commit/4b78efa91c8ae3c42e14b8eaeaad773c5eb3b71a",
        "commit_title": "gnttab: correct maptrack table accesses",
        "commit_text": " In order to observe a consistent (limit,pointer-table) pair, the reader needs to either hold the maptrack lock (in line with documentation) or both sides need to order their accesses suitably (the writer side barrier was removed by commit dff515dfea [\"gnttab: use per-VCPU maptrack free lists\"], and a read side barrier has never been there).  Make the writer publish a new table page before limit (for bounds checks to work), and new list head last (for racing maptrack_entry() invocations to work). At the same time add read barriers to lockless readers.  Additionally get_maptrack_handle() must not assume ->maptrack_head to not change behind its back: Another handle may be put (updating only ->maptrack_tail) and then got or stolen (updating ->maptrack_head).  This is part of XSA-218. ",
        "func_before": "static void\n__gnttab_unmap_common(\n    struct gnttab_unmap_common *op)\n{\n    domid_t          dom;\n    struct domain   *ld, *rd;\n    struct grant_table *lgt, *rgt;\n    struct active_grant_entry *act;\n    s16              rc = 0;\n    struct grant_mapping *map;\n    bool put_handle = false;\n\n    ld = current->domain;\n    lgt = ld->grant_table;\n\n    op->frame = (unsigned long)(op->dev_bus_addr >> PAGE_SHIFT);\n\n    if ( unlikely(op->handle >= lgt->maptrack_limit) )\n    {\n        gdprintk(XENLOG_INFO, \"Bad handle %#x\\n\", op->handle);\n        op->status = GNTST_bad_handle;\n        return;\n    }\n\n    map = &maptrack_entry(lgt, op->handle);\n\n    grant_read_lock(lgt);\n\n    if ( unlikely(!read_atomic(&map->flags)) )\n    {\n        grant_read_unlock(lgt);\n        gdprintk(XENLOG_INFO, \"Zero flags for handle %#x\\n\", op->handle);\n        op->status = GNTST_bad_handle;\n        return;\n    }\n\n    dom = map->domid;\n    grant_read_unlock(lgt);\n\n    if ( unlikely((rd = rcu_lock_domain_by_id(dom)) == NULL) )\n    {\n        /* This can happen when a grant is implicitly unmapped. */\n        gdprintk(XENLOG_INFO, \"Could not find domain %d\\n\", dom);\n        domain_crash(ld); /* naughty... */\n        return;\n    }\n\n    rc = xsm_grant_unmapref(XSM_HOOK, ld, rd);\n    if ( rc )\n    {\n        rcu_unlock_domain(rd);\n        op->status = GNTST_permission_denied;\n        return;\n    }\n\n    TRACE_1D(TRC_MEM_PAGE_GRANT_UNMAP, dom);\n\n    rgt = rd->grant_table;\n\n    grant_read_lock(rgt);\n\n    op->rd = rd;\n    op->ref = map->ref;\n\n    /*\n     * We can't assume there was no racing unmap for this maptrack entry,\n     * and hence we can't assume map->ref is valid for rd. While the checks\n     * below (with the active entry lock held) will reject any such racing\n     * requests, we still need to make sure we don't attempt to acquire an\n     * invalid lock.\n     */\n    smp_rmb();\n    if ( unlikely(op->ref >= nr_grant_entries(rgt)) )\n    {\n        gdprintk(XENLOG_WARNING, \"Unstable handle %#x\\n\", op->handle);\n        rc = GNTST_bad_handle;\n        goto unlock_out;\n    }\n\n    act = active_entry_acquire(rgt, op->ref);\n\n    /*\n     * Note that we (ab)use the active entry lock here to protect against\n     * multiple unmaps of the same mapping here. We don't want to hold lgt's\n     * lock, and we only hold rgt's lock for reading (but the latter wouldn't\n     * be the right one anyway). Hence the easiest is to rely on a lock we\n     * hold anyway; see docs/misc/grant-tables.txt's \"Locking\" section.\n     */\n\n    op->flags = read_atomic(&map->flags);\n    smp_rmb();\n    if ( unlikely(!op->flags) || unlikely(map->domid != dom) ||\n         unlikely(map->ref != op->ref) )\n    {\n        gdprintk(XENLOG_WARNING, \"Unstable handle %#x\\n\", op->handle);\n        rc = GNTST_bad_handle;\n        goto act_release_out;\n    }\n\n    if ( op->frame == 0 )\n    {\n        op->frame = act->frame;\n    }\n    else\n    {\n        if ( unlikely(op->frame != act->frame) )\n            PIN_FAIL(act_release_out, GNTST_general_error,\n                     \"Bad frame number doesn't match gntref. (%lx != %lx)\\n\",\n                     op->frame, act->frame);\n\n        map->flags &= ~GNTMAP_device_map;\n    }\n\n    if ( (op->host_addr != 0) && (op->flags & GNTMAP_host_map) )\n    {\n        if ( (rc = replace_grant_host_mapping(op->host_addr,\n                                              op->frame, op->new_addr, \n                                              op->flags)) < 0 )\n            goto act_release_out;\n\n        map->flags &= ~GNTMAP_host_map;\n    }\n\n    if ( !(map->flags & (GNTMAP_device_map|GNTMAP_host_map)) )\n    {\n        map->flags = 0;\n        put_handle = true;\n    }\n\n act_release_out:\n    active_entry_release(act);\n unlock_out:\n    grant_read_unlock(rgt);\n\n    if ( put_handle )\n        put_maptrack_handle(lgt, op->handle);\n\n    if ( rc == GNTST_okay && gnttab_need_iommu_mapping(ld) )\n    {\n        unsigned int kind;\n        int err = 0;\n\n        double_gt_lock(lgt, rgt);\n\n        kind = mapkind(lgt, rd, op->frame);\n        if ( !kind )\n            err = iommu_unmap_page(ld, op->frame);\n        else if ( !(kind & MAPKIND_WRITE) )\n            err = iommu_map_page(ld, op->frame, op->frame, IOMMUF_readable);\n\n        double_gt_unlock(lgt, rgt);\n\n        if ( err )\n            rc = GNTST_general_error;\n    }\n\n    /* If just unmapped a writable mapping, mark as dirtied */\n    if ( rc == GNTST_okay && !(op->flags & GNTMAP_readonly) )\n         gnttab_mark_dirty(rd, op->frame);\n\n    op->status = rc;\n    rcu_unlock_domain(rd);\n}",
        "func": "static void\n__gnttab_unmap_common(\n    struct gnttab_unmap_common *op)\n{\n    domid_t          dom;\n    struct domain   *ld, *rd;\n    struct grant_table *lgt, *rgt;\n    struct active_grant_entry *act;\n    s16              rc = 0;\n    struct grant_mapping *map;\n    bool put_handle = false;\n\n    ld = current->domain;\n    lgt = ld->grant_table;\n\n    op->frame = (unsigned long)(op->dev_bus_addr >> PAGE_SHIFT);\n\n    if ( unlikely(op->handle >= lgt->maptrack_limit) )\n    {\n        gdprintk(XENLOG_INFO, \"Bad handle %#x\\n\", op->handle);\n        op->status = GNTST_bad_handle;\n        return;\n    }\n\n    smp_rmb();\n    map = &maptrack_entry(lgt, op->handle);\n\n    grant_read_lock(lgt);\n\n    if ( unlikely(!read_atomic(&map->flags)) )\n    {\n        grant_read_unlock(lgt);\n        gdprintk(XENLOG_INFO, \"Zero flags for handle %#x\\n\", op->handle);\n        op->status = GNTST_bad_handle;\n        return;\n    }\n\n    dom = map->domid;\n    grant_read_unlock(lgt);\n\n    if ( unlikely((rd = rcu_lock_domain_by_id(dom)) == NULL) )\n    {\n        /* This can happen when a grant is implicitly unmapped. */\n        gdprintk(XENLOG_INFO, \"Could not find domain %d\\n\", dom);\n        domain_crash(ld); /* naughty... */\n        return;\n    }\n\n    rc = xsm_grant_unmapref(XSM_HOOK, ld, rd);\n    if ( rc )\n    {\n        rcu_unlock_domain(rd);\n        op->status = GNTST_permission_denied;\n        return;\n    }\n\n    TRACE_1D(TRC_MEM_PAGE_GRANT_UNMAP, dom);\n\n    rgt = rd->grant_table;\n\n    grant_read_lock(rgt);\n\n    op->rd = rd;\n    op->ref = map->ref;\n\n    /*\n     * We can't assume there was no racing unmap for this maptrack entry,\n     * and hence we can't assume map->ref is valid for rd. While the checks\n     * below (with the active entry lock held) will reject any such racing\n     * requests, we still need to make sure we don't attempt to acquire an\n     * invalid lock.\n     */\n    smp_rmb();\n    if ( unlikely(op->ref >= nr_grant_entries(rgt)) )\n    {\n        gdprintk(XENLOG_WARNING, \"Unstable handle %#x\\n\", op->handle);\n        rc = GNTST_bad_handle;\n        goto unlock_out;\n    }\n\n    act = active_entry_acquire(rgt, op->ref);\n\n    /*\n     * Note that we (ab)use the active entry lock here to protect against\n     * multiple unmaps of the same mapping here. We don't want to hold lgt's\n     * lock, and we only hold rgt's lock for reading (but the latter wouldn't\n     * be the right one anyway). Hence the easiest is to rely on a lock we\n     * hold anyway; see docs/misc/grant-tables.txt's \"Locking\" section.\n     */\n\n    op->flags = read_atomic(&map->flags);\n    smp_rmb();\n    if ( unlikely(!op->flags) || unlikely(map->domid != dom) ||\n         unlikely(map->ref != op->ref) )\n    {\n        gdprintk(XENLOG_WARNING, \"Unstable handle %#x\\n\", op->handle);\n        rc = GNTST_bad_handle;\n        goto act_release_out;\n    }\n\n    if ( op->frame == 0 )\n    {\n        op->frame = act->frame;\n    }\n    else\n    {\n        if ( unlikely(op->frame != act->frame) )\n            PIN_FAIL(act_release_out, GNTST_general_error,\n                     \"Bad frame number doesn't match gntref. (%lx != %lx)\\n\",\n                     op->frame, act->frame);\n\n        map->flags &= ~GNTMAP_device_map;\n    }\n\n    if ( (op->host_addr != 0) && (op->flags & GNTMAP_host_map) )\n    {\n        if ( (rc = replace_grant_host_mapping(op->host_addr,\n                                              op->frame, op->new_addr, \n                                              op->flags)) < 0 )\n            goto act_release_out;\n\n        map->flags &= ~GNTMAP_host_map;\n    }\n\n    if ( !(map->flags & (GNTMAP_device_map|GNTMAP_host_map)) )\n    {\n        map->flags = 0;\n        put_handle = true;\n    }\n\n act_release_out:\n    active_entry_release(act);\n unlock_out:\n    grant_read_unlock(rgt);\n\n    if ( put_handle )\n        put_maptrack_handle(lgt, op->handle);\n\n    if ( rc == GNTST_okay && gnttab_need_iommu_mapping(ld) )\n    {\n        unsigned int kind;\n        int err = 0;\n\n        double_gt_lock(lgt, rgt);\n\n        kind = mapkind(lgt, rd, op->frame);\n        if ( !kind )\n            err = iommu_unmap_page(ld, op->frame);\n        else if ( !(kind & MAPKIND_WRITE) )\n            err = iommu_map_page(ld, op->frame, op->frame, IOMMUF_readable);\n\n        double_gt_unlock(lgt, rgt);\n\n        if ( err )\n            rc = GNTST_general_error;\n    }\n\n    /* If just unmapped a writable mapping, mark as dirtied */\n    if ( rc == GNTST_okay && !(op->flags & GNTMAP_readonly) )\n         gnttab_mark_dirty(rd, op->frame);\n\n    op->status = rc;\n    rcu_unlock_domain(rd);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -22,6 +22,7 @@\n         return;\n     }\n \n+    smp_rmb();\n     map = &maptrack_entry(lgt, op->handle);\n \n     grant_read_lock(lgt);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    smp_rmb();"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-10913",
        "func_name": "xen-project/xen/get_maptrack_handle",
        "description": "The grant-table feature in Xen through 4.8.x provides false mapping information in certain cases of concurrent unmap calls, which allows backend attackers to obtain sensitive information or gain privileges, aka XSA-218 bug 1.",
        "git_url": "https://github.com/xen-project/xen/commit/4b78efa91c8ae3c42e14b8eaeaad773c5eb3b71a",
        "commit_title": "gnttab: correct maptrack table accesses",
        "commit_text": " In order to observe a consistent (limit,pointer-table) pair, the reader needs to either hold the maptrack lock (in line with documentation) or both sides need to order their accesses suitably (the writer side barrier was removed by commit dff515dfea [\"gnttab: use per-VCPU maptrack free lists\"], and a read side barrier has never been there).  Make the writer publish a new table page before limit (for bounds checks to work), and new list head last (for racing maptrack_entry() invocations to work). At the same time add read barriers to lockless readers.  Additionally get_maptrack_handle() must not assume ->maptrack_head to not change behind its back: Another handle may be put (updating only ->maptrack_tail) and then got or stolen (updating ->maptrack_head).  This is part of XSA-218. ",
        "func_before": "static inline int\nget_maptrack_handle(\n    struct grant_table *lgt)\n{\n    struct vcpu          *curr = current;\n    int                   i;\n    grant_handle_t        handle;\n    struct grant_mapping *new_mt;\n\n    handle = __get_maptrack_handle(lgt, curr);\n    if ( likely(handle != -1) )\n        return handle;\n\n    spin_lock(&lgt->maptrack_lock);\n\n    /*\n     * If we've run out of frames, try stealing an entry from another\n     * VCPU (in case the guest isn't mapping across its VCPUs evenly).\n     */\n    if ( nr_maptrack_frames(lgt) >= max_maptrack_frames )\n    {\n        /*\n         * Can drop the lock since no other VCPU can be adding a new\n         * frame once they've run out.\n         */\n        spin_unlock(&lgt->maptrack_lock);\n\n        /*\n         * Uninitialized free list? Steal an extra entry for the tail\n         * sentinel.\n         */\n        if ( curr->maptrack_tail == MAPTRACK_TAIL )\n        {\n            handle = steal_maptrack_handle(lgt, curr);\n            if ( handle == -1 )\n                return -1;\n            curr->maptrack_tail = handle;\n            write_atomic(&curr->maptrack_head, handle);\n        }\n        return steal_maptrack_handle(lgt, curr);\n    }\n\n    new_mt = alloc_xenheap_page();\n    if ( !new_mt )\n    {\n        spin_unlock(&lgt->maptrack_lock);\n        return -1;\n    }\n    clear_page(new_mt);\n\n    /*\n     * Use the first new entry and add the remaining entries to the\n     * head of the free list.\n     */\n    handle = lgt->maptrack_limit;\n\n    for ( i = 0; i < MAPTRACK_PER_PAGE; i++ )\n    {\n        new_mt[i].ref = handle + i + 1;\n        new_mt[i].vcpu = curr->vcpu_id;\n    }\n    new_mt[i - 1].ref = curr->maptrack_head;\n\n    /* Set tail directly if this is the first page for this VCPU. */\n    if ( curr->maptrack_tail == MAPTRACK_TAIL )\n        curr->maptrack_tail = handle + MAPTRACK_PER_PAGE - 1;\n\n    write_atomic(&curr->maptrack_head, handle + 1);\n\n    lgt->maptrack[nr_maptrack_frames(lgt)] = new_mt;\n    lgt->maptrack_limit += MAPTRACK_PER_PAGE;\n\n    spin_unlock(&lgt->maptrack_lock);\n\n    return handle;\n}",
        "func": "static inline int\nget_maptrack_handle(\n    struct grant_table *lgt)\n{\n    struct vcpu          *curr = current;\n    unsigned int          i, head;\n    grant_handle_t        handle;\n    struct grant_mapping *new_mt;\n\n    handle = __get_maptrack_handle(lgt, curr);\n    if ( likely(handle != -1) )\n        return handle;\n\n    spin_lock(&lgt->maptrack_lock);\n\n    /*\n     * If we've run out of frames, try stealing an entry from another\n     * VCPU (in case the guest isn't mapping across its VCPUs evenly).\n     */\n    if ( nr_maptrack_frames(lgt) >= max_maptrack_frames )\n    {\n        /*\n         * Can drop the lock since no other VCPU can be adding a new\n         * frame once they've run out.\n         */\n        spin_unlock(&lgt->maptrack_lock);\n\n        /*\n         * Uninitialized free list? Steal an extra entry for the tail\n         * sentinel.\n         */\n        if ( curr->maptrack_tail == MAPTRACK_TAIL )\n        {\n            handle = steal_maptrack_handle(lgt, curr);\n            if ( handle == -1 )\n                return -1;\n            curr->maptrack_tail = handle;\n            write_atomic(&curr->maptrack_head, handle);\n        }\n        return steal_maptrack_handle(lgt, curr);\n    }\n\n    new_mt = alloc_xenheap_page();\n    if ( !new_mt )\n    {\n        spin_unlock(&lgt->maptrack_lock);\n        return -1;\n    }\n    clear_page(new_mt);\n\n    /*\n     * Use the first new entry and add the remaining entries to the\n     * head of the free list.\n     */\n    handle = lgt->maptrack_limit;\n\n    for ( i = 0; i < MAPTRACK_PER_PAGE; i++ )\n    {\n        new_mt[i].ref = handle + i + 1;\n        new_mt[i].vcpu = curr->vcpu_id;\n    }\n\n    /* Set tail directly if this is the first page for this VCPU. */\n    if ( curr->maptrack_tail == MAPTRACK_TAIL )\n        curr->maptrack_tail = handle + MAPTRACK_PER_PAGE - 1;\n\n    lgt->maptrack[nr_maptrack_frames(lgt)] = new_mt;\n    smp_wmb();\n    lgt->maptrack_limit += MAPTRACK_PER_PAGE;\n\n    do {\n        new_mt[i - 1].ref = read_atomic(&curr->maptrack_head);\n        head = cmpxchg(&curr->maptrack_head, new_mt[i - 1].ref, handle + 1);\n    } while ( head != new_mt[i - 1].ref );\n\n    spin_unlock(&lgt->maptrack_lock);\n\n    return handle;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,7 +3,7 @@\n     struct grant_table *lgt)\n {\n     struct vcpu          *curr = current;\n-    int                   i;\n+    unsigned int          i, head;\n     grant_handle_t        handle;\n     struct grant_mapping *new_mt;\n \n@@ -59,16 +59,19 @@\n         new_mt[i].ref = handle + i + 1;\n         new_mt[i].vcpu = curr->vcpu_id;\n     }\n-    new_mt[i - 1].ref = curr->maptrack_head;\n \n     /* Set tail directly if this is the first page for this VCPU. */\n     if ( curr->maptrack_tail == MAPTRACK_TAIL )\n         curr->maptrack_tail = handle + MAPTRACK_PER_PAGE - 1;\n \n-    write_atomic(&curr->maptrack_head, handle + 1);\n+    lgt->maptrack[nr_maptrack_frames(lgt)] = new_mt;\n+    smp_wmb();\n+    lgt->maptrack_limit += MAPTRACK_PER_PAGE;\n \n-    lgt->maptrack[nr_maptrack_frames(lgt)] = new_mt;\n-    lgt->maptrack_limit += MAPTRACK_PER_PAGE;\n+    do {\n+        new_mt[i - 1].ref = read_atomic(&curr->maptrack_head);\n+        head = cmpxchg(&curr->maptrack_head, new_mt[i - 1].ref, handle + 1);\n+    } while ( head != new_mt[i - 1].ref );\n \n     spin_unlock(&lgt->maptrack_lock);\n ",
        "diff_line_info": {
            "deleted_lines": [
                "    int                   i;",
                "    new_mt[i - 1].ref = curr->maptrack_head;",
                "    write_atomic(&curr->maptrack_head, handle + 1);",
                "    lgt->maptrack[nr_maptrack_frames(lgt)] = new_mt;",
                "    lgt->maptrack_limit += MAPTRACK_PER_PAGE;"
            ],
            "added_lines": [
                "    unsigned int          i, head;",
                "    lgt->maptrack[nr_maptrack_frames(lgt)] = new_mt;",
                "    smp_wmb();",
                "    lgt->maptrack_limit += MAPTRACK_PER_PAGE;",
                "    do {",
                "        new_mt[i - 1].ref = read_atomic(&curr->maptrack_head);",
                "        head = cmpxchg(&curr->maptrack_head, new_mt[i - 1].ref, handle + 1);",
                "    } while ( head != new_mt[i - 1].ref );"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-10913",
        "func_name": "xen-project/xen/__gnttab_unmap_common_complete",
        "description": "The grant-table feature in Xen through 4.8.x provides false mapping information in certain cases of concurrent unmap calls, which allows backend attackers to obtain sensitive information or gain privileges, aka XSA-218 bug 1.",
        "git_url": "https://github.com/xen-project/xen/commit/9a0bd460cfc28564d39fa23541bb872b13e7f7ea",
        "commit_title": "gnttab: fix unmap pin accounting race",
        "commit_text": " Once all {writable} mappings of a grant entry have been unmapped, the hypervisor informs the guest that the grant entry has been released by clearing the _GTF_{reading,writing} usage flags in the guest's grant table as appropriate.  Unfortunately, at the moment, the code that updates the accounting happens in a different critical section than the one which updates the usage flags; this means that under the right circumstances, there may be a window in time after the hypervisor reported the grant as being free during which the grant referee still had access to the page.  Move the grant accounting code into the same critical section as the reporting code to make sure this kind of race can't happen.  This is part of XSA-218. ",
        "func_before": "static void\n__gnttab_unmap_common_complete(struct gnttab_unmap_common *op)\n{\n    struct domain *ld, *rd = op->rd;\n    struct grant_table *rgt;\n    struct active_grant_entry *act;\n    grant_entry_header_t *sha;\n    struct page_info *pg;\n    uint16_t *status;\n    bool_t put_handle = 0;\n\n    if ( rd == NULL )\n    { \n        /*\n         * Suggests that __gntab_unmap_common failed in\n         * rcu_lock_domain_by_id() or earlier, and so we have nothing\n         * to complete\n         */\n        return;\n    }\n\n    ld = current->domain;\n\n    rcu_lock_domain(rd);\n    rgt = rd->grant_table;\n\n    grant_read_lock(rgt);\n    if ( rgt->gt_version == 0 )\n        goto unlock_out;\n\n    act = active_entry_acquire(rgt, op->map->ref);\n    sha = shared_entry_header(rgt, op->map->ref);\n\n    if ( rgt->gt_version == 1 )\n        status = &sha->flags;\n    else\n        status = &status_entry(rgt, op->map->ref);\n\n    if ( unlikely(op->frame != act->frame) ) \n    {\n        /*\n         * Suggests that __gntab_unmap_common failed early and so\n         * nothing further to do\n         */\n        goto act_release_out;\n    }\n\n    pg = mfn_to_page(op->frame);\n\n    if ( op->flags & GNTMAP_device_map ) \n    {\n        if ( !is_iomem_page(_mfn(act->frame)) )\n        {\n            if ( op->flags & GNTMAP_readonly )\n                put_page(pg);\n            else\n                put_page_and_type(pg);\n        }\n    }\n\n    if ( (op->host_addr != 0) && (op->flags & GNTMAP_host_map) )\n    {\n        if ( op->status != 0 ) \n        {\n            /*\n             * Suggests that __gntab_unmap_common failed in\n             * replace_grant_host_mapping() so nothing further to do\n             */\n            goto act_release_out;\n        }\n\n        if ( !is_iomem_page(_mfn(op->frame)) )\n        {\n            if ( gnttab_host_mapping_get_page_type(op, ld, rd) )\n                put_page_type(pg);\n            put_page(pg);\n        }\n    }\n\n    if ( (op->map->flags & (GNTMAP_device_map|GNTMAP_host_map)) == 0 )\n        put_handle = 1;\n\n    if ( ((act->pin & (GNTPIN_devw_mask|GNTPIN_hstw_mask)) == 0) &&\n         !(op->flags & GNTMAP_readonly) )\n        gnttab_clear_flag(_GTF_writing, status);\n\n    if ( act->pin == 0 )\n        gnttab_clear_flag(_GTF_reading, status);\n\n act_release_out:\n    active_entry_release(act);\n unlock_out:\n    grant_read_unlock(rgt);\n\n    if ( put_handle )\n    {\n        op->map->flags = 0;\n        put_maptrack_handle(ld->grant_table, op->handle);\n    }\n    rcu_unlock_domain(rd);\n}",
        "func": "static void\n__gnttab_unmap_common_complete(struct gnttab_unmap_common *op)\n{\n    struct domain *ld, *rd = op->rd;\n    struct grant_table *rgt;\n    struct active_grant_entry *act;\n    grant_entry_header_t *sha;\n    struct page_info *pg;\n    uint16_t *status;\n    bool_t put_handle = 0;\n\n    if ( rd == NULL )\n    { \n        /*\n         * Suggests that __gntab_unmap_common failed in\n         * rcu_lock_domain_by_id() or earlier, and so we have nothing\n         * to complete\n         */\n        return;\n    }\n\n    ld = current->domain;\n\n    rcu_lock_domain(rd);\n    rgt = rd->grant_table;\n\n    grant_read_lock(rgt);\n    if ( rgt->gt_version == 0 )\n        goto unlock_out;\n\n    act = active_entry_acquire(rgt, op->map->ref);\n    sha = shared_entry_header(rgt, op->map->ref);\n\n    if ( rgt->gt_version == 1 )\n        status = &sha->flags;\n    else\n        status = &status_entry(rgt, op->map->ref);\n\n    if ( unlikely(op->frame != act->frame) ) \n    {\n        /*\n         * Suggests that __gntab_unmap_common failed early and so\n         * nothing further to do\n         */\n        goto act_release_out;\n    }\n\n    pg = mfn_to_page(op->frame);\n\n    if ( op->flags & GNTMAP_device_map ) \n    {\n        if ( !is_iomem_page(_mfn(act->frame)) )\n        {\n            if ( op->flags & GNTMAP_readonly )\n                put_page(pg);\n            else\n                put_page_and_type(pg);\n        }\n\n        ASSERT(act->pin & (GNTPIN_devw_mask | GNTPIN_devr_mask));\n        if ( op->flags & GNTMAP_readonly )\n            act->pin -= GNTPIN_devr_inc;\n        else\n            act->pin -= GNTPIN_devw_inc;\n    }\n\n    if ( (op->host_addr != 0) && (op->flags & GNTMAP_host_map) )\n    {\n        if ( op->status != 0 ) \n        {\n            /*\n             * Suggests that __gntab_unmap_common failed in\n             * replace_grant_host_mapping() or IOMMU handling, so nothing\n             * further to do (short of re-establishing the mapping in the\n             * latter case).\n             */\n            goto act_release_out;\n        }\n\n        if ( !is_iomem_page(_mfn(op->frame)) )\n        {\n            if ( gnttab_host_mapping_get_page_type(op, ld, rd) )\n                put_page_type(pg);\n            put_page(pg);\n        }\n\n        ASSERT(act->pin & (GNTPIN_hstw_mask | GNTPIN_hstr_mask));\n        if ( op->flags & GNTMAP_readonly )\n            act->pin -= GNTPIN_hstr_inc;\n        else\n            act->pin -= GNTPIN_hstw_inc;\n    }\n\n    if ( (op->map->flags & (GNTMAP_device_map|GNTMAP_host_map)) == 0 )\n        put_handle = 1;\n\n    if ( ((act->pin & (GNTPIN_devw_mask|GNTPIN_hstw_mask)) == 0) &&\n         !(op->flags & GNTMAP_readonly) )\n        gnttab_clear_flag(_GTF_writing, status);\n\n    if ( act->pin == 0 )\n        gnttab_clear_flag(_GTF_reading, status);\n\n act_release_out:\n    active_entry_release(act);\n unlock_out:\n    grant_read_unlock(rgt);\n\n    if ( put_handle )\n    {\n        op->map->flags = 0;\n        put_maptrack_handle(ld->grant_table, op->handle);\n    }\n    rcu_unlock_domain(rd);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -56,6 +56,12 @@\n             else\n                 put_page_and_type(pg);\n         }\n+\n+        ASSERT(act->pin & (GNTPIN_devw_mask | GNTPIN_devr_mask));\n+        if ( op->flags & GNTMAP_readonly )\n+            act->pin -= GNTPIN_devr_inc;\n+        else\n+            act->pin -= GNTPIN_devw_inc;\n     }\n \n     if ( (op->host_addr != 0) && (op->flags & GNTMAP_host_map) )\n@@ -64,7 +70,9 @@\n         {\n             /*\n              * Suggests that __gntab_unmap_common failed in\n-             * replace_grant_host_mapping() so nothing further to do\n+             * replace_grant_host_mapping() or IOMMU handling, so nothing\n+             * further to do (short of re-establishing the mapping in the\n+             * latter case).\n              */\n             goto act_release_out;\n         }\n@@ -75,6 +83,12 @@\n                 put_page_type(pg);\n             put_page(pg);\n         }\n+\n+        ASSERT(act->pin & (GNTPIN_hstw_mask | GNTPIN_hstr_mask));\n+        if ( op->flags & GNTMAP_readonly )\n+            act->pin -= GNTPIN_hstr_inc;\n+        else\n+            act->pin -= GNTPIN_hstw_inc;\n     }\n \n     if ( (op->map->flags & (GNTMAP_device_map|GNTMAP_host_map)) == 0 )",
        "diff_line_info": {
            "deleted_lines": [
                "             * replace_grant_host_mapping() so nothing further to do"
            ],
            "added_lines": [
                "",
                "        ASSERT(act->pin & (GNTPIN_devw_mask | GNTPIN_devr_mask));",
                "        if ( op->flags & GNTMAP_readonly )",
                "            act->pin -= GNTPIN_devr_inc;",
                "        else",
                "            act->pin -= GNTPIN_devw_inc;",
                "             * replace_grant_host_mapping() or IOMMU handling, so nothing",
                "             * further to do (short of re-establishing the mapping in the",
                "             * latter case).",
                "",
                "        ASSERT(act->pin & (GNTPIN_hstw_mask | GNTPIN_hstr_mask));",
                "        if ( op->flags & GNTMAP_readonly )",
                "            act->pin -= GNTPIN_hstr_inc;",
                "        else",
                "            act->pin -= GNTPIN_hstw_inc;"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-10913",
        "func_name": "xen-project/xen/__gnttab_unmap_common",
        "description": "The grant-table feature in Xen through 4.8.x provides false mapping information in certain cases of concurrent unmap calls, which allows backend attackers to obtain sensitive information or gain privileges, aka XSA-218 bug 1.",
        "git_url": "https://github.com/xen-project/xen/commit/9a0bd460cfc28564d39fa23541bb872b13e7f7ea",
        "commit_title": "gnttab: fix unmap pin accounting race",
        "commit_text": " Once all {writable} mappings of a grant entry have been unmapped, the hypervisor informs the guest that the grant entry has been released by clearing the _GTF_{reading,writing} usage flags in the guest's grant table as appropriate.  Unfortunately, at the moment, the code that updates the accounting happens in a different critical section than the one which updates the usage flags; this means that under the right circumstances, there may be a window in time after the hypervisor reported the grant as being free during which the grant referee still had access to the page.  Move the grant accounting code into the same critical section as the reporting code to make sure this kind of race can't happen.  This is part of XSA-218. ",
        "func_before": "static void\n__gnttab_unmap_common(\n    struct gnttab_unmap_common *op)\n{\n    domid_t          dom;\n    struct domain   *ld, *rd;\n    struct grant_table *lgt, *rgt;\n    struct active_grant_entry *act;\n    s16              rc = 0;\n\n    ld = current->domain;\n    lgt = ld->grant_table;\n\n    op->frame = (unsigned long)(op->dev_bus_addr >> PAGE_SHIFT);\n\n    if ( unlikely(op->handle >= lgt->maptrack_limit) )\n    {\n        gdprintk(XENLOG_INFO, \"Bad handle %#x\\n\", op->handle);\n        op->status = GNTST_bad_handle;\n        return;\n    }\n\n    op->map = &maptrack_entry(lgt, op->handle);\n\n    grant_read_lock(lgt);\n\n    if ( unlikely(!read_atomic(&op->map->flags)) )\n    {\n        grant_read_unlock(lgt);\n        gdprintk(XENLOG_INFO, \"Zero flags for handle %#x\\n\", op->handle);\n        op->status = GNTST_bad_handle;\n        return;\n    }\n\n    dom = op->map->domid;\n    grant_read_unlock(lgt);\n\n    if ( unlikely((rd = rcu_lock_domain_by_id(dom)) == NULL) )\n    {\n        /* This can happen when a grant is implicitly unmapped. */\n        gdprintk(XENLOG_INFO, \"Could not find domain %d\\n\", dom);\n        domain_crash(ld); /* naughty... */\n        return;\n    }\n\n    rc = xsm_grant_unmapref(XSM_HOOK, ld, rd);\n    if ( rc )\n    {\n        rcu_unlock_domain(rd);\n        op->status = GNTST_permission_denied;\n        return;\n    }\n\n    TRACE_1D(TRC_MEM_PAGE_GRANT_UNMAP, dom);\n\n    rgt = rd->grant_table;\n\n    grant_read_lock(rgt);\n\n    op->flags = read_atomic(&op->map->flags);\n    if ( unlikely(!op->flags) || unlikely(op->map->domid != dom) )\n    {\n        gdprintk(XENLOG_WARNING, \"Unstable handle %#x\\n\", op->handle);\n        rc = GNTST_bad_handle;\n        goto unmap_out;\n    }\n\n    op->rd = rd;\n    act = active_entry_acquire(rgt, op->map->ref);\n\n    if ( op->frame == 0 )\n    {\n        op->frame = act->frame;\n    }\n    else\n    {\n        if ( unlikely(op->frame != act->frame) )\n            PIN_FAIL(act_release_out, GNTST_general_error,\n                     \"Bad frame number doesn't match gntref. (%lx != %lx)\\n\",\n                     op->frame, act->frame);\n        if ( op->flags & GNTMAP_device_map )\n        {\n            ASSERT(act->pin & (GNTPIN_devw_mask | GNTPIN_devr_mask));\n            op->map->flags &= ~GNTMAP_device_map;\n            if ( op->flags & GNTMAP_readonly )\n                act->pin -= GNTPIN_devr_inc;\n            else\n                act->pin -= GNTPIN_devw_inc;\n        }\n    }\n\n    if ( (op->host_addr != 0) && (op->flags & GNTMAP_host_map) )\n    {\n        if ( (rc = replace_grant_host_mapping(op->host_addr,\n                                              op->frame, op->new_addr, \n                                              op->flags)) < 0 )\n            goto act_release_out;\n\n        ASSERT(act->pin & (GNTPIN_hstw_mask | GNTPIN_hstr_mask));\n        op->map->flags &= ~GNTMAP_host_map;\n        if ( op->flags & GNTMAP_readonly )\n            act->pin -= GNTPIN_hstr_inc;\n        else\n            act->pin -= GNTPIN_hstw_inc;\n    }\n\n act_release_out:\n    active_entry_release(act);\n unmap_out:\n    grant_read_unlock(rgt);\n\n    if ( rc == GNTST_okay && gnttab_need_iommu_mapping(ld) )\n    {\n        unsigned int kind;\n        int err = 0;\n\n        double_gt_lock(lgt, rgt);\n\n        kind = mapkind(lgt, rd, op->frame);\n        if ( !kind )\n            err = iommu_unmap_page(ld, op->frame);\n        else if ( !(kind & MAPKIND_WRITE) )\n            err = iommu_map_page(ld, op->frame, op->frame, IOMMUF_readable);\n\n        double_gt_unlock(lgt, rgt);\n\n        if ( err )\n            rc = GNTST_general_error;\n    }\n\n    /* If just unmapped a writable mapping, mark as dirtied */\n    if ( rc == GNTST_okay && !(op->flags & GNTMAP_readonly) )\n         gnttab_mark_dirty(rd, op->frame);\n\n    op->status = rc;\n    rcu_unlock_domain(rd);\n}",
        "func": "static void\n__gnttab_unmap_common(\n    struct gnttab_unmap_common *op)\n{\n    domid_t          dom;\n    struct domain   *ld, *rd;\n    struct grant_table *lgt, *rgt;\n    struct active_grant_entry *act;\n    s16              rc = 0;\n\n    ld = current->domain;\n    lgt = ld->grant_table;\n\n    op->frame = (unsigned long)(op->dev_bus_addr >> PAGE_SHIFT);\n\n    if ( unlikely(op->handle >= lgt->maptrack_limit) )\n    {\n        gdprintk(XENLOG_INFO, \"Bad handle %#x\\n\", op->handle);\n        op->status = GNTST_bad_handle;\n        return;\n    }\n\n    op->map = &maptrack_entry(lgt, op->handle);\n\n    grant_read_lock(lgt);\n\n    if ( unlikely(!read_atomic(&op->map->flags)) )\n    {\n        grant_read_unlock(lgt);\n        gdprintk(XENLOG_INFO, \"Zero flags for handle %#x\\n\", op->handle);\n        op->status = GNTST_bad_handle;\n        return;\n    }\n\n    dom = op->map->domid;\n    grant_read_unlock(lgt);\n\n    if ( unlikely((rd = rcu_lock_domain_by_id(dom)) == NULL) )\n    {\n        /* This can happen when a grant is implicitly unmapped. */\n        gdprintk(XENLOG_INFO, \"Could not find domain %d\\n\", dom);\n        domain_crash(ld); /* naughty... */\n        return;\n    }\n\n    rc = xsm_grant_unmapref(XSM_HOOK, ld, rd);\n    if ( rc )\n    {\n        rcu_unlock_domain(rd);\n        op->status = GNTST_permission_denied;\n        return;\n    }\n\n    TRACE_1D(TRC_MEM_PAGE_GRANT_UNMAP, dom);\n\n    rgt = rd->grant_table;\n\n    grant_read_lock(rgt);\n\n    op->flags = read_atomic(&op->map->flags);\n    if ( unlikely(!op->flags) || unlikely(op->map->domid != dom) )\n    {\n        gdprintk(XENLOG_WARNING, \"Unstable handle %#x\\n\", op->handle);\n        rc = GNTST_bad_handle;\n        goto unmap_out;\n    }\n\n    op->rd = rd;\n    act = active_entry_acquire(rgt, op->map->ref);\n\n    if ( op->frame == 0 )\n    {\n        op->frame = act->frame;\n    }\n    else\n    {\n        if ( unlikely(op->frame != act->frame) )\n            PIN_FAIL(act_release_out, GNTST_general_error,\n                     \"Bad frame number doesn't match gntref. (%lx != %lx)\\n\",\n                     op->frame, act->frame);\n\n        op->map->flags &= ~GNTMAP_device_map;\n    }\n\n    if ( (op->host_addr != 0) && (op->flags & GNTMAP_host_map) )\n    {\n        if ( (rc = replace_grant_host_mapping(op->host_addr,\n                                              op->frame, op->new_addr, \n                                              op->flags)) < 0 )\n            goto act_release_out;\n\n        op->map->flags &= ~GNTMAP_host_map;\n    }\n\n act_release_out:\n    active_entry_release(act);\n unmap_out:\n    grant_read_unlock(rgt);\n\n    if ( rc == GNTST_okay && gnttab_need_iommu_mapping(ld) )\n    {\n        unsigned int kind;\n        int err = 0;\n\n        double_gt_lock(lgt, rgt);\n\n        kind = mapkind(lgt, rd, op->frame);\n        if ( !kind )\n            err = iommu_unmap_page(ld, op->frame);\n        else if ( !(kind & MAPKIND_WRITE) )\n            err = iommu_map_page(ld, op->frame, op->frame, IOMMUF_readable);\n\n        double_gt_unlock(lgt, rgt);\n\n        if ( err )\n            rc = GNTST_general_error;\n    }\n\n    /* If just unmapped a writable mapping, mark as dirtied */\n    if ( rc == GNTST_okay && !(op->flags & GNTMAP_readonly) )\n         gnttab_mark_dirty(rd, op->frame);\n\n    op->status = rc;\n    rcu_unlock_domain(rd);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -78,15 +78,8 @@\n             PIN_FAIL(act_release_out, GNTST_general_error,\n                      \"Bad frame number doesn't match gntref. (%lx != %lx)\\n\",\n                      op->frame, act->frame);\n-        if ( op->flags & GNTMAP_device_map )\n-        {\n-            ASSERT(act->pin & (GNTPIN_devw_mask | GNTPIN_devr_mask));\n-            op->map->flags &= ~GNTMAP_device_map;\n-            if ( op->flags & GNTMAP_readonly )\n-                act->pin -= GNTPIN_devr_inc;\n-            else\n-                act->pin -= GNTPIN_devw_inc;\n-        }\n+\n+        op->map->flags &= ~GNTMAP_device_map;\n     }\n \n     if ( (op->host_addr != 0) && (op->flags & GNTMAP_host_map) )\n@@ -96,12 +89,7 @@\n                                               op->flags)) < 0 )\n             goto act_release_out;\n \n-        ASSERT(act->pin & (GNTPIN_hstw_mask | GNTPIN_hstr_mask));\n         op->map->flags &= ~GNTMAP_host_map;\n-        if ( op->flags & GNTMAP_readonly )\n-            act->pin -= GNTPIN_hstr_inc;\n-        else\n-            act->pin -= GNTPIN_hstw_inc;\n     }\n \n  act_release_out:",
        "diff_line_info": {
            "deleted_lines": [
                "        if ( op->flags & GNTMAP_device_map )",
                "        {",
                "            ASSERT(act->pin & (GNTPIN_devw_mask | GNTPIN_devr_mask));",
                "            op->map->flags &= ~GNTMAP_device_map;",
                "            if ( op->flags & GNTMAP_readonly )",
                "                act->pin -= GNTPIN_devr_inc;",
                "            else",
                "                act->pin -= GNTPIN_devw_inc;",
                "        }",
                "        ASSERT(act->pin & (GNTPIN_hstw_mask | GNTPIN_hstr_mask));",
                "        if ( op->flags & GNTMAP_readonly )",
                "            act->pin -= GNTPIN_hstr_inc;",
                "        else",
                "            act->pin -= GNTPIN_hstw_inc;"
            ],
            "added_lines": [
                "",
                "        op->map->flags &= ~GNTMAP_device_map;"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-1000072",
        "func_name": "marcobambini/gravity/gravity_iscore_class",
        "description": "Creolabs Gravity version 1.0 is vulnerable to a Double Free in gravity_value resulting potentially leading to modification of unexpected memory locations",
        "git_url": "https://github.com/marcobambini/gravity/commit/f00c04dfa62d5f6ce0bc30e26545066de31d622c",
        "commit_title": "Fixed https://github.com/marcobambini/gravity/issues/123",
        "commit_text": "",
        "func_before": "bool gravity_iscore_class (gravity_class_t *c) {\n\treturn ((c == gravity_class_object) || (c == gravity_class_class) || (c == gravity_class_bool) ||\n\t\t\t(c == gravity_class_null) || (c == gravity_class_int) || (c == gravity_class_float) ||\n\t\t\t(c == gravity_class_function) || (c == gravity_class_fiber) || (c == gravity_class_string) ||\n\t\t\t(c == gravity_class_instance) || (c == gravity_class_list) || (c == gravity_class_map) ||\n\t\t\t(c == gravity_class_range) || (c == gravity_class_system) || (c == gravity_class_closure) ||\n\t\t\t(c == gravity_class_upvalue));\n}",
        "func": "bool gravity_iscore_class (gravity_class_t *c) {\n\t// first check if it is a class\n\tif ((c == gravity_class_object) || (c == gravity_class_class) || (c == gravity_class_bool) ||\n\t\t\t(c == gravity_class_null) || (c == gravity_class_int) || (c == gravity_class_float) ||\n\t\t\t(c == gravity_class_function) || (c == gravity_class_fiber) || (c == gravity_class_string) ||\n\t\t\t(c == gravity_class_instance) || (c == gravity_class_list) || (c == gravity_class_map) ||\n\t\t\t(c == gravity_class_range) || (c == gravity_class_system) || (c == gravity_class_closure) ||\n\t\t(c == gravity_class_upvalue)) return true;\n\t\n\t// if class check is false then check for meta\n\treturn ((c == gravity_class_get_meta(gravity_class_object)) || (c == gravity_class_get_meta(gravity_class_class)) ||\n\t\t\t(c == gravity_class_get_meta(gravity_class_bool)) || (c == gravity_class_get_meta(gravity_class_null)) ||\n\t\t\t(c == gravity_class_get_meta(gravity_class_int)) || (c == gravity_class_get_meta(gravity_class_float)) ||\n\t\t\t(c == gravity_class_get_meta(gravity_class_function)) || (c == gravity_class_get_meta(gravity_class_fiber)) ||\n\t\t\t(c == gravity_class_get_meta(gravity_class_string)) || (c == gravity_class_get_meta(gravity_class_instance)) ||\n\t\t\t(c == gravity_class_get_meta(gravity_class_list)) || (c == gravity_class_get_meta(gravity_class_map)) ||\n\t\t\t(c == gravity_class_get_meta(gravity_class_range)) || (c == gravity_class_get_meta(gravity_class_system)) ||\n\t\t\t(c == gravity_class_get_meta(gravity_class_closure)) || (c == gravity_class_get_meta(gravity_class_upvalue)));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,8 +1,19 @@\n bool gravity_iscore_class (gravity_class_t *c) {\n-\treturn ((c == gravity_class_object) || (c == gravity_class_class) || (c == gravity_class_bool) ||\n+\t// first check if it is a class\n+\tif ((c == gravity_class_object) || (c == gravity_class_class) || (c == gravity_class_bool) ||\n \t\t\t(c == gravity_class_null) || (c == gravity_class_int) || (c == gravity_class_float) ||\n \t\t\t(c == gravity_class_function) || (c == gravity_class_fiber) || (c == gravity_class_string) ||\n \t\t\t(c == gravity_class_instance) || (c == gravity_class_list) || (c == gravity_class_map) ||\n \t\t\t(c == gravity_class_range) || (c == gravity_class_system) || (c == gravity_class_closure) ||\n-\t\t\t(c == gravity_class_upvalue));\n+\t\t(c == gravity_class_upvalue)) return true;\n+\t\n+\t// if class check is false then check for meta\n+\treturn ((c == gravity_class_get_meta(gravity_class_object)) || (c == gravity_class_get_meta(gravity_class_class)) ||\n+\t\t\t(c == gravity_class_get_meta(gravity_class_bool)) || (c == gravity_class_get_meta(gravity_class_null)) ||\n+\t\t\t(c == gravity_class_get_meta(gravity_class_int)) || (c == gravity_class_get_meta(gravity_class_float)) ||\n+\t\t\t(c == gravity_class_get_meta(gravity_class_function)) || (c == gravity_class_get_meta(gravity_class_fiber)) ||\n+\t\t\t(c == gravity_class_get_meta(gravity_class_string)) || (c == gravity_class_get_meta(gravity_class_instance)) ||\n+\t\t\t(c == gravity_class_get_meta(gravity_class_list)) || (c == gravity_class_get_meta(gravity_class_map)) ||\n+\t\t\t(c == gravity_class_get_meta(gravity_class_range)) || (c == gravity_class_get_meta(gravity_class_system)) ||\n+\t\t\t(c == gravity_class_get_meta(gravity_class_closure)) || (c == gravity_class_get_meta(gravity_class_upvalue)));\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\treturn ((c == gravity_class_object) || (c == gravity_class_class) || (c == gravity_class_bool) ||",
                "\t\t\t(c == gravity_class_upvalue));"
            ],
            "added_lines": [
                "\t// first check if it is a class",
                "\tif ((c == gravity_class_object) || (c == gravity_class_class) || (c == gravity_class_bool) ||",
                "\t\t(c == gravity_class_upvalue)) return true;",
                "\t",
                "\t// if class check is false then check for meta",
                "\treturn ((c == gravity_class_get_meta(gravity_class_object)) || (c == gravity_class_get_meta(gravity_class_class)) ||",
                "\t\t\t(c == gravity_class_get_meta(gravity_class_bool)) || (c == gravity_class_get_meta(gravity_class_null)) ||",
                "\t\t\t(c == gravity_class_get_meta(gravity_class_int)) || (c == gravity_class_get_meta(gravity_class_float)) ||",
                "\t\t\t(c == gravity_class_get_meta(gravity_class_function)) || (c == gravity_class_get_meta(gravity_class_fiber)) ||",
                "\t\t\t(c == gravity_class_get_meta(gravity_class_string)) || (c == gravity_class_get_meta(gravity_class_instance)) ||",
                "\t\t\t(c == gravity_class_get_meta(gravity_class_list)) || (c == gravity_class_get_meta(gravity_class_map)) ||",
                "\t\t\t(c == gravity_class_get_meta(gravity_class_range)) || (c == gravity_class_get_meta(gravity_class_system)) ||",
                "\t\t\t(c == gravity_class_get_meta(gravity_class_closure)) || (c == gravity_class_get_meta(gravity_class_upvalue)));"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-1000072",
        "func_name": "marcobambini/gravity/object_bind",
        "description": "Creolabs Gravity version 1.0 is vulnerable to a Double Free in gravity_value resulting potentially leading to modification of unexpected memory locations",
        "git_url": "https://github.com/marcobambini/gravity/commit/f00c04dfa62d5f6ce0bc30e26545066de31d622c",
        "commit_title": "Fixed https://github.com/marcobambini/gravity/issues/123",
        "commit_text": "",
        "func_before": "static bool object_bind (gravity_vm *vm, gravity_value_t *args, uint16_t nargs, uint32_t rindex) {\n\t#pragma unused(rindex)\n\t\n\t// sanity check first\n\tif (nargs < 3) RETURN_ERROR(\"Incorrect number of arguments.\");\n\tif (!VALUE_ISA_STRING(GET_VALUE(1))) RETURN_ERROR(\"First argument must be a String.\");\n\tif (!VALUE_ISA_CLOSURE(GET_VALUE(2))) RETURN_ERROR(\"Second argument must be a Closure.\");\n\t\n\tgravity_object_t *object = NULL;\n\tif (VALUE_ISA_INSTANCE(GET_VALUE(0))) {\n\t\tobject = VALUE_AS_OBJECT(GET_VALUE(0));\n\t} else if (VALUE_ISA_CLASS(GET_VALUE(0))) {\n\t\tobject = VALUE_AS_OBJECT(GET_VALUE(0));\n\t} else {\n\t\tRETURN_ERROR(\"bind method can be applied only to instances or classes.\");\n\t}\n\t\n\tgravity_string_t *key = VALUE_AS_STRING(GET_VALUE(1));\n\tgravity_class_t *c = gravity_value_getclass(GET_VALUE(0));\n\t\n\t// check if instance has already an anonymous class added to its hierarchy\n\tif (string_casencmp(c->identifier, GRAVITY_VM_ANONYMOUS_PREFIX, strlen(GRAVITY_VM_ANONYMOUS_PREFIX) != 0)) {\n\t\t// no super anonymous class found so create a new one, set its super as c, and add it to the hierarchy\n\t\tchar *name = gravity_vm_anonymous(vm);\n\t\tgravity_class_t *anon = gravity_class_new_pair(NULL, name, c, 0, 0);\n\t\tgravity_class_t *anon_meta = gravity_class_get_meta(anon);\n\t\tobject->objclass = anon;\n\t\tc = anon;\n\t\t\n\t\t// store anonymous class (and its meta) into VM special GC stack\n\t\t// manually retains anonymous class that will retain its bound functions\n\t\tgravity_gc_push(vm, (gravity_object_t *)anon);\n\t\tgravity_gc_push(vm, (gravity_object_t *)anon_meta);\n\t}\n\t\n\t// add closure to anonymous class\n\tgravity_class_bind(c, key->s, GET_VALUE(2));\n\tRETURN_NOVALUE();\n}",
        "func": "static bool object_bind (gravity_vm *vm, gravity_value_t *args, uint16_t nargs, uint32_t rindex) {\n\t#pragma unused(rindex)\n\t\n\t// sanity check first\n\tif (nargs < 3) RETURN_ERROR(\"Incorrect number of arguments.\");\n\tif (!VALUE_ISA_STRING(GET_VALUE(1))) RETURN_ERROR(\"First argument must be a String.\");\n\tif (!VALUE_ISA_CLOSURE(GET_VALUE(2))) RETURN_ERROR(\"Second argument must be a Closure.\");\n\t\n\tgravity_object_t *object = NULL;\n\tif (VALUE_ISA_INSTANCE(GET_VALUE(0)) || VALUE_ISA_CLASS(GET_VALUE(0))) {\n\t\tobject = VALUE_AS_OBJECT(GET_VALUE(0));\n\t} else {\n\t\tRETURN_ERROR(\"bind method can be applied only to instances or classes.\");\n\t}\n\t\n\tgravity_string_t *key = VALUE_AS_STRING(GET_VALUE(1));\n\tgravity_class_t *c = gravity_value_getclass(GET_VALUE(0));\n\t\n\t// in this version core classes are shared among all VM instances and\n\t// this could be an issue in case of bound methods so it would be probably\n\t// a good idea to play safe and forbid bind on core classes\n\tif (gravity_iscore_class(c)) {\n\t\tRETURN_ERROR(\"Unable to bind method to a Gravity core class.\");\n\t}\n\t\n\t// check if instance has already an anonymous class added to its hierarchy\n\tif (string_casencmp(c->identifier, GRAVITY_VM_ANONYMOUS_PREFIX, strlen(GRAVITY_VM_ANONYMOUS_PREFIX) != 0)) {\n\t\t// no super anonymous class found so create a new one, set its super as c, and add it to the hierarchy\n\t\tchar *name = gravity_vm_anonymous(vm);\n\t\tgravity_class_t *anon = gravity_class_new_pair(NULL, name, c, 0, 0);\n\t\tgravity_class_t *anon_meta = gravity_class_get_meta(anon);\n\t\tobject->objclass = anon;\n\t\tc = anon;\n\t\t\n\t\t// store anonymous class (and its meta) into VM special GC stack\n\t\t// manually retains anonymous class that will retain its bound functions\n\t\tgravity_gc_push(vm, (gravity_object_t *)anon);\n\t\tgravity_gc_push(vm, (gravity_object_t *)anon_meta);\n\t}\n\t\n\t// add closure to anonymous class\n\tgravity_class_bind(c, key->s, GET_VALUE(2));\n\tRETURN_NOVALUE();\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -7,9 +7,7 @@\n \tif (!VALUE_ISA_CLOSURE(GET_VALUE(2))) RETURN_ERROR(\"Second argument must be a Closure.\");\n \t\n \tgravity_object_t *object = NULL;\n-\tif (VALUE_ISA_INSTANCE(GET_VALUE(0))) {\n-\t\tobject = VALUE_AS_OBJECT(GET_VALUE(0));\n-\t} else if (VALUE_ISA_CLASS(GET_VALUE(0))) {\n+\tif (VALUE_ISA_INSTANCE(GET_VALUE(0)) || VALUE_ISA_CLASS(GET_VALUE(0))) {\n \t\tobject = VALUE_AS_OBJECT(GET_VALUE(0));\n \t} else {\n \t\tRETURN_ERROR(\"bind method can be applied only to instances or classes.\");\n@@ -17,6 +15,13 @@\n \t\n \tgravity_string_t *key = VALUE_AS_STRING(GET_VALUE(1));\n \tgravity_class_t *c = gravity_value_getclass(GET_VALUE(0));\n+\t\n+\t// in this version core classes are shared among all VM instances and\n+\t// this could be an issue in case of bound methods so it would be probably\n+\t// a good idea to play safe and forbid bind on core classes\n+\tif (gravity_iscore_class(c)) {\n+\t\tRETURN_ERROR(\"Unable to bind method to a Gravity core class.\");\n+\t}\n \t\n \t// check if instance has already an anonymous class added to its hierarchy\n \tif (string_casencmp(c->identifier, GRAVITY_VM_ANONYMOUS_PREFIX, strlen(GRAVITY_VM_ANONYMOUS_PREFIX) != 0)) {",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (VALUE_ISA_INSTANCE(GET_VALUE(0))) {",
                "\t\tobject = VALUE_AS_OBJECT(GET_VALUE(0));",
                "\t} else if (VALUE_ISA_CLASS(GET_VALUE(0))) {"
            ],
            "added_lines": [
                "\tif (VALUE_ISA_INSTANCE(GET_VALUE(0)) || VALUE_ISA_CLASS(GET_VALUE(0))) {",
                "\t",
                "\t// in this version core classes are shared among all VM instances and",
                "\t// this could be an issue in case of bound methods so it would be probably",
                "\t// a good idea to play safe and forbid bind on core classes",
                "\tif (gravity_iscore_class(c)) {",
                "\t\tRETURN_ERROR(\"Unable to bind method to a Gravity core class.\");",
                "\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-19725",
        "func_name": "sysstat/check_file_actlst",
        "description": "sysstat through 12.2.0 has a double free in check_file_actlst in sa_common.c.",
        "git_url": "https://github.com/sysstat/sysstat/commit/a5c8abd4a481ee6e27a3acf00e6d9b0f023e20ed",
        "commit_title": "Fix #242: Double free in check_file_actlst()",
        "commit_text": " Avoid freeing buffer() twice. ",
        "func_before": "void check_file_actlst(int *ifd, char *dfile, struct activity *act[], uint64_t flags,\n\t\t       struct file_magic *file_magic, struct file_header *file_hdr,\n\t\t       struct file_activity **file_actlst, unsigned int id_seq[],\n\t\t       int ignore, int *endian_mismatch, int *arch_64)\n{\n\tint i, j, k, p;\n\tstruct file_activity *fal;\n\tvoid *buffer = NULL;\n\tsize_t bh_size = FILE_HEADER_SIZE;\n\tsize_t ba_size = FILE_ACTIVITY_SIZE;\n\n\t/* Open sa data file and read its magic structure */\n\tif (sa_open_read_magic(ifd, dfile, file_magic, ignore, endian_mismatch, TRUE) < 0)\n\t\t/*\n\t\t * Not current sysstat's format.\n\t\t * Return now so that sadf -H can display at least\n\t\t * file's version and magic number.\n\t\t */\n\t\treturn;\n\n\t/*\n\t * We know now that we have a *compatible* sysstat datafile format\n\t * (correct FORMAT_MAGIC value), and in this case, we should have\n\t * checked header_size value. Anyway, with a corrupted datafile,\n\t * this may not be the case. So check again.\n\t */\n\tif ((file_magic->header_size <= MIN_FILE_HEADER_SIZE) ||\n\t    (file_magic->header_size > MAX_FILE_HEADER_SIZE)) {\n#ifdef DEBUG\n\t\tfprintf(stderr, \"%s: header_size=%u\\n\",\n\t\t\t__FUNCTION__, file_magic->header_size);\n#endif\n\t\tgoto format_error;\n\t}\n\n\t/* Allocate buffer for file_header structure */\n\tif (file_magic->header_size > FILE_HEADER_SIZE) {\n\t\tbh_size = file_magic->header_size;\n\t}\n\tSREALLOC(buffer, char, bh_size);\n\n\t/* Read sa data file standard header and allocate activity list */\n\tsa_fread(*ifd, buffer, (size_t) file_magic->header_size, HARD_SIZE, UEOF_STOP);\n\t/*\n\t * Data file header size (file_magic->header_size) may be greater or\n\t * smaller than FILE_HEADER_SIZE. Remap the fields of the file header\n\t * then copy its contents to the expected structure.\n\t */\n\tif (remap_struct(hdr_types_nr, file_magic->hdr_types_nr, buffer,\n\t\t\t file_magic->header_size, FILE_HEADER_SIZE, bh_size) < 0)\n\t\tgoto format_error;\n\n\tmemcpy(file_hdr, buffer, FILE_HEADER_SIZE);\n\tfree(buffer);\n\tbuffer = NULL;\n\n\t/* Tell that data come from a 64 bit machine */\n\t*arch_64 = (file_hdr->sa_sizeof_long == SIZEOF_LONG_64BIT);\n\n\t/* Normalize endianness for file_hdr structure */\n\tif (*endian_mismatch) {\n\t\tswap_struct(hdr_types_nr, file_hdr, *arch_64);\n\t}\n\n\t/*\n\t * Sanity checks.\n\t * NB: Compare against MAX_NR_ACT and not NR_ACT because\n\t * we are maybe reading a datafile from a future sysstat version\n\t * with more activities than known today.\n\t */\n\tif ((file_hdr->sa_act_nr > MAX_NR_ACT) ||\n\t    (file_hdr->act_size > MAX_FILE_ACTIVITY_SIZE) ||\n\t    (file_hdr->rec_size > MAX_RECORD_HEADER_SIZE) ||\n\t    (MAP_SIZE(file_hdr->act_types_nr) > file_hdr->act_size) ||\n\t    (MAP_SIZE(file_hdr->rec_types_nr) > file_hdr->rec_size)) {\n#ifdef DEBUG\n\t\tfprintf(stderr, \"%s: sa_act_nr=%d act_size=%u rec_size=%u map_size(act)=%u map_size(rec)=%u\\n\",\n\t\t\t__FUNCTION__, file_hdr->sa_act_nr, file_hdr->act_size, file_hdr->rec_size,\n\t\t\tMAP_SIZE(file_hdr->act_types_nr), MAP_SIZE(file_hdr->rec_types_nr));\n#endif\n\t\t/* Maybe a \"false positive\" sysstat datafile? */\n\t\tgoto format_error;\n\t}\n\n\t/* Allocate buffer for file_activity structures */\n\tif (file_hdr->act_size > FILE_ACTIVITY_SIZE) {\n\t\tba_size = file_hdr->act_size;\n\t}\n\tSREALLOC(buffer, char, ba_size);\n\tSREALLOC(*file_actlst, struct file_activity, FILE_ACTIVITY_SIZE * file_hdr->sa_act_nr);\n\tfal = *file_actlst;\n\n\t/* Read activity list */\n\tj = 0;\n\tfor (i = 0; i < file_hdr->sa_act_nr; i++, fal++) {\n\n\t\t/* Read current file_activity structure from file */\n\t\tsa_fread(*ifd, buffer, (size_t) file_hdr->act_size, HARD_SIZE, UEOF_STOP);\n\t\t/*\n\t\t* Data file_activity size (file_hdr->act_size) may be greater or\n\t\t* smaller than FILE_ACTIVITY_SIZE. Remap the fields of the file's structure\n\t\t* then copy its contents to the expected structure.\n\t\t*/\n\t\tif (remap_struct(act_types_nr, file_hdr->act_types_nr, buffer,\n\t\t\t     file_hdr->act_size, FILE_ACTIVITY_SIZE, ba_size) < 0)\n\t\t\tgoto format_error;\n\t\tmemcpy(fal, buffer, FILE_ACTIVITY_SIZE);\n\n\t\t/* Normalize endianness for file_activity structures */\n\t\tif (*endian_mismatch) {\n\t\t\tswap_struct(act_types_nr, fal, *arch_64);\n\t\t}\n\n\t\t/*\n\t\t * Every activity, known or unknown, should have\n\t\t * at least one item and sub-item, and a positive size value.\n\t\t * Also check that the number of items and sub-items\n\t\t * doesn't exceed a max value. This is necessary\n\t\t * because we will use @nr and @nr2 to\n\t\t * allocate memory to read the file contents. So we\n\t\t * must make sure the file is not corrupted.\n\t\t * NB: Another check will be made below for known\n\t\t * activities which have each a specific max value.\n\t\t */\n\t\tif ((fal->nr < 1) || (fal->nr2 < 1) ||\n\t\t    (fal->nr > NR_MAX) || (fal->nr2 > NR2_MAX) ||\n\t\t    (fal->size <= 0)) {\n#ifdef DEBUG\n\t\t\tfprintf(stderr, \"%s: id=%d nr=%d nr2=%d\\n\",\n\t\t\t\t__FUNCTION__, fal->id, fal->nr, fal->nr2);\n#endif\n\t\t\tgoto format_error;\n\t\t}\n\n\t\tif ((p = get_activity_position(act, fal->id, RESUME_IF_NOT_FOUND)) < 0)\n\t\t\t/* Unknown activity */\n\t\t\tcontinue;\n\n\t\tif (act[p]->magic != fal->magic) {\n\t\t\t/* Bad magical number */\n\t\t\tif (ignore) {\n\t\t\t\t/*\n\t\t\t\t * This is how sadf -H knows that this\n\t\t\t\t * activity has an unknown format.\n\t\t\t\t */\n\t\t\t\tact[p]->magic = ACTIVITY_MAGIC_UNKNOWN;\n\t\t\t}\n\t\t\telse\n\t\t\t\tcontinue;\n\t\t}\n\n\t\t/* Check max value for known activities */\n\t\tif (fal->nr > act[p]->nr_max) {\n#ifdef DEBUG\n\t\t\tfprintf(stderr, \"%s: id=%d nr=%d nr_max=%d\\n\",\n\t\t\t\t__FUNCTION__, fal->id, fal->nr, act[p]->nr_max);\n#endif\n\t\t\tgoto format_error;\n\t\t}\n\n\t\t/*\n\t\t * Number of fields of each type (\"long long\", or \"long\"\n\t\t * or \"int\") composing the structure with statistics may\n\t\t * only increase with new sysstat versions. Here, we may\n\t\t * be reading a file created by current sysstat version,\n\t\t * or by an older or a newer version.\n\t\t */\n\t\tif (!(((fal->types_nr[0] >= act[p]->gtypes_nr[0]) &&\n\t\t     (fal->types_nr[1] >= act[p]->gtypes_nr[1]) &&\n\t\t     (fal->types_nr[2] >= act[p]->gtypes_nr[2]))\n\t\t     ||\n\t\t     ((fal->types_nr[0] <= act[p]->gtypes_nr[0]) &&\n\t\t     (fal->types_nr[1] <= act[p]->gtypes_nr[1]) &&\n\t\t     (fal->types_nr[2] <= act[p]->gtypes_nr[2]))) && !ignore) {\n#ifdef DEBUG\n\t\t\tfprintf(stderr, \"%s: id=%d file=%d,%d,%d activity=%d,%d,%d\\n\",\n\t\t\t\t__FUNCTION__, fal->id, fal->types_nr[0], fal->types_nr[1], fal->types_nr[2],\n\t\t\t\tact[p]->gtypes_nr[0], act[p]->gtypes_nr[1], act[p]->gtypes_nr[2]);\n#endif\n\t\t\tgoto format_error;\n\t\t}\n\n\t\tif (MAP_SIZE(fal->types_nr) > fal->size) {\n#ifdef DEBUG\n\t\tfprintf(stderr, \"%s: id=%d size=%u map_size=%u\\n\",\n\t\t\t__FUNCTION__, fal->id, fal->size, MAP_SIZE(fal->types_nr));\n#endif\n\t\t\tgoto format_error;\n\t\t}\n\n\t\tfor (k = 0; k < 3; k++) {\n\t\t\tact[p]->ftypes_nr[k] = fal->types_nr[k];\n\t\t}\n\n\t\tif (fal->size > act[p]->msize) {\n\t\t\tact[p]->msize = fal->size;\n\t\t}\n\n\t\tact[p]->nr_ini = fal->nr;\n\t\tact[p]->nr2    = fal->nr2;\n\t\tact[p]->fsize  = fal->size;\n\t\t/*\n\t\t * This is a known activity with a known format\n\t\t * (magical number). Only such activities will be displayed.\n\t\t * (Well, this may also be an unknown format if we have entered sadf -H.)\n\t\t */\n\t\tid_seq[j++] = fal->id;\n\t}\n\n\twhile (j < NR_ACT) {\n\t\tid_seq[j++] = 0;\n\t}\n\n\tfree(buffer);\n\n\t/* Check that at least one activity selected by the user is available in file */\n\tfor (i = 0; i < NR_ACT; i++) {\n\n\t\tif (!IS_SELECTED(act[i]->options))\n\t\t\tcontinue;\n\n\t\t/* Here is a selected activity: Does it exist in file? */\n\t\tfal = *file_actlst;\n\t\tfor (j = 0; j < file_hdr->sa_act_nr; j++, fal++) {\n\t\t\tif (act[i]->id == fal->id)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (j == file_hdr->sa_act_nr) {\n\t\t\t/* No: Unselect it */\n\t\t\tact[i]->options &= ~AO_SELECTED;\n\t\t}\n\t}\n\n\t/*\n\t * None of selected activities exist in file: Abort.\n\t * NB: Error is ignored if we only want to display\n\t * datafile header (sadf -H).\n\t */\n\tif (!get_activity_nr(act, AO_SELECTED, COUNT_ACTIVITIES) && !DISPLAY_HDR_ONLY(flags)) {\n\t\tfprintf(stderr, _(\"Requested activities not available in file %s\\n\"),\n\t\t\tdfile);\n\t\tclose(*ifd);\n\t\texit(1);\n\t}\n\n\t/*\n\t * Check if there are some extra structures.\n\t * We will just skip them as they are unknown for now.\n\t */\n\tif (file_hdr->extra_next && (skip_extra_struct(*ifd, *endian_mismatch, *arch_64) < 0))\n\t\tgoto format_error;\n\n\treturn;\n\nformat_error:\n\tif (buffer) {\n\t\tfree(buffer);\n\t}\n\thandle_invalid_sa_file(*ifd, file_magic, dfile, 0);\n}",
        "func": "void check_file_actlst(int *ifd, char *dfile, struct activity *act[], uint64_t flags,\n\t\t       struct file_magic *file_magic, struct file_header *file_hdr,\n\t\t       struct file_activity **file_actlst, unsigned int id_seq[],\n\t\t       int ignore, int *endian_mismatch, int *arch_64)\n{\n\tint i, j, k, p;\n\tstruct file_activity *fal;\n\tvoid *buffer = NULL;\n\tsize_t bh_size = FILE_HEADER_SIZE;\n\tsize_t ba_size = FILE_ACTIVITY_SIZE;\n\n\t/* Open sa data file and read its magic structure */\n\tif (sa_open_read_magic(ifd, dfile, file_magic, ignore, endian_mismatch, TRUE) < 0)\n\t\t/*\n\t\t * Not current sysstat's format.\n\t\t * Return now so that sadf -H can display at least\n\t\t * file's version and magic number.\n\t\t */\n\t\treturn;\n\n\t/*\n\t * We know now that we have a *compatible* sysstat datafile format\n\t * (correct FORMAT_MAGIC value), and in this case, we should have\n\t * checked header_size value. Anyway, with a corrupted datafile,\n\t * this may not be the case. So check again.\n\t */\n\tif ((file_magic->header_size <= MIN_FILE_HEADER_SIZE) ||\n\t    (file_magic->header_size > MAX_FILE_HEADER_SIZE)) {\n#ifdef DEBUG\n\t\tfprintf(stderr, \"%s: header_size=%u\\n\",\n\t\t\t__FUNCTION__, file_magic->header_size);\n#endif\n\t\tgoto format_error;\n\t}\n\n\t/* Allocate buffer for file_header structure */\n\tif (file_magic->header_size > FILE_HEADER_SIZE) {\n\t\tbh_size = file_magic->header_size;\n\t}\n\tSREALLOC(buffer, char, bh_size);\n\n\t/* Read sa data file standard header and allocate activity list */\n\tsa_fread(*ifd, buffer, (size_t) file_magic->header_size, HARD_SIZE, UEOF_STOP);\n\t/*\n\t * Data file header size (file_magic->header_size) may be greater or\n\t * smaller than FILE_HEADER_SIZE. Remap the fields of the file header\n\t * then copy its contents to the expected structure.\n\t */\n\tif (remap_struct(hdr_types_nr, file_magic->hdr_types_nr, buffer,\n\t\t\t file_magic->header_size, FILE_HEADER_SIZE, bh_size) < 0)\n\t\tgoto format_error;\n\n\tmemcpy(file_hdr, buffer, FILE_HEADER_SIZE);\n\tfree(buffer);\n\tbuffer = NULL;\n\n\t/* Tell that data come from a 64 bit machine */\n\t*arch_64 = (file_hdr->sa_sizeof_long == SIZEOF_LONG_64BIT);\n\n\t/* Normalize endianness for file_hdr structure */\n\tif (*endian_mismatch) {\n\t\tswap_struct(hdr_types_nr, file_hdr, *arch_64);\n\t}\n\n\t/*\n\t * Sanity checks.\n\t * NB: Compare against MAX_NR_ACT and not NR_ACT because\n\t * we are maybe reading a datafile from a future sysstat version\n\t * with more activities than known today.\n\t */\n\tif ((file_hdr->sa_act_nr > MAX_NR_ACT) ||\n\t    (file_hdr->act_size > MAX_FILE_ACTIVITY_SIZE) ||\n\t    (file_hdr->rec_size > MAX_RECORD_HEADER_SIZE) ||\n\t    (MAP_SIZE(file_hdr->act_types_nr) > file_hdr->act_size) ||\n\t    (MAP_SIZE(file_hdr->rec_types_nr) > file_hdr->rec_size)) {\n#ifdef DEBUG\n\t\tfprintf(stderr, \"%s: sa_act_nr=%d act_size=%u rec_size=%u map_size(act)=%u map_size(rec)=%u\\n\",\n\t\t\t__FUNCTION__, file_hdr->sa_act_nr, file_hdr->act_size, file_hdr->rec_size,\n\t\t\tMAP_SIZE(file_hdr->act_types_nr), MAP_SIZE(file_hdr->rec_types_nr));\n#endif\n\t\t/* Maybe a \"false positive\" sysstat datafile? */\n\t\tgoto format_error;\n\t}\n\n\t/* Allocate buffer for file_activity structures */\n\tif (file_hdr->act_size > FILE_ACTIVITY_SIZE) {\n\t\tba_size = file_hdr->act_size;\n\t}\n\tSREALLOC(buffer, char, ba_size);\n\tSREALLOC(*file_actlst, struct file_activity, FILE_ACTIVITY_SIZE * file_hdr->sa_act_nr);\n\tfal = *file_actlst;\n\n\t/* Read activity list */\n\tj = 0;\n\tfor (i = 0; i < file_hdr->sa_act_nr; i++, fal++) {\n\n\t\t/* Read current file_activity structure from file */\n\t\tsa_fread(*ifd, buffer, (size_t) file_hdr->act_size, HARD_SIZE, UEOF_STOP);\n\t\t/*\n\t\t* Data file_activity size (file_hdr->act_size) may be greater or\n\t\t* smaller than FILE_ACTIVITY_SIZE. Remap the fields of the file's structure\n\t\t* then copy its contents to the expected structure.\n\t\t*/\n\t\tif (remap_struct(act_types_nr, file_hdr->act_types_nr, buffer,\n\t\t\t     file_hdr->act_size, FILE_ACTIVITY_SIZE, ba_size) < 0)\n\t\t\tgoto format_error;\n\t\tmemcpy(fal, buffer, FILE_ACTIVITY_SIZE);\n\n\t\t/* Normalize endianness for file_activity structures */\n\t\tif (*endian_mismatch) {\n\t\t\tswap_struct(act_types_nr, fal, *arch_64);\n\t\t}\n\n\t\t/*\n\t\t * Every activity, known or unknown, should have\n\t\t * at least one item and sub-item, and a positive size value.\n\t\t * Also check that the number of items and sub-items\n\t\t * doesn't exceed a max value. This is necessary\n\t\t * because we will use @nr and @nr2 to\n\t\t * allocate memory to read the file contents. So we\n\t\t * must make sure the file is not corrupted.\n\t\t * NB: Another check will be made below for known\n\t\t * activities which have each a specific max value.\n\t\t */\n\t\tif ((fal->nr < 1) || (fal->nr2 < 1) ||\n\t\t    (fal->nr > NR_MAX) || (fal->nr2 > NR2_MAX) ||\n\t\t    (fal->size <= 0)) {\n#ifdef DEBUG\n\t\t\tfprintf(stderr, \"%s: id=%d nr=%d nr2=%d\\n\",\n\t\t\t\t__FUNCTION__, fal->id, fal->nr, fal->nr2);\n#endif\n\t\t\tgoto format_error;\n\t\t}\n\n\t\tif ((p = get_activity_position(act, fal->id, RESUME_IF_NOT_FOUND)) < 0)\n\t\t\t/* Unknown activity */\n\t\t\tcontinue;\n\n\t\tif (act[p]->magic != fal->magic) {\n\t\t\t/* Bad magical number */\n\t\t\tif (ignore) {\n\t\t\t\t/*\n\t\t\t\t * This is how sadf -H knows that this\n\t\t\t\t * activity has an unknown format.\n\t\t\t\t */\n\t\t\t\tact[p]->magic = ACTIVITY_MAGIC_UNKNOWN;\n\t\t\t}\n\t\t\telse\n\t\t\t\tcontinue;\n\t\t}\n\n\t\t/* Check max value for known activities */\n\t\tif (fal->nr > act[p]->nr_max) {\n#ifdef DEBUG\n\t\t\tfprintf(stderr, \"%s: id=%d nr=%d nr_max=%d\\n\",\n\t\t\t\t__FUNCTION__, fal->id, fal->nr, act[p]->nr_max);\n#endif\n\t\t\tgoto format_error;\n\t\t}\n\n\t\t/*\n\t\t * Number of fields of each type (\"long long\", or \"long\"\n\t\t * or \"int\") composing the structure with statistics may\n\t\t * only increase with new sysstat versions. Here, we may\n\t\t * be reading a file created by current sysstat version,\n\t\t * or by an older or a newer version.\n\t\t */\n\t\tif (!(((fal->types_nr[0] >= act[p]->gtypes_nr[0]) &&\n\t\t     (fal->types_nr[1] >= act[p]->gtypes_nr[1]) &&\n\t\t     (fal->types_nr[2] >= act[p]->gtypes_nr[2]))\n\t\t     ||\n\t\t     ((fal->types_nr[0] <= act[p]->gtypes_nr[0]) &&\n\t\t     (fal->types_nr[1] <= act[p]->gtypes_nr[1]) &&\n\t\t     (fal->types_nr[2] <= act[p]->gtypes_nr[2]))) && !ignore) {\n#ifdef DEBUG\n\t\t\tfprintf(stderr, \"%s: id=%d file=%d,%d,%d activity=%d,%d,%d\\n\",\n\t\t\t\t__FUNCTION__, fal->id, fal->types_nr[0], fal->types_nr[1], fal->types_nr[2],\n\t\t\t\tact[p]->gtypes_nr[0], act[p]->gtypes_nr[1], act[p]->gtypes_nr[2]);\n#endif\n\t\t\tgoto format_error;\n\t\t}\n\n\t\tif (MAP_SIZE(fal->types_nr) > fal->size) {\n#ifdef DEBUG\n\t\tfprintf(stderr, \"%s: id=%d size=%u map_size=%u\\n\",\n\t\t\t__FUNCTION__, fal->id, fal->size, MAP_SIZE(fal->types_nr));\n#endif\n\t\t\tgoto format_error;\n\t\t}\n\n\t\tfor (k = 0; k < 3; k++) {\n\t\t\tact[p]->ftypes_nr[k] = fal->types_nr[k];\n\t\t}\n\n\t\tif (fal->size > act[p]->msize) {\n\t\t\tact[p]->msize = fal->size;\n\t\t}\n\n\t\tact[p]->nr_ini = fal->nr;\n\t\tact[p]->nr2    = fal->nr2;\n\t\tact[p]->fsize  = fal->size;\n\t\t/*\n\t\t * This is a known activity with a known format\n\t\t * (magical number). Only such activities will be displayed.\n\t\t * (Well, this may also be an unknown format if we have entered sadf -H.)\n\t\t */\n\t\tid_seq[j++] = fal->id;\n\t}\n\n\twhile (j < NR_ACT) {\n\t\tid_seq[j++] = 0;\n\t}\n\n\tfree(buffer);\n\tbuffer = NULL;\n\n\t/* Check that at least one activity selected by the user is available in file */\n\tfor (i = 0; i < NR_ACT; i++) {\n\n\t\tif (!IS_SELECTED(act[i]->options))\n\t\t\tcontinue;\n\n\t\t/* Here is a selected activity: Does it exist in file? */\n\t\tfal = *file_actlst;\n\t\tfor (j = 0; j < file_hdr->sa_act_nr; j++, fal++) {\n\t\t\tif (act[i]->id == fal->id)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (j == file_hdr->sa_act_nr) {\n\t\t\t/* No: Unselect it */\n\t\t\tact[i]->options &= ~AO_SELECTED;\n\t\t}\n\t}\n\n\t/*\n\t * None of selected activities exist in file: Abort.\n\t * NB: Error is ignored if we only want to display\n\t * datafile header (sadf -H).\n\t */\n\tif (!get_activity_nr(act, AO_SELECTED, COUNT_ACTIVITIES) && !DISPLAY_HDR_ONLY(flags)) {\n\t\tfprintf(stderr, _(\"Requested activities not available in file %s\\n\"),\n\t\t\tdfile);\n\t\tclose(*ifd);\n\t\texit(1);\n\t}\n\n\t/*\n\t * Check if there are some extra structures.\n\t * We will just skip them as they are unknown for now.\n\t */\n\tif (file_hdr->extra_next && (skip_extra_struct(*ifd, *endian_mismatch, *arch_64) < 0))\n\t\tgoto format_error;\n\n\treturn;\n\nformat_error:\n\tif (buffer) {\n\t\tfree(buffer);\n\t}\n\thandle_invalid_sa_file(*ifd, file_magic, dfile, 0);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -212,6 +212,7 @@\n \t}\n \n \tfree(buffer);\n+\tbuffer = NULL;\n \n \t/* Check that at least one activity selected by the user is available in file */\n \tfor (i = 0; i < NR_ACT; i++) {",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tbuffer = NULL;"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-11049",
        "func_name": "php/php-src/TSendMail",
        "description": "In PHP versions 7.3.x below 7.3.13 and 7.4.0 on Windows, when supplying custom headers to mail() function, due to mistake introduced in commit 78f4b4a2dcf92ddbccea1bb95f8390a18ac3342e, if the header is supplied in lowercase, this can result in double-freeing certain memory locations.",
        "git_url": "https://github.com/php/php-src/commit/11893c8e665d285f72c2b8a0fbe01a3fcc03b806",
        "commit_title": "Fix #78943: mail() may release string with refcount==1 twice",
        "commit_text": " Since we need `headers_lc` as well as `headers_trim` in the following, we do not release the former even if they are the same string, to avoid complicating the release logic even more.  A new test case is not necessary, since we already have mail_basic_alt2-win32.phpt and others.  (cherry picked from commit 518a160b65fe1c535dc7e78972ba7428c2a4e197)",
        "func_before": "PHPAPI int TSendMail(char *host, int *error, char **error_message,\n\t\t\t  char *headers, char *Subject, char *mailTo, char *data,\n\t\t\t  char *mailCc, char *mailBcc, char *mailRPath)\n{\n\tint ret;\n\tchar *RPath = NULL;\n\tzend_string *headers_lc = NULL, *headers_trim = NULL; /* headers_lc is only created if we've a header at all */\n\tchar *pos1 = NULL, *pos2 = NULL;\n\n\tif (host == NULL) {\n\t\t*error = BAD_MAIL_HOST;\n\t\treturn FAILURE;\n\t} else if (strlen(host) >= HOST_NAME_LEN) {\n\t\t*error = BAD_MAIL_HOST;\n\t\treturn FAILURE;\n\t} else {\n\t\tstrcpy(PW32G(mail_host), host);\n\t}\n\n\tif (headers) {\n\t\tchar *pos = NULL;\n\n\t\t/* Use PCRE to trim the header into the right format */\n\t\tif (NULL == (headers_trim = php_win32_mail_trim_header(headers))) {\n\t\t\t*error = W32_SM_PCRE_ERROR;\n\t\t\treturn FAILURE;\n\t\t}\n\n\t\t/* Create a lowercased header for all the searches so we're finally case\n\t\t * insensitive when searching for a pattern. */\n\t\theaders_lc = zend_string_tolower(headers_trim);\n\t\tif (headers_lc == headers_trim) {\n\t\t\tzend_string_release_ex(headers_lc, 0);\n\t\t}\n\t}\n\n\t/* Fall back to sendmail_from php.ini setting */\n\tif (mailRPath && *mailRPath) {\n\t\tRPath = estrdup(mailRPath);\n\t} else if (INI_STR(\"sendmail_from\")) {\n\t\tRPath = estrdup(INI_STR(\"sendmail_from\"));\n\t} else if (headers_lc) {\n\t\tint found = 0;\n\t\tchar *lookup = ZSTR_VAL(headers_lc);\n\n\t\twhile (lookup) {\n\t\t\tpos1 = strstr(lookup, \"from:\");\n\n\t\t\tif (!pos1) {\n\t\t\t\tbreak;\n\t\t\t} else if (pos1 != ZSTR_VAL(headers_lc) && *(pos1-1) != '\\n') {\n\t\t\t\tif (strlen(pos1) >= sizeof(\"from:\")) {\n\t\t\t\t\tlookup = pos1 + sizeof(\"from:\");\n\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfound = 1;\n\n\t\t\t/* Real offset is memaddress from the original headers + difference of\n\t\t\t * string found in the lowercase headrs + 5 characters to jump over\n\t\t\t * the from: */\n\t\t\tpos1 = headers + (pos1 - lookup) + 5;\n\t\t\tif (NULL == (pos2 = strstr(pos1, \"\\r\\n\"))) {\n\t\t\t\tRPath = estrndup(pos1, strlen(pos1));\n\t\t\t} else {\n\t\t\t\tRPath = estrndup(pos1, pos2 - pos1);\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!found) {\n\t\t\tif (headers) {\n\t\t\t\tzend_string_release(headers_trim);\n\t\t\t\tzend_string_release(headers_lc);\n\t\t\t}\n\t\t\t*error = W32_SM_SENDMAIL_FROM_NOT_SET;\n\t\t\treturn FAILURE;\n\t\t}\n\t}\n\n\t/* attempt to connect with mail host */\n\t*error = MailConnect();\n\tif (*error != 0) {\n\t\tif (RPath) {\n\t\t\tefree(RPath);\n\t\t}\n\t\tif (headers) {\n\t\t\tzend_string_release(headers_trim);\n\t\t\tzend_string_release(headers_lc);\n\t\t}\n\t\t/* 128 is safe here, the specifier in snprintf isn't longer than that */\n\t\t*error_message = ecalloc(1, HOST_NAME_LEN + 128);\n\t\tsnprintf(*error_message, HOST_NAME_LEN + 128,\n\t\t\t\"Failed to connect to mailserver at \\\"%s\\\" port %d, verify your \\\"SMTP\\\" \"\n\t\t\t\"and \\\"smtp_port\\\" setting in php.ini or use ini_set()\",\n\t\t\tPW32G(mail_host), !INI_INT(\"smtp_port\") ? 25 : INI_INT(\"smtp_port\"));\n\t\treturn FAILURE;\n\t} else {\n\t\tret = SendText(RPath, Subject, mailTo, mailCc, mailBcc, data, headers ? ZSTR_VAL(headers_trim) : NULL, headers ? ZSTR_VAL(headers_lc) : NULL, error_message);\n\t\tTSMClose();\n\t\tif (RPath) {\n\t\t\tefree(RPath);\n\t\t}\n\t\tif (headers) {\n\t\t\tzend_string_release(headers_trim);\n\t\t\tzend_string_release(headers_lc);\n\t\t}\n\t\tif (ret != SUCCESS) {\n\t\t\t*error = ret;\n\t\t\treturn FAILURE;\n\t\t}\n\t\treturn SUCCESS;\n\t}\n}",
        "func": "PHPAPI int TSendMail(char *host, int *error, char **error_message,\n\t\t\t  char *headers, char *Subject, char *mailTo, char *data,\n\t\t\t  char *mailCc, char *mailBcc, char *mailRPath)\n{\n\tint ret;\n\tchar *RPath = NULL;\n\tzend_string *headers_lc = NULL, *headers_trim = NULL; /* headers_lc is only created if we've a header at all */\n\tchar *pos1 = NULL, *pos2 = NULL;\n\n\tif (host == NULL) {\n\t\t*error = BAD_MAIL_HOST;\n\t\treturn FAILURE;\n\t} else if (strlen(host) >= HOST_NAME_LEN) {\n\t\t*error = BAD_MAIL_HOST;\n\t\treturn FAILURE;\n\t} else {\n\t\tstrcpy(PW32G(mail_host), host);\n\t}\n\n\tif (headers) {\n\t\tchar *pos = NULL;\n\n\t\t/* Use PCRE to trim the header into the right format */\n\t\tif (NULL == (headers_trim = php_win32_mail_trim_header(headers))) {\n\t\t\t*error = W32_SM_PCRE_ERROR;\n\t\t\treturn FAILURE;\n\t\t}\n\n\t\t/* Create a lowercased header for all the searches so we're finally case\n\t\t * insensitive when searching for a pattern. */\n\t\theaders_lc = zend_string_tolower(headers_trim);\n\t}\n\n\t/* Fall back to sendmail_from php.ini setting */\n\tif (mailRPath && *mailRPath) {\n\t\tRPath = estrdup(mailRPath);\n\t} else if (INI_STR(\"sendmail_from\")) {\n\t\tRPath = estrdup(INI_STR(\"sendmail_from\"));\n\t} else if (headers_lc) {\n\t\tint found = 0;\n\t\tchar *lookup = ZSTR_VAL(headers_lc);\n\n\t\twhile (lookup) {\n\t\t\tpos1 = strstr(lookup, \"from:\");\n\n\t\t\tif (!pos1) {\n\t\t\t\tbreak;\n\t\t\t} else if (pos1 != ZSTR_VAL(headers_lc) && *(pos1-1) != '\\n') {\n\t\t\t\tif (strlen(pos1) >= sizeof(\"from:\")) {\n\t\t\t\t\tlookup = pos1 + sizeof(\"from:\");\n\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfound = 1;\n\n\t\t\t/* Real offset is memaddress from the original headers + difference of\n\t\t\t * string found in the lowercase headrs + 5 characters to jump over\n\t\t\t * the from: */\n\t\t\tpos1 = headers + (pos1 - lookup) + 5;\n\t\t\tif (NULL == (pos2 = strstr(pos1, \"\\r\\n\"))) {\n\t\t\t\tRPath = estrndup(pos1, strlen(pos1));\n\t\t\t} else {\n\t\t\t\tRPath = estrndup(pos1, pos2 - pos1);\n\t\t\t}\n\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!found) {\n\t\t\tif (headers) {\n\t\t\t\tzend_string_release(headers_trim);\n\t\t\t\tzend_string_release(headers_lc);\n\t\t\t}\n\t\t\t*error = W32_SM_SENDMAIL_FROM_NOT_SET;\n\t\t\treturn FAILURE;\n\t\t}\n\t}\n\n\t/* attempt to connect with mail host */\n\t*error = MailConnect();\n\tif (*error != 0) {\n\t\tif (RPath) {\n\t\t\tefree(RPath);\n\t\t}\n\t\tif (headers) {\n\t\t\tzend_string_release(headers_trim);\n\t\t\tzend_string_release(headers_lc);\n\t\t}\n\t\t/* 128 is safe here, the specifier in snprintf isn't longer than that */\n\t\t*error_message = ecalloc(1, HOST_NAME_LEN + 128);\n\t\tsnprintf(*error_message, HOST_NAME_LEN + 128,\n\t\t\t\"Failed to connect to mailserver at \\\"%s\\\" port %d, verify your \\\"SMTP\\\" \"\n\t\t\t\"and \\\"smtp_port\\\" setting in php.ini or use ini_set()\",\n\t\t\tPW32G(mail_host), !INI_INT(\"smtp_port\") ? 25 : INI_INT(\"smtp_port\"));\n\t\treturn FAILURE;\n\t} else {\n\t\tret = SendText(RPath, Subject, mailTo, mailCc, mailBcc, data, headers ? ZSTR_VAL(headers_trim) : NULL, headers ? ZSTR_VAL(headers_lc) : NULL, error_message);\n\t\tTSMClose();\n\t\tif (RPath) {\n\t\t\tefree(RPath);\n\t\t}\n\t\tif (headers) {\n\t\t\tzend_string_release(headers_trim);\n\t\t\tzend_string_release(headers_lc);\n\t\t}\n\t\tif (ret != SUCCESS) {\n\t\t\t*error = ret;\n\t\t\treturn FAILURE;\n\t\t}\n\t\treturn SUCCESS;\n\t}\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -29,9 +29,6 @@\n \t\t/* Create a lowercased header for all the searches so we're finally case\n \t\t * insensitive when searching for a pattern. */\n \t\theaders_lc = zend_string_tolower(headers_trim);\n-\t\tif (headers_lc == headers_trim) {\n-\t\t\tzend_string_release_ex(headers_lc, 0);\n-\t\t}\n \t}\n \n \t/* Fall back to sendmail_from php.ini setting */",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tif (headers_lc == headers_trim) {",
                "\t\t\tzend_string_release_ex(headers_lc, 0);",
                "\t\t}"
            ],
            "added_lines": []
        }
    },
    {
        "cve_id": "CVE-2018-14524",
        "func_name": "LibreDWG/libredwg/dwg_decode_eed",
        "description": "dwg_decode_eed in decode.c in GNU LibreDWG before 0.6 leads to a double free (in dwg_free_eed in free.c) because it does not properly manage the obj->eed value after a free occurs.",
        "git_url": "https://github.com/LibreDWG/libredwg/commit/9a8b9fb49108bab5d12f3353292f8fd8ea12898f",
        "commit_title": "free: improve eed double-free",
        "commit_text": " Fixes [GH #33], detected by jinyu00",
        "func_before": "static int\ndwg_decode_eed(Bit_Chain * dat, Dwg_Object_Object * obj)\n{\n  BITCODE_BS size;\n  unsigned int idx = 0;\n  int error = 0;\n  Dwg_Data *dwg = obj->dwg;\n\n  obj->num_eed = 0;\n  while ((size = bit_read_BS(dat)))\n    {\n      int i;\n      BITCODE_BS j;\n      BITCODE_RC code = 0;\n      long unsigned int end, offset;\n      long unsigned int sav_byte;\n      Dwg_Object *_obj = &dwg->object[obj->objid];\n\n      LOG_TRACE(\"EED[%u] size: \" FORMAT_BS \"\\n\", idx, size);\n      if (size > _obj->size)\n        {\n          LOG_ERROR(\"Invalid EED size \" FORMAT_BS \" > %u\", size, _obj->size)\n          obj->num_eed = 0;\n          return DWG_ERR_INVALIDEED; /* may continue */\n        }\n\n      if (idx) {\n        obj->eed = (Dwg_Eed*)realloc(obj->eed, (idx+1) * sizeof(Dwg_Eed));\n        memset(&obj->eed[idx], 0, sizeof(Dwg_Eed));\n      } else {\n        obj->eed = (Dwg_Eed*)calloc(1, sizeof(Dwg_Eed));\n      }\n      obj->eed[idx].size = size;\n      error = bit_read_H(dat, &obj->eed[idx].handle);\n      if (error) {\n        LOG_ERROR(\"No EED[%d].handle\", idx);\n        obj->num_eed = 0;\n        free(obj->eed);\n        return error;\n      } else {\n        end = dat->byte + size;\n        LOG_TRACE(\"EED[%u] handle: %d.%d.%lX\\n\", idx,\n                  obj->eed[idx].handle.code, obj->eed[idx].handle.size,\n                  obj->eed[idx].handle.value);\n        if (_obj->supertype == DWG_SUPERTYPE_OBJECT &&\n            _obj->dxfname &&\n            !strcmp(_obj->dxfname, \"MLEADERSTYLE\"))\n          { // check for is_new_format: has extended data for APPID ACAD_MLEADERVER\n            Dwg_Object_Ref ref;\n            ref.obj = NULL;\n            ref.handleref = obj->eed[idx].handle;\n            ref.absolute_ref = 0L;\n            if (dwg_resolve_handleref(&ref, _obj))\n              {\n                Dwg_Object_APPID_CONTROL *appid = &dwg->appid_control;\n                // search absref in APPID_CONTROL apps[]\n                for (j=0; j < appid->num_entries; j++)\n                  {\n                    if ( appid->apps[j]->absolute_ref == ref.absolute_ref )\n                      {\n                        Dwg_Object_MLEADERSTYLE *this = obj->tio.MLEADERSTYLE;\n                        this->is_new_format = 1;\n                        LOG_TRACE(\"EED found ACAD_MLEADERVER %lu: new format\\n\",\n                                  ref.absolute_ref);\n                      }\n                  }\n              }\n          }\n      }\n\n      sav_byte = dat->byte;\n      obj->eed[idx].raw = bit_read_TF(dat, size);\n      LOG_INSANE_TF(obj->eed[idx].raw, size);\n      dat->byte = sav_byte;\n\n      while (dat->byte < end)\n        {\n          int lenc;\n          BITCODE_RS lens;\n\n          obj->eed[idx].data = (Dwg_Eed_Data*)calloc(size + 8, 1);\n          obj->eed[idx].data->code = code = bit_read_RC(dat);\n          LOG_TRACE(\"EED[%u] code: %d\\n\", idx, (int)code);\n          switch (code)\n            {\n            case 0:\n              PRE(R_2007) {\n                obj->eed[idx].data->u.eed_0.length = lenc = bit_read_RC(dat);\n                obj->eed[idx].data->u.eed_0.codepage = bit_read_RS_LE(dat);\n                if (lenc > size-4)\n                  {\n                    LOG_ERROR(\"Invalid EED string len %d, max %d\", lenc, size-4);\n                    dat->byte = end;\n                    break;\n#if 0\n\n                    obj->num_eed = 0;\n                    if (obj->eed[idx].size)\n                      free(obj->eed[idx].raw);\n                    free(obj->eed[idx].data);\n                    free(obj->eed);\n                    dat->byte = end;\n                    return DWG_ERR_VALUEOUTOFBOUNDS; /* may not continue */\n#endif\n                  }\n                /* code:1 + len:1 + cp:2 */\n                bit_read_fixed(dat, obj->eed[idx].data->u.eed_0.string, lenc);\n                obj->eed[idx].data->u.eed_0.string[lenc] = '\\0';\n                LOG_TRACE(\"EED[%u] string: \\\"%s\\\" len=%d cp=%d\\n\", idx,\n                          obj->eed[idx].data->u.eed_0.string, (int)lenc,\n                          (int)obj->eed[idx].data->u.eed_0.codepage);\n              } LATER_VERSIONS {\n                obj->eed[idx].data->u.eed_0_r2007.length = lens = bit_read_RS(dat);\n                /* code:1 + len:2 NUL? */\n                for (j=0; j < MIN(lens,(size-3)/2); j++)\n                  obj->eed[idx].data->u.eed_0_r2007.string[j] = bit_read_RS_LE(dat);\n                //obj->eed[idx].data->u.eed_0_r2007.string[j] = 0; //already calloc'ed\n#ifdef _WIN32\n                LOG_TRACE(\"EED[%u] string: \\\"\" FORMAT_TU \"\\\" len=%d\\n\", idx,\n                          obj->eed[idx].data->u.eed_0_r2007.string, (int)lens);\n#endif\n              }\n              break;\n            case 2:\n              obj->eed[idx].data->u.eed_2.byte = bit_read_RC(dat);\n              LOG_TRACE(\"EED[%u] byte: \" FORMAT_RC \"\\n\", idx,\n                        obj->eed[idx].data->u.eed_2.byte);\n              break;\n            case 3:\n            case 5:\n              obj->eed[idx].data->u.eed_3.layer = bit_read_RL(dat);\n              LOG_TRACE(\"EED[%u] layer/...: \" FORMAT_RL \"\\n\", idx,\n                        obj->eed[idx].data->u.eed_3.layer);\n              break;\n            case 4:\n              obj->eed[idx].data->u.eed_4.length = lenc = bit_read_RC(dat);\n              /* code:1 + len:1 */\n              for (j=0; j < MIN(lenc,size-2); j++)\n                obj->eed[idx].data->u.eed_4.data[j] = bit_read_RC(dat);\n              LOG_TRACE(\"EED[%u] raw: %s\\n\", idx, obj->eed[idx].data->u.eed_4.data);\n              break;\n            case 10: case 11: case 12: case 13: /*case 14: case 15:*/\n              obj->eed[idx].data->u.eed_10.point.x = bit_read_RD(dat);\n              obj->eed[idx].data->u.eed_10.point.y = bit_read_RD(dat);\n              obj->eed[idx].data->u.eed_10.point.z = bit_read_RD(dat);\n              LOG_TRACE(\"EED[%u] 3dpoint: %f, %f, %f\\n\", idx,\n                        obj->eed[idx].data->u.eed_10.point.x,\n                        obj->eed[idx].data->u.eed_10.point.y,\n                        obj->eed[idx].data->u.eed_10.point.z);\n              break;\n            case 40: case 41: case 42: /*case 43: case 44: case 45: case 46:\n            case 51: case 54:*/\n              obj->eed[idx].data->u.eed_40.real = bit_read_RD(dat);\n              LOG_TRACE(\"EED[%u] real: %f\\n\", idx,\n                        obj->eed[idx].data->u.eed_40.real);\n              break;\n            case 70:\n              obj->eed[idx].data->u.eed_70.rs = bit_read_RS(dat);\n              LOG_TRACE(\"EED[%u] short: \" FORMAT_RS \"\\n\", idx,\n                        obj->eed[idx].data->u.eed_70.rs);\n              break;\n            case 71:\n              obj->eed[idx].data->u.eed_71.rl = bit_read_RL(dat);\n              LOG_TRACE(\"EED[%u] long: \" FORMAT_RL \"\\n\", idx,\n                        obj->eed[idx].data->u.eed_71.rl);\n              break;\n            default:\n              LOG_ERROR(\"Unknown EED code %d\", code);\n              dat->byte = end;\n              return DWG_ERR_INVALIDTYPE; /* may continue */\n            }\n#ifdef DEBUG\n          // sanity checks\n          if (code == 0 || code == 4)\n            assert(obj->eed[idx].data->u.eed_0.length <= size-1);\n          if (code == 10) // 3 double\n            assert(size >= 1 + 3*8);\n#endif\n\n          idx++;\n          obj->num_eed++;\n          if (dat->byte < end-1)\n            {\n              size = (long)(end - dat->byte + 1);\n              LOG_INSANE(\"EED[%u] size remaining: %ld\\n\", idx, (long)size);\n\n              obj->eed = (Dwg_Eed*)realloc(obj->eed, (idx+1) * sizeof(Dwg_Eed));\n              obj->eed[idx].handle = obj->eed[idx-1].handle;\n              obj->eed[idx].size = 0;\n              obj->eed[idx].raw = NULL;\n            }\n        }\n      dat->byte = end;\n    }\n  return error;\n}",
        "func": "static int\ndwg_decode_eed(Bit_Chain * dat, Dwg_Object_Object * obj)\n{\n  BITCODE_BS size;\n  unsigned int idx = 0;\n  int error = 0;\n  Dwg_Data *dwg = obj->dwg;\n\n  obj->num_eed = 0;\n  while ((size = bit_read_BS(dat)))\n    {\n      int i;\n      BITCODE_BS j;\n      BITCODE_RC code = 0;\n      long unsigned int end, offset;\n      long unsigned int sav_byte;\n      Dwg_Object *_obj = &dwg->object[obj->objid];\n\n      LOG_TRACE(\"EED[%u] size: \" FORMAT_BS \"\\n\", idx, size);\n      if (size > _obj->size)\n        {\n          LOG_ERROR(\"Invalid EED size \" FORMAT_BS \" > %u\", size, _obj->size)\n          obj->num_eed = 0;\n          return DWG_ERR_INVALIDEED; /* may continue */\n        }\n\n      if (idx) {\n        obj->eed = (Dwg_Eed*)realloc(obj->eed, (idx+1) * sizeof(Dwg_Eed));\n        memset(&obj->eed[idx], 0, sizeof(Dwg_Eed));\n      } else {\n        obj->eed = (Dwg_Eed*)calloc(1, sizeof(Dwg_Eed));\n      }\n      obj->eed[idx].size = size;\n      error = bit_read_H(dat, &obj->eed[idx].handle);\n      if (error) {\n        LOG_ERROR(\"No EED[%d].handle\", idx);\n        obj->num_eed = 0;\n        free(obj->eed);\n        obj->eed = NULL;\n        return error;\n      } else {\n        end = dat->byte + size;\n        LOG_TRACE(\"EED[%u] handle: %d.%d.%lX\\n\", idx,\n                  obj->eed[idx].handle.code, obj->eed[idx].handle.size,\n                  obj->eed[idx].handle.value);\n        if (_obj->supertype == DWG_SUPERTYPE_OBJECT &&\n            _obj->dxfname &&\n            !strcmp(_obj->dxfname, \"MLEADERSTYLE\"))\n          { // check for is_new_format: has extended data for APPID ACAD_MLEADERVER\n            Dwg_Object_Ref ref;\n            ref.obj = NULL;\n            ref.handleref = obj->eed[idx].handle;\n            ref.absolute_ref = 0L;\n            if (dwg_resolve_handleref(&ref, _obj))\n              {\n                Dwg_Object_APPID_CONTROL *appid = &dwg->appid_control;\n                // search absref in APPID_CONTROL apps[]\n                for (j=0; j < appid->num_entries; j++)\n                  {\n                    if ( appid->apps[j]->absolute_ref == ref.absolute_ref )\n                      {\n                        Dwg_Object_MLEADERSTYLE *this = obj->tio.MLEADERSTYLE;\n                        this->is_new_format = 1;\n                        LOG_TRACE(\"EED found ACAD_MLEADERVER %lu: new format\\n\",\n                                  ref.absolute_ref);\n                      }\n                  }\n              }\n          }\n      }\n\n      sav_byte = dat->byte;\n      obj->eed[idx].raw = bit_read_TF(dat, size);\n      LOG_INSANE_TF(obj->eed[idx].raw, size);\n      dat->byte = sav_byte;\n\n      while (dat->byte < end)\n        {\n          int lenc;\n          BITCODE_RS lens;\n\n          obj->eed[idx].data = (Dwg_Eed_Data*)calloc(size + 8, 1);\n          obj->eed[idx].data->code = code = bit_read_RC(dat);\n          LOG_TRACE(\"EED[%u] code: %d\\n\", idx, (int)code);\n          switch (code)\n            {\n            case 0:\n              PRE(R_2007) {\n                obj->eed[idx].data->u.eed_0.length = lenc = bit_read_RC(dat);\n                obj->eed[idx].data->u.eed_0.codepage = bit_read_RS_LE(dat);\n                if (lenc > size-4)\n                  {\n                    LOG_ERROR(\"Invalid EED string len %d, max %d\", lenc, size-4);\n                    dat->byte = end;\n                    break;\n#if 0\n\n                    obj->num_eed = 0;\n                    if (obj->eed[idx].size)\n                      free(obj->eed[idx].raw);\n                    free(obj->eed[idx].data);\n                    free(obj->eed);\n                    obj->eed = NULL;\n                    dat->byte = end;\n                    return DWG_ERR_VALUEOUTOFBOUNDS; /* may not continue */\n#endif\n                  }\n                /* code:1 + len:1 + cp:2 */\n                bit_read_fixed(dat, obj->eed[idx].data->u.eed_0.string, lenc);\n                obj->eed[idx].data->u.eed_0.string[lenc] = '\\0';\n                LOG_TRACE(\"EED[%u] string: \\\"%s\\\" len=%d cp=%d\\n\", idx,\n                          obj->eed[idx].data->u.eed_0.string, (int)lenc,\n                          (int)obj->eed[idx].data->u.eed_0.codepage);\n              } LATER_VERSIONS {\n                obj->eed[idx].data->u.eed_0_r2007.length = lens = bit_read_RS(dat);\n                /* code:1 + len:2 NUL? */\n                for (j=0; j < MIN(lens,(size-3)/2); j++)\n                  obj->eed[idx].data->u.eed_0_r2007.string[j] = bit_read_RS_LE(dat);\n                //obj->eed[idx].data->u.eed_0_r2007.string[j] = 0; //already calloc'ed\n#ifdef _WIN32\n                LOG_TRACE(\"EED[%u] string: \\\"\" FORMAT_TU \"\\\" len=%d\\n\", idx,\n                          obj->eed[idx].data->u.eed_0_r2007.string, (int)lens);\n#endif\n              }\n              break;\n            case 2:\n              obj->eed[idx].data->u.eed_2.byte = bit_read_RC(dat);\n              LOG_TRACE(\"EED[%u] byte: \" FORMAT_RC \"\\n\", idx,\n                        obj->eed[idx].data->u.eed_2.byte);\n              break;\n            case 3:\n            case 5:\n              obj->eed[idx].data->u.eed_3.layer = bit_read_RL(dat);\n              LOG_TRACE(\"EED[%u] layer/...: \" FORMAT_RL \"\\n\", idx,\n                        obj->eed[idx].data->u.eed_3.layer);\n              break;\n            case 4:\n              obj->eed[idx].data->u.eed_4.length = lenc = bit_read_RC(dat);\n              /* code:1 + len:1 */\n              for (j=0; j < MIN(lenc,size-2); j++)\n                obj->eed[idx].data->u.eed_4.data[j] = bit_read_RC(dat);\n              LOG_TRACE(\"EED[%u] raw: %s\\n\", idx, obj->eed[idx].data->u.eed_4.data);\n              break;\n            case 10: case 11: case 12: case 13: /*case 14: case 15:*/\n              obj->eed[idx].data->u.eed_10.point.x = bit_read_RD(dat);\n              obj->eed[idx].data->u.eed_10.point.y = bit_read_RD(dat);\n              obj->eed[idx].data->u.eed_10.point.z = bit_read_RD(dat);\n              LOG_TRACE(\"EED[%u] 3dpoint: %f, %f, %f\\n\", idx,\n                        obj->eed[idx].data->u.eed_10.point.x,\n                        obj->eed[idx].data->u.eed_10.point.y,\n                        obj->eed[idx].data->u.eed_10.point.z);\n              break;\n            case 40: case 41: case 42: /*case 43: case 44: case 45: case 46:\n            case 51: case 54:*/\n              obj->eed[idx].data->u.eed_40.real = bit_read_RD(dat);\n              LOG_TRACE(\"EED[%u] real: %f\\n\", idx,\n                        obj->eed[idx].data->u.eed_40.real);\n              break;\n            case 70:\n              obj->eed[idx].data->u.eed_70.rs = bit_read_RS(dat);\n              LOG_TRACE(\"EED[%u] short: \" FORMAT_RS \"\\n\", idx,\n                        obj->eed[idx].data->u.eed_70.rs);\n              break;\n            case 71:\n              obj->eed[idx].data->u.eed_71.rl = bit_read_RL(dat);\n              LOG_TRACE(\"EED[%u] long: \" FORMAT_RL \"\\n\", idx,\n                        obj->eed[idx].data->u.eed_71.rl);\n              break;\n            default:\n              LOG_ERROR(\"Unknown EED code %d\", code);\n              dat->byte = end;\n              return DWG_ERR_INVALIDTYPE; /* may continue */\n            }\n#ifdef DEBUG\n          // sanity checks\n          if (code == 0 || code == 4)\n            assert(obj->eed[idx].data->u.eed_0.length <= size-1);\n          if (code == 10) // 3 double\n            assert(size >= 1 + 3*8);\n#endif\n\n          idx++;\n          obj->num_eed++;\n          if (dat->byte < end-1)\n            {\n              size = (long)(end - dat->byte + 1);\n              LOG_INSANE(\"EED[%u] size remaining: %ld\\n\", idx, (long)size);\n\n              obj->eed = (Dwg_Eed*)realloc(obj->eed, (idx+1) * sizeof(Dwg_Eed));\n              obj->eed[idx].handle = obj->eed[idx-1].handle;\n              obj->eed[idx].size = 0;\n              obj->eed[idx].raw = NULL;\n            }\n        }\n      dat->byte = end;\n    }\n  return error;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -36,6 +36,7 @@\n         LOG_ERROR(\"No EED[%d].handle\", idx);\n         obj->num_eed = 0;\n         free(obj->eed);\n+        obj->eed = NULL;\n         return error;\n       } else {\n         end = dat->byte + size;\n@@ -99,6 +100,7 @@\n                       free(obj->eed[idx].raw);\n                     free(obj->eed[idx].data);\n                     free(obj->eed);\n+                    obj->eed = NULL;\n                     dat->byte = end;\n                     return DWG_ERR_VALUEOUTOFBOUNDS; /* may not continue */\n #endif",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "        obj->eed = NULL;",
                "                    obj->eed = NULL;"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-14524",
        "func_name": "LibreDWG/libredwg/dwg_free_eed",
        "description": "dwg_decode_eed in decode.c in GNU LibreDWG before 0.6 leads to a double free (in dwg_free_eed in free.c) because it does not properly manage the obj->eed value after a free occurs.",
        "git_url": "https://github.com/LibreDWG/libredwg/commit/9a8b9fb49108bab5d12f3353292f8fd8ea12898f",
        "commit_title": "free: improve eed double-free",
        "commit_text": " Fixes [GH #33], detected by jinyu00",
        "func_before": "static void\ndwg_free_eed(Dwg_Object* obj)\n{\n  unsigned int i;\n  if (obj->supertype == DWG_SUPERTYPE_OBJECT) {\n    Dwg_Object_Object* _obj = obj->tio.object;\n    for (i=0; i < _obj->num_eed; i++) {\n      if (_obj->eed[i].size)\n        FREE_IF(_obj->eed[i].raw);\n      if (_obj->eed[i].data)\n        FREE_IF(_obj->eed[i].data);\n    }\n    FREE_IF(_obj->eed);\n  }\n  else if (obj->supertype == DWG_SUPERTYPE_ENTITY) {\n    Dwg_Object_Entity* _obj = obj->tio.entity;\n    for (i=0; i < _obj->num_eed; i++) {\n      if (_obj->eed[i].size)\n        FREE_IF(_obj->eed[i].raw);\n      if (_obj->eed[i].data)\n        FREE_IF(_obj->eed[i].data);\n    }\n    FREE_IF(_obj->eed);\n  }\n}",
        "func": "static void\ndwg_free_eed(Dwg_Object* obj)\n{\n  unsigned int i;\n  if (obj->supertype == DWG_SUPERTYPE_OBJECT) {\n    Dwg_Object_Object* _obj = obj->tio.object;\n    for (i=0; i < _obj->num_eed; i++) {\n      if (_obj->eed[i].size)\n        FREE_IF(_obj->eed[i].raw);\n      FREE_IF(_obj->eed[i].data);\n    }\n    FREE_IF(_obj->eed);\n  }\n  else if (obj->supertype == DWG_SUPERTYPE_ENTITY) {\n    Dwg_Object_Entity* _obj = obj->tio.entity;\n    for (i=0; i < _obj->num_eed; i++) {\n      if (_obj->eed[i].size)\n        FREE_IF(_obj->eed[i].raw);\n      FREE_IF(_obj->eed[i].data);\n    }\n    FREE_IF(_obj->eed);\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -7,8 +7,7 @@\n     for (i=0; i < _obj->num_eed; i++) {\n       if (_obj->eed[i].size)\n         FREE_IF(_obj->eed[i].raw);\n-      if (_obj->eed[i].data)\n-        FREE_IF(_obj->eed[i].data);\n+      FREE_IF(_obj->eed[i].data);\n     }\n     FREE_IF(_obj->eed);\n   }\n@@ -17,8 +16,7 @@\n     for (i=0; i < _obj->num_eed; i++) {\n       if (_obj->eed[i].size)\n         FREE_IF(_obj->eed[i].raw);\n-      if (_obj->eed[i].data)\n-        FREE_IF(_obj->eed[i].data);\n+      FREE_IF(_obj->eed[i].data);\n     }\n     FREE_IF(_obj->eed);\n   }",
        "diff_line_info": {
            "deleted_lines": [
                "      if (_obj->eed[i].data)",
                "        FREE_IF(_obj->eed[i].data);",
                "      if (_obj->eed[i].data)",
                "        FREE_IF(_obj->eed[i].data);"
            ],
            "added_lines": [
                "      FREE_IF(_obj->eed[i].data);",
                "      FREE_IF(_obj->eed[i].data);"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-1000216",
        "func_name": "DaveGamble/cJSON/print_value",
        "description": "Dave Gamble cJSON version 1.7.2 and earlier contains a CWE-415: Double Free vulnerability in cJSON library that can result in Possible crash or RCE. This attack appear to be exploitable via Attacker must be able to force victim to print JSON data, depending on how cJSON library is used this could be either local or over a network. This vulnerability appears to have been fixed in 1.7.3.",
        "git_url": "https://github.com/DaveGamble/cJSON/commit/d514bb866ef9d7d8ab394fbce5168c3b45f7c504",
        "commit_title": "Fix #241, potential double free",
        "commit_text": "",
        "func_before": "static cJSON_bool print_value(const cJSON * const item, printbuffer * const output_buffer)\n{\n    unsigned char *output = NULL;\n\n    if ((item == NULL) || (output_buffer == NULL))\n    {\n        return false;\n    }\n\n    switch ((item->type) & 0xFF)\n    {\n        case cJSON_NULL:\n            output = ensure(output_buffer, 5);\n            if (output == NULL)\n            {\n                return false;\n            }\n            strcpy((char*)output, \"null\");\n            return true;\n\n        case cJSON_False:\n            output = ensure(output_buffer, 6);\n            if (output == NULL)\n            {\n                return false;\n            }\n            strcpy((char*)output, \"false\");\n            return true;\n\n        case cJSON_True:\n            output = ensure(output_buffer, 5);\n            if (output == NULL)\n            {\n                return false;\n            }\n            strcpy((char*)output, \"true\");\n            return true;\n\n        case cJSON_Number:\n            return print_number(item, output_buffer);\n\n        case cJSON_Raw:\n        {\n            size_t raw_length = 0;\n            if (item->valuestring == NULL)\n            {\n                if (!output_buffer->noalloc)\n                {\n                    output_buffer->hooks.deallocate(output_buffer->buffer);\n                }\n                return false;\n            }\n\n            raw_length = strlen(item->valuestring) + sizeof(\"\");\n            output = ensure(output_buffer, raw_length);\n            if (output == NULL)\n            {\n                return false;\n            }\n            memcpy(output, item->valuestring, raw_length);\n            return true;\n        }\n\n        case cJSON_String:\n            return print_string(item, output_buffer);\n\n        case cJSON_Array:\n            return print_array(item, output_buffer);\n\n        case cJSON_Object:\n            return print_object(item, output_buffer);\n\n        default:\n            return false;\n    }\n}",
        "func": "static cJSON_bool print_value(const cJSON * const item, printbuffer * const output_buffer)\n{\n    unsigned char *output = NULL;\n\n    if ((item == NULL) || (output_buffer == NULL))\n    {\n        return false;\n    }\n\n    switch ((item->type) & 0xFF)\n    {\n        case cJSON_NULL:\n            output = ensure(output_buffer, 5);\n            if (output == NULL)\n            {\n                return false;\n            }\n            strcpy((char*)output, \"null\");\n            return true;\n\n        case cJSON_False:\n            output = ensure(output_buffer, 6);\n            if (output == NULL)\n            {\n                return false;\n            }\n            strcpy((char*)output, \"false\");\n            return true;\n\n        case cJSON_True:\n            output = ensure(output_buffer, 5);\n            if (output == NULL)\n            {\n                return false;\n            }\n            strcpy((char*)output, \"true\");\n            return true;\n\n        case cJSON_Number:\n            return print_number(item, output_buffer);\n\n        case cJSON_Raw:\n        {\n            size_t raw_length = 0;\n            if (item->valuestring == NULL)\n            {\n                return false;\n            }\n\n            raw_length = strlen(item->valuestring) + sizeof(\"\");\n            output = ensure(output_buffer, raw_length);\n            if (output == NULL)\n            {\n                return false;\n            }\n            memcpy(output, item->valuestring, raw_length);\n            return true;\n        }\n\n        case cJSON_String:\n            return print_string(item, output_buffer);\n\n        case cJSON_Array:\n            return print_array(item, output_buffer);\n\n        case cJSON_Object:\n            return print_object(item, output_buffer);\n\n        default:\n            return false;\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -44,10 +44,6 @@\n             size_t raw_length = 0;\n             if (item->valuestring == NULL)\n             {\n-                if (!output_buffer->noalloc)\n-                {\n-                    output_buffer->hooks.deallocate(output_buffer->buffer);\n-                }\n                 return false;\n             }\n ",
        "diff_line_info": {
            "deleted_lines": [
                "                if (!output_buffer->noalloc)",
                "                {",
                "                    output_buffer->hooks.deallocate(output_buffer->buffer);",
                "                }"
            ],
            "added_lines": []
        }
    },
    {
        "cve_id": "CVE-2018-16391",
        "func_name": "OpenSC/cac_get_serial_nr_from_CUID",
        "description": "Several buffer overflows when handling responses from a Muscle Card in muscle_list_files in libopensc/card-muscle.c in OpenSC before 0.19.0-rc1 could be used by attackers able to supply crafted smartcards to cause a denial of service (application crash) or possibly have unspecified other impact.",
        "git_url": "https://github.com/OpenSC/OpenSC/commit/360e95d45ac4123255a4c796db96337f332160ad",
        "commit_title": "fixed out of bounds writes",
        "commit_text": " Thanks to Eric Sesterhenn from X41 D-SEC GmbH for reporting the problems.",
        "func_before": "static int cac_get_serial_nr_from_CUID(sc_card_t* card, sc_serial_number_t* serial)\n{\n\tcac_private_data_t * priv = CAC_DATA(card);\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_NORMAL);\n        if (card->serialnr.len)   {\n                *serial = card->serialnr;\n                SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_SUCCESS);\n        }\n\tif (priv->cac_id_len) {\n\t\tserial->len = MIN(priv->cac_id_len, SC_MAX_SERIALNR);\n\t\tmemcpy(serial->value, priv->cac_id, priv->cac_id_len);\n\t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_SUCCESS);\n\t}\n\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_FILE_NOT_FOUND);\n}",
        "func": "static int cac_get_serial_nr_from_CUID(sc_card_t* card, sc_serial_number_t* serial)\n{\n\tcac_private_data_t * priv = CAC_DATA(card);\n\n\tSC_FUNC_CALLED(card->ctx, SC_LOG_DEBUG_NORMAL);\n        if (card->serialnr.len)   {\n                *serial = card->serialnr;\n                SC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_SUCCESS);\n        }\n\tif (priv->cac_id_len) {\n\t\tserial->len = MIN(priv->cac_id_len, SC_MAX_SERIALNR);\n\t\tmemcpy(serial->value, priv->cac_id, serial->len);\n\t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_SUCCESS);\n\t}\n\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_FILE_NOT_FOUND);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -9,7 +9,7 @@\n         }\n \tif (priv->cac_id_len) {\n \t\tserial->len = MIN(priv->cac_id_len, SC_MAX_SERIALNR);\n-\t\tmemcpy(serial->value, priv->cac_id, priv->cac_id_len);\n+\t\tmemcpy(serial->value, priv->cac_id, serial->len);\n \t\tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_SUCCESS);\n \t}\n \tSC_FUNC_RETURN(card->ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_FILE_NOT_FOUND);",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tmemcpy(serial->value, priv->cac_id, priv->cac_id_len);"
            ],
            "added_lines": [
                "\t\tmemcpy(serial->value, priv->cac_id, serial->len);"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-16391",
        "func_name": "OpenSC/decrypt_response",
        "description": "Several buffer overflows when handling responses from a Muscle Card in muscle_list_files in libopensc/card-muscle.c in OpenSC before 0.19.0-rc1 could be used by attackers able to supply crafted smartcards to cause a denial of service (application crash) or possibly have unspecified other impact.",
        "git_url": "https://github.com/OpenSC/OpenSC/commit/360e95d45ac4123255a4c796db96337f332160ad",
        "commit_title": "fixed out of bounds writes",
        "commit_text": " Thanks to Eric Sesterhenn from X41 D-SEC GmbH for reporting the problems.",
        "func_before": "static int\ndecrypt_response(struct sc_card *card, unsigned char *in, size_t inlen, unsigned char *out, size_t * out_len)\n{\n\tsize_t cipher_len;\n\tsize_t i;\n\tunsigned char iv[16] = { 0 };\n\tunsigned char plaintext[4096] = { 0 };\n\tepass2003_exdata *exdata = NULL;\n\n\tif (!card->drv_data) \n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\n\texdata = (epass2003_exdata *)card->drv_data;\n\n\t/* no cipher */\n\tif (in[0] == 0x99)\n\t\treturn 0;\n\n\t/* parse cipher length */\n\tif (0x01 == in[2] && 0x82 != in[1]) {\n\t\tcipher_len = in[1];\n\t\ti = 3;\n\t}\n\telse if (0x01 == in[3] && 0x81 == in[1]) {\n\t\tcipher_len = in[2];\n\t\ti = 4;\n\t}\n\telse if (0x01 == in[4] && 0x82 == in[1]) {\n\t\tcipher_len = in[2] * 0x100;\n\t\tcipher_len += in[3];\n\t\ti = 5;\n\t}\n\telse {\n\t\treturn -1;\n\t}\n\n\tif (cipher_len < 2 || i+cipher_len > inlen || cipher_len > sizeof plaintext)\n\t\treturn -1;\n\n\t/* decrypt */\n\tif (KEY_TYPE_AES == exdata->smtype)\n\t\taes128_decrypt_cbc(exdata->sk_enc, 16, iv, &in[i], cipher_len - 1, plaintext);\n\telse\n\t\tdes3_decrypt_cbc(exdata->sk_enc, 16, iv, &in[i], cipher_len - 1, plaintext);\n\n\t/* unpadding */\n\twhile (0x80 != plaintext[cipher_len - 2] && (cipher_len - 2 > 0))\n\t\tcipher_len--;\n\n\tif (2 == cipher_len)\n\t\treturn -1;\n\n\tmemcpy(out, plaintext, cipher_len - 2);\n\t*out_len = cipher_len - 2;\n\treturn 0;\n}",
        "func": "static int\ndecrypt_response(struct sc_card *card, unsigned char *in, size_t inlen, unsigned char *out, size_t * out_len)\n{\n\tsize_t cipher_len;\n\tsize_t i;\n\tunsigned char iv[16] = { 0 };\n\tunsigned char plaintext[4096] = { 0 };\n\tepass2003_exdata *exdata = NULL;\n\n\tif (!card->drv_data) \n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\n\texdata = (epass2003_exdata *)card->drv_data;\n\n\t/* no cipher */\n\tif (in[0] == 0x99)\n\t\treturn 0;\n\n\t/* parse cipher length */\n\tif (0x01 == in[2] && 0x82 != in[1]) {\n\t\tcipher_len = in[1];\n\t\ti = 3;\n\t}\n\telse if (0x01 == in[3] && 0x81 == in[1]) {\n\t\tcipher_len = in[2];\n\t\ti = 4;\n\t}\n\telse if (0x01 == in[4] && 0x82 == in[1]) {\n\t\tcipher_len = in[2] * 0x100;\n\t\tcipher_len += in[3];\n\t\ti = 5;\n\t}\n\telse {\n\t\treturn -1;\n\t}\n\n\tif (cipher_len < 2 || i+cipher_len > inlen || cipher_len > sizeof plaintext)\n\t\treturn -1;\n\n\t/* decrypt */\n\tif (KEY_TYPE_AES == exdata->smtype)\n\t\taes128_decrypt_cbc(exdata->sk_enc, 16, iv, &in[i], cipher_len - 1, plaintext);\n\telse\n\t\tdes3_decrypt_cbc(exdata->sk_enc, 16, iv, &in[i], cipher_len - 1, plaintext);\n\n\t/* unpadding */\n\twhile (0x80 != plaintext[cipher_len - 2] && (cipher_len - 2 > 0))\n\t\tcipher_len--;\n\n\tif (2 == cipher_len || *out_len < cipher_len - 2)\n\t\treturn -1;\n\n\tmemcpy(out, plaintext, cipher_len - 2);\n\t*out_len = cipher_len - 2;\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -47,7 +47,7 @@\n \twhile (0x80 != plaintext[cipher_len - 2] && (cipher_len - 2 > 0))\n \t\tcipher_len--;\n \n-\tif (2 == cipher_len)\n+\tif (2 == cipher_len || *out_len < cipher_len - 2)\n \t\treturn -1;\n \n \tmemcpy(out, plaintext, cipher_len - 2);",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (2 == cipher_len)"
            ],
            "added_lines": [
                "\tif (2 == cipher_len || *out_len < cipher_len - 2)"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-16391",
        "func_name": "OpenSC/epass2003_sm_unwrap_apdu",
        "description": "Several buffer overflows when handling responses from a Muscle Card in muscle_list_files in libopensc/card-muscle.c in OpenSC before 0.19.0-rc1 could be used by attackers able to supply crafted smartcards to cause a denial of service (application crash) or possibly have unspecified other impact.",
        "git_url": "https://github.com/OpenSC/OpenSC/commit/360e95d45ac4123255a4c796db96337f332160ad",
        "commit_title": "fixed out of bounds writes",
        "commit_text": " Thanks to Eric Sesterhenn from X41 D-SEC GmbH for reporting the problems.",
        "func_before": "static int\nepass2003_sm_unwrap_apdu(struct sc_card *card, struct sc_apdu *sm, struct sc_apdu *plain)\n{\n\tint r;\n\tsize_t len = 0;\n\tepass2003_exdata *exdata = NULL;\n\n\tif (!card->drv_data) \n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\n\texdata = (epass2003_exdata *)card->drv_data;\n\n\tLOG_FUNC_CALLED(card->ctx);\n\n\tr = sc_check_sw(card, sm->sw1, sm->sw2);\n\tif (r == SC_SUCCESS) {\n\t\tif (exdata->sm) {\n\t\t\tif (0 != decrypt_response(card, sm->resp, sm->resplen, plain->resp, &len))\n\t\t\t\treturn SC_ERROR_CARD_CMD_FAILED;\n\t\t}\n\t\telse {\n\t\t\tmemcpy(plain->resp, sm->resp, sm->resplen);\n\t\t\tlen = sm->resplen;\n\t\t}\n\t}\n\n\tplain->resplen = len;\n\tplain->sw1 = sm->sw1;\n\tplain->sw2 = sm->sw2;\n\n\tsc_log(card->ctx,\n\t       \"unwrapped APDU: resplen %\"SC_FORMAT_LEN_SIZE_T\"u, SW %02X%02X\",\n\t       plain->resplen, plain->sw1, plain->sw2);\n\tLOG_FUNC_RETURN(card->ctx, SC_SUCCESS);\n}",
        "func": "static int\nepass2003_sm_unwrap_apdu(struct sc_card *card, struct sc_apdu *sm, struct sc_apdu *plain)\n{\n\tint r;\n\tsize_t len = 0;\n\tepass2003_exdata *exdata = NULL;\n\n\tif (!card->drv_data) \n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\n\texdata = (epass2003_exdata *)card->drv_data;\n\n\tLOG_FUNC_CALLED(card->ctx);\n\n\tr = sc_check_sw(card, sm->sw1, sm->sw2);\n\tif (r == SC_SUCCESS) {\n\t\tif (exdata->sm) {\n\t\t\tlen = plain->resplen;\n\t\t\tif (0 != decrypt_response(card, sm->resp, sm->resplen, plain->resp, &len))\n\t\t\t\treturn SC_ERROR_CARD_CMD_FAILED;\n\t\t}\n\t\telse {\n\t\t\tmemcpy(plain->resp, sm->resp, sm->resplen);\n\t\t\tlen = sm->resplen;\n\t\t}\n\t}\n\n\tplain->resplen = len;\n\tplain->sw1 = sm->sw1;\n\tplain->sw2 = sm->sw2;\n\n\tsc_log(card->ctx,\n\t       \"unwrapped APDU: resplen %\"SC_FORMAT_LEN_SIZE_T\"u, SW %02X%02X\",\n\t       plain->resplen, plain->sw1, plain->sw2);\n\tLOG_FUNC_RETURN(card->ctx, SC_SUCCESS);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -15,6 +15,7 @@\n \tr = sc_check_sw(card, sm->sw1, sm->sw2);\n \tif (r == SC_SUCCESS) {\n \t\tif (exdata->sm) {\n+\t\t\tlen = plain->resplen;\n \t\t\tif (0 != decrypt_response(card, sm->resp, sm->resplen, plain->resp, &len))\n \t\t\t\treturn SC_ERROR_CARD_CMD_FAILED;\n \t\t}",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\t\tlen = plain->resplen;"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-16391",
        "func_name": "OpenSC/tcos_select_file",
        "description": "Several buffer overflows when handling responses from a Muscle Card in muscle_list_files in libopensc/card-muscle.c in OpenSC before 0.19.0-rc1 could be used by attackers able to supply crafted smartcards to cause a denial of service (application crash) or possibly have unspecified other impact.",
        "git_url": "https://github.com/OpenSC/OpenSC/commit/360e95d45ac4123255a4c796db96337f332160ad",
        "commit_title": "fixed out of bounds writes",
        "commit_text": " Thanks to Eric Sesterhenn from X41 D-SEC GmbH for reporting the problems.",
        "func_before": "static int tcos_select_file(sc_card_t *card,\n\t\t\t    const sc_path_t *in_path,\n\t\t\t    sc_file_t **file_out)\n{\n\tsc_context_t *ctx;\n\tsc_apdu_t apdu;\n\tsc_file_t *file=NULL;\n\tu8 buf[SC_MAX_APDU_BUFFER_SIZE], pathbuf[SC_MAX_PATH_SIZE], *path = pathbuf;\n\tunsigned int i;\n\tint r, pathlen;\n\n\tassert(card != NULL && in_path != NULL);\n\tctx=card->ctx;\n\tmemcpy(path, in_path->value, in_path->len);\n\tpathlen = in_path->len;\n\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_4_SHORT, 0xA4, 0, 0x04);\n\t\n\tswitch (in_path->type) {\n\tcase SC_PATH_TYPE_FILE_ID:\n\t\tif (pathlen != 2) return SC_ERROR_INVALID_ARGUMENTS;\n\t\t/* fall through */\n\tcase SC_PATH_TYPE_FROM_CURRENT:\n\t\tapdu.p1 = 9;\n\t\tbreak;\n\tcase SC_PATH_TYPE_DF_NAME:\n\t\tapdu.p1 = 4;\n\t\tbreak;\n\tcase SC_PATH_TYPE_PATH:\n\t\tapdu.p1 = 8;\n\t\tif (pathlen >= 2 && memcmp(path, \"\\x3F\\x00\", 2) == 0) path += 2, pathlen -= 2;\n\t\tif (pathlen == 0) apdu.p1 = 0;\n\t\tbreak;\n\tcase SC_PATH_TYPE_PARENT:\n\t\tapdu.p1 = 3;\n\t\tpathlen = 0;\n\t\tbreak;\n\tdefault:\n\t\tSC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_INVALID_ARGUMENTS);\n\t}\n\tif( pathlen == 0 ) apdu.cse = SC_APDU_CASE_2_SHORT;\n\n\tapdu.lc = pathlen;\n\tapdu.data = path;\n\tapdu.datalen = pathlen;\n\n\tif (file_out != NULL) {\n\t\tapdu.resp = buf;\n\t\tapdu.resplen = sizeof(buf);\n\t\tapdu.le = 256;\n\t} else {\n\t\tapdu.resplen = 0;\n\t\tapdu.le = 0; \n\t\tapdu.p2 = 0x0C; \n\t\tapdu.cse = (pathlen == 0) ? SC_APDU_CASE_1 : SC_APDU_CASE_3_SHORT;\n\t}\n\n\tr = sc_transmit_apdu(card, &apdu);\n\tSC_TEST_RET(ctx, SC_LOG_DEBUG_NORMAL, r, \"APDU transmit failed\");\n\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tif (r || file_out == NULL) SC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, r);\n\n\tif (apdu.resplen < 1 || apdu.resp[0] != 0x62){\n\t\tsc_debug(ctx, SC_LOG_DEBUG_NORMAL, \"received invalid template %02X\\n\", apdu.resp[0]);\n\t\tSC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_UNKNOWN_DATA_RECEIVED);\n\t}\n\n\tfile = sc_file_new();\n\tif (file == NULL) SC_FUNC_RETURN(ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_OUT_OF_MEMORY);\n\t*file_out = file;\n\tfile->path = *in_path;\n\n\tfor(i=2; i+1<apdu.resplen && i+1+apdu.resp[i+1]<apdu.resplen; i+=2+apdu.resp[i+1]){\n\t\tint j, len=apdu.resp[i+1];\n\t\tunsigned char type=apdu.resp[i], *d=apdu.resp+i+2;\n\n\t\tswitch (type) {\n\t\tcase 0x80:\n\t\tcase 0x81:\n\t\t\tfile->size=0;\n\t\t\tfor(j=0; j<len; ++j) file->size = (file->size<<8) | d[j];\n\t\t\tbreak;\n\t\tcase 0x82:\n\t\t\tfile->shareable = (d[0] & 0x40) ? 1 : 0;\n\t\t\tfile->ef_structure = d[0] & 7;\n\t\t\tswitch ((d[0]>>3) & 7) {\n\t\t\tcase 0: file->type = SC_FILE_TYPE_WORKING_EF; break;\n\t\t\tcase 7: file->type = SC_FILE_TYPE_DF; break;\n\t\t\tdefault:\n\t\t\t\tsc_debug(ctx, SC_LOG_DEBUG_NORMAL, \"invalid file type %02X in file descriptor\\n\", d[0]);\n\t\t\t\tSC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_UNKNOWN_DATA_RECEIVED);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x83:\n\t\t\tfile->id = (d[0]<<8) | d[1];\n\t\t\tbreak;\n\t\tcase 0x84:\n\t\t\tmemcpy(file->name, d, len);\n\t\t\tfile->namelen = len;\n\t\t\tbreak;\n\t\tcase 0x86:\n\t\t\tsc_file_set_sec_attr(file, d, len); \n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (len>0) sc_file_set_prop_attr(file, d, len); \n\t\t}\n\t}\n\tfile->magic = SC_FILE_MAGIC;\n\n\tparse_sec_attr(card, file, file->sec_attr, file->sec_attr_len);\n\n\treturn 0;\n}",
        "func": "static int tcos_select_file(sc_card_t *card,\n\t\t\t    const sc_path_t *in_path,\n\t\t\t    sc_file_t **file_out)\n{\n\tsc_context_t *ctx;\n\tsc_apdu_t apdu;\n\tsc_file_t *file=NULL;\n\tu8 buf[SC_MAX_APDU_BUFFER_SIZE], pathbuf[SC_MAX_PATH_SIZE], *path = pathbuf;\n\tunsigned int i;\n\tint r, pathlen;\n\n\tassert(card != NULL && in_path != NULL);\n\tctx=card->ctx;\n\tmemcpy(path, in_path->value, in_path->len);\n\tpathlen = in_path->len;\n\n\tsc_format_apdu(card, &apdu, SC_APDU_CASE_4_SHORT, 0xA4, 0, 0x04);\n\t\n\tswitch (in_path->type) {\n\tcase SC_PATH_TYPE_FILE_ID:\n\t\tif (pathlen != 2) return SC_ERROR_INVALID_ARGUMENTS;\n\t\t/* fall through */\n\tcase SC_PATH_TYPE_FROM_CURRENT:\n\t\tapdu.p1 = 9;\n\t\tbreak;\n\tcase SC_PATH_TYPE_DF_NAME:\n\t\tapdu.p1 = 4;\n\t\tbreak;\n\tcase SC_PATH_TYPE_PATH:\n\t\tapdu.p1 = 8;\n\t\tif (pathlen >= 2 && memcmp(path, \"\\x3F\\x00\", 2) == 0) path += 2, pathlen -= 2;\n\t\tif (pathlen == 0) apdu.p1 = 0;\n\t\tbreak;\n\tcase SC_PATH_TYPE_PARENT:\n\t\tapdu.p1 = 3;\n\t\tpathlen = 0;\n\t\tbreak;\n\tdefault:\n\t\tSC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_INVALID_ARGUMENTS);\n\t}\n\tif( pathlen == 0 ) apdu.cse = SC_APDU_CASE_2_SHORT;\n\n\tapdu.lc = pathlen;\n\tapdu.data = path;\n\tapdu.datalen = pathlen;\n\n\tif (file_out != NULL) {\n\t\tapdu.resp = buf;\n\t\tapdu.resplen = sizeof(buf);\n\t\tapdu.le = 256;\n\t} else {\n\t\tapdu.resplen = 0;\n\t\tapdu.le = 0; \n\t\tapdu.p2 = 0x0C; \n\t\tapdu.cse = (pathlen == 0) ? SC_APDU_CASE_1 : SC_APDU_CASE_3_SHORT;\n\t}\n\n\tr = sc_transmit_apdu(card, &apdu);\n\tSC_TEST_RET(ctx, SC_LOG_DEBUG_NORMAL, r, \"APDU transmit failed\");\n\tr = sc_check_sw(card, apdu.sw1, apdu.sw2);\n\tif (r || file_out == NULL) SC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, r);\n\n\tif (apdu.resplen < 1 || apdu.resp[0] != 0x62){\n\t\tsc_debug(ctx, SC_LOG_DEBUG_NORMAL, \"received invalid template %02X\\n\", apdu.resp[0]);\n\t\tSC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_UNKNOWN_DATA_RECEIVED);\n\t}\n\n\tfile = sc_file_new();\n\tif (file == NULL) SC_FUNC_RETURN(ctx, SC_LOG_DEBUG_NORMAL, SC_ERROR_OUT_OF_MEMORY);\n\t*file_out = file;\n\tfile->path = *in_path;\n\n\tfor(i=2; i+1<apdu.resplen && i+1+apdu.resp[i+1]<apdu.resplen; i+=2+apdu.resp[i+1]){\n\t\tsize_t j, len=apdu.resp[i+1];\n\t\tunsigned char type=apdu.resp[i], *d=apdu.resp+i+2;\n\n\t\tswitch (type) {\n\t\tcase 0x80:\n\t\tcase 0x81:\n\t\t\tfile->size=0;\n\t\t\tfor(j=0; j<len; ++j) file->size = (file->size<<8) | d[j];\n\t\t\tbreak;\n\t\tcase 0x82:\n\t\t\tfile->shareable = (d[0] & 0x40) ? 1 : 0;\n\t\t\tfile->ef_structure = d[0] & 7;\n\t\t\tswitch ((d[0]>>3) & 7) {\n\t\t\tcase 0: file->type = SC_FILE_TYPE_WORKING_EF; break;\n\t\t\tcase 7: file->type = SC_FILE_TYPE_DF; break;\n\t\t\tdefault:\n\t\t\t\tsc_debug(ctx, SC_LOG_DEBUG_NORMAL, \"invalid file type %02X in file descriptor\\n\", d[0]);\n\t\t\t\tSC_FUNC_RETURN(ctx, SC_LOG_DEBUG_VERBOSE, SC_ERROR_UNKNOWN_DATA_RECEIVED);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 0x83:\n\t\t\tfile->id = (d[0]<<8) | d[1];\n\t\t\tbreak;\n\t\tcase 0x84:\n\t\t\tfile->namelen = MIN(sizeof file->name, len);\n\t\t\tmemcpy(file->name, d, file->namelen);\n\t\t\tbreak;\n\t\tcase 0x86:\n\t\t\tsc_file_set_sec_attr(file, d, len); \n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (len>0) sc_file_set_prop_attr(file, d, len); \n\t\t}\n\t}\n\tfile->magic = SC_FILE_MAGIC;\n\n\tparse_sec_attr(card, file, file->sec_attr, file->sec_attr_len);\n\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -71,7 +71,7 @@\n \tfile->path = *in_path;\n \n \tfor(i=2; i+1<apdu.resplen && i+1+apdu.resp[i+1]<apdu.resplen; i+=2+apdu.resp[i+1]){\n-\t\tint j, len=apdu.resp[i+1];\n+\t\tsize_t j, len=apdu.resp[i+1];\n \t\tunsigned char type=apdu.resp[i], *d=apdu.resp+i+2;\n \n \t\tswitch (type) {\n@@ -95,8 +95,8 @@\n \t\t\tfile->id = (d[0]<<8) | d[1];\n \t\t\tbreak;\n \t\tcase 0x84:\n-\t\t\tmemcpy(file->name, d, len);\n-\t\t\tfile->namelen = len;\n+\t\t\tfile->namelen = MIN(sizeof file->name, len);\n+\t\t\tmemcpy(file->name, d, file->namelen);\n \t\t\tbreak;\n \t\tcase 0x86:\n \t\t\tsc_file_set_sec_attr(file, d, len); ",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tint j, len=apdu.resp[i+1];",
                "\t\t\tmemcpy(file->name, d, len);",
                "\t\t\tfile->namelen = len;"
            ],
            "added_lines": [
                "\t\tsize_t j, len=apdu.resp[i+1];",
                "\t\t\tfile->namelen = MIN(sizeof file->name, len);",
                "\t\t\tmemcpy(file->name, d, file->namelen);"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-16391",
        "func_name": "OpenSC/gemsafe_get_cert_len",
        "description": "Several buffer overflows when handling responses from a Muscle Card in muscle_list_files in libopensc/card-muscle.c in OpenSC before 0.19.0-rc1 could be used by attackers able to supply crafted smartcards to cause a denial of service (application crash) or possibly have unspecified other impact.",
        "git_url": "https://github.com/OpenSC/OpenSC/commit/360e95d45ac4123255a4c796db96337f332160ad",
        "commit_title": "fixed out of bounds writes",
        "commit_text": " Thanks to Eric Sesterhenn from X41 D-SEC GmbH for reporting the problems.",
        "func_before": "static int gemsafe_get_cert_len(sc_card_t *card)\n{\n\tint r;\n\tu8  ibuf[GEMSAFE_MAX_OBJLEN];\n\tu8 *iptr;\n\tstruct sc_path path;\n\tstruct sc_file *file;\n\tsize_t objlen, certlen;\n\tunsigned int ind, i=0;\n\n\tsc_format_path(GEMSAFE_PATH, &path);\n\tr = sc_select_file(card, &path, &file);\n\tif (r != SC_SUCCESS || !file)\n\t\treturn SC_ERROR_INTERNAL;\n\n\t/* Initial read */\n\tr = sc_read_binary(card, 0, ibuf, GEMSAFE_READ_QUANTUM, 0);\n\tif (r < 0)\n\t\treturn SC_ERROR_INTERNAL;\n\n\t/* Actual stored object size is encoded in first 2 bytes\n\t * (allocated EF space is much greater!)\n\t */\n\tobjlen = (((size_t) ibuf[0]) << 8) | ibuf[1];\n\tsc_log(card->ctx, \"Stored object is of size: %\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t       objlen);\n\tif (objlen < 1 || objlen > GEMSAFE_MAX_OBJLEN) {\n\t    sc_log(card->ctx, \"Invalid object size: %\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t\t   objlen);\n\t    return SC_ERROR_INTERNAL;\n\t}\n\n\t/* It looks like the first thing in the block is a table of\n\t * which keys are allocated. The table is small and is in the\n\t * first 248 bytes. Example for a card with 10 key containers:\n\t * 01 f0 00 03 03 b0 00 03     <=  1st key unallocated\n\t * 01 f0 00 04 03 b0 00 04     <=  2nd key unallocated\n\t * 01 fe 14 00 05 03 b0 00 05  <=  3rd key allocated\n\t * 01 fe 14 01 06 03 b0 00 06  <=  4th key allocated\n\t * 01 f0 00 07 03 b0 00 07     <=  5th key unallocated\n\t * ...\n\t * 01 f0 00 0c 03 b0 00 0c     <= 10th key unallocated\n\t * For allocated keys, the fourth byte seems to indicate the\n\t * default key and the fifth byte indicates the key_ref of\n\t * the private key.\n\t */\n\tind = 2; /* skip length */\n\twhile (ibuf[ind] == 0x01) {\n\t\tif (ibuf[ind+1] == 0xFE) {\n\t\t\tgemsafe_prkeys[i].ref = ibuf[ind+4];\n\t\t\tsc_log(card->ctx, \"Key container %d is allocated and uses key_ref %d\",\n\t\t\t\t\ti+1, gemsafe_prkeys[i].ref);\n\t\t\tind += 9;\n\t\t}\n\t\telse {\n\t\t\tgemsafe_prkeys[i].label = NULL;\n\t\t\tgemsafe_cert[i].label = NULL;\n\t\t\tsc_log(card->ctx, \"Key container %d is unallocated\", i+1);\n\t\t\tind += 8;\n\t\t}\n\t\ti++;\n\t}\n\n\t/* Delete additional key containers from the data structures if\n\t * this card can't accommodate them.\n\t */\n\tfor (; i < gemsafe_cert_max; i++) {\n\t\tgemsafe_prkeys[i].label = NULL;\n\t\tgemsafe_cert[i].label = NULL;\n\t}\n\n\t/* Read entire file, then dissect in memory.\n\t * Gemalto ClassicClient seems to do it the same way.\n\t */\n\tiptr = ibuf + GEMSAFE_READ_QUANTUM;\n\twhile ((size_t)(iptr - ibuf) < objlen) {\n\t\tr = sc_read_binary(card, iptr - ibuf, iptr,\n\t\t\t\t   MIN(GEMSAFE_READ_QUANTUM, objlen - (iptr - ibuf)), 0);\n\t\tif (r < 0) {\n\t\t\tsc_log(card->ctx, \"Could not read cert object\");\n\t\t\treturn SC_ERROR_INTERNAL;\n\t\t}\n\t\tiptr += GEMSAFE_READ_QUANTUM;\n\t}\n\n\t/* Search buffer for certificates, they start with 0x3082. */\n\ti = 0;\n\twhile (ind < objlen - 1) {\n\t\tif (ibuf[ind] == 0x30 && ibuf[ind+1] == 0x82) {\n\t\t\t/* Find next allocated key container */\n\t\t\twhile (i < gemsafe_cert_max && gemsafe_cert[i].label == NULL)\n\t\t\t\ti++;\n\t\t\tif (i == gemsafe_cert_max) {\n\t\t\t\tsc_log(card->ctx, \"Warning: Found orphaned certificate at offset %d\", ind);\n\t\t\t\treturn SC_SUCCESS;\n\t\t\t}\n\t\t\t/* DER cert len is encoded this way */\n\t\t\tif (ind+3 >= sizeof ibuf)\n\t\t\t\treturn SC_ERROR_INVALID_DATA;\n\t\t\tcertlen = ((((size_t) ibuf[ind+2]) << 8) | ibuf[ind+3]) + 4;\n\t\t\tsc_log(card->ctx,\n\t\t\t       \"Found certificate of key container %d at offset %d, len %\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t\t\t       i+1, ind, certlen);\n\t\t\tgemsafe_cert[i].index = ind;\n\t\t\tgemsafe_cert[i].count = certlen;\n\t\t\tind += certlen;\n\t\t\ti++;\n\t\t} else\n\t\t\tind++;\n\t}\n\n\t/* Delete additional key containers from the data structures if\n\t * they're missing on the card.\n\t */\n\tfor (; i < gemsafe_cert_max; i++) {\n\t\tif (gemsafe_cert[i].label) {\n\t\t\tsc_log(card->ctx, \"Warning: Certificate of key container %d is missing\", i+1);\n\t\t\tgemsafe_prkeys[i].label = NULL;\n\t\t\tgemsafe_cert[i].label = NULL;\n\t\t}\n\t}\n\n\treturn SC_SUCCESS;\n}",
        "func": "static int gemsafe_get_cert_len(sc_card_t *card)\n{\n\tint r;\n\tu8  ibuf[GEMSAFE_MAX_OBJLEN];\n\tu8 *iptr;\n\tstruct sc_path path;\n\tstruct sc_file *file;\n\tsize_t objlen, certlen;\n\tunsigned int ind, i=0;\n\n\tsc_format_path(GEMSAFE_PATH, &path);\n\tr = sc_select_file(card, &path, &file);\n\tif (r != SC_SUCCESS || !file)\n\t\treturn SC_ERROR_INTERNAL;\n\n\t/* Initial read */\n\tr = sc_read_binary(card, 0, ibuf, GEMSAFE_READ_QUANTUM, 0);\n\tif (r < 0)\n\t\treturn SC_ERROR_INTERNAL;\n\n\t/* Actual stored object size is encoded in first 2 bytes\n\t * (allocated EF space is much greater!)\n\t */\n\tobjlen = (((size_t) ibuf[0]) << 8) | ibuf[1];\n\tsc_log(card->ctx, \"Stored object is of size: %\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t       objlen);\n\tif (objlen < 1 || objlen > GEMSAFE_MAX_OBJLEN) {\n\t    sc_log(card->ctx, \"Invalid object size: %\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t\t   objlen);\n\t    return SC_ERROR_INTERNAL;\n\t}\n\n\t/* It looks like the first thing in the block is a table of\n\t * which keys are allocated. The table is small and is in the\n\t * first 248 bytes. Example for a card with 10 key containers:\n\t * 01 f0 00 03 03 b0 00 03     <=  1st key unallocated\n\t * 01 f0 00 04 03 b0 00 04     <=  2nd key unallocated\n\t * 01 fe 14 00 05 03 b0 00 05  <=  3rd key allocated\n\t * 01 fe 14 01 06 03 b0 00 06  <=  4th key allocated\n\t * 01 f0 00 07 03 b0 00 07     <=  5th key unallocated\n\t * ...\n\t * 01 f0 00 0c 03 b0 00 0c     <= 10th key unallocated\n\t * For allocated keys, the fourth byte seems to indicate the\n\t * default key and the fifth byte indicates the key_ref of\n\t * the private key.\n\t */\n\tind = 2; /* skip length */\n\twhile (ibuf[ind] == 0x01 && i < gemsafe_cert_max) {\n\t\tif (ibuf[ind+1] == 0xFE) {\n\t\t\tgemsafe_prkeys[i].ref = ibuf[ind+4];\n\t\t\tsc_log(card->ctx, \"Key container %d is allocated and uses key_ref %d\",\n\t\t\t\t\ti+1, gemsafe_prkeys[i].ref);\n\t\t\tind += 9;\n\t\t}\n\t\telse {\n\t\t\tgemsafe_prkeys[i].label = NULL;\n\t\t\tgemsafe_cert[i].label = NULL;\n\t\t\tsc_log(card->ctx, \"Key container %d is unallocated\", i+1);\n\t\t\tind += 8;\n\t\t}\n\t\ti++;\n\t}\n\n\t/* Delete additional key containers from the data structures if\n\t * this card can't accommodate them.\n\t */\n\tfor (; i < gemsafe_cert_max; i++) {\n\t\tgemsafe_prkeys[i].label = NULL;\n\t\tgemsafe_cert[i].label = NULL;\n\t}\n\n\t/* Read entire file, then dissect in memory.\n\t * Gemalto ClassicClient seems to do it the same way.\n\t */\n\tiptr = ibuf + GEMSAFE_READ_QUANTUM;\n\twhile ((size_t)(iptr - ibuf) < objlen) {\n\t\tr = sc_read_binary(card, iptr - ibuf, iptr,\n\t\t\t\t   MIN(GEMSAFE_READ_QUANTUM, objlen - (iptr - ibuf)), 0);\n\t\tif (r < 0) {\n\t\t\tsc_log(card->ctx, \"Could not read cert object\");\n\t\t\treturn SC_ERROR_INTERNAL;\n\t\t}\n\t\tiptr += GEMSAFE_READ_QUANTUM;\n\t}\n\n\t/* Search buffer for certificates, they start with 0x3082. */\n\ti = 0;\n\twhile (ind < objlen - 1) {\n\t\tif (ibuf[ind] == 0x30 && ibuf[ind+1] == 0x82) {\n\t\t\t/* Find next allocated key container */\n\t\t\twhile (i < gemsafe_cert_max && gemsafe_cert[i].label == NULL)\n\t\t\t\ti++;\n\t\t\tif (i == gemsafe_cert_max) {\n\t\t\t\tsc_log(card->ctx, \"Warning: Found orphaned certificate at offset %d\", ind);\n\t\t\t\treturn SC_SUCCESS;\n\t\t\t}\n\t\t\t/* DER cert len is encoded this way */\n\t\t\tif (ind+3 >= sizeof ibuf)\n\t\t\t\treturn SC_ERROR_INVALID_DATA;\n\t\t\tcertlen = ((((size_t) ibuf[ind+2]) << 8) | ibuf[ind+3]) + 4;\n\t\t\tsc_log(card->ctx,\n\t\t\t       \"Found certificate of key container %d at offset %d, len %\"SC_FORMAT_LEN_SIZE_T\"u\",\n\t\t\t       i+1, ind, certlen);\n\t\t\tgemsafe_cert[i].index = ind;\n\t\t\tgemsafe_cert[i].count = certlen;\n\t\t\tind += certlen;\n\t\t\ti++;\n\t\t} else\n\t\t\tind++;\n\t}\n\n\t/* Delete additional key containers from the data structures if\n\t * they're missing on the card.\n\t */\n\tfor (; i < gemsafe_cert_max; i++) {\n\t\tif (gemsafe_cert[i].label) {\n\t\t\tsc_log(card->ctx, \"Warning: Certificate of key container %d is missing\", i+1);\n\t\t\tgemsafe_prkeys[i].label = NULL;\n\t\t\tgemsafe_cert[i].label = NULL;\n\t\t}\n\t}\n\n\treturn SC_SUCCESS;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -45,7 +45,7 @@\n \t * the private key.\n \t */\n \tind = 2; /* skip length */\n-\twhile (ibuf[ind] == 0x01) {\n+\twhile (ibuf[ind] == 0x01 && i < gemsafe_cert_max) {\n \t\tif (ibuf[ind+1] == 0xFE) {\n \t\t\tgemsafe_prkeys[i].ref = ibuf[ind+4];\n \t\t\tsc_log(card->ctx, \"Key container %d is allocated and uses key_ref %d\",",
        "diff_line_info": {
            "deleted_lines": [
                "\twhile (ibuf[ind] == 0x01) {"
            ],
            "added_lines": [
                "\twhile (ibuf[ind] == 0x01 && i < gemsafe_cert_max) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-16391",
        "func_name": "OpenSC/sc_pkcs15emu_sc_hsm_init",
        "description": "Several buffer overflows when handling responses from a Muscle Card in muscle_list_files in libopensc/card-muscle.c in OpenSC before 0.19.0-rc1 could be used by attackers able to supply crafted smartcards to cause a denial of service (application crash) or possibly have unspecified other impact.",
        "git_url": "https://github.com/OpenSC/OpenSC/commit/360e95d45ac4123255a4c796db96337f332160ad",
        "commit_title": "fixed out of bounds writes",
        "commit_text": " Thanks to Eric Sesterhenn from X41 D-SEC GmbH for reporting the problems.",
        "func_before": "static int sc_pkcs15emu_sc_hsm_init (sc_pkcs15_card_t * p15card)\n{\n\tsc_card_t *card = p15card->card;\n\tsc_hsm_private_data_t *priv = (sc_hsm_private_data_t *) card->drv_data;\n\tsc_file_t *file = NULL;\n\tsc_path_t path;\n\tu8 filelist[MAX_EXT_APDU_LENGTH];\n\tint filelistlength;\n\tint r, i;\n\tsc_cvc_t devcert;\n\tstruct sc_app_info *appinfo;\n\tstruct sc_pkcs15_auth_info pin_info;\n\tstruct sc_pkcs15_object pin_obj;\n\tstruct sc_pin_cmd_data pindata;\n\tu8 efbin[1024];\n\tu8 *ptr;\n\tsize_t len;\n\n\tLOG_FUNC_CALLED(card->ctx);\n\n\tappinfo = calloc(1, sizeof(struct sc_app_info));\n\n\tif (appinfo == NULL) {\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);\n\t}\n\n\tappinfo->aid = sc_hsm_aid;\n\n\tappinfo->ddo.aid = sc_hsm_aid;\n\tp15card->app = appinfo;\n\n\tsc_path_set(&path, SC_PATH_TYPE_DF_NAME, sc_hsm_aid.value, sc_hsm_aid.len, 0, 0);\n\tr = sc_select_file(card, &path, &file);\n\tLOG_TEST_RET(card->ctx, r, \"Could not select SmartCard-HSM application\");\n\n\tp15card->card->version.hw_major = 24;\t/* JCOP 2.4.1r3 */\n\tp15card->card->version.hw_minor = 13;\n\tif (file && file->prop_attr && file->prop_attr_len >= 2) {\n\t\tp15card->card->version.fw_major = file->prop_attr[file->prop_attr_len - 2];\n\t\tp15card->card->version.fw_minor = file->prop_attr[file->prop_attr_len - 1];\n\t}\n\n\tsc_file_free(file);\n\n\t/* Read device certificate to determine serial number */\n\tif (priv->EF_C_DevAut && priv->EF_C_DevAut_len) {\n\t\tptr = priv->EF_C_DevAut;\n\t\tlen = priv->EF_C_DevAut_len;\n\t} else {\n\t\tlen = sizeof efbin;\n\t\tr = read_file(p15card, (u8 *) \"\\x2F\\x02\", efbin, &len, 1);\n\t\tLOG_TEST_RET(card->ctx, r, \"Skipping optional EF.C_DevAut\");\n\n\t\t/* save EF_C_DevAut for further use */\n\t\tptr = realloc(priv->EF_C_DevAut, len);\n\t\tif (ptr) {\n\t\t\tmemcpy(ptr, efbin, len);\n\t\t\tpriv->EF_C_DevAut = ptr;\n\t\t\tpriv->EF_C_DevAut_len = len;\n\t\t}\n\n\t\tptr = efbin;\n\t}\n\n\tmemset(&devcert, 0 ,sizeof(devcert));\n\tr = sc_pkcs15emu_sc_hsm_decode_cvc(p15card, (const u8 **)&ptr, &len, &devcert);\n\tLOG_TEST_RET(card->ctx, r, \"Could not decode EF.C_DevAut\");\n\n\tsc_pkcs15emu_sc_hsm_read_tokeninfo(p15card);\n\n\tif (p15card->tokeninfo->label == NULL) {\n\t\tif (p15card->card->type == SC_CARD_TYPE_SC_HSM_GOID\n\t\t\t\t|| p15card->card->type == SC_CARD_TYPE_SC_HSM_SOC) {\n\t\t\tp15card->tokeninfo->label = strdup(\"GoID\");\n\t\t} else {\n\t\t\tp15card->tokeninfo->label = strdup(\"SmartCard-HSM\");\n\t\t}\n\t\tif (p15card->tokeninfo->label == NULL)\n\t\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);\n\t}\n\n\tif ((p15card->tokeninfo->manufacturer_id != NULL) && !strcmp(\"(unknown)\", p15card->tokeninfo->manufacturer_id)) {\n\t\tfree(p15card->tokeninfo->manufacturer_id);\n\t\tp15card->tokeninfo->manufacturer_id = NULL;\n\t}\n\n\tif (p15card->tokeninfo->manufacturer_id == NULL) {\n\t\tif (p15card->card->type == SC_CARD_TYPE_SC_HSM_GOID\n\t\t\t\t|| p15card->card->type == SC_CARD_TYPE_SC_HSM_SOC) {\n\t\t\tp15card->tokeninfo->manufacturer_id = strdup(\"Bundesdruckerei GmbH\");\n\t\t} else {\n\t\t\tp15card->tokeninfo->manufacturer_id = strdup(\"www.CardContact.de\");\n\t\t}\n\t\tif (p15card->tokeninfo->manufacturer_id == NULL)\n\t\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);\n\t}\n\n\tappinfo->label = strdup(p15card->tokeninfo->label);\n\tif (appinfo->label == NULL)\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);\n\n\tlen = strnlen(devcert.chr, sizeof devcert.chr);\t\t/* Strip last 5 digit sequence number from CHR */\n\tassert(len >= 8);\n\tlen -= 5;\n\n\tp15card->tokeninfo->serial_number = calloc(len + 1, 1);\n\tif (p15card->tokeninfo->serial_number == NULL)\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);\n\n\tmemcpy(p15card->tokeninfo->serial_number, devcert.chr, len);\n\t*(p15card->tokeninfo->serial_number + len) = 0;\n\n\tsc_hsm_set_serialnr(card, p15card->tokeninfo->serial_number);\n\n\tsc_pkcs15emu_sc_hsm_free_cvc(&devcert);\n\n\tmemset(&pin_info, 0, sizeof(pin_info));\n\tmemset(&pin_obj, 0, sizeof(pin_obj));\n\n\tpin_info.auth_id.len = 1;\n\tpin_info.auth_id.value[0] = 1;\n\tpin_info.path.aid = sc_hsm_aid;\n\tpin_info.auth_type = SC_PKCS15_PIN_AUTH_TYPE_PIN;\n\tpin_info.attrs.pin.reference = 0x81;\n\tpin_info.attrs.pin.flags = SC_PKCS15_PIN_FLAG_LOCAL|SC_PKCS15_PIN_FLAG_INITIALIZED|SC_PKCS15_PIN_FLAG_EXCHANGE_REF_DATA;\n\tpin_info.attrs.pin.type = SC_PKCS15_PIN_TYPE_ASCII_NUMERIC;\n\tpin_info.attrs.pin.min_length = 6;\n\tpin_info.attrs.pin.stored_length = 0;\n\tpin_info.attrs.pin.max_length = 15;\n\tpin_info.attrs.pin.pad_char = '\\0';\n\tpin_info.tries_left = 3;\n\tpin_info.max_tries = 3;\n\n\tpin_obj.auth_id.len = 1;\n\tpin_obj.auth_id.value[0] = 2;\n\tstrlcpy(pin_obj.label, \"UserPIN\", sizeof(pin_obj.label));\n\tpin_obj.flags = SC_PKCS15_CO_FLAG_PRIVATE|SC_PKCS15_CO_FLAG_MODIFIABLE;\n\n\tr = sc_pkcs15emu_add_pin_obj(p15card, &pin_obj, &pin_info);\n\tif (r < 0)\n\t\tLOG_FUNC_RETURN(card->ctx, r);\n\n\tmemset(&pin_info, 0, sizeof(pin_info));\n\tmemset(&pin_obj, 0, sizeof(pin_obj));\n\n\tpin_info.auth_id.len = 1;\n\tpin_info.auth_id.value[0] = 2;\n\tpin_info.path.aid = sc_hsm_aid;\n\tpin_info.auth_type = SC_PKCS15_PIN_AUTH_TYPE_PIN;\n\tpin_info.attrs.pin.reference = 0x88;\n\tpin_info.attrs.pin.flags = SC_PKCS15_PIN_FLAG_LOCAL|SC_PKCS15_PIN_FLAG_INITIALIZED|SC_PKCS15_PIN_FLAG_UNBLOCK_DISABLED|SC_PKCS15_PIN_FLAG_SO_PIN;\n\tpin_info.attrs.pin.type = SC_PKCS15_PIN_TYPE_BCD;\n\tpin_info.attrs.pin.min_length = 16;\n\tpin_info.attrs.pin.stored_length = 0;\n\tpin_info.attrs.pin.max_length = 16;\n\tpin_info.attrs.pin.pad_char = '\\0';\n\tpin_info.tries_left = 15;\n\tpin_info.max_tries = 15;\n\n\tstrlcpy(pin_obj.label, \"SOPIN\", sizeof(pin_obj.label));\n\tpin_obj.flags = SC_PKCS15_CO_FLAG_PRIVATE;\n\n\tr = sc_pkcs15emu_add_pin_obj(p15card, &pin_obj, &pin_info);\n\tif (r < 0)\n\t\tLOG_FUNC_RETURN(card->ctx, r);\n\n\n\tif (card->type == SC_CARD_TYPE_SC_HSM_SOC\n\t\t\t|| card->type == SC_CARD_TYPE_SC_HSM_GOID) {\n\t\t/* SC-HSM of this type always has a PIN-Pad */\n\t\tr = SC_SUCCESS;\n\t} else {\n\t\tmemset(&pindata, 0, sizeof(pindata));\n\t\tpindata.cmd = SC_PIN_CMD_GET_INFO;\n\t\tpindata.pin_type = SC_AC_CHV;\n\t\tpindata.pin_reference = 0x85;\n\n\t\tr = sc_pin_cmd(card, &pindata, NULL);\n\t}\n\tif (r == SC_ERROR_DATA_OBJECT_NOT_FOUND) {\n\t\tmemset(&pindata, 0, sizeof(pindata));\n\t\tpindata.cmd = SC_PIN_CMD_GET_INFO;\n\t\tpindata.pin_type = SC_AC_CHV;\n\t\tpindata.pin_reference = 0x86;\n\n\t\tr = sc_pin_cmd(card, &pindata, NULL);\n\t}\n\n\tif ((r != SC_ERROR_DATA_OBJECT_NOT_FOUND) && (r != SC_ERROR_INCORRECT_PARAMETERS))\n\t\tcard->caps |= SC_CARD_CAP_PROTECTED_AUTHENTICATION_PATH;\n\n\n\tfilelistlength = sc_list_files(card, filelist, sizeof(filelist));\n\tLOG_TEST_RET(card->ctx, filelistlength, \"Could not enumerate file and key identifier\");\n\n\tfor (i = 0; i < filelistlength; i += 2) {\n\t\tswitch(filelist[i]) {\n\t\tcase KEY_PREFIX:\n\t\t\tr = sc_pkcs15emu_sc_hsm_add_prkd(p15card, filelist[i + 1]);\n\t\t\tbreak;\n\t\tcase DCOD_PREFIX:\n\t\t\tr = sc_pkcs15emu_sc_hsm_add_dcod(p15card, filelist[i + 1]);\n\t\t\tbreak;\n\t\tcase CD_PREFIX:\n\t\t\tr = sc_pkcs15emu_sc_hsm_add_cd(p15card, filelist[i + 1]);\n\t\t\tbreak;\n\t\t}\n\t\tif (r != SC_SUCCESS) {\n\t\t\tsc_log(card->ctx, \"Error %d adding elements to framework\", r);\n\t\t}\n\t}\n\n\tLOG_FUNC_RETURN(card->ctx, SC_SUCCESS);\n}",
        "func": "static int sc_pkcs15emu_sc_hsm_init (sc_pkcs15_card_t * p15card)\n{\n\tsc_card_t *card = p15card->card;\n\tsc_hsm_private_data_t *priv = (sc_hsm_private_data_t *) card->drv_data;\n\tsc_file_t *file = NULL;\n\tsc_path_t path;\n\tu8 filelist[MAX_EXT_APDU_LENGTH];\n\tint filelistlength;\n\tint r, i;\n\tsc_cvc_t devcert;\n\tstruct sc_app_info *appinfo;\n\tstruct sc_pkcs15_auth_info pin_info;\n\tstruct sc_pkcs15_object pin_obj;\n\tstruct sc_pin_cmd_data pindata;\n\tu8 efbin[1024];\n\tu8 *ptr;\n\tsize_t len;\n\n\tLOG_FUNC_CALLED(card->ctx);\n\n\tappinfo = calloc(1, sizeof(struct sc_app_info));\n\n\tif (appinfo == NULL) {\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);\n\t}\n\n\tappinfo->aid = sc_hsm_aid;\n\n\tappinfo->ddo.aid = sc_hsm_aid;\n\tp15card->app = appinfo;\n\n\tsc_path_set(&path, SC_PATH_TYPE_DF_NAME, sc_hsm_aid.value, sc_hsm_aid.len, 0, 0);\n\tr = sc_select_file(card, &path, &file);\n\tLOG_TEST_RET(card->ctx, r, \"Could not select SmartCard-HSM application\");\n\n\tp15card->card->version.hw_major = 24;\t/* JCOP 2.4.1r3 */\n\tp15card->card->version.hw_minor = 13;\n\tif (file && file->prop_attr && file->prop_attr_len >= 2) {\n\t\tp15card->card->version.fw_major = file->prop_attr[file->prop_attr_len - 2];\n\t\tp15card->card->version.fw_minor = file->prop_attr[file->prop_attr_len - 1];\n\t}\n\n\tsc_file_free(file);\n\n\t/* Read device certificate to determine serial number */\n\tif (priv->EF_C_DevAut && priv->EF_C_DevAut_len) {\n\t\tptr = priv->EF_C_DevAut;\n\t\tlen = priv->EF_C_DevAut_len;\n\t} else {\n\t\tlen = sizeof efbin;\n\t\tr = read_file(p15card, (u8 *) \"\\x2F\\x02\", efbin, &len, 1);\n\t\tLOG_TEST_RET(card->ctx, r, \"Skipping optional EF.C_DevAut\");\n\n\t\tif (len > 0) {\n\t\t\t/* save EF_C_DevAut for further use */\n\t\t\tptr = realloc(priv->EF_C_DevAut, len);\n\t\t\tif (ptr) {\n\t\t\t\tmemcpy(ptr, efbin, len);\n\t\t\t\tpriv->EF_C_DevAut = ptr;\n\t\t\t\tpriv->EF_C_DevAut_len = len;\n\t\t\t}\n\t\t}\n\n\t\tptr = efbin;\n\t}\n\n\tmemset(&devcert, 0 ,sizeof(devcert));\n\tr = sc_pkcs15emu_sc_hsm_decode_cvc(p15card, (const u8 **)&ptr, &len, &devcert);\n\tLOG_TEST_RET(card->ctx, r, \"Could not decode EF.C_DevAut\");\n\n\tsc_pkcs15emu_sc_hsm_read_tokeninfo(p15card);\n\n\tif (p15card->tokeninfo->label == NULL) {\n\t\tif (p15card->card->type == SC_CARD_TYPE_SC_HSM_GOID\n\t\t\t\t|| p15card->card->type == SC_CARD_TYPE_SC_HSM_SOC) {\n\t\t\tp15card->tokeninfo->label = strdup(\"GoID\");\n\t\t} else {\n\t\t\tp15card->tokeninfo->label = strdup(\"SmartCard-HSM\");\n\t\t}\n\t\tif (p15card->tokeninfo->label == NULL)\n\t\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);\n\t}\n\n\tif ((p15card->tokeninfo->manufacturer_id != NULL) && !strcmp(\"(unknown)\", p15card->tokeninfo->manufacturer_id)) {\n\t\tfree(p15card->tokeninfo->manufacturer_id);\n\t\tp15card->tokeninfo->manufacturer_id = NULL;\n\t}\n\n\tif (p15card->tokeninfo->manufacturer_id == NULL) {\n\t\tif (p15card->card->type == SC_CARD_TYPE_SC_HSM_GOID\n\t\t\t\t|| p15card->card->type == SC_CARD_TYPE_SC_HSM_SOC) {\n\t\t\tp15card->tokeninfo->manufacturer_id = strdup(\"Bundesdruckerei GmbH\");\n\t\t} else {\n\t\t\tp15card->tokeninfo->manufacturer_id = strdup(\"www.CardContact.de\");\n\t\t}\n\t\tif (p15card->tokeninfo->manufacturer_id == NULL)\n\t\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);\n\t}\n\n\tappinfo->label = strdup(p15card->tokeninfo->label);\n\tif (appinfo->label == NULL)\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);\n\n\tlen = strnlen(devcert.chr, sizeof devcert.chr);\t\t/* Strip last 5 digit sequence number from CHR */\n\tassert(len >= 8);\n\tlen -= 5;\n\n\tp15card->tokeninfo->serial_number = calloc(len + 1, 1);\n\tif (p15card->tokeninfo->serial_number == NULL)\n\t\tLOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);\n\n\tmemcpy(p15card->tokeninfo->serial_number, devcert.chr, len);\n\t*(p15card->tokeninfo->serial_number + len) = 0;\n\n\tsc_hsm_set_serialnr(card, p15card->tokeninfo->serial_number);\n\n\tsc_pkcs15emu_sc_hsm_free_cvc(&devcert);\n\n\tmemset(&pin_info, 0, sizeof(pin_info));\n\tmemset(&pin_obj, 0, sizeof(pin_obj));\n\n\tpin_info.auth_id.len = 1;\n\tpin_info.auth_id.value[0] = 1;\n\tpin_info.path.aid = sc_hsm_aid;\n\tpin_info.auth_type = SC_PKCS15_PIN_AUTH_TYPE_PIN;\n\tpin_info.attrs.pin.reference = 0x81;\n\tpin_info.attrs.pin.flags = SC_PKCS15_PIN_FLAG_LOCAL|SC_PKCS15_PIN_FLAG_INITIALIZED|SC_PKCS15_PIN_FLAG_EXCHANGE_REF_DATA;\n\tpin_info.attrs.pin.type = SC_PKCS15_PIN_TYPE_ASCII_NUMERIC;\n\tpin_info.attrs.pin.min_length = 6;\n\tpin_info.attrs.pin.stored_length = 0;\n\tpin_info.attrs.pin.max_length = 15;\n\tpin_info.attrs.pin.pad_char = '\\0';\n\tpin_info.tries_left = 3;\n\tpin_info.max_tries = 3;\n\n\tpin_obj.auth_id.len = 1;\n\tpin_obj.auth_id.value[0] = 2;\n\tstrlcpy(pin_obj.label, \"UserPIN\", sizeof(pin_obj.label));\n\tpin_obj.flags = SC_PKCS15_CO_FLAG_PRIVATE|SC_PKCS15_CO_FLAG_MODIFIABLE;\n\n\tr = sc_pkcs15emu_add_pin_obj(p15card, &pin_obj, &pin_info);\n\tif (r < 0)\n\t\tLOG_FUNC_RETURN(card->ctx, r);\n\n\tmemset(&pin_info, 0, sizeof(pin_info));\n\tmemset(&pin_obj, 0, sizeof(pin_obj));\n\n\tpin_info.auth_id.len = 1;\n\tpin_info.auth_id.value[0] = 2;\n\tpin_info.path.aid = sc_hsm_aid;\n\tpin_info.auth_type = SC_PKCS15_PIN_AUTH_TYPE_PIN;\n\tpin_info.attrs.pin.reference = 0x88;\n\tpin_info.attrs.pin.flags = SC_PKCS15_PIN_FLAG_LOCAL|SC_PKCS15_PIN_FLAG_INITIALIZED|SC_PKCS15_PIN_FLAG_UNBLOCK_DISABLED|SC_PKCS15_PIN_FLAG_SO_PIN;\n\tpin_info.attrs.pin.type = SC_PKCS15_PIN_TYPE_BCD;\n\tpin_info.attrs.pin.min_length = 16;\n\tpin_info.attrs.pin.stored_length = 0;\n\tpin_info.attrs.pin.max_length = 16;\n\tpin_info.attrs.pin.pad_char = '\\0';\n\tpin_info.tries_left = 15;\n\tpin_info.max_tries = 15;\n\n\tstrlcpy(pin_obj.label, \"SOPIN\", sizeof(pin_obj.label));\n\tpin_obj.flags = SC_PKCS15_CO_FLAG_PRIVATE;\n\n\tr = sc_pkcs15emu_add_pin_obj(p15card, &pin_obj, &pin_info);\n\tif (r < 0)\n\t\tLOG_FUNC_RETURN(card->ctx, r);\n\n\n\tif (card->type == SC_CARD_TYPE_SC_HSM_SOC\n\t\t\t|| card->type == SC_CARD_TYPE_SC_HSM_GOID) {\n\t\t/* SC-HSM of this type always has a PIN-Pad */\n\t\tr = SC_SUCCESS;\n\t} else {\n\t\tmemset(&pindata, 0, sizeof(pindata));\n\t\tpindata.cmd = SC_PIN_CMD_GET_INFO;\n\t\tpindata.pin_type = SC_AC_CHV;\n\t\tpindata.pin_reference = 0x85;\n\n\t\tr = sc_pin_cmd(card, &pindata, NULL);\n\t}\n\tif (r == SC_ERROR_DATA_OBJECT_NOT_FOUND) {\n\t\tmemset(&pindata, 0, sizeof(pindata));\n\t\tpindata.cmd = SC_PIN_CMD_GET_INFO;\n\t\tpindata.pin_type = SC_AC_CHV;\n\t\tpindata.pin_reference = 0x86;\n\n\t\tr = sc_pin_cmd(card, &pindata, NULL);\n\t}\n\n\tif ((r != SC_ERROR_DATA_OBJECT_NOT_FOUND) && (r != SC_ERROR_INCORRECT_PARAMETERS))\n\t\tcard->caps |= SC_CARD_CAP_PROTECTED_AUTHENTICATION_PATH;\n\n\n\tfilelistlength = sc_list_files(card, filelist, sizeof(filelist));\n\tLOG_TEST_RET(card->ctx, filelistlength, \"Could not enumerate file and key identifier\");\n\n\tfor (i = 0; i < filelistlength; i += 2) {\n\t\tswitch(filelist[i]) {\n\t\tcase KEY_PREFIX:\n\t\t\tr = sc_pkcs15emu_sc_hsm_add_prkd(p15card, filelist[i + 1]);\n\t\t\tbreak;\n\t\tcase DCOD_PREFIX:\n\t\t\tr = sc_pkcs15emu_sc_hsm_add_dcod(p15card, filelist[i + 1]);\n\t\t\tbreak;\n\t\tcase CD_PREFIX:\n\t\t\tr = sc_pkcs15emu_sc_hsm_add_cd(p15card, filelist[i + 1]);\n\t\t\tbreak;\n\t\t}\n\t\tif (r != SC_SUCCESS) {\n\t\t\tsc_log(card->ctx, \"Error %d adding elements to framework\", r);\n\t\t}\n\t}\n\n\tLOG_FUNC_RETURN(card->ctx, SC_SUCCESS);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -51,12 +51,14 @@\n \t\tr = read_file(p15card, (u8 *) \"\\x2F\\x02\", efbin, &len, 1);\n \t\tLOG_TEST_RET(card->ctx, r, \"Skipping optional EF.C_DevAut\");\n \n-\t\t/* save EF_C_DevAut for further use */\n-\t\tptr = realloc(priv->EF_C_DevAut, len);\n-\t\tif (ptr) {\n-\t\t\tmemcpy(ptr, efbin, len);\n-\t\t\tpriv->EF_C_DevAut = ptr;\n-\t\t\tpriv->EF_C_DevAut_len = len;\n+\t\tif (len > 0) {\n+\t\t\t/* save EF_C_DevAut for further use */\n+\t\t\tptr = realloc(priv->EF_C_DevAut, len);\n+\t\t\tif (ptr) {\n+\t\t\t\tmemcpy(ptr, efbin, len);\n+\t\t\t\tpriv->EF_C_DevAut = ptr;\n+\t\t\t\tpriv->EF_C_DevAut_len = len;\n+\t\t\t}\n \t\t}\n \n \t\tptr = efbin;",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t/* save EF_C_DevAut for further use */",
                "\t\tptr = realloc(priv->EF_C_DevAut, len);",
                "\t\tif (ptr) {",
                "\t\t\tmemcpy(ptr, efbin, len);",
                "\t\t\tpriv->EF_C_DevAut = ptr;",
                "\t\t\tpriv->EF_C_DevAut_len = len;"
            ],
            "added_lines": [
                "\t\tif (len > 0) {",
                "\t\t\t/* save EF_C_DevAut for further use */",
                "\t\t\tptr = realloc(priv->EF_C_DevAut, len);",
                "\t\t\tif (ptr) {",
                "\t\t\t\tmemcpy(ptr, efbin, len);",
                "\t\t\t\tpriv->EF_C_DevAut = ptr;",
                "\t\t\t\tpriv->EF_C_DevAut_len = len;",
                "\t\t\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-16391",
        "func_name": "OpenSC/read_private_key",
        "description": "Several buffer overflows when handling responses from a Muscle Card in muscle_list_files in libopensc/card-muscle.c in OpenSC before 0.19.0-rc1 could be used by attackers able to supply crafted smartcards to cause a denial of service (application crash) or possibly have unspecified other impact.",
        "git_url": "https://github.com/OpenSC/OpenSC/commit/360e95d45ac4123255a4c796db96337f332160ad",
        "commit_title": "fixed out of bounds writes",
        "commit_text": " Thanks to Eric Sesterhenn from X41 D-SEC GmbH for reporting the problems.",
        "func_before": "static int read_private_key(RSA *rsa)\n{\n\tint r;\n\tsc_path_t path;\n\tsc_file_t *file;\n\tconst sc_acl_entry_t *e;\n\n\tu8 buf[2048], *p = buf;\n\tsize_t bufsize, keysize;\n\n\tr = select_app_df();\n\tif (r)\n\t\treturn 1;\n\tsc_format_path(\"I0012\", &path);\n\tr = sc_select_file(card, &path, &file);\n\tif (r) {\n\t\tfprintf(stderr, \"Unable to select private key file: %s\\n\", sc_strerror(r));\n\t\treturn 2;\n\t}\n\te = sc_file_get_acl_entry(file, SC_AC_OP_READ);\n\tif (e == NULL || e->method == SC_AC_NEVER)\n\t\treturn 10;\n\tbufsize = file->size;\n\tsc_file_free(file);\n\tr = sc_read_binary(card, 0, buf, bufsize, 0);\n\tif (r < 0) {\n\t\tfprintf(stderr, \"Unable to read private key file: %s\\n\", sc_strerror(r));\n\t\treturn 2;\n\t}\n\tbufsize = r;\n\tdo {\n\t\tif (bufsize < 4)\n\t\t\treturn 3;\n\t\tkeysize = (p[0] << 8) | p[1];\n\t\tif (keysize == 0)\n\t\t\tbreak;\n\t\tif (keysize < 3)\n\t\t\treturn 3;\n\t\tif (p[2] == opt_key_num)\n\t\t\tbreak;\n\t\tp += keysize;\n\t\tbufsize -= keysize;\n\t} while (1);\n\tif (keysize == 0) {\n\t\tprintf(\"Key number %d not found.\\n\", opt_key_num);\n\t\treturn 2;\n\t}\n\treturn parse_private_key(p, keysize, rsa);\n}",
        "func": "static int read_private_key(RSA *rsa)\n{\n\tint r;\n\tsc_path_t path;\n\tsc_file_t *file;\n\tconst sc_acl_entry_t *e;\n\n\tu8 buf[2048], *p = buf;\n\tsize_t bufsize, keysize;\n\n\tr = select_app_df();\n\tif (r)\n\t\treturn 1;\n\tsc_format_path(\"I0012\", &path);\n\tr = sc_select_file(card, &path, &file);\n\tif (r) {\n\t\tfprintf(stderr, \"Unable to select private key file: %s\\n\", sc_strerror(r));\n\t\treturn 2;\n\t}\n\te = sc_file_get_acl_entry(file, SC_AC_OP_READ);\n\tif (e == NULL || e->method == SC_AC_NEVER)\n\t\treturn 10;\n\tbufsize = MIN(file->size, sizeof buf);\n\tsc_file_free(file);\n\tr = sc_read_binary(card, 0, buf, bufsize, 0);\n\tif (r < 0) {\n\t\tfprintf(stderr, \"Unable to read private key file: %s\\n\", sc_strerror(r));\n\t\treturn 2;\n\t}\n\tbufsize = r;\n\tdo {\n\t\tif (bufsize < 4)\n\t\t\treturn 3;\n\t\tkeysize = (p[0] << 8) | p[1];\n\t\tif (keysize == 0)\n\t\t\tbreak;\n\t\tif (keysize < 3)\n\t\t\treturn 3;\n\t\tif (p[2] == opt_key_num)\n\t\t\tbreak;\n\t\tp += keysize;\n\t\tbufsize -= keysize;\n\t} while (1);\n\tif (keysize == 0) {\n\t\tprintf(\"Key number %d not found.\\n\", opt_key_num);\n\t\treturn 2;\n\t}\n\treturn parse_private_key(p, keysize, rsa);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -20,7 +20,7 @@\n \te = sc_file_get_acl_entry(file, SC_AC_OP_READ);\n \tif (e == NULL || e->method == SC_AC_NEVER)\n \t\treturn 10;\n-\tbufsize = file->size;\n+\tbufsize = MIN(file->size, sizeof buf);\n \tsc_file_free(file);\n \tr = sc_read_binary(card, 0, buf, bufsize, 0);\n \tif (r < 0) {",
        "diff_line_info": {
            "deleted_lines": [
                "\tbufsize = file->size;"
            ],
            "added_lines": [
                "\tbufsize = MIN(file->size, sizeof buf);"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-16391",
        "func_name": "OpenSC/read_public_key",
        "description": "Several buffer overflows when handling responses from a Muscle Card in muscle_list_files in libopensc/card-muscle.c in OpenSC before 0.19.0-rc1 could be used by attackers able to supply crafted smartcards to cause a denial of service (application crash) or possibly have unspecified other impact.",
        "git_url": "https://github.com/OpenSC/OpenSC/commit/360e95d45ac4123255a4c796db96337f332160ad",
        "commit_title": "fixed out of bounds writes",
        "commit_text": " Thanks to Eric Sesterhenn from X41 D-SEC GmbH for reporting the problems.",
        "func_before": "static int read_public_key(RSA *rsa)\n{\n\tint r;\n\tsc_path_t path;\n\tsc_file_t *file;\n\tu8 buf[2048], *p = buf;\n\tsize_t bufsize, keysize;\n\n\tr = select_app_df();\n\tif (r)\n\t\treturn 1;\n\tsc_format_path(\"I1012\", &path);\n\tr = sc_select_file(card, &path, &file);\n\tif (r) {\n\t\tfprintf(stderr, \"Unable to select public key file: %s\\n\", sc_strerror(r));\n\t\treturn 2;\n\t}\n\tbufsize = file->size;\n\tsc_file_free(file);\n\tr = sc_read_binary(card, 0, buf, bufsize, 0);\n\tif (r < 0) {\n\t\tfprintf(stderr, \"Unable to read public key file: %s\\n\", sc_strerror(r));\n\t\treturn 2;\n\t}\n\tbufsize = r;\n\tdo {\n\t\tif (bufsize < 4)\n\t\t\treturn 3;\n\t\tkeysize = (p[0] << 8) | p[1];\n\t\tif (keysize == 0)\n\t\t\tbreak;\n\t\tif (keysize < 3)\n\t\t\treturn 3;\n\t\tif (p[2] == opt_key_num)\n\t\t\tbreak;\n\t\tp += keysize;\n\t\tbufsize -= keysize;\n\t} while (1);\n\tif (keysize == 0) {\n\t\tprintf(\"Key number %d not found.\\n\", opt_key_num);\n\t\treturn 2;\n\t}\n\treturn parse_public_key(p, keysize, rsa);\n}",
        "func": "static int read_public_key(RSA *rsa)\n{\n\tint r;\n\tsc_path_t path;\n\tsc_file_t *file;\n\tu8 buf[2048], *p = buf;\n\tsize_t bufsize, keysize;\n\n\tr = select_app_df();\n\tif (r)\n\t\treturn 1;\n\tsc_format_path(\"I1012\", &path);\n\tr = sc_select_file(card, &path, &file);\n\tif (r) {\n\t\tfprintf(stderr, \"Unable to select public key file: %s\\n\", sc_strerror(r));\n\t\treturn 2;\n\t}\n\tbufsize = MIN(file->size, sizeof buf);\n\tsc_file_free(file);\n\tr = sc_read_binary(card, 0, buf, bufsize, 0);\n\tif (r < 0) {\n\t\tfprintf(stderr, \"Unable to read public key file: %s\\n\", sc_strerror(r));\n\t\treturn 2;\n\t}\n\tbufsize = r;\n\tdo {\n\t\tif (bufsize < 4)\n\t\t\treturn 3;\n\t\tkeysize = (p[0] << 8) | p[1];\n\t\tif (keysize == 0)\n\t\t\tbreak;\n\t\tif (keysize < 3)\n\t\t\treturn 3;\n\t\tif (p[2] == opt_key_num)\n\t\t\tbreak;\n\t\tp += keysize;\n\t\tbufsize -= keysize;\n\t} while (1);\n\tif (keysize == 0) {\n\t\tprintf(\"Key number %d not found.\\n\", opt_key_num);\n\t\treturn 2;\n\t}\n\treturn parse_public_key(p, keysize, rsa);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -15,7 +15,7 @@\n \t\tfprintf(stderr, \"Unable to select public key file: %s\\n\", sc_strerror(r));\n \t\treturn 2;\n \t}\n-\tbufsize = file->size;\n+\tbufsize = MIN(file->size, sizeof buf);\n \tsc_file_free(file);\n \tr = sc_read_binary(card, 0, buf, bufsize, 0);\n \tif (r < 0) {",
        "diff_line_info": {
            "deleted_lines": [
                "\tbufsize = file->size;"
            ],
            "added_lines": [
                "\tbufsize = MIN(file->size, sizeof buf);"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-16391",
        "func_name": "OpenSC/sc_pkcs15emu_esteid_init",
        "description": "Several buffer overflows when handling responses from a Muscle Card in muscle_list_files in libopensc/card-muscle.c in OpenSC before 0.19.0-rc1 could be used by attackers able to supply crafted smartcards to cause a denial of service (application crash) or possibly have unspecified other impact.",
        "git_url": "https://github.com/OpenSC/OpenSC/commit/360e95d45ac4123255a4c796db96337f332160ad",
        "commit_title": "fixed out of bounds writes",
        "commit_text": " Thanks to Eric Sesterhenn from X41 D-SEC GmbH for reporting the problems.",
        "func_before": "static int\nsc_pkcs15emu_esteid_init (sc_pkcs15_card_t * p15card)\n{\n\tsc_card_t *card = p15card->card;\n\tunsigned char buff[128];\n\tint r, i;\n\tsize_t field_length = 0, modulus_length = 0;\n\tsc_path_t tmppath;\n\n\tset_string (&p15card->tokeninfo->label, \"ID-kaart\");\n\tset_string (&p15card->tokeninfo->manufacturer_id, \"AS Sertifitseerimiskeskus\");\n\n\t/* Select application directory */\n\tsc_format_path (\"3f00eeee5044\", &tmppath);\n\tr = sc_select_file (card, &tmppath, NULL);\n\tSC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, \"select esteid PD failed\");\n\n\t/* read the serial (document number) */\n\tr = sc_read_record (card, SC_ESTEID_PD_DOCUMENT_NR, buff, sizeof(buff), SC_RECORD_BY_REC_NR);\n\tSC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, \"read document number failed\");\n\tbuff[r] = '\\0';\n\tset_string (&p15card->tokeninfo->serial_number, (const char *) buff);\n\n\tp15card->tokeninfo->flags = SC_PKCS15_TOKEN_PRN_GENERATION\n\t\t\t\t  | SC_PKCS15_TOKEN_EID_COMPLIANT\n\t\t\t\t  | SC_PKCS15_TOKEN_READONLY;\n\n\t/* add certificates */\n\tfor (i = 0; i < 2; i++) {\n\t\tstatic const char *esteid_cert_names[2] = {\n\t\t\t\"Isikutuvastus\",\n\t\t\t\"Allkirjastamine\"};\n\t\tstatic char const *esteid_cert_paths[2] = {\n\t\t\t\"3f00eeeeaace\",\n\t\t\t\"3f00eeeeddce\"};\n\t\tstatic int esteid_cert_ids[2] = {1, 2};\n\n\t\tstruct sc_pkcs15_cert_info cert_info;\n\t\tstruct sc_pkcs15_object cert_obj;\n\n\t\tmemset(&cert_info, 0, sizeof(cert_info));\n\t\tmemset(&cert_obj, 0, sizeof(cert_obj));\n\n\t\tcert_info.id.value[0] = esteid_cert_ids[i];\n\t\tcert_info.id.len = 1;\n\t\tsc_format_path(esteid_cert_paths[i], &cert_info.path);\n\t\tstrlcpy(cert_obj.label, esteid_cert_names[i], sizeof(cert_obj.label));\n\t\tr = sc_pkcs15emu_add_x509_cert(p15card, &cert_obj, &cert_info);\n\t\tif (r < 0)\n\t\t\treturn SC_ERROR_INTERNAL;\n\t\tif (i == 0) {\n\t\t\tsc_pkcs15_cert_t *cert = NULL;\n\t\t\tr = sc_pkcs15_read_certificate(p15card, &cert_info, &cert);\n\t\t\tif (r < 0)\n\t\t\t\treturn SC_ERROR_INTERNAL;\n\t\t\tif (cert->key->algorithm == SC_ALGORITHM_EC)\n\t\t\t\tfield_length = cert->key->u.ec.params.field_length;\n\t\t\telse\n\t\t\t\tmodulus_length = cert->key->u.rsa.modulus.len * 8;\n\t\t\tif (r == SC_SUCCESS) {\n\t\t\t\tstatic const struct sc_object_id cn_oid = {{ 2, 5, 4, 3, -1 }};\n\t\t\t\tu8 *cn_name = NULL;\n\t\t\t\tsize_t cn_len = 0;\n\t\t\t\tsc_pkcs15_get_name_from_dn(card->ctx, cert->subject,\n\t\t\t\t\tcert->subject_len, &cn_oid, &cn_name, &cn_len);\n\t\t\t\tif (cn_len > 0) {\n\t\t\t\t\tchar *token_name = malloc(cn_len+1);\n\t\t\t\t\tif (token_name) {\n\t\t\t\t\t\tmemcpy(token_name, cn_name, cn_len);\n\t\t\t\t\t\ttoken_name[cn_len] = '\\0';\n\t\t\t\t\t\tset_string(&p15card->tokeninfo->label, (const char*)token_name);\n\t\t\t\t\t\tfree(token_name);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfree(cn_name);\n\t\t\t\tsc_pkcs15_free_certificate(cert);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* the file with key pin info (tries left) */\n\tsc_format_path (\"3f000016\", &tmppath);\n\tr = sc_select_file (card, &tmppath, NULL);\n\tif (r < 0)\n\t\treturn SC_ERROR_INTERNAL;\n\n\t/* add pins */\n\tfor (i = 0; i < 3; i++) {\n\t\tunsigned char tries_left;\n\t\tstatic const char *esteid_pin_names[3] = {\n\t\t\t\"PIN1\",\n\t\t\t\"PIN2\",\n\t\t\t\"PUK\" };\n\t\t\t\n\t\tstatic const int esteid_pin_min[3] = {4, 5, 8};\n\t\tstatic const int esteid_pin_ref[3] = {1, 2, 0};\n\t\tstatic const int esteid_pin_authid[3] = {1, 2, 3};\n\t\tstatic const int esteid_pin_flags[3] = {0, 0, SC_PKCS15_PIN_FLAG_UNBLOCKING_PIN};\n\t\t\n\t\tstruct sc_pkcs15_auth_info pin_info;\n\t\tstruct sc_pkcs15_object pin_obj;\n\n\t\tmemset(&pin_info, 0, sizeof(pin_info));\n\t\tmemset(&pin_obj, 0, sizeof(pin_obj));\n\n\t\t/* read the number of tries left for the PIN */\n\t\tr = sc_read_record (card, i + 1, buff, sizeof(buff), SC_RECORD_BY_REC_NR);\n\t\tif (r < 0)\n\t\t\treturn SC_ERROR_INTERNAL;\n\t\ttries_left = buff[5];\n\n\t\tpin_info.auth_id.len = 1;\n\t\tpin_info.auth_id.value[0] = esteid_pin_authid[i];\n\t\tpin_info.auth_type = SC_PKCS15_PIN_AUTH_TYPE_PIN;\n\t\tpin_info.attrs.pin.reference = esteid_pin_ref[i];\n\t\tpin_info.attrs.pin.flags = esteid_pin_flags[i];\n\t\tpin_info.attrs.pin.type = SC_PKCS15_PIN_TYPE_ASCII_NUMERIC;\n\t\tpin_info.attrs.pin.min_length = esteid_pin_min[i];\n\t\tpin_info.attrs.pin.stored_length = 12;\n\t\tpin_info.attrs.pin.max_length = 12;\n\t\tpin_info.attrs.pin.pad_char = '\\0';\n\t\tpin_info.tries_left = (int)tries_left;\n\t\tpin_info.max_tries = 3;\n\n\t\tstrlcpy(pin_obj.label, esteid_pin_names[i], sizeof(pin_obj.label));\n\t\tpin_obj.flags = esteid_pin_flags[i];\n\n\t\t/* Link normal PINs with PUK */\n\t\tif (i < 2) {\n\t\t\tpin_obj.auth_id.len = 1;\n\t\t\tpin_obj.auth_id.value[0] = 3;\n\t\t}\n\n\t\tr = sc_pkcs15emu_add_pin_obj(p15card, &pin_obj, &pin_info);\n\t\tif (r < 0)\n\t\t\treturn SC_ERROR_INTERNAL;\n\t}\n\n\t/* add private keys */\n\tfor (i = 0; i < 2; i++) {\n\t\tstatic int prkey_pin[2] = {1, 2};\n\n\t\tstatic const char *prkey_name[2] = {\n\t\t\t\"Isikutuvastus\",\n\t\t\t\"Allkirjastamine\"};\n\n\t\tstruct sc_pkcs15_prkey_info prkey_info;\n\t\tstruct sc_pkcs15_object prkey_obj;\n\n\t\tmemset(&prkey_info, 0, sizeof(prkey_info));\n\t\tmemset(&prkey_obj, 0, sizeof(prkey_obj));\n\n\t\tprkey_info.id.len = 1;\n\t\tprkey_info.id.value[0] = prkey_pin[i];\n\t\tprkey_info.native = 1;\n\t\tprkey_info.key_reference = i + 1;\n\t\tprkey_info.field_length = field_length;\n\t\tprkey_info.modulus_length = modulus_length;\n\t\tif (i == 1)\n\t\t\tprkey_info.usage = SC_PKCS15_PRKEY_USAGE_NONREPUDIATION;\n\t\telse if(field_length > 0) // ECC has sign and derive usage\n\t\t\tprkey_info.usage = SC_PKCS15_PRKEY_USAGE_SIGN | SC_PKCS15_PRKEY_USAGE_DERIVE;\n\t\telse\n\t\t\tprkey_info.usage = SC_PKCS15_PRKEY_USAGE_SIGN | SC_PKCS15_PRKEY_USAGE_ENCRYPT | SC_PKCS15_PRKEY_USAGE_DECRYPT;\n\n\t\tstrlcpy(prkey_obj.label, prkey_name[i], sizeof(prkey_obj.label));\n\t\tprkey_obj.auth_id.len = 1;\n\t\tprkey_obj.auth_id.value[0] = prkey_pin[i];\n\t\tprkey_obj.user_consent = 0;\n\t\tprkey_obj.flags = SC_PKCS15_CO_FLAG_PRIVATE;\n\n\t\tif(field_length > 0)\n\t\t\tr = sc_pkcs15emu_add_ec_prkey(p15card, &prkey_obj, &prkey_info);\n\t\telse\n\t\t\tr = sc_pkcs15emu_add_rsa_prkey(p15card, &prkey_obj, &prkey_info);\n\t\tif (r < 0)\n\t\t\treturn SC_ERROR_INTERNAL;\n\t}\n\n\treturn SC_SUCCESS;\n}",
        "func": "static int\nsc_pkcs15emu_esteid_init (sc_pkcs15_card_t * p15card)\n{\n\tsc_card_t *card = p15card->card;\n\tunsigned char buff[128];\n\tint r, i;\n\tsize_t field_length = 0, modulus_length = 0;\n\tsc_path_t tmppath;\n\n\tset_string (&p15card->tokeninfo->label, \"ID-kaart\");\n\tset_string (&p15card->tokeninfo->manufacturer_id, \"AS Sertifitseerimiskeskus\");\n\n\t/* Select application directory */\n\tsc_format_path (\"3f00eeee5044\", &tmppath);\n\tr = sc_select_file (card, &tmppath, NULL);\n\tSC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, \"select esteid PD failed\");\n\n\t/* read the serial (document number) */\n\tr = sc_read_record (card, SC_ESTEID_PD_DOCUMENT_NR, buff, sizeof(buff), SC_RECORD_BY_REC_NR);\n\tSC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, \"read document number failed\");\n\tbuff[MIN((size_t) r, (sizeof buff)-1)] = '\\0';\n\tset_string (&p15card->tokeninfo->serial_number, (const char *) buff);\n\n\tp15card->tokeninfo->flags = SC_PKCS15_TOKEN_PRN_GENERATION\n\t\t\t\t  | SC_PKCS15_TOKEN_EID_COMPLIANT\n\t\t\t\t  | SC_PKCS15_TOKEN_READONLY;\n\n\t/* add certificates */\n\tfor (i = 0; i < 2; i++) {\n\t\tstatic const char *esteid_cert_names[2] = {\n\t\t\t\"Isikutuvastus\",\n\t\t\t\"Allkirjastamine\"};\n\t\tstatic char const *esteid_cert_paths[2] = {\n\t\t\t\"3f00eeeeaace\",\n\t\t\t\"3f00eeeeddce\"};\n\t\tstatic int esteid_cert_ids[2] = {1, 2};\n\n\t\tstruct sc_pkcs15_cert_info cert_info;\n\t\tstruct sc_pkcs15_object cert_obj;\n\n\t\tmemset(&cert_info, 0, sizeof(cert_info));\n\t\tmemset(&cert_obj, 0, sizeof(cert_obj));\n\n\t\tcert_info.id.value[0] = esteid_cert_ids[i];\n\t\tcert_info.id.len = 1;\n\t\tsc_format_path(esteid_cert_paths[i], &cert_info.path);\n\t\tstrlcpy(cert_obj.label, esteid_cert_names[i], sizeof(cert_obj.label));\n\t\tr = sc_pkcs15emu_add_x509_cert(p15card, &cert_obj, &cert_info);\n\t\tif (r < 0)\n\t\t\treturn SC_ERROR_INTERNAL;\n\t\tif (i == 0) {\n\t\t\tsc_pkcs15_cert_t *cert = NULL;\n\t\t\tr = sc_pkcs15_read_certificate(p15card, &cert_info, &cert);\n\t\t\tif (r < 0)\n\t\t\t\treturn SC_ERROR_INTERNAL;\n\t\t\tif (cert->key->algorithm == SC_ALGORITHM_EC)\n\t\t\t\tfield_length = cert->key->u.ec.params.field_length;\n\t\t\telse\n\t\t\t\tmodulus_length = cert->key->u.rsa.modulus.len * 8;\n\t\t\tif (r == SC_SUCCESS) {\n\t\t\t\tstatic const struct sc_object_id cn_oid = {{ 2, 5, 4, 3, -1 }};\n\t\t\t\tu8 *cn_name = NULL;\n\t\t\t\tsize_t cn_len = 0;\n\t\t\t\tsc_pkcs15_get_name_from_dn(card->ctx, cert->subject,\n\t\t\t\t\tcert->subject_len, &cn_oid, &cn_name, &cn_len);\n\t\t\t\tif (cn_len > 0) {\n\t\t\t\t\tchar *token_name = malloc(cn_len+1);\n\t\t\t\t\tif (token_name) {\n\t\t\t\t\t\tmemcpy(token_name, cn_name, cn_len);\n\t\t\t\t\t\ttoken_name[cn_len] = '\\0';\n\t\t\t\t\t\tset_string(&p15card->tokeninfo->label, (const char*)token_name);\n\t\t\t\t\t\tfree(token_name);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfree(cn_name);\n\t\t\t\tsc_pkcs15_free_certificate(cert);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* the file with key pin info (tries left) */\n\tsc_format_path (\"3f000016\", &tmppath);\n\tr = sc_select_file (card, &tmppath, NULL);\n\tif (r < 0)\n\t\treturn SC_ERROR_INTERNAL;\n\n\t/* add pins */\n\tfor (i = 0; i < 3; i++) {\n\t\tunsigned char tries_left;\n\t\tstatic const char *esteid_pin_names[3] = {\n\t\t\t\"PIN1\",\n\t\t\t\"PIN2\",\n\t\t\t\"PUK\" };\n\t\t\t\n\t\tstatic const int esteid_pin_min[3] = {4, 5, 8};\n\t\tstatic const int esteid_pin_ref[3] = {1, 2, 0};\n\t\tstatic const int esteid_pin_authid[3] = {1, 2, 3};\n\t\tstatic const int esteid_pin_flags[3] = {0, 0, SC_PKCS15_PIN_FLAG_UNBLOCKING_PIN};\n\t\t\n\t\tstruct sc_pkcs15_auth_info pin_info;\n\t\tstruct sc_pkcs15_object pin_obj;\n\n\t\tmemset(&pin_info, 0, sizeof(pin_info));\n\t\tmemset(&pin_obj, 0, sizeof(pin_obj));\n\n\t\t/* read the number of tries left for the PIN */\n\t\tr = sc_read_record (card, i + 1, buff, sizeof(buff), SC_RECORD_BY_REC_NR);\n\t\tif (r < 0)\n\t\t\treturn SC_ERROR_INTERNAL;\n\t\ttries_left = buff[5];\n\n\t\tpin_info.auth_id.len = 1;\n\t\tpin_info.auth_id.value[0] = esteid_pin_authid[i];\n\t\tpin_info.auth_type = SC_PKCS15_PIN_AUTH_TYPE_PIN;\n\t\tpin_info.attrs.pin.reference = esteid_pin_ref[i];\n\t\tpin_info.attrs.pin.flags = esteid_pin_flags[i];\n\t\tpin_info.attrs.pin.type = SC_PKCS15_PIN_TYPE_ASCII_NUMERIC;\n\t\tpin_info.attrs.pin.min_length = esteid_pin_min[i];\n\t\tpin_info.attrs.pin.stored_length = 12;\n\t\tpin_info.attrs.pin.max_length = 12;\n\t\tpin_info.attrs.pin.pad_char = '\\0';\n\t\tpin_info.tries_left = (int)tries_left;\n\t\tpin_info.max_tries = 3;\n\n\t\tstrlcpy(pin_obj.label, esteid_pin_names[i], sizeof(pin_obj.label));\n\t\tpin_obj.flags = esteid_pin_flags[i];\n\n\t\t/* Link normal PINs with PUK */\n\t\tif (i < 2) {\n\t\t\tpin_obj.auth_id.len = 1;\n\t\t\tpin_obj.auth_id.value[0] = 3;\n\t\t}\n\n\t\tr = sc_pkcs15emu_add_pin_obj(p15card, &pin_obj, &pin_info);\n\t\tif (r < 0)\n\t\t\treturn SC_ERROR_INTERNAL;\n\t}\n\n\t/* add private keys */\n\tfor (i = 0; i < 2; i++) {\n\t\tstatic int prkey_pin[2] = {1, 2};\n\n\t\tstatic const char *prkey_name[2] = {\n\t\t\t\"Isikutuvastus\",\n\t\t\t\"Allkirjastamine\"};\n\n\t\tstruct sc_pkcs15_prkey_info prkey_info;\n\t\tstruct sc_pkcs15_object prkey_obj;\n\n\t\tmemset(&prkey_info, 0, sizeof(prkey_info));\n\t\tmemset(&prkey_obj, 0, sizeof(prkey_obj));\n\n\t\tprkey_info.id.len = 1;\n\t\tprkey_info.id.value[0] = prkey_pin[i];\n\t\tprkey_info.native = 1;\n\t\tprkey_info.key_reference = i + 1;\n\t\tprkey_info.field_length = field_length;\n\t\tprkey_info.modulus_length = modulus_length;\n\t\tif (i == 1)\n\t\t\tprkey_info.usage = SC_PKCS15_PRKEY_USAGE_NONREPUDIATION;\n\t\telse if(field_length > 0) // ECC has sign and derive usage\n\t\t\tprkey_info.usage = SC_PKCS15_PRKEY_USAGE_SIGN | SC_PKCS15_PRKEY_USAGE_DERIVE;\n\t\telse\n\t\t\tprkey_info.usage = SC_PKCS15_PRKEY_USAGE_SIGN | SC_PKCS15_PRKEY_USAGE_ENCRYPT | SC_PKCS15_PRKEY_USAGE_DECRYPT;\n\n\t\tstrlcpy(prkey_obj.label, prkey_name[i], sizeof(prkey_obj.label));\n\t\tprkey_obj.auth_id.len = 1;\n\t\tprkey_obj.auth_id.value[0] = prkey_pin[i];\n\t\tprkey_obj.user_consent = 0;\n\t\tprkey_obj.flags = SC_PKCS15_CO_FLAG_PRIVATE;\n\n\t\tif(field_length > 0)\n\t\t\tr = sc_pkcs15emu_add_ec_prkey(p15card, &prkey_obj, &prkey_info);\n\t\telse\n\t\t\tr = sc_pkcs15emu_add_rsa_prkey(p15card, &prkey_obj, &prkey_info);\n\t\tif (r < 0)\n\t\t\treturn SC_ERROR_INTERNAL;\n\t}\n\n\treturn SC_SUCCESS;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -18,7 +18,7 @@\n \t/* read the serial (document number) */\n \tr = sc_read_record (card, SC_ESTEID_PD_DOCUMENT_NR, buff, sizeof(buff), SC_RECORD_BY_REC_NR);\n \tSC_TEST_RET(card->ctx, SC_LOG_DEBUG_NORMAL, r, \"read document number failed\");\n-\tbuff[r] = '\\0';\n+\tbuff[MIN((size_t) r, (sizeof buff)-1)] = '\\0';\n \tset_string (&p15card->tokeninfo->serial_number, (const char *) buff);\n \n \tp15card->tokeninfo->flags = SC_PKCS15_TOKEN_PRN_GENERATION",
        "diff_line_info": {
            "deleted_lines": [
                "\tbuff[r] = '\\0';"
            ],
            "added_lines": [
                "\tbuff[MIN((size_t) r, (sizeof buff)-1)] = '\\0';"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-16391",
        "func_name": "OpenSC/util_acl_to_str",
        "description": "Several buffer overflows when handling responses from a Muscle Card in muscle_list_files in libopensc/card-muscle.c in OpenSC before 0.19.0-rc1 could be used by attackers able to supply crafted smartcards to cause a denial of service (application crash) or possibly have unspecified other impact.",
        "git_url": "https://github.com/OpenSC/OpenSC/commit/360e95d45ac4123255a4c796db96337f332160ad",
        "commit_title": "fixed out of bounds writes",
        "commit_text": " Thanks to Eric Sesterhenn from X41 D-SEC GmbH for reporting the problems.",
        "func_before": "const char * util_acl_to_str(const sc_acl_entry_t *e)\n{\n\tstatic char line[80], buf[20];\n\tunsigned int acl;\n\n\tif (e == NULL)\n\t\treturn \"N/A\";\n\tline[0] = 0;\n\twhile (e != NULL) {\n\t\tacl = e->method;\n\n\t\tswitch (acl) {\n\t\tcase SC_AC_UNKNOWN:\n\t\t\treturn \"N/A\";\n\t\tcase SC_AC_NEVER:\n\t\t\treturn \"NEVR\";\n\t\tcase SC_AC_NONE:\n\t\t\treturn \"NONE\";\n\t\tcase SC_AC_CHV:\n\t\t\tstrcpy(buf, \"CHV\");\n\t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)\n\t\t\t\tsprintf(buf + 3, \"%d\", e->key_ref);\n\t\t\tbreak;\n\t\tcase SC_AC_TERM:\n\t\t\tstrcpy(buf, \"TERM\");\n\t\t\tbreak;\n\t\tcase SC_AC_PRO:\n\t\t\tstrcpy(buf, \"PROT\");\n\t\t\tbreak;\n\t\tcase SC_AC_AUT:\n\t\t\tstrcpy(buf, \"AUTH\");\n\t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)\n\t\t\t\tsprintf(buf + 4, \"%d\", e->key_ref);\n\t\t\tbreak;\n\t\tcase SC_AC_SEN:\n\t\t\tstrcpy(buf, \"Sec.Env. \");\n\t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)\n\t\t\t\tsprintf(buf + 3, \"#%d\", e->key_ref);\n\t\t\tbreak;\n\t\tcase SC_AC_SCB:\n\t\t\tstrcpy(buf, \"Sec.ControlByte \");\n\t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)\n\t\t\t\tsprintf(buf + 3, \"Ox%X\", e->key_ref);\n\t\t\tbreak;\n\t\tcase SC_AC_IDA:\n\t\t\tstrcpy(buf, \"PKCS#15 AuthID \");\n\t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)\n\t\t\t\tsprintf(buf + 3, \"#%d\", e->key_ref);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstrcpy(buf, \"????\");\n\t\t\tbreak;\n\t\t}\n\t\tstrcat(line, buf);\n\t\tstrcat(line, \" \");\n\t\te = e->next;\n\t}\n\tline[strlen(line)-1] = 0; /* get rid of trailing space */\n\treturn line;\n}",
        "func": "const char * util_acl_to_str(const sc_acl_entry_t *e)\n{\n\tstatic char line[80], buf[20];\n\tunsigned int acl;\n\n\tif (e == NULL)\n\t\treturn \"N/A\";\n\tline[0] = 0;\n\twhile (e != NULL) {\n\t\tacl = e->method;\n\n\t\tswitch (acl) {\n\t\tcase SC_AC_UNKNOWN:\n\t\t\treturn \"N/A\";\n\t\tcase SC_AC_NEVER:\n\t\t\treturn \"NEVR\";\n\t\tcase SC_AC_NONE:\n\t\t\treturn \"NONE\";\n\t\tcase SC_AC_CHV:\n\t\t\tstrcpy(buf, \"CHV\");\n\t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)\n\t\t\t\tsprintf(buf + 3, \"%d\", e->key_ref);\n\t\t\tbreak;\n\t\tcase SC_AC_TERM:\n\t\t\tstrcpy(buf, \"TERM\");\n\t\t\tbreak;\n\t\tcase SC_AC_PRO:\n\t\t\tstrcpy(buf, \"PROT\");\n\t\t\tbreak;\n\t\tcase SC_AC_AUT:\n\t\t\tstrcpy(buf, \"AUTH\");\n\t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)\n\t\t\t\tsprintf(buf + 4, \"%d\", e->key_ref);\n\t\t\tbreak;\n\t\tcase SC_AC_SEN:\n\t\t\tstrcpy(buf, \"Sec.Env. \");\n\t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)\n\t\t\t\tsprintf(buf + 3, \"#%d\", e->key_ref);\n\t\t\tbreak;\n\t\tcase SC_AC_SCB:\n\t\t\tstrcpy(buf, \"Sec.ControlByte \");\n\t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)\n\t\t\t\tsprintf(buf + 3, \"Ox%X\", e->key_ref);\n\t\t\tbreak;\n\t\tcase SC_AC_IDA:\n\t\t\tstrcpy(buf, \"PKCS#15 AuthID \");\n\t\t\tif (e->key_ref != SC_AC_KEY_REF_NONE)\n\t\t\t\tsprintf(buf + 3, \"#%d\", e->key_ref);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tstrcpy(buf, \"????\");\n\t\t\tbreak;\n\t\t}\n\t\tstrncat(line, buf, sizeof line);\n\t\tstrncat(line, \" \", sizeof line);\n\t\te = e->next;\n\t}\n\tline[(sizeof line)-1] = '\\0'; /* make sure it's NUL terminated */\n\tline[strlen(line)-1] = 0; /* get rid of trailing space */\n\treturn line;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -51,10 +51,11 @@\n \t\t\tstrcpy(buf, \"????\");\n \t\t\tbreak;\n \t\t}\n-\t\tstrcat(line, buf);\n-\t\tstrcat(line, \" \");\n+\t\tstrncat(line, buf, sizeof line);\n+\t\tstrncat(line, \" \", sizeof line);\n \t\te = e->next;\n \t}\n+\tline[(sizeof line)-1] = '\\0'; /* make sure it's NUL terminated */\n \tline[strlen(line)-1] = 0; /* get rid of trailing space */\n \treturn line;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tstrcat(line, buf);",
                "\t\tstrcat(line, \" \");"
            ],
            "added_lines": [
                "\t\tstrncat(line, buf, sizeof line);",
                "\t\tstrncat(line, \" \", sizeof line);",
                "\tline[(sizeof line)-1] = '\\0'; /* make sure it's NUL terminated */"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-16391",
        "func_name": "OpenSC/sc_file_set_sec_attr",
        "description": "Several buffer overflows when handling responses from a Muscle Card in muscle_list_files in libopensc/card-muscle.c in OpenSC before 0.19.0-rc1 could be used by attackers able to supply crafted smartcards to cause a denial of service (application crash) or possibly have unspecified other impact.",
        "git_url": "https://github.com/OpenSC/OpenSC/commit/360e95d45ac4123255a4c796db96337f332160ad",
        "commit_title": "fixed out of bounds writes",
        "commit_text": " Thanks to Eric Sesterhenn from X41 D-SEC GmbH for reporting the problems.",
        "func_before": "int sc_file_set_sec_attr(sc_file_t *file, const u8 *sec_attr,\n\t\t\t size_t sec_attr_len)\n{\n\tu8 *tmp;\n\tif (!sc_file_valid(file)) {\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\t}\n\n\tif (sec_attr == NULL) {\n\t\tif (file->sec_attr != NULL)\n\t\t\tfree(file->sec_attr);\n\t\tfile->sec_attr = NULL;\n\t\tfile->sec_attr_len = 0;\n\t\treturn 0;\n\t }\n\ttmp = (u8 *) realloc(file->sec_attr, sec_attr_len);\n\tif (!tmp) {\n\t\tif (file->sec_attr)\n\t\t\tfree(file->sec_attr);\n\t\tfile->sec_attr     = NULL;\n\t\tfile->sec_attr_len = 0;\n\t\treturn SC_ERROR_OUT_OF_MEMORY;\n\t}\n\tfile->sec_attr = tmp;\n\tmemcpy(file->sec_attr, sec_attr, sec_attr_len);\n\tfile->sec_attr_len = sec_attr_len;\n\n\treturn 0;\n}",
        "func": "int sc_file_set_sec_attr(sc_file_t *file, const u8 *sec_attr,\n\t\t\t size_t sec_attr_len)\n{\n\tu8 *tmp;\n\tif (!sc_file_valid(file)) {\n\t\treturn SC_ERROR_INVALID_ARGUMENTS;\n\t}\n\n\tif (sec_attr == NULL || sec_attr_len) {\n\t\tif (file->sec_attr != NULL)\n\t\t\tfree(file->sec_attr);\n\t\tfile->sec_attr = NULL;\n\t\tfile->sec_attr_len = 0;\n\t\treturn 0;\n\t }\n\ttmp = (u8 *) realloc(file->sec_attr, sec_attr_len);\n\tif (!tmp) {\n\t\tif (file->sec_attr)\n\t\t\tfree(file->sec_attr);\n\t\tfile->sec_attr     = NULL;\n\t\tfile->sec_attr_len = 0;\n\t\treturn SC_ERROR_OUT_OF_MEMORY;\n\t}\n\tfile->sec_attr = tmp;\n\tmemcpy(file->sec_attr, sec_attr, sec_attr_len);\n\tfile->sec_attr_len = sec_attr_len;\n\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,7 +6,7 @@\n \t\treturn SC_ERROR_INVALID_ARGUMENTS;\n \t}\n \n-\tif (sec_attr == NULL) {\n+\tif (sec_attr == NULL || sec_attr_len) {\n \t\tif (file->sec_attr != NULL)\n \t\t\tfree(file->sec_attr);\n \t\tfile->sec_attr = NULL;",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (sec_attr == NULL) {"
            ],
            "added_lines": [
                "\tif (sec_attr == NULL || sec_attr_len) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-16391",
        "func_name": "OpenSC/read_file",
        "description": "Several buffer overflows when handling responses from a Muscle Card in muscle_list_files in libopensc/card-muscle.c in OpenSC before 0.19.0-rc1 could be used by attackers able to supply crafted smartcards to cause a denial of service (application crash) or possibly have unspecified other impact.",
        "git_url": "https://github.com/OpenSC/OpenSC/commit/360e95d45ac4123255a4c796db96337f332160ad",
        "commit_title": "fixed out of bounds writes",
        "commit_text": " Thanks to Eric Sesterhenn from X41 D-SEC GmbH for reporting the problems.",
        "func_before": "int read_file(struct sc_card *card, char *str_path, unsigned char **data, size_t *data_len)\n{\n\tstruct sc_path path;\n\tstruct sc_file *file;\n\tunsigned char *p;\n\tint ok = 0;\n\tint r;\n\tsize_t len;\n\n\tsc_format_path(str_path, &path);\n\tif (SC_SUCCESS != sc_select_file(card, &path, &file)) {\n\t\tgoto err;\n\t}\n\n\tlen = file ? file->size : 4096;\n\tp = realloc(*data, len);\n\tif (!p) {\n\t\tgoto err;\n\t}\n\t*data = p;\n\t*data_len = len;\n\n\tr = sc_read_binary(card, 0, p, len, 0);\n\tif (r < 0)\n\t\tgoto err;\n\n\t*data_len = r;\n\tok = 1;\n\nerr:\n\tsc_file_free(file);\n\n\treturn ok;\n}",
        "func": "int read_file(struct sc_card *card, char *str_path, unsigned char **data, size_t *data_len)\n{\n\tstruct sc_path path;\n\tstruct sc_file *file;\n\tunsigned char *p;\n\tint ok = 0;\n\tint r;\n\tsize_t len;\n\n\tsc_format_path(str_path, &path);\n\tif (SC_SUCCESS != sc_select_file(card, &path, &file)) {\n\t\tgoto err;\n\t}\n\n\tlen = file && file->size > 0 ? file->size : 4096;\n\tp = realloc(*data, len);\n\tif (!p) {\n\t\tgoto err;\n\t}\n\t*data = p;\n\t*data_len = len;\n\n\tr = sc_read_binary(card, 0, p, len, 0);\n\tif (r < 0)\n\t\tgoto err;\n\n\t*data_len = r;\n\tok = 1;\n\nerr:\n\tsc_file_free(file);\n\n\treturn ok;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -12,7 +12,7 @@\n \t\tgoto err;\n \t}\n \n-\tlen = file ? file->size : 4096;\n+\tlen = file && file->size > 0 ? file->size : 4096;\n \tp = realloc(*data, len);\n \tif (!p) {\n \t\tgoto err;",
        "diff_line_info": {
            "deleted_lines": [
                "\tlen = file ? file->size : 4096;"
            ],
            "added_lines": [
                "\tlen = file && file->size > 0 ? file->size : 4096;"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-16391",
        "func_name": "OpenSC/muscle_list_files",
        "description": "Several buffer overflows when handling responses from a Muscle Card in muscle_list_files in libopensc/card-muscle.c in OpenSC before 0.19.0-rc1 could be used by attackers able to supply crafted smartcards to cause a denial of service (application crash) or possibly have unspecified other impact.",
        "git_url": "https://github.com/OpenSC/OpenSC/commit/360e95d45ac4123255a4c796db96337f332160ad",
        "commit_title": "fixed out of bounds writes",
        "commit_text": " Thanks to Eric Sesterhenn from X41 D-SEC GmbH for reporting the problems.",
        "func_before": "static int muscle_list_files(sc_card_t *card, u8 *buf, size_t bufLen)\n{\n\tmuscle_private_t* priv = MUSCLE_DATA(card);\n\tmscfs_t *fs = priv->fs;\n\tint x;\n\tint count = 0;\n\n\tmscfs_check_cache(priv->fs);\n\n\tfor(x = 0; x < fs->cache.size; x++) {\n\t\tu8* oid= fs->cache.array[x].objectId.id;\n\t\tsc_debug(card->ctx, SC_LOG_DEBUG_NORMAL,\n\t\t\t\"FILE: %02X%02X%02X%02X\\n\",\n\t\t\toid[0],oid[1],oid[2],oid[3]);\n\t\tif(0 == memcmp(fs->currentPath, oid, 2)) {\n\t\t\tbuf[0] = oid[2];\n\t\t\tbuf[1] = oid[3];\n\t\t\tif(buf[0] == 0x00 && buf[1] == 0x00) continue; /* No directories/null names outside of root */\n\t\t\tbuf += 2;\n\t\t\tcount+=2;\n\t\t}\n\t}\n\treturn count;\n}",
        "func": "static int muscle_list_files(sc_card_t *card, u8 *buf, size_t bufLen)\n{\n\tmuscle_private_t* priv = MUSCLE_DATA(card);\n\tmscfs_t *fs = priv->fs;\n\tint x;\n\tint count = 0;\n\n\tmscfs_check_cache(priv->fs);\n\n\tfor(x = 0; x < fs->cache.size; x++) {\n\t\tu8* oid = fs->cache.array[x].objectId.id;\n\t\tif (bufLen < 2)\n\t\t\tbreak;\n\t\tsc_debug(card->ctx, SC_LOG_DEBUG_NORMAL,\n\t\t\t\"FILE: %02X%02X%02X%02X\\n\",\n\t\t\toid[0],oid[1],oid[2],oid[3]);\n\t\tif(0 == memcmp(fs->currentPath, oid, 2)) {\n\t\t\tbuf[0] = oid[2];\n\t\t\tbuf[1] = oid[3];\n\t\t\tif(buf[0] == 0x00 && buf[1] == 0x00) continue; /* No directories/null names outside of root */\n\t\t\tbuf += 2;\n\t\t\tcount += 2;\n\t\t\tbufLen -= 2;\n\t\t}\n\t}\n\treturn count;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -8,7 +8,9 @@\n \tmscfs_check_cache(priv->fs);\n \n \tfor(x = 0; x < fs->cache.size; x++) {\n-\t\tu8* oid= fs->cache.array[x].objectId.id;\n+\t\tu8* oid = fs->cache.array[x].objectId.id;\n+\t\tif (bufLen < 2)\n+\t\t\tbreak;\n \t\tsc_debug(card->ctx, SC_LOG_DEBUG_NORMAL,\n \t\t\t\"FILE: %02X%02X%02X%02X\\n\",\n \t\t\toid[0],oid[1],oid[2],oid[3]);\n@@ -17,7 +19,8 @@\n \t\t\tbuf[1] = oid[3];\n \t\t\tif(buf[0] == 0x00 && buf[1] == 0x00) continue; /* No directories/null names outside of root */\n \t\t\tbuf += 2;\n-\t\t\tcount+=2;\n+\t\t\tcount += 2;\n+\t\t\tbufLen -= 2;\n \t\t}\n \t}\n \treturn count;",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tu8* oid= fs->cache.array[x].objectId.id;",
                "\t\t\tcount+=2;"
            ],
            "added_lines": [
                "\t\tu8* oid = fs->cache.array[x].objectId.id;",
                "\t\tif (bufLen < 2)",
                "\t\t\tbreak;",
                "\t\t\tcount += 2;",
                "\t\t\tbufLen -= 2;"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-17825",
        "func_name": "adplug/OPLDestroy",
        "description": "An issue was discovered in AdPlug 2.3.1. There are several double-free vulnerabilities in the CEmuopl class in emuopl.cpp because of a destructor's two OPLDestroy calls, each of which frees TL_TABLE, SIN_TABLE, AMS_TABLE, and VIB_TABLE.",
        "git_url": "https://github.com/adplug/adplug/commit/19ebb61bf92262dc1868de10ba5a211db249ce76",
        "commit_title": "FMOPL: Avoid double-free by checking OPL pointer (fix #67)",
        "commit_text": " Fixes CVE-2018-17825.",
        "func_before": "void OPLDestroy(FM_OPL *OPL)\n{\n#ifdef OPL_OUTPUT_LOG\n\tif(opl_dbg_fp)\n\t{\n\t\tfclose(opl_dbg_fp);\n\t\topl_dbg_fp = NULL;\n\t}\n#endif\n\tOPL_UnLockTable();\n\tfree(OPL);\n}",
        "func": "void OPLDestroy(FM_OPL *OPL)\n{\n\tif(!OPL)\n\t{\n\t\treturn;\n\t}\n#ifdef OPL_OUTPUT_LOG\n\tif(opl_dbg_fp)\n\t{\n\t\tfclose(opl_dbg_fp);\n\t\topl_dbg_fp = NULL;\n\t}\n#endif\n\tOPL_UnLockTable();\n\tfree(OPL);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,9 @@\n void OPLDestroy(FM_OPL *OPL)\n {\n+\tif(!OPL)\n+\t{\n+\t\treturn;\n+\t}\n #ifdef OPL_OUTPUT_LOG\n \tif(opl_dbg_fp)\n \t{",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tif(!OPL)",
                "\t{",
                "\t\treturn;",
                "\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-18718",
        "func_name": "GNOME/gthumb/add_themes_from_dir",
        "description": "An issue was discovered in gThumb through 3.6.2. There is a double-free vulnerability in the add_themes_from_dir method in dlg-contact-sheet.c because of two successive calls of g_free, each of which frees the same buffer.",
        "git_url": "https://github.com/GNOME/gthumb/commit/06c39346fda502bd37429006d4822dd977995661",
        "commit_title": "contact sheet: error if the theme file could not be loaded",
        "commit_text": "",
        "func_before": "static void\nadd_themes_from_dir (DialogData *data,\n\t\t     GFile      *dir,\n\t\t     gboolean    editable)\n{\n\tGFileEnumerator *enumerator;\n\tGFileInfo       *file_info;\n\n\tenumerator = g_file_enumerate_children (dir,\n\t\t\t\t\t\t(G_FILE_ATTRIBUTE_STANDARD_NAME \",\"\n\t\t\t\t\t\t G_FILE_ATTRIBUTE_STANDARD_TYPE \",\"\n\t\t\t\t\t\t G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME),\n\t\t\t\t\t\tG_FILE_QUERY_INFO_NONE,\n\t\t\t\t\t\tNULL,\n\t\t\t\t\t\tNULL);\n\tif (enumerator == NULL)\n\t\treturn;\n\n\twhile ((file_info = g_file_enumerator_next_file (enumerator, NULL, NULL)) != NULL) {\n\t\tGthContactSheetTheme *theme;\n\t\tGFile                *file;\n\t\tchar                 *buffer;\n\t\tgsize                 size;\n\t\tGKeyFile             *key_file;\n\t\tGtkTreeIter           iter;\n\t\tGdkPixbuf            *preview;\n\n\t\tif (g_file_info_get_file_type (file_info) != G_FILE_TYPE_REGULAR) {\n\t\t\tg_object_unref (file_info);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (g_strcmp0 (_g_uri_get_file_extension (g_file_info_get_name (file_info)), \".cst\") != 0) {\n\t\t\tg_object_unref (file_info);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfile = g_file_get_child (dir, g_file_info_get_name (file_info));\n\t\tif (! _g_file_load_in_buffer (file,\n\t\t\t\t\t      (void **) &buffer,\n\t\t\t\t\t      &size,\n\t\t\t\t\t      NULL,\n\t\t\t\t\t      NULL))\n\t\t{\n\t\t\tg_object_unref (file);\n\t\t\tg_object_unref (file_info);\n\t\t\tcontinue;\n\t\t}\n\n\t\tkey_file = g_key_file_new ();\n\t\tif (! g_key_file_load_from_data (key_file, buffer, size, G_KEY_FILE_NONE, NULL)) {\n\t\t\tg_key_file_free (key_file);\n\t\t\tg_free (buffer);\n\t\t\tg_object_unref (file);\n\t\t\tg_object_unref (file_info);\n\t\t}\n\n\t\ttheme = gth_contact_sheet_theme_new_from_key_file (key_file);\n\t\ttheme->file = g_object_ref (file);\n\t\ttheme->editable = editable;\n\n\t\tpreview = gth_contact_sheet_theme_create_preview (theme, PREVIEW_SIZE);\n\t\tgtk_list_store_append (GTK_LIST_STORE (GET_WIDGET (\"theme_liststore\")), &iter);\n\t\tgtk_list_store_set (GTK_LIST_STORE (GET_WIDGET (\"theme_liststore\")), &iter,\n\t\t\t\t    THEME_COLUMN_THEME, theme,\n\t\t\t\t    THEME_COLUMN_DISPLAY_NAME, theme->display_name,\n\t\t\t\t    THEME_COLUMN_PREVIEW, preview,\n\t\t\t\t    -1);\n\n\t\t_g_object_unref (preview);\n\t\tg_key_file_free (key_file);\n\t\tg_free (buffer);\n\t\tg_object_unref (file);\n\t\tg_object_unref (file_info);\n\t}\n\n\tg_object_unref (enumerator);\n}",
        "func": "static void\nadd_themes_from_dir (DialogData *data,\n\t\t     GFile      *dir,\n\t\t     gboolean    editable)\n{\n\tGFileEnumerator *enumerator;\n\tGFileInfo       *file_info;\n\n\tenumerator = g_file_enumerate_children (dir,\n\t\t\t\t\t\t(G_FILE_ATTRIBUTE_STANDARD_NAME \",\"\n\t\t\t\t\t\t G_FILE_ATTRIBUTE_STANDARD_TYPE \",\"\n\t\t\t\t\t\t G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME),\n\t\t\t\t\t\tG_FILE_QUERY_INFO_NONE,\n\t\t\t\t\t\tNULL,\n\t\t\t\t\t\tNULL);\n\tif (enumerator == NULL)\n\t\treturn;\n\n\twhile ((file_info = g_file_enumerator_next_file (enumerator, NULL, NULL)) != NULL) {\n\t\tGthContactSheetTheme *theme;\n\t\tGFile                *file;\n\t\tchar                 *buffer;\n\t\tgsize                 size;\n\t\tGKeyFile             *key_file;\n\t\tGtkTreeIter           iter;\n\t\tGdkPixbuf            *preview;\n\n\t\tif (g_file_info_get_file_type (file_info) != G_FILE_TYPE_REGULAR) {\n\t\t\tg_object_unref (file_info);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (g_strcmp0 (_g_uri_get_file_extension (g_file_info_get_name (file_info)), \".cst\") != 0) {\n\t\t\tg_object_unref (file_info);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfile = g_file_get_child (dir, g_file_info_get_name (file_info));\n\t\tif (! _g_file_load_in_buffer (file,\n\t\t\t\t\t      (void **) &buffer,\n\t\t\t\t\t      &size,\n\t\t\t\t\t      NULL,\n\t\t\t\t\t      NULL))\n\t\t{\n\t\t\tg_object_unref (file);\n\t\t\tg_object_unref (file_info);\n\t\t\tcontinue;\n\t\t}\n\n\t\tkey_file = g_key_file_new ();\n\t\tif (! g_key_file_load_from_data (key_file, buffer, size, G_KEY_FILE_NONE, NULL)) {\n\t\t\tg_key_file_free (key_file);\n\t\t\tg_free (buffer);\n\t\t\tg_object_unref (file);\n\t\t\tg_object_unref (file_info);\n\t\t\tcontinue;\n\t\t}\n\n\t\ttheme = gth_contact_sheet_theme_new_from_key_file (key_file);\n\t\ttheme->file = g_object_ref (file);\n\t\ttheme->editable = editable;\n\n\t\tpreview = gth_contact_sheet_theme_create_preview (theme, PREVIEW_SIZE);\n\t\tgtk_list_store_append (GTK_LIST_STORE (GET_WIDGET (\"theme_liststore\")), &iter);\n\t\tgtk_list_store_set (GTK_LIST_STORE (GET_WIDGET (\"theme_liststore\")), &iter,\n\t\t\t\t    THEME_COLUMN_THEME, theme,\n\t\t\t\t    THEME_COLUMN_DISPLAY_NAME, theme->display_name,\n\t\t\t\t    THEME_COLUMN_PREVIEW, preview,\n\t\t\t\t    -1);\n\n\t\t_g_object_unref (preview);\n\t\tg_key_file_free (key_file);\n\t\tg_free (buffer);\n\t\tg_object_unref (file);\n\t\tg_object_unref (file_info);\n\t}\n\n\tg_object_unref (enumerator);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -53,6 +53,7 @@\n \t\t\tg_free (buffer);\n \t\t\tg_object_unref (file);\n \t\t\tg_object_unref (file_info);\n+\t\t\tcontinue;\n \t\t}\n \n \t\ttheme = gth_contact_sheet_theme_new_from_key_file (key_file);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\t\tcontinue;"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-1000877",
        "func_name": "libarchive/parse_codes",
        "description": "libarchive version commit 416694915449219d505531b1096384f3237dd6cc onwards (release v3.1.0 onwards) contains a CWE-415: Double Free vulnerability in RAR decoder - libarchive/archive_read_support_format_rar.c, parse_codes(), realloc(rar->lzss.window, new_size) with new_size = 0 that can result in Crash/DoS. This attack appear to be exploitable via the victim must open a specially crafted RAR archive.",
        "git_url": "https://github.com/libarchive/libarchive/commit/021efa522ad729ff0f5806c4ce53e4a6cc1daa31",
        "commit_title": "Avoid a double-free when a window size of 0 is specified",
        "commit_text": " new_size can be 0 with a malicious or corrupted RAR archive.  realloc(area, 0) is equivalent to free(area), so the region would be free()d here and the free()d again in the cleanup function.  Found with a setup running AFL, afl-rb, and qsym.",
        "func_before": "static int\nparse_codes(struct archive_read *a)\n{\n  int i, j, val, n, r;\n  unsigned char bitlengths[MAX_SYMBOLS], zerocount, ppmd_flags;\n  unsigned int maxorder;\n  struct huffman_code precode;\n  struct rar *rar = (struct rar *)(a->format->data);\n  struct rar_br *br = &(rar->br);\n\n  free_codes(a);\n\n  /* Skip to the next byte */\n  rar_br_consume_unalined_bits(br);\n\n  /* PPMd block flag */\n  if (!rar_br_read_ahead(a, br, 1))\n    goto truncated_data;\n  if ((rar->is_ppmd_block = rar_br_bits(br, 1)) != 0)\n  {\n    rar_br_consume(br, 1);\n    if (!rar_br_read_ahead(a, br, 7))\n      goto truncated_data;\n    ppmd_flags = rar_br_bits(br, 7);\n    rar_br_consume(br, 7);\n\n    /* Memory is allocated in MB */\n    if (ppmd_flags & 0x20)\n    {\n      if (!rar_br_read_ahead(a, br, 8))\n        goto truncated_data;\n      rar->dictionary_size = (rar_br_bits(br, 8) + 1) << 20;\n      rar_br_consume(br, 8);\n    }\n\n    if (ppmd_flags & 0x40)\n    {\n      if (!rar_br_read_ahead(a, br, 8))\n        goto truncated_data;\n      rar->ppmd_escape = rar->ppmd7_context.InitEsc = rar_br_bits(br, 8);\n      rar_br_consume(br, 8);\n    }\n    else\n      rar->ppmd_escape = 2;\n\n    if (ppmd_flags & 0x20)\n    {\n      maxorder = (ppmd_flags & 0x1F) + 1;\n      if(maxorder > 16)\n        maxorder = 16 + (maxorder - 16) * 3;\n\n      if (maxorder == 1)\n      {\n        archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                          \"Truncated RAR file data\");\n        return (ARCHIVE_FATAL);\n      }\n\n      /* Make sure ppmd7_contest is freed before Ppmd7_Construct\n       * because reading a broken file cause this abnormal sequence. */\n      __archive_ppmd7_functions.Ppmd7_Free(&rar->ppmd7_context);\n\n      rar->bytein.a = a;\n      rar->bytein.Read = &ppmd_read;\n      __archive_ppmd7_functions.PpmdRAR_RangeDec_CreateVTable(&rar->range_dec);\n      rar->range_dec.Stream = &rar->bytein;\n      __archive_ppmd7_functions.Ppmd7_Construct(&rar->ppmd7_context);\n\n      if (rar->dictionary_size == 0) {\n\t      archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                          \"Invalid zero dictionary size\");\n\t      return (ARCHIVE_FATAL);\n      }\n\n      if (!__archive_ppmd7_functions.Ppmd7_Alloc(&rar->ppmd7_context,\n        rar->dictionary_size))\n      {\n        archive_set_error(&a->archive, ENOMEM,\n                          \"Out of memory\");\n        return (ARCHIVE_FATAL);\n      }\n      if (!__archive_ppmd7_functions.PpmdRAR_RangeDec_Init(&rar->range_dec))\n      {\n        archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                          \"Unable to initialize PPMd range decoder\");\n        return (ARCHIVE_FATAL);\n      }\n      __archive_ppmd7_functions.Ppmd7_Init(&rar->ppmd7_context, maxorder);\n      rar->ppmd_valid = 1;\n    }\n    else\n    {\n      if (!rar->ppmd_valid) {\n        archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                          \"Invalid PPMd sequence\");\n        return (ARCHIVE_FATAL);\n      }\n      if (!__archive_ppmd7_functions.PpmdRAR_RangeDec_Init(&rar->range_dec))\n      {\n        archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                          \"Unable to initialize PPMd range decoder\");\n        return (ARCHIVE_FATAL);\n      }\n    }\n  }\n  else\n  {\n    rar_br_consume(br, 1);\n\n    /* Keep existing table flag */\n    if (!rar_br_read_ahead(a, br, 1))\n      goto truncated_data;\n    if (!rar_br_bits(br, 1))\n      memset(rar->lengthtable, 0, sizeof(rar->lengthtable));\n    rar_br_consume(br, 1);\n\n    memset(&bitlengths, 0, sizeof(bitlengths));\n    for (i = 0; i < MAX_SYMBOLS;)\n    {\n      if (!rar_br_read_ahead(a, br, 4))\n        goto truncated_data;\n      bitlengths[i++] = rar_br_bits(br, 4);\n      rar_br_consume(br, 4);\n      if (bitlengths[i-1] == 0xF)\n      {\n        if (!rar_br_read_ahead(a, br, 4))\n          goto truncated_data;\n        zerocount = rar_br_bits(br, 4);\n        rar_br_consume(br, 4);\n        if (zerocount)\n        {\n          i--;\n          for (j = 0; j < zerocount + 2 && i < MAX_SYMBOLS; j++)\n            bitlengths[i++] = 0;\n        }\n      }\n    }\n\n    memset(&precode, 0, sizeof(precode));\n    r = create_code(a, &precode, bitlengths, MAX_SYMBOLS, MAX_SYMBOL_LENGTH);\n    if (r != ARCHIVE_OK) {\n      free(precode.tree);\n      free(precode.table);\n      return (r);\n    }\n\n    for (i = 0; i < HUFFMAN_TABLE_SIZE;)\n    {\n      if ((val = read_next_symbol(a, &precode)) < 0) {\n        free(precode.tree);\n        free(precode.table);\n        return (ARCHIVE_FATAL);\n      }\n      if (val < 16)\n      {\n        rar->lengthtable[i] = (rar->lengthtable[i] + val) & 0xF;\n        i++;\n      }\n      else if (val < 18)\n      {\n        if (i == 0)\n        {\n          free(precode.tree);\n          free(precode.table);\n          archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                            \"Internal error extracting RAR file.\");\n          return (ARCHIVE_FATAL);\n        }\n\n        if(val == 16) {\n          if (!rar_br_read_ahead(a, br, 3)) {\n            free(precode.tree);\n            free(precode.table);\n            goto truncated_data;\n          }\n          n = rar_br_bits(br, 3) + 3;\n          rar_br_consume(br, 3);\n        } else {\n          if (!rar_br_read_ahead(a, br, 7)) {\n            free(precode.tree);\n            free(precode.table);\n            goto truncated_data;\n          }\n          n = rar_br_bits(br, 7) + 11;\n          rar_br_consume(br, 7);\n        }\n\n        for (j = 0; j < n && i < HUFFMAN_TABLE_SIZE; j++)\n        {\n          rar->lengthtable[i] = rar->lengthtable[i-1];\n          i++;\n        }\n      }\n      else\n      {\n        if(val == 18) {\n          if (!rar_br_read_ahead(a, br, 3)) {\n            free(precode.tree);\n            free(precode.table);\n            goto truncated_data;\n          }\n          n = rar_br_bits(br, 3) + 3;\n          rar_br_consume(br, 3);\n        } else {\n          if (!rar_br_read_ahead(a, br, 7)) {\n            free(precode.tree);\n            free(precode.table);\n            goto truncated_data;\n          }\n          n = rar_br_bits(br, 7) + 11;\n          rar_br_consume(br, 7);\n        }\n\n        for(j = 0; j < n && i < HUFFMAN_TABLE_SIZE; j++)\n          rar->lengthtable[i++] = 0;\n      }\n    }\n    free(precode.tree);\n    free(precode.table);\n\n    r = create_code(a, &rar->maincode, &rar->lengthtable[0], MAINCODE_SIZE,\n                MAX_SYMBOL_LENGTH);\n    if (r != ARCHIVE_OK)\n      return (r);\n    r = create_code(a, &rar->offsetcode, &rar->lengthtable[MAINCODE_SIZE],\n                OFFSETCODE_SIZE, MAX_SYMBOL_LENGTH);\n    if (r != ARCHIVE_OK)\n      return (r);\n    r = create_code(a, &rar->lowoffsetcode,\n                &rar->lengthtable[MAINCODE_SIZE + OFFSETCODE_SIZE],\n                LOWOFFSETCODE_SIZE, MAX_SYMBOL_LENGTH);\n    if (r != ARCHIVE_OK)\n      return (r);\n    r = create_code(a, &rar->lengthcode,\n                &rar->lengthtable[MAINCODE_SIZE + OFFSETCODE_SIZE +\n                LOWOFFSETCODE_SIZE], LENGTHCODE_SIZE, MAX_SYMBOL_LENGTH);\n    if (r != ARCHIVE_OK)\n      return (r);\n  }\n\n  if (!rar->dictionary_size || !rar->lzss.window)\n  {\n    /* Seems as though dictionary sizes are not used. Even so, minimize\n     * memory usage as much as possible.\n     */\n    void *new_window;\n    unsigned int new_size;\n\n    if (rar->unp_size >= DICTIONARY_MAX_SIZE)\n      new_size = DICTIONARY_MAX_SIZE;\n    else\n      new_size = rar_fls((unsigned int)rar->unp_size) << 1;\n    new_window = realloc(rar->lzss.window, new_size);\n    if (new_window == NULL) {\n      archive_set_error(&a->archive, ENOMEM,\n                        \"Unable to allocate memory for uncompressed data.\");\n      return (ARCHIVE_FATAL);\n    }\n    rar->lzss.window = (unsigned char *)new_window;\n    rar->dictionary_size = new_size;\n    memset(rar->lzss.window, 0, rar->dictionary_size);\n    rar->lzss.mask = rar->dictionary_size - 1;\n  }\n\n  rar->start_new_table = 0;\n  return (ARCHIVE_OK);\ntruncated_data:\n  archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                    \"Truncated RAR file data\");\n  rar->valid = 0;\n  return (ARCHIVE_FATAL);\n}",
        "func": "static int\nparse_codes(struct archive_read *a)\n{\n  int i, j, val, n, r;\n  unsigned char bitlengths[MAX_SYMBOLS], zerocount, ppmd_flags;\n  unsigned int maxorder;\n  struct huffman_code precode;\n  struct rar *rar = (struct rar *)(a->format->data);\n  struct rar_br *br = &(rar->br);\n\n  free_codes(a);\n\n  /* Skip to the next byte */\n  rar_br_consume_unalined_bits(br);\n\n  /* PPMd block flag */\n  if (!rar_br_read_ahead(a, br, 1))\n    goto truncated_data;\n  if ((rar->is_ppmd_block = rar_br_bits(br, 1)) != 0)\n  {\n    rar_br_consume(br, 1);\n    if (!rar_br_read_ahead(a, br, 7))\n      goto truncated_data;\n    ppmd_flags = rar_br_bits(br, 7);\n    rar_br_consume(br, 7);\n\n    /* Memory is allocated in MB */\n    if (ppmd_flags & 0x20)\n    {\n      if (!rar_br_read_ahead(a, br, 8))\n        goto truncated_data;\n      rar->dictionary_size = (rar_br_bits(br, 8) + 1) << 20;\n      rar_br_consume(br, 8);\n    }\n\n    if (ppmd_flags & 0x40)\n    {\n      if (!rar_br_read_ahead(a, br, 8))\n        goto truncated_data;\n      rar->ppmd_escape = rar->ppmd7_context.InitEsc = rar_br_bits(br, 8);\n      rar_br_consume(br, 8);\n    }\n    else\n      rar->ppmd_escape = 2;\n\n    if (ppmd_flags & 0x20)\n    {\n      maxorder = (ppmd_flags & 0x1F) + 1;\n      if(maxorder > 16)\n        maxorder = 16 + (maxorder - 16) * 3;\n\n      if (maxorder == 1)\n      {\n        archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                          \"Truncated RAR file data\");\n        return (ARCHIVE_FATAL);\n      }\n\n      /* Make sure ppmd7_contest is freed before Ppmd7_Construct\n       * because reading a broken file cause this abnormal sequence. */\n      __archive_ppmd7_functions.Ppmd7_Free(&rar->ppmd7_context);\n\n      rar->bytein.a = a;\n      rar->bytein.Read = &ppmd_read;\n      __archive_ppmd7_functions.PpmdRAR_RangeDec_CreateVTable(&rar->range_dec);\n      rar->range_dec.Stream = &rar->bytein;\n      __archive_ppmd7_functions.Ppmd7_Construct(&rar->ppmd7_context);\n\n      if (rar->dictionary_size == 0) {\n\t      archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                          \"Invalid zero dictionary size\");\n\t      return (ARCHIVE_FATAL);\n      }\n\n      if (!__archive_ppmd7_functions.Ppmd7_Alloc(&rar->ppmd7_context,\n        rar->dictionary_size))\n      {\n        archive_set_error(&a->archive, ENOMEM,\n                          \"Out of memory\");\n        return (ARCHIVE_FATAL);\n      }\n      if (!__archive_ppmd7_functions.PpmdRAR_RangeDec_Init(&rar->range_dec))\n      {\n        archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                          \"Unable to initialize PPMd range decoder\");\n        return (ARCHIVE_FATAL);\n      }\n      __archive_ppmd7_functions.Ppmd7_Init(&rar->ppmd7_context, maxorder);\n      rar->ppmd_valid = 1;\n    }\n    else\n    {\n      if (!rar->ppmd_valid) {\n        archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                          \"Invalid PPMd sequence\");\n        return (ARCHIVE_FATAL);\n      }\n      if (!__archive_ppmd7_functions.PpmdRAR_RangeDec_Init(&rar->range_dec))\n      {\n        archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                          \"Unable to initialize PPMd range decoder\");\n        return (ARCHIVE_FATAL);\n      }\n    }\n  }\n  else\n  {\n    rar_br_consume(br, 1);\n\n    /* Keep existing table flag */\n    if (!rar_br_read_ahead(a, br, 1))\n      goto truncated_data;\n    if (!rar_br_bits(br, 1))\n      memset(rar->lengthtable, 0, sizeof(rar->lengthtable));\n    rar_br_consume(br, 1);\n\n    memset(&bitlengths, 0, sizeof(bitlengths));\n    for (i = 0; i < MAX_SYMBOLS;)\n    {\n      if (!rar_br_read_ahead(a, br, 4))\n        goto truncated_data;\n      bitlengths[i++] = rar_br_bits(br, 4);\n      rar_br_consume(br, 4);\n      if (bitlengths[i-1] == 0xF)\n      {\n        if (!rar_br_read_ahead(a, br, 4))\n          goto truncated_data;\n        zerocount = rar_br_bits(br, 4);\n        rar_br_consume(br, 4);\n        if (zerocount)\n        {\n          i--;\n          for (j = 0; j < zerocount + 2 && i < MAX_SYMBOLS; j++)\n            bitlengths[i++] = 0;\n        }\n      }\n    }\n\n    memset(&precode, 0, sizeof(precode));\n    r = create_code(a, &precode, bitlengths, MAX_SYMBOLS, MAX_SYMBOL_LENGTH);\n    if (r != ARCHIVE_OK) {\n      free(precode.tree);\n      free(precode.table);\n      return (r);\n    }\n\n    for (i = 0; i < HUFFMAN_TABLE_SIZE;)\n    {\n      if ((val = read_next_symbol(a, &precode)) < 0) {\n        free(precode.tree);\n        free(precode.table);\n        return (ARCHIVE_FATAL);\n      }\n      if (val < 16)\n      {\n        rar->lengthtable[i] = (rar->lengthtable[i] + val) & 0xF;\n        i++;\n      }\n      else if (val < 18)\n      {\n        if (i == 0)\n        {\n          free(precode.tree);\n          free(precode.table);\n          archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                            \"Internal error extracting RAR file.\");\n          return (ARCHIVE_FATAL);\n        }\n\n        if(val == 16) {\n          if (!rar_br_read_ahead(a, br, 3)) {\n            free(precode.tree);\n            free(precode.table);\n            goto truncated_data;\n          }\n          n = rar_br_bits(br, 3) + 3;\n          rar_br_consume(br, 3);\n        } else {\n          if (!rar_br_read_ahead(a, br, 7)) {\n            free(precode.tree);\n            free(precode.table);\n            goto truncated_data;\n          }\n          n = rar_br_bits(br, 7) + 11;\n          rar_br_consume(br, 7);\n        }\n\n        for (j = 0; j < n && i < HUFFMAN_TABLE_SIZE; j++)\n        {\n          rar->lengthtable[i] = rar->lengthtable[i-1];\n          i++;\n        }\n      }\n      else\n      {\n        if(val == 18) {\n          if (!rar_br_read_ahead(a, br, 3)) {\n            free(precode.tree);\n            free(precode.table);\n            goto truncated_data;\n          }\n          n = rar_br_bits(br, 3) + 3;\n          rar_br_consume(br, 3);\n        } else {\n          if (!rar_br_read_ahead(a, br, 7)) {\n            free(precode.tree);\n            free(precode.table);\n            goto truncated_data;\n          }\n          n = rar_br_bits(br, 7) + 11;\n          rar_br_consume(br, 7);\n        }\n\n        for(j = 0; j < n && i < HUFFMAN_TABLE_SIZE; j++)\n          rar->lengthtable[i++] = 0;\n      }\n    }\n    free(precode.tree);\n    free(precode.table);\n\n    r = create_code(a, &rar->maincode, &rar->lengthtable[0], MAINCODE_SIZE,\n                MAX_SYMBOL_LENGTH);\n    if (r != ARCHIVE_OK)\n      return (r);\n    r = create_code(a, &rar->offsetcode, &rar->lengthtable[MAINCODE_SIZE],\n                OFFSETCODE_SIZE, MAX_SYMBOL_LENGTH);\n    if (r != ARCHIVE_OK)\n      return (r);\n    r = create_code(a, &rar->lowoffsetcode,\n                &rar->lengthtable[MAINCODE_SIZE + OFFSETCODE_SIZE],\n                LOWOFFSETCODE_SIZE, MAX_SYMBOL_LENGTH);\n    if (r != ARCHIVE_OK)\n      return (r);\n    r = create_code(a, &rar->lengthcode,\n                &rar->lengthtable[MAINCODE_SIZE + OFFSETCODE_SIZE +\n                LOWOFFSETCODE_SIZE], LENGTHCODE_SIZE, MAX_SYMBOL_LENGTH);\n    if (r != ARCHIVE_OK)\n      return (r);\n  }\n\n  if (!rar->dictionary_size || !rar->lzss.window)\n  {\n    /* Seems as though dictionary sizes are not used. Even so, minimize\n     * memory usage as much as possible.\n     */\n    void *new_window;\n    unsigned int new_size;\n\n    if (rar->unp_size >= DICTIONARY_MAX_SIZE)\n      new_size = DICTIONARY_MAX_SIZE;\n    else\n      new_size = rar_fls((unsigned int)rar->unp_size) << 1;\n    if (new_size == 0) {\n      archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                        \"Zero window size is invalid.\");\n      return (ARCHIVE_FATAL);\n    }\n    new_window = realloc(rar->lzss.window, new_size);\n    if (new_window == NULL) {\n      archive_set_error(&a->archive, ENOMEM,\n                        \"Unable to allocate memory for uncompressed data.\");\n      return (ARCHIVE_FATAL);\n    }\n    rar->lzss.window = (unsigned char *)new_window;\n    rar->dictionary_size = new_size;\n    memset(rar->lzss.window, 0, rar->dictionary_size);\n    rar->lzss.mask = rar->dictionary_size - 1;\n  }\n\n  rar->start_new_table = 0;\n  return (ARCHIVE_OK);\ntruncated_data:\n  archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n                    \"Truncated RAR file data\");\n  rar->valid = 0;\n  return (ARCHIVE_FATAL);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -250,6 +250,11 @@\n       new_size = DICTIONARY_MAX_SIZE;\n     else\n       new_size = rar_fls((unsigned int)rar->unp_size) << 1;\n+    if (new_size == 0) {\n+      archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,\n+                        \"Zero window size is invalid.\");\n+      return (ARCHIVE_FATAL);\n+    }\n     new_window = realloc(rar->lzss.window, new_size);\n     if (new_window == NULL) {\n       archive_set_error(&a->archive, ENOMEM,",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    if (new_size == 0) {",
                "      archive_set_error(&a->archive, ARCHIVE_ERRNO_FILE_FORMAT,",
                "                        \"Zero window size is invalid.\");",
                "      return (ARCHIVE_FATAL);",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-42459",
        "func_name": "eProsima/Fast-DDS/MessageReceiver::proc_Submsg_Data",
        "description": "Fast DDS is a C++ implementation of the DDS (Data Distribution Service) standard of the OMG (Object Management Group). In affected versions specific DATA submessages can be sent to a discovery locator which may trigger a free error. This can remotely crash any Fast-DDS process. The call to free() could potentially leave the pointer in the attackers control which could lead to a double free. This issue has been addressed in versions 2.12.0, 2.11.3, 2.10.3, and 2.6.7. Users are advised to upgrade. There are no known workarounds for this vulnerability.\n",
        "git_url": "https://github.com/eProsima/Fast-DDS/commit/6fdbe790fe814c8799860bf896742bae58b7bf35",
        "commit_title": "Refs #16784. Fix issue.",
        "commit_text": "",
        "func_before": "bool MessageReceiver::proc_Submsg_Data(\n        CDRMessage_t* msg,\n        SubmessageHeader_t* smh,\n        EntityId_t& writerID) const\n{\n    eprosima::shared_lock<eprosima::shared_mutex> guard(mtx_);\n\n    //READ and PROCESS\n    if (smh->submessageLength < RTPSMESSAGE_DATA_MIN_LENGTH)\n    {\n        EPROSIMA_LOG_INFO(RTPS_MSG_IN, IDSTRING \"Too short submessage received, ignoring\");\n        return false;\n    }\n    //Fill flags bool values\n    bool endiannessFlag = (smh->flags & BIT(0)) != 0;\n    bool inlineQosFlag = (smh->flags & BIT(1)) != 0;\n    bool dataFlag = (smh->flags & BIT(2)) != 0;\n    bool keyFlag = (smh->flags & BIT(3)) != 0;\n    if (keyFlag && dataFlag)\n    {\n        EPROSIMA_LOG_WARNING(RTPS_MSG_IN, IDSTRING \"Message received with Data and Key Flag set, ignoring\");\n        return false;\n    }\n\n    //Assign message endianness\n    if (endiannessFlag)\n    {\n        msg->msg_endian = LITTLEEND;\n    }\n    else\n    {\n        msg->msg_endian = BIGEND;\n    }\n\n    //Extra flags don't matter now. Avoid those bytes\n    msg->pos += 2;\n\n    bool valid = true;\n    int16_t octetsToInlineQos = 0;\n    valid &= CDRMessage::readInt16(msg, &octetsToInlineQos); //it should be 16 in this implementation\n\n    //reader and writer ID\n    RTPSReader* first_reader = nullptr;\n    EntityId_t readerID;\n    valid &= CDRMessage::readEntityId(msg, &readerID);\n\n    //WE KNOW THE READER THAT THE MESSAGE IS DIRECTED TO SO WE LOOK FOR IT:\n    if (!willAReaderAcceptMsgDirectedTo(readerID, first_reader))\n    {\n        return false;\n    }\n\n    //FOUND THE READER.\n    //We ask the reader for a cachechange to store the information.\n    CacheChange_t ch;\n    ch.kind = ALIVE;\n    ch.writerGUID.guidPrefix = source_guid_prefix_;\n    valid &= CDRMessage::readEntityId(msg, &ch.writerGUID.entityId);\n\n    writerID = ch.writerGUID.entityId;\n\n    //Get sequence number\n    valid &= CDRMessage::readSequenceNumber(msg, &ch.sequenceNumber);\n\n    if (!valid)\n    {\n        return false;\n    }\n\n    if (ch.sequenceNumber <= SequenceNumber_t())\n    {\n        EPROSIMA_LOG_WARNING(RTPS_MSG_IN, IDSTRING \"Invalid message received, bad sequence Number\");\n        return false;\n    }\n\n    //Jump ahead if more parameters are before inlineQos (not in this version, maybe if further minor versions.)\n    if (octetsToInlineQos > RTPSMESSAGE_OCTETSTOINLINEQOS_DATASUBMSG)\n    {\n        msg->pos += (octetsToInlineQos - RTPSMESSAGE_OCTETSTOINLINEQOS_DATASUBMSG);\n        if (msg->pos > msg->length)\n        {\n            EPROSIMA_LOG_WARNING(RTPS_MSG_IN,\n                    IDSTRING \"Invalid jump through msg, msg->pos \" << msg->pos << \" > msg->length \" << msg->length);\n            return false;\n        }\n    }\n\n    uint32_t inlineQosSize = 0;\n\n    if (inlineQosFlag)\n    {\n        if (!ParameterList::updateCacheChangeFromInlineQos(ch, msg, inlineQosSize))\n        {\n            EPROSIMA_LOG_INFO(RTPS_MSG_IN, IDSTRING \"SubMessage Data ERROR, Inline Qos ParameterList error\");\n            return false;\n        }\n        ch.inline_qos.data = &msg->buffer[msg->pos - inlineQosSize];\n        ch.inline_qos.max_size = inlineQosSize;\n        ch.inline_qos.length = inlineQosSize;\n        ch.inline_qos.encapsulation = endiannessFlag ? PL_CDR_LE : PL_CDR_BE;\n        ch.inline_qos.pos = 0;\n    }\n\n    if (dataFlag || keyFlag)\n    {\n        uint32_t payload_size;\n        payload_size = smh->submessageLength -\n                (RTPSMESSAGE_DATA_EXTRA_INLINEQOS_SIZE + octetsToInlineQos + inlineQosSize);\n\n        if (dataFlag)\n        {\n            uint32_t next_pos = msg->pos + payload_size;\n            if (msg->length >= next_pos && payload_size > 0)\n            {\n                ch.serializedPayload.data = &msg->buffer[msg->pos];\n                ch.serializedPayload.length = payload_size;\n                ch.serializedPayload.max_size = payload_size;\n                msg->pos = next_pos;\n            }\n            else\n            {\n                EPROSIMA_LOG_WARNING(RTPS_MSG_IN, IDSTRING \"Serialized Payload value invalid or larger than maximum allowed size\"\n                        \"(\" << payload_size << \"/\" << (msg->length - msg->pos) << \")\");\n                return false;\n            }\n        }\n        else if (keyFlag)\n        {\n            if (payload_size <= 0)\n            {\n                EPROSIMA_LOG_WARNING(RTPS_MSG_IN, IDSTRING \"Serialized Payload value invalid (\" << payload_size << \")\");\n                return false;\n            }\n\n            if (payload_size <= PARAMETER_KEY_HASH_LENGTH)\n            {\n                memcpy(ch.instanceHandle.value, &msg->buffer[msg->pos], payload_size);\n            }\n            else\n            {\n                EPROSIMA_LOG_WARNING(RTPS_MSG_IN, IDSTRING \"Ignoring Serialized Payload for too large key-only data (\" <<\n                        payload_size << \")\");\n            }\n            msg->pos += payload_size;\n        }\n    }\n\n    // Set sourcetimestamp\n    if (have_timestamp_)\n    {\n        ch.sourceTimestamp = timestamp_;\n    }\n\n    EPROSIMA_LOG_INFO(RTPS_MSG_IN, IDSTRING \"from Writer \" << ch.writerGUID << \"; possible RTPSReader entities: \" <<\n            associated_readers_.size());\n\n    //Look for the correct reader to add the change\n    process_data_message_function_(readerID, ch);\n\n    IPayloadPool* payload_pool = ch.payload_owner();\n    if (payload_pool)\n    {\n        payload_pool->release_payload(ch);\n    }\n\n    //TODO(Ricardo) If an exception is thrown (ex, by fastcdr), these lines are not executed -> segmentation fault\n    ch.serializedPayload.data = nullptr;\n    ch.inline_qos.data = nullptr;\n\n    EPROSIMA_LOG_INFO(RTPS_MSG_IN, IDSTRING \"Sub Message DATA processed\");\n    return true;\n}",
        "func": "bool MessageReceiver::proc_Submsg_Data(\n        CDRMessage_t* msg,\n        SubmessageHeader_t* smh,\n        EntityId_t& writerID) const\n{\n    eprosima::shared_lock<eprosima::shared_mutex> guard(mtx_);\n\n    //READ and PROCESS\n    if (smh->submessageLength < RTPSMESSAGE_DATA_MIN_LENGTH)\n    {\n        EPROSIMA_LOG_INFO(RTPS_MSG_IN, IDSTRING \"Too short submessage received, ignoring\");\n        return false;\n    }\n    //Fill flags bool values\n    bool endiannessFlag = (smh->flags & BIT(0)) != 0;\n    bool inlineQosFlag = (smh->flags & BIT(1)) != 0;\n    bool dataFlag = (smh->flags & BIT(2)) != 0;\n    bool keyFlag = (smh->flags & BIT(3)) != 0;\n    if (keyFlag && dataFlag)\n    {\n        EPROSIMA_LOG_WARNING(RTPS_MSG_IN, IDSTRING \"Message received with Data and Key Flag set, ignoring\");\n        return false;\n    }\n\n    //Assign message endianness\n    if (endiannessFlag)\n    {\n        msg->msg_endian = LITTLEEND;\n    }\n    else\n    {\n        msg->msg_endian = BIGEND;\n    }\n\n    //Extra flags don't matter now. Avoid those bytes\n    msg->pos += 2;\n\n    bool valid = true;\n    int16_t octetsToInlineQos = 0;\n    valid &= CDRMessage::readInt16(msg, &octetsToInlineQos); //it should be 16 in this implementation\n\n    //reader and writer ID\n    RTPSReader* first_reader = nullptr;\n    EntityId_t readerID;\n    valid &= CDRMessage::readEntityId(msg, &readerID);\n\n    //WE KNOW THE READER THAT THE MESSAGE IS DIRECTED TO SO WE LOOK FOR IT:\n    if (!willAReaderAcceptMsgDirectedTo(readerID, first_reader))\n    {\n        return false;\n    }\n\n    //FOUND THE READER.\n    //We ask the reader for a cachechange to store the information.\n    CacheChange_t ch;\n    ch.kind = ALIVE;\n    ch.writerGUID.guidPrefix = source_guid_prefix_;\n    valid &= CDRMessage::readEntityId(msg, &ch.writerGUID.entityId);\n\n    writerID = ch.writerGUID.entityId;\n\n    //Get sequence number\n    valid &= CDRMessage::readSequenceNumber(msg, &ch.sequenceNumber);\n\n    if (!valid)\n    {\n        return false;\n    }\n\n    if (ch.sequenceNumber <= SequenceNumber_t())\n    {\n        EPROSIMA_LOG_WARNING(RTPS_MSG_IN, IDSTRING \"Invalid message received, bad sequence Number\");\n        return false;\n    }\n\n    //Jump ahead if more parameters are before inlineQos (not in this version, maybe if further minor versions.)\n    if (octetsToInlineQos > RTPSMESSAGE_OCTETSTOINLINEQOS_DATASUBMSG)\n    {\n        msg->pos += (octetsToInlineQos - RTPSMESSAGE_OCTETSTOINLINEQOS_DATASUBMSG);\n        if (msg->pos > msg->length)\n        {\n            EPROSIMA_LOG_WARNING(RTPS_MSG_IN,\n                    IDSTRING \"Invalid jump through msg, msg->pos \" << msg->pos << \" > msg->length \" << msg->length);\n            return false;\n        }\n    }\n\n    uint32_t inlineQosSize = 0;\n\n    if (inlineQosFlag)\n    {\n        if (!ParameterList::updateCacheChangeFromInlineQos(ch, msg, inlineQosSize))\n        {\n            EPROSIMA_LOG_INFO(RTPS_MSG_IN, IDSTRING \"SubMessage Data ERROR, Inline Qos ParameterList error\");\n            return false;\n        }\n        ch.inline_qos.data = &msg->buffer[msg->pos - inlineQosSize];\n        ch.inline_qos.max_size = inlineQosSize;\n        ch.inline_qos.length = inlineQosSize;\n        ch.inline_qos.encapsulation = endiannessFlag ? PL_CDR_LE : PL_CDR_BE;\n        ch.inline_qos.pos = 0;\n    }\n\n    if (dataFlag || keyFlag)\n    {\n        uint32_t payload_size;\n        payload_size = smh->submessageLength -\n                (RTPSMESSAGE_DATA_EXTRA_INLINEQOS_SIZE + octetsToInlineQos + inlineQosSize);\n\n        if (dataFlag)\n        {\n            uint32_t next_pos = msg->pos + payload_size;\n            if (msg->length >= next_pos && payload_size > 0)\n            {\n                ch.serializedPayload.data = &msg->buffer[msg->pos];\n                ch.serializedPayload.length = payload_size;\n                ch.serializedPayload.max_size = payload_size;\n                msg->pos = next_pos;\n            }\n            else\n            {\n                EPROSIMA_LOG_WARNING(RTPS_MSG_IN, IDSTRING \"Serialized Payload value invalid or larger than maximum allowed size\"\n                        \"(\" << payload_size << \"/\" << (msg->length - msg->pos) << \")\");\n                ch.serializedPayload.data = nullptr;\n                ch.inline_qos.data = nullptr;\n                return false;\n            }\n        }\n        else if (keyFlag)\n        {\n            if (payload_size <= 0)\n            {\n                EPROSIMA_LOG_WARNING(RTPS_MSG_IN, IDSTRING \"Serialized Payload value invalid (\" << payload_size << \")\");\n                ch.serializedPayload.data = nullptr;\n                ch.inline_qos.data = nullptr;\n                return false;\n            }\n\n            if (payload_size <= PARAMETER_KEY_HASH_LENGTH)\n            {\n                memcpy(ch.instanceHandle.value, &msg->buffer[msg->pos], payload_size);\n            }\n            else\n            {\n                EPROSIMA_LOG_WARNING(RTPS_MSG_IN, IDSTRING \"Ignoring Serialized Payload for too large key-only data (\" <<\n                        payload_size << \")\");\n            }\n            msg->pos += payload_size;\n        }\n    }\n\n    // Set sourcetimestamp\n    if (have_timestamp_)\n    {\n        ch.sourceTimestamp = timestamp_;\n    }\n\n    EPROSIMA_LOG_INFO(RTPS_MSG_IN, IDSTRING \"from Writer \" << ch.writerGUID << \"; possible RTPSReader entities: \" <<\n            associated_readers_.size());\n\n    //Look for the correct reader to add the change\n    process_data_message_function_(readerID, ch);\n\n    IPayloadPool* payload_pool = ch.payload_owner();\n    if (payload_pool)\n    {\n        payload_pool->release_payload(ch);\n    }\n\n    //TODO(Ricardo) If an exception is thrown (ex, by fastcdr), these lines are not executed -> segmentation fault\n    ch.serializedPayload.data = nullptr;\n    ch.inline_qos.data = nullptr;\n\n    EPROSIMA_LOG_INFO(RTPS_MSG_IN, IDSTRING \"Sub Message DATA processed\");\n    return true;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -121,6 +121,8 @@\n             {\n                 EPROSIMA_LOG_WARNING(RTPS_MSG_IN, IDSTRING \"Serialized Payload value invalid or larger than maximum allowed size\"\n                         \"(\" << payload_size << \"/\" << (msg->length - msg->pos) << \")\");\n+                ch.serializedPayload.data = nullptr;\n+                ch.inline_qos.data = nullptr;\n                 return false;\n             }\n         }\n@@ -129,6 +131,8 @@\n             if (payload_size <= 0)\n             {\n                 EPROSIMA_LOG_WARNING(RTPS_MSG_IN, IDSTRING \"Serialized Payload value invalid (\" << payload_size << \")\");\n+                ch.serializedPayload.data = nullptr;\n+                ch.inline_qos.data = nullptr;\n                 return false;\n             }\n ",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "                ch.serializedPayload.data = nullptr;",
                "                ch.inline_qos.data = nullptr;",
                "                ch.serializedPayload.data = nullptr;",
                "                ch.inline_qos.data = nullptr;"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-48013",
        "func_name": "gpac/isor_reader_get_sample",
        "description": "GPAC v2.3-DEV-rev566-g50c2ab06f-master was discovered to contain a double free via the gf_filterpacket_del function at /gpac/src/filter_core/filter.c.",
        "git_url": "https://github.com/gpac/gpac/commit/cd8a95c1efb8f5bfc950b86c2ef77b4c76f6b893",
        "commit_title": "Fixed #2612",
        "commit_text": "",
        "func_before": "void isor_reader_get_sample(ISOMChannel *ch)\n{\n\tGF_Err e;\n\tBool skip_sample=GF_FALSE;\n\tu32 sample_desc_index;\n\tif (ch->sample) return;\n\n\tif (ch->next_track) {\n\t\tch->track = ch->next_track;\n\t\tif (!ch->owner->nodata)\n\t\t\tgf_isom_set_sample_alloc(ch->owner->mov, ch->track, isor_sample_alloc, ch);\n\t\tch->next_track = 0;\n\t}\n\n\tif (ch->to_init) {\n\t\tif (!ch->owner->nodata)\n\t\t\tgf_isom_set_sample_alloc(ch->owner->mov, ch->track, isor_sample_alloc, ch);\n\t\tinit_reader(ch);\n\t\tsample_desc_index = ch->last_sample_desc_index;\n\t} else if (ch->speed < 0) {\n\t\tif (ch->last_state == GF_EOS) {\n\t\t\tch->sample = NULL;\n\t\t\treturn;\n\t\t}\n\n\t\tif (ch->static_sample->IsRAP) {\n\t\t\tch->last_rap_sample_time = ch->sample_time;\n\t\t}\n\n\t\te = gf_isom_get_sample_for_movie_time(ch->owner->mov, ch->track, ch->sample_time + 1, &sample_desc_index, GF_ISOM_SEARCH_FORWARD, &ch->static_sample, &ch->sample_num, NULL);\n\t\tch->static_sample->alloc_size = 0;\n\n\t\tif ((e==GF_EOS) || (ch->static_sample->IsRAP)) {\n\t\t\tif (!ch->last_rap_sample_time) {\n\t\t\t\te = GF_EOS;\n\t\t\t} else {\n\t\t\t\te = gf_isom_get_sample_for_movie_time(ch->owner->mov, ch->track, ch->last_rap_sample_time - 1, &sample_desc_index, GF_ISOM_SEARCH_SYNC_BACKWARD, &ch->static_sample, &ch->sample_num, NULL);\n\t\t\t\tch->static_sample->alloc_size = 0;\n\t\t\t}\n\t\t}\n\n\t\tif (e) {\n\t\t\tif ((e==GF_EOS) && !ch->owner->frag_type) {\n\t\t\t\tch->last_state = GF_EOS;\n\t\t\t}\n\t\t\tch->sample = NULL;\n\t\t\treturn;\n\t\t}\n\t\tch->sample = ch->static_sample;\n\n\t\tif (ch->sample->DTS == ch->sample_time) {\n\t\t\tif (!ch->owner->frag_type) {\n\t\t\t\tch->last_state = GF_EOS;\n\t\t\t}\n\t\t}\n\t\tif (ch->sample) {\n\t\t\tch->sample_time = ch->sample->DTS;\n\t\t}\n\n\t} else if (ch->has_edit_list) {\n\t\tu32 prev_sample = ch->sample_num;\n\t\te = gf_isom_get_sample_for_movie_time(ch->owner->mov, ch->track, ch->sample_time + 1, &sample_desc_index, GF_ISOM_SEARCH_FORWARD, &ch->static_sample, &ch->sample_num, &ch->sample_data_offset);\n\t\tch->static_sample->alloc_size = 0;\n\n\t\tif (e == GF_OK) {\n\t\t\tch->sample = ch->static_sample;\n\n\t\t\t/*we are in forced seek mode: fetch all samples before the one matching the sample time*/\n\t\t\tif (ch->edit_sync_frame) {\n\t\t\t\tch->edit_sync_frame++;\n\t\t\t\tif (ch->edit_sync_frame < ch->sample_num) {\n\t\t\t\t\tch->sample = gf_isom_get_sample_ex(ch->owner->mov, ch->track, ch->edit_sync_frame, &sample_desc_index, ch->static_sample, &ch->sample_data_offset);\n\t\t\t\t\tif (ch->sample) {\n\t\t\t\t\t\tch->sample->DTS = ch->sample_time;\n\t\t\t\t\t\tch->sample->CTS_Offset = 0;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tch->edit_sync_frame = 0;\n\t\t\t\t\tif (ch->sample) ch->sample_time = ch->sample->DTS;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/*if we get the same sample, figure out next interesting time (current sample + DTS gap to next sample should be a good bet)*/\n\t\t\t\tif (prev_sample == ch->sample_num) {\n\t\t\t\t\tif (ch->owner->frag_type && (ch->sample_num==gf_isom_get_sample_count(ch->owner->mov, ch->track))) {\n\t\t\t\t\t\tch->sample = NULL;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tu32 sample_num = ch->sample_num ? ch->sample_num : 1;\n\n\t\t\t\t\t\tif (sample_num >= gf_isom_get_sample_count(ch->owner->mov, ch->track) ) {\n\t\t\t\t\t\t\t//e = GF_EOS;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tu32 time_diff = gf_isom_get_sample_duration(ch->owner->mov, ch->track, sample_num);\n\t\t\t\t\t\t\te = gf_isom_get_sample_for_movie_time(ch->owner->mov, ch->track, ch->sample_time + time_diff, &sample_desc_index, GF_ISOM_SEARCH_FORWARD, &ch->static_sample, &ch->sample_num, &ch->sample_data_offset);\n\t\t\t\t\t\t\tch->static_sample->alloc_size = 0;\n\t\t\t\t\t\t\tif (e==GF_OK) {\n\t\t\t\t\t\t\t\tif (ch->sample_num == prev_sample) {\n\t\t\t\t\t\t\t\t\tch->sample_time += time_diff;\n\t\t\t\t\t\t\t\t\tch->sample = NULL;\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tch->sample = ch->static_sample;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/*we jumped to another segment - if RAP is needed look for closest rap in decoding order and\n\t\t\t\tforce seek mode*/\n\t\t\t\tif (ch->sample && !ch->sample->IsRAP && ch->has_rap && (ch->sample_num != prev_sample+1)) {\n\t\t\t\t\tGF_ISOSample *found = ch->static_sample;\n\t\t\t\t\tu32 samp_num = ch->sample_num;\n\t\t\t\t\tch->sample = NULL;\n\t\t\t\t\te = gf_isom_get_sample_for_movie_time(ch->owner->mov, ch->track, ch->sample_time + 1, &sample_desc_index, GF_ISOM_SEARCH_SYNC_BACKWARD, &ch->static_sample, &ch->sample_num, &ch->sample_data_offset);\n\n\t\t\t\t\tch->static_sample->alloc_size = 0;\n\t\t\t\t\tch->sample = (e == GF_OK) ? ch->static_sample : NULL;\n\n\t\t\t\t\t/*if no sync point in the past, use the first non-sync for the given time*/\n\t\t\t\t\tif (!ch->sample || !ch->sample->data) {\n\t\t\t\t\t\tch->sample = ch->static_sample = found;\n\t\t\t\t\t\tch->sample_time = ch->sample->DTS;\n\t\t\t\t\t\tch->sample_num = samp_num;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tch->sample = ch->static_sample;\n\t\t\t\t\t\tch->edit_sync_frame = ch->sample_num;\n\t\t\t\t\t\tch->sample->DTS = ch->sample_time;\n\t\t\t\t\t\tch->sample->CTS_Offset = 0;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (ch->sample) ch->sample_time = ch->sample->DTS;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tBool do_fetch = GF_TRUE;\n\t\tch->sample_num++;\n\t\tif (ch->sample_last && (ch->sample_last<ch->sample_num)) {\n\t\t\tch->sample = NULL;\n\t\t\tch->last_state = GF_EOS;\n\t\t\tch->playing = 2;\n\t\t\treturn;\n\t\t}\n\n\t\tif (ch->sap_only) {\n\t\t\tBool is_rap = gf_isom_get_sample_sync(ch->owner->mov, ch->track, ch->sample_num);\n\t\t\tif (!is_rap) {\n\t\t\t\tGF_ISOSampleRollType roll_type;\n\t\t\t\tgf_isom_get_sample_rap_roll_info(ch->owner->mov, ch->track, ch->sample_num, &is_rap, &roll_type, NULL);\n\t\t\t\tif (roll_type) is_rap = GF_TRUE;\n\t\t\t}\n\n\t\t\tif (!is_rap) {\n\t\t\t\tdo_fetch = GF_FALSE;\n\t\t\t} else if (ch->sap_only==2) {\n\t\t\t\tch->sap_only = 0;\n\t\t\t}\n\t\t}\n\t\tif (do_fetch) {\n\t\t\tif (ch->owner->nodata) {\n\t\t\t\tch->sample = gf_isom_get_sample_info_ex(ch->owner->mov, ch->track, ch->sample_num, &sample_desc_index, &ch->sample_data_offset, ch->static_sample);\n\t\t\t} else {\n\t\t\t\tch->sample = gf_isom_get_sample_ex(ch->owner->mov, ch->track, ch->sample_num, &sample_desc_index, ch->static_sample, &ch->sample_data_offset);\n\t\t\t}\n\t\t\t/*if sync shadow / carousel RAP skip*/\n\t\t\tif (ch->sample && (ch->sample->IsRAP==RAP_REDUNDANT)) {\n\t\t\t\tch->sample = NULL;\n\t\t\t\tch->sample_num++;\n\t\t\t\tif (ch->pck) {\n\t\t\t\t\tgf_filter_pck_discard(ch->pck);\n\t\t\t\t\tch->pck = NULL;\n\t\t\t\t\tch->static_sample->alloc_size = ch->static_sample->dataLength = 0;\n\t\t\t\t}\n\t\t\t\tisor_reader_get_sample(ch);\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\tskip_sample = GF_TRUE;\n\t\t}\n\t}\n\n\t//check scalable track change\n\tif (ch->sample && ch->sample->IsRAP && ch->next_track) {\n\t\tch->track = ch->next_track;\n\t\tch->next_track = 0;\n\t\tch->sample = NULL;\n\t\tif (ch->pck) {\n\t\t\tgf_filter_pck_discard(ch->pck);\n\t\t\tch->pck = NULL;\n\t\t}\n\t\tisor_reader_get_sample(ch);\n\t\treturn;\n\t}\n\n\tif (!ch->sample) {\n\t\tu32 sample_count = gf_isom_get_sample_count(ch->owner->mov, ch->track);\n\t\tch->sample_data_offset = 0;\n\t\t/*incomplete file - check if we're still downloading or not*/\n\t\tif (gf_isom_get_missing_bytes(ch->owner->mov, ch->track)) {\n\t\t\tch->last_state = GF_ISOM_INCOMPLETE_FILE;\n\t\t\tif (ch->owner->mem_load_mode==2)\n\t\t\t\tch->owner->force_fetch = GF_TRUE;\n\n\t\t\tif (!ch->owner->input_loaded) {\n\t\t\t\tch->last_state = GF_OK;\n\t\t\t\tif (!ch->has_edit_list && ch->sample_num)\n\t\t\t\t\tch->sample_num--;\n\t\t\t} else {\n\t\t\t\tif (ch->to_init && ch->sample_num) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[IsoMedia] Failed to fetch initial sample %d for track %d\\n\", ch->sample_num, ch->track));\n\t\t\t\t\tch->last_state = GF_ISOM_INVALID_FILE;\n\t\t\t\t} else {\n\t\t\t\t\tif (!ch->eos_sent) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[IsoMedia] File truncated, aborting read for track %d\\n\", ch->track));\n\t\t\t\t\t}\n\t\t\t\t\tch->last_state = GF_EOS;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (!ch->sample_num\n\t\t         || ((ch->speed >= 0) && (ch->sample_num >= sample_count))\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t         || ((ch->speed < 0) && (ch->sample_time == gf_isom_get_current_tfdt(ch->owner->mov, ch->track) ))\n#endif\n\t\t) {\n\n\t\t\tif (ch->owner->frag_type==1) {\n\t\t\t\t/*if sample cannot be found and file is fragmented, rewind sample*/\n\t\t\t\tif (ch->sample_num) ch->sample_num--;\n\t\t\t\tch->last_state = GF_EOS;\n\t\t\t} else if (ch->last_state != GF_EOS) {\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[IsoMedia] Track #%d end of stream reached\\n\", ch->track));\n\t\t\t\tch->last_state = GF_EOS;\n\t\t\t\tif (ch->sample_num>sample_count) ch->sample_num = sample_count;\n\t\t\t} else {\n\t\t\t\tif (ch->sample_num>sample_count) ch->sample_num = sample_count;\n\t\t\t}\n\t\t} else if (!skip_sample) {\n\t\t\te = gf_isom_last_error(ch->owner->mov);\n\t\t\tGF_LOG((e==GF_ISOM_INCOMPLETE_FILE) ? GF_LOG_DEBUG : GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[IsoMedia] Track #%d fail to fetch sample %d / %d: %s\\n\", ch->track, ch->sample_num, gf_isom_get_sample_count(ch->owner->mov, ch->track), gf_error_to_string(e) ));\n\n\t\t\tif ((e<GF_OK) && (e!=GF_ISOM_INCOMPLETE_FILE)) {\n\t\t\t\tch->last_state = GF_EOS;\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\n\t//first sample fetched has DTS, we have a tfdt so ignore the hinted one\n\tif ((ch->sample_num==1) && ch->hint_first_tfdt && ch->sample->DTS) {\n\t\tch->hint_first_tfdt = 0;\n\t}\n\tch->sample->DTS += ch->hint_first_tfdt;\n\n\tif (sample_desc_index != ch->last_sample_desc_index) {\n\t\tif (!ch->owner->stsd) {\n\t\t\t//we used sample entry 1 by default to setup, if no active prev sample (edit list might trigger this)\n\t\t\t//and new sample desc is 1, do not reconfigure\n\t\t\tif (!ch->last_sample_desc_index && (sample_desc_index==1)) {\n\n\t\t\t} else {\n\t\t\t\tch->needs_pid_reconfig = 1;\n\t\t\t}\n\t\t}\n\t\tch->last_sample_desc_index = sample_desc_index;\n\t}\n\n\tch->last_state = GF_OK;\n\n\tch->sap_3 = GF_FALSE;\n\tch->sap_4_type = 0;\n\tch->roll = 0;\n\n\tif (ch->sample) {\n\t\tgf_isom_get_sample_rap_roll_info(ch->owner->mov, ch->track, ch->sample_num, &ch->sap_3, &ch->sap_4_type, &ch->roll);\n\n\t\t/*still seeking or not ?\n\t\t 1- when speed is negative, the RAP found is \"after\" the seek point in playback order since we used backward RAP search: nothing to do\n\t\t 2- otherwise set DTS+CTS to start value\n\t\t */\n\t\tif ((ch->speed < 0) || (ch->start <= ch->sample->DTS + ch->sample->CTS_Offset)) {\n\t\t\tch->dts = ch->sample->DTS;\n\t\t\tch->cts = ch->sample->DTS + ch->sample->CTS_Offset;\n\t\t\tch->seek_flag = 0;\n\t\t} else {\n\t\t\tch->cts = ch->start;\n\t\t\tch->seek_flag = 1;\n\t\t\tch->dts = ch->start;\n\t\t}\n\n\t\tif (ch->end && (ch->end < ch->sample->DTS + ch->sample->CTS_Offset + ch->sample->duration)) {\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[IsoMedia] End of Channel \"LLD\" (CTS \"LLD\")\\n\", ch->end, ch->sample->DTS + ch->sample->CTS_Offset));\n\t\t\tch->sample = NULL;\n\t\t\tch->last_state = GF_EOS;\n\t\t\tch->playing = 2;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (ch->owner->last_sender_ntp && ch->cts==ch->owner->cts_for_last_sender_ntp) {\n\t\tch->sender_ntp = ch->owner->last_sender_ntp;\n\t\tch->ntp_at_server_ntp = ch->owner->ntp_at_last_sender_ntp;\n\t} else if (ch->owner->last_sender_ntp && ch->dts==ch->owner->cts_for_last_sender_ntp) {\n\t\tch->sender_ntp = ch->owner->last_sender_ntp;\n\t\tch->ntp_at_server_ntp = ch->owner->ntp_at_last_sender_ntp;\n\t} else {\n\t\tch->sender_ntp = ch->ntp_at_server_ntp = 0;\n\t}\n\n\tif (!ch->sample_num) return;\n\n\tgf_isom_get_sample_flags(ch->owner->mov, ch->track, ch->sample_num, &ch->isLeading, &ch->dependsOn, &ch->dependedOn, &ch->redundant);\n\n\tif (ch->is_encrypted) {\n\t\t/*in case of CENC: we write sample auxiliary information to slh->sai; its size is in saiz*/\n\t\tif (gf_isom_is_cenc_media(ch->owner->mov, ch->track, ch->last_sample_desc_index)) {\n\t\t\tisor_update_cenc_info(ch, GF_FALSE);\n\n\t\t} else if (gf_isom_is_media_encrypted(ch->owner->mov, ch->track, ch->last_sample_desc_index)) {\n\t\t\tch->pck_encrypted = GF_TRUE;\n\t\t} else {\n\t\t\tch->pck_encrypted = GF_FALSE;\n\t\t}\n\t}\n\tif (ch->sample && ch->sample->nb_pack)\n\t\tch->sample_num += ch->sample->nb_pack-1;\n}",
        "func": "void isor_reader_get_sample(ISOMChannel *ch)\n{\n\tGF_Err e;\n\tBool skip_sample=GF_FALSE;\n\tu32 sample_desc_index;\n\tif (ch->sample) return;\n\n\tif (ch->next_track) {\n\t\tch->track = ch->next_track;\n\t\tif (!ch->owner->nodata)\n\t\t\tgf_isom_set_sample_alloc(ch->owner->mov, ch->track, isor_sample_alloc, ch);\n\t\tch->next_track = 0;\n\t}\n\n\tif (ch->to_init) {\n\t\tif (!ch->owner->nodata)\n\t\t\tgf_isom_set_sample_alloc(ch->owner->mov, ch->track, isor_sample_alloc, ch);\n\t\tinit_reader(ch);\n\t\tsample_desc_index = ch->last_sample_desc_index;\n\t} else if (ch->speed < 0) {\n\t\tif (ch->last_state == GF_EOS) {\n\t\t\tch->sample = NULL;\n\t\t\treturn;\n\t\t}\n\n\t\tif (ch->static_sample->IsRAP) {\n\t\t\tch->last_rap_sample_time = ch->sample_time;\n\t\t}\n\n\t\te = gf_isom_get_sample_for_movie_time(ch->owner->mov, ch->track, ch->sample_time + 1, &sample_desc_index, GF_ISOM_SEARCH_FORWARD, &ch->static_sample, &ch->sample_num, NULL);\n\t\tch->static_sample->alloc_size = 0;\n\n\t\tif ((e==GF_EOS) || (ch->static_sample->IsRAP)) {\n\t\t\tif (!ch->last_rap_sample_time) {\n\t\t\t\te = GF_EOS;\n\t\t\t} else {\n\t\t\t\te = gf_isom_get_sample_for_movie_time(ch->owner->mov, ch->track, ch->last_rap_sample_time - 1, &sample_desc_index, GF_ISOM_SEARCH_SYNC_BACKWARD, &ch->static_sample, &ch->sample_num, NULL);\n\t\t\t\tch->static_sample->alloc_size = 0;\n\t\t\t}\n\t\t}\n\n\t\tif (e) {\n\t\t\tif ((e==GF_EOS) && !ch->owner->frag_type) {\n\t\t\t\tch->last_state = GF_EOS;\n\t\t\t}\n\t\t\tch->sample = NULL;\n\t\t\treturn;\n\t\t}\n\t\tch->sample = ch->static_sample;\n\n\t\tif (ch->sample->DTS == ch->sample_time) {\n\t\t\tif (!ch->owner->frag_type) {\n\t\t\t\tch->last_state = GF_EOS;\n\t\t\t}\n\t\t}\n\t\tif (ch->sample) {\n\t\t\tch->sample_time = ch->sample->DTS;\n\t\t}\n\n\t} else if (ch->has_edit_list) {\n\t\tu32 prev_sample = ch->sample_num;\n\t\te = gf_isom_get_sample_for_movie_time(ch->owner->mov, ch->track, ch->sample_time + 1, &sample_desc_index, GF_ISOM_SEARCH_FORWARD, &ch->static_sample, &ch->sample_num, &ch->sample_data_offset);\n\t\tch->static_sample->alloc_size = 0;\n\n\t\tif (e == GF_OK) {\n\t\t\tch->sample = ch->static_sample;\n\n\t\t\t/*we are in forced seek mode: fetch all samples before the one matching the sample time*/\n\t\t\tif (ch->edit_sync_frame) {\n\t\t\t\tch->edit_sync_frame++;\n\t\t\t\tif (ch->edit_sync_frame < ch->sample_num) {\n\t\t\t\t\tch->static_sample->alloc_size = 0;\n\t\t\t\t\tch->static_sample->dataLength = 0;\n\t\t\t\t\tch->sample = gf_isom_get_sample_ex(ch->owner->mov, ch->track, ch->edit_sync_frame, &sample_desc_index, ch->static_sample, &ch->sample_data_offset);\n\t\t\t\t\tif (ch->sample) {\n\t\t\t\t\t\tch->sample->DTS = ch->sample_time;\n\t\t\t\t\t\tch->sample->CTS_Offset = 0;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tch->edit_sync_frame = 0;\n\t\t\t\t\tif (ch->sample) ch->sample_time = ch->sample->DTS;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/*if we get the same sample, figure out next interesting time (current sample + DTS gap to next sample should be a good bet)*/\n\t\t\t\tif (prev_sample == ch->sample_num) {\n\t\t\t\t\tif (ch->owner->frag_type && (ch->sample_num==gf_isom_get_sample_count(ch->owner->mov, ch->track))) {\n\t\t\t\t\t\tch->sample = NULL;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tu32 sample_num = ch->sample_num ? ch->sample_num : 1;\n\n\t\t\t\t\t\tif (sample_num >= gf_isom_get_sample_count(ch->owner->mov, ch->track) ) {\n\t\t\t\t\t\t\t//e = GF_EOS;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tu32 time_diff = gf_isom_get_sample_duration(ch->owner->mov, ch->track, sample_num);\n\n\t\t\t\t\t\t\tch->static_sample->alloc_size = 0;\n\t\t\t\t\t\t\tch->static_sample->dataLength = 0;\n\n\t\t\t\t\t\t\te = gf_isom_get_sample_for_movie_time(ch->owner->mov, ch->track, ch->sample_time + time_diff, &sample_desc_index, GF_ISOM_SEARCH_FORWARD, &ch->static_sample, &ch->sample_num, &ch->sample_data_offset);\n\t\t\t\t\t\t\tch->static_sample->alloc_size = 0;\n\t\t\t\t\t\t\tif (e==GF_OK) {\n\t\t\t\t\t\t\t\tif (ch->sample_num == prev_sample) {\n\t\t\t\t\t\t\t\t\tch->sample_time += time_diff;\n\t\t\t\t\t\t\t\t\tch->sample = NULL;\n\t\t\t\t\t\t\t\t\tif (ch->pck) {\n\t\t\t\t\t\t\t\t\t\tgf_filter_pck_discard(ch->pck);\n\t\t\t\t\t\t\t\t\t\tch->pck = NULL;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tch->sample = ch->static_sample;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/*we jumped to another segment - if RAP is needed look for closest rap in decoding order and\n\t\t\t\tforce seek mode*/\n\t\t\t\tif (ch->sample && !ch->sample->IsRAP && ch->has_rap && (ch->sample_num != prev_sample+1)) {\n\t\t\t\t\tGF_ISOSample *found = ch->static_sample;\n\t\t\t\t\tu32 samp_num = ch->sample_num;\n\t\t\t\t\tch->sample = NULL;\n\t\t\t\t\tch->static_sample->alloc_size = 0;\n\t\t\t\t\tch->static_sample->dataLength = 0;\n\t\t\t\t\te = gf_isom_get_sample_for_movie_time(ch->owner->mov, ch->track, ch->sample_time + 1, &sample_desc_index, GF_ISOM_SEARCH_SYNC_BACKWARD, &ch->static_sample, &ch->sample_num, &ch->sample_data_offset);\n\n\t\t\t\t\tch->static_sample->alloc_size = 0;\n\t\t\t\t\tch->sample = (e == GF_OK) ? ch->static_sample : NULL;\n\n\t\t\t\t\t/*if no sync point in the past, use the first non-sync for the given time*/\n\t\t\t\t\tif (!ch->sample || !ch->sample->data) {\n\t\t\t\t\t\tch->sample = ch->static_sample = found;\n\t\t\t\t\t\tch->sample_time = ch->sample->DTS;\n\t\t\t\t\t\tch->sample_num = samp_num;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tch->sample = ch->static_sample;\n\t\t\t\t\t\tch->edit_sync_frame = ch->sample_num;\n\t\t\t\t\t\tch->sample->DTS = ch->sample_time;\n\t\t\t\t\t\tch->sample->CTS_Offset = 0;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (ch->sample) ch->sample_time = ch->sample->DTS;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\tBool do_fetch = GF_TRUE;\n\t\tch->sample_num++;\n\t\tif (ch->sample_last && (ch->sample_last<ch->sample_num)) {\n\t\t\tch->sample = NULL;\n\t\t\tch->last_state = GF_EOS;\n\t\t\tch->playing = 2;\n\t\t\treturn;\n\t\t}\n\n\t\tif (ch->sap_only) {\n\t\t\tBool is_rap = gf_isom_get_sample_sync(ch->owner->mov, ch->track, ch->sample_num);\n\t\t\tif (!is_rap) {\n\t\t\t\tGF_ISOSampleRollType roll_type;\n\t\t\t\tgf_isom_get_sample_rap_roll_info(ch->owner->mov, ch->track, ch->sample_num, &is_rap, &roll_type, NULL);\n\t\t\t\tif (roll_type) is_rap = GF_TRUE;\n\t\t\t}\n\n\t\t\tif (!is_rap) {\n\t\t\t\tdo_fetch = GF_FALSE;\n\t\t\t} else if (ch->sap_only==2) {\n\t\t\t\tch->sap_only = 0;\n\t\t\t}\n\t\t}\n\t\tif (do_fetch) {\n\t\t\tif (ch->owner->nodata) {\n\t\t\t\tch->sample = gf_isom_get_sample_info_ex(ch->owner->mov, ch->track, ch->sample_num, &sample_desc_index, &ch->sample_data_offset, ch->static_sample);\n\t\t\t} else {\n\t\t\t\tch->sample = gf_isom_get_sample_ex(ch->owner->mov, ch->track, ch->sample_num, &sample_desc_index, ch->static_sample, &ch->sample_data_offset);\n\t\t\t}\n\t\t\t/*if sync shadow / carousel RAP skip*/\n\t\t\tif (ch->sample && (ch->sample->IsRAP==RAP_REDUNDANT)) {\n\t\t\t\tch->sample = NULL;\n\t\t\t\tch->sample_num++;\n\t\t\t\tif (ch->pck) {\n\t\t\t\t\tgf_filter_pck_discard(ch->pck);\n\t\t\t\t\tch->pck = NULL;\n\t\t\t\t\tch->static_sample->alloc_size = ch->static_sample->dataLength = 0;\n\t\t\t\t}\n\t\t\t\tisor_reader_get_sample(ch);\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\tskip_sample = GF_TRUE;\n\t\t}\n\t}\n\n\t//check scalable track change\n\tif (ch->sample && ch->sample->IsRAP && ch->next_track) {\n\t\tch->track = ch->next_track;\n\t\tch->next_track = 0;\n\t\tch->sample = NULL;\n\t\tif (ch->pck) {\n\t\t\tgf_filter_pck_discard(ch->pck);\n\t\t\tch->pck = NULL;\n\t\t}\n\t\tisor_reader_get_sample(ch);\n\t\treturn;\n\t}\n\n\tif (!ch->sample) {\n\t\tu32 sample_count = gf_isom_get_sample_count(ch->owner->mov, ch->track);\n\t\tch->sample_data_offset = 0;\n\t\t/*incomplete file - check if we're still downloading or not*/\n\t\tif (gf_isom_get_missing_bytes(ch->owner->mov, ch->track)) {\n\t\t\tch->last_state = GF_ISOM_INCOMPLETE_FILE;\n\t\t\tif (ch->owner->mem_load_mode==2)\n\t\t\t\tch->owner->force_fetch = GF_TRUE;\n\n\t\t\tif (!ch->owner->input_loaded) {\n\t\t\t\tch->last_state = GF_OK;\n\t\t\t\tif (!ch->has_edit_list && ch->sample_num)\n\t\t\t\t\tch->sample_num--;\n\t\t\t} else {\n\t\t\t\tif (ch->to_init && ch->sample_num) {\n\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[IsoMedia] Failed to fetch initial sample %d for track %d\\n\", ch->sample_num, ch->track));\n\t\t\t\t\tch->last_state = GF_ISOM_INVALID_FILE;\n\t\t\t\t} else {\n\t\t\t\t\tif (!ch->eos_sent) {\n\t\t\t\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[IsoMedia] File truncated, aborting read for track %d\\n\", ch->track));\n\t\t\t\t\t}\n\t\t\t\t\tch->last_state = GF_EOS;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (!ch->sample_num\n\t\t         || ((ch->speed >= 0) && (ch->sample_num >= sample_count))\n#ifndef GPAC_DISABLE_ISOM_FRAGMENTS\n\t\t         || ((ch->speed < 0) && (ch->sample_time == gf_isom_get_current_tfdt(ch->owner->mov, ch->track) ))\n#endif\n\t\t) {\n\n\t\t\tif (ch->owner->frag_type==1) {\n\t\t\t\t/*if sample cannot be found and file is fragmented, rewind sample*/\n\t\t\t\tif (ch->sample_num) ch->sample_num--;\n\t\t\t\tch->last_state = GF_EOS;\n\t\t\t} else if (ch->last_state != GF_EOS) {\n\t\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[IsoMedia] Track #%d end of stream reached\\n\", ch->track));\n\t\t\t\tch->last_state = GF_EOS;\n\t\t\t\tif (ch->sample_num>sample_count) ch->sample_num = sample_count;\n\t\t\t} else {\n\t\t\t\tif (ch->sample_num>sample_count) ch->sample_num = sample_count;\n\t\t\t}\n\t\t} else if (!skip_sample) {\n\t\t\te = gf_isom_last_error(ch->owner->mov);\n\t\t\tGF_LOG((e==GF_ISOM_INCOMPLETE_FILE) ? GF_LOG_DEBUG : GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[IsoMedia] Track #%d fail to fetch sample %d / %d: %s\\n\", ch->track, ch->sample_num, gf_isom_get_sample_count(ch->owner->mov, ch->track), gf_error_to_string(e) ));\n\n\t\t\tif ((e<GF_OK) && (e!=GF_ISOM_INCOMPLETE_FILE)) {\n\t\t\t\tch->last_state = GF_EOS;\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\n\t//first sample fetched has DTS, we have a tfdt so ignore the hinted one\n\tif ((ch->sample_num==1) && ch->hint_first_tfdt && ch->sample->DTS) {\n\t\tch->hint_first_tfdt = 0;\n\t}\n\tch->sample->DTS += ch->hint_first_tfdt;\n\n\tif (sample_desc_index != ch->last_sample_desc_index) {\n\t\tif (!ch->owner->stsd) {\n\t\t\t//we used sample entry 1 by default to setup, if no active prev sample (edit list might trigger this)\n\t\t\t//and new sample desc is 1, do not reconfigure\n\t\t\tif (!ch->last_sample_desc_index && (sample_desc_index==1)) {\n\n\t\t\t} else {\n\t\t\t\tch->needs_pid_reconfig = 1;\n\t\t\t}\n\t\t}\n\t\tch->last_sample_desc_index = sample_desc_index;\n\t}\n\n\tch->last_state = GF_OK;\n\n\tch->sap_3 = GF_FALSE;\n\tch->sap_4_type = 0;\n\tch->roll = 0;\n\n\tif (ch->sample) {\n\t\tgf_isom_get_sample_rap_roll_info(ch->owner->mov, ch->track, ch->sample_num, &ch->sap_3, &ch->sap_4_type, &ch->roll);\n\n\t\t/*still seeking or not ?\n\t\t 1- when speed is negative, the RAP found is \"after\" the seek point in playback order since we used backward RAP search: nothing to do\n\t\t 2- otherwise set DTS+CTS to start value\n\t\t */\n\t\tif ((ch->speed < 0) || (ch->start <= ch->sample->DTS + ch->sample->CTS_Offset)) {\n\t\t\tch->dts = ch->sample->DTS;\n\t\t\tch->cts = ch->sample->DTS + ch->sample->CTS_Offset;\n\t\t\tch->seek_flag = 0;\n\t\t} else {\n\t\t\tch->cts = ch->start;\n\t\t\tch->seek_flag = 1;\n\t\t\tch->dts = ch->start;\n\t\t}\n\n\t\tif (ch->end && (ch->end < ch->sample->DTS + ch->sample->CTS_Offset + ch->sample->duration)) {\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[IsoMedia] End of Channel \"LLD\" (CTS \"LLD\")\\n\", ch->end, ch->sample->DTS + ch->sample->CTS_Offset));\n\t\t\tch->sample = NULL;\n\t\t\tch->last_state = GF_EOS;\n\t\t\tch->playing = 2;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (ch->owner->last_sender_ntp && ch->cts==ch->owner->cts_for_last_sender_ntp) {\n\t\tch->sender_ntp = ch->owner->last_sender_ntp;\n\t\tch->ntp_at_server_ntp = ch->owner->ntp_at_last_sender_ntp;\n\t} else if (ch->owner->last_sender_ntp && ch->dts==ch->owner->cts_for_last_sender_ntp) {\n\t\tch->sender_ntp = ch->owner->last_sender_ntp;\n\t\tch->ntp_at_server_ntp = ch->owner->ntp_at_last_sender_ntp;\n\t} else {\n\t\tch->sender_ntp = ch->ntp_at_server_ntp = 0;\n\t}\n\n\tif (!ch->sample_num) return;\n\n\tgf_isom_get_sample_flags(ch->owner->mov, ch->track, ch->sample_num, &ch->isLeading, &ch->dependsOn, &ch->dependedOn, &ch->redundant);\n\n\tif (ch->is_encrypted) {\n\t\t/*in case of CENC: we write sample auxiliary information to slh->sai; its size is in saiz*/\n\t\tif (gf_isom_is_cenc_media(ch->owner->mov, ch->track, ch->last_sample_desc_index)) {\n\t\t\tisor_update_cenc_info(ch, GF_FALSE);\n\n\t\t} else if (gf_isom_is_media_encrypted(ch->owner->mov, ch->track, ch->last_sample_desc_index)) {\n\t\t\tch->pck_encrypted = GF_TRUE;\n\t\t} else {\n\t\t\tch->pck_encrypted = GF_FALSE;\n\t\t}\n\t}\n\tif (ch->sample && ch->sample->nb_pack)\n\t\tch->sample_num += ch->sample->nb_pack-1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -69,6 +69,8 @@\n \t\t\tif (ch->edit_sync_frame) {\n \t\t\t\tch->edit_sync_frame++;\n \t\t\t\tif (ch->edit_sync_frame < ch->sample_num) {\n+\t\t\t\t\tch->static_sample->alloc_size = 0;\n+\t\t\t\t\tch->static_sample->dataLength = 0;\n \t\t\t\t\tch->sample = gf_isom_get_sample_ex(ch->owner->mov, ch->track, ch->edit_sync_frame, &sample_desc_index, ch->static_sample, &ch->sample_data_offset);\n \t\t\t\t\tif (ch->sample) {\n \t\t\t\t\t\tch->sample->DTS = ch->sample_time;\n@@ -90,12 +92,20 @@\n \t\t\t\t\t\t\t//e = GF_EOS;\n \t\t\t\t\t\t} else {\n \t\t\t\t\t\t\tu32 time_diff = gf_isom_get_sample_duration(ch->owner->mov, ch->track, sample_num);\n+\n+\t\t\t\t\t\t\tch->static_sample->alloc_size = 0;\n+\t\t\t\t\t\t\tch->static_sample->dataLength = 0;\n+\n \t\t\t\t\t\t\te = gf_isom_get_sample_for_movie_time(ch->owner->mov, ch->track, ch->sample_time + time_diff, &sample_desc_index, GF_ISOM_SEARCH_FORWARD, &ch->static_sample, &ch->sample_num, &ch->sample_data_offset);\n \t\t\t\t\t\t\tch->static_sample->alloc_size = 0;\n \t\t\t\t\t\t\tif (e==GF_OK) {\n \t\t\t\t\t\t\t\tif (ch->sample_num == prev_sample) {\n \t\t\t\t\t\t\t\t\tch->sample_time += time_diff;\n \t\t\t\t\t\t\t\t\tch->sample = NULL;\n+\t\t\t\t\t\t\t\t\tif (ch->pck) {\n+\t\t\t\t\t\t\t\t\t\tgf_filter_pck_discard(ch->pck);\n+\t\t\t\t\t\t\t\t\t\tch->pck = NULL;\n+\t\t\t\t\t\t\t\t\t}\n \t\t\t\t\t\t\t\t\treturn;\n \t\t\t\t\t\t\t\t} else {\n \t\t\t\t\t\t\t\t\tch->sample = ch->static_sample;\n@@ -111,6 +121,8 @@\n \t\t\t\t\tGF_ISOSample *found = ch->static_sample;\n \t\t\t\t\tu32 samp_num = ch->sample_num;\n \t\t\t\t\tch->sample = NULL;\n+\t\t\t\t\tch->static_sample->alloc_size = 0;\n+\t\t\t\t\tch->static_sample->dataLength = 0;\n \t\t\t\t\te = gf_isom_get_sample_for_movie_time(ch->owner->mov, ch->track, ch->sample_time + 1, &sample_desc_index, GF_ISOM_SEARCH_SYNC_BACKWARD, &ch->static_sample, &ch->sample_num, &ch->sample_data_offset);\n \n \t\t\t\t\tch->static_sample->alloc_size = 0;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\t\t\t\tch->static_sample->alloc_size = 0;",
                "\t\t\t\t\tch->static_sample->dataLength = 0;",
                "",
                "\t\t\t\t\t\t\tch->static_sample->alloc_size = 0;",
                "\t\t\t\t\t\t\tch->static_sample->dataLength = 0;",
                "",
                "\t\t\t\t\t\t\t\t\tif (ch->pck) {",
                "\t\t\t\t\t\t\t\t\t\tgf_filter_pck_discard(ch->pck);",
                "\t\t\t\t\t\t\t\t\t\tch->pck = NULL;",
                "\t\t\t\t\t\t\t\t\t}",
                "\t\t\t\t\tch->static_sample->alloc_size = 0;",
                "\t\t\t\t\tch->static_sample->dataLength = 0;"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-8693",
        "func_name": "jasper-software/jasper/mem_resize",
        "description": "Double free vulnerability in the mem_close function in jas_stream.c in JasPer before 1.900.10 allows remote attackers to cause a denial of service (crash) or possibly execute arbitrary code via a crafted BMP image to the imginfo command.",
        "git_url": "https://github.com/jasper-software/jasper/commit/44a524e367597af58d6265ae2014468b334d0309",
        "commit_title": "The memory stream interface allows for a buffer size of zero.",
        "commit_text": "The case of a zero-sized buffer was not handled correctly, as it could lead to a double free. This problem has now been fixed (hopefully). One might ask whether a zero-sized buffer should be allowed at all, but this is a question for another day.",
        "func_before": "static int mem_resize(jas_stream_memobj_t *m, int bufsize)\n{\n\tunsigned char *buf;\n\n\tassert(m->buf_);\n\tassert(bufsize >= 0);\n\tif (!(buf = jas_realloc2(m->buf_, bufsize, sizeof(unsigned char)))) {\n\t\treturn -1;\n\t}\n\tm->buf_ = buf;\n\tm->bufsize_ = bufsize;\n\treturn 0;\n}",
        "func": "static int mem_resize(jas_stream_memobj_t *m, int bufsize)\n{\n\tunsigned char *buf;\n\n\t//assert(m->buf_);\n\tassert(bufsize >= 0);\n\tif (!(buf = jas_realloc2(m->buf_, bufsize, sizeof(unsigned char))) &&\n\t  bufsize) {\n\t\treturn -1;\n\t}\n\tm->buf_ = buf;\n\tm->bufsize_ = bufsize;\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,9 +2,10 @@\n {\n \tunsigned char *buf;\n \n-\tassert(m->buf_);\n+\t//assert(m->buf_);\n \tassert(bufsize >= 0);\n-\tif (!(buf = jas_realloc2(m->buf_, bufsize, sizeof(unsigned char)))) {\n+\tif (!(buf = jas_realloc2(m->buf_, bufsize, sizeof(unsigned char))) &&\n+\t  bufsize) {\n \t\treturn -1;\n \t}\n \tm->buf_ = buf;",
        "diff_line_info": {
            "deleted_lines": [
                "\tassert(m->buf_);",
                "\tif (!(buf = jas_realloc2(m->buf_, bufsize, sizeof(unsigned char)))) {"
            ],
            "added_lines": [
                "\t//assert(m->buf_);",
                "\tif (!(buf = jas_realloc2(m->buf_, bufsize, sizeof(unsigned char))) &&",
                "\t  bufsize) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-6074",
        "func_name": "torvalds/linux/dccp_rcv_state_process",
        "description": "The dccp_rcv_state_process function in net/dccp/input.c in the Linux kernel through 4.9.11 mishandles DCCP_PKT_REQUEST packet data structures in the LISTEN state, which allows local users to obtain root privileges or cause a denial of service (double free) via an application that makes an IPV6_RECVPKTINFO setsockopt system call.",
        "git_url": "https://github.com/torvalds/linux/commit/5edabca9d4cff7f1f2b68f0bac55ef99d9798ba4",
        "commit_title": "dccp: fix freeing skb too early for IPV6_RECVPKTINFO",
        "commit_text": " In the current DCCP implementation an skb for a DCCP_PKT_REQUEST packet is forcibly freed via __kfree_skb in dccp_rcv_state_process if dccp_v6_conn_request successfully returns.  However, if IPV6_RECVPKTINFO is set on a socket, the address of the skb is saved to ireq->pktopts and the ref count for skb is incremented in dccp_v6_conn_request, so skb is still in use. Nevertheless, it gets freed in dccp_rcv_state_process.  Fix by calling consume_skb instead of doing goto discard and therefore calling __kfree_skb.  Similar fixes for TCP:  fb7e2399ec17f1004c0e0ccfd17439f8759ede01 [TCP]: skb is unexpectedly freed. 0aea76d35c9651d55bbaf746e7914e5f9ae5a25d tcp: SYN packets are now simply consumed ",
        "func_before": "int dccp_rcv_state_process(struct sock *sk, struct sk_buff *skb,\n\t\t\t   struct dccp_hdr *dh, unsigned int len)\n{\n\tstruct dccp_sock *dp = dccp_sk(sk);\n\tstruct dccp_skb_cb *dcb = DCCP_SKB_CB(skb);\n\tconst int old_state = sk->sk_state;\n\tint queued = 0;\n\n\t/*\n\t *  Step 3: Process LISTEN state\n\t *\n\t *     If S.state == LISTEN,\n\t *\t If P.type == Request or P contains a valid Init Cookie option,\n\t *\t      (* Must scan the packet's options to check for Init\n\t *\t\t Cookies.  Only Init Cookies are processed here,\n\t *\t\t however; other options are processed in Step 8.  This\n\t *\t\t scan need only be performed if the endpoint uses Init\n\t *\t\t Cookies *)\n\t *\t      (* Generate a new socket and switch to that socket *)\n\t *\t      Set S := new socket for this port pair\n\t *\t      S.state = RESPOND\n\t *\t      Choose S.ISS (initial seqno) or set from Init Cookies\n\t *\t      Initialize S.GAR := S.ISS\n\t *\t      Set S.ISR, S.GSR, S.SWL, S.SWH from packet or Init\n\t *\t      Cookies Continue with S.state == RESPOND\n\t *\t      (* A Response packet will be generated in Step 11 *)\n\t *\t Otherwise,\n\t *\t      Generate Reset(No Connection) unless P.type == Reset\n\t *\t      Drop packet and return\n\t */\n\tif (sk->sk_state == DCCP_LISTEN) {\n\t\tif (dh->dccph_type == DCCP_PKT_REQUEST) {\n\t\t\tif (inet_csk(sk)->icsk_af_ops->conn_request(sk,\n\t\t\t\t\t\t\t\t    skb) < 0)\n\t\t\t\treturn 1;\n\t\t\tgoto discard;\n\t\t}\n\t\tif (dh->dccph_type == DCCP_PKT_RESET)\n\t\t\tgoto discard;\n\n\t\t/* Caller (dccp_v4_do_rcv) will send Reset */\n\t\tdcb->dccpd_reset_code = DCCP_RESET_CODE_NO_CONNECTION;\n\t\treturn 1;\n\t} else if (sk->sk_state == DCCP_CLOSED) {\n\t\tdcb->dccpd_reset_code = DCCP_RESET_CODE_NO_CONNECTION;\n\t\treturn 1;\n\t}\n\n\t/* Step 6: Check sequence numbers (omitted in LISTEN/REQUEST state) */\n\tif (sk->sk_state != DCCP_REQUESTING && dccp_check_seqno(sk, skb))\n\t\tgoto discard;\n\n\t/*\n\t *   Step 7: Check for unexpected packet types\n\t *      If (S.is_server and P.type == Response)\n\t *\t    or (S.is_client and P.type == Request)\n\t *\t    or (S.state == RESPOND and P.type == Data),\n\t *\t  Send Sync packet acknowledging P.seqno\n\t *\t  Drop packet and return\n\t */\n\tif ((dp->dccps_role != DCCP_ROLE_CLIENT &&\n\t     dh->dccph_type == DCCP_PKT_RESPONSE) ||\n\t    (dp->dccps_role == DCCP_ROLE_CLIENT &&\n\t     dh->dccph_type == DCCP_PKT_REQUEST) ||\n\t    (sk->sk_state == DCCP_RESPOND && dh->dccph_type == DCCP_PKT_DATA)) {\n\t\tdccp_send_sync(sk, dcb->dccpd_seq, DCCP_PKT_SYNC);\n\t\tgoto discard;\n\t}\n\n\t/*  Step 8: Process options */\n\tif (dccp_parse_options(sk, NULL, skb))\n\t\treturn 1;\n\n\t/*\n\t *  Step 9: Process Reset\n\t *\tIf P.type == Reset,\n\t *\t\tTear down connection\n\t *\t\tS.state := TIMEWAIT\n\t *\t\tSet TIMEWAIT timer\n\t *\t\tDrop packet and return\n\t */\n\tif (dh->dccph_type == DCCP_PKT_RESET) {\n\t\tdccp_rcv_reset(sk, skb);\n\t\treturn 0;\n\t} else if (dh->dccph_type == DCCP_PKT_CLOSEREQ) {\t/* Step 13 */\n\t\tif (dccp_rcv_closereq(sk, skb))\n\t\t\treturn 0;\n\t\tgoto discard;\n\t} else if (dh->dccph_type == DCCP_PKT_CLOSE) {\t\t/* Step 14 */\n\t\tif (dccp_rcv_close(sk, skb))\n\t\t\treturn 0;\n\t\tgoto discard;\n\t}\n\n\tswitch (sk->sk_state) {\n\tcase DCCP_REQUESTING:\n\t\tqueued = dccp_rcv_request_sent_state_process(sk, skb, dh, len);\n\t\tif (queued >= 0)\n\t\t\treturn queued;\n\n\t\t__kfree_skb(skb);\n\t\treturn 0;\n\n\tcase DCCP_PARTOPEN:\n\t\t/* Step 8: if using Ack Vectors, mark packet acknowledgeable */\n\t\tdccp_handle_ackvec_processing(sk, skb);\n\t\tdccp_deliver_input_to_ccids(sk, skb);\n\t\t/* fall through */\n\tcase DCCP_RESPOND:\n\t\tqueued = dccp_rcv_respond_partopen_state_process(sk, skb,\n\t\t\t\t\t\t\t\t dh, len);\n\t\tbreak;\n\t}\n\n\tif (dh->dccph_type == DCCP_PKT_ACK ||\n\t    dh->dccph_type == DCCP_PKT_DATAACK) {\n\t\tswitch (old_state) {\n\t\tcase DCCP_PARTOPEN:\n\t\t\tsk->sk_state_change(sk);\n\t\t\tsk_wake_async(sk, SOCK_WAKE_IO, POLL_OUT);\n\t\t\tbreak;\n\t\t}\n\t} else if (unlikely(dh->dccph_type == DCCP_PKT_SYNC)) {\n\t\tdccp_send_sync(sk, dcb->dccpd_seq, DCCP_PKT_SYNCACK);\n\t\tgoto discard;\n\t}\n\n\tif (!queued) {\ndiscard:\n\t\t__kfree_skb(skb);\n\t}\n\treturn 0;\n}",
        "func": "int dccp_rcv_state_process(struct sock *sk, struct sk_buff *skb,\n\t\t\t   struct dccp_hdr *dh, unsigned int len)\n{\n\tstruct dccp_sock *dp = dccp_sk(sk);\n\tstruct dccp_skb_cb *dcb = DCCP_SKB_CB(skb);\n\tconst int old_state = sk->sk_state;\n\tint queued = 0;\n\n\t/*\n\t *  Step 3: Process LISTEN state\n\t *\n\t *     If S.state == LISTEN,\n\t *\t If P.type == Request or P contains a valid Init Cookie option,\n\t *\t      (* Must scan the packet's options to check for Init\n\t *\t\t Cookies.  Only Init Cookies are processed here,\n\t *\t\t however; other options are processed in Step 8.  This\n\t *\t\t scan need only be performed if the endpoint uses Init\n\t *\t\t Cookies *)\n\t *\t      (* Generate a new socket and switch to that socket *)\n\t *\t      Set S := new socket for this port pair\n\t *\t      S.state = RESPOND\n\t *\t      Choose S.ISS (initial seqno) or set from Init Cookies\n\t *\t      Initialize S.GAR := S.ISS\n\t *\t      Set S.ISR, S.GSR, S.SWL, S.SWH from packet or Init\n\t *\t      Cookies Continue with S.state == RESPOND\n\t *\t      (* A Response packet will be generated in Step 11 *)\n\t *\t Otherwise,\n\t *\t      Generate Reset(No Connection) unless P.type == Reset\n\t *\t      Drop packet and return\n\t */\n\tif (sk->sk_state == DCCP_LISTEN) {\n\t\tif (dh->dccph_type == DCCP_PKT_REQUEST) {\n\t\t\tif (inet_csk(sk)->icsk_af_ops->conn_request(sk,\n\t\t\t\t\t\t\t\t    skb) < 0)\n\t\t\t\treturn 1;\n\t\t\tconsume_skb(skb);\n\t\t\treturn 0;\n\t\t}\n\t\tif (dh->dccph_type == DCCP_PKT_RESET)\n\t\t\tgoto discard;\n\n\t\t/* Caller (dccp_v4_do_rcv) will send Reset */\n\t\tdcb->dccpd_reset_code = DCCP_RESET_CODE_NO_CONNECTION;\n\t\treturn 1;\n\t} else if (sk->sk_state == DCCP_CLOSED) {\n\t\tdcb->dccpd_reset_code = DCCP_RESET_CODE_NO_CONNECTION;\n\t\treturn 1;\n\t}\n\n\t/* Step 6: Check sequence numbers (omitted in LISTEN/REQUEST state) */\n\tif (sk->sk_state != DCCP_REQUESTING && dccp_check_seqno(sk, skb))\n\t\tgoto discard;\n\n\t/*\n\t *   Step 7: Check for unexpected packet types\n\t *      If (S.is_server and P.type == Response)\n\t *\t    or (S.is_client and P.type == Request)\n\t *\t    or (S.state == RESPOND and P.type == Data),\n\t *\t  Send Sync packet acknowledging P.seqno\n\t *\t  Drop packet and return\n\t */\n\tif ((dp->dccps_role != DCCP_ROLE_CLIENT &&\n\t     dh->dccph_type == DCCP_PKT_RESPONSE) ||\n\t    (dp->dccps_role == DCCP_ROLE_CLIENT &&\n\t     dh->dccph_type == DCCP_PKT_REQUEST) ||\n\t    (sk->sk_state == DCCP_RESPOND && dh->dccph_type == DCCP_PKT_DATA)) {\n\t\tdccp_send_sync(sk, dcb->dccpd_seq, DCCP_PKT_SYNC);\n\t\tgoto discard;\n\t}\n\n\t/*  Step 8: Process options */\n\tif (dccp_parse_options(sk, NULL, skb))\n\t\treturn 1;\n\n\t/*\n\t *  Step 9: Process Reset\n\t *\tIf P.type == Reset,\n\t *\t\tTear down connection\n\t *\t\tS.state := TIMEWAIT\n\t *\t\tSet TIMEWAIT timer\n\t *\t\tDrop packet and return\n\t */\n\tif (dh->dccph_type == DCCP_PKT_RESET) {\n\t\tdccp_rcv_reset(sk, skb);\n\t\treturn 0;\n\t} else if (dh->dccph_type == DCCP_PKT_CLOSEREQ) {\t/* Step 13 */\n\t\tif (dccp_rcv_closereq(sk, skb))\n\t\t\treturn 0;\n\t\tgoto discard;\n\t} else if (dh->dccph_type == DCCP_PKT_CLOSE) {\t\t/* Step 14 */\n\t\tif (dccp_rcv_close(sk, skb))\n\t\t\treturn 0;\n\t\tgoto discard;\n\t}\n\n\tswitch (sk->sk_state) {\n\tcase DCCP_REQUESTING:\n\t\tqueued = dccp_rcv_request_sent_state_process(sk, skb, dh, len);\n\t\tif (queued >= 0)\n\t\t\treturn queued;\n\n\t\t__kfree_skb(skb);\n\t\treturn 0;\n\n\tcase DCCP_PARTOPEN:\n\t\t/* Step 8: if using Ack Vectors, mark packet acknowledgeable */\n\t\tdccp_handle_ackvec_processing(sk, skb);\n\t\tdccp_deliver_input_to_ccids(sk, skb);\n\t\t/* fall through */\n\tcase DCCP_RESPOND:\n\t\tqueued = dccp_rcv_respond_partopen_state_process(sk, skb,\n\t\t\t\t\t\t\t\t dh, len);\n\t\tbreak;\n\t}\n\n\tif (dh->dccph_type == DCCP_PKT_ACK ||\n\t    dh->dccph_type == DCCP_PKT_DATAACK) {\n\t\tswitch (old_state) {\n\t\tcase DCCP_PARTOPEN:\n\t\t\tsk->sk_state_change(sk);\n\t\t\tsk_wake_async(sk, SOCK_WAKE_IO, POLL_OUT);\n\t\t\tbreak;\n\t\t}\n\t} else if (unlikely(dh->dccph_type == DCCP_PKT_SYNC)) {\n\t\tdccp_send_sync(sk, dcb->dccpd_seq, DCCP_PKT_SYNCACK);\n\t\tgoto discard;\n\t}\n\n\tif (!queued) {\ndiscard:\n\t\t__kfree_skb(skb);\n\t}\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -33,7 +33,8 @@\n \t\t\tif (inet_csk(sk)->icsk_af_ops->conn_request(sk,\n \t\t\t\t\t\t\t\t    skb) < 0)\n \t\t\t\treturn 1;\n-\t\t\tgoto discard;\n+\t\t\tconsume_skb(skb);\n+\t\t\treturn 0;\n \t\t}\n \t\tif (dh->dccph_type == DCCP_PKT_RESET)\n \t\t\tgoto discard;",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\tgoto discard;"
            ],
            "added_lines": [
                "\t\t\tconsume_skb(skb);",
                "\t\t\treturn 0;"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-14354",
        "func_name": "c-ares/host_callback",
        "description": "A possible use-after-free and double-free in c-ares lib version 1.16.0 if ares_destroy() is called prior to ares_getaddrinfo() completing. This flaw possibly allows an attacker to crash the service that uses c-ares lib. The highest threat from this vulnerability is to this service availability.",
        "git_url": "https://github.com/c-ares/c-ares/commit/1cc7e83c3bdfaafbc5919c95025592d8de3a170e",
        "commit_title": "Prevent possible double-free in ares_getaddrinfo() if ares_destroy() is called",
        "commit_text": " In the event that ares_destroy() is called prior to ares_getaddrinfo() completing, it would result in an invalid read and double-free due to calling end_hquery() twice.  Reported By: Jann Horn @ Google Project Zero",
        "func_before": "static void host_callback(void *arg, int status, int timeouts,\n                          unsigned char *abuf, int alen)\n{\n  struct host_query *hquery = (struct host_query*)arg;\n  int addinfostatus = ARES_SUCCESS;\n  hquery->timeouts += timeouts;\n  hquery->remaining--;\n\n  if (status == ARES_SUCCESS)\n    {\n      addinfostatus = ares__parse_into_addrinfo(abuf, alen, hquery->ai);\n    }\n  else if (status == ARES_EDESTRUCTION)\n    {\n      end_hquery(hquery, status);\n    }\n\n  if (!hquery->remaining)\n    {\n      if (addinfostatus != ARES_SUCCESS)\n        {\n          /* error in parsing result e.g. no memory */\n          end_hquery(hquery, addinfostatus);\n        }\n      else if (hquery->ai->nodes)\n        {\n          /* at least one query ended with ARES_SUCCESS */\n          end_hquery(hquery, ARES_SUCCESS);\n        }\n      else if (status == ARES_ENOTFOUND)\n        {\n          next_lookup(hquery, status);\n        }\n      else\n        {\n          end_hquery(hquery, status);\n        }\n    }\n\n  /* at this point we keep on waiting for the next query to finish */\n}",
        "func": "static void host_callback(void *arg, int status, int timeouts,\n                          unsigned char *abuf, int alen)\n{\n  struct host_query *hquery = (struct host_query*)arg;\n  int addinfostatus = ARES_SUCCESS;\n  hquery->timeouts += timeouts;\n  hquery->remaining--;\n\n  if (status == ARES_SUCCESS)\n    {\n      addinfostatus = ares__parse_into_addrinfo(abuf, alen, hquery->ai);\n    }\n  else if (status == ARES_EDESTRUCTION)\n    {\n      end_hquery(hquery, status);\n      return;\n    }\n\n  if (!hquery->remaining)\n    {\n      if (addinfostatus != ARES_SUCCESS)\n        {\n          /* error in parsing result e.g. no memory */\n          end_hquery(hquery, addinfostatus);\n        }\n      else if (hquery->ai->nodes)\n        {\n          /* at least one query ended with ARES_SUCCESS */\n          end_hquery(hquery, ARES_SUCCESS);\n        }\n      else if (status == ARES_ENOTFOUND)\n        {\n          next_lookup(hquery, status);\n        }\n      else\n        {\n          end_hquery(hquery, status);\n        }\n    }\n\n  /* at this point we keep on waiting for the next query to finish */\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -13,6 +13,7 @@\n   else if (status == ARES_EDESTRUCTION)\n     {\n       end_hquery(hquery, status);\n+      return;\n     }\n \n   if (!hquery->remaining)",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "      return;"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-32613",
        "func_name": "radareorg/radare2/get_none_object",
        "description": "In radare2 through 5.3.0 there is a double free vulnerability in the pyc parse via a crafted file which can lead to DoS.",
        "git_url": "https://github.com/radareorg/radare2/commit/5e16e2d1c9fe245e4c17005d779fde91ec0b9c05",
        "commit_title": "Fix #18666 - uaf in python bin parser",
        "commit_text": "",
        "func_before": "static pyc_object *get_none_object(void) {\n\tpyc_object *ret;\n\n\tret = R_NEW0 (pyc_object);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tret->type = TYPE_NONE;\n\tret->data = strdup (\"None\");\n\tif (!ret->data) {\n\t\tR_FREE (ret);\n\t}\n\treturn ret;\n}",
        "func": "static pyc_object *get_none_object(void) {\n\tpyc_object *ret = R_NEW0 (pyc_object);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\tret->type = TYPE_NONE;\n\tret->data = strdup (\"None\");\n\tif (!ret->data) {\n\t\tR_FREE (ret);\n\t}\n\treturn ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,7 +1,5 @@\n static pyc_object *get_none_object(void) {\n-\tpyc_object *ret;\n-\n-\tret = R_NEW0 (pyc_object);\n+\tpyc_object *ret = R_NEW0 (pyc_object);\n \tif (!ret) {\n \t\treturn NULL;\n \t}",
        "diff_line_info": {
            "deleted_lines": [
                "\tpyc_object *ret;",
                "",
                "\tret = R_NEW0 (pyc_object);"
            ],
            "added_lines": [
                "\tpyc_object *ret = R_NEW0 (pyc_object);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-32613",
        "func_name": "radareorg/radare2/get_object",
        "description": "In radare2 through 5.3.0 there is a double free vulnerability in the pyc parse via a crafted file which can lead to DoS.",
        "git_url": "https://github.com/radareorg/radare2/commit/5e16e2d1c9fe245e4c17005d779fde91ec0b9c05",
        "commit_title": "Fix #18666 - uaf in python bin parser",
        "commit_text": "",
        "func_before": "static pyc_object *get_object(RBuffer *buffer) {\n\tbool error = false;\n\tpyc_object *ret = NULL;\n\tut8 code = get_ut8 (buffer, &error);\n\tut8 flag = code & FLAG_REF;\n\tRListIter *ref_idx = NULL;\n\tut8 type = code & ~FLAG_REF;\n\n\tif (error) {\n\t\treturn NULL;\n\t}\n\n\tif (flag) {\n\t\tret = get_none_object ();\n\t\tif (!ret) {\n\t\t\treturn NULL;\n\t\t}\n\t\tref_idx = r_list_append (refs, ret);\n\t\tif (!ref_idx) {\n\t\t\tfree_object (ret);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tswitch (type) {\n\tcase TYPE_NULL:\n\t\tfree_object (ret);\n\t\treturn NULL;\n\tcase TYPE_TRUE:\n\t\tfree_object (ret);\n\t\treturn get_true_object ();\n\tcase TYPE_FALSE:\n\t\tfree_object (ret);\n\t\treturn get_false_object ();\n\tcase TYPE_NONE:\n\t\tfree_object (ret);\n\t\treturn get_none_object ();\n\tcase TYPE_REF:\n\t\tfree_object (ret);\n\t\treturn get_ref_object (buffer);\n\tcase TYPE_SMALL_TUPLE:\n\t\tret = get_small_tuple_object (buffer);\n\t\tbreak;\n\tcase TYPE_TUPLE:\n\t\tret = get_tuple_object (buffer);\n\t\tbreak;\n\tcase TYPE_STRING:\n\t\tret = get_string_object (buffer);\n\t\tbreak;\n\tcase TYPE_CODE_v0:\n\t\tret = get_code_object (buffer);\n\t\tif (ret) {\n\t\t\tret->type = TYPE_CODE_v0;\n\t\t}\n\t\tbreak;\n\tcase TYPE_CODE_v1:\n\t\tret = get_code_object (buffer);\n\t\tif (ret) {\n\t\t\tret->type = TYPE_CODE_v1;\n\t\t}\n\t\tbreak;\n\tcase TYPE_INT:\n\t\tret = get_int_object (buffer);\n\t\tbreak;\n\tcase TYPE_ASCII_INTERNED:\n\t\tret = get_ascii_interned_object (buffer);\n\t\tbreak;\n\tcase TYPE_SHORT_ASCII:\n\t\tret = get_short_ascii_object (buffer);\n\t\tbreak;\n\tcase TYPE_ASCII:\n\t\tret = get_ascii_object (buffer);\n\t\tbreak;\n\tcase TYPE_SHORT_ASCII_INTERNED:\n\t\tret = get_short_ascii_interned_object (buffer);\n\t\tbreak;\n\tcase TYPE_INT64:\n\t\tret = get_int64_object (buffer);\n\t\tbreak;\n\tcase TYPE_INTERNED:\n\t\tret = get_interned_object (buffer);\n\t\tbreak;\n\tcase TYPE_STRINGREF:\n\t\tret = get_stringref_object (buffer);\n\t\tbreak;\n\tcase TYPE_FLOAT:\n\t\tret = get_float_object (buffer);\n\t\tbreak;\n\tcase TYPE_BINARY_FLOAT:\n\t\tret = get_binary_float_object (buffer);\n\t\tbreak;\n\tcase TYPE_COMPLEX:\n\t\tret = get_complex_object (buffer); // behaviour depends on Python version\n\t\tbreak;\n\tcase TYPE_BINARY_COMPLEX:\n\t\tret = get_binary_complex_object (buffer);\n\t\tbreak;\n\tcase TYPE_LIST:\n\t\tret = get_list_object (buffer);\n\t\tbreak;\n\tcase TYPE_LONG:\n\t\tret = get_long_object (buffer);\n\t\tbreak;\n\tcase TYPE_UNICODE:\n\t\tret = get_unicode_object (buffer);\n\t\tbreak;\n\tcase TYPE_DICT:\n\t\tret = get_dict_object (buffer);\n\t\tbreak;\n\tcase TYPE_FROZENSET:\n\tcase TYPE_SET:\n\t\tret = get_set_object (buffer);\n\t\tbreak;\n\tcase TYPE_STOPITER:\n\tcase TYPE_ELLIPSIS:\n\t\tret = R_NEW0 (pyc_object);\n\t\tbreak;\n\tcase TYPE_UNKNOWN:\n\t\teprintf (\"Get not implemented for type 0x%x\\n\", type);\n\t\tfree_object (ret);\n\t\treturn NULL;\n\tcase 0:\n\t\t// nop\n\t\tbreak;\n\tdefault:\n\t\teprintf (\"Undefined type in get_object (0x%x)\\n\", type);\n\t\tfree_object (ret);\n\t\treturn NULL;\n\t}\n\n\tif (flag && ref_idx) {\n\t\tfree_object (ref_idx->data);\n\t\tref_idx->data = copy_object (ret);\n\t}\n\treturn ret;\n}",
        "func": "static pyc_object *get_object(RBuffer *buffer) {\n\tbool error = false;\n\tpyc_object *ret = NULL;\n\tut8 code = get_ut8 (buffer, &error);\n\tut8 flag = code & FLAG_REF;\n\tRListIter *ref_idx = NULL;\n\tut8 type = code & ~FLAG_REF;\n\n\tif (error) {\n\t\treturn NULL;\n\t}\n\n\tif (flag) {\n\t\tret = get_none_object ();\n\t\tif (!ret) {\n\t\t\treturn NULL;\n\t\t}\n\t\tref_idx = r_list_append (refs, ret);\n\t\tif (!ref_idx) {\n\t\t\tfree_object (ret);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tswitch (type) {\n\tcase TYPE_NULL:\n\t\tfree_object (ret);\n\t\treturn NULL;\n\tcase TYPE_TRUE:\n\t\tfree_object (ret);\n\t\treturn get_true_object ();\n\tcase TYPE_FALSE:\n\t\tfree_object (ret);\n\t\treturn get_false_object ();\n\tcase TYPE_NONE:\n\t\tfree_object (ret);\n\t\treturn get_none_object ();\n\tcase TYPE_REF:\n\t\tfree_object (ret);\n\t\treturn get_ref_object (buffer);\n\tcase TYPE_SMALL_TUPLE:\n\t\tret = get_small_tuple_object (buffer);\n\t\tbreak;\n\tcase TYPE_TUPLE:\n\t\tret = get_tuple_object (buffer);\n\t\tbreak;\n\tcase TYPE_STRING:\n\t\tret = get_string_object (buffer);\n\t\tbreak;\n\tcase TYPE_CODE_v0:\n\t\tret = get_code_object (buffer);\n\t\tif (ret) {\n\t\t\tret->type = TYPE_CODE_v0;\n\t\t}\n\t\tbreak;\n\tcase TYPE_CODE_v1:\n\t\tret = get_code_object (buffer);\n\t\tif (ret) {\n\t\t\tret->type = TYPE_CODE_v1;\n\t\t}\n\t\tbreak;\n\tcase TYPE_INT:\n\t\tret = get_int_object (buffer);\n\t\tbreak;\n\tcase TYPE_ASCII_INTERNED:\n\t\tret = get_ascii_interned_object (buffer);\n\t\tbreak;\n\tcase TYPE_SHORT_ASCII:\n\t\tret = get_short_ascii_object (buffer);\n\t\tbreak;\n\tcase TYPE_ASCII:\n\t\tret = get_ascii_object (buffer);\n\t\tbreak;\n\tcase TYPE_SHORT_ASCII_INTERNED:\n\t\tret = get_short_ascii_interned_object (buffer);\n\t\tbreak;\n\tcase TYPE_INT64:\n\t\tret = get_int64_object (buffer);\n\t\tbreak;\n\tcase TYPE_INTERNED:\n\t\tret = get_interned_object (buffer);\n\t\tbreak;\n\tcase TYPE_STRINGREF:\n\t\tret = get_stringref_object (buffer);\n\t\tbreak;\n\tcase TYPE_FLOAT:\n\t\tret = get_float_object (buffer);\n\t\tbreak;\n\tcase TYPE_BINARY_FLOAT:\n\t\tret = get_binary_float_object (buffer);\n\t\tbreak;\n\tcase TYPE_COMPLEX:\n\t\tret = get_complex_object (buffer); // behaviour depends on Python version\n\t\tbreak;\n\tcase TYPE_BINARY_COMPLEX:\n\t\tret = get_binary_complex_object (buffer);\n\t\tbreak;\n\tcase TYPE_LIST:\n\t\tret = get_list_object (buffer);\n\t\tbreak;\n\tcase TYPE_LONG:\n\t\tret = get_long_object (buffer);\n\t\tbreak;\n\tcase TYPE_UNICODE:\n\t\tret = get_unicode_object (buffer);\n\t\tbreak;\n\tcase TYPE_DICT:\n\t\tret = get_dict_object (buffer);\n\t\tbreak;\n\tcase TYPE_FROZENSET:\n\tcase TYPE_SET:\n\t\tret = get_set_object (buffer);\n\t\tbreak;\n\tcase TYPE_STOPITER:\n\tcase TYPE_ELLIPSIS:\n\t\tret = R_NEW0 (pyc_object);\n\t\tbreak;\n\tcase TYPE_UNKNOWN:\n\t\teprintf (\"Get not implemented for type 0x%x\\n\", type);\n\t\tfree_object (ret);\n\t\treturn NULL;\n\tcase 0:\n\t\t// nop\n\t\tbreak;\n\tdefault:\n\t\teprintf (\"Undefined type in get_object (0x%x)\\n\", type);\n\t\tfree_object (ret);\n\t\treturn NULL;\n\t}\n\n\tif (flag && ref_idx) {\n\t\tif (ref_idx->data != ret) {\n\t\t\tfree_object (ref_idx->data);\n\t\t}\n\t\tref_idx->data = copy_object (ret);\n\t}\n\treturn ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -129,7 +129,9 @@\n \t}\n \n \tif (flag && ref_idx) {\n-\t\tfree_object (ref_idx->data);\n+\t\tif (ref_idx->data != ret) {\n+\t\t\tfree_object (ref_idx->data);\n+\t\t}\n \t\tref_idx->data = copy_object (ret);\n \t}\n \treturn ret;",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tfree_object (ref_idx->data);"
            ],
            "added_lines": [
                "\t\tif (ref_idx->data != ret) {",
                "\t\t\tfree_object (ref_idx->data);",
                "\t\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-32613",
        "func_name": "radareorg/radare2/rebase_buffer",
        "description": "In radare2 through 5.3.0 there is a double free vulnerability in the pyc parse via a crafted file which can lead to DoS.",
        "git_url": "https://github.com/radareorg/radare2/commit/a07dedb804a82bc01c07072861942dd80c6b6d62",
        "commit_title": "Fix #18667 - division by zero in the macho parser ##bin",
        "commit_text": "",
        "func_before": "static void rebase_buffer(struct MACH0_(obj_t) *obj, ut64 off, RIODesc *fd, ut8 *buf, int count) {\n\tif (obj->rebasing_buffer) {\n\t\treturn;\n\t}\n\tobj->rebasing_buffer = true;\n\tut64 eob = off + count;\n\tint i = 0;\n\tfor (; i < obj->nsegs; i++) {\n\t\tif (!obj->chained_starts[i]) {\n\t\t\tcontinue;\n\t\t}\n\t\tut64 page_size = obj->chained_starts[i]->page_size;\n\t\tut64 start = obj->segs[i].fileoff;\n\t\tut64 end = start + obj->segs[i].filesize;\n\t\tif (end >= off && start <= eob) {\n\t\t\tut64 page_idx = (R_MAX (start, off) - start) / page_size;\n\t\t\tut64 page_end_idx = (R_MIN (eob, end) - start) / page_size;\n\t\t\tfor (; page_idx <= page_end_idx; page_idx++) {\n\t\t\t\tif (page_idx >= obj->chained_starts[i]->page_count) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tut16 page_start = obj->chained_starts[i]->page_start[page_idx];\n\t\t\t\tif (page_start == DYLD_CHAINED_PTR_START_NONE) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tut64 cursor = start + page_idx * page_size + page_start;\n\t\t\t\twhile (cursor < eob && cursor < end) {\n\t\t\t\t\tut8 tmp[8];\n\t\t\t\t\tif (r_buf_read_at (obj->b, cursor, tmp, 8) != 8) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tut64 raw_ptr = r_read_le64 (tmp);\n\t\t\t\t\tbool is_auth = IS_PTR_AUTH (raw_ptr);\n\t\t\t\t\tbool is_bind = IS_PTR_BIND (raw_ptr);\n\t\t\t\t\tut64 ptr_value = raw_ptr;\n\t\t\t\t\tut64 delta;\n\t\t\t\t\tif (is_auth && is_bind) {\n\t\t\t\t\t\tstruct dyld_chained_ptr_arm64e_auth_bind *p =\n\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_arm64e_auth_bind *) &raw_ptr;\n\t\t\t\t\t\tdelta = p->next;\n\t\t\t\t\t} else if (!is_auth && is_bind) {\n\t\t\t\t\t\tstruct dyld_chained_ptr_arm64e_bind *p =\n\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_arm64e_bind *) &raw_ptr;\n\t\t\t\t\t\tdelta = p->next;\n\t\t\t\t\t} else if (is_auth && !is_bind) {\n\t\t\t\t\t\tstruct dyld_chained_ptr_arm64e_auth_rebase *p =\n\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_arm64e_auth_rebase *) &raw_ptr;\n\t\t\t\t\t\tdelta = p->next;\n\t\t\t\t\t\tptr_value = p->target + obj->baddr;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstruct dyld_chained_ptr_arm64e_rebase *p =\n\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_arm64e_rebase *) &raw_ptr;\n\t\t\t\t\t\tdelta = p->next;\n\t\t\t\t\t\tptr_value = ((ut64)p->high8 << 56) | p->target;\n\t\t\t\t\t}\n\t\t\t\t\tut64 in_buf = cursor - off;\n\t\t\t\t\tif (cursor >= off && cursor <= eob - 8) {\n\t\t\t\t\t\tr_write_le64 (&buf[in_buf], ptr_value);\n\t\t\t\t\t}\n\t\t\t\t\tcursor += delta * 8;\n\t\t\t\t\tif (!delta) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tobj->rebasing_buffer = false;\n}",
        "func": "static void rebase_buffer(struct MACH0_(obj_t) *obj, ut64 off, RIODesc *fd, ut8 *buf, int count) {\n\tif (obj->rebasing_buffer) {\n\t\treturn;\n\t}\n\tobj->rebasing_buffer = true;\n\tut64 eob = off + count;\n\tint i = 0;\n\tfor (; i < obj->nsegs; i++) {\n\t\tif (!obj->chained_starts[i]) {\n\t\t\tcontinue;\n\t\t}\n\t\tint page_size = obj->chained_starts[i]->page_size;\n\t\tif (page_size < 1) {\n\t\t\tpage_size = 4096;\n\t\t}\n\t\tut64 start = obj->segs[i].fileoff;\n\t\tut64 end = start + obj->segs[i].filesize;\n\t\tif (end >= off && start <= eob) {\n\t\t\tut64 page_idx = (R_MAX (start, off) - start) / page_size;\n\t\t\tut64 page_end_idx = (R_MIN (eob, end) - start) / page_size;\n\t\t\tfor (; page_idx <= page_end_idx; page_idx++) {\n\t\t\t\tif (page_idx >= obj->chained_starts[i]->page_count) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tut16 page_start = obj->chained_starts[i]->page_start[page_idx];\n\t\t\t\tif (page_start == DYLD_CHAINED_PTR_START_NONE) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tut64 cursor = start + page_idx * page_size + page_start;\n\t\t\t\twhile (cursor < eob && cursor < end) {\n\t\t\t\t\tut8 tmp[8];\n\t\t\t\t\tif (r_buf_read_at (obj->b, cursor, tmp, 8) != 8) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tut64 raw_ptr = r_read_le64 (tmp);\n\t\t\t\t\tbool is_auth = IS_PTR_AUTH (raw_ptr);\n\t\t\t\t\tbool is_bind = IS_PTR_BIND (raw_ptr);\n\t\t\t\t\tut64 ptr_value = raw_ptr;\n\t\t\t\t\tut64 delta;\n\t\t\t\t\tif (is_auth && is_bind) {\n\t\t\t\t\t\tstruct dyld_chained_ptr_arm64e_auth_bind *p =\n\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_arm64e_auth_bind *) &raw_ptr;\n\t\t\t\t\t\tdelta = p->next;\n\t\t\t\t\t} else if (!is_auth && is_bind) {\n\t\t\t\t\t\tstruct dyld_chained_ptr_arm64e_bind *p =\n\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_arm64e_bind *) &raw_ptr;\n\t\t\t\t\t\tdelta = p->next;\n\t\t\t\t\t} else if (is_auth && !is_bind) {\n\t\t\t\t\t\tstruct dyld_chained_ptr_arm64e_auth_rebase *p =\n\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_arm64e_auth_rebase *) &raw_ptr;\n\t\t\t\t\t\tdelta = p->next;\n\t\t\t\t\t\tptr_value = p->target + obj->baddr;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstruct dyld_chained_ptr_arm64e_rebase *p =\n\t\t\t\t\t\t\t\t(struct dyld_chained_ptr_arm64e_rebase *) &raw_ptr;\n\t\t\t\t\t\tdelta = p->next;\n\t\t\t\t\t\tptr_value = ((ut64)p->high8 << 56) | p->target;\n\t\t\t\t\t}\n\t\t\t\t\tut64 in_buf = cursor - off;\n\t\t\t\t\tif (cursor >= off && cursor <= eob - 8) {\n\t\t\t\t\t\tr_write_le64 (&buf[in_buf], ptr_value);\n\t\t\t\t\t}\n\t\t\t\t\tcursor += delta * 8;\n\t\t\t\t\tif (!delta) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tobj->rebasing_buffer = false;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -9,7 +9,10 @@\n \t\tif (!obj->chained_starts[i]) {\n \t\t\tcontinue;\n \t\t}\n-\t\tut64 page_size = obj->chained_starts[i]->page_size;\n+\t\tint page_size = obj->chained_starts[i]->page_size;\n+\t\tif (page_size < 1) {\n+\t\t\tpage_size = 4096;\n+\t\t}\n \t\tut64 start = obj->segs[i].fileoff;\n \t\tut64 end = start + obj->segs[i].filesize;\n \t\tif (end >= off && start <= eob) {",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tut64 page_size = obj->chained_starts[i]->page_size;"
            ],
            "added_lines": [
                "\t\tint page_size = obj->chained_starts[i]->page_size;",
                "\t\tif (page_size < 1) {",
                "\t\t\tpage_size = 4096;",
                "\t\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-34184",
        "func_name": "mackron/miniaudio/ma_decoder_uninit",
        "description": "Miniaudio 0.10.35 has a Double free vulnerability that could cause a buffer overflow in ma_default_vfs_close__stdio in miniaudio.h.",
        "git_url": "https://github.com/mackron/miniaudio/commit/8234df87c9268507847e0033280067bade9a57a1",
        "commit_title": "Fix a possible double file close when decoder initialization fails.",
        "commit_text": " Public issue https://github.com/mackron/miniaudio/issues/319",
        "func_before": "MA_API ma_result ma_decoder_uninit(ma_decoder* pDecoder)\n{\n    if (pDecoder == NULL) {\n        return MA_INVALID_ARGS;\n    }\n\n    if (pDecoder->onUninit) {\n        pDecoder->onUninit(pDecoder);\n    }\n\n    if (pDecoder->onRead == ma_decoder__on_read_vfs) {\n        ma_vfs_or_default_close(pDecoder->backend.vfs.pVFS, pDecoder->backend.vfs.file);\n    }\n\n    ma_data_converter_uninit(&pDecoder->converter);\n    ma_data_source_uninit(&pDecoder->ds);\n\n    return MA_SUCCESS;\n}",
        "func": "MA_API ma_result ma_decoder_uninit(ma_decoder* pDecoder)\n{\n    if (pDecoder == NULL) {\n        return MA_INVALID_ARGS;\n    }\n\n    if (pDecoder->onUninit) {\n        pDecoder->onUninit(pDecoder);\n    }\n\n    if (pDecoder->onRead == ma_decoder__on_read_vfs) {\n        ma_vfs_or_default_close(pDecoder->backend.vfs.pVFS, pDecoder->backend.vfs.file);\n        pDecoder->backend.vfs.file = NULL;\n    }\n\n    ma_data_converter_uninit(&pDecoder->converter);\n    ma_data_source_uninit(&pDecoder->ds);\n\n    return MA_SUCCESS;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -10,6 +10,7 @@\n \n     if (pDecoder->onRead == ma_decoder__on_read_vfs) {\n         ma_vfs_or_default_close(pDecoder->backend.vfs.pVFS, pDecoder->backend.vfs.file);\n+        pDecoder->backend.vfs.file = NULL;\n     }\n \n     ma_data_converter_uninit(&pDecoder->converter);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "        pDecoder->backend.vfs.file = NULL;"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-34184",
        "func_name": "mackron/miniaudio/ma_decoder_init_vfs",
        "description": "Miniaudio 0.10.35 has a Double free vulnerability that could cause a buffer overflow in ma_default_vfs_close__stdio in miniaudio.h.",
        "git_url": "https://github.com/mackron/miniaudio/commit/8234df87c9268507847e0033280067bade9a57a1",
        "commit_title": "Fix a possible double file close when decoder initialization fails.",
        "commit_text": " Public issue https://github.com/mackron/miniaudio/issues/319",
        "func_before": "MA_API ma_result ma_decoder_init_vfs(ma_vfs* pVFS, const char* pFilePath, const ma_decoder_config* pConfig, ma_decoder* pDecoder)\n{\n    ma_result result;\n    ma_decoder_config config;\n\n    config = ma_decoder_config_init_copy(pConfig);\n    result = ma_decoder__preinit_vfs(pVFS, pFilePath, &config, pDecoder);\n    if (result != MA_SUCCESS) {\n        return result;\n    }\n\n    result = MA_NO_BACKEND;\n\n#ifdef MA_HAS_WAV\n    if (result != MA_SUCCESS && ma_path_extension_equal(pFilePath, \"wav\")) {\n        result = ma_decoder_init_wav__internal(&config, pDecoder);\n        if (result != MA_SUCCESS) {\n            ma_decoder__on_seek_vfs(pDecoder, 0, ma_seek_origin_start);\n        }\n    }\n#endif\n#ifdef MA_HAS_FLAC\n    if (result != MA_SUCCESS && ma_path_extension_equal(pFilePath, \"flac\")) {\n        result = ma_decoder_init_flac__internal(&config, pDecoder);\n        if (result != MA_SUCCESS) {\n            ma_decoder__on_seek_vfs(pDecoder, 0, ma_seek_origin_start);\n        }\n    }\n#endif\n#ifdef MA_HAS_MP3\n    if (result != MA_SUCCESS && ma_path_extension_equal(pFilePath, \"mp3\")) {\n        result = ma_decoder_init_mp3__internal(&config, pDecoder);\n        if (result != MA_SUCCESS) {\n            ma_decoder__on_seek_vfs(pDecoder, 0, ma_seek_origin_start);\n        }\n    }\n#endif\n\n    /* If we still haven't got a result just use trial and error. Otherwise we can finish up. */\n    if (result != MA_SUCCESS) {\n        result = ma_decoder_init__internal(ma_decoder__on_read_vfs, ma_decoder__on_seek_vfs, NULL, &config, pDecoder);\n    } else {\n        result = ma_decoder__postinit(&config, pDecoder);\n    }\n\n    if (result != MA_SUCCESS) {\n        ma_vfs_or_default_close(pVFS, pDecoder->backend.vfs.file);\n        return result;\n    }\n\n    return MA_SUCCESS;\n}",
        "func": "MA_API ma_result ma_decoder_init_vfs(ma_vfs* pVFS, const char* pFilePath, const ma_decoder_config* pConfig, ma_decoder* pDecoder)\n{\n    ma_result result;\n    ma_decoder_config config;\n\n    config = ma_decoder_config_init_copy(pConfig);\n    result = ma_decoder__preinit_vfs(pVFS, pFilePath, &config, pDecoder);\n    if (result != MA_SUCCESS) {\n        return result;\n    }\n\n    result = MA_NO_BACKEND;\n\n#ifdef MA_HAS_WAV\n    if (result != MA_SUCCESS && ma_path_extension_equal(pFilePath, \"wav\")) {\n        result = ma_decoder_init_wav__internal(&config, pDecoder);\n        if (result != MA_SUCCESS) {\n            ma_decoder__on_seek_vfs(pDecoder, 0, ma_seek_origin_start);\n        }\n    }\n#endif\n#ifdef MA_HAS_FLAC\n    if (result != MA_SUCCESS && ma_path_extension_equal(pFilePath, \"flac\")) {\n        result = ma_decoder_init_flac__internal(&config, pDecoder);\n        if (result != MA_SUCCESS) {\n            ma_decoder__on_seek_vfs(pDecoder, 0, ma_seek_origin_start);\n        }\n    }\n#endif\n#ifdef MA_HAS_MP3\n    if (result != MA_SUCCESS && ma_path_extension_equal(pFilePath, \"mp3\")) {\n        result = ma_decoder_init_mp3__internal(&config, pDecoder);\n        if (result != MA_SUCCESS) {\n            ma_decoder__on_seek_vfs(pDecoder, 0, ma_seek_origin_start);\n        }\n    }\n#endif\n\n    /* If we still haven't got a result just use trial and error. Otherwise we can finish up. */\n    if (result != MA_SUCCESS) {\n        result = ma_decoder_init__internal(ma_decoder__on_read_vfs, ma_decoder__on_seek_vfs, NULL, &config, pDecoder);\n    } else {\n        result = ma_decoder__postinit(&config, pDecoder);\n    }\n\n    if (result != MA_SUCCESS) {\n        if (pDecoder->backend.vfs.file != NULL) {   /* <-- Will be reset to NULL if ma_decoder_uninit() is called in one of the steps above which allows us to avoid a double close of the file. */\n            ma_vfs_or_default_close(pVFS, pDecoder->backend.vfs.file);\n        }\n\n        return result;\n    }\n\n    return MA_SUCCESS;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -44,7 +44,10 @@\n     }\n \n     if (result != MA_SUCCESS) {\n-        ma_vfs_or_default_close(pVFS, pDecoder->backend.vfs.file);\n+        if (pDecoder->backend.vfs.file != NULL) {   /* <-- Will be reset to NULL if ma_decoder_uninit() is called in one of the steps above which allows us to avoid a double close of the file. */\n+            ma_vfs_or_default_close(pVFS, pDecoder->backend.vfs.file);\n+        }\n+\n         return result;\n     }\n ",
        "diff_line_info": {
            "deleted_lines": [
                "        ma_vfs_or_default_close(pVFS, pDecoder->backend.vfs.file);"
            ],
            "added_lines": [
                "        if (pDecoder->backend.vfs.file != NULL) {   /* <-- Will be reset to NULL if ma_decoder_uninit() is called in one of the steps above which allows us to avoid a double close of the file. */",
                "            ma_vfs_or_default_close(pVFS, pDecoder->backend.vfs.file);",
                "        }",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2022-31291",
        "func_name": "COVESA/dlt-daemon/dlt_config_file_set_section",
        "description": "An issue in dlt_config_file_parser.c of dlt-daemon v2.18.8 allows attackers to cause a double free via crafted TCP packets.",
        "git_url": "https://github.com/COVESA/dlt-daemon/commit/44c814c469eb89cca218a41341d9de5016c5d096",
        "commit_title": "Fix a double-free bug.",
        "commit_text": " In the dlt_config_file_set_section function of dlt_config_file_parser.c:   s-name is not set to null after free.   It will be freed again in the dlt_config_file_release function. ",
        "func_before": "static int dlt_config_file_set_section(DltConfigFile *file, char *name)\n{\n    int section = file->num_sections;\n\n    /* check if adding another section would exceed max number of sections */\n    if (section >= DLT_CONFIG_FILE_SECTIONS_MAX) {\n        dlt_log(LOG_WARNING, \"Cannot store more sections\\n\");\n        return -1; /* reached max number of sections */\n    }\n\n    /* do not store section with same name again */\n    if (dlt_config_file_is_section_name(file, name) != 0) {\n        dlt_log(LOG_WARNING, \"Cannot store section name again\\n\");\n        return -1;\n    }\n\n    DltConfigFileSection *s = &file->sections[section];\n\n    /* alloc data for entries */\n    s->name = calloc(sizeof(char), DLT_CONFIG_FILE_ENTRY_MAX_LEN + 1);\n\n    if (s->name == NULL) {\n        dlt_log(LOG_ERR, \"Cannot allocate memory for internal data structure\\n\");\n        return -1;\n    }\n\n    s->keys = calloc(sizeof(char), DLT_CONFIG_FILE_ENTRY_MAX_LEN * DLT_CONFIG_FILE_KEYS_MAX + 1);\n\n    if (s->keys == NULL) {\n        free(s->name);\n        dlt_log(LOG_ERR, \"Cannot allocate memory for internal data structure\\n\");\n        return -1;\n    }\n\n    strncpy(file->sections[section].name, name, DLT_CONFIG_FILE_ENTRY_MAX_LEN);\n    file->num_sections += 1;\n    return 0;\n}",
        "func": "static int dlt_config_file_set_section(DltConfigFile *file, char *name)\n{\n    int section = file->num_sections;\n\n    /* check if adding another section would exceed max number of sections */\n    if (section >= DLT_CONFIG_FILE_SECTIONS_MAX) {\n        dlt_log(LOG_WARNING, \"Cannot store more sections\\n\");\n        return -1; /* reached max number of sections */\n    }\n\n    /* do not store section with same name again */\n    if (dlt_config_file_is_section_name(file, name) != 0) {\n        dlt_log(LOG_WARNING, \"Cannot store section name again\\n\");\n        return -1;\n    }\n\n    DltConfigFileSection *s = &file->sections[section];\n\n    /* alloc data for entries */\n    s->name = calloc(sizeof(char), DLT_CONFIG_FILE_ENTRY_MAX_LEN + 1);\n\n    if (s->name == NULL) {\n        dlt_log(LOG_ERR, \"Cannot allocate memory for internal data structure\\n\");\n        return -1;\n    }\n\n    s->keys = calloc(sizeof(char), DLT_CONFIG_FILE_ENTRY_MAX_LEN * DLT_CONFIG_FILE_KEYS_MAX + 1);\n\n    if (s->keys == NULL) {\n        free(s->name);\n        s->name = NULL;\n        dlt_log(LOG_ERR, \"Cannot allocate memory for internal data structure\\n\");\n        return -1;\n    }\n\n    strncpy(file->sections[section].name, name, DLT_CONFIG_FILE_ENTRY_MAX_LEN);\n    file->num_sections += 1;\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -28,6 +28,7 @@\n \n     if (s->keys == NULL) {\n         free(s->name);\n+        s->name = NULL;\n         dlt_log(LOG_ERR, \"Cannot allocate memory for internal data structure\\n\");\n         return -1;\n     }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "        s->name = NULL;"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-1449",
        "func_name": "gpac/av1dmx_parse_flush_sample",
        "description": "A vulnerability has been found in GPAC 2.3-DEV-rev35-gbbca86917-master and classified as problematic. This vulnerability affects the function gf_av1_reset_state of the file media_tools/av_parsers.c. The manipulation leads to double free. It is possible to launch the attack on the local host. The exploit has been disclosed to the public and may be used. It is recommended to apply a patch to fix this issue. VDB-223294 is the identifier assigned to this vulnerability.",
        "git_url": "https://github.com/gpac/gpac/commit/8ebbfd61c73d61a2913721a492e5a81fb8d9f9a9",
        "commit_title": "av1: flush samples on parse error (#2387)",
        "commit_text": "",
        "func_before": "static GF_Err av1dmx_parse_flush_sample(GF_Filter *filter, GF_AV1DmxCtx *ctx)\n{\n\tu32 pck_size = 0;\n\tGF_FilterPacket *pck = NULL;\n\tu8 *output = NULL;\n\n\tif (!ctx->opid)\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t\t\n\tgf_bs_get_content_no_truncate(ctx->state.bs, &ctx->state.frame_obus, &pck_size, &ctx->state.frame_obus_alloc);\n\n\tif (!pck_size) {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_MEDIA, (\"[AV1Dmx] no frame OBU, skipping OBU\\n\"));\n\t\treturn GF_OK;\n\t}\n\n\tpck = gf_filter_pck_new_alloc(ctx->opid, pck_size, &output);\n\tif (!pck) return GF_OUT_OF_MEM;\n\n\tif (ctx->src_pck)\n\t\tgf_filter_pck_merge_properties(ctx->src_pck, pck);\n\n\tgf_filter_pck_set_cts(pck, ctx->cts);\n\tgf_filter_pck_set_sap(pck, ctx->state.frame_state.key_frame ? GF_FILTER_SAP_1 : 0);\n\n\tmemcpy(output, ctx->state.frame_obus, pck_size);\n\n\tif (ctx->deps) {\n\t\tu8 flags = 0;\n\t\t//dependsOn\n\t\tflags = ( ctx->state.frame_state.key_frame) ? 2 : 1;\n\t\tflags <<= 2;\n\t\t//dependedOn\n\t \tflags |= ctx->state.frame_state.refresh_frame_flags ? 1 : 2;\n\t\tflags <<= 2;\n\t\t//hasRedundant\n\t \t//flags |= ctx->has_redundant ? 1 : 2;\n\t \tgf_filter_pck_set_dependency_flags(pck, flags);\n\t}\n\n\tif (ctx->state.clli_valid) {\n\t\tu32 crc = gf_crc_32(ctx->state.clli_data, 4);\n\t\tif (crc != ctx->clli_crc) {\n\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PID_CONTENT_LIGHT_LEVEL, &PROP_DATA(ctx->state.clli_data, 4));\n\t\t}\n\t}\n\tif (ctx->state.mdcv_valid) {\n\t\tu32 crc = gf_crc_32(ctx->state.mdcv_data, 24);\n\t\tif (crc != ctx->mdcv_crc) {\n\t\t\tav1dmx_set_mdcv(ctx, NULL, pck);\n\t\t}\n\t}\n\n\tgf_filter_pck_send(pck);\n\n\tav1dmx_update_cts(ctx);\n\tgf_av1_reset_state(&ctx->state, GF_FALSE);\n\n\treturn GF_OK;\n\n}",
        "func": "static GF_Err av1dmx_parse_flush_sample(GF_Filter *filter, GF_AV1DmxCtx *ctx)\n{\n\tu32 pck_size = 0;\n\tGF_FilterPacket *pck = NULL;\n\tu8 *output = NULL;\n\n\tif (!ctx->opid)\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\n\tgf_bs_get_content_no_truncate(ctx->state.bs, &ctx->state.frame_obus, &pck_size, &ctx->state.frame_obus_alloc);\n\n\tif (!pck_size) {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_MEDIA, (\"[AV1Dmx] no frame OBU, skipping OBU\\n\"));\n\t\treturn GF_OK;\n\t}\n\n\tpck = gf_filter_pck_new_alloc(ctx->opid, pck_size, &output);\n\tif (!pck) return GF_OUT_OF_MEM;\n\n\tif (ctx->src_pck)\n\t\tgf_filter_pck_merge_properties(ctx->src_pck, pck);\n\n\tgf_filter_pck_set_cts(pck, ctx->cts);\n\tgf_filter_pck_set_sap(pck, ctx->state.frame_state.key_frame ? GF_FILTER_SAP_1 : 0);\n\n\tmemcpy(output, ctx->state.frame_obus, pck_size);\n\n\tif (ctx->deps) {\n\t\tu8 flags = 0;\n\t\t//dependsOn\n\t\tflags = ( ctx->state.frame_state.key_frame) ? 2 : 1;\n\t\tflags <<= 2;\n\t\t//dependedOn\n\t \tflags |= ctx->state.frame_state.refresh_frame_flags ? 1 : 2;\n\t\tflags <<= 2;\n\t\t//hasRedundant\n\t \t//flags |= ctx->has_redundant ? 1 : 2;\n\t \tgf_filter_pck_set_dependency_flags(pck, flags);\n\t}\n\n\tif (ctx->state.clli_valid) {\n\t\tu32 crc = gf_crc_32(ctx->state.clli_data, 4);\n\t\tif (crc != ctx->clli_crc) {\n\t\t\tgf_filter_pck_set_property(pck, GF_PROP_PID_CONTENT_LIGHT_LEVEL, &PROP_DATA(ctx->state.clli_data, 4));\n\t\t}\n\t}\n\tif (ctx->state.mdcv_valid) {\n\t\tu32 crc = gf_crc_32(ctx->state.mdcv_data, 24);\n\t\tif (crc != ctx->mdcv_crc) {\n\t\t\tav1dmx_set_mdcv(ctx, NULL, pck);\n\t\t}\n\t}\n\n\tgf_filter_pck_send(pck);\n\n\tav1dmx_update_cts(ctx);\n\tgf_av1_reset_state(&ctx->state, GF_FALSE);\n\n\treturn GF_OK;\n\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,7 +6,7 @@\n \n \tif (!ctx->opid)\n \t\treturn GF_NON_COMPLIANT_BITSTREAM;\n-\t\t\n+\n \tgf_bs_get_content_no_truncate(ctx->state.bs, &ctx->state.frame_obus, &pck_size, &ctx->state.frame_obus_alloc);\n \n \tif (!pck_size) {",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t"
            ],
            "added_lines": [
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2023-1449",
        "func_name": "gpac/av1dmx_parse_av1",
        "description": "A vulnerability has been found in GPAC 2.3-DEV-rev35-gbbca86917-master and classified as problematic. This vulnerability affects the function gf_av1_reset_state of the file media_tools/av_parsers.c. The manipulation leads to double free. It is possible to launch the attack on the local host. The exploit has been disclosed to the public and may be used. It is recommended to apply a patch to fix this issue. VDB-223294 is the identifier assigned to this vulnerability.",
        "git_url": "https://github.com/gpac/gpac/commit/8ebbfd61c73d61a2913721a492e5a81fb8d9f9a9",
        "commit_title": "av1: flush samples on parse error (#2387)",
        "commit_text": "",
        "func_before": "GF_Err av1dmx_parse_av1(GF_Filter *filter, GF_AV1DmxCtx *ctx)\n{\n\tGF_Err e = GF_OK;\n\tu64 start;\n\n\tif (!ctx->is_playing) {\n\t\tctx->state.frame_state.is_first_frame = GF_TRUE;\n\t}\n\n\t/*we process each TU and extract only the necessary OBUs*/\n\tstart = gf_bs_get_position(ctx->bs);\n\tswitch (ctx->bsmode) {\n\tcase OBUs:\n\t\t//first frame loaded !\n\t\tif (ctx->state.bs && gf_bs_get_position(ctx->state.bs) && (ctx->state.obu_type == OBU_TEMPORAL_DELIMITER)) {\n\t\t\te = GF_OK;\n\t\t} else {\n\t\t\te = aom_av1_parse_temporal_unit_from_section5(ctx->bs, &ctx->state);\n\t\t}\n\t\tbreak;\n\tcase AnnexB:\n\t\t//first TU loaded !\n\t\tif (ctx->state.bs && gf_bs_get_position(ctx->state.bs)) {\n\t\t\te = GF_OK;\n\t\t} else {\n\t\t\te = aom_av1_parse_temporal_unit_from_annexb(ctx->bs, &ctx->state);\n\t\t\tif (e==GF_BUFFER_TOO_SMALL) {\n\t\t\t\tgf_av1_reset_state(&ctx->state, GF_FALSE);\n\t\t\t\tgf_bs_seek(ctx->bs, start);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase IVF:\n\t\t//first frame loaded !\n\t\tif (ctx->state.bs && gf_bs_get_position(ctx->state.bs)) {\n\t\t\te = GF_OK;\n\t\t} else {\n\t\t\te = aom_av1_parse_temporal_unit_from_ivf(ctx->bs, &ctx->state);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\te = GF_NOT_SUPPORTED;\n\t}\n\n\t//check pid state\n\tav1dmx_check_pid(filter, ctx);\n\n\t//fixme, we need to flush at each DFG start - for now we assume one PES = one DFG as we do in the muxer\n\tif (ctx->timescale && (e==GF_BUFFER_TOO_SMALL))\n\t\te = GF_OK;\n\n\tif (e) return e;\n\n\n\tif (!ctx->opid) {\n\t\tif (ctx->state.obu_type != OBU_TEMPORAL_DELIMITER) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, (\"[AV1Dmx] output pid not configured (no sequence header yet ?), skipping OBU\\n\"));\n\t\t}\n\t\tgf_av1_reset_state(&ctx->state, GF_FALSE);\n\t\treturn GF_OK;\n\t}\n\n\tif (!ctx->is_playing) {\n\t\t//don't reset state we would skip seq header obu in first frame\n\t\t//gf_av1_reset_state(&ctx->state, GF_FALSE);\n\t\treturn GF_OK;\n\t}\n\n\treturn av1dmx_parse_flush_sample(filter, ctx);\n\n}",
        "func": "GF_Err av1dmx_parse_av1(GF_Filter *filter, GF_AV1DmxCtx *ctx)\n{\n\tGF_Err e = GF_OK;\n\tu64 start;\n\n\tif (!ctx->is_playing) {\n\t\tctx->state.frame_state.is_first_frame = GF_TRUE;\n\t}\n\n\t/*we process each TU and extract only the necessary OBUs*/\n\tstart = gf_bs_get_position(ctx->bs);\n\tswitch (ctx->bsmode) {\n\tcase OBUs:\n\t\t//first frame loaded !\n\t\tif (ctx->state.bs && gf_bs_get_position(ctx->state.bs) && (ctx->state.obu_type == OBU_TEMPORAL_DELIMITER)) {\n\t\t\te = GF_OK;\n\t\t} else {\n\t\t\te = aom_av1_parse_temporal_unit_from_section5(ctx->bs, &ctx->state);\n\t\t}\n\t\tbreak;\n\tcase AnnexB:\n\t\t//first TU loaded !\n\t\tif (ctx->state.bs && gf_bs_get_position(ctx->state.bs)) {\n\t\t\te = GF_OK;\n\t\t} else {\n\t\t\te = aom_av1_parse_temporal_unit_from_annexb(ctx->bs, &ctx->state);\n\t\t\tif (e==GF_BUFFER_TOO_SMALL) {\n\t\t\t\tgf_av1_reset_state(&ctx->state, GF_FALSE);\n\t\t\t\tgf_bs_seek(ctx->bs, start);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase IVF:\n\t\t//first frame loaded !\n\t\tif (ctx->state.bs && gf_bs_get_position(ctx->state.bs)) {\n\t\t\te = GF_OK;\n\t\t} else {\n\t\t\te = aom_av1_parse_temporal_unit_from_ivf(ctx->bs, &ctx->state);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\te = GF_NOT_SUPPORTED;\n\t}\n\n\t//check pid state\n\tav1dmx_check_pid(filter, ctx);\n\n\t//fixme, we need to flush at each DFG start - for now we assume one PES = one DFG as we do in the muxer\n\tif (ctx->timescale && (e==GF_BUFFER_TOO_SMALL))\n\t\te = GF_OK;\n\n\tif (e) {\n\t\tif (e!=GF_EOS && e!=GF_BUFFER_TOO_SMALL) {\n\t\t\tav1dmx_parse_flush_sample(filter, ctx);\n\t\t}\n\t\treturn e;\n\t}\n\n\n\tif (!ctx->opid) {\n\t\tif (ctx->state.obu_type != OBU_TEMPORAL_DELIMITER) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_MEDIA, (\"[AV1Dmx] output pid not configured (no sequence header yet ?), skipping OBU\\n\"));\n\t\t}\n\t\tgf_av1_reset_state(&ctx->state, GF_FALSE);\n\t\treturn GF_OK;\n\t}\n\n\tif (!ctx->is_playing) {\n\t\t//don't reset state we would skip seq header obu in first frame\n\t\t//gf_av1_reset_state(&ctx->state, GF_FALSE);\n\t\treturn GF_OK;\n\t}\n\n\treturn av1dmx_parse_flush_sample(filter, ctx);\n\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -49,7 +49,12 @@\n \tif (ctx->timescale && (e==GF_BUFFER_TOO_SMALL))\n \t\te = GF_OK;\n \n-\tif (e) return e;\n+\tif (e) {\n+\t\tif (e!=GF_EOS && e!=GF_BUFFER_TOO_SMALL) {\n+\t\t\tav1dmx_parse_flush_sample(filter, ctx);\n+\t\t}\n+\t\treturn e;\n+\t}\n \n \n \tif (!ctx->opid) {",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (e) return e;"
            ],
            "added_lines": [
                "\tif (e) {",
                "\t\tif (e!=GF_EOS && e!=GF_BUFFER_TOO_SMALL) {",
                "\t\t\tav1dmx_parse_flush_sample(filter, ctx);",
                "\t\t}",
                "\t\treturn e;",
                "\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-25801",
        "func_name": "tensorflow/FractionalAvgPoolOp",
        "description": "TensorFlow is an open source machine learning platform. Prior to versions 2.12.0 and 2.11.1, `nn_ops.fractional_avg_pool_v2` and `nn_ops.fractional_max_pool_v2` require the first and fourth elements of their parameter `pooling_ratio` to be equal to 1.0, as pooling on batch and channel dimensions is not supported. A fix is included in TensorFlow 2.12.0 and 2.11.1.",
        "git_url": "https://github.com/tensorflow/tensorflow/commit/ee50d1e00f81f62a4517453f721c634bbb478307",
        "commit_title": "Fix security vulnerability with FractionalMax(AVG)Pool with illegal pooling_ratio",
        "commit_text": " PiperOrigin-RevId: 501651261",
        "func_before": "explicit FractionalAvgPoolOp(OpKernelConstruction* context)\n      : OpKernel(context) {\n    OP_REQUIRES_OK(context, context->GetAttr(\"pooling_ratio\", &pooling_ratio_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"pseudo_random\", &pseudo_random_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"overlapping\", &overlapping_));\n    OP_REQUIRES(context, pooling_ratio_.size() == 4,\n                errors::InvalidArgument(\n                    \"pooling_ratio field must specify 4 dimensions\"));\n    for (std::size_t i = 0; i < pooling_ratio_.size(); ++i) {\n      OP_REQUIRES(context, pooling_ratio_[i] >= 1,\n                  errors::InvalidArgument(\n                      \"pooling_ratio cannot be smaller than 1, got: \",\n                      pooling_ratio_[i]));\n    }\n    OP_REQUIRES(\n        context, pooling_ratio_[0] == 1 || pooling_ratio_[3] == 1,\n        errors::Unimplemented(\"Fractional average pooling is not yet \"\n                              \"supported on the batch nor channel dimension.\"));\n    OP_REQUIRES_OK(context, context->GetAttr(\"deterministic\", &deterministic_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"seed\", &seed_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"seed2\", &seed2_));\n    if (deterministic_) {\n      // If both seeds are not set when deterministic_ is true, force set seeds.\n      if ((seed_ == 0) && (seed2_ == 0)) {\n        seed_ = random::New64();\n        seed2_ = random::New64();\n      }\n    } else {\n      OP_REQUIRES(\n          context, (seed_ == 0) && (seed2_ == 0),\n          errors::InvalidArgument(\n              \"Both seed and seed2 should be 0 if deterministic is false.\"));\n    }\n  }",
        "func": "explicit FractionalAvgPoolOp(OpKernelConstruction* context)\n      : OpKernel(context) {\n    OP_REQUIRES_OK(context, context->GetAttr(\"pooling_ratio\", &pooling_ratio_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"pseudo_random\", &pseudo_random_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"overlapping\", &overlapping_));\n    OP_REQUIRES(context, pooling_ratio_.size() == 4,\n                errors::InvalidArgument(\n                    \"pooling_ratio field must specify 4 dimensions\"));\n    for (std::size_t i = 0; i < pooling_ratio_.size(); ++i) {\n      OP_REQUIRES(context, pooling_ratio_[i] >= 1,\n                  errors::InvalidArgument(\n                      \"pooling_ratio cannot be smaller than 1, got: \",\n                      pooling_ratio_[i]));\n    }\n    OP_REQUIRES(\n        context, pooling_ratio_[0] == 1 && pooling_ratio_[3] == 1,\n        errors::Unimplemented(\"Fractional average pooling is not yet \"\n                              \"supported on the batch nor channel dimension.\"));\n    OP_REQUIRES_OK(context, context->GetAttr(\"deterministic\", &deterministic_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"seed\", &seed_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"seed2\", &seed2_));\n    if (deterministic_) {\n      // If both seeds are not set when deterministic_ is true, force set seeds.\n      if ((seed_ == 0) && (seed2_ == 0)) {\n        seed_ = random::New64();\n        seed2_ = random::New64();\n      }\n    } else {\n      OP_REQUIRES(\n          context, (seed_ == 0) && (seed2_ == 0),\n          errors::InvalidArgument(\n              \"Both seed and seed2 should be 0 if deterministic is false.\"));\n    }\n  }",
        "diff_func": "--- func_before\n+++ func_after\n@@ -13,7 +13,7 @@\n                       pooling_ratio_[i]));\n     }\n     OP_REQUIRES(\n-        context, pooling_ratio_[0] == 1 || pooling_ratio_[3] == 1,\n+        context, pooling_ratio_[0] == 1 && pooling_ratio_[3] == 1,\n         errors::Unimplemented(\"Fractional average pooling is not yet \"\n                               \"supported on the batch nor channel dimension.\"));\n     OP_REQUIRES_OK(context, context->GetAttr(\"deterministic\", &deterministic_));",
        "diff_line_info": {
            "deleted_lines": [
                "        context, pooling_ratio_[0] == 1 || pooling_ratio_[3] == 1,"
            ],
            "added_lines": [
                "        context, pooling_ratio_[0] == 1 && pooling_ratio_[3] == 1,"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-25801",
        "func_name": "tensorflow/FractionalMaxPoolOp",
        "description": "TensorFlow is an open source machine learning platform. Prior to versions 2.12.0 and 2.11.1, `nn_ops.fractional_avg_pool_v2` and `nn_ops.fractional_max_pool_v2` require the first and fourth elements of their parameter `pooling_ratio` to be equal to 1.0, as pooling on batch and channel dimensions is not supported. A fix is included in TensorFlow 2.12.0 and 2.11.1.",
        "git_url": "https://github.com/tensorflow/tensorflow/commit/ee50d1e00f81f62a4517453f721c634bbb478307",
        "commit_title": "Fix security vulnerability with FractionalMax(AVG)Pool with illegal pooling_ratio",
        "commit_text": " PiperOrigin-RevId: 501651261",
        "func_before": "explicit FractionalMaxPoolOp(OpKernelConstruction* context)\n      : OpKernel(context) {\n    OP_REQUIRES_OK(context, context->GetAttr(\"pooling_ratio\", &pooling_ratio_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"pseudo_random\", &pseudo_random_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"overlapping\", &overlapping_));\n\n    OP_REQUIRES(context, pooling_ratio_.size() == 4,\n                errors::InvalidArgument(\"pooling_ratio field must \"\n                                        \"specify 4 dimensions\"));\n    for (std::size_t i = 0; i < pooling_ratio_.size(); ++i) {\n      OP_REQUIRES(context, pooling_ratio_[i] >= 1,\n                  errors::InvalidArgument(\n                      \"pooling_ratio cannot be smaller than 1, got: \",\n                      pooling_ratio_[i]));\n    }\n\n    OP_REQUIRES(\n        context, pooling_ratio_[0] == 1 || pooling_ratio_[3] == 1,\n        errors::Unimplemented(\"Fractional max pooling is not yet \"\n                              \"supported on the batch nor channel dimension.\"));\n\n    OP_REQUIRES_OK(context, context->GetAttr(\"deterministic\", &deterministic_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"seed\", &seed_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"seed2\", &seed2_));\n    if (deterministic_) {\n      // If both seeds are not set when deterministic_ is true, force set seeds.\n      if ((seed_ == 0) && (seed2_ == 0)) {\n        seed_ = random::New64();\n        seed2_ = random::New64();\n      }\n    } else {\n      OP_REQUIRES(\n          context, (seed_ == 0) && (seed2_ == 0),\n          errors::InvalidArgument(\n              \"Both seed and seed2 should be 0 if deterministic is false.\"));\n    }\n  }",
        "func": "explicit FractionalMaxPoolOp(OpKernelConstruction* context)\n      : OpKernel(context) {\n    OP_REQUIRES_OK(context, context->GetAttr(\"pooling_ratio\", &pooling_ratio_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"pseudo_random\", &pseudo_random_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"overlapping\", &overlapping_));\n\n    OP_REQUIRES(context, pooling_ratio_.size() == 4,\n                errors::InvalidArgument(\"pooling_ratio field must \"\n                                        \"specify 4 dimensions\"));\n    for (std::size_t i = 0; i < pooling_ratio_.size(); ++i) {\n      OP_REQUIRES(context, pooling_ratio_[i] >= 1,\n                  errors::InvalidArgument(\n                      \"pooling_ratio cannot be smaller than 1, got: \",\n                      pooling_ratio_[i]));\n    }\n\n    OP_REQUIRES(\n        context, pooling_ratio_[0] == 1 && pooling_ratio_[3] == 1,\n        errors::Unimplemented(\"Fractional max pooling is not yet \"\n                              \"supported on the batch nor channel dimension.\"));\n\n    OP_REQUIRES_OK(context, context->GetAttr(\"deterministic\", &deterministic_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"seed\", &seed_));\n    OP_REQUIRES_OK(context, context->GetAttr(\"seed2\", &seed2_));\n    if (deterministic_) {\n      // If both seeds are not set when deterministic_ is true, force set seeds.\n      if ((seed_ == 0) && (seed2_ == 0)) {\n        seed_ = random::New64();\n        seed2_ = random::New64();\n      }\n    } else {\n      OP_REQUIRES(\n          context, (seed_ == 0) && (seed2_ == 0),\n          errors::InvalidArgument(\n              \"Both seed and seed2 should be 0 if deterministic is false.\"));\n    }\n  }",
        "diff_func": "--- func_before\n+++ func_after\n@@ -15,7 +15,7 @@\n     }\n \n     OP_REQUIRES(\n-        context, pooling_ratio_[0] == 1 || pooling_ratio_[3] == 1,\n+        context, pooling_ratio_[0] == 1 && pooling_ratio_[3] == 1,\n         errors::Unimplemented(\"Fractional max pooling is not yet \"\n                               \"supported on the batch nor channel dimension.\"));\n ",
        "diff_line_info": {
            "deleted_lines": [
                "        context, pooling_ratio_[0] == 1 || pooling_ratio_[3] == 1,"
            ],
            "added_lines": [
                "        context, pooling_ratio_[0] == 1 && pooling_ratio_[3] == 1,"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-29469",
        "func_name": "GNOME/libxml2/xmlDictComputeFastKey",
        "description": "An issue was discovered in libxml2 before 2.10.4. When hashing empty dict strings in a crafted XML document, xmlDictComputeFastKey in dict.c can produce non-deterministic values, leading to various logic and memory errors, such as a double free. This behavior occurs because there is an attempt to use the first byte of an empty string, and any value is possible (not solely the '\\0' value).",
        "git_url": "https://github.com/GNOME/libxml2/commit/547edbf1cbdccd46b2e8ff322a456eaa5931c5df",
        "commit_title": "[CVE-2023-29469] Hashing of empty dict strings isn't deterministic",
        "commit_text": " When hashing empty strings which aren't null-terminated, xmlDictComputeFastKey could produce inconsistent results. This could lead to various logic or memory errors, including double frees.  For consistency the seed is also taken into account, but this shouldn't have an impact on security.  Found by OSS-Fuzz.  Fixes #510.",
        "func_before": "static unsigned long\nxmlDictComputeFastKey(const xmlChar *name, int namelen, int seed) {\n    unsigned long value = seed;\n\n    if (name == NULL) return(0);\n    value += *name;\n    value <<= 5;\n    if (namelen > 10) {\n        value += name[namelen - 1];\n        namelen = 10;\n    }\n    switch (namelen) {\n        case 10: value += name[9];\n        /* Falls through. */\n        case 9: value += name[8];\n        /* Falls through. */\n        case 8: value += name[7];\n        /* Falls through. */\n        case 7: value += name[6];\n        /* Falls through. */\n        case 6: value += name[5];\n        /* Falls through. */\n        case 5: value += name[4];\n        /* Falls through. */\n        case 4: value += name[3];\n        /* Falls through. */\n        case 3: value += name[2];\n        /* Falls through. */\n        case 2: value += name[1];\n        /* Falls through. */\n        default: break;\n    }\n    return(value);\n}",
        "func": "static unsigned long\nxmlDictComputeFastKey(const xmlChar *name, int namelen, int seed) {\n    unsigned long value = seed;\n\n    if ((name == NULL) || (namelen <= 0))\n        return(value);\n    value += *name;\n    value <<= 5;\n    if (namelen > 10) {\n        value += name[namelen - 1];\n        namelen = 10;\n    }\n    switch (namelen) {\n        case 10: value += name[9];\n        /* Falls through. */\n        case 9: value += name[8];\n        /* Falls through. */\n        case 8: value += name[7];\n        /* Falls through. */\n        case 7: value += name[6];\n        /* Falls through. */\n        case 6: value += name[5];\n        /* Falls through. */\n        case 5: value += name[4];\n        /* Falls through. */\n        case 4: value += name[3];\n        /* Falls through. */\n        case 3: value += name[2];\n        /* Falls through. */\n        case 2: value += name[1];\n        /* Falls through. */\n        default: break;\n    }\n    return(value);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,7 +2,8 @@\n xmlDictComputeFastKey(const xmlChar *name, int namelen, int seed) {\n     unsigned long value = seed;\n \n-    if (name == NULL) return(0);\n+    if ((name == NULL) || (namelen <= 0))\n+        return(value);\n     value += *name;\n     value <<= 5;\n     if (namelen > 10) {",
        "diff_line_info": {
            "deleted_lines": [
                "    if (name == NULL) return(0);"
            ],
            "added_lines": [
                "    if ((name == NULL) || (namelen <= 0))",
                "        return(value);"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-35784",
        "func_name": "libressl/openbsd/ssl3_free",
        "description": "A double free or use after free could occur after SSL_clear in OpenBSD 7.2 before errata 026 and 7.3 before errata 004, and in LibreSSL before 3.6.3 and 3.7.x before 3.7.3. NOTE: OpenSSL is not affected.",
        "git_url": "https://github.com/libressl/openbsd/commit/e42d8f4b21a8a498e2eabbffe4c7b7d4ef7cec54",
        "commit_title": "add missing pointer invalidation",
        "commit_text": " ok tb",
        "func_before": "void\nssl3_free(SSL *s)\n{\n\tif (s == NULL)\n\t\treturn;\n\n\ttls1_cleanup_key_block(s);\n\tssl3_release_read_buffer(s);\n\tssl3_release_write_buffer(s);\n\n\ttls_content_free(s->s3->rcontent);\n\n\ttls_buffer_free(s->s3->alert_fragment);\n\ttls_buffer_free(s->s3->handshake_fragment);\n\n\tfreezero(s->s3->hs.sigalgs, s->s3->hs.sigalgs_len);\n\tsk_X509_pop_free(s->s3->hs.peer_certs, X509_free);\n\tsk_X509_pop_free(s->s3->hs.peer_certs_no_leaf, X509_free);\n\ttls_key_share_free(s->s3->hs.key_share);\n\n\ttls13_secrets_destroy(s->s3->hs.tls13.secrets);\n\tfreezero(s->s3->hs.tls13.cookie, s->s3->hs.tls13.cookie_len);\n\ttls13_clienthello_hash_clear(&s->s3->hs.tls13);\n\n\ttls_buffer_free(s->s3->hs.tls13.quic_read_buffer);\n\n\tsk_X509_NAME_pop_free(s->s3->hs.tls12.ca_names, X509_NAME_free);\n\tsk_X509_pop_free(s->verified_chain, X509_free);\n\n\ttls1_transcript_free(s);\n\ttls1_transcript_hash_free(s);\n\n\tfree(s->s3->alpn_selected);\n\n\tfreezero(s->s3->peer_quic_transport_params,\n\t    s->s3->peer_quic_transport_params_len);\n\n\tfreezero(s->s3, sizeof(*s->s3));\n\n\ts->s3 = NULL;\n}",
        "func": "void\nssl3_free(SSL *s)\n{\n\tif (s == NULL)\n\t\treturn;\n\n\ttls1_cleanup_key_block(s);\n\tssl3_release_read_buffer(s);\n\tssl3_release_write_buffer(s);\n\n\ttls_content_free(s->s3->rcontent);\n\n\ttls_buffer_free(s->s3->alert_fragment);\n\ttls_buffer_free(s->s3->handshake_fragment);\n\n\tfreezero(s->s3->hs.sigalgs, s->s3->hs.sigalgs_len);\n\tsk_X509_pop_free(s->s3->hs.peer_certs, X509_free);\n\tsk_X509_pop_free(s->s3->hs.peer_certs_no_leaf, X509_free);\n\ttls_key_share_free(s->s3->hs.key_share);\n\n\ttls13_secrets_destroy(s->s3->hs.tls13.secrets);\n\tfreezero(s->s3->hs.tls13.cookie, s->s3->hs.tls13.cookie_len);\n\ttls13_clienthello_hash_clear(&s->s3->hs.tls13);\n\n\ttls_buffer_free(s->s3->hs.tls13.quic_read_buffer);\n\n\tsk_X509_NAME_pop_free(s->s3->hs.tls12.ca_names, X509_NAME_free);\n\tsk_X509_pop_free(s->verified_chain, X509_free);\n\ts->verified_chain = NULL;\n\n\ttls1_transcript_free(s);\n\ttls1_transcript_hash_free(s);\n\n\tfree(s->s3->alpn_selected);\n\n\tfreezero(s->s3->peer_quic_transport_params,\n\t    s->s3->peer_quic_transport_params_len);\n\n\tfreezero(s->s3, sizeof(*s->s3));\n\n\ts->s3 = NULL;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -26,6 +26,7 @@\n \n \tsk_X509_NAME_pop_free(s->s3->hs.tls12.ca_names, X509_NAME_free);\n \tsk_X509_pop_free(s->verified_chain, X509_free);\n+\ts->verified_chain = NULL;\n \n \ttls1_transcript_free(s);\n \ttls1_transcript_hash_free(s);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\ts->verified_chain = NULL;"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-12858",
        "func_name": "nih-at/libzip/_zip_dirent_read",
        "description": "Double free vulnerability in the _zip_dirent_read function in zip_dirent.c in libzip allows attackers to have unspecified impact via unknown vectors.",
        "git_url": "https://github.com/nih-at/libzip/commit/2217022b7d1142738656d891e00b3d2d9179b796",
        "commit_title": "Fix double free().",
        "commit_text": " Found by Brian 'geeknik' Carpenter using AFL.",
        "func_before": "zip_int64_t\n_zip_dirent_read(zip_dirent_t *zde, zip_source_t *src, zip_buffer_t *buffer, bool local, zip_error_t *error)\n{\n    zip_uint8_t buf[CDENTRYSIZE];\n    zip_uint16_t dostime, dosdate;\n    zip_uint32_t size, variable_size;\n    zip_uint16_t filename_len, comment_len, ef_len;\n\n    bool from_buffer = (buffer != NULL);\n\n    size = local ? LENTRYSIZE : CDENTRYSIZE;\n\n    if (buffer) {\n        if (_zip_buffer_left(buffer) < size) {\n            zip_error_set(error, ZIP_ER_NOZIP, 0);\n            return -1;\n        }\n    }\n    else {\n        if ((buffer = _zip_buffer_new_from_source(src, size, buf, error)) == NULL) {\n            return -1;\n        }\n    }\n\n    if (memcmp(_zip_buffer_get(buffer, 4), (local ? LOCAL_MAGIC : CENTRAL_MAGIC), 4) != 0) {\n\tzip_error_set(error, ZIP_ER_NOZIP, 0);\n        if (!from_buffer) {\n            _zip_buffer_free(buffer);\n        }\n\treturn -1;\n    }\n\n    /* convert buffercontents to zip_dirent */\n\n    _zip_dirent_init(zde);\n    if (!local)\n\tzde->version_madeby = _zip_buffer_get_16(buffer);\n    else\n\tzde->version_madeby = 0;\n    zde->version_needed = _zip_buffer_get_16(buffer);\n    zde->bitflags = _zip_buffer_get_16(buffer);\n    zde->comp_method = _zip_buffer_get_16(buffer);\n\n    /* convert to time_t */\n    dostime = _zip_buffer_get_16(buffer);\n    dosdate = _zip_buffer_get_16(buffer);\n    zde->last_mod = _zip_d2u_time(dostime, dosdate);\n\n    zde->crc = _zip_buffer_get_32(buffer);\n    zde->comp_size = _zip_buffer_get_32(buffer);\n    zde->uncomp_size = _zip_buffer_get_32(buffer);\n\n    filename_len = _zip_buffer_get_16(buffer);\n    ef_len = _zip_buffer_get_16(buffer);\n\n    if (local) {\n\tcomment_len = 0;\n\tzde->disk_number = 0;\n\tzde->int_attrib = 0;\n\tzde->ext_attrib = 0;\n\tzde->offset = 0;\n    } else {\n\tcomment_len = _zip_buffer_get_16(buffer);\n\tzde->disk_number = _zip_buffer_get_16(buffer);\n\tzde->int_attrib = _zip_buffer_get_16(buffer);\n\tzde->ext_attrib = _zip_buffer_get_32(buffer);\n\tzde->offset = _zip_buffer_get_32(buffer);\n    }\n\n    if (!_zip_buffer_ok(buffer)) {\n        zip_error_set(error, ZIP_ER_INTERNAL, 0);\n        if (!from_buffer) {\n            _zip_buffer_free(buffer);\n        }\n        return -1;\n    }\n\n    if (zde->bitflags & ZIP_GPBF_ENCRYPTED) {\n\tif (zde->bitflags & ZIP_GPBF_STRONG_ENCRYPTION) {\n\t    /* TODO */\n\t    zde->encryption_method = ZIP_EM_UNKNOWN;\n\t}\n\telse {\n\t    zde->encryption_method = ZIP_EM_TRAD_PKWARE;\n\t}\n    }\n    else {\n\tzde->encryption_method = ZIP_EM_NONE;\n    }\n\n    zde->filename = NULL;\n    zde->extra_fields = NULL;\n    zde->comment = NULL;\n\n    variable_size = (zip_uint32_t)filename_len+(zip_uint32_t)ef_len+(zip_uint32_t)comment_len;\n\n    if (from_buffer) {\n        if (_zip_buffer_left(buffer) < variable_size) {\n            zip_error_set(error, ZIP_ER_INCONS, 0);\n            return -1;\n        }\n    }\n    else {\n        _zip_buffer_free(buffer);\n\n        if ((buffer = _zip_buffer_new_from_source(src, variable_size, NULL, error)) == NULL) {\n            return -1;\n        }\n    }\n\n    if (filename_len) {\n\tzde->filename = _zip_read_string(buffer, src, filename_len, 1, error);\n        if (!zde->filename) {\n            if (zip_error_code_zip(error) == ZIP_ER_EOF) {\n                zip_error_set(error, ZIP_ER_INCONS, 0);\n            }\n            if (!from_buffer) {\n                _zip_buffer_free(buffer);\n            }\n\t    return -1;\n        }\n\n\tif (zde->bitflags & ZIP_GPBF_ENCODING_UTF_8) {\n\t    if (_zip_guess_encoding(zde->filename, ZIP_ENCODING_UTF8_KNOWN) == ZIP_ENCODING_ERROR) {\n\t\tzip_error_set(error, ZIP_ER_INCONS, 0);\n                if (!from_buffer) {\n                    _zip_buffer_free(buffer);\n                }\n\t\treturn -1;\n\t    }\n\t}\n    }\n\n    if (ef_len) {\n\tzip_uint8_t *ef = _zip_read_data(buffer, src, ef_len, 0, error);\n\n        if (ef == NULL) {\n            if (!from_buffer) {\n                _zip_buffer_free(buffer);\n            }\n\t    return -1;\n        }\n        if (!_zip_ef_parse(ef, ef_len, local ? ZIP_EF_LOCAL : ZIP_EF_CENTRAL, &zde->extra_fields, error)) {\n\t    free(ef);\n            if (!from_buffer) {\n                _zip_buffer_free(buffer);\n            }\n\t    return -1;\n\t}\n\tfree(ef);\n\tif (local)\n\t    zde->local_extra_fields_read = 1;\n    }\n\n    if (comment_len) {\n\tzde->comment = _zip_read_string(buffer, src, comment_len, 0, error);\n        if (!zde->comment) {\n            if (!from_buffer) {\n                _zip_buffer_free(buffer);\n            }\n\t    return -1;\n        }\n\tif (zde->bitflags & ZIP_GPBF_ENCODING_UTF_8) {\n\t    if (_zip_guess_encoding(zde->comment, ZIP_ENCODING_UTF8_KNOWN) == ZIP_ENCODING_ERROR) {\n\t\tzip_error_set(error, ZIP_ER_INCONS, 0);\n                if (!from_buffer) {\n                    _zip_buffer_free(buffer);\n                }\n\t\treturn -1;\n\t    }\n\t}\n    }\n\n    zde->filename = _zip_dirent_process_ef_utf_8(zde, ZIP_EF_UTF_8_NAME, zde->filename);\n    zde->comment = _zip_dirent_process_ef_utf_8(zde, ZIP_EF_UTF_8_COMMENT, zde->comment);\n\n    /* Zip64 */\n\n    if (zde->uncomp_size == ZIP_UINT32_MAX || zde->comp_size == ZIP_UINT32_MAX || zde->offset == ZIP_UINT32_MAX) {\n\tzip_uint16_t got_len;\n        zip_buffer_t *ef_buffer;\n\tconst zip_uint8_t *ef = _zip_ef_get_by_id(zde->extra_fields, &got_len, ZIP_EF_ZIP64, 0, local ? ZIP_EF_LOCAL : ZIP_EF_CENTRAL, error);\n\t/* TODO: if got_len == 0 && !ZIP64_EOCD: no error, 0xffffffff is valid value */\n        if (ef == NULL) {\n            if (!from_buffer) {\n                _zip_buffer_free(buffer);\n            }\n\t    return -1;\n        }\n\n        if ((ef_buffer = _zip_buffer_new((zip_uint8_t *)ef, got_len)) == NULL) {\n            zip_error_set(error, ZIP_ER_MEMORY, 0);\n            if (!from_buffer) {\n                _zip_buffer_free(buffer);\n            }\n            return -1;\n        }\n\n\tif (zde->uncomp_size == ZIP_UINT32_MAX)\n\t    zde->uncomp_size = _zip_buffer_get_64(ef_buffer);\n\telse if (local) {\n\t    /* From appnote.txt: This entry in the Local header MUST\n\t       include BOTH original and compressed file size fields. */\n            (void)_zip_buffer_skip(ef_buffer, 8); /* error is caught by _zip_buffer_eof() call */\n\t}\n\tif (zde->comp_size == ZIP_UINT32_MAX)\n\t    zde->comp_size = _zip_buffer_get_64(ef_buffer);\n\tif (!local) {\n\t    if (zde->offset == ZIP_UINT32_MAX)\n\t\tzde->offset = _zip_buffer_get_64(ef_buffer);\n\t    if (zde->disk_number == ZIP_UINT16_MAX)\n\t\tzde->disk_number = _zip_buffer_get_32(buffer);\n\t}\n\n        if (!_zip_buffer_eof(ef_buffer)) {\n            zip_error_set(error, ZIP_ER_INCONS, 0);\n            _zip_buffer_free(ef_buffer);\n            if (!from_buffer) {\n                _zip_buffer_free(buffer);\n            }\n            return -1;\n        }\n        _zip_buffer_free(ef_buffer);\n    }\n\n    if (!_zip_buffer_ok(buffer)) {\n        zip_error_set(error, ZIP_ER_INTERNAL, 0);\n        if (!from_buffer) {\n            _zip_buffer_free(buffer);\n        }\n        return -1;\n    }\n    if (!from_buffer) {\n        _zip_buffer_free(buffer);\n    }\n\n    /* zip_source_seek / zip_source_tell don't support values > ZIP_INT64_MAX */\n    if (zde->offset > ZIP_INT64_MAX) {\n\tzip_error_set(error, ZIP_ER_SEEK, EFBIG);\n\treturn -1;\n    }\n\n    if (!_zip_dirent_process_winzip_aes(zde, error)) {\n\tif (!from_buffer) {\n\t    _zip_buffer_free(buffer);\n\t}\n\treturn -1;\n    }\n\n    zde->extra_fields = _zip_ef_remove_internal(zde->extra_fields);\n\n    return (zip_int64_t)(size + variable_size);\n}",
        "func": "zip_int64_t\n_zip_dirent_read(zip_dirent_t *zde, zip_source_t *src, zip_buffer_t *buffer, bool local, zip_error_t *error)\n{\n    zip_uint8_t buf[CDENTRYSIZE];\n    zip_uint16_t dostime, dosdate;\n    zip_uint32_t size, variable_size;\n    zip_uint16_t filename_len, comment_len, ef_len;\n\n    bool from_buffer = (buffer != NULL);\n\n    size = local ? LENTRYSIZE : CDENTRYSIZE;\n\n    if (buffer) {\n        if (_zip_buffer_left(buffer) < size) {\n            zip_error_set(error, ZIP_ER_NOZIP, 0);\n            return -1;\n        }\n    }\n    else {\n        if ((buffer = _zip_buffer_new_from_source(src, size, buf, error)) == NULL) {\n            return -1;\n        }\n    }\n\n    if (memcmp(_zip_buffer_get(buffer, 4), (local ? LOCAL_MAGIC : CENTRAL_MAGIC), 4) != 0) {\n\tzip_error_set(error, ZIP_ER_NOZIP, 0);\n        if (!from_buffer) {\n            _zip_buffer_free(buffer);\n        }\n\treturn -1;\n    }\n\n    /* convert buffercontents to zip_dirent */\n\n    _zip_dirent_init(zde);\n    if (!local)\n\tzde->version_madeby = _zip_buffer_get_16(buffer);\n    else\n\tzde->version_madeby = 0;\n    zde->version_needed = _zip_buffer_get_16(buffer);\n    zde->bitflags = _zip_buffer_get_16(buffer);\n    zde->comp_method = _zip_buffer_get_16(buffer);\n\n    /* convert to time_t */\n    dostime = _zip_buffer_get_16(buffer);\n    dosdate = _zip_buffer_get_16(buffer);\n    zde->last_mod = _zip_d2u_time(dostime, dosdate);\n\n    zde->crc = _zip_buffer_get_32(buffer);\n    zde->comp_size = _zip_buffer_get_32(buffer);\n    zde->uncomp_size = _zip_buffer_get_32(buffer);\n\n    filename_len = _zip_buffer_get_16(buffer);\n    ef_len = _zip_buffer_get_16(buffer);\n\n    if (local) {\n\tcomment_len = 0;\n\tzde->disk_number = 0;\n\tzde->int_attrib = 0;\n\tzde->ext_attrib = 0;\n\tzde->offset = 0;\n    } else {\n\tcomment_len = _zip_buffer_get_16(buffer);\n\tzde->disk_number = _zip_buffer_get_16(buffer);\n\tzde->int_attrib = _zip_buffer_get_16(buffer);\n\tzde->ext_attrib = _zip_buffer_get_32(buffer);\n\tzde->offset = _zip_buffer_get_32(buffer);\n    }\n\n    if (!_zip_buffer_ok(buffer)) {\n        zip_error_set(error, ZIP_ER_INTERNAL, 0);\n        if (!from_buffer) {\n            _zip_buffer_free(buffer);\n        }\n        return -1;\n    }\n\n    if (zde->bitflags & ZIP_GPBF_ENCRYPTED) {\n\tif (zde->bitflags & ZIP_GPBF_STRONG_ENCRYPTION) {\n\t    /* TODO */\n\t    zde->encryption_method = ZIP_EM_UNKNOWN;\n\t}\n\telse {\n\t    zde->encryption_method = ZIP_EM_TRAD_PKWARE;\n\t}\n    }\n    else {\n\tzde->encryption_method = ZIP_EM_NONE;\n    }\n\n    zde->filename = NULL;\n    zde->extra_fields = NULL;\n    zde->comment = NULL;\n\n    variable_size = (zip_uint32_t)filename_len+(zip_uint32_t)ef_len+(zip_uint32_t)comment_len;\n\n    if (from_buffer) {\n        if (_zip_buffer_left(buffer) < variable_size) {\n            zip_error_set(error, ZIP_ER_INCONS, 0);\n            return -1;\n        }\n    }\n    else {\n        _zip_buffer_free(buffer);\n\n        if ((buffer = _zip_buffer_new_from_source(src, variable_size, NULL, error)) == NULL) {\n            return -1;\n        }\n    }\n\n    if (filename_len) {\n\tzde->filename = _zip_read_string(buffer, src, filename_len, 1, error);\n        if (!zde->filename) {\n            if (zip_error_code_zip(error) == ZIP_ER_EOF) {\n                zip_error_set(error, ZIP_ER_INCONS, 0);\n            }\n            if (!from_buffer) {\n                _zip_buffer_free(buffer);\n            }\n\t    return -1;\n        }\n\n\tif (zde->bitflags & ZIP_GPBF_ENCODING_UTF_8) {\n\t    if (_zip_guess_encoding(zde->filename, ZIP_ENCODING_UTF8_KNOWN) == ZIP_ENCODING_ERROR) {\n\t\tzip_error_set(error, ZIP_ER_INCONS, 0);\n                if (!from_buffer) {\n                    _zip_buffer_free(buffer);\n                }\n\t\treturn -1;\n\t    }\n\t}\n    }\n\n    if (ef_len) {\n\tzip_uint8_t *ef = _zip_read_data(buffer, src, ef_len, 0, error);\n\n        if (ef == NULL) {\n            if (!from_buffer) {\n                _zip_buffer_free(buffer);\n            }\n\t    return -1;\n        }\n        if (!_zip_ef_parse(ef, ef_len, local ? ZIP_EF_LOCAL : ZIP_EF_CENTRAL, &zde->extra_fields, error)) {\n\t    free(ef);\n            if (!from_buffer) {\n                _zip_buffer_free(buffer);\n            }\n\t    return -1;\n\t}\n\tfree(ef);\n\tif (local)\n\t    zde->local_extra_fields_read = 1;\n    }\n\n    if (comment_len) {\n\tzde->comment = _zip_read_string(buffer, src, comment_len, 0, error);\n        if (!zde->comment) {\n            if (!from_buffer) {\n                _zip_buffer_free(buffer);\n            }\n\t    return -1;\n        }\n\tif (zde->bitflags & ZIP_GPBF_ENCODING_UTF_8) {\n\t    if (_zip_guess_encoding(zde->comment, ZIP_ENCODING_UTF8_KNOWN) == ZIP_ENCODING_ERROR) {\n\t\tzip_error_set(error, ZIP_ER_INCONS, 0);\n                if (!from_buffer) {\n                    _zip_buffer_free(buffer);\n                }\n\t\treturn -1;\n\t    }\n\t}\n    }\n\n    zde->filename = _zip_dirent_process_ef_utf_8(zde, ZIP_EF_UTF_8_NAME, zde->filename);\n    zde->comment = _zip_dirent_process_ef_utf_8(zde, ZIP_EF_UTF_8_COMMENT, zde->comment);\n\n    /* Zip64 */\n\n    if (zde->uncomp_size == ZIP_UINT32_MAX || zde->comp_size == ZIP_UINT32_MAX || zde->offset == ZIP_UINT32_MAX) {\n\tzip_uint16_t got_len;\n        zip_buffer_t *ef_buffer;\n\tconst zip_uint8_t *ef = _zip_ef_get_by_id(zde->extra_fields, &got_len, ZIP_EF_ZIP64, 0, local ? ZIP_EF_LOCAL : ZIP_EF_CENTRAL, error);\n\t/* TODO: if got_len == 0 && !ZIP64_EOCD: no error, 0xffffffff is valid value */\n        if (ef == NULL) {\n            if (!from_buffer) {\n                _zip_buffer_free(buffer);\n            }\n\t    return -1;\n        }\n\n        if ((ef_buffer = _zip_buffer_new((zip_uint8_t *)ef, got_len)) == NULL) {\n            zip_error_set(error, ZIP_ER_MEMORY, 0);\n            if (!from_buffer) {\n                _zip_buffer_free(buffer);\n            }\n            return -1;\n        }\n\n\tif (zde->uncomp_size == ZIP_UINT32_MAX)\n\t    zde->uncomp_size = _zip_buffer_get_64(ef_buffer);\n\telse if (local) {\n\t    /* From appnote.txt: This entry in the Local header MUST\n\t       include BOTH original and compressed file size fields. */\n            (void)_zip_buffer_skip(ef_buffer, 8); /* error is caught by _zip_buffer_eof() call */\n\t}\n\tif (zde->comp_size == ZIP_UINT32_MAX)\n\t    zde->comp_size = _zip_buffer_get_64(ef_buffer);\n\tif (!local) {\n\t    if (zde->offset == ZIP_UINT32_MAX)\n\t\tzde->offset = _zip_buffer_get_64(ef_buffer);\n\t    if (zde->disk_number == ZIP_UINT16_MAX)\n\t\tzde->disk_number = _zip_buffer_get_32(buffer);\n\t}\n\n        if (!_zip_buffer_eof(ef_buffer)) {\n            zip_error_set(error, ZIP_ER_INCONS, 0);\n            _zip_buffer_free(ef_buffer);\n            if (!from_buffer) {\n                _zip_buffer_free(buffer);\n            }\n            return -1;\n        }\n        _zip_buffer_free(ef_buffer);\n    }\n\n    if (!_zip_buffer_ok(buffer)) {\n        zip_error_set(error, ZIP_ER_INTERNAL, 0);\n        if (!from_buffer) {\n            _zip_buffer_free(buffer);\n        }\n        return -1;\n    }\n    if (!from_buffer) {\n        _zip_buffer_free(buffer);\n    }\n\n    /* zip_source_seek / zip_source_tell don't support values > ZIP_INT64_MAX */\n    if (zde->offset > ZIP_INT64_MAX) {\n\tzip_error_set(error, ZIP_ER_SEEK, EFBIG);\n\treturn -1;\n    }\n\n    if (!_zip_dirent_process_winzip_aes(zde, error)) {\n\treturn -1;\n    }\n\n    zde->extra_fields = _zip_ef_remove_internal(zde->extra_fields);\n\n    return (zip_int64_t)(size + variable_size);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -241,9 +241,6 @@\n     }\n \n     if (!_zip_dirent_process_winzip_aes(zde, error)) {\n-\tif (!from_buffer) {\n-\t    _zip_buffer_free(buffer);\n-\t}\n \treturn -1;\n     }\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (!from_buffer) {",
                "\t    _zip_buffer_free(buffer);",
                "\t}"
            ],
            "added_lines": []
        }
    },
    {
        "cve_id": "CVE-2021-45288",
        "func_name": "gpac/gf_sm_load_run_isom",
        "description": "A Double Free vulnerability exists in filedump.c in GPAC 1.0.1, which could cause a Denail of Service via a crafted file in the MP4Box command.",
        "git_url": "https://github.com/gpac/gpac/commit/9bbce9634cba1128aa4b96d590be578ae3ce80b3",
        "commit_title": "fixed #1956",
        "commit_text": "",
        "func_before": "static GF_Err gf_sm_load_run_isom(GF_SceneLoader *load)\n{\n\tGF_Err e;\n\tFILE *logs;\n\tu32 i, j, di, nbBifs, nbLaser, nb_samp, samp_done, init_offset;\n\tGF_StreamContext *sc;\n\tGF_ESD *esd;\n\tGF_ODCodec *od_dec;\n#ifndef GPAC_DISABLE_BIFS\n\tGF_BifsDecoder *bifs_dec;\n#endif\n#ifndef GPAC_DISABLE_LASER\n\tGF_LASeRCodec *lsr_dec;\n#endif\n\n\tif (!load || !load->isom) return GF_BAD_PARAM;\n\n\tnbBifs = nbLaser = 0;\n\te = GF_OK;\n#ifndef GPAC_DISABLE_BIFS\n\tbifs_dec = gf_bifs_decoder_new(load->scene_graph, 1);\n#endif\n\tod_dec = gf_odf_codec_new();\n\tlogs = NULL;\n#ifndef GPAC_DISABLE_LASER\n\tlsr_dec = gf_laser_decoder_new(load->scene_graph);\n#endif\n\tesd = NULL;\n\t/*load each stream*/\n\tnb_samp = 0;\n\tfor (i=0; i<gf_isom_get_track_count(load->isom); i++) {\n\t\tu32 type = gf_isom_get_media_type(load->isom, i+1);\n\t\tu32 subtype = gf_isom_get_mpeg4_subtype(load->isom, i+1, 1);\n\t\tswitch (type) {\n\t\tcase GF_ISOM_MEDIA_SCENE:\n\t\tcase GF_ISOM_MEDIA_OD:\n\t\t\tnb_samp += gf_isom_get_sample_count(load->isom, i+1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (subtype==GF_ISOM_SUBTYPE_MP4S) {\n\t\t\t\tnb_samp += gf_isom_get_sample_count(load->isom, i+1);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tsamp_done = 1;\n\tgf_isom_text_set_streaming_mode(load->isom, 1);\n\n\tfor (i=0; i<gf_isom_get_track_count(load->isom); i++) {\n\t\tu32 type = gf_isom_get_media_type(load->isom, i+1);\n\t\tu32 subtype = gf_isom_get_mpeg4_subtype(load->isom, i+1, 1);\n\t\tswitch (type) {\n\t\tcase GF_ISOM_MEDIA_SCENE:\n\t\tcase GF_ISOM_MEDIA_OD:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (subtype!=GF_ISOM_SUBTYPE_MP4S)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\t}\n\t\tesd = gf_isom_get_esd(load->isom, i+1, 1);\n\t\tif (!esd) continue;\n\t\tif (!esd->decoderConfig || (esd->decoderConfig->objectTypeIndication==GF_CODECID_TEXT_MPEG4)) {\n\t\t\tgf_odf_desc_del((GF_Descriptor *) esd);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ((esd->decoderConfig->objectTypeIndication == GF_CODECID_AFX) ||\n\t\t        (esd->decoderConfig->objectTypeIndication == GF_CODECID_SYNTHESIZED_TEXTURE)\n\t\t   ) {\n\t\t\tnb_samp += gf_isom_get_sample_count(load->isom, i+1);\n\t\t\tgf_odf_desc_del((GF_Descriptor *) esd);\n\t\t\tcontinue;\n\t\t}\n\t\tsc = gf_sm_stream_new(load->ctx, esd->ESID, esd->decoderConfig->streamType, esd->decoderConfig->objectTypeIndication);\n\t\tsc->streamType = esd->decoderConfig->streamType;\n\t\tsc->ESID = esd->ESID;\n\t\tsc->codec_id = esd->decoderConfig->objectTypeIndication;\n\t\tsc->timeScale = gf_isom_get_media_timescale(load->isom, i+1);\n\n\t\t/*we still need to reconfig the BIFS*/\n\t\tif (esd->decoderConfig->streamType==GF_STREAM_SCENE) {\n#ifndef GPAC_DISABLE_BIFS\n\t\t\t/*BIFS*/\n\t\t\tif (esd->decoderConfig->objectTypeIndication<=2) {\n\t\t\t\tif (!esd->dependsOnESID && nbBifs && !i)\n\t\t\t\t\tmp4_report(load, GF_OK, \"several scene namespaces used or improper scene dependencies in file - import may be incorrect\");\n\t\t\t\tif (!esd->decoderConfig->decoderSpecificInfo) {\n\t\t\t\t\t/* Hack for T-DMB non compliant streams */\n\t\t\t\t\te = gf_bifs_decoder_configure_stream(bifs_dec, esd->ESID, NULL, 0, esd->decoderConfig->objectTypeIndication);\n\t\t\t\t} else {\n\t\t\t\t\te = gf_bifs_decoder_configure_stream(bifs_dec, esd->ESID, esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength, esd->decoderConfig->objectTypeIndication);\n\t\t\t\t}\n\t\t\t\tif (e) goto exit;\n\t\t\t\tnbBifs++;\n\t\t\t}\n#endif\n\n#ifndef GPAC_DISABLE_LASER\n\t\t\t/*LASER*/\n\t\t\tif (esd->decoderConfig->objectTypeIndication==0x09) {\n\t\t\t\tif (!esd->dependsOnESID && nbBifs && !i)\n\t\t\t\t\tmp4_report(load, GF_OK, \"several scene namespaces used or improper scene dependencies in file - import may be incorrect\");\n\n\t\t\t\tif (!esd->decoderConfig->decoderSpecificInfo)\n\t\t\t\t\te = GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t\telse\n\t\t\t\t\te = gf_laser_decoder_configure_stream(lsr_dec, esd->ESID, esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength);\n\n\t\t\t\tif (e) goto exit;\n\t\t\t\tnbLaser++;\n\t\t\t}\n#endif\n\t\t}\n\n\t\tinit_offset = 0;\n\t\t/*dump all AUs*/\n\t\tfor (j=0; j<gf_isom_get_sample_count(load->isom, i+1); j++) {\n\t\t\tGF_AUContext *au;\n\t\t\tGF_ISOSample *samp = gf_isom_get_sample(load->isom, i+1, j+1, &di);\n\t\t\tif (!samp) {\n\t\t\t\tmp4_report(load, gf_isom_last_error(load->isom), \"Unable to fetch sample %d from track ID %d - aborting track import\", j+1, gf_isom_get_track_id(load->isom, i+1));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/*check if track has initial offset*/\n\t\t\tif (!j && gf_isom_get_edits_count(load->isom, i+1)) {\n\t\t\t\tu64 EditTime, dur, mtime;\n\t\t\t\tGF_ISOEditType mode;\n\t\t\t\tgf_isom_get_edit(load->isom, i+1, 1, &EditTime, &dur, &mtime, &mode);\n\t\t\t\tif (mode==GF_ISOM_EDIT_EMPTY) {\n\t\t\t\t\tinit_offset = (u32) (dur * sc->timeScale / gf_isom_get_timescale(load->isom) );\n\t\t\t\t}\n\t\t\t}\n\t\t\tsamp->DTS += init_offset;\n\n\t\t\tau = gf_sm_stream_au_new(sc, samp->DTS, ((Double)(s64) samp->DTS) / sc->timeScale, (samp->IsRAP==RAP) ? 1 : 0);\n\n\t\t\tif (esd->decoderConfig->streamType==GF_STREAM_SCENE) {\n#ifndef GPAC_DISABLE_BIFS\n\t\t\t\tif (esd->decoderConfig->objectTypeIndication<=2)\n\t\t\t\t\te = gf_bifs_decode_command_list(bifs_dec, esd->ESID, samp->data, samp->dataLength, au->commands);\n#endif\n#ifndef GPAC_DISABLE_LASER\n\t\t\t\tif (esd->decoderConfig->objectTypeIndication==0x09)\n\t\t\t\t\te = gf_laser_decode_command_list(lsr_dec, esd->ESID, samp->data, samp->dataLength, au->commands);\n#endif\n\t\t\t} else {\n\t\t\t\te = gf_odf_codec_set_au(od_dec, samp->data, samp->dataLength);\n\t\t\t\tif (!e) e = gf_odf_codec_decode(od_dec);\n\t\t\t\tif (!e) {\n\t\t\t\t\twhile (1) {\n\t\t\t\t\t\tGF_ODCom *odc = gf_odf_codec_get_com(od_dec);\n\t\t\t\t\t\tif (!odc) break;\n\t\t\t\t\t\t/*update ESDs if any*/\n\t\t\t\t\t\tUpdateODCommand(load->isom, odc);\n\t\t\t\t\t\tgf_list_add(au->commands, odc);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tgf_isom_sample_del(&samp);\n\t\t\tif (e) {\n\t\t\t\tmp4_report(load, gf_isom_last_error(load->isom), \"decoding sample %d from track ID %d failed\", j+1, gf_isom_get_track_id(load->isom, i+1));\n\t\t\t\tgoto exit;\n\t\t\t}\n\n\t\t\tsamp_done++;\n\t\t\tgf_set_progress(\"MP4 Loading\", samp_done, nb_samp);\n\t\t}\n\t\tgf_odf_desc_del((GF_Descriptor *) esd);\n\t\tesd = NULL;\n\t}\n\tgf_isom_text_set_streaming_mode(load->isom, 0);\n\nexit:\n#ifndef GPAC_DISABLE_BIFS\n\tgf_bifs_decoder_del(bifs_dec);\n#endif\n\tgf_odf_codec_del(od_dec);\n#ifndef GPAC_DISABLE_LASER\n\tgf_laser_decoder_del(lsr_dec);\n#endif\n\tif (esd) gf_odf_desc_del((GF_Descriptor *) esd);\n\tif (logs) gf_fclose(logs);\n\treturn e;\n}",
        "func": "static GF_Err gf_sm_load_run_isom(GF_SceneLoader *load)\n{\n\tGF_Err e;\n\tFILE *logs;\n\tu32 i, j, di, nbBifs, nbLaser, nb_samp, samp_done, init_offset;\n\tGF_StreamContext *sc;\n\tGF_ESD *esd;\n\tGF_ODCodec *od_dec;\n#ifndef GPAC_DISABLE_BIFS\n\tGF_BifsDecoder *bifs_dec;\n#endif\n#ifndef GPAC_DISABLE_LASER\n\tGF_LASeRCodec *lsr_dec;\n#endif\n\n\tif (!load || !load->isom) return GF_BAD_PARAM;\n\n\tnbBifs = nbLaser = 0;\n\te = GF_OK;\n#ifndef GPAC_DISABLE_BIFS\n\tbifs_dec = gf_bifs_decoder_new(load->scene_graph, 1);\n#endif\n\tod_dec = gf_odf_codec_new();\n\tlogs = NULL;\n#ifndef GPAC_DISABLE_LASER\n\tlsr_dec = gf_laser_decoder_new(load->scene_graph);\n#endif\n\tesd = NULL;\n\t/*load each stream*/\n\tnb_samp = 0;\n\tfor (i=0; i<gf_isom_get_track_count(load->isom); i++) {\n\t\tu32 type = gf_isom_get_media_type(load->isom, i+1);\n\t\tu32 subtype = gf_isom_get_mpeg4_subtype(load->isom, i+1, 1);\n\t\tswitch (type) {\n\t\tcase GF_ISOM_MEDIA_SCENE:\n\t\tcase GF_ISOM_MEDIA_OD:\n\t\t\tnb_samp += gf_isom_get_sample_count(load->isom, i+1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (subtype==GF_ISOM_SUBTYPE_MP4S) {\n\t\t\t\tnb_samp += gf_isom_get_sample_count(load->isom, i+1);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\tsamp_done = 1;\n\tgf_isom_text_set_streaming_mode(load->isom, 1);\n\n\tfor (i=0; i<gf_isom_get_track_count(load->isom); i++) {\n\t\tu32 type = gf_isom_get_media_type(load->isom, i+1);\n\t\tu32 subtype = gf_isom_get_mpeg4_subtype(load->isom, i+1, 1);\n\t\tswitch (type) {\n\t\tcase GF_ISOM_MEDIA_SCENE:\n\t\tcase GF_ISOM_MEDIA_OD:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (subtype!=GF_ISOM_SUBTYPE_MP4S)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\t}\n\t\tesd = gf_isom_get_esd(load->isom, i+1, 1);\n\t\tif (!esd) continue;\n\t\tif (!esd->decoderConfig || (esd->decoderConfig->objectTypeIndication==GF_CODECID_TEXT_MPEG4)) {\n\t\t\tgf_odf_desc_del((GF_Descriptor *) esd);\n\t\t\tesd = NULL;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ((esd->decoderConfig->objectTypeIndication == GF_CODECID_AFX) ||\n\t\t        (esd->decoderConfig->objectTypeIndication == GF_CODECID_SYNTHESIZED_TEXTURE)\n\t\t   ) {\n\t\t\tnb_samp += gf_isom_get_sample_count(load->isom, i+1);\n\t\t\tgf_odf_desc_del((GF_Descriptor *) esd);\n\t\t\tesd = NULL;\n\t\t\tcontinue;\n\t\t}\n\t\tsc = gf_sm_stream_new(load->ctx, esd->ESID, esd->decoderConfig->streamType, esd->decoderConfig->objectTypeIndication);\n\t\tsc->streamType = esd->decoderConfig->streamType;\n\t\tsc->ESID = esd->ESID;\n\t\tsc->codec_id = esd->decoderConfig->objectTypeIndication;\n\t\tsc->timeScale = gf_isom_get_media_timescale(load->isom, i+1);\n\n\t\t/*we still need to reconfig the BIFS*/\n\t\tif (esd->decoderConfig->streamType==GF_STREAM_SCENE) {\n#ifndef GPAC_DISABLE_BIFS\n\t\t\t/*BIFS*/\n\t\t\tif (esd->decoderConfig->objectTypeIndication<=2) {\n\t\t\t\tif (!esd->dependsOnESID && nbBifs && !i)\n\t\t\t\t\tmp4_report(load, GF_OK, \"several scene namespaces used or improper scene dependencies in file - import may be incorrect\");\n\t\t\t\tif (!esd->decoderConfig->decoderSpecificInfo) {\n\t\t\t\t\t/* Hack for T-DMB non compliant streams */\n\t\t\t\t\te = gf_bifs_decoder_configure_stream(bifs_dec, esd->ESID, NULL, 0, esd->decoderConfig->objectTypeIndication);\n\t\t\t\t} else {\n\t\t\t\t\te = gf_bifs_decoder_configure_stream(bifs_dec, esd->ESID, esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength, esd->decoderConfig->objectTypeIndication);\n\t\t\t\t}\n\t\t\t\tif (e) goto exit;\n\t\t\t\tnbBifs++;\n\t\t\t}\n#endif\n\n#ifndef GPAC_DISABLE_LASER\n\t\t\t/*LASER*/\n\t\t\tif (esd->decoderConfig->objectTypeIndication==0x09) {\n\t\t\t\tif (!esd->dependsOnESID && nbBifs && !i)\n\t\t\t\t\tmp4_report(load, GF_OK, \"several scene namespaces used or improper scene dependencies in file - import may be incorrect\");\n\n\t\t\t\tif (!esd->decoderConfig->decoderSpecificInfo)\n\t\t\t\t\te = GF_NON_COMPLIANT_BITSTREAM;\n\t\t\t\telse\n\t\t\t\t\te = gf_laser_decoder_configure_stream(lsr_dec, esd->ESID, esd->decoderConfig->decoderSpecificInfo->data, esd->decoderConfig->decoderSpecificInfo->dataLength);\n\n\t\t\t\tif (e) goto exit;\n\t\t\t\tnbLaser++;\n\t\t\t}\n#endif\n\t\t}\n\n\t\tinit_offset = 0;\n\t\t/*dump all AUs*/\n\t\tfor (j=0; j<gf_isom_get_sample_count(load->isom, i+1); j++) {\n\t\t\tGF_AUContext *au;\n\t\t\tGF_ISOSample *samp = gf_isom_get_sample(load->isom, i+1, j+1, &di);\n\t\t\tif (!samp) {\n\t\t\t\tmp4_report(load, gf_isom_last_error(load->isom), \"Unable to fetch sample %d from track ID %d - aborting track import\", j+1, gf_isom_get_track_id(load->isom, i+1));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/*check if track has initial offset*/\n\t\t\tif (!j && gf_isom_get_edits_count(load->isom, i+1)) {\n\t\t\t\tu64 EditTime, dur, mtime;\n\t\t\t\tGF_ISOEditType mode;\n\t\t\t\tgf_isom_get_edit(load->isom, i+1, 1, &EditTime, &dur, &mtime, &mode);\n\t\t\t\tif (mode==GF_ISOM_EDIT_EMPTY) {\n\t\t\t\t\tinit_offset = (u32) (dur * sc->timeScale / gf_isom_get_timescale(load->isom) );\n\t\t\t\t}\n\t\t\t}\n\t\t\tsamp->DTS += init_offset;\n\n\t\t\tau = gf_sm_stream_au_new(sc, samp->DTS, ((Double)(s64) samp->DTS) / sc->timeScale, (samp->IsRAP==RAP) ? 1 : 0);\n\n\t\t\tif (esd->decoderConfig->streamType==GF_STREAM_SCENE) {\n#ifndef GPAC_DISABLE_BIFS\n\t\t\t\tif (esd->decoderConfig->objectTypeIndication<=2)\n\t\t\t\t\te = gf_bifs_decode_command_list(bifs_dec, esd->ESID, samp->data, samp->dataLength, au->commands);\n#endif\n#ifndef GPAC_DISABLE_LASER\n\t\t\t\tif (esd->decoderConfig->objectTypeIndication==0x09)\n\t\t\t\t\te = gf_laser_decode_command_list(lsr_dec, esd->ESID, samp->data, samp->dataLength, au->commands);\n#endif\n\t\t\t} else {\n\t\t\t\te = gf_odf_codec_set_au(od_dec, samp->data, samp->dataLength);\n\t\t\t\tif (!e) e = gf_odf_codec_decode(od_dec);\n\t\t\t\tif (!e) {\n\t\t\t\t\twhile (1) {\n\t\t\t\t\t\tGF_ODCom *odc = gf_odf_codec_get_com(od_dec);\n\t\t\t\t\t\tif (!odc) break;\n\t\t\t\t\t\t/*update ESDs if any*/\n\t\t\t\t\t\tUpdateODCommand(load->isom, odc);\n\t\t\t\t\t\tgf_list_add(au->commands, odc);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tgf_isom_sample_del(&samp);\n\t\t\tif (e) {\n\t\t\t\tmp4_report(load, gf_isom_last_error(load->isom), \"decoding sample %d from track ID %d failed\", j+1, gf_isom_get_track_id(load->isom, i+1));\n\t\t\t\tgoto exit;\n\t\t\t}\n\n\t\t\tsamp_done++;\n\t\t\tgf_set_progress(\"MP4 Loading\", samp_done, nb_samp);\n\t\t}\n\t\tgf_odf_desc_del((GF_Descriptor *) esd);\n\t\tesd = NULL;\n\t}\n\tgf_isom_text_set_streaming_mode(load->isom, 0);\n\nexit:\n#ifndef GPAC_DISABLE_BIFS\n\tgf_bifs_decoder_del(bifs_dec);\n#endif\n\tgf_odf_codec_del(od_dec);\n#ifndef GPAC_DISABLE_LASER\n\tgf_laser_decoder_del(lsr_dec);\n#endif\n\tif (esd) gf_odf_desc_del((GF_Descriptor *) esd);\n\tif (logs) gf_fclose(logs);\n\treturn e;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -62,6 +62,7 @@\n \t\tif (!esd) continue;\n \t\tif (!esd->decoderConfig || (esd->decoderConfig->objectTypeIndication==GF_CODECID_TEXT_MPEG4)) {\n \t\t\tgf_odf_desc_del((GF_Descriptor *) esd);\n+\t\t\tesd = NULL;\n \t\t\tcontinue;\n \t\t}\n \n@@ -70,6 +71,7 @@\n \t\t   ) {\n \t\t\tnb_samp += gf_isom_get_sample_count(load->isom, i+1);\n \t\t\tgf_odf_desc_del((GF_Descriptor *) esd);\n+\t\t\tesd = NULL;\n \t\t\tcontinue;\n \t\t}\n \t\tsc = gf_sm_stream_new(load->ctx, esd->ESID, esd->decoderConfig->streamType, esd->decoderConfig->objectTypeIndication);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\t\tesd = NULL;",
                "\t\t\tesd = NULL;"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-40569",
        "func_name": "gpac/iloc_box_read",
        "description": "The binary MP4Box in Gpac through 1.0.1 has a double-free vulnerability in the iloc_entry_del funciton in box_code_meta.c, which allows attackers to cause a denial of service.",
        "git_url": "https://github.com/gpac/gpac/commit/b03c9f252526bb42fbd1b87b9f5e339c3cf2390a",
        "commit_title": "fixed #1890",
        "commit_text": "",
        "func_before": "GF_Err iloc_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 item_count, extent_count, i, j;\n\tGF_ItemLocationBox *ptr = (GF_ItemLocationBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 2)\n\tptr->offset_size = gf_bs_read_int(bs, 4);\n\tptr->length_size = gf_bs_read_int(bs, 4);\n\tptr->base_offset_size = gf_bs_read_int(bs, 4);\n\tif (ptr->version == 1 || ptr->version == 2) {\n\t\tptr->index_size = gf_bs_read_int(bs, 4);\n\t} else {\n\t\tgf_bs_read_int(bs, 4);\n\t}\n\tif (ptr->version < 2) {\n\t\tISOM_DECREASE_SIZE(ptr, 2)\n\t\titem_count = gf_bs_read_u16(bs);\n\t} else {\n\t\tISOM_DECREASE_SIZE(ptr, 4)\n\t\titem_count = gf_bs_read_u32(bs);\n\t}\n\n\tfor (i = 0; i < item_count; i++) {\n\t\tGF_ItemLocationEntry *location_entry = (GF_ItemLocationEntry *)gf_malloc(sizeof(GF_ItemLocationEntry));\n\t\tif (!location_entry) return GF_OUT_OF_MEM;\n\n\t\tgf_list_add(ptr->location_entries, location_entry);\n\t\tif (ptr->version < 2) {\n\t\t\tISOM_DECREASE_SIZE(ptr, 2)\n\t\t\tlocation_entry->item_ID = gf_bs_read_u16(bs);\n\t\t} else {\n\t\t\tISOM_DECREASE_SIZE(ptr, 4)\n\t\t\tlocation_entry->item_ID = gf_bs_read_u32(bs);\n\t\t}\n\t\tif (ptr->version == 1 || ptr->version == 2) {\n\t\t\tISOM_DECREASE_SIZE(ptr, 2)\n\t\t\tlocation_entry->construction_method = gf_bs_read_u16(bs);\n\t\t}\n\t\telse {\n\t\t\tlocation_entry->construction_method = 0;\n\t\t}\n\t\tISOM_DECREASE_SIZE(ptr, (2 + ptr->base_offset_size) )\n\t\tlocation_entry->data_reference_index = gf_bs_read_u16(bs);\n\t\tlocation_entry->base_offset = gf_bs_read_int(bs, 8*ptr->base_offset_size);\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\t\tlocation_entry->original_base_offset = location_entry->base_offset;\n#endif\n\n\t\tISOM_DECREASE_SIZE(ptr, 2)\n\t\textent_count = gf_bs_read_u16(bs);\n\t\tlocation_entry->extent_entries = gf_list_new();\n\t\tfor (j = 0; j < extent_count; j++) {\n\t\t\tGF_ItemExtentEntry *extent_entry = (GF_ItemExtentEntry *)gf_malloc(sizeof(GF_ItemExtentEntry));\n\t\t\tif (!extent_entry) return GF_OUT_OF_MEM;\n\t\t\t\n\t\t\tgf_list_add(location_entry->extent_entries, extent_entry);\n\t\t\tif ((ptr->version == 1 || ptr->version == 2) && ptr->index_size > 0) {\n\t\t\t\tISOM_DECREASE_SIZE(ptr, ptr->index_size)\n\t\t\t\textent_entry->extent_index = gf_bs_read_int(bs, 8 * ptr->index_size);\n\t\t\t}\n\t\t\telse {\n\t\t\t\textent_entry->extent_index = 0;\n\t\t\t}\n\t\t\tISOM_DECREASE_SIZE(ptr, (ptr->offset_size+ptr->length_size) )\n\n\t\t\textent_entry->extent_offset = gf_bs_read_int(bs, 8*ptr->offset_size);\n\t\t\textent_entry->extent_length = gf_bs_read_int(bs, 8*ptr->length_size);\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\t\t\textent_entry->original_extent_offset = extent_entry->extent_offset;\n#endif\n\t\t}\n\t}\n\treturn GF_OK;\n}",
        "func": "GF_Err iloc_box_read(GF_Box *s, GF_BitStream *bs)\n{\n\tu32 item_count, extent_count, i, j;\n\tGF_ItemLocationBox *ptr = (GF_ItemLocationBox *)s;\n\n\tISOM_DECREASE_SIZE(ptr, 2)\n\tptr->offset_size = gf_bs_read_int(bs, 4);\n\tptr->length_size = gf_bs_read_int(bs, 4);\n\tptr->base_offset_size = gf_bs_read_int(bs, 4);\n\tif (ptr->version == 1 || ptr->version == 2) {\n\t\tptr->index_size = gf_bs_read_int(bs, 4);\n\t} else {\n\t\tgf_bs_read_int(bs, 4);\n\t}\n\tif (ptr->version < 2) {\n\t\tISOM_DECREASE_SIZE(ptr, 2)\n\t\titem_count = gf_bs_read_u16(bs);\n\t} else {\n\t\tISOM_DECREASE_SIZE(ptr, 4)\n\t\titem_count = gf_bs_read_u32(bs);\n\t}\n\n\tfor (i = 0; i < item_count; i++) {\n\t\tGF_ItemLocationEntry *location_entry;\n\t\tGF_SAFEALLOC(location_entry, GF_ItemLocationEntry);\n\t\tif (!location_entry) return GF_OUT_OF_MEM;\n\n\t\tgf_list_add(ptr->location_entries, location_entry);\n\t\tif (ptr->version < 2) {\n\t\t\tISOM_DECREASE_SIZE(ptr, 2)\n\t\t\tlocation_entry->item_ID = gf_bs_read_u16(bs);\n\t\t} else {\n\t\t\tISOM_DECREASE_SIZE(ptr, 4)\n\t\t\tlocation_entry->item_ID = gf_bs_read_u32(bs);\n\t\t}\n\t\tif (ptr->version == 1 || ptr->version == 2) {\n\t\t\tISOM_DECREASE_SIZE(ptr, 2)\n\t\t\tlocation_entry->construction_method = gf_bs_read_u16(bs);\n\t\t}\n\t\telse {\n\t\t\tlocation_entry->construction_method = 0;\n\t\t}\n\t\tISOM_DECREASE_SIZE(ptr, (2 + ptr->base_offset_size) )\n\t\tlocation_entry->data_reference_index = gf_bs_read_u16(bs);\n\t\tlocation_entry->base_offset = gf_bs_read_int(bs, 8*ptr->base_offset_size);\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\t\tlocation_entry->original_base_offset = location_entry->base_offset;\n#endif\n\n\t\tISOM_DECREASE_SIZE(ptr, 2)\n\t\textent_count = gf_bs_read_u16(bs);\n\t\tlocation_entry->extent_entries = gf_list_new();\n\t\tfor (j = 0; j < extent_count; j++) {\n\t\t\tGF_ItemExtentEntry *extent_entry;\n\t\t\tGF_SAFEALLOC(extent_entry, GF_ItemExtentEntry);\n\t\t\tif (!extent_entry) return GF_OUT_OF_MEM;\n\t\t\t\n\t\t\tgf_list_add(location_entry->extent_entries, extent_entry);\n\t\t\tif ((ptr->version == 1 || ptr->version == 2) && ptr->index_size > 0) {\n\t\t\t\tISOM_DECREASE_SIZE(ptr, ptr->index_size)\n\t\t\t\textent_entry->extent_index = gf_bs_read_int(bs, 8 * ptr->index_size);\n\t\t\t}\n\t\t\telse {\n\t\t\t\textent_entry->extent_index = 0;\n\t\t\t}\n\t\t\tISOM_DECREASE_SIZE(ptr, (ptr->offset_size+ptr->length_size) )\n\n\t\t\textent_entry->extent_offset = gf_bs_read_int(bs, 8*ptr->offset_size);\n\t\t\textent_entry->extent_length = gf_bs_read_int(bs, 8*ptr->length_size);\n#ifndef GPAC_DISABLE_ISOM_WRITE\n\t\t\textent_entry->original_extent_offset = extent_entry->extent_offset;\n#endif\n\t\t}\n\t}\n\treturn GF_OK;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -21,7 +21,8 @@\n \t}\n \n \tfor (i = 0; i < item_count; i++) {\n-\t\tGF_ItemLocationEntry *location_entry = (GF_ItemLocationEntry *)gf_malloc(sizeof(GF_ItemLocationEntry));\n+\t\tGF_ItemLocationEntry *location_entry;\n+\t\tGF_SAFEALLOC(location_entry, GF_ItemLocationEntry);\n \t\tif (!location_entry) return GF_OUT_OF_MEM;\n \n \t\tgf_list_add(ptr->location_entries, location_entry);\n@@ -50,7 +51,8 @@\n \t\textent_count = gf_bs_read_u16(bs);\n \t\tlocation_entry->extent_entries = gf_list_new();\n \t\tfor (j = 0; j < extent_count; j++) {\n-\t\t\tGF_ItemExtentEntry *extent_entry = (GF_ItemExtentEntry *)gf_malloc(sizeof(GF_ItemExtentEntry));\n+\t\t\tGF_ItemExtentEntry *extent_entry;\n+\t\t\tGF_SAFEALLOC(extent_entry, GF_ItemExtentEntry);\n \t\t\tif (!extent_entry) return GF_OUT_OF_MEM;\n \t\t\t\n \t\t\tgf_list_add(location_entry->extent_entries, extent_entry);",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tGF_ItemLocationEntry *location_entry = (GF_ItemLocationEntry *)gf_malloc(sizeof(GF_ItemLocationEntry));",
                "\t\t\tGF_ItemExtentEntry *extent_entry = (GF_ItemExtentEntry *)gf_malloc(sizeof(GF_ItemExtentEntry));"
            ],
            "added_lines": [
                "\t\tGF_ItemLocationEntry *location_entry;",
                "\t\tGF_SAFEALLOC(location_entry, GF_ItemLocationEntry);",
                "\t\t\tGF_ItemExtentEntry *extent_entry;",
                "\t\t\tGF_SAFEALLOC(extent_entry, GF_ItemExtentEntry);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-40570",
        "func_name": "gpac/gf_avc_read_sps_bs_internal",
        "description": "The binary MP4Box in Gpac 1.0.1 has a double-free vulnerability in the avc_compute_poc function in av_parsers.c, which allows attackers to cause a denial of service, even code execution and escalation of privileges.",
        "git_url": "https://github.com/gpac/gpac/commit/04dbf08bff4d61948bab80c3f9096ecc60c7f302",
        "commit_title": "fixed #1899",
        "commit_text": "",
        "func_before": "static s32 gf_avc_read_sps_bs_internal(GF_BitStream *bs, AVCState *avc, u32 subseq_sps, u32 *vui_flag_pos, u32 nal_hdr)\n{\n\tAVC_SPS *sps;\n\ts32 mb_width, mb_height, sps_id = -1;\n\tu32 profile_idc, level_idc, pcomp, i, chroma_format_idc, cl = 0, cr = 0, ct = 0, cb = 0, luma_bd, chroma_bd;\n\tu8 separate_colour_plane_flag = 0;\n\n\tif (!vui_flag_pos) {\n\t\tgf_bs_enable_emulation_byte_removal(bs, GF_TRUE);\n\t}\n\n\tif (!bs) {\n\t\treturn -1;\n\t}\n\n\tif (!nal_hdr) {\n\t\tgf_bs_read_int_log(bs, 1, \"forbidden_zero_bit\");\n\t\tgf_bs_read_int_log(bs, 2, \"nal_ref_idc\");\n\t\tgf_bs_read_int_log(bs, 5, \"nal_unit_type\");\n\t}\n\tprofile_idc = gf_bs_read_int_log(bs, 8, \"profile_idc\");\n\n\tpcomp = gf_bs_read_int_log(bs, 8, \"profile_compatibility\");\n\t/*sanity checks*/\n\tif (pcomp & 0x3)\n\t\treturn -1;\n\n\tlevel_idc = gf_bs_read_int_log(bs, 8, \"level_idc\");\n\n\t/*SubsetSps is used to be sure that AVC SPS are not going to be scratched\n\tby subset SPS. According to the SVC standard, subset SPS can have the same sps_id\n\tthan its base layer, but it does not refer to the same SPS. */\n\tsps_id = gf_bs_read_ue_log(bs, \"sps_id\") + GF_SVC_SSPS_ID_SHIFT * subseq_sps;\n\tif ((sps_id < 0) || (sps_id >= 32)) {\n\t\treturn -1;\n\t}\n\n\tluma_bd = chroma_bd = 0;\n\tsps = &avc->sps[sps_id];\n\tchroma_format_idc = sps->ChromaArrayType = 1;\n\tsps->state |= subseq_sps ? AVC_SUBSPS_PARSED : AVC_SPS_PARSED;\n\n\t/*High Profile and SVC*/\n\tswitch (profile_idc) {\n\tcase 100:\n\tcase 110:\n\tcase 122:\n\tcase 244:\n\tcase 44:\n\t\t/*sanity checks: note1 from 7.4.2.1.1 of iso/iec 14496-10-N11084*/\n\t\tif (pcomp & 0xE0)\n\t\t\treturn -1;\n\tcase 83:\n\tcase 86:\n\tcase 118:\n\tcase 128:\n\t\tchroma_format_idc = gf_bs_read_ue_log(bs, \"chroma_format_idc\");\n\t\tsps->ChromaArrayType = chroma_format_idc;\n\t\tif (chroma_format_idc == 3) {\n\t\t\tseparate_colour_plane_flag = gf_bs_read_int_log(bs, 1, \"separate_colour_plane_flag\");\n\t\t\t/*\n\t\t\tDepending on the value of separate_colour_plane_flag, the value of the variable ChromaArrayType is assigned as follows.\n\t\t\t\\96\tIf separate_colour_plane_flag is equal to 0, ChromaArrayType is set equal to chroma_format_idc.\n\t\t\t\\96\tOtherwise (separate_colour_plane_flag is equal to 1), ChromaArrayType is set equal to 0.\n\t\t\t*/\n\t\t\tif (separate_colour_plane_flag) sps->ChromaArrayType = 0;\n\t\t}\n\t\tluma_bd = gf_bs_read_ue_log(bs, \"luma_bit_depth\");\n\t\tchroma_bd = gf_bs_read_ue_log(bs, \"chroma_bit_depth\");\n\t\t/*qpprime_y_zero_transform_bypass_flag = */ gf_bs_read_int_log(bs, 1, \"qpprime_y_zero_transform_bypass_flag\");\n\t\t/*seq_scaling_matrix_present_flag*/\n\t\tif (gf_bs_read_int_log(bs, 1, \"seq_scaling_matrix_present_flag\")) {\n\t\t\tu32 k;\n\t\t\tfor (k = 0; k < 8; k++) {\n\t\t\t\tif (gf_bs_read_int_log_idx(bs, 1, \"seq_scaling_list_present_flag\", k)) {\n\t\t\t\t\tu32 z, last = 8, next = 8;\n\t\t\t\t\tu32 sl = k < 6 ? 16 : 64;\n\t\t\t\t\tfor (z = 0; z < sl; z++) {\n\t\t\t\t\t\tif (next) {\n\t\t\t\t\t\t\ts32 delta = gf_bs_read_se(bs);\n\t\t\t\t\t\t\tnext = (last + delta + 256) % 256;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlast = next ? next : last;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\n\tsps->profile_idc = profile_idc;\n\tsps->level_idc = level_idc;\n\tsps->prof_compat = pcomp;\n\tsps->log2_max_frame_num = gf_bs_read_ue_log(bs, \"log2_max_frame_num\") + 4;\n\tsps->poc_type = gf_bs_read_ue_log(bs, \"poc_type\");\n\tsps->chroma_format = chroma_format_idc;\n\tsps->luma_bit_depth_m8 = luma_bd;\n\tsps->chroma_bit_depth_m8 = chroma_bd;\n\n\tif (sps->poc_type == 0) {\n\t\tsps->log2_max_poc_lsb = gf_bs_read_ue_log(bs, \"log2_max_poc_lsb\") + 4;\n\t}\n\telse if (sps->poc_type == 1) {\n\t\tsps->delta_pic_order_always_zero_flag = gf_bs_read_int_log(bs, 1, \"delta_pic_order_always_zero_flag\");\n\t\tsps->offset_for_non_ref_pic = gf_bs_read_se_log(bs, \"offset_for_non_ref_pic\");\n\t\tsps->offset_for_top_to_bottom_field = gf_bs_read_se_log(bs, \"offset_for_top_to_bottom_field\");\n\t\tsps->poc_cycle_length = gf_bs_read_ue_log(bs, \"poc_cycle_length\");\n\t\tif (sps->poc_cycle_length > GF_ARRAY_LENGTH(sps->offset_for_ref_frame)) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[avc-h264] offset_for_ref_frame overflow from poc_cycle_length\\n\"));\n\t\t\treturn -1;\n\t\t}\n\t\tfor (i = 0; i < sps->poc_cycle_length; i++)\n\t\t\tsps->offset_for_ref_frame[i] = gf_bs_read_se_log_idx(bs, \"offset_for_ref_frame\", i);\n\t}\n\tif (sps->poc_type > 2) {\n\t\treturn -1;\n\t}\n\tsps->max_num_ref_frames = gf_bs_read_ue_log(bs, \"max_num_ref_frames\");\n\tsps->gaps_in_frame_num_value_allowed_flag = gf_bs_read_int_log(bs, 1, \"gaps_in_frame_num_value_allowed_flag\");\n\tmb_width = gf_bs_read_ue_log(bs, \"pic_width_in_mbs_minus1\") + 1;\n\tmb_height = gf_bs_read_ue_log(bs, \"pic_height_in_map_units_minus1\") + 1;\n\n\tsps->frame_mbs_only_flag = gf_bs_read_int_log(bs, 1, \"frame_mbs_only_flag\");\n\n\tsps->width = mb_width * 16;\n\tsps->height = (2 - sps->frame_mbs_only_flag) * mb_height * 16;\n\n\tif (!sps->frame_mbs_only_flag) sps->mb_adaptive_frame_field_flag = gf_bs_read_int_log(bs, 1, \"mb_adaptive_frame_field_flag\");\n\tgf_bs_read_int_log(bs, 1, \"direct_8x8_inference_flag\");\n\n\tif (gf_bs_read_int_log(bs, 1, \"frame_cropping_flag\")) {\n\t\tint CropUnitX, CropUnitY, SubWidthC = -1, SubHeightC = -1;\n\n\t\tif (chroma_format_idc == 1) {\n\t\t\tSubWidthC = 2; SubHeightC = 2;\n\t\t}\n\t\telse if (chroma_format_idc == 2) {\n\t\t\tSubWidthC = 2; SubHeightC = 1;\n\t\t}\n\t\telse if ((chroma_format_idc == 3) && (separate_colour_plane_flag == 0)) {\n\t\t\tSubWidthC = 1; SubHeightC = 1;\n\t\t}\n\n\t\tif (sps->ChromaArrayType == 0) {\n\t\t\tassert(SubWidthC == -1);\n\t\t\tCropUnitX = 1;\n\t\t\tCropUnitY = 2 - sps->frame_mbs_only_flag;\n\t\t}\n\t\telse {\n\t\t\tCropUnitX = SubWidthC;\n\t\t\tCropUnitY = SubHeightC * (2 - sps->frame_mbs_only_flag);\n\t\t}\n\n\t\tcl = gf_bs_read_ue_log(bs, \"frame_crop_left_offset\");\n\t\tcr = gf_bs_read_ue_log(bs, \"frame_crop_right_offset\");\n\t\tct = gf_bs_read_ue_log(bs, \"frame_crop_top_offset\");\n\t\tcb = gf_bs_read_ue_log(bs, \"frame_crop_bottom_offset\");\n\n\t\tsps->width -= CropUnitX * (cl + cr);\n\t\tsps->height -= CropUnitY * (ct + cb);\n\t\tcl *= CropUnitX;\n\t\tcr *= CropUnitX;\n\t\tct *= CropUnitY;\n\t\tcb *= CropUnitY;\n\t}\n\tsps->crop.left = cl;\n\tsps->crop.right = cr;\n\tsps->crop.top = ct;\n\tsps->crop.bottom = cb;\n\n\tif (vui_flag_pos) {\n\t\t*vui_flag_pos = (u32)gf_bs_get_bit_offset(bs);\n\t}\n\t/*vui_parameters_present_flag*/\n\tsps->vui_parameters_present_flag = gf_bs_read_int_log(bs, 1, \"vui_parameters_present_flag\");\n\tif (sps->vui_parameters_present_flag) {\n\t\tsps->vui.aspect_ratio_info_present_flag = gf_bs_read_int_log(bs, 1, \"aspect_ratio_info_present_flag\");\n\t\tif (sps->vui.aspect_ratio_info_present_flag) {\n\t\t\ts32 aspect_ratio_idc = gf_bs_read_int_log(bs, 8, \"aspect_ratio_idc\");\n\t\t\tif (aspect_ratio_idc == 255) {\n\t\t\t\tsps->vui.par_num = gf_bs_read_int_log(bs, 16, \"aspect_ratio_num\");\n\t\t\t\tsps->vui.par_den = gf_bs_read_int_log(bs, 16, \"aspect_ratio_den\");\n\t\t\t}\n\t\t\telse if (aspect_ratio_idc < GF_ARRAY_LENGTH(avc_hevc_sar) ) {\n\t\t\t\tsps->vui.par_num = avc_hevc_sar[aspect_ratio_idc].w;\n\t\t\t\tsps->vui.par_den = avc_hevc_sar[aspect_ratio_idc].h;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"[avc-h264] Unknown aspect_ratio_idc: your video may have a wrong aspect ratio. Contact the GPAC team!\\n\"));\n\t\t\t}\n\t\t}\n\t\tsps->vui.overscan_info_present_flag = gf_bs_read_int_log(bs, 1, \"overscan_info_present_flag\");\n\t\tif (sps->vui.overscan_info_present_flag)\n\t\t\tgf_bs_read_int_log(bs, 1, \"overscan_appropriate_flag\");\n\n\t\t/* default values */\n\t\tsps->vui.video_format = 5;\n\t\tsps->vui.colour_primaries = 2;\n\t\tsps->vui.transfer_characteristics = 2;\n\t\tsps->vui.matrix_coefficients = 2;\n\t\t/* now read values if possible */\n\t\tsps->vui.video_signal_type_present_flag = gf_bs_read_int_log(bs, 1, \"video_signal_type_present_flag\");\n\t\tif (sps->vui.video_signal_type_present_flag) {\n\t\t\tsps->vui.video_format = gf_bs_read_int_log(bs, 3, \"video_format\");\n\t\t\tsps->vui.video_full_range_flag = gf_bs_read_int_log(bs, 1, \"video_full_range_flag\");\n\t\t\tsps->vui.colour_description_present_flag = gf_bs_read_int_log(bs, 1, \"colour_description_present_flag\");\n\t\t\tif (sps->vui.colour_description_present_flag) {\n\t\t\t\tsps->vui.colour_primaries = gf_bs_read_int_log(bs, 8, \"colour_primaries\");\n\t\t\t\tsps->vui.transfer_characteristics = gf_bs_read_int_log(bs, 8, \"transfer_characteristics\");\n\t\t\t\tsps->vui.matrix_coefficients = gf_bs_read_int_log(bs, 8, \"matrix_coefficients\");\n\t\t\t}\n\t\t}\n\n\t\tif (gf_bs_read_int_log(bs, 1, \"chroma_location_info_present_flag\")) {\n\t\t\tgf_bs_read_ue_log(bs, \"chroma_sample_location_type_top_field\");\n\t\t\tgf_bs_read_ue_log(bs, \"chroma_sample_location_type_bottom_field\");\n\t\t}\n\n\t\tsps->vui.timing_info_present_flag = gf_bs_read_int_log(bs, 1, \"timing_info_present_flag\");\n\t\tif (sps->vui.timing_info_present_flag) {\n\t\t\tsps->vui.num_units_in_tick = gf_bs_read_int_log(bs, 32, \"num_units_in_tick\");\n\t\t\tsps->vui.time_scale = gf_bs_read_int_log(bs, 32, \"time_scale\");\n\t\t\tsps->vui.fixed_frame_rate_flag = gf_bs_read_int_log(bs, 1, \"fixed_frame_rate_flag\");\n\t\t}\n\n\t\tsps->vui.nal_hrd_parameters_present_flag = gf_bs_read_int_log(bs, 1, \"nal_hrd_parameters_present_flag\");\n\t\tif (sps->vui.nal_hrd_parameters_present_flag)\n\t\t\tavc_parse_hrd_parameters(bs, &sps->vui.hrd);\n\n\t\tsps->vui.vcl_hrd_parameters_present_flag = gf_bs_read_int_log(bs, 1, \"vcl_hrd_parameters_present_flag\");\n\t\tif (sps->vui.vcl_hrd_parameters_present_flag)\n\t\t\tavc_parse_hrd_parameters(bs, &sps->vui.hrd);\n\n\t\tif (sps->vui.nal_hrd_parameters_present_flag || sps->vui.vcl_hrd_parameters_present_flag)\n\t\t\tsps->vui.low_delay_hrd_flag = gf_bs_read_int_log(bs, 1, \"low_delay_hrd_flag\");\n\n\t\tsps->vui.pic_struct_present_flag = gf_bs_read_int_log(bs, 1, \"pic_struct_present_flag\");\n\t}\n\t/*end of seq_parameter_set_data*/\n\n\tif (subseq_sps) {\n\t\tif ((profile_idc == 83) || (profile_idc == 86)) {\n\t\t\tu8 extended_spatial_scalability_idc;\n\t\t\t/*parsing seq_parameter_set_svc_extension*/\n\n\t\t\tgf_bs_read_int_log(bs, 1, \"inter_layer_deblocking_filter_control_present_flag\");\n\t\t\textended_spatial_scalability_idc = gf_bs_read_int_log(bs, 2, \"extended_spatial_scalability_idc\");\n\t\t\tif (sps->ChromaArrayType == 1 || sps->ChromaArrayType == 2) {\n\t\t\t\tgf_bs_read_int_log(bs, 1, \"chroma_phase_x_plus1_flag\");\n\t\t\t}\n\t\t\tif (sps->ChromaArrayType == 1) {\n\t\t\t\tgf_bs_read_int_log(bs, 2, \"chroma_phase_y_plus1\");\n\t\t\t}\n\t\t\tif (extended_spatial_scalability_idc == 1) {\n\t\t\t\tif (sps->ChromaArrayType > 0) {\n\t\t\t\t\tgf_bs_read_int_log(bs, 1, \"seq_ref_layer_chroma_phase_x_plus1_flag\");\n\t\t\t\t\tgf_bs_read_int_log(bs, 2, \"seq_ref_layer_chroma_phase_y_plus1\");\n\t\t\t\t}\n\t\t\t\tgf_bs_read_se_log(bs, \"seq_scaled_ref_layer_left_offset\");\n\t\t\t\tgf_bs_read_se_log(bs, \"seq_scaled_ref_layer_top_offset\");\n\t\t\t\tgf_bs_read_se_log(bs, \"seq_scaled_ref_layer_right_offset\");\n\t\t\t\tgf_bs_read_se_log(bs, \"seq_scaled_ref_layer_bottom_offset\");\n\t\t\t}\n\t\t\tif (gf_bs_read_int_log(bs, 1, \"seq_tcoeff_level_prediction_flag\")) {\n\t\t\t\tgf_bs_read_int_log(bs, 1, \"adaptive_tcoeff_level_prediction_flag\");\n\t\t\t}\n\t\t\tgf_bs_read_int_log(bs, 1, \"slice_header_restriction_flag\");\n\n\t\t\tif (gf_bs_read_int_log(bs, 1, \"svc_vui_parameters_present\")) {\n\t\t\t\tu32 vui_ext_num_entries_minus1 = gf_bs_read_ue_log(bs, \"vui_ext_num_entries_minus1\");\n\n\t\t\t\tfor (i = 0; i <= vui_ext_num_entries_minus1; i++) {\n\t\t\t\t\tu8 vui_ext_nal_hrd_parameters_present_flag, vui_ext_vcl_hrd_parameters_present_flag, vui_ext_timing_info_present_flag;\n\t\t\t\t\tgf_bs_read_int_log(bs, 3, \"vui_ext_dependency_id\");\n\t\t\t\t\tgf_bs_read_int_log(bs, 4, \"vui_ext_quality_id\");\n\t\t\t\t\tgf_bs_read_int_log(bs, 3, \"vui_ext_temporal_id\");\n\t\t\t\t\tvui_ext_timing_info_present_flag = gf_bs_read_int_log(bs, 1, \"vui_ext_timing_info_present_flag\");\n\t\t\t\t\tif (vui_ext_timing_info_present_flag) {\n\t\t\t\t\t\tgf_bs_read_int_log(bs, 32, \"vui_ext_num_units_in_tick\");\n\t\t\t\t\t\tgf_bs_read_int_log(bs, 32, \"vui_ext_time_scale\");\n\t\t\t\t\t\tgf_bs_read_int_log(bs, 1, \"vui_ext_fixed_frame_rate_flag\");\n\t\t\t\t\t}\n\t\t\t\t\tvui_ext_nal_hrd_parameters_present_flag = gf_bs_read_int_log(bs, 1, \"vui_ext_nal_hrd_parameters_present_flag\");\n\t\t\t\t\tif (vui_ext_nal_hrd_parameters_present_flag) {\n\t\t\t\t\t\t//hrd_parameters( )\n\t\t\t\t\t}\n\t\t\t\t\tvui_ext_vcl_hrd_parameters_present_flag = gf_bs_read_int_log(bs, 1, \"vui_ext_vcl_hrd_parameters_present_flag\");\n\t\t\t\t\tif (vui_ext_vcl_hrd_parameters_present_flag) {\n\t\t\t\t\t\t//hrd_parameters( )\n\t\t\t\t\t}\n\t\t\t\t\tif (vui_ext_nal_hrd_parameters_present_flag || vui_ext_vcl_hrd_parameters_present_flag) {\n\t\t\t\t\t\tgf_bs_read_int_log(bs, 1, \"vui_ext_low_delay_hrd_flag\");\n\t\t\t\t\t}\n\t\t\t\t\tgf_bs_read_int_log(bs, 1, \"vui_ext_pic_struct_present_flag\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if ((profile_idc == 118) || (profile_idc == 128)) {\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CODING, (\"[avc-h264] MVC parsing not implemented - skipping parsing end of Subset SPS\\n\"));\n\t\t\treturn sps_id;\n\t\t}\n\n\t\tif (gf_bs_read_int_log(bs, 1, \"additional_extension2\")) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"[avc-h264] skipping parsing end of Subset SPS (additional_extension2)\\n\"));\n\t\t\treturn sps_id;\n\t\t}\n\t}\n\treturn sps_id;\n}",
        "func": "static s32 gf_avc_read_sps_bs_internal(GF_BitStream *bs, AVCState *avc, u32 subseq_sps, u32 *vui_flag_pos, u32 nal_hdr)\n{\n\tAVC_SPS *sps;\n\ts32 mb_width, mb_height, sps_id = -1;\n\tu32 profile_idc, level_idc, pcomp, i, chroma_format_idc, cl = 0, cr = 0, ct = 0, cb = 0, luma_bd, chroma_bd;\n\tu8 separate_colour_plane_flag = 0;\n\n\tif (!vui_flag_pos) {\n\t\tgf_bs_enable_emulation_byte_removal(bs, GF_TRUE);\n\t}\n\n\tif (!bs) {\n\t\treturn -1;\n\t}\n\n\tif (!nal_hdr) {\n\t\tgf_bs_read_int_log(bs, 1, \"forbidden_zero_bit\");\n\t\tgf_bs_read_int_log(bs, 2, \"nal_ref_idc\");\n\t\tgf_bs_read_int_log(bs, 5, \"nal_unit_type\");\n\t}\n\tprofile_idc = gf_bs_read_int_log(bs, 8, \"profile_idc\");\n\n\tpcomp = gf_bs_read_int_log(bs, 8, \"profile_compatibility\");\n\t/*sanity checks*/\n\tif (pcomp & 0x3)\n\t\treturn -1;\n\n\tlevel_idc = gf_bs_read_int_log(bs, 8, \"level_idc\");\n\n\t/*SubsetSps is used to be sure that AVC SPS are not going to be scratched\n\tby subset SPS. According to the SVC standard, subset SPS can have the same sps_id\n\tthan its base layer, but it does not refer to the same SPS. */\n\tsps_id = gf_bs_read_ue_log(bs, \"sps_id\") + GF_SVC_SSPS_ID_SHIFT * subseq_sps;\n\tif ((sps_id < 0) || (sps_id >= 32)) {\n\t\treturn -1;\n\t}\n\n\tluma_bd = chroma_bd = 0;\n\tsps = &avc->sps[sps_id];\n\tchroma_format_idc = sps->ChromaArrayType = 1;\n\tsps->state |= subseq_sps ? AVC_SUBSPS_PARSED : AVC_SPS_PARSED;\n\n\t/*High Profile and SVC*/\n\tswitch (profile_idc) {\n\tcase 100:\n\tcase 110:\n\tcase 122:\n\tcase 244:\n\tcase 44:\n\t\t/*sanity checks: note1 from 7.4.2.1.1 of iso/iec 14496-10-N11084*/\n\t\tif (pcomp & 0xE0)\n\t\t\treturn -1;\n\tcase 83:\n\tcase 86:\n\tcase 118:\n\tcase 128:\n\t\tchroma_format_idc = gf_bs_read_ue_log(bs, \"chroma_format_idc\");\n\t\tsps->ChromaArrayType = chroma_format_idc;\n\t\tif (chroma_format_idc == 3) {\n\t\t\tseparate_colour_plane_flag = gf_bs_read_int_log(bs, 1, \"separate_colour_plane_flag\");\n\t\t\t/*\n\t\t\tDepending on the value of separate_colour_plane_flag, the value of the variable ChromaArrayType is assigned as follows.\n\t\t\t\\96\tIf separate_colour_plane_flag is equal to 0, ChromaArrayType is set equal to chroma_format_idc.\n\t\t\t\\96\tOtherwise (separate_colour_plane_flag is equal to 1), ChromaArrayType is set equal to 0.\n\t\t\t*/\n\t\t\tif (separate_colour_plane_flag) sps->ChromaArrayType = 0;\n\t\t}\n\t\tluma_bd = gf_bs_read_ue_log(bs, \"luma_bit_depth\");\n\t\tchroma_bd = gf_bs_read_ue_log(bs, \"chroma_bit_depth\");\n\t\t/*qpprime_y_zero_transform_bypass_flag = */ gf_bs_read_int_log(bs, 1, \"qpprime_y_zero_transform_bypass_flag\");\n\t\t/*seq_scaling_matrix_present_flag*/\n\t\tif (gf_bs_read_int_log(bs, 1, \"seq_scaling_matrix_present_flag\")) {\n\t\t\tu32 k;\n\t\t\tfor (k = 0; k < 8; k++) {\n\t\t\t\tif (gf_bs_read_int_log_idx(bs, 1, \"seq_scaling_list_present_flag\", k)) {\n\t\t\t\t\tu32 z, last = 8, next = 8;\n\t\t\t\t\tu32 sl = k < 6 ? 16 : 64;\n\t\t\t\t\tfor (z = 0; z < sl; z++) {\n\t\t\t\t\t\tif (next) {\n\t\t\t\t\t\t\ts32 delta = gf_bs_read_se(bs);\n\t\t\t\t\t\t\tnext = (last + delta + 256) % 256;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlast = next ? next : last;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\n\tsps->profile_idc = profile_idc;\n\tsps->level_idc = level_idc;\n\tsps->prof_compat = pcomp;\n\tsps->log2_max_frame_num = gf_bs_read_ue_log(bs, \"log2_max_frame_num\") + 4;\n\tsps->poc_type = gf_bs_read_ue_log(bs, \"poc_type\");\n\tsps->chroma_format = chroma_format_idc;\n\tsps->luma_bit_depth_m8 = luma_bd;\n\tsps->chroma_bit_depth_m8 = chroma_bd;\n\n\tif (sps->poc_type == 0) {\n\t\tsps->log2_max_poc_lsb = gf_bs_read_ue_log(bs, \"log2_max_poc_lsb\") + 4;\n\t}\n\telse if (sps->poc_type == 1) {\n\t\tsps->delta_pic_order_always_zero_flag = gf_bs_read_int_log(bs, 1, \"delta_pic_order_always_zero_flag\");\n\t\tsps->offset_for_non_ref_pic = gf_bs_read_se_log(bs, \"offset_for_non_ref_pic\");\n\t\tsps->offset_for_top_to_bottom_field = gf_bs_read_se_log(bs, \"offset_for_top_to_bottom_field\");\n\t\tsps->poc_cycle_length = gf_bs_read_ue_log(bs, \"poc_cycle_length\");\n\t\tif (sps->poc_cycle_length > GF_ARRAY_LENGTH(sps->offset_for_ref_frame)) {\n\t\t\tsps->poc_cycle_length = 255;\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[avc-h264] offset_for_ref_frame overflow from poc_cycle_length\\n\"));\n\t\t\treturn -1;\n\t\t}\n\t\tfor (i = 0; i < sps->poc_cycle_length; i++)\n\t\t\tsps->offset_for_ref_frame[i] = gf_bs_read_se_log_idx(bs, \"offset_for_ref_frame\", i);\n\t}\n\tif (sps->poc_type > 2) {\n\t\treturn -1;\n\t}\n\tsps->max_num_ref_frames = gf_bs_read_ue_log(bs, \"max_num_ref_frames\");\n\tsps->gaps_in_frame_num_value_allowed_flag = gf_bs_read_int_log(bs, 1, \"gaps_in_frame_num_value_allowed_flag\");\n\tmb_width = gf_bs_read_ue_log(bs, \"pic_width_in_mbs_minus1\") + 1;\n\tmb_height = gf_bs_read_ue_log(bs, \"pic_height_in_map_units_minus1\") + 1;\n\n\tsps->frame_mbs_only_flag = gf_bs_read_int_log(bs, 1, \"frame_mbs_only_flag\");\n\n\tsps->width = mb_width * 16;\n\tsps->height = (2 - sps->frame_mbs_only_flag) * mb_height * 16;\n\n\tif (!sps->frame_mbs_only_flag) sps->mb_adaptive_frame_field_flag = gf_bs_read_int_log(bs, 1, \"mb_adaptive_frame_field_flag\");\n\tgf_bs_read_int_log(bs, 1, \"direct_8x8_inference_flag\");\n\n\tif (gf_bs_read_int_log(bs, 1, \"frame_cropping_flag\")) {\n\t\tint CropUnitX, CropUnitY, SubWidthC = -1, SubHeightC = -1;\n\n\t\tif (chroma_format_idc == 1) {\n\t\t\tSubWidthC = 2; SubHeightC = 2;\n\t\t}\n\t\telse if (chroma_format_idc == 2) {\n\t\t\tSubWidthC = 2; SubHeightC = 1;\n\t\t}\n\t\telse if ((chroma_format_idc == 3) && (separate_colour_plane_flag == 0)) {\n\t\t\tSubWidthC = 1; SubHeightC = 1;\n\t\t}\n\n\t\tif (sps->ChromaArrayType == 0) {\n\t\t\tassert(SubWidthC == -1);\n\t\t\tCropUnitX = 1;\n\t\t\tCropUnitY = 2 - sps->frame_mbs_only_flag;\n\t\t}\n\t\telse {\n\t\t\tCropUnitX = SubWidthC;\n\t\t\tCropUnitY = SubHeightC * (2 - sps->frame_mbs_only_flag);\n\t\t}\n\n\t\tcl = gf_bs_read_ue_log(bs, \"frame_crop_left_offset\");\n\t\tcr = gf_bs_read_ue_log(bs, \"frame_crop_right_offset\");\n\t\tct = gf_bs_read_ue_log(bs, \"frame_crop_top_offset\");\n\t\tcb = gf_bs_read_ue_log(bs, \"frame_crop_bottom_offset\");\n\n\t\tsps->width -= CropUnitX * (cl + cr);\n\t\tsps->height -= CropUnitY * (ct + cb);\n\t\tcl *= CropUnitX;\n\t\tcr *= CropUnitX;\n\t\tct *= CropUnitY;\n\t\tcb *= CropUnitY;\n\t}\n\tsps->crop.left = cl;\n\tsps->crop.right = cr;\n\tsps->crop.top = ct;\n\tsps->crop.bottom = cb;\n\n\tif (vui_flag_pos) {\n\t\t*vui_flag_pos = (u32)gf_bs_get_bit_offset(bs);\n\t}\n\t/*vui_parameters_present_flag*/\n\tsps->vui_parameters_present_flag = gf_bs_read_int_log(bs, 1, \"vui_parameters_present_flag\");\n\tif (sps->vui_parameters_present_flag) {\n\t\tsps->vui.aspect_ratio_info_present_flag = gf_bs_read_int_log(bs, 1, \"aspect_ratio_info_present_flag\");\n\t\tif (sps->vui.aspect_ratio_info_present_flag) {\n\t\t\ts32 aspect_ratio_idc = gf_bs_read_int_log(bs, 8, \"aspect_ratio_idc\");\n\t\t\tif (aspect_ratio_idc == 255) {\n\t\t\t\tsps->vui.par_num = gf_bs_read_int_log(bs, 16, \"aspect_ratio_num\");\n\t\t\t\tsps->vui.par_den = gf_bs_read_int_log(bs, 16, \"aspect_ratio_den\");\n\t\t\t}\n\t\t\telse if (aspect_ratio_idc < GF_ARRAY_LENGTH(avc_hevc_sar) ) {\n\t\t\t\tsps->vui.par_num = avc_hevc_sar[aspect_ratio_idc].w;\n\t\t\t\tsps->vui.par_den = avc_hevc_sar[aspect_ratio_idc].h;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"[avc-h264] Unknown aspect_ratio_idc: your video may have a wrong aspect ratio. Contact the GPAC team!\\n\"));\n\t\t\t}\n\t\t}\n\t\tsps->vui.overscan_info_present_flag = gf_bs_read_int_log(bs, 1, \"overscan_info_present_flag\");\n\t\tif (sps->vui.overscan_info_present_flag)\n\t\t\tgf_bs_read_int_log(bs, 1, \"overscan_appropriate_flag\");\n\n\t\t/* default values */\n\t\tsps->vui.video_format = 5;\n\t\tsps->vui.colour_primaries = 2;\n\t\tsps->vui.transfer_characteristics = 2;\n\t\tsps->vui.matrix_coefficients = 2;\n\t\t/* now read values if possible */\n\t\tsps->vui.video_signal_type_present_flag = gf_bs_read_int_log(bs, 1, \"video_signal_type_present_flag\");\n\t\tif (sps->vui.video_signal_type_present_flag) {\n\t\t\tsps->vui.video_format = gf_bs_read_int_log(bs, 3, \"video_format\");\n\t\t\tsps->vui.video_full_range_flag = gf_bs_read_int_log(bs, 1, \"video_full_range_flag\");\n\t\t\tsps->vui.colour_description_present_flag = gf_bs_read_int_log(bs, 1, \"colour_description_present_flag\");\n\t\t\tif (sps->vui.colour_description_present_flag) {\n\t\t\t\tsps->vui.colour_primaries = gf_bs_read_int_log(bs, 8, \"colour_primaries\");\n\t\t\t\tsps->vui.transfer_characteristics = gf_bs_read_int_log(bs, 8, \"transfer_characteristics\");\n\t\t\t\tsps->vui.matrix_coefficients = gf_bs_read_int_log(bs, 8, \"matrix_coefficients\");\n\t\t\t}\n\t\t}\n\n\t\tif (gf_bs_read_int_log(bs, 1, \"chroma_location_info_present_flag\")) {\n\t\t\tgf_bs_read_ue_log(bs, \"chroma_sample_location_type_top_field\");\n\t\t\tgf_bs_read_ue_log(bs, \"chroma_sample_location_type_bottom_field\");\n\t\t}\n\n\t\tsps->vui.timing_info_present_flag = gf_bs_read_int_log(bs, 1, \"timing_info_present_flag\");\n\t\tif (sps->vui.timing_info_present_flag) {\n\t\t\tsps->vui.num_units_in_tick = gf_bs_read_int_log(bs, 32, \"num_units_in_tick\");\n\t\t\tsps->vui.time_scale = gf_bs_read_int_log(bs, 32, \"time_scale\");\n\t\t\tsps->vui.fixed_frame_rate_flag = gf_bs_read_int_log(bs, 1, \"fixed_frame_rate_flag\");\n\t\t}\n\n\t\tsps->vui.nal_hrd_parameters_present_flag = gf_bs_read_int_log(bs, 1, \"nal_hrd_parameters_present_flag\");\n\t\tif (sps->vui.nal_hrd_parameters_present_flag)\n\t\t\tavc_parse_hrd_parameters(bs, &sps->vui.hrd);\n\n\t\tsps->vui.vcl_hrd_parameters_present_flag = gf_bs_read_int_log(bs, 1, \"vcl_hrd_parameters_present_flag\");\n\t\tif (sps->vui.vcl_hrd_parameters_present_flag)\n\t\t\tavc_parse_hrd_parameters(bs, &sps->vui.hrd);\n\n\t\tif (sps->vui.nal_hrd_parameters_present_flag || sps->vui.vcl_hrd_parameters_present_flag)\n\t\t\tsps->vui.low_delay_hrd_flag = gf_bs_read_int_log(bs, 1, \"low_delay_hrd_flag\");\n\n\t\tsps->vui.pic_struct_present_flag = gf_bs_read_int_log(bs, 1, \"pic_struct_present_flag\");\n\t}\n\t/*end of seq_parameter_set_data*/\n\n\tif (subseq_sps) {\n\t\tif ((profile_idc == 83) || (profile_idc == 86)) {\n\t\t\tu8 extended_spatial_scalability_idc;\n\t\t\t/*parsing seq_parameter_set_svc_extension*/\n\n\t\t\tgf_bs_read_int_log(bs, 1, \"inter_layer_deblocking_filter_control_present_flag\");\n\t\t\textended_spatial_scalability_idc = gf_bs_read_int_log(bs, 2, \"extended_spatial_scalability_idc\");\n\t\t\tif (sps->ChromaArrayType == 1 || sps->ChromaArrayType == 2) {\n\t\t\t\tgf_bs_read_int_log(bs, 1, \"chroma_phase_x_plus1_flag\");\n\t\t\t}\n\t\t\tif (sps->ChromaArrayType == 1) {\n\t\t\t\tgf_bs_read_int_log(bs, 2, \"chroma_phase_y_plus1\");\n\t\t\t}\n\t\t\tif (extended_spatial_scalability_idc == 1) {\n\t\t\t\tif (sps->ChromaArrayType > 0) {\n\t\t\t\t\tgf_bs_read_int_log(bs, 1, \"seq_ref_layer_chroma_phase_x_plus1_flag\");\n\t\t\t\t\tgf_bs_read_int_log(bs, 2, \"seq_ref_layer_chroma_phase_y_plus1\");\n\t\t\t\t}\n\t\t\t\tgf_bs_read_se_log(bs, \"seq_scaled_ref_layer_left_offset\");\n\t\t\t\tgf_bs_read_se_log(bs, \"seq_scaled_ref_layer_top_offset\");\n\t\t\t\tgf_bs_read_se_log(bs, \"seq_scaled_ref_layer_right_offset\");\n\t\t\t\tgf_bs_read_se_log(bs, \"seq_scaled_ref_layer_bottom_offset\");\n\t\t\t}\n\t\t\tif (gf_bs_read_int_log(bs, 1, \"seq_tcoeff_level_prediction_flag\")) {\n\t\t\t\tgf_bs_read_int_log(bs, 1, \"adaptive_tcoeff_level_prediction_flag\");\n\t\t\t}\n\t\t\tgf_bs_read_int_log(bs, 1, \"slice_header_restriction_flag\");\n\n\t\t\tif (gf_bs_read_int_log(bs, 1, \"svc_vui_parameters_present\")) {\n\t\t\t\tu32 vui_ext_num_entries_minus1 = gf_bs_read_ue_log(bs, \"vui_ext_num_entries_minus1\");\n\n\t\t\t\tfor (i = 0; i <= vui_ext_num_entries_minus1; i++) {\n\t\t\t\t\tu8 vui_ext_nal_hrd_parameters_present_flag, vui_ext_vcl_hrd_parameters_present_flag, vui_ext_timing_info_present_flag;\n\t\t\t\t\tgf_bs_read_int_log(bs, 3, \"vui_ext_dependency_id\");\n\t\t\t\t\tgf_bs_read_int_log(bs, 4, \"vui_ext_quality_id\");\n\t\t\t\t\tgf_bs_read_int_log(bs, 3, \"vui_ext_temporal_id\");\n\t\t\t\t\tvui_ext_timing_info_present_flag = gf_bs_read_int_log(bs, 1, \"vui_ext_timing_info_present_flag\");\n\t\t\t\t\tif (vui_ext_timing_info_present_flag) {\n\t\t\t\t\t\tgf_bs_read_int_log(bs, 32, \"vui_ext_num_units_in_tick\");\n\t\t\t\t\t\tgf_bs_read_int_log(bs, 32, \"vui_ext_time_scale\");\n\t\t\t\t\t\tgf_bs_read_int_log(bs, 1, \"vui_ext_fixed_frame_rate_flag\");\n\t\t\t\t\t}\n\t\t\t\t\tvui_ext_nal_hrd_parameters_present_flag = gf_bs_read_int_log(bs, 1, \"vui_ext_nal_hrd_parameters_present_flag\");\n\t\t\t\t\tif (vui_ext_nal_hrd_parameters_present_flag) {\n\t\t\t\t\t\t//hrd_parameters( )\n\t\t\t\t\t}\n\t\t\t\t\tvui_ext_vcl_hrd_parameters_present_flag = gf_bs_read_int_log(bs, 1, \"vui_ext_vcl_hrd_parameters_present_flag\");\n\t\t\t\t\tif (vui_ext_vcl_hrd_parameters_present_flag) {\n\t\t\t\t\t\t//hrd_parameters( )\n\t\t\t\t\t}\n\t\t\t\t\tif (vui_ext_nal_hrd_parameters_present_flag || vui_ext_vcl_hrd_parameters_present_flag) {\n\t\t\t\t\t\tgf_bs_read_int_log(bs, 1, \"vui_ext_low_delay_hrd_flag\");\n\t\t\t\t\t}\n\t\t\t\t\tgf_bs_read_int_log(bs, 1, \"vui_ext_pic_struct_present_flag\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if ((profile_idc == 118) || (profile_idc == 128)) {\n\t\t\tGF_LOG(GF_LOG_INFO, GF_LOG_CODING, (\"[avc-h264] MVC parsing not implemented - skipping parsing end of Subset SPS\\n\"));\n\t\t\treturn sps_id;\n\t\t}\n\n\t\tif (gf_bs_read_int_log(bs, 1, \"additional_extension2\")) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CODING, (\"[avc-h264] skipping parsing end of Subset SPS (additional_extension2)\\n\"));\n\t\t\treturn sps_id;\n\t\t}\n\t}\n\treturn sps_id;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -106,6 +106,7 @@\n \t\tsps->offset_for_top_to_bottom_field = gf_bs_read_se_log(bs, \"offset_for_top_to_bottom_field\");\n \t\tsps->poc_cycle_length = gf_bs_read_ue_log(bs, \"poc_cycle_length\");\n \t\tif (sps->poc_cycle_length > GF_ARRAY_LENGTH(sps->offset_for_ref_frame)) {\n+\t\t\tsps->poc_cycle_length = 255;\n \t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CODING, (\"[avc-h264] offset_for_ref_frame overflow from poc_cycle_length\\n\"));\n \t\t\treturn -1;\n \t\t}",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\t\tsps->poc_cycle_length = 255;"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-40571",
        "func_name": "gpac/gf_odf_av1_cfg_read_bs_size",
        "description": "The binary MP4Box in Gpac 1.0.1 has a double-free vulnerability in the ilst_box_read function in box_code_apple.c, which allows attackers to cause a denial of service, even code execution and escalation of privileges.",
        "git_url": "https://github.com/gpac/gpac/commit/a69b567b8c95c72f9560c873c5ab348be058f340",
        "commit_title": "fixed #1895",
        "commit_text": "",
        "func_before": "GF_EXPORT\nGF_AV1Config *gf_odf_av1_cfg_read_bs_size(GF_BitStream *bs, u32 size)\n{\n#ifndef GPAC_DISABLE_AV_PARSERS\n\tAV1State state;\n\tu8 reserved;\n\tGF_AV1Config *cfg;\n\n\tif (!size) size = (u32) gf_bs_available(bs);\n\tif (!size) return NULL;\n\n\tcfg = gf_odf_av1_cfg_new();\n\tgf_av1_init_state(&state);\n\tstate.config = cfg;\n\n\tcfg->marker = gf_bs_read_int(bs, 1);\n\tcfg->version = gf_bs_read_int(bs, 7);\n\tcfg->seq_profile = gf_bs_read_int(bs, 3);\n\tcfg->seq_level_idx_0 = gf_bs_read_int(bs, 5);\n\tcfg->seq_tier_0 = gf_bs_read_int(bs, 1);\n\tcfg->high_bitdepth = gf_bs_read_int(bs, 1);\n\tcfg->twelve_bit = gf_bs_read_int(bs, 1);\n\tcfg->monochrome = gf_bs_read_int(bs, 1);\n\tcfg->chroma_subsampling_x = gf_bs_read_int(bs, 1);\n\tcfg->chroma_subsampling_y = gf_bs_read_int(bs, 1);\n\tcfg->chroma_sample_position = gf_bs_read_int(bs, 2);\n\n\treserved = gf_bs_read_int(bs, 3);\n\tif (reserved != 0 || cfg->marker != 1 || cfg->version != 1) {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[AV1] wrong avcC reserved %d / marker %d / version %d expecting 0 1 1\\n\", reserved, cfg->marker, cfg->version));\n\t\tgf_odf_av1_cfg_del(cfg);\n\t\treturn NULL;\n\t}\n\tcfg->initial_presentation_delay_present = gf_bs_read_int(bs, 1);\n\tif (cfg->initial_presentation_delay_present) {\n\t\tcfg->initial_presentation_delay_minus_one = gf_bs_read_int(bs, 4);\n\t} else {\n\t\t/*reserved = */gf_bs_read_int(bs, 4);\n\t\tcfg->initial_presentation_delay_minus_one = 0;\n\t}\n\tsize -= 4;\n\n\twhile (size) {\n\t\tu64 pos, obu_size;\n\t\tObuType obu_type;\n\t\tGF_AV1_OBUArrayEntry *a;\n\n\t\tpos = gf_bs_get_position(bs);\n\t\tobu_size = 0;\n\t\tif (gf_av1_parse_obu(bs, &obu_type, &obu_size, NULL, &state) != GF_OK) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[AV1] could not parse AV1 OBU at position \"LLU\". Leaving parsing.\\n\", pos));\n\t\t\tbreak;\n\t\t}\n\t\tassert(obu_size == gf_bs_get_position(bs) - pos);\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[AV1] parsed AV1 OBU type=%u size=\"LLU\" at position \"LLU\".\\n\", obu_type, obu_size, pos));\n\n\t\tif (!av1_is_obu_header(obu_type)) {\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[AV1] AV1 unexpected OBU type=%u size=\"LLU\" found at position \"LLU\". Forwarding.\\n\", pos));\n\t\t}\n\t\tGF_SAFEALLOC(a, GF_AV1_OBUArrayEntry);\n\t\tif (!a) break;\n\t\ta->obu = gf_malloc((size_t)obu_size);\n\t\tif (!a->obu) {\n\t\t\tgf_free(a);\n\t\t\tbreak;\n\t\t}\n\t\tgf_bs_seek(bs, pos);\n\t\tgf_bs_read_data(bs, (char *) a->obu, (u32)obu_size);\n\t\ta->obu_length = obu_size;\n\t\ta->obu_type = obu_type;\n\t\tgf_list_add(cfg->obu_array, a);\n\n\t\tif (size<obu_size) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[AV1] AV1 config misses %d bytes to fit the entire OBU\\n\", obu_size - size));\n\t\t\tbreak;\n\t\t}\n\t\tsize -= (u32) obu_size;\n\t}\n\tgf_av1_reset_state(& state, GF_TRUE);\n\treturn cfg;\n#else\n\treturn NULL;\n#endif\n}",
        "func": "GF_EXPORT\nGF_AV1Config *gf_odf_av1_cfg_read_bs_size(GF_BitStream *bs, u32 size)\n{\n#ifndef GPAC_DISABLE_AV_PARSERS\n\tAV1State state;\n\tu8 reserved;\n\tGF_AV1Config *cfg;\n\n\tif (!size) size = (u32) gf_bs_available(bs);\n\tif (!size) return NULL;\n\n\tcfg = gf_odf_av1_cfg_new();\n\tgf_av1_init_state(&state);\n\tstate.config = cfg;\n\n\tcfg->marker = gf_bs_read_int(bs, 1);\n\tcfg->version = gf_bs_read_int(bs, 7);\n\tcfg->seq_profile = gf_bs_read_int(bs, 3);\n\tcfg->seq_level_idx_0 = gf_bs_read_int(bs, 5);\n\tcfg->seq_tier_0 = gf_bs_read_int(bs, 1);\n\tcfg->high_bitdepth = gf_bs_read_int(bs, 1);\n\tcfg->twelve_bit = gf_bs_read_int(bs, 1);\n\tcfg->monochrome = gf_bs_read_int(bs, 1);\n\tcfg->chroma_subsampling_x = gf_bs_read_int(bs, 1);\n\tcfg->chroma_subsampling_y = gf_bs_read_int(bs, 1);\n\tcfg->chroma_sample_position = gf_bs_read_int(bs, 2);\n\n\treserved = gf_bs_read_int(bs, 3);\n\tif (reserved != 0 || cfg->marker != 1 || cfg->version != 1) {\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[AV1] wrong avcC reserved %d / marker %d / version %d expecting 0 1 1\\n\", reserved, cfg->marker, cfg->version));\n\t\tgf_odf_av1_cfg_del(cfg);\n\t\treturn NULL;\n\t}\n\tcfg->initial_presentation_delay_present = gf_bs_read_int(bs, 1);\n\tif (cfg->initial_presentation_delay_present) {\n\t\tcfg->initial_presentation_delay_minus_one = gf_bs_read_int(bs, 4);\n\t} else {\n\t\t/*reserved = */gf_bs_read_int(bs, 4);\n\t\tcfg->initial_presentation_delay_minus_one = 0;\n\t}\n\tsize -= 4;\n\n\twhile (size) {\n\t\tu64 pos, obu_size;\n\t\tObuType obu_type;\n\t\tGF_AV1_OBUArrayEntry *a;\n\n\t\tpos = gf_bs_get_position(bs);\n\t\tobu_size = 0;\n\t\tif (gf_av1_parse_obu(bs, &obu_type, &obu_size, NULL, &state) != GF_OK) {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_CONTAINER, (\"[AV1] could not parse AV1 OBU at position \"LLU\". Leaving parsing.\\n\", pos));\n\t\t\tbreak;\n\t\t}\n\t\tassert(obu_size == gf_bs_get_position(bs) - pos);\n\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[AV1] parsed AV1 OBU type=%u size=\"LLU\" at position \"LLU\".\\n\", obu_type, obu_size, pos));\n\n\t\tif (!av1_is_obu_header(obu_type)) {\n\t\t\tGF_LOG(GF_LOG_DEBUG, GF_LOG_CONTAINER, (\"[AV1] AV1 unexpected OBU type=%u size=\"LLU\" found at position \"LLU\". Forwarding.\\n\", pos));\n\t\t}\n\t\tGF_SAFEALLOC(a, GF_AV1_OBUArrayEntry);\n\t\tif (!a) break;\n\t\ta->obu = gf_malloc((size_t)obu_size);\n\t\tif (!a->obu) {\n\t\t\tgf_free(a);\n\t\t\tbreak;\n\t\t}\n\t\tgf_bs_seek(bs, pos);\n\t\tgf_bs_read_data(bs, (char *) a->obu, (u32)obu_size);\n\t\ta->obu_length = obu_size;\n\t\ta->obu_type = obu_type;\n\t\tgf_list_add(cfg->obu_array, a);\n\n\t\tif (size<obu_size) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_CONTAINER, (\"[AV1] AV1 config misses %d bytes to fit the entire OBU\\n\", obu_size - size));\n\t\t\tbreak;\n\t\t}\n\t\tsize -= (u32) obu_size;\n\t}\n\tgf_av1_reset_state(& state, GF_TRUE);\n\tgf_bs_align(bs);\n\treturn cfg;\n#else\n\treturn NULL;\n#endif\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -77,6 +77,7 @@\n \t\tsize -= (u32) obu_size;\n \t}\n \tgf_av1_reset_state(& state, GF_TRUE);\n+\tgf_bs_align(bs);\n \treturn cfg;\n #else\n \treturn NULL;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tgf_bs_align(bs);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-40572",
        "func_name": "gpac/gf_av1_reset_state",
        "description": "The binary MP4Box in Gpac 1.0.1 has a double-free bug in the av1dmx_finalize function in reframe_av1.c, which allows attackers to cause a denial of service.",
        "git_url": "https://github.com/gpac/gpac/commit/7bb1b4a4dd23c885f9db9f577dfe79ecc5433109",
        "commit_title": "fixed #1893",
        "commit_text": "",
        "func_before": "GF_EXPORT\nvoid gf_av1_reset_state(AV1State *state, Bool is_destroy)\n{\n\tGF_List *l1, *l2;\n\n\tif (state->frame_state.header_obus) {\n\t\twhile (gf_list_count(state->frame_state.header_obus)) {\n\t\t\tGF_AV1_OBUArrayEntry *a = (GF_AV1_OBUArrayEntry*)gf_list_pop_back(state->frame_state.header_obus);\n\t\t\tif (a->obu) gf_free(a->obu);\n\t\t\tgf_free(a);\n\t\t}\n\t}\n\n\tif (state->frame_state.frame_obus) {\n\t\twhile (gf_list_count(state->frame_state.frame_obus)) {\n\t\t\tGF_AV1_OBUArrayEntry *a = (GF_AV1_OBUArrayEntry*)gf_list_pop_back(state->frame_state.frame_obus);\n\t\t\tif (a->obu) gf_free(a->obu);\n\t\t\tgf_free(a);\n\t\t}\n\t}\n\tl1 = state->frame_state.frame_obus;\n\tl2 = state->frame_state.header_obus;\n\tmemset(&state->frame_state, 0, sizeof(AV1StateFrame));\n\tstate->frame_state.is_first_frame = GF_TRUE;\n\n\tif (is_destroy) {\n\t\tgf_list_del(l1);\n\t\tgf_list_del(l2);\n\t\tif (state->bs) {\n\t\t\tif (gf_bs_get_position(state->bs)) {\n\t\t\t\tu32 size;\n\t\t\t\tgf_bs_get_content_no_truncate(state->bs, &state->frame_obus, &size, &state->frame_obus_alloc);\n\t\t\t}\n\t\t\tgf_bs_del(state->bs);\n\t\t}\n\t\tstate->bs = NULL;\n\t}\n\telse {\n\t\tstate->frame_state.frame_obus = l1;\n\t\tstate->frame_state.header_obus = l2;\n\t\tif (state->bs)\n\t\t\tgf_bs_seek(state->bs, 0);\n\t}\n}",
        "func": "GF_EXPORT\nvoid gf_av1_reset_state(AV1State *state, Bool is_destroy)\n{\n\tGF_List *l1, *l2;\n\n\tif (state->frame_state.header_obus) {\n\t\twhile (gf_list_count(state->frame_state.header_obus)) {\n\t\t\tGF_AV1_OBUArrayEntry *a = (GF_AV1_OBUArrayEntry*)gf_list_pop_back(state->frame_state.header_obus);\n\t\t\tif (a->obu) gf_free(a->obu);\n\t\t\tgf_free(a);\n\t\t}\n\t}\n\n\tif (state->frame_state.frame_obus) {\n\t\twhile (gf_list_count(state->frame_state.frame_obus)) {\n\t\t\tGF_AV1_OBUArrayEntry *a = (GF_AV1_OBUArrayEntry*)gf_list_pop_back(state->frame_state.frame_obus);\n\t\t\tif (a->obu) gf_free(a->obu);\n\t\t\tgf_free(a);\n\t\t}\n\t}\n\tl1 = state->frame_state.frame_obus;\n\tl2 = state->frame_state.header_obus;\n\tmemset(&state->frame_state, 0, sizeof(AV1StateFrame));\n\tstate->frame_state.is_first_frame = GF_TRUE;\n\n\tif (is_destroy) {\n\t\tgf_list_del(l1);\n\t\tgf_list_del(l2);\n\t\tif (state->bs) {\n\t\t\tu32 size;\n\t\t\tgf_bs_get_content_no_truncate(state->bs, &state->frame_obus, &size, &state->frame_obus_alloc);\n\t\t\tgf_bs_del(state->bs);\n\t\t}\n\t\tstate->bs = NULL;\n\t}\n\telse {\n\t\tstate->frame_state.frame_obus = l1;\n\t\tstate->frame_state.header_obus = l2;\n\t\tif (state->bs)\n\t\t\tgf_bs_seek(state->bs, 0);\n\t}\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -27,10 +27,8 @@\n \t\tgf_list_del(l1);\n \t\tgf_list_del(l2);\n \t\tif (state->bs) {\n-\t\t\tif (gf_bs_get_position(state->bs)) {\n-\t\t\t\tu32 size;\n-\t\t\t\tgf_bs_get_content_no_truncate(state->bs, &state->frame_obus, &size, &state->frame_obus_alloc);\n-\t\t\t}\n+\t\t\tu32 size;\n+\t\t\tgf_bs_get_content_no_truncate(state->bs, &state->frame_obus, &size, &state->frame_obus_alloc);\n \t\t\tgf_bs_del(state->bs);\n \t\t}\n \t\tstate->bs = NULL;",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\tif (gf_bs_get_position(state->bs)) {",
                "\t\t\t\tu32 size;",
                "\t\t\t\tgf_bs_get_content_no_truncate(state->bs, &state->frame_obus, &size, &state->frame_obus_alloc);",
                "\t\t\t}"
            ],
            "added_lines": [
                "\t\t\tu32 size;",
                "\t\t\tgf_bs_get_content_no_truncate(state->bs, &state->frame_obus, &size, &state->frame_obus_alloc);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-40574",
        "func_name": "gpac/gf_text_process_sub",
        "description": "The binary MP4Box in Gpac 1.0.1 has a double-free vulnerability in the gf_text_get_utf8_line function in load_text.c, which allows attackers to cause a denial of service, even code execution and escalation of privileges.",
        "git_url": "https://github.com/gpac/gpac/commit/30ac5e5236b790accd1f25347eebf2dc8c6c1bcb",
        "commit_title": "fixed #1897",
        "commit_text": "",
        "func_before": "static GF_Err gf_text_process_sub(GF_Filter *filter, GF_TXTIn *ctx)\n{\n\tu32 i, j, len, line;\n\tGF_TextSample *samp;\n\tDouble ts_scale;\n\tchar szLine[2048], szTime[20], szText[2048];\n\n\t//same setup as for srt\n\tif (!ctx->is_setup) {\n\t\tctx->is_setup = GF_TRUE;\n\t\treturn txtin_setup_srt(filter, ctx);\n\t}\n\tif (!ctx->opid) return GF_NOT_SUPPORTED;\n\tif (!ctx->playstate) return GF_OK;\n\telse if (ctx->playstate==2) return GF_EOS;\n\n\tif (ctx->seek_state==1) {\n\t\tctx->seek_state = 2;\n\t\tgf_fseek(ctx->src, 0, SEEK_SET);\n\t}\n\n\tif (ctx->fps.den && ctx->fps.num) {\n\t\tts_scale = ((Double) ctx->fps.num) / ctx->fps.den;\n\t} else {\n\t\tts_scale = 25;\n\t}\n\n\tline = 0;\n\n\twhile (1) {\n\t\tchar *sOK = gf_text_get_utf8_line(szLine, 2048, ctx->src, ctx->unicode_type);\n\t\tif (!sOK) break;\n\n\t\tREM_TRAIL_MARKS(szLine, \"\\r\\n\\t \")\n\n\t\tline++;\n\t\tlen = (u32) strlen(szLine);\n\t\tif (!len) continue;\n\n\t\ti=0;\n\t\tif (szLine[i] != '{') {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[TXTIn] Bad SUB file (line %d): expecting \\\"{\\\" got \\\"%c\\\"\\n\", line, szLine[i]));\n\t\t\tcontinue;\n\t\t}\n\t\twhile (szLine[i+1] && szLine[i+1]!='}') {\n\t\t\tszTime[i] = szLine[i+1];\n\t\t\ti++;\n\t\t}\n\t\tszTime[i] = 0;\n\t\tctx->start = atoi(szTime);\n\t\tif (ctx->start < ctx->end) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TXTIn] corrupted SUB frame (line %d) - starts (at %d ms) before end of previous one (%d ms) - adjusting time stamps\\n\", line, ctx->start, ctx->end));\n\t\t\tctx->start = ctx->end;\n\t\t}\n\t\tj=i+2;\n\t\ti=0;\n\t\tif (szLine[i+j] != '{') {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TXTIn] Bad SUB file - expecting \\\"{\\\" got \\\"%c\\\"\\n\", szLine[i]));\n\t\t\tcontinue;\n\t\t}\n\t\twhile (szLine[i+1+j] && szLine[i+1+j]!='}') {\n\t\t\tszTime[i] = szLine[i+1+j];\n\t\t\ti++;\n\t\t}\n\t\tszTime[i] = 0;\n\t\tctx->end = atoi(szTime);\n\t\tj+=i+2;\n\n\t\tif (ctx->start > ctx->end) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TXTIn] corrupted SUB frame (line %d) - ends (at %d ms) before start of current frame (%d ms) - skipping\\n\", line, ctx->end, ctx->start));\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ctx->start && ctx->first_samp) {\n\t\t\tsamp = gf_isom_new_text_sample();\n\t\t\ttxtin_process_send_text_sample(ctx, samp, 0, (u32) (ts_scale*ctx->start), GF_TRUE);\n\t\t\tctx->first_samp = GF_FALSE;\n\t\t\tgf_isom_delete_text_sample(samp);\n\t\t}\n\n\t\tfor (i=j; i<len; i++) {\n\t\t\tif (szLine[i]=='|') {\n\t\t\t\tszText[i-j] = '\\n';\n\t\t\t} else {\n\t\t\t\tszText[i-j] = szLine[i];\n\t\t\t}\n\t\t}\n\t\tszText[i-j] = 0;\n\n\t\tif (ctx->prev_end) {\n\t\t\tsamp = gf_isom_new_text_sample();\n\t\t\ttxtin_process_send_text_sample(ctx, samp, (u64) (ts_scale*(s64)ctx->prev_end), (u32) (ts_scale*(ctx->start - ctx->prev_end)), GF_TRUE);\n\t\t\tgf_isom_delete_text_sample(samp);\n\t\t}\n\n\t\tsamp = gf_isom_new_text_sample();\n\t\tgf_isom_text_add_text(samp, szText, (u32) strlen(szText) );\n\t\ttxtin_process_send_text_sample(ctx, samp, (u64) (ts_scale*(s64)ctx->start), (u32) (ts_scale*(ctx->end - ctx->start)), GF_TRUE);\n\t\tgf_isom_delete_text_sample(samp);\n\n\t\tctx->prev_end = ctx->end;\n\n\t\tgf_filter_pid_set_info(ctx->opid, GF_PROP_PID_DOWN_BYTES, &PROP_LONGUINT( gf_ftell(ctx->src )) );\n\n\t\tif (gf_filter_pid_would_block(ctx->opid))\n\t\t\treturn GF_OK;\n\t}\n\t/*final flush*/\n\tif (ctx->end && !ctx->noflush) {\n\t\tsamp = gf_isom_new_text_sample();\n\t\ttxtin_process_send_text_sample(ctx, samp, (u64) (ts_scale*(s64)ctx->end), 0, GF_TRUE);\n\t\tgf_isom_delete_text_sample(samp);\n\t}\n\n\tgf_filter_pid_set_info_str( ctx->opid, \"ttxt:last_dur\", &PROP_UINT(0) );\n\n\treturn GF_EOS;\n}",
        "func": "static GF_Err gf_text_process_sub(GF_Filter *filter, GF_TXTIn *ctx)\n{\n\tu32 i, j, len, line;\n\tGF_TextSample *samp;\n\tDouble ts_scale;\n\tchar szLine[2048], szTime[20], szText[2048];\n\n\t//same setup as for srt\n\tif (!ctx->is_setup) {\n\t\tctx->is_setup = GF_TRUE;\n\t\treturn txtin_setup_srt(filter, ctx);\n\t}\n\tif (!ctx->opid) return GF_NOT_SUPPORTED;\n\tif (!ctx->playstate) return GF_OK;\n\telse if (ctx->playstate==2) return GF_EOS;\n\n\tif (ctx->seek_state==1) {\n\t\tctx->seek_state = 2;\n\t\tgf_fseek(ctx->src, 0, SEEK_SET);\n\t}\n\n\tif (ctx->fps.den && ctx->fps.num) {\n\t\tts_scale = ((Double) ctx->fps.num) / ctx->fps.den;\n\t} else {\n\t\tts_scale = 25;\n\t}\n\n\tline = 0;\n\n\twhile (1) {\n\t\tchar *sOK = gf_text_get_utf8_line(szLine, 2048, ctx->src, ctx->unicode_type);\n\t\tif (!sOK) break;\n\n\t\tREM_TRAIL_MARKS(szLine, \"\\r\\n\\t \")\n\n\t\tline++;\n\t\tlen = (u32) strlen(szLine);\n\t\tif (!len) continue;\n\n\t\ti=0;\n\t\tif (szLine[i] != '{') {\n\t\t\tGF_LOG(GF_LOG_ERROR, GF_LOG_PARSER, (\"[TXTIn] Bad SUB file (line %d): expecting \\\"{\\\" got \\\"%c\\\"\\n\", line, szLine[i]));\n\t\t\tcontinue;\n\t\t}\n\t\twhile (szLine[i+1] && szLine[i+1]!='}') {\n\t\t\tszTime[i] = szLine[i+1];\n\t\t\ti++;\n\t\t\tif (i>=19)\n\t\t\t\tbreak;\n\t\t}\n\t\tszTime[i] = 0;\n\t\tctx->start = atoi(szTime);\n\t\tif (ctx->start < ctx->end) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TXTIn] corrupted SUB frame (line %d) - starts (at %d ms) before end of previous one (%d ms) - adjusting time stamps\\n\", line, ctx->start, ctx->end));\n\t\t\tctx->start = ctx->end;\n\t\t}\n\t\tj=i+2;\n\t\ti=0;\n\t\tif (szLine[i+j] != '{') {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TXTIn] Bad SUB file - expecting \\\"{\\\" got \\\"%c\\\"\\n\", szLine[i]));\n\t\t\tcontinue;\n\t\t}\n\t\twhile (szLine[i+1+j] && szLine[i+1+j]!='}') {\n\t\t\tszTime[i] = szLine[i+1+j];\n\t\t\ti++;\n\t\t}\n\t\tszTime[i] = 0;\n\t\tctx->end = atoi(szTime);\n\t\tj+=i+2;\n\n\t\tif (ctx->start > ctx->end) {\n\t\t\tGF_LOG(GF_LOG_WARNING, GF_LOG_PARSER, (\"[TXTIn] corrupted SUB frame (line %d) - ends (at %d ms) before start of current frame (%d ms) - skipping\\n\", line, ctx->end, ctx->start));\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (ctx->start && ctx->first_samp) {\n\t\t\tsamp = gf_isom_new_text_sample();\n\t\t\ttxtin_process_send_text_sample(ctx, samp, 0, (u32) (ts_scale*ctx->start), GF_TRUE);\n\t\t\tctx->first_samp = GF_FALSE;\n\t\t\tgf_isom_delete_text_sample(samp);\n\t\t}\n\n\t\tfor (i=j; i<len; i++) {\n\t\t\tif (szLine[i]=='|') {\n\t\t\t\tszText[i-j] = '\\n';\n\t\t\t} else {\n\t\t\t\tszText[i-j] = szLine[i];\n\t\t\t}\n\t\t}\n\t\tszText[i-j] = 0;\n\n\t\tif (ctx->prev_end) {\n\t\t\tsamp = gf_isom_new_text_sample();\n\t\t\ttxtin_process_send_text_sample(ctx, samp, (u64) (ts_scale*(s64)ctx->prev_end), (u32) (ts_scale*(ctx->start - ctx->prev_end)), GF_TRUE);\n\t\t\tgf_isom_delete_text_sample(samp);\n\t\t}\n\n\t\tsamp = gf_isom_new_text_sample();\n\t\tgf_isom_text_add_text(samp, szText, (u32) strlen(szText) );\n\t\ttxtin_process_send_text_sample(ctx, samp, (u64) (ts_scale*(s64)ctx->start), (u32) (ts_scale*(ctx->end - ctx->start)), GF_TRUE);\n\t\tgf_isom_delete_text_sample(samp);\n\n\t\tctx->prev_end = ctx->end;\n\n\t\tgf_filter_pid_set_info(ctx->opid, GF_PROP_PID_DOWN_BYTES, &PROP_LONGUINT( gf_ftell(ctx->src )) );\n\n\t\tif (gf_filter_pid_would_block(ctx->opid))\n\t\t\treturn GF_OK;\n\t}\n\t/*final flush*/\n\tif (ctx->end && !ctx->noflush) {\n\t\tsamp = gf_isom_new_text_sample();\n\t\ttxtin_process_send_text_sample(ctx, samp, (u64) (ts_scale*(s64)ctx->end), 0, GF_TRUE);\n\t\tgf_isom_delete_text_sample(samp);\n\t}\n\n\tgf_filter_pid_set_info_str( ctx->opid, \"ttxt:last_dur\", &PROP_UINT(0) );\n\n\treturn GF_EOS;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -45,6 +45,8 @@\n \t\twhile (szLine[i+1] && szLine[i+1]!='}') {\n \t\t\tszTime[i] = szLine[i+1];\n \t\t\ti++;\n+\t\t\tif (i>=19)\n+\t\t\t\tbreak;\n \t\t}\n \t\tszTime[i] = 0;\n \t\tctx->start = atoi(szTime);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\t\tif (i>=19)",
                "\t\t\t\tbreak;"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-40574",
        "func_name": "gpac/gf_text_get_utf8_line",
        "description": "The binary MP4Box in Gpac 1.0.1 has a double-free vulnerability in the gf_text_get_utf8_line function in load_text.c, which allows attackers to cause a denial of service, even code execution and escalation of privileges.",
        "git_url": "https://github.com/gpac/gpac/commit/30ac5e5236b790accd1f25347eebf2dc8c6c1bcb",
        "commit_title": "fixed #1897",
        "commit_text": "",
        "func_before": "char *gf_text_get_utf8_line(char *szLine, u32 lineSize, FILE *txt_in, s32 unicode_type)\n{\n\tu32 i, j, len;\n\tchar *sOK;\n\tchar szLineConv[1024];\n\tunsigned short *sptr;\n\n\tmemset(szLine, 0, sizeof(char)*lineSize);\n\tsOK = gf_fgets(szLine, lineSize, txt_in);\n\tif (!sOK) return NULL;\n\tif (unicode_type<=1) {\n\t\tj=0;\n\t\tlen = (u32) strlen(szLine);\n\t\tfor (i=0; i<len; i++) {\n\t\t\tif (!unicode_type && (szLine[i] & 0x80)) {\n\t\t\t\t/*non UTF8 (likely some win-CP)*/\n\t\t\t\tif ((szLine[i+1] & 0xc0) != 0x80) {\n\t\t\t\t\tszLineConv[j] = 0xc0 | ( (szLine[i] >> 6) & 0x3 );\n\t\t\t\t\tj++;\n\t\t\t\t\tszLine[i] &= 0xbf;\n\t\t\t\t}\n\t\t\t\t/*UTF8 2 bytes char*/\n\t\t\t\telse if ( (szLine[i] & 0xe0) == 0xc0) {\n\t\t\t\t\tszLineConv[j] = szLine[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\t/*UTF8 3 bytes char*/\n\t\t\t\telse if ( (szLine[i] & 0xf0) == 0xe0) {\n\t\t\t\t\tszLineConv[j] = szLine[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t\tszLineConv[j] = szLine[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\t/*UTF8 4 bytes char*/\n\t\t\t\telse if ( (szLine[i] & 0xf8) == 0xf0) {\n\t\t\t\t\tszLineConv[j] = szLine[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t\tszLineConv[j] = szLine[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t\tszLineConv[j] = szLine[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t} else {\n\t\t\t\t\ti+=1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tszLineConv[j] = szLine[i];\n\t\t\tj++;\n\t\t}\n\t\tszLineConv[j] = 0;\n\t\tstrcpy(szLine, szLineConv);\n\t\treturn sOK;\n\t}\n\n#ifdef GPAC_BIG_ENDIAN\n\tif (unicode_type==3)\n#else\n\tif (unicode_type==2)\n#endif\n\t{\n\t\ti=0;\n\t\twhile (1) {\n\t\t\tchar c;\n\t\t\tif (!szLine[i] && !szLine[i+1]) break;\n\t\t\tc = szLine[i+1];\n\t\t\tszLine[i+1] = szLine[i];\n\t\t\tszLine[i] = c;\n\t\t\ti+=2;\n\t\t}\n\t}\n\tsptr = (u16 *)szLine;\n\ti = (u32) gf_utf8_wcstombs(szLineConv, 1024, (const unsigned short **) &sptr);\n\tszLineConv[i] = 0;\n\tstrcpy(szLine, szLineConv);\n\t/*this is ugly indeed: since input is UTF16-LE, there are many chances the gf_fgets never reads the \\0 after a \\n*/\n\tif (unicode_type==3) gf_fgetc(txt_in);\n\treturn sOK;\n}",
        "func": "char *gf_text_get_utf8_line(char *szLine, u32 lineSize, FILE *txt_in, s32 unicode_type)\n{\n\tu32 i, j, len;\n\tchar *sOK;\n\tchar szLineConv[2048];\n\tunsigned short *sptr;\n\n\tmemset(szLine, 0, sizeof(char)*lineSize);\n\tsOK = gf_fgets(szLine, lineSize, txt_in);\n\tif (!sOK) return NULL;\n\tif (unicode_type<=1) {\n\t\tj=0;\n\t\tlen = (u32) strlen(szLine);\n\t\tfor (i=0; i<len; i++) {\n\t\t\tif (!unicode_type && (szLine[i] & 0x80)) {\n\t\t\t\t/*non UTF8 (likely some win-CP)*/\n\t\t\t\tif ((szLine[i+1] & 0xc0) != 0x80) {\n\t\t\t\t\tszLineConv[j] = 0xc0 | ( (szLine[i] >> 6) & 0x3 );\n\t\t\t\t\tj++;\n\t\t\t\t\tszLine[i] &= 0xbf;\n\t\t\t\t}\n\t\t\t\t/*UTF8 2 bytes char*/\n\t\t\t\telse if ( (szLine[i] & 0xe0) == 0xc0) {\n\t\t\t\t\tszLineConv[j] = szLine[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\t/*UTF8 3 bytes char*/\n\t\t\t\telse if ( (szLine[i] & 0xf0) == 0xe0) {\n\t\t\t\t\tszLineConv[j] = szLine[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t\tszLineConv[j] = szLine[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\t/*UTF8 4 bytes char*/\n\t\t\t\telse if ( (szLine[i] & 0xf8) == 0xf0) {\n\t\t\t\t\tszLineConv[j] = szLine[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t\tszLineConv[j] = szLine[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t\tszLineConv[j] = szLine[i];\n\t\t\t\t\ti++;\n\t\t\t\t\tj++;\n\t\t\t\t} else {\n\t\t\t\t\ti+=1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tszLineConv[j] = szLine[i];\n\t\t\tj++;\n\t\t}\n\t\tszLineConv[j] = 0;\n\t\tstrcpy(szLine, szLineConv);\n\t\treturn sOK;\n\t}\n\n#ifdef GPAC_BIG_ENDIAN\n\tif (unicode_type==3)\n#else\n\tif (unicode_type==2)\n#endif\n\t{\n\t\ti=0;\n\t\twhile (1) {\n\t\t\tchar c;\n\t\t\tif (!szLine[i] && !szLine[i+1]) break;\n\t\t\tc = szLine[i+1];\n\t\t\tszLine[i+1] = szLine[i];\n\t\t\tszLine[i] = c;\n\t\t\ti+=2;\n\t\t}\n\t}\n\tsptr = (u16 *)szLine;\n\ti = (u32) gf_utf8_wcstombs(szLineConv, 2048, (const unsigned short **) &sptr);\n\tszLineConv[i] = 0;\n\tstrcpy(szLine, szLineConv);\n\t/*this is ugly indeed: since input is UTF16-LE, there are many chances the gf_fgets never reads the \\0 after a \\n*/\n\tif (unicode_type==3) gf_fgetc(txt_in);\n\treturn sOK;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,7 +2,7 @@\n {\n \tu32 i, j, len;\n \tchar *sOK;\n-\tchar szLineConv[1024];\n+\tchar szLineConv[2048];\n \tunsigned short *sptr;\n \n \tmemset(szLine, 0, sizeof(char)*lineSize);\n@@ -75,7 +75,7 @@\n \t\t}\n \t}\n \tsptr = (u16 *)szLine;\n-\ti = (u32) gf_utf8_wcstombs(szLineConv, 1024, (const unsigned short **) &sptr);\n+\ti = (u32) gf_utf8_wcstombs(szLineConv, 2048, (const unsigned short **) &sptr);\n \tszLineConv[i] = 0;\n \tstrcpy(szLine, szLineConv);\n \t/*this is ugly indeed: since input is UTF16-LE, there are many chances the gf_fgets never reads the \\0 after a \\n*/",
        "diff_line_info": {
            "deleted_lines": [
                "\tchar szLineConv[1024];",
                "\ti = (u32) gf_utf8_wcstombs(szLineConv, 1024, (const unsigned short **) &sptr);"
            ],
            "added_lines": [
                "\tchar szLineConv[2048];",
                "\ti = (u32) gf_utf8_wcstombs(szLineConv, 2048, (const unsigned short **) &sptr);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-22600",
        "func_name": "torvalds/linux/packet_set_ring",
        "description": "A double free bug in packet_set_ring() in net/packet/af_packet.c can be exploited by a local user through crafted syscalls to escalate privileges or deny service. We recommend upgrading kernel past the effected versions or rebuilding past ec6af094ea28f0f2dda1a6a33b14cd57e36a9755",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit?h=ec6af094ea28f0f2dda1a6a33b14cd57e36a9755",
        "commit_title": "Packet sockets may switch ring versions. Avoid misinterpreting state",
        "commit_text": "between versions, whose fields share a union. rx_owner_map is only allocated with a packet ring (pg_vec) and both are swapped together. If pg_vec is NULL, meaning no packet ring was allocated, then neither was rx_owner_map. And the field may be old state from a tpacket_v3.  Link: https://lore.kernel.org/r/20211215143937.106178-1-willemdebruijn.kernel@gmail.com ",
        "func_before": "static int packet_set_ring(struct sock *sk, union tpacket_req_u *req_u,\n\t\tint closing, int tx_ring)\n{\n\tstruct pgv *pg_vec = NULL;\n\tstruct packet_sock *po = pkt_sk(sk);\n\tunsigned long *rx_owner_map = NULL;\n\tint was_running, order = 0;\n\tstruct packet_ring_buffer *rb;\n\tstruct sk_buff_head *rb_queue;\n\t__be16 num;\n\tint err;\n\t/* Added to avoid minimal code churn */\n\tstruct tpacket_req *req = &req_u->req;\n\n\trb = tx_ring ? &po->tx_ring : &po->rx_ring;\n\trb_queue = tx_ring ? &sk->sk_write_queue : &sk->sk_receive_queue;\n\n\terr = -EBUSY;\n\tif (!closing) {\n\t\tif (atomic_read(&po->mapped))\n\t\t\tgoto out;\n\t\tif (packet_read_pending(rb))\n\t\t\tgoto out;\n\t}\n\n\tif (req->tp_block_nr) {\n\t\tunsigned int min_frame_size;\n\n\t\t/* Sanity tests and some calculations */\n\t\terr = -EBUSY;\n\t\tif (unlikely(rb->pg_vec))\n\t\t\tgoto out;\n\n\t\tswitch (po->tp_version) {\n\t\tcase TPACKET_V1:\n\t\t\tpo->tp_hdrlen = TPACKET_HDRLEN;\n\t\t\tbreak;\n\t\tcase TPACKET_V2:\n\t\t\tpo->tp_hdrlen = TPACKET2_HDRLEN;\n\t\t\tbreak;\n\t\tcase TPACKET_V3:\n\t\t\tpo->tp_hdrlen = TPACKET3_HDRLEN;\n\t\t\tbreak;\n\t\t}\n\n\t\terr = -EINVAL;\n\t\tif (unlikely((int)req->tp_block_size <= 0))\n\t\t\tgoto out;\n\t\tif (unlikely(!PAGE_ALIGNED(req->tp_block_size)))\n\t\t\tgoto out;\n\t\tmin_frame_size = po->tp_hdrlen + po->tp_reserve;\n\t\tif (po->tp_version >= TPACKET_V3 &&\n\t\t    req->tp_block_size <\n\t\t    BLK_PLUS_PRIV((u64)req_u->req3.tp_sizeof_priv) + min_frame_size)\n\t\t\tgoto out;\n\t\tif (unlikely(req->tp_frame_size < min_frame_size))\n\t\t\tgoto out;\n\t\tif (unlikely(req->tp_frame_size & (TPACKET_ALIGNMENT - 1)))\n\t\t\tgoto out;\n\n\t\trb->frames_per_block = req->tp_block_size / req->tp_frame_size;\n\t\tif (unlikely(rb->frames_per_block == 0))\n\t\t\tgoto out;\n\t\tif (unlikely(rb->frames_per_block > UINT_MAX / req->tp_block_nr))\n\t\t\tgoto out;\n\t\tif (unlikely((rb->frames_per_block * req->tp_block_nr) !=\n\t\t\t\t\treq->tp_frame_nr))\n\t\t\tgoto out;\n\n\t\terr = -ENOMEM;\n\t\torder = get_order(req->tp_block_size);\n\t\tpg_vec = alloc_pg_vec(req, order);\n\t\tif (unlikely(!pg_vec))\n\t\t\tgoto out;\n\t\tswitch (po->tp_version) {\n\t\tcase TPACKET_V3:\n\t\t\t/* Block transmit is not supported yet */\n\t\t\tif (!tx_ring) {\n\t\t\t\tinit_prb_bdqc(po, rb, pg_vec, req_u);\n\t\t\t} else {\n\t\t\t\tstruct tpacket_req3 *req3 = &req_u->req3;\n\n\t\t\t\tif (req3->tp_retire_blk_tov ||\n\t\t\t\t    req3->tp_sizeof_priv ||\n\t\t\t\t    req3->tp_feature_req_word) {\n\t\t\t\t\terr = -EINVAL;\n\t\t\t\t\tgoto out_free_pg_vec;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (!tx_ring) {\n\t\t\t\trx_owner_map = bitmap_alloc(req->tp_frame_nr,\n\t\t\t\t\tGFP_KERNEL | __GFP_NOWARN | __GFP_ZERO);\n\t\t\t\tif (!rx_owner_map)\n\t\t\t\t\tgoto out_free_pg_vec;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\t/* Done */\n\telse {\n\t\terr = -EINVAL;\n\t\tif (unlikely(req->tp_frame_nr))\n\t\t\tgoto out;\n\t}\n\n\n\t/* Detach socket from network */\n\tspin_lock(&po->bind_lock);\n\twas_running = po->running;\n\tnum = po->num;\n\tif (was_running) {\n\t\tWRITE_ONCE(po->num, 0);\n\t\t__unregister_prot_hook(sk, false);\n\t}\n\tspin_unlock(&po->bind_lock);\n\n\tsynchronize_net();\n\n\terr = -EBUSY;\n\tmutex_lock(&po->pg_vec_lock);\n\tif (closing || atomic_read(&po->mapped) == 0) {\n\t\terr = 0;\n\t\tspin_lock_bh(&rb_queue->lock);\n\t\tswap(rb->pg_vec, pg_vec);\n\t\tif (po->tp_version <= TPACKET_V2)\n\t\t\tswap(rb->rx_owner_map, rx_owner_map);\n\t\trb->frame_max = (req->tp_frame_nr - 1);\n\t\trb->head = 0;\n\t\trb->frame_size = req->tp_frame_size;\n\t\tspin_unlock_bh(&rb_queue->lock);\n\n\t\tswap(rb->pg_vec_order, order);\n\t\tswap(rb->pg_vec_len, req->tp_block_nr);\n\n\t\trb->pg_vec_pages = req->tp_block_size/PAGE_SIZE;\n\t\tpo->prot_hook.func = (po->rx_ring.pg_vec) ?\n\t\t\t\t\t\ttpacket_rcv : packet_rcv;\n\t\tskb_queue_purge(rb_queue);\n\t\tif (atomic_read(&po->mapped))\n\t\t\tpr_err(\"packet_mmap: vma is busy: %d\\n\",\n\t\t\t       atomic_read(&po->mapped));\n\t}\n\tmutex_unlock(&po->pg_vec_lock);\n\n\tspin_lock(&po->bind_lock);\n\tif (was_running) {\n\t\tWRITE_ONCE(po->num, num);\n\t\tregister_prot_hook(sk);\n\t}\n\tspin_unlock(&po->bind_lock);\n\tif (pg_vec && (po->tp_version > TPACKET_V2)) {\n\t\t/* Because we don't support block-based V3 on tx-ring */\n\t\tif (!tx_ring)\n\t\t\tprb_shutdown_retire_blk_timer(po, rb_queue);\n\t}\n\nout_free_pg_vec:\n\tbitmap_free(rx_owner_map);\n\tif (pg_vec)\n\t\tfree_pg_vec(pg_vec, order, req->tp_block_nr);\nout:\n\treturn err;\n}",
        "func": "static int packet_set_ring(struct sock *sk, union tpacket_req_u *req_u,\n\t\tint closing, int tx_ring)\n{\n\tstruct pgv *pg_vec = NULL;\n\tstruct packet_sock *po = pkt_sk(sk);\n\tunsigned long *rx_owner_map = NULL;\n\tint was_running, order = 0;\n\tstruct packet_ring_buffer *rb;\n\tstruct sk_buff_head *rb_queue;\n\t__be16 num;\n\tint err;\n\t/* Added to avoid minimal code churn */\n\tstruct tpacket_req *req = &req_u->req;\n\n\trb = tx_ring ? &po->tx_ring : &po->rx_ring;\n\trb_queue = tx_ring ? &sk->sk_write_queue : &sk->sk_receive_queue;\n\n\terr = -EBUSY;\n\tif (!closing) {\n\t\tif (atomic_read(&po->mapped))\n\t\t\tgoto out;\n\t\tif (packet_read_pending(rb))\n\t\t\tgoto out;\n\t}\n\n\tif (req->tp_block_nr) {\n\t\tunsigned int min_frame_size;\n\n\t\t/* Sanity tests and some calculations */\n\t\terr = -EBUSY;\n\t\tif (unlikely(rb->pg_vec))\n\t\t\tgoto out;\n\n\t\tswitch (po->tp_version) {\n\t\tcase TPACKET_V1:\n\t\t\tpo->tp_hdrlen = TPACKET_HDRLEN;\n\t\t\tbreak;\n\t\tcase TPACKET_V2:\n\t\t\tpo->tp_hdrlen = TPACKET2_HDRLEN;\n\t\t\tbreak;\n\t\tcase TPACKET_V3:\n\t\t\tpo->tp_hdrlen = TPACKET3_HDRLEN;\n\t\t\tbreak;\n\t\t}\n\n\t\terr = -EINVAL;\n\t\tif (unlikely((int)req->tp_block_size <= 0))\n\t\t\tgoto out;\n\t\tif (unlikely(!PAGE_ALIGNED(req->tp_block_size)))\n\t\t\tgoto out;\n\t\tmin_frame_size = po->tp_hdrlen + po->tp_reserve;\n\t\tif (po->tp_version >= TPACKET_V3 &&\n\t\t    req->tp_block_size <\n\t\t    BLK_PLUS_PRIV((u64)req_u->req3.tp_sizeof_priv) + min_frame_size)\n\t\t\tgoto out;\n\t\tif (unlikely(req->tp_frame_size < min_frame_size))\n\t\t\tgoto out;\n\t\tif (unlikely(req->tp_frame_size & (TPACKET_ALIGNMENT - 1)))\n\t\t\tgoto out;\n\n\t\trb->frames_per_block = req->tp_block_size / req->tp_frame_size;\n\t\tif (unlikely(rb->frames_per_block == 0))\n\t\t\tgoto out;\n\t\tif (unlikely(rb->frames_per_block > UINT_MAX / req->tp_block_nr))\n\t\t\tgoto out;\n\t\tif (unlikely((rb->frames_per_block * req->tp_block_nr) !=\n\t\t\t\t\treq->tp_frame_nr))\n\t\t\tgoto out;\n\n\t\terr = -ENOMEM;\n\t\torder = get_order(req->tp_block_size);\n\t\tpg_vec = alloc_pg_vec(req, order);\n\t\tif (unlikely(!pg_vec))\n\t\t\tgoto out;\n\t\tswitch (po->tp_version) {\n\t\tcase TPACKET_V3:\n\t\t\t/* Block transmit is not supported yet */\n\t\t\tif (!tx_ring) {\n\t\t\t\tinit_prb_bdqc(po, rb, pg_vec, req_u);\n\t\t\t} else {\n\t\t\t\tstruct tpacket_req3 *req3 = &req_u->req3;\n\n\t\t\t\tif (req3->tp_retire_blk_tov ||\n\t\t\t\t    req3->tp_sizeof_priv ||\n\t\t\t\t    req3->tp_feature_req_word) {\n\t\t\t\t\terr = -EINVAL;\n\t\t\t\t\tgoto out_free_pg_vec;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (!tx_ring) {\n\t\t\t\trx_owner_map = bitmap_alloc(req->tp_frame_nr,\n\t\t\t\t\tGFP_KERNEL | __GFP_NOWARN | __GFP_ZERO);\n\t\t\t\tif (!rx_owner_map)\n\t\t\t\t\tgoto out_free_pg_vec;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\t/* Done */\n\telse {\n\t\terr = -EINVAL;\n\t\tif (unlikely(req->tp_frame_nr))\n\t\t\tgoto out;\n\t}\n\n\n\t/* Detach socket from network */\n\tspin_lock(&po->bind_lock);\n\twas_running = po->running;\n\tnum = po->num;\n\tif (was_running) {\n\t\tWRITE_ONCE(po->num, 0);\n\t\t__unregister_prot_hook(sk, false);\n\t}\n\tspin_unlock(&po->bind_lock);\n\n\tsynchronize_net();\n\n\terr = -EBUSY;\n\tmutex_lock(&po->pg_vec_lock);\n\tif (closing || atomic_read(&po->mapped) == 0) {\n\t\terr = 0;\n\t\tspin_lock_bh(&rb_queue->lock);\n\t\tswap(rb->pg_vec, pg_vec);\n\t\tif (po->tp_version <= TPACKET_V2)\n\t\t\tswap(rb->rx_owner_map, rx_owner_map);\n\t\trb->frame_max = (req->tp_frame_nr - 1);\n\t\trb->head = 0;\n\t\trb->frame_size = req->tp_frame_size;\n\t\tspin_unlock_bh(&rb_queue->lock);\n\n\t\tswap(rb->pg_vec_order, order);\n\t\tswap(rb->pg_vec_len, req->tp_block_nr);\n\n\t\trb->pg_vec_pages = req->tp_block_size/PAGE_SIZE;\n\t\tpo->prot_hook.func = (po->rx_ring.pg_vec) ?\n\t\t\t\t\t\ttpacket_rcv : packet_rcv;\n\t\tskb_queue_purge(rb_queue);\n\t\tif (atomic_read(&po->mapped))\n\t\t\tpr_err(\"packet_mmap: vma is busy: %d\\n\",\n\t\t\t       atomic_read(&po->mapped));\n\t}\n\tmutex_unlock(&po->pg_vec_lock);\n\n\tspin_lock(&po->bind_lock);\n\tif (was_running) {\n\t\tWRITE_ONCE(po->num, num);\n\t\tregister_prot_hook(sk);\n\t}\n\tspin_unlock(&po->bind_lock);\n\tif (pg_vec && (po->tp_version > TPACKET_V2)) {\n\t\t/* Because we don't support block-based V3 on tx-ring */\n\t\tif (!tx_ring)\n\t\t\tprb_shutdown_retire_blk_timer(po, rb_queue);\n\t}\n\nout_free_pg_vec:\n\tif (pg_vec) {\n\t\tbitmap_free(rx_owner_map);\n\t\tfree_pg_vec(pg_vec, order, req->tp_block_nr);\n\t}\nout:\n\treturn err;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -157,9 +157,10 @@\n \t}\n \n out_free_pg_vec:\n-\tbitmap_free(rx_owner_map);\n-\tif (pg_vec)\n+\tif (pg_vec) {\n+\t\tbitmap_free(rx_owner_map);\n \t\tfree_pg_vec(pg_vec, order, req->tp_block_nr);\n+\t}\n out:\n \treturn err;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tbitmap_free(rx_owner_map);",
                "\tif (pg_vec)"
            ],
            "added_lines": [
                "\tif (pg_vec) {",
                "\t\tbitmap_free(rx_owner_map);",
                "\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-5836",
        "func_name": "libimobiledevice/libplist/parse_dict_node",
        "description": "The plist_free_data function in plist.c in libplist allows attackers to cause a denial of service (crash) via vectors involving an integer node that is treated as a PLIST_KEY and then triggers an invalid free.",
        "git_url": "https://github.com/libimobiledevice/libplist/commit/7a28a14cf6ed547dfd2e52a4db17f47242bfdef9",
        "commit_title": "bplist: Disallow key nodes with non-string node types",
        "commit_text": " As reported in #86, the binary plist parser would force the type of the key node to be of type PLIST_KEY while the node might be of a different i.e. non-string type. A following plist_free() might then call free() on an invalid pointer; e.g. if the node is of type integer, its value would be considered a pointer, and free() would cause an error. We prevent this issue by disallowing non-string key nodes during parsing.",
        "func_before": "static plist_t parse_dict_node(struct bplist_data *bplist, const char** bnode, uint64_t size)\n{\n    uint64_t j;\n    uint64_t str_i = 0, str_j = 0;\n    uint64_t index1, index2;\n    plist_data_t data = plist_new_plist_data();\n    const char *const end_data = bplist->data + bplist->size;\n    const char *index1_ptr = NULL;\n    const char *index2_ptr = NULL;\n\n    data->type = PLIST_DICT;\n    data->length = size;\n\n    plist_t node = node_create(NULL, data);\n\n    for (j = 0; j < data->length; j++) {\n        str_i = j * bplist->dict_size;\n        str_j = (j + size) * bplist->dict_size;\n        index1_ptr = (*bnode) + str_i;\n        index2_ptr = (*bnode) + str_j;\n\n        if ((index1_ptr < bplist->data || index1_ptr + bplist->dict_size >= end_data) ||\n            (index2_ptr < bplist->data || index2_ptr + bplist->dict_size >= end_data)) {\n            plist_free(node);\n            return NULL;\n        }\n\n        index1 = UINT_TO_HOST(index1_ptr, bplist->dict_size);\n        index2 = UINT_TO_HOST(index2_ptr, bplist->dict_size);\n\n        if (index1 >= bplist->num_objects) {\n            plist_free(node);\n            return NULL;\n        }\n        if (index2 >= bplist->num_objects) {\n            plist_free(node);\n            return NULL;\n        }\n\n        /* process key node */\n        plist_t key = parse_bin_node_at_index(bplist, index1);\n        if (!key) {\n            plist_free(node);\n            return NULL;\n        }\n        /* enforce key type */\n        plist_get_data(key)->type = PLIST_KEY;\n        if (!plist_get_data(key)->strval) {\n            fprintf(stderr, \"ERROR: Malformed binary plist dict, invalid key node encountered!\\n\");\n            plist_free(key);\n            plist_free(node);\n            return NULL;\n        }\n\n        /* process value node */\n        plist_t val = parse_bin_node_at_index(bplist, index2);\n        if (!val) {\n            plist_free(key);\n            plist_free(node);\n            return NULL;\n        }\n\n        node_attach(node, key);\n        node_attach(node, val);\n    }\n\n    return node;\n}",
        "func": "static plist_t parse_dict_node(struct bplist_data *bplist, const char** bnode, uint64_t size)\n{\n    uint64_t j;\n    uint64_t str_i = 0, str_j = 0;\n    uint64_t index1, index2;\n    plist_data_t data = plist_new_plist_data();\n    const char *const end_data = bplist->data + bplist->size;\n    const char *index1_ptr = NULL;\n    const char *index2_ptr = NULL;\n\n    data->type = PLIST_DICT;\n    data->length = size;\n\n    plist_t node = node_create(NULL, data);\n\n    for (j = 0; j < data->length; j++) {\n        str_i = j * bplist->dict_size;\n        str_j = (j + size) * bplist->dict_size;\n        index1_ptr = (*bnode) + str_i;\n        index2_ptr = (*bnode) + str_j;\n\n        if ((index1_ptr < bplist->data || index1_ptr + bplist->dict_size >= end_data) ||\n            (index2_ptr < bplist->data || index2_ptr + bplist->dict_size >= end_data)) {\n            plist_free(node);\n            return NULL;\n        }\n\n        index1 = UINT_TO_HOST(index1_ptr, bplist->dict_size);\n        index2 = UINT_TO_HOST(index2_ptr, bplist->dict_size);\n\n        if (index1 >= bplist->num_objects) {\n            plist_free(node);\n            return NULL;\n        }\n        if (index2 >= bplist->num_objects) {\n            plist_free(node);\n            return NULL;\n        }\n\n        /* process key node */\n        plist_t key = parse_bin_node_at_index(bplist, index1);\n        if (!key) {\n            plist_free(node);\n            return NULL;\n        }\n\n        if (plist_get_data(key)->type != PLIST_STRING) {\n            fprintf(stderr, \"ERROR: Malformed binary plist dict, invalid node type for key!\\n\");\n            plist_free(node);\n            return NULL;\n        }\n\n        /* enforce key type */\n        plist_get_data(key)->type = PLIST_KEY;\n        if (!plist_get_data(key)->strval) {\n            fprintf(stderr, \"ERROR: Malformed binary plist dict, invalid key node encountered!\\n\");\n            plist_free(key);\n            plist_free(node);\n            return NULL;\n        }\n\n        /* process value node */\n        plist_t val = parse_bin_node_at_index(bplist, index2);\n        if (!val) {\n            plist_free(key);\n            plist_free(node);\n            return NULL;\n        }\n\n        node_attach(node, key);\n        node_attach(node, val);\n    }\n\n    return node;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -43,6 +43,13 @@\n             plist_free(node);\n             return NULL;\n         }\n+\n+        if (plist_get_data(key)->type != PLIST_STRING) {\n+            fprintf(stderr, \"ERROR: Malformed binary plist dict, invalid node type for key!\\n\");\n+            plist_free(node);\n+            return NULL;\n+        }\n+\n         /* enforce key type */\n         plist_get_data(key)->type = PLIST_KEY;\n         if (!plist_get_data(key)->strval) {",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "        if (plist_get_data(key)->type != PLIST_STRING) {",
                "            fprintf(stderr, \"ERROR: Malformed binary plist dict, invalid node type for key!\\n\");",
                "            plist_free(node);",
                "            return NULL;",
                "        }",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2023-52284",
        "func_name": "bytecodealliance/wasm-micro-runtime/wasm_loader_push_pop_frame_ref_offset",
        "description": "Bytecode Alliance wasm-micro-runtime (aka WebAssembly Micro Runtime or WAMR) before 1.3.0 can have an \"double free or corruption\" error for a valid WebAssembly module because push_pop_frame_ref_offset is mishandled.",
        "git_url": "https://github.com/bytecodealliance/wasm-micro-runtime/commit/b2e668c08414c421718f73366c6c2222684eb828",
        "commit_title": "Fix loader push_pop_frame_ref_offset",
        "commit_text": "",
        "func_before": "static bool\nwasm_loader_push_pop_frame_ref_offset(WASMLoaderContext *ctx, uint8 pop_cnt,\n                                      uint8 type_push, uint8 type_pop,\n                                      bool disable_emit, int16 operand_offset,\n                                      char *error_buf, uint32 error_buf_size)\n{\n    if (!wasm_loader_push_pop_frame_offset(ctx, pop_cnt, type_push, type_pop,\n                                           disable_emit, operand_offset,\n                                           error_buf, error_buf_size))\n        return false;\n    if (!wasm_loader_push_pop_frame_ref(ctx, pop_cnt, type_push, type_pop,\n                                        error_buf, error_buf_size))\n        return false;\n\n    return true;\n}",
        "func": "static bool\nwasm_loader_push_pop_frame_ref_offset(WASMLoaderContext *ctx, uint8 pop_cnt,\n                                      uint8 type_push, uint8 type_pop,\n                                      bool disable_emit, int16 operand_offset,\n                                      char *error_buf, uint32 error_buf_size)\n{\n    uint8 i;\n\n    for (i = 0; i < pop_cnt; i++) {\n        if (!wasm_loader_pop_frame_offset(ctx, type_pop, error_buf,\n                                          error_buf_size))\n            return false;\n\n        if (!wasm_loader_pop_frame_ref(ctx, type_pop, error_buf,\n                                       error_buf_size))\n            return false;\n    }\n\n    if (!wasm_loader_push_frame_offset(ctx, type_push, disable_emit,\n                                       operand_offset, error_buf,\n                                       error_buf_size))\n        return false;\n\n    if (!wasm_loader_push_frame_ref(ctx, type_push, error_buf, error_buf_size))\n        return false;\n\n    return true;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,12 +4,24 @@\n                                       bool disable_emit, int16 operand_offset,\n                                       char *error_buf, uint32 error_buf_size)\n {\n-    if (!wasm_loader_push_pop_frame_offset(ctx, pop_cnt, type_push, type_pop,\n-                                           disable_emit, operand_offset,\n-                                           error_buf, error_buf_size))\n+    uint8 i;\n+\n+    for (i = 0; i < pop_cnt; i++) {\n+        if (!wasm_loader_pop_frame_offset(ctx, type_pop, error_buf,\n+                                          error_buf_size))\n+            return false;\n+\n+        if (!wasm_loader_pop_frame_ref(ctx, type_pop, error_buf,\n+                                       error_buf_size))\n+            return false;\n+    }\n+\n+    if (!wasm_loader_push_frame_offset(ctx, type_push, disable_emit,\n+                                       operand_offset, error_buf,\n+                                       error_buf_size))\n         return false;\n-    if (!wasm_loader_push_pop_frame_ref(ctx, pop_cnt, type_push, type_pop,\n-                                        error_buf, error_buf_size))\n+\n+    if (!wasm_loader_push_frame_ref(ctx, type_push, error_buf, error_buf_size))\n         return false;\n \n     return true;",
        "diff_line_info": {
            "deleted_lines": [
                "    if (!wasm_loader_push_pop_frame_offset(ctx, pop_cnt, type_push, type_pop,",
                "                                           disable_emit, operand_offset,",
                "                                           error_buf, error_buf_size))",
                "    if (!wasm_loader_push_pop_frame_ref(ctx, pop_cnt, type_push, type_pop,",
                "                                        error_buf, error_buf_size))"
            ],
            "added_lines": [
                "    uint8 i;",
                "",
                "    for (i = 0; i < pop_cnt; i++) {",
                "        if (!wasm_loader_pop_frame_offset(ctx, type_pop, error_buf,",
                "                                          error_buf_size))",
                "            return false;",
                "",
                "        if (!wasm_loader_pop_frame_ref(ctx, type_pop, error_buf,",
                "                                       error_buf_size))",
                "            return false;",
                "    }",
                "",
                "    if (!wasm_loader_push_frame_offset(ctx, type_push, disable_emit,",
                "                                       operand_offset, error_buf,",
                "                                       error_buf_size))",
                "",
                "    if (!wasm_loader_push_frame_ref(ctx, type_push, error_buf, error_buf_size))"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-52284",
        "func_name": "bytecodealliance/wasm-micro-runtime/wasm_loader_push_pop_frame_ref_offset",
        "description": "Bytecode Alliance wasm-micro-runtime (aka WebAssembly Micro Runtime or WAMR) before 1.3.0 can have an \"double free or corruption\" error for a valid WebAssembly module because push_pop_frame_ref_offset is mishandled.",
        "git_url": "https://github.com/bytecodealliance/wasm-micro-runtime/commit/b2e668c08414c421718f73366c6c2222684eb828",
        "commit_title": "Fix loader push_pop_frame_ref_offset",
        "commit_text": "",
        "func_before": "static bool\nwasm_loader_push_pop_frame_ref_offset(WASMLoaderContext *ctx, uint8 pop_cnt,\n                                      uint8 type_push, uint8 type_pop,\n                                      bool disable_emit, int16 operand_offset,\n                                      char *error_buf, uint32 error_buf_size)\n{\n    if (!wasm_loader_push_pop_frame_offset(ctx, pop_cnt, type_push, type_pop,\n                                           disable_emit, operand_offset,\n                                           error_buf, error_buf_size))\n        return false;\n    if (!wasm_loader_push_pop_frame_ref(ctx, pop_cnt, type_push, type_pop,\n                                        error_buf, error_buf_size))\n        return false;\n\n    return true;\n}",
        "func": "static bool\nwasm_loader_push_pop_frame_ref_offset(WASMLoaderContext *ctx, uint8 pop_cnt,\n                                      uint8 type_push, uint8 type_pop,\n                                      bool disable_emit, int16 operand_offset,\n                                      char *error_buf, uint32 error_buf_size)\n{\n    uint8 i;\n\n    for (i = 0; i < pop_cnt; i++) {\n        if (!wasm_loader_pop_frame_offset(ctx, type_pop, error_buf,\n                                          error_buf_size))\n            return false;\n\n        if (!wasm_loader_pop_frame_ref(ctx, type_pop, error_buf,\n                                       error_buf_size))\n            return false;\n    }\n\n    if (!wasm_loader_push_frame_offset(ctx, type_push, disable_emit,\n                                       operand_offset, error_buf,\n                                       error_buf_size))\n        return false;\n\n    if (!wasm_loader_push_frame_ref(ctx, type_push, error_buf, error_buf_size))\n        return false;\n\n    return true;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,12 +4,24 @@\n                                       bool disable_emit, int16 operand_offset,\n                                       char *error_buf, uint32 error_buf_size)\n {\n-    if (!wasm_loader_push_pop_frame_offset(ctx, pop_cnt, type_push, type_pop,\n-                                           disable_emit, operand_offset,\n-                                           error_buf, error_buf_size))\n+    uint8 i;\n+\n+    for (i = 0; i < pop_cnt; i++) {\n+        if (!wasm_loader_pop_frame_offset(ctx, type_pop, error_buf,\n+                                          error_buf_size))\n+            return false;\n+\n+        if (!wasm_loader_pop_frame_ref(ctx, type_pop, error_buf,\n+                                       error_buf_size))\n+            return false;\n+    }\n+\n+    if (!wasm_loader_push_frame_offset(ctx, type_push, disable_emit,\n+                                       operand_offset, error_buf,\n+                                       error_buf_size))\n         return false;\n-    if (!wasm_loader_push_pop_frame_ref(ctx, pop_cnt, type_push, type_pop,\n-                                        error_buf, error_buf_size))\n+\n+    if (!wasm_loader_push_frame_ref(ctx, type_push, error_buf, error_buf_size))\n         return false;\n \n     return true;",
        "diff_line_info": {
            "deleted_lines": [
                "    if (!wasm_loader_push_pop_frame_offset(ctx, pop_cnt, type_push, type_pop,",
                "                                           disable_emit, operand_offset,",
                "                                           error_buf, error_buf_size))",
                "    if (!wasm_loader_push_pop_frame_ref(ctx, pop_cnt, type_push, type_pop,",
                "                                        error_buf, error_buf_size))"
            ],
            "added_lines": [
                "    uint8 i;",
                "",
                "    for (i = 0; i < pop_cnt; i++) {",
                "        if (!wasm_loader_pop_frame_offset(ctx, type_pop, error_buf,",
                "                                          error_buf_size))",
                "            return false;",
                "",
                "        if (!wasm_loader_pop_frame_ref(ctx, type_pop, error_buf,",
                "                                       error_buf_size))",
                "            return false;",
                "    }",
                "",
                "    if (!wasm_loader_push_frame_offset(ctx, type_push, disable_emit,",
                "                                       operand_offset, error_buf,",
                "                                       error_buf_size))",
                "",
                "    if (!wasm_loader_push_frame_ref(ctx, type_push, error_buf, error_buf_size))"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-20393",
        "func_name": "CESNET/libyang/yang_read_extcomplex_str",
        "description": "A double-free is present in libyang before v1.0-r1 in the function yyparse() when an empty description is used. Applications that use libyang to parse untrusted input yang files may be vulnerable to this flaw, which would cause a crash or potentially code execution.",
        "git_url": "https://github.com/CESNET/libyang/commit/d9feacc4a590d35dbc1af21caf9080008b4450ed",
        "commit_title": "yang parser BUGFIX double free",
        "commit_text": " Fixes #742",
        "func_before": "int\nyang_read_extcomplex_str(struct lys_module *module, struct lys_ext_instance_complex *ext, const char *arg_name,\n                         const char *parent_name, char *value, int parent_stmt, LY_STMT stmt)\n{\n    int c;\n    const char **str, ***p = NULL;\n    void *reallocated;\n    struct lyext_substmt *info;\n\n    c = 0;\n    if (stmt == LY_STMT_PREFIX && parent_stmt == LY_STMT_BELONGSTO) {\n        /* str contains no NULL value */\n        str = lys_ext_complex_get_substmt(LY_STMT_BELONGSTO, ext, &info);\n        if (info->cardinality < LY_STMT_CARD_SOME) {\n            str++;\n        } else {\n           /* get the index in the array to add new item */\n            p = (const char ***)str;\n            for (c = 0; p[0][c + 1]; c++);\n            str = p[1];\n        }\n        str[c] = lydict_insert_zc(module->ctx, value);\n    }  else {\n        str = lys_ext_complex_get_substmt(stmt, ext, &info);\n        if (!str) {\n            LOGVAL(module->ctx, LYE_INCHILDSTMT, LY_VLOG_NONE, NULL, arg_name, parent_name);\n            goto error;\n        }\n        if (info->cardinality < LY_STMT_CARD_SOME && *str) {\n            LOGVAL(module->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, arg_name, parent_name);\n            goto error;\n        }\n\n        if (info->cardinality >= LY_STMT_CARD_SOME) {\n            /* there can be multiple instances, str is actually const char *** */\n            p = (const char ***)str;\n            if (!p[0]) {\n                /* allocate initial array */\n                p[0] = calloc(2, sizeof(const char *));\n                LY_CHECK_ERR_GOTO(!p[0], LOGMEM(module->ctx), error);\n                if (stmt == LY_STMT_BELONGSTO) {\n                    /* allocate another array for the belongs-to's prefixes */\n                    p[1] = calloc(2, sizeof(const char *));\n                    LY_CHECK_ERR_GOTO(!p[1], LOGMEM(module->ctx), error);\n                } else if (stmt == LY_STMT_ARGUMENT) {\n                    /* allocate another array for the yin element */\n                    ((uint8_t **)p)[1] = calloc(2, sizeof(uint8_t));\n                    LY_CHECK_ERR_GOTO(!p[1], LOGMEM(module->ctx), error);\n                    /* default value of yin element */\n                    ((uint8_t *)p[1])[0] = 2;\n                }\n            } else {\n                /* get the index in the array to add new item */\n                for (c = 0; p[0][c]; c++);\n            }\n            str = p[0];\n        }\n\n        str[c] = lydict_insert_zc(module->ctx, value);\n        value = NULL;\n\n        if (c) {\n            /* enlarge the array(s) */\n            reallocated = realloc(p[0], (c + 2) * sizeof(const char *));\n            if (!reallocated) {\n                LOGMEM(module->ctx);\n                lydict_remove(module->ctx, p[0][c]);\n                p[0][c] = NULL;\n                return EXIT_FAILURE;\n            }\n            p[0] = reallocated;\n            p[0][c + 1] = NULL;\n\n            if (stmt == LY_STMT_BELONGSTO) {\n                /* enlarge the second belongs-to's array with prefixes */\n                reallocated = realloc(p[1], (c + 2) * sizeof(const char *));\n                if (!reallocated) {\n                    LOGMEM(module->ctx);\n                    lydict_remove(module->ctx, p[1][c]);\n                    p[1][c] = NULL;\n                    return EXIT_FAILURE;\n                }\n                p[1] = reallocated;\n                p[1][c + 1] = NULL;\n            } else if (stmt == LY_STMT_ARGUMENT) {\n                /* enlarge the second argument's array with yin element */\n                reallocated = realloc(p[1], (c + 2) * sizeof(uint8_t));\n                if (!reallocated) {\n                    LOGMEM(module->ctx);\n                    ((uint8_t *)p[1])[c] = 0;\n                    return EXIT_FAILURE;\n                }\n                p[1] = reallocated;\n                ((uint8_t *)p[1])[c + 1] = 0;\n            }\n        }\n    }\n\n    return EXIT_SUCCESS;\n\nerror:\n    free(value);\n    return EXIT_FAILURE;\n}",
        "func": "int\nyang_read_extcomplex_str(struct lys_module *module, struct lys_ext_instance_complex *ext, const char *arg_name,\n                         const char *parent_name, char **value, int parent_stmt, LY_STMT stmt)\n{\n    int c;\n    const char **str, ***p = NULL;\n    void *reallocated;\n    struct lyext_substmt *info;\n\n    c = 0;\n    if (stmt == LY_STMT_PREFIX && parent_stmt == LY_STMT_BELONGSTO) {\n        /* str contains no NULL value */\n        str = lys_ext_complex_get_substmt(LY_STMT_BELONGSTO, ext, &info);\n        if (info->cardinality < LY_STMT_CARD_SOME) {\n            str++;\n        } else {\n           /* get the index in the array to add new item */\n            p = (const char ***)str;\n            for (c = 0; p[0][c + 1]; c++);\n            str = p[1];\n        }\n        str[c] = lydict_insert_zc(module->ctx, *value);\n        *value = NULL;\n    }  else {\n        str = lys_ext_complex_get_substmt(stmt, ext, &info);\n        if (!str) {\n            LOGVAL(module->ctx, LYE_INCHILDSTMT, LY_VLOG_NONE, NULL, arg_name, parent_name);\n            goto error;\n        }\n        if (info->cardinality < LY_STMT_CARD_SOME && *str) {\n            LOGVAL(module->ctx, LYE_TOOMANY, LY_VLOG_NONE, NULL, arg_name, parent_name);\n            goto error;\n        }\n\n        if (info->cardinality >= LY_STMT_CARD_SOME) {\n            /* there can be multiple instances, str is actually const char *** */\n            p = (const char ***)str;\n            if (!p[0]) {\n                /* allocate initial array */\n                p[0] = calloc(2, sizeof(const char *));\n                LY_CHECK_ERR_GOTO(!p[0], LOGMEM(module->ctx), error);\n                if (stmt == LY_STMT_BELONGSTO) {\n                    /* allocate another array for the belongs-to's prefixes */\n                    p[1] = calloc(2, sizeof(const char *));\n                    LY_CHECK_ERR_GOTO(!p[1], LOGMEM(module->ctx), error);\n                } else if (stmt == LY_STMT_ARGUMENT) {\n                    /* allocate another array for the yin element */\n                    ((uint8_t **)p)[1] = calloc(2, sizeof(uint8_t));\n                    LY_CHECK_ERR_GOTO(!p[1], LOGMEM(module->ctx), error);\n                    /* default value of yin element */\n                    ((uint8_t *)p[1])[0] = 2;\n                }\n            } else {\n                /* get the index in the array to add new item */\n                for (c = 0; p[0][c]; c++);\n            }\n            str = p[0];\n        }\n\n        str[c] = lydict_insert_zc(module->ctx, *value);\n        *value = NULL;\n\n        if (c) {\n            /* enlarge the array(s) */\n            reallocated = realloc(p[0], (c + 2) * sizeof(const char *));\n            if (!reallocated) {\n                LOGMEM(module->ctx);\n                lydict_remove(module->ctx, p[0][c]);\n                p[0][c] = NULL;\n                return EXIT_FAILURE;\n            }\n            p[0] = reallocated;\n            p[0][c + 1] = NULL;\n\n            if (stmt == LY_STMT_BELONGSTO) {\n                /* enlarge the second belongs-to's array with prefixes */\n                reallocated = realloc(p[1], (c + 2) * sizeof(const char *));\n                if (!reallocated) {\n                    LOGMEM(module->ctx);\n                    lydict_remove(module->ctx, p[1][c]);\n                    p[1][c] = NULL;\n                    return EXIT_FAILURE;\n                }\n                p[1] = reallocated;\n                p[1][c + 1] = NULL;\n            } else if (stmt == LY_STMT_ARGUMENT) {\n                /* enlarge the second argument's array with yin element */\n                reallocated = realloc(p[1], (c + 2) * sizeof(uint8_t));\n                if (!reallocated) {\n                    LOGMEM(module->ctx);\n                    ((uint8_t *)p[1])[c] = 0;\n                    return EXIT_FAILURE;\n                }\n                p[1] = reallocated;\n                ((uint8_t *)p[1])[c + 1] = 0;\n            }\n        }\n    }\n\n    return EXIT_SUCCESS;\n\nerror:\n    free(*value);\n    *value = NULL;\n    return EXIT_FAILURE;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,6 @@\n int\n yang_read_extcomplex_str(struct lys_module *module, struct lys_ext_instance_complex *ext, const char *arg_name,\n-                         const char *parent_name, char *value, int parent_stmt, LY_STMT stmt)\n+                         const char *parent_name, char **value, int parent_stmt, LY_STMT stmt)\n {\n     int c;\n     const char **str, ***p = NULL;\n@@ -19,7 +19,8 @@\n             for (c = 0; p[0][c + 1]; c++);\n             str = p[1];\n         }\n-        str[c] = lydict_insert_zc(module->ctx, value);\n+        str[c] = lydict_insert_zc(module->ctx, *value);\n+        *value = NULL;\n     }  else {\n         str = lys_ext_complex_get_substmt(stmt, ext, &info);\n         if (!str) {\n@@ -56,8 +57,8 @@\n             str = p[0];\n         }\n \n-        str[c] = lydict_insert_zc(module->ctx, value);\n-        value = NULL;\n+        str[c] = lydict_insert_zc(module->ctx, *value);\n+        *value = NULL;\n \n         if (c) {\n             /* enlarge the array(s) */\n@@ -99,6 +100,7 @@\n     return EXIT_SUCCESS;\n \n error:\n-    free(value);\n+    free(*value);\n+    *value = NULL;\n     return EXIT_FAILURE;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "                         const char *parent_name, char *value, int parent_stmt, LY_STMT stmt)",
                "        str[c] = lydict_insert_zc(module->ctx, value);",
                "        str[c] = lydict_insert_zc(module->ctx, value);",
                "        value = NULL;",
                "    free(value);"
            ],
            "added_lines": [
                "                         const char *parent_name, char **value, int parent_stmt, LY_STMT stmt)",
                "        str[c] = lydict_insert_zc(module->ctx, *value);",
                "        *value = NULL;",
                "        str[c] = lydict_insert_zc(module->ctx, *value);",
                "        *value = NULL;",
                "    free(*value);",
                "    *value = NULL;"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-20397",
        "func_name": "CESNET/libyang/yyerror",
        "description": "A double-free is present in libyang before v1.0-r1 in the function yyparse() when an organization field is not terminated. Applications that use libyang to parse untrusted input yang files may be vulnerable to this flaw, which would cause a crash or potentially code execution.",
        "git_url": "https://github.com/CESNET/libyang/commit/88bd6c548ba79bce176cd875e9b56e7e0ef4d8d4",
        "commit_title": "yang parser BUGFIX double free",
        "commit_text": " Fixes #739",
        "func_before": "void\nyyerror(YYLTYPE *yylloc, void *scanner, struct yang_parameter *param, ...)\n{\n  free(*param->value);\n  if (yylloc->first_line != -1) {\n    if (*param->data_node && (*param->data_node) == (*param->actual_node)) {\n      LOGVAL(param->module->ctx, LYE_INSTMT, LY_VLOG_LYS, *param->data_node, yyget_text(scanner));\n    } else {\n      LOGVAL(param->module->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, yyget_text(scanner));\n    }\n  }\n}",
        "func": "void\nyyerror(YYLTYPE *yylloc, void *scanner, struct yang_parameter *param, ...)\n{\n  free(*param->value);\n  *param->value = NULL;\n  if (yylloc->first_line != -1) {\n    if (*param->data_node && (*param->data_node) == (*param->actual_node)) {\n      LOGVAL(param->module->ctx, LYE_INSTMT, LY_VLOG_LYS, *param->data_node, yyget_text(scanner));\n    } else {\n      LOGVAL(param->module->ctx, LYE_INSTMT, LY_VLOG_NONE, NULL, yyget_text(scanner));\n    }\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,6 +2,7 @@\n yyerror(YYLTYPE *yylloc, void *scanner, struct yang_parameter *param, ...)\n {\n   free(*param->value);\n+  *param->value = NULL;\n   if (yylloc->first_line != -1) {\n     if (*param->data_node && (*param->data_node) == (*param->actual_node)) {\n       LOGVAL(param->module->ctx, LYE_INSTMT, LY_VLOG_LYS, *param->data_node, yyget_text(scanner));",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "  *param->value = NULL;"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-8002",
        "func_name": "virglrenderer/vrend_renderer_resource_allocate_texture",
        "description": "A NULL pointer dereference in vrend_renderer.c in virglrenderer through 0.8.1 allows attackers to cause a denial of service via commands that attempt to launch a grid without previously providing a Compute Shader (CS).",
        "git_url": "https://cgit.freedesktop.org/virglrenderer/commit/?id=522b610a826f6de58c560cbb38fa8dfc65ae3c42",
        "commit_title": "The structure is allocated outside this function and also deleted there",
        "commit_text": "if texture creation failes or it is asserted that it doesn't fail for intermediate blitting textures. Therefore, don't free the struct inside this function when allocation fails.  Closes #154  ",
        "func_before": "static int vrend_renderer_resource_allocate_texture(struct vrend_resource *gr,\n                                                    void *image_oes)\n{\n   uint level;\n   GLenum internalformat, glformat, gltype;\n   enum virgl_formats format = gr->base.format;\n   struct vrend_texture *gt = (struct vrend_texture *)gr;\n   struct pipe_resource *pr = &gr->base;\n\n   if (pr->width0 == 0)\n      return EINVAL;\n\n   bool format_can_texture_storage = has_feature(feat_texture_storage) &&\n         (tex_conv_table[format].flags & VIRGL_TEXTURE_CAN_TEXTURE_STORAGE);\n\n   /* On GLES there is no support for glTexImage*DMultisample and\n    * BGRA surfaces are also unlikely to support glTexStorage2DMultisample\n    * so we try to emulate here\n    */\n   if (vrend_state.use_gles && pr->nr_samples > 0 && !format_can_texture_storage) {\n      VREND_DEBUG(dbg_tex, NULL, \"Apply VIRGL_BIND_PREFER_EMULATED_BGRA because GLES+MS+noTS\\n\");\n      gr->base.bind |= VIRGL_BIND_PREFER_EMULATED_BGRA;\n   }\n\n   if (image_oes && !has_feature(feat_egl_image_storage))\n      gr->base.bind &= ~VIRGL_BIND_PREFER_EMULATED_BGRA;\n\n#ifdef ENABLE_GBM_ALLOCATION\n   if (virgl_gbm_external_allocation_preferred(gr->base.bind) &&\n       !has_feature(feat_egl_image_storage))\n      gr->base.bind &= ~VIRGL_BIND_PREFER_EMULATED_BGRA;\n#endif\n\n   format = vrend_format_replace_emulated(gr->base.bind, gr->base.format);\n   format_can_texture_storage = has_feature(feat_texture_storage) &&\n        (tex_conv_table[format].flags & VIRGL_TEXTURE_CAN_TEXTURE_STORAGE);\n\n   if (format_can_texture_storage)\n      gr->storage_bits |= VREND_STORAGE_GL_IMMUTABLE;\n\n   if (!image_oes) {\n      vrend_resource_gbm_init(gr, format);\n      if (gr->gbm_bo && !has_bit(gr->storage_bits, VREND_STORAGE_EGL_IMAGE))\n         return 0;\n\n      image_oes = gr->egl_image;\n   }\n\n   gr->target = tgsitargettogltarget(pr->target, pr->nr_samples);\n   gr->storage_bits |= VREND_STORAGE_GL_TEXTURE;\n\n   /* ugly workaround for texture rectangle missing on GLES */\n   if (vrend_state.use_gles && gr->target == GL_TEXTURE_RECTANGLE_NV) {\n      /* for some guests this is the only usage of rect */\n      if (pr->width0 != 1 || pr->height0 != 1) {\n         report_gles_warn(NULL, GLES_WARN_TEXTURE_RECT);\n      }\n      gr->target = GL_TEXTURE_2D;\n   }\n\n   /* fallback for 1D textures */\n   if (vrend_state.use_gles && gr->target == GL_TEXTURE_1D) {\n      gr->target = GL_TEXTURE_2D;\n   }\n\n   /* fallback for 1D array textures */\n   if (vrend_state.use_gles && gr->target == GL_TEXTURE_1D_ARRAY) {\n      gr->target = GL_TEXTURE_2D_ARRAY;\n   }\n\n   glGenTextures(1, &gr->id);\n   glBindTexture(gr->target, gr->id);\n\n   debug_texture(__func__, gr);\n\n   if (image_oes) {\n      if (has_bit(gr->storage_bits, VREND_STORAGE_GL_IMMUTABLE) &&\n          has_feature(feat_egl_image_storage)) {\n         glEGLImageTargetTexStorageEXT(gr->target, (GLeglImageOES) image_oes, NULL);\n      } else if (has_feature(feat_egl_image_external)) {\n         gr->storage_bits &= ~VREND_STORAGE_GL_IMMUTABLE;\n         glEGLImageTargetTexture2DOES(gr->target, (GLeglImageOES) image_oes);\n      } else {\n         vrend_printf( \"missing GL_OES_EGL_image_external extensions\\n\");\n         glBindTexture(gr->target, 0);\n         FREE(gr);\n         return EINVAL;\n      }\n   } else {\n      internalformat = tex_conv_table[format].internalformat;\n      glformat = tex_conv_table[format].glformat;\n      gltype = tex_conv_table[format].gltype;\n\n      if (internalformat == 0) {\n         vrend_printf(\"unknown format is %d\\n\", pr->format);\n         glBindTexture(gr->target, 0);\n         FREE(gt);\n         return EINVAL;\n      }\n\n      if (pr->nr_samples > 0) {\n         if (format_can_texture_storage) {\n            if (gr->target == GL_TEXTURE_2D_MULTISAMPLE) {\n               glTexStorage2DMultisample(gr->target, pr->nr_samples,\n                                         internalformat, pr->width0, pr->height0,\n                                         GL_TRUE);\n            } else {\n               glTexStorage3DMultisample(gr->target, pr->nr_samples,\n                                         internalformat, pr->width0, pr->height0, pr->array_size,\n                                         GL_TRUE);\n            }\n         } else {\n            if (gr->target == GL_TEXTURE_2D_MULTISAMPLE) {\n               glTexImage2DMultisample(gr->target, pr->nr_samples,\n                                       internalformat, pr->width0, pr->height0,\n                                       GL_TRUE);\n            } else {\n               glTexImage3DMultisample(gr->target, pr->nr_samples,\n                                       internalformat, pr->width0, pr->height0, pr->array_size,\n                                       GL_TRUE);\n            }\n         }\n      } else if (gr->target == GL_TEXTURE_CUBE_MAP) {\n            int i;\n            if (format_can_texture_storage)\n               glTexStorage2D(GL_TEXTURE_CUBE_MAP, pr->last_level + 1, internalformat, pr->width0, pr->height0);\n            else {\n               for (i = 0; i < 6; i++) {\n                  GLenum ctarget = GL_TEXTURE_CUBE_MAP_POSITIVE_X + i;\n                  for (level = 0; level <= pr->last_level; level++) {\n                     unsigned mwidth = u_minify(pr->width0, level);\n                     unsigned mheight = u_minify(pr->height0, level);\n\n                     glTexImage2D(ctarget, level, internalformat, mwidth, mheight, 0, glformat,\n                                  gltype, NULL);\n                  }\n               }\n            }\n      } else if (gr->target == GL_TEXTURE_3D ||\n                 gr->target == GL_TEXTURE_2D_ARRAY ||\n                 gr->target == GL_TEXTURE_CUBE_MAP_ARRAY) {\n         if (format_can_texture_storage) {\n            unsigned depth_param = (gr->target == GL_TEXTURE_2D_ARRAY || gr->target == GL_TEXTURE_CUBE_MAP_ARRAY) ?\n                                      pr->array_size : pr->depth0;\n            glTexStorage3D(gr->target, pr->last_level + 1, internalformat, pr->width0, pr->height0, depth_param);\n         } else {\n            for (level = 0; level <= pr->last_level; level++) {\n               unsigned depth_param = (gr->target == GL_TEXTURE_2D_ARRAY || gr->target == GL_TEXTURE_CUBE_MAP_ARRAY) ?\n                                         pr->array_size : u_minify(pr->depth0, level);\n               unsigned mwidth = u_minify(pr->width0, level);\n               unsigned mheight = u_minify(pr->height0, level);\n               glTexImage3D(gr->target, level, internalformat, mwidth, mheight,\n                            depth_param, 0, glformat, gltype, NULL);\n            }\n         }\n      } else if (gr->target == GL_TEXTURE_1D && vrend_state.use_gles) {\n         report_gles_missing_func(NULL, \"glTexImage1D\");\n      } else if (gr->target == GL_TEXTURE_1D) {\n         if (format_can_texture_storage) {\n            glTexStorage1D(gr->target, pr->last_level + 1, internalformat, pr->width0);\n         } else {\n            for (level = 0; level <= pr->last_level; level++) {\n               unsigned mwidth = u_minify(pr->width0, level);\n               glTexImage1D(gr->target, level, internalformat, mwidth, 0,\n                            glformat, gltype, NULL);\n            }\n         }\n      } else {\n         if (format_can_texture_storage)\n            glTexStorage2D(gr->target, pr->last_level + 1, internalformat, pr->width0,\n                           gr->target == GL_TEXTURE_1D_ARRAY ? pr->array_size : pr->height0);\n         else {\n            for (level = 0; level <= pr->last_level; level++) {\n               unsigned mwidth = u_minify(pr->width0, level);\n               unsigned mheight = u_minify(pr->height0, level);\n               glTexImage2D(gr->target, level, internalformat, mwidth,\n                            gr->target == GL_TEXTURE_1D_ARRAY ? pr->array_size : mheight,\n                            0, glformat, gltype, NULL);\n            }\n         }\n      }\n   }\n\n   if (!format_can_texture_storage) {\n      glTexParameteri(gr->target, GL_TEXTURE_BASE_LEVEL, 0);\n      glTexParameteri(gr->target, GL_TEXTURE_MAX_LEVEL, pr->last_level);\n   }\n\n   glBindTexture(gr->target, 0);\n\n   if (image_oes && gr->gbm_bo) {\n#ifdef ENABLE_GBM_ALLOCATION\n      for (int i = 0; i < gbm_bo_get_plane_count(gr->gbm_bo) - 1; i++) {\n         gr->aux_plane_egl_image[i] =\n               virgl_egl_aux_plane_image_from_dmabuf(egl, gr->gbm_bo, i + 1);\n      }\n#endif\n   }\n\n   gt->state.max_lod = -1;\n   gt->cur_swizzle_r = gt->cur_swizzle_g = gt->cur_swizzle_b = gt->cur_swizzle_a = -1;\n   gt->cur_base = -1;\n   gt->cur_max = 10000;\n   return 0;\n}",
        "func": "static int vrend_renderer_resource_allocate_texture(struct vrend_resource *gr,\n                                                    void *image_oes)\n{\n   uint level;\n   GLenum internalformat, glformat, gltype;\n   enum virgl_formats format = gr->base.format;\n   struct vrend_texture *gt = (struct vrend_texture *)gr;\n   struct pipe_resource *pr = &gr->base;\n\n   if (pr->width0 == 0)\n      return EINVAL;\n\n   bool format_can_texture_storage = has_feature(feat_texture_storage) &&\n         (tex_conv_table[format].flags & VIRGL_TEXTURE_CAN_TEXTURE_STORAGE);\n\n   /* On GLES there is no support for glTexImage*DMultisample and\n    * BGRA surfaces are also unlikely to support glTexStorage2DMultisample\n    * so we try to emulate here\n    */\n   if (vrend_state.use_gles && pr->nr_samples > 0 && !format_can_texture_storage) {\n      VREND_DEBUG(dbg_tex, NULL, \"Apply VIRGL_BIND_PREFER_EMULATED_BGRA because GLES+MS+noTS\\n\");\n      gr->base.bind |= VIRGL_BIND_PREFER_EMULATED_BGRA;\n   }\n\n   if (image_oes && !has_feature(feat_egl_image_storage))\n      gr->base.bind &= ~VIRGL_BIND_PREFER_EMULATED_BGRA;\n\n#ifdef ENABLE_GBM_ALLOCATION\n   if (virgl_gbm_external_allocation_preferred(gr->base.bind) &&\n       !has_feature(feat_egl_image_storage))\n      gr->base.bind &= ~VIRGL_BIND_PREFER_EMULATED_BGRA;\n#endif\n\n   format = vrend_format_replace_emulated(gr->base.bind, gr->base.format);\n   format_can_texture_storage = has_feature(feat_texture_storage) &&\n        (tex_conv_table[format].flags & VIRGL_TEXTURE_CAN_TEXTURE_STORAGE);\n\n   if (format_can_texture_storage)\n      gr->storage_bits |= VREND_STORAGE_GL_IMMUTABLE;\n\n   if (!image_oes) {\n      vrend_resource_gbm_init(gr, format);\n      if (gr->gbm_bo && !has_bit(gr->storage_bits, VREND_STORAGE_EGL_IMAGE))\n         return 0;\n\n      image_oes = gr->egl_image;\n   }\n\n   gr->target = tgsitargettogltarget(pr->target, pr->nr_samples);\n   gr->storage_bits |= VREND_STORAGE_GL_TEXTURE;\n\n   /* ugly workaround for texture rectangle missing on GLES */\n   if (vrend_state.use_gles && gr->target == GL_TEXTURE_RECTANGLE_NV) {\n      /* for some guests this is the only usage of rect */\n      if (pr->width0 != 1 || pr->height0 != 1) {\n         report_gles_warn(NULL, GLES_WARN_TEXTURE_RECT);\n      }\n      gr->target = GL_TEXTURE_2D;\n   }\n\n   /* fallback for 1D textures */\n   if (vrend_state.use_gles && gr->target == GL_TEXTURE_1D) {\n      gr->target = GL_TEXTURE_2D;\n   }\n\n   /* fallback for 1D array textures */\n   if (vrend_state.use_gles && gr->target == GL_TEXTURE_1D_ARRAY) {\n      gr->target = GL_TEXTURE_2D_ARRAY;\n   }\n\n   glGenTextures(1, &gr->id);\n   glBindTexture(gr->target, gr->id);\n\n   debug_texture(__func__, gr);\n\n   if (image_oes) {\n      if (has_bit(gr->storage_bits, VREND_STORAGE_GL_IMMUTABLE) &&\n          has_feature(feat_egl_image_storage)) {\n         glEGLImageTargetTexStorageEXT(gr->target, (GLeglImageOES) image_oes, NULL);\n      } else if (has_feature(feat_egl_image_external)) {\n         gr->storage_bits &= ~VREND_STORAGE_GL_IMMUTABLE;\n         glEGLImageTargetTexture2DOES(gr->target, (GLeglImageOES) image_oes);\n      } else {\n         vrend_printf( \"missing GL_OES_EGL_image_external extensions\\n\");\n         glBindTexture(gr->target, 0);\n         return EINVAL;\n      }\n   } else {\n      internalformat = tex_conv_table[format].internalformat;\n      glformat = tex_conv_table[format].glformat;\n      gltype = tex_conv_table[format].gltype;\n\n      if (internalformat == 0) {\n         vrend_printf(\"unknown format is %d\\n\", pr->format);\n         glBindTexture(gr->target, 0);\n         return EINVAL;\n      }\n\n      if (pr->nr_samples > 0) {\n         if (format_can_texture_storage) {\n            if (gr->target == GL_TEXTURE_2D_MULTISAMPLE) {\n               glTexStorage2DMultisample(gr->target, pr->nr_samples,\n                                         internalformat, pr->width0, pr->height0,\n                                         GL_TRUE);\n            } else {\n               glTexStorage3DMultisample(gr->target, pr->nr_samples,\n                                         internalformat, pr->width0, pr->height0, pr->array_size,\n                                         GL_TRUE);\n            }\n         } else {\n            if (gr->target == GL_TEXTURE_2D_MULTISAMPLE) {\n               glTexImage2DMultisample(gr->target, pr->nr_samples,\n                                       internalformat, pr->width0, pr->height0,\n                                       GL_TRUE);\n            } else {\n               glTexImage3DMultisample(gr->target, pr->nr_samples,\n                                       internalformat, pr->width0, pr->height0, pr->array_size,\n                                       GL_TRUE);\n            }\n         }\n      } else if (gr->target == GL_TEXTURE_CUBE_MAP) {\n            int i;\n            if (format_can_texture_storage)\n               glTexStorage2D(GL_TEXTURE_CUBE_MAP, pr->last_level + 1, internalformat, pr->width0, pr->height0);\n            else {\n               for (i = 0; i < 6; i++) {\n                  GLenum ctarget = GL_TEXTURE_CUBE_MAP_POSITIVE_X + i;\n                  for (level = 0; level <= pr->last_level; level++) {\n                     unsigned mwidth = u_minify(pr->width0, level);\n                     unsigned mheight = u_minify(pr->height0, level);\n\n                     glTexImage2D(ctarget, level, internalformat, mwidth, mheight, 0, glformat,\n                                  gltype, NULL);\n                  }\n               }\n            }\n      } else if (gr->target == GL_TEXTURE_3D ||\n                 gr->target == GL_TEXTURE_2D_ARRAY ||\n                 gr->target == GL_TEXTURE_CUBE_MAP_ARRAY) {\n         if (format_can_texture_storage) {\n            unsigned depth_param = (gr->target == GL_TEXTURE_2D_ARRAY || gr->target == GL_TEXTURE_CUBE_MAP_ARRAY) ?\n                                      pr->array_size : pr->depth0;\n            glTexStorage3D(gr->target, pr->last_level + 1, internalformat, pr->width0, pr->height0, depth_param);\n         } else {\n            for (level = 0; level <= pr->last_level; level++) {\n               unsigned depth_param = (gr->target == GL_TEXTURE_2D_ARRAY || gr->target == GL_TEXTURE_CUBE_MAP_ARRAY) ?\n                                         pr->array_size : u_minify(pr->depth0, level);\n               unsigned mwidth = u_minify(pr->width0, level);\n               unsigned mheight = u_minify(pr->height0, level);\n               glTexImage3D(gr->target, level, internalformat, mwidth, mheight,\n                            depth_param, 0, glformat, gltype, NULL);\n            }\n         }\n      } else if (gr->target == GL_TEXTURE_1D && vrend_state.use_gles) {\n         report_gles_missing_func(NULL, \"glTexImage1D\");\n      } else if (gr->target == GL_TEXTURE_1D) {\n         if (format_can_texture_storage) {\n            glTexStorage1D(gr->target, pr->last_level + 1, internalformat, pr->width0);\n         } else {\n            for (level = 0; level <= pr->last_level; level++) {\n               unsigned mwidth = u_minify(pr->width0, level);\n               glTexImage1D(gr->target, level, internalformat, mwidth, 0,\n                            glformat, gltype, NULL);\n            }\n         }\n      } else {\n         if (format_can_texture_storage)\n            glTexStorage2D(gr->target, pr->last_level + 1, internalformat, pr->width0,\n                           gr->target == GL_TEXTURE_1D_ARRAY ? pr->array_size : pr->height0);\n         else {\n            for (level = 0; level <= pr->last_level; level++) {\n               unsigned mwidth = u_minify(pr->width0, level);\n               unsigned mheight = u_minify(pr->height0, level);\n               glTexImage2D(gr->target, level, internalformat, mwidth,\n                            gr->target == GL_TEXTURE_1D_ARRAY ? pr->array_size : mheight,\n                            0, glformat, gltype, NULL);\n            }\n         }\n      }\n   }\n\n   if (!format_can_texture_storage) {\n      glTexParameteri(gr->target, GL_TEXTURE_BASE_LEVEL, 0);\n      glTexParameteri(gr->target, GL_TEXTURE_MAX_LEVEL, pr->last_level);\n   }\n\n   glBindTexture(gr->target, 0);\n\n   if (image_oes && gr->gbm_bo) {\n#ifdef ENABLE_GBM_ALLOCATION\n      for (int i = 0; i < gbm_bo_get_plane_count(gr->gbm_bo) - 1; i++) {\n         gr->aux_plane_egl_image[i] =\n               virgl_egl_aux_plane_image_from_dmabuf(egl, gr->gbm_bo, i + 1);\n      }\n#endif\n   }\n\n   gt->state.max_lod = -1;\n   gt->cur_swizzle_r = gt->cur_swizzle_g = gt->cur_swizzle_b = gt->cur_swizzle_a = -1;\n   gt->cur_base = -1;\n   gt->cur_max = 10000;\n   return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -83,7 +83,6 @@\n       } else {\n          vrend_printf( \"missing GL_OES_EGL_image_external extensions\\n\");\n          glBindTexture(gr->target, 0);\n-         FREE(gr);\n          return EINVAL;\n       }\n    } else {\n@@ -94,7 +93,6 @@\n       if (internalformat == 0) {\n          vrend_printf(\"unknown format is %d\\n\", pr->format);\n          glBindTexture(gr->target, 0);\n-         FREE(gt);\n          return EINVAL;\n       }\n ",
        "diff_line_info": {
            "deleted_lines": [
                "         FREE(gr);",
                "         FREE(gt);"
            ],
            "added_lines": []
        }
    },
    {
        "cve_id": "CVE-2020-8002",
        "func_name": "virglrenderer/vrend_launch_grid",
        "description": "A NULL pointer dereference in vrend_renderer.c in virglrenderer through 0.8.1 allows attackers to cause a denial of service via commands that attempt to launch a grid without previously providing a Compute Shader (CS).",
        "git_url": "https://cgit.freedesktop.org/virglrenderer/commit/?id=63bcca251f093d83da7e290ab4bbd38ae69089b5",
        "commit_title": "Closes #155",
        "commit_text": " ",
        "func_before": "void vrend_launch_grid(struct vrend_context *ctx,\n                       UNUSED uint32_t *block,\n                       uint32_t *grid,\n                       uint32_t indirect_handle,\n                       uint32_t indirect_offset)\n{\n   bool new_program = false;\n   struct vrend_resource *indirect_res = NULL;\n\n   if (!has_feature(feat_compute_shader))\n      return;\n\n   if (ctx->sub->cs_shader_dirty) {\n      struct vrend_linked_shader_program *prog;\n      bool cs_dirty;\n\n      ctx->sub->cs_shader_dirty = false;\n\n      if (!ctx->sub->shaders[PIPE_SHADER_COMPUTE]) {\n         vrend_printf(\"dropping rendering due to missing shaders: %s\\n\", ctx->debug_name);\n         return;\n      }\n\n      vrend_shader_select(ctx, ctx->sub->shaders[PIPE_SHADER_COMPUTE], &cs_dirty);\n      if (!ctx->sub->shaders[PIPE_SHADER_COMPUTE]->current) {\n         vrend_printf( \"failure to compile shader variants: %s\\n\", ctx->debug_name);\n         return;\n      }\n      if (ctx->sub->shaders[PIPE_SHADER_COMPUTE]->current->id != (GLuint)ctx->sub->prog_ids[PIPE_SHADER_COMPUTE]) {\n         prog = lookup_cs_shader_program(ctx, ctx->sub->shaders[PIPE_SHADER_COMPUTE]->current->id);\n         if (!prog) {\n            prog = add_cs_shader_program(ctx, ctx->sub->shaders[PIPE_SHADER_COMPUTE]->current);\n            if (!prog)\n               return;\n         }\n      } else\n         prog = ctx->sub->prog;\n\n      if (ctx->sub->prog != prog) {\n         new_program = true;\n         ctx->sub->prog_ids[PIPE_SHADER_VERTEX] = -1;\n         ctx->sub->prog_ids[PIPE_SHADER_COMPUTE] = ctx->sub->shaders[PIPE_SHADER_COMPUTE]->current->id;\n         ctx->sub->prog = prog;\n         prog->ref_context = ctx->sub;\n      }\n      ctx->sub->shader_dirty = true;\n   }\n   vrend_use_program(ctx, ctx->sub->prog->id);\n\n   vrend_draw_bind_ubo_shader(ctx, PIPE_SHADER_COMPUTE, 0);\n   vrend_draw_bind_const_shader(ctx, PIPE_SHADER_COMPUTE, new_program);\n   vrend_draw_bind_samplers_shader(ctx, PIPE_SHADER_COMPUTE, 0);\n   vrend_draw_bind_images_shader(ctx, PIPE_SHADER_COMPUTE);\n   vrend_draw_bind_ssbo_shader(ctx, PIPE_SHADER_COMPUTE);\n   vrend_draw_bind_abo_shader(ctx);\n\n   if (indirect_handle) {\n      indirect_res = vrend_renderer_ctx_res_lookup(ctx, indirect_handle);\n      if (!indirect_res) {\n         report_context_error(ctx, VIRGL_ERROR_CTX_ILLEGAL_RESOURCE, indirect_handle);\n         return;\n      }\n   }\n\n   if (indirect_res)\n      glBindBuffer(GL_DISPATCH_INDIRECT_BUFFER, indirect_res->id);\n   else\n      glBindBuffer(GL_DISPATCH_INDIRECT_BUFFER, 0);\n\n   if (indirect_res) {\n      glDispatchComputeIndirect(indirect_offset);\n   } else {\n      glDispatchCompute(grid[0], grid[1], grid[2]);\n   }\n}",
        "func": "void vrend_launch_grid(struct vrend_context *ctx,\n                       UNUSED uint32_t *block,\n                       uint32_t *grid,\n                       uint32_t indirect_handle,\n                       uint32_t indirect_offset)\n{\n   bool new_program = false;\n   struct vrend_resource *indirect_res = NULL;\n\n   if (!has_feature(feat_compute_shader))\n      return;\n\n   if (ctx->sub->cs_shader_dirty) {\n      struct vrend_linked_shader_program *prog;\n      bool cs_dirty;\n\n      ctx->sub->cs_shader_dirty = false;\n\n      if (!ctx->sub->shaders[PIPE_SHADER_COMPUTE]) {\n         vrend_printf(\"dropping rendering due to missing shaders: %s\\n\", ctx->debug_name);\n         return;\n      }\n\n      vrend_shader_select(ctx, ctx->sub->shaders[PIPE_SHADER_COMPUTE], &cs_dirty);\n      if (!ctx->sub->shaders[PIPE_SHADER_COMPUTE]->current) {\n         vrend_printf( \"failure to compile shader variants: %s\\n\", ctx->debug_name);\n         return;\n      }\n      if (ctx->sub->shaders[PIPE_SHADER_COMPUTE]->current->id != (GLuint)ctx->sub->prog_ids[PIPE_SHADER_COMPUTE]) {\n         prog = lookup_cs_shader_program(ctx, ctx->sub->shaders[PIPE_SHADER_COMPUTE]->current->id);\n         if (!prog) {\n            prog = add_cs_shader_program(ctx, ctx->sub->shaders[PIPE_SHADER_COMPUTE]->current);\n            if (!prog)\n               return;\n         }\n      } else\n         prog = ctx->sub->prog;\n\n      if (ctx->sub->prog != prog) {\n         new_program = true;\n         ctx->sub->prog_ids[PIPE_SHADER_VERTEX] = -1;\n         ctx->sub->prog_ids[PIPE_SHADER_COMPUTE] = ctx->sub->shaders[PIPE_SHADER_COMPUTE]->current->id;\n         ctx->sub->prog = prog;\n         prog->ref_context = ctx->sub;\n      }\n      ctx->sub->shader_dirty = true;\n   }\n\n   if (!ctx->sub->prog) {\n      vrend_printf(\"%s: Skipping compute shader execution due to missing shaders: %s\\n\",\n                   __func__, ctx->debug_name);\n      return;\n   }\n\n   vrend_use_program(ctx, ctx->sub->prog->id);\n\n   vrend_draw_bind_ubo_shader(ctx, PIPE_SHADER_COMPUTE, 0);\n   vrend_draw_bind_const_shader(ctx, PIPE_SHADER_COMPUTE, new_program);\n   vrend_draw_bind_samplers_shader(ctx, PIPE_SHADER_COMPUTE, 0);\n   vrend_draw_bind_images_shader(ctx, PIPE_SHADER_COMPUTE);\n   vrend_draw_bind_ssbo_shader(ctx, PIPE_SHADER_COMPUTE);\n   vrend_draw_bind_abo_shader(ctx);\n\n   if (indirect_handle) {\n      indirect_res = vrend_renderer_ctx_res_lookup(ctx, indirect_handle);\n      if (!indirect_res) {\n         report_context_error(ctx, VIRGL_ERROR_CTX_ILLEGAL_RESOURCE, indirect_handle);\n         return;\n      }\n   }\n\n   if (indirect_res)\n      glBindBuffer(GL_DISPATCH_INDIRECT_BUFFER, indirect_res->id);\n   else\n      glBindBuffer(GL_DISPATCH_INDIRECT_BUFFER, 0);\n\n   if (indirect_res) {\n      glDispatchComputeIndirect(indirect_offset);\n   } else {\n      glDispatchCompute(grid[0], grid[1], grid[2]);\n   }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -45,6 +45,13 @@\n       }\n       ctx->sub->shader_dirty = true;\n    }\n+\n+   if (!ctx->sub->prog) {\n+      vrend_printf(\"%s: Skipping compute shader execution due to missing shaders: %s\\n\",\n+                   __func__, ctx->debug_name);\n+      return;\n+   }\n+\n    vrend_use_program(ctx, ctx->sub->prog->id);\n \n    vrend_draw_bind_ubo_shader(ctx, PIPE_SHADER_COMPUTE, 0);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "   if (!ctx->sub->prog) {",
                "      vrend_printf(\"%s: Skipping compute shader execution due to missing shaders: %s\\n\",",
                "                   __func__, ctx->debug_name);",
                "      return;",
                "   }",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2022-40304",
        "func_name": "GNOME/libxml2/xmlCreateEntity",
        "description": "An issue was discovered in libxml2 before 2.10.3. Certain invalid XML entity definitions can corrupt a hash table key, potentially leading to subsequent logic errors. In one case, a double-free can be provoked.",
        "git_url": "https://github.com/GNOME/libxml2/commit/1b41ec4e9433b05bb0376be4725804c54ef1d80b",
        "commit_title": "[CVE-2022-40304] Fix dict corruption caused by entity reference cycles",
        "commit_text": " When an entity reference cycle is detected, the entity content is cleared by setting its first byte to zero. But the entity content might be allocated from a dict. In this case, the dict entry becomes corrupted leading to all kinds of logic errors, including memory errors like double-frees.  Stop storing entity content, orig, ExternalID and SystemID in a dict. These values are unlikely to occur multiple times in a document, so they shouldn't have been stored in a dict in the first place.  Thanks to Ned Williamson and Nathan Wachholz working with Google Project Zero for the report!",
        "func_before": "static xmlEntityPtr\nxmlCreateEntity(xmlDictPtr dict, const xmlChar *name, int type,\n\t        const xmlChar *ExternalID, const xmlChar *SystemID,\n\t        const xmlChar *content) {\n    xmlEntityPtr ret;\n\n    ret = (xmlEntityPtr) xmlMalloc(sizeof(xmlEntity));\n    if (ret == NULL) {\n        xmlEntitiesErrMemory(\"xmlCreateEntity: malloc failed\");\n\treturn(NULL);\n    }\n    memset(ret, 0, sizeof(xmlEntity));\n    ret->type = XML_ENTITY_DECL;\n    ret->checked = 0;\n\n    /*\n     * fill the structure.\n     */\n    ret->etype = (xmlEntityType) type;\n    if (dict == NULL) {\n\tret->name = xmlStrdup(name);\n\tif (ExternalID != NULL)\n\t    ret->ExternalID = xmlStrdup(ExternalID);\n\tif (SystemID != NULL)\n\t    ret->SystemID = xmlStrdup(SystemID);\n    } else {\n        ret->name = xmlDictLookup(dict, name, -1);\n\tif (ExternalID != NULL)\n\t    ret->ExternalID = xmlDictLookup(dict, ExternalID, -1);\n\tif (SystemID != NULL)\n\t    ret->SystemID = xmlDictLookup(dict, SystemID, -1);\n    }\n    if (content != NULL) {\n        ret->length = xmlStrlen(content);\n\tif ((dict != NULL) && (ret->length < 5))\n\t    ret->content = (xmlChar *)\n\t                   xmlDictLookup(dict, content, ret->length);\n\telse\n\t    ret->content = xmlStrndup(content, ret->length);\n     } else {\n        ret->length = 0;\n        ret->content = NULL;\n    }\n    ret->URI = NULL; /* to be computed by the layer knowing\n\t\t\tthe defining entity */\n    ret->orig = NULL;\n    ret->owner = 0;\n\n    return(ret);\n}",
        "func": "static xmlEntityPtr\nxmlCreateEntity(xmlDictPtr dict, const xmlChar *name, int type,\n\t        const xmlChar *ExternalID, const xmlChar *SystemID,\n\t        const xmlChar *content) {\n    xmlEntityPtr ret;\n\n    ret = (xmlEntityPtr) xmlMalloc(sizeof(xmlEntity));\n    if (ret == NULL) {\n        xmlEntitiesErrMemory(\"xmlCreateEntity: malloc failed\");\n\treturn(NULL);\n    }\n    memset(ret, 0, sizeof(xmlEntity));\n    ret->type = XML_ENTITY_DECL;\n    ret->checked = 0;\n\n    /*\n     * fill the structure.\n     */\n    ret->etype = (xmlEntityType) type;\n    if (dict == NULL) {\n\tret->name = xmlStrdup(name);\n\tif (ExternalID != NULL)\n\t    ret->ExternalID = xmlStrdup(ExternalID);\n\tif (SystemID != NULL)\n\t    ret->SystemID = xmlStrdup(SystemID);\n    } else {\n        ret->name = xmlDictLookup(dict, name, -1);\n\tret->ExternalID = xmlStrdup(ExternalID);\n\tret->SystemID = xmlStrdup(SystemID);\n    }\n    if (content != NULL) {\n        ret->length = xmlStrlen(content);\n\tret->content = xmlStrndup(content, ret->length);\n     } else {\n        ret->length = 0;\n        ret->content = NULL;\n    }\n    ret->URI = NULL; /* to be computed by the layer knowing\n\t\t\tthe defining entity */\n    ret->orig = NULL;\n    ret->owner = 0;\n\n    return(ret);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -25,18 +25,12 @@\n \t    ret->SystemID = xmlStrdup(SystemID);\n     } else {\n         ret->name = xmlDictLookup(dict, name, -1);\n-\tif (ExternalID != NULL)\n-\t    ret->ExternalID = xmlDictLookup(dict, ExternalID, -1);\n-\tif (SystemID != NULL)\n-\t    ret->SystemID = xmlDictLookup(dict, SystemID, -1);\n+\tret->ExternalID = xmlStrdup(ExternalID);\n+\tret->SystemID = xmlStrdup(SystemID);\n     }\n     if (content != NULL) {\n         ret->length = xmlStrlen(content);\n-\tif ((dict != NULL) && (ret->length < 5))\n-\t    ret->content = (xmlChar *)\n-\t                   xmlDictLookup(dict, content, ret->length);\n-\telse\n-\t    ret->content = xmlStrndup(content, ret->length);\n+\tret->content = xmlStrndup(content, ret->length);\n      } else {\n         ret->length = 0;\n         ret->content = NULL;",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (ExternalID != NULL)",
                "\t    ret->ExternalID = xmlDictLookup(dict, ExternalID, -1);",
                "\tif (SystemID != NULL)",
                "\t    ret->SystemID = xmlDictLookup(dict, SystemID, -1);",
                "\tif ((dict != NULL) && (ret->length < 5))",
                "\t    ret->content = (xmlChar *)",
                "\t                   xmlDictLookup(dict, content, ret->length);",
                "\telse",
                "\t    ret->content = xmlStrndup(content, ret->length);"
            ],
            "added_lines": [
                "\tret->ExternalID = xmlStrdup(ExternalID);",
                "\tret->SystemID = xmlStrdup(SystemID);",
                "\tret->content = xmlStrndup(content, ret->length);"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-40304",
        "func_name": "GNOME/libxml2/xmlFreeEntity",
        "description": "An issue was discovered in libxml2 before 2.10.3. Certain invalid XML entity definitions can corrupt a hash table key, potentially leading to subsequent logic errors. In one case, a double-free can be provoked.",
        "git_url": "https://github.com/GNOME/libxml2/commit/1b41ec4e9433b05bb0376be4725804c54ef1d80b",
        "commit_title": "[CVE-2022-40304] Fix dict corruption caused by entity reference cycles",
        "commit_text": " When an entity reference cycle is detected, the entity content is cleared by setting its first byte to zero. But the entity content might be allocated from a dict. In this case, the dict entry becomes corrupted leading to all kinds of logic errors, including memory errors like double-frees.  Stop storing entity content, orig, ExternalID and SystemID in a dict. These values are unlikely to occur multiple times in a document, so they shouldn't have been stored in a dict in the first place.  Thanks to Ned Williamson and Nathan Wachholz working with Google Project Zero for the report!",
        "func_before": "static void\nxmlFreeEntity(xmlEntityPtr entity)\n{\n    xmlDictPtr dict = NULL;\n\n    if (entity == NULL)\n        return;\n\n    if (entity->doc != NULL)\n        dict = entity->doc->dict;\n\n\n    if ((entity->children) && (entity->owner == 1) &&\n        (entity == (xmlEntityPtr) entity->children->parent))\n        xmlFreeNodeList(entity->children);\n    if (dict != NULL) {\n        if ((entity->name != NULL) && (!xmlDictOwns(dict, entity->name)))\n            xmlFree((char *) entity->name);\n        if ((entity->ExternalID != NULL) &&\n\t    (!xmlDictOwns(dict, entity->ExternalID)))\n            xmlFree((char *) entity->ExternalID);\n        if ((entity->SystemID != NULL) &&\n\t    (!xmlDictOwns(dict, entity->SystemID)))\n            xmlFree((char *) entity->SystemID);\n        if ((entity->URI != NULL) && (!xmlDictOwns(dict, entity->URI)))\n            xmlFree((char *) entity->URI);\n        if ((entity->content != NULL)\n            && (!xmlDictOwns(dict, entity->content)))\n            xmlFree((char *) entity->content);\n        if ((entity->orig != NULL) && (!xmlDictOwns(dict, entity->orig)))\n            xmlFree((char *) entity->orig);\n    } else {\n        if (entity->name != NULL)\n            xmlFree((char *) entity->name);\n        if (entity->ExternalID != NULL)\n            xmlFree((char *) entity->ExternalID);\n        if (entity->SystemID != NULL)\n            xmlFree((char *) entity->SystemID);\n        if (entity->URI != NULL)\n            xmlFree((char *) entity->URI);\n        if (entity->content != NULL)\n            xmlFree((char *) entity->content);\n        if (entity->orig != NULL)\n            xmlFree((char *) entity->orig);\n    }\n    xmlFree(entity);\n}",
        "func": "static void\nxmlFreeEntity(xmlEntityPtr entity)\n{\n    xmlDictPtr dict = NULL;\n\n    if (entity == NULL)\n        return;\n\n    if (entity->doc != NULL)\n        dict = entity->doc->dict;\n\n\n    if ((entity->children) && (entity->owner == 1) &&\n        (entity == (xmlEntityPtr) entity->children->parent))\n        xmlFreeNodeList(entity->children);\n    if ((entity->name != NULL) &&\n        ((dict == NULL) || (!xmlDictOwns(dict, entity->name))))\n        xmlFree((char *) entity->name);\n    if (entity->ExternalID != NULL)\n        xmlFree((char *) entity->ExternalID);\n    if (entity->SystemID != NULL)\n        xmlFree((char *) entity->SystemID);\n    if (entity->URI != NULL)\n        xmlFree((char *) entity->URI);\n    if (entity->content != NULL)\n        xmlFree((char *) entity->content);\n    if (entity->orig != NULL)\n        xmlFree((char *) entity->orig);\n    xmlFree(entity);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -13,35 +13,18 @@\n     if ((entity->children) && (entity->owner == 1) &&\n         (entity == (xmlEntityPtr) entity->children->parent))\n         xmlFreeNodeList(entity->children);\n-    if (dict != NULL) {\n-        if ((entity->name != NULL) && (!xmlDictOwns(dict, entity->name)))\n-            xmlFree((char *) entity->name);\n-        if ((entity->ExternalID != NULL) &&\n-\t    (!xmlDictOwns(dict, entity->ExternalID)))\n-            xmlFree((char *) entity->ExternalID);\n-        if ((entity->SystemID != NULL) &&\n-\t    (!xmlDictOwns(dict, entity->SystemID)))\n-            xmlFree((char *) entity->SystemID);\n-        if ((entity->URI != NULL) && (!xmlDictOwns(dict, entity->URI)))\n-            xmlFree((char *) entity->URI);\n-        if ((entity->content != NULL)\n-            && (!xmlDictOwns(dict, entity->content)))\n-            xmlFree((char *) entity->content);\n-        if ((entity->orig != NULL) && (!xmlDictOwns(dict, entity->orig)))\n-            xmlFree((char *) entity->orig);\n-    } else {\n-        if (entity->name != NULL)\n-            xmlFree((char *) entity->name);\n-        if (entity->ExternalID != NULL)\n-            xmlFree((char *) entity->ExternalID);\n-        if (entity->SystemID != NULL)\n-            xmlFree((char *) entity->SystemID);\n-        if (entity->URI != NULL)\n-            xmlFree((char *) entity->URI);\n-        if (entity->content != NULL)\n-            xmlFree((char *) entity->content);\n-        if (entity->orig != NULL)\n-            xmlFree((char *) entity->orig);\n-    }\n+    if ((entity->name != NULL) &&\n+        ((dict == NULL) || (!xmlDictOwns(dict, entity->name))))\n+        xmlFree((char *) entity->name);\n+    if (entity->ExternalID != NULL)\n+        xmlFree((char *) entity->ExternalID);\n+    if (entity->SystemID != NULL)\n+        xmlFree((char *) entity->SystemID);\n+    if (entity->URI != NULL)\n+        xmlFree((char *) entity->URI);\n+    if (entity->content != NULL)\n+        xmlFree((char *) entity->content);\n+    if (entity->orig != NULL)\n+        xmlFree((char *) entity->orig);\n     xmlFree(entity);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    if (dict != NULL) {",
                "        if ((entity->name != NULL) && (!xmlDictOwns(dict, entity->name)))",
                "            xmlFree((char *) entity->name);",
                "        if ((entity->ExternalID != NULL) &&",
                "\t    (!xmlDictOwns(dict, entity->ExternalID)))",
                "            xmlFree((char *) entity->ExternalID);",
                "        if ((entity->SystemID != NULL) &&",
                "\t    (!xmlDictOwns(dict, entity->SystemID)))",
                "            xmlFree((char *) entity->SystemID);",
                "        if ((entity->URI != NULL) && (!xmlDictOwns(dict, entity->URI)))",
                "            xmlFree((char *) entity->URI);",
                "        if ((entity->content != NULL)",
                "            && (!xmlDictOwns(dict, entity->content)))",
                "            xmlFree((char *) entity->content);",
                "        if ((entity->orig != NULL) && (!xmlDictOwns(dict, entity->orig)))",
                "            xmlFree((char *) entity->orig);",
                "    } else {",
                "        if (entity->name != NULL)",
                "            xmlFree((char *) entity->name);",
                "        if (entity->ExternalID != NULL)",
                "            xmlFree((char *) entity->ExternalID);",
                "        if (entity->SystemID != NULL)",
                "            xmlFree((char *) entity->SystemID);",
                "        if (entity->URI != NULL)",
                "            xmlFree((char *) entity->URI);",
                "        if (entity->content != NULL)",
                "            xmlFree((char *) entity->content);",
                "        if (entity->orig != NULL)",
                "            xmlFree((char *) entity->orig);",
                "    }"
            ],
            "added_lines": [
                "    if ((entity->name != NULL) &&",
                "        ((dict == NULL) || (!xmlDictOwns(dict, entity->name))))",
                "        xmlFree((char *) entity->name);",
                "    if (entity->ExternalID != NULL)",
                "        xmlFree((char *) entity->ExternalID);",
                "    if (entity->SystemID != NULL)",
                "        xmlFree((char *) entity->SystemID);",
                "    if (entity->URI != NULL)",
                "        xmlFree((char *) entity->URI);",
                "    if (entity->content != NULL)",
                "        xmlFree((char *) entity->content);",
                "    if (entity->orig != NULL)",
                "        xmlFree((char *) entity->orig);"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-27153",
        "func_name": "bluez/bt_att_cancel",
        "description": "In BlueZ before 5.55, a double free was found in the gatttool disconnect_cb() routine from shared/att.c. A remote attacker could potentially cause a denial of service or code execution, during service discovery, due to a redundant disconnect MGMT event.",
        "git_url": "https://github.com/bluez/bluez/commit/1cd644db8c23a2f530ddb93cebed7dacc5f5721a",
        "commit_title": "shared/att: Fix possible crash on disconnect",
        "commit_text": " If there are pending request while disconnecting they would be notified but clients may endup being freed in the proccess which will then be calling bt_att_cancel to cancal its requests causing the following trace:  Invalid read of size 4    at 0x1D894C: enable_ccc_callback (gatt-client.c:1627)    by 0x1D247B: disc_att_send_op (att.c:417)    by 0x1CCC17: queue_remove_all (queue.c:354)    by 0x1D47B7: disconnect_cb (att.c:635)    by 0x1E0707: watch_callback (io-glib.c:170)    by 0x48E963B: g_main_context_dispatch (in /usr/lib/libglib-2.0.so.0.6400.4)    by 0x48E9AC7: ??? (in /usr/lib/libglib-2.0.so.0.6400.4)    by 0x48E9ECF: g_main_loop_run (in /usr/lib/libglib-2.0.so.0.6400.4)    by 0x1E0E97: mainloop_run (mainloop-glib.c:79)    by 0x1E13B3: mainloop_run_with_signal (mainloop-notify.c:201)    by 0x12BC3B: main (main.c:770)  Address 0x7d40a28 is 24 bytes inside a block of size 32 free'd    at 0x484A2E0: free (vg_replace_malloc.c:540)    by 0x1CCC17: queue_remove_all (queue.c:354)    by 0x1CCC83: queue_destroy (queue.c:73)    by 0x1D7DD7: bt_gatt_client_free (gatt-client.c:2209)    by 0x16497B: batt_free (battery.c:77)    by 0x16497B: batt_remove (battery.c:286)    by 0x1A0013: service_remove (service.c:176)    by 0x1A9B7B: device_remove_gatt_service (device.c:3691)    by 0x1A9B7B: gatt_service_removed (device.c:3805)    by 0x1CC90B: queue_foreach (queue.c:220)    by 0x1DE27B: notify_service_changed.isra.0.part.0 (gatt-db.c:369)    by 0x1DE387: notify_service_changed (gatt-db.c:361)    by 0x1DE387: gatt_db_service_destroy (gatt-db.c:385)    by 0x1DE3EF: gatt_db_remove_service (gatt-db.c:519)    by 0x1D674F: discovery_op_complete (gatt-client.c:388)    by 0x1D6877: discover_primary_cb (gatt-client.c:1260)    by 0x1E220B: discovery_op_complete (gatt-helpers.c:628)    by 0x1E249B: read_by_grp_type_cb (gatt-helpers.c:730)    by 0x1D247B: disc_att_send_op (att.c:417)    by 0x1CCC17: queue_remove_all (queue.c:354)    by 0x1D47B7: disconnect_cb (att.c:635)",
        "func_before": "bool bt_att_cancel(struct bt_att *att, unsigned int id)\n{\n\tconst struct queue_entry *entry;\n\tstruct att_send_op *op;\n\n\tif (!att || !id)\n\t\treturn false;\n\n\t/* Lookuo request on each channel first */\n\tfor (entry = queue_get_entries(att->chans); entry;\n\t\t\t\t\t\tentry = entry->next) {\n\t\tstruct bt_att_chan *chan = entry->data;\n\n\t\tif (bt_att_chan_cancel(chan, id))\n\t\t\treturn true;\n\t}\n\n\top = queue_remove_if(att->req_queue, match_op_id, UINT_TO_PTR(id));\n\tif (op)\n\t\tgoto done;\n\n\top = queue_remove_if(att->ind_queue, match_op_id, UINT_TO_PTR(id));\n\tif (op)\n\t\tgoto done;\n\n\top = queue_remove_if(att->write_queue, match_op_id, UINT_TO_PTR(id));\n\tif (op)\n\t\tgoto done;\n\n\tif (!op)\n\t\treturn false;\n\ndone:\n\tdestroy_att_send_op(op);\n\n\twakeup_writer(att);\n\n\treturn true;\n}",
        "func": "bool bt_att_cancel(struct bt_att *att, unsigned int id)\n{\n\tconst struct queue_entry *entry;\n\tstruct att_send_op *op;\n\n\tif (!att || !id)\n\t\treturn false;\n\n\t/* Lookuo request on each channel first */\n\tfor (entry = queue_get_entries(att->chans); entry;\n\t\t\t\t\t\tentry = entry->next) {\n\t\tstruct bt_att_chan *chan = entry->data;\n\n\t\tif (bt_att_chan_cancel(chan, id))\n\t\t\treturn true;\n\t}\n\n\tif (att->in_disc)\n\t\treturn bt_att_disc_cancel(att, id);\n\n\top = queue_remove_if(att->req_queue, match_op_id, UINT_TO_PTR(id));\n\tif (op)\n\t\tgoto done;\n\n\top = queue_remove_if(att->ind_queue, match_op_id, UINT_TO_PTR(id));\n\tif (op)\n\t\tgoto done;\n\n\top = queue_remove_if(att->write_queue, match_op_id, UINT_TO_PTR(id));\n\tif (op)\n\t\tgoto done;\n\n\tif (!op)\n\t\treturn false;\n\ndone:\n\tdestroy_att_send_op(op);\n\n\twakeup_writer(att);\n\n\treturn true;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -14,6 +14,9 @@\n \t\tif (bt_att_chan_cancel(chan, id))\n \t\t\treturn true;\n \t}\n+\n+\tif (att->in_disc)\n+\t\treturn bt_att_disc_cancel(att, id);\n \n \top = queue_remove_if(att->req_queue, match_op_id, UINT_TO_PTR(id));\n \tif (op)",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "\tif (att->in_disc)",
                "\t\treturn bt_att_disc_cancel(att, id);"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-27153",
        "func_name": "bluez/disconnect_cb",
        "description": "In BlueZ before 5.55, a double free was found in the gatttool disconnect_cb() routine from shared/att.c. A remote attacker could potentially cause a denial of service or code execution, during service discovery, due to a redundant disconnect MGMT event.",
        "git_url": "https://github.com/bluez/bluez/commit/1cd644db8c23a2f530ddb93cebed7dacc5f5721a",
        "commit_title": "shared/att: Fix possible crash on disconnect",
        "commit_text": " If there are pending request while disconnecting they would be notified but clients may endup being freed in the proccess which will then be calling bt_att_cancel to cancal its requests causing the following trace:  Invalid read of size 4    at 0x1D894C: enable_ccc_callback (gatt-client.c:1627)    by 0x1D247B: disc_att_send_op (att.c:417)    by 0x1CCC17: queue_remove_all (queue.c:354)    by 0x1D47B7: disconnect_cb (att.c:635)    by 0x1E0707: watch_callback (io-glib.c:170)    by 0x48E963B: g_main_context_dispatch (in /usr/lib/libglib-2.0.so.0.6400.4)    by 0x48E9AC7: ??? (in /usr/lib/libglib-2.0.so.0.6400.4)    by 0x48E9ECF: g_main_loop_run (in /usr/lib/libglib-2.0.so.0.6400.4)    by 0x1E0E97: mainloop_run (mainloop-glib.c:79)    by 0x1E13B3: mainloop_run_with_signal (mainloop-notify.c:201)    by 0x12BC3B: main (main.c:770)  Address 0x7d40a28 is 24 bytes inside a block of size 32 free'd    at 0x484A2E0: free (vg_replace_malloc.c:540)    by 0x1CCC17: queue_remove_all (queue.c:354)    by 0x1CCC83: queue_destroy (queue.c:73)    by 0x1D7DD7: bt_gatt_client_free (gatt-client.c:2209)    by 0x16497B: batt_free (battery.c:77)    by 0x16497B: batt_remove (battery.c:286)    by 0x1A0013: service_remove (service.c:176)    by 0x1A9B7B: device_remove_gatt_service (device.c:3691)    by 0x1A9B7B: gatt_service_removed (device.c:3805)    by 0x1CC90B: queue_foreach (queue.c:220)    by 0x1DE27B: notify_service_changed.isra.0.part.0 (gatt-db.c:369)    by 0x1DE387: notify_service_changed (gatt-db.c:361)    by 0x1DE387: gatt_db_service_destroy (gatt-db.c:385)    by 0x1DE3EF: gatt_db_remove_service (gatt-db.c:519)    by 0x1D674F: discovery_op_complete (gatt-client.c:388)    by 0x1D6877: discover_primary_cb (gatt-client.c:1260)    by 0x1E220B: discovery_op_complete (gatt-helpers.c:628)    by 0x1E249B: read_by_grp_type_cb (gatt-helpers.c:730)    by 0x1D247B: disc_att_send_op (att.c:417)    by 0x1CCC17: queue_remove_all (queue.c:354)    by 0x1D47B7: disconnect_cb (att.c:635)",
        "func_before": "static bool disconnect_cb(struct io *io, void *user_data)\n{\n\tstruct bt_att_chan *chan = user_data;\n\tstruct bt_att *att = chan->att;\n\tint err;\n\tsocklen_t len;\n\n\tlen = sizeof(err);\n\n\tif (getsockopt(chan->fd, SOL_SOCKET, SO_ERROR, &err, &len) < 0) {\n\t\tutil_debug(chan->att->debug_callback, chan->att->debug_data,\n\t\t\t\t\t\"(chan %p) Failed to obtain disconnect\"\n\t\t\t\t\t\" error: %s\", chan, strerror(errno));\n\t\terr = 0;\n\t}\n\n\tutil_debug(chan->att->debug_callback, chan->att->debug_data,\n\t\t\t\t\t\"Channel %p disconnected: %s\",\n\t\t\t\t\tchan, strerror(err));\n\n\t/* Dettach channel */\n\tqueue_remove(att->chans, chan);\n\n\t/* Notify request callbacks */\n\tqueue_remove_all(att->req_queue, NULL, NULL, disc_att_send_op);\n\tqueue_remove_all(att->ind_queue, NULL, NULL, disc_att_send_op);\n\tqueue_remove_all(att->write_queue, NULL, NULL, disc_att_send_op);\n\n\tif (chan->pending_req) {\n\t\tdisc_att_send_op(chan->pending_req);\n\t\tchan->pending_req = NULL;\n\t}\n\n\tif (chan->pending_ind) {\n\t\tdisc_att_send_op(chan->pending_ind);\n\t\tchan->pending_ind = NULL;\n\t}\n\n\tbt_att_chan_free(chan);\n\n\t/* Don't run disconnect callback if there are channels left */\n\tif (!queue_isempty(att->chans))\n\t\treturn false;\n\n\tbt_att_ref(att);\n\n\tqueue_foreach(att->disconn_list, disconn_handler, INT_TO_PTR(err));\n\n\tbt_att_unregister_all(att);\n\tbt_att_unref(att);\n\n\treturn false;\n}",
        "func": "static bool disconnect_cb(struct io *io, void *user_data)\n{\n\tstruct bt_att_chan *chan = user_data;\n\tstruct bt_att *att = chan->att;\n\tint err;\n\tsocklen_t len;\n\n\tlen = sizeof(err);\n\n\tif (getsockopt(chan->fd, SOL_SOCKET, SO_ERROR, &err, &len) < 0) {\n\t\tutil_debug(chan->att->debug_callback, chan->att->debug_data,\n\t\t\t\t\t\"(chan %p) Failed to obtain disconnect\"\n\t\t\t\t\t\" error: %s\", chan, strerror(errno));\n\t\terr = 0;\n\t}\n\n\tutil_debug(chan->att->debug_callback, chan->att->debug_data,\n\t\t\t\t\t\"Channel %p disconnected: %s\",\n\t\t\t\t\tchan, strerror(err));\n\n\t/* Dettach channel */\n\tqueue_remove(att->chans, chan);\n\n\tif (chan->pending_req) {\n\t\tdisc_att_send_op(chan->pending_req);\n\t\tchan->pending_req = NULL;\n\t}\n\n\tif (chan->pending_ind) {\n\t\tdisc_att_send_op(chan->pending_ind);\n\t\tchan->pending_ind = NULL;\n\t}\n\n\tbt_att_chan_free(chan);\n\n\t/* Don't run disconnect callback if there are channels left */\n\tif (!queue_isempty(att->chans))\n\t\treturn false;\n\n\tbt_att_ref(att);\n\n\tatt->in_disc = true;\n\n\t/* Notify request callbacks */\n\tqueue_remove_all(att->req_queue, NULL, NULL, disc_att_send_op);\n\tqueue_remove_all(att->ind_queue, NULL, NULL, disc_att_send_op);\n\tqueue_remove_all(att->write_queue, NULL, NULL, disc_att_send_op);\n\n\tatt->in_disc = false;\n\n\tqueue_foreach(att->disconn_list, disconn_handler, INT_TO_PTR(err));\n\n\tbt_att_unregister_all(att);\n\tbt_att_unref(att);\n\n\treturn false;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -21,11 +21,6 @@\n \t/* Dettach channel */\n \tqueue_remove(att->chans, chan);\n \n-\t/* Notify request callbacks */\n-\tqueue_remove_all(att->req_queue, NULL, NULL, disc_att_send_op);\n-\tqueue_remove_all(att->ind_queue, NULL, NULL, disc_att_send_op);\n-\tqueue_remove_all(att->write_queue, NULL, NULL, disc_att_send_op);\n-\n \tif (chan->pending_req) {\n \t\tdisc_att_send_op(chan->pending_req);\n \t\tchan->pending_req = NULL;\n@@ -44,6 +39,15 @@\n \n \tbt_att_ref(att);\n \n+\tatt->in_disc = true;\n+\n+\t/* Notify request callbacks */\n+\tqueue_remove_all(att->req_queue, NULL, NULL, disc_att_send_op);\n+\tqueue_remove_all(att->ind_queue, NULL, NULL, disc_att_send_op);\n+\tqueue_remove_all(att->write_queue, NULL, NULL, disc_att_send_op);\n+\n+\tatt->in_disc = false;\n+\n \tqueue_foreach(att->disconn_list, disconn_handler, INT_TO_PTR(err));\n \n \tbt_att_unregister_all(att);",
        "diff_line_info": {
            "deleted_lines": [
                "\t/* Notify request callbacks */",
                "\tqueue_remove_all(att->req_queue, NULL, NULL, disc_att_send_op);",
                "\tqueue_remove_all(att->ind_queue, NULL, NULL, disc_att_send_op);",
                "\tqueue_remove_all(att->write_queue, NULL, NULL, disc_att_send_op);",
                ""
            ],
            "added_lines": [
                "\tatt->in_disc = true;",
                "",
                "\t/* Notify request callbacks */",
                "\tqueue_remove_all(att->req_queue, NULL, NULL, disc_att_send_op);",
                "\tqueue_remove_all(att->ind_queue, NULL, NULL, disc_att_send_op);",
                "\tqueue_remove_all(att->write_queue, NULL, NULL, disc_att_send_op);",
                "",
                "\tatt->in_disc = false;",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2020-27153",
        "func_name": "bluez/cancel_att_send_op",
        "description": "In BlueZ before 5.55, a double free was found in the gatttool disconnect_cb() routine from shared/att.c. A remote attacker could potentially cause a denial of service or code execution, during service discovery, due to a redundant disconnect MGMT event.",
        "git_url": "https://github.com/bluez/bluez/commit/1cd644db8c23a2f530ddb93cebed7dacc5f5721a",
        "commit_title": "shared/att: Fix possible crash on disconnect",
        "commit_text": " If there are pending request while disconnecting they would be notified but clients may endup being freed in the proccess which will then be calling bt_att_cancel to cancal its requests causing the following trace:  Invalid read of size 4    at 0x1D894C: enable_ccc_callback (gatt-client.c:1627)    by 0x1D247B: disc_att_send_op (att.c:417)    by 0x1CCC17: queue_remove_all (queue.c:354)    by 0x1D47B7: disconnect_cb (att.c:635)    by 0x1E0707: watch_callback (io-glib.c:170)    by 0x48E963B: g_main_context_dispatch (in /usr/lib/libglib-2.0.so.0.6400.4)    by 0x48E9AC7: ??? (in /usr/lib/libglib-2.0.so.0.6400.4)    by 0x48E9ECF: g_main_loop_run (in /usr/lib/libglib-2.0.so.0.6400.4)    by 0x1E0E97: mainloop_run (mainloop-glib.c:79)    by 0x1E13B3: mainloop_run_with_signal (mainloop-notify.c:201)    by 0x12BC3B: main (main.c:770)  Address 0x7d40a28 is 24 bytes inside a block of size 32 free'd    at 0x484A2E0: free (vg_replace_malloc.c:540)    by 0x1CCC17: queue_remove_all (queue.c:354)    by 0x1CCC83: queue_destroy (queue.c:73)    by 0x1D7DD7: bt_gatt_client_free (gatt-client.c:2209)    by 0x16497B: batt_free (battery.c:77)    by 0x16497B: batt_remove (battery.c:286)    by 0x1A0013: service_remove (service.c:176)    by 0x1A9B7B: device_remove_gatt_service (device.c:3691)    by 0x1A9B7B: gatt_service_removed (device.c:3805)    by 0x1CC90B: queue_foreach (queue.c:220)    by 0x1DE27B: notify_service_changed.isra.0.part.0 (gatt-db.c:369)    by 0x1DE387: notify_service_changed (gatt-db.c:361)    by 0x1DE387: gatt_db_service_destroy (gatt-db.c:385)    by 0x1DE3EF: gatt_db_remove_service (gatt-db.c:519)    by 0x1D674F: discovery_op_complete (gatt-client.c:388)    by 0x1D6877: discover_primary_cb (gatt-client.c:1260)    by 0x1E220B: discovery_op_complete (gatt-helpers.c:628)    by 0x1E249B: read_by_grp_type_cb (gatt-helpers.c:730)    by 0x1D247B: disc_att_send_op (att.c:417)    by 0x1CCC17: queue_remove_all (queue.c:354)    by 0x1D47B7: disconnect_cb (att.c:635)",
        "func_before": "static void cancel_att_send_op(struct att_send_op *op)\n{\n\tif (op->destroy)\n\t\top->destroy(op->user_data);\n\n\top->user_data = NULL;\n\top->callback = NULL;\n\top->destroy = NULL;\n}",
        "func": "static void cancel_att_send_op(void *data)\n{\n\tstruct att_send_op *op = data;\n\n\tif (op->destroy)\n\t\top->destroy(op->user_data);\n\n\top->user_data = NULL;\n\top->callback = NULL;\n\top->destroy = NULL;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,7 @@\n-static void cancel_att_send_op(struct att_send_op *op)\n+static void cancel_att_send_op(void *data)\n {\n+\tstruct att_send_op *op = data;\n+\n \tif (op->destroy)\n \t\top->destroy(op->user_data);\n ",
        "diff_line_info": {
            "deleted_lines": [
                "static void cancel_att_send_op(struct att_send_op *op)"
            ],
            "added_lines": [
                "static void cancel_att_send_op(void *data)",
                "\tstruct att_send_op *op = data;",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2020-16590",
        "func_name": "binutils-gdb/get_num_dynamic_syms",
        "description": "A double free vulnerability exists in the Binary File Descriptor (BFD) (aka libbrd) in GNU Binutils 2.35 in the process_symbol_table, as demonstrated in readelf, via a crafted file.",
        "git_url": "https://sourceware.org/git/gitweb.cgi?p=binutils-gdb.git;h=c98a4545dc7bf2bcaf1de539c4eb84784680eaa4",
        "commit_title": "",
        "commit_text": "Re: readelf: Consolidate --syms --use-dynamic with --dyn-syms  \tPR 25821 \t* readelf.c (get_num_dynamic_syms): Typo fix. ",
        "func_before": "static unsigned long\nget_num_dynamic_syms (Filedata * filedata)\n{\n  unsigned long num_of_syms = 0;\n\n  if (!do_histogram && (!do_using_dynamic || do_dyn_syms))\n    return num_of_syms;\n\n  if (dynamic_info[DT_HASH])\n    {\n      unsigned char nb[8];\n      unsigned char nc[8];\n      unsigned int hash_ent_size = 4;\n\n      if ((filedata->file_header.e_machine == EM_ALPHA\n\t   || filedata->file_header.e_machine == EM_S390\n\t   || filedata->file_header.e_machine == EM_S390_OLD)\n\t  && filedata->file_header.e_ident[EI_CLASS] == ELFCLASS64)\n\thash_ent_size = 8;\n\n      if (fseek (filedata->handle,\n\t\t (archive_file_offset\n\t\t  + offset_from_vma (filedata, dynamic_info[DT_HASH],\n\t\t\t\t     sizeof nb + sizeof nc)),\n\t\t SEEK_SET))\n\t{\n\t  error (_(\"Unable to seek to start of dynamic information\\n\"));\n\t  goto no_hash;\n\t}\n\n      if (fread (nb, hash_ent_size, 1, filedata->handle) != 1)\n\t{\n\t  error (_(\"Failed to read in number of buckets\\n\"));\n\t  goto no_hash;\n\t}\n\n      if (fread (nc, hash_ent_size, 1, filedata->handle) != 1)\n\t{\n\t  error (_(\"Failed to read in number of chains\\n\"));\n\t  goto no_hash;\n\t}\n\n      nbuckets = byte_get (nb, hash_ent_size);\n      nchains = byte_get (nc, hash_ent_size);\n      num_of_syms = nchains;\n\n      buckets = get_dynamic_data (filedata, nbuckets, hash_ent_size);\n      chains  = get_dynamic_data (filedata, nchains, hash_ent_size);\n\n  no_hash:\n      if (num_of_syms == 0)\n\t{\n\t  if (buckets)\n\t    {\n\t      free (buckets);\n\t      buckets = NULL;\n\t    }\n\t  if (chains)\n\t    {\n\t      free (chains);\n\t      buckets = NULL;\n\t    }\n\t  nbuckets = 0;\n\t}\n    }\n\n  if (dynamic_info_DT_GNU_HASH)\n    {\n      unsigned char nb[16];\n      bfd_vma i, maxchain = 0xffffffff, bitmaskwords;\n      bfd_vma buckets_vma;\n      unsigned long hn;\n      bfd_boolean gnu_hash_error = FALSE;\n\n      if (fseek (filedata->handle,\n\t\t (archive_file_offset\n\t\t  + offset_from_vma (filedata, dynamic_info_DT_GNU_HASH,\n\t\t\t\t     sizeof nb)),\n\t\t SEEK_SET))\n\t{\n\t  error (_(\"Unable to seek to start of dynamic information\\n\"));\n\t  gnu_hash_error = TRUE;\n\t  goto no_gnu_hash;\n\t}\n\n      if (fread (nb, 16, 1, filedata->handle) != 1)\n\t{\n\t  error (_(\"Failed to read in number of buckets\\n\"));\n\t  gnu_hash_error = TRUE;\n\t  goto no_gnu_hash;\n\t}\n\n      ngnubuckets = byte_get (nb, 4);\n      gnusymidx = byte_get (nb + 4, 4);\n      bitmaskwords = byte_get (nb + 8, 4);\n      buckets_vma = dynamic_info_DT_GNU_HASH + 16;\n      if (is_32bit_elf)\n\tbuckets_vma += bitmaskwords * 4;\n      else\n\tbuckets_vma += bitmaskwords * 8;\n\n      if (fseek (filedata->handle,\n\t\t (archive_file_offset\n\t\t  + offset_from_vma (filedata, buckets_vma, 4)),\n\t\t SEEK_SET))\n\t{\n\t  error (_(\"Unable to seek to start of dynamic information\\n\"));\n\t  gnu_hash_error = TRUE;\n\t  goto no_gnu_hash;\n\t}\n\n      gnubuckets = get_dynamic_data (filedata, ngnubuckets, 4);\n\n      if (gnubuckets == NULL)\n\t{\n\t  gnu_hash_error = TRUE;\n\t  goto no_gnu_hash;\n\t}\n\n      for (i = 0; i < ngnubuckets; i++)\n\tif (gnubuckets[i] != 0)\n\t  {\n\t    if (gnubuckets[i] < gnusymidx)\n\t      {\n\t\tgnu_hash_error = TRUE;\n\t\treturn FALSE;\n\t      }\n\n\t    if (maxchain == 0xffffffff || gnubuckets[i] > maxchain)\n\t      maxchain = gnubuckets[i];\n\t  }\n\n      if (maxchain == 0xffffffff)\n\t{\n\t  gnu_hash_error = TRUE;\n\t  goto no_gnu_hash;\n\t}\n\n      maxchain -= gnusymidx;\n\n      if (fseek (filedata->handle,\n\t\t (archive_file_offset\n\t\t  + offset_from_vma (filedata, buckets_vma\n\t\t\t\t\t   + 4 * (ngnubuckets + maxchain), 4)),\n\t\t SEEK_SET))\n\t{\n\t  error (_(\"Unable to seek to start of dynamic information\\n\"));\n\t  gnu_hash_error = TRUE;\n\t  goto no_gnu_hash;\n\t}\n\n      do\n\t{\n\t  if (fread (nb, 4, 1, filedata->handle) != 1)\n\t    {\n\t      error (_(\"Failed to determine last chain length\\n\"));\n\t  gnu_hash_error = TRUE;\n\t      goto no_gnu_hash;\n\t    }\n\n\t  if (maxchain + 1 == 0)\n\t    {\n\t      gnu_hash_error = TRUE;\n\t      goto no_gnu_hash;\n\t    }\n\n\t  ++maxchain;\n\t}\n      while ((byte_get (nb, 4) & 1) == 0);\n\n      if (fseek (filedata->handle,\n\t\t (archive_file_offset\n\t\t  + offset_from_vma (filedata, buckets_vma + 4 * ngnubuckets, 4)),\n\t\t SEEK_SET))\n\t{\n\t  error (_(\"Unable to seek to start of dynamic information\\n\"));\n\t  gnu_hash_error = TRUE;\n\t  goto no_gnu_hash;\n\t}\n\n      gnuchains = get_dynamic_data (filedata, maxchain, 4);\n      ngnuchains = maxchain;\n\n      if (gnuchains == NULL)\n\t{\n\t  gnu_hash_error = TRUE;\n\t  goto no_gnu_hash;\n\t}\n\n      if (dynamic_info_DT_MIPS_XHASH)\n\t{\n\t  if (fseek (filedata->handle,\n\t\t     (archive_file_offset\n\t\t      + offset_from_vma (filedata, (buckets_vma\n\t\t\t\t\t\t    + 4 * (ngnubuckets\n\t\t\t\t\t\t\t   + maxchain)), 4)),\n\t\t     SEEK_SET))\n\t    {\n\t      error (_(\"Unable to seek to start of dynamic information\\n\"));\n\t      gnu_hash_error = TRUE;\n\t      goto no_gnu_hash;\n\t    }\n\n\t  mipsxlat = get_dynamic_data (filedata, maxchain, 4);\n\t}\n\n      for (hn = 0; hn < ngnubuckets; ++hn)\n\tif (gnubuckets[hn] != 0)\n\t  {\n\t    bfd_vma si = gnubuckets[hn];\n\t    bfd_vma off = si - gnusymidx;\n\n\t    do\n\t      {\n\t\tif (dynamic_info_DT_MIPS_XHASH)\n\t\t  {\n\t\t    if (mipsxlat[off] >= num_of_syms)\n\t\t      num_of_syms = mipsxlat[off] + 1;\n\t\t  }\n\t\telse\n\t\t  {\n\t\t    if (si >= num_of_syms)\n\t\t      num_of_syms = si + 1;\n\t\t  }\n\t\tsi++;\n\t      }\n\t    while (off < ngnuchains && (gnuchains[off++] & 1) == 0);\n\t  }\n\n  no_gnu_hash:\n      if (gnu_hash_error)\n\t{\n\t  if (mipsxlat)\n\t    {\n\t      free (mipsxlat);\n\t      mipsxlat = NULL;\n\t    }\n\t  if (gnuchains)\n\t    {\n\t      free (gnuchains);\n\t      gnuchains = NULL;\n\t    }\n\t  if (gnubuckets)\n\t    {\n\t      free (gnubuckets);\n\t      gnubuckets = NULL;\n\t    }\n\t  ngnubuckets = 0;\n\t  ngnuchains = 0;\n\t}\n    }\n\n  return num_of_syms;\n}",
        "func": "static unsigned long\nget_num_dynamic_syms (Filedata * filedata)\n{\n  unsigned long num_of_syms = 0;\n\n  if (!do_histogram && (!do_using_dynamic || do_dyn_syms))\n    return num_of_syms;\n\n  if (dynamic_info[DT_HASH])\n    {\n      unsigned char nb[8];\n      unsigned char nc[8];\n      unsigned int hash_ent_size = 4;\n\n      if ((filedata->file_header.e_machine == EM_ALPHA\n\t   || filedata->file_header.e_machine == EM_S390\n\t   || filedata->file_header.e_machine == EM_S390_OLD)\n\t  && filedata->file_header.e_ident[EI_CLASS] == ELFCLASS64)\n\thash_ent_size = 8;\n\n      if (fseek (filedata->handle,\n\t\t (archive_file_offset\n\t\t  + offset_from_vma (filedata, dynamic_info[DT_HASH],\n\t\t\t\t     sizeof nb + sizeof nc)),\n\t\t SEEK_SET))\n\t{\n\t  error (_(\"Unable to seek to start of dynamic information\\n\"));\n\t  goto no_hash;\n\t}\n\n      if (fread (nb, hash_ent_size, 1, filedata->handle) != 1)\n\t{\n\t  error (_(\"Failed to read in number of buckets\\n\"));\n\t  goto no_hash;\n\t}\n\n      if (fread (nc, hash_ent_size, 1, filedata->handle) != 1)\n\t{\n\t  error (_(\"Failed to read in number of chains\\n\"));\n\t  goto no_hash;\n\t}\n\n      nbuckets = byte_get (nb, hash_ent_size);\n      nchains = byte_get (nc, hash_ent_size);\n      num_of_syms = nchains;\n\n      buckets = get_dynamic_data (filedata, nbuckets, hash_ent_size);\n      chains  = get_dynamic_data (filedata, nchains, hash_ent_size);\n\n  no_hash:\n      if (num_of_syms == 0)\n\t{\n\t  if (buckets)\n\t    {\n\t      free (buckets);\n\t      buckets = NULL;\n\t    }\n\t  if (chains)\n\t    {\n\t      free (chains);\n\t      chains = NULL;\n\t    }\n\t  nbuckets = 0;\n\t}\n    }\n\n  if (dynamic_info_DT_GNU_HASH)\n    {\n      unsigned char nb[16];\n      bfd_vma i, maxchain = 0xffffffff, bitmaskwords;\n      bfd_vma buckets_vma;\n      unsigned long hn;\n      bfd_boolean gnu_hash_error = FALSE;\n\n      if (fseek (filedata->handle,\n\t\t (archive_file_offset\n\t\t  + offset_from_vma (filedata, dynamic_info_DT_GNU_HASH,\n\t\t\t\t     sizeof nb)),\n\t\t SEEK_SET))\n\t{\n\t  error (_(\"Unable to seek to start of dynamic information\\n\"));\n\t  gnu_hash_error = TRUE;\n\t  goto no_gnu_hash;\n\t}\n\n      if (fread (nb, 16, 1, filedata->handle) != 1)\n\t{\n\t  error (_(\"Failed to read in number of buckets\\n\"));\n\t  gnu_hash_error = TRUE;\n\t  goto no_gnu_hash;\n\t}\n\n      ngnubuckets = byte_get (nb, 4);\n      gnusymidx = byte_get (nb + 4, 4);\n      bitmaskwords = byte_get (nb + 8, 4);\n      buckets_vma = dynamic_info_DT_GNU_HASH + 16;\n      if (is_32bit_elf)\n\tbuckets_vma += bitmaskwords * 4;\n      else\n\tbuckets_vma += bitmaskwords * 8;\n\n      if (fseek (filedata->handle,\n\t\t (archive_file_offset\n\t\t  + offset_from_vma (filedata, buckets_vma, 4)),\n\t\t SEEK_SET))\n\t{\n\t  error (_(\"Unable to seek to start of dynamic information\\n\"));\n\t  gnu_hash_error = TRUE;\n\t  goto no_gnu_hash;\n\t}\n\n      gnubuckets = get_dynamic_data (filedata, ngnubuckets, 4);\n\n      if (gnubuckets == NULL)\n\t{\n\t  gnu_hash_error = TRUE;\n\t  goto no_gnu_hash;\n\t}\n\n      for (i = 0; i < ngnubuckets; i++)\n\tif (gnubuckets[i] != 0)\n\t  {\n\t    if (gnubuckets[i] < gnusymidx)\n\t      {\n\t\tgnu_hash_error = TRUE;\n\t\treturn FALSE;\n\t      }\n\n\t    if (maxchain == 0xffffffff || gnubuckets[i] > maxchain)\n\t      maxchain = gnubuckets[i];\n\t  }\n\n      if (maxchain == 0xffffffff)\n\t{\n\t  gnu_hash_error = TRUE;\n\t  goto no_gnu_hash;\n\t}\n\n      maxchain -= gnusymidx;\n\n      if (fseek (filedata->handle,\n\t\t (archive_file_offset\n\t\t  + offset_from_vma (filedata, buckets_vma\n\t\t\t\t\t   + 4 * (ngnubuckets + maxchain), 4)),\n\t\t SEEK_SET))\n\t{\n\t  error (_(\"Unable to seek to start of dynamic information\\n\"));\n\t  gnu_hash_error = TRUE;\n\t  goto no_gnu_hash;\n\t}\n\n      do\n\t{\n\t  if (fread (nb, 4, 1, filedata->handle) != 1)\n\t    {\n\t      error (_(\"Failed to determine last chain length\\n\"));\n\t  gnu_hash_error = TRUE;\n\t      goto no_gnu_hash;\n\t    }\n\n\t  if (maxchain + 1 == 0)\n\t    {\n\t      gnu_hash_error = TRUE;\n\t      goto no_gnu_hash;\n\t    }\n\n\t  ++maxchain;\n\t}\n      while ((byte_get (nb, 4) & 1) == 0);\n\n      if (fseek (filedata->handle,\n\t\t (archive_file_offset\n\t\t  + offset_from_vma (filedata, buckets_vma + 4 * ngnubuckets, 4)),\n\t\t SEEK_SET))\n\t{\n\t  error (_(\"Unable to seek to start of dynamic information\\n\"));\n\t  gnu_hash_error = TRUE;\n\t  goto no_gnu_hash;\n\t}\n\n      gnuchains = get_dynamic_data (filedata, maxchain, 4);\n      ngnuchains = maxchain;\n\n      if (gnuchains == NULL)\n\t{\n\t  gnu_hash_error = TRUE;\n\t  goto no_gnu_hash;\n\t}\n\n      if (dynamic_info_DT_MIPS_XHASH)\n\t{\n\t  if (fseek (filedata->handle,\n\t\t     (archive_file_offset\n\t\t      + offset_from_vma (filedata, (buckets_vma\n\t\t\t\t\t\t    + 4 * (ngnubuckets\n\t\t\t\t\t\t\t   + maxchain)), 4)),\n\t\t     SEEK_SET))\n\t    {\n\t      error (_(\"Unable to seek to start of dynamic information\\n\"));\n\t      gnu_hash_error = TRUE;\n\t      goto no_gnu_hash;\n\t    }\n\n\t  mipsxlat = get_dynamic_data (filedata, maxchain, 4);\n\t}\n\n      for (hn = 0; hn < ngnubuckets; ++hn)\n\tif (gnubuckets[hn] != 0)\n\t  {\n\t    bfd_vma si = gnubuckets[hn];\n\t    bfd_vma off = si - gnusymidx;\n\n\t    do\n\t      {\n\t\tif (dynamic_info_DT_MIPS_XHASH)\n\t\t  {\n\t\t    if (mipsxlat[off] >= num_of_syms)\n\t\t      num_of_syms = mipsxlat[off] + 1;\n\t\t  }\n\t\telse\n\t\t  {\n\t\t    if (si >= num_of_syms)\n\t\t      num_of_syms = si + 1;\n\t\t  }\n\t\tsi++;\n\t      }\n\t    while (off < ngnuchains && (gnuchains[off++] & 1) == 0);\n\t  }\n\n  no_gnu_hash:\n      if (gnu_hash_error)\n\t{\n\t  if (mipsxlat)\n\t    {\n\t      free (mipsxlat);\n\t      mipsxlat = NULL;\n\t    }\n\t  if (gnuchains)\n\t    {\n\t      free (gnuchains);\n\t      gnuchains = NULL;\n\t    }\n\t  if (gnubuckets)\n\t    {\n\t      free (gnubuckets);\n\t      gnubuckets = NULL;\n\t    }\n\t  ngnubuckets = 0;\n\t  ngnuchains = 0;\n\t}\n    }\n\n  return num_of_syms;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -58,7 +58,7 @@\n \t  if (chains)\n \t    {\n \t      free (chains);\n-\t      buckets = NULL;\n+\t      chains = NULL;\n \t    }\n \t  nbuckets = 0;\n \t}",
        "diff_line_info": {
            "deleted_lines": [
                "\t      buckets = NULL;"
            ],
            "added_lines": [
                "\t      chains = NULL;"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-19004",
        "func_name": "autotrace/input_bmp_reader",
        "description": "A biWidth*biBitCnt integer overflow in input-bmp.c in autotrace 0.31.1 allows attackers to provide an unexpected input value to malloc via a malformed bitmap image.",
        "git_url": "https://github.com/autotrace/autotrace/commit/64c5833e55d7672d6136a3fbfeae24bd012d36a5",
        "commit_title": "Check for overflow in row bytes",
        "commit_text": " Fixes CVE-2019-19004",
        "func_before": "at_bitmap input_bmp_reader(gchar * filename, at_input_opts_type * opts, at_msg_func msg_func, gpointer msg_data, gpointer user_data)\n{\n  FILE *fd;\n  unsigned char buffer[64];\n  int ColormapSize, rowbytes, Maps, Grey;\n  unsigned char ColorMap[256][3];\n  at_bitmap image = at_bitmap_init(0, 0, 0, 1);\n  unsigned char *image_storage;\n  at_exception_type exp = at_exception_new(msg_func, msg_data);\n\n  fd = fopen(filename, \"rb\");\n\n  if (!fd) {\n    LOG(\"Can't open \\\"%s\\\"\\n\", filename);\n    at_exception_fatal(&exp, \"bmp: cannot open input file\");\n    return image;\n  }\n\n  /* It is a File. Now is it a Bitmap? Read the shortest possible header. */\n\n  if (!ReadOK(fd, buffer, 18) || (strncmp((const char *)buffer, \"BM\", 2))) {\n    LOG(\"Not a valid BMP file %s\\n\", filename);\n    at_exception_fatal(&exp, \"bmp: invalid input file\");\n    goto cleanup;\n  }\n\n  /* bring them to the right byteorder. Not too nice, but it should work */\n\n  Bitmap_File_Head.bfSize = ToL(&buffer[0x02]);\n  Bitmap_File_Head.zzHotX = ToS(&buffer[0x06]);\n  Bitmap_File_Head.zzHotY = ToS(&buffer[0x08]);\n  Bitmap_File_Head.bfOffs = ToL(&buffer[0x0a]);\n  Bitmap_File_Head.biSize = ToL(&buffer[0x0e]);\n\n  /* What kind of bitmap is it? */\n\n  if (Bitmap_File_Head.biSize == 12) {  /* OS/2 1.x ? */\n    if (!ReadOK(fd, buffer, 8)) {\n      LOG(\"Error reading BMP file header\\n\");\n      at_exception_fatal(&exp, \"Error reading BMP file header\");\n      goto cleanup;\n    }\n\n    Bitmap_Head.biWidth = ToS(&buffer[0x00]); /* 12 */\n    Bitmap_Head.biHeight = ToS(&buffer[0x02]);  /* 14 */\n    Bitmap_Head.biPlanes = ToS(&buffer[0x04]);  /* 16 */\n    Bitmap_Head.biBitCnt = ToS(&buffer[0x06]);  /* 18 */\n    Bitmap_Head.biCompr = 0;\n    Bitmap_Head.biSizeIm = 0;\n    Bitmap_Head.biXPels = Bitmap_Head.biYPels = 0;\n    Bitmap_Head.biClrUsed = 0;\n    Maps = 3;\n  } else if (Bitmap_File_Head.biSize == 40) { /* Windows 3.x */\n    if (!ReadOK(fd, buffer, Bitmap_File_Head.biSize - 4)) {\n      LOG(\"Error reading BMP file header\\n\");\n      at_exception_fatal(&exp, \"Error reading BMP file header\");\n      goto cleanup;\n    }\n\n    Bitmap_Head.biWidth = ToL(&buffer[0x00]); /* 12 */\n    Bitmap_Head.biHeight = ToL(&buffer[0x04]);  /* 16 */\n    Bitmap_Head.biPlanes = ToS(&buffer[0x08]);  /* 1A */\n    Bitmap_Head.biBitCnt = ToS(&buffer[0x0A]);  /* 1C */\n    Bitmap_Head.biCompr = ToL(&buffer[0x0C]); /* 1E */\n    Bitmap_Head.biSizeIm = ToL(&buffer[0x10]);  /* 22 */\n    Bitmap_Head.biXPels = ToL(&buffer[0x14]); /* 26 */\n    Bitmap_Head.biYPels = ToL(&buffer[0x18]); /* 2A */\n    Bitmap_Head.biClrUsed = ToL(&buffer[0x1C]); /* 2E */\n    Bitmap_Head.biClrImp = ToL(&buffer[0x20]);  /* 32 */\n    /* 36 */\n    Maps = 4;\n  } else if (Bitmap_File_Head.biSize >= 40 && Bitmap_File_Head.biSize <= 64) {  /* Probably OS/2 2.x */\n    if (!ReadOK(fd, buffer, Bitmap_File_Head.biSize - 4)) {\n      LOG(\"Error reading BMP file header\\n\");\n      at_exception_fatal(&exp, \"Error reading BMP file header\");\n      goto cleanup;\n    }\n\n    Bitmap_Head.biWidth = ToL(&buffer[0x00]); /* 12 */\n    Bitmap_Head.biHeight = ToL(&buffer[0x04]);  /* 16 */\n    Bitmap_Head.biPlanes = ToS(&buffer[0x08]);  /* 1A */\n    Bitmap_Head.biBitCnt = ToS(&buffer[0x0A]);  /* 1C */\n    Bitmap_Head.biCompr = ToL(&buffer[0x0C]); /* 1E */\n    Bitmap_Head.biSizeIm = ToL(&buffer[0x10]);  /* 22 */\n    Bitmap_Head.biXPels = ToL(&buffer[0x14]); /* 26 */\n    Bitmap_Head.biYPels = ToL(&buffer[0x18]); /* 2A */\n    Bitmap_Head.biClrUsed = ToL(&buffer[0x1C]); /* 2E */\n    Bitmap_Head.biClrImp = ToL(&buffer[0x20]);  /* 32 */\n    /* 36 */\n    Maps = 3;\n  } else {\n    LOG(\"Error reading BMP file header\\n\");\n    at_exception_fatal(&exp, \"Error reading BMP file header\");\n    goto cleanup;\n  }\n\n  /* Valid options 1, 4, 8, 16, 24, 32 */\n  /* 16 is awful, we should probably shoot whoever invented it */\n\n  /* There should be some colors used! */\n\n  ColormapSize = (Bitmap_File_Head.bfOffs - Bitmap_File_Head.biSize - 14) / Maps;\n\n  if ((Bitmap_Head.biClrUsed == 0) && (Bitmap_Head.biBitCnt <= 8))\n    Bitmap_Head.biClrUsed = ColormapSize;\n\n  /* Sanity checks */\n\n  if ((Bitmap_Head.biHeight == 0 || Bitmap_Head.biWidth == 0)\n      || (Bitmap_Head.biPlanes != 1)\n      || (ColormapSize > 256 || Bitmap_Head.biClrUsed > 256)) {\n    LOG(\"Error reading BMP file header\\n\");\n    at_exception_fatal(&exp, \"Error reading BMP file header\");\n    goto cleanup;\n  }\n\n  /* Windows and OS/2 declare filler so that rows are a multiple of\n   * word length (32 bits == 4 bytes)\n   */\n\n  rowbytes = ((Bitmap_Head.biWidth * Bitmap_Head.biBitCnt - 1) / 32) * 4 + 4;\n\n#ifdef DEBUG\n  printf(\"\\nSize: %u, Colors: %u, Bits: %u, Width: %u, Height: %u, Comp: %u, Zeile: %u\\n\", Bitmap_File_Head.bfSize, Bitmap_Head.biClrUsed, Bitmap_Head.biBitCnt, Bitmap_Head.biWidth, Bitmap_Head.biHeight, Bitmap_Head.biCompr, rowbytes);\n#endif\n\n  /* Get the Colormap */\n  ReadColorMap(fd, ColorMap, ColormapSize, Maps, &Grey, &exp);\n  if (at_exception_got_fatal(&exp))\n    goto cleanup;\n\n#ifdef DEBUG\n  printf(\"Colormap read\\n\");\n#endif\n\n  /* Get the Image and return the ID or -1 on error */\n  image_storage = ReadImage(fd, Bitmap_Head.biWidth, Bitmap_Head.biHeight, ColorMap, Bitmap_Head.biBitCnt, Bitmap_Head.biCompr, rowbytes, Grey);\n  image = at_bitmap_init(image_storage, (unsigned short)Bitmap_Head.biWidth, (unsigned short)Bitmap_Head.biHeight, Grey ? 1 : 3);\ncleanup:\n  fclose(fd);\n  return (image);\n}",
        "func": "at_bitmap input_bmp_reader(gchar * filename, at_input_opts_type * opts, at_msg_func msg_func, gpointer msg_data, gpointer user_data)\n{\n  FILE *fd;\n  unsigned char buffer[64];\n  int ColormapSize, rowbytes, Maps, Grey;\n  unsigned char ColorMap[256][3];\n  at_bitmap image = at_bitmap_init(0, 0, 0, 1);\n  unsigned char *image_storage;\n  at_exception_type exp = at_exception_new(msg_func, msg_data);\n\n  fd = fopen(filename, \"rb\");\n\n  if (!fd) {\n    LOG(\"Can't open \\\"%s\\\"\\n\", filename);\n    at_exception_fatal(&exp, \"bmp: cannot open input file\");\n    return image;\n  }\n\n  /* It is a File. Now is it a Bitmap? Read the shortest possible header. */\n\n  if (!ReadOK(fd, buffer, 18) || (strncmp((const char *)buffer, \"BM\", 2))) {\n    LOG(\"Not a valid BMP file %s\\n\", filename);\n    at_exception_fatal(&exp, \"bmp: invalid input file\");\n    goto cleanup;\n  }\n\n  /* bring them to the right byteorder. Not too nice, but it should work */\n\n  Bitmap_File_Head.bfSize = ToL(&buffer[0x02]);\n  Bitmap_File_Head.zzHotX = ToS(&buffer[0x06]);\n  Bitmap_File_Head.zzHotY = ToS(&buffer[0x08]);\n  Bitmap_File_Head.bfOffs = ToL(&buffer[0x0a]);\n  Bitmap_File_Head.biSize = ToL(&buffer[0x0e]);\n\n  /* What kind of bitmap is it? */\n\n  if (Bitmap_File_Head.biSize == 12) {  /* OS/2 1.x ? */\n    if (!ReadOK(fd, buffer, 8)) {\n      LOG(\"Error reading BMP file header\\n\");\n      at_exception_fatal(&exp, \"Error reading BMP file header\");\n      goto cleanup;\n    }\n\n    Bitmap_Head.biWidth = ToS(&buffer[0x00]); /* 12 */\n    Bitmap_Head.biHeight = ToS(&buffer[0x02]);  /* 14 */\n    Bitmap_Head.biPlanes = ToS(&buffer[0x04]);  /* 16 */\n    Bitmap_Head.biBitCnt = ToS(&buffer[0x06]);  /* 18 */\n    Bitmap_Head.biCompr = 0;\n    Bitmap_Head.biSizeIm = 0;\n    Bitmap_Head.biXPels = Bitmap_Head.biYPels = 0;\n    Bitmap_Head.biClrUsed = 0;\n    Maps = 3;\n  } else if (Bitmap_File_Head.biSize == 40) { /* Windows 3.x */\n    if (!ReadOK(fd, buffer, Bitmap_File_Head.biSize - 4)) {\n      LOG(\"Error reading BMP file header\\n\");\n      at_exception_fatal(&exp, \"Error reading BMP file header\");\n      goto cleanup;\n    }\n\n    Bitmap_Head.biWidth = ToL(&buffer[0x00]); /* 12 */\n    Bitmap_Head.biHeight = ToL(&buffer[0x04]);  /* 16 */\n    Bitmap_Head.biPlanes = ToS(&buffer[0x08]);  /* 1A */\n    Bitmap_Head.biBitCnt = ToS(&buffer[0x0A]);  /* 1C */\n    Bitmap_Head.biCompr = ToL(&buffer[0x0C]); /* 1E */\n    Bitmap_Head.biSizeIm = ToL(&buffer[0x10]);  /* 22 */\n    Bitmap_Head.biXPels = ToL(&buffer[0x14]); /* 26 */\n    Bitmap_Head.biYPels = ToL(&buffer[0x18]); /* 2A */\n    Bitmap_Head.biClrUsed = ToL(&buffer[0x1C]); /* 2E */\n    Bitmap_Head.biClrImp = ToL(&buffer[0x20]);  /* 32 */\n    /* 36 */\n    Maps = 4;\n  } else if (Bitmap_File_Head.biSize >= 40 && Bitmap_File_Head.biSize <= 64) {  /* Probably OS/2 2.x */\n    if (!ReadOK(fd, buffer, Bitmap_File_Head.biSize - 4)) {\n      LOG(\"Error reading BMP file header\\n\");\n      at_exception_fatal(&exp, \"Error reading BMP file header\");\n      goto cleanup;\n    }\n\n    Bitmap_Head.biWidth = ToL(&buffer[0x00]); /* 12 */\n    Bitmap_Head.biHeight = ToL(&buffer[0x04]);  /* 16 */\n    Bitmap_Head.biPlanes = ToS(&buffer[0x08]);  /* 1A */\n    Bitmap_Head.biBitCnt = ToS(&buffer[0x0A]);  /* 1C */\n    Bitmap_Head.biCompr = ToL(&buffer[0x0C]); /* 1E */\n    Bitmap_Head.biSizeIm = ToL(&buffer[0x10]);  /* 22 */\n    Bitmap_Head.biXPels = ToL(&buffer[0x14]); /* 26 */\n    Bitmap_Head.biYPels = ToL(&buffer[0x18]); /* 2A */\n    Bitmap_Head.biClrUsed = ToL(&buffer[0x1C]); /* 2E */\n    Bitmap_Head.biClrImp = ToL(&buffer[0x20]);  /* 32 */\n    /* 36 */\n    Maps = 3;\n  } else {\n    LOG(\"Error reading BMP file header\\n\");\n    at_exception_fatal(&exp, \"Error reading BMP file header\");\n    goto cleanup;\n  }\n\n  /* Valid options 1, 4, 8, 16, 24, 32 */\n  /* 16 is awful, we should probably shoot whoever invented it */\n\n  /* There should be some colors used! */\n\n  ColormapSize = (Bitmap_File_Head.bfOffs - Bitmap_File_Head.biSize - 14) / Maps;\n\n  if ((Bitmap_Head.biClrUsed == 0) && (Bitmap_Head.biBitCnt <= 8))\n    Bitmap_Head.biClrUsed = ColormapSize;\n\n  /* Sanity checks */\n\n  if ((Bitmap_Head.biHeight == 0 || Bitmap_Head.biWidth == 0)\n      || (Bitmap_Head.biPlanes != 1)\n      || (ColormapSize > 256 || Bitmap_Head.biClrUsed > 256)) {\n    LOG(\"Error reading BMP file header\\n\");\n    at_exception_fatal(&exp, \"Error reading BMP file header\");\n    goto cleanup;\n  }\n\n  /* Windows and OS/2 declare filler so that rows are a multiple of\n   * word length (32 bits == 4 bytes)\n   */\n   \n  unsigned long overflowTest = Bitmap_Head.biWidth * Bitmap_Head.biBitCnt;\n  if (overflowTest / Bitmap_Head.biWidth != Bitmap_Head.biBitCnt) {\n    LOG(\"Error reading BMP file header. Width is too large\\n\");\n    at_exception_fatal(&exp, \"Error reading BMP file header. Width is too large\");\n    goto cleanup;\n  }\n\n  rowbytes = ((Bitmap_Head.biWidth * Bitmap_Head.biBitCnt - 1) / 32) * 4 + 4;\n\n#ifdef DEBUG\n  printf(\"\\nSize: %u, Colors: %u, Bits: %u, Width: %u, Height: %u, Comp: %u, Zeile: %u\\n\", Bitmap_File_Head.bfSize, Bitmap_Head.biClrUsed, Bitmap_Head.biBitCnt, Bitmap_Head.biWidth, Bitmap_Head.biHeight, Bitmap_Head.biCompr, rowbytes);\n#endif\n\n  /* Get the Colormap */\n  ReadColorMap(fd, ColorMap, ColormapSize, Maps, &Grey, &exp);\n  if (at_exception_got_fatal(&exp))\n    goto cleanup;\n\n#ifdef DEBUG\n  printf(\"Colormap read\\n\");\n#endif\n\n  /* Get the Image and return the ID or -1 on error */\n  image_storage = ReadImage(fd, Bitmap_Head.biWidth, Bitmap_Head.biHeight, ColorMap, Bitmap_Head.biBitCnt, Bitmap_Head.biCompr, rowbytes, Grey);\n  image = at_bitmap_init(image_storage, (unsigned short)Bitmap_Head.biWidth, (unsigned short)Bitmap_Head.biHeight, Grey ? 1 : 3);\ncleanup:\n  fclose(fd);\n  return (image);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -117,6 +117,13 @@\n   /* Windows and OS/2 declare filler so that rows are a multiple of\n    * word length (32 bits == 4 bytes)\n    */\n+   \n+  unsigned long overflowTest = Bitmap_Head.biWidth * Bitmap_Head.biBitCnt;\n+  if (overflowTest / Bitmap_Head.biWidth != Bitmap_Head.biBitCnt) {\n+    LOG(\"Error reading BMP file header. Width is too large\\n\");\n+    at_exception_fatal(&exp, \"Error reading BMP file header. Width is too large\");\n+    goto cleanup;\n+  }\n \n   rowbytes = ((Bitmap_Head.biWidth * Bitmap_Head.biBitCnt - 1) / 32) * 4 + 4;\n ",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "   ",
                "  unsigned long overflowTest = Bitmap_Head.biWidth * Bitmap_Head.biBitCnt;",
                "  if (overflowTest / Bitmap_Head.biWidth != Bitmap_Head.biBitCnt) {",
                "    LOG(\"Error reading BMP file header. Width is too large\\n\");",
                "    at_exception_fatal(&exp, \"Error reading BMP file header. Width is too large\");",
                "    goto cleanup;",
                "  }"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-3407",
        "func_name": "ArtifexSoftware/mupdf/pdf_read_new_xref",
        "description": "A flaw was found in mupdf 1.18.0. Double free of object during linearization may lead to memory corruption and other potential consequences.",
        "git_url": "https://github.com/ArtifexSoftware/mupdf/commit/cee7cefc610d42fd383b3c80c12cbc675443176a",
        "commit_title": "Bug 703366: Fix double free of object during linearization.",
        "commit_text": " This appears to happen because we parse an illegal object from a broken file and assign it to object 0, which is defined to be free.  Here, we fix the parsing code so this can't happen.",
        "func_before": "static pdf_obj *\npdf_read_new_xref(fz_context *ctx, pdf_document *doc, pdf_lexbuf *buf)\n{\n\tfz_stream *stm = NULL;\n\tpdf_obj *trailer = NULL;\n\tpdf_obj *index = NULL;\n\tpdf_obj *obj = NULL;\n\tint gen, num = 0;\n\tint64_t ofs, stm_ofs;\n\tint size, w0, w1, w2;\n\tint t;\n\n\tfz_var(trailer);\n\tfz_var(stm);\n\n\tfz_try(ctx)\n\t{\n\t\tofs = fz_tell(ctx, doc->file);\n\t\ttrailer = pdf_parse_ind_obj(ctx, doc, doc->file, buf, &num, &gen, &stm_ofs, NULL);\n\t}\n\tfz_catch(ctx)\n\t{\n\t\tpdf_drop_obj(ctx, trailer);\n\t\tfz_rethrow(ctx);\n\t}\n\n\tfz_try(ctx)\n\t{\n\t\tpdf_xref_entry *entry;\n\n\t\tobj = pdf_dict_get(ctx, trailer, PDF_NAME(Size));\n\t\tif (!obj)\n\t\t\tfz_throw(ctx, FZ_ERROR_GENERIC, \"xref stream missing Size entry (%d 0 R)\", num);\n\n\t\tsize = pdf_to_int(ctx, obj);\n\n\t\tobj = pdf_dict_get(ctx, trailer, PDF_NAME(W));\n\t\tif (!obj)\n\t\t\tfz_throw(ctx, FZ_ERROR_GENERIC, \"xref stream missing W entry (%d  R)\", num);\n\t\tw0 = pdf_array_get_int(ctx, obj, 0);\n\t\tw1 = pdf_array_get_int(ctx, obj, 1);\n\t\tw2 = pdf_array_get_int(ctx, obj, 2);\n\n\t\tif (w0 < 0)\n\t\t\tfz_warn(ctx, \"xref stream objects have corrupt type\");\n\t\tif (w1 < 0)\n\t\t\tfz_warn(ctx, \"xref stream objects have corrupt offset\");\n\t\tif (w2 < 0)\n\t\t\tfz_warn(ctx, \"xref stream objects have corrupt generation\");\n\n\t\tw0 = w0 < 0 ? 0 : w0;\n\t\tw1 = w1 < 0 ? 0 : w1;\n\t\tw2 = w2 < 0 ? 0 : w2;\n\n\t\tindex = pdf_dict_get(ctx, trailer, PDF_NAME(Index));\n\n\t\tstm = pdf_open_stream_with_offset(ctx, doc, num, trailer, stm_ofs);\n\n\t\tif (!index)\n\t\t{\n\t\t\tpdf_read_new_xref_section(ctx, doc, stm, 0, size, w0, w1, w2);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint n = pdf_array_len(ctx, index);\n\t\t\tfor (t = 0; t < n; t += 2)\n\t\t\t{\n\t\t\t\tint i0 = pdf_array_get_int(ctx, index, t + 0);\n\t\t\t\tint i1 = pdf_array_get_int(ctx, index, t + 1);\n\t\t\t\tpdf_read_new_xref_section(ctx, doc, stm, i0, i1, w0, w1, w2);\n\t\t\t}\n\t\t}\n\t\tentry = pdf_get_populating_xref_entry(ctx, doc, num);\n\t\tentry->ofs = ofs;\n\t\tentry->gen = gen;\n\t\tentry->num = num;\n\t\tentry->stm_ofs = stm_ofs;\n\t\tpdf_drop_obj(ctx, entry->obj);\n\t\tentry->obj = pdf_keep_obj(ctx, trailer);\n\t\tentry->type = 'n';\n\t}\n\tfz_always(ctx)\n\t{\n\t\tfz_drop_stream(ctx, stm);\n\t}\n\tfz_catch(ctx)\n\t{\n\t\tpdf_drop_obj(ctx, trailer);\n\t\tfz_rethrow(ctx);\n\t}\n\n\treturn trailer;\n}",
        "func": "static pdf_obj *\npdf_read_new_xref(fz_context *ctx, pdf_document *doc, pdf_lexbuf *buf)\n{\n\tfz_stream *stm = NULL;\n\tpdf_obj *trailer = NULL;\n\tpdf_obj *index = NULL;\n\tpdf_obj *obj = NULL;\n\tint gen, num = 0;\n\tint64_t ofs, stm_ofs;\n\tint size, w0, w1, w2;\n\tint t;\n\n\tfz_var(trailer);\n\tfz_var(stm);\n\n\tfz_try(ctx)\n\t{\n\t\tofs = fz_tell(ctx, doc->file);\n\t\ttrailer = pdf_parse_ind_obj(ctx, doc, doc->file, buf, &num, &gen, &stm_ofs, NULL);\n\t\tif (num == 0)\n\t\t\tfz_throw(ctx, FZ_ERROR_GENERIC, \"Trailer object number cannot be 0\\n\");\n\t}\n\tfz_catch(ctx)\n\t{\n\t\tpdf_drop_obj(ctx, trailer);\n\t\tfz_rethrow(ctx);\n\t}\n\n\tfz_try(ctx)\n\t{\n\t\tpdf_xref_entry *entry;\n\n\t\tobj = pdf_dict_get(ctx, trailer, PDF_NAME(Size));\n\t\tif (!obj)\n\t\t\tfz_throw(ctx, FZ_ERROR_GENERIC, \"xref stream missing Size entry (%d 0 R)\", num);\n\n\t\tsize = pdf_to_int(ctx, obj);\n\n\t\tobj = pdf_dict_get(ctx, trailer, PDF_NAME(W));\n\t\tif (!obj)\n\t\t\tfz_throw(ctx, FZ_ERROR_GENERIC, \"xref stream missing W entry (%d  R)\", num);\n\t\tw0 = pdf_array_get_int(ctx, obj, 0);\n\t\tw1 = pdf_array_get_int(ctx, obj, 1);\n\t\tw2 = pdf_array_get_int(ctx, obj, 2);\n\n\t\tif (w0 < 0)\n\t\t\tfz_warn(ctx, \"xref stream objects have corrupt type\");\n\t\tif (w1 < 0)\n\t\t\tfz_warn(ctx, \"xref stream objects have corrupt offset\");\n\t\tif (w2 < 0)\n\t\t\tfz_warn(ctx, \"xref stream objects have corrupt generation\");\n\n\t\tw0 = w0 < 0 ? 0 : w0;\n\t\tw1 = w1 < 0 ? 0 : w1;\n\t\tw2 = w2 < 0 ? 0 : w2;\n\n\t\tindex = pdf_dict_get(ctx, trailer, PDF_NAME(Index));\n\n\t\tstm = pdf_open_stream_with_offset(ctx, doc, num, trailer, stm_ofs);\n\n\t\tif (!index)\n\t\t{\n\t\t\tpdf_read_new_xref_section(ctx, doc, stm, 0, size, w0, w1, w2);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint n = pdf_array_len(ctx, index);\n\t\t\tfor (t = 0; t < n; t += 2)\n\t\t\t{\n\t\t\t\tint i0 = pdf_array_get_int(ctx, index, t + 0);\n\t\t\t\tint i1 = pdf_array_get_int(ctx, index, t + 1);\n\t\t\t\tpdf_read_new_xref_section(ctx, doc, stm, i0, i1, w0, w1, w2);\n\t\t\t}\n\t\t}\n\t\tentry = pdf_get_populating_xref_entry(ctx, doc, num);\n\t\tentry->ofs = ofs;\n\t\tentry->gen = gen;\n\t\tentry->num = num;\n\t\tentry->stm_ofs = stm_ofs;\n\t\tpdf_drop_obj(ctx, entry->obj);\n\t\tentry->obj = pdf_keep_obj(ctx, trailer);\n\t\tentry->type = 'n';\n\t}\n\tfz_always(ctx)\n\t{\n\t\tfz_drop_stream(ctx, stm);\n\t}\n\tfz_catch(ctx)\n\t{\n\t\tpdf_drop_obj(ctx, trailer);\n\t\tfz_rethrow(ctx);\n\t}\n\n\treturn trailer;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -17,6 +17,8 @@\n \t{\n \t\tofs = fz_tell(ctx, doc->file);\n \t\ttrailer = pdf_parse_ind_obj(ctx, doc, doc->file, buf, &num, &gen, &stm_ofs, NULL);\n+\t\tif (num == 0)\n+\t\t\tfz_throw(ctx, FZ_ERROR_GENERIC, \"Trailer object number cannot be 0\\n\");\n \t}\n \tfz_catch(ctx)\n \t{",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\tif (num == 0)",
                "\t\t\tfz_throw(ctx, FZ_ERROR_GENERIC, \"Trailer object number cannot be 0\\n\");"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-3407",
        "func_name": "ArtifexSoftware/mupdf/pdf_parse_ind_obj",
        "description": "A flaw was found in mupdf 1.18.0. Double free of object during linearization may lead to memory corruption and other potential consequences.",
        "git_url": "https://github.com/ArtifexSoftware/mupdf/commit/cee7cefc610d42fd383b3c80c12cbc675443176a",
        "commit_title": "Bug 703366: Fix double free of object during linearization.",
        "commit_text": " This appears to happen because we parse an illegal object from a broken file and assign it to object 0, which is defined to be free.  Here, we fix the parsing code so this can't happen.",
        "func_before": "pdf_obj *\npdf_parse_ind_obj(fz_context *ctx, pdf_document *doc,\n\tfz_stream *file, pdf_lexbuf *buf,\n\tint *onum, int *ogen, int64_t *ostmofs, int *try_repair)\n{\n\tpdf_obj *obj = NULL;\n\tint num = 0, gen = 0;\n\tint64_t stm_ofs;\n\tpdf_token tok;\n\tint64_t a, b;\n\tint read_next_token = 1;\n\n\tfz_var(obj);\n\n\ttok = pdf_lex(ctx, file, buf);\n\tif (tok != PDF_TOK_INT)\n\t{\n\t\tif (try_repair)\n\t\t\t*try_repair = 1;\n\t\tfz_throw(ctx, FZ_ERROR_SYNTAX, \"expected object number\");\n\t}\n\tnum = buf->i;\n\tif (num < 0 || num > PDF_MAX_OBJECT_NUMBER)\n\t\tfz_throw(ctx, FZ_ERROR_SYNTAX, \"object number out of range\");\n\n\ttok = pdf_lex(ctx, file, buf);\n\tif (tok != PDF_TOK_INT)\n\t{\n\t\tif (try_repair)\n\t\t\t*try_repair = 1;\n\t\tfz_throw(ctx, FZ_ERROR_SYNTAX, \"expected generation number (%d ? obj)\", num);\n\t}\n\tgen = buf->i;\n\n\ttok = pdf_lex(ctx, file, buf);\n\tif (tok != PDF_TOK_OBJ)\n\t{\n\t\tif (try_repair)\n\t\t\t*try_repair = 1;\n\t\tfz_throw(ctx, FZ_ERROR_SYNTAX, \"expected 'obj' keyword (%d %d ?)\", num, gen);\n\t}\n\n\ttok = pdf_lex(ctx, file, buf);\n\n\tswitch (tok)\n\t{\n\tcase PDF_TOK_OPEN_ARRAY:\n\t\tobj = pdf_parse_array(ctx, doc, file, buf);\n\t\tbreak;\n\n\tcase PDF_TOK_OPEN_DICT:\n\t\tobj = pdf_parse_dict(ctx, doc, file, buf);\n\t\tbreak;\n\n\tcase PDF_TOK_NAME: obj = pdf_new_name(ctx, buf->scratch); break;\n\tcase PDF_TOK_REAL: obj = pdf_new_real(ctx, buf->f); break;\n\tcase PDF_TOK_STRING: obj = pdf_new_string(ctx, buf->scratch, buf->len); break;\n\tcase PDF_TOK_TRUE: obj = PDF_TRUE; break;\n\tcase PDF_TOK_FALSE: obj = PDF_FALSE; break;\n\tcase PDF_TOK_NULL: obj = PDF_NULL; break;\n\n\tcase PDF_TOK_INT:\n\t\ta = buf->i;\n\t\ttok = pdf_lex(ctx, file, buf);\n\n\t\tif (tok == PDF_TOK_STREAM || tok == PDF_TOK_ENDOBJ)\n\t\t{\n\t\t\tobj = pdf_new_int(ctx, a);\n\t\t\tread_next_token = 0;\n\t\t\tbreak;\n\t\t}\n\t\telse if (tok == PDF_TOK_INT)\n\t\t{\n\t\t\tb = buf->i;\n\t\t\ttok = pdf_lex(ctx, file, buf);\n\t\t\tif (tok == PDF_TOK_R)\n\t\t\t{\n\t\t\t\tobj = pdf_new_indirect(ctx, doc, a, b);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfz_throw(ctx, FZ_ERROR_SYNTAX, \"expected 'R' keyword (%d %d R)\", num, gen);\n\n\tcase PDF_TOK_ENDOBJ:\n\t\tobj = PDF_NULL;\n\t\tread_next_token = 0;\n\t\tbreak;\n\n\tdefault:\n\t\tfz_throw(ctx, FZ_ERROR_SYNTAX, \"syntax error in object (%d %d R)\", num, gen);\n\t}\n\n\tfz_try(ctx)\n\t{\n\t\tif (read_next_token)\n\t\t\ttok = pdf_lex(ctx, file, buf);\n\n\t\tif (tok == PDF_TOK_STREAM)\n\t\t{\n\t\t\tint c = fz_read_byte(ctx, file);\n\t\t\twhile (c == ' ')\n\t\t\t\tc = fz_read_byte(ctx, file);\n\t\t\tif (c == '\\r')\n\t\t\t{\n\t\t\t\tc = fz_peek_byte(ctx, file);\n\t\t\t\tif (c != '\\n')\n\t\t\t\t\tfz_warn(ctx, \"line feed missing after stream begin marker (%d %d R)\", num, gen);\n\t\t\t\telse\n\t\t\t\t\tfz_read_byte(ctx, file);\n\t\t\t}\n\t\t\tstm_ofs = fz_tell(ctx, file);\n\t\t}\n\t\telse if (tok == PDF_TOK_ENDOBJ)\n\t\t{\n\t\t\tstm_ofs = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfz_warn(ctx, \"expected 'endobj' or 'stream' keyword (%d %d R)\", num, gen);\n\t\t\tstm_ofs = 0;\n\t\t}\n\t}\n\tfz_catch(ctx)\n\t{\n\t\tpdf_drop_obj(ctx, obj);\n\t\tfz_rethrow(ctx);\n\t}\n\n\tif (onum) *onum = num;\n\tif (ogen) *ogen = gen;\n\tif (ostmofs) *ostmofs = stm_ofs;\n\n\treturn obj;\n}",
        "func": "pdf_obj *\npdf_parse_ind_obj(fz_context *ctx, pdf_document *doc,\n\tfz_stream *file, pdf_lexbuf *buf,\n\tint *onum, int *ogen, int64_t *ostmofs, int *try_repair)\n{\n\tpdf_obj *obj = NULL;\n\tint num = 0, gen = 0;\n\tint64_t stm_ofs;\n\tpdf_token tok;\n\tint64_t a, b;\n\tint read_next_token = 1;\n\n\tfz_var(obj);\n\n\ttok = pdf_lex(ctx, file, buf);\n\tif (tok != PDF_TOK_INT)\n\t{\n\t\tif (try_repair)\n\t\t\t*try_repair = 1;\n\t\tfz_throw(ctx, FZ_ERROR_SYNTAX, \"expected object number\");\n\t}\n\tnum = buf->i;\n\tif (num < 0 || num > PDF_MAX_OBJECT_NUMBER)\n\t\tfz_throw(ctx, FZ_ERROR_SYNTAX, \"object number out of range\");\n\n\ttok = pdf_lex(ctx, file, buf);\n\tif (tok != PDF_TOK_INT)\n\t{\n\t\tif (try_repair)\n\t\t\t*try_repair = 1;\n\t\tfz_throw(ctx, FZ_ERROR_SYNTAX, \"expected generation number (%d ? obj)\", num);\n\t}\n\tgen = buf->i;\n\tif (gen < 0 || gen >= 65536)\n\t{\n\t\tif (try_repair)\n\t\t\t*try_repair = 1;\n\t\tfz_throw(ctx, FZ_ERROR_SYNTAX, \"invalid generation number (%d)\", gen);\n\t}\n\n\ttok = pdf_lex(ctx, file, buf);\n\tif (tok != PDF_TOK_OBJ)\n\t{\n\t\tif (try_repair)\n\t\t\t*try_repair = 1;\n\t\tfz_throw(ctx, FZ_ERROR_SYNTAX, \"expected 'obj' keyword (%d %d ?)\", num, gen);\n\t}\n\n\ttok = pdf_lex(ctx, file, buf);\n\n\tswitch (tok)\n\t{\n\tcase PDF_TOK_OPEN_ARRAY:\n\t\tobj = pdf_parse_array(ctx, doc, file, buf);\n\t\tbreak;\n\n\tcase PDF_TOK_OPEN_DICT:\n\t\tobj = pdf_parse_dict(ctx, doc, file, buf);\n\t\tbreak;\n\n\tcase PDF_TOK_NAME: obj = pdf_new_name(ctx, buf->scratch); break;\n\tcase PDF_TOK_REAL: obj = pdf_new_real(ctx, buf->f); break;\n\tcase PDF_TOK_STRING: obj = pdf_new_string(ctx, buf->scratch, buf->len); break;\n\tcase PDF_TOK_TRUE: obj = PDF_TRUE; break;\n\tcase PDF_TOK_FALSE: obj = PDF_FALSE; break;\n\tcase PDF_TOK_NULL: obj = PDF_NULL; break;\n\n\tcase PDF_TOK_INT:\n\t\ta = buf->i;\n\t\ttok = pdf_lex(ctx, file, buf);\n\n\t\tif (tok == PDF_TOK_STREAM || tok == PDF_TOK_ENDOBJ)\n\t\t{\n\t\t\tobj = pdf_new_int(ctx, a);\n\t\t\tread_next_token = 0;\n\t\t\tbreak;\n\t\t}\n\t\telse if (tok == PDF_TOK_INT)\n\t\t{\n\t\t\tb = buf->i;\n\t\t\ttok = pdf_lex(ctx, file, buf);\n\t\t\tif (tok == PDF_TOK_R)\n\t\t\t{\n\t\t\t\tobj = pdf_new_indirect(ctx, doc, a, b);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfz_throw(ctx, FZ_ERROR_SYNTAX, \"expected 'R' keyword (%d %d R)\", num, gen);\n\n\tcase PDF_TOK_ENDOBJ:\n\t\tobj = PDF_NULL;\n\t\tread_next_token = 0;\n\t\tbreak;\n\n\tdefault:\n\t\tfz_throw(ctx, FZ_ERROR_SYNTAX, \"syntax error in object (%d %d R)\", num, gen);\n\t}\n\n\tfz_try(ctx)\n\t{\n\t\tif (read_next_token)\n\t\t\ttok = pdf_lex(ctx, file, buf);\n\n\t\tif (tok == PDF_TOK_STREAM)\n\t\t{\n\t\t\tint c = fz_read_byte(ctx, file);\n\t\t\twhile (c == ' ')\n\t\t\t\tc = fz_read_byte(ctx, file);\n\t\t\tif (c == '\\r')\n\t\t\t{\n\t\t\t\tc = fz_peek_byte(ctx, file);\n\t\t\t\tif (c != '\\n')\n\t\t\t\t\tfz_warn(ctx, \"line feed missing after stream begin marker (%d %d R)\", num, gen);\n\t\t\t\telse\n\t\t\t\t\tfz_read_byte(ctx, file);\n\t\t\t}\n\t\t\tstm_ofs = fz_tell(ctx, file);\n\t\t}\n\t\telse if (tok == PDF_TOK_ENDOBJ)\n\t\t{\n\t\t\tstm_ofs = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfz_warn(ctx, \"expected 'endobj' or 'stream' keyword (%d %d R)\", num, gen);\n\t\t\tstm_ofs = 0;\n\t\t}\n\t}\n\tfz_catch(ctx)\n\t{\n\t\tpdf_drop_obj(ctx, obj);\n\t\tfz_rethrow(ctx);\n\t}\n\n\tif (onum) *onum = num;\n\tif (ogen) *ogen = gen;\n\tif (ostmofs) *ostmofs = stm_ofs;\n\n\treturn obj;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -31,6 +31,12 @@\n \t\tfz_throw(ctx, FZ_ERROR_SYNTAX, \"expected generation number (%d ? obj)\", num);\n \t}\n \tgen = buf->i;\n+\tif (gen < 0 || gen >= 65536)\n+\t{\n+\t\tif (try_repair)\n+\t\t\t*try_repair = 1;\n+\t\tfz_throw(ctx, FZ_ERROR_SYNTAX, \"invalid generation number (%d)\", gen);\n+\t}\n \n \ttok = pdf_lex(ctx, file, buf);\n \tif (tok != PDF_TOK_OBJ)",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tif (gen < 0 || gen >= 65536)",
                "\t{",
                "\t\tif (try_repair)",
                "\t\t\t*try_repair = 1;",
                "\t\tfz_throw(ctx, FZ_ERROR_SYNTAX, \"invalid generation number (%d)\", gen);",
                "\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-28041",
        "func_name": "openssh/openssh-portable/parse_key_constraints",
        "description": "ssh-agent in OpenSSH before 8.5 has a double free that may be relevant in a few less-common scenarios, such as unconstrained agent-socket access on a legacy operating system, or the forwarding of an agent to an attacker-controlled host.",
        "git_url": "https://github.com/openssh/openssh-portable/commit/e04fd6dde16de1cdc5a4d9946397ff60d96568db",
        "commit_title": "upstream: factor SSH_AGENT_CONSTRAIN_EXTENSION parsing into its own",
        "commit_text": " function and remove an unused variable; ok dtucker@  OpenBSD-Commit-ID: e1a938657fbf7ef0ba5e73b30365734a0cc96559",
        "func_before": "static int\nparse_key_constraints(struct sshbuf *m, struct sshkey *k, time_t *deathp,\n    u_int *secondsp, int *confirmp, char **sk_providerp)\n{\n\tu_char ctype;\n\tint r;\n\tu_int seconds, maxsign = 0;\n\tchar *ext_name = NULL;\n\tstruct sshbuf *b = NULL;\n\n\twhile (sshbuf_len(m)) {\n\t\tif ((r = sshbuf_get_u8(m, &ctype)) != 0) {\n\t\t\terror_fr(r, \"parse constraint type\");\n\t\t\tgoto err;\n\t\t}\n\t\tswitch (ctype) {\n\t\tcase SSH_AGENT_CONSTRAIN_LIFETIME:\n\t\t\tif (*deathp != 0) {\n\t\t\t\terror_f(\"lifetime already set\");\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tif ((r = sshbuf_get_u32(m, &seconds)) != 0) {\n\t\t\t\terror_fr(r, \"parse lifetime constraint\");\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\t*deathp = monotime() + seconds;\n\t\t\t*secondsp = seconds;\n\t\t\tbreak;\n\t\tcase SSH_AGENT_CONSTRAIN_CONFIRM:\n\t\t\tif (*confirmp != 0) {\n\t\t\t\terror_f(\"confirm already set\");\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\t*confirmp = 1;\n\t\t\tbreak;\n\t\tcase SSH_AGENT_CONSTRAIN_MAXSIGN:\n\t\t\tif (k == NULL) {\n\t\t\t\terror_f(\"maxsign not valid here\");\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tif (maxsign != 0) {\n\t\t\t\terror_f(\"maxsign already set\");\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tif ((r = sshbuf_get_u32(m, &maxsign)) != 0) {\n\t\t\t\terror_fr(r, \"parse maxsign constraint\");\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tif ((r = sshkey_enable_maxsign(k, maxsign)) != 0) {\n\t\t\t\terror_fr(r, \"enable maxsign\");\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SSH_AGENT_CONSTRAIN_EXTENSION:\n\t\t\tif ((r = sshbuf_get_cstring(m, &ext_name, NULL)) != 0) {\n\t\t\t\terror_fr(r, \"parse constraint extension\");\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tdebug_f(\"constraint ext %s\", ext_name);\n\t\t\tif (strcmp(ext_name, \"sk-provider@openssh.com\") == 0) {\n\t\t\t\tif (sk_providerp == NULL) {\n\t\t\t\t\terror_f(\"%s not valid here\", ext_name);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\tif (*sk_providerp != NULL) {\n\t\t\t\t\terror_f(\"%s already set\", ext_name);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t\tif ((r = sshbuf_get_cstring(m,\n\t\t\t\t    sk_providerp, NULL)) != 0) {\n\t\t\t\t\terror_fr(r, \"parse %s\", ext_name);\n\t\t\t\t\tgoto err;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\terror_f(\"unsupported constraint \\\"%s\\\"\",\n\t\t\t\t    ext_name);\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t\tfree(ext_name);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror_f(\"Unknown constraint %d\", ctype);\n err:\n\t\t\tfree(ext_name);\n\t\t\tsshbuf_free(b);\n\t\t\treturn -1;\n\t\t}\n\t}\n\t/* success */\n\treturn 0;\n}",
        "func": "static int\nparse_key_constraints(struct sshbuf *m, struct sshkey *k, time_t *deathp,\n    u_int *secondsp, int *confirmp, char **sk_providerp)\n{\n\tu_char ctype;\n\tint r;\n\tu_int seconds, maxsign = 0;\n\n\twhile (sshbuf_len(m)) {\n\t\tif ((r = sshbuf_get_u8(m, &ctype)) != 0) {\n\t\t\terror_fr(r, \"parse constraint type\");\n\t\t\tgoto out;\n\t\t}\n\t\tswitch (ctype) {\n\t\tcase SSH_AGENT_CONSTRAIN_LIFETIME:\n\t\t\tif (*deathp != 0) {\n\t\t\t\terror_f(\"lifetime already set\");\n\t\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif ((r = sshbuf_get_u32(m, &seconds)) != 0) {\n\t\t\t\terror_fr(r, \"parse lifetime constraint\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\t*deathp = monotime() + seconds;\n\t\t\t*secondsp = seconds;\n\t\t\tbreak;\n\t\tcase SSH_AGENT_CONSTRAIN_CONFIRM:\n\t\t\tif (*confirmp != 0) {\n\t\t\t\terror_f(\"confirm already set\");\n\t\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\t*confirmp = 1;\n\t\t\tbreak;\n\t\tcase SSH_AGENT_CONSTRAIN_MAXSIGN:\n\t\t\tif (k == NULL) {\n\t\t\t\terror_f(\"maxsign not valid here\");\n\t\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif (maxsign != 0) {\n\t\t\t\terror_f(\"maxsign already set\");\n\t\t\t\tr = SSH_ERR_INVALID_FORMAT;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif ((r = sshbuf_get_u32(m, &maxsign)) != 0) {\n\t\t\t\terror_fr(r, \"parse maxsign constraint\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tif ((r = sshkey_enable_maxsign(k, maxsign)) != 0) {\n\t\t\t\terror_fr(r, \"enable maxsign\");\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase SSH_AGENT_CONSTRAIN_EXTENSION:\n\t\t\tif ((r = parse_key_constraint_extension(m,\n\t\t\t    sk_providerp)) != 0)\n\t\t\t\tgoto out; /* error already logged */\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror_f(\"Unknown constraint %d\", ctype);\n\t\t\tr = SSH_ERR_FEATURE_UNSUPPORTED;\n\t\t\tgoto out;\n\t\t}\n\t}\n\t/* success */\n\tr = 0;\n out:\n\treturn r;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,23 +5,22 @@\n \tu_char ctype;\n \tint r;\n \tu_int seconds, maxsign = 0;\n-\tchar *ext_name = NULL;\n-\tstruct sshbuf *b = NULL;\n \n \twhile (sshbuf_len(m)) {\n \t\tif ((r = sshbuf_get_u8(m, &ctype)) != 0) {\n \t\t\terror_fr(r, \"parse constraint type\");\n-\t\t\tgoto err;\n+\t\t\tgoto out;\n \t\t}\n \t\tswitch (ctype) {\n \t\tcase SSH_AGENT_CONSTRAIN_LIFETIME:\n \t\t\tif (*deathp != 0) {\n \t\t\t\terror_f(\"lifetime already set\");\n-\t\t\t\tgoto err;\n+\t\t\t\tr = SSH_ERR_INVALID_FORMAT;\n+\t\t\t\tgoto out;\n \t\t\t}\n \t\t\tif ((r = sshbuf_get_u32(m, &seconds)) != 0) {\n \t\t\t\terror_fr(r, \"parse lifetime constraint\");\n-\t\t\t\tgoto err;\n+\t\t\t\tgoto out;\n \t\t\t}\n \t\t\t*deathp = monotime() + seconds;\n \t\t\t*secondsp = seconds;\n@@ -29,63 +28,44 @@\n \t\tcase SSH_AGENT_CONSTRAIN_CONFIRM:\n \t\t\tif (*confirmp != 0) {\n \t\t\t\terror_f(\"confirm already set\");\n-\t\t\t\tgoto err;\n+\t\t\t\tr = SSH_ERR_INVALID_FORMAT;\n+\t\t\t\tgoto out;\n \t\t\t}\n \t\t\t*confirmp = 1;\n \t\t\tbreak;\n \t\tcase SSH_AGENT_CONSTRAIN_MAXSIGN:\n \t\t\tif (k == NULL) {\n \t\t\t\terror_f(\"maxsign not valid here\");\n-\t\t\t\tgoto err;\n+\t\t\t\tr = SSH_ERR_INVALID_FORMAT;\n+\t\t\t\tgoto out;\n \t\t\t}\n \t\t\tif (maxsign != 0) {\n \t\t\t\terror_f(\"maxsign already set\");\n-\t\t\t\tgoto err;\n+\t\t\t\tr = SSH_ERR_INVALID_FORMAT;\n+\t\t\t\tgoto out;\n \t\t\t}\n \t\t\tif ((r = sshbuf_get_u32(m, &maxsign)) != 0) {\n \t\t\t\terror_fr(r, \"parse maxsign constraint\");\n-\t\t\t\tgoto err;\n+\t\t\t\tgoto out;\n \t\t\t}\n \t\t\tif ((r = sshkey_enable_maxsign(k, maxsign)) != 0) {\n \t\t\t\terror_fr(r, \"enable maxsign\");\n-\t\t\t\tgoto err;\n+\t\t\t\tgoto out;\n \t\t\t}\n \t\t\tbreak;\n \t\tcase SSH_AGENT_CONSTRAIN_EXTENSION:\n-\t\t\tif ((r = sshbuf_get_cstring(m, &ext_name, NULL)) != 0) {\n-\t\t\t\terror_fr(r, \"parse constraint extension\");\n-\t\t\t\tgoto err;\n-\t\t\t}\n-\t\t\tdebug_f(\"constraint ext %s\", ext_name);\n-\t\t\tif (strcmp(ext_name, \"sk-provider@openssh.com\") == 0) {\n-\t\t\t\tif (sk_providerp == NULL) {\n-\t\t\t\t\terror_f(\"%s not valid here\", ext_name);\n-\t\t\t\t\tgoto err;\n-\t\t\t\t}\n-\t\t\t\tif (*sk_providerp != NULL) {\n-\t\t\t\t\terror_f(\"%s already set\", ext_name);\n-\t\t\t\t\tgoto err;\n-\t\t\t\t}\n-\t\t\t\tif ((r = sshbuf_get_cstring(m,\n-\t\t\t\t    sk_providerp, NULL)) != 0) {\n-\t\t\t\t\terror_fr(r, \"parse %s\", ext_name);\n-\t\t\t\t\tgoto err;\n-\t\t\t\t}\n-\t\t\t} else {\n-\t\t\t\terror_f(\"unsupported constraint \\\"%s\\\"\",\n-\t\t\t\t    ext_name);\n-\t\t\t\tgoto err;\n-\t\t\t}\n-\t\t\tfree(ext_name);\n+\t\t\tif ((r = parse_key_constraint_extension(m,\n+\t\t\t    sk_providerp)) != 0)\n+\t\t\t\tgoto out; /* error already logged */\n \t\t\tbreak;\n \t\tdefault:\n \t\t\terror_f(\"Unknown constraint %d\", ctype);\n- err:\n-\t\t\tfree(ext_name);\n-\t\t\tsshbuf_free(b);\n-\t\t\treturn -1;\n+\t\t\tr = SSH_ERR_FEATURE_UNSUPPORTED;\n+\t\t\tgoto out;\n \t\t}\n \t}\n \t/* success */\n-\treturn 0;\n+\tr = 0;\n+ out:\n+\treturn r;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tchar *ext_name = NULL;",
                "\tstruct sshbuf *b = NULL;",
                "\t\t\tgoto err;",
                "\t\t\t\tgoto err;",
                "\t\t\t\tgoto err;",
                "\t\t\t\tgoto err;",
                "\t\t\t\tgoto err;",
                "\t\t\t\tgoto err;",
                "\t\t\t\tgoto err;",
                "\t\t\t\tgoto err;",
                "\t\t\tif ((r = sshbuf_get_cstring(m, &ext_name, NULL)) != 0) {",
                "\t\t\t\terror_fr(r, \"parse constraint extension\");",
                "\t\t\t\tgoto err;",
                "\t\t\t}",
                "\t\t\tdebug_f(\"constraint ext %s\", ext_name);",
                "\t\t\tif (strcmp(ext_name, \"sk-provider@openssh.com\") == 0) {",
                "\t\t\t\tif (sk_providerp == NULL) {",
                "\t\t\t\t\terror_f(\"%s not valid here\", ext_name);",
                "\t\t\t\t\tgoto err;",
                "\t\t\t\t}",
                "\t\t\t\tif (*sk_providerp != NULL) {",
                "\t\t\t\t\terror_f(\"%s already set\", ext_name);",
                "\t\t\t\t\tgoto err;",
                "\t\t\t\t}",
                "\t\t\t\tif ((r = sshbuf_get_cstring(m,",
                "\t\t\t\t    sk_providerp, NULL)) != 0) {",
                "\t\t\t\t\terror_fr(r, \"parse %s\", ext_name);",
                "\t\t\t\t\tgoto err;",
                "\t\t\t\t}",
                "\t\t\t} else {",
                "\t\t\t\terror_f(\"unsupported constraint \\\"%s\\\"\",",
                "\t\t\t\t    ext_name);",
                "\t\t\t\tgoto err;",
                "\t\t\t}",
                "\t\t\tfree(ext_name);",
                " err:",
                "\t\t\tfree(ext_name);",
                "\t\t\tsshbuf_free(b);",
                "\t\t\treturn -1;",
                "\treturn 0;"
            ],
            "added_lines": [
                "\t\t\tgoto out;",
                "\t\t\t\tr = SSH_ERR_INVALID_FORMAT;",
                "\t\t\t\tgoto out;",
                "\t\t\t\tgoto out;",
                "\t\t\t\tr = SSH_ERR_INVALID_FORMAT;",
                "\t\t\t\tgoto out;",
                "\t\t\t\tr = SSH_ERR_INVALID_FORMAT;",
                "\t\t\t\tgoto out;",
                "\t\t\t\tr = SSH_ERR_INVALID_FORMAT;",
                "\t\t\t\tgoto out;",
                "\t\t\t\tgoto out;",
                "\t\t\t\tgoto out;",
                "\t\t\tif ((r = parse_key_constraint_extension(m,",
                "\t\t\t    sk_providerp)) != 0)",
                "\t\t\t\tgoto out; /* error already logged */",
                "\t\t\tr = SSH_ERR_FEATURE_UNSUPPORTED;",
                "\t\t\tgoto out;",
                "\tr = 0;",
                " out:",
                "\treturn r;"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-39975",
        "func_name": "krb5/tgs_issue_ticket",
        "description": "kdc/do_tgs_req.c in MIT Kerberos 5 (aka krb5) 1.21 before 1.21.2 has a double free that is reachable if an authenticated user can trigger an authorization-data handling failure. Incorrect data is copied from one ticket to another.",
        "git_url": "https://github.com/krb5/krb5/commit/88a1701b423c13991a8064feeb26952d3641d840",
        "commit_title": "Fix double-free in KDC TGS processing",
        "commit_text": " When issuing a ticket for a TGS renew or validate request, copy only the server field from the outer part of the header ticket to the new ticket.  Copying the whole structure causes the enc_part pointer to be aliased to the header ticket until krb5_encrypt_tkt_part() is called, resulting in a double-free if handle_authdata() fails.  [ghudson@mit.edu: changed the fix to avoid aliasing enc_part rather than check for aliasing before freeing; rewrote commit message]  CVE-2023-39975:  In MIT krb5 release 1.21, an authenticated attacker can cause a KDC to free the same pointer twice if it can induce a failure in authorization data handling.  ticket: 9101 (new) tags: pullup target_version: 1.21-next",
        "func_before": "static krb5_error_code\ntgs_issue_ticket(kdc_realm_t *realm, struct tgs_req_info *t,\n                 krb5_flags tktflags, krb5_ticket_times *times, krb5_data *pkt,\n                 const krb5_fulladdr *from,\n                 struct kdc_request_state *fast_state,\n                 krb5_audit_state *au_state, const char **status,\n                 krb5_data **response)\n{\n    krb5_context context = realm->realm_context;\n    krb5_error_code ret;\n    krb5_keyblock session_key = { 0 }, server_key = { 0 };\n    krb5_keyblock *ticket_encrypting_key, *subject_key;\n    krb5_keyblock *initial_reply_key, *fast_reply_key = NULL;\n    krb5_enc_tkt_part enc_tkt_reply = { 0 };\n    krb5_ticket ticket_reply = { 0 };\n    krb5_enc_kdc_rep_part reply_encpart = { 0 };\n    krb5_kdc_rep reply = { 0 };\n    krb5_pac subject_pac;\n    krb5_db_entry *subject_server;\n    krb5_enc_tkt_part *header_enc_tkt = t->header_tkt->enc_part2;\n    krb5_last_req_entry nolrentry = { KV5M_LAST_REQ_ENTRY, KRB5_LRQ_NONE, 0 };\n    krb5_last_req_entry *nolrarray[2] = { &nolrentry, NULL };\n\n    au_state->stage = ISSUE_TKT;\n\n    ret = gen_session_key(context, t->req, t->server, &session_key, status);\n    if (ret)\n        goto cleanup;\n\n    if (t->flags & KRB5_KDB_FLAG_CONSTRAINED_DELEGATION) {\n        subject_pac = t->stkt_pac;\n        subject_server = t->stkt_server;\n        subject_key = t->stkt_server_key;\n    } else {\n        subject_pac = t->header_pac;\n        subject_server = t->header_server;\n        subject_key = t->header_key;\n    }\n\n    initial_reply_key = (t->subkey != NULL) ? t->subkey :\n        t->header_tkt->enc_part2->session;\n\n    if (t->req->kdc_options & KDC_OPT_ENC_TKT_IN_SKEY) {\n        /* For user-to-user, encrypt the ticket with the second ticket's\n         * session key. */\n        ticket_encrypting_key = t->stkt->enc_part2->session;\n    } else {\n        /* Otherwise encrypt the ticket with the server entry's first long-term\n         * key. */\n        ret = get_first_current_key(context, t->server, &server_key);\n        if (ret) {\n            *status = \"FINDING_SERVER_KEY\";\n            goto cleanup;\n        }\n        ticket_encrypting_key = &server_key;\n    }\n\n    if (t->req->kdc_options & (KDC_OPT_VALIDATE | KDC_OPT_RENEW)) {\n        /* Copy the whole header ticket except for authorization data. */\n        ticket_reply = *t->header_tkt;\n        enc_tkt_reply = *t->header_tkt->enc_part2;\n        enc_tkt_reply.authorization_data = NULL;\n    } else {\n        if (t->req->kdc_options & (KDC_OPT_FORWARDED | KDC_OPT_PROXY)) {\n            /* Include the requested addresses in the ticket and reply. */\n            enc_tkt_reply.caddrs = t->req->addresses;\n            reply_encpart.caddrs = t->req->addresses;\n        } else {\n            /* Use the header ticket addresses and omit them from the reply. */\n            enc_tkt_reply.caddrs = header_enc_tkt->caddrs;\n            reply_encpart.caddrs = NULL;\n        }\n\n        ticket_reply.server = t->is_referral ? t->sprinc : t->req->server;\n    }\n\n    enc_tkt_reply.flags = tktflags;\n    enc_tkt_reply.times = *times;\n    enc_tkt_reply.client = t->tkt_client;\n    enc_tkt_reply.session = &session_key;\n    enc_tkt_reply.transited = t->transited;\n\n    ret = handle_authdata(realm, t->flags, t->client, t->server,\n                          subject_server, t->local_tgt, &t->local_tgt_key,\n                          initial_reply_key, ticket_encrypting_key,\n                          subject_key, NULL, pkt, t->req, t->s4u_cprinc,\n                          subject_pac, t->subject_tkt, &t->auth_indicators,\n                          &enc_tkt_reply);\n    if (ret) {\n        krb5_klog_syslog(LOG_INFO, _(\"TGS_REQ : handle_authdata (%d)\"), ret);\n        *status = \"HANDLE_AUTHDATA\";\n        goto cleanup;\n    }\n\n    ticket_reply.enc_part2 = &enc_tkt_reply;\n\n    ret = krb5_encrypt_tkt_part(context, ticket_encrypting_key, &ticket_reply);\n    if (ret)\n        goto cleanup;\n\n    if (t->req->kdc_options & KDC_OPT_ENC_TKT_IN_SKEY) {\n        ticket_reply.enc_part.kvno = 0;\n        kau_u2u(context, TRUE, au_state);\n    } else {\n        ticket_reply.enc_part.kvno = current_kvno(t->server);\n    }\n\n    au_state->stage = ENCR_REP;\n\n    if (t->s4u2self != NULL &&\n        krb5int_find_pa_data(context, t->req->padata,\n                             KRB5_PADATA_S4U_X509_USER) != NULL) {\n        /* Add an S4U2Self response to the encrypted padata (skipped if the\n         * request only included PA-FOR-USER padata). */\n        ret = kdc_make_s4u2self_rep(context, t->subkey,\n                                    t->header_tkt->enc_part2->session,\n                                    t->s4u2self, &reply, &reply_encpart);\n        if (ret)\n            goto cleanup;\n    }\n\n    reply_encpart.session = &session_key;\n    reply_encpart.nonce = t->req->nonce;\n    reply_encpart.times = enc_tkt_reply.times;\n    reply_encpart.last_req = nolrarray;\n    reply_encpart.key_exp = 0;\n    reply_encpart.flags = enc_tkt_reply.flags;\n    reply_encpart.server = ticket_reply.server;\n\n    reply.msg_type = KRB5_TGS_REP;\n    reply.client = enc_tkt_reply.client;\n    reply.ticket = &ticket_reply;\n    reply.enc_part.kvno = 0;\n    reply.enc_part.enctype = initial_reply_key->enctype;\n    ret = kdc_fast_response_handle_padata(fast_state, t->req, &reply,\n                                          initial_reply_key->enctype);\n    if (ret)\n        goto cleanup;\n    ret = kdc_fast_handle_reply_key(fast_state, initial_reply_key,\n                                    &fast_reply_key);\n    if (ret)\n        goto cleanup;\n    ret = return_enc_padata(context, pkt, t->req, fast_reply_key, t->server,\n                            &reply_encpart,\n                            t->is_referral &&\n                            (t->req->kdc_options & KDC_OPT_CANONICALIZE));\n    if (ret) {\n        *status = \"KDC_RETURN_ENC_PADATA\";\n        goto cleanup;\n    }\n\n    ret = kau_make_tkt_id(context, &ticket_reply, &au_state->tkt_out_id);\n    if (ret)\n        goto cleanup;\n\n    if (kdc_fast_hide_client(fast_state))\n        reply.client = (krb5_principal)krb5_anonymous_principal();\n    ret = krb5_encode_kdc_rep(context, KRB5_TGS_REP, &reply_encpart,\n                              t->subkey != NULL, fast_reply_key, &reply,\n                              response);\n    if (ret)\n        goto cleanup;\n\n    log_tgs_req(context, from, t->req, &reply, t->cprinc, t->sprinc,\n                t->s4u_cprinc, t->authtime, t->flags, \"ISSUE\", 0, NULL);\n    au_state->status = \"ISSUE\";\n    au_state->reply = &reply;\n    if (t->flags & KRB5_KDB_FLAG_CONSTRAINED_DELEGATION)\n        kau_s4u2proxy(context, TRUE, au_state);\n    kau_tgs_req(context, TRUE, au_state);\n    au_state->reply = NULL;\n\ncleanup:\n    zapfree(ticket_reply.enc_part.ciphertext.data,\n            ticket_reply.enc_part.ciphertext.length);\n    zapfree(reply.enc_part.ciphertext.data, reply.enc_part.ciphertext.length);\n    krb5_free_pa_data(context, reply.padata);\n    krb5_free_pa_data(context, reply_encpart.enc_padata);\n    krb5_free_authdata(context, enc_tkt_reply.authorization_data);\n    krb5_free_keyblock_contents(context, &session_key);\n    krb5_free_keyblock_contents(context, &server_key);\n    krb5_free_keyblock(context, fast_reply_key);\n    return ret;\n}",
        "func": "static krb5_error_code\ntgs_issue_ticket(kdc_realm_t *realm, struct tgs_req_info *t,\n                 krb5_flags tktflags, krb5_ticket_times *times, krb5_data *pkt,\n                 const krb5_fulladdr *from,\n                 struct kdc_request_state *fast_state,\n                 krb5_audit_state *au_state, const char **status,\n                 krb5_data **response)\n{\n    krb5_context context = realm->realm_context;\n    krb5_error_code ret;\n    krb5_keyblock session_key = { 0 }, server_key = { 0 };\n    krb5_keyblock *ticket_encrypting_key, *subject_key;\n    krb5_keyblock *initial_reply_key, *fast_reply_key = NULL;\n    krb5_enc_tkt_part enc_tkt_reply = { 0 };\n    krb5_ticket ticket_reply = { 0 };\n    krb5_enc_kdc_rep_part reply_encpart = { 0 };\n    krb5_kdc_rep reply = { 0 };\n    krb5_pac subject_pac;\n    krb5_db_entry *subject_server;\n    krb5_enc_tkt_part *header_enc_tkt = t->header_tkt->enc_part2;\n    krb5_last_req_entry nolrentry = { KV5M_LAST_REQ_ENTRY, KRB5_LRQ_NONE, 0 };\n    krb5_last_req_entry *nolrarray[2] = { &nolrentry, NULL };\n\n    au_state->stage = ISSUE_TKT;\n\n    ret = gen_session_key(context, t->req, t->server, &session_key, status);\n    if (ret)\n        goto cleanup;\n\n    if (t->flags & KRB5_KDB_FLAG_CONSTRAINED_DELEGATION) {\n        subject_pac = t->stkt_pac;\n        subject_server = t->stkt_server;\n        subject_key = t->stkt_server_key;\n    } else {\n        subject_pac = t->header_pac;\n        subject_server = t->header_server;\n        subject_key = t->header_key;\n    }\n\n    initial_reply_key = (t->subkey != NULL) ? t->subkey :\n        t->header_tkt->enc_part2->session;\n\n    if (t->req->kdc_options & KDC_OPT_ENC_TKT_IN_SKEY) {\n        /* For user-to-user, encrypt the ticket with the second ticket's\n         * session key. */\n        ticket_encrypting_key = t->stkt->enc_part2->session;\n    } else {\n        /* Otherwise encrypt the ticket with the server entry's first long-term\n         * key. */\n        ret = get_first_current_key(context, t->server, &server_key);\n        if (ret) {\n            *status = \"FINDING_SERVER_KEY\";\n            goto cleanup;\n        }\n        ticket_encrypting_key = &server_key;\n    }\n\n    if (t->req->kdc_options & (KDC_OPT_VALIDATE | KDC_OPT_RENEW)) {\n        /* Copy the header ticket server and all enc-part fields except for\n         * authorization data. */\n        ticket_reply.server = t->header_tkt->server;\n        enc_tkt_reply = *t->header_tkt->enc_part2;\n        enc_tkt_reply.authorization_data = NULL;\n    } else {\n        if (t->req->kdc_options & (KDC_OPT_FORWARDED | KDC_OPT_PROXY)) {\n            /* Include the requested addresses in the ticket and reply. */\n            enc_tkt_reply.caddrs = t->req->addresses;\n            reply_encpart.caddrs = t->req->addresses;\n        } else {\n            /* Use the header ticket addresses and omit them from the reply. */\n            enc_tkt_reply.caddrs = header_enc_tkt->caddrs;\n            reply_encpart.caddrs = NULL;\n        }\n\n        ticket_reply.server = t->is_referral ? t->sprinc : t->req->server;\n    }\n\n    enc_tkt_reply.flags = tktflags;\n    enc_tkt_reply.times = *times;\n    enc_tkt_reply.client = t->tkt_client;\n    enc_tkt_reply.session = &session_key;\n    enc_tkt_reply.transited = t->transited;\n\n    ret = handle_authdata(realm, t->flags, t->client, t->server,\n                          subject_server, t->local_tgt, &t->local_tgt_key,\n                          initial_reply_key, ticket_encrypting_key,\n                          subject_key, NULL, pkt, t->req, t->s4u_cprinc,\n                          subject_pac, t->subject_tkt, &t->auth_indicators,\n                          &enc_tkt_reply);\n    if (ret) {\n        krb5_klog_syslog(LOG_INFO, _(\"TGS_REQ : handle_authdata (%d)\"), ret);\n        *status = \"HANDLE_AUTHDATA\";\n        goto cleanup;\n    }\n\n    ticket_reply.enc_part2 = &enc_tkt_reply;\n\n    ret = krb5_encrypt_tkt_part(context, ticket_encrypting_key, &ticket_reply);\n    if (ret)\n        goto cleanup;\n\n    if (t->req->kdc_options & KDC_OPT_ENC_TKT_IN_SKEY) {\n        ticket_reply.enc_part.kvno = 0;\n        kau_u2u(context, TRUE, au_state);\n    } else {\n        ticket_reply.enc_part.kvno = current_kvno(t->server);\n    }\n\n    au_state->stage = ENCR_REP;\n\n    if (t->s4u2self != NULL &&\n        krb5int_find_pa_data(context, t->req->padata,\n                             KRB5_PADATA_S4U_X509_USER) != NULL) {\n        /* Add an S4U2Self response to the encrypted padata (skipped if the\n         * request only included PA-FOR-USER padata). */\n        ret = kdc_make_s4u2self_rep(context, t->subkey,\n                                    t->header_tkt->enc_part2->session,\n                                    t->s4u2self, &reply, &reply_encpart);\n        if (ret)\n            goto cleanup;\n    }\n\n    reply_encpart.session = &session_key;\n    reply_encpart.nonce = t->req->nonce;\n    reply_encpart.times = enc_tkt_reply.times;\n    reply_encpart.last_req = nolrarray;\n    reply_encpart.key_exp = 0;\n    reply_encpart.flags = enc_tkt_reply.flags;\n    reply_encpart.server = ticket_reply.server;\n\n    reply.msg_type = KRB5_TGS_REP;\n    reply.client = enc_tkt_reply.client;\n    reply.ticket = &ticket_reply;\n    reply.enc_part.kvno = 0;\n    reply.enc_part.enctype = initial_reply_key->enctype;\n    ret = kdc_fast_response_handle_padata(fast_state, t->req, &reply,\n                                          initial_reply_key->enctype);\n    if (ret)\n        goto cleanup;\n    ret = kdc_fast_handle_reply_key(fast_state, initial_reply_key,\n                                    &fast_reply_key);\n    if (ret)\n        goto cleanup;\n    ret = return_enc_padata(context, pkt, t->req, fast_reply_key, t->server,\n                            &reply_encpart,\n                            t->is_referral &&\n                            (t->req->kdc_options & KDC_OPT_CANONICALIZE));\n    if (ret) {\n        *status = \"KDC_RETURN_ENC_PADATA\";\n        goto cleanup;\n    }\n\n    ret = kau_make_tkt_id(context, &ticket_reply, &au_state->tkt_out_id);\n    if (ret)\n        goto cleanup;\n\n    if (kdc_fast_hide_client(fast_state))\n        reply.client = (krb5_principal)krb5_anonymous_principal();\n    ret = krb5_encode_kdc_rep(context, KRB5_TGS_REP, &reply_encpart,\n                              t->subkey != NULL, fast_reply_key, &reply,\n                              response);\n    if (ret)\n        goto cleanup;\n\n    log_tgs_req(context, from, t->req, &reply, t->cprinc, t->sprinc,\n                t->s4u_cprinc, t->authtime, t->flags, \"ISSUE\", 0, NULL);\n    au_state->status = \"ISSUE\";\n    au_state->reply = &reply;\n    if (t->flags & KRB5_KDB_FLAG_CONSTRAINED_DELEGATION)\n        kau_s4u2proxy(context, TRUE, au_state);\n    kau_tgs_req(context, TRUE, au_state);\n    au_state->reply = NULL;\n\ncleanup:\n    zapfree(ticket_reply.enc_part.ciphertext.data,\n            ticket_reply.enc_part.ciphertext.length);\n    zapfree(reply.enc_part.ciphertext.data, reply.enc_part.ciphertext.length);\n    krb5_free_pa_data(context, reply.padata);\n    krb5_free_pa_data(context, reply_encpart.enc_padata);\n    krb5_free_authdata(context, enc_tkt_reply.authorization_data);\n    krb5_free_keyblock_contents(context, &session_key);\n    krb5_free_keyblock_contents(context, &server_key);\n    krb5_free_keyblock(context, fast_reply_key);\n    return ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -56,8 +56,9 @@\n     }\n \n     if (t->req->kdc_options & (KDC_OPT_VALIDATE | KDC_OPT_RENEW)) {\n-        /* Copy the whole header ticket except for authorization data. */\n-        ticket_reply = *t->header_tkt;\n+        /* Copy the header ticket server and all enc-part fields except for\n+         * authorization data. */\n+        ticket_reply.server = t->header_tkt->server;\n         enc_tkt_reply = *t->header_tkt->enc_part2;\n         enc_tkt_reply.authorization_data = NULL;\n     } else {",
        "diff_line_info": {
            "deleted_lines": [
                "        /* Copy the whole header ticket except for authorization data. */",
                "        ticket_reply = *t->header_tkt;"
            ],
            "added_lines": [
                "        /* Copy the header ticket server and all enc-part fields except for",
                "         * authorization data. */",
                "        ticket_reply.server = t->header_tkt->server;"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-8099",
        "func_name": "libgit2/parse_index",
        "description": "Incorrect returning of an error code in the index.c:read_entry() function leads to a double free in libgit2 before v0.26.2, which allows an attacker to cause a denial of service via a crafted repository index file.",
        "git_url": "https://github.com/libgit2/libgit2/commit/58a6fe94cb851f71214dbefac3f9bffee437d6fe",
        "commit_title": "index: convert `read_entry` to return entry size via an out-param",
        "commit_text": " The function `read_entry` does not conform to our usual coding style of returning stuff via the out parameter and to use the return value for reporting errors. Due to most of our code conforming to that pattern, it has become quite natural for us to actually return `-1` in case there is any error, which has also slipped in with commit 5625d86b9 (index: support index v4, 2016-05-17). As the function returns an `size_t` only, though, the return value is wrapped around, causing the caller of `read_tree` to continue with an invalid index entry. Ultimately, this can lead to a double-free.  Improve code and fix the bug by converting the function to return the index entry size via an out parameter and only using the return value to indicate errors. ",
        "func_before": "static int parse_index(git_index *index, const char *buffer, size_t buffer_size)\n{\n\tint error = 0;\n\tunsigned int i;\n\tstruct index_header header = { 0 };\n\tgit_oid checksum_calculated, checksum_expected;\n\tconst char *last = NULL;\n\tconst char *empty = \"\";\n\n#define seek_forward(_increase) { \\\n\tif (_increase >= buffer_size) { \\\n\t\terror = index_error_invalid(\"ran out of data while parsing\"); \\\n\t\tgoto done; } \\\n\tbuffer += _increase; \\\n\tbuffer_size -= _increase;\\\n}\n\n\tif (buffer_size < INDEX_HEADER_SIZE + INDEX_FOOTER_SIZE)\n\t\treturn index_error_invalid(\"insufficient buffer space\");\n\n\t/* Precalculate the SHA1 of the files's contents -- we'll match it to\n\t * the provided SHA1 in the footer */\n\tgit_hash_buf(&checksum_calculated, buffer, buffer_size - INDEX_FOOTER_SIZE);\n\n\t/* Parse header */\n\tif ((error = read_header(&header, buffer)) < 0)\n\t\treturn error;\n\n\tindex->version = header.version;\n\tif (index->version >= INDEX_VERSION_NUMBER_COMP)\n\t\tlast = empty;\n\n\tseek_forward(INDEX_HEADER_SIZE);\n\n\tassert(!index->entries.length);\n\n\tif (index->ignore_case)\n\t\tgit_idxmap_icase_resize((khash_t(idxicase) *) index->entries_map, header.entry_count);\n\telse\n\t\tgit_idxmap_resize(index->entries_map, header.entry_count);\n\n\t/* Parse all the entries */\n\tfor (i = 0; i < header.entry_count && buffer_size > INDEX_FOOTER_SIZE; ++i) {\n\t\tgit_index_entry *entry = NULL;\n\t\tsize_t entry_size = read_entry(&entry, index, buffer, buffer_size, last);\n\n\t\t/* 0 bytes read means an object corruption */\n\t\tif (entry_size == 0) {\n\t\t\terror = index_error_invalid(\"invalid entry\");\n\t\t\tgoto done;\n\t\t}\n\n\t\tif ((error = git_vector_insert(&index->entries, entry)) < 0) {\n\t\t\tindex_entry_free(entry);\n\t\t\tgoto done;\n\t\t}\n\n\t\tINSERT_IN_MAP(index, entry, &error);\n\n\t\tif (error < 0) {\n\t\t\tindex_entry_free(entry);\n\t\t\tgoto done;\n\t\t}\n\t\terror = 0;\n\n\t\tif (index->version >= INDEX_VERSION_NUMBER_COMP)\n\t\t\tlast = entry->path;\n\n\t\tseek_forward(entry_size);\n\t}\n\n\tif (i != header.entry_count) {\n\t\terror = index_error_invalid(\"header entries changed while parsing\");\n\t\tgoto done;\n\t}\n\n\t/* There's still space for some extensions! */\n\twhile (buffer_size > INDEX_FOOTER_SIZE) {\n\t\tsize_t extension_size;\n\n\t\textension_size = read_extension(index, buffer, buffer_size);\n\n\t\t/* see if we have read any bytes from the extension */\n\t\tif (extension_size == 0) {\n\t\t\terror = index_error_invalid(\"extension is truncated\");\n\t\t\tgoto done;\n\t\t}\n\n\t\tseek_forward(extension_size);\n\t}\n\n\tif (buffer_size != INDEX_FOOTER_SIZE) {\n\t\terror = index_error_invalid(\n\t\t\t\"buffer size does not match index footer size\");\n\t\tgoto done;\n\t}\n\n\t/* 160-bit SHA-1 over the content of the index file before this checksum. */\n\tgit_oid_fromraw(&checksum_expected, (const unsigned char *)buffer);\n\n\tif (git_oid__cmp(&checksum_calculated, &checksum_expected) != 0) {\n\t\terror = index_error_invalid(\n\t\t\t\"calculated checksum does not match expected\");\n\t\tgoto done;\n\t}\n\n\tgit_oid_cpy(&index->checksum, &checksum_calculated);\n\n#undef seek_forward\n\n\t/* Entries are stored case-sensitively on disk, so re-sort now if\n\t * in-memory index is supposed to be case-insensitive\n\t */\n\tgit_vector_set_sorted(&index->entries, !index->ignore_case);\n\tgit_vector_sort(&index->entries);\n\ndone:\n\treturn error;\n}",
        "func": "static int parse_index(git_index *index, const char *buffer, size_t buffer_size)\n{\n\tint error = 0;\n\tunsigned int i;\n\tstruct index_header header = { 0 };\n\tgit_oid checksum_calculated, checksum_expected;\n\tconst char *last = NULL;\n\tconst char *empty = \"\";\n\n#define seek_forward(_increase) { \\\n\tif (_increase >= buffer_size) { \\\n\t\terror = index_error_invalid(\"ran out of data while parsing\"); \\\n\t\tgoto done; } \\\n\tbuffer += _increase; \\\n\tbuffer_size -= _increase;\\\n}\n\n\tif (buffer_size < INDEX_HEADER_SIZE + INDEX_FOOTER_SIZE)\n\t\treturn index_error_invalid(\"insufficient buffer space\");\n\n\t/* Precalculate the SHA1 of the files's contents -- we'll match it to\n\t * the provided SHA1 in the footer */\n\tgit_hash_buf(&checksum_calculated, buffer, buffer_size - INDEX_FOOTER_SIZE);\n\n\t/* Parse header */\n\tif ((error = read_header(&header, buffer)) < 0)\n\t\treturn error;\n\n\tindex->version = header.version;\n\tif (index->version >= INDEX_VERSION_NUMBER_COMP)\n\t\tlast = empty;\n\n\tseek_forward(INDEX_HEADER_SIZE);\n\n\tassert(!index->entries.length);\n\n\tif (index->ignore_case)\n\t\tgit_idxmap_icase_resize((khash_t(idxicase) *) index->entries_map, header.entry_count);\n\telse\n\t\tgit_idxmap_resize(index->entries_map, header.entry_count);\n\n\t/* Parse all the entries */\n\tfor (i = 0; i < header.entry_count && buffer_size > INDEX_FOOTER_SIZE; ++i) {\n\t\tgit_index_entry *entry = NULL;\n\t\tsize_t entry_size;\n\n\t\tif ((error = read_entry(&entry, &entry_size, index, buffer, buffer_size, last)) < 0) {\n\t\t\terror = index_error_invalid(\"invalid entry\");\n\t\t\tgoto done;\n\t\t}\n\n\t\tif ((error = git_vector_insert(&index->entries, entry)) < 0) {\n\t\t\tindex_entry_free(entry);\n\t\t\tgoto done;\n\t\t}\n\n\t\tINSERT_IN_MAP(index, entry, &error);\n\n\t\tif (error < 0) {\n\t\t\tindex_entry_free(entry);\n\t\t\tgoto done;\n\t\t}\n\t\terror = 0;\n\n\t\tif (index->version >= INDEX_VERSION_NUMBER_COMP)\n\t\t\tlast = entry->path;\n\n\t\tseek_forward(entry_size);\n\t}\n\n\tif (i != header.entry_count) {\n\t\terror = index_error_invalid(\"header entries changed while parsing\");\n\t\tgoto done;\n\t}\n\n\t/* There's still space for some extensions! */\n\twhile (buffer_size > INDEX_FOOTER_SIZE) {\n\t\tsize_t extension_size;\n\n\t\textension_size = read_extension(index, buffer, buffer_size);\n\n\t\t/* see if we have read any bytes from the extension */\n\t\tif (extension_size == 0) {\n\t\t\terror = index_error_invalid(\"extension is truncated\");\n\t\t\tgoto done;\n\t\t}\n\n\t\tseek_forward(extension_size);\n\t}\n\n\tif (buffer_size != INDEX_FOOTER_SIZE) {\n\t\terror = index_error_invalid(\n\t\t\t\"buffer size does not match index footer size\");\n\t\tgoto done;\n\t}\n\n\t/* 160-bit SHA-1 over the content of the index file before this checksum. */\n\tgit_oid_fromraw(&checksum_expected, (const unsigned char *)buffer);\n\n\tif (git_oid__cmp(&checksum_calculated, &checksum_expected) != 0) {\n\t\terror = index_error_invalid(\n\t\t\t\"calculated checksum does not match expected\");\n\t\tgoto done;\n\t}\n\n\tgit_oid_cpy(&index->checksum, &checksum_calculated);\n\n#undef seek_forward\n\n\t/* Entries are stored case-sensitively on disk, so re-sort now if\n\t * in-memory index is supposed to be case-insensitive\n\t */\n\tgit_vector_set_sorted(&index->entries, !index->ignore_case);\n\tgit_vector_sort(&index->entries);\n\ndone:\n\treturn error;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -42,10 +42,9 @@\n \t/* Parse all the entries */\n \tfor (i = 0; i < header.entry_count && buffer_size > INDEX_FOOTER_SIZE; ++i) {\n \t\tgit_index_entry *entry = NULL;\n-\t\tsize_t entry_size = read_entry(&entry, index, buffer, buffer_size, last);\n+\t\tsize_t entry_size;\n \n-\t\t/* 0 bytes read means an object corruption */\n-\t\tif (entry_size == 0) {\n+\t\tif ((error = read_entry(&entry, &entry_size, index, buffer, buffer_size, last)) < 0) {\n \t\t\terror = index_error_invalid(\"invalid entry\");\n \t\t\tgoto done;\n \t\t}",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tsize_t entry_size = read_entry(&entry, index, buffer, buffer_size, last);",
                "\t\t/* 0 bytes read means an object corruption */",
                "\t\tif (entry_size == 0) {"
            ],
            "added_lines": [
                "\t\tsize_t entry_size;",
                "\t\tif ((error = read_entry(&entry, &entry_size, index, buffer, buffer_size, last)) < 0) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-8099",
        "func_name": "libgit2/read_entry",
        "description": "Incorrect returning of an error code in the index.c:read_entry() function leads to a double free in libgit2 before v0.26.2, which allows an attacker to cause a denial of service via a crafted repository index file.",
        "git_url": "https://github.com/libgit2/libgit2/commit/58a6fe94cb851f71214dbefac3f9bffee437d6fe",
        "commit_title": "index: convert `read_entry` to return entry size via an out-param",
        "commit_text": " The function `read_entry` does not conform to our usual coding style of returning stuff via the out parameter and to use the return value for reporting errors. Due to most of our code conforming to that pattern, it has become quite natural for us to actually return `-1` in case there is any error, which has also slipped in with commit 5625d86b9 (index: support index v4, 2016-05-17). As the function returns an `size_t` only, though, the return value is wrapped around, causing the caller of `read_tree` to continue with an invalid index entry. Ultimately, this can lead to a double-free.  Improve code and fix the bug by converting the function to return the index entry size via an out parameter and only using the return value to indicate errors. ",
        "func_before": "static size_t read_entry(\n\tgit_index_entry **out,\n\tgit_index *index,\n\tconst void *buffer,\n\tsize_t buffer_size,\n\tconst char *last)\n{\n\tsize_t path_length, entry_size;\n\tconst char *path_ptr;\n\tstruct entry_short source;\n\tgit_index_entry entry = {{0}};\n\tbool compressed = index->version >= INDEX_VERSION_NUMBER_COMP;\n\tchar *tmp_path = NULL;\n\n\tif (INDEX_FOOTER_SIZE + minimal_entry_size > buffer_size)\n\t\treturn 0;\n\n\t/* buffer is not guaranteed to be aligned */\n\tmemcpy(&source, buffer, sizeof(struct entry_short));\n\n\tentry.ctime.seconds = (git_time_t)ntohl(source.ctime.seconds);\n\tentry.ctime.nanoseconds = ntohl(source.ctime.nanoseconds);\n\tentry.mtime.seconds = (git_time_t)ntohl(source.mtime.seconds);\n\tentry.mtime.nanoseconds = ntohl(source.mtime.nanoseconds);\n\tentry.dev = ntohl(source.dev);\n\tentry.ino = ntohl(source.ino);\n\tentry.mode = ntohl(source.mode);\n\tentry.uid = ntohl(source.uid);\n\tentry.gid = ntohl(source.gid);\n\tentry.file_size = ntohl(source.file_size);\n\tgit_oid_cpy(&entry.id, &source.oid);\n\tentry.flags = ntohs(source.flags);\n\n\tif (entry.flags & GIT_IDXENTRY_EXTENDED) {\n\t\tuint16_t flags_raw;\n\t\tsize_t flags_offset;\n\n\t\tflags_offset = offsetof(struct entry_long, flags_extended);\n\t\tmemcpy(&flags_raw, (const char *) buffer + flags_offset,\n\t\t\tsizeof(flags_raw));\n\t\tflags_raw = ntohs(flags_raw);\n\n\t\tmemcpy(&entry.flags_extended, &flags_raw, sizeof(flags_raw));\n\t\tpath_ptr = (const char *) buffer + offsetof(struct entry_long, path);\n\t} else\n\t\tpath_ptr = (const char *) buffer + offsetof(struct entry_short, path);\n\n\tif (!compressed) {\n\t\tpath_length = entry.flags & GIT_IDXENTRY_NAMEMASK;\n\n\t\t/* if this is a very long string, we must find its\n\t\t * real length without overflowing */\n\t\tif (path_length == 0xFFF) {\n\t\t\tconst char *path_end;\n\n\t\t\tpath_end = memchr(path_ptr, '\\0', buffer_size);\n\t\t\tif (path_end == NULL)\n\t\t\t\treturn 0;\n\n\t\t\tpath_length = path_end - path_ptr;\n\t\t}\n\n\t\tentry_size = index_entry_size(path_length, 0, entry.flags);\n\t\tentry.path = (char *)path_ptr;\n\t} else {\n\t\tsize_t varint_len;\n\t\tsize_t strip_len = git_decode_varint((const unsigned char *)path_ptr,\n\t\t\t\t\t\t     &varint_len);\n\t\tsize_t last_len = strlen(last);\n\t\tsize_t prefix_len = last_len - strip_len;\n\t\tsize_t suffix_len = strlen(path_ptr + varint_len);\n\t\tsize_t path_len;\n\n\t\tif (varint_len == 0)\n\t\t\treturn index_error_invalid(\"incorrect prefix length\");\n\n\t\tGITERR_CHECK_ALLOC_ADD(&path_len, prefix_len, suffix_len);\n\t\tGITERR_CHECK_ALLOC_ADD(&path_len, path_len, 1);\n\t\ttmp_path = git__malloc(path_len);\n\t\tGITERR_CHECK_ALLOC(tmp_path);\n\n\t\tmemcpy(tmp_path, last, prefix_len);\n\t\tmemcpy(tmp_path + prefix_len, path_ptr + varint_len, suffix_len + 1);\n\t\tentry_size = index_entry_size(suffix_len, varint_len, entry.flags);\n\t\tentry.path = tmp_path;\n\t}\n\n\tif (INDEX_FOOTER_SIZE + entry_size > buffer_size)\n\t\treturn 0;\n\n\tif (index_entry_dup(out, index, &entry) < 0) {\n\t\tgit__free(tmp_path);\n\t\treturn 0;\n\t}\n\n\tgit__free(tmp_path);\n\treturn entry_size;\n}",
        "func": "static int read_entry(\n\tgit_index_entry **out,\n\tsize_t *out_size,\n\tgit_index *index,\n\tconst void *buffer,\n\tsize_t buffer_size,\n\tconst char *last)\n{\n\tsize_t path_length, entry_size;\n\tconst char *path_ptr;\n\tstruct entry_short source;\n\tgit_index_entry entry = {{0}};\n\tbool compressed = index->version >= INDEX_VERSION_NUMBER_COMP;\n\tchar *tmp_path = NULL;\n\n\tif (INDEX_FOOTER_SIZE + minimal_entry_size > buffer_size)\n\t\treturn -1;\n\n\t/* buffer is not guaranteed to be aligned */\n\tmemcpy(&source, buffer, sizeof(struct entry_short));\n\n\tentry.ctime.seconds = (git_time_t)ntohl(source.ctime.seconds);\n\tentry.ctime.nanoseconds = ntohl(source.ctime.nanoseconds);\n\tentry.mtime.seconds = (git_time_t)ntohl(source.mtime.seconds);\n\tentry.mtime.nanoseconds = ntohl(source.mtime.nanoseconds);\n\tentry.dev = ntohl(source.dev);\n\tentry.ino = ntohl(source.ino);\n\tentry.mode = ntohl(source.mode);\n\tentry.uid = ntohl(source.uid);\n\tentry.gid = ntohl(source.gid);\n\tentry.file_size = ntohl(source.file_size);\n\tgit_oid_cpy(&entry.id, &source.oid);\n\tentry.flags = ntohs(source.flags);\n\n\tif (entry.flags & GIT_IDXENTRY_EXTENDED) {\n\t\tuint16_t flags_raw;\n\t\tsize_t flags_offset;\n\n\t\tflags_offset = offsetof(struct entry_long, flags_extended);\n\t\tmemcpy(&flags_raw, (const char *) buffer + flags_offset,\n\t\t\tsizeof(flags_raw));\n\t\tflags_raw = ntohs(flags_raw);\n\n\t\tmemcpy(&entry.flags_extended, &flags_raw, sizeof(flags_raw));\n\t\tpath_ptr = (const char *) buffer + offsetof(struct entry_long, path);\n\t} else\n\t\tpath_ptr = (const char *) buffer + offsetof(struct entry_short, path);\n\n\tif (!compressed) {\n\t\tpath_length = entry.flags & GIT_IDXENTRY_NAMEMASK;\n\n\t\t/* if this is a very long string, we must find its\n\t\t * real length without overflowing */\n\t\tif (path_length == 0xFFF) {\n\t\t\tconst char *path_end;\n\n\t\t\tpath_end = memchr(path_ptr, '\\0', buffer_size);\n\t\t\tif (path_end == NULL)\n\t\t\t\treturn -1;\n\n\t\t\tpath_length = path_end - path_ptr;\n\t\t}\n\n\t\tentry_size = index_entry_size(path_length, 0, entry.flags);\n\t\tentry.path = (char *)path_ptr;\n\t} else {\n\t\tsize_t varint_len;\n\t\tsize_t strip_len = git_decode_varint((const unsigned char *)path_ptr,\n\t\t\t\t\t\t     &varint_len);\n\t\tsize_t last_len = strlen(last);\n\t\tsize_t prefix_len = last_len - strip_len;\n\t\tsize_t suffix_len = strlen(path_ptr + varint_len);\n\t\tsize_t path_len;\n\n\t\tif (varint_len == 0)\n\t\t\treturn index_error_invalid(\"incorrect prefix length\");\n\n\t\tGITERR_CHECK_ALLOC_ADD(&path_len, prefix_len, suffix_len);\n\t\tGITERR_CHECK_ALLOC_ADD(&path_len, path_len, 1);\n\t\ttmp_path = git__malloc(path_len);\n\t\tGITERR_CHECK_ALLOC(tmp_path);\n\n\t\tmemcpy(tmp_path, last, prefix_len);\n\t\tmemcpy(tmp_path + prefix_len, path_ptr + varint_len, suffix_len + 1);\n\t\tentry_size = index_entry_size(suffix_len, varint_len, entry.flags);\n\t\tentry.path = tmp_path;\n\t}\n\n\tif (entry_size == 0)\n\t\treturn -1;\n\n\tif (INDEX_FOOTER_SIZE + entry_size > buffer_size)\n\t\treturn -1;\n\n\tif (index_entry_dup(out, index, &entry) < 0) {\n\t\tgit__free(tmp_path);\n\t\treturn -1;\n\t}\n\n\tgit__free(tmp_path);\n\t*out_size = entry_size;\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,6 @@\n-static size_t read_entry(\n+static int read_entry(\n \tgit_index_entry **out,\n+\tsize_t *out_size,\n \tgit_index *index,\n \tconst void *buffer,\n \tsize_t buffer_size,\n@@ -13,7 +14,7 @@\n \tchar *tmp_path = NULL;\n \n \tif (INDEX_FOOTER_SIZE + minimal_entry_size > buffer_size)\n-\t\treturn 0;\n+\t\treturn -1;\n \n \t/* buffer is not guaranteed to be aligned */\n \tmemcpy(&source, buffer, sizeof(struct entry_short));\n@@ -55,7 +56,7 @@\n \n \t\t\tpath_end = memchr(path_ptr, '\\0', buffer_size);\n \t\t\tif (path_end == NULL)\n-\t\t\t\treturn 0;\n+\t\t\t\treturn -1;\n \n \t\t\tpath_length = path_end - path_ptr;\n \t\t}\n@@ -85,14 +86,18 @@\n \t\tentry.path = tmp_path;\n \t}\n \n+\tif (entry_size == 0)\n+\t\treturn -1;\n+\n \tif (INDEX_FOOTER_SIZE + entry_size > buffer_size)\n-\t\treturn 0;\n+\t\treturn -1;\n \n \tif (index_entry_dup(out, index, &entry) < 0) {\n \t\tgit__free(tmp_path);\n-\t\treturn 0;\n+\t\treturn -1;\n \t}\n \n \tgit__free(tmp_path);\n-\treturn entry_size;\n+\t*out_size = entry_size;\n+\treturn 0;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "static size_t read_entry(",
                "\t\treturn 0;",
                "\t\t\t\treturn 0;",
                "\t\treturn 0;",
                "\t\treturn 0;",
                "\treturn entry_size;"
            ],
            "added_lines": [
                "static int read_entry(",
                "\tsize_t *out_size,",
                "\t\treturn -1;",
                "\t\t\t\treturn -1;",
                "\tif (entry_size == 0)",
                "\t\treturn -1;",
                "",
                "\t\treturn -1;",
                "\t\treturn -1;",
                "\t*out_size = entry_size;",
                "\treturn 0;"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-8804",
        "func_name": "ImageMagick/WriteEPTImage",
        "description": "WriteEPTImage in coders/ept.c in ImageMagick 7.0.7-25 Q16 allows remote attackers to cause a denial of service (MagickCore/memory.c double free and application crash) or possibly have unspecified other impact via a crafted file.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/6355db269e03f879c516cf9d592c72e157bc75d6",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/1025",
        "commit_text": "",
        "func_before": "static MagickBooleanType WriteEPTImage(const ImageInfo *image_info,Image *image)\n{\n  char\n     filename[MaxTextExtent];\n\n  EPTInfo\n    ept_info;\n\n  Image\n    *write_image;\n\n  ImageInfo\n    *write_info;\n\n  MagickBooleanType\n    status;\n\n  /*\n    Write EPT image.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,&image->exception);\n  if (status == MagickFalse)\n    return(status);\n  write_image=CloneImage(image,0,0,MagickTrue,&image->exception);\n  if (write_image == (Image *) NULL)\n    return(MagickFalse);\n  write_info=CloneImageInfo(image_info);\n  *write_info->magick='\\0';\n  (void) CopyMagickString(write_info->magick,\"EPS\",MaxTextExtent);\n  if (LocaleCompare(image_info->magick,\"EPT2\") == 0)\n    (void) CopyMagickString(write_info->magick,\"EPS2\",MaxTextExtent);\n  if (LocaleCompare(image_info->magick,\"EPT3\") == 0)\n    (void) CopyMagickString(write_info->magick,\"EPS3\",MaxTextExtent);\n  (void) memset(&ept_info,0,sizeof(ept_info));\n  ept_info.magick=0xc6d3d0c5ul;\n  ept_info.postscript=(unsigned char *) ImageToBlob(write_info,write_image,\n    &ept_info.postscript_length,&image->exception);\n  write_image=DestroyImage(write_image);\n  write_info=DestroyImageInfo(write_info);\n  if (ept_info.postscript == (void *) NULL)\n    return(MagickFalse);\n  write_image=CloneImage(image,0,0,MagickTrue,&image->exception);\n  if (write_image == (Image *) NULL)\n    return(MagickFalse);\n  write_info=CloneImageInfo(image_info);\n  (void) CopyMagickString(write_info->magick,\"TIFF\",MaxTextExtent);\n  (void) FormatLocaleString(filename,MaxTextExtent,\"tiff:%s\",\n    write_info->filename);\n  (void) CopyMagickString(write_info->filename,filename,MaxTextExtent);\n  (void) TransformImage(&write_image,(char *) NULL,\"512x512>\");\n  if ((write_image->storage_class == DirectClass) ||\n      (write_image->colors > 256))\n    {\n      QuantizeInfo\n        quantize_info;\n\n      /*\n        EPT preview requires that the image is colormapped.\n      */\n      GetQuantizeInfo(&quantize_info);\n      quantize_info.dither=IsPaletteImage(write_image,&image->exception) ==\n        MagickFalse ? MagickTrue : MagickFalse;\n      (void) QuantizeImage(&quantize_info,write_image);\n    }\n  write_info->compression=NoCompression;\n  ept_info.tiff=(unsigned char *) ImageToBlob(write_info,write_image,\n    &ept_info.tiff_length,&image->exception);\n  write_image=DestroyImage(write_image);\n  write_info=DestroyImageInfo(write_info);\n  if (ept_info.tiff == (void *) NULL)\n    {\n      ept_info.postscript=(unsigned char *) RelinquishMagickMemory(\n        ept_info.postscript);\n      return(MagickFalse);\n    }\n  /*\n    Write EPT image.\n  */\n  (void) WriteBlobLSBLong(image,(unsigned int) ept_info.magick);\n  (void) WriteBlobLSBLong(image,30);\n  (void) WriteBlobLSBLong(image,(unsigned int) ept_info.postscript_length);\n  (void) WriteBlobLSBLong(image,0);\n  (void) WriteBlobLSBLong(image,0);\n  (void) WriteBlobLSBLong(image,(unsigned int) ept_info.postscript_length+30);\n  (void) WriteBlobLSBLong(image,(unsigned int) ept_info.tiff_length);\n  (void) WriteBlobLSBShort(image,0xffff);\n  (void) WriteBlob(image,ept_info.postscript_length,ept_info.postscript);\n  (void) WriteBlob(image,ept_info.tiff_length,ept_info.tiff);\n  /*\n    Relinquish resources.\n  */\n  ept_info.postscript=(unsigned char *) RelinquishMagickMemory(\n    ept_info.postscript);\n  ept_info.tiff=(unsigned char *) RelinquishMagickMemory(ept_info.tiff);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}",
        "func": "static MagickBooleanType WriteEPTImage(const ImageInfo *image_info,Image *image)\n{\n  char\n     filename[MaxTextExtent];\n\n  EPTInfo\n    ept_info;\n\n  Image\n    *write_image;\n\n  ImageInfo\n    *write_info;\n\n  MagickBooleanType\n    status;\n\n  /*\n    Write EPT image.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,&image->exception);\n  if (status == MagickFalse)\n    return(status);\n  write_image=CloneImage(image,0,0,MagickTrue,&image->exception);\n  if (write_image == (Image *) NULL)\n    return(MagickFalse);\n  write_info=CloneImageInfo(image_info);\n  (void) CopyMagickString(write_info->filename,\"EPS:\",MagickPathExtent);\n  (void) CopyMagickString(write_info->magick,\"EPS\",MagickPathExtent);\n  if (LocaleCompare(image_info->magick,\"EPT2\") == 0)\n    {\n      (void) CopyMagickString(write_info->filename,\"EPS2:\",MagickPathExtent);\n      (void) CopyMagickString(write_info->magick,\"EPS2\",MagickPathExtent);\n    }\n  if (LocaleCompare(image_info->magick,\"EPT3\") == 0)\n    {\n      (void) CopyMagickString(write_info->filename,\"EPS3:\",MagickPathExtent);\n      (void) CopyMagickString(write_info->magick,\"EPS3\",MagickPathExtent);\n    }\n  (void) memset(&ept_info,0,sizeof(ept_info));\n  ept_info.magick=0xc6d3d0c5ul;\n  ept_info.postscript=(unsigned char *) ImageToBlob(write_info,write_image,\n    &ept_info.postscript_length,&image->exception);\n  write_image=DestroyImage(write_image);\n  write_info=DestroyImageInfo(write_info);\n  if (ept_info.postscript == (void *) NULL)\n    return(MagickFalse);\n  write_image=CloneImage(image,0,0,MagickTrue,&image->exception);\n  if (write_image == (Image *) NULL)\n    return(MagickFalse);\n  write_info=CloneImageInfo(image_info);\n  (void) CopyMagickString(write_info->magick,\"TIFF\",MaxTextExtent);\n  (void) FormatLocaleString(filename,MaxTextExtent,\"tiff:%s\",\n    write_info->filename);\n  (void) CopyMagickString(write_info->filename,filename,MaxTextExtent);\n  (void) TransformImage(&write_image,(char *) NULL,\"512x512>\");\n  if ((write_image->storage_class == DirectClass) ||\n      (write_image->colors > 256))\n    {\n      QuantizeInfo\n        quantize_info;\n\n      /*\n        EPT preview requires that the image is colormapped.\n      */\n      GetQuantizeInfo(&quantize_info);\n      quantize_info.dither=IsPaletteImage(write_image,&image->exception) ==\n        MagickFalse ? MagickTrue : MagickFalse;\n      (void) QuantizeImage(&quantize_info,write_image);\n    }\n  write_info->compression=NoCompression;\n  ept_info.tiff=(unsigned char *) ImageToBlob(write_info,write_image,\n    &ept_info.tiff_length,&image->exception);\n  write_image=DestroyImage(write_image);\n  write_info=DestroyImageInfo(write_info);\n  if (ept_info.tiff == (void *) NULL)\n    {\n      ept_info.postscript=(unsigned char *) RelinquishMagickMemory(\n        ept_info.postscript);\n      return(MagickFalse);\n    }\n  /*\n    Write EPT image.\n  */\n  (void) WriteBlobLSBLong(image,(unsigned int) ept_info.magick);\n  (void) WriteBlobLSBLong(image,30);\n  (void) WriteBlobLSBLong(image,(unsigned int) ept_info.postscript_length);\n  (void) WriteBlobLSBLong(image,0);\n  (void) WriteBlobLSBLong(image,0);\n  (void) WriteBlobLSBLong(image,(unsigned int) ept_info.postscript_length+30);\n  (void) WriteBlobLSBLong(image,(unsigned int) ept_info.tiff_length);\n  (void) WriteBlobLSBShort(image,0xffff);\n  (void) WriteBlob(image,ept_info.postscript_length,ept_info.postscript);\n  (void) WriteBlob(image,ept_info.tiff_length,ept_info.tiff);\n  /*\n    Relinquish resources.\n  */\n  ept_info.postscript=(unsigned char *) RelinquishMagickMemory(\n    ept_info.postscript);\n  ept_info.tiff=(unsigned char *) RelinquishMagickMemory(ept_info.tiff);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -31,12 +31,18 @@\n   if (write_image == (Image *) NULL)\n     return(MagickFalse);\n   write_info=CloneImageInfo(image_info);\n-  *write_info->magick='\\0';\n-  (void) CopyMagickString(write_info->magick,\"EPS\",MaxTextExtent);\n+  (void) CopyMagickString(write_info->filename,\"EPS:\",MagickPathExtent);\n+  (void) CopyMagickString(write_info->magick,\"EPS\",MagickPathExtent);\n   if (LocaleCompare(image_info->magick,\"EPT2\") == 0)\n-    (void) CopyMagickString(write_info->magick,\"EPS2\",MaxTextExtent);\n+    {\n+      (void) CopyMagickString(write_info->filename,\"EPS2:\",MagickPathExtent);\n+      (void) CopyMagickString(write_info->magick,\"EPS2\",MagickPathExtent);\n+    }\n   if (LocaleCompare(image_info->magick,\"EPT3\") == 0)\n-    (void) CopyMagickString(write_info->magick,\"EPS3\",MaxTextExtent);\n+    {\n+      (void) CopyMagickString(write_info->filename,\"EPS3:\",MagickPathExtent);\n+      (void) CopyMagickString(write_info->magick,\"EPS3\",MagickPathExtent);\n+    }\n   (void) memset(&ept_info,0,sizeof(ept_info));\n   ept_info.magick=0xc6d3d0c5ul;\n   ept_info.postscript=(unsigned char *) ImageToBlob(write_info,write_image,",
        "diff_line_info": {
            "deleted_lines": [
                "  *write_info->magick='\\0';",
                "  (void) CopyMagickString(write_info->magick,\"EPS\",MaxTextExtent);",
                "    (void) CopyMagickString(write_info->magick,\"EPS2\",MaxTextExtent);",
                "    (void) CopyMagickString(write_info->magick,\"EPS3\",MaxTextExtent);"
            ],
            "added_lines": [
                "  (void) CopyMagickString(write_info->filename,\"EPS:\",MagickPathExtent);",
                "  (void) CopyMagickString(write_info->magick,\"EPS\",MagickPathExtent);",
                "    {",
                "      (void) CopyMagickString(write_info->filename,\"EPS2:\",MagickPathExtent);",
                "      (void) CopyMagickString(write_info->magick,\"EPS2\",MagickPathExtent);",
                "    }",
                "    {",
                "      (void) CopyMagickString(write_info->filename,\"EPS3:\",MagickPathExtent);",
                "      (void) CopyMagickString(write_info->magick,\"EPS3\",MagickPathExtent);",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-9336",
        "func_name": "OpenVPN/openvpn/GetStartupData",
        "description": "openvpnserv.exe (aka the interactive service helper) in OpenVPN 2.4.x before 2.4.6 allows a local attacker to cause a double-free of memory by sending a malformed request to the interactive service. This could cause a denial-of-service through memory corruption or possibly have unspecified other impact including privilege escalation.",
        "git_url": "https://github.com/OpenVPN/openvpn/commit/1394192b210cb3c6624a7419bcf3ff966742e79b",
        "commit_title": "Fix potential double-free() in Interactive Service (CVE-2018-9336)",
        "commit_text": " Malformed input data on the service pipe towards the OpenVPN interactive service (normally used by the OpenVPN GUI to request openvpn instances from the service) can result in a double free() in the error handling code.  This usually only leads to a process crash (DoS by an unprivileged local account) but since it could possibly lead to memory corruption if happening while multiple other threads are active at the same time, CVE-2018-9336 has been assigned to acknowledge this risk.  Fix by ensuring that sud->directory is set to NULL in GetStartUpData() for all error cases (thus not being free()ed in FreeStartupData()).  Rewrite control flow to use explicit error label for error exit.  Discovered and reported by Jacob Baines <jbaines@tenable.com>.  CVE: 2018-9336  Message-Id: <20180414072617.25075-1-gert@greenie.muc.de> URL: https://www.mail-archive.com/search?l=mid&q=20180414072617.25075-1-gert@greenie.muc.de ",
        "func_before": "static BOOL\nGetStartupData(HANDLE pipe, STARTUP_DATA *sud)\n{\n    size_t size, len;\n    BOOL ret = FALSE;\n    WCHAR *data = NULL;\n    DWORD bytes, read;\n\n    bytes = PeekNamedPipeAsync(pipe, 1, &exit_event);\n    if (bytes == 0)\n    {\n        MsgToEventLog(M_SYSERR, TEXT(\"PeekNamedPipeAsync failed\"));\n        ReturnLastError(pipe, L\"PeekNamedPipeAsync\");\n        goto out;\n    }\n\n    size = bytes / sizeof(*data);\n    if (size == 0)\n    {\n        MsgToEventLog(M_SYSERR, TEXT(\"malformed startup data: 1 byte received\"));\n        ReturnError(pipe, ERROR_STARTUP_DATA, L\"GetStartupData\", 1, &exit_event);\n        goto out;\n    }\n\n    data = malloc(bytes);\n    if (data == NULL)\n    {\n        MsgToEventLog(M_SYSERR, TEXT(\"malloc failed\"));\n        ReturnLastError(pipe, L\"malloc\");\n        goto out;\n    }\n\n    read = ReadPipeAsync(pipe, data, bytes, 1, &exit_event);\n    if (bytes != read)\n    {\n        MsgToEventLog(M_SYSERR, TEXT(\"ReadPipeAsync failed\"));\n        ReturnLastError(pipe, L\"ReadPipeAsync\");\n        goto out;\n    }\n\n    if (data[size - 1] != 0)\n    {\n        MsgToEventLog(M_ERR, TEXT(\"Startup data is not NULL terminated\"));\n        ReturnError(pipe, ERROR_STARTUP_DATA, L\"GetStartupData\", 1, &exit_event);\n        goto out;\n    }\n\n    sud->directory = data;\n    len = wcslen(sud->directory) + 1;\n    size -= len;\n    if (size <= 0)\n    {\n        MsgToEventLog(M_ERR, TEXT(\"Startup data ends at working directory\"));\n        ReturnError(pipe, ERROR_STARTUP_DATA, L\"GetStartupData\", 1, &exit_event);\n        goto out;\n    }\n\n    sud->options = sud->directory + len;\n    len = wcslen(sud->options) + 1;\n    size -= len;\n    if (size <= 0)\n    {\n        MsgToEventLog(M_ERR, TEXT(\"Startup data ends at command line options\"));\n        ReturnError(pipe, ERROR_STARTUP_DATA, L\"GetStartupData\", 1, &exit_event);\n        goto out;\n    }\n\n    sud->std_input = sud->options + len;\n    data = NULL; /* don't free data */\n    ret = TRUE;\n\nout:\n    free(data);\n    return ret;\n}",
        "func": "static BOOL\nGetStartupData(HANDLE pipe, STARTUP_DATA *sud)\n{\n    size_t size, len;\n    WCHAR *data = NULL;\n    DWORD bytes, read;\n\n    bytes = PeekNamedPipeAsync(pipe, 1, &exit_event);\n    if (bytes == 0)\n    {\n        MsgToEventLog(M_SYSERR, TEXT(\"PeekNamedPipeAsync failed\"));\n        ReturnLastError(pipe, L\"PeekNamedPipeAsync\");\n        goto err;\n    }\n\n    size = bytes / sizeof(*data);\n    if (size == 0)\n    {\n        MsgToEventLog(M_SYSERR, TEXT(\"malformed startup data: 1 byte received\"));\n        ReturnError(pipe, ERROR_STARTUP_DATA, L\"GetStartupData\", 1, &exit_event);\n        goto err;\n    }\n\n    data = malloc(bytes);\n    if (data == NULL)\n    {\n        MsgToEventLog(M_SYSERR, TEXT(\"malloc failed\"));\n        ReturnLastError(pipe, L\"malloc\");\n        goto err;\n    }\n\n    read = ReadPipeAsync(pipe, data, bytes, 1, &exit_event);\n    if (bytes != read)\n    {\n        MsgToEventLog(M_SYSERR, TEXT(\"ReadPipeAsync failed\"));\n        ReturnLastError(pipe, L\"ReadPipeAsync\");\n        goto err;\n    }\n\n    if (data[size - 1] != 0)\n    {\n        MsgToEventLog(M_ERR, TEXT(\"Startup data is not NULL terminated\"));\n        ReturnError(pipe, ERROR_STARTUP_DATA, L\"GetStartupData\", 1, &exit_event);\n        goto err;\n    }\n\n    sud->directory = data;\n    len = wcslen(sud->directory) + 1;\n    size -= len;\n    if (size <= 0)\n    {\n        MsgToEventLog(M_ERR, TEXT(\"Startup data ends at working directory\"));\n        ReturnError(pipe, ERROR_STARTUP_DATA, L\"GetStartupData\", 1, &exit_event);\n        goto err;\n    }\n\n    sud->options = sud->directory + len;\n    len = wcslen(sud->options) + 1;\n    size -= len;\n    if (size <= 0)\n    {\n        MsgToEventLog(M_ERR, TEXT(\"Startup data ends at command line options\"));\n        ReturnError(pipe, ERROR_STARTUP_DATA, L\"GetStartupData\", 1, &exit_event);\n        goto err;\n    }\n\n    sud->std_input = sud->options + len;\n    return TRUE;\n\nerr:\n    sud->directory = NULL;\t\t/* caller must not free() */\n    free(data);\n    return FALSE;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,7 +2,6 @@\n GetStartupData(HANDLE pipe, STARTUP_DATA *sud)\n {\n     size_t size, len;\n-    BOOL ret = FALSE;\n     WCHAR *data = NULL;\n     DWORD bytes, read;\n \n@@ -11,7 +10,7 @@\n     {\n         MsgToEventLog(M_SYSERR, TEXT(\"PeekNamedPipeAsync failed\"));\n         ReturnLastError(pipe, L\"PeekNamedPipeAsync\");\n-        goto out;\n+        goto err;\n     }\n \n     size = bytes / sizeof(*data);\n@@ -19,7 +18,7 @@\n     {\n         MsgToEventLog(M_SYSERR, TEXT(\"malformed startup data: 1 byte received\"));\n         ReturnError(pipe, ERROR_STARTUP_DATA, L\"GetStartupData\", 1, &exit_event);\n-        goto out;\n+        goto err;\n     }\n \n     data = malloc(bytes);\n@@ -27,7 +26,7 @@\n     {\n         MsgToEventLog(M_SYSERR, TEXT(\"malloc failed\"));\n         ReturnLastError(pipe, L\"malloc\");\n-        goto out;\n+        goto err;\n     }\n \n     read = ReadPipeAsync(pipe, data, bytes, 1, &exit_event);\n@@ -35,14 +34,14 @@\n     {\n         MsgToEventLog(M_SYSERR, TEXT(\"ReadPipeAsync failed\"));\n         ReturnLastError(pipe, L\"ReadPipeAsync\");\n-        goto out;\n+        goto err;\n     }\n \n     if (data[size - 1] != 0)\n     {\n         MsgToEventLog(M_ERR, TEXT(\"Startup data is not NULL terminated\"));\n         ReturnError(pipe, ERROR_STARTUP_DATA, L\"GetStartupData\", 1, &exit_event);\n-        goto out;\n+        goto err;\n     }\n \n     sud->directory = data;\n@@ -52,7 +51,7 @@\n     {\n         MsgToEventLog(M_ERR, TEXT(\"Startup data ends at working directory\"));\n         ReturnError(pipe, ERROR_STARTUP_DATA, L\"GetStartupData\", 1, &exit_event);\n-        goto out;\n+        goto err;\n     }\n \n     sud->options = sud->directory + len;\n@@ -62,14 +61,14 @@\n     {\n         MsgToEventLog(M_ERR, TEXT(\"Startup data ends at command line options\"));\n         ReturnError(pipe, ERROR_STARTUP_DATA, L\"GetStartupData\", 1, &exit_event);\n-        goto out;\n+        goto err;\n     }\n \n     sud->std_input = sud->options + len;\n-    data = NULL; /* don't free data */\n-    ret = TRUE;\n+    return TRUE;\n \n-out:\n+err:\n+    sud->directory = NULL;\t\t/* caller must not free() */\n     free(data);\n-    return ret;\n+    return FALSE;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    BOOL ret = FALSE;",
                "        goto out;",
                "        goto out;",
                "        goto out;",
                "        goto out;",
                "        goto out;",
                "        goto out;",
                "        goto out;",
                "    data = NULL; /* don't free data */",
                "    ret = TRUE;",
                "out:",
                "    return ret;"
            ],
            "added_lines": [
                "        goto err;",
                "        goto err;",
                "        goto err;",
                "        goto err;",
                "        goto err;",
                "        goto err;",
                "        goto err;",
                "    return TRUE;",
                "err:",
                "    sud->directory = NULL;\t\t/* caller must not free() */",
                "    return FALSE;"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-11243",
        "func_name": "upx/PackLinuxElf32::check_pt_dynamic",
        "description": "PackLinuxElf64::unpack in p_lx_elf.cpp in UPX 3.95 allows remote attackers to cause a denial of service (double free), limit the ability of a malware scanner to operate on the entire original data, or possibly have unspecified other impact via a crafted file.",
        "git_url": "https://github.com/upx/upx/commit/d9288213ec156dffc435566b9d393d23e87c6914",
        "commit_title": "More checking of PT_DYNAMIC and its contents.",
        "commit_text": " https://github.com/upx/upx/issues/206 \tmodified:   p_lx_elf.cpp",
        "func_before": "unsigned  // checked .p_offset; sz_dynseg set\nPackLinuxElf32::check_pt_dynamic(Elf32_Phdr const *const phdr)\n{\n    unsigned t = get_te32(&phdr->p_offset), s = sizeof(Elf32_Dyn) + t;\n    unsigned filesz = get_te32(&phdr->p_filesz), memsz = get_te32(&phdr->p_memsz);\n    if (s < t || file_size < (off_t)s\n    ||  (3 & t) || (7 & (filesz | memsz))  // .balign 4; 8==sizeof(Elf32_Dyn)\n    ||  filesz < sizeof(Elf32_Dyn)\n    ||  memsz  < sizeof(Elf32_Dyn)\n    ||  filesz < memsz) {\n        char msg[50]; snprintf(msg, sizeof(msg), \"bad PT_DYNAMIC phdr[%u]\",\n            (unsigned)(phdr - phdri));\n        throwCantPack(msg);\n    }\n    sz_dynseg = memsz;\n    return t;\n}",
        "func": "unsigned  // checked .p_offset; sz_dynseg set\nPackLinuxElf32::check_pt_dynamic(Elf32_Phdr const *const phdr)\n{\n    unsigned t = get_te32(&phdr->p_offset), s = sizeof(Elf32_Dyn) + t;\n    unsigned vaddr = get_te32(&phdr->p_vaddr);\n    unsigned filesz = get_te32(&phdr->p_filesz), memsz = get_te32(&phdr->p_memsz);\n    if (s < t || file_size < (off_t)s\n    ||  (3 & t) || (7 & (filesz | memsz))  // .balign 4; 8==sizeof(Elf32_Dyn)\n    ||  (-1+ page_size) & (t ^ vaddr)\n    ||  filesz < sizeof(Elf32_Dyn)\n    ||  memsz  < sizeof(Elf32_Dyn)\n    ||  filesz < memsz) {\n        char msg[50]; snprintf(msg, sizeof(msg), \"bad PT_DYNAMIC phdr[%u]\",\n            (unsigned)(phdr - phdri));\n        throwCantPack(msg);\n    }\n    sz_dynseg = memsz;\n    return t;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,9 +2,11 @@\n PackLinuxElf32::check_pt_dynamic(Elf32_Phdr const *const phdr)\n {\n     unsigned t = get_te32(&phdr->p_offset), s = sizeof(Elf32_Dyn) + t;\n+    unsigned vaddr = get_te32(&phdr->p_vaddr);\n     unsigned filesz = get_te32(&phdr->p_filesz), memsz = get_te32(&phdr->p_memsz);\n     if (s < t || file_size < (off_t)s\n     ||  (3 & t) || (7 & (filesz | memsz))  // .balign 4; 8==sizeof(Elf32_Dyn)\n+    ||  (-1+ page_size) & (t ^ vaddr)\n     ||  filesz < sizeof(Elf32_Dyn)\n     ||  memsz  < sizeof(Elf32_Dyn)\n     ||  filesz < memsz) {",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    unsigned vaddr = get_te32(&phdr->p_vaddr);",
                "    ||  (-1+ page_size) & (t ^ vaddr)"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-11243",
        "func_name": "upx/PackLinuxElf64::calls_crt1",
        "description": "PackLinuxElf64::unpack in p_lx_elf.cpp in UPX 3.95 allows remote attackers to cause a denial of service (double free), limit the ability of a malware scanner to operate on the entire original data, or possibly have unspecified other impact via a crafted file.",
        "git_url": "https://github.com/upx/upx/commit/d9288213ec156dffc435566b9d393d23e87c6914",
        "commit_title": "More checking of PT_DYNAMIC and its contents.",
        "commit_text": " https://github.com/upx/upx/issues/206 \tmodified:   p_lx_elf.cpp",
        "func_before": "bool PackLinuxElf64::calls_crt1(Elf64_Rela const *rela, int sz)\n{\n    for (; 0 < sz; (sz -= sizeof(Elf64_Rela)), ++rela) {\n        unsigned const symnum = get_te64(&rela->r_info) >> 32;\n        char const *const symnam = get_te32(&dynsym[symnum].st_name) + dynstr;\n        if (0==strcmp(symnam, \"__libc_start_main\")  // glibc\n        ||  0==strcmp(symnam, \"__libc_init\")  // Android\n        ||  0==strcmp(symnam, \"__uClibc_main\")\n        ||  0==strcmp(symnam, \"__uClibc_start_main\"))\n            return true;\n    }\n    return false;\n}",
        "func": "bool PackLinuxElf64::calls_crt1(Elf64_Rela const *rela, int sz)\n{\n    if (!dynsym || !dynstr) {\n        return false;\n    }\n    for (; 0 < sz; (sz -= sizeof(Elf64_Rela)), ++rela) {\n        unsigned const symnum = get_te64(&rela->r_info) >> 32;\n        char const *const symnam = get_te32(&dynsym[symnum].st_name) + dynstr;\n        if (0==strcmp(symnam, \"__libc_start_main\")  // glibc\n        ||  0==strcmp(symnam, \"__libc_init\")  // Android\n        ||  0==strcmp(symnam, \"__uClibc_main\")\n        ||  0==strcmp(symnam, \"__uClibc_start_main\"))\n            return true;\n    }\n    return false;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,8 @@\n bool PackLinuxElf64::calls_crt1(Elf64_Rela const *rela, int sz)\n {\n+    if (!dynsym || !dynstr) {\n+        return false;\n+    }\n     for (; 0 < sz; (sz -= sizeof(Elf64_Rela)), ++rela) {\n         unsigned const symnum = get_te64(&rela->r_info) >> 32;\n         char const *const symnam = get_te32(&dynsym[symnum].st_name) + dynstr;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    if (!dynsym || !dynstr) {",
                "        return false;",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-11243",
        "func_name": "upx/PackLinuxElf32::canPack",
        "description": "PackLinuxElf64::unpack in p_lx_elf.cpp in UPX 3.95 allows remote attackers to cause a denial of service (double free), limit the ability of a malware scanner to operate on the entire original data, or possibly have unspecified other impact via a crafted file.",
        "git_url": "https://github.com/upx/upx/commit/d9288213ec156dffc435566b9d393d23e87c6914",
        "commit_title": "More checking of PT_DYNAMIC and its contents.",
        "commit_text": " https://github.com/upx/upx/issues/206 \tmodified:   p_lx_elf.cpp",
        "func_before": "bool PackLinuxElf32::canPack()\n{\n    union {\n        unsigned char buf[sizeof(Elf32_Ehdr) + 14*sizeof(Elf32_Phdr)];\n        //struct { Elf32_Ehdr ehdr; Elf32_Phdr phdr; } e;\n    } u;\n    COMPILE_TIME_ASSERT(sizeof(u.buf) <= 512)\n\n    fi->seek(0, SEEK_SET);\n    fi->readx(u.buf, sizeof(u.buf));\n    fi->seek(0, SEEK_SET);\n    Elf32_Ehdr const *const ehdr = (Elf32_Ehdr *) u.buf;\n\n    // now check the ELF header\n    if (checkEhdr(ehdr) != 0)\n        return false;\n\n    // additional requirements for linux/elf386\n    if (get_te16(&ehdr->e_ehsize) != sizeof(*ehdr)) {\n        throwCantPack(\"invalid Ehdr e_ehsize; try '--force-execve'\");\n        return false;\n    }\n    if (e_phoff != sizeof(*ehdr)) {// Phdrs not contiguous with Ehdr\n        throwCantPack(\"non-contiguous Ehdr/Phdr; try '--force-execve'\");\n        return false;\n    }\n\n    unsigned char osabi0 = u.buf[Elf32_Ehdr::EI_OSABI];\n    // The first PT_LOAD32 must cover the beginning of the file (0==p_offset).\n    Elf32_Phdr const *phdr = phdri;\n    note_size = 0;\n    for (unsigned j=0; j < e_phnum; ++phdr, ++j) {\n        if (j >= 14) {\n            throwCantPack(\"too many ElfXX_Phdr; try '--force-execve'\");\n            return false;\n        }\n        unsigned const p_type = get_te32(&phdr->p_type);\n        unsigned const p_offset = get_te32(&phdr->p_offset);\n        if (1!=exetype && PT_LOAD32 == p_type) { // 1st PT_LOAD\n            exetype = 1;\n            load_va = get_te32(&phdr->p_vaddr);  // class data member\n\n            // Cast on next line is to avoid a compiler bug (incorrect complaint) in\n            // Microsoft (R) C/C++ Optimizing Compiler Version 19.00.24215.1 for x64\n            // error C4319: '~': zero extending 'unsigned int' to 'upx_uint64_t' of greater size\n            unsigned const off = ~page_mask & (unsigned)load_va;\n\n            if (off && off == p_offset) { // specific hint\n                throwCantPack(\"Go-language PT_LOAD: try hemfix.c, or try '--force-execve'\");\n                // Fixing it inside upx fails because packExtent() reads original file.\n                return false;\n            }\n            if (0 != p_offset) { // 1st PT_LOAD must cover Ehdr and Phdr\n                throwCantPack(\"first PT_LOAD.p_offset != 0; try '--force-execve'\");\n                return false;\n            }\n            hatch_off = ~3u & (3+ get_te32(&phdr->p_memsz));\n        }\n        if (PT_NOTE32 == p_type) {\n            unsigned const x = get_te32(&phdr->p_memsz);\n            if ( sizeof(elfout.notes) < x  // beware overflow of note_size\n            ||  (sizeof(elfout.notes) < (note_size += x)) ) {\n                throwCantPack(\"PT_NOTEs too big; try '--force-execve'\");\n                return false;\n            }\n            if (osabi_note && Elf32_Ehdr::ELFOSABI_NONE==osabi0) { // Still seems to be generic.\n                struct {\n                    struct Elf32_Nhdr nhdr;\n                    char name[8];\n                    unsigned body;\n                } note;\n                memset(&note, 0, sizeof(note));\n                fi->seek(p_offset, SEEK_SET);\n                fi->readx(&note, sizeof(note));\n                fi->seek(0, SEEK_SET);\n                if (4==get_te32(&note.nhdr.descsz)\n                &&  1==get_te32(&note.nhdr.type)\n                // &&  0==note.end\n                &&  (1+ strlen(osabi_note))==get_te32(&note.nhdr.namesz)\n                &&  0==strcmp(osabi_note, (char const *)&note.name[0])\n                ) {\n                    osabi0 = ei_osabi;  // Specified by PT_NOTE.\n                }\n            }\n        }\n    }\n    if (Elf32_Ehdr::ELFOSABI_NONE ==osabi0\n    ||  Elf32_Ehdr::ELFOSABI_LINUX==osabi0) { // No EI_OSBAI, no PT_NOTE.\n        unsigned const arm_eabi = 0xff000000u & get_te32(&ehdr->e_flags);\n        if (Elf32_Ehdr::EM_ARM==e_machine\n        &&   (EF_ARM_EABI_VER5==arm_eabi\n          ||  EF_ARM_EABI_VER4==arm_eabi ) ) {\n            // armel-eabi armeb-eabi ARM Linux EABI version 4 is a mess.\n            ei_osabi = osabi0 = Elf32_Ehdr::ELFOSABI_LINUX;\n        }\n        else {\n            osabi0 = opt->o_unix.osabi0;  // Possibly specified by command-line.\n        }\n    }\n    if (osabi0!=ei_osabi) {\n        return false;\n    }\n\n    // We want to compress position-independent executable (gcc -pie)\n    // main programs, but compressing a shared library must be avoided\n    // because the result is no longer usable.  In theory, there is no way\n    // to tell them apart: both are just ET_DYN.  Also in theory,\n    // neither the presence nor the absence of any particular symbol name\n    // can be used to tell them apart; there are counterexamples.\n    // However, we will use the following heuristic suggested by\n    // Peter S. Mazinger <ps.m@gmx.net> September 2005:\n    // If a ET_DYN has __libc_start_main as a global undefined symbol,\n    // then the file is a position-independent executable main program\n    // (that depends on libc.so.6) and is eligible to be compressed.\n    // Otherwise (no __libc_start_main as global undefined): skip it.\n    // Also allow  __uClibc_main  and  __uClibc_start_main .\n\n    if (Elf32_Ehdr::ET_DYN==get_te16(&ehdr->e_type)) {\n        // The DT_SYMTAB has no designated length.  Read the whole file.\n        alloc_file_image(file_image, file_size);\n        fi->seek(0, SEEK_SET);\n        fi->readx(file_image, file_size);\n        memcpy(&ehdri, ehdr, sizeof(Elf32_Ehdr));\n        phdri= (Elf32_Phdr *)((size_t)e_phoff + file_image);  // do not free() !!\n        shdri= (Elf32_Shdr *)((size_t)e_shoff + file_image);  // do not free() !!\n\n        sec_strndx = &shdri[get_te16(&ehdr->e_shstrndx)];\n        shstrtab = (char const *)(get_te32(&sec_strndx->sh_offset) + file_image);\n        sec_dynsym = elf_find_section_type(Elf32_Shdr::SHT_DYNSYM);\n        if (sec_dynsym)\n            sec_dynstr = get_te32(&sec_dynsym->sh_link) + shdri;\n\n        if (Elf32_Shdr::SHT_STRTAB != get_te32(&sec_strndx->sh_type)\n        || 0!=strcmp((char const *)\".shstrtab\",\n                    &shstrtab[get_te32(&sec_strndx->sh_name)]) ) {\n            throwCantPack(\"bad e_shstrndx\");\n        }\n\n        phdr= phdri;\n        for (int j= e_phnum; --j>=0; ++phdr)\n        if (Elf32_Phdr::PT_DYNAMIC==get_te32(&phdr->p_type)) {\n            dynseg= (Elf32_Dyn const *)(check_pt_dynamic(phdr) + file_image);\n            invert_pt_dynamic(dynseg);\n            break;\n        }\n        // elf_find_dynamic() returns 0 if 0==dynseg.\n        dynstr=          (char const *)elf_find_dynamic(Elf32_Dyn::DT_STRTAB);\n        dynsym=     (Elf32_Sym const *)elf_find_dynamic(Elf32_Dyn::DT_SYMTAB);\n\n        if (opt->o_unix.force_pie\n        ||      Elf32_Dyn::DF_1_PIE & elf_unsigned_dynamic(Elf32_Dyn::DT_FLAGS_1)\n        ||  calls_crt1((Elf32_Rel const *)elf_find_dynamic(Elf32_Dyn::DT_REL),\n                                 (int)elf_unsigned_dynamic(Elf32_Dyn::DT_RELSZ))\n        ||  calls_crt1((Elf32_Rel const *)elf_find_dynamic(Elf32_Dyn::DT_JMPREL),\n                                 (int)elf_unsigned_dynamic(Elf32_Dyn::DT_PLTRELSZ))) {\n            is_pie = true;\n            goto proceed;  // calls C library init for main program\n        }\n\n        // Heuristic HACK for shared libraries (compare Darwin (MacOS) Dylib.)\n        // If there is an existing DT_INIT, and if everything that the dynamic\n        // linker ld-linux needs to perform relocations before calling DT_INIT\n        // resides below the first SHT_EXECINSTR Section in one PT_LOAD, then\n        // compress from the first executable Section to the end of that PT_LOAD.\n        // We must not alter anything that ld-linux might touch before it calls\n        // the DT_INIT function.\n        //\n        // Obviously this hack requires that the linker script put pieces\n        // into good positions when building the original shared library,\n        // and also requires ld-linux to behave.\n\n        // Apparently glibc-2.13.90 insists on 0==e_ident[EI_PAD..15],\n        // so compressing shared libraries may be doomed anyway.\n        // 2011-06-01: stub.shlib-init.S works around by installing hatch\n        // at end of .text.\n\n        if (/*jni_onload_sym ||*/ elf_find_dynamic(upx_dt_init)) {\n            if (this->e_machine!=Elf32_Ehdr::EM_386\n            &&  this->e_machine!=Elf32_Ehdr::EM_MIPS\n            &&  this->e_machine!=Elf32_Ehdr::EM_ARM)\n                goto abandon;  // need stub: EM_PPC\n            if (elf_has_dynamic(Elf32_Dyn::DT_TEXTREL)) {\n                throwCantPack(\"DT_TEXTREL found; re-compile with -fPIC\");\n                goto abandon;\n            }\n            Elf32_Shdr const *shdr = shdri;\n            xct_va = ~0u;\n            if (e_shnum) {\n                for (int j= e_shnum; --j>=0; ++shdr) {\n                    unsigned const sh_type = get_te32(&shdr->sh_type);\n                    if (Elf32_Shdr::SHF_EXECINSTR & get_te32(&shdr->sh_flags)) {\n                        xct_va = umin(xct_va, get_te32(&shdr->sh_addr));\n                    }\n                    // Hook the first slot of DT_PREINIT_ARRAY or DT_INIT_ARRAY.\n                    if ((     Elf32_Dyn::DT_PREINIT_ARRAY==upx_dt_init\n                        &&  Elf32_Shdr::SHT_PREINIT_ARRAY==sh_type)\n                    ||  (     Elf32_Dyn::DT_INIT_ARRAY   ==upx_dt_init\n                        &&  Elf32_Shdr::SHT_INIT_ARRAY   ==sh_type) ) {\n                        user_init_off = get_te32(&shdr->sh_offset);\n                        user_init_va = get_te32(&file_image[user_init_off]);\n                    }\n                    // By default /usr/bin/ld leaves 4 extra DT_NULL to support pre-linking.\n                    // Take one as a last resort.\n                    if ((Elf32_Dyn::DT_INIT==upx_dt_init || !upx_dt_init)\n                    &&  Elf32_Shdr::SHT_DYNAMIC == sh_type) {\n                        unsigned const n = get_te32(&shdr->sh_size) / sizeof(Elf32_Dyn);\n                        Elf32_Dyn *dynp = (Elf32_Dyn *)&file_image[get_te32(&shdr->sh_offset)];\n                        for (; Elf32_Dyn::DT_NULL != dynp->d_tag; ++dynp) {\n                            if (upx_dt_init == get_te32(&dynp->d_tag)) {\n                                break;  // re-found DT_INIT\n                            }\n                        }\n                        if ((1+ dynp) < (n+ dynseg)) { // not the terminator, so take it\n                            user_init_va = get_te32(&dynp->d_val);  // 0 if (0==upx_dt_init)\n                            set_te32(&dynp->d_tag, upx_dt_init = Elf32_Dyn::DT_INIT);\n                            user_init_off = (char const *)&dynp->d_val - (char const *)&file_image[0];\n                        }\n                    }\n                }\n            }\n            else { // no Sections; use heuristics\n                unsigned const strsz  = elf_unsigned_dynamic(Elf32_Dyn::DT_STRSZ);\n                unsigned const strtab = elf_unsigned_dynamic(Elf32_Dyn::DT_STRTAB);\n                unsigned const relsz  = elf_unsigned_dynamic(Elf32_Dyn::DT_RELSZ);\n                unsigned const rel    = elf_unsigned_dynamic(Elf32_Dyn::DT_REL);\n                unsigned const init   = elf_unsigned_dynamic(upx_dt_init);\n                if ((init == (relsz + rel   ) && rel    == (strsz + strtab))\n                ||  (init == (strsz + strtab) && strtab == (relsz + rel   ))\n                ) {\n                    xct_va = init;\n                    user_init_va = init;\n                    user_init_off = elf_get_offset_from_address(init);\n                }\n            }\n            // Rely on 0==elf_unsigned_dynamic(tag) if no such tag.\n            unsigned const va_gash = elf_unsigned_dynamic(Elf32_Dyn::DT_GNU_HASH);\n            unsigned const va_hash = elf_unsigned_dynamic(Elf32_Dyn::DT_HASH);\n            if (xct_va < va_gash  ||  (0==va_gash && xct_va < va_hash)\n            ||  xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_STRTAB)\n            ||  xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_SYMTAB)\n            ||  xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_REL)\n            ||  xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_RELA)\n            ||  xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_JMPREL)\n            ||  xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_VERDEF)\n            ||  xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_VERSYM)\n            ||  xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_VERNEEDED) ) {\n                throwCantPack(\"DT_ tag above stub\");\n                goto abandon;\n            }\n            if (!opt->o_unix.android_shlib) {\n                phdr = phdri;\n                for (unsigned j= 0; j < e_phnum; ++phdr, ++j) {\n                    unsigned const vaddr = get_te32(&phdr->p_vaddr);\n                    if (PT_NOTE32 == get_te32(&phdr->p_type)\n                    && xct_va < vaddr) {\n                        char buf[40]; snprintf(buf, sizeof(buf),\n                           \"PT_NOTE %#x above stub\", vaddr);\n                        throwCantPack(buf);\n                        goto abandon;\n                    }\n                }\n            }\n            xct_off = elf_get_offset_from_address(xct_va);\n            if (opt->debug.debug_level) {\n                fprintf(stderr, \"shlib canPack: xct_va=%#lx  xct_off=%lx\\n\",\n                    (long)xct_va, (long)xct_off);\n            }\n            goto proceed;  // But proper packing depends on checking xct_va.\n        }\n        else\n            throwCantPack(\"need DT_INIT; try \\\"void _init(void){}\\\"\");\nabandon:\n        return false;\nproceed: ;\n    }\n    // XXX Theoretically the following test should be first,\n    // but PackUnix::canPack() wants 0!=exetype ?\n    if (!super::canPack())\n        return false;\n    assert(exetype == 1);\n    exetype = 0;\n\n    // set options\n    opt->o_unix.blocksize = blocksize = file_size;\n    return true;\n}",
        "func": "bool PackLinuxElf32::canPack()\n{\n    union {\n        unsigned char buf[sizeof(Elf32_Ehdr) + 14*sizeof(Elf32_Phdr)];\n        //struct { Elf32_Ehdr ehdr; Elf32_Phdr phdr; } e;\n    } u;\n    COMPILE_TIME_ASSERT(sizeof(u.buf) <= 512)\n\n    fi->seek(0, SEEK_SET);\n    fi->readx(u.buf, sizeof(u.buf));\n    fi->seek(0, SEEK_SET);\n    Elf32_Ehdr const *const ehdr = (Elf32_Ehdr *) u.buf;\n\n    // now check the ELF header\n    if (checkEhdr(ehdr) != 0)\n        return false;\n\n    // additional requirements for linux/elf386\n    if (get_te16(&ehdr->e_ehsize) != sizeof(*ehdr)) {\n        throwCantPack(\"invalid Ehdr e_ehsize; try '--force-execve'\");\n        return false;\n    }\n    if (e_phoff != sizeof(*ehdr)) {// Phdrs not contiguous with Ehdr\n        throwCantPack(\"non-contiguous Ehdr/Phdr; try '--force-execve'\");\n        return false;\n    }\n\n    unsigned char osabi0 = u.buf[Elf32_Ehdr::EI_OSABI];\n    // The first PT_LOAD32 must cover the beginning of the file (0==p_offset).\n    Elf32_Phdr const *phdr = phdri;\n    note_size = 0;\n    for (unsigned j=0; j < e_phnum; ++phdr, ++j) {\n        if (j >= 14) {\n            throwCantPack(\"too many ElfXX_Phdr; try '--force-execve'\");\n            return false;\n        }\n        unsigned const p_type = get_te32(&phdr->p_type);\n        unsigned const p_offset = get_te32(&phdr->p_offset);\n        if (1!=exetype && PT_LOAD32 == p_type) { // 1st PT_LOAD\n            exetype = 1;\n            load_va = get_te32(&phdr->p_vaddr);  // class data member\n\n            // Cast on next line is to avoid a compiler bug (incorrect complaint) in\n            // Microsoft (R) C/C++ Optimizing Compiler Version 19.00.24215.1 for x64\n            // error C4319: '~': zero extending 'unsigned int' to 'upx_uint64_t' of greater size\n            unsigned const off = ~page_mask & (unsigned)load_va;\n\n            if (off && off == p_offset) { // specific hint\n                throwCantPack(\"Go-language PT_LOAD: try hemfix.c, or try '--force-execve'\");\n                // Fixing it inside upx fails because packExtent() reads original file.\n                return false;\n            }\n            if (0 != p_offset) { // 1st PT_LOAD must cover Ehdr and Phdr\n                throwCantPack(\"first PT_LOAD.p_offset != 0; try '--force-execve'\");\n                return false;\n            }\n            hatch_off = ~3u & (3+ get_te32(&phdr->p_memsz));\n        }\n        if (PT_NOTE32 == p_type) {\n            unsigned const x = get_te32(&phdr->p_memsz);\n            if ( sizeof(elfout.notes) < x  // beware overflow of note_size\n            ||  (sizeof(elfout.notes) < (note_size += x)) ) {\n                throwCantPack(\"PT_NOTEs too big; try '--force-execve'\");\n                return false;\n            }\n            if (osabi_note && Elf32_Ehdr::ELFOSABI_NONE==osabi0) { // Still seems to be generic.\n                struct {\n                    struct Elf32_Nhdr nhdr;\n                    char name[8];\n                    unsigned body;\n                } note;\n                memset(&note, 0, sizeof(note));\n                fi->seek(p_offset, SEEK_SET);\n                fi->readx(&note, sizeof(note));\n                fi->seek(0, SEEK_SET);\n                if (4==get_te32(&note.nhdr.descsz)\n                &&  1==get_te32(&note.nhdr.type)\n                // &&  0==note.end\n                &&  (1+ strlen(osabi_note))==get_te32(&note.nhdr.namesz)\n                &&  0==strcmp(osabi_note, (char const *)&note.name[0])\n                ) {\n                    osabi0 = ei_osabi;  // Specified by PT_NOTE.\n                }\n            }\n        }\n    }\n    if (Elf32_Ehdr::ELFOSABI_NONE ==osabi0\n    ||  Elf32_Ehdr::ELFOSABI_LINUX==osabi0) { // No EI_OSBAI, no PT_NOTE.\n        unsigned const arm_eabi = 0xff000000u & get_te32(&ehdr->e_flags);\n        if (Elf32_Ehdr::EM_ARM==e_machine\n        &&   (EF_ARM_EABI_VER5==arm_eabi\n          ||  EF_ARM_EABI_VER4==arm_eabi ) ) {\n            // armel-eabi armeb-eabi ARM Linux EABI version 4 is a mess.\n            ei_osabi = osabi0 = Elf32_Ehdr::ELFOSABI_LINUX;\n        }\n        else {\n            osabi0 = opt->o_unix.osabi0;  // Possibly specified by command-line.\n        }\n    }\n    if (osabi0!=ei_osabi) {\n        return false;\n    }\n\n    // We want to compress position-independent executable (gcc -pie)\n    // main programs, but compressing a shared library must be avoided\n    // because the result is no longer usable.  In theory, there is no way\n    // to tell them apart: both are just ET_DYN.  Also in theory,\n    // neither the presence nor the absence of any particular symbol name\n    // can be used to tell them apart; there are counterexamples.\n    // However, we will use the following heuristic suggested by\n    // Peter S. Mazinger <ps.m@gmx.net> September 2005:\n    // If a ET_DYN has __libc_start_main as a global undefined symbol,\n    // then the file is a position-independent executable main program\n    // (that depends on libc.so.6) and is eligible to be compressed.\n    // Otherwise (no __libc_start_main as global undefined): skip it.\n    // Also allow  __uClibc_main  and  __uClibc_start_main .\n\n    if (Elf32_Ehdr::ET_DYN==get_te16(&ehdr->e_type)) {\n        // The DT_SYMTAB has no designated length.  Read the whole file.\n        alloc_file_image(file_image, file_size);\n        fi->seek(0, SEEK_SET);\n        fi->readx(file_image, file_size);\n        memcpy(&ehdri, ehdr, sizeof(Elf32_Ehdr));\n        phdri= (Elf32_Phdr *)((size_t)e_phoff + file_image);  // do not free() !!\n        shdri= (Elf32_Shdr *)((size_t)e_shoff + file_image);  // do not free() !!\n\n        sec_strndx = &shdri[get_te16(&ehdr->e_shstrndx)];\n        shstrtab = (char const *)(get_te32(&sec_strndx->sh_offset) + file_image);\n        sec_dynsym = elf_find_section_type(Elf32_Shdr::SHT_DYNSYM);\n        if (sec_dynsym)\n            sec_dynstr = get_te32(&sec_dynsym->sh_link) + shdri;\n\n        if (Elf32_Shdr::SHT_STRTAB != get_te32(&sec_strndx->sh_type)\n        || 0!=strcmp((char const *)\".shstrtab\",\n                    &shstrtab[get_te32(&sec_strndx->sh_name)]) ) {\n            throwCantPack(\"bad e_shstrndx\");\n        }\n\n        phdr= phdri;\n        for (int j= e_phnum; --j>=0; ++phdr)\n        if (Elf32_Phdr::PT_DYNAMIC==get_te32(&phdr->p_type)) {\n            dynseg= (Elf32_Dyn const *)(check_pt_dynamic(phdr) + file_image);\n            invert_pt_dynamic(dynseg);\n            break;\n        }\n        // elf_find_dynamic() returns 0 if 0==dynseg.\n        dynstr=          (char const *)elf_find_dynamic(Elf32_Dyn::DT_STRTAB);\n        dynsym=     (Elf32_Sym const *)elf_find_dynamic(Elf32_Dyn::DT_SYMTAB);\n\n        if (opt->o_unix.force_pie\n        ||      Elf32_Dyn::DF_1_PIE & elf_unsigned_dynamic(Elf32_Dyn::DT_FLAGS_1)\n        ||  calls_crt1((Elf32_Rel const *)elf_find_dynamic(Elf32_Dyn::DT_REL),\n                                 (int)elf_unsigned_dynamic(Elf32_Dyn::DT_RELSZ))\n        ||  calls_crt1((Elf32_Rel const *)elf_find_dynamic(Elf32_Dyn::DT_JMPREL),\n                                 (int)elf_unsigned_dynamic(Elf32_Dyn::DT_PLTRELSZ))) {\n            is_pie = true;\n            goto proceed;  // calls C library init for main program\n        }\n\n        // Heuristic HACK for shared libraries (compare Darwin (MacOS) Dylib.)\n        // If there is an existing DT_INIT, and if everything that the dynamic\n        // linker ld-linux needs to perform relocations before calling DT_INIT\n        // resides below the first SHT_EXECINSTR Section in one PT_LOAD, then\n        // compress from the first executable Section to the end of that PT_LOAD.\n        // We must not alter anything that ld-linux might touch before it calls\n        // the DT_INIT function.\n        //\n        // Obviously this hack requires that the linker script put pieces\n        // into good positions when building the original shared library,\n        // and also requires ld-linux to behave.\n\n        // Apparently glibc-2.13.90 insists on 0==e_ident[EI_PAD..15],\n        // so compressing shared libraries may be doomed anyway.\n        // 2011-06-01: stub.shlib-init.S works around by installing hatch\n        // at end of .text.\n\n        if (/*jni_onload_sym ||*/ elf_find_dynamic(upx_dt_init)) {\n            if (this->e_machine!=Elf32_Ehdr::EM_386\n            &&  this->e_machine!=Elf32_Ehdr::EM_MIPS\n            &&  this->e_machine!=Elf32_Ehdr::EM_ARM)\n                goto abandon;  // need stub: EM_PPC\n            if (elf_has_dynamic(Elf32_Dyn::DT_TEXTREL)) {\n                throwCantPack(\"DT_TEXTREL found; re-compile with -fPIC\");\n                goto abandon;\n            }\n            Elf32_Shdr const *shdr = shdri;\n            xct_va = ~0u;\n            if (e_shnum) {\n                for (int j= e_shnum; --j>=0; ++shdr) {\n                    unsigned const sh_type = get_te32(&shdr->sh_type);\n                    if (Elf32_Shdr::SHF_EXECINSTR & get_te32(&shdr->sh_flags)) {\n                        xct_va = umin(xct_va, get_te32(&shdr->sh_addr));\n                    }\n                    // Hook the first slot of DT_PREINIT_ARRAY or DT_INIT_ARRAY.\n                    if ((     Elf32_Dyn::DT_PREINIT_ARRAY==upx_dt_init\n                        &&  Elf32_Shdr::SHT_PREINIT_ARRAY==sh_type)\n                    ||  (     Elf32_Dyn::DT_INIT_ARRAY   ==upx_dt_init\n                        &&  Elf32_Shdr::SHT_INIT_ARRAY   ==sh_type) ) {\n                        user_init_off = get_te32(&shdr->sh_offset);\n                        user_init_va = get_te32(&file_image[user_init_off]);\n                    }\n                    // By default /usr/bin/ld leaves 4 extra DT_NULL to support pre-linking.\n                    // Take one as a last resort.\n                    if ((Elf32_Dyn::DT_INIT==upx_dt_init || !upx_dt_init)\n                    &&  Elf32_Shdr::SHT_DYNAMIC == sh_type) {\n                        unsigned const n = get_te32(&shdr->sh_size) / sizeof(Elf32_Dyn);\n                        Elf32_Dyn *dynp = (Elf32_Dyn *)&file_image[get_te32(&shdr->sh_offset)];\n                        for (; Elf32_Dyn::DT_NULL != dynp->d_tag; ++dynp) {\n                            if (upx_dt_init == get_te32(&dynp->d_tag)) {\n                                break;  // re-found DT_INIT\n                            }\n                        }\n                        if ((1+ dynp) < (n+ dynseg)) { // not the terminator, so take it\n                            user_init_va = get_te32(&dynp->d_val);  // 0 if (0==upx_dt_init)\n                            set_te32(&dynp->d_tag, upx_dt_init = Elf32_Dyn::DT_INIT);\n                            user_init_off = (char const *)&dynp->d_val - (char const *)&file_image[0];\n                        }\n                    }\n                }\n            }\n            else { // no Sections; use heuristics\n                unsigned const strsz  = elf_unsigned_dynamic(Elf32_Dyn::DT_STRSZ);\n                unsigned const strtab = elf_unsigned_dynamic(Elf32_Dyn::DT_STRTAB);\n                unsigned const relsz  = elf_unsigned_dynamic(Elf32_Dyn::DT_RELSZ);\n                unsigned const rel    = elf_unsigned_dynamic(Elf32_Dyn::DT_REL);\n                unsigned const init   = elf_unsigned_dynamic(upx_dt_init);\n                if ((init == (relsz + rel   ) && rel    == (strsz + strtab))\n                ||  (init == (strsz + strtab) && strtab == (relsz + rel   ))\n                ) {\n                    xct_va = init;\n                    user_init_va = init;\n                    user_init_off = elf_get_offset_from_address(init);\n                }\n            }\n            // Rely on 0==elf_unsigned_dynamic(tag) if no such tag.\n            unsigned const va_gash = elf_unsigned_dynamic(Elf32_Dyn::DT_GNU_HASH);\n            unsigned const va_hash = elf_unsigned_dynamic(Elf32_Dyn::DT_HASH);\n            unsigned y = 0;\n            if ((y=1, xct_va < va_gash)  ||  (y=2, (0==va_gash && xct_va < va_hash))\n            ||  (y=3, xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_STRTAB))\n            ||  (y=4, xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_SYMTAB))\n            ||  (y=5, xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_REL))\n            ||  (y=6, xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_RELA))\n            ||  (y=7, xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_JMPREL))\n            ||  (y=8, xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_VERDEF))\n            ||  (y=9, xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_VERSYM))\n            ||  (y=10, xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_VERNEEDED)) ) {\n                static char const *which[] = {\n                    \"unknown\",\n                    \"DT_GNU_HASH\",\n                    \"DT_HASH\",\n                    \"DT_STRTAB\",\n                    \"DT_SYMTAB\",\n                    \"DT_REL\",\n                    \"DT_RELA\",\n                    \"DT_JMPREL\",\n                    \"DT_VERDEF\",\n                    \"DT_VERSYM\",\n                    \"DT_VERNEEDED\",\n                };\n                char buf[30]; snprintf(buf, sizeof(buf), \"%s above stub\", which[y]);\n                throwCantPack(buf);\n                goto abandon;\n            }\n            if (!opt->o_unix.android_shlib) {\n                phdr = phdri;\n                for (unsigned j= 0; j < e_phnum; ++phdr, ++j) {\n                    unsigned const vaddr = get_te32(&phdr->p_vaddr);\n                    if (PT_NOTE32 == get_te32(&phdr->p_type)\n                    && xct_va < vaddr) {\n                        char buf[40]; snprintf(buf, sizeof(buf),\n                           \"PT_NOTE %#x above stub\", vaddr);\n                        throwCantPack(buf);\n                        goto abandon;\n                    }\n                }\n            }\n            xct_off = elf_get_offset_from_address(xct_va);\n            if (opt->debug.debug_level) {\n                fprintf(stderr, \"shlib canPack: xct_va=%#lx  xct_off=%lx\\n\",\n                    (long)xct_va, (long)xct_off);\n            }\n            goto proceed;  // But proper packing depends on checking xct_va.\n        }\n        else\n            throwCantPack(\"need DT_INIT; try \\\"void _init(void){}\\\"\");\nabandon:\n        return false;\nproceed: ;\n    }\n    // XXX Theoretically the following test should be first,\n    // but PackUnix::canPack() wants 0!=exetype ?\n    if (!super::canPack())\n        return false;\n    assert(exetype == 1);\n    exetype = 0;\n\n    // set options\n    opt->o_unix.blocksize = blocksize = file_size;\n    return true;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -235,16 +235,31 @@\n             // Rely on 0==elf_unsigned_dynamic(tag) if no such tag.\n             unsigned const va_gash = elf_unsigned_dynamic(Elf32_Dyn::DT_GNU_HASH);\n             unsigned const va_hash = elf_unsigned_dynamic(Elf32_Dyn::DT_HASH);\n-            if (xct_va < va_gash  ||  (0==va_gash && xct_va < va_hash)\n-            ||  xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_STRTAB)\n-            ||  xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_SYMTAB)\n-            ||  xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_REL)\n-            ||  xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_RELA)\n-            ||  xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_JMPREL)\n-            ||  xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_VERDEF)\n-            ||  xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_VERSYM)\n-            ||  xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_VERNEEDED) ) {\n-                throwCantPack(\"DT_ tag above stub\");\n+            unsigned y = 0;\n+            if ((y=1, xct_va < va_gash)  ||  (y=2, (0==va_gash && xct_va < va_hash))\n+            ||  (y=3, xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_STRTAB))\n+            ||  (y=4, xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_SYMTAB))\n+            ||  (y=5, xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_REL))\n+            ||  (y=6, xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_RELA))\n+            ||  (y=7, xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_JMPREL))\n+            ||  (y=8, xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_VERDEF))\n+            ||  (y=9, xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_VERSYM))\n+            ||  (y=10, xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_VERNEEDED)) ) {\n+                static char const *which[] = {\n+                    \"unknown\",\n+                    \"DT_GNU_HASH\",\n+                    \"DT_HASH\",\n+                    \"DT_STRTAB\",\n+                    \"DT_SYMTAB\",\n+                    \"DT_REL\",\n+                    \"DT_RELA\",\n+                    \"DT_JMPREL\",\n+                    \"DT_VERDEF\",\n+                    \"DT_VERSYM\",\n+                    \"DT_VERNEEDED\",\n+                };\n+                char buf[30]; snprintf(buf, sizeof(buf), \"%s above stub\", which[y]);\n+                throwCantPack(buf);\n                 goto abandon;\n             }\n             if (!opt->o_unix.android_shlib) {",
        "diff_line_info": {
            "deleted_lines": [
                "            if (xct_va < va_gash  ||  (0==va_gash && xct_va < va_hash)",
                "            ||  xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_STRTAB)",
                "            ||  xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_SYMTAB)",
                "            ||  xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_REL)",
                "            ||  xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_RELA)",
                "            ||  xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_JMPREL)",
                "            ||  xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_VERDEF)",
                "            ||  xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_VERSYM)",
                "            ||  xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_VERNEEDED) ) {",
                "                throwCantPack(\"DT_ tag above stub\");"
            ],
            "added_lines": [
                "            unsigned y = 0;",
                "            if ((y=1, xct_va < va_gash)  ||  (y=2, (0==va_gash && xct_va < va_hash))",
                "            ||  (y=3, xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_STRTAB))",
                "            ||  (y=4, xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_SYMTAB))",
                "            ||  (y=5, xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_REL))",
                "            ||  (y=6, xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_RELA))",
                "            ||  (y=7, xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_JMPREL))",
                "            ||  (y=8, xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_VERDEF))",
                "            ||  (y=9, xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_VERSYM))",
                "            ||  (y=10, xct_va < elf_unsigned_dynamic(Elf32_Dyn::DT_VERNEEDED)) ) {",
                "                static char const *which[] = {",
                "                    \"unknown\",",
                "                    \"DT_GNU_HASH\",",
                "                    \"DT_HASH\",",
                "                    \"DT_STRTAB\",",
                "                    \"DT_SYMTAB\",",
                "                    \"DT_REL\",",
                "                    \"DT_RELA\",",
                "                    \"DT_JMPREL\",",
                "                    \"DT_VERDEF\",",
                "                    \"DT_VERSYM\",",
                "                    \"DT_VERNEEDED\",",
                "                };",
                "                char buf[30]; snprintf(buf, sizeof(buf), \"%s above stub\", which[y]);",
                "                throwCantPack(buf);"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-11243",
        "func_name": "upx/PackLinuxElf64::canPack",
        "description": "PackLinuxElf64::unpack in p_lx_elf.cpp in UPX 3.95 allows remote attackers to cause a denial of service (double free), limit the ability of a malware scanner to operate on the entire original data, or possibly have unspecified other impact via a crafted file.",
        "git_url": "https://github.com/upx/upx/commit/d9288213ec156dffc435566b9d393d23e87c6914",
        "commit_title": "More checking of PT_DYNAMIC and its contents.",
        "commit_text": " https://github.com/upx/upx/issues/206 \tmodified:   p_lx_elf.cpp",
        "func_before": "bool\nPackLinuxElf64::canPack()\n{\n    union {\n        unsigned char buf[sizeof(Elf64_Ehdr) + 14*sizeof(Elf64_Phdr)];\n        //struct { Elf64_Ehdr ehdr; Elf64_Phdr phdr; } e;\n    } u;\n    COMPILE_TIME_ASSERT(sizeof(u) <= 1024)\n\n    fi->readx(u.buf, sizeof(u.buf));\n    fi->seek(0, SEEK_SET);\n    Elf64_Ehdr const *const ehdr = (Elf64_Ehdr *) u.buf;\n\n    // now check the ELF header\n    if (checkEhdr(ehdr) != 0)\n        return false;\n\n    // additional requirements for linux/elf386\n    if (get_te16(&ehdr->e_ehsize) != sizeof(*ehdr)) {\n        throwCantPack(\"invalid Ehdr e_ehsize; try '--force-execve'\");\n        return false;\n    }\n    if (e_phoff != sizeof(*ehdr)) {// Phdrs not contiguous with Ehdr\n        throwCantPack(\"non-contiguous Ehdr/Phdr; try '--force-execve'\");\n        return false;\n    }\n\n    // The first PT_LOAD64 must cover the beginning of the file (0==p_offset).\n    Elf64_Phdr const *phdr = phdri;\n    for (unsigned j=0; j < e_phnum; ++phdr, ++j) {\n        if (j >= 14) {\n            throwCantPack(\"too many ElfXX_Phdr; try '--force-execve'\");\n            return false;\n        }\n        unsigned const p_type = get_te32(&phdr->p_type);\n        if (1!=exetype && PT_LOAD64 == p_type) { // 1st PT_LOAD\n            exetype = 1;\n            load_va = get_te64(&phdr->p_vaddr);  // class data member\n            upx_uint64_t const p_offset = get_te64(&phdr->p_offset);\n            upx_uint64_t const off = ~page_mask & load_va;\n            if (off && off == p_offset) { // specific hint\n                throwCantPack(\"Go-language PT_LOAD: try hemfix.c, or try '--force-execve'\");\n                // Fixing it inside upx fails because packExtent() reads original file.\n                return false;\n            }\n            if (0 != p_offset) { // 1st PT_LOAD must cover Ehdr and Phdr\n                throwCantPack(\"first PT_LOAD.p_offset != 0; try '--force-execve'\");\n                return false;\n            }\n            hatch_off = ~3ul & (3+ get_te64(&phdr->p_memsz));\n            break;\n        }\n    }\n    // We want to compress position-independent executable (gcc -pie)\n    // main programs, but compressing a shared library must be avoided\n    // because the result is no longer usable.  In theory, there is no way\n    // to tell them apart: both are just ET_DYN.  Also in theory,\n    // neither the presence nor the absence of any particular symbol name\n    // can be used to tell them apart; there are counterexamples.\n    // However, we will use the following heuristic suggested by\n    // Peter S. Mazinger <ps.m@gmx.net> September 2005:\n    // If a ET_DYN has __libc_start_main as a global undefined symbol,\n    // then the file is a position-independent executable main program\n    // (that depends on libc.so.6) and is eligible to be compressed.\n    // Otherwise (no __libc_start_main as global undefined): skip it.\n    // Also allow  __uClibc_main  and  __uClibc_start_main .\n\n    if (Elf64_Ehdr::ET_DYN==get_te16(&ehdr->e_type)) {\n        // The DT_SYMTAB has no designated length.  Read the whole file.\n        alloc_file_image(file_image, file_size);\n        fi->seek(0, SEEK_SET);\n        fi->readx(file_image, file_size);\n        memcpy(&ehdri, ehdr, sizeof(Elf64_Ehdr));\n        phdri= (Elf64_Phdr *)((size_t)e_phoff + file_image);  // do not free() !!\n        shdri= (Elf64_Shdr *)((size_t)e_shoff + file_image);  // do not free() !!\n\n        sec_dynsym = elf_find_section_type(Elf64_Shdr::SHT_DYNSYM);\n        if (sec_dynsym)\n            sec_dynstr = get_te32(&sec_dynsym->sh_link) + shdri;\n\n        sec_strndx = &shdri[get_te16(&ehdr->e_shstrndx)];\n        shstrtab = (char const *)(get_te64(&sec_strndx->sh_offset) + file_image);\n        if (Elf64_Shdr::SHT_STRTAB != get_te32(&sec_strndx->sh_type)\n        || 0!=strcmp((char const *)\".shstrtab\",\n                    &shstrtab[get_te32(&sec_strndx->sh_name)]) ) {\n            throwCantPack(\"bad e_shstrndx\");\n        }\n\n        phdr= phdri;\n        for (int j= e_phnum; --j>=0; ++phdr)\n        if (Elf64_Phdr::PT_DYNAMIC==get_te32(&phdr->p_type)) {\n            dynseg= (Elf64_Dyn const *)(check_pt_dynamic(phdr) + file_image);\n            invert_pt_dynamic(dynseg);\n            break;\n        }\n        // elf_find_dynamic() returns 0 if 0==dynseg.\n        dynstr=          (char const *)elf_find_dynamic(Elf64_Dyn::DT_STRTAB);\n        dynsym=     (Elf64_Sym const *)elf_find_dynamic(Elf64_Dyn::DT_SYMTAB);\n\n        if (opt->o_unix.force_pie\n        ||       Elf64_Dyn::DF_1_PIE & elf_unsigned_dynamic(Elf64_Dyn::DT_FLAGS_1)\n        ||  calls_crt1((Elf64_Rela const *)elf_find_dynamic(Elf64_Dyn::DT_RELA),\n                                  (int)elf_unsigned_dynamic(Elf64_Dyn::DT_RELASZ))\n        ||  calls_crt1((Elf64_Rela const *)elf_find_dynamic(Elf64_Dyn::DT_JMPREL),\n                                  (int)elf_unsigned_dynamic(Elf64_Dyn::DT_PLTRELSZ))) {\n            is_pie = true;\n            goto proceed;  // calls C library init for main program\n        }\n\n        // Heuristic HACK for shared libraries (compare Darwin (MacOS) Dylib.)\n        // If there is an existing DT_INIT, and if everything that the dynamic\n        // linker ld-linux needs to perform relocations before calling DT_INIT\n        // resides below the first SHT_EXECINSTR Section in one PT_LOAD, then\n        // compress from the first executable Section to the end of that PT_LOAD.\n        // We must not alter anything that ld-linux might touch before it calls\n        // the DT_INIT function.\n        //\n        // Obviously this hack requires that the linker script put pieces\n        // into good positions when building the original shared library,\n        // and also requires ld-linux to behave.\n\n        if (elf_find_dynamic(upx_dt_init)) {\n            if (elf_has_dynamic(Elf64_Dyn::DT_TEXTREL)) {\n                throwCantPack(\"DT_TEXTREL found; re-compile with -fPIC\");\n                goto abandon;\n            }\n            Elf64_Shdr const *shdr = shdri;\n            xct_va = ~0ull;\n            if (e_shnum) {\n                for (int j= e_shnum; --j>=0; ++shdr) {\n                    unsigned const sh_type = get_te64(&shdr->sh_type);\n                    if (Elf64_Shdr::SHF_EXECINSTR & get_te64(&shdr->sh_flags)) {\n                        xct_va = umin(xct_va, get_te64(&shdr->sh_addr));\n                    }\n                    // Hook the first slot of DT_PREINIT_ARRAY or DT_INIT_ARRAY.\n                    if ((     Elf64_Dyn::DT_PREINIT_ARRAY==upx_dt_init\n                        &&  Elf64_Shdr::SHT_PREINIT_ARRAY==sh_type)\n                    ||  (     Elf64_Dyn::DT_INIT_ARRAY   ==upx_dt_init\n                        &&  Elf64_Shdr::SHT_INIT_ARRAY   ==sh_type) ) {\n                        user_init_off = get_te64(&shdr->sh_offset);\n                        user_init_va = get_te64(&file_image[user_init_off]);\n                    }\n                    // By default /usr/bin/ld leaves 4 extra DT_NULL to support pre-linking.\n                    // Take one as a last resort.\n                    if ((Elf64_Dyn::DT_INIT==upx_dt_init || !upx_dt_init)\n                    &&  Elf64_Shdr::SHT_DYNAMIC == sh_type) {\n                        unsigned const n = get_te64(&shdr->sh_size) / sizeof(Elf64_Dyn);\n                        Elf64_Dyn *dynp = (Elf64_Dyn *)&file_image[get_te64(&shdr->sh_offset)];\n                        for (; Elf64_Dyn::DT_NULL != dynp->d_tag; ++dynp) {\n                            if (upx_dt_init == get_te64(&dynp->d_tag)) {\n                                break;  // re-found DT_INIT\n                            }\n                        }\n                        if ((1+ dynp) < (n+ dynseg)) { // not the terminator, so take it\n                            user_init_va = get_te64(&dynp->d_val);  // 0 if (0==upx_dt_init)\n                            set_te64(&dynp->d_tag, upx_dt_init = Elf64_Dyn::DT_INIT);\n                            user_init_off = (char const *)&dynp->d_val - (char const *)&file_image[0];\n                        }\n                    }\n                }\n            }\n            else { // no Sections; use heuristics\n                upx_uint64_t const strsz  = elf_unsigned_dynamic(Elf64_Dyn::DT_STRSZ);\n                upx_uint64_t const strtab = elf_unsigned_dynamic(Elf64_Dyn::DT_STRTAB);\n                upx_uint64_t const relsz  = elf_unsigned_dynamic(Elf64_Dyn::DT_RELSZ);\n                upx_uint64_t const rel    = elf_unsigned_dynamic(Elf64_Dyn::DT_REL);\n                upx_uint64_t const init   = elf_unsigned_dynamic(upx_dt_init);\n                if ((init == (relsz + rel   ) && rel    == (strsz + strtab))\n                ||  (init == (strsz + strtab) && strtab == (relsz + rel   ))\n                ) {\n                    xct_va = init;\n                    user_init_va = init;\n                    user_init_off = elf_get_offset_from_address(init);\n                }\n            }\n            // Rely on 0==elf_unsigned_dynamic(tag) if no such tag.\n            upx_uint64_t const va_gash = elf_unsigned_dynamic(Elf64_Dyn::DT_GNU_HASH);\n            upx_uint64_t const va_hash = elf_unsigned_dynamic(Elf64_Dyn::DT_HASH);\n            if (xct_va < va_gash  ||  (0==va_gash && xct_va < va_hash)\n            ||  xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_STRTAB)\n            ||  xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_SYMTAB)\n            ||  xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_REL)\n            ||  xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_RELA)\n            ||  xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_JMPREL)\n            ||  xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_VERDEF)\n            ||  xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_VERSYM)\n            ||  xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_VERNEEDED) ) {\n                throwCantPack(\"DT_ tag above stub\");\n                goto abandon;\n            }\n            if (!opt->o_unix.android_shlib) {\n                phdr = phdri;\n                for (unsigned j= 0; j < e_phnum; ++phdr, ++j) {\n                    upx_uint64_t const vaddr = get_te64(&phdr->p_vaddr);\n                    if (PT_NOTE64 == get_te32(&phdr->p_type)\n                    && xct_va < vaddr) {\n                        char buf[40]; snprintf(buf, sizeof(buf),\n                           \"PT_NOTE %#lx above stub\", (unsigned long)vaddr);\n                        throwCantPack(buf);\n                        goto abandon;\n                    }\n                }\n            }\n            xct_off = elf_get_offset_from_address(xct_va);\n            if (opt->debug.debug_level) {\n                fprintf(stderr, \"shlib canPack: xct_va=%#lx  xct_off=%lx\\n\",\n                    (long)xct_va, (long)xct_off);\n            }\n            goto proceed;  // But proper packing depends on checking xct_va.\n        }\n        else\n            throwCantPack(\"need DT_INIT; try \\\"void _init(void){}\\\"\");\nabandon:\n        return false;\nproceed: ;\n    }\n    // XXX Theoretically the following test should be first,\n    // but PackUnix::canPack() wants 0!=exetype ?\n    if (!super::canPack())\n        return false;\n    assert(exetype == 1);\n    exetype = 0;\n\n    // set options\n    opt->o_unix.blocksize = blocksize = file_size;\n    return true;\n}",
        "func": "bool\nPackLinuxElf64::canPack()\n{\n    union {\n        unsigned char buf[sizeof(Elf64_Ehdr) + 14*sizeof(Elf64_Phdr)];\n        //struct { Elf64_Ehdr ehdr; Elf64_Phdr phdr; } e;\n    } u;\n    COMPILE_TIME_ASSERT(sizeof(u) <= 1024)\n\n    fi->readx(u.buf, sizeof(u.buf));\n    fi->seek(0, SEEK_SET);\n    Elf64_Ehdr const *const ehdr = (Elf64_Ehdr *) u.buf;\n\n    // now check the ELF header\n    if (checkEhdr(ehdr) != 0)\n        return false;\n\n    // additional requirements for linux/elf386\n    if (get_te16(&ehdr->e_ehsize) != sizeof(*ehdr)) {\n        throwCantPack(\"invalid Ehdr e_ehsize; try '--force-execve'\");\n        return false;\n    }\n    if (e_phoff != sizeof(*ehdr)) {// Phdrs not contiguous with Ehdr\n        throwCantPack(\"non-contiguous Ehdr/Phdr; try '--force-execve'\");\n        return false;\n    }\n\n    // The first PT_LOAD64 must cover the beginning of the file (0==p_offset).\n    Elf64_Phdr const *phdr = phdri;\n    for (unsigned j=0; j < e_phnum; ++phdr, ++j) {\n        if (j >= 14) {\n            throwCantPack(\"too many ElfXX_Phdr; try '--force-execve'\");\n            return false;\n        }\n        unsigned const p_type = get_te32(&phdr->p_type);\n        if (1!=exetype && PT_LOAD64 == p_type) { // 1st PT_LOAD\n            exetype = 1;\n            load_va = get_te64(&phdr->p_vaddr);  // class data member\n            upx_uint64_t const p_offset = get_te64(&phdr->p_offset);\n            upx_uint64_t const off = ~page_mask & load_va;\n            if (off && off == p_offset) { // specific hint\n                throwCantPack(\"Go-language PT_LOAD: try hemfix.c, or try '--force-execve'\");\n                // Fixing it inside upx fails because packExtent() reads original file.\n                return false;\n            }\n            if (0 != p_offset) { // 1st PT_LOAD must cover Ehdr and Phdr\n                throwCantPack(\"first PT_LOAD.p_offset != 0; try '--force-execve'\");\n                return false;\n            }\n            hatch_off = ~3ul & (3+ get_te64(&phdr->p_memsz));\n            break;\n        }\n    }\n    // We want to compress position-independent executable (gcc -pie)\n    // main programs, but compressing a shared library must be avoided\n    // because the result is no longer usable.  In theory, there is no way\n    // to tell them apart: both are just ET_DYN.  Also in theory,\n    // neither the presence nor the absence of any particular symbol name\n    // can be used to tell them apart; there are counterexamples.\n    // However, we will use the following heuristic suggested by\n    // Peter S. Mazinger <ps.m@gmx.net> September 2005:\n    // If a ET_DYN has __libc_start_main as a global undefined symbol,\n    // then the file is a position-independent executable main program\n    // (that depends on libc.so.6) and is eligible to be compressed.\n    // Otherwise (no __libc_start_main as global undefined): skip it.\n    // Also allow  __uClibc_main  and  __uClibc_start_main .\n\n    if (Elf64_Ehdr::ET_DYN==get_te16(&ehdr->e_type)) {\n        // The DT_SYMTAB has no designated length.  Read the whole file.\n        alloc_file_image(file_image, file_size);\n        fi->seek(0, SEEK_SET);\n        fi->readx(file_image, file_size);\n        memcpy(&ehdri, ehdr, sizeof(Elf64_Ehdr));\n        phdri= (Elf64_Phdr *)((size_t)e_phoff + file_image);  // do not free() !!\n        shdri= (Elf64_Shdr *)((size_t)e_shoff + file_image);  // do not free() !!\n\n        sec_dynsym = elf_find_section_type(Elf64_Shdr::SHT_DYNSYM);\n        if (sec_dynsym)\n            sec_dynstr = get_te32(&sec_dynsym->sh_link) + shdri;\n\n        sec_strndx = &shdri[get_te16(&ehdr->e_shstrndx)];\n        shstrtab = (char const *)(get_te64(&sec_strndx->sh_offset) + file_image);\n        if (Elf64_Shdr::SHT_STRTAB != get_te32(&sec_strndx->sh_type)\n        || 0!=strcmp((char const *)\".shstrtab\",\n                    &shstrtab[get_te32(&sec_strndx->sh_name)]) ) {\n            throwCantPack(\"bad e_shstrndx\");\n        }\n\n        phdr= phdri;\n        for (int j= e_phnum; --j>=0; ++phdr)\n        if (Elf64_Phdr::PT_DYNAMIC==get_te32(&phdr->p_type)) {\n            dynseg= (Elf64_Dyn const *)(check_pt_dynamic(phdr) + file_image);\n            invert_pt_dynamic(dynseg);\n            break;\n        }\n        // elf_find_dynamic() returns 0 if 0==dynseg.\n        dynstr=          (char const *)elf_find_dynamic(Elf64_Dyn::DT_STRTAB);\n        dynsym=     (Elf64_Sym const *)elf_find_dynamic(Elf64_Dyn::DT_SYMTAB);\n\n        if (opt->o_unix.force_pie\n        ||       Elf64_Dyn::DF_1_PIE & elf_unsigned_dynamic(Elf64_Dyn::DT_FLAGS_1)\n        ||  calls_crt1((Elf64_Rela const *)elf_find_dynamic(Elf64_Dyn::DT_RELA),\n                                  (int)elf_unsigned_dynamic(Elf64_Dyn::DT_RELASZ))\n        ||  calls_crt1((Elf64_Rela const *)elf_find_dynamic(Elf64_Dyn::DT_JMPREL),\n                                  (int)elf_unsigned_dynamic(Elf64_Dyn::DT_PLTRELSZ))) {\n            is_pie = true;\n            goto proceed;  // calls C library init for main program\n        }\n\n        // Heuristic HACK for shared libraries (compare Darwin (MacOS) Dylib.)\n        // If there is an existing DT_INIT, and if everything that the dynamic\n        // linker ld-linux needs to perform relocations before calling DT_INIT\n        // resides below the first SHT_EXECINSTR Section in one PT_LOAD, then\n        // compress from the first executable Section to the end of that PT_LOAD.\n        // We must not alter anything that ld-linux might touch before it calls\n        // the DT_INIT function.\n        //\n        // Obviously this hack requires that the linker script put pieces\n        // into good positions when building the original shared library,\n        // and also requires ld-linux to behave.\n\n        if (elf_find_dynamic(upx_dt_init)) {\n            if (elf_has_dynamic(Elf64_Dyn::DT_TEXTREL)) {\n                throwCantPack(\"DT_TEXTREL found; re-compile with -fPIC\");\n                goto abandon;\n            }\n            Elf64_Shdr const *shdr = shdri;\n            xct_va = ~0ull;\n            if (e_shnum) {\n                for (int j= e_shnum; --j>=0; ++shdr) {\n                    unsigned const sh_type = get_te64(&shdr->sh_type);\n                    if (Elf64_Shdr::SHF_EXECINSTR & get_te64(&shdr->sh_flags)) {\n                        xct_va = umin(xct_va, get_te64(&shdr->sh_addr));\n                    }\n                    // Hook the first slot of DT_PREINIT_ARRAY or DT_INIT_ARRAY.\n                    if ((     Elf64_Dyn::DT_PREINIT_ARRAY==upx_dt_init\n                        &&  Elf64_Shdr::SHT_PREINIT_ARRAY==sh_type)\n                    ||  (     Elf64_Dyn::DT_INIT_ARRAY   ==upx_dt_init\n                        &&  Elf64_Shdr::SHT_INIT_ARRAY   ==sh_type) ) {\n                        user_init_off = get_te64(&shdr->sh_offset);\n                        user_init_va = get_te64(&file_image[user_init_off]);\n                    }\n                    // By default /usr/bin/ld leaves 4 extra DT_NULL to support pre-linking.\n                    // Take one as a last resort.\n                    if ((Elf64_Dyn::DT_INIT==upx_dt_init || !upx_dt_init)\n                    &&  Elf64_Shdr::SHT_DYNAMIC == sh_type) {\n                        unsigned const n = get_te64(&shdr->sh_size) / sizeof(Elf64_Dyn);\n                        Elf64_Dyn *dynp = (Elf64_Dyn *)&file_image[get_te64(&shdr->sh_offset)];\n                        for (; Elf64_Dyn::DT_NULL != dynp->d_tag; ++dynp) {\n                            if (upx_dt_init == get_te64(&dynp->d_tag)) {\n                                break;  // re-found DT_INIT\n                            }\n                        }\n                        if ((1+ dynp) < (n+ dynseg)) { // not the terminator, so take it\n                            user_init_va = get_te64(&dynp->d_val);  // 0 if (0==upx_dt_init)\n                            set_te64(&dynp->d_tag, upx_dt_init = Elf64_Dyn::DT_INIT);\n                            user_init_off = (char const *)&dynp->d_val - (char const *)&file_image[0];\n                        }\n                    }\n                }\n            }\n            else { // no Sections; use heuristics\n                upx_uint64_t const strsz  = elf_unsigned_dynamic(Elf64_Dyn::DT_STRSZ);\n                upx_uint64_t const strtab = elf_unsigned_dynamic(Elf64_Dyn::DT_STRTAB);\n                upx_uint64_t const relsz  = elf_unsigned_dynamic(Elf64_Dyn::DT_RELSZ);\n                upx_uint64_t const rel    = elf_unsigned_dynamic(Elf64_Dyn::DT_REL);\n                upx_uint64_t const init   = elf_unsigned_dynamic(upx_dt_init);\n                if ((init == (relsz + rel   ) && rel    == (strsz + strtab))\n                ||  (init == (strsz + strtab) && strtab == (relsz + rel   ))\n                ) {\n                    xct_va = init;\n                    user_init_va = init;\n                    user_init_off = elf_get_offset_from_address(init);\n                }\n            }\n            // Rely on 0==elf_unsigned_dynamic(tag) if no such tag.\n            upx_uint64_t const va_gash = elf_unsigned_dynamic(Elf64_Dyn::DT_GNU_HASH);\n            upx_uint64_t const va_hash = elf_unsigned_dynamic(Elf64_Dyn::DT_HASH);\n            unsigned y = 0;\n            if ((y=1, xct_va < va_gash)  ||  (y=2, (0==va_gash && xct_va < va_hash))\n            ||  (y=3, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_STRTAB))\n            ||  (y=4, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_SYMTAB))\n            ||  (y=5, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_REL))\n            ||  (y=6, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_RELA))\n            ||  (y=7, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_JMPREL))\n            ||  (y=8, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_VERDEF))\n            ||  (y=9, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_VERSYM))\n            ||  (y=10, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_VERNEEDED)) ) {\n                static char const *which[] = {\n                    \"unknown\",\n                    \"DT_GNU_HASH\",\n                    \"DT_HASH\",\n                    \"DT_STRTAB\",\n                    \"DT_SYMTAB\",\n                    \"DT_REL\",\n                    \"DT_RELA\",\n                    \"DT_JMPREL\",\n                    \"DT_VERDEF\",\n                    \"DT_VERSYM\",\n                    \"DT_VERNEEDED\",\n                };\n                char buf[30]; snprintf(buf, sizeof(buf), \"%s above stub\", which[y]);\n                throwCantPack(buf);\n                goto abandon;\n            }\n            if (!opt->o_unix.android_shlib) {\n                phdr = phdri;\n                for (unsigned j= 0; j < e_phnum; ++phdr, ++j) {\n                    upx_uint64_t const vaddr = get_te64(&phdr->p_vaddr);\n                    if (PT_NOTE64 == get_te32(&phdr->p_type)\n                    && xct_va < vaddr) {\n                        char buf[40]; snprintf(buf, sizeof(buf),\n                           \"PT_NOTE %#lx above stub\", (unsigned long)vaddr);\n                        throwCantPack(buf);\n                        goto abandon;\n                    }\n                }\n            }\n            xct_off = elf_get_offset_from_address(xct_va);\n            if (opt->debug.debug_level) {\n                fprintf(stderr, \"shlib canPack: xct_va=%#lx  xct_off=%lx\\n\",\n                    (long)xct_va, (long)xct_off);\n            }\n            goto proceed;  // But proper packing depends on checking xct_va.\n        }\n        else\n            throwCantPack(\"need DT_INIT; try \\\"void _init(void){}\\\"\");\nabandon:\n        return false;\nproceed: ;\n    }\n    // XXX Theoretically the following test should be first,\n    // but PackUnix::canPack() wants 0!=exetype ?\n    if (!super::canPack())\n        return false;\n    assert(exetype == 1);\n    exetype = 0;\n\n    // set options\n    opt->o_unix.blocksize = blocksize = file_size;\n    return true;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -176,16 +176,31 @@\n             // Rely on 0==elf_unsigned_dynamic(tag) if no such tag.\n             upx_uint64_t const va_gash = elf_unsigned_dynamic(Elf64_Dyn::DT_GNU_HASH);\n             upx_uint64_t const va_hash = elf_unsigned_dynamic(Elf64_Dyn::DT_HASH);\n-            if (xct_va < va_gash  ||  (0==va_gash && xct_va < va_hash)\n-            ||  xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_STRTAB)\n-            ||  xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_SYMTAB)\n-            ||  xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_REL)\n-            ||  xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_RELA)\n-            ||  xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_JMPREL)\n-            ||  xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_VERDEF)\n-            ||  xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_VERSYM)\n-            ||  xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_VERNEEDED) ) {\n-                throwCantPack(\"DT_ tag above stub\");\n+            unsigned y = 0;\n+            if ((y=1, xct_va < va_gash)  ||  (y=2, (0==va_gash && xct_va < va_hash))\n+            ||  (y=3, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_STRTAB))\n+            ||  (y=4, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_SYMTAB))\n+            ||  (y=5, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_REL))\n+            ||  (y=6, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_RELA))\n+            ||  (y=7, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_JMPREL))\n+            ||  (y=8, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_VERDEF))\n+            ||  (y=9, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_VERSYM))\n+            ||  (y=10, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_VERNEEDED)) ) {\n+                static char const *which[] = {\n+                    \"unknown\",\n+                    \"DT_GNU_HASH\",\n+                    \"DT_HASH\",\n+                    \"DT_STRTAB\",\n+                    \"DT_SYMTAB\",\n+                    \"DT_REL\",\n+                    \"DT_RELA\",\n+                    \"DT_JMPREL\",\n+                    \"DT_VERDEF\",\n+                    \"DT_VERSYM\",\n+                    \"DT_VERNEEDED\",\n+                };\n+                char buf[30]; snprintf(buf, sizeof(buf), \"%s above stub\", which[y]);\n+                throwCantPack(buf);\n                 goto abandon;\n             }\n             if (!opt->o_unix.android_shlib) {",
        "diff_line_info": {
            "deleted_lines": [
                "            if (xct_va < va_gash  ||  (0==va_gash && xct_va < va_hash)",
                "            ||  xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_STRTAB)",
                "            ||  xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_SYMTAB)",
                "            ||  xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_REL)",
                "            ||  xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_RELA)",
                "            ||  xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_JMPREL)",
                "            ||  xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_VERDEF)",
                "            ||  xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_VERSYM)",
                "            ||  xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_VERNEEDED) ) {",
                "                throwCantPack(\"DT_ tag above stub\");"
            ],
            "added_lines": [
                "            unsigned y = 0;",
                "            if ((y=1, xct_va < va_gash)  ||  (y=2, (0==va_gash && xct_va < va_hash))",
                "            ||  (y=3, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_STRTAB))",
                "            ||  (y=4, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_SYMTAB))",
                "            ||  (y=5, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_REL))",
                "            ||  (y=6, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_RELA))",
                "            ||  (y=7, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_JMPREL))",
                "            ||  (y=8, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_VERDEF))",
                "            ||  (y=9, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_VERSYM))",
                "            ||  (y=10, xct_va < elf_unsigned_dynamic(Elf64_Dyn::DT_VERNEEDED)) ) {",
                "                static char const *which[] = {",
                "                    \"unknown\",",
                "                    \"DT_GNU_HASH\",",
                "                    \"DT_HASH\",",
                "                    \"DT_STRTAB\",",
                "                    \"DT_SYMTAB\",",
                "                    \"DT_REL\",",
                "                    \"DT_RELA\",",
                "                    \"DT_JMPREL\",",
                "                    \"DT_VERDEF\",",
                "                    \"DT_VERSYM\",",
                "                    \"DT_VERNEEDED\",",
                "                };",
                "                char buf[30]; snprintf(buf, sizeof(buf), \"%s above stub\", which[y]);",
                "                throwCantPack(buf);"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-11243",
        "func_name": "upx/PackLinuxElf32::calls_crt1",
        "description": "PackLinuxElf64::unpack in p_lx_elf.cpp in UPX 3.95 allows remote attackers to cause a denial of service (double free), limit the ability of a malware scanner to operate on the entire original data, or possibly have unspecified other impact via a crafted file.",
        "git_url": "https://github.com/upx/upx/commit/d9288213ec156dffc435566b9d393d23e87c6914",
        "commit_title": "More checking of PT_DYNAMIC and its contents.",
        "commit_text": " https://github.com/upx/upx/issues/206 \tmodified:   p_lx_elf.cpp",
        "func_before": "bool PackLinuxElf32::calls_crt1(Elf32_Rel const *rel, int sz)\n{\n    for (; 0 < sz; (sz -= sizeof(Elf32_Rel)), ++rel) {\n        unsigned const symnum = get_te32(&rel->r_info) >> 8;\n        char const *const symnam = get_te32(&dynsym[symnum].st_name) + dynstr;\n        if (0==strcmp(symnam, \"__libc_start_main\")  // glibc\n        ||  0==strcmp(symnam, \"__libc_init\")  // Android\n        ||  0==strcmp(symnam, \"__uClibc_main\")\n        ||  0==strcmp(symnam, \"__uClibc_start_main\"))\n            return true;\n    }\n    return false;\n}",
        "func": "bool PackLinuxElf32::calls_crt1(Elf32_Rel const *rel, int sz)\n{\n    if (!dynsym || !dynstr) {\n        return false;\n    }\n    for (; 0 < sz; (sz -= sizeof(Elf32_Rel)), ++rel) {\n        unsigned const symnum = get_te32(&rel->r_info) >> 8;\n        char const *const symnam = get_te32(&dynsym[symnum].st_name) + dynstr;\n        if (0==strcmp(symnam, \"__libc_start_main\")  // glibc\n        ||  0==strcmp(symnam, \"__libc_init\")  // Android\n        ||  0==strcmp(symnam, \"__uClibc_main\")\n        ||  0==strcmp(symnam, \"__uClibc_start_main\"))\n            return true;\n    }\n    return false;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,8 @@\n bool PackLinuxElf32::calls_crt1(Elf32_Rel const *rel, int sz)\n {\n+    if (!dynsym || !dynstr) {\n+        return false;\n+    }\n     for (; 0 < sz; (sz -= sizeof(Elf32_Rel)), ++rel) {\n         unsigned const symnum = get_te32(&rel->r_info) >> 8;\n         char const *const symnam = get_te32(&dynsym[symnum].st_name) + dynstr;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    if (!dynsym || !dynstr) {",
                "        return false;",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-11243",
        "func_name": "upx/PackLinuxElf64::check_pt_dynamic",
        "description": "PackLinuxElf64::unpack in p_lx_elf.cpp in UPX 3.95 allows remote attackers to cause a denial of service (double free), limit the ability of a malware scanner to operate on the entire original data, or possibly have unspecified other impact via a crafted file.",
        "git_url": "https://github.com/upx/upx/commit/d9288213ec156dffc435566b9d393d23e87c6914",
        "commit_title": "More checking of PT_DYNAMIC and its contents.",
        "commit_text": " https://github.com/upx/upx/issues/206 \tmodified:   p_lx_elf.cpp",
        "func_before": "upx_uint64_t  // checked .p_offset; sz_dynseg set\nPackLinuxElf64::check_pt_dynamic(Elf64_Phdr const *const phdr)\n{\n    upx_uint64_t t = get_te64(&phdr->p_offset), s = sizeof(Elf64_Dyn) + t;\n    upx_uint64_t filesz = get_te64(&phdr->p_filesz), memsz = get_te64(&phdr->p_memsz);\n    if (s < t || (upx_uint64_t)file_size < s\n    ||  (7 & t) || (0xf & (filesz | memsz))  // .balign 8; 16==sizeof(Elf64_Dyn)\n    ||  filesz < sizeof(Elf64_Dyn)\n    ||  memsz  < sizeof(Elf64_Dyn)\n    ||  filesz < memsz) {\n        char msg[50]; snprintf(msg, sizeof(msg), \"bad PT_DYNAMIC phdr[%u]\",\n            (unsigned)(phdr - phdri));\n        throwCantPack(msg);\n    }\n    sz_dynseg = memsz;\n    return t;\n}",
        "func": "upx_uint64_t  // checked .p_offset; sz_dynseg set\nPackLinuxElf64::check_pt_dynamic(Elf64_Phdr const *const phdr)\n{\n    upx_uint64_t t = get_te64(&phdr->p_offset), s = sizeof(Elf64_Dyn) + t;\n    upx_uint64_t vaddr = get_te64(&phdr->p_vaddr);\n    upx_uint64_t filesz = get_te64(&phdr->p_filesz), memsz = get_te64(&phdr->p_memsz);\n    if (s < t || (upx_uint64_t)file_size < s\n    ||  (7 & t) || (0xf & (filesz | memsz))  // .balign 8; 16==sizeof(Elf64_Dyn)\n    ||  (-1+ page_size) & (t ^ vaddr)\n    ||  filesz < sizeof(Elf64_Dyn)\n    ||  memsz  < sizeof(Elf64_Dyn)\n    ||  filesz < memsz) {\n        char msg[50]; snprintf(msg, sizeof(msg), \"bad PT_DYNAMIC phdr[%u]\",\n            (unsigned)(phdr - phdri));\n        throwCantPack(msg);\n    }\n    sz_dynseg = memsz;\n    return t;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,9 +2,11 @@\n PackLinuxElf64::check_pt_dynamic(Elf64_Phdr const *const phdr)\n {\n     upx_uint64_t t = get_te64(&phdr->p_offset), s = sizeof(Elf64_Dyn) + t;\n+    upx_uint64_t vaddr = get_te64(&phdr->p_vaddr);\n     upx_uint64_t filesz = get_te64(&phdr->p_filesz), memsz = get_te64(&phdr->p_memsz);\n     if (s < t || (upx_uint64_t)file_size < s\n     ||  (7 & t) || (0xf & (filesz | memsz))  // .balign 8; 16==sizeof(Elf64_Dyn)\n+    ||  (-1+ page_size) & (t ^ vaddr)\n     ||  filesz < sizeof(Elf64_Dyn)\n     ||  memsz  < sizeof(Elf64_Dyn)\n     ||  filesz < memsz) {",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    upx_uint64_t vaddr = get_te64(&phdr->p_vaddr);",
                "    ||  (-1+ page_size) & (t ^ vaddr)"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-20792",
        "func_name": "OpenSC/coolkey_add_object",
        "description": "OpenSC before 0.20.0 has a double free in coolkey_free_private_data because coolkey_add_object in libopensc/card-coolkey.c lacks a uniqueness check.",
        "git_url": "https://github.com/OpenSC/OpenSC/commit/c246f6f69a749d4f68626b40795a4f69168008f4",
        "commit_title": "coolkey: Make sure the object ID is unique when filling list",
        "commit_text": " Thanks to oss-fuzz  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=19208",
        "func_before": "static int\ncoolkey_add_object(coolkey_private_data_t *priv, unsigned long object_id, const u8 *object_data, size_t object_length, int add_v1_record)\n{\n\tsc_cardctl_coolkey_object_t new_object;\n\tint r;\n\n\tmemset(&new_object, 0, sizeof(new_object));\n\tnew_object.path = coolkey_template_path;\n\tnew_object.path.len = 4;\n\tulong2bebytes(new_object.path.value, object_id);\n\tnew_object.id = object_id;\n\tnew_object.length = object_length;\n\n\tif (object_data) {\n\t\tnew_object.data = malloc(object_length + add_v1_record);\n\t\tif (new_object.data == NULL) {\n\t\t\treturn SC_ERROR_OUT_OF_MEMORY;\n\t\t}\n\t\tif (add_v1_record) {\n\t\t\tnew_object.data[0] = COOLKEY_V1_OBJECT;\n\t\t\tnew_object.length++;\n\t\t}\n\t\tmemcpy(&new_object.data[add_v1_record], object_data, object_length);\n\t}\n\n\tr = coolkey_add_object_to_list(&priv->objects_list, &new_object);\n\tif (r != SC_SUCCESS) {\n\t\t/* if we didn't successfully put the object on the list,\n\t\t * the data space didn't get adopted. free it before we return */\n\t\tfree(new_object.data);\n\t\tnew_object.data = NULL;\n\t}\n\treturn r;\n}",
        "func": "static int\ncoolkey_add_object(coolkey_private_data_t *priv, unsigned long object_id, const u8 *object_data, size_t object_length, int add_v1_record)\n{\n\tsc_cardctl_coolkey_object_t new_object;\n\tint r;\n\n\tmemset(&new_object, 0, sizeof(new_object));\n\tnew_object.path = coolkey_template_path;\n\tnew_object.path.len = 4;\n\tulong2bebytes(new_object.path.value, object_id);\n\tnew_object.id = object_id;\n\tnew_object.length = object_length;\n\n\t/* The object ID needs to be unique */\n\tif (coolkey_find_object_by_id(&priv->objects_list, object_id) != NULL) {\n\t\treturn SC_ERROR_INTERNAL;\n\t}\n\n\tif (object_data) {\n\t\tnew_object.data = malloc(object_length + add_v1_record);\n\t\tif (new_object.data == NULL) {\n\t\t\treturn SC_ERROR_OUT_OF_MEMORY;\n\t\t}\n\t\tif (add_v1_record) {\n\t\t\tnew_object.data[0] = COOLKEY_V1_OBJECT;\n\t\t\tnew_object.length++;\n\t\t}\n\t\tmemcpy(&new_object.data[add_v1_record], object_data, object_length);\n\t}\n\n\tr = coolkey_add_object_to_list(&priv->objects_list, &new_object);\n\tif (r != SC_SUCCESS) {\n\t\t/* if we didn't successfully put the object on the list,\n\t\t * the data space didn't get adopted. free it before we return */\n\t\tfree(new_object.data);\n\t\tnew_object.data = NULL;\n\t}\n\treturn r;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -10,6 +10,11 @@\n \tulong2bebytes(new_object.path.value, object_id);\n \tnew_object.id = object_id;\n \tnew_object.length = object_length;\n+\n+\t/* The object ID needs to be unique */\n+\tif (coolkey_find_object_by_id(&priv->objects_list, object_id) != NULL) {\n+\t\treturn SC_ERROR_INTERNAL;\n+\t}\n \n \tif (object_data) {\n \t\tnew_object.data = malloc(object_length + add_v1_record);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "\t/* The object ID needs to be unique */",
                "\tif (coolkey_find_object_by_id(&priv->objects_list, object_id) != NULL) {",
                "\t\treturn SC_ERROR_INTERNAL;",
                "\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-11044",
        "func_name": "FreeRDP/update_read_cache_bitmap_v3_order",
        "description": "In FreeRDP greater than 1.2 and before 2.0.0, a double free in update_read_cache_bitmap_v3_order crashes the client application if corrupted data from a manipulated server is parsed. This has been patched in 2.0.0.",
        "git_url": "https://github.com/FreeRDP/FreeRDP/commit/67c2aa52b2ae0341d469071d1bc8aab91f8d2ed8",
        "commit_title": "Fixed #6013: Check new length is > 0",
        "commit_text": "",
        "func_before": "static CACHE_BITMAP_V3_ORDER* update_read_cache_bitmap_v3_order(rdpUpdate* update, wStream* s,\n                                                                UINT16 flags)\n{\n\tBYTE bitsPerPixelId;\n\tBITMAP_DATA_EX* bitmapData;\n\tUINT32 new_len;\n\tBYTE* new_data;\n\tCACHE_BITMAP_V3_ORDER* cache_bitmap_v3;\n\n\tif (!update || !s)\n\t\treturn NULL;\n\n\tcache_bitmap_v3 = calloc(1, sizeof(CACHE_BITMAP_V3_ORDER));\n\n\tif (!cache_bitmap_v3)\n\t\tgoto fail;\n\n\tcache_bitmap_v3->cacheId = flags & 0x00000003;\n\tcache_bitmap_v3->flags = (flags & 0x0000FF80) >> 7;\n\tbitsPerPixelId = (flags & 0x00000078) >> 3;\n\tcache_bitmap_v3->bpp = CBR23_BPP[bitsPerPixelId];\n\n\tif (Stream_GetRemainingLength(s) < 21)\n\t\tgoto fail;\n\n\tStream_Read_UINT16(s, cache_bitmap_v3->cacheIndex); /* cacheIndex (2 bytes) */\n\tStream_Read_UINT32(s, cache_bitmap_v3->key1);       /* key1 (4 bytes) */\n\tStream_Read_UINT32(s, cache_bitmap_v3->key2);       /* key2 (4 bytes) */\n\tbitmapData = &cache_bitmap_v3->bitmapData;\n\tStream_Read_UINT8(s, bitmapData->bpp);\n\n\tif ((bitmapData->bpp < 1) || (bitmapData->bpp > 32))\n\t{\n\t\tWLog_Print(update->log, WLOG_ERROR, \"invalid bpp value %\" PRIu32 \"\", bitmapData->bpp);\n\t\tgoto fail;\n\t}\n\n\tStream_Seek_UINT8(s);                      /* reserved1 (1 byte) */\n\tStream_Seek_UINT8(s);                      /* reserved2 (1 byte) */\n\tStream_Read_UINT8(s, bitmapData->codecID); /* codecID (1 byte) */\n\tStream_Read_UINT16(s, bitmapData->width);  /* width (2 bytes) */\n\tStream_Read_UINT16(s, bitmapData->height); /* height (2 bytes) */\n\tStream_Read_UINT32(s, new_len);            /* length (4 bytes) */\n\n\tif (Stream_GetRemainingLength(s) < new_len)\n\t\tgoto fail;\n\n\tnew_data = (BYTE*)realloc(bitmapData->data, new_len);\n\n\tif (!new_data)\n\t\tgoto fail;\n\n\tbitmapData->data = new_data;\n\tbitmapData->length = new_len;\n\tStream_Read(s, bitmapData->data, bitmapData->length);\n\treturn cache_bitmap_v3;\nfail:\n\tfree_cache_bitmap_v3_order(update->context, cache_bitmap_v3);\n\treturn NULL;\n}",
        "func": "static CACHE_BITMAP_V3_ORDER* update_read_cache_bitmap_v3_order(rdpUpdate* update, wStream* s,\n                                                                UINT16 flags)\n{\n\tBYTE bitsPerPixelId;\n\tBITMAP_DATA_EX* bitmapData;\n\tUINT32 new_len;\n\tBYTE* new_data;\n\tCACHE_BITMAP_V3_ORDER* cache_bitmap_v3;\n\n\tif (!update || !s)\n\t\treturn NULL;\n\n\tcache_bitmap_v3 = calloc(1, sizeof(CACHE_BITMAP_V3_ORDER));\n\n\tif (!cache_bitmap_v3)\n\t\tgoto fail;\n\n\tcache_bitmap_v3->cacheId = flags & 0x00000003;\n\tcache_bitmap_v3->flags = (flags & 0x0000FF80) >> 7;\n\tbitsPerPixelId = (flags & 0x00000078) >> 3;\n\tcache_bitmap_v3->bpp = CBR23_BPP[bitsPerPixelId];\n\n\tif (Stream_GetRemainingLength(s) < 21)\n\t\tgoto fail;\n\n\tStream_Read_UINT16(s, cache_bitmap_v3->cacheIndex); /* cacheIndex (2 bytes) */\n\tStream_Read_UINT32(s, cache_bitmap_v3->key1);       /* key1 (4 bytes) */\n\tStream_Read_UINT32(s, cache_bitmap_v3->key2);       /* key2 (4 bytes) */\n\tbitmapData = &cache_bitmap_v3->bitmapData;\n\tStream_Read_UINT8(s, bitmapData->bpp);\n\n\tif ((bitmapData->bpp < 1) || (bitmapData->bpp > 32))\n\t{\n\t\tWLog_Print(update->log, WLOG_ERROR, \"invalid bpp value %\" PRIu32 \"\", bitmapData->bpp);\n\t\tgoto fail;\n\t}\n\n\tStream_Seek_UINT8(s);                      /* reserved1 (1 byte) */\n\tStream_Seek_UINT8(s);                      /* reserved2 (1 byte) */\n\tStream_Read_UINT8(s, bitmapData->codecID); /* codecID (1 byte) */\n\tStream_Read_UINT16(s, bitmapData->width);  /* width (2 bytes) */\n\tStream_Read_UINT16(s, bitmapData->height); /* height (2 bytes) */\n\tStream_Read_UINT32(s, new_len);            /* length (4 bytes) */\n\n\tif ((new_len == 0) || (Stream_GetRemainingLength(s) < new_len))\n\t\tgoto fail;\n\n\tnew_data = (BYTE*)realloc(bitmapData->data, new_len);\n\n\tif (!new_data)\n\t\tgoto fail;\n\n\tbitmapData->data = new_data;\n\tbitmapData->length = new_len;\n\tStream_Read(s, bitmapData->data, bitmapData->length);\n\treturn cache_bitmap_v3;\nfail:\n\tfree_cache_bitmap_v3_order(update->context, cache_bitmap_v3);\n\treturn NULL;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -42,7 +42,7 @@\n \tStream_Read_UINT16(s, bitmapData->height); /* height (2 bytes) */\n \tStream_Read_UINT32(s, new_len);            /* length (4 bytes) */\n \n-\tif (Stream_GetRemainingLength(s) < new_len)\n+\tif ((new_len == 0) || (Stream_GetRemainingLength(s) < new_len))\n \t\tgoto fail;\n \n \tnew_data = (BYTE*)realloc(bitmapData->data, new_len);",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (Stream_GetRemainingLength(s) < new_len)"
            ],
            "added_lines": [
                "\tif ((new_len == 0) || (Stream_GetRemainingLength(s) < new_len))"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-20892",
        "func_name": "net-snmp/_clone_pdu_header",
        "description": "net-snmp before 5.8.1.pre1 has a double free in usm_free_usmStateReference in snmplib/snmpusm.c via an SNMPv3 GetBulk request. NOTE: this affects net-snmp packages shipped to end users by multiple Linux distributions, but might not affect an upstream release.",
        "git_url": "https://github.com/net-snmp/net-snmp/commit/5f881d3bf24599b90d67a45cae7a3eb099cd71c9",
        "commit_title": "libsnmp, USM: Introduce a reference count in struct usmStateReference",
        "commit_text": " This patch fixes https://sourceforge.net/p/net-snmp/bugs/2956/.",
        "func_before": "static\nnetsnmp_pdu    *\n_clone_pdu_header(netsnmp_pdu *pdu)\n{\n    netsnmp_pdu    *newpdu;\n    struct snmp_secmod_def *sptr;\n    int ret;\n\n    if (!pdu)\n        return NULL;\n\n    newpdu = (netsnmp_pdu *) malloc(sizeof(netsnmp_pdu));\n    if (!newpdu)\n        return NULL;\n    memmove(newpdu, pdu, sizeof(netsnmp_pdu));\n\n    /*\n     * reset copied pointers if copy fails \n     */\n    newpdu->variables = NULL;\n    newpdu->enterprise = NULL;\n    newpdu->community = NULL;\n    newpdu->securityEngineID = NULL;\n    newpdu->securityName = NULL;\n    newpdu->contextEngineID = NULL;\n    newpdu->contextName = NULL;\n    newpdu->transport_data = NULL;\n\n    /*\n     * copy buffers individually. If any copy fails, all are freed. \n     */\n    if (snmp_clone_mem((void **) &newpdu->enterprise, pdu->enterprise,\n                       sizeof(oid) * pdu->enterprise_length) ||\n        snmp_clone_mem((void **) &newpdu->community, pdu->community,\n                       pdu->community_len) ||\n        snmp_clone_mem((void **) &newpdu->contextEngineID,\n                       pdu->contextEngineID, pdu->contextEngineIDLen)\n        || snmp_clone_mem((void **) &newpdu->securityEngineID,\n                          pdu->securityEngineID, pdu->securityEngineIDLen)\n        || snmp_clone_mem((void **) &newpdu->contextName, pdu->contextName,\n                          pdu->contextNameLen)\n        || snmp_clone_mem((void **) &newpdu->securityName,\n                          pdu->securityName, pdu->securityNameLen)\n        || snmp_clone_mem((void **) &newpdu->transport_data,\n                          pdu->transport_data,\n                          pdu->transport_data_length)) {\n        snmp_free_pdu(newpdu);\n        return NULL;\n    }\n\n    if (pdu->securityStateRef &&\n        pdu->command == SNMP_MSG_TRAP2) {\n\n        netsnmp_assert(pdu->securityModel == SNMP_DEFAULT_SECMODEL);\n        ret = usm_clone_usmStateReference((struct usmStateReference *) pdu->securityStateRef,\n                (struct usmStateReference **) &newpdu->securityStateRef );\n\n        if (ret)\n        {\n            snmp_free_pdu(newpdu);\n            return NULL;\n        }\n    }\n\n    if ((sptr = find_sec_mod(newpdu->securityModel)) != NULL &&\n        sptr->pdu_clone != NULL) {\n        /*\n         * call security model if it needs to know about this \n         */\n        (*sptr->pdu_clone) (pdu, newpdu);\n    }\n\n    return newpdu;\n}",
        "func": "static\nnetsnmp_pdu    *\n_clone_pdu_header(netsnmp_pdu *pdu)\n{\n    netsnmp_pdu    *newpdu;\n    struct snmp_secmod_def *sptr;\n    int ret;\n\n    if (!pdu)\n        return NULL;\n\n    newpdu = (netsnmp_pdu *) malloc(sizeof(netsnmp_pdu));\n    if (!newpdu)\n        return NULL;\n    memmove(newpdu, pdu, sizeof(netsnmp_pdu));\n\n    /*\n     * reset copied pointers if copy fails \n     */\n    newpdu->variables = NULL;\n    newpdu->enterprise = NULL;\n    newpdu->community = NULL;\n    newpdu->securityEngineID = NULL;\n    newpdu->securityName = NULL;\n    newpdu->contextEngineID = NULL;\n    newpdu->contextName = NULL;\n    newpdu->transport_data = NULL;\n\n    /*\n     * copy buffers individually. If any copy fails, all are freed. \n     */\n    if (snmp_clone_mem((void **) &newpdu->enterprise, pdu->enterprise,\n                       sizeof(oid) * pdu->enterprise_length) ||\n        snmp_clone_mem((void **) &newpdu->community, pdu->community,\n                       pdu->community_len) ||\n        snmp_clone_mem((void **) &newpdu->contextEngineID,\n                       pdu->contextEngineID, pdu->contextEngineIDLen)\n        || snmp_clone_mem((void **) &newpdu->securityEngineID,\n                          pdu->securityEngineID, pdu->securityEngineIDLen)\n        || snmp_clone_mem((void **) &newpdu->contextName, pdu->contextName,\n                          pdu->contextNameLen)\n        || snmp_clone_mem((void **) &newpdu->securityName,\n                          pdu->securityName, pdu->securityNameLen)\n        || snmp_clone_mem((void **) &newpdu->transport_data,\n                          pdu->transport_data,\n                          pdu->transport_data_length)) {\n        snmp_free_pdu(newpdu);\n        return NULL;\n    }\n\n    sptr = find_sec_mod(newpdu->securityModel);\n    if (sptr && sptr->pdu_clone) {\n        /* call security model if it needs to know about this */\n        ret = sptr->pdu_clone(pdu, newpdu);\n        if (ret) {\n            snmp_free_pdu(newpdu);\n            return NULL;\n        }\n    }\n\n    return newpdu;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -48,27 +48,15 @@\n         return NULL;\n     }\n \n-    if (pdu->securityStateRef &&\n-        pdu->command == SNMP_MSG_TRAP2) {\n-\n-        netsnmp_assert(pdu->securityModel == SNMP_DEFAULT_SECMODEL);\n-        ret = usm_clone_usmStateReference((struct usmStateReference *) pdu->securityStateRef,\n-                (struct usmStateReference **) &newpdu->securityStateRef );\n-\n-        if (ret)\n-        {\n+    sptr = find_sec_mod(newpdu->securityModel);\n+    if (sptr && sptr->pdu_clone) {\n+        /* call security model if it needs to know about this */\n+        ret = sptr->pdu_clone(pdu, newpdu);\n+        if (ret) {\n             snmp_free_pdu(newpdu);\n             return NULL;\n         }\n     }\n \n-    if ((sptr = find_sec_mod(newpdu->securityModel)) != NULL &&\n-        sptr->pdu_clone != NULL) {\n-        /*\n-         * call security model if it needs to know about this \n-         */\n-        (*sptr->pdu_clone) (pdu, newpdu);\n-    }\n-\n     return newpdu;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    if (pdu->securityStateRef &&",
                "        pdu->command == SNMP_MSG_TRAP2) {",
                "",
                "        netsnmp_assert(pdu->securityModel == SNMP_DEFAULT_SECMODEL);",
                "        ret = usm_clone_usmStateReference((struct usmStateReference *) pdu->securityStateRef,",
                "                (struct usmStateReference **) &newpdu->securityStateRef );",
                "",
                "        if (ret)",
                "        {",
                "    if ((sptr = find_sec_mod(newpdu->securityModel)) != NULL &&",
                "        sptr->pdu_clone != NULL) {",
                "        /*",
                "         * call security model if it needs to know about this ",
                "         */",
                "        (*sptr->pdu_clone) (pdu, newpdu);",
                "    }",
                ""
            ],
            "added_lines": [
                "    sptr = find_sec_mod(newpdu->securityModel);",
                "    if (sptr && sptr->pdu_clone) {",
                "        /* call security model if it needs to know about this */",
                "        ret = sptr->pdu_clone(pdu, newpdu);",
                "        if (ret) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-20892",
        "func_name": "net-snmp/init_usm",
        "description": "net-snmp before 5.8.1.pre1 has a double free in usm_free_usmStateReference in snmplib/snmpusm.c via an SNMPv3 GetBulk request. NOTE: this affects net-snmp packages shipped to end users by multiple Linux distributions, but might not affect an upstream release.",
        "git_url": "https://github.com/net-snmp/net-snmp/commit/5f881d3bf24599b90d67a45cae7a3eb099cd71c9",
        "commit_title": "libsnmp, USM: Introduce a reference count in struct usmStateReference",
        "commit_text": " This patch fixes https://sourceforge.net/p/net-snmp/bugs/2956/.",
        "func_before": "void\ninit_usm(void)\n{\n    struct snmp_secmod_def *def;\n    char *type;\n\n    DEBUGMSGTL((\"init_usm\", \"unit_usm: %\" NETSNMP_PRIo \"u %\" NETSNMP_PRIo \"u\\n\",\n                usmNoPrivProtocol[0], usmNoPrivProtocol[1]));\n\n    sc_init();                  /* initalize scapi code */\n\n    /*\n     * register ourselves as a security service\n     */\n    def = SNMP_MALLOC_STRUCT(snmp_secmod_def);\n    if (def == NULL)\n        return;\n    /*\n     * XXX: def->init_sess_secmod move stuff from snmp_api.c\n     */\n    def->encode_reverse = usm_secmod_rgenerate_out_msg;\n    def->encode_forward = usm_secmod_generate_out_msg;\n    def->decode = usm_secmod_process_in_msg;\n    def->pdu_free_state_ref = usm_free_usmStateReference;\n    def->session_setup = usm_session_init;\n    def->handle_report = usm_handle_report;\n    def->probe_engineid = usm_discover_engineid;\n    def->post_probe_engineid = usm_create_user_from_session_hook;\n    if (register_sec_mod(USM_SEC_MODEL_NUMBER, \"usm\", def) != SNMPERR_SUCCESS) {\n        SNMP_FREE(def);\n        snmp_log(LOG_ERR, \"could not register usm sec mod\\n\");\n        return;\n    }\n\n    snmp_register_callback(SNMP_CALLBACK_LIBRARY,\n                           SNMP_CALLBACK_POST_PREMIB_READ_CONFIG,\n                           init_usm_post_config, NULL);\n\n    snmp_register_callback(SNMP_CALLBACK_LIBRARY,\n                           SNMP_CALLBACK_SHUTDOWN,\n                           deinit_usm_post_config, NULL);\n\n    snmp_register_callback(SNMP_CALLBACK_LIBRARY,\n                           SNMP_CALLBACK_SHUTDOWN,\n                           free_engineID, NULL);\n\n    register_config_handler(\"snmp\", \"defAuthType\", snmpv3_authtype_conf,\n                            NULL, \"MD5|SHA|SHA-512|SHA-384|SHA-256|SHA-224\");\n    register_config_handler(\"snmp\", \"defPrivType\", snmpv3_privtype_conf,\n                            NULL,\n                            \"DES\"\n#ifdef HAVE_AES\n                            \"|AES|AES-128\"\n#ifdef NETSNMP_DRAFT_BLUMENTHAL_AES_04\n                            \"|AES-192|AES-256\"\n#endif /* NETSNMP_DRAFT_BLUMENTHAL_AES_04 */\n#else\n                            \" (AES support not available)\"\n#endif\n                           );\n\n    /*\n     * Free stuff at shutdown time\n     */\n    snmp_register_callback(SNMP_CALLBACK_LIBRARY,\n                           SNMP_CALLBACK_SHUTDOWN,\n                           free_enginetime_on_shutdown, NULL);\n\n\n    type = netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_APPTYPE);\n\n    register_config_handler(type, \"userSetAuthPass\", usm_set_password,\n                            NULL, NULL);\n    register_config_handler(type, \"userSetPrivPass\", usm_set_password,\n                            NULL, NULL);\n    register_config_handler(type, \"userSetAuthKey\", usm_set_password, NULL,\n                            NULL);\n    register_config_handler(type, \"userSetPrivKey\", usm_set_password, NULL,\n                            NULL);\n    register_config_handler(type, \"userSetAuthLocalKey\", usm_set_password,\n                            NULL, NULL);\n    register_config_handler(type, \"userSetPrivLocalKey\", usm_set_password,\n                            NULL, NULL);\n}",
        "func": "void\ninit_usm(void)\n{\n    struct snmp_secmod_def *def;\n    char *type;\n\n    DEBUGMSGTL((\"init_usm\", \"unit_usm: %\" NETSNMP_PRIo \"u %\" NETSNMP_PRIo \"u\\n\",\n                usmNoPrivProtocol[0], usmNoPrivProtocol[1]));\n\n    sc_init();                  /* initalize scapi code */\n\n    /*\n     * register ourselves as a security service\n     */\n    def = SNMP_MALLOC_STRUCT(snmp_secmod_def);\n    if (def == NULL)\n        return;\n    /*\n     * XXX: def->init_sess_secmod move stuff from snmp_api.c\n     */\n    def->encode_reverse = usm_secmod_rgenerate_out_msg;\n    def->encode_forward = usm_secmod_generate_out_msg;\n    def->decode = usm_secmod_process_in_msg;\n    def->pdu_clone = usm_clone;\n    def->pdu_free_state_ref = usm_free_usmStateReference;\n    def->session_setup = usm_session_init;\n    def->handle_report = usm_handle_report;\n    def->probe_engineid = usm_discover_engineid;\n    def->post_probe_engineid = usm_create_user_from_session_hook;\n    if (register_sec_mod(USM_SEC_MODEL_NUMBER, \"usm\", def) != SNMPERR_SUCCESS) {\n        SNMP_FREE(def);\n        snmp_log(LOG_ERR, \"could not register usm sec mod\\n\");\n        return;\n    }\n\n    snmp_register_callback(SNMP_CALLBACK_LIBRARY,\n                           SNMP_CALLBACK_POST_PREMIB_READ_CONFIG,\n                           init_usm_post_config, NULL);\n\n    snmp_register_callback(SNMP_CALLBACK_LIBRARY,\n                           SNMP_CALLBACK_SHUTDOWN,\n                           deinit_usm_post_config, NULL);\n\n    snmp_register_callback(SNMP_CALLBACK_LIBRARY,\n                           SNMP_CALLBACK_SHUTDOWN,\n                           free_engineID, NULL);\n\n    register_config_handler(\"snmp\", \"defAuthType\", snmpv3_authtype_conf,\n                            NULL, \"MD5|SHA|SHA-512|SHA-384|SHA-256|SHA-224\");\n    register_config_handler(\"snmp\", \"defPrivType\", snmpv3_privtype_conf,\n                            NULL,\n                            \"DES\"\n#ifdef HAVE_AES\n                            \"|AES|AES-128\"\n#ifdef NETSNMP_DRAFT_BLUMENTHAL_AES_04\n                            \"|AES-192|AES-256\"\n#endif /* NETSNMP_DRAFT_BLUMENTHAL_AES_04 */\n#else\n                            \" (AES support not available)\"\n#endif\n                           );\n\n    /*\n     * Free stuff at shutdown time\n     */\n    snmp_register_callback(SNMP_CALLBACK_LIBRARY,\n                           SNMP_CALLBACK_SHUTDOWN,\n                           free_enginetime_on_shutdown, NULL);\n\n\n    type = netsnmp_ds_get_string(NETSNMP_DS_LIBRARY_ID, NETSNMP_DS_LIB_APPTYPE);\n\n    register_config_handler(type, \"userSetAuthPass\", usm_set_password,\n                            NULL, NULL);\n    register_config_handler(type, \"userSetPrivPass\", usm_set_password,\n                            NULL, NULL);\n    register_config_handler(type, \"userSetAuthKey\", usm_set_password, NULL,\n                            NULL);\n    register_config_handler(type, \"userSetPrivKey\", usm_set_password, NULL,\n                            NULL);\n    register_config_handler(type, \"userSetAuthLocalKey\", usm_set_password,\n                            NULL, NULL);\n    register_config_handler(type, \"userSetPrivLocalKey\", usm_set_password,\n                            NULL, NULL);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -21,6 +21,7 @@\n     def->encode_reverse = usm_secmod_rgenerate_out_msg;\n     def->encode_forward = usm_secmod_generate_out_msg;\n     def->decode = usm_secmod_process_in_msg;\n+    def->pdu_clone = usm_clone;\n     def->pdu_free_state_ref = usm_free_usmStateReference;\n     def->session_setup = usm_session_init;\n     def->handle_report = usm_handle_report;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    def->pdu_clone = usm_clone;"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-20892",
        "func_name": "net-snmp/usm_malloc_usmStateReference",
        "description": "net-snmp before 5.8.1.pre1 has a double free in usm_free_usmStateReference in snmplib/snmpusm.c via an SNMPv3 GetBulk request. NOTE: this affects net-snmp packages shipped to end users by multiple Linux distributions, but might not affect an upstream release.",
        "git_url": "https://github.com/net-snmp/net-snmp/commit/5f881d3bf24599b90d67a45cae7a3eb099cd71c9",
        "commit_title": "libsnmp, USM: Introduce a reference count in struct usmStateReference",
        "commit_text": " This patch fixes https://sourceforge.net/p/net-snmp/bugs/2956/.",
        "func_before": "static struct usmStateReference *\nusm_malloc_usmStateReference(void)\n{\n    struct usmStateReference *retval = (struct usmStateReference *)\n        calloc(1, sizeof(struct usmStateReference));\n\n    return retval;\n}",
        "func": "static struct usmStateReference *\nusm_malloc_usmStateReference(void)\n{\n    struct usmStateReference *retval;\n\n    retval = calloc(1, sizeof(struct usmStateReference));\n    if (retval)\n        retval->refcnt = 1;\n\n    return retval;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,8 +1,11 @@\n static struct usmStateReference *\n usm_malloc_usmStateReference(void)\n {\n-    struct usmStateReference *retval = (struct usmStateReference *)\n-        calloc(1, sizeof(struct usmStateReference));\n+    struct usmStateReference *retval;\n+\n+    retval = calloc(1, sizeof(struct usmStateReference));\n+    if (retval)\n+        retval->refcnt = 1;\n \n     return retval;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    struct usmStateReference *retval = (struct usmStateReference *)",
                "        calloc(1, sizeof(struct usmStateReference));"
            ],
            "added_lines": [
                "    struct usmStateReference *retval;",
                "",
                "    retval = calloc(1, sizeof(struct usmStateReference));",
                "    if (retval)",
                "        retval->refcnt = 1;"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-20892",
        "func_name": "net-snmp/usm_free_usmStateReference",
        "description": "net-snmp before 5.8.1.pre1 has a double free in usm_free_usmStateReference in snmplib/snmpusm.c via an SNMPv3 GetBulk request. NOTE: this affects net-snmp packages shipped to end users by multiple Linux distributions, but might not affect an upstream release.",
        "git_url": "https://github.com/net-snmp/net-snmp/commit/5f881d3bf24599b90d67a45cae7a3eb099cd71c9",
        "commit_title": "libsnmp, USM: Introduce a reference count in struct usmStateReference",
        "commit_text": " This patch fixes https://sourceforge.net/p/net-snmp/bugs/2956/.",
        "func_before": "static void\nusm_free_usmStateReference(void *old)\n{\n    struct usmStateReference *old_ref = (struct usmStateReference *) old;\n\n    if (old_ref) {\n\n        if (old_ref->usr_name_length)\n            SNMP_FREE(old_ref->usr_name);\n        if (old_ref->usr_engine_id_length)\n            SNMP_FREE(old_ref->usr_engine_id);\n        if (old_ref->usr_auth_protocol_length)\n            SNMP_FREE(old_ref->usr_auth_protocol);\n        if (old_ref->usr_priv_protocol_length)\n            SNMP_FREE(old_ref->usr_priv_protocol);\n\n        if (old_ref->usr_auth_key_length && old_ref->usr_auth_key) {\n            SNMP_ZERO(old_ref->usr_auth_key, old_ref->usr_auth_key_length);\n            SNMP_FREE(old_ref->usr_auth_key);\n        }\n        if (old_ref->usr_priv_key_length && old_ref->usr_priv_key) {\n            SNMP_ZERO(old_ref->usr_priv_key, old_ref->usr_priv_key_length);\n            SNMP_FREE(old_ref->usr_priv_key);\n        }\n\n        SNMP_ZERO(old_ref, sizeof(*old_ref));\n        SNMP_FREE(old_ref);\n\n    }\n\n}",
        "func": "static void\nusm_free_usmStateReference(void *old)\n{\n    struct usmStateReference *ref = old;\n\n    if (!ref)\n        return;\n\n    if (--ref->refcnt > 0)\n        return;\n\n    SNMP_FREE(ref->usr_name);\n    SNMP_FREE(ref->usr_engine_id);\n    SNMP_FREE(ref->usr_auth_protocol);\n    SNMP_FREE(ref->usr_priv_protocol);\n\n    if (ref->usr_auth_key_length && ref->usr_auth_key) {\n        SNMP_ZERO(ref->usr_auth_key, ref->usr_auth_key_length);\n        SNMP_FREE(ref->usr_auth_key);\n    }\n    if (ref->usr_priv_key_length && ref->usr_priv_key) {\n        SNMP_ZERO(ref->usr_priv_key, ref->usr_priv_key_length);\n        SNMP_FREE(ref->usr_priv_key);\n    }\n\n    SNMP_FREE(ref);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,31 +1,27 @@\n static void\n usm_free_usmStateReference(void *old)\n {\n-    struct usmStateReference *old_ref = (struct usmStateReference *) old;\n+    struct usmStateReference *ref = old;\n \n-    if (old_ref) {\n+    if (!ref)\n+        return;\n \n-        if (old_ref->usr_name_length)\n-            SNMP_FREE(old_ref->usr_name);\n-        if (old_ref->usr_engine_id_length)\n-            SNMP_FREE(old_ref->usr_engine_id);\n-        if (old_ref->usr_auth_protocol_length)\n-            SNMP_FREE(old_ref->usr_auth_protocol);\n-        if (old_ref->usr_priv_protocol_length)\n-            SNMP_FREE(old_ref->usr_priv_protocol);\n+    if (--ref->refcnt > 0)\n+        return;\n \n-        if (old_ref->usr_auth_key_length && old_ref->usr_auth_key) {\n-            SNMP_ZERO(old_ref->usr_auth_key, old_ref->usr_auth_key_length);\n-            SNMP_FREE(old_ref->usr_auth_key);\n-        }\n-        if (old_ref->usr_priv_key_length && old_ref->usr_priv_key) {\n-            SNMP_ZERO(old_ref->usr_priv_key, old_ref->usr_priv_key_length);\n-            SNMP_FREE(old_ref->usr_priv_key);\n-        }\n+    SNMP_FREE(ref->usr_name);\n+    SNMP_FREE(ref->usr_engine_id);\n+    SNMP_FREE(ref->usr_auth_protocol);\n+    SNMP_FREE(ref->usr_priv_protocol);\n \n-        SNMP_ZERO(old_ref, sizeof(*old_ref));\n-        SNMP_FREE(old_ref);\n-\n+    if (ref->usr_auth_key_length && ref->usr_auth_key) {\n+        SNMP_ZERO(ref->usr_auth_key, ref->usr_auth_key_length);\n+        SNMP_FREE(ref->usr_auth_key);\n+    }\n+    if (ref->usr_priv_key_length && ref->usr_priv_key) {\n+        SNMP_ZERO(ref->usr_priv_key, ref->usr_priv_key_length);\n+        SNMP_FREE(ref->usr_priv_key);\n     }\n \n+    SNMP_FREE(ref);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    struct usmStateReference *old_ref = (struct usmStateReference *) old;",
                "    if (old_ref) {",
                "        if (old_ref->usr_name_length)",
                "            SNMP_FREE(old_ref->usr_name);",
                "        if (old_ref->usr_engine_id_length)",
                "            SNMP_FREE(old_ref->usr_engine_id);",
                "        if (old_ref->usr_auth_protocol_length)",
                "            SNMP_FREE(old_ref->usr_auth_protocol);",
                "        if (old_ref->usr_priv_protocol_length)",
                "            SNMP_FREE(old_ref->usr_priv_protocol);",
                "        if (old_ref->usr_auth_key_length && old_ref->usr_auth_key) {",
                "            SNMP_ZERO(old_ref->usr_auth_key, old_ref->usr_auth_key_length);",
                "            SNMP_FREE(old_ref->usr_auth_key);",
                "        }",
                "        if (old_ref->usr_priv_key_length && old_ref->usr_priv_key) {",
                "            SNMP_ZERO(old_ref->usr_priv_key, old_ref->usr_priv_key_length);",
                "            SNMP_FREE(old_ref->usr_priv_key);",
                "        }",
                "        SNMP_ZERO(old_ref, sizeof(*old_ref));",
                "        SNMP_FREE(old_ref);",
                ""
            ],
            "added_lines": [
                "    struct usmStateReference *ref = old;",
                "    if (!ref)",
                "        return;",
                "    if (--ref->refcnt > 0)",
                "        return;",
                "    SNMP_FREE(ref->usr_name);",
                "    SNMP_FREE(ref->usr_engine_id);",
                "    SNMP_FREE(ref->usr_auth_protocol);",
                "    SNMP_FREE(ref->usr_priv_protocol);",
                "    if (ref->usr_auth_key_length && ref->usr_auth_key) {",
                "        SNMP_ZERO(ref->usr_auth_key, ref->usr_auth_key_length);",
                "        SNMP_FREE(ref->usr_auth_key);",
                "    }",
                "    if (ref->usr_priv_key_length && ref->usr_priv_key) {",
                "        SNMP_ZERO(ref->usr_priv_key, ref->usr_priv_key_length);",
                "        SNMP_FREE(ref->usr_priv_key);",
                "    SNMP_FREE(ref);"
            ]
        }
    }
]