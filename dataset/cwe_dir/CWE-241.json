[
    {
        "cve_id": "CVE-2022-29181",
        "func_name": "sparklemotion/nokogiri/parse_memory",
        "description": "Nokogiri is an open source XML and HTML library for Ruby. Nokogiri prior to version 1.13.6 does not type-check all inputs into the XML and HTML4 SAX parsers, allowing specially crafted untrusted inputs to cause illegal memory access errors (segfault) or reads from unrelated memory. Version 1.13.6 contains a patch for this issue. As a workaround, ensure the untrusted input is a `String` by calling `#to_s` or equivalent.",
        "git_url": "https://github.com/sparklemotion/nokogiri/commit/db05ba9a1bd4b90aa6c76742cf6102a7c7297267",
        "commit_title": "fix: {HTML4,XML}::SAX::{Parser,ParserContext} check arg types",
        "commit_text": " Previously, arguments of the wrong type might cause segfault on CRuby.",
        "func_before": "static VALUE\nparse_memory(VALUE klass, VALUE data, VALUE encoding)\n{\n  htmlParserCtxtPtr ctxt;\n\n  if (NIL_P(data)) {\n    rb_raise(rb_eArgError, \"data cannot be nil\");\n  }\n  if (!(int)RSTRING_LEN(data)) {\n    rb_raise(rb_eRuntimeError, \"data cannot be empty\");\n  }\n\n  ctxt = htmlCreateMemoryParserCtxt(StringValuePtr(data),\n                                    (int)RSTRING_LEN(data));\n  if (ctxt->sax) {\n    xmlFree(ctxt->sax);\n    ctxt->sax = NULL;\n  }\n\n  if (RTEST(encoding)) {\n    xmlCharEncodingHandlerPtr enc = xmlFindCharEncodingHandler(StringValueCStr(encoding));\n    if (enc != NULL) {\n      xmlSwitchToEncoding(ctxt, enc);\n      if (ctxt->errNo == XML_ERR_UNSUPPORTED_ENCODING) {\n        rb_raise(rb_eRuntimeError, \"Unsupported encoding %s\",\n                 StringValueCStr(encoding));\n      }\n    }\n  }\n\n  return Data_Wrap_Struct(klass, NULL, deallocate, ctxt);\n}",
        "func": "static VALUE\nparse_memory(VALUE klass, VALUE data, VALUE encoding)\n{\n  htmlParserCtxtPtr ctxt;\n\n  Check_Type(data, T_STRING);\n\n  if (!(int)RSTRING_LEN(data)) {\n    rb_raise(rb_eRuntimeError, \"data cannot be empty\");\n  }\n\n  ctxt = htmlCreateMemoryParserCtxt(StringValuePtr(data),\n                                    (int)RSTRING_LEN(data));\n  if (ctxt->sax) {\n    xmlFree(ctxt->sax);\n    ctxt->sax = NULL;\n  }\n\n  if (RTEST(encoding)) {\n    xmlCharEncodingHandlerPtr enc = xmlFindCharEncodingHandler(StringValueCStr(encoding));\n    if (enc != NULL) {\n      xmlSwitchToEncoding(ctxt, enc);\n      if (ctxt->errNo == XML_ERR_UNSUPPORTED_ENCODING) {\n        rb_raise(rb_eRuntimeError, \"Unsupported encoding %s\",\n                 StringValueCStr(encoding));\n      }\n    }\n  }\n\n  return Data_Wrap_Struct(klass, NULL, deallocate, ctxt);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,9 +3,8 @@\n {\n   htmlParserCtxtPtr ctxt;\n \n-  if (NIL_P(data)) {\n-    rb_raise(rb_eArgError, \"data cannot be nil\");\n-  }\n+  Check_Type(data, T_STRING);\n+\n   if (!(int)RSTRING_LEN(data)) {\n     rb_raise(rb_eRuntimeError, \"data cannot be empty\");\n   }",
        "diff_line_info": {
            "deleted_lines": [
                "  if (NIL_P(data)) {",
                "    rb_raise(rb_eArgError, \"data cannot be nil\");",
                "  }"
            ],
            "added_lines": [
                "  Check_Type(data, T_STRING);",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2022-29181",
        "func_name": "sparklemotion/nokogiri/parse_io",
        "description": "Nokogiri is an open source XML and HTML library for Ruby. Nokogiri prior to version 1.13.6 does not type-check all inputs into the XML and HTML4 SAX parsers, allowing specially crafted untrusted inputs to cause illegal memory access errors (segfault) or reads from unrelated memory. Version 1.13.6 contains a patch for this issue. As a workaround, ensure the untrusted input is a `String` by calling `#to_s` or equivalent.",
        "git_url": "https://github.com/sparklemotion/nokogiri/commit/db05ba9a1bd4b90aa6c76742cf6102a7c7297267",
        "commit_title": "fix: {HTML4,XML}::SAX::{Parser,ParserContext} check arg types",
        "commit_text": " Previously, arguments of the wrong type might cause segfault on CRuby.",
        "func_before": "static VALUE\nparse_io(VALUE klass, VALUE io, VALUE encoding)\n{\n  xmlParserCtxtPtr ctxt;\n  xmlCharEncoding enc = (xmlCharEncoding)NUM2INT(encoding);\n\n  ctxt = xmlCreateIOParserCtxt(NULL, NULL,\n                               (xmlInputReadCallback)noko_io_read,\n                               (xmlInputCloseCallback)noko_io_close,\n                               (void *)io, enc);\n  if (ctxt->sax) {\n    xmlFree(ctxt->sax);\n    ctxt->sax = NULL;\n  }\n\n  return Data_Wrap_Struct(klass, NULL, deallocate, ctxt);\n}",
        "func": "static VALUE\nparse_io(VALUE klass, VALUE io, VALUE encoding)\n{\n  xmlParserCtxtPtr ctxt;\n  xmlCharEncoding enc = (xmlCharEncoding)NUM2INT(encoding);\n\n  if (!rb_respond_to(io, id_read)) {\n    rb_raise(rb_eTypeError, \"argument expected to respond to :read\");\n  }\n\n  ctxt = xmlCreateIOParserCtxt(NULL, NULL,\n                               (xmlInputReadCallback)noko_io_read,\n                               (xmlInputCloseCallback)noko_io_close,\n                               (void *)io, enc);\n  if (ctxt->sax) {\n    xmlFree(ctxt->sax);\n    ctxt->sax = NULL;\n  }\n\n  return Data_Wrap_Struct(klass, NULL, deallocate, ctxt);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,6 +3,10 @@\n {\n   xmlParserCtxtPtr ctxt;\n   xmlCharEncoding enc = (xmlCharEncoding)NUM2INT(encoding);\n+\n+  if (!rb_respond_to(io, id_read)) {\n+    rb_raise(rb_eTypeError, \"argument expected to respond to :read\");\n+  }\n \n   ctxt = xmlCreateIOParserCtxt(NULL, NULL,\n                                (xmlInputReadCallback)noko_io_read,",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "  if (!rb_respond_to(io, id_read)) {",
                "    rb_raise(rb_eTypeError, \"argument expected to respond to :read\");",
                "  }"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-29181",
        "func_name": "sparklemotion/nokogiri/parse_memory",
        "description": "Nokogiri is an open source XML and HTML library for Ruby. Nokogiri prior to version 1.13.6 does not type-check all inputs into the XML and HTML4 SAX parsers, allowing specially crafted untrusted inputs to cause illegal memory access errors (segfault) or reads from unrelated memory. Version 1.13.6 contains a patch for this issue. As a workaround, ensure the untrusted input is a `String` by calling `#to_s` or equivalent.",
        "git_url": "https://github.com/sparklemotion/nokogiri/commit/db05ba9a1bd4b90aa6c76742cf6102a7c7297267",
        "commit_title": "fix: {HTML4,XML}::SAX::{Parser,ParserContext} check arg types",
        "commit_text": " Previously, arguments of the wrong type might cause segfault on CRuby.",
        "func_before": "static VALUE\nparse_memory(VALUE klass, VALUE data)\n{\n  xmlParserCtxtPtr ctxt;\n\n  if (NIL_P(data)) {\n    rb_raise(rb_eArgError, \"data cannot be nil\");\n  }\n  if (!(int)RSTRING_LEN(data)) {\n    rb_raise(rb_eRuntimeError, \"data cannot be empty\");\n  }\n\n  ctxt = xmlCreateMemoryParserCtxt(StringValuePtr(data),\n                                   (int)RSTRING_LEN(data));\n  if (ctxt->sax) {\n    xmlFree(ctxt->sax);\n    ctxt->sax = NULL;\n  }\n\n  return Data_Wrap_Struct(klass, NULL, deallocate, ctxt);\n}",
        "func": "static VALUE\nparse_memory(VALUE klass, VALUE data)\n{\n  xmlParserCtxtPtr ctxt;\n\n  Check_Type(data, T_STRING);\n\n  if (!(int)RSTRING_LEN(data)) {\n    rb_raise(rb_eRuntimeError, \"data cannot be empty\");\n  }\n\n  ctxt = xmlCreateMemoryParserCtxt(StringValuePtr(data),\n                                   (int)RSTRING_LEN(data));\n  if (ctxt->sax) {\n    xmlFree(ctxt->sax);\n    ctxt->sax = NULL;\n  }\n\n  return Data_Wrap_Struct(klass, NULL, deallocate, ctxt);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,9 +3,8 @@\n {\n   xmlParserCtxtPtr ctxt;\n \n-  if (NIL_P(data)) {\n-    rb_raise(rb_eArgError, \"data cannot be nil\");\n-  }\n+  Check_Type(data, T_STRING);\n+\n   if (!(int)RSTRING_LEN(data)) {\n     rb_raise(rb_eRuntimeError, \"data cannot be empty\");\n   }",
        "diff_line_info": {
            "deleted_lines": [
                "  if (NIL_P(data)) {",
                "    rb_raise(rb_eArgError, \"data cannot be nil\");",
                "  }"
            ],
            "added_lines": [
                "  Check_Type(data, T_STRING);",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2022-29181",
        "func_name": "sparklemotion/nokogiri/noko_init_xml_sax_parser_context",
        "description": "Nokogiri is an open source XML and HTML library for Ruby. Nokogiri prior to version 1.13.6 does not type-check all inputs into the XML and HTML4 SAX parsers, allowing specially crafted untrusted inputs to cause illegal memory access errors (segfault) or reads from unrelated memory. Version 1.13.6 contains a patch for this issue. As a workaround, ensure the untrusted input is a `String` by calling `#to_s` or equivalent.",
        "git_url": "https://github.com/sparklemotion/nokogiri/commit/db05ba9a1bd4b90aa6c76742cf6102a7c7297267",
        "commit_title": "fix: {HTML4,XML}::SAX::{Parser,ParserContext} check arg types",
        "commit_text": " Previously, arguments of the wrong type might cause segfault on CRuby.",
        "func_before": "void\nnoko_init_xml_sax_parser_context()\n{\n  cNokogiriXmlSaxParserContext = rb_define_class_under(mNokogiriXmlSax, \"ParserContext\", rb_cObject);\n\n  rb_undef_alloc_func(cNokogiriXmlSaxParserContext);\n\n  rb_define_singleton_method(cNokogiriXmlSaxParserContext, \"io\", parse_io, 2);\n  rb_define_singleton_method(cNokogiriXmlSaxParserContext, \"memory\", parse_memory, 1);\n  rb_define_singleton_method(cNokogiriXmlSaxParserContext, \"file\", parse_file, 1);\n\n  rb_define_method(cNokogiriXmlSaxParserContext, \"parse_with\", parse_with, 1);\n  rb_define_method(cNokogiriXmlSaxParserContext, \"replace_entities=\", set_replace_entities, 1);\n  rb_define_method(cNokogiriXmlSaxParserContext, \"replace_entities\", get_replace_entities, 0);\n  rb_define_method(cNokogiriXmlSaxParserContext, \"recovery=\", set_recovery, 1);\n  rb_define_method(cNokogiriXmlSaxParserContext, \"recovery\", get_recovery, 0);\n  rb_define_method(cNokogiriXmlSaxParserContext, \"line\", line, 0);\n  rb_define_method(cNokogiriXmlSaxParserContext, \"column\", column, 0);\n}",
        "func": "void\nnoko_init_xml_sax_parser_context()\n{\n  cNokogiriXmlSaxParserContext = rb_define_class_under(mNokogiriXmlSax, \"ParserContext\", rb_cObject);\n\n  rb_undef_alloc_func(cNokogiriXmlSaxParserContext);\n\n  rb_define_singleton_method(cNokogiriXmlSaxParserContext, \"io\", parse_io, 2);\n  rb_define_singleton_method(cNokogiriXmlSaxParserContext, \"memory\", parse_memory, 1);\n  rb_define_singleton_method(cNokogiriXmlSaxParserContext, \"file\", parse_file, 1);\n\n  rb_define_method(cNokogiriXmlSaxParserContext, \"parse_with\", parse_with, 1);\n  rb_define_method(cNokogiriXmlSaxParserContext, \"replace_entities=\", set_replace_entities, 1);\n  rb_define_method(cNokogiriXmlSaxParserContext, \"replace_entities\", get_replace_entities, 0);\n  rb_define_method(cNokogiriXmlSaxParserContext, \"recovery=\", set_recovery, 1);\n  rb_define_method(cNokogiriXmlSaxParserContext, \"recovery\", get_recovery, 0);\n  rb_define_method(cNokogiriXmlSaxParserContext, \"line\", line, 0);\n  rb_define_method(cNokogiriXmlSaxParserContext, \"column\", column, 0);\n\n  id_read = rb_intern(\"read\");\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -16,4 +16,6 @@\n   rb_define_method(cNokogiriXmlSaxParserContext, \"recovery\", get_recovery, 0);\n   rb_define_method(cNokogiriXmlSaxParserContext, \"line\", line, 0);\n   rb_define_method(cNokogiriXmlSaxParserContext, \"column\", column, 0);\n+\n+  id_read = rb_intern(\"read\");\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "  id_read = rb_intern(\"read\");"
            ]
        }
    }
]