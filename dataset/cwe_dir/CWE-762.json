[
    {
        "cve_id": "CVE-2023-3648",
        "func_name": "wireshark/decompress_lz4",
        "description": "Kafka dissector crash in Wireshark 4.0.0 to 4.0.6 and 3.6.0 to 3.6.14 allows denial of service via packet injection or crafted capture file",
        "git_url": "https://gitlab.com/wireshark/wireshark/-/commit/b673bc022aa28c2c381cb96cae09357bd27eb0df",
        "commit_title": "kafka: Don't use after free",
        "commit_text": " Neither tvb_new_child_real_data() nor tvb_composite_append() copy the real data buffer that they're given. So we can't free a decompressed buffer after making it a tvb.  We can realloc if the output size is smaller.  Fix #19105 ",
        "func_before": "static gboolean\ndecompress_lz4(tvbuff_t *tvb, packet_info *pinfo, int offset, guint32 length, tvbuff_t **decompressed_tvb, int *decompressed_offset)\n{\n    LZ4F_decompressionContext_t lz4_ctxt = NULL;\n    LZ4F_frameInfo_t lz4_info;\n    LZ4F_errorCode_t rc = 0;\n    size_t src_offset = 0, src_size = 0, dst_size = 0;\n    guchar *decompressed_buffer = NULL;\n    tvbuff_t *composite_tvb = NULL;\n\n    gboolean ret = FALSE;\n\n    /* Prepare compressed data buffer */\n    guint8 *data = (guint8*)tvb_memdup(pinfo->pool, tvb, offset, length);\n    /* Override header checksum to workaround buggy Kafka implementations */\n    if (length > 7) {\n        guint32 hdr_end = 6;\n        if (data[4] & 0x08) {\n            hdr_end += 8;\n        }\n        if (hdr_end < length) {\n            data[hdr_end] = (XXH32(&data[4], hdr_end - 4, 0) >> 8) & 0xff;\n        }\n    }\n\n    /* Allocate output buffer */\n    rc = LZ4F_createDecompressionContext(&lz4_ctxt, LZ4F_VERSION);\n    if (LZ4F_isError(rc)) {\n        goto end;\n    }\n\n    src_offset = length;\n    rc = LZ4F_getFrameInfo(lz4_ctxt, &lz4_info, data, &src_offset);\n    if (LZ4F_isError(rc)) {\n        goto end;\n    }\n\n    switch (lz4_info.blockSizeID) {\n        case LZ4F_max64KB:\n            dst_size = 1 << 16;\n            break;\n        case LZ4F_max256KB:\n            dst_size = 1 << 18;\n            break;\n        case LZ4F_max1MB:\n            dst_size = 1 << 20;\n            break;\n        case LZ4F_max4MB:\n            dst_size = 1 << 22;\n            break;\n        default:\n            goto end;\n    }\n\n    if (lz4_info.contentSize && lz4_info.contentSize < dst_size) {\n        dst_size = (size_t)lz4_info.contentSize;\n    }\n\n    decompressed_buffer = wmem_alloc(pinfo->pool, dst_size);\n    size_t out_size;\n    int count = 0;\n\n    do {\n        src_size = length - src_offset; // set the number of available octets\n        if (src_size == 0) {\n            goto end;\n        }\n\n        out_size = dst_size;\n        rc = LZ4F_decompress(lz4_ctxt, decompressed_buffer, &out_size,\n                              &data[src_offset], &src_size, NULL);\n        if (LZ4F_isError(rc)) {\n            goto end;\n        }\n        if (out_size == 0) {\n            goto end;\n        }\n        if (!composite_tvb) {\n            composite_tvb = tvb_new_composite();\n        }\n        tvb_composite_append(composite_tvb,\n                             tvb_new_child_real_data(tvb, (guint8*)decompressed_buffer, (guint)out_size, (gint)out_size));\n        src_offset += src_size; // bump up the offset for the next iteration\n        DISSECTOR_ASSERT_HINT(count < MAX_LOOP_ITERATIONS, \"MAX_LOOP_ITERATIONS exceeded\");\n    } while (rc > 0 && count++ < MAX_LOOP_ITERATIONS);\n\n    ret = TRUE;\nend:\n    if (composite_tvb) {\n        tvb_composite_finalize(composite_tvb);\n    }\n    LZ4F_freeDecompressionContext(lz4_ctxt);\n    if (ret == 1) {\n        *decompressed_tvb = composite_tvb;\n        *decompressed_offset = 0;\n    }\n    else {\n        col_append_str(pinfo->cinfo, COL_INFO, \" [lz4 decompression failed]\");\n    }\n    return ret;\n}",
        "func": "static gboolean\ndecompress_lz4(tvbuff_t *tvb, packet_info *pinfo, int offset, guint32 length, tvbuff_t **decompressed_tvb, int *decompressed_offset)\n{\n    LZ4F_decompressionContext_t lz4_ctxt = NULL;\n    LZ4F_frameInfo_t lz4_info;\n    LZ4F_errorCode_t rc = 0;\n    size_t src_offset = 0, src_size = 0, dst_size = 0;\n    guchar *decompressed_buffer = NULL;\n    tvbuff_t *composite_tvb = NULL;\n\n    gboolean ret = FALSE;\n\n    /* Prepare compressed data buffer */\n    guint8 *data = (guint8*)tvb_memdup(pinfo->pool, tvb, offset, length);\n    /* Override header checksum to workaround buggy Kafka implementations */\n    if (length > 7) {\n        guint32 hdr_end = 6;\n        if (data[4] & 0x08) {\n            hdr_end += 8;\n        }\n        if (hdr_end < length) {\n            data[hdr_end] = (XXH32(&data[4], hdr_end - 4, 0) >> 8) & 0xff;\n        }\n    }\n\n    /* Allocate output buffer */\n    rc = LZ4F_createDecompressionContext(&lz4_ctxt, LZ4F_VERSION);\n    if (LZ4F_isError(rc)) {\n        goto end;\n    }\n\n    src_offset = length;\n    rc = LZ4F_getFrameInfo(lz4_ctxt, &lz4_info, data, &src_offset);\n    if (LZ4F_isError(rc)) {\n        goto end;\n    }\n\n    switch (lz4_info.blockSizeID) {\n        case LZ4F_max64KB:\n            dst_size = 1 << 16;\n            break;\n        case LZ4F_max256KB:\n            dst_size = 1 << 18;\n            break;\n        case LZ4F_max1MB:\n            dst_size = 1 << 20;\n            break;\n        case LZ4F_max4MB:\n            dst_size = 1 << 22;\n            break;\n        default:\n            goto end;\n    }\n\n    if (lz4_info.contentSize && lz4_info.contentSize < dst_size) {\n        dst_size = (size_t)lz4_info.contentSize;\n    }\n\n    size_t out_size;\n    int count = 0;\n\n    do {\n        src_size = length - src_offset; // set the number of available octets\n        if (src_size == 0) {\n            goto end;\n        }\n\n        decompressed_buffer = wmem_alloc(pinfo->pool, dst_size);\n        out_size = dst_size;\n        rc = LZ4F_decompress(lz4_ctxt, decompressed_buffer, &out_size,\n                              &data[src_offset], &src_size, NULL);\n        if (LZ4F_isError(rc)) {\n            goto end;\n        }\n        if (out_size != dst_size) {\n            decompressed_buffer = (guint8 *)wmem_realloc(pinfo->pool, decompressed_buffer, out_size);\n        }\n        if (out_size == 0) {\n            goto end;\n        }\n        if (!composite_tvb) {\n            composite_tvb = tvb_new_composite();\n        }\n        tvb_composite_append(composite_tvb,\n                             tvb_new_child_real_data(tvb, (guint8*)decompressed_buffer, (guint)out_size, (gint)out_size));\n        src_offset += src_size; // bump up the offset for the next iteration\n        DISSECTOR_ASSERT_HINT(count < MAX_LOOP_ITERATIONS, \"MAX_LOOP_ITERATIONS exceeded\");\n    } while (rc > 0 && count++ < MAX_LOOP_ITERATIONS);\n\n    ret = TRUE;\nend:\n    if (composite_tvb) {\n        tvb_composite_finalize(composite_tvb);\n    }\n    LZ4F_freeDecompressionContext(lz4_ctxt);\n    if (ret == 1) {\n        *decompressed_tvb = composite_tvb;\n        *decompressed_offset = 0;\n    }\n    else {\n        col_append_str(pinfo->cinfo, COL_INFO, \" [lz4 decompression failed]\");\n    }\n    return ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -56,7 +56,6 @@\n         dst_size = (size_t)lz4_info.contentSize;\n     }\n \n-    decompressed_buffer = wmem_alloc(pinfo->pool, dst_size);\n     size_t out_size;\n     int count = 0;\n \n@@ -66,11 +65,15 @@\n             goto end;\n         }\n \n+        decompressed_buffer = wmem_alloc(pinfo->pool, dst_size);\n         out_size = dst_size;\n         rc = LZ4F_decompress(lz4_ctxt, decompressed_buffer, &out_size,\n                               &data[src_offset], &src_size, NULL);\n         if (LZ4F_isError(rc)) {\n             goto end;\n+        }\n+        if (out_size != dst_size) {\n+            decompressed_buffer = (guint8 *)wmem_realloc(pinfo->pool, decompressed_buffer, out_size);\n         }\n         if (out_size == 0) {\n             goto end;",
        "diff_line_info": {
            "deleted_lines": [
                "    decompressed_buffer = wmem_alloc(pinfo->pool, dst_size);"
            ],
            "added_lines": [
                "        decompressed_buffer = wmem_alloc(pinfo->pool, dst_size);",
                "        }",
                "        if (out_size != dst_size) {",
                "            decompressed_buffer = (guint8 *)wmem_realloc(pinfo->pool, decompressed_buffer, out_size);"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-3648",
        "func_name": "wireshark/decompress_snappy",
        "description": "Kafka dissector crash in Wireshark 4.0.0 to 4.0.6 and 3.6.0 to 3.6.14 allows denial of service via packet injection or crafted capture file",
        "git_url": "https://gitlab.com/wireshark/wireshark/-/commit/b673bc022aa28c2c381cb96cae09357bd27eb0df",
        "commit_title": "kafka: Don't use after free",
        "commit_text": " Neither tvb_new_child_real_data() nor tvb_composite_append() copy the real data buffer that they're given. So we can't free a decompressed buffer after making it a tvb.  We can realloc if the output size is smaller.  Fix #19105 ",
        "func_before": "static gboolean\ndecompress_snappy(tvbuff_t *tvb, packet_info *pinfo, int offset, guint32 length, tvbuff_t **decompressed_tvb, int *decompressed_offset)\n{\n    guint8 *data = (guint8*)tvb_memdup(pinfo->pool, tvb, offset, length);\n    size_t uncompressed_size;\n    snappy_status rc = SNAPPY_OK;\n    tvbuff_t *composite_tvb = NULL;\n    gboolean ret = FALSE;\n\n    if (tvb_memeql(tvb, offset, kafka_xerial_header, sizeof(kafka_xerial_header)) == 0) {\n\n        /* xerial framing format */\n        guint32 chunk_size, pos = 16;\n        int count = 0;\n\n        while (pos < length && count < MAX_LOOP_ITERATIONS) {\n            if (pos > length-4) {\n                // XXX - this is presumably an error, as the chunk size\n                // doesn't fully fit in the data, so an error should be\n                // reported.\n                goto end;\n            }\n            chunk_size = tvb_get_ntohl(tvb, offset+pos);\n            pos += 4;\n            if (chunk_size > length) {\n                // XXX - this is presumably an error, as the chunk to be\n                // decompressed doesn't fully fit in the data, so an error\n                // should be reported.\n                goto end;\n            }\n            if (pos > length-chunk_size) {\n                // XXX - this is presumably an error, as the chunk to be\n                // decompressed doesn't fully fit in the data, so an error\n                // should be reported.\n                goto end;\n            }\n            rc = snappy_uncompressed_length(&data[pos], chunk_size, &uncompressed_size);\n            if (rc != SNAPPY_OK) {\n                goto end;\n            }\n            guint8 *decompressed_buffer = (guint8*)wmem_alloc(pinfo->pool, uncompressed_size);\n            rc = snappy_uncompress(&data[pos], chunk_size, decompressed_buffer, &uncompressed_size);\n            if (rc != SNAPPY_OK) {\n                goto end;\n            }\n\n            if (!composite_tvb) {\n                composite_tvb = tvb_new_composite();\n            }\n            tvb_composite_append(composite_tvb,\n                      tvb_new_child_real_data(tvb, decompressed_buffer, (guint)uncompressed_size, (gint)uncompressed_size));\n            pos += chunk_size;\n            wmem_free(pinfo->pool, decompressed_buffer);\n            count++;\n            DISSECTOR_ASSERT_HINT(count < MAX_LOOP_ITERATIONS, \"MAX_LOOP_ITERATIONS exceeded\");\n        }\n\n    } else {\n\n        /* unframed format */\n        rc = snappy_uncompressed_length(data, length, &uncompressed_size);\n        if (rc != SNAPPY_OK) {\n            goto end;\n        }\n\n        guint8 *decompressed_buffer = (guint8*)wmem_alloc(pinfo->pool, uncompressed_size);\n\n        rc = snappy_uncompress(data, length, decompressed_buffer, &uncompressed_size);\n        if (rc != SNAPPY_OK) {\n            goto end;\n        }\n\n        *decompressed_tvb = tvb_new_child_real_data(tvb, decompressed_buffer, (guint)uncompressed_size, (gint)uncompressed_size);\n        *decompressed_offset = 0;\n\n    }\n    ret = TRUE;\nend:\n    if (composite_tvb) {\n        tvb_composite_finalize(composite_tvb);\n        if (ret == 1) {\n            *decompressed_tvb = composite_tvb;\n            *decompressed_offset = 0;\n        }\n    }\n    if (ret == FALSE) {\n        col_append_str(pinfo->cinfo, COL_INFO, \" [snappy decompression failed]\");\n    }\n    return ret;\n}",
        "func": "static gboolean\ndecompress_snappy(tvbuff_t *tvb, packet_info *pinfo, int offset, guint32 length, tvbuff_t **decompressed_tvb, int *decompressed_offset)\n{\n    guint8 *data = (guint8*)tvb_memdup(pinfo->pool, tvb, offset, length);\n    size_t uncompressed_size, out_size;\n    snappy_status rc = SNAPPY_OK;\n    tvbuff_t *composite_tvb = NULL;\n    gboolean ret = FALSE;\n\n    if (tvb_memeql(tvb, offset, kafka_xerial_header, sizeof(kafka_xerial_header)) == 0) {\n\n        /* xerial framing format */\n        guint32 chunk_size, pos = 16;\n        int count = 0;\n\n        while (pos < length && count < MAX_LOOP_ITERATIONS) {\n            if (pos > length-4) {\n                // XXX - this is presumably an error, as the chunk size\n                // doesn't fully fit in the data, so an error should be\n                // reported.\n                goto end;\n            }\n            chunk_size = tvb_get_ntohl(tvb, offset+pos);\n            pos += 4;\n            if (chunk_size > length) {\n                // XXX - this is presumably an error, as the chunk to be\n                // decompressed doesn't fully fit in the data, so an error\n                // should be reported.\n                goto end;\n            }\n            if (pos > length-chunk_size) {\n                // XXX - this is presumably an error, as the chunk to be\n                // decompressed doesn't fully fit in the data, so an error\n                // should be reported.\n                goto end;\n            }\n            rc = snappy_uncompressed_length(&data[pos], chunk_size, &uncompressed_size);\n            if (rc != SNAPPY_OK) {\n                goto end;\n            }\n            guint8 *decompressed_buffer = (guint8*)wmem_alloc(pinfo->pool, uncompressed_size);\n            out_size = uncompressed_size;\n            rc = snappy_uncompress(&data[pos], chunk_size, decompressed_buffer, &out_size);\n            if (rc != SNAPPY_OK) {\n                goto end;\n            }\n            if (out_size != uncompressed_size) {\n                decompressed_buffer = (guint8 *)wmem_realloc(pinfo->pool, decompressed_buffer, out_size);\n            }\n\n            if (!composite_tvb) {\n                composite_tvb = tvb_new_composite();\n            }\n            tvb_composite_append(composite_tvb,\n                      tvb_new_child_real_data(tvb, decompressed_buffer, (guint)out_size, (gint)out_size));\n            pos += chunk_size;\n            count++;\n            DISSECTOR_ASSERT_HINT(count < MAX_LOOP_ITERATIONS, \"MAX_LOOP_ITERATIONS exceeded\");\n        }\n\n    } else {\n\n        /* unframed format */\n        rc = snappy_uncompressed_length(data, length, &uncompressed_size);\n        if (rc != SNAPPY_OK) {\n            goto end;\n        }\n\n        guint8 *decompressed_buffer = (guint8*)wmem_alloc(pinfo->pool, uncompressed_size);\n\n        out_size = uncompressed_size;\n        rc = snappy_uncompress(data, length, decompressed_buffer, &out_size);\n        if (rc != SNAPPY_OK) {\n            goto end;\n        }\n        if (out_size != uncompressed_size) {\n            decompressed_buffer = (guint8 *)wmem_realloc(pinfo->pool, decompressed_buffer, out_size);\n        }\n\n        *decompressed_tvb = tvb_new_child_real_data(tvb, decompressed_buffer, (guint)out_size, (gint)out_size);\n        *decompressed_offset = 0;\n\n    }\n    ret = TRUE;\nend:\n    if (composite_tvb) {\n        tvb_composite_finalize(composite_tvb);\n        if (ret == 1) {\n            *decompressed_tvb = composite_tvb;\n            *decompressed_offset = 0;\n        }\n    }\n    if (ret == FALSE) {\n        col_append_str(pinfo->cinfo, COL_INFO, \" [snappy decompression failed]\");\n    }\n    return ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,7 +2,7 @@\n decompress_snappy(tvbuff_t *tvb, packet_info *pinfo, int offset, guint32 length, tvbuff_t **decompressed_tvb, int *decompressed_offset)\n {\n     guint8 *data = (guint8*)tvb_memdup(pinfo->pool, tvb, offset, length);\n-    size_t uncompressed_size;\n+    size_t uncompressed_size, out_size;\n     snappy_status rc = SNAPPY_OK;\n     tvbuff_t *composite_tvb = NULL;\n     gboolean ret = FALSE;\n@@ -39,18 +39,21 @@\n                 goto end;\n             }\n             guint8 *decompressed_buffer = (guint8*)wmem_alloc(pinfo->pool, uncompressed_size);\n-            rc = snappy_uncompress(&data[pos], chunk_size, decompressed_buffer, &uncompressed_size);\n+            out_size = uncompressed_size;\n+            rc = snappy_uncompress(&data[pos], chunk_size, decompressed_buffer, &out_size);\n             if (rc != SNAPPY_OK) {\n                 goto end;\n+            }\n+            if (out_size != uncompressed_size) {\n+                decompressed_buffer = (guint8 *)wmem_realloc(pinfo->pool, decompressed_buffer, out_size);\n             }\n \n             if (!composite_tvb) {\n                 composite_tvb = tvb_new_composite();\n             }\n             tvb_composite_append(composite_tvb,\n-                      tvb_new_child_real_data(tvb, decompressed_buffer, (guint)uncompressed_size, (gint)uncompressed_size));\n+                      tvb_new_child_real_data(tvb, decompressed_buffer, (guint)out_size, (gint)out_size));\n             pos += chunk_size;\n-            wmem_free(pinfo->pool, decompressed_buffer);\n             count++;\n             DISSECTOR_ASSERT_HINT(count < MAX_LOOP_ITERATIONS, \"MAX_LOOP_ITERATIONS exceeded\");\n         }\n@@ -65,12 +68,16 @@\n \n         guint8 *decompressed_buffer = (guint8*)wmem_alloc(pinfo->pool, uncompressed_size);\n \n-        rc = snappy_uncompress(data, length, decompressed_buffer, &uncompressed_size);\n+        out_size = uncompressed_size;\n+        rc = snappy_uncompress(data, length, decompressed_buffer, &out_size);\n         if (rc != SNAPPY_OK) {\n             goto end;\n         }\n+        if (out_size != uncompressed_size) {\n+            decompressed_buffer = (guint8 *)wmem_realloc(pinfo->pool, decompressed_buffer, out_size);\n+        }\n \n-        *decompressed_tvb = tvb_new_child_real_data(tvb, decompressed_buffer, (guint)uncompressed_size, (gint)uncompressed_size);\n+        *decompressed_tvb = tvb_new_child_real_data(tvb, decompressed_buffer, (guint)out_size, (gint)out_size);\n         *decompressed_offset = 0;\n \n     }",
        "diff_line_info": {
            "deleted_lines": [
                "    size_t uncompressed_size;",
                "            rc = snappy_uncompress(&data[pos], chunk_size, decompressed_buffer, &uncompressed_size);",
                "                      tvb_new_child_real_data(tvb, decompressed_buffer, (guint)uncompressed_size, (gint)uncompressed_size));",
                "            wmem_free(pinfo->pool, decompressed_buffer);",
                "        rc = snappy_uncompress(data, length, decompressed_buffer, &uncompressed_size);",
                "        *decompressed_tvb = tvb_new_child_real_data(tvb, decompressed_buffer, (guint)uncompressed_size, (gint)uncompressed_size);"
            ],
            "added_lines": [
                "    size_t uncompressed_size, out_size;",
                "            out_size = uncompressed_size;",
                "            rc = snappy_uncompress(&data[pos], chunk_size, decompressed_buffer, &out_size);",
                "            }",
                "            if (out_size != uncompressed_size) {",
                "                decompressed_buffer = (guint8 *)wmem_realloc(pinfo->pool, decompressed_buffer, out_size);",
                "                      tvb_new_child_real_data(tvb, decompressed_buffer, (guint)out_size, (gint)out_size));",
                "        out_size = uncompressed_size;",
                "        rc = snappy_uncompress(data, length, decompressed_buffer, &out_size);",
                "        if (out_size != uncompressed_size) {",
                "            decompressed_buffer = (guint8 *)wmem_realloc(pinfo->pool, decompressed_buffer, out_size);",
                "        }",
                "        *decompressed_tvb = tvb_new_child_real_data(tvb, decompressed_buffer, (guint)out_size, (gint)out_size);"
            ]
        }
    }
]