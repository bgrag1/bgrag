[
    {
        "cve_id": "CVE-2021-21413",
        "func_name": "laverdet/isolated-vm/NativeModule::NativeModule",
        "description": "isolated-vm is a library for nodejs which gives you access to v8's Isolate interface. Versions of isolated-vm before v4.0.0 have API pitfalls which may make it easy for implementers to expose supposed secure isolates to the permissions of the main nodejs isolate. Reference objects allow access to the underlying reference's full prototype chain. In an environment where the implementer has exposed a Reference instance to an attacker they would be able to use it to acquire a Reference to the nodejs context's Function object. Similar application-specific attacks could be possible by modifying the local prototype of other API objects. Access to NativeModule objects could allow an attacker to load and run native code from anywhere on the filesystem. If combined with, for example, a file upload API this would allow for arbitrary code execution. This is addressed in v4.0.0 through a series of related changes.",
        "git_url": "https://github.com/laverdet/isolated-vm/commit/27151bfecc260e96714443613880e3b2e6596704",
        "commit_title": "Disallow NativeModule creation unless main isolate",
        "commit_text": "",
        "func_before": "NativeModule::NativeModule(const std::string& filename) : init(nullptr) {\n\tif (uv_dlopen(filename.c_str(), &lib) != 0) {\n\t\tthrow RuntimeGenericError(\"Failed to load module\");\n\t}\n\tif (uv_dlsym(&lib, \"InitForContext\", reinterpret_cast<void**>(&init)) != 0 || init == nullptr) {\n\t\tuv_dlclose(&lib);\n\t\tthrow RuntimeGenericError(\"Module is not isolated-vm compatible\");\n\t}\n}",
        "func": "NativeModule::NativeModule(const std::string& filename) : init(nullptr) {\n\tif (!IsolateEnvironment::GetCurrent()->IsDefault()) {\n\t\tthrow RuntimeGenericError(\"NativeModule may only be instantiated from default nodejs isolate\");\n\t}\n\tif (uv_dlopen(filename.c_str(), &lib) != 0) {\n\t\tthrow RuntimeGenericError(\"Failed to load module\");\n\t}\n\tif (uv_dlsym(&lib, \"InitForContext\", reinterpret_cast<void**>(&init)) != 0 || init == nullptr) {\n\t\tuv_dlclose(&lib);\n\t\tthrow RuntimeGenericError(\"Module is not isolated-vm compatible\");\n\t}\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,7 @@\n NativeModule::NativeModule(const std::string& filename) : init(nullptr) {\n+\tif (!IsolateEnvironment::GetCurrent()->IsDefault()) {\n+\t\tthrow RuntimeGenericError(\"NativeModule may only be instantiated from default nodejs isolate\");\n+\t}\n \tif (uv_dlopen(filename.c_str(), &lib) != 0) {\n \t\tthrow RuntimeGenericError(\"Failed to load module\");\n \t}",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tif (!IsolateEnvironment::GetCurrent()->IsDefault()) {",
                "\t\tthrow RuntimeGenericError(\"NativeModule may only be instantiated from default nodejs isolate\");",
                "\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-21413",
        "func_name": "laverdet/isolated-vm/Phase3",
        "description": "isolated-vm is a library for nodejs which gives you access to v8's Isolate interface. Versions of isolated-vm before v4.0.0 have API pitfalls which may make it easy for implementers to expose supposed secure isolates to the permissions of the main nodejs isolate. Reference objects allow access to the underlying reference's full prototype chain. In an environment where the implementer has exposed a Reference instance to an attacker they would be able to use it to acquire a Reference to the nodejs context's Function object. Similar application-specific attacks could be possible by modifying the local prototype of other API objects. Access to NativeModule objects could allow an attacker to load and run native code from anywhere on the filesystem. If combined with, for example, a file upload API this would allow for arbitrary code execution. This is addressed in v4.0.0 through a series of related changes.",
        "git_url": "https://github.com/laverdet/isolated-vm/commit/2646e6c1558bac66285daeab54c7d490ed332b15",
        "commit_title": "Don't invoke accessors or proxies via Reference functions",
        "commit_text": "",
        "func_before": "auto Phase3() -> Local<Value> final {\n\t\t\treturn Boolean::New(Isolate::GetCurrent(), did_set);\n\t\t}",
        "func": "auto Phase3() -> Local<Value> final {\n\t\t\treturn Undefined(Isolate::GetCurrent());\n\t\t}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,3 +1,3 @@\n auto Phase3() -> Local<Value> final {\n-\t\t\treturn Boolean::New(Isolate::GetCurrent(), did_set);\n+\t\t\treturn Undefined(Isolate::GetCurrent());\n \t\t}",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\treturn Boolean::New(Isolate::GetCurrent(), did_set);"
            ],
            "added_lines": [
                "\t\t\treturn Undefined(Isolate::GetCurrent());"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-21413",
        "func_name": "laverdet/isolated-vm/ReferenceHandle::Get",
        "description": "isolated-vm is a library for nodejs which gives you access to v8's Isolate interface. Versions of isolated-vm before v4.0.0 have API pitfalls which may make it easy for implementers to expose supposed secure isolates to the permissions of the main nodejs isolate. Reference objects allow access to the underlying reference's full prototype chain. In an environment where the implementer has exposed a Reference instance to an attacker they would be able to use it to acquire a Reference to the nodejs context's Function object. Similar application-specific attacks could be possible by modifying the local prototype of other API objects. Access to NativeModule objects could allow an attacker to load and run native code from anywhere on the filesystem. If combined with, for example, a file upload API this would allow for arbitrary code execution. This is addressed in v4.0.0 through a series of related changes.",
        "git_url": "https://github.com/laverdet/isolated-vm/commit/2646e6c1558bac66285daeab54c7d490ed332b15",
        "commit_title": "Don't invoke accessors or proxies via Reference functions",
        "commit_text": "",
        "func_before": "auto ReferenceHandle::Get(Local<Value> key_handle, MaybeLocal<Object> maybe_options) -> Local<Value> {\n\treturn ThreePhaseTask::Run<async, GetRunner>(*isolate, *this, key_handle, maybe_options, inherit);\n}",
        "func": "auto ReferenceHandle::Get(Local<Value> key_handle, MaybeLocal<Object> maybe_options) -> Local<Value> {\n\treturn ThreePhaseTask::Run<async, GetRunner>(*isolate, *this, key_handle, maybe_options);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,3 +1,3 @@\n auto ReferenceHandle::Get(Local<Value> key_handle, MaybeLocal<Object> maybe_options) -> Local<Value> {\n-\treturn ThreePhaseTask::Run<async, GetRunner>(*isolate, *this, key_handle, maybe_options, inherit);\n+\treturn ThreePhaseTask::Run<async, GetRunner>(*isolate, *this, key_handle, maybe_options);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\treturn ThreePhaseTask::Run<async, GetRunner>(*isolate, *this, key_handle, maybe_options, inherit);"
            ],
            "added_lines": [
                "\treturn ThreePhaseTask::Run<async, GetRunner>(*isolate, *this, key_handle, maybe_options);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-21413",
        "func_name": "laverdet/isolated-vm/GetRunner",
        "description": "isolated-vm is a library for nodejs which gives you access to v8's Isolate interface. Versions of isolated-vm before v4.0.0 have API pitfalls which may make it easy for implementers to expose supposed secure isolates to the permissions of the main nodejs isolate. Reference objects allow access to the underlying reference's full prototype chain. In an environment where the implementer has exposed a Reference instance to an attacker they would be able to use it to acquire a Reference to the nodejs context's Function object. Similar application-specific attacks could be possible by modifying the local prototype of other API objects. Access to NativeModule objects could allow an attacker to load and run native code from anywhere on the filesystem. If combined with, for example, a file upload API this would allow for arbitrary code execution. This is addressed in v4.0.0 through a series of related changes.",
        "git_url": "https://github.com/laverdet/isolated-vm/commit/2646e6c1558bac66285daeab54c7d490ed332b15",
        "commit_title": "Don't invoke accessors or proxies via Reference functions",
        "commit_text": "",
        "func_before": "GetRunner(\n\t\t\tconst ReferenceHandle& that,\n\t\t\tLocal<Value> key_handle,\n\t\t\tMaybeLocal<Object> maybe_options,\n\t\t\tbool inherit\n\t\t) :\n\t\t\t\tcontext{that.context},\n\t\t\t\treference{that.reference},\n\t\t\t\toptions{maybe_options, inherit ?\n\t\t\t\t\tTransferOptions::Type::DeepReference : TransferOptions::Type::Reference},\n\t\t\t\tinherit{inherit} {\n\t\t\tthat.CheckDisposed();\n\t\t\tkey = ExternalCopy::CopyIfPrimitive(key_handle);\n\t\t\tif (!key) {\n\t\t\t\tthrow RuntimeTypeError(\"Invalid `key`\");\n\t\t\t}\n\t\t}",
        "func": "GetRunner(ReferenceHandle& target, Local<Value> key_handle, MaybeLocal<Object> maybe_options) :\n\t\tAccessorRunner{target, key_handle},\n\t\toptions{maybe_options, target.inherit ?\n\t\t\tTransferOptions::Type::DeepReference : TransferOptions::Type::Reference},\n\t\tinherit{target.inherit} {}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,17 +1,5 @@\n-GetRunner(\n-\t\t\tconst ReferenceHandle& that,\n-\t\t\tLocal<Value> key_handle,\n-\t\t\tMaybeLocal<Object> maybe_options,\n-\t\t\tbool inherit\n-\t\t) :\n-\t\t\t\tcontext{that.context},\n-\t\t\t\treference{that.reference},\n-\t\t\t\toptions{maybe_options, inherit ?\n-\t\t\t\t\tTransferOptions::Type::DeepReference : TransferOptions::Type::Reference},\n-\t\t\t\tinherit{inherit} {\n-\t\t\tthat.CheckDisposed();\n-\t\t\tkey = ExternalCopy::CopyIfPrimitive(key_handle);\n-\t\t\tif (!key) {\n-\t\t\t\tthrow RuntimeTypeError(\"Invalid `key`\");\n-\t\t\t}\n-\t\t}\n+GetRunner(ReferenceHandle& target, Local<Value> key_handle, MaybeLocal<Object> maybe_options) :\n+\t\tAccessorRunner{target, key_handle},\n+\t\toptions{maybe_options, target.inherit ?\n+\t\t\tTransferOptions::Type::DeepReference : TransferOptions::Type::Reference},\n+\t\tinherit{target.inherit} {}",
        "diff_line_info": {
            "deleted_lines": [
                "GetRunner(",
                "\t\t\tconst ReferenceHandle& that,",
                "\t\t\tLocal<Value> key_handle,",
                "\t\t\tMaybeLocal<Object> maybe_options,",
                "\t\t\tbool inherit",
                "\t\t) :",
                "\t\t\t\tcontext{that.context},",
                "\t\t\t\treference{that.reference},",
                "\t\t\t\toptions{maybe_options, inherit ?",
                "\t\t\t\t\tTransferOptions::Type::DeepReference : TransferOptions::Type::Reference},",
                "\t\t\t\tinherit{inherit} {",
                "\t\t\tthat.CheckDisposed();",
                "\t\t\tkey = ExternalCopy::CopyIfPrimitive(key_handle);",
                "\t\t\tif (!key) {",
                "\t\t\t\tthrow RuntimeTypeError(\"Invalid `key`\");",
                "\t\t\t}",
                "\t\t}"
            ],
            "added_lines": [
                "GetRunner(ReferenceHandle& target, Local<Value> key_handle, MaybeLocal<Object> maybe_options) :",
                "\t\tAccessorRunner{target, key_handle},",
                "\t\toptions{maybe_options, target.inherit ?",
                "\t\t\tTransferOptions::Type::DeepReference : TransferOptions::Type::Reference},",
                "\t\tinherit{target.inherit} {}"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-21413",
        "func_name": "laverdet/isolated-vm/SetRunner",
        "description": "isolated-vm is a library for nodejs which gives you access to v8's Isolate interface. Versions of isolated-vm before v4.0.0 have API pitfalls which may make it easy for implementers to expose supposed secure isolates to the permissions of the main nodejs isolate. Reference objects allow access to the underlying reference's full prototype chain. In an environment where the implementer has exposed a Reference instance to an attacker they would be able to use it to acquire a Reference to the nodejs context's Function object. Similar application-specific attacks could be possible by modifying the local prototype of other API objects. Access to NativeModule objects could allow an attacker to load and run native code from anywhere on the filesystem. If combined with, for example, a file upload API this would allow for arbitrary code execution. This is addressed in v4.0.0 through a series of related changes.",
        "git_url": "https://github.com/laverdet/isolated-vm/commit/2646e6c1558bac66285daeab54c7d490ed332b15",
        "commit_title": "Don't invoke accessors or proxies via Reference functions",
        "commit_text": "",
        "func_before": "SetRunner(\n\t\t\tReferenceHandle& that,\n\t\t\tLocal<Value> key_handle,\n\t\t\tLocal<Value> val_handle,\n\t\t\tMaybeLocal<Object> maybe_options\n\t\t) :\n\t\t\t\tkey{ExternalCopy::CopyIfPrimitive(key_handle)},\n\t\t\t\tval{TransferOut(val_handle, TransferOptions{maybe_options})},\n\t\t\t\tcontext{that.context},\n\t\t\t\treference{that.reference} {\n\t\t\tthat.CheckDisposed();\n\t\t\tif (!key) {\n\t\t\t\tthrow RuntimeTypeError(\"Invalid `key`\");\n\t\t\t}\n\t\t}",
        "func": "SetRunner(\n\t\t\tReferenceHandle& that,\n\t\t\tLocal<Value> key_handle,\n\t\t\tLocal<Value> val_handle,\n\t\t\tMaybeLocal<Object> maybe_options\n\t\t) :\n\t\tAccessorRunner{that, key_handle},\n\t\tval{TransferOut(val_handle, TransferOptions{maybe_options})} {}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,12 +4,5 @@\n \t\t\tLocal<Value> val_handle,\n \t\t\tMaybeLocal<Object> maybe_options\n \t\t) :\n-\t\t\t\tkey{ExternalCopy::CopyIfPrimitive(key_handle)},\n-\t\t\t\tval{TransferOut(val_handle, TransferOptions{maybe_options})},\n-\t\t\t\tcontext{that.context},\n-\t\t\t\treference{that.reference} {\n-\t\t\tthat.CheckDisposed();\n-\t\t\tif (!key) {\n-\t\t\t\tthrow RuntimeTypeError(\"Invalid `key`\");\n-\t\t\t}\n-\t\t}\n+\t\tAccessorRunner{that, key_handle},\n+\t\tval{TransferOut(val_handle, TransferOptions{maybe_options})} {}",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\t\tkey{ExternalCopy::CopyIfPrimitive(key_handle)},",
                "\t\t\t\tval{TransferOut(val_handle, TransferOptions{maybe_options})},",
                "\t\t\t\tcontext{that.context},",
                "\t\t\t\treference{that.reference} {",
                "\t\t\tthat.CheckDisposed();",
                "\t\t\tif (!key) {",
                "\t\t\t\tthrow RuntimeTypeError(\"Invalid `key`\");",
                "\t\t\t}",
                "\t\t}"
            ],
            "added_lines": [
                "\t\tAccessorRunner{that, key_handle},",
                "\t\tval{TransferOut(val_handle, TransferOptions{maybe_options})} {}"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-21413",
        "func_name": "laverdet/isolated-vm/ReferenceHandle::New",
        "description": "isolated-vm is a library for nodejs which gives you access to v8's Isolate interface. Versions of isolated-vm before v4.0.0 have API pitfalls which may make it easy for implementers to expose supposed secure isolates to the permissions of the main nodejs isolate. Reference objects allow access to the underlying reference's full prototype chain. In an environment where the implementer has exposed a Reference instance to an attacker they would be able to use it to acquire a Reference to the nodejs context's Function object. Similar application-specific attacks could be possible by modifying the local prototype of other API objects. Access to NativeModule objects could allow an attacker to load and run native code from anywhere on the filesystem. If combined with, for example, a file upload API this would allow for arbitrary code execution. This is addressed in v4.0.0 through a series of related changes.",
        "git_url": "https://github.com/laverdet/isolated-vm/commit/2646e6c1558bac66285daeab54c7d490ed332b15",
        "commit_title": "Don't invoke accessors or proxies via Reference functions",
        "commit_text": "",
        "func_before": "auto ReferenceHandle::New(Local<Value> value, MaybeLocal<Object> options) -> unique_ptr<ReferenceHandle> {\n\tauto inherit = ReadOption<bool>(options, StringTable::Get().inheritUnsafe, false);\n\treturn std::make_unique<ReferenceHandle>(value, inherit);\n}",
        "func": "auto ReferenceHandle::New(Local<Value> value, MaybeLocal<Object> options) -> unique_ptr<ReferenceHandle> {\n\tauto inherit = ReadOption<bool>(options, StringTable::Get().unsafeInherit, false);\n\treturn std::make_unique<ReferenceHandle>(value, inherit);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,4 @@\n auto ReferenceHandle::New(Local<Value> value, MaybeLocal<Object> options) -> unique_ptr<ReferenceHandle> {\n-\tauto inherit = ReadOption<bool>(options, StringTable::Get().inheritUnsafe, false);\n+\tauto inherit = ReadOption<bool>(options, StringTable::Get().unsafeInherit, false);\n \treturn std::make_unique<ReferenceHandle>(value, inherit);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tauto inherit = ReadOption<bool>(options, StringTable::Get().inheritUnsafe, false);"
            ],
            "added_lines": [
                "\tauto inherit = ReadOption<bool>(options, StringTable::Get().unsafeInherit, false);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-21413",
        "func_name": "laverdet/isolated-vm/Phase2",
        "description": "isolated-vm is a library for nodejs which gives you access to v8's Isolate interface. Versions of isolated-vm before v4.0.0 have API pitfalls which may make it easy for implementers to expose supposed secure isolates to the permissions of the main nodejs isolate. Reference objects allow access to the underlying reference's full prototype chain. In an environment where the implementer has exposed a Reference instance to an attacker they would be able to use it to acquire a Reference to the nodejs context's Function object. Similar application-specific attacks could be possible by modifying the local prototype of other API objects. Access to NativeModule objects could allow an attacker to load and run native code from anywhere on the filesystem. If combined with, for example, a file upload API this would allow for arbitrary code execution. This is addressed in v4.0.0 through a series of related changes.",
        "git_url": "https://github.com/laverdet/isolated-vm/commit/2646e6c1558bac66285daeab54c7d490ed332b15",
        "commit_title": "Don't invoke accessors or proxies via Reference functions",
        "commit_text": "",
        "func_before": "void Phase2() final {\n\t\t\tLocal<Context> context_handle = Deref(context);\n\t\t\tContext::Scope context_scope{context_handle};\n\t\t\tLocal<Value> key_inner = key->CopyInto();\n\t\t\tLocal<Object> object = Local<Object>::Cast(Deref(reference));\n\t\t\t// Delete key before transferring in, potentially freeing up some v8 heap\n\t\t\tUnmaybe(object->Delete(context_handle, key_inner));\n\t\t\tLocal<Value> val_inner = val->TransferIn();\n\t\t\tdid_set = Unmaybe(object->Set(context_handle, key_inner, val_inner));\n\t\t}",
        "func": "void Phase2() final {\n\t\t\tauto context = Deref(this->context);\n\t\t\tContext::Scope context_scope{context};\n\t\t\tauto name = GetKey(context);\n\t\t\tauto object = GetTargetAndAlsoCheckForProxy();\n\t\t\t// Delete key before transferring in, potentially freeing up some v8 heap\n\t\t\tUnmaybe(object->Delete(context, name));\n\t\t\tauto val_inner = val->TransferIn();\n\t\t\tif (!Unmaybe(object->CreateDataProperty(context, GetKey(context), val_inner))) {\n\t\t\t\tthrow RuntimeTypeError(\"Set failed\");\n\t\t\t}\n\t\t}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,10 +1,12 @@\n void Phase2() final {\n-\t\t\tLocal<Context> context_handle = Deref(context);\n-\t\t\tContext::Scope context_scope{context_handle};\n-\t\t\tLocal<Value> key_inner = key->CopyInto();\n-\t\t\tLocal<Object> object = Local<Object>::Cast(Deref(reference));\n+\t\t\tauto context = Deref(this->context);\n+\t\t\tContext::Scope context_scope{context};\n+\t\t\tauto name = GetKey(context);\n+\t\t\tauto object = GetTargetAndAlsoCheckForProxy();\n \t\t\t// Delete key before transferring in, potentially freeing up some v8 heap\n-\t\t\tUnmaybe(object->Delete(context_handle, key_inner));\n-\t\t\tLocal<Value> val_inner = val->TransferIn();\n-\t\t\tdid_set = Unmaybe(object->Set(context_handle, key_inner, val_inner));\n+\t\t\tUnmaybe(object->Delete(context, name));\n+\t\t\tauto val_inner = val->TransferIn();\n+\t\t\tif (!Unmaybe(object->CreateDataProperty(context, GetKey(context), val_inner))) {\n+\t\t\t\tthrow RuntimeTypeError(\"Set failed\");\n+\t\t\t}\n \t\t}",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\tLocal<Context> context_handle = Deref(context);",
                "\t\t\tContext::Scope context_scope{context_handle};",
                "\t\t\tLocal<Value> key_inner = key->CopyInto();",
                "\t\t\tLocal<Object> object = Local<Object>::Cast(Deref(reference));",
                "\t\t\tUnmaybe(object->Delete(context_handle, key_inner));",
                "\t\t\tLocal<Value> val_inner = val->TransferIn();",
                "\t\t\tdid_set = Unmaybe(object->Set(context_handle, key_inner, val_inner));"
            ],
            "added_lines": [
                "\t\t\tauto context = Deref(this->context);",
                "\t\t\tContext::Scope context_scope{context};",
                "\t\t\tauto name = GetKey(context);",
                "\t\t\tauto object = GetTargetAndAlsoCheckForProxy();",
                "\t\t\tUnmaybe(object->Delete(context, name));",
                "\t\t\tauto val_inner = val->TransferIn();",
                "\t\t\tif (!Unmaybe(object->CreateDataProperty(context, GetKey(context), val_inner))) {",
                "\t\t\t\tthrow RuntimeTypeError(\"Set failed\");",
                "\t\t\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-21413",
        "func_name": "laverdet/isolated-vm/DeleteRunner",
        "description": "isolated-vm is a library for nodejs which gives you access to v8's Isolate interface. Versions of isolated-vm before v4.0.0 have API pitfalls which may make it easy for implementers to expose supposed secure isolates to the permissions of the main nodejs isolate. Reference objects allow access to the underlying reference's full prototype chain. In an environment where the implementer has exposed a Reference instance to an attacker they would be able to use it to acquire a Reference to the nodejs context's Function object. Similar application-specific attacks could be possible by modifying the local prototype of other API objects. Access to NativeModule objects could allow an attacker to load and run native code from anywhere on the filesystem. If combined with, for example, a file upload API this would allow for arbitrary code execution. This is addressed in v4.0.0 through a series of related changes.",
        "git_url": "https://github.com/laverdet/isolated-vm/commit/2646e6c1558bac66285daeab54c7d490ed332b15",
        "commit_title": "Don't invoke accessors or proxies via Reference functions",
        "commit_text": "",
        "func_before": "DeleteRunner(ReferenceHandle& that, Local<Value> key_handle) :\n\t\t\t\tkey{ExternalCopy::CopyIfPrimitive(key_handle)},\n\t\t\t\tcontext{that.context},\n\t\t\t\treference{that.reference} {\n\t\t\tthat.CheckDisposed();\n\t\t\tif (!key) {\n\t\t\t\tthrow RuntimeTypeError(\"Invalid `key`\");\n\t\t\t}\n\t\t}",
        "func": "DeleteRunner(ReferenceHandle& that, Local<Value> key_handle) :\n\t\tAccessorRunner{that, key_handle} {}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,9 +1,2 @@\n DeleteRunner(ReferenceHandle& that, Local<Value> key_handle) :\n-\t\t\t\tkey{ExternalCopy::CopyIfPrimitive(key_handle)},\n-\t\t\t\tcontext{that.context},\n-\t\t\t\treference{that.reference} {\n-\t\t\tthat.CheckDisposed();\n-\t\t\tif (!key) {\n-\t\t\t\tthrow RuntimeTypeError(\"Invalid `key`\");\n-\t\t\t}\n-\t\t}\n+\t\tAccessorRunner{that, key_handle} {}",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\t\tkey{ExternalCopy::CopyIfPrimitive(key_handle)},",
                "\t\t\t\tcontext{that.context},",
                "\t\t\t\treference{that.reference} {",
                "\t\t\tthat.CheckDisposed();",
                "\t\t\tif (!key) {",
                "\t\t\t\tthrow RuntimeTypeError(\"Invalid `key`\");",
                "\t\t\t}",
                "\t\t}"
            ],
            "added_lines": [
                "\t\tAccessorRunner{that, key_handle} {}"
            ]
        }
    }
]