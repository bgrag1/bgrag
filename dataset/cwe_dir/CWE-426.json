[
    {
        "cve_id": "CVE-2015-3887",
        "func_name": "rofl0r/proxychains-ng/set_own_dir",
        "description": "Untrusted search path vulnerability in ProxyChains-NG before 4.9 allows local users to gain privileges via a Trojan horse libproxychains4.so library in the current working directory, which is referenced in the LD_PRELOAD path.",
        "git_url": "https://github.com/rofl0r/proxychains-ng/commit/9ab7dbeb3baff67a51d0c5e71465c453be0890b5",
        "commit_title": "fix for CVE-2015-3887",
        "commit_text": " closes #60",
        "func_before": "static void set_own_dir(const char *argv0) {\n\tsize_t l = strlen(argv0);\n\twhile(l && argv0[l - 1] != '/')\n\t\tl--;\n\tif(l == 0)\n\t\tmemcpy(own_dir, \".\", 2);\n\telse {\n\t\tmemcpy(own_dir, argv0, l - 1);\n\t\town_dir[l] = 0;\n\t}\n}",
        "func": "static void set_own_dir(const char *argv0) {\n\tsize_t l = strlen(argv0);\n\twhile(l && argv0[l - 1] != '/')\n\t\tl--;\n\tif(l == 0)\n#ifdef SUPER_SECURE\n\t\tmemcpy(own_dir, \"/dev/null/\", 2);\n#else\n\t\tmemcpy(own_dir, \".\", 2);\n#endif\n\telse {\n\t\tmemcpy(own_dir, argv0, l - 1);\n\t\town_dir[l] = 0;\n\t}\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,7 +3,11 @@\n \twhile(l && argv0[l - 1] != '/')\n \t\tl--;\n \tif(l == 0)\n+#ifdef SUPER_SECURE\n+\t\tmemcpy(own_dir, \"/dev/null/\", 2);\n+#else\n \t\tmemcpy(own_dir, \".\", 2);\n+#endif\n \telse {\n \t\tmemcpy(own_dir, argv0, l - 1);\n \t\town_dir[l] = 0;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "#ifdef SUPER_SECURE",
                "\t\tmemcpy(own_dir, \"/dev/null/\", 2);",
                "#else",
                "#endif"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-15801",
        "func_name": "python/cpython/get_pth_filename",
        "description": "In Python 3.8.4, sys.path restrictions specified in a python38._pth file are ignored, allowing code to be loaded from arbitrary locations. The <executable-name>._pth file (e.g., the python._pth file) is not affected.",
        "git_url": "https://github.com/python/cpython/commit/c92eb8616e86981c50f8fbeafa022b3a6647fdc7",
        "commit_title": "bpo-41304: Ensure python3x._pth is loaded on Windows",
        "commit_text": "",
        "func_before": "static int\nget_pth_filename(PyCalculatePath *calculate, wchar_t *filename,\n                 const _PyPathConfig *pathconfig)\n{\n    if (get_dllpath(filename) &&\n        !change_ext(filename, filename, L\"._pth\") &&\n        exists(filename))\n    {\n        return 1;\n    }\n    if (pathconfig->program_full_path[0] &&\n        !change_ext(filename, pathconfig->program_full_path, L\"._pth\") &&\n        exists(filename))\n    {\n        return 1;\n    }\n    return 0;\n}",
        "func": "static int\nget_pth_filename(PyCalculatePath *calculate, wchar_t *filename,\n                 const _PyPathConfig *pathconfig)\n{\n    if (!get_dllpath(filename) &&\n        !change_ext(filename, filename, L\"._pth\") &&\n        exists(filename))\n    {\n        return 1;\n    }\n    if (pathconfig->program_full_path[0] &&\n        !change_ext(filename, pathconfig->program_full_path, L\"._pth\") &&\n        exists(filename))\n    {\n        return 1;\n    }\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,7 +2,7 @@\n get_pth_filename(PyCalculatePath *calculate, wchar_t *filename,\n                  const _PyPathConfig *pathconfig)\n {\n-    if (get_dllpath(filename) &&\n+    if (!get_dllpath(filename) &&\n         !change_ext(filename, filename, L\"._pth\") &&\n         exists(filename))\n     {",
        "diff_line_info": {
            "deleted_lines": [
                "    if (get_dllpath(filename) &&"
            ],
            "added_lines": [
                "    if (!get_dllpath(filename) &&"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-10009",
        "func_name": "openbsd/src/main",
        "description": "Untrusted search path vulnerability in ssh-agent.c in ssh-agent in OpenSSH before 7.4 allows remote attackers to execute arbitrary local PKCS#11 modules by leveraging control over a forwarded agent-socket.",
        "git_url": "https://github.com/openbsd/src/commit/9476ce1dd37d3c3218d5640b74c34c65e5f4efe5",
        "commit_title": "add a whitelist of paths from which ssh-agent will load (via",
        "commit_text": "ssh-pkcs11-helper) a PKCS#11 module; ok markus@",
        "func_before": "int\nmain(int ac, char **av)\n{\n\tint c_flag = 0, d_flag = 0, D_flag = 0, k_flag = 0, s_flag = 0;\n\tint sock, fd, ch, result, saved_errno;\n\tu_int nalloc;\n\tchar *shell, *format, *pidstr, *agentsocket = NULL;\n\tfd_set *readsetp = NULL, *writesetp = NULL;\n\tstruct rlimit rlim;\n\textern int optind;\n\textern char *optarg;\n\tpid_t pid;\n\tchar pidstrbuf[1 + 3 * sizeof pid];\n\tstruct timeval *tvp = NULL;\n\tsize_t len;\n\tmode_t prev_mask;\n\n\tssh_malloc_init();\t/* must be called before any mallocs */\n\t/* Ensure that fds 0, 1 and 2 are open or directed to /dev/null */\n\tsanitise_stdfd();\n\n\t/* drop */\n\tsetegid(getgid());\n\tsetgid(getgid());\n\n#ifdef WITH_OPENSSL\n\tOpenSSL_add_all_algorithms();\n#endif\n\n\twhile ((ch = getopt(ac, av, \"cDdksE:a:t:\")) != -1) {\n\t\tswitch (ch) {\n\t\tcase 'E':\n\t\t\tfingerprint_hash = ssh_digest_alg_by_name(optarg);\n\t\t\tif (fingerprint_hash == -1)\n\t\t\t\tfatal(\"Invalid hash algorithm \\\"%s\\\"\", optarg);\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tif (s_flag)\n\t\t\t\tusage();\n\t\t\tc_flag++;\n\t\t\tbreak;\n\t\tcase 'k':\n\t\t\tk_flag++;\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tif (c_flag)\n\t\t\t\tusage();\n\t\t\ts_flag++;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tif (d_flag || D_flag)\n\t\t\t\tusage();\n\t\t\td_flag++;\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\tif (d_flag || D_flag)\n\t\t\t\tusage();\n\t\t\tD_flag++;\n\t\t\tbreak;\n\t\tcase 'a':\n\t\t\tagentsocket = optarg;\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tif ((lifetime = convtime(optarg)) == -1) {\n\t\t\t\tfprintf(stderr, \"Invalid lifetime\\n\");\n\t\t\t\tusage();\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage();\n\t\t}\n\t}\n\tac -= optind;\n\tav += optind;\n\n\tif (ac > 0 && (c_flag || k_flag || s_flag || d_flag || D_flag))\n\t\tusage();\n\n\tif (ac == 0 && !c_flag && !s_flag) {\n\t\tshell = getenv(\"SHELL\");\n\t\tif (shell != NULL && (len = strlen(shell)) > 2 &&\n\t\t    strncmp(shell + len - 3, \"csh\", 3) == 0)\n\t\t\tc_flag = 1;\n\t}\n\tif (k_flag) {\n\t\tconst char *errstr = NULL;\n\n\t\tpidstr = getenv(SSH_AGENTPID_ENV_NAME);\n\t\tif (pidstr == NULL) {\n\t\t\tfprintf(stderr, \"%s not set, cannot kill agent\\n\",\n\t\t\t    SSH_AGENTPID_ENV_NAME);\n\t\t\texit(1);\n\t\t}\n\t\tpid = (int)strtonum(pidstr, 2, INT_MAX, &errstr);\n\t\tif (errstr) {\n\t\t\tfprintf(stderr,\n\t\t\t    \"%s=\\\"%s\\\", which is not a good PID: %s\\n\",\n\t\t\t    SSH_AGENTPID_ENV_NAME, pidstr, errstr);\n\t\t\texit(1);\n\t\t}\n\t\tif (kill(pid, SIGTERM) == -1) {\n\t\t\tperror(\"kill\");\n\t\t\texit(1);\n\t\t}\n\t\tformat = c_flag ? \"unsetenv %s;\\n\" : \"unset %s;\\n\";\n\t\tprintf(format, SSH_AUTHSOCKET_ENV_NAME);\n\t\tprintf(format, SSH_AGENTPID_ENV_NAME);\n\t\tprintf(\"echo Agent pid %ld killed;\\n\", (long)pid);\n\t\texit(0);\n\t}\n\tparent_pid = getpid();\n\n\tif (agentsocket == NULL) {\n\t\t/* Create private directory for agent socket */\n\t\tmktemp_proto(socket_dir, sizeof(socket_dir));\n\t\tif (mkdtemp(socket_dir) == NULL) {\n\t\t\tperror(\"mkdtemp: private socket dir\");\n\t\t\texit(1);\n\t\t}\n\t\tsnprintf(socket_name, sizeof socket_name, \"%s/agent.%ld\", socket_dir,\n\t\t    (long)parent_pid);\n\t} else {\n\t\t/* Try to use specified agent socket */\n\t\tsocket_dir[0] = '\\0';\n\t\tstrlcpy(socket_name, agentsocket, sizeof socket_name);\n\t}\n\n\t/*\n\t * Create socket early so it will exist before command gets run from\n\t * the parent.\n\t */\n\tprev_mask = umask(0177);\n\tsock = unix_listener(socket_name, SSH_LISTEN_BACKLOG, 0);\n\tif (sock < 0) {\n\t\t/* XXX - unix_listener() calls error() not perror() */\n\t\t*socket_name = '\\0'; /* Don't unlink any existing file */\n\t\tcleanup_exit(1);\n\t}\n\tumask(prev_mask);\n\n\t/*\n\t * Fork, and have the parent execute the command, if any, or present\n\t * the socket data.  The child continues as the authentication agent.\n\t */\n\tif (D_flag || d_flag) {\n\t\tlog_init(__progname,\n\t\t    d_flag ? SYSLOG_LEVEL_DEBUG3 : SYSLOG_LEVEL_INFO,\n\t\t    SYSLOG_FACILITY_AUTH, 1);\n\t\tformat = c_flag ? \"setenv %s %s;\\n\" : \"%s=%s; export %s;\\n\";\n\t\tprintf(format, SSH_AUTHSOCKET_ENV_NAME, socket_name,\n\t\t    SSH_AUTHSOCKET_ENV_NAME);\n\t\tprintf(\"echo Agent pid %ld;\\n\", (long)parent_pid);\n\t\tfflush(stdout);\n\t\tgoto skip;\n\t}\n\tpid = fork();\n\tif (pid == -1) {\n\t\tperror(\"fork\");\n\t\tcleanup_exit(1);\n\t}\n\tif (pid != 0) {\t\t/* Parent - execute the given command. */\n\t\tclose(sock);\n\t\tsnprintf(pidstrbuf, sizeof pidstrbuf, \"%ld\", (long)pid);\n\t\tif (ac == 0) {\n\t\t\tformat = c_flag ? \"setenv %s %s;\\n\" : \"%s=%s; export %s;\\n\";\n\t\t\tprintf(format, SSH_AUTHSOCKET_ENV_NAME, socket_name,\n\t\t\t    SSH_AUTHSOCKET_ENV_NAME);\n\t\t\tprintf(format, SSH_AGENTPID_ENV_NAME, pidstrbuf,\n\t\t\t    SSH_AGENTPID_ENV_NAME);\n\t\t\tprintf(\"echo Agent pid %ld;\\n\", (long)pid);\n\t\t\texit(0);\n\t\t}\n\t\tif (setenv(SSH_AUTHSOCKET_ENV_NAME, socket_name, 1) == -1 ||\n\t\t    setenv(SSH_AGENTPID_ENV_NAME, pidstrbuf, 1) == -1) {\n\t\t\tperror(\"setenv\");\n\t\t\texit(1);\n\t\t}\n\t\texecvp(av[0], av);\n\t\tperror(av[0]);\n\t\texit(1);\n\t}\n\t/* child */\n\tlog_init(__progname, SYSLOG_LEVEL_INFO, SYSLOG_FACILITY_AUTH, 0);\n\n\tif (setsid() == -1) {\n\t\terror(\"setsid: %s\", strerror(errno));\n\t\tcleanup_exit(1);\n\t}\n\n\t(void)chdir(\"/\");\n\tif ((fd = open(_PATH_DEVNULL, O_RDWR, 0)) != -1) {\n\t\t/* XXX might close listen socket */\n\t\t(void)dup2(fd, STDIN_FILENO);\n\t\t(void)dup2(fd, STDOUT_FILENO);\n\t\t(void)dup2(fd, STDERR_FILENO);\n\t\tif (fd > 2)\n\t\t\tclose(fd);\n\t}\n\n\t/* deny core dumps, since memory contains unencrypted private keys */\n\trlim.rlim_cur = rlim.rlim_max = 0;\n\tif (setrlimit(RLIMIT_CORE, &rlim) < 0) {\n\t\terror(\"setrlimit RLIMIT_CORE: %s\", strerror(errno));\n\t\tcleanup_exit(1);\n\t}\n\nskip:\n\n\tcleanup_pid = getpid();\n\n#ifdef ENABLE_PKCS11\n\tpkcs11_init(0);\n#endif\n\tnew_socket(AUTH_SOCKET, sock);\n\tif (ac > 0)\n\t\tparent_alive_interval = 10;\n\tidtab_init();\n\tsignal(SIGPIPE, SIG_IGN);\n\tsignal(SIGINT, (d_flag | D_flag) ? cleanup_handler : SIG_IGN);\n\tsignal(SIGHUP, cleanup_handler);\n\tsignal(SIGTERM, cleanup_handler);\n\tnalloc = 0;\n\n\tif (pledge(\"stdio cpath unix id proc exec\", NULL) == -1)\n\t\tfatal(\"%s: pledge: %s\", __progname, strerror(errno));\n\n\twhile (1) {\n\t\tprepare_select(&readsetp, &writesetp, &max_fd, &nalloc, &tvp);\n\t\tresult = select(max_fd + 1, readsetp, writesetp, NULL, tvp);\n\t\tsaved_errno = errno;\n\t\tif (parent_alive_interval != 0)\n\t\t\tcheck_parent_exists();\n\t\t(void) reaper();\t/* remove expired keys */\n\t\tif (result < 0) {\n\t\t\tif (saved_errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\tfatal(\"select: %s\", strerror(saved_errno));\n\t\t} else if (result > 0)\n\t\t\tafter_select(readsetp, writesetp);\n\t}\n\t/* NOTREACHED */\n}",
        "func": "int\nmain(int ac, char **av)\n{\n\tint c_flag = 0, d_flag = 0, D_flag = 0, k_flag = 0, s_flag = 0;\n\tint sock, fd, ch, result, saved_errno;\n\tu_int nalloc;\n\tchar *shell, *format, *pidstr, *agentsocket = NULL;\n\tfd_set *readsetp = NULL, *writesetp = NULL;\n\tstruct rlimit rlim;\n\textern int optind;\n\textern char *optarg;\n\tpid_t pid;\n\tchar pidstrbuf[1 + 3 * sizeof pid];\n\tstruct timeval *tvp = NULL;\n\tsize_t len;\n\tmode_t prev_mask;\n\n\tssh_malloc_init();\t/* must be called before any mallocs */\n\t/* Ensure that fds 0, 1 and 2 are open or directed to /dev/null */\n\tsanitise_stdfd();\n\n\t/* drop */\n\tsetegid(getgid());\n\tsetgid(getgid());\n\n#ifdef WITH_OPENSSL\n\tOpenSSL_add_all_algorithms();\n#endif\n\n\twhile ((ch = getopt(ac, av, \"cDdksE:a:P:t:\")) != -1) {\n\t\tswitch (ch) {\n\t\tcase 'E':\n\t\t\tfingerprint_hash = ssh_digest_alg_by_name(optarg);\n\t\t\tif (fingerprint_hash == -1)\n\t\t\t\tfatal(\"Invalid hash algorithm \\\"%s\\\"\", optarg);\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tif (s_flag)\n\t\t\t\tusage();\n\t\t\tc_flag++;\n\t\t\tbreak;\n\t\tcase 'k':\n\t\t\tk_flag++;\n\t\t\tbreak;\n\t\tcase 'P':\n\t\t\tif (pkcs11_whitelist != NULL)\n\t\t\t\tfatal(\"-P option already specified\");\n\t\t\tpkcs11_whitelist = xstrdup(optarg);\n\t\t\tbreak;\n\t\tcase 's':\n\t\t\tif (c_flag)\n\t\t\t\tusage();\n\t\t\ts_flag++;\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\tif (d_flag || D_flag)\n\t\t\t\tusage();\n\t\t\td_flag++;\n\t\t\tbreak;\n\t\tcase 'D':\n\t\t\tif (d_flag || D_flag)\n\t\t\t\tusage();\n\t\t\tD_flag++;\n\t\t\tbreak;\n\t\tcase 'a':\n\t\t\tagentsocket = optarg;\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tif ((lifetime = convtime(optarg)) == -1) {\n\t\t\t\tfprintf(stderr, \"Invalid lifetime\\n\");\n\t\t\t\tusage();\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage();\n\t\t}\n\t}\n\tac -= optind;\n\tav += optind;\n\n\tif (ac > 0 && (c_flag || k_flag || s_flag || d_flag || D_flag))\n\t\tusage();\n\n\tif (pkcs11_whitelist == NULL)\n\t\tpkcs11_whitelist = xstrdup(DEFAULT_PKCS11_WHITELIST);\n\n\tif (ac == 0 && !c_flag && !s_flag) {\n\t\tshell = getenv(\"SHELL\");\n\t\tif (shell != NULL && (len = strlen(shell)) > 2 &&\n\t\t    strncmp(shell + len - 3, \"csh\", 3) == 0)\n\t\t\tc_flag = 1;\n\t}\n\tif (k_flag) {\n\t\tconst char *errstr = NULL;\n\n\t\tpidstr = getenv(SSH_AGENTPID_ENV_NAME);\n\t\tif (pidstr == NULL) {\n\t\t\tfprintf(stderr, \"%s not set, cannot kill agent\\n\",\n\t\t\t    SSH_AGENTPID_ENV_NAME);\n\t\t\texit(1);\n\t\t}\n\t\tpid = (int)strtonum(pidstr, 2, INT_MAX, &errstr);\n\t\tif (errstr) {\n\t\t\tfprintf(stderr,\n\t\t\t    \"%s=\\\"%s\\\", which is not a good PID: %s\\n\",\n\t\t\t    SSH_AGENTPID_ENV_NAME, pidstr, errstr);\n\t\t\texit(1);\n\t\t}\n\t\tif (kill(pid, SIGTERM) == -1) {\n\t\t\tperror(\"kill\");\n\t\t\texit(1);\n\t\t}\n\t\tformat = c_flag ? \"unsetenv %s;\\n\" : \"unset %s;\\n\";\n\t\tprintf(format, SSH_AUTHSOCKET_ENV_NAME);\n\t\tprintf(format, SSH_AGENTPID_ENV_NAME);\n\t\tprintf(\"echo Agent pid %ld killed;\\n\", (long)pid);\n\t\texit(0);\n\t}\n\tparent_pid = getpid();\n\n\tif (agentsocket == NULL) {\n\t\t/* Create private directory for agent socket */\n\t\tmktemp_proto(socket_dir, sizeof(socket_dir));\n\t\tif (mkdtemp(socket_dir) == NULL) {\n\t\t\tperror(\"mkdtemp: private socket dir\");\n\t\t\texit(1);\n\t\t}\n\t\tsnprintf(socket_name, sizeof socket_name, \"%s/agent.%ld\", socket_dir,\n\t\t    (long)parent_pid);\n\t} else {\n\t\t/* Try to use specified agent socket */\n\t\tsocket_dir[0] = '\\0';\n\t\tstrlcpy(socket_name, agentsocket, sizeof socket_name);\n\t}\n\n\t/*\n\t * Create socket early so it will exist before command gets run from\n\t * the parent.\n\t */\n\tprev_mask = umask(0177);\n\tsock = unix_listener(socket_name, SSH_LISTEN_BACKLOG, 0);\n\tif (sock < 0) {\n\t\t/* XXX - unix_listener() calls error() not perror() */\n\t\t*socket_name = '\\0'; /* Don't unlink any existing file */\n\t\tcleanup_exit(1);\n\t}\n\tumask(prev_mask);\n\n\t/*\n\t * Fork, and have the parent execute the command, if any, or present\n\t * the socket data.  The child continues as the authentication agent.\n\t */\n\tif (D_flag || d_flag) {\n\t\tlog_init(__progname,\n\t\t    d_flag ? SYSLOG_LEVEL_DEBUG3 : SYSLOG_LEVEL_INFO,\n\t\t    SYSLOG_FACILITY_AUTH, 1);\n\t\tformat = c_flag ? \"setenv %s %s;\\n\" : \"%s=%s; export %s;\\n\";\n\t\tprintf(format, SSH_AUTHSOCKET_ENV_NAME, socket_name,\n\t\t    SSH_AUTHSOCKET_ENV_NAME);\n\t\tprintf(\"echo Agent pid %ld;\\n\", (long)parent_pid);\n\t\tfflush(stdout);\n\t\tgoto skip;\n\t}\n\tpid = fork();\n\tif (pid == -1) {\n\t\tperror(\"fork\");\n\t\tcleanup_exit(1);\n\t}\n\tif (pid != 0) {\t\t/* Parent - execute the given command. */\n\t\tclose(sock);\n\t\tsnprintf(pidstrbuf, sizeof pidstrbuf, \"%ld\", (long)pid);\n\t\tif (ac == 0) {\n\t\t\tformat = c_flag ? \"setenv %s %s;\\n\" : \"%s=%s; export %s;\\n\";\n\t\t\tprintf(format, SSH_AUTHSOCKET_ENV_NAME, socket_name,\n\t\t\t    SSH_AUTHSOCKET_ENV_NAME);\n\t\t\tprintf(format, SSH_AGENTPID_ENV_NAME, pidstrbuf,\n\t\t\t    SSH_AGENTPID_ENV_NAME);\n\t\t\tprintf(\"echo Agent pid %ld;\\n\", (long)pid);\n\t\t\texit(0);\n\t\t}\n\t\tif (setenv(SSH_AUTHSOCKET_ENV_NAME, socket_name, 1) == -1 ||\n\t\t    setenv(SSH_AGENTPID_ENV_NAME, pidstrbuf, 1) == -1) {\n\t\t\tperror(\"setenv\");\n\t\t\texit(1);\n\t\t}\n\t\texecvp(av[0], av);\n\t\tperror(av[0]);\n\t\texit(1);\n\t}\n\t/* child */\n\tlog_init(__progname, SYSLOG_LEVEL_INFO, SYSLOG_FACILITY_AUTH, 0);\n\n\tif (setsid() == -1) {\n\t\terror(\"setsid: %s\", strerror(errno));\n\t\tcleanup_exit(1);\n\t}\n\n\t(void)chdir(\"/\");\n\tif ((fd = open(_PATH_DEVNULL, O_RDWR, 0)) != -1) {\n\t\t/* XXX might close listen socket */\n\t\t(void)dup2(fd, STDIN_FILENO);\n\t\t(void)dup2(fd, STDOUT_FILENO);\n\t\t(void)dup2(fd, STDERR_FILENO);\n\t\tif (fd > 2)\n\t\t\tclose(fd);\n\t}\n\n\t/* deny core dumps, since memory contains unencrypted private keys */\n\trlim.rlim_cur = rlim.rlim_max = 0;\n\tif (setrlimit(RLIMIT_CORE, &rlim) < 0) {\n\t\terror(\"setrlimit RLIMIT_CORE: %s\", strerror(errno));\n\t\tcleanup_exit(1);\n\t}\n\nskip:\n\n\tcleanup_pid = getpid();\n\n#ifdef ENABLE_PKCS11\n\tpkcs11_init(0);\n#endif\n\tnew_socket(AUTH_SOCKET, sock);\n\tif (ac > 0)\n\t\tparent_alive_interval = 10;\n\tidtab_init();\n\tsignal(SIGPIPE, SIG_IGN);\n\tsignal(SIGINT, (d_flag | D_flag) ? cleanup_handler : SIG_IGN);\n\tsignal(SIGHUP, cleanup_handler);\n\tsignal(SIGTERM, cleanup_handler);\n\tnalloc = 0;\n\n\tif (pledge(\"stdio rpath cpath unix id proc exec\", NULL) == -1)\n\t\tfatal(\"%s: pledge: %s\", __progname, strerror(errno));\n\n\twhile (1) {\n\t\tprepare_select(&readsetp, &writesetp, &max_fd, &nalloc, &tvp);\n\t\tresult = select(max_fd + 1, readsetp, writesetp, NULL, tvp);\n\t\tsaved_errno = errno;\n\t\tif (parent_alive_interval != 0)\n\t\t\tcheck_parent_exists();\n\t\t(void) reaper();\t/* remove expired keys */\n\t\tif (result < 0) {\n\t\t\tif (saved_errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\tfatal(\"select: %s\", strerror(saved_errno));\n\t\t} else if (result > 0)\n\t\t\tafter_select(readsetp, writesetp);\n\t}\n\t/* NOTREACHED */\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -27,7 +27,7 @@\n \tOpenSSL_add_all_algorithms();\n #endif\n \n-\twhile ((ch = getopt(ac, av, \"cDdksE:a:t:\")) != -1) {\n+\twhile ((ch = getopt(ac, av, \"cDdksE:a:P:t:\")) != -1) {\n \t\tswitch (ch) {\n \t\tcase 'E':\n \t\t\tfingerprint_hash = ssh_digest_alg_by_name(optarg);\n@@ -42,6 +42,11 @@\n \t\tcase 'k':\n \t\t\tk_flag++;\n \t\t\tbreak;\n+\t\tcase 'P':\n+\t\t\tif (pkcs11_whitelist != NULL)\n+\t\t\t\tfatal(\"-P option already specified\");\n+\t\t\tpkcs11_whitelist = xstrdup(optarg);\n+\t\t\tbreak;\n \t\tcase 's':\n \t\t\tif (c_flag)\n \t\t\t\tusage();\n@@ -75,6 +80,9 @@\n \n \tif (ac > 0 && (c_flag || k_flag || s_flag || d_flag || D_flag))\n \t\tusage();\n+\n+\tif (pkcs11_whitelist == NULL)\n+\t\tpkcs11_whitelist = xstrdup(DEFAULT_PKCS11_WHITELIST);\n \n \tif (ac == 0 && !c_flag && !s_flag) {\n \t\tshell = getenv(\"SHELL\");\n@@ -221,7 +229,7 @@\n \tsignal(SIGTERM, cleanup_handler);\n \tnalloc = 0;\n \n-\tif (pledge(\"stdio cpath unix id proc exec\", NULL) == -1)\n+\tif (pledge(\"stdio rpath cpath unix id proc exec\", NULL) == -1)\n \t\tfatal(\"%s: pledge: %s\", __progname, strerror(errno));\n \n \twhile (1) {",
        "diff_line_info": {
            "deleted_lines": [
                "\twhile ((ch = getopt(ac, av, \"cDdksE:a:t:\")) != -1) {",
                "\tif (pledge(\"stdio cpath unix id proc exec\", NULL) == -1)"
            ],
            "added_lines": [
                "\twhile ((ch = getopt(ac, av, \"cDdksE:a:P:t:\")) != -1) {",
                "\t\tcase 'P':",
                "\t\t\tif (pkcs11_whitelist != NULL)",
                "\t\t\t\tfatal(\"-P option already specified\");",
                "\t\t\tpkcs11_whitelist = xstrdup(optarg);",
                "\t\t\tbreak;",
                "",
                "\tif (pkcs11_whitelist == NULL)",
                "\t\tpkcs11_whitelist = xstrdup(DEFAULT_PKCS11_WHITELIST);",
                "\tif (pledge(\"stdio rpath cpath unix id proc exec\", NULL) == -1)"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-10009",
        "func_name": "openbsd/src/process_add_smartcard_key",
        "description": "Untrusted search path vulnerability in ssh-agent.c in ssh-agent in OpenSSH before 7.4 allows remote attackers to execute arbitrary local PKCS#11 modules by leveraging control over a forwarded agent-socket.",
        "git_url": "https://github.com/openbsd/src/commit/9476ce1dd37d3c3218d5640b74c34c65e5f4efe5",
        "commit_title": "add a whitelist of paths from which ssh-agent will load (via",
        "commit_text": "ssh-pkcs11-helper) a PKCS#11 module; ok markus@",
        "func_before": "static void\nprocess_add_smartcard_key(SocketEntry *e)\n{\n\tchar *provider = NULL, *pin;\n\tint r, i, version, count = 0, success = 0, confirm = 0;\n\tu_int seconds;\n\ttime_t death = 0;\n\tu_char type;\n\tstruct sshkey **keys = NULL, *k;\n\tIdentity *id;\n\tIdtab *tab;\n\n\tif ((r = sshbuf_get_cstring(e->request, &provider, NULL)) != 0 ||\n\t    (r = sshbuf_get_cstring(e->request, &pin, NULL)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\twhile (sshbuf_len(e->request)) {\n\t\tif ((r = sshbuf_get_u8(e->request, &type)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tswitch (type) {\n\t\tcase SSH_AGENT_CONSTRAIN_LIFETIME:\n\t\t\tif ((r = sshbuf_get_u32(e->request, &seconds)) != 0)\n\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\tdeath = monotime() + seconds;\n\t\t\tbreak;\n\t\tcase SSH_AGENT_CONSTRAIN_CONFIRM:\n\t\t\tconfirm = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror(\"process_add_smartcard_key: \"\n\t\t\t    \"Unknown constraint type %d\", type);\n\t\t\tgoto send;\n\t\t}\n\t}\n\tif (lifetime && !death)\n\t\tdeath = monotime() + lifetime;\n\n\tcount = pkcs11_add_provider(provider, pin, &keys);\n\tfor (i = 0; i < count; i++) {\n\t\tk = keys[i];\n\t\tversion = k->type == KEY_RSA1 ? 1 : 2;\n\t\ttab = idtab_lookup(version);\n\t\tif (lookup_identity(k, version) == NULL) {\n\t\t\tid = xcalloc(1, sizeof(Identity));\n\t\t\tid->key = k;\n\t\t\tid->provider = xstrdup(provider);\n\t\t\tid->comment = xstrdup(provider); /* XXX */\n\t\t\tid->death = death;\n\t\t\tid->confirm = confirm;\n\t\t\tTAILQ_INSERT_TAIL(&tab->idlist, id, next);\n\t\t\ttab->nentries++;\n\t\t\tsuccess = 1;\n\t\t} else {\n\t\t\tsshkey_free(k);\n\t\t}\n\t\tkeys[i] = NULL;\n\t}\nsend:\n\tfree(pin);\n\tfree(provider);\n\tfree(keys);\n\tsend_status(e, success);\n}",
        "func": "static void\nprocess_add_smartcard_key(SocketEntry *e)\n{\n\tchar *provider = NULL, *pin, canonical_provider[PATH_MAX];\n\tint r, i, version, count = 0, success = 0, confirm = 0;\n\tu_int seconds;\n\ttime_t death = 0;\n\tu_char type;\n\tstruct sshkey **keys = NULL, *k;\n\tIdentity *id;\n\tIdtab *tab;\n\n\tif ((r = sshbuf_get_cstring(e->request, &provider, NULL)) != 0 ||\n\t    (r = sshbuf_get_cstring(e->request, &pin, NULL)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\twhile (sshbuf_len(e->request)) {\n\t\tif ((r = sshbuf_get_u8(e->request, &type)) != 0)\n\t\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\t\tswitch (type) {\n\t\tcase SSH_AGENT_CONSTRAIN_LIFETIME:\n\t\t\tif ((r = sshbuf_get_u32(e->request, &seconds)) != 0)\n\t\t\t\tfatal(\"%s: buffer error: %s\",\n\t\t\t\t    __func__, ssh_err(r));\n\t\t\tdeath = monotime() + seconds;\n\t\t\tbreak;\n\t\tcase SSH_AGENT_CONSTRAIN_CONFIRM:\n\t\t\tconfirm = 1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terror(\"process_add_smartcard_key: \"\n\t\t\t    \"Unknown constraint type %d\", type);\n\t\t\tgoto send;\n\t\t}\n\t}\n\tif (realpath(provider, canonical_provider) == NULL) {\n\t\tverbose(\"failed PKCS#11 add of \\\"%.100s\\\": realpath: %s\",\n\t\t    provider, strerror(errno));\n\t\tgoto send;\n\t}\n\tif (match_pattern_list(canonical_provider, pkcs11_whitelist, 0) != 1) {\n\t\tverbose(\"refusing PKCS#11 add of \\\"%.100s\\\": \"\n\t\t    \"provider not whitelisted\", canonical_provider);\n\t\tgoto send;\n\t}\n\tdebug(\"%s: add %.100s\", __func__, canonical_provider);\n\tif (lifetime && !death)\n\t\tdeath = monotime() + lifetime;\n\n\tcount = pkcs11_add_provider(canonical_provider, pin, &keys);\n\tfor (i = 0; i < count; i++) {\n\t\tk = keys[i];\n\t\tversion = k->type == KEY_RSA1 ? 1 : 2;\n\t\ttab = idtab_lookup(version);\n\t\tif (lookup_identity(k, version) == NULL) {\n\t\t\tid = xcalloc(1, sizeof(Identity));\n\t\t\tid->key = k;\n\t\t\tid->provider = xstrdup(canonical_provider);\n\t\t\tid->comment = xstrdup(canonical_provider); /* XXX */\n\t\t\tid->death = death;\n\t\t\tid->confirm = confirm;\n\t\t\tTAILQ_INSERT_TAIL(&tab->idlist, id, next);\n\t\t\ttab->nentries++;\n\t\t\tsuccess = 1;\n\t\t} else {\n\t\t\tsshkey_free(k);\n\t\t}\n\t\tkeys[i] = NULL;\n\t}\nsend:\n\tfree(pin);\n\tfree(provider);\n\tfree(keys);\n\tsend_status(e, success);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,7 +1,7 @@\n static void\n process_add_smartcard_key(SocketEntry *e)\n {\n-\tchar *provider = NULL, *pin;\n+\tchar *provider = NULL, *pin, canonical_provider[PATH_MAX];\n \tint r, i, version, count = 0, success = 0, confirm = 0;\n \tu_int seconds;\n \ttime_t death = 0;\n@@ -33,10 +33,21 @@\n \t\t\tgoto send;\n \t\t}\n \t}\n+\tif (realpath(provider, canonical_provider) == NULL) {\n+\t\tverbose(\"failed PKCS#11 add of \\\"%.100s\\\": realpath: %s\",\n+\t\t    provider, strerror(errno));\n+\t\tgoto send;\n+\t}\n+\tif (match_pattern_list(canonical_provider, pkcs11_whitelist, 0) != 1) {\n+\t\tverbose(\"refusing PKCS#11 add of \\\"%.100s\\\": \"\n+\t\t    \"provider not whitelisted\", canonical_provider);\n+\t\tgoto send;\n+\t}\n+\tdebug(\"%s: add %.100s\", __func__, canonical_provider);\n \tif (lifetime && !death)\n \t\tdeath = monotime() + lifetime;\n \n-\tcount = pkcs11_add_provider(provider, pin, &keys);\n+\tcount = pkcs11_add_provider(canonical_provider, pin, &keys);\n \tfor (i = 0; i < count; i++) {\n \t\tk = keys[i];\n \t\tversion = k->type == KEY_RSA1 ? 1 : 2;\n@@ -44,8 +55,8 @@\n \t\tif (lookup_identity(k, version) == NULL) {\n \t\t\tid = xcalloc(1, sizeof(Identity));\n \t\t\tid->key = k;\n-\t\t\tid->provider = xstrdup(provider);\n-\t\t\tid->comment = xstrdup(provider); /* XXX */\n+\t\t\tid->provider = xstrdup(canonical_provider);\n+\t\t\tid->comment = xstrdup(canonical_provider); /* XXX */\n \t\t\tid->death = death;\n \t\t\tid->confirm = confirm;\n \t\t\tTAILQ_INSERT_TAIL(&tab->idlist, id, next);",
        "diff_line_info": {
            "deleted_lines": [
                "\tchar *provider = NULL, *pin;",
                "\tcount = pkcs11_add_provider(provider, pin, &keys);",
                "\t\t\tid->provider = xstrdup(provider);",
                "\t\t\tid->comment = xstrdup(provider); /* XXX */"
            ],
            "added_lines": [
                "\tchar *provider = NULL, *pin, canonical_provider[PATH_MAX];",
                "\tif (realpath(provider, canonical_provider) == NULL) {",
                "\t\tverbose(\"failed PKCS#11 add of \\\"%.100s\\\": realpath: %s\",",
                "\t\t    provider, strerror(errno));",
                "\t\tgoto send;",
                "\t}",
                "\tif (match_pattern_list(canonical_provider, pkcs11_whitelist, 0) != 1) {",
                "\t\tverbose(\"refusing PKCS#11 add of \\\"%.100s\\\": \"",
                "\t\t    \"provider not whitelisted\", canonical_provider);",
                "\t\tgoto send;",
                "\t}",
                "\tdebug(\"%s: add %.100s\", __func__, canonical_provider);",
                "\tcount = pkcs11_add_provider(canonical_provider, pin, &keys);",
                "\t\t\tid->provider = xstrdup(canonical_provider);",
                "\t\t\tid->comment = xstrdup(canonical_provider); /* XXX */"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-10009",
        "func_name": "openbsd/src/usage",
        "description": "Untrusted search path vulnerability in ssh-agent.c in ssh-agent in OpenSSH before 7.4 allows remote attackers to execute arbitrary local PKCS#11 modules by leveraging control over a forwarded agent-socket.",
        "git_url": "https://github.com/openbsd/src/commit/9476ce1dd37d3c3218d5640b74c34c65e5f4efe5",
        "commit_title": "add a whitelist of paths from which ssh-agent will load (via",
        "commit_text": "ssh-pkcs11-helper) a PKCS#11 module; ok markus@",
        "func_before": "static void\nusage(void)\n{\n\tfprintf(stderr,\n\t    \"usage: ssh-agent [-c | -s] [-Dd] [-a bind_address] [-E fingerprint_hash]\\n\"\n\t    \"                 [-t life] [command [arg ...]]\\n\"\n\t    \"       ssh-agent [-c | -s] -k\\n\");\n\texit(1);\n}",
        "func": "static void\nusage(void)\n{\n\tfprintf(stderr,\n\t    \"usage: ssh-agent [-c | -s] [-Dd] [-a bind_address] [-E fingerprint_hash]\\n\"\n\t    \"                 [-P pkcs11_whitelist] [-t life] [command [arg ...]]\\n\"\n\t    \"       ssh-agent [-c | -s] -k\\n\");\n\texit(1);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,7 +3,7 @@\n {\n \tfprintf(stderr,\n \t    \"usage: ssh-agent [-c | -s] [-Dd] [-a bind_address] [-E fingerprint_hash]\\n\"\n-\t    \"                 [-t life] [command [arg ...]]\\n\"\n+\t    \"                 [-P pkcs11_whitelist] [-t life] [command [arg ...]]\\n\"\n \t    \"       ssh-agent [-c | -s] -k\\n\");\n \texit(1);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\t    \"                 [-t life] [command [arg ...]]\\n\""
            ],
            "added_lines": [
                "\t    \"                 [-P pkcs11_whitelist] [-t life] [command [arg ...]]\\n\""
            ]
        }
    },
    {
        "cve_id": "CVE-2016-7838",
        "func_name": "vslavik/winsparkle/CreateUniqueTempDirectory",
        "description": "Untrusted search path vulnerability in WinSparkle versions prior to 0.5.3 allows remote attackers to execute arbitrary code via a specially crafted executable file in an unspecified directory.",
        "git_url": "https://github.com/vslavik/winsparkle/commit/bb454857348245a7397f9e4fbb3a902f4ac25913",
        "commit_title": "Verify UpdateTempDir isn't maliciously modified",
        "commit_text": " Don't just delete the stored updates temporary directory on launch, but validate the registry key to ensure it is in an expected location and follows WinSparkle's naming convention. This is to prevent malicious users from modifying this registry key and forcing the host app to delete arbitrary directories (a user being able to delete the key would be able to delete the directory themselves, so it's not a serious issue, but it nevertheless is bad behavior and shouldn't be possible).",
        "func_before": "std::wstring CreateUniqueTempDirectory()\n{\n    // We need to put downloaded updates into a directory of their own, because\n    // if we put it in $TMP, some DLLs could be there and interfere with the\n    // installer.\n    //\n    // This code creates a new randomized directory name and tries to create it;\n    // this process is repeated if the directory already exists.\n    wchar_t tmpdir[MAX_PATH+1];\n    if ( GetTempPath(MAX_PATH+1, tmpdir) == 0 )\n        throw Win32Exception(\"Cannot create temporary directory\");\n\n    for ( ;; )\n    {\n        std::wstring dir(tmpdir);\n        dir += L\"Update-\";\n\n        UUID uuid;\n        UuidCreate(&uuid);\n        RPC_WSTR uuidStr;\n        RPC_STATUS status = UuidToString(&uuid, &uuidStr);\n        dir += reinterpret_cast<wchar_t*>(uuidStr);\n        RpcStringFree(&uuidStr);\n\n        if ( CreateDirectory(dir.c_str(), NULL) )\n            return dir;\n        else if ( GetLastError() != ERROR_ALREADY_EXISTS )\n            throw Win32Exception(\"Cannot create temporary directory\");\n    }\n}",
        "func": "std::wstring CreateUniqueTempDirectory()\n{\n    // We need to put downloaded updates into a directory of their own, because\n    // if we put it in $TMP, some DLLs could be there and interfere with the\n    // installer.\n    //\n    // This code creates a new randomized directory name and tries to create it;\n    // this process is repeated if the directory already exists.\n    const std::wstring tmpdir = GetUniqueTempDirectoryPrefix();\n\n    for ( ;; )\n    {\n        std::wstring dir(tmpdir);\n        UUID uuid;\n        UuidCreate(&uuid);\n        RPC_WSTR uuidStr;\n        RPC_STATUS status = UuidToString(&uuid, &uuidStr);\n        dir += reinterpret_cast<wchar_t*>(uuidStr);\n        RpcStringFree(&uuidStr);\n\n        if ( CreateDirectory(dir.c_str(), NULL) )\n            return dir;\n        else if ( GetLastError() != ERROR_ALREADY_EXISTS )\n            throw Win32Exception(\"Cannot create temporary directory\");\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,15 +6,11 @@\n     //\n     // This code creates a new randomized directory name and tries to create it;\n     // this process is repeated if the directory already exists.\n-    wchar_t tmpdir[MAX_PATH+1];\n-    if ( GetTempPath(MAX_PATH+1, tmpdir) == 0 )\n-        throw Win32Exception(\"Cannot create temporary directory\");\n+    const std::wstring tmpdir = GetUniqueTempDirectoryPrefix();\n \n     for ( ;; )\n     {\n         std::wstring dir(tmpdir);\n-        dir += L\"Update-\";\n-\n         UUID uuid;\n         UuidCreate(&uuid);\n         RPC_WSTR uuidStr;",
        "diff_line_info": {
            "deleted_lines": [
                "    wchar_t tmpdir[MAX_PATH+1];",
                "    if ( GetTempPath(MAX_PATH+1, tmpdir) == 0 )",
                "        throw Win32Exception(\"Cannot create temporary directory\");",
                "        dir += L\"Update-\";",
                ""
            ],
            "added_lines": [
                "    const std::wstring tmpdir = GetUniqueTempDirectoryPrefix();"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-7838",
        "func_name": "vslavik/winsparkle/UpdateDownloader::CleanLeftovers",
        "description": "Untrusted search path vulnerability in WinSparkle versions prior to 0.5.3 allows remote attackers to execute arbitrary code via a specially crafted executable file in an unspecified directory.",
        "git_url": "https://github.com/vslavik/winsparkle/commit/bb454857348245a7397f9e4fbb3a902f4ac25913",
        "commit_title": "Verify UpdateTempDir isn't maliciously modified",
        "commit_text": " Don't just delete the stored updates temporary directory on launch, but validate the registry key to ensure it is in an expected location and follows WinSparkle's naming convention. This is to prevent malicious users from modifying this registry key and forcing the host app to delete arbitrary directories (a user being able to delete the key would be able to delete the directory themselves, so it's not a serious issue, but it nevertheless is bad behavior and shouldn't be possible).",
        "func_before": "void UpdateDownloader::CleanLeftovers()\n{\n    // Note: this is called at startup. Do not use wxWidgets from this code!\n\n    std::wstring tmpdir;\n    if ( !Settings::ReadConfigValue(\"UpdateTempDir\", tmpdir) )\n        return;\n\n    tmpdir.append(1, '\\0'); // double NULL-terminate for SHFileOperation\n\n    SHFILEOPSTRUCT fos = {0};\n    fos.wFunc = FO_DELETE;\n    fos.pFrom = tmpdir.c_str();\n    fos.fFlags = FOF_NO_UI | // Vista+-only\n                 FOF_SILENT |\n                 FOF_NOCONFIRMATION |\n                 FOF_NOERRORUI;\n\n    if ( SHFileOperation(&fos) == 0 )\n    {\n        Settings::DeleteConfigValue(\"UpdateTempDir\");\n    }\n    // else: try another time, this is just a \"soft\" error\n}",
        "func": "void UpdateDownloader::CleanLeftovers()\n{\n    // Note: this is called at startup. Do not use wxWidgets from this code!\n\n    std::wstring tmpdir;\n    if ( !Settings::ReadConfigValue(\"UpdateTempDir\", tmpdir) )\n        return;\n\n    // Check that the directory actually is a valid update temp dir, to prevent\n    // malicious users from forcing us into deleting arbitrary directories:\n    try\n    {\n        if (tmpdir.find(GetUniqueTempDirectoryPrefix()) != 0)\n        {\n            Settings::DeleteConfigValue(\"UpdateTempDir\");\n            return;\n        }\n    }\n    catch (Win32Exception&) // cannot determine temp directory\n    {\n        return;\n    }\n\n    tmpdir.append(1, '\\0'); // double NULL-terminate for SHFileOperation\n\n    SHFILEOPSTRUCT fos = {0};\n    fos.wFunc = FO_DELETE;\n    fos.pFrom = tmpdir.c_str();\n    fos.fFlags = FOF_NO_UI | // Vista+-only\n                 FOF_SILENT |\n                 FOF_NOCONFIRMATION |\n                 FOF_NOERRORUI;\n\n    if ( SHFileOperation(&fos) == 0 )\n    {\n        Settings::DeleteConfigValue(\"UpdateTempDir\");\n    }\n    // else: try another time, this is just a \"soft\" error\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,6 +5,21 @@\n     std::wstring tmpdir;\n     if ( !Settings::ReadConfigValue(\"UpdateTempDir\", tmpdir) )\n         return;\n+\n+    // Check that the directory actually is a valid update temp dir, to prevent\n+    // malicious users from forcing us into deleting arbitrary directories:\n+    try\n+    {\n+        if (tmpdir.find(GetUniqueTempDirectoryPrefix()) != 0)\n+        {\n+            Settings::DeleteConfigValue(\"UpdateTempDir\");\n+            return;\n+        }\n+    }\n+    catch (Win32Exception&) // cannot determine temp directory\n+    {\n+        return;\n+    }\n \n     tmpdir.append(1, '\\0'); // double NULL-terminate for SHFileOperation\n ",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "    // Check that the directory actually is a valid update temp dir, to prevent",
                "    // malicious users from forcing us into deleting arbitrary directories:",
                "    try",
                "    {",
                "        if (tmpdir.find(GetUniqueTempDirectoryPrefix()) != 0)",
                "        {",
                "            Settings::DeleteConfigValue(\"UpdateTempDir\");",
                "            return;",
                "        }",
                "    }",
                "    catch (Win32Exception&) // cannot determine temp directory",
                "    {",
                "        return;",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-19486",
        "func_name": "git/start_command",
        "description": "Git before 2.19.2 on Linux and UNIX executes commands from the current working directory (as if '.' were at the end of $PATH) in certain cases involving the run_command() API and run-command.c, because there was a dangerous change from execvp to execv during 2017.",
        "git_url": "https://git.kernel.org/pub/scm/git/git.git/commit/?h=321fd82389742398d2924640ce3a61791fd27d60",
        "commit_title": "Since commit e3a434468f (run-command: use the",
        "commit_text": "async-signal-safe execv instead of execvp, 2017-04-19), prepare_cmd() does its own PATH lookup for any commands we run (on non-Windows platforms).  However, its logic does not match the old execvp call when we fail to find a matching entry in the PATH. Instead of feeding the name directly to execv, execvp would consider that an ENOENT error. By continuing and passing the name directly to execv, we effectively behave as if \".\" was included at the end of the PATH. This can have confusing and even dangerous results.  The fix itself is pretty straight-forward. There's a new test in t0061 to cover this explicitly, and I've also added a duplicate of the ENOENT test to ensure that we return the correct errno for this case.  ",
        "func_before": "int start_command(struct child_process *cmd)\n{\n\tint need_in, need_out, need_err;\n\tint fdin[2], fdout[2], fderr[2];\n\tint failed_errno;\n\tchar *str;\n\n\tif (!cmd->argv)\n\t\tcmd->argv = cmd->args.argv;\n\tif (!cmd->env)\n\t\tcmd->env = cmd->env_array.argv;\n\n\t/*\n\t * In case of errors we must keep the promise to close FDs\n\t * that have been passed in via ->in and ->out.\n\t */\n\n\tneed_in = !cmd->no_stdin && cmd->in < 0;\n\tif (need_in) {\n\t\tif (pipe(fdin) < 0) {\n\t\t\tfailed_errno = errno;\n\t\t\tif (cmd->out > 0)\n\t\t\t\tclose(cmd->out);\n\t\t\tstr = \"standard input\";\n\t\t\tgoto fail_pipe;\n\t\t}\n\t\tcmd->in = fdin[1];\n\t}\n\n\tneed_out = !cmd->no_stdout\n\t\t&& !cmd->stdout_to_stderr\n\t\t&& cmd->out < 0;\n\tif (need_out) {\n\t\tif (pipe(fdout) < 0) {\n\t\t\tfailed_errno = errno;\n\t\t\tif (need_in)\n\t\t\t\tclose_pair(fdin);\n\t\t\telse if (cmd->in)\n\t\t\t\tclose(cmd->in);\n\t\t\tstr = \"standard output\";\n\t\t\tgoto fail_pipe;\n\t\t}\n\t\tcmd->out = fdout[0];\n\t}\n\n\tneed_err = !cmd->no_stderr && cmd->err < 0;\n\tif (need_err) {\n\t\tif (pipe(fderr) < 0) {\n\t\t\tfailed_errno = errno;\n\t\t\tif (need_in)\n\t\t\t\tclose_pair(fdin);\n\t\t\telse if (cmd->in)\n\t\t\t\tclose(cmd->in);\n\t\t\tif (need_out)\n\t\t\t\tclose_pair(fdout);\n\t\t\telse if (cmd->out)\n\t\t\t\tclose(cmd->out);\n\t\t\tstr = \"standard error\";\nfail_pipe:\n\t\t\terror(\"cannot create %s pipe for %s: %s\",\n\t\t\t\tstr, cmd->argv[0], strerror(failed_errno));\n\t\t\tchild_process_clear(cmd);\n\t\t\terrno = failed_errno;\n\t\t\treturn -1;\n\t\t}\n\t\tcmd->err = fderr[0];\n\t}\n\n\ttrace_argv_printf(cmd->argv, \"trace: run_command:\");\n\tfflush(NULL);\n\n#ifndef GIT_WINDOWS_NATIVE\n{\n\tint notify_pipe[2];\n\tint null_fd = -1;\n\tchar **childenv;\n\tstruct argv_array argv = ARGV_ARRAY_INIT;\n\tstruct child_err cerr;\n\tstruct atfork_state as;\n\n\tif (pipe(notify_pipe))\n\t\tnotify_pipe[0] = notify_pipe[1] = -1;\n\n\tif (cmd->no_stdin || cmd->no_stdout || cmd->no_stderr) {\n\t\tnull_fd = open(\"/dev/null\", O_RDWR | O_CLOEXEC);\n\t\tif (null_fd < 0)\n\t\t\tdie_errno(_(\"open /dev/null failed\"));\n\t\tset_cloexec(null_fd);\n\t}\n\n\tprepare_cmd(&argv, cmd);\n\tchildenv = prep_childenv(cmd->env);\n\tatfork_prepare(&as);\n\n\t/*\n\t * NOTE: In order to prevent deadlocking when using threads special\n\t * care should be taken with the function calls made in between the\n\t * fork() and exec() calls.  No calls should be made to functions which\n\t * require acquiring a lock (e.g. malloc) as the lock could have been\n\t * held by another thread at the time of forking, causing the lock to\n\t * never be released in the child process.  This means only\n\t * Async-Signal-Safe functions are permitted in the child.\n\t */\n\tcmd->pid = fork();\n\tfailed_errno = errno;\n\tif (!cmd->pid) {\n\t\tint sig;\n\t\t/*\n\t\t * Ensure the default die/error/warn routines do not get\n\t\t * called, they can take stdio locks and malloc.\n\t\t */\n\t\tset_die_routine(child_die_fn);\n\t\tset_error_routine(child_error_fn);\n\t\tset_warn_routine(child_warn_fn);\n\n\t\tclose(notify_pipe[0]);\n\t\tset_cloexec(notify_pipe[1]);\n\t\tchild_notifier = notify_pipe[1];\n\n\t\tif (cmd->no_stdin)\n\t\t\tchild_dup2(null_fd, 0);\n\t\telse if (need_in) {\n\t\t\tchild_dup2(fdin[0], 0);\n\t\t\tchild_close_pair(fdin);\n\t\t} else if (cmd->in) {\n\t\t\tchild_dup2(cmd->in, 0);\n\t\t\tchild_close(cmd->in);\n\t\t}\n\n\t\tif (cmd->no_stderr)\n\t\t\tchild_dup2(null_fd, 2);\n\t\telse if (need_err) {\n\t\t\tchild_dup2(fderr[1], 2);\n\t\t\tchild_close_pair(fderr);\n\t\t} else if (cmd->err > 1) {\n\t\t\tchild_dup2(cmd->err, 2);\n\t\t\tchild_close(cmd->err);\n\t\t}\n\n\t\tif (cmd->no_stdout)\n\t\t\tchild_dup2(null_fd, 1);\n\t\telse if (cmd->stdout_to_stderr)\n\t\t\tchild_dup2(2, 1);\n\t\telse if (need_out) {\n\t\t\tchild_dup2(fdout[1], 1);\n\t\t\tchild_close_pair(fdout);\n\t\t} else if (cmd->out > 1) {\n\t\t\tchild_dup2(cmd->out, 1);\n\t\t\tchild_close(cmd->out);\n\t\t}\n\n\t\tif (cmd->dir && chdir(cmd->dir))\n\t\t\tchild_die(CHILD_ERR_CHDIR);\n\n\t\t/*\n\t\t * restore default signal handlers here, in case\n\t\t * we catch a signal right before execve below\n\t\t */\n\t\tfor (sig = 1; sig < NSIG; sig++) {\n\t\t\t/* ignored signals get reset to SIG_DFL on execve */\n\t\t\tif (signal(sig, SIG_DFL) == SIG_IGN)\n\t\t\t\tsignal(sig, SIG_IGN);\n\t\t}\n\n\t\tif (sigprocmask(SIG_SETMASK, &as.old, NULL) != 0)\n\t\t\tchild_die(CHILD_ERR_SIGPROCMASK);\n\n\t\t/*\n\t\t * Attempt to exec using the command and arguments starting at\n\t\t * argv.argv[1].  argv.argv[0] contains SHELL_PATH which will\n\t\t * be used in the event exec failed with ENOEXEC at which point\n\t\t * we will try to interpret the command using 'sh'.\n\t\t */\n\t\texecve(argv.argv[1], (char *const *) argv.argv + 1,\n\t\t       (char *const *) childenv);\n\t\tif (errno == ENOEXEC)\n\t\t\texecve(argv.argv[0], (char *const *) argv.argv,\n\t\t\t       (char *const *) childenv);\n\n\t\tif (errno == ENOENT) {\n\t\t\tif (cmd->silent_exec_failure)\n\t\t\t\tchild_die(CHILD_ERR_SILENT);\n\t\t\tchild_die(CHILD_ERR_ENOENT);\n\t\t} else {\n\t\t\tchild_die(CHILD_ERR_ERRNO);\n\t\t}\n\t}\n\tatfork_parent(&as);\n\tif (cmd->pid < 0)\n\t\terror_errno(\"cannot fork() for %s\", cmd->argv[0]);\n\telse if (cmd->clean_on_exit)\n\t\tmark_child_for_cleanup(cmd->pid, cmd);\n\n\t/*\n\t * Wait for child's exec. If the exec succeeds (or if fork()\n\t * failed), EOF is seen immediately by the parent. Otherwise, the\n\t * child process sends a child_err struct.\n\t * Note that use of this infrastructure is completely advisory,\n\t * therefore, we keep error checks minimal.\n\t */\n\tclose(notify_pipe[1]);\n\tif (xread(notify_pipe[0], &cerr, sizeof(cerr)) == sizeof(cerr)) {\n\t\t/*\n\t\t * At this point we know that fork() succeeded, but exec()\n\t\t * failed. Errors have been reported to our stderr.\n\t\t */\n\t\twait_or_whine(cmd->pid, cmd->argv[0], 0);\n\t\tchild_err_spew(cmd, &cerr);\n\t\tfailed_errno = errno;\n\t\tcmd->pid = -1;\n\t}\n\tclose(notify_pipe[0]);\n\n\tif (null_fd >= 0)\n\t\tclose(null_fd);\n\targv_array_clear(&argv);\n\tfree(childenv);\n}\n#else\n{\n\tint fhin = 0, fhout = 1, fherr = 2;\n\tconst char **sargv = cmd->argv;\n\tstruct argv_array nargv = ARGV_ARRAY_INIT;\n\n\tif (cmd->no_stdin)\n\t\tfhin = open(\"/dev/null\", O_RDWR);\n\telse if (need_in)\n\t\tfhin = dup(fdin[0]);\n\telse if (cmd->in)\n\t\tfhin = dup(cmd->in);\n\n\tif (cmd->no_stderr)\n\t\tfherr = open(\"/dev/null\", O_RDWR);\n\telse if (need_err)\n\t\tfherr = dup(fderr[1]);\n\telse if (cmd->err > 2)\n\t\tfherr = dup(cmd->err);\n\n\tif (cmd->no_stdout)\n\t\tfhout = open(\"/dev/null\", O_RDWR);\n\telse if (cmd->stdout_to_stderr)\n\t\tfhout = dup(fherr);\n\telse if (need_out)\n\t\tfhout = dup(fdout[1]);\n\telse if (cmd->out > 1)\n\t\tfhout = dup(cmd->out);\n\n\tif (cmd->git_cmd)\n\t\tcmd->argv = prepare_git_cmd(&nargv, cmd->argv);\n\telse if (cmd->use_shell)\n\t\tcmd->argv = prepare_shell_cmd(&nargv, cmd->argv);\n\n\tcmd->pid = mingw_spawnvpe(cmd->argv[0], cmd->argv, (char**) cmd->env,\n\t\t\tcmd->dir, fhin, fhout, fherr);\n\tfailed_errno = errno;\n\tif (cmd->pid < 0 && (!cmd->silent_exec_failure || errno != ENOENT))\n\t\terror_errno(\"cannot spawn %s\", cmd->argv[0]);\n\tif (cmd->clean_on_exit && cmd->pid >= 0)\n\t\tmark_child_for_cleanup(cmd->pid, cmd);\n\n\targv_array_clear(&nargv);\n\tcmd->argv = sargv;\n\tif (fhin != 0)\n\t\tclose(fhin);\n\tif (fhout != 1)\n\t\tclose(fhout);\n\tif (fherr != 2)\n\t\tclose(fherr);\n}\n#endif\n\n\tif (cmd->pid < 0) {\n\t\tif (need_in)\n\t\t\tclose_pair(fdin);\n\t\telse if (cmd->in)\n\t\t\tclose(cmd->in);\n\t\tif (need_out)\n\t\t\tclose_pair(fdout);\n\t\telse if (cmd->out)\n\t\t\tclose(cmd->out);\n\t\tif (need_err)\n\t\t\tclose_pair(fderr);\n\t\telse if (cmd->err)\n\t\t\tclose(cmd->err);\n\t\tchild_process_clear(cmd);\n\t\terrno = failed_errno;\n\t\treturn -1;\n\t}\n\n\tif (need_in)\n\t\tclose(fdin[0]);\n\telse if (cmd->in)\n\t\tclose(cmd->in);\n\n\tif (need_out)\n\t\tclose(fdout[1]);\n\telse if (cmd->out)\n\t\tclose(cmd->out);\n\n\tif (need_err)\n\t\tclose(fderr[1]);\n\telse if (cmd->err)\n\t\tclose(cmd->err);\n\n\treturn 0;\n}",
        "func": "int start_command(struct child_process *cmd)\n{\n\tint need_in, need_out, need_err;\n\tint fdin[2], fdout[2], fderr[2];\n\tint failed_errno;\n\tchar *str;\n\n\tif (!cmd->argv)\n\t\tcmd->argv = cmd->args.argv;\n\tif (!cmd->env)\n\t\tcmd->env = cmd->env_array.argv;\n\n\t/*\n\t * In case of errors we must keep the promise to close FDs\n\t * that have been passed in via ->in and ->out.\n\t */\n\n\tneed_in = !cmd->no_stdin && cmd->in < 0;\n\tif (need_in) {\n\t\tif (pipe(fdin) < 0) {\n\t\t\tfailed_errno = errno;\n\t\t\tif (cmd->out > 0)\n\t\t\t\tclose(cmd->out);\n\t\t\tstr = \"standard input\";\n\t\t\tgoto fail_pipe;\n\t\t}\n\t\tcmd->in = fdin[1];\n\t}\n\n\tneed_out = !cmd->no_stdout\n\t\t&& !cmd->stdout_to_stderr\n\t\t&& cmd->out < 0;\n\tif (need_out) {\n\t\tif (pipe(fdout) < 0) {\n\t\t\tfailed_errno = errno;\n\t\t\tif (need_in)\n\t\t\t\tclose_pair(fdin);\n\t\t\telse if (cmd->in)\n\t\t\t\tclose(cmd->in);\n\t\t\tstr = \"standard output\";\n\t\t\tgoto fail_pipe;\n\t\t}\n\t\tcmd->out = fdout[0];\n\t}\n\n\tneed_err = !cmd->no_stderr && cmd->err < 0;\n\tif (need_err) {\n\t\tif (pipe(fderr) < 0) {\n\t\t\tfailed_errno = errno;\n\t\t\tif (need_in)\n\t\t\t\tclose_pair(fdin);\n\t\t\telse if (cmd->in)\n\t\t\t\tclose(cmd->in);\n\t\t\tif (need_out)\n\t\t\t\tclose_pair(fdout);\n\t\t\telse if (cmd->out)\n\t\t\t\tclose(cmd->out);\n\t\t\tstr = \"standard error\";\nfail_pipe:\n\t\t\terror(\"cannot create %s pipe for %s: %s\",\n\t\t\t\tstr, cmd->argv[0], strerror(failed_errno));\n\t\t\tchild_process_clear(cmd);\n\t\t\terrno = failed_errno;\n\t\t\treturn -1;\n\t\t}\n\t\tcmd->err = fderr[0];\n\t}\n\n\ttrace_argv_printf(cmd->argv, \"trace: run_command:\");\n\tfflush(NULL);\n\n#ifndef GIT_WINDOWS_NATIVE\n{\n\tint notify_pipe[2];\n\tint null_fd = -1;\n\tchar **childenv;\n\tstruct argv_array argv = ARGV_ARRAY_INIT;\n\tstruct child_err cerr;\n\tstruct atfork_state as;\n\n\tif (prepare_cmd(&argv, cmd) < 0) {\n\t\tfailed_errno = errno;\n\t\tcmd->pid = -1;\n\t\tgoto end_of_spawn;\n\t}\n\n\tif (pipe(notify_pipe))\n\t\tnotify_pipe[0] = notify_pipe[1] = -1;\n\n\tif (cmd->no_stdin || cmd->no_stdout || cmd->no_stderr) {\n\t\tnull_fd = open(\"/dev/null\", O_RDWR | O_CLOEXEC);\n\t\tif (null_fd < 0)\n\t\t\tdie_errno(_(\"open /dev/null failed\"));\n\t\tset_cloexec(null_fd);\n\t}\n\n\tchildenv = prep_childenv(cmd->env);\n\tatfork_prepare(&as);\n\n\t/*\n\t * NOTE: In order to prevent deadlocking when using threads special\n\t * care should be taken with the function calls made in between the\n\t * fork() and exec() calls.  No calls should be made to functions which\n\t * require acquiring a lock (e.g. malloc) as the lock could have been\n\t * held by another thread at the time of forking, causing the lock to\n\t * never be released in the child process.  This means only\n\t * Async-Signal-Safe functions are permitted in the child.\n\t */\n\tcmd->pid = fork();\n\tfailed_errno = errno;\n\tif (!cmd->pid) {\n\t\tint sig;\n\t\t/*\n\t\t * Ensure the default die/error/warn routines do not get\n\t\t * called, they can take stdio locks and malloc.\n\t\t */\n\t\tset_die_routine(child_die_fn);\n\t\tset_error_routine(child_error_fn);\n\t\tset_warn_routine(child_warn_fn);\n\n\t\tclose(notify_pipe[0]);\n\t\tset_cloexec(notify_pipe[1]);\n\t\tchild_notifier = notify_pipe[1];\n\n\t\tif (cmd->no_stdin)\n\t\t\tchild_dup2(null_fd, 0);\n\t\telse if (need_in) {\n\t\t\tchild_dup2(fdin[0], 0);\n\t\t\tchild_close_pair(fdin);\n\t\t} else if (cmd->in) {\n\t\t\tchild_dup2(cmd->in, 0);\n\t\t\tchild_close(cmd->in);\n\t\t}\n\n\t\tif (cmd->no_stderr)\n\t\t\tchild_dup2(null_fd, 2);\n\t\telse if (need_err) {\n\t\t\tchild_dup2(fderr[1], 2);\n\t\t\tchild_close_pair(fderr);\n\t\t} else if (cmd->err > 1) {\n\t\t\tchild_dup2(cmd->err, 2);\n\t\t\tchild_close(cmd->err);\n\t\t}\n\n\t\tif (cmd->no_stdout)\n\t\t\tchild_dup2(null_fd, 1);\n\t\telse if (cmd->stdout_to_stderr)\n\t\t\tchild_dup2(2, 1);\n\t\telse if (need_out) {\n\t\t\tchild_dup2(fdout[1], 1);\n\t\t\tchild_close_pair(fdout);\n\t\t} else if (cmd->out > 1) {\n\t\t\tchild_dup2(cmd->out, 1);\n\t\t\tchild_close(cmd->out);\n\t\t}\n\n\t\tif (cmd->dir && chdir(cmd->dir))\n\t\t\tchild_die(CHILD_ERR_CHDIR);\n\n\t\t/*\n\t\t * restore default signal handlers here, in case\n\t\t * we catch a signal right before execve below\n\t\t */\n\t\tfor (sig = 1; sig < NSIG; sig++) {\n\t\t\t/* ignored signals get reset to SIG_DFL on execve */\n\t\t\tif (signal(sig, SIG_DFL) == SIG_IGN)\n\t\t\t\tsignal(sig, SIG_IGN);\n\t\t}\n\n\t\tif (sigprocmask(SIG_SETMASK, &as.old, NULL) != 0)\n\t\t\tchild_die(CHILD_ERR_SIGPROCMASK);\n\n\t\t/*\n\t\t * Attempt to exec using the command and arguments starting at\n\t\t * argv.argv[1].  argv.argv[0] contains SHELL_PATH which will\n\t\t * be used in the event exec failed with ENOEXEC at which point\n\t\t * we will try to interpret the command using 'sh'.\n\t\t */\n\t\texecve(argv.argv[1], (char *const *) argv.argv + 1,\n\t\t       (char *const *) childenv);\n\t\tif (errno == ENOEXEC)\n\t\t\texecve(argv.argv[0], (char *const *) argv.argv,\n\t\t\t       (char *const *) childenv);\n\n\t\tif (errno == ENOENT) {\n\t\t\tif (cmd->silent_exec_failure)\n\t\t\t\tchild_die(CHILD_ERR_SILENT);\n\t\t\tchild_die(CHILD_ERR_ENOENT);\n\t\t} else {\n\t\t\tchild_die(CHILD_ERR_ERRNO);\n\t\t}\n\t}\n\tatfork_parent(&as);\n\tif (cmd->pid < 0)\n\t\terror_errno(\"cannot fork() for %s\", cmd->argv[0]);\n\telse if (cmd->clean_on_exit)\n\t\tmark_child_for_cleanup(cmd->pid, cmd);\n\n\t/*\n\t * Wait for child's exec. If the exec succeeds (or if fork()\n\t * failed), EOF is seen immediately by the parent. Otherwise, the\n\t * child process sends a child_err struct.\n\t * Note that use of this infrastructure is completely advisory,\n\t * therefore, we keep error checks minimal.\n\t */\n\tclose(notify_pipe[1]);\n\tif (xread(notify_pipe[0], &cerr, sizeof(cerr)) == sizeof(cerr)) {\n\t\t/*\n\t\t * At this point we know that fork() succeeded, but exec()\n\t\t * failed. Errors have been reported to our stderr.\n\t\t */\n\t\twait_or_whine(cmd->pid, cmd->argv[0], 0);\n\t\tchild_err_spew(cmd, &cerr);\n\t\tfailed_errno = errno;\n\t\tcmd->pid = -1;\n\t}\n\tclose(notify_pipe[0]);\n\n\tif (null_fd >= 0)\n\t\tclose(null_fd);\n\targv_array_clear(&argv);\n\tfree(childenv);\n}\nend_of_spawn:\n\n#else\n{\n\tint fhin = 0, fhout = 1, fherr = 2;\n\tconst char **sargv = cmd->argv;\n\tstruct argv_array nargv = ARGV_ARRAY_INIT;\n\n\tif (cmd->no_stdin)\n\t\tfhin = open(\"/dev/null\", O_RDWR);\n\telse if (need_in)\n\t\tfhin = dup(fdin[0]);\n\telse if (cmd->in)\n\t\tfhin = dup(cmd->in);\n\n\tif (cmd->no_stderr)\n\t\tfherr = open(\"/dev/null\", O_RDWR);\n\telse if (need_err)\n\t\tfherr = dup(fderr[1]);\n\telse if (cmd->err > 2)\n\t\tfherr = dup(cmd->err);\n\n\tif (cmd->no_stdout)\n\t\tfhout = open(\"/dev/null\", O_RDWR);\n\telse if (cmd->stdout_to_stderr)\n\t\tfhout = dup(fherr);\n\telse if (need_out)\n\t\tfhout = dup(fdout[1]);\n\telse if (cmd->out > 1)\n\t\tfhout = dup(cmd->out);\n\n\tif (cmd->git_cmd)\n\t\tcmd->argv = prepare_git_cmd(&nargv, cmd->argv);\n\telse if (cmd->use_shell)\n\t\tcmd->argv = prepare_shell_cmd(&nargv, cmd->argv);\n\n\tcmd->pid = mingw_spawnvpe(cmd->argv[0], cmd->argv, (char**) cmd->env,\n\t\t\tcmd->dir, fhin, fhout, fherr);\n\tfailed_errno = errno;\n\tif (cmd->pid < 0 && (!cmd->silent_exec_failure || errno != ENOENT))\n\t\terror_errno(\"cannot spawn %s\", cmd->argv[0]);\n\tif (cmd->clean_on_exit && cmd->pid >= 0)\n\t\tmark_child_for_cleanup(cmd->pid, cmd);\n\n\targv_array_clear(&nargv);\n\tcmd->argv = sargv;\n\tif (fhin != 0)\n\t\tclose(fhin);\n\tif (fhout != 1)\n\t\tclose(fhout);\n\tif (fherr != 2)\n\t\tclose(fherr);\n}\n#endif\n\n\tif (cmd->pid < 0) {\n\t\tif (need_in)\n\t\t\tclose_pair(fdin);\n\t\telse if (cmd->in)\n\t\t\tclose(cmd->in);\n\t\tif (need_out)\n\t\t\tclose_pair(fdout);\n\t\telse if (cmd->out)\n\t\t\tclose(cmd->out);\n\t\tif (need_err)\n\t\t\tclose_pair(fderr);\n\t\telse if (cmd->err)\n\t\t\tclose(cmd->err);\n\t\tchild_process_clear(cmd);\n\t\terrno = failed_errno;\n\t\treturn -1;\n\t}\n\n\tif (need_in)\n\t\tclose(fdin[0]);\n\telse if (cmd->in)\n\t\tclose(cmd->in);\n\n\tif (need_out)\n\t\tclose(fdout[1]);\n\telse if (cmd->out)\n\t\tclose(cmd->out);\n\n\tif (need_err)\n\t\tclose(fderr[1]);\n\telse if (cmd->err)\n\t\tclose(cmd->err);\n\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -78,6 +78,12 @@\n \tstruct child_err cerr;\n \tstruct atfork_state as;\n \n+\tif (prepare_cmd(&argv, cmd) < 0) {\n+\t\tfailed_errno = errno;\n+\t\tcmd->pid = -1;\n+\t\tgoto end_of_spawn;\n+\t}\n+\n \tif (pipe(notify_pipe))\n \t\tnotify_pipe[0] = notify_pipe[1] = -1;\n \n@@ -88,7 +94,6 @@\n \t\tset_cloexec(null_fd);\n \t}\n \n-\tprepare_cmd(&argv, cmd);\n \tchildenv = prep_childenv(cmd->env);\n \tatfork_prepare(&as);\n \n@@ -216,6 +221,8 @@\n \targv_array_clear(&argv);\n \tfree(childenv);\n }\n+end_of_spawn:\n+\n #else\n {\n \tint fhin = 0, fhout = 1, fherr = 2;",
        "diff_line_info": {
            "deleted_lines": [
                "\tprepare_cmd(&argv, cmd);"
            ],
            "added_lines": [
                "\tif (prepare_cmd(&argv, cmd) < 0) {",
                "\t\tfailed_errno = errno;",
                "\t\tcmd->pid = -1;",
                "\t\tgoto end_of_spawn;",
                "\t}",
                "",
                "end_of_spawn:",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2018-19486",
        "func_name": "git/prepare_cmd",
        "description": "Git before 2.19.2 on Linux and UNIX executes commands from the current working directory (as if '.' were at the end of $PATH) in certain cases involving the run_command() API and run-command.c, because there was a dangerous change from execvp to execv during 2017.",
        "git_url": "https://git.kernel.org/pub/scm/git/git.git/commit/?h=321fd82389742398d2924640ce3a61791fd27d60",
        "commit_title": "Since commit e3a434468f (run-command: use the",
        "commit_text": "async-signal-safe execv instead of execvp, 2017-04-19), prepare_cmd() does its own PATH lookup for any commands we run (on non-Windows platforms).  However, its logic does not match the old execvp call when we fail to find a matching entry in the PATH. Instead of feeding the name directly to execv, execvp would consider that an ENOENT error. By continuing and passing the name directly to execv, we effectively behave as if \".\" was included at the end of the PATH. This can have confusing and even dangerous results.  The fix itself is pretty straight-forward. There's a new test in t0061 to cover this explicitly, and I've also added a duplicate of the ENOENT test to ensure that we return the correct errno for this case.  ",
        "func_before": "static void prepare_cmd(struct argv_array *out, const struct child_process *cmd)\n{\n\tif (!cmd->argv[0])\n\t\tdie(\"BUG: command is empty\");\n\n\t/*\n\t * Add SHELL_PATH so in the event exec fails with ENOEXEC we can\n\t * attempt to interpret the command with 'sh'.\n\t */\n\targv_array_push(out, SHELL_PATH);\n\n\tif (cmd->git_cmd) {\n\t\targv_array_push(out, \"git\");\n\t\targv_array_pushv(out, cmd->argv);\n\t} else if (cmd->use_shell) {\n\t\tprepare_shell_cmd(out, cmd->argv);\n\t} else {\n\t\targv_array_pushv(out, cmd->argv);\n\t}\n\n\t/*\n\t * If there are no '/' characters in the command then perform a path\n\t * lookup and use the resolved path as the command to exec.  If there\n\t * are no '/' characters or if the command wasn't found in the path,\n\t * have exec attempt to invoke the command directly.\n\t */\n\tif (!strchr(out->argv[1], '/')) {\n\t\tchar *program = locate_in_PATH(out->argv[1]);\n\t\tif (program) {\n\t\t\tfree((char *)out->argv[1]);\n\t\t\tout->argv[1] = program;\n\t\t}\n\t}\n}",
        "func": "static int prepare_cmd(struct argv_array *out, const struct child_process *cmd)\n{\n\tif (!cmd->argv[0])\n\t\tdie(\"BUG: command is empty\");\n\n\t/*\n\t * Add SHELL_PATH so in the event exec fails with ENOEXEC we can\n\t * attempt to interpret the command with 'sh'.\n\t */\n\targv_array_push(out, SHELL_PATH);\n\n\tif (cmd->git_cmd) {\n\t\targv_array_push(out, \"git\");\n\t\targv_array_pushv(out, cmd->argv);\n\t} else if (cmd->use_shell) {\n\t\tprepare_shell_cmd(out, cmd->argv);\n\t} else {\n\t\targv_array_pushv(out, cmd->argv);\n\t}\n\n\t/*\n\t * If there are no '/' characters in the command then perform a path\n\t * lookup and use the resolved path as the command to exec.  If there\n\t * are '/' characters, we have exec attempt to invoke the command\n\t * directly.\n\t */\n\tif (!strchr(out->argv[1], '/')) {\n\t\tchar *program = locate_in_PATH(out->argv[1]);\n\t\tif (program) {\n\t\t\tfree((char *)out->argv[1]);\n\t\t\tout->argv[1] = program;\n\t\t} else {\n\t\t\targv_array_clear(out);\n\t\t\terrno = ENOENT;\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,4 @@\n-static void prepare_cmd(struct argv_array *out, const struct child_process *cmd)\n+static int prepare_cmd(struct argv_array *out, const struct child_process *cmd)\n {\n \tif (!cmd->argv[0])\n \t\tdie(\"BUG: command is empty\");\n@@ -21,14 +21,20 @@\n \t/*\n \t * If there are no '/' characters in the command then perform a path\n \t * lookup and use the resolved path as the command to exec.  If there\n-\t * are no '/' characters or if the command wasn't found in the path,\n-\t * have exec attempt to invoke the command directly.\n+\t * are '/' characters, we have exec attempt to invoke the command\n+\t * directly.\n \t */\n \tif (!strchr(out->argv[1], '/')) {\n \t\tchar *program = locate_in_PATH(out->argv[1]);\n \t\tif (program) {\n \t\t\tfree((char *)out->argv[1]);\n \t\t\tout->argv[1] = program;\n+\t\t} else {\n+\t\t\targv_array_clear(out);\n+\t\t\terrno = ENOENT;\n+\t\t\treturn -1;\n \t\t}\n \t}\n+\n+\treturn 0;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "static void prepare_cmd(struct argv_array *out, const struct child_process *cmd)",
                "\t * are no '/' characters or if the command wasn't found in the path,",
                "\t * have exec attempt to invoke the command directly."
            ],
            "added_lines": [
                "static int prepare_cmd(struct argv_array *out, const struct child_process *cmd)",
                "\t * are '/' characters, we have exec attempt to invoke the command",
                "\t * directly.",
                "\t\t} else {",
                "\t\t\targv_array_clear(out);",
                "\t\t\terrno = ENOENT;",
                "\t\t\treturn -1;",
                "",
                "\treturn 0;"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-11742",
        "func_name": "libexpat/writeRandomBytes_RtlGenRandom",
        "description": "The writeRandomBytes_RtlGenRandom function in xmlparse.c in libexpat in Expat 2.2.1 and 2.2.2 on Windows allows local users to gain privileges via a Trojan horse ADVAPI32.DLL in the current working directory because of an untrusted search path, aka DLL hijacking.",
        "git_url": "https://github.com/libexpat/libexpat/commit/99fb4b57f8d951c5f143f7873749eaf71ae5895e",
        "commit_title": "xmlparse.c: Fix DLL hijacking vulnerability (#82)",
        "commit_text": "",
        "func_before": "static int\nwriteRandomBytes_RtlGenRandom(void * target, size_t count) {\n  int success = 0;  /* full count bytes written? */\n  const HMODULE advapi32 = LoadLibrary(TEXT(\"ADVAPI32.DLL\"));\n\n  if (advapi32) {\n    const RTLGENRANDOM_FUNC RtlGenRandom\n        = (RTLGENRANDOM_FUNC)GetProcAddress(advapi32, \"SystemFunction036\");\n    if (RtlGenRandom) {\n      if (RtlGenRandom((PVOID)target, (ULONG)count) == TRUE) {\n        success = 1;\n      }\n    }\n    FreeLibrary(advapi32);\n  }\n\n  return success;\n}",
        "func": "static int\nwriteRandomBytes_RtlGenRandom(void * target, size_t count) {\n  int success = 0;  /* full count bytes written? */\n  const LPCTSTR file_name = TEXT(\"ADVAPI32.DLL\");\n  HMODULE advapi32 = LoadLibraryEx(file_name, 0, LOAD_LIBRARY_SEARCH_SYSTEM32);\n\n  if (! advapi32) {\n    /* Try again without LOAD_LIBRARY_SEARCH_SYSTEM32 if unsupported */\n    advapi32 = LoadLibraryEx(file_name, 0, 0);\n  }\n\n  if (advapi32) {\n    const RTLGENRANDOM_FUNC RtlGenRandom\n        = (RTLGENRANDOM_FUNC)GetProcAddress(advapi32, \"SystemFunction036\");\n    if (RtlGenRandom) {\n      if (RtlGenRandom((PVOID)target, (ULONG)count) == TRUE) {\n        success = 1;\n      }\n    }\n    FreeLibrary(advapi32);\n  }\n\n  return success;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,7 +1,13 @@\n static int\n writeRandomBytes_RtlGenRandom(void * target, size_t count) {\n   int success = 0;  /* full count bytes written? */\n-  const HMODULE advapi32 = LoadLibrary(TEXT(\"ADVAPI32.DLL\"));\n+  const LPCTSTR file_name = TEXT(\"ADVAPI32.DLL\");\n+  HMODULE advapi32 = LoadLibraryEx(file_name, 0, LOAD_LIBRARY_SEARCH_SYSTEM32);\n+\n+  if (! advapi32) {\n+    /* Try again without LOAD_LIBRARY_SEARCH_SYSTEM32 if unsupported */\n+    advapi32 = LoadLibraryEx(file_name, 0, 0);\n+  }\n \n   if (advapi32) {\n     const RTLGENRANDOM_FUNC RtlGenRandom",
        "diff_line_info": {
            "deleted_lines": [
                "  const HMODULE advapi32 = LoadLibrary(TEXT(\"ADVAPI32.DLL\"));"
            ],
            "added_lines": [
                "  const LPCTSTR file_name = TEXT(\"ADVAPI32.DLL\");",
                "  HMODULE advapi32 = LoadLibraryEx(file_name, 0, LOAD_LIBRARY_SEARCH_SYSTEM32);",
                "",
                "  if (! advapi32) {",
                "    /* Try again without LOAD_LIBRARY_SEARCH_SYSTEM32 if unsupported */",
                "    advapi32 = LoadLibraryEx(file_name, 0, 0);",
                "  }"
            ]
        }
    }
]