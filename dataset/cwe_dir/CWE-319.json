[
    {
        "cve_id": "CVE-2022-39269",
        "func_name": "pjsip/pjproject/srtp_rtp_cb",
        "description": "PJSIP is a free and open source multimedia communication library written in C. When processing certain packets, PJSIP may incorrectly switch from using SRTP media transport to using basic RTP upon SRTP restart, causing the media to be sent insecurely. The vulnerability impacts all PJSIP users that use SRTP. The patch is available as commit d2acb9a in the master branch of the project and will be included in version 2.13. Users are advised to manually patch or to upgrade. There are no known workarounds for this vulnerability.",
        "git_url": "https://github.com/pjsip/pjproject/commit/d2acb9af4e27b5ba75d658690406cec9c274c5cc",
        "commit_title": "Merge pull request from GHSA-wx5m-cj97-4wwg",
        "commit_text": "",
        "func_before": "static void srtp_rtp_cb(pjmedia_tp_cb_param *param)\n{\n    transport_srtp *srtp = (transport_srtp *) param->user_data;\n    void *pkt = param->pkt;\n    pj_ssize_t size = param->size;\n    int len = (int)size;\n    srtp_err_status_t err;\n    void (*cb)(void*, void*, pj_ssize_t) = NULL;\n    void (*cb2)(pjmedia_tp_cb_param*) = NULL;\n    void *cb_data = NULL;\n\n    if (srtp->bypass_srtp) {\n        if (srtp->rtp_cb2) {\n            pjmedia_tp_cb_param param2 = *param;\n            param2.user_data = srtp->user_data;\n            srtp->rtp_cb2(&param2);\n            param->rem_switch = param2.rem_switch;\n        } else if (srtp->rtp_cb) {\n\t    srtp->rtp_cb(srtp->user_data, pkt, size);\n\t}\n\treturn;\n    }\n\n    if (size < 0) {\n\treturn;\n    }\n\n    /* Give the packet to keying first by invoking its send_rtp() op.\n     * Yes, the usage of send_rtp() is rather hacky, but it is convenient\n     * as the signature suits the purpose and it is ready to use\n     * (no futher registration/setting needed), and it may never be used\n     * by any keying method in the future.\n     */\n    {\n\tunsigned i;\n\tpj_status_t status;\n\tfor (i=0; i < srtp->keying_cnt; i++) {\n\t    if (!srtp->keying[i]->op->send_rtp)\n\t\tcontinue;\n\t    status = pjmedia_transport_send_rtp(srtp->keying[i], pkt, size);\n\t    if (status != PJ_EIGNORED) {\n\t\t/* Packet is already consumed by the keying method */\n\t\treturn;\n\t    }\n\t}\n    }\n\n    /* Make sure buffer is 32bit aligned */\n    PJ_ASSERT_ON_FAIL( (((pj_ssize_t)pkt) & 0x03)==0, return );\n\n    if (srtp->probation_cnt > 0)\n\t--srtp->probation_cnt;\n\n    pj_lock_acquire(srtp->mutex);\n\n    if (!srtp->session_inited) {\n\tpj_lock_release(srtp->mutex);\n\treturn;\n    }\n\n    /* Check if multiplexing is allowed and the payload indicates RTCP. */\n    if (srtp->use_rtcp_mux) {\n    \tpjmedia_rtp_hdr *hdr = (pjmedia_rtp_hdr *)pkt;\n  \n\tif (hdr->pt >= 64 && hdr->pt <= 95) {   \n\t    pj_lock_release(srtp->mutex);\n\t    srtp_rtcp_cb(srtp, pkt, size);\n    \t    return;\n    \t}\n    }\n\n#if TEST_ROC\n    if (srtp->setting.rx_roc.ssrc == 0) {\n\tsrtp_err_status_t status;\n\t\n\tsrtp->rx_ssrc = ntohl(((pjmedia_rtp_hdr*)pkt)->ssrc);\n    \tstatus = srtp_set_stream_roc(srtp->srtp_rx_ctx, srtp->rx_ssrc, \n    \t\t\t    \t     (srtp->offerer_side? 2: 1));\n\tif (status == srtp_err_status_ok) {    \t\n    \t    srtp->setting.rx_roc.ssrc = srtp->rx_ssrc;\n\t    srtp->setting.rx_roc.roc = (srtp->offerer_side? 2: 1);\n\n\t    PJ_LOG(4, (THIS_FILE, \"Setting RX ROC from SSRC %d to %d\",\n\t\t   \t\t  srtp->rx_ssrc, srtp->setting.rx_roc.roc));\n\t} else {\n\t    PJ_LOG(4, (THIS_FILE, \"Setting RX ROC %s\",\n\t    \t       get_libsrtp_errstr(status)));\n\t}\n    }\n#endif\n    \n    err = srtp_unprotect(srtp->srtp_rx_ctx, (pj_uint8_t*)pkt, &len);\n\n#if PJMEDIA_SRTP_CHECK_RTP_SEQ_ON_RESTART\n    if (srtp->probation_cnt > 0 &&\n\t(err == srtp_err_status_replay_old ||\n\t err == srtp_err_status_replay_fail))\n    {\n\t/* Handle such condition that stream is updated (RTP seq is reinited\n\t * & SRTP is restarted), but some old packets are still coming\n\t * so SRTP is learning wrong RTP seq. While the newly inited RTP seq\n\t * comes, SRTP thinks the RTP seq is replayed, so srtp_unprotect()\n\t * will return err_status_replay_*. Restarting SRTP can resolve this.\n\t */\n\tpjmedia_srtp_crypto tx, rx;\n\tpj_status_t status;\n\n\t/* Stop SRTP first, otherwise srtp_start() will maintain current\n\t * roll-over counter.\n\t */\n\tpjmedia_transport_srtp_stop((pjmedia_transport*)srtp);\n\n\ttx = srtp->tx_policy;\n\trx = srtp->rx_policy;\n\tstatus = pjmedia_transport_srtp_start((pjmedia_transport*)srtp,\n\t\t\t\t\t      &tx, &rx);\n\tif (status != PJ_SUCCESS) {\n\t    PJ_LOG(5,(srtp->pool->obj_name, \"Failed to restart SRTP, err=%s\",\n\t\t      get_libsrtp_errstr(err)));\n\t} else if (!srtp->bypass_srtp) {\n\t    err = srtp_unprotect(srtp->srtp_rx_ctx, (pj_uint8_t*)pkt, &len);\n\t}\n    }\n#if PJMEDIA_SRTP_CHECK_ROC_ON_RESTART\n    else\n#endif\n#endif\n\n#if PJMEDIA_SRTP_CHECK_ROC_ON_RESTART\n    if (srtp->probation_cnt > 0 && err == srtp_err_status_auth_fail &&\n\tsrtp->setting.prev_rx_roc.ssrc != 0 &&\n\tsrtp->setting.prev_rx_roc.ssrc == srtp->setting.rx_roc.ssrc &&\n\tsrtp->setting.prev_rx_roc.roc != srtp->setting.rx_roc.roc)\n    {\n        unsigned roc, new_roc;\n\tsrtp_err_status_t status;\n\n    \tsrtp_get_stream_roc(srtp->srtp_rx_ctx, srtp->setting.rx_roc.ssrc,\n    \t\t\t    &roc);\n    \tnew_roc = (roc == srtp->setting.rx_roc.roc?\n    \t\t   srtp->setting.prev_rx_roc.roc: srtp->setting.rx_roc.roc);\n    \tstatus = srtp_set_stream_roc(srtp->srtp_rx_ctx,\n    \t\t\t\t     srtp->setting.rx_roc.ssrc, new_roc);\n\tif (status == srtp_err_status_ok) {\n\t    PJ_LOG(4, (srtp->pool->obj_name,\n\t\t       \"Retrying to unprotect SRTP from ROC %d to new ROC %d\",\n\t\t       roc, new_roc));\n    \t    err = srtp_unprotect(srtp->srtp_rx_ctx, (pj_uint8_t*)pkt, &len);\n    \t}\n    }\n#endif\n\n    if (err != srtp_err_status_ok) {\n\tPJ_LOG(5,(srtp->pool->obj_name,\n\t\t  \"Failed to unprotect SRTP, pkt size=%d, err=%s\",\n\t\t  size, get_libsrtp_errstr(err)));\n    } else {\n\tcb = srtp->rtp_cb;\n\tcb2 = srtp->rtp_cb2;\n\tcb_data = srtp->user_data;\n\n\t/* Save SSRC after successful SRTP unprotect */\n\tsrtp->rx_ssrc = ntohl(((pjmedia_rtp_hdr*)pkt)->ssrc);\n    }\n\n    pj_lock_release(srtp->mutex);\n\n    if (cb2) {\n        pjmedia_tp_cb_param param2 = *param;\n        param2.user_data = cb_data;\n        param2.pkt = pkt;\n        param2.size = len;\n        (*cb2)(&param2);\n        param->rem_switch = param2.rem_switch;\n    } else if (cb) {\n\t(*cb)(cb_data, pkt, len);\n    }\n}",
        "func": "static void srtp_rtp_cb(pjmedia_tp_cb_param *param)\n{\n    transport_srtp *srtp = (transport_srtp *) param->user_data;\n    void *pkt = param->pkt;\n    pj_ssize_t size = param->size;\n    int len = (int)size;\n    srtp_err_status_t err;\n    void (*cb)(void*, void*, pj_ssize_t) = NULL;\n    void (*cb2)(pjmedia_tp_cb_param*) = NULL;\n    void *cb_data = NULL;\n\n    if (srtp->bypass_srtp) {\n        if (srtp->rtp_cb2) {\n            pjmedia_tp_cb_param param2 = *param;\n            param2.user_data = srtp->user_data;\n            srtp->rtp_cb2(&param2);\n            param->rem_switch = param2.rem_switch;\n        } else if (srtp->rtp_cb) {\n\t    srtp->rtp_cb(srtp->user_data, pkt, size);\n\t}\n\treturn;\n    }\n\n    if (size < 0) {\n\treturn;\n    }\n\n    /* Give the packet to keying first by invoking its send_rtp() op.\n     * Yes, the usage of send_rtp() is rather hacky, but it is convenient\n     * as the signature suits the purpose and it is ready to use\n     * (no futher registration/setting needed), and it may never be used\n     * by any keying method in the future.\n     */\n    {\n\tunsigned i;\n\tpj_status_t status;\n\tfor (i=0; i < srtp->keying_cnt; i++) {\n\t    if (!srtp->keying[i]->op->send_rtp)\n\t\tcontinue;\n\t    status = pjmedia_transport_send_rtp(srtp->keying[i], pkt, size);\n\t    if (status != PJ_EIGNORED) {\n\t\t/* Packet is already consumed by the keying method */\n\t\treturn;\n\t    }\n\t}\n    }\n\n    /* Make sure buffer is 32bit aligned */\n    PJ_ASSERT_ON_FAIL( (((pj_ssize_t)pkt) & 0x03)==0, return );\n\n    if (srtp->probation_cnt > 0)\n\t--srtp->probation_cnt;\n\n    pj_lock_acquire(srtp->mutex);\n\n    if (!srtp->session_inited) {\n\tpj_lock_release(srtp->mutex);\n\treturn;\n    }\n\n    /* Check if multiplexing is allowed and the payload indicates RTCP. */\n    if (srtp->use_rtcp_mux) {\n    \tpjmedia_rtp_hdr *hdr = (pjmedia_rtp_hdr *)pkt;\n  \n\tif (hdr->pt >= 64 && hdr->pt <= 95) {   \n\t    pj_lock_release(srtp->mutex);\n\t    srtp_rtcp_cb(srtp, pkt, size);\n    \t    return;\n    \t}\n    }\n\n#if TEST_ROC\n    if (srtp->setting.rx_roc.ssrc == 0) {\n\tsrtp_err_status_t status;\n\t\n\tsrtp->rx_ssrc = ntohl(((pjmedia_rtp_hdr*)pkt)->ssrc);\n    \tstatus = srtp_set_stream_roc(srtp->srtp_rx_ctx, srtp->rx_ssrc, \n    \t\t\t    \t     (srtp->offerer_side? 2: 1));\n\tif (status == srtp_err_status_ok) {    \t\n    \t    srtp->setting.rx_roc.ssrc = srtp->rx_ssrc;\n\t    srtp->setting.rx_roc.roc = (srtp->offerer_side? 2: 1);\n\n\t    PJ_LOG(4, (THIS_FILE, \"Setting RX ROC from SSRC %d to %d\",\n\t\t   \t\t  srtp->rx_ssrc, srtp->setting.rx_roc.roc));\n\t} else {\n\t    PJ_LOG(4, (THIS_FILE, \"Setting RX ROC %s\",\n\t    \t       get_libsrtp_errstr(status)));\n\t}\n    }\n#endif\n    \n    err = srtp_unprotect(srtp->srtp_rx_ctx, (pj_uint8_t*)pkt, &len);\n\n#if PJMEDIA_SRTP_CHECK_RTP_SEQ_ON_RESTART\n    if (srtp->probation_cnt > 0 &&\n\t(err == srtp_err_status_replay_old ||\n\t err == srtp_err_status_replay_fail))\n    {\n\t/* Handle such condition that stream is updated (RTP seq is reinited\n\t * & SRTP is restarted), but some old packets are still coming\n\t * so SRTP is learning wrong RTP seq. While the newly inited RTP seq\n\t * comes, SRTP thinks the RTP seq is replayed, so srtp_unprotect()\n\t * will return err_status_replay_*. Restarting SRTP can resolve this.\n\t */\n\tpjmedia_srtp_crypto tx, rx;\n\tpj_status_t status;\n\n\ttx = srtp->tx_policy;\n\trx = srtp->rx_policy;\n\n\t/* Stop SRTP first, otherwise srtp_start() will maintain current\n\t * roll-over counter.\n\t */\n\tpjmedia_transport_srtp_stop((pjmedia_transport*)srtp);\n\n\tstatus = pjmedia_transport_srtp_start((pjmedia_transport*)srtp,\n\t\t\t\t\t      &tx, &rx);\n\tif (status != PJ_SUCCESS) {\n\t    PJ_LOG(5,(srtp->pool->obj_name, \"Failed to restart SRTP, err=%s\",\n\t\t      get_libsrtp_errstr(err)));\n\t} else if (!srtp->bypass_srtp) {\n\t    err = srtp_unprotect(srtp->srtp_rx_ctx, (pj_uint8_t*)pkt, &len);\n\t}\n    }\n#if PJMEDIA_SRTP_CHECK_ROC_ON_RESTART\n    else\n#endif\n#endif\n\n#if PJMEDIA_SRTP_CHECK_ROC_ON_RESTART\n    if (srtp->probation_cnt > 0 && err == srtp_err_status_auth_fail &&\n\tsrtp->setting.prev_rx_roc.ssrc != 0 &&\n\tsrtp->setting.prev_rx_roc.ssrc == srtp->setting.rx_roc.ssrc &&\n\tsrtp->setting.prev_rx_roc.roc != srtp->setting.rx_roc.roc)\n    {\n        unsigned roc, new_roc;\n\tsrtp_err_status_t status;\n\n    \tsrtp_get_stream_roc(srtp->srtp_rx_ctx, srtp->setting.rx_roc.ssrc,\n    \t\t\t    &roc);\n    \tnew_roc = (roc == srtp->setting.rx_roc.roc?\n    \t\t   srtp->setting.prev_rx_roc.roc: srtp->setting.rx_roc.roc);\n    \tstatus = srtp_set_stream_roc(srtp->srtp_rx_ctx,\n    \t\t\t\t     srtp->setting.rx_roc.ssrc, new_roc);\n\tif (status == srtp_err_status_ok) {\n\t    PJ_LOG(4, (srtp->pool->obj_name,\n\t\t       \"Retrying to unprotect SRTP from ROC %d to new ROC %d\",\n\t\t       roc, new_roc));\n    \t    err = srtp_unprotect(srtp->srtp_rx_ctx, (pj_uint8_t*)pkt, &len);\n    \t}\n    }\n#endif\n\n    if (err != srtp_err_status_ok) {\n\tPJ_LOG(5,(srtp->pool->obj_name,\n\t\t  \"Failed to unprotect SRTP, pkt size=%d, err=%s\",\n\t\t  size, get_libsrtp_errstr(err)));\n    } else {\n\tcb = srtp->rtp_cb;\n\tcb2 = srtp->rtp_cb2;\n\tcb_data = srtp->user_data;\n\n\t/* Save SSRC after successful SRTP unprotect */\n\tsrtp->rx_ssrc = ntohl(((pjmedia_rtp_hdr*)pkt)->ssrc);\n    }\n\n    pj_lock_release(srtp->mutex);\n\n    if (cb2) {\n        pjmedia_tp_cb_param param2 = *param;\n        param2.user_data = cb_data;\n        param2.pkt = pkt;\n        param2.size = len;\n        (*cb2)(&param2);\n        param->rem_switch = param2.rem_switch;\n    } else if (cb) {\n\t(*cb)(cb_data, pkt, len);\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -105,13 +105,14 @@\n \tpjmedia_srtp_crypto tx, rx;\n \tpj_status_t status;\n \n+\ttx = srtp->tx_policy;\n+\trx = srtp->rx_policy;\n+\n \t/* Stop SRTP first, otherwise srtp_start() will maintain current\n \t * roll-over counter.\n \t */\n \tpjmedia_transport_srtp_stop((pjmedia_transport*)srtp);\n \n-\ttx = srtp->tx_policy;\n-\trx = srtp->rx_policy;\n \tstatus = pjmedia_transport_srtp_start((pjmedia_transport*)srtp,\n \t\t\t\t\t      &tx, &rx);\n \tif (status != PJ_SUCCESS) {",
        "diff_line_info": {
            "deleted_lines": [
                "\ttx = srtp->tx_policy;",
                "\trx = srtp->rx_policy;"
            ],
            "added_lines": [
                "\ttx = srtp->tx_policy;",
                "\trx = srtp->rx_policy;",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2019-5489",
        "func_name": "torvalds/linux/mincore_pte_range",
        "description": "The mincore() implementation in mm/mincore.c in the Linux kernel through 4.19.13 allowed local attackers to observe page cache access patterns of other processes on the same system, potentially allowing sniffing of secret information. (Fixing this affects the output of the fincore program.) Limited remote exploitation may be possible, as demonstrated by latency differences in accessing public files from an Apache HTTP Server.",
        "git_url": "https://github.com/torvalds/linux/commit/574823bfab82d9d8fa47f422778043fbb4b4f50e",
        "commit_title": "Change mincore() to count \"mapped\" pages rather than \"cached\" pages",
        "commit_text": " The semantics of what \"in core\" means for the mincore() system call are somewhat unclear, but Linux has always (since 2.3.52, which is when mincore() was initially done) treated it as \"page is available in page cache\" rather than \"page is mapped in the mapping\".  The problem with that traditional semantic is that it exposes a lot of system cache state that it really probably shouldn't, and that users shouldn't really even care about.  So let's try to avoid that information leak by simply changing the semantics to be that mincore() counts actual mapped pages, not pages that might be cheaply mapped if they were faulted (note the \"might be\" part of the old semantics: being in the cache doesn't actually guarantee that you can access them without IO anyway, since things like network filesystems may have to revalidate the cache before use).  In many ways the old semantics were somewhat insane even aside from the information leak issue.  From the very beginning (and that beginning is a long time ago: 2.3.52 was released in March 2000, I think), the code had a comment saying    Later we can get more picky about what \"in core\" means precisely.  and this is that \"later\".  Admittedly it is much later than is really comfortable.  NOTE! This is a real semantic change, and it is for example known to change the output of \"fincore\", since that program literally does a mmmap without populating it, and then doing \"mincore()\" on that mapping that doesn't actually have any pages in it.  I'm hoping that nobody actually has any workflow that cares, and the info leak is real.  We may have to do something different if it turns out that people have valid reasons to want the old semantics, and if we can limit the information leak sanely.  Cc: Kevin Easton <kevin@guarana.org> Cc: Jiri Kosina <jikos@kernel.org> Cc: Masatake YAMATO <yamato@redhat.com> Cc: Andrew Morton <akpm@linux-foundation.org> Cc: Greg KH <gregkh@linuxfoundation.org> Cc: Peter Zijlstra <peterz@infradead.org> Cc: Michal Hocko <mhocko@suse.com>",
        "func_before": "static int mincore_pte_range(pmd_t *pmd, unsigned long addr, unsigned long end,\n\t\t\tstruct mm_walk *walk)\n{\n\tspinlock_t *ptl;\n\tstruct vm_area_struct *vma = walk->vma;\n\tpte_t *ptep;\n\tunsigned char *vec = walk->private;\n\tint nr = (end - addr) >> PAGE_SHIFT;\n\n\tptl = pmd_trans_huge_lock(pmd, vma);\n\tif (ptl) {\n\t\tmemset(vec, 1, nr);\n\t\tspin_unlock(ptl);\n\t\tgoto out;\n\t}\n\n\tif (pmd_trans_unstable(pmd)) {\n\t\t__mincore_unmapped_range(addr, end, vma, vec);\n\t\tgoto out;\n\t}\n\n\tptep = pte_offset_map_lock(walk->mm, pmd, addr, &ptl);\n\tfor (; addr != end; ptep++, addr += PAGE_SIZE) {\n\t\tpte_t pte = *ptep;\n\n\t\tif (pte_none(pte))\n\t\t\t__mincore_unmapped_range(addr, addr + PAGE_SIZE,\n\t\t\t\t\t\t vma, vec);\n\t\telse if (pte_present(pte))\n\t\t\t*vec = 1;\n\t\telse { /* pte is a swap entry */\n\t\t\tswp_entry_t entry = pte_to_swp_entry(pte);\n\n\t\t\tif (non_swap_entry(entry)) {\n\t\t\t\t/*\n\t\t\t\t * migration or hwpoison entries are always\n\t\t\t\t * uptodate\n\t\t\t\t */\n\t\t\t\t*vec = 1;\n\t\t\t} else {\n#ifdef CONFIG_SWAP\n\t\t\t\t*vec = mincore_page(swap_address_space(entry),\n\t\t\t\t\t\t    swp_offset(entry));\n#else\n\t\t\t\tWARN_ON(1);\n\t\t\t\t*vec = 1;\n#endif\n\t\t\t}\n\t\t}\n\t\tvec++;\n\t}\n\tpte_unmap_unlock(ptep - 1, ptl);\nout:\n\twalk->private += nr;\n\tcond_resched();\n\treturn 0;\n}",
        "func": "static int mincore_pte_range(pmd_t *pmd, unsigned long addr, unsigned long end,\n\t\t\tstruct mm_walk *walk)\n{\n\tspinlock_t *ptl;\n\tstruct vm_area_struct *vma = walk->vma;\n\tpte_t *ptep;\n\tunsigned char *vec = walk->private;\n\tint nr = (end - addr) >> PAGE_SHIFT;\n\n\tptl = pmd_trans_huge_lock(pmd, vma);\n\tif (ptl) {\n\t\tmemset(vec, 1, nr);\n\t\tspin_unlock(ptl);\n\t\tgoto out;\n\t}\n\n\t/* We'll consider a THP page under construction to be there */\n\tif (pmd_trans_unstable(pmd)) {\n\t\tmemset(vec, 1, nr);\n\t\tgoto out;\n\t}\n\n\tptep = pte_offset_map_lock(walk->mm, pmd, addr, &ptl);\n\tfor (; addr != end; ptep++, addr += PAGE_SIZE) {\n\t\tpte_t pte = *ptep;\n\n\t\tif (pte_none(pte))\n\t\t\t*vec = 0;\n\t\telse if (pte_present(pte))\n\t\t\t*vec = 1;\n\t\telse { /* pte is a swap entry */\n\t\t\tswp_entry_t entry = pte_to_swp_entry(pte);\n\n\t\t\t/*\n\t\t\t * migration or hwpoison entries are always\n\t\t\t * uptodate\n\t\t\t */\n\t\t\t*vec = !!non_swap_entry(entry);\n\t\t}\n\t\tvec++;\n\t}\n\tpte_unmap_unlock(ptep - 1, ptl);\nout:\n\twalk->private += nr;\n\tcond_resched();\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -14,8 +14,9 @@\n \t\tgoto out;\n \t}\n \n+\t/* We'll consider a THP page under construction to be there */\n \tif (pmd_trans_unstable(pmd)) {\n-\t\t__mincore_unmapped_range(addr, end, vma, vec);\n+\t\tmemset(vec, 1, nr);\n \t\tgoto out;\n \t}\n \n@@ -24,28 +25,17 @@\n \t\tpte_t pte = *ptep;\n \n \t\tif (pte_none(pte))\n-\t\t\t__mincore_unmapped_range(addr, addr + PAGE_SIZE,\n-\t\t\t\t\t\t vma, vec);\n+\t\t\t*vec = 0;\n \t\telse if (pte_present(pte))\n \t\t\t*vec = 1;\n \t\telse { /* pte is a swap entry */\n \t\t\tswp_entry_t entry = pte_to_swp_entry(pte);\n \n-\t\t\tif (non_swap_entry(entry)) {\n-\t\t\t\t/*\n-\t\t\t\t * migration or hwpoison entries are always\n-\t\t\t\t * uptodate\n-\t\t\t\t */\n-\t\t\t\t*vec = 1;\n-\t\t\t} else {\n-#ifdef CONFIG_SWAP\n-\t\t\t\t*vec = mincore_page(swap_address_space(entry),\n-\t\t\t\t\t\t    swp_offset(entry));\n-#else\n-\t\t\t\tWARN_ON(1);\n-\t\t\t\t*vec = 1;\n-#endif\n-\t\t\t}\n+\t\t\t/*\n+\t\t\t * migration or hwpoison entries are always\n+\t\t\t * uptodate\n+\t\t\t */\n+\t\t\t*vec = !!non_swap_entry(entry);\n \t\t}\n \t\tvec++;\n \t}",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t__mincore_unmapped_range(addr, end, vma, vec);",
                "\t\t\t__mincore_unmapped_range(addr, addr + PAGE_SIZE,",
                "\t\t\t\t\t\t vma, vec);",
                "\t\t\tif (non_swap_entry(entry)) {",
                "\t\t\t\t/*",
                "\t\t\t\t * migration or hwpoison entries are always",
                "\t\t\t\t * uptodate",
                "\t\t\t\t */",
                "\t\t\t\t*vec = 1;",
                "\t\t\t} else {",
                "#ifdef CONFIG_SWAP",
                "\t\t\t\t*vec = mincore_page(swap_address_space(entry),",
                "\t\t\t\t\t\t    swp_offset(entry));",
                "#else",
                "\t\t\t\tWARN_ON(1);",
                "\t\t\t\t*vec = 1;",
                "#endif",
                "\t\t\t}"
            ],
            "added_lines": [
                "\t/* We'll consider a THP page under construction to be there */",
                "\t\tmemset(vec, 1, nr);",
                "\t\t\t*vec = 0;",
                "\t\t\t/*",
                "\t\t\t * migration or hwpoison entries are always",
                "\t\t\t * uptodate",
                "\t\t\t */",
                "\t\t\t*vec = !!non_swap_entry(entry);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-5489",
        "func_name": "torvalds/linux/mincore_unmapped_range",
        "description": "The mincore() implementation in mm/mincore.c in the Linux kernel through 4.19.13 allowed local attackers to observe page cache access patterns of other processes on the same system, potentially allowing sniffing of secret information. (Fixing this affects the output of the fincore program.) Limited remote exploitation may be possible, as demonstrated by latency differences in accessing public files from an Apache HTTP Server.",
        "git_url": "https://github.com/torvalds/linux/commit/574823bfab82d9d8fa47f422778043fbb4b4f50e",
        "commit_title": "Change mincore() to count \"mapped\" pages rather than \"cached\" pages",
        "commit_text": " The semantics of what \"in core\" means for the mincore() system call are somewhat unclear, but Linux has always (since 2.3.52, which is when mincore() was initially done) treated it as \"page is available in page cache\" rather than \"page is mapped in the mapping\".  The problem with that traditional semantic is that it exposes a lot of system cache state that it really probably shouldn't, and that users shouldn't really even care about.  So let's try to avoid that information leak by simply changing the semantics to be that mincore() counts actual mapped pages, not pages that might be cheaply mapped if they were faulted (note the \"might be\" part of the old semantics: being in the cache doesn't actually guarantee that you can access them without IO anyway, since things like network filesystems may have to revalidate the cache before use).  In many ways the old semantics were somewhat insane even aside from the information leak issue.  From the very beginning (and that beginning is a long time ago: 2.3.52 was released in March 2000, I think), the code had a comment saying    Later we can get more picky about what \"in core\" means precisely.  and this is that \"later\".  Admittedly it is much later than is really comfortable.  NOTE! This is a real semantic change, and it is for example known to change the output of \"fincore\", since that program literally does a mmmap without populating it, and then doing \"mincore()\" on that mapping that doesn't actually have any pages in it.  I'm hoping that nobody actually has any workflow that cares, and the info leak is real.  We may have to do something different if it turns out that people have valid reasons to want the old semantics, and if we can limit the information leak sanely.  Cc: Kevin Easton <kevin@guarana.org> Cc: Jiri Kosina <jikos@kernel.org> Cc: Masatake YAMATO <yamato@redhat.com> Cc: Andrew Morton <akpm@linux-foundation.org> Cc: Greg KH <gregkh@linuxfoundation.org> Cc: Peter Zijlstra <peterz@infradead.org> Cc: Michal Hocko <mhocko@suse.com>",
        "func_before": "static int mincore_unmapped_range(unsigned long addr, unsigned long end,\n\t\t\t\t   struct mm_walk *walk)\n{\n\twalk->private += __mincore_unmapped_range(addr, end,\n\t\t\t\t\t\t  walk->vma, walk->private);\n\treturn 0;\n}",
        "func": "static int mincore_unmapped_range(unsigned long addr, unsigned long end,\n\t\t\t\t   struct mm_walk *walk)\n{\n\tunsigned char *vec = walk->private;\n\tunsigned long nr = (end - addr) >> PAGE_SHIFT;\n\n\tmemset(vec, 0, nr);\n\twalk->private += nr;\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,7 +1,10 @@\n static int mincore_unmapped_range(unsigned long addr, unsigned long end,\n \t\t\t\t   struct mm_walk *walk)\n {\n-\twalk->private += __mincore_unmapped_range(addr, end,\n-\t\t\t\t\t\t  walk->vma, walk->private);\n+\tunsigned char *vec = walk->private;\n+\tunsigned long nr = (end - addr) >> PAGE_SHIFT;\n+\n+\tmemset(vec, 0, nr);\n+\twalk->private += nr;\n \treturn 0;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\twalk->private += __mincore_unmapped_range(addr, end,",
                "\t\t\t\t\t\t  walk->vma, walk->private);"
            ],
            "added_lines": [
                "\tunsigned char *vec = walk->private;",
                "\tunsigned long nr = (end - addr) >> PAGE_SHIFT;",
                "",
                "\tmemset(vec, 0, nr);",
                "\twalk->private += nr;"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-34825",
        "func_name": "quassel/SslServer::SslServer",
        "description": "Quassel through 0.13.1, when --require-ssl is enabled, launches without SSL or TLS support if a usable X.509 certificate is not found on the local system.",
        "git_url": "https://github.com/quassel/quassel/commit/104d01d2c619f6926bcaccea860da90b19449ad5",
        "commit_title": "core: Require TLS cert to be loaded if --require-ssl is used",
        "commit_text": "If the user specifies --require-ssl, but the core cannot load a SSL/TLS certificate for any reason, the core will throw an exception and quit. This fixes a minor security vulnerability where previously, the core would simply fall back to plaintext mode and not offer encrypted connections at all.",
        "func_before": "SslServer::SslServer(QObject* parent)\n    : QTcpServer(parent)\n{\n    // Keep track if the SSL warning has been mentioned at least once before\n    static bool sslWarningShown = false;\n\n    if (Quassel::isOptionSet(\"ssl-cert\")) {\n        _sslCertPath = Quassel::optionValue(\"ssl-cert\");\n    }\n    else {\n        _sslCertPath = Quassel::configDirPath() + \"quasselCert.pem\";\n    }\n\n    if (Quassel::isOptionSet(\"ssl-key\")) {\n        _sslKeyPath = Quassel::optionValue(\"ssl-key\");\n    }\n    else {\n        _sslKeyPath = _sslCertPath;\n    }\n\n    // Initialize the certificates for first-time usage\n    if (!loadCerts()) {\n        if (!sslWarningShown) {\n            qWarning() << \"SslServer: Unable to set certificate file\\n\"\n                       << \"          Quassel Core will still work, but cannot provide SSL for client connections.\\n\"\n                       << \"          Please see https://quassel-irc.org/faq/cert to learn how to enable SSL support.\";\n            sslWarningShown = true;\n        }\n    }\n}",
        "func": "SslServer::SslServer(QObject* parent)\n    : QTcpServer(parent)\n{\n    // Keep track if the SSL warning has been mentioned at least once before\n    static bool sslWarningShown = false;\n\n    if (Quassel::isOptionSet(\"ssl-cert\")) {\n        _sslCertPath = Quassel::optionValue(\"ssl-cert\");\n    }\n    else {\n        _sslCertPath = Quassel::configDirPath() + \"quasselCert.pem\";\n    }\n\n    if (Quassel::isOptionSet(\"ssl-key\")) {\n        _sslKeyPath = Quassel::optionValue(\"ssl-key\");\n    }\n    else {\n        _sslKeyPath = _sslCertPath;\n    }\n\n    // Initialize the certificates for first-time usage\n    if (!loadCerts()) {\n        // If the core is unable to load a certificate, and \"--require-ssl\" is specified,\n        // do not proceed, throw an exception and quit. This prevents the core from falling\n        // back to a plaintext-only core when they should be expecting SSL/TLS only.\n        if (Quassel::isOptionSet(\"require-ssl\")) {\n            throw ExitException{EXIT_FAILURE, tr(\"--require-ssl is set, but no SSL certificate is available. Exiting.\")};\n        }\n        if (!sslWarningShown) {\n            qWarning() << \"SslServer: Unable to set certificate file\\n\"\n                       << \"          Quassel Core will still work, but cannot provide SSL for client connections.\\n\"\n                       << \"          Please see https://quassel-irc.org/faq/cert to learn how to enable SSL support.\";\n            sslWarningShown = true;\n        }\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -20,6 +20,12 @@\n \n     // Initialize the certificates for first-time usage\n     if (!loadCerts()) {\n+        // If the core is unable to load a certificate, and \"--require-ssl\" is specified,\n+        // do not proceed, throw an exception and quit. This prevents the core from falling\n+        // back to a plaintext-only core when they should be expecting SSL/TLS only.\n+        if (Quassel::isOptionSet(\"require-ssl\")) {\n+            throw ExitException{EXIT_FAILURE, tr(\"--require-ssl is set, but no SSL certificate is available. Exiting.\")};\n+        }\n         if (!sslWarningShown) {\n             qWarning() << \"SslServer: Unable to set certificate file\\n\"\n                        << \"          Quassel Core will still work, but cannot provide SSL for client connections.\\n\"",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "        // If the core is unable to load a certificate, and \"--require-ssl\" is specified,",
                "        // do not proceed, throw an exception and quit. This prevents the core from falling",
                "        // back to a plaintext-only core when they should be expecting SSL/TLS only.",
                "        if (Quassel::isOptionSet(\"require-ssl\")) {",
                "            throw ExitException{EXIT_FAILURE, tr(\"--require-ssl is set, but no SSL certificate is available. Exiting.\")};",
                "        }"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-34825",
        "func_name": "quassel/SslServer::SslServer",
        "description": "Quassel through 0.13.1, when --require-ssl is enabled, launches without SSL or TLS support if a usable X.509 certificate is not found on the local system.",
        "git_url": "https://github.com/quassel/quassel/commit/1fc1282f0859daa4fa2cd42a7b4d3ab785765563",
        "commit_title": "Add link to certificate FAQ in --require-ssl error\r",
        "commit_text": "\r Include a link to the FAQ page explaining how to set up SSL support on the quassel-irc.org website.  Co-authored-by: Shane Synan <digitalcircuit36939@gmail.com>",
        "func_before": "SslServer::SslServer(QObject* parent)\n    : QTcpServer(parent)\n{\n    // Keep track if the SSL warning has been mentioned at least once before\n    static bool sslWarningShown = false;\n\n    if (Quassel::isOptionSet(\"ssl-cert\")) {\n        _sslCertPath = Quassel::optionValue(\"ssl-cert\");\n    }\n    else {\n        _sslCertPath = Quassel::configDirPath() + \"quasselCert.pem\";\n    }\n\n    if (Quassel::isOptionSet(\"ssl-key\")) {\n        _sslKeyPath = Quassel::optionValue(\"ssl-key\");\n    }\n    else {\n        _sslKeyPath = _sslCertPath;\n    }\n\n    // Initialize the certificates for first-time usage\n    if (!loadCerts()) {\n        // If the core is unable to load a certificate, and \"--require-ssl\" is specified,\n        // do not proceed, throw an exception and quit. This prevents the core from falling\n        // back to a plaintext-only core when they should be expecting SSL/TLS only.\n        if (Quassel::isOptionSet(\"require-ssl\")) {\n            throw ExitException{EXIT_FAILURE, tr(\"--require-ssl is set, but no SSL certificate is available. Exiting.\")};\n        }\n        if (!sslWarningShown) {\n            qWarning() << \"SslServer: Unable to set certificate file\\n\"\n                       << \"          Quassel Core will still work, but cannot provide SSL for client connections.\\n\"\n                       << \"          Please see https://quassel-irc.org/faq/cert to learn how to enable SSL support.\";\n            sslWarningShown = true;\n        }\n    }\n}",
        "func": "SslServer::SslServer(QObject* parent)\n    : QTcpServer(parent)\n{\n    // Keep track if the SSL warning has been mentioned at least once before\n    static bool sslWarningShown = false;\n\n    if (Quassel::isOptionSet(\"ssl-cert\")) {\n        _sslCertPath = Quassel::optionValue(\"ssl-cert\");\n    }\n    else {\n        _sslCertPath = Quassel::configDirPath() + \"quasselCert.pem\";\n    }\n\n    if (Quassel::isOptionSet(\"ssl-key\")) {\n        _sslKeyPath = Quassel::optionValue(\"ssl-key\");\n    }\n    else {\n        _sslKeyPath = _sslCertPath;\n    }\n\n    // Initialize the certificates for first-time usage\n    if (!loadCerts()) {\n        // If the core is unable to load a certificate, and \"--require-ssl\" is specified,\n        // do not proceed, throw an exception and quit. This prevents the core from falling\n        // back to a plaintext-only core when they should be expecting SSL/TLS only.\n        if (Quassel::isOptionSet(\"require-ssl\")) {\n            throw ExitException{EXIT_FAILURE, tr(\"--require-ssl is set, but no SSL certificate is available. Exiting.\\n\"\n                                                 \"Please see https://quassel-irc.org/faq/cert to learn how to enable SSL support.\")};\n        }\n        if (!sslWarningShown) {\n            qWarning() << \"SslServer: Unable to set certificate file\\n\"\n                       << \"          Quassel Core will still work, but cannot provide SSL for client connections.\\n\"\n                       << \"          Please see https://quassel-irc.org/faq/cert to learn how to enable SSL support.\";\n            sslWarningShown = true;\n        }\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -24,7 +24,8 @@\n         // do not proceed, throw an exception and quit. This prevents the core from falling\n         // back to a plaintext-only core when they should be expecting SSL/TLS only.\n         if (Quassel::isOptionSet(\"require-ssl\")) {\n-            throw ExitException{EXIT_FAILURE, tr(\"--require-ssl is set, but no SSL certificate is available. Exiting.\")};\n+            throw ExitException{EXIT_FAILURE, tr(\"--require-ssl is set, but no SSL certificate is available. Exiting.\\n\"\n+                                                 \"Please see https://quassel-irc.org/faq/cert to learn how to enable SSL support.\")};\n         }\n         if (!sslWarningShown) {\n             qWarning() << \"SslServer: Unable to set certificate file\\n\"",
        "diff_line_info": {
            "deleted_lines": [
                "            throw ExitException{EXIT_FAILURE, tr(\"--require-ssl is set, but no SSL certificate is available. Exiting.\")};"
            ],
            "added_lines": [
                "            throw ExitException{EXIT_FAILURE, tr(\"--require-ssl is set, but no SSL certificate is available. Exiting.\\n\"",
                "                                                 \"Please see https://quassel-irc.org/faq/cert to learn how to enable SSL support.\")};"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-45100",
        "func_name": "cifsd-team/ksmbd/ntlm_authenticate",
        "description": "The ksmbd server through 3.4.2, as used in the Linux kernel through 5.15.8, sometimes communicates in cleartext even though encryption has been enabled. This occurs because it sets the SMB2_GLOBAL_CAP_ENCRYPTION flag when using the SMB 3.1.1 protocol, which is a violation of the SMB protocol specification. When Windows 10 detects this protocol violation, it disables encryption.",
        "git_url": "https://github.com/cifsd-team/ksmbd/commit/b0b104adae26de607db43f346a7c450ef0c6af9a",
        "commit_title": "Do not set SMB2_GLOBAL_CAP_ENCRYPTION for SMB 3.1.1",
        "commit_text": " According to the official Microsoft MS-SMB2 document section 3.3.5.4, this flag should be used only for 3.0 and 3.0.2 dialects. Setting it for 3.1.1 is a violation of the specification.",
        "func_before": "static int ntlm_authenticate(struct ksmbd_work *work)\n{\n\tstruct smb2_sess_setup_req *req = work->request_buf;\n\tstruct smb2_sess_setup_rsp *rsp = work->response_buf;\n\tstruct ksmbd_conn *conn = work->conn;\n\tstruct ksmbd_session *sess = work->sess;\n\tstruct channel *chann = NULL;\n\tstruct ksmbd_user *user;\n\tu64 prev_id;\n\tint sz, rc;\n\n\tksmbd_debug(SMB, \"authenticate phase\\n\");\n\tif (conn->use_spnego) {\n\t\tunsigned char *spnego_blob;\n\t\tu16 spnego_blob_len;\n\n\t\trc = build_spnego_ntlmssp_auth_blob(&spnego_blob,\n\t\t\t\t\t\t    &spnego_blob_len,\n\t\t\t\t\t\t    0);\n\t\tif (rc)\n\t\t\treturn -ENOMEM;\n\n\t\tsz = le16_to_cpu(rsp->SecurityBufferOffset);\n\t\tmemcpy((char *)&rsp->hdr.ProtocolId + sz, spnego_blob, spnego_blob_len);\n\t\trsp->SecurityBufferLength = cpu_to_le16(spnego_blob_len);\n\t\tkfree(spnego_blob);\n\t\tinc_rfc1001_len(rsp, spnego_blob_len - 1);\n\t}\n\n\tuser = session_user(conn, req);\n\tif (!user) {\n\t\tksmbd_debug(SMB, \"Unknown user name or an error\\n\");\n\t\treturn -EPERM;\n\t}\n\n\t/* Check for previous session */\n\tprev_id = le64_to_cpu(req->PreviousSessionId);\n\tif (prev_id && prev_id != sess->id)\n\t\tdestroy_previous_session(user, prev_id);\n\n\tif (sess->state == SMB2_SESSION_VALID) {\n\t\t/*\n\t\t * Reuse session if anonymous try to connect\n\t\t * on reauthetication.\n\t\t */\n\t\tif (ksmbd_anonymous_user(user)) {\n\t\t\tksmbd_free_user(user);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (!ksmbd_compare_user(sess->user, user))\n\t\t\treturn -EPERM;\n\n\t\tksmbd_free_user(user);\n\t} else {\n\t\tsess->user = user;\n\t}\n\n\tif (user_guest(sess->user)) {\n\t\tif (conn->sign) {\n\t\t\tksmbd_debug(SMB, \"Guest login not allowed when signing enabled\\n\");\n\t\t\treturn -EPERM;\n\t\t}\n\n\t\trsp->SessionFlags = SMB2_SESSION_FLAG_IS_GUEST_LE;\n\t} else {\n\t\tstruct authenticate_message *authblob;\n\n\t\tauthblob = user_authblob(conn, req);\n\t\tsz = le16_to_cpu(req->SecurityBufferLength);\n\t\trc = ksmbd_decode_ntlmssp_auth_blob(authblob, sz, conn, sess);\n\t\tif (rc) {\n\t\t\tset_user_flag(sess->user, KSMBD_USER_FLAG_BAD_PASSWORD);\n\t\t\tksmbd_debug(SMB, \"authentication failed\\n\");\n\t\t\treturn -EPERM;\n\t\t}\n\n\t\t/*\n\t\t * If session state is SMB2_SESSION_VALID, We can assume\n\t\t * that it is reauthentication. And the user/password\n\t\t * has been verified, so return it here.\n\t\t */\n\t\tif (sess->state == SMB2_SESSION_VALID) {\n\t\t\tif (conn->binding)\n\t\t\t\tgoto binding_session;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif ((conn->sign || server_conf.enforced_signing) ||\n\t\t    (req->SecurityMode & SMB2_NEGOTIATE_SIGNING_REQUIRED))\n\t\t\tsess->sign = true;\n\n\t\tif (conn->vals->capabilities & SMB2_GLOBAL_CAP_ENCRYPTION &&\n\t\t    conn->ops->generate_encryptionkey &&\n\t\t    !(req->Flags & SMB2_SESSION_REQ_FLAG_BINDING)) {\n\t\t\trc = conn->ops->generate_encryptionkey(sess);\n\t\t\tif (rc) {\n\t\t\t\tksmbd_debug(SMB,\n\t\t\t\t\t    \"SMB3 encryption key generation failed\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tsess->enc = true;\n\t\t\trsp->SessionFlags = SMB2_SESSION_FLAG_ENCRYPT_DATA_LE;\n\t\t\t/*\n\t\t\t * signing is disable if encryption is enable\n\t\t\t * on this session\n\t\t\t */\n\t\t\tsess->sign = false;\n\t\t}\n\t}\n\nbinding_session:\n\tif (conn->dialect >= SMB30_PROT_ID) {\n\t\tchann = lookup_chann_list(sess, conn);\n\t\tif (!chann) {\n\t\t\tchann = kmalloc(sizeof(struct channel), GFP_KERNEL);\n\t\t\tif (!chann)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tchann->conn = conn;\n\t\t\tINIT_LIST_HEAD(&chann->chann_list);\n\t\t\tlist_add(&chann->chann_list, &sess->ksmbd_chann_list);\n\t\t}\n\t}\n\n\tif (conn->ops->generate_signingkey) {\n\t\trc = conn->ops->generate_signingkey(sess, conn);\n\t\tif (rc) {\n\t\t\tksmbd_debug(SMB, \"SMB3 signing key generation failed\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (conn->dialect > SMB20_PROT_ID) {\n\t\tif (!ksmbd_conn_lookup_dialect(conn)) {\n\t\t\tpr_err(\"fail to verify the dialect\\n\");\n\t\t\treturn -ENOENT;\n\t\t}\n\t}\n\treturn 0;\n}",
        "func": "static int ntlm_authenticate(struct ksmbd_work *work)\n{\n\tstruct smb2_sess_setup_req *req = work->request_buf;\n\tstruct smb2_sess_setup_rsp *rsp = work->response_buf;\n\tstruct ksmbd_conn *conn = work->conn;\n\tstruct ksmbd_session *sess = work->sess;\n\tstruct channel *chann = NULL;\n\tstruct ksmbd_user *user;\n\tu64 prev_id;\n\tint sz, rc;\n\n\tksmbd_debug(SMB, \"authenticate phase\\n\");\n\tif (conn->use_spnego) {\n\t\tunsigned char *spnego_blob;\n\t\tu16 spnego_blob_len;\n\n\t\trc = build_spnego_ntlmssp_auth_blob(&spnego_blob,\n\t\t\t\t\t\t    &spnego_blob_len,\n\t\t\t\t\t\t    0);\n\t\tif (rc)\n\t\t\treturn -ENOMEM;\n\n\t\tsz = le16_to_cpu(rsp->SecurityBufferOffset);\n\t\tmemcpy((char *)&rsp->hdr.ProtocolId + sz, spnego_blob, spnego_blob_len);\n\t\trsp->SecurityBufferLength = cpu_to_le16(spnego_blob_len);\n\t\tkfree(spnego_blob);\n\t\tinc_rfc1001_len(rsp, spnego_blob_len - 1);\n\t}\n\n\tuser = session_user(conn, req);\n\tif (!user) {\n\t\tksmbd_debug(SMB, \"Unknown user name or an error\\n\");\n\t\treturn -EPERM;\n\t}\n\n\t/* Check for previous session */\n\tprev_id = le64_to_cpu(req->PreviousSessionId);\n\tif (prev_id && prev_id != sess->id)\n\t\tdestroy_previous_session(user, prev_id);\n\n\tif (sess->state == SMB2_SESSION_VALID) {\n\t\t/*\n\t\t * Reuse session if anonymous try to connect\n\t\t * on reauthetication.\n\t\t */\n\t\tif (ksmbd_anonymous_user(user)) {\n\t\t\tksmbd_free_user(user);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif (!ksmbd_compare_user(sess->user, user))\n\t\t\treturn -EPERM;\n\n\t\tksmbd_free_user(user);\n\t} else {\n\t\tsess->user = user;\n\t}\n\n\tif (user_guest(sess->user)) {\n\t\tif (conn->sign) {\n\t\t\tksmbd_debug(SMB, \"Guest login not allowed when signing enabled\\n\");\n\t\t\treturn -EPERM;\n\t\t}\n\n\t\trsp->SessionFlags = SMB2_SESSION_FLAG_IS_GUEST_LE;\n\t} else {\n\t\tstruct authenticate_message *authblob;\n\n\t\tauthblob = user_authblob(conn, req);\n\t\tsz = le16_to_cpu(req->SecurityBufferLength);\n\t\trc = ksmbd_decode_ntlmssp_auth_blob(authblob, sz, conn, sess);\n\t\tif (rc) {\n\t\t\tset_user_flag(sess->user, KSMBD_USER_FLAG_BAD_PASSWORD);\n\t\t\tksmbd_debug(SMB, \"authentication failed\\n\");\n\t\t\treturn -EPERM;\n\t\t}\n\n\t\t/*\n\t\t * If session state is SMB2_SESSION_VALID, We can assume\n\t\t * that it is reauthentication. And the user/password\n\t\t * has been verified, so return it here.\n\t\t */\n\t\tif (sess->state == SMB2_SESSION_VALID) {\n\t\t\tif (conn->binding)\n\t\t\t\tgoto binding_session;\n\t\t\treturn 0;\n\t\t}\n\n\t\tif ((conn->sign || server_conf.enforced_signing) ||\n\t\t    (req->SecurityMode & SMB2_NEGOTIATE_SIGNING_REQUIRED))\n\t\t\tsess->sign = true;\n\n\t\tif (should_encrypt(conn) &&\n\t\t    !(req->Flags & SMB2_SESSION_REQ_FLAG_BINDING)) {\n\t\t\trc = conn->ops->generate_encryptionkey(sess);\n\t\t\tif (rc) {\n\t\t\t\tksmbd_debug(SMB,\n\t\t\t\t\t    \"SMB3 encryption key generation failed\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tsess->enc = true;\n\t\t\trsp->SessionFlags = SMB2_SESSION_FLAG_ENCRYPT_DATA_LE;\n\t\t\t/*\n\t\t\t * signing is disable if encryption is enable\n\t\t\t * on this session\n\t\t\t */\n\t\t\tsess->sign = false;\n\t\t}\n\t}\n\nbinding_session:\n\tif (conn->dialect >= SMB30_PROT_ID) {\n\t\tchann = lookup_chann_list(sess, conn);\n\t\tif (!chann) {\n\t\t\tchann = kmalloc(sizeof(struct channel), GFP_KERNEL);\n\t\t\tif (!chann)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tchann->conn = conn;\n\t\t\tINIT_LIST_HEAD(&chann->chann_list);\n\t\t\tlist_add(&chann->chann_list, &sess->ksmbd_chann_list);\n\t\t}\n\t}\n\n\tif (conn->ops->generate_signingkey) {\n\t\trc = conn->ops->generate_signingkey(sess, conn);\n\t\tif (rc) {\n\t\t\tksmbd_debug(SMB, \"SMB3 signing key generation failed\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (conn->dialect > SMB20_PROT_ID) {\n\t\tif (!ksmbd_conn_lookup_dialect(conn)) {\n\t\t\tpr_err(\"fail to verify the dialect\\n\");\n\t\t\treturn -ENOENT;\n\t\t}\n\t}\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -90,8 +90,7 @@\n \t\t    (req->SecurityMode & SMB2_NEGOTIATE_SIGNING_REQUIRED))\n \t\t\tsess->sign = true;\n \n-\t\tif (conn->vals->capabilities & SMB2_GLOBAL_CAP_ENCRYPTION &&\n-\t\t    conn->ops->generate_encryptionkey &&\n+\t\tif (should_encrypt(conn) &&\n \t\t    !(req->Flags & SMB2_SESSION_REQ_FLAG_BINDING)) {\n \t\t\trc = conn->ops->generate_encryptionkey(sess);\n \t\t\tif (rc) {",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tif (conn->vals->capabilities & SMB2_GLOBAL_CAP_ENCRYPTION &&",
                "\t\t    conn->ops->generate_encryptionkey &&"
            ],
            "added_lines": [
                "\t\tif (should_encrypt(conn) &&"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-45100",
        "func_name": "cifsd-team/ksmbd/krb5_authenticate",
        "description": "The ksmbd server through 3.4.2, as used in the Linux kernel through 5.15.8, sometimes communicates in cleartext even though encryption has been enabled. This occurs because it sets the SMB2_GLOBAL_CAP_ENCRYPTION flag when using the SMB 3.1.1 protocol, which is a violation of the SMB protocol specification. When Windows 10 detects this protocol violation, it disables encryption.",
        "git_url": "https://github.com/cifsd-team/ksmbd/commit/b0b104adae26de607db43f346a7c450ef0c6af9a",
        "commit_title": "Do not set SMB2_GLOBAL_CAP_ENCRYPTION for SMB 3.1.1",
        "commit_text": " According to the official Microsoft MS-SMB2 document section 3.3.5.4, this flag should be used only for 3.0 and 3.0.2 dialects. Setting it for 3.1.1 is a violation of the specification.",
        "func_before": "static int krb5_authenticate(struct ksmbd_work *work)\n{\n\tstruct smb2_sess_setup_req *req = work->request_buf;\n\tstruct smb2_sess_setup_rsp *rsp = work->response_buf;\n\tstruct ksmbd_conn *conn = work->conn;\n\tstruct ksmbd_session *sess = work->sess;\n\tchar *in_blob, *out_blob;\n\tstruct channel *chann = NULL;\n\tu64 prev_sess_id;\n\tint in_len, out_len;\n\tint retval;\n\n\tin_blob = (char *)&req->hdr.ProtocolId +\n\t\tle16_to_cpu(req->SecurityBufferOffset);\n\tin_len = le16_to_cpu(req->SecurityBufferLength);\n\tout_blob = (char *)&rsp->hdr.ProtocolId +\n\t\tle16_to_cpu(rsp->SecurityBufferOffset);\n\tout_len = work->response_sz -\n\t\toffsetof(struct smb2_hdr, smb2_buf_length) -\n\t\tle16_to_cpu(rsp->SecurityBufferOffset);\n\n\t/* Check previous session */\n\tprev_sess_id = le64_to_cpu(req->PreviousSessionId);\n\tif (prev_sess_id && prev_sess_id != sess->id)\n\t\tdestroy_previous_session(sess->user, prev_sess_id);\n\n\tif (sess->state == SMB2_SESSION_VALID)\n\t\tksmbd_free_user(sess->user);\n\n\tretval = ksmbd_krb5_authenticate(sess, in_blob, in_len,\n\t\t\t\t\t out_blob, &out_len);\n\tif (retval) {\n\t\tksmbd_debug(SMB, \"krb5 authentication failed\\n\");\n\t\treturn -EINVAL;\n\t}\n\trsp->SecurityBufferLength = cpu_to_le16(out_len);\n\tinc_rfc1001_len(rsp, out_len - 1);\n\n\tif ((conn->sign || server_conf.enforced_signing) ||\n\t    (req->SecurityMode & SMB2_NEGOTIATE_SIGNING_REQUIRED))\n\t\tsess->sign = true;\n\n\tif ((conn->vals->capabilities & SMB2_GLOBAL_CAP_ENCRYPTION) &&\n\t    conn->ops->generate_encryptionkey) {\n\t\tretval = conn->ops->generate_encryptionkey(sess);\n\t\tif (retval) {\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"SMB3 encryption key generation failed\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tsess->enc = true;\n\t\trsp->SessionFlags = SMB2_SESSION_FLAG_ENCRYPT_DATA_LE;\n\t\tsess->sign = false;\n\t}\n\n\tif (conn->dialect >= SMB30_PROT_ID) {\n\t\tchann = lookup_chann_list(sess, conn);\n\t\tif (!chann) {\n\t\t\tchann = kmalloc(sizeof(struct channel), GFP_KERNEL);\n\t\t\tif (!chann)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tchann->conn = conn;\n\t\t\tINIT_LIST_HEAD(&chann->chann_list);\n\t\t\tlist_add(&chann->chann_list, &sess->ksmbd_chann_list);\n\t\t}\n\t}\n\n\tif (conn->ops->generate_signingkey) {\n\t\tretval = conn->ops->generate_signingkey(sess, conn);\n\t\tif (retval) {\n\t\t\tksmbd_debug(SMB, \"SMB3 signing key generation failed\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (conn->dialect > SMB20_PROT_ID) {\n\t\tif (!ksmbd_conn_lookup_dialect(conn)) {\n\t\t\tpr_err(\"fail to verify the dialect\\n\");\n\t\t\treturn -ENOENT;\n\t\t}\n\t}\n\treturn 0;\n}",
        "func": "static int krb5_authenticate(struct ksmbd_work *work)\n{\n\tstruct smb2_sess_setup_req *req = work->request_buf;\n\tstruct smb2_sess_setup_rsp *rsp = work->response_buf;\n\tstruct ksmbd_conn *conn = work->conn;\n\tstruct ksmbd_session *sess = work->sess;\n\tchar *in_blob, *out_blob;\n\tstruct channel *chann = NULL;\n\tu64 prev_sess_id;\n\tint in_len, out_len;\n\tint retval;\n\n\tin_blob = (char *)&req->hdr.ProtocolId +\n\t\tle16_to_cpu(req->SecurityBufferOffset);\n\tin_len = le16_to_cpu(req->SecurityBufferLength);\n\tout_blob = (char *)&rsp->hdr.ProtocolId +\n\t\tle16_to_cpu(rsp->SecurityBufferOffset);\n\tout_len = work->response_sz -\n\t\toffsetof(struct smb2_hdr, smb2_buf_length) -\n\t\tle16_to_cpu(rsp->SecurityBufferOffset);\n\n\t/* Check previous session */\n\tprev_sess_id = le64_to_cpu(req->PreviousSessionId);\n\tif (prev_sess_id && prev_sess_id != sess->id)\n\t\tdestroy_previous_session(sess->user, prev_sess_id);\n\n\tif (sess->state == SMB2_SESSION_VALID)\n\t\tksmbd_free_user(sess->user);\n\n\tretval = ksmbd_krb5_authenticate(sess, in_blob, in_len,\n\t\t\t\t\t out_blob, &out_len);\n\tif (retval) {\n\t\tksmbd_debug(SMB, \"krb5 authentication failed\\n\");\n\t\treturn -EINVAL;\n\t}\n\trsp->SecurityBufferLength = cpu_to_le16(out_len);\n\tinc_rfc1001_len(rsp, out_len - 1);\n\n\tif ((conn->sign || server_conf.enforced_signing) ||\n\t    (req->SecurityMode & SMB2_NEGOTIATE_SIGNING_REQUIRED))\n\t\tsess->sign = true;\n\n\tif (should_encrypt(conn)) {\n\t\tretval = conn->ops->generate_encryptionkey(sess);\n\t\tif (retval) {\n\t\t\tksmbd_debug(SMB,\n\t\t\t\t    \"SMB3 encryption key generation failed\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tsess->enc = true;\n\t\trsp->SessionFlags = SMB2_SESSION_FLAG_ENCRYPT_DATA_LE;\n\t\tsess->sign = false;\n\t}\n\n\tif (conn->dialect >= SMB30_PROT_ID) {\n\t\tchann = lookup_chann_list(sess, conn);\n\t\tif (!chann) {\n\t\t\tchann = kmalloc(sizeof(struct channel), GFP_KERNEL);\n\t\t\tif (!chann)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tchann->conn = conn;\n\t\t\tINIT_LIST_HEAD(&chann->chann_list);\n\t\t\tlist_add(&chann->chann_list, &sess->ksmbd_chann_list);\n\t\t}\n\t}\n\n\tif (conn->ops->generate_signingkey) {\n\t\tretval = conn->ops->generate_signingkey(sess, conn);\n\t\tif (retval) {\n\t\t\tksmbd_debug(SMB, \"SMB3 signing key generation failed\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\tif (conn->dialect > SMB20_PROT_ID) {\n\t\tif (!ksmbd_conn_lookup_dialect(conn)) {\n\t\t\tpr_err(\"fail to verify the dialect\\n\");\n\t\t\treturn -ENOENT;\n\t\t}\n\t}\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -40,8 +40,7 @@\n \t    (req->SecurityMode & SMB2_NEGOTIATE_SIGNING_REQUIRED))\n \t\tsess->sign = true;\n \n-\tif ((conn->vals->capabilities & SMB2_GLOBAL_CAP_ENCRYPTION) &&\n-\t    conn->ops->generate_encryptionkey) {\n+\tif (should_encrypt(conn)) {\n \t\tretval = conn->ops->generate_encryptionkey(sess);\n \t\tif (retval) {\n \t\t\tksmbd_debug(SMB,",
        "diff_line_info": {
            "deleted_lines": [
                "\tif ((conn->vals->capabilities & SMB2_GLOBAL_CAP_ENCRYPTION) &&",
                "\t    conn->ops->generate_encryptionkey) {"
            ],
            "added_lines": [
                "\tif (should_encrypt(conn)) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-45100",
        "func_name": "cifsd-team/ksmbd/init_smb3_11_server",
        "description": "The ksmbd server through 3.4.2, as used in the Linux kernel through 5.15.8, sometimes communicates in cleartext even though encryption has been enabled. This occurs because it sets the SMB2_GLOBAL_CAP_ENCRYPTION flag when using the SMB 3.1.1 protocol, which is a violation of the SMB protocol specification. When Windows 10 detects this protocol violation, it disables encryption.",
        "git_url": "https://github.com/cifsd-team/ksmbd/commit/b0b104adae26de607db43f346a7c450ef0c6af9a",
        "commit_title": "Do not set SMB2_GLOBAL_CAP_ENCRYPTION for SMB 3.1.1",
        "commit_text": " According to the official Microsoft MS-SMB2 document section 3.3.5.4, this flag should be used only for 3.0 and 3.0.2 dialects. Setting it for 3.1.1 is a violation of the specification.",
        "func_before": "int init_smb3_11_server(struct ksmbd_conn *conn)\n{\n\tconn->vals = &smb311_server_values;\n\tconn->ops = &smb3_11_server_ops;\n\tconn->cmds = smb2_0_server_cmds;\n\tconn->max_cmds = ARRAY_SIZE(smb2_0_server_cmds);\n\tconn->max_credits = SMB2_MAX_CREDITS;\n\tconn->signing_algorithm = SIGNING_ALG_AES_CMAC;\n\n\tif (server_conf.flags & KSMBD_GLOBAL_FLAG_SMB2_LEASES)\n\t\tconn->vals->capabilities |= SMB2_GLOBAL_CAP_LEASING;\n\n\tif (conn->cipher_type)\n\t\tconn->vals->capabilities |= SMB2_GLOBAL_CAP_ENCRYPTION;\n\n\tif (server_conf.flags & KSMBD_GLOBAL_FLAG_SMB3_MULTICHANNEL)\n\t\tconn->vals->capabilities |= SMB2_GLOBAL_CAP_MULTI_CHANNEL;\n\n\tINIT_LIST_HEAD(&conn->preauth_sess_table);\n\treturn 0;\n}",
        "func": "int init_smb3_11_server(struct ksmbd_conn *conn)\n{\n\tconn->vals = &smb311_server_values;\n\tconn->ops = &smb3_11_server_ops;\n\tconn->cmds = smb2_0_server_cmds;\n\tconn->max_cmds = ARRAY_SIZE(smb2_0_server_cmds);\n\tconn->max_credits = SMB2_MAX_CREDITS;\n\tconn->signing_algorithm = SIGNING_ALG_AES_CMAC;\n\n\tif (server_conf.flags & KSMBD_GLOBAL_FLAG_SMB2_LEASES)\n\t\tconn->vals->capabilities |= SMB2_GLOBAL_CAP_LEASING;\n\n\tif (server_conf.flags & KSMBD_GLOBAL_FLAG_SMB3_MULTICHANNEL)\n\t\tconn->vals->capabilities |= SMB2_GLOBAL_CAP_MULTI_CHANNEL;\n\n\tINIT_LIST_HEAD(&conn->preauth_sess_table);\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -10,9 +10,6 @@\n \tif (server_conf.flags & KSMBD_GLOBAL_FLAG_SMB2_LEASES)\n \t\tconn->vals->capabilities |= SMB2_GLOBAL_CAP_LEASING;\n \n-\tif (conn->cipher_type)\n-\t\tconn->vals->capabilities |= SMB2_GLOBAL_CAP_ENCRYPTION;\n-\n \tif (server_conf.flags & KSMBD_GLOBAL_FLAG_SMB3_MULTICHANNEL)\n \t\tconn->vals->capabilities |= SMB2_GLOBAL_CAP_MULTI_CHANNEL;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (conn->cipher_type)",
                "\t\tconn->vals->capabilities |= SMB2_GLOBAL_CAP_ENCRYPTION;",
                ""
            ],
            "added_lines": []
        }
    },
    {
        "cve_id": "CVE-2020-14093",
        "func_name": "muttmua/mutt/imap_open_connection",
        "description": "Mutt before 1.14.3 allows an IMAP fcc/postpone man-in-the-middle attack via a PREAUTH response.",
        "git_url": "https://github.com/muttmua/mutt/commit/3e88866dc60b5fa6aaba6fd7c1710c12c1c3cd01",
        "commit_title": "Prevent possible IMAP MITM via PREAUTH response.",
        "commit_text": " This is similar to CVE-2014-2567 and CVE-2020-12398.  STARTTLS is not allowed in the Authenticated state, so previously Mutt would implicitly mark the connection as authenticated and skip any encryption checking/enabling.  No credentials are exposed, but it does allow messages to be sent to an attacker, via postpone or fcc'ing for instance.  Reuse the $ssl_starttls quadoption \"in reverse\" to prompt to abort the connection if it is unencrypted.  Thanks very much to Damian Poddebniak and Fabian Ising from the Mnster University of Applied Sciences for reporting this issue, and their help in testing the fix.",
        "func_before": "int imap_open_connection (IMAP_DATA* idata)\n{\n  if (mutt_socket_open (idata->conn) < 0)\n    return -1;\n\n  idata->state = IMAP_CONNECTED;\n\n  if (imap_cmd_step (idata) != IMAP_CMD_OK)\n  {\n    imap_close_connection (idata);\n    return -1;\n  }\n\n  if (ascii_strncasecmp (\"* OK\", idata->buf, 4) == 0)\n  {\n    if (ascii_strncasecmp (\"* OK [CAPABILITY\", idata->buf, 16)\n        && imap_check_capabilities (idata))\n      goto bail;\n#if defined(USE_SSL)\n    /* Attempt STARTTLS if available and desired. */\n    if (!idata->conn->ssf && (option(OPTSSLFORCETLS) ||\n                              mutt_bit_isset (idata->capabilities, STARTTLS)))\n    {\n      int rc;\n\n      if (option(OPTSSLFORCETLS))\n        rc = MUTT_YES;\n      else if ((rc = query_quadoption (OPT_SSLSTARTTLS,\n                                       _(\"Secure connection with TLS?\"))) == -1)\n\tgoto err_close_conn;\n      if (rc == MUTT_YES)\n      {\n\tif ((rc = imap_exec (idata, \"STARTTLS\", IMAP_CMD_FAIL_OK)) == -1)\n\t  goto bail;\n\tif (rc != -2)\n\t{\n\t  if (mutt_ssl_starttls (idata->conn))\n\t  {\n\t    mutt_error (_(\"Could not negotiate TLS connection\"));\n\t    mutt_sleep (1);\n\t    goto err_close_conn;\n\t  }\n\t  else\n\t  {\n\t    /* RFC 2595 demands we recheck CAPABILITY after TLS completes. */\n\t    if (imap_exec (idata, \"CAPABILITY\", 0))\n\t      goto bail;\n\t  }\n\t}\n      }\n    }\n\n    if (option(OPTSSLFORCETLS) && ! idata->conn->ssf)\n    {\n      mutt_error _(\"Encrypted connection unavailable\");\n      mutt_sleep (1);\n      goto err_close_conn;\n    }\n#endif\n  }\n  else if (ascii_strncasecmp (\"* PREAUTH\", idata->buf, 9) == 0)\n  {\n    idata->state = IMAP_AUTHENTICATED;\n    if (imap_check_capabilities (idata) != 0)\n      goto bail;\n    FREE (&idata->capstr);\n  }\n  else\n  {\n    imap_error (\"imap_open_connection()\", idata->buf);\n    goto bail;\n  }\n\n  return 0;\n\n#if defined(USE_SSL)\nerr_close_conn:\n  imap_close_connection (idata);\n#endif\nbail:\n  FREE (&idata->capstr);\n  return -1;\n}",
        "func": "int imap_open_connection (IMAP_DATA* idata)\n{\n  if (mutt_socket_open (idata->conn) < 0)\n    return -1;\n\n  idata->state = IMAP_CONNECTED;\n\n  if (imap_cmd_step (idata) != IMAP_CMD_OK)\n  {\n    imap_close_connection (idata);\n    return -1;\n  }\n\n  if (ascii_strncasecmp (\"* OK\", idata->buf, 4) == 0)\n  {\n    if (ascii_strncasecmp (\"* OK [CAPABILITY\", idata->buf, 16)\n        && imap_check_capabilities (idata))\n      goto bail;\n#if defined(USE_SSL)\n    /* Attempt STARTTLS if available and desired. */\n    if (!idata->conn->ssf && (option(OPTSSLFORCETLS) ||\n                              mutt_bit_isset (idata->capabilities, STARTTLS)))\n    {\n      int rc;\n\n      if (option(OPTSSLFORCETLS))\n        rc = MUTT_YES;\n      else if ((rc = query_quadoption (OPT_SSLSTARTTLS,\n                                       _(\"Secure connection with TLS?\"))) == -1)\n\tgoto err_close_conn;\n      if (rc == MUTT_YES)\n      {\n\tif ((rc = imap_exec (idata, \"STARTTLS\", IMAP_CMD_FAIL_OK)) == -1)\n\t  goto bail;\n\tif (rc != -2)\n\t{\n\t  if (mutt_ssl_starttls (idata->conn))\n\t  {\n\t    mutt_error (_(\"Could not negotiate TLS connection\"));\n\t    mutt_sleep (1);\n\t    goto err_close_conn;\n\t  }\n\t  else\n\t  {\n\t    /* RFC 2595 demands we recheck CAPABILITY after TLS completes. */\n\t    if (imap_exec (idata, \"CAPABILITY\", 0))\n\t      goto bail;\n\t  }\n\t}\n      }\n    }\n\n    if (option(OPTSSLFORCETLS) && ! idata->conn->ssf)\n    {\n      mutt_error _(\"Encrypted connection unavailable\");\n      mutt_sleep (1);\n      goto err_close_conn;\n    }\n#endif\n  }\n  else if (ascii_strncasecmp (\"* PREAUTH\", idata->buf, 9) == 0)\n  {\n#if defined(USE_SSL)\n    /* An unencrypted PREAUTH response is most likely a MITM attack.\n     * Require a confirmation. */\n    if (!idata->conn->ssf)\n    {\n      if (option(OPTSSLFORCETLS) ||\n          (query_quadoption (OPT_SSLSTARTTLS,\n                             _(\"Abort unencrypted PREAUTH connection?\")) != MUTT_NO))\n      {\n        mutt_error _(\"Encrypted connection unavailable\");\n        mutt_sleep (1);\n        goto err_close_conn;\n      }\n    }\n#endif\n\n    idata->state = IMAP_AUTHENTICATED;\n    if (imap_check_capabilities (idata) != 0)\n      goto bail;\n    FREE (&idata->capstr);\n  }\n  else\n  {\n    imap_error (\"imap_open_connection()\", idata->buf);\n    goto bail;\n  }\n\n  return 0;\n\n#if defined(USE_SSL)\nerr_close_conn:\n  imap_close_connection (idata);\n#endif\nbail:\n  FREE (&idata->capstr);\n  return -1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -60,6 +60,22 @@\n   }\n   else if (ascii_strncasecmp (\"* PREAUTH\", idata->buf, 9) == 0)\n   {\n+#if defined(USE_SSL)\n+    /* An unencrypted PREAUTH response is most likely a MITM attack.\n+     * Require a confirmation. */\n+    if (!idata->conn->ssf)\n+    {\n+      if (option(OPTSSLFORCETLS) ||\n+          (query_quadoption (OPT_SSLSTARTTLS,\n+                             _(\"Abort unencrypted PREAUTH connection?\")) != MUTT_NO))\n+      {\n+        mutt_error _(\"Encrypted connection unavailable\");\n+        mutt_sleep (1);\n+        goto err_close_conn;\n+      }\n+    }\n+#endif\n+\n     idata->state = IMAP_AUTHENTICATED;\n     if (imap_check_capabilities (idata) != 0)\n       goto bail;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "#if defined(USE_SSL)",
                "    /* An unencrypted PREAUTH response is most likely a MITM attack.",
                "     * Require a confirmation. */",
                "    if (!idata->conn->ssf)",
                "    {",
                "      if (option(OPTSSLFORCETLS) ||",
                "          (query_quadoption (OPT_SSLSTARTTLS,",
                "                             _(\"Abort unencrypted PREAUTH connection?\")) != MUTT_NO))",
                "      {",
                "        mutt_error _(\"Encrypted connection unavailable\");",
                "        mutt_sleep (1);",
                "        goto err_close_conn;",
                "      }",
                "    }",
                "#endif",
                ""
            ]
        }
    }
]