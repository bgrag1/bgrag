[
    {
        "cve_id": "CVE-2019-10069",
        "func_name": "godotengine/godot/MultiplayerAPI::_process_rpc",
        "description": "In Godot through 3.1, remote code execution is possible due to the deserialization policy not being applied correctly.",
        "git_url": "https://github.com/godotengine/godot/commit/65c7fd209947d5b2e080c9818b5a0df7c7d02440",
        "commit_title": "Multiplayer API now respects allow_object_decoding",
        "commit_text": "",
        "func_before": "void MultiplayerAPI::_process_rpc(Node *p_node, const StringName &p_name, int p_from, const uint8_t *p_packet, int p_packet_len, int p_offset) {\n\n\tERR_EXPLAIN(\"Invalid packet received. Size too small.\");\n\tERR_FAIL_COND(p_offset >= p_packet_len);\n\n\t// Check that remote can call the RPC on this node.\n\tRPCMode rpc_mode = RPC_MODE_DISABLED;\n\tconst Map<StringName, RPCMode>::Element *E = p_node->get_node_rpc_mode(p_name);\n\tif (E) {\n\t\trpc_mode = E->get();\n\t} else if (p_node->get_script_instance()) {\n\t\trpc_mode = p_node->get_script_instance()->get_rpc_mode(p_name);\n\t}\n\n\tERR_EXPLAIN(\"RPC '\" + String(p_name) + \"' is not allowed from: \" + itos(p_from) + \". Mode is \" + itos((int)rpc_mode) + \", master is \" + itos(p_node->get_network_master()) + \".\");\n\tERR_FAIL_COND(!_can_call_mode(p_node, rpc_mode, p_from));\n\n\tint argc = p_packet[p_offset];\n\tVector<Variant> args;\n\tVector<const Variant *> argp;\n\targs.resize(argc);\n\targp.resize(argc);\n\n\tp_offset++;\n\n\tfor (int i = 0; i < argc; i++) {\n\n\t\tERR_EXPLAIN(\"Invalid packet received. Size too small.\");\n\t\tERR_FAIL_COND(p_offset >= p_packet_len);\n\n\t\tint vlen;\n\t\tError err = decode_variant(args.write[i], &p_packet[p_offset], p_packet_len - p_offset, &vlen);\n\t\tERR_EXPLAIN(\"Invalid packet received. Unable to decode RPC argument.\");\n\t\tERR_FAIL_COND(err != OK);\n\n\t\targp.write[i] = &args[i];\n\t\tp_offset += vlen;\n\t}\n\n\tVariant::CallError ce;\n\n\tp_node->call(p_name, (const Variant **)argp.ptr(), argc, ce);\n\tif (ce.error != Variant::CallError::CALL_OK) {\n\t\tString error = Variant::get_call_error_text(p_node, p_name, (const Variant **)argp.ptr(), argc, ce);\n\t\terror = \"RPC - \" + error;\n\t\tERR_PRINTS(error);\n\t}\n}",
        "func": "void MultiplayerAPI::_process_rpc(Node *p_node, const StringName &p_name, int p_from, const uint8_t *p_packet, int p_packet_len, int p_offset) {\n\n\tERR_EXPLAIN(\"Invalid packet received. Size too small.\");\n\tERR_FAIL_COND(p_offset >= p_packet_len);\n\n\t// Check that remote can call the RPC on this node.\n\tRPCMode rpc_mode = RPC_MODE_DISABLED;\n\tconst Map<StringName, RPCMode>::Element *E = p_node->get_node_rpc_mode(p_name);\n\tif (E) {\n\t\trpc_mode = E->get();\n\t} else if (p_node->get_script_instance()) {\n\t\trpc_mode = p_node->get_script_instance()->get_rpc_mode(p_name);\n\t}\n\n\tERR_EXPLAIN(\"RPC '\" + String(p_name) + \"' is not allowed from: \" + itos(p_from) + \". Mode is \" + itos((int)rpc_mode) + \", master is \" + itos(p_node->get_network_master()) + \".\");\n\tERR_FAIL_COND(!_can_call_mode(p_node, rpc_mode, p_from));\n\n\tint argc = p_packet[p_offset];\n\tVector<Variant> args;\n\tVector<const Variant *> argp;\n\targs.resize(argc);\n\targp.resize(argc);\n\n\tp_offset++;\n\n\tfor (int i = 0; i < argc; i++) {\n\n\t\tERR_EXPLAIN(\"Invalid packet received. Size too small.\");\n\t\tERR_FAIL_COND(p_offset >= p_packet_len);\n\n\t\tint vlen;\n\t\tError err = decode_variant(args.write[i], &p_packet[p_offset], p_packet_len - p_offset, &vlen, network_peer->is_object_decoding_allowed());\n\t\tERR_EXPLAIN(\"Invalid packet received. Unable to decode RPC argument.\");\n\t\tERR_FAIL_COND(err != OK);\n\n\t\targp.write[i] = &args[i];\n\t\tp_offset += vlen;\n\t}\n\n\tVariant::CallError ce;\n\n\tp_node->call(p_name, (const Variant **)argp.ptr(), argc, ce);\n\tif (ce.error != Variant::CallError::CALL_OK) {\n\t\tString error = Variant::get_call_error_text(p_node, p_name, (const Variant **)argp.ptr(), argc, ce);\n\t\terror = \"RPC - \" + error;\n\t\tERR_PRINTS(error);\n\t}\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -29,7 +29,7 @@\n \t\tERR_FAIL_COND(p_offset >= p_packet_len);\n \n \t\tint vlen;\n-\t\tError err = decode_variant(args.write[i], &p_packet[p_offset], p_packet_len - p_offset, &vlen);\n+\t\tError err = decode_variant(args.write[i], &p_packet[p_offset], p_packet_len - p_offset, &vlen, network_peer->is_object_decoding_allowed());\n \t\tERR_EXPLAIN(\"Invalid packet received. Unable to decode RPC argument.\");\n \t\tERR_FAIL_COND(err != OK);\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tError err = decode_variant(args.write[i], &p_packet[p_offset], p_packet_len - p_offset, &vlen);"
            ],
            "added_lines": [
                "\t\tError err = decode_variant(args.write[i], &p_packet[p_offset], p_packet_len - p_offset, &vlen, network_peer->is_object_decoding_allowed());"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-10069",
        "func_name": "godotengine/godot/MultiplayerAPI::_process_rset",
        "description": "In Godot through 3.1, remote code execution is possible due to the deserialization policy not being applied correctly.",
        "git_url": "https://github.com/godotengine/godot/commit/65c7fd209947d5b2e080c9818b5a0df7c7d02440",
        "commit_title": "Multiplayer API now respects allow_object_decoding",
        "commit_text": "",
        "func_before": "void MultiplayerAPI::_process_rset(Node *p_node, const StringName &p_name, int p_from, const uint8_t *p_packet, int p_packet_len, int p_offset) {\n\n\tERR_EXPLAIN(\"Invalid packet received. Size too small.\");\n\tERR_FAIL_COND(p_offset >= p_packet_len);\n\n\t// Check that remote can call the RSET on this node.\n\tRPCMode rset_mode = RPC_MODE_DISABLED;\n\tconst Map<StringName, RPCMode>::Element *E = p_node->get_node_rset_mode(p_name);\n\tif (E) {\n\t\trset_mode = E->get();\n\t} else if (p_node->get_script_instance()) {\n\t\trset_mode = p_node->get_script_instance()->get_rset_mode(p_name);\n\t}\n\n\tERR_EXPLAIN(\"RSET '\" + String(p_name) + \"' is not allowed from: \" + itos(p_from) + \". Mode is \" + itos((int)rset_mode) + \", master is \" + itos(p_node->get_network_master()) + \".\");\n\tERR_FAIL_COND(!_can_call_mode(p_node, rset_mode, p_from));\n\n\tVariant value;\n\tError err = decode_variant(value, &p_packet[p_offset], p_packet_len - p_offset);\n\n\tERR_EXPLAIN(\"Invalid packet received. Unable to decode RSET value.\");\n\tERR_FAIL_COND(err != OK);\n\n\tbool valid;\n\n\tp_node->set(p_name, value, &valid);\n\tif (!valid) {\n\t\tString error = \"Error setting remote property '\" + String(p_name) + \"', not found in object of type \" + p_node->get_class();\n\t\tERR_PRINTS(error);\n\t}\n}",
        "func": "void MultiplayerAPI::_process_rset(Node *p_node, const StringName &p_name, int p_from, const uint8_t *p_packet, int p_packet_len, int p_offset) {\n\n\tERR_EXPLAIN(\"Invalid packet received. Size too small.\");\n\tERR_FAIL_COND(p_offset >= p_packet_len);\n\n\t// Check that remote can call the RSET on this node.\n\tRPCMode rset_mode = RPC_MODE_DISABLED;\n\tconst Map<StringName, RPCMode>::Element *E = p_node->get_node_rset_mode(p_name);\n\tif (E) {\n\t\trset_mode = E->get();\n\t} else if (p_node->get_script_instance()) {\n\t\trset_mode = p_node->get_script_instance()->get_rset_mode(p_name);\n\t}\n\n\tERR_EXPLAIN(\"RSET '\" + String(p_name) + \"' is not allowed from: \" + itos(p_from) + \". Mode is \" + itos((int)rset_mode) + \", master is \" + itos(p_node->get_network_master()) + \".\");\n\tERR_FAIL_COND(!_can_call_mode(p_node, rset_mode, p_from));\n\n\tVariant value;\n\tError err = decode_variant(value, &p_packet[p_offset], p_packet_len - p_offset, NULL, network_peer->is_object_decoding_allowed());\n\n\tERR_EXPLAIN(\"Invalid packet received. Unable to decode RSET value.\");\n\tERR_FAIL_COND(err != OK);\n\n\tbool valid;\n\n\tp_node->set(p_name, value, &valid);\n\tif (!valid) {\n\t\tString error = \"Error setting remote property '\" + String(p_name) + \"', not found in object of type \" + p_node->get_class();\n\t\tERR_PRINTS(error);\n\t}\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -16,7 +16,7 @@\n \tERR_FAIL_COND(!_can_call_mode(p_node, rset_mode, p_from));\n \n \tVariant value;\n-\tError err = decode_variant(value, &p_packet[p_offset], p_packet_len - p_offset);\n+\tError err = decode_variant(value, &p_packet[p_offset], p_packet_len - p_offset, NULL, network_peer->is_object_decoding_allowed());\n \n \tERR_EXPLAIN(\"Invalid packet received. Unable to decode RSET value.\");\n \tERR_FAIL_COND(err != OK);",
        "diff_line_info": {
            "deleted_lines": [
                "\tError err = decode_variant(value, &p_packet[p_offset], p_packet_len - p_offset);"
            ],
            "added_lines": [
                "\tError err = decode_variant(value, &p_packet[p_offset], p_packet_len - p_offset, NULL, network_peer->is_object_decoding_allowed());"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-10069",
        "func_name": "godotengine/godot/MultiplayerAPI::_send_rpc",
        "description": "In Godot through 3.1, remote code execution is possible due to the deserialization policy not being applied correctly.",
        "git_url": "https://github.com/godotengine/godot/commit/65c7fd209947d5b2e080c9818b5a0df7c7d02440",
        "commit_title": "Multiplayer API now respects allow_object_decoding",
        "commit_text": "",
        "func_before": "void MultiplayerAPI::_send_rpc(Node *p_from, int p_to, bool p_unreliable, bool p_set, const StringName &p_name, const Variant **p_arg, int p_argcount) {\n\n\tif (network_peer.is_null()) {\n\t\tERR_EXPLAIN(\"Attempt to remote call/set when networking is not active in SceneTree.\");\n\t\tERR_FAIL();\n\t}\n\n\tif (network_peer->get_connection_status() == NetworkedMultiplayerPeer::CONNECTION_CONNECTING) {\n\t\tERR_EXPLAIN(\"Attempt to remote call/set when networking is not connected yet in SceneTree.\");\n\t\tERR_FAIL();\n\t}\n\n\tif (network_peer->get_connection_status() == NetworkedMultiplayerPeer::CONNECTION_DISCONNECTED) {\n\t\tERR_EXPLAIN(\"Attempt to remote call/set when networking is disconnected.\");\n\t\tERR_FAIL();\n\t}\n\n\tif (p_argcount > 255) {\n\t\tERR_EXPLAIN(\"Too many arguments >255.\");\n\t\tERR_FAIL();\n\t}\n\n\tif (p_to != 0 && !connected_peers.has(ABS(p_to))) {\n\t\tif (p_to == network_peer->get_unique_id()) {\n\t\t\tERR_EXPLAIN(\"Attempt to remote call/set yourself! unique ID: \" + itos(network_peer->get_unique_id()));\n\t\t} else {\n\t\t\tERR_EXPLAIN(\"Attempt to remote call unexisting ID: \" + itos(p_to));\n\t\t}\n\n\t\tERR_FAIL();\n\t}\n\n\tNodePath from_path = (root_node->get_path()).rel_path_to(p_from->get_path());\n\tERR_EXPLAIN(\"Unable to send RPC. Relative path is empty. THIS IS LIKELY A BUG IN THE ENGINE!\");\n\tERR_FAIL_COND(from_path.is_empty());\n\n\t// See if the path is cached.\n\tPathSentCache *psc = path_send_cache.getptr(from_path);\n\tif (!psc) {\n\t\t// Path is not cached, create.\n\t\tpath_send_cache[from_path] = PathSentCache();\n\t\tpsc = path_send_cache.getptr(from_path);\n\t\tpsc->id = last_send_cache_id++;\n\t}\n\n\t// Create base packet, lots of hardcode because it must be tight.\n\n\tint ofs = 0;\n\n#define MAKE_ROOM(m_amount) \\\n\tif (packet_cache.size() < m_amount) packet_cache.resize(m_amount);\n\n\t// Encode type.\n\tMAKE_ROOM(1);\n\tpacket_cache.write[0] = p_set ? NETWORK_COMMAND_REMOTE_SET : NETWORK_COMMAND_REMOTE_CALL;\n\tofs += 1;\n\n\t// Encode ID.\n\tMAKE_ROOM(ofs + 4);\n\tencode_uint32(psc->id, &(packet_cache.write[ofs]));\n\tofs += 4;\n\n\t// Encode function name.\n\tCharString name = String(p_name).utf8();\n\tint len = encode_cstring(name.get_data(), NULL);\n\tMAKE_ROOM(ofs + len);\n\tencode_cstring(name.get_data(), &(packet_cache.write[ofs]));\n\tofs += len;\n\n\tif (p_set) {\n\t\t// Set argument.\n\t\tError err = encode_variant(*p_arg[0], NULL, len);\n\t\tERR_EXPLAIN(\"Unable to encode RSET value. THIS IS LIKELY A BUG IN THE ENGINE!\");\n\t\tERR_FAIL_COND(err != OK);\n\t\tMAKE_ROOM(ofs + len);\n\t\tencode_variant(*p_arg[0], &(packet_cache.write[ofs]), len);\n\t\tofs += len;\n\n\t} else {\n\t\t// Call arguments.\n\t\tMAKE_ROOM(ofs + 1);\n\t\tpacket_cache.write[ofs] = p_argcount;\n\t\tofs += 1;\n\t\tfor (int i = 0; i < p_argcount; i++) {\n\t\t\tError err = encode_variant(*p_arg[i], NULL, len);\n\t\t\tERR_EXPLAIN(\"Unable to encode RPC argument. THIS IS LIKELY A BUG IN THE ENGINE!\");\n\t\t\tERR_FAIL_COND(err != OK);\n\t\t\tMAKE_ROOM(ofs + len);\n\t\t\tencode_variant(*p_arg[i], &(packet_cache.write[ofs]), len);\n\t\t\tofs += len;\n\t\t}\n\t}\n\n\t// See if all peers have cached path (is so, call can be fast).\n\tbool has_all_peers = _send_confirm_path(from_path, psc, p_to);\n\n\t// Take chance and set transfer mode, since all send methods will use it.\n\tnetwork_peer->set_transfer_mode(p_unreliable ? NetworkedMultiplayerPeer::TRANSFER_MODE_UNRELIABLE : NetworkedMultiplayerPeer::TRANSFER_MODE_RELIABLE);\n\n\tif (has_all_peers) {\n\n\t\t// They all have verified paths, so send fast.\n\t\tnetwork_peer->set_target_peer(p_to); // To all of you.\n\t\tnetwork_peer->put_packet(packet_cache.ptr(), ofs); // A message with love.\n\t} else {\n\t\t// Not all verified path, so send one by one.\n\n\t\t// Append path at the end, since we will need it for some packets.\n\t\tCharString pname = String(from_path).utf8();\n\t\tint path_len = encode_cstring(pname.get_data(), NULL);\n\t\tMAKE_ROOM(ofs + path_len);\n\t\tencode_cstring(pname.get_data(), &(packet_cache.write[ofs]));\n\n\t\tfor (Set<int>::Element *E = connected_peers.front(); E; E = E->next()) {\n\n\t\t\tif (p_to < 0 && E->get() == -p_to)\n\t\t\t\tcontinue; // Continue, excluded.\n\n\t\t\tif (p_to > 0 && E->get() != p_to)\n\t\t\t\tcontinue; // Continue, not for this peer.\n\n\t\t\tMap<int, bool>::Element *F = psc->confirmed_peers.find(E->get());\n\t\t\tERR_CONTINUE(!F); // Should never happen.\n\n\t\t\tnetwork_peer->set_target_peer(E->get()); // To this one specifically.\n\n\t\t\tif (F->get()) {\n\t\t\t\t// This one confirmed path, so use id.\n\t\t\t\tencode_uint32(psc->id, &(packet_cache.write[1]));\n\t\t\t\tnetwork_peer->put_packet(packet_cache.ptr(), ofs);\n\t\t\t} else {\n\t\t\t\t// This one did not confirm path yet, so use entire path (sorry!).\n\t\t\t\tencode_uint32(0x80000000 | ofs, &(packet_cache.write[1])); // Offset to path and flag.\n\t\t\t\tnetwork_peer->put_packet(packet_cache.ptr(), ofs + path_len);\n\t\t\t}\n\t\t}\n\t}\n}",
        "func": "void MultiplayerAPI::_send_rpc(Node *p_from, int p_to, bool p_unreliable, bool p_set, const StringName &p_name, const Variant **p_arg, int p_argcount) {\n\n\tif (network_peer.is_null()) {\n\t\tERR_EXPLAIN(\"Attempt to remote call/set when networking is not active in SceneTree.\");\n\t\tERR_FAIL();\n\t}\n\n\tif (network_peer->get_connection_status() == NetworkedMultiplayerPeer::CONNECTION_CONNECTING) {\n\t\tERR_EXPLAIN(\"Attempt to remote call/set when networking is not connected yet in SceneTree.\");\n\t\tERR_FAIL();\n\t}\n\n\tif (network_peer->get_connection_status() == NetworkedMultiplayerPeer::CONNECTION_DISCONNECTED) {\n\t\tERR_EXPLAIN(\"Attempt to remote call/set when networking is disconnected.\");\n\t\tERR_FAIL();\n\t}\n\n\tif (p_argcount > 255) {\n\t\tERR_EXPLAIN(\"Too many arguments >255.\");\n\t\tERR_FAIL();\n\t}\n\n\tif (p_to != 0 && !connected_peers.has(ABS(p_to))) {\n\t\tif (p_to == network_peer->get_unique_id()) {\n\t\t\tERR_EXPLAIN(\"Attempt to remote call/set yourself! unique ID: \" + itos(network_peer->get_unique_id()));\n\t\t} else {\n\t\t\tERR_EXPLAIN(\"Attempt to remote call unexisting ID: \" + itos(p_to));\n\t\t}\n\n\t\tERR_FAIL();\n\t}\n\n\tNodePath from_path = (root_node->get_path()).rel_path_to(p_from->get_path());\n\tERR_EXPLAIN(\"Unable to send RPC. Relative path is empty. THIS IS LIKELY A BUG IN THE ENGINE!\");\n\tERR_FAIL_COND(from_path.is_empty());\n\n\t// See if the path is cached.\n\tPathSentCache *psc = path_send_cache.getptr(from_path);\n\tif (!psc) {\n\t\t// Path is not cached, create.\n\t\tpath_send_cache[from_path] = PathSentCache();\n\t\tpsc = path_send_cache.getptr(from_path);\n\t\tpsc->id = last_send_cache_id++;\n\t}\n\n\t// Create base packet, lots of hardcode because it must be tight.\n\n\tint ofs = 0;\n\n#define MAKE_ROOM(m_amount) \\\n\tif (packet_cache.size() < m_amount) packet_cache.resize(m_amount);\n\n\t// Encode type.\n\tMAKE_ROOM(1);\n\tpacket_cache.write[0] = p_set ? NETWORK_COMMAND_REMOTE_SET : NETWORK_COMMAND_REMOTE_CALL;\n\tofs += 1;\n\n\t// Encode ID.\n\tMAKE_ROOM(ofs + 4);\n\tencode_uint32(psc->id, &(packet_cache.write[ofs]));\n\tofs += 4;\n\n\t// Encode function name.\n\tCharString name = String(p_name).utf8();\n\tint len = encode_cstring(name.get_data(), NULL);\n\tMAKE_ROOM(ofs + len);\n\tencode_cstring(name.get_data(), &(packet_cache.write[ofs]));\n\tofs += len;\n\n\tif (p_set) {\n\t\t// Set argument.\n\t\tError err = encode_variant(*p_arg[0], NULL, len, !network_peer->is_object_decoding_allowed());\n\t\tERR_EXPLAIN(\"Unable to encode RSET value. THIS IS LIKELY A BUG IN THE ENGINE!\");\n\t\tERR_FAIL_COND(err != OK);\n\t\tMAKE_ROOM(ofs + len);\n\t\tencode_variant(*p_arg[0], &(packet_cache.write[ofs]), len, !network_peer->is_object_decoding_allowed());\n\t\tofs += len;\n\n\t} else {\n\t\t// Call arguments.\n\t\tMAKE_ROOM(ofs + 1);\n\t\tpacket_cache.write[ofs] = p_argcount;\n\t\tofs += 1;\n\t\tfor (int i = 0; i < p_argcount; i++) {\n\t\t\tError err = encode_variant(*p_arg[i], NULL, len, !network_peer->is_object_decoding_allowed());\n\t\t\tERR_EXPLAIN(\"Unable to encode RPC argument. THIS IS LIKELY A BUG IN THE ENGINE!\");\n\t\t\tERR_FAIL_COND(err != OK);\n\t\t\tMAKE_ROOM(ofs + len);\n\t\t\tencode_variant(*p_arg[i], &(packet_cache.write[ofs]), len, !network_peer->is_object_decoding_allowed());\n\t\t\tofs += len;\n\t\t}\n\t}\n\n\t// See if all peers have cached path (is so, call can be fast).\n\tbool has_all_peers = _send_confirm_path(from_path, psc, p_to);\n\n\t// Take chance and set transfer mode, since all send methods will use it.\n\tnetwork_peer->set_transfer_mode(p_unreliable ? NetworkedMultiplayerPeer::TRANSFER_MODE_UNRELIABLE : NetworkedMultiplayerPeer::TRANSFER_MODE_RELIABLE);\n\n\tif (has_all_peers) {\n\n\t\t// They all have verified paths, so send fast.\n\t\tnetwork_peer->set_target_peer(p_to); // To all of you.\n\t\tnetwork_peer->put_packet(packet_cache.ptr(), ofs); // A message with love.\n\t} else {\n\t\t// Not all verified path, so send one by one.\n\n\t\t// Append path at the end, since we will need it for some packets.\n\t\tCharString pname = String(from_path).utf8();\n\t\tint path_len = encode_cstring(pname.get_data(), NULL);\n\t\tMAKE_ROOM(ofs + path_len);\n\t\tencode_cstring(pname.get_data(), &(packet_cache.write[ofs]));\n\n\t\tfor (Set<int>::Element *E = connected_peers.front(); E; E = E->next()) {\n\n\t\t\tif (p_to < 0 && E->get() == -p_to)\n\t\t\t\tcontinue; // Continue, excluded.\n\n\t\t\tif (p_to > 0 && E->get() != p_to)\n\t\t\t\tcontinue; // Continue, not for this peer.\n\n\t\t\tMap<int, bool>::Element *F = psc->confirmed_peers.find(E->get());\n\t\t\tERR_CONTINUE(!F); // Should never happen.\n\n\t\t\tnetwork_peer->set_target_peer(E->get()); // To this one specifically.\n\n\t\t\tif (F->get()) {\n\t\t\t\t// This one confirmed path, so use id.\n\t\t\t\tencode_uint32(psc->id, &(packet_cache.write[1]));\n\t\t\t\tnetwork_peer->put_packet(packet_cache.ptr(), ofs);\n\t\t\t} else {\n\t\t\t\t// This one did not confirm path yet, so use entire path (sorry!).\n\t\t\t\tencode_uint32(0x80000000 | ofs, &(packet_cache.write[1])); // Offset to path and flag.\n\t\t\t\tnetwork_peer->put_packet(packet_cache.ptr(), ofs + path_len);\n\t\t\t}\n\t\t}\n\t}\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -69,11 +69,11 @@\n \n \tif (p_set) {\n \t\t// Set argument.\n-\t\tError err = encode_variant(*p_arg[0], NULL, len);\n+\t\tError err = encode_variant(*p_arg[0], NULL, len, !network_peer->is_object_decoding_allowed());\n \t\tERR_EXPLAIN(\"Unable to encode RSET value. THIS IS LIKELY A BUG IN THE ENGINE!\");\n \t\tERR_FAIL_COND(err != OK);\n \t\tMAKE_ROOM(ofs + len);\n-\t\tencode_variant(*p_arg[0], &(packet_cache.write[ofs]), len);\n+\t\tencode_variant(*p_arg[0], &(packet_cache.write[ofs]), len, !network_peer->is_object_decoding_allowed());\n \t\tofs += len;\n \n \t} else {\n@@ -82,11 +82,11 @@\n \t\tpacket_cache.write[ofs] = p_argcount;\n \t\tofs += 1;\n \t\tfor (int i = 0; i < p_argcount; i++) {\n-\t\t\tError err = encode_variant(*p_arg[i], NULL, len);\n+\t\t\tError err = encode_variant(*p_arg[i], NULL, len, !network_peer->is_object_decoding_allowed());\n \t\t\tERR_EXPLAIN(\"Unable to encode RPC argument. THIS IS LIKELY A BUG IN THE ENGINE!\");\n \t\t\tERR_FAIL_COND(err != OK);\n \t\t\tMAKE_ROOM(ofs + len);\n-\t\t\tencode_variant(*p_arg[i], &(packet_cache.write[ofs]), len);\n+\t\t\tencode_variant(*p_arg[i], &(packet_cache.write[ofs]), len, !network_peer->is_object_decoding_allowed());\n \t\t\tofs += len;\n \t\t}\n \t}",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tError err = encode_variant(*p_arg[0], NULL, len);",
                "\t\tencode_variant(*p_arg[0], &(packet_cache.write[ofs]), len);",
                "\t\t\tError err = encode_variant(*p_arg[i], NULL, len);",
                "\t\t\tencode_variant(*p_arg[i], &(packet_cache.write[ofs]), len);"
            ],
            "added_lines": [
                "\t\tError err = encode_variant(*p_arg[0], NULL, len, !network_peer->is_object_decoding_allowed());",
                "\t\tencode_variant(*p_arg[0], &(packet_cache.write[ofs]), len, !network_peer->is_object_decoding_allowed());",
                "\t\t\tError err = encode_variant(*p_arg[i], NULL, len, !network_peer->is_object_decoding_allowed());",
                "\t\t\tencode_variant(*p_arg[i], &(packet_cache.write[ofs]), len, !network_peer->is_object_decoding_allowed());"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-7124",
        "func_name": "php/php-src/object_common1",
        "description": "ext/standard/var_unserializer.c in PHP before 5.6.25 and 7.x before 7.0.10 mishandles certain invalid objects, which allows remote attackers to cause a denial of service or possibly have unspecified other impact via crafted serialized data that leads to a (1) __destruct call or (2) magic method call.",
        "git_url": "https://github.com/php/php-src/commit/448c9be157f4147e121f1a2a524536c75c9c6059",
        "commit_title": "Fix bug #72663 - destroy broken object when unserializing",
        "commit_text": "",
        "func_before": "static inline long object_common1(UNSERIALIZE_PARAMETER, zend_class_entry *ce)\n{\n\tlong elements;\n\n\telements = parse_iv2((*p) + 2, p);\n\n\t(*p) += 2;\n\t\n\tif (ce->serialize == NULL) {\n\t\tobject_init_ex(*rval, ce);\n\t} else {\n\t\t/* If this class implements Serializable, it should not land here but in object_custom(). The passed string\n\t\tobviously doesn't descend from the regular serializer. */\n\t\tzend_error(E_WARNING, \"Erroneous data format for unserializing '%s'\", ce->name);\n\t\treturn 0;\n\t}\n\n\treturn elements;\n}",
        "func": "static inline long object_common1(UNSERIALIZE_PARAMETER, zend_class_entry *ce)\n{\n\tlong elements;\n\n\telements = parse_iv2((*p) + 2, p);\n\n\t(*p) += 2;\n\n\tif (ce->serialize == NULL) {\n\t\tobject_init_ex(*rval, ce);\n\t} else {\n\t\t/* If this class implements Serializable, it should not land here but in object_custom(). The passed string\n\t\tobviously doesn't descend from the regular serializer. */\n\t\tzend_error(E_WARNING, \"Erroneous data format for unserializing '%s'\", ce->name);\n\t\treturn 0;\n\t}\n\n\treturn elements;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,7 +5,7 @@\n \telements = parse_iv2((*p) + 2, p);\n \n \t(*p) += 2;\n-\t\n+\n \tif (ce->serialize == NULL) {\n \t\tobject_init_ex(*rval, ce);\n \t} else {",
        "diff_line_info": {
            "deleted_lines": [
                "\t"
            ],
            "added_lines": [
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2016-7124",
        "func_name": "php/php-src/object_common2",
        "description": "ext/standard/var_unserializer.c in PHP before 5.6.25 and 7.x before 7.0.10 mishandles certain invalid objects, which allows remote attackers to cause a denial of service or possibly have unspecified other impact via crafted serialized data that leads to a (1) __destruct call or (2) magic method call.",
        "git_url": "https://github.com/php/php-src/commit/448c9be157f4147e121f1a2a524536c75c9c6059",
        "commit_title": "Fix bug #72663 - destroy broken object when unserializing",
        "commit_text": "",
        "func_before": "static inline int object_common2(UNSERIALIZE_PARAMETER, long elements)\n{\n\tzval *retval_ptr = NULL;\n\tzval fname;\n\n\tif (Z_TYPE_PP(rval) != IS_OBJECT) {\n\t\treturn 0;\n\t}\n\n\tif (!process_nested_data(UNSERIALIZE_PASSTHRU, Z_OBJPROP_PP(rval), elements, 1)) {\n\t\treturn 0;\n\t}\n\n\tif (Z_OBJCE_PP(rval) != PHP_IC_ENTRY &&\n\t\tzend_hash_exists(&Z_OBJCE_PP(rval)->function_table, \"__wakeup\", sizeof(\"__wakeup\"))) {\n\t\tINIT_PZVAL(&fname);\n\t\tZVAL_STRINGL(&fname, \"__wakeup\", sizeof(\"__wakeup\") - 1, 0);\n\t\tBG(serialize_lock)++;\n\t\tcall_user_function_ex(CG(function_table), rval, &fname, &retval_ptr, 0, 0, 1, NULL TSRMLS_CC);\n\t\tBG(serialize_lock)--;\n\t}\n\n\tif (retval_ptr) {\n\t\tzval_ptr_dtor(&retval_ptr);\n\t}\n\n\tif (EG(exception)) {\n\t\treturn 0;\n\t}\n\n\treturn finish_nested_data(UNSERIALIZE_PASSTHRU);\n\n}",
        "func": "static inline int object_common2(UNSERIALIZE_PARAMETER, long elements)\n{\n\tzval *retval_ptr = NULL;\n\tzval fname;\n\n\tif (Z_TYPE_PP(rval) != IS_OBJECT) {\n\t\treturn 0;\n\t}\n\n\tif (!process_nested_data(UNSERIALIZE_PASSTHRU, Z_OBJPROP_PP(rval), elements, 1)) {\n\t    /* We've got partially constructed object on our hands here. Wipe it */\n\t    zend_hash_clean(Z_OBJPROP_PP(rval));\n\t    ZVAL_NULL(*rval);\n\t\treturn 0;\n\t}\n\n\tif (Z_OBJCE_PP(rval) != PHP_IC_ENTRY &&\n\t\tzend_hash_exists(&Z_OBJCE_PP(rval)->function_table, \"__wakeup\", sizeof(\"__wakeup\"))) {\n\t\tINIT_PZVAL(&fname);\n\t\tZVAL_STRINGL(&fname, \"__wakeup\", sizeof(\"__wakeup\") - 1, 0);\n\t\tBG(serialize_lock)++;\n\t\tcall_user_function_ex(CG(function_table), rval, &fname, &retval_ptr, 0, 0, 1, NULL TSRMLS_CC);\n\t\tBG(serialize_lock)--;\n\t}\n\n\tif (retval_ptr) {\n\t\tzval_ptr_dtor(&retval_ptr);\n\t}\n\n\tif (EG(exception)) {\n\t\treturn 0;\n\t}\n\n\treturn finish_nested_data(UNSERIALIZE_PASSTHRU);\n\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -8,6 +8,9 @@\n \t}\n \n \tif (!process_nested_data(UNSERIALIZE_PASSTHRU, Z_OBJPROP_PP(rval), elements, 1)) {\n+\t    /* We've got partially constructed object on our hands here. Wipe it */\n+\t    zend_hash_clean(Z_OBJPROP_PP(rval));\n+\t    ZVAL_NULL(*rval);\n \t\treturn 0;\n \t}\n ",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t    /* We've got partially constructed object on our hands here. Wipe it */",
                "\t    zend_hash_clean(Z_OBJPROP_PP(rval));",
                "\t    ZVAL_NULL(*rval);"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-7124",
        "func_name": "php/php-src/object_common1",
        "description": "ext/standard/var_unserializer.c in PHP before 5.6.25 and 7.x before 7.0.10 mishandles certain invalid objects, which allows remote attackers to cause a denial of service or possibly have unspecified other impact via crafted serialized data that leads to a (1) __destruct call or (2) magic method call.",
        "git_url": "https://github.com/php/php-src/commit/c1cfd6a9fe23765191ea2f654790c7b127d4b797",
        "commit_title": "Fix bug #72663 - destroy broken object when unserializing",
        "commit_text": "",
        "func_before": "static inline long object_common1(UNSERIALIZE_PARAMETER, zend_class_entry *ce)\n{\n\tlong elements;\n\n\telements = parse_iv2((*p) + 2, p);\n\n\t(*p) += 2;\n\t\n\tif (ce->serialize == NULL) {\n\t\tobject_init_ex(*rval, ce);\n\t} else {\n\t\t/* If this class implements Serializable, it should not land here but in object_custom(). The passed string\n\t\tobviously doesn't descend from the regular serializer. */\n\t\tzend_error(E_WARNING, \"Erroneous data format for unserializing '%s'\", ce->name);\n\t\treturn 0;\n\t}\n\n\treturn elements;\n}",
        "func": "static inline long object_common1(UNSERIALIZE_PARAMETER, zend_class_entry *ce)\n{\n\tlong elements;\n\n\telements = parse_iv2((*p) + 2, p);\n\n\t(*p) += 2;\n\n\tif (ce->serialize == NULL) {\n\t\tobject_init_ex(*rval, ce);\n\t} else {\n\t\t/* If this class implements Serializable, it should not land here but in object_custom(). The passed string\n\t\tobviously doesn't descend from the regular serializer. */\n\t\tzend_error(E_WARNING, \"Erroneous data format for unserializing '%s'\", ce->name);\n\t\treturn 0;\n\t}\n\n\treturn elements;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,7 +5,7 @@\n \telements = parse_iv2((*p) + 2, p);\n \n \t(*p) += 2;\n-\t\n+\n \tif (ce->serialize == NULL) {\n \t\tobject_init_ex(*rval, ce);\n \t} else {",
        "diff_line_info": {
            "deleted_lines": [
                "\t"
            ],
            "added_lines": [
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2016-7124",
        "func_name": "php/php-src/object_common2",
        "description": "ext/standard/var_unserializer.c in PHP before 5.6.25 and 7.x before 7.0.10 mishandles certain invalid objects, which allows remote attackers to cause a denial of service or possibly have unspecified other impact via crafted serialized data that leads to a (1) __destruct call or (2) magic method call.",
        "git_url": "https://github.com/php/php-src/commit/c1cfd6a9fe23765191ea2f654790c7b127d4b797",
        "commit_title": "Fix bug #72663 - destroy broken object when unserializing",
        "commit_text": "",
        "func_before": "static inline int object_common2(UNSERIALIZE_PARAMETER, long elements)\n{\n\tzval *retval_ptr = NULL;\n\tzval fname;\n\n\tif (Z_TYPE_PP(rval) != IS_OBJECT) {\n\t\treturn 0;\n\t}\n\n\tif (!process_nested_data(UNSERIALIZE_PASSTHRU, Z_OBJPROP_PP(rval), elements, 1)) {\n\t\treturn 0;\n\t}\n\n\tif (Z_OBJCE_PP(rval) != PHP_IC_ENTRY &&\n\t\tzend_hash_exists(&Z_OBJCE_PP(rval)->function_table, \"__wakeup\", sizeof(\"__wakeup\"))) {\n\t\tINIT_PZVAL(&fname);\n\t\tZVAL_STRINGL(&fname, \"__wakeup\", sizeof(\"__wakeup\") - 1, 0);\n\t\tBG(serialize_lock)++;\n\t\tcall_user_function_ex(CG(function_table), rval, &fname, &retval_ptr, 0, 0, 1, NULL TSRMLS_CC);\n\t\tBG(serialize_lock)--;\n\t}\n\n\tif (retval_ptr) {\n\t\tzval_ptr_dtor(&retval_ptr);\n\t}\n\n\tif (EG(exception)) {\n\t\treturn 0;\n\t}\n\n\treturn finish_nested_data(UNSERIALIZE_PASSTHRU);\n\n}",
        "func": "static inline int object_common2(UNSERIALIZE_PARAMETER, long elements)\n{\n\tzval *retval_ptr = NULL;\n\tzval fname;\n\n\tif (Z_TYPE_PP(rval) != IS_OBJECT) {\n\t\treturn 0;\n\t}\n\n\tif (!process_nested_data(UNSERIALIZE_PASSTHRU, Z_OBJPROP_PP(rval), elements, 1)) {\n\t    /* We've got partially constructed object on our hands here. Wipe it */\n\t    zend_hash_clean(Z_OBJPROP_PP(rval));\n\t    ZVAL_NULL(*rval);\n\t\treturn 0;\n\t}\n\n\tif (Z_OBJCE_PP(rval) != PHP_IC_ENTRY &&\n\t\tzend_hash_exists(&Z_OBJCE_PP(rval)->function_table, \"__wakeup\", sizeof(\"__wakeup\"))) {\n\t\tINIT_PZVAL(&fname);\n\t\tZVAL_STRINGL(&fname, \"__wakeup\", sizeof(\"__wakeup\") - 1, 0);\n\t\tBG(serialize_lock)++;\n\t\tcall_user_function_ex(CG(function_table), rval, &fname, &retval_ptr, 0, 0, 1, NULL TSRMLS_CC);\n\t\tBG(serialize_lock)--;\n\t}\n\n\tif (retval_ptr) {\n\t\tzval_ptr_dtor(&retval_ptr);\n\t}\n\n\tif (EG(exception)) {\n\t\treturn 0;\n\t}\n\n\treturn finish_nested_data(UNSERIALIZE_PASSTHRU);\n\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -8,6 +8,9 @@\n \t}\n \n \tif (!process_nested_data(UNSERIALIZE_PASSTHRU, Z_OBJPROP_PP(rval), elements, 1)) {\n+\t    /* We've got partially constructed object on our hands here. Wipe it */\n+\t    zend_hash_clean(Z_OBJPROP_PP(rval));\n+\t    ZVAL_NULL(*rval);\n \t\treturn 0;\n \t}\n ",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t    /* We've got partially constructed object on our hands here. Wipe it */",
                "\t    zend_hash_clean(Z_OBJPROP_PP(rval));",
                "\t    ZVAL_NULL(*rval);"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-11143",
        "func_name": "php/php-src/php_wddx_push_element",
        "description": "In PHP before 5.6.31, an invalid free in the WDDX deserialization of boolean parameters could be used by attackers able to inject XML for deserialization to crash the PHP interpreter, related to an invalid free for an empty boolean element in ext/wddx/wddx.c.",
        "git_url": "https://github.com/php/php-src/commit/2aae60461c2ff7b7fbcdd194c789ac841d0747d7",
        "commit_title": "Fix bug #74145 - wddx parsing empty boolean tag leads to SIGSEGV",
        "commit_text": "",
        "func_before": "static void php_wddx_push_element(void *user_data, const XML_Char *name, const XML_Char **atts)\n{\n\tst_entry ent;\n\twddx_stack *stack = (wddx_stack *)user_data;\n\n\tif (!strcmp(name, EL_PACKET)) {\n\t\tint i;\n\n\t\tif (atts) for (i=0; atts[i]; i++) {\n\t\t\tif (!strcmp(atts[i], EL_VERSION)) {\n\t\t\t\t/* nothing for now */\n\t\t\t}\n\t\t}\n\t} else if (!strcmp(name, EL_STRING)) {\n\t\tent.type = ST_STRING;\n\t\tSET_STACK_VARNAME;\n\n\t\tALLOC_ZVAL(ent.data);\n\t\tINIT_PZVAL(ent.data);\n\t\tZ_TYPE_P(ent.data) = IS_STRING;\n\t\tZ_STRVAL_P(ent.data) = STR_EMPTY_ALLOC();\n\t\tZ_STRLEN_P(ent.data) = 0;\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp(name, EL_BINARY)) {\n\t\tent.type = ST_BINARY;\n\t\tSET_STACK_VARNAME;\n\n\t\tALLOC_ZVAL(ent.data);\n\t\tINIT_PZVAL(ent.data);\n\t\tZ_TYPE_P(ent.data) = IS_STRING;\n\t\tZ_STRVAL_P(ent.data) = STR_EMPTY_ALLOC();\n\t\tZ_STRLEN_P(ent.data) = 0;\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp(name, EL_CHAR)) {\n\t\tint i;\n\n\t\tif (atts) for (i = 0; atts[i]; i++) {\n\t\t\tif (!strcmp(atts[i], EL_CHAR_CODE) && atts[i+1] && atts[i+1][0]) {\n\t\t\t\tchar tmp_buf[2];\n\n\t\t\t\tsnprintf(tmp_buf, sizeof(tmp_buf), \"%c\", (char)strtol(atts[i+1], NULL, 16));\n\t\t\t\tphp_wddx_process_data(user_data, tmp_buf, strlen(tmp_buf));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else if (!strcmp(name, EL_NUMBER)) {\n\t\tent.type = ST_NUMBER;\n\t\tSET_STACK_VARNAME;\n\n\t\tALLOC_ZVAL(ent.data);\n\t\tINIT_PZVAL(ent.data);\n\t\tZ_TYPE_P(ent.data) = IS_LONG;\n\t\tZ_LVAL_P(ent.data) = 0;\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp(name, EL_BOOLEAN)) {\n\t\tint i;\n\n\t\tif (atts) for (i = 0; atts[i]; i++) {\n\t\t\tif (!strcmp(atts[i], EL_VALUE) && atts[i+1] && atts[i+1][0]) {\n\t\t\t\tent.type = ST_BOOLEAN;\n\t\t\t\tSET_STACK_VARNAME;\n\n\t\t\t\tALLOC_ZVAL(ent.data);\n\t\t\t\tINIT_PZVAL(ent.data);\n\t\t\t\tZ_TYPE_P(ent.data) = IS_BOOL;\n\t\t\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t\t\t\tphp_wddx_process_data(user_data, atts[i+1], strlen(atts[i+1]));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tent.type = ST_BOOLEAN;\n\t\t\tSET_STACK_VARNAME;\n\t\t\tZVAL_FALSE(&ent.data);\n\t\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t\t}\n\t} else if (!strcmp(name, EL_NULL)) {\n\t\tent.type = ST_NULL;\n\t\tSET_STACK_VARNAME;\n\n\t\tALLOC_ZVAL(ent.data);\n\t\tINIT_PZVAL(ent.data);\n\t\tZVAL_NULL(ent.data);\n\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp(name, EL_ARRAY)) {\n\t\tent.type = ST_ARRAY;\n\t\tSET_STACK_VARNAME;\n\n\t\tALLOC_ZVAL(ent.data);\n\t\tarray_init(ent.data);\n\t\tINIT_PZVAL(ent.data);\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp(name, EL_STRUCT)) {\n\t\tent.type = ST_STRUCT;\n\t\tSET_STACK_VARNAME;\n\n\t\tALLOC_ZVAL(ent.data);\n\t\tarray_init(ent.data);\n\t\tINIT_PZVAL(ent.data);\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp(name, EL_VAR)) {\n\t\tint i;\n\n\t\tif (atts) for (i = 0; atts[i]; i++) {\n\t\t\tif (!strcmp(atts[i], EL_NAME) && atts[i+1] && atts[i+1][0]) {\n\t\t\t\tif (stack->varname) efree(stack->varname);\n\t\t\t\tstack->varname = estrdup(atts[i+1]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else if (!strcmp(name, EL_RECORDSET)) {\n\t\tint i;\n\n\t\tent.type = ST_RECORDSET;\n\t\tSET_STACK_VARNAME;\n\t\tMAKE_STD_ZVAL(ent.data);\n\t\tarray_init(ent.data);\n\n\t\tif (atts) for (i = 0; atts[i]; i++) {\n\t\t\tif (!strcmp(atts[i], \"fieldNames\") && atts[i+1] && atts[i+1][0]) {\n\t\t\t\tzval *tmp;\n\t\t\t\tchar *key;\n\t\t\t\tchar *p1, *p2, *endp;\n\n\t\t\t\ti++;\n\t\t\t\tendp = (char *)atts[i] + strlen(atts[i]);\n\t\t\t\tp1 = (char *)atts[i];\n\t\t\t\twhile ((p2 = php_memnstr(p1, \",\", sizeof(\",\")-1, endp)) != NULL) {\n\t\t\t\t\tkey = estrndup(p1, p2 - p1);\n\t\t\t\t\tMAKE_STD_ZVAL(tmp);\n\t\t\t\t\tarray_init(tmp);\n\t\t\t\t\tadd_assoc_zval_ex(ent.data, key, p2 - p1 + 1, tmp);\n\t\t\t\t\tp1 = p2 + sizeof(\",\")-1;\n\t\t\t\t\tefree(key);\n\t\t\t\t}\n\n\t\t\t\tif (p1 <= endp) {\n\t\t\t\t\tMAKE_STD_ZVAL(tmp);\n\t\t\t\t\tarray_init(tmp);\n\t\t\t\t\tadd_assoc_zval_ex(ent.data, p1, endp - p1 + 1, tmp);\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp(name, EL_FIELD)) {\n\t\tint i;\n\t\tst_entry ent;\n\n\t\tent.type = ST_FIELD;\n\t\tent.varname = NULL;\n\t\tent.data = NULL;\n\n\t\tif (atts) for (i = 0; atts[i]; i++) {\n\t\t\tif (!strcmp(atts[i], EL_NAME) && atts[i+1] && atts[i+1][0]) {\n\t\t\t\tst_entry *recordset;\n\t\t\t\tzval **field;\n\n\t\t\t\tif (wddx_stack_top(stack, (void**)&recordset) == SUCCESS &&\n\t\t\t\t\trecordset->type == ST_RECORDSET &&\n\t\t\t\t\tzend_hash_find(Z_ARRVAL_P(recordset->data), (char*)atts[i+1], strlen(atts[i+1])+1, (void**)&field) == SUCCESS) {\n\t\t\t\t\tent.data = *field;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp(name, EL_DATETIME)) {\n\t\tent.type = ST_DATETIME;\n\t\tSET_STACK_VARNAME;\n\n\t\tALLOC_ZVAL(ent.data);\n\t\tINIT_PZVAL(ent.data);\n\t\tZ_TYPE_P(ent.data) = IS_LONG;\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t}\n}",
        "func": "static void php_wddx_push_element(void *user_data, const XML_Char *name, const XML_Char **atts)\n{\n\tst_entry ent;\n\twddx_stack *stack = (wddx_stack *)user_data;\n\n\tif (!strcmp(name, EL_PACKET)) {\n\t\tint i;\n\n\t\tif (atts) for (i=0; atts[i]; i++) {\n\t\t\tif (!strcmp(atts[i], EL_VERSION)) {\n\t\t\t\t/* nothing for now */\n\t\t\t}\n\t\t}\n\t} else if (!strcmp(name, EL_STRING)) {\n\t\tent.type = ST_STRING;\n\t\tSET_STACK_VARNAME;\n\n\t\tALLOC_ZVAL(ent.data);\n\t\tINIT_PZVAL(ent.data);\n\t\tZ_TYPE_P(ent.data) = IS_STRING;\n\t\tZ_STRVAL_P(ent.data) = STR_EMPTY_ALLOC();\n\t\tZ_STRLEN_P(ent.data) = 0;\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp(name, EL_BINARY)) {\n\t\tent.type = ST_BINARY;\n\t\tSET_STACK_VARNAME;\n\n\t\tALLOC_ZVAL(ent.data);\n\t\tINIT_PZVAL(ent.data);\n\t\tZ_TYPE_P(ent.data) = IS_STRING;\n\t\tZ_STRVAL_P(ent.data) = STR_EMPTY_ALLOC();\n\t\tZ_STRLEN_P(ent.data) = 0;\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp(name, EL_CHAR)) {\n\t\tint i;\n\n\t\tif (atts) for (i = 0; atts[i]; i++) {\n\t\t\tif (!strcmp(atts[i], EL_CHAR_CODE) && atts[i+1] && atts[i+1][0]) {\n\t\t\t\tchar tmp_buf[2];\n\n\t\t\t\tsnprintf(tmp_buf, sizeof(tmp_buf), \"%c\", (char)strtol(atts[i+1], NULL, 16));\n\t\t\t\tphp_wddx_process_data(user_data, tmp_buf, strlen(tmp_buf));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else if (!strcmp(name, EL_NUMBER)) {\n\t\tent.type = ST_NUMBER;\n\t\tSET_STACK_VARNAME;\n\n\t\tALLOC_ZVAL(ent.data);\n\t\tINIT_PZVAL(ent.data);\n\t\tZ_TYPE_P(ent.data) = IS_LONG;\n\t\tZ_LVAL_P(ent.data) = 0;\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp(name, EL_BOOLEAN)) {\n\t\tint i;\n\n\t\tALLOC_ZVAL(ent.data);\n\t\tINIT_PZVAL(ent.data);\n\t\tZ_TYPE_P(ent.data) = IS_BOOL;\n\t\tent.type = ST_BOOLEAN;\n\t\tSET_STACK_VARNAME;\n\t\tif (atts) for (i = 0; atts[i]; i++) {\n\t\t\tif (!strcmp(atts[i], EL_VALUE) && atts[i+1] && atts[i+1][0]) {\n\t\t\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t\t\t\tphp_wddx_process_data(user_data, atts[i+1], strlen(atts[i+1]));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tZVAL_FALSE(ent.data);\n\t\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t\t}\n\t} else if (!strcmp(name, EL_NULL)) {\n\t\tent.type = ST_NULL;\n\t\tSET_STACK_VARNAME;\n\n\t\tALLOC_ZVAL(ent.data);\n\t\tINIT_PZVAL(ent.data);\n\t\tZVAL_NULL(ent.data);\n\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp(name, EL_ARRAY)) {\n\t\tent.type = ST_ARRAY;\n\t\tSET_STACK_VARNAME;\n\n\t\tALLOC_ZVAL(ent.data);\n\t\tarray_init(ent.data);\n\t\tINIT_PZVAL(ent.data);\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp(name, EL_STRUCT)) {\n\t\tent.type = ST_STRUCT;\n\t\tSET_STACK_VARNAME;\n\n\t\tALLOC_ZVAL(ent.data);\n\t\tarray_init(ent.data);\n\t\tINIT_PZVAL(ent.data);\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp(name, EL_VAR)) {\n\t\tint i;\n\n\t\tif (atts) for (i = 0; atts[i]; i++) {\n\t\t\tif (!strcmp(atts[i], EL_NAME) && atts[i+1] && atts[i+1][0]) {\n\t\t\t\tif (stack->varname) efree(stack->varname);\n\t\t\t\tstack->varname = estrdup(atts[i+1]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else if (!strcmp(name, EL_RECORDSET)) {\n\t\tint i;\n\n\t\tent.type = ST_RECORDSET;\n\t\tSET_STACK_VARNAME;\n\t\tMAKE_STD_ZVAL(ent.data);\n\t\tarray_init(ent.data);\n\n\t\tif (atts) for (i = 0; atts[i]; i++) {\n\t\t\tif (!strcmp(atts[i], \"fieldNames\") && atts[i+1] && atts[i+1][0]) {\n\t\t\t\tzval *tmp;\n\t\t\t\tchar *key;\n\t\t\t\tchar *p1, *p2, *endp;\n\n\t\t\t\ti++;\n\t\t\t\tendp = (char *)atts[i] + strlen(atts[i]);\n\t\t\t\tp1 = (char *)atts[i];\n\t\t\t\twhile ((p2 = php_memnstr(p1, \",\", sizeof(\",\")-1, endp)) != NULL) {\n\t\t\t\t\tkey = estrndup(p1, p2 - p1);\n\t\t\t\t\tMAKE_STD_ZVAL(tmp);\n\t\t\t\t\tarray_init(tmp);\n\t\t\t\t\tadd_assoc_zval_ex(ent.data, key, p2 - p1 + 1, tmp);\n\t\t\t\t\tp1 = p2 + sizeof(\",\")-1;\n\t\t\t\t\tefree(key);\n\t\t\t\t}\n\n\t\t\t\tif (p1 <= endp) {\n\t\t\t\t\tMAKE_STD_ZVAL(tmp);\n\t\t\t\t\tarray_init(tmp);\n\t\t\t\t\tadd_assoc_zval_ex(ent.data, p1, endp - p1 + 1, tmp);\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp(name, EL_FIELD)) {\n\t\tint i;\n\t\tst_entry ent;\n\n\t\tent.type = ST_FIELD;\n\t\tent.varname = NULL;\n\t\tent.data = NULL;\n\n\t\tif (atts) for (i = 0; atts[i]; i++) {\n\t\t\tif (!strcmp(atts[i], EL_NAME) && atts[i+1] && atts[i+1][0]) {\n\t\t\t\tst_entry *recordset;\n\t\t\t\tzval **field;\n\n\t\t\t\tif (wddx_stack_top(stack, (void**)&recordset) == SUCCESS &&\n\t\t\t\t\trecordset->type == ST_RECORDSET &&\n\t\t\t\t\tzend_hash_find(Z_ARRVAL_P(recordset->data), (char*)atts[i+1], strlen(atts[i+1])+1, (void**)&field) == SUCCESS) {\n\t\t\t\t\tent.data = *field;\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t} else if (!strcmp(name, EL_DATETIME)) {\n\t\tent.type = ST_DATETIME;\n\t\tSET_STACK_VARNAME;\n\n\t\tALLOC_ZVAL(ent.data);\n\t\tINIT_PZVAL(ent.data);\n\t\tZ_TYPE_P(ent.data) = IS_LONG;\n\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n\t}\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -55,22 +55,19 @@\n \t} else if (!strcmp(name, EL_BOOLEAN)) {\n \t\tint i;\n \n+\t\tALLOC_ZVAL(ent.data);\n+\t\tINIT_PZVAL(ent.data);\n+\t\tZ_TYPE_P(ent.data) = IS_BOOL;\n+\t\tent.type = ST_BOOLEAN;\n+\t\tSET_STACK_VARNAME;\n \t\tif (atts) for (i = 0; atts[i]; i++) {\n \t\t\tif (!strcmp(atts[i], EL_VALUE) && atts[i+1] && atts[i+1][0]) {\n-\t\t\t\tent.type = ST_BOOLEAN;\n-\t\t\t\tSET_STACK_VARNAME;\n-\n-\t\t\t\tALLOC_ZVAL(ent.data);\n-\t\t\t\tINIT_PZVAL(ent.data);\n-\t\t\t\tZ_TYPE_P(ent.data) = IS_BOOL;\n \t\t\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n \t\t\t\tphp_wddx_process_data(user_data, atts[i+1], strlen(atts[i+1]));\n \t\t\t\tbreak;\n \t\t\t}\n \t\t} else {\n-\t\t\tent.type = ST_BOOLEAN;\n-\t\t\tSET_STACK_VARNAME;\n-\t\t\tZVAL_FALSE(&ent.data);\n+\t\t\tZVAL_FALSE(ent.data);\n \t\t\twddx_stack_push((wddx_stack *)stack, &ent, sizeof(st_entry));\n \t\t}\n \t} else if (!strcmp(name, EL_NULL)) {",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\t\tent.type = ST_BOOLEAN;",
                "\t\t\t\tSET_STACK_VARNAME;",
                "",
                "\t\t\t\tALLOC_ZVAL(ent.data);",
                "\t\t\t\tINIT_PZVAL(ent.data);",
                "\t\t\t\tZ_TYPE_P(ent.data) = IS_BOOL;",
                "\t\t\tent.type = ST_BOOLEAN;",
                "\t\t\tSET_STACK_VARNAME;",
                "\t\t\tZVAL_FALSE(&ent.data);"
            ],
            "added_lines": [
                "\t\tALLOC_ZVAL(ent.data);",
                "\t\tINIT_PZVAL(ent.data);",
                "\t\tZ_TYPE_P(ent.data) = IS_BOOL;",
                "\t\tent.type = ST_BOOLEAN;",
                "\t\tSET_STACK_VARNAME;",
                "\t\t\tZVAL_FALSE(ent.data);"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-19395",
        "func_name": "php/php-src/com_properties_get",
        "description": "ext/standard/var.c in PHP 5.x through 7.1.24 on Windows allows attackers to cause a denial of service (NULL pointer dereference and application crash) because com and com_safearray_proxy return NULL in com_properties_get in ext/com_dotnet/com_handlers.c, as demonstrated by a serialize call on COM(\"WScript.Shell\").",
        "git_url": "https://github.com/php/php-src/commit/115ee49b0be12e3df7d2c7027609fbe1a1297e42",
        "commit_title": "Fix #77177: Serializing or unserializing COM objects crashes",
        "commit_text": " Firstly, we avoid returning NULL from the get_property handler, but instead return an empty HashTable, which already prevents the crashes. Secondly, since (de-)serialization obviously makes no sense for COM, DOTNET and VARIANT objects (at least with the current implementation), we prohibit it right away.",
        "func_before": "static HashTable *com_properties_get(zval *object)\n{\n\t/* TODO: use type-info to get all the names and values ?\n\t * DANGER: if we do that, there is a strong possibility for\n\t * infinite recursion when the hash is displayed via var_dump().\n\t * Perhaps it is best to leave it un-implemented.\n\t */\n\treturn NULL;\n}",
        "func": "static HashTable *com_properties_get(zval *object)\n{\n\t/* TODO: use type-info to get all the names and values ?\n\t * DANGER: if we do that, there is a strong possibility for\n\t * infinite recursion when the hash is displayed via var_dump().\n\t * Perhaps it is best to leave it un-implemented.\n\t */\n\treturn &com_dotnet_object_properties;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,5 +5,5 @@\n \t * infinite recursion when the hash is displayed via var_dump().\n \t * Perhaps it is best to leave it un-implemented.\n \t */\n-\treturn NULL;\n+\treturn &com_dotnet_object_properties;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\treturn NULL;"
            ],
            "added_lines": [
                "\treturn &com_dotnet_object_properties;"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-32636",
        "func_name": "GNOME/glib/gvs_tuple_get_member_bounds",
        "description": "A flaw was found in glib, where the gvariant deserialization code is vulnerable to a denial of service introduced by additional input validation added to resolve CVE-2023-29499. The offset table validation may be very slow. This bug does not affect any released version of glib but does affect glib distributors who followed the guidance of glib developers to backport the initial fix for CVE-2023-29499.",
        "git_url": "https://github.com/GNOME/glib/commit/78da5faccb3e065116b75b3ff87ff55381da6c76",
        "commit_title": "gvariant: Check offset table doesn’t fall outside variant bounds",
        "commit_text": " When dereferencing the first entry in the offset table for a tuple, check that it doesn’t fall outside the bounds of the variant first.  This prevents an out-of-bounds read from some non-normal tuples.  This bug was introduced in commit 73d0aa81c2575a5c9ae77d.  Includes a unit test, although the test will likely only catch the original bug if run with asan enabled.   oss-fuzz#54302",
        "func_before": "static void\ngvs_tuple_get_member_bounds (GVariantSerialised  value,\n                             gsize               index_,\n                             gsize               offset_size,\n                             gsize              *out_member_start,\n                             gsize              *out_member_end)\n{\n  const GVariantMemberInfo *member_info;\n  gsize member_start, member_end;\n\n  member_info = g_variant_type_info_member_info (value.type_info, index_);\n\n  if (member_info->i + 1)\n    member_start = gvs_read_unaligned_le (value.data + value.size -\n                                          offset_size * (member_info->i + 1),\n                                          offset_size);\n  else\n    member_start = 0;\n\n  member_start += member_info->a;\n  member_start &= member_info->b;\n  member_start |= member_info->c;\n\n  if (member_info->ending_type == G_VARIANT_MEMBER_ENDING_LAST)\n    member_end = value.size - offset_size * (member_info->i + 1);\n\n  else if (member_info->ending_type == G_VARIANT_MEMBER_ENDING_FIXED)\n    {\n      gsize fixed_size;\n\n      g_variant_type_info_query (member_info->type_info, NULL, &fixed_size);\n      member_end = member_start + fixed_size;\n    }\n\n  else /* G_VARIANT_MEMBER_ENDING_OFFSET */\n    member_end = gvs_read_unaligned_le (value.data + value.size -\n                                        offset_size * (member_info->i + 2),\n                                        offset_size);\n\n  if (out_member_start != NULL)\n    *out_member_start = member_start;\n  if (out_member_end != NULL)\n    *out_member_end = member_end;\n}",
        "func": "static void\ngvs_tuple_get_member_bounds (GVariantSerialised  value,\n                             gsize               index_,\n                             gsize               offset_size,\n                             gsize              *out_member_start,\n                             gsize              *out_member_end)\n{\n  const GVariantMemberInfo *member_info;\n  gsize member_start, member_end;\n\n  member_info = g_variant_type_info_member_info (value.type_info, index_);\n\n  if (member_info->i + 1 &&\n      offset_size * (member_info->i + 1) <= value.size)\n    member_start = gvs_read_unaligned_le (value.data + value.size -\n                                          offset_size * (member_info->i + 1),\n                                          offset_size);\n  else\n    member_start = 0;\n\n  member_start += member_info->a;\n  member_start &= member_info->b;\n  member_start |= member_info->c;\n\n  if (member_info->ending_type == G_VARIANT_MEMBER_ENDING_LAST &&\n      offset_size * (member_info->i + 1) <= value.size)\n    member_end = value.size - offset_size * (member_info->i + 1);\n\n  else if (member_info->ending_type == G_VARIANT_MEMBER_ENDING_FIXED)\n    {\n      gsize fixed_size;\n\n      g_variant_type_info_query (member_info->type_info, NULL, &fixed_size);\n      member_end = member_start + fixed_size;\n    }\n\n  else if (member_info->ending_type == G_VARIANT_MEMBER_ENDING_OFFSET &&\n           offset_size * (member_info->i + 2) <= value.size)\n    member_end = gvs_read_unaligned_le (value.data + value.size -\n                                        offset_size * (member_info->i + 2),\n                                        offset_size);\n\n  else  /* invalid */\n    member_end = G_MAXSIZE;\n\n  if (out_member_start != NULL)\n    *out_member_start = member_start;\n  if (out_member_end != NULL)\n    *out_member_end = member_end;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -10,7 +10,8 @@\n \n   member_info = g_variant_type_info_member_info (value.type_info, index_);\n \n-  if (member_info->i + 1)\n+  if (member_info->i + 1 &&\n+      offset_size * (member_info->i + 1) <= value.size)\n     member_start = gvs_read_unaligned_le (value.data + value.size -\n                                           offset_size * (member_info->i + 1),\n                                           offset_size);\n@@ -21,7 +22,8 @@\n   member_start &= member_info->b;\n   member_start |= member_info->c;\n \n-  if (member_info->ending_type == G_VARIANT_MEMBER_ENDING_LAST)\n+  if (member_info->ending_type == G_VARIANT_MEMBER_ENDING_LAST &&\n+      offset_size * (member_info->i + 1) <= value.size)\n     member_end = value.size - offset_size * (member_info->i + 1);\n \n   else if (member_info->ending_type == G_VARIANT_MEMBER_ENDING_FIXED)\n@@ -32,10 +34,14 @@\n       member_end = member_start + fixed_size;\n     }\n \n-  else /* G_VARIANT_MEMBER_ENDING_OFFSET */\n+  else if (member_info->ending_type == G_VARIANT_MEMBER_ENDING_OFFSET &&\n+           offset_size * (member_info->i + 2) <= value.size)\n     member_end = gvs_read_unaligned_le (value.data + value.size -\n                                         offset_size * (member_info->i + 2),\n                                         offset_size);\n+\n+  else  /* invalid */\n+    member_end = G_MAXSIZE;\n \n   if (out_member_start != NULL)\n     *out_member_start = member_start;",
        "diff_line_info": {
            "deleted_lines": [
                "  if (member_info->i + 1)",
                "  if (member_info->ending_type == G_VARIANT_MEMBER_ENDING_LAST)",
                "  else /* G_VARIANT_MEMBER_ENDING_OFFSET */"
            ],
            "added_lines": [
                "  if (member_info->i + 1 &&",
                "      offset_size * (member_info->i + 1) <= value.size)",
                "  if (member_info->ending_type == G_VARIANT_MEMBER_ENDING_LAST &&",
                "      offset_size * (member_info->i + 1) <= value.size)",
                "  else if (member_info->ending_type == G_VARIANT_MEMBER_ENDING_OFFSET &&",
                "           offset_size * (member_info->i + 2) <= value.size)",
                "",
                "  else  /* invalid */",
                "    member_end = G_MAXSIZE;"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-32636",
        "func_name": "GNOME/glib/g_variant_get_child_value",
        "description": "A flaw was found in glib, where the gvariant deserialization code is vulnerable to a denial of service introduced by additional input validation added to resolve CVE-2023-29499. The offset table validation may be very slow. This bug does not affect any released version of glib but does affect glib distributors who followed the guidance of glib developers to backport the initial fix for CVE-2023-29499.",
        "git_url": "https://github.com/GNOME/glib/commit/21a204147b16539b3eda3143b32844c49e29f4d4",
        "commit_title": "gvariant: Propagate trust when getting a child of a serialised variant",
        "commit_text": " If a variant is trusted, that means all its children are trusted, so ensure that their checked offsets are set as such.  This allows a lot of the offset table checks to be avoided when getting children from trusted serialised tuples, which speeds things up.  No unit test is included because this is just a performance fix. If there are other slownesses, or regressions, in serialised `GVariant` performance, the fuzzing setup will catch them like it did this one.  This change does reduce the time to run the oss-fuzz reproducer from 80s to about 0.7s on my machine.   oss-fuzz#54314",
        "func_before": "GVariant *\ng_variant_get_child_value (GVariant *value,\n                           gsize     index_)\n{\n  g_return_val_if_fail (index_ < g_variant_n_children (value), NULL);\n  g_return_val_if_fail (value->depth < G_MAXSIZE, NULL);\n\n  if (~g_atomic_int_get (&value->state) & STATE_SERIALISED)\n    {\n      g_variant_lock (value);\n\n      if (~value->state & STATE_SERIALISED)\n        {\n          GVariant *child;\n\n          child = g_variant_ref (value->contents.tree.children[index_]);\n          g_variant_unlock (value);\n\n          return child;\n        }\n\n      g_variant_unlock (value);\n    }\n\n  {\n    GVariantSerialised serialised = g_variant_to_serialised (value);\n    GVariantSerialised s_child;\n    GVariant *child;\n\n    /* get the serializer to extract the serialized data for the child\n     * from the serialized data for the container\n     */\n    s_child = g_variant_serialised_get_child (serialised, index_);\n\n    /* Update the cached ordered_offsets_up_to, since @serialised will be thrown away when this function exits */\n    value->contents.serialised.ordered_offsets_up_to = MAX (value->contents.serialised.ordered_offsets_up_to, serialised.ordered_offsets_up_to);\n    value->contents.serialised.checked_offsets_up_to = MAX (value->contents.serialised.checked_offsets_up_to, serialised.checked_offsets_up_to);\n\n    /* Check whether this would cause nesting too deep. If so, return a fake\n     * child. The only situation we expect this to happen in is with a variant,\n     * as all other deeply-nested types have a static type, and hence should\n     * have been rejected earlier. In the case of a variant whose nesting plus\n     * the depth of its child is too great, return a unit variant () instead of\n     * the real child. */\n    if (!(value->state & STATE_TRUSTED) &&\n        g_variant_type_info_query_depth (s_child.type_info) >=\n        G_VARIANT_MAX_RECURSION_DEPTH - value->depth)\n      {\n        g_assert (g_variant_is_of_type (value, G_VARIANT_TYPE_VARIANT));\n        g_variant_type_info_unref (s_child.type_info);\n        return g_variant_new_tuple (NULL, 0);\n      }\n\n    /* create a new serialized instance out of it */\n    child = g_slice_new (GVariant);\n    child->type_info = s_child.type_info;\n    child->state = (value->state & STATE_TRUSTED) |\n                   STATE_SERIALISED;\n    child->size = s_child.size;\n    g_atomic_ref_count_init (&child->ref_count);\n    child->depth = value->depth + 1;\n    child->contents.serialised.bytes =\n      g_bytes_ref (value->contents.serialised.bytes);\n    child->contents.serialised.data = s_child.data;\n    child->contents.serialised.ordered_offsets_up_to = s_child.ordered_offsets_up_to;\n    child->contents.serialised.checked_offsets_up_to = s_child.checked_offsets_up_to;\n\n    return child;\n  }\n}",
        "func": "GVariant *\ng_variant_get_child_value (GVariant *value,\n                           gsize     index_)\n{\n  g_return_val_if_fail (index_ < g_variant_n_children (value), NULL);\n  g_return_val_if_fail (value->depth < G_MAXSIZE, NULL);\n\n  if (~g_atomic_int_get (&value->state) & STATE_SERIALISED)\n    {\n      g_variant_lock (value);\n\n      if (~value->state & STATE_SERIALISED)\n        {\n          GVariant *child;\n\n          child = g_variant_ref (value->contents.tree.children[index_]);\n          g_variant_unlock (value);\n\n          return child;\n        }\n\n      g_variant_unlock (value);\n    }\n\n  {\n    GVariantSerialised serialised = g_variant_to_serialised (value);\n    GVariantSerialised s_child;\n    GVariant *child;\n\n    /* get the serializer to extract the serialized data for the child\n     * from the serialized data for the container\n     */\n    s_child = g_variant_serialised_get_child (serialised, index_);\n\n    /* Update the cached ordered_offsets_up_to, since @serialised will be thrown away when this function exits */\n    value->contents.serialised.ordered_offsets_up_to = MAX (value->contents.serialised.ordered_offsets_up_to, serialised.ordered_offsets_up_to);\n    value->contents.serialised.checked_offsets_up_to = MAX (value->contents.serialised.checked_offsets_up_to, serialised.checked_offsets_up_to);\n\n    /* Check whether this would cause nesting too deep. If so, return a fake\n     * child. The only situation we expect this to happen in is with a variant,\n     * as all other deeply-nested types have a static type, and hence should\n     * have been rejected earlier. In the case of a variant whose nesting plus\n     * the depth of its child is too great, return a unit variant () instead of\n     * the real child. */\n    if (!(value->state & STATE_TRUSTED) &&\n        g_variant_type_info_query_depth (s_child.type_info) >=\n        G_VARIANT_MAX_RECURSION_DEPTH - value->depth)\n      {\n        g_assert (g_variant_is_of_type (value, G_VARIANT_TYPE_VARIANT));\n        g_variant_type_info_unref (s_child.type_info);\n        return g_variant_new_tuple (NULL, 0);\n      }\n\n    /* create a new serialized instance out of it */\n    child = g_slice_new (GVariant);\n    child->type_info = s_child.type_info;\n    child->state = (value->state & STATE_TRUSTED) |\n                   STATE_SERIALISED;\n    child->size = s_child.size;\n    g_atomic_ref_count_init (&child->ref_count);\n    child->depth = value->depth + 1;\n    child->contents.serialised.bytes =\n      g_bytes_ref (value->contents.serialised.bytes);\n    child->contents.serialised.data = s_child.data;\n    child->contents.serialised.ordered_offsets_up_to = (value->state & STATE_TRUSTED) ? G_MAXSIZE : s_child.ordered_offsets_up_to;\n    child->contents.serialised.checked_offsets_up_to = (value->state & STATE_TRUSTED) ? G_MAXSIZE : s_child.checked_offsets_up_to;\n\n    return child;\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -62,8 +62,8 @@\n     child->contents.serialised.bytes =\n       g_bytes_ref (value->contents.serialised.bytes);\n     child->contents.serialised.data = s_child.data;\n-    child->contents.serialised.ordered_offsets_up_to = s_child.ordered_offsets_up_to;\n-    child->contents.serialised.checked_offsets_up_to = s_child.checked_offsets_up_to;\n+    child->contents.serialised.ordered_offsets_up_to = (value->state & STATE_TRUSTED) ? G_MAXSIZE : s_child.ordered_offsets_up_to;\n+    child->contents.serialised.checked_offsets_up_to = (value->state & STATE_TRUSTED) ? G_MAXSIZE : s_child.checked_offsets_up_to;\n \n     return child;\n   }",
        "diff_line_info": {
            "deleted_lines": [
                "    child->contents.serialised.ordered_offsets_up_to = s_child.ordered_offsets_up_to;",
                "    child->contents.serialised.checked_offsets_up_to = s_child.checked_offsets_up_to;"
            ],
            "added_lines": [
                "    child->contents.serialised.ordered_offsets_up_to = (value->state & STATE_TRUSTED) ? G_MAXSIZE : s_child.ordered_offsets_up_to;",
                "    child->contents.serialised.checked_offsets_up_to = (value->state & STATE_TRUSTED) ? G_MAXSIZE : s_child.checked_offsets_up_to;"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-32665",
        "func_name": "GNOME/glib/g_variant_get_child_value",
        "description": "A flaw was found in GLib. GVariant deserialization is vulnerable to an exponential blowup issue where a crafted GVariant can cause excessive processing, leading to denial of service.",
        "git_url": "https://github.com/GNOME/glib/commit/ade71fb544391b2e33e1859645726bfee0d5eaaf",
        "commit_title": "gvariant: Don’t allow child elements to overlap with each other",
        "commit_text": " If different elements of a variable sized array can overlap with each other then we can cause a `GVariant` to normalise to a much larger type.  This commit changes the behaviour of `GVariant` with non-normal form data. If an invalid frame offset is found all subsequent elements are given their default value.  When retrieving an element at index `n` we scan the frame offsets up to index `n` and if they are not in order we return an element with the default value for that type.  This guarantees that elements don't overlap with each other.  We remember the offset we've scanned up to so we don't need to repeat this work on subsequent accesses.  We skip these checks for trusted data.  Unfortunately this makes random access of untrusted data O(n) — at least on first access.  It doesn't affect the algorithmic complexity of accessing elements in order, such as when using the `GVariantIter` interface.  Also: the cost of validation will be amortised as the `GVariant` instance is continued to be used.  I've implemented this with 4 different functions, 1 for each element size, rather than looping calling `gvs_read_unaligned_le` in the hope that the compiler will find it easy to optimise and should produce fairly tight code. ",
        "func_before": "GVariant *\ng_variant_get_child_value (GVariant *value,\n                           gsize     index_)\n{\n  g_return_val_if_fail (index_ < g_variant_n_children (value), NULL);\n  g_return_val_if_fail (value->depth < G_MAXSIZE, NULL);\n\n  if (~g_atomic_int_get (&value->state) & STATE_SERIALISED)\n    {\n      g_variant_lock (value);\n\n      if (~value->state & STATE_SERIALISED)\n        {\n          GVariant *child;\n\n          child = g_variant_ref (value->contents.tree.children[index_]);\n          g_variant_unlock (value);\n\n          return child;\n        }\n\n      g_variant_unlock (value);\n    }\n\n  {\n    GVariantSerialised serialised = g_variant_to_serialised (value);\n    GVariantSerialised s_child;\n    GVariant *child;\n\n    /* get the serializer to extract the serialized data for the child\n     * from the serialized data for the container\n     */\n    s_child = g_variant_serialised_get_child (serialised, index_);\n\n    /* Check whether this would cause nesting too deep. If so, return a fake\n     * child. The only situation we expect this to happen in is with a variant,\n     * as all other deeply-nested types have a static type, and hence should\n     * have been rejected earlier. In the case of a variant whose nesting plus\n     * the depth of its child is too great, return a unit variant () instead of\n     * the real child. */\n    if (!(value->state & STATE_TRUSTED) &&\n        g_variant_type_info_query_depth (s_child.type_info) >=\n        G_VARIANT_MAX_RECURSION_DEPTH - value->depth)\n      {\n        g_assert (g_variant_is_of_type (value, G_VARIANT_TYPE_VARIANT));\n        return g_variant_new_tuple (NULL, 0);\n      }\n\n    /* create a new serialized instance out of it */\n    child = g_slice_new (GVariant);\n    child->type_info = s_child.type_info;\n    child->state = (value->state & STATE_TRUSTED) |\n                   STATE_SERIALISED;\n    child->size = s_child.size;\n    g_atomic_ref_count_init (&child->ref_count);\n    child->depth = value->depth + 1;\n    child->contents.serialised.bytes =\n      g_bytes_ref (value->contents.serialised.bytes);\n    child->contents.serialised.data = s_child.data;\n\n    return child;\n  }\n}",
        "func": "GVariant *\ng_variant_get_child_value (GVariant *value,\n                           gsize     index_)\n{\n  g_return_val_if_fail (index_ < g_variant_n_children (value), NULL);\n  g_return_val_if_fail (value->depth < G_MAXSIZE, NULL);\n\n  if (~g_atomic_int_get (&value->state) & STATE_SERIALISED)\n    {\n      g_variant_lock (value);\n\n      if (~value->state & STATE_SERIALISED)\n        {\n          GVariant *child;\n\n          child = g_variant_ref (value->contents.tree.children[index_]);\n          g_variant_unlock (value);\n\n          return child;\n        }\n\n      g_variant_unlock (value);\n    }\n\n  {\n    GVariantSerialised serialised = g_variant_to_serialised (value);\n    GVariantSerialised s_child;\n    GVariant *child;\n\n    /* get the serializer to extract the serialized data for the child\n     * from the serialized data for the container\n     */\n    s_child = g_variant_serialised_get_child (serialised, index_);\n\n    /* Check whether this would cause nesting too deep. If so, return a fake\n     * child. The only situation we expect this to happen in is with a variant,\n     * as all other deeply-nested types have a static type, and hence should\n     * have been rejected earlier. In the case of a variant whose nesting plus\n     * the depth of its child is too great, return a unit variant () instead of\n     * the real child. */\n    if (!(value->state & STATE_TRUSTED) &&\n        g_variant_type_info_query_depth (s_child.type_info) >=\n        G_VARIANT_MAX_RECURSION_DEPTH - value->depth)\n      {\n        g_assert (g_variant_is_of_type (value, G_VARIANT_TYPE_VARIANT));\n        return g_variant_new_tuple (NULL, 0);\n      }\n\n    /* create a new serialized instance out of it */\n    child = g_slice_new (GVariant);\n    child->type_info = s_child.type_info;\n    child->state = (value->state & STATE_TRUSTED) |\n                   STATE_SERIALISED;\n    child->size = s_child.size;\n    g_atomic_ref_count_init (&child->ref_count);\n    child->depth = value->depth + 1;\n    child->contents.serialised.bytes =\n      g_bytes_ref (value->contents.serialised.bytes);\n    child->contents.serialised.data = s_child.data;\n    child->contents.serialised.ordered_offsets_up_to = s_child.ordered_offsets_up_to;\n\n    return child;\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -57,6 +57,7 @@\n     child->contents.serialised.bytes =\n       g_bytes_ref (value->contents.serialised.bytes);\n     child->contents.serialised.data = s_child.data;\n+    child->contents.serialised.ordered_offsets_up_to = s_child.ordered_offsets_up_to;\n \n     return child;\n   }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    child->contents.serialised.ordered_offsets_up_to = s_child.ordered_offsets_up_to;"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-32665",
        "func_name": "GNOME/glib/g_variant_new_from_bytes",
        "description": "A flaw was found in GLib. GVariant deserialization is vulnerable to an exponential blowup issue where a crafted GVariant can cause excessive processing, leading to denial of service.",
        "git_url": "https://github.com/GNOME/glib/commit/ade71fb544391b2e33e1859645726bfee0d5eaaf",
        "commit_title": "gvariant: Don’t allow child elements to overlap with each other",
        "commit_text": " If different elements of a variable sized array can overlap with each other then we can cause a `GVariant` to normalise to a much larger type.  This commit changes the behaviour of `GVariant` with non-normal form data. If an invalid frame offset is found all subsequent elements are given their default value.  When retrieving an element at index `n` we scan the frame offsets up to index `n` and if they are not in order we return an element with the default value for that type.  This guarantees that elements don't overlap with each other.  We remember the offset we've scanned up to so we don't need to repeat this work on subsequent accesses.  We skip these checks for trusted data.  Unfortunately this makes random access of untrusted data O(n) — at least on first access.  It doesn't affect the algorithmic complexity of accessing elements in order, such as when using the `GVariantIter` interface.  Also: the cost of validation will be amortised as the `GVariant` instance is continued to be used.  I've implemented this with 4 different functions, 1 for each element size, rather than looping calling `gvs_read_unaligned_le` in the hope that the compiler will find it easy to optimise and should produce fairly tight code. ",
        "func_before": "GVariant *\ng_variant_new_from_bytes (const GVariantType *type,\n                          GBytes             *bytes,\n                          gboolean            trusted)\n{\n  GVariant *value;\n  guint alignment;\n  gsize size;\n  GBytes *owned_bytes = NULL;\n  GVariantSerialised serialised;\n\n  value = g_variant_alloc (type, TRUE, trusted);\n\n  g_variant_type_info_query (value->type_info,\n                             &alignment, &size);\n\n  /* Ensure the alignment is correct. This is a huge performance hit if it’s\n   * not correct, but that’s better than aborting if a caller provides data\n   * with the wrong alignment (which is likely to happen very occasionally, and\n   * only cause an abort on some architectures — so is unlikely to be caught\n   * in testing). Callers can always actively ensure they use the correct\n   * alignment to avoid the performance hit. */\n  serialised.type_info = value->type_info;\n  serialised.data = (guchar *) g_bytes_get_data (bytes, &serialised.size);\n  serialised.depth = 0;\n\n  if (!g_variant_serialised_check (serialised))\n    {\n#ifdef HAVE_POSIX_MEMALIGN\n      gpointer aligned_data = NULL;\n      gsize aligned_size = g_bytes_get_size (bytes);\n\n      /* posix_memalign() requires the alignment to be a multiple of\n       * sizeof(void*), and a power of 2. See g_variant_type_info_query() for\n       * details on the alignment format. */\n      if (posix_memalign (&aligned_data, MAX (sizeof (void *), alignment + 1),\n                          aligned_size) != 0)\n        g_error (\"posix_memalign failed\");\n\n      if (aligned_size != 0)\n        memcpy (aligned_data, g_bytes_get_data (bytes, NULL), aligned_size);\n\n      bytes = owned_bytes = g_bytes_new_with_free_func (aligned_data,\n                                                        aligned_size,\n                                                        free, aligned_data);\n      aligned_data = NULL;\n#else\n      /* NOTE: there may be platforms that lack posix_memalign() and also\n       * have malloc() that returns non-8-aligned.  if so, we need to try\n       * harder here.\n       */\n      bytes = owned_bytes = g_bytes_new (g_bytes_get_data (bytes, NULL),\n                                         g_bytes_get_size (bytes));\n#endif\n    }\n\n  value->contents.serialised.bytes = g_bytes_ref (bytes);\n\n  if (size && g_bytes_get_size (bytes) != size)\n    {\n      /* Creating a fixed-sized GVariant with a bytes of the wrong\n       * size.\n       *\n       * We should do the equivalent of pulling a fixed-sized child out\n       * of a brozen container (ie: data is NULL size is equal to the correct\n       * fixed size).\n       */\n      value->contents.serialised.data = NULL;\n      value->size = size;\n    }\n  else\n    {\n      value->contents.serialised.data = g_bytes_get_data (bytes, &value->size);\n    }\n\n  g_clear_pointer (&owned_bytes, g_bytes_unref);\n\n  return value;\n}",
        "func": "GVariant *\ng_variant_new_from_bytes (const GVariantType *type,\n                          GBytes             *bytes,\n                          gboolean            trusted)\n{\n  GVariant *value;\n  guint alignment;\n  gsize size;\n  GBytes *owned_bytes = NULL;\n  GVariantSerialised serialised;\n\n  value = g_variant_alloc (type, TRUE, trusted);\n\n  g_variant_type_info_query (value->type_info,\n                             &alignment, &size);\n\n  /* Ensure the alignment is correct. This is a huge performance hit if it’s\n   * not correct, but that’s better than aborting if a caller provides data\n   * with the wrong alignment (which is likely to happen very occasionally, and\n   * only cause an abort on some architectures — so is unlikely to be caught\n   * in testing). Callers can always actively ensure they use the correct\n   * alignment to avoid the performance hit. */\n  serialised.type_info = value->type_info;\n  serialised.data = (guchar *) g_bytes_get_data (bytes, &serialised.size);\n  serialised.depth = 0;\n  serialised.ordered_offsets_up_to = trusted ? G_MAXSIZE : 0;\n\n  if (!g_variant_serialised_check (serialised))\n    {\n#ifdef HAVE_POSIX_MEMALIGN\n      gpointer aligned_data = NULL;\n      gsize aligned_size = g_bytes_get_size (bytes);\n\n      /* posix_memalign() requires the alignment to be a multiple of\n       * sizeof(void*), and a power of 2. See g_variant_type_info_query() for\n       * details on the alignment format. */\n      if (posix_memalign (&aligned_data, MAX (sizeof (void *), alignment + 1),\n                          aligned_size) != 0)\n        g_error (\"posix_memalign failed\");\n\n      if (aligned_size != 0)\n        memcpy (aligned_data, g_bytes_get_data (bytes, NULL), aligned_size);\n\n      bytes = owned_bytes = g_bytes_new_with_free_func (aligned_data,\n                                                        aligned_size,\n                                                        free, aligned_data);\n      aligned_data = NULL;\n#else\n      /* NOTE: there may be platforms that lack posix_memalign() and also\n       * have malloc() that returns non-8-aligned.  if so, we need to try\n       * harder here.\n       */\n      bytes = owned_bytes = g_bytes_new (g_bytes_get_data (bytes, NULL),\n                                         g_bytes_get_size (bytes));\n#endif\n    }\n\n  value->contents.serialised.bytes = g_bytes_ref (bytes);\n\n  if (size && g_bytes_get_size (bytes) != size)\n    {\n      /* Creating a fixed-sized GVariant with a bytes of the wrong\n       * size.\n       *\n       * We should do the equivalent of pulling a fixed-sized child out\n       * of a brozen container (ie: data is NULL size is equal to the correct\n       * fixed size).\n       */\n      value->contents.serialised.data = NULL;\n      value->size = size;\n    }\n  else\n    {\n      value->contents.serialised.data = g_bytes_get_data (bytes, &value->size);\n    }\n\n  value->contents.serialised.ordered_offsets_up_to = trusted ? G_MAXSIZE : 0;\n\n  g_clear_pointer (&owned_bytes, g_bytes_unref);\n\n  return value;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -23,6 +23,7 @@\n   serialised.type_info = value->type_info;\n   serialised.data = (guchar *) g_bytes_get_data (bytes, &serialised.size);\n   serialised.depth = 0;\n+  serialised.ordered_offsets_up_to = trusted ? G_MAXSIZE : 0;\n \n   if (!g_variant_serialised_check (serialised))\n     {\n@@ -73,6 +74,8 @@\n       value->contents.serialised.data = g_bytes_get_data (bytes, &value->size);\n     }\n \n+  value->contents.serialised.ordered_offsets_up_to = trusted ? G_MAXSIZE : 0;\n+\n   g_clear_pointer (&owned_bytes, g_bytes_unref);\n \n   return value;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "  serialised.ordered_offsets_up_to = trusted ? G_MAXSIZE : 0;",
                "  value->contents.serialised.ordered_offsets_up_to = trusted ? G_MAXSIZE : 0;",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2023-32665",
        "func_name": "GNOME/glib/g_variant_to_serialised",
        "description": "A flaw was found in GLib. GVariant deserialization is vulnerable to an exponential blowup issue where a crafted GVariant can cause excessive processing, leading to denial of service.",
        "git_url": "https://github.com/GNOME/glib/commit/ade71fb544391b2e33e1859645726bfee0d5eaaf",
        "commit_title": "gvariant: Don’t allow child elements to overlap with each other",
        "commit_text": " If different elements of a variable sized array can overlap with each other then we can cause a `GVariant` to normalise to a much larger type.  This commit changes the behaviour of `GVariant` with non-normal form data. If an invalid frame offset is found all subsequent elements are given their default value.  When retrieving an element at index `n` we scan the frame offsets up to index `n` and if they are not in order we return an element with the default value for that type.  This guarantees that elements don't overlap with each other.  We remember the offset we've scanned up to so we don't need to repeat this work on subsequent accesses.  We skip these checks for trusted data.  Unfortunately this makes random access of untrusted data O(n) — at least on first access.  It doesn't affect the algorithmic complexity of accessing elements in order, such as when using the `GVariantIter` interface.  Also: the cost of validation will be amortised as the `GVariant` instance is continued to be used.  I've implemented this with 4 different functions, 1 for each element size, rather than looping calling `gvs_read_unaligned_le` in the hope that the compiler will find it easy to optimise and should produce fairly tight code. ",
        "func_before": "inline static GVariantSerialised\ng_variant_to_serialised (GVariant *value)\n{\n  g_assert (value->state & STATE_SERIALISED);\n  {\n    GVariantSerialised serialised = {\n      value->type_info,\n      (gpointer) value->contents.serialised.data,\n      value->size,\n      value->depth,\n    };\n    return serialised;\n  }\n}",
        "func": "inline static GVariantSerialised\ng_variant_to_serialised (GVariant *value)\n{\n  g_assert (value->state & STATE_SERIALISED);\n  {\n    GVariantSerialised serialised = {\n      value->type_info,\n      (gpointer) value->contents.serialised.data,\n      value->size,\n      value->depth,\n      value->contents.serialised.ordered_offsets_up_to,\n    };\n    return serialised;\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -8,6 +8,7 @@\n       (gpointer) value->contents.serialised.data,\n       value->size,\n       value->depth,\n+      value->contents.serialised.ordered_offsets_up_to,\n     };\n     return serialised;\n   }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "      value->contents.serialised.ordered_offsets_up_to,"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-32665",
        "func_name": "GNOME/glib/g_variant_ensure_serialised",
        "description": "A flaw was found in GLib. GVariant deserialization is vulnerable to an exponential blowup issue where a crafted GVariant can cause excessive processing, leading to denial of service.",
        "git_url": "https://github.com/GNOME/glib/commit/ade71fb544391b2e33e1859645726bfee0d5eaaf",
        "commit_title": "gvariant: Don’t allow child elements to overlap with each other",
        "commit_text": " If different elements of a variable sized array can overlap with each other then we can cause a `GVariant` to normalise to a much larger type.  This commit changes the behaviour of `GVariant` with non-normal form data. If an invalid frame offset is found all subsequent elements are given their default value.  When retrieving an element at index `n` we scan the frame offsets up to index `n` and if they are not in order we return an element with the default value for that type.  This guarantees that elements don't overlap with each other.  We remember the offset we've scanned up to so we don't need to repeat this work on subsequent accesses.  We skip these checks for trusted data.  Unfortunately this makes random access of untrusted data O(n) — at least on first access.  It doesn't affect the algorithmic complexity of accessing elements in order, such as when using the `GVariantIter` interface.  Also: the cost of validation will be amortised as the `GVariant` instance is continued to be used.  I've implemented this with 4 different functions, 1 for each element size, rather than looping calling `gvs_read_unaligned_le` in the hope that the compiler will find it easy to optimise and should produce fairly tight code. ",
        "func_before": "static void\ng_variant_ensure_serialised (GVariant *value)\n{\n  g_assert (value->state & STATE_LOCKED);\n\n  if (~value->state & STATE_SERIALISED)\n    {\n      GBytes *bytes;\n      gpointer data;\n\n      g_variant_ensure_size (value);\n      data = g_malloc (value->size);\n      g_variant_serialise (value, data);\n\n      g_variant_release_children (value);\n\n      bytes = g_bytes_new_take (data, value->size);\n      value->contents.serialised.data = g_bytes_get_data (bytes, NULL);\n      value->contents.serialised.bytes = bytes;\n      value->state |= STATE_SERIALISED;\n    }\n}",
        "func": "static void\ng_variant_ensure_serialised (GVariant *value)\n{\n  g_assert (value->state & STATE_LOCKED);\n\n  if (~value->state & STATE_SERIALISED)\n    {\n      GBytes *bytes;\n      gpointer data;\n\n      g_variant_ensure_size (value);\n      data = g_malloc (value->size);\n      g_variant_serialise (value, data);\n\n      g_variant_release_children (value);\n\n      bytes = g_bytes_new_take (data, value->size);\n      value->contents.serialised.data = g_bytes_get_data (bytes, NULL);\n      value->contents.serialised.bytes = bytes;\n      value->contents.serialised.ordered_offsets_up_to = G_MAXSIZE;\n      value->state |= STATE_SERIALISED;\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -17,6 +17,7 @@\n       bytes = g_bytes_new_take (data, value->size);\n       value->contents.serialised.data = g_bytes_get_data (bytes, NULL);\n       value->contents.serialised.bytes = bytes;\n+      value->contents.serialised.ordered_offsets_up_to = G_MAXSIZE;\n       value->state |= STATE_SERIALISED;\n     }\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "      value->contents.serialised.ordered_offsets_up_to = G_MAXSIZE;"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-32665",
        "func_name": "GNOME/glib/g_variant_serialise",
        "description": "A flaw was found in GLib. GVariant deserialization is vulnerable to an exponential blowup issue where a crafted GVariant can cause excessive processing, leading to denial of service.",
        "git_url": "https://github.com/GNOME/glib/commit/ade71fb544391b2e33e1859645726bfee0d5eaaf",
        "commit_title": "gvariant: Don’t allow child elements to overlap with each other",
        "commit_text": " If different elements of a variable sized array can overlap with each other then we can cause a `GVariant` to normalise to a much larger type.  This commit changes the behaviour of `GVariant` with non-normal form data. If an invalid frame offset is found all subsequent elements are given their default value.  When retrieving an element at index `n` we scan the frame offsets up to index `n` and if they are not in order we return an element with the default value for that type.  This guarantees that elements don't overlap with each other.  We remember the offset we've scanned up to so we don't need to repeat this work on subsequent accesses.  We skip these checks for trusted data.  Unfortunately this makes random access of untrusted data O(n) — at least on first access.  It doesn't affect the algorithmic complexity of accessing elements in order, such as when using the `GVariantIter` interface.  Also: the cost of validation will be amortised as the `GVariant` instance is continued to be used.  I've implemented this with 4 different functions, 1 for each element size, rather than looping calling `gvs_read_unaligned_le` in the hope that the compiler will find it easy to optimise and should produce fairly tight code. ",
        "func_before": "static void\ng_variant_serialise (GVariant *value,\n                     gpointer  data)\n{\n  GVariantSerialised serialised = { 0, };\n  gpointer *children;\n  gsize n_children;\n\n  g_assert (~value->state & STATE_SERIALISED);\n  g_assert (value->state & STATE_LOCKED);\n\n  serialised.type_info = value->type_info;\n  serialised.size = value->size;\n  serialised.data = data;\n  serialised.depth = value->depth;\n\n  children = (gpointer *) value->contents.tree.children;\n  n_children = value->contents.tree.n_children;\n\n  g_variant_serialiser_serialise (serialised, g_variant_fill_gvs,\n                                  children, n_children);\n}",
        "func": "static void\ng_variant_serialise (GVariant *value,\n                     gpointer  data)\n{\n  GVariantSerialised serialised = { 0, };\n  gpointer *children;\n  gsize n_children;\n\n  g_assert (~value->state & STATE_SERIALISED);\n  g_assert (value->state & STATE_LOCKED);\n\n  serialised.type_info = value->type_info;\n  serialised.size = value->size;\n  serialised.data = data;\n  serialised.depth = value->depth;\n  serialised.ordered_offsets_up_to = 0;\n\n  children = (gpointer *) value->contents.tree.children;\n  n_children = value->contents.tree.n_children;\n\n  g_variant_serialiser_serialise (serialised, g_variant_fill_gvs,\n                                  children, n_children);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -13,6 +13,7 @@\n   serialised.size = value->size;\n   serialised.data = data;\n   serialised.depth = value->depth;\n+  serialised.ordered_offsets_up_to = 0;\n \n   children = (gpointer *) value->contents.tree.children;\n   n_children = value->contents.tree.n_children;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "  serialised.ordered_offsets_up_to = 0;"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-32665",
        "func_name": "GNOME/glib/g_variant_fill_gvs",
        "description": "A flaw was found in GLib. GVariant deserialization is vulnerable to an exponential blowup issue where a crafted GVariant can cause excessive processing, leading to denial of service.",
        "git_url": "https://github.com/GNOME/glib/commit/ade71fb544391b2e33e1859645726bfee0d5eaaf",
        "commit_title": "gvariant: Don’t allow child elements to overlap with each other",
        "commit_text": " If different elements of a variable sized array can overlap with each other then we can cause a `GVariant` to normalise to a much larger type.  This commit changes the behaviour of `GVariant` with non-normal form data. If an invalid frame offset is found all subsequent elements are given their default value.  When retrieving an element at index `n` we scan the frame offsets up to index `n` and if they are not in order we return an element with the default value for that type.  This guarantees that elements don't overlap with each other.  We remember the offset we've scanned up to so we don't need to repeat this work on subsequent accesses.  We skip these checks for trusted data.  Unfortunately this makes random access of untrusted data O(n) — at least on first access.  It doesn't affect the algorithmic complexity of accessing elements in order, such as when using the `GVariantIter` interface.  Also: the cost of validation will be amortised as the `GVariant` instance is continued to be used.  I've implemented this with 4 different functions, 1 for each element size, rather than looping calling `gvs_read_unaligned_le` in the hope that the compiler will find it easy to optimise and should produce fairly tight code. ",
        "func_before": "static void\ng_variant_fill_gvs (GVariantSerialised *serialised,\n                    gpointer            data)\n{\n  GVariant *value = data;\n\n  g_variant_lock (value);\n  g_variant_ensure_size (value);\n  g_variant_unlock (value);\n\n  if (serialised->type_info == NULL)\n    serialised->type_info = value->type_info;\n  g_assert (serialised->type_info == value->type_info);\n\n  if (serialised->size == 0)\n    serialised->size = value->size;\n  g_assert (serialised->size == value->size);\n  serialised->depth = value->depth;\n\n  if (serialised->data)\n    /* g_variant_store() is a public API, so it\n     * it will reacquire the lock if it needs to.\n     */\n    g_variant_store (value, serialised->data);\n}",
        "func": "static void\ng_variant_fill_gvs (GVariantSerialised *serialised,\n                    gpointer            data)\n{\n  GVariant *value = data;\n\n  g_variant_lock (value);\n  g_variant_ensure_size (value);\n  g_variant_unlock (value);\n\n  if (serialised->type_info == NULL)\n    serialised->type_info = value->type_info;\n  g_assert (serialised->type_info == value->type_info);\n\n  if (serialised->size == 0)\n    serialised->size = value->size;\n  g_assert (serialised->size == value->size);\n  serialised->depth = value->depth;\n\n  if (value->state & STATE_SERIALISED)\n    {\n      serialised->ordered_offsets_up_to = value->contents.serialised.ordered_offsets_up_to;\n    }\n  else\n    {\n      serialised->ordered_offsets_up_to = 0;\n    }\n\n  if (serialised->data)\n    /* g_variant_store() is a public API, so it\n     * it will reacquire the lock if it needs to.\n     */\n    g_variant_store (value, serialised->data);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -17,6 +17,15 @@\n   g_assert (serialised->size == value->size);\n   serialised->depth = value->depth;\n \n+  if (value->state & STATE_SERIALISED)\n+    {\n+      serialised->ordered_offsets_up_to = value->contents.serialised.ordered_offsets_up_to;\n+    }\n+  else\n+    {\n+      serialised->ordered_offsets_up_to = 0;\n+    }\n+\n   if (serialised->data)\n     /* g_variant_store() is a public API, so it\n      * it will reacquire the lock if it needs to.",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "  if (value->state & STATE_SERIALISED)",
                "    {",
                "      serialised->ordered_offsets_up_to = value->contents.serialised.ordered_offsets_up_to;",
                "    }",
                "  else",
                "    {",
                "      serialised->ordered_offsets_up_to = 0;",
                "    }",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2023-32665",
        "func_name": "GNOME/glib/gvs_variable_sized_array_get_child",
        "description": "A flaw was found in GLib. GVariant deserialization is vulnerable to an exponential blowup issue where a crafted GVariant can cause excessive processing, leading to denial of service.",
        "git_url": "https://github.com/GNOME/glib/commit/ade71fb544391b2e33e1859645726bfee0d5eaaf",
        "commit_title": "gvariant: Don’t allow child elements to overlap with each other",
        "commit_text": " If different elements of a variable sized array can overlap with each other then we can cause a `GVariant` to normalise to a much larger type.  This commit changes the behaviour of `GVariant` with non-normal form data. If an invalid frame offset is found all subsequent elements are given their default value.  When retrieving an element at index `n` we scan the frame offsets up to index `n` and if they are not in order we return an element with the default value for that type.  This guarantees that elements don't overlap with each other.  We remember the offset we've scanned up to so we don't need to repeat this work on subsequent accesses.  We skip these checks for trusted data.  Unfortunately this makes random access of untrusted data O(n) — at least on first access.  It doesn't affect the algorithmic complexity of accessing elements in order, such as when using the `GVariantIter` interface.  Also: the cost of validation will be amortised as the `GVariant` instance is continued to be used.  I've implemented this with 4 different functions, 1 for each element size, rather than looping calling `gvs_read_unaligned_le` in the hope that the compiler will find it easy to optimise and should produce fairly tight code. ",
        "func_before": "static GVariantSerialised\ngvs_variable_sized_array_get_child (GVariantSerialised value,\n                                    gsize              index_)\n{\n  GVariantSerialised child = { 0, };\n\n  struct Offsets offsets = gvs_variable_sized_array_get_frame_offsets (value);\n\n  gsize start;\n  gsize end;\n\n  child.type_info = g_variant_type_info_element (value.type_info);\n  g_variant_type_info_ref (child.type_info);\n  child.depth = value.depth + 1;\n\n  if (index_ > 0)\n    {\n      guint alignment;\n\n      start = gvs_offsets_get_offset_n (&offsets, index_ - 1);\n\n      g_variant_type_info_query (child.type_info, &alignment, NULL);\n      start += (-start) & alignment;\n    }\n  else\n    start = 0;\n\n  end = gvs_offsets_get_offset_n (&offsets, index_);\n\n  if (start < end && end <= value.size && end <= offsets.data_size)\n    {\n      child.data = value.data + start;\n      child.size = end - start;\n    }\n\n  return child;\n}",
        "func": "static GVariantSerialised\ngvs_variable_sized_array_get_child (GVariantSerialised value,\n                                    gsize              index_)\n{\n  GVariantSerialised child = { 0, };\n\n  struct Offsets offsets = gvs_variable_sized_array_get_frame_offsets (value);\n\n  gsize start;\n  gsize end;\n\n  child.type_info = g_variant_type_info_element (value.type_info);\n  g_variant_type_info_ref (child.type_info);\n  child.depth = value.depth + 1;\n\n  /* If the requested @index_ is beyond the set of indices whose framing offsets\n   * have been checked, check the remaining offsets to see whether they’re\n   * normal (in order, no overlapping array elements). */\n  if (index_ > value.ordered_offsets_up_to)\n    {\n      switch (offsets.offset_size)\n        {\n        case 1:\n          {\n            value.ordered_offsets_up_to = find_unordered_guint8 (\n                offsets.array, value.ordered_offsets_up_to, index_ + 1);\n            break;\n          }\n        case 2:\n          {\n            value.ordered_offsets_up_to = find_unordered_guint16 (\n                offsets.array, value.ordered_offsets_up_to, index_ + 1);\n            break;\n          }\n        case 4:\n          {\n            value.ordered_offsets_up_to = find_unordered_guint32 (\n                offsets.array, value.ordered_offsets_up_to, index_ + 1);\n            break;\n          }\n        case 8:\n          {\n            value.ordered_offsets_up_to = find_unordered_guint64 (\n                offsets.array, value.ordered_offsets_up_to, index_ + 1);\n            break;\n          }\n        default:\n          /* gvs_get_offset_size() only returns maximum 8 */\n          g_assert_not_reached ();\n        }\n    }\n\n  if (index_ > value.ordered_offsets_up_to)\n    {\n      /* Offsets are invalid somewhere, so return an empty child. */\n      return child;\n    }\n\n  if (index_ > 0)\n    {\n      guint alignment;\n\n      start = gvs_offsets_get_offset_n (&offsets, index_ - 1);\n\n      g_variant_type_info_query (child.type_info, &alignment, NULL);\n      start += (-start) & alignment;\n    }\n  else\n    start = 0;\n\n  end = gvs_offsets_get_offset_n (&offsets, index_);\n\n  if (start < end && end <= value.size && end <= offsets.data_size)\n    {\n      child.data = value.data + start;\n      child.size = end - start;\n    }\n\n  return child;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -12,6 +12,49 @@\n   child.type_info = g_variant_type_info_element (value.type_info);\n   g_variant_type_info_ref (child.type_info);\n   child.depth = value.depth + 1;\n+\n+  /* If the requested @index_ is beyond the set of indices whose framing offsets\n+   * have been checked, check the remaining offsets to see whether they’re\n+   * normal (in order, no overlapping array elements). */\n+  if (index_ > value.ordered_offsets_up_to)\n+    {\n+      switch (offsets.offset_size)\n+        {\n+        case 1:\n+          {\n+            value.ordered_offsets_up_to = find_unordered_guint8 (\n+                offsets.array, value.ordered_offsets_up_to, index_ + 1);\n+            break;\n+          }\n+        case 2:\n+          {\n+            value.ordered_offsets_up_to = find_unordered_guint16 (\n+                offsets.array, value.ordered_offsets_up_to, index_ + 1);\n+            break;\n+          }\n+        case 4:\n+          {\n+            value.ordered_offsets_up_to = find_unordered_guint32 (\n+                offsets.array, value.ordered_offsets_up_to, index_ + 1);\n+            break;\n+          }\n+        case 8:\n+          {\n+            value.ordered_offsets_up_to = find_unordered_guint64 (\n+                offsets.array, value.ordered_offsets_up_to, index_ + 1);\n+            break;\n+          }\n+        default:\n+          /* gvs_get_offset_size() only returns maximum 8 */\n+          g_assert_not_reached ();\n+        }\n+    }\n+\n+  if (index_ > value.ordered_offsets_up_to)\n+    {\n+      /* Offsets are invalid somewhere, so return an empty child. */\n+      return child;\n+    }\n \n   if (index_ > 0)\n     {",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "  /* If the requested @index_ is beyond the set of indices whose framing offsets",
                "   * have been checked, check the remaining offsets to see whether they’re",
                "   * normal (in order, no overlapping array elements). */",
                "  if (index_ > value.ordered_offsets_up_to)",
                "    {",
                "      switch (offsets.offset_size)",
                "        {",
                "        case 1:",
                "          {",
                "            value.ordered_offsets_up_to = find_unordered_guint8 (",
                "                offsets.array, value.ordered_offsets_up_to, index_ + 1);",
                "            break;",
                "          }",
                "        case 2:",
                "          {",
                "            value.ordered_offsets_up_to = find_unordered_guint16 (",
                "                offsets.array, value.ordered_offsets_up_to, index_ + 1);",
                "            break;",
                "          }",
                "        case 4:",
                "          {",
                "            value.ordered_offsets_up_to = find_unordered_guint32 (",
                "                offsets.array, value.ordered_offsets_up_to, index_ + 1);",
                "            break;",
                "          }",
                "        case 8:",
                "          {",
                "            value.ordered_offsets_up_to = find_unordered_guint64 (",
                "                offsets.array, value.ordered_offsets_up_to, index_ + 1);",
                "            break;",
                "          }",
                "        default:",
                "          /* gvs_get_offset_size() only returns maximum 8 */",
                "          g_assert_not_reached ();",
                "        }",
                "    }",
                "",
                "  if (index_ > value.ordered_offsets_up_to)",
                "    {",
                "      /* Offsets are invalid somewhere, so return an empty child. */",
                "      return child;",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-32665",
        "func_name": "GNOME/glib/gvs_variable_sized_array_is_normal",
        "description": "A flaw was found in GLib. GVariant deserialization is vulnerable to an exponential blowup issue where a crafted GVariant can cause excessive processing, leading to denial of service.",
        "git_url": "https://github.com/GNOME/glib/commit/ade71fb544391b2e33e1859645726bfee0d5eaaf",
        "commit_title": "gvariant: Don’t allow child elements to overlap with each other",
        "commit_text": " If different elements of a variable sized array can overlap with each other then we can cause a `GVariant` to normalise to a much larger type.  This commit changes the behaviour of `GVariant` with non-normal form data. If an invalid frame offset is found all subsequent elements are given their default value.  When retrieving an element at index `n` we scan the frame offsets up to index `n` and if they are not in order we return an element with the default value for that type.  This guarantees that elements don't overlap with each other.  We remember the offset we've scanned up to so we don't need to repeat this work on subsequent accesses.  We skip these checks for trusted data.  Unfortunately this makes random access of untrusted data O(n) — at least on first access.  It doesn't affect the algorithmic complexity of accessing elements in order, such as when using the `GVariantIter` interface.  Also: the cost of validation will be amortised as the `GVariant` instance is continued to be used.  I've implemented this with 4 different functions, 1 for each element size, rather than looping calling `gvs_read_unaligned_le` in the hope that the compiler will find it easy to optimise and should produce fairly tight code. ",
        "func_before": "static gboolean\ngvs_variable_sized_array_is_normal (GVariantSerialised value)\n{\n  GVariantSerialised child = { 0, };\n  guint alignment;\n  gsize offset;\n  gsize i;\n\n  struct Offsets offsets = gvs_variable_sized_array_get_frame_offsets (value);\n\n  if (!offsets.is_normal)\n    return FALSE;\n\n  if (value.size != 0 && offsets.length == 0)\n    return FALSE;\n\n  child.type_info = g_variant_type_info_element (value.type_info);\n  g_variant_type_info_query (child.type_info, &alignment, NULL);\n  child.depth = value.depth + 1;\n  offset = 0;\n\n  for (i = 0; i < offsets.length; i++)\n    {\n      gsize this_end;\n\n      this_end = gvs_read_unaligned_le (offsets.array + offsets.offset_size * i,\n                                        offsets.offset_size);\n\n      if (this_end < offset || this_end > offsets.data_size)\n        return FALSE;\n\n      while (offset & alignment)\n        {\n          if (!(offset < this_end && value.data[offset] == '\\0'))\n            return FALSE;\n          offset++;\n        }\n\n      child.data = value.data + offset;\n      child.size = this_end - offset;\n\n      if (child.size == 0)\n        child.data = NULL;\n\n      if (!g_variant_serialised_is_normal (child))\n        return FALSE;\n\n      offset = this_end;\n    }\n\n  g_assert (offset == offsets.data_size);\n\n  return TRUE;\n}",
        "func": "static gboolean\ngvs_variable_sized_array_is_normal (GVariantSerialised value)\n{\n  GVariantSerialised child = { 0, };\n  guint alignment;\n  gsize offset;\n  gsize i;\n\n  struct Offsets offsets = gvs_variable_sized_array_get_frame_offsets (value);\n\n  if (!offsets.is_normal)\n    return FALSE;\n\n  if (value.size != 0 && offsets.length == 0)\n    return FALSE;\n\n  child.type_info = g_variant_type_info_element (value.type_info);\n  g_variant_type_info_query (child.type_info, &alignment, NULL);\n  child.depth = value.depth + 1;\n  offset = 0;\n\n  for (i = 0; i < offsets.length; i++)\n    {\n      gsize this_end;\n\n      this_end = gvs_read_unaligned_le (offsets.array + offsets.offset_size * i,\n                                        offsets.offset_size);\n\n      if (this_end < offset || this_end > offsets.data_size)\n        return FALSE;\n\n      while (offset & alignment)\n        {\n          if (!(offset < this_end && value.data[offset] == '\\0'))\n            return FALSE;\n          offset++;\n        }\n\n      child.data = value.data + offset;\n      child.size = this_end - offset;\n\n      if (child.size == 0)\n        child.data = NULL;\n\n      if (!g_variant_serialised_is_normal (child))\n        return FALSE;\n\n      offset = this_end;\n    }\n\n  g_assert (offset == offsets.data_size);\n\n  /* All offsets have now been checked. */\n  value.ordered_offsets_up_to = G_MAXSIZE;\n\n  return TRUE;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -50,5 +50,8 @@\n \n   g_assert (offset == offsets.data_size);\n \n+  /* All offsets have now been checked. */\n+  value.ordered_offsets_up_to = G_MAXSIZE;\n+\n   return TRUE;\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "  /* All offsets have now been checked. */",
                "  value.ordered_offsets_up_to = G_MAXSIZE;",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2023-32665",
        "func_name": "GNOME/glib/gvs_variable_sized_maybe_serialise",
        "description": "A flaw was found in GLib. GVariant deserialization is vulnerable to an exponential blowup issue where a crafted GVariant can cause excessive processing, leading to denial of service.",
        "git_url": "https://github.com/GNOME/glib/commit/ade71fb544391b2e33e1859645726bfee0d5eaaf",
        "commit_title": "gvariant: Don’t allow child elements to overlap with each other",
        "commit_text": " If different elements of a variable sized array can overlap with each other then we can cause a `GVariant` to normalise to a much larger type.  This commit changes the behaviour of `GVariant` with non-normal form data. If an invalid frame offset is found all subsequent elements are given their default value.  When retrieving an element at index `n` we scan the frame offsets up to index `n` and if they are not in order we return an element with the default value for that type.  This guarantees that elements don't overlap with each other.  We remember the offset we've scanned up to so we don't need to repeat this work on subsequent accesses.  We skip these checks for trusted data.  Unfortunately this makes random access of untrusted data O(n) — at least on first access.  It doesn't affect the algorithmic complexity of accessing elements in order, such as when using the `GVariantIter` interface.  Also: the cost of validation will be amortised as the `GVariant` instance is continued to be used.  I've implemented this with 4 different functions, 1 for each element size, rather than looping calling `gvs_read_unaligned_le` in the hope that the compiler will find it easy to optimise and should produce fairly tight code. ",
        "func_before": "static void\ngvs_variable_sized_maybe_serialise (GVariantSerialised        value,\n                                    GVariantSerialisedFiller  gvs_filler,\n                                    const gpointer           *children,\n                                    gsize                     n_children)\n{\n  if (n_children)\n    {\n      GVariantSerialised child = { NULL, value.data, value.size - 1, value.depth + 1 };\n\n      /* write the data for the child.  */\n      gvs_filler (&child, children[0]);\n      value.data[child.size] = '\\0';\n    }\n}",
        "func": "static void\ngvs_variable_sized_maybe_serialise (GVariantSerialised        value,\n                                    GVariantSerialisedFiller  gvs_filler,\n                                    const gpointer           *children,\n                                    gsize                     n_children)\n{\n  if (n_children)\n    {\n      GVariantSerialised child = { NULL, value.data, value.size - 1, value.depth + 1, 0 };\n\n      /* write the data for the child.  */\n      gvs_filler (&child, children[0]);\n      value.data[child.size] = '\\0';\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,7 +6,7 @@\n {\n   if (n_children)\n     {\n-      GVariantSerialised child = { NULL, value.data, value.size - 1, value.depth + 1 };\n+      GVariantSerialised child = { NULL, value.data, value.size - 1, value.depth + 1, 0 };\n \n       /* write the data for the child.  */\n       gvs_filler (&child, children[0]);",
        "diff_line_info": {
            "deleted_lines": [
                "      GVariantSerialised child = { NULL, value.data, value.size - 1, value.depth + 1 };"
            ],
            "added_lines": [
                "      GVariantSerialised child = { NULL, value.data, value.size - 1, value.depth + 1, 0 };"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-32665",
        "func_name": "GNOME/glib/gvs_fixed_sized_maybe_get_child",
        "description": "A flaw was found in GLib. GVariant deserialization is vulnerable to an exponential blowup issue where a crafted GVariant can cause excessive processing, leading to denial of service.",
        "git_url": "https://github.com/GNOME/glib/commit/ade71fb544391b2e33e1859645726bfee0d5eaaf",
        "commit_title": "gvariant: Don’t allow child elements to overlap with each other",
        "commit_text": " If different elements of a variable sized array can overlap with each other then we can cause a `GVariant` to normalise to a much larger type.  This commit changes the behaviour of `GVariant` with non-normal form data. If an invalid frame offset is found all subsequent elements are given their default value.  When retrieving an element at index `n` we scan the frame offsets up to index `n` and if they are not in order we return an element with the default value for that type.  This guarantees that elements don't overlap with each other.  We remember the offset we've scanned up to so we don't need to repeat this work on subsequent accesses.  We skip these checks for trusted data.  Unfortunately this makes random access of untrusted data O(n) — at least on first access.  It doesn't affect the algorithmic complexity of accessing elements in order, such as when using the `GVariantIter` interface.  Also: the cost of validation will be amortised as the `GVariant` instance is continued to be used.  I've implemented this with 4 different functions, 1 for each element size, rather than looping calling `gvs_read_unaligned_le` in the hope that the compiler will find it easy to optimise and should produce fairly tight code. ",
        "func_before": "static GVariantSerialised\ngvs_fixed_sized_maybe_get_child (GVariantSerialised value,\n                                 gsize              index_)\n{\n  /* the child has the same bounds as the\n   * container, so just update the type.\n   */\n  value.type_info = g_variant_type_info_element (value.type_info);\n  g_variant_type_info_ref (value.type_info);\n  value.depth++;\n\n  return value;\n}",
        "func": "static GVariantSerialised\ngvs_fixed_sized_maybe_get_child (GVariantSerialised value,\n                                 gsize              index_)\n{\n  /* the child has the same bounds as the\n   * container, so just update the type.\n   */\n  value.type_info = g_variant_type_info_element (value.type_info);\n  g_variant_type_info_ref (value.type_info);\n  value.depth++;\n  value.ordered_offsets_up_to = 0;\n\n  return value;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -8,6 +8,7 @@\n   value.type_info = g_variant_type_info_element (value.type_info);\n   g_variant_type_info_ref (value.type_info);\n   value.depth++;\n+  value.ordered_offsets_up_to = 0;\n \n   return value;\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "  value.ordered_offsets_up_to = 0;"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-32665",
        "func_name": "GNOME/glib/gvs_fixed_sized_maybe_is_normal",
        "description": "A flaw was found in GLib. GVariant deserialization is vulnerable to an exponential blowup issue where a crafted GVariant can cause excessive processing, leading to denial of service.",
        "git_url": "https://github.com/GNOME/glib/commit/ade71fb544391b2e33e1859645726bfee0d5eaaf",
        "commit_title": "gvariant: Don’t allow child elements to overlap with each other",
        "commit_text": " If different elements of a variable sized array can overlap with each other then we can cause a `GVariant` to normalise to a much larger type.  This commit changes the behaviour of `GVariant` with non-normal form data. If an invalid frame offset is found all subsequent elements are given their default value.  When retrieving an element at index `n` we scan the frame offsets up to index `n` and if they are not in order we return an element with the default value for that type.  This guarantees that elements don't overlap with each other.  We remember the offset we've scanned up to so we don't need to repeat this work on subsequent accesses.  We skip these checks for trusted data.  Unfortunately this makes random access of untrusted data O(n) — at least on first access.  It doesn't affect the algorithmic complexity of accessing elements in order, such as when using the `GVariantIter` interface.  Also: the cost of validation will be amortised as the `GVariant` instance is continued to be used.  I've implemented this with 4 different functions, 1 for each element size, rather than looping calling `gvs_read_unaligned_le` in the hope that the compiler will find it easy to optimise and should produce fairly tight code. ",
        "func_before": "static gboolean\ngvs_fixed_sized_maybe_is_normal (GVariantSerialised value)\n{\n  if (value.size > 0)\n    {\n      gsize element_fixed_size;\n\n      g_variant_type_info_query_element (value.type_info,\n                                         NULL, &element_fixed_size);\n\n      if (value.size != element_fixed_size)\n        return FALSE;\n\n      /* proper element size: \"Just\".  recurse to the child. */\n      value.type_info = g_variant_type_info_element (value.type_info);\n      value.depth++;\n\n      return g_variant_serialised_is_normal (value);\n    }\n\n  /* size of 0: \"Nothing\" */\n  return TRUE;\n}",
        "func": "static gboolean\ngvs_fixed_sized_maybe_is_normal (GVariantSerialised value)\n{\n  if (value.size > 0)\n    {\n      gsize element_fixed_size;\n\n      g_variant_type_info_query_element (value.type_info,\n                                         NULL, &element_fixed_size);\n\n      if (value.size != element_fixed_size)\n        return FALSE;\n\n      /* proper element size: \"Just\".  recurse to the child. */\n      value.type_info = g_variant_type_info_element (value.type_info);\n      value.depth++;\n      value.ordered_offsets_up_to = 0;\n\n      return g_variant_serialised_is_normal (value);\n    }\n\n  /* size of 0: \"Nothing\" */\n  return TRUE;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -14,6 +14,7 @@\n       /* proper element size: \"Just\".  recurse to the child. */\n       value.type_info = g_variant_type_info_element (value.type_info);\n       value.depth++;\n+      value.ordered_offsets_up_to = 0;\n \n       return g_variant_serialised_is_normal (value);\n     }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "      value.ordered_offsets_up_to = 0;"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-32665",
        "func_name": "GNOME/glib/gvs_variable_sized_maybe_get_child",
        "description": "A flaw was found in GLib. GVariant deserialization is vulnerable to an exponential blowup issue where a crafted GVariant can cause excessive processing, leading to denial of service.",
        "git_url": "https://github.com/GNOME/glib/commit/ade71fb544391b2e33e1859645726bfee0d5eaaf",
        "commit_title": "gvariant: Don’t allow child elements to overlap with each other",
        "commit_text": " If different elements of a variable sized array can overlap with each other then we can cause a `GVariant` to normalise to a much larger type.  This commit changes the behaviour of `GVariant` with non-normal form data. If an invalid frame offset is found all subsequent elements are given their default value.  When retrieving an element at index `n` we scan the frame offsets up to index `n` and if they are not in order we return an element with the default value for that type.  This guarantees that elements don't overlap with each other.  We remember the offset we've scanned up to so we don't need to repeat this work on subsequent accesses.  We skip these checks for trusted data.  Unfortunately this makes random access of untrusted data O(n) — at least on first access.  It doesn't affect the algorithmic complexity of accessing elements in order, such as when using the `GVariantIter` interface.  Also: the cost of validation will be amortised as the `GVariant` instance is continued to be used.  I've implemented this with 4 different functions, 1 for each element size, rather than looping calling `gvs_read_unaligned_le` in the hope that the compiler will find it easy to optimise and should produce fairly tight code. ",
        "func_before": "static GVariantSerialised\ngvs_variable_sized_maybe_get_child (GVariantSerialised value,\n                                    gsize              index_)\n{\n  /* remove the padding byte and update the type. */\n  value.type_info = g_variant_type_info_element (value.type_info);\n  g_variant_type_info_ref (value.type_info);\n  value.size--;\n\n  /* if it's zero-sized then it may as well be NULL */\n  if (value.size == 0)\n    value.data = NULL;\n\n  value.depth++;\n\n  return value;\n}",
        "func": "static GVariantSerialised\ngvs_variable_sized_maybe_get_child (GVariantSerialised value,\n                                    gsize              index_)\n{\n  /* remove the padding byte and update the type. */\n  value.type_info = g_variant_type_info_element (value.type_info);\n  g_variant_type_info_ref (value.type_info);\n  value.size--;\n\n  /* if it's zero-sized then it may as well be NULL */\n  if (value.size == 0)\n    value.data = NULL;\n\n  value.depth++;\n  value.ordered_offsets_up_to = 0;\n\n  return value;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -12,6 +12,7 @@\n     value.data = NULL;\n \n   value.depth++;\n+  value.ordered_offsets_up_to = 0;\n \n   return value;\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "  value.ordered_offsets_up_to = 0;"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-32665",
        "func_name": "GNOME/glib/gvs_tuple_is_normal",
        "description": "A flaw was found in GLib. GVariant deserialization is vulnerable to an exponential blowup issue where a crafted GVariant can cause excessive processing, leading to denial of service.",
        "git_url": "https://github.com/GNOME/glib/commit/ade71fb544391b2e33e1859645726bfee0d5eaaf",
        "commit_title": "gvariant: Don’t allow child elements to overlap with each other",
        "commit_text": " If different elements of a variable sized array can overlap with each other then we can cause a `GVariant` to normalise to a much larger type.  This commit changes the behaviour of `GVariant` with non-normal form data. If an invalid frame offset is found all subsequent elements are given their default value.  When retrieving an element at index `n` we scan the frame offsets up to index `n` and if they are not in order we return an element with the default value for that type.  This guarantees that elements don't overlap with each other.  We remember the offset we've scanned up to so we don't need to repeat this work on subsequent accesses.  We skip these checks for trusted data.  Unfortunately this makes random access of untrusted data O(n) — at least on first access.  It doesn't affect the algorithmic complexity of accessing elements in order, such as when using the `GVariantIter` interface.  Also: the cost of validation will be amortised as the `GVariant` instance is continued to be used.  I've implemented this with 4 different functions, 1 for each element size, rather than looping calling `gvs_read_unaligned_le` in the hope that the compiler will find it easy to optimise and should produce fairly tight code. ",
        "func_before": "static gboolean\ngvs_tuple_is_normal (GVariantSerialised value)\n{\n  guint offset_size;\n  gsize offset_ptr;\n  gsize length;\n  gsize offset;\n  gsize i;\n\n  /* as per the comment in gvs_tuple_get_child() */\n  if G_UNLIKELY (value.data == NULL && value.size != 0)\n    return FALSE;\n\n  offset_size = gvs_get_offset_size (value.size);\n  length = g_variant_type_info_n_members (value.type_info);\n  offset_ptr = value.size;\n  offset = 0;\n\n  for (i = 0; i < length; i++)\n    {\n      const GVariantMemberInfo *member_info;\n      GVariantSerialised child;\n      gsize fixed_size;\n      guint alignment;\n      gsize end;\n\n      member_info = g_variant_type_info_member_info (value.type_info, i);\n      child.type_info = member_info->type_info;\n      child.depth = value.depth + 1;\n\n      g_variant_type_info_query (child.type_info, &alignment, &fixed_size);\n\n      while (offset & alignment)\n        {\n          if (offset > value.size || value.data[offset] != '\\0')\n            return FALSE;\n          offset++;\n        }\n\n      child.data = value.data + offset;\n\n      switch (member_info->ending_type)\n        {\n        case G_VARIANT_MEMBER_ENDING_FIXED:\n          end = offset + fixed_size;\n          break;\n\n        case G_VARIANT_MEMBER_ENDING_LAST:\n          end = offset_ptr;\n          break;\n\n        case G_VARIANT_MEMBER_ENDING_OFFSET:\n          if (offset_ptr < offset_size)\n            return FALSE;\n\n          offset_ptr -= offset_size;\n\n          if (offset_ptr < offset)\n            return FALSE;\n\n          end = gvs_read_unaligned_le (value.data + offset_ptr, offset_size);\n          break;\n\n        default:\n          g_assert_not_reached ();\n        }\n\n      if (end < offset || end > offset_ptr)\n        return FALSE;\n\n      child.size = end - offset;\n\n      if (child.size == 0)\n        child.data = NULL;\n\n      if (!g_variant_serialised_is_normal (child))\n        return FALSE;\n\n      offset = end;\n    }\n\n  {\n    gsize fixed_size;\n    guint alignment;\n\n    g_variant_type_info_query (value.type_info, &alignment, &fixed_size);\n\n    if (fixed_size)\n      {\n        g_assert (fixed_size == value.size);\n        g_assert (offset_ptr == value.size);\n\n        if (i == 0)\n          {\n            if (value.data[offset++] != '\\0')\n              return FALSE;\n          }\n        else\n          {\n            while (offset & alignment)\n              if (value.data[offset++] != '\\0')\n                return FALSE;\n          }\n\n        g_assert (offset == value.size);\n      }\n  }\n\n  return offset_ptr == offset;\n}",
        "func": "static gboolean\ngvs_tuple_is_normal (GVariantSerialised value)\n{\n  guint offset_size;\n  gsize offset_ptr;\n  gsize length;\n  gsize offset;\n  gsize i;\n\n  /* as per the comment in gvs_tuple_get_child() */\n  if G_UNLIKELY (value.data == NULL && value.size != 0)\n    return FALSE;\n\n  offset_size = gvs_get_offset_size (value.size);\n  length = g_variant_type_info_n_members (value.type_info);\n  offset_ptr = value.size;\n  offset = 0;\n\n  for (i = 0; i < length; i++)\n    {\n      const GVariantMemberInfo *member_info;\n      GVariantSerialised child = { 0, };\n      gsize fixed_size;\n      guint alignment;\n      gsize end;\n\n      member_info = g_variant_type_info_member_info (value.type_info, i);\n      child.type_info = member_info->type_info;\n      child.depth = value.depth + 1;\n\n      g_variant_type_info_query (child.type_info, &alignment, &fixed_size);\n\n      while (offset & alignment)\n        {\n          if (offset > value.size || value.data[offset] != '\\0')\n            return FALSE;\n          offset++;\n        }\n\n      child.data = value.data + offset;\n\n      switch (member_info->ending_type)\n        {\n        case G_VARIANT_MEMBER_ENDING_FIXED:\n          end = offset + fixed_size;\n          break;\n\n        case G_VARIANT_MEMBER_ENDING_LAST:\n          end = offset_ptr;\n          break;\n\n        case G_VARIANT_MEMBER_ENDING_OFFSET:\n          if (offset_ptr < offset_size)\n            return FALSE;\n\n          offset_ptr -= offset_size;\n\n          if (offset_ptr < offset)\n            return FALSE;\n\n          end = gvs_read_unaligned_le (value.data + offset_ptr, offset_size);\n          break;\n\n        default:\n          g_assert_not_reached ();\n        }\n\n      if (end < offset || end > offset_ptr)\n        return FALSE;\n\n      child.size = end - offset;\n\n      if (child.size == 0)\n        child.data = NULL;\n\n      if (!g_variant_serialised_is_normal (child))\n        return FALSE;\n\n      offset = end;\n    }\n\n  /* All element bounds have been checked above. */\n  value.ordered_offsets_up_to = G_MAXSIZE;\n\n  {\n    gsize fixed_size;\n    guint alignment;\n\n    g_variant_type_info_query (value.type_info, &alignment, &fixed_size);\n\n    if (fixed_size)\n      {\n        g_assert (fixed_size == value.size);\n        g_assert (offset_ptr == value.size);\n\n        if (i == 0)\n          {\n            if (value.data[offset++] != '\\0')\n              return FALSE;\n          }\n        else\n          {\n            while (offset & alignment)\n              if (value.data[offset++] != '\\0')\n                return FALSE;\n          }\n\n        g_assert (offset == value.size);\n      }\n  }\n\n  return offset_ptr == offset;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -19,7 +19,7 @@\n   for (i = 0; i < length; i++)\n     {\n       const GVariantMemberInfo *member_info;\n-      GVariantSerialised child;\n+      GVariantSerialised child = { 0, };\n       gsize fixed_size;\n       guint alignment;\n       gsize end;\n@@ -79,6 +79,9 @@\n       offset = end;\n     }\n \n+  /* All element bounds have been checked above. */\n+  value.ordered_offsets_up_to = G_MAXSIZE;\n+\n   {\n     gsize fixed_size;\n     guint alignment;",
        "diff_line_info": {
            "deleted_lines": [
                "      GVariantSerialised child;"
            ],
            "added_lines": [
                "      GVariantSerialised child = { 0, };",
                "  /* All element bounds have been checked above. */",
                "  value.ordered_offsets_up_to = G_MAXSIZE;",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2023-32665",
        "func_name": "GNOME/glib/gvs_fixed_sized_maybe_serialise",
        "description": "A flaw was found in GLib. GVariant deserialization is vulnerable to an exponential blowup issue where a crafted GVariant can cause excessive processing, leading to denial of service.",
        "git_url": "https://github.com/GNOME/glib/commit/ade71fb544391b2e33e1859645726bfee0d5eaaf",
        "commit_title": "gvariant: Don’t allow child elements to overlap with each other",
        "commit_text": " If different elements of a variable sized array can overlap with each other then we can cause a `GVariant` to normalise to a much larger type.  This commit changes the behaviour of `GVariant` with non-normal form data. If an invalid frame offset is found all subsequent elements are given their default value.  When retrieving an element at index `n` we scan the frame offsets up to index `n` and if they are not in order we return an element with the default value for that type.  This guarantees that elements don't overlap with each other.  We remember the offset we've scanned up to so we don't need to repeat this work on subsequent accesses.  We skip these checks for trusted data.  Unfortunately this makes random access of untrusted data O(n) — at least on first access.  It doesn't affect the algorithmic complexity of accessing elements in order, such as when using the `GVariantIter` interface.  Also: the cost of validation will be amortised as the `GVariant` instance is continued to be used.  I've implemented this with 4 different functions, 1 for each element size, rather than looping calling `gvs_read_unaligned_le` in the hope that the compiler will find it easy to optimise and should produce fairly tight code. ",
        "func_before": "static void\ngvs_fixed_sized_maybe_serialise (GVariantSerialised        value,\n                                 GVariantSerialisedFiller  gvs_filler,\n                                 const gpointer           *children,\n                                 gsize                     n_children)\n{\n  if (n_children)\n    {\n      GVariantSerialised child = { NULL, value.data, value.size, value.depth + 1 };\n\n      gvs_filler (&child, children[0]);\n    }\n}",
        "func": "static void\ngvs_fixed_sized_maybe_serialise (GVariantSerialised        value,\n                                 GVariantSerialisedFiller  gvs_filler,\n                                 const gpointer           *children,\n                                 gsize                     n_children)\n{\n  if (n_children)\n    {\n      GVariantSerialised child = { NULL, value.data, value.size, value.depth + 1, 0 };\n\n      gvs_filler (&child, children[0]);\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,7 +6,7 @@\n {\n   if (n_children)\n     {\n-      GVariantSerialised child = { NULL, value.data, value.size, value.depth + 1 };\n+      GVariantSerialised child = { NULL, value.data, value.size, value.depth + 1, 0 };\n \n       gvs_filler (&child, children[0]);\n     }",
        "diff_line_info": {
            "deleted_lines": [
                "      GVariantSerialised child = { NULL, value.data, value.size, value.depth + 1 };"
            ],
            "added_lines": [
                "      GVariantSerialised child = { NULL, value.data, value.size, value.depth + 1, 0 };"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-32665",
        "func_name": "GNOME/glib/gvs_variable_sized_maybe_is_normal",
        "description": "A flaw was found in GLib. GVariant deserialization is vulnerable to an exponential blowup issue where a crafted GVariant can cause excessive processing, leading to denial of service.",
        "git_url": "https://github.com/GNOME/glib/commit/ade71fb544391b2e33e1859645726bfee0d5eaaf",
        "commit_title": "gvariant: Don’t allow child elements to overlap with each other",
        "commit_text": " If different elements of a variable sized array can overlap with each other then we can cause a `GVariant` to normalise to a much larger type.  This commit changes the behaviour of `GVariant` with non-normal form data. If an invalid frame offset is found all subsequent elements are given their default value.  When retrieving an element at index `n` we scan the frame offsets up to index `n` and if they are not in order we return an element with the default value for that type.  This guarantees that elements don't overlap with each other.  We remember the offset we've scanned up to so we don't need to repeat this work on subsequent accesses.  We skip these checks for trusted data.  Unfortunately this makes random access of untrusted data O(n) — at least on first access.  It doesn't affect the algorithmic complexity of accessing elements in order, such as when using the `GVariantIter` interface.  Also: the cost of validation will be amortised as the `GVariant` instance is continued to be used.  I've implemented this with 4 different functions, 1 for each element size, rather than looping calling `gvs_read_unaligned_le` in the hope that the compiler will find it easy to optimise and should produce fairly tight code. ",
        "func_before": "static gboolean\ngvs_variable_sized_maybe_is_normal (GVariantSerialised value)\n{\n  if (value.size == 0)\n    return TRUE;\n\n  if (value.data[value.size - 1] != '\\0')\n    return FALSE;\n\n  value.type_info = g_variant_type_info_element (value.type_info);\n  value.size--;\n  value.depth++;\n\n  return g_variant_serialised_is_normal (value);\n}",
        "func": "static gboolean\ngvs_variable_sized_maybe_is_normal (GVariantSerialised value)\n{\n  if (value.size == 0)\n    return TRUE;\n\n  if (value.data[value.size - 1] != '\\0')\n    return FALSE;\n\n  value.type_info = g_variant_type_info_element (value.type_info);\n  value.size--;\n  value.depth++;\n  value.ordered_offsets_up_to = 0;\n\n  return g_variant_serialised_is_normal (value);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -10,6 +10,7 @@\n   value.type_info = g_variant_type_info_element (value.type_info);\n   value.size--;\n   value.depth++;\n+  value.ordered_offsets_up_to = 0;\n \n   return g_variant_serialised_is_normal (value);\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "  value.ordered_offsets_up_to = 0;"
            ]
        }
    }
]