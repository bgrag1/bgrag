[
    {
        "cve_id": "CVE-2016-10517",
        "func_name": "redis/processInputBuffer",
        "description": "networking.c in Redis before 3.2.7 allows \"Cross Protocol Scripting\" because it lacks a check for POST and Host: strings, which are not valid in the Redis protocol (but commonly occur when an attack triggers an HTTP request to the Redis TCP port).",
        "git_url": "https://github.com/redis/redis/commit/874804da0c014a7d704b3d285aa500098a931f50",
        "commit_title": "Security: Cross Protocol Scripting protection.",
        "commit_text": " This is an attempt at mitigating problems due to cross protocol scripting, an attack targeting services using line oriented protocols like Redis that can accept HTTP requests as valid protocol, by discarding the invalid parts and accepting the payloads sent, for example, via a POST request.  For this to be effective, when we detect POST and Host: and terminate the connection asynchronously, the networking code was modified in order to never process further input. It was later verified that in a pipelined request containing a POST command, the successive commands are not executed.",
        "func_before": "void processInputBuffer(client *c) {\n    server.current_client = c;\n    /* Keep processing while there is something in the input buffer */\n    while(sdslen(c->querybuf)) {\n        /* Return if clients are paused. */\n        if (!(c->flags & CLIENT_SLAVE) && clientsArePaused()) break;\n\n        /* Immediately abort if the client is in the middle of something. */\n        if (c->flags & CLIENT_BLOCKED) break;\n\n        /* CLIENT_CLOSE_AFTER_REPLY closes the connection once the reply is\n         * written to the client. Make sure to not let the reply grow after\n         * this flag has been set (i.e. don't process more commands). */\n        if (c->flags & CLIENT_CLOSE_AFTER_REPLY) break;\n\n        /* Determine request type when unknown. */\n        if (!c->reqtype) {\n            if (c->querybuf[0] == '*') {\n                c->reqtype = PROTO_REQ_MULTIBULK;\n            } else {\n                c->reqtype = PROTO_REQ_INLINE;\n            }\n        }\n\n        if (c->reqtype == PROTO_REQ_INLINE) {\n            if (processInlineBuffer(c) != C_OK) break;\n        } else if (c->reqtype == PROTO_REQ_MULTIBULK) {\n            if (processMultibulkBuffer(c) != C_OK) break;\n        } else {\n            serverPanic(\"Unknown request type\");\n        }\n\n        /* Multibulk processing could see a <= 0 length. */\n        if (c->argc == 0) {\n            resetClient(c);\n        } else {\n            /* Only reset the client when the command was executed. */\n            if (processCommand(c) == C_OK)\n                resetClient(c);\n            /* freeMemoryIfNeeded may flush slave output buffers. This may result\n             * into a slave, that may be the active client, to be freed. */\n            if (server.current_client == NULL) break;\n        }\n    }\n    server.current_client = NULL;\n}",
        "func": "void processInputBuffer(client *c) {\n    server.current_client = c;\n    /* Keep processing while there is something in the input buffer */\n    while(sdslen(c->querybuf)) {\n        /* Return if clients are paused. */\n        if (!(c->flags & CLIENT_SLAVE) && clientsArePaused()) break;\n\n        /* Immediately abort if the client is in the middle of something. */\n        if (c->flags & CLIENT_BLOCKED) break;\n\n        /* CLIENT_CLOSE_AFTER_REPLY closes the connection once the reply is\n         * written to the client. Make sure to not let the reply grow after\n         * this flag has been set (i.e. don't process more commands).\n         *\n         * The same applies for clients we want to terminate ASAP. */\n        if (c->flags & (CLIENT_CLOSE_AFTER_REPLY|CLIENT_CLOSE_ASAP)) break;\n\n        /* Determine request type when unknown. */\n        if (!c->reqtype) {\n            if (c->querybuf[0] == '*') {\n                c->reqtype = PROTO_REQ_MULTIBULK;\n            } else {\n                c->reqtype = PROTO_REQ_INLINE;\n            }\n        }\n\n        if (c->reqtype == PROTO_REQ_INLINE) {\n            if (processInlineBuffer(c) != C_OK) break;\n        } else if (c->reqtype == PROTO_REQ_MULTIBULK) {\n            if (processMultibulkBuffer(c) != C_OK) break;\n        } else {\n            serverPanic(\"Unknown request type\");\n        }\n\n        /* Multibulk processing could see a <= 0 length. */\n        if (c->argc == 0) {\n            resetClient(c);\n        } else {\n            /* Only reset the client when the command was executed. */\n            if (processCommand(c) == C_OK)\n                resetClient(c);\n            /* freeMemoryIfNeeded may flush slave output buffers. This may result\n             * into a slave, that may be the active client, to be freed. */\n            if (server.current_client == NULL) break;\n        }\n    }\n    server.current_client = NULL;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -10,8 +10,10 @@\n \n         /* CLIENT_CLOSE_AFTER_REPLY closes the connection once the reply is\n          * written to the client. Make sure to not let the reply grow after\n-         * this flag has been set (i.e. don't process more commands). */\n-        if (c->flags & CLIENT_CLOSE_AFTER_REPLY) break;\n+         * this flag has been set (i.e. don't process more commands).\n+         *\n+         * The same applies for clients we want to terminate ASAP. */\n+        if (c->flags & (CLIENT_CLOSE_AFTER_REPLY|CLIENT_CLOSE_ASAP)) break;\n \n         /* Determine request type when unknown. */\n         if (!c->reqtype) {",
        "diff_line_info": {
            "deleted_lines": [
                "         * this flag has been set (i.e. don't process more commands). */",
                "        if (c->flags & CLIENT_CLOSE_AFTER_REPLY) break;"
            ],
            "added_lines": [
                "         * this flag has been set (i.e. don't process more commands).",
                "         *",
                "         * The same applies for clients we want to terminate ASAP. */",
                "        if (c->flags & (CLIENT_CLOSE_AFTER_REPLY|CLIENT_CLOSE_ASAP)) break;"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-7837",
        "func_name": "mjg59/linux/setup_efi_state",
        "description": "The Linux kernel, as used in Red Hat Enterprise Linux 7, kernel-rt, and Enterprise MRG 2 and when booted with UEFI Secure Boot enabled, allows local users to bypass intended securelevel/secureboot restrictions by leveraging improper handling of secure_boot flag across kexec reboot.",
        "git_url": "https://github.com/mjg59/linux/commit/4b2b64d5a6ebc84214755ebccd599baef7c1b798",
        "commit_title": "kexec/uefi: copy secure_boot flag in boot params across kexec reboot",
        "commit_text": " Kexec reboot in case secure boot being enabled does not keep the secure boot mode in new kernel, so later one can load unsigned kernel via legacy kexec_load.  In this state, the system is missing the protections provided by secure boot. Adding a patch to fix this by retain the secure_boot flag in original kernel.  secure_boot flag in boot_params is set in EFI stub, but kexec bypasses the stub. Fixing this issue by copying secure_boot flag across kexec reboot. ",
        "func_before": "static int\nsetup_efi_state(struct boot_params *params, unsigned long params_load_addr,\n\t\tunsigned int efi_map_offset, unsigned int efi_map_sz,\n\t\tunsigned int efi_setup_data_offset)\n{\n\tstruct efi_info *current_ei = &boot_params.efi_info;\n\tstruct efi_info *ei = &params->efi_info;\n\n\tif (!current_ei->efi_memmap_size)\n\t\treturn 0;\n\n\t/*\n\t * If 1:1 mapping is not enabled, second kernel can not setup EFI\n\t * and use EFI run time services. User space will have to pass\n\t * acpi_rsdp=<addr> on kernel command line to make second kernel boot\n\t * without efi.\n\t */\n\tif (efi_enabled(EFI_OLD_MEMMAP))\n\t\treturn 0;\n\n\tei->efi_loader_signature = current_ei->efi_loader_signature;\n\tei->efi_systab = current_ei->efi_systab;\n\tei->efi_systab_hi = current_ei->efi_systab_hi;\n\n\tei->efi_memdesc_version = current_ei->efi_memdesc_version;\n\tei->efi_memdesc_size = efi_get_runtime_map_desc_size();\n\n\tsetup_efi_info_memmap(params, params_load_addr, efi_map_offset,\n\t\t\t      efi_map_sz);\n\tprepare_add_efi_setup_data(params, params_load_addr,\n\t\t\t\t   efi_setup_data_offset);\n\treturn 0;\n}",
        "func": "static int\nsetup_efi_state(struct boot_params *params, unsigned long params_load_addr,\n\t\tunsigned int efi_map_offset, unsigned int efi_map_sz,\n\t\tunsigned int efi_setup_data_offset)\n{\n\tstruct efi_info *current_ei = &boot_params.efi_info;\n\tstruct efi_info *ei = &params->efi_info;\n\n\tif (!current_ei->efi_memmap_size)\n\t\treturn 0;\n\n\t/*\n\t * If 1:1 mapping is not enabled, second kernel can not setup EFI\n\t * and use EFI run time services. User space will have to pass\n\t * acpi_rsdp=<addr> on kernel command line to make second kernel boot\n\t * without efi.\n\t */\n\tif (efi_enabled(EFI_OLD_MEMMAP))\n\t\treturn 0;\n\n\tparams->secure_boot = boot_params.secure_boot;\n\tei->efi_loader_signature = current_ei->efi_loader_signature;\n\tei->efi_systab = current_ei->efi_systab;\n\tei->efi_systab_hi = current_ei->efi_systab_hi;\n\n\tei->efi_memdesc_version = current_ei->efi_memdesc_version;\n\tei->efi_memdesc_size = efi_get_runtime_map_desc_size();\n\n\tsetup_efi_info_memmap(params, params_load_addr, efi_map_offset,\n\t\t\t      efi_map_sz);\n\tprepare_add_efi_setup_data(params, params_load_addr,\n\t\t\t\t   efi_setup_data_offset);\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -18,6 +18,7 @@\n \tif (efi_enabled(EFI_OLD_MEMMAP))\n \t\treturn 0;\n \n+\tparams->secure_boot = boot_params.secure_boot;\n \tei->efi_loader_signature = current_ei->efi_loader_signature;\n \tei->efi_systab = current_ei->efi_systab;\n \tei->efi_systab_hi = current_ei->efi_systab_hi;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tparams->secure_boot = boot_params.secure_boot;"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-0824",
        "func_name": "android/impeg2d_dec_d_slice",
        "description": "libmpeg2 in libstagefright in Android 6.x before 2016-03-01 allows attackers to obtain sensitive information, and consequently bypass an unspecified protection mechanism, via crafted Bitstream data, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 25765591.",
        "git_url": "https://android.googlesource.com/platform/external/libmpeg2/+/ffab15eb80630dc799eb410855c93525b75233c3",
        "commit_title": "Fixed bit stream access to make sure that it is not read beyond the allocated size.",
        "commit_text": " Bug: 25765591  ",
        "func_before": "IMPEG2D_ERROR_CODES_T impeg2d_dec_d_slice(dec_state_t *ps_dec)\n{\n    UWORD32 i;\n    yuv_buf_t *ps_cur_frm_buf  = &ps_dec->s_cur_frm_buf;\n\n    stream_t   *ps_stream       = &ps_dec->s_bit_stream;\n    UWORD8   *pu1_vld_buf;\n\n    WORD16 i2_dc_diff;\n    UWORD32 u4_frame_width = ps_dec->u2_frame_width;\n    UWORD32 u4_frm_offset = 0;\n    if(ps_dec->u2_picture_structure != FRAME_PICTURE)\n    {\n        u4_frame_width <<= 1;\n        if(ps_dec->u2_picture_structure == BOTTOM_FIELD)\n        {\n            u4_frm_offset = ps_dec->u2_frame_width;\n        }\n    }\n\n    do\n    {\n\n        UWORD32 u4_x_offset, u4_y_offset;\n        UWORD32 u4_blk_pos;\n        WORD16 i2_dc_val;\n\n        UWORD32 u4_dst_x_offset     = u4_frm_offset + (ps_dec->u2_mb_x << 4);\n        UWORD32 u4_dst_y_offset     = (ps_dec->u2_mb_y << 4) * u4_frame_width;\n        UWORD8 *pu1_vld_buf8        = ps_cur_frm_buf->pu1_y + u4_dst_x_offset + u4_dst_y_offset;\n        UWORD32 u4_dst_wd           = u4_frame_width;\n        /*------------------------------------------------------------------*/\n        /* Discard the Macroblock stuffing in case of MPEG-1 stream         */\n        /*------------------------------------------------------------------*/\n        while(impeg2d_bit_stream_nxt(ps_stream,MB_STUFFING_CODE_LEN) == MB_STUFFING_CODE)\n            impeg2d_bit_stream_flush(ps_stream,MB_STUFFING_CODE_LEN);\n\n        /*------------------------------------------------------------------*/\n        /* Flush 2 bits from bitstream [MB_Type and MacroBlockAddrIncrement]*/\n        /*------------------------------------------------------------------*/\n        impeg2d_bit_stream_flush(ps_stream,1);\n\n        if(impeg2d_bit_stream_get(ps_stream, 1) != 0x01)\n        {\n            /* Ignore and continue decoding. */\n        }\n\n        /* Process LUMA blocks of the MB */\n        for(i = 0; i < NUM_LUMA_BLKS; ++i)\n        {\n\n            u4_x_offset    = gai2_impeg2_blk_x_off[i];\n            u4_y_offset    = gai2_impeg2_blk_y_off_frm[i] ;\n            u4_blk_pos     = (u4_y_offset * u4_dst_wd) + u4_x_offset;\n            pu1_vld_buf     = pu1_vld_buf8 + u4_blk_pos;\n\n            i2_dc_diff = impeg2d_get_luma_dc_diff(ps_stream);\n            i2_dc_val = ps_dec->u2_def_dc_pred[Y_LUMA] + i2_dc_diff;\n            ps_dec->u2_def_dc_pred[Y_LUMA] = i2_dc_val;\n            i2_dc_val = CLIP_U8(i2_dc_val);\n\n            ps_dec->pf_memset_8bit_8x8_block(pu1_vld_buf, i2_dc_val, u4_dst_wd);\n        }\n\n\n\n        /* Process U block of the MB */\n\n        u4_dst_x_offset                >>= 1;\n        u4_dst_y_offset                >>= 2;\n        u4_dst_wd                      >>= 1;\n        pu1_vld_buf                     = ps_cur_frm_buf->pu1_u + u4_dst_x_offset + u4_dst_y_offset;\n        i2_dc_diff                     = impeg2d_get_chroma_dc_diff(ps_stream);\n        i2_dc_val                      = ps_dec->u2_def_dc_pred[U_CHROMA] + i2_dc_diff;\n        ps_dec->u2_def_dc_pred[U_CHROMA]    = i2_dc_val;\n        i2_dc_val = CLIP_U8(i2_dc_val);\n        ps_dec->pf_memset_8bit_8x8_block(pu1_vld_buf, i2_dc_val, u4_dst_wd);\n\n\n        /* Process V block of the MB */\n\n        pu1_vld_buf                     = ps_cur_frm_buf->pu1_v + u4_dst_x_offset + u4_dst_y_offset;\n        i2_dc_diff                     = impeg2d_get_chroma_dc_diff(ps_stream);\n        i2_dc_val                      = ps_dec->u2_def_dc_pred[V_CHROMA] + i2_dc_diff;\n        ps_dec->u2_def_dc_pred[V_CHROMA]    = i2_dc_val;\n        i2_dc_val = CLIP_U8(i2_dc_val);\n        ps_dec->pf_memset_8bit_8x8_block(pu1_vld_buf, i2_dc_val, u4_dst_wd);\n\n        /* Common MB processing Steps */\n\n\n        ps_dec->u2_num_mbs_left--;\n        ps_dec->u2_mb_x++;\n\n        if(ps_dec->s_bit_stream.u4_offset > ps_dec->s_bit_stream.u4_max_offset)\n        {\n            return IMPEG2D_BITSTREAM_BUFF_EXCEEDED_ERR;\n        }\n        else if (ps_dec->u2_mb_x == ps_dec->u2_num_horiz_mb)\n        {\n            ps_dec->u2_mb_x = 0;\n            ps_dec->u2_mb_y++;\n\n        }\n\n        /* Flush end of macro block */\n        impeg2d_bit_stream_flush(ps_stream,1);\n    }\n    while(ps_dec->u2_num_mbs_left != 0 && impeg2d_bit_stream_nxt(&ps_dec->s_bit_stream,23) != 0x0);\n    return (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE;\n}",
        "func": "IMPEG2D_ERROR_CODES_T impeg2d_dec_d_slice(dec_state_t *ps_dec)\n{\n    UWORD32 i;\n    yuv_buf_t *ps_cur_frm_buf  = &ps_dec->s_cur_frm_buf;\n\n    stream_t   *ps_stream       = &ps_dec->s_bit_stream;\n    UWORD8   *pu1_vld_buf;\n\n    WORD16 i2_dc_diff;\n    UWORD32 u4_frame_width = ps_dec->u2_frame_width;\n    UWORD32 u4_frm_offset = 0;\n    if(ps_dec->u2_picture_structure != FRAME_PICTURE)\n    {\n        u4_frame_width <<= 1;\n        if(ps_dec->u2_picture_structure == BOTTOM_FIELD)\n        {\n            u4_frm_offset = ps_dec->u2_frame_width;\n        }\n    }\n\n    do\n    {\n\n        UWORD32 u4_x_offset, u4_y_offset;\n        UWORD32 u4_blk_pos;\n        WORD16 i2_dc_val;\n\n        UWORD32 u4_dst_x_offset     = u4_frm_offset + (ps_dec->u2_mb_x << 4);\n        UWORD32 u4_dst_y_offset     = (ps_dec->u2_mb_y << 4) * u4_frame_width;\n        UWORD8 *pu1_vld_buf8        = ps_cur_frm_buf->pu1_y + u4_dst_x_offset + u4_dst_y_offset;\n        UWORD32 u4_dst_wd           = u4_frame_width;\n        /*------------------------------------------------------------------*/\n        /* Discard the Macroblock stuffing in case of MPEG-1 stream         */\n        /*------------------------------------------------------------------*/\n        while(impeg2d_bit_stream_nxt(ps_stream,MB_STUFFING_CODE_LEN) == MB_STUFFING_CODE &&\n                ps_stream->u4_offset < ps_stream->u4_max_offset)\n            impeg2d_bit_stream_flush(ps_stream,MB_STUFFING_CODE_LEN);\n\n        /*------------------------------------------------------------------*/\n        /* Flush 2 bits from bitstream [MB_Type and MacroBlockAddrIncrement]*/\n        /*------------------------------------------------------------------*/\n        impeg2d_bit_stream_flush(ps_stream,1);\n\n        if(impeg2d_bit_stream_get(ps_stream, 1) != 0x01)\n        {\n            /* Ignore and continue decoding. */\n        }\n\n        /* Process LUMA blocks of the MB */\n        for(i = 0; i < NUM_LUMA_BLKS; ++i)\n        {\n\n            u4_x_offset    = gai2_impeg2_blk_x_off[i];\n            u4_y_offset    = gai2_impeg2_blk_y_off_frm[i] ;\n            u4_blk_pos     = (u4_y_offset * u4_dst_wd) + u4_x_offset;\n            pu1_vld_buf     = pu1_vld_buf8 + u4_blk_pos;\n\n            i2_dc_diff = impeg2d_get_luma_dc_diff(ps_stream);\n            i2_dc_val = ps_dec->u2_def_dc_pred[Y_LUMA] + i2_dc_diff;\n            ps_dec->u2_def_dc_pred[Y_LUMA] = i2_dc_val;\n            i2_dc_val = CLIP_U8(i2_dc_val);\n\n            ps_dec->pf_memset_8bit_8x8_block(pu1_vld_buf, i2_dc_val, u4_dst_wd);\n        }\n\n\n\n        /* Process U block of the MB */\n\n        u4_dst_x_offset                >>= 1;\n        u4_dst_y_offset                >>= 2;\n        u4_dst_wd                      >>= 1;\n        pu1_vld_buf                     = ps_cur_frm_buf->pu1_u + u4_dst_x_offset + u4_dst_y_offset;\n        i2_dc_diff                     = impeg2d_get_chroma_dc_diff(ps_stream);\n        i2_dc_val                      = ps_dec->u2_def_dc_pred[U_CHROMA] + i2_dc_diff;\n        ps_dec->u2_def_dc_pred[U_CHROMA]    = i2_dc_val;\n        i2_dc_val = CLIP_U8(i2_dc_val);\n        ps_dec->pf_memset_8bit_8x8_block(pu1_vld_buf, i2_dc_val, u4_dst_wd);\n\n\n        /* Process V block of the MB */\n\n        pu1_vld_buf                     = ps_cur_frm_buf->pu1_v + u4_dst_x_offset + u4_dst_y_offset;\n        i2_dc_diff                     = impeg2d_get_chroma_dc_diff(ps_stream);\n        i2_dc_val                      = ps_dec->u2_def_dc_pred[V_CHROMA] + i2_dc_diff;\n        ps_dec->u2_def_dc_pred[V_CHROMA]    = i2_dc_val;\n        i2_dc_val = CLIP_U8(i2_dc_val);\n        ps_dec->pf_memset_8bit_8x8_block(pu1_vld_buf, i2_dc_val, u4_dst_wd);\n\n        /* Common MB processing Steps */\n\n\n        ps_dec->u2_num_mbs_left--;\n        ps_dec->u2_mb_x++;\n\n        if(ps_dec->s_bit_stream.u4_offset > ps_dec->s_bit_stream.u4_max_offset)\n        {\n            return IMPEG2D_BITSTREAM_BUFF_EXCEEDED_ERR;\n        }\n        else if (ps_dec->u2_mb_x == ps_dec->u2_num_horiz_mb)\n        {\n            ps_dec->u2_mb_x = 0;\n            ps_dec->u2_mb_y++;\n\n        }\n\n        /* Flush end of macro block */\n        impeg2d_bit_stream_flush(ps_stream,1);\n    }\n    while(ps_dec->u2_num_mbs_left != 0 && impeg2d_bit_stream_nxt(&ps_dec->s_bit_stream,23) != 0x0);\n    return (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -32,7 +32,8 @@\n         /*------------------------------------------------------------------*/\n         /* Discard the Macroblock stuffing in case of MPEG-1 stream         */\n         /*------------------------------------------------------------------*/\n-        while(impeg2d_bit_stream_nxt(ps_stream,MB_STUFFING_CODE_LEN) == MB_STUFFING_CODE)\n+        while(impeg2d_bit_stream_nxt(ps_stream,MB_STUFFING_CODE_LEN) == MB_STUFFING_CODE &&\n+                ps_stream->u4_offset < ps_stream->u4_max_offset)\n             impeg2d_bit_stream_flush(ps_stream,MB_STUFFING_CODE_LEN);\n \n         /*------------------------------------------------------------------*/",
        "diff_line_info": {
            "deleted_lines": [
                "        while(impeg2d_bit_stream_nxt(ps_stream,MB_STUFFING_CODE_LEN) == MB_STUFFING_CODE)"
            ],
            "added_lines": [
                "        while(impeg2d_bit_stream_nxt(ps_stream,MB_STUFFING_CODE_LEN) == MB_STUFFING_CODE &&",
                "                ps_stream->u4_offset < ps_stream->u4_max_offset)"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-0824",
        "func_name": "android/impeg2d_dec_pic_ext_data",
        "description": "libmpeg2 in libstagefright in Android 6.x before 2016-03-01 allows attackers to obtain sensitive information, and consequently bypass an unspecified protection mechanism, via crafted Bitstream data, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 25765591.",
        "git_url": "https://android.googlesource.com/platform/external/libmpeg2/+/ffab15eb80630dc799eb410855c93525b75233c3",
        "commit_title": "Fixed bit stream access to make sure that it is not read beyond the allocated size.",
        "commit_text": " Bug: 25765591  ",
        "func_before": "IMPEG2D_ERROR_CODES_T impeg2d_dec_pic_ext_data(dec_state_t *ps_dec)\n{\n    stream_t   *ps_stream;\n    UWORD32     u4_start_code;\n    IMPEG2D_ERROR_CODES_T e_error;\n\n    e_error = (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE;\n\n    ps_stream      = &ps_dec->s_bit_stream;\n    u4_start_code   = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);\n    while ( (u4_start_code == EXTENSION_START_CODE ||\n            u4_start_code == USER_DATA_START_CODE) &&\n            (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error)\n    {\n        if(u4_start_code == USER_DATA_START_CODE)\n        {\n            impeg2d_dec_user_data(ps_dec);\n        }\n        else\n        {\n            impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);\n            u4_start_code   = impeg2d_bit_stream_nxt(ps_stream,EXT_ID_LEN);\n            switch(u4_start_code)\n            {\n            case QUANT_MATRIX_EXT_ID:\n                impeg2d_dec_quant_matrix_ext(ps_dec);\n                break;\n            case COPYRIGHT_EXT_ID:\n                impeg2d_dec_copyright_ext(ps_dec);\n                break;\n            case PIC_DISPLAY_EXT_ID:\n                impeg2d_dec_pic_disp_ext(ps_dec);\n                break;\n            case CAMERA_PARAM_EXT_ID:\n                impeg2d_dec_cam_param_ext(ps_dec);\n                break;\n            case ITU_T_EXT_ID:\n                impeg2d_dec_itu_t_ext(ps_dec);\n                break;\n            case PIC_SPATIAL_SCALABLE_EXT_ID:\n            case PIC_TEMPORAL_SCALABLE_EXT_ID:\n                e_error = IMPEG2D_SCALABLITY_NOT_SUP;\n                break;\n            default:\n                /* In case its a reserved extension code */\n                impeg2d_bit_stream_flush(ps_stream,EXT_ID_LEN);\n                impeg2d_next_start_code(ps_dec);\n                break;\n            }\n        }\n        u4_start_code = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);\n    }\n    return e_error;\n}",
        "func": "IMPEG2D_ERROR_CODES_T impeg2d_dec_pic_ext_data(dec_state_t *ps_dec)\n{\n    stream_t   *ps_stream;\n    UWORD32     u4_start_code;\n    IMPEG2D_ERROR_CODES_T e_error;\n\n    e_error = (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE;\n\n    ps_stream      = &ps_dec->s_bit_stream;\n    u4_start_code   = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);\n    while ( (u4_start_code == EXTENSION_START_CODE ||\n            u4_start_code == USER_DATA_START_CODE) &&\n            (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error &&\n            (ps_stream->u4_offset < ps_stream->u4_max_offset))\n    {\n        if(u4_start_code == USER_DATA_START_CODE)\n        {\n            impeg2d_dec_user_data(ps_dec);\n        }\n        else\n        {\n            impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);\n            u4_start_code   = impeg2d_bit_stream_nxt(ps_stream,EXT_ID_LEN);\n            switch(u4_start_code)\n            {\n            case QUANT_MATRIX_EXT_ID:\n                impeg2d_dec_quant_matrix_ext(ps_dec);\n                break;\n            case COPYRIGHT_EXT_ID:\n                impeg2d_dec_copyright_ext(ps_dec);\n                break;\n            case PIC_DISPLAY_EXT_ID:\n                impeg2d_dec_pic_disp_ext(ps_dec);\n                break;\n            case CAMERA_PARAM_EXT_ID:\n                impeg2d_dec_cam_param_ext(ps_dec);\n                break;\n            case ITU_T_EXT_ID:\n                impeg2d_dec_itu_t_ext(ps_dec);\n                break;\n            case PIC_SPATIAL_SCALABLE_EXT_ID:\n            case PIC_TEMPORAL_SCALABLE_EXT_ID:\n                e_error = IMPEG2D_SCALABLITY_NOT_SUP;\n                break;\n            default:\n                /* In case its a reserved extension code */\n                impeg2d_bit_stream_flush(ps_stream,EXT_ID_LEN);\n                impeg2d_next_start_code(ps_dec);\n                break;\n            }\n        }\n        u4_start_code = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);\n    }\n    return e_error;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -10,7 +10,8 @@\n     u4_start_code   = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);\n     while ( (u4_start_code == EXTENSION_START_CODE ||\n             u4_start_code == USER_DATA_START_CODE) &&\n-            (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error)\n+            (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error &&\n+            (ps_stream->u4_offset < ps_stream->u4_max_offset))\n     {\n         if(u4_start_code == USER_DATA_START_CODE)\n         {",
        "diff_line_info": {
            "deleted_lines": [
                "            (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error)"
            ],
            "added_lines": [
                "            (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error &&",
                "            (ps_stream->u4_offset < ps_stream->u4_max_offset))"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-0824",
        "func_name": "android/impeg2d_dec_pic_hdr",
        "description": "libmpeg2 in libstagefright in Android 6.x before 2016-03-01 allows attackers to obtain sensitive information, and consequently bypass an unspecified protection mechanism, via crafted Bitstream data, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 25765591.",
        "git_url": "https://android.googlesource.com/platform/external/libmpeg2/+/ffab15eb80630dc799eb410855c93525b75233c3",
        "commit_title": "Fixed bit stream access to make sure that it is not read beyond the allocated size.",
        "commit_text": " Bug: 25765591  ",
        "func_before": "IMPEG2D_ERROR_CODES_T impeg2d_dec_pic_hdr(dec_state_t *ps_dec)\n{\n    stream_t *ps_stream;\n    ps_stream = &ps_dec->s_bit_stream;\n\n    impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);\n    /* Flush temporal reference */\n    impeg2d_bit_stream_get(ps_stream,10);\n\n    /* Picture type */\n    ps_dec->e_pic_type = (e_pic_type_t)impeg2d_bit_stream_get(ps_stream,3);\n    if((ps_dec->e_pic_type < I_PIC) || (ps_dec->e_pic_type > D_PIC))\n    {\n        impeg2d_next_code(ps_dec, PICTURE_START_CODE);\n        return IMPEG2D_INVALID_PIC_TYPE;\n    }\n\n    /* Flush vbv_delay */\n    impeg2d_bit_stream_get(ps_stream,16);\n\n    if(ps_dec->e_pic_type == P_PIC || ps_dec->e_pic_type == B_PIC)\n    {\n        ps_dec->u2_full_pel_forw_vector = impeg2d_bit_stream_get_bit(ps_stream);\n        ps_dec->u2_forw_f_code          = impeg2d_bit_stream_get(ps_stream,3);\n    }\n    if(ps_dec->e_pic_type == B_PIC)\n    {\n        ps_dec->u2_full_pel_back_vector = impeg2d_bit_stream_get_bit(ps_stream);\n        ps_dec->u2_back_f_code          = impeg2d_bit_stream_get(ps_stream,3);\n    }\n\n    if(ps_dec->u2_is_mpeg2 == 0)\n    {\n        ps_dec->au2_f_code[0][0] = ps_dec->au2_f_code[0][1] = ps_dec->u2_forw_f_code;\n        ps_dec->au2_f_code[1][0] = ps_dec->au2_f_code[1][1] = ps_dec->u2_back_f_code;\n    }\n\n    /*-----------------------------------------------------------------------*/\n    /*  Flush the extra bit value                                            */\n    /*                                                                       */\n    /*  while(impeg2d_bit_stream_nxt() == '1')                                  */\n    /*  {                                                                    */\n    /*      extra_bit_picture         1                                      */\n    /*      extra_information_picture 8                                      */\n    /*  }                                                                    */\n    /*  extra_bit_picture             1                                      */\n    /*-----------------------------------------------------------------------*/\n    while (impeg2d_bit_stream_nxt(ps_stream,1) == 1)\n    {\n        impeg2d_bit_stream_get(ps_stream,9);\n    }\n    impeg2d_bit_stream_get_bit(ps_stream);\n    impeg2d_next_start_code(ps_dec);\n\n    return (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE;\n}",
        "func": "IMPEG2D_ERROR_CODES_T impeg2d_dec_pic_hdr(dec_state_t *ps_dec)\n{\n    stream_t *ps_stream;\n    ps_stream = &ps_dec->s_bit_stream;\n\n    impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);\n    /* Flush temporal reference */\n    impeg2d_bit_stream_get(ps_stream,10);\n\n    /* Picture type */\n    ps_dec->e_pic_type = (e_pic_type_t)impeg2d_bit_stream_get(ps_stream,3);\n    if((ps_dec->e_pic_type < I_PIC) || (ps_dec->e_pic_type > D_PIC))\n    {\n        impeg2d_next_code(ps_dec, PICTURE_START_CODE);\n        return IMPEG2D_INVALID_PIC_TYPE;\n    }\n\n    /* Flush vbv_delay */\n    impeg2d_bit_stream_get(ps_stream,16);\n\n    if(ps_dec->e_pic_type == P_PIC || ps_dec->e_pic_type == B_PIC)\n    {\n        ps_dec->u2_full_pel_forw_vector = impeg2d_bit_stream_get_bit(ps_stream);\n        ps_dec->u2_forw_f_code          = impeg2d_bit_stream_get(ps_stream,3);\n    }\n    if(ps_dec->e_pic_type == B_PIC)\n    {\n        ps_dec->u2_full_pel_back_vector = impeg2d_bit_stream_get_bit(ps_stream);\n        ps_dec->u2_back_f_code          = impeg2d_bit_stream_get(ps_stream,3);\n    }\n\n    if(ps_dec->u2_is_mpeg2 == 0)\n    {\n        ps_dec->au2_f_code[0][0] = ps_dec->au2_f_code[0][1] = ps_dec->u2_forw_f_code;\n        ps_dec->au2_f_code[1][0] = ps_dec->au2_f_code[1][1] = ps_dec->u2_back_f_code;\n    }\n\n    /*-----------------------------------------------------------------------*/\n    /*  Flush the extra bit value                                            */\n    /*                                                                       */\n    /*  while(impeg2d_bit_stream_nxt() == '1')                                  */\n    /*  {                                                                    */\n    /*      extra_bit_picture         1                                      */\n    /*      extra_information_picture 8                                      */\n    /*  }                                                                    */\n    /*  extra_bit_picture             1                                      */\n    /*-----------------------------------------------------------------------*/\n    while (impeg2d_bit_stream_nxt(ps_stream,1) == 1 &&\n           ps_stream->u4_offset < ps_stream->u4_max_offset)\n    {\n        impeg2d_bit_stream_get(ps_stream,9);\n    }\n    impeg2d_bit_stream_get_bit(ps_stream);\n    impeg2d_next_start_code(ps_dec);\n\n    return (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -45,7 +45,8 @@\n     /*  }                                                                    */\n     /*  extra_bit_picture             1                                      */\n     /*-----------------------------------------------------------------------*/\n-    while (impeg2d_bit_stream_nxt(ps_stream,1) == 1)\n+    while (impeg2d_bit_stream_nxt(ps_stream,1) == 1 &&\n+           ps_stream->u4_offset < ps_stream->u4_max_offset)\n     {\n         impeg2d_bit_stream_get(ps_stream,9);\n     }",
        "diff_line_info": {
            "deleted_lines": [
                "    while (impeg2d_bit_stream_nxt(ps_stream,1) == 1)"
            ],
            "added_lines": [
                "    while (impeg2d_bit_stream_nxt(ps_stream,1) == 1 &&",
                "           ps_stream->u4_offset < ps_stream->u4_max_offset)"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-0824",
        "func_name": "android/impeg2d_dec_slice",
        "description": "libmpeg2 in libstagefright in Android 6.x before 2016-03-01 allows attackers to obtain sensitive information, and consequently bypass an unspecified protection mechanism, via crafted Bitstream data, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 25765591.",
        "git_url": "https://android.googlesource.com/platform/external/libmpeg2/+/ffab15eb80630dc799eb410855c93525b75233c3",
        "commit_title": "Fixed bit stream access to make sure that it is not read beyond the allocated size.",
        "commit_text": " Bug: 25765591  ",
        "func_before": "IMPEG2D_ERROR_CODES_T impeg2d_dec_slice(dec_state_t *ps_dec)\n{\n    stream_t *ps_stream;\n    UWORD32 u4_slice_vertical_position;\n    UWORD32 u4_slice_vertical_position_extension;\n    IMPEG2D_ERROR_CODES_T e_error;\n\n    ps_stream = &ps_dec->s_bit_stream;\n\n    /*------------------------------------------------------------------------*/\n    /* All the profiles supported require restricted slice structure. Hence   */\n    /* there is no need to store slice_vertical_position. Note that max       */\n    /* height supported does not exceed 2800 and scalablity is not supported  */\n    /*------------------------------------------------------------------------*/\n\n    /* Remove the slice start code */\n    impeg2d_bit_stream_flush(ps_stream,START_CODE_PREFIX_LEN);\n    u4_slice_vertical_position = impeg2d_bit_stream_get(ps_stream, 8);\n    if(u4_slice_vertical_position > 2800)\n    {\n        u4_slice_vertical_position_extension = impeg2d_bit_stream_get(ps_stream, 3);\n        u4_slice_vertical_position += (u4_slice_vertical_position_extension << 7);\n    }\n\n    if((u4_slice_vertical_position > ps_dec->u2_num_vert_mb) ||\n       (u4_slice_vertical_position == 0))\n    {\n        return IMPEG2D_INVALID_VERT_SIZE;\n    }\n\n    // change the mb_y to point to slice_vertical_position\n    u4_slice_vertical_position--;\n    if (ps_dec->u2_mb_y != u4_slice_vertical_position)\n    {\n        ps_dec->u2_mb_y    = u4_slice_vertical_position;\n        ps_dec->u2_mb_x    = 0;\n    }\n    ps_dec->u2_first_mb = 1;\n\n    /*------------------------------------------------------------------------*/\n    /* Quant scale code decoding                                              */\n    /*------------------------------------------------------------------------*/\n    {\n        UWORD16 u2_quant_scale_code;\n        u2_quant_scale_code = impeg2d_bit_stream_get(ps_stream,5);\n        ps_dec->u1_quant_scale = (ps_dec->u2_q_scale_type) ?\n            gau1_impeg2_non_linear_quant_scale[u2_quant_scale_code] : (u2_quant_scale_code << 1);\n    }\n\n    if (impeg2d_bit_stream_nxt(ps_stream,1) == 1)\n    {\n        impeg2d_bit_stream_flush(ps_stream,9);\n        /* Flush extra bit information */\n        while (impeg2d_bit_stream_nxt(ps_stream,1) == 1)\n        {\n            impeg2d_bit_stream_flush(ps_stream,9);\n        }\n    }\n    impeg2d_bit_stream_get_bit(ps_stream);\n\n    /* Reset the DC predictors to reset values given in Table 7.2 at the start*/\n    /* of slice data */\n    ps_dec->u2_def_dc_pred[Y_LUMA]   = 128 << ps_dec->u2_intra_dc_precision;\n    ps_dec->u2_def_dc_pred[U_CHROMA]   = 128 << ps_dec->u2_intra_dc_precision;\n    ps_dec->u2_def_dc_pred[V_CHROMA]   = 128 << ps_dec->u2_intra_dc_precision;\n    /*------------------------------------------------------------------------*/\n    /* dec->DecMBsinSlice() implements the following psuedo code from standard*/\n    /* do                                                                     */\n    /* {                                                                      */\n    /*      macroblock()                                                      */\n    /* } while (impeg2d_bit_stream_nxt() != '000 0000 0000 0000 0000 0000')      */\n    /*------------------------------------------------------------------------*/\n\n    e_error = ps_dec->pf_decode_slice(ps_dec);\n    if ((IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE != e_error)\n    {\n        return e_error;\n    }\n\n    /* Check for the MBy index instead of number of MBs left, because the\n     * number of MBs left in case of multi-thread decode is the number of MBs\n     * in that row only\n     */\n    if(ps_dec->u2_mb_y < ps_dec->u2_num_vert_mb)\n        impeg2d_next_start_code(ps_dec);\n\n    return (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE;\n}",
        "func": "IMPEG2D_ERROR_CODES_T impeg2d_dec_slice(dec_state_t *ps_dec)\n{\n    stream_t *ps_stream;\n    UWORD32 u4_slice_vertical_position;\n    UWORD32 u4_slice_vertical_position_extension;\n    IMPEG2D_ERROR_CODES_T e_error;\n\n    ps_stream = &ps_dec->s_bit_stream;\n\n    /*------------------------------------------------------------------------*/\n    /* All the profiles supported require restricted slice structure. Hence   */\n    /* there is no need to store slice_vertical_position. Note that max       */\n    /* height supported does not exceed 2800 and scalablity is not supported  */\n    /*------------------------------------------------------------------------*/\n\n    /* Remove the slice start code */\n    impeg2d_bit_stream_flush(ps_stream,START_CODE_PREFIX_LEN);\n    u4_slice_vertical_position = impeg2d_bit_stream_get(ps_stream, 8);\n    if(u4_slice_vertical_position > 2800)\n    {\n        u4_slice_vertical_position_extension = impeg2d_bit_stream_get(ps_stream, 3);\n        u4_slice_vertical_position += (u4_slice_vertical_position_extension << 7);\n    }\n\n    if((u4_slice_vertical_position > ps_dec->u2_num_vert_mb) ||\n       (u4_slice_vertical_position == 0))\n    {\n        return IMPEG2D_INVALID_VERT_SIZE;\n    }\n\n    // change the mb_y to point to slice_vertical_position\n    u4_slice_vertical_position--;\n    if (ps_dec->u2_mb_y != u4_slice_vertical_position)\n    {\n        ps_dec->u2_mb_y    = u4_slice_vertical_position;\n        ps_dec->u2_mb_x    = 0;\n    }\n    ps_dec->u2_first_mb = 1;\n\n    /*------------------------------------------------------------------------*/\n    /* Quant scale code decoding                                              */\n    /*------------------------------------------------------------------------*/\n    {\n        UWORD16 u2_quant_scale_code;\n        u2_quant_scale_code = impeg2d_bit_stream_get(ps_stream,5);\n        ps_dec->u1_quant_scale = (ps_dec->u2_q_scale_type) ?\n            gau1_impeg2_non_linear_quant_scale[u2_quant_scale_code] : (u2_quant_scale_code << 1);\n    }\n\n    if (impeg2d_bit_stream_nxt(ps_stream,1) == 1)\n    {\n        impeg2d_bit_stream_flush(ps_stream,9);\n        /* Flush extra bit information */\n        while (impeg2d_bit_stream_nxt(ps_stream,1) == 1 &&\n               ps_stream->u4_offset < ps_stream->u4_max_offset)\n        {\n            impeg2d_bit_stream_flush(ps_stream,9);\n        }\n    }\n    impeg2d_bit_stream_get_bit(ps_stream);\n\n    /* Reset the DC predictors to reset values given in Table 7.2 at the start*/\n    /* of slice data */\n    ps_dec->u2_def_dc_pred[Y_LUMA]   = 128 << ps_dec->u2_intra_dc_precision;\n    ps_dec->u2_def_dc_pred[U_CHROMA]   = 128 << ps_dec->u2_intra_dc_precision;\n    ps_dec->u2_def_dc_pred[V_CHROMA]   = 128 << ps_dec->u2_intra_dc_precision;\n    /*------------------------------------------------------------------------*/\n    /* dec->DecMBsinSlice() implements the following psuedo code from standard*/\n    /* do                                                                     */\n    /* {                                                                      */\n    /*      macroblock()                                                      */\n    /* } while (impeg2d_bit_stream_nxt() != '000 0000 0000 0000 0000 0000')      */\n    /*------------------------------------------------------------------------*/\n\n    e_error = ps_dec->pf_decode_slice(ps_dec);\n    if ((IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE != e_error)\n    {\n        return e_error;\n    }\n\n    /* Check for the MBy index instead of number of MBs left, because the\n     * number of MBs left in case of multi-thread decode is the number of MBs\n     * in that row only\n     */\n    if(ps_dec->u2_mb_y < ps_dec->u2_num_vert_mb)\n        impeg2d_next_start_code(ps_dec);\n\n    return (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -51,7 +51,8 @@\n     {\n         impeg2d_bit_stream_flush(ps_stream,9);\n         /* Flush extra bit information */\n-        while (impeg2d_bit_stream_nxt(ps_stream,1) == 1)\n+        while (impeg2d_bit_stream_nxt(ps_stream,1) == 1 &&\n+               ps_stream->u4_offset < ps_stream->u4_max_offset)\n         {\n             impeg2d_bit_stream_flush(ps_stream,9);\n         }",
        "diff_line_info": {
            "deleted_lines": [
                "        while (impeg2d_bit_stream_nxt(ps_stream,1) == 1)"
            ],
            "added_lines": [
                "        while (impeg2d_bit_stream_nxt(ps_stream,1) == 1 &&",
                "               ps_stream->u4_offset < ps_stream->u4_max_offset)"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-0824",
        "func_name": "android/impeg2d_peek_next_start_code",
        "description": "libmpeg2 in libstagefright in Android 6.x before 2016-03-01 allows attackers to obtain sensitive information, and consequently bypass an unspecified protection mechanism, via crafted Bitstream data, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 25765591.",
        "git_url": "https://android.googlesource.com/platform/external/libmpeg2/+/ffab15eb80630dc799eb410855c93525b75233c3",
        "commit_title": "Fixed bit stream access to make sure that it is not read beyond the allocated size.",
        "commit_text": " Bug: 25765591  ",
        "func_before": "void impeg2d_peek_next_start_code(dec_state_t *ps_dec)\n{\n    stream_t *ps_stream;\n    ps_stream = &ps_dec->s_bit_stream;\n    impeg2d_bit_stream_flush_to_byte_boundary(ps_stream);\n\n    while ((impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX)\n        && (ps_dec->s_bit_stream.u4_offset <= ps_dec->s_bit_stream.u4_max_offset))\n    {\n        impeg2d_bit_stream_get(ps_stream,8);\n    }\n    return;\n}",
        "func": "void impeg2d_peek_next_start_code(dec_state_t *ps_dec)\n{\n    stream_t *ps_stream;\n    ps_stream = &ps_dec->s_bit_stream;\n    impeg2d_bit_stream_flush_to_byte_boundary(ps_stream);\n\n    while ((impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX)\n        && (ps_dec->s_bit_stream.u4_offset < ps_dec->s_bit_stream.u4_max_offset))\n    {\n        impeg2d_bit_stream_get(ps_stream,8);\n    }\n    return;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,7 +5,7 @@\n     impeg2d_bit_stream_flush_to_byte_boundary(ps_stream);\n \n     while ((impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX)\n-        && (ps_dec->s_bit_stream.u4_offset <= ps_dec->s_bit_stream.u4_max_offset))\n+        && (ps_dec->s_bit_stream.u4_offset < ps_dec->s_bit_stream.u4_max_offset))\n     {\n         impeg2d_bit_stream_get(ps_stream,8);\n     }",
        "diff_line_info": {
            "deleted_lines": [
                "        && (ps_dec->s_bit_stream.u4_offset <= ps_dec->s_bit_stream.u4_max_offset))"
            ],
            "added_lines": [
                "        && (ps_dec->s_bit_stream.u4_offset < ps_dec->s_bit_stream.u4_max_offset))"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-0824",
        "func_name": "android/impeg2d_dec_user_data",
        "description": "libmpeg2 in libstagefright in Android 6.x before 2016-03-01 allows attackers to obtain sensitive information, and consequently bypass an unspecified protection mechanism, via crafted Bitstream data, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 25765591.",
        "git_url": "https://android.googlesource.com/platform/external/libmpeg2/+/ffab15eb80630dc799eb410855c93525b75233c3",
        "commit_title": "Fixed bit stream access to make sure that it is not read beyond the allocated size.",
        "commit_text": " Bug: 25765591  ",
        "func_before": "void impeg2d_dec_user_data(dec_state_t *ps_dec)\n{\n    UWORD32 u4_start_code;\n    stream_t *ps_stream;\n\n    ps_stream    = &ps_dec->s_bit_stream;\n    u4_start_code = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);\n\n    while(u4_start_code == USER_DATA_START_CODE)\n    {\n        impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);\n        while(impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX)\n        {\n            impeg2d_bit_stream_flush(ps_stream,8);\n        }\n        u4_start_code = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);\n    }\n}",
        "func": "void impeg2d_dec_user_data(dec_state_t *ps_dec)\n{\n    UWORD32 u4_start_code;\n    stream_t *ps_stream;\n\n    ps_stream    = &ps_dec->s_bit_stream;\n    u4_start_code = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);\n\n    while(u4_start_code == USER_DATA_START_CODE)\n    {\n        impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);\n        while((impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX) &&\n                (ps_stream->u4_offset < ps_stream->u4_max_offset))\n        {\n            impeg2d_bit_stream_flush(ps_stream,8);\n        }\n        u4_start_code = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -9,7 +9,8 @@\n     while(u4_start_code == USER_DATA_START_CODE)\n     {\n         impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);\n-        while(impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX)\n+        while((impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX) &&\n+                (ps_stream->u4_offset < ps_stream->u4_max_offset))\n         {\n             impeg2d_bit_stream_flush(ps_stream,8);\n         }",
        "diff_line_info": {
            "deleted_lines": [
                "        while(impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX)"
            ],
            "added_lines": [
                "        while((impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX) &&",
                "                (ps_stream->u4_offset < ps_stream->u4_max_offset))"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-0824",
        "func_name": "android/impeg2d_next_code",
        "description": "libmpeg2 in libstagefright in Android 6.x before 2016-03-01 allows attackers to obtain sensitive information, and consequently bypass an unspecified protection mechanism, via crafted Bitstream data, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 25765591.",
        "git_url": "https://android.googlesource.com/platform/external/libmpeg2/+/ffab15eb80630dc799eb410855c93525b75233c3",
        "commit_title": "Fixed bit stream access to make sure that it is not read beyond the allocated size.",
        "commit_text": " Bug: 25765591  ",
        "func_before": "void impeg2d_next_code(dec_state_t *ps_dec, UWORD32 u4_start_code_val)\n{\n    stream_t *ps_stream;\n    ps_stream = &ps_dec->s_bit_stream;\n    impeg2d_bit_stream_flush_to_byte_boundary(ps_stream);\n\n    while ((impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN) != u4_start_code_val)\n        && (ps_dec->s_bit_stream.u4_offset <= ps_dec->s_bit_stream.u4_max_offset))\n    {\n\n        if (impeg2d_bit_stream_get(ps_stream,8) != 0)\n        {\n            /* Ignore stuffing bit errors. */\n        }\n\n    }\n    return;\n}",
        "func": "void impeg2d_next_code(dec_state_t *ps_dec, UWORD32 u4_start_code_val)\n{\n    stream_t *ps_stream;\n    ps_stream = &ps_dec->s_bit_stream;\n    impeg2d_bit_stream_flush_to_byte_boundary(ps_stream);\n\n    while ((impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN) != u4_start_code_val) &&\n            (ps_dec->s_bit_stream.u4_offset < ps_dec->s_bit_stream.u4_max_offset))\n    {\n\n        if (impeg2d_bit_stream_get(ps_stream,8) != 0)\n        {\n            /* Ignore stuffing bit errors. */\n        }\n\n    }\n    return;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,8 +4,8 @@\n     ps_stream = &ps_dec->s_bit_stream;\n     impeg2d_bit_stream_flush_to_byte_boundary(ps_stream);\n \n-    while ((impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN) != u4_start_code_val)\n-        && (ps_dec->s_bit_stream.u4_offset <= ps_dec->s_bit_stream.u4_max_offset))\n+    while ((impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN) != u4_start_code_val) &&\n+            (ps_dec->s_bit_stream.u4_offset < ps_dec->s_bit_stream.u4_max_offset))\n     {\n \n         if (impeg2d_bit_stream_get(ps_stream,8) != 0)",
        "diff_line_info": {
            "deleted_lines": [
                "    while ((impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN) != u4_start_code_val)",
                "        && (ps_dec->s_bit_stream.u4_offset <= ps_dec->s_bit_stream.u4_max_offset))"
            ],
            "added_lines": [
                "    while ((impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN) != u4_start_code_val) &&",
                "            (ps_dec->s_bit_stream.u4_offset < ps_dec->s_bit_stream.u4_max_offset))"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-0824",
        "func_name": "android/impeg2d_flush_ext_and_user_data",
        "description": "libmpeg2 in libstagefright in Android 6.x before 2016-03-01 allows attackers to obtain sensitive information, and consequently bypass an unspecified protection mechanism, via crafted Bitstream data, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 25765591.",
        "git_url": "https://android.googlesource.com/platform/external/libmpeg2/+/ffab15eb80630dc799eb410855c93525b75233c3",
        "commit_title": "Fixed bit stream access to make sure that it is not read beyond the allocated size.",
        "commit_text": " Bug: 25765591  ",
        "func_before": "void impeg2d_flush_ext_and_user_data(dec_state_t *ps_dec)\n{\n    UWORD32 u4_start_code;\n    stream_t *ps_stream;\n\n    ps_stream    = &ps_dec->s_bit_stream;\n    u4_start_code = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);\n\n    while(u4_start_code == EXTENSION_START_CODE || u4_start_code == USER_DATA_START_CODE)\n    {\n        impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);\n        while(impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX)\n        {\n            impeg2d_bit_stream_flush(ps_stream,8);\n        }\n        u4_start_code = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);\n    }\n}",
        "func": "void impeg2d_flush_ext_and_user_data(dec_state_t *ps_dec)\n{\n    UWORD32 u4_start_code;\n    stream_t *ps_stream;\n\n    ps_stream    = &ps_dec->s_bit_stream;\n    u4_start_code = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);\n\n    while((u4_start_code == EXTENSION_START_CODE || u4_start_code == USER_DATA_START_CODE) &&\n            (ps_stream->u4_offset < ps_stream->u4_max_offset))\n    {\n        impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);\n        while(impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX &&\n                (ps_stream->u4_offset < ps_stream->u4_max_offset))\n        {\n            impeg2d_bit_stream_flush(ps_stream,8);\n        }\n        u4_start_code = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,10 +6,12 @@\n     ps_stream    = &ps_dec->s_bit_stream;\n     u4_start_code = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);\n \n-    while(u4_start_code == EXTENSION_START_CODE || u4_start_code == USER_DATA_START_CODE)\n+    while((u4_start_code == EXTENSION_START_CODE || u4_start_code == USER_DATA_START_CODE) &&\n+            (ps_stream->u4_offset < ps_stream->u4_max_offset))\n     {\n         impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);\n-        while(impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX)\n+        while(impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX &&\n+                (ps_stream->u4_offset < ps_stream->u4_max_offset))\n         {\n             impeg2d_bit_stream_flush(ps_stream,8);\n         }",
        "diff_line_info": {
            "deleted_lines": [
                "    while(u4_start_code == EXTENSION_START_CODE || u4_start_code == USER_DATA_START_CODE)",
                "        while(impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX)"
            ],
            "added_lines": [
                "    while((u4_start_code == EXTENSION_START_CODE || u4_start_code == USER_DATA_START_CODE) &&",
                "            (ps_stream->u4_offset < ps_stream->u4_max_offset))",
                "        while(impeg2d_bit_stream_nxt(ps_stream,START_CODE_PREFIX_LEN) != START_CODE_PREFIX &&",
                "                (ps_stream->u4_offset < ps_stream->u4_max_offset))"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-0824",
        "func_name": "android/impeg2d_dec_seq_ext_data",
        "description": "libmpeg2 in libstagefright in Android 6.x before 2016-03-01 allows attackers to obtain sensitive information, and consequently bypass an unspecified protection mechanism, via crafted Bitstream data, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 25765591.",
        "git_url": "https://android.googlesource.com/platform/external/libmpeg2/+/ffab15eb80630dc799eb410855c93525b75233c3",
        "commit_title": "Fixed bit stream access to make sure that it is not read beyond the allocated size.",
        "commit_text": " Bug: 25765591  ",
        "func_before": "IMPEG2D_ERROR_CODES_T impeg2d_dec_seq_ext_data(dec_state_t *ps_dec)\n{\n    stream_t   *ps_stream;\n    UWORD32     u4_start_code;\n    IMPEG2D_ERROR_CODES_T e_error;\n\n    e_error = (IMPEG2D_ERROR_CODES_T) IVD_ERROR_NONE;\n\n    ps_stream      = &ps_dec->s_bit_stream;\n    u4_start_code = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);\n    while( (u4_start_code == EXTENSION_START_CODE ||\n            u4_start_code == USER_DATA_START_CODE) &&\n            (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error)\n    {\n        if(u4_start_code == USER_DATA_START_CODE)\n        {\n            impeg2d_dec_user_data(ps_dec);\n        }\n        else\n        {\n            impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);\n            u4_start_code   = impeg2d_bit_stream_nxt(ps_stream,EXT_ID_LEN);\n            switch(u4_start_code)\n            {\n            case SEQ_DISPLAY_EXT_ID:\n                impeg2d_dec_seq_disp_ext(ps_dec);\n                break;\n            case SEQ_SCALABLE_EXT_ID:\n                e_error = IMPEG2D_SCALABILITIY_NOT_SUPPORTED;\n                break;\n            default:\n                /* In case its a reserved extension code */\n                impeg2d_bit_stream_flush(ps_stream,EXT_ID_LEN);\n                impeg2d_peek_next_start_code(ps_dec);\n                break;\n            }\n        }\n        u4_start_code = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);\n    }\n    return e_error;\n}",
        "func": "IMPEG2D_ERROR_CODES_T impeg2d_dec_seq_ext_data(dec_state_t *ps_dec)\n{\n    stream_t   *ps_stream;\n    UWORD32     u4_start_code;\n    IMPEG2D_ERROR_CODES_T e_error;\n\n    e_error = (IMPEG2D_ERROR_CODES_T) IVD_ERROR_NONE;\n\n    ps_stream      = &ps_dec->s_bit_stream;\n    u4_start_code = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);\n    while( (u4_start_code == EXTENSION_START_CODE ||\n            u4_start_code == USER_DATA_START_CODE) &&\n            (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error &&\n            (ps_stream->u4_offset < ps_stream->u4_max_offset))\n    {\n        if(u4_start_code == USER_DATA_START_CODE)\n        {\n            impeg2d_dec_user_data(ps_dec);\n        }\n        else\n        {\n            impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);\n            u4_start_code   = impeg2d_bit_stream_nxt(ps_stream,EXT_ID_LEN);\n            switch(u4_start_code)\n            {\n            case SEQ_DISPLAY_EXT_ID:\n                impeg2d_dec_seq_disp_ext(ps_dec);\n                break;\n            case SEQ_SCALABLE_EXT_ID:\n                e_error = IMPEG2D_SCALABILITIY_NOT_SUPPORTED;\n                break;\n            default:\n                /* In case its a reserved extension code */\n                impeg2d_bit_stream_flush(ps_stream,EXT_ID_LEN);\n                impeg2d_peek_next_start_code(ps_dec);\n                break;\n            }\n        }\n        u4_start_code = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);\n    }\n    return e_error;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -10,7 +10,8 @@\n     u4_start_code = impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN);\n     while( (u4_start_code == EXTENSION_START_CODE ||\n             u4_start_code == USER_DATA_START_CODE) &&\n-            (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error)\n+            (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error &&\n+            (ps_stream->u4_offset < ps_stream->u4_max_offset))\n     {\n         if(u4_start_code == USER_DATA_START_CODE)\n         {",
        "diff_line_info": {
            "deleted_lines": [
                "            (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error)"
            ],
            "added_lines": [
                "            (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE == e_error &&",
                "            (ps_stream->u4_offset < ps_stream->u4_max_offset))"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-0824",
        "func_name": "android/impeg2d_bit_stream_get_bit",
        "description": "libmpeg2 in libstagefright in Android 6.x before 2016-03-01 allows attackers to obtain sensitive information, and consequently bypass an unspecified protection mechanism, via crafted Bitstream data, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 25765591.",
        "git_url": "https://android.googlesource.com/platform/external/libmpeg2/+/ffab15eb80630dc799eb410855c93525b75233c3",
        "commit_title": "Fixed bit stream access to make sure that it is not read beyond the allocated size.",
        "commit_text": " Bug: 25765591  ",
        "func_before": "INLINE UWORD8 impeg2d_bit_stream_get_bit(stream_t *ps_stream)\n{\n    UWORD32     u4_bit,u4_offset,u4_temp;\n    UWORD32     u4_curr_bit;\n\n    u4_offset               = ps_stream->u4_offset;\n    u4_curr_bit             = u4_offset & 0x1F;\n    u4_bit                  = ps_stream->u4_buf;\n\n    /* Move the current bit read from the current word to the\n       least significant bit positions of 'c'.*/\n    u4_bit                  >>= BITS_IN_INT - u4_curr_bit - 1;\n\n    u4_offset++;\n\n    /* If the last bit of the last word of the buffer has been read update\n       the currrent buf with next, and read next buf from bit stream buffer */\n    if (u4_curr_bit == 31)\n    {\n        ps_stream->u4_buf      = ps_stream->u4_buf_nxt;\n        u4_temp             = *(ps_stream->pu4_buf_aligned)++;\n\n        CONV_LE_TO_BE(ps_stream->u4_buf_nxt,u4_temp)\n    }\n    ps_stream->u4_offset          = u4_offset;\n\n    return (u4_bit & 0x1);\n}",
        "func": "INLINE UWORD8 impeg2d_bit_stream_get_bit(stream_t *ps_stream)\n{\n    UWORD32     u4_bit,u4_offset,u4_temp;\n    UWORD32     u4_curr_bit;\n\n    u4_offset               = ps_stream->u4_offset;\n    u4_curr_bit             = u4_offset & 0x1F;\n    u4_bit                  = ps_stream->u4_buf;\n\n    /* Move the current bit read from the current word to the\n       least significant bit positions of 'c'.*/\n    u4_bit                  >>= BITS_IN_INT - u4_curr_bit - 1;\n\n    u4_offset++;\n\n    /* If the last bit of the last word of the buffer has been read update\n       the currrent buf with next, and read next buf from bit stream buffer */\n    if (u4_curr_bit == 31)\n    {\n        ps_stream->u4_buf      = ps_stream->u4_buf_nxt;\n\n        if (ps_stream->u4_offset < ps_stream->u4_max_offset)\n        {\n            u4_temp             = *(ps_stream->pu4_buf_aligned)++;\n            CONV_LE_TO_BE(ps_stream->u4_buf_nxt,u4_temp)\n        }\n    }\n    ps_stream->u4_offset          = u4_offset;\n\n    return (u4_bit & 0x1);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -18,9 +18,12 @@\n     if (u4_curr_bit == 31)\n     {\n         ps_stream->u4_buf      = ps_stream->u4_buf_nxt;\n-        u4_temp             = *(ps_stream->pu4_buf_aligned)++;\n \n-        CONV_LE_TO_BE(ps_stream->u4_buf_nxt,u4_temp)\n+        if (ps_stream->u4_offset < ps_stream->u4_max_offset)\n+        {\n+            u4_temp             = *(ps_stream->pu4_buf_aligned)++;\n+            CONV_LE_TO_BE(ps_stream->u4_buf_nxt,u4_temp)\n+        }\n     }\n     ps_stream->u4_offset          = u4_offset;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "        u4_temp             = *(ps_stream->pu4_buf_aligned)++;",
                "        CONV_LE_TO_BE(ps_stream->u4_buf_nxt,u4_temp)"
            ],
            "added_lines": [
                "        if (ps_stream->u4_offset < ps_stream->u4_max_offset)",
                "        {",
                "            u4_temp             = *(ps_stream->pu4_buf_aligned)++;",
                "            CONV_LE_TO_BE(ps_stream->u4_buf_nxt,u4_temp)",
                "        }"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-0824",
        "func_name": "android/impeg2d_bit_stream_flush",
        "description": "libmpeg2 in libstagefright in Android 6.x before 2016-03-01 allows attackers to obtain sensitive information, and consequently bypass an unspecified protection mechanism, via crafted Bitstream data, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 25765591.",
        "git_url": "https://android.googlesource.com/platform/external/libmpeg2/+/ffab15eb80630dc799eb410855c93525b75233c3",
        "commit_title": "Fixed bit stream access to make sure that it is not read beyond the allocated size.",
        "commit_text": " Bug: 25765591  ",
        "func_before": "INLINE void impeg2d_bit_stream_flush(void* pv_ctxt, UWORD32 u4_no_of_bits)\n{\n    stream_t *ps_stream = (stream_t *)pv_ctxt;\n\n    FLUSH_BITS(ps_stream->u4_offset,ps_stream->u4_buf,ps_stream->u4_buf_nxt,u4_no_of_bits,ps_stream->pu4_buf_aligned)\n    return;\n}",
        "func": "INLINE void impeg2d_bit_stream_flush(void* pv_ctxt, UWORD32 u4_no_of_bits)\n{\n    stream_t *ps_stream = (stream_t *)pv_ctxt;\n\n\n    if (ps_stream->u4_offset < ps_stream->u4_max_offset)\n    {\n        FLUSH_BITS(ps_stream->u4_offset,ps_stream->u4_buf,ps_stream->u4_buf_nxt,u4_no_of_bits,ps_stream->pu4_buf_aligned)\n    }\n    return;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,6 +2,10 @@\n {\n     stream_t *ps_stream = (stream_t *)pv_ctxt;\n \n-    FLUSH_BITS(ps_stream->u4_offset,ps_stream->u4_buf,ps_stream->u4_buf_nxt,u4_no_of_bits,ps_stream->pu4_buf_aligned)\n+\n+    if (ps_stream->u4_offset < ps_stream->u4_max_offset)\n+    {\n+        FLUSH_BITS(ps_stream->u4_offset,ps_stream->u4_buf,ps_stream->u4_buf_nxt,u4_no_of_bits,ps_stream->pu4_buf_aligned)\n+    }\n     return;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    FLUSH_BITS(ps_stream->u4_offset,ps_stream->u4_buf,ps_stream->u4_buf_nxt,u4_no_of_bits,ps_stream->pu4_buf_aligned)"
            ],
            "added_lines": [
                "",
                "    if (ps_stream->u4_offset < ps_stream->u4_max_offset)",
                "    {",
                "        FLUSH_BITS(ps_stream->u4_offset,ps_stream->u4_buf,ps_stream->u4_buf_nxt,u4_no_of_bits,ps_stream->pu4_buf_aligned)",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-0824",
        "func_name": "android/impeg2d_get_mb_addr_incr",
        "description": "libmpeg2 in libstagefright in Android 6.x before 2016-03-01 allows attackers to obtain sensitive information, and consequently bypass an unspecified protection mechanism, via crafted Bitstream data, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 25765591.",
        "git_url": "https://android.googlesource.com/platform/external/libmpeg2/+/ffab15eb80630dc799eb410855c93525b75233c3",
        "commit_title": "Fixed bit stream access to make sure that it is not read beyond the allocated size.",
        "commit_text": " Bug: 25765591  ",
        "func_before": "UWORD16 impeg2d_get_mb_addr_incr(stream_t *ps_stream)\n{\n    UWORD16 u2_mb_addr_incr = 0;\n    while (impeg2d_bit_stream_nxt(ps_stream,MB_ESCAPE_CODE_LEN) == MB_ESCAPE_CODE)\n    {\n        impeg2d_bit_stream_flush(ps_stream,MB_ESCAPE_CODE_LEN);\n        u2_mb_addr_incr += 33;\n    }\n    u2_mb_addr_incr += impeg2d_dec_vld_symbol(ps_stream,gai2_impeg2d_mb_addr_incr,MB_ADDR_INCR_LEN) +\n        MB_ADDR_INCR_OFFSET;\n    return(u2_mb_addr_incr);\n}",
        "func": "UWORD16 impeg2d_get_mb_addr_incr(stream_t *ps_stream)\n{\n    UWORD16 u2_mb_addr_incr = 0;\n    while (impeg2d_bit_stream_nxt(ps_stream,MB_ESCAPE_CODE_LEN) == MB_ESCAPE_CODE &&\n            ps_stream->u4_offset < ps_stream->u4_max_offset)\n    {\n        impeg2d_bit_stream_flush(ps_stream,MB_ESCAPE_CODE_LEN);\n        u2_mb_addr_incr += 33;\n    }\n    u2_mb_addr_incr += impeg2d_dec_vld_symbol(ps_stream,gai2_impeg2d_mb_addr_incr,MB_ADDR_INCR_LEN) +\n        MB_ADDR_INCR_OFFSET;\n    return(u2_mb_addr_incr);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,7 +1,8 @@\n UWORD16 impeg2d_get_mb_addr_incr(stream_t *ps_stream)\n {\n     UWORD16 u2_mb_addr_incr = 0;\n-    while (impeg2d_bit_stream_nxt(ps_stream,MB_ESCAPE_CODE_LEN) == MB_ESCAPE_CODE)\n+    while (impeg2d_bit_stream_nxt(ps_stream,MB_ESCAPE_CODE_LEN) == MB_ESCAPE_CODE &&\n+            ps_stream->u4_offset < ps_stream->u4_max_offset)\n     {\n         impeg2d_bit_stream_flush(ps_stream,MB_ESCAPE_CODE_LEN);\n         u2_mb_addr_incr += 33;",
        "diff_line_info": {
            "deleted_lines": [
                "    while (impeg2d_bit_stream_nxt(ps_stream,MB_ESCAPE_CODE_LEN) == MB_ESCAPE_CODE)"
            ],
            "added_lines": [
                "    while (impeg2d_bit_stream_nxt(ps_stream,MB_ESCAPE_CODE_LEN) == MB_ESCAPE_CODE &&",
                "            ps_stream->u4_offset < ps_stream->u4_max_offset)"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-0828",
        "func_name": "android/BnGraphicBufferConsumer::onTransact",
        "description": "The BnGraphicBufferConsumer::onTransact function in libs/gui/IGraphicBufferConsumer.cpp in mediaserver in Android 5.x before 5.1.1 LMY49H and 6.x before 2016-03-01 does not initialize a certain slot variable, which allows attackers to obtain sensitive information, and consequently bypass an unspecified protection mechanism, by triggering an ATTACH_BUFFER action, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 26338113.",
        "git_url": "https://android.googlesource.com/platform/frameworks/native/+/dded8fdbb700d6cc498debc69a780915bc34d755",
        "commit_title": "IGraphicBufferConsumer: fix ATTACH_BUFFER info leak",
        "commit_text": " Bug: 26338113 ",
        "func_before": "status_t BnGraphicBufferConsumer::onTransact(\n        uint32_t code, const Parcel& data, Parcel* reply, uint32_t flags)\n{\n    switch(code) {\n        case ACQUIRE_BUFFER: {\n            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);\n            BufferItem item;\n            int64_t presentWhen = data.readInt64();\n            status_t result = acquireBuffer(&item, presentWhen);\n            status_t err = reply->write(item);\n            if (err) return err;\n            reply->writeInt32(result);\n            return NO_ERROR;\n        } break;\n        case DETACH_BUFFER: {\n            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);\n            int slot = data.readInt32();\n            int result = detachBuffer(slot);\n            reply->writeInt32(result);\n            return NO_ERROR;\n        } break;\n        case ATTACH_BUFFER: {\n            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);\n            sp<GraphicBuffer> buffer = new GraphicBuffer();\n            data.read(*buffer.get());\n            int slot;\n            int result = attachBuffer(&slot, buffer);\n            reply->writeInt32(slot);\n            reply->writeInt32(result);\n            return NO_ERROR;\n        } break;\n        case RELEASE_BUFFER: {\n            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);\n            int buf = data.readInt32();\n            uint64_t frameNumber = data.readInt64();\n            sp<Fence> releaseFence = new Fence();\n            status_t err = data.read(*releaseFence);\n            if (err) return err;\n            status_t result = releaseBuffer(buf, frameNumber,\n                    EGL_NO_DISPLAY, EGL_NO_SYNC_KHR, releaseFence);\n            reply->writeInt32(result);\n            return NO_ERROR;\n        } break;\n        case CONSUMER_CONNECT: {\n            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);\n            sp<IConsumerListener> consumer = IConsumerListener::asInterface( data.readStrongBinder() );\n            bool controlledByApp = data.readInt32();\n            status_t result = consumerConnect(consumer, controlledByApp);\n            reply->writeInt32(result);\n            return NO_ERROR;\n        } break;\n        case CONSUMER_DISCONNECT: {\n            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);\n            status_t result = consumerDisconnect();\n            reply->writeInt32(result);\n            return NO_ERROR;\n        } break;\n        case GET_RELEASED_BUFFERS: {\n            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);\n            uint64_t slotMask;\n            status_t result = getReleasedBuffers(&slotMask);\n            reply->writeInt64(slotMask);\n            reply->writeInt32(result);\n            return NO_ERROR;\n        } break;\n        case SET_DEFAULT_BUFFER_SIZE: {\n            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);\n            uint32_t w = data.readInt32();\n            uint32_t h = data.readInt32();\n            status_t result = setDefaultBufferSize(w, h);\n            reply->writeInt32(result);\n            return NO_ERROR;\n        } break;\n        case SET_DEFAULT_MAX_BUFFER_COUNT: {\n            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);\n            uint32_t bufferCount = data.readInt32();\n            status_t result = setDefaultMaxBufferCount(bufferCount);\n            reply->writeInt32(result);\n            return NO_ERROR;\n        } break;\n        case DISABLE_ASYNC_BUFFER: {\n            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);\n            status_t result = disableAsyncBuffer();\n            reply->writeInt32(result);\n            return NO_ERROR;\n        } break;\n        case SET_MAX_ACQUIRED_BUFFER_COUNT: {\n            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);\n            uint32_t maxAcquiredBuffers = data.readInt32();\n            status_t result = setMaxAcquiredBufferCount(maxAcquiredBuffers);\n            reply->writeInt32(result);\n            return NO_ERROR;\n        } break;\n        case SET_CONSUMER_NAME: {\n            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);\n            setConsumerName( data.readString8() );\n            return NO_ERROR;\n        } break;\n        case SET_DEFAULT_BUFFER_FORMAT: {\n            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);\n            uint32_t defaultFormat = data.readInt32();\n            status_t result = setDefaultBufferFormat(defaultFormat);\n            reply->writeInt32(result);\n            return NO_ERROR;\n        } break;\n        case SET_CONSUMER_USAGE_BITS: {\n            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);\n            uint32_t usage = data.readInt32();\n            status_t result = setConsumerUsageBits(usage);\n            reply->writeInt32(result);\n            return NO_ERROR;\n        } break;\n        case SET_TRANSFORM_HINT: {\n            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);\n            uint32_t hint = data.readInt32();\n            status_t result = setTransformHint(hint);\n            reply->writeInt32(result);\n            return NO_ERROR;\n        } break;\n        case DUMP: {\n            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);\n            String8 result = data.readString8();\n            String8 prefix = data.readString8();\n            static_cast<IGraphicBufferConsumer*>(this)->dump(result, prefix);\n            reply->writeString8(result);\n            return NO_ERROR;\n        }\n    }\n    return BBinder::onTransact(code, data, reply, flags);\n}",
        "func": "status_t BnGraphicBufferConsumer::onTransact(\n        uint32_t code, const Parcel& data, Parcel* reply, uint32_t flags)\n{\n    switch(code) {\n        case ACQUIRE_BUFFER: {\n            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);\n            BufferItem item;\n            int64_t presentWhen = data.readInt64();\n            status_t result = acquireBuffer(&item, presentWhen);\n            status_t err = reply->write(item);\n            if (err) return err;\n            reply->writeInt32(result);\n            return NO_ERROR;\n        } break;\n        case DETACH_BUFFER: {\n            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);\n            int slot = data.readInt32();\n            int result = detachBuffer(slot);\n            reply->writeInt32(result);\n            return NO_ERROR;\n        } break;\n        case ATTACH_BUFFER: {\n            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);\n            sp<GraphicBuffer> buffer = new GraphicBuffer();\n            data.read(*buffer.get());\n            int slot = -1;\n            int result = attachBuffer(&slot, buffer);\n            reply->writeInt32(slot);\n            reply->writeInt32(result);\n            return NO_ERROR;\n        } break;\n        case RELEASE_BUFFER: {\n            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);\n            int buf = data.readInt32();\n            uint64_t frameNumber = data.readInt64();\n            sp<Fence> releaseFence = new Fence();\n            status_t err = data.read(*releaseFence);\n            if (err) return err;\n            status_t result = releaseBuffer(buf, frameNumber,\n                    EGL_NO_DISPLAY, EGL_NO_SYNC_KHR, releaseFence);\n            reply->writeInt32(result);\n            return NO_ERROR;\n        } break;\n        case CONSUMER_CONNECT: {\n            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);\n            sp<IConsumerListener> consumer = IConsumerListener::asInterface( data.readStrongBinder() );\n            bool controlledByApp = data.readInt32();\n            status_t result = consumerConnect(consumer, controlledByApp);\n            reply->writeInt32(result);\n            return NO_ERROR;\n        } break;\n        case CONSUMER_DISCONNECT: {\n            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);\n            status_t result = consumerDisconnect();\n            reply->writeInt32(result);\n            return NO_ERROR;\n        } break;\n        case GET_RELEASED_BUFFERS: {\n            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);\n            uint64_t slotMask;\n            status_t result = getReleasedBuffers(&slotMask);\n            reply->writeInt64(slotMask);\n            reply->writeInt32(result);\n            return NO_ERROR;\n        } break;\n        case SET_DEFAULT_BUFFER_SIZE: {\n            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);\n            uint32_t w = data.readInt32();\n            uint32_t h = data.readInt32();\n            status_t result = setDefaultBufferSize(w, h);\n            reply->writeInt32(result);\n            return NO_ERROR;\n        } break;\n        case SET_DEFAULT_MAX_BUFFER_COUNT: {\n            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);\n            uint32_t bufferCount = data.readInt32();\n            status_t result = setDefaultMaxBufferCount(bufferCount);\n            reply->writeInt32(result);\n            return NO_ERROR;\n        } break;\n        case DISABLE_ASYNC_BUFFER: {\n            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);\n            status_t result = disableAsyncBuffer();\n            reply->writeInt32(result);\n            return NO_ERROR;\n        } break;\n        case SET_MAX_ACQUIRED_BUFFER_COUNT: {\n            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);\n            uint32_t maxAcquiredBuffers = data.readInt32();\n            status_t result = setMaxAcquiredBufferCount(maxAcquiredBuffers);\n            reply->writeInt32(result);\n            return NO_ERROR;\n        } break;\n        case SET_CONSUMER_NAME: {\n            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);\n            setConsumerName( data.readString8() );\n            return NO_ERROR;\n        } break;\n        case SET_DEFAULT_BUFFER_FORMAT: {\n            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);\n            uint32_t defaultFormat = data.readInt32();\n            status_t result = setDefaultBufferFormat(defaultFormat);\n            reply->writeInt32(result);\n            return NO_ERROR;\n        } break;\n        case SET_CONSUMER_USAGE_BITS: {\n            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);\n            uint32_t usage = data.readInt32();\n            status_t result = setConsumerUsageBits(usage);\n            reply->writeInt32(result);\n            return NO_ERROR;\n        } break;\n        case SET_TRANSFORM_HINT: {\n            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);\n            uint32_t hint = data.readInt32();\n            status_t result = setTransformHint(hint);\n            reply->writeInt32(result);\n            return NO_ERROR;\n        } break;\n        case DUMP: {\n            CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);\n            String8 result = data.readString8();\n            String8 prefix = data.readString8();\n            static_cast<IGraphicBufferConsumer*>(this)->dump(result, prefix);\n            reply->writeString8(result);\n            return NO_ERROR;\n        }\n    }\n    return BBinder::onTransact(code, data, reply, flags);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -23,7 +23,7 @@\n             CHECK_INTERFACE(IGraphicBufferConsumer, data, reply);\n             sp<GraphicBuffer> buffer = new GraphicBuffer();\n             data.read(*buffer.get());\n-            int slot;\n+            int slot = -1;\n             int result = attachBuffer(&slot, buffer);\n             reply->writeInt32(slot);\n             reply->writeInt32(result);",
        "diff_line_info": {
            "deleted_lines": [
                "            int slot;"
            ],
            "added_lines": [
                "            int slot = -1;"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-0829",
        "func_name": "android/BnGraphicBufferProducer::onTransact",
        "description": "The BnGraphicBufferProducer::onTransact function in libs/gui/IGraphicBufferConsumer.cpp in mediaserver in Android 4.x before 4.4.4, 5.x before 5.1.1 LMY49H, and 6.x before 2016-03-01 does not initialize a certain output data structure, which allows attackers to obtain sensitive information, and consequently bypass an unspecified protection mechanism, by triggering a QUEUE_BUFFER action, as demonstrated by obtaining Signature or SignatureOrSystem access, aka internal bug 26338109.",
        "git_url": "https://android.googlesource.com/platform/frameworks/native/+/d06421fd37fbb7fd07002e6738fac3a223cb1a62",
        "commit_title": "IGraphicBufferProducer: fix QUEUE_BUFFER info leak",
        "commit_text": " Bug: 26338109 ",
        "func_before": "status_t BnGraphicBufferProducer::onTransact(\n    uint32_t code, const Parcel& data, Parcel* reply, uint32_t flags)\n{\n    switch(code) {\n        case REQUEST_BUFFER: {\n            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);\n            int bufferIdx   = data.readInt32();\n            sp<GraphicBuffer> buffer;\n            int result = requestBuffer(bufferIdx, &buffer);\n            reply->writeInt32(buffer != 0);\n            if (buffer != 0) {\n                reply->write(*buffer);\n            }\n            reply->writeInt32(result);\n            return NO_ERROR;\n        } break;\n        case SET_BUFFER_COUNT: {\n            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);\n            int bufferCount = data.readInt32();\n            int result = setBufferCount(bufferCount);\n            reply->writeInt32(result);\n            return NO_ERROR;\n        } break;\n        case DEQUEUE_BUFFER: {\n            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);\n            bool async      = data.readInt32();\n            uint32_t w      = data.readInt32();\n            uint32_t h      = data.readInt32();\n            uint32_t format = data.readInt32();\n            uint32_t usage  = data.readInt32();\n            int buf = 0;\n            sp<Fence> fence;\n            int result = dequeueBuffer(&buf, &fence, async, w, h, format, usage);\n            reply->writeInt32(buf);\n            reply->writeInt32(fence != NULL);\n            if (fence != NULL) {\n                reply->write(*fence);\n            }\n            reply->writeInt32(result);\n            return NO_ERROR;\n        } break;\n        case QUEUE_BUFFER: {\n            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);\n            int buf = data.readInt32();\n            QueueBufferInput input(data);\n            QueueBufferOutput* const output =\n                    reinterpret_cast<QueueBufferOutput *>(\n                            reply->writeInplace(sizeof(QueueBufferOutput)));\n            status_t result = queueBuffer(buf, input, output);\n            reply->writeInt32(result);\n            return NO_ERROR;\n        } break;\n        case CANCEL_BUFFER: {\n            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);\n            int buf = data.readInt32();\n            sp<Fence> fence = new Fence();\n            data.read(*fence.get());\n            cancelBuffer(buf, fence);\n            return NO_ERROR;\n        } break;\n        case QUERY: {\n            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);\n            int value = 0;\n            int what = data.readInt32();\n            int res = query(what, &value);\n            reply->writeInt32(value);\n            reply->writeInt32(res);\n            return NO_ERROR;\n        } break;\n        case CONNECT: {\n            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);\n            sp<IBinder> token = data.readStrongBinder();\n            int api = data.readInt32();\n            bool producerControlledByApp = data.readInt32();\n            QueueBufferOutput* const output =\n                    reinterpret_cast<QueueBufferOutput *>(\n                            reply->writeInplace(sizeof(QueueBufferOutput)));\n            status_t res = connect(token, api, producerControlledByApp, output);\n            reply->writeInt32(res);\n            return NO_ERROR;\n        } break;\n        case DISCONNECT: {\n            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);\n            int api = data.readInt32();\n            status_t res = disconnect(api);\n            reply->writeInt32(res);\n            return NO_ERROR;\n        } break;\n    }\n    return BBinder::onTransact(code, data, reply, flags);\n}",
        "func": "status_t BnGraphicBufferProducer::onTransact(\n    uint32_t code, const Parcel& data, Parcel* reply, uint32_t flags)\n{\n    switch(code) {\n        case REQUEST_BUFFER: {\n            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);\n            int bufferIdx   = data.readInt32();\n            sp<GraphicBuffer> buffer;\n            int result = requestBuffer(bufferIdx, &buffer);\n            reply->writeInt32(buffer != 0);\n            if (buffer != 0) {\n                reply->write(*buffer);\n            }\n            reply->writeInt32(result);\n            return NO_ERROR;\n        } break;\n        case SET_BUFFER_COUNT: {\n            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);\n            int bufferCount = data.readInt32();\n            int result = setBufferCount(bufferCount);\n            reply->writeInt32(result);\n            return NO_ERROR;\n        } break;\n        case DEQUEUE_BUFFER: {\n            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);\n            bool async      = data.readInt32();\n            uint32_t w      = data.readInt32();\n            uint32_t h      = data.readInt32();\n            uint32_t format = data.readInt32();\n            uint32_t usage  = data.readInt32();\n            int buf = 0;\n            sp<Fence> fence;\n            int result = dequeueBuffer(&buf, &fence, async, w, h, format, usage);\n            reply->writeInt32(buf);\n            reply->writeInt32(fence != NULL);\n            if (fence != NULL) {\n                reply->write(*fence);\n            }\n            reply->writeInt32(result);\n            return NO_ERROR;\n        } break;\n        case QUEUE_BUFFER: {\n            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);\n            int buf = data.readInt32();\n            QueueBufferInput input(data);\n            QueueBufferOutput* const output =\n                    reinterpret_cast<QueueBufferOutput *>(\n                            reply->writeInplace(sizeof(QueueBufferOutput)));\n            memset(output, 0, sizeof(QueueBufferOutput));\n            status_t result = queueBuffer(buf, input, output);\n            reply->writeInt32(result);\n            return NO_ERROR;\n        } break;\n        case CANCEL_BUFFER: {\n            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);\n            int buf = data.readInt32();\n            sp<Fence> fence = new Fence();\n            data.read(*fence.get());\n            cancelBuffer(buf, fence);\n            return NO_ERROR;\n        } break;\n        case QUERY: {\n            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);\n            int value = 0;\n            int what = data.readInt32();\n            int res = query(what, &value);\n            reply->writeInt32(value);\n            reply->writeInt32(res);\n            return NO_ERROR;\n        } break;\n        case CONNECT: {\n            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);\n            sp<IBinder> token = data.readStrongBinder();\n            int api = data.readInt32();\n            bool producerControlledByApp = data.readInt32();\n            QueueBufferOutput* const output =\n                    reinterpret_cast<QueueBufferOutput *>(\n                            reply->writeInplace(sizeof(QueueBufferOutput)));\n            status_t res = connect(token, api, producerControlledByApp, output);\n            reply->writeInt32(res);\n            return NO_ERROR;\n        } break;\n        case DISCONNECT: {\n            CHECK_INTERFACE(IGraphicBufferProducer, data, reply);\n            int api = data.readInt32();\n            status_t res = disconnect(api);\n            reply->writeInt32(res);\n            return NO_ERROR;\n        } break;\n    }\n    return BBinder::onTransact(code, data, reply, flags);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -46,6 +46,7 @@\n             QueueBufferOutput* const output =\n                     reinterpret_cast<QueueBufferOutput *>(\n                             reply->writeInplace(sizeof(QueueBufferOutput)));\n+            memset(output, 0, sizeof(QueueBufferOutput));\n             status_t result = queueBuffer(buf, input, output);\n             reply->writeInt32(result);\n             return NO_ERROR;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "            memset(output, 0, sizeof(QueueBufferOutput));"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-1652",
        "func_name": "chromium/ModuleSystem::RequireForJsInner",
        "description": "Cross-site scripting (XSS) vulnerability in the ModuleSystem::RequireForJsInner function in extensions/renderer/module_system.cc in the Extensions subsystem in Google Chrome before 50.0.2661.75 allows remote attackers to inject arbitrary web script or HTML via a crafted web site, aka \"Universal XSS (UXSS).\"",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/75b803b1c81ed9fa5513cbff550232b4fb915e7b",
        "commit_title": "[Extensions] Harden against bindings interception",
        "commit_text": " There's more we can do but this is a start.    ",
        "func_before": "v8::Local<v8::Value> ModuleSystem::RequireForJsInner(\n    v8::Local<v8::String> module_name) {\n  v8::EscapableHandleScope handle_scope(GetIsolate());\n  v8::Local<v8::Context> v8_context = context()->v8_context();\n  v8::Context::Scope context_scope(v8_context);\n\n  v8::Local<v8::Object> global(context()->v8_context()->Global());\n\n  // The module system might have been deleted. This can happen if a different\n  // context keeps a reference to us, but our frame is destroyed (e.g.\n  // background page keeps reference to chrome object in a closed popup).\n  v8::Local<v8::Value> modules_value;\n  if (!GetPrivate(global, kModulesField, &modules_value) ||\n      modules_value->IsUndefined()) {\n    Warn(GetIsolate(), \"Extension view no longer exists\");\n    return v8::Undefined(GetIsolate());\n  }\n\n  v8::Local<v8::Object> modules(v8::Local<v8::Object>::Cast(modules_value));\n  v8::Local<v8::Value> exports;\n  if (!GetProperty(v8_context, modules, module_name, &exports) ||\n      !exports->IsUndefined())\n    return handle_scope.Escape(exports);\n\n  exports = LoadModule(*v8::String::Utf8Value(module_name));\n  SetProperty(v8_context, modules, module_name, exports);\n  return handle_scope.Escape(exports);\n}",
        "func": "v8::Local<v8::Value> ModuleSystem::RequireForJsInner(\n    v8::Local<v8::String> module_name) {\n  v8::EscapableHandleScope handle_scope(GetIsolate());\n  v8::Local<v8::Context> v8_context = context()->v8_context();\n  v8::Context::Scope context_scope(v8_context);\n\n  v8::Local<v8::Object> global(context()->v8_context()->Global());\n\n  // The module system might have been deleted. This can happen if a different\n  // context keeps a reference to us, but our frame is destroyed (e.g.\n  // background page keeps reference to chrome object in a closed popup).\n  v8::Local<v8::Value> modules_value;\n  if (!GetPrivate(global, kModulesField, &modules_value) ||\n      modules_value->IsUndefined()) {\n    Warn(GetIsolate(), \"Extension view no longer exists\");\n    return v8::Undefined(GetIsolate());\n  }\n\n  v8::Local<v8::Object> modules(v8::Local<v8::Object>::Cast(modules_value));\n  v8::Local<v8::Value> exports;\n  if (!GetPrivateProperty(v8_context, modules, module_name, &exports) ||\n      !exports->IsUndefined())\n    return handle_scope.Escape(exports);\n\n  exports = LoadModule(*v8::String::Utf8Value(module_name));\n  SetPrivateProperty(v8_context, modules, module_name, exports);\n  return handle_scope.Escape(exports);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -18,11 +18,11 @@\n \n   v8::Local<v8::Object> modules(v8::Local<v8::Object>::Cast(modules_value));\n   v8::Local<v8::Value> exports;\n-  if (!GetProperty(v8_context, modules, module_name, &exports) ||\n+  if (!GetPrivateProperty(v8_context, modules, module_name, &exports) ||\n       !exports->IsUndefined())\n     return handle_scope.Escape(exports);\n \n   exports = LoadModule(*v8::String::Utf8Value(module_name));\n-  SetProperty(v8_context, modules, module_name, exports);\n+  SetPrivateProperty(v8_context, modules, module_name, exports);\n   return handle_scope.Escape(exports);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "  if (!GetProperty(v8_context, modules, module_name, &exports) ||",
                "  SetProperty(v8_context, modules, module_name, exports);"
            ],
            "added_lines": [
                "  if (!GetPrivateProperty(v8_context, modules, module_name, &exports) ||",
                "  SetPrivateProperty(v8_context, modules, module_name, exports);"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-1657",
        "func_name": "chromium/WebContentsImpl::FocusLocationBarByDefault",
        "description": "The WebContentsImpl::FocusLocationBarByDefault function in content/browser/web_contents/web_contents_impl.cc in Google Chrome before 50.0.2661.75 mishandles focus for certain about:blank pages, which allows remote attackers to spoof the address bar via a crafted URL.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/c70cb1fe9303df33b11187d0f5f60d22938e6e63",
        "commit_title": "Don't focus the location bar in a phishy situation.",
        "commit_text": " There is logic to focus the location bar for editing if the URL is about:blank. However, if the page transition type is PAGE_TRANSITION_LINK, bypass that logic; it's not really a blank page. This avoids a phishy edge case with window.open.    ",
        "func_before": "bool WebContentsImpl::FocusLocationBarByDefault() {\n  NavigationEntry* entry = controller_.GetVisibleEntry();\n  if (entry && entry->GetURL() == GURL(url::kAboutBlankURL))\n    return true;\n  return delegate_ && delegate_->ShouldFocusLocationBarByDefault(this);\n}",
        "func": "bool WebContentsImpl::FocusLocationBarByDefault() {\n  // When the browser is started with about:blank as the startup URL, focus\n  // the location bar (which will also select its contents) so people can\n  // simply begin typing to navigate elsewhere.\n  //\n  // We need to be careful not to trigger this for anything other than the\n  // startup navigation. In particular, if we allow an attacker to open a\n  // popup to about:blank, then navigate, focusing the Omnibox will cause the\n  // end of the new URL to be scrolled into view instead of the start,\n  // allowing the attacker to spoof other URLs. The conditions checked here\n  // are all aimed at ensuring no such attacker-controlled navigation can\n  // trigger this.\n  //\n  // Note that we check the pending entry instead of the visible one; for the\n  // startup URL case these are the same, but for the attacker-controlled\n  // navigation case the visible entry is the committed \"about:blank\" URL and\n  // the pending entry is the problematic navigation elsewhere.\n  NavigationEntryImpl* entry = controller_.GetPendingEntry();\n  if (controller_.IsInitialNavigation() && entry &&\n      !entry->is_renderer_initiated() &&\n      entry->GetURL() == GURL(url::kAboutBlankURL)) {\n    return true;\n  }\n  return delegate_ && delegate_->ShouldFocusLocationBarByDefault(this);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,25 @@\n bool WebContentsImpl::FocusLocationBarByDefault() {\n-  NavigationEntry* entry = controller_.GetVisibleEntry();\n-  if (entry && entry->GetURL() == GURL(url::kAboutBlankURL))\n+  // When the browser is started with about:blank as the startup URL, focus\n+  // the location bar (which will also select its contents) so people can\n+  // simply begin typing to navigate elsewhere.\n+  //\n+  // We need to be careful not to trigger this for anything other than the\n+  // startup navigation. In particular, if we allow an attacker to open a\n+  // popup to about:blank, then navigate, focusing the Omnibox will cause the\n+  // end of the new URL to be scrolled into view instead of the start,\n+  // allowing the attacker to spoof other URLs. The conditions checked here\n+  // are all aimed at ensuring no such attacker-controlled navigation can\n+  // trigger this.\n+  //\n+  // Note that we check the pending entry instead of the visible one; for the\n+  // startup URL case these are the same, but for the attacker-controlled\n+  // navigation case the visible entry is the committed \"about:blank\" URL and\n+  // the pending entry is the problematic navigation elsewhere.\n+  NavigationEntryImpl* entry = controller_.GetPendingEntry();\n+  if (controller_.IsInitialNavigation() && entry &&\n+      !entry->is_renderer_initiated() &&\n+      entry->GetURL() == GURL(url::kAboutBlankURL)) {\n     return true;\n+  }\n   return delegate_ && delegate_->ShouldFocusLocationBarByDefault(this);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "  NavigationEntry* entry = controller_.GetVisibleEntry();",
                "  if (entry && entry->GetURL() == GURL(url::kAboutBlankURL))"
            ],
            "added_lines": [
                "  // When the browser is started with about:blank as the startup URL, focus",
                "  // the location bar (which will also select its contents) so people can",
                "  // simply begin typing to navigate elsewhere.",
                "  //",
                "  // We need to be careful not to trigger this for anything other than the",
                "  // startup navigation. In particular, if we allow an attacker to open a",
                "  // popup to about:blank, then navigate, focusing the Omnibox will cause the",
                "  // end of the new URL to be scrolled into view instead of the start,",
                "  // allowing the attacker to spoof other URLs. The conditions checked here",
                "  // are all aimed at ensuring no such attacker-controlled navigation can",
                "  // trigger this.",
                "  //",
                "  // Note that we check the pending entry instead of the visible one; for the",
                "  // startup URL case these are the same, but for the attacker-controlled",
                "  // navigation case the visible entry is the committed \"about:blank\" URL and",
                "  // the pending entry is the problematic navigation elsewhere.",
                "  NavigationEntryImpl* entry = controller_.GetPendingEntry();",
                "  if (controller_.IsInitialNavigation() && entry &&",
                "      !entry->is_renderer_initiated() &&",
                "      entry->GetURL() == GURL(url::kAboutBlankURL)) {",
                "  }"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-3672",
        "func_name": "torvalds/linux/arch_pick_mmap_layout",
        "description": "The arch_pick_mmap_layout function in arch/x86/mm/mmap.c in the Linux kernel through 4.5.2 does not properly randomize the legacy base address, which makes it easier for local users to defeat the intended restrictions on the ADDR_NO_RANDOMIZE flag, and bypass the ASLR protection mechanism for a setuid or setgid program, by disabling stack-consumption resource limits.",
        "git_url": "https://github.com/torvalds/linux/commit/8b8addf891de8a00e4d39fc32f93f7c5eb8feceb",
        "commit_title": "x86/mm/32: Enable full randomization on i386 and X86_32",
        "commit_text": " Currently on i386 and on X86_64 when emulating X86_32 in legacy mode, only the stack and the executable are randomized but not other mmapped files (libraries, vDSO, etc.). This patch enables randomization for the libraries, vDSO and mmap requests on i386 and in X86_32 in legacy mode.  By default on i386 there are 8 bits for the randomization of the libraries, vDSO and mmaps which only uses 1MB of VA.  This patch preserves the original randomness, using 1MB of VA out of 3GB or 4GB. We think that 1MB out of 3GB is not a big cost for having the ASLR.  The first obvious security benefit is that all objects are randomized (not only the stack and the executable) in legacy mode which highly increases the ASLR effectiveness, otherwise the attackers may use these non-randomized areas. But also sensitive setuid/setgid applications are more secure because currently, attackers can disable the randomization of these applications by setting the ulimit stack to \"unlimited\". This is a very old and widely known trick to disable the ASLR in i386 which has been allowed for too long.  Another trick used to disable the ASLR was to set the ADDR_NO_RANDOMIZE personality flag, but fortunately this doesn't work on setuid/setgid applications because there is security checks which clear Security-relevant flags.  This patch always randomizes the mmap_legacy_base address, removing the possibility to disable the ASLR by setting the stack to \"unlimited\".  Cc: Linus Torvalds <torvalds@linux-foundation.org> Cc: Peter Zijlstra <peterz@infradead.org> Cc: Thomas Gleixner <tglx@linutronix.de> Cc: akpm@linux-foundation.org Cc: kees Cook <keescook@chromium.org> Link: http://lkml.kernel.org/r/1457639460-5242-1-git-send-email-hecmargi@upv.es",
        "func_before": "void arch_pick_mmap_layout(struct mm_struct *mm)\n{\n\tunsigned long random_factor = 0UL;\n\n\tif (current->flags & PF_RANDOMIZE)\n\t\trandom_factor = arch_mmap_rnd();\n\n\tmm->mmap_legacy_base = mmap_legacy_base(random_factor);\n\n\tif (mmap_is_legacy()) {\n\t\tmm->mmap_base = mm->mmap_legacy_base;\n\t\tmm->get_unmapped_area = arch_get_unmapped_area;\n\t} else {\n\t\tmm->mmap_base = mmap_base(random_factor);\n\t\tmm->get_unmapped_area = arch_get_unmapped_area_topdown;\n\t}\n}",
        "func": "void arch_pick_mmap_layout(struct mm_struct *mm)\n{\n\tunsigned long random_factor = 0UL;\n\n\tif (current->flags & PF_RANDOMIZE)\n\t\trandom_factor = arch_mmap_rnd();\n\n\tmm->mmap_legacy_base = TASK_UNMAPPED_BASE + random_factor;\n\n\tif (mmap_is_legacy()) {\n\t\tmm->mmap_base = mm->mmap_legacy_base;\n\t\tmm->get_unmapped_area = arch_get_unmapped_area;\n\t} else {\n\t\tmm->mmap_base = mmap_base(random_factor);\n\t\tmm->get_unmapped_area = arch_get_unmapped_area_topdown;\n\t}\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,7 +5,7 @@\n \tif (current->flags & PF_RANDOMIZE)\n \t\trandom_factor = arch_mmap_rnd();\n \n-\tmm->mmap_legacy_base = mmap_legacy_base(random_factor);\n+\tmm->mmap_legacy_base = TASK_UNMAPPED_BASE + random_factor;\n \n \tif (mmap_is_legacy()) {\n \t\tmm->mmap_base = mm->mmap_legacy_base;",
        "diff_line_info": {
            "deleted_lines": [
                "\tmm->mmap_legacy_base = mmap_legacy_base(random_factor);"
            ],
            "added_lines": [
                "\tmm->mmap_legacy_base = TASK_UNMAPPED_BASE + random_factor;"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-1664",
        "func_name": "chromium/HistoryController::UpdateForCommit",
        "description": "The HistoryController::UpdateForCommit function in content/renderer/history_controller.cc in Google Chrome before 50.0.2661.94 mishandles the interaction between subframe forward navigations and other forward navigations, which allows remote attackers to spoof the address bar via a crafted web site.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/82500315884357312b3caafb49d347ef011c296f",
        "commit_title": "Fix HistoryEntry corruption when commit isn't for provisional entry (try #2).",
        "commit_text": " CQ_INCLUDE_TRYBOTS=tryserver.chromium.linux:linux_site_isolation   ",
        "func_before": "void HistoryController::UpdateForCommit(RenderFrameImpl* frame,\n                                        const WebHistoryItem& item,\n                                        WebHistoryCommitType commit_type,\n                                        bool navigation_within_page) {\n  switch (commit_type) {\n    case blink::WebBackForwardCommit:\n      if (!provisional_entry_)\n        return;\n      current_entry_.reset(provisional_entry_.release());\n      if (HistoryEntry::HistoryNode* node =\n              current_entry_->GetHistoryNodeForFrame(frame)) {\n        node->set_item(item);\n      }\n      break;\n    case blink::WebStandardCommit:\n      CreateNewBackForwardItem(frame, item, navigation_within_page);\n      break;\n    case blink::WebInitialCommitInChildFrame:\n      UpdateForInitialLoadInChildFrame(frame, item);\n      break;\n    case blink::WebHistoryInertCommit:\n      // Even for inert commits (e.g., location.replace, client redirects), make\n      // sure the current entry gets updated, if there is one.\n      if (current_entry_) {\n        if (HistoryEntry::HistoryNode* node =\n                current_entry_->GetHistoryNodeForFrame(frame)) {\n          // Inert commits that reset the page without changing the item (e.g.,\n          // reloads, location.replace) shouldn't keep the old subtree.\n          if (!navigation_within_page)\n            node->RemoveChildren();\n          node->set_item(item);\n        }\n      }\n      break;\n    default:\n      NOTREACHED() << \"Invalid commit type: \" << commit_type;\n  }\n}",
        "func": "void HistoryController::UpdateForCommit(RenderFrameImpl* frame,\n                                        const WebHistoryItem& item,\n                                        WebHistoryCommitType commit_type,\n                                        bool navigation_within_page) {\n  switch (commit_type) {\n    case blink::WebBackForwardCommit:\n      if (!provisional_entry_)\n        return;\n\n      // If the current entry is null, this must be a main frame commit.\n      DCHECK(current_entry_ || frame->IsMainFrame());\n\n      // Commit the provisional entry, but only if it is a plausible transition.\n      // Do not commit it if the navigation is in a subframe and the provisional\n      // entry's main frame item does not match the current entry's main frame,\n      // which can happen if multiple forward navigations occur.  In that case,\n      // committing the provisional entry would corrupt it, leading to a URL\n      // spoof.  See https://crbug.com/597322.  (Note that the race in this bug\n      // does not affect main frame navigations, only navigations in subframes.)\n      //\n      // Note that we cannot compare the provisional entry against |item|, since\n      // |item| may have redirected to a different URL and ISN.  We also cannot\n      // compare against the main frame's URL, since that may have changed due\n      // to a replaceState.  (Even origin can change on replaceState in certain\n      // modes.)\n      //\n      // It would be safe to additionally check the ISNs of all parent frames\n      // (and not just the root), but that is less critical because it won't\n      // lead to a URL spoof.\n      if (frame->IsMainFrame() ||\n          current_entry_->root().itemSequenceNumber() ==\n              provisional_entry_->root().itemSequenceNumber()) {\n        current_entry_.reset(provisional_entry_.release());\n      }\n\n      // We're guaranteed to have a current entry now.\n      DCHECK(current_entry_);\n\n      if (HistoryEntry::HistoryNode* node =\n              current_entry_->GetHistoryNodeForFrame(frame)) {\n        node->set_item(item);\n      }\n      break;\n    case blink::WebStandardCommit:\n      CreateNewBackForwardItem(frame, item, navigation_within_page);\n      break;\n    case blink::WebInitialCommitInChildFrame:\n      UpdateForInitialLoadInChildFrame(frame, item);\n      break;\n    case blink::WebHistoryInertCommit:\n      // Even for inert commits (e.g., location.replace, client redirects), make\n      // sure the current entry gets updated, if there is one.\n      if (current_entry_) {\n        if (HistoryEntry::HistoryNode* node =\n                current_entry_->GetHistoryNodeForFrame(frame)) {\n          // Inert commits that reset the page without changing the item (e.g.,\n          // reloads, location.replace) shouldn't keep the old subtree.\n          if (!navigation_within_page)\n            node->RemoveChildren();\n          node->set_item(item);\n        }\n      }\n      break;\n    default:\n      NOTREACHED() << \"Invalid commit type: \" << commit_type;\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,7 +6,36 @@\n     case blink::WebBackForwardCommit:\n       if (!provisional_entry_)\n         return;\n-      current_entry_.reset(provisional_entry_.release());\n+\n+      // If the current entry is null, this must be a main frame commit.\n+      DCHECK(current_entry_ || frame->IsMainFrame());\n+\n+      // Commit the provisional entry, but only if it is a plausible transition.\n+      // Do not commit it if the navigation is in a subframe and the provisional\n+      // entry's main frame item does not match the current entry's main frame,\n+      // which can happen if multiple forward navigations occur.  In that case,\n+      // committing the provisional entry would corrupt it, leading to a URL\n+      // spoof.  See https://crbug.com/597322.  (Note that the race in this bug\n+      // does not affect main frame navigations, only navigations in subframes.)\n+      //\n+      // Note that we cannot compare the provisional entry against |item|, since\n+      // |item| may have redirected to a different URL and ISN.  We also cannot\n+      // compare against the main frame's URL, since that may have changed due\n+      // to a replaceState.  (Even origin can change on replaceState in certain\n+      // modes.)\n+      //\n+      // It would be safe to additionally check the ISNs of all parent frames\n+      // (and not just the root), but that is less critical because it won't\n+      // lead to a URL spoof.\n+      if (frame->IsMainFrame() ||\n+          current_entry_->root().itemSequenceNumber() ==\n+              provisional_entry_->root().itemSequenceNumber()) {\n+        current_entry_.reset(provisional_entry_.release());\n+      }\n+\n+      // We're guaranteed to have a current entry now.\n+      DCHECK(current_entry_);\n+\n       if (HistoryEntry::HistoryNode* node =\n               current_entry_->GetHistoryNodeForFrame(frame)) {\n         node->set_item(item);",
        "diff_line_info": {
            "deleted_lines": [
                "      current_entry_.reset(provisional_entry_.release());"
            ],
            "added_lines": [
                "",
                "      // If the current entry is null, this must be a main frame commit.",
                "      DCHECK(current_entry_ || frame->IsMainFrame());",
                "",
                "      // Commit the provisional entry, but only if it is a plausible transition.",
                "      // Do not commit it if the navigation is in a subframe and the provisional",
                "      // entry's main frame item does not match the current entry's main frame,",
                "      // which can happen if multiple forward navigations occur.  In that case,",
                "      // committing the provisional entry would corrupt it, leading to a URL",
                "      // spoof.  See https://crbug.com/597322.  (Note that the race in this bug",
                "      // does not affect main frame navigations, only navigations in subframes.)",
                "      //",
                "      // Note that we cannot compare the provisional entry against |item|, since",
                "      // |item| may have redirected to a different URL and ISN.  We also cannot",
                "      // compare against the main frame's URL, since that may have changed due",
                "      // to a replaceState.  (Even origin can change on replaceState in certain",
                "      // modes.)",
                "      //",
                "      // It would be safe to additionally check the ISNs of all parent frames",
                "      // (and not just the root), but that is less critical because it won't",
                "      // lead to a URL spoof.",
                "      if (frame->IsMainFrame() ||",
                "          current_entry_->root().itemSequenceNumber() ==",
                "              provisional_entry_->root().itemSequenceNumber()) {",
                "        current_entry_.reset(provisional_entry_.release());",
                "      }",
                "",
                "      // We're guaranteed to have a current entry now.",
                "      DCHECK(current_entry_);",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2015-3411",
        "func_name": "php/php-src/_php_image_create_from",
        "description": "PHP before 5.4.40, 5.5.x before 5.5.24, and 5.6.x before 5.6.8 does not ensure that pathnames lack %00 sequences, which might allow remote attackers to read or write to arbitrary files via crafted input to an application that calls (1) a DOMDocument load method, (2) the xmlwriter_open_uri function, (3) the finfo_file function, or (4) the hash_hmac_file function, as demonstrated by a filename\\0.xml attack that bypasses an intended configuration in which client users may read only .xml files.",
        "git_url": "https://github.com/php/php-src/commit/4435b9142ff9813845d5c97ab29a5d637bedb257",
        "commit_title": "Fixed bug #69353 (Missing null byte checks for paths in various PHP extensions)",
        "commit_text": "",
        "func_before": "static void _php_image_create_from(INTERNAL_FUNCTION_PARAMETERS, int image_type, char *tn, gdImagePtr (*func_p)(), gdImagePtr (*ioctx_func_p)())\n{\n\tchar *file;\n\tint file_len;\n\tlong srcx, srcy, width, height;\n\tgdImagePtr im = NULL;\n\tphp_stream *stream;\n\tFILE * fp = NULL;\n#ifdef HAVE_GD_JPG\n\tlong ignore_warning;\n#endif\n\tif (image_type == PHP_GDIMG_TYPE_GD2PART) {\n\t\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"sllll\", &file, &file_len, &srcx, &srcy, &width, &height) == FAILURE) {\n\t\t\treturn;\n\t\t}\n\t\tif (width < 1 || height < 1) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Zero width or height not allowed\");\n\t\t\tRETURN_FALSE;\n\t\t}\n\t} else {\n\t\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s\", &file, &file_len) == FAILURE) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tstream = php_stream_open_wrapper(file, \"rb\", REPORT_ERRORS|IGNORE_PATH|IGNORE_URL_WIN, NULL);\n\tif (stream == NULL)\t{\n\t\tRETURN_FALSE;\n\t}\n\n#ifndef USE_GD_IOCTX\n\tioctx_func_p = NULL; /* don't allow sockets without IOCtx */\n#endif\n\n\tif (image_type == PHP_GDIMG_TYPE_WEBP) {\n\t\tsize_t buff_size;\n\t\tchar *buff;\n\n\t\t/* needs to be malloc (persistent) - GD will free() it later */\n\t\tbuff_size = php_stream_copy_to_mem(stream, &buff, PHP_STREAM_COPY_ALL, 1);\n\t\tif (!buff_size) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING,\"Cannot read image data\");\n\t\t\tgoto out_err;\n\t\t}\n\t\tim = (*ioctx_func_p)(buff_size, buff);\n\t\tif (!im) {\n\t\t\tgoto out_err;\n\t\t}\n\t\tgoto register_im;\n\t}\n\n\t/* try and avoid allocating a FILE* if the stream is not naturally a FILE* */\n\tif (php_stream_is(stream, PHP_STREAM_IS_STDIO))\t{\n\t\tif (FAILURE == php_stream_cast(stream, PHP_STREAM_AS_STDIO, (void**)&fp, REPORT_ERRORS)) {\n\t\t\tgoto out_err;\n\t\t}\n\t} else if (ioctx_func_p) {\n#ifdef USE_GD_IOCTX\n\t\t/* we can create an io context */\n\t\tgdIOCtx* io_ctx;\n\t\tsize_t buff_size;\n\t\tchar *buff;\n\n\t\t/* needs to be malloc (persistent) - GD will free() it later */\n\t\tbuff_size = php_stream_copy_to_mem(stream, &buff, PHP_STREAM_COPY_ALL, 1);\n\n\t\tif (!buff_size) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING,\"Cannot read image data\");\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tio_ctx = gdNewDynamicCtxEx(buff_size, buff, 0);\n\t\tif (!io_ctx) {\n\t\t\tpefree(buff, 1);\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING,\"Cannot allocate GD IO context\");\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tif (image_type == PHP_GDIMG_TYPE_GD2PART) {\n\t\t\tim = (*ioctx_func_p)(io_ctx, srcx, srcy, width, height);\n\t\t} else {\n\t\t\tim = (*ioctx_func_p)(io_ctx);\n\t\t}\n#if HAVE_LIBGD204\n\t\tio_ctx->gd_free(io_ctx);\n#else\n\t\tio_ctx->free(io_ctx);\n#endif\n\t\tpefree(buff, 1);\n#endif\n\t}\n\telse {\n\t\t/* try and force the stream to be FILE* */\n\t\tif (FAILURE == php_stream_cast(stream, PHP_STREAM_AS_STDIO | PHP_STREAM_CAST_TRY_HARD, (void **) &fp, REPORT_ERRORS)) {\n\t\t\tgoto out_err;\n\t\t}\n\t}\n\n\tif (!im && fp) {\n\t\tswitch (image_type) {\n\t\t\tcase PHP_GDIMG_TYPE_GD2PART:\n\t\t\t\tim = (*func_p)(fp, srcx, srcy, width, height);\n\t\t\t\tbreak;\n#if defined(HAVE_GD_XPM) && defined(HAVE_GD_BUNDLED)\n\t\t\tcase PHP_GDIMG_TYPE_XPM:\n\t\t\t\tim = gdImageCreateFromXpm(file);\n\t\t\t\tbreak;\n#endif\n\n#ifdef HAVE_GD_JPG\n\t\t\tcase PHP_GDIMG_TYPE_JPG:\n\t\t\t\tignore_warning = INI_INT(\"gd.jpeg_ignore_warning\");\n#ifdef HAVE_GD_BUNDLED\n\t\t\t\tim = gdImageCreateFromJpeg(fp, ignore_warning);\n#else\n\t\t\t\tim = gdImageCreateFromJpeg(fp);\n#endif\n\t\t\tbreak;\n#endif\n\n\t\t\tdefault:\n\t\t\t\tim = (*func_p)(fp);\n\t\t\t\tbreak;\n\t\t}\n\n\t\tfflush(fp);\n\t}\n\nregister_im:\n\tif (im) {\n\t\tZEND_REGISTER_RESOURCE(return_value, im, le_gd);\n\t\tphp_stream_close(stream);\n\t\treturn;\n\t}\n\n\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"'%s' is not a valid %s file\", file, tn);\nout_err:\n\tphp_stream_close(stream);\n\tRETURN_FALSE;\n\n}",
        "func": "static void _php_image_create_from(INTERNAL_FUNCTION_PARAMETERS, int image_type, char *tn, gdImagePtr (*func_p)(), gdImagePtr (*ioctx_func_p)())\n{\n\tchar *file;\n\tint file_len;\n\tlong srcx, srcy, width, height;\n\tgdImagePtr im = NULL;\n\tphp_stream *stream;\n\tFILE * fp = NULL;\n#ifdef HAVE_GD_JPG\n\tlong ignore_warning;\n#endif\n\tif (image_type == PHP_GDIMG_TYPE_GD2PART) {\n\t\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"pllll\", &file, &file_len, &srcx, &srcy, &width, &height) == FAILURE) {\n\t\t\treturn;\n\t\t}\n\t\tif (width < 1 || height < 1) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Zero width or height not allowed\");\n\t\t\tRETURN_FALSE;\n\t\t}\n\t} else {\n\t\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"p\", &file, &file_len) == FAILURE) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tstream = php_stream_open_wrapper(file, \"rb\", REPORT_ERRORS|IGNORE_PATH|IGNORE_URL_WIN, NULL);\n\tif (stream == NULL)\t{\n\t\tRETURN_FALSE;\n\t}\n\n#ifndef USE_GD_IOCTX\n\tioctx_func_p = NULL; /* don't allow sockets without IOCtx */\n#endif\n\n\tif (image_type == PHP_GDIMG_TYPE_WEBP) {\n\t\tsize_t buff_size;\n\t\tchar *buff;\n\n\t\t/* needs to be malloc (persistent) - GD will free() it later */\n\t\tbuff_size = php_stream_copy_to_mem(stream, &buff, PHP_STREAM_COPY_ALL, 1);\n\t\tif (!buff_size) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING,\"Cannot read image data\");\n\t\t\tgoto out_err;\n\t\t}\n\t\tim = (*ioctx_func_p)(buff_size, buff);\n\t\tif (!im) {\n\t\t\tgoto out_err;\n\t\t}\n\t\tgoto register_im;\n\t}\n\n\t/* try and avoid allocating a FILE* if the stream is not naturally a FILE* */\n\tif (php_stream_is(stream, PHP_STREAM_IS_STDIO))\t{\n\t\tif (FAILURE == php_stream_cast(stream, PHP_STREAM_AS_STDIO, (void**)&fp, REPORT_ERRORS)) {\n\t\t\tgoto out_err;\n\t\t}\n\t} else if (ioctx_func_p) {\n#ifdef USE_GD_IOCTX\n\t\t/* we can create an io context */\n\t\tgdIOCtx* io_ctx;\n\t\tsize_t buff_size;\n\t\tchar *buff;\n\n\t\t/* needs to be malloc (persistent) - GD will free() it later */\n\t\tbuff_size = php_stream_copy_to_mem(stream, &buff, PHP_STREAM_COPY_ALL, 1);\n\n\t\tif (!buff_size) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING,\"Cannot read image data\");\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tio_ctx = gdNewDynamicCtxEx(buff_size, buff, 0);\n\t\tif (!io_ctx) {\n\t\t\tpefree(buff, 1);\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING,\"Cannot allocate GD IO context\");\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tif (image_type == PHP_GDIMG_TYPE_GD2PART) {\n\t\t\tim = (*ioctx_func_p)(io_ctx, srcx, srcy, width, height);\n\t\t} else {\n\t\t\tim = (*ioctx_func_p)(io_ctx);\n\t\t}\n#if HAVE_LIBGD204\n\t\tio_ctx->gd_free(io_ctx);\n#else\n\t\tio_ctx->free(io_ctx);\n#endif\n\t\tpefree(buff, 1);\n#endif\n\t}\n\telse {\n\t\t/* try and force the stream to be FILE* */\n\t\tif (FAILURE == php_stream_cast(stream, PHP_STREAM_AS_STDIO | PHP_STREAM_CAST_TRY_HARD, (void **) &fp, REPORT_ERRORS)) {\n\t\t\tgoto out_err;\n\t\t}\n\t}\n\n\tif (!im && fp) {\n\t\tswitch (image_type) {\n\t\t\tcase PHP_GDIMG_TYPE_GD2PART:\n\t\t\t\tim = (*func_p)(fp, srcx, srcy, width, height);\n\t\t\t\tbreak;\n#if defined(HAVE_GD_XPM) && defined(HAVE_GD_BUNDLED)\n\t\t\tcase PHP_GDIMG_TYPE_XPM:\n\t\t\t\tim = gdImageCreateFromXpm(file);\n\t\t\t\tbreak;\n#endif\n\n#ifdef HAVE_GD_JPG\n\t\t\tcase PHP_GDIMG_TYPE_JPG:\n\t\t\t\tignore_warning = INI_INT(\"gd.jpeg_ignore_warning\");\n#ifdef HAVE_GD_BUNDLED\n\t\t\t\tim = gdImageCreateFromJpeg(fp, ignore_warning);\n#else\n\t\t\t\tim = gdImageCreateFromJpeg(fp);\n#endif\n\t\t\tbreak;\n#endif\n\n\t\t\tdefault:\n\t\t\t\tim = (*func_p)(fp);\n\t\t\t\tbreak;\n\t\t}\n\n\t\tfflush(fp);\n\t}\n\nregister_im:\n\tif (im) {\n\t\tZEND_REGISTER_RESOURCE(return_value, im, le_gd);\n\t\tphp_stream_close(stream);\n\t\treturn;\n\t}\n\n\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"'%s' is not a valid %s file\", file, tn);\nout_err:\n\tphp_stream_close(stream);\n\tRETURN_FALSE;\n\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -10,7 +10,7 @@\n \tlong ignore_warning;\n #endif\n \tif (image_type == PHP_GDIMG_TYPE_GD2PART) {\n-\t\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"sllll\", &file, &file_len, &srcx, &srcy, &width, &height) == FAILURE) {\n+\t\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"pllll\", &file, &file_len, &srcx, &srcy, &width, &height) == FAILURE) {\n \t\t\treturn;\n \t\t}\n \t\tif (width < 1 || height < 1) {\n@@ -18,7 +18,7 @@\n \t\t\tRETURN_FALSE;\n \t\t}\n \t} else {\n-\t\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s\", &file, &file_len) == FAILURE) {\n+\t\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"p\", &file, &file_len) == FAILURE) {\n \t\t\treturn;\n \t\t}\n \t}",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"sllll\", &file, &file_len, &srcx, &srcy, &width, &height) == FAILURE) {",
                "\t\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s\", &file, &file_len) == FAILURE) {"
            ],
            "added_lines": [
                "\t\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"pllll\", &file, &file_len, &srcx, &srcy, &width, &height) == FAILURE) {",
                "\t\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"p\", &file, &file_len) == FAILURE) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-3411",
        "func_name": "php/php-src/dom_load_html",
        "description": "PHP before 5.4.40, 5.5.x before 5.5.24, and 5.6.x before 5.6.8 does not ensure that pathnames lack %00 sequences, which might allow remote attackers to read or write to arbitrary files via crafted input to an application that calls (1) a DOMDocument load method, (2) the xmlwriter_open_uri function, (3) the finfo_file function, or (4) the hash_hmac_file function, as demonstrated by a filename\\0.xml attack that bypasses an intended configuration in which client users may read only .xml files.",
        "git_url": "https://github.com/php/php-src/commit/4435b9142ff9813845d5c97ab29a5d637bedb257",
        "commit_title": "Fixed bug #69353 (Missing null byte checks for paths in various PHP extensions)",
        "commit_text": "",
        "func_before": "static void dom_load_html(INTERNAL_FUNCTION_PARAMETERS, int mode) /* {{{ */\n{\n\tzval *id;\n\txmlDoc *docp = NULL, *newdoc;\n\tdom_object *intern;\n\tdom_doc_propsptr doc_prop;\n\tchar *source;\n\tint source_len, refcount, ret;\n\tlong options = 0;\n\thtmlParserCtxtPtr ctxt;\n\t\n\tid = getThis();\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s|l\", &source, &source_len, &options) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (!source_len) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Empty string supplied as input\");\n\t\tRETURN_FALSE;\n\t}\n\n\tif (mode == DOM_LOAD_FILE) {\n\t\tctxt = htmlCreateFileParserCtxt(source, NULL);\n\t} else {\n\t\tsource_len = xmlStrlen(source);\n\t\tctxt = htmlCreateMemoryParserCtxt(source, source_len);\n\t}\n\n\tif (!ctxt) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (options) {\n\t\thtmlCtxtUseOptions(ctxt, options);\n\t}\n\n\tctxt->vctxt.error = php_libxml_ctx_error;\n\tctxt->vctxt.warning = php_libxml_ctx_warning;\n\tif (ctxt->sax != NULL) {\n\t\tctxt->sax->error = php_libxml_ctx_error;\n\t\tctxt->sax->warning = php_libxml_ctx_warning;\n\t}\n\thtmlParseDocument(ctxt);\n\tnewdoc = ctxt->myDoc;\n\thtmlFreeParserCtxt(ctxt);\n\t\n\tif (!newdoc)\n\t\tRETURN_FALSE;\n\n\tif (id != NULL && instanceof_function(Z_OBJCE_P(id), dom_document_class_entry TSRMLS_CC)) {\n\t\tintern = (dom_object *)zend_object_store_get_object(id TSRMLS_CC);\n\t\tif (intern != NULL) {\n\t\t\tdocp = (xmlDocPtr) dom_object_get_node(intern);\n\t\t\tdoc_prop = NULL;\n\t\t\tif (docp != NULL) {\n\t\t\t\tphp_libxml_decrement_node_ptr((php_libxml_node_object *) intern TSRMLS_CC);\n\t\t\t\tdoc_prop = intern->document->doc_props;\n\t\t\t\tintern->document->doc_props = NULL;\n\t\t\t\trefcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern TSRMLS_CC);\n\t\t\t\tif (refcount != 0) {\n\t\t\t\t\tdocp->_private = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tintern->document = NULL;\n\t\t\tif (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, newdoc TSRMLS_CC) == -1) {\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t\tintern->document->doc_props = doc_prop;\n\t\t}\n\n\t\tphp_libxml_increment_node_ptr((php_libxml_node_object *)intern, (xmlNodePtr)newdoc, (void *)intern TSRMLS_CC);\n\n\t\tRETURN_TRUE;\n\t} else {\n\t\tDOM_RET_OBJ((xmlNodePtr) newdoc, &ret, NULL);\n\t}\n}",
        "func": "static void dom_load_html(INTERNAL_FUNCTION_PARAMETERS, int mode) /* {{{ */\n{\n\tzval *id;\n\txmlDoc *docp = NULL, *newdoc;\n\tdom_object *intern;\n\tdom_doc_propsptr doc_prop;\n\tchar *source;\n\tint source_len, refcount, ret;\n\tlong options = 0;\n\thtmlParserCtxtPtr ctxt;\n\t\n\tid = getThis();\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"p|l\", &source, &source_len, &options) == FAILURE) {\n\t\treturn;\n\t}\n\n\tif (!source_len) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Empty string supplied as input\");\n\t\tRETURN_FALSE;\n\t}\n\n\tif (mode == DOM_LOAD_FILE) {\n\t\tctxt = htmlCreateFileParserCtxt(source, NULL);\n\t} else {\n\t\tsource_len = xmlStrlen(source);\n\t\tctxt = htmlCreateMemoryParserCtxt(source, source_len);\n\t}\n\n\tif (!ctxt) {\n\t\tRETURN_FALSE;\n\t}\n\n\tif (options) {\n\t\thtmlCtxtUseOptions(ctxt, options);\n\t}\n\n\tctxt->vctxt.error = php_libxml_ctx_error;\n\tctxt->vctxt.warning = php_libxml_ctx_warning;\n\tif (ctxt->sax != NULL) {\n\t\tctxt->sax->error = php_libxml_ctx_error;\n\t\tctxt->sax->warning = php_libxml_ctx_warning;\n\t}\n\thtmlParseDocument(ctxt);\n\tnewdoc = ctxt->myDoc;\n\thtmlFreeParserCtxt(ctxt);\n\t\n\tif (!newdoc)\n\t\tRETURN_FALSE;\n\n\tif (id != NULL && instanceof_function(Z_OBJCE_P(id), dom_document_class_entry TSRMLS_CC)) {\n\t\tintern = (dom_object *)zend_object_store_get_object(id TSRMLS_CC);\n\t\tif (intern != NULL) {\n\t\t\tdocp = (xmlDocPtr) dom_object_get_node(intern);\n\t\t\tdoc_prop = NULL;\n\t\t\tif (docp != NULL) {\n\t\t\t\tphp_libxml_decrement_node_ptr((php_libxml_node_object *) intern TSRMLS_CC);\n\t\t\t\tdoc_prop = intern->document->doc_props;\n\t\t\t\tintern->document->doc_props = NULL;\n\t\t\t\trefcount = php_libxml_decrement_doc_ref((php_libxml_node_object *)intern TSRMLS_CC);\n\t\t\t\tif (refcount != 0) {\n\t\t\t\t\tdocp->_private = NULL;\n\t\t\t\t}\n\t\t\t}\n\t\t\tintern->document = NULL;\n\t\t\tif (php_libxml_increment_doc_ref((php_libxml_node_object *)intern, newdoc TSRMLS_CC) == -1) {\n\t\t\t\tRETURN_FALSE;\n\t\t\t}\n\t\t\tintern->document->doc_props = doc_prop;\n\t\t}\n\n\t\tphp_libxml_increment_node_ptr((php_libxml_node_object *)intern, (xmlNodePtr)newdoc, (void *)intern TSRMLS_CC);\n\n\t\tRETURN_TRUE;\n\t} else {\n\t\tDOM_RET_OBJ((xmlNodePtr) newdoc, &ret, NULL);\n\t}\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -11,7 +11,7 @@\n \t\n \tid = getThis();\n \n-\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s|l\", &source, &source_len, &options) == FAILURE) {\n+\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"p|l\", &source, &source_len, &options) == FAILURE) {\n \t\treturn;\n \t}\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s|l\", &source, &source_len, &options) == FAILURE) {"
            ],
            "added_lines": [
                "\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"p|l\", &source, &source_len, &options) == FAILURE) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-3411",
        "func_name": "php/php-src/dom_document_parser",
        "description": "PHP before 5.4.40, 5.5.x before 5.5.24, and 5.6.x before 5.6.8 does not ensure that pathnames lack %00 sequences, which might allow remote attackers to read or write to arbitrary files via crafted input to an application that calls (1) a DOMDocument load method, (2) the xmlwriter_open_uri function, (3) the finfo_file function, or (4) the hash_hmac_file function, as demonstrated by a filename\\0.xml attack that bypasses an intended configuration in which client users may read only .xml files.",
        "git_url": "https://github.com/php/php-src/commit/4435b9142ff9813845d5c97ab29a5d637bedb257",
        "commit_title": "Fixed bug #69353 (Missing null byte checks for paths in various PHP extensions)",
        "commit_text": "",
        "func_before": "static xmlDocPtr dom_document_parser(zval *id, int mode, char *source, int source_len, int options TSRMLS_DC) /* {{{ */\n{\n    xmlDocPtr ret;\n    xmlParserCtxtPtr ctxt = NULL;\n\tdom_doc_propsptr doc_props;\n\tdom_object *intern;\n\tphp_libxml_ref_obj *document = NULL;\n\tint validate, recover, resolve_externals, keep_blanks, substitute_ent;\n\tint resolved_path_len;\n\tint old_error_reporting = 0;\n\tchar *directory=NULL, resolved_path[MAXPATHLEN];\n\n\tif (id != NULL) {\n\t\tintern = (dom_object *)zend_object_store_get_object(id TSRMLS_CC);\n\t\tdocument = intern->document;\n\t}\n\n\tdoc_props = dom_get_doc_props(document);\n\tvalidate = doc_props->validateonparse;\n\tresolve_externals = doc_props->resolveexternals;\n\tkeep_blanks = doc_props->preservewhitespace;\n\tsubstitute_ent = doc_props->substituteentities;\n\trecover = doc_props->recover;\n\n\tif (document == NULL) {\n\t\tefree(doc_props);\n\t}\n\n\txmlInitParser();\n\n\tif (mode == DOM_LOAD_FILE) {\n\t\tchar *file_dest = _dom_get_valid_file_path(source, resolved_path, MAXPATHLEN  TSRMLS_CC);\n\t\tif (file_dest) {\n\t\t\tctxt = xmlCreateFileParserCtxt(file_dest);\n\t\t}\n\t\t\n\t} else {\n\t\tctxt = xmlCreateMemoryParserCtxt(source, source_len);\n\t}\n\n\tif (ctxt == NULL) {\n\t\treturn(NULL);\n\t}\n\n\t/* If loading from memory, we need to set the base directory for the document */\n\tif (mode != DOM_LOAD_FILE) {\n#if HAVE_GETCWD\n\t\tdirectory = VCWD_GETCWD(resolved_path, MAXPATHLEN);\n#elif HAVE_GETWD\n\t\tdirectory = VCWD_GETWD(resolved_path);\n#endif\n\t\tif (directory) {\n\t\t\tif(ctxt->directory != NULL) {\n\t\t\t\txmlFree((char *) ctxt->directory);\n\t\t\t}\n\t\t\tresolved_path_len = strlen(resolved_path);\n\t\t\tif (resolved_path[resolved_path_len - 1] != DEFAULT_SLASH) {\n\t\t\t\tresolved_path[resolved_path_len] = DEFAULT_SLASH;\n\t\t\t\tresolved_path[++resolved_path_len] = '\\0';\n\t\t\t}\n\t\t\tctxt->directory = (char *) xmlCanonicPath((const xmlChar *) resolved_path);\n\t\t}\n\t}\n\n\tctxt->vctxt.error = php_libxml_ctx_error;\n\tctxt->vctxt.warning = php_libxml_ctx_warning;\n\n\tif (ctxt->sax != NULL) {\n\t\tctxt->sax->error = php_libxml_ctx_error;\n\t\tctxt->sax->warning = php_libxml_ctx_warning;\n\t}\n\n\tif (validate && ! (options & XML_PARSE_DTDVALID)) {\n\t\toptions |= XML_PARSE_DTDVALID;\n\t}\n\tif (resolve_externals && ! (options & XML_PARSE_DTDATTR)) {\n\t\toptions |= XML_PARSE_DTDATTR;\n\t}\n\tif (substitute_ent && ! (options & XML_PARSE_NOENT)) {\n\t\toptions |= XML_PARSE_NOENT;\n\t}\n\tif (keep_blanks == 0 && ! (options & XML_PARSE_NOBLANKS)) {\n\t\toptions |= XML_PARSE_NOBLANKS;\n\t}\n\n\txmlCtxtUseOptions(ctxt, options);\n\n\tctxt->recovery = recover;\n\tif (recover) {\n\t\told_error_reporting = EG(error_reporting);\n\t\tEG(error_reporting) = old_error_reporting | E_WARNING;\n\t}\n\n\txmlParseDocument(ctxt);\n\n\tif (ctxt->wellFormed || recover) {\n\t\tret = ctxt->myDoc;\n\t\tif (ctxt->recovery) {\n\t\t\tEG(error_reporting) = old_error_reporting;\n\t\t}\n\t\t/* If loading from memory, set the base reference uri for the document */\n\t\tif (ret && ret->URL == NULL && ctxt->directory != NULL) {\n\t\t\tret->URL = xmlStrdup(ctxt->directory);\n\t\t}\n\t} else {\n\t\tret = NULL;\n\t\txmlFreeDoc(ctxt->myDoc);\n\t\tctxt->myDoc = NULL;\n\t}\n\n\txmlFreeParserCtxt(ctxt);\n\n\treturn(ret);\n}",
        "func": "static xmlDocPtr dom_document_parser(zval *id, int mode, char *source, int source_len, int options TSRMLS_DC) /* {{{ */\n{\n    xmlDocPtr ret;\n    xmlParserCtxtPtr ctxt = NULL;\n\tdom_doc_propsptr doc_props;\n\tdom_object *intern;\n\tphp_libxml_ref_obj *document = NULL;\n\tint validate, recover, resolve_externals, keep_blanks, substitute_ent;\n\tint resolved_path_len;\n\tint old_error_reporting = 0;\n\tchar *directory=NULL, resolved_path[MAXPATHLEN];\n\n\tif (id != NULL) {\n\t\tintern = (dom_object *)zend_object_store_get_object(id TSRMLS_CC);\n\t\tdocument = intern->document;\n\t}\n\n\tdoc_props = dom_get_doc_props(document);\n\tvalidate = doc_props->validateonparse;\n\tresolve_externals = doc_props->resolveexternals;\n\tkeep_blanks = doc_props->preservewhitespace;\n\tsubstitute_ent = doc_props->substituteentities;\n\trecover = doc_props->recover;\n\n\tif (document == NULL) {\n\t\tefree(doc_props);\n\t}\n\n\txmlInitParser();\n\n\tif (mode == DOM_LOAD_FILE) {\n\t\tif (CHECK_NULL_PATH(source, source_len)) {\n\t\t\treturn NULL;\n\t\t}\n\t\tchar *file_dest = _dom_get_valid_file_path(source, resolved_path, MAXPATHLEN  TSRMLS_CC);\n\t\tif (file_dest) {\n\t\t\tctxt = xmlCreateFileParserCtxt(file_dest);\n\t\t}\n\t\t\n\t} else {\n\t\tctxt = xmlCreateMemoryParserCtxt(source, source_len);\n\t}\n\n\tif (ctxt == NULL) {\n\t\treturn(NULL);\n\t}\n\n\t/* If loading from memory, we need to set the base directory for the document */\n\tif (mode != DOM_LOAD_FILE) {\n#if HAVE_GETCWD\n\t\tdirectory = VCWD_GETCWD(resolved_path, MAXPATHLEN);\n#elif HAVE_GETWD\n\t\tdirectory = VCWD_GETWD(resolved_path);\n#endif\n\t\tif (directory) {\n\t\t\tif(ctxt->directory != NULL) {\n\t\t\t\txmlFree((char *) ctxt->directory);\n\t\t\t}\n\t\t\tresolved_path_len = strlen(resolved_path);\n\t\t\tif (resolved_path[resolved_path_len - 1] != DEFAULT_SLASH) {\n\t\t\t\tresolved_path[resolved_path_len] = DEFAULT_SLASH;\n\t\t\t\tresolved_path[++resolved_path_len] = '\\0';\n\t\t\t}\n\t\t\tctxt->directory = (char *) xmlCanonicPath((const xmlChar *) resolved_path);\n\t\t}\n\t}\n\n\tctxt->vctxt.error = php_libxml_ctx_error;\n\tctxt->vctxt.warning = php_libxml_ctx_warning;\n\n\tif (ctxt->sax != NULL) {\n\t\tctxt->sax->error = php_libxml_ctx_error;\n\t\tctxt->sax->warning = php_libxml_ctx_warning;\n\t}\n\n\tif (validate && ! (options & XML_PARSE_DTDVALID)) {\n\t\toptions |= XML_PARSE_DTDVALID;\n\t}\n\tif (resolve_externals && ! (options & XML_PARSE_DTDATTR)) {\n\t\toptions |= XML_PARSE_DTDATTR;\n\t}\n\tif (substitute_ent && ! (options & XML_PARSE_NOENT)) {\n\t\toptions |= XML_PARSE_NOENT;\n\t}\n\tif (keep_blanks == 0 && ! (options & XML_PARSE_NOBLANKS)) {\n\t\toptions |= XML_PARSE_NOBLANKS;\n\t}\n\n\txmlCtxtUseOptions(ctxt, options);\n\n\tctxt->recovery = recover;\n\tif (recover) {\n\t\told_error_reporting = EG(error_reporting);\n\t\tEG(error_reporting) = old_error_reporting | E_WARNING;\n\t}\n\n\txmlParseDocument(ctxt);\n\n\tif (ctxt->wellFormed || recover) {\n\t\tret = ctxt->myDoc;\n\t\tif (ctxt->recovery) {\n\t\t\tEG(error_reporting) = old_error_reporting;\n\t\t}\n\t\t/* If loading from memory, set the base reference uri for the document */\n\t\tif (ret && ret->URL == NULL && ctxt->directory != NULL) {\n\t\t\tret->URL = xmlStrdup(ctxt->directory);\n\t\t}\n\t} else {\n\t\tret = NULL;\n\t\txmlFreeDoc(ctxt->myDoc);\n\t\tctxt->myDoc = NULL;\n\t}\n\n\txmlFreeParserCtxt(ctxt);\n\n\treturn(ret);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -29,6 +29,9 @@\n \txmlInitParser();\n \n \tif (mode == DOM_LOAD_FILE) {\n+\t\tif (CHECK_NULL_PATH(source, source_len)) {\n+\t\t\treturn NULL;\n+\t\t}\n \t\tchar *file_dest = _dom_get_valid_file_path(source, resolved_path, MAXPATHLEN  TSRMLS_CC);\n \t\tif (file_dest) {\n \t\t\tctxt = xmlCreateFileParserCtxt(file_dest);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\tif (CHECK_NULL_PATH(source, source_len)) {",
                "\t\t\treturn NULL;",
                "\t\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-3411",
        "func_name": "php/php-src/php_hash_do_hash_hmac",
        "description": "PHP before 5.4.40, 5.5.x before 5.5.24, and 5.6.x before 5.6.8 does not ensure that pathnames lack %00 sequences, which might allow remote attackers to read or write to arbitrary files via crafted input to an application that calls (1) a DOMDocument load method, (2) the xmlwriter_open_uri function, (3) the finfo_file function, or (4) the hash_hmac_file function, as demonstrated by a filename\\0.xml attack that bypasses an intended configuration in which client users may read only .xml files.",
        "git_url": "https://github.com/php/php-src/commit/4435b9142ff9813845d5c97ab29a5d637bedb257",
        "commit_title": "Fixed bug #69353 (Missing null byte checks for paths in various PHP extensions)",
        "commit_text": "",
        "func_before": "static void php_hash_do_hash_hmac(INTERNAL_FUNCTION_PARAMETERS, int isfilename, zend_bool raw_output_default) /* {{{ */\n{\n\tchar *algo, *data, *digest, *key, *K;\n\tint algo_len, data_len, key_len, i;\n\tzend_bool raw_output = raw_output_default;\n\tconst php_hash_ops *ops;\n\tvoid *context;\n\tphp_stream *stream = NULL;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"sss|b\", &algo, &algo_len, &data, &data_len, \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  &key, &key_len, &raw_output) == FAILURE) {\n\t\treturn;\n\t}\n\n\tops = php_hash_fetch_ops(algo, algo_len);\n\tif (!ops) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unknown hashing algorithm: %s\", algo);\n\t\tRETURN_FALSE;\n\t}\n\tif (isfilename) {\n\t\tstream = php_stream_open_wrapper_ex(data, \"rb\", REPORT_ERRORS, NULL, DEFAULT_CONTEXT);\n\t\tif (!stream) {\n\t\t\t/* Stream will report errors opening file */\n\t\t\tRETURN_FALSE;\n\t\t}\n\t}\n\n\tcontext = emalloc(ops->context_size);\n\tops->hash_init(context);\n\n\tK = emalloc(ops->block_size);\n\tmemset(K, 0, ops->block_size);\n\n\tif (key_len > ops->block_size) {\n\t\t/* Reduce the key first */\n\t\tops->hash_update(context, (unsigned char *) key, key_len);\n\t\tops->hash_final((unsigned char *) K, context);\n\t\t/* Make the context ready to start over */\n\t\tops->hash_init(context);\n\t} else {\n\t\tmemcpy(K, key, key_len);\n\t}\n\t\t\t\n\t/* XOR ipad */\n\tfor(i=0; i < ops->block_size; i++) {\n\t\tK[i] ^= 0x36;\n\t}\n\tops->hash_update(context, (unsigned char *) K, ops->block_size);\n\n\tif (isfilename) {\n\t\tchar buf[1024];\n\t\tint n;\n\n\t\twhile ((n = php_stream_read(stream, buf, sizeof(buf))) > 0) {\n\t\t\tops->hash_update(context, (unsigned char *) buf, n);\n\t\t}\n\t\tphp_stream_close(stream);\n\t} else {\n\t\tops->hash_update(context, (unsigned char *) data, data_len);\n\t}\n\n\tdigest = emalloc(ops->digest_size + 1);\n\tops->hash_final((unsigned char *) digest, context);\n\n\t/* Convert K to opad -- 0x6A = 0x36 ^ 0x5C */\n\tfor(i=0; i < ops->block_size; i++) {\n\t\tK[i] ^= 0x6A;\n\t}\n\n\t/* Feed this result into the outter hash */\n\tops->hash_init(context);\n\tops->hash_update(context, (unsigned char *) K, ops->block_size);\n\tops->hash_update(context, (unsigned char *) digest, ops->digest_size);\n\tops->hash_final((unsigned char *) digest, context);\n\n\t/* Zero the key */\n\tmemset(K, 0, ops->block_size);\n\tefree(K);\n\tefree(context);\n\n\tif (raw_output) {\n\t\tdigest[ops->digest_size] = 0;\n\t\tRETURN_STRINGL(digest, ops->digest_size, 0);\n\t} else {\n\t\tchar *hex_digest = safe_emalloc(ops->digest_size, 2, 1);\n\n\t\tphp_hash_bin2hex(hex_digest, (unsigned char *) digest, ops->digest_size);\n\t\thex_digest[2 * ops->digest_size] = 0;\n\t\tefree(digest);\n\t\tRETURN_STRINGL(hex_digest, 2 * ops->digest_size, 0);\n\t}\n}",
        "func": "static void php_hash_do_hash_hmac(INTERNAL_FUNCTION_PARAMETERS, int isfilename, zend_bool raw_output_default) /* {{{ */\n{\n\tchar *algo, *data, *digest, *key, *K;\n\tint algo_len, data_len, key_len, i;\n\tzend_bool raw_output = raw_output_default;\n\tconst php_hash_ops *ops;\n\tvoid *context;\n\tphp_stream *stream = NULL;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"sss|b\", &algo, &algo_len, &data, &data_len, \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  &key, &key_len, &raw_output) == FAILURE) {\n\t\treturn;\n\t}\n\n\tops = php_hash_fetch_ops(algo, algo_len);\n\tif (!ops) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unknown hashing algorithm: %s\", algo);\n\t\tRETURN_FALSE;\n\t}\n\tif (isfilename) {\n\t\tif (CHECK_NULL_PATH(data, data_len)) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Invalid path\");\n\t\t\tRETURN_FALSE;\n\t\t}\n\t\tstream = php_stream_open_wrapper_ex(data, \"rb\", REPORT_ERRORS, NULL, DEFAULT_CONTEXT);\n\t\tif (!stream) {\n\t\t\t/* Stream will report errors opening file */\n\t\t\tRETURN_FALSE;\n\t\t}\n\t}\n\n\tcontext = emalloc(ops->context_size);\n\tops->hash_init(context);\n\n\tK = emalloc(ops->block_size);\n\tmemset(K, 0, ops->block_size);\n\n\tif (key_len > ops->block_size) {\n\t\t/* Reduce the key first */\n\t\tops->hash_update(context, (unsigned char *) key, key_len);\n\t\tops->hash_final((unsigned char *) K, context);\n\t\t/* Make the context ready to start over */\n\t\tops->hash_init(context);\n\t} else {\n\t\tmemcpy(K, key, key_len);\n\t}\n\t\t\t\n\t/* XOR ipad */\n\tfor(i=0; i < ops->block_size; i++) {\n\t\tK[i] ^= 0x36;\n\t}\n\tops->hash_update(context, (unsigned char *) K, ops->block_size);\n\n\tif (isfilename) {\n\t\tchar buf[1024];\n\t\tint n;\n\n\t\twhile ((n = php_stream_read(stream, buf, sizeof(buf))) > 0) {\n\t\t\tops->hash_update(context, (unsigned char *) buf, n);\n\t\t}\n\t\tphp_stream_close(stream);\n\t} else {\n\t\tops->hash_update(context, (unsigned char *) data, data_len);\n\t}\n\n\tdigest = emalloc(ops->digest_size + 1);\n\tops->hash_final((unsigned char *) digest, context);\n\n\t/* Convert K to opad -- 0x6A = 0x36 ^ 0x5C */\n\tfor(i=0; i < ops->block_size; i++) {\n\t\tK[i] ^= 0x6A;\n\t}\n\n\t/* Feed this result into the outter hash */\n\tops->hash_init(context);\n\tops->hash_update(context, (unsigned char *) K, ops->block_size);\n\tops->hash_update(context, (unsigned char *) digest, ops->digest_size);\n\tops->hash_final((unsigned char *) digest, context);\n\n\t/* Zero the key */\n\tmemset(K, 0, ops->block_size);\n\tefree(K);\n\tefree(context);\n\n\tif (raw_output) {\n\t\tdigest[ops->digest_size] = 0;\n\t\tRETURN_STRINGL(digest, ops->digest_size, 0);\n\t} else {\n\t\tchar *hex_digest = safe_emalloc(ops->digest_size, 2, 1);\n\n\t\tphp_hash_bin2hex(hex_digest, (unsigned char *) digest, ops->digest_size);\n\t\thex_digest[2 * ops->digest_size] = 0;\n\t\tefree(digest);\n\t\tRETURN_STRINGL(hex_digest, 2 * ops->digest_size, 0);\n\t}\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -18,6 +18,10 @@\n \t\tRETURN_FALSE;\n \t}\n \tif (isfilename) {\n+\t\tif (CHECK_NULL_PATH(data, data_len)) {\n+\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Invalid path\");\n+\t\t\tRETURN_FALSE;\n+\t\t}\n \t\tstream = php_stream_open_wrapper_ex(data, \"rb\", REPORT_ERRORS, NULL, DEFAULT_CONTEXT);\n \t\tif (!stream) {\n \t\t\t/* Stream will report errors opening file */",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\tif (CHECK_NULL_PATH(data, data_len)) {",
                "\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Invalid path\");",
                "\t\t\tRETURN_FALSE;",
                "\t\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-3411",
        "func_name": "php/php-src/php_hash_do_hash",
        "description": "PHP before 5.4.40, 5.5.x before 5.5.24, and 5.6.x before 5.6.8 does not ensure that pathnames lack %00 sequences, which might allow remote attackers to read or write to arbitrary files via crafted input to an application that calls (1) a DOMDocument load method, (2) the xmlwriter_open_uri function, (3) the finfo_file function, or (4) the hash_hmac_file function, as demonstrated by a filename\\0.xml attack that bypasses an intended configuration in which client users may read only .xml files.",
        "git_url": "https://github.com/php/php-src/commit/4435b9142ff9813845d5c97ab29a5d637bedb257",
        "commit_title": "Fixed bug #69353 (Missing null byte checks for paths in various PHP extensions)",
        "commit_text": "",
        "func_before": "static void php_hash_do_hash(INTERNAL_FUNCTION_PARAMETERS, int isfilename, zend_bool raw_output_default) /* {{{ */\n{\n\tchar *algo, *data, *digest;\n\tint algo_len, data_len;\n\tzend_bool raw_output = raw_output_default;\n\tconst php_hash_ops *ops;\n\tvoid *context;\n\tphp_stream *stream = NULL;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"ss|b\", &algo, &algo_len, &data, &data_len, &raw_output) == FAILURE) {\n\t\treturn;\n\t}\n\n\tops = php_hash_fetch_ops(algo, algo_len);\n\tif (!ops) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unknown hashing algorithm: %s\", algo);\n\t\tRETURN_FALSE;\n\t}\n\tif (isfilename) {\n\t\tif (CHECK_NULL_PATH(data, data_len)) {\n\t\t\tRETURN_FALSE;\n\t\t}\n\t\tstream = php_stream_open_wrapper_ex(data, \"rb\", REPORT_ERRORS, NULL, DEFAULT_CONTEXT);\n\t\tif (!stream) {\n\t\t\t/* Stream will report errors opening file */\n\t\t\tRETURN_FALSE;\n\t\t}\n\t}\n\n\tcontext = emalloc(ops->context_size);\n\tops->hash_init(context);\n\n\tif (isfilename) {\n\t\tchar buf[1024];\n\t\tint n;\n\n\t\twhile ((n = php_stream_read(stream, buf, sizeof(buf))) > 0) {\n\t\t\tops->hash_update(context, (unsigned char *) buf, n);\n\t\t}\n\t\tphp_stream_close(stream);\n\t} else {\n\t\tops->hash_update(context, (unsigned char *) data, data_len);\n\t}\n\n\tdigest = emalloc(ops->digest_size + 1);\n\tops->hash_final((unsigned char *) digest, context);\n\tefree(context);\n\n\tif (raw_output) {\n\t\tdigest[ops->digest_size] = 0;\n\t\tRETURN_STRINGL(digest, ops->digest_size, 0);\n\t} else {\n\t\tchar *hex_digest = safe_emalloc(ops->digest_size, 2, 1);\n\n\t\tphp_hash_bin2hex(hex_digest, (unsigned char *) digest, ops->digest_size);\n\t\thex_digest[2 * ops->digest_size] = 0;\n\t\tefree(digest);\n\t\tRETURN_STRINGL(hex_digest, 2 * ops->digest_size, 0);\n\t}\n}",
        "func": "static void php_hash_do_hash(INTERNAL_FUNCTION_PARAMETERS, int isfilename, zend_bool raw_output_default) /* {{{ */\n{\n\tchar *algo, *data, *digest;\n\tint algo_len, data_len;\n\tzend_bool raw_output = raw_output_default;\n\tconst php_hash_ops *ops;\n\tvoid *context;\n\tphp_stream *stream = NULL;\n\n\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"ss|b\", &algo, &algo_len, &data, &data_len, &raw_output) == FAILURE) {\n\t\treturn;\n\t}\n\n\tops = php_hash_fetch_ops(algo, algo_len);\n\tif (!ops) {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Unknown hashing algorithm: %s\", algo);\n\t\tRETURN_FALSE;\n\t}\n\tif (isfilename) {\n\t\tif (CHECK_NULL_PATH(data, data_len)) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Invalid path\");\n\t\t\tRETURN_FALSE;\n\t\t}\n\t\tstream = php_stream_open_wrapper_ex(data, \"rb\", REPORT_ERRORS, NULL, DEFAULT_CONTEXT);\n\t\tif (!stream) {\n\t\t\t/* Stream will report errors opening file */\n\t\t\tRETURN_FALSE;\n\t\t}\n\t}\n\n\tcontext = emalloc(ops->context_size);\n\tops->hash_init(context);\n\n\tif (isfilename) {\n\t\tchar buf[1024];\n\t\tint n;\n\n\t\twhile ((n = php_stream_read(stream, buf, sizeof(buf))) > 0) {\n\t\t\tops->hash_update(context, (unsigned char *) buf, n);\n\t\t}\n\t\tphp_stream_close(stream);\n\t} else {\n\t\tops->hash_update(context, (unsigned char *) data, data_len);\n\t}\n\n\tdigest = emalloc(ops->digest_size + 1);\n\tops->hash_final((unsigned char *) digest, context);\n\tefree(context);\n\n\tif (raw_output) {\n\t\tdigest[ops->digest_size] = 0;\n\t\tRETURN_STRINGL(digest, ops->digest_size, 0);\n\t} else {\n\t\tchar *hex_digest = safe_emalloc(ops->digest_size, 2, 1);\n\n\t\tphp_hash_bin2hex(hex_digest, (unsigned char *) digest, ops->digest_size);\n\t\thex_digest[2 * ops->digest_size] = 0;\n\t\tefree(digest);\n\t\tRETURN_STRINGL(hex_digest, 2 * ops->digest_size, 0);\n\t}\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -18,6 +18,7 @@\n \t}\n \tif (isfilename) {\n \t\tif (CHECK_NULL_PATH(data, data_len)) {\n+\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Invalid path\");\n \t\t\tRETURN_FALSE;\n \t\t}\n \t\tstream = php_stream_open_wrapper_ex(data, \"rb\", REPORT_ERRORS, NULL, DEFAULT_CONTEXT);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Invalid path\");"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-3411",
        "func_name": "php/php-src/_php_finfo_get_type",
        "description": "PHP before 5.4.40, 5.5.x before 5.5.24, and 5.6.x before 5.6.8 does not ensure that pathnames lack %00 sequences, which might allow remote attackers to read or write to arbitrary files via crafted input to an application that calls (1) a DOMDocument load method, (2) the xmlwriter_open_uri function, (3) the finfo_file function, or (4) the hash_hmac_file function, as demonstrated by a filename\\0.xml attack that bypasses an intended configuration in which client users may read only .xml files.",
        "git_url": "https://github.com/php/php-src/commit/4435b9142ff9813845d5c97ab29a5d637bedb257",
        "commit_title": "Fixed bug #69353 (Missing null byte checks for paths in various PHP extensions)",
        "commit_text": "",
        "func_before": "static void _php_finfo_get_type(INTERNAL_FUNCTION_PARAMETERS, int mode, int mimetype_emu) /* {{{ */\n{\n\tlong options = 0;\n\tchar *ret_val = NULL, *buffer = NULL;\n\tint buffer_len;\n\tstruct php_fileinfo *finfo = NULL;\n\tzval *zfinfo, *zcontext = NULL;\n\tzval *what;\n\tchar mime_directory[] = \"directory\";\n\n\tstruct magic_set *magic = NULL;\n\tFILEINFO_DECLARE_INIT_OBJECT(object)\n\n\tif (mimetype_emu) {\n\n\t\t/* mime_content_type(..) emulation */\n\t\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"z\", &what) == FAILURE) {\n\t\t\treturn;\n\t\t}\n\n\t\tswitch (Z_TYPE_P(what)) {\n\t\t\tcase IS_STRING:\n\t\t\t\tbuffer = Z_STRVAL_P(what);\n\t\t\t\tbuffer_len = Z_STRLEN_P(what);\n\t\t\t\tmode = FILEINFO_MODE_FILE;\n\t\t\t\tbreak;\n\n\t\t\tcase IS_RESOURCE:\n\t\t\t\tmode = FILEINFO_MODE_STREAM;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Can only process string or stream arguments\");\n\t\t\t\tRETURN_FALSE;\n\t\t}\n\n\t\tmagic = magic_open(MAGIC_MIME_TYPE);\n\t\tif (magic_load(magic, NULL) == -1) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Failed to load magic database.\");\n\t\t\tgoto common;\n\t\t}\n\t} else if (object) {\n\t\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s|lr\", &buffer, &buffer_len, &options, &zcontext) == FAILURE) {\n\t\t\tRETURN_FALSE;\n\t\t}\n\t\tFILEINFO_FROM_OBJECT(finfo, object);\n\t\tmagic = finfo->magic;\n\t} else {\n\t\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rs|lr\", &zfinfo, &buffer, &buffer_len, &options, &zcontext) == FAILURE) {\n\t\t\tRETURN_FALSE;\n\t\t}\n\t\tZEND_FETCH_RESOURCE(finfo, struct php_fileinfo *, &zfinfo, -1, \"file_info\", le_fileinfo);\n\t\tmagic = finfo->magic;\n\t}\t\n\n\t/* Set options for the current file/buffer. */\n\tif (options) {\n\t\tFINFO_SET_OPTION(magic, options)\n\t}\n\n\tswitch (mode) {\n\t\tcase FILEINFO_MODE_BUFFER:\n\t\t{\n\t\t\tret_val = (char *) magic_buffer(magic, buffer, buffer_len);\n\t\t\tbreak;\n\t\t}\n\n\t\tcase FILEINFO_MODE_STREAM:\n\t\t{\n\t\t\t\tphp_stream *stream;\n\t\t\t\toff_t streampos;\n\n\t\t\t\tphp_stream_from_zval_no_verify(stream, &what);\n\t\t\t\tif (!stream) {\n\t\t\t\t\tgoto common;\n\t\t\t\t}\n\n\t\t\t\tstreampos = php_stream_tell(stream); /* remember stream position for restoration */\n\t\t\t\tphp_stream_seek(stream, 0, SEEK_SET);\n\n\t\t\t\tret_val = (char *) magic_stream(magic, stream);\n\n\t\t\t\tphp_stream_seek(stream, streampos, SEEK_SET);\n\t\t\t\tbreak;\n\t\t}\n\n\t\tcase FILEINFO_MODE_FILE:\n\t\t{\n\t\t\t/* determine if the file is a local file or remote URL */\n\t\t\tchar *tmp2;\n\t\t\tphp_stream_wrapper *wrap;\n\t\t\tphp_stream_statbuf ssb;\n\n\t\t\tif (buffer == NULL || !*buffer) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Empty filename or path\");\n\t\t\t\tRETVAL_FALSE;\n\t\t\t\tgoto clean;\n\t\t\t}\n\n\t\t\twrap = php_stream_locate_url_wrapper(buffer, &tmp2, 0 TSRMLS_CC);\n\n\t\t\tif (wrap) {\n\t\t\t\tphp_stream *stream;\n\t\t\t\tphp_stream_context *context = php_stream_context_from_zval(zcontext, 0);\n\n#ifdef PHP_WIN32\n\t\t\t\tif (php_stream_stat_path_ex(buffer, 0, &ssb, context) == SUCCESS) {\n\t\t\t\t\tif (ssb.sb.st_mode & S_IFDIR) {\n\t\t\t\t\t\tret_val = mime_directory;\n\t\t\t\t\t\tgoto common;\n\t\t\t\t\t}\n\t\t\t\t}\n#endif\n\n#if PHP_API_VERSION < 20100412\n\t\t\t\tstream = php_stream_open_wrapper_ex(buffer, \"rb\", ENFORCE_SAFE_MODE | REPORT_ERRORS, NULL, context);\n#else\n\t\t\t\tstream = php_stream_open_wrapper_ex(buffer, \"rb\", REPORT_ERRORS, NULL, context);\n#endif\n\n\t\t\t\tif (!stream) {\n\t\t\t\t\tRETVAL_FALSE;\n\t\t\t\t\tgoto clean;\n\t\t\t\t}\n\n\t\t\t\tif (php_stream_stat(stream, &ssb) == SUCCESS) {\n\t\t\t\t\tif (ssb.sb.st_mode & S_IFDIR) {\n\t\t\t\t\t\tret_val = mime_directory;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tret_val = (char *)magic_stream(magic, stream);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tphp_stream_close(stream);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tdefault:\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Can only process string or stream arguments\");\n\t}\n\ncommon:\n\tif (ret_val) {\n\t\tRETVAL_STRING(ret_val, 1);\n\t} else {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Failed identify data %d:%s\", magic_errno(magic), magic_error(magic));\n\t\tRETVAL_FALSE;\n\t}\n\nclean:\n\tif (mimetype_emu) {\n\t\tmagic_close(magic);\n\t}\n\n\t/* Restore options */\n\tif (options) {\n\t\tFINFO_SET_OPTION(magic, finfo->options)\n\t}\n\treturn;\n}",
        "func": "static void _php_finfo_get_type(INTERNAL_FUNCTION_PARAMETERS, int mode, int mimetype_emu) /* {{{ */\n{\n\tlong options = 0;\n\tchar *ret_val = NULL, *buffer = NULL;\n\tint buffer_len;\n\tstruct php_fileinfo *finfo = NULL;\n\tzval *zfinfo, *zcontext = NULL;\n\tzval *what;\n\tchar mime_directory[] = \"directory\";\n\n\tstruct magic_set *magic = NULL;\n\tFILEINFO_DECLARE_INIT_OBJECT(object)\n\n\tif (mimetype_emu) {\n\n\t\t/* mime_content_type(..) emulation */\n\t\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"z\", &what) == FAILURE) {\n\t\t\treturn;\n\t\t}\n\n\t\tswitch (Z_TYPE_P(what)) {\n\t\t\tcase IS_STRING:\n\t\t\t\tbuffer = Z_STRVAL_P(what);\n\t\t\t\tbuffer_len = Z_STRLEN_P(what);\n\t\t\t\tmode = FILEINFO_MODE_FILE;\n\t\t\t\tbreak;\n\n\t\t\tcase IS_RESOURCE:\n\t\t\t\tmode = FILEINFO_MODE_STREAM;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Can only process string or stream arguments\");\n\t\t\t\tRETURN_FALSE;\n\t\t}\n\n\t\tmagic = magic_open(MAGIC_MIME_TYPE);\n\t\tif (magic_load(magic, NULL) == -1) {\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Failed to load magic database.\");\n\t\t\tgoto common;\n\t\t}\n\t} else if (object) {\n\t\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"s|lr\", &buffer, &buffer_len, &options, &zcontext) == FAILURE) {\n\t\t\tRETURN_FALSE;\n\t\t}\n\t\tFILEINFO_FROM_OBJECT(finfo, object);\n\t\tmagic = finfo->magic;\n\t} else {\n\t\tif (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rs|lr\", &zfinfo, &buffer, &buffer_len, &options, &zcontext) == FAILURE) {\n\t\t\tRETURN_FALSE;\n\t\t}\n\t\tZEND_FETCH_RESOURCE(finfo, struct php_fileinfo *, &zfinfo, -1, \"file_info\", le_fileinfo);\n\t\tmagic = finfo->magic;\n\t}\t\n\n\t/* Set options for the current file/buffer. */\n\tif (options) {\n\t\tFINFO_SET_OPTION(magic, options)\n\t}\n\n\tswitch (mode) {\n\t\tcase FILEINFO_MODE_BUFFER:\n\t\t{\n\t\t\tret_val = (char *) magic_buffer(magic, buffer, buffer_len);\n\t\t\tbreak;\n\t\t}\n\n\t\tcase FILEINFO_MODE_STREAM:\n\t\t{\n\t\t\t\tphp_stream *stream;\n\t\t\t\toff_t streampos;\n\n\t\t\t\tphp_stream_from_zval_no_verify(stream, &what);\n\t\t\t\tif (!stream) {\n\t\t\t\t\tgoto common;\n\t\t\t\t}\n\n\t\t\t\tstreampos = php_stream_tell(stream); /* remember stream position for restoration */\n\t\t\t\tphp_stream_seek(stream, 0, SEEK_SET);\n\n\t\t\t\tret_val = (char *) magic_stream(magic, stream);\n\n\t\t\t\tphp_stream_seek(stream, streampos, SEEK_SET);\n\t\t\t\tbreak;\n\t\t}\n\n\t\tcase FILEINFO_MODE_FILE:\n\t\t{\n\t\t\t/* determine if the file is a local file or remote URL */\n\t\t\tchar *tmp2;\n\t\t\tphp_stream_wrapper *wrap;\n\t\t\tphp_stream_statbuf ssb;\n\n\t\t\tif (buffer == NULL || !*buffer) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Empty filename or path\");\n\t\t\t\tRETVAL_FALSE;\n\t\t\t\tgoto clean;\n\t\t\t}\n\t\t\tif (CHECK_NULL_PATH(buffer, buffer_len)) {\n\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Invalid path\");\n\t\t\t\tRETVAL_FALSE;\n\t\t\t\tgoto clean;\n\t\t\t}\n\n\t\t\twrap = php_stream_locate_url_wrapper(buffer, &tmp2, 0 TSRMLS_CC);\n\n\t\t\tif (wrap) {\n\t\t\t\tphp_stream *stream;\n\t\t\t\tphp_stream_context *context = php_stream_context_from_zval(zcontext, 0);\n\n#ifdef PHP_WIN32\n\t\t\t\tif (php_stream_stat_path_ex(buffer, 0, &ssb, context) == SUCCESS) {\n\t\t\t\t\tif (ssb.sb.st_mode & S_IFDIR) {\n\t\t\t\t\t\tret_val = mime_directory;\n\t\t\t\t\t\tgoto common;\n\t\t\t\t\t}\n\t\t\t\t}\n#endif\n\n#if PHP_API_VERSION < 20100412\n\t\t\t\tstream = php_stream_open_wrapper_ex(buffer, \"rb\", ENFORCE_SAFE_MODE | REPORT_ERRORS, NULL, context);\n#else\n\t\t\t\tstream = php_stream_open_wrapper_ex(buffer, \"rb\", REPORT_ERRORS, NULL, context);\n#endif\n\n\t\t\t\tif (!stream) {\n\t\t\t\t\tRETVAL_FALSE;\n\t\t\t\t\tgoto clean;\n\t\t\t\t}\n\n\t\t\t\tif (php_stream_stat(stream, &ssb) == SUCCESS) {\n\t\t\t\t\tif (ssb.sb.st_mode & S_IFDIR) {\n\t\t\t\t\t\tret_val = mime_directory;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tret_val = (char *)magic_stream(magic, stream);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tphp_stream_close(stream);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\n\t\tdefault:\n\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Can only process string or stream arguments\");\n\t}\n\ncommon:\n\tif (ret_val) {\n\t\tRETVAL_STRING(ret_val, 1);\n\t} else {\n\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Failed identify data %d:%s\", magic_errno(magic), magic_error(magic));\n\t\tRETVAL_FALSE;\n\t}\n\nclean:\n\tif (mimetype_emu) {\n\t\tmagic_close(magic);\n\t}\n\n\t/* Restore options */\n\tif (options) {\n\t\tFINFO_SET_OPTION(magic, finfo->options)\n\t}\n\treturn;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -96,6 +96,11 @@\n \t\t\t\tRETVAL_FALSE;\n \t\t\t\tgoto clean;\n \t\t\t}\n+\t\t\tif (CHECK_NULL_PATH(buffer, buffer_len)) {\n+\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Invalid path\");\n+\t\t\t\tRETVAL_FALSE;\n+\t\t\t\tgoto clean;\n+\t\t\t}\n \n \t\t\twrap = php_stream_locate_url_wrapper(buffer, &tmp2, 0 TSRMLS_CC);\n ",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\t\tif (CHECK_NULL_PATH(buffer, buffer_len)) {",
                "\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"Invalid path\");",
                "\t\t\t\tRETVAL_FALSE;",
                "\t\t\t\tgoto clean;",
                "\t\t\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-1682",
        "func_name": "chromium/ServiceWorkerContainer::registerServiceWorkerImpl",
        "description": "The ServiceWorkerContainer::registerServiceWorkerImpl function in WebKit/Source/modules/serviceworkers/ServiceWorkerContainer.cpp in Blink, as used in Google Chrome before 51.0.2704.63, allows remote attackers to bypass the Content Security Policy (CSP) protection mechanism via a ServiceWorker registration.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/5289a5d4c98681e9a0f2d28da0c7aa35e282db57",
        "commit_title": "Check CSP before registering ServiceWorkers",
        "commit_text": " Service Worker registrations should be subject to the same CSP checks as other workers. The spec doesn't say this explicitly (https://www.w3.org/TR/CSP2/#directive-child-src-workers says \"Worker or SharedWorker constructors\"), but it seems to be in the spirit of things, and it matches Firefox's behavior.    ",
        "func_before": "void ServiceWorkerContainer::registerServiceWorkerImpl(ExecutionContext* executionContext, const KURL& rawScriptURL, const KURL& scope, PassOwnPtr<RegistrationCallbacks> callbacks)\n{\n    if (!m_provider) {\n        callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeState, \"Failed to register a ServiceWorker: The document is in an invalid state.\"));\n        return;\n    }\n\n    RefPtr<SecurityOrigin> documentOrigin = executionContext->getSecurityOrigin();\n    String errorMessage;\n    // Restrict to secure origins: https://w3c.github.io/webappsec/specs/powerfulfeatures/#settings-privileged\n    if (!executionContext->isSecureContext(errorMessage)) {\n        callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeSecurity, errorMessage));\n        return;\n    }\n\n    KURL pageURL = KURL(KURL(), documentOrigin->toString());\n    if (!SchemeRegistry::shouldTreatURLSchemeAsAllowingServiceWorkers(pageURL.protocol())) {\n        callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeSecurity, String(\"Failed to register a ServiceWorker: The URL protocol of the current origin ('\" + documentOrigin->toString() + \"') is not supported.\")));\n        return;\n    }\n\n    KURL scriptURL = rawScriptURL;\n    scriptURL.removeFragmentIdentifier();\n    if (!documentOrigin->canRequest(scriptURL)) {\n        RefPtr<SecurityOrigin> scriptOrigin = SecurityOrigin::create(scriptURL);\n        callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeSecurity, String(\"Failed to register a ServiceWorker: The origin of the provided scriptURL ('\" + scriptOrigin->toString() + \"') does not match the current origin ('\" + documentOrigin->toString() + \"').\")));\n        return;\n    }\n    if (!SchemeRegistry::shouldTreatURLSchemeAsAllowingServiceWorkers(scriptURL.protocol())) {\n        callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeSecurity, String(\"Failed to register a ServiceWorker: The URL protocol of the script ('\" + scriptURL.getString() + \"') is not supported.\")));\n        return;\n    }\n\n    KURL patternURL = scope;\n    patternURL.removeFragmentIdentifier();\n\n    if (!documentOrigin->canRequest(patternURL)) {\n        RefPtr<SecurityOrigin> patternOrigin = SecurityOrigin::create(patternURL);\n        callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeSecurity, String(\"Failed to register a ServiceWorker: The origin of the provided scope ('\" + patternOrigin->toString() + \"') does not match the current origin ('\" + documentOrigin->toString() + \"').\")));\n        return;\n    }\n    if (!SchemeRegistry::shouldTreatURLSchemeAsAllowingServiceWorkers(patternURL.protocol())) {\n        callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeSecurity, String(\"Failed to register a ServiceWorker: The URL protocol of the scope ('\" + patternURL.getString() + \"') is not supported.\")));\n        return;\n    }\n\n    WebString webErrorMessage;\n    if (!m_provider->validateScopeAndScriptURL(patternURL, scriptURL, &webErrorMessage)) {\n        callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeType, WebString::fromUTF8(\"Failed to register a ServiceWorker: \" + webErrorMessage.utf8())));\n        return;\n    }\n\n    m_provider->registerServiceWorker(patternURL, scriptURL, callbacks.leakPtr());\n}",
        "func": "void ServiceWorkerContainer::registerServiceWorkerImpl(ExecutionContext* executionContext, const KURL& rawScriptURL, const KURL& scope, PassOwnPtr<RegistrationCallbacks> callbacks)\n{\n    if (!m_provider) {\n        callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeState, \"Failed to register a ServiceWorker: The document is in an invalid state.\"));\n        return;\n    }\n\n    RefPtr<SecurityOrigin> documentOrigin = executionContext->getSecurityOrigin();\n    String errorMessage;\n    // Restrict to secure origins: https://w3c.github.io/webappsec/specs/powerfulfeatures/#settings-privileged\n    if (!executionContext->isSecureContext(errorMessage)) {\n        callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeSecurity, errorMessage));\n        return;\n    }\n\n    KURL pageURL = KURL(KURL(), documentOrigin->toString());\n    if (!SchemeRegistry::shouldTreatURLSchemeAsAllowingServiceWorkers(pageURL.protocol())) {\n        callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeSecurity, String(\"Failed to register a ServiceWorker: The URL protocol of the current origin ('\" + documentOrigin->toString() + \"') is not supported.\")));\n        return;\n    }\n\n    KURL scriptURL = rawScriptURL;\n    scriptURL.removeFragmentIdentifier();\n    if (!documentOrigin->canRequest(scriptURL)) {\n        RefPtr<SecurityOrigin> scriptOrigin = SecurityOrigin::create(scriptURL);\n        callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeSecurity, String(\"Failed to register a ServiceWorker: The origin of the provided scriptURL ('\" + scriptOrigin->toString() + \"') does not match the current origin ('\" + documentOrigin->toString() + \"').\")));\n        return;\n    }\n    if (!SchemeRegistry::shouldTreatURLSchemeAsAllowingServiceWorkers(scriptURL.protocol())) {\n        callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeSecurity, String(\"Failed to register a ServiceWorker: The URL protocol of the script ('\" + scriptURL.getString() + \"') is not supported.\")));\n        return;\n    }\n\n    KURL patternURL = scope;\n    patternURL.removeFragmentIdentifier();\n\n    if (!documentOrigin->canRequest(patternURL)) {\n        RefPtr<SecurityOrigin> patternOrigin = SecurityOrigin::create(patternURL);\n        callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeSecurity, String(\"Failed to register a ServiceWorker: The origin of the provided scope ('\" + patternOrigin->toString() + \"') does not match the current origin ('\" + documentOrigin->toString() + \"').\")));\n        return;\n    }\n    if (!SchemeRegistry::shouldTreatURLSchemeAsAllowingServiceWorkers(patternURL.protocol())) {\n        callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeSecurity, String(\"Failed to register a ServiceWorker: The URL protocol of the scope ('\" + patternURL.getString() + \"') is not supported.\")));\n        return;\n    }\n\n    WebString webErrorMessage;\n    if (!m_provider->validateScopeAndScriptURL(patternURL, scriptURL, &webErrorMessage)) {\n        callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeType, WebString::fromUTF8(\"Failed to register a ServiceWorker: \" + webErrorMessage.utf8())));\n        return;\n    }\n\n    ContentSecurityPolicy* csp = executionContext->contentSecurityPolicy();\n    if (csp) {\n        if (!csp->allowWorkerContextFromSource(scriptURL, ContentSecurityPolicy::DidNotRedirect, ContentSecurityPolicy::SendReport)) {\n            callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeSecurity, String(\"Failed to register a ServiceWorker: The provided scriptURL ('\" + scriptURL.getString() + \"') violates the Content Security Policy.\")));\n            return;\n        }\n    }\n\n    m_provider->registerServiceWorker(patternURL, scriptURL, callbacks.leakPtr());\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -50,5 +50,13 @@\n         return;\n     }\n \n+    ContentSecurityPolicy* csp = executionContext->contentSecurityPolicy();\n+    if (csp) {\n+        if (!csp->allowWorkerContextFromSource(scriptURL, ContentSecurityPolicy::DidNotRedirect, ContentSecurityPolicy::SendReport)) {\n+            callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeSecurity, String(\"Failed to register a ServiceWorker: The provided scriptURL ('\" + scriptURL.getString() + \"') violates the Content Security Policy.\")));\n+            return;\n+        }\n+    }\n+\n     m_provider->registerServiceWorker(patternURL, scriptURL, callbacks.leakPtr());\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    ContentSecurityPolicy* csp = executionContext->contentSecurityPolicy();",
                "    if (csp) {",
                "        if (!csp->allowWorkerContextFromSource(scriptURL, ContentSecurityPolicy::DidNotRedirect, ContentSecurityPolicy::SendReport)) {",
                "            callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeSecurity, String(\"Failed to register a ServiceWorker: The provided scriptURL ('\" + scriptURL.getString() + \"') violates the Content Security Policy.\")));",
                "            return;",
                "        }",
                "    }",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2016-1696",
        "func_name": "chromium/RuntimeCustomBindings::RuntimeCustomBindings",
        "description": "The extensions subsystem in Google Chrome before 51.0.2704.79 does not properly restrict bindings access, which allows remote attackers to bypass the Same Origin Policy via unspecified vectors.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/c0569cc04741cccf6548c2169fcc1609d958523f",
        "commit_title": "[Extensions] Expand bindings access checks",
        "commit_text": "   ",
        "func_before": "RuntimeCustomBindings::RuntimeCustomBindings(ScriptContext* context)\n    : ObjectBackedNativeHandler(context) {\n  RouteFunction(\n      \"GetManifest\",\n      base::Bind(&RuntimeCustomBindings::GetManifest, base::Unretained(this)));\n  RouteFunction(\"OpenChannelToExtension\",\n                base::Bind(&RuntimeCustomBindings::OpenChannelToExtension,\n                           base::Unretained(this)));\n  RouteFunction(\"OpenChannelToNativeApp\",\n                base::Bind(&RuntimeCustomBindings::OpenChannelToNativeApp,\n                           base::Unretained(this)));\n  RouteFunction(\"GetExtensionViews\",\n                base::Bind(&RuntimeCustomBindings::GetExtensionViews,\n                           base::Unretained(this)));\n}",
        "func": "RuntimeCustomBindings::RuntimeCustomBindings(ScriptContext* context)\n    : ObjectBackedNativeHandler(context) {\n  RouteFunction(\n      \"GetManifest\",\n      base::Bind(&RuntimeCustomBindings::GetManifest, base::Unretained(this)));\n  RouteFunction(\"OpenChannelToExtension\", \"runtime.connect\",\n                base::Bind(&RuntimeCustomBindings::OpenChannelToExtension,\n                           base::Unretained(this)));\n  RouteFunction(\"OpenChannelToNativeApp\", \"runtime.connectNative\",\n                base::Bind(&RuntimeCustomBindings::OpenChannelToNativeApp,\n                           base::Unretained(this)));\n  RouteFunction(\"GetExtensionViews\",\n                base::Bind(&RuntimeCustomBindings::GetExtensionViews,\n                           base::Unretained(this)));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,10 +3,10 @@\n   RouteFunction(\n       \"GetManifest\",\n       base::Bind(&RuntimeCustomBindings::GetManifest, base::Unretained(this)));\n-  RouteFunction(\"OpenChannelToExtension\",\n+  RouteFunction(\"OpenChannelToExtension\", \"runtime.connect\",\n                 base::Bind(&RuntimeCustomBindings::OpenChannelToExtension,\n                            base::Unretained(this)));\n-  RouteFunction(\"OpenChannelToNativeApp\",\n+  RouteFunction(\"OpenChannelToNativeApp\", \"runtime.connectNative\",\n                 base::Bind(&RuntimeCustomBindings::OpenChannelToNativeApp,\n                            base::Unretained(this)));\n   RouteFunction(\"GetExtensionViews\",",
        "diff_line_info": {
            "deleted_lines": [
                "  RouteFunction(\"OpenChannelToExtension\",",
                "  RouteFunction(\"OpenChannelToNativeApp\","
            ],
            "added_lines": [
                "  RouteFunction(\"OpenChannelToExtension\", \"runtime.connect\",",
                "  RouteFunction(\"OpenChannelToNativeApp\", \"runtime.connectNative\","
            ]
        }
    },
    {
        "cve_id": "CVE-2016-1696",
        "func_name": "chromium/WebstoreBindings::WebstoreBindings",
        "description": "The extensions subsystem in Google Chrome before 51.0.2704.79 does not properly restrict bindings access, which allows remote attackers to bypass the Same Origin Policy via unspecified vectors.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/c0569cc04741cccf6548c2169fcc1609d958523f",
        "commit_title": "[Extensions] Expand bindings access checks",
        "commit_text": "   ",
        "func_before": "WebstoreBindings::WebstoreBindings(ScriptContext* context)\n    : ObjectBackedNativeHandler(context) {\n  RouteFunction(\"Install\",\n                base::Bind(&WebstoreBindings::Install, base::Unretained(this)));\n}",
        "func": "WebstoreBindings::WebstoreBindings(ScriptContext* context)\n    : ObjectBackedNativeHandler(context) {\n  RouteFunction(\"Install\", \"webstore\",\n                base::Bind(&WebstoreBindings::Install, base::Unretained(this)));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,5 @@\n WebstoreBindings::WebstoreBindings(ScriptContext* context)\n     : ObjectBackedNativeHandler(context) {\n-  RouteFunction(\"Install\",\n+  RouteFunction(\"Install\", \"webstore\",\n                 base::Bind(&WebstoreBindings::Install, base::Unretained(this)));\n }",
        "diff_line_info": {
            "deleted_lines": [
                "  RouteFunction(\"Install\","
            ],
            "added_lines": [
                "  RouteFunction(\"Install\", \"webstore\","
            ]
        }
    },
    {
        "cve_id": "CVE-2016-1696",
        "func_name": "chromium/ObjectBackedNativeHandler::Router",
        "description": "The extensions subsystem in Google Chrome before 51.0.2704.79 does not properly restrict bindings access, which allows remote attackers to bypass the Same Origin Policy via unspecified vectors.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/c0569cc04741cccf6548c2169fcc1609d958523f",
        "commit_title": "[Extensions] Expand bindings access checks",
        "commit_text": "   ",
        "func_before": "void ObjectBackedNativeHandler::Router(\n    const v8::FunctionCallbackInfo<v8::Value>& args) {\n  v8::Isolate* isolate = args.GetIsolate();\n  v8::HandleScope handle_scope(isolate);\n  v8::Local<v8::Object> data = args.Data().As<v8::Object>();\n  v8::Local<v8::Context> context = isolate->GetCurrentContext();\n\n  v8::Local<v8::Value> handler_function_value;\n  v8::Local<v8::Value> feature_name_value;\n  // See comment in header file for why we do this.\n  if (!GetPrivate(context, data, kHandlerFunction, &handler_function_value) ||\n      handler_function_value->IsUndefined() ||\n      !GetPrivate(context, data, kFeatureName, &feature_name_value) ||\n      !feature_name_value->IsString()) {\n    ScriptContext* script_context =\n        ScriptContextSet::GetContextByV8Context(context);\n    console::Error(script_context ? script_context->GetRenderFrame() : nullptr,\n                   \"Extension view no longer exists\");\n    return;\n  }\n\n  // We can't access the ScriptContextSet on a worker thread. Luckily, we also\n  // don't inject many bindings into worker threads.\n  // TODO(devlin): Figure out a way around this.\n  if (content::WorkerThread::GetCurrentId() == 0) {\n    ScriptContext* script_context =\n        ScriptContextSet::GetContextByV8Context(context);\n    v8::Local<v8::String> feature_name_string =\n        feature_name_value->ToString(context).ToLocalChecked();\n    std::string feature_name = *v8::String::Utf8Value(feature_name_string);\n    // TODO(devlin): Eventually, we should fail if either script_context is null\n    // or feature_name is empty.\n    if (script_context &&\n        !feature_name.empty() &&\n        !script_context->GetAvailability(feature_name).is_available()) {\n      return;\n    }\n  }\n  // This CHECK is *important*. Otherwise, we'll go around happily executing\n  // something random.  See crbug.com/548273.\n  CHECK(handler_function_value->IsExternal());\n  static_cast<HandlerFunction*>(\n      handler_function_value.As<v8::External>()->Value())->Run(args);\n\n  // Verify that the return value, if any, is accessible by the context.\n  v8::ReturnValue<v8::Value> ret = args.GetReturnValue();\n  v8::Local<v8::Value> ret_value = ret.Get();\n  if (ret_value->IsObject() && !ret_value->IsNull() &&\n      !ContextCanAccessObject(context, v8::Local<v8::Object>::Cast(ret_value),\n                              true)) {\n    NOTREACHED() << \"Insecure return value\";\n    ret.SetUndefined();\n  }\n}",
        "func": "void ObjectBackedNativeHandler::Router(\n    const v8::FunctionCallbackInfo<v8::Value>& args) {\n  v8::Isolate* isolate = args.GetIsolate();\n  v8::HandleScope handle_scope(isolate);\n  v8::Local<v8::Object> data = args.Data().As<v8::Object>();\n  v8::Local<v8::Context> context = isolate->GetCurrentContext();\n\n  v8::Local<v8::Value> handler_function_value;\n  v8::Local<v8::Value> feature_name_value;\n  // See comment in header file for why we do this.\n  if (!GetPrivate(context, data, kHandlerFunction, &handler_function_value) ||\n      handler_function_value->IsUndefined() ||\n      !GetPrivate(context, data, kFeatureName, &feature_name_value) ||\n      !feature_name_value->IsString()) {\n    ScriptContext* script_context =\n        ScriptContextSet::GetContextByV8Context(context);\n    console::Error(script_context ? script_context->GetRenderFrame() : nullptr,\n                   \"Extension view no longer exists\");\n    return;\n  }\n\n  // We can't access the ScriptContextSet on a worker thread. Luckily, we also\n  // don't inject many bindings into worker threads.\n  // TODO(devlin): Figure out a way around this.\n  if (content::WorkerThread::GetCurrentId() == 0) {\n    ScriptContext* script_context =\n        ScriptContextSet::GetContextByV8Context(context);\n    v8::Local<v8::String> feature_name_string =\n        feature_name_value->ToString(context).ToLocalChecked();\n    std::string feature_name = *v8::String::Utf8Value(feature_name_string);\n    // TODO(devlin): Eventually, we should fail if either script_context is null\n    // or feature_name is empty.\n    if (script_context && !feature_name.empty()) {\n      Feature::Availability availability =\n          script_context->GetAvailability(feature_name);\n      if (!availability.is_available()) {\n        DVLOG(1) << feature_name\n                 << \" is not available: \" << availability.message();\n        return;\n      }\n    }\n  }\n  // This CHECK is *important*. Otherwise, we'll go around happily executing\n  // something random.  See crbug.com/548273.\n  CHECK(handler_function_value->IsExternal());\n  static_cast<HandlerFunction*>(\n      handler_function_value.As<v8::External>()->Value())->Run(args);\n\n  // Verify that the return value, if any, is accessible by the context.\n  v8::ReturnValue<v8::Value> ret = args.GetReturnValue();\n  v8::Local<v8::Value> ret_value = ret.Get();\n  if (ret_value->IsObject() && !ret_value->IsNull() &&\n      !ContextCanAccessObject(context, v8::Local<v8::Object>::Cast(ret_value),\n                              true)) {\n    NOTREACHED() << \"Insecure return value\";\n    ret.SetUndefined();\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -30,10 +30,14 @@\n     std::string feature_name = *v8::String::Utf8Value(feature_name_string);\n     // TODO(devlin): Eventually, we should fail if either script_context is null\n     // or feature_name is empty.\n-    if (script_context &&\n-        !feature_name.empty() &&\n-        !script_context->GetAvailability(feature_name).is_available()) {\n-      return;\n+    if (script_context && !feature_name.empty()) {\n+      Feature::Availability availability =\n+          script_context->GetAvailability(feature_name);\n+      if (!availability.is_available()) {\n+        DVLOG(1) << feature_name\n+                 << \" is not available: \" << availability.message();\n+        return;\n+      }\n     }\n   }\n   // This CHECK is *important*. Otherwise, we'll go around happily executing",
        "diff_line_info": {
            "deleted_lines": [
                "    if (script_context &&",
                "        !feature_name.empty() &&",
                "        !script_context->GetAvailability(feature_name).is_available()) {",
                "      return;"
            ],
            "added_lines": [
                "    if (script_context && !feature_name.empty()) {",
                "      Feature::Availability availability =",
                "          script_context->GetAvailability(feature_name);",
                "      if (!availability.is_available()) {",
                "        DVLOG(1) << feature_name",
                "                 << \" is not available: \" << availability.message();",
                "        return;",
                "      }"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-1696",
        "func_name": "chromium/ChromeExtensionsDispatcherDelegate::RegisterNativeHandlers",
        "description": "The extensions subsystem in Google Chrome before 51.0.2704.79 does not properly restrict bindings access, which allows remote attackers to bypass the Same Origin Policy via unspecified vectors.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/c0569cc04741cccf6548c2169fcc1609d958523f",
        "commit_title": "[Extensions] Expand bindings access checks",
        "commit_text": "   ",
        "func_before": "void ChromeExtensionsDispatcherDelegate::RegisterNativeHandlers(\n    extensions::Dispatcher* dispatcher,\n    extensions::ModuleSystem* module_system,\n    extensions::ScriptContext* context) {\n  module_system->RegisterNativeHandler(\n      \"app\", std::unique_ptr<NativeHandler>(\n                 new extensions::AppBindings(dispatcher, context)));\n  module_system->RegisterNativeHandler(\n      \"sync_file_system\",\n      std::unique_ptr<NativeHandler>(\n          new extensions::SyncFileSystemCustomBindings(context)));\n  module_system->RegisterNativeHandler(\n      \"file_browser_handler\",\n      std::unique_ptr<NativeHandler>(\n          new extensions::FileBrowserHandlerCustomBindings(context)));\n  module_system->RegisterNativeHandler(\n      \"file_manager_private\",\n      std::unique_ptr<NativeHandler>(\n          new extensions::FileManagerPrivateCustomBindings(context)));\n  module_system->RegisterNativeHandler(\n      \"notifications_private\",\n      std::unique_ptr<NativeHandler>(\n          new extensions::NotificationsNativeHandler(context)));\n  module_system->RegisterNativeHandler(\n      \"mediaGalleries\",\n      std::unique_ptr<NativeHandler>(\n          new extensions::MediaGalleriesCustomBindings(context)));\n  module_system->RegisterNativeHandler(\n      \"page_capture\", std::unique_ptr<NativeHandler>(\n                          new extensions::PageCaptureCustomBindings(context)));\n  module_system->RegisterNativeHandler(\n      \"platform_keys_natives\",\n      std::unique_ptr<NativeHandler>(\n          new extensions::PlatformKeysNatives(context)));\n  module_system->RegisterNativeHandler(\n      \"tabs\", std::unique_ptr<NativeHandler>(\n                  new extensions::TabsCustomBindings(context)));\n  module_system->RegisterNativeHandler(\n      \"webstore\", std::unique_ptr<NativeHandler>(\n                      new extensions::WebstoreBindings(context)));\n#if defined(ENABLE_WEBRTC)\n  module_system->RegisterNativeHandler(\n      \"cast_streaming_natives\",\n      std::unique_ptr<NativeHandler>(\n          new extensions::CastStreamingNativeHandler(context)));\n#endif\n  module_system->RegisterNativeHandler(\n      \"automationInternal\",\n      std::unique_ptr<NativeHandler>(\n          new extensions::AutomationInternalCustomBindings(context)));\n}",
        "func": "void ChromeExtensionsDispatcherDelegate::RegisterNativeHandlers(\n    extensions::Dispatcher* dispatcher,\n    extensions::ModuleSystem* module_system,\n    extensions::ScriptContext* context) {\n  module_system->RegisterNativeHandler(\n      \"app\", std::unique_ptr<NativeHandler>(\n                 new extensions::AppBindings(dispatcher, context)));\n  module_system->RegisterNativeHandler(\n      \"sync_file_system\",\n      std::unique_ptr<NativeHandler>(\n          new extensions::SyncFileSystemCustomBindings(context)));\n  module_system->RegisterNativeHandler(\n      \"file_browser_handler\",\n      std::unique_ptr<NativeHandler>(\n          new extensions::FileBrowserHandlerCustomBindings(context)));\n  module_system->RegisterNativeHandler(\n      \"file_manager_private\",\n      std::unique_ptr<NativeHandler>(\n          new extensions::FileManagerPrivateCustomBindings(context)));\n  module_system->RegisterNativeHandler(\n      \"notifications_private\",\n      std::unique_ptr<NativeHandler>(\n          new extensions::NotificationsNativeHandler(context)));\n  module_system->RegisterNativeHandler(\n      \"mediaGalleries\",\n      std::unique_ptr<NativeHandler>(\n          new extensions::MediaGalleriesCustomBindings(context)));\n  module_system->RegisterNativeHandler(\n      \"page_capture\", std::unique_ptr<NativeHandler>(\n                          new extensions::PageCaptureCustomBindings(context)));\n  module_system->RegisterNativeHandler(\n      \"platform_keys_natives\",\n      std::unique_ptr<NativeHandler>(\n          new extensions::PlatformKeysNatives(context)));\n  module_system->RegisterNativeHandler(\n      \"tabs\", std::unique_ptr<NativeHandler>(\n                  new extensions::TabsCustomBindings(context)));\n  module_system->RegisterNativeHandler(\n      \"webstore\", std::unique_ptr<NativeHandler>(\n                      new extensions::WebstoreBindings(context)));\n#if defined(ENABLE_WEBRTC)\n  module_system->RegisterNativeHandler(\n      \"cast_streaming_natives\",\n      std::unique_ptr<NativeHandler>(\n          new extensions::CastStreamingNativeHandler(context)));\n#endif\n  module_system->RegisterNativeHandler(\n      \"automationInternal\",\n      std::unique_ptr<NativeHandler>(\n          new extensions::AutomationInternalCustomBindings(context)));\n\n  // The following are native handlers that are defined in //extensions, but\n  // are only used for APIs defined in Chrome.\n  // TODO(devlin): We should clean this up. If an API is defined in Chrome,\n  // there's no reason to have its native handlers residing and being compiled\n  // in //extensions.\n  module_system->RegisterNativeHandler(\n      \"i18n\",\n      scoped_ptr<NativeHandler>(new extensions::I18NCustomBindings(context)));\n  module_system->RegisterNativeHandler(\n      \"lazy_background_page\",\n      scoped_ptr<NativeHandler>(\n          new extensions::LazyBackgroundPageNativeHandler(context)));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -48,4 +48,17 @@\n       \"automationInternal\",\n       std::unique_ptr<NativeHandler>(\n           new extensions::AutomationInternalCustomBindings(context)));\n+\n+  // The following are native handlers that are defined in //extensions, but\n+  // are only used for APIs defined in Chrome.\n+  // TODO(devlin): We should clean this up. If an API is defined in Chrome,\n+  // there's no reason to have its native handlers residing and being compiled\n+  // in //extensions.\n+  module_system->RegisterNativeHandler(\n+      \"i18n\",\n+      scoped_ptr<NativeHandler>(new extensions::I18NCustomBindings(context)));\n+  module_system->RegisterNativeHandler(\n+      \"lazy_background_page\",\n+      scoped_ptr<NativeHandler>(\n+          new extensions::LazyBackgroundPageNativeHandler(context)));\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "  // The following are native handlers that are defined in //extensions, but",
                "  // are only used for APIs defined in Chrome.",
                "  // TODO(devlin): We should clean this up. If an API is defined in Chrome,",
                "  // there's no reason to have its native handlers residing and being compiled",
                "  // in //extensions.",
                "  module_system->RegisterNativeHandler(",
                "      \"i18n\",",
                "      scoped_ptr<NativeHandler>(new extensions::I18NCustomBindings(context)));",
                "  module_system->RegisterNativeHandler(",
                "      \"lazy_background_page\",",
                "      scoped_ptr<NativeHandler>(",
                "          new extensions::LazyBackgroundPageNativeHandler(context)));"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-1696",
        "func_name": "chromium/I18NCustomBindings::I18NCustomBindings",
        "description": "The extensions subsystem in Google Chrome before 51.0.2704.79 does not properly restrict bindings access, which allows remote attackers to bypass the Same Origin Policy via unspecified vectors.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/c0569cc04741cccf6548c2169fcc1609d958523f",
        "commit_title": "[Extensions] Expand bindings access checks",
        "commit_text": "   ",
        "func_before": "I18NCustomBindings::I18NCustomBindings(ScriptContext* context)\n    : ObjectBackedNativeHandler(context) {\n  RouteFunction(\n      \"GetL10nMessage\",\n      base::Bind(&I18NCustomBindings::GetL10nMessage, base::Unretained(this)));\n  RouteFunction(\"GetL10nUILanguage\",\n                base::Bind(&I18NCustomBindings::GetL10nUILanguage,\n                           base::Unretained(this)));\n  RouteFunction(\"DetectTextLanguage\",\n                base::Bind(&I18NCustomBindings::DetectTextLanguage,\n                           base::Unretained(this)));\n}",
        "func": "I18NCustomBindings::I18NCustomBindings(ScriptContext* context)\n    : ObjectBackedNativeHandler(context) {\n  RouteFunction(\n      \"GetL10nMessage\", \"i18n\",\n      base::Bind(&I18NCustomBindings::GetL10nMessage, base::Unretained(this)));\n  RouteFunction(\"GetL10nUILanguage\", \"i18n\",\n                base::Bind(&I18NCustomBindings::GetL10nUILanguage,\n                           base::Unretained(this)));\n  RouteFunction(\"DetectTextLanguage\", \"i18n\",\n                base::Bind(&I18NCustomBindings::DetectTextLanguage,\n                           base::Unretained(this)));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,12 +1,12 @@\n I18NCustomBindings::I18NCustomBindings(ScriptContext* context)\n     : ObjectBackedNativeHandler(context) {\n   RouteFunction(\n-      \"GetL10nMessage\",\n+      \"GetL10nMessage\", \"i18n\",\n       base::Bind(&I18NCustomBindings::GetL10nMessage, base::Unretained(this)));\n-  RouteFunction(\"GetL10nUILanguage\",\n+  RouteFunction(\"GetL10nUILanguage\", \"i18n\",\n                 base::Bind(&I18NCustomBindings::GetL10nUILanguage,\n                            base::Unretained(this)));\n-  RouteFunction(\"DetectTextLanguage\",\n+  RouteFunction(\"DetectTextLanguage\", \"i18n\",\n                 base::Bind(&I18NCustomBindings::DetectTextLanguage,\n                            base::Unretained(this)));\n }",
        "diff_line_info": {
            "deleted_lines": [
                "      \"GetL10nMessage\",",
                "  RouteFunction(\"GetL10nUILanguage\",",
                "  RouteFunction(\"DetectTextLanguage\","
            ],
            "added_lines": [
                "      \"GetL10nMessage\", \"i18n\",",
                "  RouteFunction(\"GetL10nUILanguage\", \"i18n\",",
                "  RouteFunction(\"DetectTextLanguage\", \"i18n\","
            ]
        }
    },
    {
        "cve_id": "CVE-2016-1696",
        "func_name": "chromium/DisplaySourceCustomBindings::DisplaySourceCustomBindings",
        "description": "The extensions subsystem in Google Chrome before 51.0.2704.79 does not properly restrict bindings access, which allows remote attackers to bypass the Same Origin Policy via unspecified vectors.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/c0569cc04741cccf6548c2169fcc1609d958523f",
        "commit_title": "[Extensions] Expand bindings access checks",
        "commit_text": "   ",
        "func_before": "DisplaySourceCustomBindings::DisplaySourceCustomBindings(ScriptContext* context)\n    : ObjectBackedNativeHandler(context),\n      weak_factory_(this) {\n  RouteFunction(\"StartSession\",\n                base::Bind(&DisplaySourceCustomBindings::StartSession,\n                           weak_factory_.GetWeakPtr()));\n  RouteFunction(\"TerminateSession\",\n                base::Bind(&DisplaySourceCustomBindings::TerminateSession,\n                           weak_factory_.GetWeakPtr()));\n}",
        "func": "DisplaySourceCustomBindings::DisplaySourceCustomBindings(ScriptContext* context)\n    : ObjectBackedNativeHandler(context),\n      weak_factory_(this) {\n  RouteFunction(\"StartSession\", \"displaySource\",\n                base::Bind(&DisplaySourceCustomBindings::StartSession,\n                           weak_factory_.GetWeakPtr()));\n  RouteFunction(\"TerminateSession\", \"displaySource\",\n                base::Bind(&DisplaySourceCustomBindings::TerminateSession,\n                           weak_factory_.GetWeakPtr()));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,10 +1,10 @@\n DisplaySourceCustomBindings::DisplaySourceCustomBindings(ScriptContext* context)\n     : ObjectBackedNativeHandler(context),\n       weak_factory_(this) {\n-  RouteFunction(\"StartSession\",\n+  RouteFunction(\"StartSession\", \"displaySource\",\n                 base::Bind(&DisplaySourceCustomBindings::StartSession,\n                            weak_factory_.GetWeakPtr()));\n-  RouteFunction(\"TerminateSession\",\n+  RouteFunction(\"TerminateSession\", \"displaySource\",\n                 base::Bind(&DisplaySourceCustomBindings::TerminateSession,\n                            weak_factory_.GetWeakPtr()));\n }",
        "diff_line_info": {
            "deleted_lines": [
                "  RouteFunction(\"StartSession\",",
                "  RouteFunction(\"TerminateSession\","
            ],
            "added_lines": [
                "  RouteFunction(\"StartSession\", \"displaySource\",",
                "  RouteFunction(\"TerminateSession\", \"displaySource\","
            ]
        }
    },
    {
        "cve_id": "CVE-2016-1696",
        "func_name": "chromium/ApiDefinitionsNatives::ApiDefinitionsNatives",
        "description": "The extensions subsystem in Google Chrome before 51.0.2704.79 does not properly restrict bindings access, which allows remote attackers to bypass the Same Origin Policy via unspecified vectors.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/c0569cc04741cccf6548c2169fcc1609d958523f",
        "commit_title": "[Extensions] Expand bindings access checks",
        "commit_text": "   ",
        "func_before": "ApiDefinitionsNatives::ApiDefinitionsNatives(Dispatcher* dispatcher,\n                                             ScriptContext* context)\n    : ObjectBackedNativeHandler(context), dispatcher_(dispatcher) {\n  RouteFunction(\n      \"GetExtensionAPIDefinitionsForTest\",\n      base::Bind(&ApiDefinitionsNatives::GetExtensionAPIDefinitionsForTest,\n                 base::Unretained(this)));\n}",
        "func": "ApiDefinitionsNatives::ApiDefinitionsNatives(Dispatcher* dispatcher,\n                                             ScriptContext* context)\n    : ObjectBackedNativeHandler(context), dispatcher_(dispatcher) {\n  RouteFunction(\n      \"GetExtensionAPIDefinitionsForTest\", \"test\",\n      base::Bind(&ApiDefinitionsNatives::GetExtensionAPIDefinitionsForTest,\n                 base::Unretained(this)));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,7 +2,7 @@\n                                              ScriptContext* context)\n     : ObjectBackedNativeHandler(context), dispatcher_(dispatcher) {\n   RouteFunction(\n-      \"GetExtensionAPIDefinitionsForTest\",\n+      \"GetExtensionAPIDefinitionsForTest\", \"test\",\n       base::Bind(&ApiDefinitionsNatives::GetExtensionAPIDefinitionsForTest,\n                  base::Unretained(this)));\n }",
        "diff_line_info": {
            "deleted_lines": [
                "      \"GetExtensionAPIDefinitionsForTest\","
            ],
            "added_lines": [
                "      \"GetExtensionAPIDefinitionsForTest\", \"test\","
            ]
        }
    },
    {
        "cve_id": "CVE-2016-1696",
        "func_name": "chromium/TabsCustomBindings::TabsCustomBindings",
        "description": "The extensions subsystem in Google Chrome before 51.0.2704.79 does not properly restrict bindings access, which allows remote attackers to bypass the Same Origin Policy via unspecified vectors.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/c0569cc04741cccf6548c2169fcc1609d958523f",
        "commit_title": "[Extensions] Expand bindings access checks",
        "commit_text": "   ",
        "func_before": "TabsCustomBindings::TabsCustomBindings(ScriptContext* context)\n    : ObjectBackedNativeHandler(context) {\n  RouteFunction(\"OpenChannelToTab\",\n      base::Bind(&TabsCustomBindings::OpenChannelToTab,\n                 base::Unretained(this)));\n}",
        "func": "TabsCustomBindings::TabsCustomBindings(ScriptContext* context)\n    : ObjectBackedNativeHandler(context) {\n  RouteFunction(\"OpenChannelToTab\", \"tabs\",\n                base::Bind(&TabsCustomBindings::OpenChannelToTab,\n                           base::Unretained(this)));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,6 @@\n TabsCustomBindings::TabsCustomBindings(ScriptContext* context)\n     : ObjectBackedNativeHandler(context) {\n-  RouteFunction(\"OpenChannelToTab\",\n-      base::Bind(&TabsCustomBindings::OpenChannelToTab,\n-                 base::Unretained(this)));\n+  RouteFunction(\"OpenChannelToTab\", \"tabs\",\n+                base::Bind(&TabsCustomBindings::OpenChannelToTab,\n+                           base::Unretained(this)));\n }",
        "diff_line_info": {
            "deleted_lines": [
                "  RouteFunction(\"OpenChannelToTab\",",
                "      base::Bind(&TabsCustomBindings::OpenChannelToTab,",
                "                 base::Unretained(this)));"
            ],
            "added_lines": [
                "  RouteFunction(\"OpenChannelToTab\", \"tabs\",",
                "                base::Bind(&TabsCustomBindings::OpenChannelToTab,",
                "                           base::Unretained(this)));"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-1696",
        "func_name": "chromium/V8ContextNativeHandler::V8ContextNativeHandler",
        "description": "The extensions subsystem in Google Chrome before 51.0.2704.79 does not properly restrict bindings access, which allows remote attackers to bypass the Same Origin Policy via unspecified vectors.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/c0569cc04741cccf6548c2169fcc1609d958523f",
        "commit_title": "[Extensions] Expand bindings access checks",
        "commit_text": "   ",
        "func_before": "V8ContextNativeHandler::V8ContextNativeHandler(ScriptContext* context)\n    : ObjectBackedNativeHandler(context), context_(context) {\n  RouteFunction(\"GetAvailability\",\n                base::Bind(&V8ContextNativeHandler::GetAvailability,\n                           base::Unretained(this)));\n  RouteFunction(\"GetModuleSystem\",\n                base::Bind(&V8ContextNativeHandler::GetModuleSystem,\n                           base::Unretained(this)));\n  RouteFunction(\n      \"RunWithNativesEnabled\",\n      base::Bind(&V8ContextNativeHandler::RunWithNativesEnabled,\n                 base::Unretained(this)));\n}",
        "func": "V8ContextNativeHandler::V8ContextNativeHandler(ScriptContext* context)\n    : ObjectBackedNativeHandler(context), context_(context) {\n  RouteFunction(\"GetAvailability\",\n                base::Bind(&V8ContextNativeHandler::GetAvailability,\n                           base::Unretained(this)));\n  RouteFunction(\"GetModuleSystem\",\n                base::Bind(&V8ContextNativeHandler::GetModuleSystem,\n                           base::Unretained(this)));\n  RouteFunction(\"RunWithNativesEnabled\", \"test\",\n                base::Bind(&V8ContextNativeHandler::RunWithNativesEnabled,\n                           base::Unretained(this)));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,8 +6,7 @@\n   RouteFunction(\"GetModuleSystem\",\n                 base::Bind(&V8ContextNativeHandler::GetModuleSystem,\n                            base::Unretained(this)));\n-  RouteFunction(\n-      \"RunWithNativesEnabled\",\n-      base::Bind(&V8ContextNativeHandler::RunWithNativesEnabled,\n-                 base::Unretained(this)));\n+  RouteFunction(\"RunWithNativesEnabled\", \"test\",\n+                base::Bind(&V8ContextNativeHandler::RunWithNativesEnabled,\n+                           base::Unretained(this)));\n }",
        "diff_line_info": {
            "deleted_lines": [
                "  RouteFunction(",
                "      \"RunWithNativesEnabled\",",
                "      base::Bind(&V8ContextNativeHandler::RunWithNativesEnabled,",
                "                 base::Unretained(this)));"
            ],
            "added_lines": [
                "  RouteFunction(\"RunWithNativesEnabled\", \"test\",",
                "                base::Bind(&V8ContextNativeHandler::RunWithNativesEnabled,",
                "                           base::Unretained(this)));"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-1696",
        "func_name": "chromium/LazyBackgroundPageNativeHandler::LazyBackgroundPageNativeHandler",
        "description": "The extensions subsystem in Google Chrome before 51.0.2704.79 does not properly restrict bindings access, which allows remote attackers to bypass the Same Origin Policy via unspecified vectors.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/c0569cc04741cccf6548c2169fcc1609d958523f",
        "commit_title": "[Extensions] Expand bindings access checks",
        "commit_text": "   ",
        "func_before": "LazyBackgroundPageNativeHandler::LazyBackgroundPageNativeHandler(\n    ScriptContext* context)\n    : ObjectBackedNativeHandler(context) {\n  RouteFunction(\n      \"IncrementKeepaliveCount\",\n      base::Bind(&LazyBackgroundPageNativeHandler::IncrementKeepaliveCount,\n                 base::Unretained(this)));\n  RouteFunction(\n      \"DecrementKeepaliveCount\",\n      base::Bind(&LazyBackgroundPageNativeHandler::DecrementKeepaliveCount,\n                 base::Unretained(this)));\n}",
        "func": "LazyBackgroundPageNativeHandler::LazyBackgroundPageNativeHandler(\n    ScriptContext* context)\n    : ObjectBackedNativeHandler(context) {\n  RouteFunction(\n      \"IncrementKeepaliveCount\", \"tts\",\n      base::Bind(&LazyBackgroundPageNativeHandler::IncrementKeepaliveCount,\n                 base::Unretained(this)));\n  RouteFunction(\n      \"DecrementKeepaliveCount\", \"tts\",\n      base::Bind(&LazyBackgroundPageNativeHandler::DecrementKeepaliveCount,\n                 base::Unretained(this)));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,11 +2,11 @@\n     ScriptContext* context)\n     : ObjectBackedNativeHandler(context) {\n   RouteFunction(\n-      \"IncrementKeepaliveCount\",\n+      \"IncrementKeepaliveCount\", \"tts\",\n       base::Bind(&LazyBackgroundPageNativeHandler::IncrementKeepaliveCount,\n                  base::Unretained(this)));\n   RouteFunction(\n-      \"DecrementKeepaliveCount\",\n+      \"DecrementKeepaliveCount\", \"tts\",\n       base::Bind(&LazyBackgroundPageNativeHandler::DecrementKeepaliveCount,\n                  base::Unretained(this)));\n }",
        "diff_line_info": {
            "deleted_lines": [
                "      \"IncrementKeepaliveCount\",",
                "      \"DecrementKeepaliveCount\","
            ],
            "added_lines": [
                "      \"IncrementKeepaliveCount\", \"tts\",",
                "      \"DecrementKeepaliveCount\", \"tts\","
            ]
        }
    },
    {
        "cve_id": "CVE-2016-1696",
        "func_name": "chromium/RenderFrameObserverNatives::RenderFrameObserverNatives",
        "description": "The extensions subsystem in Google Chrome before 51.0.2704.79 does not properly restrict bindings access, which allows remote attackers to bypass the Same Origin Policy via unspecified vectors.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/c0569cc04741cccf6548c2169fcc1609d958523f",
        "commit_title": "[Extensions] Expand bindings access checks",
        "commit_text": "   ",
        "func_before": "RenderFrameObserverNatives::RenderFrameObserverNatives(ScriptContext* context)\n    : ObjectBackedNativeHandler(context), weak_ptr_factory_(this) {\n  RouteFunction(\n      \"OnDocumentElementCreated\",\n      base::Bind(&RenderFrameObserverNatives::OnDocumentElementCreated,\n                 base::Unretained(this)));\n}",
        "func": "RenderFrameObserverNatives::RenderFrameObserverNatives(ScriptContext* context)\n    : ObjectBackedNativeHandler(context), weak_ptr_factory_(this) {\n  RouteFunction(\n      \"OnDocumentElementCreated\", \"app.window\",\n      base::Bind(&RenderFrameObserverNatives::OnDocumentElementCreated,\n                 base::Unretained(this)));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,7 +1,7 @@\n RenderFrameObserverNatives::RenderFrameObserverNatives(ScriptContext* context)\n     : ObjectBackedNativeHandler(context), weak_ptr_factory_(this) {\n   RouteFunction(\n-      \"OnDocumentElementCreated\",\n+      \"OnDocumentElementCreated\", \"app.window\",\n       base::Bind(&RenderFrameObserverNatives::OnDocumentElementCreated,\n                  base::Unretained(this)));\n }",
        "diff_line_info": {
            "deleted_lines": [
                "      \"OnDocumentElementCreated\","
            ],
            "added_lines": [
                "      \"OnDocumentElementCreated\", \"app.window\","
            ]
        }
    },
    {
        "cve_id": "CVE-2016-1696",
        "func_name": "chromium/Dispatcher::RegisterNativeHandlers",
        "description": "The extensions subsystem in Google Chrome before 51.0.2704.79 does not properly restrict bindings access, which allows remote attackers to bypass the Same Origin Policy via unspecified vectors.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/c0569cc04741cccf6548c2169fcc1609d958523f",
        "commit_title": "[Extensions] Expand bindings access checks",
        "commit_text": "   ",
        "func_before": "void Dispatcher::RegisterNativeHandlers(ModuleSystem* module_system,\n                                        ScriptContext* context,\n                                        Dispatcher* dispatcher,\n                                        RequestSender* request_sender,\n                                        V8SchemaRegistry* v8_schema_registry) {\n  module_system->RegisterNativeHandler(\n      \"chrome\", scoped_ptr<NativeHandler>(new ChromeNativeHandler(context)));\n  module_system->RegisterNativeHandler(\n      \"lazy_background_page\",\n      scoped_ptr<NativeHandler>(new LazyBackgroundPageNativeHandler(context)));\n  module_system->RegisterNativeHandler(\n      \"logging\", scoped_ptr<NativeHandler>(new LoggingNativeHandler(context)));\n  module_system->RegisterNativeHandler(\"schema_registry\",\n                                       v8_schema_registry->AsNativeHandler());\n  module_system->RegisterNativeHandler(\n      \"print\", scoped_ptr<NativeHandler>(new PrintNativeHandler(context)));\n  module_system->RegisterNativeHandler(\n      \"test_features\",\n      scoped_ptr<NativeHandler>(new TestFeaturesNativeHandler(context)));\n  module_system->RegisterNativeHandler(\n      \"test_native_handler\",\n      scoped_ptr<NativeHandler>(new TestNativeHandler(context)));\n  module_system->RegisterNativeHandler(\n      \"user_gestures\",\n      scoped_ptr<NativeHandler>(new UserGesturesNativeHandler(context)));\n  module_system->RegisterNativeHandler(\n      \"utils\", scoped_ptr<NativeHandler>(new UtilsNativeHandler(context)));\n  module_system->RegisterNativeHandler(\n      \"v8_context\",\n      scoped_ptr<NativeHandler>(new V8ContextNativeHandler(context)));\n  module_system->RegisterNativeHandler(\n      \"event_natives\", scoped_ptr<NativeHandler>(new EventBindings(context)));\n  module_system->RegisterNativeHandler(\n      \"messaging_natives\",\n      scoped_ptr<NativeHandler>(MessagingBindings::Get(dispatcher, context)));\n  module_system->RegisterNativeHandler(\n      \"apiDefinitions\",\n      scoped_ptr<NativeHandler>(\n          new ApiDefinitionsNatives(dispatcher, context)));\n  module_system->RegisterNativeHandler(\n      \"sendRequest\",\n      scoped_ptr<NativeHandler>(\n          new SendRequestNatives(request_sender, context)));\n  module_system->RegisterNativeHandler(\n      \"setIcon\",\n      scoped_ptr<NativeHandler>(new SetIconNatives(context)));\n  module_system->RegisterNativeHandler(\n      \"activityLogger\",\n      scoped_ptr<NativeHandler>(new APIActivityLogger(context)));\n  module_system->RegisterNativeHandler(\n      \"renderFrameObserverNatives\",\n      scoped_ptr<NativeHandler>(new RenderFrameObserverNatives(context)));\n\n  // Natives used by multiple APIs.\n  module_system->RegisterNativeHandler(\n      \"file_system_natives\",\n      scoped_ptr<NativeHandler>(new FileSystemNatives(context)));\n\n  // Custom bindings.\n  module_system->RegisterNativeHandler(\n      \"app_window_natives\",\n      scoped_ptr<NativeHandler>(new AppWindowCustomBindings(context)));\n  module_system->RegisterNativeHandler(\n      \"blob_natives\",\n      scoped_ptr<NativeHandler>(new BlobNativeHandler(context)));\n  module_system->RegisterNativeHandler(\n      \"context_menus\",\n      scoped_ptr<NativeHandler>(new ContextMenusCustomBindings(context)));\n  module_system->RegisterNativeHandler(\n      \"css_natives\", scoped_ptr<NativeHandler>(new CssNativeHandler(context)));\n  module_system->RegisterNativeHandler(\n      \"document_natives\",\n      scoped_ptr<NativeHandler>(new DocumentCustomBindings(context)));\n  module_system->RegisterNativeHandler(\n      \"guest_view_internal\",\n      scoped_ptr<NativeHandler>(\n          new GuestViewInternalCustomBindings(context)));\n  module_system->RegisterNativeHandler(\n      \"i18n\", scoped_ptr<NativeHandler>(new I18NCustomBindings(context)));\n  module_system->RegisterNativeHandler(\n      \"id_generator\",\n      scoped_ptr<NativeHandler>(new IdGeneratorCustomBindings(context)));\n  module_system->RegisterNativeHandler(\n      \"runtime\", scoped_ptr<NativeHandler>(new RuntimeCustomBindings(context)));\n  module_system->RegisterNativeHandler(\n      \"display_source\",\n      scoped_ptr<NativeHandler>(new DisplaySourceCustomBindings(context)));\n}",
        "func": "void Dispatcher::RegisterNativeHandlers(ModuleSystem* module_system,\n                                        ScriptContext* context,\n                                        Dispatcher* dispatcher,\n                                        RequestSender* request_sender,\n                                        V8SchemaRegistry* v8_schema_registry) {\n  module_system->RegisterNativeHandler(\n      \"chrome\", scoped_ptr<NativeHandler>(new ChromeNativeHandler(context)));\n  module_system->RegisterNativeHandler(\n      \"logging\", scoped_ptr<NativeHandler>(new LoggingNativeHandler(context)));\n  module_system->RegisterNativeHandler(\"schema_registry\",\n                                       v8_schema_registry->AsNativeHandler());\n  module_system->RegisterNativeHandler(\n      \"test_features\",\n      scoped_ptr<NativeHandler>(new TestFeaturesNativeHandler(context)));\n  module_system->RegisterNativeHandler(\n      \"test_native_handler\",\n      scoped_ptr<NativeHandler>(new TestNativeHandler(context)));\n  module_system->RegisterNativeHandler(\n      \"user_gestures\",\n      scoped_ptr<NativeHandler>(new UserGesturesNativeHandler(context)));\n  module_system->RegisterNativeHandler(\n      \"utils\", scoped_ptr<NativeHandler>(new UtilsNativeHandler(context)));\n  module_system->RegisterNativeHandler(\n      \"v8_context\",\n      scoped_ptr<NativeHandler>(new V8ContextNativeHandler(context)));\n  module_system->RegisterNativeHandler(\n      \"event_natives\", scoped_ptr<NativeHandler>(new EventBindings(context)));\n  module_system->RegisterNativeHandler(\n      \"messaging_natives\",\n      scoped_ptr<NativeHandler>(MessagingBindings::Get(dispatcher, context)));\n  module_system->RegisterNativeHandler(\n      \"apiDefinitions\",\n      scoped_ptr<NativeHandler>(\n          new ApiDefinitionsNatives(dispatcher, context)));\n  module_system->RegisterNativeHandler(\n      \"sendRequest\",\n      scoped_ptr<NativeHandler>(\n          new SendRequestNatives(request_sender, context)));\n  module_system->RegisterNativeHandler(\n      \"setIcon\",\n      scoped_ptr<NativeHandler>(new SetIconNatives(context)));\n  module_system->RegisterNativeHandler(\n      \"activityLogger\",\n      scoped_ptr<NativeHandler>(new APIActivityLogger(context)));\n  module_system->RegisterNativeHandler(\n      \"renderFrameObserverNatives\",\n      scoped_ptr<NativeHandler>(new RenderFrameObserverNatives(context)));\n\n  // Natives used by multiple APIs.\n  module_system->RegisterNativeHandler(\n      \"file_system_natives\",\n      scoped_ptr<NativeHandler>(new FileSystemNatives(context)));\n\n  // Custom bindings.\n  module_system->RegisterNativeHandler(\n      \"app_window_natives\",\n      scoped_ptr<NativeHandler>(new AppWindowCustomBindings(context)));\n  module_system->RegisterNativeHandler(\n      \"blob_natives\",\n      scoped_ptr<NativeHandler>(new BlobNativeHandler(context)));\n  module_system->RegisterNativeHandler(\n      \"context_menus\",\n      scoped_ptr<NativeHandler>(new ContextMenusCustomBindings(context)));\n  module_system->RegisterNativeHandler(\n      \"css_natives\", scoped_ptr<NativeHandler>(new CssNativeHandler(context)));\n  module_system->RegisterNativeHandler(\n      \"document_natives\",\n      scoped_ptr<NativeHandler>(new DocumentCustomBindings(context)));\n  module_system->RegisterNativeHandler(\n      \"guest_view_internal\",\n      scoped_ptr<NativeHandler>(\n          new GuestViewInternalCustomBindings(context)));\n  module_system->RegisterNativeHandler(\n      \"id_generator\",\n      scoped_ptr<NativeHandler>(new IdGeneratorCustomBindings(context)));\n  module_system->RegisterNativeHandler(\n      \"runtime\", scoped_ptr<NativeHandler>(new RuntimeCustomBindings(context)));\n  module_system->RegisterNativeHandler(\n      \"display_source\",\n      scoped_ptr<NativeHandler>(new DisplaySourceCustomBindings(context)));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,14 +6,9 @@\n   module_system->RegisterNativeHandler(\n       \"chrome\", scoped_ptr<NativeHandler>(new ChromeNativeHandler(context)));\n   module_system->RegisterNativeHandler(\n-      \"lazy_background_page\",\n-      scoped_ptr<NativeHandler>(new LazyBackgroundPageNativeHandler(context)));\n-  module_system->RegisterNativeHandler(\n       \"logging\", scoped_ptr<NativeHandler>(new LoggingNativeHandler(context)));\n   module_system->RegisterNativeHandler(\"schema_registry\",\n                                        v8_schema_registry->AsNativeHandler());\n-  module_system->RegisterNativeHandler(\n-      \"print\", scoped_ptr<NativeHandler>(new PrintNativeHandler(context)));\n   module_system->RegisterNativeHandler(\n       \"test_features\",\n       scoped_ptr<NativeHandler>(new TestFeaturesNativeHandler(context)));\n@@ -76,8 +71,6 @@\n       scoped_ptr<NativeHandler>(\n           new GuestViewInternalCustomBindings(context)));\n   module_system->RegisterNativeHandler(\n-      \"i18n\", scoped_ptr<NativeHandler>(new I18NCustomBindings(context)));\n-  module_system->RegisterNativeHandler(\n       \"id_generator\",\n       scoped_ptr<NativeHandler>(new IdGeneratorCustomBindings(context)));\n   module_system->RegisterNativeHandler(",
        "diff_line_info": {
            "deleted_lines": [
                "      \"lazy_background_page\",",
                "      scoped_ptr<NativeHandler>(new LazyBackgroundPageNativeHandler(context)));",
                "  module_system->RegisterNativeHandler(",
                "  module_system->RegisterNativeHandler(",
                "      \"print\", scoped_ptr<NativeHandler>(new PrintNativeHandler(context)));",
                "      \"i18n\", scoped_ptr<NativeHandler>(new I18NCustomBindings(context)));",
                "  module_system->RegisterNativeHandler("
            ],
            "added_lines": []
        }
    },
    {
        "cve_id": "CVE-2016-10746",
        "func_name": "libvirt/virDomainGetTime",
        "description": "libvirt-domain.c in libvirt before 1.3.1 supports virDomainGetTime API calls by guest agents with an RO connection, even though an RW connection was supposed to be required, a different vulnerability than CVE-2019-3886.",
        "git_url": "https://github.com/libvirt/libvirt/commit/506e9d6c2d4baaf580d489fff0690c0ff2ff588f",
        "commit_title": "virDomainGetTime: Deny on RO connections",
        "commit_text": " We have a policy that if API may end up talking to a guest agent it should require RW connection. We don't obey the rule in virDomainGetTime(). ",
        "func_before": "int\nvirDomainGetTime(virDomainPtr dom,\n                 long long *seconds,\n                 unsigned int *nseconds,\n                 unsigned int flags)\n{\n    VIR_DOMAIN_DEBUG(dom, \"seconds=%p, nseconds=%p, flags=%x\",\n                     seconds, nseconds, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(dom, -1);\n\n    if (dom->conn->driver->domainGetTime) {\n        int ret = dom->conn->driver->domainGetTime(dom, seconds,\n                                                   nseconds, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(dom->conn);\n    return -1;\n}",
        "func": "int\nvirDomainGetTime(virDomainPtr dom,\n                 long long *seconds,\n                 unsigned int *nseconds,\n                 unsigned int flags)\n{\n    VIR_DOMAIN_DEBUG(dom, \"seconds=%p, nseconds=%p, flags=%x\",\n                     seconds, nseconds, flags);\n\n    virResetLastError();\n\n    virCheckDomainReturn(dom, -1);\n    virCheckReadOnlyGoto(dom->conn->flags, error);\n\n    if (dom->conn->driver->domainGetTime) {\n        int ret = dom->conn->driver->domainGetTime(dom, seconds,\n                                                   nseconds, flags);\n        if (ret < 0)\n            goto error;\n        return ret;\n    }\n\n    virReportUnsupportedError();\n\n error:\n    virDispatchError(dom->conn);\n    return -1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -10,6 +10,7 @@\n     virResetLastError();\n \n     virCheckDomainReturn(dom, -1);\n+    virCheckReadOnlyGoto(dom->conn->flags, error);\n \n     if (dom->conn->driver->domainGetTime) {\n         int ret = dom->conn->driver->domainGetTime(dom, seconds,",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    virCheckReadOnlyGoto(dom->conn->flags, error);"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-1266",
        "func_name": "chromium/ContentWebUIControllerFactory::CreateWebUIControllerForURL",
        "description": "content/browser/webui/content_web_ui_controller_factory.cc in Google Chrome before 43.0.2357.130 does not properly consider the scheme in determining whether a URL is associated with a WebUI SiteInstance, which allows remote attackers to bypass intended access restrictions via a similar URL, as demonstrated by use of http://gpu when there is a WebUI class for handling chrome://gpu requests.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/7cdcf50b4ae3858f5132a1bb0d4cb5e104527b42",
        "commit_title": "Don't treat http://gpu as a WebUI url",
        "commit_text": "   ",
        "func_before": "WebUIController* ContentWebUIControllerFactory::CreateWebUIControllerForURL(\n    WebUI* web_ui, const GURL& url) const {\n  if (url.host() == kChromeUIGpuHost)\n    return new GpuInternalsUI(web_ui);\n  if (url.host() == kChromeUIIndexedDBInternalsHost)\n    return new IndexedDBInternalsUI(web_ui);\n  if (url.host() == kChromeUIMediaInternalsHost)\n    return new MediaInternalsUI(web_ui);\n  if (url.host() == kChromeUIAccessibilityHost)\n    return new AccessibilityUI(web_ui);\n  if (url.host() == kChromeUIServiceWorkerInternalsHost)\n    return new ServiceWorkerInternalsUI(web_ui);\n#if !defined(OS_ANDROID)\n  if (url.host() == kChromeUITracingHost)\n    return new TracingUI(web_ui);\n#endif\n\n#if defined(ENABLE_WEBRTC)\n  if (url.host() == kChromeUIWebRTCInternalsHost)\n    return new WebRTCInternalsUI(web_ui);\n#endif\n\n  return NULL;\n}",
        "func": "WebUIController* ContentWebUIControllerFactory::CreateWebUIControllerForURL(\n    WebUI* web_ui, const GURL& url) const {\n  if (!url.SchemeIs(kChromeUIScheme))\n    return nullptr;\n\n  if (url.host() == kChromeUIGpuHost)\n    return new GpuInternalsUI(web_ui);\n  if (url.host() == kChromeUIIndexedDBInternalsHost)\n    return new IndexedDBInternalsUI(web_ui);\n  if (url.host() == kChromeUIMediaInternalsHost)\n    return new MediaInternalsUI(web_ui);\n  if (url.host() == kChromeUIAccessibilityHost)\n    return new AccessibilityUI(web_ui);\n  if (url.host() == kChromeUIServiceWorkerInternalsHost)\n    return new ServiceWorkerInternalsUI(web_ui);\n#if !defined(OS_ANDROID)\n  if (url.host() == kChromeUITracingHost)\n    return new TracingUI(web_ui);\n#endif\n\n#if defined(ENABLE_WEBRTC)\n  if (url.host() == kChromeUIWebRTCInternalsHost)\n    return new WebRTCInternalsUI(web_ui);\n#endif\n\n  return nullptr;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,8 @@\n WebUIController* ContentWebUIControllerFactory::CreateWebUIControllerForURL(\n     WebUI* web_ui, const GURL& url) const {\n+  if (!url.SchemeIs(kChromeUIScheme))\n+    return nullptr;\n+\n   if (url.host() == kChromeUIGpuHost)\n     return new GpuInternalsUI(web_ui);\n   if (url.host() == kChromeUIIndexedDBInternalsHost)\n@@ -20,5 +23,5 @@\n     return new WebRTCInternalsUI(web_ui);\n #endif\n \n-  return NULL;\n+  return nullptr;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "  return NULL;"
            ],
            "added_lines": [
                "  if (!url.SchemeIs(kChromeUIScheme))",
                "    return nullptr;",
                "",
                "  return nullptr;"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-1266",
        "func_name": "chromium/ContentWebUIControllerFactory::GetWebUIType",
        "description": "content/browser/webui/content_web_ui_controller_factory.cc in Google Chrome before 43.0.2357.130 does not properly consider the scheme in determining whether a URL is associated with a WebUI SiteInstance, which allows remote attackers to bypass intended access restrictions via a similar URL, as demonstrated by use of http://gpu when there is a WebUI class for handling chrome://gpu requests.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/7cdcf50b4ae3858f5132a1bb0d4cb5e104527b42",
        "commit_title": "Don't treat http://gpu as a WebUI url",
        "commit_text": "   ",
        "func_before": "WebUI::TypeID ContentWebUIControllerFactory::GetWebUIType(\n      BrowserContext* browser_context, const GURL& url) const {\n  if (url.host() == kChromeUIWebRTCInternalsHost ||\n#if !defined(OS_ANDROID)\n      url.host() == kChromeUITracingHost ||\n#endif\n      url.host() == kChromeUIGpuHost ||\n      url.host() == kChromeUIIndexedDBInternalsHost ||\n      url.host() == kChromeUIMediaInternalsHost ||\n      url.host() == kChromeUIServiceWorkerInternalsHost ||\n      url.host() == kChromeUIAccessibilityHost) {\n    return const_cast<ContentWebUIControllerFactory*>(this);\n  }\n  return WebUI::kNoWebUI;\n}",
        "func": "WebUI::TypeID ContentWebUIControllerFactory::GetWebUIType(\n      BrowserContext* browser_context, const GURL& url) const {\n  if (!url.SchemeIs(kChromeUIScheme))\n    return WebUI::kNoWebUI;\n\n  if (url.host() == kChromeUIWebRTCInternalsHost ||\n#if !defined(OS_ANDROID)\n      url.host() == kChromeUITracingHost ||\n#endif\n      url.host() == kChromeUIGpuHost ||\n      url.host() == kChromeUIIndexedDBInternalsHost ||\n      url.host() == kChromeUIMediaInternalsHost ||\n      url.host() == kChromeUIServiceWorkerInternalsHost ||\n      url.host() == kChromeUIAccessibilityHost) {\n    return const_cast<ContentWebUIControllerFactory*>(this);\n  }\n  return WebUI::kNoWebUI;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,8 @@\n WebUI::TypeID ContentWebUIControllerFactory::GetWebUIType(\n       BrowserContext* browser_context, const GURL& url) const {\n+  if (!url.SchemeIs(kChromeUIScheme))\n+    return WebUI::kNoWebUI;\n+\n   if (url.host() == kChromeUIWebRTCInternalsHost ||\n #if !defined(OS_ANDROID)\n       url.host() == kChromeUITracingHost ||",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "  if (!url.SchemeIs(kChromeUIScheme))",
                "    return WebUI::kNoWebUI;",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2015-1267",
        "func_name": "chromium/WebArrayBufferConverter::toV8Value",
        "description": "Blink, as used in Google Chrome before 43.0.2357.130, does not properly restrict the creation context during creation of a DOM wrapper, which allows remote attackers to bypass the Same Origin Policy via crafted JavaScript code that uses a Blink public API, related to WebArrayBufferConverter.cpp, WebBlob.cpp, WebDOMError.cpp, and WebDOMFileSystem.cpp.",
        "git_url": "https://github.com/chromium/chromium/commit/ca9573d5b634524afefe1e65bb905b89b6545970",
        "commit_title": "bindings: Stop using the given creationContext in public APIs.",
        "commit_text": " The creation context passed through the public APIs may be unsafe and faked by user script.  The callers of the APIs often do not check if the context is safe and valid or not.  Plus, there shouldn't be a case that a caller needs to handle cross-origin cases, so let us always use the current context instead of the creation context given through the callers, which are not reliable.   ",
        "func_before": "v8::Local<v8::Value> WebArrayBufferConverter::toV8Value(WebArrayBuffer* buffer, v8::Local<v8::Object> creationContext, v8::Isolate* isolate)\n{\n    if (!buffer)\n        return v8::Local<v8::Value>();\n    return toV8(PassRefPtr<DOMArrayBuffer>(*buffer), creationContext, isolate);\n}",
        "func": "v8::Local<v8::Value> WebArrayBufferConverter::toV8Value(WebArrayBuffer* buffer, v8::Local<v8::Object> /* creationContext */, v8::Isolate* isolate)\n{\n    // We no longer use |creationContext| because it's often misused and points\n    // to a context faked by user script.\n    if (!buffer)\n        return v8::Local<v8::Value>();\n    return toV8(PassRefPtr<DOMArrayBuffer>(*buffer), isolate->GetCurrentContext()->Global(), isolate);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,8 @@\n-v8::Local<v8::Value> WebArrayBufferConverter::toV8Value(WebArrayBuffer* buffer, v8::Local<v8::Object> creationContext, v8::Isolate* isolate)\n+v8::Local<v8::Value> WebArrayBufferConverter::toV8Value(WebArrayBuffer* buffer, v8::Local<v8::Object> /* creationContext */, v8::Isolate* isolate)\n {\n+    // We no longer use |creationContext| because it's often misused and points\n+    // to a context faked by user script.\n     if (!buffer)\n         return v8::Local<v8::Value>();\n-    return toV8(PassRefPtr<DOMArrayBuffer>(*buffer), creationContext, isolate);\n+    return toV8(PassRefPtr<DOMArrayBuffer>(*buffer), isolate->GetCurrentContext()->Global(), isolate);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "v8::Local<v8::Value> WebArrayBufferConverter::toV8Value(WebArrayBuffer* buffer, v8::Local<v8::Object> creationContext, v8::Isolate* isolate)",
                "    return toV8(PassRefPtr<DOMArrayBuffer>(*buffer), creationContext, isolate);"
            ],
            "added_lines": [
                "v8::Local<v8::Value> WebArrayBufferConverter::toV8Value(WebArrayBuffer* buffer, v8::Local<v8::Object> /* creationContext */, v8::Isolate* isolate)",
                "    // We no longer use |creationContext| because it's often misused and points",
                "    // to a context faked by user script.",
                "    return toV8(PassRefPtr<DOMArrayBuffer>(*buffer), isolate->GetCurrentContext()->Global(), isolate);"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-1267",
        "func_name": "chromium/WebDOMError::toV8Value",
        "description": "Blink, as used in Google Chrome before 43.0.2357.130, does not properly restrict the creation context during creation of a DOM wrapper, which allows remote attackers to bypass the Same Origin Policy via crafted JavaScript code that uses a Blink public API, related to WebArrayBufferConverter.cpp, WebBlob.cpp, WebDOMError.cpp, and WebDOMFileSystem.cpp.",
        "git_url": "https://github.com/chromium/chromium/commit/ca9573d5b634524afefe1e65bb905b89b6545970",
        "commit_title": "bindings: Stop using the given creationContext in public APIs.",
        "commit_text": " The creation context passed through the public APIs may be unsafe and faked by user script.  The callers of the APIs often do not check if the context is safe and valid or not.  Plus, there shouldn't be a case that a caller needs to handle cross-origin cases, so let us always use the current context instead of the creation context given through the callers, which are not reliable.   ",
        "func_before": "v8::Local<v8::Value>  WebDOMError::toV8Value(v8::Local<v8::Object> creationContext, v8::Isolate* isolate)\n{\n    if (!m_private.get())\n        return v8::Local<v8::Value>();\n    return toV8(m_private.get(), creationContext, isolate);\n}",
        "func": "v8::Local<v8::Value>  WebDOMError::toV8Value(v8::Local<v8::Object> /* creationContext */, v8::Isolate* isolate)\n{\n    // We no longer use |creationContext| because it's often misused and points\n    // to a context faked by user script.\n    if (!m_private.get())\n        return v8::Local<v8::Value>();\n    return toV8(m_private.get(), isolate->GetCurrentContext()->Global(), isolate);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,8 @@\n-v8::Local<v8::Value>  WebDOMError::toV8Value(v8::Local<v8::Object> creationContext, v8::Isolate* isolate)\n+v8::Local<v8::Value>  WebDOMError::toV8Value(v8::Local<v8::Object> /* creationContext */, v8::Isolate* isolate)\n {\n+    // We no longer use |creationContext| because it's often misused and points\n+    // to a context faked by user script.\n     if (!m_private.get())\n         return v8::Local<v8::Value>();\n-    return toV8(m_private.get(), creationContext, isolate);\n+    return toV8(m_private.get(), isolate->GetCurrentContext()->Global(), isolate);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "v8::Local<v8::Value>  WebDOMError::toV8Value(v8::Local<v8::Object> creationContext, v8::Isolate* isolate)",
                "    return toV8(m_private.get(), creationContext, isolate);"
            ],
            "added_lines": [
                "v8::Local<v8::Value>  WebDOMError::toV8Value(v8::Local<v8::Object> /* creationContext */, v8::Isolate* isolate)",
                "    // We no longer use |creationContext| because it's often misused and points",
                "    // to a context faked by user script.",
                "    return toV8(m_private.get(), isolate->GetCurrentContext()->Global(), isolate);"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-1267",
        "func_name": "chromium/WebDOMFileSystem::createV8Entry",
        "description": "Blink, as used in Google Chrome before 43.0.2357.130, does not properly restrict the creation context during creation of a DOM wrapper, which allows remote attackers to bypass the Same Origin Policy via crafted JavaScript code that uses a Blink public API, related to WebArrayBufferConverter.cpp, WebBlob.cpp, WebDOMError.cpp, and WebDOMFileSystem.cpp.",
        "git_url": "https://github.com/chromium/chromium/commit/ca9573d5b634524afefe1e65bb905b89b6545970",
        "commit_title": "bindings: Stop using the given creationContext in public APIs.",
        "commit_text": " The creation context passed through the public APIs may be unsafe and faked by user script.  The callers of the APIs often do not check if the context is safe and valid or not.  Plus, there shouldn't be a case that a caller needs to handle cross-origin cases, so let us always use the current context instead of the creation context given through the callers, which are not reliable.   ",
        "func_before": "v8::Local<v8::Value> WebDOMFileSystem::createV8Entry(\n    const WebString& path,\n    EntryType entryType,\n    v8::Local<v8::Object> creationContext,\n    v8::Isolate* isolate)\n{\n    if (!m_private.get())\n        return v8::Local<v8::Value>();\n    if (entryType == EntryTypeDirectory)\n        return toV8(DirectoryEntry::create(m_private.get(), path), creationContext, isolate);\n    ASSERT(entryType == EntryTypeFile);\n    return toV8(FileEntry::create(m_private.get(), path), creationContext, isolate);\n}",
        "func": "v8::Local<v8::Value> WebDOMFileSystem::createV8Entry(\n    const WebString& path,\n    EntryType entryType,\n    v8::Local<v8::Object> creationContext,\n    v8::Isolate* isolate)\n{\n    if (!m_private.get())\n        return v8::Local<v8::Value>();\n    if (entryType == EntryTypeDirectory)\n        return toV8(DirectoryEntry::create(m_private.get(), path), isolate->GetCurrentContext()->Global(), isolate);\n    ASSERT(entryType == EntryTypeFile);\n    return toV8(FileEntry::create(m_private.get(), path), isolate->GetCurrentContext()->Global(), isolate);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -7,7 +7,7 @@\n     if (!m_private.get())\n         return v8::Local<v8::Value>();\n     if (entryType == EntryTypeDirectory)\n-        return toV8(DirectoryEntry::create(m_private.get(), path), creationContext, isolate);\n+        return toV8(DirectoryEntry::create(m_private.get(), path), isolate->GetCurrentContext()->Global(), isolate);\n     ASSERT(entryType == EntryTypeFile);\n-    return toV8(FileEntry::create(m_private.get(), path), creationContext, isolate);\n+    return toV8(FileEntry::create(m_private.get(), path), isolate->GetCurrentContext()->Global(), isolate);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "        return toV8(DirectoryEntry::create(m_private.get(), path), creationContext, isolate);",
                "    return toV8(FileEntry::create(m_private.get(), path), creationContext, isolate);"
            ],
            "added_lines": [
                "        return toV8(DirectoryEntry::create(m_private.get(), path), isolate->GetCurrentContext()->Global(), isolate);",
                "    return toV8(FileEntry::create(m_private.get(), path), isolate->GetCurrentContext()->Global(), isolate);"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-1267",
        "func_name": "chromium/WebDOMFileSystem::toV8Value",
        "description": "Blink, as used in Google Chrome before 43.0.2357.130, does not properly restrict the creation context during creation of a DOM wrapper, which allows remote attackers to bypass the Same Origin Policy via crafted JavaScript code that uses a Blink public API, related to WebArrayBufferConverter.cpp, WebBlob.cpp, WebDOMError.cpp, and WebDOMFileSystem.cpp.",
        "git_url": "https://github.com/chromium/chromium/commit/ca9573d5b634524afefe1e65bb905b89b6545970",
        "commit_title": "bindings: Stop using the given creationContext in public APIs.",
        "commit_text": " The creation context passed through the public APIs may be unsafe and faked by user script.  The callers of the APIs often do not check if the context is safe and valid or not.  Plus, there shouldn't be a case that a caller needs to handle cross-origin cases, so let us always use the current context instead of the creation context given through the callers, which are not reliable.   ",
        "func_before": "v8::Local<v8::Value> WebDOMFileSystem::toV8Value(v8::Local<v8::Object> creationContext, v8::Isolate* isolate)\n{\n    if (!m_private.get())\n        return v8::Local<v8::Value>();\n    return toV8(m_private.get(), creationContext, isolate);\n}",
        "func": "v8::Local<v8::Value> WebDOMFileSystem::toV8Value(v8::Local<v8::Object> /* creationContext */, v8::Isolate* isolate)\n{\n    // We no longer use |creationContext| because it's often misused and points\n    // to a context faked by user script.\n    if (!m_private.get())\n        return v8::Local<v8::Value>();\n    return toV8(m_private.get(), isolate->GetCurrentContext()->Global(), isolate);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,8 @@\n-v8::Local<v8::Value> WebDOMFileSystem::toV8Value(v8::Local<v8::Object> creationContext, v8::Isolate* isolate)\n+v8::Local<v8::Value> WebDOMFileSystem::toV8Value(v8::Local<v8::Object> /* creationContext */, v8::Isolate* isolate)\n {\n+    // We no longer use |creationContext| because it's often misused and points\n+    // to a context faked by user script.\n     if (!m_private.get())\n         return v8::Local<v8::Value>();\n-    return toV8(m_private.get(), creationContext, isolate);\n+    return toV8(m_private.get(), isolate->GetCurrentContext()->Global(), isolate);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "v8::Local<v8::Value> WebDOMFileSystem::toV8Value(v8::Local<v8::Object> creationContext, v8::Isolate* isolate)",
                "    return toV8(m_private.get(), creationContext, isolate);"
            ],
            "added_lines": [
                "v8::Local<v8::Value> WebDOMFileSystem::toV8Value(v8::Local<v8::Object> /* creationContext */, v8::Isolate* isolate)",
                "    // We no longer use |creationContext| because it's often misused and points",
                "    // to a context faked by user script.",
                "    return toV8(m_private.get(), isolate->GetCurrentContext()->Global(), isolate);"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-1267",
        "func_name": "chromium/WebBlob::toV8Value",
        "description": "Blink, as used in Google Chrome before 43.0.2357.130, does not properly restrict the creation context during creation of a DOM wrapper, which allows remote attackers to bypass the Same Origin Policy via crafted JavaScript code that uses a Blink public API, related to WebArrayBufferConverter.cpp, WebBlob.cpp, WebDOMError.cpp, and WebDOMFileSystem.cpp.",
        "git_url": "https://github.com/chromium/chromium/commit/ca9573d5b634524afefe1e65bb905b89b6545970",
        "commit_title": "bindings: Stop using the given creationContext in public APIs.",
        "commit_text": " The creation context passed through the public APIs may be unsafe and faked by user script.  The callers of the APIs often do not check if the context is safe and valid or not.  Plus, there shouldn't be a case that a caller needs to handle cross-origin cases, so let us always use the current context instead of the creation context given through the callers, which are not reliable.   ",
        "func_before": "v8::Local<v8::Value> WebBlob::toV8Value(v8::Local<v8::Object> creationContext, v8::Isolate* isolate)\n{\n    if (!m_private.get())\n        return v8::Local<v8::Value>();\n    return toV8(m_private.get(), creationContext, isolate);\n}",
        "func": "v8::Local<v8::Value> WebBlob::toV8Value(v8::Local<v8::Object> /* creationContext */, v8::Isolate* isolate)\n{\n    // We no longer use |creationContext| because it's often misused and points\n    // to a context faked by user script.\n    if (!m_private.get())\n        return v8::Local<v8::Value>();\n    return toV8(m_private.get(), isolate->GetCurrentContext()->Global(), isolate);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,8 @@\n-v8::Local<v8::Value> WebBlob::toV8Value(v8::Local<v8::Object> creationContext, v8::Isolate* isolate)\n+v8::Local<v8::Value> WebBlob::toV8Value(v8::Local<v8::Object> /* creationContext */, v8::Isolate* isolate)\n {\n+    // We no longer use |creationContext| because it's often misused and points\n+    // to a context faked by user script.\n     if (!m_private.get())\n         return v8::Local<v8::Value>();\n-    return toV8(m_private.get(), creationContext, isolate);\n+    return toV8(m_private.get(), isolate->GetCurrentContext()->Global(), isolate);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "v8::Local<v8::Value> WebBlob::toV8Value(v8::Local<v8::Object> creationContext, v8::Isolate* isolate)",
                "    return toV8(m_private.get(), creationContext, isolate);"
            ],
            "added_lines": [
                "v8::Local<v8::Value> WebBlob::toV8Value(v8::Local<v8::Object> /* creationContext */, v8::Isolate* isolate)",
                "    // We no longer use |creationContext| because it's often misused and points",
                "    // to a context faked by user script.",
                "    return toV8(m_private.get(), isolate->GetCurrentContext()->Global(), isolate);"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-1267",
        "func_name": "chromium/AppRuntimeCustomBindings::AppRuntimeCustomBindings",
        "description": "Blink, as used in Google Chrome before 43.0.2357.130, does not properly restrict the creation context during creation of a DOM wrapper, which allows remote attackers to bypass the Same Origin Policy via crafted JavaScript code that uses a Blink public API, related to WebArrayBufferConverter.cpp, WebBlob.cpp, WebDOMError.cpp, and WebDOMFileSystem.cpp.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/42bd05a2bf4260f500687a2457d01e298033f2bb",
        "commit_title": "blink:bindings: Passes the global context instead of |this| in JS.",
        "commit_text": " |this| in JS (args.Holder() in C++ code) is not a reliable object.  User script can pass any object as |this|.  So we shouldn't use it as creation context when calling Blink APIs to create a new DOM wrapper.  We should instead use the current context where the user script is running as creation context.    ",
        "func_before": "AppRuntimeCustomBindings::AppRuntimeCustomBindings(ScriptContext* context)\n    : ObjectBackedNativeHandler(context) {\n  RouteFunction(\"DeserializeString\", base::Bind(&DeserializeString));\n  RouteFunction(\"SerializeToString\", base::Bind(&SerializeToString));\n  RouteFunction(\"CreateBlob\", base::Bind(&CreateBlob));\n}",
        "func": "AppRuntimeCustomBindings::AppRuntimeCustomBindings(ScriptContext* context)\n    : ObjectBackedNativeHandler(context) {\n  RouteFunction(\"DeserializeString\", base::Bind(&DeserializeString));\n  RouteFunction(\"SerializeToString\", base::Bind(&SerializeToString));\n  RouteFunction(\"CreateBlob\", base::Bind(&AppRuntimeCustomBindings::CreateBlob,\n                                         base::Unretained(this)));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,5 +2,6 @@\n     : ObjectBackedNativeHandler(context) {\n   RouteFunction(\"DeserializeString\", base::Bind(&DeserializeString));\n   RouteFunction(\"SerializeToString\", base::Bind(&SerializeToString));\n-  RouteFunction(\"CreateBlob\", base::Bind(&CreateBlob));\n+  RouteFunction(\"CreateBlob\", base::Bind(&AppRuntimeCustomBindings::CreateBlob,\n+                                         base::Unretained(this)));\n }",
        "diff_line_info": {
            "deleted_lines": [
                "  RouteFunction(\"CreateBlob\", base::Bind(&CreateBlob));"
            ],
            "added_lines": [
                "  RouteFunction(\"CreateBlob\", base::Bind(&AppRuntimeCustomBindings::CreateBlob,",
                "                                         base::Unretained(this)));"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-1267",
        "func_name": "chromium/PageCaptureCustomBindings::CreateBlob",
        "description": "Blink, as used in Google Chrome before 43.0.2357.130, does not properly restrict the creation context during creation of a DOM wrapper, which allows remote attackers to bypass the Same Origin Policy via crafted JavaScript code that uses a Blink public API, related to WebArrayBufferConverter.cpp, WebBlob.cpp, WebDOMError.cpp, and WebDOMFileSystem.cpp.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/42bd05a2bf4260f500687a2457d01e298033f2bb",
        "commit_title": "blink:bindings: Passes the global context instead of |this| in JS.",
        "commit_text": " |this| in JS (args.Holder() in C++ code) is not a reliable object.  User script can pass any object as |this|.  So we shouldn't use it as creation context when calling Blink APIs to create a new DOM wrapper.  We should instead use the current context where the user script is running as creation context.    ",
        "func_before": "void PageCaptureCustomBindings::CreateBlob(\n    const v8::FunctionCallbackInfo<v8::Value>& args) {\n  CHECK(args.Length() == 2);\n  CHECK(args[0]->IsString());\n  CHECK(args[1]->IsInt32());\n  blink::WebString path(base::UTF8ToUTF16(*v8::String::Utf8Value(args[0])));\n  blink::WebBlob blob =\n      blink::WebBlob::createFromFile(path, args[1]->Int32Value());\n  args.GetReturnValue().Set(blob.toV8Value(args.Holder(), args.GetIsolate()));\n}",
        "func": "void PageCaptureCustomBindings::CreateBlob(\n    const v8::FunctionCallbackInfo<v8::Value>& args) {\n  CHECK(args.Length() == 2);\n  CHECK(args[0]->IsString());\n  CHECK(args[1]->IsInt32());\n  blink::WebString path(base::UTF8ToUTF16(*v8::String::Utf8Value(args[0])));\n  blink::WebBlob blob =\n      blink::WebBlob::createFromFile(path, args[1]->Int32Value());\n  args.GetReturnValue().Set(\n      blob.toV8Value(context()->v8_context()->Global(), args.GetIsolate()));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,5 +6,6 @@\n   blink::WebString path(base::UTF8ToUTF16(*v8::String::Utf8Value(args[0])));\n   blink::WebBlob blob =\n       blink::WebBlob::createFromFile(path, args[1]->Int32Value());\n-  args.GetReturnValue().Set(blob.toV8Value(args.Holder(), args.GetIsolate()));\n+  args.GetReturnValue().Set(\n+      blob.toV8Value(context()->v8_context()->Global(), args.GetIsolate()));\n }",
        "diff_line_info": {
            "deleted_lines": [
                "  args.GetReturnValue().Set(blob.toV8Value(args.Holder(), args.GetIsolate()));"
            ],
            "added_lines": [
                "  args.GetReturnValue().Set(",
                "      blob.toV8Value(context()->v8_context()->Global(), args.GetIsolate()));"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-1267",
        "func_name": "chromium/MediaGalleriesCustomBindings::MediaGalleriesCustomBindings",
        "description": "Blink, as used in Google Chrome before 43.0.2357.130, does not properly restrict the creation context during creation of a DOM wrapper, which allows remote attackers to bypass the Same Origin Policy via crafted JavaScript code that uses a Blink public API, related to WebArrayBufferConverter.cpp, WebBlob.cpp, WebDOMError.cpp, and WebDOMFileSystem.cpp.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/42bd05a2bf4260f500687a2457d01e298033f2bb",
        "commit_title": "blink:bindings: Passes the global context instead of |this| in JS.",
        "commit_text": " |this| in JS (args.Holder() in C++ code) is not a reliable object.  User script can pass any object as |this|.  So we shouldn't use it as creation context when calling Blink APIs to create a new DOM wrapper.  We should instead use the current context where the user script is running as creation context.    ",
        "func_before": "MediaGalleriesCustomBindings::MediaGalleriesCustomBindings(\n    ScriptContext* context)\n    : ObjectBackedNativeHandler(context) {\n  RouteFunction(\"GetMediaFileSystemObject\",\n                base::Bind(&GetMediaFileSystemObject));\n}",
        "func": "MediaGalleriesCustomBindings::MediaGalleriesCustomBindings(\n    ScriptContext* context)\n    : ObjectBackedNativeHandler(context) {\n  RouteFunction(\n      \"GetMediaFileSystemObject\",\n      base::Bind(&MediaGalleriesCustomBindings::GetMediaFileSystemObject,\n                 base::Unretained(this)));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,8 @@\n MediaGalleriesCustomBindings::MediaGalleriesCustomBindings(\n     ScriptContext* context)\n     : ObjectBackedNativeHandler(context) {\n-  RouteFunction(\"GetMediaFileSystemObject\",\n-                base::Bind(&GetMediaFileSystemObject));\n+  RouteFunction(\n+      \"GetMediaFileSystemObject\",\n+      base::Bind(&MediaGalleriesCustomBindings::GetMediaFileSystemObject,\n+                 base::Unretained(this)));\n }",
        "diff_line_info": {
            "deleted_lines": [
                "  RouteFunction(\"GetMediaFileSystemObject\",",
                "                base::Bind(&GetMediaFileSystemObject));"
            ],
            "added_lines": [
                "  RouteFunction(",
                "      \"GetMediaFileSystemObject\",",
                "      base::Bind(&MediaGalleriesCustomBindings::GetMediaFileSystemObject,",
                "                 base::Unretained(this)));"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-1267",
        "func_name": "chromium/BlobNativeHandler::BlobNativeHandler",
        "description": "Blink, as used in Google Chrome before 43.0.2357.130, does not properly restrict the creation context during creation of a DOM wrapper, which allows remote attackers to bypass the Same Origin Policy via crafted JavaScript code that uses a Blink public API, related to WebArrayBufferConverter.cpp, WebBlob.cpp, WebDOMError.cpp, and WebDOMFileSystem.cpp.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/42bd05a2bf4260f500687a2457d01e298033f2bb",
        "commit_title": "blink:bindings: Passes the global context instead of |this| in JS.",
        "commit_text": " |this| in JS (args.Holder() in C++ code) is not a reliable object.  User script can pass any object as |this|.  So we shouldn't use it as creation context when calling Blink APIs to create a new DOM wrapper.  We should instead use the current context where the user script is running as creation context.    ",
        "func_before": "BlobNativeHandler::BlobNativeHandler(ScriptContext* context)\n    : ObjectBackedNativeHandler(context) {\n  RouteFunction(\"GetBlobUuid\", base::Bind(&GetBlobUuid));\n  RouteFunction(\"TakeBrowserProcessBlob\", base::Bind(&TakeBrowserProcessBlob));\n}",
        "func": "BlobNativeHandler::BlobNativeHandler(ScriptContext* context)\n    : ObjectBackedNativeHandler(context) {\n  RouteFunction(\"GetBlobUuid\", base::Bind(&GetBlobUuid));\n  RouteFunction(\"TakeBrowserProcessBlob\",\n                base::Bind(&BlobNativeHandler::TakeBrowserProcessBlob,\n                           base::Unretained(this)));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,7 @@\n BlobNativeHandler::BlobNativeHandler(ScriptContext* context)\n     : ObjectBackedNativeHandler(context) {\n   RouteFunction(\"GetBlobUuid\", base::Bind(&GetBlobUuid));\n-  RouteFunction(\"TakeBrowserProcessBlob\", base::Bind(&TakeBrowserProcessBlob));\n+  RouteFunction(\"TakeBrowserProcessBlob\",\n+                base::Bind(&BlobNativeHandler::TakeBrowserProcessBlob,\n+                           base::Unretained(this)));\n }",
        "diff_line_info": {
            "deleted_lines": [
                "  RouteFunction(\"TakeBrowserProcessBlob\", base::Bind(&TakeBrowserProcessBlob));"
            ],
            "added_lines": [
                "  RouteFunction(\"TakeBrowserProcessBlob\",",
                "                base::Bind(&BlobNativeHandler::TakeBrowserProcessBlob,",
                "                           base::Unretained(this)));"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-1267",
        "func_name": "chromium/SyncFileSystemCustomBindings::GetSyncFileSystemObject",
        "description": "Blink, as used in Google Chrome before 43.0.2357.130, does not properly restrict the creation context during creation of a DOM wrapper, which allows remote attackers to bypass the Same Origin Policy via crafted JavaScript code that uses a Blink public API, related to WebArrayBufferConverter.cpp, WebBlob.cpp, WebDOMError.cpp, and WebDOMFileSystem.cpp.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/42bd05a2bf4260f500687a2457d01e298033f2bb",
        "commit_title": "blink:bindings: Passes the global context instead of |this| in JS.",
        "commit_text": " |this| in JS (args.Holder() in C++ code) is not a reliable object.  User script can pass any object as |this|.  So we shouldn't use it as creation context when calling Blink APIs to create a new DOM wrapper.  We should instead use the current context where the user script is running as creation context.    ",
        "func_before": "void SyncFileSystemCustomBindings::GetSyncFileSystemObject(\n    const v8::FunctionCallbackInfo<v8::Value>& args) {\n  if (args.Length() != 2) {\n    NOTREACHED();\n    return;\n  }\n  if (!args[0]->IsString()) {\n    NOTREACHED();\n    return;\n  }\n  if (!args[1]->IsString()) {\n    NOTREACHED();\n    return;\n  }\n\n  std::string name(*v8::String::Utf8Value(args[0]));\n  if (name.empty()) {\n    NOTREACHED();\n    return;\n  }\n  std::string root_url(*v8::String::Utf8Value(args[1]));\n  if (root_url.empty()) {\n    NOTREACHED();\n    return;\n  }\n\n  blink::WebLocalFrame* webframe =\n      blink::WebLocalFrame::frameForContext(context()->v8_context());\n  args.GetReturnValue().Set(\n      blink::WebDOMFileSystem::create(webframe,\n                                      blink::WebFileSystemTypeExternal,\n                                      blink::WebString::fromUTF8(name),\n                                      GURL(root_url))\n          .toV8Value(args.Holder(), args.GetIsolate()));\n}",
        "func": "void SyncFileSystemCustomBindings::GetSyncFileSystemObject(\n    const v8::FunctionCallbackInfo<v8::Value>& args) {\n  if (args.Length() != 2) {\n    NOTREACHED();\n    return;\n  }\n  if (!args[0]->IsString()) {\n    NOTREACHED();\n    return;\n  }\n  if (!args[1]->IsString()) {\n    NOTREACHED();\n    return;\n  }\n\n  std::string name(*v8::String::Utf8Value(args[0]));\n  if (name.empty()) {\n    NOTREACHED();\n    return;\n  }\n  std::string root_url(*v8::String::Utf8Value(args[1]));\n  if (root_url.empty()) {\n    NOTREACHED();\n    return;\n  }\n\n  blink::WebLocalFrame* webframe =\n      blink::WebLocalFrame::frameForContext(context()->v8_context());\n  args.GetReturnValue().Set(\n      blink::WebDOMFileSystem::create(webframe,\n                                      blink::WebFileSystemTypeExternal,\n                                      blink::WebString::fromUTF8(name),\n                                      GURL(root_url))\n          .toV8Value(context()->v8_context()->Global(), args.GetIsolate()));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -31,5 +31,5 @@\n                                       blink::WebFileSystemTypeExternal,\n                                       blink::WebString::fromUTF8(name),\n                                       GURL(root_url))\n-          .toV8Value(args.Holder(), args.GetIsolate()));\n+          .toV8Value(context()->v8_context()->Global(), args.GetIsolate()));\n }",
        "diff_line_info": {
            "deleted_lines": [
                "          .toV8Value(args.Holder(), args.GetIsolate()));"
            ],
            "added_lines": [
                "          .toV8Value(context()->v8_context()->Global(), args.GetIsolate()));"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-1267",
        "func_name": "chromium/FileSystemNatives::GetFileEntry",
        "description": "Blink, as used in Google Chrome before 43.0.2357.130, does not properly restrict the creation context during creation of a DOM wrapper, which allows remote attackers to bypass the Same Origin Policy via crafted JavaScript code that uses a Blink public API, related to WebArrayBufferConverter.cpp, WebBlob.cpp, WebDOMError.cpp, and WebDOMFileSystem.cpp.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/42bd05a2bf4260f500687a2457d01e298033f2bb",
        "commit_title": "blink:bindings: Passes the global context instead of |this| in JS.",
        "commit_text": " |this| in JS (args.Holder() in C++ code) is not a reliable object.  User script can pass any object as |this|.  So we shouldn't use it as creation context when calling Blink APIs to create a new DOM wrapper.  We should instead use the current context where the user script is running as creation context.    ",
        "func_before": "void FileSystemNatives::GetFileEntry(\n    const v8::FunctionCallbackInfo<v8::Value>& args) {\n  DCHECK(args.Length() == 5);\n  DCHECK(args[0]->IsString());\n  std::string type_string = *v8::String::Utf8Value(args[0]);\n  blink::WebFileSystemType type;\n  bool is_valid_type = storage::GetFileSystemPublicType(type_string, &type);\n  DCHECK(is_valid_type);\n  if (is_valid_type == false) {\n    return;\n  }\n\n  DCHECK(args[1]->IsString());\n  DCHECK(args[2]->IsString());\n  DCHECK(args[3]->IsString());\n  std::string file_system_name(*v8::String::Utf8Value(args[1]));\n  GURL file_system_root_url(*v8::String::Utf8Value(args[2]));\n  std::string file_path_string(*v8::String::Utf8Value(args[3]));\n  base::FilePath file_path = base::FilePath::FromUTF8Unsafe(file_path_string);\n  DCHECK(storage::VirtualPath::IsAbsolute(file_path.value()));\n\n  DCHECK(args[4]->IsBoolean());\n  blink::WebDOMFileSystem::EntryType entry_type =\n      args[4]->BooleanValue() ? blink::WebDOMFileSystem::EntryTypeDirectory\n                              : blink::WebDOMFileSystem::EntryTypeFile;\n\n  blink::WebLocalFrame* webframe =\n      blink::WebLocalFrame::frameForContext(context()->v8_context());\n  DCHECK(webframe);\n  args.GetReturnValue().Set(\n      blink::WebDOMFileSystem::create(\n          webframe,\n          type,\n          blink::WebString::fromUTF8(file_system_name),\n          file_system_root_url)\n          .createV8Entry(blink::WebString::fromUTF8(file_path_string),\n                         entry_type,\n                         args.Holder(),\n                         args.GetIsolate()));\n}",
        "func": "void FileSystemNatives::GetFileEntry(\n    const v8::FunctionCallbackInfo<v8::Value>& args) {\n  DCHECK(args.Length() == 5);\n  DCHECK(args[0]->IsString());\n  std::string type_string = *v8::String::Utf8Value(args[0]);\n  blink::WebFileSystemType type;\n  bool is_valid_type = storage::GetFileSystemPublicType(type_string, &type);\n  DCHECK(is_valid_type);\n  if (is_valid_type == false) {\n    return;\n  }\n\n  DCHECK(args[1]->IsString());\n  DCHECK(args[2]->IsString());\n  DCHECK(args[3]->IsString());\n  std::string file_system_name(*v8::String::Utf8Value(args[1]));\n  GURL file_system_root_url(*v8::String::Utf8Value(args[2]));\n  std::string file_path_string(*v8::String::Utf8Value(args[3]));\n  base::FilePath file_path = base::FilePath::FromUTF8Unsafe(file_path_string);\n  DCHECK(storage::VirtualPath::IsAbsolute(file_path.value()));\n\n  DCHECK(args[4]->IsBoolean());\n  blink::WebDOMFileSystem::EntryType entry_type =\n      args[4]->BooleanValue() ? blink::WebDOMFileSystem::EntryTypeDirectory\n                              : blink::WebDOMFileSystem::EntryTypeFile;\n\n  blink::WebLocalFrame* webframe =\n      blink::WebLocalFrame::frameForContext(context()->v8_context());\n  DCHECK(webframe);\n  args.GetReturnValue().Set(\n      blink::WebDOMFileSystem::create(\n          webframe,\n          type,\n          blink::WebString::fromUTF8(file_system_name),\n          file_system_root_url)\n          .createV8Entry(blink::WebString::fromUTF8(file_path_string),\n                         entry_type,\n                         context()->v8_context()->Global(),\n                         args.GetIsolate()));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -35,6 +35,6 @@\n           file_system_root_url)\n           .createV8Entry(blink::WebString::fromUTF8(file_path_string),\n                          entry_type,\n-                         args.Holder(),\n+                         context()->v8_context()->Global(),\n                          args.GetIsolate()));\n }",
        "diff_line_info": {
            "deleted_lines": [
                "                         args.Holder(),"
            ],
            "added_lines": [
                "                         context()->v8_context()->Global(),"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-1267",
        "func_name": "chromium/FileSystemNatives::GetDOMError",
        "description": "Blink, as used in Google Chrome before 43.0.2357.130, does not properly restrict the creation context during creation of a DOM wrapper, which allows remote attackers to bypass the Same Origin Policy via crafted JavaScript code that uses a Blink public API, related to WebArrayBufferConverter.cpp, WebBlob.cpp, WebDOMError.cpp, and WebDOMFileSystem.cpp.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/42bd05a2bf4260f500687a2457d01e298033f2bb",
        "commit_title": "blink:bindings: Passes the global context instead of |this| in JS.",
        "commit_text": " |this| in JS (args.Holder() in C++ code) is not a reliable object.  User script can pass any object as |this|.  So we shouldn't use it as creation context when calling Blink APIs to create a new DOM wrapper.  We should instead use the current context where the user script is running as creation context.    ",
        "func_before": "void FileSystemNatives::GetDOMError(\n    const v8::FunctionCallbackInfo<v8::Value>& args) {\n  if (args.Length() != 2) {\n    NOTREACHED();\n    return;\n  }\n  if (!args[0]->IsString()) {\n    NOTREACHED();\n    return;\n  }\n  if (!args[1]->IsString()) {\n    NOTREACHED();\n    return;\n  }\n\n  std::string name(*v8::String::Utf8Value(args[0]));\n  if (name.empty()) {\n    NOTREACHED();\n    return;\n  }\n  std::string message(*v8::String::Utf8Value(args[1]));\n  // message is optional hence empty is fine.\n\n  blink::WebDOMError dom_error = blink::WebDOMError::create(\n      blink::WebString::fromUTF8(name), blink::WebString::fromUTF8(message));\n  args.GetReturnValue().Set(\n      dom_error.toV8Value(args.Holder(), args.GetIsolate()));\n}",
        "func": "void FileSystemNatives::GetDOMError(\n    const v8::FunctionCallbackInfo<v8::Value>& args) {\n  if (args.Length() != 2) {\n    NOTREACHED();\n    return;\n  }\n  if (!args[0]->IsString()) {\n    NOTREACHED();\n    return;\n  }\n  if (!args[1]->IsString()) {\n    NOTREACHED();\n    return;\n  }\n\n  std::string name(*v8::String::Utf8Value(args[0]));\n  if (name.empty()) {\n    NOTREACHED();\n    return;\n  }\n  std::string message(*v8::String::Utf8Value(args[1]));\n  // message is optional hence empty is fine.\n\n  blink::WebDOMError dom_error = blink::WebDOMError::create(\n      blink::WebString::fromUTF8(name), blink::WebString::fromUTF8(message));\n  args.GetReturnValue().Set(\n      dom_error.toV8Value(context()->v8_context()->Global(),\n                          args.GetIsolate()));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -24,5 +24,6 @@\n   blink::WebDOMError dom_error = blink::WebDOMError::create(\n       blink::WebString::fromUTF8(name), blink::WebString::fromUTF8(message));\n   args.GetReturnValue().Set(\n-      dom_error.toV8Value(args.Holder(), args.GetIsolate()));\n+      dom_error.toV8Value(context()->v8_context()->Global(),\n+                          args.GetIsolate()));\n }",
        "diff_line_info": {
            "deleted_lines": [
                "      dom_error.toV8Value(args.Holder(), args.GetIsolate()));"
            ],
            "added_lines": [
                "      dom_error.toV8Value(context()->v8_context()->Global(),",
                "                          args.GetIsolate()));"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-1267",
        "func_name": "chromium/FileSystemNatives::GetIsolatedFileSystem",
        "description": "Blink, as used in Google Chrome before 43.0.2357.130, does not properly restrict the creation context during creation of a DOM wrapper, which allows remote attackers to bypass the Same Origin Policy via crafted JavaScript code that uses a Blink public API, related to WebArrayBufferConverter.cpp, WebBlob.cpp, WebDOMError.cpp, and WebDOMFileSystem.cpp.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/42bd05a2bf4260f500687a2457d01e298033f2bb",
        "commit_title": "blink:bindings: Passes the global context instead of |this| in JS.",
        "commit_text": " |this| in JS (args.Holder() in C++ code) is not a reliable object.  User script can pass any object as |this|.  So we shouldn't use it as creation context when calling Blink APIs to create a new DOM wrapper.  We should instead use the current context where the user script is running as creation context.    ",
        "func_before": "void FileSystemNatives::GetIsolatedFileSystem(\n    const v8::FunctionCallbackInfo<v8::Value>& args) {\n  DCHECK(args.Length() == 1 || args.Length() == 2);\n  DCHECK(args[0]->IsString());\n  std::string file_system_id(*v8::String::Utf8Value(args[0]));\n  blink::WebLocalFrame* webframe =\n      blink::WebLocalFrame::frameForContext(context()->v8_context());\n  DCHECK(webframe);\n\n  GURL context_url =\n      extensions::ScriptContext::GetDataSourceURLForFrame(webframe);\n  CHECK(context_url.SchemeIs(extensions::kExtensionScheme));\n\n  std::string name(storage::GetIsolatedFileSystemName(context_url.GetOrigin(),\n                                                      file_system_id));\n\n  // The optional second argument is the subfolder within the isolated file\n  // system at which to root the DOMFileSystem we're returning to the caller.\n  std::string optional_root_name;\n  if (args.Length() == 2) {\n    DCHECK(args[1]->IsString());\n    optional_root_name = *v8::String::Utf8Value(args[1]);\n  }\n\n  GURL root_url(storage::GetIsolatedFileSystemRootURIString(\n      context_url.GetOrigin(), file_system_id, optional_root_name));\n\n  args.GetReturnValue().Set(\n      blink::WebDOMFileSystem::create(webframe,\n                                      blink::WebFileSystemTypeIsolated,\n                                      blink::WebString::fromUTF8(name),\n                                      root_url)\n          .toV8Value(args.Holder(), args.GetIsolate()));\n}",
        "func": "void FileSystemNatives::GetIsolatedFileSystem(\n    const v8::FunctionCallbackInfo<v8::Value>& args) {\n  DCHECK(args.Length() == 1 || args.Length() == 2);\n  DCHECK(args[0]->IsString());\n  std::string file_system_id(*v8::String::Utf8Value(args[0]));\n  blink::WebLocalFrame* webframe =\n      blink::WebLocalFrame::frameForContext(context()->v8_context());\n  DCHECK(webframe);\n\n  GURL context_url =\n      extensions::ScriptContext::GetDataSourceURLForFrame(webframe);\n  CHECK(context_url.SchemeIs(extensions::kExtensionScheme));\n\n  std::string name(storage::GetIsolatedFileSystemName(context_url.GetOrigin(),\n                                                      file_system_id));\n\n  // The optional second argument is the subfolder within the isolated file\n  // system at which to root the DOMFileSystem we're returning to the caller.\n  std::string optional_root_name;\n  if (args.Length() == 2) {\n    DCHECK(args[1]->IsString());\n    optional_root_name = *v8::String::Utf8Value(args[1]);\n  }\n\n  GURL root_url(storage::GetIsolatedFileSystemRootURIString(\n      context_url.GetOrigin(), file_system_id, optional_root_name));\n\n  args.GetReturnValue().Set(\n      blink::WebDOMFileSystem::create(webframe,\n                                      blink::WebFileSystemTypeIsolated,\n                                      blink::WebString::fromUTF8(name),\n                                      root_url)\n          .toV8Value(context()->v8_context()->Global(), args.GetIsolate()));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -30,5 +30,5 @@\n                                       blink::WebFileSystemTypeIsolated,\n                                       blink::WebString::fromUTF8(name),\n                                       root_url)\n-          .toV8Value(args.Holder(), args.GetIsolate()));\n+          .toV8Value(context()->v8_context()->Global(), args.GetIsolate()));\n }",
        "diff_line_info": {
            "deleted_lines": [
                "          .toV8Value(args.Holder(), args.GetIsolate()));"
            ],
            "added_lines": [
                "          .toV8Value(context()->v8_context()->Global(), args.GetIsolate()));"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-1267",
        "func_name": "chromium/FileManagerPrivateCustomBindings::GetFileSystem",
        "description": "Blink, as used in Google Chrome before 43.0.2357.130, does not properly restrict the creation context during creation of a DOM wrapper, which allows remote attackers to bypass the Same Origin Policy via crafted JavaScript code that uses a Blink public API, related to WebArrayBufferConverter.cpp, WebBlob.cpp, WebDOMError.cpp, and WebDOMFileSystem.cpp.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/42bd05a2bf4260f500687a2457d01e298033f2bb",
        "commit_title": "blink:bindings: Passes the global context instead of |this| in JS.",
        "commit_text": " |this| in JS (args.Holder() in C++ code) is not a reliable object.  User script can pass any object as |this|.  So we shouldn't use it as creation context when calling Blink APIs to create a new DOM wrapper.  We should instead use the current context where the user script is running as creation context.    ",
        "func_before": "void FileManagerPrivateCustomBindings::GetFileSystem(\n    const v8::FunctionCallbackInfo<v8::Value>& args) {\n  DCHECK(args.Length() == 2);\n  DCHECK(args[0]->IsString());\n  DCHECK(args[1]->IsString());\n  std::string name(*v8::String::Utf8Value(args[0]));\n  std::string root_url(*v8::String::Utf8Value(args[1]));\n\n  blink::WebLocalFrame* webframe =\n      blink::WebLocalFrame::frameForContext(context()->v8_context());\n  DCHECK(webframe);\n  args.GetReturnValue().Set(\n      blink::WebDOMFileSystem::create(webframe,\n                                      blink::WebFileSystemTypeExternal,\n                                      blink::WebString::fromUTF8(name),\n                                      GURL(root_url))\n          .toV8Value(args.Holder(), args.GetIsolate()));\n}",
        "func": "void FileManagerPrivateCustomBindings::GetFileSystem(\n    const v8::FunctionCallbackInfo<v8::Value>& args) {\n  DCHECK(args.Length() == 2);\n  DCHECK(args[0]->IsString());\n  DCHECK(args[1]->IsString());\n  std::string name(*v8::String::Utf8Value(args[0]));\n  std::string root_url(*v8::String::Utf8Value(args[1]));\n\n  blink::WebLocalFrame* webframe =\n      blink::WebLocalFrame::frameForContext(context()->v8_context());\n  DCHECK(webframe);\n  args.GetReturnValue().Set(\n      blink::WebDOMFileSystem::create(webframe,\n                                      blink::WebFileSystemTypeExternal,\n                                      blink::WebString::fromUTF8(name),\n                                      GURL(root_url))\n          .toV8Value(context()->v8_context()->Global(), args.GetIsolate()));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -14,5 +14,5 @@\n                                       blink::WebFileSystemTypeExternal,\n                                       blink::WebString::fromUTF8(name),\n                                       GURL(root_url))\n-          .toV8Value(args.Holder(), args.GetIsolate()));\n+          .toV8Value(context()->v8_context()->Global(), args.GetIsolate()));\n }",
        "diff_line_info": {
            "deleted_lines": [
                "          .toV8Value(args.Holder(), args.GetIsolate()));"
            ],
            "added_lines": [
                "          .toV8Value(context()->v8_context()->Global(), args.GetIsolate()));"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-1268",
        "func_name": "chromium/v8SetReturnValue",
        "description": "bindings/scripts/v8_types.py in Blink, as used in Google Chrome before 43.0.2357.130, does not properly select a creation context for a return value's DOM wrapper, which allows remote attackers to bypass the Same Origin Policy via crafted JavaScript code, as demonstrated by use of a data: URL.",
        "git_url": "https://github.com/chromium/chromium/commit/542ab473e104b7df23e95f933bda41723794d4da",
        "commit_title": "binding: Supports static operations/attrs returning non-primitive types.",
        "commit_text": " Correctly supports static operations/attributes which return non-primitive types, so that the returned object is associated with the caller's context, not associated with |this| which can be faked.   ",
        "func_before": "inline void v8SetReturnValue(const CallbackInfo& callbackInfo, ScriptWrappable* impl)\n{\n    if (UNLIKELY(!impl)) {\n        v8SetReturnValueNull(callbackInfo);\n        return;\n    }\n    if (DOMDataStore::setReturnValue(callbackInfo.GetReturnValue(), impl))\n        return;\n    v8::Local<v8::Object> wrapper = impl->wrap(callbackInfo.GetIsolate(), callbackInfo.Holder());\n    v8SetReturnValue(callbackInfo, wrapper);\n}",
        "func": "inline void v8SetReturnValue(const CallbackInfo& callbackInfo, ScriptWrappable* impl)\n{\n    v8SetReturnValue(callbackInfo, impl, callbackInfo.Holder());\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,11 +1,4 @@\n inline void v8SetReturnValue(const CallbackInfo& callbackInfo, ScriptWrappable* impl)\n {\n-    if (UNLIKELY(!impl)) {\n-        v8SetReturnValueNull(callbackInfo);\n-        return;\n-    }\n-    if (DOMDataStore::setReturnValue(callbackInfo.GetReturnValue(), impl))\n-        return;\n-    v8::Local<v8::Object> wrapper = impl->wrap(callbackInfo.GetIsolate(), callbackInfo.Holder());\n-    v8SetReturnValue(callbackInfo, wrapper);\n+    v8SetReturnValue(callbackInfo, impl, callbackInfo.Holder());\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    if (UNLIKELY(!impl)) {",
                "        v8SetReturnValueNull(callbackInfo);",
                "        return;",
                "    }",
                "    if (DOMDataStore::setReturnValue(callbackInfo.GetReturnValue(), impl))",
                "        return;",
                "    v8::Local<v8::Object> wrapper = impl->wrap(callbackInfo.GetIsolate(), callbackInfo.Holder());",
                "    v8SetReturnValue(callbackInfo, wrapper);"
            ],
            "added_lines": [
                "    v8SetReturnValue(callbackInfo, impl, callbackInfo.Holder());"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-1269",
        "func_name": "chromium/TransportSecurityState::Iterator::~Iterator",
        "description": "The DecodeHSTSPreloadRaw function in net/http/transport_security_state.cc in Google Chrome before 43.0.2357.130 does not properly canonicalize DNS hostnames before making comparisons to HSTS or HPKP preload entries, which allows remote attackers to bypass intended access restrictions via a string that (1) ends in a . (dot) character or (2) is not entirely lowercase.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/c2dd599bdd35753da237172dc37a447e9d65c463",
        "commit_title": "Normalize hostnames before searching for HSTS/HPKP preloads",
        "commit_text": " The HSTS/HPKP preload set is pre-normalized at construction time. Since the queries come from the GURL, not from the DNS layer, we need to normalize the hostname before scanning for preloads. This used to be handled by CanonicalizeHost(), which used the same mechanism as the resolver, but the storage of the preloads has changed to be more efficient, and thus no longer uses the resolver-normalized form.    ",
        "func_before": "TransportSecurityState::Iterator::~Iterator() {}",
        "func": "TransportSecurityState::Iterator::~Iterator() {\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1 +1,2 @@\n-TransportSecurityState::Iterator::~Iterator() {}\n+TransportSecurityState::Iterator::~Iterator() {\n+}",
        "diff_line_info": {
            "deleted_lines": [
                "TransportSecurityState::Iterator::~Iterator() {}"
            ],
            "added_lines": [
                "TransportSecurityState::Iterator::~Iterator() {",
                "}"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-1269",
        "func_name": "chromium/TransportSecurityState::ShouldUpgradeToSSL",
        "description": "The DecodeHSTSPreloadRaw function in net/http/transport_security_state.cc in Google Chrome before 43.0.2357.130 does not properly canonicalize DNS hostnames before making comparisons to HSTS or HPKP preload entries, which allows remote attackers to bypass intended access restrictions via a string that (1) ends in a . (dot) character or (2) is not entirely lowercase.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/c2dd599bdd35753da237172dc37a447e9d65c463",
        "commit_title": "Normalize hostnames before searching for HSTS/HPKP preloads",
        "commit_text": " The HSTS/HPKP preload set is pre-normalized at construction time. Since the queries come from the GURL, not from the DNS layer, we need to normalize the hostname before scanning for preloads. This used to be handled by CanonicalizeHost(), which used the same mechanism as the resolver, but the storage of the preloads has changed to be more efficient, and thus no longer uses the resolver-normalized form.    ",
        "func_before": "bool TransportSecurityState::ShouldUpgradeToSSL(const std::string& host) {\n  DomainState dynamic_state;\n  if (GetDynamicDomainState(host, &dynamic_state))\n    return dynamic_state.ShouldUpgradeToSSL();\n\n  DomainState static_state;\n  if (GetStaticDomainState(host, &static_state) &&\n      static_state.ShouldUpgradeToSSL()) {\n      return true;\n  }\n\n  return false;\n}",
        "func": "bool TransportSecurityState::ShouldUpgradeToSSL(const std::string& host) {\n  DomainState dynamic_state;\n  if (GetDynamicDomainState(host, &dynamic_state))\n    return dynamic_state.ShouldUpgradeToSSL();\n\n  DomainState static_state;\n  if (GetStaticDomainState(host, &static_state) &&\n      static_state.ShouldUpgradeToSSL()) {\n    return true;\n  }\n\n  return false;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,7 +6,7 @@\n   DomainState static_state;\n   if (GetStaticDomainState(host, &static_state) &&\n       static_state.ShouldUpgradeToSSL()) {\n-      return true;\n+    return true;\n   }\n \n   return false;",
        "diff_line_info": {
            "deleted_lines": [
                "      return true;"
            ],
            "added_lines": [
                "    return true;"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-1269",
        "func_name": "chromium/DecodeHSTSPreloadRaw",
        "description": "The DecodeHSTSPreloadRaw function in net/http/transport_security_state.cc in Google Chrome before 43.0.2357.130 does not properly canonicalize DNS hostnames before making comparisons to HSTS or HPKP preload entries, which allows remote attackers to bypass intended access restrictions via a string that (1) ends in a . (dot) character or (2) is not entirely lowercase.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/c2dd599bdd35753da237172dc37a447e9d65c463",
        "commit_title": "Normalize hostnames before searching for HSTS/HPKP preloads",
        "commit_text": " The HSTS/HPKP preload set is pre-normalized at construction time. Since the queries come from the GURL, not from the DNS layer, we need to normalize the hostname before scanning for preloads. This used to be handled by CanonicalizeHost(), which used the same mechanism as the resolver, but the storage of the preloads has changed to be more efficient, and thus no longer uses the resolver-normalized form.    ",
        "func_before": "bool DecodeHSTSPreloadRaw(const std::string& hostname,\n                          bool* out_found,\n                          PreloadResult* out) {\n  HuffmanDecoder huffman(kHSTSHuffmanTree, sizeof(kHSTSHuffmanTree));\n  BitReader reader(kPreloadedHSTSData, kPreloadedHSTSBits);\n  size_t bit_offset = kHSTSRootPosition;\n  static const char kEndOfString = 0;\n  static const char kEndOfTable = 127;\n\n  *out_found = false;\n\n  if (hostname.empty()) {\n    return true;\n  }\n  // hostname_offset contains one more than the index of the current character\n  // in the hostname that is being considered. It's one greater so that we can\n  // represent the position just before the beginning (with zero).\n  size_t hostname_offset = hostname.size();\n\n  for (;;) {\n    // Seek to the desired location.\n    if (!reader.Seek(bit_offset)) {\n      return false;\n    }\n\n    // Decode the unary length of the common prefix.\n    size_t prefix_length;\n    if (!reader.Unary(&prefix_length)) {\n      return false;\n    }\n\n    // Match each character in the prefix.\n    for (size_t i = 0; i < prefix_length; ++i) {\n      if (hostname_offset == 0) {\n        // We can't match the terminator with a prefix string.\n        return true;\n      }\n\n      char c;\n      if (!huffman.Decode(&reader, &c)) {\n        return false;\n      }\n      if (hostname[hostname_offset - 1] != c) {\n        return true;\n      }\n      hostname_offset--;\n    }\n\n    bool is_first_offset = true;\n    size_t current_offset = 0;\n\n    // Next is the dispatch table.\n    for (;;) {\n      char c;\n      if (!huffman.Decode(&reader, &c)) {\n        return false;\n      }\n      if (c == kEndOfTable) {\n        // No exact match.\n        return true;\n      }\n\n      if (c == kEndOfString) {\n        PreloadResult tmp;\n        if (!reader.Next(&tmp.sts_include_subdomains) ||\n            !reader.Next(&tmp.force_https) ||\n            !reader.Next(&tmp.has_pins)) {\n          return false;\n        }\n\n        tmp.pkp_include_subdomains = tmp.sts_include_subdomains;\n\n        if (tmp.has_pins) {\n          if (!reader.Read(4, &tmp.pinset_id) ||\n              !reader.Read(9, &tmp.domain_id) ||\n              (!tmp.sts_include_subdomains &&\n               !reader.Next(&tmp.pkp_include_subdomains))) {\n            return false;\n          }\n        }\n\n        tmp.hostname_offset = hostname_offset;\n\n        if (hostname_offset == 0 || hostname[hostname_offset - 1] == '.') {\n          *out_found =\n              tmp.sts_include_subdomains || tmp.pkp_include_subdomains;\n          *out = tmp;\n\n          if (hostname_offset > 0) {\n            out->force_https &= tmp.sts_include_subdomains;\n          } else {\n            *out_found = true;\n            return true;\n          }\n        }\n\n        continue;\n      }\n\n      // The entries in a dispatch table are in order thus we can tell if there\n      // will be no match if the current character past the one that we want.\n      if (hostname_offset == 0 || hostname[hostname_offset-1] < c) {\n        return true;\n      }\n\n      if (is_first_offset) {\n        // The first offset is backwards from the current position.\n        uint32 jump_delta_bits;\n        uint32 jump_delta;\n        if (!reader.Read(5, &jump_delta_bits) ||\n            !reader.Read(jump_delta_bits, &jump_delta)) {\n          return false;\n        }\n\n        if (bit_offset < jump_delta) {\n          return false;\n        }\n\n        current_offset = bit_offset - jump_delta;\n        is_first_offset = false;\n      } else {\n        // Subsequent offsets are forward from the target of the first offset.\n        uint32 is_long_jump;\n        if (!reader.Read(1, &is_long_jump)) {\n          return false;\n        }\n\n        uint32 jump_delta;\n        if (!is_long_jump) {\n          if (!reader.Read(7, &jump_delta)) {\n            return false;\n          }\n        } else {\n          uint32 jump_delta_bits;\n          if (!reader.Read(4, &jump_delta_bits) ||\n              !reader.Read(jump_delta_bits + 8, &jump_delta)) {\n            return false;\n          }\n        }\n\n        current_offset += jump_delta;\n        if (current_offset >= bit_offset) {\n          return false;\n        }\n      }\n\n      DCHECK_LT(0u, hostname_offset);\n      if (hostname[hostname_offset - 1] == c) {\n        bit_offset = current_offset;\n        hostname_offset--;\n        break;\n      }\n    }\n  }\n}",
        "func": "bool DecodeHSTSPreloadRaw(const std::string& search_hostname,\n                          bool* out_found,\n                          PreloadResult* out) {\n  HuffmanDecoder huffman(kHSTSHuffmanTree, sizeof(kHSTSHuffmanTree));\n  BitReader reader(kPreloadedHSTSData, kPreloadedHSTSBits);\n  size_t bit_offset = kHSTSRootPosition;\n  static const char kEndOfString = 0;\n  static const char kEndOfTable = 127;\n\n  *out_found = false;\n\n  // Ensure that |search_hostname| is a valid hostname before\n  // processing.\n  if (CanonicalizeHost(search_hostname).empty()) {\n    return true;\n  }\n\n  // Normalize any trailing '.' used for DNS suffix searches.\n  std::string hostname = search_hostname;\n  size_t found = hostname.find_last_not_of('.');\n  if (found != std::string::npos) {\n    hostname.erase(found + 1);\n  } else {\n    hostname.clear();\n  }\n\n  // |hostname| has already undergone IDN conversion, so should be\n  // entirely A-Labels. The preload data is entirely normalized to\n  // lower case.\n  base::StringToLowerASCII(&hostname);\n\n  if (hostname.empty()) {\n    return true;\n  }\n\n  // hostname_offset contains one more than the index of the current character\n  // in the hostname that is being considered. It's one greater so that we can\n  // represent the position just before the beginning (with zero).\n  size_t hostname_offset = hostname.size();\n\n  for (;;) {\n    // Seek to the desired location.\n    if (!reader.Seek(bit_offset)) {\n      return false;\n    }\n\n    // Decode the unary length of the common prefix.\n    size_t prefix_length;\n    if (!reader.Unary(&prefix_length)) {\n      return false;\n    }\n\n    // Match each character in the prefix.\n    for (size_t i = 0; i < prefix_length; ++i) {\n      if (hostname_offset == 0) {\n        // We can't match the terminator with a prefix string.\n        return true;\n      }\n\n      char c;\n      if (!huffman.Decode(&reader, &c)) {\n        return false;\n      }\n      if (hostname[hostname_offset - 1] != c) {\n        return true;\n      }\n      hostname_offset--;\n    }\n\n    bool is_first_offset = true;\n    size_t current_offset = 0;\n\n    // Next is the dispatch table.\n    for (;;) {\n      char c;\n      if (!huffman.Decode(&reader, &c)) {\n        return false;\n      }\n      if (c == kEndOfTable) {\n        // No exact match.\n        return true;\n      }\n\n      if (c == kEndOfString) {\n        PreloadResult tmp;\n        if (!reader.Next(&tmp.sts_include_subdomains) ||\n            !reader.Next(&tmp.force_https) ||\n            !reader.Next(&tmp.has_pins)) {\n          return false;\n        }\n\n        tmp.pkp_include_subdomains = tmp.sts_include_subdomains;\n\n        if (tmp.has_pins) {\n          if (!reader.Read(4, &tmp.pinset_id) ||\n              !reader.Read(9, &tmp.domain_id) ||\n              (!tmp.sts_include_subdomains &&\n               !reader.Next(&tmp.pkp_include_subdomains))) {\n            return false;\n          }\n        }\n\n        tmp.hostname_offset = hostname_offset;\n\n        if (hostname_offset == 0 || hostname[hostname_offset - 1] == '.') {\n          *out_found =\n              tmp.sts_include_subdomains || tmp.pkp_include_subdomains;\n          *out = tmp;\n\n          if (hostname_offset > 0) {\n            out->force_https &= tmp.sts_include_subdomains;\n          } else {\n            *out_found = true;\n            return true;\n          }\n        }\n\n        continue;\n      }\n\n      // The entries in a dispatch table are in order thus we can tell if there\n      // will be no match if the current character past the one that we want.\n      if (hostname_offset == 0 || hostname[hostname_offset-1] < c) {\n        return true;\n      }\n\n      if (is_first_offset) {\n        // The first offset is backwards from the current position.\n        uint32 jump_delta_bits;\n        uint32 jump_delta;\n        if (!reader.Read(5, &jump_delta_bits) ||\n            !reader.Read(jump_delta_bits, &jump_delta)) {\n          return false;\n        }\n\n        if (bit_offset < jump_delta) {\n          return false;\n        }\n\n        current_offset = bit_offset - jump_delta;\n        is_first_offset = false;\n      } else {\n        // Subsequent offsets are forward from the target of the first offset.\n        uint32 is_long_jump;\n        if (!reader.Read(1, &is_long_jump)) {\n          return false;\n        }\n\n        uint32 jump_delta;\n        if (!is_long_jump) {\n          if (!reader.Read(7, &jump_delta)) {\n            return false;\n          }\n        } else {\n          uint32 jump_delta_bits;\n          if (!reader.Read(4, &jump_delta_bits) ||\n              !reader.Read(jump_delta_bits + 8, &jump_delta)) {\n            return false;\n          }\n        }\n\n        current_offset += jump_delta;\n        if (current_offset >= bit_offset) {\n          return false;\n        }\n      }\n\n      DCHECK_LT(0u, hostname_offset);\n      if (hostname[hostname_offset - 1] == c) {\n        bit_offset = current_offset;\n        hostname_offset--;\n        break;\n      }\n    }\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,4 @@\n-bool DecodeHSTSPreloadRaw(const std::string& hostname,\n+bool DecodeHSTSPreloadRaw(const std::string& search_hostname,\n                           bool* out_found,\n                           PreloadResult* out) {\n   HuffmanDecoder huffman(kHSTSHuffmanTree, sizeof(kHSTSHuffmanTree));\n@@ -9,9 +9,30 @@\n \n   *out_found = false;\n \n+  // Ensure that |search_hostname| is a valid hostname before\n+  // processing.\n+  if (CanonicalizeHost(search_hostname).empty()) {\n+    return true;\n+  }\n+\n+  // Normalize any trailing '.' used for DNS suffix searches.\n+  std::string hostname = search_hostname;\n+  size_t found = hostname.find_last_not_of('.');\n+  if (found != std::string::npos) {\n+    hostname.erase(found + 1);\n+  } else {\n+    hostname.clear();\n+  }\n+\n+  // |hostname| has already undergone IDN conversion, so should be\n+  // entirely A-Labels. The preload data is entirely normalized to\n+  // lower case.\n+  base::StringToLowerASCII(&hostname);\n+\n   if (hostname.empty()) {\n     return true;\n   }\n+\n   // hostname_offset contains one more than the index of the current character\n   // in the hostname that is being considered. It's one greater so that we can\n   // represent the position just before the beginning (with zero).",
        "diff_line_info": {
            "deleted_lines": [
                "bool DecodeHSTSPreloadRaw(const std::string& hostname,"
            ],
            "added_lines": [
                "bool DecodeHSTSPreloadRaw(const std::string& search_hostname,",
                "  // Ensure that |search_hostname| is a valid hostname before",
                "  // processing.",
                "  if (CanonicalizeHost(search_hostname).empty()) {",
                "    return true;",
                "  }",
                "",
                "  // Normalize any trailing '.' used for DNS suffix searches.",
                "  std::string hostname = search_hostname;",
                "  size_t found = hostname.find_last_not_of('.');",
                "  if (found != std::string::npos) {",
                "    hostname.erase(found + 1);",
                "  } else {",
                "    hostname.clear();",
                "  }",
                "",
                "  // |hostname| has already undergone IDN conversion, so should be",
                "  // entirely A-Labels. The preload data is entirely normalized to",
                "  // lower case.",
                "  base::StringToLowerASCII(&hostname);",
                "",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2015-1269",
        "func_name": "chromium/TransportSecurityState::CheckPublicKeyPins",
        "description": "The DecodeHSTSPreloadRaw function in net/http/transport_security_state.cc in Google Chrome before 43.0.2357.130 does not properly canonicalize DNS hostnames before making comparisons to HSTS or HPKP preload entries, which allows remote attackers to bypass intended access restrictions via a string that (1) ends in a . (dot) character or (2) is not entirely lowercase.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/c2dd599bdd35753da237172dc37a447e9d65c463",
        "commit_title": "Normalize hostnames before searching for HSTS/HPKP preloads",
        "commit_text": " The HSTS/HPKP preload set is pre-normalized at construction time. Since the queries come from the GURL, not from the DNS layer, we need to normalize the hostname before scanning for preloads. This used to be handled by CanonicalizeHost(), which used the same mechanism as the resolver, but the storage of the preloads has changed to be more efficient, and thus no longer uses the resolver-normalized form.    ",
        "func_before": "bool TransportSecurityState::CheckPublicKeyPins(\n    const std::string& host,\n    bool is_issued_by_known_root,\n    const HashValueVector& public_key_hashes,\n    std::string* pinning_failure_log) {\n  // Perform pin validation if, and only if, all these conditions obtain:\n  //\n  // * the server's certificate chain chains up to a known root (i.e. not a\n  //   user-installed trust anchor); and\n  // * the server actually has public key pins.\n  if (!is_issued_by_known_root || !HasPublicKeyPins(host)) {\n    return true;\n  }\n\n  bool pins_are_valid = CheckPublicKeyPinsImpl(\n      host, public_key_hashes, pinning_failure_log);\n  if (!pins_are_valid) {\n    LOG(ERROR) << *pinning_failure_log;\n    ReportUMAOnPinFailure(host);\n  }\n\n  UMA_HISTOGRAM_BOOLEAN(\"Net.PublicKeyPinSuccess\", pins_are_valid);\n  return pins_are_valid;\n}",
        "func": "bool TransportSecurityState::CheckPublicKeyPins(\n    const std::string& host,\n    bool is_issued_by_known_root,\n    const HashValueVector& public_key_hashes,\n    std::string* pinning_failure_log) {\n  // Perform pin validation if, and only if, all these conditions obtain:\n  //\n  // * the server's certificate chain chains up to a known root (i.e. not a\n  //   user-installed trust anchor); and\n  // * the server actually has public key pins.\n  if (!is_issued_by_known_root || !HasPublicKeyPins(host)) {\n    return true;\n  }\n\n  bool pins_are_valid =\n      CheckPublicKeyPinsImpl(host, public_key_hashes, pinning_failure_log);\n  if (!pins_are_valid) {\n    LOG(ERROR) << *pinning_failure_log;\n    ReportUMAOnPinFailure(host);\n  }\n\n  UMA_HISTOGRAM_BOOLEAN(\"Net.PublicKeyPinSuccess\", pins_are_valid);\n  return pins_are_valid;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -12,8 +12,8 @@\n     return true;\n   }\n \n-  bool pins_are_valid = CheckPublicKeyPinsImpl(\n-      host, public_key_hashes, pinning_failure_log);\n+  bool pins_are_valid =\n+      CheckPublicKeyPinsImpl(host, public_key_hashes, pinning_failure_log);\n   if (!pins_are_valid) {\n     LOG(ERROR) << *pinning_failure_log;\n     ReportUMAOnPinFailure(host);",
        "diff_line_info": {
            "deleted_lines": [
                "  bool pins_are_valid = CheckPublicKeyPinsImpl(",
                "      host, public_key_hashes, pinning_failure_log);"
            ],
            "added_lines": [
                "  bool pins_are_valid =",
                "      CheckPublicKeyPinsImpl(host, public_key_hashes, pinning_failure_log);"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-1269",
        "func_name": "chromium/TransportSecurityState::DeleteDynamicDataForHost",
        "description": "The DecodeHSTSPreloadRaw function in net/http/transport_security_state.cc in Google Chrome before 43.0.2357.130 does not properly canonicalize DNS hostnames before making comparisons to HSTS or HPKP preload entries, which allows remote attackers to bypass intended access restrictions via a string that (1) ends in a . (dot) character or (2) is not entirely lowercase.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/c2dd599bdd35753da237172dc37a447e9d65c463",
        "commit_title": "Normalize hostnames before searching for HSTS/HPKP preloads",
        "commit_text": " The HSTS/HPKP preload set is pre-normalized at construction time. Since the queries come from the GURL, not from the DNS layer, we need to normalize the hostname before scanning for preloads. This used to be handled by CanonicalizeHost(), which used the same mechanism as the resolver, but the storage of the preloads has changed to be more efficient, and thus no longer uses the resolver-normalized form.    ",
        "func_before": "bool TransportSecurityState::DeleteDynamicDataForHost(const std::string& host) {\n  DCHECK(CalledOnValidThread());\n\n  const std::string canonicalized_host = CanonicalizeHost(host);\n  if (canonicalized_host.empty())\n    return false;\n\n  DomainStateMap::iterator i = enabled_hosts_.find(\n      HashHost(canonicalized_host));\n  if (i != enabled_hosts_.end()) {\n    enabled_hosts_.erase(i);\n    DirtyNotify();\n    return true;\n  }\n  return false;\n}",
        "func": "bool TransportSecurityState::DeleteDynamicDataForHost(const std::string& host) {\n  DCHECK(CalledOnValidThread());\n\n  const std::string canonicalized_host = CanonicalizeHost(host);\n  if (canonicalized_host.empty())\n    return false;\n\n  DomainStateMap::iterator i =\n      enabled_hosts_.find(HashHost(canonicalized_host));\n  if (i != enabled_hosts_.end()) {\n    enabled_hosts_.erase(i);\n    DirtyNotify();\n    return true;\n  }\n  return false;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,8 +5,8 @@\n   if (canonicalized_host.empty())\n     return false;\n \n-  DomainStateMap::iterator i = enabled_hosts_.find(\n-      HashHost(canonicalized_host));\n+  DomainStateMap::iterator i =\n+      enabled_hosts_.find(HashHost(canonicalized_host));\n   if (i != enabled_hosts_.end()) {\n     enabled_hosts_.erase(i);\n     DirtyNotify();",
        "diff_line_info": {
            "deleted_lines": [
                "  DomainStateMap::iterator i = enabled_hosts_.find(",
                "      HashHost(canonicalized_host));"
            ],
            "added_lines": [
                "  DomainStateMap::iterator i =",
                "      enabled_hosts_.find(HashHost(canonicalized_host));"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-1793",
        "func_name": "openssl/X509_verify_cert",
        "description": "The X509_verify_cert function in crypto/x509/x509_vfy.c in OpenSSL 1.0.1n, 1.0.1o, 1.0.2b, and 1.0.2c does not properly process X.509 Basic Constraints cA values during identification of alternative certificate chains, which allows remote attackers to spoof a Certification Authority role and trigger unintended certificate verifications via a valid leaf certificate.",
        "git_url": "https://git.openssl.org/?p=openssl.git;a=commit;h=9a0db453ba017ebcaccbee933ee6511a9ae4d1c8",
        "commit_title": "",
        "commit_text": "Fix alternate chains certificate forgery issue  During certificate verfification, OpenSSL will attempt to find an alternative certificate chain if the first attempt to build such a chain fails. An error in the implementation of this logic can mean that an attacker could cause certain checks on untrusted certificates to be bypassed, such as the CA flag, enabling them to use a valid leaf certificate to act as a CA and \"issue\" an invalid certificate.  This occurs where at least one cert is added to the first chain from the trust store, but that chain still ends up being untrusted. In that case ctx->last_untrusted is decremented in error.  Patch provided by the BoringSSL project.  CVE-2015-1793  ",
        "func_before": "int X509_verify_cert(X509_STORE_CTX *ctx)\n{\n    X509 *x, *xtmp, *xtmp2, *chain_ss = NULL;\n    int bad_chain = 0;\n    X509_VERIFY_PARAM *param = ctx->param;\n    int depth, i, ok = 0;\n    int num, j, retry;\n    int (*cb) (int xok, X509_STORE_CTX *xctx);\n    STACK_OF(X509) *sktmp = NULL;\n    if (ctx->cert == NULL) {\n        X509err(X509_F_X509_VERIFY_CERT, X509_R_NO_CERT_SET_FOR_US_TO_VERIFY);\n        return -1;\n    }\n\n    cb = ctx->verify_cb;\n\n    /*\n     * first we make sure the chain we are going to build is present and that\n     * the first entry is in place\n     */\n    if (ctx->chain == NULL) {\n        if (((ctx->chain = sk_X509_new_null()) == NULL) ||\n            (!sk_X509_push(ctx->chain, ctx->cert))) {\n            X509err(X509_F_X509_VERIFY_CERT, ERR_R_MALLOC_FAILURE);\n            goto end;\n        }\n        CRYPTO_add(&ctx->cert->references, 1, CRYPTO_LOCK_X509);\n        ctx->last_untrusted = 1;\n    }\n\n    /* We use a temporary STACK so we can chop and hack at it */\n    if (ctx->untrusted != NULL\n        && (sktmp = sk_X509_dup(ctx->untrusted)) == NULL) {\n        X509err(X509_F_X509_VERIFY_CERT, ERR_R_MALLOC_FAILURE);\n        goto end;\n    }\n\n    num = sk_X509_num(ctx->chain);\n    x = sk_X509_value(ctx->chain, num - 1);\n    depth = param->depth;\n\n    for (;;) {\n        /* If we have enough, we break */\n        if (depth < num)\n            break;              /* FIXME: If this happens, we should take\n                                 * note of it and, if appropriate, use the\n                                 * X509_V_ERR_CERT_CHAIN_TOO_LONG error code\n                                 * later. */\n\n        /* If we are self signed, we break */\n        if (ctx->check_issued(ctx, x, x))\n            break;\n\n        /* If we were passed a cert chain, use it first */\n        if (ctx->untrusted != NULL) {\n            xtmp = find_issuer(ctx, sktmp, x);\n            if (xtmp != NULL) {\n                if (!sk_X509_push(ctx->chain, xtmp)) {\n                    X509err(X509_F_X509_VERIFY_CERT, ERR_R_MALLOC_FAILURE);\n                    goto end;\n                }\n                CRYPTO_add(&xtmp->references, 1, CRYPTO_LOCK_X509);\n                (void)sk_X509_delete_ptr(sktmp, xtmp);\n                ctx->last_untrusted++;\n                x = xtmp;\n                num++;\n                /*\n                 * reparse the full chain for the next one\n                 */\n                continue;\n            }\n        }\n        break;\n    }\n\n    /* Remember how many untrusted certs we have */\n    j = num;\n    /*\n     * at this point, chain should contain a list of untrusted certificates.\n     * We now need to add at least one trusted one, if possible, otherwise we\n     * complain.\n     */\n\n    do {\n        /*\n         * Examine last certificate in chain and see if it is self signed.\n         */\n        i = sk_X509_num(ctx->chain);\n        x = sk_X509_value(ctx->chain, i - 1);\n        if (ctx->check_issued(ctx, x, x)) {\n            /* we have a self signed certificate */\n            if (sk_X509_num(ctx->chain) == 1) {\n                /*\n                 * We have a single self signed certificate: see if we can\n                 * find it in the store. We must have an exact match to avoid\n                 * possible impersonation.\n                 */\n                ok = ctx->get_issuer(&xtmp, ctx, x);\n                if ((ok <= 0) || X509_cmp(x, xtmp)) {\n                    ctx->error = X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT;\n                    ctx->current_cert = x;\n                    ctx->error_depth = i - 1;\n                    if (ok == 1)\n                        X509_free(xtmp);\n                    bad_chain = 1;\n                    ok = cb(0, ctx);\n                    if (!ok)\n                        goto end;\n                } else {\n                    /*\n                     * We have a match: replace certificate with store\n                     * version so we get any trust settings.\n                     */\n                    X509_free(x);\n                    x = xtmp;\n                    (void)sk_X509_set(ctx->chain, i - 1, x);\n                    ctx->last_untrusted = 0;\n                }\n            } else {\n                /*\n                 * extract and save self signed certificate for later use\n                 */\n                chain_ss = sk_X509_pop(ctx->chain);\n                ctx->last_untrusted--;\n                num--;\n                j--;\n                x = sk_X509_value(ctx->chain, num - 1);\n            }\n        }\n        /* We now lookup certs from the certificate store */\n        for (;;) {\n            /* If we have enough, we break */\n            if (depth < num)\n                break;\n            /* If we are self signed, we break */\n            if (ctx->check_issued(ctx, x, x))\n                break;\n            ok = ctx->get_issuer(&xtmp, ctx, x);\n            if (ok < 0)\n                return ok;\n            if (ok == 0)\n                break;\n            x = xtmp;\n            if (!sk_X509_push(ctx->chain, x)) {\n                X509_free(xtmp);\n                X509err(X509_F_X509_VERIFY_CERT, ERR_R_MALLOC_FAILURE);\n                return 0;\n            }\n            num++;\n        }\n\n        /*\n         * If we haven't got a least one certificate from our store then check\n         * if there is an alternative chain that could be used.  We only do this\n         * if the user hasn't switched off alternate chain checking\n         */\n        retry = 0;\n        if (j == ctx->last_untrusted &&\n            !(ctx->param->flags & X509_V_FLAG_NO_ALT_CHAINS)) {\n            while (j-- > 1) {\n                xtmp2 = sk_X509_value(ctx->chain, j - 1);\n                ok = ctx->get_issuer(&xtmp, ctx, xtmp2);\n                if (ok < 0)\n                    goto end;\n                /* Check if we found an alternate chain */\n                if (ok > 0) {\n                    /*\n                     * Free up the found cert we'll add it again later\n                     */\n                    X509_free(xtmp);\n\n                    /*\n                     * Dump all the certs above this point - we've found an\n                     * alternate chain\n                     */\n                    while (num > j) {\n                        xtmp = sk_X509_pop(ctx->chain);\n                        X509_free(xtmp);\n                        num--;\n                        ctx->last_untrusted--;\n                    }\n                    retry = 1;\n                    break;\n                }\n            }\n        }\n    } while (retry);\n\n    /* Is last certificate looked up self signed? */\n    if (!ctx->check_issued(ctx, x, x)) {\n        if ((chain_ss == NULL) || !ctx->check_issued(ctx, x, chain_ss)) {\n            if (ctx->last_untrusted >= num)\n                ctx->error = X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY;\n            else\n                ctx->error = X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT;\n            ctx->current_cert = x;\n        } else {\n\n            sk_X509_push(ctx->chain, chain_ss);\n            num++;\n            ctx->last_untrusted = num;\n            ctx->current_cert = chain_ss;\n            ctx->error = X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN;\n            chain_ss = NULL;\n        }\n\n        ctx->error_depth = num - 1;\n        bad_chain = 1;\n        ok = cb(0, ctx);\n        if (!ok)\n            goto end;\n    }\n\n    /* We have the chain complete: now we need to check its purpose */\n    ok = check_chain_extensions(ctx);\n\n    if (!ok)\n        goto end;\n\n    /* Check name constraints */\n\n    ok = check_name_constraints(ctx);\n\n    if (!ok)\n        goto end;\n\n    /* The chain extensions are OK: check trust */\n\n    if (param->trust > 0)\n        ok = check_trust(ctx);\n\n    if (!ok)\n        goto end;\n\n    /* We may as well copy down any DSA parameters that are required */\n    X509_get_pubkey_parameters(NULL, ctx->chain);\n\n    /*\n     * Check revocation status: we do this after copying parameters because\n     * they may be needed for CRL signature verification.\n     */\n\n    ok = ctx->check_revocation(ctx);\n    if (!ok)\n        goto end;\n\n    /* At this point, we have a chain and need to verify it */\n    if (ctx->verify != NULL)\n        ok = ctx->verify(ctx);\n    else\n        ok = internal_verify(ctx);\n    if (!ok)\n        goto end;\n\n#ifndef OPENSSL_NO_RFC3779\n    /* RFC 3779 path validation, now that CRL check has been done */\n    ok = v3_asid_validate_path(ctx);\n    if (!ok)\n        goto end;\n    ok = v3_addr_validate_path(ctx);\n    if (!ok)\n        goto end;\n#endif\n\n    /* If we get this far evaluate policies */\n    if (!bad_chain && (ctx->param->flags & X509_V_FLAG_POLICY_CHECK))\n        ok = ctx->check_policy(ctx);\n    if (!ok)\n        goto end;\n    if (0) {\n end:\n        X509_get_pubkey_parameters(NULL, ctx->chain);\n    }\n    if (sktmp != NULL)\n        sk_X509_free(sktmp);\n    if (chain_ss != NULL)\n        X509_free(chain_ss);\n    return ok;\n}",
        "func": "int X509_verify_cert(X509_STORE_CTX *ctx)\n{\n    X509 *x, *xtmp, *xtmp2, *chain_ss = NULL;\n    int bad_chain = 0;\n    X509_VERIFY_PARAM *param = ctx->param;\n    int depth, i, ok = 0;\n    int num, j, retry;\n    int (*cb) (int xok, X509_STORE_CTX *xctx);\n    STACK_OF(X509) *sktmp = NULL;\n    if (ctx->cert == NULL) {\n        X509err(X509_F_X509_VERIFY_CERT, X509_R_NO_CERT_SET_FOR_US_TO_VERIFY);\n        return -1;\n    }\n\n    cb = ctx->verify_cb;\n\n    /*\n     * first we make sure the chain we are going to build is present and that\n     * the first entry is in place\n     */\n    if (ctx->chain == NULL) {\n        if (((ctx->chain = sk_X509_new_null()) == NULL) ||\n            (!sk_X509_push(ctx->chain, ctx->cert))) {\n            X509err(X509_F_X509_VERIFY_CERT, ERR_R_MALLOC_FAILURE);\n            goto end;\n        }\n        CRYPTO_add(&ctx->cert->references, 1, CRYPTO_LOCK_X509);\n        ctx->last_untrusted = 1;\n    }\n\n    /* We use a temporary STACK so we can chop and hack at it */\n    if (ctx->untrusted != NULL\n        && (sktmp = sk_X509_dup(ctx->untrusted)) == NULL) {\n        X509err(X509_F_X509_VERIFY_CERT, ERR_R_MALLOC_FAILURE);\n        goto end;\n    }\n\n    num = sk_X509_num(ctx->chain);\n    x = sk_X509_value(ctx->chain, num - 1);\n    depth = param->depth;\n\n    for (;;) {\n        /* If we have enough, we break */\n        if (depth < num)\n            break;              /* FIXME: If this happens, we should take\n                                 * note of it and, if appropriate, use the\n                                 * X509_V_ERR_CERT_CHAIN_TOO_LONG error code\n                                 * later. */\n\n        /* If we are self signed, we break */\n        if (ctx->check_issued(ctx, x, x))\n            break;\n\n        /* If we were passed a cert chain, use it first */\n        if (ctx->untrusted != NULL) {\n            xtmp = find_issuer(ctx, sktmp, x);\n            if (xtmp != NULL) {\n                if (!sk_X509_push(ctx->chain, xtmp)) {\n                    X509err(X509_F_X509_VERIFY_CERT, ERR_R_MALLOC_FAILURE);\n                    goto end;\n                }\n                CRYPTO_add(&xtmp->references, 1, CRYPTO_LOCK_X509);\n                (void)sk_X509_delete_ptr(sktmp, xtmp);\n                ctx->last_untrusted++;\n                x = xtmp;\n                num++;\n                /*\n                 * reparse the full chain for the next one\n                 */\n                continue;\n            }\n        }\n        break;\n    }\n\n    /* Remember how many untrusted certs we have */\n    j = num;\n    /*\n     * at this point, chain should contain a list of untrusted certificates.\n     * We now need to add at least one trusted one, if possible, otherwise we\n     * complain.\n     */\n\n    do {\n        /*\n         * Examine last certificate in chain and see if it is self signed.\n         */\n        i = sk_X509_num(ctx->chain);\n        x = sk_X509_value(ctx->chain, i - 1);\n        if (ctx->check_issued(ctx, x, x)) {\n            /* we have a self signed certificate */\n            if (sk_X509_num(ctx->chain) == 1) {\n                /*\n                 * We have a single self signed certificate: see if we can\n                 * find it in the store. We must have an exact match to avoid\n                 * possible impersonation.\n                 */\n                ok = ctx->get_issuer(&xtmp, ctx, x);\n                if ((ok <= 0) || X509_cmp(x, xtmp)) {\n                    ctx->error = X509_V_ERR_DEPTH_ZERO_SELF_SIGNED_CERT;\n                    ctx->current_cert = x;\n                    ctx->error_depth = i - 1;\n                    if (ok == 1)\n                        X509_free(xtmp);\n                    bad_chain = 1;\n                    ok = cb(0, ctx);\n                    if (!ok)\n                        goto end;\n                } else {\n                    /*\n                     * We have a match: replace certificate with store\n                     * version so we get any trust settings.\n                     */\n                    X509_free(x);\n                    x = xtmp;\n                    (void)sk_X509_set(ctx->chain, i - 1, x);\n                    ctx->last_untrusted = 0;\n                }\n            } else {\n                /*\n                 * extract and save self signed certificate for later use\n                 */\n                chain_ss = sk_X509_pop(ctx->chain);\n                ctx->last_untrusted--;\n                num--;\n                j--;\n                x = sk_X509_value(ctx->chain, num - 1);\n            }\n        }\n        /* We now lookup certs from the certificate store */\n        for (;;) {\n            /* If we have enough, we break */\n            if (depth < num)\n                break;\n            /* If we are self signed, we break */\n            if (ctx->check_issued(ctx, x, x))\n                break;\n            ok = ctx->get_issuer(&xtmp, ctx, x);\n            if (ok < 0)\n                return ok;\n            if (ok == 0)\n                break;\n            x = xtmp;\n            if (!sk_X509_push(ctx->chain, x)) {\n                X509_free(xtmp);\n                X509err(X509_F_X509_VERIFY_CERT, ERR_R_MALLOC_FAILURE);\n                return 0;\n            }\n            num++;\n        }\n\n        /*\n         * If we haven't got a least one certificate from our store then check\n         * if there is an alternative chain that could be used.  We only do this\n         * if the user hasn't switched off alternate chain checking\n         */\n        retry = 0;\n        if (j == ctx->last_untrusted &&\n            !(ctx->param->flags & X509_V_FLAG_NO_ALT_CHAINS)) {\n            while (j-- > 1) {\n                xtmp2 = sk_X509_value(ctx->chain, j - 1);\n                ok = ctx->get_issuer(&xtmp, ctx, xtmp2);\n                if (ok < 0)\n                    goto end;\n                /* Check if we found an alternate chain */\n                if (ok > 0) {\n                    /*\n                     * Free up the found cert we'll add it again later\n                     */\n                    X509_free(xtmp);\n\n                    /*\n                     * Dump all the certs above this point - we've found an\n                     * alternate chain\n                     */\n                    while (num > j) {\n                        xtmp = sk_X509_pop(ctx->chain);\n                        X509_free(xtmp);\n                        num--;\n                    }\n                    ctx->last_untrusted = sk_X509_num(ctx->chain);\n                    retry = 1;\n                    break;\n                }\n            }\n        }\n    } while (retry);\n\n    /* Is last certificate looked up self signed? */\n    if (!ctx->check_issued(ctx, x, x)) {\n        if ((chain_ss == NULL) || !ctx->check_issued(ctx, x, chain_ss)) {\n            if (ctx->last_untrusted >= num)\n                ctx->error = X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY;\n            else\n                ctx->error = X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT;\n            ctx->current_cert = x;\n        } else {\n\n            sk_X509_push(ctx->chain, chain_ss);\n            num++;\n            ctx->last_untrusted = num;\n            ctx->current_cert = chain_ss;\n            ctx->error = X509_V_ERR_SELF_SIGNED_CERT_IN_CHAIN;\n            chain_ss = NULL;\n        }\n\n        ctx->error_depth = num - 1;\n        bad_chain = 1;\n        ok = cb(0, ctx);\n        if (!ok)\n            goto end;\n    }\n\n    /* We have the chain complete: now we need to check its purpose */\n    ok = check_chain_extensions(ctx);\n\n    if (!ok)\n        goto end;\n\n    /* Check name constraints */\n\n    ok = check_name_constraints(ctx);\n\n    if (!ok)\n        goto end;\n\n    /* The chain extensions are OK: check trust */\n\n    if (param->trust > 0)\n        ok = check_trust(ctx);\n\n    if (!ok)\n        goto end;\n\n    /* We may as well copy down any DSA parameters that are required */\n    X509_get_pubkey_parameters(NULL, ctx->chain);\n\n    /*\n     * Check revocation status: we do this after copying parameters because\n     * they may be needed for CRL signature verification.\n     */\n\n    ok = ctx->check_revocation(ctx);\n    if (!ok)\n        goto end;\n\n    /* At this point, we have a chain and need to verify it */\n    if (ctx->verify != NULL)\n        ok = ctx->verify(ctx);\n    else\n        ok = internal_verify(ctx);\n    if (!ok)\n        goto end;\n\n#ifndef OPENSSL_NO_RFC3779\n    /* RFC 3779 path validation, now that CRL check has been done */\n    ok = v3_asid_validate_path(ctx);\n    if (!ok)\n        goto end;\n    ok = v3_addr_validate_path(ctx);\n    if (!ok)\n        goto end;\n#endif\n\n    /* If we get this far evaluate policies */\n    if (!bad_chain && (ctx->param->flags & X509_V_FLAG_POLICY_CHECK))\n        ok = ctx->check_policy(ctx);\n    if (!ok)\n        goto end;\n    if (0) {\n end:\n        X509_get_pubkey_parameters(NULL, ctx->chain);\n    }\n    if (sktmp != NULL)\n        sk_X509_free(sktmp);\n    if (chain_ss != NULL)\n        X509_free(chain_ss);\n    return ok;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -177,8 +177,8 @@\n                         xtmp = sk_X509_pop(ctx->chain);\n                         X509_free(xtmp);\n                         num--;\n-                        ctx->last_untrusted--;\n                     }\n+                    ctx->last_untrusted = sk_X509_num(ctx->chain);\n                     retry = 1;\n                     break;\n                 }",
        "diff_line_info": {
            "deleted_lines": [
                "                        ctx->last_untrusted--;"
            ],
            "added_lines": [
                "                    ctx->last_untrusted = sk_X509_num(ctx->chain);"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-1274",
        "func_name": "chromium/DownloadCommands::IsCommandEnabled",
        "description": "Google Chrome before 44.0.2403.89 does not ensure that the auto-open list omits all dangerous file types, which makes it easier for remote attackers to execute arbitrary code by providing a crafted file and leveraging a user's previous \"Always open files of this type\" choice, related to download_commands.cc and download_prefs.cc.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/39841e54180e2583dffa16fbbb9b99fd293821d0",
        "commit_title": "[Downloads] Prevent executable files from being opened automatically.",
        "commit_text": " Users can accidentally mark executable or other dangerous file types for opening automatically upon download. This change prevents such file types from being considered for auto open.  If the user already has any dangerous file types in the auto-open list, those entries will be ignored on new browser sessions. Any action that causes the persisted auto-open list to be updated will, as a side-effect, premanently remove any dangerous file types that were there.  Currently the list of file types that are excluded from auto open is maintained by chrome/browser/download/download_extension.cc.       (2) Verify that the \"Always open files of this type\" option is          disabled.   ",
        "func_before": "bool DownloadCommands::IsCommandEnabled(Command command) const {\n  switch (command) {\n    case SHOW_IN_FOLDER:\n      return download_item_->CanShowInFolder();\n    case OPEN_WHEN_COMPLETE:\n    case PLATFORM_OPEN:\n      return download_item_->CanOpenDownload() &&\n             !download_crx_util::IsExtensionDownload(*download_item_);\n    case ALWAYS_OPEN_TYPE:\n      // For temporary downloads, the target filename might be a temporary\n      // filename. Don't base an \"Always open\" decision based on it. Also\n      // exclude extensions.\n      return download_item_->CanOpenDownload() &&\n             !download_crx_util::IsExtensionDownload(*download_item_);\n    case CANCEL:\n      return !download_item_->IsDone();\n    case PAUSE:\n      return !download_item_->IsDone() && !download_item_->IsPaused() &&\n             download_item_->GetState() == content::DownloadItem::IN_PROGRESS;\n    case RESUME:\n      return download_item_->CanResume() &&\n             (download_item_->IsPaused() ||\n              download_item_->GetState() != content::DownloadItem::IN_PROGRESS);\n    case DISCARD:\n    case KEEP:\n    case LEARN_MORE_SCANNING:\n    case LEARN_MORE_INTERRUPTED:\n      return true;\n  }\n  NOTREACHED();\n  return false;\n}",
        "func": "bool DownloadCommands::IsCommandEnabled(Command command) const {\n  switch (command) {\n    case SHOW_IN_FOLDER:\n      return download_item_->CanShowInFolder();\n    case OPEN_WHEN_COMPLETE:\n    case PLATFORM_OPEN:\n      return download_item_->CanOpenDownload() &&\n             !download_crx_util::IsExtensionDownload(*download_item_);\n    case ALWAYS_OPEN_TYPE:\n      // For temporary downloads, the target filename might be a temporary\n      // filename. Don't base an \"Always open\" decision based on it. Also\n      // exclude extensions.\n      return download_item_->CanOpenDownload() &&\n             download_util::IsAllowedToOpenAutomatically(\n                 download_item_->GetTargetFilePath()) &&\n             !download_crx_util::IsExtensionDownload(*download_item_);\n    case CANCEL:\n      return !download_item_->IsDone();\n    case PAUSE:\n      return !download_item_->IsDone() && !download_item_->IsPaused() &&\n             download_item_->GetState() == content::DownloadItem::IN_PROGRESS;\n    case RESUME:\n      return download_item_->CanResume() &&\n             (download_item_->IsPaused() ||\n              download_item_->GetState() != content::DownloadItem::IN_PROGRESS);\n    case DISCARD:\n    case KEEP:\n    case LEARN_MORE_SCANNING:\n    case LEARN_MORE_INTERRUPTED:\n      return true;\n  }\n  NOTREACHED();\n  return false;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -11,6 +11,8 @@\n       // filename. Don't base an \"Always open\" decision based on it. Also\n       // exclude extensions.\n       return download_item_->CanOpenDownload() &&\n+             download_util::IsAllowedToOpenAutomatically(\n+                 download_item_->GetTargetFilePath()) &&\n              !download_crx_util::IsExtensionDownload(*download_item_);\n     case CANCEL:\n       return !download_item_->IsDone();",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "             download_util::IsAllowedToOpenAutomatically(",
                "                 download_item_->GetTargetFilePath()) &&"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-1274",
        "func_name": "chromium/DownloadPrefs::DownloadPrefs",
        "description": "Google Chrome before 44.0.2403.89 does not ensure that the auto-open list omits all dangerous file types, which makes it easier for remote attackers to execute arbitrary code by providing a crafted file and leveraging a user's previous \"Always open files of this type\" choice, related to download_commands.cc and download_prefs.cc.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/39841e54180e2583dffa16fbbb9b99fd293821d0",
        "commit_title": "[Downloads] Prevent executable files from being opened automatically.",
        "commit_text": " Users can accidentally mark executable or other dangerous file types for opening automatically upon download. This change prevents such file types from being considered for auto open.  If the user already has any dangerous file types in the auto-open list, those entries will be ignored on new browser sessions. Any action that causes the persisted auto-open list to be updated will, as a side-effect, premanently remove any dangerous file types that were there.  Currently the list of file types that are excluded from auto open is maintained by chrome/browser/download/download_extension.cc.       (2) Verify that the \"Always open files of this type\" option is          disabled.   ",
        "func_before": "DownloadPrefs::DownloadPrefs(Profile* profile) : profile_(profile) {\n  PrefService* prefs = profile->GetPrefs();\n\n#if defined(OS_CHROMEOS)\n  // On Chrome OS, the default download directory is different for each profile.\n  // If the profile-unaware default path (from GetDefaultDownloadDirectory())\n  // is set (this happens during the initial preference registration in static\n  // RegisterProfilePrefs()), alter by GetDefaultDownloadDirectoryForProfile().\n  // file_manager::util::MigratePathFromOldFormat will do this.\n  const char* path_pref[] = {\n      prefs::kSaveFileDefaultDirectory,\n      prefs::kDownloadDefaultDirectory\n  };\n  for (size_t i = 0; i < arraysize(path_pref); ++i) {\n    const base::FilePath current = prefs->GetFilePath(path_pref[i]);\n    base::FilePath migrated;\n    if (!current.empty() &&\n        file_manager::util::MigratePathFromOldFormat(\n            profile_, current, &migrated)) {\n      prefs->SetFilePath(path_pref[i], migrated);\n    }\n  }\n\n  // Ensure that the default download directory exists.\n  BrowserThread::PostTask(\n      BrowserThread::FILE, FROM_HERE,\n      base::Bind(base::IgnoreResult(&base::CreateDirectory),\n                 GetDefaultDownloadDirectoryForProfile()));\n#endif  // defined(OS_CHROMEOS)\n\n#if defined(OS_WIN) || defined(OS_LINUX) || \\\n    (defined(OS_MACOSX) && !defined(OS_IOS))\n  should_open_pdf_in_system_reader_ =\n      prefs->GetBoolean(prefs::kOpenPdfDownloadInSystemReader);\n#endif\n\n  // If the download path is dangerous we forcefully reset it. But if we do\n  // so we set a flag to make sure we only do it once, to avoid fighting\n  // the user if he really wants it on an unsafe place such as the desktop.\n  if (!prefs->GetBoolean(prefs::kDownloadDirUpgraded)) {\n    base::FilePath current_download_dir = prefs->GetFilePath(\n        prefs::kDownloadDefaultDirectory);\n    if (DownloadPathIsDangerous(current_download_dir)) {\n      prefs->SetFilePath(prefs::kDownloadDefaultDirectory,\n                         GetDefaultDownloadDirectoryForProfile());\n    }\n    prefs->SetBoolean(prefs::kDownloadDirUpgraded, true);\n  }\n\n  prompt_for_download_.Init(prefs::kPromptForDownload, prefs);\n  download_path_.Init(prefs::kDownloadDefaultDirectory, prefs);\n  save_file_path_.Init(prefs::kSaveFileDefaultDirectory, prefs);\n  save_file_type_.Init(prefs::kSaveFileType, prefs);\n\n  // We store any file extension that should be opened automatically at\n  // download completion in this pref.\n  std::string extensions_to_open =\n      prefs->GetString(prefs::kDownloadExtensionsToOpen);\n  std::vector<std::string> extensions;\n  base::SplitString(extensions_to_open, ':', &extensions);\n\n  for (size_t i = 0; i < extensions.size(); ++i) {\n#if defined(OS_POSIX)\n    base::FilePath path(extensions[i]);\n#elif defined(OS_WIN)\n    base::FilePath path(base::UTF8ToWide(extensions[i]));\n#endif\n    if (!extensions[i].empty() &&\n        download_util::GetFileDangerLevel(path) == download_util::NOT_DANGEROUS)\n      auto_open_.insert(path.value());\n  }\n}",
        "func": "DownloadPrefs::DownloadPrefs(Profile* profile) : profile_(profile) {\n  PrefService* prefs = profile->GetPrefs();\n\n#if defined(OS_CHROMEOS)\n  // On Chrome OS, the default download directory is different for each profile.\n  // If the profile-unaware default path (from GetDefaultDownloadDirectory())\n  // is set (this happens during the initial preference registration in static\n  // RegisterProfilePrefs()), alter by GetDefaultDownloadDirectoryForProfile().\n  // file_manager::util::MigratePathFromOldFormat will do this.\n  const char* path_pref[] = {\n      prefs::kSaveFileDefaultDirectory,\n      prefs::kDownloadDefaultDirectory\n  };\n  for (size_t i = 0; i < arraysize(path_pref); ++i) {\n    const base::FilePath current = prefs->GetFilePath(path_pref[i]);\n    base::FilePath migrated;\n    if (!current.empty() &&\n        file_manager::util::MigratePathFromOldFormat(\n            profile_, current, &migrated)) {\n      prefs->SetFilePath(path_pref[i], migrated);\n    }\n  }\n\n  // Ensure that the default download directory exists.\n  BrowserThread::PostTask(\n      BrowserThread::FILE, FROM_HERE,\n      base::Bind(base::IgnoreResult(&base::CreateDirectory),\n                 GetDefaultDownloadDirectoryForProfile()));\n#endif  // defined(OS_CHROMEOS)\n\n#if defined(OS_WIN) || defined(OS_LINUX) || \\\n    (defined(OS_MACOSX) && !defined(OS_IOS))\n  should_open_pdf_in_system_reader_ =\n      prefs->GetBoolean(prefs::kOpenPdfDownloadInSystemReader);\n#endif\n\n  // If the download path is dangerous we forcefully reset it. But if we do\n  // so we set a flag to make sure we only do it once, to avoid fighting\n  // the user if he really wants it on an unsafe place such as the desktop.\n  if (!prefs->GetBoolean(prefs::kDownloadDirUpgraded)) {\n    base::FilePath current_download_dir = prefs->GetFilePath(\n        prefs::kDownloadDefaultDirectory);\n    if (DownloadPathIsDangerous(current_download_dir)) {\n      prefs->SetFilePath(prefs::kDownloadDefaultDirectory,\n                         GetDefaultDownloadDirectoryForProfile());\n    }\n    prefs->SetBoolean(prefs::kDownloadDirUpgraded, true);\n  }\n\n  prompt_for_download_.Init(prefs::kPromptForDownload, prefs);\n  download_path_.Init(prefs::kDownloadDefaultDirectory, prefs);\n  save_file_path_.Init(prefs::kSaveFileDefaultDirectory, prefs);\n  save_file_type_.Init(prefs::kSaveFileType, prefs);\n\n  // We store any file extension that should be opened automatically at\n  // download completion in this pref.\n  std::string extensions_to_open =\n      prefs->GetString(prefs::kDownloadExtensionsToOpen);\n  std::vector<std::string> extensions;\n  base::SplitString(extensions_to_open, ':', &extensions);\n\n  for (const auto& extension_string : extensions) {\n#if defined(OS_POSIX)\n    base::FilePath::StringType extension = extension_string;\n#elif defined(OS_WIN)\n    base::FilePath::StringType extension = base::UTF8ToWide(extension_string);\n#endif\n    // If it's empty or malformed or not allowed to open automatically, then\n    // skip the entry. Any such entries will be dropped from preferences the\n    // next time SaveAutoOpenState() is called.\n    if (extension.empty() ||\n        *extension.begin() == base::FilePath::kExtensionSeparator)\n      continue;\n    // Construct something like \".<extension>\", since\n    // IsAllowedToOpenAutomatically() needs a filename.\n    base::FilePath filename_with_extension = base::FilePath(\n        base::FilePath::StringType(1, base::FilePath::kExtensionSeparator) +\n        extension);\n\n    // Note that the list of file types that are not allowed to open\n    // automatically can change in the future. When the list is tightened, it is\n    // expected that some entries in the users' auto open list will get dropped\n    // permanently as a result.\n    if (download_util::IsAllowedToOpenAutomatically(filename_with_extension))\n      auto_open_.insert(extension);\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -59,14 +59,29 @@\n   std::vector<std::string> extensions;\n   base::SplitString(extensions_to_open, ':', &extensions);\n \n-  for (size_t i = 0; i < extensions.size(); ++i) {\n+  for (const auto& extension_string : extensions) {\n #if defined(OS_POSIX)\n-    base::FilePath path(extensions[i]);\n+    base::FilePath::StringType extension = extension_string;\n #elif defined(OS_WIN)\n-    base::FilePath path(base::UTF8ToWide(extensions[i]));\n+    base::FilePath::StringType extension = base::UTF8ToWide(extension_string);\n #endif\n-    if (!extensions[i].empty() &&\n-        download_util::GetFileDangerLevel(path) == download_util::NOT_DANGEROUS)\n-      auto_open_.insert(path.value());\n+    // If it's empty or malformed or not allowed to open automatically, then\n+    // skip the entry. Any such entries will be dropped from preferences the\n+    // next time SaveAutoOpenState() is called.\n+    if (extension.empty() ||\n+        *extension.begin() == base::FilePath::kExtensionSeparator)\n+      continue;\n+    // Construct something like \".<extension>\", since\n+    // IsAllowedToOpenAutomatically() needs a filename.\n+    base::FilePath filename_with_extension = base::FilePath(\n+        base::FilePath::StringType(1, base::FilePath::kExtensionSeparator) +\n+        extension);\n+\n+    // Note that the list of file types that are not allowed to open\n+    // automatically can change in the future. When the list is tightened, it is\n+    // expected that some entries in the users' auto open list will get dropped\n+    // permanently as a result.\n+    if (download_util::IsAllowedToOpenAutomatically(filename_with_extension))\n+      auto_open_.insert(extension);\n   }\n }",
        "diff_line_info": {
            "deleted_lines": [
                "  for (size_t i = 0; i < extensions.size(); ++i) {",
                "    base::FilePath path(extensions[i]);",
                "    base::FilePath path(base::UTF8ToWide(extensions[i]));",
                "    if (!extensions[i].empty() &&",
                "        download_util::GetFileDangerLevel(path) == download_util::NOT_DANGEROUS)",
                "      auto_open_.insert(path.value());"
            ],
            "added_lines": [
                "  for (const auto& extension_string : extensions) {",
                "    base::FilePath::StringType extension = extension_string;",
                "    base::FilePath::StringType extension = base::UTF8ToWide(extension_string);",
                "    // If it's empty or malformed or not allowed to open automatically, then",
                "    // skip the entry. Any such entries will be dropped from preferences the",
                "    // next time SaveAutoOpenState() is called.",
                "    if (extension.empty() ||",
                "        *extension.begin() == base::FilePath::kExtensionSeparator)",
                "      continue;",
                "    // Construct something like \".<extension>\", since",
                "    // IsAllowedToOpenAutomatically() needs a filename.",
                "    base::FilePath filename_with_extension = base::FilePath(",
                "        base::FilePath::StringType(1, base::FilePath::kExtensionSeparator) +",
                "        extension);",
                "",
                "    // Note that the list of file types that are not allowed to open",
                "    // automatically can change in the future. When the list is tightened, it is",
                "    // expected that some entries in the users' auto open list will get dropped",
                "    // permanently as a result.",
                "    if (download_util::IsAllowedToOpenAutomatically(filename_with_extension))",
                "      auto_open_.insert(extension);"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-1274",
        "func_name": "chromium/DownloadPrefs::IsAutoOpenEnabledBasedOnExtension",
        "description": "Google Chrome before 44.0.2403.89 does not ensure that the auto-open list omits all dangerous file types, which makes it easier for remote attackers to execute arbitrary code by providing a crafted file and leveraging a user's previous \"Always open files of this type\" choice, related to download_commands.cc and download_prefs.cc.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/39841e54180e2583dffa16fbbb9b99fd293821d0",
        "commit_title": "[Downloads] Prevent executable files from being opened automatically.",
        "commit_text": " Users can accidentally mark executable or other dangerous file types for opening automatically upon download. This change prevents such file types from being considered for auto open.  If the user already has any dangerous file types in the auto-open list, those entries will be ignored on new browser sessions. Any action that causes the persisted auto-open list to be updated will, as a side-effect, premanently remove any dangerous file types that were there.  Currently the list of file types that are excluded from auto open is maintained by chrome/browser/download/download_extension.cc.       (2) Verify that the \"Always open files of this type\" option is          disabled.   ",
        "func_before": "bool DownloadPrefs::IsAutoOpenEnabledBasedOnExtension(\n    const base::FilePath& path) const {\n  base::FilePath::StringType extension = path.Extension();\n  if (extension.empty())\n    return false;\n  DCHECK(extension[0] == base::FilePath::kExtensionSeparator);\n  extension.erase(0, 1);\n#if defined(OS_WIN) || defined(OS_LINUX) || \\\n    (defined(OS_MACOSX) && !defined(OS_IOS))\n  if (extension == FILE_PATH_LITERAL(\"pdf\") && ShouldOpenPdfInSystemReader())\n    return true;\n#endif\n  return auto_open_.find(extension) != auto_open_.end();\n}",
        "func": "bool DownloadPrefs::IsAutoOpenEnabledBasedOnExtension(\n    const base::FilePath& path) const {\n  base::FilePath::StringType extension = path.Extension();\n  if (extension.empty())\n    return false;\n  DCHECK(extension[0] == base::FilePath::kExtensionSeparator);\n  extension.erase(0, 1);\n#if defined(OS_WIN) || defined(OS_LINUX) || \\\n    (defined(OS_MACOSX) && !defined(OS_IOS))\n  if (extension == FILE_PATH_LITERAL(\"pdf\") && ShouldOpenPdfInSystemReader())\n    return true;\n#endif\n\n  return auto_open_.find(extension) != auto_open_.end();\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -10,5 +10,6 @@\n   if (extension == FILE_PATH_LITERAL(\"pdf\") && ShouldOpenPdfInSystemReader())\n     return true;\n #endif\n+\n   return auto_open_.find(extension) != auto_open_.end();\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2015-1274",
        "func_name": "chromium/DownloadPrefs::EnableAutoOpenBasedOnExtension",
        "description": "Google Chrome before 44.0.2403.89 does not ensure that the auto-open list omits all dangerous file types, which makes it easier for remote attackers to execute arbitrary code by providing a crafted file and leveraging a user's previous \"Always open files of this type\" choice, related to download_commands.cc and download_prefs.cc.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/39841e54180e2583dffa16fbbb9b99fd293821d0",
        "commit_title": "[Downloads] Prevent executable files from being opened automatically.",
        "commit_text": " Users can accidentally mark executable or other dangerous file types for opening automatically upon download. This change prevents such file types from being considered for auto open.  If the user already has any dangerous file types in the auto-open list, those entries will be ignored on new browser sessions. Any action that causes the persisted auto-open list to be updated will, as a side-effect, premanently remove any dangerous file types that were there.  Currently the list of file types that are excluded from auto open is maintained by chrome/browser/download/download_extension.cc.       (2) Verify that the \"Always open files of this type\" option is          disabled.   ",
        "func_before": "bool DownloadPrefs::EnableAutoOpenBasedOnExtension(\n    const base::FilePath& file_name) {\n  base::FilePath::StringType extension = file_name.Extension();\n  if (extension.empty())\n    return false;\n  DCHECK(extension[0] == base::FilePath::kExtensionSeparator);\n  extension.erase(0, 1);\n\n  auto_open_.insert(extension);\n  SaveAutoOpenState();\n  return true;\n}",
        "func": "bool DownloadPrefs::EnableAutoOpenBasedOnExtension(\n    const base::FilePath& file_name) {\n  base::FilePath::StringType extension = file_name.Extension();\n  if (!download_util::IsAllowedToOpenAutomatically(file_name))\n    return false;\n\n  DCHECK(extension[0] == base::FilePath::kExtensionSeparator);\n  extension.erase(0, 1);\n\n  auto_open_.insert(extension);\n  SaveAutoOpenState();\n  return true;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,8 +1,9 @@\n bool DownloadPrefs::EnableAutoOpenBasedOnExtension(\n     const base::FilePath& file_name) {\n   base::FilePath::StringType extension = file_name.Extension();\n-  if (extension.empty())\n+  if (!download_util::IsAllowedToOpenAutomatically(file_name))\n     return false;\n+\n   DCHECK(extension[0] == base::FilePath::kExtensionSeparator);\n   extension.erase(0, 1);\n ",
        "diff_line_info": {
            "deleted_lines": [
                "  if (extension.empty())"
            ],
            "added_lines": [
                "  if (!download_util::IsAllowedToOpenAutomatically(file_name))",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2015-1274",
        "func_name": "chromium/GetFileDangerLevel",
        "description": "Google Chrome before 44.0.2403.89 does not ensure that the auto-open list omits all dangerous file types, which makes it easier for remote attackers to execute arbitrary code by providing a crafted file and leveraging a user's previous \"Always open files of this type\" choice, related to download_commands.cc and download_prefs.cc.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/39841e54180e2583dffa16fbbb9b99fd293821d0",
        "commit_title": "[Downloads] Prevent executable files from being opened automatically.",
        "commit_text": " Users can accidentally mark executable or other dangerous file types for opening automatically upon download. This change prevents such file types from being considered for auto open.  If the user already has any dangerous file types in the auto-open list, those entries will be ignored on new browser sessions. Any action that causes the persisted auto-open list to be updated will, as a side-effect, premanently remove any dangerous file types that were there.  Currently the list of file types that are excluded from auto open is maintained by chrome/browser/download/download_extension.cc.       (2) Verify that the \"Always open files of this type\" option is          disabled.   ",
        "func_before": "DownloadDangerLevel GetFileDangerLevel(const base::FilePath& path) {\n  base::FilePath::StringType extension(path.FinalExtension());\n  if (extension.empty())\n    return NOT_DANGEROUS;\n  if (!base::IsStringASCII(extension))\n    return NOT_DANGEROUS;\n#if defined(OS_WIN)\n  std::string ascii_extension = base::UTF16ToASCII(extension);\n#elif defined(OS_POSIX)\n  std::string ascii_extension = extension;\n#endif\n\n  // Strip out leading dot if it's still there\n  if (ascii_extension[0] == base::FilePath::kExtensionSeparator)\n    ascii_extension.erase(0, 1);\n\n  for (size_t i = 0; i < arraysize(g_executables); ++i) {\n    if (base::LowerCaseEqualsASCII(ascii_extension, g_executables[i].extension))\n      return g_executables[i].level;\n  }\n  return NOT_DANGEROUS;\n}",
        "func": "DownloadDangerLevel GetFileDangerLevel(const base::FilePath& path) {\n  return GetFileType(path).danger_level;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,22 +1,3 @@\n DownloadDangerLevel GetFileDangerLevel(const base::FilePath& path) {\n-  base::FilePath::StringType extension(path.FinalExtension());\n-  if (extension.empty())\n-    return NOT_DANGEROUS;\n-  if (!base::IsStringASCII(extension))\n-    return NOT_DANGEROUS;\n-#if defined(OS_WIN)\n-  std::string ascii_extension = base::UTF16ToASCII(extension);\n-#elif defined(OS_POSIX)\n-  std::string ascii_extension = extension;\n-#endif\n-\n-  // Strip out leading dot if it's still there\n-  if (ascii_extension[0] == base::FilePath::kExtensionSeparator)\n-    ascii_extension.erase(0, 1);\n-\n-  for (size_t i = 0; i < arraysize(g_executables); ++i) {\n-    if (base::LowerCaseEqualsASCII(ascii_extension, g_executables[i].extension))\n-      return g_executables[i].level;\n-  }\n-  return NOT_DANGEROUS;\n+  return GetFileType(path).danger_level;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "  base::FilePath::StringType extension(path.FinalExtension());",
                "  if (extension.empty())",
                "    return NOT_DANGEROUS;",
                "  if (!base::IsStringASCII(extension))",
                "    return NOT_DANGEROUS;",
                "#if defined(OS_WIN)",
                "  std::string ascii_extension = base::UTF16ToASCII(extension);",
                "#elif defined(OS_POSIX)",
                "  std::string ascii_extension = extension;",
                "#endif",
                "",
                "  // Strip out leading dot if it's still there",
                "  if (ascii_extension[0] == base::FilePath::kExtensionSeparator)",
                "    ascii_extension.erase(0, 1);",
                "",
                "  for (size_t i = 0; i < arraysize(g_executables); ++i) {",
                "    if (base::LowerCaseEqualsASCII(ascii_extension, g_executables[i].extension))",
                "      return g_executables[i].level;",
                "  }",
                "  return NOT_DANGEROUS;"
            ],
            "added_lines": [
                "  return GetFileType(path).danger_level;"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-1278",
        "func_name": "chromium/WebContentsImpl::CancelModalDialogsForRenderManager",
        "description": "content/browser/web_contents/web_contents_impl.cc in Google Chrome before 44.0.2403.89 does not ensure that a PDF document's modal dialog is closed upon navigation to an interstitial page, which allows remote attackers to spoof URLs via a crafted document, as demonstrated by the alert_dialog.pdf document.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/89a0f782193755ad7a0b93c58dbcc1b96528405f",
        "commit_title": "Dismiss browser plugin modal dialogs when the embedder needs to.",
        "commit_text": " Test from wjmaclean@.  PDF simply shows an alert dialog using script.    ",
        "func_before": "void WebContentsImpl::CancelModalDialogsForRenderManager() {\n  // We need to cancel modal dialogs when doing a process swap, since the load\n  // deferrer would prevent us from swapping out. We also clear the state\n  // because this is a cross-process navigation, which means that it's a new\n  // site that should not have to pay for the sins of its predecessor.\n  if (dialog_manager_)\n    dialog_manager_->ResetDialogState(this);\n}",
        "func": "void WebContentsImpl::CancelModalDialogsForRenderManager() {\n  // We need to cancel modal dialogs when doing a process swap, since the load\n  // deferrer would prevent us from swapping out. We also clear the state\n  // because this is a cross-process navigation, which means that it's a new\n  // site that should not have to pay for the sins of its predecessor.\n  //\n  // Note that we don't bother telling browser_plugin_embedder_ because the\n  // cross-process navigation will either destroy the browser plugins or not\n  // require their dialogs to close.\n  if (dialog_manager_)\n    dialog_manager_->ResetDialogState(this);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,6 +3,10 @@\n   // deferrer would prevent us from swapping out. We also clear the state\n   // because this is a cross-process navigation, which means that it's a new\n   // site that should not have to pay for the sins of its predecessor.\n+  //\n+  // Note that we don't bother telling browser_plugin_embedder_ because the\n+  // cross-process navigation will either destroy the browser plugins or not\n+  // require their dialogs to close.\n   if (dialog_manager_)\n     dialog_manager_->ResetDialogState(this);\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "  //",
                "  // Note that we don't bother telling browser_plugin_embedder_ because the",
                "  // cross-process navigation will either destroy the browser plugins or not",
                "  // require their dialogs to close."
            ]
        }
    },
    {
        "cve_id": "CVE-2015-1278",
        "func_name": "chromium/WebContentsImpl::AttachInterstitialPage",
        "description": "content/browser/web_contents/web_contents_impl.cc in Google Chrome before 44.0.2403.89 does not ensure that a PDF document's modal dialog is closed upon navigation to an interstitial page, which allows remote attackers to spoof URLs via a crafted document, as demonstrated by the alert_dialog.pdf document.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/89a0f782193755ad7a0b93c58dbcc1b96528405f",
        "commit_title": "Dismiss browser plugin modal dialogs when the embedder needs to.",
        "commit_text": " Test from wjmaclean@.  PDF simply shows an alert dialog using script.    ",
        "func_before": "void WebContentsImpl::AttachInterstitialPage(\n    InterstitialPageImpl* interstitial_page) {\n  DCHECK(interstitial_page);\n  GetRenderManager()->set_interstitial_page(interstitial_page);\n\n  // Cancel any visible dialogs so that they don't interfere with the\n  // interstitial.\n  if (dialog_manager_)\n    dialog_manager_->CancelActiveAndPendingDialogs(this);\n\n  FOR_EACH_OBSERVER(WebContentsObserver, observers_,\n                    DidAttachInterstitialPage());\n}",
        "func": "void WebContentsImpl::AttachInterstitialPage(\n    InterstitialPageImpl* interstitial_page) {\n  DCHECK(interstitial_page);\n  GetRenderManager()->set_interstitial_page(interstitial_page);\n\n  // Cancel any visible dialogs so that they don't interfere with the\n  // interstitial.\n  CancelActiveAndPendingDialogs();\n\n  FOR_EACH_OBSERVER(WebContentsObserver, observers_,\n                    DidAttachInterstitialPage());\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,8 +5,7 @@\n \n   // Cancel any visible dialogs so that they don't interfere with the\n   // interstitial.\n-  if (dialog_manager_)\n-    dialog_manager_->CancelActiveAndPendingDialogs(this);\n+  CancelActiveAndPendingDialogs();\n \n   FOR_EACH_OBSERVER(WebContentsObserver, observers_,\n                     DidAttachInterstitialPage());",
        "diff_line_info": {
            "deleted_lines": [
                "  if (dialog_manager_)",
                "    dialog_manager_->CancelActiveAndPendingDialogs(this);"
            ],
            "added_lines": [
                "  CancelActiveAndPendingDialogs();"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-1278",
        "func_name": "chromium/WebContentsImpl::RenderViewTerminated",
        "description": "content/browser/web_contents/web_contents_impl.cc in Google Chrome before 44.0.2403.89 does not ensure that a PDF document's modal dialog is closed upon navigation to an interstitial page, which allows remote attackers to spoof URLs via a crafted document, as demonstrated by the alert_dialog.pdf document.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/89a0f782193755ad7a0b93c58dbcc1b96528405f",
        "commit_title": "Dismiss browser plugin modal dialogs when the embedder needs to.",
        "commit_text": " Test from wjmaclean@.  PDF simply shows an alert dialog using script.    ",
        "func_before": "void WebContentsImpl::RenderViewTerminated(RenderViewHost* rvh,\n                                           base::TerminationStatus status,\n                                           int error_code) {\n  if (rvh != GetRenderViewHost()) {\n    // The pending page's RenderViewHost is gone.\n    return;\n  }\n\n  // Ensure fullscreen mode is exited in the |delegate_| since a crashed\n  // renderer may not have made a clean exit.\n  if (IsFullscreenForCurrentTab())\n    ExitFullscreenMode();\n\n  // Cancel any visible dialogs so they are not left dangling over the sad tab.\n  if (dialog_manager_)\n    dialog_manager_->CancelActiveAndPendingDialogs(this);\n\n  if (delegate_)\n    delegate_->HideValidationMessage(this);\n\n  SetIsLoading(false, true, nullptr);\n  NotifyDisconnected();\n  SetIsCrashed(status, error_code);\n\n  // Reset the loading progress. TODO(avi): What does it mean to have a\n  // \"renderer crash\" when there is more than one renderer process serving a\n  // webpage? Once this function is called at a more granular frame level, we\n  // probably will need to more granularly reset the state here.\n  ResetLoadProgressState();\n\n  FOR_EACH_OBSERVER(WebContentsObserver,\n                    observers_,\n                    RenderProcessGone(GetCrashedStatus()));\n}",
        "func": "void WebContentsImpl::RenderViewTerminated(RenderViewHost* rvh,\n                                           base::TerminationStatus status,\n                                           int error_code) {\n  if (rvh != GetRenderViewHost()) {\n    // The pending page's RenderViewHost is gone.\n    return;\n  }\n\n  // Ensure fullscreen mode is exited in the |delegate_| since a crashed\n  // renderer may not have made a clean exit.\n  if (IsFullscreenForCurrentTab())\n    ExitFullscreenMode();\n\n  // Cancel any visible dialogs so they are not left dangling over the sad tab.\n  CancelActiveAndPendingDialogs();\n\n  if (delegate_)\n    delegate_->HideValidationMessage(this);\n\n  SetIsLoading(false, true, nullptr);\n  NotifyDisconnected();\n  SetIsCrashed(status, error_code);\n\n  // Reset the loading progress. TODO(avi): What does it mean to have a\n  // \"renderer crash\" when there is more than one renderer process serving a\n  // webpage? Once this function is called at a more granular frame level, we\n  // probably will need to more granularly reset the state here.\n  ResetLoadProgressState();\n\n  FOR_EACH_OBSERVER(WebContentsObserver,\n                    observers_,\n                    RenderProcessGone(GetCrashedStatus()));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -12,8 +12,7 @@\n     ExitFullscreenMode();\n \n   // Cancel any visible dialogs so they are not left dangling over the sad tab.\n-  if (dialog_manager_)\n-    dialog_manager_->CancelActiveAndPendingDialogs(this);\n+  CancelActiveAndPendingDialogs();\n \n   if (delegate_)\n     delegate_->HideValidationMessage(this);",
        "diff_line_info": {
            "deleted_lines": [
                "  if (dialog_manager_)",
                "    dialog_manager_->CancelActiveAndPendingDialogs(this);"
            ],
            "added_lines": [
                "  CancelActiveAndPendingDialogs();"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-1278",
        "func_name": "chromium/WebContentsImpl::DidNavigateAnyFramePostCommit",
        "description": "content/browser/web_contents/web_contents_impl.cc in Google Chrome before 44.0.2403.89 does not ensure that a PDF document's modal dialog is closed upon navigation to an interstitial page, which allows remote attackers to spoof URLs via a crafted document, as demonstrated by the alert_dialog.pdf document.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/89a0f782193755ad7a0b93c58dbcc1b96528405f",
        "commit_title": "Dismiss browser plugin modal dialogs when the embedder needs to.",
        "commit_text": " Test from wjmaclean@.  PDF simply shows an alert dialog using script.    ",
        "func_before": "void WebContentsImpl::DidNavigateAnyFramePostCommit(\n    RenderFrameHostImpl* render_frame_host,\n    const LoadCommittedDetails& details,\n    const FrameHostMsg_DidCommitProvisionalLoad_Params& params) {\n  // Now that something has committed, we don't need to track whether the\n  // initial page has been accessed.\n  has_accessed_initial_document_ = false;\n\n  // If we navigate off the page, close all JavaScript dialogs.\n  if (dialog_manager_ && !details.is_in_page)\n    dialog_manager_->CancelActiveAndPendingDialogs(this);\n\n  // Notify observers about navigation.\n  FOR_EACH_OBSERVER(WebContentsObserver, observers_,\n                    DidNavigateAnyFrame(render_frame_host, details, params));\n}",
        "func": "void WebContentsImpl::DidNavigateAnyFramePostCommit(\n    RenderFrameHostImpl* render_frame_host,\n    const LoadCommittedDetails& details,\n    const FrameHostMsg_DidCommitProvisionalLoad_Params& params) {\n  // Now that something has committed, we don't need to track whether the\n  // initial page has been accessed.\n  has_accessed_initial_document_ = false;\n\n  // If we navigate off the page, close all JavaScript dialogs.\n  if (!details.is_in_page)\n    CancelActiveAndPendingDialogs();\n\n  // Notify observers about navigation.\n  FOR_EACH_OBSERVER(WebContentsObserver, observers_,\n                    DidNavigateAnyFrame(render_frame_host, details, params));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -7,8 +7,8 @@\n   has_accessed_initial_document_ = false;\n \n   // If we navigate off the page, close all JavaScript dialogs.\n-  if (dialog_manager_ && !details.is_in_page)\n-    dialog_manager_->CancelActiveAndPendingDialogs(this);\n+  if (!details.is_in_page)\n+    CancelActiveAndPendingDialogs();\n \n   // Notify observers about navigation.\n   FOR_EACH_OBSERVER(WebContentsObserver, observers_,",
        "diff_line_info": {
            "deleted_lines": [
                "  if (dialog_manager_ && !details.is_in_page)",
                "    dialog_manager_->CancelActiveAndPendingDialogs(this);"
            ],
            "added_lines": [
                "  if (!details.is_in_page)",
                "    CancelActiveAndPendingDialogs();"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-1281",
        "func_name": "chromium/clearLoader",
        "description": "core/loader/ImageLoader.cpp in Blink, as used in Google Chrome before 44.0.2403.89, does not properly determine the V8 context of a microtask, which allows remote attackers to bypass Content Security Policy (CSP) restrictions by providing an image from an unintended source.",
        "git_url": "https://github.com/chromium/chromium/commit/9fb1e9fc1f3829f9597f830e599fc40fadc84db3",
        "commit_title": "Reland \"Correctly set ScriptState in the image loader microtask\"",
        "commit_text": " Original review: https://codereview.chromium.org/1153233002/   ",
        "func_before": "void clearLoader()\n    {\n        m_loader = 0;\n    }",
        "func": "void clearLoader()\n    {\n        m_loader = 0;\n        m_scriptState.clear();\n    }",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,5 @@\n void clearLoader()\n     {\n         m_loader = 0;\n+        m_scriptState.clear();\n     }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "        m_scriptState.clear();"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-1281",
        "func_name": "chromium/Task",
        "description": "core/loader/ImageLoader.cpp in Blink, as used in Google Chrome before 44.0.2403.89, does not properly determine the V8 context of a microtask, which allows remote attackers to bypass Content Security Policy (CSP) restrictions by providing an image from an unintended source.",
        "git_url": "https://github.com/chromium/chromium/commit/9fb1e9fc1f3829f9597f830e599fc40fadc84db3",
        "commit_title": "Reland \"Correctly set ScriptState in the image loader microtask\"",
        "commit_text": " Original review: https://codereview.chromium.org/1153233002/   ",
        "func_before": "Task(ImageLoader* loader, UpdateFromElementBehavior updateBehavior)\n        : m_loader(loader)\n        , m_shouldBypassMainWorldCSP(shouldBypassMainWorldCSP(loader))\n        , m_updateBehavior(updateBehavior)\n        , m_weakFactory(this)\n    {\n    }",
        "func": "Task(ImageLoader* loader, UpdateFromElementBehavior updateBehavior)\n        : m_loader(loader)\n        , m_shouldBypassMainWorldCSP(shouldBypassMainWorldCSP(loader))\n        , m_updateBehavior(updateBehavior)\n        , m_weakFactory(this)\n    {\n        v8::Isolate* isolate = V8PerIsolateData::mainThreadIsolate();\n        v8::HandleScope scope(isolate);\n        v8::Local<v8::Context> context = isolate->GetCurrentContext();\n        // If we're invoked from C++ without a V8 context on the stack, we should\n        // run the microtask in the context of the element's document's main world.\n        if (context.IsEmpty())\n            m_scriptState = ScriptState::from(toV8Context(&loader->element()->document(), DOMWrapperWorld::mainWorld()));\n        else\n            m_scriptState = ScriptState::from(context);\n    }",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,4 +4,13 @@\n         , m_updateBehavior(updateBehavior)\n         , m_weakFactory(this)\n     {\n+        v8::Isolate* isolate = V8PerIsolateData::mainThreadIsolate();\n+        v8::HandleScope scope(isolate);\n+        v8::Local<v8::Context> context = isolate->GetCurrentContext();\n+        // If we're invoked from C++ without a V8 context on the stack, we should\n+        // run the microtask in the context of the element's document's main world.\n+        if (context.IsEmpty())\n+            m_scriptState = ScriptState::from(toV8Context(&loader->element()->document(), DOMWrapperWorld::mainWorld()));\n+        else\n+            m_scriptState = ScriptState::from(context);\n     }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "        v8::Isolate* isolate = V8PerIsolateData::mainThreadIsolate();",
                "        v8::HandleScope scope(isolate);",
                "        v8::Local<v8::Context> context = isolate->GetCurrentContext();",
                "        // If we're invoked from C++ without a V8 context on the stack, we should",
                "        // run the microtask in the context of the element's document's main world.",
                "        if (context.IsEmpty())",
                "            m_scriptState = ScriptState::from(toV8Context(&loader->element()->document(), DOMWrapperWorld::mainWorld()));",
                "        else",
                "            m_scriptState = ScriptState::from(context);"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-1281",
        "func_name": "chromium/run",
        "description": "core/loader/ImageLoader.cpp in Blink, as used in Google Chrome before 44.0.2403.89, does not properly determine the V8 context of a microtask, which allows remote attackers to bypass Content Security Policy (CSP) restrictions by providing an image from an unintended source.",
        "git_url": "https://github.com/chromium/chromium/commit/9fb1e9fc1f3829f9597f830e599fc40fadc84db3",
        "commit_title": "Reland \"Correctly set ScriptState in the image loader microtask\"",
        "commit_text": " Original review: https://codereview.chromium.org/1153233002/   ",
        "func_before": "virtual void run() override\n    {\n        if (m_loader) {\n#if ENABLE(OILPAN)\n            // Oilpan: this WebThread::Task microtask may run after the\n            // loader has been GCed, but not yet lazily swept & finalized\n            // (when this task's loader reference will be cleared.)\n            //\n            // Handle this transient condition by explicitly checking here\n            // before going ahead with the update operation. Unsafe to do it\n            // if so, as the objects that the loader refers to may have been\n            // finalized by this time.\n            if (Heap::willObjectBeLazilySwept(m_loader))\n                return;\n#endif\n            m_loader->doUpdateFromElement(m_shouldBypassMainWorldCSP, m_updateBehavior);\n        }\n    }",
        "func": "void run() override\n    {\n        if (m_loader) {\n#if ENABLE(OILPAN)\n            // Oilpan: this WebThread::Task microtask may run after the\n            // loader has been GCed, but not yet lazily swept & finalized\n            // (when this task's loader reference will be cleared.)\n            //\n            // Handle this transient condition by explicitly checking here\n            // before going ahead with the update operation. Unsafe to do it\n            // if so, as the objects that the loader refers to may have been\n            // finalized by this time.\n            if (Heap::willObjectBeLazilySwept(m_loader))\n                return;\n#endif\n            if (m_scriptState->contextIsValid()) {\n                ScriptState::Scope scope(m_scriptState.get());\n                m_loader->doUpdateFromElement(m_shouldBypassMainWorldCSP, m_updateBehavior);\n            } else {\n                m_loader->doUpdateFromElement(m_shouldBypassMainWorldCSP, m_updateBehavior);\n            }\n        }\n    }",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,4 @@\n-virtual void run() override\n+void run() override\n     {\n         if (m_loader) {\n #if ENABLE(OILPAN)\n@@ -13,6 +13,11 @@\n             if (Heap::willObjectBeLazilySwept(m_loader))\n                 return;\n #endif\n-            m_loader->doUpdateFromElement(m_shouldBypassMainWorldCSP, m_updateBehavior);\n+            if (m_scriptState->contextIsValid()) {\n+                ScriptState::Scope scope(m_scriptState.get());\n+                m_loader->doUpdateFromElement(m_shouldBypassMainWorldCSP, m_updateBehavior);\n+            } else {\n+                m_loader->doUpdateFromElement(m_shouldBypassMainWorldCSP, m_updateBehavior);\n+            }\n         }\n     }",
        "diff_line_info": {
            "deleted_lines": [
                "virtual void run() override",
                "            m_loader->doUpdateFromElement(m_shouldBypassMainWorldCSP, m_updateBehavior);"
            ],
            "added_lines": [
                "void run() override",
                "            if (m_scriptState->contextIsValid()) {",
                "                ScriptState::Scope scope(m_scriptState.get());",
                "                m_loader->doUpdateFromElement(m_shouldBypassMainWorldCSP, m_updateBehavior);",
                "            } else {",
                "                m_loader->doUpdateFromElement(m_shouldBypassMainWorldCSP, m_updateBehavior);",
                "            }"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-1281",
        "func_name": "chromium/ImageLoader::updateFromElement",
        "description": "core/loader/ImageLoader.cpp in Blink, as used in Google Chrome before 44.0.2403.89, does not properly determine the V8 context of a microtask, which allows remote attackers to bypass Content Security Policy (CSP) restrictions by providing an image from an unintended source.",
        "git_url": "https://github.com/chromium/chromium/commit/9fb1e9fc1f3829f9597f830e599fc40fadc84db3",
        "commit_title": "Reland \"Correctly set ScriptState in the image loader microtask\"",
        "commit_text": " Original review: https://codereview.chromium.org/1153233002/   ",
        "func_before": "void ImageLoader::updateFromElement(UpdateFromElementBehavior updateBehavior)\n{\n    AtomicString imageSourceURL = m_element->imageSourceURL();\n    m_suppressErrorEvents = (updateBehavior == UpdateSizeChanged);\n\n    if (updateBehavior == UpdateIgnorePreviousError)\n        clearFailedLoadURL();\n\n    if (!m_failedLoadURL.isEmpty() && imageSourceURL == m_failedLoadURL)\n        return;\n\n    // If we have a pending task, we have to clear it -- either we're\n    // now loading immediately, or we need to reset the task's state.\n    if (m_pendingTask) {\n        m_pendingTask->clearLoader();\n        m_pendingTask.clear();\n    }\n\n    KURL url = imageSourceToKURL(imageSourceURL);\n    if (shouldLoadImmediately(url)) {\n        doUpdateFromElement(DoNotBypassMainWorldCSP, updateBehavior);\n        return;\n    }\n    // Allow the idiom \"img.src=''; img.src='..\" to clear down the image before\n    // an asynchronous load completes.\n    if (imageSourceURL.isEmpty()) {\n        ImageResource* image = m_image.get();\n        if (image)\n            image->removeClient(this);\n        m_image = nullptr;\n    }\n    enqueueImageLoadingMicroTask(updateBehavior);\n}",
        "func": "void ImageLoader::updateFromElement(UpdateFromElementBehavior updateBehavior)\n{\n    AtomicString imageSourceURL = m_element->imageSourceURL();\n    m_suppressErrorEvents = (updateBehavior == UpdateSizeChanged);\n\n    if (updateBehavior == UpdateIgnorePreviousError)\n        clearFailedLoadURL();\n\n    if (!m_failedLoadURL.isEmpty() && imageSourceURL == m_failedLoadURL)\n        return;\n\n    // If we have a pending task, we have to clear it -- either we're\n    // now loading immediately, or we need to reset the task's state.\n    if (m_pendingTask) {\n        m_pendingTask->clearLoader();\n        m_pendingTask.clear();\n    }\n\n    KURL url = imageSourceToKURL(imageSourceURL);\n    if (shouldLoadImmediately(url)) {\n        doUpdateFromElement(DoNotBypassMainWorldCSP, updateBehavior);\n        return;\n    }\n    // Allow the idiom \"img.src=''; img.src='..\" to clear down the image before\n    // an asynchronous load completes.\n    if (imageSourceURL.isEmpty()) {\n        ImageResource* image = m_image.get();\n        if (image)\n            image->removeClient(this);\n        m_image = nullptr;\n    }\n\n    // Don't load images for inactive documents. We don't want to slow down the\n    // raw HTML parsing case by loading images we don't intend to display.\n    Document& document = m_element->document();\n    if (document.isActive())\n        enqueueImageLoadingMicroTask(updateBehavior);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -29,5 +29,10 @@\n             image->removeClient(this);\n         m_image = nullptr;\n     }\n-    enqueueImageLoadingMicroTask(updateBehavior);\n+\n+    // Don't load images for inactive documents. We don't want to slow down the\n+    // raw HTML parsing case by loading images we don't intend to display.\n+    Document& document = m_element->document();\n+    if (document.isActive())\n+        enqueueImageLoadingMicroTask(updateBehavior);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    enqueueImageLoadingMicroTask(updateBehavior);"
            ],
            "added_lines": [
                "",
                "    // Don't load images for inactive documents. We don't want to slow down the",
                "    // raw HTML parsing case by loading images we don't intend to display.",
                "    Document& document = m_element->document();",
                "    if (document.isActive())",
                "        enqueueImageLoadingMicroTask(updateBehavior);"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-5128",
        "func_name": "chromium/setScriptableObjectProperty",
        "description": "objects.cc in Google V8 before 5.2.361.27, as used in Google Chrome before 52.0.2743.82, does not prevent API interceptors from modifying a store target without setting a property, which allows remote attackers to bypass the Same Origin Policy via a crafted web site.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/dbbdebecc3416092a833f8ac14a849500be8a2eb",
        "commit_title": "Only access a plugin's scriptable object, and not also its prototype chain",
        "commit_text": "  Review-Url: https://codereview.chromium.org/2084183004 ",
        "func_before": "void setScriptableObjectProperty(PropertyType property, v8::Local<v8::Value> value, const v8::PropertyCallbackInfo<v8::Value>& info)\n{\n    ASSERT(!value.IsEmpty());\n    HTMLPlugInElement* impl = ElementType::toImpl(info.Holder());\n    RefPtr<SharedPersistent<v8::Object>> wrapper = impl->pluginWrapper();\n    if (!wrapper)\n        return;\n\n    v8::Local<v8::Object> instance = wrapper->newLocal(info.GetIsolate());\n    if (instance.IsEmpty())\n        return;\n\n    // FIXME: The gTalk pepper plugin is the only plugin to make use of\n    // SetProperty and that is being deprecated. This can be removed as soon as\n    // it goes away.\n    // Call SetProperty on a pepper plugin's scriptable object. Note that we\n    // never set the return value here which would indicate that the plugin has\n    // intercepted the SetProperty call, which means that the property on the\n    // DOM element will also be set. For plugin's that don't intercept the call\n    // (all except gTalk) this makes no difference at all. For gTalk the fact\n    // that the property on the DOM element also gets set is inconsequential.\n    v8::Maybe<bool> unused = instance->Set(info.GetIsolate()->GetCurrentContext(), property, value);\n    ALLOW_UNUSED_LOCAL(unused);\n}",
        "func": "void setScriptableObjectProperty(PropertyType property, v8::Local<v8::Value> value, const v8::PropertyCallbackInfo<v8::Value>& info)\n{\n    ASSERT(!value.IsEmpty());\n    HTMLPlugInElement* impl = ElementType::toImpl(info.Holder());\n    RefPtr<SharedPersistent<v8::Object>> wrapper = impl->pluginWrapper();\n    if (!wrapper)\n        return;\n\n    v8::Local<v8::Object> instance = wrapper->newLocal(info.GetIsolate());\n    if (instance.IsEmpty())\n        return;\n\n    // FIXME: The gTalk pepper plugin is the only plugin to make use of\n    // SetProperty and that is being deprecated. This can be removed as soon as\n    // it goes away.\n    // Call SetProperty on a pepper plugin's scriptable object. Note that we\n    // never set the return value here which would indicate that the plugin has\n    // intercepted the SetProperty call, which means that the property on the\n    // DOM element will also be set. For plugin's that don't intercept the call\n    // (all except gTalk) this makes no difference at all. For gTalk the fact\n    // that the property on the DOM element also gets set is inconsequential.\n    v8CallBoolean(instance->CreateDataProperty(info.GetIsolate()->GetCurrentContext(), property, value));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -19,6 +19,5 @@\n     // DOM element will also be set. For plugin's that don't intercept the call\n     // (all except gTalk) this makes no difference at all. For gTalk the fact\n     // that the property on the DOM element also gets set is inconsequential.\n-    v8::Maybe<bool> unused = instance->Set(info.GetIsolate()->GetCurrentContext(), property, value);\n-    ALLOW_UNUSED_LOCAL(unused);\n+    v8CallBoolean(instance->CreateDataProperty(info.GetIsolate()->GetCurrentContext(), property, value));\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    v8::Maybe<bool> unused = instance->Set(info.GetIsolate()->GetCurrentContext(), property, value);",
                "    ALLOW_UNUSED_LOCAL(unused);"
            ],
            "added_lines": [
                "    v8CallBoolean(instance->CreateDataProperty(info.GetIsolate()->GetCurrentContext(), property, value));"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-5128",
        "func_name": "chromium/getScriptableObjectProperty",
        "description": "objects.cc in Google V8 before 5.2.361.27, as used in Google Chrome before 52.0.2743.82, does not prevent API interceptors from modifying a store target without setting a property, which allows remote attackers to bypass the Same Origin Policy via a crafted web site.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/dbbdebecc3416092a833f8ac14a849500be8a2eb",
        "commit_title": "Only access a plugin's scriptable object, and not also its prototype chain",
        "commit_text": "  Review-Url: https://codereview.chromium.org/2084183004 ",
        "func_before": "void getScriptableObjectProperty(PropertyType property, const v8::PropertyCallbackInfo<v8::Value>& info)\n{\n    HTMLPlugInElement* impl = ElementType::toImpl(info.Holder());\n    RefPtr<SharedPersistent<v8::Object>> wrapper = impl->pluginWrapper();\n    if (!wrapper)\n        return;\n\n    v8::Local<v8::Object> instance = wrapper->newLocal(info.GetIsolate());\n    if (instance.IsEmpty())\n        return;\n\n    v8::Local<v8::Value> value;\n    if (!instance->Get(info.GetIsolate()->GetCurrentContext(), property).ToLocal(&value))\n        return;\n\n    // We quit here to allow the binding code to look up general HTMLObjectElement properties\n    // if they are not overriden by plugin.\n    if (value->IsUndefined() && !v8CallBoolean(instance->Has(info.GetIsolate()->GetCurrentContext(), property)))\n        return;\n\n    v8SetReturnValue(info, value);\n}",
        "func": "void getScriptableObjectProperty(PropertyType property, const v8::PropertyCallbackInfo<v8::Value>& info)\n{\n    HTMLPlugInElement* impl = ElementType::toImpl(info.Holder());\n    RefPtr<SharedPersistent<v8::Object>> wrapper = impl->pluginWrapper();\n    if (!wrapper)\n        return;\n\n    v8::Local<v8::Object> instance = wrapper->newLocal(info.GetIsolate());\n    if (instance.IsEmpty())\n        return;\n\n    if (!v8CallBoolean(instance->HasOwnProperty(info.GetIsolate()->GetCurrentContext(), property)))\n        return;\n\n    v8::Local<v8::Value> value;\n    if (!instance->Get(info.GetIsolate()->GetCurrentContext(), property).ToLocal(&value))\n        return;\n\n    v8SetReturnValue(info, value);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -9,14 +9,12 @@\n     if (instance.IsEmpty())\n         return;\n \n+    if (!v8CallBoolean(instance->HasOwnProperty(info.GetIsolate()->GetCurrentContext(), property)))\n+        return;\n+\n     v8::Local<v8::Value> value;\n     if (!instance->Get(info.GetIsolate()->GetCurrentContext(), property).ToLocal(&value))\n         return;\n \n-    // We quit here to allow the binding code to look up general HTMLObjectElement properties\n-    // if they are not overriden by plugin.\n-    if (value->IsUndefined() && !v8CallBoolean(instance->Has(info.GetIsolate()->GetCurrentContext(), property)))\n-        return;\n-\n     v8SetReturnValue(info, value);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    // We quit here to allow the binding code to look up general HTMLObjectElement properties",
                "    // if they are not overriden by plugin.",
                "    if (value->IsUndefined() && !v8CallBoolean(instance->Has(info.GetIsolate()->GetCurrentContext(), property)))",
                "        return;",
                ""
            ],
            "added_lines": [
                "    if (!v8CallBoolean(instance->HasOwnProperty(info.GetIsolate()->GetCurrentContext(), property)))",
                "        return;",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2016-5128",
        "func_name": "chromium/Object::SetPropertyInternal",
        "description": "objects.cc in Google V8 before 5.2.361.27, as used in Google Chrome before 52.0.2743.82, does not prevent API interceptors from modifying a store target without setting a property, which allows remote attackers to bypass the Same Origin Policy via a crafted web site.",
        "git_url": "https://chromium.googlesource.com/v8/v8/+/2c8ca9ad09281d4138ae363566051e45afd0838c",
        "commit_title": "Make sure api interceptors don't change the store target w/o storing",
        "commit_text": "  Review-Url: https://codereview.chromium.org/2082633002 ",
        "func_before": "Maybe<bool> Object::SetPropertyInternal(LookupIterator* it,\n                                        Handle<Object> value,\n                                        LanguageMode language_mode,\n                                        StoreFromKeyed store_mode,\n                                        bool* found) {\n  it->UpdateProtector();\n  DCHECK(it->IsFound());\n  ShouldThrow should_throw =\n      is_sloppy(language_mode) ? DONT_THROW : THROW_ON_ERROR;\n\n  // Make sure that the top context does not change when doing callbacks or\n  // interceptor calls.\n  AssertNoContextChange ncc(it->isolate());\n\n  do {\n    switch (it->state()) {\n      case LookupIterator::NOT_FOUND:\n        UNREACHABLE();\n\n      case LookupIterator::ACCESS_CHECK:\n        if (it->HasAccess()) break;\n        // Check whether it makes sense to reuse the lookup iterator. Here it\n        // might still call into setters up the prototype chain.\n        return JSObject::SetPropertyWithFailedAccessCheck(it, value,\n                                                          should_throw);\n\n      case LookupIterator::JSPROXY:\n        return JSProxy::SetProperty(it->GetHolder<JSProxy>(), it->GetName(),\n                                    value, it->GetReceiver(), language_mode);\n\n      case LookupIterator::INTERCEPTOR:\n        if (it->HolderIsReceiverOrHiddenPrototype()) {\n          Maybe<bool> result =\n              JSObject::SetPropertyWithInterceptor(it, should_throw, value);\n          if (result.IsNothing() || result.FromJust()) return result;\n        } else {\n          Maybe<PropertyAttributes> maybe_attributes =\n              JSObject::GetPropertyAttributesWithInterceptor(it);\n          if (!maybe_attributes.IsJust()) return Nothing<bool>();\n          if (maybe_attributes.FromJust() == ABSENT) break;\n          if ((maybe_attributes.FromJust() & READ_ONLY) != 0) {\n            return WriteToReadOnlyProperty(it, value, should_throw);\n          }\n          *found = false;\n          return Nothing<bool>();\n        }\n        break;\n\n      case LookupIterator::ACCESSOR: {\n        if (it->IsReadOnly()) {\n          return WriteToReadOnlyProperty(it, value, should_throw);\n        }\n        Handle<Object> accessors = it->GetAccessors();\n        if (accessors->IsAccessorInfo() &&\n            !it->HolderIsReceiverOrHiddenPrototype() &&\n            AccessorInfo::cast(*accessors)->is_special_data_property()) {\n          *found = false;\n          return Nothing<bool>();\n        }\n        return SetPropertyWithAccessor(it, value, should_throw);\n      }\n      case LookupIterator::INTEGER_INDEXED_EXOTIC:\n        // TODO(verwaest): We should throw an exception if holder is receiver.\n        return Just(true);\n\n      case LookupIterator::DATA:\n        if (it->IsReadOnly()) {\n          return WriteToReadOnlyProperty(it, value, should_throw);\n        }\n        if (it->HolderIsReceiverOrHiddenPrototype()) {\n          return SetDataProperty(it, value);\n        }\n      // Fall through.\n      case LookupIterator::TRANSITION:\n        *found = false;\n        return Nothing<bool>();\n    }\n    it->Next();\n  } while (it->IsFound());\n\n  *found = false;\n  return Nothing<bool>();\n}",
        "func": "Maybe<bool> Object::SetPropertyInternal(LookupIterator* it,\n                                        Handle<Object> value,\n                                        LanguageMode language_mode,\n                                        StoreFromKeyed store_mode,\n                                        bool* found) {\n  it->UpdateProtector();\n  DCHECK(it->IsFound());\n  ShouldThrow should_throw =\n      is_sloppy(language_mode) ? DONT_THROW : THROW_ON_ERROR;\n\n  // Make sure that the top context does not change when doing callbacks or\n  // interceptor calls.\n  AssertNoContextChange ncc(it->isolate());\n\n  do {\n    switch (it->state()) {\n      case LookupIterator::NOT_FOUND:\n        UNREACHABLE();\n\n      case LookupIterator::ACCESS_CHECK:\n        if (it->HasAccess()) break;\n        // Check whether it makes sense to reuse the lookup iterator. Here it\n        // might still call into setters up the prototype chain.\n        return JSObject::SetPropertyWithFailedAccessCheck(it, value,\n                                                          should_throw);\n\n      case LookupIterator::JSPROXY:\n        return JSProxy::SetProperty(it->GetHolder<JSProxy>(), it->GetName(),\n                                    value, it->GetReceiver(), language_mode);\n\n      case LookupIterator::INTERCEPTOR: {\n        Handle<Map> store_target_map =\n            handle(it->GetStoreTarget()->map(), it->isolate());\n        if (it->HolderIsReceiverOrHiddenPrototype()) {\n          Maybe<bool> result =\n              JSObject::SetPropertyWithInterceptor(it, should_throw, value);\n          if (result.IsNothing() || result.FromJust()) return result;\n          // Interceptor modified the store target but failed to set the\n          // property.\n          Utils::ApiCheck(*store_target_map == it->GetStoreTarget()->map(),\n                          it->IsElement() ? \"v8::IndexedPropertySetterCallback\"\n                                          : \"v8::NamedPropertySetterCallback\",\n                          \"Interceptor silently changed store target.\");\n        } else {\n          Maybe<PropertyAttributes> maybe_attributes =\n              JSObject::GetPropertyAttributesWithInterceptor(it);\n          if (!maybe_attributes.IsJust()) return Nothing<bool>();\n          if ((maybe_attributes.FromJust() & READ_ONLY) != 0) {\n            return WriteToReadOnlyProperty(it, value, should_throw);\n          }\n          // Interceptor modified the store target but failed to set the\n          // property.\n          Utils::ApiCheck(*store_target_map == it->GetStoreTarget()->map(),\n                          it->IsElement() ? \"v8::IndexedPropertySetterCallback\"\n                                          : \"v8::NamedPropertySetterCallback\",\n                          \"Interceptor silently changed store target.\");\n          if (maybe_attributes.FromJust() == ABSENT) break;\n          *found = false;\n          return Nothing<bool>();\n        }\n        break;\n      }\n\n      case LookupIterator::ACCESSOR: {\n        if (it->IsReadOnly()) {\n          return WriteToReadOnlyProperty(it, value, should_throw);\n        }\n        Handle<Object> accessors = it->GetAccessors();\n        if (accessors->IsAccessorInfo() &&\n            !it->HolderIsReceiverOrHiddenPrototype() &&\n            AccessorInfo::cast(*accessors)->is_special_data_property()) {\n          *found = false;\n          return Nothing<bool>();\n        }\n        return SetPropertyWithAccessor(it, value, should_throw);\n      }\n      case LookupIterator::INTEGER_INDEXED_EXOTIC:\n        // TODO(verwaest): We should throw an exception if holder is receiver.\n        return Just(true);\n\n      case LookupIterator::DATA:\n        if (it->IsReadOnly()) {\n          return WriteToReadOnlyProperty(it, value, should_throw);\n        }\n        if (it->HolderIsReceiverOrHiddenPrototype()) {\n          return SetDataProperty(it, value);\n        }\n      // Fall through.\n      case LookupIterator::TRANSITION:\n        *found = false;\n        return Nothing<bool>();\n    }\n    it->Next();\n  } while (it->IsFound());\n\n  *found = false;\n  return Nothing<bool>();\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -28,23 +28,38 @@\n         return JSProxy::SetProperty(it->GetHolder<JSProxy>(), it->GetName(),\n                                     value, it->GetReceiver(), language_mode);\n \n-      case LookupIterator::INTERCEPTOR:\n+      case LookupIterator::INTERCEPTOR: {\n+        Handle<Map> store_target_map =\n+            handle(it->GetStoreTarget()->map(), it->isolate());\n         if (it->HolderIsReceiverOrHiddenPrototype()) {\n           Maybe<bool> result =\n               JSObject::SetPropertyWithInterceptor(it, should_throw, value);\n           if (result.IsNothing() || result.FromJust()) return result;\n+          // Interceptor modified the store target but failed to set the\n+          // property.\n+          Utils::ApiCheck(*store_target_map == it->GetStoreTarget()->map(),\n+                          it->IsElement() ? \"v8::IndexedPropertySetterCallback\"\n+                                          : \"v8::NamedPropertySetterCallback\",\n+                          \"Interceptor silently changed store target.\");\n         } else {\n           Maybe<PropertyAttributes> maybe_attributes =\n               JSObject::GetPropertyAttributesWithInterceptor(it);\n           if (!maybe_attributes.IsJust()) return Nothing<bool>();\n-          if (maybe_attributes.FromJust() == ABSENT) break;\n           if ((maybe_attributes.FromJust() & READ_ONLY) != 0) {\n             return WriteToReadOnlyProperty(it, value, should_throw);\n           }\n+          // Interceptor modified the store target but failed to set the\n+          // property.\n+          Utils::ApiCheck(*store_target_map == it->GetStoreTarget()->map(),\n+                          it->IsElement() ? \"v8::IndexedPropertySetterCallback\"\n+                                          : \"v8::NamedPropertySetterCallback\",\n+                          \"Interceptor silently changed store target.\");\n+          if (maybe_attributes.FromJust() == ABSENT) break;\n           *found = false;\n           return Nothing<bool>();\n         }\n         break;\n+      }\n \n       case LookupIterator::ACCESSOR: {\n         if (it->IsReadOnly()) {",
        "diff_line_info": {
            "deleted_lines": [
                "      case LookupIterator::INTERCEPTOR:",
                "          if (maybe_attributes.FromJust() == ABSENT) break;"
            ],
            "added_lines": [
                "      case LookupIterator::INTERCEPTOR: {",
                "        Handle<Map> store_target_map =",
                "            handle(it->GetStoreTarget()->map(), it->isolate());",
                "          // Interceptor modified the store target but failed to set the",
                "          // property.",
                "          Utils::ApiCheck(*store_target_map == it->GetStoreTarget()->map(),",
                "                          it->IsElement() ? \"v8::IndexedPropertySetterCallback\"",
                "                                          : \"v8::NamedPropertySetterCallback\",",
                "                          \"Interceptor silently changed store target.\");",
                "          // Interceptor modified the store target but failed to set the",
                "          // property.",
                "          Utils::ApiCheck(*store_target_map == it->GetStoreTarget()->map(),",
                "                          it->IsElement() ? \"v8::IndexedPropertySetterCallback\"",
                "                                          : \"v8::NamedPropertySetterCallback\",",
                "                          \"Interceptor silently changed store target.\");",
                "          if (maybe_attributes.FromJust() == ABSENT) break;",
                "      }"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-5128",
        "func_name": "chromium/Object::SetPropertyInternal",
        "description": "objects.cc in Google V8 before 5.2.361.27, as used in Google Chrome before 52.0.2743.82, does not prevent API interceptors from modifying a store target without setting a property, which allows remote attackers to bypass the Same Origin Policy via a crafted web site.",
        "git_url": "https://chromium.googlesource.com/v8/v8/+/72657cda42e7055755c4cacceeafd34626440d26",
        "commit_title": "Version 5.2.361.26 (cherry-pick)",
        "commit_text": " Merged 2c8ca9ad09281d4138ae363566051e45afd0838c  Make sure api interceptors don't change the store target w/o storing  TBR=verwaest@chromium.org   ",
        "func_before": "Maybe<bool> Object::SetPropertyInternal(LookupIterator* it,\n                                        Handle<Object> value,\n                                        LanguageMode language_mode,\n                                        StoreFromKeyed store_mode,\n                                        bool* found) {\n  it->UpdateProtector();\n  DCHECK(it->IsFound());\n  ShouldThrow should_throw =\n      is_sloppy(language_mode) ? DONT_THROW : THROW_ON_ERROR;\n\n  // Make sure that the top context does not change when doing callbacks or\n  // interceptor calls.\n  AssertNoContextChange ncc(it->isolate());\n\n  do {\n    switch (it->state()) {\n      case LookupIterator::NOT_FOUND:\n        UNREACHABLE();\n\n      case LookupIterator::ACCESS_CHECK:\n        if (it->HasAccess()) break;\n        // Check whether it makes sense to reuse the lookup iterator. Here it\n        // might still call into setters up the prototype chain.\n        return JSObject::SetPropertyWithFailedAccessCheck(it, value,\n                                                          should_throw);\n\n      case LookupIterator::JSPROXY:\n        return JSProxy::SetProperty(it->GetHolder<JSProxy>(), it->GetName(),\n                                    value, it->GetReceiver(), language_mode);\n\n      case LookupIterator::INTERCEPTOR:\n        if (it->HolderIsReceiverOrHiddenPrototype()) {\n          Maybe<bool> result =\n              JSObject::SetPropertyWithInterceptor(it, should_throw, value);\n          if (result.IsNothing() || result.FromJust()) return result;\n        } else {\n          Maybe<PropertyAttributes> maybe_attributes =\n              JSObject::GetPropertyAttributesWithInterceptor(it);\n          if (!maybe_attributes.IsJust()) return Nothing<bool>();\n          if (maybe_attributes.FromJust() == ABSENT) break;\n          if ((maybe_attributes.FromJust() & READ_ONLY) != 0) {\n            return WriteToReadOnlyProperty(it, value, should_throw);\n          }\n          *found = false;\n          return Nothing<bool>();\n        }\n        break;\n\n      case LookupIterator::ACCESSOR: {\n        if (it->IsReadOnly()) {\n          return WriteToReadOnlyProperty(it, value, should_throw);\n        }\n        Handle<Object> accessors = it->GetAccessors();\n        if (accessors->IsAccessorInfo() &&\n            !it->HolderIsReceiverOrHiddenPrototype() &&\n            AccessorInfo::cast(*accessors)->is_special_data_property()) {\n          *found = false;\n          return Nothing<bool>();\n        }\n        return SetPropertyWithAccessor(it, value, should_throw);\n      }\n      case LookupIterator::INTEGER_INDEXED_EXOTIC:\n        // TODO(verwaest): We should throw an exception if holder is receiver.\n        return Just(true);\n\n      case LookupIterator::DATA:\n        if (it->IsReadOnly()) {\n          return WriteToReadOnlyProperty(it, value, should_throw);\n        }\n        if (it->HolderIsReceiverOrHiddenPrototype()) {\n          return SetDataProperty(it, value);\n        }\n      // Fall through.\n      case LookupIterator::TRANSITION:\n        *found = false;\n        return Nothing<bool>();\n    }\n    it->Next();\n  } while (it->IsFound());\n\n  *found = false;\n  return Nothing<bool>();\n}",
        "func": "Maybe<bool> Object::SetPropertyInternal(LookupIterator* it,\n                                        Handle<Object> value,\n                                        LanguageMode language_mode,\n                                        StoreFromKeyed store_mode,\n                                        bool* found) {\n  it->UpdateProtector();\n  DCHECK(it->IsFound());\n  ShouldThrow should_throw =\n      is_sloppy(language_mode) ? DONT_THROW : THROW_ON_ERROR;\n\n  // Make sure that the top context does not change when doing callbacks or\n  // interceptor calls.\n  AssertNoContextChange ncc(it->isolate());\n\n  do {\n    switch (it->state()) {\n      case LookupIterator::NOT_FOUND:\n        UNREACHABLE();\n\n      case LookupIterator::ACCESS_CHECK:\n        if (it->HasAccess()) break;\n        // Check whether it makes sense to reuse the lookup iterator. Here it\n        // might still call into setters up the prototype chain.\n        return JSObject::SetPropertyWithFailedAccessCheck(it, value,\n                                                          should_throw);\n\n      case LookupIterator::JSPROXY:\n        return JSProxy::SetProperty(it->GetHolder<JSProxy>(), it->GetName(),\n                                    value, it->GetReceiver(), language_mode);\n\n      case LookupIterator::INTERCEPTOR: {\n        Handle<Map> store_target_map =\n            handle(it->GetStoreTarget()->map(), it->isolate());\n        if (it->HolderIsReceiverOrHiddenPrototype()) {\n          Maybe<bool> result =\n              JSObject::SetPropertyWithInterceptor(it, should_throw, value);\n          if (result.IsNothing() || result.FromJust()) return result;\n          // Interceptor modified the store target but failed to set the\n          // property.\n          Utils::ApiCheck(*store_target_map == it->GetStoreTarget()->map(),\n                          it->IsElement() ? \"v8::IndexedPropertySetterCallback\"\n                                          : \"v8::NamedPropertySetterCallback\",\n                          \"Interceptor silently changed store target.\");\n        } else {\n          Maybe<PropertyAttributes> maybe_attributes =\n              JSObject::GetPropertyAttributesWithInterceptor(it);\n          if (!maybe_attributes.IsJust()) return Nothing<bool>();\n          if ((maybe_attributes.FromJust() & READ_ONLY) != 0) {\n            return WriteToReadOnlyProperty(it, value, should_throw);\n          }\n          // Interceptor modified the store target but failed to set the\n          // property.\n          Utils::ApiCheck(*store_target_map == it->GetStoreTarget()->map(),\n                          it->IsElement() ? \"v8::IndexedPropertySetterCallback\"\n                                          : \"v8::NamedPropertySetterCallback\",\n                          \"Interceptor silently changed store target.\");\n          if (maybe_attributes.FromJust() == ABSENT) break;\n          *found = false;\n          return Nothing<bool>();\n        }\n        break;\n      }\n\n      case LookupIterator::ACCESSOR: {\n        if (it->IsReadOnly()) {\n          return WriteToReadOnlyProperty(it, value, should_throw);\n        }\n        Handle<Object> accessors = it->GetAccessors();\n        if (accessors->IsAccessorInfo() &&\n            !it->HolderIsReceiverOrHiddenPrototype() &&\n            AccessorInfo::cast(*accessors)->is_special_data_property()) {\n          *found = false;\n          return Nothing<bool>();\n        }\n        return SetPropertyWithAccessor(it, value, should_throw);\n      }\n      case LookupIterator::INTEGER_INDEXED_EXOTIC:\n        // TODO(verwaest): We should throw an exception if holder is receiver.\n        return Just(true);\n\n      case LookupIterator::DATA:\n        if (it->IsReadOnly()) {\n          return WriteToReadOnlyProperty(it, value, should_throw);\n        }\n        if (it->HolderIsReceiverOrHiddenPrototype()) {\n          return SetDataProperty(it, value);\n        }\n      // Fall through.\n      case LookupIterator::TRANSITION:\n        *found = false;\n        return Nothing<bool>();\n    }\n    it->Next();\n  } while (it->IsFound());\n\n  *found = false;\n  return Nothing<bool>();\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -28,23 +28,38 @@\n         return JSProxy::SetProperty(it->GetHolder<JSProxy>(), it->GetName(),\n                                     value, it->GetReceiver(), language_mode);\n \n-      case LookupIterator::INTERCEPTOR:\n+      case LookupIterator::INTERCEPTOR: {\n+        Handle<Map> store_target_map =\n+            handle(it->GetStoreTarget()->map(), it->isolate());\n         if (it->HolderIsReceiverOrHiddenPrototype()) {\n           Maybe<bool> result =\n               JSObject::SetPropertyWithInterceptor(it, should_throw, value);\n           if (result.IsNothing() || result.FromJust()) return result;\n+          // Interceptor modified the store target but failed to set the\n+          // property.\n+          Utils::ApiCheck(*store_target_map == it->GetStoreTarget()->map(),\n+                          it->IsElement() ? \"v8::IndexedPropertySetterCallback\"\n+                                          : \"v8::NamedPropertySetterCallback\",\n+                          \"Interceptor silently changed store target.\");\n         } else {\n           Maybe<PropertyAttributes> maybe_attributes =\n               JSObject::GetPropertyAttributesWithInterceptor(it);\n           if (!maybe_attributes.IsJust()) return Nothing<bool>();\n-          if (maybe_attributes.FromJust() == ABSENT) break;\n           if ((maybe_attributes.FromJust() & READ_ONLY) != 0) {\n             return WriteToReadOnlyProperty(it, value, should_throw);\n           }\n+          // Interceptor modified the store target but failed to set the\n+          // property.\n+          Utils::ApiCheck(*store_target_map == it->GetStoreTarget()->map(),\n+                          it->IsElement() ? \"v8::IndexedPropertySetterCallback\"\n+                                          : \"v8::NamedPropertySetterCallback\",\n+                          \"Interceptor silently changed store target.\");\n+          if (maybe_attributes.FromJust() == ABSENT) break;\n           *found = false;\n           return Nothing<bool>();\n         }\n         break;\n+      }\n \n       case LookupIterator::ACCESSOR: {\n         if (it->IsReadOnly()) {",
        "diff_line_info": {
            "deleted_lines": [
                "      case LookupIterator::INTERCEPTOR:",
                "          if (maybe_attributes.FromJust() == ABSENT) break;"
            ],
            "added_lines": [
                "      case LookupIterator::INTERCEPTOR: {",
                "        Handle<Map> store_target_map =",
                "            handle(it->GetStoreTarget()->map(), it->isolate());",
                "          // Interceptor modified the store target but failed to set the",
                "          // property.",
                "          Utils::ApiCheck(*store_target_map == it->GetStoreTarget()->map(),",
                "                          it->IsElement() ? \"v8::IndexedPropertySetterCallback\"",
                "                                          : \"v8::NamedPropertySetterCallback\",",
                "                          \"Interceptor silently changed store target.\");",
                "          // Interceptor modified the store target but failed to set the",
                "          // property.",
                "          Utils::ApiCheck(*store_target_map == it->GetStoreTarget()->map(),",
                "                          it->IsElement() ? \"v8::IndexedPropertySetterCallback\"",
                "                                          : \"v8::NamedPropertySetterCallback\",",
                "                          \"Interceptor silently changed store target.\");",
                "          if (maybe_attributes.FromJust() == ABSENT) break;",
                "      }"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-5145",
        "func_name": "chromium/SerializedScriptValueWriter::writeImageBitmap",
        "description": "Blink, as used in Google Chrome before 52.0.2743.116, does not ensure that a taint property is preserved after a structure-clone operation on an ImageBitmap object derived from a cross-origin image, which allows remote attackers to bypass the Same Origin Policy via crafted JavaScript code.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/d790e336fd68029d802aa7da6d262eb5ef36488c",
        "commit_title": "Pass origin clean flag of ImageBitmap when structure clone",
        "commit_text": " In this CL, we pass the origin clean flag of an ImageBitmap when this ImageBitmap is being structure cloned, so that the receive of the ImageBitmap is aware of this flag.   Review-Url: https://codereview.chromium.org/2097393002 ",
        "func_before": "void SerializedScriptValueWriter::writeImageBitmap(uint32_t width, uint32_t height, const uint8_t* pixelData, uint32_t pixelDataLength)\n{\n    append(ImageBitmapTag);\n    doWriteImageData(width, height, pixelData, pixelDataLength);\n}",
        "func": "void SerializedScriptValueWriter::writeImageBitmap(uint32_t width, uint32_t height, uint32_t isOriginClean, const uint8_t* pixelData, uint32_t pixelDataLength)\n{\n    append(ImageBitmapTag);\n    append(isOriginClean);\n    doWriteImageData(width, height, pixelData, pixelDataLength);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,6 @@\n-void SerializedScriptValueWriter::writeImageBitmap(uint32_t width, uint32_t height, const uint8_t* pixelData, uint32_t pixelDataLength)\n+void SerializedScriptValueWriter::writeImageBitmap(uint32_t width, uint32_t height, uint32_t isOriginClean, const uint8_t* pixelData, uint32_t pixelDataLength)\n {\n     append(ImageBitmapTag);\n+    append(isOriginClean);\n     doWriteImageData(width, height, pixelData, pixelDataLength);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "void SerializedScriptValueWriter::writeImageBitmap(uint32_t width, uint32_t height, const uint8_t* pixelData, uint32_t pixelDataLength)"
            ],
            "added_lines": [
                "void SerializedScriptValueWriter::writeImageBitmap(uint32_t width, uint32_t height, uint32_t isOriginClean, const uint8_t* pixelData, uint32_t pixelDataLength)",
                "    append(isOriginClean);"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-5145",
        "func_name": "chromium/ScriptValueSerializer::writeAndGreyImageBitmap",
        "description": "Blink, as used in Google Chrome before 52.0.2743.116, does not ensure that a taint property is preserved after a structure-clone operation on an ImageBitmap object derived from a cross-origin image, which allows remote attackers to bypass the Same Origin Policy via crafted JavaScript code.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/d790e336fd68029d802aa7da6d262eb5ef36488c",
        "commit_title": "Pass origin clean flag of ImageBitmap when structure clone",
        "commit_text": " In this CL, we pass the origin clean flag of an ImageBitmap when this ImageBitmap is being structure cloned, so that the receive of the ImageBitmap is aware of this flag.   Review-Url: https://codereview.chromium.org/2097393002 ",
        "func_before": "ScriptValueSerializer::StateBase* ScriptValueSerializer::writeAndGreyImageBitmap(v8::Local<v8::Object> object, ScriptValueSerializer::StateBase* next)\n{\n    ImageBitmap* imageBitmap = V8ImageBitmap::toImpl(object);\n    if (!imageBitmap)\n        return nullptr;\n    if (imageBitmap->isNeutered())\n        return handleError(Status::DataCloneError, \"An ImageBitmap is detached and could not be cloned.\", next);\n\n    uint32_t index;\n    if (m_transferredImageBitmaps.tryGet(object, &index)) {\n        m_writer.writeTransferredImageBitmap(index);\n    } else {\n        greyObject(object);\n        std::unique_ptr<uint8_t[]> pixelData = imageBitmap->copyBitmapData(PremultiplyAlpha);\n        m_writer.writeImageBitmap(imageBitmap->width(), imageBitmap->height(), pixelData.get(), imageBitmap->width() * imageBitmap->height() * 4);\n    }\n    return nullptr;\n}",
        "func": "ScriptValueSerializer::StateBase* ScriptValueSerializer::writeAndGreyImageBitmap(v8::Local<v8::Object> object, ScriptValueSerializer::StateBase* next)\n{\n    ImageBitmap* imageBitmap = V8ImageBitmap::toImpl(object);\n    if (!imageBitmap)\n        return nullptr;\n    if (imageBitmap->isNeutered())\n        return handleError(Status::DataCloneError, \"An ImageBitmap is detached and could not be cloned.\", next);\n\n    uint32_t index;\n    if (m_transferredImageBitmaps.tryGet(object, &index)) {\n        m_writer.writeTransferredImageBitmap(index);\n    } else {\n        greyObject(object);\n        std::unique_ptr<uint8_t[]> pixelData = imageBitmap->copyBitmapData(PremultiplyAlpha);\n        m_writer.writeImageBitmap(imageBitmap->width(), imageBitmap->height(), static_cast<uint32_t>(imageBitmap->originClean()), pixelData.get(), imageBitmap->width() * imageBitmap->height() * 4);\n    }\n    return nullptr;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -12,7 +12,7 @@\n     } else {\n         greyObject(object);\n         std::unique_ptr<uint8_t[]> pixelData = imageBitmap->copyBitmapData(PremultiplyAlpha);\n-        m_writer.writeImageBitmap(imageBitmap->width(), imageBitmap->height(), pixelData.get(), imageBitmap->width() * imageBitmap->height() * 4);\n+        m_writer.writeImageBitmap(imageBitmap->width(), imageBitmap->height(), static_cast<uint32_t>(imageBitmap->originClean()), pixelData.get(), imageBitmap->width() * imageBitmap->height() * 4);\n     }\n     return nullptr;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "        m_writer.writeImageBitmap(imageBitmap->width(), imageBitmap->height(), pixelData.get(), imageBitmap->width() * imageBitmap->height() * 4);"
            ],
            "added_lines": [
                "        m_writer.writeImageBitmap(imageBitmap->width(), imageBitmap->height(), static_cast<uint32_t>(imageBitmap->originClean()), pixelData.get(), imageBitmap->width() * imageBitmap->height() * 4);"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-5145",
        "func_name": "chromium/SerializedScriptValueReader::readImageBitmap",
        "description": "Blink, as used in Google Chrome before 52.0.2743.116, does not ensure that a taint property is preserved after a structure-clone operation on an ImageBitmap object derived from a cross-origin image, which allows remote attackers to bypass the Same Origin Policy via crafted JavaScript code.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/d790e336fd68029d802aa7da6d262eb5ef36488c",
        "commit_title": "Pass origin clean flag of ImageBitmap when structure clone",
        "commit_text": " In this CL, we pass the origin clean flag of an ImageBitmap when this ImageBitmap is being structure cloned, so that the receive of the ImageBitmap is aware of this flag.   Review-Url: https://codereview.chromium.org/2097393002 ",
        "func_before": "bool SerializedScriptValueReader::readImageBitmap(v8::Local<v8::Value>* value)\n{\n    ImageData* imageData = doReadImageData();\n    if (!imageData)\n        return false;\n    ImageBitmapOptions options;\n    options.setPremultiplyAlpha(\"none\");\n    ImageBitmap* imageBitmap = ImageBitmap::create(imageData, IntRect(0, 0, imageData->width(), imageData->height()), options, true);\n    if (!imageBitmap)\n        return false;\n    *value = toV8(imageBitmap, m_scriptState->context()->Global(), isolate());\n    return !value->IsEmpty();\n}",
        "func": "bool SerializedScriptValueReader::readImageBitmap(v8::Local<v8::Value>* value)\n{\n    uint32_t isOriginClean;\n    if (!doReadUint32(&isOriginClean))\n        return false;\n    ImageData* imageData = doReadImageData();\n    if (!imageData)\n        return false;\n    ImageBitmapOptions options;\n    options.setPremultiplyAlpha(\"none\");\n    ImageBitmap* imageBitmap = ImageBitmap::create(imageData, IntRect(0, 0, imageData->width(), imageData->height()), options, true, isOriginClean);\n    if (!imageBitmap)\n        return false;\n    *value = toV8(imageBitmap, m_scriptState->context()->Global(), isolate());\n    return !value->IsEmpty();\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,11 +1,14 @@\n bool SerializedScriptValueReader::readImageBitmap(v8::Local<v8::Value>* value)\n {\n+    uint32_t isOriginClean;\n+    if (!doReadUint32(&isOriginClean))\n+        return false;\n     ImageData* imageData = doReadImageData();\n     if (!imageData)\n         return false;\n     ImageBitmapOptions options;\n     options.setPremultiplyAlpha(\"none\");\n-    ImageBitmap* imageBitmap = ImageBitmap::create(imageData, IntRect(0, 0, imageData->width(), imageData->height()), options, true);\n+    ImageBitmap* imageBitmap = ImageBitmap::create(imageData, IntRect(0, 0, imageData->width(), imageData->height()), options, true, isOriginClean);\n     if (!imageBitmap)\n         return false;\n     *value = toV8(imageBitmap, m_scriptState->context()->Global(), isolate());",
        "diff_line_info": {
            "deleted_lines": [
                "    ImageBitmap* imageBitmap = ImageBitmap::create(imageData, IntRect(0, 0, imageData->width(), imageData->height()), options, true);"
            ],
            "added_lines": [
                "    uint32_t isOriginClean;",
                "    if (!doReadUint32(&isOriginClean))",
                "        return false;",
                "    ImageBitmap* imageBitmap = ImageBitmap::create(imageData, IntRect(0, 0, imageData->width(), imageData->height()), options, true, isOriginClean);"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-5155",
        "func_name": "chromium/BindingSecurity::shouldAllowAccessTo",
        "description": "Google Chrome before 53.0.2785.89 on Windows and OS X and before 53.0.2785.92 on Linux does not properly validate access to the initial document, which allows remote attackers to spoof the address bar via a crafted web site.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/b8dcfeb065bbfd777cdc5f5433da9a87f25e6ec6",
        "commit_title": "binding: Moves the check for the first access to the initial document into BindingSecurity.",
        "commit_text": " Checks the access to the initial document and reports it not only at securityCheck() in V8Window.cpp but also at every call to BindingSecurity::shouldAllowAccessTo() because V8 only calls back securityCheck() on property lookups, and not for function invocation.  BindingSecurity::shouldAllowAccessTo() is called with every possible cross-origin window, which means every possible new window.  Thus, shouldAllowAccessTo() should be the right place to check the access to the initial document.  TBR=benwells@chromium.org  Review-Url: https://codereview.chromium.org/2209303002 ",
        "func_before": "bool BindingSecurity::shouldAllowAccessTo(v8::Isolate* isolate, const LocalDOMWindow* accessingWindow, const Node* target, ExceptionState& exceptionState)\n{\n    if (!target)\n        return false;\n    return canAccessFrame(isolate, accessingWindow, target->document().getSecurityOrigin(), target->document().domWindow(), exceptionState);\n}",
        "func": "bool BindingSecurity::shouldAllowAccessTo(v8::Isolate* isolate, const LocalDOMWindow* accessingWindow, const Node* target, ExceptionState& exceptionState)\n{\n    if (!target)\n        return false;\n    return canAccessFrame(accessingWindow, target->document().getSecurityOrigin(), target->document().domWindow(), exceptionState);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,5 +2,5 @@\n {\n     if (!target)\n         return false;\n-    return canAccessFrame(isolate, accessingWindow, target->document().getSecurityOrigin(), target->document().domWindow(), exceptionState);\n+    return canAccessFrame(accessingWindow, target->document().getSecurityOrigin(), target->document().domWindow(), exceptionState);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    return canAccessFrame(isolate, accessingWindow, target->document().getSecurityOrigin(), target->document().domWindow(), exceptionState);"
            ],
            "added_lines": [
                "    return canAccessFrame(accessingWindow, target->document().getSecurityOrigin(), target->document().domWindow(), exceptionState);"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-5155",
        "func_name": "chromium/BindingSecurity::shouldAllowAccessTo",
        "description": "Google Chrome before 53.0.2785.89 on Windows and OS X and before 53.0.2785.92 on Linux does not properly validate access to the initial document, which allows remote attackers to spoof the address bar via a crafted web site.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/b8dcfeb065bbfd777cdc5f5433da9a87f25e6ec6",
        "commit_title": "binding: Moves the check for the first access to the initial document into BindingSecurity.",
        "commit_text": " Checks the access to the initial document and reports it not only at securityCheck() in V8Window.cpp but also at every call to BindingSecurity::shouldAllowAccessTo() because V8 only calls back securityCheck() on property lookups, and not for function invocation.  BindingSecurity::shouldAllowAccessTo() is called with every possible cross-origin window, which means every possible new window.  Thus, shouldAllowAccessTo() should be the right place to check the access to the initial document.  TBR=benwells@chromium.org  Review-Url: https://codereview.chromium.org/2209303002 ",
        "func_before": "bool BindingSecurity::shouldAllowAccessTo(v8::Isolate* isolate, v8::Local<v8::Context> context, const ExecutionContext* executionContext, const MainThreadWorkletGlobalScope* workletGlobalScope, SecurityReportingOption reportingOption)\n{\n    DCHECK(executionContext);\n    DOMWindow* domWindow = toDOMWindow(context);\n    if (executionContext->isMainThreadWorkletGlobalScope()) {\n        Frame* callingFrame = toMainThreadWorkletGlobalScope(executionContext)->frame();\n        domWindow = callingFrame ? callingFrame->domWindow() : nullptr;\n    }\n\n    DCHECK(workletGlobalScope);\n    const Frame* workletGlobalScopeFrame = workletGlobalScope->frame();\n    if (!workletGlobalScopeFrame || !workletGlobalScopeFrame->securityContext())\n        return false;\n\n    return domWindow && canAccessFrame(isolate, toLocalDOMWindow(domWindow), workletGlobalScopeFrame->securityContext()->getSecurityOrigin(), workletGlobalScopeFrame->domWindow(), reportingOption);\n}",
        "func": "bool BindingSecurity::shouldAllowAccessTo(v8::Isolate* isolate, v8::Local<v8::Context> context, const ExecutionContext* executionContext, const MainThreadWorkletGlobalScope* workletGlobalScope, SecurityReportingOption reportingOption)\n{\n    DCHECK(executionContext);\n    DOMWindow* domWindow = toDOMWindow(context);\n    if (executionContext->isMainThreadWorkletGlobalScope()) {\n        Frame* callingFrame = toMainThreadWorkletGlobalScope(executionContext)->frame();\n        domWindow = callingFrame ? callingFrame->domWindow() : nullptr;\n    }\n\n    DCHECK(workletGlobalScope);\n    const Frame* workletGlobalScopeFrame = workletGlobalScope->frame();\n    if (!workletGlobalScopeFrame || !workletGlobalScopeFrame->securityContext())\n        return false;\n\n    return domWindow && canAccessFrame(toLocalDOMWindow(domWindow), workletGlobalScopeFrame->securityContext()->getSecurityOrigin(), workletGlobalScopeFrame->domWindow(), reportingOption);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -12,5 +12,5 @@\n     if (!workletGlobalScopeFrame || !workletGlobalScopeFrame->securityContext())\n         return false;\n \n-    return domWindow && canAccessFrame(isolate, toLocalDOMWindow(domWindow), workletGlobalScopeFrame->securityContext()->getSecurityOrigin(), workletGlobalScopeFrame->domWindow(), reportingOption);\n+    return domWindow && canAccessFrame(toLocalDOMWindow(domWindow), workletGlobalScopeFrame->securityContext()->getSecurityOrigin(), workletGlobalScopeFrame->domWindow(), reportingOption);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    return domWindow && canAccessFrame(isolate, toLocalDOMWindow(domWindow), workletGlobalScopeFrame->securityContext()->getSecurityOrigin(), workletGlobalScopeFrame->domWindow(), reportingOption);"
            ],
            "added_lines": [
                "    return domWindow && canAccessFrame(toLocalDOMWindow(domWindow), workletGlobalScopeFrame->securityContext()->getSecurityOrigin(), workletGlobalScopeFrame->domWindow(), reportingOption);"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-5155",
        "func_name": "chromium/BindingSecurity::shouldAllowAccessTo",
        "description": "Google Chrome before 53.0.2785.89 on Windows and OS X and before 53.0.2785.92 on Linux does not properly validate access to the initial document, which allows remote attackers to spoof the address bar via a crafted web site.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/b8dcfeb065bbfd777cdc5f5433da9a87f25e6ec6",
        "commit_title": "binding: Moves the check for the first access to the initial document into BindingSecurity.",
        "commit_text": " Checks the access to the initial document and reports it not only at securityCheck() in V8Window.cpp but also at every call to BindingSecurity::shouldAllowAccessTo() because V8 only calls back securityCheck() on property lookups, and not for function invocation.  BindingSecurity::shouldAllowAccessTo() is called with every possible cross-origin window, which means every possible new window.  Thus, shouldAllowAccessTo() should be the right place to check the access to the initial document.  TBR=benwells@chromium.org  Review-Url: https://codereview.chromium.org/2209303002 ",
        "func_before": "bool BindingSecurity::shouldAllowAccessTo(v8::Isolate* isolate, const LocalDOMWindow* accessingWindow, const Location* target, ExceptionState& exceptionState)\n{\n    ASSERT(target);\n    const Frame* frame = target->frame();\n    if (!frame || !frame->securityContext())\n        return false;\n    return canAccessFrame(isolate, accessingWindow, frame->securityContext()->getSecurityOrigin(), frame->domWindow(), exceptionState);\n}",
        "func": "bool BindingSecurity::shouldAllowAccessTo(v8::Isolate* isolate, const LocalDOMWindow* accessingWindow, const Location* target, ExceptionState& exceptionState)\n{\n    ASSERT(target);\n    const Frame* frame = target->frame();\n    if (!frame || !frame->securityContext())\n        return false;\n    return canAccessFrame(accessingWindow, frame->securityContext()->getSecurityOrigin(), frame->domWindow(), exceptionState);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,5 +4,5 @@\n     const Frame* frame = target->frame();\n     if (!frame || !frame->securityContext())\n         return false;\n-    return canAccessFrame(isolate, accessingWindow, frame->securityContext()->getSecurityOrigin(), frame->domWindow(), exceptionState);\n+    return canAccessFrame(accessingWindow, frame->securityContext()->getSecurityOrigin(), frame->domWindow(), exceptionState);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    return canAccessFrame(isolate, accessingWindow, frame->securityContext()->getSecurityOrigin(), frame->domWindow(), exceptionState);"
            ],
            "added_lines": [
                "    return canAccessFrame(accessingWindow, frame->securityContext()->getSecurityOrigin(), frame->domWindow(), exceptionState);"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-5155",
        "func_name": "chromium/BindingSecurity::shouldAllowAccessTo",
        "description": "Google Chrome before 53.0.2785.89 on Windows and OS X and before 53.0.2785.92 on Linux does not properly validate access to the initial document, which allows remote attackers to spoof the address bar via a crafted web site.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/b8dcfeb065bbfd777cdc5f5433da9a87f25e6ec6",
        "commit_title": "binding: Moves the check for the first access to the initial document into BindingSecurity.",
        "commit_text": " Checks the access to the initial document and reports it not only at securityCheck() in V8Window.cpp but also at every call to BindingSecurity::shouldAllowAccessTo() because V8 only calls back securityCheck() on property lookups, and not for function invocation.  BindingSecurity::shouldAllowAccessTo() is called with every possible cross-origin window, which means every possible new window.  Thus, shouldAllowAccessTo() should be the right place to check the access to the initial document.  TBR=benwells@chromium.org  Review-Url: https://codereview.chromium.org/2209303002 ",
        "func_before": "bool BindingSecurity::shouldAllowAccessTo(v8::Isolate* isolate, const LocalDOMWindow* accessingWindow, const DOMWindow* target, ExceptionState& exceptionState)\n{\n    ASSERT(target);\n    const Frame* frame = target->frame();\n    if (!frame || !frame->securityContext())\n        return false;\n    return canAccessFrame(isolate, accessingWindow, frame->securityContext()->getSecurityOrigin(), target, exceptionState);\n}",
        "func": "bool BindingSecurity::shouldAllowAccessTo(v8::Isolate* isolate, const LocalDOMWindow* accessingWindow, const DOMWindow* target, ExceptionState& exceptionState)\n{\n    ASSERT(target);\n    const Frame* frame = target->frame();\n    if (!frame || !frame->securityContext())\n        return false;\n    return canAccessFrame(accessingWindow, frame->securityContext()->getSecurityOrigin(), target, exceptionState);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,5 +4,5 @@\n     const Frame* frame = target->frame();\n     if (!frame || !frame->securityContext())\n         return false;\n-    return canAccessFrame(isolate, accessingWindow, frame->securityContext()->getSecurityOrigin(), target, exceptionState);\n+    return canAccessFrame(accessingWindow, frame->securityContext()->getSecurityOrigin(), target, exceptionState);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    return canAccessFrame(isolate, accessingWindow, frame->securityContext()->getSecurityOrigin(), target, exceptionState);"
            ],
            "added_lines": [
                "    return canAccessFrame(accessingWindow, frame->securityContext()->getSecurityOrigin(), target, exceptionState);"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-5155",
        "func_name": "chromium/BindingSecurity::shouldAllowAccessTo",
        "description": "Google Chrome before 53.0.2785.89 on Windows and OS X and before 53.0.2785.92 on Linux does not properly validate access to the initial document, which allows remote attackers to spoof the address bar via a crafted web site.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/b8dcfeb065bbfd777cdc5f5433da9a87f25e6ec6",
        "commit_title": "binding: Moves the check for the first access to the initial document into BindingSecurity.",
        "commit_text": " Checks the access to the initial document and reports it not only at securityCheck() in V8Window.cpp but also at every call to BindingSecurity::shouldAllowAccessTo() because V8 only calls back securityCheck() on property lookups, and not for function invocation.  BindingSecurity::shouldAllowAccessTo() is called with every possible cross-origin window, which means every possible new window.  Thus, shouldAllowAccessTo() should be the right place to check the access to the initial document.  TBR=benwells@chromium.org  Review-Url: https://codereview.chromium.org/2209303002 ",
        "func_before": "bool BindingSecurity::shouldAllowAccessTo(v8::Isolate* isolate, const LocalDOMWindow* accessingWindow, const DOMWindow* target, SecurityReportingOption reportingOption)\n{\n    ASSERT(target);\n    const Frame* frame = target->frame();\n    if (!frame || !frame->securityContext())\n        return false;\n    return canAccessFrame(isolate, accessingWindow, frame->securityContext()->getSecurityOrigin(), target, reportingOption);\n}",
        "func": "bool BindingSecurity::shouldAllowAccessTo(v8::Isolate* isolate, const LocalDOMWindow* accessingWindow, const DOMWindow* target, SecurityReportingOption reportingOption)\n{\n    ASSERT(target);\n    const Frame* frame = target->frame();\n    if (!frame || !frame->securityContext())\n        return false;\n    return canAccessFrame(accessingWindow, frame->securityContext()->getSecurityOrigin(), target, reportingOption);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,5 +4,5 @@\n     const Frame* frame = target->frame();\n     if (!frame || !frame->securityContext())\n         return false;\n-    return canAccessFrame(isolate, accessingWindow, frame->securityContext()->getSecurityOrigin(), target, reportingOption);\n+    return canAccessFrame(accessingWindow, frame->securityContext()->getSecurityOrigin(), target, reportingOption);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    return canAccessFrame(isolate, accessingWindow, frame->securityContext()->getSecurityOrigin(), target, reportingOption);"
            ],
            "added_lines": [
                "    return canAccessFrame(accessingWindow, frame->securityContext()->getSecurityOrigin(), target, reportingOption);"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-5155",
        "func_name": "chromium/BindingSecurity::shouldAllowAccessTo",
        "description": "Google Chrome before 53.0.2785.89 on Windows and OS X and before 53.0.2785.92 on Linux does not properly validate access to the initial document, which allows remote attackers to spoof the address bar via a crafted web site.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/b8dcfeb065bbfd777cdc5f5433da9a87f25e6ec6",
        "commit_title": "binding: Moves the check for the first access to the initial document into BindingSecurity.",
        "commit_text": " Checks the access to the initial document and reports it not only at securityCheck() in V8Window.cpp but also at every call to BindingSecurity::shouldAllowAccessTo() because V8 only calls back securityCheck() on property lookups, and not for function invocation.  BindingSecurity::shouldAllowAccessTo() is called with every possible cross-origin window, which means every possible new window.  Thus, shouldAllowAccessTo() should be the right place to check the access to the initial document.  TBR=benwells@chromium.org  Review-Url: https://codereview.chromium.org/2209303002 ",
        "func_before": "bool BindingSecurity::shouldAllowAccessTo(v8::Isolate* isolate, const LocalDOMWindow* accessingWindow, const Node* target, SecurityReportingOption reportingOption)\n{\n    if (!target)\n        return false;\n    return canAccessFrame(isolate, accessingWindow, target->document().getSecurityOrigin(), target->document().domWindow(), reportingOption);\n}",
        "func": "bool BindingSecurity::shouldAllowAccessTo(v8::Isolate* isolate, const LocalDOMWindow* accessingWindow, const Node* target, SecurityReportingOption reportingOption)\n{\n    if (!target)\n        return false;\n    return canAccessFrame(accessingWindow, target->document().getSecurityOrigin(), target->document().domWindow(), reportingOption);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,5 +2,5 @@\n {\n     if (!target)\n         return false;\n-    return canAccessFrame(isolate, accessingWindow, target->document().getSecurityOrigin(), target->document().domWindow(), reportingOption);\n+    return canAccessFrame(accessingWindow, target->document().getSecurityOrigin(), target->document().domWindow(), reportingOption);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    return canAccessFrame(isolate, accessingWindow, target->document().getSecurityOrigin(), target->document().domWindow(), reportingOption);"
            ],
            "added_lines": [
                "    return canAccessFrame(accessingWindow, target->document().getSecurityOrigin(), target->document().domWindow(), reportingOption);"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-5155",
        "func_name": "chromium/BindingSecurity::shouldAllowAccessTo",
        "description": "Google Chrome before 53.0.2785.89 on Windows and OS X and before 53.0.2785.92 on Linux does not properly validate access to the initial document, which allows remote attackers to spoof the address bar via a crafted web site.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/b8dcfeb065bbfd777cdc5f5433da9a87f25e6ec6",
        "commit_title": "binding: Moves the check for the first access to the initial document into BindingSecurity.",
        "commit_text": " Checks the access to the initial document and reports it not only at securityCheck() in V8Window.cpp but also at every call to BindingSecurity::shouldAllowAccessTo() because V8 only calls back securityCheck() on property lookups, and not for function invocation.  BindingSecurity::shouldAllowAccessTo() is called with every possible cross-origin window, which means every possible new window.  Thus, shouldAllowAccessTo() should be the right place to check the access to the initial document.  TBR=benwells@chromium.org  Review-Url: https://codereview.chromium.org/2209303002 ",
        "func_before": "bool BindingSecurity::shouldAllowAccessTo(v8::Isolate* isolate, const LocalDOMWindow* accessingWindow, const EventTarget* target, ExceptionState& exceptionState)\n{\n    ASSERT(target);\n    const DOMWindow* window = target->toDOMWindow();\n    if (!window) {\n        // We only need to check the access to Window objects which are\n        // cross-origin accessible.  If it's not a Window, the object's\n        // origin must always be the same origin (or it already leaked).\n        return true;\n    }\n    const Frame* frame = window->frame();\n    if (!frame || !frame->securityContext())\n        return false;\n    return canAccessFrame(isolate, accessingWindow, frame->securityContext()->getSecurityOrigin(), window, exceptionState);\n}",
        "func": "bool BindingSecurity::shouldAllowAccessTo(v8::Isolate* isolate, const LocalDOMWindow* accessingWindow, const EventTarget* target, ExceptionState& exceptionState)\n{\n    ASSERT(target);\n    const DOMWindow* window = target->toDOMWindow();\n    if (!window) {\n        // We only need to check the access to Window objects which are\n        // cross-origin accessible.  If it's not a Window, the object's\n        // origin must always be the same origin (or it already leaked).\n        return true;\n    }\n    const Frame* frame = window->frame();\n    if (!frame || !frame->securityContext())\n        return false;\n    return canAccessFrame(accessingWindow, frame->securityContext()->getSecurityOrigin(), window, exceptionState);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -11,5 +11,5 @@\n     const Frame* frame = window->frame();\n     if (!frame || !frame->securityContext())\n         return false;\n-    return canAccessFrame(isolate, accessingWindow, frame->securityContext()->getSecurityOrigin(), window, exceptionState);\n+    return canAccessFrame(accessingWindow, frame->securityContext()->getSecurityOrigin(), window, exceptionState);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    return canAccessFrame(isolate, accessingWindow, frame->securityContext()->getSecurityOrigin(), window, exceptionState);"
            ],
            "added_lines": [
                "    return canAccessFrame(accessingWindow, frame->securityContext()->getSecurityOrigin(), window, exceptionState);"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-5155",
        "func_name": "chromium/BindingSecurity::shouldAllowAccessTo",
        "description": "Google Chrome before 53.0.2785.89 on Windows and OS X and before 53.0.2785.92 on Linux does not properly validate access to the initial document, which allows remote attackers to spoof the address bar via a crafted web site.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/b8dcfeb065bbfd777cdc5f5433da9a87f25e6ec6",
        "commit_title": "binding: Moves the check for the first access to the initial document into BindingSecurity.",
        "commit_text": " Checks the access to the initial document and reports it not only at securityCheck() in V8Window.cpp but also at every call to BindingSecurity::shouldAllowAccessTo() because V8 only calls back securityCheck() on property lookups, and not for function invocation.  BindingSecurity::shouldAllowAccessTo() is called with every possible cross-origin window, which means every possible new window.  Thus, shouldAllowAccessTo() should be the right place to check the access to the initial document.  TBR=benwells@chromium.org  Review-Url: https://codereview.chromium.org/2209303002 ",
        "func_before": "bool BindingSecurity::shouldAllowAccessTo(v8::Isolate* isolate, const LocalDOMWindow* accessingWindow, const Location* target, SecurityReportingOption reportingOption)\n{\n    ASSERT(target);\n    const Frame* frame = target->frame();\n    if (!frame || !frame->securityContext())\n        return false;\n    return canAccessFrame(isolate, accessingWindow, frame->securityContext()->getSecurityOrigin(), frame->domWindow(), reportingOption);\n}",
        "func": "bool BindingSecurity::shouldAllowAccessTo(v8::Isolate* isolate, const LocalDOMWindow* accessingWindow, const Location* target, SecurityReportingOption reportingOption)\n{\n    ASSERT(target);\n    const Frame* frame = target->frame();\n    if (!frame || !frame->securityContext())\n        return false;\n    return canAccessFrame(accessingWindow, frame->securityContext()->getSecurityOrigin(), frame->domWindow(), reportingOption);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,5 +4,5 @@\n     const Frame* frame = target->frame();\n     if (!frame || !frame->securityContext())\n         return false;\n-    return canAccessFrame(isolate, accessingWindow, frame->securityContext()->getSecurityOrigin(), frame->domWindow(), reportingOption);\n+    return canAccessFrame(accessingWindow, frame->securityContext()->getSecurityOrigin(), frame->domWindow(), reportingOption);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    return canAccessFrame(isolate, accessingWindow, frame->securityContext()->getSecurityOrigin(), frame->domWindow(), reportingOption);"
            ],
            "added_lines": [
                "    return canAccessFrame(accessingWindow, frame->securityContext()->getSecurityOrigin(), frame->domWindow(), reportingOption);"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-5155",
        "func_name": "chromium/BindingSecurity::shouldAllowAccessToFrame",
        "description": "Google Chrome before 53.0.2785.89 on Windows and OS X and before 53.0.2785.92 on Linux does not properly validate access to the initial document, which allows remote attackers to spoof the address bar via a crafted web site.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/b8dcfeb065bbfd777cdc5f5433da9a87f25e6ec6",
        "commit_title": "binding: Moves the check for the first access to the initial document into BindingSecurity.",
        "commit_text": " Checks the access to the initial document and reports it not only at securityCheck() in V8Window.cpp but also at every call to BindingSecurity::shouldAllowAccessTo() because V8 only calls back securityCheck() on property lookups, and not for function invocation.  BindingSecurity::shouldAllowAccessTo() is called with every possible cross-origin window, which means every possible new window.  Thus, shouldAllowAccessTo() should be the right place to check the access to the initial document.  TBR=benwells@chromium.org  Review-Url: https://codereview.chromium.org/2209303002 ",
        "func_before": "bool BindingSecurity::shouldAllowAccessToFrame(v8::Isolate* isolate, const LocalDOMWindow* accessingWindow, const Frame* target, SecurityReportingOption reportingOption)\n{\n    if (!target || !target->securityContext())\n        return false;\n    return canAccessFrame(isolate, accessingWindow, target->securityContext()->getSecurityOrigin(), target->domWindow(), reportingOption);\n}",
        "func": "bool BindingSecurity::shouldAllowAccessToFrame(v8::Isolate* isolate, const LocalDOMWindow* accessingWindow, const Frame* target, SecurityReportingOption reportingOption)\n{\n    if (!target || !target->securityContext())\n        return false;\n    return canAccessFrame(accessingWindow, target->securityContext()->getSecurityOrigin(), target->domWindow(), reportingOption);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,5 +2,5 @@\n {\n     if (!target || !target->securityContext())\n         return false;\n-    return canAccessFrame(isolate, accessingWindow, target->securityContext()->getSecurityOrigin(), target->domWindow(), reportingOption);\n+    return canAccessFrame(accessingWindow, target->securityContext()->getSecurityOrigin(), target->domWindow(), reportingOption);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    return canAccessFrame(isolate, accessingWindow, target->securityContext()->getSecurityOrigin(), target->domWindow(), reportingOption);"
            ],
            "added_lines": [
                "    return canAccessFrame(accessingWindow, target->securityContext()->getSecurityOrigin(), target->domWindow(), reportingOption);"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-5160",
        "func_name": "chromium/AllowCrossRendererResourceLoad",
        "description": "The AllowCrossRendererResourceLoad function in extensions/browser/url_request_util.cc in Google Chrome before 53.0.2785.89 on Windows and OS X and before 53.0.2785.92 on Linux does not properly use an extension's manifest.json web_accessible_resources field for restrictions on IFRAME elements, which makes it easier for remote attackers to conduct clickjacking attacks, and trick users into changing extension settings, via a crafted web site, a different vulnerability than CVE-2016-5162.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/5cf9d45c437b7b2d899e46f2f324c147a2743eb7",
        "commit_title": "Disallow navigation to documents not explicitly listed as web accessible.",
        "commit_text": " The existing check for web accessible resources is inadequate and allows navigations to non-whitelisted pages to succeed. This patch ensures that the document is listed explicitly in the manifest when a navigation is performed to it.   Review-Url: https://codereview.chromium.org/2007133004 ",
        "func_before": "bool AllowCrossRendererResourceLoad(net::URLRequest* request,\n                                    bool is_incognito,\n                                    const Extension* extension,\n                                    InfoMap* extension_info_map,\n                                    bool* allowed) {\n  const content::ResourceRequestInfo* info =\n      content::ResourceRequestInfo::ForRequest(request);\n\n  // Extensions with webview: allow loading certain resources by guest renderers\n  // with privileged partition IDs as specified in owner's extension the\n  // manifest file.\n  std::string owner_extension_id;\n  int owner_process_id;\n  WebViewRendererState::GetInstance()->GetOwnerInfo(\n      info->GetChildID(), &owner_process_id, &owner_extension_id);\n  const Extension* owner_extension =\n      extension_info_map->extensions().GetByID(owner_extension_id);\n  std::string partition_id;\n  bool is_guest = WebViewRendererState::GetInstance()->GetPartitionID(\n      info->GetChildID(), &partition_id);\n  std::string resource_path = request->url().path();\n  // |owner_extension == extension| needs to be checked because extension\n  // resources should only be accessible to WebViews owned by that extension.\n  if (is_guest && owner_extension == extension &&\n      WebviewInfo::IsResourceWebviewAccessible(extension, partition_id,\n                                               resource_path)) {\n    *allowed = true;\n    return true;\n  }\n\n  // If the request is for navigations outside of webviews, then it should be\n  // allowed. The navigation logic in CrossSiteResourceHandler will properly\n  // transfer the navigation to a privileged process before it commits.\n  if (content::IsResourceTypeFrame(info->GetResourceType()) && !is_guest) {\n    *allowed = true;\n    return true;\n  }\n\n  if (!ui::PageTransitionIsWebTriggerable(info->GetPageTransition())) {\n    *allowed = false;\n    return true;\n  }\n\n  // The following checks require that we have an actual extension object. If we\n  // don't have it, allow the request handling to continue with the rest of the\n  // checks.\n  if (!extension) {\n    *allowed = true;\n    return true;\n  }\n\n  // Disallow loading of packaged resources for hosted apps. We don't allow\n  // hybrid hosted/packaged apps. The one exception is access to icons, since\n  // some extensions want to be able to do things like create their own\n  // launchers.\n  std::string resource_root_relative_path =\n      request->url().path().empty() ? std::string()\n                                    : request->url().path().substr(1);\n  if (extension->is_hosted_app() &&\n      !IconsInfo::GetIcons(extension)\n           .ContainsPath(resource_root_relative_path)) {\n    LOG(ERROR) << \"Denying load of \" << request->url().spec() << \" from \"\n               << \"hosted app.\";\n    *allowed = false;\n    return true;\n  }\n\n  // Extensions with web_accessible_resources: allow loading by regular\n  // renderers. Since not all subresources are required to be listed in a v2\n  // manifest, we must allow all loads if there are any web accessible\n  // resources. See http://crbug.com/179127.\n  if (extension->manifest_version() < 2 ||\n      WebAccessibleResourcesInfo::HasWebAccessibleResources(extension)) {\n    *allowed = true;\n    return true;\n  }\n\n  // Couldn't determine if the resource is allowed or not.\n  return false;\n}",
        "func": "bool AllowCrossRendererResourceLoad(net::URLRequest* request,\n                                    bool is_incognito,\n                                    const Extension* extension,\n                                    InfoMap* extension_info_map,\n                                    bool* allowed) {\n  const content::ResourceRequestInfo* info =\n      content::ResourceRequestInfo::ForRequest(request);\n\n  // Extensions with webview: allow loading certain resources by guest renderers\n  // with privileged partition IDs as specified in owner's extension the\n  // manifest file.\n  std::string owner_extension_id;\n  int owner_process_id;\n  WebViewRendererState::GetInstance()->GetOwnerInfo(\n      info->GetChildID(), &owner_process_id, &owner_extension_id);\n  const Extension* owner_extension =\n      extension_info_map->extensions().GetByID(owner_extension_id);\n  std::string partition_id;\n  bool is_guest = WebViewRendererState::GetInstance()->GetPartitionID(\n      info->GetChildID(), &partition_id);\n  std::string resource_path = request->url().path();\n\n  // |owner_extension == extension| needs to be checked because extension\n  // resources should only be accessible to WebViews owned by that extension.\n  if (is_guest && owner_extension == extension &&\n      WebviewInfo::IsResourceWebviewAccessible(extension, partition_id,\n                                               resource_path)) {\n    *allowed = true;\n    return true;\n  }\n\n  if (!ui::PageTransitionIsWebTriggerable(info->GetPageTransition())) {\n    *allowed = false;\n    return true;\n  }\n\n  // The following checks require that we have an actual extension object. If we\n  // don't have it, allow the request handling to continue with the rest of the\n  // checks.\n  if (!extension) {\n    *allowed = true;\n    return true;\n  }\n\n  // Disallow loading of packaged resources for hosted apps. We don't allow\n  // hybrid hosted/packaged apps. The one exception is access to icons, since\n  // some extensions want to be able to do things like create their own\n  // launchers.\n  std::string resource_root_relative_path =\n      request->url().path().empty() ? std::string()\n                                    : request->url().path().substr(1);\n  if (extension->is_hosted_app() &&\n      !IconsInfo::GetIcons(extension)\n           .ContainsPath(resource_root_relative_path)) {\n    LOG(ERROR) << \"Denying load of \" << request->url().spec() << \" from \"\n               << \"hosted app.\";\n    *allowed = false;\n    return true;\n  }\n\n  DCHECK_EQ(extension->url(), request->url().GetWithEmptyPath());\n\n  // Extensions with manifest before v2 did not have web_accessible_resource\n  // section, therefore the request needs to be allowed.\n  if (extension->manifest_version() < 2) {\n    *allowed = true;\n    return true;\n  }\n\n  // Navigating the main frame to an extension URL is allowed, even if not\n  // explicitly listed as web_accessible_resource.\n  if (info->GetResourceType() == content::RESOURCE_TYPE_MAIN_FRAME) {\n    *allowed = true;\n    return true;\n  } else if (info->GetResourceType() == content::RESOURCE_TYPE_SUB_FRAME) {\n    // When navigating in subframe, allow if it is the same origin\n    // as the top-level frame. This can only be the case if the subframe\n    // request is coming from the extension process.\n    if (extension_info_map->process_map().Contains(info->GetChildID())) {\n      *allowed = true;\n      return true;\n    }\n\n    // Also allow if the file is explicitly listed as a web_accessible_resource.\n    if (WebAccessibleResourcesInfo::IsResourceWebAccessible(extension,\n                                                            resource_path)) {\n      *allowed = true;\n      return true;\n    }\n  }\n\n  // Since not all subresources are required to be listed in a v2\n  // manifest, we must allow all subresource loads if there are any web\n  // accessible resources. See http://crbug.com/179127.\n  if (!content::IsResourceTypeFrame(info->GetResourceType()) &&\n      WebAccessibleResourcesInfo::HasWebAccessibleResources(extension)) {\n    *allowed = true;\n    return true;\n  }\n\n  // Couldn't determine if the resource is allowed or not.\n  return false;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -19,19 +19,12 @@\n   bool is_guest = WebViewRendererState::GetInstance()->GetPartitionID(\n       info->GetChildID(), &partition_id);\n   std::string resource_path = request->url().path();\n+\n   // |owner_extension == extension| needs to be checked because extension\n   // resources should only be accessible to WebViews owned by that extension.\n   if (is_guest && owner_extension == extension &&\n       WebviewInfo::IsResourceWebviewAccessible(extension, partition_id,\n                                                resource_path)) {\n-    *allowed = true;\n-    return true;\n-  }\n-\n-  // If the request is for navigations outside of webviews, then it should be\n-  // allowed. The navigation logic in CrossSiteResourceHandler will properly\n-  // transfer the navigation to a privileged process before it commits.\n-  if (content::IsResourceTypeFrame(info->GetResourceType()) && !is_guest) {\n     *allowed = true;\n     return true;\n   }\n@@ -65,11 +58,41 @@\n     return true;\n   }\n \n-  // Extensions with web_accessible_resources: allow loading by regular\n-  // renderers. Since not all subresources are required to be listed in a v2\n-  // manifest, we must allow all loads if there are any web accessible\n-  // resources. See http://crbug.com/179127.\n-  if (extension->manifest_version() < 2 ||\n+  DCHECK_EQ(extension->url(), request->url().GetWithEmptyPath());\n+\n+  // Extensions with manifest before v2 did not have web_accessible_resource\n+  // section, therefore the request needs to be allowed.\n+  if (extension->manifest_version() < 2) {\n+    *allowed = true;\n+    return true;\n+  }\n+\n+  // Navigating the main frame to an extension URL is allowed, even if not\n+  // explicitly listed as web_accessible_resource.\n+  if (info->GetResourceType() == content::RESOURCE_TYPE_MAIN_FRAME) {\n+    *allowed = true;\n+    return true;\n+  } else if (info->GetResourceType() == content::RESOURCE_TYPE_SUB_FRAME) {\n+    // When navigating in subframe, allow if it is the same origin\n+    // as the top-level frame. This can only be the case if the subframe\n+    // request is coming from the extension process.\n+    if (extension_info_map->process_map().Contains(info->GetChildID())) {\n+      *allowed = true;\n+      return true;\n+    }\n+\n+    // Also allow if the file is explicitly listed as a web_accessible_resource.\n+    if (WebAccessibleResourcesInfo::IsResourceWebAccessible(extension,\n+                                                            resource_path)) {\n+      *allowed = true;\n+      return true;\n+    }\n+  }\n+\n+  // Since not all subresources are required to be listed in a v2\n+  // manifest, we must allow all subresource loads if there are any web\n+  // accessible resources. See http://crbug.com/179127.\n+  if (!content::IsResourceTypeFrame(info->GetResourceType()) &&\n       WebAccessibleResourcesInfo::HasWebAccessibleResources(extension)) {\n     *allowed = true;\n     return true;",
        "diff_line_info": {
            "deleted_lines": [
                "    *allowed = true;",
                "    return true;",
                "  }",
                "",
                "  // If the request is for navigations outside of webviews, then it should be",
                "  // allowed. The navigation logic in CrossSiteResourceHandler will properly",
                "  // transfer the navigation to a privileged process before it commits.",
                "  if (content::IsResourceTypeFrame(info->GetResourceType()) && !is_guest) {",
                "  // Extensions with web_accessible_resources: allow loading by regular",
                "  // renderers. Since not all subresources are required to be listed in a v2",
                "  // manifest, we must allow all loads if there are any web accessible",
                "  // resources. See http://crbug.com/179127.",
                "  if (extension->manifest_version() < 2 ||"
            ],
            "added_lines": [
                "",
                "  DCHECK_EQ(extension->url(), request->url().GetWithEmptyPath());",
                "",
                "  // Extensions with manifest before v2 did not have web_accessible_resource",
                "  // section, therefore the request needs to be allowed.",
                "  if (extension->manifest_version() < 2) {",
                "    *allowed = true;",
                "    return true;",
                "  }",
                "",
                "  // Navigating the main frame to an extension URL is allowed, even if not",
                "  // explicitly listed as web_accessible_resource.",
                "  if (info->GetResourceType() == content::RESOURCE_TYPE_MAIN_FRAME) {",
                "    *allowed = true;",
                "    return true;",
                "  } else if (info->GetResourceType() == content::RESOURCE_TYPE_SUB_FRAME) {",
                "    // When navigating in subframe, allow if it is the same origin",
                "    // as the top-level frame. This can only be the case if the subframe",
                "    // request is coming from the extension process.",
                "    if (extension_info_map->process_map().Contains(info->GetChildID())) {",
                "      *allowed = true;",
                "      return true;",
                "    }",
                "",
                "    // Also allow if the file is explicitly listed as a web_accessible_resource.",
                "    if (WebAccessibleResourcesInfo::IsResourceWebAccessible(extension,",
                "                                                            resource_path)) {",
                "      *allowed = true;",
                "      return true;",
                "    }",
                "  }",
                "",
                "  // Since not all subresources are required to be listed in a v2",
                "  // manifest, we must allow all subresource loads if there are any web",
                "  // accessible resources. See http://crbug.com/179127.",
                "  if (!content::IsResourceTypeFrame(info->GetResourceType()) &&"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-7031",
        "func_name": "ceph/rgw_build_policies",
        "description": "The RGW code in Ceph before 10.0.1, when authenticated-read ACL is applied to a bucket, allows remote attackers to list the bucket contents via a URL.",
        "git_url": "https://github.com/ceph/ceph/commit/99ba6610a8f437604cadf68cbe9969def893e870",
        "commit_title": "13207: Rados Gateway: Anonymous user is able to read bucket with authenticated read ACL",
        "commit_text": "",
        "func_before": "static int rgw_build_policies(RGWRados *store, struct req_state *s, bool only_bucket, bool prefetch_data)\n{\n  int ret = 0;\n  rgw_obj_key obj;\n  RGWUserInfo bucket_owner_info;\n  RGWObjectCtx& obj_ctx = *static_cast<RGWObjectCtx *>(s->obj_ctx);\n\n  string bi = s->info.args.get(RGW_SYS_PARAM_PREFIX \"bucket-instance\");\n  if (!bi.empty()) {\n    int shard_id;\n    ret = rgw_bucket_parse_bucket_instance(bi, &s->bucket_instance_id, &shard_id);\n    if (ret < 0) {\n      return ret;\n    }\n  }\n\n  s->bucket_acl = new RGWAccessControlPolicy(s->cct);\n\n  if (s->copy_source) { /* check if copy source is within the current domain */\n    const char *src = s->copy_source;\n    if (*src == '/')\n      ++src;\n    string copy_source_str(src);\n\n    int pos = copy_source_str.find('/');\n    if (pos > 0)\n      copy_source_str = copy_source_str.substr(0, pos);\n\n    RGWBucketInfo source_info;\n\n    ret = store->get_bucket_info(obj_ctx, copy_source_str, source_info, NULL);\n    if (ret == 0) {\n      string& region = source_info.region;\n      s->local_source = store->region.equals(region);\n    }\n  }\n\n  if (!s->bucket_name_str.empty()) {\n    s->bucket_exists = true;\n    if (s->bucket_instance_id.empty()) {\n      ret = store->get_bucket_info(obj_ctx, s->bucket_name_str, s->bucket_info, NULL, &s->bucket_attrs);\n    } else {\n      ret = store->get_bucket_instance_info(obj_ctx, s->bucket_instance_id, s->bucket_info, NULL, &s->bucket_attrs);\n    }\n    if (ret < 0) {\n      if (ret != -ENOENT) {\n        ldout(s->cct, 0) << \"NOTICE: couldn't get bucket from bucket_name (name=\" << s->bucket_name_str << \")\" << dendl;\n        return ret;\n      }\n      s->bucket_exists = false;\n    }\n    s->bucket = s->bucket_info.bucket;\n\n    if (s->bucket_exists) {\n      rgw_obj_key no_obj;\n      ret = read_policy(store, s, s->bucket_info, s->bucket_attrs, s->bucket_acl, s->bucket, no_obj);\n    } else {\n      s->bucket_acl->create_default(s->user.user_id, s->user.display_name);\n      ret = -ERR_NO_SUCH_BUCKET;\n    }\n\n    s->bucket_owner = s->bucket_acl->get_owner();\n\n    string& region = s->bucket_info.region;\n    map<string, RGWRegion>::iterator dest_region = store->region_map.regions.find(region);\n    if (dest_region != store->region_map.regions.end() && !dest_region->second.endpoints.empty()) {\n      s->region_endpoint = dest_region->second.endpoints.front();\n    }\n    if (s->bucket_exists && !store->region.equals(region)) {\n      ldout(s->cct, 0) << \"NOTICE: request for data in a different region (\" << region << \" != \" << store->region.name << \")\" << dendl;\n      /* we now need to make sure that the operation actually requires copy source, that is\n       * it's a copy operation\n       */\n      if (store->region.is_master && s->op == OP_DELETE && s->system_request) {\n        /*If the operation is delete and if this is the master, don't redirect*/\n      } else if (!s->local_source ||\n          (s->op != OP_PUT && s->op != OP_COPY) ||\n          s->object.empty()) {\n        return -ERR_PERMANENT_REDIRECT;\n      }\n    }\n  }\n\n  /* we're passed only_bucket = true when we specifically need the bucket's\n     acls, that happens on write operations */\n  if (!only_bucket && !s->object.empty()) {\n    if (!s->bucket_exists) {\n      return -ERR_NO_SUCH_BUCKET;\n    }\n    s->object_acl = new RGWAccessControlPolicy(s->cct);\n\n    rgw_obj obj(s->bucket, s->object);\n    store->set_atomic(s->obj_ctx, obj);\n    if (prefetch_data) {\n      store->set_prefetch_data(s->obj_ctx, obj);\n    }\n    ret = read_policy(store, s, s->bucket_info, s->bucket_attrs, s->object_acl, s->bucket, s->object);\n  }\n\n  return ret;\n}",
        "func": "static int rgw_build_policies(RGWRados *store, struct req_state *s, bool only_bucket, bool prefetch_data)\n{\n  int ret = 0;\n  rgw_obj_key obj;\n  RGWUserInfo bucket_owner_info;\n  RGWObjectCtx& obj_ctx = *static_cast<RGWObjectCtx *>(s->obj_ctx);\n\n  string bi = s->info.args.get(RGW_SYS_PARAM_PREFIX \"bucket-instance\");\n  if (!bi.empty()) {\n    int shard_id;\n    ret = rgw_bucket_parse_bucket_instance(bi, &s->bucket_instance_id, &shard_id);\n    if (ret < 0) {\n      return ret;\n    }\n  }\n\n  if(s->dialect.compare(\"s3\") == 0) {\n    s->bucket_acl = new RGWAccessControlPolicy_S3(s->cct);\n  } else if(s->dialect.compare(\"swift\")  == 0) {\n    s->bucket_acl = new RGWAccessControlPolicy_SWIFT(s->cct);\n  } else {\n    s->bucket_acl = new RGWAccessControlPolicy(s->cct);\n  }\n\n  if (s->copy_source) { /* check if copy source is within the current domain */\n    const char *src = s->copy_source;\n    if (*src == '/')\n      ++src;\n    string copy_source_str(src);\n\n    int pos = copy_source_str.find('/');\n    if (pos > 0)\n      copy_source_str = copy_source_str.substr(0, pos);\n\n    RGWBucketInfo source_info;\n\n    ret = store->get_bucket_info(obj_ctx, copy_source_str, source_info, NULL);\n    if (ret == 0) {\n      string& region = source_info.region;\n      s->local_source = store->region.equals(region);\n    }\n  }\n\n  if (!s->bucket_name_str.empty()) {\n    s->bucket_exists = true;\n    if (s->bucket_instance_id.empty()) {\n      ret = store->get_bucket_info(obj_ctx, s->bucket_name_str, s->bucket_info, NULL, &s->bucket_attrs);\n    } else {\n      ret = store->get_bucket_instance_info(obj_ctx, s->bucket_instance_id, s->bucket_info, NULL, &s->bucket_attrs);\n    }\n    if (ret < 0) {\n      if (ret != -ENOENT) {\n        ldout(s->cct, 0) << \"NOTICE: couldn't get bucket from bucket_name (name=\" << s->bucket_name_str << \")\" << dendl;\n        return ret;\n      }\n      s->bucket_exists = false;\n    }\n    s->bucket = s->bucket_info.bucket;\n\n    if (s->bucket_exists) {\n      rgw_obj_key no_obj;\n      ret = read_policy(store, s, s->bucket_info, s->bucket_attrs, s->bucket_acl, s->bucket, no_obj);\n    } else {\n      s->bucket_acl->create_default(s->user.user_id, s->user.display_name);\n      ret = -ERR_NO_SUCH_BUCKET;\n    }\n\n    s->bucket_owner = s->bucket_acl->get_owner();\n\n    string& region = s->bucket_info.region;\n    map<string, RGWRegion>::iterator dest_region = store->region_map.regions.find(region);\n    if (dest_region != store->region_map.regions.end() && !dest_region->second.endpoints.empty()) {\n      s->region_endpoint = dest_region->second.endpoints.front();\n    }\n    if (s->bucket_exists && !store->region.equals(region)) {\n      ldout(s->cct, 0) << \"NOTICE: request for data in a different region (\" << region << \" != \" << store->region.name << \")\" << dendl;\n      /* we now need to make sure that the operation actually requires copy source, that is\n       * it's a copy operation\n       */\n      if (store->region.is_master && s->op == OP_DELETE && s->system_request) {\n        /*If the operation is delete and if this is the master, don't redirect*/\n      } else if (!s->local_source ||\n          (s->op != OP_PUT && s->op != OP_COPY) ||\n          s->object.empty()) {\n        return -ERR_PERMANENT_REDIRECT;\n      }\n    }\n  }\n\n  /* we're passed only_bucket = true when we specifically need the bucket's\n     acls, that happens on write operations */\n  if (!only_bucket && !s->object.empty()) {\n    if (!s->bucket_exists) {\n      return -ERR_NO_SUCH_BUCKET;\n    }\n    s->object_acl = new RGWAccessControlPolicy(s->cct);\n\n    rgw_obj obj(s->bucket, s->object);\n    store->set_atomic(s->obj_ctx, obj);\n    if (prefetch_data) {\n      store->set_prefetch_data(s->obj_ctx, obj);\n    }\n    ret = read_policy(store, s, s->bucket_info, s->bucket_attrs, s->object_acl, s->bucket, s->object);\n  }\n\n  return ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -14,7 +14,13 @@\n     }\n   }\n \n-  s->bucket_acl = new RGWAccessControlPolicy(s->cct);\n+  if(s->dialect.compare(\"s3\") == 0) {\n+    s->bucket_acl = new RGWAccessControlPolicy_S3(s->cct);\n+  } else if(s->dialect.compare(\"swift\")  == 0) {\n+    s->bucket_acl = new RGWAccessControlPolicy_SWIFT(s->cct);\n+  } else {\n+    s->bucket_acl = new RGWAccessControlPolicy(s->cct);\n+  }\n \n   if (s->copy_source) { /* check if copy source is within the current domain */\n     const char *src = s->copy_source;",
        "diff_line_info": {
            "deleted_lines": [
                "  s->bucket_acl = new RGWAccessControlPolicy(s->cct);"
            ],
            "added_lines": [
                "  if(s->dialect.compare(\"s3\") == 0) {",
                "    s->bucket_acl = new RGWAccessControlPolicy_S3(s->cct);",
                "  } else if(s->dialect.compare(\"swift\")  == 0) {",
                "    s->bucket_acl = new RGWAccessControlPolicy_SWIFT(s->cct);",
                "  } else {",
                "    s->bucket_acl = new RGWAccessControlPolicy(s->cct);",
                "  }"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-7031",
        "func_name": "ceph/RGWAccessControlPolicy_S3::compare_group_name",
        "description": "The RGW code in Ceph before 10.0.1, when authenticated-read ACL is applied to a bucket, allows remote attackers to list the bucket contents via a URL.",
        "git_url": "https://github.com/ceph/ceph/commit/99ba6610a8f437604cadf68cbe9969def893e870",
        "commit_title": "13207: Rados Gateway: Anonymous user is able to read bucket with authenticated read ACL",
        "commit_text": "",
        "func_before": "bool RGWAccessControlPolicy_S3::compare_group_name(string& id, ACLGroupTypeEnum group)\n{\n  switch (group) {\n  case ACL_GROUP_ALL_USERS:\n    return (id.compare(rgw_uri_all_users) == 0);\n  case ACL_GROUP_AUTHENTICATED_USERS:\n    return (id.compare(rgw_uri_auth_users) == 0);\n  default:\n    return id.empty();\n  }\n\n  // shouldn't get here\n  return false;\n}",
        "func": "bool RGWAccessControlPolicy_S3::compare_group_name(string& id, ACLGroupTypeEnum group)\n{\n  switch (group) {\n  case ACL_GROUP_ALL_USERS:\n    return (id.compare(RGW_USER_ANON_ID) == 0);\n  case ACL_GROUP_AUTHENTICATED_USERS:\n    return (id.compare(rgw_uri_auth_users) == 0);\n  default:\n    return id.empty();\n  }\n\n  // shouldn't get here\n  return false;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,7 +2,7 @@\n {\n   switch (group) {\n   case ACL_GROUP_ALL_USERS:\n-    return (id.compare(rgw_uri_all_users) == 0);\n+    return (id.compare(RGW_USER_ANON_ID) == 0);\n   case ACL_GROUP_AUTHENTICATED_USERS:\n     return (id.compare(rgw_uri_auth_users) == 0);\n   default:",
        "diff_line_info": {
            "deleted_lines": [
                "    return (id.compare(rgw_uri_all_users) == 0);"
            ],
            "added_lines": [
                "    return (id.compare(RGW_USER_ANON_ID) == 0);"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-6271",
        "func_name": "BelledonneCommunications/bzrtp/bzrtp_packetParser",
        "description": "The Bzrtp library (aka libbzrtp) 1.0.x before 1.0.4 allows man-in-the-middle attackers to conduct spoofing attacks by leveraging a missing HVI check on DHPart2 packet reception.",
        "git_url": "https://github.com/BelledonneCommunications/bzrtp/commit/bbb1e6e2f467ee4bd7b9a8c800e4f07343d7d99b",
        "commit_title": "Add ZRTP Commit packet hvi check on DHPart2 packet reception",
        "commit_text": "",
        "func_before": "int bzrtp_packetParser(bzrtpContext_t *zrtpContext, bzrtpChannelContext_t *zrtpChannelContext, const uint8_t * input, uint16_t inputLength, bzrtpPacket_t *zrtpPacket) {\n\n\tint i;\n\n\t/* now allocate and fill the correct message structure according to the message type */\n\t/* messageContent points to the begining of the ZRTP message */\n\tuint8_t *messageContent = (uint8_t *)(input+ZRTP_PACKET_HEADER_LENGTH+ZRTP_MESSAGE_HEADER_LENGTH);\n\n\tswitch (zrtpPacket->messageType) {\n\t\tcase MSGTYPE_HELLO : \n\t\t\t{\n\t\t\t\t/* allocate a Hello message structure */\n\t\t\t\tbzrtpHelloMessage_t *messageData;\n\t\t\t\tmessageData = (bzrtpHelloMessage_t *)malloc(sizeof(bzrtpHelloMessage_t));\n\n\t\t\t\t/* fill it */\n\t\t\t\tmemcpy(messageData->version, messageContent, 4);\n\t\t\t\tmessageContent +=4;\n\t\t\t\tmemcpy(messageData->clientIdentifier, messageContent, 16);\n\t\t\t\tmessageContent +=16;\n\t\t\t\tmemcpy(messageData->H3, messageContent, 32);\n\t\t\t\tmessageContent +=32;\n\t\t\t\tmemcpy(messageData->ZID, messageContent, 12);\n\t\t\t\tmessageContent +=12;\n\t\t\t\tmessageData->S = ((*messageContent)>>6)&0x01;\n\t\t\t\tmessageData->M = ((*messageContent)>>5)&0x01;\n\t\t\t\tmessageData->P = ((*messageContent)>>4)&0x01;\n\t\t\t\tmessageContent +=1;\n\t\t\t\tmessageData->hc = MIN((*messageContent)&0x0F, 7);\n\t\t\t\tmessageContent +=1;\n\t\t\t\tmessageData->cc = MIN(((*messageContent)>>4)&0x0F, 7);\n\t\t\t\tmessageData->ac = MIN((*messageContent)&0x0F, 7);\n\t\t\t\tmessageContent +=1;\n\t\t\t\tmessageData->kc = MIN(((*messageContent)>>4)&0x0F, 7);\n\t\t\t\tmessageData->sc = MIN((*messageContent)&0x0F, 7);\n\t\t\t\tmessageContent +=1;\n\n\t\t\t\t/* Check message length according to value in hc, cc, ac, kc and sc */\n\t\t\t\tif (zrtpPacket->messageLength != ZRTP_HELLOMESSAGE_FIXED_LENGTH + 4*((uint16_t)(messageData->hc)+(uint16_t)(messageData->cc)+(uint16_t)(messageData->ac)+(uint16_t)(messageData->kc)+(uint16_t)(messageData->sc))) {\n\t\t\t\t\tfree(messageData);\n\t\t\t\t\treturn BZRTP_PARSER_ERROR_INVALIDMESSAGE;\n\t\t\t\t}\n\n\t\t\t\t/* parse the variable length part: algorithms types */\n\t\t\t\tfor (i=0; i<messageData->hc; i++) {\n\t\t\t\t\tmessageData->supportedHash[i] = cryptoAlgoTypeStringToInt(messageContent, ZRTP_HASH_TYPE);\n\t\t\t\t\tmessageContent +=4;\n\t\t\t\t}\n\t\t\t\tfor (i=0; i<messageData->cc; i++) {\n\t\t\t\t\tmessageData->supportedCipher[i] = cryptoAlgoTypeStringToInt(messageContent, ZRTP_CIPHERBLOCK_TYPE);\n\t\t\t\t\tmessageContent +=4;\n\t\t\t\t}\n\t\t\t\tfor (i=0; i<messageData->ac; i++) {\n\t\t\t\t\tmessageData->supportedAuthTag[i] = cryptoAlgoTypeStringToInt(messageContent, ZRTP_AUTHTAG_TYPE);\n\t\t\t\t\tmessageContent +=4;\n\t\t\t\t}\n\t\t\t\tfor (i=0; i<messageData->kc; i++) {\n\t\t\t\t\tmessageData->supportedKeyAgreement[i] = cryptoAlgoTypeStringToInt(messageContent, ZRTP_KEYAGREEMENT_TYPE);\n\t\t\t\t\tmessageContent +=4;\n\t\t\t\t}\n\t\t\t\tfor (i=0; i<messageData->sc; i++) {\n\t\t\t\t\tmessageData->supportedSas[i] = cryptoAlgoTypeStringToInt(messageContent, ZRTP_SAS_TYPE);\n\t\t\t\t\tmessageContent +=4;\n\t\t\t\t}\n\n\t\t\t\taddMandatoryCryptoTypesIfNeeded(ZRTP_HASH_TYPE, messageData->supportedHash, &messageData->hc);\n\t\t\t\taddMandatoryCryptoTypesIfNeeded(ZRTP_CIPHERBLOCK_TYPE, messageData->supportedCipher, &messageData->cc);\n\t\t\t\taddMandatoryCryptoTypesIfNeeded(ZRTP_AUTHTAG_TYPE, messageData->supportedAuthTag, &messageData->ac);\n\t\t\t\taddMandatoryCryptoTypesIfNeeded(ZRTP_KEYAGREEMENT_TYPE, messageData->supportedKeyAgreement, &messageData->kc);\n\t\t\t\taddMandatoryCryptoTypesIfNeeded(ZRTP_SAS_TYPE, messageData->supportedSas, &messageData->sc);\n\n\t\t\t\tmemcpy(messageData->MAC, messageContent, 8);\n\t\t\t\t\n\t\t\t\t/* attach the message structure to the packet one */\n\t\t\t\tzrtpPacket->messageData = (void *)messageData;\n\n\t\t\t\t/* the parsed Hello packet must be saved as it may be used to generate commit message or the total_hash */\n\t\t\t\tzrtpPacket->packetString = (uint8_t *)malloc(inputLength*sizeof(uint8_t));\n\t\t\t\tmemcpy(zrtpPacket->packetString, input, inputLength); /* store the whole packet even if we may use the message only */\n\t\t\t}\n\t\t\tbreak; /* MSGTYPE_HELLO */\n\n\t\tcase MSGTYPE_HELLOACK :\n\t\t\t{\n\t\t\t\t/* check message length */\n\t\t\t\tif (zrtpPacket->messageLength != ZRTP_HELLOACKMESSAGE_FIXED_LENGTH) {\n\t\t\t\t\treturn BZRTP_PARSER_ERROR_INVALIDMESSAGE;\n\t\t\t\t}\n\n\n\t\t\t}\n\t\t\tbreak; /* MSGTYPE_HELLOACK */\n\n\t\tcase MSGTYPE_COMMIT:\n\t\t\t{\n\t\t\t\tuint8_t checkH3[32];\n\t\t\t\tuint8_t checkMAC[32];\n\t\t\t\tbzrtpHelloMessage_t *peerHelloMessageData;\n\t\t\t\tuint16_t variableLength = 0;\n\n\t\t\t\t/* allocate a commit message structure */\n\t\t\t\tbzrtpCommitMessage_t *messageData;\n\t\t\t\tmessageData = (bzrtpCommitMessage_t *)malloc(sizeof(bzrtpCommitMessage_t));\n\n\t\t\t\t/* fill the structure */\n\t\t\t\tmemcpy(messageData->H2, messageContent, 32);\n\t\t\t\tmessageContent +=32;\n\n\t\t\t\t/* We have now H2, check it matches the H3 we had in the hello message H3=SHA256(H2) and that the Hello message MAC is correct */\n\t\t\t\tif (zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID] == NULL) {\n\t\t\t\t\tfree (messageData);\n\t\t\t\t\t/* we have no Hello message in this channel, this commit shall never have arrived, discard it as invalid */\n\t\t\t\t\treturn BZRTP_PARSER_ERROR_UNEXPECTEDMESSAGE;\n\t\t\t\t}\n\t\t\t\tpeerHelloMessageData = (bzrtpHelloMessage_t *)zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID]->messageData;\n\t\t\t\t/* Check H3 = SHA256(H2) */\n\t\t\t\tbctoolbox_sha256(messageData->H2, 32, 32, checkH3);\n\t\t\t\tif (memcmp(checkH3, peerHelloMessageData->H3, 32) != 0) {\n\t\t\t\t\tfree (messageData);\n\t\t\t\t\treturn BZRTP_PARSER_ERROR_UNMATCHINGHASHCHAIN;\n\t\t\t\t}\n\t\t\t\t/* Check the hello MAC message. \n\t\t\t\t * MAC is 8 bytes long and is computed on the message(skip the ZRTP_PACKET_HEADER) and exclude the mac itself (-8 bytes from message Length) */\n\t\t\t\tbctoolbox_hmacSha256(messageData->H2, 32, zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID]->packetString+ZRTP_PACKET_HEADER_LENGTH, zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID]->messageLength-8, 8, checkMAC);\n\t\t\t\tif (memcmp(checkMAC, peerHelloMessageData->MAC, 8) != 0) {\n\t\t\t\t\tfree (messageData);\n\t\t\t\t\treturn BZRTP_PARSER_ERROR_UNMATCHINGMAC;\n\t\t\t\t}\n\n\t\t\t\tmemcpy(messageData->ZID, messageContent, 12);\n\t\t\t\tmessageContent +=12;\n\t\t\t\tmessageData->hashAlgo = cryptoAlgoTypeStringToInt(messageContent, ZRTP_HASH_TYPE);\n\t\t\t\tmessageContent += 4;\n\t\t\t\tmessageData->cipherAlgo = cryptoAlgoTypeStringToInt(messageContent, ZRTP_CIPHERBLOCK_TYPE);\n\t\t\t\tmessageContent += 4;\n\t\t\t\tmessageData->authTagAlgo = cryptoAlgoTypeStringToInt(messageContent, ZRTP_AUTHTAG_TYPE);\n\t\t\t\tmessageContent += 4;\n\t\t\t\tmessageData->keyAgreementAlgo = cryptoAlgoTypeStringToInt(messageContent, ZRTP_KEYAGREEMENT_TYPE);\n\t\t\t\tmessageContent += 4;\n\t\t\t\t/* commit message length depends on the key agreement type choosen (and set in the zrtpContext->keyAgreementAlgo) */\n\t\t\t\tswitch(messageData->keyAgreementAlgo) {\n\t\t\t\t\tcase ZRTP_KEYAGREEMENT_DH2k :\n\t\t\t\t\tcase ZRTP_KEYAGREEMENT_EC25 :\n\t\t\t\t\tcase ZRTP_KEYAGREEMENT_DH3k :\n\t\t\t\t\tcase ZRTP_KEYAGREEMENT_EC38 :\n\t\t\t\t\tcase ZRTP_KEYAGREEMENT_EC52 :\n\t\t\t\t\t\tvariableLength = 32; /* hvi is 32 bytes length in DH Commit message format */\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ZRTP_KEYAGREEMENT_Prsh :\n\t\t\t\t\t\tvariableLength = 24; /* nonce (16 bytes) and keyID(8 bytes) are 24 bytes length in preshared Commit message format */\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ZRTP_KEYAGREEMENT_Mult :\n\t\t\t\t\t\tvariableLength = 16; /* nonce is 24 bytes length in multistream Commit message format */\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tfree(messageData);\n\t\t\t\t\t\treturn BZRTP_PARSER_ERROR_INVALIDMESSAGE;\n\t\t\t\t}\n\n\t\t\t\tif (zrtpPacket->messageLength != ZRTP_COMMITMESSAGE_FIXED_LENGTH + variableLength) {\n\t\t\t\t\tfree(messageData);\n\t\t\t\t\treturn BZRTP_PARSER_ERROR_INVALIDMESSAGE;\n\t\t\t\t}\n\t\t\t\tmessageData->sasAlgo = cryptoAlgoTypeStringToInt(messageContent, ZRTP_SAS_TYPE);\n\t\t\t\tmessageContent += 4;\n\n\t\t\t\t/* if it is a multistream or preshared commit, get the 16 bytes nonce */\n\t\t\t\tif ((messageData->keyAgreementAlgo == ZRTP_KEYAGREEMENT_Prsh) || (messageData->keyAgreementAlgo == ZRTP_KEYAGREEMENT_Mult)) {\n\t\t\t\t\tmemcpy(messageData->nonce, messageContent, 16);\n\t\t\t\t\tmessageContent +=16;\n\n\t\t\t\t\t/* and the keyID for preshared commit only */\n\t\t\t\t\tif (messageData->keyAgreementAlgo == ZRTP_KEYAGREEMENT_Prsh) {\n\t\t\t\t\t\tmemcpy(messageData->keyID, messageContent, 8);\n\t\t\t\t\t\tmessageContent +=8;\n\t\t\t\t\t}\n\t\t\t\t} else { /* it's a DH commit message, get the hvi */\n\t\t\t\t\tmemcpy(messageData->hvi, messageContent, 32);\n\t\t\t\t\tmessageContent +=32;\n\t\t\t\t}\n\n\t\t\t\t/* get the MAC and attach the message data to the packet structure */\n\t\t\t\tmemcpy(messageData->MAC, messageContent, 8);\n\t\t\t\tzrtpPacket->messageData = (void *)messageData;\n\n\t\t\t\t/* the parsed commit packet must be saved as it is used to generate the total_hash */\n\t\t\t\tzrtpPacket->packetString = (uint8_t *)malloc(inputLength*sizeof(uint8_t));\n\t\t\t\tmemcpy(zrtpPacket->packetString, input, inputLength); /* store the whole packet even if we may use the message only */\n\t\t\t}\n\t\t\tbreak; /* MSGTYPE_COMMIT */\n\t\tcase MSGTYPE_DHPART1 :\n\t\tcase MSGTYPE_DHPART2 :\n\t\t\t{\n\t\t\t\tbzrtpDHPartMessage_t *messageData;\n\n\t\t\t\t/*check message length, depends on the selected key agreement algo set in zrtpContext */\n\t\t\t\tuint16_t pvLength = computeKeyAgreementPrivateValueLength(zrtpChannelContext->keyAgreementAlgo);\n\t\t\t\tif (pvLength == 0) {\n\t\t\t\t\treturn BZRTP_PARSER_ERROR_INVALIDCONTEXT;\n\t\t\t\t}\n\n\t\t\t\tif (zrtpPacket->messageLength != ZRTP_DHPARTMESSAGE_FIXED_LENGTH+pvLength) {\n\t\t\t\t\treturn BZRTP_PARSER_ERROR_INVALIDMESSAGE;\n\t\t\t\t}\n\n\t\t\t\t/* allocate a DHPart message structure and pv */\n\t\t\t\tmessageData = (bzrtpDHPartMessage_t *)malloc(sizeof(bzrtpDHPartMessage_t));\n\t\t\t\tmessageData->pv = (uint8_t *)malloc(pvLength*sizeof(uint8_t));\n\n\t\t\t\t/* fill the structure */\n\t\t\t\tmemcpy(messageData->H1, messageContent, 32);\n\t\t\t\tmessageContent +=32;\n\n\t\t\t\t/* We have now H1, check it matches the H2 we had in the commit message H2=SHA256(H1) and that the Commit message MAC is correct */\n\t\t\t\tif ( zrtpChannelContext->role == RESPONDER) { /* do it only if we are responder (we received a commit packet) */\n\t\t\t\t\tuint8_t checkH2[32];\n\t\t\t\t\tuint8_t checkMAC[32];\n\t\t\t\t\tbzrtpCommitMessage_t *peerCommitMessageData;\n\n\t\t\t\t\tif (zrtpChannelContext->peerPackets[COMMIT_MESSAGE_STORE_ID] == NULL) {\n\t\t\t\t\t\tfree (messageData);\n\t\t\t\t\t\t/* we have no Commit message in this channel, this DHPart2 shall never have arrived, discard it as invalid */\n\t\t\t\t\t\treturn BZRTP_PARSER_ERROR_UNEXPECTEDMESSAGE;\n\t\t\t\t\t}\n\t\t\t\t\tpeerCommitMessageData = (bzrtpCommitMessage_t *)zrtpChannelContext->peerPackets[COMMIT_MESSAGE_STORE_ID]->messageData;\n\t\t\t\t\t/* Check H2 = SHA256(H1) */\n\t\t\t\t\tbctoolbox_sha256(messageData->H1, 32, 32, checkH2);\n\t\t\t\t\tif (memcmp(checkH2, peerCommitMessageData->H2, 32) != 0) {\n\t\t\t\t\t\tfree (messageData);\n\t\t\t\t\t\treturn BZRTP_PARSER_ERROR_UNMATCHINGHASHCHAIN;\n\t\t\t\t\t}\n\t\t\t\t\t/* Check the Commit MAC message. \n\t\t\t\t\t * MAC is 8 bytes long and is computed on the message(skip the ZRTP_PACKET_HEADER) and exclude the mac itself (-8 bytes from message Length) */\n\t\t\t\t\tbctoolbox_hmacSha256(messageData->H1, 32, zrtpChannelContext->peerPackets[COMMIT_MESSAGE_STORE_ID]->packetString+ZRTP_PACKET_HEADER_LENGTH, zrtpChannelContext->peerPackets[COMMIT_MESSAGE_STORE_ID]->messageLength-8, 8, checkMAC);\n\t\t\t\t\tif (memcmp(checkMAC, peerCommitMessageData->MAC, 8) != 0) {\n\t\t\t\t\t\tfree (messageData);\n\t\t\t\t\t\treturn BZRTP_PARSER_ERROR_UNMATCHINGMAC;\n\t\t\t\t\t}\n\t\t\t\t} else { /* if we are initiator(we didn't received any commit message and then no H2), we must check that H3=SHA256(SHA256(H1)) and the Hello message MAC */\n\t\t\t\t\tuint8_t checkH2[32];\n\t\t\t\t\tuint8_t checkH3[32];\n\t\t\t\t\tuint8_t checkMAC[32];\n\t\t\t\t\tbzrtpHelloMessage_t *peerHelloMessageData;\n\n\t\t\t\t\tif (zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID] == NULL) {\n\t\t\t\t\t\tfree (messageData);\n\t\t\t\t\t\t/* we have no Hello message in this channel, this DHPart1 shall never have arrived, discard it as invalid */\n\t\t\t\t\t\treturn BZRTP_PARSER_ERROR_UNEXPECTEDMESSAGE;\n\t\t\t\t\t}\n\t\t\t\t\tpeerHelloMessageData = (bzrtpHelloMessage_t *)zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID]->messageData;\n\t\t\t\t\t/* Check H3 = SHA256(SHA256(H1)) */\n\t\t\t\t\tbctoolbox_sha256(messageData->H1, 32, 32, checkH2);\n\t\t\t\t\tbctoolbox_sha256(checkH2, 32, 32, checkH3);\n\t\t\t\t\tif (memcmp(checkH3, peerHelloMessageData->H3, 32) != 0) {\n\t\t\t\t\t\tfree (messageData);\n\t\t\t\t\t\treturn BZRTP_PARSER_ERROR_UNMATCHINGHASHCHAIN;\n\t\t\t\t\t}\n\t\t\t\t\t/* Check the hello MAC message. \n\t\t\t\t\t * MAC is 8 bytes long and is computed on the message(skip the ZRTP_PACKET_HEADER) and exclude the mac itself (-8 bytes from message Length) */\n\t\t\t\t\tbctoolbox_hmacSha256(checkH2, 32, zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID]->packetString+ZRTP_PACKET_HEADER_LENGTH, zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID]->messageLength-8, 8, checkMAC);\n\t\t\t\t\tif (memcmp(checkMAC, peerHelloMessageData->MAC, 8) != 0) {\n\t\t\t\t\t\tfree (messageData);\n\t\t\t\t\t\treturn BZRTP_PARSER_ERROR_UNMATCHINGMAC;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tmemcpy(messageData->rs1ID, messageContent, 8);\n\t\t\t\tmessageContent +=8;\n\t\t\t\tmemcpy(messageData->rs2ID, messageContent, 8);\n\t\t\t\tmessageContent +=8;\n\t\t\t\tmemcpy(messageData->auxsecretID, messageContent, 8);\n\t\t\t\tmessageContent +=8;\n\t\t\t\tmemcpy(messageData->pbxsecretID, messageContent, 8);\n\t\t\t\tmessageContent +=8;\n\t\t\t\tmemcpy(messageData->pv, messageContent, pvLength);\n\t\t\t\tmessageContent +=pvLength;\n\t\t\t\tmemcpy(messageData->MAC, messageContent, 8);\n\n\t\t\t\t/* attach the message structure to the packet one */\n\t\t\t\tzrtpPacket->messageData = (void *)messageData;\n\n\t\t\t\t/* the parsed commit packet must be saved as it is used to generate the total_hash */\n\t\t\t\tzrtpPacket->packetString = (uint8_t *)malloc(inputLength*sizeof(uint8_t));\n\t\t\t\tmemcpy(zrtpPacket->packetString, input, inputLength); /* store the whole packet even if we may use the message only */\n\t\t\t}\n\t\t\tbreak; /* MSGTYPE_DHPART1 and MSGTYPE_DHPART2 */\n\t\tcase MSGTYPE_CONFIRM1:\n\t\tcase MSGTYPE_CONFIRM2:\n\t\t\t{\n\t\t\t\tuint8_t *confirmMessageKey = NULL;\n\t\t\t\tuint8_t *confirmMessageMacKey = NULL;\n\t\t\t\tbzrtpConfirmMessage_t *messageData;\n\t\t\t\tuint16_t cipherTextLength;\n\t\t\t\tuint8_t computedHmac[8];\n\t\t\t\tuint8_t *confirmPlainMessageBuffer;\n\t\t\t\tuint8_t *confirmPlainMessage;\n\n\t\t\t\t/* we shall first decrypt and validate the message, check we have the keys to do it */\n\t\t\t\tif (zrtpChannelContext->role == RESPONDER) { /* responder uses initiator's keys to decrypt */\n\t\t\t\t\tif ((zrtpChannelContext->zrtpkeyi == NULL) || (zrtpChannelContext->mackeyi == NULL)) {\n\t\t\t\t\t\treturn BZRTP_PARSER_ERROR_INVALIDCONTEXT;\n\t\t\t\t\t}\n\t\t\t\t\tconfirmMessageKey = zrtpChannelContext->zrtpkeyi;\n\t\t\t\t\tconfirmMessageMacKey = zrtpChannelContext->mackeyi;\n\t\t\t\t}\n\n\t\t\t\tif (zrtpChannelContext->role == INITIATOR) { /* the iniator uses responder's keys to decrypt */\n\t\t\t\t\tif ((zrtpChannelContext->zrtpkeyr == NULL) || (zrtpChannelContext->mackeyr == NULL)) {\n\t\t\t\t\t\treturn BZRTP_PARSER_ERROR_INVALIDCONTEXT;\n\t\t\t\t\t}\n\t\t\t\t\tconfirmMessageKey = zrtpChannelContext->zrtpkeyr;\n\t\t\t\t\tconfirmMessageMacKey = zrtpChannelContext->mackeyr;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t/* allocate a confirm message structure */\n\t\t\t\tmessageData = (bzrtpConfirmMessage_t *)malloc(sizeof(bzrtpConfirmMessage_t));\n\n\t\t\t\t/* get the mac and the IV */\n\t\t\t\tmemcpy(messageData->confirm_mac, messageContent, 8);\n\t\t\t\tmessageContent +=8;\n\t\t\t\tmemcpy(messageData->CFBIV, messageContent, 16);\n\t\t\t\tmessageContent +=16;\n\n\n\t\t\t\t\n\t\t\t\t/* get the cipher text length */\n\t\t\t\tcipherTextLength = zrtpPacket->messageLength - ZRTP_MESSAGE_HEADER_LENGTH - 24; /* confirm message is header, confirm_mac(8 bytes), CFB IV(16 bytes), encrypted part */\n\n\t\t\t\t/* validate the mac over the cipher text */\n\t\t\t\tzrtpChannelContext->hmacFunction(confirmMessageMacKey, zrtpChannelContext->hashLength, messageContent, cipherTextLength, 8, computedHmac);\n\t\t\t\t\n\t\t\t\tif (memcmp(computedHmac, messageData->confirm_mac, 8) != 0) { /* confirm_mac doesn't match */\n\t\t\t\t\tfree(messageData);\n\t\t\t\t\treturn BZRTP_PARSER_ERROR_UNMATCHINGCONFIRMMAC;\n\t\t\t\t}\n\n\t\t\t\t/* get plain message */\n\t\t\t\tconfirmPlainMessageBuffer = (uint8_t *)malloc(cipherTextLength*sizeof(uint8_t));\n\t\t\t\tzrtpChannelContext->cipherDecryptionFunction(confirmMessageKey, messageData->CFBIV, messageContent, cipherTextLength, confirmPlainMessageBuffer);\n\t\t\t\tconfirmPlainMessage = confirmPlainMessageBuffer; /* point into the allocated buffer */\n\n\t\t\t\t/* parse it */\n\t\t\t\tmemcpy(messageData->H0, confirmPlainMessage, 32);\n\t\t\t\tconfirmPlainMessage +=33; /* +33 because next 8 bits are unused */\n\n\t\t\t\t/* Hash chain checking: if we are in multichannel or shared mode, we had not DHPart and then no H1 */\n\t\t\t\tif (zrtpChannelContext->keyAgreementAlgo == ZRTP_KEYAGREEMENT_Prsh || zrtpChannelContext->keyAgreementAlgo == ZRTP_KEYAGREEMENT_Mult) {\n\t\t\t\t\t/* compute the H1=SHA256(H0) we never received */\n\t\t\t\t\tuint8_t checkH1[32];\n\t\t\t\t\tbctoolbox_sha256(messageData->H0, 32, 32, checkH1);\n\n\t\t\t\t\t/* if we are responder, we received a commit packet with H2 then check that H2=SHA256(H1) and that the commit message MAC keyed with H1 match */\n\t\t\t\t\tif ( zrtpChannelContext->role == RESPONDER) {\n\t\t\t\t\t\tuint8_t checkH2[32];\n\t\t\t\t\t\tuint8_t checkMAC[32];\n\t\t\t\t\t\tbzrtpCommitMessage_t *peerCommitMessageData;\n\n\t\t\t\t\t\tif (zrtpChannelContext->peerPackets[COMMIT_MESSAGE_STORE_ID] == NULL) {\n\t\t\t\t\t\t\tfree (messageData);\n\t\t\t\t\t\t\t/* we have no Commit message in this channel, this Confirm2 shall never have arrived, discard it as invalid */\n\t\t\t\t\t\t\treturn BZRTP_PARSER_ERROR_UNEXPECTEDMESSAGE;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpeerCommitMessageData = (bzrtpCommitMessage_t *)zrtpChannelContext->peerPackets[COMMIT_MESSAGE_STORE_ID]->messageData;\n\t\t\t\t\t\t/* Check H2 = SHA256(H1) */\n\t\t\t\t\t\tbctoolbox_sha256(checkH1, 32, 32, checkH2);\n\t\t\t\t\t\tif (memcmp(checkH2, peerCommitMessageData->H2, 32) != 0) {\n\t\t\t\t\t\t\tfree (messageData);\n\t\t\t\t\t\t\treturn BZRTP_PARSER_ERROR_UNMATCHINGHASHCHAIN;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* Check the Commit MAC message. \n\t\t\t\t\t\t * MAC is 8 bytes long and is computed on the message(skip the ZRTP_PACKET_HEADER) and exclude the mac itself (-8 bytes from message Length) */\n\t\t\t\t\t\tbctoolbox_hmacSha256(checkH1, 32, zrtpChannelContext->peerPackets[COMMIT_MESSAGE_STORE_ID]->packetString+ZRTP_PACKET_HEADER_LENGTH, zrtpChannelContext->peerPackets[COMMIT_MESSAGE_STORE_ID]->messageLength-8, 8, checkMAC);\n\t\t\t\t\t\tif (memcmp(checkMAC, peerCommitMessageData->MAC, 8) != 0) {\n\t\t\t\t\t\t\tfree (messageData);\n\t\t\t\t\t\t\treturn BZRTP_PARSER_ERROR_UNMATCHINGMAC;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else { /* if we are initiator(we didn't received any commit message and then no H2), we must check that H3=SHA256(SHA256(H1)) and the Hello message MAC */\n\t\t\t\t\t\tuint8_t checkH2[32];\n\t\t\t\t\t\tuint8_t checkH3[32];\n\t\t\t\t\t\tuint8_t checkMAC[32];\n\t\t\t\t\t\tbzrtpHelloMessage_t *peerHelloMessageData;\n\n\t\t\t\t\t\tif (zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID] == NULL) {\n\t\t\t\t\t\t\tfree (messageData);\n\t\t\t\t\t\t\t/* we have no Hello message in this channel, this Confirm1 shall never have arrived, discard it as invalid */\n\t\t\t\t\t\t\treturn BZRTP_PARSER_ERROR_UNEXPECTEDMESSAGE;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpeerHelloMessageData = (bzrtpHelloMessage_t *)zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID]->messageData;\n\t\t\t\t\t\t/* Check H3 = SHA256(SHA256(H1)) */\n\t\t\t\t\t\tbctoolbox_sha256(checkH1, 32, 32, checkH2);\n\t\t\t\t\t\tbctoolbox_sha256(checkH2, 32, 32, checkH3);\n\t\t\t\t\t\tif (memcmp(checkH3, peerHelloMessageData->H3, 32) != 0) {\n\t\t\t\t\t\t\tfree (messageData);\n\t\t\t\t\t\t\treturn BZRTP_PARSER_ERROR_UNMATCHINGHASHCHAIN;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* Check the hello MAC message. \n\t\t\t\t\t\t * MAC is 8 bytes long and is computed on the message(skip the ZRTP_PACKET_HEADER) and exclude the mac itself (-8 bytes from message Length) */\n\t\t\t\t\t\tbctoolbox_hmacSha256(checkH2, 32, zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID]->packetString+ZRTP_PACKET_HEADER_LENGTH, zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID]->messageLength-8, 8, checkMAC);\n\t\t\t\t\t\tif (memcmp(checkMAC, peerHelloMessageData->MAC, 8) != 0) {\n\t\t\t\t\t\t\tfree (messageData);\n\t\t\t\t\t\t\treturn BZRTP_PARSER_ERROR_UNMATCHINGMAC;\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\t\t\t} else { /* we are in DHM mode */\n\t\t\t\t\t/* We have now H0, check it matches the H1 we had in the DHPart message H1=SHA256(H0) and that the DHPart message MAC is correct */\n\t\t\t\t\tuint8_t checkH1[32];\n\t\t\t\t\tuint8_t checkMAC[32];\n\t\t\t\t\tbzrtpDHPartMessage_t *peerDHPartMessageData;\n\n\t\t\t\t\tif (zrtpChannelContext->peerPackets[DHPART_MESSAGE_STORE_ID] == NULL) {\n\t\t\t\t\t\tfree (messageData);\n\t\t\t\t\t\t/* we have no DHPART message in this channel, this confirm shall never have arrived, discard it as invalid */\n\t\t\t\t\t\treturn BZRTP_PARSER_ERROR_UNEXPECTEDMESSAGE;\n\t\t\t\t\t}\n\t\t\t\t\tpeerDHPartMessageData = (bzrtpDHPartMessage_t *)zrtpChannelContext->peerPackets[DHPART_MESSAGE_STORE_ID]->messageData;\n\t\t\t\t\t/* Check H1 = SHA256(H0) */\n\t\t\t\t\tbctoolbox_sha256(messageData->H0, 32, 32, checkH1);\n\t\t\t\t\tif (memcmp(checkH1, peerDHPartMessageData->H1, 32) != 0) {\n\t\t\t\t\t\tfree (messageData);\n\t\t\t\t\t\treturn BZRTP_PARSER_ERROR_UNMATCHINGHASHCHAIN;\n\t\t\t\t\t}\n\t\t\t\t\t/* Check the DHPart message. \n\t\t\t\t\t * MAC is 8 bytes long and is computed on the message(skip the ZRTP_PACKET_HEADER) and exclude the mac itself (-8 bytes from message Length) */\n\t\t\t\t\tbctoolbox_hmacSha256(messageData->H0, 32, zrtpChannelContext->peerPackets[DHPART_MESSAGE_STORE_ID]->packetString+ZRTP_PACKET_HEADER_LENGTH, zrtpChannelContext->peerPackets[DHPART_MESSAGE_STORE_ID]->messageLength-8, 8, checkMAC);\n\t\t\t\t\tif (memcmp(checkMAC, peerDHPartMessageData->MAC, 8) != 0) {\n\t\t\t\t\t\tfree (messageData);\n\t\t\t\t\t\treturn BZRTP_PARSER_ERROR_UNMATCHINGMAC;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tmessageData->sig_len = ((uint16_t)(confirmPlainMessage[0]&0x01))<<8 | (((uint16_t)confirmPlainMessage[1])&0x00FF);\n\t\t\t\tconfirmPlainMessage += 2;\n\t\t\t\tmessageData->E = ((*confirmPlainMessage)&0x08)>>3;\n\t\t\t\tmessageData->V = ((*confirmPlainMessage)&0x04)>>2;\n\t\t\t\tmessageData->A = ((*confirmPlainMessage)&0x02)>>1;\n\t\t\t\tmessageData->D = (*confirmPlainMessage)&0x01;\n\t\t\t\tconfirmPlainMessage += 1;\n\n\t\t\t\tmessageData->cacheExpirationInterval = (((uint32_t)confirmPlainMessage[0])<<24) | (((uint32_t)confirmPlainMessage[1])<<16) | (((uint32_t)confirmPlainMessage[2])<<8) | ((uint32_t)confirmPlainMessage[3]);\n\t\t\t\tconfirmPlainMessage += 4;\n\n\n\t\t\t\t/* if sig_len indicate a signature, parse it */\n\t\t\t\tif (messageData->sig_len>0) {\n\t\t\t\t\tmemcpy(messageData->signatureBlockType, confirmPlainMessage, 4);\n\t\t\t\t\tconfirmPlainMessage += 4;\n\t\t\t\t\t/* allocate memory for the signature block, sig_len is in words(32 bits) and includes the signature block type word */\n\t\t\t\t\tmessageData->signatureBlock = (uint8_t *)malloc(4*(messageData->sig_len-1)*sizeof(uint8_t));\n\t\t\t\t\tmemcpy(messageData->signatureBlock, confirmPlainMessage, 4*(messageData->sig_len-1));\n\t\t\t\t} else {\n\t\t\t\t\tmessageData->signatureBlock  = NULL;\n\t\t\t\t}\n\n\t\t\t\t/* free plain buffer */\n\t\t\t\tfree(confirmPlainMessageBuffer);\n\n\t\t\t\t/* the parsed commit packet must be saved as it is used to check correct packet repetition */\n\t\t\t\tzrtpPacket->packetString = (uint8_t *)malloc(inputLength*sizeof(uint8_t));\n\t\t\t\tmemcpy(zrtpPacket->packetString, input, inputLength); /* store the whole packet even if we may use the message only */\n\n\t\t\t\t/* attach the message structure to the packet one */\n\t\t\t\tzrtpPacket->messageData = (void *)messageData;\n\t\t\t}\n\t\t\tbreak; /* MSGTYPE_CONFIRM1 and MSGTYPE_CONFIRM2 */\n\n\t\tcase MSGTYPE_CONF2ACK:\n\t\t\t/* nothing to do for this one */\n\t\t\tbreak; /* MSGTYPE_CONF2ACK */\n\t\t\n\t\tcase MSGTYPE_PING:\n\t\t\t{\n\t\t\t\t/* allocate a ping message structure */\n\t\t\t\tbzrtpPingMessage_t *messageData;\n\t\t\t\tmessageData = (bzrtpPingMessage_t *)malloc(sizeof(bzrtpPingMessage_t));\n\n\t\t\t\t/* fill the structure */\n\t\t\t\tmemcpy(messageData->version, messageContent, 4);\n\t\t\t\tmessageContent +=4;\n\t\t\t\tmemcpy(messageData->endpointHash, messageContent, 8);\n\n\t\t\t\t/* attach the message structure to the packet one */\n\t\t\t\tzrtpPacket->messageData = (void *)messageData;\n\t\t\t}\n\t\t\tbreak; /* MSGTYPE_PING */\n\n\t}\n\n\treturn 0;\n}",
        "func": "int bzrtp_packetParser(bzrtpContext_t *zrtpContext, bzrtpChannelContext_t *zrtpChannelContext, const uint8_t * input, uint16_t inputLength, bzrtpPacket_t *zrtpPacket) {\n\n\tint i;\n\n\t/* now allocate and fill the correct message structure according to the message type */\n\t/* messageContent points to the begining of the ZRTP message */\n\tuint8_t *messageContent = (uint8_t *)(input+ZRTP_PACKET_HEADER_LENGTH+ZRTP_MESSAGE_HEADER_LENGTH);\n\n\tswitch (zrtpPacket->messageType) {\n\t\tcase MSGTYPE_HELLO : \n\t\t\t{\n\t\t\t\t/* allocate a Hello message structure */\n\t\t\t\tbzrtpHelloMessage_t *messageData;\n\t\t\t\tmessageData = (bzrtpHelloMessage_t *)malloc(sizeof(bzrtpHelloMessage_t));\n\n\t\t\t\t/* fill it */\n\t\t\t\tmemcpy(messageData->version, messageContent, 4);\n\t\t\t\tmessageContent +=4;\n\t\t\t\tmemcpy(messageData->clientIdentifier, messageContent, 16);\n\t\t\t\tmessageContent +=16;\n\t\t\t\tmemcpy(messageData->H3, messageContent, 32);\n\t\t\t\tmessageContent +=32;\n\t\t\t\tmemcpy(messageData->ZID, messageContent, 12);\n\t\t\t\tmessageContent +=12;\n\t\t\t\tmessageData->S = ((*messageContent)>>6)&0x01;\n\t\t\t\tmessageData->M = ((*messageContent)>>5)&0x01;\n\t\t\t\tmessageData->P = ((*messageContent)>>4)&0x01;\n\t\t\t\tmessageContent +=1;\n\t\t\t\tmessageData->hc = MIN((*messageContent)&0x0F, 7);\n\t\t\t\tmessageContent +=1;\n\t\t\t\tmessageData->cc = MIN(((*messageContent)>>4)&0x0F, 7);\n\t\t\t\tmessageData->ac = MIN((*messageContent)&0x0F, 7);\n\t\t\t\tmessageContent +=1;\n\t\t\t\tmessageData->kc = MIN(((*messageContent)>>4)&0x0F, 7);\n\t\t\t\tmessageData->sc = MIN((*messageContent)&0x0F, 7);\n\t\t\t\tmessageContent +=1;\n\n\t\t\t\t/* Check message length according to value in hc, cc, ac, kc and sc */\n\t\t\t\tif (zrtpPacket->messageLength != ZRTP_HELLOMESSAGE_FIXED_LENGTH + 4*((uint16_t)(messageData->hc)+(uint16_t)(messageData->cc)+(uint16_t)(messageData->ac)+(uint16_t)(messageData->kc)+(uint16_t)(messageData->sc))) {\n\t\t\t\t\tfree(messageData);\n\t\t\t\t\treturn BZRTP_PARSER_ERROR_INVALIDMESSAGE;\n\t\t\t\t}\n\n\t\t\t\t/* parse the variable length part: algorithms types */\n\t\t\t\tfor (i=0; i<messageData->hc; i++) {\n\t\t\t\t\tmessageData->supportedHash[i] = cryptoAlgoTypeStringToInt(messageContent, ZRTP_HASH_TYPE);\n\t\t\t\t\tmessageContent +=4;\n\t\t\t\t}\n\t\t\t\tfor (i=0; i<messageData->cc; i++) {\n\t\t\t\t\tmessageData->supportedCipher[i] = cryptoAlgoTypeStringToInt(messageContent, ZRTP_CIPHERBLOCK_TYPE);\n\t\t\t\t\tmessageContent +=4;\n\t\t\t\t}\n\t\t\t\tfor (i=0; i<messageData->ac; i++) {\n\t\t\t\t\tmessageData->supportedAuthTag[i] = cryptoAlgoTypeStringToInt(messageContent, ZRTP_AUTHTAG_TYPE);\n\t\t\t\t\tmessageContent +=4;\n\t\t\t\t}\n\t\t\t\tfor (i=0; i<messageData->kc; i++) {\n\t\t\t\t\tmessageData->supportedKeyAgreement[i] = cryptoAlgoTypeStringToInt(messageContent, ZRTP_KEYAGREEMENT_TYPE);\n\t\t\t\t\tmessageContent +=4;\n\t\t\t\t}\n\t\t\t\tfor (i=0; i<messageData->sc; i++) {\n\t\t\t\t\tmessageData->supportedSas[i] = cryptoAlgoTypeStringToInt(messageContent, ZRTP_SAS_TYPE);\n\t\t\t\t\tmessageContent +=4;\n\t\t\t\t}\n\n\t\t\t\taddMandatoryCryptoTypesIfNeeded(ZRTP_HASH_TYPE, messageData->supportedHash, &messageData->hc);\n\t\t\t\taddMandatoryCryptoTypesIfNeeded(ZRTP_CIPHERBLOCK_TYPE, messageData->supportedCipher, &messageData->cc);\n\t\t\t\taddMandatoryCryptoTypesIfNeeded(ZRTP_AUTHTAG_TYPE, messageData->supportedAuthTag, &messageData->ac);\n\t\t\t\taddMandatoryCryptoTypesIfNeeded(ZRTP_KEYAGREEMENT_TYPE, messageData->supportedKeyAgreement, &messageData->kc);\n\t\t\t\taddMandatoryCryptoTypesIfNeeded(ZRTP_SAS_TYPE, messageData->supportedSas, &messageData->sc);\n\n\t\t\t\tmemcpy(messageData->MAC, messageContent, 8);\n\t\t\t\t\n\t\t\t\t/* attach the message structure to the packet one */\n\t\t\t\tzrtpPacket->messageData = (void *)messageData;\n\n\t\t\t\t/* the parsed Hello packet must be saved as it may be used to generate commit message or the total_hash */\n\t\t\t\tzrtpPacket->packetString = (uint8_t *)malloc(inputLength*sizeof(uint8_t));\n\t\t\t\tmemcpy(zrtpPacket->packetString, input, inputLength); /* store the whole packet even if we may use the message only */\n\t\t\t}\n\t\t\tbreak; /* MSGTYPE_HELLO */\n\n\t\tcase MSGTYPE_HELLOACK :\n\t\t\t{\n\t\t\t\t/* check message length */\n\t\t\t\tif (zrtpPacket->messageLength != ZRTP_HELLOACKMESSAGE_FIXED_LENGTH) {\n\t\t\t\t\treturn BZRTP_PARSER_ERROR_INVALIDMESSAGE;\n\t\t\t\t}\n\n\n\t\t\t}\n\t\t\tbreak; /* MSGTYPE_HELLOACK */\n\n\t\tcase MSGTYPE_COMMIT:\n\t\t\t{\n\t\t\t\tuint8_t checkH3[32];\n\t\t\t\tuint8_t checkMAC[32];\n\t\t\t\tbzrtpHelloMessage_t *peerHelloMessageData;\n\t\t\t\tuint16_t variableLength = 0;\n\n\t\t\t\t/* allocate a commit message structure */\n\t\t\t\tbzrtpCommitMessage_t *messageData;\n\t\t\t\tmessageData = (bzrtpCommitMessage_t *)malloc(sizeof(bzrtpCommitMessage_t));\n\n\t\t\t\t/* fill the structure */\n\t\t\t\tmemcpy(messageData->H2, messageContent, 32);\n\t\t\t\tmessageContent +=32;\n\n\t\t\t\t/* We have now H2, check it matches the H3 we had in the hello message H3=SHA256(H2) and that the Hello message MAC is correct */\n\t\t\t\tif (zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID] == NULL) {\n\t\t\t\t\tfree (messageData);\n\t\t\t\t\t/* we have no Hello message in this channel, this commit shall never have arrived, discard it as invalid */\n\t\t\t\t\treturn BZRTP_PARSER_ERROR_UNEXPECTEDMESSAGE;\n\t\t\t\t}\n\t\t\t\tpeerHelloMessageData = (bzrtpHelloMessage_t *)zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID]->messageData;\n\t\t\t\t/* Check H3 = SHA256(H2) */\n\t\t\t\tbctoolbox_sha256(messageData->H2, 32, 32, checkH3);\n\t\t\t\tif (memcmp(checkH3, peerHelloMessageData->H3, 32) != 0) {\n\t\t\t\t\tfree (messageData);\n\t\t\t\t\treturn BZRTP_PARSER_ERROR_UNMATCHINGHASHCHAIN;\n\t\t\t\t}\n\t\t\t\t/* Check the hello MAC message. \n\t\t\t\t * MAC is 8 bytes long and is computed on the message(skip the ZRTP_PACKET_HEADER) and exclude the mac itself (-8 bytes from message Length) */\n\t\t\t\tbctoolbox_hmacSha256(messageData->H2, 32, zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID]->packetString+ZRTP_PACKET_HEADER_LENGTH, zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID]->messageLength-8, 8, checkMAC);\n\t\t\t\tif (memcmp(checkMAC, peerHelloMessageData->MAC, 8) != 0) {\n\t\t\t\t\tfree (messageData);\n\t\t\t\t\treturn BZRTP_PARSER_ERROR_UNMATCHINGMAC;\n\t\t\t\t}\n\n\t\t\t\tmemcpy(messageData->ZID, messageContent, 12);\n\t\t\t\tmessageContent +=12;\n\t\t\t\tmessageData->hashAlgo = cryptoAlgoTypeStringToInt(messageContent, ZRTP_HASH_TYPE);\n\t\t\t\tmessageContent += 4;\n\t\t\t\tmessageData->cipherAlgo = cryptoAlgoTypeStringToInt(messageContent, ZRTP_CIPHERBLOCK_TYPE);\n\t\t\t\tmessageContent += 4;\n\t\t\t\tmessageData->authTagAlgo = cryptoAlgoTypeStringToInt(messageContent, ZRTP_AUTHTAG_TYPE);\n\t\t\t\tmessageContent += 4;\n\t\t\t\tmessageData->keyAgreementAlgo = cryptoAlgoTypeStringToInt(messageContent, ZRTP_KEYAGREEMENT_TYPE);\n\t\t\t\tmessageContent += 4;\n\t\t\t\t/* commit message length depends on the key agreement type choosen (and set in the zrtpContext->keyAgreementAlgo) */\n\t\t\t\tswitch(messageData->keyAgreementAlgo) {\n\t\t\t\t\tcase ZRTP_KEYAGREEMENT_DH2k :\n\t\t\t\t\tcase ZRTP_KEYAGREEMENT_EC25 :\n\t\t\t\t\tcase ZRTP_KEYAGREEMENT_DH3k :\n\t\t\t\t\tcase ZRTP_KEYAGREEMENT_EC38 :\n\t\t\t\t\tcase ZRTP_KEYAGREEMENT_EC52 :\n\t\t\t\t\t\tvariableLength = 32; /* hvi is 32 bytes length in DH Commit message format */\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ZRTP_KEYAGREEMENT_Prsh :\n\t\t\t\t\t\tvariableLength = 24; /* nonce (16 bytes) and keyID(8 bytes) are 24 bytes length in preshared Commit message format */\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase ZRTP_KEYAGREEMENT_Mult :\n\t\t\t\t\t\tvariableLength = 16; /* nonce is 24 bytes length in multistream Commit message format */\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tfree(messageData);\n\t\t\t\t\t\treturn BZRTP_PARSER_ERROR_INVALIDMESSAGE;\n\t\t\t\t}\n\n\t\t\t\tif (zrtpPacket->messageLength != ZRTP_COMMITMESSAGE_FIXED_LENGTH + variableLength) {\n\t\t\t\t\tfree(messageData);\n\t\t\t\t\treturn BZRTP_PARSER_ERROR_INVALIDMESSAGE;\n\t\t\t\t}\n\t\t\t\tmessageData->sasAlgo = cryptoAlgoTypeStringToInt(messageContent, ZRTP_SAS_TYPE);\n\t\t\t\tmessageContent += 4;\n\n\t\t\t\t/* if it is a multistream or preshared commit, get the 16 bytes nonce */\n\t\t\t\tif ((messageData->keyAgreementAlgo == ZRTP_KEYAGREEMENT_Prsh) || (messageData->keyAgreementAlgo == ZRTP_KEYAGREEMENT_Mult)) {\n\t\t\t\t\tmemcpy(messageData->nonce, messageContent, 16);\n\t\t\t\t\tmessageContent +=16;\n\n\t\t\t\t\t/* and the keyID for preshared commit only */\n\t\t\t\t\tif (messageData->keyAgreementAlgo == ZRTP_KEYAGREEMENT_Prsh) {\n\t\t\t\t\t\tmemcpy(messageData->keyID, messageContent, 8);\n\t\t\t\t\t\tmessageContent +=8;\n\t\t\t\t\t}\n\t\t\t\t} else { /* it's a DH commit message, get the hvi */\n\t\t\t\t\tmemcpy(messageData->hvi, messageContent, 32);\n\t\t\t\t\tmessageContent +=32;\n\t\t\t\t}\n\n\t\t\t\t/* get the MAC and attach the message data to the packet structure */\n\t\t\t\tmemcpy(messageData->MAC, messageContent, 8);\n\t\t\t\tzrtpPacket->messageData = (void *)messageData;\n\n\t\t\t\t/* the parsed commit packet must be saved as it is used to generate the total_hash */\n\t\t\t\tzrtpPacket->packetString = (uint8_t *)malloc(inputLength*sizeof(uint8_t));\n\t\t\t\tmemcpy(zrtpPacket->packetString, input, inputLength); /* store the whole packet even if we may use the message only */\n\t\t\t}\n\t\t\tbreak; /* MSGTYPE_COMMIT */\n\t\tcase MSGTYPE_DHPART1 :\n\t\tcase MSGTYPE_DHPART2 :\n\t\t\t{\n\t\t\t\tbzrtpDHPartMessage_t *messageData;\n\n\t\t\t\t/*check message length, depends on the selected key agreement algo set in zrtpContext */\n\t\t\t\tuint16_t pvLength = computeKeyAgreementPrivateValueLength(zrtpChannelContext->keyAgreementAlgo);\n\t\t\t\tif (pvLength == 0) {\n\t\t\t\t\treturn BZRTP_PARSER_ERROR_INVALIDCONTEXT;\n\t\t\t\t}\n\n\t\t\t\tif (zrtpPacket->messageLength != ZRTP_DHPARTMESSAGE_FIXED_LENGTH+pvLength) {\n\t\t\t\t\treturn BZRTP_PARSER_ERROR_INVALIDMESSAGE;\n\t\t\t\t}\n\n\t\t\t\t/* allocate a DHPart message structure and pv */\n\t\t\t\tmessageData = (bzrtpDHPartMessage_t *)malloc(sizeof(bzrtpDHPartMessage_t));\n\t\t\t\tmessageData->pv = (uint8_t *)malloc(pvLength*sizeof(uint8_t));\n\n\t\t\t\t/* fill the structure */\n\t\t\t\tmemcpy(messageData->H1, messageContent, 32);\n\t\t\t\tmessageContent +=32;\n\n\t\t\t\t/* We have now H1, check it matches the H2 we had in the commit message H2=SHA256(H1) and that the Commit message MAC is correct */\n\t\t\t\tif ( zrtpChannelContext->role == RESPONDER) { /* do it only if we are responder (we received a commit packet) */\n\t\t\t\t\tuint8_t checkH2[32];\n\t\t\t\t\tuint8_t checkMAC[32];\n\t\t\t\t\tbzrtpCommitMessage_t *peerCommitMessageData;\n\n\t\t\t\t\tif (zrtpChannelContext->peerPackets[COMMIT_MESSAGE_STORE_ID] == NULL) {\n\t\t\t\t\t\tfree (messageData);\n\t\t\t\t\t\t/* we have no Commit message in this channel, this DHPart2 shall never have arrived, discard it as invalid */\n\t\t\t\t\t\treturn BZRTP_PARSER_ERROR_UNEXPECTEDMESSAGE;\n\t\t\t\t\t}\n\t\t\t\t\tpeerCommitMessageData = (bzrtpCommitMessage_t *)zrtpChannelContext->peerPackets[COMMIT_MESSAGE_STORE_ID]->messageData;\n\t\t\t\t\t/* Check H2 = SHA256(H1) */\n\t\t\t\t\tbctoolbox_sha256(messageData->H1, 32, 32, checkH2);\n\t\t\t\t\tif (memcmp(checkH2, peerCommitMessageData->H2, 32) != 0) {\n\t\t\t\t\t\tfree (messageData);\n\t\t\t\t\t\treturn BZRTP_PARSER_ERROR_UNMATCHINGHASHCHAIN;\n\t\t\t\t\t}\n\t\t\t\t\t/* Check the Commit MAC message. \n\t\t\t\t\t * MAC is 8 bytes long and is computed on the message(skip the ZRTP_PACKET_HEADER) and exclude the mac itself (-8 bytes from message Length) */\n\t\t\t\t\tbctoolbox_hmacSha256(messageData->H1, 32, zrtpChannelContext->peerPackets[COMMIT_MESSAGE_STORE_ID]->packetString+ZRTP_PACKET_HEADER_LENGTH, zrtpChannelContext->peerPackets[COMMIT_MESSAGE_STORE_ID]->messageLength-8, 8, checkMAC);\n\t\t\t\t\tif (memcmp(checkMAC, peerCommitMessageData->MAC, 8) != 0) {\n\t\t\t\t\t\tfree (messageData);\n\t\t\t\t\t\treturn BZRTP_PARSER_ERROR_UNMATCHINGMAC;\n\t\t\t\t\t}\n\n\t\t\t\t\t/* Check the hvi received in the commit message  - RFC section 4.4.1.1*/\n\t\t\t\t\t/* First compute the expected hvi */\n\t\t\t\t\t/* hvi = hash(initiator's DHPart2 message(current zrtpPacket)) || responder's Hello message) using the agreed hash function truncated to 256 bits */\n\t\t\t\t\t/* create a string with the messages concatenated */\n\t\t\t\t\t{\n\t\t\t\t\t\tuint8_t computedHvi[32];\n\t\t\t\t\t\tuint16_t HelloMessageLength = zrtpChannelContext->selfPackets[HELLO_MESSAGE_STORE_ID]->messageLength;\n\t\t\t\t\t\tuint16_t DHPartHelloMessageStringLength = zrtpPacket->messageLength + HelloMessageLength;\n\n\t\t\t\t\t\tuint8_t *DHPartHelloMessageString = (uint8_t *)malloc(DHPartHelloMessageStringLength*sizeof(uint8_t));\n\n\t\t\t\t\t\tmemcpy(DHPartHelloMessageString, input+ZRTP_PACKET_HEADER_LENGTH, zrtpPacket->messageLength);\n\t\t\t\t\t\tmemcpy(DHPartHelloMessageString+zrtpPacket->messageLength, zrtpChannelContext->selfPackets[HELLO_MESSAGE_STORE_ID]->packetString+ZRTP_PACKET_HEADER_LENGTH, HelloMessageLength);\n\n\t\t\t\t\t\tzrtpChannelContext->hashFunction(DHPartHelloMessageString, DHPartHelloMessageStringLength, 32, computedHvi);\n\n\t\t\t\t\t\tfree(DHPartHelloMessageString);\n\n\t\t\t\t\t\t/* Compare computed and received hvi */\n\t\t\t\t\t\tif (memcmp(computedHvi, peerCommitMessageData->hvi, 32)!=0) {\n\t\t\t\t\t\t\tfree (messageData);\n\t\t\t\t\t\t\treturn BZRTP_PARSER_ERROR_UNMATCHINGHVI;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t} else { /* if we are initiator(we didn't received any commit message and then no H2), we must check that H3=SHA256(SHA256(H1)) and the Hello message MAC */\n\t\t\t\t\tuint8_t checkH2[32];\n\t\t\t\t\tuint8_t checkH3[32];\n\t\t\t\t\tuint8_t checkMAC[32];\n\t\t\t\t\tbzrtpHelloMessage_t *peerHelloMessageData;\n\n\t\t\t\t\tif (zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID] == NULL) {\n\t\t\t\t\t\tfree (messageData);\n\t\t\t\t\t\t/* we have no Hello message in this channel, this DHPart1 shall never have arrived, discard it as invalid */\n\t\t\t\t\t\treturn BZRTP_PARSER_ERROR_UNEXPECTEDMESSAGE;\n\t\t\t\t\t}\n\t\t\t\t\tpeerHelloMessageData = (bzrtpHelloMessage_t *)zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID]->messageData;\n\t\t\t\t\t/* Check H3 = SHA256(SHA256(H1)) */\n\t\t\t\t\tbctoolbox_sha256(messageData->H1, 32, 32, checkH2);\n\t\t\t\t\tbctoolbox_sha256(checkH2, 32, 32, checkH3);\n\t\t\t\t\tif (memcmp(checkH3, peerHelloMessageData->H3, 32) != 0) {\n\t\t\t\t\t\tfree (messageData);\n\t\t\t\t\t\treturn BZRTP_PARSER_ERROR_UNMATCHINGHASHCHAIN;\n\t\t\t\t\t}\n\t\t\t\t\t/* Check the hello MAC message. \n\t\t\t\t\t * MAC is 8 bytes long and is computed on the message(skip the ZRTP_PACKET_HEADER) and exclude the mac itself (-8 bytes from message Length) */\n\t\t\t\t\tbctoolbox_hmacSha256(checkH2, 32, zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID]->packetString+ZRTP_PACKET_HEADER_LENGTH, zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID]->messageLength-8, 8, checkMAC);\n\t\t\t\t\tif (memcmp(checkMAC, peerHelloMessageData->MAC, 8) != 0) {\n\t\t\t\t\t\tfree (messageData);\n\t\t\t\t\t\treturn BZRTP_PARSER_ERROR_UNMATCHINGMAC;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tmemcpy(messageData->rs1ID, messageContent, 8);\n\t\t\t\tmessageContent +=8;\n\t\t\t\tmemcpy(messageData->rs2ID, messageContent, 8);\n\t\t\t\tmessageContent +=8;\n\t\t\t\tmemcpy(messageData->auxsecretID, messageContent, 8);\n\t\t\t\tmessageContent +=8;\n\t\t\t\tmemcpy(messageData->pbxsecretID, messageContent, 8);\n\t\t\t\tmessageContent +=8;\n\t\t\t\tmemcpy(messageData->pv, messageContent, pvLength);\n\t\t\t\tmessageContent +=pvLength;\n\t\t\t\tmemcpy(messageData->MAC, messageContent, 8);\n\n\t\t\t\t/* attach the message structure to the packet one */\n\t\t\t\tzrtpPacket->messageData = (void *)messageData;\n\n\t\t\t\t/* the parsed packet must be saved as it is used to generate the total_hash */\n\t\t\t\tzrtpPacket->packetString = (uint8_t *)malloc(inputLength*sizeof(uint8_t));\n\t\t\t\tmemcpy(zrtpPacket->packetString, input, inputLength); /* store the whole packet even if we may use the message only */\n\t\t\t}\n\t\t\tbreak; /* MSGTYPE_DHPART1 and MSGTYPE_DHPART2 */\n\t\tcase MSGTYPE_CONFIRM1:\n\t\tcase MSGTYPE_CONFIRM2:\n\t\t\t{\n\t\t\t\tuint8_t *confirmMessageKey = NULL;\n\t\t\t\tuint8_t *confirmMessageMacKey = NULL;\n\t\t\t\tbzrtpConfirmMessage_t *messageData;\n\t\t\t\tuint16_t cipherTextLength;\n\t\t\t\tuint8_t computedHmac[8];\n\t\t\t\tuint8_t *confirmPlainMessageBuffer;\n\t\t\t\tuint8_t *confirmPlainMessage;\n\n\t\t\t\t/* we shall first decrypt and validate the message, check we have the keys to do it */\n\t\t\t\tif (zrtpChannelContext->role == RESPONDER) { /* responder uses initiator's keys to decrypt */\n\t\t\t\t\tif ((zrtpChannelContext->zrtpkeyi == NULL) || (zrtpChannelContext->mackeyi == NULL)) {\n\t\t\t\t\t\treturn BZRTP_PARSER_ERROR_INVALIDCONTEXT;\n\t\t\t\t\t}\n\t\t\t\t\tconfirmMessageKey = zrtpChannelContext->zrtpkeyi;\n\t\t\t\t\tconfirmMessageMacKey = zrtpChannelContext->mackeyi;\n\t\t\t\t}\n\n\t\t\t\tif (zrtpChannelContext->role == INITIATOR) { /* the iniator uses responder's keys to decrypt */\n\t\t\t\t\tif ((zrtpChannelContext->zrtpkeyr == NULL) || (zrtpChannelContext->mackeyr == NULL)) {\n\t\t\t\t\t\treturn BZRTP_PARSER_ERROR_INVALIDCONTEXT;\n\t\t\t\t\t}\n\t\t\t\t\tconfirmMessageKey = zrtpChannelContext->zrtpkeyr;\n\t\t\t\t\tconfirmMessageMacKey = zrtpChannelContext->mackeyr;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t/* allocate a confirm message structure */\n\t\t\t\tmessageData = (bzrtpConfirmMessage_t *)malloc(sizeof(bzrtpConfirmMessage_t));\n\n\t\t\t\t/* get the mac and the IV */\n\t\t\t\tmemcpy(messageData->confirm_mac, messageContent, 8);\n\t\t\t\tmessageContent +=8;\n\t\t\t\tmemcpy(messageData->CFBIV, messageContent, 16);\n\t\t\t\tmessageContent +=16;\n\n\n\t\t\t\t\n\t\t\t\t/* get the cipher text length */\n\t\t\t\tcipherTextLength = zrtpPacket->messageLength - ZRTP_MESSAGE_HEADER_LENGTH - 24; /* confirm message is header, confirm_mac(8 bytes), CFB IV(16 bytes), encrypted part */\n\n\t\t\t\t/* validate the mac over the cipher text */\n\t\t\t\tzrtpChannelContext->hmacFunction(confirmMessageMacKey, zrtpChannelContext->hashLength, messageContent, cipherTextLength, 8, computedHmac);\n\t\t\t\t\n\t\t\t\tif (memcmp(computedHmac, messageData->confirm_mac, 8) != 0) { /* confirm_mac doesn't match */\n\t\t\t\t\tfree(messageData);\n\t\t\t\t\treturn BZRTP_PARSER_ERROR_UNMATCHINGCONFIRMMAC;\n\t\t\t\t}\n\n\t\t\t\t/* get plain message */\n\t\t\t\tconfirmPlainMessageBuffer = (uint8_t *)malloc(cipherTextLength*sizeof(uint8_t));\n\t\t\t\tzrtpChannelContext->cipherDecryptionFunction(confirmMessageKey, messageData->CFBIV, messageContent, cipherTextLength, confirmPlainMessageBuffer);\n\t\t\t\tconfirmPlainMessage = confirmPlainMessageBuffer; /* point into the allocated buffer */\n\n\t\t\t\t/* parse it */\n\t\t\t\tmemcpy(messageData->H0, confirmPlainMessage, 32);\n\t\t\t\tconfirmPlainMessage +=33; /* +33 because next 8 bits are unused */\n\n\t\t\t\t/* Hash chain checking: if we are in multichannel or shared mode, we had not DHPart and then no H1 */\n\t\t\t\tif (zrtpChannelContext->keyAgreementAlgo == ZRTP_KEYAGREEMENT_Prsh || zrtpChannelContext->keyAgreementAlgo == ZRTP_KEYAGREEMENT_Mult) {\n\t\t\t\t\t/* compute the H1=SHA256(H0) we never received */\n\t\t\t\t\tuint8_t checkH1[32];\n\t\t\t\t\tbctoolbox_sha256(messageData->H0, 32, 32, checkH1);\n\n\t\t\t\t\t/* if we are responder, we received a commit packet with H2 then check that H2=SHA256(H1) and that the commit message MAC keyed with H1 match */\n\t\t\t\t\tif ( zrtpChannelContext->role == RESPONDER) {\n\t\t\t\t\t\tuint8_t checkH2[32];\n\t\t\t\t\t\tuint8_t checkMAC[32];\n\t\t\t\t\t\tbzrtpCommitMessage_t *peerCommitMessageData;\n\n\t\t\t\t\t\tif (zrtpChannelContext->peerPackets[COMMIT_MESSAGE_STORE_ID] == NULL) {\n\t\t\t\t\t\t\tfree (messageData);\n\t\t\t\t\t\t\t/* we have no Commit message in this channel, this Confirm2 shall never have arrived, discard it as invalid */\n\t\t\t\t\t\t\treturn BZRTP_PARSER_ERROR_UNEXPECTEDMESSAGE;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpeerCommitMessageData = (bzrtpCommitMessage_t *)zrtpChannelContext->peerPackets[COMMIT_MESSAGE_STORE_ID]->messageData;\n\t\t\t\t\t\t/* Check H2 = SHA256(H1) */\n\t\t\t\t\t\tbctoolbox_sha256(checkH1, 32, 32, checkH2);\n\t\t\t\t\t\tif (memcmp(checkH2, peerCommitMessageData->H2, 32) != 0) {\n\t\t\t\t\t\t\tfree (messageData);\n\t\t\t\t\t\t\treturn BZRTP_PARSER_ERROR_UNMATCHINGHASHCHAIN;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* Check the Commit MAC message. \n\t\t\t\t\t\t * MAC is 8 bytes long and is computed on the message(skip the ZRTP_PACKET_HEADER) and exclude the mac itself (-8 bytes from message Length) */\n\t\t\t\t\t\tbctoolbox_hmacSha256(checkH1, 32, zrtpChannelContext->peerPackets[COMMIT_MESSAGE_STORE_ID]->packetString+ZRTP_PACKET_HEADER_LENGTH, zrtpChannelContext->peerPackets[COMMIT_MESSAGE_STORE_ID]->messageLength-8, 8, checkMAC);\n\t\t\t\t\t\tif (memcmp(checkMAC, peerCommitMessageData->MAC, 8) != 0) {\n\t\t\t\t\t\t\tfree (messageData);\n\t\t\t\t\t\t\treturn BZRTP_PARSER_ERROR_UNMATCHINGMAC;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else { /* if we are initiator(we didn't received any commit message and then no H2), we must check that H3=SHA256(SHA256(H1)) and the Hello message MAC */\n\t\t\t\t\t\tuint8_t checkH2[32];\n\t\t\t\t\t\tuint8_t checkH3[32];\n\t\t\t\t\t\tuint8_t checkMAC[32];\n\t\t\t\t\t\tbzrtpHelloMessage_t *peerHelloMessageData;\n\n\t\t\t\t\t\tif (zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID] == NULL) {\n\t\t\t\t\t\t\tfree (messageData);\n\t\t\t\t\t\t\t/* we have no Hello message in this channel, this Confirm1 shall never have arrived, discard it as invalid */\n\t\t\t\t\t\t\treturn BZRTP_PARSER_ERROR_UNEXPECTEDMESSAGE;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpeerHelloMessageData = (bzrtpHelloMessage_t *)zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID]->messageData;\n\t\t\t\t\t\t/* Check H3 = SHA256(SHA256(H1)) */\n\t\t\t\t\t\tbctoolbox_sha256(checkH1, 32, 32, checkH2);\n\t\t\t\t\t\tbctoolbox_sha256(checkH2, 32, 32, checkH3);\n\t\t\t\t\t\tif (memcmp(checkH3, peerHelloMessageData->H3, 32) != 0) {\n\t\t\t\t\t\t\tfree (messageData);\n\t\t\t\t\t\t\treturn BZRTP_PARSER_ERROR_UNMATCHINGHASHCHAIN;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t/* Check the hello MAC message. \n\t\t\t\t\t\t * MAC is 8 bytes long and is computed on the message(skip the ZRTP_PACKET_HEADER) and exclude the mac itself (-8 bytes from message Length) */\n\t\t\t\t\t\tbctoolbox_hmacSha256(checkH2, 32, zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID]->packetString+ZRTP_PACKET_HEADER_LENGTH, zrtpChannelContext->peerPackets[HELLO_MESSAGE_STORE_ID]->messageLength-8, 8, checkMAC);\n\t\t\t\t\t\tif (memcmp(checkMAC, peerHelloMessageData->MAC, 8) != 0) {\n\t\t\t\t\t\t\tfree (messageData);\n\t\t\t\t\t\t\treturn BZRTP_PARSER_ERROR_UNMATCHINGMAC;\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t}\n\t\t\t\t} else { /* we are in DHM mode */\n\t\t\t\t\t/* We have now H0, check it matches the H1 we had in the DHPart message H1=SHA256(H0) and that the DHPart message MAC is correct */\n\t\t\t\t\tuint8_t checkH1[32];\n\t\t\t\t\tuint8_t checkMAC[32];\n\t\t\t\t\tbzrtpDHPartMessage_t *peerDHPartMessageData;\n\n\t\t\t\t\tif (zrtpChannelContext->peerPackets[DHPART_MESSAGE_STORE_ID] == NULL) {\n\t\t\t\t\t\tfree (messageData);\n\t\t\t\t\t\t/* we have no DHPART message in this channel, this confirm shall never have arrived, discard it as invalid */\n\t\t\t\t\t\treturn BZRTP_PARSER_ERROR_UNEXPECTEDMESSAGE;\n\t\t\t\t\t}\n\t\t\t\t\tpeerDHPartMessageData = (bzrtpDHPartMessage_t *)zrtpChannelContext->peerPackets[DHPART_MESSAGE_STORE_ID]->messageData;\n\t\t\t\t\t/* Check H1 = SHA256(H0) */\n\t\t\t\t\tbctoolbox_sha256(messageData->H0, 32, 32, checkH1);\n\t\t\t\t\tif (memcmp(checkH1, peerDHPartMessageData->H1, 32) != 0) {\n\t\t\t\t\t\tfree (messageData);\n\t\t\t\t\t\treturn BZRTP_PARSER_ERROR_UNMATCHINGHASHCHAIN;\n\t\t\t\t\t}\n\t\t\t\t\t/* Check the DHPart message. \n\t\t\t\t\t * MAC is 8 bytes long and is computed on the message(skip the ZRTP_PACKET_HEADER) and exclude the mac itself (-8 bytes from message Length) */\n\t\t\t\t\tbctoolbox_hmacSha256(messageData->H0, 32, zrtpChannelContext->peerPackets[DHPART_MESSAGE_STORE_ID]->packetString+ZRTP_PACKET_HEADER_LENGTH, zrtpChannelContext->peerPackets[DHPART_MESSAGE_STORE_ID]->messageLength-8, 8, checkMAC);\n\t\t\t\t\tif (memcmp(checkMAC, peerDHPartMessageData->MAC, 8) != 0) {\n\t\t\t\t\t\tfree (messageData);\n\t\t\t\t\t\treturn BZRTP_PARSER_ERROR_UNMATCHINGMAC;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tmessageData->sig_len = ((uint16_t)(confirmPlainMessage[0]&0x01))<<8 | (((uint16_t)confirmPlainMessage[1])&0x00FF);\n\t\t\t\tconfirmPlainMessage += 2;\n\t\t\t\tmessageData->E = ((*confirmPlainMessage)&0x08)>>3;\n\t\t\t\tmessageData->V = ((*confirmPlainMessage)&0x04)>>2;\n\t\t\t\tmessageData->A = ((*confirmPlainMessage)&0x02)>>1;\n\t\t\t\tmessageData->D = (*confirmPlainMessage)&0x01;\n\t\t\t\tconfirmPlainMessage += 1;\n\n\t\t\t\tmessageData->cacheExpirationInterval = (((uint32_t)confirmPlainMessage[0])<<24) | (((uint32_t)confirmPlainMessage[1])<<16) | (((uint32_t)confirmPlainMessage[2])<<8) | ((uint32_t)confirmPlainMessage[3]);\n\t\t\t\tconfirmPlainMessage += 4;\n\n\n\t\t\t\t/* if sig_len indicate a signature, parse it */\n\t\t\t\tif (messageData->sig_len>0) {\n\t\t\t\t\tmemcpy(messageData->signatureBlockType, confirmPlainMessage, 4);\n\t\t\t\t\tconfirmPlainMessage += 4;\n\t\t\t\t\t/* allocate memory for the signature block, sig_len is in words(32 bits) and includes the signature block type word */\n\t\t\t\t\tmessageData->signatureBlock = (uint8_t *)malloc(4*(messageData->sig_len-1)*sizeof(uint8_t));\n\t\t\t\t\tmemcpy(messageData->signatureBlock, confirmPlainMessage, 4*(messageData->sig_len-1));\n\t\t\t\t} else {\n\t\t\t\t\tmessageData->signatureBlock  = NULL;\n\t\t\t\t}\n\n\t\t\t\t/* free plain buffer */\n\t\t\t\tfree(confirmPlainMessageBuffer);\n\n\t\t\t\t/* the parsed commit packet must be saved as it is used to check correct packet repetition */\n\t\t\t\tzrtpPacket->packetString = (uint8_t *)malloc(inputLength*sizeof(uint8_t));\n\t\t\t\tmemcpy(zrtpPacket->packetString, input, inputLength); /* store the whole packet even if we may use the message only */\n\n\t\t\t\t/* attach the message structure to the packet one */\n\t\t\t\tzrtpPacket->messageData = (void *)messageData;\n\t\t\t}\n\t\t\tbreak; /* MSGTYPE_CONFIRM1 and MSGTYPE_CONFIRM2 */\n\n\t\tcase MSGTYPE_CONF2ACK:\n\t\t\t/* nothing to do for this one */\n\t\t\tbreak; /* MSGTYPE_CONF2ACK */\n\t\t\n\t\tcase MSGTYPE_PING:\n\t\t\t{\n\t\t\t\t/* allocate a ping message structure */\n\t\t\t\tbzrtpPingMessage_t *messageData;\n\t\t\t\tmessageData = (bzrtpPingMessage_t *)malloc(sizeof(bzrtpPingMessage_t));\n\n\t\t\t\t/* fill the structure */\n\t\t\t\tmemcpy(messageData->version, messageContent, 4);\n\t\t\t\tmessageContent +=4;\n\t\t\t\tmemcpy(messageData->endpointHash, messageContent, 8);\n\n\t\t\t\t/* attach the message structure to the packet one */\n\t\t\t\tzrtpPacket->messageData = (void *)messageData;\n\t\t\t}\n\t\t\tbreak; /* MSGTYPE_PING */\n\n\t}\n\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -236,6 +236,32 @@\n \t\t\t\t\t\tfree (messageData);\n \t\t\t\t\t\treturn BZRTP_PARSER_ERROR_UNMATCHINGMAC;\n \t\t\t\t\t}\n+\n+\t\t\t\t\t/* Check the hvi received in the commit message  - RFC section 4.4.1.1*/\n+\t\t\t\t\t/* First compute the expected hvi */\n+\t\t\t\t\t/* hvi = hash(initiator's DHPart2 message(current zrtpPacket)) || responder's Hello message) using the agreed hash function truncated to 256 bits */\n+\t\t\t\t\t/* create a string with the messages concatenated */\n+\t\t\t\t\t{\n+\t\t\t\t\t\tuint8_t computedHvi[32];\n+\t\t\t\t\t\tuint16_t HelloMessageLength = zrtpChannelContext->selfPackets[HELLO_MESSAGE_STORE_ID]->messageLength;\n+\t\t\t\t\t\tuint16_t DHPartHelloMessageStringLength = zrtpPacket->messageLength + HelloMessageLength;\n+\n+\t\t\t\t\t\tuint8_t *DHPartHelloMessageString = (uint8_t *)malloc(DHPartHelloMessageStringLength*sizeof(uint8_t));\n+\n+\t\t\t\t\t\tmemcpy(DHPartHelloMessageString, input+ZRTP_PACKET_HEADER_LENGTH, zrtpPacket->messageLength);\n+\t\t\t\t\t\tmemcpy(DHPartHelloMessageString+zrtpPacket->messageLength, zrtpChannelContext->selfPackets[HELLO_MESSAGE_STORE_ID]->packetString+ZRTP_PACKET_HEADER_LENGTH, HelloMessageLength);\n+\n+\t\t\t\t\t\tzrtpChannelContext->hashFunction(DHPartHelloMessageString, DHPartHelloMessageStringLength, 32, computedHvi);\n+\n+\t\t\t\t\t\tfree(DHPartHelloMessageString);\n+\n+\t\t\t\t\t\t/* Compare computed and received hvi */\n+\t\t\t\t\t\tif (memcmp(computedHvi, peerCommitMessageData->hvi, 32)!=0) {\n+\t\t\t\t\t\t\tfree (messageData);\n+\t\t\t\t\t\t\treturn BZRTP_PARSER_ERROR_UNMATCHINGHVI;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\n \t\t\t\t} else { /* if we are initiator(we didn't received any commit message and then no H2), we must check that H3=SHA256(SHA256(H1)) and the Hello message MAC */\n \t\t\t\t\tuint8_t checkH2[32];\n \t\t\t\t\tuint8_t checkH3[32];\n@@ -280,7 +306,7 @@\n \t\t\t\t/* attach the message structure to the packet one */\n \t\t\t\tzrtpPacket->messageData = (void *)messageData;\n \n-\t\t\t\t/* the parsed commit packet must be saved as it is used to generate the total_hash */\n+\t\t\t\t/* the parsed packet must be saved as it is used to generate the total_hash */\n \t\t\t\tzrtpPacket->packetString = (uint8_t *)malloc(inputLength*sizeof(uint8_t));\n \t\t\t\tmemcpy(zrtpPacket->packetString, input, inputLength); /* store the whole packet even if we may use the message only */\n \t\t\t}",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\t\t/* the parsed commit packet must be saved as it is used to generate the total_hash */"
            ],
            "added_lines": [
                "",
                "\t\t\t\t\t/* Check the hvi received in the commit message  - RFC section 4.4.1.1*/",
                "\t\t\t\t\t/* First compute the expected hvi */",
                "\t\t\t\t\t/* hvi = hash(initiator's DHPart2 message(current zrtpPacket)) || responder's Hello message) using the agreed hash function truncated to 256 bits */",
                "\t\t\t\t\t/* create a string with the messages concatenated */",
                "\t\t\t\t\t{",
                "\t\t\t\t\t\tuint8_t computedHvi[32];",
                "\t\t\t\t\t\tuint16_t HelloMessageLength = zrtpChannelContext->selfPackets[HELLO_MESSAGE_STORE_ID]->messageLength;",
                "\t\t\t\t\t\tuint16_t DHPartHelloMessageStringLength = zrtpPacket->messageLength + HelloMessageLength;",
                "",
                "\t\t\t\t\t\tuint8_t *DHPartHelloMessageString = (uint8_t *)malloc(DHPartHelloMessageStringLength*sizeof(uint8_t));",
                "",
                "\t\t\t\t\t\tmemcpy(DHPartHelloMessageString, input+ZRTP_PACKET_HEADER_LENGTH, zrtpPacket->messageLength);",
                "\t\t\t\t\t\tmemcpy(DHPartHelloMessageString+zrtpPacket->messageLength, zrtpChannelContext->selfPackets[HELLO_MESSAGE_STORE_ID]->packetString+ZRTP_PACKET_HEADER_LENGTH, HelloMessageLength);",
                "",
                "\t\t\t\t\t\tzrtpChannelContext->hashFunction(DHPartHelloMessageString, DHPartHelloMessageStringLength, 32, computedHvi);",
                "",
                "\t\t\t\t\t\tfree(DHPartHelloMessageString);",
                "",
                "\t\t\t\t\t\t/* Compare computed and received hvi */",
                "\t\t\t\t\t\tif (memcmp(computedHvi, peerCommitMessageData->hvi, 32)!=0) {",
                "\t\t\t\t\t\t\tfree (messageData);",
                "\t\t\t\t\t\t\treturn BZRTP_PARSER_ERROR_UNMATCHINGHVI;",
                "\t\t\t\t\t\t}",
                "\t\t\t\t\t}",
                "",
                "\t\t\t\t/* the parsed packet must be saved as it is used to generate the total_hash */"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-2925",
        "func_name": "torvalds/linux/prepend_path",
        "description": "The prepend_path function in fs/dcache.c in the Linux kernel before 4.2.4 does not properly handle rename actions inside a bind mount, which allows local users to bypass an intended container protection mechanism by renaming a directory, related to a \"double-chroot attack.\"",
        "git_url": "https://github.com/torvalds/linux/commit/cde93be45a8a90d8c264c776fab63487b5038a65",
        "commit_title": "dcache: Handle escaped paths in prepend_path",
        "commit_text": " A rename can result in a dentry that by walking up d_parent will never reach it's mnt_root.  For lack of a better term I call this an escaped path.  prepend_path is called by four different functions __d_path, d_absolute_path, d_path, and getcwd.  __d_path only wants to see paths are connected to the root it passes in.  So __d_path needs prepend_path to return an error.  d_absolute_path similarly wants to see paths that are connected to some root.  Escaped paths are not connected to any mnt_root so d_absolute_path needs prepend_path to return an error greater than 1.  So escaped paths will be treated like paths on lazily unmounted mounts.  getcwd needs to prepend \"(unreachable)\" so getcwd also needs prepend_path to return an error.  d_path is the interesting hold out.  d_path just wants to print something, and does not care about the weird cases.  Which raises the question what should be printed?  Given that <escaped_path>/<anything> should result in -ENOENT I believe it is desirable for escaped paths to be printed as empty paths.  As there are not really any meaninful path components when considered from the perspective of a mount tree.  So tweak prepend_path to return an empty path with an new error code of 3 when it encounters an escaped path. ",
        "func_before": "static int prepend_path(const struct path *path,\n\t\t\tconst struct path *root,\n\t\t\tchar **buffer, int *buflen)\n{\n\tstruct dentry *dentry;\n\tstruct vfsmount *vfsmnt;\n\tstruct mount *mnt;\n\tint error = 0;\n\tunsigned seq, m_seq = 0;\n\tchar *bptr;\n\tint blen;\n\n\trcu_read_lock();\nrestart_mnt:\n\tread_seqbegin_or_lock(&mount_lock, &m_seq);\n\tseq = 0;\n\trcu_read_lock();\nrestart:\n\tbptr = *buffer;\n\tblen = *buflen;\n\terror = 0;\n\tdentry = path->dentry;\n\tvfsmnt = path->mnt;\n\tmnt = real_mount(vfsmnt);\n\tread_seqbegin_or_lock(&rename_lock, &seq);\n\twhile (dentry != root->dentry || vfsmnt != root->mnt) {\n\t\tstruct dentry * parent;\n\n\t\tif (dentry == vfsmnt->mnt_root || IS_ROOT(dentry)) {\n\t\t\tstruct mount *parent = ACCESS_ONCE(mnt->mnt_parent);\n\t\t\t/* Global root? */\n\t\t\tif (mnt != parent) {\n\t\t\t\tdentry = ACCESS_ONCE(mnt->mnt_mountpoint);\n\t\t\t\tmnt = parent;\n\t\t\t\tvfsmnt = &mnt->mnt;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!error)\n\t\t\t\terror = is_mounted(vfsmnt) ? 1 : 2;\n\t\t\tbreak;\n\t\t}\n\t\tparent = dentry->d_parent;\n\t\tprefetch(parent);\n\t\terror = prepend_name(&bptr, &blen, &dentry->d_name);\n\t\tif (error)\n\t\t\tbreak;\n\n\t\tdentry = parent;\n\t}\n\tif (!(seq & 1))\n\t\trcu_read_unlock();\n\tif (need_seqretry(&rename_lock, seq)) {\n\t\tseq = 1;\n\t\tgoto restart;\n\t}\n\tdone_seqretry(&rename_lock, seq);\n\n\tif (!(m_seq & 1))\n\t\trcu_read_unlock();\n\tif (need_seqretry(&mount_lock, m_seq)) {\n\t\tm_seq = 1;\n\t\tgoto restart_mnt;\n\t}\n\tdone_seqretry(&mount_lock, m_seq);\n\n\tif (error >= 0 && bptr == *buffer) {\n\t\tif (--blen < 0)\n\t\t\terror = -ENAMETOOLONG;\n\t\telse\n\t\t\t*--bptr = '/';\n\t}\n\t*buffer = bptr;\n\t*buflen = blen;\n\treturn error;\n}",
        "func": "static int prepend_path(const struct path *path,\n\t\t\tconst struct path *root,\n\t\t\tchar **buffer, int *buflen)\n{\n\tstruct dentry *dentry;\n\tstruct vfsmount *vfsmnt;\n\tstruct mount *mnt;\n\tint error = 0;\n\tunsigned seq, m_seq = 0;\n\tchar *bptr;\n\tint blen;\n\n\trcu_read_lock();\nrestart_mnt:\n\tread_seqbegin_or_lock(&mount_lock, &m_seq);\n\tseq = 0;\n\trcu_read_lock();\nrestart:\n\tbptr = *buffer;\n\tblen = *buflen;\n\terror = 0;\n\tdentry = path->dentry;\n\tvfsmnt = path->mnt;\n\tmnt = real_mount(vfsmnt);\n\tread_seqbegin_or_lock(&rename_lock, &seq);\n\twhile (dentry != root->dentry || vfsmnt != root->mnt) {\n\t\tstruct dentry * parent;\n\n\t\tif (dentry == vfsmnt->mnt_root || IS_ROOT(dentry)) {\n\t\t\tstruct mount *parent = ACCESS_ONCE(mnt->mnt_parent);\n\t\t\t/* Escaped? */\n\t\t\tif (dentry != vfsmnt->mnt_root) {\n\t\t\t\tbptr = *buffer;\n\t\t\t\tblen = *buflen;\n\t\t\t\terror = 3;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* Global root? */\n\t\t\tif (mnt != parent) {\n\t\t\t\tdentry = ACCESS_ONCE(mnt->mnt_mountpoint);\n\t\t\t\tmnt = parent;\n\t\t\t\tvfsmnt = &mnt->mnt;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (!error)\n\t\t\t\terror = is_mounted(vfsmnt) ? 1 : 2;\n\t\t\tbreak;\n\t\t}\n\t\tparent = dentry->d_parent;\n\t\tprefetch(parent);\n\t\terror = prepend_name(&bptr, &blen, &dentry->d_name);\n\t\tif (error)\n\t\t\tbreak;\n\n\t\tdentry = parent;\n\t}\n\tif (!(seq & 1))\n\t\trcu_read_unlock();\n\tif (need_seqretry(&rename_lock, seq)) {\n\t\tseq = 1;\n\t\tgoto restart;\n\t}\n\tdone_seqretry(&rename_lock, seq);\n\n\tif (!(m_seq & 1))\n\t\trcu_read_unlock();\n\tif (need_seqretry(&mount_lock, m_seq)) {\n\t\tm_seq = 1;\n\t\tgoto restart_mnt;\n\t}\n\tdone_seqretry(&mount_lock, m_seq);\n\n\tif (error >= 0 && bptr == *buffer) {\n\t\tif (--blen < 0)\n\t\t\terror = -ENAMETOOLONG;\n\t\telse\n\t\t\t*--bptr = '/';\n\t}\n\t*buffer = bptr;\n\t*buflen = blen;\n\treturn error;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -28,6 +28,13 @@\n \n \t\tif (dentry == vfsmnt->mnt_root || IS_ROOT(dentry)) {\n \t\t\tstruct mount *parent = ACCESS_ONCE(mnt->mnt_parent);\n+\t\t\t/* Escaped? */\n+\t\t\tif (dentry != vfsmnt->mnt_root) {\n+\t\t\t\tbptr = *buffer;\n+\t\t\t\tblen = *buflen;\n+\t\t\t\terror = 3;\n+\t\t\t\tbreak;\n+\t\t\t}\n \t\t\t/* Global root? */\n \t\t\tif (mnt != parent) {\n \t\t\t\tdentry = ACCESS_ONCE(mnt->mnt_mountpoint);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\t\t/* Escaped? */",
                "\t\t\tif (dentry != vfsmnt->mnt_root) {",
                "\t\t\t\tbptr = *buffer;",
                "\t\t\t\tblen = *buflen;",
                "\t\t\t\terror = 3;",
                "\t\t\t\tbreak;",
                "\t\t\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-2925",
        "func_name": "torvalds/linux/handle_dots",
        "description": "The prepend_path function in fs/dcache.c in the Linux kernel before 4.2.4 does not properly handle rename actions inside a bind mount, which allows local users to bypass an intended container protection mechanism by renaming a directory, related to a \"double-chroot attack.\"",
        "git_url": "https://github.com/torvalds/linux/commit/397d425dc26da728396e66d392d5dcb8dac30c37",
        "commit_title": "vfs: Test for and handle paths that are unreachable from their mnt_root",
        "commit_text": " In rare cases a directory can be renamed out from under a bind mount. In those cases without special handling it becomes possible to walk up the directory tree to the root dentry of the filesystem and down from the root dentry to every other file or directory on the filesystem.  Like division by zero .. from an unconnected path can not be given a useful semantic as there is no predicting at which path component the code will realize it is unconnected.  We certainly can not match the current behavior as the current behavior is a security hole.  Therefore when encounting .. when following an unconnected path return -ENOENT.  - Add a function path_connected to verify path->dentry is reachable   from path->mnt.mnt_root.  AKA to validate that rename did not do   something nasty to the bind mount.    To avoid races path_connected must be called after following a path   component to it's next path component. ",
        "func_before": "static inline int handle_dots(struct nameidata *nd, int type)\n{\n\tif (type == LAST_DOTDOT) {\n\t\tif (nd->flags & LOOKUP_RCU) {\n\t\t\treturn follow_dotdot_rcu(nd);\n\t\t} else\n\t\t\tfollow_dotdot(nd);\n\t}\n\treturn 0;\n}",
        "func": "static inline int handle_dots(struct nameidata *nd, int type)\n{\n\tif (type == LAST_DOTDOT) {\n\t\tif (nd->flags & LOOKUP_RCU) {\n\t\t\treturn follow_dotdot_rcu(nd);\n\t\t} else\n\t\t\treturn follow_dotdot(nd);\n\t}\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,7 +4,7 @@\n \t\tif (nd->flags & LOOKUP_RCU) {\n \t\t\treturn follow_dotdot_rcu(nd);\n \t\t} else\n-\t\t\tfollow_dotdot(nd);\n+\t\t\treturn follow_dotdot(nd);\n \t}\n \treturn 0;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\tfollow_dotdot(nd);"
            ],
            "added_lines": [
                "\t\t\treturn follow_dotdot(nd);"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-2925",
        "func_name": "torvalds/linux/follow_dotdot_rcu",
        "description": "The prepend_path function in fs/dcache.c in the Linux kernel before 4.2.4 does not properly handle rename actions inside a bind mount, which allows local users to bypass an intended container protection mechanism by renaming a directory, related to a \"double-chroot attack.\"",
        "git_url": "https://github.com/torvalds/linux/commit/397d425dc26da728396e66d392d5dcb8dac30c37",
        "commit_title": "vfs: Test for and handle paths that are unreachable from their mnt_root",
        "commit_text": " In rare cases a directory can be renamed out from under a bind mount. In those cases without special handling it becomes possible to walk up the directory tree to the root dentry of the filesystem and down from the root dentry to every other file or directory on the filesystem.  Like division by zero .. from an unconnected path can not be given a useful semantic as there is no predicting at which path component the code will realize it is unconnected.  We certainly can not match the current behavior as the current behavior is a security hole.  Therefore when encounting .. when following an unconnected path return -ENOENT.  - Add a function path_connected to verify path->dentry is reachable   from path->mnt.mnt_root.  AKA to validate that rename did not do   something nasty to the bind mount.    To avoid races path_connected must be called after following a path   component to it's next path component. ",
        "func_before": "static int follow_dotdot_rcu(struct nameidata *nd)\n{\n\tstruct inode *inode = nd->inode;\n\tif (!nd->root.mnt)\n\t\tset_root_rcu(nd);\n\n\twhile (1) {\n\t\tif (path_equal(&nd->path, &nd->root))\n\t\t\tbreak;\n\t\tif (nd->path.dentry != nd->path.mnt->mnt_root) {\n\t\t\tstruct dentry *old = nd->path.dentry;\n\t\t\tstruct dentry *parent = old->d_parent;\n\t\t\tunsigned seq;\n\n\t\t\tinode = parent->d_inode;\n\t\t\tseq = read_seqcount_begin(&parent->d_seq);\n\t\t\tif (unlikely(read_seqcount_retry(&old->d_seq, nd->seq)))\n\t\t\t\treturn -ECHILD;\n\t\t\tnd->path.dentry = parent;\n\t\t\tnd->seq = seq;\n\t\t\tbreak;\n\t\t} else {\n\t\t\tstruct mount *mnt = real_mount(nd->path.mnt);\n\t\t\tstruct mount *mparent = mnt->mnt_parent;\n\t\t\tstruct dentry *mountpoint = mnt->mnt_mountpoint;\n\t\t\tstruct inode *inode2 = mountpoint->d_inode;\n\t\t\tunsigned seq = read_seqcount_begin(&mountpoint->d_seq);\n\t\t\tif (unlikely(read_seqretry(&mount_lock, nd->m_seq)))\n\t\t\t\treturn -ECHILD;\n\t\t\tif (&mparent->mnt == nd->path.mnt)\n\t\t\t\tbreak;\n\t\t\t/* we know that mountpoint was pinned */\n\t\t\tnd->path.dentry = mountpoint;\n\t\t\tnd->path.mnt = &mparent->mnt;\n\t\t\tinode = inode2;\n\t\t\tnd->seq = seq;\n\t\t}\n\t}\n\twhile (unlikely(d_mountpoint(nd->path.dentry))) {\n\t\tstruct mount *mounted;\n\t\tmounted = __lookup_mnt(nd->path.mnt, nd->path.dentry);\n\t\tif (unlikely(read_seqretry(&mount_lock, nd->m_seq)))\n\t\t\treturn -ECHILD;\n\t\tif (!mounted)\n\t\t\tbreak;\n\t\tnd->path.mnt = &mounted->mnt;\n\t\tnd->path.dentry = mounted->mnt.mnt_root;\n\t\tinode = nd->path.dentry->d_inode;\n\t\tnd->seq = read_seqcount_begin(&nd->path.dentry->d_seq);\n\t}\n\tnd->inode = inode;\n\treturn 0;\n}",
        "func": "static int follow_dotdot_rcu(struct nameidata *nd)\n{\n\tstruct inode *inode = nd->inode;\n\tif (!nd->root.mnt)\n\t\tset_root_rcu(nd);\n\n\twhile (1) {\n\t\tif (path_equal(&nd->path, &nd->root))\n\t\t\tbreak;\n\t\tif (nd->path.dentry != nd->path.mnt->mnt_root) {\n\t\t\tstruct dentry *old = nd->path.dentry;\n\t\t\tstruct dentry *parent = old->d_parent;\n\t\t\tunsigned seq;\n\n\t\t\tinode = parent->d_inode;\n\t\t\tseq = read_seqcount_begin(&parent->d_seq);\n\t\t\tif (unlikely(read_seqcount_retry(&old->d_seq, nd->seq)))\n\t\t\t\treturn -ECHILD;\n\t\t\tnd->path.dentry = parent;\n\t\t\tnd->seq = seq;\n\t\t\tif (unlikely(!path_connected(&nd->path)))\n\t\t\t\treturn -ENOENT;\n\t\t\tbreak;\n\t\t} else {\n\t\t\tstruct mount *mnt = real_mount(nd->path.mnt);\n\t\t\tstruct mount *mparent = mnt->mnt_parent;\n\t\t\tstruct dentry *mountpoint = mnt->mnt_mountpoint;\n\t\t\tstruct inode *inode2 = mountpoint->d_inode;\n\t\t\tunsigned seq = read_seqcount_begin(&mountpoint->d_seq);\n\t\t\tif (unlikely(read_seqretry(&mount_lock, nd->m_seq)))\n\t\t\t\treturn -ECHILD;\n\t\t\tif (&mparent->mnt == nd->path.mnt)\n\t\t\t\tbreak;\n\t\t\t/* we know that mountpoint was pinned */\n\t\t\tnd->path.dentry = mountpoint;\n\t\t\tnd->path.mnt = &mparent->mnt;\n\t\t\tinode = inode2;\n\t\t\tnd->seq = seq;\n\t\t}\n\t}\n\twhile (unlikely(d_mountpoint(nd->path.dentry))) {\n\t\tstruct mount *mounted;\n\t\tmounted = __lookup_mnt(nd->path.mnt, nd->path.dentry);\n\t\tif (unlikely(read_seqretry(&mount_lock, nd->m_seq)))\n\t\t\treturn -ECHILD;\n\t\tif (!mounted)\n\t\t\tbreak;\n\t\tnd->path.mnt = &mounted->mnt;\n\t\tnd->path.dentry = mounted->mnt.mnt_root;\n\t\tinode = nd->path.dentry->d_inode;\n\t\tnd->seq = read_seqcount_begin(&nd->path.dentry->d_seq);\n\t}\n\tnd->inode = inode;\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -18,6 +18,8 @@\n \t\t\t\treturn -ECHILD;\n \t\t\tnd->path.dentry = parent;\n \t\t\tnd->seq = seq;\n+\t\t\tif (unlikely(!path_connected(&nd->path)))\n+\t\t\t\treturn -ENOENT;\n \t\t\tbreak;\n \t\t} else {\n \t\t\tstruct mount *mnt = real_mount(nd->path.mnt);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\t\tif (unlikely(!path_connected(&nd->path)))",
                "\t\t\t\treturn -ENOENT;"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-2925",
        "func_name": "torvalds/linux/follow_dotdot",
        "description": "The prepend_path function in fs/dcache.c in the Linux kernel before 4.2.4 does not properly handle rename actions inside a bind mount, which allows local users to bypass an intended container protection mechanism by renaming a directory, related to a \"double-chroot attack.\"",
        "git_url": "https://github.com/torvalds/linux/commit/397d425dc26da728396e66d392d5dcb8dac30c37",
        "commit_title": "vfs: Test for and handle paths that are unreachable from their mnt_root",
        "commit_text": " In rare cases a directory can be renamed out from under a bind mount. In those cases without special handling it becomes possible to walk up the directory tree to the root dentry of the filesystem and down from the root dentry to every other file or directory on the filesystem.  Like division by zero .. from an unconnected path can not be given a useful semantic as there is no predicting at which path component the code will realize it is unconnected.  We certainly can not match the current behavior as the current behavior is a security hole.  Therefore when encounting .. when following an unconnected path return -ENOENT.  - Add a function path_connected to verify path->dentry is reachable   from path->mnt.mnt_root.  AKA to validate that rename did not do   something nasty to the bind mount.    To avoid races path_connected must be called after following a path   component to it's next path component. ",
        "func_before": "static void follow_dotdot(struct nameidata *nd)\n{\n\tif (!nd->root.mnt)\n\t\tset_root(nd);\n\n\twhile(1) {\n\t\tstruct dentry *old = nd->path.dentry;\n\n\t\tif (nd->path.dentry == nd->root.dentry &&\n\t\t    nd->path.mnt == nd->root.mnt) {\n\t\t\tbreak;\n\t\t}\n\t\tif (nd->path.dentry != nd->path.mnt->mnt_root) {\n\t\t\t/* rare case of legitimate dget_parent()... */\n\t\t\tnd->path.dentry = dget_parent(nd->path.dentry);\n\t\t\tdput(old);\n\t\t\tbreak;\n\t\t}\n\t\tif (!follow_up(&nd->path))\n\t\t\tbreak;\n\t}\n\tfollow_mount(&nd->path);\n\tnd->inode = nd->path.dentry->d_inode;\n}",
        "func": "static int follow_dotdot(struct nameidata *nd)\n{\n\tif (!nd->root.mnt)\n\t\tset_root(nd);\n\n\twhile(1) {\n\t\tstruct dentry *old = nd->path.dentry;\n\n\t\tif (nd->path.dentry == nd->root.dentry &&\n\t\t    nd->path.mnt == nd->root.mnt) {\n\t\t\tbreak;\n\t\t}\n\t\tif (nd->path.dentry != nd->path.mnt->mnt_root) {\n\t\t\t/* rare case of legitimate dget_parent()... */\n\t\t\tnd->path.dentry = dget_parent(nd->path.dentry);\n\t\t\tdput(old);\n\t\t\tif (unlikely(!path_connected(&nd->path)))\n\t\t\t\treturn -ENOENT;\n\t\t\tbreak;\n\t\t}\n\t\tif (!follow_up(&nd->path))\n\t\t\tbreak;\n\t}\n\tfollow_mount(&nd->path);\n\tnd->inode = nd->path.dentry->d_inode;\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,4 @@\n-static void follow_dotdot(struct nameidata *nd)\n+static int follow_dotdot(struct nameidata *nd)\n {\n \tif (!nd->root.mnt)\n \t\tset_root(nd);\n@@ -14,6 +14,8 @@\n \t\t\t/* rare case of legitimate dget_parent()... */\n \t\t\tnd->path.dentry = dget_parent(nd->path.dentry);\n \t\t\tdput(old);\n+\t\t\tif (unlikely(!path_connected(&nd->path)))\n+\t\t\t\treturn -ENOENT;\n \t\t\tbreak;\n \t\t}\n \t\tif (!follow_up(&nd->path))\n@@ -21,4 +23,5 @@\n \t}\n \tfollow_mount(&nd->path);\n \tnd->inode = nd->path.dentry->d_inode;\n+\treturn 0;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "static void follow_dotdot(struct nameidata *nd)"
            ],
            "added_lines": [
                "static int follow_dotdot(struct nameidata *nd)",
                "\t\t\tif (unlikely(!path_connected(&nd->path)))",
                "\t\t\t\treturn -ENOENT;",
                "\treturn 0;"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-7812",
        "func_name": "xen-project/xen/hypercall_create_continuation",
        "description": "The hypercall_create_continuation function in arch/arm/domain.c in Xen 4.4.x through 4.6.x allows local guest users to cause a denial of service (host crash) via a preemptible hypercall to the multicall interface.",
        "git_url": "https://github.com/xen-project/xen/commit/29bcf64ce8bc0b1b7aacd00c8668f255c4f0686c",
        "commit_title": "arm: Support hypercall_create_continuation for multicall",
        "commit_text": " Multicall for ARM has been supported since commit f0dbdc6 \"xen: arm: fully implement multicall interface.\". Although, if an hypercall in multicall requires preemption, it will crash the host:  (XEN) Xen BUG at domain.c:347 (XEN) ----[ Xen-4.7-unstable  arm64  debug=y  Tainted:    C ]---- [...] (XEN) Xen call trace: (XEN)    [<00000000002420cc>] hypercall_create_continuation+0x64/0x380 (PC) (XEN)    [<0000000000217274>] do_memory_op+0x1b00/0x2334 (LR) (XEN)    [<0000000000250d2c>] do_multicall_call+0x114/0x124 (XEN)    [<0000000000217ff0>] do_multicall+0x17c/0x23c (XEN)    [<000000000024f97c>] do_trap_hypercall+0x90/0x12c (XEN)    [<0000000000251ca8>] do_trap_hypervisor+0xd2c/0x1ba4 (XEN)    [<00000000002582cc>] guest_sync+0x88/0xb8 (XEN) (XEN) (XEN) **************************************** (XEN) Panic on CPU 5: (XEN) Xen BUG at domain.c:347 (XEN) **************************************** (XEN) (XEN) Manual reset required ('noreboot' specified)  Looking to the code, the support of multicall looks valid to me, as we only need to fill call.args[...]. So drop the BUG();  This is CVE-2015-7812 / XSA-145. ",
        "func_before": "unsigned long hypercall_create_continuation(\n    unsigned int op, const char *format, ...)\n{\n    struct mc_state *mcs = &current->mc_state;\n    struct cpu_user_regs *regs;\n    const char *p = format;\n    unsigned long arg, rc;\n    unsigned int i;\n    va_list args;\n\n    /* All hypercalls take at least one argument */\n    BUG_ON( !p || *p == '\\0' );\n\n    va_start(args, format);\n\n    if ( test_bit(_MCSF_in_multicall, &mcs->flags) )\n    {\n        BUG(); /* XXX multicalls not implemented yet. */\n\n        __set_bit(_MCSF_call_preempted, &mcs->flags);\n\n        for ( i = 0; *p != '\\0'; i++ )\n            mcs->call.args[i] = next_arg(p, args);\n\n        /* Return value gets written back to mcs->call.result */\n        rc = mcs->call.result;\n    }\n    else\n    {\n        regs = guest_cpu_user_regs();\n\n        /* Ensure the hypercall trap instruction is re-executed. */\n        regs->pc -= 4;  /* re-execute 'hvc #XEN_HYPERCALL_TAG' */\n\n#ifdef CONFIG_ARM_64\n        if ( !is_32bit_domain(current->domain) )\n        {\n            regs->x16 = op;\n\n            for ( i = 0; *p != '\\0'; i++ )\n            {\n                arg = next_arg(p, args);\n\n                switch ( i )\n                {\n                case 0: regs->x0 = arg; break;\n                case 1: regs->x1 = arg; break;\n                case 2: regs->x2 = arg; break;\n                case 3: regs->x3 = arg; break;\n                case 4: regs->x4 = arg; break;\n                case 5: regs->x5 = arg; break;\n                }\n            }\n\n            /* Return value gets written back to x0 */\n            rc = regs->x0;\n        }\n        else\n#endif\n        {\n            regs->r12 = op;\n\n            for ( i = 0; *p != '\\0'; i++ )\n            {\n                arg = next_arg(p, args);\n\n                switch ( i )\n                {\n                case 0: regs->r0 = arg; break;\n                case 1: regs->r1 = arg; break;\n                case 2: regs->r2 = arg; break;\n                case 3: regs->r3 = arg; break;\n                case 4: regs->r4 = arg; break;\n                case 5: regs->r5 = arg; break;\n                }\n            }\n\n            /* Return value gets written back to r0 */\n            rc = regs->r0;\n        }\n    }\n\n    va_end(args);\n\n    return rc;\n}",
        "func": "unsigned long hypercall_create_continuation(\n    unsigned int op, const char *format, ...)\n{\n    struct mc_state *mcs = &current->mc_state;\n    struct cpu_user_regs *regs;\n    const char *p = format;\n    unsigned long arg, rc;\n    unsigned int i;\n    va_list args;\n\n    /* All hypercalls take at least one argument */\n    BUG_ON( !p || *p == '\\0' );\n\n    va_start(args, format);\n\n    if ( test_bit(_MCSF_in_multicall, &mcs->flags) )\n    {\n        __set_bit(_MCSF_call_preempted, &mcs->flags);\n\n        for ( i = 0; *p != '\\0'; i++ )\n            mcs->call.args[i] = next_arg(p, args);\n\n        /* Return value gets written back to mcs->call.result */\n        rc = mcs->call.result;\n    }\n    else\n    {\n        regs = guest_cpu_user_regs();\n\n        /* Ensure the hypercall trap instruction is re-executed. */\n        regs->pc -= 4;  /* re-execute 'hvc #XEN_HYPERCALL_TAG' */\n\n#ifdef CONFIG_ARM_64\n        if ( !is_32bit_domain(current->domain) )\n        {\n            regs->x16 = op;\n\n            for ( i = 0; *p != '\\0'; i++ )\n            {\n                arg = next_arg(p, args);\n\n                switch ( i )\n                {\n                case 0: regs->x0 = arg; break;\n                case 1: regs->x1 = arg; break;\n                case 2: regs->x2 = arg; break;\n                case 3: regs->x3 = arg; break;\n                case 4: regs->x4 = arg; break;\n                case 5: regs->x5 = arg; break;\n                }\n            }\n\n            /* Return value gets written back to x0 */\n            rc = regs->x0;\n        }\n        else\n#endif\n        {\n            regs->r12 = op;\n\n            for ( i = 0; *p != '\\0'; i++ )\n            {\n                arg = next_arg(p, args);\n\n                switch ( i )\n                {\n                case 0: regs->r0 = arg; break;\n                case 1: regs->r1 = arg; break;\n                case 2: regs->r2 = arg; break;\n                case 3: regs->r3 = arg; break;\n                case 4: regs->r4 = arg; break;\n                case 5: regs->r5 = arg; break;\n                }\n            }\n\n            /* Return value gets written back to r0 */\n            rc = regs->r0;\n        }\n    }\n\n    va_end(args);\n\n    return rc;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -15,8 +15,6 @@\n \n     if ( test_bit(_MCSF_in_multicall, &mcs->flags) )\n     {\n-        BUG(); /* XXX multicalls not implemented yet. */\n-\n         __set_bit(_MCSF_call_preempted, &mcs->flags);\n \n         for ( i = 0; *p != '\\0'; i++ )",
        "diff_line_info": {
            "deleted_lines": [
                "        BUG(); /* XXX multicalls not implemented yet. */",
                ""
            ],
            "added_lines": []
        }
    },
    {
        "cve_id": "CVE-2015-8338",
        "func_name": "xen-project/xen/increase_reservation",
        "description": "Xen 4.6.x and earlier does not properly enforce limits on page order inputs for the (1) XENMEM_increase_reservation, (2) XENMEM_populate_physmap, (3) XENMEM_exchange, and possibly other HYPERVISOR_memory_op suboperations, which allows ARM guest OS administrators to cause a denial of service (CPU consumption, guest reboot, or watchdog timeout and host reboot) and possibly have unspecified other impact via unknown vectors.",
        "git_url": "https://github.com/xen-project/xen/commit/4a578b316eb98975374d88f28904acf13dbcfac2",
        "commit_title": "memory: split and tighten maximum order permitted in memops",
        "commit_text": " Introduce and enforce separate limits for ordinary DomU, DomU with pass-through device(s), control domain, and hardware domain.  The DomU defaults were determined based on what so far was allowed by multipage_allocation_permitted().  The x86 hwdom default was chosen based on linux-2.6.18-xen.hg c/s 1102:82782f1361a9 indicating 2Mb is not enough, plus some slack.  The ARM hwdom default was chosen to allow 2Mb (order-9) mappings, plus a little bit of slack.  This is CVE-2015-8338 / XSA-158. ",
        "func_before": "static void increase_reservation(struct memop_args *a)\n{\n    struct page_info *page;\n    unsigned long i;\n    xen_pfn_t mfn;\n    struct domain *d = a->domain;\n\n    if ( !guest_handle_is_null(a->extent_list) &&\n         !guest_handle_subrange_okay(a->extent_list, a->nr_done,\n                                     a->nr_extents-1) )\n        return;\n\n    if ( !multipage_allocation_permitted(current->domain, a->extent_order) )\n        return;\n\n    for ( i = a->nr_done; i < a->nr_extents; i++ )\n    {\n        if ( i != a->nr_done && hypercall_preempt_check() )\n        {\n            a->preempted = 1;\n            goto out;\n        }\n\n        page = alloc_domheap_pages(d, a->extent_order, a->memflags);\n        if ( unlikely(page == NULL) ) \n        {\n            gdprintk(XENLOG_INFO, \"Could not allocate order=%d extent: \"\n                    \"id=%d memflags=%x (%ld of %d)\\n\",\n                     a->extent_order, d->domain_id, a->memflags,\n                     i, a->nr_extents);\n            goto out;\n        }\n\n        /* Inform the domain of the new page's machine address. */ \n        if ( !guest_handle_is_null(a->extent_list) )\n        {\n            mfn = page_to_mfn(page);\n            if ( unlikely(__copy_to_guest_offset(a->extent_list, i, &mfn, 1)) )\n                goto out;\n        }\n    }\n\n out:\n    a->nr_done = i;\n}",
        "func": "static void increase_reservation(struct memop_args *a)\n{\n    struct page_info *page;\n    unsigned long i;\n    xen_pfn_t mfn;\n    struct domain *d = a->domain;\n\n    if ( !guest_handle_is_null(a->extent_list) &&\n         !guest_handle_subrange_okay(a->extent_list, a->nr_done,\n                                     a->nr_extents-1) )\n        return;\n\n    if ( a->extent_order > max_order(current->domain) )\n        return;\n\n    for ( i = a->nr_done; i < a->nr_extents; i++ )\n    {\n        if ( i != a->nr_done && hypercall_preempt_check() )\n        {\n            a->preempted = 1;\n            goto out;\n        }\n\n        page = alloc_domheap_pages(d, a->extent_order, a->memflags);\n        if ( unlikely(page == NULL) ) \n        {\n            gdprintk(XENLOG_INFO, \"Could not allocate order=%d extent: \"\n                    \"id=%d memflags=%x (%ld of %d)\\n\",\n                     a->extent_order, d->domain_id, a->memflags,\n                     i, a->nr_extents);\n            goto out;\n        }\n\n        /* Inform the domain of the new page's machine address. */ \n        if ( !guest_handle_is_null(a->extent_list) )\n        {\n            mfn = page_to_mfn(page);\n            if ( unlikely(__copy_to_guest_offset(a->extent_list, i, &mfn, 1)) )\n                goto out;\n        }\n    }\n\n out:\n    a->nr_done = i;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -10,7 +10,7 @@\n                                      a->nr_extents-1) )\n         return;\n \n-    if ( !multipage_allocation_permitted(current->domain, a->extent_order) )\n+    if ( a->extent_order > max_order(current->domain) )\n         return;\n \n     for ( i = a->nr_done; i < a->nr_extents; i++ )",
        "diff_line_info": {
            "deleted_lines": [
                "    if ( !multipage_allocation_permitted(current->domain, a->extent_order) )"
            ],
            "added_lines": [
                "    if ( a->extent_order > max_order(current->domain) )"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-8338",
        "func_name": "xen-project/xen/decrease_reservation",
        "description": "Xen 4.6.x and earlier does not properly enforce limits on page order inputs for the (1) XENMEM_increase_reservation, (2) XENMEM_populate_physmap, (3) XENMEM_exchange, and possibly other HYPERVISOR_memory_op suboperations, which allows ARM guest OS administrators to cause a denial of service (CPU consumption, guest reboot, or watchdog timeout and host reboot) and possibly have unspecified other impact via unknown vectors.",
        "git_url": "https://github.com/xen-project/xen/commit/4a578b316eb98975374d88f28904acf13dbcfac2",
        "commit_title": "memory: split and tighten maximum order permitted in memops",
        "commit_text": " Introduce and enforce separate limits for ordinary DomU, DomU with pass-through device(s), control domain, and hardware domain.  The DomU defaults were determined based on what so far was allowed by multipage_allocation_permitted().  The x86 hwdom default was chosen based on linux-2.6.18-xen.hg c/s 1102:82782f1361a9 indicating 2Mb is not enough, plus some slack.  The ARM hwdom default was chosen to allow 2Mb (order-9) mappings, plus a little bit of slack.  This is CVE-2015-8338 / XSA-158. ",
        "func_before": "static void decrease_reservation(struct memop_args *a)\n{\n    unsigned long i, j;\n    xen_pfn_t gmfn;\n\n    if ( !guest_handle_subrange_okay(a->extent_list, a->nr_done,\n                                     a->nr_extents-1) ||\n         a->extent_order > MAX_ORDER )\n        return;\n\n    for ( i = a->nr_done; i < a->nr_extents; i++ )\n    {\n        if ( i != a->nr_done && hypercall_preempt_check() )\n        {\n            a->preempted = 1;\n            goto out;\n        }\n\n        if ( unlikely(__copy_from_guest_offset(&gmfn, a->extent_list, i, 1)) )\n            goto out;\n\n        if ( tb_init_done )\n        {\n            struct {\n                u64 gfn;\n                int d:16,order:16;\n            } t;\n\n            t.gfn = gmfn;\n            t.d = a->domain->domain_id;\n            t.order = a->extent_order;\n        \n            __trace_var(TRC_MEM_DECREASE_RESERVATION, 0, sizeof(t), &t);\n        }\n\n        /* See if populate-on-demand wants to handle this */\n        if ( is_hvm_domain(a->domain)\n             && p2m_pod_decrease_reservation(a->domain, gmfn, a->extent_order) )\n            continue;\n\n        for ( j = 0; j < (1 << a->extent_order); j++ )\n            if ( !guest_remove_page(a->domain, gmfn + j) )\n                goto out;\n    }\n\n out:\n    a->nr_done = i;\n}",
        "func": "static void decrease_reservation(struct memop_args *a)\n{\n    unsigned long i, j;\n    xen_pfn_t gmfn;\n\n    if ( !guest_handle_subrange_okay(a->extent_list, a->nr_done,\n                                     a->nr_extents-1) ||\n         a->extent_order > max_order(current->domain) )\n        return;\n\n    for ( i = a->nr_done; i < a->nr_extents; i++ )\n    {\n        if ( i != a->nr_done && hypercall_preempt_check() )\n        {\n            a->preempted = 1;\n            goto out;\n        }\n\n        if ( unlikely(__copy_from_guest_offset(&gmfn, a->extent_list, i, 1)) )\n            goto out;\n\n        if ( tb_init_done )\n        {\n            struct {\n                u64 gfn;\n                int d:16,order:16;\n            } t;\n\n            t.gfn = gmfn;\n            t.d = a->domain->domain_id;\n            t.order = a->extent_order;\n        \n            __trace_var(TRC_MEM_DECREASE_RESERVATION, 0, sizeof(t), &t);\n        }\n\n        /* See if populate-on-demand wants to handle this */\n        if ( is_hvm_domain(a->domain)\n             && p2m_pod_decrease_reservation(a->domain, gmfn, a->extent_order) )\n            continue;\n\n        for ( j = 0; j < (1 << a->extent_order); j++ )\n            if ( !guest_remove_page(a->domain, gmfn + j) )\n                goto out;\n    }\n\n out:\n    a->nr_done = i;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,7 +5,7 @@\n \n     if ( !guest_handle_subrange_okay(a->extent_list, a->nr_done,\n                                      a->nr_extents-1) ||\n-         a->extent_order > MAX_ORDER )\n+         a->extent_order > max_order(current->domain) )\n         return;\n \n     for ( i = a->nr_done; i < a->nr_extents; i++ )",
        "diff_line_info": {
            "deleted_lines": [
                "         a->extent_order > MAX_ORDER )"
            ],
            "added_lines": [
                "         a->extent_order > max_order(current->domain) )"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-8338",
        "func_name": "xen-project/xen/memory_exchange",
        "description": "Xen 4.6.x and earlier does not properly enforce limits on page order inputs for the (1) XENMEM_increase_reservation, (2) XENMEM_populate_physmap, (3) XENMEM_exchange, and possibly other HYPERVISOR_memory_op suboperations, which allows ARM guest OS administrators to cause a denial of service (CPU consumption, guest reboot, or watchdog timeout and host reboot) and possibly have unspecified other impact via unknown vectors.",
        "git_url": "https://github.com/xen-project/xen/commit/4a578b316eb98975374d88f28904acf13dbcfac2",
        "commit_title": "memory: split and tighten maximum order permitted in memops",
        "commit_text": " Introduce and enforce separate limits for ordinary DomU, DomU with pass-through device(s), control domain, and hardware domain.  The DomU defaults were determined based on what so far was allowed by multipage_allocation_permitted().  The x86 hwdom default was chosen based on linux-2.6.18-xen.hg c/s 1102:82782f1361a9 indicating 2Mb is not enough, plus some slack.  The ARM hwdom default was chosen to allow 2Mb (order-9) mappings, plus a little bit of slack.  This is CVE-2015-8338 / XSA-158. ",
        "func_before": "static long memory_exchange(XEN_GUEST_HANDLE_PARAM(xen_memory_exchange_t) arg)\n{\n    struct xen_memory_exchange exch;\n    PAGE_LIST_HEAD(in_chunk_list);\n    PAGE_LIST_HEAD(out_chunk_list);\n    unsigned long in_chunk_order, out_chunk_order;\n    xen_pfn_t     gpfn, gmfn, mfn;\n    unsigned long i, j, k = 0; /* gcc ... */\n    unsigned int  memflags = 0;\n    long          rc = 0;\n    struct domain *d;\n    struct page_info *page;\n\n    if ( copy_from_guest(&exch, arg, 1) )\n        return -EFAULT;\n\n    /* Various sanity checks. */\n    if ( (exch.nr_exchanged > exch.in.nr_extents) ||\n         /* Input and output domain identifiers match? */\n         (exch.in.domid != exch.out.domid) ||\n         /* Extent orders are sensible? */\n         (exch.in.extent_order > MAX_ORDER) ||\n         (exch.out.extent_order > MAX_ORDER) ||\n         /* Sizes of input and output lists do not overflow a long? */\n         ((~0UL >> exch.in.extent_order) < exch.in.nr_extents) ||\n         ((~0UL >> exch.out.extent_order) < exch.out.nr_extents) ||\n         /* Sizes of input and output lists match? */\n         ((exch.in.nr_extents << exch.in.extent_order) !=\n          (exch.out.nr_extents << exch.out.extent_order)) )\n    {\n        rc = -EINVAL;\n        goto fail_early;\n    }\n\n    if ( !guest_handle_okay(exch.in.extent_start, exch.in.nr_extents) ||\n         !guest_handle_okay(exch.out.extent_start, exch.out.nr_extents) )\n    {\n        rc = -EFAULT;\n        goto fail_early;\n    }\n\n    /* Only privileged guests can allocate multi-page contiguous extents. */\n    if ( !multipage_allocation_permitted(current->domain,\n                                         exch.in.extent_order) ||\n         !multipage_allocation_permitted(current->domain,\n                                         exch.out.extent_order) )\n    {\n        rc = -EPERM;\n        goto fail_early;\n    }\n\n    if ( exch.in.extent_order <= exch.out.extent_order )\n    {\n        in_chunk_order  = exch.out.extent_order - exch.in.extent_order;\n        out_chunk_order = 0;\n    }\n    else\n    {\n        in_chunk_order  = 0;\n        out_chunk_order = exch.in.extent_order - exch.out.extent_order;\n    }\n\n    d = rcu_lock_domain_by_any_id(exch.in.domid);\n    if ( d == NULL )\n    {\n        rc = -ESRCH;\n        goto fail_early;\n    }\n\n    rc = xsm_memory_exchange(XSM_TARGET, d);\n    if ( rc )\n    {\n        rcu_unlock_domain(d);\n        goto fail_early;\n    }\n\n    memflags |= MEMF_bits(domain_clamp_alloc_bitsize(\n        d,\n        XENMEMF_get_address_bits(exch.out.mem_flags) ? :\n        (BITS_PER_LONG+PAGE_SHIFT)));\n    memflags |= MEMF_node(XENMEMF_get_node(exch.out.mem_flags));\n\n    for ( i = (exch.nr_exchanged >> in_chunk_order);\n          i < (exch.in.nr_extents >> in_chunk_order);\n          i++ )\n    {\n        if ( i != (exch.nr_exchanged >> in_chunk_order) &&\n             hypercall_preempt_check() )\n        {\n            exch.nr_exchanged = i << in_chunk_order;\n            rcu_unlock_domain(d);\n            if ( __copy_field_to_guest(arg, &exch, nr_exchanged) )\n                return -EFAULT;\n            return hypercall_create_continuation(\n                __HYPERVISOR_memory_op, \"lh\", XENMEM_exchange, arg);\n        }\n\n        /* Steal a chunk's worth of input pages from the domain. */\n        for ( j = 0; j < (1UL << in_chunk_order); j++ )\n        {\n            if ( unlikely(__copy_from_guest_offset(\n                &gmfn, exch.in.extent_start, (i<<in_chunk_order)+j, 1)) )\n            {\n                rc = -EFAULT;\n                goto fail;\n            }\n\n            for ( k = 0; k < (1UL << exch.in.extent_order); k++ )\n            {\n#ifdef CONFIG_X86\n                p2m_type_t p2mt;\n\n                /* Shared pages cannot be exchanged */\n                mfn = mfn_x(get_gfn_unshare(d, gmfn + k, &p2mt));\n                if ( p2m_is_shared(p2mt) )\n                {\n                    put_gfn(d, gmfn + k);\n                    rc = -ENOMEM;\n                    goto fail; \n                }\n#else /* !CONFIG_X86 */\n                mfn = gmfn_to_mfn(d, gmfn + k);\n#endif\n                if ( unlikely(!mfn_valid(mfn)) )\n                {\n                    put_gfn(d, gmfn + k);\n                    rc = -EINVAL;\n                    goto fail;\n                }\n\n                page = mfn_to_page(mfn);\n\n                if ( unlikely(steal_page(d, page, MEMF_no_refcount)) )\n                {\n                    put_gfn(d, gmfn + k);\n                    rc = -EINVAL;\n                    goto fail;\n                }\n\n                page_list_add(page, &in_chunk_list);\n                put_gfn(d, gmfn + k);\n            }\n        }\n\n        /* Allocate a chunk's worth of anonymous output pages. */\n        for ( j = 0; j < (1UL << out_chunk_order); j++ )\n        {\n            page = alloc_domheap_pages(d, exch.out.extent_order,\n                                       MEMF_no_owner | memflags);\n            if ( unlikely(page == NULL) )\n            {\n                rc = -ENOMEM;\n                goto fail;\n            }\n\n            page_list_add(page, &out_chunk_list);\n        }\n\n        /*\n         * Success! Beyond this point we cannot fail for this chunk.\n         */\n\n        /* Destroy final reference to each input page. */\n        while ( (page = page_list_remove_head(&in_chunk_list)) )\n        {\n            unsigned long gfn;\n\n            if ( !test_and_clear_bit(_PGC_allocated, &page->count_info) )\n                BUG();\n            mfn = page_to_mfn(page);\n            gfn = mfn_to_gmfn(d, mfn);\n            /* Pages were unshared above */\n            BUG_ON(SHARED_M2P(gfn));\n            guest_physmap_remove_page(d, gfn, mfn, 0);\n            put_page(page);\n        }\n\n        /* Assign each output page to the domain. */\n        for ( j = 0; (page = page_list_remove_head(&out_chunk_list)); ++j )\n        {\n            if ( assign_pages(d, page, exch.out.extent_order,\n                              MEMF_no_refcount) )\n            {\n                unsigned long dec_count;\n                bool_t drop_dom_ref;\n\n                /*\n                 * Pages in in_chunk_list is stolen without\n                 * decreasing the tot_pages. If the domain is dying when\n                 * assign pages, we need decrease the count. For those pages\n                 * that has been assigned, it should be covered by\n                 * domain_relinquish_resources().\n                 */\n                dec_count = (((1UL << exch.in.extent_order) *\n                              (1UL << in_chunk_order)) -\n                             (j * (1UL << exch.out.extent_order)));\n\n                spin_lock(&d->page_alloc_lock);\n                drop_dom_ref = (dec_count &&\n                                !domain_adjust_tot_pages(d, -dec_count));\n                spin_unlock(&d->page_alloc_lock);\n\n                if ( drop_dom_ref )\n                    put_domain(d);\n\n                free_domheap_pages(page, exch.out.extent_order);\n                goto dying;\n            }\n\n            if ( __copy_from_guest_offset(&gpfn, exch.out.extent_start,\n                                          (i << out_chunk_order) + j, 1) )\n            {\n                rc = -EFAULT;\n                continue;\n            }\n\n            mfn = page_to_mfn(page);\n            guest_physmap_add_page(d, gpfn, mfn, exch.out.extent_order);\n\n            if ( !paging_mode_translate(d) )\n            {\n                for ( k = 0; k < (1UL << exch.out.extent_order); k++ )\n                    set_gpfn_from_mfn(mfn + k, gpfn + k);\n                if ( __copy_to_guest_offset(exch.out.extent_start,\n                                            (i << out_chunk_order) + j,\n                                            &mfn, 1) )\n                    rc = -EFAULT;\n            }\n        }\n        BUG_ON( !(d->is_dying) && (j != (1UL << out_chunk_order)) );\n    }\n\n    exch.nr_exchanged = exch.in.nr_extents;\n    if ( __copy_field_to_guest(arg, &exch, nr_exchanged) )\n        rc = -EFAULT;\n    rcu_unlock_domain(d);\n    return rc;\n\n    /*\n     * Failed a chunk! Free any partial chunk work. Tell caller how many\n     * chunks succeeded.\n     */\n fail:\n    /* Reassign any input pages we managed to steal. */\n    while ( (page = page_list_remove_head(&in_chunk_list)) )\n    {\n        put_gfn(d, gmfn + k--);\n        if ( assign_pages(d, page, 0, MEMF_no_refcount) )\n            BUG();\n    }\n\n dying:\n    rcu_unlock_domain(d);\n    /* Free any output pages we managed to allocate. */\n    while ( (page = page_list_remove_head(&out_chunk_list)) )\n        free_domheap_pages(page, exch.out.extent_order);\n\n    exch.nr_exchanged = i << in_chunk_order;\n\n fail_early:\n    if ( __copy_field_to_guest(arg, &exch, nr_exchanged) )\n        rc = -EFAULT;\n    return rc;\n}",
        "func": "static long memory_exchange(XEN_GUEST_HANDLE_PARAM(xen_memory_exchange_t) arg)\n{\n    struct xen_memory_exchange exch;\n    PAGE_LIST_HEAD(in_chunk_list);\n    PAGE_LIST_HEAD(out_chunk_list);\n    unsigned long in_chunk_order, out_chunk_order;\n    xen_pfn_t     gpfn, gmfn, mfn;\n    unsigned long i, j, k = 0; /* gcc ... */\n    unsigned int  memflags = 0;\n    long          rc = 0;\n    struct domain *d;\n    struct page_info *page;\n\n    if ( copy_from_guest(&exch, arg, 1) )\n        return -EFAULT;\n\n    if ( max(exch.in.extent_order, exch.out.extent_order) >\n         max_order(current->domain) )\n    {\n        rc = -EPERM;\n        goto fail_early;\n    }\n\n    /* Various sanity checks. */\n    if ( (exch.nr_exchanged > exch.in.nr_extents) ||\n         /* Input and output domain identifiers match? */\n         (exch.in.domid != exch.out.domid) ||\n         /* Sizes of input and output lists do not overflow a long? */\n         ((~0UL >> exch.in.extent_order) < exch.in.nr_extents) ||\n         ((~0UL >> exch.out.extent_order) < exch.out.nr_extents) ||\n         /* Sizes of input and output lists match? */\n         ((exch.in.nr_extents << exch.in.extent_order) !=\n          (exch.out.nr_extents << exch.out.extent_order)) )\n    {\n        rc = -EINVAL;\n        goto fail_early;\n    }\n\n    if ( !guest_handle_okay(exch.in.extent_start, exch.in.nr_extents) ||\n         !guest_handle_okay(exch.out.extent_start, exch.out.nr_extents) )\n    {\n        rc = -EFAULT;\n        goto fail_early;\n    }\n\n    if ( exch.in.extent_order <= exch.out.extent_order )\n    {\n        in_chunk_order  = exch.out.extent_order - exch.in.extent_order;\n        out_chunk_order = 0;\n    }\n    else\n    {\n        in_chunk_order  = 0;\n        out_chunk_order = exch.in.extent_order - exch.out.extent_order;\n    }\n\n    d = rcu_lock_domain_by_any_id(exch.in.domid);\n    if ( d == NULL )\n    {\n        rc = -ESRCH;\n        goto fail_early;\n    }\n\n    rc = xsm_memory_exchange(XSM_TARGET, d);\n    if ( rc )\n    {\n        rcu_unlock_domain(d);\n        goto fail_early;\n    }\n\n    memflags |= MEMF_bits(domain_clamp_alloc_bitsize(\n        d,\n        XENMEMF_get_address_bits(exch.out.mem_flags) ? :\n        (BITS_PER_LONG+PAGE_SHIFT)));\n    memflags |= MEMF_node(XENMEMF_get_node(exch.out.mem_flags));\n\n    for ( i = (exch.nr_exchanged >> in_chunk_order);\n          i < (exch.in.nr_extents >> in_chunk_order);\n          i++ )\n    {\n        if ( i != (exch.nr_exchanged >> in_chunk_order) &&\n             hypercall_preempt_check() )\n        {\n            exch.nr_exchanged = i << in_chunk_order;\n            rcu_unlock_domain(d);\n            if ( __copy_field_to_guest(arg, &exch, nr_exchanged) )\n                return -EFAULT;\n            return hypercall_create_continuation(\n                __HYPERVISOR_memory_op, \"lh\", XENMEM_exchange, arg);\n        }\n\n        /* Steal a chunk's worth of input pages from the domain. */\n        for ( j = 0; j < (1UL << in_chunk_order); j++ )\n        {\n            if ( unlikely(__copy_from_guest_offset(\n                &gmfn, exch.in.extent_start, (i<<in_chunk_order)+j, 1)) )\n            {\n                rc = -EFAULT;\n                goto fail;\n            }\n\n            for ( k = 0; k < (1UL << exch.in.extent_order); k++ )\n            {\n#ifdef CONFIG_X86\n                p2m_type_t p2mt;\n\n                /* Shared pages cannot be exchanged */\n                mfn = mfn_x(get_gfn_unshare(d, gmfn + k, &p2mt));\n                if ( p2m_is_shared(p2mt) )\n                {\n                    put_gfn(d, gmfn + k);\n                    rc = -ENOMEM;\n                    goto fail; \n                }\n#else /* !CONFIG_X86 */\n                mfn = gmfn_to_mfn(d, gmfn + k);\n#endif\n                if ( unlikely(!mfn_valid(mfn)) )\n                {\n                    put_gfn(d, gmfn + k);\n                    rc = -EINVAL;\n                    goto fail;\n                }\n\n                page = mfn_to_page(mfn);\n\n                if ( unlikely(steal_page(d, page, MEMF_no_refcount)) )\n                {\n                    put_gfn(d, gmfn + k);\n                    rc = -EINVAL;\n                    goto fail;\n                }\n\n                page_list_add(page, &in_chunk_list);\n                put_gfn(d, gmfn + k);\n            }\n        }\n\n        /* Allocate a chunk's worth of anonymous output pages. */\n        for ( j = 0; j < (1UL << out_chunk_order); j++ )\n        {\n            page = alloc_domheap_pages(d, exch.out.extent_order,\n                                       MEMF_no_owner | memflags);\n            if ( unlikely(page == NULL) )\n            {\n                rc = -ENOMEM;\n                goto fail;\n            }\n\n            page_list_add(page, &out_chunk_list);\n        }\n\n        /*\n         * Success! Beyond this point we cannot fail for this chunk.\n         */\n\n        /* Destroy final reference to each input page. */\n        while ( (page = page_list_remove_head(&in_chunk_list)) )\n        {\n            unsigned long gfn;\n\n            if ( !test_and_clear_bit(_PGC_allocated, &page->count_info) )\n                BUG();\n            mfn = page_to_mfn(page);\n            gfn = mfn_to_gmfn(d, mfn);\n            /* Pages were unshared above */\n            BUG_ON(SHARED_M2P(gfn));\n            guest_physmap_remove_page(d, gfn, mfn, 0);\n            put_page(page);\n        }\n\n        /* Assign each output page to the domain. */\n        for ( j = 0; (page = page_list_remove_head(&out_chunk_list)); ++j )\n        {\n            if ( assign_pages(d, page, exch.out.extent_order,\n                              MEMF_no_refcount) )\n            {\n                unsigned long dec_count;\n                bool_t drop_dom_ref;\n\n                /*\n                 * Pages in in_chunk_list is stolen without\n                 * decreasing the tot_pages. If the domain is dying when\n                 * assign pages, we need decrease the count. For those pages\n                 * that has been assigned, it should be covered by\n                 * domain_relinquish_resources().\n                 */\n                dec_count = (((1UL << exch.in.extent_order) *\n                              (1UL << in_chunk_order)) -\n                             (j * (1UL << exch.out.extent_order)));\n\n                spin_lock(&d->page_alloc_lock);\n                drop_dom_ref = (dec_count &&\n                                !domain_adjust_tot_pages(d, -dec_count));\n                spin_unlock(&d->page_alloc_lock);\n\n                if ( drop_dom_ref )\n                    put_domain(d);\n\n                free_domheap_pages(page, exch.out.extent_order);\n                goto dying;\n            }\n\n            if ( __copy_from_guest_offset(&gpfn, exch.out.extent_start,\n                                          (i << out_chunk_order) + j, 1) )\n            {\n                rc = -EFAULT;\n                continue;\n            }\n\n            mfn = page_to_mfn(page);\n            guest_physmap_add_page(d, gpfn, mfn, exch.out.extent_order);\n\n            if ( !paging_mode_translate(d) )\n            {\n                for ( k = 0; k < (1UL << exch.out.extent_order); k++ )\n                    set_gpfn_from_mfn(mfn + k, gpfn + k);\n                if ( __copy_to_guest_offset(exch.out.extent_start,\n                                            (i << out_chunk_order) + j,\n                                            &mfn, 1) )\n                    rc = -EFAULT;\n            }\n        }\n        BUG_ON( !(d->is_dying) && (j != (1UL << out_chunk_order)) );\n    }\n\n    exch.nr_exchanged = exch.in.nr_extents;\n    if ( __copy_field_to_guest(arg, &exch, nr_exchanged) )\n        rc = -EFAULT;\n    rcu_unlock_domain(d);\n    return rc;\n\n    /*\n     * Failed a chunk! Free any partial chunk work. Tell caller how many\n     * chunks succeeded.\n     */\n fail:\n    /* Reassign any input pages we managed to steal. */\n    while ( (page = page_list_remove_head(&in_chunk_list)) )\n    {\n        put_gfn(d, gmfn + k--);\n        if ( assign_pages(d, page, 0, MEMF_no_refcount) )\n            BUG();\n    }\n\n dying:\n    rcu_unlock_domain(d);\n    /* Free any output pages we managed to allocate. */\n    while ( (page = page_list_remove_head(&out_chunk_list)) )\n        free_domheap_pages(page, exch.out.extent_order);\n\n    exch.nr_exchanged = i << in_chunk_order;\n\n fail_early:\n    if ( __copy_field_to_guest(arg, &exch, nr_exchanged) )\n        rc = -EFAULT;\n    return rc;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -14,13 +14,17 @@\n     if ( copy_from_guest(&exch, arg, 1) )\n         return -EFAULT;\n \n+    if ( max(exch.in.extent_order, exch.out.extent_order) >\n+         max_order(current->domain) )\n+    {\n+        rc = -EPERM;\n+        goto fail_early;\n+    }\n+\n     /* Various sanity checks. */\n     if ( (exch.nr_exchanged > exch.in.nr_extents) ||\n          /* Input and output domain identifiers match? */\n          (exch.in.domid != exch.out.domid) ||\n-         /* Extent orders are sensible? */\n-         (exch.in.extent_order > MAX_ORDER) ||\n-         (exch.out.extent_order > MAX_ORDER) ||\n          /* Sizes of input and output lists do not overflow a long? */\n          ((~0UL >> exch.in.extent_order) < exch.in.nr_extents) ||\n          ((~0UL >> exch.out.extent_order) < exch.out.nr_extents) ||\n@@ -36,16 +40,6 @@\n          !guest_handle_okay(exch.out.extent_start, exch.out.nr_extents) )\n     {\n         rc = -EFAULT;\n-        goto fail_early;\n-    }\n-\n-    /* Only privileged guests can allocate multi-page contiguous extents. */\n-    if ( !multipage_allocation_permitted(current->domain,\n-                                         exch.in.extent_order) ||\n-         !multipage_allocation_permitted(current->domain,\n-                                         exch.out.extent_order) )\n-    {\n-        rc = -EPERM;\n         goto fail_early;\n     }\n ",
        "diff_line_info": {
            "deleted_lines": [
                "         /* Extent orders are sensible? */",
                "         (exch.in.extent_order > MAX_ORDER) ||",
                "         (exch.out.extent_order > MAX_ORDER) ||",
                "        goto fail_early;",
                "    }",
                "",
                "    /* Only privileged guests can allocate multi-page contiguous extents. */",
                "    if ( !multipage_allocation_permitted(current->domain,",
                "                                         exch.in.extent_order) ||",
                "         !multipage_allocation_permitted(current->domain,",
                "                                         exch.out.extent_order) )",
                "    {",
                "        rc = -EPERM;"
            ],
            "added_lines": [
                "    if ( max(exch.in.extent_order, exch.out.extent_order) >",
                "         max_order(current->domain) )",
                "    {",
                "        rc = -EPERM;",
                "        goto fail_early;",
                "    }",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2015-8338",
        "func_name": "xen-project/xen/populate_physmap",
        "description": "Xen 4.6.x and earlier does not properly enforce limits on page order inputs for the (1) XENMEM_increase_reservation, (2) XENMEM_populate_physmap, (3) XENMEM_exchange, and possibly other HYPERVISOR_memory_op suboperations, which allows ARM guest OS administrators to cause a denial of service (CPU consumption, guest reboot, or watchdog timeout and host reboot) and possibly have unspecified other impact via unknown vectors.",
        "git_url": "https://github.com/xen-project/xen/commit/4a578b316eb98975374d88f28904acf13dbcfac2",
        "commit_title": "memory: split and tighten maximum order permitted in memops",
        "commit_text": " Introduce and enforce separate limits for ordinary DomU, DomU with pass-through device(s), control domain, and hardware domain.  The DomU defaults were determined based on what so far was allowed by multipage_allocation_permitted().  The x86 hwdom default was chosen based on linux-2.6.18-xen.hg c/s 1102:82782f1361a9 indicating 2Mb is not enough, plus some slack.  The ARM hwdom default was chosen to allow 2Mb (order-9) mappings, plus a little bit of slack.  This is CVE-2015-8338 / XSA-158. ",
        "func_before": "static void populate_physmap(struct memop_args *a)\n{\n    struct page_info *page;\n    unsigned int i, j;\n    xen_pfn_t gpfn, mfn;\n    struct domain *d = a->domain;\n\n    if ( !guest_handle_subrange_okay(a->extent_list, a->nr_done,\n                                     a->nr_extents-1) )\n        return;\n\n    if ( a->memflags & MEMF_populate_on_demand ? a->extent_order > MAX_ORDER :\n         !multipage_allocation_permitted(current->domain, a->extent_order) )\n        return;\n\n    for ( i = a->nr_done; i < a->nr_extents; i++ )\n    {\n        if ( i != a->nr_done && hypercall_preempt_check() )\n        {\n            a->preempted = 1;\n            goto out;\n        }\n\n        if ( unlikely(__copy_from_guest_offset(&gpfn, a->extent_list, i, 1)) )\n            goto out;\n\n        if ( a->memflags & MEMF_populate_on_demand )\n        {\n            if ( guest_physmap_mark_populate_on_demand(d, gpfn,\n                                                       a->extent_order) < 0 )\n                goto out;\n        }\n        else\n        {\n            if ( is_domain_direct_mapped(d) )\n            {\n                mfn = gpfn;\n\n                for ( j = 0; j < (1U << a->extent_order); j++, mfn++ )\n                {\n                    if ( !mfn_valid(mfn) )\n                    {\n                        gdprintk(XENLOG_INFO, \"Invalid mfn %#\"PRI_xen_pfn\"\\n\",\n                                 mfn);\n                        goto out;\n                    }\n\n                    page = mfn_to_page(mfn);\n                    if ( !get_page(page, d) )\n                    {\n                        gdprintk(XENLOG_INFO,\n                                 \"mfn %#\"PRI_xen_pfn\" doesn't belong to d%d\\n\",\n                                  mfn, d->domain_id);\n                        goto out;\n                    }\n                    put_page(page);\n                }\n\n                mfn = gpfn;\n                page = mfn_to_page(mfn);\n            }\n            else\n            {\n                page = alloc_domheap_pages(d, a->extent_order, a->memflags);\n\n                if ( unlikely(!page) )\n                {\n                    if ( !opt_tmem || a->extent_order )\n                        gdprintk(XENLOG_INFO,\n                                 \"Could not allocate order=%u extent: id=%d memflags=%#x (%u of %u)\\n\",\n                                 a->extent_order, d->domain_id, a->memflags,\n                                 i, a->nr_extents);\n                    goto out;\n                }\n\n                mfn = page_to_mfn(page);\n            }\n\n            guest_physmap_add_page(d, gpfn, mfn, a->extent_order);\n\n            if ( !paging_mode_translate(d) )\n            {\n                for ( j = 0; j < (1U << a->extent_order); j++ )\n                    set_gpfn_from_mfn(mfn + j, gpfn + j);\n\n                /* Inform the domain of the new page's machine address. */ \n                if ( unlikely(__copy_to_guest_offset(a->extent_list, i, &mfn, 1)) )\n                    goto out;\n            }\n        }\n    }\n\nout:\n    a->nr_done = i;\n}",
        "func": "static void populate_physmap(struct memop_args *a)\n{\n    struct page_info *page;\n    unsigned int i, j;\n    xen_pfn_t gpfn, mfn;\n    struct domain *d = a->domain;\n\n    if ( !guest_handle_subrange_okay(a->extent_list, a->nr_done,\n                                     a->nr_extents-1) )\n        return;\n\n    if ( a->extent_order > (a->memflags & MEMF_populate_on_demand ? MAX_ORDER :\n                            max_order(current->domain)) )\n        return;\n\n    for ( i = a->nr_done; i < a->nr_extents; i++ )\n    {\n        if ( i != a->nr_done && hypercall_preempt_check() )\n        {\n            a->preempted = 1;\n            goto out;\n        }\n\n        if ( unlikely(__copy_from_guest_offset(&gpfn, a->extent_list, i, 1)) )\n            goto out;\n\n        if ( a->memflags & MEMF_populate_on_demand )\n        {\n            if ( guest_physmap_mark_populate_on_demand(d, gpfn,\n                                                       a->extent_order) < 0 )\n                goto out;\n        }\n        else\n        {\n            if ( is_domain_direct_mapped(d) )\n            {\n                mfn = gpfn;\n\n                for ( j = 0; j < (1U << a->extent_order); j++, mfn++ )\n                {\n                    if ( !mfn_valid(mfn) )\n                    {\n                        gdprintk(XENLOG_INFO, \"Invalid mfn %#\"PRI_xen_pfn\"\\n\",\n                                 mfn);\n                        goto out;\n                    }\n\n                    page = mfn_to_page(mfn);\n                    if ( !get_page(page, d) )\n                    {\n                        gdprintk(XENLOG_INFO,\n                                 \"mfn %#\"PRI_xen_pfn\" doesn't belong to d%d\\n\",\n                                  mfn, d->domain_id);\n                        goto out;\n                    }\n                    put_page(page);\n                }\n\n                mfn = gpfn;\n                page = mfn_to_page(mfn);\n            }\n            else\n            {\n                page = alloc_domheap_pages(d, a->extent_order, a->memflags);\n\n                if ( unlikely(!page) )\n                {\n                    if ( !opt_tmem || a->extent_order )\n                        gdprintk(XENLOG_INFO,\n                                 \"Could not allocate order=%u extent: id=%d memflags=%#x (%u of %u)\\n\",\n                                 a->extent_order, d->domain_id, a->memflags,\n                                 i, a->nr_extents);\n                    goto out;\n                }\n\n                mfn = page_to_mfn(page);\n            }\n\n            guest_physmap_add_page(d, gpfn, mfn, a->extent_order);\n\n            if ( !paging_mode_translate(d) )\n            {\n                for ( j = 0; j < (1U << a->extent_order); j++ )\n                    set_gpfn_from_mfn(mfn + j, gpfn + j);\n\n                /* Inform the domain of the new page's machine address. */ \n                if ( unlikely(__copy_to_guest_offset(a->extent_list, i, &mfn, 1)) )\n                    goto out;\n            }\n        }\n    }\n\nout:\n    a->nr_done = i;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -9,8 +9,8 @@\n                                      a->nr_extents-1) )\n         return;\n \n-    if ( a->memflags & MEMF_populate_on_demand ? a->extent_order > MAX_ORDER :\n-         !multipage_allocation_permitted(current->domain, a->extent_order) )\n+    if ( a->extent_order > (a->memflags & MEMF_populate_on_demand ? MAX_ORDER :\n+                            max_order(current->domain)) )\n         return;\n \n     for ( i = a->nr_done; i < a->nr_extents; i++ )",
        "diff_line_info": {
            "deleted_lines": [
                "    if ( a->memflags & MEMF_populate_on_demand ? a->extent_order > MAX_ORDER :",
                "         !multipage_allocation_permitted(current->domain, a->extent_order) )"
            ],
            "added_lines": [
                "    if ( a->extent_order > (a->memflags & MEMF_populate_on_demand ? MAX_ORDER :",
                "                            max_order(current->domain)) )"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-8615",
        "func_name": "xen-project/xen/hvm_set_callback_via",
        "description": "The hvm_set_callback_via function in arch/x86/hvm/irq.c in Xen 4.6 does not limit the number of printk console messages when logging the new callback method, which allows local HVM guest OS users to cause a denial of service via a large number of changes to the callback method (HVM_PARAM_CALLBACK_IRQ).",
        "git_url": "https://github.com/xen-project/xen/commit/5c1048565ba5b240f47203bdb67572bee73d639e",
        "commit_title": "x86: make debug output consistent in hvm_set_callback_via",
        "commit_text": " The unconditional printks in the switch statement of the hvm_set_callback_via function results in Xen log spam in non debug versions of Xen. The printks are for debug output only so conditionally compile the entire switch statement on debug versions of Xen only.  This is XSA-169. ",
        "func_before": "void hvm_set_callback_via(struct domain *d, uint64_t via)\n{\n    struct hvm_irq *hvm_irq = &d->arch.hvm_domain.irq;\n    unsigned int gsi=0, pdev=0, pintx=0;\n    uint8_t via_type;\n\n    via_type = (uint8_t)(via >> 56) + 1;\n    if ( ((via_type == HVMIRQ_callback_gsi) && (via == 0)) ||\n         (via_type > HVMIRQ_callback_vector) )\n        via_type = HVMIRQ_callback_none;\n\n    if ( via_type != HVMIRQ_callback_vector &&\n         (!has_vlapic(d) || !has_vioapic(d) || !has_vpic(d)) )\n        return;\n\n    spin_lock(&d->arch.hvm_domain.irq_lock);\n\n    /* Tear down old callback via. */\n    if ( hvm_irq->callback_via_asserted )\n    {\n        switch ( hvm_irq->callback_via_type )\n        {\n        case HVMIRQ_callback_gsi:\n            gsi = hvm_irq->callback_via.gsi;\n            if ( (--hvm_irq->gsi_assert_count[gsi] == 0) && (gsi <= 15) )\n                vpic_irq_negative_edge(d, gsi);\n            break;\n        case HVMIRQ_callback_pci_intx:\n            pdev  = hvm_irq->callback_via.pci.dev;\n            pintx = hvm_irq->callback_via.pci.intx;\n            __hvm_pci_intx_deassert(d, pdev, pintx);\n            break;\n        default:\n            break;\n        }\n    }\n\n    /* Set up new callback via. */\n    switch ( hvm_irq->callback_via_type = via_type )\n    {\n    case HVMIRQ_callback_gsi:\n        gsi = hvm_irq->callback_via.gsi = (uint8_t)via;\n        if ( (gsi == 0) || (gsi >= ARRAY_SIZE(hvm_irq->gsi_assert_count)) )\n            hvm_irq->callback_via_type = HVMIRQ_callback_none;\n        else if ( hvm_irq->callback_via_asserted &&\n                  (hvm_irq->gsi_assert_count[gsi]++ == 0) )\n        {\n            vioapic_irq_positive_edge(d, gsi);\n            if ( gsi <= 15 )\n                vpic_irq_positive_edge(d, gsi);\n        }\n        break;\n    case HVMIRQ_callback_pci_intx:\n        pdev  = hvm_irq->callback_via.pci.dev  = (uint8_t)(via >> 11) & 31;\n        pintx = hvm_irq->callback_via.pci.intx = (uint8_t)via & 3;\n        if ( hvm_irq->callback_via_asserted )\n             __hvm_pci_intx_assert(d, pdev, pintx);\n        break;\n    case HVMIRQ_callback_vector:\n        hvm_irq->callback_via.vector = (uint8_t)via;\n        break;\n    default:\n        break;\n    }\n\n    spin_unlock(&d->arch.hvm_domain.irq_lock);\n\n    dprintk(XENLOG_G_INFO, \"Dom%u callback via changed to \", d->domain_id);\n    switch ( via_type )\n    {\n    case HVMIRQ_callback_gsi:\n        printk(\"GSI %u\\n\", gsi);\n        break;\n    case HVMIRQ_callback_pci_intx:\n        printk(\"PCI INTx Dev 0x%02x Int%c\\n\", pdev, 'A' + pintx);\n        break;\n    case HVMIRQ_callback_vector:\n        printk(\"Direct Vector 0x%02x\\n\", (uint8_t)via);\n        break;\n    default:\n        printk(\"None\\n\");\n        break;\n    }\n}",
        "func": "void hvm_set_callback_via(struct domain *d, uint64_t via)\n{\n    struct hvm_irq *hvm_irq = &d->arch.hvm_domain.irq;\n    unsigned int gsi=0, pdev=0, pintx=0;\n    uint8_t via_type;\n\n    via_type = (uint8_t)(via >> 56) + 1;\n    if ( ((via_type == HVMIRQ_callback_gsi) && (via == 0)) ||\n         (via_type > HVMIRQ_callback_vector) )\n        via_type = HVMIRQ_callback_none;\n\n    if ( via_type != HVMIRQ_callback_vector &&\n         (!has_vlapic(d) || !has_vioapic(d) || !has_vpic(d)) )\n        return;\n\n    spin_lock(&d->arch.hvm_domain.irq_lock);\n\n    /* Tear down old callback via. */\n    if ( hvm_irq->callback_via_asserted )\n    {\n        switch ( hvm_irq->callback_via_type )\n        {\n        case HVMIRQ_callback_gsi:\n            gsi = hvm_irq->callback_via.gsi;\n            if ( (--hvm_irq->gsi_assert_count[gsi] == 0) && (gsi <= 15) )\n                vpic_irq_negative_edge(d, gsi);\n            break;\n        case HVMIRQ_callback_pci_intx:\n            pdev  = hvm_irq->callback_via.pci.dev;\n            pintx = hvm_irq->callback_via.pci.intx;\n            __hvm_pci_intx_deassert(d, pdev, pintx);\n            break;\n        default:\n            break;\n        }\n    }\n\n    /* Set up new callback via. */\n    switch ( hvm_irq->callback_via_type = via_type )\n    {\n    case HVMIRQ_callback_gsi:\n        gsi = hvm_irq->callback_via.gsi = (uint8_t)via;\n        if ( (gsi == 0) || (gsi >= ARRAY_SIZE(hvm_irq->gsi_assert_count)) )\n            hvm_irq->callback_via_type = HVMIRQ_callback_none;\n        else if ( hvm_irq->callback_via_asserted &&\n                  (hvm_irq->gsi_assert_count[gsi]++ == 0) )\n        {\n            vioapic_irq_positive_edge(d, gsi);\n            if ( gsi <= 15 )\n                vpic_irq_positive_edge(d, gsi);\n        }\n        break;\n    case HVMIRQ_callback_pci_intx:\n        pdev  = hvm_irq->callback_via.pci.dev  = (uint8_t)(via >> 11) & 31;\n        pintx = hvm_irq->callback_via.pci.intx = (uint8_t)via & 3;\n        if ( hvm_irq->callback_via_asserted )\n             __hvm_pci_intx_assert(d, pdev, pintx);\n        break;\n    case HVMIRQ_callback_vector:\n        hvm_irq->callback_via.vector = (uint8_t)via;\n        break;\n    default:\n        break;\n    }\n\n    spin_unlock(&d->arch.hvm_domain.irq_lock);\n\n#ifndef NDEBUG\n    printk(XENLOG_G_INFO \"Dom%u callback via changed to \", d->domain_id);\n    switch ( via_type )\n    {\n    case HVMIRQ_callback_gsi:\n        printk(\"GSI %u\\n\", gsi);\n        break;\n    case HVMIRQ_callback_pci_intx:\n        printk(\"PCI INTx Dev 0x%02x Int%c\\n\", pdev, 'A' + pintx);\n        break;\n    case HVMIRQ_callback_vector:\n        printk(\"Direct Vector 0x%02x\\n\", (uint8_t)via);\n        break;\n    default:\n        printk(\"None\\n\");\n        break;\n    }\n#endif\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -65,7 +65,8 @@\n \n     spin_unlock(&d->arch.hvm_domain.irq_lock);\n \n-    dprintk(XENLOG_G_INFO, \"Dom%u callback via changed to \", d->domain_id);\n+#ifndef NDEBUG\n+    printk(XENLOG_G_INFO \"Dom%u callback via changed to \", d->domain_id);\n     switch ( via_type )\n     {\n     case HVMIRQ_callback_gsi:\n@@ -81,4 +82,5 @@\n         printk(\"None\\n\");\n         break;\n     }\n+#endif\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    dprintk(XENLOG_G_INFO, \"Dom%u callback via changed to \", d->domain_id);"
            ],
            "added_lines": [
                "#ifndef NDEBUG",
                "    printk(XENLOG_G_INFO \"Dom%u callback via changed to \", d->domain_id);",
                "#endif"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-8400",
        "func_name": "shellinabox/initSSL",
        "description": "The HTTPS fallback implementation in Shell In A Box (aka shellinabox) before 2.19 makes it easier for remote attackers to conduct DNS rebinding attacks via the \"/plain\" URL.",
        "git_url": "https://github.com/shellinabox/shellinabox/commit/4aa0eb97e4c90490a9c84a0d8bd57cd22572c37a",
        "commit_title": "Disable HTTP fallback via \"/plain\" URL (CVE-2015-8400)",
        "commit_text": " * Disabled all methods of HTTP fallback when HTTPS is enabled. This   is enforced on server side so that even modified client code (JS)   can not redirect client from HTTPS to HTTP, like it was possible   before (issue #355). * Current solution unfortunately also disables automatic upgrade from   HTTP to HTTPS (when available), since all non-SSL connections are   droped immediately.",
        "func_before": "void initSSL(struct SSLSupport *ssl) {\n  ssl->enabled               = serverSupportsSSL();\n  ssl->sslContext            = NULL;\n  ssl->sniCertificatePattern = NULL;\n  ssl->generateMissing       = 0;\n  ssl->renegotiationCount    = 0;\n  initTrie(&ssl->sniContexts, sslDestroyCachedContext, ssl);\n}",
        "func": "void initSSL(struct SSLSupport *ssl) {\n  ssl->enabled               = serverSupportsSSL();\n  ssl->force                 = 0;\n  ssl->sslContext            = NULL;\n  ssl->sniCertificatePattern = NULL;\n  ssl->generateMissing       = 0;\n  ssl->renegotiationCount    = 0;\n  initTrie(&ssl->sniContexts, sslDestroyCachedContext, ssl);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,6 @@\n void initSSL(struct SSLSupport *ssl) {\n   ssl->enabled               = serverSupportsSSL();\n+  ssl->force                 = 0;\n   ssl->sslContext            = NULL;\n   ssl->sniCertificatePattern = NULL;\n   ssl->generateMissing       = 0;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "  ssl->force                 = 0;"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-8400",
        "func_name": "shellinabox/httpHandleConnection",
        "description": "The HTTPS fallback implementation in Shell In A Box (aka shellinabox) before 2.19 makes it easier for remote attackers to conduct DNS rebinding attacks via the \"/plain\" URL.",
        "git_url": "https://github.com/shellinabox/shellinabox/commit/4aa0eb97e4c90490a9c84a0d8bd57cd22572c37a",
        "commit_title": "Disable HTTP fallback via \"/plain\" URL (CVE-2015-8400)",
        "commit_text": " * Disabled all methods of HTTP fallback when HTTPS is enabled. This   is enforced on server side so that even modified client code (JS)   can not redirect client from HTTPS to HTTP, like it was possible   before (issue #355). * Current solution unfortunately also disables automatic upgrade from   HTTP to HTTPS (when available), since all non-SSL connections are   droped immediately.",
        "func_before": "int httpHandleConnection(struct ServerConnection *connection, void *http_,\n                         short *events, short revents) {\n  struct HttpConnection *http        = (struct HttpConnection *)http_;\n  struct Trie *handlers              = serverGetHttpHandlers(http->server);\n  http->connection                   = connection;\n  int  bytes;\n  do {\n    bytes                            = 0;\n    *events                          = 0;\n    char buf[4096];\n    int  eof                         = http->closed;\n    if ((revents & POLLIN) && !http->closed) {\n      bytes                          = httpRead(http, buf, sizeof(buf));\n      if (bytes > 0) {\n        http->headerLength          += bytes;\n        if (http->headerLength > MAX_HEADER_LENGTH) {\n          debug(\"[http] Connection closed due to exceeded header size!\");\n          httpSendReply(http, 413, \"Header too big\", NO_MSG);\n          bytes                      = 0;\n          eof                        = 1;\n        }\n      } else {\n        if (bytes == 0 || errno != EAGAIN) {\n          httpCloseRead(http);\n          eof                        = 1;\n        } else {\n          if (http->sslHndl && http->lastError == SSL_ERROR_WANT_WRITE) {\n            *events                 |= POLLOUT;\n          }\n        }\n        bytes                        = 0;\n      }\n    }\n\n    if (bytes > 0 && http->state == SNIFFING_SSL) {\n      // Assume that all legitimate HTTP commands start with a sequence of\n      // letters followed by a space character. If we don't see this pattern,\n      // or if the method does not match one of the known methods, we try\n      // switching to SSL, instead.\n      int isSSL                      = 0;\n      char method[12]                = { 0 };\n      for (int i = -http->partialLength, j = 0, ch;\n           (ch = httpGetChar(http, buf, bytes, &i)) != -1;\n           j++) {\n        if ((j > 0 && (ch == ' ' || ch == '\\t')) ||\n            ch == '\\r' || ch == '\\n') {\n          isSSL                      = strcmp(method, \"OPTIONS\") &&\n                                       strcmp(method, \"GET\") &&\n                                       strcmp(method, \"HEAD\") &&\n                                       strcmp(method, \"POST\") &&\n                                       strcmp(method, \"PUT\") &&\n                                       strcmp(method, \"DELETE\") &&\n                                       strcmp(method, \"TRACE\") &&\n                                       strcmp(method, \"CONNECT\");\n          http->state                = COMMAND;\n          break;\n        } else if (j >= (int)sizeof(method)-1 ||\n                   ch < 'A' || (ch > 'Z' && ch < 'a') || ch > 'z') {\n          isSSL                      = 1;\n          http->state                = COMMAND;\n          break;\n        } else {\n          method[j]                  = ch & ~0x20;\n        }\n      }\n      if (isSSL) {\n        if (httpPromoteToSSL(http, buf, bytes) < 0) {\n          httpCloseRead(http);\n          bytes                      = 0;\n          eof                        = 1;\n        } else {\n          http->headerLength         = 0;\n          *events                   |= POLLIN;\n          continue;\n        }\n      }\n    }\n\n    if (bytes > 0 || (eof && http->partial)) {\n      check(!!http->partial == !!http->partialLength);\n      int  offset                    = -http->partialLength;\n      int  eob                       = 0;\n      do {\n        int pushBack                 = 0;\n        int consumed                 = 0;\n        if (http->state == SNIFFING_SSL || http->state == COMMAND ||\n            http->state == HEADERS) {\n          check(!http->expecting);\n          int  lineLength            = 0;\n          int  colon                 = -1;\n          int  firstSpace            = -1;\n          int  lastSpace             = -1;\n          int  fullLine              = 1;\n          for (int i = offset; ; lineLength++) {\n            int ch                   = httpGetChar(http, buf, bytes, &i);\n            if (ch == ':') {\n              if (colon < 0) {\n                colon                = lineLength;\n              }\n            } else if (ch == ' ' || ch == '\\t') {\n              if (firstSpace < 0) {\n                firstSpace           = lineLength;\n              } else {\n                lastSpace            = lineLength;\n              }\n            } else if (ch == '\\n') {\n              break;\n            } else if (ch == -1) {\n              fullLine               = 0;\n              eob                    = 1;\n              break;\n            }\n          }\n          if (fullLine || eof) {\n            consumed                 = lineLength + 1;\n            if (lineLength) {\n              if (http->state == SNIFFING_SSL || http->state == COMMAND) {\n                if (!httpParseCommand(http, offset, buf, bytes, firstSpace,\n                                      lastSpace, lineLength)) {\n                  break;\n                }\n              } else {\n                check(http->state == HEADERS);\n                if (!httpParseHeaders(http, handlers, offset, buf, bytes,\n                                      colon, lineLength)) {\n                  break;\n                }\n              }\n            }\n          } else {\n            pushBack                 = lineLength;\n          }\n        } else if (http->state == PAYLOAD ||\n                   http->state == DISCARD_PAYLOAD) {\n          if (http->expecting) {\n            int len                  = bytes - offset;\n            if (http->expecting > 0 &&\n                len > http->expecting) {\n              len                    = http->expecting;\n            }\n            if (http->state == PAYLOAD) {\n              len                    = httpParsePayload(http, offset, buf,\n                                                        len + offset);\n            }\n            consumed                 = len;\n            pushBack                 = bytes - offset - len;\n          }\n        } else if (http->state == WEBSOCKET) {\n          if (!httpHandleWebSocket(http, offset, buf, bytes)) {\n            httpCloseRead(http);\n            break;\n          }\n          consumed                  += bytes - offset;\n        } else {\n          check(0);\n        }\n\n        offset                      += consumed;\n        if (pushBack) {\n          check(offset + pushBack == bytes);\n          if (offset >= 0) {\n            check(http->partial      = realloc(http->partial, pushBack));\n            memcpy(http->partial, buf + offset, pushBack);\n          } else if (pushBack != http->partialLength) {\n            char *partial;\n            check(partial            = malloc(pushBack));\n            for (int i = offset, j = 0; j < pushBack; j++) {\n              partial[j]             = httpGetChar(http, buf, bytes, &i);\n            }\n            free(http->partial);\n            http->partial            = partial;\n          }\n          http->partialLength        = pushBack;\n          offset                     = -pushBack;\n          break;\n        } else {\n          eob                       |= offset >= bytes;\n        }\n      } while (!eob && !http->closed);\n      if (http->closed || offset >= 0) {\n        free(http->partial);\n        http->partial                = NULL;\n        http->partialLength          = 0;\n      } else if (-offset != http->partialLength) {\n        check(-offset < http->partialLength);\n        memmove(http->partial, http->partial + http->partialLength + offset,\n                -offset);\n        http->partialLength          = -offset;\n      }\n    }\n\n    // If the peer closed the connection, clean up now.\n    if (eof) {\n      check(!http->partial);\n      switch (http->state) {\n      case SNIFFING_SSL:\n      case COMMAND:\n        break;\n      case HEADERS:\n        check(!http->expecting);\n        http->callback               = NULL;\n        http->arg                    = NULL;\n        httpHandleCommand(http, handlers);\n        httpCloseRead(http);\n        httpSetState(http, COMMAND);\n        break;\n      case PAYLOAD:\n      case DISCARD_PAYLOAD:\n      case WEBSOCKET:\n        http->expecting              = 0;\n        httpCloseRead(http);\n        httpSetState(http, COMMAND);\n        break;\n      }\n    }\n\n    for (;;) {\n      // Try to write any pending outgoing data\n      if (http->msg && http->msgLength > 0) {\n        int wrote                    = httpWrite(http, http->msg,\n                                                 http->msgLength);\n        if (wrote < 0 && errno != EAGAIN) {\n          httpCloseRead(http);\n          free(http->msg);\n          http->msgLength            = 0;\n          http->msg                  = NULL;\n          break;\n        } else if (wrote > 0) {\n          if (wrote == http->msgLength) {\n            free(http->msg);\n            http->msgLength          = 0;\n            http->msg                = NULL;\n          } else {\n            memmove(http->msg, http->msg + wrote, http->msgLength - wrote);\n            http->msgLength         -= wrote;\n          }\n        }\n        // SSL might require reading in order to write\n        else if (wrote < 0 && errno == EAGAIN && http->sslHndl) {\n          if (http->lastError == SSL_ERROR_WANT_READ && !http->closed) {\n            *events                 |= POLLIN;\n          }\n        }\n      }\n\n      // If the callback only provided partial data, refill the outgoing\n      // buffer whenever it runs low.\n      if (http->isPartialReply && (!http->msg || http->msgLength <= 0)) {\n        httpConsumePayload(http, \"\", 0);\n      } else {\n        break;\n      }\n    }\n\n    *events                         |=\n      (*events & ~(POLLIN|POLLOUT)) |\n      (!http->closed && ((http->state != PAYLOAD &&\n                          http->state != DISCARD_PAYLOAD) ||\n                         http->expecting) ? POLLIN : 0) |\n      (http->msg || http->isPartialReply ? POLLOUT : 0);\n\n    connection                       = httpGetServerConnection(http);\n    int timedOut                     = serverGetTimeout(connection) < 0;\n    if (timedOut) {\n      free(http->partial);\n      http->partial                  = NULL;\n      http->partialLength            = 0;\n      free(http->msg);\n      http->msg                      = NULL;\n      http->msgLength                = 0;\n    }\n\n    if ((!(*events || http->isSuspended) || timedOut) && http->sslHndl) {\n      *events                        = 0;\n      serverSetTimeout(connection, 1);\n      int wasAlreadyClosed           = http->closed;\n      httpCloseRead(http);\n      dcheck(!ERR_peek_error());\n      sslBlockSigPipe();\n      int rc                         = SSL_shutdown(http->sslHndl);\n      switch (rc) {\n      case 1:\n        sslFreeHndl(&http->sslHndl);\n        break;\n      case 0:\n        if (!wasAlreadyClosed) {\n          *events                   |= POLLIN;\n        }\n        break;\n      case -1:\n        switch (SSL_get_error(http->sslHndl, rc)) {\n        case SSL_ERROR_WANT_READ:\n          if (!wasAlreadyClosed) {\n            *events                 |= POLLIN;\n          }\n          break;\n        case SSL_ERROR_WANT_WRITE:\n          *events                   |= POLLOUT;\n          break;\n        }\n        break;\n      }\n      ERR_clear_error();\n      dcheck(!ERR_peek_error());\n      if (sslUnblockSigPipe()) {\n        *events                      = 0;\n        sslFreeHndl(&http->sslHndl);\n      }\n    } else if (!http->sslHndl && timedOut) {\n      *events                        = 0;\n      serverSetTimeout(connection, 0);\n      httpCloseRead(http);\n    }\n    revents                          = POLLIN | POLLOUT;\n  } while (bytes > 0 && *events & POLLIN && !http->closed);\n  return (*events & (POLLIN|POLLOUT)) ||\n         (!http->closed && http->isSuspended);\n}",
        "func": "int httpHandleConnection(struct ServerConnection *connection, void *http_,\n                         short *events, short revents) {\n  struct HttpConnection *http        = (struct HttpConnection *)http_;\n  struct Trie *handlers              = serverGetHttpHandlers(http->server);\n  http->connection                   = connection;\n  int  bytes;\n  do {\n    bytes                            = 0;\n    *events                          = 0;\n    char buf[4096];\n    int  eof                         = http->closed;\n    if ((revents & POLLIN) && !http->closed) {\n      bytes                          = httpRead(http, buf, sizeof(buf));\n      if (bytes > 0) {\n        http->headerLength          += bytes;\n        if (http->headerLength > MAX_HEADER_LENGTH) {\n          debug(\"[http] Connection closed due to exceeded header size!\");\n          httpSendReply(http, 413, \"Header too big\", NO_MSG);\n          bytes                      = 0;\n          eof                        = 1;\n        }\n      } else {\n        if (bytes == 0 || errno != EAGAIN) {\n          httpCloseRead(http);\n          eof                        = 1;\n        } else {\n          if (http->sslHndl && http->lastError == SSL_ERROR_WANT_WRITE) {\n            *events                 |= POLLOUT;\n          }\n        }\n        bytes                        = 0;\n      }\n    }\n\n    if (bytes > 0 && http->state == SNIFFING_SSL) {\n      // Assume that all legitimate HTTP commands start with a sequence of\n      // letters followed by a space character. If we don't see this pattern,\n      // or if the method does not match one of the known methods, we try\n      // switching to SSL, instead.\n      int isSSL                      = 0;\n      char method[12]                = { 0 };\n      for (int i = -http->partialLength, j = 0, ch;\n           (ch = httpGetChar(http, buf, bytes, &i)) != -1;\n           j++) {\n        if ((j > 0 && (ch == ' ' || ch == '\\t')) ||\n            ch == '\\r' || ch == '\\n') {\n          isSSL                      = strcmp(method, \"OPTIONS\") &&\n                                       strcmp(method, \"GET\") &&\n                                       strcmp(method, \"HEAD\") &&\n                                       strcmp(method, \"POST\") &&\n                                       strcmp(method, \"PUT\") &&\n                                       strcmp(method, \"DELETE\") &&\n                                       strcmp(method, \"TRACE\") &&\n                                       strcmp(method, \"CONNECT\");\n          http->state                = COMMAND;\n          break;\n        } else if (j >= (int)sizeof(method)-1 ||\n                   ch < 'A' || (ch > 'Z' && ch < 'a') || ch > 'z') {\n          isSSL                      = 1;\n          http->state                = COMMAND;\n          break;\n        } else {\n          method[j]                  = ch & ~0x20;\n        }\n      }\n      if (isSSL) {\n        if (httpPromoteToSSL(http, buf, bytes) < 0) {\n          httpCloseRead(http);\n          bytes                      = 0;\n          eof                        = 1;\n        } else {\n          http->headerLength         = 0;\n          *events                   |= POLLIN;\n          continue;\n        }\n      } else {\n        if (http->ssl && http->ssl->enabled && http->ssl->force) {\n          debug(\"[http] Non-SSL connections not allowed!\");\n          httpCloseRead(http);\n          bytes                      = 0;\n          eof                        = 1;\n        }\n      }\n    }\n\n    if (bytes > 0 || (eof && http->partial)) {\n      check(!!http->partial == !!http->partialLength);\n      int  offset                    = -http->partialLength;\n      int  eob                       = 0;\n      do {\n        int pushBack                 = 0;\n        int consumed                 = 0;\n        if (http->state == SNIFFING_SSL || http->state == COMMAND ||\n            http->state == HEADERS) {\n          check(!http->expecting);\n          int  lineLength            = 0;\n          int  colon                 = -1;\n          int  firstSpace            = -1;\n          int  lastSpace             = -1;\n          int  fullLine              = 1;\n          for (int i = offset; ; lineLength++) {\n            int ch                   = httpGetChar(http, buf, bytes, &i);\n            if (ch == ':') {\n              if (colon < 0) {\n                colon                = lineLength;\n              }\n            } else if (ch == ' ' || ch == '\\t') {\n              if (firstSpace < 0) {\n                firstSpace           = lineLength;\n              } else {\n                lastSpace            = lineLength;\n              }\n            } else if (ch == '\\n') {\n              break;\n            } else if (ch == -1) {\n              fullLine               = 0;\n              eob                    = 1;\n              break;\n            }\n          }\n          if (fullLine || eof) {\n            consumed                 = lineLength + 1;\n            if (lineLength) {\n              if (http->state == SNIFFING_SSL || http->state == COMMAND) {\n                if (!httpParseCommand(http, offset, buf, bytes, firstSpace,\n                                      lastSpace, lineLength)) {\n                  break;\n                }\n              } else {\n                check(http->state == HEADERS);\n                if (!httpParseHeaders(http, handlers, offset, buf, bytes,\n                                      colon, lineLength)) {\n                  break;\n                }\n              }\n            }\n          } else {\n            pushBack                 = lineLength;\n          }\n        } else if (http->state == PAYLOAD ||\n                   http->state == DISCARD_PAYLOAD) {\n          if (http->expecting) {\n            int len                  = bytes - offset;\n            if (http->expecting > 0 &&\n                len > http->expecting) {\n              len                    = http->expecting;\n            }\n            if (http->state == PAYLOAD) {\n              len                    = httpParsePayload(http, offset, buf,\n                                                        len + offset);\n            }\n            consumed                 = len;\n            pushBack                 = bytes - offset - len;\n          }\n        } else if (http->state == WEBSOCKET) {\n          if (!httpHandleWebSocket(http, offset, buf, bytes)) {\n            httpCloseRead(http);\n            break;\n          }\n          consumed                  += bytes - offset;\n        } else {\n          check(0);\n        }\n\n        offset                      += consumed;\n        if (pushBack) {\n          check(offset + pushBack == bytes);\n          if (offset >= 0) {\n            check(http->partial      = realloc(http->partial, pushBack));\n            memcpy(http->partial, buf + offset, pushBack);\n          } else if (pushBack != http->partialLength) {\n            char *partial;\n            check(partial            = malloc(pushBack));\n            for (int i = offset, j = 0; j < pushBack; j++) {\n              partial[j]             = httpGetChar(http, buf, bytes, &i);\n            }\n            free(http->partial);\n            http->partial            = partial;\n          }\n          http->partialLength        = pushBack;\n          offset                     = -pushBack;\n          break;\n        } else {\n          eob                       |= offset >= bytes;\n        }\n      } while (!eob && !http->closed);\n      if (http->closed || offset >= 0) {\n        free(http->partial);\n        http->partial                = NULL;\n        http->partialLength          = 0;\n      } else if (-offset != http->partialLength) {\n        check(-offset < http->partialLength);\n        memmove(http->partial, http->partial + http->partialLength + offset,\n                -offset);\n        http->partialLength          = -offset;\n      }\n    }\n\n    // If the peer closed the connection, clean up now.\n    if (eof) {\n      check(!http->partial);\n      switch (http->state) {\n      case SNIFFING_SSL:\n      case COMMAND:\n        break;\n      case HEADERS:\n        check(!http->expecting);\n        http->callback               = NULL;\n        http->arg                    = NULL;\n        httpHandleCommand(http, handlers);\n        httpCloseRead(http);\n        httpSetState(http, COMMAND);\n        break;\n      case PAYLOAD:\n      case DISCARD_PAYLOAD:\n      case WEBSOCKET:\n        http->expecting              = 0;\n        httpCloseRead(http);\n        httpSetState(http, COMMAND);\n        break;\n      }\n    }\n\n    for (;;) {\n      // Try to write any pending outgoing data\n      if (http->msg && http->msgLength > 0) {\n        int wrote                    = httpWrite(http, http->msg,\n                                                 http->msgLength);\n        if (wrote < 0 && errno != EAGAIN) {\n          httpCloseRead(http);\n          free(http->msg);\n          http->msgLength            = 0;\n          http->msg                  = NULL;\n          break;\n        } else if (wrote > 0) {\n          if (wrote == http->msgLength) {\n            free(http->msg);\n            http->msgLength          = 0;\n            http->msg                = NULL;\n          } else {\n            memmove(http->msg, http->msg + wrote, http->msgLength - wrote);\n            http->msgLength         -= wrote;\n          }\n        }\n        // SSL might require reading in order to write\n        else if (wrote < 0 && errno == EAGAIN && http->sslHndl) {\n          if (http->lastError == SSL_ERROR_WANT_READ && !http->closed) {\n            *events                 |= POLLIN;\n          }\n        }\n      }\n\n      // If the callback only provided partial data, refill the outgoing\n      // buffer whenever it runs low.\n      if (http->isPartialReply && (!http->msg || http->msgLength <= 0)) {\n        httpConsumePayload(http, \"\", 0);\n      } else {\n        break;\n      }\n    }\n\n    *events                         |=\n      (*events & ~(POLLIN|POLLOUT)) |\n      (!http->closed && ((http->state != PAYLOAD &&\n                          http->state != DISCARD_PAYLOAD) ||\n                         http->expecting) ? POLLIN : 0) |\n      (http->msg || http->isPartialReply ? POLLOUT : 0);\n\n    connection                       = httpGetServerConnection(http);\n    int timedOut                     = serverGetTimeout(connection) < 0;\n    if (timedOut) {\n      free(http->partial);\n      http->partial                  = NULL;\n      http->partialLength            = 0;\n      free(http->msg);\n      http->msg                      = NULL;\n      http->msgLength                = 0;\n    }\n\n    if ((!(*events || http->isSuspended) || timedOut) && http->sslHndl) {\n      *events                        = 0;\n      serverSetTimeout(connection, 1);\n      int wasAlreadyClosed           = http->closed;\n      httpCloseRead(http);\n      dcheck(!ERR_peek_error());\n      sslBlockSigPipe();\n      int rc                         = SSL_shutdown(http->sslHndl);\n      switch (rc) {\n      case 1:\n        sslFreeHndl(&http->sslHndl);\n        break;\n      case 0:\n        if (!wasAlreadyClosed) {\n          *events                   |= POLLIN;\n        }\n        break;\n      case -1:\n        switch (SSL_get_error(http->sslHndl, rc)) {\n        case SSL_ERROR_WANT_READ:\n          if (!wasAlreadyClosed) {\n            *events                 |= POLLIN;\n          }\n          break;\n        case SSL_ERROR_WANT_WRITE:\n          *events                   |= POLLOUT;\n          break;\n        }\n        break;\n      }\n      ERR_clear_error();\n      dcheck(!ERR_peek_error());\n      if (sslUnblockSigPipe()) {\n        *events                      = 0;\n        sslFreeHndl(&http->sslHndl);\n      }\n    } else if (!http->sslHndl && timedOut) {\n      *events                        = 0;\n      serverSetTimeout(connection, 0);\n      httpCloseRead(http);\n    }\n    revents                          = POLLIN | POLLOUT;\n  } while (bytes > 0 && *events & POLLIN && !http->closed);\n  return (*events & (POLLIN|POLLOUT)) ||\n         (!http->closed && http->isSuspended);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -72,6 +72,13 @@\n           http->headerLength         = 0;\n           *events                   |= POLLIN;\n           continue;\n+        }\n+      } else {\n+        if (http->ssl && http->ssl->enabled && http->ssl->force) {\n+          debug(\"[http] Non-SSL connections not allowed!\");\n+          httpCloseRead(http);\n+          bytes                      = 0;\n+          eof                        = 1;\n         }\n       }\n     }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "        }",
                "      } else {",
                "        if (http->ssl && http->ssl->enabled && http->ssl->force) {",
                "          debug(\"[http] Non-SSL connections not allowed!\");",
                "          httpCloseRead(http);",
                "          bytes                      = 0;",
                "          eof                        = 1;"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-8400",
        "func_name": "shellinabox/setUpSSL",
        "description": "The HTTPS fallback implementation in Shell In A Box (aka shellinabox) before 2.19 makes it easier for remote attackers to conduct DNS rebinding attacks via the \"/plain\" URL.",
        "git_url": "https://github.com/shellinabox/shellinabox/commit/4aa0eb97e4c90490a9c84a0d8bd57cd22572c37a",
        "commit_title": "Disable HTTP fallback via \"/plain\" URL (CVE-2015-8400)",
        "commit_text": " * Disabled all methods of HTTP fallback when HTTPS is enabled. This   is enforced on server side so that even modified client code (JS)   can not redirect client from HTTPS to HTTP, like it was possible   before (issue #355). * Current solution unfortunately also disables automatic upgrade from   HTTP to HTTPS (when available), since all non-SSL connections are   droped immediately.",
        "func_before": "static void setUpSSL(Server *server) {\n  serverEnableSSL(server, enableSSL);\n\n  // Enable SSL support (if available)\n  if (enableSSL) {\n    check(serverSupportsSSL());\n    if (certificateFd >= 0) {\n      serverSetCertificateFd(server, certificateFd);\n    } else if (certificateDir) {\n      char *tmp;\n      if (strchr(certificateDir, '%')) {\n        fatal(\"[ssl] Invalid certificate directory name \\\"%s\\\".\", certificateDir);\n      }\n      check(tmp = stringPrintf(NULL, \"%s/certificate%%s.pem\", certificateDir));\n      serverSetCertificate(server, tmp, 1);\n      free(tmp);\n    } else {\n      serverSetCertificate(server, \"certificate%s.pem\", 1);\n    }\n  }\n}",
        "func": "static void setUpSSL(Server *server) {\n\n  serverSetupSSL(server, enableSSL, forceSSL);\n\n  // Enable SSL support (if available)\n  if (enableSSL) {\n    check(serverSupportsSSL());\n    if (certificateFd >= 0) {\n      serverSetCertificateFd(server, certificateFd);\n    } else if (certificateDir) {\n      char *tmp;\n      if (strchr(certificateDir, '%')) {\n        fatal(\"[ssl] Invalid certificate directory name \\\"%s\\\".\", certificateDir);\n      }\n      check(tmp = stringPrintf(NULL, \"%s/certificate%%s.pem\", certificateDir));\n      serverSetCertificate(server, tmp, 1);\n      free(tmp);\n    } else {\n      serverSetCertificate(server, \"certificate%s.pem\", 1);\n    }\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,6 @@\n static void setUpSSL(Server *server) {\n-  serverEnableSSL(server, enableSSL);\n+\n+  serverSetupSSL(server, enableSSL, forceSSL);\n \n   // Enable SSL support (if available)\n   if (enableSSL) {",
        "diff_line_info": {
            "deleted_lines": [
                "  serverEnableSSL(server, enableSSL);"
            ],
            "added_lines": [
                "",
                "  serverSetupSSL(server, enableSSL, forceSSL);"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-1616",
        "func_name": "chromium/CustomButton::AcceleratorPressed",
        "description": "The CustomButton::AcceleratorPressed function in ui/views/controls/button/custom_button.cc in Google Chrome before 48.0.2564.82 allows remote attackers to spoof URLs via vectors involving an unfocused custom button.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/297ae873b471a46929ea39697b121c0b411434ee",
        "commit_title": "Custom buttons should only handle accelerators when focused.",
        "commit_text": "   ",
        "func_before": "bool CustomButton::AcceleratorPressed(const ui::Accelerator& accelerator) {\n  SetState(STATE_NORMAL);\n  // TODO(beng): remove once NotifyClick takes ui::Event.\n  ui::MouseEvent synthetic_event(\n      ui::ET_MOUSE_RELEASED, gfx::Point(), gfx::Point(), ui::EventTimeForNow(),\n      ui::EF_LEFT_MOUSE_BUTTON, ui::EF_LEFT_MOUSE_BUTTON);\n  NotifyClick(synthetic_event);\n  return true;\n}",
        "func": "bool CustomButton::AcceleratorPressed(const ui::Accelerator& accelerator) {\n  // Should only handle accelerators when active. However, only top level\n  // widgets can be active, so for child widgets check if they are focused\n  // instead.\n  if ((IsChildWidget() && !FocusInChildWidget()) ||\n      (!IsChildWidget() && !GetWidget()->IsActive())) {\n    return false;\n  }\n  SetState(STATE_NORMAL);\n  // TODO(beng): remove once NotifyClick takes ui::Event.\n  ui::MouseEvent synthetic_event(\n      ui::ET_MOUSE_RELEASED, gfx::Point(), gfx::Point(), ui::EventTimeForNow(),\n      ui::EF_LEFT_MOUSE_BUTTON, ui::EF_LEFT_MOUSE_BUTTON);\n  NotifyClick(synthetic_event);\n  return true;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,11 @@\n bool CustomButton::AcceleratorPressed(const ui::Accelerator& accelerator) {\n+  // Should only handle accelerators when active. However, only top level\n+  // widgets can be active, so for child widgets check if they are focused\n+  // instead.\n+  if ((IsChildWidget() && !FocusInChildWidget()) ||\n+      (!IsChildWidget() && !GetWidget()->IsActive())) {\n+    return false;\n+  }\n   SetState(STATE_NORMAL);\n   // TODO(beng): remove once NotifyClick takes ui::Event.\n   ui::MouseEvent synthetic_event(",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "  // Should only handle accelerators when active. However, only top level",
                "  // widgets can be active, so for child widgets check if they are focused",
                "  // instead.",
                "  if ((IsChildWidget() && !FocusInChildWidget()) ||",
                "      (!IsChildWidget() && !GetWidget()->IsActive())) {",
                "    return false;",
                "  }"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-7797",
        "func_name": "ClusterLabs/pacemaker/lrmd_remote_listen",
        "description": "Pacemaker before 1.1.15, when using pacemaker remote, might allow remote attackers to cause a denial of service (node disconnection) via an unauthenticated connection.",
        "git_url": "https://github.com/ClusterLabs/pacemaker/commit/5ec24a2642bd0854b884d1a9b51d12371373b410",
        "commit_title": "Fix: remote: cl#5269 - Notify other clients of a new connection only if the handshake has completed (bsc#967388)",
        "commit_text": "",
        "func_before": "static int\nlrmd_remote_listen(gpointer data)\n{\n    int csock = 0;\n    int flag = 0;\n    unsigned laddr = 0;\n    struct sockaddr addr;\n    gnutls_session_t *session = NULL;\n    crm_client_t *new_client = NULL;\n\n    static struct mainloop_fd_callbacks lrmd_remote_fd_cb = {\n        .dispatch = lrmd_remote_client_msg,\n        .destroy = lrmd_remote_client_destroy,\n    };\n\n    laddr = sizeof(addr);\n    memset(&addr, 0, sizeof(addr));\n    getsockname(ssock, &addr, &laddr);\n\n    /* accept the connection */\n\n    if (addr.sa_family == AF_INET6) {\n        struct sockaddr_in6 sa;\n        char addr_str[INET6_ADDRSTRLEN];\n\n        laddr = sizeof(sa);\n        memset(&sa, 0, sizeof(sa));\n        csock = accept(ssock, &sa, &laddr);\n        get_ip_str((struct sockaddr *)&sa, addr_str, INET6_ADDRSTRLEN);\n        crm_info(\"New remote connection from %s\", addr_str);\n\n    } else {\n        struct sockaddr_in sa;\n        char addr_str[INET_ADDRSTRLEN];\n\n        laddr = sizeof(sa);\n        memset(&sa, 0, sizeof(sa));\n        csock = accept(ssock, &sa, &laddr);\n        get_ip_str((struct sockaddr *)&sa, addr_str, INET_ADDRSTRLEN);\n        crm_info(\"New remote connection from %s\", addr_str);\n    }\n\n    if (csock == -1) {\n        crm_err(\"accept socket failed\");\n        return TRUE;\n    }\n\n    if ((flag = fcntl(csock, F_GETFL)) >= 0) {\n        if (fcntl(csock, F_SETFL, flag | O_NONBLOCK) < 0) {\n            crm_err(\"fcntl() write failed\");\n            close(csock);\n            return TRUE;\n        }\n    } else {\n        crm_err(\"fcntl() read failed\");\n        close(csock);\n        return TRUE;\n    }\n\n    session = create_psk_tls_session(csock, GNUTLS_SERVER, psk_cred_s);\n    if (session == NULL) {\n        crm_err(\"TLS session creation failed\");\n        close(csock);\n        return TRUE;\n    }\n\n    new_client = calloc(1, sizeof(crm_client_t));\n    new_client->remote = calloc(1, sizeof(crm_remote_t));\n    new_client->kind = CRM_CLIENT_TLS;\n    new_client->remote->tls_session = session;\n    new_client->id = crm_generate_uuid();\n    new_client->remote->auth_timeout =\n        g_timeout_add(LRMD_REMOTE_AUTH_TIMEOUT, lrmd_auth_timeout_cb, new_client);\n    crm_notice(\"LRMD client connection established. %p id: %s\", new_client, new_client->id);\n\n    new_client->remote->source =\n        mainloop_add_fd(\"lrmd-remote-client\", G_PRIORITY_DEFAULT, csock, new_client,\n                        &lrmd_remote_fd_cb);\n    g_hash_table_insert(client_connections, new_client->id, new_client);\n\n    /* Alert other clients of the new connection */\n    notify_of_new_client(new_client);\n    return TRUE;\n}",
        "func": "static int\nlrmd_remote_listen(gpointer data)\n{\n    int csock = 0;\n    int flag = 0;\n    unsigned laddr = 0;\n    struct sockaddr addr;\n    gnutls_session_t *session = NULL;\n    crm_client_t *new_client = NULL;\n\n    static struct mainloop_fd_callbacks lrmd_remote_fd_cb = {\n        .dispatch = lrmd_remote_client_msg,\n        .destroy = lrmd_remote_client_destroy,\n    };\n\n    laddr = sizeof(addr);\n    memset(&addr, 0, sizeof(addr));\n    getsockname(ssock, &addr, &laddr);\n\n    /* accept the connection */\n\n    if (addr.sa_family == AF_INET6) {\n        struct sockaddr_in6 sa;\n        char addr_str[INET6_ADDRSTRLEN];\n\n        laddr = sizeof(sa);\n        memset(&sa, 0, sizeof(sa));\n        csock = accept(ssock, &sa, &laddr);\n        get_ip_str((struct sockaddr *)&sa, addr_str, INET6_ADDRSTRLEN);\n        crm_info(\"New remote connection from %s\", addr_str);\n\n    } else {\n        struct sockaddr_in sa;\n        char addr_str[INET_ADDRSTRLEN];\n\n        laddr = sizeof(sa);\n        memset(&sa, 0, sizeof(sa));\n        csock = accept(ssock, &sa, &laddr);\n        get_ip_str((struct sockaddr *)&sa, addr_str, INET_ADDRSTRLEN);\n        crm_info(\"New remote connection from %s\", addr_str);\n    }\n\n    if (csock == -1) {\n        crm_err(\"accept socket failed\");\n        return TRUE;\n    }\n\n    if ((flag = fcntl(csock, F_GETFL)) >= 0) {\n        if (fcntl(csock, F_SETFL, flag | O_NONBLOCK) < 0) {\n            crm_err(\"fcntl() write failed\");\n            close(csock);\n            return TRUE;\n        }\n    } else {\n        crm_err(\"fcntl() read failed\");\n        close(csock);\n        return TRUE;\n    }\n\n    session = create_psk_tls_session(csock, GNUTLS_SERVER, psk_cred_s);\n    if (session == NULL) {\n        crm_err(\"TLS session creation failed\");\n        close(csock);\n        return TRUE;\n    }\n\n    new_client = calloc(1, sizeof(crm_client_t));\n    new_client->remote = calloc(1, sizeof(crm_remote_t));\n    new_client->kind = CRM_CLIENT_TLS;\n    new_client->remote->tls_session = session;\n    new_client->id = crm_generate_uuid();\n    new_client->remote->auth_timeout =\n        g_timeout_add(LRMD_REMOTE_AUTH_TIMEOUT, lrmd_auth_timeout_cb, new_client);\n    crm_notice(\"LRMD client connection established. %p id: %s\", new_client, new_client->id);\n\n    new_client->remote->source =\n        mainloop_add_fd(\"lrmd-remote-client\", G_PRIORITY_DEFAULT, csock, new_client,\n                        &lrmd_remote_fd_cb);\n    g_hash_table_insert(client_connections, new_client->id, new_client);\n\n    return TRUE;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -78,7 +78,5 @@\n                         &lrmd_remote_fd_cb);\n     g_hash_table_insert(client_connections, new_client->id, new_client);\n \n-    /* Alert other clients of the new connection */\n-    notify_of_new_client(new_client);\n     return TRUE;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    /* Alert other clients of the new connection */",
                "    notify_of_new_client(new_client);"
            ],
            "added_lines": []
        }
    },
    {
        "cve_id": "CVE-2016-7797",
        "func_name": "ClusterLabs/pacemaker/lrmd_remote_client_msg",
        "description": "Pacemaker before 1.1.15, when using pacemaker remote, might allow remote attackers to cause a denial of service (node disconnection) via an unauthenticated connection.",
        "git_url": "https://github.com/ClusterLabs/pacemaker/commit/5ec24a2642bd0854b884d1a9b51d12371373b410",
        "commit_title": "Fix: remote: cl#5269 - Notify other clients of a new connection only if the handshake has completed (bsc#967388)",
        "commit_text": "",
        "func_before": "static int\nlrmd_remote_client_msg(gpointer data)\n{\n    int id = 0;\n    int rc = 0;\n    int disconnected = 0;\n    xmlNode *request = NULL;\n    crm_client_t *client = data;\n\n    if (client->remote->tls_handshake_complete == FALSE) {\n        int rc = 0;\n\n        /* Muliple calls to handshake will be required, this callback\n         * will be invoked once the client sends more handshake data. */\n        do {\n            rc = gnutls_handshake(*client->remote->tls_session);\n\n            if (rc < 0 && rc != GNUTLS_E_AGAIN) {\n                crm_err(\"Remote lrmd tls handshake failed\");\n                return -1;\n            }\n        } while (rc == GNUTLS_E_INTERRUPTED);\n\n        if (rc == 0) {\n            crm_debug(\"Remote lrmd tls handshake completed\");\n            client->remote->tls_handshake_complete = TRUE;\n            if (client->remote->auth_timeout) {\n                g_source_remove(client->remote->auth_timeout);\n            }\n            client->remote->auth_timeout = 0;\n        }\n        return 0;\n    }\n\n    rc = crm_remote_ready(client->remote, 0);\n    if (rc == 0) {\n        /* no msg to read */\n        return 0;\n    } else if (rc < 0) {\n        crm_info(\"Client disconnected during remote client read\");\n        return -1;\n    }\n\n    crm_remote_recv(client->remote, -1, &disconnected);\n\n    request = crm_remote_parse_buffer(client->remote);\n    while (request) {\n        crm_element_value_int(request, F_LRMD_REMOTE_MSG_ID, &id);\n        crm_trace(\"processing request from remote client with remote msg id %d\", id);\n        if (!client->name) {\n            const char *value = crm_element_value(request, F_LRMD_CLIENTNAME);\n\n            if (value) {\n                client->name = strdup(value);\n            }\n        }\n\n        lrmd_call_id++;\n        if (lrmd_call_id < 1) {\n            lrmd_call_id = 1;\n        }\n\n        crm_xml_add(request, F_LRMD_CLIENTID, client->id);\n        crm_xml_add(request, F_LRMD_CLIENTNAME, client->name);\n        crm_xml_add_int(request, F_LRMD_CALLID, lrmd_call_id);\n\n        process_lrmd_message(client, id, request);\n        free_xml(request);\n\n        /* process all the messages in the current buffer */\n        request = crm_remote_parse_buffer(client->remote);\n    }\n\n    if (disconnected) {\n        crm_info(\"Client disconnect detected in tls msg dispatcher.\");\n        return -1;\n    }\n\n    return 0;\n}",
        "func": "static int\nlrmd_remote_client_msg(gpointer data)\n{\n    int id = 0;\n    int rc = 0;\n    int disconnected = 0;\n    xmlNode *request = NULL;\n    crm_client_t *client = data;\n\n    if (client->remote->tls_handshake_complete == FALSE) {\n        int rc = 0;\n\n        /* Muliple calls to handshake will be required, this callback\n         * will be invoked once the client sends more handshake data. */\n        do {\n            rc = gnutls_handshake(*client->remote->tls_session);\n\n            if (rc < 0 && rc != GNUTLS_E_AGAIN) {\n                crm_err(\"Remote lrmd tls handshake failed\");\n                return -1;\n            }\n        } while (rc == GNUTLS_E_INTERRUPTED);\n\n        if (rc == 0) {\n            crm_debug(\"Remote lrmd tls handshake completed\");\n            client->remote->tls_handshake_complete = TRUE;\n            if (client->remote->auth_timeout) {\n                g_source_remove(client->remote->auth_timeout);\n            }\n            client->remote->auth_timeout = 0;\n\n            /* Alert other clients of the new connection */\n            notify_of_new_client(client);\n        }\n        return 0;\n    }\n\n    rc = crm_remote_ready(client->remote, 0);\n    if (rc == 0) {\n        /* no msg to read */\n        return 0;\n    } else if (rc < 0) {\n        crm_info(\"Client disconnected during remote client read\");\n        return -1;\n    }\n\n    crm_remote_recv(client->remote, -1, &disconnected);\n\n    request = crm_remote_parse_buffer(client->remote);\n    while (request) {\n        crm_element_value_int(request, F_LRMD_REMOTE_MSG_ID, &id);\n        crm_trace(\"processing request from remote client with remote msg id %d\", id);\n        if (!client->name) {\n            const char *value = crm_element_value(request, F_LRMD_CLIENTNAME);\n\n            if (value) {\n                client->name = strdup(value);\n            }\n        }\n\n        lrmd_call_id++;\n        if (lrmd_call_id < 1) {\n            lrmd_call_id = 1;\n        }\n\n        crm_xml_add(request, F_LRMD_CLIENTID, client->id);\n        crm_xml_add(request, F_LRMD_CLIENTNAME, client->name);\n        crm_xml_add_int(request, F_LRMD_CALLID, lrmd_call_id);\n\n        process_lrmd_message(client, id, request);\n        free_xml(request);\n\n        /* process all the messages in the current buffer */\n        request = crm_remote_parse_buffer(client->remote);\n    }\n\n    if (disconnected) {\n        crm_info(\"Client disconnect detected in tls msg dispatcher.\");\n        return -1;\n    }\n\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -28,6 +28,9 @@\n                 g_source_remove(client->remote->auth_timeout);\n             }\n             client->remote->auth_timeout = 0;\n+\n+            /* Alert other clients of the new connection */\n+            notify_of_new_client(client);\n         }\n         return 0;\n     }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "            /* Alert other clients of the new connection */",
                "            notify_of_new_client(client);"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-1296",
        "func_name": "chromium/OmniboxViewViews::EmphasizeURLComponents",
        "description": "The UnescapeURLWithAdjustmentsImpl implementation in net/base/escape.cc in Google Chrome before 45.0.2454.85 does not prevent display of Unicode LOCK characters in the omnibox, which makes it easier for remote attackers to spoof the SSL lock icon by placing one of these characters at the end of a URL, as demonstrated by the omnibox in localizations for right-to-left languages.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/1c7d9ce02925cf766fc508d4ee83424369e71548",
        "commit_title": "Omnibox: Force text field to LTR context if it is a URL.",
        "commit_text": " This means that URLs will be displayed in a left-to-right paragraph context. Right-to-left runs are still rendered RTL, but will not flip the whole URL around. For example (if \"ABC\" is Hebrew), this will render \"ABC.com\" as \"CBA.com\", rather than \"com.CBA\".  This is consistent with the behaviour in the Omnibox drop-down items (OmniboxResultView::CreateClassifiedRenderText) and status bubble (StatusBubbleViews::SetURL).    ",
        "func_before": "void OmniboxViewViews::EmphasizeURLComponents() {\n  if (!location_bar_view_)\n    return;\n  // See whether the contents are a URL with a non-empty host portion, which we\n  // should emphasize.  To check for a URL, rather than using the type returned\n  // by Parse(), ask the model, which will check the desired page transition for\n  // this input.  This can tell us whether an UNKNOWN input string is going to\n  // be treated as a search or a navigation, and is the same method the Paste\n  // And Go system uses.\n  url::Component scheme, host;\n  AutocompleteInput::ParseForEmphasizeComponents(\n      text(), ChromeAutocompleteSchemeClassifier(profile()), &scheme, &host);\n  bool grey_out_url = text().substr(scheme.begin, scheme.len) ==\n      base::UTF8ToUTF16(extensions::kExtensionScheme);\n  bool grey_base = model()->CurrentTextIsURL() &&\n      (host.is_nonempty() || grey_out_url);\n  SetColor(location_bar_view_->GetColor(\n      security_level_,\n      grey_base ? LocationBarView::DEEMPHASIZED_TEXT : LocationBarView::TEXT));\n  if (grey_base && !grey_out_url) {\n    ApplyColor(\n        location_bar_view_->GetColor(security_level_, LocationBarView::TEXT),\n        gfx::Range(host.begin, host.end()));\n  }\n\n  // Emphasize the scheme for security UI display purposes (if necessary).\n  // Note that we check CurrentTextIsURL() because if we're replacing search\n  // URLs with search terms, we may have a non-URL even when the user is not\n  // editing; and in some cases, e.g. for \"site:foo.com\" searches, the parser\n  // may have incorrectly identified a qualifier as a scheme.\n  SetStyle(gfx::DIAGONAL_STRIKE, false);\n  if (!model()->user_input_in_progress() && model()->CurrentTextIsURL() &&\n      scheme.is_nonempty() && (security_level_ != connection_security::NONE)) {\n    SkColor security_color = location_bar_view_->GetColor(\n        security_level_, LocationBarView::SECURITY_TEXT);\n    const bool strike =\n        (security_level_ == connection_security::SECURITY_ERROR);\n    const gfx::Range scheme_range(scheme.begin, scheme.end());\n    ApplyColor(security_color, scheme_range);\n    ApplyStyle(gfx::DIAGONAL_STRIKE, strike, scheme_range);\n  }\n}",
        "func": "void OmniboxViewViews::EmphasizeURLComponents() {\n  if (!location_bar_view_)\n    return;\n\n  // If the current contents is a URL, force left-to-right rendering at the\n  // paragraph level. Right-to-left runs are still rendered RTL, but will not\n  // flip the whole URL around. For example (if \"ABC\" is Hebrew), this will\n  // render \"ABC.com\" as \"CBA.com\", rather than \"com.CBA\".\n  bool text_is_url = model()->CurrentTextIsURL();\n  GetRenderText()->SetDirectionalityMode(text_is_url\n                                             ? gfx::DIRECTIONALITY_FORCE_LTR\n                                             : gfx::DIRECTIONALITY_FROM_TEXT);\n\n  // See whether the contents are a URL with a non-empty host portion, which we\n  // should emphasize.  To check for a URL, rather than using the type returned\n  // by Parse(), ask the model, which will check the desired page transition for\n  // this input.  This can tell us whether an UNKNOWN input string is going to\n  // be treated as a search or a navigation, and is the same method the Paste\n  // And Go system uses.\n  url::Component scheme, host;\n  AutocompleteInput::ParseForEmphasizeComponents(\n      text(), ChromeAutocompleteSchemeClassifier(profile()), &scheme, &host);\n  bool grey_out_url = text().substr(scheme.begin, scheme.len) ==\n      base::UTF8ToUTF16(extensions::kExtensionScheme);\n  bool grey_base = text_is_url && (host.is_nonempty() || grey_out_url);\n  SetColor(location_bar_view_->GetColor(\n      security_level_,\n      grey_base ? LocationBarView::DEEMPHASIZED_TEXT : LocationBarView::TEXT));\n  if (grey_base && !grey_out_url) {\n    ApplyColor(\n        location_bar_view_->GetColor(security_level_, LocationBarView::TEXT),\n        gfx::Range(host.begin, host.end()));\n  }\n\n  // Emphasize the scheme for security UI display purposes (if necessary).\n  // Note that we check CurrentTextIsURL() because if we're replacing search\n  // URLs with search terms, we may have a non-URL even when the user is not\n  // editing; and in some cases, e.g. for \"site:foo.com\" searches, the parser\n  // may have incorrectly identified a qualifier as a scheme.\n  SetStyle(gfx::DIAGONAL_STRIKE, false);\n  if (!model()->user_input_in_progress() && text_is_url &&\n      scheme.is_nonempty() && (security_level_ != connection_security::NONE)) {\n    SkColor security_color = location_bar_view_->GetColor(\n        security_level_, LocationBarView::SECURITY_TEXT);\n    const bool strike =\n        (security_level_ == connection_security::SECURITY_ERROR);\n    const gfx::Range scheme_range(scheme.begin, scheme.end());\n    ApplyColor(security_color, scheme_range);\n    ApplyStyle(gfx::DIAGONAL_STRIKE, strike, scheme_range);\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,16 @@\n void OmniboxViewViews::EmphasizeURLComponents() {\n   if (!location_bar_view_)\n     return;\n+\n+  // If the current contents is a URL, force left-to-right rendering at the\n+  // paragraph level. Right-to-left runs are still rendered RTL, but will not\n+  // flip the whole URL around. For example (if \"ABC\" is Hebrew), this will\n+  // render \"ABC.com\" as \"CBA.com\", rather than \"com.CBA\".\n+  bool text_is_url = model()->CurrentTextIsURL();\n+  GetRenderText()->SetDirectionalityMode(text_is_url\n+                                             ? gfx::DIRECTIONALITY_FORCE_LTR\n+                                             : gfx::DIRECTIONALITY_FROM_TEXT);\n+\n   // See whether the contents are a URL with a non-empty host portion, which we\n   // should emphasize.  To check for a URL, rather than using the type returned\n   // by Parse(), ask the model, which will check the desired page transition for\n@@ -12,8 +22,7 @@\n       text(), ChromeAutocompleteSchemeClassifier(profile()), &scheme, &host);\n   bool grey_out_url = text().substr(scheme.begin, scheme.len) ==\n       base::UTF8ToUTF16(extensions::kExtensionScheme);\n-  bool grey_base = model()->CurrentTextIsURL() &&\n-      (host.is_nonempty() || grey_out_url);\n+  bool grey_base = text_is_url && (host.is_nonempty() || grey_out_url);\n   SetColor(location_bar_view_->GetColor(\n       security_level_,\n       grey_base ? LocationBarView::DEEMPHASIZED_TEXT : LocationBarView::TEXT));\n@@ -29,7 +38,7 @@\n   // editing; and in some cases, e.g. for \"site:foo.com\" searches, the parser\n   // may have incorrectly identified a qualifier as a scheme.\n   SetStyle(gfx::DIAGONAL_STRIKE, false);\n-  if (!model()->user_input_in_progress() && model()->CurrentTextIsURL() &&\n+  if (!model()->user_input_in_progress() && text_is_url &&\n       scheme.is_nonempty() && (security_level_ != connection_security::NONE)) {\n     SkColor security_color = location_bar_view_->GetColor(\n         security_level_, LocationBarView::SECURITY_TEXT);",
        "diff_line_info": {
            "deleted_lines": [
                "  bool grey_base = model()->CurrentTextIsURL() &&",
                "      (host.is_nonempty() || grey_out_url);",
                "  if (!model()->user_input_in_progress() && model()->CurrentTextIsURL() &&"
            ],
            "added_lines": [
                "",
                "  // If the current contents is a URL, force left-to-right rendering at the",
                "  // paragraph level. Right-to-left runs are still rendered RTL, but will not",
                "  // flip the whole URL around. For example (if \"ABC\" is Hebrew), this will",
                "  // render \"ABC.com\" as \"CBA.com\", rather than \"com.CBA\".",
                "  bool text_is_url = model()->CurrentTextIsURL();",
                "  GetRenderText()->SetDirectionalityMode(text_is_url",
                "                                             ? gfx::DIRECTIONALITY_FORCE_LTR",
                "                                             : gfx::DIRECTIONALITY_FROM_TEXT);",
                "",
                "  bool grey_base = text_is_url && (host.is_nonempty() || grey_out_url);",
                "  if (!model()->user_input_in_progress() && text_is_url &&"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-1296",
        "func_name": "chromium/Unescape",
        "description": "The UnescapeURLWithAdjustmentsImpl implementation in net/base/escape.cc in Google Chrome before 45.0.2454.85 does not prevent display of Unicode LOCK characters in the omnibox, which makes it easier for remote attackers to spoof the SSL lock icon by placing one of these characters at the end of a URL, as demonstrated by the omnibox in localizations for right-to-left languages.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/7c2cbc445a81424c7df48ebe61ec4d0dcadd5dff",
        "commit_title": "Added characters that look like padlocks to URL unescaping blacklist.",
        "commit_text": " This blacklists the following Unicode characters: - U+1F50F LOCK WITH INK PEN - U+1F510 CLOSED LOCK WITH KEY - U+1F512 LOCK - U+1F513 OPEN LOCK  This prevents LOCK characters from appearing in a URL in the Chrome UI, potentially looking like an SSL padlock icon (e.g., \"google.com/\" is now displayed as \"google.com/%F0%9F%94%92\"). This presented a spoofing risk due to a few complications: 1. In RTL mode, the end of the URL (path/query) is aligned right up    against the right edge of the Omnibox, where the SSL padlock is    usually displayed. 2. On Mac, ChromeOS, and Android, LOCK characters are displayed in    colour, making them more convincing.  Note: These characters will still be unescaped when using the SPOOFING_AND_CONTROL_CHARS unescape rule (used for decoding data URLs, previously known as CONTROL_CHARS).  TBR=jam@chromium.org   ",
        "func_before": "std::string Unescape(const std::string& url) {\n  std::string unescaped_str(url);\n  std::string old_unescaped_str;\n  const int kMaxLoopIterations = 1024;\n  int loop_var = 0;\n  do {\n    old_unescaped_str = unescaped_str;\n    unescaped_str = net::UnescapeURLComponent(old_unescaped_str,\n        net::UnescapeRule::CONTROL_CHARS | net::UnescapeRule::SPACES |\n        net::UnescapeRule::URL_SPECIAL_CHARS);\n  } while (unescaped_str != old_unescaped_str && ++loop_var <=\n           kMaxLoopIterations);\n\n  return unescaped_str;\n}",
        "func": "std::string Unescape(const std::string& url) {\n  std::string unescaped_str(url);\n  std::string old_unescaped_str;\n  const int kMaxLoopIterations = 1024;\n  int loop_var = 0;\n  do {\n    old_unescaped_str = unescaped_str;\n    unescaped_str = net::UnescapeURLComponent(\n        old_unescaped_str, net::UnescapeRule::SPOOFING_AND_CONTROL_CHARS |\n                               net::UnescapeRule::SPACES |\n                               net::UnescapeRule::URL_SPECIAL_CHARS);\n  } while (unescaped_str != old_unescaped_str && ++loop_var <=\n           kMaxLoopIterations);\n\n  return unescaped_str;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,9 +5,10 @@\n   int loop_var = 0;\n   do {\n     old_unescaped_str = unescaped_str;\n-    unescaped_str = net::UnescapeURLComponent(old_unescaped_str,\n-        net::UnescapeRule::CONTROL_CHARS | net::UnescapeRule::SPACES |\n-        net::UnescapeRule::URL_SPECIAL_CHARS);\n+    unescaped_str = net::UnescapeURLComponent(\n+        old_unescaped_str, net::UnescapeRule::SPOOFING_AND_CONTROL_CHARS |\n+                               net::UnescapeRule::SPACES |\n+                               net::UnescapeRule::URL_SPECIAL_CHARS);\n   } while (unescaped_str != old_unescaped_str && ++loop_var <=\n            kMaxLoopIterations);\n ",
        "diff_line_info": {
            "deleted_lines": [
                "    unescaped_str = net::UnescapeURLComponent(old_unescaped_str,",
                "        net::UnescapeRule::CONTROL_CHARS | net::UnescapeRule::SPACES |",
                "        net::UnescapeRule::URL_SPECIAL_CHARS);"
            ],
            "added_lines": [
                "    unescaped_str = net::UnescapeURLComponent(",
                "        old_unescaped_str, net::UnescapeRule::SPOOFING_AND_CONTROL_CHARS |",
                "                               net::UnescapeRule::SPACES |",
                "                               net::UnescapeRule::URL_SPECIAL_CHARS);"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-1296",
        "func_name": "chromium/EmbeddedSearchRequestParams::EmbeddedSearchRequestParams",
        "description": "The UnescapeURLWithAdjustmentsImpl implementation in net/base/escape.cc in Google Chrome before 45.0.2454.85 does not prevent display of Unicode LOCK characters in the omnibox, which makes it easier for remote attackers to spoof the SSL lock icon by placing one of these characters at the end of a URL, as demonstrated by the omnibox in localizations for right-to-left languages.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/7c2cbc445a81424c7df48ebe61ec4d0dcadd5dff",
        "commit_title": "Added characters that look like padlocks to URL unescaping blacklist.",
        "commit_text": " This blacklists the following Unicode characters: - U+1F50F LOCK WITH INK PEN - U+1F510 CLOSED LOCK WITH KEY - U+1F512 LOCK - U+1F513 OPEN LOCK  This prevents LOCK characters from appearing in a URL in the Chrome UI, potentially looking like an SSL padlock icon (e.g., \"google.com/\" is now displayed as \"google.com/%F0%9F%94%92\"). This presented a spoofing risk due to a few complications: 1. In RTL mode, the end of the URL (path/query) is aligned right up    against the right edge of the Omnibox, where the SSL padlock is    usually displayed. 2. On Mac, ChromeOS, and Android, LOCK characters are displayed in    colour, making them more convincing.  Note: These characters will still be unescaped when using the SPOOFING_AND_CONTROL_CHARS unescape rule (used for decoding data URLs, previously known as CONTROL_CHARS).  TBR=jam@chromium.org   ",
        "func_before": "EmbeddedSearchRequestParams::EmbeddedSearchRequestParams(const GURL& url) {\n  const std::string& url_params(url.ref().empty()? url.query() : url.ref());\n  url::Component query, key, value;\n  query.len = static_cast<int>(url_params.size());\n\n  const net::UnescapeRule::Type unescape_rules =\n      net::UnescapeRule::CONTROL_CHARS | net::UnescapeRule::SPACES |\n      net::UnescapeRule::URL_SPECIAL_CHARS | net::UnescapeRule::NORMAL |\n      net::UnescapeRule::REPLACE_PLUS_WITH_SPACE;\n\n  while (url::ExtractQueryKeyValue(url_params.c_str(), &query, &key, &value)) {\n    if (!key.is_nonempty())\n      continue;\n\n    std::string key_param(GetComponent(url_params, key));\n    std::string value_param(GetComponent(url_params, value));\n    if (key_param == kSearchQueryKey) {\n      search_query = base::UTF8ToUTF16(net::UnescapeURLComponent(\n          value_param, unescape_rules));\n    } else if (key_param == kOriginalQueryKey) {\n      original_query = base::UTF8ToUTF16(net::UnescapeURLComponent(\n          value_param, unescape_rules));\n    } else if (key_param == kRLZParameterKey) {\n      rlz_parameter_value = net::UnescapeAndDecodeUTF8URLComponent(\n          value_param, net::UnescapeRule::NORMAL);\n    } else if (key_param == kInputEncodingKey) {\n      input_encoding = net::UnescapeAndDecodeUTF8URLComponent(\n          value_param, net::UnescapeRule::NORMAL);\n    } else if (key_param == kAssistedQueryStatsKey) {\n      assisted_query_stats = net::UnescapeAndDecodeUTF8URLComponent(\n          value_param, net::UnescapeRule::NORMAL);\n    }\n  }\n}",
        "func": "EmbeddedSearchRequestParams::EmbeddedSearchRequestParams(const GURL& url) {\n  const std::string& url_params(url.ref().empty()? url.query() : url.ref());\n  url::Component query, key, value;\n  query.len = static_cast<int>(url_params.size());\n\n  const net::UnescapeRule::Type unescape_rules =\n      net::UnescapeRule::SPOOFING_AND_CONTROL_CHARS |\n      net::UnescapeRule::SPACES | net::UnescapeRule::URL_SPECIAL_CHARS |\n      net::UnescapeRule::NORMAL | net::UnescapeRule::REPLACE_PLUS_WITH_SPACE;\n\n  while (url::ExtractQueryKeyValue(url_params.c_str(), &query, &key, &value)) {\n    if (!key.is_nonempty())\n      continue;\n\n    std::string key_param(GetComponent(url_params, key));\n    std::string value_param(GetComponent(url_params, value));\n    if (key_param == kSearchQueryKey) {\n      search_query = base::UTF8ToUTF16(net::UnescapeURLComponent(\n          value_param, unescape_rules));\n    } else if (key_param == kOriginalQueryKey) {\n      original_query = base::UTF8ToUTF16(net::UnescapeURLComponent(\n          value_param, unescape_rules));\n    } else if (key_param == kRLZParameterKey) {\n      rlz_parameter_value = net::UnescapeAndDecodeUTF8URLComponent(\n          value_param, net::UnescapeRule::NORMAL);\n    } else if (key_param == kInputEncodingKey) {\n      input_encoding = net::UnescapeAndDecodeUTF8URLComponent(\n          value_param, net::UnescapeRule::NORMAL);\n    } else if (key_param == kAssistedQueryStatsKey) {\n      assisted_query_stats = net::UnescapeAndDecodeUTF8URLComponent(\n          value_param, net::UnescapeRule::NORMAL);\n    }\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,9 +4,9 @@\n   query.len = static_cast<int>(url_params.size());\n \n   const net::UnescapeRule::Type unescape_rules =\n-      net::UnescapeRule::CONTROL_CHARS | net::UnescapeRule::SPACES |\n-      net::UnescapeRule::URL_SPECIAL_CHARS | net::UnescapeRule::NORMAL |\n-      net::UnescapeRule::REPLACE_PLUS_WITH_SPACE;\n+      net::UnescapeRule::SPOOFING_AND_CONTROL_CHARS |\n+      net::UnescapeRule::SPACES | net::UnescapeRule::URL_SPECIAL_CHARS |\n+      net::UnescapeRule::NORMAL | net::UnescapeRule::REPLACE_PLUS_WITH_SPACE;\n \n   while (url::ExtractQueryKeyValue(url_params.c_str(), &query, &key, &value)) {\n     if (!key.is_nonempty())",
        "diff_line_info": {
            "deleted_lines": [
                "      net::UnescapeRule::CONTROL_CHARS | net::UnescapeRule::SPACES |",
                "      net::UnescapeRule::URL_SPECIAL_CHARS | net::UnescapeRule::NORMAL |",
                "      net::UnescapeRule::REPLACE_PLUS_WITH_SPACE;"
            ],
            "added_lines": [
                "      net::UnescapeRule::SPOOFING_AND_CONTROL_CHARS |",
                "      net::UnescapeRule::SPACES | net::UnescapeRule::URL_SPECIAL_CHARS |",
                "      net::UnescapeRule::NORMAL | net::UnescapeRule::REPLACE_PLUS_WITH_SPACE;"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-1296",
        "func_name": "chromium/ParseFileSystemSchemeURL",
        "description": "The UnescapeURLWithAdjustmentsImpl implementation in net/base/escape.cc in Google Chrome before 45.0.2454.85 does not prevent display of Unicode LOCK characters in the omnibox, which makes it easier for remote attackers to spoof the SSL lock icon by placing one of these characters at the end of a URL, as demonstrated by the omnibox in localizations for right-to-left languages.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/7c2cbc445a81424c7df48ebe61ec4d0dcadd5dff",
        "commit_title": "Added characters that look like padlocks to URL unescaping blacklist.",
        "commit_text": " This blacklists the following Unicode characters: - U+1F50F LOCK WITH INK PEN - U+1F510 CLOSED LOCK WITH KEY - U+1F512 LOCK - U+1F513 OPEN LOCK  This prevents LOCK characters from appearing in a URL in the Chrome UI, potentially looking like an SSL padlock icon (e.g., \"google.com/\" is now displayed as \"google.com/%F0%9F%94%92\"). This presented a spoofing risk due to a few complications: 1. In RTL mode, the end of the URL (path/query) is aligned right up    against the right edge of the Omnibox, where the SSL padlock is    usually displayed. 2. On Mac, ChromeOS, and Android, LOCK characters are displayed in    colour, making them more convincing.  Note: These characters will still be unescaped when using the SPOOFING_AND_CONTROL_CHARS unescape rule (used for decoding data URLs, previously known as CONTROL_CHARS).  TBR=jam@chromium.org   ",
        "func_before": "bool ParseFileSystemSchemeURL(const GURL& url,\n                              GURL* origin_url,\n                              FileSystemType* type,\n                              base::FilePath* virtual_path) {\n  GURL origin;\n  FileSystemType file_system_type = kFileSystemTypeUnknown;\n\n  if (!url.is_valid() || !url.SchemeIsFileSystem())\n    return false;\n\n  const struct {\n    FileSystemType type;\n    const char* dir;\n  } kValidTypes[] = {\n    { kFileSystemTypePersistent, kPersistentDir },\n    { kFileSystemTypeTemporary, kTemporaryDir },\n    { kFileSystemTypeIsolated, kIsolatedDir },\n    { kFileSystemTypeExternal, kExternalDir },\n    { kFileSystemTypeTest, kTestDir },\n  };\n\n  // A path of the inner_url contains only mount type part (e.g. \"/temporary\").\n  DCHECK(url.inner_url());\n  std::string inner_path = url.inner_url()->path();\n  for (size_t i = 0; i < arraysize(kValidTypes); ++i) {\n    if (inner_path == kValidTypes[i].dir) {\n      file_system_type = kValidTypes[i].type;\n      break;\n    }\n  }\n\n  if (file_system_type == kFileSystemTypeUnknown)\n    return false;\n\n  std::string path = net::UnescapeURLComponent(url.path(),\n      net::UnescapeRule::SPACES | net::UnescapeRule::URL_SPECIAL_CHARS |\n      net::UnescapeRule::CONTROL_CHARS);\n\n  // Ensure the path is relative.\n  while (!path.empty() && path[0] == '/')\n    path.erase(0, 1);\n\n  base::FilePath converted_path = base::FilePath::FromUTF8Unsafe(path);\n\n  // All parent references should have been resolved in the renderer.\n  if (converted_path.ReferencesParent())\n    return false;\n\n  if (origin_url)\n    *origin_url = url.GetOrigin();\n  if (type)\n    *type = file_system_type;\n  if (virtual_path)\n    *virtual_path = converted_path.NormalizePathSeparators().\n        StripTrailingSeparators();\n\n  return true;\n}",
        "func": "bool ParseFileSystemSchemeURL(const GURL& url,\n                              GURL* origin_url,\n                              FileSystemType* type,\n                              base::FilePath* virtual_path) {\n  GURL origin;\n  FileSystemType file_system_type = kFileSystemTypeUnknown;\n\n  if (!url.is_valid() || !url.SchemeIsFileSystem())\n    return false;\n\n  const struct {\n    FileSystemType type;\n    const char* dir;\n  } kValidTypes[] = {\n    { kFileSystemTypePersistent, kPersistentDir },\n    { kFileSystemTypeTemporary, kTemporaryDir },\n    { kFileSystemTypeIsolated, kIsolatedDir },\n    { kFileSystemTypeExternal, kExternalDir },\n    { kFileSystemTypeTest, kTestDir },\n  };\n\n  // A path of the inner_url contains only mount type part (e.g. \"/temporary\").\n  DCHECK(url.inner_url());\n  std::string inner_path = url.inner_url()->path();\n  for (size_t i = 0; i < arraysize(kValidTypes); ++i) {\n    if (inner_path == kValidTypes[i].dir) {\n      file_system_type = kValidTypes[i].type;\n      break;\n    }\n  }\n\n  if (file_system_type == kFileSystemTypeUnknown)\n    return false;\n\n  std::string path = net::UnescapeURLComponent(url.path(),\n      net::UnescapeRule::SPACES | net::UnescapeRule::URL_SPECIAL_CHARS |\n      net::UnescapeRule::SPOOFING_AND_CONTROL_CHARS);\n\n  // Ensure the path is relative.\n  while (!path.empty() && path[0] == '/')\n    path.erase(0, 1);\n\n  base::FilePath converted_path = base::FilePath::FromUTF8Unsafe(path);\n\n  // All parent references should have been resolved in the renderer.\n  if (converted_path.ReferencesParent())\n    return false;\n\n  if (origin_url)\n    *origin_url = url.GetOrigin();\n  if (type)\n    *type = file_system_type;\n  if (virtual_path)\n    *virtual_path = converted_path.NormalizePathSeparators().\n        StripTrailingSeparators();\n\n  return true;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -34,7 +34,7 @@\n \n   std::string path = net::UnescapeURLComponent(url.path(),\n       net::UnescapeRule::SPACES | net::UnescapeRule::URL_SPECIAL_CHARS |\n-      net::UnescapeRule::CONTROL_CHARS);\n+      net::UnescapeRule::SPOOFING_AND_CONTROL_CHARS);\n \n   // Ensure the path is relative.\n   while (!path.empty() && path[0] == '/')",
        "diff_line_info": {
            "deleted_lines": [
                "      net::UnescapeRule::CONTROL_CHARS);"
            ],
            "added_lines": [
                "      net::UnescapeRule::SPOOFING_AND_CONTROL_CHARS);"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-1296",
        "func_name": "chromium/DataURL::Parse",
        "description": "The UnescapeURLWithAdjustmentsImpl implementation in net/base/escape.cc in Google Chrome before 45.0.2454.85 does not prevent display of Unicode LOCK characters in the omnibox, which makes it easier for remote attackers to spoof the SSL lock icon by placing one of these characters at the end of a URL, as demonstrated by the omnibox in localizations for right-to-left languages.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/7c2cbc445a81424c7df48ebe61ec4d0dcadd5dff",
        "commit_title": "Added characters that look like padlocks to URL unescaping blacklist.",
        "commit_text": " This blacklists the following Unicode characters: - U+1F50F LOCK WITH INK PEN - U+1F510 CLOSED LOCK WITH KEY - U+1F512 LOCK - U+1F513 OPEN LOCK  This prevents LOCK characters from appearing in a URL in the Chrome UI, potentially looking like an SSL padlock icon (e.g., \"google.com/\" is now displayed as \"google.com/%F0%9F%94%92\"). This presented a spoofing risk due to a few complications: 1. In RTL mode, the end of the URL (path/query) is aligned right up    against the right edge of the Omnibox, where the SSL padlock is    usually displayed. 2. On Mac, ChromeOS, and Android, LOCK characters are displayed in    colour, making them more convincing.  Note: These characters will still be unescaped when using the SPOOFING_AND_CONTROL_CHARS unescape rule (used for decoding data URLs, previously known as CONTROL_CHARS).  TBR=jam@chromium.org   ",
        "func_before": "bool DataURL::Parse(const GURL& url, std::string* mime_type,\n                    std::string* charset, std::string* data) {\n  DCHECK(mime_type->empty());\n  DCHECK(charset->empty());\n  std::string::const_iterator begin = url.spec().begin();\n  std::string::const_iterator end = url.spec().end();\n\n  std::string::const_iterator after_colon = std::find(begin, end, ':');\n  if (after_colon == end)\n    return false;\n  ++after_colon;\n\n  std::string::const_iterator comma = std::find(after_colon, end, ',');\n  if (comma == end)\n    return false;\n\n  std::vector<std::string> meta_data;\n  std::string unparsed_meta_data(after_colon, comma);\n  base::SplitString(unparsed_meta_data, ';', &meta_data);\n\n  std::vector<std::string>::iterator iter = meta_data.begin();\n  if (iter != meta_data.end()) {\n    mime_type->swap(*iter);\n    base::StringToLowerASCII(mime_type);\n    ++iter;\n  }\n\n  static const char kBase64Tag[] = \"base64\";\n  static const char kCharsetTag[] = \"charset=\";\n  const size_t kCharsetTagLength = arraysize(kCharsetTag) - 1;\n\n  bool base64_encoded = false;\n  for (; iter != meta_data.end(); ++iter) {\n    if (!base64_encoded && *iter == kBase64Tag) {\n      base64_encoded = true;\n    } else if (charset->empty() &&\n               iter->compare(0, kCharsetTagLength, kCharsetTag) == 0) {\n      charset->assign(iter->substr(kCharsetTagLength));\n      // The grammar for charset is not specially defined in RFC2045 and\n      // RFC2397. It just needs to be a token.\n      if (!HttpUtil::IsToken(*charset))\n        return false;\n    }\n  }\n\n  if (mime_type->empty()) {\n    // Fallback to the default if nothing specified in the mediatype part as\n    // specified in RFC2045. As specified in RFC2397, we use |charset| even if\n    // |mime_type| is empty.\n    mime_type->assign(\"text/plain\");\n  } else if (!ParseMimeTypeWithoutParameter(*mime_type, NULL, NULL)) {\n    // Fallback to the default as recommended in RFC2045 when the mediatype\n    // value is invalid. For this case, we don't respect |charset| but force it\n    // set to \"US-ASCII\".\n    mime_type->assign(\"text/plain\");\n    charset->assign(\"US-ASCII\");\n  }\n  if (charset->empty())\n    charset->assign(\"US-ASCII\");\n\n  // The caller may not be interested in receiving the data.\n  if (!data)\n    return true;\n\n  // Preserve spaces if dealing with text or xml input, same as mozilla:\n  //   https://bugzilla.mozilla.org/show_bug.cgi?id=138052\n  // but strip them otherwise:\n  //   https://bugzilla.mozilla.org/show_bug.cgi?id=37200\n  // (Spaces in a data URL should be escaped, which is handled below, so any\n  // spaces now are wrong. People expect to be able to enter them in the URL\n  // bar for text, and it can't hurt, so we allow it.)\n  std::string temp_data = std::string(comma + 1, end);\n\n  // For base64, we may have url-escaped whitespace which is not part\n  // of the data, and should be stripped. Otherwise, the escaped whitespace\n  // could be part of the payload, so don't strip it.\n  if (base64_encoded) {\n    temp_data = UnescapeURLComponent(temp_data,\n        UnescapeRule::SPACES | UnescapeRule::URL_SPECIAL_CHARS |\n        UnescapeRule::CONTROL_CHARS);\n  }\n\n  // Strip whitespace.\n  if (base64_encoded || !(mime_type->compare(0, 5, \"text/\") == 0 ||\n                          mime_type->find(\"xml\") != std::string::npos)) {\n    temp_data.erase(std::remove_if(temp_data.begin(), temp_data.end(),\n                                   base::IsAsciiWhitespace<wchar_t>),\n                    temp_data.end());\n  }\n\n  if (!base64_encoded) {\n    temp_data = UnescapeURLComponent(temp_data,\n        UnescapeRule::SPACES | UnescapeRule::URL_SPECIAL_CHARS |\n        UnescapeRule::CONTROL_CHARS);\n  }\n\n  if (base64_encoded) {\n    size_t length = temp_data.length();\n    size_t padding_needed = 4 - (length % 4);\n    // If the input wasn't padded, then we pad it as necessary until we have a\n    // length that is a multiple of 4 as required by our decoder. We don't\n    // correct if the input was incorrectly padded. If |padding_needed| == 3,\n    // then the input isn't well formed and decoding will fail with or without\n    // padding.\n    if ((padding_needed == 1 || padding_needed == 2) &&\n        temp_data[length - 1] != '=') {\n      temp_data.resize(length + padding_needed, '=');\n    }\n    return base::Base64Decode(temp_data, data);\n  }\n\n  temp_data.swap(*data);\n  return true;\n}",
        "func": "bool DataURL::Parse(const GURL& url, std::string* mime_type,\n                    std::string* charset, std::string* data) {\n  DCHECK(mime_type->empty());\n  DCHECK(charset->empty());\n  std::string::const_iterator begin = url.spec().begin();\n  std::string::const_iterator end = url.spec().end();\n\n  std::string::const_iterator after_colon = std::find(begin, end, ':');\n  if (after_colon == end)\n    return false;\n  ++after_colon;\n\n  std::string::const_iterator comma = std::find(after_colon, end, ',');\n  if (comma == end)\n    return false;\n\n  std::vector<std::string> meta_data;\n  std::string unparsed_meta_data(after_colon, comma);\n  base::SplitString(unparsed_meta_data, ';', &meta_data);\n\n  std::vector<std::string>::iterator iter = meta_data.begin();\n  if (iter != meta_data.end()) {\n    mime_type->swap(*iter);\n    base::StringToLowerASCII(mime_type);\n    ++iter;\n  }\n\n  static const char kBase64Tag[] = \"base64\";\n  static const char kCharsetTag[] = \"charset=\";\n  const size_t kCharsetTagLength = arraysize(kCharsetTag) - 1;\n\n  bool base64_encoded = false;\n  for (; iter != meta_data.end(); ++iter) {\n    if (!base64_encoded && *iter == kBase64Tag) {\n      base64_encoded = true;\n    } else if (charset->empty() &&\n               iter->compare(0, kCharsetTagLength, kCharsetTag) == 0) {\n      charset->assign(iter->substr(kCharsetTagLength));\n      // The grammar for charset is not specially defined in RFC2045 and\n      // RFC2397. It just needs to be a token.\n      if (!HttpUtil::IsToken(*charset))\n        return false;\n    }\n  }\n\n  if (mime_type->empty()) {\n    // Fallback to the default if nothing specified in the mediatype part as\n    // specified in RFC2045. As specified in RFC2397, we use |charset| even if\n    // |mime_type| is empty.\n    mime_type->assign(\"text/plain\");\n  } else if (!ParseMimeTypeWithoutParameter(*mime_type, NULL, NULL)) {\n    // Fallback to the default as recommended in RFC2045 when the mediatype\n    // value is invalid. For this case, we don't respect |charset| but force it\n    // set to \"US-ASCII\".\n    mime_type->assign(\"text/plain\");\n    charset->assign(\"US-ASCII\");\n  }\n  if (charset->empty())\n    charset->assign(\"US-ASCII\");\n\n  // The caller may not be interested in receiving the data.\n  if (!data)\n    return true;\n\n  // Preserve spaces if dealing with text or xml input, same as mozilla:\n  //   https://bugzilla.mozilla.org/show_bug.cgi?id=138052\n  // but strip them otherwise:\n  //   https://bugzilla.mozilla.org/show_bug.cgi?id=37200\n  // (Spaces in a data URL should be escaped, which is handled below, so any\n  // spaces now are wrong. People expect to be able to enter them in the URL\n  // bar for text, and it can't hurt, so we allow it.)\n  std::string temp_data = std::string(comma + 1, end);\n\n  // For base64, we may have url-escaped whitespace which is not part\n  // of the data, and should be stripped. Otherwise, the escaped whitespace\n  // could be part of the payload, so don't strip it.\n  if (base64_encoded) {\n    temp_data = UnescapeURLComponent(temp_data,\n        UnescapeRule::SPACES | UnescapeRule::URL_SPECIAL_CHARS |\n        UnescapeRule::SPOOFING_AND_CONTROL_CHARS);\n  }\n\n  // Strip whitespace.\n  if (base64_encoded || !(mime_type->compare(0, 5, \"text/\") == 0 ||\n                          mime_type->find(\"xml\") != std::string::npos)) {\n    temp_data.erase(std::remove_if(temp_data.begin(), temp_data.end(),\n                                   base::IsAsciiWhitespace<wchar_t>),\n                    temp_data.end());\n  }\n\n  if (!base64_encoded) {\n    temp_data = UnescapeURLComponent(temp_data,\n        UnescapeRule::SPACES | UnescapeRule::URL_SPECIAL_CHARS |\n        UnescapeRule::SPOOFING_AND_CONTROL_CHARS);\n  }\n\n  if (base64_encoded) {\n    size_t length = temp_data.length();\n    size_t padding_needed = 4 - (length % 4);\n    // If the input wasn't padded, then we pad it as necessary until we have a\n    // length that is a multiple of 4 as required by our decoder. We don't\n    // correct if the input was incorrectly padded. If |padding_needed| == 3,\n    // then the input isn't well formed and decoding will fail with or without\n    // padding.\n    if ((padding_needed == 1 || padding_needed == 2) &&\n        temp_data[length - 1] != '=') {\n      temp_data.resize(length + padding_needed, '=');\n    }\n    return base::Base64Decode(temp_data, data);\n  }\n\n  temp_data.swap(*data);\n  return true;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -77,7 +77,7 @@\n   if (base64_encoded) {\n     temp_data = UnescapeURLComponent(temp_data,\n         UnescapeRule::SPACES | UnescapeRule::URL_SPECIAL_CHARS |\n-        UnescapeRule::CONTROL_CHARS);\n+        UnescapeRule::SPOOFING_AND_CONTROL_CHARS);\n   }\n \n   // Strip whitespace.\n@@ -91,7 +91,7 @@\n   if (!base64_encoded) {\n     temp_data = UnescapeURLComponent(temp_data,\n         UnescapeRule::SPACES | UnescapeRule::URL_SPECIAL_CHARS |\n-        UnescapeRule::CONTROL_CHARS);\n+        UnescapeRule::SPOOFING_AND_CONTROL_CHARS);\n   }\n \n   if (base64_encoded) {",
        "diff_line_info": {
            "deleted_lines": [
                "        UnescapeRule::CONTROL_CHARS);",
                "        UnescapeRule::CONTROL_CHARS);"
            ],
            "added_lines": [
                "        UnescapeRule::SPOOFING_AND_CONTROL_CHARS);",
                "        UnescapeRule::SPOOFING_AND_CONTROL_CHARS);"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-1296",
        "func_name": "chromium/UnescapeURLWithAdjustmentsImpl",
        "description": "The UnescapeURLWithAdjustmentsImpl implementation in net/base/escape.cc in Google Chrome before 45.0.2454.85 does not prevent display of Unicode LOCK characters in the omnibox, which makes it easier for remote attackers to spoof the SSL lock icon by placing one of these characters at the end of a URL, as demonstrated by the omnibox in localizations for right-to-left languages.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/7c2cbc445a81424c7df48ebe61ec4d0dcadd5dff",
        "commit_title": "Added characters that look like padlocks to URL unescaping blacklist.",
        "commit_text": " This blacklists the following Unicode characters: - U+1F50F LOCK WITH INK PEN - U+1F510 CLOSED LOCK WITH KEY - U+1F512 LOCK - U+1F513 OPEN LOCK  This prevents LOCK characters from appearing in a URL in the Chrome UI, potentially looking like an SSL padlock icon (e.g., \"google.com/\" is now displayed as \"google.com/%F0%9F%94%92\"). This presented a spoofing risk due to a few complications: 1. In RTL mode, the end of the URL (path/query) is aligned right up    against the right edge of the Omnibox, where the SSL padlock is    usually displayed. 2. On Mac, ChromeOS, and Android, LOCK characters are displayed in    colour, making them more convincing.  Note: These characters will still be unescaped when using the SPOOFING_AND_CONTROL_CHARS unescape rule (used for decoding data URLs, previously known as CONTROL_CHARS).  TBR=jam@chromium.org   ",
        "func_before": "STR UnescapeURLWithAdjustmentsImpl(\n    const STR& escaped_text,\n    UnescapeRule::Type rules,\n    base::OffsetAdjuster::Adjustments* adjustments) {\n  if (adjustments)\n    adjustments->clear();\n  // Do not unescape anything, return the |escaped_text| text.\n  if (rules == UnescapeRule::NONE)\n    return escaped_text;\n\n  // The output of the unescaping is always smaller than the input, so we can\n  // reserve the input size to make sure we have enough buffer and don't have\n  // to allocate in the loop below.\n  STR result;\n  result.reserve(escaped_text.length());\n\n  // Locations of adjusted text.\n  for (size_t i = 0, max = escaped_text.size(); i < max; ++i) {\n    if (static_cast<unsigned char>(escaped_text[i]) >= 128) {\n      // Non ASCII character, append as is.\n      result.push_back(escaped_text[i]);\n      continue;\n    }\n\n    unsigned char first_byte;\n    if (UnescapeUnsignedCharAtIndex(escaped_text, i, &first_byte)) {\n      // Per http://tools.ietf.org/html/rfc3987#section-4.1, the following BiDi\n      // control characters are not allowed to appear unescaped in URLs:\n      //\n      // U+200E LEFT-TO-RIGHT MARK         (%E2%80%8E)\n      // U+200F RIGHT-TO-LEFT MARK         (%E2%80%8F)\n      // U+202A LEFT-TO-RIGHT EMBEDDING    (%E2%80%AA)\n      // U+202B RIGHT-TO-LEFT EMBEDDING    (%E2%80%AB)\n      // U+202C POP DIRECTIONAL FORMATTING (%E2%80%AC)\n      // U+202D LEFT-TO-RIGHT OVERRIDE     (%E2%80%AD)\n      // U+202E RIGHT-TO-LEFT OVERRIDE     (%E2%80%AE)\n      //\n      // Additionally, the Unicode Technical Report (TR9) as referenced by RFC\n      // 3987 above has since added some new BiDi control characters.\n      // http://www.unicode.org/reports/tr9\n      //\n      // U+061C ARABIC LETTER MARK         (%D8%9C)\n      // U+2066 LEFT-TO-RIGHT ISOLATE      (%E2%81%A6)\n      // U+2067 RIGHT-TO-LEFT ISOLATE      (%E2%81%A7)\n      // U+2068 FIRST STRONG ISOLATE       (%E2%81%A8)\n      // U+2069 POP DIRECTIONAL ISOLATE    (%E2%81%A9)\n      //\n      // However, some schemes such as data: and file: need to parse the exact\n      // binary data when loading the URL. For that reason, CONTROL_CHARS allows\n      // unescaping BiDi control characters.\n      // DO NOT use CONTROL_CHARS if the parsed URL is going to be displayed\n      // in the UI.\n      if (!(rules & UnescapeRule::CONTROL_CHARS)) {\n        if (HasArabicLanguageMarkAtIndex(escaped_text, first_byte, i)) {\n          // Keep Arabic Language Mark escaped.\n          result.append(escaped_text, i, 6);\n          i += 5;\n          continue;\n        }\n        if (HasThreeByteBidiControlCharAtIndex(escaped_text, first_byte, i)) {\n          // Keep BiDi control char escaped.\n          result.append(escaped_text, i, 9);\n          i += 8;\n          continue;\n        }\n      }\n\n      if (first_byte >= 0x80 ||  // Unescape all high-bit characters.\n          // For 7-bit characters, the lookup table tells us all valid chars.\n          (kUrlUnescape[first_byte] ||\n           // ...and we allow some additional unescaping when flags are set.\n           (first_byte == ' ' && (rules & UnescapeRule::SPACES)) ||\n           // Allow any of the prohibited but non-control characters when\n           // we're doing \"special\" chars.\n           (first_byte > ' ' && (rules & UnescapeRule::URL_SPECIAL_CHARS)) ||\n           // Additionally allow control characters if requested.\n           (first_byte < ' ' && (rules & UnescapeRule::CONTROL_CHARS)))) {\n        // Use the unescaped version of the character.\n        if (adjustments)\n          adjustments->push_back(base::OffsetAdjuster::Adjustment(i, 3, 1));\n        result.push_back(first_byte);\n        i += 2;\n      } else {\n        // Keep escaped. Append a percent and we'll get the following two\n        // digits on the next loops through.\n        result.push_back('%');\n      }\n    } else if ((rules & UnescapeRule::REPLACE_PLUS_WITH_SPACE) &&\n               escaped_text[i] == '+') {\n      result.push_back(' ');\n    } else {\n      // Normal case for unescaped characters.\n      result.push_back(escaped_text[i]);\n    }\n  }\n\n  return result;\n}",
        "func": "STR UnescapeURLWithAdjustmentsImpl(\n    const STR& escaped_text,\n    UnescapeRule::Type rules,\n    base::OffsetAdjuster::Adjustments* adjustments) {\n  if (adjustments)\n    adjustments->clear();\n  // Do not unescape anything, return the |escaped_text| text.\n  if (rules == UnescapeRule::NONE)\n    return escaped_text;\n\n  // The output of the unescaping is always smaller than the input, so we can\n  // reserve the input size to make sure we have enough buffer and don't have\n  // to allocate in the loop below.\n  STR result;\n  result.reserve(escaped_text.length());\n\n  // Locations of adjusted text.\n  for (size_t i = 0, max = escaped_text.size(); i < max; ++i) {\n    if (static_cast<unsigned char>(escaped_text[i]) >= 128) {\n      // Non ASCII character, append as is.\n      result.push_back(escaped_text[i]);\n      continue;\n    }\n\n    unsigned char first_byte;\n    if (UnescapeUnsignedCharAtIndex(escaped_text, i, &first_byte)) {\n      // Per http://tools.ietf.org/html/rfc3987#section-4.1, the following BiDi\n      // control characters are not allowed to appear unescaped in URLs:\n      //\n      // U+200E LEFT-TO-RIGHT MARK         (%E2%80%8E)\n      // U+200F RIGHT-TO-LEFT MARK         (%E2%80%8F)\n      // U+202A LEFT-TO-RIGHT EMBEDDING    (%E2%80%AA)\n      // U+202B RIGHT-TO-LEFT EMBEDDING    (%E2%80%AB)\n      // U+202C POP DIRECTIONAL FORMATTING (%E2%80%AC)\n      // U+202D LEFT-TO-RIGHT OVERRIDE     (%E2%80%AD)\n      // U+202E RIGHT-TO-LEFT OVERRIDE     (%E2%80%AE)\n      //\n      // Additionally, the Unicode Technical Report (TR9) as referenced by RFC\n      // 3987 above has since added some new BiDi control characters.\n      // http://www.unicode.org/reports/tr9\n      //\n      // U+061C ARABIC LETTER MARK         (%D8%9C)\n      // U+2066 LEFT-TO-RIGHT ISOLATE      (%E2%81%A6)\n      // U+2067 RIGHT-TO-LEFT ISOLATE      (%E2%81%A7)\n      // U+2068 FIRST STRONG ISOLATE       (%E2%81%A8)\n      // U+2069 POP DIRECTIONAL ISOLATE    (%E2%81%A9)\n      //\n      // The following spoofable characters are also banned, because they could\n      // be used to imitate parts of a web browser's UI.\n      //\n      // U+1F50F LOCK WITH INK PEN         (%F0%9F%94%8F)\n      // U+1F510 CLOSED LOCK WITH KEY      (%F0%9F%94%90)\n      // U+1F512 LOCK                      (%F0%9F%94%92)\n      // U+1F513 OPEN LOCK                 (%F0%9F%94%93)\n      //\n      // However, some schemes such as data: and file: need to parse the exact\n      // binary data when loading the URL. For that reason,\n      // SPOOFING_AND_CONTROL_CHARS allows unescaping BiDi control characters.\n      // DO NOT use SPOOFING_AND_CONTROL_CHARS if the parsed URL is going to be\n      // displayed in the UI.\n      if (!(rules & UnescapeRule::SPOOFING_AND_CONTROL_CHARS)) {\n        if (HasArabicLanguageMarkAtIndex(escaped_text, first_byte, i)) {\n          // Keep Arabic Language Mark escaped.\n          result.append(escaped_text, i, 6);\n          i += 5;\n          continue;\n        }\n        if (HasThreeByteBidiControlCharAtIndex(escaped_text, first_byte, i)) {\n          // Keep BiDi control char escaped.\n          result.append(escaped_text, i, 9);\n          i += 8;\n          continue;\n        }\n        if (HasFourByteBannedCharAtIndex(escaped_text, first_byte, i)) {\n          // Keep banned char escaped.\n          result.append(escaped_text, i, 12);\n          i += 11;\n          continue;\n        }\n      }\n\n      if (first_byte >= 0x80 ||  // Unescape all high-bit characters.\n          // For 7-bit characters, the lookup table tells us all valid chars.\n          (kUrlUnescape[first_byte] ||\n           // ...and we allow some additional unescaping when flags are set.\n           (first_byte == ' ' && (rules & UnescapeRule::SPACES)) ||\n           // Allow any of the prohibited but non-control characters when\n           // we're doing \"special\" chars.\n           (first_byte > ' ' && (rules & UnescapeRule::URL_SPECIAL_CHARS)) ||\n           // Additionally allow non-display characters if requested.\n           (first_byte < ' ' &&\n            (rules & UnescapeRule::SPOOFING_AND_CONTROL_CHARS)))) {\n        // Use the unescaped version of the character.\n        if (adjustments)\n          adjustments->push_back(base::OffsetAdjuster::Adjustment(i, 3, 1));\n        result.push_back(first_byte);\n        i += 2;\n      } else {\n        // Keep escaped. Append a percent and we'll get the following two\n        // digits on the next loops through.\n        result.push_back('%');\n      }\n    } else if ((rules & UnescapeRule::REPLACE_PLUS_WITH_SPACE) &&\n               escaped_text[i] == '+') {\n      result.push_back(' ');\n    } else {\n      // Normal case for unescaped characters.\n      result.push_back(escaped_text[i]);\n    }\n  }\n\n  return result;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -45,12 +45,20 @@\n       // U+2068 FIRST STRONG ISOLATE       (%E2%81%A8)\n       // U+2069 POP DIRECTIONAL ISOLATE    (%E2%81%A9)\n       //\n+      // The following spoofable characters are also banned, because they could\n+      // be used to imitate parts of a web browser's UI.\n+      //\n+      // U+1F50F LOCK WITH INK PEN         (%F0%9F%94%8F)\n+      // U+1F510 CLOSED LOCK WITH KEY      (%F0%9F%94%90)\n+      // U+1F512 LOCK                      (%F0%9F%94%92)\n+      // U+1F513 OPEN LOCK                 (%F0%9F%94%93)\n+      //\n       // However, some schemes such as data: and file: need to parse the exact\n-      // binary data when loading the URL. For that reason, CONTROL_CHARS allows\n-      // unescaping BiDi control characters.\n-      // DO NOT use CONTROL_CHARS if the parsed URL is going to be displayed\n-      // in the UI.\n-      if (!(rules & UnescapeRule::CONTROL_CHARS)) {\n+      // binary data when loading the URL. For that reason,\n+      // SPOOFING_AND_CONTROL_CHARS allows unescaping BiDi control characters.\n+      // DO NOT use SPOOFING_AND_CONTROL_CHARS if the parsed URL is going to be\n+      // displayed in the UI.\n+      if (!(rules & UnescapeRule::SPOOFING_AND_CONTROL_CHARS)) {\n         if (HasArabicLanguageMarkAtIndex(escaped_text, first_byte, i)) {\n           // Keep Arabic Language Mark escaped.\n           result.append(escaped_text, i, 6);\n@@ -63,6 +71,12 @@\n           i += 8;\n           continue;\n         }\n+        if (HasFourByteBannedCharAtIndex(escaped_text, first_byte, i)) {\n+          // Keep banned char escaped.\n+          result.append(escaped_text, i, 12);\n+          i += 11;\n+          continue;\n+        }\n       }\n \n       if (first_byte >= 0x80 ||  // Unescape all high-bit characters.\n@@ -73,8 +87,9 @@\n            // Allow any of the prohibited but non-control characters when\n            // we're doing \"special\" chars.\n            (first_byte > ' ' && (rules & UnescapeRule::URL_SPECIAL_CHARS)) ||\n-           // Additionally allow control characters if requested.\n-           (first_byte < ' ' && (rules & UnescapeRule::CONTROL_CHARS)))) {\n+           // Additionally allow non-display characters if requested.\n+           (first_byte < ' ' &&\n+            (rules & UnescapeRule::SPOOFING_AND_CONTROL_CHARS)))) {\n         // Use the unescaped version of the character.\n         if (adjustments)\n           adjustments->push_back(base::OffsetAdjuster::Adjustment(i, 3, 1));",
        "diff_line_info": {
            "deleted_lines": [
                "      // binary data when loading the URL. For that reason, CONTROL_CHARS allows",
                "      // unescaping BiDi control characters.",
                "      // DO NOT use CONTROL_CHARS if the parsed URL is going to be displayed",
                "      // in the UI.",
                "      if (!(rules & UnescapeRule::CONTROL_CHARS)) {",
                "           // Additionally allow control characters if requested.",
                "           (first_byte < ' ' && (rules & UnescapeRule::CONTROL_CHARS)))) {"
            ],
            "added_lines": [
                "      // The following spoofable characters are also banned, because they could",
                "      // be used to imitate parts of a web browser's UI.",
                "      //",
                "      // U+1F50F LOCK WITH INK PEN         (%F0%9F%94%8F)",
                "      // U+1F510 CLOSED LOCK WITH KEY      (%F0%9F%94%90)",
                "      // U+1F512 LOCK                      (%F0%9F%94%92)",
                "      // U+1F513 OPEN LOCK                 (%F0%9F%94%93)",
                "      //",
                "      // binary data when loading the URL. For that reason,",
                "      // SPOOFING_AND_CONTROL_CHARS allows unescaping BiDi control characters.",
                "      // DO NOT use SPOOFING_AND_CONTROL_CHARS if the parsed URL is going to be",
                "      // displayed in the UI.",
                "      if (!(rules & UnescapeRule::SPOOFING_AND_CONTROL_CHARS)) {",
                "        if (HasFourByteBannedCharAtIndex(escaped_text, first_byte, i)) {",
                "          // Keep banned char escaped.",
                "          result.append(escaped_text, i, 12);",
                "          i += 11;",
                "          continue;",
                "        }",
                "           // Additionally allow non-display characters if requested.",
                "           (first_byte < ' ' &&",
                "            (rules & UnescapeRule::SPOOFING_AND_CONTROL_CHARS)))) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-1296",
        "func_name": "chromium/FormDataParserMultipart::GetNextNameValue",
        "description": "The UnescapeURLWithAdjustmentsImpl implementation in net/base/escape.cc in Google Chrome before 45.0.2454.85 does not prevent display of Unicode LOCK characters in the omnibox, which makes it easier for remote attackers to spoof the SSL lock icon by placing one of these characters at the end of a URL, as demonstrated by the omnibox in localizations for right-to-left languages.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/7c2cbc445a81424c7df48ebe61ec4d0dcadd5dff",
        "commit_title": "Added characters that look like padlocks to URL unescaping blacklist.",
        "commit_text": " This blacklists the following Unicode characters: - U+1F50F LOCK WITH INK PEN - U+1F510 CLOSED LOCK WITH KEY - U+1F512 LOCK - U+1F513 OPEN LOCK  This prevents LOCK characters from appearing in a URL in the Chrome UI, potentially looking like an SSL padlock icon (e.g., \"google.com/\" is now displayed as \"google.com/%F0%9F%94%92\"). This presented a spoofing risk due to a few complications: 1. In RTL mode, the end of the URL (path/query) is aligned right up    against the right edge of the Omnibox, where the SSL padlock is    usually displayed. 2. On Mac, ChromeOS, and Android, LOCK characters are displayed in    colour, making them more convincing.  Note: These characters will still be unescaped when using the SPOOFING_AND_CONTROL_CHARS unescape rule (used for decoding data URLs, previously known as CONTROL_CHARS).  TBR=jam@chromium.org   ",
        "func_before": "bool FormDataParserMultipart::GetNextNameValue(Result* result) {\n  if (source_.empty() || state_ != STATE_READY)\n    return false;\n\n  // 1. Read body-part headers.\n  base::StringPiece name;\n  base::StringPiece value;\n  bool value_assigned = false;\n  bool value_assigned_temp;\n  while (TryReadHeader(&name, &value, &value_assigned_temp))\n    value_assigned |= value_assigned_temp;\n  if (name.empty() || state_ == STATE_ERROR) {\n    state_ = STATE_ERROR;\n    return false;\n  }\n\n  // 2. Read the trailing CRLF after headers.\n  if (!RE2::Consume(&source_, crlf_pattern())) {\n    state_ = STATE_ERROR;\n    return false;\n  }\n\n  // 3. Read the data of this body part, i.e., everything until the first\n  // dash-boundary.\n  bool return_value;\n  if (value_assigned && source_.empty()) {  // Wait for a new source?\n    return_value = true;\n    state_ = STATE_SUSPEND;\n  } else {\n    return_value = FinishReadingPart(value_assigned ? NULL : &value);\n  }\n\n  std::string unescaped_name = net::UnescapeURLComponent(\n      name.as_string(),\n      net::UnescapeRule::URL_SPECIAL_CHARS | net::UnescapeRule::CONTROL_CHARS);\n  result->set_name(unescaped_name);\n  result->set_value(value);\n\n  return return_value;\n}",
        "func": "bool FormDataParserMultipart::GetNextNameValue(Result* result) {\n  if (source_.empty() || state_ != STATE_READY)\n    return false;\n\n  // 1. Read body-part headers.\n  base::StringPiece name;\n  base::StringPiece value;\n  bool value_assigned = false;\n  bool value_assigned_temp;\n  while (TryReadHeader(&name, &value, &value_assigned_temp))\n    value_assigned |= value_assigned_temp;\n  if (name.empty() || state_ == STATE_ERROR) {\n    state_ = STATE_ERROR;\n    return false;\n  }\n\n  // 2. Read the trailing CRLF after headers.\n  if (!RE2::Consume(&source_, crlf_pattern())) {\n    state_ = STATE_ERROR;\n    return false;\n  }\n\n  // 3. Read the data of this body part, i.e., everything until the first\n  // dash-boundary.\n  bool return_value;\n  if (value_assigned && source_.empty()) {  // Wait for a new source?\n    return_value = true;\n    state_ = STATE_SUSPEND;\n  } else {\n    return_value = FinishReadingPart(value_assigned ? NULL : &value);\n  }\n\n  std::string unescaped_name = net::UnescapeURLComponent(\n      name.as_string(), net::UnescapeRule::URL_SPECIAL_CHARS |\n                            net::UnescapeRule::SPOOFING_AND_CONTROL_CHARS);\n  result->set_name(unescaped_name);\n  result->set_value(value);\n\n  return return_value;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -31,8 +31,8 @@\n   }\n \n   std::string unescaped_name = net::UnescapeURLComponent(\n-      name.as_string(),\n-      net::UnescapeRule::URL_SPECIAL_CHARS | net::UnescapeRule::CONTROL_CHARS);\n+      name.as_string(), net::UnescapeRule::URL_SPECIAL_CHARS |\n+                            net::UnescapeRule::SPOOFING_AND_CONTROL_CHARS);\n   result->set_name(unescaped_name);\n   result->set_value(value);\n ",
        "diff_line_info": {
            "deleted_lines": [
                "      name.as_string(),",
                "      net::UnescapeRule::URL_SPECIAL_CHARS | net::UnescapeRule::CONTROL_CHARS);"
            ],
            "added_lines": [
                "      name.as_string(), net::UnescapeRule::URL_SPECIAL_CHARS |",
                "                            net::UnescapeRule::SPOOFING_AND_CONTROL_CHARS);"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-1297",
        "func_name": "chromium/ExtensionWebRequestEventRouter::GetMatchingListenersImpl",
        "description": "The WebRequest API implementation in extensions/browser/api/web_request/web_request_api.cc in Google Chrome before 45.0.2454.85 does not properly consider a request's source before accepting the request, which allows remote attackers to bypass intended access restrictions via a crafted (1) app or (2) extension.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/86154b409eed6ea7f9177f6bf576e76533ab2f7b",
        "commit_title": "Hide requests in an extension from other extensions",
        "commit_text": "   ",
        "func_before": "void ExtensionWebRequestEventRouter::GetMatchingListenersImpl(\n    void* browser_context,\n    net::URLRequest* request,\n    InfoMap* extension_info_map,\n    bool crosses_incognito,\n    const std::string& event_name,\n    const GURL& url,\n    int render_process_host_id,\n    int routing_id,\n    ResourceType resource_type,\n    bool is_async_request,\n    bool is_request_from_extension,\n    int* extra_info_spec,\n    std::vector<const ExtensionWebRequestEventRouter::EventListener*>*\n        matching_listeners) {\n  std::string web_request_event_name(event_name);\n  WebViewRendererState::WebViewInfo web_view_info;\n  bool is_web_view_guest = WebViewRendererState::GetInstance()->GetInfo(\n      render_process_host_id, routing_id, &web_view_info);\n  if (is_web_view_guest) {\n    web_request_event_name.replace(\n        0, sizeof(kWebRequestEventPrefix) - 1, webview::kWebViewEventPrefix);\n  }\n\n  std::set<EventListener>& listeners =\n      listeners_[browser_context][web_request_event_name];\n  for (std::set<EventListener>::iterator it = listeners.begin();\n       it != listeners.end(); ++it) {\n    if (!it->ipc_sender.get()) {\n      // The IPC sender has been deleted. This listener will be removed soon\n      // via a call to RemoveEventListener. For now, just skip it.\n      continue;\n    }\n\n    if (is_web_view_guest &&\n        (it->embedder_process_id != web_view_info.embedder_process_id ||\n         it->web_view_instance_id != web_view_info.instance_id))\n      continue;\n\n    if (!it->filter.urls.is_empty() && !it->filter.urls.MatchesURL(url))\n      continue;\n    if (web_request_event_router_delegate_ &&\n        web_request_event_router_delegate_->OnGetMatchingListenersImplCheck(\n            it->filter.tab_id, it->filter.window_id, request))\n      continue;\n    if (!it->filter.types.empty() &&\n        std::find(it->filter.types.begin(), it->filter.types.end(),\n                  resource_type) == it->filter.types.end())\n      continue;\n\n    if (!is_web_view_guest && !WebRequestPermissions::CanExtensionAccessURL(\n            extension_info_map, it->extension_id, url, crosses_incognito,\n            WebRequestPermissions::REQUIRE_HOST_PERMISSION))\n      continue;\n\n    bool blocking_listener =\n        (it->extra_info_spec &\n            (ExtraInfoSpec::BLOCKING | ExtraInfoSpec::ASYNC_BLOCKING)) != 0;\n\n    // We do not want to notify extensions about XHR requests that are\n    // triggered by themselves. This is a workaround to prevent deadlocks\n    // in case of synchronous XHR requests that block the extension renderer\n    // and therefore prevent the extension from processing the request\n    // handler. This is only a problem for blocking listeners.\n    // http://crbug.com/105656\n    bool synchronous_xhr_from_extension =\n        !is_async_request && is_request_from_extension &&\n        resource_type == content::RESOURCE_TYPE_XHR;\n\n    // Only send webRequest events for URLs the extension has access to.\n    if (blocking_listener && synchronous_xhr_from_extension)\n      continue;\n\n    matching_listeners->push_back(&(*it));\n    *extra_info_spec |= it->extra_info_spec;\n  }\n}",
        "func": "void ExtensionWebRequestEventRouter::GetMatchingListenersImpl(\n    void* browser_context,\n    net::URLRequest* request,\n    InfoMap* extension_info_map,\n    bool crosses_incognito,\n    const std::string& event_name,\n    const GURL& url,\n    int render_process_host_id,\n    int routing_id,\n    ResourceType resource_type,\n    bool is_async_request,\n    bool is_request_from_extension,\n    int* extra_info_spec,\n    std::vector<const ExtensionWebRequestEventRouter::EventListener*>*\n        matching_listeners) {\n  std::string web_request_event_name(event_name);\n  WebViewRendererState::WebViewInfo web_view_info;\n  bool is_web_view_guest = WebViewRendererState::GetInstance()->GetInfo(\n      render_process_host_id, routing_id, &web_view_info);\n  if (is_web_view_guest) {\n    web_request_event_name.replace(\n        0, sizeof(kWebRequestEventPrefix) - 1, webview::kWebViewEventPrefix);\n  }\n\n  std::set<EventListener>& listeners =\n      listeners_[browser_context][web_request_event_name];\n  for (std::set<EventListener>::iterator it = listeners.begin();\n       it != listeners.end(); ++it) {\n    if (!it->ipc_sender.get()) {\n      // The IPC sender has been deleted. This listener will be removed soon\n      // via a call to RemoveEventListener. For now, just skip it.\n      continue;\n    }\n\n    if (is_web_view_guest &&\n        (it->embedder_process_id != web_view_info.embedder_process_id ||\n         it->web_view_instance_id != web_view_info.instance_id))\n      continue;\n\n    // Filter requests from other extensions / apps. This does not work for\n    // content scripts, or extension pages in non-extension processes.\n    if (is_request_from_extension &&\n        it->embedder_process_id != render_process_host_id)\n      continue;\n\n    if (!it->filter.urls.is_empty() && !it->filter.urls.MatchesURL(url))\n      continue;\n    if (web_request_event_router_delegate_ &&\n        web_request_event_router_delegate_->OnGetMatchingListenersImplCheck(\n            it->filter.tab_id, it->filter.window_id, request))\n      continue;\n    if (!it->filter.types.empty() &&\n        std::find(it->filter.types.begin(), it->filter.types.end(),\n                  resource_type) == it->filter.types.end())\n      continue;\n\n    if (!is_web_view_guest && !WebRequestPermissions::CanExtensionAccessURL(\n            extension_info_map, it->extension_id, url, crosses_incognito,\n            WebRequestPermissions::REQUIRE_HOST_PERMISSION))\n      continue;\n\n    bool blocking_listener =\n        (it->extra_info_spec &\n            (ExtraInfoSpec::BLOCKING | ExtraInfoSpec::ASYNC_BLOCKING)) != 0;\n\n    // We do not want to notify extensions about XHR requests that are\n    // triggered by themselves. This is a workaround to prevent deadlocks\n    // in case of synchronous XHR requests that block the extension renderer\n    // and therefore prevent the extension from processing the request\n    // handler. This is only a problem for blocking listeners.\n    // http://crbug.com/105656\n    bool synchronous_xhr_from_extension =\n        !is_async_request && is_request_from_extension &&\n        resource_type == content::RESOURCE_TYPE_XHR;\n\n    // Only send webRequest events for URLs the extension has access to.\n    if (blocking_listener && synchronous_xhr_from_extension)\n      continue;\n\n    matching_listeners->push_back(&(*it));\n    *extra_info_spec |= it->extra_info_spec;\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -35,6 +35,12 @@\n     if (is_web_view_guest &&\n         (it->embedder_process_id != web_view_info.embedder_process_id ||\n          it->web_view_instance_id != web_view_info.instance_id))\n+      continue;\n+\n+    // Filter requests from other extensions / apps. This does not work for\n+    // content scripts, or extension pages in non-extension processes.\n+    if (is_request_from_extension &&\n+        it->embedder_process_id != render_process_host_id)\n       continue;\n \n     if (!it->filter.urls.is_empty() && !it->filter.urls.MatchesURL(url))",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "      continue;",
                "",
                "    // Filter requests from other extensions / apps. This does not work for",
                "    // content scripts, or extension pages in non-extension processes.",
                "    if (is_request_from_extension &&",
                "        it->embedder_process_id != render_process_host_id)"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-1297",
        "func_name": "chromium/ExtensionWebRequestEventRouter::OnEventHandled",
        "description": "The WebRequest API implementation in extensions/browser/api/web_request/web_request_api.cc in Google Chrome before 45.0.2454.85 does not properly consider a request's source before accepting the request, which allows remote attackers to bypass intended access restrictions via a crafted (1) app or (2) extension.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/86154b409eed6ea7f9177f6bf576e76533ab2f7b",
        "commit_title": "Hide requests in an extension from other extensions",
        "commit_text": "   ",
        "func_before": "void ExtensionWebRequestEventRouter::OnEventHandled(\n    void* browser_context,\n    const std::string& extension_id,\n    const std::string& event_name,\n    const std::string& sub_event_name,\n    uint64 request_id,\n    EventResponse* response) {\n  EventListener listener;\n  listener.extension_id = extension_id;\n  listener.sub_event_name = sub_event_name;\n\n  // The listener may have been removed (e.g. due to the process going away)\n  // before we got here.\n  std::set<EventListener>::iterator found =\n      listeners_[browser_context][event_name].find(listener);\n  if (found != listeners_[browser_context][event_name].end())\n    found->blocked_requests.erase(request_id);\n\n  DecrementBlockCount(\n      browser_context, extension_id, event_name, request_id, response);\n}",
        "func": "void ExtensionWebRequestEventRouter::OnEventHandled(\n    void* browser_context,\n    const std::string& extension_id,\n    const std::string& event_name,\n    const std::string& sub_event_name,\n    uint64 request_id,\n    EventResponse* response) {\n  // TODO(robwu): Does this also work with webviews? operator< (used by find)\n  // takes the webview ID into account, which is not set on |listener|.\n  EventListener listener;\n  listener.extension_id = extension_id;\n  listener.sub_event_name = sub_event_name;\n\n  // The listener may have been removed (e.g. due to the process going away)\n  // before we got here.\n  std::set<EventListener>::iterator found =\n      listeners_[browser_context][event_name].find(listener);\n  if (found != listeners_[browser_context][event_name].end())\n    found->blocked_requests.erase(request_id);\n\n  DecrementBlockCount(\n      browser_context, extension_id, event_name, request_id, response);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,6 +5,8 @@\n     const std::string& sub_event_name,\n     uint64 request_id,\n     EventResponse* response) {\n+  // TODO(robwu): Does this also work with webviews? operator< (used by find)\n+  // takes the webview ID into account, which is not set on |listener|.\n   EventListener listener;\n   listener.extension_id = extension_id;\n   listener.sub_event_name = sub_event_name;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "  // TODO(robwu): Does this also work with webviews? operator< (used by find)",
                "  // takes the webview ID into account, which is not set on |listener|."
            ]
        }
    },
    {
        "cve_id": "CVE-2015-1297",
        "func_name": "chromium/operator<",
        "description": "The WebRequest API implementation in extensions/browser/api/web_request/web_request_api.cc in Google Chrome before 45.0.2454.85 does not properly consider a request's source before accepting the request, which allows remote attackers to bypass intended access restrictions via a crafted (1) app or (2) extension.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/86154b409eed6ea7f9177f6bf576e76533ab2f7b",
        "commit_title": "Hide requests in an extension from other extensions",
        "commit_text": "   ",
        "func_before": "bool operator<(const EventListener& that) const {\n    if (extension_id != that.extension_id)\n      return extension_id < that.extension_id;\n\n    if (sub_event_name != that.sub_event_name)\n      return sub_event_name < that.sub_event_name;\n\n    if (embedder_process_id != that.embedder_process_id)\n      return embedder_process_id < that.embedder_process_id;\n\n    if (web_view_instance_id != that.web_view_instance_id)\n      return web_view_instance_id < that.web_view_instance_id;\n\n    return false;\n  }",
        "func": "bool operator<(const EventListener& that) const {\n    if (extension_id != that.extension_id)\n      return extension_id < that.extension_id;\n\n    if (sub_event_name != that.sub_event_name)\n      return sub_event_name < that.sub_event_name;\n\n    if (web_view_instance_id != that.web_view_instance_id)\n      return web_view_instance_id < that.web_view_instance_id;\n\n    if (web_view_instance_id == 0) {\n      // Do not filter by process ID for non-webviews, because this comparator\n      // is also used to find and remove an event listener when an extension is\n      // unloaded. At this point, the event listener cannot be mapped back to\n      // the original process, so 0 is used instead of the actual process ID.\n      DCHECK(embedder_process_id == 0 || that.embedder_process_id == 0);\n      return false;\n    }\n\n    if (embedder_process_id != that.embedder_process_id)\n      return embedder_process_id < that.embedder_process_id;\n\n    return false;\n  }",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,11 +5,20 @@\n     if (sub_event_name != that.sub_event_name)\n       return sub_event_name < that.sub_event_name;\n \n+    if (web_view_instance_id != that.web_view_instance_id)\n+      return web_view_instance_id < that.web_view_instance_id;\n+\n+    if (web_view_instance_id == 0) {\n+      // Do not filter by process ID for non-webviews, because this comparator\n+      // is also used to find and remove an event listener when an extension is\n+      // unloaded. At this point, the event listener cannot be mapped back to\n+      // the original process, so 0 is used instead of the actual process ID.\n+      DCHECK(embedder_process_id == 0 || that.embedder_process_id == 0);\n+      return false;\n+    }\n+\n     if (embedder_process_id != that.embedder_process_id)\n       return embedder_process_id < that.embedder_process_id;\n \n-    if (web_view_instance_id != that.web_view_instance_id)\n-      return web_view_instance_id < that.web_view_instance_id;\n-\n     return false;\n   }",
        "diff_line_info": {
            "deleted_lines": [
                "    if (web_view_instance_id != that.web_view_instance_id)",
                "      return web_view_instance_id < that.web_view_instance_id;",
                ""
            ],
            "added_lines": [
                "    if (web_view_instance_id != that.web_view_instance_id)",
                "      return web_view_instance_id < that.web_view_instance_id;",
                "",
                "    if (web_view_instance_id == 0) {",
                "      // Do not filter by process ID for non-webviews, because this comparator",
                "      // is also used to find and remove an event listener when an extension is",
                "      // unloaded. At this point, the event listener cannot be mapped back to",
                "      // the original process, so 0 is used instead of the actual process ID.",
                "      DCHECK(embedder_process_id == 0 || that.embedder_process_id == 0);",
                "      return false;",
                "    }",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2015-1297",
        "func_name": "chromium/WebRequestAPI::OnListenerRemoved",
        "description": "The WebRequest API implementation in extensions/browser/api/web_request/web_request_api.cc in Google Chrome before 45.0.2454.85 does not properly consider a request's source before accepting the request, which allows remote attackers to bypass intended access restrictions via a crafted (1) app or (2) extension.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/86154b409eed6ea7f9177f6bf576e76533ab2f7b",
        "commit_title": "Hide requests in an extension from other extensions",
        "commit_text": "   ",
        "func_before": "void WebRequestAPI::OnListenerRemoved(const EventListenerInfo& details) {\n  DCHECK_CURRENTLY_ON(BrowserThread::UI);\n  // Note that details.event_name includes the sub-event details (e.g. \"/123\").\n  // TODO(fsamuel): <webview> events will not be removed through this code path.\n  // <webview> events will be removed in RemoveWebViewEventListeners. Ideally,\n  // this code should be decoupled from extensions, we should use the host ID\n  // instead, and not have two different code paths. This is a huge undertaking\n  // unfortunately, so we'll resort to two code paths for now.\n  BrowserThread::PostTask(BrowserThread::IO,\n                          FROM_HERE,\n                          base::Bind(&RemoveEventListenerOnIOThread,\n                                     details.browser_context,\n                                     details.extension_id,\n                                     details.event_name,\n                                     0 /* embedder_process_id */,\n                                     0 /* web_view_instance_id */));\n}",
        "func": "void WebRequestAPI::OnListenerRemoved(const EventListenerInfo& details) {\n  DCHECK_CURRENTLY_ON(BrowserThread::UI);\n  // Note that details.event_name includes the sub-event details (e.g. \"/123\").\n  // TODO(fsamuel): <webview> events will not be removed through this code path.\n  // <webview> events will be removed in RemoveWebViewEventListeners. Ideally,\n  // this code should be decoupled from extensions, we should use the host ID\n  // instead, and not have two different code paths. This is a huge undertaking\n  // unfortunately, so we'll resort to two code paths for now.\n  BrowserThread::PostTask(BrowserThread::IO,\n                          FROM_HERE,\n                          base::Bind(&RemoveEventListenerOnIOThread,\n                                     details.browser_context,\n                                     details.extension_id,\n                                     details.event_name,\n                                     0 /* embedder_process_id (ignored) */,\n                                     0 /* web_view_instance_id */));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -12,6 +12,6 @@\n                                      details.browser_context,\n                                      details.extension_id,\n                                      details.event_name,\n-                                     0 /* embedder_process_id */,\n+                                     0 /* embedder_process_id (ignored) */,\n                                      0 /* web_view_instance_id */));\n }",
        "diff_line_info": {
            "deleted_lines": [
                "                                     0 /* embedder_process_id */,"
            ],
            "added_lines": [
                "                                     0 /* embedder_process_id (ignored) */,"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-1297",
        "func_name": "chromium/WebRequestInternalAddEventListenerFunction::RunSync",
        "description": "The WebRequest API implementation in extensions/browser/api/web_request/web_request_api.cc in Google Chrome before 45.0.2454.85 does not properly consider a request's source before accepting the request, which allows remote attackers to bypass intended access restrictions via a crafted (1) app or (2) extension.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/86154b409eed6ea7f9177f6bf576e76533ab2f7b",
        "commit_title": "Hide requests in an extension from other extensions",
        "commit_text": "   ",
        "func_before": "bool WebRequestInternalAddEventListenerFunction::RunSync() {\n  // Argument 0 is the callback, which we don't use here.\n  ExtensionWebRequestEventRouter::RequestFilter filter;\n  base::DictionaryValue* value = NULL;\n  error_.clear();\n  EXTENSION_FUNCTION_VALIDATE(args_->GetDictionary(1, &value));\n  // Failure + an empty error string means a fatal error.\n  EXTENSION_FUNCTION_VALIDATE(filter.InitFromValue(*value, &error_) ||\n                              !error_.empty());\n  if (!error_.empty())\n    return false;\n\n  int extra_info_spec = 0;\n  if (HasOptionalArgument(2)) {\n    base::ListValue* value = NULL;\n    EXTENSION_FUNCTION_VALIDATE(args_->GetList(2, &value));\n    EXTENSION_FUNCTION_VALIDATE(\n        ExtensionWebRequestEventRouter::ExtraInfoSpec::InitFromValue(\n            *value, &extra_info_spec));\n  }\n\n  std::string event_name;\n  EXTENSION_FUNCTION_VALIDATE(args_->GetString(3, &event_name));\n\n  std::string sub_event_name;\n  EXTENSION_FUNCTION_VALIDATE(args_->GetString(4, &sub_event_name));\n\n  int web_view_instance_id = 0;\n  EXTENSION_FUNCTION_VALIDATE(args_->GetInteger(5, &web_view_instance_id));\n\n  base::WeakPtr<IOThreadExtensionMessageFilter> ipc_sender = ipc_sender_weak();\n  int embedder_process_id =\n      ipc_sender.get() && web_view_instance_id > 0 ?\n          ipc_sender->render_process_id() : 0;\n\n  const Extension* extension =\n      extension_info_map()->extensions().GetByID(extension_id_safe());\n  std::string extension_name =\n      extension ? extension->name() : extension_id_safe();\n\n  if (!web_view_instance_id) {\n    // We check automatically whether the extension has the 'webRequest'\n    // permission. For blocking calls we require the additional permission\n    // 'webRequestBlocking'.\n    if ((extra_info_spec &\n         (ExtensionWebRequestEventRouter::ExtraInfoSpec::BLOCKING |\n          ExtensionWebRequestEventRouter::ExtraInfoSpec::ASYNC_BLOCKING)) &&\n        !extension->permissions_data()->HasAPIPermission(\n            APIPermission::kWebRequestBlocking)) {\n      error_ = keys::kBlockingPermissionRequired;\n      return false;\n    }\n\n    // We allow to subscribe to patterns that are broader than the host\n    // permissions. E.g., we could subscribe to http://www.example.com/*\n    // while having host permissions for http://www.example.com/foo/* and\n    // http://www.example.com/bar/*.\n    // For this reason we do only a coarse check here to warn the extension\n    // developer if he does something obviously wrong.\n    if (extension->permissions_data()\n            ->GetEffectiveHostPermissions()\n            .is_empty()) {\n      error_ = keys::kHostPermissionsRequired;\n      return false;\n    }\n  }\n\n  bool success =\n      ExtensionWebRequestEventRouter::GetInstance()->AddEventListener(\n          profile_id(), extension_id_safe(), extension_name,\n          event_name, sub_event_name, filter, extra_info_spec,\n          embedder_process_id, web_view_instance_id, ipc_sender_weak());\n  EXTENSION_FUNCTION_VALIDATE(success);\n\n  helpers::ClearCacheOnNavigation();\n\n  if (!extension_id_safe().empty()) {\n    BrowserThread::PostTask(BrowserThread::UI, FROM_HERE,\n                            base::Bind(&helpers::NotifyWebRequestAPIUsed,\n                                       profile_id(), extension_id_safe()));\n  }\n\n  return true;\n}",
        "func": "bool WebRequestInternalAddEventListenerFunction::RunSync() {\n  // Argument 0 is the callback, which we don't use here.\n  ExtensionWebRequestEventRouter::RequestFilter filter;\n  base::DictionaryValue* value = NULL;\n  error_.clear();\n  EXTENSION_FUNCTION_VALIDATE(args_->GetDictionary(1, &value));\n  // Failure + an empty error string means a fatal error.\n  EXTENSION_FUNCTION_VALIDATE(filter.InitFromValue(*value, &error_) ||\n                              !error_.empty());\n  if (!error_.empty())\n    return false;\n\n  int extra_info_spec = 0;\n  if (HasOptionalArgument(2)) {\n    base::ListValue* value = NULL;\n    EXTENSION_FUNCTION_VALIDATE(args_->GetList(2, &value));\n    EXTENSION_FUNCTION_VALIDATE(\n        ExtensionWebRequestEventRouter::ExtraInfoSpec::InitFromValue(\n            *value, &extra_info_spec));\n  }\n\n  std::string event_name;\n  EXTENSION_FUNCTION_VALIDATE(args_->GetString(3, &event_name));\n\n  std::string sub_event_name;\n  EXTENSION_FUNCTION_VALIDATE(args_->GetString(4, &sub_event_name));\n\n  int web_view_instance_id = 0;\n  EXTENSION_FUNCTION_VALIDATE(args_->GetInteger(5, &web_view_instance_id));\n\n  base::WeakPtr<IOThreadExtensionMessageFilter> ipc_sender = ipc_sender_weak();\n  int embedder_process_id = ipc_sender ? ipc_sender->render_process_id() : 0;\n\n  const Extension* extension =\n      extension_info_map()->extensions().GetByID(extension_id_safe());\n  std::string extension_name =\n      extension ? extension->name() : extension_id_safe();\n\n  if (!web_view_instance_id) {\n    // We check automatically whether the extension has the 'webRequest'\n    // permission. For blocking calls we require the additional permission\n    // 'webRequestBlocking'.\n    if ((extra_info_spec &\n         (ExtensionWebRequestEventRouter::ExtraInfoSpec::BLOCKING |\n          ExtensionWebRequestEventRouter::ExtraInfoSpec::ASYNC_BLOCKING)) &&\n        !extension->permissions_data()->HasAPIPermission(\n            APIPermission::kWebRequestBlocking)) {\n      error_ = keys::kBlockingPermissionRequired;\n      return false;\n    }\n\n    // We allow to subscribe to patterns that are broader than the host\n    // permissions. E.g., we could subscribe to http://www.example.com/*\n    // while having host permissions for http://www.example.com/foo/* and\n    // http://www.example.com/bar/*.\n    // For this reason we do only a coarse check here to warn the extension\n    // developer if he does something obviously wrong.\n    if (extension->permissions_data()\n            ->GetEffectiveHostPermissions()\n            .is_empty()) {\n      error_ = keys::kHostPermissionsRequired;\n      return false;\n    }\n  }\n\n  bool success =\n      ExtensionWebRequestEventRouter::GetInstance()->AddEventListener(\n          profile_id(), extension_id_safe(), extension_name,\n          event_name, sub_event_name, filter, extra_info_spec,\n          embedder_process_id, web_view_instance_id, ipc_sender_weak());\n  EXTENSION_FUNCTION_VALIDATE(success);\n\n  helpers::ClearCacheOnNavigation();\n\n  if (!extension_id_safe().empty()) {\n    BrowserThread::PostTask(BrowserThread::UI, FROM_HERE,\n                            base::Bind(&helpers::NotifyWebRequestAPIUsed,\n                                       profile_id(), extension_id_safe()));\n  }\n\n  return true;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -29,9 +29,7 @@\n   EXTENSION_FUNCTION_VALIDATE(args_->GetInteger(5, &web_view_instance_id));\n \n   base::WeakPtr<IOThreadExtensionMessageFilter> ipc_sender = ipc_sender_weak();\n-  int embedder_process_id =\n-      ipc_sender.get() && web_view_instance_id > 0 ?\n-          ipc_sender->render_process_id() : 0;\n+  int embedder_process_id = ipc_sender ? ipc_sender->render_process_id() : 0;\n \n   const Extension* extension =\n       extension_info_map()->extensions().GetByID(extension_id_safe());",
        "diff_line_info": {
            "deleted_lines": [
                "  int embedder_process_id =",
                "      ipc_sender.get() && web_view_instance_id > 0 ?",
                "          ipc_sender->render_process_id() : 0;"
            ],
            "added_lines": [
                "  int embedder_process_id = ipc_sender ? ipc_sender->render_process_id() : 0;"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-1298",
        "func_name": "chromium/RuntimeSetUninstallURLFunction::Run",
        "description": "The RuntimeEventRouter::OnExtensionUninstalled function in extensions/browser/api/runtime/runtime_api.cc in Google Chrome before 45.0.2454.85 does not ensure that the setUninstallURL preference corresponds to the URL of a web site, which allows user-assisted remote attackers to trigger access to an arbitrary URL via a crafted extension that is uninstalled.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/28fc5b095a1d19eb104a76a08d55292831dce9fa",
        "commit_title": "Restrict chrome.runtime.setUninstallURL to http(s)",
        "commit_text": " Disallow URLs other than http(s) in chrome.runtime.setUninstallURL. And allow empty URLs to be set to clear the uninstallation URL. Added an optional callback, to know when setting the URL finished (or failed).    ",
        "func_before": "ExtensionFunction::ResponseAction RuntimeSetUninstallURLFunction::Run() {\n  std::string url_string;\n  EXTENSION_FUNCTION_VALIDATE(args_->GetString(0, &url_string));\n\n  GURL url(url_string);\n  if (!url.is_valid()) {\n    return RespondNow(\n        Error(ErrorUtils::FormatErrorMessage(kInvalidUrlError, url_string)));\n  }\n  SetUninstallURL(\n      ExtensionPrefs::Get(browser_context()), extension_id(), url_string);\n  return RespondNow(NoArguments());\n}",
        "func": "ExtensionFunction::ResponseAction RuntimeSetUninstallURLFunction::Run() {\n  std::string url_string;\n  EXTENSION_FUNCTION_VALIDATE(args_->GetString(0, &url_string));\n\n  if (!url_string.empty() && !GURL(url_string).SchemeIsHTTPOrHTTPS()) {\n    return RespondNow(Error(kInvalidUrlError, url_string));\n  }\n  SetUninstallURL(\n      ExtensionPrefs::Get(browser_context()), extension_id(), url_string);\n  return RespondNow(NoArguments());\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,10 +2,8 @@\n   std::string url_string;\n   EXTENSION_FUNCTION_VALIDATE(args_->GetString(0, &url_string));\n \n-  GURL url(url_string);\n-  if (!url.is_valid()) {\n-    return RespondNow(\n-        Error(ErrorUtils::FormatErrorMessage(kInvalidUrlError, url_string)));\n+  if (!url_string.empty() && !GURL(url_string).SchemeIsHTTPOrHTTPS()) {\n+    return RespondNow(Error(kInvalidUrlError, url_string));\n   }\n   SetUninstallURL(\n       ExtensionPrefs::Get(browser_context()), extension_id(), url_string);",
        "diff_line_info": {
            "deleted_lines": [
                "  GURL url(url_string);",
                "  if (!url.is_valid()) {",
                "    return RespondNow(",
                "        Error(ErrorUtils::FormatErrorMessage(kInvalidUrlError, url_string)));"
            ],
            "added_lines": [
                "  if (!url_string.empty() && !GURL(url_string).SchemeIsHTTPOrHTTPS()) {",
                "    return RespondNow(Error(kInvalidUrlError, url_string));"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-1298",
        "func_name": "chromium/RuntimeEventRouter::OnExtensionUninstalled",
        "description": "The RuntimeEventRouter::OnExtensionUninstalled function in extensions/browser/api/runtime/runtime_api.cc in Google Chrome before 45.0.2454.85 does not ensure that the setUninstallURL preference corresponds to the URL of a web site, which allows user-assisted remote attackers to trigger access to an arbitrary URL via a crafted extension that is uninstalled.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/28fc5b095a1d19eb104a76a08d55292831dce9fa",
        "commit_title": "Restrict chrome.runtime.setUninstallURL to http(s)",
        "commit_text": " Disallow URLs other than http(s) in chrome.runtime.setUninstallURL. And allow empty URLs to be set to clear the uninstallation URL. Added an optional callback, to know when setting the URL finished (or failed).    ",
        "func_before": "void RuntimeEventRouter::OnExtensionUninstalled(\n    content::BrowserContext* context,\n    const std::string& extension_id,\n    UninstallReason reason) {\n  if (!(reason == UNINSTALL_REASON_USER_INITIATED ||\n        reason == UNINSTALL_REASON_MANAGEMENT_API)) {\n    return;\n  }\n\n  GURL uninstall_url(\n      GetUninstallURL(ExtensionPrefs::Get(context), extension_id));\n\n  if (uninstall_url.is_empty())\n    return;\n\n  RuntimeAPI::GetFactoryInstance()->Get(context)->OpenURL(uninstall_url);\n}",
        "func": "void RuntimeEventRouter::OnExtensionUninstalled(\n    content::BrowserContext* context,\n    const std::string& extension_id,\n    UninstallReason reason) {\n  if (!(reason == UNINSTALL_REASON_USER_INITIATED ||\n        reason == UNINSTALL_REASON_MANAGEMENT_API)) {\n    return;\n  }\n\n  GURL uninstall_url(\n      GetUninstallURL(ExtensionPrefs::Get(context), extension_id));\n\n  if (!uninstall_url.SchemeIsHTTPOrHTTPS()) {\n    // Previous versions of Chrome allowed non-http(s) URLs to be stored in the\n    // prefs. Now they're disallowed, but the old data may still exist.\n    return;\n  }\n\n  RuntimeAPI::GetFactoryInstance()->Get(context)->OpenURL(uninstall_url);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -10,8 +10,11 @@\n   GURL uninstall_url(\n       GetUninstallURL(ExtensionPrefs::Get(context), extension_id));\n \n-  if (uninstall_url.is_empty())\n+  if (!uninstall_url.SchemeIsHTTPOrHTTPS()) {\n+    // Previous versions of Chrome allowed non-http(s) URLs to be stored in the\n+    // prefs. Now they're disallowed, but the old data may still exist.\n     return;\n+  }\n \n   RuntimeAPI::GetFactoryInstance()->Get(context)->OpenURL(uninstall_url);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "  if (uninstall_url.is_empty())"
            ],
            "added_lines": [
                "  if (!uninstall_url.SchemeIsHTTPOrHTTPS()) {",
                "    // Previous versions of Chrome allowed non-http(s) URLs to be stored in the",
                "    // prefs. Now they're disallowed, but the old data may still exist.",
                "  }"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-1300",
        "func_name": "chromium/FrameFetchContext::updateTimingInfoForIFrameNavigation",
        "description": "The FrameFetchContext::updateTimingInfoForIFrameNavigation function in core/loader/FrameFetchContext.cpp in Blink, as used in Google Chrome before 45.0.2454.85, does not properly restrict the availability of IFRAME Resource Timing API times, which allows remote attackers to obtain sensitive information via crafted JavaScript code that leverages a history.back call.",
        "git_url": "https://github.com/chromium/chromium/commit/acf50d484e3b9fdc676a75d266303c7163b2f59f",
        "commit_title": "Do not report Resource Timing for iframe navigations when restored from history",
        "commit_text": " In a back/forward navigation, iframe navigates to its final URL directly. Iframes should not report Resource Timing except for the initial navigation requested by the parent document.   ",
        "func_before": "bool FrameFetchContext::updateTimingInfoForIFrameNavigation(ResourceTimingInfo* info)\n{\n    // <iframe>s should report the initial navigation requested by the parent document, but not subsequent navigations.\n    // FIXME: Resource timing is broken when the parent is a remote frame.\n    if (!frame()->deprecatedLocalOwner() || frame()->deprecatedLocalOwner()->loadedNonEmptyDocument())\n        return false;\n    info->setInitiatorType(frame()->deprecatedLocalOwner()->localName());\n    frame()->deprecatedLocalOwner()->didLoadNonEmptyDocument();\n    return true;\n}",
        "func": "bool FrameFetchContext::updateTimingInfoForIFrameNavigation(ResourceTimingInfo* info)\n{\n    // <iframe>s should report the initial navigation requested by the parent document, but not subsequent navigations.\n    // FIXME: Resource timing is broken when the parent is a remote frame.\n    if (!frame()->deprecatedLocalOwner() || frame()->deprecatedLocalOwner()->loadedNonEmptyDocument())\n        return false;\n    frame()->deprecatedLocalOwner()->didLoadNonEmptyDocument();\n    // Do not report iframe navigation that restored from history, since its\n    // location may have been changed after initial navigation.\n    if (frame()->loader().loadType() == FrameLoadTypeInitialHistoryLoad)\n        return false;\n    info->setInitiatorType(frame()->deprecatedLocalOwner()->localName());\n    return true;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,7 +4,11 @@\n     // FIXME: Resource timing is broken when the parent is a remote frame.\n     if (!frame()->deprecatedLocalOwner() || frame()->deprecatedLocalOwner()->loadedNonEmptyDocument())\n         return false;\n+    frame()->deprecatedLocalOwner()->didLoadNonEmptyDocument();\n+    // Do not report iframe navigation that restored from history, since its\n+    // location may have been changed after initial navigation.\n+    if (frame()->loader().loadType() == FrameLoadTypeInitialHistoryLoad)\n+        return false;\n     info->setInitiatorType(frame()->deprecatedLocalOwner()->localName());\n-    frame()->deprecatedLocalOwner()->didLoadNonEmptyDocument();\n     return true;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    frame()->deprecatedLocalOwner()->didLoadNonEmptyDocument();"
            ],
            "added_lines": [
                "    frame()->deprecatedLocalOwner()->didLoadNonEmptyDocument();",
                "    // Do not report iframe navigation that restored from history, since its",
                "    // location may have been changed after initial navigation.",
                "    if (frame()->loader().loadType() == FrameLoadTypeInitialHistoryLoad)",
                "        return false;"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-6582",
        "func_name": "chromium/decompose",
        "description": "The decompose function in platform/transforms/TransformationMatrix.cpp in Blink, as used in Google Chrome before 45.0.2454.85, does not verify that a matrix inversion succeeded, which allows remote attackers to cause a denial of service (uninitialized memory access and application crash) or possibly have unspecified other impact via a crafted web site.",
        "git_url": "https://github.com/chromium/chromium/commit/1fdafc3d1a1e067b73021696c0ed08a33ca7c325",
        "commit_title": "Fix use of uninitialized memory in TransformationMatrix decompose()",
        "commit_text": " The static decompose() method in TransformationMatrix.cpp called inverse() without checking the return value for success. If the matrix fails to invert the function proceeds to use the uninitialized return parameter as if it had succeeded.  This patch ensures decompose() fails if inverse() fails avoiding the use of uninitialized memory.   ",
        "func_before": "static bool decompose(const TransformationMatrix::Matrix4& mat, TransformationMatrix::DecomposedType& result)\n{\n    TransformationMatrix::Matrix4 localMatrix;\n    memcpy(localMatrix, mat, sizeof(TransformationMatrix::Matrix4));\n\n    // Normalize the matrix.\n    if (localMatrix[3][3] == 0)\n        return false;\n\n    int i, j;\n    for (i = 0; i < 4; i++)\n        for (j = 0; j < 4; j++)\n            localMatrix[i][j] /= localMatrix[3][3];\n\n    // perspectiveMatrix is used to solve for perspective, but it also provides\n    // an easy way to test for singularity of the upper 3x3 component.\n    TransformationMatrix::Matrix4 perspectiveMatrix;\n    memcpy(perspectiveMatrix, localMatrix, sizeof(TransformationMatrix::Matrix4));\n    for (i = 0; i < 3; i++)\n        perspectiveMatrix[i][3] = 0;\n    perspectiveMatrix[3][3] = 1;\n\n    if (determinant4x4(perspectiveMatrix) == 0)\n        return false;\n\n    // First, isolate perspective.  This is the messiest.\n    if (localMatrix[0][3] != 0 || localMatrix[1][3] != 0 || localMatrix[2][3] != 0) {\n        // rightHandSide is the right hand side of the equation.\n        Vector4 rightHandSide;\n        rightHandSide[0] = localMatrix[0][3];\n        rightHandSide[1] = localMatrix[1][3];\n        rightHandSide[2] = localMatrix[2][3];\n        rightHandSide[3] = localMatrix[3][3];\n\n        // Solve the equation by inverting perspectiveMatrix and multiplying\n        // rightHandSide by the inverse.  (This is the easiest way, not\n        // necessarily the best.)\n        TransformationMatrix::Matrix4 inversePerspectiveMatrix, transposedInversePerspectiveMatrix;\n        inverse(perspectiveMatrix, inversePerspectiveMatrix);\n        transposeMatrix4(inversePerspectiveMatrix, transposedInversePerspectiveMatrix);\n\n        Vector4 perspectivePoint;\n        v4MulPointByMatrix(rightHandSide, transposedInversePerspectiveMatrix, perspectivePoint);\n\n        result.perspectiveX = perspectivePoint[0];\n        result.perspectiveY = perspectivePoint[1];\n        result.perspectiveZ = perspectivePoint[2];\n        result.perspectiveW = perspectivePoint[3];\n\n        // Clear the perspective partition\n        localMatrix[0][3] = localMatrix[1][3] = localMatrix[2][3] = 0;\n        localMatrix[3][3] = 1;\n    } else {\n        // No perspective.\n        result.perspectiveX = result.perspectiveY = result.perspectiveZ = 0;\n        result.perspectiveW = 1;\n    }\n\n    // Next take care of translation (easy).\n    result.translateX = localMatrix[3][0];\n    localMatrix[3][0] = 0;\n    result.translateY = localMatrix[3][1];\n    localMatrix[3][1] = 0;\n    result.translateZ = localMatrix[3][2];\n    localMatrix[3][2] = 0;\n\n    // Vector4 type and functions need to be added to the common set.\n    Vector3 row[3], pdum3;\n\n    // Now get scale and shear.\n    for (i = 0; i < 3; i++) {\n        row[i][0] = localMatrix[i][0];\n        row[i][1] = localMatrix[i][1];\n        row[i][2] = localMatrix[i][2];\n    }\n\n    // Compute X scale factor and normalize first row.\n    result.scaleX = v3Length(row[0]);\n    v3Scale(row[0], 1.0);\n\n    // Compute XY shear factor and make 2nd row orthogonal to 1st.\n    result.skewXY = v3Dot(row[0], row[1]);\n    v3Combine(row[1], row[0], row[1], 1.0, -result.skewXY);\n\n    // Now, compute Y scale and normalize 2nd row.\n    result.scaleY = v3Length(row[1]);\n    v3Scale(row[1], 1.0);\n    result.skewXY /= result.scaleY;\n\n    // Compute XZ and YZ shears, orthogonalize 3rd row.\n    result.skewXZ = v3Dot(row[0], row[2]);\n    v3Combine(row[2], row[0], row[2], 1.0, -result.skewXZ);\n    result.skewYZ = v3Dot(row[1], row[2]);\n    v3Combine(row[2], row[1], row[2], 1.0, -result.skewYZ);\n\n    // Next, get Z scale and normalize 3rd row.\n    result.scaleZ = v3Length(row[2]);\n    v3Scale(row[2], 1.0);\n    result.skewXZ /= result.scaleZ;\n    result.skewYZ /= result.scaleZ;\n\n    // At this point, the matrix (in rows[]) is orthonormal.\n    // Check for a coordinate system flip.  If the determinant\n    // is -1, then negate the matrix and the scaling factors.\n    v3Cross(row[1], row[2], pdum3);\n    if (v3Dot(row[0], pdum3) < 0) {\n\n        result.scaleX *= -1;\n        result.scaleY *= -1;\n        result.scaleZ *= -1;\n\n        for (i = 0; i < 3; i++) {\n            row[i][0] *= -1;\n            row[i][1] *= -1;\n            row[i][2] *= -1;\n        }\n    }\n\n    // Now, get the rotations out, as described in the gem.\n\n    // FIXME - Add the ability to return either quaternions (which are\n    // easier to recompose with) or Euler angles (rx, ry, rz), which\n    // are easier for authors to deal with. The latter will only be useful\n    // when we fix https://bugs.webkit.org/show_bug.cgi?id=23799, so I\n    // will leave the Euler angle code here for now.\n\n    // ret.rotateY = asin(-row[0][2]);\n    // if (cos(ret.rotateY) != 0) {\n    //     ret.rotateX = atan2(row[1][2], row[2][2]);\n    //     ret.rotateZ = atan2(row[0][1], row[0][0]);\n    // } else {\n    //     ret.rotateX = atan2(-row[2][0], row[1][1]);\n    //     ret.rotateZ = 0;\n    // }\n\n    double s, t, x, y, z, w;\n\n    t = row[0][0] + row[1][1] + row[2][2] + 1.0;\n\n    if (t > 1e-4) {\n        s = 0.5 / std::sqrt(t);\n        w = 0.25 / s;\n        x = (row[2][1] - row[1][2]) * s;\n        y = (row[0][2] - row[2][0]) * s;\n        z = (row[1][0] - row[0][1]) * s;\n    } else if (row[0][0] > row[1][1] && row[0][0] > row[2][2]) {\n        s = std::sqrt(1.0 + row[0][0] - row[1][1] - row[2][2]) * 2.0; // S=4*qx\n        x = 0.25 * s;\n        y = (row[0][1] + row[1][0]) / s;\n        z = (row[0][2] + row[2][0]) / s;\n        w = (row[2][1] - row[1][2]) / s;\n    } else if (row[1][1] > row[2][2]) {\n        s = std::sqrt(1.0 + row[1][1] - row[0][0] - row[2][2]) * 2.0; // S=4*qy\n        x = (row[0][1] + row[1][0]) / s;\n        y = 0.25 * s;\n        z = (row[1][2] + row[2][1]) / s;\n        w = (row[0][2] - row[2][0]) / s;\n    } else {\n        s = std::sqrt(1.0 + row[2][2] - row[0][0] - row[1][1]) * 2.0; // S=4*qz\n        x = (row[0][2] + row[2][0]) / s;\n        y = (row[1][2] + row[2][1]) / s;\n        z = 0.25 * s;\n        w = (row[1][0] - row[0][1]) / s;\n    }\n\n    result.quaternionX = x;\n    result.quaternionY = y;\n    result.quaternionZ = z;\n    result.quaternionW = w;\n\n    return true;\n}",
        "func": "static bool decompose(const TransformationMatrix::Matrix4& mat, TransformationMatrix::DecomposedType& result)\n{\n    TransformationMatrix::Matrix4 localMatrix;\n    memcpy(localMatrix, mat, sizeof(TransformationMatrix::Matrix4));\n\n    // Normalize the matrix.\n    if (localMatrix[3][3] == 0)\n        return false;\n\n    int i, j;\n    for (i = 0; i < 4; i++)\n        for (j = 0; j < 4; j++)\n            localMatrix[i][j] /= localMatrix[3][3];\n\n    // perspectiveMatrix is used to solve for perspective, but it also provides\n    // an easy way to test for singularity of the upper 3x3 component.\n    TransformationMatrix::Matrix4 perspectiveMatrix;\n    memcpy(perspectiveMatrix, localMatrix, sizeof(TransformationMatrix::Matrix4));\n    for (i = 0; i < 3; i++)\n        perspectiveMatrix[i][3] = 0;\n    perspectiveMatrix[3][3] = 1;\n\n    if (determinant4x4(perspectiveMatrix) == 0)\n        return false;\n\n    // First, isolate perspective.  This is the messiest.\n    if (localMatrix[0][3] != 0 || localMatrix[1][3] != 0 || localMatrix[2][3] != 0) {\n        // rightHandSide is the right hand side of the equation.\n        Vector4 rightHandSide;\n        rightHandSide[0] = localMatrix[0][3];\n        rightHandSide[1] = localMatrix[1][3];\n        rightHandSide[2] = localMatrix[2][3];\n        rightHandSide[3] = localMatrix[3][3];\n\n        // Solve the equation by inverting perspectiveMatrix and multiplying\n        // rightHandSide by the inverse.  (This is the easiest way, not\n        // necessarily the best.)\n        TransformationMatrix::Matrix4 inversePerspectiveMatrix, transposedInversePerspectiveMatrix;\n        if (!inverse(perspectiveMatrix, inversePerspectiveMatrix))\n            return false;\n        transposeMatrix4(inversePerspectiveMatrix, transposedInversePerspectiveMatrix);\n\n        Vector4 perspectivePoint;\n        v4MulPointByMatrix(rightHandSide, transposedInversePerspectiveMatrix, perspectivePoint);\n\n        result.perspectiveX = perspectivePoint[0];\n        result.perspectiveY = perspectivePoint[1];\n        result.perspectiveZ = perspectivePoint[2];\n        result.perspectiveW = perspectivePoint[3];\n\n        // Clear the perspective partition\n        localMatrix[0][3] = localMatrix[1][3] = localMatrix[2][3] = 0;\n        localMatrix[3][3] = 1;\n    } else {\n        // No perspective.\n        result.perspectiveX = result.perspectiveY = result.perspectiveZ = 0;\n        result.perspectiveW = 1;\n    }\n\n    // Next take care of translation (easy).\n    result.translateX = localMatrix[3][0];\n    localMatrix[3][0] = 0;\n    result.translateY = localMatrix[3][1];\n    localMatrix[3][1] = 0;\n    result.translateZ = localMatrix[3][2];\n    localMatrix[3][2] = 0;\n\n    // Vector4 type and functions need to be added to the common set.\n    Vector3 row[3], pdum3;\n\n    // Now get scale and shear.\n    for (i = 0; i < 3; i++) {\n        row[i][0] = localMatrix[i][0];\n        row[i][1] = localMatrix[i][1];\n        row[i][2] = localMatrix[i][2];\n    }\n\n    // Compute X scale factor and normalize first row.\n    result.scaleX = v3Length(row[0]);\n    v3Scale(row[0], 1.0);\n\n    // Compute XY shear factor and make 2nd row orthogonal to 1st.\n    result.skewXY = v3Dot(row[0], row[1]);\n    v3Combine(row[1], row[0], row[1], 1.0, -result.skewXY);\n\n    // Now, compute Y scale and normalize 2nd row.\n    result.scaleY = v3Length(row[1]);\n    v3Scale(row[1], 1.0);\n    result.skewXY /= result.scaleY;\n\n    // Compute XZ and YZ shears, orthogonalize 3rd row.\n    result.skewXZ = v3Dot(row[0], row[2]);\n    v3Combine(row[2], row[0], row[2], 1.0, -result.skewXZ);\n    result.skewYZ = v3Dot(row[1], row[2]);\n    v3Combine(row[2], row[1], row[2], 1.0, -result.skewYZ);\n\n    // Next, get Z scale and normalize 3rd row.\n    result.scaleZ = v3Length(row[2]);\n    v3Scale(row[2], 1.0);\n    result.skewXZ /= result.scaleZ;\n    result.skewYZ /= result.scaleZ;\n\n    // At this point, the matrix (in rows[]) is orthonormal.\n    // Check for a coordinate system flip.  If the determinant\n    // is -1, then negate the matrix and the scaling factors.\n    v3Cross(row[1], row[2], pdum3);\n    if (v3Dot(row[0], pdum3) < 0) {\n\n        result.scaleX *= -1;\n        result.scaleY *= -1;\n        result.scaleZ *= -1;\n\n        for (i = 0; i < 3; i++) {\n            row[i][0] *= -1;\n            row[i][1] *= -1;\n            row[i][2] *= -1;\n        }\n    }\n\n    // Now, get the rotations out, as described in the gem.\n\n    // FIXME - Add the ability to return either quaternions (which are\n    // easier to recompose with) or Euler angles (rx, ry, rz), which\n    // are easier for authors to deal with. The latter will only be useful\n    // when we fix https://bugs.webkit.org/show_bug.cgi?id=23799, so I\n    // will leave the Euler angle code here for now.\n\n    // ret.rotateY = asin(-row[0][2]);\n    // if (cos(ret.rotateY) != 0) {\n    //     ret.rotateX = atan2(row[1][2], row[2][2]);\n    //     ret.rotateZ = atan2(row[0][1], row[0][0]);\n    // } else {\n    //     ret.rotateX = atan2(-row[2][0], row[1][1]);\n    //     ret.rotateZ = 0;\n    // }\n\n    double s, t, x, y, z, w;\n\n    t = row[0][0] + row[1][1] + row[2][2] + 1.0;\n\n    if (t > 1e-4) {\n        s = 0.5 / std::sqrt(t);\n        w = 0.25 / s;\n        x = (row[2][1] - row[1][2]) * s;\n        y = (row[0][2] - row[2][0]) * s;\n        z = (row[1][0] - row[0][1]) * s;\n    } else if (row[0][0] > row[1][1] && row[0][0] > row[2][2]) {\n        s = std::sqrt(1.0 + row[0][0] - row[1][1] - row[2][2]) * 2.0; // S=4*qx\n        x = 0.25 * s;\n        y = (row[0][1] + row[1][0]) / s;\n        z = (row[0][2] + row[2][0]) / s;\n        w = (row[2][1] - row[1][2]) / s;\n    } else if (row[1][1] > row[2][2]) {\n        s = std::sqrt(1.0 + row[1][1] - row[0][0] - row[2][2]) * 2.0; // S=4*qy\n        x = (row[0][1] + row[1][0]) / s;\n        y = 0.25 * s;\n        z = (row[1][2] + row[2][1]) / s;\n        w = (row[0][2] - row[2][0]) / s;\n    } else {\n        s = std::sqrt(1.0 + row[2][2] - row[0][0] - row[1][1]) * 2.0; // S=4*qz\n        x = (row[0][2] + row[2][0]) / s;\n        y = (row[1][2] + row[2][1]) / s;\n        z = 0.25 * s;\n        w = (row[1][0] - row[0][1]) / s;\n    }\n\n    result.quaternionX = x;\n    result.quaternionY = y;\n    result.quaternionZ = z;\n    result.quaternionW = w;\n\n    return true;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -36,7 +36,8 @@\n         // rightHandSide by the inverse.  (This is the easiest way, not\n         // necessarily the best.)\n         TransformationMatrix::Matrix4 inversePerspectiveMatrix, transposedInversePerspectiveMatrix;\n-        inverse(perspectiveMatrix, inversePerspectiveMatrix);\n+        if (!inverse(perspectiveMatrix, inversePerspectiveMatrix))\n+            return false;\n         transposeMatrix4(inversePerspectiveMatrix, transposedInversePerspectiveMatrix);\n \n         Vector4 perspectivePoint;",
        "diff_line_info": {
            "deleted_lines": [
                "        inverse(perspectiveMatrix, inversePerspectiveMatrix);"
            ],
            "added_lines": [
                "        if (!inverse(perspectiveMatrix, inversePerspectiveMatrix))",
                "            return false;"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-6583",
        "func_name": "chromium/Browser::SupportsLocationBar",
        "description": "Google Chrome before 45.0.2454.85 does not display a location bar for a hosted app's window after navigation away from the installation site, which might make it easier for remote attackers to spoof content via a crafted app, related to browser.cc and hosted_app_browser_controller.cc.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/11bd6ed1f622cd9421ed4cdb53454e08d689e342",
        "commit_title": "Show origin for hosted apps that navigate away from their start origin.",
        "commit_text": " This is only for hosted apps that run in their own window.    ",
        "func_before": "bool Browser::SupportsLocationBar() const {\n  // Tabbed browser always show a location bar.\n  if (is_type_tabbed())\n    return true;\n\n  // Non-app windows that aren't tabbed or system windows should always show a\n  // location bar, unless they are from a trusted source.\n  if (!is_app())\n    return !is_trusted_source();\n\n  if (bookmark_app_controller_)\n    return bookmark_app_controller_->SupportsLocationBar();\n\n  return false;\n}",
        "func": "bool Browser::SupportsLocationBar() const {\n  // Tabbed browser always show a location bar.\n  if (is_type_tabbed())\n    return true;\n\n  // Non-app windows that aren't tabbed or system windows should always show a\n  // location bar, unless they are from a trusted source.\n  if (!is_app())\n    return !is_trusted_source();\n\n  if (hosted_app_controller_)\n    return hosted_app_controller_->SupportsLocationBar();\n\n  return false;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -8,8 +8,8 @@\n   if (!is_app())\n     return !is_trusted_source();\n \n-  if (bookmark_app_controller_)\n-    return bookmark_app_controller_->SupportsLocationBar();\n+  if (hosted_app_controller_)\n+    return hosted_app_controller_->SupportsLocationBar();\n \n   return false;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "  if (bookmark_app_controller_)",
                "    return bookmark_app_controller_->SupportsLocationBar();"
            ],
            "added_lines": [
                "  if (hosted_app_controller_)",
                "    return hosted_app_controller_->SupportsLocationBar();"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-6583",
        "func_name": "chromium/Browser::ShouldUseWebAppFrame",
        "description": "Google Chrome before 45.0.2454.85 does not display a location bar for a hosted app's window after navigation away from the installation site, which might make it easier for remote attackers to spoof content via a crafted app, related to browser.cc and hosted_app_browser_controller.cc.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/11bd6ed1f622cd9421ed4cdb53454e08d689e342",
        "commit_title": "Show origin for hosted apps that navigate away from their start origin.",
        "commit_text": " This is only for hosted apps that run in their own window.    ",
        "func_before": "bool Browser::ShouldUseWebAppFrame() const {\n  // Only use the web app frame for apps in ash, and only if the web app frame\n  // is enabled.\n  if (!is_app())\n    return false;\n\n  if (bookmark_app_controller_)\n    return bookmark_app_controller_->should_use_web_app_frame();\n\n  return false;\n}",
        "func": "bool Browser::ShouldUseWebAppFrame() const {\n  // Only use the web app frame for apps in ash, and only if the web app frame\n  // is enabled.\n  if (!is_app())\n    return false;\n\n  if (hosted_app_controller_)\n    return hosted_app_controller_->should_use_web_app_frame();\n\n  return false;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,8 +4,8 @@\n   if (!is_app())\n     return false;\n \n-  if (bookmark_app_controller_)\n-    return bookmark_app_controller_->should_use_web_app_frame();\n+  if (hosted_app_controller_)\n+    return hosted_app_controller_->should_use_web_app_frame();\n \n   return false;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "  if (bookmark_app_controller_)",
                "    return bookmark_app_controller_->should_use_web_app_frame();"
            ],
            "added_lines": [
                "  if (hosted_app_controller_)",
                "    return hosted_app_controller_->should_use_web_app_frame();"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-6583",
        "func_name": "chromium/Browser::NavigationStateChanged",
        "description": "Google Chrome before 45.0.2454.85 does not display a location bar for a hosted app's window after navigation away from the installation site, which might make it easier for remote attackers to spoof content via a crafted app, related to browser.cc and hosted_app_browser_controller.cc.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/11bd6ed1f622cd9421ed4cdb53454e08d689e342",
        "commit_title": "Show origin for hosted apps that navigate away from their start origin.",
        "commit_text": " This is only for hosted apps that run in their own window.    ",
        "func_before": "void Browser::NavigationStateChanged(WebContents* source,\n                                     content::InvalidateTypes changed_flags) {\n  // TODO(erikchen): Remove ScopedTracker below once http://crbug.com/466285\n  // is fixed.\n  tracked_objects::ScopedTracker tracking_profile1(\n      FROM_HERE_WITH_EXPLICIT_FUNCTION(\n          \"466285 Browser::NavigationStateChanged::ScheduleUIUpdate\"));\n  // Only update the UI when something visible has changed.\n  if (changed_flags)\n    ScheduleUIUpdate(source, changed_flags);\n\n  // TODO(erikchen): Remove ScopedTracker below once http://crbug.com/466285\n  // is fixed.\n  tracked_objects::ScopedTracker tracking_profile2(\n      FROM_HERE_WITH_EXPLICIT_FUNCTION(\n          \"466285 Browser::NavigationStateChanged::TabStateChanged\"));\n  // We can synchronously update commands since they will only change once per\n  // navigation, so we don't have to worry about flickering. We do, however,\n  // need to update the command state early on load to always present usable\n  // actions in the face of slow-to-commit pages.\n  if (changed_flags & (content::INVALIDATE_TYPE_URL |\n                       content::INVALIDATE_TYPE_LOAD))\n    command_controller_->TabStateChanged();\n\n  if (bookmark_app_controller_)\n    bookmark_app_controller_->UpdateLocationBarVisibility(true);\n}",
        "func": "void Browser::NavigationStateChanged(WebContents* source,\n                                     content::InvalidateTypes changed_flags) {\n  // TODO(erikchen): Remove ScopedTracker below once http://crbug.com/466285\n  // is fixed.\n  tracked_objects::ScopedTracker tracking_profile1(\n      FROM_HERE_WITH_EXPLICIT_FUNCTION(\n          \"466285 Browser::NavigationStateChanged::ScheduleUIUpdate\"));\n  // Only update the UI when something visible has changed.\n  if (changed_flags)\n    ScheduleUIUpdate(source, changed_flags);\n\n  // TODO(erikchen): Remove ScopedTracker below once http://crbug.com/466285\n  // is fixed.\n  tracked_objects::ScopedTracker tracking_profile2(\n      FROM_HERE_WITH_EXPLICIT_FUNCTION(\n          \"466285 Browser::NavigationStateChanged::TabStateChanged\"));\n  // We can synchronously update commands since they will only change once per\n  // navigation, so we don't have to worry about flickering. We do, however,\n  // need to update the command state early on load to always present usable\n  // actions in the face of slow-to-commit pages.\n  if (changed_flags & (content::INVALIDATE_TYPE_URL |\n                       content::INVALIDATE_TYPE_LOAD))\n    command_controller_->TabStateChanged();\n\n  if (hosted_app_controller_)\n    hosted_app_controller_->UpdateLocationBarVisibility(true);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -22,6 +22,6 @@\n                        content::INVALIDATE_TYPE_LOAD))\n     command_controller_->TabStateChanged();\n \n-  if (bookmark_app_controller_)\n-    bookmark_app_controller_->UpdateLocationBarVisibility(true);\n+  if (hosted_app_controller_)\n+    hosted_app_controller_->UpdateLocationBarVisibility(true);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "  if (bookmark_app_controller_)",
                "    bookmark_app_controller_->UpdateLocationBarVisibility(true);"
            ],
            "added_lines": [
                "  if (hosted_app_controller_)",
                "    hosted_app_controller_->UpdateLocationBarVisibility(true);"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-6583",
        "func_name": "chromium/Browser::Browser",
        "description": "Google Chrome before 45.0.2454.85 does not display a location bar for a hosted app's window after navigation away from the installation site, which might make it easier for remote attackers to spoof content via a crafted app, related to browser.cc and hosted_app_browser_controller.cc.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/11bd6ed1f622cd9421ed4cdb53454e08d689e342",
        "commit_title": "Show origin for hosted apps that navigate away from their start origin.",
        "commit_text": " This is only for hosted apps that run in their own window.    ",
        "func_before": "Browser::Browser(const CreateParams& params)\n    : extension_registry_observer_(this),\n      type_(params.type),\n      profile_(params.profile),\n      window_(NULL),\n      tab_strip_model_delegate_(new chrome::BrowserTabStripModelDelegate(this)),\n      tab_strip_model_(\n          new TabStripModel(tab_strip_model_delegate_.get(), params.profile)),\n      app_name_(params.app_name),\n      is_trusted_source_(params.trusted_source),\n      cancel_download_confirmation_state_(NOT_PROMPTED),\n      override_bounds_(params.initial_bounds),\n      initial_show_state_(params.initial_show_state),\n      is_session_restore_(params.is_session_restore),\n      host_desktop_type_(\n          BrowserWindow::AdjustHostDesktopType(params.host_desktop_type)),\n      content_setting_bubble_model_delegate_(\n          new BrowserContentSettingBubbleModelDelegate(this)),\n      toolbar_model_delegate_(new BrowserToolbarModelDelegate(this)),\n      tab_restore_service_delegate_(new BrowserTabRestoreServiceDelegate(this)),\n      synced_window_delegate_(new BrowserSyncedWindowDelegate(this)),\n      bookmark_bar_state_(BookmarkBar::HIDDEN),\n      command_controller_(new chrome::BrowserCommandController(this)),\n      window_has_shown_(false),\n      chrome_updater_factory_(this),\n      weak_factory_(this) {\n  // If this causes a crash then a window is being opened using a profile type\n  // that is disallowed by policy. The crash prevents the disabled window type\n  // from opening at all, but the path that triggered it should be fixed.\n  CHECK(IncognitoModePrefs::CanOpenBrowser(profile_));\n  CHECK(!profile_->IsGuestSession() || profile_->IsOffTheRecord())\n      << \"Only off the record browser may be opened in guest mode\";\n  DCHECK(!profile_->IsSystemProfile())\n      << \"The system profile should never have a real browser.\";\n  // TODO(mlerman): After this hits stable channel, see if there are counts\n  // for this metric. If not, change the DCHECK above to a CHECK.\n  if (profile_->IsSystemProfile())\n    content::RecordAction(base::UserMetricsAction(\"BrowserForSystemProfile\"));\n\n  // TODO(jeremy): Move to initializer list once flag is removed.\n  if (IsFastTabUnloadEnabled())\n    fast_unload_controller_.reset(new chrome::FastUnloadController(this));\n  else\n    unload_controller_.reset(new chrome::UnloadController(this));\n\n  tab_strip_model_->AddObserver(this);\n\n  toolbar_model_.reset(new ToolbarModelImpl(toolbar_model_delegate_.get()));\n  search_model_.reset(new SearchModel());\n  search_delegate_.reset(new SearchDelegate(search_model_.get()));\n\n  extension_registry_observer_.Add(\n      extensions::ExtensionRegistry::Get(profile_));\n  registrar_.Add(this,\n                 extensions::NOTIFICATION_EXTENSION_PROCESS_TERMINATED,\n                 content::NotificationService::AllSources());\n#if defined(ENABLE_THEMES)\n  registrar_.Add(\n      this, chrome::NOTIFICATION_BROWSER_THEME_CHANGED,\n      content::Source<ThemeService>(\n          ThemeServiceFactory::GetForProfile(profile_)));\n#endif\n  registrar_.Add(this, chrome::NOTIFICATION_WEB_CONTENT_SETTINGS_CHANGED,\n                 content::NotificationService::AllSources());\n\n  profile_pref_registrar_.Init(profile_->GetPrefs());\n  profile_pref_registrar_.Add(\n      prefs::kDevToolsDisabled,\n      base::Bind(&Browser::OnDevToolsDisabledChanged, base::Unretained(this)));\n  profile_pref_registrar_.Add(\n      bookmarks::prefs::kShowBookmarkBar,\n      base::Bind(&Browser::UpdateBookmarkBarState, base::Unretained(this),\n                 BOOKMARK_BAR_STATE_CHANGE_PREF_CHANGE));\n\n  BrowserList::AddBrowser(this);\n\n  // NOTE: These prefs all need to be explicitly destroyed in the destructor\n  // or you'll get a nasty surprise when you run the incognito tests.\n  encoding_auto_detect_.Init(prefs::kWebKitUsesUniversalDetector,\n                             profile_->GetPrefs());\n\n  if (chrome::IsInstantExtendedAPIEnabled() && is_type_tabbed())\n    instant_controller_.reset(new BrowserInstantController(this));\n\n  if (extensions::BookmarkAppBrowserController::IsForBookmarkApp(this)) {\n    bookmark_app_controller_.reset(\n        new extensions::BookmarkAppBrowserController(this));\n  }\n\n  UpdateBookmarkBarState(BOOKMARK_BAR_STATE_CHANGE_INIT);\n\n  ProfileMetrics::LogProfileLaunch(profile_);\n\n  window_ = params.window ? params.window : CreateBrowserWindow(this);\n\n  if (bookmark_app_controller_)\n    bookmark_app_controller_->UpdateLocationBarVisibility(false);\n\n  // Create the extension window controller before sending notifications.\n  extension_window_controller_.reset(\n      new BrowserExtensionWindowController(this));\n\n  SessionService* session_service =\n      SessionServiceFactory::GetForProfileForSessionRestore(profile_);\n  if (session_service)\n    session_service->WindowOpened(this);\n\n  // TODO(beng): Move BrowserList::AddBrowser() to the end of this function and\n  //             replace uses of this with BL's notifications.\n  content::NotificationService::current()->Notify(\n      chrome::NOTIFICATION_BROWSER_WINDOW_READY,\n      content::Source<Browser>(this),\n      content::NotificationService::NoDetails());\n\n  // TODO(beng): move to ChromeBrowserMain:\n  if (first_run::ShouldDoPersonalDataManagerFirstRun()) {\n#if defined(OS_WIN)\n    // Notify PDM that this is a first run.\n    ImportAutofillDataWin(\n        autofill::PersonalDataManagerFactory::GetForProfile(profile_));\n#endif  // defined(OS_WIN)\n  }\n\n  exclusive_access_manager_.reset(\n      new ExclusiveAccessManager(window_->GetExclusiveAccessContext()));\n\n  // Must be initialized after window_.\n  // Also: surprise! a modal dialog host is not necessary to host modal dialogs\n  // without a modal dialog host, so that value may be null.\n  popup_manager_.reset(new web_modal::PopupManager(\n      GetWebContentsModalDialogHost()));\n}",
        "func": "Browser::Browser(const CreateParams& params)\n    : extension_registry_observer_(this),\n      type_(params.type),\n      profile_(params.profile),\n      window_(NULL),\n      tab_strip_model_delegate_(new chrome::BrowserTabStripModelDelegate(this)),\n      tab_strip_model_(\n          new TabStripModel(tab_strip_model_delegate_.get(), params.profile)),\n      app_name_(params.app_name),\n      is_trusted_source_(params.trusted_source),\n      cancel_download_confirmation_state_(NOT_PROMPTED),\n      override_bounds_(params.initial_bounds),\n      initial_show_state_(params.initial_show_state),\n      is_session_restore_(params.is_session_restore),\n      host_desktop_type_(\n          BrowserWindow::AdjustHostDesktopType(params.host_desktop_type)),\n      content_setting_bubble_model_delegate_(\n          new BrowserContentSettingBubbleModelDelegate(this)),\n      toolbar_model_delegate_(new BrowserToolbarModelDelegate(this)),\n      tab_restore_service_delegate_(new BrowserTabRestoreServiceDelegate(this)),\n      synced_window_delegate_(new BrowserSyncedWindowDelegate(this)),\n      bookmark_bar_state_(BookmarkBar::HIDDEN),\n      command_controller_(new chrome::BrowserCommandController(this)),\n      window_has_shown_(false),\n      chrome_updater_factory_(this),\n      weak_factory_(this) {\n  // If this causes a crash then a window is being opened using a profile type\n  // that is disallowed by policy. The crash prevents the disabled window type\n  // from opening at all, but the path that triggered it should be fixed.\n  CHECK(IncognitoModePrefs::CanOpenBrowser(profile_));\n  CHECK(!profile_->IsGuestSession() || profile_->IsOffTheRecord())\n      << \"Only off the record browser may be opened in guest mode\";\n  DCHECK(!profile_->IsSystemProfile())\n      << \"The system profile should never have a real browser.\";\n  // TODO(mlerman): After this hits stable channel, see if there are counts\n  // for this metric. If not, change the DCHECK above to a CHECK.\n  if (profile_->IsSystemProfile())\n    content::RecordAction(base::UserMetricsAction(\"BrowserForSystemProfile\"));\n\n  // TODO(jeremy): Move to initializer list once flag is removed.\n  if (IsFastTabUnloadEnabled())\n    fast_unload_controller_.reset(new chrome::FastUnloadController(this));\n  else\n    unload_controller_.reset(new chrome::UnloadController(this));\n\n  tab_strip_model_->AddObserver(this);\n\n  toolbar_model_.reset(new ToolbarModelImpl(toolbar_model_delegate_.get()));\n  search_model_.reset(new SearchModel());\n  search_delegate_.reset(new SearchDelegate(search_model_.get()));\n\n  extension_registry_observer_.Add(\n      extensions::ExtensionRegistry::Get(profile_));\n  registrar_.Add(this,\n                 extensions::NOTIFICATION_EXTENSION_PROCESS_TERMINATED,\n                 content::NotificationService::AllSources());\n#if defined(ENABLE_THEMES)\n  registrar_.Add(\n      this, chrome::NOTIFICATION_BROWSER_THEME_CHANGED,\n      content::Source<ThemeService>(\n          ThemeServiceFactory::GetForProfile(profile_)));\n#endif\n  registrar_.Add(this, chrome::NOTIFICATION_WEB_CONTENT_SETTINGS_CHANGED,\n                 content::NotificationService::AllSources());\n\n  profile_pref_registrar_.Init(profile_->GetPrefs());\n  profile_pref_registrar_.Add(\n      prefs::kDevToolsDisabled,\n      base::Bind(&Browser::OnDevToolsDisabledChanged, base::Unretained(this)));\n  profile_pref_registrar_.Add(\n      bookmarks::prefs::kShowBookmarkBar,\n      base::Bind(&Browser::UpdateBookmarkBarState, base::Unretained(this),\n                 BOOKMARK_BAR_STATE_CHANGE_PREF_CHANGE));\n\n  BrowserList::AddBrowser(this);\n\n  // NOTE: These prefs all need to be explicitly destroyed in the destructor\n  // or you'll get a nasty surprise when you run the incognito tests.\n  encoding_auto_detect_.Init(prefs::kWebKitUsesUniversalDetector,\n                             profile_->GetPrefs());\n\n  if (chrome::IsInstantExtendedAPIEnabled() && is_type_tabbed())\n    instant_controller_.reset(new BrowserInstantController(this));\n\n  if (extensions::HostedAppBrowserController::IsForHostedApp(this)) {\n    hosted_app_controller_.reset(\n        new extensions::HostedAppBrowserController(this));\n  }\n\n  UpdateBookmarkBarState(BOOKMARK_BAR_STATE_CHANGE_INIT);\n\n  ProfileMetrics::LogProfileLaunch(profile_);\n\n  window_ = params.window ? params.window : CreateBrowserWindow(this);\n\n  if (hosted_app_controller_)\n    hosted_app_controller_->UpdateLocationBarVisibility(false);\n\n  // Create the extension window controller before sending notifications.\n  extension_window_controller_.reset(\n      new BrowserExtensionWindowController(this));\n\n  SessionService* session_service =\n      SessionServiceFactory::GetForProfileForSessionRestore(profile_);\n  if (session_service)\n    session_service->WindowOpened(this);\n\n  // TODO(beng): Move BrowserList::AddBrowser() to the end of this function and\n  //             replace uses of this with BL's notifications.\n  content::NotificationService::current()->Notify(\n      chrome::NOTIFICATION_BROWSER_WINDOW_READY,\n      content::Source<Browser>(this),\n      content::NotificationService::NoDetails());\n\n  // TODO(beng): move to ChromeBrowserMain:\n  if (first_run::ShouldDoPersonalDataManagerFirstRun()) {\n#if defined(OS_WIN)\n    // Notify PDM that this is a first run.\n    ImportAutofillDataWin(\n        autofill::PersonalDataManagerFactory::GetForProfile(profile_));\n#endif  // defined(OS_WIN)\n  }\n\n  exclusive_access_manager_.reset(\n      new ExclusiveAccessManager(window_->GetExclusiveAccessContext()));\n\n  // Must be initialized after window_.\n  // Also: surprise! a modal dialog host is not necessary to host modal dialogs\n  // without a modal dialog host, so that value may be null.\n  popup_manager_.reset(new web_modal::PopupManager(\n      GetWebContentsModalDialogHost()));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -82,9 +82,9 @@\n   if (chrome::IsInstantExtendedAPIEnabled() && is_type_tabbed())\n     instant_controller_.reset(new BrowserInstantController(this));\n \n-  if (extensions::BookmarkAppBrowserController::IsForBookmarkApp(this)) {\n-    bookmark_app_controller_.reset(\n-        new extensions::BookmarkAppBrowserController(this));\n+  if (extensions::HostedAppBrowserController::IsForHostedApp(this)) {\n+    hosted_app_controller_.reset(\n+        new extensions::HostedAppBrowserController(this));\n   }\n \n   UpdateBookmarkBarState(BOOKMARK_BAR_STATE_CHANGE_INIT);\n@@ -93,8 +93,8 @@\n \n   window_ = params.window ? params.window : CreateBrowserWindow(this);\n \n-  if (bookmark_app_controller_)\n-    bookmark_app_controller_->UpdateLocationBarVisibility(false);\n+  if (hosted_app_controller_)\n+    hosted_app_controller_->UpdateLocationBarVisibility(false);\n \n   // Create the extension window controller before sending notifications.\n   extension_window_controller_.reset(",
        "diff_line_info": {
            "deleted_lines": [
                "  if (extensions::BookmarkAppBrowserController::IsForBookmarkApp(this)) {",
                "    bookmark_app_controller_.reset(",
                "        new extensions::BookmarkAppBrowserController(this));",
                "  if (bookmark_app_controller_)",
                "    bookmark_app_controller_->UpdateLocationBarVisibility(false);"
            ],
            "added_lines": [
                "  if (extensions::HostedAppBrowserController::IsForHostedApp(this)) {",
                "    hosted_app_controller_.reset(",
                "        new extensions::HostedAppBrowserController(this));",
                "  if (hosted_app_controller_)",
                "    hosted_app_controller_->UpdateLocationBarVisibility(false);"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-6762",
        "func_name": "chromium/CSSFontFaceSrcValue::fetch",
        "description": "The CSSFontFaceSrcValue::fetch function in core/css/CSSFontFaceSrcValue.cpp in the Cascading Style Sheets (CSS) implementation in Blink, as used in Google Chrome before 46.0.2490.71, does not use the CORS cross-origin request algorithm when a font's URL appears to be a same-origin URL, which allows remote web servers to bypass the Same Origin Policy via a redirect.",
        "git_url": "https://github.com/chromium/chromium/commit/212b92858f0ae007c90abd10b40ba805a13af43c",
        "commit_title": "Webfont fetch should be CORS-enabled even for same-origin URL",
        "commit_text": " Before this patch, webfont request was made with no-cors mode when the URL of font face was same-origin. However, that same-origin request may be redirected to another origin.  This patch makes webfont requests use cors mode for (initially) same-origin requests too, in order to let ResourceFetcher handle same/cross origin stuff. (This matches how <img crossorigin> works.)   ",
        "func_before": "FontResource* CSSFontFaceSrcValue::fetch(Document* document)\n{\n    if (!m_fetched) {\n        FetchRequest request(ResourceRequest(document->completeURL(m_resource)), FetchInitiatorTypeNames::css);\n        request.setContentSecurityCheck(m_shouldCheckContentSecurityPolicy);\n        SecurityOrigin* securityOrigin = document->securityOrigin();\n        if (shouldSetCrossOriginAccessControl(request.url(), securityOrigin)) {\n            request.setCrossOriginAccessControl(securityOrigin, DoNotAllowStoredCredentials);\n        }\n        request.mutableResourceRequest().setHTTPReferrer(SecurityPolicy::generateReferrer(m_referrer.referrerPolicy, request.url(), m_referrer.referrer));\n        m_fetched = FontResource::fetch(request, document->fetcher());\n    } else {\n        // FIXME: CSSFontFaceSrcValue::fetch is invoked when @font-face rule\n        // is processed by StyleResolver / StyleEngine.\n        restoreCachedResourceIfNeeded(document);\n    }\n    return m_fetched.get();\n}",
        "func": "FontResource* CSSFontFaceSrcValue::fetch(Document* document)\n{\n    if (!m_fetched) {\n        FetchRequest request(ResourceRequest(document->completeURL(m_resource)), FetchInitiatorTypeNames::css);\n        request.setContentSecurityCheck(m_shouldCheckContentSecurityPolicy);\n        SecurityOrigin* securityOrigin = document->securityOrigin();\n        request.setCrossOriginAccessControl(securityOrigin, DoNotAllowStoredCredentials);\n        request.mutableResourceRequest().setHTTPReferrer(SecurityPolicy::generateReferrer(m_referrer.referrerPolicy, request.url(), m_referrer.referrer));\n        m_fetched = FontResource::fetch(request, document->fetcher());\n    } else {\n        // FIXME: CSSFontFaceSrcValue::fetch is invoked when @font-face rule\n        // is processed by StyleResolver / StyleEngine.\n        restoreCachedResourceIfNeeded(document);\n    }\n    return m_fetched.get();\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,9 +4,7 @@\n         FetchRequest request(ResourceRequest(document->completeURL(m_resource)), FetchInitiatorTypeNames::css);\n         request.setContentSecurityCheck(m_shouldCheckContentSecurityPolicy);\n         SecurityOrigin* securityOrigin = document->securityOrigin();\n-        if (shouldSetCrossOriginAccessControl(request.url(), securityOrigin)) {\n-            request.setCrossOriginAccessControl(securityOrigin, DoNotAllowStoredCredentials);\n-        }\n+        request.setCrossOriginAccessControl(securityOrigin, DoNotAllowStoredCredentials);\n         request.mutableResourceRequest().setHTTPReferrer(SecurityPolicy::generateReferrer(m_referrer.referrerPolicy, request.url(), m_referrer.referrer));\n         m_fetched = FontResource::fetch(request, document->fetcher());\n     } else {",
        "diff_line_info": {
            "deleted_lines": [
                "        if (shouldSetCrossOriginAccessControl(request.url(), securityOrigin)) {",
                "            request.setCrossOriginAccessControl(securityOrigin, DoNotAllowStoredCredentials);",
                "        }"
            ],
            "added_lines": [
                "        request.setCrossOriginAccessControl(securityOrigin, DoNotAllowStoredCredentials);"
            ]
        }
    }
]