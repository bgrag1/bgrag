[
    {
        "cve_id": "CVE-2018-17961",
        "func_name": "ArtifexSoftware/ghostpdl/gs_call_interp",
        "description": "Artifex Ghostscript 9.25 and earlier allows attackers to bypass a sandbox protection mechanism via vectors involving errorhandler setup. NOTE: this issue exists because of an incomplete fix for CVE-2018-17183.",
        "git_url": "https://github.com/ArtifexSoftware/ghostpdl/commit/a6807394bd94b708be24758287b606154daaaed9",
        "commit_title": "For hidden operators, pass a name object to error handler.",
        "commit_text": " In normal operation, Postscript error handlers are passed the object which triggered the error: this is invariably an operator object.  The issue arises when an error is triggered by an operator which is for internal use only, and that operator is then passed to the error handler, meaning it becomes visible to the error handler code.  By converting to a name object, the error message is still valid, but we no longer expose internal use only operators.  The change in gs_dps1.ps is related to the above: previously an error in scheck would throw an error against .gcheck, but as .gcheck is now a hidden operator, it resulted in a name object being passed to the error handler. As scheck is a 'real' operator, it's better to use the real operator, rather than the name of an internal, hidden one.",
        "func_before": "static int\ngs_call_interp(i_ctx_t **pi_ctx_p, ref * pref, int user_errors,\n               int *pexit_code, ref * perror_object)\n{\n    ref *epref = pref;\n    ref doref;\n    ref *perrordict;\n    ref error_name;\n    int code, ccode;\n    ref saref;\n    i_ctx_t *i_ctx_p = *pi_ctx_p;\n    int *gc_signal = &imemory_system->gs_lib_ctx->gcsignal;\n\n    *pexit_code = 0;\n    *gc_signal = 0;\n    ialloc_reset_requested(idmemory);\nagain:\n    /* Avoid a dangling error object that might get traced by a future GC. */\n    make_null(perror_object);\n    o_stack.requested = e_stack.requested = d_stack.requested = 0;\n    while (*gc_signal) { /* Some routine below triggered a GC. */\n        gs_gc_root_t epref_root;\n\n        *gc_signal = 0;\n        /* Make sure that doref will get relocated properly if */\n        /* a garbage collection happens with epref == &doref. */\n        gs_register_ref_root(imemory_system, &epref_root,\n                             (void **)&epref, \"gs_call_interp(epref)\");\n        code = interp_reclaim(pi_ctx_p, -1);\n        i_ctx_p = *pi_ctx_p;\n        gs_unregister_root(imemory_system, &epref_root,\n                           \"gs_call_interp(epref)\");\n        if (code < 0)\n            return code;\n    }\n    code = interp(pi_ctx_p, epref, perror_object);\n    i_ctx_p = *pi_ctx_p;\n    if (!r_has_type(&i_ctx_p->error_object, t__invalid)) {\n        *perror_object = i_ctx_p->error_object;\n        make_t(&i_ctx_p->error_object, t__invalid);\n    }\n    /* Prevent a dangling reference to the GC signal in ticks_left */\n    /* in the frame of interp, but be prepared to do a GC if */\n    /* an allocation in this routine asks for it. */\n    *gc_signal = 0;\n    set_gc_signal(i_ctx_p, 1);\n    if (esp < esbot)            /* popped guard entry */\n        esp = esbot;\n    switch (code) {\n        case gs_error_Fatal:\n            *pexit_code = 255;\n            return code;\n        case gs_error_Quit:\n            *perror_object = osp[-1];\n            *pexit_code = code = osp->value.intval;\n            osp -= 2;\n            return\n                (code == 0 ? gs_error_Quit :\n                 code < 0 && code > -100 ? code : gs_error_Fatal);\n        case gs_error_InterpreterExit:\n            return 0;\n        case gs_error_ExecStackUnderflow:\n/****** WRONG -- must keep mark blocks intact ******/\n            ref_stack_pop_block(&e_stack);\n            doref = *perror_object;\n            epref = &doref;\n            goto again;\n        case gs_error_VMreclaim:\n            /* Do the GC and continue. */\n            /* We ignore the return value here, if it fails here\n             * we'll call it again having jumped to the \"again\" label.\n             * Where, assuming it fails again, we'll handle the error.\n             */\n            (void)interp_reclaim(pi_ctx_p,\n                                  (osp->value.intval == 2 ?\n                                   avm_global : avm_local));\n            i_ctx_p = *pi_ctx_p;\n            make_oper(&doref, 0, zpop);\n            epref = &doref;\n            goto again;\n        case gs_error_NeedInput:\n        case gs_error_interrupt:\n            return code;\n    }\n    /* Adjust osp in case of operand stack underflow */\n    if (osp < osbot - 1)\n        osp = osbot - 1;\n    /* We have to handle stack over/underflow specially, because */\n    /* we might be able to recover by adding or removing a block. */\n    switch (code) {\n        case gs_error_dictstackoverflow:\n            /* We don't have to handle this specially: */\n            /* The only places that could generate it */\n            /* use check_dstack, which does a ref_stack_extend, */\n            /* so if` we get this error, it's a real one. */\n            if (osp >= ostop) {\n                if ((ccode = ref_stack_extend(&o_stack, 1)) < 0)\n                    return ccode;\n            }\n            /* Skip system dictionaries for CET 20-02-02 */\n            ccode = copy_stack(i_ctx_p, &d_stack, min_dstack_size, &saref);\n            if (ccode < 0)\n                return ccode;\n            ref_stack_pop_to(&d_stack, min_dstack_size);\n            dict_set_top();\n            *++osp = saref;\n            break;\n        case gs_error_dictstackunderflow:\n            if (ref_stack_pop_block(&d_stack) >= 0) {\n                dict_set_top();\n                doref = *perror_object;\n                epref = &doref;\n                goto again;\n            }\n            break;\n        case gs_error_execstackoverflow:\n            /* We don't have to handle this specially: */\n            /* The only places that could generate it */\n            /* use check_estack, which does a ref_stack_extend, */\n            /* so if we get this error, it's a real one. */\n            if (osp >= ostop) {\n                if ((ccode = ref_stack_extend(&o_stack, 1)) < 0)\n                    return ccode;\n            }\n            ccode = copy_stack(i_ctx_p, &e_stack, 0, &saref);\n            if (ccode < 0)\n                return ccode;\n            {\n                uint count = ref_stack_count(&e_stack);\n                uint limit = ref_stack_max_count(&e_stack) - ES_HEADROOM;\n\n                if (count > limit) {\n                    /*\n                     * If there is an e-stack mark within MIN_BLOCK_ESTACK of\n                     * the new top, cut the stack back to remove the mark.\n                     */\n                    int skip = count - limit;\n                    int i;\n\n                    for (i = skip; i < skip + MIN_BLOCK_ESTACK; ++i) {\n                        const ref *ep = ref_stack_index(&e_stack, i);\n\n                        if (r_has_type_attrs(ep, t_null, a_executable)) {\n                            skip = i + 1;\n                            break;\n                        }\n                    }\n                    pop_estack(i_ctx_p, skip);\n                }\n            }\n            *++osp = saref;\n            break;\n        case gs_error_stackoverflow:\n            if (ref_stack_extend(&o_stack, o_stack.requested) >= 0) {   /* We can't just re-execute the object, because */\n                /* it might be a procedure being pushed as a */\n                /* literal.  We check for this case specially. */\n                doref = *perror_object;\n                if (r_is_proc(&doref)) {\n                    *++osp = doref;\n                    make_null_proc(&doref);\n                }\n                epref = &doref;\n                goto again;\n            }\n            ccode = copy_stack(i_ctx_p, &o_stack, 0, &saref);\n            if (ccode < 0)\n                return ccode;\n            ref_stack_clear(&o_stack);\n            *++osp = saref;\n            break;\n        case gs_error_stackunderflow:\n            if (ref_stack_pop_block(&o_stack) >= 0) {\n                doref = *perror_object;\n                epref = &doref;\n                goto again;\n            }\n            break;\n    }\n    if (user_errors < 0)\n        return code;\n    if (gs_errorname(i_ctx_p, code, &error_name) < 0)\n        return code;            /* out-of-range error code! */\n\n    /*  We refer to gserrordict first, which is not accessible to Postcript jobs\n     *  If we're running with SAFERERRORS all the handlers are copied to gserrordict\n     *  so we'll always find the default one. If not SAFERERRORS, only gs specific\n     *  errors are in gserrordict.\n     */\n    if (dict_find_string(systemdict, \"gserrordict\", &perrordict) <= 0 ||\n        (dict_find(perrordict, &error_name, &epref) <= 0 &&\n         (dict_find_string(systemdict, \"errordict\", &perrordict) <= 0 ||\n          dict_find(perrordict, &error_name, &epref) <= 0))\n        )\n        return code;            /* error name not in errordict??? */\n\n    doref = *epref;\n    epref = &doref;\n    /* Push the error object on the operand stack if appropriate. */\n    if (!GS_ERROR_IS_INTERRUPT(code)) {\n        /* Replace the error object if within an oparray or .errorexec. */\n        osp++;\n        if (osp >= ostop) {\n            *pexit_code = gs_error_Fatal;\n            return_error(gs_error_Fatal);\n        }\n        *osp = *perror_object;\n        errorexec_find(i_ctx_p, osp);\n        /* If using SAFER, hand a name object to the error handler, rather than the executable\n         * object/operator itself.\n         */\n        if (i_ctx_p->LockFilePermissions) {\n            code = obj_cvs(imemory, osp, buf + 2, 256, &rlen, (const byte **)&bufptr);\n            if (code < 0) {\n                const char *unknownstr = \"--unknown--\";\n                rlen = strlen(unknownstr);\n                memcpy(buf, unknownstr, rlen);\n            }\n            else {\n                buf[0] = buf[1] = buf[rlen + 2] = buf[rlen + 3] = '-';\n                rlen += 4;\n            }\n            code = name_ref(imemory, buf, rlen, osp, 1);\n            if (code < 0)\n                make_null(osp);\n        }\n    }\n    goto again;\n}",
        "func": "static int\ngs_call_interp(i_ctx_t **pi_ctx_p, ref * pref, int user_errors,\n               int *pexit_code, ref * perror_object)\n{\n    ref *epref = pref;\n    ref doref;\n    ref *perrordict;\n    ref error_name;\n    int code, ccode;\n    ref saref;\n    i_ctx_t *i_ctx_p = *pi_ctx_p;\n    int *gc_signal = &imemory_system->gs_lib_ctx->gcsignal;\n\n    *pexit_code = 0;\n    *gc_signal = 0;\n    ialloc_reset_requested(idmemory);\nagain:\n    /* Avoid a dangling error object that might get traced by a future GC. */\n    make_null(perror_object);\n    o_stack.requested = e_stack.requested = d_stack.requested = 0;\n    while (*gc_signal) { /* Some routine below triggered a GC. */\n        gs_gc_root_t epref_root;\n\n        *gc_signal = 0;\n        /* Make sure that doref will get relocated properly if */\n        /* a garbage collection happens with epref == &doref. */\n        gs_register_ref_root(imemory_system, &epref_root,\n                             (void **)&epref, \"gs_call_interp(epref)\");\n        code = interp_reclaim(pi_ctx_p, -1);\n        i_ctx_p = *pi_ctx_p;\n        gs_unregister_root(imemory_system, &epref_root,\n                           \"gs_call_interp(epref)\");\n        if (code < 0)\n            return code;\n    }\n    code = interp(pi_ctx_p, epref, perror_object);\n    i_ctx_p = *pi_ctx_p;\n    if (!r_has_type(&i_ctx_p->error_object, t__invalid)) {\n        *perror_object = i_ctx_p->error_object;\n        make_t(&i_ctx_p->error_object, t__invalid);\n    }\n    /* Prevent a dangling reference to the GC signal in ticks_left */\n    /* in the frame of interp, but be prepared to do a GC if */\n    /* an allocation in this routine asks for it. */\n    *gc_signal = 0;\n    set_gc_signal(i_ctx_p, 1);\n    if (esp < esbot)            /* popped guard entry */\n        esp = esbot;\n    switch (code) {\n        case gs_error_Fatal:\n            *pexit_code = 255;\n            return code;\n        case gs_error_Quit:\n            *perror_object = osp[-1];\n            *pexit_code = code = osp->value.intval;\n            osp -= 2;\n            return\n                (code == 0 ? gs_error_Quit :\n                 code < 0 && code > -100 ? code : gs_error_Fatal);\n        case gs_error_InterpreterExit:\n            return 0;\n        case gs_error_ExecStackUnderflow:\n/****** WRONG -- must keep mark blocks intact ******/\n            ref_stack_pop_block(&e_stack);\n            doref = *perror_object;\n            epref = &doref;\n            goto again;\n        case gs_error_VMreclaim:\n            /* Do the GC and continue. */\n            /* We ignore the return value here, if it fails here\n             * we'll call it again having jumped to the \"again\" label.\n             * Where, assuming it fails again, we'll handle the error.\n             */\n            (void)interp_reclaim(pi_ctx_p,\n                                  (osp->value.intval == 2 ?\n                                   avm_global : avm_local));\n            i_ctx_p = *pi_ctx_p;\n            make_oper(&doref, 0, zpop);\n            epref = &doref;\n            goto again;\n        case gs_error_NeedInput:\n        case gs_error_interrupt:\n            return code;\n    }\n    /* Adjust osp in case of operand stack underflow */\n    if (osp < osbot - 1)\n        osp = osbot - 1;\n    /* We have to handle stack over/underflow specially, because */\n    /* we might be able to recover by adding or removing a block. */\n    switch (code) {\n        case gs_error_dictstackoverflow:\n            /* We don't have to handle this specially: */\n            /* The only places that could generate it */\n            /* use check_dstack, which does a ref_stack_extend, */\n            /* so if` we get this error, it's a real one. */\n            if (osp >= ostop) {\n                if ((ccode = ref_stack_extend(&o_stack, 1)) < 0)\n                    return ccode;\n            }\n            /* Skip system dictionaries for CET 20-02-02 */\n            ccode = copy_stack(i_ctx_p, &d_stack, min_dstack_size, &saref);\n            if (ccode < 0)\n                return ccode;\n            ref_stack_pop_to(&d_stack, min_dstack_size);\n            dict_set_top();\n            *++osp = saref;\n            break;\n        case gs_error_dictstackunderflow:\n            if (ref_stack_pop_block(&d_stack) >= 0) {\n                dict_set_top();\n                doref = *perror_object;\n                epref = &doref;\n                goto again;\n            }\n            break;\n        case gs_error_execstackoverflow:\n            /* We don't have to handle this specially: */\n            /* The only places that could generate it */\n            /* use check_estack, which does a ref_stack_extend, */\n            /* so if we get this error, it's a real one. */\n            if (osp >= ostop) {\n                if ((ccode = ref_stack_extend(&o_stack, 1)) < 0)\n                    return ccode;\n            }\n            ccode = copy_stack(i_ctx_p, &e_stack, 0, &saref);\n            if (ccode < 0)\n                return ccode;\n            {\n                uint count = ref_stack_count(&e_stack);\n                uint limit = ref_stack_max_count(&e_stack) - ES_HEADROOM;\n\n                if (count > limit) {\n                    /*\n                     * If there is an e-stack mark within MIN_BLOCK_ESTACK of\n                     * the new top, cut the stack back to remove the mark.\n                     */\n                    int skip = count - limit;\n                    int i;\n\n                    for (i = skip; i < skip + MIN_BLOCK_ESTACK; ++i) {\n                        const ref *ep = ref_stack_index(&e_stack, i);\n\n                        if (r_has_type_attrs(ep, t_null, a_executable)) {\n                            skip = i + 1;\n                            break;\n                        }\n                    }\n                    pop_estack(i_ctx_p, skip);\n                }\n            }\n            *++osp = saref;\n            break;\n        case gs_error_stackoverflow:\n            if (ref_stack_extend(&o_stack, o_stack.requested) >= 0) {   /* We can't just re-execute the object, because */\n                /* it might be a procedure being pushed as a */\n                /* literal.  We check for this case specially. */\n                doref = *perror_object;\n                if (r_is_proc(&doref)) {\n                    *++osp = doref;\n                    make_null_proc(&doref);\n                }\n                epref = &doref;\n                goto again;\n            }\n            ccode = copy_stack(i_ctx_p, &o_stack, 0, &saref);\n            if (ccode < 0)\n                return ccode;\n            ref_stack_clear(&o_stack);\n            *++osp = saref;\n            break;\n        case gs_error_stackunderflow:\n            if (ref_stack_pop_block(&o_stack) >= 0) {\n                doref = *perror_object;\n                epref = &doref;\n                goto again;\n            }\n            break;\n    }\n    if (user_errors < 0)\n        return code;\n    if (gs_errorname(i_ctx_p, code, &error_name) < 0)\n        return code;            /* out-of-range error code! */\n\n    /*  We refer to gserrordict first, which is not accessible to Postcript jobs\n     *  If we're running with SAFERERRORS all the handlers are copied to gserrordict\n     *  so we'll always find the default one. If not SAFERERRORS, only gs specific\n     *  errors are in gserrordict.\n     */\n    if (dict_find_string(systemdict, \"gserrordict\", &perrordict) <= 0 ||\n        (dict_find(perrordict, &error_name, &epref) <= 0 &&\n         (dict_find_string(systemdict, \"errordict\", &perrordict) <= 0 ||\n          dict_find(perrordict, &error_name, &epref) <= 0))\n        )\n        return code;            /* error name not in errordict??? */\n\n    doref = *epref;\n    epref = &doref;\n    /* Push the error object on the operand stack if appropriate. */\n    if (!GS_ERROR_IS_INTERRUPT(code)) {\n        byte buf[260], *bufptr;\n        uint rlen;\n        /* Replace the error object if within an oparray or .errorexec. */\n        osp++;\n        if (osp >= ostop) {\n            *pexit_code = gs_error_Fatal;\n            return_error(gs_error_Fatal);\n        }\n        *osp = *perror_object;\n        errorexec_find(i_ctx_p, osp);\n\n        if (!r_has_type(osp, t_string) && !r_has_type(osp, t_name)) {\n            code = obj_cvs(imemory, osp, buf + 2, 256, &rlen, (const byte **)&bufptr);\n            if (code < 0) {\n                const char *unknownstr = \"--unknown--\";\n                rlen = strlen(unknownstr);\n                memcpy(buf, unknownstr, rlen);\n                bufptr = buf;\n            }\n            else {\n                ref *tobj;\n                bufptr[rlen] = '\\0';\n                /* Only pass a name object if the operator doesn't exist in systemdict\n                 * i.e. it's an internal operator we have hidden\n                 */\n                code = dict_find_string(systemdict, (const char *)bufptr, &tobj);\n                if (code < 0) {\n                    buf[0] = buf[1] = buf[rlen + 2] = buf[rlen + 3] = '-';\n                    rlen += 4;\n                    bufptr = buf;\n                }\n                else {\n                    bufptr = NULL;\n                }\n            }\n            if (bufptr) {\n                code = name_ref(imemory, buf, rlen, osp, 1);\n                if (code < 0)\n                    make_null(osp);\n            }\n        }\n    }\n    goto again;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -197,6 +197,8 @@\n     epref = &doref;\n     /* Push the error object on the operand stack if appropriate. */\n     if (!GS_ERROR_IS_INTERRUPT(code)) {\n+        byte buf[260], *bufptr;\n+        uint rlen;\n         /* Replace the error object if within an oparray or .errorexec. */\n         osp++;\n         if (osp >= ostop) {\n@@ -205,23 +207,36 @@\n         }\n         *osp = *perror_object;\n         errorexec_find(i_ctx_p, osp);\n-        /* If using SAFER, hand a name object to the error handler, rather than the executable\n-         * object/operator itself.\n-         */\n-        if (i_ctx_p->LockFilePermissions) {\n+\n+        if (!r_has_type(osp, t_string) && !r_has_type(osp, t_name)) {\n             code = obj_cvs(imemory, osp, buf + 2, 256, &rlen, (const byte **)&bufptr);\n             if (code < 0) {\n                 const char *unknownstr = \"--unknown--\";\n                 rlen = strlen(unknownstr);\n                 memcpy(buf, unknownstr, rlen);\n+                bufptr = buf;\n             }\n             else {\n-                buf[0] = buf[1] = buf[rlen + 2] = buf[rlen + 3] = '-';\n-                rlen += 4;\n-            }\n-            code = name_ref(imemory, buf, rlen, osp, 1);\n-            if (code < 0)\n-                make_null(osp);\n+                ref *tobj;\n+                bufptr[rlen] = '\\0';\n+                /* Only pass a name object if the operator doesn't exist in systemdict\n+                 * i.e. it's an internal operator we have hidden\n+                 */\n+                code = dict_find_string(systemdict, (const char *)bufptr, &tobj);\n+                if (code < 0) {\n+                    buf[0] = buf[1] = buf[rlen + 2] = buf[rlen + 3] = '-';\n+                    rlen += 4;\n+                    bufptr = buf;\n+                }\n+                else {\n+                    bufptr = NULL;\n+                }\n+            }\n+            if (bufptr) {\n+                code = name_ref(imemory, buf, rlen, osp, 1);\n+                if (code < 0)\n+                    make_null(osp);\n+            }\n         }\n     }\n     goto again;",
        "diff_line_info": {
            "deleted_lines": [
                "        /* If using SAFER, hand a name object to the error handler, rather than the executable",
                "         * object/operator itself.",
                "         */",
                "        if (i_ctx_p->LockFilePermissions) {",
                "                buf[0] = buf[1] = buf[rlen + 2] = buf[rlen + 3] = '-';",
                "                rlen += 4;",
                "            }",
                "            code = name_ref(imemory, buf, rlen, osp, 1);",
                "            if (code < 0)",
                "                make_null(osp);"
            ],
            "added_lines": [
                "        byte buf[260], *bufptr;",
                "        uint rlen;",
                "",
                "        if (!r_has_type(osp, t_string) && !r_has_type(osp, t_name)) {",
                "                bufptr = buf;",
                "                ref *tobj;",
                "                bufptr[rlen] = '\\0';",
                "                /* Only pass a name object if the operator doesn't exist in systemdict",
                "                 * i.e. it's an internal operator we have hidden",
                "                 */",
                "                code = dict_find_string(systemdict, (const char *)bufptr, &tobj);",
                "                if (code < 0) {",
                "                    buf[0] = buf[1] = buf[rlen + 2] = buf[rlen + 3] = '-';",
                "                    rlen += 4;",
                "                    bufptr = buf;",
                "                }",
                "                else {",
                "                    bufptr = NULL;",
                "                }",
                "            }",
                "            if (bufptr) {",
                "                code = name_ref(imemory, buf, rlen, osp, 1);",
                "                if (code < 0)",
                "                    make_null(osp);",
                "            }"
            ]
        }
    }
]