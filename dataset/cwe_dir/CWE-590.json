[
    {
        "cve_id": "CVE-2023-42459",
        "func_name": "eProsima/Fast-DDS/MessageReceiver::proc_Submsg_Data",
        "description": "Fast DDS is a C++ implementation of the DDS (Data Distribution Service) standard of the OMG (Object Management Group). In affected versions specific DATA submessages can be sent to a discovery locator which may trigger a free error. This can remotely crash any Fast-DDS process. The call to free() could potentially leave the pointer in the attackers control which could lead to a double free. This issue has been addressed in versions 2.12.0, 2.11.3, 2.10.3, and 2.6.7. Users are advised to upgrade. There are no known workarounds for this vulnerability.\n",
        "git_url": "https://github.com/eProsima/Fast-DDS/commit/6fdbe790fe814c8799860bf896742bae58b7bf35",
        "commit_title": "Refs #16784. Fix issue.",
        "commit_text": "",
        "func_before": "bool MessageReceiver::proc_Submsg_Data(\n        CDRMessage_t* msg,\n        SubmessageHeader_t* smh,\n        EntityId_t& writerID) const\n{\n    eprosima::shared_lock<eprosima::shared_mutex> guard(mtx_);\n\n    //READ and PROCESS\n    if (smh->submessageLength < RTPSMESSAGE_DATA_MIN_LENGTH)\n    {\n        EPROSIMA_LOG_INFO(RTPS_MSG_IN, IDSTRING \"Too short submessage received, ignoring\");\n        return false;\n    }\n    //Fill flags bool values\n    bool endiannessFlag = (smh->flags & BIT(0)) != 0;\n    bool inlineQosFlag = (smh->flags & BIT(1)) != 0;\n    bool dataFlag = (smh->flags & BIT(2)) != 0;\n    bool keyFlag = (smh->flags & BIT(3)) != 0;\n    if (keyFlag && dataFlag)\n    {\n        EPROSIMA_LOG_WARNING(RTPS_MSG_IN, IDSTRING \"Message received with Data and Key Flag set, ignoring\");\n        return false;\n    }\n\n    //Assign message endianness\n    if (endiannessFlag)\n    {\n        msg->msg_endian = LITTLEEND;\n    }\n    else\n    {\n        msg->msg_endian = BIGEND;\n    }\n\n    //Extra flags don't matter now. Avoid those bytes\n    msg->pos += 2;\n\n    bool valid = true;\n    int16_t octetsToInlineQos = 0;\n    valid &= CDRMessage::readInt16(msg, &octetsToInlineQos); //it should be 16 in this implementation\n\n    //reader and writer ID\n    RTPSReader* first_reader = nullptr;\n    EntityId_t readerID;\n    valid &= CDRMessage::readEntityId(msg, &readerID);\n\n    //WE KNOW THE READER THAT THE MESSAGE IS DIRECTED TO SO WE LOOK FOR IT:\n    if (!willAReaderAcceptMsgDirectedTo(readerID, first_reader))\n    {\n        return false;\n    }\n\n    //FOUND THE READER.\n    //We ask the reader for a cachechange to store the information.\n    CacheChange_t ch;\n    ch.kind = ALIVE;\n    ch.writerGUID.guidPrefix = source_guid_prefix_;\n    valid &= CDRMessage::readEntityId(msg, &ch.writerGUID.entityId);\n\n    writerID = ch.writerGUID.entityId;\n\n    //Get sequence number\n    valid &= CDRMessage::readSequenceNumber(msg, &ch.sequenceNumber);\n\n    if (!valid)\n    {\n        return false;\n    }\n\n    if (ch.sequenceNumber <= SequenceNumber_t())\n    {\n        EPROSIMA_LOG_WARNING(RTPS_MSG_IN, IDSTRING \"Invalid message received, bad sequence Number\");\n        return false;\n    }\n\n    //Jump ahead if more parameters are before inlineQos (not in this version, maybe if further minor versions.)\n    if (octetsToInlineQos > RTPSMESSAGE_OCTETSTOINLINEQOS_DATASUBMSG)\n    {\n        msg->pos += (octetsToInlineQos - RTPSMESSAGE_OCTETSTOINLINEQOS_DATASUBMSG);\n        if (msg->pos > msg->length)\n        {\n            EPROSIMA_LOG_WARNING(RTPS_MSG_IN,\n                    IDSTRING \"Invalid jump through msg, msg->pos \" << msg->pos << \" > msg->length \" << msg->length);\n            return false;\n        }\n    }\n\n    uint32_t inlineQosSize = 0;\n\n    if (inlineQosFlag)\n    {\n        if (!ParameterList::updateCacheChangeFromInlineQos(ch, msg, inlineQosSize))\n        {\n            EPROSIMA_LOG_INFO(RTPS_MSG_IN, IDSTRING \"SubMessage Data ERROR, Inline Qos ParameterList error\");\n            return false;\n        }\n        ch.inline_qos.data = &msg->buffer[msg->pos - inlineQosSize];\n        ch.inline_qos.max_size = inlineQosSize;\n        ch.inline_qos.length = inlineQosSize;\n        ch.inline_qos.encapsulation = endiannessFlag ? PL_CDR_LE : PL_CDR_BE;\n        ch.inline_qos.pos = 0;\n    }\n\n    if (dataFlag || keyFlag)\n    {\n        uint32_t payload_size;\n        payload_size = smh->submessageLength -\n                (RTPSMESSAGE_DATA_EXTRA_INLINEQOS_SIZE + octetsToInlineQos + inlineQosSize);\n\n        if (dataFlag)\n        {\n            uint32_t next_pos = msg->pos + payload_size;\n            if (msg->length >= next_pos && payload_size > 0)\n            {\n                ch.serializedPayload.data = &msg->buffer[msg->pos];\n                ch.serializedPayload.length = payload_size;\n                ch.serializedPayload.max_size = payload_size;\n                msg->pos = next_pos;\n            }\n            else\n            {\n                EPROSIMA_LOG_WARNING(RTPS_MSG_IN, IDSTRING \"Serialized Payload value invalid or larger than maximum allowed size\"\n                        \"(\" << payload_size << \"/\" << (msg->length - msg->pos) << \")\");\n                return false;\n            }\n        }\n        else if (keyFlag)\n        {\n            if (payload_size <= 0)\n            {\n                EPROSIMA_LOG_WARNING(RTPS_MSG_IN, IDSTRING \"Serialized Payload value invalid (\" << payload_size << \")\");\n                return false;\n            }\n\n            if (payload_size <= PARAMETER_KEY_HASH_LENGTH)\n            {\n                memcpy(ch.instanceHandle.value, &msg->buffer[msg->pos], payload_size);\n            }\n            else\n            {\n                EPROSIMA_LOG_WARNING(RTPS_MSG_IN, IDSTRING \"Ignoring Serialized Payload for too large key-only data (\" <<\n                        payload_size << \")\");\n            }\n            msg->pos += payload_size;\n        }\n    }\n\n    // Set sourcetimestamp\n    if (have_timestamp_)\n    {\n        ch.sourceTimestamp = timestamp_;\n    }\n\n    EPROSIMA_LOG_INFO(RTPS_MSG_IN, IDSTRING \"from Writer \" << ch.writerGUID << \"; possible RTPSReader entities: \" <<\n            associated_readers_.size());\n\n    //Look for the correct reader to add the change\n    process_data_message_function_(readerID, ch);\n\n    IPayloadPool* payload_pool = ch.payload_owner();\n    if (payload_pool)\n    {\n        payload_pool->release_payload(ch);\n    }\n\n    //TODO(Ricardo) If an exception is thrown (ex, by fastcdr), these lines are not executed -> segmentation fault\n    ch.serializedPayload.data = nullptr;\n    ch.inline_qos.data = nullptr;\n\n    EPROSIMA_LOG_INFO(RTPS_MSG_IN, IDSTRING \"Sub Message DATA processed\");\n    return true;\n}",
        "func": "bool MessageReceiver::proc_Submsg_Data(\n        CDRMessage_t* msg,\n        SubmessageHeader_t* smh,\n        EntityId_t& writerID) const\n{\n    eprosima::shared_lock<eprosima::shared_mutex> guard(mtx_);\n\n    //READ and PROCESS\n    if (smh->submessageLength < RTPSMESSAGE_DATA_MIN_LENGTH)\n    {\n        EPROSIMA_LOG_INFO(RTPS_MSG_IN, IDSTRING \"Too short submessage received, ignoring\");\n        return false;\n    }\n    //Fill flags bool values\n    bool endiannessFlag = (smh->flags & BIT(0)) != 0;\n    bool inlineQosFlag = (smh->flags & BIT(1)) != 0;\n    bool dataFlag = (smh->flags & BIT(2)) != 0;\n    bool keyFlag = (smh->flags & BIT(3)) != 0;\n    if (keyFlag && dataFlag)\n    {\n        EPROSIMA_LOG_WARNING(RTPS_MSG_IN, IDSTRING \"Message received with Data and Key Flag set, ignoring\");\n        return false;\n    }\n\n    //Assign message endianness\n    if (endiannessFlag)\n    {\n        msg->msg_endian = LITTLEEND;\n    }\n    else\n    {\n        msg->msg_endian = BIGEND;\n    }\n\n    //Extra flags don't matter now. Avoid those bytes\n    msg->pos += 2;\n\n    bool valid = true;\n    int16_t octetsToInlineQos = 0;\n    valid &= CDRMessage::readInt16(msg, &octetsToInlineQos); //it should be 16 in this implementation\n\n    //reader and writer ID\n    RTPSReader* first_reader = nullptr;\n    EntityId_t readerID;\n    valid &= CDRMessage::readEntityId(msg, &readerID);\n\n    //WE KNOW THE READER THAT THE MESSAGE IS DIRECTED TO SO WE LOOK FOR IT:\n    if (!willAReaderAcceptMsgDirectedTo(readerID, first_reader))\n    {\n        return false;\n    }\n\n    //FOUND THE READER.\n    //We ask the reader for a cachechange to store the information.\n    CacheChange_t ch;\n    ch.kind = ALIVE;\n    ch.writerGUID.guidPrefix = source_guid_prefix_;\n    valid &= CDRMessage::readEntityId(msg, &ch.writerGUID.entityId);\n\n    writerID = ch.writerGUID.entityId;\n\n    //Get sequence number\n    valid &= CDRMessage::readSequenceNumber(msg, &ch.sequenceNumber);\n\n    if (!valid)\n    {\n        return false;\n    }\n\n    if (ch.sequenceNumber <= SequenceNumber_t())\n    {\n        EPROSIMA_LOG_WARNING(RTPS_MSG_IN, IDSTRING \"Invalid message received, bad sequence Number\");\n        return false;\n    }\n\n    //Jump ahead if more parameters are before inlineQos (not in this version, maybe if further minor versions.)\n    if (octetsToInlineQos > RTPSMESSAGE_OCTETSTOINLINEQOS_DATASUBMSG)\n    {\n        msg->pos += (octetsToInlineQos - RTPSMESSAGE_OCTETSTOINLINEQOS_DATASUBMSG);\n        if (msg->pos > msg->length)\n        {\n            EPROSIMA_LOG_WARNING(RTPS_MSG_IN,\n                    IDSTRING \"Invalid jump through msg, msg->pos \" << msg->pos << \" > msg->length \" << msg->length);\n            return false;\n        }\n    }\n\n    uint32_t inlineQosSize = 0;\n\n    if (inlineQosFlag)\n    {\n        if (!ParameterList::updateCacheChangeFromInlineQos(ch, msg, inlineQosSize))\n        {\n            EPROSIMA_LOG_INFO(RTPS_MSG_IN, IDSTRING \"SubMessage Data ERROR, Inline Qos ParameterList error\");\n            return false;\n        }\n        ch.inline_qos.data = &msg->buffer[msg->pos - inlineQosSize];\n        ch.inline_qos.max_size = inlineQosSize;\n        ch.inline_qos.length = inlineQosSize;\n        ch.inline_qos.encapsulation = endiannessFlag ? PL_CDR_LE : PL_CDR_BE;\n        ch.inline_qos.pos = 0;\n    }\n\n    if (dataFlag || keyFlag)\n    {\n        uint32_t payload_size;\n        payload_size = smh->submessageLength -\n                (RTPSMESSAGE_DATA_EXTRA_INLINEQOS_SIZE + octetsToInlineQos + inlineQosSize);\n\n        if (dataFlag)\n        {\n            uint32_t next_pos = msg->pos + payload_size;\n            if (msg->length >= next_pos && payload_size > 0)\n            {\n                ch.serializedPayload.data = &msg->buffer[msg->pos];\n                ch.serializedPayload.length = payload_size;\n                ch.serializedPayload.max_size = payload_size;\n                msg->pos = next_pos;\n            }\n            else\n            {\n                EPROSIMA_LOG_WARNING(RTPS_MSG_IN, IDSTRING \"Serialized Payload value invalid or larger than maximum allowed size\"\n                        \"(\" << payload_size << \"/\" << (msg->length - msg->pos) << \")\");\n                ch.serializedPayload.data = nullptr;\n                ch.inline_qos.data = nullptr;\n                return false;\n            }\n        }\n        else if (keyFlag)\n        {\n            if (payload_size <= 0)\n            {\n                EPROSIMA_LOG_WARNING(RTPS_MSG_IN, IDSTRING \"Serialized Payload value invalid (\" << payload_size << \")\");\n                ch.serializedPayload.data = nullptr;\n                ch.inline_qos.data = nullptr;\n                return false;\n            }\n\n            if (payload_size <= PARAMETER_KEY_HASH_LENGTH)\n            {\n                memcpy(ch.instanceHandle.value, &msg->buffer[msg->pos], payload_size);\n            }\n            else\n            {\n                EPROSIMA_LOG_WARNING(RTPS_MSG_IN, IDSTRING \"Ignoring Serialized Payload for too large key-only data (\" <<\n                        payload_size << \")\");\n            }\n            msg->pos += payload_size;\n        }\n    }\n\n    // Set sourcetimestamp\n    if (have_timestamp_)\n    {\n        ch.sourceTimestamp = timestamp_;\n    }\n\n    EPROSIMA_LOG_INFO(RTPS_MSG_IN, IDSTRING \"from Writer \" << ch.writerGUID << \"; possible RTPSReader entities: \" <<\n            associated_readers_.size());\n\n    //Look for the correct reader to add the change\n    process_data_message_function_(readerID, ch);\n\n    IPayloadPool* payload_pool = ch.payload_owner();\n    if (payload_pool)\n    {\n        payload_pool->release_payload(ch);\n    }\n\n    //TODO(Ricardo) If an exception is thrown (ex, by fastcdr), these lines are not executed -> segmentation fault\n    ch.serializedPayload.data = nullptr;\n    ch.inline_qos.data = nullptr;\n\n    EPROSIMA_LOG_INFO(RTPS_MSG_IN, IDSTRING \"Sub Message DATA processed\");\n    return true;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -121,6 +121,8 @@\n             {\n                 EPROSIMA_LOG_WARNING(RTPS_MSG_IN, IDSTRING \"Serialized Payload value invalid or larger than maximum allowed size\"\n                         \"(\" << payload_size << \"/\" << (msg->length - msg->pos) << \")\");\n+                ch.serializedPayload.data = nullptr;\n+                ch.inline_qos.data = nullptr;\n                 return false;\n             }\n         }\n@@ -129,6 +131,8 @@\n             if (payload_size <= 0)\n             {\n                 EPROSIMA_LOG_WARNING(RTPS_MSG_IN, IDSTRING \"Serialized Payload value invalid (\" << payload_size << \")\");\n+                ch.serializedPayload.data = nullptr;\n+                ch.inline_qos.data = nullptr;\n                 return false;\n             }\n ",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "                ch.serializedPayload.data = nullptr;",
                "                ch.inline_qos.data = nullptr;",
                "                ch.serializedPayload.data = nullptr;",
                "                ch.inline_qos.data = nullptr;"
            ]
        }
    }
]