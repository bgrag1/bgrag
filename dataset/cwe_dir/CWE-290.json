[
    {
        "cve_id": "CVE-2017-18190",
        "func_name": "apple/cups/valid_host",
        "description": "A localhost.localdomain whitelist entry in valid_host() in scheduler/client.c in CUPS before 2.2.2 allows remote attackers to execute arbitrary IPP commands by sending POST requests to the CUPS daemon in conjunction with DNS rebinding. The localhost.localdomain name is often resolved via a DNS server (neither the OS nor the web browser is responsible for ensuring that localhost.localdomain is 127.0.0.1).",
        "git_url": "https://github.com/apple/cups/commit/afa80cb2b457bf8d64f775bed307588610476c41",
        "commit_title": "Don't treat \"localhost.localdomain\" as an allowed replacement for localhost, since it isn't.",
        "commit_text": "",
        "func_before": "static int\t\t\t\t/* O - 1 if valid, 0 if not */\nvalid_host(cupsd_client_t *con)\t\t/* I - Client connection */\n{\n  cupsd_alias_t\t*a;\t\t\t/* Current alias */\n  cupsd_netif_t\t*netif;\t\t\t/* Current network interface */\n  const char\t*end;\t\t\t/* End character */\n  char\t\t*ptr;\t\t\t/* Pointer into host value */\n\n\n /*\n  * Copy the Host: header for later use...\n  */\n\n  strlcpy(con->clientname, httpGetField(con->http, HTTP_FIELD_HOST),\n          sizeof(con->clientname));\n  if ((ptr = strrchr(con->clientname, ':')) != NULL && !strchr(ptr, ']'))\n  {\n    *ptr++ = '\\0';\n    con->clientport = atoi(ptr);\n  }\n  else\n    con->clientport = con->serverport;\n\n /*\n  * Then validate...\n  */\n\n  if (httpAddrLocalhost(httpGetAddress(con->http)))\n  {\n   /*\n    * Only allow \"localhost\" or the equivalent IPv4 or IPv6 numerical\n    * addresses when accessing CUPS via the loopback interface...\n    */\n\n    return (!_cups_strcasecmp(con->clientname, \"localhost\") ||\n\t    !_cups_strcasecmp(con->clientname, \"localhost.\") ||\n#ifdef __linux\n\t    !_cups_strcasecmp(con->clientname, \"localhost.localdomain\") ||\n#endif /* __linux */\n            !strcmp(con->clientname, \"127.0.0.1\") ||\n\t    !strcmp(con->clientname, \"[::1]\"));\n  }\n\n#if defined(HAVE_DNSSD) || defined(HAVE_AVAHI)\n /*\n  * Check if the hostname is something.local (Bonjour); if so, allow it.\n  */\n\n  if ((end = strrchr(con->clientname, '.')) != NULL && end > con->clientname &&\n      !end[1])\n  {\n   /*\n    * \".\" on end, work back to second-to-last \".\"...\n    */\n\n    for (end --; end > con->clientname && *end != '.'; end --);\n  }\n\n  if (end && (!_cups_strcasecmp(end, \".local\") ||\n\t      !_cups_strcasecmp(end, \".local.\")))\n    return (1);\n#endif /* HAVE_DNSSD || HAVE_AVAHI */\n\n /*\n  * Check if the hostname is an IP address...\n  */\n\n  if (isdigit(con->clientname[0] & 255) || con->clientname[0] == '[')\n  {\n   /*\n    * Possible IPv4/IPv6 address...\n    */\n\n    http_addrlist_t *addrlist;\t\t/* List of addresses */\n\n\n    if ((addrlist = httpAddrGetList(con->clientname, AF_UNSPEC, NULL)) != NULL)\n    {\n     /*\n      * Good IPv4/IPv6 address...\n      */\n\n      httpAddrFreeList(addrlist);\n      return (1);\n    }\n  }\n\n /*\n  * Check for (alias) name matches...\n  */\n\n  for (a = (cupsd_alias_t *)cupsArrayFirst(ServerAlias);\n       a;\n       a = (cupsd_alias_t *)cupsArrayNext(ServerAlias))\n  {\n   /*\n    * \"ServerAlias *\" allows all host values through...\n    */\n\n    if (!strcmp(a->name, \"*\"))\n      return (1);\n\n    if (!_cups_strncasecmp(con->clientname, a->name, a->namelen))\n    {\n     /*\n      * Prefix matches; check the character at the end - it must be \".\" or nul.\n      */\n\n      end = con->clientname + a->namelen;\n\n      if (!*end || (*end == '.' && !end[1]))\n        return (1);\n    }\n  }\n\n#if defined(HAVE_DNSSD) || defined(HAVE_AVAHI)\n  for (a = (cupsd_alias_t *)cupsArrayFirst(DNSSDAlias);\n       a;\n       a = (cupsd_alias_t *)cupsArrayNext(DNSSDAlias))\n  {\n   /*\n    * \"ServerAlias *\" allows all host values through...\n    */\n\n    if (!strcmp(a->name, \"*\"))\n      return (1);\n\n    if (!_cups_strncasecmp(con->clientname, a->name, a->namelen))\n    {\n     /*\n      * Prefix matches; check the character at the end - it must be \".\" or nul.\n      */\n\n      end = con->clientname + a->namelen;\n\n      if (!*end || (*end == '.' && !end[1]))\n        return (1);\n    }\n  }\n#endif /* HAVE_DNSSD || HAVE_AVAHI */\n\n /*\n  * Check for interface hostname matches...\n  */\n\n  for (netif = (cupsd_netif_t *)cupsArrayFirst(NetIFList);\n       netif;\n       netif = (cupsd_netif_t *)cupsArrayNext(NetIFList))\n  {\n    if (!_cups_strncasecmp(con->clientname, netif->hostname, netif->hostlen))\n    {\n     /*\n      * Prefix matches; check the character at the end - it must be \".\" or nul.\n      */\n\n      end = con->clientname + netif->hostlen;\n\n      if (!*end || (*end == '.' && !end[1]))\n        return (1);\n    }\n  }\n\n  return (0);\n}",
        "func": "static int\t\t\t\t/* O - 1 if valid, 0 if not */\nvalid_host(cupsd_client_t *con)\t\t/* I - Client connection */\n{\n  cupsd_alias_t\t*a;\t\t\t/* Current alias */\n  cupsd_netif_t\t*netif;\t\t\t/* Current network interface */\n  const char\t*end;\t\t\t/* End character */\n  char\t\t*ptr;\t\t\t/* Pointer into host value */\n\n\n /*\n  * Copy the Host: header for later use...\n  */\n\n  strlcpy(con->clientname, httpGetField(con->http, HTTP_FIELD_HOST),\n          sizeof(con->clientname));\n  if ((ptr = strrchr(con->clientname, ':')) != NULL && !strchr(ptr, ']'))\n  {\n    *ptr++ = '\\0';\n    con->clientport = atoi(ptr);\n  }\n  else\n    con->clientport = con->serverport;\n\n /*\n  * Then validate...\n  */\n\n  if (httpAddrLocalhost(httpGetAddress(con->http)))\n  {\n   /*\n    * Only allow \"localhost\" or the equivalent IPv4 or IPv6 numerical\n    * addresses when accessing CUPS via the loopback interface...\n    */\n\n    return (!_cups_strcasecmp(con->clientname, \"localhost\") ||\n\t    !_cups_strcasecmp(con->clientname, \"localhost.\") ||\n            !strcmp(con->clientname, \"127.0.0.1\") ||\n\t    !strcmp(con->clientname, \"[::1]\"));\n  }\n\n#if defined(HAVE_DNSSD) || defined(HAVE_AVAHI)\n /*\n  * Check if the hostname is something.local (Bonjour); if so, allow it.\n  */\n\n  if ((end = strrchr(con->clientname, '.')) != NULL && end > con->clientname &&\n      !end[1])\n  {\n   /*\n    * \".\" on end, work back to second-to-last \".\"...\n    */\n\n    for (end --; end > con->clientname && *end != '.'; end --);\n  }\n\n  if (end && (!_cups_strcasecmp(end, \".local\") ||\n\t      !_cups_strcasecmp(end, \".local.\")))\n    return (1);\n#endif /* HAVE_DNSSD || HAVE_AVAHI */\n\n /*\n  * Check if the hostname is an IP address...\n  */\n\n  if (isdigit(con->clientname[0] & 255) || con->clientname[0] == '[')\n  {\n   /*\n    * Possible IPv4/IPv6 address...\n    */\n\n    http_addrlist_t *addrlist;\t\t/* List of addresses */\n\n\n    if ((addrlist = httpAddrGetList(con->clientname, AF_UNSPEC, NULL)) != NULL)\n    {\n     /*\n      * Good IPv4/IPv6 address...\n      */\n\n      httpAddrFreeList(addrlist);\n      return (1);\n    }\n  }\n\n /*\n  * Check for (alias) name matches...\n  */\n\n  for (a = (cupsd_alias_t *)cupsArrayFirst(ServerAlias);\n       a;\n       a = (cupsd_alias_t *)cupsArrayNext(ServerAlias))\n  {\n   /*\n    * \"ServerAlias *\" allows all host values through...\n    */\n\n    if (!strcmp(a->name, \"*\"))\n      return (1);\n\n    if (!_cups_strncasecmp(con->clientname, a->name, a->namelen))\n    {\n     /*\n      * Prefix matches; check the character at the end - it must be \".\" or nul.\n      */\n\n      end = con->clientname + a->namelen;\n\n      if (!*end || (*end == '.' && !end[1]))\n        return (1);\n    }\n  }\n\n#if defined(HAVE_DNSSD) || defined(HAVE_AVAHI)\n  for (a = (cupsd_alias_t *)cupsArrayFirst(DNSSDAlias);\n       a;\n       a = (cupsd_alias_t *)cupsArrayNext(DNSSDAlias))\n  {\n   /*\n    * \"ServerAlias *\" allows all host values through...\n    */\n\n    if (!strcmp(a->name, \"*\"))\n      return (1);\n\n    if (!_cups_strncasecmp(con->clientname, a->name, a->namelen))\n    {\n     /*\n      * Prefix matches; check the character at the end - it must be \".\" or nul.\n      */\n\n      end = con->clientname + a->namelen;\n\n      if (!*end || (*end == '.' && !end[1]))\n        return (1);\n    }\n  }\n#endif /* HAVE_DNSSD || HAVE_AVAHI */\n\n /*\n  * Check for interface hostname matches...\n  */\n\n  for (netif = (cupsd_netif_t *)cupsArrayFirst(NetIFList);\n       netif;\n       netif = (cupsd_netif_t *)cupsArrayNext(NetIFList))\n  {\n    if (!_cups_strncasecmp(con->clientname, netif->hostname, netif->hostlen))\n    {\n     /*\n      * Prefix matches; check the character at the end - it must be \".\" or nul.\n      */\n\n      end = con->clientname + netif->hostlen;\n\n      if (!*end || (*end == '.' && !end[1]))\n        return (1);\n    }\n  }\n\n  return (0);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -34,9 +34,6 @@\n \n     return (!_cups_strcasecmp(con->clientname, \"localhost\") ||\n \t    !_cups_strcasecmp(con->clientname, \"localhost.\") ||\n-#ifdef __linux\n-\t    !_cups_strcasecmp(con->clientname, \"localhost.localdomain\") ||\n-#endif /* __linux */\n             !strcmp(con->clientname, \"127.0.0.1\") ||\n \t    !strcmp(con->clientname, \"[::1]\"));\n   }",
        "diff_line_info": {
            "deleted_lines": [
                "#ifdef __linux",
                "\t    !_cups_strcasecmp(con->clientname, \"localhost.localdomain\") ||",
                "#endif /* __linux */"
            ],
            "added_lines": []
        }
    },
    {
        "cve_id": "CVE-2021-41130",
        "func_name": "cloudendpoints/esp/AuthChecker::PassUserInfoOnSuccess",
        "description": "Extensible Service Proxy, a.k.a. ESP is a proxy which enables API management capabilities for JSON/REST or gRPC API services. ESPv1 can be configured to authenticate a JWT token. Its verified JWT claim is passed to the application by HTTP header \"X-Endpoint-API-UserInfo\", the application can use it to do authorization. But if there are two \"X-Endpoint-API-UserInfo\" headers from the client, ESPv1 only replaces the first one, the 2nd one will be passed to the application. An attacker can send two \"X-Endpoint-API-UserInfo\" headers, the second one with a fake JWT claim. Application may use the fake JWT claim to do the authorization. This impacts following ESPv1 usages: 1) Users have configured ESPv1 to do JWT authentication with Google ID Token as described in the referenced google endpoint document. 2) Users backend application is using the info in the \"X-Endpoint-API-UserInfo\" header to do the authorization. It has been fixed by v1.58.0. You need to patch it in the following ways: * If your docker image is using tag \":1\", needs to re-start the container to pick up the new version. The tag \":1\" will automatically point to the latest version. * If your docker image tag pings to a specific minor version, e.g. \":1.57\". You need to update it to \":1.58\" and re-start the container. There are no workaround for this issue.",
        "git_url": "https://github.com/cloudendpoints/esp/commit/e310c4f91d229a072507f80c73811489b4cdff27",
        "commit_title": "Remove X-Endpoint-API-UserInfo for all header occurrences. (#845)",
        "commit_text": "",
        "func_before": "void AuthChecker::PassUserInfoOnSuccess() {\n  char *json_buf = auth::WriteUserInfoToJson(user_info_);\n  if (json_buf == nullptr) {\n    return;\n  }\n  char *base64_json_buf = auth::esp_base64_encode(\n      json_buf, strlen(json_buf), true, false, true /*padding*/);\n  context_->request()->AddHeaderToBackend(auth::kEndpointApiUserInfo,\n                                          base64_json_buf);\n  auth::esp_grpc_free(json_buf);\n  auth::esp_grpc_free(base64_json_buf);\n\n  TRACE(trace_span_) << \"Authenticated.\";\n  trace_span_.reset();\n  on_done_(Status::OK);\n}",
        "func": "void AuthChecker::PassUserInfoOnSuccess() {\n  char *json_buf = auth::WriteUserInfoToJson(user_info_);\n  if (json_buf == nullptr) {\n    return;\n  }\n  char *base64_json_buf = auth::esp_base64_encode(\n      json_buf, strlen(json_buf), true, false, true /*padding*/);\n  context_->request()->AddHeaderToBackend(auth::kEndpointApiUserInfo,\n                                          base64_json_buf, false);\n  auth::esp_grpc_free(json_buf);\n  auth::esp_grpc_free(base64_json_buf);\n\n  TRACE(trace_span_) << \"Authenticated.\";\n  trace_span_.reset();\n  on_done_(Status::OK);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,7 +6,7 @@\n   char *base64_json_buf = auth::esp_base64_encode(\n       json_buf, strlen(json_buf), true, false, true /*padding*/);\n   context_->request()->AddHeaderToBackend(auth::kEndpointApiUserInfo,\n-                                          base64_json_buf);\n+                                          base64_json_buf, false);\n   auth::esp_grpc_free(json_buf);\n   auth::esp_grpc_free(base64_json_buf);\n ",
        "diff_line_info": {
            "deleted_lines": [
                "                                          base64_json_buf);"
            ],
            "added_lines": [
                "                                          base64_json_buf, false);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-41130",
        "func_name": "cloudendpoints/esp/NgxEspRequest::AddHeaderToBackend",
        "description": "Extensible Service Proxy, a.k.a. ESP is a proxy which enables API management capabilities for JSON/REST or gRPC API services. ESPv1 can be configured to authenticate a JWT token. Its verified JWT claim is passed to the application by HTTP header \"X-Endpoint-API-UserInfo\", the application can use it to do authorization. But if there are two \"X-Endpoint-API-UserInfo\" headers from the client, ESPv1 only replaces the first one, the 2nd one will be passed to the application. An attacker can send two \"X-Endpoint-API-UserInfo\" headers, the second one with a fake JWT claim. Application may use the fake JWT claim to do the authorization. This impacts following ESPv1 usages: 1) Users have configured ESPv1 to do JWT authentication with Google ID Token as described in the referenced google endpoint document. 2) Users backend application is using the info in the \"X-Endpoint-API-UserInfo\" header to do the authorization. It has been fixed by v1.58.0. You need to patch it in the following ways: * If your docker image is using tag \":1\", needs to re-start the container to pick up the new version. The tag \":1\" will automatically point to the latest version. * If your docker image tag pings to a specific minor version, e.g. \":1.57\". You need to update it to \":1.58\" and re-start the container. There are no workaround for this issue.",
        "git_url": "https://github.com/cloudendpoints/esp/commit/e310c4f91d229a072507f80c73811489b4cdff27",
        "commit_title": "Remove X-Endpoint-API-UserInfo for all header occurrences. (#845)",
        "commit_text": "",
        "func_before": "utils::Status NgxEspRequest::AddHeaderToBackend(const std::string &key,\n                                                const std::string &value) {\n  ngx_table_elt_t *h = nullptr;\n  for (auto &h_in : r_->headers_in) {\n    if (key.size() == h_in.key.len &&\n        strncasecmp(key.c_str(), reinterpret_cast<const char *>(h_in.key.data),\n                    h_in.key.len) == 0) {\n      h = &h_in;\n      break;\n    }\n  }\n  if (h == nullptr) {\n    h = reinterpret_cast<ngx_table_elt_t *>(\n        ngx_list_push(&r_->headers_in.headers));\n    if (h == nullptr) {\n      return utils::Status(Code::INTERNAL, \"Out of memory\");\n    }\n\n    h->lowcase_key =\n        reinterpret_cast<u_char *>(ngx_pcalloc(r_->pool, key.size()));\n    if (h->lowcase_key == nullptr) {\n      return utils::Status(Code::INTERNAL, \"Out of memory\");\n    }\n    h->hash = ngx_hash_strlow(\n        h->lowcase_key,\n        reinterpret_cast<u_char *>(const_cast<char *>(key.c_str())),\n        key.size());\n  }\n\n  if (ngx_str_copy_from_std(r_->pool, key, &h->key) != NGX_OK ||\n      ngx_str_copy_from_std(r_->pool, value, &h->value) != NGX_OK) {\n    return utils::Status(Code::INTERNAL, \"Out of memory\");\n  }\n  ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r_->connection->log, 0,\n                 \"updates header to backend: \\\"%V: %V\\\"\", &h->key, &h->value);\n  return utils::Status::OK;\n}",
        "func": "utils::Status NgxEspRequest::AddHeaderToBackend(const std::string &key,\n                                                const std::string &value,\n                                                bool changeAllOccurrence) {\n  std::vector<ngx_table_elt_t *> headers;\n  for (auto &h_in : r_->headers_in) {\n    if (key.size() == h_in.key.len &&\n        strncasecmp(key.c_str(), reinterpret_cast<const char *>(h_in.key.data),\n                    h_in.key.len) == 0) {\n      headers.push_back(&h_in);\n      if (!changeAllOccurrence) {\n        break;\n      }\n    }\n  }\n  if (headers.empty()) {\n    ngx_table_elt_t *h = reinterpret_cast<ngx_table_elt_t *>(\n        ngx_list_push(&r_->headers_in.headers));\n    if (h == nullptr) {\n      return utils::Status(Code::INTERNAL, \"Out of memory\");\n    }\n\n    h->lowcase_key =\n        reinterpret_cast<u_char *>(ngx_pcalloc(r_->pool, key.size()));\n    if (h->lowcase_key == nullptr) {\n      return utils::Status(Code::INTERNAL, \"Out of memory\");\n    }\n    h->hash = ngx_hash_strlow(\n        h->lowcase_key,\n        reinterpret_cast<u_char *>(const_cast<char *>(key.c_str())),\n        key.size());\n    headers.push_back(h);\n  }\n\n  for (size_t i = 0; i < headers.size(); ++i) {\n    ngx_table_elt_t *it = headers[i];\n    if (ngx_str_copy_from_std(r_->pool, key, &it->key) != NGX_OK ||\n        ngx_str_copy_from_std(r_->pool, value, &it->value) != NGX_OK) {\n      return utils::Status(Code::INTERNAL, \"Out of memory\");\n    }\n  }\n\n  ngx_log_debug3(\n      NGX_LOG_DEBUG_HTTP, r_->connection->log, 0,\n      \"updates header to backend, changeAllOccurrence: '%t', \\\"%V: %V\\\"\",\n      changeAllOccurrence, &h->key, &h->value);\n  return utils::Status::OK;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,16 +1,19 @@\n utils::Status NgxEspRequest::AddHeaderToBackend(const std::string &key,\n-                                                const std::string &value) {\n-  ngx_table_elt_t *h = nullptr;\n+                                                const std::string &value,\n+                                                bool changeAllOccurrence) {\n+  std::vector<ngx_table_elt_t *> headers;\n   for (auto &h_in : r_->headers_in) {\n     if (key.size() == h_in.key.len &&\n         strncasecmp(key.c_str(), reinterpret_cast<const char *>(h_in.key.data),\n                     h_in.key.len) == 0) {\n-      h = &h_in;\n-      break;\n+      headers.push_back(&h_in);\n+      if (!changeAllOccurrence) {\n+        break;\n+      }\n     }\n   }\n-  if (h == nullptr) {\n-    h = reinterpret_cast<ngx_table_elt_t *>(\n+  if (headers.empty()) {\n+    ngx_table_elt_t *h = reinterpret_cast<ngx_table_elt_t *>(\n         ngx_list_push(&r_->headers_in.headers));\n     if (h == nullptr) {\n       return utils::Status(Code::INTERNAL, \"Out of memory\");\n@@ -25,13 +28,20 @@\n         h->lowcase_key,\n         reinterpret_cast<u_char *>(const_cast<char *>(key.c_str())),\n         key.size());\n+    headers.push_back(h);\n   }\n \n-  if (ngx_str_copy_from_std(r_->pool, key, &h->key) != NGX_OK ||\n-      ngx_str_copy_from_std(r_->pool, value, &h->value) != NGX_OK) {\n-    return utils::Status(Code::INTERNAL, \"Out of memory\");\n+  for (size_t i = 0; i < headers.size(); ++i) {\n+    ngx_table_elt_t *it = headers[i];\n+    if (ngx_str_copy_from_std(r_->pool, key, &it->key) != NGX_OK ||\n+        ngx_str_copy_from_std(r_->pool, value, &it->value) != NGX_OK) {\n+      return utils::Status(Code::INTERNAL, \"Out of memory\");\n+    }\n   }\n-  ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r_->connection->log, 0,\n-                 \"updates header to backend: \\\"%V: %V\\\"\", &h->key, &h->value);\n+\n+  ngx_log_debug3(\n+      NGX_LOG_DEBUG_HTTP, r_->connection->log, 0,\n+      \"updates header to backend, changeAllOccurrence: '%t', \\\"%V: %V\\\"\",\n+      changeAllOccurrence, &h->key, &h->value);\n   return utils::Status::OK;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "                                                const std::string &value) {",
                "  ngx_table_elt_t *h = nullptr;",
                "      h = &h_in;",
                "      break;",
                "  if (h == nullptr) {",
                "    h = reinterpret_cast<ngx_table_elt_t *>(",
                "  if (ngx_str_copy_from_std(r_->pool, key, &h->key) != NGX_OK ||",
                "      ngx_str_copy_from_std(r_->pool, value, &h->value) != NGX_OK) {",
                "    return utils::Status(Code::INTERNAL, \"Out of memory\");",
                "  ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r_->connection->log, 0,",
                "                 \"updates header to backend: \\\"%V: %V\\\"\", &h->key, &h->value);"
            ],
            "added_lines": [
                "                                                const std::string &value,",
                "                                                bool changeAllOccurrence) {",
                "  std::vector<ngx_table_elt_t *> headers;",
                "      headers.push_back(&h_in);",
                "      if (!changeAllOccurrence) {",
                "        break;",
                "      }",
                "  if (headers.empty()) {",
                "    ngx_table_elt_t *h = reinterpret_cast<ngx_table_elt_t *>(",
                "    headers.push_back(h);",
                "  for (size_t i = 0; i < headers.size(); ++i) {",
                "    ngx_table_elt_t *it = headers[i];",
                "    if (ngx_str_copy_from_std(r_->pool, key, &it->key) != NGX_OK ||",
                "        ngx_str_copy_from_std(r_->pool, value, &it->value) != NGX_OK) {",
                "      return utils::Status(Code::INTERNAL, \"Out of memory\");",
                "    }",
                "",
                "  ngx_log_debug3(",
                "      NGX_LOG_DEBUG_HTTP, r_->connection->log, 0,",
                "      \"updates header to backend, changeAllOccurrence: '%t', \\\"%V: %V\\\"\",",
                "      changeAllOccurrence, &h->key, &h->value);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-41130",
        "func_name": "cloudendpoints/esp/CheckServiceControl",
        "description": "Extensible Service Proxy, a.k.a. ESP is a proxy which enables API management capabilities for JSON/REST or gRPC API services. ESPv1 can be configured to authenticate a JWT token. Its verified JWT claim is passed to the application by HTTP header \"X-Endpoint-API-UserInfo\", the application can use it to do authorization. But if there are two \"X-Endpoint-API-UserInfo\" headers from the client, ESPv1 only replaces the first one, the 2nd one will be passed to the application. An attacker can send two \"X-Endpoint-API-UserInfo\" headers, the second one with a fake JWT claim. Application may use the fake JWT claim to do the authorization. This impacts following ESPv1 usages: 1) Users have configured ESPv1 to do JWT authentication with Google ID Token as described in the referenced google endpoint document. 2) Users backend application is using the info in the \"X-Endpoint-API-UserInfo\" header to do the authorization. It has been fixed by v1.58.0. You need to patch it in the following ways: * If your docker image is using tag \":1\", needs to re-start the container to pick up the new version. The tag \":1\" will automatically point to the latest version. * If your docker image tag pings to a specific minor version, e.g. \":1.57\". You need to update it to \":1.58\" and re-start the container. There are no workaround for this issue.",
        "git_url": "https://github.com/cloudendpoints/esp/commit/e310c4f91d229a072507f80c73811489b4cdff27",
        "commit_title": "Remove X-Endpoint-API-UserInfo for all header occurrences. (#845)",
        "commit_text": "",
        "func_before": "void CheckServiceControl(std::shared_ptr<context::RequestContext> context,\n                         std::function<void(Status status)> continuation) {\n  std::shared_ptr<cloud_trace::CloudTraceSpan> trace_span(\n      CreateSpan(context->cloud_trace(), \"CheckServiceControl\"));\n  // If the method is not configured from the service config.\n  // or if not need to check service control, skip it.\n  if (!context->method()) {\n    if (context->GetRequestHTTPMethodWithOverride() == \"OPTIONS\") {\n      TRACE(trace_span) << \"OPTIONS request is rejected\";\n      continuation(Status(Code::PERMISSION_DENIED,\n                          \"The service does not allow CORS traffic.\",\n                          Status::SERVICE_CONTROL));\n    } else {\n      TRACE(trace_span) << \"Method is not configured in the service config\";\n      continuation(Status(Code::NOT_FOUND, \"Method does not exist.\",\n                          Status::SERVICE_CONTROL));\n    }\n    return;\n  } else if (!context->service_context()->service_control() ||\n             context->method()->skip_service_control()) {\n    TRACE(trace_span) << \"Service control check is not needed\";\n    continuation(Status::OK);\n    return;\n  }\n\n  if (context->api_key().empty()) {\n    if (context->method()->allow_unregistered_calls()) {\n      // Not need to call Check.\n      TRACE(trace_span) << \"Service control check is not needed\";\n      continuation(Status::OK);\n      return;\n    }\n\n    TRACE(trace_span) << \"Failed at checking caller identity.\";\n    continuation(\n        Status(Code::UNAUTHENTICATED,\n               \"Method doesn't allow unregistered callers (callers without \"\n               \"established identity). Please use API Key or other form of \"\n               \"API consumer identity to call this API.\",\n               Status::SERVICE_CONTROL));\n    return;\n  }\n\n  service_control::CheckRequestInfo info;\n  context->FillCheckRequestInfo(&info);\n  context->service_context()->service_control()->Check(\n      info, trace_span.get(),\n      [context, continuation, trace_span](\n          Status status, const service_control::CheckResponseInfo &info) {\n        TRACE(trace_span) << \"Check service control request returned with \"\n                          << \"status \" << status.ToString();\n        // info is valid regardless status.\n        context->set_check_response_info(info);\n\n        // update consumer_project_id to service context\n        if (!info.consumer_project_id.empty()) {\n          context->request()->AddHeaderToBackend(kConsumerProjecId,\n                                                 info.consumer_project_id);\n        }\n\n        continuation(status);\n      });\n}",
        "func": "void CheckServiceControl(std::shared_ptr<context::RequestContext> context,\n                         std::function<void(Status status)> continuation) {\n  std::shared_ptr<cloud_trace::CloudTraceSpan> trace_span(\n      CreateSpan(context->cloud_trace(), \"CheckServiceControl\"));\n  // If the method is not configured from the service config.\n  // or if not need to check service control, skip it.\n  if (!context->method()) {\n    if (context->GetRequestHTTPMethodWithOverride() == \"OPTIONS\") {\n      TRACE(trace_span) << \"OPTIONS request is rejected\";\n      continuation(Status(Code::PERMISSION_DENIED,\n                          \"The service does not allow CORS traffic.\",\n                          Status::SERVICE_CONTROL));\n    } else {\n      TRACE(trace_span) << \"Method is not configured in the service config\";\n      continuation(Status(Code::NOT_FOUND, \"Method does not exist.\",\n                          Status::SERVICE_CONTROL));\n    }\n    return;\n  } else if (!context->service_context()->service_control() ||\n             context->method()->skip_service_control()) {\n    TRACE(trace_span) << \"Service control check is not needed\";\n    continuation(Status::OK);\n    return;\n  }\n\n  if (context->api_key().empty()) {\n    if (context->method()->allow_unregistered_calls()) {\n      // Not need to call Check.\n      TRACE(trace_span) << \"Service control check is not needed\";\n      continuation(Status::OK);\n      return;\n    }\n\n    TRACE(trace_span) << \"Failed at checking caller identity.\";\n    continuation(\n        Status(Code::UNAUTHENTICATED,\n               \"Method doesn't allow unregistered callers (callers without \"\n               \"established identity). Please use API Key or other form of \"\n               \"API consumer identity to call this API.\",\n               Status::SERVICE_CONTROL));\n    return;\n  }\n\n  service_control::CheckRequestInfo info;\n  context->FillCheckRequestInfo(&info);\n  context->service_context()->service_control()->Check(\n      info, trace_span.get(),\n      [context, continuation, trace_span](\n          Status status, const service_control::CheckResponseInfo &info) {\n        TRACE(trace_span) << \"Check service control request returned with \"\n                          << \"status \" << status.ToString();\n        // info is valid regardless status.\n        context->set_check_response_info(info);\n\n        // update consumer_project_id to service context\n        if (!info.consumer_project_id.empty()) {\n          context->request()->AddHeaderToBackend(\n              kConsumerProjecId, info.consumer_project_id, false);\n        }\n\n        continuation(status);\n      });\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -54,8 +54,8 @@\n \n         // update consumer_project_id to service context\n         if (!info.consumer_project_id.empty()) {\n-          context->request()->AddHeaderToBackend(kConsumerProjecId,\n-                                                 info.consumer_project_id);\n+          context->request()->AddHeaderToBackend(\n+              kConsumerProjecId, info.consumer_project_id, false);\n         }\n \n         continuation(status);",
        "diff_line_info": {
            "deleted_lines": [
                "          context->request()->AddHeaderToBackend(kConsumerProjecId,",
                "                                                 info.consumer_project_id);"
            ],
            "added_lines": [
                "          context->request()->AddHeaderToBackend(",
                "              kConsumerProjecId, info.consumer_project_id, false);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-41130",
        "func_name": "cloudendpoints/esp/RequestContext::SetApiKeyHeader",
        "description": "Extensible Service Proxy, a.k.a. ESP is a proxy which enables API management capabilities for JSON/REST or gRPC API services. ESPv1 can be configured to authenticate a JWT token. Its verified JWT claim is passed to the application by HTTP header \"X-Endpoint-API-UserInfo\", the application can use it to do authorization. But if there are two \"X-Endpoint-API-UserInfo\" headers from the client, ESPv1 only replaces the first one, the 2nd one will be passed to the application. An attacker can send two \"X-Endpoint-API-UserInfo\" headers, the second one with a fake JWT claim. Application may use the fake JWT claim to do the authorization. This impacts following ESPv1 usages: 1) Users have configured ESPv1 to do JWT authentication with Google ID Token as described in the referenced google endpoint document. 2) Users backend application is using the info in the \"X-Endpoint-API-UserInfo\" header to do the authorization. It has been fixed by v1.58.0. You need to patch it in the following ways: * If your docker image is using tag \":1\", needs to re-start the container to pick up the new version. The tag \":1\" will automatically point to the latest version. * If your docker image tag pings to a specific minor version, e.g. \":1.57\". You need to update it to \":1.58\" and re-start the container. There are no workaround for this issue.",
        "git_url": "https://github.com/cloudendpoints/esp/commit/e310c4f91d229a072507f80c73811489b4cdff27",
        "commit_title": "Remove X-Endpoint-API-UserInfo for all header occurrences. (#845)",
        "commit_text": "",
        "func_before": "void RequestContext::SetApiKeyHeader() {\n  request_->AddHeaderToBackend(kDefaultApiKeyHeaderName, api_key_);\n}",
        "func": "void RequestContext::SetApiKeyHeader() {\n  request_->AddHeaderToBackend(kDefaultApiKeyHeaderName, api_key_, false);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,3 +1,3 @@\n void RequestContext::SetApiKeyHeader() {\n-  request_->AddHeaderToBackend(kDefaultApiKeyHeaderName, api_key_);\n+  request_->AddHeaderToBackend(kDefaultApiKeyHeaderName, api_key_, false);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "  request_->AddHeaderToBackend(kDefaultApiKeyHeaderName, api_key_);"
            ],
            "added_lines": [
                "  request_->AddHeaderToBackend(kDefaultApiKeyHeaderName, api_key_, false);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-41130",
        "func_name": "cloudendpoints/esp/RequestContext::StartBackendSpanAndSetTraceContext",
        "description": "Extensible Service Proxy, a.k.a. ESP is a proxy which enables API management capabilities for JSON/REST or gRPC API services. ESPv1 can be configured to authenticate a JWT token. Its verified JWT claim is passed to the application by HTTP header \"X-Endpoint-API-UserInfo\", the application can use it to do authorization. But if there are two \"X-Endpoint-API-UserInfo\" headers from the client, ESPv1 only replaces the first one, the 2nd one will be passed to the application. An attacker can send two \"X-Endpoint-API-UserInfo\" headers, the second one with a fake JWT claim. Application may use the fake JWT claim to do the authorization. This impacts following ESPv1 usages: 1) Users have configured ESPv1 to do JWT authentication with Google ID Token as described in the referenced google endpoint document. 2) Users backend application is using the info in the \"X-Endpoint-API-UserInfo\" header to do the authorization. It has been fixed by v1.58.0. You need to patch it in the following ways: * If your docker image is using tag \":1\", needs to re-start the container to pick up the new version. The tag \":1\" will automatically point to the latest version. * If your docker image tag pings to a specific minor version, e.g. \":1.57\". You need to update it to \":1.58\" and re-start the container. There are no workaround for this issue.",
        "git_url": "https://github.com/cloudendpoints/esp/commit/e310c4f91d229a072507f80c73811489b4cdff27",
        "commit_title": "Remove X-Endpoint-API-UserInfo for all header occurrences. (#845)",
        "commit_text": "",
        "func_before": "void RequestContext::StartBackendSpanAndSetTraceContext() {\n  backend_span_.reset(CreateSpan(cloud_trace_.get(), \"Backend\"));\n\n  // TODO: A better logic would be to send for GRPC backends the grpc-trace-bin\n  // header, and for http/https backends the X-Cloud-Trace-Context header.\n\n  std::string trace_context_header = cloud_trace()->ToTraceContextHeader(\n      backend_span_->trace_span()->span_id());\n\n  // Set trace context header to backend.\n  Status status = request()->AddHeaderToBackend(\n      cloud_trace()->header_type() == HeaderType::CLOUD_TRACE_CONTEXT\n          ? kCloudTraceContextHeader\n          : kGRpcTraceContextHeader,\n      trace_context_header);\n  if (!status.ok()) {\n    service_context()->env()->LogError(\n        \"Failed to set trace context header to backend.\");\n  }\n}",
        "func": "void RequestContext::StartBackendSpanAndSetTraceContext() {\n  backend_span_.reset(CreateSpan(cloud_trace_.get(), \"Backend\"));\n\n  // TODO: A better logic would be to send for GRPC backends the grpc-trace-bin\n  // header, and for http/https backends the X-Cloud-Trace-Context header.\n\n  std::string trace_context_header = cloud_trace()->ToTraceContextHeader(\n      backend_span_->trace_span()->span_id());\n\n  // Set trace context header to backend.\n  Status status = request()->AddHeaderToBackend(\n      cloud_trace()->header_type() == HeaderType::CLOUD_TRACE_CONTEXT\n          ? kCloudTraceContextHeader\n          : kGRpcTraceContextHeader,\n      trace_context_header, false);\n  if (!status.ok()) {\n    service_context()->env()->LogError(\n        \"Failed to set trace context header to backend.\");\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -12,7 +12,7 @@\n       cloud_trace()->header_type() == HeaderType::CLOUD_TRACE_CONTEXT\n           ? kCloudTraceContextHeader\n           : kGRpcTraceContextHeader,\n-      trace_context_header);\n+      trace_context_header, false);\n   if (!status.ok()) {\n     service_context()->env()->LogError(\n         \"Failed to set trace context header to backend.\");",
        "diff_line_info": {
            "deleted_lines": [
                "      trace_context_header);"
            ],
            "added_lines": [
                "      trace_context_header, false);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-41130",
        "func_name": "cloudendpoints/esp/RequestContext::AddInstanceIdentityToken",
        "description": "Extensible Service Proxy, a.k.a. ESP is a proxy which enables API management capabilities for JSON/REST or gRPC API services. ESPv1 can be configured to authenticate a JWT token. Its verified JWT claim is passed to the application by HTTP header \"X-Endpoint-API-UserInfo\", the application can use it to do authorization. But if there are two \"X-Endpoint-API-UserInfo\" headers from the client, ESPv1 only replaces the first one, the 2nd one will be passed to the application. An attacker can send two \"X-Endpoint-API-UserInfo\" headers, the second one with a fake JWT claim. Application may use the fake JWT claim to do the authorization. This impacts following ESPv1 usages: 1) Users have configured ESPv1 to do JWT authentication with Google ID Token as described in the referenced google endpoint document. 2) Users backend application is using the info in the \"X-Endpoint-API-UserInfo\" header to do the authorization. It has been fixed by v1.58.0. You need to patch it in the following ways: * If your docker image is using tag \":1\", needs to re-start the container to pick up the new version. The tag \":1\" will automatically point to the latest version. * If your docker image tag pings to a specific minor version, e.g. \":1.57\". You need to update it to \":1.58\" and re-start the container. There are no workaround for this issue.",
        "git_url": "https://github.com/cloudendpoints/esp/commit/e310c4f91d229a072507f80c73811489b4cdff27",
        "commit_title": "Remove X-Endpoint-API-UserInfo for all header occurrences. (#845)",
        "commit_text": "",
        "func_before": "void RequestContext::AddInstanceIdentityToken() {\n  if (!method()) {\n    return;\n  }\n\n  const auto &audience = method()->backend_jwt_audience();\n  if (!audience.empty()) {\n    auto &token = service_context()\n                      ->global_context()\n                      ->GetInstanceIdentityToken(audience)\n                      ->GetAuthToken();\n    if (!token.empty()) {\n      std::string origin_auth_header;\n      if (request()->FindHeader(kAuthorizationHeader, &origin_auth_header)) {\n        Status status = request()->AddHeaderToBackend(\n            kXForwardedAuthorizationHeader, origin_auth_header);\n        if (!status.ok()) {\n          service_context()->env()->LogError(\n              \"Failed to set X-Forwarded-Authorization header to backend.\");\n        }\n      }\n      Status status = request()->AddHeaderToBackend(kAuthorizationHeader,\n                                                    kBearerPrefix + token);\n      if (!status.ok()) {\n        service_context()->env()->LogError(\n            \"Failed to set authorization header to backend.\");\n      }\n    }\n  }\n}",
        "func": "void RequestContext::AddInstanceIdentityToken() {\n  if (!method()) {\n    return;\n  }\n\n  const auto &audience = method()->backend_jwt_audience();\n  if (!audience.empty()) {\n    auto &token = service_context()\n                      ->global_context()\n                      ->GetInstanceIdentityToken(audience)\n                      ->GetAuthToken();\n    if (!token.empty()) {\n      std::string origin_auth_header;\n      if (request()->FindHeader(kAuthorizationHeader, &origin_auth_header)) {\n        Status status = request()->AddHeaderToBackend(\n            kXForwardedAuthorizationHeader, origin_auth_header, false);\n        if (!status.ok()) {\n          service_context()->env()->LogError(\n              \"Failed to set X-Forwarded-Authorization header to backend.\");\n        }\n      }\n      Status status = request()->AddHeaderToBackend(\n          kAuthorizationHeader, kBearerPrefix + token, false);\n      if (!status.ok()) {\n        service_context()->env()->LogError(\n            \"Failed to set authorization header to backend.\");\n      }\n    }\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -13,14 +13,14 @@\n       std::string origin_auth_header;\n       if (request()->FindHeader(kAuthorizationHeader, &origin_auth_header)) {\n         Status status = request()->AddHeaderToBackend(\n-            kXForwardedAuthorizationHeader, origin_auth_header);\n+            kXForwardedAuthorizationHeader, origin_auth_header, false);\n         if (!status.ok()) {\n           service_context()->env()->LogError(\n               \"Failed to set X-Forwarded-Authorization header to backend.\");\n         }\n       }\n-      Status status = request()->AddHeaderToBackend(kAuthorizationHeader,\n-                                                    kBearerPrefix + token);\n+      Status status = request()->AddHeaderToBackend(\n+          kAuthorizationHeader, kBearerPrefix + token, false);\n       if (!status.ok()) {\n         service_context()->env()->LogError(\n             \"Failed to set authorization header to backend.\");",
        "diff_line_info": {
            "deleted_lines": [
                "            kXForwardedAuthorizationHeader, origin_auth_header);",
                "      Status status = request()->AddHeaderToBackend(kAuthorizationHeader,",
                "                                                    kBearerPrefix + token);"
            ],
            "added_lines": [
                "            kXForwardedAuthorizationHeader, origin_auth_header, false);",
                "      Status status = request()->AddHeaderToBackend(",
                "          kAuthorizationHeader, kBearerPrefix + token, false);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-41130",
        "func_name": "cloudendpoints/esp/RequestHandler::RequestHandler",
        "description": "Extensible Service Proxy, a.k.a. ESP is a proxy which enables API management capabilities for JSON/REST or gRPC API services. ESPv1 can be configured to authenticate a JWT token. Its verified JWT claim is passed to the application by HTTP header \"X-Endpoint-API-UserInfo\", the application can use it to do authorization. But if there are two \"X-Endpoint-API-UserInfo\" headers from the client, ESPv1 only replaces the first one, the 2nd one will be passed to the application. An attacker can send two \"X-Endpoint-API-UserInfo\" headers, the second one with a fake JWT claim. Application may use the fake JWT claim to do the authorization. This impacts following ESPv1 usages: 1) Users have configured ESPv1 to do JWT authentication with Google ID Token as described in the referenced google endpoint document. 2) Users backend application is using the info in the \"X-Endpoint-API-UserInfo\" header to do the authorization. It has been fixed by v1.58.0. You need to patch it in the following ways: * If your docker image is using tag \":1\", needs to re-start the container to pick up the new version. The tag \":1\" will automatically point to the latest version. * If your docker image tag pings to a specific minor version, e.g. \":1.57\". You need to update it to \":1.58\" and re-start the container. There are no workaround for this issue.",
        "git_url": "https://github.com/cloudendpoints/esp/commit/e310c4f91d229a072507f80c73811489b4cdff27",
        "commit_title": "Remove X-Endpoint-API-UserInfo for all header occurrences. (#845)",
        "commit_text": "",
        "func_before": "RequestHandler::RequestHandler(\n    std::shared_ptr<CheckWorkflow> check_workflow,\n    std::shared_ptr<context::ServiceContext> service_context,\n    std::unique_ptr<Request> request_data)\n    : context_(new context::RequestContext(service_context,\n                                           std::move(request_data))),\n      check_workflow_(check_workflow) {\n  // Remove x-endponts-api-userinfo from downstream client.\n  // It should be set by the last Endpoint proxy to prevent users spoofing.\n  std::string buffer;\n  if (context_->request()->FindHeader(\n          google::api_manager::auth::kEndpointApiUserInfo, &buffer)) {\n    context_->request()->AddHeaderToBackend(\n        google::api_manager::auth::kEndpointApiUserInfo, \"\");\n  }\n}",
        "func": "RequestHandler::RequestHandler(\n    std::shared_ptr<CheckWorkflow> check_workflow,\n    std::shared_ptr<context::ServiceContext> service_context,\n    std::unique_ptr<Request> request_data)\n    : context_(new context::RequestContext(service_context,\n                                           std::move(request_data))),\n      check_workflow_(check_workflow) {\n  // Remove x-endponts-api-userinfo from downstream client.\n  // It should be set by the last Endpoint proxy to prevent users spoofing.\n  std::string buffer;\n  if (context_->request()->FindHeader(\n          google::api_manager::auth::kEndpointApiUserInfo, &buffer)) {\n    context_->request()->AddHeaderToBackend(\n        google::api_manager::auth::kEndpointApiUserInfo, \"\", true);\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -11,6 +11,6 @@\n   if (context_->request()->FindHeader(\n           google::api_manager::auth::kEndpointApiUserInfo, &buffer)) {\n     context_->request()->AddHeaderToBackend(\n-        google::api_manager::auth::kEndpointApiUserInfo, \"\");\n+        google::api_manager::auth::kEndpointApiUserInfo, \"\", true);\n   }\n }",
        "diff_line_info": {
            "deleted_lines": [
                "        google::api_manager::auth::kEndpointApiUserInfo, \"\");"
            ],
            "added_lines": [
                "        google::api_manager::auth::kEndpointApiUserInfo, \"\", true);"
            ]
        }
    }
]