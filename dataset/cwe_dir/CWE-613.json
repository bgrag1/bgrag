[
    {
        "cve_id": "CVE-2022-24732",
        "func_name": "foxcpp/maddy/run_pam_auth",
        "description": "Maddy Mail Server is an open source SMTP compatible email server. Versions of maddy prior to 0.5.4 do not implement password expiry or account expiry checking when authenticating using PAM. Users are advised to upgrade. Users unable to upgrade should manually remove expired accounts via existing filtering mechanisms.",
        "git_url": "https://github.com/foxcpp/maddy/commit/7ee6a39c6a1939b376545f030a5efd6f90913583",
        "commit_title": "auth/pam: Check for account/password expiry",
        "commit_text": " See GHSA-6cp7-g972-w9m9. Thanks Youssef Rebahi-Gilbert (ysf) for reporting the issue.",
        "func_before": "struct error_obj run_pam_auth(const char *username, char *password) {\n    // PAM frees pam_response for us.\n    struct pam_response *reply = malloc(sizeof(struct pam_response));\n    if (reply == NULL) {\n        struct error_obj ret_val;\n        ret_val.status = 2;\n        ret_val.func_name = \"malloc\";\n        ret_val.error_msg = \"Out of memory\";\n        return ret_val;\n    }\n    reply->resp = password;\n    reply->resp_retcode = 0;\n\n    const struct pam_conv local_conv = { conv_func, reply };\n    pam_handle_t *local_auth = NULL;\n    int status = pam_start(\"maddy\", username, &local_conv, &local_auth);\n    if (status != PAM_SUCCESS) {\n        struct error_obj ret_val;\n        ret_val.status = 2;\n        ret_val.func_name = \"pam_start\";\n        ret_val.error_msg = pam_strerror(local_auth, status);\n        return ret_val;\n    }\n\n    status = pam_authenticate(local_auth, PAM_SILENT|PAM_DISALLOW_NULL_AUTHTOK);\n    if (status != PAM_SUCCESS) {\n        struct error_obj ret_val;\n        if (status == PAM_AUTH_ERR || status == PAM_USER_UNKNOWN) {\n            ret_val.status = 1;\n        } else {\n            ret_val.status = 2;\n        }\n        ret_val.func_name = \"pam_authenticate\";\n        ret_val.error_msg = pam_strerror(local_auth, status);\n        return ret_val;\n    }\n\n    status = pam_end(local_auth, status);\n    if (status != PAM_SUCCESS) {\n        struct error_obj ret_val;\n        ret_val.status = 2;\n        ret_val.func_name = \"pam_end\";\n        ret_val.error_msg = pam_strerror(local_auth, status);\n        return ret_val;\n    }\n\n    struct error_obj ret_val;\n    ret_val.status = 0;\n    ret_val.func_name = NULL;\n    ret_val.error_msg = NULL;\n    return ret_val;\n}",
        "func": "struct error_obj run_pam_auth(const char *username, char *password) {\n    // PAM frees pam_response for us.\n    struct pam_response *reply = malloc(sizeof(struct pam_response));\n    if (reply == NULL) {\n        struct error_obj ret_val;\n        ret_val.status = 2;\n        ret_val.func_name = \"malloc\";\n        ret_val.error_msg = \"Out of memory\";\n        return ret_val;\n    }\n    reply->resp = password;\n    reply->resp_retcode = 0;\n\n    const struct pam_conv local_conv = { conv_func, reply };\n    pam_handle_t *local_auth = NULL;\n    int status = pam_start(\"maddy\", username, &local_conv, &local_auth);\n    if (status != PAM_SUCCESS) {\n        struct error_obj ret_val;\n        ret_val.status = 2;\n        ret_val.func_name = \"pam_start\";\n        ret_val.error_msg = pam_strerror(local_auth, status);\n        return ret_val;\n    }\n\n    status = pam_authenticate(local_auth, PAM_SILENT|PAM_DISALLOW_NULL_AUTHTOK);\n    if (status != PAM_SUCCESS) {\n        struct error_obj ret_val;\n        if (status == PAM_AUTH_ERR || status == PAM_USER_UNKNOWN) {\n            ret_val.status = 1;\n        } else {\n            ret_val.status = 2;\n        }\n        ret_val.func_name = \"pam_authenticate\";\n        ret_val.error_msg = pam_strerror(local_auth, status);\n        return ret_val;\n    }\n\n    status = pam_acct_mgmt(local_auth, PAM_SILENT|PAM_DISALLOW_NULL_AUTHTOK);\n    if (status != PAM_SUCCESS) {\n        struct error_obj ret_val;\n        if (status == PAM_AUTH_ERR || status == PAM_USER_UNKNOWN || status == PAM_NEW_AUTHTOK_REQD) {\n            ret_val.status = 1;\n        } else {\n            ret_val.status = 2;\n        }\n        ret_val.func_name = \"pam_acct_mgmt\";\n        ret_val.error_msg = pam_strerror(local_auth, status);\n        return ret_val;\n    }\n\n    status = pam_end(local_auth, status);\n    if (status != PAM_SUCCESS) {\n        struct error_obj ret_val;\n        ret_val.status = 2;\n        ret_val.func_name = \"pam_end\";\n        ret_val.error_msg = pam_strerror(local_auth, status);\n        return ret_val;\n    }\n\n    struct error_obj ret_val;\n    ret_val.status = 0;\n    ret_val.func_name = NULL;\n    ret_val.error_msg = NULL;\n    return ret_val;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -35,6 +35,19 @@\n         return ret_val;\n     }\n \n+    status = pam_acct_mgmt(local_auth, PAM_SILENT|PAM_DISALLOW_NULL_AUTHTOK);\n+    if (status != PAM_SUCCESS) {\n+        struct error_obj ret_val;\n+        if (status == PAM_AUTH_ERR || status == PAM_USER_UNKNOWN || status == PAM_NEW_AUTHTOK_REQD) {\n+            ret_val.status = 1;\n+        } else {\n+            ret_val.status = 2;\n+        }\n+        ret_val.func_name = \"pam_acct_mgmt\";\n+        ret_val.error_msg = pam_strerror(local_auth, status);\n+        return ret_val;\n+    }\n+\n     status = pam_end(local_auth, status);\n     if (status != PAM_SUCCESS) {\n         struct error_obj ret_val;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    status = pam_acct_mgmt(local_auth, PAM_SILENT|PAM_DISALLOW_NULL_AUTHTOK);",
                "    if (status != PAM_SUCCESS) {",
                "        struct error_obj ret_val;",
                "        if (status == PAM_AUTH_ERR || status == PAM_USER_UNKNOWN || status == PAM_NEW_AUTHTOK_REQD) {",
                "            ret_val.status = 1;",
                "        } else {",
                "            ret_val.status = 2;",
                "        }",
                "        ret_val.func_name = \"pam_acct_mgmt\";",
                "        ret_val.error_msg = pam_strerror(local_auth, status);",
                "        return ret_val;",
                "    }",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2022-24732",
        "func_name": "foxcpp/maddy/run_pam_auth",
        "description": "Maddy Mail Server is an open source SMTP compatible email server. Versions of maddy prior to 0.5.4 do not implement password expiry or account expiry checking when authenticating using PAM. Users are advised to upgrade. Users unable to upgrade should manually remove expired accounts via existing filtering mechanisms.",
        "git_url": "https://github.com/foxcpp/maddy/commit/7ee6a39c6a1939b376545f030a5efd6f90913583",
        "commit_title": "auth/pam: Check for account/password expiry",
        "commit_text": " See GHSA-6cp7-g972-w9m9. Thanks Youssef Rebahi-Gilbert (ysf) for reporting the issue.",
        "func_before": "struct error_obj run_pam_auth(const char *username, char *password) {\n    // PAM frees pam_response for us.\n    struct pam_response *reply = malloc(sizeof(struct pam_response));\n    if (reply == NULL) {\n        struct error_obj ret_val;\n        ret_val.status = 2;\n        ret_val.func_name = \"malloc\";\n        ret_val.error_msg = \"Out of memory\";\n        return ret_val;\n    }\n    reply->resp = password;\n    reply->resp_retcode = 0;\n\n    const struct pam_conv local_conv = { conv_func, reply };\n    pam_handle_t *local_auth = NULL;\n    int status = pam_start(\"maddy\", username, &local_conv, &local_auth);\n    if (status != PAM_SUCCESS) {\n        struct error_obj ret_val;\n        ret_val.status = 2;\n        ret_val.func_name = \"pam_start\";\n        ret_val.error_msg = pam_strerror(local_auth, status);\n        return ret_val;\n    }\n\n    status = pam_authenticate(local_auth, PAM_SILENT|PAM_DISALLOW_NULL_AUTHTOK);\n    if (status != PAM_SUCCESS) {\n        struct error_obj ret_val;\n        if (status == PAM_AUTH_ERR || status == PAM_USER_UNKNOWN) {\n            ret_val.status = 1;\n        } else {\n            ret_val.status = 2;\n        }\n        ret_val.func_name = \"pam_authenticate\";\n        ret_val.error_msg = pam_strerror(local_auth, status);\n        return ret_val;\n    }\n\n    status = pam_end(local_auth, status);\n    if (status != PAM_SUCCESS) {\n        struct error_obj ret_val;\n        ret_val.status = 2;\n        ret_val.func_name = \"pam_end\";\n        ret_val.error_msg = pam_strerror(local_auth, status);\n        return ret_val;\n    }\n\n    struct error_obj ret_val;\n    ret_val.status = 0;\n    ret_val.func_name = NULL;\n    ret_val.error_msg = NULL;\n    return ret_val;\n}",
        "func": "struct error_obj run_pam_auth(const char *username, char *password) {\n    // PAM frees pam_response for us.\n    struct pam_response *reply = malloc(sizeof(struct pam_response));\n    if (reply == NULL) {\n        struct error_obj ret_val;\n        ret_val.status = 2;\n        ret_val.func_name = \"malloc\";\n        ret_val.error_msg = \"Out of memory\";\n        return ret_val;\n    }\n    reply->resp = password;\n    reply->resp_retcode = 0;\n\n    const struct pam_conv local_conv = { conv_func, reply };\n    pam_handle_t *local_auth = NULL;\n    int status = pam_start(\"maddy\", username, &local_conv, &local_auth);\n    if (status != PAM_SUCCESS) {\n        struct error_obj ret_val;\n        ret_val.status = 2;\n        ret_val.func_name = \"pam_start\";\n        ret_val.error_msg = pam_strerror(local_auth, status);\n        return ret_val;\n    }\n\n    status = pam_authenticate(local_auth, PAM_SILENT|PAM_DISALLOW_NULL_AUTHTOK);\n    if (status != PAM_SUCCESS) {\n        struct error_obj ret_val;\n        if (status == PAM_AUTH_ERR || status == PAM_USER_UNKNOWN) {\n            ret_val.status = 1;\n        } else {\n            ret_val.status = 2;\n        }\n        ret_val.func_name = \"pam_authenticate\";\n        ret_val.error_msg = pam_strerror(local_auth, status);\n        return ret_val;\n    }\n\n    status = pam_acct_mgmt(local_auth, PAM_SILENT|PAM_DISALLOW_NULL_AUTHTOK);\n    if (status != PAM_SUCCESS) {\n        struct error_obj ret_val;\n        if (status == PAM_AUTH_ERR || status == PAM_USER_UNKNOWN || status == PAM_NEW_AUTHTOK_REQD) {\n            ret_val.status = 1;\n        } else {\n            ret_val.status = 2;\n        }\n        ret_val.func_name = \"pam_acct_mgmt\";\n        ret_val.error_msg = pam_strerror(local_auth, status);\n        return ret_val;\n    }\n\n    status = pam_end(local_auth, status);\n    if (status != PAM_SUCCESS) {\n        struct error_obj ret_val;\n        ret_val.status = 2;\n        ret_val.func_name = \"pam_end\";\n        ret_val.error_msg = pam_strerror(local_auth, status);\n        return ret_val;\n    }\n\n    struct error_obj ret_val;\n    ret_val.status = 0;\n    ret_val.func_name = NULL;\n    ret_val.error_msg = NULL;\n    return ret_val;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -35,6 +35,19 @@\n         return ret_val;\n     }\n \n+    status = pam_acct_mgmt(local_auth, PAM_SILENT|PAM_DISALLOW_NULL_AUTHTOK);\n+    if (status != PAM_SUCCESS) {\n+        struct error_obj ret_val;\n+        if (status == PAM_AUTH_ERR || status == PAM_USER_UNKNOWN || status == PAM_NEW_AUTHTOK_REQD) {\n+            ret_val.status = 1;\n+        } else {\n+            ret_val.status = 2;\n+        }\n+        ret_val.func_name = \"pam_acct_mgmt\";\n+        ret_val.error_msg = pam_strerror(local_auth, status);\n+        return ret_val;\n+    }\n+\n     status = pam_end(local_auth, status);\n     if (status != PAM_SUCCESS) {\n         struct error_obj ret_val;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    status = pam_acct_mgmt(local_auth, PAM_SILENT|PAM_DISALLOW_NULL_AUTHTOK);",
                "    if (status != PAM_SUCCESS) {",
                "        struct error_obj ret_val;",
                "        if (status == PAM_AUTH_ERR || status == PAM_USER_UNKNOWN || status == PAM_NEW_AUTHTOK_REQD) {",
                "            ret_val.status = 1;",
                "        } else {",
                "            ret_val.status = 2;",
                "        }",
                "        ret_val.func_name = \"pam_acct_mgmt\";",
                "        ret_val.error_msg = pam_strerror(local_auth, status);",
                "        return ret_val;",
                "    }",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2018-14345",
        "func_name": "sddm/Display::startAuth",
        "description": "An issue was discovered in SDDM through 0.17.0. If configured with ReuseSession=true, the password is not checked for users with an already existing session. Any user with access to the system D-Bus can therefore unlock any graphical session. This is related to daemon/Display.cpp and helper/backend/PamBackend.cpp.",
        "git_url": "https://github.com/sddm/sddm/commit/147cec383892d143b5e02daa70f1e7def50f5d98",
        "commit_title": "Fix authentication when reusing an existing session",
        "commit_text": " - Check the success value before unlocking the session - Don't attempt to use the nonexistant \"sddm-check\" PAM service",
        "func_before": "void Display::startAuth(const QString &user, const QString &password, const Session &session) {\n        m_passPhrase = password;\n\n        // sanity check\n        if (!session.isValid()) {\n            qCritical() << \"Invalid session\" << session.fileName();\n            return;\n        }\n        if (session.xdgSessionType().isEmpty()) {\n            qCritical() << \"Failed to find XDG session type for session\" << session.fileName();\n            return;\n        }\n        if (session.exec().isEmpty()) {\n            qCritical() << \"Failed to find command for session\" << session.fileName();\n            return;\n        }\n\n        QString existingSessionId;\n\n        if (Logind::isAvailable() && mainConfig.Users.ReuseSession.get()) {\n            OrgFreedesktopLogin1ManagerInterface manager(Logind::serviceName(), Logind::managerPath(), QDBusConnection::systemBus());\n            auto reply = manager.ListSessions();\n            reply.waitForFinished();\n\n            foreach(const SessionInfo &s, reply.value()) {\n                if (s.userName == user) {\n                    OrgFreedesktopLogin1SessionInterface session(Logind::serviceName(), s.sessionPath.path(), QDBusConnection::systemBus());\n                    if (session.service() == QLatin1String(\"sddm\")) {\n                        existingSessionId =  s.sessionId;\n                        break;\n                    }\n                }\n            }\n        }\n\n        // cache last session\n        m_lastSession = session;\n\n        // save session desktop file name, we'll use it to set the\n        // last session later, in slotAuthenticationFinished()\n        m_sessionName = session.fileName();\n\n        // some information\n        qDebug() << \"Session\" << m_sessionName << \"selected, command:\" << session.exec();\n\n        // create new VT for Wayland sessions otherwise use greeter vt\n        int vt = terminalId();\n        if (session.xdgSessionType() == QLatin1String(\"wayland\"))\n            vt = VirtualTerminal::setUpNewVt();\n        m_lastSession.setVt(vt);\n\n        QProcessEnvironment env;\n        env.insert(QStringLiteral(\"PATH\"), mainConfig.Users.DefaultPath.get());\n        if (session.xdgSessionType() == QLatin1String(\"x11\"))\n            env.insert(QStringLiteral(\"DISPLAY\"), name());\n        env.insert(QStringLiteral(\"XDG_SEAT_PATH\"), daemonApp->displayManager()->seatPath(seat()->name()));\n        env.insert(QStringLiteral(\"XDG_SESSION_PATH\"), daemonApp->displayManager()->sessionPath(QStringLiteral(\"Session%1\").arg(daemonApp->newSessionId())));\n        env.insert(QStringLiteral(\"DESKTOP_SESSION\"), session.desktopSession());\n        env.insert(QStringLiteral(\"XDG_CURRENT_DESKTOP\"), session.desktopNames());\n        env.insert(QStringLiteral(\"XDG_SESSION_CLASS\"), QStringLiteral(\"user\"));\n        env.insert(QStringLiteral(\"XDG_SESSION_TYPE\"), session.xdgSessionType());\n        env.insert(QStringLiteral(\"XDG_SEAT\"), seat()->name());\n\n        env.insert(QStringLiteral(\"XDG_SESSION_DESKTOP\"), session.desktopNames());\n        if (seat()->name() == QLatin1String(\"seat0\")) {\n            env.insert(QStringLiteral(\"XDG_VTNR\"), QString::number(vt));\n        }\n\n        m_auth->insertEnvironment(env);\n\n        m_auth->setUser(user);\n        if (existingSessionId.isNull()) {\n            m_auth->setSession(session.exec());\n        } else {\n            //we only want to unlock the session if we can lock in, so we want to go via PAM auth, but not start a new session\n            //by not setting the session and the helper will emit authentication and then quit\n            connect(m_auth, &Auth::authentication, this, [=](){\n                qDebug() << \"activating existing seat\";\n                OrgFreedesktopLogin1ManagerInterface manager(Logind::serviceName(), Logind::managerPath(), QDBusConnection::systemBus());\n                manager.UnlockSession(existingSessionId);\n                manager.ActivateSession(existingSessionId);\n            });\n        }\n        m_auth->start();\n    }",
        "func": "void Display::startAuth(const QString &user, const QString &password, const Session &session) {\n        m_passPhrase = password;\n\n        // sanity check\n        if (!session.isValid()) {\n            qCritical() << \"Invalid session\" << session.fileName();\n            return;\n        }\n        if (session.xdgSessionType().isEmpty()) {\n            qCritical() << \"Failed to find XDG session type for session\" << session.fileName();\n            return;\n        }\n        if (session.exec().isEmpty()) {\n            qCritical() << \"Failed to find command for session\" << session.fileName();\n            return;\n        }\n\n        QString existingSessionId;\n\n        if (Logind::isAvailable() && mainConfig.Users.ReuseSession.get()) {\n            OrgFreedesktopLogin1ManagerInterface manager(Logind::serviceName(), Logind::managerPath(), QDBusConnection::systemBus());\n            auto reply = manager.ListSessions();\n            reply.waitForFinished();\n\n            foreach(const SessionInfo &s, reply.value()) {\n                if (s.userName == user) {\n                    OrgFreedesktopLogin1SessionInterface session(Logind::serviceName(), s.sessionPath.path(), QDBusConnection::systemBus());\n                    if (session.service() == QLatin1String(\"sddm\")) {\n                        existingSessionId =  s.sessionId;\n                        break;\n                    }\n                }\n            }\n        }\n\n        // cache last session\n        m_lastSession = session;\n\n        // save session desktop file name, we'll use it to set the\n        // last session later, in slotAuthenticationFinished()\n        m_sessionName = session.fileName();\n\n        // some information\n        qDebug() << \"Session\" << m_sessionName << \"selected, command:\" << session.exec();\n\n        // create new VT for Wayland sessions otherwise use greeter vt\n        int vt = terminalId();\n        if (session.xdgSessionType() == QLatin1String(\"wayland\"))\n            vt = VirtualTerminal::setUpNewVt();\n        m_lastSession.setVt(vt);\n\n        QProcessEnvironment env;\n        env.insert(QStringLiteral(\"PATH\"), mainConfig.Users.DefaultPath.get());\n        if (session.xdgSessionType() == QLatin1String(\"x11\"))\n            env.insert(QStringLiteral(\"DISPLAY\"), name());\n        env.insert(QStringLiteral(\"XDG_SEAT_PATH\"), daemonApp->displayManager()->seatPath(seat()->name()));\n        env.insert(QStringLiteral(\"XDG_SESSION_PATH\"), daemonApp->displayManager()->sessionPath(QStringLiteral(\"Session%1\").arg(daemonApp->newSessionId())));\n        env.insert(QStringLiteral(\"DESKTOP_SESSION\"), session.desktopSession());\n        env.insert(QStringLiteral(\"XDG_CURRENT_DESKTOP\"), session.desktopNames());\n        env.insert(QStringLiteral(\"XDG_SESSION_CLASS\"), QStringLiteral(\"user\"));\n        env.insert(QStringLiteral(\"XDG_SESSION_TYPE\"), session.xdgSessionType());\n        env.insert(QStringLiteral(\"XDG_SEAT\"), seat()->name());\n\n        env.insert(QStringLiteral(\"XDG_SESSION_DESKTOP\"), session.desktopNames());\n        if (seat()->name() == QLatin1String(\"seat0\")) {\n            env.insert(QStringLiteral(\"XDG_VTNR\"), QString::number(vt));\n        }\n\n        m_auth->insertEnvironment(env);\n\n        m_auth->setUser(user);\n        if (existingSessionId.isNull()) {\n            m_auth->setSession(session.exec());\n        } else {\n            //we only want to unlock the session if we can lock in, so we want to go via PAM auth, but not start a new session\n            //by not setting the session and the helper will emit authentication and then quit\n            connect(m_auth, &Auth::authentication, this, [=](const QString &, bool success){\n                if(!success)\n                    return;\n                qDebug() << \"activating existing seat\";\n                OrgFreedesktopLogin1ManagerInterface manager(Logind::serviceName(), Logind::managerPath(), QDBusConnection::systemBus());\n                manager.UnlockSession(existingSessionId);\n                manager.ActivateSession(existingSessionId);\n            });\n        }\n        m_auth->start();\n    }",
        "diff_func": "--- func_before\n+++ func_after\n@@ -74,7 +74,9 @@\n         } else {\n             //we only want to unlock the session if we can lock in, so we want to go via PAM auth, but not start a new session\n             //by not setting the session and the helper will emit authentication and then quit\n-            connect(m_auth, &Auth::authentication, this, [=](){\n+            connect(m_auth, &Auth::authentication, this, [=](const QString &, bool success){\n+                if(!success)\n+                    return;\n                 qDebug() << \"activating existing seat\";\n                 OrgFreedesktopLogin1ManagerInterface manager(Logind::serviceName(), Logind::managerPath(), QDBusConnection::systemBus());\n                 manager.UnlockSession(existingSessionId);",
        "diff_line_info": {
            "deleted_lines": [
                "            connect(m_auth, &Auth::authentication, this, [=](){"
            ],
            "added_lines": [
                "            connect(m_auth, &Auth::authentication, this, [=](const QString &, bool success){",
                "                if(!success)",
                "                    return;"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-14345",
        "func_name": "sddm/PamBackend::start",
        "description": "An issue was discovered in SDDM through 0.17.0. If configured with ReuseSession=true, the password is not checked for users with an already existing session. Any user with access to the system D-Bus can therefore unlock any graphical session. This is related to daemon/Display.cpp and helper/backend/PamBackend.cpp.",
        "git_url": "https://github.com/sddm/sddm/commit/147cec383892d143b5e02daa70f1e7def50f5d98",
        "commit_title": "Fix authentication when reusing an existing session",
        "commit_text": " - Check the success value before unlocking the session - Don't attempt to use the nonexistant \"sddm-check\" PAM service",
        "func_before": "bool PamBackend::start(const QString &user) {\n        bool result;\n\n        QString service = QStringLiteral(\"sddm\");\n\n        if (user == QStringLiteral(\"sddm\") && m_greeter)\n            service = QStringLiteral(\"sddm-greeter\");\n        else if (m_app->session()->path().isEmpty())\n            service = QStringLiteral(\"sddm-check\");\n        else if (m_autologin)\n            service = QStringLiteral(\"sddm-autologin\");\n        result = m_pam->start(service, user);\n\n        if (!result)\n            m_app->error(m_pam->errorString(), Auth::ERROR_INTERNAL);\n\n        return result;\n    }",
        "func": "bool PamBackend::start(const QString &user) {\n        bool result;\n\n        QString service = QStringLiteral(\"sddm\");\n\n        if (user == QStringLiteral(\"sddm\") && m_greeter)\n            service = QStringLiteral(\"sddm-greeter\");\n        else if (m_autologin)\n            service = QStringLiteral(\"sddm-autologin\");\n        result = m_pam->start(service, user);\n\n        if (!result)\n            m_app->error(m_pam->errorString(), Auth::ERROR_INTERNAL);\n\n        return result;\n    }",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,8 +5,6 @@\n \n         if (user == QStringLiteral(\"sddm\") && m_greeter)\n             service = QStringLiteral(\"sddm-greeter\");\n-        else if (m_app->session()->path().isEmpty())\n-            service = QStringLiteral(\"sddm-check\");\n         else if (m_autologin)\n             service = QStringLiteral(\"sddm-autologin\");\n         result = m_pam->start(service, user);",
        "diff_line_info": {
            "deleted_lines": [
                "        else if (m_app->session()->path().isEmpty())",
                "            service = QStringLiteral(\"sddm-check\");"
            ],
            "added_lines": []
        }
    },
    {
        "cve_id": "CVE-2021-25940",
        "func_name": "arangodb/AuthenticationFeature::collectOptions",
        "description": "In ArangoDB, versions v3.7.6 through v3.8.3 are vulnerable to Insufficient Session Expiration. When a user’s password is changed by the administrator, the session isn’t invalidated, allowing a malicious user to still be logged in and perform arbitrary actions within the system.",
        "git_url": "https://github.com/arangodb/arangodb/commit/e9c6ee9dcca7b9b4fbcd02a0b323d205bee838d3",
        "commit_title": "Revive startup parameter `--server.session-timeout` (#14118)",
        "commit_text": " Co-authored-by: Tobias Gödderz <tobias@arangodb.com>",
        "func_before": "void AuthenticationFeature::collectOptions(std::shared_ptr<ProgramOptions> options) {\n  options->addOldOption(\"server.disable-authentication\",\n                        \"server.authentication\");\n  options->addOldOption(\"server.disable-authentication-unix-sockets\",\n                        \"server.authentication-unix-sockets\");\n  options->addOldOption(\"server.authenticate-system-only\",\n                        \"server.authentication-system-only\");\n  options->addOldOption(\"server.allow-method-override\",\n                        \"http.allow-method-override\");\n  options->addOldOption(\"server.hide-product-header\",\n                        \"http.hide-product-header\");\n  options->addOldOption(\"server.keep-alive-timeout\", \"http.keep-alive-timeout\");\n  options->addOldOption(\"server.default-api-compatibility\", \"\");\n  options->addOldOption(\"no-server\", \"server.rest-server\");\n\n  options->addOption(\"--server.authentication\",\n                     \"enable authentication for ALL client requests\",\n                     new BooleanParameter(&_active));\n\n  options->addOption(\n      \"--server.authentication-timeout\",\n      \"timeout for the authentication cache in seconds (0 = indefinitely)\",\n      new DoubleParameter(&_authenticationTimeout));\n\n  options->addOption(\"--server.local-authentication\",\n                     \"enable authentication using the local user database\",\n                     new BooleanParameter(&_localAuthentication));\n\n  options->addOption(\n      \"--server.authentication-system-only\",\n      \"use HTTP authentication only for requests to /_api and /_admin\",\n      new BooleanParameter(&_authenticationSystemOnly));\n\n#ifdef ARANGODB_HAVE_DOMAIN_SOCKETS\n  options->addOption(\"--server.authentication-unix-sockets\",\n                     \"authentication for requests via UNIX domain sockets\",\n                     new BooleanParameter(&_authenticationUnixSockets));\n#endif\n\n  // Maybe deprecate this option in devel\n  options\n      ->addOption(\"--server.jwt-secret\",\n                  \"secret to use when doing jwt authentication\",\n                  new StringParameter(&_jwtSecretProgramOption))\n      .setDeprecatedIn(30322)\n      .setDeprecatedIn(30402);\n\n  options->addOption(\n      \"--server.jwt-secret-keyfile\",\n      \"file containing jwt secret to use when doing jwt authentication.\",\n      new StringParameter(&_jwtSecretKeyfileProgramOption));\n\n  options->addOption(\n      \"--server.jwt-secret-folder\",\n      \"folder containing one or more jwt secret files to use for jwt \"\n      \"authentication. Files are sorted alphabetically: First secret \"\n      \"is used for signing + verifying JWT tokens. The latter secrets \"\n      \"are only used for verifying.\",\n      new StringParameter(&_jwtSecretFolderProgramOption),\n      arangodb::options::makeDefaultFlags(arangodb::options::Flags::Enterprise))\n      .setIntroducedIn(30700);\n}",
        "func": "void AuthenticationFeature::collectOptions(std::shared_ptr<ProgramOptions> options) {\n  options->addOldOption(\"server.disable-authentication\",\n                        \"server.authentication\");\n  options->addOldOption(\"server.disable-authentication-unix-sockets\",\n                        \"server.authentication-unix-sockets\");\n  options->addOldOption(\"server.authenticate-system-only\",\n                        \"server.authentication-system-only\");\n  options->addOldOption(\"server.allow-method-override\",\n                        \"http.allow-method-override\");\n  options->addOldOption(\"server.hide-product-header\",\n                        \"http.hide-product-header\");\n  options->addOldOption(\"server.keep-alive-timeout\", \"http.keep-alive-timeout\");\n  options->addOldOption(\"server.default-api-compatibility\", \"\");\n  options->addOldOption(\"no-server\", \"server.rest-server\");\n\n  options->addOption(\"--server.authentication\",\n                     \"enable authentication for ALL client requests\",\n                     new BooleanParameter(&_active));\n\n  options->addOption(\n      \"--server.authentication-timeout\",\n      \"timeout for the authentication cache in seconds (0 = indefinitely)\",\n      new DoubleParameter(&_authenticationTimeout));\n  \n  options->addOption(\"--server.session-timeout\",\n                     \"timeout in seconds for web interface JWT sessions\",\n                     new DoubleParameter(&_sessionTimeout),\n                     arangodb::options::makeFlags(\n                       arangodb::options::Flags::DefaultNoComponents,\n                       arangodb::options::Flags::OnCoordinator,\n                       arangodb::options::Flags::OnSingle))\n                     .setIntroducedIn(30900);\n\n  options->addOption(\"--server.local-authentication\",\n                     \"enable authentication using the local user database\",\n                     new BooleanParameter(&_localAuthentication),\n                     arangodb::options::makeFlags(\n                       arangodb::options::Flags::DefaultNoComponents,\n                       arangodb::options::Flags::OnCoordinator,\n                       arangodb::options::Flags::OnSingle));\n\n  options->addOption(\n      \"--server.authentication-system-only\",\n      \"use HTTP authentication only for requests to /_api and /_admin\",\n      new BooleanParameter(&_authenticationSystemOnly));\n\n#ifdef ARANGODB_HAVE_DOMAIN_SOCKETS\n  options->addOption(\"--server.authentication-unix-sockets\",\n                     \"authentication for requests via UNIX domain sockets\",\n                     new BooleanParameter(&_authenticationUnixSockets),\n                     arangodb::options::makeFlags(\n                       arangodb::options::Flags::DefaultNoOs,\n                       arangodb::options::Flags::OsLinux,\n                       arangodb::options::Flags::OsMac));\n#endif\n\n  options\n      ->addOption(\"--server.jwt-secret\",\n                  \"secret to use when doing jwt authentication\",\n                  new StringParameter(&_jwtSecretProgramOption))\n      .setDeprecatedIn(30322)\n      .setDeprecatedIn(30402);\n\n  options->addOption(\n      \"--server.jwt-secret-keyfile\",\n      \"file containing jwt secret to use when doing jwt authentication.\",\n      new StringParameter(&_jwtSecretKeyfileProgramOption));\n\n  options->addOption(\n      \"--server.jwt-secret-folder\",\n      \"folder containing one or more jwt secret files to use for jwt \"\n      \"authentication. Files are sorted alphabetically: First secret \"\n      \"is used for signing + verifying JWT tokens. The latter secrets \"\n      \"are only used for verifying.\",\n      new StringParameter(&_jwtSecretFolderProgramOption),\n      arangodb::options::makeDefaultFlags(arangodb::options::Flags::Enterprise))\n      .setIntroducedIn(30700);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -21,10 +21,23 @@\n       \"--server.authentication-timeout\",\n       \"timeout for the authentication cache in seconds (0 = indefinitely)\",\n       new DoubleParameter(&_authenticationTimeout));\n+  \n+  options->addOption(\"--server.session-timeout\",\n+                     \"timeout in seconds for web interface JWT sessions\",\n+                     new DoubleParameter(&_sessionTimeout),\n+                     arangodb::options::makeFlags(\n+                       arangodb::options::Flags::DefaultNoComponents,\n+                       arangodb::options::Flags::OnCoordinator,\n+                       arangodb::options::Flags::OnSingle))\n+                     .setIntroducedIn(30900);\n \n   options->addOption(\"--server.local-authentication\",\n                      \"enable authentication using the local user database\",\n-                     new BooleanParameter(&_localAuthentication));\n+                     new BooleanParameter(&_localAuthentication),\n+                     arangodb::options::makeFlags(\n+                       arangodb::options::Flags::DefaultNoComponents,\n+                       arangodb::options::Flags::OnCoordinator,\n+                       arangodb::options::Flags::OnSingle));\n \n   options->addOption(\n       \"--server.authentication-system-only\",\n@@ -34,10 +47,13 @@\n #ifdef ARANGODB_HAVE_DOMAIN_SOCKETS\n   options->addOption(\"--server.authentication-unix-sockets\",\n                      \"authentication for requests via UNIX domain sockets\",\n-                     new BooleanParameter(&_authenticationUnixSockets));\n+                     new BooleanParameter(&_authenticationUnixSockets),\n+                     arangodb::options::makeFlags(\n+                       arangodb::options::Flags::DefaultNoOs,\n+                       arangodb::options::Flags::OsLinux,\n+                       arangodb::options::Flags::OsMac));\n #endif\n \n-  // Maybe deprecate this option in devel\n   options\n       ->addOption(\"--server.jwt-secret\",\n                   \"secret to use when doing jwt authentication\",",
        "diff_line_info": {
            "deleted_lines": [
                "                     new BooleanParameter(&_localAuthentication));",
                "                     new BooleanParameter(&_authenticationUnixSockets));",
                "  // Maybe deprecate this option in devel"
            ],
            "added_lines": [
                "  ",
                "  options->addOption(\"--server.session-timeout\",",
                "                     \"timeout in seconds for web interface JWT sessions\",",
                "                     new DoubleParameter(&_sessionTimeout),",
                "                     arangodb::options::makeFlags(",
                "                       arangodb::options::Flags::DefaultNoComponents,",
                "                       arangodb::options::Flags::OnCoordinator,",
                "                       arangodb::options::Flags::OnSingle))",
                "                     .setIntroducedIn(30900);",
                "                     new BooleanParameter(&_localAuthentication),",
                "                     arangodb::options::makeFlags(",
                "                       arangodb::options::Flags::DefaultNoComponents,",
                "                       arangodb::options::Flags::OnCoordinator,",
                "                       arangodb::options::Flags::OnSingle));",
                "                     new BooleanParameter(&_authenticationUnixSockets),",
                "                     arangodb::options::makeFlags(",
                "                       arangodb::options::Flags::DefaultNoOs,",
                "                       arangodb::options::Flags::OsLinux,",
                "                       arangodb::options::Flags::OsMac));"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-25940",
        "func_name": "arangodb/AuthenticationFeature::validateOptions",
        "description": "In ArangoDB, versions v3.7.6 through v3.8.3 are vulnerable to Insufficient Session Expiration. When a user’s password is changed by the administrator, the session isn’t invalidated, allowing a malicious user to still be logged in and perform arbitrary actions within the system.",
        "git_url": "https://github.com/arangodb/arangodb/commit/e9c6ee9dcca7b9b4fbcd02a0b323d205bee838d3",
        "commit_title": "Revive startup parameter `--server.session-timeout` (#14118)",
        "commit_text": " Co-authored-by: Tobias Gödderz <tobias@arangodb.com>",
        "func_before": "void AuthenticationFeature::validateOptions(std::shared_ptr<ProgramOptions> options) {\n  if (!_jwtSecretKeyfileProgramOption.empty() && !_jwtSecretFolderProgramOption.empty()) {\n    LOG_TOPIC(\"d3515\", FATAL, Logger::STARTUP)\n        << \"please specify either '--server.jwt-\"\n           \"secret-keyfile' or '--server.jwt-secret-folder' but not both.\";\n    FATAL_ERROR_EXIT();\n  }\n\n  if (!_jwtSecretKeyfileProgramOption.empty() || !_jwtSecretFolderProgramOption.empty()) {\n    Result res = loadJwtSecretsFromFile();\n    if (res.fail()) {\n      LOG_TOPIC(\"d3617\", FATAL, Logger::STARTUP) << res.errorMessage();\n      FATAL_ERROR_EXIT();\n    }\n  }\n  if (!_jwtSecretProgramOption.empty()) {\n    if (_jwtSecretProgramOption.length() > _maxSecretLength) {\n      LOG_TOPIC(\"9abfc\", FATAL, arangodb::Logger::STARTUP)\n          << \"Given JWT secret too long. Max length is \" << _maxSecretLength;\n      FATAL_ERROR_EXIT();\n    }\n  }\n\n  if (options->processingResult().touched(\"server.jwt-secret\")) {\n    LOG_TOPIC(\"1aaae\", WARN, arangodb::Logger::AUTHENTICATION)\n        << \"--server.jwt-secret is insecure. Use --server.jwt-secret-keyfile \"\n           \"instead.\";\n  }\n}",
        "func": "void AuthenticationFeature::validateOptions(std::shared_ptr<ProgramOptions> options) {\n  if (!_jwtSecretKeyfileProgramOption.empty() && !_jwtSecretFolderProgramOption.empty()) {\n    LOG_TOPIC(\"d3515\", FATAL, Logger::STARTUP)\n        << \"please specify either '--server.jwt-\"\n           \"secret-keyfile' or '--server.jwt-secret-folder' but not both.\";\n    FATAL_ERROR_EXIT();\n  }\n\n  if (!_jwtSecretKeyfileProgramOption.empty() || !_jwtSecretFolderProgramOption.empty()) {\n    Result res = loadJwtSecretsFromFile();\n    if (res.fail()) {\n      LOG_TOPIC(\"d3617\", FATAL, Logger::STARTUP) << res.errorMessage();\n      FATAL_ERROR_EXIT();\n    }\n  }\n  if (!_jwtSecretProgramOption.empty()) {\n    if (_jwtSecretProgramOption.length() > _maxSecretLength) {\n      LOG_TOPIC(\"9abfc\", FATAL, arangodb::Logger::STARTUP)\n          << \"Given JWT secret too long. Max length is \" << _maxSecretLength;\n      FATAL_ERROR_EXIT();\n    }\n  }\n  \n  if (_sessionTimeout <= 1.0) {\n    LOG_TOPIC(\"85046\", FATAL, arangodb::Logger::AUTHENTICATION)\n        << \"--server.session-timeout has an invalid value: \" << _sessionTimeout;\n    FATAL_ERROR_EXIT();\n  }\n\n  if (options->processingResult().touched(\"server.jwt-secret\")) {\n    LOG_TOPIC(\"1aaae\", WARN, arangodb::Logger::AUTHENTICATION)\n        << \"--server.jwt-secret is insecure. Use --server.jwt-secret-keyfile \"\n           \"instead.\";\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -20,6 +20,12 @@\n       FATAL_ERROR_EXIT();\n     }\n   }\n+  \n+  if (_sessionTimeout <= 1.0) {\n+    LOG_TOPIC(\"85046\", FATAL, arangodb::Logger::AUTHENTICATION)\n+        << \"--server.session-timeout has an invalid value: \" << _sessionTimeout;\n+    FATAL_ERROR_EXIT();\n+  }\n \n   if (options->processingResult().touched(\"server.jwt-secret\")) {\n     LOG_TOPIC(\"1aaae\", WARN, arangodb::Logger::AUTHENTICATION)",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "  ",
                "  if (_sessionTimeout <= 1.0) {",
                "    LOG_TOPIC(\"85046\", FATAL, arangodb::Logger::AUTHENTICATION)",
                "        << \"--server.session-timeout has an invalid value: \" << _sessionTimeout;",
                "    FATAL_ERROR_EXIT();",
                "  }"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-25940",
        "func_name": "arangodb/AuthenticationFeature::AuthenticationFeature",
        "description": "In ArangoDB, versions v3.7.6 through v3.8.3 are vulnerable to Insufficient Session Expiration. When a user’s password is changed by the administrator, the session isn’t invalidated, allowing a malicious user to still be logged in and perform arbitrary actions within the system.",
        "git_url": "https://github.com/arangodb/arangodb/commit/e9c6ee9dcca7b9b4fbcd02a0b323d205bee838d3",
        "commit_title": "Revive startup parameter `--server.session-timeout` (#14118)",
        "commit_text": " Co-authored-by: Tobias Gödderz <tobias@arangodb.com>",
        "func_before": "AuthenticationFeature::AuthenticationFeature(application_features::ApplicationServer& server)\n    : ApplicationFeature(server, \"Authentication\"),\n      _userManager(nullptr),\n      _authCache(nullptr),\n      _authenticationUnixSockets(true),\n      _authenticationSystemOnly(true),\n      _localAuthentication(true),\n      _active(true),\n      _authenticationTimeout(0.0) {\n  setOptional(false);\n  startsAfter<application_features::BasicFeaturePhaseServer>();\n\n#ifdef USE_ENTERPRISE\n  startsAfter<LdapFeature>();\n#endif\n}",
        "func": "AuthenticationFeature::AuthenticationFeature(application_features::ApplicationServer& server)\n    : ApplicationFeature(server, \"Authentication\"),\n      _userManager(nullptr),\n      _authCache(nullptr),\n      _authenticationUnixSockets(true),\n      _authenticationSystemOnly(true),\n      _localAuthentication(true),\n      _active(true),\n      _authenticationTimeout(0.0),\n      _sessionTimeout(static_cast<double>(1 * std::chrono::hours(1) / std::chrono::seconds(1))) { // 1 hour\n  setOptional(false);\n  startsAfter<application_features::BasicFeaturePhaseServer>();\n\n#ifdef USE_ENTERPRISE\n  startsAfter<LdapFeature>();\n#endif\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,7 +6,8 @@\n       _authenticationSystemOnly(true),\n       _localAuthentication(true),\n       _active(true),\n-      _authenticationTimeout(0.0) {\n+      _authenticationTimeout(0.0),\n+      _sessionTimeout(static_cast<double>(1 * std::chrono::hours(1) / std::chrono::seconds(1))) { // 1 hour\n   setOptional(false);\n   startsAfter<application_features::BasicFeaturePhaseServer>();\n ",
        "diff_line_info": {
            "deleted_lines": [
                "      _authenticationTimeout(0.0) {"
            ],
            "added_lines": [
                "      _authenticationTimeout(0.0),",
                "      _sessionTimeout(static_cast<double>(1 * std::chrono::hours(1) / std::chrono::seconds(1))) { // 1 hour"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-25940",
        "func_name": "arangodb/RestAuthHandler::execute",
        "description": "In ArangoDB, versions v3.7.6 through v3.8.3 are vulnerable to Insufficient Session Expiration. When a user’s password is changed by the administrator, the session isn’t invalidated, allowing a malicious user to still be logged in and perform arbitrary actions within the system.",
        "git_url": "https://github.com/arangodb/arangodb/commit/e9c6ee9dcca7b9b4fbcd02a0b323d205bee838d3",
        "commit_title": "Revive startup parameter `--server.session-timeout` (#14118)",
        "commit_text": " Co-authored-by: Tobias Gödderz <tobias@arangodb.com>",
        "func_before": "RestStatus RestAuthHandler::execute() {\n  auto const type = _request->requestType();\n  if (type != rest::RequestType::POST) {\n    generateError(rest::ResponseCode::METHOD_NOT_ALLOWED, TRI_ERROR_HTTP_METHOD_NOT_ALLOWED);\n    return RestStatus::DONE;\n  }\n\n  bool parseSuccess = false;\n  VPackSlice slice = this->parseVPackBody(parseSuccess);\n  if (!parseSuccess) { // error already set\n    return RestStatus::DONE;\n  }\n\n  if (!slice.isObject()) {\n    return badRequest();\n  }\n\n  VPackSlice usernameSlice = slice.get(\"username\");\n  VPackSlice passwordSlice = slice.get(\"password\");\n\n  if (!usernameSlice.isString() || !passwordSlice.isString()) {\n    return badRequest();\n  }\n\n  _username = usernameSlice.copyString();\n  std::string const password = passwordSlice.copyString();\n\n  auth::UserManager* um = AuthenticationFeature::instance()->userManager();\n  if (um == nullptr) {\n    std::string msg = \"This server does not support users\";\n    LOG_TOPIC(\"2e7d4\", ERR, Logger::AUTHENTICATION) << msg;\n    generateError(rest::ResponseCode::UNAUTHORIZED, TRI_ERROR_HTTP_UNAUTHORIZED, msg);\n  } else if (um->checkPassword(_username, password)) {\n    VPackBuilder resultBuilder;\n    {\n      VPackObjectBuilder b(&resultBuilder);\n      std::string jwt = generateJwt(_username, password);\n      resultBuilder.add(\"jwt\", VPackValue(jwt));\n    }\n\n    _isValid = true;\n    generateDocument(resultBuilder.slice(), true, &VPackOptions::Defaults);\n  } else {\n    // mop: rfc 2616 10.4.2 (if credentials wrong 401)\n    generateError(rest::ResponseCode::UNAUTHORIZED, TRI_ERROR_HTTP_UNAUTHORIZED,\n                  \"Wrong credentials\");\n  }\n  return RestStatus::DONE;\n}",
        "func": "RestStatus RestAuthHandler::execute() {\n  auto const type = _request->requestType();\n  if (type != rest::RequestType::POST) {\n    generateError(rest::ResponseCode::METHOD_NOT_ALLOWED, TRI_ERROR_HTTP_METHOD_NOT_ALLOWED);\n    return RestStatus::DONE;\n  }\n\n  bool parseSuccess = false;\n  VPackSlice slice = this->parseVPackBody(parseSuccess);\n  if (!parseSuccess) { // error already set\n    return RestStatus::DONE;\n  }\n\n  if (!slice.isObject()) {\n    return badRequest();\n  }\n\n  VPackSlice usernameSlice = slice.get(\"username\");\n  VPackSlice passwordSlice = slice.get(\"password\");\n\n  if (!usernameSlice.isString() || !passwordSlice.isString()) {\n    return badRequest();\n  }\n\n  std::string const username = usernameSlice.copyString();\n  std::string const password = passwordSlice.copyString();\n\n  bool isValid = false;\n\n  auto guard = scopeGuard([&]() {\n    try {\n      if (isValid) {\n        events::LoggedIn(*_request, username);\n      } else {\n        events::CredentialsBad(*_request, username);\n      }\n    } catch (...) {\n      // nothing we can do\n    }\n  });\n  \n  auth::UserManager* um = AuthenticationFeature::instance()->userManager();\n  if (um == nullptr) {\n    std::string msg = \"This server does not support users\";\n    LOG_TOPIC(\"2e7d4\", ERR, Logger::AUTHENTICATION) << msg;\n    generateError(rest::ResponseCode::UNAUTHORIZED, TRI_ERROR_HTTP_UNAUTHORIZED, msg);\n  } else if (um->checkPassword(username, password)) {\n    VPackBuilder resultBuilder;\n    {\n      VPackObjectBuilder b(&resultBuilder);\n      resultBuilder.add(\"jwt\", VPackValue(generateJwt(username)));\n    }\n\n    isValid = true;\n    generateDocument(resultBuilder.slice(), true, &VPackOptions::Defaults);\n  } else {\n    // mop: rfc 2616 10.4.2 (if credentials wrong 401)\n    generateError(rest::ResponseCode::UNAUTHORIZED, TRI_ERROR_HTTP_UNAUTHORIZED,\n                  \"Wrong credentials\");\n  }\n  return RestStatus::DONE;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -22,23 +22,36 @@\n     return badRequest();\n   }\n \n-  _username = usernameSlice.copyString();\n+  std::string const username = usernameSlice.copyString();\n   std::string const password = passwordSlice.copyString();\n \n+  bool isValid = false;\n+\n+  auto guard = scopeGuard([&]() {\n+    try {\n+      if (isValid) {\n+        events::LoggedIn(*_request, username);\n+      } else {\n+        events::CredentialsBad(*_request, username);\n+      }\n+    } catch (...) {\n+      // nothing we can do\n+    }\n+  });\n+  \n   auth::UserManager* um = AuthenticationFeature::instance()->userManager();\n   if (um == nullptr) {\n     std::string msg = \"This server does not support users\";\n     LOG_TOPIC(\"2e7d4\", ERR, Logger::AUTHENTICATION) << msg;\n     generateError(rest::ResponseCode::UNAUTHORIZED, TRI_ERROR_HTTP_UNAUTHORIZED, msg);\n-  } else if (um->checkPassword(_username, password)) {\n+  } else if (um->checkPassword(username, password)) {\n     VPackBuilder resultBuilder;\n     {\n       VPackObjectBuilder b(&resultBuilder);\n-      std::string jwt = generateJwt(_username, password);\n-      resultBuilder.add(\"jwt\", VPackValue(jwt));\n+      resultBuilder.add(\"jwt\", VPackValue(generateJwt(username)));\n     }\n \n-    _isValid = true;\n+    isValid = true;\n     generateDocument(resultBuilder.slice(), true, &VPackOptions::Defaults);\n   } else {\n     // mop: rfc 2616 10.4.2 (if credentials wrong 401)",
        "diff_line_info": {
            "deleted_lines": [
                "  _username = usernameSlice.copyString();",
                "  } else if (um->checkPassword(_username, password)) {",
                "      std::string jwt = generateJwt(_username, password);",
                "      resultBuilder.add(\"jwt\", VPackValue(jwt));",
                "    _isValid = true;"
            ],
            "added_lines": [
                "  std::string const username = usernameSlice.copyString();",
                "  bool isValid = false;",
                "",
                "  auto guard = scopeGuard([&]() {",
                "    try {",
                "      if (isValid) {",
                "        events::LoggedIn(*_request, username);",
                "      } else {",
                "        events::CredentialsBad(*_request, username);",
                "      }",
                "    } catch (...) {",
                "      // nothing we can do",
                "    }",
                "  });",
                "  ",
                "  } else if (um->checkPassword(username, password)) {",
                "      resultBuilder.add(\"jwt\", VPackValue(generateJwt(username)));",
                "    isValid = true;"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-25940",
        "func_name": "arangodb/RestAuthHandler::generateJwt",
        "description": "In ArangoDB, versions v3.7.6 through v3.8.3 are vulnerable to Insufficient Session Expiration. When a user’s password is changed by the administrator, the session isn’t invalidated, allowing a malicious user to still be logged in and perform arbitrary actions within the system.",
        "git_url": "https://github.com/arangodb/arangodb/commit/e9c6ee9dcca7b9b4fbcd02a0b323d205bee838d3",
        "commit_title": "Revive startup parameter `--server.session-timeout` (#14118)",
        "commit_text": " Co-authored-by: Tobias Gödderz <tobias@arangodb.com>",
        "func_before": "std::string RestAuthHandler::generateJwt(std::string const& username,\n                                         std::string const& password) {\n  AuthenticationFeature* af = AuthenticationFeature::instance();\n  TRI_ASSERT(af != nullptr);\n  return fuerte::jwt::generateUserToken(af->tokenCache().jwtSecret(), username, _validFor);\n}",
        "func": "std::string RestAuthHandler::generateJwt(std::string const& username) const {\n  AuthenticationFeature* af = AuthenticationFeature::instance();\n  TRI_ASSERT(af != nullptr);\n  return fuerte::jwt::generateUserToken(\n      af->tokenCache().jwtSecret(), \n      username, \n      std::chrono::seconds(uint64_t(af->sessionTimeout())));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,8 @@\n-std::string RestAuthHandler::generateJwt(std::string const& username,\n-                                         std::string const& password) {\n+std::string RestAuthHandler::generateJwt(std::string const& username) const {\n   AuthenticationFeature* af = AuthenticationFeature::instance();\n   TRI_ASSERT(af != nullptr);\n-  return fuerte::jwt::generateUserToken(af->tokenCache().jwtSecret(), username, _validFor);\n+  return fuerte::jwt::generateUserToken(\n+      af->tokenCache().jwtSecret(), \n+      username, \n+      std::chrono::seconds(uint64_t(af->sessionTimeout())));\n }",
        "diff_line_info": {
            "deleted_lines": [
                "std::string RestAuthHandler::generateJwt(std::string const& username,",
                "                                         std::string const& password) {",
                "  return fuerte::jwt::generateUserToken(af->tokenCache().jwtSecret(), username, _validFor);"
            ],
            "added_lines": [
                "std::string RestAuthHandler::generateJwt(std::string const& username) const {",
                "  return fuerte::jwt::generateUserToken(",
                "      af->tokenCache().jwtSecret(), ",
                "      username, ",
                "      std::chrono::seconds(uint64_t(af->sessionTimeout())));"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-25940",
        "func_name": "arangodb/RestAuthHandler::RestAuthHandler",
        "description": "In ArangoDB, versions v3.7.6 through v3.8.3 are vulnerable to Insufficient Session Expiration. When a user’s password is changed by the administrator, the session isn’t invalidated, allowing a malicious user to still be logged in and perform arbitrary actions within the system.",
        "git_url": "https://github.com/arangodb/arangodb/commit/e9c6ee9dcca7b9b4fbcd02a0b323d205bee838d3",
        "commit_title": "Revive startup parameter `--server.session-timeout` (#14118)",
        "commit_text": " Co-authored-by: Tobias Gödderz <tobias@arangodb.com>",
        "func_before": "RestAuthHandler::RestAuthHandler(application_features::ApplicationServer& server,\n                                 GeneralRequest* request, GeneralResponse* response)\n    : RestVocbaseBaseHandler(server, request, response),\n      _validFor(60 * 60 * 24 * 30) {}",
        "func": "RestAuthHandler::RestAuthHandler(application_features::ApplicationServer& server,\n                                 GeneralRequest* request, GeneralResponse* response)\n    : RestVocbaseBaseHandler(server, request, response) {}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,3 @@\n RestAuthHandler::RestAuthHandler(application_features::ApplicationServer& server,\n                                  GeneralRequest* request, GeneralResponse* response)\n-    : RestVocbaseBaseHandler(server, request, response),\n-      _validFor(60 * 60 * 24 * 30) {}\n+    : RestVocbaseBaseHandler(server, request, response) {}",
        "diff_line_info": {
            "deleted_lines": [
                "    : RestVocbaseBaseHandler(server, request, response),",
                "      _validFor(60 * 60 * 24 * 30) {}"
            ],
            "added_lines": [
                "    : RestVocbaseBaseHandler(server, request, response) {}"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-25940",
        "func_name": "arangodb/ServerFeature::collectOptions",
        "description": "In ArangoDB, versions v3.7.6 through v3.8.3 are vulnerable to Insufficient Session Expiration. When a user’s password is changed by the administrator, the session isn’t invalidated, allowing a malicious user to still be logged in and perform arbitrary actions within the system.",
        "git_url": "https://github.com/arangodb/arangodb/commit/e9c6ee9dcca7b9b4fbcd02a0b323d205bee838d3",
        "commit_title": "Revive startup parameter `--server.session-timeout` (#14118)",
        "commit_text": " Co-authored-by: Tobias Gödderz <tobias@arangodb.com>",
        "func_before": "void ServerFeature::collectOptions(std::shared_ptr<ProgramOptions> options) {\n  options->addOption(\"--console\", \"start a JavaScript emergency console\",\n                     new BooleanParameter(&_console));\n\n  options->addSection(\"server\", \"server features\");\n\n  options->addOption(\"--server.rest-server\", \"start a rest-server\",\n                     new BooleanParameter(&_restServer),\n                     arangodb::options::makeDefaultFlags(arangodb::options::Flags::Hidden));\n  \n  options->addOption(\"--server.validate-utf8-strings\", \"perform UTF-8 string validation for incoming JSON and VelocyPack data\",\n                     new BooleanParameter(&_validateUtf8Strings),\n                     arangodb::options::makeDefaultFlags(arangodb::options::Flags::Hidden)).setIntroducedIn(30700);\n\n  options->addOption(\"--javascript.script\", \"run scripts and exit\",\n                     new VectorParameter<StringParameter>(&_scripts));\n\n#if _WIN32\n  options->addOption(\"--console.code-page\",\n                     \"Windows code page to use; defaults to UTF8\",\n                     new UInt16Parameter(&_codePage),\n                     arangodb::options::makeDefaultFlags(arangodb::options::Flags::Hidden));\n#endif\n\n  // add several obsoleted options here\n  options->addSection(\"vst\", \"VelocyStream protocol\", \"\", true, true);\n  options->addObsoleteOption(\"--vst.maxsize\", \"maximal size (in bytes) \"\n                             \"for a VelocyPack chunk\", true);\n  \n  options->addObsoleteOption(\n      \"--server.session-timeout\",\n      \"timeout of web interface server sessions (in seconds)\", true);\n\n  // add obsolete MMFiles WAL options (obsoleted in 3.7)\n  options->addSection(\"wal\", \"WAL of the MMFiles engine\", \"\", true, true);\n  options->addObsoleteOption(\"--wal.allow-oversize-entries\",\n                             \"allow entries that are bigger than '--wal.logfile-size'\", false);\n  options->addObsoleteOption(\"--wal.use-mlock\",\n                             \"mlock WAL logfiles in memory (may require elevated privileges or limits)\", false);\n  options->addObsoleteOption(\"--wal.directory\", \"logfile directory\", true);\n  options->addObsoleteOption(\"--wal.historic-logfiles\", \"maximum number of historic logfiles to keep after collection\", true);\n  options->addObsoleteOption(\"--wal.ignore-logfile-errors\", \n                             \"ignore logfile errors. this will read recoverable data from corrupted logfiles but ignore any unrecoverable data\", false);\n  options->addObsoleteOption(\"--wal.ignore-recovery-errors\", \"continue recovery even if re-applying operations fails\", false);\n  options->addObsoleteOption(\"--wal.flush-timeout\", \"flush timeout (in milliseconds)\", true);\n  options->addObsoleteOption(\"--wal.logfile-size\", \"size of each logfile (in bytes)\", true);\n  options->addObsoleteOption(\"--wal.open-logfiles\", \"maximum number of parallel open logfiles\", true);\n  options->addObsoleteOption(\"--wal.reserve-logfiles\", \"maximum number of reserve logfiles to maintain\", true);\n  options->addObsoleteOption(\"--wal.slots\", \"number of logfile slots to use\", true);\n  options->addObsoleteOption(\"--wal.sync-interval\", \"interval for automatic, non-requested disk syncs (in milliseconds)\", true);\n  options->addObsoleteOption(\"--wal.throttle-when-pending\", \n                             \"throttle writes when at least this many operations are waiting for collection (set to 0 to deactivate write-throttling)\", true);\n  options->addObsoleteOption(\"--wal.throttle-wait\", \"maximum wait time per operation when write-throttled (in milliseconds)\", true);\n}",
        "func": "void ServerFeature::collectOptions(std::shared_ptr<ProgramOptions> options) {\n  options->addOption(\"--console\", \"start a JavaScript emergency console\",\n                     new BooleanParameter(&_console));\n\n  options->addSection(\"server\", \"server features\");\n\n  options->addOption(\"--server.rest-server\", \"start a rest-server\",\n                     new BooleanParameter(&_restServer),\n                     arangodb::options::makeDefaultFlags(arangodb::options::Flags::Hidden));\n  \n  options->addOption(\"--server.validate-utf8-strings\", \"perform UTF-8 string validation for incoming JSON and VelocyPack data\",\n                     new BooleanParameter(&_validateUtf8Strings),\n                     arangodb::options::makeDefaultFlags(arangodb::options::Flags::Hidden)).setIntroducedIn(30700);\n\n  options->addOption(\"--javascript.script\", \"run scripts and exit\",\n                     new VectorParameter<StringParameter>(&_scripts));\n\n#if _WIN32\n  options->addOption(\"--console.code-page\",\n                     \"Windows code page to use; defaults to UTF8\",\n                     new UInt16Parameter(&_codePage),\n                     arangodb::options::makeDefaultFlags(arangodb::options::Flags::Hidden));\n#endif\n\n  // add several obsoleted options here\n  options->addSection(\"vst\", \"VelocyStream protocol\", \"\", true, true);\n  options->addObsoleteOption(\"--vst.maxsize\", \"maximal size (in bytes) \"\n                             \"for a VelocyPack chunk\", true);\n  \n  // add obsolete MMFiles WAL options (obsoleted in 3.7)\n  options->addSection(\"wal\", \"WAL of the MMFiles engine\", \"\", true, true);\n  options->addObsoleteOption(\"--wal.allow-oversize-entries\",\n                             \"allow entries that are bigger than '--wal.logfile-size'\", false);\n  options->addObsoleteOption(\"--wal.use-mlock\",\n                             \"mlock WAL logfiles in memory (may require elevated privileges or limits)\", false);\n  options->addObsoleteOption(\"--wal.directory\", \"logfile directory\", true);\n  options->addObsoleteOption(\"--wal.historic-logfiles\", \"maximum number of historic logfiles to keep after collection\", true);\n  options->addObsoleteOption(\"--wal.ignore-logfile-errors\", \n                             \"ignore logfile errors. this will read recoverable data from corrupted logfiles but ignore any unrecoverable data\", false);\n  options->addObsoleteOption(\"--wal.ignore-recovery-errors\", \"continue recovery even if re-applying operations fails\", false);\n  options->addObsoleteOption(\"--wal.flush-timeout\", \"flush timeout (in milliseconds)\", true);\n  options->addObsoleteOption(\"--wal.logfile-size\", \"size of each logfile (in bytes)\", true);\n  options->addObsoleteOption(\"--wal.open-logfiles\", \"maximum number of parallel open logfiles\", true);\n  options->addObsoleteOption(\"--wal.reserve-logfiles\", \"maximum number of reserve logfiles to maintain\", true);\n  options->addObsoleteOption(\"--wal.slots\", \"number of logfile slots to use\", true);\n  options->addObsoleteOption(\"--wal.sync-interval\", \"interval for automatic, non-requested disk syncs (in milliseconds)\", true);\n  options->addObsoleteOption(\"--wal.throttle-when-pending\", \n                             \"throttle writes when at least this many operations are waiting for collection (set to 0 to deactivate write-throttling)\", true);\n  options->addObsoleteOption(\"--wal.throttle-wait\", \"maximum wait time per operation when write-throttled (in milliseconds)\", true);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -27,10 +27,6 @@\n   options->addObsoleteOption(\"--vst.maxsize\", \"maximal size (in bytes) \"\n                              \"for a VelocyPack chunk\", true);\n   \n-  options->addObsoleteOption(\n-      \"--server.session-timeout\",\n-      \"timeout of web interface server sessions (in seconds)\", true);\n-\n   // add obsolete MMFiles WAL options (obsoleted in 3.7)\n   options->addSection(\"wal\", \"WAL of the MMFiles engine\", \"\", true, true);\n   options->addObsoleteOption(\"--wal.allow-oversize-entries\",",
        "diff_line_info": {
            "deleted_lines": [
                "  options->addObsoleteOption(",
                "      \"--server.session-timeout\",",
                "      \"timeout of web interface server sessions (in seconds)\", true);",
                ""
            ],
            "added_lines": []
        }
    }
]