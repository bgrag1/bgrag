[
    {
        "cve_id": "CVE-2023-1523",
        "func_name": "snapcore/snapd/populate_filter",
        "description": "Using the TIOCLINUX ioctl request, a malicious snap could inject contents into the input of the controlling terminal which could allow it to cause arbitrary commands to be executed outside of the snap sandbox after the snap exits. Graphical terminal emulators like xterm, gnome-terminal and others are not affected - this can only be exploited when snaps are run on a virtual console.",
        "git_url": "https://github.com/snapcore/snapd/commit/997dbfd5327d6e429f63ae7adc2bf2b31f070931",
        "commit_title": "snap-seccomp-blacklist: also disallow the use of ioctl + TIOCLINUX",
        "commit_text": " Fixes CVE-2023-1523 ",
        "func_before": "static int populate_filter(scmp_filter_ctx ctx, const uint32_t *arch_tags, size_t num_arch_tags) {\n    int sc_err;\n\n    /* If the native architecture is not one of the supported 64bit\n     * architectures listed in main in le_arch_tags and be_arch_tags, then\n     * remove it.\n     *\n     * Libseccomp automatically adds the native architecture to each new filter.\n     * If the native architecture is a 32bit-one then we will hit a bug in libseccomp\n     * and the generated BPF program is incorrect as described below. */\n    uint32_t native_arch = seccomp_arch_native();\n    bool remove_native_arch = true;\n    for (size_t i = 0; i < num_arch_tags; ++i) {\n        if (arch_tags[i] == native_arch) {\n            remove_native_arch = false;\n            break;\n        }\n    }\n    if (remove_native_arch) {\n        sc_err = seccomp_arch_remove(ctx, SCMP_ARCH_NATIVE);\n        if (sc_err < 0) {\n            showerr(\"cannot remove native architecture\");\n            return sc_err;\n        }\n    }\n\n    /* Add 64-bit architectures supported by snapd into the seccomp filter.\n     *\n     * The documentation of seccomp_arch_add() is confusing. It says that after\n     * this call any new rules will be added to this architecture. This is\n     * correct. It doesn't, however, explain that the rules will be multiplied\n     * and re-written as explained below. */\n    for (size_t i = 0; i < num_arch_tags; ++i) {\n        uint32_t arch_tag = arch_tags[i];\n        sc_err = seccomp_arch_add(ctx, arch_tag);\n        if (sc_err < 0 && sc_err != -EEXIST) {\n            showerr(\"cannot add architecture %x\", arch_tag);\n            return sc_err;\n        }\n    }\n\n    /* When the rule set doesn't match one of the architectures above then the\n     * resulting action should be a \"allow\" rather than \"kill\". We don't add\n     * any of the 32bit architectures since there is no need for any extra\n     * filtering there. */\n    sc_err = seccomp_attr_set(ctx, SCMP_FLTATR_ACT_BADARCH, SCMP_ACT_ALLOW);\n    if (sc_err < 0) {\n        showerr(\"cannot set action for unknown architectures\");\n        return sc_err;\n    }\n\n    /* Resolve the name of \"ioctl\" on this architecture. We are not using the\n     * system call number as available through the appropriate linux-specific\n     * header. This allows us to use a system call number that is not defined\n     * for the current architecture. This does not matter here, in this\n     * specific program, however it is more generic. In addition this is more\n     * in sync with the snap-seccomp program, which does the same for every\n     * system call. */\n    int sys_ioctl_nr;\n    sys_ioctl_nr = seccomp_syscall_resolve_name(\"ioctl\");\n    if (sys_ioctl_nr == __NR_SCMP_ERROR) {\n        showerr(\"cannot resolve ioctl system call number\");\n        return -ESRCH;\n    }\n\n    /* All of the rules must be added for the native architecture (using native\n     * system call numbers). When the final program is generated the set of\n     * architectures added earlier will be used to determine the correct system\n     * call number for each architecture.\n     *\n     * In other words, arguments to scmp_rule_add() must always use native\n     * system call numbers. Translation for the correct architecture will be\n     * performed internally. This is not documented in libseccomp, but correct\n     * operation was confirmed using the pseudo-code program and the bpf_dbg\n     * tool from the kernel tools/bpf directory.\n     *\n     * NOTE: not using scmp_rule_add_exact as that was not doing anything\n     * at all (presumably due to having all the architectures defined). */\n\n    const struct scmp_arg_cmp no_tty_inject = {\n        /* We learned that existing programs make legitimate requests with all\n         * bits set in the more significant 32bit word of the 64 bit double\n         * word. While this kernel behavior remains suspect and presumably\n         * undesired it is unlikely to change for backwards compatibility\n         * reasons. As such we cannot block all requests with high-bits set.\n         *\n         * When faced with ioctl(fd, request); refuse to proceed when\n         * request&0xffffffff == TIOCSTI. This specific way to encode the\n         * filter has the following important properties:\n         *\n         * - it blocks ioctl(fd, TIOCSTI, ptr).\n         * - it also blocks ioctl(fd, (1UL<<32) | TIOCSTI, ptr).\n         * - it doesn't block ioctl(fd, (1UL<<32) | (request not equal to TIOCSTI), ptr); */\n        .arg = 1,\n        .op = SCMP_CMP_MASKED_EQ,\n        .datum_a = 0xffffffffUL,\n        .datum_b = TIOCSTI,\n    };\n    sc_err = seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EPERM), sys_ioctl_nr, 1, no_tty_inject);\n\n    if (sc_err < 0) {\n        showerr(\"cannot add rule preventing the use high bits in ioctl\");\n        return sc_err;\n    }\n    return 0;\n}",
        "func": "static int populate_filter(scmp_filter_ctx ctx, const uint32_t *arch_tags, size_t num_arch_tags) {\n    int sc_err;\n\n    /* If the native architecture is not one of the supported 64bit\n     * architectures listed in main in le_arch_tags and be_arch_tags, then\n     * remove it.\n     *\n     * Libseccomp automatically adds the native architecture to each new filter.\n     * If the native architecture is a 32bit-one then we will hit a bug in libseccomp\n     * and the generated BPF program is incorrect as described below. */\n    uint32_t native_arch = seccomp_arch_native();\n    bool remove_native_arch = true;\n    for (size_t i = 0; i < num_arch_tags; ++i) {\n        if (arch_tags[i] == native_arch) {\n            remove_native_arch = false;\n            break;\n        }\n    }\n    if (remove_native_arch) {\n        sc_err = seccomp_arch_remove(ctx, SCMP_ARCH_NATIVE);\n        if (sc_err < 0) {\n            showerr(\"cannot remove native architecture\");\n            return sc_err;\n        }\n    }\n\n    /* Add 64-bit architectures supported by snapd into the seccomp filter.\n     *\n     * The documentation of seccomp_arch_add() is confusing. It says that after\n     * this call any new rules will be added to this architecture. This is\n     * correct. It doesn't, however, explain that the rules will be multiplied\n     * and re-written as explained below. */\n    for (size_t i = 0; i < num_arch_tags; ++i) {\n        uint32_t arch_tag = arch_tags[i];\n        sc_err = seccomp_arch_add(ctx, arch_tag);\n        if (sc_err < 0 && sc_err != -EEXIST) {\n            showerr(\"cannot add architecture %x\", arch_tag);\n            return sc_err;\n        }\n    }\n\n    /* When the rule set doesn't match one of the architectures above then the\n     * resulting action should be a \"allow\" rather than \"kill\". We don't add\n     * any of the 32bit architectures since there is no need for any extra\n     * filtering there. */\n    sc_err = seccomp_attr_set(ctx, SCMP_FLTATR_ACT_BADARCH, SCMP_ACT_ALLOW);\n    if (sc_err < 0) {\n        showerr(\"cannot set action for unknown architectures\");\n        return sc_err;\n    }\n\n    /* Resolve the name of \"ioctl\" on this architecture. We are not using the\n     * system call number as available through the appropriate linux-specific\n     * header. This allows us to use a system call number that is not defined\n     * for the current architecture. This does not matter here, in this\n     * specific program, however it is more generic. In addition this is more\n     * in sync with the snap-seccomp program, which does the same for every\n     * system call. */\n    int sys_ioctl_nr;\n    sys_ioctl_nr = seccomp_syscall_resolve_name(\"ioctl\");\n    if (sys_ioctl_nr == __NR_SCMP_ERROR) {\n        showerr(\"cannot resolve ioctl system call number\");\n        return -ESRCH;\n    }\n\n    /* All of the rules must be added for the native architecture (using native\n     * system call numbers). When the final program is generated the set of\n     * architectures added earlier will be used to determine the correct system\n     * call number for each architecture.\n     *\n     * In other words, arguments to scmp_rule_add() must always use native\n     * system call numbers. Translation for the correct architecture will be\n     * performed internally. This is not documented in libseccomp, but correct\n     * operation was confirmed using the pseudo-code program and the bpf_dbg\n     * tool from the kernel tools/bpf directory.\n     *\n     * NOTE: not using scmp_rule_add_exact as that was not doing anything\n     * at all (presumably due to having all the architectures defined). */\n\n    struct scmp_arg_cmp no_tty_inject = {\n        /* We learned that existing programs make legitimate requests with all\n         * bits set in the more significant 32bit word of the 64 bit double\n         * word. While this kernel behavior remains suspect and presumably\n         * undesired it is unlikely to change for backwards compatibility\n         * reasons. As such we cannot block all requests with high-bits set.\n         *\n         * When faced with ioctl(fd, request); refuse to proceed when\n         * request&0xffffffff == TIOCSTI. This specific way to encode the\n         * filter has the following important properties:\n         *\n         * - it blocks ioctl(fd, TIOCSTI, ptr).\n         * - it also blocks ioctl(fd, (1UL<<32) | TIOCSTI, ptr).\n         * - it doesn't block ioctl(fd, (1UL<<32) | (request not equal to TIOCSTI), ptr); */\n        .arg = 1,\n        .op = SCMP_CMP_MASKED_EQ,\n        .datum_a = 0xffffffffUL,\n        .datum_b = TIOCSTI,\n    };\n    sc_err = seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EPERM), sys_ioctl_nr, 1, no_tty_inject);\n\n    /* also block use of TIOCLINUX */\n    no_tty_inject.datum_b = TIOCLINUX;\n    sc_err = seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EPERM), sys_ioctl_nr, 1, no_tty_inject);\n\n    if (sc_err < 0) {\n        showerr(\"cannot add rule preventing the use high bits in ioctl\");\n        return sc_err;\n    }\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -77,7 +77,7 @@\n      * NOTE: not using scmp_rule_add_exact as that was not doing anything\n      * at all (presumably due to having all the architectures defined). */\n \n-    const struct scmp_arg_cmp no_tty_inject = {\n+    struct scmp_arg_cmp no_tty_inject = {\n         /* We learned that existing programs make legitimate requests with all\n          * bits set in the more significant 32bit word of the 64 bit double\n          * word. While this kernel behavior remains suspect and presumably\n@@ -98,6 +98,10 @@\n     };\n     sc_err = seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EPERM), sys_ioctl_nr, 1, no_tty_inject);\n \n+    /* also block use of TIOCLINUX */\n+    no_tty_inject.datum_b = TIOCLINUX;\n+    sc_err = seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EPERM), sys_ioctl_nr, 1, no_tty_inject);\n+\n     if (sc_err < 0) {\n         showerr(\"cannot add rule preventing the use high bits in ioctl\");\n         return sc_err;",
        "diff_line_info": {
            "deleted_lines": [
                "    const struct scmp_arg_cmp no_tty_inject = {"
            ],
            "added_lines": [
                "    struct scmp_arg_cmp no_tty_inject = {",
                "    /* also block use of TIOCLINUX */",
                "    no_tty_inject.datum_b = TIOCLINUX;",
                "    sc_err = seccomp_rule_add(ctx, SCMP_ACT_ERRNO(EPERM), sys_ioctl_nr, 1, no_tty_inject);",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2020-14928",
        "func_name": "GNOME/evolution-data-server/connect_to_server",
        "description": "evolution-data-server (eds) through 3.36.3 has a STARTTLS buffering issue that affects SMTP and POP3. When a server sends a \"begin TLS\" response, eds reads additional data and evaluates it in a TLS context, aka \"response injection.\"",
        "git_url": "https://github.com/GNOME/evolution-data-server/commit/ba82be72cfd427b5d72ff21f929b3a6d8529c4df",
        "commit_title": "I#226 - CVE-2020-14928: Response Injection via STARTTLS in SMTP and POP3",
        "commit_text": " Closes https://gitlab.gnome.org/GNOME/evolution-data-server/-/issues/226",
        "func_before": "static gboolean\nconnect_to_server (CamelService *service,\n                   GCancellable *cancellable,\n                   GError **error)\n{\n\tCamelPOP3Store *store = CAMEL_POP3_STORE (service);\n\tCamelNetworkSettings *network_settings;\n\tCamelNetworkSecurityMethod method;\n\tCamelSettings *settings;\n\tCamelStream *stream = NULL;\n\tCamelPOP3Engine *pop3_engine = NULL;\n\tCamelPOP3Command *pc;\n\tGIOStream *base_stream;\n\tGIOStream *tls_stream;\n\tgboolean disable_extensions;\n\tgboolean success = TRUE;\n\tgchar *host;\n\tguint32 flags = 0;\n\tgint ret;\n\tGError *local_error = NULL;\n\n\tsettings = camel_service_ref_settings (service);\n\n\tnetwork_settings = CAMEL_NETWORK_SETTINGS (settings);\n\thost = camel_network_settings_dup_host (network_settings);\n\tmethod = camel_network_settings_get_security_method (network_settings);\n\n\tdisable_extensions = camel_pop3_settings_get_disable_extensions (\n\t\tCAMEL_POP3_SETTINGS (settings));\n\n\tg_object_unref (settings);\n\n\tbase_stream = camel_network_service_connect_sync (\n\t\tCAMEL_NETWORK_SERVICE (service), cancellable, error);\n\n\tif (base_stream != NULL) {\n\t\tstream = camel_stream_new (base_stream);\n\t\tg_object_unref (base_stream);\n\t} else {\n\t\tsuccess = FALSE;\n\t\tgoto exit;\n\t}\n\n\t/* parent class connect initialization */\n\tif (CAMEL_SERVICE_CLASS (camel_pop3_store_parent_class)->\n\t\tconnect_sync (service, cancellable, error) == FALSE) {\n\t\tg_object_unref (stream);\n\t\tsuccess = FALSE;\n\t\tgoto exit;\n\t}\n\n\tif (disable_extensions)\n\t\tflags |= CAMEL_POP3_ENGINE_DISABLE_EXTENSIONS;\n\n\tif (!(pop3_engine = camel_pop3_engine_new (stream, flags, cancellable, &local_error)) ||\n\t    local_error != NULL) {\n\t\tif (local_error)\n\t\t\tg_propagate_error (error, local_error);\n\t\telse\n\t\t\tg_set_error (\n\t\t\t\terror, CAMEL_ERROR, CAMEL_ERROR_GENERIC,\n\t\t\t\t_(\"Failed to read a valid greeting from POP server %s\"),\n\t\t\t\thost);\n\t\tg_object_unref (stream);\n\t\tsuccess = FALSE;\n\t\tgoto exit;\n\t}\n\n\tif (method != CAMEL_NETWORK_SECURITY_METHOD_STARTTLS_ON_STANDARD_PORT) {\n\t\tg_object_unref (stream);\n\t\tgoto exit;\n\t}\n\n\tif (!(pop3_engine->capa & CAMEL_POP3_CAP_STLS)) {\n\t\tg_set_error (\n\t\t\terror, CAMEL_ERROR, CAMEL_ERROR_GENERIC,\n\t\t\t_(\"Failed to connect to POP server %s in secure mode: %s\"),\n\t\t\thost, _(\"STLS not supported by server\"));\n\t\tgoto stls_exception;\n\t}\n\n\tpc = camel_pop3_engine_command_new (\n\t\tpop3_engine, 0, NULL, NULL,\n\t\tcancellable, error, \"STLS\\r\\n\");\n\twhile (camel_pop3_engine_iterate (pop3_engine, NULL, cancellable, NULL) > 0)\n\t\t;\n\n\tret = pc->state == CAMEL_POP3_COMMAND_OK;\n\tcamel_pop3_engine_command_free (pop3_engine, pc);\n\n\tif (ret == FALSE) {\n\t\tgchar *tmp;\n\n\t\ttmp = get_valid_utf8_error ((gchar *) pop3_engine->line);\n\t\tg_set_error (\n\t\t\terror, CAMEL_ERROR, CAMEL_ERROR_GENERIC,\n\t\t\t/* Translators: Last %s is an optional\n\t\t\t * explanation beginning with \": \" separator. */\n\t\t\t_(\"Failed to connect to POP server %s in secure mode%s\"),\n\t\t\thost, (tmp != NULL) ? tmp : \"\");\n\t\tg_free (tmp);\n\t\tgoto stls_exception;\n\t}\n\n\t/* Okay, now toggle SSL/TLS mode */\n\tbase_stream = camel_stream_ref_base_stream (stream);\n\ttls_stream = camel_network_service_starttls (\n\t\tCAMEL_NETWORK_SERVICE (service), base_stream, error);\n\tg_object_unref (base_stream);\n\n\tif (tls_stream != NULL) {\n\t\tcamel_stream_set_base_stream (stream, tls_stream);\n\t\tg_object_unref (tls_stream);\n\t} else {\n\t\tg_prefix_error (\n\t\t\terror,\n\t\t\t_(\"Failed to connect to POP server %s in secure mode: \"),\n\t\t\thost);\n\t\tgoto stls_exception;\n\t}\n\n\tg_clear_object (&stream);\n\n\t/* rfc2595, section 4 states that after a successful STLS\n\t * command, the client MUST discard prior CAPA responses */\n\tif (!camel_pop3_engine_reget_capabilities (pop3_engine, cancellable, error))\n\t\tgoto exception;\n\n\tgoto exit;\n\nstls_exception:\n\t/* As soon as we send a STLS command, all hope\n\t * is lost of a clean QUIT if problems arise. */\n\t/* if (clean_quit) {\n\t\t/ * try to disconnect cleanly * /\n\t\tpc = camel_pop3_engine_command_new (\n\t\t\tpop3_engine, 0, NULL, NULL,\n\t\t\tcancellable, NULL, \"QUIT\\r\\n\");\n\t\twhile (camel_pop3_engine_iterate (pop3_engine, NULL, cancellable, NULL) > 0)\n\t\t\t;\n\t\tcamel_pop3_engine_command_free (pop3_engine, pc);\n\t}*/\n\nexception:\n\tg_clear_object (&stream);\n\tg_clear_object (&pop3_engine);\n\n\tsuccess = FALSE;\n\nexit:\n\tg_free (host);\n\n\tg_mutex_lock (&store->priv->property_lock);\n\tif (pop3_engine != NULL)\n\t\tstore->priv->engine = g_object_ref (pop3_engine);\n\tg_mutex_unlock (&store->priv->property_lock);\n\n\tg_clear_object (&pop3_engine);\n\n\treturn success;\n}",
        "func": "static gboolean\nconnect_to_server (CamelService *service,\n                   GCancellable *cancellable,\n                   GError **error)\n{\n\tCamelPOP3Store *store = CAMEL_POP3_STORE (service);\n\tCamelNetworkSettings *network_settings;\n\tCamelNetworkSecurityMethod method;\n\tCamelSettings *settings;\n\tCamelStream *stream = NULL;\n\tCamelPOP3Engine *pop3_engine = NULL;\n\tCamelPOP3Command *pc;\n\tGIOStream *base_stream;\n\tGIOStream *tls_stream;\n\tgboolean disable_extensions;\n\tgboolean success = TRUE;\n\tgchar *host;\n\tguint32 flags = 0;\n\tgint ret;\n\tGError *local_error = NULL;\n\n\tsettings = camel_service_ref_settings (service);\n\n\tnetwork_settings = CAMEL_NETWORK_SETTINGS (settings);\n\thost = camel_network_settings_dup_host (network_settings);\n\tmethod = camel_network_settings_get_security_method (network_settings);\n\n\tdisable_extensions = camel_pop3_settings_get_disable_extensions (\n\t\tCAMEL_POP3_SETTINGS (settings));\n\n\tg_object_unref (settings);\n\n\tbase_stream = camel_network_service_connect_sync (\n\t\tCAMEL_NETWORK_SERVICE (service), cancellable, error);\n\n\tif (base_stream != NULL) {\n\t\tstream = camel_stream_new (base_stream);\n\t\tg_object_unref (base_stream);\n\t} else {\n\t\tsuccess = FALSE;\n\t\tgoto exit;\n\t}\n\n\t/* parent class connect initialization */\n\tif (CAMEL_SERVICE_CLASS (camel_pop3_store_parent_class)->\n\t\tconnect_sync (service, cancellable, error) == FALSE) {\n\t\tg_object_unref (stream);\n\t\tsuccess = FALSE;\n\t\tgoto exit;\n\t}\n\n\tif (disable_extensions)\n\t\tflags |= CAMEL_POP3_ENGINE_DISABLE_EXTENSIONS;\n\n\tif (!(pop3_engine = camel_pop3_engine_new (stream, flags, cancellable, &local_error)) ||\n\t    local_error != NULL) {\n\t\tif (local_error)\n\t\t\tg_propagate_error (error, local_error);\n\t\telse\n\t\t\tg_set_error (\n\t\t\t\terror, CAMEL_ERROR, CAMEL_ERROR_GENERIC,\n\t\t\t\t_(\"Failed to read a valid greeting from POP server %s\"),\n\t\t\t\thost);\n\t\tg_object_unref (stream);\n\t\tsuccess = FALSE;\n\t\tgoto exit;\n\t}\n\n\tif (method != CAMEL_NETWORK_SECURITY_METHOD_STARTTLS_ON_STANDARD_PORT) {\n\t\tg_object_unref (stream);\n\t\tgoto exit;\n\t}\n\n\tif (!(pop3_engine->capa & CAMEL_POP3_CAP_STLS)) {\n\t\tg_set_error (\n\t\t\terror, CAMEL_ERROR, CAMEL_ERROR_GENERIC,\n\t\t\t_(\"Failed to connect to POP server %s in secure mode: %s\"),\n\t\t\thost, _(\"STLS not supported by server\"));\n\t\tgoto stls_exception;\n\t}\n\n\tpc = camel_pop3_engine_command_new (\n\t\tpop3_engine, 0, NULL, NULL,\n\t\tcancellable, error, \"STLS\\r\\n\");\n\twhile (camel_pop3_engine_iterate (pop3_engine, NULL, cancellable, NULL) > 0)\n\t\t;\n\n\tret = pc->state == CAMEL_POP3_COMMAND_OK;\n\tcamel_pop3_engine_command_free (pop3_engine, pc);\n\n\tif (ret == FALSE) {\n\t\tgchar *tmp;\n\n\t\ttmp = get_valid_utf8_error ((gchar *) pop3_engine->line);\n\t\tg_set_error (\n\t\t\terror, CAMEL_ERROR, CAMEL_ERROR_GENERIC,\n\t\t\t/* Translators: Last %s is an optional\n\t\t\t * explanation beginning with \": \" separator. */\n\t\t\t_(\"Failed to connect to POP server %s in secure mode%s\"),\n\t\t\thost, (tmp != NULL) ? tmp : \"\");\n\t\tg_free (tmp);\n\t\tgoto stls_exception;\n\t}\n\n\t/* Okay, now toggle SSL/TLS mode */\n\tbase_stream = camel_stream_ref_base_stream (stream);\n\ttls_stream = camel_network_service_starttls (\n\t\tCAMEL_NETWORK_SERVICE (service), base_stream, error);\n\tg_object_unref (base_stream);\n\n\tif (tls_stream != NULL) {\n\t\tcamel_stream_set_base_stream (stream, tls_stream);\n\t\t/* Truncate any left cached input from the insecure part of the session */\n\t\tcamel_pop3_stream_truncate (pop3_engine->stream);\n\t\tg_object_unref (tls_stream);\n\t} else {\n\t\tg_prefix_error (\n\t\t\terror,\n\t\t\t_(\"Failed to connect to POP server %s in secure mode: \"),\n\t\t\thost);\n\t\tgoto stls_exception;\n\t}\n\n\tg_clear_object (&stream);\n\n\t/* rfc2595, section 4 states that after a successful STLS\n\t * command, the client MUST discard prior CAPA responses */\n\tif (!camel_pop3_engine_reget_capabilities (pop3_engine, cancellable, error))\n\t\tgoto exception;\n\n\tgoto exit;\n\nstls_exception:\n\t/* As soon as we send a STLS command, all hope\n\t * is lost of a clean QUIT if problems arise. */\n\t/* if (clean_quit) {\n\t\t/ * try to disconnect cleanly * /\n\t\tpc = camel_pop3_engine_command_new (\n\t\t\tpop3_engine, 0, NULL, NULL,\n\t\t\tcancellable, NULL, \"QUIT\\r\\n\");\n\t\twhile (camel_pop3_engine_iterate (pop3_engine, NULL, cancellable, NULL) > 0)\n\t\t\t;\n\t\tcamel_pop3_engine_command_free (pop3_engine, pc);\n\t}*/\n\nexception:\n\tg_clear_object (&stream);\n\tg_clear_object (&pop3_engine);\n\n\tsuccess = FALSE;\n\nexit:\n\tg_free (host);\n\n\tg_mutex_lock (&store->priv->property_lock);\n\tif (pop3_engine != NULL)\n\t\tstore->priv->engine = g_object_ref (pop3_engine);\n\tg_mutex_unlock (&store->priv->property_lock);\n\n\tg_clear_object (&pop3_engine);\n\n\treturn success;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -110,6 +110,8 @@\n \n \tif (tls_stream != NULL) {\n \t\tcamel_stream_set_base_stream (stream, tls_stream);\n+\t\t/* Truncate any left cached input from the insecure part of the session */\n+\t\tcamel_pop3_stream_truncate (pop3_engine->stream);\n \t\tg_object_unref (tls_stream);\n \t} else {\n \t\tg_prefix_error (",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\t/* Truncate any left cached input from the insecure part of the session */",
                "\t\tcamel_pop3_stream_truncate (pop3_engine->stream);"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-14928",
        "func_name": "GNOME/evolution-data-server/connect_to_server",
        "description": "evolution-data-server (eds) through 3.36.3 has a STARTTLS buffering issue that affects SMTP and POP3. When a server sends a \"begin TLS\" response, eds reads additional data and evaluates it in a TLS context, aka \"response injection.\"",
        "git_url": "https://github.com/GNOME/evolution-data-server/commit/ba82be72cfd427b5d72ff21f929b3a6d8529c4df",
        "commit_title": "I#226 - CVE-2020-14928: Response Injection via STARTTLS in SMTP and POP3",
        "commit_text": " Closes https://gitlab.gnome.org/GNOME/evolution-data-server/-/issues/226",
        "func_before": "static gboolean\nconnect_to_server (CamelService *service,\n                   GCancellable *cancellable,\n                   GError **error)\n{\n\tCamelSmtpTransport *transport = CAMEL_SMTP_TRANSPORT (service);\n\tCamelNetworkSettings *network_settings;\n\tCamelNetworkSecurityMethod method;\n\tCamelSettings *settings;\n\tCamelStream *stream, *ostream = NULL;\n\tCamelStreamBuffer *istream = NULL;\n\tGIOStream *base_stream;\n\tGIOStream *tls_stream;\n\tgchar *respbuf = NULL;\n\tgboolean success = TRUE;\n\tgboolean ignore_8bitmime;\n\tgchar *host;\n\n\tif (!CAMEL_SERVICE_CLASS (camel_smtp_transport_parent_class)->\n\t\tconnect_sync (service, cancellable, error))\n\t\treturn FALSE;\n\n\t/* set some smtp transport defaults */\n\ttransport->flags = 0;\n\ttransport->authtypes = NULL;\n\n\tsettings = camel_service_ref_settings (service);\n\n\tnetwork_settings = CAMEL_NETWORK_SETTINGS (settings);\n\thost = camel_network_settings_dup_host (network_settings);\n\tmethod = camel_network_settings_get_security_method (network_settings);\n\n\tg_object_unref (settings);\n\n\tbase_stream = camel_network_service_connect_sync (\n\t\tCAMEL_NETWORK_SERVICE (service), cancellable, error);\n\n\tif (base_stream != NULL) {\n\t\t/* get the localaddr - needed later by smtp_helo */\n\t\ttransport->local_address =\n\t\t\tg_socket_connection_get_local_address (\n\t\t\tG_SOCKET_CONNECTION (base_stream), NULL);\n\n\t\tstream = camel_stream_new (base_stream);\n\t\tg_object_unref (base_stream);\n\t} else {\n\t\tsuccess = FALSE;\n\t\tgoto exit;\n\t}\n\n\ttransport->connected = TRUE;\n\n\tg_mutex_lock (&transport->stream_lock);\n\n\ttransport->ostream = stream;\n\ttransport->istream = CAMEL_STREAM_BUFFER (camel_stream_buffer_new (\n\t\tstream, CAMEL_STREAM_BUFFER_READ));\n\n\tistream = g_object_ref (transport->istream);\n\tostream = g_object_ref (transport->ostream);\n\n\tg_mutex_unlock (&transport->stream_lock);\n\n\t/* Read the greeting, note whether the server is ESMTP or not. */\n\tdo {\n\t\t/* Check for \"220\" */\n\t\tg_free (respbuf);\n\t\trespbuf = camel_stream_buffer_read_line (istream, cancellable, error);\n\t\td (fprintf (stderr, \"[SMTP] received: %s\\n\", respbuf ? respbuf : \"(null)\"));\n\t\tif (respbuf == NULL) {\n\t\t\tg_prefix_error (error, _(\"Welcome response error: \"));\n\t\t\ttransport->connected = FALSE;\n\t\t\tsuccess = FALSE;\n\t\t\tgoto exit;\n\t\t}\n\t\tif (strncmp (respbuf, \"220\", 3)) {\n\t\t\tsmtp_set_error (transport, istream, respbuf, cancellable, error);\n\t\t\tg_prefix_error (error, _(\"Welcome response error: \"));\n\t\t\tg_free (respbuf);\n\t\t\tsuccess = FALSE;\n\t\t\tgoto exit;\n\t\t}\n\t} while (*(respbuf+3) == '-'); /* if we got \"220-\" then loop again */\n\tg_free (respbuf);\n\n\tignore_8bitmime = host && camel_strstrcase (host, \"yahoo.com\");\n\n\t/* Try sending EHLO */\n\ttransport->flags |= CAMEL_SMTP_TRANSPORT_IS_ESMTP;\n\tif (!smtp_helo (transport, istream, ostream, ignore_8bitmime, cancellable, error)) {\n\t\tif (!transport->connected) {\n\t\t\tsuccess = FALSE;\n\t\t\tgoto exit;\n\t\t}\n\n\t\t/* Fall back to HELO */\n\t\tg_clear_error (error);\n\t\ttransport->flags &= ~CAMEL_SMTP_TRANSPORT_IS_ESMTP;\n\n\t\tif (!smtp_helo (transport, istream, ostream, ignore_8bitmime, cancellable, error)) {\n\t\t\tsuccess = FALSE;\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\t/* Clear any EHLO/HELO exception and assume that\n\t * any SMTP errors encountered were non-fatal. */\n\tg_clear_error (error);\n\n\tif (method != CAMEL_NETWORK_SECURITY_METHOD_STARTTLS_ON_STANDARD_PORT)\n\t\tgoto exit;  /* we're done */\n\n\tif (!(transport->flags & CAMEL_SMTP_TRANSPORT_STARTTLS)) {\n\t\tg_set_error (\n\t\t\terror, CAMEL_ERROR, CAMEL_ERROR_GENERIC,\n\t\t\t_(\"Failed to connect to SMTP server %s in secure mode: %s\"),\n\t\t\thost, _(\"STARTTLS not supported\"));\n\n\t\tsuccess = FALSE;\n\t\tgoto exit;\n\t}\n\n\td (fprintf (stderr, \"[SMTP] sending: STARTTLS\\r\\n\"));\n\tif (camel_stream_write (ostream, \"STARTTLS\\r\\n\", 10, cancellable, error) == -1) {\n\t\tg_prefix_error (error, _(\"STARTTLS command failed: \"));\n\t\tsuccess = FALSE;\n\t\tgoto exit;\n\t}\n\n\trespbuf = NULL;\n\n\tdo {\n\t\t/* Check for \"220 Ready for TLS\" */\n\t\tg_free (respbuf);\n\t\trespbuf = camel_stream_buffer_read_line (istream, cancellable, error);\n\t\td (fprintf (stderr, \"[SMTP] received: %s\\n\", respbuf ? respbuf : \"(null)\"));\n\t\tif (respbuf == NULL) {\n\t\t\tg_prefix_error (error, _(\"STARTTLS command failed: \"));\n\t\t\ttransport->connected = FALSE;\n\t\t\tsuccess = FALSE;\n\t\t\tgoto exit;\n\t\t}\n\t\tif (strncmp (respbuf, \"220\", 3) != 0) {\n\t\t\tsmtp_set_error (transport, istream, respbuf, cancellable, error);\n\t\t\tg_prefix_error (error, _(\"STARTTLS command failed: \"));\n\t\t\tg_free (respbuf);\n\t\t\tsuccess = FALSE;\n\t\t\tgoto exit;\n\t\t}\n\t} while (*(respbuf+3) == '-'); /* if we got \"220-\" then loop again */\n\n\t/* Okay, now toggle SSL/TLS mode */\n\tbase_stream = camel_stream_ref_base_stream (stream);\n\ttls_stream = camel_network_service_starttls (\n\t\tCAMEL_NETWORK_SERVICE (service), base_stream, error);\n\tg_object_unref (base_stream);\n\n\tif (tls_stream != NULL) {\n\t\tcamel_stream_set_base_stream (stream, tls_stream);\n\t\tg_object_unref (tls_stream);\n\t} else {\n\t\tg_prefix_error (\n\t\t\terror,\n\t\t\t_(\"Failed to connect to SMTP server %s in secure mode: \"),\n\t\t\thost);\n\t\tsuccess = FALSE;\n\t\tgoto exit;\n\t}\n\n\t/* We are supposed to re-EHLO after a successful STARTTLS to\n\t * re-fetch any supported extensions. */\n\tif (!smtp_helo (transport, istream, ostream, ignore_8bitmime, cancellable, error)) {\n\t\tsuccess = FALSE;\n\t}\n\nexit:\n\tg_free (host);\n\n\tif (!success) {\n\t\ttransport->connected = FALSE;\n\n\t\tg_mutex_lock (&transport->stream_lock);\n\n\t\tg_clear_object (&transport->istream);\n\t\tg_clear_object (&transport->ostream);\n\n\t\tg_mutex_unlock (&transport->stream_lock);\n\t}\n\n\tg_clear_object (&istream);\n\tg_clear_object (&ostream);\n\n\treturn success;\n}",
        "func": "static gboolean\nconnect_to_server (CamelService *service,\n                   GCancellable *cancellable,\n                   GError **error)\n{\n\tCamelSmtpTransport *transport = CAMEL_SMTP_TRANSPORT (service);\n\tCamelNetworkSettings *network_settings;\n\tCamelNetworkSecurityMethod method;\n\tCamelSettings *settings;\n\tCamelStream *stream, *ostream = NULL;\n\tCamelStreamBuffer *istream = NULL;\n\tGIOStream *base_stream;\n\tGIOStream *tls_stream;\n\tgchar *respbuf = NULL;\n\tgboolean success = TRUE;\n\tgboolean ignore_8bitmime;\n\tgchar *host;\n\n\tif (!CAMEL_SERVICE_CLASS (camel_smtp_transport_parent_class)->\n\t\tconnect_sync (service, cancellable, error))\n\t\treturn FALSE;\n\n\t/* set some smtp transport defaults */\n\ttransport->flags = 0;\n\ttransport->authtypes = NULL;\n\n\tsettings = camel_service_ref_settings (service);\n\n\tnetwork_settings = CAMEL_NETWORK_SETTINGS (settings);\n\thost = camel_network_settings_dup_host (network_settings);\n\tmethod = camel_network_settings_get_security_method (network_settings);\n\n\tg_object_unref (settings);\n\n\tbase_stream = camel_network_service_connect_sync (\n\t\tCAMEL_NETWORK_SERVICE (service), cancellable, error);\n\n\tif (base_stream != NULL) {\n\t\t/* get the localaddr - needed later by smtp_helo */\n\t\ttransport->local_address =\n\t\t\tg_socket_connection_get_local_address (\n\t\t\tG_SOCKET_CONNECTION (base_stream), NULL);\n\n\t\tstream = camel_stream_new (base_stream);\n\t\tg_object_unref (base_stream);\n\t} else {\n\t\tsuccess = FALSE;\n\t\tgoto exit;\n\t}\n\n\ttransport->connected = TRUE;\n\n\tg_mutex_lock (&transport->stream_lock);\n\n\ttransport->ostream = stream;\n\ttransport->istream = CAMEL_STREAM_BUFFER (camel_stream_buffer_new (\n\t\tstream, CAMEL_STREAM_BUFFER_READ));\n\n\tistream = g_object_ref (transport->istream);\n\tostream = g_object_ref (transport->ostream);\n\n\tg_mutex_unlock (&transport->stream_lock);\n\n\t/* Read the greeting, note whether the server is ESMTP or not. */\n\tdo {\n\t\t/* Check for \"220\" */\n\t\tg_free (respbuf);\n\t\trespbuf = camel_stream_buffer_read_line (istream, cancellable, error);\n\t\td (fprintf (stderr, \"[SMTP] received: %s\\n\", respbuf ? respbuf : \"(null)\"));\n\t\tif (respbuf == NULL) {\n\t\t\tg_prefix_error (error, _(\"Welcome response error: \"));\n\t\t\ttransport->connected = FALSE;\n\t\t\tsuccess = FALSE;\n\t\t\tgoto exit;\n\t\t}\n\t\tif (strncmp (respbuf, \"220\", 3)) {\n\t\t\tsmtp_set_error (transport, istream, respbuf, cancellable, error);\n\t\t\tg_prefix_error (error, _(\"Welcome response error: \"));\n\t\t\tg_free (respbuf);\n\t\t\tsuccess = FALSE;\n\t\t\tgoto exit;\n\t\t}\n\t} while (*(respbuf+3) == '-'); /* if we got \"220-\" then loop again */\n\tg_free (respbuf);\n\n\tignore_8bitmime = host && camel_strstrcase (host, \"yahoo.com\");\n\n\t/* Try sending EHLO */\n\ttransport->flags |= CAMEL_SMTP_TRANSPORT_IS_ESMTP;\n\tif (!smtp_helo (transport, istream, ostream, ignore_8bitmime, cancellable, error)) {\n\t\tif (!transport->connected) {\n\t\t\tsuccess = FALSE;\n\t\t\tgoto exit;\n\t\t}\n\n\t\t/* Fall back to HELO */\n\t\tg_clear_error (error);\n\t\ttransport->flags &= ~CAMEL_SMTP_TRANSPORT_IS_ESMTP;\n\n\t\tif (!smtp_helo (transport, istream, ostream, ignore_8bitmime, cancellable, error)) {\n\t\t\tsuccess = FALSE;\n\t\t\tgoto exit;\n\t\t}\n\t}\n\n\t/* Clear any EHLO/HELO exception and assume that\n\t * any SMTP errors encountered were non-fatal. */\n\tg_clear_error (error);\n\n\tif (method != CAMEL_NETWORK_SECURITY_METHOD_STARTTLS_ON_STANDARD_PORT)\n\t\tgoto exit;  /* we're done */\n\n\tif (!(transport->flags & CAMEL_SMTP_TRANSPORT_STARTTLS)) {\n\t\tg_set_error (\n\t\t\terror, CAMEL_ERROR, CAMEL_ERROR_GENERIC,\n\t\t\t_(\"Failed to connect to SMTP server %s in secure mode: %s\"),\n\t\t\thost, _(\"STARTTLS not supported\"));\n\n\t\tsuccess = FALSE;\n\t\tgoto exit;\n\t}\n\n\td (fprintf (stderr, \"[SMTP] sending: STARTTLS\\r\\n\"));\n\tif (camel_stream_write (ostream, \"STARTTLS\\r\\n\", 10, cancellable, error) == -1) {\n\t\tg_prefix_error (error, _(\"STARTTLS command failed: \"));\n\t\tsuccess = FALSE;\n\t\tgoto exit;\n\t}\n\n\trespbuf = NULL;\n\n\tdo {\n\t\t/* Check for \"220 Ready for TLS\" */\n\t\tg_free (respbuf);\n\t\trespbuf = camel_stream_buffer_read_line (istream, cancellable, error);\n\t\td (fprintf (stderr, \"[SMTP] received: %s\\n\", respbuf ? respbuf : \"(null)\"));\n\t\tif (respbuf == NULL) {\n\t\t\tg_prefix_error (error, _(\"STARTTLS command failed: \"));\n\t\t\ttransport->connected = FALSE;\n\t\t\tsuccess = FALSE;\n\t\t\tgoto exit;\n\t\t}\n\t\tif (strncmp (respbuf, \"220\", 3) != 0) {\n\t\t\tsmtp_set_error (transport, istream, respbuf, cancellable, error);\n\t\t\tg_prefix_error (error, _(\"STARTTLS command failed: \"));\n\t\t\tg_free (respbuf);\n\t\t\tsuccess = FALSE;\n\t\t\tgoto exit;\n\t\t}\n\t} while (*(respbuf+3) == '-'); /* if we got \"220-\" then loop again */\n\n\t/* Okay, now toggle SSL/TLS mode */\n\tbase_stream = camel_stream_ref_base_stream (stream);\n\ttls_stream = camel_network_service_starttls (\n\t\tCAMEL_NETWORK_SERVICE (service), base_stream, error);\n\tg_object_unref (base_stream);\n\n\tif (tls_stream != NULL) {\n\t\tcamel_stream_set_base_stream (stream, tls_stream);\n\t\t/* Truncate any left cached input from the insecure part of the session */\n\t\tcamel_stream_buffer_truncate (transport->istream);\n\t\tg_object_unref (tls_stream);\n\t} else {\n\t\tg_prefix_error (\n\t\t\terror,\n\t\t\t_(\"Failed to connect to SMTP server %s in secure mode: \"),\n\t\t\thost);\n\t\tsuccess = FALSE;\n\t\tgoto exit;\n\t}\n\n\t/* We are supposed to re-EHLO after a successful STARTTLS to\n\t * re-fetch any supported extensions. */\n\tif (!smtp_helo (transport, istream, ostream, ignore_8bitmime, cancellable, error)) {\n\t\tsuccess = FALSE;\n\t}\n\nexit:\n\tg_free (host);\n\n\tif (!success) {\n\t\ttransport->connected = FALSE;\n\n\t\tg_mutex_lock (&transport->stream_lock);\n\n\t\tg_clear_object (&transport->istream);\n\t\tg_clear_object (&transport->ostream);\n\n\t\tg_mutex_unlock (&transport->stream_lock);\n\t}\n\n\tg_clear_object (&istream);\n\tg_clear_object (&ostream);\n\n\treturn success;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -157,6 +157,8 @@\n \n \tif (tls_stream != NULL) {\n \t\tcamel_stream_set_base_stream (stream, tls_stream);\n+\t\t/* Truncate any left cached input from the insecure part of the session */\n+\t\tcamel_stream_buffer_truncate (transport->istream);\n \t\tg_object_unref (tls_stream);\n \t} else {\n \t\tg_prefix_error (",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\t/* Truncate any left cached input from the insecure part of the session */",
                "\t\tcamel_stream_buffer_truncate (transport->istream);"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-15953",
        "func_name": "dinhvh/libetpan/mailpop3_stls",
        "description": "LibEtPan through 1.9.4, as used in MailCore 2 through 0.6.3 and other products, has a STARTTLS buffering issue that affects IMAP, SMTP, and POP3. When a server sends a \"begin TLS\" response, the client reads additional data (e.g., from a meddler-in-the-middle attacker) and evaluates it in a TLS context, aka \"response injection.\"",
        "git_url": "https://github.com/dinhvh/libetpan/commit/6068b0fa8310bced874b322b20ac470472c64784",
        "commit_title": "Detect extra data after STLS response and return error",
        "commit_text": "",
        "func_before": "int mailpop3_stls(mailpop3 * f)\n{\n  char command[POP3_STRING_SIZE];\n  int r;\n  char * response;\n\n  snprintf(command, POP3_STRING_SIZE, \"STLS\\r\\n\");\n  r = send_command(f, command);\n  if (r == -1)\n    return MAILPOP3_ERROR_STREAM;\n\n  response = read_line(f);\n  if (response == NULL)\n    return MAILPOP3_ERROR_STREAM;\n  r = parse_response(f, response);\n\n  if (r != RESPONSE_OK)\n    return MAILPOP3_ERROR_STLS_NOT_SUPPORTED;\n  \n  return MAILPOP3_NO_ERROR;\n}",
        "func": "int mailpop3_stls(mailpop3 * f)\n{\n  char command[POP3_STRING_SIZE];\n  int r;\n  char * response;\n\n  snprintf(command, POP3_STRING_SIZE, \"STLS\\r\\n\");\n  r = send_command(f, command);\n  if (r == -1)\n    return MAILPOP3_ERROR_STREAM;\n\n  response = read_line(f);\n  if (response == NULL)\n    return MAILPOP3_ERROR_STREAM;\n  r = parse_response(f, response);\n\n  if (r != RESPONSE_OK)\n    return MAILPOP3_ERROR_STLS_NOT_SUPPORTED;\n\n  // Detect if the server send extra data after the STLS response.\n  // This *may* be a \"response injection attack\".\n  if (f->pop3_stream->read_buffer_len != 0) {\n    // Since it is also protocol violation, exit.\n    // There is no error type for STARTTLS errors in POP3\n    return MAILPOP3_ERROR_SSL;\n  }\n  \n  return MAILPOP3_NO_ERROR;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -16,6 +16,14 @@\n \n   if (r != RESPONSE_OK)\n     return MAILPOP3_ERROR_STLS_NOT_SUPPORTED;\n+\n+  // Detect if the server send extra data after the STLS response.\n+  // This *may* be a \"response injection attack\".\n+  if (f->pop3_stream->read_buffer_len != 0) {\n+    // Since it is also protocol violation, exit.\n+    // There is no error type for STARTTLS errors in POP3\n+    return MAILPOP3_ERROR_SSL;\n+  }\n   \n   return MAILPOP3_NO_ERROR;\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "  // Detect if the server send extra data after the STLS response.",
                "  // This *may* be a \"response injection attack\".",
                "  if (f->pop3_stream->read_buffer_len != 0) {",
                "    // Since it is also protocol violation, exit.",
                "    // There is no error type for STARTTLS errors in POP3",
                "    return MAILPOP3_ERROR_SSL;",
                "  }"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-15953",
        "func_name": "dinhvh/libetpan/mailesmtp_starttls",
        "description": "LibEtPan through 1.9.4, as used in MailCore 2 through 0.6.3 and other products, has a STARTTLS buffering issue that affects IMAP, SMTP, and POP3. When a server sends a \"begin TLS\" response, the client reads additional data (e.g., from a meddler-in-the-middle attacker) and evaluates it in a TLS context, aka \"response injection.\"",
        "git_url": "https://github.com/dinhvh/libetpan/commit/874ebf7ce9d108c6c1def733f90d156b44fb6ef7",
        "commit_title": "Detect extra data after SMTP STARTTLS response and return error",
        "commit_text": "",
        "func_before": "int mailesmtp_starttls(mailsmtp * session)\n{\n  int r;\n\n  if (!(session->esmtp & MAILSMTP_ESMTP_STARTTLS))\n    return MAILSMTP_ERROR_STARTTLS_NOT_SUPPORTED;\n\n  r = send_command(session, \"STARTTLS\\r\\n\");\n  if (r == -1)\n    return MAILSMTP_ERROR_STREAM;\n  r = read_response(session);\n\n  switch (r) {\n  case 220:\n    return MAILSMTP_NO_ERROR;\n\n  case 454:\n    return MAILSMTP_ERROR_STARTTLS_TEMPORARY_FAILURE;\n\n  case 0:\n    return MAILSMTP_ERROR_STREAM;\n\n  default:\n    return MAILSMTP_ERROR_UNEXPECTED_CODE;\n  }\n}",
        "func": "int mailesmtp_starttls(mailsmtp * session)\n{\n  int r;\n\n  if (!(session->esmtp & MAILSMTP_ESMTP_STARTTLS))\n    return MAILSMTP_ERROR_STARTTLS_NOT_SUPPORTED;\n\n  r = send_command(session, \"STARTTLS\\r\\n\");\n  if (r == -1)\n    return MAILSMTP_ERROR_STREAM;\n  r = read_response(session);\n\n  // Detect if the server send extra data after the STARTTLS response.\n  // This *may* be a \"response injection attack\".\n  if (session->stream->read_buffer_len != 0) {\n    // Since it is also protocol violation, exit.\n    // There is no general error type for STARTTLS errors in SMTP\n    return MAILSMTP_ERROR_SSL;\n  }\n\n  switch (r) {\n  case 220:\n    return MAILSMTP_NO_ERROR;\n\n  case 454:\n    return MAILSMTP_ERROR_STARTTLS_TEMPORARY_FAILURE;\n\n  case 0:\n    return MAILSMTP_ERROR_STREAM;\n\n  default:\n    return MAILSMTP_ERROR_UNEXPECTED_CODE;\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -9,6 +9,14 @@\n   if (r == -1)\n     return MAILSMTP_ERROR_STREAM;\n   r = read_response(session);\n+\n+  // Detect if the server send extra data after the STARTTLS response.\n+  // This *may* be a \"response injection attack\".\n+  if (session->stream->read_buffer_len != 0) {\n+    // Since it is also protocol violation, exit.\n+    // There is no general error type for STARTTLS errors in SMTP\n+    return MAILSMTP_ERROR_SSL;\n+  }\n \n   switch (r) {\n   case 220:",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "  // Detect if the server send extra data after the STARTTLS response.",
                "  // This *may* be a \"response injection attack\".",
                "  if (session->stream->read_buffer_len != 0) {",
                "    // Since it is also protocol violation, exit.",
                "    // There is no general error type for STARTTLS errors in SMTP",
                "    return MAILSMTP_ERROR_SSL;",
                "  }"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-24275",
        "func_name": "swoole/swoole-src/php_swoole_http_response_cookie",
        "description": "A HTTP response header injection vulnerability in Swoole v4.5.2 allows attackers to execute arbitrary code via supplying a crafted URL.",
        "git_url": "https://github.com/swoole/swoole-src/commit/e3e3e89fab99efe7e8ba1645c9327c51d1bf0171",
        "commit_title": "Fixed: check cookie injection",
        "commit_text": "",
        "func_before": "static void php_swoole_http_response_cookie(INTERNAL_FUNCTION_PARAMETERS, const bool url_encode) {\n    char *name, *value = nullptr, *path = nullptr, *domain = nullptr, *samesite = nullptr;\n    zend_long expires = 0;\n    size_t name_len, value_len = 0, path_len = 0, domain_len = 0, samesite_len = 0;\n    zend_bool secure = 0, httponly = 0;\n\n    ZEND_PARSE_PARAMETERS_START(1, 8)\n    Z_PARAM_STRING(name, name_len)\n    Z_PARAM_OPTIONAL\n    Z_PARAM_STRING(value, value_len)\n    Z_PARAM_LONG(expires)\n    Z_PARAM_STRING(path, path_len)\n    Z_PARAM_STRING(domain, domain_len)\n    Z_PARAM_BOOL(secure)\n    Z_PARAM_BOOL(httponly)\n    Z_PARAM_STRING(samesite, samesite_len)\n    ZEND_PARSE_PARAMETERS_END_EX(RETURN_FALSE);\n\n    http_context *ctx = php_swoole_http_response_get_and_check_context(ZEND_THIS);\n    if (UNEXPECTED(!ctx)) {\n        RETURN_FALSE;\n    }\n\n    int cookie_size = name_len /* + value_len */ + path_len + domain_len + 100;\n    char *cookie = nullptr, *date = nullptr;\n\n    if (name_len > 0 && strpbrk(name, \"=,; \\t\\r\\n\\013\\014\") != nullptr) {\n        php_swoole_error(E_WARNING, \"Cookie names can't contain any of the following '=,; \\\\t\\\\r\\\\n\\\\013\\\\014'\");\n        RETURN_FALSE;\n    }\n    if (value_len == 0) {\n        cookie = (char *) emalloc(cookie_size);\n        date = php_swoole_format_date((char *) ZEND_STRL(\"D, d-M-Y H:i:s T\"), 1, 0);\n        snprintf(cookie, cookie_size, \"%s=deleted; expires=%s\", name, date);\n        efree(date);\n    } else {\n        if (url_encode) {\n            char *encoded_value;\n            int encoded_value_len;\n            encoded_value = php_swoole_url_encode(value, value_len, &encoded_value_len);\n            cookie_size += encoded_value_len;\n            cookie = (char *) emalloc(cookie_size);\n            snprintf(cookie, cookie_size, \"%s=%s\", name, encoded_value);\n            efree(encoded_value);\n        } else {\n            cookie_size += value_len;\n            cookie = (char *) emalloc(cookie_size);\n            snprintf(cookie, cookie_size, \"%s=%s\", name, value);\n        }\n        if (expires > 0) {\n            strlcat(cookie, \"; expires=\", cookie_size);\n            date = php_swoole_format_date((char *) ZEND_STRL(\"D, d-M-Y H:i:s T\"), expires, 0);\n            const char *p = (const char *) zend_memrchr(date, '-', strlen(date));\n            if (!p || *(p + 5) != ' ') {\n                php_swoole_error(E_WARNING, \"Expiry date can't be a year greater than 9999\");\n                efree(date);\n                efree(cookie);\n                RETURN_FALSE;\n            }\n            strlcat(cookie, date, cookie_size);\n            efree(date);\n        }\n    }\n    if (path_len > 0) {\n        strlcat(cookie, \"; path=\", cookie_size);\n        strlcat(cookie, path, cookie_size);\n    }\n    if (domain_len > 0) {\n        strlcat(cookie, \"; domain=\", cookie_size);\n        strlcat(cookie, domain, cookie_size);\n    }\n    if (secure) {\n        strlcat(cookie, \"; secure\", cookie_size);\n    }\n    if (httponly) {\n        strlcat(cookie, \"; httponly\", cookie_size);\n    }\n    if (samesite_len > 0) {\n        strlcat(cookie, \"; samesite=\", cookie_size);\n        strlcat(cookie, samesite, cookie_size);\n    }\n    add_next_index_stringl(\n        swoole_http_init_and_read_property(\n            swoole_http_response_ce, ctx->response.zobject, &ctx->response.zcookie, ZEND_STRL(\"cookie\")),\n        cookie,\n        strlen(cookie));\n    efree(cookie);\n    RETURN_TRUE;\n}",
        "func": "static void php_swoole_http_response_cookie(INTERNAL_FUNCTION_PARAMETERS, const bool url_encode) {\n    char *name, *value = nullptr, *path = nullptr, *domain = nullptr, *samesite = nullptr;\n    zend_long expires = 0;\n    size_t name_len, value_len = 0, path_len = 0, domain_len = 0, samesite_len = 0;\n    zend_bool secure = 0, httponly = 0;\n\n    ZEND_PARSE_PARAMETERS_START(1, 8)\n    Z_PARAM_STRING(name, name_len)\n    Z_PARAM_OPTIONAL\n    Z_PARAM_STRING(value, value_len)\n    Z_PARAM_LONG(expires)\n    Z_PARAM_STRING(path, path_len)\n    Z_PARAM_STRING(domain, domain_len)\n    Z_PARAM_BOOL(secure)\n    Z_PARAM_BOOL(httponly)\n    Z_PARAM_STRING(samesite, samesite_len)\n    ZEND_PARSE_PARAMETERS_END_EX(RETURN_FALSE);\n\n    http_context *ctx = php_swoole_http_response_get_and_check_context(ZEND_THIS);\n    if (UNEXPECTED(!ctx)) {\n        RETURN_FALSE;\n    }\n\n    int cookie_size = name_len /* + value_len */ + path_len + domain_len + 100;\n    char *cookie = nullptr, *date = nullptr;\n\n    if (name_len > 0 && strpbrk(name, \"=,; \\t\\r\\n\\013\\014\") != nullptr) {\n        php_swoole_error(E_WARNING, \"Cookie names can't contain any of the following '=,; \\\\t\\\\r\\\\n\\\\013\\\\014'\");\n        RETURN_FALSE;\n    }\n\n    if (http_has_crlf(value, value_len)) {\n        RETURN_FALSE;\n    }\n\n    if (value_len == 0) {\n        cookie = (char *) emalloc(cookie_size);\n        date = php_swoole_format_date((char *) ZEND_STRL(\"D, d-M-Y H:i:s T\"), 1, 0);\n        snprintf(cookie, cookie_size, \"%s=deleted; expires=%s\", name, date);\n        efree(date);\n    } else {\n        if (url_encode) {\n            char *encoded_value;\n            int encoded_value_len;\n            encoded_value = php_swoole_url_encode(value, value_len, &encoded_value_len);\n            cookie_size += encoded_value_len;\n            cookie = (char *) emalloc(cookie_size);\n            snprintf(cookie, cookie_size, \"%s=%s\", name, encoded_value);\n            efree(encoded_value);\n        } else {\n            cookie_size += value_len;\n            cookie = (char *) emalloc(cookie_size);\n            snprintf(cookie, cookie_size, \"%s=%s\", name, value);\n        }\n        if (expires > 0) {\n            strlcat(cookie, \"; expires=\", cookie_size);\n            date = php_swoole_format_date((char *) ZEND_STRL(\"D, d-M-Y H:i:s T\"), expires, 0);\n            const char *p = (const char *) zend_memrchr(date, '-', strlen(date));\n            if (!p || *(p + 5) != ' ') {\n                php_swoole_error(E_WARNING, \"Expiry date can't be a year greater than 9999\");\n                efree(date);\n                efree(cookie);\n                RETURN_FALSE;\n            }\n            strlcat(cookie, date, cookie_size);\n            efree(date);\n        }\n    }\n    if (path_len > 0) {\n        strlcat(cookie, \"; path=\", cookie_size);\n        strlcat(cookie, path, cookie_size);\n    }\n    if (domain_len > 0) {\n        strlcat(cookie, \"; domain=\", cookie_size);\n        strlcat(cookie, domain, cookie_size);\n    }\n    if (secure) {\n        strlcat(cookie, \"; secure\", cookie_size);\n    }\n    if (httponly) {\n        strlcat(cookie, \"; httponly\", cookie_size);\n    }\n    if (samesite_len > 0) {\n        strlcat(cookie, \"; samesite=\", cookie_size);\n        strlcat(cookie, samesite, cookie_size);\n    }\n    add_next_index_stringl(\n        swoole_http_init_and_read_property(\n            swoole_http_response_ce, ctx->response.zobject, &ctx->response.zcookie, ZEND_STRL(\"cookie\")),\n        cookie,\n        strlen(cookie));\n    efree(cookie);\n    RETURN_TRUE;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -28,6 +28,11 @@\n         php_swoole_error(E_WARNING, \"Cookie names can't contain any of the following '=,; \\\\t\\\\r\\\\n\\\\013\\\\014'\");\n         RETURN_FALSE;\n     }\n+\n+    if (http_has_crlf(value, value_len)) {\n+        RETURN_FALSE;\n+    }\n+\n     if (value_len == 0) {\n         cookie = (char *) emalloc(cookie_size);\n         date = php_swoole_format_date((char *) ZEND_STRL(\"D, d-M-Y H:i:s T\"), 1, 0);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "    if (http_has_crlf(value, value_len)) {",
                "        RETURN_FALSE;",
                "    }",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2020-24275",
        "func_name": "swoole/swoole-src/swoole_http_response_set_header",
        "description": "A HTTP response header injection vulnerability in Swoole v4.5.2 allows attackers to execute arbitrary code via supplying a crafted URL.",
        "git_url": "https://github.com/swoole/swoole-src/commit/e3e3e89fab99efe7e8ba1645c9327c51d1bf0171",
        "commit_title": "Fixed: check cookie injection",
        "commit_text": "",
        "func_before": "bool swoole_http_response_set_header(\n    http_context *ctx, const char *k, size_t klen, const char *v, size_t vlen, bool ucwords) {\n    if (UNEXPECTED(klen > SW_HTTP_HEADER_KEY_SIZE - 1)) {\n        php_swoole_error(E_WARNING, \"header key is too long\");\n        return false;\n    }\n\n    /* new line/NUL character safety check */\n    for (uint32_t i = 0; i < vlen; i++) {\n        /* RFC 7230 ch. 3.2.4 deprecates folding support */\n        if (v[i] == '\\n' || v[i] == '\\r') {\n            php_swoole_error(E_WARNING, \"Header may not contain more than a single header, new line detected\");\n            return false;\n        }\n        if (v[i] == '\\0') {\n            php_swoole_error(E_WARNING, \"Header may not contain NUL bytes\");\n            return false;\n        }\n    }\n\n    zval *zheader = swoole_http_init_and_read_property(\n        swoole_http_response_ce, ctx->response.zobject, &ctx->response.zheader, ZEND_STRL(\"header\"));\n    if (ucwords) {\n        char key_buf[SW_HTTP_HEADER_KEY_SIZE];\n        strncpy(key_buf, k, klen)[klen] = '\\0';\n#ifdef SW_USE_HTTP2\n        if (ctx->http2) {\n            swoole_strtolower(key_buf, klen);\n        } else\n#endif\n        {\n            http_header_key_format(key_buf, klen);\n        }\n        if (UNEXPECTED(!v)) {\n            add_assoc_null_ex(zheader, key_buf, klen);\n        } else {\n            add_assoc_stringl_ex(zheader, key_buf, klen, (char *) v, vlen);\n        }\n    } else {\n        if (UNEXPECTED(!v)) {\n            add_assoc_null_ex(zheader, k, klen);\n        } else {\n            add_assoc_stringl_ex(zheader, k, klen, (char *) v, vlen);\n        }\n    }\n    return true;\n}",
        "func": "bool swoole_http_response_set_header(\n    http_context *ctx, const char *k, size_t klen, const char *v, size_t vlen, bool ucwords) {\n    if (UNEXPECTED(klen > SW_HTTP_HEADER_KEY_SIZE - 1)) {\n        php_swoole_error(E_WARNING, \"header key is too long\");\n        return false;\n    }\n\n    if (http_has_crlf(v, vlen)) {\n        return false;\n    }\n\n    zval *zheader = swoole_http_init_and_read_property(\n        swoole_http_response_ce, ctx->response.zobject, &ctx->response.zheader, ZEND_STRL(\"header\"));\n    if (ucwords) {\n        char key_buf[SW_HTTP_HEADER_KEY_SIZE];\n        strncpy(key_buf, k, klen)[klen] = '\\0';\n#ifdef SW_USE_HTTP2\n        if (ctx->http2) {\n            swoole_strtolower(key_buf, klen);\n        } else\n#endif\n        {\n            http_header_key_format(key_buf, klen);\n        }\n        if (UNEXPECTED(!v)) {\n            add_assoc_null_ex(zheader, key_buf, klen);\n        } else {\n            add_assoc_stringl_ex(zheader, key_buf, klen, (char *) v, vlen);\n        }\n    } else {\n        if (UNEXPECTED(!v)) {\n            add_assoc_null_ex(zheader, k, klen);\n        } else {\n            add_assoc_stringl_ex(zheader, k, klen, (char *) v, vlen);\n        }\n    }\n    return true;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,17 +5,8 @@\n         return false;\n     }\n \n-    /* new line/NUL character safety check */\n-    for (uint32_t i = 0; i < vlen; i++) {\n-        /* RFC 7230 ch. 3.2.4 deprecates folding support */\n-        if (v[i] == '\\n' || v[i] == '\\r') {\n-            php_swoole_error(E_WARNING, \"Header may not contain more than a single header, new line detected\");\n-            return false;\n-        }\n-        if (v[i] == '\\0') {\n-            php_swoole_error(E_WARNING, \"Header may not contain NUL bytes\");\n-            return false;\n-        }\n+    if (http_has_crlf(v, vlen)) {\n+        return false;\n     }\n \n     zval *zheader = swoole_http_init_and_read_property(",
        "diff_line_info": {
            "deleted_lines": [
                "    /* new line/NUL character safety check */",
                "    for (uint32_t i = 0; i < vlen; i++) {",
                "        /* RFC 7230 ch. 3.2.4 deprecates folding support */",
                "        if (v[i] == '\\n' || v[i] == '\\r') {",
                "            php_swoole_error(E_WARNING, \"Header may not contain more than a single header, new line detected\");",
                "            return false;",
                "        }",
                "        if (v[i] == '\\0') {",
                "            php_swoole_error(E_WARNING, \"Header may not contain NUL bytes\");",
                "            return false;",
                "        }"
            ],
            "added_lines": [
                "    if (http_has_crlf(v, vlen)) {",
                "        return false;"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-24275",
        "func_name": "swoole/swoole-src/swoole_http_response_set_header",
        "description": "A HTTP response header injection vulnerability in Swoole v4.5.2 allows attackers to execute arbitrary code via supplying a crafted URL.",
        "git_url": "https://github.com/swoole/swoole-src/commit/fa8e98ba326749b66b09ee2195c05c872907a08f",
        "commit_title": "fix: fix header inject when use CRLF",
        "commit_text": "",
        "func_before": "bool swoole_http_response_set_header(\n    http_context *ctx, const char *k, size_t klen, const char *v, size_t vlen, bool ucwords) {\n    if (UNEXPECTED(klen > SW_HTTP_HEADER_KEY_SIZE - 1)) {\n        php_swoole_error(E_WARNING, \"header key is too long\");\n        return false;\n    }\n    zval *zheader = swoole_http_init_and_read_property(\n        swoole_http_response_ce, ctx->response.zobject, &ctx->response.zheader, ZEND_STRL(\"header\"));\n    if (ucwords) {\n        char key_buf[SW_HTTP_HEADER_KEY_SIZE];\n        strncpy(key_buf, k, klen)[klen] = '\\0';\n#ifdef SW_USE_HTTP2\n        if (ctx->http2) {\n            swoole_strtolower(key_buf, klen);\n        } else\n#endif\n        {\n            http_header_key_format(key_buf, klen);\n        }\n        if (UNEXPECTED(!v)) {\n            add_assoc_null_ex(zheader, key_buf, klen);\n        } else {\n            add_assoc_stringl_ex(zheader, key_buf, klen, (char *) v, vlen);\n        }\n    } else {\n        if (UNEXPECTED(!v)) {\n            add_assoc_null_ex(zheader, k, klen);\n        } else {\n            add_assoc_stringl_ex(zheader, k, klen, (char *) v, vlen);\n        }\n    }\n    return true;\n}",
        "func": "bool swoole_http_response_set_header(\n    http_context *ctx, const char *k, size_t klen, const char *v, size_t vlen, bool ucwords) {\n    if (UNEXPECTED(klen > SW_HTTP_HEADER_KEY_SIZE - 1)) {\n        php_swoole_error(E_WARNING, \"header key is too long\");\n        return false;\n    }\n    zval *zheader = swoole_http_init_and_read_property(\n        swoole_http_response_ce, ctx->response.zobject, &ctx->response.zheader, ZEND_STRL(\"header\"));\n    if (ucwords) {\n        char key_buf[SW_HTTP_HEADER_KEY_SIZE];\n        strncpy(key_buf, k, klen)[klen] = '\\0';\n#ifdef SW_USE_HTTP2\n        if (ctx->http2) {\n            swoole_strtolower(key_buf, klen);\n        } else\n#endif\n        {\n            http_header_key_format(key_buf, klen);\n        }\n        if (UNEXPECTED(!v)) {\n            add_assoc_null_ex(zheader, key_buf, klen);\n        } else {\n            /* new line/NUL character safety check */\n            uint32_t i;\n            for (i = 0; i < vlen; i++) {\n                /* RFC 7230 ch. 3.2.4 deprecates folding support */\n                if (v[i] == '\\n' || v[i] == '\\r') {\n                    php_swoole_error(E_WARNING, \"Header may not contain more than a single header, new line detected\");\n                    return false;\n                }\n                if (v[i] == '\\0') {\n                    php_swoole_error(E_WARNING, \"Header may not contain NUL bytes\");\n                    return false;\n                }\n            }\n\n            add_assoc_stringl_ex(zheader, key_buf, klen, (char *) v, vlen);\n        }\n    } else {\n        if (UNEXPECTED(!v)) {\n            add_assoc_null_ex(zheader, k, klen);\n        } else {\n            add_assoc_stringl_ex(zheader, k, klen, (char *) v, vlen);\n        }\n    }\n    return true;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -20,6 +20,20 @@\n         if (UNEXPECTED(!v)) {\n             add_assoc_null_ex(zheader, key_buf, klen);\n         } else {\n+            /* new line/NUL character safety check */\n+            uint32_t i;\n+            for (i = 0; i < vlen; i++) {\n+                /* RFC 7230 ch. 3.2.4 deprecates folding support */\n+                if (v[i] == '\\n' || v[i] == '\\r') {\n+                    php_swoole_error(E_WARNING, \"Header may not contain more than a single header, new line detected\");\n+                    return false;\n+                }\n+                if (v[i] == '\\0') {\n+                    php_swoole_error(E_WARNING, \"Header may not contain NUL bytes\");\n+                    return false;\n+                }\n+            }\n+\n             add_assoc_stringl_ex(zheader, key_buf, klen, (char *) v, vlen);\n         }\n     } else {",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "            /* new line/NUL character safety check */",
                "            uint32_t i;",
                "            for (i = 0; i < vlen; i++) {",
                "                /* RFC 7230 ch. 3.2.4 deprecates folding support */",
                "                if (v[i] == '\\n' || v[i] == '\\r') {",
                "                    php_swoole_error(E_WARNING, \"Header may not contain more than a single header, new line detected\");",
                "                    return false;",
                "                }",
                "                if (v[i] == '\\0') {",
                "                    php_swoole_error(E_WARNING, \"Header may not contain NUL bytes\");",
                "                    return false;",
                "                }",
                "            }",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2020-24275",
        "func_name": "swoole/swoole-src/http_build_trailer",
        "description": "A HTTP response header injection vulnerability in Swoole v4.5.2 allows attackers to execute arbitrary code via supplying a crafted URL.",
        "git_url": "https://github.com/swoole/swoole-src/commit/fa8e98ba326749b66b09ee2195c05c872907a08f",
        "commit_title": "fix: fix header inject when use CRLF",
        "commit_text": "",
        "func_before": "static ssize_t http_build_trailer(http_context *ctx, swString *response) {\n    char *buf = SwooleTG.buffer_stack->str;\n    size_t l_buf = SwooleTG.buffer_stack->size;\n    int n;\n    ssize_t ret = 0;\n\n    zval *ztrailer =\n        sw_zend_read_property_ex(swoole_http_response_ce, ctx->response.zobject, SW_ZSTR_KNOWN(SW_ZEND_STR_TRAILER), 0);\n    uint32_t size = php_swoole_array_length_safe(ztrailer);\n\n    if (size > 0) {\n        const char *key;\n        uint32_t keylen;\n        int type;\n        zval *zvalue;\n\n        SW_HASHTABLE_FOREACH_START2(Z_ARRVAL_P(ztrailer), key, keylen, type, zvalue) {\n            if (UNEXPECTED(!key || ZVAL_IS_NULL(zvalue))) {\n                continue;\n            }\n            \n            if (!ZVAL_IS_NULL(zvalue)) {\n                zend::String str_value(zvalue);\n                n = sw_snprintf(\n                    buf, l_buf, \"%.*s: %.*s\\r\\n\", (int) keylen, key, (int) str_value.len(), str_value.val());\n                swString_append_ptr(response, buf, n);\n                ret += n;\n            }\n        }\n        SW_HASHTABLE_FOREACH_END();\n        (void) type;\n        swString_append_ptr(response, ZEND_STRL(\"\\r\\n\"));\n    }\n\n    return ret;\n}",
        "func": "static ssize_t http_build_trailer(http_context *ctx, swString *response) {\n    char *buf = SwooleTG.buffer_stack->str;\n    size_t l_buf = SwooleTG.buffer_stack->size;\n    int n;\n    ssize_t ret = 0;\n\n    zval *ztrailer =\n        sw_zend_read_property_ex(swoole_http_response_ce, ctx->response.zobject, SW_ZSTR_KNOWN(SW_ZEND_STR_TRAILER), 0);\n    uint32_t size = php_swoole_array_length_safe(ztrailer);\n\n    if (size > 0) {\n        const char *key;\n        uint32_t keylen;\n        int type;\n        zval *zvalue;\n\n        SW_HASHTABLE_FOREACH_START2(Z_ARRVAL_P(ztrailer), key, keylen, type, zvalue) {\n            if (UNEXPECTED(!key || ZVAL_IS_NULL(zvalue))) {\n                continue;\n            }\n\n            if (!ZVAL_IS_NULL(zvalue)) {\n                zend::String str_value(zvalue);\n                n = sw_snprintf(\n                    buf, l_buf, \"%.*s: %.*s\\r\\n\", (int) keylen, key, (int) str_value.len(), str_value.val());\n                swString_append_ptr(response, buf, n);\n                ret += n;\n            }\n        }\n        SW_HASHTABLE_FOREACH_END();\n        (void) type;\n        swString_append_ptr(response, ZEND_STRL(\"\\r\\n\"));\n    }\n\n    return ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -18,7 +18,7 @@\n             if (UNEXPECTED(!key || ZVAL_IS_NULL(zvalue))) {\n                 continue;\n             }\n-            \n+\n             if (!ZVAL_IS_NULL(zvalue)) {\n                 zend::String str_value(zvalue);\n                 n = sw_snprintf(",
        "diff_line_info": {
            "deleted_lines": [
                "            "
            ],
            "added_lines": [
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2020-24275",
        "func_name": "swoole/swoole-src/php_swoole_http_response_cookie",
        "description": "A HTTP response header injection vulnerability in Swoole v4.5.2 allows attackers to execute arbitrary code via supplying a crafted URL.",
        "git_url": "https://github.com/swoole/swoole-src/commit/9557ca2449b333ea9c09a442e4924fa857296930",
        "commit_title": "fix: don't check crlf when use cookie urlencode",
        "commit_text": "",
        "func_before": "static void php_swoole_http_response_cookie(INTERNAL_FUNCTION_PARAMETERS, const bool url_encode) {\n    char *name, *value = nullptr, *path = nullptr, *domain = nullptr, *samesite = nullptr;\n    zend_long expires = 0;\n    size_t name_len, value_len = 0, path_len = 0, domain_len = 0, samesite_len = 0;\n    zend_bool secure = 0, httponly = 0;\n\n    ZEND_PARSE_PARAMETERS_START(1, 8)\n    Z_PARAM_STRING(name, name_len)\n    Z_PARAM_OPTIONAL\n    Z_PARAM_STRING(value, value_len)\n    Z_PARAM_LONG(expires)\n    Z_PARAM_STRING(path, path_len)\n    Z_PARAM_STRING(domain, domain_len)\n    Z_PARAM_BOOL(secure)\n    Z_PARAM_BOOL(httponly)\n    Z_PARAM_STRING(samesite, samesite_len)\n    ZEND_PARSE_PARAMETERS_END_EX(RETURN_FALSE);\n\n    http_context *ctx = php_swoole_http_response_get_and_check_context(ZEND_THIS);\n    if (UNEXPECTED(!ctx)) {\n        RETURN_FALSE;\n    }\n\n    int cookie_size = name_len /* + value_len */ + path_len + domain_len + 100;\n    char *cookie = nullptr, *date = nullptr;\n\n    if (name_len > 0 && strpbrk(name, \"=,; \\t\\r\\n\\013\\014\") != nullptr) {\n        php_swoole_error(E_WARNING, \"Cookie names can't contain any of the following '=,; \\\\t\\\\r\\\\n\\\\013\\\\014'\");\n        RETURN_FALSE;\n    }\n\n    if (http_has_crlf(value, value_len)) {\n        RETURN_FALSE;\n    }\n\n    if (value_len == 0) {\n        cookie = (char *) emalloc(cookie_size);\n        date = php_swoole_format_date((char *) ZEND_STRL(\"D, d-M-Y H:i:s T\"), 1, 0);\n        snprintf(cookie, cookie_size, \"%s=deleted; expires=%s\", name, date);\n        efree(date);\n    } else {\n        if (url_encode) {\n            char *encoded_value;\n            int encoded_value_len;\n            encoded_value = php_swoole_url_encode(value, value_len, &encoded_value_len);\n            cookie_size += encoded_value_len;\n            cookie = (char *) emalloc(cookie_size);\n            snprintf(cookie, cookie_size, \"%s=%s\", name, encoded_value);\n            efree(encoded_value);\n        } else {\n            cookie_size += value_len;\n            cookie = (char *) emalloc(cookie_size);\n            snprintf(cookie, cookie_size, \"%s=%s\", name, value);\n        }\n        if (expires > 0) {\n            strlcat(cookie, \"; expires=\", cookie_size);\n            date = php_swoole_format_date((char *) ZEND_STRL(\"D, d-M-Y H:i:s T\"), expires, 0);\n            const char *p = (const char *) zend_memrchr(date, '-', strlen(date));\n            if (!p || *(p + 5) != ' ') {\n                php_swoole_error(E_WARNING, \"Expiry date can't be a year greater than 9999\");\n                efree(date);\n                efree(cookie);\n                RETURN_FALSE;\n            }\n            strlcat(cookie, date, cookie_size);\n            efree(date);\n        }\n    }\n    if (path_len > 0) {\n        strlcat(cookie, \"; path=\", cookie_size);\n        strlcat(cookie, path, cookie_size);\n    }\n    if (domain_len > 0) {\n        strlcat(cookie, \"; domain=\", cookie_size);\n        strlcat(cookie, domain, cookie_size);\n    }\n    if (secure) {\n        strlcat(cookie, \"; secure\", cookie_size);\n    }\n    if (httponly) {\n        strlcat(cookie, \"; httponly\", cookie_size);\n    }\n    if (samesite_len > 0) {\n        strlcat(cookie, \"; samesite=\", cookie_size);\n        strlcat(cookie, samesite, cookie_size);\n    }\n    add_next_index_stringl(\n        swoole_http_init_and_read_property(\n            swoole_http_response_ce, ctx->response.zobject, &ctx->response.zcookie, ZEND_STRL(\"cookie\")),\n        cookie,\n        strlen(cookie));\n    efree(cookie);\n    RETURN_TRUE;\n}",
        "func": "static void php_swoole_http_response_cookie(INTERNAL_FUNCTION_PARAMETERS, const bool url_encode) {\n    char *name, *value = nullptr, *path = nullptr, *domain = nullptr, *samesite = nullptr;\n    zend_long expires = 0;\n    size_t name_len, value_len = 0, path_len = 0, domain_len = 0, samesite_len = 0;\n    zend_bool secure = 0, httponly = 0;\n\n    ZEND_PARSE_PARAMETERS_START(1, 8)\n    Z_PARAM_STRING(name, name_len)\n    Z_PARAM_OPTIONAL\n    Z_PARAM_STRING(value, value_len)\n    Z_PARAM_LONG(expires)\n    Z_PARAM_STRING(path, path_len)\n    Z_PARAM_STRING(domain, domain_len)\n    Z_PARAM_BOOL(secure)\n    Z_PARAM_BOOL(httponly)\n    Z_PARAM_STRING(samesite, samesite_len)\n    ZEND_PARSE_PARAMETERS_END_EX(RETURN_FALSE);\n\n    http_context *ctx = php_swoole_http_response_get_and_check_context(ZEND_THIS);\n    if (UNEXPECTED(!ctx)) {\n        RETURN_FALSE;\n    }\n\n    int cookie_size = name_len /* + value_len */ + path_len + domain_len + 100;\n    char *cookie = nullptr, *date = nullptr;\n\n    if (name_len > 0 && strpbrk(name, \"=,; \\t\\r\\n\\013\\014\") != nullptr) {\n        php_swoole_error(E_WARNING, \"Cookie names can't contain any of the following '=,; \\\\t\\\\r\\\\n\\\\013\\\\014'\");\n        RETURN_FALSE;\n    }\n\n    if (!url_encode && http_has_crlf(value, value_len)) {\n        RETURN_FALSE;\n    }\n\n    if (value_len == 0) {\n        cookie = (char *) emalloc(cookie_size);\n        date = php_swoole_format_date((char *) ZEND_STRL(\"D, d-M-Y H:i:s T\"), 1, 0);\n        snprintf(cookie, cookie_size, \"%s=deleted; expires=%s\", name, date);\n        efree(date);\n    } else {\n        if (url_encode) {\n            char *encoded_value;\n            int encoded_value_len;\n            encoded_value = php_swoole_url_encode(value, value_len, &encoded_value_len);\n            cookie_size += encoded_value_len;\n            cookie = (char *) emalloc(cookie_size);\n            snprintf(cookie, cookie_size, \"%s=%s\", name, encoded_value);\n            efree(encoded_value);\n        } else {\n            cookie_size += value_len;\n            cookie = (char *) emalloc(cookie_size);\n            snprintf(cookie, cookie_size, \"%s=%s\", name, value);\n        }\n        if (expires > 0) {\n            strlcat(cookie, \"; expires=\", cookie_size);\n            date = php_swoole_format_date((char *) ZEND_STRL(\"D, d-M-Y H:i:s T\"), expires, 0);\n            const char *p = (const char *) zend_memrchr(date, '-', strlen(date));\n            if (!p || *(p + 5) != ' ') {\n                php_swoole_error(E_WARNING, \"Expiry date can't be a year greater than 9999\");\n                efree(date);\n                efree(cookie);\n                RETURN_FALSE;\n            }\n            strlcat(cookie, date, cookie_size);\n            efree(date);\n        }\n    }\n    if (path_len > 0) {\n        strlcat(cookie, \"; path=\", cookie_size);\n        strlcat(cookie, path, cookie_size);\n    }\n    if (domain_len > 0) {\n        strlcat(cookie, \"; domain=\", cookie_size);\n        strlcat(cookie, domain, cookie_size);\n    }\n    if (secure) {\n        strlcat(cookie, \"; secure\", cookie_size);\n    }\n    if (httponly) {\n        strlcat(cookie, \"; httponly\", cookie_size);\n    }\n    if (samesite_len > 0) {\n        strlcat(cookie, \"; samesite=\", cookie_size);\n        strlcat(cookie, samesite, cookie_size);\n    }\n    add_next_index_stringl(\n        swoole_http_init_and_read_property(\n            swoole_http_response_ce, ctx->response.zobject, &ctx->response.zcookie, ZEND_STRL(\"cookie\")),\n        cookie,\n        strlen(cookie));\n    efree(cookie);\n    RETURN_TRUE;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -29,7 +29,7 @@\n         RETURN_FALSE;\n     }\n \n-    if (http_has_crlf(value, value_len)) {\n+    if (!url_encode && http_has_crlf(value, value_len)) {\n         RETURN_FALSE;\n     }\n ",
        "diff_line_info": {
            "deleted_lines": [
                "    if (http_has_crlf(value, value_len)) {"
            ],
            "added_lines": [
                "    if (!url_encode && http_has_crlf(value, value_len)) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-3695",
        "func_name": "mjg59/linux/einj_error_inject",
        "description": "The einj_error_inject function in drivers/acpi/apei/einj.c in the Linux kernel allows local users to simulate hardware errors and consequently cause a denial of service by leveraging failure to disable APEI error injection through EINJ when securelevel is set.",
        "git_url": "https://github.com/mjg59/linux/commit/d7a6be58edc01b1c66ecd8fcc91236bfbce0a420",
        "commit_title": "acpi: Disable APEI error injection if securelevel is set",
        "commit_text": " ACPI provides an error injection mechanism, EINJ, for debugging and testing the ACPI Platform Error Interface (APEI) and other RAS features. If supported by the firmware, ACPI specification 5.0 and later provide for a way to specify a physical memory address to which to inject the error.  Injecting errors through EINJ can produce errors which to the platform are indistinguishable from real hardware errors. This can have undesirable side-effects, such as causing the platform to mark hardware as needing replacement.  While it does not provide a method to load unauthenticated privileged code, the effect of these errors may persist across reboots and affect trust in the underlying hardware, so disable error injection through EINJ if securelevel is set. ",
        "func_before": "static int einj_error_inject(u32 type, u32 flags, u64 param1, u64 param2,\n\t\t\t     u64 param3, u64 param4)\n{\n\tint rc;\n\tu64 base_addr, size;\n\n\t/* If user manually set \"flags\", make sure it is legal */\n\tif (flags && (flags &\n\t\t~(SETWA_FLAGS_APICID|SETWA_FLAGS_MEM|SETWA_FLAGS_PCIE_SBDF)))\n\t\treturn -EINVAL;\n\n\t/*\n\t * We need extra sanity checks for memory errors.\n\t * Other types leap directly to injection.\n\t */\n\n\t/* ensure param1/param2 existed */\n\tif (!(param_extension || acpi5))\n\t\tgoto inject;\n\n\t/* ensure injection is memory related */\n\tif (type & ACPI5_VENDOR_BIT) {\n\t\tif (vendor_flags != SETWA_FLAGS_MEM)\n\t\t\tgoto inject;\n\t} else if (!(type & MEM_ERROR_MASK) && !(flags & SETWA_FLAGS_MEM))\n\t\tgoto inject;\n\n\t/*\n\t * Disallow crazy address masks that give BIOS leeway to pick\n\t * injection address almost anywhere. Insist on page or\n\t * better granularity and that target address is normal RAM or\n\t * NVDIMM.\n\t */\n\tbase_addr = param1 & param2;\n\tsize = ~param2 + 1;\n\n\tif (((param2 & PAGE_MASK) != PAGE_MASK) ||\n\t    ((region_intersects(base_addr, size, IORESOURCE_SYSTEM_RAM, IORES_DESC_NONE)\n\t\t\t\t!= REGION_INTERSECTS) &&\n\t     (region_intersects(base_addr, size, IORESOURCE_MEM, IORES_DESC_PERSISTENT_MEMORY)\n\t\t\t\t!= REGION_INTERSECTS)))\n\t\treturn -EINVAL;\n\ninject:\n\tmutex_lock(&einj_mutex);\n\trc = __einj_error_inject(type, flags, param1, param2, param3, param4);\n\tmutex_unlock(&einj_mutex);\n\n\treturn rc;\n}",
        "func": "static int einj_error_inject(u32 type, u32 flags, u64 param1, u64 param2,\n\t\t\t     u64 param3, u64 param4)\n{\n\tint rc;\n\tu64 base_addr, size;\n\n\tif (get_securelevel() > 0)\n\t\treturn -EPERM;\n\n\t/* If user manually set \"flags\", make sure it is legal */\n\tif (flags && (flags &\n\t\t~(SETWA_FLAGS_APICID|SETWA_FLAGS_MEM|SETWA_FLAGS_PCIE_SBDF)))\n\t\treturn -EINVAL;\n\n\t/*\n\t * We need extra sanity checks for memory errors.\n\t * Other types leap directly to injection.\n\t */\n\n\t/* ensure param1/param2 existed */\n\tif (!(param_extension || acpi5))\n\t\tgoto inject;\n\n\t/* ensure injection is memory related */\n\tif (type & ACPI5_VENDOR_BIT) {\n\t\tif (vendor_flags != SETWA_FLAGS_MEM)\n\t\t\tgoto inject;\n\t} else if (!(type & MEM_ERROR_MASK) && !(flags & SETWA_FLAGS_MEM))\n\t\tgoto inject;\n\n\t/*\n\t * Disallow crazy address masks that give BIOS leeway to pick\n\t * injection address almost anywhere. Insist on page or\n\t * better granularity and that target address is normal RAM or\n\t * NVDIMM.\n\t */\n\tbase_addr = param1 & param2;\n\tsize = ~param2 + 1;\n\n\tif (((param2 & PAGE_MASK) != PAGE_MASK) ||\n\t    ((region_intersects(base_addr, size, IORESOURCE_SYSTEM_RAM, IORES_DESC_NONE)\n\t\t\t\t!= REGION_INTERSECTS) &&\n\t     (region_intersects(base_addr, size, IORESOURCE_MEM, IORES_DESC_PERSISTENT_MEMORY)\n\t\t\t\t!= REGION_INTERSECTS)))\n\t\treturn -EINVAL;\n\ninject:\n\tmutex_lock(&einj_mutex);\n\trc = __einj_error_inject(type, flags, param1, param2, param3, param4);\n\tmutex_unlock(&einj_mutex);\n\n\treturn rc;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,6 +3,9 @@\n {\n \tint rc;\n \tu64 base_addr, size;\n+\n+\tif (get_securelevel() > 0)\n+\t\treturn -EPERM;\n \n \t/* If user manually set \"flags\", make sure it is legal */\n \tif (flags && (flags &",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "\tif (get_securelevel() > 0)",
                "\t\treturn -EPERM;"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-0302",
        "func_name": "radareorg/radare2/r_str_ansi_strip",
        "description": "Failure to Sanitize Special Elements into a Different Plane (Special Element Injection) in GitHub repository radareorg/radare2 prior to 5.8.2.",
        "git_url": "https://github.com/radareorg/radare2/commit/961f0e723903011d4f54c2396e44efa91fcc74ce",
        "commit_title": "Fix ANSI Escape Sequence Injection vulns via DWARF ##vuln",
        "commit_text": " * Reported by @solid-snail via huntrdev\r * BountyID: 583133af-7ae6-4a21-beef-a4b0182cf82e\r * Reproducer: dwarf_test_func_patched",
        "func_before": "R_API size_t r_str_ansi_strip(char *str) {\n\tsize_t i = 0;\n\twhile (str[i]) {\n\t\tsize_t chlen = __str_ansi_length (str + i);\n\t\tif (chlen > 1) {\n\t\t\tr_str_cpy (str + i + 1, str + i + chlen);\n\t\t}\n\t\ti++;\n\t}\n\treturn i;\n}",
        "func": "R_API size_t r_str_ansi_strip(char *str) {\n\tsize_t i = 0;\n\twhile (str[i]) {\n\t\tsize_t chlen = __str_ansi_length (str + i);\n\t\tif (chlen > 1) {\n\t\t\tr_str_cpy (str + i, str + i + chlen);\n\t\t} else {\n\t\t\ti++;\n\t\t}\n\t}\n\treturn i;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,9 +3,10 @@\n \twhile (str[i]) {\n \t\tsize_t chlen = __str_ansi_length (str + i);\n \t\tif (chlen > 1) {\n-\t\t\tr_str_cpy (str + i + 1, str + i + chlen);\n+\t\t\tr_str_cpy (str + i, str + i + chlen);\n+\t\t} else {\n+\t\t\ti++;\n \t\t}\n-\t\ti++;\n \t}\n \treturn i;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\tr_str_cpy (str + i + 1, str + i + chlen);",
                "\t\ti++;"
            ],
            "added_lines": [
                "\t\t\tr_str_cpy (str + i, str + i + chlen);",
                "\t\t} else {",
                "\t\t\ti++;"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-0302",
        "func_name": "radareorg/radare2/cmd_meta_comment",
        "description": "Failure to Sanitize Special Elements into a Different Plane (Special Element Injection) in GitHub repository radareorg/radare2 prior to 5.8.2.",
        "git_url": "https://github.com/radareorg/radare2/commit/961f0e723903011d4f54c2396e44efa91fcc74ce",
        "commit_title": "Fix ANSI Escape Sequence Injection vulns via DWARF ##vuln",
        "commit_text": " * Reported by @solid-snail via huntrdev\r * BountyID: 583133af-7ae6-4a21-beef-a4b0182cf82e\r * Reproducer: dwarf_test_func_patched",
        "func_before": "static int cmd_meta_comment(RCore *core, const char *input) {\n\tut64 addr = core->offset;\n\tswitch (input[1]) {\n\tcase '?':\n\t\tr_core_cmd_help (core, help_msg_CC);\n\t\tbreak;\n\tcase ',': // \"CC,\"\n\t\tr_meta_print_list_all (core->anal, R_META_TYPE_COMMENT, ',', input + 2);\n\t\tbreak;\n\tcase 'F': // \"CC,\"\n\t\tif (input[2]=='?') {\n\t\t\teprintf (\"Usage: CCF [file]\\n\");\n\t\t} else if (input[2] == ' ') {\n\t\t\tconst char *fn = input + 2;\n\t\t\tconst char *comment = r_meta_get_string (core->anal, R_META_TYPE_COMMENT, addr);\n\t\t\tfn = r_str_trim_head_ro (fn);\n\t\t\tif (comment && *comment) {\n\t\t\t\t// append filename in current comment\n\t\t\t\tchar *nc = r_str_newf (\"%s ,(%s)\", comment, fn);\n\t\t\t\tr_meta_set_string (core->anal, R_META_TYPE_COMMENT, addr, nc);\n\t\t\t\tfree (nc);\n\t\t\t} else {\n\t\t\t\tchar *newcomment = r_str_newf (\",(%s)\", fn);\n\t\t\t\tr_meta_set_string (core->anal, R_META_TYPE_COMMENT, addr, newcomment);\n\t\t\t\tfree (newcomment);\n\t\t\t}\n\t\t} else {\n\t\t\tconst char *comment = r_meta_get_string (core->anal, R_META_TYPE_COMMENT, addr);\n\t\t\tif (comment && *comment) {\n\t\t\t\tchar *cmtfile = r_str_between (comment, \",(\", \")\");\n\t\t\t\tif (cmtfile && *cmtfile) {\n\t\t\t\t\tchar *cwd = getcommapath (core);\n\t\t\t\t\tr_cons_printf (\"%s\"R_SYS_DIR\"%s\\n\", cwd, cmtfile);\n\t\t\t\t\tfree (cwd);\n\t\t\t\t}\n\t\t\t\tfree (cmtfile);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase '.':\n\t\t  {\n\t\t\t  ut64 at = input[2]? r_num_math (core->num, input + 2): addr;\n\t\t\t  const char *comment = r_meta_get_string (core->anal, R_META_TYPE_COMMENT, at);\n\t\t\t  if (comment) {\n\t\t\t\t  r_cons_println (comment);\n\t\t\t  }\n\t\t  }\n\t\tbreak;\n\tcase 0: // \"CC\"\n\t\tr_meta_print_list_all (core->anal, R_META_TYPE_COMMENT, 0, NULL);\n\t\tbreak;\n\tcase 'f': // \"CCf\"\n\t\tswitch (input[2]) {\n\t\tcase '-': // \"CCf-\"\n\t\t\t{\n\t\t\t\tut64 arg = r_num_math (core->num, input + 2);\n\t\t\t\tif (!arg) {\n\t\t\t\t\targ = core->offset;\n\t\t\t\t}\n\t\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, arg, 0);\n\t\t\t\tif (fcn) {\n\t\t\t\t\tRAnalBlock *bb;\n\t\t\t\t\tRListIter *iter;\n\t\t\t\t\tr_list_foreach (fcn->bbs, iter, bb) {\n\t\t\t\t\t\tint i;\n\t\t\t\t\t\tfor (i = 0; i < bb->size; i++) {\n\t\t\t\t\t\t\tut64 addr = bb->addr + i;\n\t\t\t\t\t\t\tr_meta_del (core->anal, R_META_TYPE_COMMENT, addr, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ',': // \"CCf,\"\n\t\t\tr_meta_print_list_in_function (core->anal, R_META_TYPE_COMMENT, ',', core->offset, input + 3);\n\t\t\tbreak;\n\t\tcase 'j': // \"CCfj\"\n\t\t\tr_meta_print_list_in_function (core->anal, R_META_TYPE_COMMENT, 'j', core->offset, NULL);\n\t\t\tbreak;\n\t\tcase '*': // \"CCf*\"\n\t\t\tr_meta_print_list_in_function (core->anal, R_META_TYPE_COMMENT, 1, core->offset, NULL);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tr_meta_print_list_in_function (core->anal, R_META_TYPE_COMMENT, 0, core->offset, NULL);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 'j': // \"CCj\"\n\t\tr_meta_print_list_all (core->anal, R_META_TYPE_COMMENT, 'j', input + 2);\n\t\tbreak;\n\tcase '!':\n\t\t{\n\t\t\tchar *out;\n\t\t\tconst char *comment = r_meta_get_string (core->anal, R_META_TYPE_COMMENT, addr);\n\t\t\tout = r_core_editor (core, NULL, comment);\n\t\t\tif (out) {\n\t\t\t\t//r_meta_set (core->anal->meta, R_META_TYPE_COMMENT, addr, 0, out);\n\t\t\t\tr_core_cmdf (core, \"CC-@0x%08\"PFMT64x, addr);\n\t\t\t\t//r_meta_del (core->anal->meta, input[0], addr, addr+1);\n\t\t\t\tr_meta_set_string (core->anal,\n\t\t\t\t\t\tR_META_TYPE_COMMENT, addr, out);\n\t\t\t\tfree (out);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase '+':\n\tcase ' ':\n\t\t{\n\t\tconst char *newcomment = r_str_trim_head_ro (input + 2);\n\t\tconst char *comment = r_meta_get_string (core->anal, R_META_TYPE_COMMENT, addr);\n\t\tchar *text;\n\t\tchar *nc = strdup (newcomment);\n\t\tr_str_unescape (nc);\n\t\tif (comment) {\n\t\t\ttext = malloc (strlen (comment) + strlen (newcomment) + 2);\n\t\t\tif (text) {\n\t\t\t\tstrcpy (text, comment);\n\t\t\t\tstrcat (text, \" \");\n\t\t\t\tstrcat (text, nc);\n\t\t\t\tr_meta_set_string (core->anal, R_META_TYPE_COMMENT, addr, text);\n\t\t\t\tfree (text);\n\t\t\t} else {\n\t\t\t\tr_sys_perror (\"malloc\");\n\t\t\t}\n\t\t} else {\n\t\t\tr_meta_set_string (core->anal, R_META_TYPE_COMMENT, addr, nc);\n\t\t\tif (r_config_get_b (core->config, \"cmd.undo\")) {\n\t\t\t\tchar *a = r_str_newf (\"CC-0x%08\"PFMT64x, addr);\n\t\t\t\tchar *b = r_str_newf (\"CC %s@0x%08\"PFMT64x, nc, addr);\n\t\t\t\tRCoreUndo *uc = r_core_undo_new (core->offset, b, a);\n\t\t\t\tr_core_undo_push (core, uc);\n\t\t\t\tfree (a);\n\t\t\t\tfree (b);\n\t\t\t}\n\t\t}\n\t\tfree (nc);\n\t\t}\n\t\tbreak;\n\tcase '*': // \"CC*\"\n\t\tr_meta_print_list_all (core->anal, R_META_TYPE_COMMENT, 1, NULL);\n\t\tbreak;\n\tcase '-': // \"CC-\"\n\t\tif (input[2] == '*') { // \"CC-*\"\n\t\t\tr_meta_del (core->anal, R_META_TYPE_COMMENT, UT64_MAX, UT64_MAX);\n\t\t} else if (input[2]) { // \"CC-$$+32\"\n\t\t\tut64 arg = r_num_math (core->num, input + 2);\n\t\t\tr_meta_del (core->anal, R_META_TYPE_COMMENT, arg, 1);\n\t\t} else { // \"CC-\"\n\t\t\tr_meta_del (core->anal, R_META_TYPE_COMMENT, core->offset, 1);\n\t\t}\n\t\tbreak;\n\tcase 'u': // \"CCu\"\n\t\t//\n\t\t{\n\t\tchar *newcomment;\n\t\tconst char *arg = input + 2;\n\t\twhile (*arg && *arg == ' ') arg++;\n\t\tif (!strncmp (arg, \"base64:\", 7)) {\n\t\t\tchar *s = (char *)sdb_decode (arg + 7, NULL);\n\t\t\tif (s) {\n\t\t\t\tnewcomment = s;\n\t\t\t} else {\n\t\t\t\tnewcomment = NULL;\n\t\t\t}\n\t\t} else {\n\t\t\tnewcomment = strdup (arg);\n\t\t}\n\t\tif (newcomment) {\n\t\t\tconst char *comment = r_meta_get_string (core->anal, R_META_TYPE_COMMENT, addr);\n\t\t\tif (!comment || (comment && !strstr (comment, newcomment))) {\n\t\t\t\tr_meta_set_string (core->anal, R_META_TYPE_COMMENT, addr, newcomment);\n\t\t\t}\n\t\t\tfree (newcomment);\n\t\t}\n\t\t}\n\t\tbreak;\n\tcase 'a': // \"CCa\"\n\t\t{\n\t\tchar *s, *p;\n\t\ts = strchr (input, ' ');\n\t\tif (s) {\n\t\t\ts = strdup (s + 1);\n\t\t} else {\n\t\t\teprintf (\"Usage: CCa [address] [comment]\\n\");\n\t\t\teprintf (\"Usage: CCa-[address]\\n\");\n\t\t\treturn false;\n\t\t}\n\t\tp = strchr (s, ' ');\n\t\tif (p) {\n\t\t\t*p++ = 0;\n\t\t}\n\t\tut64 addr;\n\t\tif (input[2] == '-') {\n\t\t\tif (input[3]) {\n\t\t\t\taddr = r_num_math (core->num, input+3);\n\t\t\t\tr_meta_del (core->anal,\n\t\t\t\t\t\tR_META_TYPE_COMMENT,\n\t\t\t\t\t\taddr, 1);\n\t\t\t} else {\n\t\t\t\teprintf (\"Usage: CCa-[address]\\n\");\n\t\t\t}\n\t\t\tfree (s);\n\t\t\treturn true;\n\t\t}\n\t\taddr = r_num_math (core->num, s);\n\t\t// Comment at\n\t\tif (p) {\n\t\t\tif (input[2]=='+') {\n\t\t\t\tconst char *comment = r_meta_get_string (core->anal, R_META_TYPE_COMMENT, addr);\n\t\t\t\tif (comment) {\n\t\t\t\t\tchar *text = r_str_newf (\"%s\\n%s\", comment, p);\n\t\t\t\t\tr_meta_set (core->anal, R_META_TYPE_COMMENT, addr, 1, text);\n\t\t\t\t\tfree (text);\n\t\t\t\t} else {\n\t\t\t\t\tr_meta_set (core->anal, R_META_TYPE_COMMENT, addr, 1, p);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tr_meta_set (core->anal, R_META_TYPE_COMMENT, addr, 1, p);\n\t\t\t}\n\t\t} else {\n\t\t\teprintf (\"Usage: CCa [address] [comment]\\n\");\n\t\t}\n\t\tfree (s);\n\t\treturn true;\n\t\t}\n\t}\n\treturn true;\n}",
        "func": "static int cmd_meta_comment(RCore *core, const char *input) {\n\tut64 addr = core->offset;\n\tswitch (input[1]) {\n\tcase '?':\n\t\tr_core_cmd_help (core, help_msg_CC);\n\t\tbreak;\n\tcase ',': // \"CC,\"\n\t\tr_meta_print_list_all (core->anal, R_META_TYPE_COMMENT, ',', input + 2);\n\t\tbreak;\n\tcase 'F': // \"CC,\"\n\t\tif (input[2]=='?') {\n\t\t\teprintf (\"Usage: CCF [file]\\n\");\n\t\t} else if (input[2] == ' ') {\n\t\t\tconst char *fn = input + 2;\n\t\t\tconst char *comment = r_meta_get_string (core->anal, R_META_TYPE_COMMENT, addr);\n\t\t\tfn = r_str_trim_head_ro (fn);\n\t\t\tif (comment && *comment) {\n\t\t\t\t// append filename in current comment\n\t\t\t\tchar *nc = r_str_newf (\"%s ,(%s)\", comment, fn);\n\t\t\t\tr_meta_set_string (core->anal, R_META_TYPE_COMMENT, addr, nc);\n\t\t\t\tfree (nc);\n\t\t\t} else {\n\t\t\t\tchar *newcomment = r_str_newf (\",(%s)\", fn);\n\t\t\t\tr_meta_set_string (core->anal, R_META_TYPE_COMMENT, addr, newcomment);\n\t\t\t\tfree (newcomment);\n\t\t\t}\n\t\t} else {\n\t\t\tconst char *comment = r_meta_get_string (core->anal, R_META_TYPE_COMMENT, addr);\n\t\t\tif (comment && *comment) {\n\t\t\t\tchar *cmtfile = r_str_between (comment, \",(\", \")\");\n\t\t\t\tif (cmtfile && *cmtfile) {\n\t\t\t\t\tchar *cwd = getcommapath (core);\n\t\t\t\t\tr_cons_printf (\"%s\"R_SYS_DIR\"%s\\n\", cwd, cmtfile);\n\t\t\t\t\tfree (cwd);\n\t\t\t\t}\n\t\t\t\tfree (cmtfile);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase '.':\n\t\t  {\n\t\t\t  ut64 at = input[2]? r_num_math (core->num, input + 2): addr;\n\t\t\t  const char *comment = r_meta_get_string (core->anal, R_META_TYPE_COMMENT, at);\n\t\t\t  if (comment) {\n\t\t\t\t  r_cons_println (comment);\n\t\t\t  }\n\t\t  }\n\t\tbreak;\n\tcase 0: // \"CC\"\n\t\tr_meta_print_list_all (core->anal, R_META_TYPE_COMMENT, 0, NULL);\n\t\tbreak;\n\tcase 'f': // \"CCf\"\n\t\tswitch (input[2]) {\n\t\tcase '-': // \"CCf-\"\n\t\t\t{\n\t\t\t\tut64 arg = r_num_math (core->num, input + 2);\n\t\t\t\tif (!arg) {\n\t\t\t\t\targ = core->offset;\n\t\t\t\t}\n\t\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, arg, 0);\n\t\t\t\tif (fcn) {\n\t\t\t\t\tRAnalBlock *bb;\n\t\t\t\t\tRListIter *iter;\n\t\t\t\t\tr_list_foreach (fcn->bbs, iter, bb) {\n\t\t\t\t\t\tint i;\n\t\t\t\t\t\tfor (i = 0; i < bb->size; i++) {\n\t\t\t\t\t\t\tut64 addr = bb->addr + i;\n\t\t\t\t\t\t\tr_meta_del (core->anal, R_META_TYPE_COMMENT, addr, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ',': // \"CCf,\"\n\t\t\tr_meta_print_list_in_function (core->anal, R_META_TYPE_COMMENT, ',', core->offset, input + 3);\n\t\t\tbreak;\n\t\tcase 'j': // \"CCfj\"\n\t\t\tr_meta_print_list_in_function (core->anal, R_META_TYPE_COMMENT, 'j', core->offset, NULL);\n\t\t\tbreak;\n\t\tcase '*': // \"CCf*\"\n\t\t\tr_meta_print_list_in_function (core->anal, R_META_TYPE_COMMENT, 1, core->offset, NULL);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tr_meta_print_list_in_function (core->anal, R_META_TYPE_COMMENT, 0, core->offset, NULL);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tcase 'j': // \"CCj\"\n\t\tr_meta_print_list_all (core->anal, R_META_TYPE_COMMENT, 'j', input + 2);\n\t\tbreak;\n\tcase '!':\n\t\t{\n\t\t\tconst char *comment = r_meta_get_string (core->anal, R_META_TYPE_COMMENT, addr);\n\t\t\tchar *out = r_core_editor (core, NULL, comment);\n\t\t\tif (out) {\n\t\t\t\tr_str_ansi_strip (out);\n\t\t\t\t//r_meta_set (core->anal->meta, R_META_TYPE_COMMENT, addr, 0, out);\n\t\t\t\tr_core_cmdf (core, \"CC-@0x%08\"PFMT64x, addr);\n\t\t\t\t//r_meta_del (core->anal->meta, input[0], addr, addr+1);\n\t\t\t\tr_meta_set_string (core->anal,\n\t\t\t\t\t\tR_META_TYPE_COMMENT, addr, out);\n\t\t\t\tfree (out);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase '+':\n\tcase ' ':\n\t\t{\n\t\tconst char *newcomment = r_str_trim_head_ro (input + 2);\n\t\tconst char *comment = r_meta_get_string (core->anal, R_META_TYPE_COMMENT, addr);\n\t\tchar *text;\n\t\tchar *nc = strdup (newcomment);\n\t\tr_str_unescape (nc);\n\t\tr_str_ansi_strip (nc);\n\t\tif (comment) {\n\t\t\ttext = malloc (strlen (comment) + strlen (newcomment) + 2);\n\t\t\tif (text) {\n\t\t\t\tstrcpy (text, comment);\n\t\t\t\tstrcat (text, \" \");\n\t\t\t\tstrcat (text, nc);\n\t\t\t\tr_meta_set_string (core->anal, R_META_TYPE_COMMENT, addr, text);\n\t\t\t\tfree (text);\n\t\t\t} else {\n\t\t\t\tr_sys_perror (\"malloc\");\n\t\t\t}\n\t\t} else {\n\t\t\tr_meta_set_string (core->anal, R_META_TYPE_COMMENT, addr, nc);\n\t\t\tif (r_config_get_b (core->config, \"cmd.undo\")) {\n\t\t\t\tchar *a = r_str_newf (\"CC-0x%08\"PFMT64x, addr);\n\t\t\t\tchar *b = r_str_newf (\"CC %s@0x%08\"PFMT64x, nc, addr);\n\t\t\t\tRCoreUndo *uc = r_core_undo_new (core->offset, b, a);\n\t\t\t\tr_core_undo_push (core, uc);\n\t\t\t\tfree (a);\n\t\t\t\tfree (b);\n\t\t\t}\n\t\t}\n\t\tfree (nc);\n\t\t}\n\t\tbreak;\n\tcase '*': // \"CC*\"\n\t\tr_meta_print_list_all (core->anal, R_META_TYPE_COMMENT, 1, NULL);\n\t\tbreak;\n\tcase '-': // \"CC-\"\n\t\tif (input[2] == '*') { // \"CC-*\"\n\t\t\tr_meta_del (core->anal, R_META_TYPE_COMMENT, UT64_MAX, UT64_MAX);\n\t\t} else if (input[2]) { // \"CC-$$+32\"\n\t\t\tut64 arg = r_num_math (core->num, input + 2);\n\t\t\tr_meta_del (core->anal, R_META_TYPE_COMMENT, arg, 1);\n\t\t} else { // \"CC-\"\n\t\t\tr_meta_del (core->anal, R_META_TYPE_COMMENT, core->offset, 1);\n\t\t}\n\t\tbreak;\n\tcase 'u': // \"CCu\"\n\t\t//\n\t\t{\n\t\tchar *newcomment;\n\t\tconst char *arg = input + 2;\n\t\twhile (*arg && *arg == ' ') arg++;\n\t\tif (!strncmp (arg, \"base64:\", 7)) {\n\t\t\tchar *s = (char *)sdb_decode (arg + 7, NULL);\n\t\t\tif (s) {\n\t\t\t\tnewcomment = s;\n\t\t\t} else {\n\t\t\t\tnewcomment = NULL;\n\t\t\t}\n\t\t} else {\n\t\t\tnewcomment = strdup (arg);\n\t\t}\n\t\tif (newcomment) {\n\t\t\tconst char *comment = r_meta_get_string (core->anal, R_META_TYPE_COMMENT, addr);\n\t\t\tif (!comment || (comment && !strstr (comment, newcomment))) {\n\t\t\t\tr_meta_set_string (core->anal, R_META_TYPE_COMMENT, addr, newcomment);\n\t\t\t}\n\t\t\tfree (newcomment);\n\t\t}\n\t\t}\n\t\tbreak;\n\tcase 'a': // \"CCa\"\n\t\t{\n\t\tchar *s, *p;\n\t\ts = strchr (input, ' ');\n\t\tif (s) {\n\t\t\ts = strdup (s + 1);\n\t\t} else {\n\t\t\teprintf (\"Usage: CCa [address] [comment]\\n\");\n\t\t\teprintf (\"Usage: CCa-[address]\\n\");\n\t\t\treturn false;\n\t\t}\n\t\tp = strchr (s, ' ');\n\t\tif (p) {\n\t\t\t*p++ = 0;\n\t\t}\n\t\tut64 addr;\n\t\tif (input[2] == '-') {\n\t\t\tif (input[3]) {\n\t\t\t\taddr = r_num_math (core->num, input+3);\n\t\t\t\tr_meta_del (core->anal,\n\t\t\t\t\t\tR_META_TYPE_COMMENT,\n\t\t\t\t\t\taddr, 1);\n\t\t\t} else {\n\t\t\t\teprintf (\"Usage: CCa-[address]\\n\");\n\t\t\t}\n\t\t\tfree (s);\n\t\t\treturn true;\n\t\t}\n\t\taddr = r_num_math (core->num, s);\n\t\t// Comment at\n\t\tif (p) {\n\t\t\tif (input[2]=='+') {\n\t\t\t\tconst char *comment = r_meta_get_string (core->anal, R_META_TYPE_COMMENT, addr);\n\t\t\t\tif (comment) {\n\t\t\t\t\tchar *text = r_str_newf (\"%s\\n%s\", comment, p);\n\t\t\t\t\tr_meta_set (core->anal, R_META_TYPE_COMMENT, addr, 1, text);\n\t\t\t\t\tfree (text);\n\t\t\t\t} else {\n\t\t\t\t\tr_meta_set (core->anal, R_META_TYPE_COMMENT, addr, 1, p);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tr_meta_set (core->anal, R_META_TYPE_COMMENT, addr, 1, p);\n\t\t\t}\n\t\t} else {\n\t\t\teprintf (\"Usage: CCa [address] [comment]\\n\");\n\t\t}\n\t\tfree (s);\n\t\treturn true;\n\t\t}\n\t}\n\treturn true;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -90,10 +90,10 @@\n \t\tbreak;\n \tcase '!':\n \t\t{\n-\t\t\tchar *out;\n-\t\t\tconst char *comment = r_meta_get_string (core->anal, R_META_TYPE_COMMENT, addr);\n-\t\t\tout = r_core_editor (core, NULL, comment);\n+\t\t\tconst char *comment = r_meta_get_string (core->anal, R_META_TYPE_COMMENT, addr);\n+\t\t\tchar *out = r_core_editor (core, NULL, comment);\n \t\t\tif (out) {\n+\t\t\t\tr_str_ansi_strip (out);\n \t\t\t\t//r_meta_set (core->anal->meta, R_META_TYPE_COMMENT, addr, 0, out);\n \t\t\t\tr_core_cmdf (core, \"CC-@0x%08\"PFMT64x, addr);\n \t\t\t\t//r_meta_del (core->anal->meta, input[0], addr, addr+1);\n@@ -111,6 +111,7 @@\n \t\tchar *text;\n \t\tchar *nc = strdup (newcomment);\n \t\tr_str_unescape (nc);\n+\t\tr_str_ansi_strip (nc);\n \t\tif (comment) {\n \t\t\ttext = malloc (strlen (comment) + strlen (newcomment) + 2);\n \t\t\tif (text) {",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\tchar *out;",
                "\t\t\tconst char *comment = r_meta_get_string (core->anal, R_META_TYPE_COMMENT, addr);",
                "\t\t\tout = r_core_editor (core, NULL, comment);"
            ],
            "added_lines": [
                "\t\t\tconst char *comment = r_meta_get_string (core->anal, R_META_TYPE_COMMENT, addr);",
                "\t\t\tchar *out = r_core_editor (core, NULL, comment);",
                "\t\t\t\tr_str_ansi_strip (out);",
                "\t\tr_str_ansi_strip (nc);"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-0302",
        "func_name": "radareorg/radare2/parse_die",
        "description": "Failure to Sanitize Special Elements into a Different Plane (Special Element Injection) in GitHub repository radareorg/radare2 prior to 5.8.2.",
        "git_url": "https://github.com/radareorg/radare2/commit/961f0e723903011d4f54c2396e44efa91fcc74ce",
        "commit_title": "Fix ANSI Escape Sequence Injection vulns via DWARF ##vuln",
        "commit_text": " * Reported by @solid-snail via huntrdev\r * BountyID: 583133af-7ae6-4a21-beef-a4b0182cf82e\r * Reproducer: dwarf_test_func_patched",
        "func_before": "static const ut8 *parse_die(const ut8 *buf, const ut8 *buf_end, RBinDwarfAbbrevDecl *abbrev, RBinDwarfCompUnitHdr *hdr, RBinDwarfDie *die, const ut8 *debug_str, size_t debug_str_len, Sdb *sdb) {\n\tsize_t i;\n\tif (!buf || !buf_end || buf > buf_end) {\n\t\treturn NULL;\n\t}\n\tfor (i = 0; i < die->count; i++) {\n\t\tmemset (&die->attr_values[i], 0, sizeof (RBinDwarfDie));\n\t}\n\tfor (i = 0; i < abbrev->count && i < die->capacity; i++) {\n\t\tmemset (&die->attr_values[i], 0, sizeof (die->attr_values[i]));\n\t\t// debug_str_len = r_str_nlen (debug_str, buf_end - buf);\n\t\tconst ut8 *nbuf = parse_attr_value (buf, buf_end - buf,\n\t\t\t&abbrev->defs[i],\n\t\t\t&die->attr_values[i],\n\t\t\thdr, debug_str, debug_str_len);\n\t\tif (nbuf) {\n\t\t\tbuf = nbuf;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\n\t\tRBinDwarfAttrValue *attribute = &die->attr_values[i];\n\n\t\tbool is_string = (attribute->attr_form == DW_FORM_strp || attribute->attr_form == DW_FORM_string);\n\t\tbool is_valid_string_form = is_string && attribute->string.content;\n\t\t// TODO  does this have a purpose anymore?\n\t\t// Or atleast it needs to rework becase there will be\n\t\t// more comp units -> more comp dirs and only the last one will be kept\n\t\tif (attribute->attr_name == DW_AT_comp_dir && is_valid_string_form) {\n\t\t\tconst char *name = attribute->string.content;\n\t\t\tsdb_set (sdb, \"DW_AT_comp_dir\", name, 0);\n\t\t}\n\t\tdie->count++;\n\t}\n\treturn buf;\n}",
        "func": "static const ut8 *parse_die(const ut8 *buf, const ut8 *buf_end, RBinDwarfAbbrevDecl *abbrev, RBinDwarfCompUnitHdr *hdr, RBinDwarfDie *die, const ut8 *debug_str, size_t debug_str_len, Sdb *sdb) {\n\tsize_t i;\n\tif (!buf || !buf_end || buf > buf_end) {\n\t\treturn NULL;\n\t}\n\tfor (i = 0; i < die->count; i++) {\n\t\tmemset (&die->attr_values[i], 0, sizeof (RBinDwarfDie));\n\t}\n\tfor (i = 0; i < abbrev->count && i < die->capacity; i++) {\n\t\tmemset (&die->attr_values[i], 0, sizeof (die->attr_values[i]));\n\t\t// debug_str_len = r_str_nlen (debug_str, buf_end - buf);\n\t\tconst ut8 *nbuf = parse_attr_value (buf, buf_end - buf,\n\t\t\t&abbrev->defs[i],\n\t\t\t&die->attr_values[i],\n\t\t\thdr, debug_str, debug_str_len);\n\t\tif (nbuf) {\n\t\t\tbuf = nbuf;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\n\t\tRBinDwarfAttrValue *attribute = &die->attr_values[i];\n\n\t\tbool is_string = (attribute->attr_form == DW_FORM_strp || attribute->attr_form == DW_FORM_string);\n\t\tbool is_valid_string_form = is_string && attribute->string.content;\n\t\t// TODO  does this have a purpose anymore?\n\t\t// Or atleast it needs to rework becase there will be\n\t\t// more comp units -> more comp dirs and only the last one will be kept\n\t\tif (attribute->attr_name == DW_AT_comp_dir && is_valid_string_form) {\n\t\t\tchar *name = strdup (attribute->string.content);\n\t\t\tr_str_ansi_strip (name);\n\t\t\tr_str_replace_ch (name, '\\n', 0, true);\n\t\t\tr_str_replace_ch (name, '\\t', 0, true);\n\t\t\tsdb_set_owned (sdb, \"DW_AT_comp_dir\", name, 0);\n\t\t}\n\t\tdie->count++;\n\t}\n\treturn buf;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -27,8 +27,11 @@\n \t\t// Or atleast it needs to rework becase there will be\n \t\t// more comp units -> more comp dirs and only the last one will be kept\n \t\tif (attribute->attr_name == DW_AT_comp_dir && is_valid_string_form) {\n-\t\t\tconst char *name = attribute->string.content;\n-\t\t\tsdb_set (sdb, \"DW_AT_comp_dir\", name, 0);\n+\t\t\tchar *name = strdup (attribute->string.content);\n+\t\t\tr_str_ansi_strip (name);\n+\t\t\tr_str_replace_ch (name, '\\n', 0, true);\n+\t\t\tr_str_replace_ch (name, '\\t', 0, true);\n+\t\t\tsdb_set_owned (sdb, \"DW_AT_comp_dir\", name, 0);\n \t\t}\n \t\tdie->count++;\n \t}",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\tconst char *name = attribute->string.content;",
                "\t\t\tsdb_set (sdb, \"DW_AT_comp_dir\", name, 0);"
            ],
            "added_lines": [
                "\t\t\tchar *name = strdup (attribute->string.content);",
                "\t\t\tr_str_ansi_strip (name);",
                "\t\t\tr_str_replace_ch (name, '\\n', 0, true);",
                "\t\t\tr_str_replace_ch (name, '\\t', 0, true);",
                "\t\t\tsdb_set_owned (sdb, \"DW_AT_comp_dir\", name, 0);"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-0302",
        "func_name": "radareorg/radare2/parse_attr_value",
        "description": "Failure to Sanitize Special Elements into a Different Plane (Special Element Injection) in GitHub repository radareorg/radare2 prior to 5.8.2.",
        "git_url": "https://github.com/radareorg/radare2/commit/961f0e723903011d4f54c2396e44efa91fcc74ce",
        "commit_title": "Fix ANSI Escape Sequence Injection vulns via DWARF ##vuln",
        "commit_text": " * Reported by @solid-snail via huntrdev\r * BountyID: 583133af-7ae6-4a21-beef-a4b0182cf82e\r * Reproducer: dwarf_test_func_patched",
        "func_before": "static const ut8 *parse_attr_value(const ut8 *obuf, int obuf_len,\n\t\tRBinDwarfAttrDef *def, RBinDwarfAttrValue *value,\n\t\tconst RBinDwarfCompUnitHdr *hdr,\n\t\tconst ut8 *debug_str, size_t debug_str_len) {\n\tr_return_val_if_fail (def && value && hdr && obuf, NULL);\n\n\tvalue->attr_form = def->attr_form;\n\tvalue->attr_name = def->attr_name;\n\tvalue->block.data = NULL;\n\tvalue->string.content = NULL;\n\tvalue->string.offset = 0;\n\n\n\tconst ut8 *buf = obuf;\n\tconst ut8 *buf_end = obuf + obuf_len;\n\tsize_t j;\n\n\tif (obuf_len < 1) {\n\t\treturn NULL;\n\t}\n\n\t// http://www.dwarfstd.org/doc/DWARF4.pdf#page=161&zoom=100,0,560\n\tswitch (def->attr_form) {\n\tcase DW_FORM_addr:\n\t\tvalue->kind = DW_AT_KIND_ADDRESS;\n\t\tswitch (hdr->address_size) {\n\t\tcase 1:\n\t\t\tvalue->address = READ8 (buf);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tvalue->address = READ16 (buf);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tvalue->address = READ32 (buf);\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tvalue->address = READ64 (buf);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tR_LOG_WARN (\"DWARF: Unexpected pointer size: %u\", (unsigned)hdr->address_size);\n\t\t\treturn NULL;\n\t\t}\n\t\tbreak;\n\tcase DW_FORM_data1:\n\t\tvalue->kind = DW_AT_KIND_CONSTANT;\n\t\tvalue->uconstant = READ8 (buf);\n\t\tbreak;\n\tcase DW_FORM_data2:\n\t\tvalue->kind = DW_AT_KIND_CONSTANT;\n\t\tvalue->uconstant = READ16 (buf);\n\t\tbreak;\n\tcase DW_FORM_data4:\n\t\tvalue->kind = DW_AT_KIND_CONSTANT;\n\t\tvalue->uconstant = READ32 (buf);\n\t\tbreak;\n\tcase DW_FORM_data8:\n\t\tvalue->kind = DW_AT_KIND_CONSTANT;\n\t\tvalue->uconstant = READ64 (buf);\n\t\tbreak;\n\tcase DW_FORM_data16: // TODO Fix this, right now I just read the data, but I need to make storage for it\n\t\tvalue->kind = DW_AT_KIND_CONSTANT;\n\t\tvalue->uconstant = READ64 (buf);\n\t\tvalue->uconstant = READ64 (buf);\n\t\tbreak;\n\tcase DW_FORM_sdata:\n\t\tvalue->kind = DW_AT_KIND_CONSTANT;\n\t\tbuf = r_leb128 (buf, buf_end - buf, &value->sconstant);\n\t\tbreak;\n\tcase DW_FORM_udata:\n\t\tvalue->kind = DW_AT_KIND_CONSTANT;\n\t\tbuf = r_uleb128 (buf, buf_end - buf, &value->uconstant, NULL);\n\t\tbreak;\n\tcase DW_FORM_string:\n\t\tvalue->kind = DW_AT_KIND_STRING;\n\t\tvalue->string.content = *buf ? r_str_ndup ((const char *)buf, buf_end - buf) : NULL;\n\t\tif (value->string.content) {\n\t\t\tbuf += strlen (value->string.content) + 1;\n\t\t}\n\t\tbreak;\n\tcase DW_FORM_block1:\n\t\tvalue->kind = DW_AT_KIND_BLOCK;\n\t\tvalue->block.length = READ8 (buf);\n\t\tbuf = fill_block_data (buf, buf_end, &value->block);\n\t\tbreak;\n\tcase DW_FORM_block2:\n\t\tvalue->kind = DW_AT_KIND_BLOCK;\n\t\tvalue->block.length = READ16 (buf);\n\t\tif (value->block.length > 0) {\n\t\t\tvalue->block.data = calloc (sizeof (ut8), value->block.length);\n\t\t\tif (!value->block.data) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tfor (j = 0; j < value->block.length; j++) {\n\t\t\t\tvalue->block.data[j] = READ (buf, ut8);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase DW_FORM_block4:\n\t\tvalue->kind = DW_AT_KIND_BLOCK;\n\t\tvalue->block.length = READ32 (buf);\n\t\tbuf = fill_block_data (buf, buf_end, &value->block);\n\t\tbreak;\n\tcase DW_FORM_block: // variable length ULEB128\n\t\tvalue->kind = DW_AT_KIND_BLOCK;\n\t\tbuf = r_uleb128 (buf, buf_end - buf, &value->block.length, NULL);\n\t\tif (!buf || buf >= buf_end) {\n\t\t\treturn NULL;\n\t\t}\n\t\tbuf = fill_block_data (buf, buf_end, &value->block);\n\t\tbreak;\n\tcase DW_FORM_flag:\n\t\tvalue->kind = DW_AT_KIND_FLAG;\n\t\tvalue->flag = READ (buf, ut8);\n\t\tbreak;\n\t// offset in .debug_str\n\tcase DW_FORM_strp:\n\t\tvalue->kind = DW_AT_KIND_STRING;\n\t\tvalue->string.offset = dwarf_read_offset (hdr->is_64bit, &buf, buf_end);\n\t\tif (debug_str && value->string.offset < debug_str_len) {\n\t\t\tconst char *ds = (const char *)(debug_str + value->string.offset);\n\t\t\tvalue->string.content = strdup (ds); // r_str_ndup (ds, debug_str_len - value->string.offset);\n\t\t} else {\n\t\t\tvalue->string.content = NULL; // Means malformed DWARF, should we print error message?\n\t\t}\n\t\tbreak;\n\t// offset in .debug_info\n\tcase DW_FORM_ref_addr:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\tvalue->reference = dwarf_read_offset (hdr->is_64bit, &buf, buf_end);\n\t\tbreak;\n\t// This type of reference is an offset from the first byte of the compilation\n\t// header for the compilation unit containing the reference\n\tcase DW_FORM_ref1:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\tvalue->reference = hdr->unit_offset + READ8 (buf);\n\t\tbreak;\n\tcase DW_FORM_ref2:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\tvalue->reference = hdr->unit_offset + READ16 (buf);\n\t\tbreak;\n\tcase DW_FORM_ref4:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\tvalue->reference = hdr->unit_offset + READ32 (buf);\n\t\tbreak;\n\tcase DW_FORM_ref8:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\tvalue->reference = hdr->unit_offset + READ64 (buf);\n\t\tbreak;\n\tcase DW_FORM_ref_udata:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\t// uleb128 is enough to fit into ut64?\n\t\tbuf = r_uleb128 (buf, buf_end - buf, &value->reference, NULL);\n\t\tvalue->reference += hdr->unit_offset;\n\t\tbreak;\n\t// offset in a section other than .debug_info or .debug_str\n\tcase DW_FORM_sec_offset:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\tvalue->reference = dwarf_read_offset(hdr->is_64bit, &buf, buf_end);\n\t\tbreak;\n\tcase DW_FORM_exprloc:\n\t\tvalue->kind = DW_AT_KIND_BLOCK;\n\t\tbuf = r_uleb128 (buf, buf_end - buf, &value->block.length, NULL);\n\t\tif (!buf || buf >= buf_end) {\n\t\t\treturn NULL;\n\t\t}\n\t\tbuf = fill_block_data (buf, buf_end, &value->block);\n\t\tbreak;\n\t// this means that the flag is present, nothing is read\n\tcase DW_FORM_flag_present:\n\t\tvalue->kind = DW_AT_KIND_FLAG;\n\t\tvalue->flag = true;\n\t\tbreak;\n\tcase DW_FORM_ref_sig8:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\tvalue->reference = READ64 (buf);\n\t\tbreak;\n\t// offset into .debug_line_str section, can't parse the section now, so we just skip\n\tcase DW_FORM_strx:\n\t\tvalue->kind = DW_AT_KIND_STRING;\n\t\t// value->string.offset = dwarf_read_offset (hdr->is_64bit, &buf, buf_end);\n\t\t// if (debug_str && value->string.offset < debug_line_str_len) {\n\t\t// \tvalue->string.content =\n\t\t// \t\tstrdup ((const char *)(debug_str + value->string.offset));\n\t\t// } else {\n\t\t// \tvalue->string.content = NULL; // Means malformed DWARF, should we print error message?\n\t\t// }\n\t\tbreak;\n\tcase DW_FORM_strx1:\n\t\tvalue->kind = DW_AT_KIND_STRING;\n\t\tvalue->string.offset = READ8 (buf);\n\t\tbreak;\n\tcase DW_FORM_strx2:\n\t\tvalue->kind = DW_AT_KIND_STRING;\n\t\tvalue->string.offset = READ16 (buf);\n\t\tbreak;\n\tcase DW_FORM_strx3: // TODO Add 3 byte int read\n\t\tvalue->kind = DW_AT_KIND_STRING;\n\t\tbuf += 3;\n\t\tbreak;\n\tcase DW_FORM_strx4:\n\t\tvalue->kind = DW_AT_KIND_STRING;\n\t\tvalue->string.offset = READ32 (buf);\n\t\tbreak;\n\tcase DW_FORM_implicit_const:\n\t\tvalue->kind = DW_AT_KIND_CONSTANT;\n\t\tvalue->uconstant = def->special;\n\t\tbreak;\n\t/*  addrx* forms : The index is relative to the value of the\n\t\tDW_AT_addr_base attribute of the associated compilation unit.\n\t    index into an array of addresses in the .debug_addr section.*/\n\tcase DW_FORM_addrx:\n\t\tvalue->kind = DW_AT_KIND_ADDRESS;\n\t\tbuf = r_uleb128 (buf, buf_end - buf, &value->address, NULL);\n\t\tbreak;\n\tcase DW_FORM_addrx1:\n\t\tvalue->kind = DW_AT_KIND_ADDRESS;\n\t\tvalue->address = READ8 (buf);\n\t\tbreak;\n\tcase DW_FORM_addrx2:\n\t\tvalue->kind = DW_AT_KIND_ADDRESS;\n\t\tvalue->address = READ16 (buf);\n\t\tbreak;\n\tcase DW_FORM_addrx3:\n\t\t// I need to add 3byte endianess free read here TODO\n\t\tvalue->kind = DW_AT_KIND_ADDRESS;\n\t\tbuf += 3;\n\t\tbreak;\n\tcase DW_FORM_addrx4:\n\t\tvalue->kind = DW_AT_KIND_ADDRESS;\n\t\tvalue->address = READ32 (buf);\n\t\tbreak;\n\tcase DW_FORM_line_ptr: // offset in a section .debug_line_str\n\tcase DW_FORM_strp_sup: // offset in a section .debug_line_str\n\t\tvalue->kind = DW_AT_KIND_STRING;\n\t\tvalue->string.offset = dwarf_read_offset (hdr->is_64bit, &buf, buf_end);\n\t\t// if (debug_str && value->string.offset < debug_line_str_len) {\n\t\t// \tvalue->string.content =\n\t\t// \t\tstrdupsts\n\t\tbreak;\n\t// offset in the supplementary object file\n\tcase DW_FORM_ref_sup4:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\tvalue->reference = READ32 (buf);\n\t\tbreak;\n\tcase DW_FORM_ref_sup8:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\tvalue->reference = READ64 (buf);\n\t\tbreak;\n\t// An index into the .debug_loc\n\tcase DW_FORM_loclistx:\n\t\tvalue->kind = DW_AT_KIND_LOCLISTPTR;\n\t\tvalue->reference = dwarf_read_offset (hdr->is_64bit, &buf, buf_end);\n\t\tbreak;\n\t // An index into the .debug_rnglists\n\tcase DW_FORM_rnglistx:\n\t\tvalue->kind = DW_AT_KIND_ADDRESS;\n\t\tbuf = r_uleb128 (buf, buf_end - buf, &value->address, NULL);\n\t\tbreak;\n\tcase 0:\n\t\tvalue->uconstant = 0;\n\t\treturn NULL;\n\tdefault:\n\t\tR_LOG_WARN (\"Unknown DW_FORM 0x%02\" PFMT64x, def->attr_form);\n\t\tvalue->uconstant = 0;\n\t\treturn NULL;\n\t}\n\treturn buf;\n}",
        "func": "static const ut8 *parse_attr_value(const ut8 *obuf, int obuf_len,\n\t\tRBinDwarfAttrDef *def, RBinDwarfAttrValue *value,\n\t\tconst RBinDwarfCompUnitHdr *hdr,\n\t\tconst ut8 *debug_str, size_t debug_str_len) {\n\tr_return_val_if_fail (def && value && hdr && obuf, NULL);\n\n\tvalue->attr_form = def->attr_form;\n\tvalue->attr_name = def->attr_name;\n\tvalue->block.data = NULL;\n\tvalue->string.content = NULL;\n\tvalue->string.offset = 0;\n\n\n\tconst ut8 *buf = obuf;\n\tconst ut8 *buf_end = obuf + obuf_len;\n\tsize_t j;\n\n\tif (obuf_len < 1) {\n\t\treturn NULL;\n\t}\n\n\t// http://www.dwarfstd.org/doc/DWARF4.pdf#page=161&zoom=100,0,560\n\tswitch (def->attr_form) {\n\tcase DW_FORM_addr:\n\t\tvalue->kind = DW_AT_KIND_ADDRESS;\n\t\tswitch (hdr->address_size) {\n\t\tcase 1:\n\t\t\tvalue->address = READ8 (buf);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tvalue->address = READ16 (buf);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tvalue->address = READ32 (buf);\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tvalue->address = READ64 (buf);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tR_LOG_WARN (\"DWARF: Unexpected pointer size: %u\", (unsigned)hdr->address_size);\n\t\t\treturn NULL;\n\t\t}\n\t\tbreak;\n\tcase DW_FORM_data1:\n\t\tvalue->kind = DW_AT_KIND_CONSTANT;\n\t\tvalue->uconstant = READ8 (buf);\n\t\tbreak;\n\tcase DW_FORM_data2:\n\t\tvalue->kind = DW_AT_KIND_CONSTANT;\n\t\tvalue->uconstant = READ16 (buf);\n\t\tbreak;\n\tcase DW_FORM_data4:\n\t\tvalue->kind = DW_AT_KIND_CONSTANT;\n\t\tvalue->uconstant = READ32 (buf);\n\t\tbreak;\n\tcase DW_FORM_data8:\n\t\tvalue->kind = DW_AT_KIND_CONSTANT;\n\t\tvalue->uconstant = READ64 (buf);\n\t\tbreak;\n\tcase DW_FORM_data16: // TODO Fix this, right now I just read the data, but I need to make storage for it\n\t\tvalue->kind = DW_AT_KIND_CONSTANT;\n\t\tvalue->uconstant = READ64 (buf);\n\t\tvalue->uconstant = READ64 (buf);\n\t\tbreak;\n\tcase DW_FORM_sdata:\n\t\tvalue->kind = DW_AT_KIND_CONSTANT;\n\t\tbuf = r_leb128 (buf, buf_end - buf, &value->sconstant);\n\t\tbreak;\n\tcase DW_FORM_udata:\n\t\tvalue->kind = DW_AT_KIND_CONSTANT;\n\t\tbuf = r_uleb128 (buf, buf_end - buf, &value->uconstant, NULL);\n\t\tbreak;\n\tcase DW_FORM_string:\n\t\tvalue->kind = DW_AT_KIND_STRING;\n\t\tif (*buf) {\n\t\t\tchar *name = r_str_ndup ((const char *)buf, buf_end - buf);\n\t\t\tr_str_ansi_strip (name);\n\t\t\tr_str_replace_ch (name, '\\n', 0, true);\n\t\t\tr_str_replace_ch (name, '\\t', 0, true);\n\t\t\tvalue->string.content = name;\n\t\t} else {\n\t\t\tvalue->string.content = NULL;\n\t\t}\n\t\tif (value->string.content) {\n\t\t\tbuf += strlen (value->string.content) + 1;\n\t\t}\n\t\tbreak;\n\tcase DW_FORM_block1:\n\t\tvalue->kind = DW_AT_KIND_BLOCK;\n\t\tvalue->block.length = READ8 (buf);\n\t\tbuf = fill_block_data (buf, buf_end, &value->block);\n\t\tbreak;\n\tcase DW_FORM_block2:\n\t\tvalue->kind = DW_AT_KIND_BLOCK;\n\t\tvalue->block.length = READ16 (buf);\n\t\tif (value->block.length > 0) {\n\t\t\tvalue->block.data = calloc (sizeof (ut8), value->block.length);\n\t\t\tif (!value->block.data) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tfor (j = 0; j < value->block.length; j++) {\n\t\t\t\tvalue->block.data[j] = READ (buf, ut8);\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tcase DW_FORM_block4:\n\t\tvalue->kind = DW_AT_KIND_BLOCK;\n\t\tvalue->block.length = READ32 (buf);\n\t\tbuf = fill_block_data (buf, buf_end, &value->block);\n\t\tbreak;\n\tcase DW_FORM_block: // variable length ULEB128\n\t\tvalue->kind = DW_AT_KIND_BLOCK;\n\t\tbuf = r_uleb128 (buf, buf_end - buf, &value->block.length, NULL);\n\t\tif (!buf || buf >= buf_end) {\n\t\t\treturn NULL;\n\t\t}\n\t\tbuf = fill_block_data (buf, buf_end, &value->block);\n\t\tbreak;\n\tcase DW_FORM_flag:\n\t\tvalue->kind = DW_AT_KIND_FLAG;\n\t\tvalue->flag = READ (buf, ut8);\n\t\tbreak;\n\t// offset in .debug_str\n\tcase DW_FORM_strp:\n\t\tvalue->kind = DW_AT_KIND_STRING;\n\t\tvalue->string.offset = dwarf_read_offset (hdr->is_64bit, &buf, buf_end);\n\t\tif (debug_str && value->string.offset < debug_str_len) {\n\t\t\tchar *ds = r_str_ndup ((const char *)(debug_str + value->string.offset), debug_str_len);\n\t\t\tif (ds) {\n\t\t\t\tr_str_ansi_strip (ds);\n\t\t\t\tr_str_replace_ch (ds, '\\n', 0, true);\n\t\t\t\tr_str_replace_ch (ds, '\\t', 0, true);\n\t\t\t\tvalue->string.content = ds;\n\t\t\t} else {\n\t\t\t\tvalue->string.content = NULL;\n\t\t\t}\n\t\t} else {\n\t\t\tvalue->string.content = NULL; // Means malformed DWARF, should we print error message?\n\t\t}\n\t\tbreak;\n\t// offset in .debug_info\n\tcase DW_FORM_ref_addr:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\tvalue->reference = dwarf_read_offset (hdr->is_64bit, &buf, buf_end);\n\t\tbreak;\n\t// This type of reference is an offset from the first byte of the compilation\n\t// header for the compilation unit containing the reference\n\tcase DW_FORM_ref1:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\tvalue->reference = hdr->unit_offset + READ8 (buf);\n\t\tbreak;\n\tcase DW_FORM_ref2:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\tvalue->reference = hdr->unit_offset + READ16 (buf);\n\t\tbreak;\n\tcase DW_FORM_ref4:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\tvalue->reference = hdr->unit_offset + READ32 (buf);\n\t\tbreak;\n\tcase DW_FORM_ref8:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\tvalue->reference = hdr->unit_offset + READ64 (buf);\n\t\tbreak;\n\tcase DW_FORM_ref_udata:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\t// uleb128 is enough to fit into ut64?\n\t\tbuf = r_uleb128 (buf, buf_end - buf, &value->reference, NULL);\n\t\tvalue->reference += hdr->unit_offset;\n\t\tbreak;\n\t// offset in a section other than .debug_info or .debug_str\n\tcase DW_FORM_sec_offset:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\tvalue->reference = dwarf_read_offset(hdr->is_64bit, &buf, buf_end);\n\t\tbreak;\n\tcase DW_FORM_exprloc:\n\t\tvalue->kind = DW_AT_KIND_BLOCK;\n\t\tbuf = r_uleb128 (buf, buf_end - buf, &value->block.length, NULL);\n\t\tif (!buf || buf >= buf_end) {\n\t\t\treturn NULL;\n\t\t}\n\t\tbuf = fill_block_data (buf, buf_end, &value->block);\n\t\tbreak;\n\t// this means that the flag is present, nothing is read\n\tcase DW_FORM_flag_present:\n\t\tvalue->kind = DW_AT_KIND_FLAG;\n\t\tvalue->flag = true;\n\t\tbreak;\n\tcase DW_FORM_ref_sig8:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\tvalue->reference = READ64 (buf);\n\t\tbreak;\n\t// offset into .debug_line_str section, can't parse the section now, so we just skip\n\tcase DW_FORM_strx:\n\t\tvalue->kind = DW_AT_KIND_STRING;\n\t\t// value->string.offset = dwarf_read_offset (hdr->is_64bit, &buf, buf_end);\n\t\t// if (debug_str && value->string.offset < debug_line_str_len) {\n\t\t// \tvalue->string.content =\n\t\t// \t\tstrdup ((const char *)(debug_str + value->string.offset));\n\t\t// } else {\n\t\t// \tvalue->string.content = NULL; // Means malformed DWARF, should we print error message?\n\t\t// }\n\t\tbreak;\n\tcase DW_FORM_strx1:\n\t\tvalue->kind = DW_AT_KIND_STRING;\n\t\tvalue->string.offset = READ8 (buf);\n\t\tbreak;\n\tcase DW_FORM_strx2:\n\t\tvalue->kind = DW_AT_KIND_STRING;\n\t\tvalue->string.offset = READ16 (buf);\n\t\tbreak;\n\tcase DW_FORM_strx3: // TODO Add 3 byte int read\n\t\tvalue->kind = DW_AT_KIND_STRING;\n\t\tbuf += 3;\n\t\tbreak;\n\tcase DW_FORM_strx4:\n\t\tvalue->kind = DW_AT_KIND_STRING;\n\t\tvalue->string.offset = READ32 (buf);\n\t\tbreak;\n\tcase DW_FORM_implicit_const:\n\t\tvalue->kind = DW_AT_KIND_CONSTANT;\n\t\tvalue->uconstant = def->special;\n\t\tbreak;\n\t/*  addrx* forms : The index is relative to the value of the\n\t\tDW_AT_addr_base attribute of the associated compilation unit.\n\t    index into an array of addresses in the .debug_addr section.*/\n\tcase DW_FORM_addrx:\n\t\tvalue->kind = DW_AT_KIND_ADDRESS;\n\t\tbuf = r_uleb128 (buf, buf_end - buf, &value->address, NULL);\n\t\tbreak;\n\tcase DW_FORM_addrx1:\n\t\tvalue->kind = DW_AT_KIND_ADDRESS;\n\t\tvalue->address = READ8 (buf);\n\t\tbreak;\n\tcase DW_FORM_addrx2:\n\t\tvalue->kind = DW_AT_KIND_ADDRESS;\n\t\tvalue->address = READ16 (buf);\n\t\tbreak;\n\tcase DW_FORM_addrx3:\n\t\t// I need to add 3byte endianess free read here TODO\n\t\tvalue->kind = DW_AT_KIND_ADDRESS;\n\t\tbuf += 3;\n\t\tbreak;\n\tcase DW_FORM_addrx4:\n\t\tvalue->kind = DW_AT_KIND_ADDRESS;\n\t\tvalue->address = READ32 (buf);\n\t\tbreak;\n\tcase DW_FORM_line_ptr: // offset in a section .debug_line_str\n\tcase DW_FORM_strp_sup: // offset in a section .debug_line_str\n\t\tvalue->kind = DW_AT_KIND_STRING;\n\t\tvalue->string.offset = dwarf_read_offset (hdr->is_64bit, &buf, buf_end);\n\t\t// if (debug_str && value->string.offset < debug_line_str_len) {\n\t\t// \tvalue->string.content =\n\t\t// \t\tstrdupsts\n\t\tbreak;\n\t// offset in the supplementary object file\n\tcase DW_FORM_ref_sup4:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\tvalue->reference = READ32 (buf);\n\t\tbreak;\n\tcase DW_FORM_ref_sup8:\n\t\tvalue->kind = DW_AT_KIND_REFERENCE;\n\t\tvalue->reference = READ64 (buf);\n\t\tbreak;\n\t// An index into the .debug_loc\n\tcase DW_FORM_loclistx:\n\t\tvalue->kind = DW_AT_KIND_LOCLISTPTR;\n\t\tvalue->reference = dwarf_read_offset (hdr->is_64bit, &buf, buf_end);\n\t\tbreak;\n\t // An index into the .debug_rnglists\n\tcase DW_FORM_rnglistx:\n\t\tvalue->kind = DW_AT_KIND_ADDRESS;\n\t\tbuf = r_uleb128 (buf, buf_end - buf, &value->address, NULL);\n\t\tbreak;\n\tcase 0:\n\t\tvalue->uconstant = 0;\n\t\treturn NULL;\n\tdefault:\n\t\tR_LOG_WARN (\"Unknown DW_FORM 0x%02\" PFMT64x, def->attr_form);\n\t\tvalue->uconstant = 0;\n\t\treturn NULL;\n\t}\n\treturn buf;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -72,7 +72,15 @@\n \t\tbreak;\n \tcase DW_FORM_string:\n \t\tvalue->kind = DW_AT_KIND_STRING;\n-\t\tvalue->string.content = *buf ? r_str_ndup ((const char *)buf, buf_end - buf) : NULL;\n+\t\tif (*buf) {\n+\t\t\tchar *name = r_str_ndup ((const char *)buf, buf_end - buf);\n+\t\t\tr_str_ansi_strip (name);\n+\t\t\tr_str_replace_ch (name, '\\n', 0, true);\n+\t\t\tr_str_replace_ch (name, '\\t', 0, true);\n+\t\t\tvalue->string.content = name;\n+\t\t} else {\n+\t\t\tvalue->string.content = NULL;\n+\t\t}\n \t\tif (value->string.content) {\n \t\t\tbuf += strlen (value->string.content) + 1;\n \t\t}\n@@ -117,8 +125,15 @@\n \t\tvalue->kind = DW_AT_KIND_STRING;\n \t\tvalue->string.offset = dwarf_read_offset (hdr->is_64bit, &buf, buf_end);\n \t\tif (debug_str && value->string.offset < debug_str_len) {\n-\t\t\tconst char *ds = (const char *)(debug_str + value->string.offset);\n-\t\t\tvalue->string.content = strdup (ds); // r_str_ndup (ds, debug_str_len - value->string.offset);\n+\t\t\tchar *ds = r_str_ndup ((const char *)(debug_str + value->string.offset), debug_str_len);\n+\t\t\tif (ds) {\n+\t\t\t\tr_str_ansi_strip (ds);\n+\t\t\t\tr_str_replace_ch (ds, '\\n', 0, true);\n+\t\t\t\tr_str_replace_ch (ds, '\\t', 0, true);\n+\t\t\t\tvalue->string.content = ds;\n+\t\t\t} else {\n+\t\t\t\tvalue->string.content = NULL;\n+\t\t\t}\n \t\t} else {\n \t\t\tvalue->string.content = NULL; // Means malformed DWARF, should we print error message?\n \t\t}",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tvalue->string.content = *buf ? r_str_ndup ((const char *)buf, buf_end - buf) : NULL;",
                "\t\t\tconst char *ds = (const char *)(debug_str + value->string.offset);",
                "\t\t\tvalue->string.content = strdup (ds); // r_str_ndup (ds, debug_str_len - value->string.offset);"
            ],
            "added_lines": [
                "\t\tif (*buf) {",
                "\t\t\tchar *name = r_str_ndup ((const char *)buf, buf_end - buf);",
                "\t\t\tr_str_ansi_strip (name);",
                "\t\t\tr_str_replace_ch (name, '\\n', 0, true);",
                "\t\t\tr_str_replace_ch (name, '\\t', 0, true);",
                "\t\t\tvalue->string.content = name;",
                "\t\t} else {",
                "\t\t\tvalue->string.content = NULL;",
                "\t\t}",
                "\t\t\tchar *ds = r_str_ndup ((const char *)(debug_str + value->string.offset), debug_str_len);",
                "\t\t\tif (ds) {",
                "\t\t\t\tr_str_ansi_strip (ds);",
                "\t\t\t\tr_str_replace_ch (ds, '\\n', 0, true);",
                "\t\t\t\tr_str_replace_ch (ds, '\\t', 0, true);",
                "\t\t\t\tvalue->string.content = ds;",
                "\t\t\t} else {",
                "\t\t\t\tvalue->string.content = NULL;",
                "\t\t\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-0302",
        "func_name": "radareorg/radare2/add_sdb_addrline",
        "description": "Failure to Sanitize Special Elements into a Different Plane (Special Element Injection) in GitHub repository radareorg/radare2 prior to 5.8.2.",
        "git_url": "https://github.com/radareorg/radare2/commit/961f0e723903011d4f54c2396e44efa91fcc74ce",
        "commit_title": "Fix ANSI Escape Sequence Injection vulns via DWARF ##vuln",
        "commit_text": " * Reported by @solid-snail via huntrdev\r * BountyID: 583133af-7ae6-4a21-beef-a4b0182cf82e\r * Reproducer: dwarf_test_func_patched",
        "func_before": "static inline void add_sdb_addrline(Sdb *s, ut64 addr, const char *file, ut64 line, int mode, PrintfCallback print) {\n\tconst char *p;\n\tchar *fileline;\n\tchar offset[SDB_NUM_BUFSZ];\n\tchar *offset_ptr;\n\n\tif (!s || !file) {\n\t\treturn;\n\t}\n\tp = r_str_rchr (file, NULL, '/');\n\tif (p) {\n\t\tp++;\n\t} else {\n\t\tp = file;\n\t}\n\t// includedirs and properly check full paths\n\tswitch (mode) {\n\tcase 1:\n\tcase 'r':\n\tcase '*':\n\t\tprint (\"CL %s:%d 0x%08\"PFMT64x\"\\n\", p, (int)line, addr);\n\t\tbreak;\n\t}\n#if 0\n\t/* THIS IS TOO SLOW */\n\tif (r_file_exists (file)) {\n\t\tp = file;\n\t}\n#else\n\tp = file;\n#endif\n\tfileline = r_str_newf (\"%s|%\"PFMT64d, p, line);\n\toffset_ptr = sdb_itoa (addr, 16, offset, sizeof (offset));\n\tsdb_add (s, offset_ptr, fileline, 0);\n\tsdb_add (s, fileline, offset_ptr, 0);\n\tfree (fileline);\n}",
        "func": "static inline void add_sdb_addrline(Sdb *s, ut64 addr, const char *file, ut64 line, int mode, PrintfCallback print) {\n\tconst char *p;\n\tchar offset[SDB_NUM_BUFSZ];\n\tchar *offset_ptr;\n\n\tif (!s || !file) {\n\t\treturn;\n\t}\n\tp = r_str_rchr (file, NULL, '/');\n\tif (p) {\n\t\tp++;\n\t} else {\n\t\tp = file;\n\t}\n\t// includedirs and properly check full paths\n\tswitch (mode) {\n\tcase 1:\n\tcase 'r':\n\tcase '*':\n\t\tprint (\"CL %s:%d 0x%08\"PFMT64x\"\\n\", p, (int)line, addr);\n\t\tbreak;\n\t}\n#if 0\n\t/* THIS IS TOO SLOW */\n\tif (r_file_exists (file)) {\n\t\tp = file;\n\t}\n#else\n\tp = file;\n#endif\n\tchar *fileline = r_str_newf (\"%s|%\"PFMT64d, p, line);\n\tr_str_ansi_strip (fileline);\n\tr_str_replace_ch (fileline, '\\n', 0, true);\n\tr_str_replace_ch (fileline, '\\t', 0, true);\n\toffset_ptr = sdb_itoa (addr, 16, offset, sizeof (offset));\n\tsdb_add (s, offset_ptr, fileline, 0);\n\tsdb_add (s, fileline, offset_ptr, 0);\n\tfree (fileline);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,5 @@\n static inline void add_sdb_addrline(Sdb *s, ut64 addr, const char *file, ut64 line, int mode, PrintfCallback print) {\n \tconst char *p;\n-\tchar *fileline;\n \tchar offset[SDB_NUM_BUFSZ];\n \tchar *offset_ptr;\n \n@@ -29,7 +28,10 @@\n #else\n \tp = file;\n #endif\n-\tfileline = r_str_newf (\"%s|%\"PFMT64d, p, line);\n+\tchar *fileline = r_str_newf (\"%s|%\"PFMT64d, p, line);\n+\tr_str_ansi_strip (fileline);\n+\tr_str_replace_ch (fileline, '\\n', 0, true);\n+\tr_str_replace_ch (fileline, '\\t', 0, true);\n \toffset_ptr = sdb_itoa (addr, 16, offset, sizeof (offset));\n \tsdb_add (s, offset_ptr, fileline, 0);\n \tsdb_add (s, fileline, offset_ptr, 0);",
        "diff_line_info": {
            "deleted_lines": [
                "\tchar *fileline;",
                "\tfileline = r_str_newf (\"%s|%\"PFMT64d, p, line);"
            ],
            "added_lines": [
                "\tchar *fileline = r_str_newf (\"%s|%\"PFMT64d, p, line);",
                "\tr_str_ansi_strip (fileline);",
                "\tr_str_replace_ch (fileline, '\\n', 0, true);",
                "\tr_str_replace_ch (fileline, '\\t', 0, true);"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-0302",
        "func_name": "radareorg/radare2/parse_line_header_source",
        "description": "Failure to Sanitize Special Elements into a Different Plane (Special Element Injection) in GitHub repository radareorg/radare2 prior to 5.8.2.",
        "git_url": "https://github.com/radareorg/radare2/commit/961f0e723903011d4f54c2396e44efa91fcc74ce",
        "commit_title": "Fix ANSI Escape Sequence Injection vulns via DWARF ##vuln",
        "commit_text": " * Reported by @solid-snail via huntrdev\r * BountyID: 583133af-7ae6-4a21-beef-a4b0182cf82e\r * Reproducer: dwarf_test_func_patched",
        "func_before": "static const ut8 *parse_line_header_source(RBinFile *bf, const ut8 *buf, const ut8 *buf_end,\n\tRBinDwarfLineHeader *hdr, Sdb *sdb, int mode, PrintfCallback print) {\n\tint i = 0;\n\tsize_t count;\n\tconst ut8 *tmp_buf = NULL;\n\n\tif (mode == R_MODE_PRINT) {\n\t\tprint (\" The Directory Table:\\n\");\n\t}\n\twhile (buf + 1 < buf_end) {\n\t\tsize_t maxlen = R_MIN ((size_t) (buf_end - buf) - 1, 0xfff);\n\t\tsize_t len = r_str_nlen ((const char *)buf, maxlen);\n\t\tchar *str = r_str_ndup ((const char *)buf, len);\n\t\tif (len < 1 || len >= 0xfff || !str) {\n\t\t\tbuf += 1;\n\t\t\tfree (str);\n\t\t\tbreak;\n\t\t}\n\t\tif (mode == R_MODE_PRINT) {\n\t\t\tprint (\"  %d     %s\\n\", i + 1, str);\n\t\t}\n\t\tadd_sdb_include_dir (sdb, str, i);\n\t\tfree (str);\n\t\ti++;\n\t\tbuf += len + 1;\n\t}\n\n\ttmp_buf = buf;\n\tcount = 0;\n\tif (mode == R_MODE_PRINT) {\n\t\tprint (\"\\n\");\n\t\tprint (\" The File Name Table:\\n\");\n\t\tprint (\"  Entry Dir     Time      Size       Name\\n\");\n\t}\n\tint entry_index = 1; // used for printing information\n\n\tfor (i = 0; i < 2; i++) {\n\t\twhile (buf + 1 < buf_end) {\n\t\t\tconst char *filename = (const char *)buf;\n\t\t\tsize_t maxlen = R_MIN ((size_t) (buf_end - buf - 1), 0xfff);\n\t\t\tut64 id_idx, mod_time, file_len;\n\t\t\tsize_t len = r_str_nlen (filename, maxlen);\n\n\t\t\tif (!len) {\n\t\t\t\tbuf++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbuf += len + 1;\n\t\t\tif (buf >= buf_end) {\n\t\t\t\tbuf = NULL;\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tbuf = r_uleb128 (buf, buf_end - buf, &id_idx, NULL);\n\t\t\tif (buf >= buf_end) {\n\t\t\t\tbuf = NULL;\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tbuf = r_uleb128 (buf, buf_end - buf, &mod_time, NULL);\n\t\t\tif (buf >= buf_end) {\n\t\t\t\tbuf = NULL;\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tbuf = r_uleb128 (buf, buf_end - buf, &file_len, NULL);\n\t\t\tif (buf >= buf_end) {\n\t\t\t\tbuf = NULL;\n\t\t\t\tgoto beach;\n\t\t\t}\n\n\t\t\tif (i) {\n\t\t\t\tchar *include_dir = NULL, *comp_dir = NULL, *pinclude_dir = NULL;\n\t\t\t\tif (id_idx > 0) {\n\t\t\t\t\tinclude_dir = pinclude_dir = sdb_array_get (sdb, \"includedirs\", id_idx - 1, 0);\n\t\t\t\t\tif (include_dir && include_dir[0] != '/') {\n\t\t\t\t\t\tcomp_dir = sdb_get (bf->sdb_addrinfo, \"DW_AT_comp_dir\", 0);\n\t\t\t\t\t\tif (comp_dir) {\n\t\t\t\t\t\t\tinclude_dir = r_str_newf (\"%s/%s/\", comp_dir, include_dir);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tinclude_dir = pinclude_dir = sdb_get (bf->sdb_addrinfo, \"DW_AT_comp_dir\", 0);\n\t\t\t\t\tif (!include_dir) {\n\t\t\t\t\t\tinclude_dir = \"./\";\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (hdr->file_names) {\n\t\t\t\t\thdr->file_names[count].name = r_str_newf(\"%s/%s\", r_str_get (include_dir), filename);\n\t\t\t\t\thdr->file_names[count].id_idx = id_idx;\n\t\t\t\t\thdr->file_names[count].mod_time = mod_time;\n\t\t\t\t\thdr->file_names[count].file_len = file_len;\n\t\t\t\t}\n\t\t\t\tif (comp_dir) {\n\t\t\t\t\tR_FREE (include_dir);\n\t\t\t\t\tR_FREE (comp_dir);\n\t\t\t\t}\n\t\t\t\tR_FREE (pinclude_dir);\n\t\t\t}\n\t\t\tcount++;\n\t\t\tif (mode == R_MODE_PRINT && i) {\n\t\t\t\tprint (\"  %d     %\" PFMT64d \"       %\" PFMT64d \"         %\" PFMT64d \"          %s\\n\", entry_index++, id_idx, mod_time, file_len, filename);\n\t\t\t}\n\t\t}\n\t\tif (i == 0) {\n\t\t\tif (count > 0) {\n\t\t\t\thdr->file_names = calloc (sizeof (file_entry), count);\n\t\t\t} else {\n\t\t\t\thdr->file_names = NULL;\n\t\t\t}\n\t\t\thdr->file_names_count = count;\n\t\t\tbuf = tmp_buf;\n\t\t\tcount = 0;\n\t\t}\n\t}\n\tif (mode == R_MODE_PRINT) {\n\t\tprint (\"\\n\");\n\t}\n\nbeach:\n\tsdb_free (sdb);\n\n\treturn buf;\n}",
        "func": "static const ut8 *parse_line_header_source(RBinFile *bf, const ut8 *buf, const ut8 *buf_end,\n\tRBinDwarfLineHeader *hdr, Sdb *sdb, int mode, PrintfCallback print) {\n\tint i = 0;\n\tsize_t count;\n\tconst ut8 *tmp_buf = NULL;\n\tchar *fn = NULL;\n\n\tif (mode == R_MODE_PRINT) {\n\t\tprint (\" The Directory Table:\\n\");\n\t}\n\twhile (buf + 1 < buf_end) {\n\t\tsize_t maxlen = R_MIN ((size_t) (buf_end - buf) - 1, 0xfff);\n\t\tsize_t len = r_str_nlen ((const char *)buf, maxlen);\n\t\tchar *str = r_str_ndup ((const char *)buf, len);\n\t\tif (len < 1 || len >= 0xfff || !str) {\n\t\t\tbuf += 1;\n\t\t\tfree (str);\n\t\t\tbreak;\n\t\t}\n\t\tif (mode == R_MODE_PRINT) {\n\t\t\tprint (\"  %d     %s\\n\", i + 1, str);\n\t\t}\n\t\tadd_sdb_include_dir (sdb, str, i);\n\t\tfree (str);\n\t\ti++;\n\t\tbuf += len + 1;\n\t}\n\n\ttmp_buf = buf;\n\tcount = 0;\n\tif (mode == R_MODE_PRINT) {\n\t\tprint (\"\\n\");\n\t\tprint (\" The File Name Table:\\n\");\n\t\tprint (\"  Entry Dir     Time      Size       Name\\n\");\n\t}\n\tint entry_index = 1; // used for printing information\n\n\tfor (i = 0; i < 2; i++) {\n\t\twhile (buf + 1 < buf_end) {\n\t\t\tsize_t maxlen = R_MIN ((size_t) (buf_end - buf - 1), 0xfff);\n\t\t\tut64 id_idx, mod_time, file_len;\n\t\t\tfree (fn);\n\t\t\tfn = r_str_ndup ((const char *)buf, maxlen);\n\t\t\tr_str_ansi_strip (fn);\n\t\t\tsize_t len = strlen (fn);\n\n\t\t\tif (!len) {\n\t\t\t\tbuf++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbuf += len + 1;\n\t\t\tif (buf >= buf_end) {\n\t\t\t\tbuf = NULL;\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tbuf = r_uleb128 (buf, buf_end - buf, &id_idx, NULL);\n\t\t\tif (buf >= buf_end) {\n\t\t\t\tbuf = NULL;\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tbuf = r_uleb128 (buf, buf_end - buf, &mod_time, NULL);\n\t\t\tif (buf >= buf_end) {\n\t\t\t\tbuf = NULL;\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tbuf = r_uleb128 (buf, buf_end - buf, &file_len, NULL);\n\t\t\tif (buf >= buf_end) {\n\t\t\t\tbuf = NULL;\n\t\t\t\tgoto beach;\n\t\t\t}\n\n\t\t\tif (i) {\n\t\t\t\tchar *include_dir = NULL, *comp_dir = NULL, *pinclude_dir = NULL;\n\t\t\t\tif (id_idx > 0) {\n\t\t\t\t\tinclude_dir = pinclude_dir = sdb_array_get (sdb, \"includedirs\", id_idx - 1, 0);\n\t\t\t\t\tif (include_dir && include_dir[0] != '/') {\n\t\t\t\t\t\tcomp_dir = sdb_get (bf->sdb_addrinfo, \"DW_AT_comp_dir\", 0);\n\t\t\t\t\t\tif (comp_dir) {\n\t\t\t\t\t\t\tinclude_dir = r_str_newf (\"%s/%s/\", comp_dir, include_dir);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tinclude_dir = pinclude_dir = sdb_get (bf->sdb_addrinfo, \"DW_AT_comp_dir\", 0);\n\t\t\t\t\tif (!include_dir) {\n\t\t\t\t\t\tinclude_dir = \"./\";\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (hdr->file_names) {\n\t\t\t\t\thdr->file_names[count].name = r_str_newf(\"%s/%s\", r_str_get (include_dir), fn);\n\t\t\t\t\thdr->file_names[count].id_idx = id_idx;\n\t\t\t\t\thdr->file_names[count].mod_time = mod_time;\n\t\t\t\t\thdr->file_names[count].file_len = file_len;\n\t\t\t\t}\n\t\t\t\tif (comp_dir) {\n\t\t\t\t\tR_FREE (include_dir);\n\t\t\t\t\tR_FREE (comp_dir);\n\t\t\t\t}\n\t\t\t\tR_FREE (pinclude_dir);\n\t\t\t}\n\t\t\tcount++;\n\t\t\tif (mode == R_MODE_PRINT && i) {\n\t\t\t\tprint (\"  %d     %\" PFMT64d \"       %\" PFMT64d \"         %\" PFMT64d \"          %s\\n\",\n\t\t\t\t\t\tentry_index++, id_idx, mod_time, file_len, fn);\n\t\t\t}\n\t\t}\n\t\tif (i == 0) {\n\t\t\tif (count > 0) {\n\t\t\t\thdr->file_names = calloc (sizeof (file_entry), count);\n\t\t\t} else {\n\t\t\t\thdr->file_names = NULL;\n\t\t\t}\n\t\t\thdr->file_names_count = count;\n\t\t\tbuf = tmp_buf;\n\t\t\tcount = 0;\n\t\t}\n\t}\n\tif (mode == R_MODE_PRINT) {\n\t\tprint (\"\\n\");\n\t}\n\nbeach:\n\tfree (fn);\n\tsdb_free (sdb);\n\n\treturn buf;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,6 +3,7 @@\n \tint i = 0;\n \tsize_t count;\n \tconst ut8 *tmp_buf = NULL;\n+\tchar *fn = NULL;\n \n \tif (mode == R_MODE_PRINT) {\n \t\tprint (\" The Directory Table:\\n\");\n@@ -36,10 +37,12 @@\n \n \tfor (i = 0; i < 2; i++) {\n \t\twhile (buf + 1 < buf_end) {\n-\t\t\tconst char *filename = (const char *)buf;\n \t\t\tsize_t maxlen = R_MIN ((size_t) (buf_end - buf - 1), 0xfff);\n \t\t\tut64 id_idx, mod_time, file_len;\n-\t\t\tsize_t len = r_str_nlen (filename, maxlen);\n+\t\t\tfree (fn);\n+\t\t\tfn = r_str_ndup ((const char *)buf, maxlen);\n+\t\t\tr_str_ansi_strip (fn);\n+\t\t\tsize_t len = strlen (fn);\n \n \t\t\tif (!len) {\n \t\t\t\tbuf++;\n@@ -84,7 +87,7 @@\n \t\t\t\t}\n \n \t\t\t\tif (hdr->file_names) {\n-\t\t\t\t\thdr->file_names[count].name = r_str_newf(\"%s/%s\", r_str_get (include_dir), filename);\n+\t\t\t\t\thdr->file_names[count].name = r_str_newf(\"%s/%s\", r_str_get (include_dir), fn);\n \t\t\t\t\thdr->file_names[count].id_idx = id_idx;\n \t\t\t\t\thdr->file_names[count].mod_time = mod_time;\n \t\t\t\t\thdr->file_names[count].file_len = file_len;\n@@ -97,7 +100,8 @@\n \t\t\t}\n \t\t\tcount++;\n \t\t\tif (mode == R_MODE_PRINT && i) {\n-\t\t\t\tprint (\"  %d     %\" PFMT64d \"       %\" PFMT64d \"         %\" PFMT64d \"          %s\\n\", entry_index++, id_idx, mod_time, file_len, filename);\n+\t\t\t\tprint (\"  %d     %\" PFMT64d \"       %\" PFMT64d \"         %\" PFMT64d \"          %s\\n\",\n+\t\t\t\t\t\tentry_index++, id_idx, mod_time, file_len, fn);\n \t\t\t}\n \t\t}\n \t\tif (i == 0) {\n@@ -116,6 +120,7 @@\n \t}\n \n beach:\n+\tfree (fn);\n \tsdb_free (sdb);\n \n \treturn buf;",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\tconst char *filename = (const char *)buf;",
                "\t\t\tsize_t len = r_str_nlen (filename, maxlen);",
                "\t\t\t\t\thdr->file_names[count].name = r_str_newf(\"%s/%s\", r_str_get (include_dir), filename);",
                "\t\t\t\tprint (\"  %d     %\" PFMT64d \"       %\" PFMT64d \"         %\" PFMT64d \"          %s\\n\", entry_index++, id_idx, mod_time, file_len, filename);"
            ],
            "added_lines": [
                "\tchar *fn = NULL;",
                "\t\t\tfree (fn);",
                "\t\t\tfn = r_str_ndup ((const char *)buf, maxlen);",
                "\t\t\tr_str_ansi_strip (fn);",
                "\t\t\tsize_t len = strlen (fn);",
                "\t\t\t\t\thdr->file_names[count].name = r_str_newf(\"%s/%s\", r_str_get (include_dir), fn);",
                "\t\t\t\tprint (\"  %d     %\" PFMT64d \"       %\" PFMT64d \"         %\" PFMT64d \"          %s\\n\",",
                "\t\t\t\t\t\tentry_index++, id_idx, mod_time, file_len, fn);",
                "\tfree (fn);"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-0302",
        "func_name": "radareorg/radare2/meta_set",
        "description": "Failure to Sanitize Special Elements into a Different Plane (Special Element Injection) in GitHub repository radareorg/radare2 prior to 5.8.2.",
        "git_url": "https://github.com/radareorg/radare2/commit/961f0e723903011d4f54c2396e44efa91fcc74ce",
        "commit_title": "Fix ANSI Escape Sequence Injection vulns via DWARF ##vuln",
        "commit_text": " * Reported by @solid-snail via huntrdev\r * BountyID: 583133af-7ae6-4a21-beef-a4b0182cf82e\r * Reproducer: dwarf_test_func_patched",
        "func_before": "static bool meta_set(RAnal *a, RAnalMetaType type, int subtype, ut64 from, ut64 to, const char *str) {\n\tif (to < from) {\n\t\treturn false;\n\t}\n\tRSpace *space = r_spaces_current (&a->meta_spaces);\n\tRIntervalNode *node = find_node_at (a, type, space, from);\n\tRAnalMetaItem *item = node ? node->data : R_NEW0 (RAnalMetaItem);\n\tif (!item) {\n\t\treturn false;\n\t}\n\titem->type = type;\n\titem->subtype = subtype;\n\titem->space = space;\n\tfree (item->str);\n\titem->str = str ? strdup (str) : NULL;\n\tif (str && !item->str) {\n\t\tif (!node) { // If we just created this\n\t\t\tfree (item);\n\t\t}\n\t\treturn false;\n\t}\n\tR_DIRTY (a);\n\tif (!node) {\n\t\tr_interval_tree_insert (&a->meta, from, to, item);\n\t} else if (node->end != to) {\n\t\tr_interval_tree_resize (&a->meta, node, from, to);\n\t}\n\treturn true;\n}",
        "func": "static bool meta_set(RAnal *a, RAnalMetaType type, int subtype, ut64 from, ut64 to, const char *str) {\n\tif (to < from) {\n\t\treturn false;\n\t}\n\tRSpace *space = r_spaces_current (&a->meta_spaces);\n\tRIntervalNode *node = find_node_at (a, type, space, from);\n\tRAnalMetaItem *item = node ? node->data : R_NEW0 (RAnalMetaItem);\n\tif (!item) {\n\t\treturn false;\n\t}\n\titem->type = type;\n\titem->subtype = subtype;\n\titem->space = space;\n\tfree (item->str);\n\tif (R_STR_ISNOTEMPTY (str)) {\n\t\titem->str = strdup (str);\n\t\t// this breaks the `ecHw` command\n\t\t// (highlights word in current instruction, which uses ansi\n\t\t// r_str_ansi_strip (item->str);\n\t} else {\n\t\titem->str = NULL;\n\t}\n\tR_DIRTY (a);\n\tif (!node) {\n\t\tr_interval_tree_insert (&a->meta, from, to, item);\n\t} else if (node->end != to) {\n\t\tr_interval_tree_resize (&a->meta, node, from, to);\n\t}\n\treturn true;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -12,12 +12,13 @@\n \titem->subtype = subtype;\n \titem->space = space;\n \tfree (item->str);\n-\titem->str = str ? strdup (str) : NULL;\n-\tif (str && !item->str) {\n-\t\tif (!node) { // If we just created this\n-\t\t\tfree (item);\n-\t\t}\n-\t\treturn false;\n+\tif (R_STR_ISNOTEMPTY (str)) {\n+\t\titem->str = strdup (str);\n+\t\t// this breaks the `ecHw` command\n+\t\t// (highlights word in current instruction, which uses ansi\n+\t\t// r_str_ansi_strip (item->str);\n+\t} else {\n+\t\titem->str = NULL;\n \t}\n \tR_DIRTY (a);\n \tif (!node) {",
        "diff_line_info": {
            "deleted_lines": [
                "\titem->str = str ? strdup (str) : NULL;",
                "\tif (str && !item->str) {",
                "\t\tif (!node) { // If we just created this",
                "\t\t\tfree (item);",
                "\t\t}",
                "\t\treturn false;"
            ],
            "added_lines": [
                "\tif (R_STR_ISNOTEMPTY (str)) {",
                "\t\titem->str = strdup (str);",
                "\t\t// this breaks the `ecHw` command",
                "\t\t// (highlights word in current instruction, which uses ansi",
                "\t\t// r_str_ansi_strip (item->str);",
                "\t} else {",
                "\t\titem->str = NULL;"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-0302",
        "func_name": "radareorg/radare2/r_cons_hud_line_string",
        "description": "Failure to Sanitize Special Elements into a Different Plane (Special Element Injection) in GitHub repository radareorg/radare2 prior to 5.8.2.",
        "git_url": "https://github.com/radareorg/radare2/commit/961f0e723903011d4f54c2396e44efa91fcc74ce",
        "commit_title": "Fix ANSI Escape Sequence Injection vulns via DWARF ##vuln",
        "commit_text": " * Reported by @solid-snail via huntrdev\r * BountyID: 583133af-7ae6-4a21-beef-a4b0182cf82e\r * Reproducer: dwarf_test_func_patched",
        "func_before": "R_API char *r_cons_hud_line_string(const char *s) {\n\tif (!r_cons_is_interactive ()) {\n\t\tR_LOG_ERROR (\"Hud mode requires scr.interactive=true\");\n\t\treturn NULL;\n\t}\n\tchar *os, *track, *ret, *o = strdup (s);\n\tif (!o) {\n\t\treturn NULL;\n\t}\n\tr_str_replace_ch (o, '\\r', 0, true);\n\tr_str_replace_ch (o, '\\t', 0, true);\n\tRList *fl = r_list_new ();\n\tint i;\n\tif (!fl) {\n\t\tfree (o);\n\t\treturn NULL;\n\t}\n\tfl->free = free;\n\tfor (os = o, i = 0; o[i]; i++) {\n\t\tif (o[i] == '\\n') {\n\t\t\to[i] = 0;\n\t\t\tif (*os && *os != '#') {\n\t\t\t\ttrack = strdup (os);\n\t\t\t\tif (!r_list_append (fl, track)) {\n\t\t\t\t\tfree (track);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tos = o + i + 1;\n\t\t}\n\t}\n\tret = r_cons_hud_line (fl, NULL);\n\tfree (o);\n\tr_list_free (fl);\n\treturn ret;\n}",
        "func": "R_API char *r_cons_hud_line_string(const char *s) {\n\tif (!r_cons_is_interactive ()) {\n\t\tR_LOG_ERROR (\"Hud mode requires scr.interactive=true\");\n\t\treturn NULL;\n\t}\n\tchar *os, *track, *ret, *o = strdup (s);\n\tif (!o) {\n\t\treturn NULL;\n\t}\n\tr_str_replace_ch (o, '\\r', 0, true);\n\tr_str_replace_ch (o, '\\t', 0, true);\n\tr_str_ansi_strip (o);\n\tRList *fl = r_list_new ();\n\tint i;\n\tif (!fl) {\n\t\tfree (o);\n\t\treturn NULL;\n\t}\n\tfl->free = free;\n\tfor (os = o, i = 0; o[i]; i++) {\n\t\tif (o[i] == '\\n') {\n\t\t\to[i] = 0;\n\t\t\tif (*os && *os != '#') {\n\t\t\t\ttrack = strdup (os);\n\t\t\t\tif (!r_list_append (fl, track)) {\n\t\t\t\t\tfree (track);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tos = o + i + 1;\n\t\t}\n\t}\n\tret = r_cons_hud_line (fl, NULL);\n\tfree (o);\n\tr_list_free (fl);\n\treturn ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -9,6 +9,7 @@\n \t}\n \tr_str_replace_ch (o, '\\r', 0, true);\n \tr_str_replace_ch (o, '\\t', 0, true);\n+\tr_str_ansi_strip (o);\n \tRList *fl = r_list_new ();\n \tint i;\n \tif (!fl) {",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tr_str_ansi_strip (o);"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-0302",
        "func_name": "radareorg/radare2/r_cons_hud_string",
        "description": "Failure to Sanitize Special Elements into a Different Plane (Special Element Injection) in GitHub repository radareorg/radare2 prior to 5.8.2.",
        "git_url": "https://github.com/radareorg/radare2/commit/961f0e723903011d4f54c2396e44efa91fcc74ce",
        "commit_title": "Fix ANSI Escape Sequence Injection vulns via DWARF ##vuln",
        "commit_text": " * Reported by @solid-snail via huntrdev\r * BountyID: 583133af-7ae6-4a21-beef-a4b0182cf82e\r * Reproducer: dwarf_test_func_patched",
        "func_before": "R_API char *r_cons_hud_string(const char *s) {\n\tif (!r_cons_is_interactive ()) {\n\t\tR_LOG_ERROR (\"Hud mode requires scr.interactive=true\");\n\t\treturn NULL;\n\t}\n\tchar *os, *track, *ret, *o = strdup (s);\n\tif (!o) {\n\t\treturn NULL;\n\t}\n\tr_str_replace_ch (o, '\\r', 0, true);\n\tr_str_replace_ch (o, '\\t', 0, true);\n\tRList *fl = r_list_new ();\n\tint i;\n\tif (!fl) {\n\t\tfree (o);\n\t\treturn NULL;\n\t}\n\tfl->free = free;\n\tfor (os = o, i = 0; o[i]; i++) {\n\t\tif (o[i] == '\\n') {\n\t\t\to[i] = 0;\n\t\t\tif (*os && *os != '#') {\n\t\t\t\ttrack = strdup (os);\n\t\t\t\tif (!r_list_append (fl, track)) {\n\t\t\t\t\tfree (track);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tos = o + i + 1;\n\t\t}\n\t}\n\tret = r_cons_hud (fl, NULL);\n\tfree (o);\n\tr_list_free (fl);\n\treturn ret;\n}",
        "func": "R_API char *r_cons_hud_string(const char *s) {\n\tif (!r_cons_is_interactive ()) {\n\t\tR_LOG_ERROR (\"Hud mode requires scr.interactive=true\");\n\t\treturn NULL;\n\t}\n\tchar *os, *track, *ret, *o = strdup (s);\n\tif (!o) {\n\t\treturn NULL;\n\t}\n\tr_str_ansi_strip (o);\n\tr_str_replace_ch (o, '\\r', 0, true);\n\tr_str_replace_ch (o, '\\t', 0, true);\n\tRList *fl = r_list_new ();\n\tint i;\n\tif (!fl) {\n\t\tfree (o);\n\t\treturn NULL;\n\t}\n\tfl->free = free;\n\tfor (os = o, i = 0; o[i]; i++) {\n\t\tif (o[i] == '\\n') {\n\t\t\to[i] = 0;\n\t\t\tif (*os && *os != '#') {\n\t\t\t\ttrack = strdup (os);\n\t\t\t\tif (!r_list_append (fl, track)) {\n\t\t\t\t\tfree (track);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tos = o + i + 1;\n\t\t}\n\t}\n\tret = r_cons_hud (fl, NULL);\n\tfree (o);\n\tr_list_free (fl);\n\treturn ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -7,6 +7,7 @@\n \tif (!o) {\n \t\treturn NULL;\n \t}\n+\tr_str_ansi_strip (o);\n \tr_str_replace_ch (o, '\\r', 0, true);\n \tr_str_replace_ch (o, '\\t', 0, true);\n \tRList *fl = r_list_new ();",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tr_str_ansi_strip (o);"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-0302",
        "func_name": "radareorg/radare2/r_cons_hud_file",
        "description": "Failure to Sanitize Special Elements into a Different Plane (Special Element Injection) in GitHub repository radareorg/radare2 prior to 5.8.2.",
        "git_url": "https://github.com/radareorg/radare2/commit/961f0e723903011d4f54c2396e44efa91fcc74ce",
        "commit_title": "Fix ANSI Escape Sequence Injection vulns via DWARF ##vuln",
        "commit_text": " * Reported by @solid-snail via huntrdev\r * BountyID: 583133af-7ae6-4a21-beef-a4b0182cf82e\r * Reproducer: dwarf_test_func_patched",
        "func_before": "R_API char *r_cons_hud_file(const char *f) {\n\tchar *s = r_file_slurp (f, NULL);\n\tif (s) {\n\t\tchar *ret = r_cons_hud_string (s);\n\t\tfree (s);\n\t\treturn ret;\n\t}\n\treturn NULL;\n}",
        "func": "R_API char *r_cons_hud_file(const char *f) {\n\tchar *s = r_file_slurp (f, NULL);\n\tif (s) {\n\t\tr_str_ansi_strip (s);\n\t\tchar *ret = r_cons_hud_string (s);\n\t\tfree (s);\n\t\treturn ret;\n\t}\n\treturn NULL;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,7 @@\n R_API char *r_cons_hud_file(const char *f) {\n \tchar *s = r_file_slurp (f, NULL);\n \tif (s) {\n+\t\tr_str_ansi_strip (s);\n \t\tchar *ret = r_cons_hud_string (s);\n \t\tfree (s);\n \t\treturn ret;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\tr_str_ansi_strip (s);"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-7703",
        "func_name": "wireshark/dissect_imap",
        "description": "In Wireshark 2.2.0 to 2.2.5 and 2.0.0 to 2.0.11, the IMAP dissector could crash, triggered by packet injection or a malformed capture file. This was addressed in epan/dissectors/packet-imap.c by calculating a line's end correctly.",
        "git_url": "https://github.com/wireshark/wireshark/commit/671e32820ab29d41d712cc8a472eab9b672684d9",
        "commit_title": "imap: Give correct lineend to get_token_len()",
        "commit_text": " The return value from get_token_len() is the token length, but the returned next_token can have a offset more than token length because it also skip trailing blanks.  Ensure we always give correct lineend.  Bug: 13466 (cherry picked from commit eb046064ff0f064896ad60508876b8a764fbbca9)",
        "func_before": "static void\ndissect_imap(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)\n{\n  gboolean        is_request;\n  proto_tree      *imap_tree, *reqresp_tree;\n  proto_item      *ti, *hidden_item;\n  gint            offset = 0;\n  gint            uid_offset = 0;\n  gint            folder_offset = 0;\n  const guchar    *line;\n  const guchar    *uid_line;\n  const guchar    *folder_line;\n  gint            next_offset;\n  int             linelen;\n  int             tokenlen;\n  int             uid_tokenlen;\n  int             folder_tokenlen;\n  const guchar    *next_token;\n  const guchar    *uid_next_token;\n  const guchar    *folder_next_token;\n  guchar          *tokenbuf;\n  guchar          *command_token;\n  int             iter;\n  int             commandlen;\n  conversation_t *conversation;\n  imap_state_t   *session_state;\n\n  conversation = find_or_create_conversation(pinfo);\n  session_state = (imap_state_t *)conversation_get_proto_data(conversation, proto_imap);\n  if (!session_state) {\n    session_state = wmem_new0(wmem_file_scope(), imap_state_t);\n    session_state->ssl_requested = FALSE;\n    conversation_add_proto_data(conversation, proto_imap, session_state);\n  }\n\n  tokenbuf = (guchar *)wmem_alloc0(wmem_packet_scope(), MAX_BUFFER);\n  command_token = (guchar *)wmem_alloc0(wmem_packet_scope(), MAX_BUFFER);\n  commandlen = 0;\n  folder_offset = 0;\n  folder_tokenlen = 0;\n  folder_line = NULL;\n  col_set_str(pinfo->cinfo, COL_PROTOCOL, \"IMAP\");\n\n\n  if (pinfo->match_uint == pinfo->destport)\n    is_request = TRUE;\n  else\n    is_request = FALSE;\n\n  /*\n   * Put the first line from the buffer into the summary\n   * (but leave out the line terminator).\n   */\n  linelen = tvb_find_line_end(tvb, offset, -1, &next_offset, FALSE);\n  line = tvb_get_ptr(tvb, offset, linelen);\n\n  col_add_fstr(pinfo->cinfo, COL_INFO, \"%s: %s\", is_request ? \"Request\" : \"Response\", format_text(line, linelen));\n\n  {\n    ti = proto_tree_add_item(tree, proto_imap, tvb, offset, -1, ENC_NA);\n    imap_tree = proto_item_add_subtree(ti, ett_imap);\n\n    hidden_item = proto_tree_add_boolean(imap_tree, hf_imap_isrequest, tvb, 0, 0, is_request);\n    PROTO_ITEM_SET_HIDDEN(hidden_item);\n\n    while(tvb_offset_exists(tvb, offset)) {\n\n      /*\n       * Find the end of each line\n       *\n       * Note that \"tvb_find_line_end()\" will return a value that is\n       * not longer than what's in the buffer, so the \"tvb_get_ptr()\"\n       * call won't throw an exception.\n       */\n      linelen = tvb_find_line_end(tvb, offset, -1, &next_offset, FALSE);\n      line = tvb_get_ptr(tvb, offset, linelen);\n\n      /*\n       * Put the line into the protocol tree.\n       */\n      ti = proto_tree_add_item(imap_tree, hf_imap_line, tvb, offset, next_offset - offset, ENC_ASCII|ENC_NA);\n\n      reqresp_tree = proto_item_add_subtree(ti, ett_imap_reqresp);\n\n      /*\n       * Check that the line doesn't begin with '*', because that's a continuation line.\n       * Otherwise if a tag is present then extract tokens.\n       */\n      if ( (line) && ((line[0] != '*') || (TRUE == is_request)) ) {\n        /*\n         * Show each line as tags + requests or replies.\n         */\n\n        /*\n         * Extract the first token, and, if there is a first\n         * token, add it as the request or reply tag.\n         */\n        tokenlen = get_token_len(line, line + linelen, &next_token);\n        if (tokenlen != 0) {\n          proto_tree_add_item(reqresp_tree, (is_request) ? hf_imap_request_tag : hf_imap_response_tag, tvb, offset, tokenlen, ENC_ASCII|ENC_NA);\n\n          offset += (gint) (next_token - line);\n          linelen -= (int) (next_token - line);\n          line = next_token;\n        }\n\n        /*\n         * Extract second token, and, if there is a second\n         * token, and it's not uid, add it as the request or reply command.\n         */\n        tokenlen = get_token_len(line, line + linelen, &next_token);\n        if (tokenlen != 0) {\n          for (iter = 0; iter < tokenlen && iter < MAX_BUFFER-1; iter++) {\n            tokenbuf[iter] = g_ascii_tolower(line[iter]);\n          }\n          if (tree && is_request && strncmp(tokenbuf, \"uid\", tokenlen) == 0) {\n            proto_tree_add_item(reqresp_tree, hf_imap_request_uid, tvb, offset, tokenlen, ENC_ASCII|ENC_NA);\n            /*\n             * UID is a precursor to a command, if following the tag,\n              * so move to next token to grab the actual command.\n              */\n            uid_offset = offset;\n            uid_offset += (gint) (next_token - line);\n            uid_line = next_token;\n            uid_tokenlen = get_token_len(uid_line, uid_line + (linelen - tokenlen), &uid_next_token);\n            if (tokenlen != 0) {\n              proto_tree_add_item(reqresp_tree, hf_imap_request_command, tvb, uid_offset, uid_tokenlen, ENC_ASCII|ENC_NA);\n\n              /*\n               * Save command string to do specialized processing.\n               */\n              for (iter = 0; iter < uid_tokenlen && iter < MAX_BUFFER-1; iter++) {\n                command_token[iter] = g_ascii_tolower(uid_line[iter]);\n              }\n              commandlen = uid_tokenlen;\n\n              folder_offset = uid_offset;\n              folder_offset += (gint) (uid_next_token - uid_line);\n              folder_line = uid_next_token;\n              folder_tokenlen = get_token_len(folder_line, folder_line + (linelen - tokenlen - uid_tokenlen), &folder_next_token);\n            }\n          } else {\n            /*\n             * Not a UID request so perform normal parsing.\n             */\n            proto_tree_add_item(reqresp_tree, (is_request) ? hf_imap_request_command : hf_imap_response_status, tvb, offset, tokenlen, ENC_ASCII|ENC_NA);\n\n            if (is_request) {\n              /*\n               * Save command string to do specialized processing.\n               */\n              for (iter = 0; iter < tokenlen && iter < 256; iter++) {\n                command_token[iter] = g_ascii_tolower(line[iter]);\n              }\n              commandlen = tokenlen;\n\n              folder_offset = offset;\n              folder_offset += (gint) (next_token - line);\n              folder_line = next_token;\n              folder_tokenlen = get_token_len(folder_line, folder_line + (linelen - tokenlen - 1), &folder_next_token);\n            }\n          }\n\n          if (tree && commandlen > 0 && (\n              strncmp(command_token, \"select\", commandlen) == 0 ||\n              strncmp(command_token, \"examine\", commandlen) == 0 ||\n              strncmp(command_token, \"create\", commandlen) == 0 ||\n              strncmp(command_token, \"delete\", commandlen) == 0 ||\n              strncmp(command_token, \"rename\", commandlen) == 0 ||\n              strncmp(command_token, \"subscribe\", commandlen) == 0 ||\n              strncmp(command_token, \"unsubscribe\", commandlen) == 0 ||\n              strncmp(command_token, \"status\", commandlen) == 0 ||\n              strncmp(command_token, \"append\", commandlen) == 0 ||\n              strncmp(command_token, \"search\", commandlen) == 0)) {\n            /*\n             * These commands support folder as an argument,\n             * so parse out the folder name.\n             */\n            if (folder_tokenlen != 0)\n              proto_tree_add_item(reqresp_tree, hf_imap_request_folder, tvb, folder_offset, folder_tokenlen, ENC_ASCII|ENC_NA);\n          }\n\n          if (tree && is_request && (NULL != folder_line) && strncmp(command_token, \"copy\", commandlen) == 0) {\n            /*\n             * Handle the copy command separately since folder\n             * is the second argument for this command.\n             */\n            folder_offset += (gint) (folder_next_token - folder_line);\n            folder_line = folder_next_token;\n            folder_tokenlen = get_token_len(folder_line, folder_line + (linelen - tokenlen), &folder_next_token);\n\n            if (folder_tokenlen != 0)\n              proto_tree_add_item(reqresp_tree, hf_imap_request_folder, tvb, folder_offset, folder_tokenlen, ENC_ASCII|ENC_NA);\n          }\n\n          /* If not yet switched to TLS, check for STARTTLS. */\n          if (session_state->ssl_requested) {\n            if (!is_request && session_state->ssl_requested &&\n              strncmp(tokenbuf, \"ok\", tokenlen) == 0) {\n              /* STARTTLS accepted, next reply will be TLS. */\n              ssl_starttls_ack(ssl_handle, pinfo, imap_handle);\n            }\n            session_state->ssl_requested = FALSE;\n          }\n          if (is_request && commandlen > 0 &&\n            strncmp(command_token, \"starttls\", commandlen) == 0) {\n            /* If next response is OK, then TLS should be commenced. */\n            session_state->ssl_requested = TRUE;\n          }\n        }\n\n        /*\n         * Add the rest of the line as request or reply data.\n         */\n        if (linelen != 0) {\n          proto_tree_add_item(reqresp_tree, (is_request) ? hf_imap_request : hf_imap_response, tvb, offset, linelen, ENC_ASCII|ENC_NA);\n        }\n\n      }\n\n      offset = next_offset; /* Skip over last line and \\r\\n at the end of it */\n    }\n  }\n}",
        "func": "static void\ndissect_imap(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree)\n{\n  gboolean        is_request;\n  proto_tree      *imap_tree, *reqresp_tree;\n  proto_item      *ti, *hidden_item;\n  gint            offset = 0;\n  gint            uid_offset = 0;\n  gint            folder_offset = 0;\n  const guchar    *line;\n  const guchar    *lineend;\n  const guchar    *uid_line;\n  const guchar    *folder_line;\n  gint            next_offset;\n  int             linelen;\n  int             tokenlen;\n  int             uid_tokenlen;\n  int             folder_tokenlen;\n  const guchar    *next_token;\n  const guchar    *uid_next_token;\n  const guchar    *folder_next_token;\n  guchar          *tokenbuf;\n  guchar          *command_token;\n  int             iter;\n  int             commandlen;\n  conversation_t *conversation;\n  imap_state_t   *session_state;\n\n  conversation = find_or_create_conversation(pinfo);\n  session_state = (imap_state_t *)conversation_get_proto_data(conversation, proto_imap);\n  if (!session_state) {\n    session_state = wmem_new0(wmem_file_scope(), imap_state_t);\n    session_state->ssl_requested = FALSE;\n    conversation_add_proto_data(conversation, proto_imap, session_state);\n  }\n\n  tokenbuf = (guchar *)wmem_alloc0(wmem_packet_scope(), MAX_BUFFER);\n  command_token = (guchar *)wmem_alloc0(wmem_packet_scope(), MAX_BUFFER);\n  commandlen = 0;\n  folder_offset = 0;\n  folder_tokenlen = 0;\n  folder_line = NULL;\n  col_set_str(pinfo->cinfo, COL_PROTOCOL, \"IMAP\");\n\n\n  if (pinfo->match_uint == pinfo->destport)\n    is_request = TRUE;\n  else\n    is_request = FALSE;\n\n  /*\n   * Put the first line from the buffer into the summary\n   * (but leave out the line terminator).\n   */\n  linelen = tvb_find_line_end(tvb, offset, -1, &next_offset, FALSE);\n  line = tvb_get_ptr(tvb, offset, linelen);\n\n  col_add_fstr(pinfo->cinfo, COL_INFO, \"%s: %s\", is_request ? \"Request\" : \"Response\", format_text(line, linelen));\n\n  {\n    ti = proto_tree_add_item(tree, proto_imap, tvb, offset, -1, ENC_NA);\n    imap_tree = proto_item_add_subtree(ti, ett_imap);\n\n    hidden_item = proto_tree_add_boolean(imap_tree, hf_imap_isrequest, tvb, 0, 0, is_request);\n    PROTO_ITEM_SET_HIDDEN(hidden_item);\n\n    while(tvb_offset_exists(tvb, offset)) {\n\n      /*\n       * Find the end of each line\n       *\n       * Note that \"tvb_find_line_end()\" will return a value that is\n       * not longer than what's in the buffer, so the \"tvb_get_ptr()\"\n       * call won't throw an exception.\n       */\n      linelen = tvb_find_line_end(tvb, offset, -1, &next_offset, FALSE);\n      line = tvb_get_ptr(tvb, offset, linelen);\n      lineend = (line + linelen);\n\n      /*\n       * Put the line into the protocol tree.\n       */\n      ti = proto_tree_add_item(imap_tree, hf_imap_line, tvb, offset, next_offset - offset, ENC_ASCII|ENC_NA);\n\n      reqresp_tree = proto_item_add_subtree(ti, ett_imap_reqresp);\n\n      /*\n       * Check that the line doesn't begin with '*', because that's a continuation line.\n       * Otherwise if a tag is present then extract tokens.\n       */\n      if ( (line) && ((line[0] != '*') || (TRUE == is_request)) ) {\n        /*\n         * Show each line as tags + requests or replies.\n         */\n\n        /*\n         * Extract the first token, and, if there is a first\n         * token, add it as the request or reply tag.\n         */\n        tokenlen = get_token_len(line, lineend, &next_token);\n        if (tokenlen != 0) {\n          proto_tree_add_item(reqresp_tree, (is_request) ? hf_imap_request_tag : hf_imap_response_tag, tvb, offset, tokenlen, ENC_ASCII|ENC_NA);\n\n          offset += (gint) (next_token - line);\n          linelen -= (int) (next_token - line);\n          line = next_token;\n        }\n\n        /*\n         * Extract second token, and, if there is a second\n         * token, and it's not uid, add it as the request or reply command.\n         */\n        tokenlen = get_token_len(line, lineend, &next_token);\n        if (tokenlen != 0) {\n          for (iter = 0; iter < tokenlen && iter < MAX_BUFFER-1; iter++) {\n            tokenbuf[iter] = g_ascii_tolower(line[iter]);\n          }\n          if (tree && is_request && strncmp(tokenbuf, \"uid\", tokenlen) == 0) {\n            proto_tree_add_item(reqresp_tree, hf_imap_request_uid, tvb, offset, tokenlen, ENC_ASCII|ENC_NA);\n            /*\n             * UID is a precursor to a command, if following the tag,\n              * so move to next token to grab the actual command.\n              */\n            uid_offset = offset;\n            uid_offset += (gint) (next_token - line);\n            uid_line = next_token;\n            uid_tokenlen = get_token_len(uid_line, lineend, &uid_next_token);\n            if (tokenlen != 0) {\n              proto_tree_add_item(reqresp_tree, hf_imap_request_command, tvb, uid_offset, uid_tokenlen, ENC_ASCII|ENC_NA);\n\n              /*\n               * Save command string to do specialized processing.\n               */\n              for (iter = 0; iter < uid_tokenlen && iter < MAX_BUFFER-1; iter++) {\n                command_token[iter] = g_ascii_tolower(uid_line[iter]);\n              }\n              commandlen = uid_tokenlen;\n\n              folder_offset = uid_offset;\n              folder_offset += (gint) (uid_next_token - uid_line);\n              folder_line = uid_next_token;\n              folder_tokenlen = get_token_len(folder_line, lineend, &folder_next_token);\n            }\n          } else {\n            /*\n             * Not a UID request so perform normal parsing.\n             */\n            proto_tree_add_item(reqresp_tree, (is_request) ? hf_imap_request_command : hf_imap_response_status, tvb, offset, tokenlen, ENC_ASCII|ENC_NA);\n\n            if (is_request) {\n              /*\n               * Save command string to do specialized processing.\n               */\n              for (iter = 0; iter < tokenlen && iter < 256; iter++) {\n                command_token[iter] = g_ascii_tolower(line[iter]);\n              }\n              commandlen = tokenlen;\n\n              folder_offset = offset;\n              folder_offset += (gint) (next_token - line);\n              folder_line = next_token;\n              folder_tokenlen = get_token_len(folder_line, lineend, &folder_next_token);\n            }\n          }\n\n          if (tree && commandlen > 0 && (\n              strncmp(command_token, \"select\", commandlen) == 0 ||\n              strncmp(command_token, \"examine\", commandlen) == 0 ||\n              strncmp(command_token, \"create\", commandlen) == 0 ||\n              strncmp(command_token, \"delete\", commandlen) == 0 ||\n              strncmp(command_token, \"rename\", commandlen) == 0 ||\n              strncmp(command_token, \"subscribe\", commandlen) == 0 ||\n              strncmp(command_token, \"unsubscribe\", commandlen) == 0 ||\n              strncmp(command_token, \"status\", commandlen) == 0 ||\n              strncmp(command_token, \"append\", commandlen) == 0 ||\n              strncmp(command_token, \"search\", commandlen) == 0)) {\n            /*\n             * These commands support folder as an argument,\n             * so parse out the folder name.\n             */\n            if (folder_tokenlen != 0)\n              proto_tree_add_item(reqresp_tree, hf_imap_request_folder, tvb, folder_offset, folder_tokenlen, ENC_ASCII|ENC_NA);\n          }\n\n          if (tree && is_request && (NULL != folder_line) && strncmp(command_token, \"copy\", commandlen) == 0) {\n            /*\n             * Handle the copy command separately since folder\n             * is the second argument for this command.\n             */\n            folder_offset += (gint) (folder_next_token - folder_line);\n            folder_line = folder_next_token;\n            folder_tokenlen = get_token_len(folder_line, lineend, &folder_next_token);\n\n            if (folder_tokenlen != 0)\n              proto_tree_add_item(reqresp_tree, hf_imap_request_folder, tvb, folder_offset, folder_tokenlen, ENC_ASCII|ENC_NA);\n          }\n\n          /* If not yet switched to TLS, check for STARTTLS. */\n          if (session_state->ssl_requested) {\n            if (!is_request && session_state->ssl_requested &&\n              strncmp(tokenbuf, \"ok\", tokenlen) == 0) {\n              /* STARTTLS accepted, next reply will be TLS. */\n              ssl_starttls_ack(ssl_handle, pinfo, imap_handle);\n            }\n            session_state->ssl_requested = FALSE;\n          }\n          if (is_request && commandlen > 0 &&\n            strncmp(command_token, \"starttls\", commandlen) == 0) {\n            /* If next response is OK, then TLS should be commenced. */\n            session_state->ssl_requested = TRUE;\n          }\n        }\n\n        /*\n         * Add the rest of the line as request or reply data.\n         */\n        if (linelen != 0) {\n          proto_tree_add_item(reqresp_tree, (is_request) ? hf_imap_request : hf_imap_response, tvb, offset, linelen, ENC_ASCII|ENC_NA);\n        }\n\n      }\n\n      offset = next_offset; /* Skip over last line and \\r\\n at the end of it */\n    }\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -8,6 +8,7 @@\n   gint            uid_offset = 0;\n   gint            folder_offset = 0;\n   const guchar    *line;\n+  const guchar    *lineend;\n   const guchar    *uid_line;\n   const guchar    *folder_line;\n   gint            next_offset;\n@@ -74,6 +75,7 @@\n        */\n       linelen = tvb_find_line_end(tvb, offset, -1, &next_offset, FALSE);\n       line = tvb_get_ptr(tvb, offset, linelen);\n+      lineend = (line + linelen);\n \n       /*\n        * Put the line into the protocol tree.\n@@ -95,7 +97,7 @@\n          * Extract the first token, and, if there is a first\n          * token, add it as the request or reply tag.\n          */\n-        tokenlen = get_token_len(line, line + linelen, &next_token);\n+        tokenlen = get_token_len(line, lineend, &next_token);\n         if (tokenlen != 0) {\n           proto_tree_add_item(reqresp_tree, (is_request) ? hf_imap_request_tag : hf_imap_response_tag, tvb, offset, tokenlen, ENC_ASCII|ENC_NA);\n \n@@ -108,7 +110,7 @@\n          * Extract second token, and, if there is a second\n          * token, and it's not uid, add it as the request or reply command.\n          */\n-        tokenlen = get_token_len(line, line + linelen, &next_token);\n+        tokenlen = get_token_len(line, lineend, &next_token);\n         if (tokenlen != 0) {\n           for (iter = 0; iter < tokenlen && iter < MAX_BUFFER-1; iter++) {\n             tokenbuf[iter] = g_ascii_tolower(line[iter]);\n@@ -122,7 +124,7 @@\n             uid_offset = offset;\n             uid_offset += (gint) (next_token - line);\n             uid_line = next_token;\n-            uid_tokenlen = get_token_len(uid_line, uid_line + (linelen - tokenlen), &uid_next_token);\n+            uid_tokenlen = get_token_len(uid_line, lineend, &uid_next_token);\n             if (tokenlen != 0) {\n               proto_tree_add_item(reqresp_tree, hf_imap_request_command, tvb, uid_offset, uid_tokenlen, ENC_ASCII|ENC_NA);\n \n@@ -137,7 +139,7 @@\n               folder_offset = uid_offset;\n               folder_offset += (gint) (uid_next_token - uid_line);\n               folder_line = uid_next_token;\n-              folder_tokenlen = get_token_len(folder_line, folder_line + (linelen - tokenlen - uid_tokenlen), &folder_next_token);\n+              folder_tokenlen = get_token_len(folder_line, lineend, &folder_next_token);\n             }\n           } else {\n             /*\n@@ -157,7 +159,7 @@\n               folder_offset = offset;\n               folder_offset += (gint) (next_token - line);\n               folder_line = next_token;\n-              folder_tokenlen = get_token_len(folder_line, folder_line + (linelen - tokenlen - 1), &folder_next_token);\n+              folder_tokenlen = get_token_len(folder_line, lineend, &folder_next_token);\n             }\n           }\n \n@@ -187,7 +189,7 @@\n              */\n             folder_offset += (gint) (folder_next_token - folder_line);\n             folder_line = folder_next_token;\n-            folder_tokenlen = get_token_len(folder_line, folder_line + (linelen - tokenlen), &folder_next_token);\n+            folder_tokenlen = get_token_len(folder_line, lineend, &folder_next_token);\n \n             if (folder_tokenlen != 0)\n               proto_tree_add_item(reqresp_tree, hf_imap_request_folder, tvb, folder_offset, folder_tokenlen, ENC_ASCII|ENC_NA);",
        "diff_line_info": {
            "deleted_lines": [
                "        tokenlen = get_token_len(line, line + linelen, &next_token);",
                "        tokenlen = get_token_len(line, line + linelen, &next_token);",
                "            uid_tokenlen = get_token_len(uid_line, uid_line + (linelen - tokenlen), &uid_next_token);",
                "              folder_tokenlen = get_token_len(folder_line, folder_line + (linelen - tokenlen - uid_tokenlen), &folder_next_token);",
                "              folder_tokenlen = get_token_len(folder_line, folder_line + (linelen - tokenlen - 1), &folder_next_token);",
                "            folder_tokenlen = get_token_len(folder_line, folder_line + (linelen - tokenlen), &folder_next_token);"
            ],
            "added_lines": [
                "  const guchar    *lineend;",
                "      lineend = (line + linelen);",
                "        tokenlen = get_token_len(line, lineend, &next_token);",
                "        tokenlen = get_token_len(line, lineend, &next_token);",
                "            uid_tokenlen = get_token_len(uid_line, lineend, &uid_next_token);",
                "              folder_tokenlen = get_token_len(folder_line, lineend, &folder_next_token);",
                "              folder_tokenlen = get_token_len(folder_line, lineend, &folder_next_token);",
                "            folder_tokenlen = get_token_len(folder_line, lineend, &folder_next_token);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-11045",
        "func_name": "php/php-src/spl_filesystem_object_construct",
        "description": "In PHP versions 7.2.x below 7.2.26, 7.3.x below 7.3.13 and 7.4.0, PHP DirectoryIterator class accepts filenames with embedded \\0 byte and treats them as terminating at that byte. This could lead to security vulnerabilities, e.g. in applications checking paths that the code is allowed to access.",
        "git_url": "https://github.com/php/php-src/commit/d74907b8575e6edb83b728c2a94df434c23e1f79",
        "commit_title": "Fix #78863: DirectoryIterator class silently truncates after a null byte",
        "commit_text": " Since the constructor of DirectoryIterator and friends is supposed to accepts paths (i.e. strings without NUL bytes), we must not accept arbitrary strings.  (cherry picked from commit a5a15965da23c8e97657278fc8dfbf1dfb20c016)",
        "func_before": "void spl_filesystem_object_construct(INTERNAL_FUNCTION_PARAMETERS, zend_long ctor_flags) /* {{{ */\n{\n\tspl_filesystem_object *intern;\n\tchar *path;\n\tint parsed;\n\tsize_t len;\n\tzend_long flags;\n\tzend_error_handling error_handling;\n\n\tzend_replace_error_handling(EH_THROW, spl_ce_UnexpectedValueException, &error_handling);\n\n\tif (SPL_HAS_FLAG(ctor_flags, DIT_CTOR_FLAGS)) {\n\t\tflags = SPL_FILE_DIR_KEY_AS_PATHNAME|SPL_FILE_DIR_CURRENT_AS_FILEINFO;\n\t\tparsed = zend_parse_parameters(ZEND_NUM_ARGS(), \"s|l\", &path, &len, &flags);\n\t} else {\n\t\tflags = SPL_FILE_DIR_KEY_AS_PATHNAME|SPL_FILE_DIR_CURRENT_AS_SELF;\n\t\tparsed = zend_parse_parameters(ZEND_NUM_ARGS(), \"s\", &path, &len);\n\t}\n\tif (SPL_HAS_FLAG(ctor_flags, SPL_FILE_DIR_SKIPDOTS)) {\n\t\tflags |= SPL_FILE_DIR_SKIPDOTS;\n\t}\n\tif (SPL_HAS_FLAG(ctor_flags, SPL_FILE_DIR_UNIXPATHS)) {\n\t\tflags |= SPL_FILE_DIR_UNIXPATHS;\n\t}\n\tif (parsed == FAILURE) {\n\t\tzend_restore_error_handling(&error_handling);\n\t\treturn;\n\t}\n\tif (!len) {\n\t\tzend_throw_exception_ex(spl_ce_RuntimeException, 0, \"Directory name must not be empty.\");\n\t\tzend_restore_error_handling(&error_handling);\n\t\treturn;\n\t}\n\n\tintern = Z_SPLFILESYSTEM_P(getThis());\n\tif (intern->_path) {\n\t\t/* object is alreay initialized */\n\t\tzend_restore_error_handling(&error_handling);\n\t\tphp_error_docref(NULL, E_WARNING, \"Directory object is already initialized\");\n\t\treturn;\n\t}\n\tintern->flags = flags;\n#ifdef HAVE_GLOB\n\tif (SPL_HAS_FLAG(ctor_flags, DIT_CTOR_GLOB) && strstr(path, \"glob://\") != path) {\n\t\tspprintf(&path, 0, \"glob://%s\", path);\n\t\tspl_filesystem_dir_open(intern, path);\n\t\tefree(path);\n\t} else\n#endif\n\t{\n\t\tspl_filesystem_dir_open(intern, path);\n\n\t}\n\n\tintern->u.dir.is_recursive = instanceof_function(intern->std.ce, spl_ce_RecursiveDirectoryIterator) ? 1 : 0;\n\n\tzend_restore_error_handling(&error_handling);\n}",
        "func": "void spl_filesystem_object_construct(INTERNAL_FUNCTION_PARAMETERS, zend_long ctor_flags) /* {{{ */\n{\n\tspl_filesystem_object *intern;\n\tchar *path;\n\tint parsed;\n\tsize_t len;\n\tzend_long flags;\n\tzend_error_handling error_handling;\n\n\tzend_replace_error_handling(EH_THROW, spl_ce_UnexpectedValueException, &error_handling);\n\n\tif (SPL_HAS_FLAG(ctor_flags, DIT_CTOR_FLAGS)) {\n\t\tflags = SPL_FILE_DIR_KEY_AS_PATHNAME|SPL_FILE_DIR_CURRENT_AS_FILEINFO;\n\t\tparsed = zend_parse_parameters(ZEND_NUM_ARGS(), \"p|l\", &path, &len, &flags);\n\t} else {\n\t\tflags = SPL_FILE_DIR_KEY_AS_PATHNAME|SPL_FILE_DIR_CURRENT_AS_SELF;\n\t\tparsed = zend_parse_parameters(ZEND_NUM_ARGS(), \"p\", &path, &len);\n\t}\n\tif (SPL_HAS_FLAG(ctor_flags, SPL_FILE_DIR_SKIPDOTS)) {\n\t\tflags |= SPL_FILE_DIR_SKIPDOTS;\n\t}\n\tif (SPL_HAS_FLAG(ctor_flags, SPL_FILE_DIR_UNIXPATHS)) {\n\t\tflags |= SPL_FILE_DIR_UNIXPATHS;\n\t}\n\tif (parsed == FAILURE) {\n\t\tzend_restore_error_handling(&error_handling);\n\t\treturn;\n\t}\n\tif (!len) {\n\t\tzend_throw_exception_ex(spl_ce_RuntimeException, 0, \"Directory name must not be empty.\");\n\t\tzend_restore_error_handling(&error_handling);\n\t\treturn;\n\t}\n\n\tintern = Z_SPLFILESYSTEM_P(getThis());\n\tif (intern->_path) {\n\t\t/* object is alreay initialized */\n\t\tzend_restore_error_handling(&error_handling);\n\t\tphp_error_docref(NULL, E_WARNING, \"Directory object is already initialized\");\n\t\treturn;\n\t}\n\tintern->flags = flags;\n#ifdef HAVE_GLOB\n\tif (SPL_HAS_FLAG(ctor_flags, DIT_CTOR_GLOB) && strstr(path, \"glob://\") != path) {\n\t\tspprintf(&path, 0, \"glob://%s\", path);\n\t\tspl_filesystem_dir_open(intern, path);\n\t\tefree(path);\n\t} else\n#endif\n\t{\n\t\tspl_filesystem_dir_open(intern, path);\n\n\t}\n\n\tintern->u.dir.is_recursive = instanceof_function(intern->std.ce, spl_ce_RecursiveDirectoryIterator) ? 1 : 0;\n\n\tzend_restore_error_handling(&error_handling);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -11,10 +11,10 @@\n \n \tif (SPL_HAS_FLAG(ctor_flags, DIT_CTOR_FLAGS)) {\n \t\tflags = SPL_FILE_DIR_KEY_AS_PATHNAME|SPL_FILE_DIR_CURRENT_AS_FILEINFO;\n-\t\tparsed = zend_parse_parameters(ZEND_NUM_ARGS(), \"s|l\", &path, &len, &flags);\n+\t\tparsed = zend_parse_parameters(ZEND_NUM_ARGS(), \"p|l\", &path, &len, &flags);\n \t} else {\n \t\tflags = SPL_FILE_DIR_KEY_AS_PATHNAME|SPL_FILE_DIR_CURRENT_AS_SELF;\n-\t\tparsed = zend_parse_parameters(ZEND_NUM_ARGS(), \"s\", &path, &len);\n+\t\tparsed = zend_parse_parameters(ZEND_NUM_ARGS(), \"p\", &path, &len);\n \t}\n \tif (SPL_HAS_FLAG(ctor_flags, SPL_FILE_DIR_SKIPDOTS)) {\n \t\tflags |= SPL_FILE_DIR_SKIPDOTS;",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tparsed = zend_parse_parameters(ZEND_NUM_ARGS(), \"s|l\", &path, &len, &flags);",
                "\t\tparsed = zend_parse_parameters(ZEND_NUM_ARGS(), \"s\", &path, &len);"
            ],
            "added_lines": [
                "\t\tparsed = zend_parse_parameters(ZEND_NUM_ARGS(), \"p|l\", &path, &len, &flags);",
                "\t\tparsed = zend_parse_parameters(ZEND_NUM_ARGS(), \"p\", &path, &len);"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-29383",
        "func_name": "shadow-maint/shadow/valid_field",
        "description": "In Shadow 4.13, it is possible to inject control characters into fields provided to the SUID program chfn (change finger). Although it is not possible to exploit this directly (e.g., adding a new user fails because \\n is in the block list), it is possible to misrepresent the /etc/passwd file when viewed. Use of \\r manipulations and Unicode characters to work around blocking of the : character make it possible to give the impression that a new user has been added. In other words, an adversary may be able to convince a system administrator to take the system offline (an indirect, social-engineered denial of service) by demonstrating that \"cat /etc/passwd\" shows a rogue user account.",
        "git_url": "https://github.com/shadow-maint/shadow/commit/e5905c4b84d4fb90aefcd96ee618411ebfac663d",
        "commit_title": "Added control character check",
        "commit_text": " Added control character check, returning -1 (to \"err\") if control characters are present.",
        "func_before": "int valid_field (const char *field, const char *illegal)\n{\n\tconst char *cp;\n\tint err = 0;\n\n\tif (NULL == field) {\n\t\treturn -1;\n\t}\n\n\t/* For each character of field, search if it appears in the list\n\t * of illegal characters. */\n\tfor (cp = field; '\\0' != *cp; cp++) {\n\t\tif (strchr (illegal, *cp) != NULL) {\n\t\t\terr = -1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (0 == err) {\n\t\t/* Search if there are some non-printable characters */\n\t\tfor (cp = field; '\\0' != *cp; cp++) {\n\t\t\tif (!isprint (*cp)) {\n\t\t\t\terr = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn err;\n}",
        "func": "int valid_field (const char *field, const char *illegal)\n{\n\tconst char *cp;\n\tint err = 0;\n\n\tif (NULL == field) {\n\t\treturn -1;\n\t}\n\n\t/* For each character of field, search if it appears in the list\n\t * of illegal characters. */\n\tfor (cp = field; '\\0' != *cp; cp++) {\n\t\tif (strchr (illegal, *cp) != NULL) {\n\t\t\terr = -1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (0 == err) {\n\t\t/* Search if there are non-printable or control characters */\n\t\tfor (cp = field; '\\0' != *cp; cp++) {\n\t\t\tif (!isprint (*cp)) {\n\t\t\t\terr = 1;\n\t\t\t}\n\t\t\tif (!iscntrl (*cp)) {\n\t\t\t\terr = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn err;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -17,10 +17,13 @@\n \t}\n \n \tif (0 == err) {\n-\t\t/* Search if there are some non-printable characters */\n+\t\t/* Search if there are non-printable or control characters */\n \t\tfor (cp = field; '\\0' != *cp; cp++) {\n \t\t\tif (!isprint (*cp)) {\n \t\t\t\terr = 1;\n+\t\t\t}\n+\t\t\tif (!iscntrl (*cp)) {\n+\t\t\t\terr = -1;\n \t\t\t\tbreak;\n \t\t\t}\n \t\t}",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t/* Search if there are some non-printable characters */"
            ],
            "added_lines": [
                "\t\t/* Search if there are non-printable or control characters */",
                "\t\t\t}",
                "\t\t\tif (!iscntrl (*cp)) {",
                "\t\t\t\terr = -1;"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-26130",
        "func_name": "yhirose/cpp-httplib/ClientImpl::Delete",
        "description": "Versions of the package yhirose/cpp-httplib before 0.12.4 are vulnerable to CRLF Injection when untrusted user input is used to set the content-type header in the HTTP .Patch, .Post, .Put and .Delete requests. This can lead to logical errors and other misbehaviors.\r\r**Note:** This issue is present due to an incomplete fix for [CVE-2020-11709](https://security.snyk.io/vuln/SNYK-UNMANAGED-YHIROSECPPHTTPLIB-2366507).",
        "git_url": "https://github.com/yhirose/cpp-httplib/commit/5b397d455d25a391ba346863830c1949627b4d08",
        "commit_title": "Fix more CRLF injection problems.",
        "commit_text": "",
        "func_before": "inline Result ClientImpl::Delete(const std::string &path,\n                                 const Headers &headers, const char *body,\n                                 size_t content_length,\n                                 const std::string &content_type) {\n  Request req;\n  req.method = \"DELETE\";\n  req.headers = headers;\n  req.path = path;\n\n  if (!content_type.empty()) {\n    req.headers.emplace(\"Content-Type\", content_type);\n  }\n  req.body.assign(body, content_length);\n\n  return send_(std::move(req));\n}",
        "func": "inline Result ClientImpl::Delete(const std::string &path,\n                                 const Headers &headers, const char *body,\n                                 size_t content_length,\n                                 const std::string &content_type) {\n  Request req;\n  req.method = \"DELETE\";\n  req.headers = headers;\n  req.path = path;\n\n  if (!content_type.empty()) { req.set_header(\"Content-Type\", content_type); }\n  req.body.assign(body, content_length);\n\n  return send_(std::move(req));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -7,9 +7,7 @@\n   req.headers = headers;\n   req.path = path;\n \n-  if (!content_type.empty()) {\n-    req.headers.emplace(\"Content-Type\", content_type);\n-  }\n+  if (!content_type.empty()) { req.set_header(\"Content-Type\", content_type); }\n   req.body.assign(body, content_length);\n \n   return send_(std::move(req));",
        "diff_line_info": {
            "deleted_lines": [
                "  if (!content_type.empty()) {",
                "    req.headers.emplace(\"Content-Type\", content_type);",
                "  }"
            ],
            "added_lines": [
                "  if (!content_type.empty()) { req.set_header(\"Content-Type\", content_type); }"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-26130",
        "func_name": "yhirose/cpp-httplib/ClientImpl::write_request",
        "description": "Versions of the package yhirose/cpp-httplib before 0.12.4 are vulnerable to CRLF Injection when untrusted user input is used to set the content-type header in the HTTP .Patch, .Post, .Put and .Delete requests. This can lead to logical errors and other misbehaviors.\r\r**Note:** This issue is present due to an incomplete fix for [CVE-2020-11709](https://security.snyk.io/vuln/SNYK-UNMANAGED-YHIROSECPPHTTPLIB-2366507).",
        "git_url": "https://github.com/yhirose/cpp-httplib/commit/5b397d455d25a391ba346863830c1949627b4d08",
        "commit_title": "Fix more CRLF injection problems.",
        "commit_text": "",
        "func_before": "inline bool ClientImpl::write_request(Stream &strm, Request &req,\n                                      bool close_connection, Error &error) {\n  // Prepare additional headers\n  if (close_connection) {\n    if (!req.has_header(\"Connection\")) {\n      req.headers.emplace(\"Connection\", \"close\");\n    }\n  }\n\n  if (!req.has_header(\"Host\")) {\n    if (is_ssl()) {\n      if (port_ == 443) {\n        req.headers.emplace(\"Host\", host_);\n      } else {\n        req.headers.emplace(\"Host\", host_and_port_);\n      }\n    } else {\n      if (port_ == 80) {\n        req.headers.emplace(\"Host\", host_);\n      } else {\n        req.headers.emplace(\"Host\", host_and_port_);\n      }\n    }\n  }\n\n  if (!req.has_header(\"Accept\")) { req.headers.emplace(\"Accept\", \"*/*\"); }\n\n#ifndef CPPHTTPLIB_NO_DEFAULT_USER_AGENT\n  if (!req.has_header(\"User-Agent\")) {\n    auto agent = std::string(\"cpp-httplib/\") + CPPHTTPLIB_VERSION;\n    req.headers.emplace(\"User-Agent\", agent);\n  }\n#endif\n\n  if (req.body.empty()) {\n    if (req.content_provider_) {\n      if (!req.is_chunked_content_provider_) {\n        if (!req.has_header(\"Content-Length\")) {\n          auto length = std::to_string(req.content_length_);\n          req.headers.emplace(\"Content-Length\", length);\n        }\n      }\n    } else {\n      if (req.method == \"POST\" || req.method == \"PUT\" ||\n          req.method == \"PATCH\") {\n        req.headers.emplace(\"Content-Length\", \"0\");\n      }\n    }\n  } else {\n    if (!req.has_header(\"Content-Type\")) {\n      req.headers.emplace(\"Content-Type\", \"text/plain\");\n    }\n\n    if (!req.has_header(\"Content-Length\")) {\n      auto length = std::to_string(req.body.size());\n      req.headers.emplace(\"Content-Length\", length);\n    }\n  }\n\n  if (!basic_auth_password_.empty() || !basic_auth_username_.empty()) {\n    if (!req.has_header(\"Authorization\")) {\n      req.headers.insert(make_basic_authentication_header(\n          basic_auth_username_, basic_auth_password_, false));\n    }\n  }\n\n  if (!proxy_basic_auth_username_.empty() &&\n      !proxy_basic_auth_password_.empty()) {\n    if (!req.has_header(\"Proxy-Authorization\")) {\n      req.headers.insert(make_basic_authentication_header(\n          proxy_basic_auth_username_, proxy_basic_auth_password_, true));\n    }\n  }\n\n  if (!bearer_token_auth_token_.empty()) {\n    if (!req.has_header(\"Authorization\")) {\n      req.headers.insert(make_bearer_token_authentication_header(\n          bearer_token_auth_token_, false));\n    }\n  }\n\n  if (!proxy_bearer_token_auth_token_.empty()) {\n    if (!req.has_header(\"Proxy-Authorization\")) {\n      req.headers.insert(make_bearer_token_authentication_header(\n          proxy_bearer_token_auth_token_, true));\n    }\n  }\n\n  // Request line and headers\n  {\n    detail::BufferStream bstrm;\n\n    const auto &path = url_encode_ ? detail::encode_url(req.path) : req.path;\n    bstrm.write_format(\"%s %s HTTP/1.1\\r\\n\", req.method.c_str(), path.c_str());\n\n    detail::write_headers(bstrm, req.headers);\n\n    // Flush buffer\n    auto &data = bstrm.get_buffer();\n    if (!detail::write_data(strm, data.data(), data.size())) {\n      error = Error::Write;\n      return false;\n    }\n  }\n\n  // Body\n  if (req.body.empty()) {\n    return write_content_with_provider(strm, req, error);\n  }\n\n  if (!detail::write_data(strm, req.body.data(), req.body.size())) {\n    error = Error::Write;\n    return false;\n  }\n\n  return true;\n}",
        "func": "inline bool ClientImpl::write_request(Stream &strm, Request &req,\n                                      bool close_connection, Error &error) {\n  // Prepare additional headers\n  if (close_connection) {\n    if (!req.has_header(\"Connection\")) {\n      req.set_header(\"Connection\", \"close\");\n    }\n  }\n\n  if (!req.has_header(\"Host\")) {\n    if (is_ssl()) {\n      if (port_ == 443) {\n        req.set_header(\"Host\", host_);\n      } else {\n        req.set_header(\"Host\", host_and_port_);\n      }\n    } else {\n      if (port_ == 80) {\n        req.set_header(\"Host\", host_);\n      } else {\n        req.set_header(\"Host\", host_and_port_);\n      }\n    }\n  }\n\n  if (!req.has_header(\"Accept\")) { req.set_header(\"Accept\", \"*/*\"); }\n\n#ifndef CPPHTTPLIB_NO_DEFAULT_USER_AGENT\n  if (!req.has_header(\"User-Agent\")) {\n    auto agent = std::string(\"cpp-httplib/\") + CPPHTTPLIB_VERSION;\n    req.set_header(\"User-Agent\", agent);\n  }\n#endif\n\n  if (req.body.empty()) {\n    if (req.content_provider_) {\n      if (!req.is_chunked_content_provider_) {\n        if (!req.has_header(\"Content-Length\")) {\n          auto length = std::to_string(req.content_length_);\n          req.set_header(\"Content-Length\", length);\n        }\n      }\n    } else {\n      if (req.method == \"POST\" || req.method == \"PUT\" ||\n          req.method == \"PATCH\") {\n        req.set_header(\"Content-Length\", \"0\");\n      }\n    }\n  } else {\n    if (!req.has_header(\"Content-Type\")) {\n      req.set_header(\"Content-Type\", \"text/plain\");\n    }\n\n    if (!req.has_header(\"Content-Length\")) {\n      auto length = std::to_string(req.body.size());\n      req.set_header(\"Content-Length\", length);\n    }\n  }\n\n  if (!basic_auth_password_.empty() || !basic_auth_username_.empty()) {\n    if (!req.has_header(\"Authorization\")) {\n      req.headers.insert(make_basic_authentication_header(\n          basic_auth_username_, basic_auth_password_, false));\n    }\n  }\n\n  if (!proxy_basic_auth_username_.empty() &&\n      !proxy_basic_auth_password_.empty()) {\n    if (!req.has_header(\"Proxy-Authorization\")) {\n      req.headers.insert(make_basic_authentication_header(\n          proxy_basic_auth_username_, proxy_basic_auth_password_, true));\n    }\n  }\n\n  if (!bearer_token_auth_token_.empty()) {\n    if (!req.has_header(\"Authorization\")) {\n      req.headers.insert(make_bearer_token_authentication_header(\n          bearer_token_auth_token_, false));\n    }\n  }\n\n  if (!proxy_bearer_token_auth_token_.empty()) {\n    if (!req.has_header(\"Proxy-Authorization\")) {\n      req.headers.insert(make_bearer_token_authentication_header(\n          proxy_bearer_token_auth_token_, true));\n    }\n  }\n\n  // Request line and headers\n  {\n    detail::BufferStream bstrm;\n\n    const auto &path = url_encode_ ? detail::encode_url(req.path) : req.path;\n    bstrm.write_format(\"%s %s HTTP/1.1\\r\\n\", req.method.c_str(), path.c_str());\n\n    detail::write_headers(bstrm, req.headers);\n\n    // Flush buffer\n    auto &data = bstrm.get_buffer();\n    if (!detail::write_data(strm, data.data(), data.size())) {\n      error = Error::Write;\n      return false;\n    }\n  }\n\n  // Body\n  if (req.body.empty()) {\n    return write_content_with_provider(strm, req, error);\n  }\n\n  if (!detail::write_data(strm, req.body.data(), req.body.size())) {\n    error = Error::Write;\n    return false;\n  }\n\n  return true;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,32 +3,32 @@\n   // Prepare additional headers\n   if (close_connection) {\n     if (!req.has_header(\"Connection\")) {\n-      req.headers.emplace(\"Connection\", \"close\");\n+      req.set_header(\"Connection\", \"close\");\n     }\n   }\n \n   if (!req.has_header(\"Host\")) {\n     if (is_ssl()) {\n       if (port_ == 443) {\n-        req.headers.emplace(\"Host\", host_);\n+        req.set_header(\"Host\", host_);\n       } else {\n-        req.headers.emplace(\"Host\", host_and_port_);\n+        req.set_header(\"Host\", host_and_port_);\n       }\n     } else {\n       if (port_ == 80) {\n-        req.headers.emplace(\"Host\", host_);\n+        req.set_header(\"Host\", host_);\n       } else {\n-        req.headers.emplace(\"Host\", host_and_port_);\n+        req.set_header(\"Host\", host_and_port_);\n       }\n     }\n   }\n \n-  if (!req.has_header(\"Accept\")) { req.headers.emplace(\"Accept\", \"*/*\"); }\n+  if (!req.has_header(\"Accept\")) { req.set_header(\"Accept\", \"*/*\"); }\n \n #ifndef CPPHTTPLIB_NO_DEFAULT_USER_AGENT\n   if (!req.has_header(\"User-Agent\")) {\n     auto agent = std::string(\"cpp-httplib/\") + CPPHTTPLIB_VERSION;\n-    req.headers.emplace(\"User-Agent\", agent);\n+    req.set_header(\"User-Agent\", agent);\n   }\n #endif\n \n@@ -37,23 +37,23 @@\n       if (!req.is_chunked_content_provider_) {\n         if (!req.has_header(\"Content-Length\")) {\n           auto length = std::to_string(req.content_length_);\n-          req.headers.emplace(\"Content-Length\", length);\n+          req.set_header(\"Content-Length\", length);\n         }\n       }\n     } else {\n       if (req.method == \"POST\" || req.method == \"PUT\" ||\n           req.method == \"PATCH\") {\n-        req.headers.emplace(\"Content-Length\", \"0\");\n+        req.set_header(\"Content-Length\", \"0\");\n       }\n     }\n   } else {\n     if (!req.has_header(\"Content-Type\")) {\n-      req.headers.emplace(\"Content-Type\", \"text/plain\");\n+      req.set_header(\"Content-Type\", \"text/plain\");\n     }\n \n     if (!req.has_header(\"Content-Length\")) {\n       auto length = std::to_string(req.body.size());\n-      req.headers.emplace(\"Content-Length\", length);\n+      req.set_header(\"Content-Length\", length);\n     }\n   }\n ",
        "diff_line_info": {
            "deleted_lines": [
                "      req.headers.emplace(\"Connection\", \"close\");",
                "        req.headers.emplace(\"Host\", host_);",
                "        req.headers.emplace(\"Host\", host_and_port_);",
                "        req.headers.emplace(\"Host\", host_);",
                "        req.headers.emplace(\"Host\", host_and_port_);",
                "  if (!req.has_header(\"Accept\")) { req.headers.emplace(\"Accept\", \"*/*\"); }",
                "    req.headers.emplace(\"User-Agent\", agent);",
                "          req.headers.emplace(\"Content-Length\", length);",
                "        req.headers.emplace(\"Content-Length\", \"0\");",
                "      req.headers.emplace(\"Content-Type\", \"text/plain\");",
                "      req.headers.emplace(\"Content-Length\", length);"
            ],
            "added_lines": [
                "      req.set_header(\"Connection\", \"close\");",
                "        req.set_header(\"Host\", host_);",
                "        req.set_header(\"Host\", host_and_port_);",
                "        req.set_header(\"Host\", host_);",
                "        req.set_header(\"Host\", host_and_port_);",
                "  if (!req.has_header(\"Accept\")) { req.set_header(\"Accept\", \"*/*\"); }",
                "    req.set_header(\"User-Agent\", agent);",
                "          req.set_header(\"Content-Length\", length);",
                "        req.set_header(\"Content-Length\", \"0\");",
                "      req.set_header(\"Content-Type\", \"text/plain\");",
                "      req.set_header(\"Content-Length\", length);"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-26130",
        "func_name": "yhirose/cpp-httplib/ClientImpl::send_with_content_provider",
        "description": "Versions of the package yhirose/cpp-httplib before 0.12.4 are vulnerable to CRLF Injection when untrusted user input is used to set the content-type header in the HTTP .Patch, .Post, .Put and .Delete requests. This can lead to logical errors and other misbehaviors.\r\r**Note:** This issue is present due to an incomplete fix for [CVE-2020-11709](https://security.snyk.io/vuln/SNYK-UNMANAGED-YHIROSECPPHTTPLIB-2366507).",
        "git_url": "https://github.com/yhirose/cpp-httplib/commit/5b397d455d25a391ba346863830c1949627b4d08",
        "commit_title": "Fix more CRLF injection problems.",
        "commit_text": "",
        "func_before": "inline std::unique_ptr<Response> ClientImpl::send_with_content_provider(\n    Request &req, const char *body, size_t content_length,\n    ContentProvider content_provider,\n    ContentProviderWithoutLength content_provider_without_length,\n    const std::string &content_type, Error &error) {\n  if (!content_type.empty()) {\n    req.headers.emplace(\"Content-Type\", content_type);\n  }\n\n#ifdef CPPHTTPLIB_ZLIB_SUPPORT\n  if (compress_) { req.headers.emplace(\"Content-Encoding\", \"gzip\"); }\n#endif\n\n#ifdef CPPHTTPLIB_ZLIB_SUPPORT\n  if (compress_ && !content_provider_without_length) {\n    // TODO: Brotli support\n    detail::gzip_compressor compressor;\n\n    if (content_provider) {\n      auto ok = true;\n      size_t offset = 0;\n      DataSink data_sink;\n\n      data_sink.write = [&](const char *data, size_t data_len) -> bool {\n        if (ok) {\n          auto last = offset + data_len == content_length;\n\n          auto ret = compressor.compress(\n              data, data_len, last,\n              [&](const char *compressed_data, size_t compressed_data_len) {\n                req.body.append(compressed_data, compressed_data_len);\n                return true;\n              });\n\n          if (ret) {\n            offset += data_len;\n          } else {\n            ok = false;\n          }\n        }\n        return ok;\n      };\n\n      while (ok && offset < content_length) {\n        if (!content_provider(offset, content_length - offset, data_sink)) {\n          error = Error::Canceled;\n          return nullptr;\n        }\n      }\n    } else {\n      if (!compressor.compress(body, content_length, true,\n                               [&](const char *data, size_t data_len) {\n                                 req.body.append(data, data_len);\n                                 return true;\n                               })) {\n        error = Error::Compression;\n        return nullptr;\n      }\n    }\n  } else\n#endif\n  {\n    if (content_provider) {\n      req.content_length_ = content_length;\n      req.content_provider_ = std::move(content_provider);\n      req.is_chunked_content_provider_ = false;\n    } else if (content_provider_without_length) {\n      req.content_length_ = 0;\n      req.content_provider_ = detail::ContentProviderAdapter(\n          std::move(content_provider_without_length));\n      req.is_chunked_content_provider_ = true;\n      req.headers.emplace(\"Transfer-Encoding\", \"chunked\");\n    } else {\n      req.body.assign(body, content_length);\n      ;\n    }\n  }\n\n  auto res = detail::make_unique<Response>();\n  return send(req, *res, error) ? std::move(res) : nullptr;\n}",
        "func": "inline std::unique_ptr<Response> ClientImpl::send_with_content_provider(\n    Request &req, const char *body, size_t content_length,\n    ContentProvider content_provider,\n    ContentProviderWithoutLength content_provider_without_length,\n    const std::string &content_type, Error &error) {\n  if (!content_type.empty()) { req.set_header(\"Content-Type\", content_type); }\n\n#ifdef CPPHTTPLIB_ZLIB_SUPPORT\n  if (compress_) { req.set_header(\"Content-Encoding\", \"gzip\"); }\n#endif\n\n#ifdef CPPHTTPLIB_ZLIB_SUPPORT\n  if (compress_ && !content_provider_without_length) {\n    // TODO: Brotli support\n    detail::gzip_compressor compressor;\n\n    if (content_provider) {\n      auto ok = true;\n      size_t offset = 0;\n      DataSink data_sink;\n\n      data_sink.write = [&](const char *data, size_t data_len) -> bool {\n        if (ok) {\n          auto last = offset + data_len == content_length;\n\n          auto ret = compressor.compress(\n              data, data_len, last,\n              [&](const char *compressed_data, size_t compressed_data_len) {\n                req.body.append(compressed_data, compressed_data_len);\n                return true;\n              });\n\n          if (ret) {\n            offset += data_len;\n          } else {\n            ok = false;\n          }\n        }\n        return ok;\n      };\n\n      while (ok && offset < content_length) {\n        if (!content_provider(offset, content_length - offset, data_sink)) {\n          error = Error::Canceled;\n          return nullptr;\n        }\n      }\n    } else {\n      if (!compressor.compress(body, content_length, true,\n                               [&](const char *data, size_t data_len) {\n                                 req.body.append(data, data_len);\n                                 return true;\n                               })) {\n        error = Error::Compression;\n        return nullptr;\n      }\n    }\n  } else\n#endif\n  {\n    if (content_provider) {\n      req.content_length_ = content_length;\n      req.content_provider_ = std::move(content_provider);\n      req.is_chunked_content_provider_ = false;\n    } else if (content_provider_without_length) {\n      req.content_length_ = 0;\n      req.content_provider_ = detail::ContentProviderAdapter(\n          std::move(content_provider_without_length));\n      req.is_chunked_content_provider_ = true;\n      req.set_header(\"Transfer-Encoding\", \"chunked\");\n    } else {\n      req.body.assign(body, content_length);\n      ;\n    }\n  }\n\n  auto res = detail::make_unique<Response>();\n  return send(req, *res, error) ? std::move(res) : nullptr;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,12 +3,10 @@\n     ContentProvider content_provider,\n     ContentProviderWithoutLength content_provider_without_length,\n     const std::string &content_type, Error &error) {\n-  if (!content_type.empty()) {\n-    req.headers.emplace(\"Content-Type\", content_type);\n-  }\n+  if (!content_type.empty()) { req.set_header(\"Content-Type\", content_type); }\n \n #ifdef CPPHTTPLIB_ZLIB_SUPPORT\n-  if (compress_) { req.headers.emplace(\"Content-Encoding\", \"gzip\"); }\n+  if (compress_) { req.set_header(\"Content-Encoding\", \"gzip\"); }\n #endif\n \n #ifdef CPPHTTPLIB_ZLIB_SUPPORT\n@@ -69,7 +67,7 @@\n       req.content_provider_ = detail::ContentProviderAdapter(\n           std::move(content_provider_without_length));\n       req.is_chunked_content_provider_ = true;\n-      req.headers.emplace(\"Transfer-Encoding\", \"chunked\");\n+      req.set_header(\"Transfer-Encoding\", \"chunked\");\n     } else {\n       req.body.assign(body, content_length);\n       ;",
        "diff_line_info": {
            "deleted_lines": [
                "  if (!content_type.empty()) {",
                "    req.headers.emplace(\"Content-Type\", content_type);",
                "  }",
                "  if (compress_) { req.headers.emplace(\"Content-Encoding\", \"gzip\"); }",
                "      req.headers.emplace(\"Transfer-Encoding\", \"chunked\");"
            ],
            "added_lines": [
                "  if (!content_type.empty()) { req.set_header(\"Content-Type\", content_type); }",
                "  if (compress_) { req.set_header(\"Content-Encoding\", \"gzip\"); }",
                "      req.set_header(\"Transfer-Encoding\", \"chunked\");"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-26130",
        "func_name": "yhirose/cpp-httplib/Server::apply_ranges",
        "description": "Versions of the package yhirose/cpp-httplib before 0.12.4 are vulnerable to CRLF Injection when untrusted user input is used to set the content-type header in the HTTP .Patch, .Post, .Put and .Delete requests. This can lead to logical errors and other misbehaviors.\r\r**Note:** This issue is present due to an incomplete fix for [CVE-2020-11709](https://security.snyk.io/vuln/SNYK-UNMANAGED-YHIROSECPPHTTPLIB-2366507).",
        "git_url": "https://github.com/yhirose/cpp-httplib/commit/5b397d455d25a391ba346863830c1949627b4d08",
        "commit_title": "Fix more CRLF injection problems.",
        "commit_text": "",
        "func_before": "inline void Server::apply_ranges(const Request &req, Response &res,\n                                 std::string &content_type,\n                                 std::string &boundary) {\n  if (req.ranges.size() > 1) {\n    boundary = detail::make_multipart_data_boundary();\n\n    auto it = res.headers.find(\"Content-Type\");\n    if (it != res.headers.end()) {\n      content_type = it->second;\n      res.headers.erase(it);\n    }\n\n    res.headers.emplace(\"Content-Type\",\n                        \"multipart/byteranges; boundary=\" + boundary);\n  }\n\n  auto type = detail::encoding_type(req, res);\n\n  if (res.body.empty()) {\n    if (res.content_length_ > 0) {\n      size_t length = 0;\n      if (req.ranges.empty()) {\n        length = res.content_length_;\n      } else if (req.ranges.size() == 1) {\n        auto offsets =\n            detail::get_range_offset_and_length(req, res.content_length_, 0);\n        auto offset = offsets.first;\n        length = offsets.second;\n        auto content_range = detail::make_content_range_header_field(\n            offset, length, res.content_length_);\n        res.set_header(\"Content-Range\", content_range);\n      } else {\n        length = detail::get_multipart_ranges_data_length(req, res, boundary,\n                                                          content_type);\n      }\n      res.set_header(\"Content-Length\", std::to_string(length));\n    } else {\n      if (res.content_provider_) {\n        if (res.is_chunked_content_provider_) {\n          res.set_header(\"Transfer-Encoding\", \"chunked\");\n          if (type == detail::EncodingType::Gzip) {\n            res.set_header(\"Content-Encoding\", \"gzip\");\n          } else if (type == detail::EncodingType::Brotli) {\n            res.set_header(\"Content-Encoding\", \"br\");\n          }\n        }\n      }\n    }\n  } else {\n    if (req.ranges.empty()) {\n      ;\n    } else if (req.ranges.size() == 1) {\n      auto offsets =\n          detail::get_range_offset_and_length(req, res.body.size(), 0);\n      auto offset = offsets.first;\n      auto length = offsets.second;\n      auto content_range = detail::make_content_range_header_field(\n          offset, length, res.body.size());\n      res.set_header(\"Content-Range\", content_range);\n      if (offset < res.body.size()) {\n        res.body = res.body.substr(offset, length);\n      } else {\n        res.body.clear();\n        res.status = 416;\n      }\n    } else {\n      std::string data;\n      if (detail::make_multipart_ranges_data(req, res, boundary, content_type,\n                                             data)) {\n        res.body.swap(data);\n      } else {\n        res.body.clear();\n        res.status = 416;\n      }\n    }\n\n    if (type != detail::EncodingType::None) {\n      std::unique_ptr<detail::compressor> compressor;\n      std::string content_encoding;\n\n      if (type == detail::EncodingType::Gzip) {\n#ifdef CPPHTTPLIB_ZLIB_SUPPORT\n        compressor = detail::make_unique<detail::gzip_compressor>();\n        content_encoding = \"gzip\";\n#endif\n      } else if (type == detail::EncodingType::Brotli) {\n#ifdef CPPHTTPLIB_BROTLI_SUPPORT\n        compressor = detail::make_unique<detail::brotli_compressor>();\n        content_encoding = \"br\";\n#endif\n      }\n\n      if (compressor) {\n        std::string compressed;\n        if (compressor->compress(res.body.data(), res.body.size(), true,\n                                 [&](const char *data, size_t data_len) {\n                                   compressed.append(data, data_len);\n                                   return true;\n                                 })) {\n          res.body.swap(compressed);\n          res.set_header(\"Content-Encoding\", content_encoding);\n        }\n      }\n    }\n\n    auto length = std::to_string(res.body.size());\n    res.set_header(\"Content-Length\", length);\n  }\n}",
        "func": "inline void Server::apply_ranges(const Request &req, Response &res,\n                                 std::string &content_type,\n                                 std::string &boundary) {\n  if (req.ranges.size() > 1) {\n    boundary = detail::make_multipart_data_boundary();\n\n    auto it = res.headers.find(\"Content-Type\");\n    if (it != res.headers.end()) {\n      content_type = it->second;\n      res.headers.erase(it);\n    }\n\n    res.set_header(\"Content-Type\",\n                   \"multipart/byteranges; boundary=\" + boundary);\n  }\n\n  auto type = detail::encoding_type(req, res);\n\n  if (res.body.empty()) {\n    if (res.content_length_ > 0) {\n      size_t length = 0;\n      if (req.ranges.empty()) {\n        length = res.content_length_;\n      } else if (req.ranges.size() == 1) {\n        auto offsets =\n            detail::get_range_offset_and_length(req, res.content_length_, 0);\n        auto offset = offsets.first;\n        length = offsets.second;\n        auto content_range = detail::make_content_range_header_field(\n            offset, length, res.content_length_);\n        res.set_header(\"Content-Range\", content_range);\n      } else {\n        length = detail::get_multipart_ranges_data_length(req, res, boundary,\n                                                          content_type);\n      }\n      res.set_header(\"Content-Length\", std::to_string(length));\n    } else {\n      if (res.content_provider_) {\n        if (res.is_chunked_content_provider_) {\n          res.set_header(\"Transfer-Encoding\", \"chunked\");\n          if (type == detail::EncodingType::Gzip) {\n            res.set_header(\"Content-Encoding\", \"gzip\");\n          } else if (type == detail::EncodingType::Brotli) {\n            res.set_header(\"Content-Encoding\", \"br\");\n          }\n        }\n      }\n    }\n  } else {\n    if (req.ranges.empty()) {\n      ;\n    } else if (req.ranges.size() == 1) {\n      auto offsets =\n          detail::get_range_offset_and_length(req, res.body.size(), 0);\n      auto offset = offsets.first;\n      auto length = offsets.second;\n      auto content_range = detail::make_content_range_header_field(\n          offset, length, res.body.size());\n      res.set_header(\"Content-Range\", content_range);\n      if (offset < res.body.size()) {\n        res.body = res.body.substr(offset, length);\n      } else {\n        res.body.clear();\n        res.status = 416;\n      }\n    } else {\n      std::string data;\n      if (detail::make_multipart_ranges_data(req, res, boundary, content_type,\n                                             data)) {\n        res.body.swap(data);\n      } else {\n        res.body.clear();\n        res.status = 416;\n      }\n    }\n\n    if (type != detail::EncodingType::None) {\n      std::unique_ptr<detail::compressor> compressor;\n      std::string content_encoding;\n\n      if (type == detail::EncodingType::Gzip) {\n#ifdef CPPHTTPLIB_ZLIB_SUPPORT\n        compressor = detail::make_unique<detail::gzip_compressor>();\n        content_encoding = \"gzip\";\n#endif\n      } else if (type == detail::EncodingType::Brotli) {\n#ifdef CPPHTTPLIB_BROTLI_SUPPORT\n        compressor = detail::make_unique<detail::brotli_compressor>();\n        content_encoding = \"br\";\n#endif\n      }\n\n      if (compressor) {\n        std::string compressed;\n        if (compressor->compress(res.body.data(), res.body.size(), true,\n                                 [&](const char *data, size_t data_len) {\n                                   compressed.append(data, data_len);\n                                   return true;\n                                 })) {\n          res.body.swap(compressed);\n          res.set_header(\"Content-Encoding\", content_encoding);\n        }\n      }\n    }\n\n    auto length = std::to_string(res.body.size());\n    res.set_header(\"Content-Length\", length);\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -10,8 +10,8 @@\n       res.headers.erase(it);\n     }\n \n-    res.headers.emplace(\"Content-Type\",\n-                        \"multipart/byteranges; boundary=\" + boundary);\n+    res.set_header(\"Content-Type\",\n+                   \"multipart/byteranges; boundary=\" + boundary);\n   }\n \n   auto type = detail::encoding_type(req, res);",
        "diff_line_info": {
            "deleted_lines": [
                "    res.headers.emplace(\"Content-Type\",",
                "                        \"multipart/byteranges; boundary=\" + boundary);"
            ],
            "added_lines": [
                "    res.set_header(\"Content-Type\",",
                "                   \"multipart/byteranges; boundary=\" + boundary);"
            ]
        }
    },
    {
        "cve_id": "CVE-2010-4654",
        "func_name": "poppler/Gfx::restoreState",
        "description": "poppler before 0.16.3 has malformed commands that may cause corruption of the internal stack.",
        "git_url": "http://cgit.freedesktop.org/poppler/poppler/commit/?id=8284008aa8230a92ba08d547864353d3290e9bf9",
        "commit_title": "While a stack of states is a good way to maintain graphics contexts, if",
        "commit_text": "the command stream you are interpreting is untrusted, we must place appropriate guards to be sure that, not only do we not pop past the end of the stack, but we do not pop past the stack as it was when we began rendering. ",
        "func_before": "void Gfx::restoreState() {\n  state = state->restore();\n  out->restoreState(state);\n  stackHeight--;\n}",
        "func": "void Gfx::restoreState() {\n  if (stackHeight <= bottomGuard() || !state->hasSaves()) {\n    error(-1, \"Restoring state when no valid states to pop\");\n    return;\n  }\n  state = state->restore();\n  out->restoreState(state);\n  stackHeight--;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,8 @@\n void Gfx::restoreState() {\n+  if (stackHeight <= bottomGuard() || !state->hasSaves()) {\n+    error(-1, \"Restoring state when no valid states to pop\");\n+    return;\n+  }\n   state = state->restore();\n   out->restoreState(state);\n   stackHeight--;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "  if (stackHeight <= bottomGuard() || !state->hasSaves()) {",
                "    error(-1, \"Restoring state when no valid states to pop\");",
                "    return;",
                "  }"
            ]
        }
    },
    {
        "cve_id": "CVE-2010-4654",
        "func_name": "poppler/Gfx::Gfx",
        "description": "poppler before 0.16.3 has malformed commands that may cause corruption of the internal stack.",
        "git_url": "http://cgit.freedesktop.org/poppler/poppler/commit/?id=8284008aa8230a92ba08d547864353d3290e9bf9",
        "commit_title": "While a stack of states is a good way to maintain graphics contexts, if",
        "commit_text": "the command stream you are interpreting is untrusted, we must place appropriate guards to be sure that, not only do we not pop past the end of the stack, but we do not pop past the stack as it was when we began rendering. ",
        "func_before": "Gfx::Gfx(XRef *xrefA, OutputDev *outA, int pageNum, Dict *resDict, Catalog *catalogA,\n\t double hDPI, double vDPI, PDFRectangle *box,\n\t PDFRectangle *cropBox, int rotate,\n\t GBool (*abortCheckCbkA)(void *data),\n\t void *abortCheckCbkDataA)\n#ifdef USE_CMS\n : iccColorSpaceCache(5)\n#endif\n{\n  int i;\n\n  xref = xrefA;\n  catalog = catalogA;\n  subPage = gFalse;\n  printCommands = globalParams->getPrintCommands();\n  profileCommands = globalParams->getProfileCommands();\n  textHaveCSPattern = gFalse;\n  drawText = gFalse;\n  maskHaveCSPattern = gFalse;\n  mcStack = NULL;\n\n  // start the resource stack\n  res = new GfxResources(xref, resDict, NULL);\n\n  // initialize\n  out = outA;\n  state = new GfxState(hDPI, vDPI, box, rotate, out->upsideDown());\n  stackHeight = 1;\n  fontChanged = gFalse;\n  clip = clipNone;\n  ignoreUndef = 0;\n  out->startPage(pageNum, state);\n  out->setDefaultCTM(state->getCTM());\n  out->updateAll(state);\n  for (i = 0; i < 6; ++i) {\n    baseMatrix[i] = state->getCTM()[i];\n  }\n  formDepth = 0;\n  abortCheckCbk = abortCheckCbkA;\n  abortCheckCbkData = abortCheckCbkDataA;\n\n  // set crop box\n  if (cropBox) {\n    state->moveTo(cropBox->x1, cropBox->y1);\n    state->lineTo(cropBox->x2, cropBox->y1);\n    state->lineTo(cropBox->x2, cropBox->y2);\n    state->lineTo(cropBox->x1, cropBox->y2);\n    state->closePath();\n    state->clip();\n    out->clip(state);\n    state->clearPath();\n  }\n}",
        "func": "Gfx::Gfx(XRef *xrefA, OutputDev *outA, int pageNum, Dict *resDict, Catalog *catalogA,\n\t double hDPI, double vDPI, PDFRectangle *box,\n\t PDFRectangle *cropBox, int rotate,\n\t GBool (*abortCheckCbkA)(void *data),\n\t void *abortCheckCbkDataA)\n#ifdef USE_CMS\n : iccColorSpaceCache(5)\n#endif\n{\n  int i;\n\n  xref = xrefA;\n  catalog = catalogA;\n  subPage = gFalse;\n  printCommands = globalParams->getPrintCommands();\n  profileCommands = globalParams->getProfileCommands();\n  textHaveCSPattern = gFalse;\n  drawText = gFalse;\n  maskHaveCSPattern = gFalse;\n  mcStack = NULL;\n\n  // start the resource stack\n  res = new GfxResources(xref, resDict, NULL);\n\n  // initialize\n  out = outA;\n  state = new GfxState(hDPI, vDPI, box, rotate, out->upsideDown());\n  stackHeight = 1;\n  pushStateGuard();\n  fontChanged = gFalse;\n  clip = clipNone;\n  ignoreUndef = 0;\n  out->startPage(pageNum, state);\n  out->setDefaultCTM(state->getCTM());\n  out->updateAll(state);\n  for (i = 0; i < 6; ++i) {\n    baseMatrix[i] = state->getCTM()[i];\n  }\n  formDepth = 0;\n  abortCheckCbk = abortCheckCbkA;\n  abortCheckCbkData = abortCheckCbkDataA;\n\n  // set crop box\n  if (cropBox) {\n    state->moveTo(cropBox->x1, cropBox->y1);\n    state->lineTo(cropBox->x2, cropBox->y1);\n    state->lineTo(cropBox->x2, cropBox->y2);\n    state->lineTo(cropBox->x1, cropBox->y2);\n    state->closePath();\n    state->clip();\n    out->clip(state);\n    state->clearPath();\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -26,6 +26,7 @@\n   out = outA;\n   state = new GfxState(hDPI, vDPI, box, rotate, out->upsideDown());\n   stackHeight = 1;\n+  pushStateGuard();\n   fontChanged = gFalse;\n   clip = clipNone;\n   ignoreUndef = 0;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "  pushStateGuard();"
            ]
        }
    },
    {
        "cve_id": "CVE-2010-4654",
        "func_name": "poppler/Gfx::~Gfx",
        "description": "poppler before 0.16.3 has malformed commands that may cause corruption of the internal stack.",
        "git_url": "http://cgit.freedesktop.org/poppler/poppler/commit/?id=8284008aa8230a92ba08d547864353d3290e9bf9",
        "commit_title": "While a stack of states is a good way to maintain graphics contexts, if",
        "commit_text": "the command stream you are interpreting is untrusted, we must place appropriate guards to be sure that, not only do we not pop past the end of the stack, but we do not pop past the stack as it was when we began rendering. ",
        "func_before": "Gfx::~Gfx() {\n  while (state->hasSaves()) {\n    restoreState();\n  }\n  if (!subPage) {\n    out->endPage();\n  }\n  while (res) {\n    popResources();\n  }\n  if (state) {\n    delete state;\n  }\n  while (mcStack) {\n    popMarkedContent();\n  }\n}",
        "func": "Gfx::~Gfx() {\n  while (stateGuards.size()) {\n    popStateGuard();\n  }\n  // There shouldn't be more saves, but pop them if there were any\n  while (state->hasSaves()) {\n    error(-1, \"Found state under last state guard. Popping.\");\n    restoreState();\n  }\n  if (!subPage) {\n    out->endPage();\n  }\n  while (res) {\n    popResources();\n  }\n  if (state) {\n    delete state;\n  }\n  while (mcStack) {\n    popMarkedContent();\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,10 @@\n Gfx::~Gfx() {\n+  while (stateGuards.size()) {\n+    popStateGuard();\n+  }\n+  // There shouldn't be more saves, but pop them if there were any\n   while (state->hasSaves()) {\n+    error(-1, \"Found state under last state guard. Popping.\");\n     restoreState();\n   }\n   if (!subPage) {",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "  while (stateGuards.size()) {",
                "    popStateGuard();",
                "  }",
                "  // There shouldn't be more saves, but pop them if there were any",
                "    error(-1, \"Found state under last state guard. Popping.\");"
            ]
        }
    },
    {
        "cve_id": "CVE-2010-4654",
        "func_name": "poppler/Gfx::go",
        "description": "poppler before 0.16.3 has malformed commands that may cause corruption of the internal stack.",
        "git_url": "http://cgit.freedesktop.org/poppler/poppler/commit/?id=8284008aa8230a92ba08d547864353d3290e9bf9",
        "commit_title": "While a stack of states is a good way to maintain graphics contexts, if",
        "commit_text": "the command stream you are interpreting is untrusted, we must place appropriate guards to be sure that, not only do we not pop past the end of the stack, but we do not pop past the stack as it was when we began rendering. ",
        "func_before": "void Gfx::go(GBool topLevel) {\n  Object obj;\n  Object args[maxArgs];\n  int numArgs, i;\n  int lastAbortCheck;\n\n  // scan a sequence of objects\n  updateLevel = lastAbortCheck = 0;\n  numArgs = 0;\n  parser->getObj(&obj);\n  while (!obj.isEOF()) {\n\n    // got a command - execute it\n    if (obj.isCmd()) {\n      if (printCommands) {\n\tobj.print(stdout);\n\tfor (i = 0; i < numArgs; ++i) {\n\t  printf(\" \");\n\t  args[i].print(stdout);\n\t}\n\tprintf(\"\\n\");\n\tfflush(stdout);\n      }\n      GooTimer timer;\n\n      // Run the operation\n      execOp(&obj, args, numArgs);\n\n      // Update the profile information\n      if (profileCommands) {\n\tGooHash *hash;\n\n\thash = out->getProfileHash ();\n\tif (hash) {\n\t  GooString *cmd_g;\n\t  ProfileData *data_p;\n\n\t  cmd_g = new GooString (obj.getCmd());\n\t  data_p = (ProfileData *)hash->lookup (cmd_g);\n\t  if (data_p == NULL) {\n\t    data_p = new ProfileData();\n\t    hash->add (cmd_g, data_p);\n\t  }\n\t  \n\t  data_p->addElement(timer.getElapsed ());\n\t}\n      }\n      obj.free();\n      for (i = 0; i < numArgs; ++i)\n\targs[i].free();\n      numArgs = 0;\n\n      // periodically update display\n      if (++updateLevel >= 20000) {\n\tout->dump();\n\tupdateLevel = 0;\n      }\n\n      // check for an abort\n      if (abortCheckCbk) {\n\tif (updateLevel - lastAbortCheck > 10) {\n\t  if ((*abortCheckCbk)(abortCheckCbkData)) {\n\t    break;\n\t  }\n\t  lastAbortCheck = updateLevel;\n\t}\n      }\n\n    // got an argument - save it\n    } else if (numArgs < maxArgs) {\n      args[numArgs++] = obj;\n\n    // too many arguments - something is wrong\n    } else {\n      error(getPos(), \"Too many args in content stream\");\n      if (printCommands) {\n\tprintf(\"throwing away arg: \");\n\tobj.print(stdout);\n\tprintf(\"\\n\");\n\tfflush(stdout);\n      }\n      obj.free();\n    }\n\n    // grab the next object\n    parser->getObj(&obj);\n  }\n  obj.free();\n\n  // args at end with no command\n  if (numArgs > 0) {\n    error(getPos(), \"Leftover args in content stream\");\n    if (printCommands) {\n      printf(\"%d leftovers:\", numArgs);\n      for (i = 0; i < numArgs; ++i) {\n\tprintf(\" \");\n\targs[i].print(stdout);\n      }\n      printf(\"\\n\");\n      fflush(stdout);\n    }\n    for (i = 0; i < numArgs; ++i)\n      args[i].free();\n  }\n\n  // update display\n  if (topLevel && updateLevel > 0) {\n    out->dump();\n  }\n}",
        "func": "void Gfx::go(GBool topLevel) {\n  Object obj;\n  Object args[maxArgs];\n  int numArgs, i;\n  int lastAbortCheck;\n\n  // scan a sequence of objects\n  pushStateGuard();\n  updateLevel = lastAbortCheck = 0;\n  numArgs = 0;\n  parser->getObj(&obj);\n  while (!obj.isEOF()) {\n\n    // got a command - execute it\n    if (obj.isCmd()) {\n      if (printCommands) {\n\tobj.print(stdout);\n\tfor (i = 0; i < numArgs; ++i) {\n\t  printf(\" \");\n\t  args[i].print(stdout);\n\t}\n\tprintf(\"\\n\");\n\tfflush(stdout);\n      }\n      GooTimer timer;\n\n      // Run the operation\n      execOp(&obj, args, numArgs);\n\n      // Update the profile information\n      if (profileCommands) {\n\tGooHash *hash;\n\n\thash = out->getProfileHash ();\n\tif (hash) {\n\t  GooString *cmd_g;\n\t  ProfileData *data_p;\n\n\t  cmd_g = new GooString (obj.getCmd());\n\t  data_p = (ProfileData *)hash->lookup (cmd_g);\n\t  if (data_p == NULL) {\n\t    data_p = new ProfileData();\n\t    hash->add (cmd_g, data_p);\n\t  }\n\t  \n\t  data_p->addElement(timer.getElapsed ());\n\t}\n      }\n      obj.free();\n      for (i = 0; i < numArgs; ++i)\n\targs[i].free();\n      numArgs = 0;\n\n      // periodically update display\n      if (++updateLevel >= 20000) {\n\tout->dump();\n\tupdateLevel = 0;\n      }\n\n      // check for an abort\n      if (abortCheckCbk) {\n\tif (updateLevel - lastAbortCheck > 10) {\n\t  if ((*abortCheckCbk)(abortCheckCbkData)) {\n\t    break;\n\t  }\n\t  lastAbortCheck = updateLevel;\n\t}\n      }\n\n    // got an argument - save it\n    } else if (numArgs < maxArgs) {\n      args[numArgs++] = obj;\n\n    // too many arguments - something is wrong\n    } else {\n      error(getPos(), \"Too many args in content stream\");\n      if (printCommands) {\n\tprintf(\"throwing away arg: \");\n\tobj.print(stdout);\n\tprintf(\"\\n\");\n\tfflush(stdout);\n      }\n      obj.free();\n    }\n\n    // grab the next object\n    parser->getObj(&obj);\n  }\n  obj.free();\n\n  // args at end with no command\n  if (numArgs > 0) {\n    error(getPos(), \"Leftover args in content stream\");\n    if (printCommands) {\n      printf(\"%d leftovers:\", numArgs);\n      for (i = 0; i < numArgs; ++i) {\n\tprintf(\" \");\n\targs[i].print(stdout);\n      }\n      printf(\"\\n\");\n      fflush(stdout);\n    }\n    for (i = 0; i < numArgs; ++i)\n      args[i].free();\n  }\n\n  popStateGuard();\n\n  // update display\n  if (topLevel && updateLevel > 0) {\n    out->dump();\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,6 +5,7 @@\n   int lastAbortCheck;\n \n   // scan a sequence of objects\n+  pushStateGuard();\n   updateLevel = lastAbortCheck = 0;\n   numArgs = 0;\n   parser->getObj(&obj);\n@@ -103,6 +104,8 @@\n       args[i].free();\n   }\n \n+  popStateGuard();\n+\n   // update display\n   if (topLevel && updateLevel > 0) {\n     out->dump();",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "  pushStateGuard();",
                "  popStateGuard();",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2010-4654",
        "func_name": "poppler/Gfx::Gfx",
        "description": "poppler before 0.16.3 has malformed commands that may cause corruption of the internal stack.",
        "git_url": "http://cgit.freedesktop.org/poppler/poppler/commit/?id=8284008aa8230a92ba08d547864353d3290e9bf9",
        "commit_title": "While a stack of states is a good way to maintain graphics contexts, if",
        "commit_text": "the command stream you are interpreting is untrusted, we must place appropriate guards to be sure that, not only do we not pop past the end of the stack, but we do not pop past the stack as it was when we began rendering. ",
        "func_before": "Gfx::Gfx(XRef *xrefA, OutputDev *outA, Dict *resDict, Catalog *catalogA,\n\t PDFRectangle *box, PDFRectangle *cropBox,\n\t GBool (*abortCheckCbkA)(void *data),\n\t void *abortCheckCbkDataA)\n #ifdef USE_CMS\n : iccColorSpaceCache(5)\n#endif\n{\n  int i;\n\n  xref = xrefA;\n  catalog = catalogA;\n  subPage = gTrue;\n  printCommands = globalParams->getPrintCommands();\n  profileCommands = globalParams->getProfileCommands();\n  textHaveCSPattern = gFalse;\n  drawText = gFalse;\n  maskHaveCSPattern = gFalse;\n  mcStack = NULL;\n\n  // start the resource stack\n  res = new GfxResources(xref, resDict, NULL);\n\n  // initialize\n  out = outA;\n  state = new GfxState(72, 72, box, 0, gFalse);\n  stackHeight = 1;\n  fontChanged = gFalse;\n  clip = clipNone;\n  ignoreUndef = 0;\n  for (i = 0; i < 6; ++i) {\n    baseMatrix[i] = state->getCTM()[i];\n  }\n  formDepth = 0;\n  abortCheckCbk = abortCheckCbkA;\n  abortCheckCbkData = abortCheckCbkDataA;\n\n  // set crop box\n  if (cropBox) {\n    state->moveTo(cropBox->x1, cropBox->y1);\n    state->lineTo(cropBox->x2, cropBox->y1);\n    state->lineTo(cropBox->x2, cropBox->y2);\n    state->lineTo(cropBox->x1, cropBox->y2);\n    state->closePath();\n    state->clip();\n    out->clip(state);\n    state->clearPath();\n  }\n}",
        "func": "Gfx::Gfx(XRef *xrefA, OutputDev *outA, Dict *resDict, Catalog *catalogA,\n\t PDFRectangle *box, PDFRectangle *cropBox,\n\t GBool (*abortCheckCbkA)(void *data),\n\t void *abortCheckCbkDataA)\n #ifdef USE_CMS\n : iccColorSpaceCache(5)\n#endif\n{\n  int i;\n\n  xref = xrefA;\n  catalog = catalogA;\n  subPage = gTrue;\n  printCommands = globalParams->getPrintCommands();\n  profileCommands = globalParams->getProfileCommands();\n  textHaveCSPattern = gFalse;\n  drawText = gFalse;\n  maskHaveCSPattern = gFalse;\n  mcStack = NULL;\n\n  // start the resource stack\n  res = new GfxResources(xref, resDict, NULL);\n\n  // initialize\n  out = outA;\n  state = new GfxState(72, 72, box, 0, gFalse);\n  stackHeight = 1;\n  pushStateGuard();\n  fontChanged = gFalse;\n  clip = clipNone;\n  ignoreUndef = 0;\n  for (i = 0; i < 6; ++i) {\n    baseMatrix[i] = state->getCTM()[i];\n  }\n  formDepth = 0;\n  abortCheckCbk = abortCheckCbkA;\n  abortCheckCbkData = abortCheckCbkDataA;\n\n  // set crop box\n  if (cropBox) {\n    state->moveTo(cropBox->x1, cropBox->y1);\n    state->lineTo(cropBox->x2, cropBox->y1);\n    state->lineTo(cropBox->x2, cropBox->y2);\n    state->lineTo(cropBox->x1, cropBox->y2);\n    state->closePath();\n    state->clip();\n    out->clip(state);\n    state->clearPath();\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -25,6 +25,7 @@\n   out = outA;\n   state = new GfxState(72, 72, box, 0, gFalse);\n   stackHeight = 1;\n+  pushStateGuard();\n   fontChanged = gFalse;\n   clip = clipNone;\n   ignoreUndef = 0;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "  pushStateGuard();"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-26298",
        "func_name": "vmg/redcarpet/rndr_quote",
        "description": "Redcarpet is a Ruby library for Markdown processing. In Redcarpet before version 3.5.1, there is an injection vulnerability which can enable a cross-site scripting attack. In affected versions no HTML escaping was being performed when processing quotes. This applies even when the `:escape_html` option was being used. This is fixed in version 3.5.1 by the referenced commit.",
        "git_url": "https://github.com/vmg/redcarpet/commit/a699c82292b17c8e6a62e1914d5eccc252272793",
        "commit_title": "Fix a security issue using `:quote` with `:escape_html`",
        "commit_text": " Reported by @johan-smits.",
        "func_before": "static int\nrndr_quote(struct buf *ob, const struct buf *text, void *opaque)\n{\n\tif (!text || !text->size)\n\t\treturn 0;\n\n\tBUFPUTSL(ob, \"<q>\");\n\tbufput(ob, text->data, text->size);\n\tBUFPUTSL(ob, \"</q>\");\n\n\treturn 1;\n}",
        "func": "static int\nrndr_quote(struct buf *ob, const struct buf *text, void *opaque)\n{\n\tif (!text || !text->size)\n\t\treturn 0;\n\n\tstruct html_renderopt *options = opaque;\n\n\tBUFPUTSL(ob, \"<q>\");\n\n\tif (options->flags & HTML_ESCAPE)\n\t\tescape_html(ob, text->data, text->size);\n\telse\n\t\tbufput(ob, text->data, text->size);\n\n\tBUFPUTSL(ob, \"</q>\");\n\n\treturn 1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,8 +4,15 @@\n \tif (!text || !text->size)\n \t\treturn 0;\n \n+\tstruct html_renderopt *options = opaque;\n+\n \tBUFPUTSL(ob, \"<q>\");\n-\tbufput(ob, text->data, text->size);\n+\n+\tif (options->flags & HTML_ESCAPE)\n+\t\tescape_html(ob, text->data, text->size);\n+\telse\n+\t\tbufput(ob, text->data, text->size);\n+\n \tBUFPUTSL(ob, \"</q>\");\n \n \treturn 1;",
        "diff_line_info": {
            "deleted_lines": [
                "\tbufput(ob, text->data, text->size);"
            ],
            "added_lines": [
                "\tstruct html_renderopt *options = opaque;",
                "",
                "",
                "\tif (options->flags & HTML_ESCAPE)",
                "\t\tescape_html(ob, text->data, text->size);",
                "\telse",
                "\t\tbufput(ob, text->data, text->size);",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2021-21261",
        "func_name": "flatpak/handle_spawn",
        "description": "Flatpak is a system for building, distributing, and running sandboxed desktop applications on Linux. A bug was discovered in the `flatpak-portal` service that can allow sandboxed applications to execute arbitrary code on the host system (a sandbox escape). This sandbox-escape bug is present in versions from 0.11.4 and before fixed versions 1.8.5 and 1.10.0. The Flatpak portal D-Bus service (`flatpak-portal`, also known by its D-Bus service name `org.freedesktop.portal.Flatpak`) allows apps in a Flatpak sandbox to launch their own subprocesses in a new sandbox instance, either with the same security settings as the caller or with more restrictive security settings. For example, this is used in Flatpak-packaged web browsers such as Chromium to launch subprocesses that will process untrusted web content, and give those subprocesses a more restrictive sandbox than the browser itself. In vulnerable versions, the Flatpak portal service passes caller-specified environment variables to non-sandboxed processes on the host system, and in particular to the `flatpak run` command that is used to launch the new sandbox instance. A malicious or compromised Flatpak app could set environment variables that are trusted by the `flatpak run` command, and use them to execute arbitrary code that is not in a sandbox. As a workaround, this vulnerability can be mitigated by preventing the `flatpak-portal` service from starting, but that mitigation will prevent many Flatpak apps from working correctly. This is fixed in versions 1.8.5 and 1.10.0.",
        "git_url": "https://github.com/flatpak/flatpak/commit/cc1401043c075268ecc652eac557ef8076b5eaba",
        "commit_title": "portal: Do not use caller-supplied variables in environment",
        "commit_text": " If the caller specifies a variable that can be used to inject arbitrary code into processes, we must not allow it to enter the environment block used to run `flatpak run`, which runs unsandboxed.  This change requires the previous commit \"context: Add --env-fd option\", which adds infrastructure used here.  To be secure, this change also requires the previous commit \"run: Convert all environment variables into bwrap arguments\", which protects a non-setuid bwrap(1) from the same attack.  Part-of: https://github.com/flatpak/flatpak/security/advisories/GHSA-4ppf-fxf6-vxg2",
        "func_before": "static gboolean\nhandle_spawn (PortalFlatpak         *object,\n              GDBusMethodInvocation *invocation,\n              GUnixFDList           *fd_list,\n              const gchar           *arg_cwd_path,\n              const gchar *const    *arg_argv,\n              GVariant              *arg_fds,\n              GVariant              *arg_envs,\n              guint                  arg_flags,\n              GVariant              *arg_options)\n{\n  g_autoptr(GError) error = NULL;\n  ChildSetupData child_setup_data = { NULL };\n  GPid pid;\n  PidData *pid_data;\n  InstanceIdReadData *instance_id_read_data = NULL;\n  gsize i, j, n_fds, n_envs;\n  const gint *fds = NULL;\n  gint fds_len = 0;\n  g_autofree FdMapEntry *fd_map = NULL;\n  gchar **env;\n  gint32 max_fd;\n  GKeyFile *app_info;\n  g_autoptr(GPtrArray) flatpak_argv = g_ptr_array_new_with_free_func (g_free);\n  g_autofree char *app_id = NULL;\n  g_autofree char *branch = NULL;\n  g_autofree char *arch = NULL;\n  g_autofree char *app_commit = NULL;\n  g_autofree char *runtime_ref = NULL;\n  g_auto(GStrv) runtime_parts = NULL;\n  g_autofree char *runtime_commit = NULL;\n  g_autofree char *instance_path = NULL;\n  g_auto(GStrv) extra_args = NULL;\n  g_auto(GStrv) shares = NULL;\n  g_auto(GStrv) sockets = NULL;\n  g_auto(GStrv) devices = NULL;\n  g_auto(GStrv) sandbox_expose = NULL;\n  g_auto(GStrv) sandbox_expose_ro = NULL;\n  g_autoptr(GVariant) sandbox_expose_fd = NULL;\n  g_autoptr(GVariant) sandbox_expose_fd_ro = NULL;\n  g_autoptr(GOutputStream) instance_id_out_stream = NULL;\n  guint sandbox_flags = 0;\n  gboolean sandboxed;\n  gboolean expose_pids;\n  gboolean share_pids;\n  gboolean notify_start;\n  gboolean devel;\n  g_autoptr(GString) env_string = g_string_new (\"\");\n\n  child_setup_data.instance_id_fd = -1;\n  child_setup_data.env_fd = -1;\n\n  if (fd_list != NULL)\n    fds = g_unix_fd_list_peek_fds (fd_list, &fds_len);\n\n  app_info = g_object_get_data (G_OBJECT (invocation), \"app-info\");\n  g_assert (app_info != NULL);\n\n  app_id = g_key_file_get_string (app_info,\n                                  FLATPAK_METADATA_GROUP_APPLICATION,\n                                  FLATPAK_METADATA_KEY_NAME, NULL);\n  g_assert (app_id != NULL);\n\n  g_debug (\"spawn() called from app: '%s'\", app_id);\n  if (*app_id == 0)\n    {\n      g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,\n                                             G_DBUS_ERROR_INVALID_ARGS,\n                                             \"org.freedesktop.portal.Flatpak.Spawn only works in a flatpak\");\n      return G_DBUS_METHOD_INVOCATION_HANDLED;\n    }\n\n  if (*arg_cwd_path == 0)\n    arg_cwd_path = NULL;\n\n  if (arg_argv == NULL || *arg_argv == NULL)\n    {\n      g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,\n                                             G_DBUS_ERROR_INVALID_ARGS,\n                                             \"No command given\");\n      return G_DBUS_METHOD_INVOCATION_HANDLED;\n    }\n\n  if ((arg_flags & ~FLATPAK_SPAWN_FLAGS_ALL) != 0)\n    {\n      g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS,\n                                             \"Unsupported flags enabled: 0x%x\", arg_flags & ~FLATPAK_SPAWN_FLAGS_ALL);\n      return G_DBUS_METHOD_INVOCATION_HANDLED;\n    }\n\n  runtime_ref = g_key_file_get_string (app_info,\n                                       FLATPAK_METADATA_GROUP_APPLICATION,\n                                       FLATPAK_METADATA_KEY_RUNTIME, NULL);\n  if (runtime_ref == NULL)\n    {\n      g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS,\n                                             \"No runtime found\");\n      return G_DBUS_METHOD_INVOCATION_HANDLED;\n    }\n\n  runtime_parts = g_strsplit (runtime_ref, \"/\", -1);\n\n  branch = g_key_file_get_string (app_info,\n                                  FLATPAK_METADATA_GROUP_INSTANCE,\n                                  FLATPAK_METADATA_KEY_BRANCH, NULL);\n  instance_path = g_key_file_get_string (app_info,\n                                         FLATPAK_METADATA_GROUP_INSTANCE,\n                                         FLATPAK_METADATA_KEY_INSTANCE_PATH, NULL);\n  arch = g_key_file_get_string (app_info,\n                                FLATPAK_METADATA_GROUP_INSTANCE,\n                                FLATPAK_METADATA_KEY_ARCH, NULL);\n  extra_args = g_key_file_get_string_list (app_info,\n                                           FLATPAK_METADATA_GROUP_INSTANCE,\n                                           FLATPAK_METADATA_KEY_EXTRA_ARGS, NULL, NULL);\n  app_commit = g_key_file_get_string (app_info,\n                                      FLATPAK_METADATA_GROUP_INSTANCE,\n                                      FLATPAK_METADATA_KEY_APP_COMMIT, NULL);\n  runtime_commit = g_key_file_get_string (app_info,\n                                          FLATPAK_METADATA_GROUP_INSTANCE,\n                                          FLATPAK_METADATA_KEY_RUNTIME_COMMIT, NULL);\n  shares = g_key_file_get_string_list (app_info, FLATPAK_METADATA_GROUP_CONTEXT,\n                                       FLATPAK_METADATA_KEY_SHARED, NULL, NULL);\n  sockets = g_key_file_get_string_list (app_info, FLATPAK_METADATA_GROUP_CONTEXT,\n                                       FLATPAK_METADATA_KEY_SOCKETS, NULL, NULL);\n  devices = g_key_file_get_string_list (app_info, FLATPAK_METADATA_GROUP_CONTEXT,\n                                        FLATPAK_METADATA_KEY_DEVICES, NULL, NULL);\n\n  devel = g_key_file_get_boolean (app_info, FLATPAK_METADATA_GROUP_INSTANCE,\n                                  FLATPAK_METADATA_KEY_DEVEL, NULL);\n\n  g_variant_lookup (arg_options, \"sandbox-expose\", \"^as\", &sandbox_expose);\n  g_variant_lookup (arg_options, \"sandbox-expose-ro\", \"^as\", &sandbox_expose_ro);\n  g_variant_lookup (arg_options, \"sandbox-flags\", \"u\", &sandbox_flags);\n  sandbox_expose_fd = g_variant_lookup_value (arg_options, \"sandbox-expose-fd\", G_VARIANT_TYPE (\"ah\"));\n  sandbox_expose_fd_ro = g_variant_lookup_value (arg_options, \"sandbox-expose-fd-ro\", G_VARIANT_TYPE (\"ah\"));\n\n  if ((sandbox_flags & ~FLATPAK_SPAWN_SANDBOX_FLAGS_ALL) != 0)\n    {\n      g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS,\n                                             \"Unsupported sandbox flags enabled: 0x%x\", arg_flags & ~FLATPAK_SPAWN_SANDBOX_FLAGS_ALL);\n      return G_DBUS_METHOD_INVOCATION_HANDLED;\n    }\n\n  if (instance_path == NULL &&\n      ((sandbox_expose != NULL && sandbox_expose[0] != NULL) ||\n       (sandbox_expose_ro != NULL && sandbox_expose_ro[0] != NULL)))\n    {\n      g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,\n                                             G_DBUS_ERROR_INVALID_ARGS,\n                                             \"Invalid sandbox expose, caller has no instance path\");\n      return G_DBUS_METHOD_INVOCATION_HANDLED;\n    }\n\n  for (i = 0; sandbox_expose != NULL && sandbox_expose[i] != NULL; i++)\n    {\n      const char *expose = sandbox_expose[i];\n\n      g_debug (\"exposing %s\", expose);\n      if (!is_valid_expose (expose, &error))\n        {\n          g_dbus_method_invocation_return_gerror (invocation, error);\n          return G_DBUS_METHOD_INVOCATION_HANDLED;\n        }\n    }\n\n  for (i = 0; sandbox_expose_ro != NULL && sandbox_expose_ro[i] != NULL; i++)\n    {\n      const char *expose = sandbox_expose_ro[i];\n      g_debug (\"exposing %s\", expose);\n      if (!is_valid_expose (expose, &error))\n        {\n          g_dbus_method_invocation_return_gerror (invocation, error);\n          return G_DBUS_METHOD_INVOCATION_HANDLED;\n        }\n    }\n\n  g_debug (\"Running spawn command %s\", arg_argv[0]);\n\n  n_fds = 0;\n  if (fds != NULL)\n    n_fds = g_variant_n_children (arg_fds);\n  fd_map = g_new0 (FdMapEntry, n_fds);\n\n  child_setup_data.fd_map = fd_map;\n  child_setup_data.fd_map_len = n_fds;\n\n  max_fd = -1;\n  for (i = 0; i < n_fds; i++)\n    {\n      gint32 handle, dest_fd;\n      int handle_fd;\n\n      g_variant_get_child (arg_fds, i, \"{uh}\", &dest_fd, &handle);\n\n      if (handle >= fds_len || handle < 0)\n        {\n          g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,\n                                                 G_DBUS_ERROR_INVALID_ARGS,\n                                                 \"No file descriptor for handle %d\",\n                                                 handle);\n          return G_DBUS_METHOD_INVOCATION_HANDLED;\n        }\n\n      handle_fd = fds[handle];\n\n      fd_map[i].to = dest_fd;\n      fd_map[i].from = handle_fd;\n      fd_map[i].final = fd_map[i].to;\n\n      /* If stdin/out/err is a tty we try to set it as the controlling\n         tty for the app, this way we can use this to run in a terminal. */\n      if ((dest_fd == 0 || dest_fd == 1 || dest_fd == 2) &&\n          !child_setup_data.set_tty &&\n          isatty (handle_fd))\n        {\n          child_setup_data.set_tty = TRUE;\n          child_setup_data.tty = handle_fd;\n        }\n\n      max_fd = MAX (max_fd, fd_map[i].to);\n      max_fd = MAX (max_fd, fd_map[i].from);\n    }\n\n  /* We make a second pass over the fds to find if any \"to\" fd index\n     overlaps an already in use fd (i.e. one in the \"from\" category\n     that are allocated randomly). If a fd overlaps \"to\" fd then its\n     a caller issue and not our fault, so we ignore that. */\n  for (i = 0; i < n_fds; i++)\n    {\n      int to_fd = fd_map[i].to;\n      gboolean conflict = FALSE;\n\n      /* At this point we're fine with using \"from\" values for this\n         value (because we handle to==from in the code), or values\n         that are before \"i\" in the fd_map (because those will be\n         closed at this point when dup:ing). However, we can't\n         reuse a fd that is in \"from\" for j > i. */\n      for (j = i + 1; j < n_fds; j++)\n        {\n          int from_fd = fd_map[j].from;\n          if (from_fd == to_fd)\n            {\n              conflict = TRUE;\n              break;\n            }\n        }\n\n      if (conflict)\n        fd_map[i].to = ++max_fd;\n    }\n\n  if (arg_flags & FLATPAK_SPAWN_FLAGS_CLEAR_ENV)\n    {\n      char *empty[] = { NULL };\n      env = g_strdupv (empty);\n    }\n  else\n    env = g_get_environ ();\n\n  n_envs = g_variant_n_children (arg_envs);\n  for (i = 0; i < n_envs; i++)\n    {\n      const char *var = NULL;\n      const char *val = NULL;\n      g_variant_get_child (arg_envs, i, \"{&s&s}\", &var, &val);\n\n      env = g_environ_setenv (env, var, val, TRUE);\n    }\n\n  g_ptr_array_add (flatpak_argv, g_strdup (\"flatpak\"));\n  g_ptr_array_add (flatpak_argv, g_strdup (\"run\"));\n\n  sandboxed = (arg_flags & FLATPAK_SPAWN_FLAGS_SANDBOX) != 0;\n\n  if (sandboxed)\n    {\n      g_ptr_array_add (flatpak_argv, g_strdup (\"--sandbox\"));\n\n      if (sandbox_flags & FLATPAK_SPAWN_SANDBOX_FLAGS_SHARE_DISPLAY)\n        {\n          if (sockets != NULL && g_strv_contains ((const char * const *) sockets, \"wayland\"))\n            g_ptr_array_add (flatpak_argv, g_strdup (\"--socket=wayland\"));\n          if (sockets != NULL && g_strv_contains ((const char * const *) sockets, \"fallback-x11\"))\n            g_ptr_array_add (flatpak_argv, g_strdup (\"--socket=fallback-x11\"));\n          if (sockets != NULL && g_strv_contains ((const char * const *) sockets, \"x11\"))\n            g_ptr_array_add (flatpak_argv, g_strdup (\"--socket=x11\"));\n          if (shares != NULL && g_strv_contains ((const char * const *) shares, \"ipc\") &&\n              sockets != NULL && (g_strv_contains ((const char * const *) sockets, \"fallback-x11\") ||\n                                  g_strv_contains ((const char * const *) sockets, \"x11\")))\n            g_ptr_array_add (flatpak_argv, g_strdup (\"--share=ipc\"));\n        }\n      if (sandbox_flags & FLATPAK_SPAWN_SANDBOX_FLAGS_SHARE_SOUND)\n        {\n          if (sockets != NULL && g_strv_contains ((const char * const *) sockets, \"pulseaudio\"))\n            g_ptr_array_add (flatpak_argv, g_strdup (\"--socket=pulseaudio\"));\n        }\n      if (sandbox_flags & FLATPAK_SPAWN_SANDBOX_FLAGS_SHARE_GPU)\n        {\n          if (devices != NULL &&\n              (g_strv_contains ((const char * const *) devices, \"dri\") ||\n               g_strv_contains ((const char * const *) devices, \"all\")))\n            g_ptr_array_add (flatpak_argv, g_strdup (\"--device=dri\"));\n        }\n      if (sandbox_flags & FLATPAK_SPAWN_SANDBOX_FLAGS_ALLOW_DBUS)\n        g_ptr_array_add (flatpak_argv, g_strdup (\"--session-bus\"));\n      if (sandbox_flags & FLATPAK_SPAWN_SANDBOX_FLAGS_ALLOW_A11Y)\n        g_ptr_array_add (flatpak_argv, g_strdup (\"--a11y-bus\"));\n    }\n  else\n    {\n      for (i = 0; extra_args != NULL && extra_args[i] != NULL; i++)\n        {\n          if (g_str_has_prefix (extra_args[i], \"--env=\"))\n            {\n              const char *var_val = extra_args[i] + strlen (\"--env=\");\n\n              if (var_val[0] == '\\0' || var_val[0] == '=')\n                {\n                  g_warning (\"Environment variable in extra-args has empty name\");\n                  continue;\n                }\n\n              if (strchr (var_val, '=') == NULL)\n                {\n                  g_warning (\"Environment variable in extra-args has no value\");\n                  continue;\n                }\n\n              g_string_append (env_string, var_val);\n              g_string_append_c (env_string, '\\0');\n            }\n          else\n            {\n              g_ptr_array_add (flatpak_argv, g_strdup (extra_args[i]));\n            }\n        }\n    }\n\n  if (env_string->len > 0)\n    {\n      g_auto(GLnxTmpfile) env_tmpf  = { 0, };\n\n      if (!flatpak_buffer_to_sealed_memfd_or_tmpfile (&env_tmpf, \"environ\",\n                                                      env_string->str,\n                                                      env_string->len, &error))\n        {\n          g_dbus_method_invocation_return_gerror (invocation, error);\n          return G_DBUS_METHOD_INVOCATION_HANDLED;\n        }\n\n      child_setup_data.env_fd = glnx_steal_fd (&env_tmpf.fd);\n      g_ptr_array_add (flatpak_argv,\n                       g_strdup_printf (\"--env-fd=%d\",\n                                        child_setup_data.env_fd));\n    }\n\n  expose_pids = (arg_flags & FLATPAK_SPAWN_FLAGS_EXPOSE_PIDS) != 0;\n  share_pids = (arg_flags & FLATPAK_SPAWN_FLAGS_SHARE_PIDS) != 0;\n\n  if (expose_pids || share_pids)\n    {\n      g_autofree char *instance_id = NULL;\n      int sender_pid1 = 0;\n\n      if (!(supports & FLATPAK_SPAWN_SUPPORT_FLAGS_EXPOSE_PIDS))\n        {\n          g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,\n                                                 G_DBUS_ERROR_NOT_SUPPORTED,\n                                                 \"Expose pids not supported with setuid bwrap\");\n          return G_DBUS_METHOD_INVOCATION_HANDLED;\n        }\n\n      instance_id = g_key_file_get_string (app_info,\n                                           FLATPAK_METADATA_GROUP_INSTANCE,\n                                           FLATPAK_METADATA_KEY_INSTANCE_ID, NULL);\n\n      if (instance_id)\n        {\n          g_autoptr(FlatpakInstance) instance = flatpak_instance_new_for_id (instance_id);\n          sender_pid1 = flatpak_instance_get_child_pid (instance);\n        }\n\n      if (sender_pid1 == 0)\n        {\n          g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,\n                                                 G_DBUS_ERROR_INVALID_ARGS,\n                                                 \"Could not find requesting pid\");\n          return G_DBUS_METHOD_INVOCATION_HANDLED;\n        }\n\n      g_ptr_array_add (flatpak_argv, g_strdup_printf (\"--parent-pid=%d\", sender_pid1));\n\n      if (share_pids)\n        g_ptr_array_add (flatpak_argv, g_strdup (\"--parent-share-pids\"));\n      else\n        g_ptr_array_add (flatpak_argv, g_strdup (\"--parent-expose-pids\"));\n    }\n\n  notify_start = (arg_flags & FLATPAK_SPAWN_FLAGS_NOTIFY_START) != 0;\n  if (notify_start)\n    {\n      int pipe_fds[2];\n      if (pipe (pipe_fds) == -1)\n        {\n          int errsv = errno;\n          g_dbus_method_invocation_return_error (invocation, G_IO_ERROR,\n                                                 g_io_error_from_errno (errsv),\n                                                 \"Failed to create instance ID pipe: %s\",\n                                                 g_strerror (errsv));\n          return G_DBUS_METHOD_INVOCATION_HANDLED;\n        }\n\n      GInputStream *in_stream = G_INPUT_STREAM (g_unix_input_stream_new (pipe_fds[0], TRUE));\n      /* This is saved to ensure the portal's end gets closed after the exec. */\n      instance_id_out_stream = G_OUTPUT_STREAM (g_unix_output_stream_new (pipe_fds[1], TRUE));\n\n      instance_id_read_data = g_new0 (InstanceIdReadData, 1);\n\n      g_input_stream_read_async (in_stream, instance_id_read_data->buffer,\n                                 INSTANCE_ID_BUFFER_SIZE - 1, G_PRIORITY_DEFAULT, NULL,\n                                 instance_id_read_finish, instance_id_read_data);\n\n      g_ptr_array_add (flatpak_argv, g_strdup_printf (\"--instance-id-fd=%d\", pipe_fds[1]));\n      child_setup_data.instance_id_fd = pipe_fds[1];\n    }\n\n  if (devel)\n    g_ptr_array_add (flatpak_argv, g_strdup (\"--devel\"));\n\n  /* Inherit launcher network access from launcher, unless\n     NO_NETWORK set. */\n  if (shares != NULL && g_strv_contains ((const char * const *) shares, \"network\") &&\n      !(arg_flags & FLATPAK_SPAWN_FLAGS_NO_NETWORK))\n    g_ptr_array_add (flatpak_argv, g_strdup (\"--share=network\"));\n  else\n    g_ptr_array_add (flatpak_argv, g_strdup (\"--unshare=network\"));\n\n\n  if (instance_path)\n    {\n      for (i = 0; sandbox_expose != NULL && sandbox_expose[i] != NULL; i++)\n        g_ptr_array_add (flatpak_argv,\n                         filesystem_sandbox_arg (instance_path, sandbox_expose[i], FALSE));\n      for (i = 0; sandbox_expose_ro != NULL && sandbox_expose_ro[i] != NULL; i++)\n        g_ptr_array_add (flatpak_argv,\n                         filesystem_sandbox_arg (instance_path, sandbox_expose_ro[i], TRUE));\n    }\n\n  for (i = 0; sandbox_expose_ro != NULL && sandbox_expose_ro[i] != NULL; i++)\n    {\n      const char *expose = sandbox_expose_ro[i];\n      g_debug (\"exposing %s\", expose);\n    }\n\n  if (sandbox_expose_fd != NULL)\n    {\n      gsize len = g_variant_n_children (sandbox_expose_fd);\n      for (i = 0; i < len; i++)\n        {\n          gint32 handle;\n          g_variant_get_child (sandbox_expose_fd, i, \"h\", &handle);\n          if (handle >= 0 && handle < fds_len)\n            {\n              int handle_fd = fds[handle];\n              g_autofree char *path = NULL;\n              gboolean writable = FALSE;\n\n              path = get_path_for_fd (handle_fd, &writable, &error);\n\n              if (path)\n                {\n                  g_ptr_array_add (flatpak_argv, filesystem_arg (path, !writable));\n                }\n              else\n                {\n                  g_debug (\"unable to get path for sandbox-exposed fd %d, ignoring: %s\",\n                           handle_fd, error->message);\n                  g_clear_error (&error);\n                }\n            }\n          else\n            {\n              g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,\n                                                     G_DBUS_ERROR_INVALID_ARGS,\n                                                     \"No file descriptor for handle %d\",\n                                                     handle);\n              return G_DBUS_METHOD_INVOCATION_HANDLED;\n            }\n        }\n    }\n\n  if (sandbox_expose_fd_ro != NULL)\n    {\n      gsize len = g_variant_n_children (sandbox_expose_fd_ro);\n      for (i = 0; i < len; i++)\n        {\n          gint32 handle;\n          g_variant_get_child (sandbox_expose_fd_ro, i, \"h\", &handle);\n          if (handle >= 0 && handle < fds_len)\n            {\n              int handle_fd = fds[handle];\n              g_autofree char *path = NULL;\n              gboolean writable = FALSE;\n\n              path = get_path_for_fd (handle_fd, &writable, &error);\n\n              if (path)\n                {\n                  g_ptr_array_add (flatpak_argv, filesystem_arg (path, TRUE));\n                }\n              else\n                {\n                  g_debug (\"unable to get path for sandbox-exposed fd %d, ignoring: %s\",\n                           handle_fd, error->message);\n                  g_clear_error (&error);\n                }\n            }\n          else\n            {\n              g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,\n                                                     G_DBUS_ERROR_INVALID_ARGS,\n                                                     \"No file descriptor for handle %d\",\n                                                     handle);\n              return G_DBUS_METHOD_INVOCATION_HANDLED;\n            }\n        }\n    }\n\n  g_ptr_array_add (flatpak_argv, g_strdup_printf (\"--runtime=%s\", runtime_parts[1]));\n  g_ptr_array_add (flatpak_argv, g_strdup_printf (\"--runtime-version=%s\", runtime_parts[3]));\n\n  if ((arg_flags & FLATPAK_SPAWN_FLAGS_LATEST_VERSION) == 0)\n    {\n      if (app_commit)\n        g_ptr_array_add (flatpak_argv, g_strdup_printf (\"--commit=%s\", app_commit));\n      if (runtime_commit)\n        g_ptr_array_add (flatpak_argv, g_strdup_printf (\"--runtime-commit=%s\", runtime_commit));\n    }\n\n  if (arg_cwd_path != NULL)\n    g_ptr_array_add (flatpak_argv, g_strdup_printf (\"--cwd=%s\", arg_cwd_path));\n\n  if (arg_argv[0][0] != 0)\n    g_ptr_array_add (flatpak_argv, g_strdup_printf (\"--command=%s\", arg_argv[0]));\n\n  g_ptr_array_add (flatpak_argv, g_strdup_printf (\"%s/%s/%s\", app_id, arch ? arch : \"\", branch ? branch : \"\"));\n  for (i = 1; arg_argv[i] != NULL; i++)\n    g_ptr_array_add (flatpak_argv, g_strdup (arg_argv[i]));\n  g_ptr_array_add (flatpak_argv, NULL);\n\n  if (opt_verbose)\n    {\n      g_autoptr(GString) cmd = g_string_new (\"\");\n\n      for (i = 0; flatpak_argv->pdata[i] != NULL; i++)\n        {\n          if (i > 0)\n            g_string_append (cmd, \" \");\n          g_string_append (cmd, flatpak_argv->pdata[i]);\n        }\n\n      g_debug (\"Starting: %s\\n\", cmd->str);\n    }\n\n  /* We use LEAVE_DESCRIPTORS_OPEN to work around dead-lock, see flatpak_close_fds_workaround */\n  if (!g_spawn_async_with_pipes (NULL,\n                                 (char **) flatpak_argv->pdata,\n                                 env,\n                                 G_SPAWN_SEARCH_PATH | G_SPAWN_DO_NOT_REAP_CHILD | G_SPAWN_LEAVE_DESCRIPTORS_OPEN,\n                                 child_setup_func, &child_setup_data,\n                                 &pid,\n                                 NULL,\n                                 NULL,\n                                 NULL,\n                                 &error))\n    {\n      gint code = G_DBUS_ERROR_FAILED;\n      if (g_error_matches (error, G_SPAWN_ERROR, G_SPAWN_ERROR_ACCES))\n        code = G_DBUS_ERROR_ACCESS_DENIED;\n      else if (g_error_matches (error, G_SPAWN_ERROR, G_SPAWN_ERROR_NOENT))\n        code = G_DBUS_ERROR_FILE_NOT_FOUND;\n      g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, code,\n                                             \"Failed to start command: %s\",\n                                             error->message);\n      return G_DBUS_METHOD_INVOCATION_HANDLED;\n    }\n\n  if (instance_id_read_data)\n    instance_id_read_data->pid = pid;\n\n  pid_data = g_new0 (PidData, 1);\n  pid_data->pid = pid;\n  pid_data->client = g_strdup (g_dbus_method_invocation_get_sender (invocation));\n  pid_data->watch_bus = (arg_flags & FLATPAK_SPAWN_FLAGS_WATCH_BUS) != 0;\n  pid_data->expose_or_share_pids = (expose_pids || share_pids);\n  pid_data->child_watch = g_child_watch_add_full (G_PRIORITY_DEFAULT,\n                                                  pid,\n                                                  child_watch_died,\n                                                  pid_data,\n                                                  NULL);\n\n  g_debug (\"Client Pid is %d\", pid_data->pid);\n\n  g_hash_table_replace (client_pid_data_hash, GUINT_TO_POINTER (pid_data->pid),\n                        pid_data);\n\n  portal_flatpak_complete_spawn (object, invocation, NULL, pid);\n  return G_DBUS_METHOD_INVOCATION_HANDLED;\n}",
        "func": "static gboolean\nhandle_spawn (PortalFlatpak         *object,\n              GDBusMethodInvocation *invocation,\n              GUnixFDList           *fd_list,\n              const gchar           *arg_cwd_path,\n              const gchar *const    *arg_argv,\n              GVariant              *arg_fds,\n              GVariant              *arg_envs,\n              guint                  arg_flags,\n              GVariant              *arg_options)\n{\n  g_autoptr(GError) error = NULL;\n  ChildSetupData child_setup_data = { NULL };\n  GPid pid;\n  PidData *pid_data;\n  InstanceIdReadData *instance_id_read_data = NULL;\n  gsize i, j, n_fds, n_envs;\n  const gint *fds = NULL;\n  gint fds_len = 0;\n  g_autofree FdMapEntry *fd_map = NULL;\n  gchar **env;\n  gint32 max_fd;\n  GKeyFile *app_info;\n  g_autoptr(GPtrArray) flatpak_argv = g_ptr_array_new_with_free_func (g_free);\n  g_autofree char *app_id = NULL;\n  g_autofree char *branch = NULL;\n  g_autofree char *arch = NULL;\n  g_autofree char *app_commit = NULL;\n  g_autofree char *runtime_ref = NULL;\n  g_auto(GStrv) runtime_parts = NULL;\n  g_autofree char *runtime_commit = NULL;\n  g_autofree char *instance_path = NULL;\n  g_auto(GStrv) extra_args = NULL;\n  g_auto(GStrv) shares = NULL;\n  g_auto(GStrv) sockets = NULL;\n  g_auto(GStrv) devices = NULL;\n  g_auto(GStrv) sandbox_expose = NULL;\n  g_auto(GStrv) sandbox_expose_ro = NULL;\n  g_autoptr(GVariant) sandbox_expose_fd = NULL;\n  g_autoptr(GVariant) sandbox_expose_fd_ro = NULL;\n  g_autoptr(GOutputStream) instance_id_out_stream = NULL;\n  guint sandbox_flags = 0;\n  gboolean sandboxed;\n  gboolean expose_pids;\n  gboolean share_pids;\n  gboolean notify_start;\n  gboolean devel;\n  g_autoptr(GString) env_string = g_string_new (\"\");\n\n  child_setup_data.instance_id_fd = -1;\n  child_setup_data.env_fd = -1;\n\n  if (fd_list != NULL)\n    fds = g_unix_fd_list_peek_fds (fd_list, &fds_len);\n\n  app_info = g_object_get_data (G_OBJECT (invocation), \"app-info\");\n  g_assert (app_info != NULL);\n\n  app_id = g_key_file_get_string (app_info,\n                                  FLATPAK_METADATA_GROUP_APPLICATION,\n                                  FLATPAK_METADATA_KEY_NAME, NULL);\n  g_assert (app_id != NULL);\n\n  g_debug (\"spawn() called from app: '%s'\", app_id);\n  if (*app_id == 0)\n    {\n      g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,\n                                             G_DBUS_ERROR_INVALID_ARGS,\n                                             \"org.freedesktop.portal.Flatpak.Spawn only works in a flatpak\");\n      return G_DBUS_METHOD_INVOCATION_HANDLED;\n    }\n\n  if (*arg_cwd_path == 0)\n    arg_cwd_path = NULL;\n\n  if (arg_argv == NULL || *arg_argv == NULL)\n    {\n      g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,\n                                             G_DBUS_ERROR_INVALID_ARGS,\n                                             \"No command given\");\n      return G_DBUS_METHOD_INVOCATION_HANDLED;\n    }\n\n  if ((arg_flags & ~FLATPAK_SPAWN_FLAGS_ALL) != 0)\n    {\n      g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS,\n                                             \"Unsupported flags enabled: 0x%x\", arg_flags & ~FLATPAK_SPAWN_FLAGS_ALL);\n      return G_DBUS_METHOD_INVOCATION_HANDLED;\n    }\n\n  runtime_ref = g_key_file_get_string (app_info,\n                                       FLATPAK_METADATA_GROUP_APPLICATION,\n                                       FLATPAK_METADATA_KEY_RUNTIME, NULL);\n  if (runtime_ref == NULL)\n    {\n      g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS,\n                                             \"No runtime found\");\n      return G_DBUS_METHOD_INVOCATION_HANDLED;\n    }\n\n  runtime_parts = g_strsplit (runtime_ref, \"/\", -1);\n\n  branch = g_key_file_get_string (app_info,\n                                  FLATPAK_METADATA_GROUP_INSTANCE,\n                                  FLATPAK_METADATA_KEY_BRANCH, NULL);\n  instance_path = g_key_file_get_string (app_info,\n                                         FLATPAK_METADATA_GROUP_INSTANCE,\n                                         FLATPAK_METADATA_KEY_INSTANCE_PATH, NULL);\n  arch = g_key_file_get_string (app_info,\n                                FLATPAK_METADATA_GROUP_INSTANCE,\n                                FLATPAK_METADATA_KEY_ARCH, NULL);\n  extra_args = g_key_file_get_string_list (app_info,\n                                           FLATPAK_METADATA_GROUP_INSTANCE,\n                                           FLATPAK_METADATA_KEY_EXTRA_ARGS, NULL, NULL);\n  app_commit = g_key_file_get_string (app_info,\n                                      FLATPAK_METADATA_GROUP_INSTANCE,\n                                      FLATPAK_METADATA_KEY_APP_COMMIT, NULL);\n  runtime_commit = g_key_file_get_string (app_info,\n                                          FLATPAK_METADATA_GROUP_INSTANCE,\n                                          FLATPAK_METADATA_KEY_RUNTIME_COMMIT, NULL);\n  shares = g_key_file_get_string_list (app_info, FLATPAK_METADATA_GROUP_CONTEXT,\n                                       FLATPAK_METADATA_KEY_SHARED, NULL, NULL);\n  sockets = g_key_file_get_string_list (app_info, FLATPAK_METADATA_GROUP_CONTEXT,\n                                       FLATPAK_METADATA_KEY_SOCKETS, NULL, NULL);\n  devices = g_key_file_get_string_list (app_info, FLATPAK_METADATA_GROUP_CONTEXT,\n                                        FLATPAK_METADATA_KEY_DEVICES, NULL, NULL);\n\n  devel = g_key_file_get_boolean (app_info, FLATPAK_METADATA_GROUP_INSTANCE,\n                                  FLATPAK_METADATA_KEY_DEVEL, NULL);\n\n  g_variant_lookup (arg_options, \"sandbox-expose\", \"^as\", &sandbox_expose);\n  g_variant_lookup (arg_options, \"sandbox-expose-ro\", \"^as\", &sandbox_expose_ro);\n  g_variant_lookup (arg_options, \"sandbox-flags\", \"u\", &sandbox_flags);\n  sandbox_expose_fd = g_variant_lookup_value (arg_options, \"sandbox-expose-fd\", G_VARIANT_TYPE (\"ah\"));\n  sandbox_expose_fd_ro = g_variant_lookup_value (arg_options, \"sandbox-expose-fd-ro\", G_VARIANT_TYPE (\"ah\"));\n\n  if ((sandbox_flags & ~FLATPAK_SPAWN_SANDBOX_FLAGS_ALL) != 0)\n    {\n      g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS,\n                                             \"Unsupported sandbox flags enabled: 0x%x\", arg_flags & ~FLATPAK_SPAWN_SANDBOX_FLAGS_ALL);\n      return G_DBUS_METHOD_INVOCATION_HANDLED;\n    }\n\n  if (instance_path == NULL &&\n      ((sandbox_expose != NULL && sandbox_expose[0] != NULL) ||\n       (sandbox_expose_ro != NULL && sandbox_expose_ro[0] != NULL)))\n    {\n      g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,\n                                             G_DBUS_ERROR_INVALID_ARGS,\n                                             \"Invalid sandbox expose, caller has no instance path\");\n      return G_DBUS_METHOD_INVOCATION_HANDLED;\n    }\n\n  for (i = 0; sandbox_expose != NULL && sandbox_expose[i] != NULL; i++)\n    {\n      const char *expose = sandbox_expose[i];\n\n      g_debug (\"exposing %s\", expose);\n      if (!is_valid_expose (expose, &error))\n        {\n          g_dbus_method_invocation_return_gerror (invocation, error);\n          return G_DBUS_METHOD_INVOCATION_HANDLED;\n        }\n    }\n\n  for (i = 0; sandbox_expose_ro != NULL && sandbox_expose_ro[i] != NULL; i++)\n    {\n      const char *expose = sandbox_expose_ro[i];\n      g_debug (\"exposing %s\", expose);\n      if (!is_valid_expose (expose, &error))\n        {\n          g_dbus_method_invocation_return_gerror (invocation, error);\n          return G_DBUS_METHOD_INVOCATION_HANDLED;\n        }\n    }\n\n  g_debug (\"Running spawn command %s\", arg_argv[0]);\n\n  n_fds = 0;\n  if (fds != NULL)\n    n_fds = g_variant_n_children (arg_fds);\n  fd_map = g_new0 (FdMapEntry, n_fds);\n\n  child_setup_data.fd_map = fd_map;\n  child_setup_data.fd_map_len = n_fds;\n\n  max_fd = -1;\n  for (i = 0; i < n_fds; i++)\n    {\n      gint32 handle, dest_fd;\n      int handle_fd;\n\n      g_variant_get_child (arg_fds, i, \"{uh}\", &dest_fd, &handle);\n\n      if (handle >= fds_len || handle < 0)\n        {\n          g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,\n                                                 G_DBUS_ERROR_INVALID_ARGS,\n                                                 \"No file descriptor for handle %d\",\n                                                 handle);\n          return G_DBUS_METHOD_INVOCATION_HANDLED;\n        }\n\n      handle_fd = fds[handle];\n\n      fd_map[i].to = dest_fd;\n      fd_map[i].from = handle_fd;\n      fd_map[i].final = fd_map[i].to;\n\n      /* If stdin/out/err is a tty we try to set it as the controlling\n         tty for the app, this way we can use this to run in a terminal. */\n      if ((dest_fd == 0 || dest_fd == 1 || dest_fd == 2) &&\n          !child_setup_data.set_tty &&\n          isatty (handle_fd))\n        {\n          child_setup_data.set_tty = TRUE;\n          child_setup_data.tty = handle_fd;\n        }\n\n      max_fd = MAX (max_fd, fd_map[i].to);\n      max_fd = MAX (max_fd, fd_map[i].from);\n    }\n\n  /* We make a second pass over the fds to find if any \"to\" fd index\n     overlaps an already in use fd (i.e. one in the \"from\" category\n     that are allocated randomly). If a fd overlaps \"to\" fd then its\n     a caller issue and not our fault, so we ignore that. */\n  for (i = 0; i < n_fds; i++)\n    {\n      int to_fd = fd_map[i].to;\n      gboolean conflict = FALSE;\n\n      /* At this point we're fine with using \"from\" values for this\n         value (because we handle to==from in the code), or values\n         that are before \"i\" in the fd_map (because those will be\n         closed at this point when dup:ing). However, we can't\n         reuse a fd that is in \"from\" for j > i. */\n      for (j = i + 1; j < n_fds; j++)\n        {\n          int from_fd = fd_map[j].from;\n          if (from_fd == to_fd)\n            {\n              conflict = TRUE;\n              break;\n            }\n        }\n\n      if (conflict)\n        fd_map[i].to = ++max_fd;\n    }\n\n  if (arg_flags & FLATPAK_SPAWN_FLAGS_CLEAR_ENV)\n    {\n      char *empty[] = { NULL };\n      env = g_strdupv (empty);\n    }\n  else\n    env = g_get_environ ();\n\n  /* Let the environment variables given by the caller override the ones\n   * from extra_args. Don't add them to @env, because they are controlled\n   * by our caller, which might be trying to use them to inject code into\n   * flatpak(1); add them to the environment block instead.\n   *\n   * We don't use --env= here, so that if the values are something that\n   * should not be exposed to other uids, they can remain confidential. */\n  n_envs = g_variant_n_children (arg_envs);\n  for (i = 0; i < n_envs; i++)\n    {\n      const char *var = NULL;\n      const char *val = NULL;\n      g_variant_get_child (arg_envs, i, \"{&s&s}\", &var, &val);\n\n      if (var[0] == '\\0')\n        {\n          g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,\n                                                 G_DBUS_ERROR_INVALID_ARGS,\n                                                 \"Environment variable cannot have empty name\");\n          return G_DBUS_METHOD_INVOCATION_HANDLED;\n        }\n\n      if (strchr (var, '=') != NULL)\n        {\n          g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,\n                                                 G_DBUS_ERROR_INVALID_ARGS,\n                                                 \"Environment variable name cannot contain '='\");\n          return G_DBUS_METHOD_INVOCATION_HANDLED;\n        }\n\n      g_string_append (env_string, var);\n      g_string_append_c (env_string, '=');\n      g_string_append (env_string, val);\n      g_string_append_c (env_string, '\\0');\n    }\n\n  g_ptr_array_add (flatpak_argv, g_strdup (\"flatpak\"));\n  g_ptr_array_add (flatpak_argv, g_strdup (\"run\"));\n\n  sandboxed = (arg_flags & FLATPAK_SPAWN_FLAGS_SANDBOX) != 0;\n\n  if (sandboxed)\n    {\n      g_ptr_array_add (flatpak_argv, g_strdup (\"--sandbox\"));\n\n      if (sandbox_flags & FLATPAK_SPAWN_SANDBOX_FLAGS_SHARE_DISPLAY)\n        {\n          if (sockets != NULL && g_strv_contains ((const char * const *) sockets, \"wayland\"))\n            g_ptr_array_add (flatpak_argv, g_strdup (\"--socket=wayland\"));\n          if (sockets != NULL && g_strv_contains ((const char * const *) sockets, \"fallback-x11\"))\n            g_ptr_array_add (flatpak_argv, g_strdup (\"--socket=fallback-x11\"));\n          if (sockets != NULL && g_strv_contains ((const char * const *) sockets, \"x11\"))\n            g_ptr_array_add (flatpak_argv, g_strdup (\"--socket=x11\"));\n          if (shares != NULL && g_strv_contains ((const char * const *) shares, \"ipc\") &&\n              sockets != NULL && (g_strv_contains ((const char * const *) sockets, \"fallback-x11\") ||\n                                  g_strv_contains ((const char * const *) sockets, \"x11\")))\n            g_ptr_array_add (flatpak_argv, g_strdup (\"--share=ipc\"));\n        }\n      if (sandbox_flags & FLATPAK_SPAWN_SANDBOX_FLAGS_SHARE_SOUND)\n        {\n          if (sockets != NULL && g_strv_contains ((const char * const *) sockets, \"pulseaudio\"))\n            g_ptr_array_add (flatpak_argv, g_strdup (\"--socket=pulseaudio\"));\n        }\n      if (sandbox_flags & FLATPAK_SPAWN_SANDBOX_FLAGS_SHARE_GPU)\n        {\n          if (devices != NULL &&\n              (g_strv_contains ((const char * const *) devices, \"dri\") ||\n               g_strv_contains ((const char * const *) devices, \"all\")))\n            g_ptr_array_add (flatpak_argv, g_strdup (\"--device=dri\"));\n        }\n      if (sandbox_flags & FLATPAK_SPAWN_SANDBOX_FLAGS_ALLOW_DBUS)\n        g_ptr_array_add (flatpak_argv, g_strdup (\"--session-bus\"));\n      if (sandbox_flags & FLATPAK_SPAWN_SANDBOX_FLAGS_ALLOW_A11Y)\n        g_ptr_array_add (flatpak_argv, g_strdup (\"--a11y-bus\"));\n    }\n  else\n    {\n      for (i = 0; extra_args != NULL && extra_args[i] != NULL; i++)\n        {\n          if (g_str_has_prefix (extra_args[i], \"--env=\"))\n            {\n              const char *var_val = extra_args[i] + strlen (\"--env=\");\n\n              if (var_val[0] == '\\0' || var_val[0] == '=')\n                {\n                  g_warning (\"Environment variable in extra-args has empty name\");\n                  continue;\n                }\n\n              if (strchr (var_val, '=') == NULL)\n                {\n                  g_warning (\"Environment variable in extra-args has no value\");\n                  continue;\n                }\n\n              g_string_append (env_string, var_val);\n              g_string_append_c (env_string, '\\0');\n            }\n          else\n            {\n              g_ptr_array_add (flatpak_argv, g_strdup (extra_args[i]));\n            }\n        }\n    }\n\n  if (env_string->len > 0)\n    {\n      g_auto(GLnxTmpfile) env_tmpf  = { 0, };\n\n      if (!flatpak_buffer_to_sealed_memfd_or_tmpfile (&env_tmpf, \"environ\",\n                                                      env_string->str,\n                                                      env_string->len, &error))\n        {\n          g_dbus_method_invocation_return_gerror (invocation, error);\n          return G_DBUS_METHOD_INVOCATION_HANDLED;\n        }\n\n      child_setup_data.env_fd = glnx_steal_fd (&env_tmpf.fd);\n      g_ptr_array_add (flatpak_argv,\n                       g_strdup_printf (\"--env-fd=%d\",\n                                        child_setup_data.env_fd));\n    }\n\n  expose_pids = (arg_flags & FLATPAK_SPAWN_FLAGS_EXPOSE_PIDS) != 0;\n  share_pids = (arg_flags & FLATPAK_SPAWN_FLAGS_SHARE_PIDS) != 0;\n\n  if (expose_pids || share_pids)\n    {\n      g_autofree char *instance_id = NULL;\n      int sender_pid1 = 0;\n\n      if (!(supports & FLATPAK_SPAWN_SUPPORT_FLAGS_EXPOSE_PIDS))\n        {\n          g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,\n                                                 G_DBUS_ERROR_NOT_SUPPORTED,\n                                                 \"Expose pids not supported with setuid bwrap\");\n          return G_DBUS_METHOD_INVOCATION_HANDLED;\n        }\n\n      instance_id = g_key_file_get_string (app_info,\n                                           FLATPAK_METADATA_GROUP_INSTANCE,\n                                           FLATPAK_METADATA_KEY_INSTANCE_ID, NULL);\n\n      if (instance_id)\n        {\n          g_autoptr(FlatpakInstance) instance = flatpak_instance_new_for_id (instance_id);\n          sender_pid1 = flatpak_instance_get_child_pid (instance);\n        }\n\n      if (sender_pid1 == 0)\n        {\n          g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,\n                                                 G_DBUS_ERROR_INVALID_ARGS,\n                                                 \"Could not find requesting pid\");\n          return G_DBUS_METHOD_INVOCATION_HANDLED;\n        }\n\n      g_ptr_array_add (flatpak_argv, g_strdup_printf (\"--parent-pid=%d\", sender_pid1));\n\n      if (share_pids)\n        g_ptr_array_add (flatpak_argv, g_strdup (\"--parent-share-pids\"));\n      else\n        g_ptr_array_add (flatpak_argv, g_strdup (\"--parent-expose-pids\"));\n    }\n\n  notify_start = (arg_flags & FLATPAK_SPAWN_FLAGS_NOTIFY_START) != 0;\n  if (notify_start)\n    {\n      int pipe_fds[2];\n      if (pipe (pipe_fds) == -1)\n        {\n          int errsv = errno;\n          g_dbus_method_invocation_return_error (invocation, G_IO_ERROR,\n                                                 g_io_error_from_errno (errsv),\n                                                 \"Failed to create instance ID pipe: %s\",\n                                                 g_strerror (errsv));\n          return G_DBUS_METHOD_INVOCATION_HANDLED;\n        }\n\n      GInputStream *in_stream = G_INPUT_STREAM (g_unix_input_stream_new (pipe_fds[0], TRUE));\n      /* This is saved to ensure the portal's end gets closed after the exec. */\n      instance_id_out_stream = G_OUTPUT_STREAM (g_unix_output_stream_new (pipe_fds[1], TRUE));\n\n      instance_id_read_data = g_new0 (InstanceIdReadData, 1);\n\n      g_input_stream_read_async (in_stream, instance_id_read_data->buffer,\n                                 INSTANCE_ID_BUFFER_SIZE - 1, G_PRIORITY_DEFAULT, NULL,\n                                 instance_id_read_finish, instance_id_read_data);\n\n      g_ptr_array_add (flatpak_argv, g_strdup_printf (\"--instance-id-fd=%d\", pipe_fds[1]));\n      child_setup_data.instance_id_fd = pipe_fds[1];\n    }\n\n  if (devel)\n    g_ptr_array_add (flatpak_argv, g_strdup (\"--devel\"));\n\n  /* Inherit launcher network access from launcher, unless\n     NO_NETWORK set. */\n  if (shares != NULL && g_strv_contains ((const char * const *) shares, \"network\") &&\n      !(arg_flags & FLATPAK_SPAWN_FLAGS_NO_NETWORK))\n    g_ptr_array_add (flatpak_argv, g_strdup (\"--share=network\"));\n  else\n    g_ptr_array_add (flatpak_argv, g_strdup (\"--unshare=network\"));\n\n\n  if (instance_path)\n    {\n      for (i = 0; sandbox_expose != NULL && sandbox_expose[i] != NULL; i++)\n        g_ptr_array_add (flatpak_argv,\n                         filesystem_sandbox_arg (instance_path, sandbox_expose[i], FALSE));\n      for (i = 0; sandbox_expose_ro != NULL && sandbox_expose_ro[i] != NULL; i++)\n        g_ptr_array_add (flatpak_argv,\n                         filesystem_sandbox_arg (instance_path, sandbox_expose_ro[i], TRUE));\n    }\n\n  for (i = 0; sandbox_expose_ro != NULL && sandbox_expose_ro[i] != NULL; i++)\n    {\n      const char *expose = sandbox_expose_ro[i];\n      g_debug (\"exposing %s\", expose);\n    }\n\n  if (sandbox_expose_fd != NULL)\n    {\n      gsize len = g_variant_n_children (sandbox_expose_fd);\n      for (i = 0; i < len; i++)\n        {\n          gint32 handle;\n          g_variant_get_child (sandbox_expose_fd, i, \"h\", &handle);\n          if (handle >= 0 && handle < fds_len)\n            {\n              int handle_fd = fds[handle];\n              g_autofree char *path = NULL;\n              gboolean writable = FALSE;\n\n              path = get_path_for_fd (handle_fd, &writable, &error);\n\n              if (path)\n                {\n                  g_ptr_array_add (flatpak_argv, filesystem_arg (path, !writable));\n                }\n              else\n                {\n                  g_debug (\"unable to get path for sandbox-exposed fd %d, ignoring: %s\",\n                           handle_fd, error->message);\n                  g_clear_error (&error);\n                }\n            }\n          else\n            {\n              g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,\n                                                     G_DBUS_ERROR_INVALID_ARGS,\n                                                     \"No file descriptor for handle %d\",\n                                                     handle);\n              return G_DBUS_METHOD_INVOCATION_HANDLED;\n            }\n        }\n    }\n\n  if (sandbox_expose_fd_ro != NULL)\n    {\n      gsize len = g_variant_n_children (sandbox_expose_fd_ro);\n      for (i = 0; i < len; i++)\n        {\n          gint32 handle;\n          g_variant_get_child (sandbox_expose_fd_ro, i, \"h\", &handle);\n          if (handle >= 0 && handle < fds_len)\n            {\n              int handle_fd = fds[handle];\n              g_autofree char *path = NULL;\n              gboolean writable = FALSE;\n\n              path = get_path_for_fd (handle_fd, &writable, &error);\n\n              if (path)\n                {\n                  g_ptr_array_add (flatpak_argv, filesystem_arg (path, TRUE));\n                }\n              else\n                {\n                  g_debug (\"unable to get path for sandbox-exposed fd %d, ignoring: %s\",\n                           handle_fd, error->message);\n                  g_clear_error (&error);\n                }\n            }\n          else\n            {\n              g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,\n                                                     G_DBUS_ERROR_INVALID_ARGS,\n                                                     \"No file descriptor for handle %d\",\n                                                     handle);\n              return G_DBUS_METHOD_INVOCATION_HANDLED;\n            }\n        }\n    }\n\n  g_ptr_array_add (flatpak_argv, g_strdup_printf (\"--runtime=%s\", runtime_parts[1]));\n  g_ptr_array_add (flatpak_argv, g_strdup_printf (\"--runtime-version=%s\", runtime_parts[3]));\n\n  if ((arg_flags & FLATPAK_SPAWN_FLAGS_LATEST_VERSION) == 0)\n    {\n      if (app_commit)\n        g_ptr_array_add (flatpak_argv, g_strdup_printf (\"--commit=%s\", app_commit));\n      if (runtime_commit)\n        g_ptr_array_add (flatpak_argv, g_strdup_printf (\"--runtime-commit=%s\", runtime_commit));\n    }\n\n  if (arg_cwd_path != NULL)\n    g_ptr_array_add (flatpak_argv, g_strdup_printf (\"--cwd=%s\", arg_cwd_path));\n\n  if (arg_argv[0][0] != 0)\n    g_ptr_array_add (flatpak_argv, g_strdup_printf (\"--command=%s\", arg_argv[0]));\n\n  g_ptr_array_add (flatpak_argv, g_strdup_printf (\"%s/%s/%s\", app_id, arch ? arch : \"\", branch ? branch : \"\"));\n  for (i = 1; arg_argv[i] != NULL; i++)\n    g_ptr_array_add (flatpak_argv, g_strdup (arg_argv[i]));\n  g_ptr_array_add (flatpak_argv, NULL);\n\n  if (opt_verbose)\n    {\n      g_autoptr(GString) cmd = g_string_new (\"\");\n\n      for (i = 0; flatpak_argv->pdata[i] != NULL; i++)\n        {\n          if (i > 0)\n            g_string_append (cmd, \" \");\n          g_string_append (cmd, flatpak_argv->pdata[i]);\n        }\n\n      g_debug (\"Starting: %s\\n\", cmd->str);\n    }\n\n  /* We use LEAVE_DESCRIPTORS_OPEN to work around dead-lock, see flatpak_close_fds_workaround */\n  if (!g_spawn_async_with_pipes (NULL,\n                                 (char **) flatpak_argv->pdata,\n                                 env,\n                                 G_SPAWN_SEARCH_PATH | G_SPAWN_DO_NOT_REAP_CHILD | G_SPAWN_LEAVE_DESCRIPTORS_OPEN,\n                                 child_setup_func, &child_setup_data,\n                                 &pid,\n                                 NULL,\n                                 NULL,\n                                 NULL,\n                                 &error))\n    {\n      gint code = G_DBUS_ERROR_FAILED;\n      if (g_error_matches (error, G_SPAWN_ERROR, G_SPAWN_ERROR_ACCES))\n        code = G_DBUS_ERROR_ACCESS_DENIED;\n      else if (g_error_matches (error, G_SPAWN_ERROR, G_SPAWN_ERROR_NOENT))\n        code = G_DBUS_ERROR_FILE_NOT_FOUND;\n      g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, code,\n                                             \"Failed to start command: %s\",\n                                             error->message);\n      return G_DBUS_METHOD_INVOCATION_HANDLED;\n    }\n\n  if (instance_id_read_data)\n    instance_id_read_data->pid = pid;\n\n  pid_data = g_new0 (PidData, 1);\n  pid_data->pid = pid;\n  pid_data->client = g_strdup (g_dbus_method_invocation_get_sender (invocation));\n  pid_data->watch_bus = (arg_flags & FLATPAK_SPAWN_FLAGS_WATCH_BUS) != 0;\n  pid_data->expose_or_share_pids = (expose_pids || share_pids);\n  pid_data->child_watch = g_child_watch_add_full (G_PRIORITY_DEFAULT,\n                                                  pid,\n                                                  child_watch_died,\n                                                  pid_data,\n                                                  NULL);\n\n  g_debug (\"Client Pid is %d\", pid_data->pid);\n\n  g_hash_table_replace (client_pid_data_hash, GUINT_TO_POINTER (pid_data->pid),\n                        pid_data);\n\n  portal_flatpak_complete_spawn (object, invocation, NULL, pid);\n  return G_DBUS_METHOD_INVOCATION_HANDLED;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -257,6 +257,13 @@\n   else\n     env = g_get_environ ();\n \n+  /* Let the environment variables given by the caller override the ones\n+   * from extra_args. Don't add them to @env, because they are controlled\n+   * by our caller, which might be trying to use them to inject code into\n+   * flatpak(1); add them to the environment block instead.\n+   *\n+   * We don't use --env= here, so that if the values are something that\n+   * should not be exposed to other uids, they can remain confidential. */\n   n_envs = g_variant_n_children (arg_envs);\n   for (i = 0; i < n_envs; i++)\n     {\n@@ -264,7 +271,26 @@\n       const char *val = NULL;\n       g_variant_get_child (arg_envs, i, \"{&s&s}\", &var, &val);\n \n-      env = g_environ_setenv (env, var, val, TRUE);\n+      if (var[0] == '\\0')\n+        {\n+          g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,\n+                                                 G_DBUS_ERROR_INVALID_ARGS,\n+                                                 \"Environment variable cannot have empty name\");\n+          return G_DBUS_METHOD_INVOCATION_HANDLED;\n+        }\n+\n+      if (strchr (var, '=') != NULL)\n+        {\n+          g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,\n+                                                 G_DBUS_ERROR_INVALID_ARGS,\n+                                                 \"Environment variable name cannot contain '='\");\n+          return G_DBUS_METHOD_INVOCATION_HANDLED;\n+        }\n+\n+      g_string_append (env_string, var);\n+      g_string_append_c (env_string, '=');\n+      g_string_append (env_string, val);\n+      g_string_append_c (env_string, '\\0');\n     }\n \n   g_ptr_array_add (flatpak_argv, g_strdup (\"flatpak\"));",
        "diff_line_info": {
            "deleted_lines": [
                "      env = g_environ_setenv (env, var, val, TRUE);"
            ],
            "added_lines": [
                "  /* Let the environment variables given by the caller override the ones",
                "   * from extra_args. Don't add them to @env, because they are controlled",
                "   * by our caller, which might be trying to use them to inject code into",
                "   * flatpak(1); add them to the environment block instead.",
                "   *",
                "   * We don't use --env= here, so that if the values are something that",
                "   * should not be exposed to other uids, they can remain confidential. */",
                "      if (var[0] == '\\0')",
                "        {",
                "          g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,",
                "                                                 G_DBUS_ERROR_INVALID_ARGS,",
                "                                                 \"Environment variable cannot have empty name\");",
                "          return G_DBUS_METHOD_INVOCATION_HANDLED;",
                "        }",
                "",
                "      if (strchr (var, '=') != NULL)",
                "        {",
                "          g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,",
                "                                                 G_DBUS_ERROR_INVALID_ARGS,",
                "                                                 \"Environment variable name cannot contain '='\");",
                "          return G_DBUS_METHOD_INVOCATION_HANDLED;",
                "        }",
                "",
                "      g_string_append (env_string, var);",
                "      g_string_append_c (env_string, '=');",
                "      g_string_append (env_string, val);",
                "      g_string_append_c (env_string, '\\0');"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-21261",
        "func_name": "flatpak/child_setup_func",
        "description": "Flatpak is a system for building, distributing, and running sandboxed desktop applications on Linux. A bug was discovered in the `flatpak-portal` service that can allow sandboxed applications to execute arbitrary code on the host system (a sandbox escape). This sandbox-escape bug is present in versions from 0.11.4 and before fixed versions 1.8.5 and 1.10.0. The Flatpak portal D-Bus service (`flatpak-portal`, also known by its D-Bus service name `org.freedesktop.portal.Flatpak`) allows apps in a Flatpak sandbox to launch their own subprocesses in a new sandbox instance, either with the same security settings as the caller or with more restrictive security settings. For example, this is used in Flatpak-packaged web browsers such as Chromium to launch subprocesses that will process untrusted web content, and give those subprocesses a more restrictive sandbox than the browser itself. In vulnerable versions, the Flatpak portal service passes caller-specified environment variables to non-sandboxed processes on the host system, and in particular to the `flatpak run` command that is used to launch the new sandbox instance. A malicious or compromised Flatpak app could set environment variables that are trusted by the `flatpak run` command, and use them to execute arbitrary code that is not in a sandbox. As a workaround, this vulnerability can be mitigated by preventing the `flatpak-portal` service from starting, but that mitigation will prevent many Flatpak apps from working correctly. This is fixed in versions 1.8.5 and 1.10.0.",
        "git_url": "https://github.com/flatpak/flatpak/commit/aeb6a7ab0abaac4a8f4ad98b3df476d9de6b8bd4",
        "commit_title": "portal: Convert --env in extra-args into --env-fd",
        "commit_text": " This hides overridden variables from the command-line, which means processes running under other uids can't see them in /proc/*/cmdline, which might be important if they contain secrets.  Part-of: https://github.com/flatpak/flatpak/security/advisories/GHSA-4ppf-fxf6-vxg2",
        "func_before": "static void\nchild_setup_func (gpointer user_data)\n{\n  ChildSetupData *data = (ChildSetupData *) user_data;\n  FdMapEntry *fd_map = data->fd_map;\n  sigset_t set;\n  int i;\n\n  flatpak_close_fds_workaround (3);\n\n  if (data->instance_id_fd != -1)\n    drop_cloexec (data->instance_id_fd);\n\n  /* Unblock all signals */\n  sigemptyset (&set);\n  if (pthread_sigmask (SIG_SETMASK, &set, NULL) == -1)\n    {\n      g_warning (\"Failed to unblock signals when starting child\");\n      return;\n    }\n\n  /* Reset the handlers for all signals to their defaults. */\n  for (i = 1; i < NSIG; i++)\n    {\n      if (i != SIGSTOP && i != SIGKILL)\n        signal (i, SIG_DFL);\n    }\n\n  for (i = 0; i < data->fd_map_len; i++)\n    {\n      if (fd_map[i].from != fd_map[i].to)\n        {\n          dup2 (fd_map[i].from, fd_map[i].to);\n          close (fd_map[i].from);\n        }\n    }\n\n  /* Second pass in case we needed an in-between fd value to avoid conflicts */\n  for (i = 0; i < data->fd_map_len; i++)\n    {\n      if (fd_map[i].to != fd_map[i].final)\n        {\n          dup2 (fd_map[i].to, fd_map[i].final);\n          close (fd_map[i].to);\n        }\n\n      /* Ensure we inherit the final fd value */\n      drop_cloexec (fd_map[i].final);\n    }\n\n  /* We become our own session and process group, because it never makes sense\n     to share the flatpak-session-helper dbus activated process group */\n  setsid ();\n  setpgid (0, 0);\n\n  if (data->set_tty)\n    {\n      /* data->tty is our from fd which is closed at this point.\n       * so locate the destination fd and use it for the ioctl.\n       */\n      for (i = 0; i < data->fd_map_len; i++)\n        {\n          if (fd_map[i].from == data->tty)\n            {\n              if (ioctl (fd_map[i].final, TIOCSCTTY, 0) == -1)\n                g_debug (\"ioctl(%d, TIOCSCTTY, 0) failed: %s\",\n                         fd_map[i].final, strerror (errno));\n              break;\n            }\n        }\n    }\n}",
        "func": "static void\nchild_setup_func (gpointer user_data)\n{\n  ChildSetupData *data = (ChildSetupData *) user_data;\n  FdMapEntry *fd_map = data->fd_map;\n  sigset_t set;\n  int i;\n\n  flatpak_close_fds_workaround (3);\n\n  if (data->instance_id_fd != -1)\n    drop_cloexec (data->instance_id_fd);\n\n  if (data->env_fd != -1)\n    drop_cloexec (data->env_fd);\n\n  /* Unblock all signals */\n  sigemptyset (&set);\n  if (pthread_sigmask (SIG_SETMASK, &set, NULL) == -1)\n    {\n      g_warning (\"Failed to unblock signals when starting child\");\n      return;\n    }\n\n  /* Reset the handlers for all signals to their defaults. */\n  for (i = 1; i < NSIG; i++)\n    {\n      if (i != SIGSTOP && i != SIGKILL)\n        signal (i, SIG_DFL);\n    }\n\n  for (i = 0; i < data->fd_map_len; i++)\n    {\n      if (fd_map[i].from != fd_map[i].to)\n        {\n          dup2 (fd_map[i].from, fd_map[i].to);\n          close (fd_map[i].from);\n        }\n    }\n\n  /* Second pass in case we needed an in-between fd value to avoid conflicts */\n  for (i = 0; i < data->fd_map_len; i++)\n    {\n      if (fd_map[i].to != fd_map[i].final)\n        {\n          dup2 (fd_map[i].to, fd_map[i].final);\n          close (fd_map[i].to);\n        }\n\n      /* Ensure we inherit the final fd value */\n      drop_cloexec (fd_map[i].final);\n    }\n\n  /* We become our own session and process group, because it never makes sense\n     to share the flatpak-session-helper dbus activated process group */\n  setsid ();\n  setpgid (0, 0);\n\n  if (data->set_tty)\n    {\n      /* data->tty is our from fd which is closed at this point.\n       * so locate the destination fd and use it for the ioctl.\n       */\n      for (i = 0; i < data->fd_map_len; i++)\n        {\n          if (fd_map[i].from == data->tty)\n            {\n              if (ioctl (fd_map[i].final, TIOCSCTTY, 0) == -1)\n                g_debug (\"ioctl(%d, TIOCSCTTY, 0) failed: %s\",\n                         fd_map[i].final, strerror (errno));\n              break;\n            }\n        }\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -10,6 +10,9 @@\n \n   if (data->instance_id_fd != -1)\n     drop_cloexec (data->instance_id_fd);\n+\n+  if (data->env_fd != -1)\n+    drop_cloexec (data->env_fd);\n \n   /* Unblock all signals */\n   sigemptyset (&set);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "  if (data->env_fd != -1)",
                "    drop_cloexec (data->env_fd);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-21261",
        "func_name": "flatpak/handle_spawn",
        "description": "Flatpak is a system for building, distributing, and running sandboxed desktop applications on Linux. A bug was discovered in the `flatpak-portal` service that can allow sandboxed applications to execute arbitrary code on the host system (a sandbox escape). This sandbox-escape bug is present in versions from 0.11.4 and before fixed versions 1.8.5 and 1.10.0. The Flatpak portal D-Bus service (`flatpak-portal`, also known by its D-Bus service name `org.freedesktop.portal.Flatpak`) allows apps in a Flatpak sandbox to launch their own subprocesses in a new sandbox instance, either with the same security settings as the caller or with more restrictive security settings. For example, this is used in Flatpak-packaged web browsers such as Chromium to launch subprocesses that will process untrusted web content, and give those subprocesses a more restrictive sandbox than the browser itself. In vulnerable versions, the Flatpak portal service passes caller-specified environment variables to non-sandboxed processes on the host system, and in particular to the `flatpak run` command that is used to launch the new sandbox instance. A malicious or compromised Flatpak app could set environment variables that are trusted by the `flatpak run` command, and use them to execute arbitrary code that is not in a sandbox. As a workaround, this vulnerability can be mitigated by preventing the `flatpak-portal` service from starting, but that mitigation will prevent many Flatpak apps from working correctly. This is fixed in versions 1.8.5 and 1.10.0.",
        "git_url": "https://github.com/flatpak/flatpak/commit/aeb6a7ab0abaac4a8f4ad98b3df476d9de6b8bd4",
        "commit_title": "portal: Convert --env in extra-args into --env-fd",
        "commit_text": " This hides overridden variables from the command-line, which means processes running under other uids can't see them in /proc/*/cmdline, which might be important if they contain secrets.  Part-of: https://github.com/flatpak/flatpak/security/advisories/GHSA-4ppf-fxf6-vxg2",
        "func_before": "static gboolean\nhandle_spawn (PortalFlatpak         *object,\n              GDBusMethodInvocation *invocation,\n              GUnixFDList           *fd_list,\n              const gchar           *arg_cwd_path,\n              const gchar *const    *arg_argv,\n              GVariant              *arg_fds,\n              GVariant              *arg_envs,\n              guint                  arg_flags,\n              GVariant              *arg_options)\n{\n  g_autoptr(GError) error = NULL;\n  ChildSetupData child_setup_data = { NULL };\n  GPid pid;\n  PidData *pid_data;\n  InstanceIdReadData *instance_id_read_data = NULL;\n  gsize i, j, n_fds, n_envs;\n  const gint *fds = NULL;\n  gint fds_len = 0;\n  g_autofree FdMapEntry *fd_map = NULL;\n  gchar **env;\n  gint32 max_fd;\n  GKeyFile *app_info;\n  g_autoptr(GPtrArray) flatpak_argv = g_ptr_array_new_with_free_func (g_free);\n  g_autofree char *app_id = NULL;\n  g_autofree char *branch = NULL;\n  g_autofree char *arch = NULL;\n  g_autofree char *app_commit = NULL;\n  g_autofree char *runtime_ref = NULL;\n  g_auto(GStrv) runtime_parts = NULL;\n  g_autofree char *runtime_commit = NULL;\n  g_autofree char *instance_path = NULL;\n  g_auto(GStrv) extra_args = NULL;\n  g_auto(GStrv) shares = NULL;\n  g_auto(GStrv) sockets = NULL;\n  g_auto(GStrv) devices = NULL;\n  g_auto(GStrv) sandbox_expose = NULL;\n  g_auto(GStrv) sandbox_expose_ro = NULL;\n  g_autoptr(GVariant) sandbox_expose_fd = NULL;\n  g_autoptr(GVariant) sandbox_expose_fd_ro = NULL;\n  g_autoptr(GOutputStream) instance_id_out_stream = NULL;\n  guint sandbox_flags = 0;\n  gboolean sandboxed;\n  gboolean expose_pids;\n  gboolean share_pids;\n  gboolean notify_start;\n  gboolean devel;\n\n  child_setup_data.instance_id_fd = -1;\n\n  if (fd_list != NULL)\n    fds = g_unix_fd_list_peek_fds (fd_list, &fds_len);\n\n  app_info = g_object_get_data (G_OBJECT (invocation), \"app-info\");\n  g_assert (app_info != NULL);\n\n  app_id = g_key_file_get_string (app_info,\n                                  FLATPAK_METADATA_GROUP_APPLICATION,\n                                  FLATPAK_METADATA_KEY_NAME, NULL);\n  g_assert (app_id != NULL);\n\n  g_debug (\"spawn() called from app: '%s'\", app_id);\n  if (*app_id == 0)\n    {\n      g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,\n                                             G_DBUS_ERROR_INVALID_ARGS,\n                                             \"org.freedesktop.portal.Flatpak.Spawn only works in a flatpak\");\n      return G_DBUS_METHOD_INVOCATION_HANDLED;\n    }\n\n  if (*arg_cwd_path == 0)\n    arg_cwd_path = NULL;\n\n  if (arg_argv == NULL || *arg_argv == NULL)\n    {\n      g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,\n                                             G_DBUS_ERROR_INVALID_ARGS,\n                                             \"No command given\");\n      return G_DBUS_METHOD_INVOCATION_HANDLED;\n    }\n\n  if ((arg_flags & ~FLATPAK_SPAWN_FLAGS_ALL) != 0)\n    {\n      g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS,\n                                             \"Unsupported flags enabled: 0x%x\", arg_flags & ~FLATPAK_SPAWN_FLAGS_ALL);\n      return G_DBUS_METHOD_INVOCATION_HANDLED;\n    }\n\n  runtime_ref = g_key_file_get_string (app_info,\n                                       FLATPAK_METADATA_GROUP_APPLICATION,\n                                       FLATPAK_METADATA_KEY_RUNTIME, NULL);\n  if (runtime_ref == NULL)\n    {\n      g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS,\n                                             \"No runtime found\");\n      return G_DBUS_METHOD_INVOCATION_HANDLED;\n    }\n\n  runtime_parts = g_strsplit (runtime_ref, \"/\", -1);\n\n  branch = g_key_file_get_string (app_info,\n                                  FLATPAK_METADATA_GROUP_INSTANCE,\n                                  FLATPAK_METADATA_KEY_BRANCH, NULL);\n  instance_path = g_key_file_get_string (app_info,\n                                         FLATPAK_METADATA_GROUP_INSTANCE,\n                                         FLATPAK_METADATA_KEY_INSTANCE_PATH, NULL);\n  arch = g_key_file_get_string (app_info,\n                                FLATPAK_METADATA_GROUP_INSTANCE,\n                                FLATPAK_METADATA_KEY_ARCH, NULL);\n  extra_args = g_key_file_get_string_list (app_info,\n                                           FLATPAK_METADATA_GROUP_INSTANCE,\n                                           FLATPAK_METADATA_KEY_EXTRA_ARGS, NULL, NULL);\n  app_commit = g_key_file_get_string (app_info,\n                                      FLATPAK_METADATA_GROUP_INSTANCE,\n                                      FLATPAK_METADATA_KEY_APP_COMMIT, NULL);\n  runtime_commit = g_key_file_get_string (app_info,\n                                          FLATPAK_METADATA_GROUP_INSTANCE,\n                                          FLATPAK_METADATA_KEY_RUNTIME_COMMIT, NULL);\n  shares = g_key_file_get_string_list (app_info, FLATPAK_METADATA_GROUP_CONTEXT,\n                                       FLATPAK_METADATA_KEY_SHARED, NULL, NULL);\n  sockets = g_key_file_get_string_list (app_info, FLATPAK_METADATA_GROUP_CONTEXT,\n                                       FLATPAK_METADATA_KEY_SOCKETS, NULL, NULL);\n  devices = g_key_file_get_string_list (app_info, FLATPAK_METADATA_GROUP_CONTEXT,\n                                        FLATPAK_METADATA_KEY_DEVICES, NULL, NULL);\n\n  devel = g_key_file_get_boolean (app_info, FLATPAK_METADATA_GROUP_INSTANCE,\n                                  FLATPAK_METADATA_KEY_DEVEL, NULL);\n\n  g_variant_lookup (arg_options, \"sandbox-expose\", \"^as\", &sandbox_expose);\n  g_variant_lookup (arg_options, \"sandbox-expose-ro\", \"^as\", &sandbox_expose_ro);\n  g_variant_lookup (arg_options, \"sandbox-flags\", \"u\", &sandbox_flags);\n  sandbox_expose_fd = g_variant_lookup_value (arg_options, \"sandbox-expose-fd\", G_VARIANT_TYPE (\"ah\"));\n  sandbox_expose_fd_ro = g_variant_lookup_value (arg_options, \"sandbox-expose-fd-ro\", G_VARIANT_TYPE (\"ah\"));\n\n  if ((sandbox_flags & ~FLATPAK_SPAWN_SANDBOX_FLAGS_ALL) != 0)\n    {\n      g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS,\n                                             \"Unsupported sandbox flags enabled: 0x%x\", arg_flags & ~FLATPAK_SPAWN_SANDBOX_FLAGS_ALL);\n      return G_DBUS_METHOD_INVOCATION_HANDLED;\n    }\n\n  if (instance_path == NULL &&\n      ((sandbox_expose != NULL && sandbox_expose[0] != NULL) ||\n       (sandbox_expose_ro != NULL && sandbox_expose_ro[0] != NULL)))\n    {\n      g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,\n                                             G_DBUS_ERROR_INVALID_ARGS,\n                                             \"Invalid sandbox expose, caller has no instance path\");\n      return G_DBUS_METHOD_INVOCATION_HANDLED;\n    }\n\n  for (i = 0; sandbox_expose != NULL && sandbox_expose[i] != NULL; i++)\n    {\n      const char *expose = sandbox_expose[i];\n\n      g_debug (\"exposing %s\", expose);\n      if (!is_valid_expose (expose, &error))\n        {\n          g_dbus_method_invocation_return_gerror (invocation, error);\n          return G_DBUS_METHOD_INVOCATION_HANDLED;\n        }\n    }\n\n  for (i = 0; sandbox_expose_ro != NULL && sandbox_expose_ro[i] != NULL; i++)\n    {\n      const char *expose = sandbox_expose_ro[i];\n      g_debug (\"exposing %s\", expose);\n      if (!is_valid_expose (expose, &error))\n        {\n          g_dbus_method_invocation_return_gerror (invocation, error);\n          return G_DBUS_METHOD_INVOCATION_HANDLED;\n        }\n    }\n\n  g_debug (\"Running spawn command %s\", arg_argv[0]);\n\n  n_fds = 0;\n  if (fds != NULL)\n    n_fds = g_variant_n_children (arg_fds);\n  fd_map = g_new0 (FdMapEntry, n_fds);\n\n  child_setup_data.fd_map = fd_map;\n  child_setup_data.fd_map_len = n_fds;\n\n  max_fd = -1;\n  for (i = 0; i < n_fds; i++)\n    {\n      gint32 handle, dest_fd;\n      int handle_fd;\n\n      g_variant_get_child (arg_fds, i, \"{uh}\", &dest_fd, &handle);\n\n      if (handle >= fds_len || handle < 0)\n        {\n          g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,\n                                                 G_DBUS_ERROR_INVALID_ARGS,\n                                                 \"No file descriptor for handle %d\",\n                                                 handle);\n          return G_DBUS_METHOD_INVOCATION_HANDLED;\n        }\n\n      handle_fd = fds[handle];\n\n      fd_map[i].to = dest_fd;\n      fd_map[i].from = handle_fd;\n      fd_map[i].final = fd_map[i].to;\n\n      /* If stdin/out/err is a tty we try to set it as the controlling\n         tty for the app, this way we can use this to run in a terminal. */\n      if ((dest_fd == 0 || dest_fd == 1 || dest_fd == 2) &&\n          !child_setup_data.set_tty &&\n          isatty (handle_fd))\n        {\n          child_setup_data.set_tty = TRUE;\n          child_setup_data.tty = handle_fd;\n        }\n\n      max_fd = MAX (max_fd, fd_map[i].to);\n      max_fd = MAX (max_fd, fd_map[i].from);\n    }\n\n  /* We make a second pass over the fds to find if any \"to\" fd index\n     overlaps an already in use fd (i.e. one in the \"from\" category\n     that are allocated randomly). If a fd overlaps \"to\" fd then its\n     a caller issue and not our fault, so we ignore that. */\n  for (i = 0; i < n_fds; i++)\n    {\n      int to_fd = fd_map[i].to;\n      gboolean conflict = FALSE;\n\n      /* At this point we're fine with using \"from\" values for this\n         value (because we handle to==from in the code), or values\n         that are before \"i\" in the fd_map (because those will be\n         closed at this point when dup:ing). However, we can't\n         reuse a fd that is in \"from\" for j > i. */\n      for (j = i + 1; j < n_fds; j++)\n        {\n          int from_fd = fd_map[j].from;\n          if (from_fd == to_fd)\n            {\n              conflict = TRUE;\n              break;\n            }\n        }\n\n      if (conflict)\n        fd_map[i].to = ++max_fd;\n    }\n\n  if (arg_flags & FLATPAK_SPAWN_FLAGS_CLEAR_ENV)\n    {\n      char *empty[] = { NULL };\n      env = g_strdupv (empty);\n    }\n  else\n    env = g_get_environ ();\n\n  n_envs = g_variant_n_children (arg_envs);\n  for (i = 0; i < n_envs; i++)\n    {\n      const char *var = NULL;\n      const char *val = NULL;\n      g_variant_get_child (arg_envs, i, \"{&s&s}\", &var, &val);\n\n      env = g_environ_setenv (env, var, val, TRUE);\n    }\n\n  g_ptr_array_add (flatpak_argv, g_strdup (\"flatpak\"));\n  g_ptr_array_add (flatpak_argv, g_strdup (\"run\"));\n\n  sandboxed = (arg_flags & FLATPAK_SPAWN_FLAGS_SANDBOX) != 0;\n\n  if (sandboxed)\n    {\n      g_ptr_array_add (flatpak_argv, g_strdup (\"--sandbox\"));\n\n      if (sandbox_flags & FLATPAK_SPAWN_SANDBOX_FLAGS_SHARE_DISPLAY)\n        {\n          if (sockets != NULL && g_strv_contains ((const char * const *) sockets, \"wayland\"))\n            g_ptr_array_add (flatpak_argv, g_strdup (\"--socket=wayland\"));\n          if (sockets != NULL && g_strv_contains ((const char * const *) sockets, \"fallback-x11\"))\n            g_ptr_array_add (flatpak_argv, g_strdup (\"--socket=fallback-x11\"));\n          if (sockets != NULL && g_strv_contains ((const char * const *) sockets, \"x11\"))\n            g_ptr_array_add (flatpak_argv, g_strdup (\"--socket=x11\"));\n          if (shares != NULL && g_strv_contains ((const char * const *) shares, \"ipc\") &&\n              sockets != NULL && (g_strv_contains ((const char * const *) sockets, \"fallback-x11\") ||\n                                  g_strv_contains ((const char * const *) sockets, \"x11\")))\n            g_ptr_array_add (flatpak_argv, g_strdup (\"--share=ipc\"));\n        }\n      if (sandbox_flags & FLATPAK_SPAWN_SANDBOX_FLAGS_SHARE_SOUND)\n        {\n          if (sockets != NULL && g_strv_contains ((const char * const *) sockets, \"pulseaudio\"))\n            g_ptr_array_add (flatpak_argv, g_strdup (\"--socket=pulseaudio\"));\n        }\n      if (sandbox_flags & FLATPAK_SPAWN_SANDBOX_FLAGS_SHARE_GPU)\n        {\n          if (devices != NULL &&\n              (g_strv_contains ((const char * const *) devices, \"dri\") ||\n               g_strv_contains ((const char * const *) devices, \"all\")))\n            g_ptr_array_add (flatpak_argv, g_strdup (\"--device=dri\"));\n        }\n      if (sandbox_flags & FLATPAK_SPAWN_SANDBOX_FLAGS_ALLOW_DBUS)\n        g_ptr_array_add (flatpak_argv, g_strdup (\"--session-bus\"));\n      if (sandbox_flags & FLATPAK_SPAWN_SANDBOX_FLAGS_ALLOW_A11Y)\n        g_ptr_array_add (flatpak_argv, g_strdup (\"--a11y-bus\"));\n    }\n  else\n    {\n      for (i = 0; extra_args != NULL && extra_args[i] != NULL; i++)\n        g_ptr_array_add (flatpak_argv, g_strdup (extra_args[i]));\n    }\n\n  expose_pids = (arg_flags & FLATPAK_SPAWN_FLAGS_EXPOSE_PIDS) != 0;\n  share_pids = (arg_flags & FLATPAK_SPAWN_FLAGS_SHARE_PIDS) != 0;\n\n  if (expose_pids || share_pids)\n    {\n      g_autofree char *instance_id = NULL;\n      int sender_pid1 = 0;\n\n      if (!(supports & FLATPAK_SPAWN_SUPPORT_FLAGS_EXPOSE_PIDS))\n        {\n          g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,\n                                                 G_DBUS_ERROR_NOT_SUPPORTED,\n                                                 \"Expose pids not supported with setuid bwrap\");\n          return G_DBUS_METHOD_INVOCATION_HANDLED;\n        }\n\n      instance_id = g_key_file_get_string (app_info,\n                                           FLATPAK_METADATA_GROUP_INSTANCE,\n                                           FLATPAK_METADATA_KEY_INSTANCE_ID, NULL);\n\n      if (instance_id)\n        {\n          g_autoptr(FlatpakInstance) instance = flatpak_instance_new_for_id (instance_id);\n          sender_pid1 = flatpak_instance_get_child_pid (instance);\n        }\n\n      if (sender_pid1 == 0)\n        {\n          g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,\n                                                 G_DBUS_ERROR_INVALID_ARGS,\n                                                 \"Could not find requesting pid\");\n          return G_DBUS_METHOD_INVOCATION_HANDLED;\n        }\n\n      g_ptr_array_add (flatpak_argv, g_strdup_printf (\"--parent-pid=%d\", sender_pid1));\n\n      if (share_pids)\n        g_ptr_array_add (flatpak_argv, g_strdup (\"--parent-share-pids\"));\n      else\n        g_ptr_array_add (flatpak_argv, g_strdup (\"--parent-expose-pids\"));\n    }\n\n  notify_start = (arg_flags & FLATPAK_SPAWN_FLAGS_NOTIFY_START) != 0;\n  if (notify_start)\n    {\n      int pipe_fds[2];\n      if (pipe (pipe_fds) == -1)\n        {\n          int errsv = errno;\n          g_dbus_method_invocation_return_error (invocation, G_IO_ERROR,\n                                                 g_io_error_from_errno (errsv),\n                                                 \"Failed to create instance ID pipe: %s\",\n                                                 g_strerror (errsv));\n          return G_DBUS_METHOD_INVOCATION_HANDLED;\n        }\n\n      GInputStream *in_stream = G_INPUT_STREAM (g_unix_input_stream_new (pipe_fds[0], TRUE));\n      /* This is saved to ensure the portal's end gets closed after the exec. */\n      instance_id_out_stream = G_OUTPUT_STREAM (g_unix_output_stream_new (pipe_fds[1], TRUE));\n\n      instance_id_read_data = g_new0 (InstanceIdReadData, 1);\n\n      g_input_stream_read_async (in_stream, instance_id_read_data->buffer,\n                                 INSTANCE_ID_BUFFER_SIZE - 1, G_PRIORITY_DEFAULT, NULL,\n                                 instance_id_read_finish, instance_id_read_data);\n\n      g_ptr_array_add (flatpak_argv, g_strdup_printf (\"--instance-id-fd=%d\", pipe_fds[1]));\n      child_setup_data.instance_id_fd = pipe_fds[1];\n    }\n\n  if (devel)\n    g_ptr_array_add (flatpak_argv, g_strdup (\"--devel\"));\n\n  /* Inherit launcher network access from launcher, unless\n     NO_NETWORK set. */\n  if (shares != NULL && g_strv_contains ((const char * const *) shares, \"network\") &&\n      !(arg_flags & FLATPAK_SPAWN_FLAGS_NO_NETWORK))\n    g_ptr_array_add (flatpak_argv, g_strdup (\"--share=network\"));\n  else\n    g_ptr_array_add (flatpak_argv, g_strdup (\"--unshare=network\"));\n\n\n  if (instance_path)\n    {\n      for (i = 0; sandbox_expose != NULL && sandbox_expose[i] != NULL; i++)\n        g_ptr_array_add (flatpak_argv,\n                         filesystem_sandbox_arg (instance_path, sandbox_expose[i], FALSE));\n      for (i = 0; sandbox_expose_ro != NULL && sandbox_expose_ro[i] != NULL; i++)\n        g_ptr_array_add (flatpak_argv,\n                         filesystem_sandbox_arg (instance_path, sandbox_expose_ro[i], TRUE));\n    }\n\n  for (i = 0; sandbox_expose_ro != NULL && sandbox_expose_ro[i] != NULL; i++)\n    {\n      const char *expose = sandbox_expose_ro[i];\n      g_debug (\"exposing %s\", expose);\n    }\n\n  if (sandbox_expose_fd != NULL)\n    {\n      gsize len = g_variant_n_children (sandbox_expose_fd);\n      for (i = 0; i < len; i++)\n        {\n          gint32 handle;\n          g_variant_get_child (sandbox_expose_fd, i, \"h\", &handle);\n          if (handle >= 0 && handle < fds_len)\n            {\n              int handle_fd = fds[handle];\n              g_autofree char *path = NULL;\n              gboolean writable = FALSE;\n\n              path = get_path_for_fd (handle_fd, &writable, &error);\n\n              if (path)\n                {\n                  g_ptr_array_add (flatpak_argv, filesystem_arg (path, !writable));\n                }\n              else\n                {\n                  g_debug (\"unable to get path for sandbox-exposed fd %d, ignoring: %s\",\n                           handle_fd, error->message);\n                  g_clear_error (&error);\n                }\n            }\n          else\n            {\n              g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,\n                                                     G_DBUS_ERROR_INVALID_ARGS,\n                                                     \"No file descriptor for handle %d\",\n                                                     handle);\n              return G_DBUS_METHOD_INVOCATION_HANDLED;\n            }\n        }\n    }\n\n  if (sandbox_expose_fd_ro != NULL)\n    {\n      gsize len = g_variant_n_children (sandbox_expose_fd_ro);\n      for (i = 0; i < len; i++)\n        {\n          gint32 handle;\n          g_variant_get_child (sandbox_expose_fd_ro, i, \"h\", &handle);\n          if (handle >= 0 && handle < fds_len)\n            {\n              int handle_fd = fds[handle];\n              g_autofree char *path = NULL;\n              gboolean writable = FALSE;\n\n              path = get_path_for_fd (handle_fd, &writable, &error);\n\n              if (path)\n                {\n                  g_ptr_array_add (flatpak_argv, filesystem_arg (path, TRUE));\n                }\n              else\n                {\n                  g_debug (\"unable to get path for sandbox-exposed fd %d, ignoring: %s\",\n                           handle_fd, error->message);\n                  g_clear_error (&error);\n                }\n            }\n          else\n            {\n              g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,\n                                                     G_DBUS_ERROR_INVALID_ARGS,\n                                                     \"No file descriptor for handle %d\",\n                                                     handle);\n              return G_DBUS_METHOD_INVOCATION_HANDLED;\n            }\n        }\n    }\n\n  g_ptr_array_add (flatpak_argv, g_strdup_printf (\"--runtime=%s\", runtime_parts[1]));\n  g_ptr_array_add (flatpak_argv, g_strdup_printf (\"--runtime-version=%s\", runtime_parts[3]));\n\n  if ((arg_flags & FLATPAK_SPAWN_FLAGS_LATEST_VERSION) == 0)\n    {\n      if (app_commit)\n        g_ptr_array_add (flatpak_argv, g_strdup_printf (\"--commit=%s\", app_commit));\n      if (runtime_commit)\n        g_ptr_array_add (flatpak_argv, g_strdup_printf (\"--runtime-commit=%s\", runtime_commit));\n    }\n\n  if (arg_cwd_path != NULL)\n    g_ptr_array_add (flatpak_argv, g_strdup_printf (\"--cwd=%s\", arg_cwd_path));\n\n  if (arg_argv[0][0] != 0)\n    g_ptr_array_add (flatpak_argv, g_strdup_printf (\"--command=%s\", arg_argv[0]));\n\n  g_ptr_array_add (flatpak_argv, g_strdup_printf (\"%s/%s/%s\", app_id, arch ? arch : \"\", branch ? branch : \"\"));\n  for (i = 1; arg_argv[i] != NULL; i++)\n    g_ptr_array_add (flatpak_argv, g_strdup (arg_argv[i]));\n  g_ptr_array_add (flatpak_argv, NULL);\n\n  if (opt_verbose)\n    {\n      g_autoptr(GString) cmd = g_string_new (\"\");\n\n      for (i = 0; flatpak_argv->pdata[i] != NULL; i++)\n        {\n          if (i > 0)\n            g_string_append (cmd, \" \");\n          g_string_append (cmd, flatpak_argv->pdata[i]);\n        }\n\n      g_debug (\"Starting: %s\\n\", cmd->str);\n    }\n\n  /* We use LEAVE_DESCRIPTORS_OPEN to work around dead-lock, see flatpak_close_fds_workaround */\n  if (!g_spawn_async_with_pipes (NULL,\n                                 (char **) flatpak_argv->pdata,\n                                 env,\n                                 G_SPAWN_SEARCH_PATH | G_SPAWN_DO_NOT_REAP_CHILD | G_SPAWN_LEAVE_DESCRIPTORS_OPEN,\n                                 child_setup_func, &child_setup_data,\n                                 &pid,\n                                 NULL,\n                                 NULL,\n                                 NULL,\n                                 &error))\n    {\n      gint code = G_DBUS_ERROR_FAILED;\n      if (g_error_matches (error, G_SPAWN_ERROR, G_SPAWN_ERROR_ACCES))\n        code = G_DBUS_ERROR_ACCESS_DENIED;\n      else if (g_error_matches (error, G_SPAWN_ERROR, G_SPAWN_ERROR_NOENT))\n        code = G_DBUS_ERROR_FILE_NOT_FOUND;\n      g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, code,\n                                             \"Failed to start command: %s\",\n                                             error->message);\n      return G_DBUS_METHOD_INVOCATION_HANDLED;\n    }\n\n  if (instance_id_read_data)\n    instance_id_read_data->pid = pid;\n\n  pid_data = g_new0 (PidData, 1);\n  pid_data->pid = pid;\n  pid_data->client = g_strdup (g_dbus_method_invocation_get_sender (invocation));\n  pid_data->watch_bus = (arg_flags & FLATPAK_SPAWN_FLAGS_WATCH_BUS) != 0;\n  pid_data->expose_or_share_pids = (expose_pids || share_pids);\n  pid_data->child_watch = g_child_watch_add_full (G_PRIORITY_DEFAULT,\n                                                  pid,\n                                                  child_watch_died,\n                                                  pid_data,\n                                                  NULL);\n\n  g_debug (\"Client Pid is %d\", pid_data->pid);\n\n  g_hash_table_replace (client_pid_data_hash, GUINT_TO_POINTER (pid_data->pid),\n                        pid_data);\n\n  portal_flatpak_complete_spawn (object, invocation, NULL, pid);\n  return G_DBUS_METHOD_INVOCATION_HANDLED;\n}",
        "func": "static gboolean\nhandle_spawn (PortalFlatpak         *object,\n              GDBusMethodInvocation *invocation,\n              GUnixFDList           *fd_list,\n              const gchar           *arg_cwd_path,\n              const gchar *const    *arg_argv,\n              GVariant              *arg_fds,\n              GVariant              *arg_envs,\n              guint                  arg_flags,\n              GVariant              *arg_options)\n{\n  g_autoptr(GError) error = NULL;\n  ChildSetupData child_setup_data = { NULL };\n  GPid pid;\n  PidData *pid_data;\n  InstanceIdReadData *instance_id_read_data = NULL;\n  gsize i, j, n_fds, n_envs;\n  const gint *fds = NULL;\n  gint fds_len = 0;\n  g_autofree FdMapEntry *fd_map = NULL;\n  gchar **env;\n  gint32 max_fd;\n  GKeyFile *app_info;\n  g_autoptr(GPtrArray) flatpak_argv = g_ptr_array_new_with_free_func (g_free);\n  g_autofree char *app_id = NULL;\n  g_autofree char *branch = NULL;\n  g_autofree char *arch = NULL;\n  g_autofree char *app_commit = NULL;\n  g_autofree char *runtime_ref = NULL;\n  g_auto(GStrv) runtime_parts = NULL;\n  g_autofree char *runtime_commit = NULL;\n  g_autofree char *instance_path = NULL;\n  g_auto(GStrv) extra_args = NULL;\n  g_auto(GStrv) shares = NULL;\n  g_auto(GStrv) sockets = NULL;\n  g_auto(GStrv) devices = NULL;\n  g_auto(GStrv) sandbox_expose = NULL;\n  g_auto(GStrv) sandbox_expose_ro = NULL;\n  g_autoptr(GVariant) sandbox_expose_fd = NULL;\n  g_autoptr(GVariant) sandbox_expose_fd_ro = NULL;\n  g_autoptr(GOutputStream) instance_id_out_stream = NULL;\n  guint sandbox_flags = 0;\n  gboolean sandboxed;\n  gboolean expose_pids;\n  gboolean share_pids;\n  gboolean notify_start;\n  gboolean devel;\n  g_autoptr(GString) env_string = g_string_new (\"\");\n\n  child_setup_data.instance_id_fd = -1;\n  child_setup_data.env_fd = -1;\n\n  if (fd_list != NULL)\n    fds = g_unix_fd_list_peek_fds (fd_list, &fds_len);\n\n  app_info = g_object_get_data (G_OBJECT (invocation), \"app-info\");\n  g_assert (app_info != NULL);\n\n  app_id = g_key_file_get_string (app_info,\n                                  FLATPAK_METADATA_GROUP_APPLICATION,\n                                  FLATPAK_METADATA_KEY_NAME, NULL);\n  g_assert (app_id != NULL);\n\n  g_debug (\"spawn() called from app: '%s'\", app_id);\n  if (*app_id == 0)\n    {\n      g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,\n                                             G_DBUS_ERROR_INVALID_ARGS,\n                                             \"org.freedesktop.portal.Flatpak.Spawn only works in a flatpak\");\n      return G_DBUS_METHOD_INVOCATION_HANDLED;\n    }\n\n  if (*arg_cwd_path == 0)\n    arg_cwd_path = NULL;\n\n  if (arg_argv == NULL || *arg_argv == NULL)\n    {\n      g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,\n                                             G_DBUS_ERROR_INVALID_ARGS,\n                                             \"No command given\");\n      return G_DBUS_METHOD_INVOCATION_HANDLED;\n    }\n\n  if ((arg_flags & ~FLATPAK_SPAWN_FLAGS_ALL) != 0)\n    {\n      g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS,\n                                             \"Unsupported flags enabled: 0x%x\", arg_flags & ~FLATPAK_SPAWN_FLAGS_ALL);\n      return G_DBUS_METHOD_INVOCATION_HANDLED;\n    }\n\n  runtime_ref = g_key_file_get_string (app_info,\n                                       FLATPAK_METADATA_GROUP_APPLICATION,\n                                       FLATPAK_METADATA_KEY_RUNTIME, NULL);\n  if (runtime_ref == NULL)\n    {\n      g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS,\n                                             \"No runtime found\");\n      return G_DBUS_METHOD_INVOCATION_HANDLED;\n    }\n\n  runtime_parts = g_strsplit (runtime_ref, \"/\", -1);\n\n  branch = g_key_file_get_string (app_info,\n                                  FLATPAK_METADATA_GROUP_INSTANCE,\n                                  FLATPAK_METADATA_KEY_BRANCH, NULL);\n  instance_path = g_key_file_get_string (app_info,\n                                         FLATPAK_METADATA_GROUP_INSTANCE,\n                                         FLATPAK_METADATA_KEY_INSTANCE_PATH, NULL);\n  arch = g_key_file_get_string (app_info,\n                                FLATPAK_METADATA_GROUP_INSTANCE,\n                                FLATPAK_METADATA_KEY_ARCH, NULL);\n  extra_args = g_key_file_get_string_list (app_info,\n                                           FLATPAK_METADATA_GROUP_INSTANCE,\n                                           FLATPAK_METADATA_KEY_EXTRA_ARGS, NULL, NULL);\n  app_commit = g_key_file_get_string (app_info,\n                                      FLATPAK_METADATA_GROUP_INSTANCE,\n                                      FLATPAK_METADATA_KEY_APP_COMMIT, NULL);\n  runtime_commit = g_key_file_get_string (app_info,\n                                          FLATPAK_METADATA_GROUP_INSTANCE,\n                                          FLATPAK_METADATA_KEY_RUNTIME_COMMIT, NULL);\n  shares = g_key_file_get_string_list (app_info, FLATPAK_METADATA_GROUP_CONTEXT,\n                                       FLATPAK_METADATA_KEY_SHARED, NULL, NULL);\n  sockets = g_key_file_get_string_list (app_info, FLATPAK_METADATA_GROUP_CONTEXT,\n                                       FLATPAK_METADATA_KEY_SOCKETS, NULL, NULL);\n  devices = g_key_file_get_string_list (app_info, FLATPAK_METADATA_GROUP_CONTEXT,\n                                        FLATPAK_METADATA_KEY_DEVICES, NULL, NULL);\n\n  devel = g_key_file_get_boolean (app_info, FLATPAK_METADATA_GROUP_INSTANCE,\n                                  FLATPAK_METADATA_KEY_DEVEL, NULL);\n\n  g_variant_lookup (arg_options, \"sandbox-expose\", \"^as\", &sandbox_expose);\n  g_variant_lookup (arg_options, \"sandbox-expose-ro\", \"^as\", &sandbox_expose_ro);\n  g_variant_lookup (arg_options, \"sandbox-flags\", \"u\", &sandbox_flags);\n  sandbox_expose_fd = g_variant_lookup_value (arg_options, \"sandbox-expose-fd\", G_VARIANT_TYPE (\"ah\"));\n  sandbox_expose_fd_ro = g_variant_lookup_value (arg_options, \"sandbox-expose-fd-ro\", G_VARIANT_TYPE (\"ah\"));\n\n  if ((sandbox_flags & ~FLATPAK_SPAWN_SANDBOX_FLAGS_ALL) != 0)\n    {\n      g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS,\n                                             \"Unsupported sandbox flags enabled: 0x%x\", arg_flags & ~FLATPAK_SPAWN_SANDBOX_FLAGS_ALL);\n      return G_DBUS_METHOD_INVOCATION_HANDLED;\n    }\n\n  if (instance_path == NULL &&\n      ((sandbox_expose != NULL && sandbox_expose[0] != NULL) ||\n       (sandbox_expose_ro != NULL && sandbox_expose_ro[0] != NULL)))\n    {\n      g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,\n                                             G_DBUS_ERROR_INVALID_ARGS,\n                                             \"Invalid sandbox expose, caller has no instance path\");\n      return G_DBUS_METHOD_INVOCATION_HANDLED;\n    }\n\n  for (i = 0; sandbox_expose != NULL && sandbox_expose[i] != NULL; i++)\n    {\n      const char *expose = sandbox_expose[i];\n\n      g_debug (\"exposing %s\", expose);\n      if (!is_valid_expose (expose, &error))\n        {\n          g_dbus_method_invocation_return_gerror (invocation, error);\n          return G_DBUS_METHOD_INVOCATION_HANDLED;\n        }\n    }\n\n  for (i = 0; sandbox_expose_ro != NULL && sandbox_expose_ro[i] != NULL; i++)\n    {\n      const char *expose = sandbox_expose_ro[i];\n      g_debug (\"exposing %s\", expose);\n      if (!is_valid_expose (expose, &error))\n        {\n          g_dbus_method_invocation_return_gerror (invocation, error);\n          return G_DBUS_METHOD_INVOCATION_HANDLED;\n        }\n    }\n\n  g_debug (\"Running spawn command %s\", arg_argv[0]);\n\n  n_fds = 0;\n  if (fds != NULL)\n    n_fds = g_variant_n_children (arg_fds);\n  fd_map = g_new0 (FdMapEntry, n_fds);\n\n  child_setup_data.fd_map = fd_map;\n  child_setup_data.fd_map_len = n_fds;\n\n  max_fd = -1;\n  for (i = 0; i < n_fds; i++)\n    {\n      gint32 handle, dest_fd;\n      int handle_fd;\n\n      g_variant_get_child (arg_fds, i, \"{uh}\", &dest_fd, &handle);\n\n      if (handle >= fds_len || handle < 0)\n        {\n          g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,\n                                                 G_DBUS_ERROR_INVALID_ARGS,\n                                                 \"No file descriptor for handle %d\",\n                                                 handle);\n          return G_DBUS_METHOD_INVOCATION_HANDLED;\n        }\n\n      handle_fd = fds[handle];\n\n      fd_map[i].to = dest_fd;\n      fd_map[i].from = handle_fd;\n      fd_map[i].final = fd_map[i].to;\n\n      /* If stdin/out/err is a tty we try to set it as the controlling\n         tty for the app, this way we can use this to run in a terminal. */\n      if ((dest_fd == 0 || dest_fd == 1 || dest_fd == 2) &&\n          !child_setup_data.set_tty &&\n          isatty (handle_fd))\n        {\n          child_setup_data.set_tty = TRUE;\n          child_setup_data.tty = handle_fd;\n        }\n\n      max_fd = MAX (max_fd, fd_map[i].to);\n      max_fd = MAX (max_fd, fd_map[i].from);\n    }\n\n  /* We make a second pass over the fds to find if any \"to\" fd index\n     overlaps an already in use fd (i.e. one in the \"from\" category\n     that are allocated randomly). If a fd overlaps \"to\" fd then its\n     a caller issue and not our fault, so we ignore that. */\n  for (i = 0; i < n_fds; i++)\n    {\n      int to_fd = fd_map[i].to;\n      gboolean conflict = FALSE;\n\n      /* At this point we're fine with using \"from\" values for this\n         value (because we handle to==from in the code), or values\n         that are before \"i\" in the fd_map (because those will be\n         closed at this point when dup:ing). However, we can't\n         reuse a fd that is in \"from\" for j > i. */\n      for (j = i + 1; j < n_fds; j++)\n        {\n          int from_fd = fd_map[j].from;\n          if (from_fd == to_fd)\n            {\n              conflict = TRUE;\n              break;\n            }\n        }\n\n      if (conflict)\n        fd_map[i].to = ++max_fd;\n    }\n\n  if (arg_flags & FLATPAK_SPAWN_FLAGS_CLEAR_ENV)\n    {\n      char *empty[] = { NULL };\n      env = g_strdupv (empty);\n    }\n  else\n    env = g_get_environ ();\n\n  n_envs = g_variant_n_children (arg_envs);\n  for (i = 0; i < n_envs; i++)\n    {\n      const char *var = NULL;\n      const char *val = NULL;\n      g_variant_get_child (arg_envs, i, \"{&s&s}\", &var, &val);\n\n      env = g_environ_setenv (env, var, val, TRUE);\n    }\n\n  g_ptr_array_add (flatpak_argv, g_strdup (\"flatpak\"));\n  g_ptr_array_add (flatpak_argv, g_strdup (\"run\"));\n\n  sandboxed = (arg_flags & FLATPAK_SPAWN_FLAGS_SANDBOX) != 0;\n\n  if (sandboxed)\n    {\n      g_ptr_array_add (flatpak_argv, g_strdup (\"--sandbox\"));\n\n      if (sandbox_flags & FLATPAK_SPAWN_SANDBOX_FLAGS_SHARE_DISPLAY)\n        {\n          if (sockets != NULL && g_strv_contains ((const char * const *) sockets, \"wayland\"))\n            g_ptr_array_add (flatpak_argv, g_strdup (\"--socket=wayland\"));\n          if (sockets != NULL && g_strv_contains ((const char * const *) sockets, \"fallback-x11\"))\n            g_ptr_array_add (flatpak_argv, g_strdup (\"--socket=fallback-x11\"));\n          if (sockets != NULL && g_strv_contains ((const char * const *) sockets, \"x11\"))\n            g_ptr_array_add (flatpak_argv, g_strdup (\"--socket=x11\"));\n          if (shares != NULL && g_strv_contains ((const char * const *) shares, \"ipc\") &&\n              sockets != NULL && (g_strv_contains ((const char * const *) sockets, \"fallback-x11\") ||\n                                  g_strv_contains ((const char * const *) sockets, \"x11\")))\n            g_ptr_array_add (flatpak_argv, g_strdup (\"--share=ipc\"));\n        }\n      if (sandbox_flags & FLATPAK_SPAWN_SANDBOX_FLAGS_SHARE_SOUND)\n        {\n          if (sockets != NULL && g_strv_contains ((const char * const *) sockets, \"pulseaudio\"))\n            g_ptr_array_add (flatpak_argv, g_strdup (\"--socket=pulseaudio\"));\n        }\n      if (sandbox_flags & FLATPAK_SPAWN_SANDBOX_FLAGS_SHARE_GPU)\n        {\n          if (devices != NULL &&\n              (g_strv_contains ((const char * const *) devices, \"dri\") ||\n               g_strv_contains ((const char * const *) devices, \"all\")))\n            g_ptr_array_add (flatpak_argv, g_strdup (\"--device=dri\"));\n        }\n      if (sandbox_flags & FLATPAK_SPAWN_SANDBOX_FLAGS_ALLOW_DBUS)\n        g_ptr_array_add (flatpak_argv, g_strdup (\"--session-bus\"));\n      if (sandbox_flags & FLATPAK_SPAWN_SANDBOX_FLAGS_ALLOW_A11Y)\n        g_ptr_array_add (flatpak_argv, g_strdup (\"--a11y-bus\"));\n    }\n  else\n    {\n      for (i = 0; extra_args != NULL && extra_args[i] != NULL; i++)\n        {\n          if (g_str_has_prefix (extra_args[i], \"--env=\"))\n            {\n              const char *var_val = extra_args[i] + strlen (\"--env=\");\n\n              if (var_val[0] == '\\0' || var_val[0] == '=')\n                {\n                  g_warning (\"Environment variable in extra-args has empty name\");\n                  continue;\n                }\n\n              if (strchr (var_val, '=') == NULL)\n                {\n                  g_warning (\"Environment variable in extra-args has no value\");\n                  continue;\n                }\n\n              g_string_append (env_string, var_val);\n              g_string_append_c (env_string, '\\0');\n            }\n          else\n            {\n              g_ptr_array_add (flatpak_argv, g_strdup (extra_args[i]));\n            }\n        }\n    }\n\n  if (env_string->len > 0)\n    {\n      g_auto(GLnxTmpfile) env_tmpf  = { 0, };\n\n      if (!flatpak_buffer_to_sealed_memfd_or_tmpfile (&env_tmpf, \"environ\",\n                                                      env_string->str,\n                                                      env_string->len, &error))\n        {\n          g_dbus_method_invocation_return_gerror (invocation, error);\n          return G_DBUS_METHOD_INVOCATION_HANDLED;\n        }\n\n      child_setup_data.env_fd = glnx_steal_fd (&env_tmpf.fd);\n      g_ptr_array_add (flatpak_argv,\n                       g_strdup_printf (\"--env-fd=%d\",\n                                        child_setup_data.env_fd));\n    }\n\n  expose_pids = (arg_flags & FLATPAK_SPAWN_FLAGS_EXPOSE_PIDS) != 0;\n  share_pids = (arg_flags & FLATPAK_SPAWN_FLAGS_SHARE_PIDS) != 0;\n\n  if (expose_pids || share_pids)\n    {\n      g_autofree char *instance_id = NULL;\n      int sender_pid1 = 0;\n\n      if (!(supports & FLATPAK_SPAWN_SUPPORT_FLAGS_EXPOSE_PIDS))\n        {\n          g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,\n                                                 G_DBUS_ERROR_NOT_SUPPORTED,\n                                                 \"Expose pids not supported with setuid bwrap\");\n          return G_DBUS_METHOD_INVOCATION_HANDLED;\n        }\n\n      instance_id = g_key_file_get_string (app_info,\n                                           FLATPAK_METADATA_GROUP_INSTANCE,\n                                           FLATPAK_METADATA_KEY_INSTANCE_ID, NULL);\n\n      if (instance_id)\n        {\n          g_autoptr(FlatpakInstance) instance = flatpak_instance_new_for_id (instance_id);\n          sender_pid1 = flatpak_instance_get_child_pid (instance);\n        }\n\n      if (sender_pid1 == 0)\n        {\n          g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,\n                                                 G_DBUS_ERROR_INVALID_ARGS,\n                                                 \"Could not find requesting pid\");\n          return G_DBUS_METHOD_INVOCATION_HANDLED;\n        }\n\n      g_ptr_array_add (flatpak_argv, g_strdup_printf (\"--parent-pid=%d\", sender_pid1));\n\n      if (share_pids)\n        g_ptr_array_add (flatpak_argv, g_strdup (\"--parent-share-pids\"));\n      else\n        g_ptr_array_add (flatpak_argv, g_strdup (\"--parent-expose-pids\"));\n    }\n\n  notify_start = (arg_flags & FLATPAK_SPAWN_FLAGS_NOTIFY_START) != 0;\n  if (notify_start)\n    {\n      int pipe_fds[2];\n      if (pipe (pipe_fds) == -1)\n        {\n          int errsv = errno;\n          g_dbus_method_invocation_return_error (invocation, G_IO_ERROR,\n                                                 g_io_error_from_errno (errsv),\n                                                 \"Failed to create instance ID pipe: %s\",\n                                                 g_strerror (errsv));\n          return G_DBUS_METHOD_INVOCATION_HANDLED;\n        }\n\n      GInputStream *in_stream = G_INPUT_STREAM (g_unix_input_stream_new (pipe_fds[0], TRUE));\n      /* This is saved to ensure the portal's end gets closed after the exec. */\n      instance_id_out_stream = G_OUTPUT_STREAM (g_unix_output_stream_new (pipe_fds[1], TRUE));\n\n      instance_id_read_data = g_new0 (InstanceIdReadData, 1);\n\n      g_input_stream_read_async (in_stream, instance_id_read_data->buffer,\n                                 INSTANCE_ID_BUFFER_SIZE - 1, G_PRIORITY_DEFAULT, NULL,\n                                 instance_id_read_finish, instance_id_read_data);\n\n      g_ptr_array_add (flatpak_argv, g_strdup_printf (\"--instance-id-fd=%d\", pipe_fds[1]));\n      child_setup_data.instance_id_fd = pipe_fds[1];\n    }\n\n  if (devel)\n    g_ptr_array_add (flatpak_argv, g_strdup (\"--devel\"));\n\n  /* Inherit launcher network access from launcher, unless\n     NO_NETWORK set. */\n  if (shares != NULL && g_strv_contains ((const char * const *) shares, \"network\") &&\n      !(arg_flags & FLATPAK_SPAWN_FLAGS_NO_NETWORK))\n    g_ptr_array_add (flatpak_argv, g_strdup (\"--share=network\"));\n  else\n    g_ptr_array_add (flatpak_argv, g_strdup (\"--unshare=network\"));\n\n\n  if (instance_path)\n    {\n      for (i = 0; sandbox_expose != NULL && sandbox_expose[i] != NULL; i++)\n        g_ptr_array_add (flatpak_argv,\n                         filesystem_sandbox_arg (instance_path, sandbox_expose[i], FALSE));\n      for (i = 0; sandbox_expose_ro != NULL && sandbox_expose_ro[i] != NULL; i++)\n        g_ptr_array_add (flatpak_argv,\n                         filesystem_sandbox_arg (instance_path, sandbox_expose_ro[i], TRUE));\n    }\n\n  for (i = 0; sandbox_expose_ro != NULL && sandbox_expose_ro[i] != NULL; i++)\n    {\n      const char *expose = sandbox_expose_ro[i];\n      g_debug (\"exposing %s\", expose);\n    }\n\n  if (sandbox_expose_fd != NULL)\n    {\n      gsize len = g_variant_n_children (sandbox_expose_fd);\n      for (i = 0; i < len; i++)\n        {\n          gint32 handle;\n          g_variant_get_child (sandbox_expose_fd, i, \"h\", &handle);\n          if (handle >= 0 && handle < fds_len)\n            {\n              int handle_fd = fds[handle];\n              g_autofree char *path = NULL;\n              gboolean writable = FALSE;\n\n              path = get_path_for_fd (handle_fd, &writable, &error);\n\n              if (path)\n                {\n                  g_ptr_array_add (flatpak_argv, filesystem_arg (path, !writable));\n                }\n              else\n                {\n                  g_debug (\"unable to get path for sandbox-exposed fd %d, ignoring: %s\",\n                           handle_fd, error->message);\n                  g_clear_error (&error);\n                }\n            }\n          else\n            {\n              g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,\n                                                     G_DBUS_ERROR_INVALID_ARGS,\n                                                     \"No file descriptor for handle %d\",\n                                                     handle);\n              return G_DBUS_METHOD_INVOCATION_HANDLED;\n            }\n        }\n    }\n\n  if (sandbox_expose_fd_ro != NULL)\n    {\n      gsize len = g_variant_n_children (sandbox_expose_fd_ro);\n      for (i = 0; i < len; i++)\n        {\n          gint32 handle;\n          g_variant_get_child (sandbox_expose_fd_ro, i, \"h\", &handle);\n          if (handle >= 0 && handle < fds_len)\n            {\n              int handle_fd = fds[handle];\n              g_autofree char *path = NULL;\n              gboolean writable = FALSE;\n\n              path = get_path_for_fd (handle_fd, &writable, &error);\n\n              if (path)\n                {\n                  g_ptr_array_add (flatpak_argv, filesystem_arg (path, TRUE));\n                }\n              else\n                {\n                  g_debug (\"unable to get path for sandbox-exposed fd %d, ignoring: %s\",\n                           handle_fd, error->message);\n                  g_clear_error (&error);\n                }\n            }\n          else\n            {\n              g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR,\n                                                     G_DBUS_ERROR_INVALID_ARGS,\n                                                     \"No file descriptor for handle %d\",\n                                                     handle);\n              return G_DBUS_METHOD_INVOCATION_HANDLED;\n            }\n        }\n    }\n\n  g_ptr_array_add (flatpak_argv, g_strdup_printf (\"--runtime=%s\", runtime_parts[1]));\n  g_ptr_array_add (flatpak_argv, g_strdup_printf (\"--runtime-version=%s\", runtime_parts[3]));\n\n  if ((arg_flags & FLATPAK_SPAWN_FLAGS_LATEST_VERSION) == 0)\n    {\n      if (app_commit)\n        g_ptr_array_add (flatpak_argv, g_strdup_printf (\"--commit=%s\", app_commit));\n      if (runtime_commit)\n        g_ptr_array_add (flatpak_argv, g_strdup_printf (\"--runtime-commit=%s\", runtime_commit));\n    }\n\n  if (arg_cwd_path != NULL)\n    g_ptr_array_add (flatpak_argv, g_strdup_printf (\"--cwd=%s\", arg_cwd_path));\n\n  if (arg_argv[0][0] != 0)\n    g_ptr_array_add (flatpak_argv, g_strdup_printf (\"--command=%s\", arg_argv[0]));\n\n  g_ptr_array_add (flatpak_argv, g_strdup_printf (\"%s/%s/%s\", app_id, arch ? arch : \"\", branch ? branch : \"\"));\n  for (i = 1; arg_argv[i] != NULL; i++)\n    g_ptr_array_add (flatpak_argv, g_strdup (arg_argv[i]));\n  g_ptr_array_add (flatpak_argv, NULL);\n\n  if (opt_verbose)\n    {\n      g_autoptr(GString) cmd = g_string_new (\"\");\n\n      for (i = 0; flatpak_argv->pdata[i] != NULL; i++)\n        {\n          if (i > 0)\n            g_string_append (cmd, \" \");\n          g_string_append (cmd, flatpak_argv->pdata[i]);\n        }\n\n      g_debug (\"Starting: %s\\n\", cmd->str);\n    }\n\n  /* We use LEAVE_DESCRIPTORS_OPEN to work around dead-lock, see flatpak_close_fds_workaround */\n  if (!g_spawn_async_with_pipes (NULL,\n                                 (char **) flatpak_argv->pdata,\n                                 env,\n                                 G_SPAWN_SEARCH_PATH | G_SPAWN_DO_NOT_REAP_CHILD | G_SPAWN_LEAVE_DESCRIPTORS_OPEN,\n                                 child_setup_func, &child_setup_data,\n                                 &pid,\n                                 NULL,\n                                 NULL,\n                                 NULL,\n                                 &error))\n    {\n      gint code = G_DBUS_ERROR_FAILED;\n      if (g_error_matches (error, G_SPAWN_ERROR, G_SPAWN_ERROR_ACCES))\n        code = G_DBUS_ERROR_ACCESS_DENIED;\n      else if (g_error_matches (error, G_SPAWN_ERROR, G_SPAWN_ERROR_NOENT))\n        code = G_DBUS_ERROR_FILE_NOT_FOUND;\n      g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, code,\n                                             \"Failed to start command: %s\",\n                                             error->message);\n      return G_DBUS_METHOD_INVOCATION_HANDLED;\n    }\n\n  if (instance_id_read_data)\n    instance_id_read_data->pid = pid;\n\n  pid_data = g_new0 (PidData, 1);\n  pid_data->pid = pid;\n  pid_data->client = g_strdup (g_dbus_method_invocation_get_sender (invocation));\n  pid_data->watch_bus = (arg_flags & FLATPAK_SPAWN_FLAGS_WATCH_BUS) != 0;\n  pid_data->expose_or_share_pids = (expose_pids || share_pids);\n  pid_data->child_watch = g_child_watch_add_full (G_PRIORITY_DEFAULT,\n                                                  pid,\n                                                  child_watch_died,\n                                                  pid_data,\n                                                  NULL);\n\n  g_debug (\"Client Pid is %d\", pid_data->pid);\n\n  g_hash_table_replace (client_pid_data_hash, GUINT_TO_POINTER (pid_data->pid),\n                        pid_data);\n\n  portal_flatpak_complete_spawn (object, invocation, NULL, pid);\n  return G_DBUS_METHOD_INVOCATION_HANDLED;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -45,8 +45,10 @@\n   gboolean share_pids;\n   gboolean notify_start;\n   gboolean devel;\n+  g_autoptr(GString) env_string = g_string_new (\"\");\n \n   child_setup_data.instance_id_fd = -1;\n+  child_setup_data.env_fd = -1;\n \n   if (fd_list != NULL)\n     fds = g_unix_fd_list_peek_fds (fd_list, &fds_len);\n@@ -307,7 +309,49 @@\n   else\n     {\n       for (i = 0; extra_args != NULL && extra_args[i] != NULL; i++)\n-        g_ptr_array_add (flatpak_argv, g_strdup (extra_args[i]));\n+        {\n+          if (g_str_has_prefix (extra_args[i], \"--env=\"))\n+            {\n+              const char *var_val = extra_args[i] + strlen (\"--env=\");\n+\n+              if (var_val[0] == '\\0' || var_val[0] == '=')\n+                {\n+                  g_warning (\"Environment variable in extra-args has empty name\");\n+                  continue;\n+                }\n+\n+              if (strchr (var_val, '=') == NULL)\n+                {\n+                  g_warning (\"Environment variable in extra-args has no value\");\n+                  continue;\n+                }\n+\n+              g_string_append (env_string, var_val);\n+              g_string_append_c (env_string, '\\0');\n+            }\n+          else\n+            {\n+              g_ptr_array_add (flatpak_argv, g_strdup (extra_args[i]));\n+            }\n+        }\n+    }\n+\n+  if (env_string->len > 0)\n+    {\n+      g_auto(GLnxTmpfile) env_tmpf  = { 0, };\n+\n+      if (!flatpak_buffer_to_sealed_memfd_or_tmpfile (&env_tmpf, \"environ\",\n+                                                      env_string->str,\n+                                                      env_string->len, &error))\n+        {\n+          g_dbus_method_invocation_return_gerror (invocation, error);\n+          return G_DBUS_METHOD_INVOCATION_HANDLED;\n+        }\n+\n+      child_setup_data.env_fd = glnx_steal_fd (&env_tmpf.fd);\n+      g_ptr_array_add (flatpak_argv,\n+                       g_strdup_printf (\"--env-fd=%d\",\n+                                        child_setup_data.env_fd));\n     }\n \n   expose_pids = (arg_flags & FLATPAK_SPAWN_FLAGS_EXPOSE_PIDS) != 0;",
        "diff_line_info": {
            "deleted_lines": [
                "        g_ptr_array_add (flatpak_argv, g_strdup (extra_args[i]));"
            ],
            "added_lines": [
                "  g_autoptr(GString) env_string = g_string_new (\"\");",
                "  child_setup_data.env_fd = -1;",
                "        {",
                "          if (g_str_has_prefix (extra_args[i], \"--env=\"))",
                "            {",
                "              const char *var_val = extra_args[i] + strlen (\"--env=\");",
                "",
                "              if (var_val[0] == '\\0' || var_val[0] == '=')",
                "                {",
                "                  g_warning (\"Environment variable in extra-args has empty name\");",
                "                  continue;",
                "                }",
                "",
                "              if (strchr (var_val, '=') == NULL)",
                "                {",
                "                  g_warning (\"Environment variable in extra-args has no value\");",
                "                  continue;",
                "                }",
                "",
                "              g_string_append (env_string, var_val);",
                "              g_string_append_c (env_string, '\\0');",
                "            }",
                "          else",
                "            {",
                "              g_ptr_array_add (flatpak_argv, g_strdup (extra_args[i]));",
                "            }",
                "        }",
                "    }",
                "",
                "  if (env_string->len > 0)",
                "    {",
                "      g_auto(GLnxTmpfile) env_tmpf  = { 0, };",
                "",
                "      if (!flatpak_buffer_to_sealed_memfd_or_tmpfile (&env_tmpf, \"environ\",",
                "                                                      env_string->str,",
                "                                                      env_string->len, &error))",
                "        {",
                "          g_dbus_method_invocation_return_gerror (invocation, error);",
                "          return G_DBUS_METHOD_INVOCATION_HANDLED;",
                "        }",
                "",
                "      child_setup_data.env_fd = glnx_steal_fd (&env_tmpf.fd);",
                "      g_ptr_array_add (flatpak_argv,",
                "                       g_strdup_printf (\"--env-fd=%d\",",
                "                                        child_setup_data.env_fd));"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-21261",
        "func_name": "flatpak/flatpak_run_add_environment_args",
        "description": "Flatpak is a system for building, distributing, and running sandboxed desktop applications on Linux. A bug was discovered in the `flatpak-portal` service that can allow sandboxed applications to execute arbitrary code on the host system (a sandbox escape). This sandbox-escape bug is present in versions from 0.11.4 and before fixed versions 1.8.5 and 1.10.0. The Flatpak portal D-Bus service (`flatpak-portal`, also known by its D-Bus service name `org.freedesktop.portal.Flatpak`) allows apps in a Flatpak sandbox to launch their own subprocesses in a new sandbox instance, either with the same security settings as the caller or with more restrictive security settings. For example, this is used in Flatpak-packaged web browsers such as Chromium to launch subprocesses that will process untrusted web content, and give those subprocesses a more restrictive sandbox than the browser itself. In vulnerable versions, the Flatpak portal service passes caller-specified environment variables to non-sandboxed processes on the host system, and in particular to the `flatpak run` command that is used to launch the new sandbox instance. A malicious or compromised Flatpak app could set environment variables that are trusted by the `flatpak run` command, and use them to execute arbitrary code that is not in a sandbox. As a workaround, this vulnerability can be mitigated by preventing the `flatpak-portal` service from starting, but that mitigation will prevent many Flatpak apps from working correctly. This is fixed in versions 1.8.5 and 1.10.0.",
        "git_url": "https://github.com/flatpak/flatpak/commit/6d1773d2a54dde9b099043f07a2094a4f1c2f486",
        "commit_title": "run: Convert all environment variables into bwrap arguments",
        "commit_text": " This avoids some of them being filtered out by a setuid bwrap. It also means that if they came from an untrusted source, they cannot be used to inject arbitrary code into a non-setuid bwrap via mechanisms like LD_PRELOAD.  Because they get bundled into a memfd or temporary file, they do not actually appear in argv, ensuring that they remain inaccessible to processes running under a different uid (which is important if their values are tokens or other secrets).  Part-of: https://github.com/flatpak/flatpak/security/advisories/GHSA-4ppf-fxf6-vxg2",
        "func_before": "gboolean\nflatpak_run_add_environment_args (FlatpakBwrap    *bwrap,\n                                  const char      *app_info_path,\n                                  FlatpakRunFlags  flags,\n                                  const char      *app_id,\n                                  FlatpakContext  *context,\n                                  GFile           *app_id_dir,\n                                  GPtrArray       *previous_app_id_dirs,\n                                  FlatpakExports **exports_out,\n                                  GCancellable    *cancellable,\n                                  GError         **error)\n{\n  g_autoptr(GError) my_error = NULL;\n  g_autoptr(FlatpakExports) exports = NULL;\n  g_autoptr(FlatpakBwrap) proxy_arg_bwrap = flatpak_bwrap_new (flatpak_bwrap_empty_env);\n  gboolean has_wayland = FALSE;\n  gboolean allow_x11 = FALSE;\n\n  if ((context->shares & FLATPAK_CONTEXT_SHARED_IPC) == 0)\n    {\n      g_debug (\"Disallowing ipc access\");\n      flatpak_bwrap_add_args (bwrap, \"--unshare-ipc\", NULL);\n    }\n\n  if ((context->shares & FLATPAK_CONTEXT_SHARED_NETWORK) == 0)\n    {\n      g_debug (\"Disallowing network access\");\n      flatpak_bwrap_add_args (bwrap, \"--unshare-net\", NULL);\n    }\n\n  if (context->devices & FLATPAK_CONTEXT_DEVICE_ALL)\n    {\n      flatpak_bwrap_add_args (bwrap,\n                              \"--dev-bind\", \"/dev\", \"/dev\",\n                              NULL);\n      /* Don't expose the host /dev/shm, just the device nodes, unless explicitly allowed */\n      if (g_file_test (\"/dev/shm\", G_FILE_TEST_IS_DIR))\n        {\n          if ((context->devices & FLATPAK_CONTEXT_DEVICE_SHM) == 0)\n            flatpak_bwrap_add_args (bwrap,\n                                    \"--tmpfs\", \"/dev/shm\",\n                                    NULL);\n        }\n      else if (g_file_test (\"/dev/shm\", G_FILE_TEST_IS_SYMLINK))\n        {\n          g_autofree char *link = flatpak_readlink (\"/dev/shm\", NULL);\n\n          /* On debian (with sysv init) the host /dev/shm is a symlink to /run/shm, so we can't\n             mount on top of it. */\n          if (g_strcmp0 (link, \"/run/shm\") == 0)\n            {\n              if (context->devices & FLATPAK_CONTEXT_DEVICE_SHM &&\n                  g_file_test (\"/run/shm\", G_FILE_TEST_IS_DIR))\n                flatpak_bwrap_add_args (bwrap,\n                                        \"--bind\", \"/run/shm\", \"/run/shm\",\n                                        NULL);\n              else\n                flatpak_bwrap_add_args (bwrap,\n                                        \"--dir\", \"/run/shm\",\n                                        NULL);\n            }\n          else\n            g_warning (\"Unexpected /dev/shm symlink %s\", link);\n        }\n    }\n  else\n    {\n      flatpak_bwrap_add_args (bwrap,\n                              \"--dev\", \"/dev\",\n                              NULL);\n      if (context->devices & FLATPAK_CONTEXT_DEVICE_DRI)\n        {\n          g_debug (\"Allowing dri access\");\n          int i;\n          char *dri_devices[] = {\n            \"/dev/dri\",\n            /* mali */\n            \"/dev/mali\",\n            \"/dev/mali0\",\n            \"/dev/umplock\",\n            /* nvidia */\n            \"/dev/nvidiactl\",\n            \"/dev/nvidia-modeset\",\n            /* nvidia OpenCL/CUDA */\n            \"/dev/nvidia-uvm\",\n            \"/dev/nvidia-uvm-tools\",\n          };\n\n          for (i = 0; i < G_N_ELEMENTS (dri_devices); i++)\n            {\n              if (g_file_test (dri_devices[i], G_FILE_TEST_EXISTS))\n                flatpak_bwrap_add_args (bwrap, \"--dev-bind\", dri_devices[i], dri_devices[i], NULL);\n            }\n\n          /* Each Nvidia card gets its own device.\n             This is a fairly arbitrary limit but ASUS sells mining boards supporting 20 in theory. */\n          char nvidia_dev[14]; /* /dev/nvidia plus up to 2 digits */\n          for (i = 0; i < 20; i++)\n            {\n              g_snprintf (nvidia_dev, sizeof (nvidia_dev), \"/dev/nvidia%d\", i);\n              if (g_file_test (nvidia_dev, G_FILE_TEST_EXISTS))\n                flatpak_bwrap_add_args (bwrap, \"--dev-bind\", nvidia_dev, nvidia_dev, NULL);\n            }\n        }\n\n      if (context->devices & FLATPAK_CONTEXT_DEVICE_KVM)\n        {\n          g_debug (\"Allowing kvm access\");\n          if (g_file_test (\"/dev/kvm\", G_FILE_TEST_EXISTS))\n            flatpak_bwrap_add_args (bwrap, \"--dev-bind\", \"/dev/kvm\", \"/dev/kvm\", NULL);\n        }\n\n      if (context->devices & FLATPAK_CONTEXT_DEVICE_SHM)\n        {\n          /* This is a symlink to /run/shm on debian, so bind to real target */\n          g_autofree char *real_dev_shm = realpath (\"/dev/shm\", NULL);\n\n          g_debug (\"Allowing /dev/shm access (as %s)\", real_dev_shm);\n          if (real_dev_shm != NULL)\n              flatpak_bwrap_add_args (bwrap, \"--bind\", real_dev_shm, \"/dev/shm\", NULL);\n        }\n    }\n\n  flatpak_context_append_bwrap_filesystem (context, bwrap, app_id, app_id_dir, previous_app_id_dirs, &exports);\n\n  if (context->sockets & FLATPAK_CONTEXT_SOCKET_WAYLAND)\n    {\n      g_debug (\"Allowing wayland access\");\n      has_wayland = flatpak_run_add_wayland_args (bwrap);\n    }\n\n  if ((context->sockets & FLATPAK_CONTEXT_SOCKET_FALLBACK_X11) != 0)\n    allow_x11 = !has_wayland;\n  else\n    allow_x11 = (context->sockets & FLATPAK_CONTEXT_SOCKET_X11) != 0;\n\n  flatpak_run_add_x11_args (bwrap, allow_x11);\n\n  if (context->sockets & FLATPAK_CONTEXT_SOCKET_SSH_AUTH)\n    {\n      flatpak_run_add_ssh_args (bwrap);\n    }\n\n  if (context->sockets & FLATPAK_CONTEXT_SOCKET_PULSEAUDIO)\n    {\n      g_debug (\"Allowing pulseaudio access\");\n      flatpak_run_add_pulseaudio_args (bwrap);\n    }\n\n  if (context->sockets & FLATPAK_CONTEXT_SOCKET_PCSC)\n    {\n      flatpak_run_add_pcsc_args (bwrap);\n    }\n\n  if (context->sockets & FLATPAK_CONTEXT_SOCKET_CUPS)\n    {\n      flatpak_run_add_cups_args (bwrap);\n    }\n\n  flatpak_run_add_session_dbus_args (bwrap, proxy_arg_bwrap, context, flags, app_id);\n  flatpak_run_add_system_dbus_args (bwrap, proxy_arg_bwrap, context, flags);\n  flatpak_run_add_a11y_dbus_args (bwrap, proxy_arg_bwrap, context, flags);\n\n  if (g_environ_getenv (bwrap->envp, \"LD_LIBRARY_PATH\") != NULL)\n    {\n      /* LD_LIBRARY_PATH is overridden for setuid helper, so pass it as cmdline arg */\n      flatpak_bwrap_add_args (bwrap,\n                              \"--setenv\", \"LD_LIBRARY_PATH\", g_environ_getenv (bwrap->envp, \"LD_LIBRARY_PATH\"),\n                              NULL);\n      flatpak_bwrap_unset_env (bwrap, \"LD_LIBRARY_PATH\");\n    }\n\n  if (g_environ_getenv (bwrap->envp, \"TMPDIR\") != NULL)\n    {\n      /* TMPDIR is overridden for setuid helper, so pass it as cmdline arg */\n      flatpak_bwrap_add_args (bwrap,\n                              \"--setenv\", \"TMPDIR\", g_environ_getenv (bwrap->envp, \"TMPDIR\"),\n                              NULL);\n      flatpak_bwrap_unset_env (bwrap, \"TMPDIR\");\n    }\n\n  /* Must run this before spawning the dbus proxy, to ensure it\n     ends up in the app cgroup */\n  if (!flatpak_run_in_transient_unit (app_id, &my_error))\n    {\n      /* We still run along even if we don't get a cgroup, as nothing\n         really depends on it. Its just nice to have */\n      g_debug (\"Failed to run in transient scope: %s\", my_error->message);\n      g_clear_error (&my_error);\n    }\n\n  if (!flatpak_bwrap_is_empty (proxy_arg_bwrap) &&\n      !start_dbus_proxy (bwrap, proxy_arg_bwrap, app_info_path, error))\n    return FALSE;\n\n  if (exports_out)\n    *exports_out = g_steal_pointer (&exports);\n\n  return TRUE;\n}",
        "func": "gboolean\nflatpak_run_add_environment_args (FlatpakBwrap    *bwrap,\n                                  const char      *app_info_path,\n                                  FlatpakRunFlags  flags,\n                                  const char      *app_id,\n                                  FlatpakContext  *context,\n                                  GFile           *app_id_dir,\n                                  GPtrArray       *previous_app_id_dirs,\n                                  FlatpakExports **exports_out,\n                                  GCancellable    *cancellable,\n                                  GError         **error)\n{\n  g_autoptr(GError) my_error = NULL;\n  g_autoptr(FlatpakExports) exports = NULL;\n  g_autoptr(FlatpakBwrap) proxy_arg_bwrap = flatpak_bwrap_new (flatpak_bwrap_empty_env);\n  gboolean has_wayland = FALSE;\n  gboolean allow_x11 = FALSE;\n\n  if ((context->shares & FLATPAK_CONTEXT_SHARED_IPC) == 0)\n    {\n      g_debug (\"Disallowing ipc access\");\n      flatpak_bwrap_add_args (bwrap, \"--unshare-ipc\", NULL);\n    }\n\n  if ((context->shares & FLATPAK_CONTEXT_SHARED_NETWORK) == 0)\n    {\n      g_debug (\"Disallowing network access\");\n      flatpak_bwrap_add_args (bwrap, \"--unshare-net\", NULL);\n    }\n\n  if (context->devices & FLATPAK_CONTEXT_DEVICE_ALL)\n    {\n      flatpak_bwrap_add_args (bwrap,\n                              \"--dev-bind\", \"/dev\", \"/dev\",\n                              NULL);\n      /* Don't expose the host /dev/shm, just the device nodes, unless explicitly allowed */\n      if (g_file_test (\"/dev/shm\", G_FILE_TEST_IS_DIR))\n        {\n          if ((context->devices & FLATPAK_CONTEXT_DEVICE_SHM) == 0)\n            flatpak_bwrap_add_args (bwrap,\n                                    \"--tmpfs\", \"/dev/shm\",\n                                    NULL);\n        }\n      else if (g_file_test (\"/dev/shm\", G_FILE_TEST_IS_SYMLINK))\n        {\n          g_autofree char *link = flatpak_readlink (\"/dev/shm\", NULL);\n\n          /* On debian (with sysv init) the host /dev/shm is a symlink to /run/shm, so we can't\n             mount on top of it. */\n          if (g_strcmp0 (link, \"/run/shm\") == 0)\n            {\n              if (context->devices & FLATPAK_CONTEXT_DEVICE_SHM &&\n                  g_file_test (\"/run/shm\", G_FILE_TEST_IS_DIR))\n                flatpak_bwrap_add_args (bwrap,\n                                        \"--bind\", \"/run/shm\", \"/run/shm\",\n                                        NULL);\n              else\n                flatpak_bwrap_add_args (bwrap,\n                                        \"--dir\", \"/run/shm\",\n                                        NULL);\n            }\n          else\n            g_warning (\"Unexpected /dev/shm symlink %s\", link);\n        }\n    }\n  else\n    {\n      flatpak_bwrap_add_args (bwrap,\n                              \"--dev\", \"/dev\",\n                              NULL);\n      if (context->devices & FLATPAK_CONTEXT_DEVICE_DRI)\n        {\n          g_debug (\"Allowing dri access\");\n          int i;\n          char *dri_devices[] = {\n            \"/dev/dri\",\n            /* mali */\n            \"/dev/mali\",\n            \"/dev/mali0\",\n            \"/dev/umplock\",\n            /* nvidia */\n            \"/dev/nvidiactl\",\n            \"/dev/nvidia-modeset\",\n            /* nvidia OpenCL/CUDA */\n            \"/dev/nvidia-uvm\",\n            \"/dev/nvidia-uvm-tools\",\n          };\n\n          for (i = 0; i < G_N_ELEMENTS (dri_devices); i++)\n            {\n              if (g_file_test (dri_devices[i], G_FILE_TEST_EXISTS))\n                flatpak_bwrap_add_args (bwrap, \"--dev-bind\", dri_devices[i], dri_devices[i], NULL);\n            }\n\n          /* Each Nvidia card gets its own device.\n             This is a fairly arbitrary limit but ASUS sells mining boards supporting 20 in theory. */\n          char nvidia_dev[14]; /* /dev/nvidia plus up to 2 digits */\n          for (i = 0; i < 20; i++)\n            {\n              g_snprintf (nvidia_dev, sizeof (nvidia_dev), \"/dev/nvidia%d\", i);\n              if (g_file_test (nvidia_dev, G_FILE_TEST_EXISTS))\n                flatpak_bwrap_add_args (bwrap, \"--dev-bind\", nvidia_dev, nvidia_dev, NULL);\n            }\n        }\n\n      if (context->devices & FLATPAK_CONTEXT_DEVICE_KVM)\n        {\n          g_debug (\"Allowing kvm access\");\n          if (g_file_test (\"/dev/kvm\", G_FILE_TEST_EXISTS))\n            flatpak_bwrap_add_args (bwrap, \"--dev-bind\", \"/dev/kvm\", \"/dev/kvm\", NULL);\n        }\n\n      if (context->devices & FLATPAK_CONTEXT_DEVICE_SHM)\n        {\n          /* This is a symlink to /run/shm on debian, so bind to real target */\n          g_autofree char *real_dev_shm = realpath (\"/dev/shm\", NULL);\n\n          g_debug (\"Allowing /dev/shm access (as %s)\", real_dev_shm);\n          if (real_dev_shm != NULL)\n              flatpak_bwrap_add_args (bwrap, \"--bind\", real_dev_shm, \"/dev/shm\", NULL);\n        }\n    }\n\n  flatpak_context_append_bwrap_filesystem (context, bwrap, app_id, app_id_dir, previous_app_id_dirs, &exports);\n\n  if (context->sockets & FLATPAK_CONTEXT_SOCKET_WAYLAND)\n    {\n      g_debug (\"Allowing wayland access\");\n      has_wayland = flatpak_run_add_wayland_args (bwrap);\n    }\n\n  if ((context->sockets & FLATPAK_CONTEXT_SOCKET_FALLBACK_X11) != 0)\n    allow_x11 = !has_wayland;\n  else\n    allow_x11 = (context->sockets & FLATPAK_CONTEXT_SOCKET_X11) != 0;\n\n  flatpak_run_add_x11_args (bwrap, allow_x11);\n\n  if (context->sockets & FLATPAK_CONTEXT_SOCKET_SSH_AUTH)\n    {\n      flatpak_run_add_ssh_args (bwrap);\n    }\n\n  if (context->sockets & FLATPAK_CONTEXT_SOCKET_PULSEAUDIO)\n    {\n      g_debug (\"Allowing pulseaudio access\");\n      flatpak_run_add_pulseaudio_args (bwrap);\n    }\n\n  if (context->sockets & FLATPAK_CONTEXT_SOCKET_PCSC)\n    {\n      flatpak_run_add_pcsc_args (bwrap);\n    }\n\n  if (context->sockets & FLATPAK_CONTEXT_SOCKET_CUPS)\n    {\n      flatpak_run_add_cups_args (bwrap);\n    }\n\n  flatpak_run_add_session_dbus_args (bwrap, proxy_arg_bwrap, context, flags, app_id);\n  flatpak_run_add_system_dbus_args (bwrap, proxy_arg_bwrap, context, flags);\n  flatpak_run_add_a11y_dbus_args (bwrap, proxy_arg_bwrap, context, flags);\n\n  /* Must run this before spawning the dbus proxy, to ensure it\n     ends up in the app cgroup */\n  if (!flatpak_run_in_transient_unit (app_id, &my_error))\n    {\n      /* We still run along even if we don't get a cgroup, as nothing\n         really depends on it. Its just nice to have */\n      g_debug (\"Failed to run in transient scope: %s\", my_error->message);\n      g_clear_error (&my_error);\n    }\n\n  if (!flatpak_bwrap_is_empty (proxy_arg_bwrap) &&\n      !start_dbus_proxy (bwrap, proxy_arg_bwrap, app_info_path, error))\n    return FALSE;\n\n  if (exports_out)\n    *exports_out = g_steal_pointer (&exports);\n\n  return TRUE;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -161,24 +161,6 @@\n   flatpak_run_add_system_dbus_args (bwrap, proxy_arg_bwrap, context, flags);\n   flatpak_run_add_a11y_dbus_args (bwrap, proxy_arg_bwrap, context, flags);\n \n-  if (g_environ_getenv (bwrap->envp, \"LD_LIBRARY_PATH\") != NULL)\n-    {\n-      /* LD_LIBRARY_PATH is overridden for setuid helper, so pass it as cmdline arg */\n-      flatpak_bwrap_add_args (bwrap,\n-                              \"--setenv\", \"LD_LIBRARY_PATH\", g_environ_getenv (bwrap->envp, \"LD_LIBRARY_PATH\"),\n-                              NULL);\n-      flatpak_bwrap_unset_env (bwrap, \"LD_LIBRARY_PATH\");\n-    }\n-\n-  if (g_environ_getenv (bwrap->envp, \"TMPDIR\") != NULL)\n-    {\n-      /* TMPDIR is overridden for setuid helper, so pass it as cmdline arg */\n-      flatpak_bwrap_add_args (bwrap,\n-                              \"--setenv\", \"TMPDIR\", g_environ_getenv (bwrap->envp, \"TMPDIR\"),\n-                              NULL);\n-      flatpak_bwrap_unset_env (bwrap, \"TMPDIR\");\n-    }\n-\n   /* Must run this before spawning the dbus proxy, to ensure it\n      ends up in the app cgroup */\n   if (!flatpak_run_in_transient_unit (app_id, &my_error))",
        "diff_line_info": {
            "deleted_lines": [
                "  if (g_environ_getenv (bwrap->envp, \"LD_LIBRARY_PATH\") != NULL)",
                "    {",
                "      /* LD_LIBRARY_PATH is overridden for setuid helper, so pass it as cmdline arg */",
                "      flatpak_bwrap_add_args (bwrap,",
                "                              \"--setenv\", \"LD_LIBRARY_PATH\", g_environ_getenv (bwrap->envp, \"LD_LIBRARY_PATH\"),",
                "                              NULL);",
                "      flatpak_bwrap_unset_env (bwrap, \"LD_LIBRARY_PATH\");",
                "    }",
                "",
                "  if (g_environ_getenv (bwrap->envp, \"TMPDIR\") != NULL)",
                "    {",
                "      /* TMPDIR is overridden for setuid helper, so pass it as cmdline arg */",
                "      flatpak_bwrap_add_args (bwrap,",
                "                              \"--setenv\", \"TMPDIR\", g_environ_getenv (bwrap->envp, \"TMPDIR\"),",
                "                              NULL);",
                "      flatpak_bwrap_unset_env (bwrap, \"TMPDIR\");",
                "    }",
                ""
            ],
            "added_lines": []
        }
    },
    {
        "cve_id": "CVE-2021-21261",
        "func_name": "flatpak/flatpak_run_app",
        "description": "Flatpak is a system for building, distributing, and running sandboxed desktop applications on Linux. A bug was discovered in the `flatpak-portal` service that can allow sandboxed applications to execute arbitrary code on the host system (a sandbox escape). This sandbox-escape bug is present in versions from 0.11.4 and before fixed versions 1.8.5 and 1.10.0. The Flatpak portal D-Bus service (`flatpak-portal`, also known by its D-Bus service name `org.freedesktop.portal.Flatpak`) allows apps in a Flatpak sandbox to launch their own subprocesses in a new sandbox instance, either with the same security settings as the caller or with more restrictive security settings. For example, this is used in Flatpak-packaged web browsers such as Chromium to launch subprocesses that will process untrusted web content, and give those subprocesses a more restrictive sandbox than the browser itself. In vulnerable versions, the Flatpak portal service passes caller-specified environment variables to non-sandboxed processes on the host system, and in particular to the `flatpak run` command that is used to launch the new sandbox instance. A malicious or compromised Flatpak app could set environment variables that are trusted by the `flatpak run` command, and use them to execute arbitrary code that is not in a sandbox. As a workaround, this vulnerability can be mitigated by preventing the `flatpak-portal` service from starting, but that mitigation will prevent many Flatpak apps from working correctly. This is fixed in versions 1.8.5 and 1.10.0.",
        "git_url": "https://github.com/flatpak/flatpak/commit/6d1773d2a54dde9b099043f07a2094a4f1c2f486",
        "commit_title": "run: Convert all environment variables into bwrap arguments",
        "commit_text": " This avoids some of them being filtered out by a setuid bwrap. It also means that if they came from an untrusted source, they cannot be used to inject arbitrary code into a non-setuid bwrap via mechanisms like LD_PRELOAD.  Because they get bundled into a memfd or temporary file, they do not actually appear in argv, ensuring that they remain inaccessible to processes running under a different uid (which is important if their values are tokens or other secrets).  Part-of: https://github.com/flatpak/flatpak/security/advisories/GHSA-4ppf-fxf6-vxg2",
        "func_before": "gboolean\nflatpak_run_app (FlatpakDecomposed *app_ref,\n                 FlatpakDeploy     *app_deploy,\n                 FlatpakContext    *extra_context,\n                 const char        *custom_runtime,\n                 const char        *custom_runtime_version,\n                 const char        *custom_runtime_commit,\n                 int                parent_pid,\n                 FlatpakRunFlags    flags,\n                 const char        *cwd,\n                 const char        *custom_command,\n                 char              *args[],\n                 int                n_args,\n                 int                instance_id_fd,\n                 char             **instance_dir_out,\n                 GCancellable      *cancellable,\n                 GError           **error)\n{\n  g_autoptr(FlatpakDeploy) runtime_deploy = NULL;\n  g_autoptr(GBytes) runtime_deploy_data = NULL;\n  g_autoptr(GBytes) app_deploy_data = NULL;\n  g_autoptr(GFile) app_files = NULL;\n  g_autoptr(GFile) runtime_files = NULL;\n  g_autoptr(GFile) bin_ldconfig = NULL;\n  g_autoptr(GFile) app_id_dir = NULL;\n  g_autoptr(GFile) real_app_id_dir = NULL;\n  g_autofree char *default_runtime_pref = NULL;\n  g_autoptr(FlatpakDecomposed) default_runtime = NULL;\n  g_autofree char *default_command = NULL;\n  g_autoptr(GKeyFile) metakey = NULL;\n  g_autoptr(GKeyFile) runtime_metakey = NULL;\n  g_autoptr(FlatpakBwrap) bwrap = NULL;\n  const char *command = \"/bin/sh\";\n  g_autoptr(GError) my_error = NULL;\n  g_autoptr(FlatpakDecomposed) runtime_ref = NULL;\n  int i;\n  g_autoptr(GPtrArray) previous_app_id_dirs = NULL;\n  g_autofree char *app_id = NULL;\n  g_autofree char *app_arch = NULL;\n  g_autofree char *app_info_path = NULL;\n  g_autofree char *instance_id_host_dir = NULL;\n  g_autoptr(FlatpakContext) app_context = NULL;\n  g_autoptr(FlatpakContext) overrides = NULL;\n  g_autoptr(FlatpakExports) exports = NULL;\n  g_autofree char *commandline = NULL;\n  g_autofree char *doc_mount_path = NULL;\n  g_autofree char *app_extensions = NULL;\n  g_autofree char *runtime_extensions = NULL;\n  g_autofree char *checksum = NULL;\n  int ld_so_fd = -1;\n  g_autoptr(GFile) runtime_ld_so_conf = NULL;\n  gboolean generate_ld_so_conf = TRUE;\n  gboolean use_ld_so_cache = TRUE;\n  gboolean sandboxed = (flags & FLATPAK_RUN_FLAG_SANDBOX) != 0;\n  gboolean parent_expose_pids = (flags & FLATPAK_RUN_FLAG_PARENT_EXPOSE_PIDS) != 0;\n  gboolean parent_share_pids = (flags & FLATPAK_RUN_FLAG_PARENT_SHARE_PIDS) != 0;\n  struct stat s;\n\n  if (!check_sudo (error))\n    return FALSE;\n\n  app_id = flatpak_decomposed_dup_id (app_ref);\n  app_arch = flatpak_decomposed_dup_arch (app_ref);\n\n  /* Check the user is allowed to run this flatpak. */\n  if (!check_parental_controls (app_ref, app_deploy, cancellable, error))\n    return FALSE;\n\n  /* Construct the bwrap context. */\n  bwrap = flatpak_bwrap_new (NULL);\n  flatpak_bwrap_add_arg (bwrap, flatpak_get_bwrap ());\n\n  if (app_deploy == NULL)\n    {\n      g_assert (flatpak_decomposed_is_runtime (app_ref));\n      default_runtime_pref = flatpak_decomposed_dup_pref (app_ref);\n    }\n  else\n    {\n      const gchar *key;\n\n      app_deploy_data = flatpak_deploy_get_deploy_data (app_deploy, FLATPAK_DEPLOY_VERSION_ANY, cancellable, error);\n      if (app_deploy_data == NULL)\n        return FALSE;\n\n      if ((flags & FLATPAK_RUN_FLAG_DEVEL) != 0)\n        key = FLATPAK_METADATA_KEY_SDK;\n      else\n        key = FLATPAK_METADATA_KEY_RUNTIME;\n\n      metakey = flatpak_deploy_get_metadata (app_deploy);\n      default_runtime_pref = g_key_file_get_string (metakey,\n                                                    FLATPAK_METADATA_GROUP_APPLICATION,\n                                                    key, &my_error);\n      if (my_error)\n        {\n          g_propagate_error (error, g_steal_pointer (&my_error));\n          return FALSE;\n        }\n    }\n\n  default_runtime = flatpak_decomposed_new_from_pref (FLATPAK_KINDS_RUNTIME, default_runtime_pref, error);\n  if (default_runtime == NULL)\n    return FALSE;\n\n  if (custom_runtime != NULL || custom_runtime_version != NULL)\n    {\n      g_auto(GStrv) custom_runtime_parts = NULL;\n      const char *custom_runtime_id = NULL;\n      const char *custom_runtime_arch = NULL;\n\n      if (custom_runtime)\n        {\n          custom_runtime_parts = g_strsplit (custom_runtime, \"/\", 0);\n          for (i = 0; i < 3 && custom_runtime_parts[i] != NULL; i++)\n            {\n              if (strlen (custom_runtime_parts[i]) > 0)\n                {\n                  if (i == 0)\n                    custom_runtime_id = custom_runtime_parts[i];\n                  if (i == 1)\n                    custom_runtime_arch = custom_runtime_parts[i];\n\n                  if (i == 2 && custom_runtime_version == NULL)\n                    custom_runtime_version = custom_runtime_parts[i];\n                }\n            }\n        }\n\n      runtime_ref = flatpak_decomposed_new_from_decomposed (default_runtime,\n                                                            FLATPAK_KINDS_RUNTIME,\n                                                            custom_runtime_id,\n                                                            custom_runtime_arch,\n                                                            custom_runtime_version,\n                                                            error);\n      if (runtime_ref == NULL)\n        return FALSE;\n    }\n  else\n    runtime_ref = flatpak_decomposed_ref (default_runtime);\n\n  runtime_deploy = flatpak_find_deploy_for_ref (flatpak_decomposed_get_ref (runtime_ref), custom_runtime_commit, NULL, cancellable, error);\n  if (runtime_deploy == NULL)\n    return FALSE;\n\n  runtime_deploy_data = flatpak_deploy_get_deploy_data (runtime_deploy, FLATPAK_DEPLOY_VERSION_ANY, cancellable, error);\n  if (runtime_deploy_data == NULL)\n    return FALSE;\n\n  runtime_metakey = flatpak_deploy_get_metadata (runtime_deploy);\n\n  app_context = flatpak_app_compute_permissions (metakey, runtime_metakey, error);\n  if (app_context == NULL)\n    return FALSE;\n\n  if (app_deploy != NULL)\n    {\n      overrides = flatpak_deploy_get_overrides (app_deploy);\n      flatpak_context_merge (app_context, overrides);\n    }\n\n  if (sandboxed)\n    flatpak_context_make_sandboxed (app_context);\n\n  if (extra_context)\n    flatpak_context_merge (app_context, extra_context);\n\n  runtime_files = flatpak_deploy_get_files (runtime_deploy);\n  bin_ldconfig = g_file_resolve_relative_path (runtime_files, \"bin/ldconfig\");\n  if (!g_file_query_exists (bin_ldconfig, NULL))\n    use_ld_so_cache = FALSE;\n\n  if (app_deploy != NULL)\n    {\n      g_autofree const char **previous_ids = NULL;\n      gsize len = 0;\n      gboolean do_migrate;\n\n      real_app_id_dir = flatpak_get_data_dir (app_id);\n      app_files = flatpak_deploy_get_files (app_deploy);\n\n      previous_app_id_dirs = g_ptr_array_new_with_free_func (g_object_unref);\n      previous_ids = flatpak_deploy_data_get_previous_ids (app_deploy_data, &len);\n\n      do_migrate = !g_file_query_exists (real_app_id_dir, cancellable);\n\n      /* When migrating, find most recent old existing source and rename that to\n       * the new name.\n       *\n       * We ignore other names than that. For more recent names that don't exist\n       * we never ran them so nothing will even reference them. For older names\n       * either they were not used, or they were used but then the more recent\n       * name was used and a symlink to it was created.\n       *\n       * This means we may end up with a chain of symlinks: oldest -> old -> current.\n       * This is unfortunate but not really a problem, but for robustness reasons we\n       * don't want to mess with user files unnecessary. For example, the app dir could\n       * actually be a symlink for other reasons. Imagine for instance that you want to put the\n       * steam games somewhere else so you leave the app dir as a symlink to /mnt/steam.\n       */\n      for (i = len - 1; i >= 0; i--)\n        {\n          g_autoptr(GFile) previous_app_id_dir = NULL;\n          g_autoptr(GFileInfo) previous_app_id_dir_info = NULL;\n          g_autoptr(GError) local_error = NULL;\n\n          previous_app_id_dir = flatpak_get_data_dir (previous_ids[i]);\n          previous_app_id_dir_info = g_file_query_info (previous_app_id_dir,\n                                                        G_FILE_ATTRIBUTE_STANDARD_IS_SYMLINK \",\"\n                                                        G_FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET,\n                                                        G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                                                        cancellable,\n                                                        &local_error);\n          /* Warn about the migration failures, but don't make them fatal, then you can never run the app */\n          if (previous_app_id_dir_info == NULL)\n            {\n              if  (!g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND) && do_migrate)\n                {\n                  g_warning (_(\"Failed to migrate from %s: %s\"), flatpak_file_get_path_cached (previous_app_id_dir),\n                             local_error->message);\n                  do_migrate = FALSE; /* Don't migrate older things, they are likely symlinks to the thing that we failed on */\n                }\n\n              g_clear_error (&local_error);\n              continue;\n            }\n\n          if (do_migrate)\n            {\n              do_migrate = FALSE; /* Don't migrate older things, they are likely symlinks to this dir */\n\n              if (!flatpak_file_rename (previous_app_id_dir, real_app_id_dir, cancellable, &local_error))\n                {\n                  g_warning (_(\"Failed to migrate old app data directory %s to new name %s: %s\"),\n                             flatpak_file_get_path_cached (previous_app_id_dir), app_id,\n                             local_error->message);\n                }\n              else\n                {\n                  /* Leave a symlink in place of the old data dir */\n                  if (!g_file_make_symbolic_link (previous_app_id_dir, app_id, cancellable, &local_error))\n                    {\n                      g_warning (_(\"Failed to create symlink while migrating %s: %s\"),\n                                 flatpak_file_get_path_cached (previous_app_id_dir),\n                                 local_error->message);\n                    }\n                }\n            }\n\n          /* Give app access to this old dir */\n          g_ptr_array_add (previous_app_id_dirs, g_steal_pointer (&previous_app_id_dir));\n        }\n\n      if (!flatpak_ensure_data_dir (real_app_id_dir, cancellable, error))\n        return FALSE;\n\n      if (!sandboxed)\n        app_id_dir = g_object_ref (real_app_id_dir);\n    }\n\n  flatpak_run_apply_env_default (bwrap, use_ld_so_cache);\n  flatpak_run_apply_env_vars (bwrap, app_context);\n  flatpak_run_apply_env_prompt (bwrap, app_id);\n\n  if (real_app_id_dir)\n    {\n      g_autoptr(GFile) sandbox_dir = g_file_get_child (real_app_id_dir, \"sandbox\");\n      flatpak_bwrap_set_env (bwrap, \"FLATPAK_SANDBOX_DIR\", flatpak_file_get_path_cached (sandbox_dir), TRUE);\n    }\n\n  flatpak_bwrap_add_args (bwrap,\n                          \"--ro-bind\", flatpak_file_get_path_cached (runtime_files), \"/usr\",\n                          \"--lock-file\", \"/usr/.ref\",\n                          NULL);\n\n  if (app_files != NULL)\n    flatpak_bwrap_add_args (bwrap,\n                            \"--ro-bind\", flatpak_file_get_path_cached (app_files), \"/app\",\n                            \"--lock-file\", \"/app/.ref\",\n                            NULL);\n  else\n    flatpak_bwrap_add_args (bwrap,\n                            \"--dir\", \"/app\",\n                            NULL);\n\n  if (metakey != NULL &&\n      !flatpak_run_add_extension_args (bwrap, metakey, app_ref, use_ld_so_cache, &app_extensions, cancellable, error))\n    return FALSE;\n\n  if (!flatpak_run_add_extension_args (bwrap, runtime_metakey, runtime_ref, use_ld_so_cache, &runtime_extensions, cancellable, error))\n    return FALSE;\n\n  runtime_ld_so_conf = g_file_resolve_relative_path (runtime_files, \"etc/ld.so.conf\");\n  if (lstat (flatpak_file_get_path_cached (runtime_ld_so_conf), &s) == 0)\n    generate_ld_so_conf = S_ISREG (s.st_mode) && s.st_size == 0;\n\n  /* At this point we have the minimal argv set up, with just the app, runtime and extensions.\n     We can reuse this to generate the ld.so.cache (if needed) */\n  if (use_ld_so_cache)\n    {\n      checksum = calculate_ld_cache_checksum (app_deploy_data, runtime_deploy_data,\n                                              app_extensions, runtime_extensions);\n      ld_so_fd = regenerate_ld_cache (bwrap->argv,\n                                      bwrap->fds,\n                                      app_id_dir,\n                                      checksum,\n                                      runtime_files,\n                                      generate_ld_so_conf,\n                                      cancellable, error);\n      if (ld_so_fd == -1)\n        return FALSE;\n      flatpak_bwrap_add_fd (bwrap, ld_so_fd);\n    }\n\n  flags |= flatpak_context_get_run_flags (app_context);\n\n  if (!flatpak_run_setup_base_argv (bwrap, runtime_files, app_id_dir, app_arch, flags, error))\n    return FALSE;\n\n  if (generate_ld_so_conf)\n    {\n      if (!add_ld_so_conf (bwrap, error))\n        return FALSE;\n    }\n\n  if (ld_so_fd != -1)\n    {\n      /* Don't add to fd_array, its already there */\n      flatpak_bwrap_add_arg (bwrap, \"--ro-bind-data\");\n      flatpak_bwrap_add_arg_printf (bwrap, \"%d\", ld_so_fd);\n      flatpak_bwrap_add_arg (bwrap, \"/etc/ld.so.cache\");\n    }\n\n  if (!flatpak_run_add_app_info_args (bwrap,\n                                      app_files, app_deploy_data, app_extensions,\n                                      runtime_files, runtime_deploy_data, runtime_extensions,\n                                      app_id, flatpak_decomposed_get_branch (app_ref),\n                                      runtime_ref, app_id_dir, app_context, extra_context,\n                                      sandboxed, FALSE, flags & FLATPAK_RUN_FLAG_DEVEL,\n                                      &app_info_path, instance_id_fd, &instance_id_host_dir,\n                                      error))\n    return FALSE;\n\n  if (!flatpak_run_add_dconf_args (bwrap, app_id, metakey, error))\n    return FALSE;\n\n  if (!sandboxed && !(flags & FLATPAK_RUN_FLAG_NO_DOCUMENTS_PORTAL))\n    add_document_portal_args (bwrap, app_id, &doc_mount_path);\n\n  if (!flatpak_run_add_environment_args (bwrap, app_info_path, flags,\n                                         app_id, app_context, app_id_dir, previous_app_id_dirs,\n                                         &exports, cancellable, error))\n    return FALSE;\n\n  if ((app_context->shares & FLATPAK_CONTEXT_SHARED_NETWORK) != 0)\n    flatpak_run_add_resolved_args (bwrap);\n\n  flatpak_run_add_journal_args (bwrap);\n  add_font_path_args (bwrap);\n  add_icon_path_args (bwrap);\n\n  flatpak_bwrap_add_args (bwrap,\n                          /* Not in base, because we don't want this for flatpak build */\n                          \"--symlink\", \"/app/lib/debug/source\", \"/run/build\",\n                          \"--symlink\", \"/usr/lib/debug/source\", \"/run/build-runtime\",\n                          NULL);\n\n  if (cwd)\n    flatpak_bwrap_add_args (bwrap, \"--chdir\", cwd, NULL);\n\n  if (parent_expose_pids || parent_share_pids)\n    {\n      g_autofree char *userns_path = NULL;\n      g_autofree char *pidns_path = NULL;\n      g_autofree char *userns2_path = NULL;\n      int userns_fd, userns2_fd, pidns_fd;\n\n      if (parent_pid == 0)\n        return flatpak_fail (error, \"No parent pid specified\");\n\n      userns_path = g_strdup_printf (\"/proc/%d/root/run/.userns\", parent_pid);\n\n      userns_fd = open_namespace_fd_if_needed (userns_path, \"/proc/self/ns/user\");\n      if (userns_fd != -1)\n        {\n          flatpak_bwrap_add_args_data_fd (bwrap, \"--userns\", userns_fd, NULL);\n\n          userns2_path = g_strdup_printf (\"/proc/%d/ns/user\", parent_pid);\n          userns2_fd = open_namespace_fd_if_needed (userns2_path, userns_path);\n          if (userns2_fd != -1)\n            flatpak_bwrap_add_args_data_fd (bwrap, \"--userns2\", userns2_fd, NULL);\n        }\n\n      pidns_path = g_strdup_printf (\"/proc/%d/ns/pid\", parent_pid);\n      pidns_fd = open (pidns_path, O_RDONLY|O_CLOEXEC);\n      if (pidns_fd != -1)\n        flatpak_bwrap_add_args_data_fd (bwrap, \"--pidns\", pidns_fd, NULL);\n    }\n\n  if (custom_command)\n    {\n      command = custom_command;\n    }\n  else if (metakey)\n    {\n      default_command = g_key_file_get_string (metakey,\n                                               FLATPAK_METADATA_GROUP_APPLICATION,\n                                               FLATPAK_METADATA_KEY_COMMAND,\n                                               &my_error);\n      if (my_error)\n        {\n          g_propagate_error (error, g_steal_pointer (&my_error));\n          return FALSE;\n        }\n      command = default_command;\n    }\n\n  if (!flatpak_bwrap_bundle_args (bwrap, 1, -1, FALSE, error))\n    return FALSE;\n\n  flatpak_bwrap_add_arg (bwrap, command);\n\n  if (!add_rest_args (bwrap, app_id,\n                      exports, (flags & FLATPAK_RUN_FLAG_FILE_FORWARDING) != 0,\n                      doc_mount_path,\n                      args, n_args, error))\n    return FALSE;\n\n  flatpak_bwrap_finish (bwrap);\n\n  commandline = flatpak_quote_argv ((const char **) bwrap->argv->pdata, -1);\n  g_debug (\"Running '%s'\", commandline);\n\n  if ((flags & FLATPAK_RUN_FLAG_BACKGROUND) != 0)\n    {\n      GPid child_pid;\n      char pid_str[64];\n      g_autofree char *pid_path = NULL;\n      GSpawnFlags spawn_flags;\n\n      spawn_flags = G_SPAWN_SEARCH_PATH;\n      if (flags & FLATPAK_RUN_FLAG_DO_NOT_REAP)\n        spawn_flags |= G_SPAWN_DO_NOT_REAP_CHILD;\n\n      /* We use LEAVE_DESCRIPTORS_OPEN to work around dead-lock, see flatpak_close_fds_workaround */\n      spawn_flags |= G_SPAWN_LEAVE_DESCRIPTORS_OPEN;\n\n      if (!g_spawn_async (NULL,\n                          (char **) bwrap->argv->pdata,\n                          bwrap->envp,\n                          spawn_flags,\n                          flatpak_bwrap_child_setup_cb, bwrap->fds,\n                          &child_pid,\n                          error))\n        return FALSE;\n\n      g_snprintf (pid_str, sizeof (pid_str), \"%d\", child_pid);\n      pid_path = g_build_filename (instance_id_host_dir, \"pid\", NULL);\n      g_file_set_contents (pid_path, pid_str, -1, NULL);\n    }\n  else\n    {\n      char pid_str[64];\n      g_autofree char *pid_path = NULL;\n\n      g_snprintf (pid_str, sizeof (pid_str), \"%d\", getpid ());\n      pid_path = g_build_filename (instance_id_host_dir, \"pid\", NULL);\n      g_file_set_contents (pid_path, pid_str, -1, NULL);\n\n      /* Ensure we unset O_CLOEXEC for marked fds and rewind fds as needed.\n       * Note that this does not close fds that are not already marked O_CLOEXEC, because\n       * we do want to allow inheriting fds into flatpak run. */\n      flatpak_bwrap_child_setup (bwrap->fds, FALSE);\n\n      if (execvpe (flatpak_get_bwrap (), (char **) bwrap->argv->pdata, bwrap->envp) == -1)\n        {\n          g_set_error_literal (error, G_IO_ERROR, g_io_error_from_errno (errno),\n                               _(\"Unable to start app\"));\n          return FALSE;\n        }\n      /* Not actually reached... */\n    }\n\n  if (instance_dir_out)\n    *instance_dir_out = g_steal_pointer (&instance_id_host_dir);\n\n  return TRUE;\n}",
        "func": "gboolean\nflatpak_run_app (FlatpakDecomposed *app_ref,\n                 FlatpakDeploy     *app_deploy,\n                 FlatpakContext    *extra_context,\n                 const char        *custom_runtime,\n                 const char        *custom_runtime_version,\n                 const char        *custom_runtime_commit,\n                 int                parent_pid,\n                 FlatpakRunFlags    flags,\n                 const char        *cwd,\n                 const char        *custom_command,\n                 char              *args[],\n                 int                n_args,\n                 int                instance_id_fd,\n                 char             **instance_dir_out,\n                 GCancellable      *cancellable,\n                 GError           **error)\n{\n  g_autoptr(FlatpakDeploy) runtime_deploy = NULL;\n  g_autoptr(GBytes) runtime_deploy_data = NULL;\n  g_autoptr(GBytes) app_deploy_data = NULL;\n  g_autoptr(GFile) app_files = NULL;\n  g_autoptr(GFile) runtime_files = NULL;\n  g_autoptr(GFile) bin_ldconfig = NULL;\n  g_autoptr(GFile) app_id_dir = NULL;\n  g_autoptr(GFile) real_app_id_dir = NULL;\n  g_autofree char *default_runtime_pref = NULL;\n  g_autoptr(FlatpakDecomposed) default_runtime = NULL;\n  g_autofree char *default_command = NULL;\n  g_autoptr(GKeyFile) metakey = NULL;\n  g_autoptr(GKeyFile) runtime_metakey = NULL;\n  g_autoptr(FlatpakBwrap) bwrap = NULL;\n  const char *command = \"/bin/sh\";\n  g_autoptr(GError) my_error = NULL;\n  g_autoptr(FlatpakDecomposed) runtime_ref = NULL;\n  int i;\n  g_autoptr(GPtrArray) previous_app_id_dirs = NULL;\n  g_autofree char *app_id = NULL;\n  g_autofree char *app_arch = NULL;\n  g_autofree char *app_info_path = NULL;\n  g_autofree char *instance_id_host_dir = NULL;\n  g_autoptr(FlatpakContext) app_context = NULL;\n  g_autoptr(FlatpakContext) overrides = NULL;\n  g_autoptr(FlatpakExports) exports = NULL;\n  g_autofree char *commandline = NULL;\n  g_autofree char *doc_mount_path = NULL;\n  g_autofree char *app_extensions = NULL;\n  g_autofree char *runtime_extensions = NULL;\n  g_autofree char *checksum = NULL;\n  int ld_so_fd = -1;\n  g_autoptr(GFile) runtime_ld_so_conf = NULL;\n  gboolean generate_ld_so_conf = TRUE;\n  gboolean use_ld_so_cache = TRUE;\n  gboolean sandboxed = (flags & FLATPAK_RUN_FLAG_SANDBOX) != 0;\n  gboolean parent_expose_pids = (flags & FLATPAK_RUN_FLAG_PARENT_EXPOSE_PIDS) != 0;\n  gboolean parent_share_pids = (flags & FLATPAK_RUN_FLAG_PARENT_SHARE_PIDS) != 0;\n  struct stat s;\n\n  if (!check_sudo (error))\n    return FALSE;\n\n  app_id = flatpak_decomposed_dup_id (app_ref);\n  app_arch = flatpak_decomposed_dup_arch (app_ref);\n\n  /* Check the user is allowed to run this flatpak. */\n  if (!check_parental_controls (app_ref, app_deploy, cancellable, error))\n    return FALSE;\n\n  /* Construct the bwrap context. */\n  bwrap = flatpak_bwrap_new (NULL);\n  flatpak_bwrap_add_arg (bwrap, flatpak_get_bwrap ());\n\n  if (app_deploy == NULL)\n    {\n      g_assert (flatpak_decomposed_is_runtime (app_ref));\n      default_runtime_pref = flatpak_decomposed_dup_pref (app_ref);\n    }\n  else\n    {\n      const gchar *key;\n\n      app_deploy_data = flatpak_deploy_get_deploy_data (app_deploy, FLATPAK_DEPLOY_VERSION_ANY, cancellable, error);\n      if (app_deploy_data == NULL)\n        return FALSE;\n\n      if ((flags & FLATPAK_RUN_FLAG_DEVEL) != 0)\n        key = FLATPAK_METADATA_KEY_SDK;\n      else\n        key = FLATPAK_METADATA_KEY_RUNTIME;\n\n      metakey = flatpak_deploy_get_metadata (app_deploy);\n      default_runtime_pref = g_key_file_get_string (metakey,\n                                                    FLATPAK_METADATA_GROUP_APPLICATION,\n                                                    key, &my_error);\n      if (my_error)\n        {\n          g_propagate_error (error, g_steal_pointer (&my_error));\n          return FALSE;\n        }\n    }\n\n  default_runtime = flatpak_decomposed_new_from_pref (FLATPAK_KINDS_RUNTIME, default_runtime_pref, error);\n  if (default_runtime == NULL)\n    return FALSE;\n\n  if (custom_runtime != NULL || custom_runtime_version != NULL)\n    {\n      g_auto(GStrv) custom_runtime_parts = NULL;\n      const char *custom_runtime_id = NULL;\n      const char *custom_runtime_arch = NULL;\n\n      if (custom_runtime)\n        {\n          custom_runtime_parts = g_strsplit (custom_runtime, \"/\", 0);\n          for (i = 0; i < 3 && custom_runtime_parts[i] != NULL; i++)\n            {\n              if (strlen (custom_runtime_parts[i]) > 0)\n                {\n                  if (i == 0)\n                    custom_runtime_id = custom_runtime_parts[i];\n                  if (i == 1)\n                    custom_runtime_arch = custom_runtime_parts[i];\n\n                  if (i == 2 && custom_runtime_version == NULL)\n                    custom_runtime_version = custom_runtime_parts[i];\n                }\n            }\n        }\n\n      runtime_ref = flatpak_decomposed_new_from_decomposed (default_runtime,\n                                                            FLATPAK_KINDS_RUNTIME,\n                                                            custom_runtime_id,\n                                                            custom_runtime_arch,\n                                                            custom_runtime_version,\n                                                            error);\n      if (runtime_ref == NULL)\n        return FALSE;\n    }\n  else\n    runtime_ref = flatpak_decomposed_ref (default_runtime);\n\n  runtime_deploy = flatpak_find_deploy_for_ref (flatpak_decomposed_get_ref (runtime_ref), custom_runtime_commit, NULL, cancellable, error);\n  if (runtime_deploy == NULL)\n    return FALSE;\n\n  runtime_deploy_data = flatpak_deploy_get_deploy_data (runtime_deploy, FLATPAK_DEPLOY_VERSION_ANY, cancellable, error);\n  if (runtime_deploy_data == NULL)\n    return FALSE;\n\n  runtime_metakey = flatpak_deploy_get_metadata (runtime_deploy);\n\n  app_context = flatpak_app_compute_permissions (metakey, runtime_metakey, error);\n  if (app_context == NULL)\n    return FALSE;\n\n  if (app_deploy != NULL)\n    {\n      overrides = flatpak_deploy_get_overrides (app_deploy);\n      flatpak_context_merge (app_context, overrides);\n    }\n\n  if (sandboxed)\n    flatpak_context_make_sandboxed (app_context);\n\n  if (extra_context)\n    flatpak_context_merge (app_context, extra_context);\n\n  runtime_files = flatpak_deploy_get_files (runtime_deploy);\n  bin_ldconfig = g_file_resolve_relative_path (runtime_files, \"bin/ldconfig\");\n  if (!g_file_query_exists (bin_ldconfig, NULL))\n    use_ld_so_cache = FALSE;\n\n  if (app_deploy != NULL)\n    {\n      g_autofree const char **previous_ids = NULL;\n      gsize len = 0;\n      gboolean do_migrate;\n\n      real_app_id_dir = flatpak_get_data_dir (app_id);\n      app_files = flatpak_deploy_get_files (app_deploy);\n\n      previous_app_id_dirs = g_ptr_array_new_with_free_func (g_object_unref);\n      previous_ids = flatpak_deploy_data_get_previous_ids (app_deploy_data, &len);\n\n      do_migrate = !g_file_query_exists (real_app_id_dir, cancellable);\n\n      /* When migrating, find most recent old existing source and rename that to\n       * the new name.\n       *\n       * We ignore other names than that. For more recent names that don't exist\n       * we never ran them so nothing will even reference them. For older names\n       * either they were not used, or they were used but then the more recent\n       * name was used and a symlink to it was created.\n       *\n       * This means we may end up with a chain of symlinks: oldest -> old -> current.\n       * This is unfortunate but not really a problem, but for robustness reasons we\n       * don't want to mess with user files unnecessary. For example, the app dir could\n       * actually be a symlink for other reasons. Imagine for instance that you want to put the\n       * steam games somewhere else so you leave the app dir as a symlink to /mnt/steam.\n       */\n      for (i = len - 1; i >= 0; i--)\n        {\n          g_autoptr(GFile) previous_app_id_dir = NULL;\n          g_autoptr(GFileInfo) previous_app_id_dir_info = NULL;\n          g_autoptr(GError) local_error = NULL;\n\n          previous_app_id_dir = flatpak_get_data_dir (previous_ids[i]);\n          previous_app_id_dir_info = g_file_query_info (previous_app_id_dir,\n                                                        G_FILE_ATTRIBUTE_STANDARD_IS_SYMLINK \",\"\n                                                        G_FILE_ATTRIBUTE_STANDARD_SYMLINK_TARGET,\n                                                        G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                                                        cancellable,\n                                                        &local_error);\n          /* Warn about the migration failures, but don't make them fatal, then you can never run the app */\n          if (previous_app_id_dir_info == NULL)\n            {\n              if  (!g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND) && do_migrate)\n                {\n                  g_warning (_(\"Failed to migrate from %s: %s\"), flatpak_file_get_path_cached (previous_app_id_dir),\n                             local_error->message);\n                  do_migrate = FALSE; /* Don't migrate older things, they are likely symlinks to the thing that we failed on */\n                }\n\n              g_clear_error (&local_error);\n              continue;\n            }\n\n          if (do_migrate)\n            {\n              do_migrate = FALSE; /* Don't migrate older things, they are likely symlinks to this dir */\n\n              if (!flatpak_file_rename (previous_app_id_dir, real_app_id_dir, cancellable, &local_error))\n                {\n                  g_warning (_(\"Failed to migrate old app data directory %s to new name %s: %s\"),\n                             flatpak_file_get_path_cached (previous_app_id_dir), app_id,\n                             local_error->message);\n                }\n              else\n                {\n                  /* Leave a symlink in place of the old data dir */\n                  if (!g_file_make_symbolic_link (previous_app_id_dir, app_id, cancellable, &local_error))\n                    {\n                      g_warning (_(\"Failed to create symlink while migrating %s: %s\"),\n                                 flatpak_file_get_path_cached (previous_app_id_dir),\n                                 local_error->message);\n                    }\n                }\n            }\n\n          /* Give app access to this old dir */\n          g_ptr_array_add (previous_app_id_dirs, g_steal_pointer (&previous_app_id_dir));\n        }\n\n      if (!flatpak_ensure_data_dir (real_app_id_dir, cancellable, error))\n        return FALSE;\n\n      if (!sandboxed)\n        app_id_dir = g_object_ref (real_app_id_dir);\n    }\n\n  flatpak_run_apply_env_default (bwrap, use_ld_so_cache);\n  flatpak_run_apply_env_vars (bwrap, app_context);\n  flatpak_run_apply_env_prompt (bwrap, app_id);\n\n  if (real_app_id_dir)\n    {\n      g_autoptr(GFile) sandbox_dir = g_file_get_child (real_app_id_dir, \"sandbox\");\n      flatpak_bwrap_set_env (bwrap, \"FLATPAK_SANDBOX_DIR\", flatpak_file_get_path_cached (sandbox_dir), TRUE);\n    }\n\n  flatpak_bwrap_add_args (bwrap,\n                          \"--ro-bind\", flatpak_file_get_path_cached (runtime_files), \"/usr\",\n                          \"--lock-file\", \"/usr/.ref\",\n                          NULL);\n\n  if (app_files != NULL)\n    flatpak_bwrap_add_args (bwrap,\n                            \"--ro-bind\", flatpak_file_get_path_cached (app_files), \"/app\",\n                            \"--lock-file\", \"/app/.ref\",\n                            NULL);\n  else\n    flatpak_bwrap_add_args (bwrap,\n                            \"--dir\", \"/app\",\n                            NULL);\n\n  if (metakey != NULL &&\n      !flatpak_run_add_extension_args (bwrap, metakey, app_ref, use_ld_so_cache, &app_extensions, cancellable, error))\n    return FALSE;\n\n  if (!flatpak_run_add_extension_args (bwrap, runtime_metakey, runtime_ref, use_ld_so_cache, &runtime_extensions, cancellable, error))\n    return FALSE;\n\n  runtime_ld_so_conf = g_file_resolve_relative_path (runtime_files, \"etc/ld.so.conf\");\n  if (lstat (flatpak_file_get_path_cached (runtime_ld_so_conf), &s) == 0)\n    generate_ld_so_conf = S_ISREG (s.st_mode) && s.st_size == 0;\n\n  /* At this point we have the minimal argv set up, with just the app, runtime and extensions.\n     We can reuse this to generate the ld.so.cache (if needed) */\n  if (use_ld_so_cache)\n    {\n      checksum = calculate_ld_cache_checksum (app_deploy_data, runtime_deploy_data,\n                                              app_extensions, runtime_extensions);\n      ld_so_fd = regenerate_ld_cache (bwrap->argv,\n                                      bwrap->fds,\n                                      app_id_dir,\n                                      checksum,\n                                      runtime_files,\n                                      generate_ld_so_conf,\n                                      cancellable, error);\n      if (ld_so_fd == -1)\n        return FALSE;\n      flatpak_bwrap_add_fd (bwrap, ld_so_fd);\n    }\n\n  flags |= flatpak_context_get_run_flags (app_context);\n\n  if (!flatpak_run_setup_base_argv (bwrap, runtime_files, app_id_dir, app_arch, flags, error))\n    return FALSE;\n\n  if (generate_ld_so_conf)\n    {\n      if (!add_ld_so_conf (bwrap, error))\n        return FALSE;\n    }\n\n  if (ld_so_fd != -1)\n    {\n      /* Don't add to fd_array, its already there */\n      flatpak_bwrap_add_arg (bwrap, \"--ro-bind-data\");\n      flatpak_bwrap_add_arg_printf (bwrap, \"%d\", ld_so_fd);\n      flatpak_bwrap_add_arg (bwrap, \"/etc/ld.so.cache\");\n    }\n\n  if (!flatpak_run_add_app_info_args (bwrap,\n                                      app_files, app_deploy_data, app_extensions,\n                                      runtime_files, runtime_deploy_data, runtime_extensions,\n                                      app_id, flatpak_decomposed_get_branch (app_ref),\n                                      runtime_ref, app_id_dir, app_context, extra_context,\n                                      sandboxed, FALSE, flags & FLATPAK_RUN_FLAG_DEVEL,\n                                      &app_info_path, instance_id_fd, &instance_id_host_dir,\n                                      error))\n    return FALSE;\n\n  if (!flatpak_run_add_dconf_args (bwrap, app_id, metakey, error))\n    return FALSE;\n\n  if (!sandboxed && !(flags & FLATPAK_RUN_FLAG_NO_DOCUMENTS_PORTAL))\n    add_document_portal_args (bwrap, app_id, &doc_mount_path);\n\n  if (!flatpak_run_add_environment_args (bwrap, app_info_path, flags,\n                                         app_id, app_context, app_id_dir, previous_app_id_dirs,\n                                         &exports, cancellable, error))\n    return FALSE;\n\n  if ((app_context->shares & FLATPAK_CONTEXT_SHARED_NETWORK) != 0)\n    flatpak_run_add_resolved_args (bwrap);\n\n  flatpak_run_add_journal_args (bwrap);\n  add_font_path_args (bwrap);\n  add_icon_path_args (bwrap);\n\n  flatpak_bwrap_add_args (bwrap,\n                          /* Not in base, because we don't want this for flatpak build */\n                          \"--symlink\", \"/app/lib/debug/source\", \"/run/build\",\n                          \"--symlink\", \"/usr/lib/debug/source\", \"/run/build-runtime\",\n                          NULL);\n\n  if (cwd)\n    flatpak_bwrap_add_args (bwrap, \"--chdir\", cwd, NULL);\n\n  if (parent_expose_pids || parent_share_pids)\n    {\n      g_autofree char *userns_path = NULL;\n      g_autofree char *pidns_path = NULL;\n      g_autofree char *userns2_path = NULL;\n      int userns_fd, userns2_fd, pidns_fd;\n\n      if (parent_pid == 0)\n        return flatpak_fail (error, \"No parent pid specified\");\n\n      userns_path = g_strdup_printf (\"/proc/%d/root/run/.userns\", parent_pid);\n\n      userns_fd = open_namespace_fd_if_needed (userns_path, \"/proc/self/ns/user\");\n      if (userns_fd != -1)\n        {\n          flatpak_bwrap_add_args_data_fd (bwrap, \"--userns\", userns_fd, NULL);\n\n          userns2_path = g_strdup_printf (\"/proc/%d/ns/user\", parent_pid);\n          userns2_fd = open_namespace_fd_if_needed (userns2_path, userns_path);\n          if (userns2_fd != -1)\n            flatpak_bwrap_add_args_data_fd (bwrap, \"--userns2\", userns2_fd, NULL);\n        }\n\n      pidns_path = g_strdup_printf (\"/proc/%d/ns/pid\", parent_pid);\n      pidns_fd = open (pidns_path, O_RDONLY|O_CLOEXEC);\n      if (pidns_fd != -1)\n        flatpak_bwrap_add_args_data_fd (bwrap, \"--pidns\", pidns_fd, NULL);\n    }\n\n  if (custom_command)\n    {\n      command = custom_command;\n    }\n  else if (metakey)\n    {\n      default_command = g_key_file_get_string (metakey,\n                                               FLATPAK_METADATA_GROUP_APPLICATION,\n                                               FLATPAK_METADATA_KEY_COMMAND,\n                                               &my_error);\n      if (my_error)\n        {\n          g_propagate_error (error, g_steal_pointer (&my_error));\n          return FALSE;\n        }\n      command = default_command;\n    }\n\n  flatpak_bwrap_envp_to_args (bwrap);\n\n  if (!flatpak_bwrap_bundle_args (bwrap, 1, -1, FALSE, error))\n    return FALSE;\n\n  flatpak_bwrap_add_arg (bwrap, command);\n\n  if (!add_rest_args (bwrap, app_id,\n                      exports, (flags & FLATPAK_RUN_FLAG_FILE_FORWARDING) != 0,\n                      doc_mount_path,\n                      args, n_args, error))\n    return FALSE;\n\n  flatpak_bwrap_finish (bwrap);\n\n  commandline = flatpak_quote_argv ((const char **) bwrap->argv->pdata, -1);\n  g_debug (\"Running '%s'\", commandline);\n\n  if ((flags & FLATPAK_RUN_FLAG_BACKGROUND) != 0)\n    {\n      GPid child_pid;\n      char pid_str[64];\n      g_autofree char *pid_path = NULL;\n      GSpawnFlags spawn_flags;\n\n      spawn_flags = G_SPAWN_SEARCH_PATH;\n      if (flags & FLATPAK_RUN_FLAG_DO_NOT_REAP)\n        spawn_flags |= G_SPAWN_DO_NOT_REAP_CHILD;\n\n      /* We use LEAVE_DESCRIPTORS_OPEN to work around dead-lock, see flatpak_close_fds_workaround */\n      spawn_flags |= G_SPAWN_LEAVE_DESCRIPTORS_OPEN;\n\n      /* flatpak_bwrap_envp_to_args() moved the environment variables to\n       * be set into --setenv instructions in argv, so the environment\n       * in which the bwrap command runs must be empty. */\n      g_assert (bwrap->envp != NULL);\n      g_assert (bwrap->envp[0] == NULL);\n\n      if (!g_spawn_async (NULL,\n                          (char **) bwrap->argv->pdata,\n                          bwrap->envp,\n                          spawn_flags,\n                          flatpak_bwrap_child_setup_cb, bwrap->fds,\n                          &child_pid,\n                          error))\n        return FALSE;\n\n      g_snprintf (pid_str, sizeof (pid_str), \"%d\", child_pid);\n      pid_path = g_build_filename (instance_id_host_dir, \"pid\", NULL);\n      g_file_set_contents (pid_path, pid_str, -1, NULL);\n    }\n  else\n    {\n      char pid_str[64];\n      g_autofree char *pid_path = NULL;\n\n      g_snprintf (pid_str, sizeof (pid_str), \"%d\", getpid ());\n      pid_path = g_build_filename (instance_id_host_dir, \"pid\", NULL);\n      g_file_set_contents (pid_path, pid_str, -1, NULL);\n\n      /* Ensure we unset O_CLOEXEC for marked fds and rewind fds as needed.\n       * Note that this does not close fds that are not already marked O_CLOEXEC, because\n       * we do want to allow inheriting fds into flatpak run. */\n      flatpak_bwrap_child_setup (bwrap->fds, FALSE);\n\n      /* flatpak_bwrap_envp_to_args() moved the environment variables to\n       * be set into --setenv instructions in argv, so the environment\n       * in which the bwrap command runs must be empty. */\n      g_assert (bwrap->envp != NULL);\n      g_assert (bwrap->envp[0] == NULL);\n\n      if (execvpe (flatpak_get_bwrap (), (char **) bwrap->argv->pdata, bwrap->envp) == -1)\n        {\n          g_set_error_literal (error, G_IO_ERROR, g_io_error_from_errno (errno),\n                               _(\"Unable to start app\"));\n          return FALSE;\n        }\n      /* Not actually reached... */\n    }\n\n  if (instance_dir_out)\n    *instance_dir_out = g_steal_pointer (&instance_id_host_dir);\n\n  return TRUE;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -415,6 +415,8 @@\n       command = default_command;\n     }\n \n+  flatpak_bwrap_envp_to_args (bwrap);\n+\n   if (!flatpak_bwrap_bundle_args (bwrap, 1, -1, FALSE, error))\n     return FALSE;\n \n@@ -444,6 +446,12 @@\n \n       /* We use LEAVE_DESCRIPTORS_OPEN to work around dead-lock, see flatpak_close_fds_workaround */\n       spawn_flags |= G_SPAWN_LEAVE_DESCRIPTORS_OPEN;\n+\n+      /* flatpak_bwrap_envp_to_args() moved the environment variables to\n+       * be set into --setenv instructions in argv, so the environment\n+       * in which the bwrap command runs must be empty. */\n+      g_assert (bwrap->envp != NULL);\n+      g_assert (bwrap->envp[0] == NULL);\n \n       if (!g_spawn_async (NULL,\n                           (char **) bwrap->argv->pdata,\n@@ -472,6 +480,12 @@\n        * we do want to allow inheriting fds into flatpak run. */\n       flatpak_bwrap_child_setup (bwrap->fds, FALSE);\n \n+      /* flatpak_bwrap_envp_to_args() moved the environment variables to\n+       * be set into --setenv instructions in argv, so the environment\n+       * in which the bwrap command runs must be empty. */\n+      g_assert (bwrap->envp != NULL);\n+      g_assert (bwrap->envp[0] == NULL);\n+\n       if (execvpe (flatpak_get_bwrap (), (char **) bwrap->argv->pdata, bwrap->envp) == -1)\n         {\n           g_set_error_literal (error, G_IO_ERROR, g_io_error_from_errno (errno),",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "  flatpak_bwrap_envp_to_args (bwrap);",
                "",
                "",
                "      /* flatpak_bwrap_envp_to_args() moved the environment variables to",
                "       * be set into --setenv instructions in argv, so the environment",
                "       * in which the bwrap command runs must be empty. */",
                "      g_assert (bwrap->envp != NULL);",
                "      g_assert (bwrap->envp[0] == NULL);",
                "      /* flatpak_bwrap_envp_to_args() moved the environment variables to",
                "       * be set into --setenv instructions in argv, so the environment",
                "       * in which the bwrap command runs must be empty. */",
                "      g_assert (bwrap->envp != NULL);",
                "      g_assert (bwrap->envp[0] == NULL);",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2021-21381",
        "func_name": "flatpak/export_desktop_file",
        "description": "Flatpak is a system for building, distributing, and running sandboxed desktop applications on Linux. In Flatpack since version 0.9.4 and before version 1.10.2 has a vulnerability in the \"file forwarding\" feature which can be used by an attacker to gain access to files that would not ordinarily be allowed by the app's permissions. By putting the special tokens `@@` and/or `@@u` in the Exec field of a Flatpak app's .desktop file, a malicious app publisher can trick flatpak into behaving as though the user had chosen to open a target file with their Flatpak app, which automatically makes that file available to the Flatpak app. This is fixed in version 1.10.2. A minimal solution is the first commit \"`Disallow @@ and @@U usage in desktop files`\". The follow-up commits \"`dir: Reserve the whole @@ prefix`\" and \"`dir: Refuse to export .desktop files with suspicious uses of @@ tokens`\" are recommended, but not strictly required. As a workaround, avoid installing Flatpak apps from untrusted sources, or check the contents of the exported `.desktop` files in `exports/share/applications/*.desktop` (typically `~/.local/share/flatpak/exports/share/applications/*.desktop` and `/var/lib/flatpak/exports/share/applications/*.desktop`) to make sure that literal filenames do not follow `@@` or `@@u`.",
        "git_url": "https://github.com/flatpak/flatpak/commit/eb7946bb6248923d8c90fe9b84425fef97ae580d",
        "commit_title": "dir: Reserve the whole @@ prefix",
        "commit_text": " If we add new features analogous to file forwarding later, we might find that we need a different magic token. Let's reserve the whole @@* namespace so we can call it @@something-else.  (cherry picked from commit 1e7e8fdb24b51078f4c48e0711e24a14930ba1f0)",
        "func_before": "static gboolean\nexport_desktop_file (const char         *app,\n                     const char         *branch,\n                     const char         *arch,\n                     GKeyFile           *metadata,\n                     const char * const *previous_ids,\n                     int                 parent_fd,\n                     const char         *name,\n                     struct stat        *stat_buf,\n                     char              **target,\n                     GCancellable       *cancellable,\n                     GError            **error)\n{\n  gboolean ret = FALSE;\n  glnx_autofd int desktop_fd = -1;\n  g_autofree char *tmpfile_name = g_strdup_printf (\"export-desktop-XXXXXX\");\n  g_autoptr(GOutputStream) out_stream = NULL;\n  g_autofree gchar *data = NULL;\n  gsize data_len;\n  g_autofree gchar *new_data = NULL;\n  gsize new_data_len;\n  g_autoptr(GKeyFile) keyfile = NULL;\n  g_autofree gchar *old_exec = NULL;\n  gint old_argc;\n  g_auto(GStrv) old_argv = NULL;\n  g_auto(GStrv) groups = NULL;\n  GString *new_exec = NULL;\n  g_autofree char *escaped_app = maybe_quote (app);\n  g_autofree char *escaped_branch = maybe_quote (branch);\n  g_autofree char *escaped_arch = maybe_quote (arch);\n  int i;\n\n  if (!flatpak_openat_noatime (parent_fd, name, &desktop_fd, cancellable, error))\n    goto out;\n\n  if (!read_fd (desktop_fd, stat_buf, &data, &data_len, error))\n    goto out;\n\n  keyfile = g_key_file_new ();\n  if (!g_key_file_load_from_data (keyfile, data, data_len, G_KEY_FILE_KEEP_TRANSLATIONS, error))\n    goto out;\n\n  if (g_str_has_suffix (name, \".service\"))\n    {\n      g_autofree gchar *dbus_name = NULL;\n      g_autofree gchar *expected_dbus_name = g_strndup (name, strlen (name) - strlen (\".service\"));\n\n      dbus_name = g_key_file_get_string (keyfile, \"D-BUS Service\", \"Name\", NULL);\n\n      if (dbus_name == NULL || strcmp (dbus_name, expected_dbus_name) != 0)\n        {\n          return flatpak_fail_error (error, FLATPAK_ERROR_EXPORT_FAILED,\n                                     _(\"D-Bus service file '%s' has wrong name\"), name);\n        }\n    }\n\n  if (g_str_has_suffix (name, \".desktop\"))\n    {\n      gsize length;\n      g_auto(GStrv) tags = g_key_file_get_string_list (metadata,\n                                                       \"Application\",\n                                                       \"tags\", &length,\n                                                       NULL);\n\n      if (tags != NULL)\n        {\n          g_key_file_set_string_list (keyfile,\n                                      G_KEY_FILE_DESKTOP_GROUP,\n                                      \"X-Flatpak-Tags\",\n                                      (const char * const *) tags, length);\n        }\n\n      /* Add a marker so consumers can easily find out that this launches a sandbox */\n      g_key_file_set_string (keyfile, G_KEY_FILE_DESKTOP_GROUP, \"X-Flatpak\", app);\n\n      /* If the app has been renamed, add its old .desktop filename to\n       * X-Flatpak-RenamedFrom in the new .desktop file, taking care not to\n       * introduce duplicates.\n       */\n      if (previous_ids != NULL)\n        {\n          const char *X_FLATPAK_RENAMED_FROM = \"X-Flatpak-RenamedFrom\";\n          g_auto(GStrv) renamed_from = g_key_file_get_string_list (keyfile,\n                                                                   G_KEY_FILE_DESKTOP_GROUP,\n                                                                   X_FLATPAK_RENAMED_FROM,\n                                                                   NULL, NULL);\n          g_autoptr(GPtrArray) merged = g_ptr_array_new_with_free_func (g_free);\n          g_autoptr(GHashTable) seen = g_hash_table_new (g_str_hash, g_str_equal);\n          const char *new_suffix;\n\n          for (i = 0; renamed_from != NULL && renamed_from[i] != NULL; i++)\n            {\n              if (!g_hash_table_contains (seen, renamed_from[i]))\n                {\n                  gchar *copy = g_strdup (renamed_from[i]);\n                  g_hash_table_insert (seen, copy, copy);\n                  g_ptr_array_add (merged, g_steal_pointer (&copy));\n                }\n            }\n\n          /* If an app was renamed from com.example.Foo to net.example.Bar, and\n           * the new version exports net.example.Bar-suffix.desktop, we assume the\n           * old version exported com.example.Foo-suffix.desktop.\n           *\n           * This assertion is true because\n           * flatpak_name_matches_one_wildcard_prefix() is called on all\n           * exported files before we get here.\n           */\n          g_assert (g_str_has_prefix (name, app));\n          /* \".desktop\" for the \"main\" desktop file; something like\n           * \"-suffix.desktop\" for extra ones.\n           */\n          new_suffix = name + strlen (app);\n\n          for (i = 0; previous_ids[i] != NULL; i++)\n            {\n              g_autofree gchar *previous_desktop = g_strconcat (previous_ids[i], new_suffix, NULL);\n              if (!g_hash_table_contains (seen, previous_desktop))\n                {\n                  g_hash_table_insert (seen, previous_desktop, previous_desktop);\n                  g_ptr_array_add (merged, g_steal_pointer (&previous_desktop));\n                }\n            }\n\n          if (merged->len > 0)\n            {\n              g_ptr_array_add (merged, NULL);\n              g_key_file_set_string_list (keyfile,\n                                          G_KEY_FILE_DESKTOP_GROUP,\n                                          X_FLATPAK_RENAMED_FROM,\n                                          (const char * const *) merged->pdata,\n                                          merged->len - 1);\n            }\n        }\n    }\n\n  groups = g_key_file_get_groups (keyfile, NULL);\n\n  for (i = 0; groups[i] != NULL; i++)\n    {\n      g_auto(GStrv) flatpak_run_opts = g_key_file_get_string_list (keyfile, groups[i], \"X-Flatpak-RunOptions\", NULL, NULL);\n      g_autofree char *flatpak_run_args = format_flatpak_run_args_from_run_opts (flatpak_run_opts);\n\n      g_key_file_remove_key (keyfile, groups[i], \"X-Flatpak-RunOptions\", NULL);\n      g_key_file_remove_key (keyfile, groups[i], \"TryExec\", NULL);\n\n      /* Remove this to make sure nothing tries to execute it outside the sandbox*/\n      g_key_file_remove_key (keyfile, groups[i], \"X-GNOME-Bugzilla-ExtraInfoScript\", NULL);\n\n      new_exec = g_string_new (\"\");\n      g_string_append_printf (new_exec,\n                              FLATPAK_BINDIR \"/flatpak run --branch=%s --arch=%s\",\n                              escaped_branch,\n                              escaped_arch);\n\n      if (flatpak_run_args != NULL)\n        g_string_append_printf (new_exec, \"%s\", flatpak_run_args);\n\n      old_exec = g_key_file_get_string (keyfile, groups[i], \"Exec\", NULL);\n      if (old_exec && g_shell_parse_argv (old_exec, &old_argc, &old_argv, NULL) && old_argc >= 1)\n        {\n          int j;\n          g_autofree char *command = maybe_quote (old_argv[0]);\n\n          g_string_append_printf (new_exec, \" --command=%s\", command);\n\n          for (j = 1; j < old_argc; j++)\n            {\n              if (strcasecmp (old_argv[j], \"%f\") == 0 ||\n                  strcasecmp (old_argv[j], \"%u\") == 0)\n                {\n                  g_string_append (new_exec, \" --file-forwarding\");\n                  break;\n                }\n            }\n\n          g_string_append (new_exec, \" \");\n          g_string_append (new_exec, escaped_app);\n\n          for (j = 1; j < old_argc; j++)\n            {\n              g_autofree char *arg = maybe_quote (old_argv[j]);\n\n              if (strcasecmp (arg, \"%f\") == 0)\n                g_string_append_printf (new_exec, \" @@ %s @@\", arg);\n              else if (strcasecmp (arg, \"%u\") == 0)\n                g_string_append_printf (new_exec, \" @@u %s @@\", arg);\n              else if (strcmp (arg, \"@@\") == 0 || strcmp (arg, \"@@u\") == 0)\n                g_print (_(\"Skipping invalid Exec argument %s\\n\"), arg);\n              else\n                g_string_append_printf (new_exec, \" %s\", arg);\n            }\n        }\n      else\n        {\n          g_string_append (new_exec, \" \");\n          g_string_append (new_exec, escaped_app);\n        }\n\n      g_key_file_set_string (keyfile, groups[i], G_KEY_FILE_DESKTOP_KEY_EXEC, new_exec->str);\n    }\n\n  new_data = g_key_file_to_data (keyfile, &new_data_len, error);\n  if (new_data == NULL)\n    goto out;\n\n  if (!flatpak_open_in_tmpdir_at (parent_fd, 0755, tmpfile_name, &out_stream, cancellable, error))\n    goto out;\n\n  if (!g_output_stream_write_all (out_stream, new_data, new_data_len, NULL, cancellable, error))\n    goto out;\n\n  if (!g_output_stream_close (out_stream, cancellable, error))\n    goto out;\n\n  if (target)\n    *target = g_steal_pointer (&tmpfile_name);\n\n  ret = TRUE;\nout:\n\n  if (new_exec != NULL)\n    g_string_free (new_exec, TRUE);\n\n  return ret;\n}",
        "func": "static gboolean\nexport_desktop_file (const char         *app,\n                     const char         *branch,\n                     const char         *arch,\n                     GKeyFile           *metadata,\n                     const char * const *previous_ids,\n                     int                 parent_fd,\n                     const char         *name,\n                     struct stat        *stat_buf,\n                     char              **target,\n                     GCancellable       *cancellable,\n                     GError            **error)\n{\n  gboolean ret = FALSE;\n  glnx_autofd int desktop_fd = -1;\n  g_autofree char *tmpfile_name = g_strdup_printf (\"export-desktop-XXXXXX\");\n  g_autoptr(GOutputStream) out_stream = NULL;\n  g_autofree gchar *data = NULL;\n  gsize data_len;\n  g_autofree gchar *new_data = NULL;\n  gsize new_data_len;\n  g_autoptr(GKeyFile) keyfile = NULL;\n  g_autofree gchar *old_exec = NULL;\n  gint old_argc;\n  g_auto(GStrv) old_argv = NULL;\n  g_auto(GStrv) groups = NULL;\n  GString *new_exec = NULL;\n  g_autofree char *escaped_app = maybe_quote (app);\n  g_autofree char *escaped_branch = maybe_quote (branch);\n  g_autofree char *escaped_arch = maybe_quote (arch);\n  int i;\n\n  if (!flatpak_openat_noatime (parent_fd, name, &desktop_fd, cancellable, error))\n    goto out;\n\n  if (!read_fd (desktop_fd, stat_buf, &data, &data_len, error))\n    goto out;\n\n  keyfile = g_key_file_new ();\n  if (!g_key_file_load_from_data (keyfile, data, data_len, G_KEY_FILE_KEEP_TRANSLATIONS, error))\n    goto out;\n\n  if (g_str_has_suffix (name, \".service\"))\n    {\n      g_autofree gchar *dbus_name = NULL;\n      g_autofree gchar *expected_dbus_name = g_strndup (name, strlen (name) - strlen (\".service\"));\n\n      dbus_name = g_key_file_get_string (keyfile, \"D-BUS Service\", \"Name\", NULL);\n\n      if (dbus_name == NULL || strcmp (dbus_name, expected_dbus_name) != 0)\n        {\n          return flatpak_fail_error (error, FLATPAK_ERROR_EXPORT_FAILED,\n                                     _(\"D-Bus service file '%s' has wrong name\"), name);\n        }\n    }\n\n  if (g_str_has_suffix (name, \".desktop\"))\n    {\n      gsize length;\n      g_auto(GStrv) tags = g_key_file_get_string_list (metadata,\n                                                       \"Application\",\n                                                       \"tags\", &length,\n                                                       NULL);\n\n      if (tags != NULL)\n        {\n          g_key_file_set_string_list (keyfile,\n                                      G_KEY_FILE_DESKTOP_GROUP,\n                                      \"X-Flatpak-Tags\",\n                                      (const char * const *) tags, length);\n        }\n\n      /* Add a marker so consumers can easily find out that this launches a sandbox */\n      g_key_file_set_string (keyfile, G_KEY_FILE_DESKTOP_GROUP, \"X-Flatpak\", app);\n\n      /* If the app has been renamed, add its old .desktop filename to\n       * X-Flatpak-RenamedFrom in the new .desktop file, taking care not to\n       * introduce duplicates.\n       */\n      if (previous_ids != NULL)\n        {\n          const char *X_FLATPAK_RENAMED_FROM = \"X-Flatpak-RenamedFrom\";\n          g_auto(GStrv) renamed_from = g_key_file_get_string_list (keyfile,\n                                                                   G_KEY_FILE_DESKTOP_GROUP,\n                                                                   X_FLATPAK_RENAMED_FROM,\n                                                                   NULL, NULL);\n          g_autoptr(GPtrArray) merged = g_ptr_array_new_with_free_func (g_free);\n          g_autoptr(GHashTable) seen = g_hash_table_new (g_str_hash, g_str_equal);\n          const char *new_suffix;\n\n          for (i = 0; renamed_from != NULL && renamed_from[i] != NULL; i++)\n            {\n              if (!g_hash_table_contains (seen, renamed_from[i]))\n                {\n                  gchar *copy = g_strdup (renamed_from[i]);\n                  g_hash_table_insert (seen, copy, copy);\n                  g_ptr_array_add (merged, g_steal_pointer (&copy));\n                }\n            }\n\n          /* If an app was renamed from com.example.Foo to net.example.Bar, and\n           * the new version exports net.example.Bar-suffix.desktop, we assume the\n           * old version exported com.example.Foo-suffix.desktop.\n           *\n           * This assertion is true because\n           * flatpak_name_matches_one_wildcard_prefix() is called on all\n           * exported files before we get here.\n           */\n          g_assert (g_str_has_prefix (name, app));\n          /* \".desktop\" for the \"main\" desktop file; something like\n           * \"-suffix.desktop\" for extra ones.\n           */\n          new_suffix = name + strlen (app);\n\n          for (i = 0; previous_ids[i] != NULL; i++)\n            {\n              g_autofree gchar *previous_desktop = g_strconcat (previous_ids[i], new_suffix, NULL);\n              if (!g_hash_table_contains (seen, previous_desktop))\n                {\n                  g_hash_table_insert (seen, previous_desktop, previous_desktop);\n                  g_ptr_array_add (merged, g_steal_pointer (&previous_desktop));\n                }\n            }\n\n          if (merged->len > 0)\n            {\n              g_ptr_array_add (merged, NULL);\n              g_key_file_set_string_list (keyfile,\n                                          G_KEY_FILE_DESKTOP_GROUP,\n                                          X_FLATPAK_RENAMED_FROM,\n                                          (const char * const *) merged->pdata,\n                                          merged->len - 1);\n            }\n        }\n    }\n\n  groups = g_key_file_get_groups (keyfile, NULL);\n\n  for (i = 0; groups[i] != NULL; i++)\n    {\n      g_auto(GStrv) flatpak_run_opts = g_key_file_get_string_list (keyfile, groups[i], \"X-Flatpak-RunOptions\", NULL, NULL);\n      g_autofree char *flatpak_run_args = format_flatpak_run_args_from_run_opts (flatpak_run_opts);\n\n      g_key_file_remove_key (keyfile, groups[i], \"X-Flatpak-RunOptions\", NULL);\n      g_key_file_remove_key (keyfile, groups[i], \"TryExec\", NULL);\n\n      /* Remove this to make sure nothing tries to execute it outside the sandbox*/\n      g_key_file_remove_key (keyfile, groups[i], \"X-GNOME-Bugzilla-ExtraInfoScript\", NULL);\n\n      new_exec = g_string_new (\"\");\n      g_string_append_printf (new_exec,\n                              FLATPAK_BINDIR \"/flatpak run --branch=%s --arch=%s\",\n                              escaped_branch,\n                              escaped_arch);\n\n      if (flatpak_run_args != NULL)\n        g_string_append_printf (new_exec, \"%s\", flatpak_run_args);\n\n      old_exec = g_key_file_get_string (keyfile, groups[i], \"Exec\", NULL);\n      if (old_exec && g_shell_parse_argv (old_exec, &old_argc, &old_argv, NULL) && old_argc >= 1)\n        {\n          int j;\n          g_autofree char *command = maybe_quote (old_argv[0]);\n\n          g_string_append_printf (new_exec, \" --command=%s\", command);\n\n          for (j = 1; j < old_argc; j++)\n            {\n              if (strcasecmp (old_argv[j], \"%f\") == 0 ||\n                  strcasecmp (old_argv[j], \"%u\") == 0)\n                {\n                  g_string_append (new_exec, \" --file-forwarding\");\n                  break;\n                }\n            }\n\n          g_string_append (new_exec, \" \");\n          g_string_append (new_exec, escaped_app);\n\n          for (j = 1; j < old_argc; j++)\n            {\n              g_autofree char *arg = maybe_quote (old_argv[j]);\n\n              if (strcasecmp (arg, \"%f\") == 0)\n                g_string_append_printf (new_exec, \" @@ %s @@\", arg);\n              else if (strcasecmp (arg, \"%u\") == 0)\n                g_string_append_printf (new_exec, \" @@u %s @@\", arg);\n              else if (g_str_has_prefix (arg, \"@@\"))\n                g_print (_(\"Skipping invalid Exec argument %s\\n\"), arg);\n              else\n                g_string_append_printf (new_exec, \" %s\", arg);\n            }\n        }\n      else\n        {\n          g_string_append (new_exec, \" \");\n          g_string_append (new_exec, escaped_app);\n        }\n\n      g_key_file_set_string (keyfile, groups[i], G_KEY_FILE_DESKTOP_KEY_EXEC, new_exec->str);\n    }\n\n  new_data = g_key_file_to_data (keyfile, &new_data_len, error);\n  if (new_data == NULL)\n    goto out;\n\n  if (!flatpak_open_in_tmpdir_at (parent_fd, 0755, tmpfile_name, &out_stream, cancellable, error))\n    goto out;\n\n  if (!g_output_stream_write_all (out_stream, new_data, new_data_len, NULL, cancellable, error))\n    goto out;\n\n  if (!g_output_stream_close (out_stream, cancellable, error))\n    goto out;\n\n  if (target)\n    *target = g_steal_pointer (&tmpfile_name);\n\n  ret = TRUE;\nout:\n\n  if (new_exec != NULL)\n    g_string_free (new_exec, TRUE);\n\n  return ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -185,7 +185,7 @@\n                 g_string_append_printf (new_exec, \" @@ %s @@\", arg);\n               else if (strcasecmp (arg, \"%u\") == 0)\n                 g_string_append_printf (new_exec, \" @@u %s @@\", arg);\n-              else if (strcmp (arg, \"@@\") == 0 || strcmp (arg, \"@@u\") == 0)\n+              else if (g_str_has_prefix (arg, \"@@\"))\n                 g_print (_(\"Skipping invalid Exec argument %s\\n\"), arg);\n               else\n                 g_string_append_printf (new_exec, \" %s\", arg);",
        "diff_line_info": {
            "deleted_lines": [
                "              else if (strcmp (arg, \"@@\") == 0 || strcmp (arg, \"@@u\") == 0)"
            ],
            "added_lines": [
                "              else if (g_str_has_prefix (arg, \"@@\"))"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-21381",
        "func_name": "flatpak/export_desktop_file",
        "description": "Flatpak is a system for building, distributing, and running sandboxed desktop applications on Linux. In Flatpack since version 0.9.4 and before version 1.10.2 has a vulnerability in the \"file forwarding\" feature which can be used by an attacker to gain access to files that would not ordinarily be allowed by the app's permissions. By putting the special tokens `@@` and/or `@@u` in the Exec field of a Flatpak app's .desktop file, a malicious app publisher can trick flatpak into behaving as though the user had chosen to open a target file with their Flatpak app, which automatically makes that file available to the Flatpak app. This is fixed in version 1.10.2. A minimal solution is the first commit \"`Disallow @@ and @@U usage in desktop files`\". The follow-up commits \"`dir: Reserve the whole @@ prefix`\" and \"`dir: Refuse to export .desktop files with suspicious uses of @@ tokens`\" are recommended, but not strictly required. As a workaround, avoid installing Flatpak apps from untrusted sources, or check the contents of the exported `.desktop` files in `exports/share/applications/*.desktop` (typically `~/.local/share/flatpak/exports/share/applications/*.desktop` and `/var/lib/flatpak/exports/share/applications/*.desktop`) to make sure that literal filenames do not follow `@@` or `@@u`.",
        "git_url": "https://github.com/flatpak/flatpak/commit/8279c5818425b6812523e3805bbe242fb6a5d961",
        "commit_title": "Disallow @@ and @@u usage in desktop files",
        "commit_text": " Fixes #4146.  (cherry picked from commit 652a28ffab67cb6cd7d12dc3a93979bcd3731c7f)",
        "func_before": "static gboolean\nexport_desktop_file (const char         *app,\n                     const char         *branch,\n                     const char         *arch,\n                     GKeyFile           *metadata,\n                     const char * const *previous_ids,\n                     int                 parent_fd,\n                     const char         *name,\n                     struct stat        *stat_buf,\n                     char              **target,\n                     GCancellable       *cancellable,\n                     GError            **error)\n{\n  gboolean ret = FALSE;\n  glnx_autofd int desktop_fd = -1;\n  g_autofree char *tmpfile_name = g_strdup_printf (\"export-desktop-XXXXXX\");\n  g_autoptr(GOutputStream) out_stream = NULL;\n  g_autofree gchar *data = NULL;\n  gsize data_len;\n  g_autofree gchar *new_data = NULL;\n  gsize new_data_len;\n  g_autoptr(GKeyFile) keyfile = NULL;\n  g_autofree gchar *old_exec = NULL;\n  gint old_argc;\n  g_auto(GStrv) old_argv = NULL;\n  g_auto(GStrv) groups = NULL;\n  GString *new_exec = NULL;\n  g_autofree char *escaped_app = maybe_quote (app);\n  g_autofree char *escaped_branch = maybe_quote (branch);\n  g_autofree char *escaped_arch = maybe_quote (arch);\n  int i;\n\n  if (!flatpak_openat_noatime (parent_fd, name, &desktop_fd, cancellable, error))\n    goto out;\n\n  if (!read_fd (desktop_fd, stat_buf, &data, &data_len, error))\n    goto out;\n\n  keyfile = g_key_file_new ();\n  if (!g_key_file_load_from_data (keyfile, data, data_len, G_KEY_FILE_KEEP_TRANSLATIONS, error))\n    goto out;\n\n  if (g_str_has_suffix (name, \".service\"))\n    {\n      g_autofree gchar *dbus_name = NULL;\n      g_autofree gchar *expected_dbus_name = g_strndup (name, strlen (name) - strlen (\".service\"));\n\n      dbus_name = g_key_file_get_string (keyfile, \"D-BUS Service\", \"Name\", NULL);\n\n      if (dbus_name == NULL || strcmp (dbus_name, expected_dbus_name) != 0)\n        {\n          return flatpak_fail_error (error, FLATPAK_ERROR_EXPORT_FAILED,\n                                     _(\"D-Bus service file '%s' has wrong name\"), name);\n        }\n    }\n\n  if (g_str_has_suffix (name, \".desktop\"))\n    {\n      gsize length;\n      g_auto(GStrv) tags = g_key_file_get_string_list (metadata,\n                                                       \"Application\",\n                                                       \"tags\", &length,\n                                                       NULL);\n\n      if (tags != NULL)\n        {\n          g_key_file_set_string_list (keyfile,\n                                      G_KEY_FILE_DESKTOP_GROUP,\n                                      \"X-Flatpak-Tags\",\n                                      (const char * const *) tags, length);\n        }\n\n      /* Add a marker so consumers can easily find out that this launches a sandbox */\n      g_key_file_set_string (keyfile, G_KEY_FILE_DESKTOP_GROUP, \"X-Flatpak\", app);\n\n      /* If the app has been renamed, add its old .desktop filename to\n       * X-Flatpak-RenamedFrom in the new .desktop file, taking care not to\n       * introduce duplicates.\n       */\n      if (previous_ids != NULL)\n        {\n          const char *X_FLATPAK_RENAMED_FROM = \"X-Flatpak-RenamedFrom\";\n          g_auto(GStrv) renamed_from = g_key_file_get_string_list (keyfile,\n                                                                   G_KEY_FILE_DESKTOP_GROUP,\n                                                                   X_FLATPAK_RENAMED_FROM,\n                                                                   NULL, NULL);\n          g_autoptr(GPtrArray) merged = g_ptr_array_new_with_free_func (g_free);\n          g_autoptr(GHashTable) seen = g_hash_table_new (g_str_hash, g_str_equal);\n          const char *new_suffix;\n\n          for (i = 0; renamed_from != NULL && renamed_from[i] != NULL; i++)\n            {\n              if (!g_hash_table_contains (seen, renamed_from[i]))\n                {\n                  gchar *copy = g_strdup (renamed_from[i]);\n                  g_hash_table_insert (seen, copy, copy);\n                  g_ptr_array_add (merged, g_steal_pointer (&copy));\n                }\n            }\n\n          /* If an app was renamed from com.example.Foo to net.example.Bar, and\n           * the new version exports net.example.Bar-suffix.desktop, we assume the\n           * old version exported com.example.Foo-suffix.desktop.\n           *\n           * This assertion is true because\n           * flatpak_name_matches_one_wildcard_prefix() is called on all\n           * exported files before we get here.\n           */\n          g_assert (g_str_has_prefix (name, app));\n          /* \".desktop\" for the \"main\" desktop file; something like\n           * \"-suffix.desktop\" for extra ones.\n           */\n          new_suffix = name + strlen (app);\n\n          for (i = 0; previous_ids[i] != NULL; i++)\n            {\n              g_autofree gchar *previous_desktop = g_strconcat (previous_ids[i], new_suffix, NULL);\n              if (!g_hash_table_contains (seen, previous_desktop))\n                {\n                  g_hash_table_insert (seen, previous_desktop, previous_desktop);\n                  g_ptr_array_add (merged, g_steal_pointer (&previous_desktop));\n                }\n            }\n\n          if (merged->len > 0)\n            {\n              g_ptr_array_add (merged, NULL);\n              g_key_file_set_string_list (keyfile,\n                                          G_KEY_FILE_DESKTOP_GROUP,\n                                          X_FLATPAK_RENAMED_FROM,\n                                          (const char * const *) merged->pdata,\n                                          merged->len - 1);\n            }\n        }\n    }\n\n  groups = g_key_file_get_groups (keyfile, NULL);\n\n  for (i = 0; groups[i] != NULL; i++)\n    {\n      g_auto(GStrv) flatpak_run_opts = g_key_file_get_string_list (keyfile, groups[i], \"X-Flatpak-RunOptions\", NULL, NULL);\n      g_autofree char *flatpak_run_args = format_flatpak_run_args_from_run_opts (flatpak_run_opts);\n\n      g_key_file_remove_key (keyfile, groups[i], \"X-Flatpak-RunOptions\", NULL);\n      g_key_file_remove_key (keyfile, groups[i], \"TryExec\", NULL);\n\n      /* Remove this to make sure nothing tries to execute it outside the sandbox*/\n      g_key_file_remove_key (keyfile, groups[i], \"X-GNOME-Bugzilla-ExtraInfoScript\", NULL);\n\n      new_exec = g_string_new (\"\");\n      g_string_append_printf (new_exec,\n                              FLATPAK_BINDIR \"/flatpak run --branch=%s --arch=%s\",\n                              escaped_branch,\n                              escaped_arch);\n\n      if (flatpak_run_args != NULL)\n        g_string_append_printf (new_exec, \"%s\", flatpak_run_args);\n\n      old_exec = g_key_file_get_string (keyfile, groups[i], \"Exec\", NULL);\n      if (old_exec && g_shell_parse_argv (old_exec, &old_argc, &old_argv, NULL) && old_argc >= 1)\n        {\n          int j;\n          g_autofree char *command = maybe_quote (old_argv[0]);\n\n          g_string_append_printf (new_exec, \" --command=%s\", command);\n\n          for (j = 1; j < old_argc; j++)\n            {\n              if (strcasecmp (old_argv[j], \"%f\") == 0 ||\n                  strcasecmp (old_argv[j], \"%u\") == 0)\n                {\n                  g_string_append (new_exec, \" --file-forwarding\");\n                  break;\n                }\n            }\n\n          g_string_append (new_exec, \" \");\n          g_string_append (new_exec, escaped_app);\n\n          for (j = 1; j < old_argc; j++)\n            {\n              g_autofree char *arg = maybe_quote (old_argv[j]);\n\n              if (strcasecmp (arg, \"%f\") == 0)\n                g_string_append_printf (new_exec, \" @@ %s @@\", arg);\n              else if (strcasecmp (arg, \"%u\") == 0)\n                g_string_append_printf (new_exec, \" @@u %s @@\", arg);\n              else\n                g_string_append_printf (new_exec, \" %s\", arg);\n            }\n        }\n      else\n        {\n          g_string_append (new_exec, \" \");\n          g_string_append (new_exec, escaped_app);\n        }\n\n      g_key_file_set_string (keyfile, groups[i], G_KEY_FILE_DESKTOP_KEY_EXEC, new_exec->str);\n    }\n\n  new_data = g_key_file_to_data (keyfile, &new_data_len, error);\n  if (new_data == NULL)\n    goto out;\n\n  if (!flatpak_open_in_tmpdir_at (parent_fd, 0755, tmpfile_name, &out_stream, cancellable, error))\n    goto out;\n\n  if (!g_output_stream_write_all (out_stream, new_data, new_data_len, NULL, cancellable, error))\n    goto out;\n\n  if (!g_output_stream_close (out_stream, cancellable, error))\n    goto out;\n\n  if (target)\n    *target = g_steal_pointer (&tmpfile_name);\n\n  ret = TRUE;\nout:\n\n  if (new_exec != NULL)\n    g_string_free (new_exec, TRUE);\n\n  return ret;\n}",
        "func": "static gboolean\nexport_desktop_file (const char         *app,\n                     const char         *branch,\n                     const char         *arch,\n                     GKeyFile           *metadata,\n                     const char * const *previous_ids,\n                     int                 parent_fd,\n                     const char         *name,\n                     struct stat        *stat_buf,\n                     char              **target,\n                     GCancellable       *cancellable,\n                     GError            **error)\n{\n  gboolean ret = FALSE;\n  glnx_autofd int desktop_fd = -1;\n  g_autofree char *tmpfile_name = g_strdup_printf (\"export-desktop-XXXXXX\");\n  g_autoptr(GOutputStream) out_stream = NULL;\n  g_autofree gchar *data = NULL;\n  gsize data_len;\n  g_autofree gchar *new_data = NULL;\n  gsize new_data_len;\n  g_autoptr(GKeyFile) keyfile = NULL;\n  g_autofree gchar *old_exec = NULL;\n  gint old_argc;\n  g_auto(GStrv) old_argv = NULL;\n  g_auto(GStrv) groups = NULL;\n  GString *new_exec = NULL;\n  g_autofree char *escaped_app = maybe_quote (app);\n  g_autofree char *escaped_branch = maybe_quote (branch);\n  g_autofree char *escaped_arch = maybe_quote (arch);\n  int i;\n\n  if (!flatpak_openat_noatime (parent_fd, name, &desktop_fd, cancellable, error))\n    goto out;\n\n  if (!read_fd (desktop_fd, stat_buf, &data, &data_len, error))\n    goto out;\n\n  keyfile = g_key_file_new ();\n  if (!g_key_file_load_from_data (keyfile, data, data_len, G_KEY_FILE_KEEP_TRANSLATIONS, error))\n    goto out;\n\n  if (g_str_has_suffix (name, \".service\"))\n    {\n      g_autofree gchar *dbus_name = NULL;\n      g_autofree gchar *expected_dbus_name = g_strndup (name, strlen (name) - strlen (\".service\"));\n\n      dbus_name = g_key_file_get_string (keyfile, \"D-BUS Service\", \"Name\", NULL);\n\n      if (dbus_name == NULL || strcmp (dbus_name, expected_dbus_name) != 0)\n        {\n          return flatpak_fail_error (error, FLATPAK_ERROR_EXPORT_FAILED,\n                                     _(\"D-Bus service file '%s' has wrong name\"), name);\n        }\n    }\n\n  if (g_str_has_suffix (name, \".desktop\"))\n    {\n      gsize length;\n      g_auto(GStrv) tags = g_key_file_get_string_list (metadata,\n                                                       \"Application\",\n                                                       \"tags\", &length,\n                                                       NULL);\n\n      if (tags != NULL)\n        {\n          g_key_file_set_string_list (keyfile,\n                                      G_KEY_FILE_DESKTOP_GROUP,\n                                      \"X-Flatpak-Tags\",\n                                      (const char * const *) tags, length);\n        }\n\n      /* Add a marker so consumers can easily find out that this launches a sandbox */\n      g_key_file_set_string (keyfile, G_KEY_FILE_DESKTOP_GROUP, \"X-Flatpak\", app);\n\n      /* If the app has been renamed, add its old .desktop filename to\n       * X-Flatpak-RenamedFrom in the new .desktop file, taking care not to\n       * introduce duplicates.\n       */\n      if (previous_ids != NULL)\n        {\n          const char *X_FLATPAK_RENAMED_FROM = \"X-Flatpak-RenamedFrom\";\n          g_auto(GStrv) renamed_from = g_key_file_get_string_list (keyfile,\n                                                                   G_KEY_FILE_DESKTOP_GROUP,\n                                                                   X_FLATPAK_RENAMED_FROM,\n                                                                   NULL, NULL);\n          g_autoptr(GPtrArray) merged = g_ptr_array_new_with_free_func (g_free);\n          g_autoptr(GHashTable) seen = g_hash_table_new (g_str_hash, g_str_equal);\n          const char *new_suffix;\n\n          for (i = 0; renamed_from != NULL && renamed_from[i] != NULL; i++)\n            {\n              if (!g_hash_table_contains (seen, renamed_from[i]))\n                {\n                  gchar *copy = g_strdup (renamed_from[i]);\n                  g_hash_table_insert (seen, copy, copy);\n                  g_ptr_array_add (merged, g_steal_pointer (&copy));\n                }\n            }\n\n          /* If an app was renamed from com.example.Foo to net.example.Bar, and\n           * the new version exports net.example.Bar-suffix.desktop, we assume the\n           * old version exported com.example.Foo-suffix.desktop.\n           *\n           * This assertion is true because\n           * flatpak_name_matches_one_wildcard_prefix() is called on all\n           * exported files before we get here.\n           */\n          g_assert (g_str_has_prefix (name, app));\n          /* \".desktop\" for the \"main\" desktop file; something like\n           * \"-suffix.desktop\" for extra ones.\n           */\n          new_suffix = name + strlen (app);\n\n          for (i = 0; previous_ids[i] != NULL; i++)\n            {\n              g_autofree gchar *previous_desktop = g_strconcat (previous_ids[i], new_suffix, NULL);\n              if (!g_hash_table_contains (seen, previous_desktop))\n                {\n                  g_hash_table_insert (seen, previous_desktop, previous_desktop);\n                  g_ptr_array_add (merged, g_steal_pointer (&previous_desktop));\n                }\n            }\n\n          if (merged->len > 0)\n            {\n              g_ptr_array_add (merged, NULL);\n              g_key_file_set_string_list (keyfile,\n                                          G_KEY_FILE_DESKTOP_GROUP,\n                                          X_FLATPAK_RENAMED_FROM,\n                                          (const char * const *) merged->pdata,\n                                          merged->len - 1);\n            }\n        }\n    }\n\n  groups = g_key_file_get_groups (keyfile, NULL);\n\n  for (i = 0; groups[i] != NULL; i++)\n    {\n      g_auto(GStrv) flatpak_run_opts = g_key_file_get_string_list (keyfile, groups[i], \"X-Flatpak-RunOptions\", NULL, NULL);\n      g_autofree char *flatpak_run_args = format_flatpak_run_args_from_run_opts (flatpak_run_opts);\n\n      g_key_file_remove_key (keyfile, groups[i], \"X-Flatpak-RunOptions\", NULL);\n      g_key_file_remove_key (keyfile, groups[i], \"TryExec\", NULL);\n\n      /* Remove this to make sure nothing tries to execute it outside the sandbox*/\n      g_key_file_remove_key (keyfile, groups[i], \"X-GNOME-Bugzilla-ExtraInfoScript\", NULL);\n\n      new_exec = g_string_new (\"\");\n      g_string_append_printf (new_exec,\n                              FLATPAK_BINDIR \"/flatpak run --branch=%s --arch=%s\",\n                              escaped_branch,\n                              escaped_arch);\n\n      if (flatpak_run_args != NULL)\n        g_string_append_printf (new_exec, \"%s\", flatpak_run_args);\n\n      old_exec = g_key_file_get_string (keyfile, groups[i], \"Exec\", NULL);\n      if (old_exec && g_shell_parse_argv (old_exec, &old_argc, &old_argv, NULL) && old_argc >= 1)\n        {\n          int j;\n          g_autofree char *command = maybe_quote (old_argv[0]);\n\n          g_string_append_printf (new_exec, \" --command=%s\", command);\n\n          for (j = 1; j < old_argc; j++)\n            {\n              if (strcasecmp (old_argv[j], \"%f\") == 0 ||\n                  strcasecmp (old_argv[j], \"%u\") == 0)\n                {\n                  g_string_append (new_exec, \" --file-forwarding\");\n                  break;\n                }\n            }\n\n          g_string_append (new_exec, \" \");\n          g_string_append (new_exec, escaped_app);\n\n          for (j = 1; j < old_argc; j++)\n            {\n              g_autofree char *arg = maybe_quote (old_argv[j]);\n\n              if (strcasecmp (arg, \"%f\") == 0)\n                g_string_append_printf (new_exec, \" @@ %s @@\", arg);\n              else if (strcasecmp (arg, \"%u\") == 0)\n                g_string_append_printf (new_exec, \" @@u %s @@\", arg);\n              else if (strcmp (arg, \"@@\") == 0 || strcmp (arg, \"@@u\") == 0)\n                g_print (_(\"Skipping invalid Exec argument %s\\n\"), arg);\n              else\n                g_string_append_printf (new_exec, \" %s\", arg);\n            }\n        }\n      else\n        {\n          g_string_append (new_exec, \" \");\n          g_string_append (new_exec, escaped_app);\n        }\n\n      g_key_file_set_string (keyfile, groups[i], G_KEY_FILE_DESKTOP_KEY_EXEC, new_exec->str);\n    }\n\n  new_data = g_key_file_to_data (keyfile, &new_data_len, error);\n  if (new_data == NULL)\n    goto out;\n\n  if (!flatpak_open_in_tmpdir_at (parent_fd, 0755, tmpfile_name, &out_stream, cancellable, error))\n    goto out;\n\n  if (!g_output_stream_write_all (out_stream, new_data, new_data_len, NULL, cancellable, error))\n    goto out;\n\n  if (!g_output_stream_close (out_stream, cancellable, error))\n    goto out;\n\n  if (target)\n    *target = g_steal_pointer (&tmpfile_name);\n\n  ret = TRUE;\nout:\n\n  if (new_exec != NULL)\n    g_string_free (new_exec, TRUE);\n\n  return ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -185,6 +185,8 @@\n                 g_string_append_printf (new_exec, \" @@ %s @@\", arg);\n               else if (strcasecmp (arg, \"%u\") == 0)\n                 g_string_append_printf (new_exec, \" @@u %s @@\", arg);\n+              else if (strcmp (arg, \"@@\") == 0 || strcmp (arg, \"@@u\") == 0)\n+                g_print (_(\"Skipping invalid Exec argument %s\\n\"), arg);\n               else\n                 g_string_append_printf (new_exec, \" %s\", arg);\n             }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "              else if (strcmp (arg, \"@@\") == 0 || strcmp (arg, \"@@u\") == 0)",
                "                g_print (_(\"Skipping invalid Exec argument %s\\n\"), arg);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-21381",
        "func_name": "flatpak/export_desktop_file",
        "description": "Flatpak is a system for building, distributing, and running sandboxed desktop applications on Linux. In Flatpack since version 0.9.4 and before version 1.10.2 has a vulnerability in the \"file forwarding\" feature which can be used by an attacker to gain access to files that would not ordinarily be allowed by the app's permissions. By putting the special tokens `@@` and/or `@@u` in the Exec field of a Flatpak app's .desktop file, a malicious app publisher can trick flatpak into behaving as though the user had chosen to open a target file with their Flatpak app, which automatically makes that file available to the Flatpak app. This is fixed in version 1.10.2. A minimal solution is the first commit \"`Disallow @@ and @@U usage in desktop files`\". The follow-up commits \"`dir: Reserve the whole @@ prefix`\" and \"`dir: Refuse to export .desktop files with suspicious uses of @@ tokens`\" are recommended, but not strictly required. As a workaround, avoid installing Flatpak apps from untrusted sources, or check the contents of the exported `.desktop` files in `exports/share/applications/*.desktop` (typically `~/.local/share/flatpak/exports/share/applications/*.desktop` and `/var/lib/flatpak/exports/share/applications/*.desktop`) to make sure that literal filenames do not follow `@@` or `@@u`.",
        "git_url": "https://github.com/flatpak/flatpak/commit/a7401e638bf0c03102039e216ab1081922f140ae",
        "commit_title": "dir: Refuse to export .desktop files with suspicious uses of @@ tokens",
        "commit_text": " This is either a malicious/compromised app trying to do an attack, or a mistake that will break handling of %f, %u and so on. Either way, if we refuse to export the .desktop file, resulting in installation failing, then it makes the rejection more obvious than quietly removing the magic tokens.  (cherry picked from commit 46b3ede5241561c7d588951048c687c5075a3eac)",
        "func_before": "static gboolean\nexport_desktop_file (const char         *app,\n                     const char         *branch,\n                     const char         *arch,\n                     GKeyFile           *metadata,\n                     const char * const *previous_ids,\n                     int                 parent_fd,\n                     const char         *name,\n                     struct stat        *stat_buf,\n                     char              **target,\n                     GCancellable       *cancellable,\n                     GError            **error)\n{\n  gboolean ret = FALSE;\n  glnx_autofd int desktop_fd = -1;\n  g_autofree char *tmpfile_name = g_strdup_printf (\"export-desktop-XXXXXX\");\n  g_autoptr(GOutputStream) out_stream = NULL;\n  g_autofree gchar *data = NULL;\n  gsize data_len;\n  g_autofree gchar *new_data = NULL;\n  gsize new_data_len;\n  g_autoptr(GKeyFile) keyfile = NULL;\n  g_autofree gchar *old_exec = NULL;\n  gint old_argc;\n  g_auto(GStrv) old_argv = NULL;\n  g_auto(GStrv) groups = NULL;\n  GString *new_exec = NULL;\n  g_autofree char *escaped_app = maybe_quote (app);\n  g_autofree char *escaped_branch = maybe_quote (branch);\n  g_autofree char *escaped_arch = maybe_quote (arch);\n  int i;\n\n  if (!flatpak_openat_noatime (parent_fd, name, &desktop_fd, cancellable, error))\n    goto out;\n\n  if (!read_fd (desktop_fd, stat_buf, &data, &data_len, error))\n    goto out;\n\n  keyfile = g_key_file_new ();\n  if (!g_key_file_load_from_data (keyfile, data, data_len, G_KEY_FILE_KEEP_TRANSLATIONS, error))\n    goto out;\n\n  if (g_str_has_suffix (name, \".service\"))\n    {\n      g_autofree gchar *dbus_name = NULL;\n      g_autofree gchar *expected_dbus_name = g_strndup (name, strlen (name) - strlen (\".service\"));\n\n      dbus_name = g_key_file_get_string (keyfile, \"D-BUS Service\", \"Name\", NULL);\n\n      if (dbus_name == NULL || strcmp (dbus_name, expected_dbus_name) != 0)\n        {\n          return flatpak_fail_error (error, FLATPAK_ERROR_EXPORT_FAILED,\n                                     _(\"D-Bus service file '%s' has wrong name\"), name);\n        }\n    }\n\n  if (g_str_has_suffix (name, \".desktop\"))\n    {\n      gsize length;\n      g_auto(GStrv) tags = g_key_file_get_string_list (metadata,\n                                                       \"Application\",\n                                                       \"tags\", &length,\n                                                       NULL);\n\n      if (tags != NULL)\n        {\n          g_key_file_set_string_list (keyfile,\n                                      G_KEY_FILE_DESKTOP_GROUP,\n                                      \"X-Flatpak-Tags\",\n                                      (const char * const *) tags, length);\n        }\n\n      /* Add a marker so consumers can easily find out that this launches a sandbox */\n      g_key_file_set_string (keyfile, G_KEY_FILE_DESKTOP_GROUP, \"X-Flatpak\", app);\n\n      /* If the app has been renamed, add its old .desktop filename to\n       * X-Flatpak-RenamedFrom in the new .desktop file, taking care not to\n       * introduce duplicates.\n       */\n      if (previous_ids != NULL)\n        {\n          const char *X_FLATPAK_RENAMED_FROM = \"X-Flatpak-RenamedFrom\";\n          g_auto(GStrv) renamed_from = g_key_file_get_string_list (keyfile,\n                                                                   G_KEY_FILE_DESKTOP_GROUP,\n                                                                   X_FLATPAK_RENAMED_FROM,\n                                                                   NULL, NULL);\n          g_autoptr(GPtrArray) merged = g_ptr_array_new_with_free_func (g_free);\n          g_autoptr(GHashTable) seen = g_hash_table_new (g_str_hash, g_str_equal);\n          const char *new_suffix;\n\n          for (i = 0; renamed_from != NULL && renamed_from[i] != NULL; i++)\n            {\n              if (!g_hash_table_contains (seen, renamed_from[i]))\n                {\n                  gchar *copy = g_strdup (renamed_from[i]);\n                  g_hash_table_insert (seen, copy, copy);\n                  g_ptr_array_add (merged, g_steal_pointer (&copy));\n                }\n            }\n\n          /* If an app was renamed from com.example.Foo to net.example.Bar, and\n           * the new version exports net.example.Bar-suffix.desktop, we assume the\n           * old version exported com.example.Foo-suffix.desktop.\n           *\n           * This assertion is true because\n           * flatpak_name_matches_one_wildcard_prefix() is called on all\n           * exported files before we get here.\n           */\n          g_assert (g_str_has_prefix (name, app));\n          /* \".desktop\" for the \"main\" desktop file; something like\n           * \"-suffix.desktop\" for extra ones.\n           */\n          new_suffix = name + strlen (app);\n\n          for (i = 0; previous_ids[i] != NULL; i++)\n            {\n              g_autofree gchar *previous_desktop = g_strconcat (previous_ids[i], new_suffix, NULL);\n              if (!g_hash_table_contains (seen, previous_desktop))\n                {\n                  g_hash_table_insert (seen, previous_desktop, previous_desktop);\n                  g_ptr_array_add (merged, g_steal_pointer (&previous_desktop));\n                }\n            }\n\n          if (merged->len > 0)\n            {\n              g_ptr_array_add (merged, NULL);\n              g_key_file_set_string_list (keyfile,\n                                          G_KEY_FILE_DESKTOP_GROUP,\n                                          X_FLATPAK_RENAMED_FROM,\n                                          (const char * const *) merged->pdata,\n                                          merged->len - 1);\n            }\n        }\n    }\n\n  groups = g_key_file_get_groups (keyfile, NULL);\n\n  for (i = 0; groups[i] != NULL; i++)\n    {\n      g_auto(GStrv) flatpak_run_opts = g_key_file_get_string_list (keyfile, groups[i], \"X-Flatpak-RunOptions\", NULL, NULL);\n      g_autofree char *flatpak_run_args = format_flatpak_run_args_from_run_opts (flatpak_run_opts);\n\n      g_key_file_remove_key (keyfile, groups[i], \"X-Flatpak-RunOptions\", NULL);\n      g_key_file_remove_key (keyfile, groups[i], \"TryExec\", NULL);\n\n      /* Remove this to make sure nothing tries to execute it outside the sandbox*/\n      g_key_file_remove_key (keyfile, groups[i], \"X-GNOME-Bugzilla-ExtraInfoScript\", NULL);\n\n      new_exec = g_string_new (\"\");\n      g_string_append_printf (new_exec,\n                              FLATPAK_BINDIR \"/flatpak run --branch=%s --arch=%s\",\n                              escaped_branch,\n                              escaped_arch);\n\n      if (flatpak_run_args != NULL)\n        g_string_append_printf (new_exec, \"%s\", flatpak_run_args);\n\n      old_exec = g_key_file_get_string (keyfile, groups[i], \"Exec\", NULL);\n      if (old_exec && g_shell_parse_argv (old_exec, &old_argc, &old_argv, NULL) && old_argc >= 1)\n        {\n          int j;\n          g_autofree char *command = maybe_quote (old_argv[0]);\n\n          g_string_append_printf (new_exec, \" --command=%s\", command);\n\n          for (j = 1; j < old_argc; j++)\n            {\n              if (strcasecmp (old_argv[j], \"%f\") == 0 ||\n                  strcasecmp (old_argv[j], \"%u\") == 0)\n                {\n                  g_string_append (new_exec, \" --file-forwarding\");\n                  break;\n                }\n            }\n\n          g_string_append (new_exec, \" \");\n          g_string_append (new_exec, escaped_app);\n\n          for (j = 1; j < old_argc; j++)\n            {\n              g_autofree char *arg = maybe_quote (old_argv[j]);\n\n              if (strcasecmp (arg, \"%f\") == 0)\n                g_string_append_printf (new_exec, \" @@ %s @@\", arg);\n              else if (strcasecmp (arg, \"%u\") == 0)\n                g_string_append_printf (new_exec, \" @@u %s @@\", arg);\n              else if (g_str_has_prefix (arg, \"@@\"))\n                g_print (_(\"Skipping invalid Exec argument %s\\n\"), arg);\n              else\n                g_string_append_printf (new_exec, \" %s\", arg);\n            }\n        }\n      else\n        {\n          g_string_append (new_exec, \" \");\n          g_string_append (new_exec, escaped_app);\n        }\n\n      g_key_file_set_string (keyfile, groups[i], G_KEY_FILE_DESKTOP_KEY_EXEC, new_exec->str);\n    }\n\n  new_data = g_key_file_to_data (keyfile, &new_data_len, error);\n  if (new_data == NULL)\n    goto out;\n\n  if (!flatpak_open_in_tmpdir_at (parent_fd, 0755, tmpfile_name, &out_stream, cancellable, error))\n    goto out;\n\n  if (!g_output_stream_write_all (out_stream, new_data, new_data_len, NULL, cancellable, error))\n    goto out;\n\n  if (!g_output_stream_close (out_stream, cancellable, error))\n    goto out;\n\n  if (target)\n    *target = g_steal_pointer (&tmpfile_name);\n\n  ret = TRUE;\nout:\n\n  if (new_exec != NULL)\n    g_string_free (new_exec, TRUE);\n\n  return ret;\n}",
        "func": "static gboolean\nexport_desktop_file (const char         *app,\n                     const char         *branch,\n                     const char         *arch,\n                     GKeyFile           *metadata,\n                     const char * const *previous_ids,\n                     int                 parent_fd,\n                     const char         *name,\n                     struct stat        *stat_buf,\n                     char              **target,\n                     GCancellable       *cancellable,\n                     GError            **error)\n{\n  gboolean ret = FALSE;\n  glnx_autofd int desktop_fd = -1;\n  g_autofree char *tmpfile_name = g_strdup_printf (\"export-desktop-XXXXXX\");\n  g_autoptr(GOutputStream) out_stream = NULL;\n  g_autofree gchar *data = NULL;\n  gsize data_len;\n  g_autofree gchar *new_data = NULL;\n  gsize new_data_len;\n  g_autoptr(GKeyFile) keyfile = NULL;\n  g_autofree gchar *old_exec = NULL;\n  gint old_argc;\n  g_auto(GStrv) old_argv = NULL;\n  g_auto(GStrv) groups = NULL;\n  GString *new_exec = NULL;\n  g_autofree char *escaped_app = maybe_quote (app);\n  g_autofree char *escaped_branch = maybe_quote (branch);\n  g_autofree char *escaped_arch = maybe_quote (arch);\n  int i;\n\n  if (!flatpak_openat_noatime (parent_fd, name, &desktop_fd, cancellable, error))\n    goto out;\n\n  if (!read_fd (desktop_fd, stat_buf, &data, &data_len, error))\n    goto out;\n\n  keyfile = g_key_file_new ();\n  if (!g_key_file_load_from_data (keyfile, data, data_len, G_KEY_FILE_KEEP_TRANSLATIONS, error))\n    goto out;\n\n  if (g_str_has_suffix (name, \".service\"))\n    {\n      g_autofree gchar *dbus_name = NULL;\n      g_autofree gchar *expected_dbus_name = g_strndup (name, strlen (name) - strlen (\".service\"));\n\n      dbus_name = g_key_file_get_string (keyfile, \"D-BUS Service\", \"Name\", NULL);\n\n      if (dbus_name == NULL || strcmp (dbus_name, expected_dbus_name) != 0)\n        {\n          return flatpak_fail_error (error, FLATPAK_ERROR_EXPORT_FAILED,\n                                     _(\"D-Bus service file '%s' has wrong name\"), name);\n        }\n    }\n\n  if (g_str_has_suffix (name, \".desktop\"))\n    {\n      gsize length;\n      g_auto(GStrv) tags = g_key_file_get_string_list (metadata,\n                                                       \"Application\",\n                                                       \"tags\", &length,\n                                                       NULL);\n\n      if (tags != NULL)\n        {\n          g_key_file_set_string_list (keyfile,\n                                      G_KEY_FILE_DESKTOP_GROUP,\n                                      \"X-Flatpak-Tags\",\n                                      (const char * const *) tags, length);\n        }\n\n      /* Add a marker so consumers can easily find out that this launches a sandbox */\n      g_key_file_set_string (keyfile, G_KEY_FILE_DESKTOP_GROUP, \"X-Flatpak\", app);\n\n      /* If the app has been renamed, add its old .desktop filename to\n       * X-Flatpak-RenamedFrom in the new .desktop file, taking care not to\n       * introduce duplicates.\n       */\n      if (previous_ids != NULL)\n        {\n          const char *X_FLATPAK_RENAMED_FROM = \"X-Flatpak-RenamedFrom\";\n          g_auto(GStrv) renamed_from = g_key_file_get_string_list (keyfile,\n                                                                   G_KEY_FILE_DESKTOP_GROUP,\n                                                                   X_FLATPAK_RENAMED_FROM,\n                                                                   NULL, NULL);\n          g_autoptr(GPtrArray) merged = g_ptr_array_new_with_free_func (g_free);\n          g_autoptr(GHashTable) seen = g_hash_table_new (g_str_hash, g_str_equal);\n          const char *new_suffix;\n\n          for (i = 0; renamed_from != NULL && renamed_from[i] != NULL; i++)\n            {\n              if (!g_hash_table_contains (seen, renamed_from[i]))\n                {\n                  gchar *copy = g_strdup (renamed_from[i]);\n                  g_hash_table_insert (seen, copy, copy);\n                  g_ptr_array_add (merged, g_steal_pointer (&copy));\n                }\n            }\n\n          /* If an app was renamed from com.example.Foo to net.example.Bar, and\n           * the new version exports net.example.Bar-suffix.desktop, we assume the\n           * old version exported com.example.Foo-suffix.desktop.\n           *\n           * This assertion is true because\n           * flatpak_name_matches_one_wildcard_prefix() is called on all\n           * exported files before we get here.\n           */\n          g_assert (g_str_has_prefix (name, app));\n          /* \".desktop\" for the \"main\" desktop file; something like\n           * \"-suffix.desktop\" for extra ones.\n           */\n          new_suffix = name + strlen (app);\n\n          for (i = 0; previous_ids[i] != NULL; i++)\n            {\n              g_autofree gchar *previous_desktop = g_strconcat (previous_ids[i], new_suffix, NULL);\n              if (!g_hash_table_contains (seen, previous_desktop))\n                {\n                  g_hash_table_insert (seen, previous_desktop, previous_desktop);\n                  g_ptr_array_add (merged, g_steal_pointer (&previous_desktop));\n                }\n            }\n\n          if (merged->len > 0)\n            {\n              g_ptr_array_add (merged, NULL);\n              g_key_file_set_string_list (keyfile,\n                                          G_KEY_FILE_DESKTOP_GROUP,\n                                          X_FLATPAK_RENAMED_FROM,\n                                          (const char * const *) merged->pdata,\n                                          merged->len - 1);\n            }\n        }\n    }\n\n  groups = g_key_file_get_groups (keyfile, NULL);\n\n  for (i = 0; groups[i] != NULL; i++)\n    {\n      g_auto(GStrv) flatpak_run_opts = g_key_file_get_string_list (keyfile, groups[i], \"X-Flatpak-RunOptions\", NULL, NULL);\n      g_autofree char *flatpak_run_args = format_flatpak_run_args_from_run_opts (flatpak_run_opts);\n\n      g_key_file_remove_key (keyfile, groups[i], \"X-Flatpak-RunOptions\", NULL);\n      g_key_file_remove_key (keyfile, groups[i], \"TryExec\", NULL);\n\n      /* Remove this to make sure nothing tries to execute it outside the sandbox*/\n      g_key_file_remove_key (keyfile, groups[i], \"X-GNOME-Bugzilla-ExtraInfoScript\", NULL);\n\n      new_exec = g_string_new (\"\");\n      g_string_append_printf (new_exec,\n                              FLATPAK_BINDIR \"/flatpak run --branch=%s --arch=%s\",\n                              escaped_branch,\n                              escaped_arch);\n\n      if (flatpak_run_args != NULL)\n        g_string_append_printf (new_exec, \"%s\", flatpak_run_args);\n\n      old_exec = g_key_file_get_string (keyfile, groups[i], \"Exec\", NULL);\n      if (old_exec && g_shell_parse_argv (old_exec, &old_argc, &old_argv, NULL) && old_argc >= 1)\n        {\n          int j;\n          g_autofree char *command = maybe_quote (old_argv[0]);\n\n          g_string_append_printf (new_exec, \" --command=%s\", command);\n\n          for (j = 1; j < old_argc; j++)\n            {\n              if (strcasecmp (old_argv[j], \"%f\") == 0 ||\n                  strcasecmp (old_argv[j], \"%u\") == 0)\n                {\n                  g_string_append (new_exec, \" --file-forwarding\");\n                  break;\n                }\n            }\n\n          g_string_append (new_exec, \" \");\n          g_string_append (new_exec, escaped_app);\n\n          for (j = 1; j < old_argc; j++)\n            {\n              g_autofree char *arg = maybe_quote (old_argv[j]);\n\n              if (strcasecmp (arg, \"%f\") == 0)\n                g_string_append_printf (new_exec, \" @@ %s @@\", arg);\n              else if (strcasecmp (arg, \"%u\") == 0)\n                g_string_append_printf (new_exec, \" @@u %s @@\", arg);\n              else if (g_str_has_prefix (arg, \"@@\"))\n                {\n                  flatpak_fail_error (error, FLATPAK_ERROR_EXPORT_FAILED,\n                                     _(\"Invalid Exec argument %s\"), arg);\n                  goto out;\n                }\n              else\n                g_string_append_printf (new_exec, \" %s\", arg);\n            }\n        }\n      else\n        {\n          g_string_append (new_exec, \" \");\n          g_string_append (new_exec, escaped_app);\n        }\n\n      g_key_file_set_string (keyfile, groups[i], G_KEY_FILE_DESKTOP_KEY_EXEC, new_exec->str);\n    }\n\n  new_data = g_key_file_to_data (keyfile, &new_data_len, error);\n  if (new_data == NULL)\n    goto out;\n\n  if (!flatpak_open_in_tmpdir_at (parent_fd, 0755, tmpfile_name, &out_stream, cancellable, error))\n    goto out;\n\n  if (!g_output_stream_write_all (out_stream, new_data, new_data_len, NULL, cancellable, error))\n    goto out;\n\n  if (!g_output_stream_close (out_stream, cancellable, error))\n    goto out;\n\n  if (target)\n    *target = g_steal_pointer (&tmpfile_name);\n\n  ret = TRUE;\nout:\n\n  if (new_exec != NULL)\n    g_string_free (new_exec, TRUE);\n\n  return ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -186,7 +186,11 @@\n               else if (strcasecmp (arg, \"%u\") == 0)\n                 g_string_append_printf (new_exec, \" @@u %s @@\", arg);\n               else if (g_str_has_prefix (arg, \"@@\"))\n-                g_print (_(\"Skipping invalid Exec argument %s\\n\"), arg);\n+                {\n+                  flatpak_fail_error (error, FLATPAK_ERROR_EXPORT_FAILED,\n+                                     _(\"Invalid Exec argument %s\"), arg);\n+                  goto out;\n+                }\n               else\n                 g_string_append_printf (new_exec, \" %s\", arg);\n             }",
        "diff_line_info": {
            "deleted_lines": [
                "                g_print (_(\"Skipping invalid Exec argument %s\\n\"), arg);"
            ],
            "added_lines": [
                "                {",
                "                  flatpak_fail_error (error, FLATPAK_ERROR_EXPORT_FAILED,",
                "                                     _(\"Invalid Exec argument %s\"), arg);",
                "                  goto out;",
                "                }"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-22191",
        "func_name": "wireshark/wslua_browser_open_data_file",
        "description": "Improper URL handling in Wireshark 3.4.0 to 3.4.3 and 3.2.0 to 3.2.11 could allow remote code execution via via packet injection or crafted capture file.",
        "git_url": "https://gitlab.com/wireshark/wireshark/-/commit/e99c9afce86edd47b4388dd6e10cf2e758fe31cf",
        "commit_title": "Be more strict about opening URLs.",
        "commit_text": " In the proto tree, copy URLs instead of opening them.  In the export dialog, enable previews only if the advertised MIME type *and* the contents of the file are plain text, GIF, JPEG, or PNG.  Add warnings to the wslua browser_open_url and browser_open_data_file documentation.  Fixes #17232. ",
        "func_before": "WSLUA_FUNCTION wslua_browser_open_data_file(lua_State* L) { /*\n    Open a file located in the data directory (specified in the Wireshark preferences) in the web browser.\n    If the file does not exist, the function silently ignores the request.\n    Requires a GUI.\n    */\n#define WSLUA_ARG_browser_open_data_file_FILENAME 1 /* The file name. */\n    const char* file = luaL_checkstring(L,WSLUA_ARG_browser_open_data_file_FILENAME);\n\n    if (!ops->browser_open_data_file) {\n        WSLUA_ERROR(browser_open_data_file, \"GUI not available\");\n        return 0;\n    }\n\n    ops->browser_open_data_file(file);\n\n    return 0;\n}",
        "func": "WSLUA_FUNCTION wslua_browser_open_data_file(lua_State* L) { /*\n    Open a file located in the data directory (specified in the Wireshark preferences) in the web browser.\n    If the file does not exist, the function silently ignores the request.\n    Requires a GUI.\n\n    [WARNING]\n    ====\n    Do not pass an untrusted URL to this function.\n\n    It will be passed to the system's URL handler, which might execute malicious code, switch on your Bluetooth-connected foghorn, or any of a number of unexpected or harmful things.\n    ====\n    */\n#define WSLUA_ARG_browser_open_data_file_FILENAME 1 /* The file name. */\n    const char* file = luaL_checkstring(L,WSLUA_ARG_browser_open_data_file_FILENAME);\n\n    if (!ops->browser_open_data_file) {\n        WSLUA_ERROR(browser_open_data_file, \"GUI not available\");\n        return 0;\n    }\n\n    ops->browser_open_data_file(file);\n\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,6 +2,13 @@\n     Open a file located in the data directory (specified in the Wireshark preferences) in the web browser.\n     If the file does not exist, the function silently ignores the request.\n     Requires a GUI.\n+\n+    [WARNING]\n+    ====\n+    Do not pass an untrusted URL to this function.\n+\n+    It will be passed to the system's URL handler, which might execute malicious code, switch on your Bluetooth-connected foghorn, or any of a number of unexpected or harmful things.\n+    ====\n     */\n #define WSLUA_ARG_browser_open_data_file_FILENAME 1 /* The file name. */\n     const char* file = luaL_checkstring(L,WSLUA_ARG_browser_open_data_file_FILENAME);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "    [WARNING]",
                "    ====",
                "    Do not pass an untrusted URL to this function.",
                "",
                "    It will be passed to the system's URL handler, which might execute malicious code, switch on your Bluetooth-connected foghorn, or any of a number of unexpected or harmful things.",
                "    ===="
            ]
        }
    },
    {
        "cve_id": "CVE-2021-22191",
        "func_name": "wireshark/wslua_browser_open_url",
        "description": "Improper URL handling in Wireshark 3.4.0 to 3.4.3 and 3.2.0 to 3.2.11 could allow remote code execution via via packet injection or crafted capture file.",
        "git_url": "https://gitlab.com/wireshark/wireshark/-/commit/e99c9afce86edd47b4388dd6e10cf2e758fe31cf",
        "commit_title": "Be more strict about opening URLs.",
        "commit_text": " In the proto tree, copy URLs instead of opening them.  In the export dialog, enable previews only if the advertised MIME type *and* the contents of the file are plain text, GIF, JPEG, or PNG.  Add warnings to the wslua browser_open_url and browser_open_data_file documentation.  Fixes #17232. ",
        "func_before": "WSLUA_FUNCTION wslua_browser_open_url(lua_State* L) { /* Opens an URL in a web browser. Requires a GUI. */\n#define WSLUA_ARG_browser_open_url_URL 1 /* The url. */\n    const char* url = luaL_checkstring(L,WSLUA_ARG_browser_open_url_URL);\n\n    if (!ops->browser_open_url) {\n        WSLUA_ERROR(browser_open_url, \"GUI not available\");\n        return 0;\n    }\n\n    ops->browser_open_url(url);\n\n    return 0;\n}",
        "func": "WSLUA_FUNCTION wslua_browser_open_url(lua_State* L) { /*\n    Opens an URL in a web browser. Requires a GUI.\n\n    [WARNING]\n    ====\n    Do not pass an untrusted URL to this function.\n\n    It will be passed to the system's URL handler, which might execute malicious code, switch on your Bluetooth-connected foghorn, or any of a number of unexpected or harmful things.\n    ====\n    */\n#define WSLUA_ARG_browser_open_url_URL 1 /* The url. */\n    const char* url = luaL_checkstring(L,WSLUA_ARG_browser_open_url_URL);\n\n    if (!ops->browser_open_url) {\n        WSLUA_ERROR(browser_open_url, \"GUI not available\");\n        return 0;\n    }\n\n    ops->browser_open_url(url);\n\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,13 @@\n-WSLUA_FUNCTION wslua_browser_open_url(lua_State* L) { /* Opens an URL in a web browser. Requires a GUI. */\n+WSLUA_FUNCTION wslua_browser_open_url(lua_State* L) { /*\n+    Opens an URL in a web browser. Requires a GUI.\n+\n+    [WARNING]\n+    ====\n+    Do not pass an untrusted URL to this function.\n+\n+    It will be passed to the system's URL handler, which might execute malicious code, switch on your Bluetooth-connected foghorn, or any of a number of unexpected or harmful things.\n+    ====\n+    */\n #define WSLUA_ARG_browser_open_url_URL 1 /* The url. */\n     const char* url = luaL_checkstring(L,WSLUA_ARG_browser_open_url_URL);\n ",
        "diff_line_info": {
            "deleted_lines": [
                "WSLUA_FUNCTION wslua_browser_open_url(lua_State* L) { /* Opens an URL in a web browser. Requires a GUI. */"
            ],
            "added_lines": [
                "WSLUA_FUNCTION wslua_browser_open_url(lua_State* L) { /*",
                "    Opens an URL in a web browser. Requires a GUI.",
                "",
                "    [WARNING]",
                "    ====",
                "    Do not pass an untrusted URL to this function.",
                "",
                "    It will be passed to the system's URL handler, which might execute malicious code, switch on your Bluetooth-connected foghorn, or any of a number of unexpected or harmful things.",
                "    ====",
                "    */"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-22191",
        "func_name": "wireshark/ExportObjectDialog::on_buttonBox_clicked",
        "description": "Improper URL handling in Wireshark 3.4.0 to 3.4.3 and 3.2.0 to 3.2.11 could allow remote code execution via via packet injection or crafted capture file.",
        "git_url": "https://gitlab.com/wireshark/wireshark/-/commit/e99c9afce86edd47b4388dd6e10cf2e758fe31cf",
        "commit_title": "Be more strict about opening URLs.",
        "commit_text": " In the proto tree, copy URLs instead of opening them.  In the export dialog, enable previews only if the advertised MIME type *and* the contents of the file are plain text, GIF, JPEG, or PNG.  Add warnings to the wslua browser_open_url and browser_open_data_file documentation.  Fixes #17232. ",
        "func_before": "void ExportObjectDialog::on_buttonBox_clicked(QAbstractButton *button)\n{\n    switch (eo_ui_->buttonBox->standardButton(button)) {\n    case QDialogButtonBox::Save:\n        saveCurrentEntry();\n        break;\n    case QDialogButtonBox::SaveAll:\n        saveAllEntries();\n        break;\n    case QDialogButtonBox::Open:\n    {\n        QString temp;\n        saveCurrentEntry(&temp);\n\n        if (temp.length() > 0)\n            QDesktopServices::openUrl(QUrl(QString(\"file:///\").append(temp), QUrl::TolerantMode));\n        break;\n    }\n    default: // Help, Cancel\n        break;\n    }\n}",
        "func": "void ExportObjectDialog::on_buttonBox_clicked(QAbstractButton *button)\n{\n    switch (eo_ui_->buttonBox->standardButton(button)) {\n    case QDialogButtonBox::Save:\n        saveCurrentEntry();\n        break;\n    case QDialogButtonBox::SaveAll:\n        saveAllEntries();\n        break;\n    case QDialogButtonBox::Open:\n    {\n        QString temp;\n        saveCurrentEntry(&temp);\n\n        if (temp.length() > 0) {\n            QMimeDatabase mime_db;\n            QMimeType mime_type = mime_db.mimeTypeForFile(temp, QMimeDatabase::MatchContent);\n            if (mimeTypeIsPreviewable(mime_type.name())) {\n                QDesktopServices::openUrl(QUrl(QString(\"file:///\").append(temp), QUrl::TolerantMode));\n            } else {\n                desktop_show_in_folder(temp);\n            }\n\n        }\n        break;\n    }\n    default: // Help, Cancel\n        break;\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -12,8 +12,16 @@\n         QString temp;\n         saveCurrentEntry(&temp);\n \n-        if (temp.length() > 0)\n-            QDesktopServices::openUrl(QUrl(QString(\"file:///\").append(temp), QUrl::TolerantMode));\n+        if (temp.length() > 0) {\n+            QMimeDatabase mime_db;\n+            QMimeType mime_type = mime_db.mimeTypeForFile(temp, QMimeDatabase::MatchContent);\n+            if (mimeTypeIsPreviewable(mime_type.name())) {\n+                QDesktopServices::openUrl(QUrl(QString(\"file:///\").append(temp), QUrl::TolerantMode));\n+            } else {\n+                desktop_show_in_folder(temp);\n+            }\n+\n+        }\n         break;\n     }\n     default: // Help, Cancel",
        "diff_line_info": {
            "deleted_lines": [
                "        if (temp.length() > 0)",
                "            QDesktopServices::openUrl(QUrl(QString(\"file:///\").append(temp), QUrl::TolerantMode));"
            ],
            "added_lines": [
                "        if (temp.length() > 0) {",
                "            QMimeDatabase mime_db;",
                "            QMimeType mime_type = mime_db.mimeTypeForFile(temp, QMimeDatabase::MatchContent);",
                "            if (mimeTypeIsPreviewable(mime_type.name())) {",
                "                QDesktopServices::openUrl(QUrl(QString(\"file:///\").append(temp), QUrl::TolerantMode));",
                "            } else {",
                "                desktop_show_in_folder(temp);",
                "            }",
                "",
                "        }"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-22191",
        "func_name": "wireshark/ExportObjectDialog::currentHasChanged",
        "description": "Improper URL handling in Wireshark 3.4.0 to 3.4.3 and 3.2.0 to 3.2.11 could allow remote code execution via via packet injection or crafted capture file.",
        "git_url": "https://gitlab.com/wireshark/wireshark/-/commit/e99c9afce86edd47b4388dd6e10cf2e758fe31cf",
        "commit_title": "Be more strict about opening URLs.",
        "commit_text": " In the proto tree, copy URLs instead of opening them.  In the export dialog, enable previews only if the advertised MIME type *and* the contents of the file are plain text, GIF, JPEG, or PNG.  Add warnings to the wslua browser_open_url and browser_open_data_file documentation.  Fixes #17232. ",
        "func_before": "void ExportObjectDialog::currentHasChanged(QModelIndex current)\n{\n    if (current.isValid())\n    {\n        QModelIndex sibl = current.sibling(current.row(), ExportObjectModel::colPacket);\n        if (eo_ui_->buttonBox->button(QDialogButtonBox::Open))\n        {\n            QString cont = sibl.sibling(current.row(), ExportObjectModel::colContent).data().toString();\n            /* For security reasons application and unknown are disabled */\n            eo_ui_->buttonBox->button(QDialogButtonBox::Open)->setEnabled(! cont.startsWith(\"application/\") && ! cont.startsWith(\"unknown/\"));\n        }\n        wsApp->gotoFrame(sibl.data().toInt());\n    }\n}",
        "func": "void ExportObjectDialog::currentHasChanged(QModelIndex current)\n{\n    if (current.isValid())\n    {\n        QModelIndex sibl = current.sibling(current.row(), ExportObjectModel::colPacket);\n        if (eo_ui_->buttonBox->button(QDialogButtonBox::Open))\n        {\n            QString mime_type = sibl.sibling(current.row(), ExportObjectModel::colContent).data().toString();\n            eo_ui_->buttonBox->button(QDialogButtonBox::Open)->setEnabled(mimeTypeIsPreviewable(mime_type));\n        }\n        wsApp->gotoFrame(sibl.data().toInt());\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,9 +5,8 @@\n         QModelIndex sibl = current.sibling(current.row(), ExportObjectModel::colPacket);\n         if (eo_ui_->buttonBox->button(QDialogButtonBox::Open))\n         {\n-            QString cont = sibl.sibling(current.row(), ExportObjectModel::colContent).data().toString();\n-            /* For security reasons application and unknown are disabled */\n-            eo_ui_->buttonBox->button(QDialogButtonBox::Open)->setEnabled(! cont.startsWith(\"application/\") && ! cont.startsWith(\"unknown/\"));\n+            QString mime_type = sibl.sibling(current.row(), ExportObjectModel::colContent).data().toString();\n+            eo_ui_->buttonBox->button(QDialogButtonBox::Open)->setEnabled(mimeTypeIsPreviewable(mime_type));\n         }\n         wsApp->gotoFrame(sibl.data().toInt());\n     }",
        "diff_line_info": {
            "deleted_lines": [
                "            QString cont = sibl.sibling(current.row(), ExportObjectModel::colContent).data().toString();",
                "            /* For security reasons application and unknown are disabled */",
                "            eo_ui_->buttonBox->button(QDialogButtonBox::Open)->setEnabled(! cont.startsWith(\"application/\") && ! cont.startsWith(\"unknown/\"));"
            ],
            "added_lines": [
                "            QString mime_type = sibl.sibling(current.row(), ExportObjectModel::colContent).data().toString();",
                "            eo_ui_->buttonBox->button(QDialogButtonBox::Open)->setEnabled(mimeTypeIsPreviewable(mime_type));"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-22191",
        "func_name": "wireshark/ProtoTree::itemDoubleClicked",
        "description": "Improper URL handling in Wireshark 3.4.0 to 3.4.3 and 3.2.0 to 3.2.11 could allow remote code execution via via packet injection or crafted capture file.",
        "git_url": "https://gitlab.com/wireshark/wireshark/-/commit/e99c9afce86edd47b4388dd6e10cf2e758fe31cf",
        "commit_title": "Be more strict about opening URLs.",
        "commit_text": " In the proto tree, copy URLs instead of opening them.  In the export dialog, enable previews only if the advertised MIME type *and* the contents of the file are plain text, GIF, JPEG, or PNG.  Add warnings to the wslua browser_open_url and browser_open_data_file documentation.  Fixes #17232. ",
        "func_before": "void ProtoTree::itemDoubleClicked(const QModelIndex &index)\n{\n    FieldInformation finfo(proto_tree_model_->protoNodeFromIndex(index).protoNode());\n    if (!finfo.isValid()) return;\n\n    if (finfo.headerInfo().type == FT_FRAMENUM) {\n        if (QApplication::queryKeyboardModifiers() & Qt::ShiftModifier) {\n            emit openPacketInNewWindow(true);\n        } else {\n            wsApp->gotoFrame(finfo.fieldInfo()->value.value.uinteger);\n        }\n    } else {\n        QString url = finfo.url();\n        if (!url.isEmpty()) {\n            QDesktopServices::openUrl(QUrl(url));\n        }\n    }\n}",
        "func": "void ProtoTree::itemDoubleClicked(const QModelIndex &index)\n{\n    FieldInformation finfo(proto_tree_model_->protoNodeFromIndex(index).protoNode());\n    if (!finfo.isValid()) return;\n\n    if (finfo.headerInfo().type == FT_FRAMENUM) {\n        if (QApplication::queryKeyboardModifiers() & Qt::ShiftModifier) {\n            emit openPacketInNewWindow(true);\n        } else {\n            wsApp->gotoFrame(finfo.fieldInfo()->value.value.uinteger);\n        }\n    } else {\n        QString url = finfo.url();\n        if (!url.isEmpty()) {\n            QApplication::clipboard()->setText(url);\n            QString push_msg = tr(\"Copied \") + url;\n            wsApp->pushStatus(WiresharkApplication::TemporaryStatus, push_msg);\n        }\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -12,7 +12,9 @@\n     } else {\n         QString url = finfo.url();\n         if (!url.isEmpty()) {\n-            QDesktopServices::openUrl(QUrl(url));\n+            QApplication::clipboard()->setText(url);\n+            QString push_msg = tr(\"Copied \") + url;\n+            wsApp->pushStatus(WiresharkApplication::TemporaryStatus, push_msg);\n         }\n     }\n }",
        "diff_line_info": {
            "deleted_lines": [
                "            QDesktopServices::openUrl(QUrl(url));"
            ],
            "added_lines": [
                "            QApplication::clipboard()->setText(url);",
                "            QString push_msg = tr(\"Copied \") + url;",
                "            wsApp->pushStatus(WiresharkApplication::TemporaryStatus, push_msg);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-22879",
        "func_name": "nextcloud/desktop/ExternalWebEnginePage::acceptNavigationRequest",
        "description": "Nextcloud Desktop Client prior to 3.1.3 is vulnerable to resource injection by way of missing validation of URLs, allowing a malicious server to execute remote commands. User interaction is needed for exploitation.",
        "git_url": "https://github.com/nextcloud/desktop/commit/013f3cea70acfe7b701cb73c93744d5ff5c0c213",
        "commit_title": "Validate sensitive URLs to onle allow http(s) schemes.",
        "commit_text": "",
        "func_before": "bool ExternalWebEnginePage::acceptNavigationRequest(const QUrl &url, QWebEnginePage::NavigationType type, bool isMainFrame)\n{\n    Q_UNUSED(type);\n    Q_UNUSED(isMainFrame);\n    QDesktopServices::openUrl(url);\n    return false;\n}",
        "func": "bool ExternalWebEnginePage::acceptNavigationRequest(const QUrl &url, QWebEnginePage::NavigationType type, bool isMainFrame)\n{\n    Q_UNUSED(type);\n    Q_UNUSED(isMainFrame);\n    Utility::openBrowser(url);\n    return false;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,6 +2,6 @@\n {\n     Q_UNUSED(type);\n     Q_UNUSED(isMainFrame);\n-    QDesktopServices::openUrl(url);\n+    Utility::openBrowser(url);\n     return false;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    QDesktopServices::openUrl(url);"
            ],
            "added_lines": [
                "    Utility::openBrowser(url);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-22879",
        "func_name": "nextcloud/desktop/Flow2Auth::fetchNewToken",
        "description": "Nextcloud Desktop Client prior to 3.1.3 is vulnerable to resource injection by way of missing validation of URLs, allowing a malicious server to execute remote commands. User interaction is needed for exploitation.",
        "git_url": "https://github.com/nextcloud/desktop/commit/013f3cea70acfe7b701cb73c93744d5ff5c0c213",
        "commit_title": "Validate sensitive URLs to onle allow http(s) schemes.",
        "commit_text": "",
        "func_before": "void Flow2Auth::fetchNewToken(const TokenAction action)\n{\n    if(_isBusy)\n        return;\n\n    _isBusy = true;\n    _hasToken = false;\n\n    emit statusChanged(PollStatus::statusFetchToken, 0);\n\n    // Step 1: Initiate a login, do an anonymous POST request\n    QUrl url = Utility::concatUrlPath(_account->url().toString(), QLatin1String(\"/index.php/login/v2\"));\n\n    // add 'Content-Length: 0' header (see https://github.com/nextcloud/desktop/issues/1473)\n    QNetworkRequest req;\n    req.setHeader(QNetworkRequest::ContentLengthHeader, \"0\");\n    req.setHeader(QNetworkRequest::UserAgentHeader, Utility::friendlyUserAgentString());\n\n    auto job = _account->sendRequest(\"POST\", url, req);\n    job->setTimeout(qMin(30 * 1000ll, job->timeoutMsec()));\n\n    QObject::connect(job, &SimpleNetworkJob::finishedSignal, this, [this, action](QNetworkReply *reply) {\n        auto jsonData = reply->readAll();\n        QJsonParseError jsonParseError;\n        QJsonObject json = QJsonDocument::fromJson(jsonData, &jsonParseError).object();\n        QString pollToken, pollEndpoint, loginUrl;\n\n        if (reply->error() == QNetworkReply::NoError && jsonParseError.error == QJsonParseError::NoError\n            && !json.isEmpty()) {\n            pollToken = json.value(\"poll\").toObject().value(\"token\").toString();\n            pollEndpoint = json.value(\"poll\").toObject().value(\"endpoint\").toString();\n            loginUrl = json[\"login\"].toString();\n        }\n\n        if (reply->error() != QNetworkReply::NoError || jsonParseError.error != QJsonParseError::NoError\n            || json.isEmpty() || pollToken.isEmpty() || pollEndpoint.isEmpty() || loginUrl.isEmpty()) {\n            QString errorReason;\n            QString errorFromJson = json[\"error\"].toString();\n            if (!errorFromJson.isEmpty()) {\n                errorReason = tr(\"Error returned from the server: <em>%1</em>\")\n                                  .arg(errorFromJson.toHtmlEscaped());\n            } else if (reply->error() != QNetworkReply::NoError) {\n                errorReason = tr(\"There was an error accessing the 'token' endpoint: <br><em>%1</em>\")\n                                  .arg(reply->errorString().toHtmlEscaped());\n            } else if (jsonParseError.error != QJsonParseError::NoError) {\n                errorReason = tr(\"Could not parse the JSON returned from the server: <br><em>%1</em>\")\n                                  .arg(jsonParseError.errorString());\n            } else {\n                errorReason = tr(\"The reply from the server did not contain all expected fields\");\n            }\n            qCWarning(lcFlow2auth) << \"Error when getting the loginUrl\" << json << errorReason;\n            emit result(Error, errorReason);\n            _pollTimer.stop();\n            _isBusy = false;\n            return;\n        }\n\n\n        _loginUrl = loginUrl;\n        _pollToken = pollToken;\n        _pollEndpoint = pollEndpoint;\n\n\n        // Start polling\n        ConfigFile cfg;\n        std::chrono::milliseconds polltime = cfg.remotePollInterval();\n        qCInfo(lcFlow2auth) << \"setting remote poll timer interval to\" << polltime.count() << \"msec\";\n        _secondsInterval = (polltime.count() / 1000);\n        _secondsLeft = _secondsInterval;\n        emit statusChanged(PollStatus::statusPollCountdown, _secondsLeft);\n\n        if(!_pollTimer.isActive()) {\n            _pollTimer.start();\n        }\n\n\n        switch(action)\n        {\n        case actionOpenBrowser:\n            // Try to open Browser\n            if (!QDesktopServices::openUrl(authorisationLink())) {\n                // We cannot open the browser, then we claim we don't support Flow2Auth.\n                // Our UI callee will ask the user to copy and open the link.\n                emit result(NotSupported);\n            }\n            break;\n        case actionCopyLinkToClipboard:\n            QApplication::clipboard()->setText(authorisationLink().toString(QUrl::FullyEncoded));\n            emit statusChanged(PollStatus::statusCopyLinkToClipboard, 0);\n            break;\n        }\n\n        _isBusy = false;\n        _hasToken = true;\n    });\n}",
        "func": "void Flow2Auth::fetchNewToken(const TokenAction action)\n{\n    if(_isBusy)\n        return;\n\n    _isBusy = true;\n    _hasToken = false;\n\n    emit statusChanged(PollStatus::statusFetchToken, 0);\n\n    // Step 1: Initiate a login, do an anonymous POST request\n    QUrl url = Utility::concatUrlPath(_account->url().toString(), QLatin1String(\"/index.php/login/v2\"));\n\n    // add 'Content-Length: 0' header (see https://github.com/nextcloud/desktop/issues/1473)\n    QNetworkRequest req;\n    req.setHeader(QNetworkRequest::ContentLengthHeader, \"0\");\n    req.setHeader(QNetworkRequest::UserAgentHeader, Utility::friendlyUserAgentString());\n\n    auto job = _account->sendRequest(\"POST\", url, req);\n    job->setTimeout(qMin(30 * 1000ll, job->timeoutMsec()));\n\n    QObject::connect(job, &SimpleNetworkJob::finishedSignal, this, [this, action](QNetworkReply *reply) {\n        auto jsonData = reply->readAll();\n        QJsonParseError jsonParseError;\n        QJsonObject json = QJsonDocument::fromJson(jsonData, &jsonParseError).object();\n        QString pollToken, pollEndpoint, loginUrl;\n\n        if (reply->error() == QNetworkReply::NoError && jsonParseError.error == QJsonParseError::NoError\n            && !json.isEmpty()) {\n            pollToken = json.value(\"poll\").toObject().value(\"token\").toString();\n            pollEndpoint = json.value(\"poll\").toObject().value(\"endpoint\").toString();\n            loginUrl = json[\"login\"].toString();\n        }\n\n        if (reply->error() != QNetworkReply::NoError || jsonParseError.error != QJsonParseError::NoError\n            || json.isEmpty() || pollToken.isEmpty() || pollEndpoint.isEmpty() || loginUrl.isEmpty()) {\n            QString errorReason;\n            QString errorFromJson = json[\"error\"].toString();\n            if (!errorFromJson.isEmpty()) {\n                errorReason = tr(\"Error returned from the server: <em>%1</em>\")\n                                  .arg(errorFromJson.toHtmlEscaped());\n            } else if (reply->error() != QNetworkReply::NoError) {\n                errorReason = tr(\"There was an error accessing the 'token' endpoint: <br><em>%1</em>\")\n                                  .arg(reply->errorString().toHtmlEscaped());\n            } else if (jsonParseError.error != QJsonParseError::NoError) {\n                errorReason = tr(\"Could not parse the JSON returned from the server: <br><em>%1</em>\")\n                                  .arg(jsonParseError.errorString());\n            } else {\n                errorReason = tr(\"The reply from the server did not contain all expected fields\");\n            }\n            qCWarning(lcFlow2auth) << \"Error when getting the loginUrl\" << json << errorReason;\n            emit result(Error, errorReason);\n            _pollTimer.stop();\n            _isBusy = false;\n            return;\n        }\n\n\n        _loginUrl = loginUrl;\n        _pollToken = pollToken;\n        _pollEndpoint = pollEndpoint;\n\n\n        // Start polling\n        ConfigFile cfg;\n        std::chrono::milliseconds polltime = cfg.remotePollInterval();\n        qCInfo(lcFlow2auth) << \"setting remote poll timer interval to\" << polltime.count() << \"msec\";\n        _secondsInterval = (polltime.count() / 1000);\n        _secondsLeft = _secondsInterval;\n        emit statusChanged(PollStatus::statusPollCountdown, _secondsLeft);\n\n        if(!_pollTimer.isActive()) {\n            _pollTimer.start();\n        }\n\n\n        switch(action)\n        {\n        case actionOpenBrowser:\n            // Try to open Browser\n            if (!Utility::openBrowser(authorisationLink())) {\n                // We cannot open the browser, then we claim we don't support Flow2Auth.\n                // Our UI callee will ask the user to copy and open the link.\n                emit result(NotSupported);\n            }\n            break;\n        case actionCopyLinkToClipboard:\n            QApplication::clipboard()->setText(authorisationLink().toString(QUrl::FullyEncoded));\n            emit statusChanged(PollStatus::statusCopyLinkToClipboard, 0);\n            break;\n        }\n\n        _isBusy = false;\n        _hasToken = true;\n    });\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -78,7 +78,7 @@\n         {\n         case actionOpenBrowser:\n             // Try to open Browser\n-            if (!QDesktopServices::openUrl(authorisationLink())) {\n+            if (!Utility::openBrowser(authorisationLink())) {\n                 // We cannot open the browser, then we claim we don't support Flow2Auth.\n                 // Our UI callee will ask the user to copy and open the link.\n                 emit result(NotSupported);",
        "diff_line_info": {
            "deleted_lines": [
                "            if (!QDesktopServices::openUrl(authorisationLink())) {"
            ],
            "added_lines": [
                "            if (!Utility::openBrowser(authorisationLink())) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-22879",
        "func_name": "nextcloud/desktop/OAuth::openBrowser",
        "description": "Nextcloud Desktop Client prior to 3.1.3 is vulnerable to resource injection by way of missing validation of URLs, allowing a malicious server to execute remote commands. User interaction is needed for exploitation.",
        "git_url": "https://github.com/nextcloud/desktop/commit/013f3cea70acfe7b701cb73c93744d5ff5c0c213",
        "commit_title": "Validate sensitive URLs to onle allow http(s) schemes.",
        "commit_text": "",
        "func_before": "bool OAuth::openBrowser()\n{\n    if (!QDesktopServices::openUrl(authorisationLink())) {\n        // We cannot open the browser, then we claim we don't support OAuth.\n        emit result(NotSupported, QString());\n        return false;\n    }\n    return true;\n}",
        "func": "bool OAuth::openBrowser()\n{\n    if (!Utility::openBrowser(authorisationLink())) {\n        // We cannot open the browser, then we claim we don't support OAuth.\n        emit result(NotSupported, QString());\n        return false;\n    }\n    return true;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,6 @@\n bool OAuth::openBrowser()\n {\n-    if (!QDesktopServices::openUrl(authorisationLink())) {\n+    if (!Utility::openBrowser(authorisationLink())) {\n         // We cannot open the browser, then we claim we don't support OAuth.\n         emit result(NotSupported, QString());\n         return false;",
        "diff_line_info": {
            "deleted_lines": [
                "    if (!QDesktopServices::openUrl(authorisationLink())) {"
            ],
            "added_lines": [
                "    if (!Utility::openBrowser(authorisationLink())) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-22879",
        "func_name": "nextcloud/desktop/OwncloudWizardResultPage::slotOpenServer",
        "description": "Nextcloud Desktop Client prior to 3.1.3 is vulnerable to resource injection by way of missing validation of URLs, allowing a malicious server to execute remote commands. User interaction is needed for exploitation.",
        "git_url": "https://github.com/nextcloud/desktop/commit/013f3cea70acfe7b701cb73c93744d5ff5c0c213",
        "commit_title": "Validate sensitive URLs to onle allow http(s) schemes.",
        "commit_text": "",
        "func_before": "void OwncloudWizardResultPage::slotOpenServer()\n{\n    Theme *theme = Theme::instance();\n    QUrl url = QUrl(field(\"OCUrl\").toString() + theme->wizardUrlPostfix());\n    QDesktopServices::openUrl(url);\n}",
        "func": "void OwncloudWizardResultPage::slotOpenServer()\n{\n    Theme *theme = Theme::instance();\n    QUrl url = QUrl(field(\"OCUrl\").toString() + theme->wizardUrlPostfix());\n    Utility::openBrowser(url);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,5 +2,5 @@\n {\n     Theme *theme = Theme::instance();\n     QUrl url = QUrl(field(\"OCUrl\").toString() + theme->wizardUrlPostfix());\n-    QDesktopServices::openUrl(url);\n+    Utility::openBrowser(url);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    QDesktopServices::openUrl(url);"
            ],
            "added_lines": [
                "    Utility::openBrowser(url);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-22879",
        "func_name": "nextcloud/desktop/Utility::openBrowser",
        "description": "Nextcloud Desktop Client prior to 3.1.3 is vulnerable to resource injection by way of missing validation of URLs, allowing a malicious server to execute remote commands. User interaction is needed for exploitation.",
        "git_url": "https://github.com/nextcloud/desktop/commit/013f3cea70acfe7b701cb73c93744d5ff5c0c213",
        "commit_title": "Validate sensitive URLs to onle allow http(s) schemes.",
        "commit_text": "",
        "func_before": "bool Utility::openBrowser(const QUrl &url, QWidget *errorWidgetParent)\n{\n    if (!QDesktopServices::openUrl(url)) {\n        if (errorWidgetParent) {\n            QMessageBox::warning(\n                errorWidgetParent,\n                QCoreApplication::translate(\"utility\", \"Could not open browser\"),\n                QCoreApplication::translate(\"utility\",\n                    \"There was an error when launching the browser to go to \"\n                    \"URL %1. Maybe no default browser is configured?\")\n                    .arg(url.toString()));\n        }\n        qCWarning(lcUtility) << \"QDesktopServices::openUrl failed for\" << url;\n        return false;\n    }\n    return true;\n}",
        "func": "bool Utility::openBrowser(const QUrl &url, QWidget *errorWidgetParent)\n{\n    const QStringList allowedUrlSchemes = {\n        \"http\",\n        \"https\",\n        \"oauthtest\"\n    };\n\n    if (!allowedUrlSchemes.contains(url.scheme())) {\n        qCWarning(lcUtility) << \"URL format is not supported, or it has been compromised for:\" << url.toString();\n        return false;\n    }\n\n    if (!QDesktopServices::openUrl(url)) {\n        if (errorWidgetParent) {\n            QMessageBox::warning(\n                errorWidgetParent,\n                QCoreApplication::translate(\"utility\", \"Could not open browser\"),\n                QCoreApplication::translate(\"utility\",\n                    \"There was an error when launching the browser to go to \"\n                    \"URL %1. Maybe no default browser is configured?\")\n                    .arg(url.toString()));\n        }\n        qCWarning(lcUtility) << \"QDesktopServices::openUrl failed for\" << url;\n        return false;\n    }\n    return true;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,16 @@\n bool Utility::openBrowser(const QUrl &url, QWidget *errorWidgetParent)\n {\n+    const QStringList allowedUrlSchemes = {\n+        \"http\",\n+        \"https\",\n+        \"oauthtest\"\n+    };\n+\n+    if (!allowedUrlSchemes.contains(url.scheme())) {\n+        qCWarning(lcUtility) << \"URL format is not supported, or it has been compromised for:\" << url.toString();\n+        return false;\n+    }\n+\n     if (!QDesktopServices::openUrl(url)) {\n         if (errorWidgetParent) {\n             QMessageBox::warning(",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    const QStringList allowedUrlSchemes = {",
                "        \"http\",",
                "        \"https\",",
                "        \"oauthtest\"",
                "    };",
                "",
                "    if (!allowedUrlSchemes.contains(url.scheme())) {",
                "        qCWarning(lcUtility) << \"URL format is not supported, or it has been compromised for:\" << url.toString();",
                "        return false;",
                "    }",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2021-22879",
        "func_name": "nextcloud/desktop/SocketApi::command_EDIT",
        "description": "Nextcloud Desktop Client prior to 3.1.3 is vulnerable to resource injection by way of missing validation of URLs, allowing a malicious server to execute remote commands. User interaction is needed for exploitation.",
        "git_url": "https://github.com/nextcloud/desktop/commit/013f3cea70acfe7b701cb73c93744d5ff5c0c213",
        "commit_title": "Validate sensitive URLs to onle allow http(s) schemes.",
        "commit_text": "",
        "func_before": "void SocketApi::command_EDIT(const QString &localFile, SocketListener *listener)\n{\n    Q_UNUSED(listener)\n    auto fileData = FileData::get(localFile);\n    if (!fileData.folder) {\n        qCWarning(lcSocketApi) << \"Unknown path\" << localFile;\n        return;\n    }\n\n    auto record = fileData.journalRecord();\n    if (!record.isValid())\n        return;\n\n    DirectEditor* editor = getDirectEditorForLocalFile(fileData.localPath);\n    if (!editor)\n        return;\n\n    auto *job = new JsonApiJob(fileData.folder->accountState()->account(), QLatin1String(\"ocs/v2.php/apps/files/api/v1/directEditing/open\"), this);\n\n    QUrlQuery params;\n    params.addQueryItem(\"path\", fileData.serverRelativePath);\n    params.addQueryItem(\"editorId\", editor->id());\n    job->addQueryParams(params);\n    job->usePOST();\n\n    QObject::connect(job, &JsonApiJob::jsonReceived, [](const QJsonDocument &json){\n        auto data = json.object().value(\"ocs\").toObject().value(\"data\").toObject();\n        auto url = QUrl(data.value(\"url\").toString());\n\n        if(!url.isEmpty())\n            Utility::openBrowser(url, nullptr);\n    });\n    job->start();\n}",
        "func": "void SocketApi::command_EDIT(const QString &localFile, SocketListener *listener)\n{\n    Q_UNUSED(listener)\n    auto fileData = FileData::get(localFile);\n    if (!fileData.folder) {\n        qCWarning(lcSocketApi) << \"Unknown path\" << localFile;\n        return;\n    }\n\n    auto record = fileData.journalRecord();\n    if (!record.isValid())\n        return;\n\n    DirectEditor* editor = getDirectEditorForLocalFile(fileData.localPath);\n    if (!editor)\n        return;\n\n    auto *job = new JsonApiJob(fileData.folder->accountState()->account(), QLatin1String(\"ocs/v2.php/apps/files/api/v1/directEditing/open\"), this);\n\n    QUrlQuery params;\n    params.addQueryItem(\"path\", fileData.serverRelativePath);\n    params.addQueryItem(\"editorId\", editor->id());\n    job->addQueryParams(params);\n    job->usePOST();\n\n    QObject::connect(job, &JsonApiJob::jsonReceived, [](const QJsonDocument &json){\n        auto data = json.object().value(\"ocs\").toObject().value(\"data\").toObject();\n        auto url = QUrl(data.value(\"url\").toString());\n\n        if(!url.isEmpty())\n            Utility::openBrowser(url);\n    });\n    job->start();\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -28,7 +28,7 @@\n         auto url = QUrl(data.value(\"url\").toString());\n \n         if(!url.isEmpty())\n-            Utility::openBrowser(url, nullptr);\n+            Utility::openBrowser(url);\n     });\n     job->start();\n }",
        "diff_line_info": {
            "deleted_lines": [
                "            Utility::openBrowser(url, nullptr);"
            ],
            "added_lines": [
                "            Utility::openBrowser(url);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-22879",
        "func_name": "nextcloud/desktop/OCC::SocketApi::openPrivateLink",
        "description": "Nextcloud Desktop Client prior to 3.1.3 is vulnerable to resource injection by way of missing validation of URLs, allowing a malicious server to execute remote commands. User interaction is needed for exploitation.",
        "git_url": "https://github.com/nextcloud/desktop/commit/013f3cea70acfe7b701cb73c93744d5ff5c0c213",
        "commit_title": "Validate sensitive URLs to onle allow http(s) schemes.",
        "commit_text": "",
        "func_before": "void OCC::SocketApi::openPrivateLink(const QString &link)\n{\n    Utility::openBrowser(link, nullptr);\n}",
        "func": "void OCC::SocketApi::openPrivateLink(const QString &link)\n{\n    Utility::openBrowser(link);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,4 @@\n void OCC::SocketApi::openPrivateLink(const QString &link)\n {\n-    Utility::openBrowser(link, nullptr);\n+    Utility::openBrowser(link);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    Utility::openBrowser(link, nullptr);"
            ],
            "added_lines": [
                "    Utility::openBrowser(link);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-22879",
        "func_name": "nextcloud/desktop/ActivityListModel::triggerAction",
        "description": "Nextcloud Desktop Client prior to 3.1.3 is vulnerable to resource injection by way of missing validation of URLs, allowing a malicious server to execute remote commands. User interaction is needed for exploitation.",
        "git_url": "https://github.com/nextcloud/desktop/commit/013f3cea70acfe7b701cb73c93744d5ff5c0c213",
        "commit_title": "Validate sensitive URLs to onle allow http(s) schemes.",
        "commit_text": "",
        "func_before": "void ActivityListModel::triggerAction(int activityIndex, int actionIndex)\n{\n    if (activityIndex < 0 || activityIndex >= _finalList.size()) {\n        qCWarning(lcActivity) << \"Couldn't trigger action on activity at index\" << activityIndex << \"/ final list size:\" << _finalList.size();\n        return;\n    }\n\n    const auto activity = _finalList[activityIndex];\n\n    if (actionIndex < 0 || actionIndex >= activity._links.size()) {\n        qCWarning(lcActivity) << \"Couldn't trigger action at index\" << actionIndex << \"/ actions list size:\" << activity._links.size();\n        return;\n    }\n\n    const auto action = activity._links[actionIndex];\n\n    if (action._verb == \"WEB\") {\n        QDesktopServices::openUrl(QUrl(action._link));\n        return;\n    }\n\n    emit sendNotificationRequest(activity._accName, action._link, action._verb, activityIndex);\n}",
        "func": "void ActivityListModel::triggerAction(int activityIndex, int actionIndex)\n{\n    if (activityIndex < 0 || activityIndex >= _finalList.size()) {\n        qCWarning(lcActivity) << \"Couldn't trigger action on activity at index\" << activityIndex << \"/ final list size:\" << _finalList.size();\n        return;\n    }\n\n    const auto activity = _finalList[activityIndex];\n\n    if (actionIndex < 0 || actionIndex >= activity._links.size()) {\n        qCWarning(lcActivity) << \"Couldn't trigger action at index\" << actionIndex << \"/ actions list size:\" << activity._links.size();\n        return;\n    }\n\n    const auto action = activity._links[actionIndex];\n\n    if (action._verb == \"WEB\") {\n        Utility::openBrowser(QUrl(action._link));\n        return;\n    }\n\n    emit sendNotificationRequest(activity._accName, action._link, action._verb, activityIndex);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -15,7 +15,7 @@\n     const auto action = activity._links[actionIndex];\n \n     if (action._verb == \"WEB\") {\n-        QDesktopServices::openUrl(QUrl(action._link));\n+        Utility::openBrowser(QUrl(action._link));\n         return;\n     }\n ",
        "diff_line_info": {
            "deleted_lines": [
                "        QDesktopServices::openUrl(QUrl(action._link));"
            ],
            "added_lines": [
                "        Utility::openBrowser(QUrl(action._link));"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-22879",
        "func_name": "nextcloud/desktop/ActivityListModel::triggerDefaultAction",
        "description": "Nextcloud Desktop Client prior to 3.1.3 is vulnerable to resource injection by way of missing validation of URLs, allowing a malicious server to execute remote commands. User interaction is needed for exploitation.",
        "git_url": "https://github.com/nextcloud/desktop/commit/013f3cea70acfe7b701cb73c93744d5ff5c0c213",
        "commit_title": "Validate sensitive URLs to onle allow http(s) schemes.",
        "commit_text": "",
        "func_before": "void ActivityListModel::triggerDefaultAction(int activityIndex)\n{\n    if (activityIndex < 0 || activityIndex >= _finalList.size()) {\n        qCWarning(lcActivity) << \"Couldn't trigger default action at index\" << activityIndex << \"/ final list size:\" << _finalList.size();\n        return;\n    }\n\n    const auto modelIndex = index(activityIndex);\n    const auto path = data(modelIndex, PathRole).toUrl();\n\n    const auto activity = _finalList.at(activityIndex);\n    if (activity._status == SyncFileItem::Conflict) {\n        Q_ASSERT(!activity._file.isEmpty());\n        Q_ASSERT(!activity._folder.isEmpty());\n        Q_ASSERT(Utility::isConflictFile(activity._file));\n\n        const auto folder = FolderMan::instance()->folder(activity._folder);\n\n        const auto conflictedRelativePath = activity._file;\n        const auto baseRelativePath = folder->journalDb()->conflictFileBaseName(conflictedRelativePath.toUtf8());\n\n        const auto dir = QDir(folder->path());\n        const auto conflictedPath = dir.filePath(conflictedRelativePath);\n        const auto basePath = dir.filePath(baseRelativePath);\n\n        const auto baseName = QFileInfo(basePath).fileName();\n\n        if (!_currentConflictDialog.isNull()) {\n            _currentConflictDialog->close();\n        }\n        _currentConflictDialog = new ConflictDialog;\n        _currentConflictDialog->setBaseFilename(baseName);\n        _currentConflictDialog->setLocalVersionFilename(conflictedPath);\n        _currentConflictDialog->setRemoteVersionFilename(basePath);\n        _currentConflictDialog->setAttribute(Qt::WA_DeleteOnClose);\n        connect(_currentConflictDialog, &ConflictDialog::accepted, folder, [folder]() {\n            folder->scheduleThisFolderSoon();\n        });\n        _currentConflictDialog->open();\n        ownCloudGui::raiseDialog(_currentConflictDialog);\n        return;\n    }\n\n    if (path.isValid()) {\n        QDesktopServices::openUrl(path);\n    } else {\n        const auto link = data(modelIndex, LinkRole).toUrl();\n        QDesktopServices::openUrl(link);\n    }\n}",
        "func": "void ActivityListModel::triggerDefaultAction(int activityIndex)\n{\n    if (activityIndex < 0 || activityIndex >= _finalList.size()) {\n        qCWarning(lcActivity) << \"Couldn't trigger default action at index\" << activityIndex << \"/ final list size:\" << _finalList.size();\n        return;\n    }\n\n    const auto modelIndex = index(activityIndex);\n    const auto path = data(modelIndex, PathRole).toUrl();\n\n    const auto activity = _finalList.at(activityIndex);\n    if (activity._status == SyncFileItem::Conflict) {\n        Q_ASSERT(!activity._file.isEmpty());\n        Q_ASSERT(!activity._folder.isEmpty());\n        Q_ASSERT(Utility::isConflictFile(activity._file));\n\n        const auto folder = FolderMan::instance()->folder(activity._folder);\n\n        const auto conflictedRelativePath = activity._file;\n        const auto baseRelativePath = folder->journalDb()->conflictFileBaseName(conflictedRelativePath.toUtf8());\n\n        const auto dir = QDir(folder->path());\n        const auto conflictedPath = dir.filePath(conflictedRelativePath);\n        const auto basePath = dir.filePath(baseRelativePath);\n\n        const auto baseName = QFileInfo(basePath).fileName();\n\n        if (!_currentConflictDialog.isNull()) {\n            _currentConflictDialog->close();\n        }\n        _currentConflictDialog = new ConflictDialog;\n        _currentConflictDialog->setBaseFilename(baseName);\n        _currentConflictDialog->setLocalVersionFilename(conflictedPath);\n        _currentConflictDialog->setRemoteVersionFilename(basePath);\n        _currentConflictDialog->setAttribute(Qt::WA_DeleteOnClose);\n        connect(_currentConflictDialog, &ConflictDialog::accepted, folder, [folder]() {\n            folder->scheduleThisFolderSoon();\n        });\n        _currentConflictDialog->open();\n        ownCloudGui::raiseDialog(_currentConflictDialog);\n        return;\n    }\n\n    if (path.isValid()) {\n        QDesktopServices::openUrl(path);\n    } else {\n        const auto link = data(modelIndex, LinkRole).toUrl();\n        Utility::openBrowser(link);\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -45,6 +45,6 @@\n         QDesktopServices::openUrl(path);\n     } else {\n         const auto link = data(modelIndex, LinkRole).toUrl();\n-        QDesktopServices::openUrl(link);\n+        Utility::openBrowser(link);\n     }\n }",
        "diff_line_info": {
            "deleted_lines": [
                "        QDesktopServices::openUrl(link);"
            ],
            "added_lines": [
                "        Utility::openBrowser(link);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-22879",
        "func_name": "nextcloud/desktop/UserModel::openCurrentAccountTalk",
        "description": "Nextcloud Desktop Client prior to 3.1.3 is vulnerable to resource injection by way of missing validation of URLs, allowing a malicious server to execute remote commands. User interaction is needed for exploitation.",
        "git_url": "https://github.com/nextcloud/desktop/commit/013f3cea70acfe7b701cb73c93744d5ff5c0c213",
        "commit_title": "Validate sensitive URLs to onle allow http(s) schemes.",
        "commit_text": "",
        "func_before": "Q_INVOKABLE void UserModel::openCurrentAccountTalk()\n{\n    if (!currentUser())\n        return;\n\n    const auto talkApp = currentUser()->talkApp();\n    if (talkApp) {\n        QDesktopServices::openUrl(talkApp->url());\n    } else {\n        qCWarning(lcActivity) << \"The Talk app is not enabled on\" << currentUser()->server();\n    }\n}",
        "func": "Q_INVOKABLE void UserModel::openCurrentAccountTalk()\n{\n    if (!currentUser())\n        return;\n\n    const auto talkApp = currentUser()->talkApp();\n    if (talkApp) {\n        Utility::openBrowser(talkApp->url());\n    } else {\n        qCWarning(lcActivity) << \"The Talk app is not enabled on\" << currentUser()->server();\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,7 +5,7 @@\n \n     const auto talkApp = currentUser()->talkApp();\n     if (talkApp) {\n-        QDesktopServices::openUrl(talkApp->url());\n+        Utility::openBrowser(talkApp->url());\n     } else {\n         qCWarning(lcActivity) << \"The Talk app is not enabled on\" << currentUser()->server();\n     }",
        "diff_line_info": {
            "deleted_lines": [
                "        QDesktopServices::openUrl(talkApp->url());"
            ],
            "added_lines": [
                "        Utility::openBrowser(talkApp->url());"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-22879",
        "func_name": "nextcloud/desktop/UserAppsModel::openAppUrl",
        "description": "Nextcloud Desktop Client prior to 3.1.3 is vulnerable to resource injection by way of missing validation of URLs, allowing a malicious server to execute remote commands. User interaction is needed for exploitation.",
        "git_url": "https://github.com/nextcloud/desktop/commit/013f3cea70acfe7b701cb73c93744d5ff5c0c213",
        "commit_title": "Validate sensitive URLs to onle allow http(s) schemes.",
        "commit_text": "",
        "func_before": "void UserAppsModel::openAppUrl(const QUrl &url)\n{\n    QDesktopServices::openUrl(url);\n}",
        "func": "void UserAppsModel::openAppUrl(const QUrl &url)\n{\n    Utility::openBrowser(url);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,4 @@\n void UserAppsModel::openAppUrl(const QUrl &url)\n {\n-    QDesktopServices::openUrl(url);\n+    Utility::openBrowser(url);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    QDesktopServices::openUrl(url);"
            ],
            "added_lines": [
                "    Utility::openBrowser(url);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-22879",
        "func_name": "nextcloud/desktop/UserModel::openCurrentAccountServer",
        "description": "Nextcloud Desktop Client prior to 3.1.3 is vulnerable to resource injection by way of missing validation of URLs, allowing a malicious server to execute remote commands. User interaction is needed for exploitation.",
        "git_url": "https://github.com/nextcloud/desktop/commit/013f3cea70acfe7b701cb73c93744d5ff5c0c213",
        "commit_title": "Validate sensitive URLs to onle allow http(s) schemes.",
        "commit_text": "",
        "func_before": "Q_INVOKABLE void UserModel::openCurrentAccountServer()\n{\n    if (_currentUserId < 0 || _currentUserId >= _users.size())\n        return;\n\n    QString url = _users[_currentUserId]->server(false);\n    if (!(url.contains(\"http://\") || url.contains(\"https://\"))) {\n        url = \"https://\" + _users[_currentUserId]->server(false);\n    }\n    QDesktopServices::openUrl(QUrl(url));\n}",
        "func": "Q_INVOKABLE void UserModel::openCurrentAccountServer()\n{\n    if (_currentUserId < 0 || _currentUserId >= _users.size())\n        return;\n\n    QString url = _users[_currentUserId]->server(false);\n    if (!url.startsWith(\"http://\") && !url.startsWith(\"https://\")) {\n        url = \"https://\" + _users[_currentUserId]->server(false);\n    }\n\n    QDesktopServices::openUrl(url);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,8 +4,9 @@\n         return;\n \n     QString url = _users[_currentUserId]->server(false);\n-    if (!(url.contains(\"http://\") || url.contains(\"https://\"))) {\n+    if (!url.startsWith(\"http://\") && !url.startsWith(\"https://\")) {\n         url = \"https://\" + _users[_currentUserId]->server(false);\n     }\n-    QDesktopServices::openUrl(QUrl(url));\n+\n+    QDesktopServices::openUrl(url);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    if (!(url.contains(\"http://\") || url.contains(\"https://\"))) {",
                "    QDesktopServices::openUrl(QUrl(url));"
            ],
            "added_lines": [
                "    if (!url.startsWith(\"http://\") && !url.startsWith(\"https://\")) {",
                "",
                "    QDesktopServices::openUrl(url);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-22879",
        "func_name": "nextcloud/desktop/ownCloudGui::slotOpenOwnCloud",
        "description": "Nextcloud Desktop Client prior to 3.1.3 is vulnerable to resource injection by way of missing validation of URLs, allowing a malicious server to execute remote commands. User interaction is needed for exploitation.",
        "git_url": "https://github.com/nextcloud/desktop/commit/013f3cea70acfe7b701cb73c93744d5ff5c0c213",
        "commit_title": "Validate sensitive URLs to onle allow http(s) schemes.",
        "commit_text": "",
        "func_before": "void ownCloudGui::slotOpenOwnCloud()\n{\n    if (auto account = qvariant_cast<AccountPtr>(sender()->property(propertyAccountC))) {\n        QDesktopServices::openUrl(account->url());\n    }\n}",
        "func": "void ownCloudGui::slotOpenOwnCloud()\n{\n    if (auto account = qvariant_cast<AccountPtr>(sender()->property(propertyAccountC))) {\n        Utility::openBrowser(account->url());\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,6 @@\n void ownCloudGui::slotOpenOwnCloud()\n {\n     if (auto account = qvariant_cast<AccountPtr>(sender()->property(propertyAccountC))) {\n-        QDesktopServices::openUrl(account->url());\n+        Utility::openBrowser(account->url());\n     }\n }",
        "diff_line_info": {
            "deleted_lines": [
                "        QDesktopServices::openUrl(account->url());"
            ],
            "added_lines": [
                "        Utility::openBrowser(account->url());"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-22879",
        "func_name": "nextcloud/desktop/AccountSettings::slotOpenOC",
        "description": "Nextcloud Desktop Client prior to 3.1.3 is vulnerable to resource injection by way of missing validation of URLs, allowing a malicious server to execute remote commands. User interaction is needed for exploitation.",
        "git_url": "https://github.com/nextcloud/desktop/commit/013f3cea70acfe7b701cb73c93744d5ff5c0c213",
        "commit_title": "Validate sensitive URLs to onle allow http(s) schemes.",
        "commit_text": "",
        "func_before": "void AccountSettings::slotOpenOC()\n{\n    if (_OCUrl.isValid())\n        QDesktopServices::openUrl(_OCUrl);\n}",
        "func": "void AccountSettings::slotOpenOC()\n{\n    if (_OCUrl.isValid()) {\n        Utility::openBrowser(_OCUrl);\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,6 @@\n void AccountSettings::slotOpenOC()\n {\n-    if (_OCUrl.isValid())\n-        QDesktopServices::openUrl(_OCUrl);\n+    if (_OCUrl.isValid()) {\n+        Utility::openBrowser(_OCUrl);\n+    }\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    if (_OCUrl.isValid())",
                "        QDesktopServices::openUrl(_OCUrl);"
            ],
            "added_lines": [
                "    if (_OCUrl.isValid()) {",
                "        Utility::openBrowser(_OCUrl);",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-11709",
        "func_name": "yhirose/cpp-httplib/Response::set_redirect",
        "description": "cpp-httplib through 0.5.8 does not filter \\r\\n in parameters passed into the set_redirect and set_header functions, which creates possibilities for CRLF injection and HTTP response splitting in some specific contexts.",
        "git_url": "https://github.com/yhirose/cpp-httplib/commit/85327e19ae7e72028c30917247238d638ce56d0b",
        "commit_title": "Fix #425",
        "commit_text": "",
        "func_before": "inline void Response::set_redirect(const char *url) {\n  set_header(\"Location\", url);\n  status = 302;\n}",
        "func": "inline void Response::set_redirect(const char *url) {\n  if (!detail::has_crlf(url)) {\n    set_header(\"Location\", url);\n    status = 302;\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,6 @@\n inline void Response::set_redirect(const char *url) {\n-  set_header(\"Location\", url);\n-  status = 302;\n+  if (!detail::has_crlf(url)) {\n+    set_header(\"Location\", url);\n+    status = 302;\n+  }\n }",
        "diff_line_info": {
            "deleted_lines": [
                "  set_header(\"Location\", url);",
                "  status = 302;"
            ],
            "added_lines": [
                "  if (!detail::has_crlf(url)) {",
                "    set_header(\"Location\", url);",
                "    status = 302;",
                "  }"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-11709",
        "func_name": "yhirose/cpp-httplib/Request::set_header",
        "description": "cpp-httplib through 0.5.8 does not filter \\r\\n in parameters passed into the set_redirect and set_header functions, which creates possibilities for CRLF injection and HTTP response splitting in some specific contexts.",
        "git_url": "https://github.com/yhirose/cpp-httplib/commit/85327e19ae7e72028c30917247238d638ce56d0b",
        "commit_title": "Fix #425",
        "commit_text": "",
        "func_before": "inline void Request::set_header(const char *key, const char *val) {\n  headers.emplace(key, val);\n}",
        "func": "inline void Request::set_header(const char *key, const char *val) {\n  if (!detail::has_crlf(key) && !detail::has_crlf(val)) {\n    headers.emplace(key, val);\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,3 +1,5 @@\n inline void Request::set_header(const char *key, const char *val) {\n-  headers.emplace(key, val);\n+  if (!detail::has_crlf(key) && !detail::has_crlf(val)) {\n+    headers.emplace(key, val);\n+  }\n }",
        "diff_line_info": {
            "deleted_lines": [
                "  headers.emplace(key, val);"
            ],
            "added_lines": [
                "  if (!detail::has_crlf(key) && !detail::has_crlf(val)) {",
                "    headers.emplace(key, val);",
                "  }"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-11709",
        "func_name": "yhirose/cpp-httplib/Response::set_header",
        "description": "cpp-httplib through 0.5.8 does not filter \\r\\n in parameters passed into the set_redirect and set_header functions, which creates possibilities for CRLF injection and HTTP response splitting in some specific contexts.",
        "git_url": "https://github.com/yhirose/cpp-httplib/commit/85327e19ae7e72028c30917247238d638ce56d0b",
        "commit_title": "Fix #425",
        "commit_text": "",
        "func_before": "inline void Response::set_header(const char *key, const char *val) {\n  headers.emplace(key, val);\n}",
        "func": "inline void Response::set_header(const char *key, const char *val) {\n  if (!detail::has_crlf(key) && !detail::has_crlf(val)) {\n    headers.emplace(key, val);\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,3 +1,5 @@\n inline void Response::set_header(const char *key, const char *val) {\n-  headers.emplace(key, val);\n+  if (!detail::has_crlf(key) && !detail::has_crlf(val)) {\n+    headers.emplace(key, val);\n+  }\n }",
        "diff_line_info": {
            "deleted_lines": [
                "  headers.emplace(key, val);"
            ],
            "added_lines": [
                "  if (!detail::has_crlf(key) && !detail::has_crlf(val)) {",
                "    headers.emplace(key, val);",
                "  }"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-11709",
        "func_name": "yhirose/cpp-httplib/Request::set_header",
        "description": "cpp-httplib through 0.5.8 does not filter \\r\\n in parameters passed into the set_redirect and set_header functions, which creates possibilities for CRLF injection and HTTP response splitting in some specific contexts.",
        "git_url": "https://github.com/yhirose/cpp-httplib/commit/85327e19ae7e72028c30917247238d638ce56d0b",
        "commit_title": "Fix #425",
        "commit_text": "",
        "func_before": "inline void Request::set_header(const char *key, const std::string &val) {\n  headers.emplace(key, val);\n}",
        "func": "inline void Request::set_header(const char *key, const std::string &val) {\n  if (!detail::has_crlf(key) && !detail::has_crlf(val.c_str())) {\n    headers.emplace(key, val);\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,3 +1,5 @@\n inline void Request::set_header(const char *key, const std::string &val) {\n-  headers.emplace(key, val);\n+  if (!detail::has_crlf(key) && !detail::has_crlf(val.c_str())) {\n+    headers.emplace(key, val);\n+  }\n }",
        "diff_line_info": {
            "deleted_lines": [
                "  headers.emplace(key, val);"
            ],
            "added_lines": [
                "  if (!detail::has_crlf(key) && !detail::has_crlf(val.c_str())) {",
                "    headers.emplace(key, val);",
                "  }"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-11709",
        "func_name": "yhirose/cpp-httplib/Response::set_header",
        "description": "cpp-httplib through 0.5.8 does not filter \\r\\n in parameters passed into the set_redirect and set_header functions, which creates possibilities for CRLF injection and HTTP response splitting in some specific contexts.",
        "git_url": "https://github.com/yhirose/cpp-httplib/commit/85327e19ae7e72028c30917247238d638ce56d0b",
        "commit_title": "Fix #425",
        "commit_text": "",
        "func_before": "inline void Response::set_header(const char *key, const std::string &val) {\n  headers.emplace(key, val);\n}",
        "func": "inline void Response::set_header(const char *key, const std::string &val) {\n  if (!detail::has_crlf(key) && !detail::has_crlf(val.c_str())) {\n    headers.emplace(key, val);\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,3 +1,5 @@\n inline void Response::set_header(const char *key, const std::string &val) {\n-  headers.emplace(key, val);\n+  if (!detail::has_crlf(key) && !detail::has_crlf(val.c_str())) {\n+    headers.emplace(key, val);\n+  }\n }",
        "diff_line_info": {
            "deleted_lines": [
                "  headers.emplace(key, val);"
            ],
            "added_lines": [
                "  if (!detail::has_crlf(key) && !detail::has_crlf(val.c_str())) {",
                "    headers.emplace(key, val);",
                "  }"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-14954",
        "func_name": "muttmua/mutt/mutt_ssl_starttls",
        "description": "Mutt before 1.14.4 and NeoMutt before 2020-06-19 have a STARTTLS buffering issue that affects IMAP, SMTP, and POP3. When a server sends a \"begin TLS\" response, the client reads additional data (e.g., from a man-in-the-middle attacker) and evaluates it in a TLS context, aka \"response injection.\"",
        "git_url": "https://gitlab.com/muttmua/mutt/-/commit/c547433cdf2e79191b15c6932c57f1472bfb5ff4",
        "commit_title": "Fix STARTTLS response injection attack.",
        "commit_text": " Thanks again to Damian Poddebniak and Fabian Ising from the Mnster University of Applied Sciences for reporting this issue.  Their summary in ticket 248 states the issue clearly:    We found another STARTTLS-related issue in Mutt. Unfortunately, it   affects SMTP, POP3 and IMAP.    When the server responds with its \"let's do TLS now message\", e.g. A   OK begin TLS\\r\\n in IMAP or +OK begin TLS\\r\\n in POP3, Mutt will   also read any data after the \\r\\n and save it into some internal   buffer for later processing. This is problematic, because a MITM   attacker can inject arbitrary responses.    There is a nice blogpost by Wietse Venema about a \"command   injection\" in postfix (http://www.postfix.org/CVE-2011-0411.html).   What we have here is the problem in reverse, i.e. not a command   injection, but a \"response injection.\"  This commit fixes the issue by clearing the CONNECTION input buffer in mutt_ssl_starttls().  To make backporting this fix easier, the new functions only clear the top-level CONNECTION buffer; they don't handle nested buffering in mutt_zstrm.c or mutt_sasl.c.  However both of those wrap the connection *after* STARTTLS, so this is currently okay.  mutt_tunnel.c occurs before connecting, but it does not perform any nesting. ",
        "func_before": "int mutt_ssl_starttls (CONNECTION* conn)\n{\n  sslsockdata* ssldata;\n  int maxbits;\n  long ssl_options = 0;\n\n  if (ssl_init())\n    goto bail;\n\n  ssldata = (sslsockdata*) safe_calloc (1, sizeof (sslsockdata));\n  /* the ssl_use_xxx protocol options don't apply. We must use TLS in TLS.\n   *\n   * However, we need to be able to negotiate amongst various TLS versions,\n   * which at present can only be done with the SSLv23_client_method;\n   * TLSv1_client_method gives us explicitly TLSv1.0, not 1.1 or 1.2 (True as\n   * of OpenSSL 1.0.1c)\n   */\n  if (! (ssldata->ctx = SSL_CTX_new (SSLv23_client_method())))\n  {\n    dprint (1, (debugfile, \"mutt_ssl_starttls: Error allocating SSL_CTX\\n\"));\n    goto bail_ssldata;\n  }\n#ifdef SSL_OP_NO_TLSv1_3\n  if (!option(OPTTLSV1_3))\n    ssl_options |= SSL_OP_NO_TLSv1_3;\n#endif\n#ifdef SSL_OP_NO_TLSv1_2\n  if (!option(OPTTLSV1_2))\n    ssl_options |= SSL_OP_NO_TLSv1_2;\n#endif\n#ifdef SSL_OP_NO_TLSv1_1\n  if (!option(OPTTLSV1_1))\n    ssl_options |= SSL_OP_NO_TLSv1_1;\n#endif\n#ifdef SSL_OP_NO_TLSv1\n  if (!option(OPTTLSV1))\n    ssl_options |= SSL_OP_NO_TLSv1;\n#endif\n  /* these are always set */\n#ifdef SSL_OP_NO_SSLv3\n  ssl_options |= SSL_OP_NO_SSLv3;\n#endif\n#ifdef SSL_OP_NO_SSLv2\n  ssl_options |= SSL_OP_NO_SSLv2;\n#endif\n  if (! SSL_CTX_set_options(ssldata->ctx, ssl_options))\n  {\n    dprint(1, (debugfile, \"mutt_ssl_starttls: Error setting options to %ld\\n\", ssl_options));\n    goto bail_ctx;\n  }\n\n  if (option (OPTSSLSYSTEMCERTS))\n  {\n    if (! SSL_CTX_set_default_verify_paths (ssldata->ctx))\n    {\n      dprint (1, (debugfile, \"mutt_ssl_starttls: Error setting default verify paths\\n\"));\n      goto bail_ctx;\n    }\n  }\n\n  if (SslCertFile && !ssl_load_certificates (ssldata->ctx))\n    dprint (1, (debugfile, \"mutt_ssl_starttls: Error loading trusted certificates\\n\"));\n\n  ssl_get_client_cert(ssldata, conn);\n\n  if (SslCiphers)\n  {\n    if (!SSL_CTX_set_cipher_list (ssldata->ctx, SslCiphers))\n    {\n      dprint (1, (debugfile, \"mutt_ssl_starttls: Could not select preferred ciphers\\n\"));\n      goto bail_ctx;\n    }\n  }\n\n  if (ssl_set_verify_partial (ssldata->ctx))\n  {\n    mutt_error (_(\"Warning: error enabling ssl_verify_partial_chains\"));\n    mutt_sleep (2);\n  }\n\n  if (! (ssldata->ssl = SSL_new (ssldata->ctx)))\n  {\n    dprint (1, (debugfile, \"mutt_ssl_starttls: Error allocating SSL\\n\"));\n    goto bail_ctx;\n  }\n\n  if (SSL_set_fd (ssldata->ssl, conn->fd) != 1)\n  {\n    dprint (1, (debugfile, \"mutt_ssl_starttls: Error setting fd\\n\"));\n    goto bail_ssl;\n  }\n\n  if (ssl_negotiate (conn, ssldata))\n    goto bail_ssl;\n\n  ssldata->isopen = 1;\n\n  /* hmm. watch out if we're starting TLS over any method other than raw. */\n  conn->sockdata = ssldata;\n  conn->conn_read = ssl_socket_read;\n  conn->conn_write = ssl_socket_write;\n  conn->conn_close = tls_close;\n  conn->conn_poll = ssl_socket_poll;\n\n  conn->ssf = SSL_CIPHER_get_bits (SSL_get_current_cipher (ssldata->ssl),\n                                   &maxbits);\n\n  return 0;\n\nbail_ssl:\n  SSL_free (ssldata->ssl);\n  ssldata->ssl = 0;\nbail_ctx:\n  SSL_CTX_free (ssldata->ctx);\n  ssldata->ctx = 0;\nbail_ssldata:\n  FREE (&ssldata);\nbail:\n  return -1;\n}",
        "func": "int mutt_ssl_starttls (CONNECTION* conn)\n{\n  sslsockdata* ssldata;\n  int maxbits;\n  long ssl_options = 0;\n\n  if (mutt_socket_has_buffered_input (conn))\n  {\n    /* L10N:\n       The server is not supposed to send data immediately after\n       confirming STARTTLS.  This warns the user that something\n       weird is going on.\n    */\n    mutt_error _(\"Warning: clearing unexpected buffered data before STARTTLS\");\n    mutt_sleep (0);\n    mutt_socket_clear_buffered_input (conn);\n  }\n\n  if (ssl_init())\n    goto bail;\n\n  ssldata = (sslsockdata*) safe_calloc (1, sizeof (sslsockdata));\n  /* the ssl_use_xxx protocol options don't apply. We must use TLS in TLS.\n   *\n   * However, we need to be able to negotiate amongst various TLS versions,\n   * which at present can only be done with the SSLv23_client_method;\n   * TLSv1_client_method gives us explicitly TLSv1.0, not 1.1 or 1.2 (True as\n   * of OpenSSL 1.0.1c)\n   */\n  if (! (ssldata->ctx = SSL_CTX_new (SSLv23_client_method())))\n  {\n    dprint (1, (debugfile, \"mutt_ssl_starttls: Error allocating SSL_CTX\\n\"));\n    goto bail_ssldata;\n  }\n#ifdef SSL_OP_NO_TLSv1_3\n  if (!option(OPTTLSV1_3))\n    ssl_options |= SSL_OP_NO_TLSv1_3;\n#endif\n#ifdef SSL_OP_NO_TLSv1_2\n  if (!option(OPTTLSV1_2))\n    ssl_options |= SSL_OP_NO_TLSv1_2;\n#endif\n#ifdef SSL_OP_NO_TLSv1_1\n  if (!option(OPTTLSV1_1))\n    ssl_options |= SSL_OP_NO_TLSv1_1;\n#endif\n#ifdef SSL_OP_NO_TLSv1\n  if (!option(OPTTLSV1))\n    ssl_options |= SSL_OP_NO_TLSv1;\n#endif\n  /* these are always set */\n#ifdef SSL_OP_NO_SSLv3\n  ssl_options |= SSL_OP_NO_SSLv3;\n#endif\n#ifdef SSL_OP_NO_SSLv2\n  ssl_options |= SSL_OP_NO_SSLv2;\n#endif\n  if (! SSL_CTX_set_options(ssldata->ctx, ssl_options))\n  {\n    dprint(1, (debugfile, \"mutt_ssl_starttls: Error setting options to %ld\\n\", ssl_options));\n    goto bail_ctx;\n  }\n\n  if (option (OPTSSLSYSTEMCERTS))\n  {\n    if (! SSL_CTX_set_default_verify_paths (ssldata->ctx))\n    {\n      dprint (1, (debugfile, \"mutt_ssl_starttls: Error setting default verify paths\\n\"));\n      goto bail_ctx;\n    }\n  }\n\n  if (SslCertFile && !ssl_load_certificates (ssldata->ctx))\n    dprint (1, (debugfile, \"mutt_ssl_starttls: Error loading trusted certificates\\n\"));\n\n  ssl_get_client_cert(ssldata, conn);\n\n  if (SslCiphers)\n  {\n    if (!SSL_CTX_set_cipher_list (ssldata->ctx, SslCiphers))\n    {\n      dprint (1, (debugfile, \"mutt_ssl_starttls: Could not select preferred ciphers\\n\"));\n      goto bail_ctx;\n    }\n  }\n\n  if (ssl_set_verify_partial (ssldata->ctx))\n  {\n    mutt_error (_(\"Warning: error enabling ssl_verify_partial_chains\"));\n    mutt_sleep (2);\n  }\n\n  if (! (ssldata->ssl = SSL_new (ssldata->ctx)))\n  {\n    dprint (1, (debugfile, \"mutt_ssl_starttls: Error allocating SSL\\n\"));\n    goto bail_ctx;\n  }\n\n  if (SSL_set_fd (ssldata->ssl, conn->fd) != 1)\n  {\n    dprint (1, (debugfile, \"mutt_ssl_starttls: Error setting fd\\n\"));\n    goto bail_ssl;\n  }\n\n  if (ssl_negotiate (conn, ssldata))\n    goto bail_ssl;\n\n  ssldata->isopen = 1;\n\n  /* hmm. watch out if we're starting TLS over any method other than raw. */\n  conn->sockdata = ssldata;\n  conn->conn_read = ssl_socket_read;\n  conn->conn_write = ssl_socket_write;\n  conn->conn_close = tls_close;\n  conn->conn_poll = ssl_socket_poll;\n\n  conn->ssf = SSL_CIPHER_get_bits (SSL_get_current_cipher (ssldata->ssl),\n                                   &maxbits);\n\n  return 0;\n\nbail_ssl:\n  SSL_free (ssldata->ssl);\n  ssldata->ssl = 0;\nbail_ctx:\n  SSL_CTX_free (ssldata->ctx);\n  ssldata->ctx = 0;\nbail_ssldata:\n  FREE (&ssldata);\nbail:\n  return -1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,6 +3,18 @@\n   sslsockdata* ssldata;\n   int maxbits;\n   long ssl_options = 0;\n+\n+  if (mutt_socket_has_buffered_input (conn))\n+  {\n+    /* L10N:\n+       The server is not supposed to send data immediately after\n+       confirming STARTTLS.  This warns the user that something\n+       weird is going on.\n+    */\n+    mutt_error _(\"Warning: clearing unexpected buffered data before STARTTLS\");\n+    mutt_sleep (0);\n+    mutt_socket_clear_buffered_input (conn);\n+  }\n \n   if (ssl_init())\n     goto bail;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "  if (mutt_socket_has_buffered_input (conn))",
                "  {",
                "    /* L10N:",
                "       The server is not supposed to send data immediately after",
                "       confirming STARTTLS.  This warns the user that something",
                "       weird is going on.",
                "    */",
                "    mutt_error _(\"Warning: clearing unexpected buffered data before STARTTLS\");",
                "    mutt_sleep (0);",
                "    mutt_socket_clear_buffered_input (conn);",
                "  }"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-14954",
        "func_name": "muttmua/mutt/mutt_ssl_starttls",
        "description": "Mutt before 1.14.4 and NeoMutt before 2020-06-19 have a STARTTLS buffering issue that affects IMAP, SMTP, and POP3. When a server sends a \"begin TLS\" response, the client reads additional data (e.g., from a man-in-the-middle attacker) and evaluates it in a TLS context, aka \"response injection.\"",
        "git_url": "https://gitlab.com/muttmua/mutt/-/commit/c547433cdf2e79191b15c6932c57f1472bfb5ff4",
        "commit_title": "Fix STARTTLS response injection attack.",
        "commit_text": " Thanks again to Damian Poddebniak and Fabian Ising from the Mnster University of Applied Sciences for reporting this issue.  Their summary in ticket 248 states the issue clearly:    We found another STARTTLS-related issue in Mutt. Unfortunately, it   affects SMTP, POP3 and IMAP.    When the server responds with its \"let's do TLS now message\", e.g. A   OK begin TLS\\r\\n in IMAP or +OK begin TLS\\r\\n in POP3, Mutt will   also read any data after the \\r\\n and save it into some internal   buffer for later processing. This is problematic, because a MITM   attacker can inject arbitrary responses.    There is a nice blogpost by Wietse Venema about a \"command   injection\" in postfix (http://www.postfix.org/CVE-2011-0411.html).   What we have here is the problem in reverse, i.e. not a command   injection, but a \"response injection.\"  This commit fixes the issue by clearing the CONNECTION input buffer in mutt_ssl_starttls().  To make backporting this fix easier, the new functions only clear the top-level CONNECTION buffer; they don't handle nested buffering in mutt_zstrm.c or mutt_sasl.c.  However both of those wrap the connection *after* STARTTLS, so this is currently okay.  mutt_tunnel.c occurs before connecting, but it does not perform any nesting. ",
        "func_before": "int mutt_ssl_starttls (CONNECTION* conn)\n{\n  if (tls_init() < 0)\n    return -1;\n\n  if (tls_negotiate (conn) < 0)\n    return -1;\n\n  conn->conn_read\t= tls_socket_read;\n  conn->conn_write\t= tls_socket_write;\n  conn->conn_close\t= tls_starttls_close;\n  conn->conn_poll       = tls_socket_poll;\n\n  return 0;\n}",
        "func": "int mutt_ssl_starttls (CONNECTION* conn)\n{\n  if (mutt_socket_has_buffered_input (conn))\n  {\n    /* L10N:\n       The server is not supposed to send data immediately after\n       confirming STARTTLS.  This warns the user that something\n       weird is going on.\n    */\n    mutt_error _(\"Warning: clearing unexpected buffered data before STARTTLS\");\n    mutt_sleep (0);\n    mutt_socket_clear_buffered_input (conn);\n  }\n\n  if (tls_init() < 0)\n    return -1;\n\n  if (tls_negotiate (conn) < 0)\n    return -1;\n\n  conn->conn_read\t= tls_socket_read;\n  conn->conn_write\t= tls_socket_write;\n  conn->conn_close\t= tls_starttls_close;\n  conn->conn_poll       = tls_socket_poll;\n\n  return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,17 @@\n int mutt_ssl_starttls (CONNECTION* conn)\n {\n+  if (mutt_socket_has_buffered_input (conn))\n+  {\n+    /* L10N:\n+       The server is not supposed to send data immediately after\n+       confirming STARTTLS.  This warns the user that something\n+       weird is going on.\n+    */\n+    mutt_error _(\"Warning: clearing unexpected buffered data before STARTTLS\");\n+    mutt_sleep (0);\n+    mutt_socket_clear_buffered_input (conn);\n+  }\n+\n   if (tls_init() < 0)\n     return -1;\n ",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "  if (mutt_socket_has_buffered_input (conn))",
                "  {",
                "    /* L10N:",
                "       The server is not supposed to send data immediately after",
                "       confirming STARTTLS.  This warns the user that something",
                "       weird is going on.",
                "    */",
                "    mutt_error _(\"Warning: clearing unexpected buffered data before STARTTLS\");",
                "    mutt_sleep (0);",
                "    mutt_socket_clear_buffered_input (conn);",
                "  }",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2020-14954",
        "func_name": "neomutt/nntp_open_connection",
        "description": "Mutt before 1.14.4 and NeoMutt before 2020-06-19 have a STARTTLS buffering issue that affects IMAP, SMTP, and POP3. When a server sends a \"begin TLS\" response, the client reads additional data (e.g., from a man-in-the-middle attacker) and evaluates it in a TLS context, aka \"response injection.\"",
        "git_url": "https://github.com/neomutt/neomutt/commit/fb013ec666759cb8a9e294347c7b4c1f597639cc",
        "commit_title": "tls: clear data after a starttls acknowledgement",
        "commit_text": " After a starttls acknowledgement message, clear the buffers of any incoming data / commands.  This will ensure that all future data is handled securely.  Co-authored-by: Pietro Cerutti <gahr@gahr.ch>",
        "func_before": "int nntp_open_connection(struct NntpAccountData *adata)\n{\n  struct Connection *conn = adata->conn;\n  char buf[256];\n  int cap;\n  bool posting = false, auth = true;\n\n  if (adata->status == NNTP_OK)\n    return 0;\n  if (adata->status == NNTP_BYE)\n    return -1;\n  adata->status = NNTP_NONE;\n\n  if (mutt_socket_open(conn) < 0)\n    return -1;\n\n  if (mutt_socket_readln(buf, sizeof(buf), conn) < 0)\n    return nntp_connect_error(adata);\n\n  if (mutt_str_startswith(buf, \"200\", CASE_MATCH))\n    posting = true;\n  else if (!mutt_str_startswith(buf, \"201\", CASE_MATCH))\n  {\n    mutt_socket_close(conn);\n    mutt_str_remove_trailing_ws(buf);\n    mutt_error(\"%s\", buf);\n    return -1;\n  }\n\n  /* get initial capabilities */\n  cap = nntp_capabilities(adata);\n  if (cap < 0)\n    return -1;\n\n  /* tell news server to switch to mode reader if it isn't so */\n  if (cap > 0)\n  {\n    if ((mutt_socket_send(conn, \"MODE READER\\r\\n\") < 0) ||\n        (mutt_socket_readln(buf, sizeof(buf), conn) < 0))\n    {\n      return nntp_connect_error(adata);\n    }\n\n    if (mutt_str_startswith(buf, \"200\", CASE_MATCH))\n      posting = true;\n    else if (mutt_str_startswith(buf, \"201\", CASE_MATCH))\n      posting = false;\n    /* error if has capabilities, ignore result if no capabilities */\n    else if (adata->hasCAPABILITIES)\n    {\n      mutt_socket_close(conn);\n      mutt_error(_(\"Could not switch to reader mode\"));\n      return -1;\n    }\n\n    /* recheck capabilities after MODE READER */\n    if (adata->hasCAPABILITIES)\n    {\n      cap = nntp_capabilities(adata);\n      if (cap < 0)\n        return -1;\n    }\n  }\n\n  mutt_message(_(\"Connected to %s. %s\"), conn->account.host,\n               posting ? _(\"Posting is ok\") : _(\"Posting is NOT ok\"));\n  mutt_sleep(1);\n\n#ifdef USE_SSL\n  /* Attempt STARTTLS if available and desired. */\n  if ((adata->use_tls != 1) && (adata->hasSTARTTLS || C_SslForceTls))\n  {\n    if (adata->use_tls == 0)\n    {\n      adata->use_tls =\n          C_SslForceTls || query_quadoption(C_SslStarttls,\n                                            _(\"Secure connection with TLS?\")) == MUTT_YES ?\n              2 :\n              1;\n    }\n    if (adata->use_tls == 2)\n    {\n      if ((mutt_socket_send(conn, \"STARTTLS\\r\\n\") < 0) ||\n          (mutt_socket_readln(buf, sizeof(buf), conn) < 0))\n      {\n        return nntp_connect_error(adata);\n      }\n      if (!mutt_str_startswith(buf, \"382\", CASE_MATCH))\n      {\n        adata->use_tls = 0;\n        mutt_error(\"STARTTLS: %s\", buf);\n      }\n      else if (mutt_ssl_starttls(conn))\n      {\n        adata->use_tls = 0;\n        adata->status = NNTP_NONE;\n        mutt_socket_close(adata->conn);\n        mutt_error(_(\"Could not negotiate TLS connection\"));\n        return -1;\n      }\n      else\n      {\n        /* recheck capabilities after STARTTLS */\n        cap = nntp_capabilities(adata);\n        if (cap < 0)\n          return -1;\n      }\n    }\n  }\n#endif\n\n  /* authentication required? */\n  if (conn->account.flags & MUTT_ACCT_USER)\n  {\n    if (!conn->account.user[0])\n      auth = false;\n  }\n  else\n  {\n    if ((mutt_socket_send(conn, \"STAT\\r\\n\") < 0) ||\n        (mutt_socket_readln(buf, sizeof(buf), conn) < 0))\n    {\n      return nntp_connect_error(adata);\n    }\n    if (!mutt_str_startswith(buf, \"480\", CASE_MATCH))\n      auth = false;\n  }\n\n  /* authenticate */\n  if (auth && (nntp_auth(adata) < 0))\n    return -1;\n\n  /* get final capabilities after authentication */\n  if (adata->hasCAPABILITIES && (auth || (cap > 0)))\n  {\n    cap = nntp_capabilities(adata);\n    if (cap < 0)\n      return -1;\n    if (cap > 0)\n    {\n      mutt_socket_close(conn);\n      mutt_error(_(\"Could not switch to reader mode\"));\n      return -1;\n    }\n  }\n\n  /* attempt features */\n  if (nntp_attempt_features(adata) < 0)\n    return -1;\n\n  adata->status = NNTP_OK;\n  return 0;\n}",
        "func": "int nntp_open_connection(struct NntpAccountData *adata)\n{\n  struct Connection *conn = adata->conn;\n  char buf[256];\n  int cap;\n  bool posting = false, auth = true;\n\n  if (adata->status == NNTP_OK)\n    return 0;\n  if (adata->status == NNTP_BYE)\n    return -1;\n  adata->status = NNTP_NONE;\n\n  if (mutt_socket_open(conn) < 0)\n    return -1;\n\n  if (mutt_socket_readln(buf, sizeof(buf), conn) < 0)\n    return nntp_connect_error(adata);\n\n  if (mutt_str_startswith(buf, \"200\", CASE_MATCH))\n    posting = true;\n  else if (!mutt_str_startswith(buf, \"201\", CASE_MATCH))\n  {\n    mutt_socket_close(conn);\n    mutt_str_remove_trailing_ws(buf);\n    mutt_error(\"%s\", buf);\n    return -1;\n  }\n\n  /* get initial capabilities */\n  cap = nntp_capabilities(adata);\n  if (cap < 0)\n    return -1;\n\n  /* tell news server to switch to mode reader if it isn't so */\n  if (cap > 0)\n  {\n    if ((mutt_socket_send(conn, \"MODE READER\\r\\n\") < 0) ||\n        (mutt_socket_readln(buf, sizeof(buf), conn) < 0))\n    {\n      return nntp_connect_error(adata);\n    }\n\n    if (mutt_str_startswith(buf, \"200\", CASE_MATCH))\n      posting = true;\n    else if (mutt_str_startswith(buf, \"201\", CASE_MATCH))\n      posting = false;\n    /* error if has capabilities, ignore result if no capabilities */\n    else if (adata->hasCAPABILITIES)\n    {\n      mutt_socket_close(conn);\n      mutt_error(_(\"Could not switch to reader mode\"));\n      return -1;\n    }\n\n    /* recheck capabilities after MODE READER */\n    if (adata->hasCAPABILITIES)\n    {\n      cap = nntp_capabilities(adata);\n      if (cap < 0)\n        return -1;\n    }\n  }\n\n  mutt_message(_(\"Connected to %s. %s\"), conn->account.host,\n               posting ? _(\"Posting is ok\") : _(\"Posting is NOT ok\"));\n  mutt_sleep(1);\n\n#ifdef USE_SSL\n  /* Attempt STARTTLS if available and desired. */\n  if ((adata->use_tls != 1) && (adata->hasSTARTTLS || C_SslForceTls))\n  {\n    if (adata->use_tls == 0)\n    {\n      adata->use_tls =\n          C_SslForceTls || query_quadoption(C_SslStarttls,\n                                            _(\"Secure connection with TLS?\")) == MUTT_YES ?\n              2 :\n              1;\n    }\n    if (adata->use_tls == 2)\n    {\n      if ((mutt_socket_send(conn, \"STARTTLS\\r\\n\") < 0) ||\n          (mutt_socket_readln(buf, sizeof(buf), conn) < 0))\n      {\n        return nntp_connect_error(adata);\n      }\n      // Clear any data after the STARTTLS acknowledgement\n      mutt_socket_empty(conn);\n      if (!mutt_str_startswith(buf, \"382\", CASE_MATCH))\n      {\n        adata->use_tls = 0;\n        mutt_error(\"STARTTLS: %s\", buf);\n      }\n      else if (mutt_ssl_starttls(conn))\n      {\n        adata->use_tls = 0;\n        adata->status = NNTP_NONE;\n        mutt_socket_close(adata->conn);\n        mutt_error(_(\"Could not negotiate TLS connection\"));\n        return -1;\n      }\n      else\n      {\n        /* recheck capabilities after STARTTLS */\n        cap = nntp_capabilities(adata);\n        if (cap < 0)\n          return -1;\n      }\n    }\n  }\n#endif\n\n  /* authentication required? */\n  if (conn->account.flags & MUTT_ACCT_USER)\n  {\n    if (!conn->account.user[0])\n      auth = false;\n  }\n  else\n  {\n    if ((mutt_socket_send(conn, \"STAT\\r\\n\") < 0) ||\n        (mutt_socket_readln(buf, sizeof(buf), conn) < 0))\n    {\n      return nntp_connect_error(adata);\n    }\n    if (!mutt_str_startswith(buf, \"480\", CASE_MATCH))\n      auth = false;\n  }\n\n  /* authenticate */\n  if (auth && (nntp_auth(adata) < 0))\n    return -1;\n\n  /* get final capabilities after authentication */\n  if (adata->hasCAPABILITIES && (auth || (cap > 0)))\n  {\n    cap = nntp_capabilities(adata);\n    if (cap < 0)\n      return -1;\n    if (cap > 0)\n    {\n      mutt_socket_close(conn);\n      mutt_error(_(\"Could not switch to reader mode\"));\n      return -1;\n    }\n  }\n\n  /* attempt features */\n  if (nntp_attempt_features(adata) < 0)\n    return -1;\n\n  adata->status = NNTP_OK;\n  return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -85,6 +85,8 @@\n       {\n         return nntp_connect_error(adata);\n       }\n+      // Clear any data after the STARTTLS acknowledgement\n+      mutt_socket_empty(conn);\n       if (!mutt_str_startswith(buf, \"382\", CASE_MATCH))\n       {\n         adata->use_tls = 0;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "      // Clear any data after the STARTTLS acknowledgement",
                "      mutt_socket_empty(conn);"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-14954",
        "func_name": "neomutt/pop_open_connection",
        "description": "Mutt before 1.14.4 and NeoMutt before 2020-06-19 have a STARTTLS buffering issue that affects IMAP, SMTP, and POP3. When a server sends a \"begin TLS\" response, the client reads additional data (e.g., from a man-in-the-middle attacker) and evaluates it in a TLS context, aka \"response injection.\"",
        "git_url": "https://github.com/neomutt/neomutt/commit/fb013ec666759cb8a9e294347c7b4c1f597639cc",
        "commit_title": "tls: clear data after a starttls acknowledgement",
        "commit_text": " After a starttls acknowledgement message, clear the buffers of any incoming data / commands.  This will ensure that all future data is handled securely.  Co-authored-by: Pietro Cerutti <gahr@gahr.ch>",
        "func_before": "int pop_open_connection(struct PopAccountData *adata)\n{\n  char buf[1024];\n\n  int rc = pop_connect(adata);\n  if (rc < 0)\n    return rc;\n\n  rc = pop_capabilities(adata, 0);\n  if (rc == -1)\n    goto err_conn;\n  if (rc == -2)\n    return -2;\n\n#ifdef USE_SSL\n  /* Attempt STLS if available and desired. */\n  if (!adata->conn->ssf && (adata->cmd_stls || C_SslForceTls))\n  {\n    if (C_SslForceTls)\n      adata->use_stls = 2;\n    if (adata->use_stls == 0)\n    {\n      enum QuadOption ans =\n          query_quadoption(C_SslStarttls, _(\"Secure connection with TLS?\"));\n      if (ans == MUTT_ABORT)\n        return -2;\n      adata->use_stls = 1;\n      if (ans == MUTT_YES)\n        adata->use_stls = 2;\n    }\n    if (adata->use_stls == 2)\n    {\n      mutt_str_strfcpy(buf, \"STLS\\r\\n\", sizeof(buf));\n      rc = pop_query(adata, buf, sizeof(buf));\n      if (rc == -1)\n        goto err_conn;\n      if (rc != 0)\n      {\n        mutt_error(\"%s\", adata->err_msg);\n      }\n      else if (mutt_ssl_starttls(adata->conn))\n      {\n        mutt_error(_(\"Could not negotiate TLS connection\"));\n        return -2;\n      }\n      else\n      {\n        /* recheck capabilities after STLS completes */\n        rc = pop_capabilities(adata, 1);\n        if (rc == -1)\n          goto err_conn;\n        if (rc == -2)\n          return -2;\n      }\n    }\n  }\n\n  if (C_SslForceTls && !adata->conn->ssf)\n  {\n    mutt_error(_(\"Encrypted connection unavailable\"));\n    return -2;\n  }\n#endif\n\n  rc = pop_authenticate(adata);\n  if (rc == -1)\n    goto err_conn;\n  if (rc == -3)\n    mutt_clear_error();\n  if (rc != 0)\n    return rc;\n\n  /* recheck capabilities after authentication */\n  rc = pop_capabilities(adata, 2);\n  if (rc == -1)\n    goto err_conn;\n  if (rc == -2)\n    return -2;\n\n  /* get total size of mailbox */\n  mutt_str_strfcpy(buf, \"STAT\\r\\n\", sizeof(buf));\n  rc = pop_query(adata, buf, sizeof(buf));\n  if (rc == -1)\n    goto err_conn;\n  if (rc == -2)\n  {\n    mutt_error(\"%s\", adata->err_msg);\n    return rc;\n  }\n\n  unsigned int n = 0, size = 0;\n  sscanf(buf, \"+OK %u %u\", &n, &size);\n  adata->size = size;\n  return 0;\n\nerr_conn:\n  adata->status = POP_DISCONNECTED;\n  mutt_error(_(\"Server closed connection\"));\n  return -1;\n}",
        "func": "int pop_open_connection(struct PopAccountData *adata)\n{\n  char buf[1024];\n\n  int rc = pop_connect(adata);\n  if (rc < 0)\n    return rc;\n\n  rc = pop_capabilities(adata, 0);\n  if (rc == -1)\n    goto err_conn;\n  if (rc == -2)\n    return -2;\n\n#ifdef USE_SSL\n  /* Attempt STLS if available and desired. */\n  if (!adata->conn->ssf && (adata->cmd_stls || C_SslForceTls))\n  {\n    if (C_SslForceTls)\n      adata->use_stls = 2;\n    if (adata->use_stls == 0)\n    {\n      enum QuadOption ans =\n          query_quadoption(C_SslStarttls, _(\"Secure connection with TLS?\"));\n      if (ans == MUTT_ABORT)\n        return -2;\n      adata->use_stls = 1;\n      if (ans == MUTT_YES)\n        adata->use_stls = 2;\n    }\n    if (adata->use_stls == 2)\n    {\n      mutt_str_strfcpy(buf, \"STLS\\r\\n\", sizeof(buf));\n      rc = pop_query(adata, buf, sizeof(buf));\n      // Clear any data after the STLS acknowledgement\n      mutt_socket_empty(adata->conn);\n      if (rc == -1)\n        goto err_conn;\n      if (rc != 0)\n      {\n        mutt_error(\"%s\", adata->err_msg);\n      }\n      else if (mutt_ssl_starttls(adata->conn))\n      {\n        mutt_error(_(\"Could not negotiate TLS connection\"));\n        return -2;\n      }\n      else\n      {\n        /* recheck capabilities after STLS completes */\n        rc = pop_capabilities(adata, 1);\n        if (rc == -1)\n          goto err_conn;\n        if (rc == -2)\n          return -2;\n      }\n    }\n  }\n\n  if (C_SslForceTls && !adata->conn->ssf)\n  {\n    mutt_error(_(\"Encrypted connection unavailable\"));\n    return -2;\n  }\n#endif\n\n  rc = pop_authenticate(adata);\n  if (rc == -1)\n    goto err_conn;\n  if (rc == -3)\n    mutt_clear_error();\n  if (rc != 0)\n    return rc;\n\n  /* recheck capabilities after authentication */\n  rc = pop_capabilities(adata, 2);\n  if (rc == -1)\n    goto err_conn;\n  if (rc == -2)\n    return -2;\n\n  /* get total size of mailbox */\n  mutt_str_strfcpy(buf, \"STAT\\r\\n\", sizeof(buf));\n  rc = pop_query(adata, buf, sizeof(buf));\n  if (rc == -1)\n    goto err_conn;\n  if (rc == -2)\n  {\n    mutt_error(\"%s\", adata->err_msg);\n    return rc;\n  }\n\n  unsigned int n = 0, size = 0;\n  sscanf(buf, \"+OK %u %u\", &n, &size);\n  adata->size = size;\n  return 0;\n\nerr_conn:\n  adata->status = POP_DISCONNECTED;\n  mutt_error(_(\"Server closed connection\"));\n  return -1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -32,6 +32,8 @@\n     {\n       mutt_str_strfcpy(buf, \"STLS\\r\\n\", sizeof(buf));\n       rc = pop_query(adata, buf, sizeof(buf));\n+      // Clear any data after the STLS acknowledgement\n+      mutt_socket_empty(adata->conn);\n       if (rc == -1)\n         goto err_conn;\n       if (rc != 0)",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "      // Clear any data after the STLS acknowledgement",
                "      mutt_socket_empty(adata->conn);"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-14954",
        "func_name": "neomutt/imap_open_connection",
        "description": "Mutt before 1.14.4 and NeoMutt before 2020-06-19 have a STARTTLS buffering issue that affects IMAP, SMTP, and POP3. When a server sends a \"begin TLS\" response, the client reads additional data (e.g., from a man-in-the-middle attacker) and evaluates it in a TLS context, aka \"response injection.\"",
        "git_url": "https://github.com/neomutt/neomutt/commit/fb013ec666759cb8a9e294347c7b4c1f597639cc",
        "commit_title": "tls: clear data after a starttls acknowledgement",
        "commit_text": " After a starttls acknowledgement message, clear the buffers of any incoming data / commands.  This will ensure that all future data is handled securely.  Co-authored-by: Pietro Cerutti <gahr@gahr.ch>",
        "func_before": "int imap_open_connection(struct ImapAccountData *adata)\n{\n  if (mutt_socket_open(adata->conn) < 0)\n    return -1;\n\n  adata->state = IMAP_CONNECTED;\n\n  if (imap_cmd_step(adata) != IMAP_RES_OK)\n  {\n    imap_close_connection(adata);\n    return -1;\n  }\n\n  if (mutt_str_startswith(adata->buf, \"* OK\", CASE_IGNORE))\n  {\n    if (!mutt_str_startswith(adata->buf, \"* OK [CAPABILITY\", CASE_IGNORE) &&\n        check_capabilities(adata))\n    {\n      goto bail;\n    }\n#ifdef USE_SSL\n    /* Attempt STARTTLS if available and desired. */\n    if (!adata->conn->ssf && (C_SslForceTls || (adata->capabilities & IMAP_CAP_STARTTLS)))\n    {\n      enum QuadOption ans;\n\n      if (C_SslForceTls)\n        ans = MUTT_YES;\n      else if ((ans = query_quadoption(C_SslStarttls,\n                                       _(\"Secure connection with TLS?\"))) == MUTT_ABORT)\n      {\n        goto err_close_conn;\n      }\n      if (ans == MUTT_YES)\n      {\n        enum ImapExecResult rc = imap_exec(adata, \"STARTTLS\", IMAP_CMD_NO_FLAGS);\n        if (rc == IMAP_EXEC_FATAL)\n          goto bail;\n        if (rc != IMAP_EXEC_ERROR)\n        {\n          if (mutt_ssl_starttls(adata->conn))\n          {\n            mutt_error(_(\"Could not negotiate TLS connection\"));\n            goto err_close_conn;\n          }\n          else\n          {\n            /* RFC2595 demands we recheck CAPABILITY after TLS completes. */\n            if (imap_exec(adata, \"CAPABILITY\", IMAP_CMD_NO_FLAGS))\n              goto bail;\n          }\n        }\n      }\n    }\n\n    if (C_SslForceTls && !adata->conn->ssf)\n    {\n      mutt_error(_(\"Encrypted connection unavailable\"));\n      goto err_close_conn;\n    }\n#endif\n  }\n  else if (mutt_str_startswith(adata->buf, \"* PREAUTH\", CASE_IGNORE))\n  {\n#ifdef USE_SSL\n    /* An unencrypted PREAUTH response is most likely a MITM attack.\n     * Require a confirmation. */\n    if (adata->conn->ssf == 0)\n    {\n      bool proceed = true;\n      if (C_SslForceTls)\n      {\n        proceed = false;\n      }\n      else if (C_SslStarttls != MUTT_NO)\n      {\n        proceed = mutt_yesorno(_(\"Abort unencrypted PREAUTH connection?\"),\n                               C_SslStarttls) != MUTT_NO;\n      }\n      if (!proceed)\n      {\n        mutt_error(_(\"Encrypted connection unavailable\"));\n        goto err_close_conn;\n      }\n    }\n#endif\n\n    adata->state = IMAP_AUTHENTICATED;\n    if (check_capabilities(adata) != 0)\n      goto bail;\n    FREE(&adata->capstr);\n  }\n  else\n  {\n    imap_error(\"imap_open_connection()\", adata->buf);\n    goto bail;\n  }\n\n  return 0;\n\n#ifdef USE_SSL\nerr_close_conn:\n  imap_close_connection(adata);\n#endif\nbail:\n  FREE(&adata->capstr);\n  return -1;\n}",
        "func": "int imap_open_connection(struct ImapAccountData *adata)\n{\n  if (mutt_socket_open(adata->conn) < 0)\n    return -1;\n\n  adata->state = IMAP_CONNECTED;\n\n  if (imap_cmd_step(adata) != IMAP_RES_OK)\n  {\n    imap_close_connection(adata);\n    return -1;\n  }\n\n  if (mutt_str_startswith(adata->buf, \"* OK\", CASE_IGNORE))\n  {\n    if (!mutt_str_startswith(adata->buf, \"* OK [CAPABILITY\", CASE_IGNORE) &&\n        check_capabilities(adata))\n    {\n      goto bail;\n    }\n#ifdef USE_SSL\n    /* Attempt STARTTLS if available and desired. */\n    if (!adata->conn->ssf && (C_SslForceTls || (adata->capabilities & IMAP_CAP_STARTTLS)))\n    {\n      enum QuadOption ans;\n\n      if (C_SslForceTls)\n        ans = MUTT_YES;\n      else if ((ans = query_quadoption(C_SslStarttls,\n                                       _(\"Secure connection with TLS?\"))) == MUTT_ABORT)\n      {\n        goto err_close_conn;\n      }\n      if (ans == MUTT_YES)\n      {\n        enum ImapExecResult rc = imap_exec(adata, \"STARTTLS\", IMAP_CMD_SINGLE);\n        // Clear any data after the STARTTLS acknowledgement\n        mutt_socket_empty(adata->conn);\n\n        if (rc == IMAP_EXEC_FATAL)\n          goto bail;\n        if (rc != IMAP_EXEC_ERROR)\n        {\n          if (mutt_ssl_starttls(adata->conn))\n          {\n            mutt_error(_(\"Could not negotiate TLS connection\"));\n            goto err_close_conn;\n          }\n          else\n          {\n            /* RFC2595 demands we recheck CAPABILITY after TLS completes. */\n            if (imap_exec(adata, \"CAPABILITY\", IMAP_CMD_NO_FLAGS))\n              goto bail;\n          }\n        }\n      }\n    }\n\n    if (C_SslForceTls && !adata->conn->ssf)\n    {\n      mutt_error(_(\"Encrypted connection unavailable\"));\n      goto err_close_conn;\n    }\n#endif\n  }\n  else if (mutt_str_startswith(adata->buf, \"* PREAUTH\", CASE_IGNORE))\n  {\n#ifdef USE_SSL\n    /* An unencrypted PREAUTH response is most likely a MITM attack.\n     * Require a confirmation. */\n    if (adata->conn->ssf == 0)\n    {\n      bool proceed = true;\n      if (C_SslForceTls)\n      {\n        proceed = false;\n      }\n      else if (C_SslStarttls != MUTT_NO)\n      {\n        proceed = mutt_yesorno(_(\"Abort unencrypted PREAUTH connection?\"),\n                               C_SslStarttls) != MUTT_NO;\n      }\n      if (!proceed)\n      {\n        mutt_error(_(\"Encrypted connection unavailable\"));\n        goto err_close_conn;\n      }\n    }\n#endif\n\n    adata->state = IMAP_AUTHENTICATED;\n    if (check_capabilities(adata) != 0)\n      goto bail;\n    FREE(&adata->capstr);\n  }\n  else\n  {\n    imap_error(\"imap_open_connection()\", adata->buf);\n    goto bail;\n  }\n\n  return 0;\n\n#ifdef USE_SSL\nerr_close_conn:\n  imap_close_connection(adata);\n#endif\nbail:\n  FREE(&adata->capstr);\n  return -1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -33,7 +33,10 @@\n       }\n       if (ans == MUTT_YES)\n       {\n-        enum ImapExecResult rc = imap_exec(adata, \"STARTTLS\", IMAP_CMD_NO_FLAGS);\n+        enum ImapExecResult rc = imap_exec(adata, \"STARTTLS\", IMAP_CMD_SINGLE);\n+        // Clear any data after the STARTTLS acknowledgement\n+        mutt_socket_empty(adata->conn);\n+\n         if (rc == IMAP_EXEC_FATAL)\n           goto bail;\n         if (rc != IMAP_EXEC_ERROR)",
        "diff_line_info": {
            "deleted_lines": [
                "        enum ImapExecResult rc = imap_exec(adata, \"STARTTLS\", IMAP_CMD_NO_FLAGS);"
            ],
            "added_lines": [
                "        enum ImapExecResult rc = imap_exec(adata, \"STARTTLS\", IMAP_CMD_SINGLE);",
                "        // Clear any data after the STARTTLS acknowledgement",
                "        mutt_socket_empty(adata->conn);",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2020-14954",
        "func_name": "neomutt/imap_exec",
        "description": "Mutt before 1.14.4 and NeoMutt before 2020-06-19 have a STARTTLS buffering issue that affects IMAP, SMTP, and POP3. When a server sends a \"begin TLS\" response, the client reads additional data (e.g., from a man-in-the-middle attacker) and evaluates it in a TLS context, aka \"response injection.\"",
        "git_url": "https://github.com/neomutt/neomutt/commit/fb013ec666759cb8a9e294347c7b4c1f597639cc",
        "commit_title": "tls: clear data after a starttls acknowledgement",
        "commit_text": " After a starttls acknowledgement message, clear the buffers of any incoming data / commands.  This will ensure that all future data is handled securely.  Co-authored-by: Pietro Cerutti <gahr@gahr.ch>",
        "func_before": "int imap_exec(struct ImapAccountData *adata, const char *cmdstr, ImapCmdFlags flags)\n{\n  int rc;\n\n  rc = cmd_start(adata, cmdstr, flags);\n  if (rc < 0)\n  {\n    cmd_handle_fatal(adata);\n    return IMAP_EXEC_FATAL;\n  }\n\n  if (flags & IMAP_CMD_QUEUE)\n    return IMAP_EXEC_SUCCESS;\n\n  if ((flags & IMAP_CMD_POLL) && (C_ImapPollTimeout > 0) &&\n      ((mutt_socket_poll(adata->conn, C_ImapPollTimeout)) == 0))\n  {\n    mutt_error(_(\"Connection to %s timed out\"), adata->conn->account.host);\n    cmd_handle_fatal(adata);\n    return IMAP_EXEC_FATAL;\n  }\n\n  /* Allow interruptions, particularly useful if there are network problems. */\n  mutt_sig_allow_interrupt(true);\n  do\n  {\n    rc = imap_cmd_step(adata);\n  } while (rc == IMAP_RES_CONTINUE);\n  mutt_sig_allow_interrupt(false);\n\n  if (rc == IMAP_RES_NO)\n    return IMAP_EXEC_ERROR;\n  if (rc != IMAP_RES_OK)\n  {\n    if (adata->status != IMAP_FATAL)\n      return IMAP_EXEC_ERROR;\n\n    mutt_debug(LL_DEBUG1, \"command failed: %s\\n\", adata->buf);\n    return IMAP_EXEC_FATAL;\n  }\n\n  return IMAP_EXEC_SUCCESS;\n}",
        "func": "int imap_exec(struct ImapAccountData *adata, const char *cmdstr, ImapCmdFlags flags)\n{\n  int rc;\n\n  if (flags & IMAP_CMD_SINGLE)\n  {\n    // Process any existing commands\n    if (adata->nextcmd != adata->lastcmd)\n      imap_exec(adata, NULL, IMAP_CMD_POLL);\n  }\n\n  rc = cmd_start(adata, cmdstr, flags);\n  if (rc < 0)\n  {\n    cmd_handle_fatal(adata);\n    return IMAP_EXEC_FATAL;\n  }\n\n  if (flags & IMAP_CMD_QUEUE)\n    return IMAP_EXEC_SUCCESS;\n\n  if ((flags & IMAP_CMD_POLL) && (C_ImapPollTimeout > 0) &&\n      ((mutt_socket_poll(adata->conn, C_ImapPollTimeout)) == 0))\n  {\n    mutt_error(_(\"Connection to %s timed out\"), adata->conn->account.host);\n    cmd_handle_fatal(adata);\n    return IMAP_EXEC_FATAL;\n  }\n\n  /* Allow interruptions, particularly useful if there are network problems. */\n  mutt_sig_allow_interrupt(true);\n  do\n  {\n    rc = imap_cmd_step(adata);\n    // The queue is empty, so the single command has been processed\n    if ((flags & IMAP_CMD_SINGLE) && (adata->nextcmd == adata->lastcmd))\n      break;\n  } while (rc == IMAP_RES_CONTINUE);\n  mutt_sig_allow_interrupt(false);\n\n  if (rc == IMAP_RES_NO)\n    return IMAP_EXEC_ERROR;\n  if (rc != IMAP_RES_OK)\n  {\n    if (adata->status != IMAP_FATAL)\n      return IMAP_EXEC_ERROR;\n\n    mutt_debug(LL_DEBUG1, \"command failed: %s\\n\", adata->buf);\n    return IMAP_EXEC_FATAL;\n  }\n\n  return IMAP_EXEC_SUCCESS;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,13 @@\n int imap_exec(struct ImapAccountData *adata, const char *cmdstr, ImapCmdFlags flags)\n {\n   int rc;\n+\n+  if (flags & IMAP_CMD_SINGLE)\n+  {\n+    // Process any existing commands\n+    if (adata->nextcmd != adata->lastcmd)\n+      imap_exec(adata, NULL, IMAP_CMD_POLL);\n+  }\n \n   rc = cmd_start(adata, cmdstr, flags);\n   if (rc < 0)\n@@ -25,6 +32,9 @@\n   do\n   {\n     rc = imap_cmd_step(adata);\n+    // The queue is empty, so the single command has been processed\n+    if ((flags & IMAP_CMD_SINGLE) && (adata->nextcmd == adata->lastcmd))\n+      break;\n   } while (rc == IMAP_RES_CONTINUE);\n   mutt_sig_allow_interrupt(false);\n ",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "  if (flags & IMAP_CMD_SINGLE)",
                "  {",
                "    // Process any existing commands",
                "    if (adata->nextcmd != adata->lastcmd)",
                "      imap_exec(adata, NULL, IMAP_CMD_POLL);",
                "  }",
                "    // The queue is empty, so the single command has been processed",
                "    if ((flags & IMAP_CMD_SINGLE) && (adata->nextcmd == adata->lastcmd))",
                "      break;"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-14954",
        "func_name": "neomutt/smtp_open",
        "description": "Mutt before 1.14.4 and NeoMutt before 2020-06-19 have a STARTTLS buffering issue that affects IMAP, SMTP, and POP3. When a server sends a \"begin TLS\" response, the client reads additional data (e.g., from a man-in-the-middle attacker) and evaluates it in a TLS context, aka \"response injection.\"",
        "git_url": "https://github.com/neomutt/neomutt/commit/fb013ec666759cb8a9e294347c7b4c1f597639cc",
        "commit_title": "tls: clear data after a starttls acknowledgement",
        "commit_text": " After a starttls acknowledgement message, clear the buffers of any incoming data / commands.  This will ensure that all future data is handled securely.  Co-authored-by: Pietro Cerutti <gahr@gahr.ch>",
        "func_before": "static int smtp_open(struct Connection *conn, bool esmtp)\n{\n  int rc;\n\n  if (mutt_socket_open(conn))\n    return -1;\n\n  /* get greeting string */\n  rc = smtp_get_resp(conn);\n  if (rc != 0)\n    return rc;\n\n  rc = smtp_helo(conn, esmtp);\n  if (rc != 0)\n    return rc;\n\n#ifdef USE_SSL\n  enum QuadOption ans = MUTT_NO;\n  if (conn->ssf)\n    ans = MUTT_NO;\n  else if (C_SslForceTls)\n    ans = MUTT_YES;\n  else if ((Capabilities & SMTP_CAP_STARTTLS) &&\n           ((ans = query_quadoption(C_SslStarttls,\n                                    _(\"Secure connection with TLS?\"))) == MUTT_ABORT))\n  {\n    return -1;\n  }\n\n  if (ans == MUTT_YES)\n  {\n    if (mutt_socket_send(conn, \"STARTTLS\\r\\n\") < 0)\n      return SMTP_ERR_WRITE;\n    rc = smtp_get_resp(conn);\n    if (rc != 0)\n      return rc;\n\n    if (mutt_ssl_starttls(conn))\n    {\n      mutt_error(_(\"Could not negotiate TLS connection\"));\n      return -1;\n    }\n\n    /* re-EHLO to get authentication mechanisms */\n    rc = smtp_helo(conn, esmtp);\n    if (rc != 0)\n      return rc;\n  }\n#endif\n\n  if (conn->account.flags & MUTT_ACCT_USER)\n  {\n    if (!(Capabilities & SMTP_CAP_AUTH))\n    {\n      mutt_error(_(\"SMTP server does not support authentication\"));\n      return -1;\n    }\n\n    return smtp_auth(conn);\n  }\n\n  return 0;\n}",
        "func": "static int smtp_open(struct Connection *conn, bool esmtp)\n{\n  int rc;\n\n  if (mutt_socket_open(conn))\n    return -1;\n\n  /* get greeting string */\n  rc = smtp_get_resp(conn);\n  if (rc != 0)\n    return rc;\n\n  rc = smtp_helo(conn, esmtp);\n  if (rc != 0)\n    return rc;\n\n#ifdef USE_SSL\n  enum QuadOption ans = MUTT_NO;\n  if (conn->ssf)\n    ans = MUTT_NO;\n  else if (C_SslForceTls)\n    ans = MUTT_YES;\n  else if ((Capabilities & SMTP_CAP_STARTTLS) &&\n           ((ans = query_quadoption(C_SslStarttls,\n                                    _(\"Secure connection with TLS?\"))) == MUTT_ABORT))\n  {\n    return -1;\n  }\n\n  if (ans == MUTT_YES)\n  {\n    if (mutt_socket_send(conn, \"STARTTLS\\r\\n\") < 0)\n      return SMTP_ERR_WRITE;\n    rc = smtp_get_resp(conn);\n    // Clear any data after the STARTTLS acknowledgement\n    mutt_socket_empty(conn);\n    if (rc != 0)\n      return rc;\n\n    if (mutt_ssl_starttls(conn))\n    {\n      mutt_error(_(\"Could not negotiate TLS connection\"));\n      return -1;\n    }\n\n    /* re-EHLO to get authentication mechanisms */\n    rc = smtp_helo(conn, esmtp);\n    if (rc != 0)\n      return rc;\n  }\n#endif\n\n  if (conn->account.flags & MUTT_ACCT_USER)\n  {\n    if (!(Capabilities & SMTP_CAP_AUTH))\n    {\n      mutt_error(_(\"SMTP server does not support authentication\"));\n      return -1;\n    }\n\n    return smtp_auth(conn);\n  }\n\n  return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -32,6 +32,8 @@\n     if (mutt_socket_send(conn, \"STARTTLS\\r\\n\") < 0)\n       return SMTP_ERR_WRITE;\n     rc = smtp_get_resp(conn);\n+    // Clear any data after the STARTTLS acknowledgement\n+    mutt_socket_empty(conn);\n     if (rc != 0)\n       return rc;\n ",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    // Clear any data after the STARTTLS acknowledgement",
                "    mutt_socket_empty(conn);"
            ]
        }
    }
]