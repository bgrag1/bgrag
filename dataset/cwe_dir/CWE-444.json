[
    {
        "cve_id": "CVE-2021-36740",
        "func_name": "varnishcache/varnish-cache/h2_vfp_body",
        "description": "Varnish Cache, with HTTP/2 enabled, allows request smuggling and VCL authorization bypass via a large Content-Length header for a POST request. This affects Varnish Enterprise 6.0.x before 6.0.8r3, and Varnish Cache 5.x and 6.x before 6.5.2, 6.6.x before 6.6.1, and 6.0 LTS before 6.0.8.",
        "git_url": "https://github.com/varnishcache/varnish-cache/commit/9be22198e258d0e7a5c41f4291792214a29405cf",
        "commit_title": "Take content length into account on H/2 request bodies",
        "commit_text": " When receiving H/2 data frames, make sure to take the advertised content length into account, and fail appropriately if the combined sum of the data frames does not match the content length.",
        "func_before": "static enum vfp_status v_matchproto_(vfp_pull_f)\nh2_vfp_body(struct vfp_ctx *vc, struct vfp_entry *vfe, void *ptr, ssize_t *lp)\n{\n\tstruct h2_req *r2;\n\tstruct h2_sess *h2;\n\tunsigned l;\n\tenum vfp_status retval = VFP_OK;\n\n\tCHECK_OBJ_NOTNULL(vc, VFP_CTX_MAGIC);\n\tCHECK_OBJ_NOTNULL(vfe, VFP_ENTRY_MAGIC);\n\tCAST_OBJ_NOTNULL(r2, vfe->priv1, H2_REQ_MAGIC);\n\th2 = r2->h2sess;\n\n\tAN(ptr);\n\tAN(lp);\n\tl = *lp;\n\t*lp = 0;\n\n\tLck_Lock(&h2->sess->mtx);\n\tassert (r2->state == H2_S_OPEN);\n\tr2->cond = &vc->wrk->cond;\n\twhile (h2->mailcall != r2 && h2->error == 0 && r2->error == 0)\n\t\tAZ(Lck_CondWait(r2->cond, &h2->sess->mtx, 0));\n\tr2->cond = NULL;\n\tif (h2->error || r2->error) {\n\t\tretval = VFP_ERROR;\n\t} else {\n\t\tassert(h2->mailcall == r2);\n\t\tif (l > h2->rxf_len)\n\t\t\tl = h2->rxf_len;\n\t\tif (l > 0) {\n\t\t\tmemcpy(ptr, h2->rxf_data, l);\n\t\t\th2->rxf_data += l;\n\t\t\th2->rxf_len -= l;\n\t\t}\n\t\t*lp = l;\n\t\tif (h2->rxf_len > 0) {\n\t\t\t/* We ran out of storage: Have VFP call us\n\t\t\t * again with a fresh buffer */\n\t\t\tLck_Unlock(&h2->sess->mtx);\n\t\t\treturn (VFP_OK);\n\t\t}\n\t\tif (h2->rxf_len == 0) {\n\t\t\tif (h2->rxf_flags & H2FF_DATA_END_STREAM) {\n\t\t\t\tretval = VFP_END;\n\t\t\t\tr2->state = H2_S_CLOS_REM;\n\t\t\t}\n\t\t}\n\t\th2->mailcall = NULL;\n\t\tAZ(pthread_cond_signal(h2->cond));\n\t}\n\tLck_Unlock(&h2->sess->mtx);\n\treturn (retval);\n}",
        "func": "static enum vfp_status v_matchproto_(vfp_pull_f)\nh2_vfp_body(struct vfp_ctx *vc, struct vfp_entry *vfe, void *ptr, ssize_t *lp)\n{\n\tstruct h2_req *r2;\n\tstruct h2_sess *h2;\n\tunsigned l;\n\tenum vfp_status retval;\n\n\tCHECK_OBJ_NOTNULL(vc, VFP_CTX_MAGIC);\n\tCHECK_OBJ_NOTNULL(vfe, VFP_ENTRY_MAGIC);\n\tCAST_OBJ_NOTNULL(r2, vfe->priv1, H2_REQ_MAGIC);\n\th2 = r2->h2sess;\n\n\tAN(ptr);\n\tAN(lp);\n\tl = *lp;\n\t*lp = 0;\n\n\tLck_Lock(&h2->sess->mtx);\n\tr2->cond = &vc->wrk->cond;\n\twhile (h2->mailcall != r2 && h2->error == 0 && r2->error == 0)\n\t\tAZ(Lck_CondWait(r2->cond, &h2->sess->mtx, 0));\n\tr2->cond = NULL;\n\tif (h2->error || r2->error) {\n\t\tretval = VFP_ERROR;\n\t} else {\n\t\tassert(h2->mailcall == r2);\n\t\tif (l > h2->rxf_len)\n\t\t\tl = h2->rxf_len;\n\t\tif (l > 0) {\n\t\t\tmemcpy(ptr, h2->rxf_data, l);\n\t\t\th2->rxf_data += l;\n\t\t\th2->rxf_len -= l;\n\t\t}\n\t\t*lp = l;\n\t\tif (h2->rxf_len > 0) {\n\t\t\t/* We ran out of storage: Have VFP call us\n\t\t\t * again with a fresh buffer */\n\t\t\tLck_Unlock(&h2->sess->mtx);\n\t\t\treturn (VFP_OK);\n\t\t}\n\t\tif (h2->rxf_len == 0 && r2->state >= H2_S_CLOS_REM)\n\t\t\tretval = VFP_END;\n\t\telse\n\t\t\tretval = VFP_OK;\n\t\th2->mailcall = NULL;\n\t\tAZ(pthread_cond_signal(h2->cond));\n\t}\n\tLck_Unlock(&h2->sess->mtx);\n\treturn (retval);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,7 +4,7 @@\n \tstruct h2_req *r2;\n \tstruct h2_sess *h2;\n \tunsigned l;\n-\tenum vfp_status retval = VFP_OK;\n+\tenum vfp_status retval;\n \n \tCHECK_OBJ_NOTNULL(vc, VFP_CTX_MAGIC);\n \tCHECK_OBJ_NOTNULL(vfe, VFP_ENTRY_MAGIC);\n@@ -17,7 +17,6 @@\n \t*lp = 0;\n \n \tLck_Lock(&h2->sess->mtx);\n-\tassert (r2->state == H2_S_OPEN);\n \tr2->cond = &vc->wrk->cond;\n \twhile (h2->mailcall != r2 && h2->error == 0 && r2->error == 0)\n \t\tAZ(Lck_CondWait(r2->cond, &h2->sess->mtx, 0));\n@@ -40,12 +39,10 @@\n \t\t\tLck_Unlock(&h2->sess->mtx);\n \t\t\treturn (VFP_OK);\n \t\t}\n-\t\tif (h2->rxf_len == 0) {\n-\t\t\tif (h2->rxf_flags & H2FF_DATA_END_STREAM) {\n-\t\t\t\tretval = VFP_END;\n-\t\t\t\tr2->state = H2_S_CLOS_REM;\n-\t\t\t}\n-\t\t}\n+\t\tif (h2->rxf_len == 0 && r2->state >= H2_S_CLOS_REM)\n+\t\t\tretval = VFP_END;\n+\t\telse\n+\t\t\tretval = VFP_OK;\n \t\th2->mailcall = NULL;\n \t\tAZ(pthread_cond_signal(h2->cond));\n \t}",
        "diff_line_info": {
            "deleted_lines": [
                "\tenum vfp_status retval = VFP_OK;",
                "\tassert (r2->state == H2_S_OPEN);",
                "\t\tif (h2->rxf_len == 0) {",
                "\t\t\tif (h2->rxf_flags & H2FF_DATA_END_STREAM) {",
                "\t\t\t\tretval = VFP_END;",
                "\t\t\t\tr2->state = H2_S_CLOS_REM;",
                "\t\t\t}",
                "\t\t}"
            ],
            "added_lines": [
                "\tenum vfp_status retval;",
                "\t\tif (h2->rxf_len == 0 && r2->state >= H2_S_CLOS_REM)",
                "\t\t\tretval = VFP_END;",
                "\t\telse",
                "\t\t\tretval = VFP_OK;"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-36740",
        "func_name": "varnishcache/varnish-cache/h2_end_headers",
        "description": "Varnish Cache, with HTTP/2 enabled, allows request smuggling and VCL authorization bypass via a large Content-Length header for a POST request. This affects Varnish Enterprise 6.0.x before 6.0.8r3, and Varnish Cache 5.x and 6.x before 6.5.2, 6.6.x before 6.6.1, and 6.0 LTS before 6.0.8.",
        "git_url": "https://github.com/varnishcache/varnish-cache/commit/9be22198e258d0e7a5c41f4291792214a29405cf",
        "commit_title": "Take content length into account on H/2 request bodies",
        "commit_text": " When receiving H/2 data frames, make sure to take the advertised content length into account, and fail appropriately if the combined sum of the data frames does not match the content length.",
        "func_before": "static h2_error\nh2_end_headers(struct worker *wrk, struct h2_sess *h2,\n    struct req *req, struct h2_req *r2)\n{\n\th2_error h2e;\n\tconst char *b;\n\n\tASSERT_RXTHR(h2);\n\tassert(r2->state == H2_S_OPEN);\n\th2e = h2h_decode_fini(h2);\n\th2->new_req = NULL;\n\tif (r2->req->req_body_status == REQ_BODY_NONE) {\n\t\t/* REQ_BODY_NONE implies one of the frames in the\n\t\t * header block contained END_STREAM */\n\t\tr2->state = H2_S_CLOS_REM;\n\t}\n\tif (h2e != NULL) {\n\t\tLck_Lock(&h2->sess->mtx);\n\t\tVSLb(h2->vsl, SLT_Debug, \"HPACK/FINI %s\", h2e->name);\n\t\tLck_Unlock(&h2->sess->mtx);\n\t\tAZ(r2->req->ws->r);\n\t\th2_del_req(wrk, r2);\n\t\treturn (h2e);\n\t}\n\tVSLb_ts_req(req, \"Req\", req->t_req);\n\n\t// XXX: Smarter to do this already at HPACK time into tail end of\n\t// XXX: WS, then copy back once all headers received.\n\t// XXX: Have I mentioned H/2 Is hodge-podge ?\n\thttp_CollectHdrSep(req->http, H_Cookie, \"; \");\t// rfc7540,l,3114,3120\n\n\tif (req->req_body_status == REQ_BODY_INIT) {\n\t\tif (!http_GetHdr(req->http, H_Content_Length, &b))\n\t\t\treq->req_body_status = REQ_BODY_WITHOUT_LEN;\n\t\telse\n\t\t\treq->req_body_status = REQ_BODY_WITH_LEN;\n\t} else {\n\t\tassert (req->req_body_status == REQ_BODY_NONE);\n\t\tif (http_GetContentLength(req->http) > 0)\n\t\t\treturn (H2CE_PROTOCOL_ERROR); //rfc7540,l,1838,1840\n\t}\n\n\tif (req->http->hd[HTTP_HDR_METHOD].b == NULL) {\n\t\tVSLb(h2->vsl, SLT_Debug, \"Missing :method\");\n\t\treturn (H2SE_PROTOCOL_ERROR); //rfc7540,l,3087,3090\n\t}\n\tif (req->http->hd[HTTP_HDR_URL].b == NULL) {\n\t\tVSLb(h2->vsl, SLT_Debug, \"Missing :path\");\n\t\treturn (H2SE_PROTOCOL_ERROR); //rfc7540,l,3087,3090\n\t}\n\tAN(req->http->hd[HTTP_HDR_PROTO].b);\n\n\treq->req_step = R_STP_TRANSPORT;\n\treq->task.func = h2_do_req;\n\treq->task.priv = req;\n\tr2->scheduled = 1;\n\tif (Pool_Task(wrk->pool, &req->task, TASK_QUEUE_STR) != 0) {\n\t\tr2->scheduled = 0;\n\t\tr2->state = H2_S_CLOSED;\n\t\treturn (H2SE_REFUSED_STREAM); //rfc7540,l,3326,3329\n\t}\n\treturn (0);\n}",
        "func": "static h2_error\nh2_end_headers(struct worker *wrk, struct h2_sess *h2,\n    struct req *req, struct h2_req *r2)\n{\n\th2_error h2e;\n\tssize_t cl;\n\n\tASSERT_RXTHR(h2);\n\tassert(r2->state == H2_S_OPEN);\n\th2e = h2h_decode_fini(h2);\n\th2->new_req = NULL;\n\tif (r2->req->req_body_status == REQ_BODY_NONE) {\n\t\t/* REQ_BODY_NONE implies one of the frames in the\n\t\t * header block contained END_STREAM */\n\t\tr2->state = H2_S_CLOS_REM;\n\t}\n\tif (h2e != NULL) {\n\t\tLck_Lock(&h2->sess->mtx);\n\t\tVSLb(h2->vsl, SLT_Debug, \"HPACK/FINI %s\", h2e->name);\n\t\tLck_Unlock(&h2->sess->mtx);\n\t\tAZ(r2->req->ws->r);\n\t\th2_del_req(wrk, r2);\n\t\treturn (h2e);\n\t}\n\tVSLb_ts_req(req, \"Req\", req->t_req);\n\n\t// XXX: Smarter to do this already at HPACK time into tail end of\n\t// XXX: WS, then copy back once all headers received.\n\t// XXX: Have I mentioned H/2 Is hodge-podge ?\n\thttp_CollectHdrSep(req->http, H_Cookie, \"; \");\t// rfc7540,l,3114,3120\n\n\tcl = http_GetContentLength(req->http);\n\tassert(cl >= -2);\n\tif (cl == -2) {\n\t\tVSLb(h2->vsl, SLT_Debug, \"Non-parseable Content-Length\");\n\t\treturn (H2SE_PROTOCOL_ERROR);\n\t}\n\n\tif (req->req_body_status == REQ_BODY_INIT) {\n\t\tif (cl == -1)\n\t\t\treq->req_body_status = REQ_BODY_WITHOUT_LEN;\n\t\telse\n\t\t\treq->req_body_status = REQ_BODY_WITH_LEN;\n\t\treq->htc->content_length = cl;\n\t} else {\n\t\t/* A HEADER frame contained END_STREAM */\n\t\tassert (req->req_body_status == REQ_BODY_NONE);\n\t\tr2->state = H2_S_CLOS_REM;\n\t\tif (cl > 0)\n\t\t\treturn (H2CE_PROTOCOL_ERROR); //rfc7540,l,1838,1840\n\t}\n\n\tif (req->http->hd[HTTP_HDR_METHOD].b == NULL) {\n\t\tVSLb(h2->vsl, SLT_Debug, \"Missing :method\");\n\t\treturn (H2SE_PROTOCOL_ERROR); //rfc7540,l,3087,3090\n\t}\n\tif (req->http->hd[HTTP_HDR_URL].b == NULL) {\n\t\tVSLb(h2->vsl, SLT_Debug, \"Missing :path\");\n\t\treturn (H2SE_PROTOCOL_ERROR); //rfc7540,l,3087,3090\n\t}\n\tAN(req->http->hd[HTTP_HDR_PROTO].b);\n\n\treq->req_step = R_STP_TRANSPORT;\n\treq->task.func = h2_do_req;\n\treq->task.priv = req;\n\tr2->scheduled = 1;\n\tif (Pool_Task(wrk->pool, &req->task, TASK_QUEUE_STR) != 0) {\n\t\tr2->scheduled = 0;\n\t\tr2->state = H2_S_CLOSED;\n\t\treturn (H2SE_REFUSED_STREAM); //rfc7540,l,3326,3329\n\t}\n\treturn (0);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,7 +3,7 @@\n     struct req *req, struct h2_req *r2)\n {\n \th2_error h2e;\n-\tconst char *b;\n+\tssize_t cl;\n \n \tASSERT_RXTHR(h2);\n \tassert(r2->state == H2_S_OPEN);\n@@ -29,14 +29,24 @@\n \t// XXX: Have I mentioned H/2 Is hodge-podge ?\n \thttp_CollectHdrSep(req->http, H_Cookie, \"; \");\t// rfc7540,l,3114,3120\n \n+\tcl = http_GetContentLength(req->http);\n+\tassert(cl >= -2);\n+\tif (cl == -2) {\n+\t\tVSLb(h2->vsl, SLT_Debug, \"Non-parseable Content-Length\");\n+\t\treturn (H2SE_PROTOCOL_ERROR);\n+\t}\n+\n \tif (req->req_body_status == REQ_BODY_INIT) {\n-\t\tif (!http_GetHdr(req->http, H_Content_Length, &b))\n+\t\tif (cl == -1)\n \t\t\treq->req_body_status = REQ_BODY_WITHOUT_LEN;\n \t\telse\n \t\t\treq->req_body_status = REQ_BODY_WITH_LEN;\n+\t\treq->htc->content_length = cl;\n \t} else {\n+\t\t/* A HEADER frame contained END_STREAM */\n \t\tassert (req->req_body_status == REQ_BODY_NONE);\n-\t\tif (http_GetContentLength(req->http) > 0)\n+\t\tr2->state = H2_S_CLOS_REM;\n+\t\tif (cl > 0)\n \t\t\treturn (H2CE_PROTOCOL_ERROR); //rfc7540,l,1838,1840\n \t}\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\tconst char *b;",
                "\t\tif (!http_GetHdr(req->http, H_Content_Length, &b))",
                "\t\tif (http_GetContentLength(req->http) > 0)"
            ],
            "added_lines": [
                "\tssize_t cl;",
                "\tcl = http_GetContentLength(req->http);",
                "\tassert(cl >= -2);",
                "\tif (cl == -2) {",
                "\t\tVSLb(h2->vsl, SLT_Debug, \"Non-parseable Content-Length\");",
                "\t\treturn (H2SE_PROTOCOL_ERROR);",
                "\t}",
                "",
                "\t\tif (cl == -1)",
                "\t\treq->htc->content_length = cl;",
                "\t\t/* A HEADER frame contained END_STREAM */",
                "\t\tr2->state = H2_S_CLOS_REM;",
                "\t\tif (cl > 0)"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-36740",
        "func_name": "varnishcache/varnish-cache/h2_rx_data",
        "description": "Varnish Cache, with HTTP/2 enabled, allows request smuggling and VCL authorization bypass via a large Content-Length header for a POST request. This affects Varnish Enterprise 6.0.x before 6.0.8r3, and Varnish Cache 5.x and 6.x before 6.5.2, 6.6.x before 6.6.1, and 6.0 LTS before 6.0.8.",
        "git_url": "https://github.com/varnishcache/varnish-cache/commit/9be22198e258d0e7a5c41f4291792214a29405cf",
        "commit_title": "Take content length into account on H/2 request bodies",
        "commit_text": " When receiving H/2 data frames, make sure to take the advertised content length into account, and fail appropriately if the combined sum of the data frames does not match the content length.",
        "func_before": "static h2_error v_matchproto_(h2_rxframe_f)\nh2_rx_data(struct worker *wrk, struct h2_sess *h2, struct h2_req *r2)\n{\n\tint w1 = 0, w2 = 0;\n\tchar buf[4];\n\tunsigned wi;\n\n\tCHECK_OBJ_NOTNULL(wrk, WORKER_MAGIC);\n\tASSERT_RXTHR(h2);\n\tCHECK_OBJ_ORNULL(r2, H2_REQ_MAGIC);\n\n\tif (r2 == NULL || !r2->scheduled)\n\t\treturn (0);\n\tif (r2->state >= H2_S_CLOS_REM) {\n\t\tr2->error = H2SE_STREAM_CLOSED;\n\t\treturn (H2SE_STREAM_CLOSED); // rfc7540,l,1766,1769\n\t}\n\tLck_Lock(&h2->sess->mtx);\n\twhile (h2->mailcall != NULL && h2->error == 0 && r2->error == 0)\n\t\tAZ(Lck_CondWait(h2->cond, &h2->sess->mtx, 0));\n\tif (h2->error || r2->error) {\n\t\tLck_Unlock(&h2->sess->mtx);\n\t\treturn (h2->error ? h2->error : r2->error);\n\t}\n\tAZ(h2->mailcall);\n\th2->mailcall = r2;\n\th2->req0->r_window -= h2->rxf_len;\n\tr2->r_window -= h2->rxf_len;\n\t// req_bodybytes accounted in CNT code.\n\tif (r2->cond)\n\t\tAZ(pthread_cond_signal(r2->cond));\n\twhile (h2->mailcall != NULL && h2->error == 0 && r2->error == 0)\n\t\tAZ(Lck_CondWait(h2->cond, &h2->sess->mtx, 0));\n\twi = cache_param->h2_rx_window_increment;\n\tif (h2->req0->r_window < cache_param->h2_rx_window_low_water) {\n\t\th2->req0->r_window += wi;\n\t\tw1 = 1;\n\t}\n\tif (r2->r_window < cache_param->h2_rx_window_low_water) {\n\t\tr2->r_window += wi;\n\t\tw2 = 1;\n\t}\n\tLck_Unlock(&h2->sess->mtx);\n\n\tif (w1 || w2) {\n\t\tvbe32enc(buf, wi);\n\t\tH2_Send_Get(wrk, h2, h2->req0);\n\t\tif (w1)\n\t\t\tH2_Send_Frame(wrk, h2, H2_F_WINDOW_UPDATE, 0,\n\t\t\t    4, 0, buf);\n\t\tif (w2)\n\t\t\tH2_Send_Frame(wrk, h2, H2_F_WINDOW_UPDATE, 0,\n\t\t\t    4, r2->stream, buf);\n\t\tH2_Send_Rel(h2, h2->req0);\n\t}\n\treturn (0);\n}",
        "func": "static h2_error v_matchproto_(h2_rxframe_f)\nh2_rx_data(struct worker *wrk, struct h2_sess *h2, struct h2_req *r2)\n{\n\tint w1 = 0, w2 = 0;\n\tchar buf[4];\n\tunsigned wi;\n\tssize_t cl;\n\n\tCHECK_OBJ_NOTNULL(wrk, WORKER_MAGIC);\n\tASSERT_RXTHR(h2);\n\tCHECK_OBJ_ORNULL(r2, H2_REQ_MAGIC);\n\n\tif (r2 == NULL || !r2->scheduled)\n\t\treturn (0);\n\tif (r2->state >= H2_S_CLOS_REM) {\n\t\tr2->error = H2SE_STREAM_CLOSED;\n\t\treturn (H2SE_STREAM_CLOSED); // rfc7540,l,1766,1769\n\t}\n\tLck_Lock(&h2->sess->mtx);\n\twhile (h2->mailcall != NULL && h2->error == 0 && r2->error == 0)\n\t\tAZ(Lck_CondWait(h2->cond, &h2->sess->mtx, 0));\n\tif (h2->error || r2->error) {\n\t\tLck_Unlock(&h2->sess->mtx);\n\t\treturn (h2->error ? h2->error : r2->error);\n\t}\n\n\tr2->reqbody_bytes += h2->rxf_len;\n\tif (h2->rxf_flags & H2FF_DATA_END_STREAM)\n\t\tr2->state = H2_S_CLOS_REM;\n\tcl = r2->req->htc->content_length;\n\tif (cl >= 0 && (r2->reqbody_bytes > cl ||\n\t      (r2->state >= H2_S_CLOS_REM && r2->reqbody_bytes != cl))) {\n\t\tVSLb(h2->vsl, SLT_Debug,\n\t\t    \"H2: stream %u: Received data and Content-Length\"\n\t\t    \" mismatch\", h2->rxf_stream);\n\t\tr2->error = H2SE_PROTOCOL_ERROR; // rfc7540,l,3150,3163\n\t\tif (r2->cond)\n\t\t\tAZ(pthread_cond_signal(r2->cond));\n\t\tLck_Unlock(&h2->sess->mtx);\n\t\treturn (H2SE_PROTOCOL_ERROR);\n\t}\n\n\tAZ(h2->mailcall);\n\th2->mailcall = r2;\n\th2->req0->r_window -= h2->rxf_len;\n\tr2->r_window -= h2->rxf_len;\n\t// req_bodybytes accounted in CNT code.\n\tif (r2->cond)\n\t\tAZ(pthread_cond_signal(r2->cond));\n\twhile (h2->mailcall != NULL && h2->error == 0 && r2->error == 0)\n\t\tAZ(Lck_CondWait(h2->cond, &h2->sess->mtx, 0));\n\twi = cache_param->h2_rx_window_increment;\n\tif (h2->req0->r_window < cache_param->h2_rx_window_low_water) {\n\t\th2->req0->r_window += wi;\n\t\tw1 = 1;\n\t}\n\tif (r2->r_window < cache_param->h2_rx_window_low_water) {\n\t\tr2->r_window += wi;\n\t\tw2 = 1;\n\t}\n\n\n\tLck_Unlock(&h2->sess->mtx);\n\n\tif (w1 || w2) {\n\t\tvbe32enc(buf, wi);\n\t\tH2_Send_Get(wrk, h2, h2->req0);\n\t\tif (w1)\n\t\t\tH2_Send_Frame(wrk, h2, H2_F_WINDOW_UPDATE, 0,\n\t\t\t    4, 0, buf);\n\t\tif (w2)\n\t\t\tH2_Send_Frame(wrk, h2, H2_F_WINDOW_UPDATE, 0,\n\t\t\t    4, r2->stream, buf);\n\t\tH2_Send_Rel(h2, h2->req0);\n\t}\n\treturn (0);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,6 +4,7 @@\n \tint w1 = 0, w2 = 0;\n \tchar buf[4];\n \tunsigned wi;\n+\tssize_t cl;\n \n \tCHECK_OBJ_NOTNULL(wrk, WORKER_MAGIC);\n \tASSERT_RXTHR(h2);\n@@ -22,6 +23,23 @@\n \t\tLck_Unlock(&h2->sess->mtx);\n \t\treturn (h2->error ? h2->error : r2->error);\n \t}\n+\n+\tr2->reqbody_bytes += h2->rxf_len;\n+\tif (h2->rxf_flags & H2FF_DATA_END_STREAM)\n+\t\tr2->state = H2_S_CLOS_REM;\n+\tcl = r2->req->htc->content_length;\n+\tif (cl >= 0 && (r2->reqbody_bytes > cl ||\n+\t      (r2->state >= H2_S_CLOS_REM && r2->reqbody_bytes != cl))) {\n+\t\tVSLb(h2->vsl, SLT_Debug,\n+\t\t    \"H2: stream %u: Received data and Content-Length\"\n+\t\t    \" mismatch\", h2->rxf_stream);\n+\t\tr2->error = H2SE_PROTOCOL_ERROR; // rfc7540,l,3150,3163\n+\t\tif (r2->cond)\n+\t\t\tAZ(pthread_cond_signal(r2->cond));\n+\t\tLck_Unlock(&h2->sess->mtx);\n+\t\treturn (H2SE_PROTOCOL_ERROR);\n+\t}\n+\n \tAZ(h2->mailcall);\n \th2->mailcall = r2;\n \th2->req0->r_window -= h2->rxf_len;\n@@ -40,6 +58,8 @@\n \t\tr2->r_window += wi;\n \t\tw2 = 1;\n \t}\n+\n+\n \tLck_Unlock(&h2->sess->mtx);\n \n \tif (w1 || w2) {",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tssize_t cl;",
                "",
                "\tr2->reqbody_bytes += h2->rxf_len;",
                "\tif (h2->rxf_flags & H2FF_DATA_END_STREAM)",
                "\t\tr2->state = H2_S_CLOS_REM;",
                "\tcl = r2->req->htc->content_length;",
                "\tif (cl >= 0 && (r2->reqbody_bytes > cl ||",
                "\t      (r2->state >= H2_S_CLOS_REM && r2->reqbody_bytes != cl))) {",
                "\t\tVSLb(h2->vsl, SLT_Debug,",
                "\t\t    \"H2: stream %u: Received data and Content-Length\"",
                "\t\t    \" mismatch\", h2->rxf_stream);",
                "\t\tr2->error = H2SE_PROTOCOL_ERROR; // rfc7540,l,3150,3163",
                "\t\tif (r2->cond)",
                "\t\t\tAZ(pthread_cond_signal(r2->cond));",
                "\t\tLck_Unlock(&h2->sess->mtx);",
                "\t\treturn (H2SE_PROTOCOL_ERROR);",
                "\t}",
                "",
                "",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2019-20372",
        "func_name": "nginx/ngx_http_send_error_page",
        "description": "NGINX before 1.17.7, with certain error_page configurations, allows HTTP request smuggling, as demonstrated by the ability of an attacker to read unauthorized web pages in environments where NGINX is being fronted by a load balancer.",
        "git_url": "https://github.com/nginx/nginx/commit/c1be55f97211d38b69ac0c2027e6812ab8b1b94e",
        "commit_title": "Discard request body when redirecting to a URL via error_page.",
        "commit_text": " Reported by Bert JW Regeer and Francisco Oca Gonzalez.",
        "func_before": "static ngx_int_t\nngx_http_send_error_page(ngx_http_request_t *r, ngx_http_err_page_t *err_page)\n{\n    ngx_int_t                  overwrite;\n    ngx_str_t                  uri, args;\n    ngx_table_elt_t           *location;\n    ngx_http_core_loc_conf_t  *clcf;\n\n    overwrite = err_page->overwrite;\n\n    if (overwrite && overwrite != NGX_HTTP_OK) {\n        r->expect_tested = 1;\n    }\n\n    if (overwrite >= 0) {\n        r->err_status = overwrite;\n    }\n\n    if (ngx_http_complex_value(r, &err_page->value, &uri) != NGX_OK) {\n        return NGX_ERROR;\n    }\n\n    if (uri.len && uri.data[0] == '/') {\n\n        if (err_page->value.lengths) {\n            ngx_http_split_args(r, &uri, &args);\n\n        } else {\n            args = err_page->args;\n        }\n\n        if (r->method != NGX_HTTP_HEAD) {\n            r->method = NGX_HTTP_GET;\n            r->method_name = ngx_http_core_get_method;\n        }\n\n        return ngx_http_internal_redirect(r, &uri, &args);\n    }\n\n    if (uri.len && uri.data[0] == '@') {\n        return ngx_http_named_location(r, &uri);\n    }\n\n    location = ngx_list_push(&r->headers_out.headers);\n\n    if (location == NULL) {\n        return NGX_ERROR;\n    }\n\n    if (overwrite != NGX_HTTP_MOVED_PERMANENTLY\n        && overwrite != NGX_HTTP_MOVED_TEMPORARILY\n        && overwrite != NGX_HTTP_SEE_OTHER\n        && overwrite != NGX_HTTP_TEMPORARY_REDIRECT\n        && overwrite != NGX_HTTP_PERMANENT_REDIRECT)\n    {\n        r->err_status = NGX_HTTP_MOVED_TEMPORARILY;\n    }\n\n    location->hash = 1;\n    ngx_str_set(&location->key, \"Location\");\n    location->value = uri;\n\n    ngx_http_clear_location(r);\n\n    r->headers_out.location = location;\n\n    clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);\n\n    if (clcf->msie_refresh && r->headers_in.msie) {\n        return ngx_http_send_refresh(r);\n    }\n\n    return ngx_http_send_special_response(r, clcf, r->err_status\n                                                   - NGX_HTTP_MOVED_PERMANENTLY\n                                                   + NGX_HTTP_OFF_3XX);\n}",
        "func": "static ngx_int_t\nngx_http_send_error_page(ngx_http_request_t *r, ngx_http_err_page_t *err_page)\n{\n    ngx_int_t                  overwrite;\n    ngx_str_t                  uri, args;\n    ngx_table_elt_t           *location;\n    ngx_http_core_loc_conf_t  *clcf;\n\n    overwrite = err_page->overwrite;\n\n    if (overwrite && overwrite != NGX_HTTP_OK) {\n        r->expect_tested = 1;\n    }\n\n    if (overwrite >= 0) {\n        r->err_status = overwrite;\n    }\n\n    if (ngx_http_complex_value(r, &err_page->value, &uri) != NGX_OK) {\n        return NGX_ERROR;\n    }\n\n    if (uri.len && uri.data[0] == '/') {\n\n        if (err_page->value.lengths) {\n            ngx_http_split_args(r, &uri, &args);\n\n        } else {\n            args = err_page->args;\n        }\n\n        if (r->method != NGX_HTTP_HEAD) {\n            r->method = NGX_HTTP_GET;\n            r->method_name = ngx_http_core_get_method;\n        }\n\n        return ngx_http_internal_redirect(r, &uri, &args);\n    }\n\n    if (uri.len && uri.data[0] == '@') {\n        return ngx_http_named_location(r, &uri);\n    }\n\n    r->expect_tested = 1;\n\n    if (ngx_http_discard_request_body(r) != NGX_OK) {\n        r->keepalive = 0;\n    }\n\n    location = ngx_list_push(&r->headers_out.headers);\n\n    if (location == NULL) {\n        return NGX_ERROR;\n    }\n\n    if (overwrite != NGX_HTTP_MOVED_PERMANENTLY\n        && overwrite != NGX_HTTP_MOVED_TEMPORARILY\n        && overwrite != NGX_HTTP_SEE_OTHER\n        && overwrite != NGX_HTTP_TEMPORARY_REDIRECT\n        && overwrite != NGX_HTTP_PERMANENT_REDIRECT)\n    {\n        r->err_status = NGX_HTTP_MOVED_TEMPORARILY;\n    }\n\n    location->hash = 1;\n    ngx_str_set(&location->key, \"Location\");\n    location->value = uri;\n\n    ngx_http_clear_location(r);\n\n    r->headers_out.location = location;\n\n    clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);\n\n    if (clcf->msie_refresh && r->headers_in.msie) {\n        return ngx_http_send_refresh(r);\n    }\n\n    return ngx_http_send_special_response(r, clcf, r->err_status\n                                                   - NGX_HTTP_MOVED_PERMANENTLY\n                                                   + NGX_HTTP_OFF_3XX);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -41,6 +41,12 @@\n         return ngx_http_named_location(r, &uri);\n     }\n \n+    r->expect_tested = 1;\n+\n+    if (ngx_http_discard_request_body(r) != NGX_OK) {\n+        r->keepalive = 0;\n+    }\n+\n     location = ngx_list_push(&r->headers_out.headers);\n \n     if (location == NULL) {",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    r->expect_tested = 1;",
                "",
                "    if (ngx_http_discard_request_body(r) != NGX_OK) {",
                "        r->keepalive = 0;",
                "    }",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2023-40225",
        "func_name": "haproxy/h1_parse_cont_len_header",
        "description": "HAProxy through 2.0.32, 2.1.x and 2.2.x through 2.2.30, 2.3.x and 2.4.x through 2.4.23, 2.5.x and 2.6.x before 2.6.15, 2.7.x before 2.7.10, and 2.8.x before 2.8.2 forwards empty Content-Length headers, violating RFC 9110 section 8.6. In uncommon cases, an HTTP/1 server behind HAProxy may interpret the payload as an extra request.",
        "git_url": "https://github.com/haproxy/haproxy/commit/6492f1f29d738457ea9f382aca54537f35f9d856",
        "commit_title": "BUG/MAJOR: http: reject any empty content-length header value",
        "commit_text": " The content-length header parser has its dedicated function, in order to take extreme care about invalid, unparsable, or conflicting values. But there's a corner case in it, by which it stops comparing values when reaching the end of the header. This has for a side effect that an empty value or a value that ends with a comma does not deserve further analysis, and it acts as if the header was absent.  While this is not necessarily a problem for the value ending with a comma as it will be cause a header folding and will disappear, it is a problem for the first isolated empty header because this one will not be recontructed when next ones are seen, and will be passed as-is to the backend server. A vulnerable HTTP/1 server hosted behind haproxy that would just use this first value as \"0\" and ignore the valid one would then not be protected by haproxy and could be attacked this way, taking the payload for an extra request.  In field the risk depends on the server. Most commonly used servers already have safe content-length parsers, but users relying on haproxy to protect a known-vulnerable server might be at risk (and the risk of a bug even in a reputable server should never be dismissed).  A configuration-based work-around consists in adding the following rule in the frontend, to explicitly reject requests featuring an empty content-length header that would have not be folded into an existing one:      http-request deny if { hdr_len(content-length) 0 }  The real fix consists in adjusting the parser so that it always expects a value at the beginning of the header or after a comma. It will now reject requests and responses having empty values anywhere in the C-L header.  This needs to be backported to all supported versions. Note that the modification was made to functions h1_parse_cont_len_header() and http_parse_cont_len_header(). Prior to 2.8 the latter was in h2_parse_cont_len_header(). One day the two should be refused but the former is also used by Lua.  The HTTP messaging reg-tests were completed to test these cases.  Thanks to Ben Kallus of Dartmouth College and Narf Industries for reporting this! (this is in GH #2237).",
        "func_before": "int h1_parse_cont_len_header(struct h1m *h1m, struct ist *value)\n{\n\tchar *e, *n;\n\tlong long cl;\n\tint not_first = !!(h1m->flags & H1_MF_CLEN);\n\tstruct ist word;\n\n\tword.ptr = value->ptr - 1; // -1 for next loop's pre-increment\n\te = value->ptr + value->len;\n\n\twhile (++word.ptr < e) {\n\t\t/* skip leading delimiter and blanks */\n\t\tif (unlikely(HTTP_IS_LWS(*word.ptr)))\n\t\t\tcontinue;\n\n\t\t/* digits only now */\n\t\tfor (cl = 0, n = word.ptr; n < e; n++) {\n\t\t\tunsigned int c = *n - '0';\n\t\t\tif (unlikely(c > 9)) {\n\t\t\t\t/* non-digit */\n\t\t\t\tif (unlikely(n == word.ptr)) // spaces only\n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (unlikely(cl > ULLONG_MAX / 10ULL))\n\t\t\t\tgoto fail; /* multiply overflow */\n\t\t\tcl = cl * 10ULL;\n\t\t\tif (unlikely(cl + c < cl))\n\t\t\t\tgoto fail; /* addition overflow */\n\t\t\tcl = cl + c;\n\t\t}\n\n\t\t/* keep a copy of the exact cleaned value */\n\t\tword.len = n - word.ptr;\n\n\t\t/* skip trailing LWS till next comma or EOL */\n\t\tfor (; n < e; n++) {\n\t\t\tif (!HTTP_IS_LWS(*n)) {\n\t\t\t\tif (unlikely(*n != ','))\n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/* if duplicate, must be equal */\n\t\tif (h1m->flags & H1_MF_CLEN && cl != h1m->body_len)\n\t\t\tgoto fail;\n\n\t\t/* OK, store this result as the one to be indexed */\n\t\th1m->flags |= H1_MF_CLEN;\n\t\th1m->curr_len = h1m->body_len = cl;\n\t\t*value = word;\n\t\tword.ptr = n;\n\t}\n\t/* here we've reached the end with a single value or a series of\n\t * identical values, all matching previous series if any. The last\n\t * parsed value was sent back into <value>. We just have to decide\n\t * if this occurrence has to be indexed (it's the first one) or\n\t * silently skipped (it's not the first one)\n\t */\n\treturn !not_first;\n fail:\n\treturn -1;\n}",
        "func": "int h1_parse_cont_len_header(struct h1m *h1m, struct ist *value)\n{\n\tchar *e, *n;\n\tlong long cl;\n\tint not_first = !!(h1m->flags & H1_MF_CLEN);\n\tstruct ist word;\n\n\tword.ptr = value->ptr;\n\te = value->ptr + value->len;\n\n\twhile (1) {\n\t\tif (word.ptr >= e) {\n\t\t\t/* empty header or empty value */\n\t\t\tgoto fail;\n\t\t}\n\n\t\t/* skip leading delimiter and blanks */\n\t\tif (unlikely(HTTP_IS_LWS(*word.ptr))) {\n\t\t\tword.ptr++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* digits only now */\n\t\tfor (cl = 0, n = word.ptr; n < e; n++) {\n\t\t\tunsigned int c = *n - '0';\n\t\t\tif (unlikely(c > 9)) {\n\t\t\t\t/* non-digit */\n\t\t\t\tif (unlikely(n == word.ptr)) // spaces only\n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (unlikely(cl > ULLONG_MAX / 10ULL))\n\t\t\t\tgoto fail; /* multiply overflow */\n\t\t\tcl = cl * 10ULL;\n\t\t\tif (unlikely(cl + c < cl))\n\t\t\t\tgoto fail; /* addition overflow */\n\t\t\tcl = cl + c;\n\t\t}\n\n\t\t/* keep a copy of the exact cleaned value */\n\t\tword.len = n - word.ptr;\n\n\t\t/* skip trailing LWS till next comma or EOL */\n\t\tfor (; n < e; n++) {\n\t\t\tif (!HTTP_IS_LWS(*n)) {\n\t\t\t\tif (unlikely(*n != ','))\n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/* if duplicate, must be equal */\n\t\tif (h1m->flags & H1_MF_CLEN && cl != h1m->body_len)\n\t\t\tgoto fail;\n\n\t\t/* OK, store this result as the one to be indexed */\n\t\th1m->flags |= H1_MF_CLEN;\n\t\th1m->curr_len = h1m->body_len = cl;\n\t\t*value = word;\n\n\t\t/* Now either n==e and we're done, or n points to the comma,\n\t\t * and we skip it and continue.\n\t\t */\n\t\tif (n++ == e)\n\t\t\tbreak;\n\n\t\tword.ptr = n;\n\t}\n\t/* here we've reached the end with a single value or a series of\n\t * identical values, all matching previous series if any. The last\n\t * parsed value was sent back into <value>. We just have to decide\n\t * if this occurrence has to be indexed (it's the first one) or\n\t * silently skipped (it's not the first one)\n\t */\n\treturn !not_first;\n fail:\n\treturn -1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,13 +5,20 @@\n \tint not_first = !!(h1m->flags & H1_MF_CLEN);\n \tstruct ist word;\n \n-\tword.ptr = value->ptr - 1; // -1 for next loop's pre-increment\n+\tword.ptr = value->ptr;\n \te = value->ptr + value->len;\n \n-\twhile (++word.ptr < e) {\n+\twhile (1) {\n+\t\tif (word.ptr >= e) {\n+\t\t\t/* empty header or empty value */\n+\t\t\tgoto fail;\n+\t\t}\n+\n \t\t/* skip leading delimiter and blanks */\n-\t\tif (unlikely(HTTP_IS_LWS(*word.ptr)))\n+\t\tif (unlikely(HTTP_IS_LWS(*word.ptr))) {\n+\t\t\tword.ptr++;\n \t\t\tcontinue;\n+\t\t}\n \n \t\t/* digits only now */\n \t\tfor (cl = 0, n = word.ptr; n < e; n++) {\n@@ -50,6 +57,13 @@\n \t\th1m->flags |= H1_MF_CLEN;\n \t\th1m->curr_len = h1m->body_len = cl;\n \t\t*value = word;\n+\n+\t\t/* Now either n==e and we're done, or n points to the comma,\n+\t\t * and we skip it and continue.\n+\t\t */\n+\t\tif (n++ == e)\n+\t\t\tbreak;\n+\n \t\tword.ptr = n;\n \t}\n \t/* here we've reached the end with a single value or a series of",
        "diff_line_info": {
            "deleted_lines": [
                "\tword.ptr = value->ptr - 1; // -1 for next loop's pre-increment",
                "\twhile (++word.ptr < e) {",
                "\t\tif (unlikely(HTTP_IS_LWS(*word.ptr)))"
            ],
            "added_lines": [
                "\tword.ptr = value->ptr;",
                "\twhile (1) {",
                "\t\tif (word.ptr >= e) {",
                "\t\t\t/* empty header or empty value */",
                "\t\t\tgoto fail;",
                "\t\t}",
                "",
                "\t\tif (unlikely(HTTP_IS_LWS(*word.ptr))) {",
                "\t\t\tword.ptr++;",
                "\t\t}",
                "",
                "\t\t/* Now either n==e and we're done, or n points to the comma,",
                "\t\t * and we skip it and continue.",
                "\t\t */",
                "\t\tif (n++ == e)",
                "\t\t\tbreak;",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2023-40225",
        "func_name": "haproxy/http_parse_cont_len_header",
        "description": "HAProxy through 2.0.32, 2.1.x and 2.2.x through 2.2.30, 2.3.x and 2.4.x through 2.4.23, 2.5.x and 2.6.x before 2.6.15, 2.7.x before 2.7.10, and 2.8.x before 2.8.2 forwards empty Content-Length headers, violating RFC 9110 section 8.6. In uncommon cases, an HTTP/1 server behind HAProxy may interpret the payload as an extra request.",
        "git_url": "https://github.com/haproxy/haproxy/commit/6492f1f29d738457ea9f382aca54537f35f9d856",
        "commit_title": "BUG/MAJOR: http: reject any empty content-length header value",
        "commit_text": " The content-length header parser has its dedicated function, in order to take extreme care about invalid, unparsable, or conflicting values. But there's a corner case in it, by which it stops comparing values when reaching the end of the header. This has for a side effect that an empty value or a value that ends with a comma does not deserve further analysis, and it acts as if the header was absent.  While this is not necessarily a problem for the value ending with a comma as it will be cause a header folding and will disappear, it is a problem for the first isolated empty header because this one will not be recontructed when next ones are seen, and will be passed as-is to the backend server. A vulnerable HTTP/1 server hosted behind haproxy that would just use this first value as \"0\" and ignore the valid one would then not be protected by haproxy and could be attacked this way, taking the payload for an extra request.  In field the risk depends on the server. Most commonly used servers already have safe content-length parsers, but users relying on haproxy to protect a known-vulnerable server might be at risk (and the risk of a bug even in a reputable server should never be dismissed).  A configuration-based work-around consists in adding the following rule in the frontend, to explicitly reject requests featuring an empty content-length header that would have not be folded into an existing one:      http-request deny if { hdr_len(content-length) 0 }  The real fix consists in adjusting the parser so that it always expects a value at the beginning of the header or after a comma. It will now reject requests and responses having empty values anywhere in the C-L header.  This needs to be backported to all supported versions. Note that the modification was made to functions h1_parse_cont_len_header() and http_parse_cont_len_header(). Prior to 2.8 the latter was in h2_parse_cont_len_header(). One day the two should be refused but the former is also used by Lua.  The HTTP messaging reg-tests were completed to test these cases.  Thanks to Ben Kallus of Dartmouth College and Narf Industries for reporting this! (this is in GH #2237).",
        "func_before": "int http_parse_cont_len_header(struct ist *value, unsigned long long *body_len,\n                               int not_first)\n{\n\tchar *e, *n;\n\tunsigned long long cl;\n\tstruct ist word;\n\tint check_prev = not_first;\n\n\tword.ptr = value->ptr - 1; // -1 for next loop's pre-increment\n\te = value->ptr + value->len;\n\n\twhile (++word.ptr < e) {\n\t\t/* skip leading delimiter and blanks */\n\t\tif (unlikely(HTTP_IS_LWS(*word.ptr)))\n\t\t\tcontinue;\n\n\t\t/* digits only now */\n\t\tfor (cl = 0, n = word.ptr; n < e; n++) {\n\t\t\tunsigned int c = *n - '0';\n\t\t\tif (unlikely(c > 9)) {\n\t\t\t\t/* non-digit */\n\t\t\t\tif (unlikely(n == word.ptr)) // spaces only\n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (unlikely(cl > ULLONG_MAX / 10ULL))\n\t\t\t\tgoto fail; /* multiply overflow */\n\t\t\tcl = cl * 10ULL;\n\t\t\tif (unlikely(cl + c < cl))\n\t\t\t\tgoto fail; /* addition overflow */\n\t\t\tcl = cl + c;\n\t\t}\n\n\t\t/* keep a copy of the exact cleaned value */\n\t\tword.len = n - word.ptr;\n\n\t\t/* skip trailing LWS till next comma or EOL */\n\t\tfor (; n < e; n++) {\n\t\t\tif (!HTTP_IS_LWS(*n)) {\n\t\t\t\tif (unlikely(*n != ','))\n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/* if duplicate, must be equal */\n\t\tif (check_prev && cl != *body_len)\n\t\t\tgoto fail;\n\n\t\t/* OK, store this result as the one to be indexed */\n\t\t*body_len = cl;\n\t\t*value = word;\n\t\tword.ptr = n;\n\t\tcheck_prev = 1;\n\t}\n\n\t/* here we've reached the end with a single value or a series of\n\t * identical values, all matching previous series if any. The last\n\t * parsed value was sent back into <value>. We just have to decide\n\t * if this occurrence has to be indexed (it's the first one) or\n\t * silently skipped (it's not the first one)\n\t */\n\treturn !not_first;\n fail:\n\treturn -1;\n}",
        "func": "int http_parse_cont_len_header(struct ist *value, unsigned long long *body_len,\n                               int not_first)\n{\n\tchar *e, *n;\n\tunsigned long long cl;\n\tstruct ist word;\n\tint check_prev = not_first;\n\n\tword.ptr = value->ptr;\n\te = value->ptr + value->len;\n\n\twhile (1) {\n\t\tif (word.ptr >= e) {\n\t\t\t/* empty header or empty value */\n\t\t\tgoto fail;\n\t\t}\n\n\t\t/* skip leading delimiter and blanks */\n\t\tif (unlikely(HTTP_IS_LWS(*word.ptr))) {\n\t\t\tword.ptr++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* digits only now */\n\t\tfor (cl = 0, n = word.ptr; n < e; n++) {\n\t\t\tunsigned int c = *n - '0';\n\t\t\tif (unlikely(c > 9)) {\n\t\t\t\t/* non-digit */\n\t\t\t\tif (unlikely(n == word.ptr)) // spaces only\n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (unlikely(cl > ULLONG_MAX / 10ULL))\n\t\t\t\tgoto fail; /* multiply overflow */\n\t\t\tcl = cl * 10ULL;\n\t\t\tif (unlikely(cl + c < cl))\n\t\t\t\tgoto fail; /* addition overflow */\n\t\t\tcl = cl + c;\n\t\t}\n\n\t\t/* keep a copy of the exact cleaned value */\n\t\tword.len = n - word.ptr;\n\n\t\t/* skip trailing LWS till next comma or EOL */\n\t\tfor (; n < e; n++) {\n\t\t\tif (!HTTP_IS_LWS(*n)) {\n\t\t\t\tif (unlikely(*n != ','))\n\t\t\t\t\tgoto fail;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/* if duplicate, must be equal */\n\t\tif (check_prev && cl != *body_len)\n\t\t\tgoto fail;\n\n\t\t/* OK, store this result as the one to be indexed */\n\t\t*body_len = cl;\n\t\t*value = word;\n\n\t\t/* Now either n==e and we're done, or n points to the comma,\n\t\t * and we skip it and continue.\n\t\t */\n\t\tif (n++ == e)\n\t\t\tbreak;\n\n\t\tword.ptr = n;\n\t\tcheck_prev = 1;\n\t}\n\n\t/* here we've reached the end with a single value or a series of\n\t * identical values, all matching previous series if any. The last\n\t * parsed value was sent back into <value>. We just have to decide\n\t * if this occurrence has to be indexed (it's the first one) or\n\t * silently skipped (it's not the first one)\n\t */\n\treturn !not_first;\n fail:\n\treturn -1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,13 +6,20 @@\n \tstruct ist word;\n \tint check_prev = not_first;\n \n-\tword.ptr = value->ptr - 1; // -1 for next loop's pre-increment\n+\tword.ptr = value->ptr;\n \te = value->ptr + value->len;\n \n-\twhile (++word.ptr < e) {\n+\twhile (1) {\n+\t\tif (word.ptr >= e) {\n+\t\t\t/* empty header or empty value */\n+\t\t\tgoto fail;\n+\t\t}\n+\n \t\t/* skip leading delimiter and blanks */\n-\t\tif (unlikely(HTTP_IS_LWS(*word.ptr)))\n+\t\tif (unlikely(HTTP_IS_LWS(*word.ptr))) {\n+\t\t\tword.ptr++;\n \t\t\tcontinue;\n+\t\t}\n \n \t\t/* digits only now */\n \t\tfor (cl = 0, n = word.ptr; n < e; n++) {\n@@ -50,6 +57,13 @@\n \t\t/* OK, store this result as the one to be indexed */\n \t\t*body_len = cl;\n \t\t*value = word;\n+\n+\t\t/* Now either n==e and we're done, or n points to the comma,\n+\t\t * and we skip it and continue.\n+\t\t */\n+\t\tif (n++ == e)\n+\t\t\tbreak;\n+\n \t\tword.ptr = n;\n \t\tcheck_prev = 1;\n \t}",
        "diff_line_info": {
            "deleted_lines": [
                "\tword.ptr = value->ptr - 1; // -1 for next loop's pre-increment",
                "\twhile (++word.ptr < e) {",
                "\t\tif (unlikely(HTTP_IS_LWS(*word.ptr)))"
            ],
            "added_lines": [
                "\tword.ptr = value->ptr;",
                "\twhile (1) {",
                "\t\tif (word.ptr >= e) {",
                "\t\t\t/* empty header or empty value */",
                "\t\t\tgoto fail;",
                "\t\t}",
                "",
                "\t\tif (unlikely(HTTP_IS_LWS(*word.ptr))) {",
                "\t\t\tword.ptr++;",
                "\t\t}",
                "",
                "\t\t/* Now either n==e and we're done, or n points to the comma,",
                "\t\t * and we skip it and continue.",
                "\t\t */",
                "\t\tif (n++ == e)",
                "\t\t\tbreak;",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2020-11724",
        "func_name": "openresty/lua-nginx-module/ngx_http_lua_copy_request_headers",
        "description": "An issue was discovered in OpenResty before 1.15.8.4. ngx_http_lua_subrequest.c allows HTTP request smuggling, as demonstrated by the ngx.location.capture API.",
        "git_url": "https://github.com/openresty/lua-nginx-module/commit/9ab38e8ee35fc08a57636b1b6190dca70b0076fa",
        "commit_title": "bugfix: prevented request smuggling in the ngx.location.capture API.",
        "commit_text": "",
        "func_before": "static ngx_int_t\nngx_http_lua_copy_request_headers(ngx_http_request_t *sr, ngx_http_request_t *r)\n{\n    ngx_table_elt_t                 *header;\n    ngx_list_part_t                 *part;\n    ngx_uint_t                       i;\n\n    if (ngx_list_init(&sr->headers_in.headers, sr->pool, 20,\n                      sizeof(ngx_table_elt_t)) != NGX_OK)\n    {\n        return NGX_ERROR;\n    }\n\n    dd(\"before: parent req headers count: %d\",\n       (int) r->headers_in.headers.part.nelts);\n\n    part = &r->headers_in.headers.part;\n    header = part->elts;\n\n    for (i = 0; /* void */; i++) {\n\n        if (i >= part->nelts) {\n            if (part->next == NULL) {\n                break;\n            }\n\n            part = part->next;\n            header = part->elts;\n            i = 0;\n        }\n\n        dd(\"setting request header %.*s: %.*s\", (int) header[i].key.len,\n           header[i].key.data, (int) header[i].value.len,\n           header[i].value.data);\n\n        if (ngx_http_lua_set_input_header(sr, header[i].key,\n                                          header[i].value, 0) == NGX_ERROR)\n        {\n            return NGX_ERROR;\n        }\n    }\n\n    dd(\"after: parent req headers count: %d\",\n       (int) r->headers_in.headers.part.nelts);\n\n    return NGX_OK;\n}",
        "func": "static ngx_int_t\nngx_http_lua_copy_request_headers(ngx_http_request_t *sr,\n    ngx_http_request_t *pr, int pr_not_chunked)\n{\n    ngx_table_elt_t                 *clh, *header;\n    ngx_list_part_t                 *part;\n    ngx_uint_t                       i;\n    u_char                          *p;\n    off_t                            len;\n\n    dd(\"before: parent req headers count: %d\",\n       (int) pr->headers_in.headers.part.nelts);\n\n    if (ngx_list_init(&sr->headers_in.headers, sr->pool, 20,\n                      sizeof(ngx_table_elt_t)) != NGX_OK)\n    {\n        return NGX_ERROR;\n    }\n\n    if (sr->request_body && !pr_not_chunked) {\n\n        /* craft our own Content-Length */\n\n        len = sr->request_body->buf ? ngx_buf_size(sr->request_body->buf) : 0;\n\n        clh = ngx_list_push(&sr->headers_in.headers);\n        if (clh == NULL) {\n            return NGX_ERROR;\n        }\n\n        clh->hash = ngx_http_lua_content_length_hash;\n        clh->key = ngx_http_lua_content_length_header_key;\n        clh->lowcase_key = ngx_pnalloc(sr->pool, clh->key.len);\n        if (clh->lowcase_key == NULL) {\n            return NGX_ERROR;\n        }\n\n        ngx_strlow(clh->lowcase_key, clh->key.data, clh->key.len);\n\n        p = ngx_palloc(sr->pool, NGX_OFF_T_LEN);\n        if (p == NULL) {\n            return NGX_ERROR;\n        }\n\n        clh->value.data = p;\n        clh->value.len = ngx_sprintf(clh->value.data, \"%O\", len)\n                         - clh->value.data;\n\n        sr->headers_in.content_length = clh;\n        sr->headers_in.content_length_n = len;\n\n        dd(\"sr crafted content-length: %.*s\",\n           (int) sr->headers_in.content_length->value.len,\n           sr->headers_in.content_length->value.data);\n    }\n\n    /* copy the parent request's headers */\n\n    part = &pr->headers_in.headers.part;\n    header = part->elts;\n\n    for (i = 0; /* void */; i++) {\n\n        if (i >= part->nelts) {\n            if (part->next == NULL) {\n                break;\n            }\n\n            part = part->next;\n            header = part->elts;\n            i = 0;\n        }\n\n        if (!pr_not_chunked && header[i].key.len == sizeof(\"Content-Length\") - 1\n            && ngx_strncasecmp(header[i].key.data, (u_char *) \"Content-Length\",\n                               sizeof(\"Content-Length\") - 1) == 0)\n        {\n            continue;\n        }\n\n        dd(\"sr copied req header %.*s: %.*s\", (int) header[i].key.len,\n           header[i].key.data, (int) header[i].value.len,\n           header[i].value.data);\n\n        if (ngx_http_lua_set_input_header(sr, header[i].key,\n                                          header[i].value, 0) == NGX_ERROR)\n        {\n            return NGX_ERROR;\n        }\n    }\n\n    dd(\"after: parent req headers count: %d\",\n       (int) pr->headers_in.headers.part.nelts);\n\n    return NGX_OK;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,9 +1,15 @@\n static ngx_int_t\n-ngx_http_lua_copy_request_headers(ngx_http_request_t *sr, ngx_http_request_t *r)\n+ngx_http_lua_copy_request_headers(ngx_http_request_t *sr,\n+    ngx_http_request_t *pr, int pr_not_chunked)\n {\n-    ngx_table_elt_t                 *header;\n+    ngx_table_elt_t                 *clh, *header;\n     ngx_list_part_t                 *part;\n     ngx_uint_t                       i;\n+    u_char                          *p;\n+    off_t                            len;\n+\n+    dd(\"before: parent req headers count: %d\",\n+       (int) pr->headers_in.headers.part.nelts);\n \n     if (ngx_list_init(&sr->headers_in.headers, sr->pool, 20,\n                       sizeof(ngx_table_elt_t)) != NGX_OK)\n@@ -11,10 +17,46 @@\n         return NGX_ERROR;\n     }\n \n-    dd(\"before: parent req headers count: %d\",\n-       (int) r->headers_in.headers.part.nelts);\n+    if (sr->request_body && !pr_not_chunked) {\n \n-    part = &r->headers_in.headers.part;\n+        /* craft our own Content-Length */\n+\n+        len = sr->request_body->buf ? ngx_buf_size(sr->request_body->buf) : 0;\n+\n+        clh = ngx_list_push(&sr->headers_in.headers);\n+        if (clh == NULL) {\n+            return NGX_ERROR;\n+        }\n+\n+        clh->hash = ngx_http_lua_content_length_hash;\n+        clh->key = ngx_http_lua_content_length_header_key;\n+        clh->lowcase_key = ngx_pnalloc(sr->pool, clh->key.len);\n+        if (clh->lowcase_key == NULL) {\n+            return NGX_ERROR;\n+        }\n+\n+        ngx_strlow(clh->lowcase_key, clh->key.data, clh->key.len);\n+\n+        p = ngx_palloc(sr->pool, NGX_OFF_T_LEN);\n+        if (p == NULL) {\n+            return NGX_ERROR;\n+        }\n+\n+        clh->value.data = p;\n+        clh->value.len = ngx_sprintf(clh->value.data, \"%O\", len)\n+                         - clh->value.data;\n+\n+        sr->headers_in.content_length = clh;\n+        sr->headers_in.content_length_n = len;\n+\n+        dd(\"sr crafted content-length: %.*s\",\n+           (int) sr->headers_in.content_length->value.len,\n+           sr->headers_in.content_length->value.data);\n+    }\n+\n+    /* copy the parent request's headers */\n+\n+    part = &pr->headers_in.headers.part;\n     header = part->elts;\n \n     for (i = 0; /* void */; i++) {\n@@ -29,7 +71,14 @@\n             i = 0;\n         }\n \n-        dd(\"setting request header %.*s: %.*s\", (int) header[i].key.len,\n+        if (!pr_not_chunked && header[i].key.len == sizeof(\"Content-Length\") - 1\n+            && ngx_strncasecmp(header[i].key.data, (u_char *) \"Content-Length\",\n+                               sizeof(\"Content-Length\") - 1) == 0)\n+        {\n+            continue;\n+        }\n+\n+        dd(\"sr copied req header %.*s: %.*s\", (int) header[i].key.len,\n            header[i].key.data, (int) header[i].value.len,\n            header[i].value.data);\n \n@@ -41,7 +90,7 @@\n     }\n \n     dd(\"after: parent req headers count: %d\",\n-       (int) r->headers_in.headers.part.nelts);\n+       (int) pr->headers_in.headers.part.nelts);\n \n     return NGX_OK;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "ngx_http_lua_copy_request_headers(ngx_http_request_t *sr, ngx_http_request_t *r)",
                "    ngx_table_elt_t                 *header;",
                "    dd(\"before: parent req headers count: %d\",",
                "       (int) r->headers_in.headers.part.nelts);",
                "    part = &r->headers_in.headers.part;",
                "        dd(\"setting request header %.*s: %.*s\", (int) header[i].key.len,",
                "       (int) r->headers_in.headers.part.nelts);"
            ],
            "added_lines": [
                "ngx_http_lua_copy_request_headers(ngx_http_request_t *sr,",
                "    ngx_http_request_t *pr, int pr_not_chunked)",
                "    ngx_table_elt_t                 *clh, *header;",
                "    u_char                          *p;",
                "    off_t                            len;",
                "",
                "    dd(\"before: parent req headers count: %d\",",
                "       (int) pr->headers_in.headers.part.nelts);",
                "    if (sr->request_body && !pr_not_chunked) {",
                "        /* craft our own Content-Length */",
                "",
                "        len = sr->request_body->buf ? ngx_buf_size(sr->request_body->buf) : 0;",
                "",
                "        clh = ngx_list_push(&sr->headers_in.headers);",
                "        if (clh == NULL) {",
                "            return NGX_ERROR;",
                "        }",
                "",
                "        clh->hash = ngx_http_lua_content_length_hash;",
                "        clh->key = ngx_http_lua_content_length_header_key;",
                "        clh->lowcase_key = ngx_pnalloc(sr->pool, clh->key.len);",
                "        if (clh->lowcase_key == NULL) {",
                "            return NGX_ERROR;",
                "        }",
                "",
                "        ngx_strlow(clh->lowcase_key, clh->key.data, clh->key.len);",
                "",
                "        p = ngx_palloc(sr->pool, NGX_OFF_T_LEN);",
                "        if (p == NULL) {",
                "            return NGX_ERROR;",
                "        }",
                "",
                "        clh->value.data = p;",
                "        clh->value.len = ngx_sprintf(clh->value.data, \"%O\", len)",
                "                         - clh->value.data;",
                "",
                "        sr->headers_in.content_length = clh;",
                "        sr->headers_in.content_length_n = len;",
                "",
                "        dd(\"sr crafted content-length: %.*s\",",
                "           (int) sr->headers_in.content_length->value.len,",
                "           sr->headers_in.content_length->value.data);",
                "    }",
                "",
                "    /* copy the parent request's headers */",
                "",
                "    part = &pr->headers_in.headers.part;",
                "        if (!pr_not_chunked && header[i].key.len == sizeof(\"Content-Length\") - 1",
                "            && ngx_strncasecmp(header[i].key.data, (u_char *) \"Content-Length\",",
                "                               sizeof(\"Content-Length\") - 1) == 0)",
                "        {",
                "            continue;",
                "        }",
                "",
                "        dd(\"sr copied req header %.*s: %.*s\", (int) header[i].key.len,",
                "       (int) pr->headers_in.headers.part.nelts);"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-11724",
        "func_name": "openresty/lua-nginx-module/ngx_http_lua_adjust_subrequest",
        "description": "An issue was discovered in OpenResty before 1.15.8.4. ngx_http_lua_subrequest.c allows HTTP request smuggling, as demonstrated by the ngx.location.capture API.",
        "git_url": "https://github.com/openresty/lua-nginx-module/commit/9ab38e8ee35fc08a57636b1b6190dca70b0076fa",
        "commit_title": "bugfix: prevented request smuggling in the ngx.location.capture API.",
        "commit_text": "",
        "func_before": "static ngx_int_t\nngx_http_lua_adjust_subrequest(ngx_http_request_t *sr, ngx_uint_t method,\n    int always_forward_body, ngx_http_request_body_t *body,\n    unsigned vars_action, ngx_array_t *extra_vars)\n{\n    ngx_http_request_t          *r;\n    ngx_int_t                    rc;\n    ngx_http_core_main_conf_t   *cmcf;\n    size_t                       size;\n\n    r = sr->parent;\n\n    sr->header_in = r->header_in;\n\n    if (body) {\n        sr->request_body = body;\n\n        rc = ngx_http_lua_set_content_length_header(sr,\n                                                    body->buf\n                                                    ? ngx_buf_size(body->buf)\n                                                    : 0);\n\n        if (rc != NGX_OK) {\n            return NGX_ERROR;\n        }\n\n    } else if (!always_forward_body\n               && method != NGX_HTTP_PUT\n               && method != NGX_HTTP_POST\n               && r->headers_in.content_length_n > 0)\n    {\n        rc = ngx_http_lua_set_content_length_header(sr, 0);\n        if (rc != NGX_OK) {\n            return NGX_ERROR;\n        }\n\n#if 1\n        sr->request_body = NULL;\n#endif\n\n    } else {\n        if (ngx_http_lua_copy_request_headers(sr, r) != NGX_OK) {\n            return NGX_ERROR;\n        }\n\n        if (sr->request_body) {\n\n            /* deep-copy the request body */\n\n            if (sr->request_body->temp_file) {\n                if (ngx_http_lua_copy_in_file_request_body(sr) != NGX_OK) {\n                    return NGX_ERROR;\n                }\n            }\n        }\n    }\n\n    sr->method = method;\n\n    switch (method) {\n        case NGX_HTTP_GET:\n            sr->method_name = ngx_http_lua_get_method;\n            break;\n\n        case NGX_HTTP_POST:\n            sr->method_name = ngx_http_lua_post_method;\n            break;\n\n        case NGX_HTTP_PUT:\n            sr->method_name = ngx_http_lua_put_method;\n            break;\n\n        case NGX_HTTP_HEAD:\n            sr->method_name = ngx_http_lua_head_method;\n            break;\n\n        case NGX_HTTP_DELETE:\n            sr->method_name = ngx_http_lua_delete_method;\n            break;\n\n        case NGX_HTTP_OPTIONS:\n            sr->method_name = ngx_http_lua_options_method;\n            break;\n\n        case NGX_HTTP_MKCOL:\n            sr->method_name = ngx_http_lua_mkcol_method;\n            break;\n\n        case NGX_HTTP_COPY:\n            sr->method_name = ngx_http_lua_copy_method;\n            break;\n\n        case NGX_HTTP_MOVE:\n            sr->method_name = ngx_http_lua_move_method;\n            break;\n\n        case NGX_HTTP_PROPFIND:\n            sr->method_name = ngx_http_lua_propfind_method;\n            break;\n\n        case NGX_HTTP_PROPPATCH:\n            sr->method_name = ngx_http_lua_proppatch_method;\n            break;\n\n        case NGX_HTTP_LOCK:\n            sr->method_name = ngx_http_lua_lock_method;\n            break;\n\n        case NGX_HTTP_UNLOCK:\n            sr->method_name = ngx_http_lua_unlock_method;\n            break;\n\n        case NGX_HTTP_PATCH:\n            sr->method_name = ngx_http_lua_patch_method;\n            break;\n\n        case NGX_HTTP_TRACE:\n            sr->method_name = ngx_http_lua_trace_method;\n            break;\n\n        default:\n            ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                          \"unsupported HTTP method: %u\", (unsigned) method);\n\n            return NGX_ERROR;\n    }\n\n    if (!(vars_action & NGX_HTTP_LUA_SHARE_ALL_VARS)) {\n        /* we do not inherit the parent request's variables */\n        cmcf = ngx_http_get_module_main_conf(sr, ngx_http_core_module);\n\n        size = cmcf->variables.nelts * sizeof(ngx_http_variable_value_t);\n\n        if (vars_action & NGX_HTTP_LUA_COPY_ALL_VARS) {\n\n            sr->variables = ngx_palloc(sr->pool, size);\n            if (sr->variables == NULL) {\n                return NGX_ERROR;\n            }\n\n            ngx_memcpy(sr->variables, r->variables, size);\n\n        } else {\n\n            /* we do not inherit the parent request's variables */\n\n            sr->variables = ngx_pcalloc(sr->pool, size);\n            if (sr->variables == NULL) {\n                return NGX_ERROR;\n            }\n        }\n    }\n\n    return ngx_http_lua_subrequest_add_extra_vars(sr, extra_vars);\n}",
        "func": "static ngx_int_t\nngx_http_lua_adjust_subrequest(ngx_http_request_t *sr, ngx_uint_t method,\n    int always_forward_body, ngx_http_request_body_t *body,\n    unsigned vars_action, ngx_array_t *extra_vars)\n{\n    ngx_http_request_t          *r;\n    ngx_http_core_main_conf_t   *cmcf;\n    int                          pr_not_chunked = 0;\n    size_t                       size;\n\n    r = sr->parent;\n\n    sr->header_in = r->header_in;\n\n    if (body) {\n        sr->request_body = body;\n\n    } else if (!always_forward_body\n               && method != NGX_HTTP_PUT\n               && method != NGX_HTTP_POST\n               && r->headers_in.content_length_n > 0)\n    {\n        sr->request_body = NULL;\n\n    } else {\n        if (!r->headers_in.chunked) {\n            pr_not_chunked = 1;\n        }\n\n        if (sr->request_body && sr->request_body->temp_file) {\n\n            /* deep-copy the request body */\n\n            if (ngx_http_lua_copy_in_file_request_body(sr) != NGX_OK) {\n                return NGX_ERROR;\n            }\n        }\n    }\n\n    if (ngx_http_lua_copy_request_headers(sr, r, pr_not_chunked) != NGX_OK) {\n        return NGX_ERROR;\n    }\n\n    sr->method = method;\n\n    switch (method) {\n        case NGX_HTTP_GET:\n            sr->method_name = ngx_http_lua_get_method;\n            break;\n\n        case NGX_HTTP_POST:\n            sr->method_name = ngx_http_lua_post_method;\n            break;\n\n        case NGX_HTTP_PUT:\n            sr->method_name = ngx_http_lua_put_method;\n            break;\n\n        case NGX_HTTP_HEAD:\n            sr->method_name = ngx_http_lua_head_method;\n            break;\n\n        case NGX_HTTP_DELETE:\n            sr->method_name = ngx_http_lua_delete_method;\n            break;\n\n        case NGX_HTTP_OPTIONS:\n            sr->method_name = ngx_http_lua_options_method;\n            break;\n\n        case NGX_HTTP_MKCOL:\n            sr->method_name = ngx_http_lua_mkcol_method;\n            break;\n\n        case NGX_HTTP_COPY:\n            sr->method_name = ngx_http_lua_copy_method;\n            break;\n\n        case NGX_HTTP_MOVE:\n            sr->method_name = ngx_http_lua_move_method;\n            break;\n\n        case NGX_HTTP_PROPFIND:\n            sr->method_name = ngx_http_lua_propfind_method;\n            break;\n\n        case NGX_HTTP_PROPPATCH:\n            sr->method_name = ngx_http_lua_proppatch_method;\n            break;\n\n        case NGX_HTTP_LOCK:\n            sr->method_name = ngx_http_lua_lock_method;\n            break;\n\n        case NGX_HTTP_UNLOCK:\n            sr->method_name = ngx_http_lua_unlock_method;\n            break;\n\n        case NGX_HTTP_PATCH:\n            sr->method_name = ngx_http_lua_patch_method;\n            break;\n\n        case NGX_HTTP_TRACE:\n            sr->method_name = ngx_http_lua_trace_method;\n            break;\n\n        default:\n            ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,\n                          \"unsupported HTTP method: %u\", (unsigned) method);\n\n            return NGX_ERROR;\n    }\n\n    if (!(vars_action & NGX_HTTP_LUA_SHARE_ALL_VARS)) {\n        /* we do not inherit the parent request's variables */\n        cmcf = ngx_http_get_module_main_conf(sr, ngx_http_core_module);\n\n        size = cmcf->variables.nelts * sizeof(ngx_http_variable_value_t);\n\n        if (vars_action & NGX_HTTP_LUA_COPY_ALL_VARS) {\n\n            sr->variables = ngx_palloc(sr->pool, size);\n            if (sr->variables == NULL) {\n                return NGX_ERROR;\n            }\n\n            ngx_memcpy(sr->variables, r->variables, size);\n\n        } else {\n\n            /* we do not inherit the parent request's variables */\n\n            sr->variables = ngx_pcalloc(sr->pool, size);\n            if (sr->variables == NULL) {\n                return NGX_ERROR;\n            }\n        }\n    }\n\n    return ngx_http_lua_subrequest_add_extra_vars(sr, extra_vars);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,8 +4,8 @@\n     unsigned vars_action, ngx_array_t *extra_vars)\n {\n     ngx_http_request_t          *r;\n-    ngx_int_t                    rc;\n     ngx_http_core_main_conf_t   *cmcf;\n+    int                          pr_not_chunked = 0;\n     size_t                       size;\n \n     r = sr->parent;\n@@ -15,44 +15,30 @@\n     if (body) {\n         sr->request_body = body;\n \n-        rc = ngx_http_lua_set_content_length_header(sr,\n-                                                    body->buf\n-                                                    ? ngx_buf_size(body->buf)\n-                                                    : 0);\n-\n-        if (rc != NGX_OK) {\n-            return NGX_ERROR;\n-        }\n-\n     } else if (!always_forward_body\n                && method != NGX_HTTP_PUT\n                && method != NGX_HTTP_POST\n                && r->headers_in.content_length_n > 0)\n     {\n-        rc = ngx_http_lua_set_content_length_header(sr, 0);\n-        if (rc != NGX_OK) {\n-            return NGX_ERROR;\n+        sr->request_body = NULL;\n+\n+    } else {\n+        if (!r->headers_in.chunked) {\n+            pr_not_chunked = 1;\n         }\n \n-#if 1\n-        sr->request_body = NULL;\n-#endif\n-\n-    } else {\n-        if (ngx_http_lua_copy_request_headers(sr, r) != NGX_OK) {\n-            return NGX_ERROR;\n-        }\n-\n-        if (sr->request_body) {\n+        if (sr->request_body && sr->request_body->temp_file) {\n \n             /* deep-copy the request body */\n \n-            if (sr->request_body->temp_file) {\n-                if (ngx_http_lua_copy_in_file_request_body(sr) != NGX_OK) {\n-                    return NGX_ERROR;\n-                }\n+            if (ngx_http_lua_copy_in_file_request_body(sr) != NGX_OK) {\n+                return NGX_ERROR;\n             }\n         }\n+    }\n+\n+    if (ngx_http_lua_copy_request_headers(sr, r, pr_not_chunked) != NGX_OK) {\n+        return NGX_ERROR;\n     }\n \n     sr->method = method;",
        "diff_line_info": {
            "deleted_lines": [
                "    ngx_int_t                    rc;",
                "        rc = ngx_http_lua_set_content_length_header(sr,",
                "                                                    body->buf",
                "                                                    ? ngx_buf_size(body->buf)",
                "                                                    : 0);",
                "",
                "        if (rc != NGX_OK) {",
                "            return NGX_ERROR;",
                "        }",
                "",
                "        rc = ngx_http_lua_set_content_length_header(sr, 0);",
                "        if (rc != NGX_OK) {",
                "            return NGX_ERROR;",
                "#if 1",
                "        sr->request_body = NULL;",
                "#endif",
                "",
                "    } else {",
                "        if (ngx_http_lua_copy_request_headers(sr, r) != NGX_OK) {",
                "            return NGX_ERROR;",
                "        }",
                "",
                "        if (sr->request_body) {",
                "            if (sr->request_body->temp_file) {",
                "                if (ngx_http_lua_copy_in_file_request_body(sr) != NGX_OK) {",
                "                    return NGX_ERROR;",
                "                }"
            ],
            "added_lines": [
                "    int                          pr_not_chunked = 0;",
                "        sr->request_body = NULL;",
                "",
                "    } else {",
                "        if (!r->headers_in.chunked) {",
                "            pr_not_chunked = 1;",
                "        if (sr->request_body && sr->request_body->temp_file) {",
                "            if (ngx_http_lua_copy_in_file_request_body(sr) != NGX_OK) {",
                "                return NGX_ERROR;",
                "    }",
                "",
                "    if (ngx_http_lua_copy_request_headers(sr, r, pr_not_chunked) != NGX_OK) {",
                "        return NGX_ERROR;"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-7670",
        "func_name": "ohler55/agoo/con_header_read",
        "description": "agoo prior to 2.14.0 allows request smuggling attacks where agoo is used as a backend and a frontend proxy also being vulnerable. HTTP pipelining issues and request smuggling attacks might be possible due to incorrect Content-Length and Transfer encoding header parsing. It is possible to conduct HTTP request smuggling attacks where `agoo` is used as part of a chain of backend servers due to insufficient `Content-Length` and `Transfer Encoding` parsing.",
        "git_url": "https://github.com/ohler55/agoo/commit/23d03535cf7b50d679a60a953a0cae9519a4a130",
        "commit_title": "Remote addr (#99)",
        "commit_text": " * REMOTE_ADDR added\r \r * Ready for merge",
        "func_before": "static HeadReturn\ncon_header_read(agooCon c, size_t *mlenp) {\n    char\t\t*hend = strstr(c->buf, \"\\r\\n\\r\\n\");\n    agooMethod\t\tmethod;\n    struct _agooSeg\tpath;\n    char\t\t*query = NULL;\n    char\t\t*qend;\n    char\t\t*b;\n    size_t\t\tclen = 0;\n    long\t\tmlen;\n    agooHook\t\thook = NULL;\n    agooPage\t\tp;\n    struct _agooErr\terr = AGOO_ERR_INIT;\n\n    if (NULL == hend) {\n\tif (sizeof(c->buf) - 1 <= c->bcnt) {\n\t    return bad_request(c, 431, __LINE__);\n\t}\n\treturn HEAD_AGAIN;\n    }\n    if (agoo_req_cat.on) {\n\t*hend = '\\0';\n\tagoo_log_cat(&agoo_req_cat, \"%s %llu: %s\", agoo_con_kind_str(c->bind->kind), (unsigned long long)c->id, c->buf);\n\t*hend = '\\r';\n    }\n    for (b = c->buf; ' ' != *b; b++) {\n\tif ('\\0' == *b) {\n\t    return bad_request(c, 400, __LINE__);\n\t}\n    }\n    switch (toupper(*c->buf)) {\n    case 'G':\n\tif (3 != b - c->buf || 0 != strncmp(\"GET\", c->buf, 3)) {\n\t    return bad_request(c, 400, __LINE__);\n\t}\n\tmethod = AGOO_GET;\n\tbreak;\n    case 'P': {\n\tconst char\t*v;\n\tint\t\tvlen = 0;\n\tchar\t\t*vend;\n\n\tif (3 == b - c->buf && 0 == strncmp(\"PUT\", c->buf, 3)) {\n\t    method = AGOO_PUT;\n\t} else if (4 == b - c->buf && 0 == strncmp(\"POST\", c->buf, 4)) {\n\t    method = AGOO_POST;\n\t} else {\n\t    return bad_request(c, 400, __LINE__);\n\t}\n\tif (NULL == (v = agoo_con_header_value(c->buf, (int)(hend - c->buf), \"Content-Length\", &vlen))) {\n\t    return bad_request(c, 411, __LINE__);\n\t}\n\tclen = (size_t)strtoul(v, &vend, 10);\n\tif (vend != v + vlen) {\n\t    return bad_request(c, 411, __LINE__);\n\t}\n\tbreak;\n    }\n    case 'D':\n\tif (6 != b - c->buf || 0 != strncmp(\"DELETE\", c->buf, 6)) {\n\t    return bad_request(c, 400, __LINE__);\n\t}\n\tmethod = AGOO_DELETE;\n\tbreak;\n    case 'H':\n\tif (4 != b - c->buf || 0 != strncmp(\"HEAD\", c->buf, 4)) {\n\t    return bad_request(c, 400, __LINE__);\n\t}\n\tmethod = AGOO_HEAD;\n\tbreak;\n    case 'O':\n\tif (7 != b - c->buf || 0 != strncmp(\"OPTIONS\", c->buf, 7)) {\n\t    return bad_request(c, 400, __LINE__);\n\t}\n\tmethod = AGOO_OPTIONS;\n\tbreak;\n    case 'C':\n\tif (7 != b - c->buf || 0 != strncmp(\"CONNECT\", c->buf, 7)) {\n\t    return bad_request(c, 400, __LINE__);\n\t}\n\tmethod = AGOO_CONNECT;\n\tbreak;\n    default:\n\treturn bad_request(c, 400, __LINE__);\n    }\n    for (; ' ' == *b; b++) {\n\tif ('\\0' == *b) {\n\t    return bad_request(c, 400, __LINE__);\n\t}\n    }\n    path.start = b;\n    for (; ' ' != *b; b++) {\n\tswitch (*b) {\n\tcase '?':\n\t    path.end = b;\n\t    query = b + 1;\n\t    break;\n\tcase '\\0':\n\t    return bad_request(c, 400, __LINE__);\n\tdefault:\n\t    break;\n\t}\n    }\n    if (NULL == query) {\n\tpath.end = b;\n\tquery = b;\n\tqend = b;\n    } else {\n\tqend = b;\n    }\n    mlen = hend - c->buf + 4 + clen;\n    *mlenp = mlen;\n\n    if (AGOO_GET == method) {\n\tchar\t\troot_buf[20148];\n\tconst char\t*root = NULL;\n\n\tif (NULL != (p = agoo_group_get(&err, path.start, (int)(path.end - path.start)))) {\n\t    if (page_response(c, p, hend)) {\n\t\treturn bad_request(c, 500, __LINE__);\n\t    }\n\t    return HEAD_HANDLED;\n\t}\n\tif (agoo_domain_use()) {\n\t    const char\t*host;\n\t    int\t\tvlen = 0;\n\n\t    if (NULL == (host = agoo_con_header_value(c->buf, (int)(hend - c->buf), \"Host\", &vlen))) {\n\t\treturn bad_request(c, 411, __LINE__);\n\t    }\n\t    ((char*)host)[vlen] = '\\0';\n\t    root = agoo_domain_resolve(host, root_buf, sizeof(root_buf));\n\t    ((char*)host)[vlen] = '\\r';\n\t}\n\tif (agoo_server.root_first &&\n\t    NULL != (p = agoo_page_get(&err, path.start, (int)(path.end - path.start), root))) {\n\t    if (page_response(c, p, hend)) {\n\t\treturn bad_request(c, 500, __LINE__);\n\t    }\n\t    return HEAD_HANDLED;\n\t}\n\tif (NULL == (hook = agoo_hook_find(agoo_server.hooks, method, &path))) {\n\t    if (NULL != (p = agoo_page_get(&err, path.start, (int)(path.end - path.start), root))) {\n\t\tif (page_response(c, p, hend)) {\n\t\t    return bad_request(c, 500, __LINE__);\n\t\t}\n\t\treturn HEAD_HANDLED;\n\t    }\n\t    if (NULL == agoo_server.hook404) {\n\t\treturn bad_request(c, 404, __LINE__);\n\t    }\n\t    hook = agoo_server.hook404;\n\t}\n    } else if (NULL == (hook = agoo_hook_find(agoo_server.hooks, method, &path))) {\n \treturn bad_request(c, 404, __LINE__);\n    }\n    // Create request and populate.\n    if (NULL == (c->req = agoo_req_create(mlen))) {\n\treturn bad_request(c, 413, __LINE__);\n    }\n    if ((long)c->bcnt <= mlen) {\n\tmemcpy(c->req->msg, c->buf, c->bcnt);\n\tif ((long)c->bcnt < mlen) {\n\t    memset(c->req->msg + c->bcnt, 0, mlen - c->bcnt);\n\t}\n    } else {\n\tmemcpy(c->req->msg, c->buf, mlen);\n    }\n    c->req->msg[mlen] = '\\0';\n    c->req->method = method;\n    c->req->upgrade = AGOO_UP_NONE;\n    c->req->up = NULL;\n    c->req->path.start = c->req->msg + (path.start - c->buf);\n    c->req->path.len = (int)(path.end - path.start);\n    c->req->query.start = c->req->msg + (query - c->buf);\n    c->req->query.len = (int)(qend - query);\n    c->req->query.start[c->req->query.len] = '\\0';\n    c->req->body.start = c->req->msg + (hend - c->buf + 4);\n    c->req->body.len = (unsigned int)clen;\n    b = strstr(b, \"\\r\\n\");\n    c->req->header.start = c->req->msg + (b + 2 - c->buf);\n    if (b < hend) {\n\tc->req->header.len = (unsigned int)(hend - b - 2);\n    } else {\n\tc->req->header.len = 0;\n    }\n    c->req->res = NULL;\n    c->req->hook = hook;\n\n    return HEAD_OK;\n}",
        "func": "static HeadReturn\ncon_header_read(agooCon c, size_t *mlenp) {\n    char\t\t*hend = strstr(c->buf, \"\\r\\n\\r\\n\");\n    agooMethod\t\tmethod;\n    struct _agooSeg\tpath;\n    char\t\t*query = NULL;\n    char\t\t*qend;\n    char\t\t*b;\n    size_t\t\tclen = 0;\n    long\t\tmlen;\n    agooHook\t\thook = NULL;\n    agooPage\t\tp;\n    struct _agooErr\terr = AGOO_ERR_INIT;\n\n    if (NULL == hend) {\n\tif (sizeof(c->buf) - 1 <= c->bcnt) {\n\t    return bad_request(c, 431, __LINE__);\n\t}\n\treturn HEAD_AGAIN;\n    }\n    if (agoo_req_cat.on) {\n\t*hend = '\\0';\n\tagoo_log_cat(&agoo_req_cat, \"%s %llu: %s\", agoo_con_kind_str(c->bind->kind), (unsigned long long)c->id, c->buf);\n\t*hend = '\\r';\n    }\n    for (b = c->buf; ' ' != *b; b++) {\n\tif ('\\0' == *b) {\n\t    return bad_request(c, 400, __LINE__);\n\t}\n    }\n    switch (toupper(*c->buf)) {\n    case 'G':\n\tif (3 != b - c->buf || 0 != strncmp(\"GET\", c->buf, 3)) {\n\t    return bad_request(c, 400, __LINE__);\n\t}\n\tmethod = AGOO_GET;\n\tbreak;\n    case 'P': {\n\tconst char\t*v;\n\tint\t\tvlen = 0;\n\tchar\t\t*vend;\n\n\tif (3 == b - c->buf && 0 == strncmp(\"PUT\", c->buf, 3)) {\n\t    method = AGOO_PUT;\n\t} else if (4 == b - c->buf && 0 == strncmp(\"POST\", c->buf, 4)) {\n\t    method = AGOO_POST;\n\t} else {\n\t    return bad_request(c, 400, __LINE__);\n\t}\n\tif (NULL == (v = agoo_con_header_value(c->buf, (int)(hend - c->buf), \"Content-Length\", &vlen))) {\n\t    return bad_request(c, 411, __LINE__);\n\t}\n\tclen = (size_t)strtoul(v, &vend, 10);\n\tif (vend != v + vlen) {\n\t    return bad_request(c, 411, __LINE__);\n\t}\n\tbreak;\n    }\n    case 'D':\n\tif (6 != b - c->buf || 0 != strncmp(\"DELETE\", c->buf, 6)) {\n\t    return bad_request(c, 400, __LINE__);\n\t}\n\tmethod = AGOO_DELETE;\n\tbreak;\n    case 'H':\n\tif (4 != b - c->buf || 0 != strncmp(\"HEAD\", c->buf, 4)) {\n\t    return bad_request(c, 400, __LINE__);\n\t}\n\tmethod = AGOO_HEAD;\n\tbreak;\n    case 'O':\n\tif (7 != b - c->buf || 0 != strncmp(\"OPTIONS\", c->buf, 7)) {\n\t    return bad_request(c, 400, __LINE__);\n\t}\n\tmethod = AGOO_OPTIONS;\n\tbreak;\n    case 'C':\n\tif (7 != b - c->buf || 0 != strncmp(\"CONNECT\", c->buf, 7)) {\n\t    return bad_request(c, 400, __LINE__);\n\t}\n\tmethod = AGOO_CONNECT;\n\tbreak;\n    default:\n\treturn bad_request(c, 400, __LINE__);\n    }\n    for (; ' ' == *b; b++) {\n\tif ('\\0' == *b) {\n\t    return bad_request(c, 400, __LINE__);\n\t}\n    }\n    path.start = b;\n    for (; ' ' != *b; b++) {\n\tswitch (*b) {\n\tcase '?':\n\t    path.end = b;\n\t    query = b + 1;\n\t    break;\n\tcase '\\0':\n\t    return bad_request(c, 400, __LINE__);\n\tdefault:\n\t    break;\n\t}\n    }\n    if (NULL == query) {\n\tpath.end = b;\n\tquery = b;\n\tqend = b;\n    } else {\n\tqend = b;\n    }\n    mlen = hend - c->buf + 4 + clen;\n    *mlenp = mlen;\n\n    if (AGOO_GET == method) {\n\tchar\t\troot_buf[20148];\n\tconst char\t*root = NULL;\n\n\tif (NULL != (p = agoo_group_get(&err, path.start, (int)(path.end - path.start)))) {\n\t    if (page_response(c, p, hend)) {\n\t\treturn bad_request(c, 500, __LINE__);\n\t    }\n\t    return HEAD_HANDLED;\n\t}\n\tif (agoo_domain_use()) {\n\t    const char\t*host;\n\t    int\t\tvlen = 0;\n\n\t    if (NULL == (host = agoo_con_header_value(c->buf, (int)(hend - c->buf), \"Host\", &vlen))) {\n\t\treturn bad_request(c, 411, __LINE__);\n\t    }\n\t    ((char*)host)[vlen] = '\\0';\n\t    root = agoo_domain_resolve(host, root_buf, sizeof(root_buf));\n\t    ((char*)host)[vlen] = '\\r';\n\t}\n\tif (agoo_server.root_first &&\n\t    NULL != (p = agoo_page_get(&err, path.start, (int)(path.end - path.start), root))) {\n\t    if (page_response(c, p, hend)) {\n\t\treturn bad_request(c, 500, __LINE__);\n\t    }\n\t    return HEAD_HANDLED;\n\t}\n\tif (NULL == (hook = agoo_hook_find(agoo_server.hooks, method, &path))) {\n\t    if (NULL != (p = agoo_page_get(&err, path.start, (int)(path.end - path.start), root))) {\n\t\tif (page_response(c, p, hend)) {\n\t\t    return bad_request(c, 500, __LINE__);\n\t\t}\n\t\treturn HEAD_HANDLED;\n\t    }\n\t    if (NULL == agoo_server.hook404) {\n\t\treturn bad_request(c, 404, __LINE__);\n\t    }\n\t    hook = agoo_server.hook404;\n\t}\n    } else if (NULL == (hook = agoo_hook_find(agoo_server.hooks, method, &path))) {\n \treturn bad_request(c, 404, __LINE__);\n    }\n    // Create request and populate.\n    if (NULL == (c->req = agoo_req_create(mlen))) {\n\treturn bad_request(c, 413, __LINE__);\n    }\n    if ((long)c->bcnt <= mlen) {\n\tmemcpy(c->req->msg, c->buf, c->bcnt);\n\tif ((long)c->bcnt < mlen) {\n\t    memset(c->req->msg + c->bcnt, 0, mlen - c->bcnt);\n\t}\n    } else {\n\tmemcpy(c->req->msg, c->buf, mlen);\n    }\n    c->req->msg[mlen] = '\\0';\n    c->req->method = method;\n    c->req->upgrade = AGOO_UP_NONE;\n    c->req->up = NULL;\n    memcpy(c->req->remote, c->remote, sizeof(c->remote));\n    c->req->path.start = c->req->msg + (path.start - c->buf);\n    c->req->path.len = (int)(path.end - path.start);\n    c->req->query.start = c->req->msg + (query - c->buf);\n    c->req->query.len = (int)(qend - query);\n    c->req->query.start[c->req->query.len] = '\\0';\n    c->req->body.start = c->req->msg + (hend - c->buf + 4);\n    c->req->body.len = (unsigned int)clen;\n    b = strstr(b, \"\\r\\n\");\n    c->req->header.start = c->req->msg + (b + 2 - c->buf);\n    if (b < hend) {\n\tc->req->header.len = (unsigned int)(hend - b - 2);\n    } else {\n\tc->req->header.len = 0;\n    }\n    c->req->res = NULL;\n    c->req->hook = hook;\n\n    return HEAD_OK;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -170,6 +170,7 @@\n     c->req->method = method;\n     c->req->upgrade = AGOO_UP_NONE;\n     c->req->up = NULL;\n+    memcpy(c->req->remote, c->remote, sizeof(c->remote));\n     c->req->path.start = c->req->msg + (path.start - c->buf);\n     c->req->path.len = (int)(path.end - path.start);\n     c->req->query.start = c->req->msg + (query - c->buf);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    memcpy(c->req->remote, c->remote, sizeof(c->remote));"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-7670",
        "func_name": "ohler55/agoo/agoo_con_create",
        "description": "agoo prior to 2.14.0 allows request smuggling attacks where agoo is used as a backend and a frontend proxy also being vulnerable. HTTP pipelining issues and request smuggling attacks might be possible due to incorrect Content-Length and Transfer encoding header parsing. It is possible to conduct HTTP request smuggling attacks where `agoo` is used as part of a chain of backend servers due to insufficient `Content-Length` and `Transfer Encoding` parsing.",
        "git_url": "https://github.com/ohler55/agoo/commit/23d03535cf7b50d679a60a953a0cae9519a4a130",
        "commit_title": "Remote addr (#99)",
        "commit_text": " * REMOTE_ADDR added\r \r * Ready for merge",
        "func_before": "agooCon\nagoo_con_create(agooErr err, int sock, uint64_t id, agooBind b) {\n    agooCon\tc;\n\n    if (NULL == (c = (agooCon)AGOO_CALLOC(1, sizeof(struct _agooCon)))) {\n\tAGOO_ERR_MEM(err, \"Connection\");\n    } else {\n\tc->sock = sock;\n\tc->id = id;\n\tc->timeout = dtime() + CON_TIMEOUT;\n\tc->bind = b;\n\tc->loop = NULL;\n\tpthread_mutex_init(&c->res_lock, 0);\n    }\n    return c;\n}",
        "func": "agooCon\nagoo_con_create(agooErr err, int sock, uint64_t id, agooBind b) {\n    agooCon\tc;\n\n    if (NULL == (c = (agooCon)AGOO_CALLOC(1, sizeof(struct _agooCon)))) {\n\tAGOO_ERR_MEM(err, \"Connection\");\n    } else {\n\t// It would be better to get this information in server.c after\n\t// accept() but that does not work on macOS so instead a call to\n\t// getpeername() is used instead.\n\tstruct sockaddr_storage\taddr;\n\tsocklen_t\t\tlen = sizeof(addr);\n\n\tgetpeername(sock, (struct sockaddr*)&addr, &len);\n\tif (addr.ss_family == AF_INET) {\n\t    struct sockaddr_in\t*s = (struct sockaddr_in*)&addr;\n\n\t    inet_ntop(AF_INET, &s->sin_addr, c->remote, sizeof(c->remote));\n\t} else {\n\t    struct sockaddr_in6\t*s = (struct sockaddr_in6*)&addr;\n\n\t    inet_ntop(AF_INET6, &s->sin6_addr, c->remote, sizeof(c->remote));\n\t}\n\tc->sock = sock;\n\tc->id = id;\n\tc->timeout = dtime() + CON_TIMEOUT;\n\tc->bind = b;\n\tc->loop = NULL;\n\tpthread_mutex_init(&c->res_lock, 0);\n    }\n    return c;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,6 +5,22 @@\n     if (NULL == (c = (agooCon)AGOO_CALLOC(1, sizeof(struct _agooCon)))) {\n \tAGOO_ERR_MEM(err, \"Connection\");\n     } else {\n+\t// It would be better to get this information in server.c after\n+\t// accept() but that does not work on macOS so instead a call to\n+\t// getpeername() is used instead.\n+\tstruct sockaddr_storage\taddr;\n+\tsocklen_t\t\tlen = sizeof(addr);\n+\n+\tgetpeername(sock, (struct sockaddr*)&addr, &len);\n+\tif (addr.ss_family == AF_INET) {\n+\t    struct sockaddr_in\t*s = (struct sockaddr_in*)&addr;\n+\n+\t    inet_ntop(AF_INET, &s->sin_addr, c->remote, sizeof(c->remote));\n+\t} else {\n+\t    struct sockaddr_in6\t*s = (struct sockaddr_in6*)&addr;\n+\n+\t    inet_ntop(AF_INET6, &s->sin6_addr, c->remote, sizeof(c->remote));\n+\t}\n \tc->sock = sock;\n \tc->id = id;\n \tc->timeout = dtime() + CON_TIMEOUT;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t// It would be better to get this information in server.c after",
                "\t// accept() but that does not work on macOS so instead a call to",
                "\t// getpeername() is used instead.",
                "\tstruct sockaddr_storage\taddr;",
                "\tsocklen_t\t\tlen = sizeof(addr);",
                "",
                "\tgetpeername(sock, (struct sockaddr*)&addr, &len);",
                "\tif (addr.ss_family == AF_INET) {",
                "\t    struct sockaddr_in\t*s = (struct sockaddr_in*)&addr;",
                "",
                "\t    inet_ntop(AF_INET, &s->sin_addr, c->remote, sizeof(c->remote));",
                "\t} else {",
                "\t    struct sockaddr_in6\t*s = (struct sockaddr_in6*)&addr;",
                "",
                "\t    inet_ntop(AF_INET6, &s->sin6_addr, c->remote, sizeof(c->remote));",
                "\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-7670",
        "func_name": "ohler55/agoo/request_env",
        "description": "agoo prior to 2.14.0 allows request smuggling attacks where agoo is used as a backend and a frontend proxy also being vulnerable. HTTP pipelining issues and request smuggling attacks might be possible due to incorrect Content-Length and Transfer encoding header parsing. It is possible to conduct HTTP request smuggling attacks where `agoo` is used as part of a chain of backend servers due to insufficient `Content-Length` and `Transfer Encoding` parsing.",
        "git_url": "https://github.com/ohler55/agoo/commit/23d03535cf7b50d679a60a953a0cae9519a4a130",
        "commit_title": "Remote addr (#99)",
        "commit_text": " * REMOTE_ADDR added\r \r * Ready for merge",
        "func_before": "VALUE\nrequest_env(agooReq req, VALUE self) {\n    if (Qnil == (VALUE)req->env) {\n\tvolatile VALUE\tenv = rb_hash_new();\n\n\t// As described by\n\t// http://www.rubydoc.info/github/rack/rack/master/file/SPEC and\n\t// https://github.com/rack/rack/blob/master/SPEC.\n\n\trb_hash_aset(env, request_method_val, req_method(req));\n\trb_hash_aset(env, script_name_val, req_script_name(req));\n\trb_hash_aset(env, path_info_val, req_path_info(req));\n\trb_hash_aset(env, query_string_val, req_query_string(req));\n\trb_hash_aset(env, server_name_val, req_server_name(req));\n\trb_hash_aset(env, server_port_val, req_server_port(req));\n\tfill_headers(req, env);\n\trb_hash_aset(env, rack_version_val, rack_version_val_val);\n\trb_hash_aset(env, rack_url_scheme_val, req_rack_url_scheme(req));\n\trb_hash_aset(env, rack_input_val, req_rack_input(req));\n\trb_hash_aset(env, rack_errors_val, req_rack_errors(req));\n\trb_hash_aset(env, rack_multithread_val, req_rack_multithread(req));\n\trb_hash_aset(env, rack_multiprocess_val, Qfalse);\n\trb_hash_aset(env, rack_run_once_val, Qfalse);\n\trb_hash_aset(env, rack_logger_val, req_rack_logger(req));\n\trb_hash_aset(env, rack_upgrade_val, req_rack_upgrade(req));\n\trb_hash_aset(env, rack_hijackq_val, Qtrue);\n\n\t// TBD should return IO on #call and set hijack_io on env object that\n\t//  has a call method that wraps the req->res->con->sock then set the\n\t//  sock to 0 or maybe con. mutex? env[rack.hijack_io] = IO.new(sock,\n\t//  \"rw\") - maybe it works.\n\t//\n\t// set a flag on con to indicate it has been hijacked\n\t// then set sock to 0 in con loop and destroy con\n\trb_hash_aset(env, rack_hijack_val, self);\n\trb_hash_aset(env, rack_hijack_io_val, Qnil);\n\n\tif (agoo_server.rack_early_hints) {\n\t    volatile VALUE\teh = agoo_early_hints_new(req);\n\n\t    rb_hash_aset(env, early_hints_val, eh);\n\t}\n\treq->env = (void*)env;\n    }\n    return (VALUE)req->env;\n}",
        "func": "VALUE\nrequest_env(agooReq req, VALUE self) {\n    if (Qnil == (VALUE)req->env) {\n\tvolatile VALUE\tenv = rb_hash_new();\n\n\t// As described by\n\t// http://www.rubydoc.info/github/rack/rack/master/file/SPEC and\n\t// https://github.com/rack/rack/blob/master/SPEC.\n\n\trb_hash_aset(env, request_method_val, req_method(req));\n\trb_hash_aset(env, script_name_val, req_script_name(req));\n\trb_hash_aset(env, path_info_val, req_path_info(req));\n\trb_hash_aset(env, query_string_val, req_query_string(req));\n\trb_hash_aset(env, remote_addr_val, req_remote_addr(req));\n\trb_hash_aset(env, server_port_val, req_server_port(req));\n\trb_hash_aset(env, server_name_val, req_server_name(req));\n\tfill_headers(req, env);\n\trb_hash_aset(env, rack_version_val, rack_version_val_val);\n\trb_hash_aset(env, rack_url_scheme_val, req_rack_url_scheme(req));\n\trb_hash_aset(env, rack_input_val, req_rack_input(req));\n\trb_hash_aset(env, rack_errors_val, req_rack_errors(req));\n\trb_hash_aset(env, rack_multithread_val, req_rack_multithread(req));\n\trb_hash_aset(env, rack_multiprocess_val, Qfalse);\n\trb_hash_aset(env, rack_run_once_val, Qfalse);\n\trb_hash_aset(env, rack_logger_val, req_rack_logger(req));\n\trb_hash_aset(env, rack_upgrade_val, req_rack_upgrade(req));\n\trb_hash_aset(env, rack_hijackq_val, Qtrue);\n\n\t// TBD should return IO on #call and set hijack_io on env object that\n\t//  has a call method that wraps the req->res->con->sock then set the\n\t//  sock to 0 or maybe con. mutex? env[rack.hijack_io] = IO.new(sock,\n\t//  \"rw\") - maybe it works.\n\t//\n\t// set a flag on con to indicate it has been hijacked\n\t// then set sock to 0 in con loop and destroy con\n\trb_hash_aset(env, rack_hijack_val, self);\n\trb_hash_aset(env, rack_hijack_io_val, Qnil);\n\n\tif (agoo_server.rack_early_hints) {\n\t    volatile VALUE\teh = agoo_early_hints_new(req);\n\n\t    rb_hash_aset(env, early_hints_val, eh);\n\t}\n\treq->env = (void*)env;\n    }\n    return (VALUE)req->env;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -11,8 +11,9 @@\n \trb_hash_aset(env, script_name_val, req_script_name(req));\n \trb_hash_aset(env, path_info_val, req_path_info(req));\n \trb_hash_aset(env, query_string_val, req_query_string(req));\n+\trb_hash_aset(env, remote_addr_val, req_remote_addr(req));\n+\trb_hash_aset(env, server_port_val, req_server_port(req));\n \trb_hash_aset(env, server_name_val, req_server_name(req));\n-\trb_hash_aset(env, server_port_val, req_server_port(req));\n \tfill_headers(req, env);\n \trb_hash_aset(env, rack_version_val, rack_version_val_val);\n \trb_hash_aset(env, rack_url_scheme_val, req_rack_url_scheme(req));",
        "diff_line_info": {
            "deleted_lines": [
                "\trb_hash_aset(env, server_port_val, req_server_port(req));"
            ],
            "added_lines": [
                "\trb_hash_aset(env, remote_addr_val, req_remote_addr(req));",
                "\trb_hash_aset(env, server_port_val, req_server_port(req));"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-7670",
        "func_name": "ohler55/agoo/add_header_value",
        "description": "agoo prior to 2.14.0 allows request smuggling attacks where agoo is used as a backend and a frontend proxy also being vulnerable. HTTP pipelining issues and request smuggling attacks might be possible due to incorrect Content-Length and Transfer encoding header parsing. It is possible to conduct HTTP request smuggling attacks where `agoo` is used as part of a chain of backend servers due to insufficient `Content-Length` and `Transfer Encoding` parsing.",
        "git_url": "https://github.com/ohler55/agoo/commit/23d03535cf7b50d679a60a953a0cae9519a4a130",
        "commit_title": "Remote addr (#99)",
        "commit_text": " * REMOTE_ADDR added\r \r * Ready for merge",
        "func_before": "static void\nadd_header_value(VALUE hh, const char *key, int klen, const char *val, int vlen) {\n    if (sizeof(content_type) - 1 == klen && 0 == strncasecmp(key, content_type, sizeof(content_type) - 1)) {\n\trb_hash_aset(hh, content_type_val, rb_str_new(val, vlen));\n    } else if (sizeof(content_length) - 1 == klen && 0 == strncasecmp(key, content_length, sizeof(content_length) - 1)) {\n\trb_hash_aset(hh, content_length_val, rb_str_new(val, vlen));\n    } else {\n\tchar\t\thkey[1024];\n\tchar\t\t*k = hkey;\n\tvolatile VALUE\tsval = rb_str_new(val, vlen);\n\n\tstrcpy(hkey, \"HTTP_\");\n\tk = hkey + 5;\n\tif ((int)(sizeof(hkey) - 5) <= klen) {\n\t    klen = sizeof(hkey) - 6;\n\t}\n\tstrncpy(k, key, klen);\n\thkey[klen + 5] = '\\0';\n\n\t//rb_hash_aset(hh, rb_str_new(hkey, klen + 5), sval);\n\t// Contrary to the Rack spec, Rails expects all upper case keys so add those as well.\n\tfor (k = hkey + 5; '\\0' != *k; k++) {\n\t    if ('-' == *k) {\n\t\t*k = '_';\n\t    } else {\n\t\t*k = toupper(*k);\n\t    }\n\t}\n\trb_hash_aset(hh, rb_str_new(hkey, klen + 5), sval);\n    }\n}",
        "func": "static void\nadd_header_value(VALUE hh, const char *key, int klen, const char *val, int vlen) {\n    VALUE\tv;\n\n    if (sizeof(content_type) - 1 == klen && 0 == strncasecmp(key, content_type, sizeof(content_type) - 1)) {\n\tif (Qnil == (v = rb_hash_lookup2(hh, content_type_val, Qnil))) {\n\t    rb_hash_aset(hh, content_type_val, rb_str_new(val, vlen));\n\t} else {\n\t    volatile VALUE\ta = rb_ary_new();\n\n\t    rb_ary_push(a, v);\n\t    rb_ary_push(a, rb_str_new(val, vlen));\n\t    rb_hash_aset(hh, content_type_val, a);\n\t}\n    } else if (sizeof(content_length) - 1 == klen && 0 == strncasecmp(key, content_length, sizeof(content_length) - 1)) {\n\tif (Qnil == (v = rb_hash_lookup2(hh, content_length_val, Qnil))) {\n\t    rb_hash_aset(hh, content_length_val, rb_str_new(val, vlen));\n\t} else {\n\t    rb_raise(rb_eArgError, \"Multiple Content-Length headers.\");\n\t}\n    } else {\n\tchar\t\thkey[1024];\n\tchar\t\t*k = hkey;\n\tvolatile VALUE\tsval = rb_str_new(val, vlen);\n\tvolatile VALUE\tkval;\n\n\tstrcpy(hkey, \"HTTP_\");\n\tk = hkey + 5;\n\tif ((int)(sizeof(hkey) - 5) <= klen) {\n\t    klen = sizeof(hkey) - 6;\n\t}\n\tstrncpy(k, key, klen);\n\thkey[klen + 5] = '\\0';\n\n\t//rb_hash_aset(hh, rb_str_new(hkey, klen + 5), sval);\n\t// Contrary to the Rack spec, Rails expects all upper case keys so add those as well.\n\tfor (k = hkey + 5; '\\0' != *k; k++) {\n\t    if ('-' == *k) {\n\t\t*k = '_';\n\t    } else {\n\t\t*k = toupper(*k);\n\t    }\n\t}\n\tkval = rb_str_new(hkey, klen + 5);\n\tif (Qnil == (v = rb_hash_lookup2(hh, kval, Qnil))) {\n\t    rb_hash_aset(hh, kval, sval);\n\t} else {\n\t    volatile VALUE\ta = rb_ary_new();\n\n\t    rb_ary_push(a, v);\n\t    rb_ary_push(a, sval);\n\t    rb_hash_aset(hh, kval, a);\n\t}\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,13 +1,28 @@\n static void\n add_header_value(VALUE hh, const char *key, int klen, const char *val, int vlen) {\n+    VALUE\tv;\n+\n     if (sizeof(content_type) - 1 == klen && 0 == strncasecmp(key, content_type, sizeof(content_type) - 1)) {\n-\trb_hash_aset(hh, content_type_val, rb_str_new(val, vlen));\n+\tif (Qnil == (v = rb_hash_lookup2(hh, content_type_val, Qnil))) {\n+\t    rb_hash_aset(hh, content_type_val, rb_str_new(val, vlen));\n+\t} else {\n+\t    volatile VALUE\ta = rb_ary_new();\n+\n+\t    rb_ary_push(a, v);\n+\t    rb_ary_push(a, rb_str_new(val, vlen));\n+\t    rb_hash_aset(hh, content_type_val, a);\n+\t}\n     } else if (sizeof(content_length) - 1 == klen && 0 == strncasecmp(key, content_length, sizeof(content_length) - 1)) {\n-\trb_hash_aset(hh, content_length_val, rb_str_new(val, vlen));\n+\tif (Qnil == (v = rb_hash_lookup2(hh, content_length_val, Qnil))) {\n+\t    rb_hash_aset(hh, content_length_val, rb_str_new(val, vlen));\n+\t} else {\n+\t    rb_raise(rb_eArgError, \"Multiple Content-Length headers.\");\n+\t}\n     } else {\n \tchar\t\thkey[1024];\n \tchar\t\t*k = hkey;\n \tvolatile VALUE\tsval = rb_str_new(val, vlen);\n+\tvolatile VALUE\tkval;\n \n \tstrcpy(hkey, \"HTTP_\");\n \tk = hkey + 5;\n@@ -26,6 +41,15 @@\n \t\t*k = toupper(*k);\n \t    }\n \t}\n-\trb_hash_aset(hh, rb_str_new(hkey, klen + 5), sval);\n+\tkval = rb_str_new(hkey, klen + 5);\n+\tif (Qnil == (v = rb_hash_lookup2(hh, kval, Qnil))) {\n+\t    rb_hash_aset(hh, kval, sval);\n+\t} else {\n+\t    volatile VALUE\ta = rb_ary_new();\n+\n+\t    rb_ary_push(a, v);\n+\t    rb_ary_push(a, sval);\n+\t    rb_hash_aset(hh, kval, a);\n+\t}\n     }\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\trb_hash_aset(hh, content_type_val, rb_str_new(val, vlen));",
                "\trb_hash_aset(hh, content_length_val, rb_str_new(val, vlen));",
                "\trb_hash_aset(hh, rb_str_new(hkey, klen + 5), sval);"
            ],
            "added_lines": [
                "    VALUE\tv;",
                "",
                "\tif (Qnil == (v = rb_hash_lookup2(hh, content_type_val, Qnil))) {",
                "\t    rb_hash_aset(hh, content_type_val, rb_str_new(val, vlen));",
                "\t} else {",
                "\t    volatile VALUE\ta = rb_ary_new();",
                "",
                "\t    rb_ary_push(a, v);",
                "\t    rb_ary_push(a, rb_str_new(val, vlen));",
                "\t    rb_hash_aset(hh, content_type_val, a);",
                "\t}",
                "\tif (Qnil == (v = rb_hash_lookup2(hh, content_length_val, Qnil))) {",
                "\t    rb_hash_aset(hh, content_length_val, rb_str_new(val, vlen));",
                "\t} else {",
                "\t    rb_raise(rb_eArgError, \"Multiple Content-Length headers.\");",
                "\t}",
                "\tvolatile VALUE\tkval;",
                "\tkval = rb_str_new(hkey, klen + 5);",
                "\tif (Qnil == (v = rb_hash_lookup2(hh, kval, Qnil))) {",
                "\t    rb_hash_aset(hh, kval, sval);",
                "\t} else {",
                "\t    volatile VALUE\ta = rb_ary_new();",
                "",
                "\t    rb_ary_push(a, v);",
                "\t    rb_ary_push(a, sval);",
                "\t    rb_hash_aset(hh, kval, a);",
                "\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-7670",
        "func_name": "ohler55/agoo/request_init",
        "description": "agoo prior to 2.14.0 allows request smuggling attacks where agoo is used as a backend and a frontend proxy also being vulnerable. HTTP pipelining issues and request smuggling attacks might be possible due to incorrect Content-Length and Transfer encoding header parsing. It is possible to conduct HTTP request smuggling attacks where `agoo` is used as part of a chain of backend servers due to insufficient `Content-Length` and `Transfer Encoding` parsing.",
        "git_url": "https://github.com/ohler55/agoo/commit/23d03535cf7b50d679a60a953a0cae9519a4a130",
        "commit_title": "Remote addr (#99)",
        "commit_text": " * REMOTE_ADDR added\r \r * Ready for merge",
        "func_before": "void\nrequest_init(VALUE mod) {\n    req_class = rb_define_class_under(mod, \"Request\", rb_cObject);\n\n    rb_define_method(req_class, \"to_s\", to_s, 0);\n    rb_define_method(req_class, \"to_h\", to_h, 0);\n    rb_define_method(req_class, \"environment\", to_h, 0);\n    rb_define_method(req_class, \"env\", to_h, 0);\n    rb_define_method(req_class, \"request_method\", method, 0);\n    rb_define_method(req_class, \"script_name\", script_name, 0);\n    rb_define_method(req_class, \"path_info\", path_info, 0);\n    rb_define_method(req_class, \"query_string\", query_string, 0);\n    rb_define_method(req_class, \"server_name\", server_name, 0);\n    rb_define_method(req_class, \"server_port\", server_port, 0);\n    rb_define_method(req_class, \"rack_version\", rack_version, 0);\n    rb_define_method(req_class, \"rack_url_scheme\", rack_url_scheme, 0);\n    rb_define_method(req_class, \"rack_input\", rack_input, 0);\n    rb_define_method(req_class, \"rack_errors\", rack_errors, 0);\n    rb_define_method(req_class, \"rack_multithread\", rack_multithread, 0);\n    rb_define_method(req_class, \"rack_multiprocess\", rack_multiprocess, 0);\n    rb_define_method(req_class, \"rack_run_once\", rack_run_once, 0);\n    rb_define_method(req_class, \"rack_upgrade?\", rack_upgrade, 0);\n    rb_define_method(req_class, \"headers\", headers, 0);\n    rb_define_method(req_class, \"body\", body, 0);\n    rb_define_method(req_class, \"rack_logger\", rack_logger, 0);\n    rb_define_method(req_class, \"call\", call, 0);\n\n    new_id = rb_intern(\"new\");\n\n    rack_version_val_val = rb_ary_new();\n    rb_ary_push(rack_version_val_val, INT2NUM(1));\n    rb_ary_push(rack_version_val_val, INT2NUM(3));\n    rb_gc_register_address(&rack_version_val_val);\n\n    stringio_class = rb_const_get(rb_cObject, rb_intern(\"StringIO\"));\n\n    connect_val = rb_str_new_cstr(\"CONNECT\");\t\t\trb_gc_register_address(&connect_val);\n    content_length_val = rb_str_new_cstr(\"CONTENT_LENGTH\");\trb_gc_register_address(&content_length_val);\n    content_type_val = rb_str_new_cstr(\"CONTENT_TYPE\");\t\trb_gc_register_address(&content_type_val);\n    delete_val = rb_str_new_cstr(\"DELETE\");\t\t\trb_gc_register_address(&delete_val);\n    early_hints_val = rb_str_new_cstr(\"early_hints\");\t\trb_gc_register_address(&early_hints_val);\n    empty_val = rb_str_new_cstr(\"\");\t\t\t\trb_gc_register_address(&empty_val);\n    get_val = rb_str_new_cstr(\"GET\");\t\t\t\trb_gc_register_address(&get_val);\n    head_val = rb_str_new_cstr(\"HEAD\");\t\t\t\trb_gc_register_address(&head_val);\n    http_val = rb_str_new_cstr(\"http\");\t\t\t\trb_gc_register_address(&http_val);\n    https_val = rb_str_new_cstr(\"https\");\t\t\trb_gc_register_address(&https_val);\n    options_val = rb_str_new_cstr(\"OPTIONS\");\t\t\trb_gc_register_address(&options_val);\n    patch_val = rb_str_new_cstr(\"PATCH\");\t\t\trb_gc_register_address(&patch_val);\n    path_info_val = rb_str_new_cstr(\"PATH_INFO\");\t\trb_gc_register_address(&path_info_val);\n    post_val = rb_str_new_cstr(\"POST\");\t\t\t\trb_gc_register_address(&post_val);\n    put_val = rb_str_new_cstr(\"PUT\");\t\t\t\trb_gc_register_address(&put_val);\n    query_string_val = rb_str_new_cstr(\"QUERY_STRING\");\t\trb_gc_register_address(&query_string_val);\n    rack_errors_val = rb_str_new_cstr(\"rack.errors\");\t\trb_gc_register_address(&rack_errors_val);\n    rack_hijack_io_val = rb_str_new_cstr(\"rack.hijack_io\");\trb_gc_register_address(&rack_hijack_io_val);\n    rack_hijack_val = rb_str_new_cstr(\"rack.hijack\");\t\trb_gc_register_address(&rack_hijack_val);\n    rack_hijackq_val = rb_str_new_cstr(\"rack.hijack?\");\t\trb_gc_register_address(&rack_hijackq_val);\n    rack_input_val = rb_str_new_cstr(\"rack.input\");\t\trb_gc_register_address(&rack_input_val);\n    rack_logger_val = rb_str_new_cstr(\"rack.logger\");\t\trb_gc_register_address(&rack_logger_val);\n    rack_multiprocess_val = rb_str_new_cstr(\"rack.multiprocess\");rb_gc_register_address(&rack_multiprocess_val);\n    rack_multithread_val = rb_str_new_cstr(\"rack.multithread\");\trb_gc_register_address(&rack_multithread_val);\n    rack_run_once_val = rb_str_new_cstr(\"rack.run_once\");\trb_gc_register_address(&rack_run_once_val);\n    rack_upgrade_val = rb_str_new_cstr(\"rack.upgrade?\");\trb_gc_register_address(&rack_upgrade_val);\n    rack_url_scheme_val = rb_str_new_cstr(\"rack.url_scheme\");\trb_gc_register_address(&rack_url_scheme_val);\n    rack_version_val = rb_str_new_cstr(\"rack.version\");\t\trb_gc_register_address(&rack_version_val);\n    request_method_val = rb_str_new_cstr(\"REQUEST_METHOD\");\trb_gc_register_address(&request_method_val);\n    script_name_val = rb_str_new_cstr(\"SCRIPT_NAME\");\t\trb_gc_register_address(&script_name_val);\n    server_name_val = rb_str_new_cstr(\"SERVER_NAME\");\t\trb_gc_register_address(&server_name_val);\n    server_port_val = rb_str_new_cstr(\"SERVER_PORT\");\t\trb_gc_register_address(&server_port_val);\n    slash_val = rb_str_new_cstr(\"/\");\t\t\t\trb_gc_register_address(&slash_val);\n\n    sse_sym = ID2SYM(rb_intern(\"sse\"));\t\t\t\trb_gc_register_address(&sse_sym);\n    websocket_sym = ID2SYM(rb_intern(\"websocket\"));\t\trb_gc_register_address(&websocket_sym);\n}",
        "func": "void\nrequest_init(VALUE mod) {\n    req_class = rb_define_class_under(mod, \"Request\", rb_cObject);\n\n    rb_define_method(req_class, \"to_s\", to_s, 0);\n    rb_define_method(req_class, \"to_h\", to_h, 0);\n    rb_define_method(req_class, \"environment\", to_h, 0);\n    rb_define_method(req_class, \"env\", to_h, 0);\n    rb_define_method(req_class, \"request_method\", method, 0);\n    rb_define_method(req_class, \"script_name\", script_name, 0);\n    rb_define_method(req_class, \"path_info\", path_info, 0);\n    rb_define_method(req_class, \"query_string\", query_string, 0);\n    rb_define_method(req_class, \"server_name\", server_name, 0);\n    rb_define_method(req_class, \"server_port\", server_port, 0);\n    rb_define_method(req_class, \"remote_addr\", remote_addr, 0);\n    rb_define_method(req_class, \"rack_version\", rack_version, 0);\n    rb_define_method(req_class, \"rack_url_scheme\", rack_url_scheme, 0);\n    rb_define_method(req_class, \"rack_input\", rack_input, 0);\n    rb_define_method(req_class, \"rack_errors\", rack_errors, 0);\n    rb_define_method(req_class, \"rack_multithread\", rack_multithread, 0);\n    rb_define_method(req_class, \"rack_multiprocess\", rack_multiprocess, 0);\n    rb_define_method(req_class, \"rack_run_once\", rack_run_once, 0);\n    rb_define_method(req_class, \"rack_upgrade?\", rack_upgrade, 0);\n    rb_define_method(req_class, \"headers\", headers, 0);\n    rb_define_method(req_class, \"body\", body, 0);\n    rb_define_method(req_class, \"rack_logger\", rack_logger, 0);\n    rb_define_method(req_class, \"call\", call, 0);\n\n    new_id = rb_intern(\"new\");\n\n    rack_version_val_val = rb_ary_new();\n    rb_ary_push(rack_version_val_val, INT2NUM(1));\n    rb_ary_push(rack_version_val_val, INT2NUM(3));\n    rb_gc_register_address(&rack_version_val_val);\n\n    stringio_class = rb_const_get(rb_cObject, rb_intern(\"StringIO\"));\n\n    connect_val = rb_str_new_cstr(\"CONNECT\");\t\t\trb_gc_register_address(&connect_val);\n    content_length_val = rb_str_new_cstr(\"CONTENT_LENGTH\");\trb_gc_register_address(&content_length_val);\n    content_type_val = rb_str_new_cstr(\"CONTENT_TYPE\");\t\trb_gc_register_address(&content_type_val);\n    delete_val = rb_str_new_cstr(\"DELETE\");\t\t\trb_gc_register_address(&delete_val);\n    early_hints_val = rb_str_new_cstr(\"early_hints\");\t\trb_gc_register_address(&early_hints_val);\n    empty_val = rb_str_new_cstr(\"\");\t\t\t\trb_gc_register_address(&empty_val);\n    get_val = rb_str_new_cstr(\"GET\");\t\t\t\trb_gc_register_address(&get_val);\n    head_val = rb_str_new_cstr(\"HEAD\");\t\t\t\trb_gc_register_address(&head_val);\n    http_val = rb_str_new_cstr(\"http\");\t\t\t\trb_gc_register_address(&http_val);\n    https_val = rb_str_new_cstr(\"https\");\t\t\trb_gc_register_address(&https_val);\n    options_val = rb_str_new_cstr(\"OPTIONS\");\t\t\trb_gc_register_address(&options_val);\n    patch_val = rb_str_new_cstr(\"PATCH\");\t\t\trb_gc_register_address(&patch_val);\n    path_info_val = rb_str_new_cstr(\"PATH_INFO\");\t\trb_gc_register_address(&path_info_val);\n    post_val = rb_str_new_cstr(\"POST\");\t\t\t\trb_gc_register_address(&post_val);\n    put_val = rb_str_new_cstr(\"PUT\");\t\t\t\trb_gc_register_address(&put_val);\n    query_string_val = rb_str_new_cstr(\"QUERY_STRING\");\t\trb_gc_register_address(&query_string_val);\n    rack_errors_val = rb_str_new_cstr(\"rack.errors\");\t\trb_gc_register_address(&rack_errors_val);\n    rack_hijack_io_val = rb_str_new_cstr(\"rack.hijack_io\");\trb_gc_register_address(&rack_hijack_io_val);\n    rack_hijack_val = rb_str_new_cstr(\"rack.hijack\");\t\trb_gc_register_address(&rack_hijack_val);\n    rack_hijackq_val = rb_str_new_cstr(\"rack.hijack?\");\t\trb_gc_register_address(&rack_hijackq_val);\n    rack_input_val = rb_str_new_cstr(\"rack.input\");\t\trb_gc_register_address(&rack_input_val);\n    rack_logger_val = rb_str_new_cstr(\"rack.logger\");\t\trb_gc_register_address(&rack_logger_val);\n    rack_multiprocess_val = rb_str_new_cstr(\"rack.multiprocess\");rb_gc_register_address(&rack_multiprocess_val);\n    rack_multithread_val = rb_str_new_cstr(\"rack.multithread\");\trb_gc_register_address(&rack_multithread_val);\n    rack_run_once_val = rb_str_new_cstr(\"rack.run_once\");\trb_gc_register_address(&rack_run_once_val);\n    rack_upgrade_val = rb_str_new_cstr(\"rack.upgrade?\");\trb_gc_register_address(&rack_upgrade_val);\n    rack_url_scheme_val = rb_str_new_cstr(\"rack.url_scheme\");\trb_gc_register_address(&rack_url_scheme_val);\n    rack_version_val = rb_str_new_cstr(\"rack.version\");\t\trb_gc_register_address(&rack_version_val);\n    remote_addr_val = rb_str_new_cstr(\"REMOTE_ADDR\");\t\trb_gc_register_address(&remote_addr_val);\n    request_method_val = rb_str_new_cstr(\"REQUEST_METHOD\");\trb_gc_register_address(&request_method_val);\n    script_name_val = rb_str_new_cstr(\"SCRIPT_NAME\");\t\trb_gc_register_address(&script_name_val);\n    server_name_val = rb_str_new_cstr(\"SERVER_NAME\");\t\trb_gc_register_address(&server_name_val);\n    server_port_val = rb_str_new_cstr(\"SERVER_PORT\");\t\trb_gc_register_address(&server_port_val);\n    slash_val = rb_str_new_cstr(\"/\");\t\t\t\trb_gc_register_address(&slash_val);\n\n    sse_sym = ID2SYM(rb_intern(\"sse\"));\t\t\t\trb_gc_register_address(&sse_sym);\n    websocket_sym = ID2SYM(rb_intern(\"websocket\"));\t\trb_gc_register_address(&websocket_sym);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -12,6 +12,7 @@\n     rb_define_method(req_class, \"query_string\", query_string, 0);\n     rb_define_method(req_class, \"server_name\", server_name, 0);\n     rb_define_method(req_class, \"server_port\", server_port, 0);\n+    rb_define_method(req_class, \"remote_addr\", remote_addr, 0);\n     rb_define_method(req_class, \"rack_version\", rack_version, 0);\n     rb_define_method(req_class, \"rack_url_scheme\", rack_url_scheme, 0);\n     rb_define_method(req_class, \"rack_input\", rack_input, 0);\n@@ -62,6 +63,7 @@\n     rack_upgrade_val = rb_str_new_cstr(\"rack.upgrade?\");\trb_gc_register_address(&rack_upgrade_val);\n     rack_url_scheme_val = rb_str_new_cstr(\"rack.url_scheme\");\trb_gc_register_address(&rack_url_scheme_val);\n     rack_version_val = rb_str_new_cstr(\"rack.version\");\t\trb_gc_register_address(&rack_version_val);\n+    remote_addr_val = rb_str_new_cstr(\"REMOTE_ADDR\");\t\trb_gc_register_address(&remote_addr_val);\n     request_method_val = rb_str_new_cstr(\"REQUEST_METHOD\");\trb_gc_register_address(&request_method_val);\n     script_name_val = rb_str_new_cstr(\"SCRIPT_NAME\");\t\trb_gc_register_address(&script_name_val);\n     server_name_val = rb_str_new_cstr(\"SERVER_NAME\");\t\trb_gc_register_address(&server_name_val);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    rb_define_method(req_class, \"remote_addr\", remote_addr, 0);",
                "    remote_addr_val = rb_str_new_cstr(\"REMOTE_ADDR\");\t\trb_gc_register_address(&remote_addr_val);"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-7670",
        "func_name": "ohler55/agoo/listen_loop",
        "description": "agoo prior to 2.14.0 allows request smuggling attacks where agoo is used as a backend and a frontend proxy also being vulnerable. HTTP pipelining issues and request smuggling attacks might be possible due to incorrect Content-Length and Transfer encoding header parsing. It is possible to conduct HTTP request smuggling attacks where `agoo` is used as part of a chain of backend servers due to insufficient `Content-Length` and `Transfer Encoding` parsing.",
        "git_url": "https://github.com/ohler55/agoo/commit/23d03535cf7b50d679a60a953a0cae9519a4a130",
        "commit_title": "Remote addr (#99)",
        "commit_text": " * REMOTE_ADDR added\r \r * Ready for merge",
        "func_before": "static void*\nlisten_loop(void *x) {\n    int\t\t\toptval = 1;\n    struct pollfd\tpa[100];\n    struct pollfd\t*p;\n    struct _agooErr\terr = AGOO_ERR_INIT;\n    struct sockaddr_in\tclient_addr;\n    int\t\t\tclient_sock;\n    int\t\t\tpcnt = 0;\n    socklen_t\t\talen = 0;\n    agooCon\t\tcon;\n    int\t\t\ti;\n    uint64_t\t\tcnt = 0;\n    agooBind\t\tb;\n\n    for (b = agoo_server.binds, p = pa; NULL != b; b = b->next, p++, pcnt++) {\n\tp->fd = b->fd;\n\tp->events = POLLIN;\n\tp->revents = 0;\n    }\n    memset(&client_addr, 0, sizeof(client_addr));\n    atomic_fetch_add(&agoo_server.running, 1);\n    while (agoo_server.active) {\n\tif (0 > (i = poll(pa, pcnt, 200))) {\n\t    if (EAGAIN == errno) {\n\t\tcontinue;\n\t    }\n\t    agoo_log_cat(&agoo_error_cat, \"Server polling error. %s.\", strerror(errno));\n\t    // Either a signal or something bad like out of memory. Might as well exit.\n\t    break;\n\t}\n\tif (0 == i) { // nothing to read\n\t    continue;\n\t}\n\tfor (b = agoo_server.binds, p = pa; NULL != b; b = b->next, p++) {\n\t    if (0 != (p->revents & POLLIN)) {\n\t\tif (0 > (client_sock = accept(p->fd, (struct sockaddr*)&client_addr, &alen))) {\n\t\t    agoo_log_cat(&agoo_error_cat, \"Server with pid %d accept connection failed. %s.\", getpid(), strerror(errno));\n\t\t} else if (NULL == (con = agoo_con_create(&err, client_sock, ++cnt, b))) {\n\t\t    agoo_log_cat(&agoo_error_cat, \"Server with pid %d accept connection failed. %s.\", getpid(), err.msg);\n\t\t    close(client_sock);\n\t\t    cnt--;\n\t\t    agoo_err_clear(&err);\n\t\t} else {\n\t\t    int\tcon_cnt;\n#ifdef OSX_OS\n\t\t    setsockopt(client_sock, SOL_SOCKET, SO_NOSIGPIPE, &optval, sizeof(optval));\n#endif\n#ifdef PLATFORM_LINUX\n\t\t    setsockopt(client_sock, IPPROTO_TCP, TCP_QUICKACK, &optval, sizeof(optval));\n#endif\n\t\t    fcntl(client_sock, F_SETFL, O_NONBLOCK);\n\t\t    //fcntl(client_sock, F_SETFL, FNDELAY);\n\t\t    setsockopt(client_sock, SOL_SOCKET, SO_KEEPALIVE, &optval, sizeof(optval));\n\t\t    setsockopt(client_sock, IPPROTO_TCP, TCP_NODELAY, &optval, sizeof(optval));\n\t\t    agoo_log_cat(&agoo_con_cat, \"Server with pid %d accepted connection %llu on %s [%d]\",\n\t\t\t\t getpid(), (unsigned long long)cnt, b->id, con->sock);\n\n\t\t    con_cnt = atomic_fetch_add(&agoo_server.con_cnt, 1);\n\t\t    if (agoo_server.loop_max > agoo_server.loop_cnt && agoo_server.loop_cnt * LOOP_UP < con_cnt) {\n\t\t\tadd_con_loop();\n\t\t    }\n\t\t    agoo_queue_push(&agoo_server.con_queue, (void*)con);\n\t\t}\n\t    }\n\t    if (0 != (p->revents & (POLLERR | POLLHUP | POLLNVAL))) {\n\t\tif (0 != (p->revents & (POLLHUP | POLLNVAL))) {\n\t\t    agoo_log_cat(&agoo_error_cat, \"Agoo server with pid %d socket on %s closed.\", getpid(), b->id);\n\t\t} else {\n\t\t    agoo_log_cat(&agoo_error_cat, \"Agoo server with pid %d socket on %s error.\", getpid(), b->id);\n\t\t}\n\t\tagoo_server.active = false;\n\t    }\n\t    p->revents = 0;\n\t}\n    }\n    for (b = agoo_server.binds; NULL != b; b = b->next) {\n\tagoo_bind_close(b);\n    }\n    atomic_fetch_sub(&agoo_server.running, 1);\n\n    return NULL;\n}",
        "func": "static void*\nlisten_loop(void *x) {\n    int\t\t\toptval = 1;\n    struct pollfd\tpa[100];\n    struct pollfd\t*p;\n    struct _agooErr\terr = AGOO_ERR_INIT;\n    struct sockaddr_in\tclient_addr;\n    int\t\t\tclient_sock;\n    int\t\t\tpcnt = 0;\n    socklen_t\t\talen = 0;\n    agooCon\t\tcon;\n    int\t\t\ti;\n    uint64_t\t\tcnt = 0;\n    agooBind\t\tb;\n\n    for (b = agoo_server.binds, p = pa; NULL != b; b = b->next, p++, pcnt++) {\n\tp->fd = b->fd;\n\tp->events = POLLIN;\n\tp->revents = 0;\n    }\n    memset(&client_addr, 0, sizeof(client_addr));\n    atomic_fetch_add(&agoo_server.running, 1);\n    while (agoo_server.active) {\n\tif (0 > (i = poll(pa, pcnt, 200))) {\n\t    if (EAGAIN == errno) {\n\t\tcontinue;\n\t    }\n\t    agoo_log_cat(&agoo_error_cat, \"Server polling error. %s.\", strerror(errno));\n\t    // Either a signal or something bad like out of memory. Might as well exit.\n\t    break;\n\t}\n\tif (0 == i) { // nothing to read\n\t    continue;\n\t}\n\tfor (b = agoo_server.binds, p = pa; NULL != b; b = b->next, p++) {\n\t    if (0 != (p->revents & POLLIN)) {\n\t\tif (0 > (client_sock = accept(p->fd, (struct sockaddr*)&client_addr, &alen))) {\n\t\t    agoo_log_cat(&agoo_error_cat, \"Server with pid %d accept connection failed. %s.\", getpid(), strerror(errno));\n\t\t} else if (NULL == (con = agoo_con_create(&err, client_sock, ++cnt, b))) {\n\t\t    agoo_log_cat(&agoo_error_cat, \"Server with pid %d accept connection failed. %s.\", getpid(), err.msg);\n\t\t    close(client_sock);\n\t\t    cnt--;\n\t\t    agoo_err_clear(&err);\n\t\t} else {\n\t\t    int\tcon_cnt;\n#ifdef OSX_OS\n\t\t    setsockopt(client_sock, SOL_SOCKET, SO_NOSIGPIPE, &optval, sizeof(optval));\n#endif\n#ifdef PLATFORM_LINUX\n\t\t    setsockopt(client_sock, IPPROTO_TCP, TCP_QUICKACK, &optval, sizeof(optval));\n#endif\n\t\t    fcntl(client_sock, F_SETFL, O_NONBLOCK);\n\t\t    //fcntl(client_sock, F_SETFL, FNDELAY);\n\t\t    setsockopt(client_sock, SOL_SOCKET, SO_KEEPALIVE, &optval, sizeof(optval));\n\t\t    setsockopt(client_sock, IPPROTO_TCP, TCP_NODELAY, &optval, sizeof(optval));\n\t\t    agoo_log_cat(&agoo_con_cat, \"Server with pid %d accepted connection %llu on %s [%d] from %s\",\n\t\t\t\t getpid(), (unsigned long long)cnt, b->id, con->sock, con->remote);\n\n\t\t    con_cnt = atomic_fetch_add(&agoo_server.con_cnt, 1);\n\t\t    if (agoo_server.loop_max > agoo_server.loop_cnt && agoo_server.loop_cnt * LOOP_UP < con_cnt) {\n\t\t\tadd_con_loop();\n\t\t    }\n\t\t    agoo_queue_push(&agoo_server.con_queue, (void*)con);\n\t\t}\n\t    }\n\t    if (0 != (p->revents & (POLLERR | POLLHUP | POLLNVAL))) {\n\t\tif (0 != (p->revents & (POLLHUP | POLLNVAL))) {\n\t\t    agoo_log_cat(&agoo_error_cat, \"Agoo server with pid %d socket on %s closed.\", getpid(), b->id);\n\t\t} else {\n\t\t    agoo_log_cat(&agoo_error_cat, \"Agoo server with pid %d socket on %s error.\", getpid(), b->id);\n\t\t}\n\t\tagoo_server.active = false;\n\t    }\n\t    p->revents = 0;\n\t}\n    }\n    for (b = agoo_server.binds; NULL != b; b = b->next) {\n\tagoo_bind_close(b);\n    }\n    atomic_fetch_sub(&agoo_server.running, 1);\n\n    return NULL;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -53,8 +53,8 @@\n \t\t    //fcntl(client_sock, F_SETFL, FNDELAY);\n \t\t    setsockopt(client_sock, SOL_SOCKET, SO_KEEPALIVE, &optval, sizeof(optval));\n \t\t    setsockopt(client_sock, IPPROTO_TCP, TCP_NODELAY, &optval, sizeof(optval));\n-\t\t    agoo_log_cat(&agoo_con_cat, \"Server with pid %d accepted connection %llu on %s [%d]\",\n-\t\t\t\t getpid(), (unsigned long long)cnt, b->id, con->sock);\n+\t\t    agoo_log_cat(&agoo_con_cat, \"Server with pid %d accepted connection %llu on %s [%d] from %s\",\n+\t\t\t\t getpid(), (unsigned long long)cnt, b->id, con->sock, con->remote);\n \n \t\t    con_cnt = atomic_fetch_add(&agoo_server.con_cnt, 1);\n \t\t    if (agoo_server.loop_max > agoo_server.loop_cnt && agoo_server.loop_cnt * LOOP_UP < con_cnt) {",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t    agoo_log_cat(&agoo_con_cat, \"Server with pid %d accepted connection %llu on %s [%d]\",",
                "\t\t\t\t getpid(), (unsigned long long)cnt, b->id, con->sock);"
            ],
            "added_lines": [
                "\t\t    agoo_log_cat(&agoo_con_cat, \"Server with pid %d accepted connection %llu on %s [%d] from %s\",",
                "\t\t\t\t getpid(), (unsigned long long)cnt, b->id, con->sock, con->remote);"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-7670",
        "func_name": "ohler55/agoo/agoo_http_code_message",
        "description": "agoo prior to 2.14.0 allows request smuggling attacks where agoo is used as a backend and a frontend proxy also being vulnerable. HTTP pipelining issues and request smuggling attacks might be possible due to incorrect Content-Length and Transfer encoding header parsing. It is possible to conduct HTTP request smuggling attacks where `agoo` is used as part of a chain of backend servers due to insufficient `Content-Length` and `Transfer Encoding` parsing.",
        "git_url": "https://github.com/ohler55/agoo/commit/23d03535cf7b50d679a60a953a0cae9519a4a130",
        "commit_title": "Remote addr (#99)",
        "commit_text": " * REMOTE_ADDR added\r \r * Ready for merge",
        "func_before": "const char*\nagoo_http_code_message(int code) {\n    const char\t*msg = \"\";\n    \n    switch (code) {\n    case 100:\tmsg = \"Continue\";\t\t\t\tbreak;\n    case 101:\tmsg = \"Switching Protocols\";\t\t\tbreak;\n    case 102:\tmsg = \"Processing\";\t\t\t\tbreak;\n    case 200:\tmsg = \"OK\";\t\t\t\t\tbreak;\n    case 201:\tmsg = \"Created\";\t\t\t\tbreak;\n    case 202:\tmsg = \"Accepted\";\t\t\t\tbreak;\n    case 203:\tmsg = \"Non-authoritative Information\";\t\tbreak;\n    case 204:\tmsg = \"No Content\";\t\t\t\tbreak;\n    case 205:\tmsg = \"Reset Content\";\t\t\t\tbreak;\n    case 206:\tmsg = \"Partial Content\";\t\t\tbreak;\n    case 207:\tmsg = \"Multi-Status\";\t\t\t\tbreak;\n    case 208:\tmsg = \"Already Reported\";\t\t\tbreak;\n    case 226:\tmsg = \"IM Used\";\t\t\t\tbreak;\n    case 300:\tmsg = \"Multiple Choices\";\t\t\tbreak;\n    case 301:\tmsg = \"Moved Permanently\";\t\t\tbreak;\n    case 302:\tmsg = \"Found\";\t\t\t\t\tbreak;\n    case 303:\tmsg = \"See Other\";\t\t\t\tbreak;\n    case 304:\tmsg = \"Not Modified\";\t\t\t\tbreak;\n    case 305:\tmsg = \"Use Proxy\";\t\t\t\tbreak;\n    case 307:\tmsg = \"Temporary Redirect\";\t\t\tbreak;\n    case 308:\tmsg = \"Permanent Redirect\";\t\t\tbreak;\n    case 400:\tmsg = \"Bad Request\";\t\t\t\tbreak;\n    case 401:\tmsg = \"Unauthorized\";\t\t\t\tbreak;\n    case 402:\tmsg = \"Payment Required\";\t\t\tbreak;\n    case 403:\tmsg = \"Forbidden\";\t\t\t\tbreak;\n    case 404:\tmsg = \"Not Found\";\t\t\t\tbreak;\n    case 405:\tmsg = \"Method Not Allowed\";\t\t\tbreak;\n    case 406:\tmsg = \"Not Acceptable\";\t\t\t\tbreak;\n    case 407:\tmsg = \"Proxy Authentication Required\";\t\tbreak;\n    case 408:\tmsg = \"Request Timeout\";\t\t\tbreak;\n    case 409:\tmsg = \"Conflict\";\t\t\t\tbreak;\n    case 410:\tmsg = \"Gone\";\t\t\t\t\tbreak;\n    case 411:\tmsg = \"Length Required\";\t\t\tbreak;\n    case 412:\tmsg = \"Precondition Failed\";\t\t\tbreak;\n    case 413:\tmsg = \"Payload Too Large\";\t\t\tbreak;\n    case 414:\tmsg = \"Request-URI Too Long\";\t\t\tbreak;\n    case 415:\tmsg = \"Unsupported Media Type\";\t\t\tbreak;\n    case 416:\tmsg = \"Requested Range Not Satisfiable\";\tbreak;\n    case 417:\tmsg = \"Expectation Failed\";\t\t\tbreak;\n    case 418:\tmsg = \"I'm a teapot\";\t\t\t\tbreak;\n    case 421:\tmsg = \"Misdirected Request\";\t\t\tbreak;\n    case 422:\tmsg = \"Unprocessable Entity\";\t\t\tbreak;\n    case 423:\tmsg = \"Locked\";\t\t\t\t\tbreak;\n    case 424:\tmsg = \"Failed Dependency\";\t\t\tbreak;\n    case 426:\tmsg = \"Upgrade Required\";\t\t\tbreak;\n    case 428:\tmsg = \"Precondition Required\";\t\t\tbreak;\n    case 429:\tmsg = \"Too Many Requests\";\t\t\tbreak;\n    case 431:\tmsg = \"Request Header Fields Too Large\";\tbreak;\n    case 444:\tmsg = \"Connection Closed Without Response\";\tbreak;\n    case 451:\tmsg = \"Unavailable For Legal Reasons\";\t\tbreak;\n    case 499:\tmsg = \"Client Closed Request\";\t\t\tbreak;\n    case 500:\tmsg = \"Internal Server Error\";\t\t\tbreak;\n    case 501:\tmsg = \"Not Implemented\";\t\t\tbreak;\n    case 502:\tmsg = \"Bad Gateway\";\t\t\t\tbreak;\n    case 503:\tmsg = \"Service Unavailable\";\t\t\tbreak;\n    case 504:\tmsg = \"Gateway Timeout\";\t\t\tbreak;\n    case 505:\tmsg = \"HTTP Version Not Supported\";\t\tbreak;\n    case 506:\tmsg = \"Variant Also Negotiates\";\t\tbreak;\n    case 507:\tmsg = \"Insufficient Storage\";\t\t\tbreak;\n    case 508:\tmsg = \"Loop Detected\";\t\t\t\tbreak;\n    case 510:\tmsg = \"Not Extended\";\t\t\t\tbreak;\n    case 511:\tmsg = \"Network Authentication Required\";\tbreak;\n    case 599:\tmsg = \"Network Connect Timeout Error\";\t\tbreak;\n    default:\t\t\t\t\t\t\tbreak;\n    }\n    return msg;\n}",
        "func": "const char*\nagoo_http_code_message(int code) {\n    const char\t*msg = \"\";\n\n    switch (code) {\n    case 100:\tmsg = \"Continue\";\t\t\t\tbreak;\n    case 101:\tmsg = \"Switching Protocols\";\t\t\tbreak;\n    case 102:\tmsg = \"Processing\";\t\t\t\tbreak;\n    case 200:\tmsg = \"OK\";\t\t\t\t\tbreak;\n    case 201:\tmsg = \"Created\";\t\t\t\tbreak;\n    case 202:\tmsg = \"Accepted\";\t\t\t\tbreak;\n    case 203:\tmsg = \"Non-authoritative Information\";\t\tbreak;\n    case 204:\tmsg = \"No Content\";\t\t\t\tbreak;\n    case 205:\tmsg = \"Reset Content\";\t\t\t\tbreak;\n    case 206:\tmsg = \"Partial Content\";\t\t\tbreak;\n    case 207:\tmsg = \"Multi-Status\";\t\t\t\tbreak;\n    case 208:\tmsg = \"Already Reported\";\t\t\tbreak;\n    case 226:\tmsg = \"IM Used\";\t\t\t\tbreak;\n    case 300:\tmsg = \"Multiple Choices\";\t\t\tbreak;\n    case 301:\tmsg = \"Moved Permanently\";\t\t\tbreak;\n    case 302:\tmsg = \"Found\";\t\t\t\t\tbreak;\n    case 303:\tmsg = \"See Other\";\t\t\t\tbreak;\n    case 304:\tmsg = \"Not Modified\";\t\t\t\tbreak;\n    case 305:\tmsg = \"Use Proxy\";\t\t\t\tbreak;\n    case 307:\tmsg = \"Temporary Redirect\";\t\t\tbreak;\n    case 308:\tmsg = \"Permanent Redirect\";\t\t\tbreak;\n    case 400:\tmsg = \"Bad Request\";\t\t\t\tbreak;\n    case 401:\tmsg = \"Unauthorized\";\t\t\t\tbreak;\n    case 402:\tmsg = \"Payment Required\";\t\t\tbreak;\n    case 403:\tmsg = \"Forbidden\";\t\t\t\tbreak;\n    case 404:\tmsg = \"Not Found\";\t\t\t\tbreak;\n    case 405:\tmsg = \"Method Not Allowed\";\t\t\tbreak;\n    case 406:\tmsg = \"Not Acceptable\";\t\t\t\tbreak;\n    case 407:\tmsg = \"Proxy Authentication Required\";\t\tbreak;\n    case 408:\tmsg = \"Request Timeout\";\t\t\tbreak;\n    case 409:\tmsg = \"Conflict\";\t\t\t\tbreak;\n    case 410:\tmsg = \"Gone\";\t\t\t\t\tbreak;\n    case 411:\tmsg = \"Length Required\";\t\t\tbreak;\n    case 412:\tmsg = \"Precondition Failed\";\t\t\tbreak;\n    case 413:\tmsg = \"Payload Too Large\";\t\t\tbreak;\n    case 414:\tmsg = \"Request-URI Too Long\";\t\t\tbreak;\n    case 415:\tmsg = \"Unsupported Media Type\";\t\t\tbreak;\n    case 416:\tmsg = \"Requested Range Not Satisfiable\";\tbreak;\n    case 417:\tmsg = \"Expectation Failed\";\t\t\tbreak;\n    case 418:\tmsg = \"I'm a teapot\";\t\t\t\tbreak;\n    case 421:\tmsg = \"Misdirected Request\";\t\t\tbreak;\n    case 422:\tmsg = \"Unprocessable Entity\";\t\t\tbreak;\n    case 423:\tmsg = \"Locked\";\t\t\t\t\tbreak;\n    case 424:\tmsg = \"Failed Dependency\";\t\t\tbreak;\n    case 426:\tmsg = \"Upgrade Required\";\t\t\tbreak;\n    case 428:\tmsg = \"Precondition Required\";\t\t\tbreak;\n    case 429:\tmsg = \"Too Many Requests\";\t\t\tbreak;\n    case 431:\tmsg = \"Request Header Fields Too Large\";\tbreak;\n    case 444:\tmsg = \"Connection Closed Without Response\";\tbreak;\n    case 451:\tmsg = \"Unavailable For Legal Reasons\";\t\tbreak;\n    case 499:\tmsg = \"Client Closed Request\";\t\t\tbreak;\n    case 500:\tmsg = \"Internal Server Error\";\t\t\tbreak;\n    case 501:\tmsg = \"Not Implemented\";\t\t\tbreak;\n    case 502:\tmsg = \"Bad Gateway\";\t\t\t\tbreak;\n    case 503:\tmsg = \"Service Unavailable\";\t\t\tbreak;\n    case 504:\tmsg = \"Gateway Timeout\";\t\t\tbreak;\n    case 505:\tmsg = \"HTTP Version Not Supported\";\t\tbreak;\n    case 506:\tmsg = \"Variant Also Negotiates\";\t\tbreak;\n    case 507:\tmsg = \"Insufficient Storage\";\t\t\tbreak;\n    case 508:\tmsg = \"Loop Detected\";\t\t\t\tbreak;\n    case 510:\tmsg = \"Not Extended\";\t\t\t\tbreak;\n    case 511:\tmsg = \"Network Authentication Required\";\tbreak;\n    case 599:\tmsg = \"Network Connect Timeout Error\";\t\tbreak;\n    default:\t\t\t\t\t\t\tbreak;\n    }\n    return msg;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,7 +1,7 @@\n const char*\n agoo_http_code_message(int code) {\n     const char\t*msg = \"\";\n-    \n+\n     switch (code) {\n     case 100:\tmsg = \"Continue\";\t\t\t\tbreak;\n     case 101:\tmsg = \"Switching Protocols\";\t\t\tbreak;",
        "diff_line_info": {
            "deleted_lines": [
                "    "
            ],
            "added_lines": [
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2020-7670",
        "func_name": "ohler55/agoo/key_set",
        "description": "agoo prior to 2.14.0 allows request smuggling attacks where agoo is used as a backend and a frontend proxy also being vulnerable. HTTP pipelining issues and request smuggling attacks might be possible due to incorrect Content-Length and Transfer encoding header parsing. It is possible to conduct HTTP request smuggling attacks where `agoo` is used as part of a chain of backend servers due to insufficient `Content-Length` and `Transfer Encoding` parsing.",
        "git_url": "https://github.com/ohler55/agoo/commit/23d03535cf7b50d679a60a953a0cae9519a4a130",
        "commit_title": "Remote addr (#99)",
        "commit_text": " * REMOTE_ADDR added\r \r * Ready for merge",
        "func_before": "static void\nkey_set(const char *key) {\n    int\t\tlen = (int)strlen(key);\n    int64_t\th = calc_hash(key, &len);\n    Slot\t*bucket = get_bucketp(h);\n    Slot\ts;\n    \n    if (NULL != (s = (Slot)AGOO_MALLOC(sizeof(struct _slot)))) {\n\ts->hash = h;\n\ts->klen = len;\n\ts->key = key;\n\ts->next = *bucket;\n\t*bucket = s;\n    }\n}",
        "func": "static void\nkey_set(const char *key) {\n    int\t\tlen = (int)strlen(key);\n    int64_t\th = calc_hash(key, &len);\n    Slot\t*bucket = get_bucketp(h);\n    Slot\ts;\n\n    if (NULL != (s = (Slot)AGOO_MALLOC(sizeof(struct _slot)))) {\n\ts->hash = h;\n\ts->klen = len;\n\ts->key = key;\n\ts->next = *bucket;\n\t*bucket = s;\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,7 +4,7 @@\n     int64_t\th = calc_hash(key, &len);\n     Slot\t*bucket = get_bucketp(h);\n     Slot\ts;\n-    \n+\n     if (NULL != (s = (Slot)AGOO_MALLOC(sizeof(struct _slot)))) {\n \ts->hash = h;\n \ts->klen = len;",
        "diff_line_info": {
            "deleted_lines": [
                "    "
            ],
            "added_lines": [
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2020-7670",
        "func_name": "ohler55/agoo/agoo_http_init",
        "description": "agoo prior to 2.14.0 allows request smuggling attacks where agoo is used as a backend and a frontend proxy also being vulnerable. HTTP pipelining issues and request smuggling attacks might be possible due to incorrect Content-Length and Transfer encoding header parsing. It is possible to conduct HTTP request smuggling attacks where `agoo` is used as part of a chain of backend servers due to insufficient `Content-Length` and `Transfer Encoding` parsing.",
        "git_url": "https://github.com/ohler55/agoo/commit/23d03535cf7b50d679a60a953a0cae9519a4a130",
        "commit_title": "Remote addr (#99)",
        "commit_text": " * REMOTE_ADDR added\r \r * Ready for merge",
        "func_before": "void\nagoo_http_init() {\n    const char\t**kp = header_keys;\n    \n    memset(&key_cache, 0, sizeof(struct _cache));\n    for (; NULL != *kp; kp++) {\n\tkey_set(*kp);\n    }\n}",
        "func": "void\nagoo_http_init() {\n    const char\t**kp = header_keys;\n\n    memset(&key_cache, 0, sizeof(struct _cache));\n    for (; NULL != *kp; kp++) {\n\tkey_set(*kp);\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,7 +1,7 @@\n void\n agoo_http_init() {\n     const char\t**kp = header_keys;\n-    \n+\n     memset(&key_cache, 0, sizeof(struct _cache));\n     for (; NULL != *kp; kp++) {\n \tkey_set(*kp);",
        "diff_line_info": {
            "deleted_lines": [
                "    "
            ],
            "added_lines": [
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2020-7670",
        "func_name": "ohler55/agoo/agoo_ws_create_req",
        "description": "agoo prior to 2.14.0 allows request smuggling attacks where agoo is used as a backend and a frontend proxy also being vulnerable. HTTP pipelining issues and request smuggling attacks might be possible due to incorrect Content-Length and Transfer encoding header parsing. It is possible to conduct HTTP request smuggling attacks where `agoo` is used as part of a chain of backend servers due to insufficient `Content-Length` and `Transfer Encoding` parsing.",
        "git_url": "https://github.com/ohler55/agoo/commit/23d03535cf7b50d679a60a953a0cae9519a4a130",
        "commit_title": "Remote addr (#99)",
        "commit_text": " * REMOTE_ADDR added\r \r * Ready for merge",
        "func_before": "bool\nagoo_ws_create_req(agooCon c, long mlen) {\n    uint8_t\top = 0x0F & *c->buf;\n\n    if (NULL == (c->req = agoo_req_create(mlen))) {\n\tagoo_log_cat(&agoo_error_cat, \"Out of memory attempting to allocate request.\");\n\treturn true;\n    }\n    if (NULL == c->up || agoo_server.ctx_nil_value == c->up->ctx) {\n\treturn true;\n    }\n    memset(c->req, 0, sizeof(struct _agooReq));\n    if ((long)c->bcnt <= mlen) {\n\tmemcpy(c->req->msg, c->buf, c->bcnt);\n\tif ((long)c->bcnt < mlen) {\n\t    memset(c->req->msg + c->bcnt, 0, mlen - c->bcnt);\n\t}\n    } else {\n\tmemcpy(c->req->msg, c->buf, mlen);\n    }\n    c->req->msg[mlen] = '\\0';\n    c->req->mlen = mlen;\n    c->req->method = (AGOO_WS_OP_BIN == op) ? AGOO_ON_BIN : AGOO_ON_MSG;\n    c->req->upgrade = AGOO_UP_NONE;\n    c->req->up = c->up;\n    c->req->res = NULL;\n    if (c->up->on_msg) {\n\tc->req->hook = agoo_hook_create(AGOO_NONE, NULL, c->up->ctx, PUSH_HOOK, &agoo_server.eval_queue);\n    }\n    return false;\n}",
        "func": "bool\nagoo_ws_create_req(agooCon c, long mlen) {\n    uint8_t\top = 0x0F & *c->buf;\n\n    if (NULL == (c->req = agoo_req_create(mlen))) {\n\tagoo_log_cat(&agoo_error_cat, \"Out of memory attempting to allocate request.\");\n\treturn true;\n    }\n    if (NULL == c->up || agoo_server.ctx_nil_value == c->up->ctx) {\n\treturn true;\n    }\n    memset(c->req, 0, sizeof(struct _agooReq));\n    if ((long)c->bcnt <= mlen) {\n\tmemcpy(c->req->msg, c->buf, c->bcnt);\n\tif ((long)c->bcnt < mlen) {\n\t    memset(c->req->msg + c->bcnt, 0, mlen - c->bcnt);\n\t}\n    } else {\n\tmemcpy(c->req->msg, c->buf, mlen);\n    }\n    c->req->msg[mlen] = '\\0';\n    c->req->mlen = mlen;\n    c->req->method = (AGOO_WS_OP_BIN == op) ? AGOO_ON_BIN : AGOO_ON_MSG;\n    c->req->upgrade = AGOO_UP_NONE;\n    c->req->up = c->up;\n    memcpy(c->req->remote, c->remote, sizeof(c->remote));\n    c->req->res = NULL;\n    if (c->up->on_msg) {\n\tc->req->hook = agoo_hook_create(AGOO_NONE, NULL, c->up->ctx, PUSH_HOOK, &agoo_server.eval_queue);\n    }\n    return false;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -23,6 +23,7 @@\n     c->req->method = (AGOO_WS_OP_BIN == op) ? AGOO_ON_BIN : AGOO_ON_MSG;\n     c->req->upgrade = AGOO_UP_NONE;\n     c->req->up = c->up;\n+    memcpy(c->req->remote, c->remote, sizeof(c->remote));\n     c->req->res = NULL;\n     if (c->up->on_msg) {\n \tc->req->hook = agoo_hook_create(AGOO_NONE, NULL, c->up->ctx, PUSH_HOOK, &agoo_server.eval_queue);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    memcpy(c->req->remote, c->remote, sizeof(c->remote));"
            ]
        }
    }
]