[
    {
        "cve_id": "CVE-2019-15903",
        "func_name": "libexpat/externalParEntProcessor",
        "description": "In libexpat before 2.2.8, crafted XML input could fool the parser into changing from DTD parsing to document parsing too early; a consecutive call to XML_GetCurrentLineNumber (or XML_GetCurrentColumnNumber) then resulted in a heap-based buffer over-read.",
        "git_url": "https://github.com/libexpat/libexpat/commit/c20b758c332d9a13afbbb276d30db1d183a85d43",
        "commit_title": "xmlparse.c: Deny internal entities closing the doctype",
        "commit_text": "",
        "func_before": "static enum XML_Error PTRCALL\nexternalParEntProcessor(XML_Parser parser, const char *s, const char *end,\n                        const char **nextPtr) {\n  const char *next = s;\n  int tok;\n\n  tok = XmlPrologTok(parser->m_encoding, s, end, &next);\n  if (tok <= 0) {\n    if (! parser->m_parsingStatus.finalBuffer && tok != XML_TOK_INVALID) {\n      *nextPtr = s;\n      return XML_ERROR_NONE;\n    }\n    switch (tok) {\n    case XML_TOK_INVALID:\n      return XML_ERROR_INVALID_TOKEN;\n    case XML_TOK_PARTIAL:\n      return XML_ERROR_UNCLOSED_TOKEN;\n    case XML_TOK_PARTIAL_CHAR:\n      return XML_ERROR_PARTIAL_CHAR;\n    case XML_TOK_NONE: /* start == end */\n    default:\n      break;\n    }\n  }\n  /* This would cause the next stage, i.e. doProlog to be passed XML_TOK_BOM.\n     However, when parsing an external subset, doProlog will not accept a BOM\n     as valid, and report a syntax error, so we have to skip the BOM\n  */\n  else if (tok == XML_TOK_BOM) {\n    s = next;\n    tok = XmlPrologTok(parser->m_encoding, s, end, &next);\n  }\n\n  parser->m_processor = prologProcessor;\n  return doProlog(parser, parser->m_encoding, s, end, tok, next, nextPtr,\n                  (XML_Bool)! parser->m_parsingStatus.finalBuffer);\n}",
        "func": "static enum XML_Error PTRCALL\nexternalParEntProcessor(XML_Parser parser, const char *s, const char *end,\n                        const char **nextPtr) {\n  const char *next = s;\n  int tok;\n\n  tok = XmlPrologTok(parser->m_encoding, s, end, &next);\n  if (tok <= 0) {\n    if (! parser->m_parsingStatus.finalBuffer && tok != XML_TOK_INVALID) {\n      *nextPtr = s;\n      return XML_ERROR_NONE;\n    }\n    switch (tok) {\n    case XML_TOK_INVALID:\n      return XML_ERROR_INVALID_TOKEN;\n    case XML_TOK_PARTIAL:\n      return XML_ERROR_UNCLOSED_TOKEN;\n    case XML_TOK_PARTIAL_CHAR:\n      return XML_ERROR_PARTIAL_CHAR;\n    case XML_TOK_NONE: /* start == end */\n    default:\n      break;\n    }\n  }\n  /* This would cause the next stage, i.e. doProlog to be passed XML_TOK_BOM.\n     However, when parsing an external subset, doProlog will not accept a BOM\n     as valid, and report a syntax error, so we have to skip the BOM\n  */\n  else if (tok == XML_TOK_BOM) {\n    s = next;\n    tok = XmlPrologTok(parser->m_encoding, s, end, &next);\n  }\n\n  parser->m_processor = prologProcessor;\n  return doProlog(parser, parser->m_encoding, s, end, tok, next, nextPtr,\n                  (XML_Bool)! parser->m_parsingStatus.finalBuffer, XML_TRUE);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -33,5 +33,5 @@\n \n   parser->m_processor = prologProcessor;\n   return doProlog(parser, parser->m_encoding, s, end, tok, next, nextPtr,\n-                  (XML_Bool)! parser->m_parsingStatus.finalBuffer);\n+                  (XML_Bool)! parser->m_parsingStatus.finalBuffer, XML_TRUE);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "                  (XML_Bool)! parser->m_parsingStatus.finalBuffer);"
            ],
            "added_lines": [
                "                  (XML_Bool)! parser->m_parsingStatus.finalBuffer, XML_TRUE);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-15903",
        "func_name": "libexpat/internalEntityProcessor",
        "description": "In libexpat before 2.2.8, crafted XML input could fool the parser into changing from DTD parsing to document parsing too early; a consecutive call to XML_GetCurrentLineNumber (or XML_GetCurrentColumnNumber) then resulted in a heap-based buffer over-read.",
        "git_url": "https://github.com/libexpat/libexpat/commit/c20b758c332d9a13afbbb276d30db1d183a85d43",
        "commit_title": "xmlparse.c: Deny internal entities closing the doctype",
        "commit_text": "",
        "func_before": "static enum XML_Error PTRCALL\ninternalEntityProcessor(XML_Parser parser, const char *s, const char *end,\n                        const char **nextPtr) {\n  ENTITY *entity;\n  const char *textStart, *textEnd;\n  const char *next;\n  enum XML_Error result;\n  OPEN_INTERNAL_ENTITY *openEntity = parser->m_openInternalEntities;\n  if (! openEntity)\n    return XML_ERROR_UNEXPECTED_STATE;\n\n  entity = openEntity->entity;\n  textStart = ((char *)entity->textPtr) + entity->processed;\n  textEnd = (char *)(entity->textPtr + entity->textLen);\n  /* Set a safe default value in case 'next' does not get set */\n  next = textStart;\n\n#ifdef XML_DTD\n  if (entity->is_param) {\n    int tok\n        = XmlPrologTok(parser->m_internalEncoding, textStart, textEnd, &next);\n    result = doProlog(parser, parser->m_internalEncoding, textStart, textEnd,\n                      tok, next, &next, XML_FALSE);\n  } else\n#endif /* XML_DTD */\n    result = doContent(parser, openEntity->startTagLevel,\n                       parser->m_internalEncoding, textStart, textEnd, &next,\n                       XML_FALSE);\n\n  if (result != XML_ERROR_NONE)\n    return result;\n  else if (textEnd != next\n           && parser->m_parsingStatus.parsing == XML_SUSPENDED) {\n    entity->processed = (int)(next - (char *)entity->textPtr);\n    return result;\n  } else {\n    entity->open = XML_FALSE;\n    parser->m_openInternalEntities = openEntity->next;\n    /* put openEntity back in list of free instances */\n    openEntity->next = parser->m_freeInternalEntities;\n    parser->m_freeInternalEntities = openEntity;\n  }\n\n#ifdef XML_DTD\n  if (entity->is_param) {\n    int tok;\n    parser->m_processor = prologProcessor;\n    tok = XmlPrologTok(parser->m_encoding, s, end, &next);\n    return doProlog(parser, parser->m_encoding, s, end, tok, next, nextPtr,\n                    (XML_Bool)! parser->m_parsingStatus.finalBuffer);\n  } else\n#endif /* XML_DTD */\n  {\n    parser->m_processor = contentProcessor;\n    /* see externalEntityContentProcessor vs contentProcessor */\n    return doContent(parser, parser->m_parentParser ? 1 : 0, parser->m_encoding,\n                     s, end, nextPtr,\n                     (XML_Bool)! parser->m_parsingStatus.finalBuffer);\n  }\n}",
        "func": "static enum XML_Error PTRCALL\ninternalEntityProcessor(XML_Parser parser, const char *s, const char *end,\n                        const char **nextPtr) {\n  ENTITY *entity;\n  const char *textStart, *textEnd;\n  const char *next;\n  enum XML_Error result;\n  OPEN_INTERNAL_ENTITY *openEntity = parser->m_openInternalEntities;\n  if (! openEntity)\n    return XML_ERROR_UNEXPECTED_STATE;\n\n  entity = openEntity->entity;\n  textStart = ((char *)entity->textPtr) + entity->processed;\n  textEnd = (char *)(entity->textPtr + entity->textLen);\n  /* Set a safe default value in case 'next' does not get set */\n  next = textStart;\n\n#ifdef XML_DTD\n  if (entity->is_param) {\n    int tok\n        = XmlPrologTok(parser->m_internalEncoding, textStart, textEnd, &next);\n    result = doProlog(parser, parser->m_internalEncoding, textStart, textEnd,\n                      tok, next, &next, XML_FALSE, XML_TRUE);\n  } else\n#endif /* XML_DTD */\n    result = doContent(parser, openEntity->startTagLevel,\n                       parser->m_internalEncoding, textStart, textEnd, &next,\n                       XML_FALSE);\n\n  if (result != XML_ERROR_NONE)\n    return result;\n  else if (textEnd != next\n           && parser->m_parsingStatus.parsing == XML_SUSPENDED) {\n    entity->processed = (int)(next - (char *)entity->textPtr);\n    return result;\n  } else {\n    entity->open = XML_FALSE;\n    parser->m_openInternalEntities = openEntity->next;\n    /* put openEntity back in list of free instances */\n    openEntity->next = parser->m_freeInternalEntities;\n    parser->m_freeInternalEntities = openEntity;\n  }\n\n#ifdef XML_DTD\n  if (entity->is_param) {\n    int tok;\n    parser->m_processor = prologProcessor;\n    tok = XmlPrologTok(parser->m_encoding, s, end, &next);\n    return doProlog(parser, parser->m_encoding, s, end, tok, next, nextPtr,\n                    (XML_Bool)! parser->m_parsingStatus.finalBuffer, XML_TRUE);\n  } else\n#endif /* XML_DTD */\n  {\n    parser->m_processor = contentProcessor;\n    /* see externalEntityContentProcessor vs contentProcessor */\n    return doContent(parser, parser->m_parentParser ? 1 : 0, parser->m_encoding,\n                     s, end, nextPtr,\n                     (XML_Bool)! parser->m_parsingStatus.finalBuffer);\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -20,7 +20,7 @@\n     int tok\n         = XmlPrologTok(parser->m_internalEncoding, textStart, textEnd, &next);\n     result = doProlog(parser, parser->m_internalEncoding, textStart, textEnd,\n-                      tok, next, &next, XML_FALSE);\n+                      tok, next, &next, XML_FALSE, XML_TRUE);\n   } else\n #endif /* XML_DTD */\n     result = doContent(parser, openEntity->startTagLevel,\n@@ -47,7 +47,7 @@\n     parser->m_processor = prologProcessor;\n     tok = XmlPrologTok(parser->m_encoding, s, end, &next);\n     return doProlog(parser, parser->m_encoding, s, end, tok, next, nextPtr,\n-                    (XML_Bool)! parser->m_parsingStatus.finalBuffer);\n+                    (XML_Bool)! parser->m_parsingStatus.finalBuffer, XML_TRUE);\n   } else\n #endif /* XML_DTD */\n   {",
        "diff_line_info": {
            "deleted_lines": [
                "                      tok, next, &next, XML_FALSE);",
                "                    (XML_Bool)! parser->m_parsingStatus.finalBuffer);"
            ],
            "added_lines": [
                "                      tok, next, &next, XML_FALSE, XML_TRUE);",
                "                    (XML_Bool)! parser->m_parsingStatus.finalBuffer, XML_TRUE);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-15903",
        "func_name": "libexpat/processInternalEntity",
        "description": "In libexpat before 2.2.8, crafted XML input could fool the parser into changing from DTD parsing to document parsing too early; a consecutive call to XML_GetCurrentLineNumber (or XML_GetCurrentColumnNumber) then resulted in a heap-based buffer over-read.",
        "git_url": "https://github.com/libexpat/libexpat/commit/c20b758c332d9a13afbbb276d30db1d183a85d43",
        "commit_title": "xmlparse.c: Deny internal entities closing the doctype",
        "commit_text": "",
        "func_before": "static enum XML_Error\nprocessInternalEntity(XML_Parser parser, ENTITY *entity, XML_Bool betweenDecl) {\n  const char *textStart, *textEnd;\n  const char *next;\n  enum XML_Error result;\n  OPEN_INTERNAL_ENTITY *openEntity;\n\n  if (parser->m_freeInternalEntities) {\n    openEntity = parser->m_freeInternalEntities;\n    parser->m_freeInternalEntities = openEntity->next;\n  } else {\n    openEntity\n        = (OPEN_INTERNAL_ENTITY *)MALLOC(parser, sizeof(OPEN_INTERNAL_ENTITY));\n    if (! openEntity)\n      return XML_ERROR_NO_MEMORY;\n  }\n  entity->open = XML_TRUE;\n  entity->processed = 0;\n  openEntity->next = parser->m_openInternalEntities;\n  parser->m_openInternalEntities = openEntity;\n  openEntity->entity = entity;\n  openEntity->startTagLevel = parser->m_tagLevel;\n  openEntity->betweenDecl = betweenDecl;\n  openEntity->internalEventPtr = NULL;\n  openEntity->internalEventEndPtr = NULL;\n  textStart = (char *)entity->textPtr;\n  textEnd = (char *)(entity->textPtr + entity->textLen);\n  /* Set a safe default value in case 'next' does not get set */\n  next = textStart;\n\n#ifdef XML_DTD\n  if (entity->is_param) {\n    int tok\n        = XmlPrologTok(parser->m_internalEncoding, textStart, textEnd, &next);\n    result = doProlog(parser, parser->m_internalEncoding, textStart, textEnd,\n                      tok, next, &next, XML_FALSE);\n  } else\n#endif /* XML_DTD */\n    result = doContent(parser, parser->m_tagLevel, parser->m_internalEncoding,\n                       textStart, textEnd, &next, XML_FALSE);\n\n  if (result == XML_ERROR_NONE) {\n    if (textEnd != next && parser->m_parsingStatus.parsing == XML_SUSPENDED) {\n      entity->processed = (int)(next - textStart);\n      parser->m_processor = internalEntityProcessor;\n    } else {\n      entity->open = XML_FALSE;\n      parser->m_openInternalEntities = openEntity->next;\n      /* put openEntity back in list of free instances */\n      openEntity->next = parser->m_freeInternalEntities;\n      parser->m_freeInternalEntities = openEntity;\n    }\n  }\n  return result;\n}",
        "func": "static enum XML_Error\nprocessInternalEntity(XML_Parser parser, ENTITY *entity, XML_Bool betweenDecl) {\n  const char *textStart, *textEnd;\n  const char *next;\n  enum XML_Error result;\n  OPEN_INTERNAL_ENTITY *openEntity;\n\n  if (parser->m_freeInternalEntities) {\n    openEntity = parser->m_freeInternalEntities;\n    parser->m_freeInternalEntities = openEntity->next;\n  } else {\n    openEntity\n        = (OPEN_INTERNAL_ENTITY *)MALLOC(parser, sizeof(OPEN_INTERNAL_ENTITY));\n    if (! openEntity)\n      return XML_ERROR_NO_MEMORY;\n  }\n  entity->open = XML_TRUE;\n  entity->processed = 0;\n  openEntity->next = parser->m_openInternalEntities;\n  parser->m_openInternalEntities = openEntity;\n  openEntity->entity = entity;\n  openEntity->startTagLevel = parser->m_tagLevel;\n  openEntity->betweenDecl = betweenDecl;\n  openEntity->internalEventPtr = NULL;\n  openEntity->internalEventEndPtr = NULL;\n  textStart = (char *)entity->textPtr;\n  textEnd = (char *)(entity->textPtr + entity->textLen);\n  /* Set a safe default value in case 'next' does not get set */\n  next = textStart;\n\n#ifdef XML_DTD\n  if (entity->is_param) {\n    int tok\n        = XmlPrologTok(parser->m_internalEncoding, textStart, textEnd, &next);\n    result = doProlog(parser, parser->m_internalEncoding, textStart, textEnd,\n                      tok, next, &next, XML_FALSE, XML_FALSE);\n  } else\n#endif /* XML_DTD */\n    result = doContent(parser, parser->m_tagLevel, parser->m_internalEncoding,\n                       textStart, textEnd, &next, XML_FALSE);\n\n  if (result == XML_ERROR_NONE) {\n    if (textEnd != next && parser->m_parsingStatus.parsing == XML_SUSPENDED) {\n      entity->processed = (int)(next - textStart);\n      parser->m_processor = internalEntityProcessor;\n    } else {\n      entity->open = XML_FALSE;\n      parser->m_openInternalEntities = openEntity->next;\n      /* put openEntity back in list of free instances */\n      openEntity->next = parser->m_freeInternalEntities;\n      parser->m_freeInternalEntities = openEntity;\n    }\n  }\n  return result;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -33,7 +33,7 @@\n     int tok\n         = XmlPrologTok(parser->m_internalEncoding, textStart, textEnd, &next);\n     result = doProlog(parser, parser->m_internalEncoding, textStart, textEnd,\n-                      tok, next, &next, XML_FALSE);\n+                      tok, next, &next, XML_FALSE, XML_FALSE);\n   } else\n #endif /* XML_DTD */\n     result = doContent(parser, parser->m_tagLevel, parser->m_internalEncoding,",
        "diff_line_info": {
            "deleted_lines": [
                "                      tok, next, &next, XML_FALSE);"
            ],
            "added_lines": [
                "                      tok, next, &next, XML_FALSE, XML_FALSE);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-15903",
        "func_name": "libexpat/prologProcessor",
        "description": "In libexpat before 2.2.8, crafted XML input could fool the parser into changing from DTD parsing to document parsing too early; a consecutive call to XML_GetCurrentLineNumber (or XML_GetCurrentColumnNumber) then resulted in a heap-based buffer over-read.",
        "git_url": "https://github.com/libexpat/libexpat/commit/c20b758c332d9a13afbbb276d30db1d183a85d43",
        "commit_title": "xmlparse.c: Deny internal entities closing the doctype",
        "commit_text": "",
        "func_before": "static enum XML_Error PTRCALL\nprologProcessor(XML_Parser parser, const char *s, const char *end,\n                const char **nextPtr) {\n  const char *next = s;\n  int tok = XmlPrologTok(parser->m_encoding, s, end, &next);\n  return doProlog(parser, parser->m_encoding, s, end, tok, next, nextPtr,\n                  (XML_Bool)! parser->m_parsingStatus.finalBuffer);\n}",
        "func": "static enum XML_Error PTRCALL\nprologProcessor(XML_Parser parser, const char *s, const char *end,\n                const char **nextPtr) {\n  const char *next = s;\n  int tok = XmlPrologTok(parser->m_encoding, s, end, &next);\n  return doProlog(parser, parser->m_encoding, s, end, tok, next, nextPtr,\n                  (XML_Bool)! parser->m_parsingStatus.finalBuffer, XML_TRUE);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,5 +4,5 @@\n   const char *next = s;\n   int tok = XmlPrologTok(parser->m_encoding, s, end, &next);\n   return doProlog(parser, parser->m_encoding, s, end, tok, next, nextPtr,\n-                  (XML_Bool)! parser->m_parsingStatus.finalBuffer);\n+                  (XML_Bool)! parser->m_parsingStatus.finalBuffer, XML_TRUE);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "                  (XML_Bool)! parser->m_parsingStatus.finalBuffer);"
            ],
            "added_lines": [
                "                  (XML_Bool)! parser->m_parsingStatus.finalBuffer, XML_TRUE);"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-52426",
        "func_name": "libexpat/tmain",
        "description": "libexpat through 2.5.0 allows recursive XML Entity Expansion if XML_DTD is undefined at compile time.",
        "git_url": "https://github.com/libexpat/libexpat/commit/0f075ec8ecb5e43f8fdca5182f8cca4703da0404",
        "commit_title": "lib|xmlwf|cmake: Extend scope of billion laughs attack protection",
        "commit_text": " .. from \"defined(XML_DTD)\" to \"defined(XML_DTD) || XML_GE==1\".",
        "func_before": "int\ntmain(int argc, XML_Char **argv) {\n  int i, j;\n  const XML_Char *outputDir = NULL;\n  const XML_Char *encoding = NULL;\n  unsigned processFlags = XML_MAP_FILE;\n  int windowsCodePages = 0;\n  int outputType = 0;\n  int useNamespaces = 0;\n  int requireStandalone = 0;\n  int requiresNotations = 0;\n  int continueOnError = 0;\n\n  float attackMaximumAmplification = -1.0f; /* signaling \"not set\" */\n  unsigned long long attackThresholdBytes = 0;\n  XML_Bool attackThresholdGiven = XML_FALSE;\n\n  int exitCode = XMLWF_EXIT_SUCCESS;\n  enum XML_ParamEntityParsing paramEntityParsing\n      = XML_PARAM_ENTITY_PARSING_NEVER;\n  int useStdin = 0;\n  XmlwfUserData userData = {NULL, NULL, NULL};\n\n#ifdef _MSC_VER\n  _CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF);\n#endif\n\n  i = 1;\n  j = 0;\n  while (i < argc) {\n    if (j == 0) {\n      if (argv[i][0] != T('-'))\n        break;\n      if (argv[i][1] == T('-')) {\n        if (argv[i][2] == T('\\0')) {\n          i++;\n          break;\n        } else if (tcscmp(argv[i] + 2, T(\"help\")) == 0) {\n          usage(argv[0], XMLWF_EXIT_SUCCESS);\n          // usage called exit(..), never gets here\n        } else if (tcscmp(argv[i] + 2, T(\"version\")) == 0) {\n          showVersion(argv[0]);\n          return XMLWF_EXIT_SUCCESS;\n        }\n      }\n      j++;\n    }\n    switch (argv[i][j]) {\n    case T('r'):\n      processFlags &= ~XML_MAP_FILE;\n      j++;\n      break;\n    case T('s'):\n      requireStandalone = 1;\n      j++;\n      break;\n    case T('n'):\n      useNamespaces = 1;\n      j++;\n      break;\n    case T('p'):\n      paramEntityParsing = XML_PARAM_ENTITY_PARSING_ALWAYS;\n      /* fall through */\n    case T('x'):\n      processFlags |= XML_EXTERNAL_ENTITIES;\n      j++;\n      break;\n    case T('w'):\n      windowsCodePages = 1;\n      j++;\n      break;\n    case T('m'):\n      outputType = 'm';\n      j++;\n      break;\n    case T('c'):\n      outputType = 'c';\n      useNamespaces = 0;\n      j++;\n      break;\n    case T('t'):\n      outputType = 't';\n      j++;\n      break;\n    case T('N'):\n      requiresNotations = 1;\n      j++;\n      break;\n    case T('d'):\n      XMLWF_SHIFT_ARG_INTO(outputDir, argc, argv, i, j);\n      break;\n    case T('e'):\n      XMLWF_SHIFT_ARG_INTO(encoding, argc, argv, i, j);\n      break;\n    case T('h'):\n      usage(argv[0], XMLWF_EXIT_SUCCESS);\n      // usage called exit(..), never gets here\n    case T('v'):\n      showVersion(argv[0]);\n      return XMLWF_EXIT_SUCCESS;\n    case T('g'): {\n      const XML_Char *valueText = NULL;\n      XMLWF_SHIFT_ARG_INTO(valueText, argc, argv, i, j);\n\n      errno = 0;\n      XML_Char *afterValueText = (XML_Char *)valueText;\n      const long long read_size_bytes_candidate\n          = tcstoull(valueText, &afterValueText, 10);\n      if ((errno != 0) || (afterValueText[0] != T('\\0'))\n          || (read_size_bytes_candidate < 1)\n          || (read_size_bytes_candidate > (INT_MAX / 2 + 1))) {\n        // This prevents tperror(..) from reporting misleading \"[..]: Success\"\n        errno = ERANGE;\n        tperror(T(\"invalid buffer size\") T(\n            \" (needs an integer from 1 to INT_MAX/2+1 i.e. 1,073,741,824 on most platforms)\"));\n        exit(XMLWF_EXIT_USAGE_ERROR);\n      }\n      g_read_size_bytes = (int)read_size_bytes_candidate;\n      break;\n    }\n    case T('k'):\n      continueOnError = 1;\n      j++;\n      break;\n    case T('a'): {\n      const XML_Char *valueText = NULL;\n      XMLWF_SHIFT_ARG_INTO(valueText, argc, argv, i, j);\n\n      errno = 0;\n      XML_Char *afterValueText = NULL;\n      attackMaximumAmplification = tcstof(valueText, &afterValueText);\n      if ((errno != 0) || (afterValueText[0] != T('\\0'))\n          || isnan(attackMaximumAmplification)\n          || (attackMaximumAmplification < 1.0f)) {\n        // This prevents tperror(..) from reporting misleading \"[..]: Success\"\n        errno = ERANGE;\n        tperror(T(\"invalid amplification limit\") T(\n            \" (needs a floating point number greater or equal than 1.0)\"));\n        exit(XMLWF_EXIT_USAGE_ERROR);\n      }\n#ifndef XML_DTD\n      ftprintf(stderr, T(\"Warning: Given amplification limit ignored\") T(\n                           \", xmlwf has been compiled without DTD support.\\n\"));\n#endif\n      break;\n    }\n    case T('b'): {\n      const XML_Char *valueText = NULL;\n      XMLWF_SHIFT_ARG_INTO(valueText, argc, argv, i, j);\n\n      errno = 0;\n      XML_Char *afterValueText = (XML_Char *)valueText;\n      attackThresholdBytes = tcstoull(valueText, &afterValueText, 10);\n      if ((errno != 0) || (afterValueText[0] != T('\\0'))) {\n        // This prevents tperror(..) from reporting misleading \"[..]: Success\"\n        errno = ERANGE;\n        tperror(T(\"invalid ignore threshold\")\n                    T(\" (needs an integer from 0 to 2^64-1)\"));\n        exit(XMLWF_EXIT_USAGE_ERROR);\n      }\n      attackThresholdGiven = XML_TRUE;\n#ifndef XML_DTD\n      ftprintf(stderr, T(\"Warning: Given attack threshold ignored\") T(\n                           \", xmlwf has been compiled without DTD support.\\n\"));\n#endif\n      break;\n    }\n    case T('\\0'):\n      if (j > 1) {\n        i++;\n        j = 0;\n        break;\n      }\n      /* fall through */\n    default:\n      usage(argv[0], XMLWF_EXIT_USAGE_ERROR);\n      // usage called exit(..), never gets here\n    }\n  }\n  if (i == argc) {\n    useStdin = 1;\n    processFlags &= ~XML_MAP_FILE;\n    i--;\n  }\n  for (; i < argc; i++) {\n    XML_Char *outName = 0;\n    int result;\n    XML_Parser parser;\n    if (useNamespaces)\n      parser = XML_ParserCreateNS(encoding, NSSEP);\n    else\n      parser = XML_ParserCreate(encoding);\n\n    if (! parser) {\n      tperror(T(\"Could not instantiate parser\"));\n      exit(XMLWF_EXIT_INTERNAL_ERROR);\n    }\n\n    if (attackMaximumAmplification != -1.0f) {\n#ifdef XML_DTD\n      XML_SetBillionLaughsAttackProtectionMaximumAmplification(\n          parser, attackMaximumAmplification);\n#endif\n    }\n    if (attackThresholdGiven) {\n#ifdef XML_DTD\n      XML_SetBillionLaughsAttackProtectionActivationThreshold(\n          parser, attackThresholdBytes);\n#else\n      (void)attackThresholdBytes; // silence -Wunused-but-set-variable\n#endif\n    }\n\n    if (requireStandalone)\n      XML_SetNotStandaloneHandler(parser, notStandalone);\n    XML_SetParamEntityParsing(parser, paramEntityParsing);\n    if (outputType == 't') {\n      /* This is for doing timings; this gives a more realistic estimate of\n         the parsing time. */\n      outputDir = 0;\n      XML_SetElementHandler(parser, nopStartElement, nopEndElement);\n      XML_SetCharacterDataHandler(parser, nopCharacterData);\n      XML_SetProcessingInstructionHandler(parser, nopProcessingInstruction);\n    } else if (outputDir) {\n      const XML_Char *delim = T(\"/\");\n      const XML_Char *file = useStdin ? T(\"STDIN\") : argv[i];\n      if (! useStdin) {\n        /* Jump after last (back)slash */\n        const XML_Char *lastDelim = tcsrchr(file, delim[0]);\n        if (lastDelim)\n          file = lastDelim + 1;\n#if defined(_WIN32)\n        else {\n          const XML_Char *winDelim = T(\"\\\\\");\n          lastDelim = tcsrchr(file, winDelim[0]);\n          if (lastDelim) {\n            file = lastDelim + 1;\n            delim = winDelim;\n          }\n        }\n#endif\n      }\n      outName = (XML_Char *)malloc((tcslen(outputDir) + tcslen(file) + 2)\n                                   * sizeof(XML_Char));\n      if (! outName) {\n        tperror(T(\"Could not allocate memory\"));\n        exit(XMLWF_EXIT_INTERNAL_ERROR);\n      }\n      tcscpy(outName, outputDir);\n      tcscat(outName, delim);\n      tcscat(outName, file);\n      userData.fp = tfopen(outName, T(\"wb\"));\n      if (! userData.fp) {\n        tperror(outName);\n        exitCode = XMLWF_EXIT_OUTPUT_ERROR;\n        free(outName);\n        XML_ParserFree(parser);\n        if (continueOnError) {\n          continue;\n        } else {\n          break;\n        }\n      }\n      setvbuf(userData.fp, NULL, _IOFBF, 16384);\n#ifdef XML_UNICODE\n      puttc(0xFEFF, userData.fp);\n#endif\n      XML_SetUserData(parser, &userData);\n      switch (outputType) {\n      case 'm':\n        XML_UseParserAsHandlerArg(parser);\n        XML_SetElementHandler(parser, metaStartElement, metaEndElement);\n        XML_SetProcessingInstructionHandler(parser, metaProcessingInstruction);\n        XML_SetCommentHandler(parser, metaComment);\n        XML_SetCdataSectionHandler(parser, metaStartCdataSection,\n                                   metaEndCdataSection);\n        XML_SetCharacterDataHandler(parser, metaCharacterData);\n        XML_SetDoctypeDeclHandler(parser, metaStartDoctypeDecl,\n                                  metaEndDoctypeDecl);\n        XML_SetEntityDeclHandler(parser, metaEntityDecl);\n        XML_SetNotationDeclHandler(parser, metaNotationDecl);\n        XML_SetNamespaceDeclHandler(parser, metaStartNamespaceDecl,\n                                    metaEndNamespaceDecl);\n        metaStartDocument(parser);\n        break;\n      case 'c':\n        XML_UseParserAsHandlerArg(parser);\n        XML_SetDefaultHandler(parser, markup);\n        XML_SetElementHandler(parser, defaultStartElement, defaultEndElement);\n        XML_SetCharacterDataHandler(parser, defaultCharacterData);\n        XML_SetProcessingInstructionHandler(parser,\n                                            defaultProcessingInstruction);\n        break;\n      default:\n        if (useNamespaces)\n          XML_SetElementHandler(parser, startElementNS, endElementNS);\n        else\n          XML_SetElementHandler(parser, startElement, endElement);\n        XML_SetCharacterDataHandler(parser, characterData);\n#ifndef W3C14N\n        XML_SetProcessingInstructionHandler(parser, processingInstruction);\n        if (requiresNotations) {\n          XML_SetDoctypeDeclHandler(parser, startDoctypeDecl, endDoctypeDecl);\n          XML_SetNotationDeclHandler(parser, notationDecl);\n        }\n#endif /* not W3C14N */\n        break;\n      }\n    }\n    if (windowsCodePages)\n      XML_SetUnknownEncodingHandler(parser, unknownEncoding, 0);\n    result = XML_ProcessFile(parser, useStdin ? NULL : argv[i], processFlags);\n    if (outputDir) {\n      if (outputType == 'm')\n        metaEndDocument(parser);\n      fclose(userData.fp);\n      if (! result) {\n        tremove(outName);\n      }\n      free(outName);\n    }\n    XML_ParserFree(parser);\n    if (! result) {\n      exitCode = XMLWF_EXIT_NOT_WELLFORMED;\n      cleanupUserData(&userData);\n      if (! continueOnError) {\n        break;\n      }\n    }\n  }\n  return exitCode;\n}",
        "func": "int\ntmain(int argc, XML_Char **argv) {\n  int i, j;\n  const XML_Char *outputDir = NULL;\n  const XML_Char *encoding = NULL;\n  unsigned processFlags = XML_MAP_FILE;\n  int windowsCodePages = 0;\n  int outputType = 0;\n  int useNamespaces = 0;\n  int requireStandalone = 0;\n  int requiresNotations = 0;\n  int continueOnError = 0;\n\n  float attackMaximumAmplification = -1.0f; /* signaling \"not set\" */\n  unsigned long long attackThresholdBytes = 0;\n  XML_Bool attackThresholdGiven = XML_FALSE;\n\n  int exitCode = XMLWF_EXIT_SUCCESS;\n  enum XML_ParamEntityParsing paramEntityParsing\n      = XML_PARAM_ENTITY_PARSING_NEVER;\n  int useStdin = 0;\n  XmlwfUserData userData = {NULL, NULL, NULL};\n\n#ifdef _MSC_VER\n  _CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF);\n#endif\n\n  i = 1;\n  j = 0;\n  while (i < argc) {\n    if (j == 0) {\n      if (argv[i][0] != T('-'))\n        break;\n      if (argv[i][1] == T('-')) {\n        if (argv[i][2] == T('\\0')) {\n          i++;\n          break;\n        } else if (tcscmp(argv[i] + 2, T(\"help\")) == 0) {\n          usage(argv[0], XMLWF_EXIT_SUCCESS);\n          // usage called exit(..), never gets here\n        } else if (tcscmp(argv[i] + 2, T(\"version\")) == 0) {\n          showVersion(argv[0]);\n          return XMLWF_EXIT_SUCCESS;\n        }\n      }\n      j++;\n    }\n    switch (argv[i][j]) {\n    case T('r'):\n      processFlags &= ~XML_MAP_FILE;\n      j++;\n      break;\n    case T('s'):\n      requireStandalone = 1;\n      j++;\n      break;\n    case T('n'):\n      useNamespaces = 1;\n      j++;\n      break;\n    case T('p'):\n      paramEntityParsing = XML_PARAM_ENTITY_PARSING_ALWAYS;\n      /* fall through */\n    case T('x'):\n      processFlags |= XML_EXTERNAL_ENTITIES;\n      j++;\n      break;\n    case T('w'):\n      windowsCodePages = 1;\n      j++;\n      break;\n    case T('m'):\n      outputType = 'm';\n      j++;\n      break;\n    case T('c'):\n      outputType = 'c';\n      useNamespaces = 0;\n      j++;\n      break;\n    case T('t'):\n      outputType = 't';\n      j++;\n      break;\n    case T('N'):\n      requiresNotations = 1;\n      j++;\n      break;\n    case T('d'):\n      XMLWF_SHIFT_ARG_INTO(outputDir, argc, argv, i, j);\n      break;\n    case T('e'):\n      XMLWF_SHIFT_ARG_INTO(encoding, argc, argv, i, j);\n      break;\n    case T('h'):\n      usage(argv[0], XMLWF_EXIT_SUCCESS);\n      // usage called exit(..), never gets here\n    case T('v'):\n      showVersion(argv[0]);\n      return XMLWF_EXIT_SUCCESS;\n    case T('g'): {\n      const XML_Char *valueText = NULL;\n      XMLWF_SHIFT_ARG_INTO(valueText, argc, argv, i, j);\n\n      errno = 0;\n      XML_Char *afterValueText = (XML_Char *)valueText;\n      const long long read_size_bytes_candidate\n          = tcstoull(valueText, &afterValueText, 10);\n      if ((errno != 0) || (afterValueText[0] != T('\\0'))\n          || (read_size_bytes_candidate < 1)\n          || (read_size_bytes_candidate > (INT_MAX / 2 + 1))) {\n        // This prevents tperror(..) from reporting misleading \"[..]: Success\"\n        errno = ERANGE;\n        tperror(T(\"invalid buffer size\") T(\n            \" (needs an integer from 1 to INT_MAX/2+1 i.e. 1,073,741,824 on most platforms)\"));\n        exit(XMLWF_EXIT_USAGE_ERROR);\n      }\n      g_read_size_bytes = (int)read_size_bytes_candidate;\n      break;\n    }\n    case T('k'):\n      continueOnError = 1;\n      j++;\n      break;\n    case T('a'): {\n      const XML_Char *valueText = NULL;\n      XMLWF_SHIFT_ARG_INTO(valueText, argc, argv, i, j);\n\n      errno = 0;\n      XML_Char *afterValueText = NULL;\n      attackMaximumAmplification = tcstof(valueText, &afterValueText);\n      if ((errno != 0) || (afterValueText[0] != T('\\0'))\n          || isnan(attackMaximumAmplification)\n          || (attackMaximumAmplification < 1.0f)) {\n        // This prevents tperror(..) from reporting misleading \"[..]: Success\"\n        errno = ERANGE;\n        tperror(T(\"invalid amplification limit\") T(\n            \" (needs a floating point number greater or equal than 1.0)\"));\n        exit(XMLWF_EXIT_USAGE_ERROR);\n      }\n#if ! defined(XML_DTD) && XML_GE == 0\n      ftprintf(stderr,\n               T(\"Warning: Given amplification limit ignored\")\n                   T(\", xmlwf has been compiled without DTD/GE support.\\n\"));\n#endif\n      break;\n    }\n    case T('b'): {\n      const XML_Char *valueText = NULL;\n      XMLWF_SHIFT_ARG_INTO(valueText, argc, argv, i, j);\n\n      errno = 0;\n      XML_Char *afterValueText = (XML_Char *)valueText;\n      attackThresholdBytes = tcstoull(valueText, &afterValueText, 10);\n      if ((errno != 0) || (afterValueText[0] != T('\\0'))) {\n        // This prevents tperror(..) from reporting misleading \"[..]: Success\"\n        errno = ERANGE;\n        tperror(T(\"invalid ignore threshold\")\n                    T(\" (needs an integer from 0 to 2^64-1)\"));\n        exit(XMLWF_EXIT_USAGE_ERROR);\n      }\n      attackThresholdGiven = XML_TRUE;\n#if ! defined(XML_DTD) && XML_GE == 0\n      ftprintf(stderr,\n               T(\"Warning: Given attack threshold ignored\")\n                   T(\", xmlwf has been compiled without DTD/GE support.\\n\"));\n#endif\n      break;\n    }\n    case T('\\0'):\n      if (j > 1) {\n        i++;\n        j = 0;\n        break;\n      }\n      /* fall through */\n    default:\n      usage(argv[0], XMLWF_EXIT_USAGE_ERROR);\n      // usage called exit(..), never gets here\n    }\n  }\n  if (i == argc) {\n    useStdin = 1;\n    processFlags &= ~XML_MAP_FILE;\n    i--;\n  }\n  for (; i < argc; i++) {\n    XML_Char *outName = 0;\n    int result;\n    XML_Parser parser;\n    if (useNamespaces)\n      parser = XML_ParserCreateNS(encoding, NSSEP);\n    else\n      parser = XML_ParserCreate(encoding);\n\n    if (! parser) {\n      tperror(T(\"Could not instantiate parser\"));\n      exit(XMLWF_EXIT_INTERNAL_ERROR);\n    }\n\n    if (attackMaximumAmplification != -1.0f) {\n#if defined(XML_DTD) || XML_GE == 1\n      XML_SetBillionLaughsAttackProtectionMaximumAmplification(\n          parser, attackMaximumAmplification);\n#endif\n    }\n    if (attackThresholdGiven) {\n#if defined(XML_DTD) || XML_GE == 1\n      XML_SetBillionLaughsAttackProtectionActivationThreshold(\n          parser, attackThresholdBytes);\n#else\n      (void)attackThresholdBytes; // silence -Wunused-but-set-variable\n#endif\n    }\n\n    if (requireStandalone)\n      XML_SetNotStandaloneHandler(parser, notStandalone);\n    XML_SetParamEntityParsing(parser, paramEntityParsing);\n    if (outputType == 't') {\n      /* This is for doing timings; this gives a more realistic estimate of\n         the parsing time. */\n      outputDir = 0;\n      XML_SetElementHandler(parser, nopStartElement, nopEndElement);\n      XML_SetCharacterDataHandler(parser, nopCharacterData);\n      XML_SetProcessingInstructionHandler(parser, nopProcessingInstruction);\n    } else if (outputDir) {\n      const XML_Char *delim = T(\"/\");\n      const XML_Char *file = useStdin ? T(\"STDIN\") : argv[i];\n      if (! useStdin) {\n        /* Jump after last (back)slash */\n        const XML_Char *lastDelim = tcsrchr(file, delim[0]);\n        if (lastDelim)\n          file = lastDelim + 1;\n#if defined(_WIN32)\n        else {\n          const XML_Char *winDelim = T(\"\\\\\");\n          lastDelim = tcsrchr(file, winDelim[0]);\n          if (lastDelim) {\n            file = lastDelim + 1;\n            delim = winDelim;\n          }\n        }\n#endif\n      }\n      outName = (XML_Char *)malloc((tcslen(outputDir) + tcslen(file) + 2)\n                                   * sizeof(XML_Char));\n      if (! outName) {\n        tperror(T(\"Could not allocate memory\"));\n        exit(XMLWF_EXIT_INTERNAL_ERROR);\n      }\n      tcscpy(outName, outputDir);\n      tcscat(outName, delim);\n      tcscat(outName, file);\n      userData.fp = tfopen(outName, T(\"wb\"));\n      if (! userData.fp) {\n        tperror(outName);\n        exitCode = XMLWF_EXIT_OUTPUT_ERROR;\n        free(outName);\n        XML_ParserFree(parser);\n        if (continueOnError) {\n          continue;\n        } else {\n          break;\n        }\n      }\n      setvbuf(userData.fp, NULL, _IOFBF, 16384);\n#ifdef XML_UNICODE\n      puttc(0xFEFF, userData.fp);\n#endif\n      XML_SetUserData(parser, &userData);\n      switch (outputType) {\n      case 'm':\n        XML_UseParserAsHandlerArg(parser);\n        XML_SetElementHandler(parser, metaStartElement, metaEndElement);\n        XML_SetProcessingInstructionHandler(parser, metaProcessingInstruction);\n        XML_SetCommentHandler(parser, metaComment);\n        XML_SetCdataSectionHandler(parser, metaStartCdataSection,\n                                   metaEndCdataSection);\n        XML_SetCharacterDataHandler(parser, metaCharacterData);\n        XML_SetDoctypeDeclHandler(parser, metaStartDoctypeDecl,\n                                  metaEndDoctypeDecl);\n        XML_SetEntityDeclHandler(parser, metaEntityDecl);\n        XML_SetNotationDeclHandler(parser, metaNotationDecl);\n        XML_SetNamespaceDeclHandler(parser, metaStartNamespaceDecl,\n                                    metaEndNamespaceDecl);\n        metaStartDocument(parser);\n        break;\n      case 'c':\n        XML_UseParserAsHandlerArg(parser);\n        XML_SetDefaultHandler(parser, markup);\n        XML_SetElementHandler(parser, defaultStartElement, defaultEndElement);\n        XML_SetCharacterDataHandler(parser, defaultCharacterData);\n        XML_SetProcessingInstructionHandler(parser,\n                                            defaultProcessingInstruction);\n        break;\n      default:\n        if (useNamespaces)\n          XML_SetElementHandler(parser, startElementNS, endElementNS);\n        else\n          XML_SetElementHandler(parser, startElement, endElement);\n        XML_SetCharacterDataHandler(parser, characterData);\n#ifndef W3C14N\n        XML_SetProcessingInstructionHandler(parser, processingInstruction);\n        if (requiresNotations) {\n          XML_SetDoctypeDeclHandler(parser, startDoctypeDecl, endDoctypeDecl);\n          XML_SetNotationDeclHandler(parser, notationDecl);\n        }\n#endif /* not W3C14N */\n        break;\n      }\n    }\n    if (windowsCodePages)\n      XML_SetUnknownEncodingHandler(parser, unknownEncoding, 0);\n    result = XML_ProcessFile(parser, useStdin ? NULL : argv[i], processFlags);\n    if (outputDir) {\n      if (outputType == 'm')\n        metaEndDocument(parser);\n      fclose(userData.fp);\n      if (! result) {\n        tremove(outName);\n      }\n      free(outName);\n    }\n    XML_ParserFree(parser);\n    if (! result) {\n      exitCode = XMLWF_EXIT_NOT_WELLFORMED;\n      cleanupUserData(&userData);\n      if (! continueOnError) {\n        break;\n      }\n    }\n  }\n  return exitCode;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -138,9 +138,10 @@\n             \" (needs a floating point number greater or equal than 1.0)\"));\n         exit(XMLWF_EXIT_USAGE_ERROR);\n       }\n-#ifndef XML_DTD\n-      ftprintf(stderr, T(\"Warning: Given amplification limit ignored\") T(\n-                           \", xmlwf has been compiled without DTD support.\\n\"));\n+#if ! defined(XML_DTD) && XML_GE == 0\n+      ftprintf(stderr,\n+               T(\"Warning: Given amplification limit ignored\")\n+                   T(\", xmlwf has been compiled without DTD/GE support.\\n\"));\n #endif\n       break;\n     }\n@@ -159,9 +160,10 @@\n         exit(XMLWF_EXIT_USAGE_ERROR);\n       }\n       attackThresholdGiven = XML_TRUE;\n-#ifndef XML_DTD\n-      ftprintf(stderr, T(\"Warning: Given attack threshold ignored\") T(\n-                           \", xmlwf has been compiled without DTD support.\\n\"));\n+#if ! defined(XML_DTD) && XML_GE == 0\n+      ftprintf(stderr,\n+               T(\"Warning: Given attack threshold ignored\")\n+                   T(\", xmlwf has been compiled without DTD/GE support.\\n\"));\n #endif\n       break;\n     }\n@@ -197,13 +199,13 @@\n     }\n \n     if (attackMaximumAmplification != -1.0f) {\n-#ifdef XML_DTD\n+#if defined(XML_DTD) || XML_GE == 1\n       XML_SetBillionLaughsAttackProtectionMaximumAmplification(\n           parser, attackMaximumAmplification);\n #endif\n     }\n     if (attackThresholdGiven) {\n-#ifdef XML_DTD\n+#if defined(XML_DTD) || XML_GE == 1\n       XML_SetBillionLaughsAttackProtectionActivationThreshold(\n           parser, attackThresholdBytes);\n #else",
        "diff_line_info": {
            "deleted_lines": [
                "#ifndef XML_DTD",
                "      ftprintf(stderr, T(\"Warning: Given amplification limit ignored\") T(",
                "                           \", xmlwf has been compiled without DTD support.\\n\"));",
                "#ifndef XML_DTD",
                "      ftprintf(stderr, T(\"Warning: Given attack threshold ignored\") T(",
                "                           \", xmlwf has been compiled without DTD support.\\n\"));",
                "#ifdef XML_DTD",
                "#ifdef XML_DTD"
            ],
            "added_lines": [
                "#if ! defined(XML_DTD) && XML_GE == 0",
                "      ftprintf(stderr,",
                "               T(\"Warning: Given amplification limit ignored\")",
                "                   T(\", xmlwf has been compiled without DTD/GE support.\\n\"));",
                "#if ! defined(XML_DTD) && XML_GE == 0",
                "      ftprintf(stderr,",
                "               T(\"Warning: Given attack threshold ignored\")",
                "                   T(\", xmlwf has been compiled without DTD/GE support.\\n\"));",
                "#if defined(XML_DTD) || XML_GE == 1",
                "#if defined(XML_DTD) || XML_GE == 1"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-52426",
        "func_name": "libexpat/appendAttributeValue",
        "description": "libexpat through 2.5.0 allows recursive XML Entity Expansion if XML_DTD is undefined at compile time.",
        "git_url": "https://github.com/libexpat/libexpat/commit/0f075ec8ecb5e43f8fdca5182f8cca4703da0404",
        "commit_title": "lib|xmlwf|cmake: Extend scope of billion laughs attack protection",
        "commit_text": " .. from \"defined(XML_DTD)\" to \"defined(XML_DTD) || XML_GE==1\".",
        "func_before": "static enum XML_Error\nappendAttributeValue(XML_Parser parser, const ENCODING *enc, XML_Bool isCdata,\n                     const char *ptr, const char *end, STRING_POOL *pool,\n                     enum XML_Account account) {\n  DTD *const dtd = parser->m_dtd; /* save one level of indirection */\n#ifndef XML_DTD\n  UNUSED_P(account);\n#endif\n\n  for (;;) {\n    const char *next\n        = ptr; /* XmlAttributeValueTok doesn't always set the last arg */\n    int tok = XmlAttributeValueTok(enc, ptr, end, &next);\n#ifdef XML_DTD\n    if (! accountingDiffTolerated(parser, tok, ptr, next, __LINE__, account)) {\n      accountingOnAbort(parser);\n      return XML_ERROR_AMPLIFICATION_LIMIT_BREACH;\n    }\n#endif\n    switch (tok) {\n    case XML_TOK_NONE:\n      return XML_ERROR_NONE;\n    case XML_TOK_INVALID:\n      if (enc == parser->m_encoding)\n        parser->m_eventPtr = next;\n      return XML_ERROR_INVALID_TOKEN;\n    case XML_TOK_PARTIAL:\n      if (enc == parser->m_encoding)\n        parser->m_eventPtr = ptr;\n      return XML_ERROR_INVALID_TOKEN;\n    case XML_TOK_CHAR_REF: {\n      XML_Char buf[XML_ENCODE_MAX];\n      int i;\n      int n = XmlCharRefNumber(enc, ptr);\n      if (n < 0) {\n        if (enc == parser->m_encoding)\n          parser->m_eventPtr = ptr;\n        return XML_ERROR_BAD_CHAR_REF;\n      }\n      if (! isCdata && n == 0x20 /* space */\n          && (poolLength(pool) == 0 || poolLastChar(pool) == 0x20))\n        break;\n      n = XmlEncode(n, (ICHAR *)buf);\n      /* The XmlEncode() functions can never return 0 here.  That\n       * error return happens if the code point passed in is either\n       * negative or greater than or equal to 0x110000.  The\n       * XmlCharRefNumber() functions will all return a number\n       * strictly less than 0x110000 or a negative value if an error\n       * occurred.  The negative value is intercepted above, so\n       * XmlEncode() is never passed a value it might return an\n       * error for.\n       */\n      for (i = 0; i < n; i++) {\n        if (! poolAppendChar(pool, buf[i]))\n          return XML_ERROR_NO_MEMORY;\n      }\n    } break;\n    case XML_TOK_DATA_CHARS:\n      if (! poolAppend(pool, enc, ptr, next))\n        return XML_ERROR_NO_MEMORY;\n      break;\n    case XML_TOK_TRAILING_CR:\n      next = ptr + enc->minBytesPerChar;\n      /* fall through */\n    case XML_TOK_ATTRIBUTE_VALUE_S:\n    case XML_TOK_DATA_NEWLINE:\n      if (! isCdata && (poolLength(pool) == 0 || poolLastChar(pool) == 0x20))\n        break;\n      if (! poolAppendChar(pool, 0x20))\n        return XML_ERROR_NO_MEMORY;\n      break;\n    case XML_TOK_ENTITY_REF: {\n      const XML_Char *name;\n      ENTITY *entity;\n      char checkEntityDecl;\n      XML_Char ch = (XML_Char)XmlPredefinedEntityName(\n          enc, ptr + enc->minBytesPerChar, next - enc->minBytesPerChar);\n      if (ch) {\n#ifdef XML_DTD\n        /* NOTE: We are replacing 4-6 characters original input for 1 character\n         *       so there is no amplification and hence recording without\n         *       protection. */\n        accountingDiffTolerated(parser, tok, (char *)&ch,\n                                ((char *)&ch) + sizeof(XML_Char), __LINE__,\n                                XML_ACCOUNT_ENTITY_EXPANSION);\n#endif /* XML_DTD */\n        if (! poolAppendChar(pool, ch))\n          return XML_ERROR_NO_MEMORY;\n        break;\n      }\n      name = poolStoreString(&parser->m_temp2Pool, enc,\n                             ptr + enc->minBytesPerChar,\n                             next - enc->minBytesPerChar);\n      if (! name)\n        return XML_ERROR_NO_MEMORY;\n      entity = (ENTITY *)lookup(parser, &dtd->generalEntities, name, 0);\n      poolDiscard(&parser->m_temp2Pool);\n      /* First, determine if a check for an existing declaration is needed;\n         if yes, check that the entity exists, and that it is internal.\n      */\n      if (pool == &dtd->pool) /* are we called from prolog? */\n        checkEntityDecl =\n#ifdef XML_DTD\n            parser->m_prologState.documentEntity &&\n#endif /* XML_DTD */\n            (dtd->standalone ? ! parser->m_openInternalEntities\n                             : ! dtd->hasParamEntityRefs);\n      else /* if (pool == &parser->m_tempPool): we are called from content */\n        checkEntityDecl = ! dtd->hasParamEntityRefs || dtd->standalone;\n      if (checkEntityDecl) {\n        if (! entity)\n          return XML_ERROR_UNDEFINED_ENTITY;\n        else if (! entity->is_internal)\n          return XML_ERROR_ENTITY_DECLARED_IN_PE;\n      } else if (! entity) {\n        /* Cannot report skipped entity here - see comments on\n           parser->m_skippedEntityHandler.\n        if (parser->m_skippedEntityHandler)\n          parser->m_skippedEntityHandler(parser->m_handlerArg, name, 0);\n        */\n        /* Cannot call the default handler because this would be\n           out of sync with the call to the startElementHandler.\n        if ((pool == &parser->m_tempPool) && parser->m_defaultHandler)\n          reportDefault(parser, enc, ptr, next);\n        */\n        break;\n      }\n      if (entity->open) {\n        if (enc == parser->m_encoding) {\n          /* It does not appear that this line can be executed.\n           *\n           * The \"if (entity->open)\" check catches recursive entity\n           * definitions.  In order to be called with an open\n           * entity, it must have gone through this code before and\n           * been through the recursive call to\n           * appendAttributeValue() some lines below.  That call\n           * sets the local encoding (\"enc\") to the parser's\n           * internal encoding (internal_utf8 or internal_utf16),\n           * which can never be the same as the principle encoding.\n           * It doesn't appear there is another code path that gets\n           * here with entity->open being TRUE.\n           *\n           * Since it is not certain that this logic is watertight,\n           * we keep the line and merely exclude it from coverage\n           * tests.\n           */\n          parser->m_eventPtr = ptr; /* LCOV_EXCL_LINE */\n        }\n        return XML_ERROR_RECURSIVE_ENTITY_REF;\n      }\n      if (entity->notation) {\n        if (enc == parser->m_encoding)\n          parser->m_eventPtr = ptr;\n        return XML_ERROR_BINARY_ENTITY_REF;\n      }\n      if (! entity->textPtr) {\n        if (enc == parser->m_encoding)\n          parser->m_eventPtr = ptr;\n        return XML_ERROR_ATTRIBUTE_EXTERNAL_ENTITY_REF;\n      } else {\n        enum XML_Error result;\n        const XML_Char *textEnd = entity->textPtr + entity->textLen;\n        entity->open = XML_TRUE;\n#ifdef XML_DTD\n        entityTrackingOnOpen(parser, entity, __LINE__);\n#endif\n        result = appendAttributeValue(parser, parser->m_internalEncoding,\n                                      isCdata, (const char *)entity->textPtr,\n                                      (const char *)textEnd, pool,\n                                      XML_ACCOUNT_ENTITY_EXPANSION);\n#ifdef XML_DTD\n        entityTrackingOnClose(parser, entity, __LINE__);\n#endif\n        entity->open = XML_FALSE;\n        if (result)\n          return result;\n      }\n    } break;\n    default:\n      /* The only token returned by XmlAttributeValueTok() that does\n       * not have an explicit case here is XML_TOK_PARTIAL_CHAR.\n       * Getting that would require an entity name to contain an\n       * incomplete XML character (e.g. \\xE2\\x82); however previous\n       * tokenisers will have already recognised and rejected such\n       * names before XmlAttributeValueTok() gets a look-in.  This\n       * default case should be retained as a safety net, but the code\n       * excluded from coverage tests.\n       *\n       * LCOV_EXCL_START\n       */\n      if (enc == parser->m_encoding)\n        parser->m_eventPtr = ptr;\n      return XML_ERROR_UNEXPECTED_STATE;\n      /* LCOV_EXCL_STOP */\n    }\n    ptr = next;\n  }\n  /* not reached */\n}",
        "func": "static enum XML_Error\nappendAttributeValue(XML_Parser parser, const ENCODING *enc, XML_Bool isCdata,\n                     const char *ptr, const char *end, STRING_POOL *pool,\n                     enum XML_Account account) {\n  DTD *const dtd = parser->m_dtd; /* save one level of indirection */\n#ifndef XML_DTD\n  UNUSED_P(account);\n#endif\n\n  for (;;) {\n    const char *next\n        = ptr; /* XmlAttributeValueTok doesn't always set the last arg */\n    int tok = XmlAttributeValueTok(enc, ptr, end, &next);\n#if defined(XML_DTD) || XML_GE == 1\n    if (! accountingDiffTolerated(parser, tok, ptr, next, __LINE__, account)) {\n      accountingOnAbort(parser);\n      return XML_ERROR_AMPLIFICATION_LIMIT_BREACH;\n    }\n#endif\n    switch (tok) {\n    case XML_TOK_NONE:\n      return XML_ERROR_NONE;\n    case XML_TOK_INVALID:\n      if (enc == parser->m_encoding)\n        parser->m_eventPtr = next;\n      return XML_ERROR_INVALID_TOKEN;\n    case XML_TOK_PARTIAL:\n      if (enc == parser->m_encoding)\n        parser->m_eventPtr = ptr;\n      return XML_ERROR_INVALID_TOKEN;\n    case XML_TOK_CHAR_REF: {\n      XML_Char buf[XML_ENCODE_MAX];\n      int i;\n      int n = XmlCharRefNumber(enc, ptr);\n      if (n < 0) {\n        if (enc == parser->m_encoding)\n          parser->m_eventPtr = ptr;\n        return XML_ERROR_BAD_CHAR_REF;\n      }\n      if (! isCdata && n == 0x20 /* space */\n          && (poolLength(pool) == 0 || poolLastChar(pool) == 0x20))\n        break;\n      n = XmlEncode(n, (ICHAR *)buf);\n      /* The XmlEncode() functions can never return 0 here.  That\n       * error return happens if the code point passed in is either\n       * negative or greater than or equal to 0x110000.  The\n       * XmlCharRefNumber() functions will all return a number\n       * strictly less than 0x110000 or a negative value if an error\n       * occurred.  The negative value is intercepted above, so\n       * XmlEncode() is never passed a value it might return an\n       * error for.\n       */\n      for (i = 0; i < n; i++) {\n        if (! poolAppendChar(pool, buf[i]))\n          return XML_ERROR_NO_MEMORY;\n      }\n    } break;\n    case XML_TOK_DATA_CHARS:\n      if (! poolAppend(pool, enc, ptr, next))\n        return XML_ERROR_NO_MEMORY;\n      break;\n    case XML_TOK_TRAILING_CR:\n      next = ptr + enc->minBytesPerChar;\n      /* fall through */\n    case XML_TOK_ATTRIBUTE_VALUE_S:\n    case XML_TOK_DATA_NEWLINE:\n      if (! isCdata && (poolLength(pool) == 0 || poolLastChar(pool) == 0x20))\n        break;\n      if (! poolAppendChar(pool, 0x20))\n        return XML_ERROR_NO_MEMORY;\n      break;\n    case XML_TOK_ENTITY_REF: {\n      const XML_Char *name;\n      ENTITY *entity;\n      char checkEntityDecl;\n      XML_Char ch = (XML_Char)XmlPredefinedEntityName(\n          enc, ptr + enc->minBytesPerChar, next - enc->minBytesPerChar);\n      if (ch) {\n#if defined(XML_DTD) || XML_GE == 1\n        /* NOTE: We are replacing 4-6 characters original input for 1 character\n         *       so there is no amplification and hence recording without\n         *       protection. */\n        accountingDiffTolerated(parser, tok, (char *)&ch,\n                                ((char *)&ch) + sizeof(XML_Char), __LINE__,\n                                XML_ACCOUNT_ENTITY_EXPANSION);\n#endif /* defined(XML_DTD) || XML_GE == 1 */\n        if (! poolAppendChar(pool, ch))\n          return XML_ERROR_NO_MEMORY;\n        break;\n      }\n      name = poolStoreString(&parser->m_temp2Pool, enc,\n                             ptr + enc->minBytesPerChar,\n                             next - enc->minBytesPerChar);\n      if (! name)\n        return XML_ERROR_NO_MEMORY;\n      entity = (ENTITY *)lookup(parser, &dtd->generalEntities, name, 0);\n      poolDiscard(&parser->m_temp2Pool);\n      /* First, determine if a check for an existing declaration is needed;\n         if yes, check that the entity exists, and that it is internal.\n      */\n      if (pool == &dtd->pool) /* are we called from prolog? */\n        checkEntityDecl =\n#ifdef XML_DTD\n            parser->m_prologState.documentEntity &&\n#endif /* XML_DTD */\n            (dtd->standalone ? ! parser->m_openInternalEntities\n                             : ! dtd->hasParamEntityRefs);\n      else /* if (pool == &parser->m_tempPool): we are called from content */\n        checkEntityDecl = ! dtd->hasParamEntityRefs || dtd->standalone;\n      if (checkEntityDecl) {\n        if (! entity)\n          return XML_ERROR_UNDEFINED_ENTITY;\n        else if (! entity->is_internal)\n          return XML_ERROR_ENTITY_DECLARED_IN_PE;\n      } else if (! entity) {\n        /* Cannot report skipped entity here - see comments on\n           parser->m_skippedEntityHandler.\n        if (parser->m_skippedEntityHandler)\n          parser->m_skippedEntityHandler(parser->m_handlerArg, name, 0);\n        */\n        /* Cannot call the default handler because this would be\n           out of sync with the call to the startElementHandler.\n        if ((pool == &parser->m_tempPool) && parser->m_defaultHandler)\n          reportDefault(parser, enc, ptr, next);\n        */\n        break;\n      }\n      if (entity->open) {\n        if (enc == parser->m_encoding) {\n          /* It does not appear that this line can be executed.\n           *\n           * The \"if (entity->open)\" check catches recursive entity\n           * definitions.  In order to be called with an open\n           * entity, it must have gone through this code before and\n           * been through the recursive call to\n           * appendAttributeValue() some lines below.  That call\n           * sets the local encoding (\"enc\") to the parser's\n           * internal encoding (internal_utf8 or internal_utf16),\n           * which can never be the same as the principle encoding.\n           * It doesn't appear there is another code path that gets\n           * here with entity->open being TRUE.\n           *\n           * Since it is not certain that this logic is watertight,\n           * we keep the line and merely exclude it from coverage\n           * tests.\n           */\n          parser->m_eventPtr = ptr; /* LCOV_EXCL_LINE */\n        }\n        return XML_ERROR_RECURSIVE_ENTITY_REF;\n      }\n      if (entity->notation) {\n        if (enc == parser->m_encoding)\n          parser->m_eventPtr = ptr;\n        return XML_ERROR_BINARY_ENTITY_REF;\n      }\n      if (! entity->textPtr) {\n        if (enc == parser->m_encoding)\n          parser->m_eventPtr = ptr;\n        return XML_ERROR_ATTRIBUTE_EXTERNAL_ENTITY_REF;\n      } else {\n        enum XML_Error result;\n        const XML_Char *textEnd = entity->textPtr + entity->textLen;\n        entity->open = XML_TRUE;\n#if defined(XML_DTD) || XML_GE == 1\n        entityTrackingOnOpen(parser, entity, __LINE__);\n#endif\n        result = appendAttributeValue(parser, parser->m_internalEncoding,\n                                      isCdata, (const char *)entity->textPtr,\n                                      (const char *)textEnd, pool,\n                                      XML_ACCOUNT_ENTITY_EXPANSION);\n#if defined(XML_DTD) || XML_GE == 1\n        entityTrackingOnClose(parser, entity, __LINE__);\n#endif\n        entity->open = XML_FALSE;\n        if (result)\n          return result;\n      }\n    } break;\n    default:\n      /* The only token returned by XmlAttributeValueTok() that does\n       * not have an explicit case here is XML_TOK_PARTIAL_CHAR.\n       * Getting that would require an entity name to contain an\n       * incomplete XML character (e.g. \\xE2\\x82); however previous\n       * tokenisers will have already recognised and rejected such\n       * names before XmlAttributeValueTok() gets a look-in.  This\n       * default case should be retained as a safety net, but the code\n       * excluded from coverage tests.\n       *\n       * LCOV_EXCL_START\n       */\n      if (enc == parser->m_encoding)\n        parser->m_eventPtr = ptr;\n      return XML_ERROR_UNEXPECTED_STATE;\n      /* LCOV_EXCL_STOP */\n    }\n    ptr = next;\n  }\n  /* not reached */\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -11,7 +11,7 @@\n     const char *next\n         = ptr; /* XmlAttributeValueTok doesn't always set the last arg */\n     int tok = XmlAttributeValueTok(enc, ptr, end, &next);\n-#ifdef XML_DTD\n+#if defined(XML_DTD) || XML_GE == 1\n     if (! accountingDiffTolerated(parser, tok, ptr, next, __LINE__, account)) {\n       accountingOnAbort(parser);\n       return XML_ERROR_AMPLIFICATION_LIMIT_BREACH;\n@@ -76,14 +76,14 @@\n       XML_Char ch = (XML_Char)XmlPredefinedEntityName(\n           enc, ptr + enc->minBytesPerChar, next - enc->minBytesPerChar);\n       if (ch) {\n-#ifdef XML_DTD\n+#if defined(XML_DTD) || XML_GE == 1\n         /* NOTE: We are replacing 4-6 characters original input for 1 character\n          *       so there is no amplification and hence recording without\n          *       protection. */\n         accountingDiffTolerated(parser, tok, (char *)&ch,\n                                 ((char *)&ch) + sizeof(XML_Char), __LINE__,\n                                 XML_ACCOUNT_ENTITY_EXPANSION);\n-#endif /* XML_DTD */\n+#endif /* defined(XML_DTD) || XML_GE == 1 */\n         if (! poolAppendChar(pool, ch))\n           return XML_ERROR_NO_MEMORY;\n         break;\n@@ -161,14 +161,14 @@\n         enum XML_Error result;\n         const XML_Char *textEnd = entity->textPtr + entity->textLen;\n         entity->open = XML_TRUE;\n-#ifdef XML_DTD\n+#if defined(XML_DTD) || XML_GE == 1\n         entityTrackingOnOpen(parser, entity, __LINE__);\n #endif\n         result = appendAttributeValue(parser, parser->m_internalEncoding,\n                                       isCdata, (const char *)entity->textPtr,\n                                       (const char *)textEnd, pool,\n                                       XML_ACCOUNT_ENTITY_EXPANSION);\n-#ifdef XML_DTD\n+#if defined(XML_DTD) || XML_GE == 1\n         entityTrackingOnClose(parser, entity, __LINE__);\n #endif\n         entity->open = XML_FALSE;",
        "diff_line_info": {
            "deleted_lines": [
                "#ifdef XML_DTD",
                "#ifdef XML_DTD",
                "#endif /* XML_DTD */",
                "#ifdef XML_DTD",
                "#ifdef XML_DTD"
            ],
            "added_lines": [
                "#if defined(XML_DTD) || XML_GE == 1",
                "#if defined(XML_DTD) || XML_GE == 1",
                "#endif /* defined(XML_DTD) || XML_GE == 1 */",
                "#if defined(XML_DTD) || XML_GE == 1",
                "#if defined(XML_DTD) || XML_GE == 1"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-52426",
        "func_name": "libexpat/parserInit",
        "description": "libexpat through 2.5.0 allows recursive XML Entity Expansion if XML_DTD is undefined at compile time.",
        "git_url": "https://github.com/libexpat/libexpat/commit/0f075ec8ecb5e43f8fdca5182f8cca4703da0404",
        "commit_title": "lib|xmlwf|cmake: Extend scope of billion laughs attack protection",
        "commit_text": " .. from \"defined(XML_DTD)\" to \"defined(XML_DTD) || XML_GE==1\".",
        "func_before": "static void\nparserInit(XML_Parser parser, const XML_Char *encodingName) {\n  parser->m_processor = prologInitProcessor;\n  XmlPrologStateInit(&parser->m_prologState);\n  if (encodingName != NULL) {\n    parser->m_protocolEncodingName = copyString(encodingName, &(parser->m_mem));\n  }\n  parser->m_curBase = NULL;\n  XmlInitEncoding(&parser->m_initEncoding, &parser->m_encoding, 0);\n  parser->m_userData = NULL;\n  parser->m_handlerArg = NULL;\n  parser->m_startElementHandler = NULL;\n  parser->m_endElementHandler = NULL;\n  parser->m_characterDataHandler = NULL;\n  parser->m_processingInstructionHandler = NULL;\n  parser->m_commentHandler = NULL;\n  parser->m_startCdataSectionHandler = NULL;\n  parser->m_endCdataSectionHandler = NULL;\n  parser->m_defaultHandler = NULL;\n  parser->m_startDoctypeDeclHandler = NULL;\n  parser->m_endDoctypeDeclHandler = NULL;\n  parser->m_unparsedEntityDeclHandler = NULL;\n  parser->m_notationDeclHandler = NULL;\n  parser->m_startNamespaceDeclHandler = NULL;\n  parser->m_endNamespaceDeclHandler = NULL;\n  parser->m_notStandaloneHandler = NULL;\n  parser->m_externalEntityRefHandler = NULL;\n  parser->m_externalEntityRefHandlerArg = parser;\n  parser->m_skippedEntityHandler = NULL;\n  parser->m_elementDeclHandler = NULL;\n  parser->m_attlistDeclHandler = NULL;\n  parser->m_entityDeclHandler = NULL;\n  parser->m_xmlDeclHandler = NULL;\n  parser->m_bufferPtr = parser->m_buffer;\n  parser->m_bufferEnd = parser->m_buffer;\n  parser->m_parseEndByteIndex = 0;\n  parser->m_parseEndPtr = NULL;\n  parser->m_declElementType = NULL;\n  parser->m_declAttributeId = NULL;\n  parser->m_declEntity = NULL;\n  parser->m_doctypeName = NULL;\n  parser->m_doctypeSysid = NULL;\n  parser->m_doctypePubid = NULL;\n  parser->m_declAttributeType = NULL;\n  parser->m_declNotationName = NULL;\n  parser->m_declNotationPublicId = NULL;\n  parser->m_declAttributeIsCdata = XML_FALSE;\n  parser->m_declAttributeIsId = XML_FALSE;\n  memset(&parser->m_position, 0, sizeof(POSITION));\n  parser->m_errorCode = XML_ERROR_NONE;\n  parser->m_eventPtr = NULL;\n  parser->m_eventEndPtr = NULL;\n  parser->m_positionPtr = NULL;\n  parser->m_openInternalEntities = NULL;\n  parser->m_defaultExpandInternalEntities = XML_TRUE;\n  parser->m_tagLevel = 0;\n  parser->m_tagStack = NULL;\n  parser->m_inheritedBindings = NULL;\n  parser->m_nSpecifiedAtts = 0;\n  parser->m_unknownEncodingMem = NULL;\n  parser->m_unknownEncodingRelease = NULL;\n  parser->m_unknownEncodingData = NULL;\n  parser->m_parentParser = NULL;\n  parser->m_parsingStatus.parsing = XML_INITIALIZED;\n#ifdef XML_DTD\n  parser->m_isParamEntity = XML_FALSE;\n  parser->m_useForeignDTD = XML_FALSE;\n  parser->m_paramEntityParsing = XML_PARAM_ENTITY_PARSING_NEVER;\n#endif\n  parser->m_hash_secret_salt = 0;\n\n#ifdef XML_DTD\n  memset(&parser->m_accounting, 0, sizeof(ACCOUNTING));\n  parser->m_accounting.debugLevel = getDebugLevel(\"EXPAT_ACCOUNTING_DEBUG\", 0u);\n  parser->m_accounting.maximumAmplificationFactor\n      = EXPAT_BILLION_LAUGHS_ATTACK_PROTECTION_MAXIMUM_AMPLIFICATION_DEFAULT;\n  parser->m_accounting.activationThresholdBytes\n      = EXPAT_BILLION_LAUGHS_ATTACK_PROTECTION_ACTIVATION_THRESHOLD_DEFAULT;\n\n  memset(&parser->m_entity_stats, 0, sizeof(ENTITY_STATS));\n  parser->m_entity_stats.debugLevel = getDebugLevel(\"EXPAT_ENTITY_DEBUG\", 0u);\n#endif\n}",
        "func": "static void\nparserInit(XML_Parser parser, const XML_Char *encodingName) {\n  parser->m_processor = prologInitProcessor;\n  XmlPrologStateInit(&parser->m_prologState);\n  if (encodingName != NULL) {\n    parser->m_protocolEncodingName = copyString(encodingName, &(parser->m_mem));\n  }\n  parser->m_curBase = NULL;\n  XmlInitEncoding(&parser->m_initEncoding, &parser->m_encoding, 0);\n  parser->m_userData = NULL;\n  parser->m_handlerArg = NULL;\n  parser->m_startElementHandler = NULL;\n  parser->m_endElementHandler = NULL;\n  parser->m_characterDataHandler = NULL;\n  parser->m_processingInstructionHandler = NULL;\n  parser->m_commentHandler = NULL;\n  parser->m_startCdataSectionHandler = NULL;\n  parser->m_endCdataSectionHandler = NULL;\n  parser->m_defaultHandler = NULL;\n  parser->m_startDoctypeDeclHandler = NULL;\n  parser->m_endDoctypeDeclHandler = NULL;\n  parser->m_unparsedEntityDeclHandler = NULL;\n  parser->m_notationDeclHandler = NULL;\n  parser->m_startNamespaceDeclHandler = NULL;\n  parser->m_endNamespaceDeclHandler = NULL;\n  parser->m_notStandaloneHandler = NULL;\n  parser->m_externalEntityRefHandler = NULL;\n  parser->m_externalEntityRefHandlerArg = parser;\n  parser->m_skippedEntityHandler = NULL;\n  parser->m_elementDeclHandler = NULL;\n  parser->m_attlistDeclHandler = NULL;\n  parser->m_entityDeclHandler = NULL;\n  parser->m_xmlDeclHandler = NULL;\n  parser->m_bufferPtr = parser->m_buffer;\n  parser->m_bufferEnd = parser->m_buffer;\n  parser->m_parseEndByteIndex = 0;\n  parser->m_parseEndPtr = NULL;\n  parser->m_declElementType = NULL;\n  parser->m_declAttributeId = NULL;\n  parser->m_declEntity = NULL;\n  parser->m_doctypeName = NULL;\n  parser->m_doctypeSysid = NULL;\n  parser->m_doctypePubid = NULL;\n  parser->m_declAttributeType = NULL;\n  parser->m_declNotationName = NULL;\n  parser->m_declNotationPublicId = NULL;\n  parser->m_declAttributeIsCdata = XML_FALSE;\n  parser->m_declAttributeIsId = XML_FALSE;\n  memset(&parser->m_position, 0, sizeof(POSITION));\n  parser->m_errorCode = XML_ERROR_NONE;\n  parser->m_eventPtr = NULL;\n  parser->m_eventEndPtr = NULL;\n  parser->m_positionPtr = NULL;\n  parser->m_openInternalEntities = NULL;\n  parser->m_defaultExpandInternalEntities = XML_TRUE;\n  parser->m_tagLevel = 0;\n  parser->m_tagStack = NULL;\n  parser->m_inheritedBindings = NULL;\n  parser->m_nSpecifiedAtts = 0;\n  parser->m_unknownEncodingMem = NULL;\n  parser->m_unknownEncodingRelease = NULL;\n  parser->m_unknownEncodingData = NULL;\n  parser->m_parentParser = NULL;\n  parser->m_parsingStatus.parsing = XML_INITIALIZED;\n#ifdef XML_DTD\n  parser->m_isParamEntity = XML_FALSE;\n  parser->m_useForeignDTD = XML_FALSE;\n  parser->m_paramEntityParsing = XML_PARAM_ENTITY_PARSING_NEVER;\n#endif\n  parser->m_hash_secret_salt = 0;\n\n#if defined(XML_DTD) || XML_GE == 1\n  memset(&parser->m_accounting, 0, sizeof(ACCOUNTING));\n  parser->m_accounting.debugLevel = getDebugLevel(\"EXPAT_ACCOUNTING_DEBUG\", 0u);\n  parser->m_accounting.maximumAmplificationFactor\n      = EXPAT_BILLION_LAUGHS_ATTACK_PROTECTION_MAXIMUM_AMPLIFICATION_DEFAULT;\n  parser->m_accounting.activationThresholdBytes\n      = EXPAT_BILLION_LAUGHS_ATTACK_PROTECTION_ACTIVATION_THRESHOLD_DEFAULT;\n\n  memset(&parser->m_entity_stats, 0, sizeof(ENTITY_STATS));\n  parser->m_entity_stats.debugLevel = getDebugLevel(\"EXPAT_ENTITY_DEBUG\", 0u);\n#endif\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -69,7 +69,7 @@\n #endif\n   parser->m_hash_secret_salt = 0;\n \n-#ifdef XML_DTD\n+#if defined(XML_DTD) || XML_GE == 1\n   memset(&parser->m_accounting, 0, sizeof(ACCOUNTING));\n   parser->m_accounting.debugLevel = getDebugLevel(\"EXPAT_ACCOUNTING_DEBUG\", 0u);\n   parser->m_accounting.maximumAmplificationFactor",
        "diff_line_info": {
            "deleted_lines": [
                "#ifdef XML_DTD"
            ],
            "added_lines": [
                "#if defined(XML_DTD) || XML_GE == 1"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-52426",
        "func_name": "libexpat/storeEntityValue",
        "description": "libexpat through 2.5.0 allows recursive XML Entity Expansion if XML_DTD is undefined at compile time.",
        "git_url": "https://github.com/libexpat/libexpat/commit/0f075ec8ecb5e43f8fdca5182f8cca4703da0404",
        "commit_title": "lib|xmlwf|cmake: Extend scope of billion laughs attack protection",
        "commit_text": " .. from \"defined(XML_DTD)\" to \"defined(XML_DTD) || XML_GE==1\".",
        "func_before": "static enum XML_Error\nstoreEntityValue(XML_Parser parser, const ENCODING *enc,\n                 const char *entityTextPtr, const char *entityTextEnd,\n                 enum XML_Account account) {\n  DTD *const dtd = parser->m_dtd; /* save one level of indirection */\n  STRING_POOL *pool = &(dtd->entityValuePool);\n  enum XML_Error result = XML_ERROR_NONE;\n#ifdef XML_DTD\n  int oldInEntityValue = parser->m_prologState.inEntityValue;\n  parser->m_prologState.inEntityValue = 1;\n#else\n  UNUSED_P(account);\n#endif /* XML_DTD */\n  /* never return Null for the value argument in EntityDeclHandler,\n     since this would indicate an external entity; therefore we\n     have to make sure that entityValuePool.start is not null */\n  if (! pool->blocks) {\n    if (! poolGrow(pool))\n      return XML_ERROR_NO_MEMORY;\n  }\n\n  for (;;) {\n    const char *next\n        = entityTextPtr; /* XmlEntityValueTok doesn't always set the last arg */\n    int tok = XmlEntityValueTok(enc, entityTextPtr, entityTextEnd, &next);\n\n#ifdef XML_DTD\n    if (! accountingDiffTolerated(parser, tok, entityTextPtr, next, __LINE__,\n                                  account)) {\n      accountingOnAbort(parser);\n      result = XML_ERROR_AMPLIFICATION_LIMIT_BREACH;\n      goto endEntityValue;\n    }\n#endif\n\n    switch (tok) {\n    case XML_TOK_PARAM_ENTITY_REF:\n#ifdef XML_DTD\n      if (parser->m_isParamEntity || enc != parser->m_encoding) {\n        const XML_Char *name;\n        ENTITY *entity;\n        name = poolStoreString(&parser->m_tempPool, enc,\n                               entityTextPtr + enc->minBytesPerChar,\n                               next - enc->minBytesPerChar);\n        if (! name) {\n          result = XML_ERROR_NO_MEMORY;\n          goto endEntityValue;\n        }\n        entity = (ENTITY *)lookup(parser, &dtd->paramEntities, name, 0);\n        poolDiscard(&parser->m_tempPool);\n        if (! entity) {\n          /* not a well-formedness error - see XML 1.0: WFC Entity Declared */\n          /* cannot report skipped entity here - see comments on\n             parser->m_skippedEntityHandler\n          if (parser->m_skippedEntityHandler)\n            parser->m_skippedEntityHandler(parser->m_handlerArg, name, 0);\n          */\n          dtd->keepProcessing = dtd->standalone;\n          goto endEntityValue;\n        }\n        if (entity->open) {\n          if (enc == parser->m_encoding)\n            parser->m_eventPtr = entityTextPtr;\n          result = XML_ERROR_RECURSIVE_ENTITY_REF;\n          goto endEntityValue;\n        }\n        if (entity->systemId) {\n          if (parser->m_externalEntityRefHandler) {\n            dtd->paramEntityRead = XML_FALSE;\n            entity->open = XML_TRUE;\n            entityTrackingOnOpen(parser, entity, __LINE__);\n            if (! parser->m_externalEntityRefHandler(\n                    parser->m_externalEntityRefHandlerArg, 0, entity->base,\n                    entity->systemId, entity->publicId)) {\n              entityTrackingOnClose(parser, entity, __LINE__);\n              entity->open = XML_FALSE;\n              result = XML_ERROR_EXTERNAL_ENTITY_HANDLING;\n              goto endEntityValue;\n            }\n            entityTrackingOnClose(parser, entity, __LINE__);\n            entity->open = XML_FALSE;\n            if (! dtd->paramEntityRead)\n              dtd->keepProcessing = dtd->standalone;\n          } else\n            dtd->keepProcessing = dtd->standalone;\n        } else {\n          entity->open = XML_TRUE;\n          entityTrackingOnOpen(parser, entity, __LINE__);\n          result = storeEntityValue(\n              parser, parser->m_internalEncoding, (const char *)entity->textPtr,\n              (const char *)(entity->textPtr + entity->textLen),\n              XML_ACCOUNT_ENTITY_EXPANSION);\n          entityTrackingOnClose(parser, entity, __LINE__);\n          entity->open = XML_FALSE;\n          if (result)\n            goto endEntityValue;\n        }\n        break;\n      }\n#endif /* XML_DTD */\n      /* In the internal subset, PE references are not legal\n         within markup declarations, e.g entity values in this case. */\n      parser->m_eventPtr = entityTextPtr;\n      result = XML_ERROR_PARAM_ENTITY_REF;\n      goto endEntityValue;\n    case XML_TOK_NONE:\n      result = XML_ERROR_NONE;\n      goto endEntityValue;\n    case XML_TOK_ENTITY_REF:\n    case XML_TOK_DATA_CHARS:\n      if (! poolAppend(pool, enc, entityTextPtr, next)) {\n        result = XML_ERROR_NO_MEMORY;\n        goto endEntityValue;\n      }\n      break;\n    case XML_TOK_TRAILING_CR:\n      next = entityTextPtr + enc->minBytesPerChar;\n      /* fall through */\n    case XML_TOK_DATA_NEWLINE:\n      if (pool->end == pool->ptr && ! poolGrow(pool)) {\n        result = XML_ERROR_NO_MEMORY;\n        goto endEntityValue;\n      }\n      *(pool->ptr)++ = 0xA;\n      break;\n    case XML_TOK_CHAR_REF: {\n      XML_Char buf[XML_ENCODE_MAX];\n      int i;\n      int n = XmlCharRefNumber(enc, entityTextPtr);\n      if (n < 0) {\n        if (enc == parser->m_encoding)\n          parser->m_eventPtr = entityTextPtr;\n        result = XML_ERROR_BAD_CHAR_REF;\n        goto endEntityValue;\n      }\n      n = XmlEncode(n, (ICHAR *)buf);\n      /* The XmlEncode() functions can never return 0 here.  That\n       * error return happens if the code point passed in is either\n       * negative or greater than or equal to 0x110000.  The\n       * XmlCharRefNumber() functions will all return a number\n       * strictly less than 0x110000 or a negative value if an error\n       * occurred.  The negative value is intercepted above, so\n       * XmlEncode() is never passed a value it might return an\n       * error for.\n       */\n      for (i = 0; i < n; i++) {\n        if (pool->end == pool->ptr && ! poolGrow(pool)) {\n          result = XML_ERROR_NO_MEMORY;\n          goto endEntityValue;\n        }\n        *(pool->ptr)++ = buf[i];\n      }\n    } break;\n    case XML_TOK_PARTIAL:\n      if (enc == parser->m_encoding)\n        parser->m_eventPtr = entityTextPtr;\n      result = XML_ERROR_INVALID_TOKEN;\n      goto endEntityValue;\n    case XML_TOK_INVALID:\n      if (enc == parser->m_encoding)\n        parser->m_eventPtr = next;\n      result = XML_ERROR_INVALID_TOKEN;\n      goto endEntityValue;\n    default:\n      /* This default case should be unnecessary -- all the tokens\n       * that XmlEntityValueTok() can return have their own explicit\n       * cases -- but should be retained for safety.  We do however\n       * exclude it from the coverage statistics.\n       *\n       * LCOV_EXCL_START\n       */\n      if (enc == parser->m_encoding)\n        parser->m_eventPtr = entityTextPtr;\n      result = XML_ERROR_UNEXPECTED_STATE;\n      goto endEntityValue;\n      /* LCOV_EXCL_STOP */\n    }\n    entityTextPtr = next;\n  }\nendEntityValue:\n#ifdef XML_DTD\n  parser->m_prologState.inEntityValue = oldInEntityValue;\n#endif /* XML_DTD */\n  return result;\n}",
        "func": "static enum XML_Error\nstoreEntityValue(XML_Parser parser, const ENCODING *enc,\n                 const char *entityTextPtr, const char *entityTextEnd,\n                 enum XML_Account account) {\n  DTD *const dtd = parser->m_dtd; /* save one level of indirection */\n  STRING_POOL *pool = &(dtd->entityValuePool);\n  enum XML_Error result = XML_ERROR_NONE;\n#ifdef XML_DTD\n  int oldInEntityValue = parser->m_prologState.inEntityValue;\n  parser->m_prologState.inEntityValue = 1;\n#else\n  UNUSED_P(account);\n#endif /* XML_DTD */\n  /* never return Null for the value argument in EntityDeclHandler,\n     since this would indicate an external entity; therefore we\n     have to make sure that entityValuePool.start is not null */\n  if (! pool->blocks) {\n    if (! poolGrow(pool))\n      return XML_ERROR_NO_MEMORY;\n  }\n\n  for (;;) {\n    const char *next\n        = entityTextPtr; /* XmlEntityValueTok doesn't always set the last arg */\n    int tok = XmlEntityValueTok(enc, entityTextPtr, entityTextEnd, &next);\n\n#if defined(XML_DTD) || XML_GE == 1\n    if (! accountingDiffTolerated(parser, tok, entityTextPtr, next, __LINE__,\n                                  account)) {\n      accountingOnAbort(parser);\n      result = XML_ERROR_AMPLIFICATION_LIMIT_BREACH;\n      goto endEntityValue;\n    }\n#endif\n\n    switch (tok) {\n    case XML_TOK_PARAM_ENTITY_REF:\n#ifdef XML_DTD\n      if (parser->m_isParamEntity || enc != parser->m_encoding) {\n        const XML_Char *name;\n        ENTITY *entity;\n        name = poolStoreString(&parser->m_tempPool, enc,\n                               entityTextPtr + enc->minBytesPerChar,\n                               next - enc->minBytesPerChar);\n        if (! name) {\n          result = XML_ERROR_NO_MEMORY;\n          goto endEntityValue;\n        }\n        entity = (ENTITY *)lookup(parser, &dtd->paramEntities, name, 0);\n        poolDiscard(&parser->m_tempPool);\n        if (! entity) {\n          /* not a well-formedness error - see XML 1.0: WFC Entity Declared */\n          /* cannot report skipped entity here - see comments on\n             parser->m_skippedEntityHandler\n          if (parser->m_skippedEntityHandler)\n            parser->m_skippedEntityHandler(parser->m_handlerArg, name, 0);\n          */\n          dtd->keepProcessing = dtd->standalone;\n          goto endEntityValue;\n        }\n        if (entity->open) {\n          if (enc == parser->m_encoding)\n            parser->m_eventPtr = entityTextPtr;\n          result = XML_ERROR_RECURSIVE_ENTITY_REF;\n          goto endEntityValue;\n        }\n        if (entity->systemId) {\n          if (parser->m_externalEntityRefHandler) {\n            dtd->paramEntityRead = XML_FALSE;\n            entity->open = XML_TRUE;\n            entityTrackingOnOpen(parser, entity, __LINE__);\n            if (! parser->m_externalEntityRefHandler(\n                    parser->m_externalEntityRefHandlerArg, 0, entity->base,\n                    entity->systemId, entity->publicId)) {\n              entityTrackingOnClose(parser, entity, __LINE__);\n              entity->open = XML_FALSE;\n              result = XML_ERROR_EXTERNAL_ENTITY_HANDLING;\n              goto endEntityValue;\n            }\n            entityTrackingOnClose(parser, entity, __LINE__);\n            entity->open = XML_FALSE;\n            if (! dtd->paramEntityRead)\n              dtd->keepProcessing = dtd->standalone;\n          } else\n            dtd->keepProcessing = dtd->standalone;\n        } else {\n          entity->open = XML_TRUE;\n          entityTrackingOnOpen(parser, entity, __LINE__);\n          result = storeEntityValue(\n              parser, parser->m_internalEncoding, (const char *)entity->textPtr,\n              (const char *)(entity->textPtr + entity->textLen),\n              XML_ACCOUNT_ENTITY_EXPANSION);\n          entityTrackingOnClose(parser, entity, __LINE__);\n          entity->open = XML_FALSE;\n          if (result)\n            goto endEntityValue;\n        }\n        break;\n      }\n#endif /* XML_DTD */\n      /* In the internal subset, PE references are not legal\n         within markup declarations, e.g entity values in this case. */\n      parser->m_eventPtr = entityTextPtr;\n      result = XML_ERROR_PARAM_ENTITY_REF;\n      goto endEntityValue;\n    case XML_TOK_NONE:\n      result = XML_ERROR_NONE;\n      goto endEntityValue;\n    case XML_TOK_ENTITY_REF:\n    case XML_TOK_DATA_CHARS:\n      if (! poolAppend(pool, enc, entityTextPtr, next)) {\n        result = XML_ERROR_NO_MEMORY;\n        goto endEntityValue;\n      }\n      break;\n    case XML_TOK_TRAILING_CR:\n      next = entityTextPtr + enc->minBytesPerChar;\n      /* fall through */\n    case XML_TOK_DATA_NEWLINE:\n      if (pool->end == pool->ptr && ! poolGrow(pool)) {\n        result = XML_ERROR_NO_MEMORY;\n        goto endEntityValue;\n      }\n      *(pool->ptr)++ = 0xA;\n      break;\n    case XML_TOK_CHAR_REF: {\n      XML_Char buf[XML_ENCODE_MAX];\n      int i;\n      int n = XmlCharRefNumber(enc, entityTextPtr);\n      if (n < 0) {\n        if (enc == parser->m_encoding)\n          parser->m_eventPtr = entityTextPtr;\n        result = XML_ERROR_BAD_CHAR_REF;\n        goto endEntityValue;\n      }\n      n = XmlEncode(n, (ICHAR *)buf);\n      /* The XmlEncode() functions can never return 0 here.  That\n       * error return happens if the code point passed in is either\n       * negative or greater than or equal to 0x110000.  The\n       * XmlCharRefNumber() functions will all return a number\n       * strictly less than 0x110000 or a negative value if an error\n       * occurred.  The negative value is intercepted above, so\n       * XmlEncode() is never passed a value it might return an\n       * error for.\n       */\n      for (i = 0; i < n; i++) {\n        if (pool->end == pool->ptr && ! poolGrow(pool)) {\n          result = XML_ERROR_NO_MEMORY;\n          goto endEntityValue;\n        }\n        *(pool->ptr)++ = buf[i];\n      }\n    } break;\n    case XML_TOK_PARTIAL:\n      if (enc == parser->m_encoding)\n        parser->m_eventPtr = entityTextPtr;\n      result = XML_ERROR_INVALID_TOKEN;\n      goto endEntityValue;\n    case XML_TOK_INVALID:\n      if (enc == parser->m_encoding)\n        parser->m_eventPtr = next;\n      result = XML_ERROR_INVALID_TOKEN;\n      goto endEntityValue;\n    default:\n      /* This default case should be unnecessary -- all the tokens\n       * that XmlEntityValueTok() can return have their own explicit\n       * cases -- but should be retained for safety.  We do however\n       * exclude it from the coverage statistics.\n       *\n       * LCOV_EXCL_START\n       */\n      if (enc == parser->m_encoding)\n        parser->m_eventPtr = entityTextPtr;\n      result = XML_ERROR_UNEXPECTED_STATE;\n      goto endEntityValue;\n      /* LCOV_EXCL_STOP */\n    }\n    entityTextPtr = next;\n  }\nendEntityValue:\n#ifdef XML_DTD\n  parser->m_prologState.inEntityValue = oldInEntityValue;\n#endif /* XML_DTD */\n  return result;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -24,7 +24,7 @@\n         = entityTextPtr; /* XmlEntityValueTok doesn't always set the last arg */\n     int tok = XmlEntityValueTok(enc, entityTextPtr, entityTextEnd, &next);\n \n-#ifdef XML_DTD\n+#if defined(XML_DTD) || XML_GE == 1\n     if (! accountingDiffTolerated(parser, tok, entityTextPtr, next, __LINE__,\n                                   account)) {\n       accountingOnAbort(parser);",
        "diff_line_info": {
            "deleted_lines": [
                "#ifdef XML_DTD"
            ],
            "added_lines": [
                "#if defined(XML_DTD) || XML_GE == 1"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-52426",
        "func_name": "libexpat/externalEntityInitProcessor2",
        "description": "libexpat through 2.5.0 allows recursive XML Entity Expansion if XML_DTD is undefined at compile time.",
        "git_url": "https://github.com/libexpat/libexpat/commit/0f075ec8ecb5e43f8fdca5182f8cca4703da0404",
        "commit_title": "lib|xmlwf|cmake: Extend scope of billion laughs attack protection",
        "commit_text": " .. from \"defined(XML_DTD)\" to \"defined(XML_DTD) || XML_GE==1\".",
        "func_before": "static enum XML_Error PTRCALL\nexternalEntityInitProcessor2(XML_Parser parser, const char *start,\n                             const char *end, const char **endPtr) {\n  const char *next = start; /* XmlContentTok doesn't always set the last arg */\n  int tok = XmlContentTok(parser->m_encoding, start, end, &next);\n  switch (tok) {\n  case XML_TOK_BOM:\n#ifdef XML_DTD\n    if (! accountingDiffTolerated(parser, tok, start, next, __LINE__,\n                                  XML_ACCOUNT_DIRECT)) {\n      accountingOnAbort(parser);\n      return XML_ERROR_AMPLIFICATION_LIMIT_BREACH;\n    }\n#endif /* XML_DTD */\n\n    /* If we are at the end of the buffer, this would cause the next stage,\n       i.e. externalEntityInitProcessor3, to pass control directly to\n       doContent (by detecting XML_TOK_NONE) without processing any xml text\n       declaration - causing the error XML_ERROR_MISPLACED_XML_PI in doContent.\n    */\n    if (next == end && ! parser->m_parsingStatus.finalBuffer) {\n      *endPtr = next;\n      return XML_ERROR_NONE;\n    }\n    start = next;\n    break;\n  case XML_TOK_PARTIAL:\n    if (! parser->m_parsingStatus.finalBuffer) {\n      *endPtr = start;\n      return XML_ERROR_NONE;\n    }\n    parser->m_eventPtr = start;\n    return XML_ERROR_UNCLOSED_TOKEN;\n  case XML_TOK_PARTIAL_CHAR:\n    if (! parser->m_parsingStatus.finalBuffer) {\n      *endPtr = start;\n      return XML_ERROR_NONE;\n    }\n    parser->m_eventPtr = start;\n    return XML_ERROR_PARTIAL_CHAR;\n  }\n  parser->m_processor = externalEntityInitProcessor3;\n  return externalEntityInitProcessor3(parser, start, end, endPtr);\n}",
        "func": "static enum XML_Error PTRCALL\nexternalEntityInitProcessor2(XML_Parser parser, const char *start,\n                             const char *end, const char **endPtr) {\n  const char *next = start; /* XmlContentTok doesn't always set the last arg */\n  int tok = XmlContentTok(parser->m_encoding, start, end, &next);\n  switch (tok) {\n  case XML_TOK_BOM:\n#if defined(XML_DTD) || XML_GE == 1\n    if (! accountingDiffTolerated(parser, tok, start, next, __LINE__,\n                                  XML_ACCOUNT_DIRECT)) {\n      accountingOnAbort(parser);\n      return XML_ERROR_AMPLIFICATION_LIMIT_BREACH;\n    }\n#endif /* defined(XML_DTD) || XML_GE == 1 */\n\n    /* If we are at the end of the buffer, this would cause the next stage,\n       i.e. externalEntityInitProcessor3, to pass control directly to\n       doContent (by detecting XML_TOK_NONE) without processing any xml text\n       declaration - causing the error XML_ERROR_MISPLACED_XML_PI in doContent.\n    */\n    if (next == end && ! parser->m_parsingStatus.finalBuffer) {\n      *endPtr = next;\n      return XML_ERROR_NONE;\n    }\n    start = next;\n    break;\n  case XML_TOK_PARTIAL:\n    if (! parser->m_parsingStatus.finalBuffer) {\n      *endPtr = start;\n      return XML_ERROR_NONE;\n    }\n    parser->m_eventPtr = start;\n    return XML_ERROR_UNCLOSED_TOKEN;\n  case XML_TOK_PARTIAL_CHAR:\n    if (! parser->m_parsingStatus.finalBuffer) {\n      *endPtr = start;\n      return XML_ERROR_NONE;\n    }\n    parser->m_eventPtr = start;\n    return XML_ERROR_PARTIAL_CHAR;\n  }\n  parser->m_processor = externalEntityInitProcessor3;\n  return externalEntityInitProcessor3(parser, start, end, endPtr);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,13 +5,13 @@\n   int tok = XmlContentTok(parser->m_encoding, start, end, &next);\n   switch (tok) {\n   case XML_TOK_BOM:\n-#ifdef XML_DTD\n+#if defined(XML_DTD) || XML_GE == 1\n     if (! accountingDiffTolerated(parser, tok, start, next, __LINE__,\n                                   XML_ACCOUNT_DIRECT)) {\n       accountingOnAbort(parser);\n       return XML_ERROR_AMPLIFICATION_LIMIT_BREACH;\n     }\n-#endif /* XML_DTD */\n+#endif /* defined(XML_DTD) || XML_GE == 1 */\n \n     /* If we are at the end of the buffer, this would cause the next stage,\n        i.e. externalEntityInitProcessor3, to pass control directly to",
        "diff_line_info": {
            "deleted_lines": [
                "#ifdef XML_DTD",
                "#endif /* XML_DTD */"
            ],
            "added_lines": [
                "#if defined(XML_DTD) || XML_GE == 1",
                "#endif /* defined(XML_DTD) || XML_GE == 1 */"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-52426",
        "func_name": "libexpat/processXmlDecl",
        "description": "libexpat through 2.5.0 allows recursive XML Entity Expansion if XML_DTD is undefined at compile time.",
        "git_url": "https://github.com/libexpat/libexpat/commit/0f075ec8ecb5e43f8fdca5182f8cca4703da0404",
        "commit_title": "lib|xmlwf|cmake: Extend scope of billion laughs attack protection",
        "commit_text": " .. from \"defined(XML_DTD)\" to \"defined(XML_DTD) || XML_GE==1\".",
        "func_before": "static enum XML_Error\nprocessXmlDecl(XML_Parser parser, int isGeneralTextEntity, const char *s,\n               const char *next) {\n  const char *encodingName = NULL;\n  const XML_Char *storedEncName = NULL;\n  const ENCODING *newEncoding = NULL;\n  const char *version = NULL;\n  const char *versionend = NULL;\n  const XML_Char *storedversion = NULL;\n  int standalone = -1;\n\n#ifdef XML_DTD\n  if (! accountingDiffTolerated(parser, XML_TOK_XML_DECL, s, next, __LINE__,\n                                XML_ACCOUNT_DIRECT)) {\n    accountingOnAbort(parser);\n    return XML_ERROR_AMPLIFICATION_LIMIT_BREACH;\n  }\n#endif\n\n  if (! (parser->m_ns ? XmlParseXmlDeclNS : XmlParseXmlDecl)(\n          isGeneralTextEntity, parser->m_encoding, s, next, &parser->m_eventPtr,\n          &version, &versionend, &encodingName, &newEncoding, &standalone)) {\n    if (isGeneralTextEntity)\n      return XML_ERROR_TEXT_DECL;\n    else\n      return XML_ERROR_XML_DECL;\n  }\n  if (! isGeneralTextEntity && standalone == 1) {\n    parser->m_dtd->standalone = XML_TRUE;\n#ifdef XML_DTD\n    if (parser->m_paramEntityParsing\n        == XML_PARAM_ENTITY_PARSING_UNLESS_STANDALONE)\n      parser->m_paramEntityParsing = XML_PARAM_ENTITY_PARSING_NEVER;\n#endif /* XML_DTD */\n  }\n  if (parser->m_xmlDeclHandler) {\n    if (encodingName != NULL) {\n      storedEncName = poolStoreString(\n          &parser->m_temp2Pool, parser->m_encoding, encodingName,\n          encodingName + XmlNameLength(parser->m_encoding, encodingName));\n      if (! storedEncName)\n        return XML_ERROR_NO_MEMORY;\n      poolFinish(&parser->m_temp2Pool);\n    }\n    if (version) {\n      storedversion\n          = poolStoreString(&parser->m_temp2Pool, parser->m_encoding, version,\n                            versionend - parser->m_encoding->minBytesPerChar);\n      if (! storedversion)\n        return XML_ERROR_NO_MEMORY;\n    }\n    parser->m_xmlDeclHandler(parser->m_handlerArg, storedversion, storedEncName,\n                             standalone);\n  } else if (parser->m_defaultHandler)\n    reportDefault(parser, parser->m_encoding, s, next);\n  if (parser->m_protocolEncodingName == NULL) {\n    if (newEncoding) {\n      /* Check that the specified encoding does not conflict with what\n       * the parser has already deduced.  Do we have the same number\n       * of bytes in the smallest representation of a character?  If\n       * this is UTF-16, is it the same endianness?\n       */\n      if (newEncoding->minBytesPerChar != parser->m_encoding->minBytesPerChar\n          || (newEncoding->minBytesPerChar == 2\n              && newEncoding != parser->m_encoding)) {\n        parser->m_eventPtr = encodingName;\n        return XML_ERROR_INCORRECT_ENCODING;\n      }\n      parser->m_encoding = newEncoding;\n    } else if (encodingName) {\n      enum XML_Error result;\n      if (! storedEncName) {\n        storedEncName = poolStoreString(\n            &parser->m_temp2Pool, parser->m_encoding, encodingName,\n            encodingName + XmlNameLength(parser->m_encoding, encodingName));\n        if (! storedEncName)\n          return XML_ERROR_NO_MEMORY;\n      }\n      result = handleUnknownEncoding(parser, storedEncName);\n      poolClear(&parser->m_temp2Pool);\n      if (result == XML_ERROR_UNKNOWN_ENCODING)\n        parser->m_eventPtr = encodingName;\n      return result;\n    }\n  }\n\n  if (storedEncName || storedversion)\n    poolClear(&parser->m_temp2Pool);\n\n  return XML_ERROR_NONE;\n}",
        "func": "static enum XML_Error\nprocessXmlDecl(XML_Parser parser, int isGeneralTextEntity, const char *s,\n               const char *next) {\n  const char *encodingName = NULL;\n  const XML_Char *storedEncName = NULL;\n  const ENCODING *newEncoding = NULL;\n  const char *version = NULL;\n  const char *versionend = NULL;\n  const XML_Char *storedversion = NULL;\n  int standalone = -1;\n\n#if defined(XML_DTD) || XML_GE == 1\n  if (! accountingDiffTolerated(parser, XML_TOK_XML_DECL, s, next, __LINE__,\n                                XML_ACCOUNT_DIRECT)) {\n    accountingOnAbort(parser);\n    return XML_ERROR_AMPLIFICATION_LIMIT_BREACH;\n  }\n#endif\n\n  if (! (parser->m_ns ? XmlParseXmlDeclNS : XmlParseXmlDecl)(\n          isGeneralTextEntity, parser->m_encoding, s, next, &parser->m_eventPtr,\n          &version, &versionend, &encodingName, &newEncoding, &standalone)) {\n    if (isGeneralTextEntity)\n      return XML_ERROR_TEXT_DECL;\n    else\n      return XML_ERROR_XML_DECL;\n  }\n  if (! isGeneralTextEntity && standalone == 1) {\n    parser->m_dtd->standalone = XML_TRUE;\n#ifdef XML_DTD\n    if (parser->m_paramEntityParsing\n        == XML_PARAM_ENTITY_PARSING_UNLESS_STANDALONE)\n      parser->m_paramEntityParsing = XML_PARAM_ENTITY_PARSING_NEVER;\n#endif /* XML_DTD */\n  }\n  if (parser->m_xmlDeclHandler) {\n    if (encodingName != NULL) {\n      storedEncName = poolStoreString(\n          &parser->m_temp2Pool, parser->m_encoding, encodingName,\n          encodingName + XmlNameLength(parser->m_encoding, encodingName));\n      if (! storedEncName)\n        return XML_ERROR_NO_MEMORY;\n      poolFinish(&parser->m_temp2Pool);\n    }\n    if (version) {\n      storedversion\n          = poolStoreString(&parser->m_temp2Pool, parser->m_encoding, version,\n                            versionend - parser->m_encoding->minBytesPerChar);\n      if (! storedversion)\n        return XML_ERROR_NO_MEMORY;\n    }\n    parser->m_xmlDeclHandler(parser->m_handlerArg, storedversion, storedEncName,\n                             standalone);\n  } else if (parser->m_defaultHandler)\n    reportDefault(parser, parser->m_encoding, s, next);\n  if (parser->m_protocolEncodingName == NULL) {\n    if (newEncoding) {\n      /* Check that the specified encoding does not conflict with what\n       * the parser has already deduced.  Do we have the same number\n       * of bytes in the smallest representation of a character?  If\n       * this is UTF-16, is it the same endianness?\n       */\n      if (newEncoding->minBytesPerChar != parser->m_encoding->minBytesPerChar\n          || (newEncoding->minBytesPerChar == 2\n              && newEncoding != parser->m_encoding)) {\n        parser->m_eventPtr = encodingName;\n        return XML_ERROR_INCORRECT_ENCODING;\n      }\n      parser->m_encoding = newEncoding;\n    } else if (encodingName) {\n      enum XML_Error result;\n      if (! storedEncName) {\n        storedEncName = poolStoreString(\n            &parser->m_temp2Pool, parser->m_encoding, encodingName,\n            encodingName + XmlNameLength(parser->m_encoding, encodingName));\n        if (! storedEncName)\n          return XML_ERROR_NO_MEMORY;\n      }\n      result = handleUnknownEncoding(parser, storedEncName);\n      poolClear(&parser->m_temp2Pool);\n      if (result == XML_ERROR_UNKNOWN_ENCODING)\n        parser->m_eventPtr = encodingName;\n      return result;\n    }\n  }\n\n  if (storedEncName || storedversion)\n    poolClear(&parser->m_temp2Pool);\n\n  return XML_ERROR_NONE;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -9,7 +9,7 @@\n   const XML_Char *storedversion = NULL;\n   int standalone = -1;\n \n-#ifdef XML_DTD\n+#if defined(XML_DTD) || XML_GE == 1\n   if (! accountingDiffTolerated(parser, XML_TOK_XML_DECL, s, next, __LINE__,\n                                 XML_ACCOUNT_DIRECT)) {\n     accountingOnAbort(parser);",
        "diff_line_info": {
            "deleted_lines": [
                "#ifdef XML_DTD"
            ],
            "added_lines": [
                "#if defined(XML_DTD) || XML_GE == 1"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-52426",
        "func_name": "libexpat/XML_GetFeatureList",
        "description": "libexpat through 2.5.0 allows recursive XML Entity Expansion if XML_DTD is undefined at compile time.",
        "git_url": "https://github.com/libexpat/libexpat/commit/0f075ec8ecb5e43f8fdca5182f8cca4703da0404",
        "commit_title": "lib|xmlwf|cmake: Extend scope of billion laughs attack protection",
        "commit_text": " .. from \"defined(XML_DTD)\" to \"defined(XML_DTD) || XML_GE==1\".",
        "func_before": "const XML_Feature *XMLCALL\nXML_GetFeatureList(void) {\n  static const XML_Feature features[] = {\n    {XML_FEATURE_SIZEOF_XML_CHAR, XML_L(\"sizeof(XML_Char)\"), sizeof(XML_Char)},\n    {XML_FEATURE_SIZEOF_XML_LCHAR, XML_L(\"sizeof(XML_LChar)\"),\n     sizeof(XML_LChar)},\n#ifdef XML_UNICODE\n    {XML_FEATURE_UNICODE, XML_L(\"XML_UNICODE\"), 0},\n#endif\n#ifdef XML_UNICODE_WCHAR_T\n    {XML_FEATURE_UNICODE_WCHAR_T, XML_L(\"XML_UNICODE_WCHAR_T\"), 0},\n#endif\n#ifdef XML_DTD\n    {XML_FEATURE_DTD, XML_L(\"XML_DTD\"), 0},\n#endif\n#if XML_CONTEXT_BYTES > 0\n    {XML_FEATURE_CONTEXT_BYTES, XML_L(\"XML_CONTEXT_BYTES\"), XML_CONTEXT_BYTES},\n#endif\n#ifdef XML_MIN_SIZE\n    {XML_FEATURE_MIN_SIZE, XML_L(\"XML_MIN_SIZE\"), 0},\n#endif\n#ifdef XML_NS\n    {XML_FEATURE_NS, XML_L(\"XML_NS\"), 0},\n#endif\n#ifdef XML_LARGE_SIZE\n    {XML_FEATURE_LARGE_SIZE, XML_L(\"XML_LARGE_SIZE\"), 0},\n#endif\n#ifdef XML_ATTR_INFO\n    {XML_FEATURE_ATTR_INFO, XML_L(\"XML_ATTR_INFO\"), 0},\n#endif\n#ifdef XML_DTD\n    /* Added in Expat 2.4.0. */\n    {XML_FEATURE_BILLION_LAUGHS_ATTACK_PROTECTION_MAXIMUM_AMPLIFICATION_DEFAULT,\n     XML_L(\"XML_BLAP_MAX_AMP\"),\n     (long int)\n         EXPAT_BILLION_LAUGHS_ATTACK_PROTECTION_MAXIMUM_AMPLIFICATION_DEFAULT},\n    {XML_FEATURE_BILLION_LAUGHS_ATTACK_PROTECTION_ACTIVATION_THRESHOLD_DEFAULT,\n     XML_L(\"XML_BLAP_ACT_THRES\"),\n     EXPAT_BILLION_LAUGHS_ATTACK_PROTECTION_ACTIVATION_THRESHOLD_DEFAULT},\n#endif\n    {XML_FEATURE_END, NULL, 0}\n  };\n\n  return features;\n}",
        "func": "const XML_Feature *XMLCALL\nXML_GetFeatureList(void) {\n  static const XML_Feature features[] = {\n    {XML_FEATURE_SIZEOF_XML_CHAR, XML_L(\"sizeof(XML_Char)\"), sizeof(XML_Char)},\n    {XML_FEATURE_SIZEOF_XML_LCHAR, XML_L(\"sizeof(XML_LChar)\"),\n     sizeof(XML_LChar)},\n#ifdef XML_UNICODE\n    {XML_FEATURE_UNICODE, XML_L(\"XML_UNICODE\"), 0},\n#endif\n#ifdef XML_UNICODE_WCHAR_T\n    {XML_FEATURE_UNICODE_WCHAR_T, XML_L(\"XML_UNICODE_WCHAR_T\"), 0},\n#endif\n#ifdef XML_DTD\n    {XML_FEATURE_DTD, XML_L(\"XML_DTD\"), 0},\n#endif\n#if XML_CONTEXT_BYTES > 0\n    {XML_FEATURE_CONTEXT_BYTES, XML_L(\"XML_CONTEXT_BYTES\"), XML_CONTEXT_BYTES},\n#endif\n#ifdef XML_MIN_SIZE\n    {XML_FEATURE_MIN_SIZE, XML_L(\"XML_MIN_SIZE\"), 0},\n#endif\n#ifdef XML_NS\n    {XML_FEATURE_NS, XML_L(\"XML_NS\"), 0},\n#endif\n#ifdef XML_LARGE_SIZE\n    {XML_FEATURE_LARGE_SIZE, XML_L(\"XML_LARGE_SIZE\"), 0},\n#endif\n#ifdef XML_ATTR_INFO\n    {XML_FEATURE_ATTR_INFO, XML_L(\"XML_ATTR_INFO\"), 0},\n#endif\n#if defined(XML_DTD) || XML_GE == 1\n    /* Added in Expat 2.4.0 for XML_DTD defined and\n     * added in Expat 2.6.0 for XML_GE == 1. */\n    {XML_FEATURE_BILLION_LAUGHS_ATTACK_PROTECTION_MAXIMUM_AMPLIFICATION_DEFAULT,\n     XML_L(\"XML_BLAP_MAX_AMP\"),\n     (long int)\n         EXPAT_BILLION_LAUGHS_ATTACK_PROTECTION_MAXIMUM_AMPLIFICATION_DEFAULT},\n    {XML_FEATURE_BILLION_LAUGHS_ATTACK_PROTECTION_ACTIVATION_THRESHOLD_DEFAULT,\n     XML_L(\"XML_BLAP_ACT_THRES\"),\n     EXPAT_BILLION_LAUGHS_ATTACK_PROTECTION_ACTIVATION_THRESHOLD_DEFAULT},\n#endif\n    {XML_FEATURE_END, NULL, 0}\n  };\n\n  return features;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -28,8 +28,9 @@\n #ifdef XML_ATTR_INFO\n     {XML_FEATURE_ATTR_INFO, XML_L(\"XML_ATTR_INFO\"), 0},\n #endif\n-#ifdef XML_DTD\n-    /* Added in Expat 2.4.0. */\n+#if defined(XML_DTD) || XML_GE == 1\n+    /* Added in Expat 2.4.0 for XML_DTD defined and\n+     * added in Expat 2.6.0 for XML_GE == 1. */\n     {XML_FEATURE_BILLION_LAUGHS_ATTACK_PROTECTION_MAXIMUM_AMPLIFICATION_DEFAULT,\n      XML_L(\"XML_BLAP_MAX_AMP\"),\n      (long int)",
        "diff_line_info": {
            "deleted_lines": [
                "#ifdef XML_DTD",
                "    /* Added in Expat 2.4.0. */"
            ],
            "added_lines": [
                "#if defined(XML_DTD) || XML_GE == 1",
                "    /* Added in Expat 2.4.0 for XML_DTD defined and",
                "     * added in Expat 2.6.0 for XML_GE == 1. */"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-52426",
        "func_name": "libexpat/internalEntityProcessor",
        "description": "libexpat through 2.5.0 allows recursive XML Entity Expansion if XML_DTD is undefined at compile time.",
        "git_url": "https://github.com/libexpat/libexpat/commit/0f075ec8ecb5e43f8fdca5182f8cca4703da0404",
        "commit_title": "lib|xmlwf|cmake: Extend scope of billion laughs attack protection",
        "commit_text": " .. from \"defined(XML_DTD)\" to \"defined(XML_DTD) || XML_GE==1\".",
        "func_before": "static enum XML_Error PTRCALL\ninternalEntityProcessor(XML_Parser parser, const char *s, const char *end,\n                        const char **nextPtr) {\n  ENTITY *entity;\n  const char *textStart, *textEnd;\n  const char *next;\n  enum XML_Error result;\n  OPEN_INTERNAL_ENTITY *openEntity = parser->m_openInternalEntities;\n  if (! openEntity)\n    return XML_ERROR_UNEXPECTED_STATE;\n\n  entity = openEntity->entity;\n  textStart = ((const char *)entity->textPtr) + entity->processed;\n  textEnd = (const char *)(entity->textPtr + entity->textLen);\n  /* Set a safe default value in case 'next' does not get set */\n  next = textStart;\n\n#ifdef XML_DTD\n  if (entity->is_param) {\n    int tok\n        = XmlPrologTok(parser->m_internalEncoding, textStart, textEnd, &next);\n    result = doProlog(parser, parser->m_internalEncoding, textStart, textEnd,\n                      tok, next, &next, XML_FALSE, XML_TRUE,\n                      XML_ACCOUNT_ENTITY_EXPANSION);\n  } else\n#endif /* XML_DTD */\n    result = doContent(parser, openEntity->startTagLevel,\n                       parser->m_internalEncoding, textStart, textEnd, &next,\n                       XML_FALSE, XML_ACCOUNT_ENTITY_EXPANSION);\n\n  if (result != XML_ERROR_NONE)\n    return result;\n\n  if (textEnd != next && parser->m_parsingStatus.parsing == XML_SUSPENDED) {\n    entity->processed = (int)(next - (const char *)entity->textPtr);\n    return result;\n  }\n\n#ifdef XML_DTD\n  entityTrackingOnClose(parser, entity, __LINE__);\n#endif\n  entity->open = XML_FALSE;\n  parser->m_openInternalEntities = openEntity->next;\n  /* put openEntity back in list of free instances */\n  openEntity->next = parser->m_freeInternalEntities;\n  parser->m_freeInternalEntities = openEntity;\n\n  // If there are more open entities we want to stop right here and have the\n  // upcoming call to XML_ResumeParser continue with entity content, or it would\n  // be ignored altogether.\n  if (parser->m_openInternalEntities != NULL\n      && parser->m_parsingStatus.parsing == XML_SUSPENDED) {\n    return XML_ERROR_NONE;\n  }\n\n#ifdef XML_DTD\n  if (entity->is_param) {\n    int tok;\n    parser->m_processor = prologProcessor;\n    tok = XmlPrologTok(parser->m_encoding, s, end, &next);\n    return doProlog(parser, parser->m_encoding, s, end, tok, next, nextPtr,\n                    (XML_Bool)! parser->m_parsingStatus.finalBuffer, XML_TRUE,\n                    XML_ACCOUNT_DIRECT);\n  } else\n#endif /* XML_DTD */\n  {\n    parser->m_processor = contentProcessor;\n    /* see externalEntityContentProcessor vs contentProcessor */\n    result = doContent(parser, parser->m_parentParser ? 1 : 0,\n                       parser->m_encoding, s, end, nextPtr,\n                       (XML_Bool)! parser->m_parsingStatus.finalBuffer,\n                       XML_ACCOUNT_DIRECT);\n    if (result == XML_ERROR_NONE) {\n      if (! storeRawNames(parser))\n        return XML_ERROR_NO_MEMORY;\n    }\n    return result;\n  }\n}",
        "func": "static enum XML_Error PTRCALL\ninternalEntityProcessor(XML_Parser parser, const char *s, const char *end,\n                        const char **nextPtr) {\n  ENTITY *entity;\n  const char *textStart, *textEnd;\n  const char *next;\n  enum XML_Error result;\n  OPEN_INTERNAL_ENTITY *openEntity = parser->m_openInternalEntities;\n  if (! openEntity)\n    return XML_ERROR_UNEXPECTED_STATE;\n\n  entity = openEntity->entity;\n  textStart = ((const char *)entity->textPtr) + entity->processed;\n  textEnd = (const char *)(entity->textPtr + entity->textLen);\n  /* Set a safe default value in case 'next' does not get set */\n  next = textStart;\n\n#ifdef XML_DTD\n  if (entity->is_param) {\n    int tok\n        = XmlPrologTok(parser->m_internalEncoding, textStart, textEnd, &next);\n    result = doProlog(parser, parser->m_internalEncoding, textStart, textEnd,\n                      tok, next, &next, XML_FALSE, XML_TRUE,\n                      XML_ACCOUNT_ENTITY_EXPANSION);\n  } else\n#endif /* XML_DTD */\n    result = doContent(parser, openEntity->startTagLevel,\n                       parser->m_internalEncoding, textStart, textEnd, &next,\n                       XML_FALSE, XML_ACCOUNT_ENTITY_EXPANSION);\n\n  if (result != XML_ERROR_NONE)\n    return result;\n\n  if (textEnd != next && parser->m_parsingStatus.parsing == XML_SUSPENDED) {\n    entity->processed = (int)(next - (const char *)entity->textPtr);\n    return result;\n  }\n\n#if defined(XML_DTD) || XML_GE == 1\n  entityTrackingOnClose(parser, entity, __LINE__);\n#endif\n  entity->open = XML_FALSE;\n  parser->m_openInternalEntities = openEntity->next;\n  /* put openEntity back in list of free instances */\n  openEntity->next = parser->m_freeInternalEntities;\n  parser->m_freeInternalEntities = openEntity;\n\n  // If there are more open entities we want to stop right here and have the\n  // upcoming call to XML_ResumeParser continue with entity content, or it would\n  // be ignored altogether.\n  if (parser->m_openInternalEntities != NULL\n      && parser->m_parsingStatus.parsing == XML_SUSPENDED) {\n    return XML_ERROR_NONE;\n  }\n\n#ifdef XML_DTD\n  if (entity->is_param) {\n    int tok;\n    parser->m_processor = prologProcessor;\n    tok = XmlPrologTok(parser->m_encoding, s, end, &next);\n    return doProlog(parser, parser->m_encoding, s, end, tok, next, nextPtr,\n                    (XML_Bool)! parser->m_parsingStatus.finalBuffer, XML_TRUE,\n                    XML_ACCOUNT_DIRECT);\n  } else\n#endif /* XML_DTD */\n  {\n    parser->m_processor = contentProcessor;\n    /* see externalEntityContentProcessor vs contentProcessor */\n    result = doContent(parser, parser->m_parentParser ? 1 : 0,\n                       parser->m_encoding, s, end, nextPtr,\n                       (XML_Bool)! parser->m_parsingStatus.finalBuffer,\n                       XML_ACCOUNT_DIRECT);\n    if (result == XML_ERROR_NONE) {\n      if (! storeRawNames(parser))\n        return XML_ERROR_NO_MEMORY;\n    }\n    return result;\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -36,7 +36,7 @@\n     return result;\n   }\n \n-#ifdef XML_DTD\n+#if defined(XML_DTD) || XML_GE == 1\n   entityTrackingOnClose(parser, entity, __LINE__);\n #endif\n   entity->open = XML_FALSE;",
        "diff_line_info": {
            "deleted_lines": [
                "#ifdef XML_DTD"
            ],
            "added_lines": [
                "#if defined(XML_DTD) || XML_GE == 1"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-52426",
        "func_name": "libexpat/epilogProcessor",
        "description": "libexpat through 2.5.0 allows recursive XML Entity Expansion if XML_DTD is undefined at compile time.",
        "git_url": "https://github.com/libexpat/libexpat/commit/0f075ec8ecb5e43f8fdca5182f8cca4703da0404",
        "commit_title": "lib|xmlwf|cmake: Extend scope of billion laughs attack protection",
        "commit_text": " .. from \"defined(XML_DTD)\" to \"defined(XML_DTD) || XML_GE==1\".",
        "func_before": "static enum XML_Error PTRCALL\nepilogProcessor(XML_Parser parser, const char *s, const char *end,\n                const char **nextPtr) {\n  parser->m_processor = epilogProcessor;\n  parser->m_eventPtr = s;\n  for (;;) {\n    const char *next = NULL;\n    int tok = XmlPrologTok(parser->m_encoding, s, end, &next);\n#ifdef XML_DTD\n    if (! accountingDiffTolerated(parser, tok, s, next, __LINE__,\n                                  XML_ACCOUNT_DIRECT)) {\n      accountingOnAbort(parser);\n      return XML_ERROR_AMPLIFICATION_LIMIT_BREACH;\n    }\n#endif\n    parser->m_eventEndPtr = next;\n    switch (tok) {\n    /* report partial linebreak - it might be the last token */\n    case -XML_TOK_PROLOG_S:\n      if (parser->m_defaultHandler) {\n        reportDefault(parser, parser->m_encoding, s, next);\n        if (parser->m_parsingStatus.parsing == XML_FINISHED)\n          return XML_ERROR_ABORTED;\n      }\n      *nextPtr = next;\n      return XML_ERROR_NONE;\n    case XML_TOK_NONE:\n      *nextPtr = s;\n      return XML_ERROR_NONE;\n    case XML_TOK_PROLOG_S:\n      if (parser->m_defaultHandler)\n        reportDefault(parser, parser->m_encoding, s, next);\n      break;\n    case XML_TOK_PI:\n      if (! reportProcessingInstruction(parser, parser->m_encoding, s, next))\n        return XML_ERROR_NO_MEMORY;\n      break;\n    case XML_TOK_COMMENT:\n      if (! reportComment(parser, parser->m_encoding, s, next))\n        return XML_ERROR_NO_MEMORY;\n      break;\n    case XML_TOK_INVALID:\n      parser->m_eventPtr = next;\n      return XML_ERROR_INVALID_TOKEN;\n    case XML_TOK_PARTIAL:\n      if (! parser->m_parsingStatus.finalBuffer) {\n        *nextPtr = s;\n        return XML_ERROR_NONE;\n      }\n      return XML_ERROR_UNCLOSED_TOKEN;\n    case XML_TOK_PARTIAL_CHAR:\n      if (! parser->m_parsingStatus.finalBuffer) {\n        *nextPtr = s;\n        return XML_ERROR_NONE;\n      }\n      return XML_ERROR_PARTIAL_CHAR;\n    default:\n      return XML_ERROR_JUNK_AFTER_DOC_ELEMENT;\n    }\n    parser->m_eventPtr = s = next;\n    switch (parser->m_parsingStatus.parsing) {\n    case XML_SUSPENDED:\n      *nextPtr = next;\n      return XML_ERROR_NONE;\n    case XML_FINISHED:\n      return XML_ERROR_ABORTED;\n    default:;\n    }\n  }\n}",
        "func": "static enum XML_Error PTRCALL\nepilogProcessor(XML_Parser parser, const char *s, const char *end,\n                const char **nextPtr) {\n  parser->m_processor = epilogProcessor;\n  parser->m_eventPtr = s;\n  for (;;) {\n    const char *next = NULL;\n    int tok = XmlPrologTok(parser->m_encoding, s, end, &next);\n#if defined(XML_DTD) || XML_GE == 1\n    if (! accountingDiffTolerated(parser, tok, s, next, __LINE__,\n                                  XML_ACCOUNT_DIRECT)) {\n      accountingOnAbort(parser);\n      return XML_ERROR_AMPLIFICATION_LIMIT_BREACH;\n    }\n#endif\n    parser->m_eventEndPtr = next;\n    switch (tok) {\n    /* report partial linebreak - it might be the last token */\n    case -XML_TOK_PROLOG_S:\n      if (parser->m_defaultHandler) {\n        reportDefault(parser, parser->m_encoding, s, next);\n        if (parser->m_parsingStatus.parsing == XML_FINISHED)\n          return XML_ERROR_ABORTED;\n      }\n      *nextPtr = next;\n      return XML_ERROR_NONE;\n    case XML_TOK_NONE:\n      *nextPtr = s;\n      return XML_ERROR_NONE;\n    case XML_TOK_PROLOG_S:\n      if (parser->m_defaultHandler)\n        reportDefault(parser, parser->m_encoding, s, next);\n      break;\n    case XML_TOK_PI:\n      if (! reportProcessingInstruction(parser, parser->m_encoding, s, next))\n        return XML_ERROR_NO_MEMORY;\n      break;\n    case XML_TOK_COMMENT:\n      if (! reportComment(parser, parser->m_encoding, s, next))\n        return XML_ERROR_NO_MEMORY;\n      break;\n    case XML_TOK_INVALID:\n      parser->m_eventPtr = next;\n      return XML_ERROR_INVALID_TOKEN;\n    case XML_TOK_PARTIAL:\n      if (! parser->m_parsingStatus.finalBuffer) {\n        *nextPtr = s;\n        return XML_ERROR_NONE;\n      }\n      return XML_ERROR_UNCLOSED_TOKEN;\n    case XML_TOK_PARTIAL_CHAR:\n      if (! parser->m_parsingStatus.finalBuffer) {\n        *nextPtr = s;\n        return XML_ERROR_NONE;\n      }\n      return XML_ERROR_PARTIAL_CHAR;\n    default:\n      return XML_ERROR_JUNK_AFTER_DOC_ELEMENT;\n    }\n    parser->m_eventPtr = s = next;\n    switch (parser->m_parsingStatus.parsing) {\n    case XML_SUSPENDED:\n      *nextPtr = next;\n      return XML_ERROR_NONE;\n    case XML_FINISHED:\n      return XML_ERROR_ABORTED;\n    default:;\n    }\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,7 +6,7 @@\n   for (;;) {\n     const char *next = NULL;\n     int tok = XmlPrologTok(parser->m_encoding, s, end, &next);\n-#ifdef XML_DTD\n+#if defined(XML_DTD) || XML_GE == 1\n     if (! accountingDiffTolerated(parser, tok, s, next, __LINE__,\n                                   XML_ACCOUNT_DIRECT)) {\n       accountingOnAbort(parser);",
        "diff_line_info": {
            "deleted_lines": [
                "#ifdef XML_DTD"
            ],
            "added_lines": [
                "#if defined(XML_DTD) || XML_GE == 1"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-52426",
        "func_name": "libexpat/entityValueInitProcessor",
        "description": "libexpat through 2.5.0 allows recursive XML Entity Expansion if XML_DTD is undefined at compile time.",
        "git_url": "https://github.com/libexpat/libexpat/commit/0f075ec8ecb5e43f8fdca5182f8cca4703da0404",
        "commit_title": "lib|xmlwf|cmake: Extend scope of billion laughs attack protection",
        "commit_text": " .. from \"defined(XML_DTD)\" to \"defined(XML_DTD) || XML_GE==1\".",
        "func_before": "static enum XML_Error PTRCALL\nentityValueInitProcessor(XML_Parser parser, const char *s, const char *end,\n                         const char **nextPtr) {\n  int tok;\n  const char *start = s;\n  const char *next = start;\n  parser->m_eventPtr = start;\n\n  for (;;) {\n    tok = XmlPrologTok(parser->m_encoding, start, end, &next);\n    /* Note: Except for XML_TOK_BOM below, these bytes are accounted later in:\n             - storeEntityValue\n             - processXmlDecl\n    */\n    parser->m_eventEndPtr = next;\n    if (tok <= 0) {\n      if (! parser->m_parsingStatus.finalBuffer && tok != XML_TOK_INVALID) {\n        *nextPtr = s;\n        return XML_ERROR_NONE;\n      }\n      switch (tok) {\n      case XML_TOK_INVALID:\n        return XML_ERROR_INVALID_TOKEN;\n      case XML_TOK_PARTIAL:\n        return XML_ERROR_UNCLOSED_TOKEN;\n      case XML_TOK_PARTIAL_CHAR:\n        return XML_ERROR_PARTIAL_CHAR;\n      case XML_TOK_NONE: /* start == end */\n      default:\n        break;\n      }\n      /* found end of entity value - can store it now */\n      return storeEntityValue(parser, parser->m_encoding, s, end,\n                              XML_ACCOUNT_DIRECT);\n    } else if (tok == XML_TOK_XML_DECL) {\n      enum XML_Error result;\n      result = processXmlDecl(parser, 0, start, next);\n      if (result != XML_ERROR_NONE)\n        return result;\n      /* At this point, m_parsingStatus.parsing cannot be XML_SUSPENDED.  For\n       * that to happen, a parameter entity parsing handler must have attempted\n       * to suspend the parser, which fails and raises an error.  The parser can\n       * be aborted, but can't be suspended.\n       */\n      if (parser->m_parsingStatus.parsing == XML_FINISHED)\n        return XML_ERROR_ABORTED;\n      *nextPtr = next;\n      /* stop scanning for text declaration - we found one */\n      parser->m_processor = entityValueProcessor;\n      return entityValueProcessor(parser, next, end, nextPtr);\n    }\n    /* XmlPrologTok has now set the encoding based on the BOM it found, and we\n       must move s and nextPtr forward to consume the BOM.\n\n       If we didn't, and got XML_TOK_NONE from the next XmlPrologTok call, we\n       would leave the BOM in the buffer and return. On the next call to this\n       function, our XmlPrologTok call would return XML_TOK_INVALID, since it\n       is not valid to have multiple BOMs.\n    */\n    else if (tok == XML_TOK_BOM) {\n#  ifdef XML_DTD\n      if (! accountingDiffTolerated(parser, tok, s, next, __LINE__,\n                                    XML_ACCOUNT_DIRECT)) {\n        accountingOnAbort(parser);\n        return XML_ERROR_AMPLIFICATION_LIMIT_BREACH;\n      }\n#  endif\n\n      *nextPtr = next;\n      s = next;\n    }\n    /* If we get this token, we have the start of what might be a\n       normal tag, but not a declaration (i.e. it doesn't begin with\n       \"<!\").  In a DTD context, that isn't legal.\n    */\n    else if (tok == XML_TOK_INSTANCE_START) {\n      *nextPtr = next;\n      return XML_ERROR_SYNTAX;\n    }\n    start = next;\n    parser->m_eventPtr = start;\n  }\n}",
        "func": "static enum XML_Error PTRCALL\nentityValueInitProcessor(XML_Parser parser, const char *s, const char *end,\n                         const char **nextPtr) {\n  int tok;\n  const char *start = s;\n  const char *next = start;\n  parser->m_eventPtr = start;\n\n  for (;;) {\n    tok = XmlPrologTok(parser->m_encoding, start, end, &next);\n    /* Note: Except for XML_TOK_BOM below, these bytes are accounted later in:\n             - storeEntityValue\n             - processXmlDecl\n    */\n    parser->m_eventEndPtr = next;\n    if (tok <= 0) {\n      if (! parser->m_parsingStatus.finalBuffer && tok != XML_TOK_INVALID) {\n        *nextPtr = s;\n        return XML_ERROR_NONE;\n      }\n      switch (tok) {\n      case XML_TOK_INVALID:\n        return XML_ERROR_INVALID_TOKEN;\n      case XML_TOK_PARTIAL:\n        return XML_ERROR_UNCLOSED_TOKEN;\n      case XML_TOK_PARTIAL_CHAR:\n        return XML_ERROR_PARTIAL_CHAR;\n      case XML_TOK_NONE: /* start == end */\n      default:\n        break;\n      }\n      /* found end of entity value - can store it now */\n      return storeEntityValue(parser, parser->m_encoding, s, end,\n                              XML_ACCOUNT_DIRECT);\n    } else if (tok == XML_TOK_XML_DECL) {\n      enum XML_Error result;\n      result = processXmlDecl(parser, 0, start, next);\n      if (result != XML_ERROR_NONE)\n        return result;\n      /* At this point, m_parsingStatus.parsing cannot be XML_SUSPENDED.  For\n       * that to happen, a parameter entity parsing handler must have attempted\n       * to suspend the parser, which fails and raises an error.  The parser can\n       * be aborted, but can't be suspended.\n       */\n      if (parser->m_parsingStatus.parsing == XML_FINISHED)\n        return XML_ERROR_ABORTED;\n      *nextPtr = next;\n      /* stop scanning for text declaration - we found one */\n      parser->m_processor = entityValueProcessor;\n      return entityValueProcessor(parser, next, end, nextPtr);\n    }\n    /* XmlPrologTok has now set the encoding based on the BOM it found, and we\n       must move s and nextPtr forward to consume the BOM.\n\n       If we didn't, and got XML_TOK_NONE from the next XmlPrologTok call, we\n       would leave the BOM in the buffer and return. On the next call to this\n       function, our XmlPrologTok call would return XML_TOK_INVALID, since it\n       is not valid to have multiple BOMs.\n    */\n    else if (tok == XML_TOK_BOM) {\n#  if defined(XML_DTD) || XML_GE == 1\n      if (! accountingDiffTolerated(parser, tok, s, next, __LINE__,\n                                    XML_ACCOUNT_DIRECT)) {\n        accountingOnAbort(parser);\n        return XML_ERROR_AMPLIFICATION_LIMIT_BREACH;\n      }\n#  endif\n\n      *nextPtr = next;\n      s = next;\n    }\n    /* If we get this token, we have the start of what might be a\n       normal tag, but not a declaration (i.e. it doesn't begin with\n       \"<!\").  In a DTD context, that isn't legal.\n    */\n    else if (tok == XML_TOK_INSTANCE_START) {\n      *nextPtr = next;\n      return XML_ERROR_SYNTAX;\n    }\n    start = next;\n    parser->m_eventPtr = start;\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -58,7 +58,7 @@\n        is not valid to have multiple BOMs.\n     */\n     else if (tok == XML_TOK_BOM) {\n-#  ifdef XML_DTD\n+#  if defined(XML_DTD) || XML_GE == 1\n       if (! accountingDiffTolerated(parser, tok, s, next, __LINE__,\n                                     XML_ACCOUNT_DIRECT)) {\n         accountingOnAbort(parser);",
        "diff_line_info": {
            "deleted_lines": [
                "#  ifdef XML_DTD"
            ],
            "added_lines": [
                "#  if defined(XML_DTD) || XML_GE == 1"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-52426",
        "func_name": "libexpat/processInternalEntity",
        "description": "libexpat through 2.5.0 allows recursive XML Entity Expansion if XML_DTD is undefined at compile time.",
        "git_url": "https://github.com/libexpat/libexpat/commit/0f075ec8ecb5e43f8fdca5182f8cca4703da0404",
        "commit_title": "lib|xmlwf|cmake: Extend scope of billion laughs attack protection",
        "commit_text": " .. from \"defined(XML_DTD)\" to \"defined(XML_DTD) || XML_GE==1\".",
        "func_before": "static enum XML_Error\nprocessInternalEntity(XML_Parser parser, ENTITY *entity, XML_Bool betweenDecl) {\n  const char *textStart, *textEnd;\n  const char *next;\n  enum XML_Error result;\n  OPEN_INTERNAL_ENTITY *openEntity;\n\n  if (parser->m_freeInternalEntities) {\n    openEntity = parser->m_freeInternalEntities;\n    parser->m_freeInternalEntities = openEntity->next;\n  } else {\n    openEntity\n        = (OPEN_INTERNAL_ENTITY *)MALLOC(parser, sizeof(OPEN_INTERNAL_ENTITY));\n    if (! openEntity)\n      return XML_ERROR_NO_MEMORY;\n  }\n  entity->open = XML_TRUE;\n#ifdef XML_DTD\n  entityTrackingOnOpen(parser, entity, __LINE__);\n#endif\n  entity->processed = 0;\n  openEntity->next = parser->m_openInternalEntities;\n  parser->m_openInternalEntities = openEntity;\n  openEntity->entity = entity;\n  openEntity->startTagLevel = parser->m_tagLevel;\n  openEntity->betweenDecl = betweenDecl;\n  openEntity->internalEventPtr = NULL;\n  openEntity->internalEventEndPtr = NULL;\n  textStart = (const char *)entity->textPtr;\n  textEnd = (const char *)(entity->textPtr + entity->textLen);\n  /* Set a safe default value in case 'next' does not get set */\n  next = textStart;\n\n#ifdef XML_DTD\n  if (entity->is_param) {\n    int tok\n        = XmlPrologTok(parser->m_internalEncoding, textStart, textEnd, &next);\n    result = doProlog(parser, parser->m_internalEncoding, textStart, textEnd,\n                      tok, next, &next, XML_FALSE, XML_FALSE,\n                      XML_ACCOUNT_ENTITY_EXPANSION);\n  } else\n#endif /* XML_DTD */\n    result = doContent(parser, parser->m_tagLevel, parser->m_internalEncoding,\n                       textStart, textEnd, &next, XML_FALSE,\n                       XML_ACCOUNT_ENTITY_EXPANSION);\n\n  if (result == XML_ERROR_NONE) {\n    if (textEnd != next && parser->m_parsingStatus.parsing == XML_SUSPENDED) {\n      entity->processed = (int)(next - textStart);\n      parser->m_processor = internalEntityProcessor;\n    } else {\n#ifdef XML_DTD\n      entityTrackingOnClose(parser, entity, __LINE__);\n#endif /* XML_DTD */\n      entity->open = XML_FALSE;\n      parser->m_openInternalEntities = openEntity->next;\n      /* put openEntity back in list of free instances */\n      openEntity->next = parser->m_freeInternalEntities;\n      parser->m_freeInternalEntities = openEntity;\n    }\n  }\n  return result;\n}",
        "func": "static enum XML_Error\nprocessInternalEntity(XML_Parser parser, ENTITY *entity, XML_Bool betweenDecl) {\n  const char *textStart, *textEnd;\n  const char *next;\n  enum XML_Error result;\n  OPEN_INTERNAL_ENTITY *openEntity;\n\n  if (parser->m_freeInternalEntities) {\n    openEntity = parser->m_freeInternalEntities;\n    parser->m_freeInternalEntities = openEntity->next;\n  } else {\n    openEntity\n        = (OPEN_INTERNAL_ENTITY *)MALLOC(parser, sizeof(OPEN_INTERNAL_ENTITY));\n    if (! openEntity)\n      return XML_ERROR_NO_MEMORY;\n  }\n  entity->open = XML_TRUE;\n#if defined(XML_DTD) || XML_GE == 1\n  entityTrackingOnOpen(parser, entity, __LINE__);\n#endif\n  entity->processed = 0;\n  openEntity->next = parser->m_openInternalEntities;\n  parser->m_openInternalEntities = openEntity;\n  openEntity->entity = entity;\n  openEntity->startTagLevel = parser->m_tagLevel;\n  openEntity->betweenDecl = betweenDecl;\n  openEntity->internalEventPtr = NULL;\n  openEntity->internalEventEndPtr = NULL;\n  textStart = (const char *)entity->textPtr;\n  textEnd = (const char *)(entity->textPtr + entity->textLen);\n  /* Set a safe default value in case 'next' does not get set */\n  next = textStart;\n\n#ifdef XML_DTD\n  if (entity->is_param) {\n    int tok\n        = XmlPrologTok(parser->m_internalEncoding, textStart, textEnd, &next);\n    result = doProlog(parser, parser->m_internalEncoding, textStart, textEnd,\n                      tok, next, &next, XML_FALSE, XML_FALSE,\n                      XML_ACCOUNT_ENTITY_EXPANSION);\n  } else\n#endif /* XML_DTD */\n    result = doContent(parser, parser->m_tagLevel, parser->m_internalEncoding,\n                       textStart, textEnd, &next, XML_FALSE,\n                       XML_ACCOUNT_ENTITY_EXPANSION);\n\n  if (result == XML_ERROR_NONE) {\n    if (textEnd != next && parser->m_parsingStatus.parsing == XML_SUSPENDED) {\n      entity->processed = (int)(next - textStart);\n      parser->m_processor = internalEntityProcessor;\n    } else {\n#if defined(XML_DTD) || XML_GE == 1\n      entityTrackingOnClose(parser, entity, __LINE__);\n#endif /* defined(XML_DTD) || XML_GE == 1 */\n      entity->open = XML_FALSE;\n      parser->m_openInternalEntities = openEntity->next;\n      /* put openEntity back in list of free instances */\n      openEntity->next = parser->m_freeInternalEntities;\n      parser->m_freeInternalEntities = openEntity;\n    }\n  }\n  return result;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -15,7 +15,7 @@\n       return XML_ERROR_NO_MEMORY;\n   }\n   entity->open = XML_TRUE;\n-#ifdef XML_DTD\n+#if defined(XML_DTD) || XML_GE == 1\n   entityTrackingOnOpen(parser, entity, __LINE__);\n #endif\n   entity->processed = 0;\n@@ -49,9 +49,9 @@\n       entity->processed = (int)(next - textStart);\n       parser->m_processor = internalEntityProcessor;\n     } else {\n-#ifdef XML_DTD\n+#if defined(XML_DTD) || XML_GE == 1\n       entityTrackingOnClose(parser, entity, __LINE__);\n-#endif /* XML_DTD */\n+#endif /* defined(XML_DTD) || XML_GE == 1 */\n       entity->open = XML_FALSE;\n       parser->m_openInternalEntities = openEntity->next;\n       /* put openEntity back in list of free instances */",
        "diff_line_info": {
            "deleted_lines": [
                "#ifdef XML_DTD",
                "#ifdef XML_DTD",
                "#endif /* XML_DTD */"
            ],
            "added_lines": [
                "#if defined(XML_DTD) || XML_GE == 1",
                "#if defined(XML_DTD) || XML_GE == 1",
                "#endif /* defined(XML_DTD) || XML_GE == 1 */"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-52426",
        "func_name": "libexpat/doCdataSection",
        "description": "libexpat through 2.5.0 allows recursive XML Entity Expansion if XML_DTD is undefined at compile time.",
        "git_url": "https://github.com/libexpat/libexpat/commit/0f075ec8ecb5e43f8fdca5182f8cca4703da0404",
        "commit_title": "lib|xmlwf|cmake: Extend scope of billion laughs attack protection",
        "commit_text": " .. from \"defined(XML_DTD)\" to \"defined(XML_DTD) || XML_GE==1\".",
        "func_before": "static enum XML_Error\ndoCdataSection(XML_Parser parser, const ENCODING *enc, const char **startPtr,\n               const char *end, const char **nextPtr, XML_Bool haveMore,\n               enum XML_Account account) {\n  const char *s = *startPtr;\n  const char **eventPP;\n  const char **eventEndPP;\n  if (enc == parser->m_encoding) {\n    eventPP = &parser->m_eventPtr;\n    *eventPP = s;\n    eventEndPP = &parser->m_eventEndPtr;\n  } else {\n    eventPP = &(parser->m_openInternalEntities->internalEventPtr);\n    eventEndPP = &(parser->m_openInternalEntities->internalEventEndPtr);\n  }\n  *eventPP = s;\n  *startPtr = NULL;\n\n  for (;;) {\n    const char *next = s; /* in case of XML_TOK_NONE or XML_TOK_PARTIAL */\n    int tok = XmlCdataSectionTok(enc, s, end, &next);\n#ifdef XML_DTD\n    if (! accountingDiffTolerated(parser, tok, s, next, __LINE__, account)) {\n      accountingOnAbort(parser);\n      return XML_ERROR_AMPLIFICATION_LIMIT_BREACH;\n    }\n#else\n    UNUSED_P(account);\n#endif\n    *eventEndPP = next;\n    switch (tok) {\n    case XML_TOK_CDATA_SECT_CLOSE:\n      if (parser->m_endCdataSectionHandler)\n        parser->m_endCdataSectionHandler(parser->m_handlerArg);\n      /* BEGIN disabled code */\n      /* see comment under XML_TOK_CDATA_SECT_OPEN */\n      else if ((0) && parser->m_characterDataHandler)\n        parser->m_characterDataHandler(parser->m_handlerArg, parser->m_dataBuf,\n                                       0);\n      /* END disabled code */\n      else if (parser->m_defaultHandler)\n        reportDefault(parser, enc, s, next);\n      *startPtr = next;\n      *nextPtr = next;\n      if (parser->m_parsingStatus.parsing == XML_FINISHED)\n        return XML_ERROR_ABORTED;\n      else\n        return XML_ERROR_NONE;\n    case XML_TOK_DATA_NEWLINE:\n      if (parser->m_characterDataHandler) {\n        XML_Char c = 0xA;\n        parser->m_characterDataHandler(parser->m_handlerArg, &c, 1);\n      } else if (parser->m_defaultHandler)\n        reportDefault(parser, enc, s, next);\n      break;\n    case XML_TOK_DATA_CHARS: {\n      XML_CharacterDataHandler charDataHandler = parser->m_characterDataHandler;\n      if (charDataHandler) {\n        if (MUST_CONVERT(enc, s)) {\n          for (;;) {\n            ICHAR *dataPtr = (ICHAR *)parser->m_dataBuf;\n            const enum XML_Convert_Result convert_res = XmlConvert(\n                enc, &s, next, &dataPtr, (ICHAR *)parser->m_dataBufEnd);\n            *eventEndPP = next;\n            charDataHandler(parser->m_handlerArg, parser->m_dataBuf,\n                            (int)(dataPtr - (ICHAR *)parser->m_dataBuf));\n            if ((convert_res == XML_CONVERT_COMPLETED)\n                || (convert_res == XML_CONVERT_INPUT_INCOMPLETE))\n              break;\n            *eventPP = s;\n          }\n        } else\n          charDataHandler(parser->m_handlerArg, (const XML_Char *)s,\n                          (int)((const XML_Char *)next - (const XML_Char *)s));\n      } else if (parser->m_defaultHandler)\n        reportDefault(parser, enc, s, next);\n    } break;\n    case XML_TOK_INVALID:\n      *eventPP = next;\n      return XML_ERROR_INVALID_TOKEN;\n    case XML_TOK_PARTIAL_CHAR:\n      if (haveMore) {\n        *nextPtr = s;\n        return XML_ERROR_NONE;\n      }\n      return XML_ERROR_PARTIAL_CHAR;\n    case XML_TOK_PARTIAL:\n    case XML_TOK_NONE:\n      if (haveMore) {\n        *nextPtr = s;\n        return XML_ERROR_NONE;\n      }\n      return XML_ERROR_UNCLOSED_CDATA_SECTION;\n    default:\n      /* Every token returned by XmlCdataSectionTok() has its own\n       * explicit case, so this default case will never be executed.\n       * We retain it as a safety net and exclude it from the coverage\n       * statistics.\n       *\n       * LCOV_EXCL_START\n       */\n      *eventPP = next;\n      return XML_ERROR_UNEXPECTED_STATE;\n      /* LCOV_EXCL_STOP */\n    }\n\n    *eventPP = s = next;\n    switch (parser->m_parsingStatus.parsing) {\n    case XML_SUSPENDED:\n      *nextPtr = next;\n      return XML_ERROR_NONE;\n    case XML_FINISHED:\n      return XML_ERROR_ABORTED;\n    default:;\n    }\n  }\n  /* not reached */\n}",
        "func": "static enum XML_Error\ndoCdataSection(XML_Parser parser, const ENCODING *enc, const char **startPtr,\n               const char *end, const char **nextPtr, XML_Bool haveMore,\n               enum XML_Account account) {\n  const char *s = *startPtr;\n  const char **eventPP;\n  const char **eventEndPP;\n  if (enc == parser->m_encoding) {\n    eventPP = &parser->m_eventPtr;\n    *eventPP = s;\n    eventEndPP = &parser->m_eventEndPtr;\n  } else {\n    eventPP = &(parser->m_openInternalEntities->internalEventPtr);\n    eventEndPP = &(parser->m_openInternalEntities->internalEventEndPtr);\n  }\n  *eventPP = s;\n  *startPtr = NULL;\n\n  for (;;) {\n    const char *next = s; /* in case of XML_TOK_NONE or XML_TOK_PARTIAL */\n    int tok = XmlCdataSectionTok(enc, s, end, &next);\n#if defined(XML_DTD) || XML_GE == 1\n    if (! accountingDiffTolerated(parser, tok, s, next, __LINE__, account)) {\n      accountingOnAbort(parser);\n      return XML_ERROR_AMPLIFICATION_LIMIT_BREACH;\n    }\n#else\n    UNUSED_P(account);\n#endif\n    *eventEndPP = next;\n    switch (tok) {\n    case XML_TOK_CDATA_SECT_CLOSE:\n      if (parser->m_endCdataSectionHandler)\n        parser->m_endCdataSectionHandler(parser->m_handlerArg);\n      /* BEGIN disabled code */\n      /* see comment under XML_TOK_CDATA_SECT_OPEN */\n      else if ((0) && parser->m_characterDataHandler)\n        parser->m_characterDataHandler(parser->m_handlerArg, parser->m_dataBuf,\n                                       0);\n      /* END disabled code */\n      else if (parser->m_defaultHandler)\n        reportDefault(parser, enc, s, next);\n      *startPtr = next;\n      *nextPtr = next;\n      if (parser->m_parsingStatus.parsing == XML_FINISHED)\n        return XML_ERROR_ABORTED;\n      else\n        return XML_ERROR_NONE;\n    case XML_TOK_DATA_NEWLINE:\n      if (parser->m_characterDataHandler) {\n        XML_Char c = 0xA;\n        parser->m_characterDataHandler(parser->m_handlerArg, &c, 1);\n      } else if (parser->m_defaultHandler)\n        reportDefault(parser, enc, s, next);\n      break;\n    case XML_TOK_DATA_CHARS: {\n      XML_CharacterDataHandler charDataHandler = parser->m_characterDataHandler;\n      if (charDataHandler) {\n        if (MUST_CONVERT(enc, s)) {\n          for (;;) {\n            ICHAR *dataPtr = (ICHAR *)parser->m_dataBuf;\n            const enum XML_Convert_Result convert_res = XmlConvert(\n                enc, &s, next, &dataPtr, (ICHAR *)parser->m_dataBufEnd);\n            *eventEndPP = next;\n            charDataHandler(parser->m_handlerArg, parser->m_dataBuf,\n                            (int)(dataPtr - (ICHAR *)parser->m_dataBuf));\n            if ((convert_res == XML_CONVERT_COMPLETED)\n                || (convert_res == XML_CONVERT_INPUT_INCOMPLETE))\n              break;\n            *eventPP = s;\n          }\n        } else\n          charDataHandler(parser->m_handlerArg, (const XML_Char *)s,\n                          (int)((const XML_Char *)next - (const XML_Char *)s));\n      } else if (parser->m_defaultHandler)\n        reportDefault(parser, enc, s, next);\n    } break;\n    case XML_TOK_INVALID:\n      *eventPP = next;\n      return XML_ERROR_INVALID_TOKEN;\n    case XML_TOK_PARTIAL_CHAR:\n      if (haveMore) {\n        *nextPtr = s;\n        return XML_ERROR_NONE;\n      }\n      return XML_ERROR_PARTIAL_CHAR;\n    case XML_TOK_PARTIAL:\n    case XML_TOK_NONE:\n      if (haveMore) {\n        *nextPtr = s;\n        return XML_ERROR_NONE;\n      }\n      return XML_ERROR_UNCLOSED_CDATA_SECTION;\n    default:\n      /* Every token returned by XmlCdataSectionTok() has its own\n       * explicit case, so this default case will never be executed.\n       * We retain it as a safety net and exclude it from the coverage\n       * statistics.\n       *\n       * LCOV_EXCL_START\n       */\n      *eventPP = next;\n      return XML_ERROR_UNEXPECTED_STATE;\n      /* LCOV_EXCL_STOP */\n    }\n\n    *eventPP = s = next;\n    switch (parser->m_parsingStatus.parsing) {\n    case XML_SUSPENDED:\n      *nextPtr = next;\n      return XML_ERROR_NONE;\n    case XML_FINISHED:\n      return XML_ERROR_ABORTED;\n    default:;\n    }\n  }\n  /* not reached */\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -19,7 +19,7 @@\n   for (;;) {\n     const char *next = s; /* in case of XML_TOK_NONE or XML_TOK_PARTIAL */\n     int tok = XmlCdataSectionTok(enc, s, end, &next);\n-#ifdef XML_DTD\n+#if defined(XML_DTD) || XML_GE == 1\n     if (! accountingDiffTolerated(parser, tok, s, next, __LINE__, account)) {\n       accountingOnAbort(parser);\n       return XML_ERROR_AMPLIFICATION_LIMIT_BREACH;",
        "diff_line_info": {
            "deleted_lines": [
                "#ifdef XML_DTD"
            ],
            "added_lines": [
                "#if defined(XML_DTD) || XML_GE == 1"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-52426",
        "func_name": "libexpat/doContent",
        "description": "libexpat through 2.5.0 allows recursive XML Entity Expansion if XML_DTD is undefined at compile time.",
        "git_url": "https://github.com/libexpat/libexpat/commit/0f075ec8ecb5e43f8fdca5182f8cca4703da0404",
        "commit_title": "lib|xmlwf|cmake: Extend scope of billion laughs attack protection",
        "commit_text": " .. from \"defined(XML_DTD)\" to \"defined(XML_DTD) || XML_GE==1\".",
        "func_before": "static enum XML_Error\ndoContent(XML_Parser parser, int startTagLevel, const ENCODING *enc,\n          const char *s, const char *end, const char **nextPtr,\n          XML_Bool haveMore, enum XML_Account account) {\n  /* save one level of indirection */\n  DTD *const dtd = parser->m_dtd;\n\n  const char **eventPP;\n  const char **eventEndPP;\n  if (enc == parser->m_encoding) {\n    eventPP = &parser->m_eventPtr;\n    eventEndPP = &parser->m_eventEndPtr;\n  } else {\n    eventPP = &(parser->m_openInternalEntities->internalEventPtr);\n    eventEndPP = &(parser->m_openInternalEntities->internalEventEndPtr);\n  }\n  *eventPP = s;\n\n  for (;;) {\n    const char *next = s; /* XmlContentTok doesn't always set the last arg */\n    int tok = XmlContentTok(enc, s, end, &next);\n#ifdef XML_DTD\n    const char *accountAfter\n        = ((tok == XML_TOK_TRAILING_RSQB) || (tok == XML_TOK_TRAILING_CR))\n              ? (haveMore ? s /* i.e. 0 bytes */ : end)\n              : next;\n    if (! accountingDiffTolerated(parser, tok, s, accountAfter, __LINE__,\n                                  account)) {\n      accountingOnAbort(parser);\n      return XML_ERROR_AMPLIFICATION_LIMIT_BREACH;\n    }\n#endif\n    *eventEndPP = next;\n    switch (tok) {\n    case XML_TOK_TRAILING_CR:\n      if (haveMore) {\n        *nextPtr = s;\n        return XML_ERROR_NONE;\n      }\n      *eventEndPP = end;\n      if (parser->m_characterDataHandler) {\n        XML_Char c = 0xA;\n        parser->m_characterDataHandler(parser->m_handlerArg, &c, 1);\n      } else if (parser->m_defaultHandler)\n        reportDefault(parser, enc, s, end);\n      /* We are at the end of the final buffer, should we check for\n         XML_SUSPENDED, XML_FINISHED?\n      */\n      if (startTagLevel == 0)\n        return XML_ERROR_NO_ELEMENTS;\n      if (parser->m_tagLevel != startTagLevel)\n        return XML_ERROR_ASYNC_ENTITY;\n      *nextPtr = end;\n      return XML_ERROR_NONE;\n    case XML_TOK_NONE:\n      if (haveMore) {\n        *nextPtr = s;\n        return XML_ERROR_NONE;\n      }\n      if (startTagLevel > 0) {\n        if (parser->m_tagLevel != startTagLevel)\n          return XML_ERROR_ASYNC_ENTITY;\n        *nextPtr = s;\n        return XML_ERROR_NONE;\n      }\n      return XML_ERROR_NO_ELEMENTS;\n    case XML_TOK_INVALID:\n      *eventPP = next;\n      return XML_ERROR_INVALID_TOKEN;\n    case XML_TOK_PARTIAL:\n      if (haveMore) {\n        *nextPtr = s;\n        return XML_ERROR_NONE;\n      }\n      return XML_ERROR_UNCLOSED_TOKEN;\n    case XML_TOK_PARTIAL_CHAR:\n      if (haveMore) {\n        *nextPtr = s;\n        return XML_ERROR_NONE;\n      }\n      return XML_ERROR_PARTIAL_CHAR;\n    case XML_TOK_ENTITY_REF: {\n      const XML_Char *name;\n      ENTITY *entity;\n      XML_Char ch = (XML_Char)XmlPredefinedEntityName(\n          enc, s + enc->minBytesPerChar, next - enc->minBytesPerChar);\n      if (ch) {\n#ifdef XML_DTD\n        /* NOTE: We are replacing 4-6 characters original input for 1 character\n         *       so there is no amplification and hence recording without\n         *       protection. */\n        accountingDiffTolerated(parser, tok, (char *)&ch,\n                                ((char *)&ch) + sizeof(XML_Char), __LINE__,\n                                XML_ACCOUNT_ENTITY_EXPANSION);\n#endif /* XML_DTD */\n        if (parser->m_characterDataHandler)\n          parser->m_characterDataHandler(parser->m_handlerArg, &ch, 1);\n        else if (parser->m_defaultHandler)\n          reportDefault(parser, enc, s, next);\n        break;\n      }\n      name = poolStoreString(&dtd->pool, enc, s + enc->minBytesPerChar,\n                             next - enc->minBytesPerChar);\n      if (! name)\n        return XML_ERROR_NO_MEMORY;\n      entity = (ENTITY *)lookup(parser, &dtd->generalEntities, name, 0);\n      poolDiscard(&dtd->pool);\n      /* First, determine if a check for an existing declaration is needed;\n         if yes, check that the entity exists, and that it is internal,\n         otherwise call the skipped entity or default handler.\n      */\n      if (! dtd->hasParamEntityRefs || dtd->standalone) {\n        if (! entity)\n          return XML_ERROR_UNDEFINED_ENTITY;\n        else if (! entity->is_internal)\n          return XML_ERROR_ENTITY_DECLARED_IN_PE;\n      } else if (! entity) {\n        if (parser->m_skippedEntityHandler)\n          parser->m_skippedEntityHandler(parser->m_handlerArg, name, 0);\n        else if (parser->m_defaultHandler)\n          reportDefault(parser, enc, s, next);\n        break;\n      }\n      if (entity->open)\n        return XML_ERROR_RECURSIVE_ENTITY_REF;\n      if (entity->notation)\n        return XML_ERROR_BINARY_ENTITY_REF;\n      if (entity->textPtr) {\n        enum XML_Error result;\n        if (! parser->m_defaultExpandInternalEntities) {\n          if (parser->m_skippedEntityHandler)\n            parser->m_skippedEntityHandler(parser->m_handlerArg, entity->name,\n                                           0);\n          else if (parser->m_defaultHandler)\n            reportDefault(parser, enc, s, next);\n          break;\n        }\n        result = processInternalEntity(parser, entity, XML_FALSE);\n        if (result != XML_ERROR_NONE)\n          return result;\n      } else if (parser->m_externalEntityRefHandler) {\n        const XML_Char *context;\n        entity->open = XML_TRUE;\n        context = getContext(parser);\n        entity->open = XML_FALSE;\n        if (! context)\n          return XML_ERROR_NO_MEMORY;\n        if (! parser->m_externalEntityRefHandler(\n                parser->m_externalEntityRefHandlerArg, context, entity->base,\n                entity->systemId, entity->publicId))\n          return XML_ERROR_EXTERNAL_ENTITY_HANDLING;\n        poolDiscard(&parser->m_tempPool);\n      } else if (parser->m_defaultHandler)\n        reportDefault(parser, enc, s, next);\n      break;\n    }\n    case XML_TOK_START_TAG_NO_ATTS:\n      /* fall through */\n    case XML_TOK_START_TAG_WITH_ATTS: {\n      TAG *tag;\n      enum XML_Error result;\n      XML_Char *toPtr;\n      if (parser->m_freeTagList) {\n        tag = parser->m_freeTagList;\n        parser->m_freeTagList = parser->m_freeTagList->parent;\n      } else {\n        tag = (TAG *)MALLOC(parser, sizeof(TAG));\n        if (! tag)\n          return XML_ERROR_NO_MEMORY;\n        tag->buf = (char *)MALLOC(parser, INIT_TAG_BUF_SIZE);\n        if (! tag->buf) {\n          FREE(parser, tag);\n          return XML_ERROR_NO_MEMORY;\n        }\n        tag->bufEnd = tag->buf + INIT_TAG_BUF_SIZE;\n      }\n      tag->bindings = NULL;\n      tag->parent = parser->m_tagStack;\n      parser->m_tagStack = tag;\n      tag->name.localPart = NULL;\n      tag->name.prefix = NULL;\n      tag->rawName = s + enc->minBytesPerChar;\n      tag->rawNameLength = XmlNameLength(enc, tag->rawName);\n      ++parser->m_tagLevel;\n      {\n        const char *rawNameEnd = tag->rawName + tag->rawNameLength;\n        const char *fromPtr = tag->rawName;\n        toPtr = (XML_Char *)tag->buf;\n        for (;;) {\n          int bufSize;\n          int convLen;\n          const enum XML_Convert_Result convert_res\n              = XmlConvert(enc, &fromPtr, rawNameEnd, (ICHAR **)&toPtr,\n                           (ICHAR *)tag->bufEnd - 1);\n          convLen = (int)(toPtr - (XML_Char *)tag->buf);\n          if ((fromPtr >= rawNameEnd)\n              || (convert_res == XML_CONVERT_INPUT_INCOMPLETE)) {\n            tag->name.strLen = convLen;\n            break;\n          }\n          bufSize = (int)(tag->bufEnd - tag->buf) << 1;\n          {\n            char *temp = (char *)REALLOC(parser, tag->buf, bufSize);\n            if (temp == NULL)\n              return XML_ERROR_NO_MEMORY;\n            tag->buf = temp;\n            tag->bufEnd = temp + bufSize;\n            toPtr = (XML_Char *)temp + convLen;\n          }\n        }\n      }\n      tag->name.str = (XML_Char *)tag->buf;\n      *toPtr = XML_T('\\0');\n      result\n          = storeAtts(parser, enc, s, &(tag->name), &(tag->bindings), account);\n      if (result)\n        return result;\n      if (parser->m_startElementHandler)\n        parser->m_startElementHandler(parser->m_handlerArg, tag->name.str,\n                                      (const XML_Char **)parser->m_atts);\n      else if (parser->m_defaultHandler)\n        reportDefault(parser, enc, s, next);\n      poolClear(&parser->m_tempPool);\n      break;\n    }\n    case XML_TOK_EMPTY_ELEMENT_NO_ATTS:\n      /* fall through */\n    case XML_TOK_EMPTY_ELEMENT_WITH_ATTS: {\n      const char *rawName = s + enc->minBytesPerChar;\n      enum XML_Error result;\n      BINDING *bindings = NULL;\n      XML_Bool noElmHandlers = XML_TRUE;\n      TAG_NAME name;\n      name.str = poolStoreString(&parser->m_tempPool, enc, rawName,\n                                 rawName + XmlNameLength(enc, rawName));\n      if (! name.str)\n        return XML_ERROR_NO_MEMORY;\n      poolFinish(&parser->m_tempPool);\n      result = storeAtts(parser, enc, s, &name, &bindings,\n                         XML_ACCOUNT_NONE /* token spans whole start tag */);\n      if (result != XML_ERROR_NONE) {\n        freeBindings(parser, bindings);\n        return result;\n      }\n      poolFinish(&parser->m_tempPool);\n      if (parser->m_startElementHandler) {\n        parser->m_startElementHandler(parser->m_handlerArg, name.str,\n                                      (const XML_Char **)parser->m_atts);\n        noElmHandlers = XML_FALSE;\n      }\n      if (parser->m_endElementHandler) {\n        if (parser->m_startElementHandler)\n          *eventPP = *eventEndPP;\n        parser->m_endElementHandler(parser->m_handlerArg, name.str);\n        noElmHandlers = XML_FALSE;\n      }\n      if (noElmHandlers && parser->m_defaultHandler)\n        reportDefault(parser, enc, s, next);\n      poolClear(&parser->m_tempPool);\n      freeBindings(parser, bindings);\n    }\n      if ((parser->m_tagLevel == 0)\n          && (parser->m_parsingStatus.parsing != XML_FINISHED)) {\n        if (parser->m_parsingStatus.parsing == XML_SUSPENDED)\n          parser->m_processor = epilogProcessor;\n        else\n          return epilogProcessor(parser, next, end, nextPtr);\n      }\n      break;\n    case XML_TOK_END_TAG:\n      if (parser->m_tagLevel == startTagLevel)\n        return XML_ERROR_ASYNC_ENTITY;\n      else {\n        int len;\n        const char *rawName;\n        TAG *tag = parser->m_tagStack;\n        rawName = s + enc->minBytesPerChar * 2;\n        len = XmlNameLength(enc, rawName);\n        if (len != tag->rawNameLength\n            || memcmp(tag->rawName, rawName, len) != 0) {\n          *eventPP = rawName;\n          return XML_ERROR_TAG_MISMATCH;\n        }\n        parser->m_tagStack = tag->parent;\n        tag->parent = parser->m_freeTagList;\n        parser->m_freeTagList = tag;\n        --parser->m_tagLevel;\n        if (parser->m_endElementHandler) {\n          const XML_Char *localPart;\n          const XML_Char *prefix;\n          XML_Char *uri;\n          localPart = tag->name.localPart;\n          if (parser->m_ns && localPart) {\n            /* localPart and prefix may have been overwritten in\n               tag->name.str, since this points to the binding->uri\n               buffer which gets reused; so we have to add them again\n            */\n            uri = (XML_Char *)tag->name.str + tag->name.uriLen;\n            /* don't need to check for space - already done in storeAtts() */\n            while (*localPart)\n              *uri++ = *localPart++;\n            prefix = tag->name.prefix;\n            if (parser->m_ns_triplets && prefix) {\n              *uri++ = parser->m_namespaceSeparator;\n              while (*prefix)\n                *uri++ = *prefix++;\n            }\n            *uri = XML_T('\\0');\n          }\n          parser->m_endElementHandler(parser->m_handlerArg, tag->name.str);\n        } else if (parser->m_defaultHandler)\n          reportDefault(parser, enc, s, next);\n        while (tag->bindings) {\n          BINDING *b = tag->bindings;\n          if (parser->m_endNamespaceDeclHandler)\n            parser->m_endNamespaceDeclHandler(parser->m_handlerArg,\n                                              b->prefix->name);\n          tag->bindings = tag->bindings->nextTagBinding;\n          b->nextTagBinding = parser->m_freeBindingList;\n          parser->m_freeBindingList = b;\n          b->prefix->binding = b->prevPrefixBinding;\n        }\n        if ((parser->m_tagLevel == 0)\n            && (parser->m_parsingStatus.parsing != XML_FINISHED)) {\n          if (parser->m_parsingStatus.parsing == XML_SUSPENDED)\n            parser->m_processor = epilogProcessor;\n          else\n            return epilogProcessor(parser, next, end, nextPtr);\n        }\n      }\n      break;\n    case XML_TOK_CHAR_REF: {\n      int n = XmlCharRefNumber(enc, s);\n      if (n < 0)\n        return XML_ERROR_BAD_CHAR_REF;\n      if (parser->m_characterDataHandler) {\n        XML_Char buf[XML_ENCODE_MAX];\n        parser->m_characterDataHandler(parser->m_handlerArg, buf,\n                                       XmlEncode(n, (ICHAR *)buf));\n      } else if (parser->m_defaultHandler)\n        reportDefault(parser, enc, s, next);\n    } break;\n    case XML_TOK_XML_DECL:\n      return XML_ERROR_MISPLACED_XML_PI;\n    case XML_TOK_DATA_NEWLINE:\n      if (parser->m_characterDataHandler) {\n        XML_Char c = 0xA;\n        parser->m_characterDataHandler(parser->m_handlerArg, &c, 1);\n      } else if (parser->m_defaultHandler)\n        reportDefault(parser, enc, s, next);\n      break;\n    case XML_TOK_CDATA_SECT_OPEN: {\n      enum XML_Error result;\n      if (parser->m_startCdataSectionHandler)\n        parser->m_startCdataSectionHandler(parser->m_handlerArg);\n      /* BEGIN disabled code */\n      /* Suppose you doing a transformation on a document that involves\n         changing only the character data.  You set up a defaultHandler\n         and a characterDataHandler.  The defaultHandler simply copies\n         characters through.  The characterDataHandler does the\n         transformation and writes the characters out escaping them as\n         necessary.  This case will fail to work if we leave out the\n         following two lines (because & and < inside CDATA sections will\n         be incorrectly escaped).\n\n         However, now we have a start/endCdataSectionHandler, so it seems\n         easier to let the user deal with this.\n      */\n      else if ((0) && parser->m_characterDataHandler)\n        parser->m_characterDataHandler(parser->m_handlerArg, parser->m_dataBuf,\n                                       0);\n      /* END disabled code */\n      else if (parser->m_defaultHandler)\n        reportDefault(parser, enc, s, next);\n      result\n          = doCdataSection(parser, enc, &next, end, nextPtr, haveMore, account);\n      if (result != XML_ERROR_NONE)\n        return result;\n      else if (! next) {\n        parser->m_processor = cdataSectionProcessor;\n        return result;\n      }\n    } break;\n    case XML_TOK_TRAILING_RSQB:\n      if (haveMore) {\n        *nextPtr = s;\n        return XML_ERROR_NONE;\n      }\n      if (parser->m_characterDataHandler) {\n        if (MUST_CONVERT(enc, s)) {\n          ICHAR *dataPtr = (ICHAR *)parser->m_dataBuf;\n          XmlConvert(enc, &s, end, &dataPtr, (ICHAR *)parser->m_dataBufEnd);\n          parser->m_characterDataHandler(\n              parser->m_handlerArg, parser->m_dataBuf,\n              (int)(dataPtr - (ICHAR *)parser->m_dataBuf));\n        } else\n          parser->m_characterDataHandler(\n              parser->m_handlerArg, (const XML_Char *)s,\n              (int)((const XML_Char *)end - (const XML_Char *)s));\n      } else if (parser->m_defaultHandler)\n        reportDefault(parser, enc, s, end);\n      /* We are at the end of the final buffer, should we check for\n         XML_SUSPENDED, XML_FINISHED?\n      */\n      if (startTagLevel == 0) {\n        *eventPP = end;\n        return XML_ERROR_NO_ELEMENTS;\n      }\n      if (parser->m_tagLevel != startTagLevel) {\n        *eventPP = end;\n        return XML_ERROR_ASYNC_ENTITY;\n      }\n      *nextPtr = end;\n      return XML_ERROR_NONE;\n    case XML_TOK_DATA_CHARS: {\n      XML_CharacterDataHandler charDataHandler = parser->m_characterDataHandler;\n      if (charDataHandler) {\n        if (MUST_CONVERT(enc, s)) {\n          for (;;) {\n            ICHAR *dataPtr = (ICHAR *)parser->m_dataBuf;\n            const enum XML_Convert_Result convert_res = XmlConvert(\n                enc, &s, next, &dataPtr, (ICHAR *)parser->m_dataBufEnd);\n            *eventEndPP = s;\n            charDataHandler(parser->m_handlerArg, parser->m_dataBuf,\n                            (int)(dataPtr - (ICHAR *)parser->m_dataBuf));\n            if ((convert_res == XML_CONVERT_COMPLETED)\n                || (convert_res == XML_CONVERT_INPUT_INCOMPLETE))\n              break;\n            *eventPP = s;\n          }\n        } else\n          charDataHandler(parser->m_handlerArg, (const XML_Char *)s,\n                          (int)((const XML_Char *)next - (const XML_Char *)s));\n      } else if (parser->m_defaultHandler)\n        reportDefault(parser, enc, s, next);\n    } break;\n    case XML_TOK_PI:\n      if (! reportProcessingInstruction(parser, enc, s, next))\n        return XML_ERROR_NO_MEMORY;\n      break;\n    case XML_TOK_COMMENT:\n      if (! reportComment(parser, enc, s, next))\n        return XML_ERROR_NO_MEMORY;\n      break;\n    default:\n      /* All of the tokens produced by XmlContentTok() have their own\n       * explicit cases, so this default is not strictly necessary.\n       * However it is a useful safety net, so we retain the code and\n       * simply exclude it from the coverage tests.\n       *\n       * LCOV_EXCL_START\n       */\n      if (parser->m_defaultHandler)\n        reportDefault(parser, enc, s, next);\n      break;\n      /* LCOV_EXCL_STOP */\n    }\n    *eventPP = s = next;\n    switch (parser->m_parsingStatus.parsing) {\n    case XML_SUSPENDED:\n      *nextPtr = next;\n      return XML_ERROR_NONE;\n    case XML_FINISHED:\n      return XML_ERROR_ABORTED;\n    default:;\n    }\n  }\n  /* not reached */\n}",
        "func": "static enum XML_Error\ndoContent(XML_Parser parser, int startTagLevel, const ENCODING *enc,\n          const char *s, const char *end, const char **nextPtr,\n          XML_Bool haveMore, enum XML_Account account) {\n  /* save one level of indirection */\n  DTD *const dtd = parser->m_dtd;\n\n  const char **eventPP;\n  const char **eventEndPP;\n  if (enc == parser->m_encoding) {\n    eventPP = &parser->m_eventPtr;\n    eventEndPP = &parser->m_eventEndPtr;\n  } else {\n    eventPP = &(parser->m_openInternalEntities->internalEventPtr);\n    eventEndPP = &(parser->m_openInternalEntities->internalEventEndPtr);\n  }\n  *eventPP = s;\n\n  for (;;) {\n    const char *next = s; /* XmlContentTok doesn't always set the last arg */\n    int tok = XmlContentTok(enc, s, end, &next);\n#if defined(XML_DTD) || XML_GE == 1\n    const char *accountAfter\n        = ((tok == XML_TOK_TRAILING_RSQB) || (tok == XML_TOK_TRAILING_CR))\n              ? (haveMore ? s /* i.e. 0 bytes */ : end)\n              : next;\n    if (! accountingDiffTolerated(parser, tok, s, accountAfter, __LINE__,\n                                  account)) {\n      accountingOnAbort(parser);\n      return XML_ERROR_AMPLIFICATION_LIMIT_BREACH;\n    }\n#endif\n    *eventEndPP = next;\n    switch (tok) {\n    case XML_TOK_TRAILING_CR:\n      if (haveMore) {\n        *nextPtr = s;\n        return XML_ERROR_NONE;\n      }\n      *eventEndPP = end;\n      if (parser->m_characterDataHandler) {\n        XML_Char c = 0xA;\n        parser->m_characterDataHandler(parser->m_handlerArg, &c, 1);\n      } else if (parser->m_defaultHandler)\n        reportDefault(parser, enc, s, end);\n      /* We are at the end of the final buffer, should we check for\n         XML_SUSPENDED, XML_FINISHED?\n      */\n      if (startTagLevel == 0)\n        return XML_ERROR_NO_ELEMENTS;\n      if (parser->m_tagLevel != startTagLevel)\n        return XML_ERROR_ASYNC_ENTITY;\n      *nextPtr = end;\n      return XML_ERROR_NONE;\n    case XML_TOK_NONE:\n      if (haveMore) {\n        *nextPtr = s;\n        return XML_ERROR_NONE;\n      }\n      if (startTagLevel > 0) {\n        if (parser->m_tagLevel != startTagLevel)\n          return XML_ERROR_ASYNC_ENTITY;\n        *nextPtr = s;\n        return XML_ERROR_NONE;\n      }\n      return XML_ERROR_NO_ELEMENTS;\n    case XML_TOK_INVALID:\n      *eventPP = next;\n      return XML_ERROR_INVALID_TOKEN;\n    case XML_TOK_PARTIAL:\n      if (haveMore) {\n        *nextPtr = s;\n        return XML_ERROR_NONE;\n      }\n      return XML_ERROR_UNCLOSED_TOKEN;\n    case XML_TOK_PARTIAL_CHAR:\n      if (haveMore) {\n        *nextPtr = s;\n        return XML_ERROR_NONE;\n      }\n      return XML_ERROR_PARTIAL_CHAR;\n    case XML_TOK_ENTITY_REF: {\n      const XML_Char *name;\n      ENTITY *entity;\n      XML_Char ch = (XML_Char)XmlPredefinedEntityName(\n          enc, s + enc->minBytesPerChar, next - enc->minBytesPerChar);\n      if (ch) {\n#if defined(XML_DTD) || XML_GE == 1\n        /* NOTE: We are replacing 4-6 characters original input for 1 character\n         *       so there is no amplification and hence recording without\n         *       protection. */\n        accountingDiffTolerated(parser, tok, (char *)&ch,\n                                ((char *)&ch) + sizeof(XML_Char), __LINE__,\n                                XML_ACCOUNT_ENTITY_EXPANSION);\n#endif /* defined(XML_DTD) || XML_GE == 1 */\n        if (parser->m_characterDataHandler)\n          parser->m_characterDataHandler(parser->m_handlerArg, &ch, 1);\n        else if (parser->m_defaultHandler)\n          reportDefault(parser, enc, s, next);\n        break;\n      }\n      name = poolStoreString(&dtd->pool, enc, s + enc->minBytesPerChar,\n                             next - enc->minBytesPerChar);\n      if (! name)\n        return XML_ERROR_NO_MEMORY;\n      entity = (ENTITY *)lookup(parser, &dtd->generalEntities, name, 0);\n      poolDiscard(&dtd->pool);\n      /* First, determine if a check for an existing declaration is needed;\n         if yes, check that the entity exists, and that it is internal,\n         otherwise call the skipped entity or default handler.\n      */\n      if (! dtd->hasParamEntityRefs || dtd->standalone) {\n        if (! entity)\n          return XML_ERROR_UNDEFINED_ENTITY;\n        else if (! entity->is_internal)\n          return XML_ERROR_ENTITY_DECLARED_IN_PE;\n      } else if (! entity) {\n        if (parser->m_skippedEntityHandler)\n          parser->m_skippedEntityHandler(parser->m_handlerArg, name, 0);\n        else if (parser->m_defaultHandler)\n          reportDefault(parser, enc, s, next);\n        break;\n      }\n      if (entity->open)\n        return XML_ERROR_RECURSIVE_ENTITY_REF;\n      if (entity->notation)\n        return XML_ERROR_BINARY_ENTITY_REF;\n      if (entity->textPtr) {\n        enum XML_Error result;\n        if (! parser->m_defaultExpandInternalEntities) {\n          if (parser->m_skippedEntityHandler)\n            parser->m_skippedEntityHandler(parser->m_handlerArg, entity->name,\n                                           0);\n          else if (parser->m_defaultHandler)\n            reportDefault(parser, enc, s, next);\n          break;\n        }\n        result = processInternalEntity(parser, entity, XML_FALSE);\n        if (result != XML_ERROR_NONE)\n          return result;\n      } else if (parser->m_externalEntityRefHandler) {\n        const XML_Char *context;\n        entity->open = XML_TRUE;\n        context = getContext(parser);\n        entity->open = XML_FALSE;\n        if (! context)\n          return XML_ERROR_NO_MEMORY;\n        if (! parser->m_externalEntityRefHandler(\n                parser->m_externalEntityRefHandlerArg, context, entity->base,\n                entity->systemId, entity->publicId))\n          return XML_ERROR_EXTERNAL_ENTITY_HANDLING;\n        poolDiscard(&parser->m_tempPool);\n      } else if (parser->m_defaultHandler)\n        reportDefault(parser, enc, s, next);\n      break;\n    }\n    case XML_TOK_START_TAG_NO_ATTS:\n      /* fall through */\n    case XML_TOK_START_TAG_WITH_ATTS: {\n      TAG *tag;\n      enum XML_Error result;\n      XML_Char *toPtr;\n      if (parser->m_freeTagList) {\n        tag = parser->m_freeTagList;\n        parser->m_freeTagList = parser->m_freeTagList->parent;\n      } else {\n        tag = (TAG *)MALLOC(parser, sizeof(TAG));\n        if (! tag)\n          return XML_ERROR_NO_MEMORY;\n        tag->buf = (char *)MALLOC(parser, INIT_TAG_BUF_SIZE);\n        if (! tag->buf) {\n          FREE(parser, tag);\n          return XML_ERROR_NO_MEMORY;\n        }\n        tag->bufEnd = tag->buf + INIT_TAG_BUF_SIZE;\n      }\n      tag->bindings = NULL;\n      tag->parent = parser->m_tagStack;\n      parser->m_tagStack = tag;\n      tag->name.localPart = NULL;\n      tag->name.prefix = NULL;\n      tag->rawName = s + enc->minBytesPerChar;\n      tag->rawNameLength = XmlNameLength(enc, tag->rawName);\n      ++parser->m_tagLevel;\n      {\n        const char *rawNameEnd = tag->rawName + tag->rawNameLength;\n        const char *fromPtr = tag->rawName;\n        toPtr = (XML_Char *)tag->buf;\n        for (;;) {\n          int bufSize;\n          int convLen;\n          const enum XML_Convert_Result convert_res\n              = XmlConvert(enc, &fromPtr, rawNameEnd, (ICHAR **)&toPtr,\n                           (ICHAR *)tag->bufEnd - 1);\n          convLen = (int)(toPtr - (XML_Char *)tag->buf);\n          if ((fromPtr >= rawNameEnd)\n              || (convert_res == XML_CONVERT_INPUT_INCOMPLETE)) {\n            tag->name.strLen = convLen;\n            break;\n          }\n          bufSize = (int)(tag->bufEnd - tag->buf) << 1;\n          {\n            char *temp = (char *)REALLOC(parser, tag->buf, bufSize);\n            if (temp == NULL)\n              return XML_ERROR_NO_MEMORY;\n            tag->buf = temp;\n            tag->bufEnd = temp + bufSize;\n            toPtr = (XML_Char *)temp + convLen;\n          }\n        }\n      }\n      tag->name.str = (XML_Char *)tag->buf;\n      *toPtr = XML_T('\\0');\n      result\n          = storeAtts(parser, enc, s, &(tag->name), &(tag->bindings), account);\n      if (result)\n        return result;\n      if (parser->m_startElementHandler)\n        parser->m_startElementHandler(parser->m_handlerArg, tag->name.str,\n                                      (const XML_Char **)parser->m_atts);\n      else if (parser->m_defaultHandler)\n        reportDefault(parser, enc, s, next);\n      poolClear(&parser->m_tempPool);\n      break;\n    }\n    case XML_TOK_EMPTY_ELEMENT_NO_ATTS:\n      /* fall through */\n    case XML_TOK_EMPTY_ELEMENT_WITH_ATTS: {\n      const char *rawName = s + enc->minBytesPerChar;\n      enum XML_Error result;\n      BINDING *bindings = NULL;\n      XML_Bool noElmHandlers = XML_TRUE;\n      TAG_NAME name;\n      name.str = poolStoreString(&parser->m_tempPool, enc, rawName,\n                                 rawName + XmlNameLength(enc, rawName));\n      if (! name.str)\n        return XML_ERROR_NO_MEMORY;\n      poolFinish(&parser->m_tempPool);\n      result = storeAtts(parser, enc, s, &name, &bindings,\n                         XML_ACCOUNT_NONE /* token spans whole start tag */);\n      if (result != XML_ERROR_NONE) {\n        freeBindings(parser, bindings);\n        return result;\n      }\n      poolFinish(&parser->m_tempPool);\n      if (parser->m_startElementHandler) {\n        parser->m_startElementHandler(parser->m_handlerArg, name.str,\n                                      (const XML_Char **)parser->m_atts);\n        noElmHandlers = XML_FALSE;\n      }\n      if (parser->m_endElementHandler) {\n        if (parser->m_startElementHandler)\n          *eventPP = *eventEndPP;\n        parser->m_endElementHandler(parser->m_handlerArg, name.str);\n        noElmHandlers = XML_FALSE;\n      }\n      if (noElmHandlers && parser->m_defaultHandler)\n        reportDefault(parser, enc, s, next);\n      poolClear(&parser->m_tempPool);\n      freeBindings(parser, bindings);\n    }\n      if ((parser->m_tagLevel == 0)\n          && (parser->m_parsingStatus.parsing != XML_FINISHED)) {\n        if (parser->m_parsingStatus.parsing == XML_SUSPENDED)\n          parser->m_processor = epilogProcessor;\n        else\n          return epilogProcessor(parser, next, end, nextPtr);\n      }\n      break;\n    case XML_TOK_END_TAG:\n      if (parser->m_tagLevel == startTagLevel)\n        return XML_ERROR_ASYNC_ENTITY;\n      else {\n        int len;\n        const char *rawName;\n        TAG *tag = parser->m_tagStack;\n        rawName = s + enc->minBytesPerChar * 2;\n        len = XmlNameLength(enc, rawName);\n        if (len != tag->rawNameLength\n            || memcmp(tag->rawName, rawName, len) != 0) {\n          *eventPP = rawName;\n          return XML_ERROR_TAG_MISMATCH;\n        }\n        parser->m_tagStack = tag->parent;\n        tag->parent = parser->m_freeTagList;\n        parser->m_freeTagList = tag;\n        --parser->m_tagLevel;\n        if (parser->m_endElementHandler) {\n          const XML_Char *localPart;\n          const XML_Char *prefix;\n          XML_Char *uri;\n          localPart = tag->name.localPart;\n          if (parser->m_ns && localPart) {\n            /* localPart and prefix may have been overwritten in\n               tag->name.str, since this points to the binding->uri\n               buffer which gets reused; so we have to add them again\n            */\n            uri = (XML_Char *)tag->name.str + tag->name.uriLen;\n            /* don't need to check for space - already done in storeAtts() */\n            while (*localPart)\n              *uri++ = *localPart++;\n            prefix = tag->name.prefix;\n            if (parser->m_ns_triplets && prefix) {\n              *uri++ = parser->m_namespaceSeparator;\n              while (*prefix)\n                *uri++ = *prefix++;\n            }\n            *uri = XML_T('\\0');\n          }\n          parser->m_endElementHandler(parser->m_handlerArg, tag->name.str);\n        } else if (parser->m_defaultHandler)\n          reportDefault(parser, enc, s, next);\n        while (tag->bindings) {\n          BINDING *b = tag->bindings;\n          if (parser->m_endNamespaceDeclHandler)\n            parser->m_endNamespaceDeclHandler(parser->m_handlerArg,\n                                              b->prefix->name);\n          tag->bindings = tag->bindings->nextTagBinding;\n          b->nextTagBinding = parser->m_freeBindingList;\n          parser->m_freeBindingList = b;\n          b->prefix->binding = b->prevPrefixBinding;\n        }\n        if ((parser->m_tagLevel == 0)\n            && (parser->m_parsingStatus.parsing != XML_FINISHED)) {\n          if (parser->m_parsingStatus.parsing == XML_SUSPENDED)\n            parser->m_processor = epilogProcessor;\n          else\n            return epilogProcessor(parser, next, end, nextPtr);\n        }\n      }\n      break;\n    case XML_TOK_CHAR_REF: {\n      int n = XmlCharRefNumber(enc, s);\n      if (n < 0)\n        return XML_ERROR_BAD_CHAR_REF;\n      if (parser->m_characterDataHandler) {\n        XML_Char buf[XML_ENCODE_MAX];\n        parser->m_characterDataHandler(parser->m_handlerArg, buf,\n                                       XmlEncode(n, (ICHAR *)buf));\n      } else if (parser->m_defaultHandler)\n        reportDefault(parser, enc, s, next);\n    } break;\n    case XML_TOK_XML_DECL:\n      return XML_ERROR_MISPLACED_XML_PI;\n    case XML_TOK_DATA_NEWLINE:\n      if (parser->m_characterDataHandler) {\n        XML_Char c = 0xA;\n        parser->m_characterDataHandler(parser->m_handlerArg, &c, 1);\n      } else if (parser->m_defaultHandler)\n        reportDefault(parser, enc, s, next);\n      break;\n    case XML_TOK_CDATA_SECT_OPEN: {\n      enum XML_Error result;\n      if (parser->m_startCdataSectionHandler)\n        parser->m_startCdataSectionHandler(parser->m_handlerArg);\n      /* BEGIN disabled code */\n      /* Suppose you doing a transformation on a document that involves\n         changing only the character data.  You set up a defaultHandler\n         and a characterDataHandler.  The defaultHandler simply copies\n         characters through.  The characterDataHandler does the\n         transformation and writes the characters out escaping them as\n         necessary.  This case will fail to work if we leave out the\n         following two lines (because & and < inside CDATA sections will\n         be incorrectly escaped).\n\n         However, now we have a start/endCdataSectionHandler, so it seems\n         easier to let the user deal with this.\n      */\n      else if ((0) && parser->m_characterDataHandler)\n        parser->m_characterDataHandler(parser->m_handlerArg, parser->m_dataBuf,\n                                       0);\n      /* END disabled code */\n      else if (parser->m_defaultHandler)\n        reportDefault(parser, enc, s, next);\n      result\n          = doCdataSection(parser, enc, &next, end, nextPtr, haveMore, account);\n      if (result != XML_ERROR_NONE)\n        return result;\n      else if (! next) {\n        parser->m_processor = cdataSectionProcessor;\n        return result;\n      }\n    } break;\n    case XML_TOK_TRAILING_RSQB:\n      if (haveMore) {\n        *nextPtr = s;\n        return XML_ERROR_NONE;\n      }\n      if (parser->m_characterDataHandler) {\n        if (MUST_CONVERT(enc, s)) {\n          ICHAR *dataPtr = (ICHAR *)parser->m_dataBuf;\n          XmlConvert(enc, &s, end, &dataPtr, (ICHAR *)parser->m_dataBufEnd);\n          parser->m_characterDataHandler(\n              parser->m_handlerArg, parser->m_dataBuf,\n              (int)(dataPtr - (ICHAR *)parser->m_dataBuf));\n        } else\n          parser->m_characterDataHandler(\n              parser->m_handlerArg, (const XML_Char *)s,\n              (int)((const XML_Char *)end - (const XML_Char *)s));\n      } else if (parser->m_defaultHandler)\n        reportDefault(parser, enc, s, end);\n      /* We are at the end of the final buffer, should we check for\n         XML_SUSPENDED, XML_FINISHED?\n      */\n      if (startTagLevel == 0) {\n        *eventPP = end;\n        return XML_ERROR_NO_ELEMENTS;\n      }\n      if (parser->m_tagLevel != startTagLevel) {\n        *eventPP = end;\n        return XML_ERROR_ASYNC_ENTITY;\n      }\n      *nextPtr = end;\n      return XML_ERROR_NONE;\n    case XML_TOK_DATA_CHARS: {\n      XML_CharacterDataHandler charDataHandler = parser->m_characterDataHandler;\n      if (charDataHandler) {\n        if (MUST_CONVERT(enc, s)) {\n          for (;;) {\n            ICHAR *dataPtr = (ICHAR *)parser->m_dataBuf;\n            const enum XML_Convert_Result convert_res = XmlConvert(\n                enc, &s, next, &dataPtr, (ICHAR *)parser->m_dataBufEnd);\n            *eventEndPP = s;\n            charDataHandler(parser->m_handlerArg, parser->m_dataBuf,\n                            (int)(dataPtr - (ICHAR *)parser->m_dataBuf));\n            if ((convert_res == XML_CONVERT_COMPLETED)\n                || (convert_res == XML_CONVERT_INPUT_INCOMPLETE))\n              break;\n            *eventPP = s;\n          }\n        } else\n          charDataHandler(parser->m_handlerArg, (const XML_Char *)s,\n                          (int)((const XML_Char *)next - (const XML_Char *)s));\n      } else if (parser->m_defaultHandler)\n        reportDefault(parser, enc, s, next);\n    } break;\n    case XML_TOK_PI:\n      if (! reportProcessingInstruction(parser, enc, s, next))\n        return XML_ERROR_NO_MEMORY;\n      break;\n    case XML_TOK_COMMENT:\n      if (! reportComment(parser, enc, s, next))\n        return XML_ERROR_NO_MEMORY;\n      break;\n    default:\n      /* All of the tokens produced by XmlContentTok() have their own\n       * explicit cases, so this default is not strictly necessary.\n       * However it is a useful safety net, so we retain the code and\n       * simply exclude it from the coverage tests.\n       *\n       * LCOV_EXCL_START\n       */\n      if (parser->m_defaultHandler)\n        reportDefault(parser, enc, s, next);\n      break;\n      /* LCOV_EXCL_STOP */\n    }\n    *eventPP = s = next;\n    switch (parser->m_parsingStatus.parsing) {\n    case XML_SUSPENDED:\n      *nextPtr = next;\n      return XML_ERROR_NONE;\n    case XML_FINISHED:\n      return XML_ERROR_ABORTED;\n    default:;\n    }\n  }\n  /* not reached */\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -19,7 +19,7 @@\n   for (;;) {\n     const char *next = s; /* XmlContentTok doesn't always set the last arg */\n     int tok = XmlContentTok(enc, s, end, &next);\n-#ifdef XML_DTD\n+#if defined(XML_DTD) || XML_GE == 1\n     const char *accountAfter\n         = ((tok == XML_TOK_TRAILING_RSQB) || (tok == XML_TOK_TRAILING_CR))\n               ? (haveMore ? s /* i.e. 0 bytes */ : end)\n@@ -85,14 +85,14 @@\n       XML_Char ch = (XML_Char)XmlPredefinedEntityName(\n           enc, s + enc->minBytesPerChar, next - enc->minBytesPerChar);\n       if (ch) {\n-#ifdef XML_DTD\n+#if defined(XML_DTD) || XML_GE == 1\n         /* NOTE: We are replacing 4-6 characters original input for 1 character\n          *       so there is no amplification and hence recording without\n          *       protection. */\n         accountingDiffTolerated(parser, tok, (char *)&ch,\n                                 ((char *)&ch) + sizeof(XML_Char), __LINE__,\n                                 XML_ACCOUNT_ENTITY_EXPANSION);\n-#endif /* XML_DTD */\n+#endif /* defined(XML_DTD) || XML_GE == 1 */\n         if (parser->m_characterDataHandler)\n           parser->m_characterDataHandler(parser->m_handlerArg, &ch, 1);\n         else if (parser->m_defaultHandler)",
        "diff_line_info": {
            "deleted_lines": [
                "#ifdef XML_DTD",
                "#ifdef XML_DTD",
                "#endif /* XML_DTD */"
            ],
            "added_lines": [
                "#if defined(XML_DTD) || XML_GE == 1",
                "#if defined(XML_DTD) || XML_GE == 1",
                "#endif /* defined(XML_DTD) || XML_GE == 1 */"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-52426",
        "func_name": "libexpat/doIgnoreSection",
        "description": "libexpat through 2.5.0 allows recursive XML Entity Expansion if XML_DTD is undefined at compile time.",
        "git_url": "https://github.com/libexpat/libexpat/commit/0f075ec8ecb5e43f8fdca5182f8cca4703da0404",
        "commit_title": "lib|xmlwf|cmake: Extend scope of billion laughs attack protection",
        "commit_text": " .. from \"defined(XML_DTD)\" to \"defined(XML_DTD) || XML_GE==1\".",
        "func_before": "static enum XML_Error\ndoIgnoreSection(XML_Parser parser, const ENCODING *enc, const char **startPtr,\n                const char *end, const char **nextPtr, XML_Bool haveMore) {\n  const char *next = *startPtr; /* in case of XML_TOK_NONE or XML_TOK_PARTIAL */\n  int tok;\n  const char *s = *startPtr;\n  const char **eventPP;\n  const char **eventEndPP;\n  if (enc == parser->m_encoding) {\n    eventPP = &parser->m_eventPtr;\n    *eventPP = s;\n    eventEndPP = &parser->m_eventEndPtr;\n  } else {\n    /* It's not entirely clear, but it seems the following two lines\n     * of code cannot be executed.  The only occasions on which 'enc'\n     * is not 'encoding' are when this function is called\n     * from the internal entity processing, and IGNORE sections are an\n     * error in internal entities.\n     *\n     * Since it really isn't clear that this is true, we keep the code\n     * and just remove it from our coverage tests.\n     *\n     * LCOV_EXCL_START\n     */\n    eventPP = &(parser->m_openInternalEntities->internalEventPtr);\n    eventEndPP = &(parser->m_openInternalEntities->internalEventEndPtr);\n    /* LCOV_EXCL_STOP */\n  }\n  *eventPP = s;\n  *startPtr = NULL;\n  tok = XmlIgnoreSectionTok(enc, s, end, &next);\n#  ifdef XML_DTD\n  if (! accountingDiffTolerated(parser, tok, s, next, __LINE__,\n                                XML_ACCOUNT_DIRECT)) {\n    accountingOnAbort(parser);\n    return XML_ERROR_AMPLIFICATION_LIMIT_BREACH;\n  }\n#  endif\n  *eventEndPP = next;\n  switch (tok) {\n  case XML_TOK_IGNORE_SECT:\n    if (parser->m_defaultHandler)\n      reportDefault(parser, enc, s, next);\n    *startPtr = next;\n    *nextPtr = next;\n    if (parser->m_parsingStatus.parsing == XML_FINISHED)\n      return XML_ERROR_ABORTED;\n    else\n      return XML_ERROR_NONE;\n  case XML_TOK_INVALID:\n    *eventPP = next;\n    return XML_ERROR_INVALID_TOKEN;\n  case XML_TOK_PARTIAL_CHAR:\n    if (haveMore) {\n      *nextPtr = s;\n      return XML_ERROR_NONE;\n    }\n    return XML_ERROR_PARTIAL_CHAR;\n  case XML_TOK_PARTIAL:\n  case XML_TOK_NONE:\n    if (haveMore) {\n      *nextPtr = s;\n      return XML_ERROR_NONE;\n    }\n    return XML_ERROR_SYNTAX; /* XML_ERROR_UNCLOSED_IGNORE_SECTION */\n  default:\n    /* All of the tokens that XmlIgnoreSectionTok() returns have\n     * explicit cases to handle them, so this default case is never\n     * executed.  We keep it as a safety net anyway, and remove it\n     * from our test coverage statistics.\n     *\n     * LCOV_EXCL_START\n     */\n    *eventPP = next;\n    return XML_ERROR_UNEXPECTED_STATE;\n    /* LCOV_EXCL_STOP */\n  }\n  /* not reached */\n}",
        "func": "static enum XML_Error\ndoIgnoreSection(XML_Parser parser, const ENCODING *enc, const char **startPtr,\n                const char *end, const char **nextPtr, XML_Bool haveMore) {\n  const char *next = *startPtr; /* in case of XML_TOK_NONE or XML_TOK_PARTIAL */\n  int tok;\n  const char *s = *startPtr;\n  const char **eventPP;\n  const char **eventEndPP;\n  if (enc == parser->m_encoding) {\n    eventPP = &parser->m_eventPtr;\n    *eventPP = s;\n    eventEndPP = &parser->m_eventEndPtr;\n  } else {\n    /* It's not entirely clear, but it seems the following two lines\n     * of code cannot be executed.  The only occasions on which 'enc'\n     * is not 'encoding' are when this function is called\n     * from the internal entity processing, and IGNORE sections are an\n     * error in internal entities.\n     *\n     * Since it really isn't clear that this is true, we keep the code\n     * and just remove it from our coverage tests.\n     *\n     * LCOV_EXCL_START\n     */\n    eventPP = &(parser->m_openInternalEntities->internalEventPtr);\n    eventEndPP = &(parser->m_openInternalEntities->internalEventEndPtr);\n    /* LCOV_EXCL_STOP */\n  }\n  *eventPP = s;\n  *startPtr = NULL;\n  tok = XmlIgnoreSectionTok(enc, s, end, &next);\n#  if defined(XML_DTD) || XML_GE == 1\n  if (! accountingDiffTolerated(parser, tok, s, next, __LINE__,\n                                XML_ACCOUNT_DIRECT)) {\n    accountingOnAbort(parser);\n    return XML_ERROR_AMPLIFICATION_LIMIT_BREACH;\n  }\n#  endif\n  *eventEndPP = next;\n  switch (tok) {\n  case XML_TOK_IGNORE_SECT:\n    if (parser->m_defaultHandler)\n      reportDefault(parser, enc, s, next);\n    *startPtr = next;\n    *nextPtr = next;\n    if (parser->m_parsingStatus.parsing == XML_FINISHED)\n      return XML_ERROR_ABORTED;\n    else\n      return XML_ERROR_NONE;\n  case XML_TOK_INVALID:\n    *eventPP = next;\n    return XML_ERROR_INVALID_TOKEN;\n  case XML_TOK_PARTIAL_CHAR:\n    if (haveMore) {\n      *nextPtr = s;\n      return XML_ERROR_NONE;\n    }\n    return XML_ERROR_PARTIAL_CHAR;\n  case XML_TOK_PARTIAL:\n  case XML_TOK_NONE:\n    if (haveMore) {\n      *nextPtr = s;\n      return XML_ERROR_NONE;\n    }\n    return XML_ERROR_SYNTAX; /* XML_ERROR_UNCLOSED_IGNORE_SECTION */\n  default:\n    /* All of the tokens that XmlIgnoreSectionTok() returns have\n     * explicit cases to handle them, so this default case is never\n     * executed.  We keep it as a safety net anyway, and remove it\n     * from our test coverage statistics.\n     *\n     * LCOV_EXCL_START\n     */\n    *eventPP = next;\n    return XML_ERROR_UNEXPECTED_STATE;\n    /* LCOV_EXCL_STOP */\n  }\n  /* not reached */\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -29,7 +29,7 @@\n   *eventPP = s;\n   *startPtr = NULL;\n   tok = XmlIgnoreSectionTok(enc, s, end, &next);\n-#  ifdef XML_DTD\n+#  if defined(XML_DTD) || XML_GE == 1\n   if (! accountingDiffTolerated(parser, tok, s, next, __LINE__,\n                                 XML_ACCOUNT_DIRECT)) {\n     accountingOnAbort(parser);",
        "diff_line_info": {
            "deleted_lines": [
                "#  ifdef XML_DTD"
            ],
            "added_lines": [
                "#  if defined(XML_DTD) || XML_GE == 1"
            ]
        }
    }
]