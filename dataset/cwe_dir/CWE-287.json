[
    {
        "cve_id": "CVE-2017-6062",
        "func_name": "OpenIDC/mod_auth_openidc/oidc_check_userid_openidc",
        "description": "The \"OpenID Connect Relying Party and OAuth 2.0 Resource Server\" (aka mod_auth_openidc) module before 2.1.5 for the Apache HTTP Server does not skip OIDC_CLAIM_ and OIDCAuthNHeader headers in an \"OIDCUnAuthAction pass\" configuration, which allows remote attackers to bypass authentication via crafted HTTP traffic.",
        "git_url": "https://github.com/OpenIDC/mod_auth_openidc/commit/e81822a7d5f5bdf04ba03ca92680821893303850",
        "commit_title": "security fix: scrub headers on `OIDCUnAuthAction pass`; closes #222",
        "commit_text": " On accessing paths protected with `OIDCUnAuthAction pass` no headers would be scrubbed when a user is not authenticated so malicious software/users could set OIDC_CLAIM_ and OIDCAuthNHeader headers that applications would interpret as set by mod_auth_openidc. Thanks @wouterhund. ",
        "func_before": "static int oidc_check_userid_openidc(request_rec *r, oidc_cfg *c) {\n\n\tif (c->redirect_uri == NULL) {\n\t\toidc_error(r,\n\t\t\t\t\"configuration error: the authentication type is set to \\\"openid-connect\\\" but OIDCRedirectURI has not been set\");\n\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t}\n\n\t/* check if this is a sub-request or an initial request */\n\tif (ap_is_initial_req(r)) {\n\n\t\tint rc = OK;\n\n\t\t/* load the session from the request state; this will be a new \"empty\" session if no state exists */\n\t\toidc_session_t *session = NULL;\n\t\toidc_session_load(r, &session);\n\n\t\t/* see if the initial request is to the redirect URI; this handles potential logout too */\n\t\tif (oidc_util_request_matches_url(r, c->redirect_uri)) {\n\n\t\t\t/* handle request to the redirect_uri */\n\t\t\trc = oidc_handle_redirect_uri_request(r, c, session);\n\n\t\t\t/* free resources allocated for the session */\n\t\t\toidc_session_free(r, session);\n\n\t\t\treturn rc;\n\n\t\t/* initial request to non-redirect URI, check if we have an existing session */\n\t\t} else if (session->remote_user != NULL) {\n\n\t\t\t/* set the user in the main request for further (incl. sub-request) processing */\n\t\t\tr->user = (char *) session->remote_user;\n\n\t\t\t/* this is initial request and we already have a session */\n\t\t\trc = oidc_handle_existing_session(r, c, session);\n\n\t\t\t/* free resources allocated for the session */\n\t\t\toidc_session_free(r, session);\n\n\t\t\t/* strip any cookies that we need to */\n\t\t\toidc_strip_cookies(r);\n\n\t\t\treturn rc;\n\t\t}\n\n\t\t/* free resources allocated for the session */\n\t\toidc_session_free(r, session);\n\n\t\t/*\n\t\t * else: initial request, we have no session and it is not an authorization or\n\t\t *       discovery response: just hit the default flow for unauthenticated users\n\t\t */\n\t} else {\n\n\t\t/* not an initial request, try to recycle what we've already established in the main request */\n\t\tif (r->main != NULL)\n\t\t\tr->user = r->main->user;\n\t\telse if (r->prev != NULL)\n\t\t\tr->user = r->prev->user;\n\n\t\tif (r->user != NULL) {\n\n\t\t\t/* this is a sub-request and we have a session (headers will have been scrubbed and set already) */\n\t\t\toidc_debug(r,\n\t\t\t\t\t\"recycling user '%s' from initial request for sub-request\",\n\t\t\t\t\tr->user);\n\n\t\t\t/*\n\t\t\t * apparently request state can get lost in sub-requests, so let's see\n\t\t\t * if we need to restore id_token and/or claims from the session cache\n\t\t\t */\n\t\t\tconst char *s_id_token = oidc_request_state_get(r,\n\t\t\t\t\tOIDC_IDTOKEN_CLAIMS_SESSION_KEY);\n\t\t\tif (s_id_token == NULL) {\n\n\t\t\t\toidc_session_t *session = NULL;\n\t\t\t\toidc_session_load(r, &session);\n\n\t\t\t\toidc_copy_tokens_to_request_state(r, session, NULL, NULL);\n\n\t\t\t\t/* free resources allocated for the session */\n\t\t\t\toidc_session_free(r, session);\n\t\t\t}\n\n\t\t\t/* strip any cookies that we need to */\n\t\t\toidc_strip_cookies(r);\n\n\t\t\treturn OK;\n\t\t}\n\t\t/*\n\t\t * else: not initial request, but we could not find a session, so:\n\t\t * just hit the default flow for unauthenticated users\n\t\t */\n\t}\n\n\t/* find out which action we need to take when encountering an unauthenticated request */\n\tswitch (oidc_dir_cfg_unauth_action(r)) {\n\t\tcase OIDC_UNAUTH_RETURN410:\n\t\t\treturn HTTP_GONE;\n\t\tcase OIDC_UNAUTH_RETURN401:\n\t\t\treturn HTTP_UNAUTHORIZED;\n\t\tcase OIDC_UNAUTH_PASS:\n\t\t\tr->user = \"\";\n\t\t\treturn OK;\n\t\tcase OIDC_UNAUTH_AUTHENTICATE:\n\t\t\t/* if this is a Javascript path we won't redirect the user and create a state cookie */\n\t\t\tif (apr_table_get(r->headers_in, \"X-Requested-With\") != NULL)\n\t\t\t\treturn HTTP_UNAUTHORIZED;\n\t\t\tbreak;\n\t}\n\n\t/* else: no session (regardless of whether it is main or sub-request), go and authenticate the user */\n\treturn oidc_authenticate_user(r, c, NULL, oidc_get_current_url(r), NULL,\n\t\t\tNULL, NULL, NULL);\n}",
        "func": "static int oidc_check_userid_openidc(request_rec *r, oidc_cfg *c) {\n\n\tif (c->redirect_uri == NULL) {\n\t\toidc_error(r,\n\t\t\t\t\"configuration error: the authentication type is set to \\\"openid-connect\\\" but OIDCRedirectURI has not been set\");\n\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t}\n\n\t/* check if this is a sub-request or an initial request */\n\tif (ap_is_initial_req(r)) {\n\n\t\tint rc = OK;\n\n\t\t/* load the session from the request state; this will be a new \"empty\" session if no state exists */\n\t\toidc_session_t *session = NULL;\n\t\toidc_session_load(r, &session);\n\n\t\t/* see if the initial request is to the redirect URI; this handles potential logout too */\n\t\tif (oidc_util_request_matches_url(r, c->redirect_uri)) {\n\n\t\t\t/* handle request to the redirect_uri */\n\t\t\trc = oidc_handle_redirect_uri_request(r, c, session);\n\n\t\t\t/* free resources allocated for the session */\n\t\t\toidc_session_free(r, session);\n\n\t\t\treturn rc;\n\n\t\t/* initial request to non-redirect URI, check if we have an existing session */\n\t\t} else if (session->remote_user != NULL) {\n\n\t\t\t/* set the user in the main request for further (incl. sub-request) processing */\n\t\t\tr->user = (char *) session->remote_user;\n\n\t\t\t/* this is initial request and we already have a session */\n\t\t\trc = oidc_handle_existing_session(r, c, session);\n\n\t\t\t/* free resources allocated for the session */\n\t\t\toidc_session_free(r, session);\n\n\t\t\t/* strip any cookies that we need to */\n\t\t\toidc_strip_cookies(r);\n\n\t\t\treturn rc;\n\t\t}\n\n\t\t/* free resources allocated for the session */\n\t\toidc_session_free(r, session);\n\n\t\t/*\n\t\t * else: initial request, we have no session and it is not an authorization or\n\t\t *       discovery response: just hit the default flow for unauthenticated users\n\t\t */\n\t} else {\n\n\t\t/* not an initial request, try to recycle what we've already established in the main request */\n\t\tif (r->main != NULL)\n\t\t\tr->user = r->main->user;\n\t\telse if (r->prev != NULL)\n\t\t\tr->user = r->prev->user;\n\n\t\tif (r->user != NULL) {\n\n\t\t\t/* this is a sub-request and we have a session (headers will have been scrubbed and set already) */\n\t\t\toidc_debug(r,\n\t\t\t\t\t\"recycling user '%s' from initial request for sub-request\",\n\t\t\t\t\tr->user);\n\n\t\t\t/*\n\t\t\t * apparently request state can get lost in sub-requests, so let's see\n\t\t\t * if we need to restore id_token and/or claims from the session cache\n\t\t\t */\n\t\t\tconst char *s_id_token = oidc_request_state_get(r,\n\t\t\t\t\tOIDC_IDTOKEN_CLAIMS_SESSION_KEY);\n\t\t\tif (s_id_token == NULL) {\n\n\t\t\t\toidc_session_t *session = NULL;\n\t\t\t\toidc_session_load(r, &session);\n\n\t\t\t\toidc_copy_tokens_to_request_state(r, session, NULL, NULL);\n\n\t\t\t\t/* free resources allocated for the session */\n\t\t\t\toidc_session_free(r, session);\n\t\t\t}\n\n\t\t\t/* strip any cookies that we need to */\n\t\t\toidc_strip_cookies(r);\n\n\t\t\treturn OK;\n\t\t}\n\t\t/*\n\t\t * else: not initial request, but we could not find a session, so:\n\t\t * just hit the default flow for unauthenticated users\n\t\t */\n\t}\n\n\t/* find out which action we need to take when encountering an unauthenticated request */\n\tswitch (oidc_dir_cfg_unauth_action(r)) {\n\t\tcase OIDC_UNAUTH_RETURN410:\n\t\t\treturn HTTP_GONE;\n\t\tcase OIDC_UNAUTH_RETURN401:\n\t\t\treturn HTTP_UNAUTHORIZED;\n\t\tcase OIDC_UNAUTH_PASS:\n\t\t\tr->user = \"\";\n\n\t\t\t/*\n\t\t\t * we're not going to pass information about an authenticated user to the application,\n\t\t\t * but we do need to scrub the headers that mod_auth_openidc would set for security reasons\n\t\t\t */\n\t\t\toidc_scrub_headers(r);\n\n\t\t\treturn OK;\n\t\tcase OIDC_UNAUTH_AUTHENTICATE:\n\t\t\t/* if this is a Javascript path we won't redirect the user and create a state cookie */\n\t\t\tif (apr_table_get(r->headers_in, \"X-Requested-With\") != NULL)\n\t\t\t\treturn HTTP_UNAUTHORIZED;\n\t\t\tbreak;\n\t}\n\n\t/* else: no session (regardless of whether it is main or sub-request), go and authenticate the user */\n\treturn oidc_authenticate_user(r, c, NULL, oidc_get_current_url(r), NULL,\n\t\t\tNULL, NULL, NULL);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -102,6 +102,13 @@\n \t\t\treturn HTTP_UNAUTHORIZED;\n \t\tcase OIDC_UNAUTH_PASS:\n \t\t\tr->user = \"\";\n+\n+\t\t\t/*\n+\t\t\t * we're not going to pass information about an authenticated user to the application,\n+\t\t\t * but we do need to scrub the headers that mod_auth_openidc would set for security reasons\n+\t\t\t */\n+\t\t\toidc_scrub_headers(r);\n+\n \t\t\treturn OK;\n \t\tcase OIDC_UNAUTH_AUTHENTICATE:\n \t\t\t/* if this is a Javascript path we won't redirect the user and create a state cookie */",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "\t\t\t/*",
                "\t\t\t * we're not going to pass information about an authenticated user to the application,",
                "\t\t\t * but we do need to scrub the headers that mod_auth_openidc would set for security reasons",
                "\t\t\t */",
                "\t\t\toidc_scrub_headers(r);",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2017-6062",
        "func_name": "OpenIDC/mod_auth_openidc/oidc_handle_existing_session",
        "description": "The \"OpenID Connect Relying Party and OAuth 2.0 Resource Server\" (aka mod_auth_openidc) module before 2.1.5 for the Apache HTTP Server does not skip OIDC_CLAIM_ and OIDCAuthNHeader headers in an \"OIDCUnAuthAction pass\" configuration, which allows remote attackers to bypass authentication via crafted HTTP traffic.",
        "git_url": "https://github.com/OpenIDC/mod_auth_openidc/commit/e81822a7d5f5bdf04ba03ca92680821893303850",
        "commit_title": "security fix: scrub headers on `OIDCUnAuthAction pass`; closes #222",
        "commit_text": " On accessing paths protected with `OIDCUnAuthAction pass` no headers would be scrubbed when a user is not authenticated so malicious software/users could set OIDC_CLAIM_ and OIDCAuthNHeader headers that applications would interpret as set by mod_auth_openidc. Thanks @wouterhund. ",
        "func_before": "static int oidc_handle_existing_session(request_rec *r, oidc_cfg *cfg,\n\t\toidc_session_t *session) {\n\n\toidc_debug(r, \"enter\");\n\n\t/* get the header name in which the remote user name needs to be passed */\n\tchar *authn_header = oidc_cfg_dir_authn_header(r);\n\tint pass_headers = oidc_cfg_dir_pass_info_in_headers(r);\n\tint pass_envvars = oidc_cfg_dir_pass_info_in_envvars(r);\n\n\t/* verify current cookie domain against issued cookie domain */\n\tif (oidc_check_cookie_domain(r, cfg, session) == FALSE)\n\t\treturn HTTP_UNAUTHORIZED;\n\n\t/* check if the maximum session duration was exceeded */\n\tint rc = oidc_check_max_session_duration(r, cfg, session);\n\tif (rc != OK)\n\t\treturn rc;\n\n\t/* if needed, refresh claims from the user info endpoint */\n\tapr_byte_t needs_save = oidc_refresh_claims_from_userinfo_endpoint(r, cfg,\n\t\t\tsession);\n\n\t/*\n\t * we're going to pass the information that we have to the application,\n\t * but first we need to scrub the headers that we're going to use for security reasons\n\t */\n\tif (cfg->scrub_request_headers != 0) {\n\n\t\t/* scrub all headers starting with OIDC_ first */\n\t\toidc_scrub_request_headers(r, OIDC_DEFAULT_HEADER_PREFIX,\n\t\t\t\toidc_cfg_dir_authn_header(r));\n\n\t\t/*\n\t\t * then see if the claim headers need to be removed on top of that\n\t\t * (i.e. the prefix does not start with the default OIDC_)\n\t\t */\n\t\tif ((strstr(cfg->claim_prefix, OIDC_DEFAULT_HEADER_PREFIX)\n\t\t\t\t!= cfg->claim_prefix)) {\n\t\t\toidc_scrub_request_headers(r, cfg->claim_prefix, NULL);\n\t\t}\n\t}\n\n\t/* set the user authentication HTTP header if set and required */\n\tif ((r->user != NULL) && (authn_header != NULL))\n\t\toidc_util_set_header(r, authn_header, r->user);\n\n\tconst char *s_claims = NULL;\n\tconst char *s_id_token = NULL;\n\n\t/* copy id_token and claims from session to request state and obtain their values */\n\toidc_copy_tokens_to_request_state(r, session, &s_id_token, &s_claims);\n\n\t/* set the claims in the app headers  */\n\tif (oidc_set_app_claims(r, cfg, session, s_claims) == FALSE)\n\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\n\tif ((cfg->pass_idtoken_as & OIDC_PASS_IDTOKEN_AS_CLAIMS)) {\n\t\t/* set the id_token in the app headers */\n\t\tif (oidc_set_app_claims(r, cfg, session, s_id_token) == FALSE)\n\t\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t}\n\n\tif ((cfg->pass_idtoken_as & OIDC_PASS_IDTOKEN_AS_PAYLOAD)) {\n\t\t/* pass the id_token JSON object to the app in a header or environment variable */\n\t\toidc_util_set_app_info(r, \"id_token_payload\", s_id_token,\n\t\t\t\tOIDC_DEFAULT_HEADER_PREFIX, pass_headers, pass_envvars);\n\t}\n\n\tif ((cfg->pass_idtoken_as & OIDC_PASS_IDTOKEN_AS_SERIALIZED)) {\n\t\tif (cfg->session_type != OIDC_SESSION_TYPE_CLIENT_COOKIE) {\n\t\t\tconst char *s_id_token = NULL;\n\t\t\t/* get the compact serialized JWT from the session */\n\t\t\toidc_session_get(r, session, OIDC_IDTOKEN_SESSION_KEY, &s_id_token);\n\t\t\t/* pass the compact serialized JWT to the app in a header or environment variable */\n\t\t\toidc_util_set_app_info(r, \"id_token\", s_id_token,\n\t\t\t\t\tOIDC_DEFAULT_HEADER_PREFIX, pass_headers, pass_envvars);\n\t\t} else {\n\t\t\toidc_error(r,\n\t\t\t\t\t\"session type \\\"client-cookie\\\" does not allow storing/passing the id_token; use \\\"OIDCSessionType server-cache\\\" for that\");\n\t\t}\n\t}\n\n\t/* set the refresh_token in the app headers/variables, if enabled for this location/directory */\n\tconst char *refresh_token = NULL;\n\toidc_session_get(r, session, OIDC_REFRESHTOKEN_SESSION_KEY, &refresh_token);\n\tif ((oidc_cfg_dir_pass_refresh_token(r) != 0) && (refresh_token != NULL)) {\n\t\t/* pass it to the app in a header or environment variable */\n\t\toidc_util_set_app_info(r, \"refresh_token\", refresh_token,\n\t\t\t\tOIDC_DEFAULT_HEADER_PREFIX, pass_headers, pass_envvars);\n\t}\n\n\t/* set the access_token in the app headers/variables */\n\tconst char *access_token = NULL;\n\toidc_session_get(r, session, OIDC_ACCESSTOKEN_SESSION_KEY, &access_token);\n\tif (access_token != NULL) {\n\t\t/* pass it to the app in a header or environment variable */\n\t\toidc_util_set_app_info(r, \"access_token\", access_token,\n\t\t\t\tOIDC_DEFAULT_HEADER_PREFIX, pass_headers, pass_envvars);\n\t}\n\n\t/* set the expiry timestamp in the app headers/variables */\n\tconst char *access_token_expires = NULL;\n\toidc_session_get(r, session, OIDC_ACCESSTOKEN_EXPIRES_SESSION_KEY,\n\t\t\t&access_token_expires);\n\tif (access_token_expires != NULL) {\n\t\t/* pass it to the app in a header or environment variable */\n\t\toidc_util_set_app_info(r, \"access_token_expires\", access_token_expires,\n\t\t\t\tOIDC_DEFAULT_HEADER_PREFIX, pass_headers, pass_envvars);\n\t}\n\n\t/*\n\t * reset the session inactivity timer\n\t * but only do this once per 10% of the inactivity timeout interval (with a max to 60 seconds)\n\t * for performance reasons\n\t *\n\t * now there's a small chance that the session ends 10% (or a minute) earlier than configured/expected\n\t * cq. when there's a request after a recent save (so no update) and then no activity happens until\n\t * a request comes in just before the session should expire\n\t * (\"recent\" and \"just before\" refer to 10%-with-a-max-of-60-seconds of the inactivity interval after\n\t * the start/last-update and before the expiry of the session respectively)\n\t *\n\t * this is be deemed acceptable here because of performance gain\n\t */\n\tapr_time_t interval = apr_time_from_sec(cfg->session_inactivity_timeout);\n\tapr_time_t now = apr_time_now();\n\tapr_time_t slack = interval / 10;\n\tif (slack > apr_time_from_sec(60))\n\t\tslack = apr_time_from_sec(60);\n\tif (session->expiry - now < interval - slack) {\n\t\tsession->expiry = now + interval;\n\t\tneeds_save = TRUE;\n\t}\n\n\t/* check if something was updated in the session and we need to save it again */\n\tif (needs_save)\n\t\tif (oidc_session_save(r, session) == FALSE)\n\t\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\n\t/* return \"user authenticated\" status */\n\treturn OK;\n}",
        "func": "static int oidc_handle_existing_session(request_rec *r, oidc_cfg *cfg,\n\t\toidc_session_t *session) {\n\n\toidc_debug(r, \"enter\");\n\n\t/* get the header name in which the remote user name needs to be passed */\n\tchar *authn_header = oidc_cfg_dir_authn_header(r);\n\tint pass_headers = oidc_cfg_dir_pass_info_in_headers(r);\n\tint pass_envvars = oidc_cfg_dir_pass_info_in_envvars(r);\n\n\t/* verify current cookie domain against issued cookie domain */\n\tif (oidc_check_cookie_domain(r, cfg, session) == FALSE)\n\t\treturn HTTP_UNAUTHORIZED;\n\n\t/* check if the maximum session duration was exceeded */\n\tint rc = oidc_check_max_session_duration(r, cfg, session);\n\tif (rc != OK)\n\t\treturn rc;\n\n\t/* if needed, refresh claims from the user info endpoint */\n\tapr_byte_t needs_save = oidc_refresh_claims_from_userinfo_endpoint(r, cfg,\n\t\t\tsession);\n\n\t/*\n\t * we're going to pass the information that we have to the application,\n\t * but first we need to scrub the headers that we're going to use for security reasons\n\t */\n\toidc_scrub_headers(r);\n\n\t/* set the user authentication HTTP header if set and required */\n\tif ((r->user != NULL) && (authn_header != NULL))\n\t\toidc_util_set_header(r, authn_header, r->user);\n\n\tconst char *s_claims = NULL;\n\tconst char *s_id_token = NULL;\n\n\t/* copy id_token and claims from session to request state and obtain their values */\n\toidc_copy_tokens_to_request_state(r, session, &s_id_token, &s_claims);\n\n\t/* set the claims in the app headers  */\n\tif (oidc_set_app_claims(r, cfg, session, s_claims) == FALSE)\n\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\n\tif ((cfg->pass_idtoken_as & OIDC_PASS_IDTOKEN_AS_CLAIMS)) {\n\t\t/* set the id_token in the app headers */\n\t\tif (oidc_set_app_claims(r, cfg, session, s_id_token) == FALSE)\n\t\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t}\n\n\tif ((cfg->pass_idtoken_as & OIDC_PASS_IDTOKEN_AS_PAYLOAD)) {\n\t\t/* pass the id_token JSON object to the app in a header or environment variable */\n\t\toidc_util_set_app_info(r, \"id_token_payload\", s_id_token,\n\t\t\t\tOIDC_DEFAULT_HEADER_PREFIX, pass_headers, pass_envvars);\n\t}\n\n\tif ((cfg->pass_idtoken_as & OIDC_PASS_IDTOKEN_AS_SERIALIZED)) {\n\t\tif (cfg->session_type != OIDC_SESSION_TYPE_CLIENT_COOKIE) {\n\t\t\tconst char *s_id_token = NULL;\n\t\t\t/* get the compact serialized JWT from the session */\n\t\t\toidc_session_get(r, session, OIDC_IDTOKEN_SESSION_KEY, &s_id_token);\n\t\t\t/* pass the compact serialized JWT to the app in a header or environment variable */\n\t\t\toidc_util_set_app_info(r, \"id_token\", s_id_token,\n\t\t\t\t\tOIDC_DEFAULT_HEADER_PREFIX, pass_headers, pass_envvars);\n\t\t} else {\n\t\t\toidc_error(r,\n\t\t\t\t\t\"session type \\\"client-cookie\\\" does not allow storing/passing the id_token; use \\\"OIDCSessionType server-cache\\\" for that\");\n\t\t}\n\t}\n\n\t/* set the refresh_token in the app headers/variables, if enabled for this location/directory */\n\tconst char *refresh_token = NULL;\n\toidc_session_get(r, session, OIDC_REFRESHTOKEN_SESSION_KEY, &refresh_token);\n\tif ((oidc_cfg_dir_pass_refresh_token(r) != 0) && (refresh_token != NULL)) {\n\t\t/* pass it to the app in a header or environment variable */\n\t\toidc_util_set_app_info(r, \"refresh_token\", refresh_token,\n\t\t\t\tOIDC_DEFAULT_HEADER_PREFIX, pass_headers, pass_envvars);\n\t}\n\n\t/* set the access_token in the app headers/variables */\n\tconst char *access_token = NULL;\n\toidc_session_get(r, session, OIDC_ACCESSTOKEN_SESSION_KEY, &access_token);\n\tif (access_token != NULL) {\n\t\t/* pass it to the app in a header or environment variable */\n\t\toidc_util_set_app_info(r, \"access_token\", access_token,\n\t\t\t\tOIDC_DEFAULT_HEADER_PREFIX, pass_headers, pass_envvars);\n\t}\n\n\t/* set the expiry timestamp in the app headers/variables */\n\tconst char *access_token_expires = NULL;\n\toidc_session_get(r, session, OIDC_ACCESSTOKEN_EXPIRES_SESSION_KEY,\n\t\t\t&access_token_expires);\n\tif (access_token_expires != NULL) {\n\t\t/* pass it to the app in a header or environment variable */\n\t\toidc_util_set_app_info(r, \"access_token_expires\", access_token_expires,\n\t\t\t\tOIDC_DEFAULT_HEADER_PREFIX, pass_headers, pass_envvars);\n\t}\n\n\t/*\n\t * reset the session inactivity timer\n\t * but only do this once per 10% of the inactivity timeout interval (with a max to 60 seconds)\n\t * for performance reasons\n\t *\n\t * now there's a small chance that the session ends 10% (or a minute) earlier than configured/expected\n\t * cq. when there's a request after a recent save (so no update) and then no activity happens until\n\t * a request comes in just before the session should expire\n\t * (\"recent\" and \"just before\" refer to 10%-with-a-max-of-60-seconds of the inactivity interval after\n\t * the start/last-update and before the expiry of the session respectively)\n\t *\n\t * this is be deemed acceptable here because of performance gain\n\t */\n\tapr_time_t interval = apr_time_from_sec(cfg->session_inactivity_timeout);\n\tapr_time_t now = apr_time_now();\n\tapr_time_t slack = interval / 10;\n\tif (slack > apr_time_from_sec(60))\n\t\tslack = apr_time_from_sec(60);\n\tif (session->expiry - now < interval - slack) {\n\t\tsession->expiry = now + interval;\n\t\tneeds_save = TRUE;\n\t}\n\n\t/* check if something was updated in the session and we need to save it again */\n\tif (needs_save)\n\t\tif (oidc_session_save(r, session) == FALSE)\n\t\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\n\t/* return \"user authenticated\" status */\n\treturn OK;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -25,21 +25,7 @@\n \t * we're going to pass the information that we have to the application,\n \t * but first we need to scrub the headers that we're going to use for security reasons\n \t */\n-\tif (cfg->scrub_request_headers != 0) {\n-\n-\t\t/* scrub all headers starting with OIDC_ first */\n-\t\toidc_scrub_request_headers(r, OIDC_DEFAULT_HEADER_PREFIX,\n-\t\t\t\toidc_cfg_dir_authn_header(r));\n-\n-\t\t/*\n-\t\t * then see if the claim headers need to be removed on top of that\n-\t\t * (i.e. the prefix does not start with the default OIDC_)\n-\t\t */\n-\t\tif ((strstr(cfg->claim_prefix, OIDC_DEFAULT_HEADER_PREFIX)\n-\t\t\t\t!= cfg->claim_prefix)) {\n-\t\t\toidc_scrub_request_headers(r, cfg->claim_prefix, NULL);\n-\t\t}\n-\t}\n+\toidc_scrub_headers(r);\n \n \t/* set the user authentication HTTP header if set and required */\n \tif ((r->user != NULL) && (authn_header != NULL))",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (cfg->scrub_request_headers != 0) {",
                "",
                "\t\t/* scrub all headers starting with OIDC_ first */",
                "\t\toidc_scrub_request_headers(r, OIDC_DEFAULT_HEADER_PREFIX,",
                "\t\t\t\toidc_cfg_dir_authn_header(r));",
                "",
                "\t\t/*",
                "\t\t * then see if the claim headers need to be removed on top of that",
                "\t\t * (i.e. the prefix does not start with the default OIDC_)",
                "\t\t */",
                "\t\tif ((strstr(cfg->claim_prefix, OIDC_DEFAULT_HEADER_PREFIX)",
                "\t\t\t\t!= cfg->claim_prefix)) {",
                "\t\t\toidc_scrub_request_headers(r, cfg->claim_prefix, NULL);",
                "\t\t}",
                "\t}"
            ],
            "added_lines": [
                "\toidc_scrub_headers(r);"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-24976",
        "func_name": "atheme/sasl_handle_login",
        "description": "Atheme IRC Services before 7.2.12, when used in conjunction with InspIRCd, allows authentication bypass by ending an IRC handshake at a certain point during a challenge-response login sequence.",
        "git_url": "https://github.com/atheme/atheme/commit/4e664c75d0b280a052eb8b5e81aa41944e593c52",
        "commit_title": "saslserv/main: Track EID we're pending login to",
        "commit_text": " The existing model does not remember that we've sent a SVSLOGIN for a given SASL session, and simply assumes that if a client is introduced with a SASL session open, that session must have succeeded. The security of this approach requires ircd to implicitly abort SASL sessions on client registration.  This also means that if a client successfully authenticates and then does something else its pending login is forgotten about, even though a SVSLOGIN has been sent for it, and the ircd is going to think it's logged in.  This change removes the dependency on ircd's state machine by keeping explicit track of the pending login, i.e. the one we've most recently sent a SVSLOGIN for. The next commit will ensure that a client abort (even an implicit one) doesn't blow that information away.",
        "func_before": "static bool\nsasl_handle_login(struct sasl_session *const restrict p, struct user *const u, struct myuser *mu)\n{\n\tbool was_killed = false;\n\n\t// Find the account if necessary\n\tif (! mu)\n\t{\n\t\tif (! *p->authzeid)\n\t\t{\n\t\t\t(void) slog(LG_INFO, \"%s: session for '%s' without an authzeid (BUG)\",\n\t\t\t                     MOWGLI_FUNC_NAME, u->nick);\n\t\t\t(void) notice(saslsvs->nick, u->nick, LOGIN_CANCELLED_STR);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (! (mu = myuser_find_uid(p->authzeid)))\n\t\t{\n\t\t\tif (*p->authzid)\n\t\t\t\t(void) notice(saslsvs->nick, u->nick, \"Account %s dropped; login cancelled\",\n\t\t\t\t                                      p->authzid);\n\t\t\telse\n\t\t\t\t(void) notice(saslsvs->nick, u->nick, \"Account dropped; login cancelled\");\n\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t// If the user is already logged in, and not to the same account, log them out first\n\tif (u->myuser && u->myuser != mu)\n\t{\n\t\tif (is_soper(u->myuser))\n\t\t\t(void) logcommand_user(saslsvs, u, CMDLOG_ADMIN, \"DESOPER: \\2%s\\2 as \\2%s\\2\",\n\t\t\t                                                 u->nick, entity(u->myuser)->name);\n\n\t\t(void) logcommand_user(saslsvs, u, CMDLOG_LOGIN, \"LOGOUT\");\n\n\t\tif (! (was_killed = ircd_on_logout(u, entity(u->myuser)->name)))\n\t\t{\n\t\t\tmowgli_node_t *n;\n\n\t\t\tMOWGLI_ITER_FOREACH(n, u->myuser->logins.head)\n\t\t\t{\n\t\t\t\tif (n->data == u)\n\t\t\t\t{\n\t\t\t\t\t(void) mowgli_node_delete(n, &u->myuser->logins);\n\t\t\t\t\t(void) mowgli_node_free(n);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tu->myuser = NULL;\n\t\t}\n\t}\n\n\t// If they were not killed above, log them in now\n\tif (! was_killed)\n\t{\n\t\tif (u->myuser != mu)\n\t\t{\n\t\t\t// If they're not logged in, or logging in to a different account, do a full login\n\t\t\t(void) myuser_login(saslsvs, u, mu, false);\n\t\t\t(void) logcommand_user(saslsvs, u, CMDLOG_LOGIN, \"LOGIN (%s)\", p->mechptr->name);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Otherwise, just update login time ...\n\t\t\tmu->lastlogin = CURRTIME;\n\t\t\t(void) logcommand_user(saslsvs, u, CMDLOG_LOGIN, \"REAUTHENTICATE (%s)\", p->mechptr->name);\n\t\t}\n\t}\n\n\treturn true;\n}",
        "func": "static bool\nsasl_handle_login(struct sasl_session *const restrict p, struct user *const u, struct myuser *mu)\n{\n\tbool was_killed = false;\n\n\t// Find the account if necessary\n\tif (! mu)\n\t{\n\t\tif (! *p->pendingeid)\n\t\t{\n\t\t\t(void) slog(LG_INFO, \"%s: session for '%s' without an pendingeid (BUG)\",\n\t\t\t                     MOWGLI_FUNC_NAME, u->nick);\n\t\t\t(void) notice(saslsvs->nick, u->nick, LOGIN_CANCELLED_STR);\n\t\t\treturn false;\n\t\t}\n\n\t\tif (! (mu = myuser_find_uid(p->pendingeid)))\n\t\t{\n\t\t\tif (*p->authzid)\n\t\t\t\t(void) notice(saslsvs->nick, u->nick, \"Account %s dropped; login cancelled\",\n\t\t\t\t                                      p->authzid);\n\t\t\telse\n\t\t\t\t(void) notice(saslsvs->nick, u->nick, \"Account dropped; login cancelled\");\n\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t// If the user is already logged in, and not to the same account, log them out first\n\tif (u->myuser && u->myuser != mu)\n\t{\n\t\tif (is_soper(u->myuser))\n\t\t\t(void) logcommand_user(saslsvs, u, CMDLOG_ADMIN, \"DESOPER: \\2%s\\2 as \\2%s\\2\",\n\t\t\t                                                 u->nick, entity(u->myuser)->name);\n\n\t\t(void) logcommand_user(saslsvs, u, CMDLOG_LOGIN, \"LOGOUT\");\n\n\t\tif (! (was_killed = ircd_on_logout(u, entity(u->myuser)->name)))\n\t\t{\n\t\t\tmowgli_node_t *n;\n\n\t\t\tMOWGLI_ITER_FOREACH(n, u->myuser->logins.head)\n\t\t\t{\n\t\t\t\tif (n->data == u)\n\t\t\t\t{\n\t\t\t\t\t(void) mowgli_node_delete(n, &u->myuser->logins);\n\t\t\t\t\t(void) mowgli_node_free(n);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tu->myuser = NULL;\n\t\t}\n\t}\n\n\t// If they were not killed above, log them in now\n\tif (! was_killed)\n\t{\n\t\tif (u->myuser != mu)\n\t\t{\n\t\t\t// If they're not logged in, or logging in to a different account, do a full login\n\t\t\t(void) myuser_login(saslsvs, u, mu, false);\n\t\t\t(void) logcommand_user(saslsvs, u, CMDLOG_LOGIN, \"LOGIN (%s)\", p->mechptr->name);\n\t\t}\n\t\telse\n\t\t{\n\t\t\t// Otherwise, just update login time ...\n\t\t\tmu->lastlogin = CURRTIME;\n\t\t\t(void) logcommand_user(saslsvs, u, CMDLOG_LOGIN, \"REAUTHENTICATE (%s)\", p->mechptr->name);\n\t\t}\n\t}\n\n\treturn true;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,15 +6,15 @@\n \t// Find the account if necessary\n \tif (! mu)\n \t{\n-\t\tif (! *p->authzeid)\n+\t\tif (! *p->pendingeid)\n \t\t{\n-\t\t\t(void) slog(LG_INFO, \"%s: session for '%s' without an authzeid (BUG)\",\n+\t\t\t(void) slog(LG_INFO, \"%s: session for '%s' without an pendingeid (BUG)\",\n \t\t\t                     MOWGLI_FUNC_NAME, u->nick);\n \t\t\t(void) notice(saslsvs->nick, u->nick, LOGIN_CANCELLED_STR);\n \t\t\treturn false;\n \t\t}\n \n-\t\tif (! (mu = myuser_find_uid(p->authzeid)))\n+\t\tif (! (mu = myuser_find_uid(p->pendingeid)))\n \t\t{\n \t\t\tif (*p->authzid)\n \t\t\t\t(void) notice(saslsvs->nick, u->nick, \"Account %s dropped; login cancelled\",",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tif (! *p->authzeid)",
                "\t\t\t(void) slog(LG_INFO, \"%s: session for '%s' without an authzeid (BUG)\",",
                "\t\tif (! (mu = myuser_find_uid(p->authzeid)))"
            ],
            "added_lines": [
                "\t\tif (! *p->pendingeid)",
                "\t\t\t(void) slog(LG_INFO, \"%s: session for '%s' without an pendingeid (BUG)\",",
                "\t\tif (! (mu = myuser_find_uid(p->pendingeid)))"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-24976",
        "func_name": "atheme/sasl_process_packet",
        "description": "Atheme IRC Services before 7.2.12, when used in conjunction with InspIRCd, allows authentication bypass by ending an IRC handshake at a certain point during a challenge-response login sequence.",
        "git_url": "https://github.com/atheme/atheme/commit/4e664c75d0b280a052eb8b5e81aa41944e593c52",
        "commit_title": "saslserv/main: Track EID we're pending login to",
        "commit_text": " The existing model does not remember that we've sent a SVSLOGIN for a given SASL session, and simply assumes that if a client is introduced with a SASL session open, that session must have succeeded. The security of this approach requires ircd to implicitly abort SASL sessions on client registration.  This also means that if a client successfully authenticates and then does something else its pending login is forgotten about, even though a SVSLOGIN has been sent for it, and the ircd is going to think it's logged in.  This change removes the dependency on ircd's state machine by keeping explicit track of the pending login, i.e. the one we've most recently sent a SVSLOGIN for. The next commit will ensure that a client abort (even an implicit one) doesn't blow that information away.",
        "func_before": "static bool ATHEME_FATTR_WUR\nsasl_process_packet(struct sasl_session *const restrict p, char *const restrict buf, const size_t len)\n{\n\tstruct sasl_output_buf outbuf = {\n\t\t.buf    = NULL,\n\t\t.len    = 0,\n\t\t.flags  = ASASL_OUTFLAG_NONE,\n\t};\n\n\tenum sasl_mechanism_result rc;\n\tbool have_responded = false;\n\n\tif (! p->mechptr && ! len)\n\t{\n\t\t// First piece of data in a session is the name of the SASL mechanism that will be used\n\t\tif (! (p->mechptr = sasl_mechanism_find(buf)))\n\t\t{\n\t\t\t(void) sasl_sts(p->uid, 'M', sasl_mechlist_string);\n\t\t\treturn false;\n\t\t}\n\n\t\t(void) sasl_sourceinfo_recreate(p);\n\n\t\tif (p->mechptr->mech_start)\n\t\t\trc = p->mechptr->mech_start(p, &outbuf);\n\t\telse\n\t\t\trc = ASASL_MRESULT_CONTINUE;\n\t}\n\telse if (! p->mechptr)\n\t{\n\t\t(void) slog(LG_DEBUG, \"%s: session has no mechanism?\", MOWGLI_FUNC_NAME);\n\t\treturn false;\n\t}\n\telse\n\t{\n\t\trc = sasl_process_input(p, buf, len, &outbuf);\n\t}\n\n\tif (outbuf.buf && outbuf.len)\n\t{\n\t\tif (! sasl_process_output(p, &outbuf))\n\t\t\treturn false;\n\n\t\thave_responded = true;\n\t}\n\n\t// Some progress has been made, reset timeout.\n\tp->flags &= ~ASASL_SFLAG_MARKED_FOR_DELETION;\n\n\tswitch (rc)\n\t{\n\t\tcase ASASL_MRESULT_CONTINUE:\n\t\t{\n\t\t\tif (! have_responded)\n\t\t\t\t/* We want more data from the client, but we haven't sent any of our own.\n\t\t\t\t * Send an empty string to advance the session.    -- amdj\n\t\t\t\t */\n\t\t\t\t(void) sasl_sts(p->uid, 'C', \"+\");\n\n\t\t\treturn true;\n\t\t}\n\n\t\tcase ASASL_MRESULT_SUCCESS:\n\t\t{\n\t\t\tstruct user *const u = user_find(p->uid);\n\t\t\tstruct myuser *const mu = sasl_user_can_login(p);\n\n\t\t\tif (! mu)\n\t\t\t{\n\t\t\t\tif (u)\n\t\t\t\t\t(void) notice(saslsvs->nick, u->nick, LOGIN_CANCELLED_STR);\n\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t/* If the user is already on the network, attempt to log them in immediately.\n\t\t\t * Otherwise, we will log them in on introduction of user to network\n\t\t\t */\n\t\t\tif (u && ! sasl_handle_login(p, u, mu))\n\t\t\t\treturn false;\n\n\t\t\treturn sasl_session_success(p, mu, (u != NULL));\n\t\t}\n\n\t\tcase ASASL_MRESULT_FAILURE:\n\t\t{\n\t\t\tif (*p->authceid)\n\t\t\t{\n\t\t\t\t/* If we reach this, they failed SASL auth, so if they were trying\n\t\t\t\t * to authenticate as a specific user, run bad_password() on them.\n\t\t\t\t */\n\t\t\t\tstruct myuser *const mu = myuser_find_uid(p->authceid);\n\n\t\t\t\tif (! mu)\n\t\t\t\t\treturn false;\n\n\t\t\t\t/* We might have more information to construct a more accurate sourceinfo now?\n\t\t\t\t * TODO: Investigate whether this is necessary\n\t\t\t\t */\n\t\t\t\t(void) sasl_sourceinfo_recreate(p);\n\n\t\t\t\t(void) logcommand(p->si, CMDLOG_LOGIN, \"failed LOGIN (%s) to \\2%s\\2 (bad password)\",\n\t\t\t\t                                       p->mechptr->name, entity(mu)->name);\n\t\t\t\t(void) bad_password(p->si, mu);\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}\n\n\t\tcase ASASL_MRESULT_ERROR:\n\t\t\treturn false;\n\t}\n\n\t/* This is only here to keep GCC happy -- Clang can see that the switch() handles all legal\n\t * values of the enumeration, and so knows that this function will never get to this point;\n\t * GCC is dumb, and warns that control reaches the end of this non-void function.    -- amdj\n\t */\n\treturn false;\n}",
        "func": "static bool ATHEME_FATTR_WUR\nsasl_process_packet(struct sasl_session *const restrict p, char *const restrict buf, const size_t len)\n{\n\tstruct sasl_output_buf outbuf = {\n\t\t.buf    = NULL,\n\t\t.len    = 0,\n\t\t.flags  = ASASL_OUTFLAG_NONE,\n\t};\n\n\tenum sasl_mechanism_result rc;\n\tbool have_responded = false;\n\n\tif (! p->mechptr && ! len)\n\t{\n\t\t// First piece of data in a session is the name of the SASL mechanism that will be used\n\t\tif (! (p->mechptr = sasl_mechanism_find(buf)))\n\t\t{\n\t\t\t(void) sasl_sts(p->uid, 'M', sasl_mechlist_string);\n\t\t\treturn false;\n\t\t}\n\n\t\t(void) sasl_sourceinfo_recreate(p);\n\n\t\tif (p->mechptr->mech_start)\n\t\t\trc = p->mechptr->mech_start(p, &outbuf);\n\t\telse\n\t\t\trc = ASASL_MRESULT_CONTINUE;\n\t}\n\telse if (! p->mechptr)\n\t{\n\t\t(void) slog(LG_DEBUG, \"%s: session has no mechanism?\", MOWGLI_FUNC_NAME);\n\t\treturn false;\n\t}\n\telse\n\t{\n\t\trc = sasl_process_input(p, buf, len, &outbuf);\n\t}\n\n\tif (outbuf.buf && outbuf.len)\n\t{\n\t\tif (! sasl_process_output(p, &outbuf))\n\t\t\treturn false;\n\n\t\thave_responded = true;\n\t}\n\n\t// Some progress has been made, reset timeout.\n\tp->flags &= ~ASASL_SFLAG_MARKED_FOR_DELETION;\n\n\tswitch (rc)\n\t{\n\t\tcase ASASL_MRESULT_CONTINUE:\n\t\t{\n\t\t\tif (! have_responded)\n\t\t\t\t/* We want more data from the client, but we haven't sent any of our own.\n\t\t\t\t * Send an empty string to advance the session.    -- amdj\n\t\t\t\t */\n\t\t\t\t(void) sasl_sts(p->uid, 'C', \"+\");\n\n\t\t\treturn true;\n\t\t}\n\n\t\tcase ASASL_MRESULT_SUCCESS:\n\t\t{\n\t\t\tstruct user *const u = user_find(p->uid);\n\t\t\tstruct myuser *const mu = sasl_user_can_login(p);\n\n\t\t\tif (! mu)\n\t\t\t{\n\t\t\t\tif (u)\n\t\t\t\t\t(void) notice(saslsvs->nick, u->nick, LOGIN_CANCELLED_STR);\n\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t(void) mowgli_strlcpy(p->pendingeid, p->authzeid, sizeof p->pendingeid);\n\n\t\t\t/* If the user is already on the network, attempt to log them in immediately.\n\t\t\t * Otherwise, we will log them in on introduction of user to network\n\t\t\t */\n\t\t\tif (u && ! sasl_handle_login(p, u, mu))\n\t\t\t\treturn false;\n\n\t\t\treturn sasl_session_success(p, mu, (u != NULL));\n\t\t}\n\n\t\tcase ASASL_MRESULT_FAILURE:\n\t\t{\n\t\t\tif (*p->authceid)\n\t\t\t{\n\t\t\t\t/* If we reach this, they failed SASL auth, so if they were trying\n\t\t\t\t * to authenticate as a specific user, run bad_password() on them.\n\t\t\t\t */\n\t\t\t\tstruct myuser *const mu = myuser_find_uid(p->authceid);\n\n\t\t\t\tif (! mu)\n\t\t\t\t\treturn false;\n\n\t\t\t\t/* We might have more information to construct a more accurate sourceinfo now?\n\t\t\t\t * TODO: Investigate whether this is necessary\n\t\t\t\t */\n\t\t\t\t(void) sasl_sourceinfo_recreate(p);\n\n\t\t\t\t(void) logcommand(p->si, CMDLOG_LOGIN, \"failed LOGIN (%s) to \\2%s\\2 (bad password)\",\n\t\t\t\t                                       p->mechptr->name, entity(mu)->name);\n\t\t\t\t(void) bad_password(p->si, mu);\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}\n\n\t\tcase ASASL_MRESULT_ERROR:\n\t\t\treturn false;\n\t}\n\n\t/* This is only here to keep GCC happy -- Clang can see that the switch() handles all legal\n\t * values of the enumeration, and so knows that this function will never get to this point;\n\t * GCC is dumb, and warns that control reaches the end of this non-void function.    -- amdj\n\t */\n\treturn false;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -73,6 +73,8 @@\n \t\t\t\treturn false;\n \t\t\t}\n \n+\t\t\t(void) mowgli_strlcpy(p->pendingeid, p->authzeid, sizeof p->pendingeid);\n+\n \t\t\t/* If the user is already on the network, attempt to log them in immediately.\n \t\t\t * Otherwise, we will log them in on introduction of user to network\n \t\t\t */",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\t\t(void) mowgli_strlcpy(p->pendingeid, p->authzeid, sizeof p->pendingeid);",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2022-39264",
        "func_name": "Nheko-Reborn/nheko/handle_olm_message",
        "description": "nheko is a desktop client for the Matrix communication application. All versions below 0.10.2 are vulnerable homeservers inserting malicious secrets, which could lead to man-in-the-middle attacks. Users can upgrade to version 0.10.2 to protect against this issue. As a workaround, one may apply the patch manually, avoid doing verifications of one's own devices, and/or avoid pressing the request button in the settings menu.",
        "git_url": "https://github.com/Nheko-Reborn/nheko/commit/67bee15a389f9b8a9f6c3a340558d1e2319e7199",
        "commit_title": "Prevent the homeserver from inserting malicious secrets",
        "commit_text": " Correctly verify that the reply to a secrets request is actually coming from a verified device. While we did verify that it was us who replied, we didn't properly cancel storing the secret if the sending device was one of ours but was maliciously inserted by the homeserver and unverified. We only send secret requests to verified devices in the first place, so only the homeserver could abuse this issue.  Additionally we protected against malicious secret poisoning by verifying that the secret is actually the reply to a request. This means the server only has 2 places where it can poison the secrets:  - After a verification when we automatically request the secrets - When the user manually hits the request button  It also needs to prevent other secret answers to reach the client first since we ignore all replies after that one.  The impact of this might be quite severe. It could allow the server to replace the cross-signing keys silently and while we might not trust that key, we possibly could trust it in the future if we rely on the stored secret. Similarly this could potentially be abused to make the client trust a malicious online key backup.  If your deployment is not patched yet and you don't control your homeserver, you can protect against this by simply not doing any verifications of your own devices and not pressing the request button in the settings menu.",
        "func_before": "void\nhandle_olm_message(const OlmMessage &msg, const UserKeyCache &otherUserDeviceKeys)\n{\n    nhlog::crypto()->info(\"sender    : {}\", msg.sender);\n    nhlog::crypto()->info(\"sender_key: {}\", msg.sender_key);\n\n    if (msg.sender_key == olm::client()->identity_keys().ed25519) {\n        nhlog::crypto()->warn(\"Ignoring olm message from ourselves!\");\n        return;\n    }\n\n    const auto my_key = olm::client()->identity_keys().curve25519;\n\n    bool failed_decryption = false;\n\n    for (const auto &cipher : msg.ciphertext) {\n        // We skip messages not meant for the current device.\n        if (cipher.first != my_key) {\n            nhlog::crypto()->debug(\n              \"Skipping message for {} since we are {}.\", cipher.first, my_key);\n            continue;\n        }\n\n        const auto type = cipher.second.type;\n        nhlog::crypto()->info(\"type: {}\", type == 0 ? \"OLM_PRE_KEY\" : \"OLM_MESSAGE\");\n\n        auto payload = try_olm_decryption(msg.sender_key, cipher.second);\n\n        if (payload.is_null()) {\n            // Check for PRE_KEY message\n            if (cipher.second.type == 0) {\n                payload = handle_pre_key_olm_message(msg.sender, msg.sender_key, cipher.second);\n            } else {\n                nhlog::crypto()->error(\"Undecryptable olm message!\");\n                failed_decryption = true;\n                continue;\n            }\n        }\n\n        if (!payload.is_null()) {\n            mtx::events::collections::DeviceEvents device_event;\n\n            // Other properties are included in order to prevent an attacker from\n            // publishing someone else's curve25519 keys as their own and subsequently\n            // claiming to have sent messages which they didn't. sender must correspond\n            // to the user who sent the event, recipient to the local user, and\n            // recipient_keys to the local ed25519 key.\n            std::string receiver_ed25519 = payload[\"recipient_keys\"][\"ed25519\"].get<std::string>();\n            if (receiver_ed25519.empty() ||\n                receiver_ed25519 != olm::client()->identity_keys().ed25519) {\n                nhlog::crypto()->warn(\"Decrypted event doesn't include our ed25519: {}\",\n                                      payload.dump());\n                return;\n            }\n            std::string receiver = payload[\"recipient\"].get<std::string>();\n            if (receiver.empty() || receiver != http::client()->user_id().to_string()) {\n                nhlog::crypto()->warn(\"Decrypted event doesn't include our user_id: {}\",\n                                      payload.dump());\n                return;\n            }\n\n            // Clients must confirm that the sender_key and the ed25519 field value\n            // under the keys property match the keys returned by /keys/query for the\n            // given user, and must also verify the signature of the payload. Without\n            // this check, a client cannot be sure that the sender device owns the\n            // private part of the ed25519 key it claims to have in the Olm payload.\n            // This is crucial when the ed25519 key corresponds to a verified device.\n            std::string sender_ed25519 = payload[\"keys\"][\"ed25519\"].get<std::string>();\n            if (sender_ed25519.empty()) {\n                nhlog::crypto()->warn(\"Decrypted event doesn't include sender ed25519: {}\",\n                                      payload.dump());\n                return;\n            }\n\n            bool from_their_device = false;\n            for (const auto &[device_id, key] : otherUserDeviceKeys.device_keys) {\n                auto c_key = key.keys.find(\"curve25519:\" + device_id);\n                auto e_key = key.keys.find(\"ed25519:\" + device_id);\n\n                if (c_key == key.keys.end() || e_key == key.keys.end()) {\n                    nhlog::crypto()->warn(\"Skipping device {} as we have no keys for it.\",\n                                          device_id);\n                } else if (c_key->second == msg.sender_key && e_key->second == sender_ed25519) {\n                    from_their_device = true;\n                    break;\n                }\n            }\n            if (!from_their_device) {\n                nhlog::crypto()->warn(\"Decrypted event isn't sent from a device \"\n                                      \"listed by that user! {}\",\n                                      payload.dump());\n                return;\n            }\n\n            {\n                std::string msg_type       = payload[\"type\"].get<std::string>();\n                nlohmann::json event_array = nlohmann::json::array();\n                event_array.push_back(payload);\n\n                std::vector<mtx::events::collections::DeviceEvents> temp_events;\n                mtx::responses::utils::parse_device_events(event_array, temp_events);\n                if (temp_events.empty()) {\n                    nhlog::crypto()->warn(\"Decrypted unknown event: {}\", payload.dump());\n                    return;\n                }\n                device_event = temp_events.at(0);\n            }\n\n            using namespace mtx::events;\n            if (auto e1 = std::get_if<DeviceEvent<msg::KeyVerificationAccept>>(&device_event)) {\n                ChatPage::instance()->receivedDeviceVerificationAccept(e1->content);\n            } else if (auto e2 =\n                         std::get_if<DeviceEvent<msg::KeyVerificationRequest>>(&device_event)) {\n                ChatPage::instance()->receivedDeviceVerificationRequest(e2->content, e2->sender);\n            } else if (auto e3 =\n                         std::get_if<DeviceEvent<msg::KeyVerificationCancel>>(&device_event)) {\n                ChatPage::instance()->receivedDeviceVerificationCancel(e3->content);\n            } else if (auto e4 = std::get_if<DeviceEvent<msg::KeyVerificationKey>>(&device_event)) {\n                ChatPage::instance()->receivedDeviceVerificationKey(e4->content);\n            } else if (auto e5 = std::get_if<DeviceEvent<msg::KeyVerificationMac>>(&device_event)) {\n                ChatPage::instance()->receivedDeviceVerificationMac(e5->content);\n            } else if (auto e6 =\n                         std::get_if<DeviceEvent<msg::KeyVerificationStart>>(&device_event)) {\n                ChatPage::instance()->receivedDeviceVerificationStart(e6->content, e6->sender);\n            } else if (auto e7 =\n                         std::get_if<DeviceEvent<msg::KeyVerificationReady>>(&device_event)) {\n                ChatPage::instance()->receivedDeviceVerificationReady(e7->content);\n            } else if (auto e8 =\n                         std::get_if<DeviceEvent<msg::KeyVerificationDone>>(&device_event)) {\n                ChatPage::instance()->receivedDeviceVerificationDone(e8->content);\n            } else if (auto roomKey = std::get_if<DeviceEvent<msg::RoomKey>>(&device_event)) {\n                create_inbound_megolm_session(*roomKey, msg.sender_key, sender_ed25519);\n            } else if (auto forwardedRoomKey =\n                         std::get_if<DeviceEvent<msg::ForwardedRoomKey>>(&device_event)) {\n                forwardedRoomKey->content.forwarding_curve25519_key_chain.push_back(msg.sender_key);\n                import_inbound_megolm_session(*forwardedRoomKey);\n            } else if (auto e = std::get_if<DeviceEvent<msg::SecretSend>>(&device_event)) {\n                auto local_user = http::client()->user_id();\n\n                if (msg.sender != local_user.to_string())\n                    return;\n\n                auto secret_name = request_id_to_secret_name.find(e->content.request_id);\n\n                if (secret_name != request_id_to_secret_name.end()) {\n                    nhlog::crypto()->info(\"Received secret: {}\", secret_name->second);\n\n                    mtx::events::msg::SecretRequest secretRequest{};\n                    secretRequest.action = mtx::events::msg::RequestAction::Cancellation;\n                    secretRequest.requesting_device_id = http::client()->device_id();\n                    secretRequest.request_id           = e->content.request_id;\n\n                    auto verificationStatus = cache::verificationStatus(local_user.to_string());\n\n                    if (!verificationStatus)\n                        return;\n\n                    auto deviceKeys = cache::userKeys(local_user.to_string());\n                    std::string sender_device_id;\n                    if (deviceKeys) {\n                        for (auto &[dev, key] : deviceKeys->device_keys) {\n                            if (key.keys[\"curve25519:\" + dev] == msg.sender_key) {\n                                sender_device_id = dev;\n                                break;\n                            }\n                        }\n                    }\n\n                    std::map<mtx::identifiers::User,\n                             std::map<std::string, mtx::events::msg::SecretRequest>>\n                      body;\n\n                    for (const auto &dev : verificationStatus->verified_devices) {\n                        if (dev != secretRequest.requesting_device_id && dev != sender_device_id)\n                            body[local_user][dev] = secretRequest;\n                    }\n\n                    http::client()->send_to_device<mtx::events::msg::SecretRequest>(\n                      http::client()->generate_txn_id(),\n                      body,\n                      [name = secret_name->second](mtx::http::RequestErr err) {\n                          if (err) {\n                              nhlog::net()->error(\"Failed to send request cancellation \"\n                                                  \"for secrect \"\n                                                  \"'{}'\",\n                                                  name);\n                          }\n                      });\n\n                    nhlog::crypto()->info(\"Storing secret {}\", secret_name->second);\n                    cache::client()->storeSecret(secret_name->second, e->content.secret);\n\n                    request_id_to_secret_name.erase(secret_name);\n                }\n\n            } else if (auto sec_req = std::get_if<DeviceEvent<msg::SecretRequest>>(&device_event)) {\n                handle_secret_request(sec_req, msg.sender);\n            }\n\n            return;\n        } else {\n            failed_decryption = true;\n        }\n    }\n\n    if (failed_decryption) {\n        try {\n            std::map<std::string, std::vector<std::string>> targets;\n            for (const auto &[device_id, key] : otherUserDeviceKeys.device_keys) {\n                if (key.keys.at(\"curve25519:\" + device_id) == msg.sender_key)\n                    targets[msg.sender].push_back(device_id);\n            }\n\n            send_encrypted_to_device_messages(\n              targets, mtx::events::DeviceEvent<mtx::events::msg::Dummy>{}, true);\n            nhlog::crypto()->info(\n              \"Recovering from broken olm channel with {}:{}\", msg.sender, msg.sender_key);\n        } catch (std::exception &e) {\n            nhlog::crypto()->error(\"Failed to recover from broken olm sessions: {}\", e.what());\n        }\n    }\n}",
        "func": "void\nhandle_olm_message(const OlmMessage &msg, const UserKeyCache &otherUserDeviceKeys)\n{\n    nhlog::crypto()->info(\"sender    : {}\", msg.sender);\n    nhlog::crypto()->info(\"sender_key: {}\", msg.sender_key);\n\n    if (msg.sender_key == olm::client()->identity_keys().ed25519) {\n        nhlog::crypto()->warn(\"Ignoring olm message from ourselves!\");\n        return;\n    }\n\n    const auto my_key = olm::client()->identity_keys().curve25519;\n\n    bool failed_decryption = false;\n\n    for (const auto &cipher : msg.ciphertext) {\n        // We skip messages not meant for the current device.\n        if (cipher.first != my_key) {\n            nhlog::crypto()->debug(\n              \"Skipping message for {} since we are {}.\", cipher.first, my_key);\n            continue;\n        }\n\n        const auto type = cipher.second.type;\n        nhlog::crypto()->info(\"type: {}\", type == 0 ? \"OLM_PRE_KEY\" : \"OLM_MESSAGE\");\n\n        auto payload = try_olm_decryption(msg.sender_key, cipher.second);\n\n        if (payload.is_null()) {\n            // Check for PRE_KEY message\n            if (cipher.second.type == 0) {\n                payload = handle_pre_key_olm_message(msg.sender, msg.sender_key, cipher.second);\n            } else {\n                nhlog::crypto()->error(\"Undecryptable olm message!\");\n                failed_decryption = true;\n                continue;\n            }\n        }\n\n        if (!payload.is_null()) {\n            mtx::events::collections::DeviceEvents device_event;\n\n            // Other properties are included in order to prevent an attacker from\n            // publishing someone else's curve25519 keys as their own and subsequently\n            // claiming to have sent messages which they didn't. sender must correspond\n            // to the user who sent the event, recipient to the local user, and\n            // recipient_keys to the local ed25519 key.\n            std::string receiver_ed25519 = payload[\"recipient_keys\"][\"ed25519\"].get<std::string>();\n            if (receiver_ed25519.empty() ||\n                receiver_ed25519 != olm::client()->identity_keys().ed25519) {\n                nhlog::crypto()->warn(\"Decrypted event doesn't include our ed25519: {}\",\n                                      payload.dump());\n                return;\n            }\n            std::string receiver = payload[\"recipient\"].get<std::string>();\n            if (receiver.empty() || receiver != http::client()->user_id().to_string()) {\n                nhlog::crypto()->warn(\"Decrypted event doesn't include our user_id: {}\",\n                                      payload.dump());\n                return;\n            }\n\n            // Clients must confirm that the sender_key and the ed25519 field value\n            // under the keys property match the keys returned by /keys/query for the\n            // given user, and must also verify the signature of the payload. Without\n            // this check, a client cannot be sure that the sender device owns the\n            // private part of the ed25519 key it claims to have in the Olm payload.\n            // This is crucial when the ed25519 key corresponds to a verified device.\n            std::string sender_ed25519 = payload[\"keys\"][\"ed25519\"].get<std::string>();\n            if (sender_ed25519.empty()) {\n                nhlog::crypto()->warn(\"Decrypted event doesn't include sender ed25519: {}\",\n                                      payload.dump());\n                return;\n            }\n\n            bool from_their_device = false;\n            for (const auto &[device_id, key] : otherUserDeviceKeys.device_keys) {\n                auto c_key = key.keys.find(\"curve25519:\" + device_id);\n                auto e_key = key.keys.find(\"ed25519:\" + device_id);\n\n                if (c_key == key.keys.end() || e_key == key.keys.end()) {\n                    nhlog::crypto()->warn(\"Skipping device {} as we have no keys for it.\",\n                                          device_id);\n                } else if (c_key->second == msg.sender_key && e_key->second == sender_ed25519) {\n                    from_their_device = true;\n                    break;\n                }\n            }\n            if (!from_their_device) {\n                nhlog::crypto()->warn(\"Decrypted event isn't sent from a device \"\n                                      \"listed by that user! {}\",\n                                      payload.dump());\n                return;\n            }\n\n            {\n                std::string msg_type       = payload[\"type\"].get<std::string>();\n                nlohmann::json event_array = nlohmann::json::array();\n                event_array.push_back(payload);\n\n                std::vector<mtx::events::collections::DeviceEvents> temp_events;\n                mtx::responses::utils::parse_device_events(event_array, temp_events);\n                if (temp_events.empty()) {\n                    nhlog::crypto()->warn(\"Decrypted unknown event: {}\", payload.dump());\n                    return;\n                }\n                device_event = temp_events.at(0);\n            }\n\n            using namespace mtx::events;\n            if (auto e1 = std::get_if<DeviceEvent<msg::KeyVerificationAccept>>(&device_event)) {\n                ChatPage::instance()->receivedDeviceVerificationAccept(e1->content);\n            } else if (auto e2 =\n                         std::get_if<DeviceEvent<msg::KeyVerificationRequest>>(&device_event)) {\n                ChatPage::instance()->receivedDeviceVerificationRequest(e2->content, e2->sender);\n            } else if (auto e3 =\n                         std::get_if<DeviceEvent<msg::KeyVerificationCancel>>(&device_event)) {\n                ChatPage::instance()->receivedDeviceVerificationCancel(e3->content);\n            } else if (auto e4 = std::get_if<DeviceEvent<msg::KeyVerificationKey>>(&device_event)) {\n                ChatPage::instance()->receivedDeviceVerificationKey(e4->content);\n            } else if (auto e5 = std::get_if<DeviceEvent<msg::KeyVerificationMac>>(&device_event)) {\n                ChatPage::instance()->receivedDeviceVerificationMac(e5->content);\n            } else if (auto e6 =\n                         std::get_if<DeviceEvent<msg::KeyVerificationStart>>(&device_event)) {\n                ChatPage::instance()->receivedDeviceVerificationStart(e6->content, e6->sender);\n            } else if (auto e7 =\n                         std::get_if<DeviceEvent<msg::KeyVerificationReady>>(&device_event)) {\n                ChatPage::instance()->receivedDeviceVerificationReady(e7->content);\n            } else if (auto e8 =\n                         std::get_if<DeviceEvent<msg::KeyVerificationDone>>(&device_event)) {\n                ChatPage::instance()->receivedDeviceVerificationDone(e8->content);\n            } else if (auto roomKey = std::get_if<DeviceEvent<msg::RoomKey>>(&device_event)) {\n                create_inbound_megolm_session(*roomKey, msg.sender_key, sender_ed25519);\n            } else if (auto forwardedRoomKey =\n                         std::get_if<DeviceEvent<msg::ForwardedRoomKey>>(&device_event)) {\n                forwardedRoomKey->content.forwarding_curve25519_key_chain.push_back(msg.sender_key);\n                import_inbound_megolm_session(*forwardedRoomKey);\n            } else if (auto e = std::get_if<DeviceEvent<msg::SecretSend>>(&device_event)) {\n                auto local_user = http::client()->user_id();\n\n                if (msg.sender != local_user.to_string())\n                    return;\n\n                auto secret_name_it = request_id_to_secret_name.find(e->content.request_id);\n\n                if (secret_name_it != request_id_to_secret_name.end()) {\n                    auto secret_name = secret_name_it->second;\n                    request_id_to_secret_name.erase(secret_name_it);\n\n                    nhlog::crypto()->info(\"Received secret: {}\", secret_name);\n\n                    mtx::events::msg::SecretRequest secretRequest{};\n                    secretRequest.action = mtx::events::msg::RequestAction::Cancellation;\n                    secretRequest.requesting_device_id = http::client()->device_id();\n                    secretRequest.request_id           = e->content.request_id;\n\n                    auto verificationStatus = cache::verificationStatus(local_user.to_string());\n\n                    if (!verificationStatus)\n                        return;\n\n                    auto deviceKeys = cache::userKeys(local_user.to_string());\n                    if (!deviceKeys)\n                        return;\n\n                    std::string sender_device_id;\n                    for (auto &[dev, key] : deviceKeys->device_keys) {\n                        if (key.keys[\"curve25519:\" + dev] == msg.sender_key) {\n                            sender_device_id = dev;\n                            break;\n                        }\n                    }\n                    if (!verificationStatus->verified_devices.count(sender_device_id) ||\n                        !verificationStatus->verified_device_keys.count(msg.sender_key) ||\n                        verificationStatus->verified_device_keys.at(msg.sender_key) !=\n                          crypto::Trust::Verified) {\n                        nhlog::net()->critical(\n                          \"Received secret from unverified device {}! Ignoring!\", sender_device_id);\n                        return;\n                    }\n\n                    std::map<mtx::identifiers::User,\n                             std::map<std::string, mtx::events::msg::SecretRequest>>\n                      body;\n\n                    for (const auto &dev : verificationStatus->verified_devices) {\n                        if (dev != secretRequest.requesting_device_id && dev != sender_device_id)\n                            body[local_user][dev] = secretRequest;\n                    }\n\n                    http::client()->send_to_device<mtx::events::msg::SecretRequest>(\n                      http::client()->generate_txn_id(),\n                      body,\n                      [secret_name](mtx::http::RequestErr err) {\n                          if (err) {\n                              nhlog::net()->error(\"Failed to send request cancellation \"\n                                                  \"for secrect \"\n                                                  \"'{}'\",\n                                                  secret_name);\n                          }\n                      });\n\n                    nhlog::crypto()->info(\"Storing secret {}\", secret_name);\n                    cache::client()->storeSecret(secret_name, e->content.secret);\n                }\n\n            } else if (auto sec_req = std::get_if<DeviceEvent<msg::SecretRequest>>(&device_event)) {\n                handle_secret_request(sec_req, msg.sender);\n            }\n\n            return;\n        } else {\n            failed_decryption = true;\n        }\n    }\n\n    if (failed_decryption) {\n        try {\n            std::map<std::string, std::vector<std::string>> targets;\n            for (const auto &[device_id, key] : otherUserDeviceKeys.device_keys) {\n                if (key.keys.at(\"curve25519:\" + device_id) == msg.sender_key)\n                    targets[msg.sender].push_back(device_id);\n            }\n\n            send_encrypted_to_device_messages(\n              targets, mtx::events::DeviceEvent<mtx::events::msg::Dummy>{}, true);\n            nhlog::crypto()->info(\n              \"Recovering from broken olm channel with {}:{}\", msg.sender, msg.sender_key);\n        } catch (std::exception &e) {\n            nhlog::crypto()->error(\"Failed to recover from broken olm sessions: {}\", e.what());\n        }\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -140,10 +140,13 @@\n                 if (msg.sender != local_user.to_string())\n                     return;\n \n-                auto secret_name = request_id_to_secret_name.find(e->content.request_id);\n-\n-                if (secret_name != request_id_to_secret_name.end()) {\n-                    nhlog::crypto()->info(\"Received secret: {}\", secret_name->second);\n+                auto secret_name_it = request_id_to_secret_name.find(e->content.request_id);\n+\n+                if (secret_name_it != request_id_to_secret_name.end()) {\n+                    auto secret_name = secret_name_it->second;\n+                    request_id_to_secret_name.erase(secret_name_it);\n+\n+                    nhlog::crypto()->info(\"Received secret: {}\", secret_name);\n \n                     mtx::events::msg::SecretRequest secretRequest{};\n                     secretRequest.action = mtx::events::msg::RequestAction::Cancellation;\n@@ -156,14 +159,23 @@\n                         return;\n \n                     auto deviceKeys = cache::userKeys(local_user.to_string());\n+                    if (!deviceKeys)\n+                        return;\n+\n                     std::string sender_device_id;\n-                    if (deviceKeys) {\n-                        for (auto &[dev, key] : deviceKeys->device_keys) {\n-                            if (key.keys[\"curve25519:\" + dev] == msg.sender_key) {\n-                                sender_device_id = dev;\n-                                break;\n-                            }\n+                    for (auto &[dev, key] : deviceKeys->device_keys) {\n+                        if (key.keys[\"curve25519:\" + dev] == msg.sender_key) {\n+                            sender_device_id = dev;\n+                            break;\n                         }\n+                    }\n+                    if (!verificationStatus->verified_devices.count(sender_device_id) ||\n+                        !verificationStatus->verified_device_keys.count(msg.sender_key) ||\n+                        verificationStatus->verified_device_keys.at(msg.sender_key) !=\n+                          crypto::Trust::Verified) {\n+                        nhlog::net()->critical(\n+                          \"Received secret from unverified device {}! Ignoring!\", sender_device_id);\n+                        return;\n                     }\n \n                     std::map<mtx::identifiers::User,\n@@ -178,19 +190,17 @@\n                     http::client()->send_to_device<mtx::events::msg::SecretRequest>(\n                       http::client()->generate_txn_id(),\n                       body,\n-                      [name = secret_name->second](mtx::http::RequestErr err) {\n+                      [secret_name](mtx::http::RequestErr err) {\n                           if (err) {\n                               nhlog::net()->error(\"Failed to send request cancellation \"\n                                                   \"for secrect \"\n                                                   \"'{}'\",\n-                                                  name);\n+                                                  secret_name);\n                           }\n                       });\n \n-                    nhlog::crypto()->info(\"Storing secret {}\", secret_name->second);\n-                    cache::client()->storeSecret(secret_name->second, e->content.secret);\n-\n-                    request_id_to_secret_name.erase(secret_name);\n+                    nhlog::crypto()->info(\"Storing secret {}\", secret_name);\n+                    cache::client()->storeSecret(secret_name, e->content.secret);\n                 }\n \n             } else if (auto sec_req = std::get_if<DeviceEvent<msg::SecretRequest>>(&device_event)) {",
        "diff_line_info": {
            "deleted_lines": [
                "                auto secret_name = request_id_to_secret_name.find(e->content.request_id);",
                "",
                "                if (secret_name != request_id_to_secret_name.end()) {",
                "                    nhlog::crypto()->info(\"Received secret: {}\", secret_name->second);",
                "                    if (deviceKeys) {",
                "                        for (auto &[dev, key] : deviceKeys->device_keys) {",
                "                            if (key.keys[\"curve25519:\" + dev] == msg.sender_key) {",
                "                                sender_device_id = dev;",
                "                                break;",
                "                            }",
                "                      [name = secret_name->second](mtx::http::RequestErr err) {",
                "                                                  name);",
                "                    nhlog::crypto()->info(\"Storing secret {}\", secret_name->second);",
                "                    cache::client()->storeSecret(secret_name->second, e->content.secret);",
                "",
                "                    request_id_to_secret_name.erase(secret_name);"
            ],
            "added_lines": [
                "                auto secret_name_it = request_id_to_secret_name.find(e->content.request_id);",
                "",
                "                if (secret_name_it != request_id_to_secret_name.end()) {",
                "                    auto secret_name = secret_name_it->second;",
                "                    request_id_to_secret_name.erase(secret_name_it);",
                "",
                "                    nhlog::crypto()->info(\"Received secret: {}\", secret_name);",
                "                    if (!deviceKeys)",
                "                        return;",
                "",
                "                    for (auto &[dev, key] : deviceKeys->device_keys) {",
                "                        if (key.keys[\"curve25519:\" + dev] == msg.sender_key) {",
                "                            sender_device_id = dev;",
                "                            break;",
                "                    }",
                "                    if (!verificationStatus->verified_devices.count(sender_device_id) ||",
                "                        !verificationStatus->verified_device_keys.count(msg.sender_key) ||",
                "                        verificationStatus->verified_device_keys.at(msg.sender_key) !=",
                "                          crypto::Trust::Verified) {",
                "                        nhlog::net()->critical(",
                "                          \"Received secret from unverified device {}! Ignoring!\", sender_device_id);",
                "                        return;",
                "                      [secret_name](mtx::http::RequestErr err) {",
                "                                                  secret_name);",
                "                    nhlog::crypto()->info(\"Storing secret {}\", secret_name);",
                "                    cache::client()->storeSecret(secret_name, e->content.secret);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-36369",
        "func_name": "mkj/dropbear/add_extendedopt",
        "description": "An issue was discovered in Dropbear through 2020.81. Due to a non-RFC-compliant check of the available authentication methods in the client-side SSH code, it is possible for an SSH server to change the login process in its favor. This attack can bypass additional security measures such as FIDO2 tokens or SSH-Askpass. Thus, it allows an attacker to abuse a forwarded agent for logging on to another server unnoticed.",
        "git_url": "https://github.com/mkj/dropbear/commit/adbdb213eb0fe3e982cc57d7ae882c1915bef818",
        "commit_title": "rename argument to match with other ssh clients",
        "commit_text": "",
        "func_before": "static void add_extendedopt(const char* origstr) {\n\tconst char *optstr = origstr;\n\n\tif (strcmp(origstr, \"help\") == 0) {\n\t\tdropbear_log(LOG_INFO, \"Available options:\\n\"\n#if DROPBEAR_CLI_ANYTCPFWD\n\t\t\t\"\\tExitOnForwardFailure\\n\"\n#endif\n\t\t\t\"\\tExitOnTrivialAuth\\n\"\n#ifndef DISABLE_SYSLOG\n\t\t\t\"\\tUseSyslog\\n\"\n#endif\n\t\t\t\"\\tPort\\n\"\n\t\t);\n\t\texit(EXIT_SUCCESS);\n\t}\n\n#if DROPBEAR_CLI_ANYTCPFWD\n\tif (match_extendedopt(&optstr, \"ExitOnForwardFailure\") == DROPBEAR_SUCCESS) {\n\t\tcli_opts.exit_on_fwd_failure = parse_flag_value(optstr);\n\t\treturn;\n\t}\n#endif\n\n#ifndef DISABLE_SYSLOG\n\tif (match_extendedopt(&optstr, \"UseSyslog\") == DROPBEAR_SUCCESS) {\n\t\topts.usingsyslog = parse_flag_value(optstr);\n\t\treturn;\n\t}\n#endif\n\n\tif (match_extendedopt(&optstr, \"Port\") == DROPBEAR_SUCCESS) {\n\t\tcli_opts.remoteport = optstr;\n\t\treturn;\n\t}\n\n\tif (match_extendedopt(&optstr, \"ExitOnTrivialAuth\") == DROPBEAR_SUCCESS) {\n\t\tcli_opts.exit_on_trivial_auth = parse_flag_value(optstr);\n\t\treturn;\n\t}\n\n\tdropbear_log(LOG_WARNING, \"Ignoring unknown configuration option '%s'\", origstr);\n}",
        "func": "static void add_extendedopt(const char* origstr) {\n\tconst char *optstr = origstr;\n\n\tif (strcmp(origstr, \"help\") == 0) {\n\t\tdropbear_log(LOG_INFO, \"Available options:\\n\"\n#if DROPBEAR_CLI_ANYTCPFWD\n\t\t\t\"\\tExitOnForwardFailure\\n\"\n#endif\n\t\t\t\"\\tDisableTrivialAuth\\n\"\n#ifndef DISABLE_SYSLOG\n\t\t\t\"\\tUseSyslog\\n\"\n#endif\n\t\t\t\"\\tPort\\n\"\n\t\t);\n\t\texit(EXIT_SUCCESS);\n\t}\n\n#if DROPBEAR_CLI_ANYTCPFWD\n\tif (match_extendedopt(&optstr, \"ExitOnForwardFailure\") == DROPBEAR_SUCCESS) {\n\t\tcli_opts.exit_on_fwd_failure = parse_flag_value(optstr);\n\t\treturn;\n\t}\n#endif\n\n#ifndef DISABLE_SYSLOG\n\tif (match_extendedopt(&optstr, \"UseSyslog\") == DROPBEAR_SUCCESS) {\n\t\topts.usingsyslog = parse_flag_value(optstr);\n\t\treturn;\n\t}\n#endif\n\n\tif (match_extendedopt(&optstr, \"Port\") == DROPBEAR_SUCCESS) {\n\t\tcli_opts.remoteport = optstr;\n\t\treturn;\n\t}\n\n\tif (match_extendedopt(&optstr, \"DisableTrivialAuth\") == DROPBEAR_SUCCESS) {\n\t\tcli_opts.disable_trivial_auth = parse_flag_value(optstr);\n\t\treturn;\n\t}\n\n\tdropbear_log(LOG_WARNING, \"Ignoring unknown configuration option '%s'\", origstr);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,7 +6,7 @@\n #if DROPBEAR_CLI_ANYTCPFWD\n \t\t\t\"\\tExitOnForwardFailure\\n\"\n #endif\n-\t\t\t\"\\tExitOnTrivialAuth\\n\"\n+\t\t\t\"\\tDisableTrivialAuth\\n\"\n #ifndef DISABLE_SYSLOG\n \t\t\t\"\\tUseSyslog\\n\"\n #endif\n@@ -34,8 +34,8 @@\n \t\treturn;\n \t}\n \n-\tif (match_extendedopt(&optstr, \"ExitOnTrivialAuth\") == DROPBEAR_SUCCESS) {\n-\t\tcli_opts.exit_on_trivial_auth = parse_flag_value(optstr);\n+\tif (match_extendedopt(&optstr, \"DisableTrivialAuth\") == DROPBEAR_SUCCESS) {\n+\t\tcli_opts.disable_trivial_auth = parse_flag_value(optstr);\n \t\treturn;\n \t}\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\t\"\\tExitOnTrivialAuth\\n\"",
                "\tif (match_extendedopt(&optstr, \"ExitOnTrivialAuth\") == DROPBEAR_SUCCESS) {",
                "\t\tcli_opts.exit_on_trivial_auth = parse_flag_value(optstr);"
            ],
            "added_lines": [
                "\t\t\t\"\\tDisableTrivialAuth\\n\"",
                "\tif (match_extendedopt(&optstr, \"DisableTrivialAuth\") == DROPBEAR_SUCCESS) {",
                "\t\tcli_opts.disable_trivial_auth = parse_flag_value(optstr);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-36369",
        "func_name": "mkj/dropbear/cli_getopts",
        "description": "An issue was discovered in Dropbear through 2020.81. Due to a non-RFC-compliant check of the available authentication methods in the client-side SSH code, it is possible for an SSH server to change the login process in its favor. This attack can bypass additional security measures such as FIDO2 tokens or SSH-Askpass. Thus, it allows an attacker to abuse a forwarded agent for logging on to another server unnoticed.",
        "git_url": "https://github.com/mkj/dropbear/commit/adbdb213eb0fe3e982cc57d7ae882c1915bef818",
        "commit_title": "rename argument to match with other ssh clients",
        "commit_text": "",
        "func_before": "void cli_getopts(int argc, char ** argv) {\n\tunsigned int i, j;\n\tchar ** next = NULL;\n\tenum {\n\t\tOPT_EXTENDED_OPTIONS,\n#if DROPBEAR_CLI_PUBKEY_AUTH\n\t\tOPT_AUTHKEY,\n#endif\n#if DROPBEAR_CLI_LOCALTCPFWD\n\t\tOPT_LOCALTCPFWD,\n#endif\n#if DROPBEAR_CLI_REMOTETCPFWD\n\t\tOPT_REMOTETCPFWD,\n#endif\n#if DROPBEAR_CLI_NETCAT\n\t\tOPT_NETCAT,\n#endif\n\t\t/* a flag (no arg) if 'next' is NULL, a string-valued option otherwise */\n\t\tOPT_OTHER\n\t} opt;\n\tunsigned int cmdlen;\n\n\tchar* recv_window_arg = NULL;\n\tchar* keepalive_arg = NULL;\n\tchar* idle_timeout_arg = NULL;\n\tchar *host_arg = NULL;\n\tchar *bind_arg = NULL;\n\tchar c;\n\n\t/* see printhelp() for options */\n\tcli_opts.progname = argv[0];\n\tcli_opts.remotehost = NULL;\n\tcli_opts.remoteport = NULL;\n\tcli_opts.username = NULL;\n\tcli_opts.cmd = NULL;\n\tcli_opts.no_cmd = 0;\n\tcli_opts.backgrounded = 0;\n\tcli_opts.wantpty = 9; /* 9 means \"it hasn't been touched\", gets set later */\n\tcli_opts.always_accept_key = 0;\n\tcli_opts.no_hostkey_check = 0;\n\tcli_opts.is_subsystem = 0;\n#if DROPBEAR_CLI_PUBKEY_AUTH\n\tcli_opts.privkeys = list_new();\n#endif\n#if DROPBEAR_CLI_ANYTCPFWD\n\tcli_opts.exit_on_fwd_failure = 0;\n#endif\n\tcli_opts.exit_on_trivial_auth = 0;\n#if DROPBEAR_CLI_LOCALTCPFWD\n\tcli_opts.localfwds = list_new();\n\topts.listen_fwd_all = 0;\n#endif\n#if DROPBEAR_CLI_REMOTETCPFWD\n\tcli_opts.remotefwds = list_new();\n#endif\n#if DROPBEAR_CLI_AGENTFWD\n\tcli_opts.agent_fwd = 0;\n\tcli_opts.agent_fd = -1;\n\tcli_opts.agent_keys_loaded = 0;\n#endif\n#if DROPBEAR_CLI_PROXYCMD\n\tcli_opts.proxycmd = NULL;\n#endif\n\tcli_opts.bind_address = NULL;\n\tcli_opts.bind_port = NULL;\n#ifndef DISABLE_ZLIB\n\topts.compress_mode = DROPBEAR_COMPRESS_ON;\n#endif\n#if DROPBEAR_USER_ALGO_LIST\n\topts.cipher_list = NULL;\n\topts.mac_list = NULL;\n#endif\n#ifndef DISABLE_SYSLOG\n\topts.usingsyslog = 0;\n#endif\n\t/* not yet\n\topts.ipv4 = 1;\n\topts.ipv6 = 1;\n\t*/\n\topts.recv_window = DEFAULT_RECV_WINDOW;\n\topts.keepalive_secs = DEFAULT_KEEPALIVE;\n\topts.idle_timeout_secs = DEFAULT_IDLE_TIMEOUT;\n\n\tfill_own_user();\n\n\tfor (i = 1; i < (unsigned int)argc; i++) {\n\t\t/* Handle non-flag arguments such as hostname or commands for the remote host */\n\t\tif (argv[i][0] != '-')\n\t\t{\n\t\t\tif (host_arg == NULL) {\n\t\t\t\thost_arg = argv[i];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* Commands to pass to the remote host. No more flag handling,\n\t\t\tcommands are consumed below */\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Begins with '-' */\n\t\topt = OPT_OTHER;\n\t\tfor (j = 1; (c = argv[i][j]) != '\\0' && !next && opt == OPT_OTHER; j++) {\n\t\t\tswitch (c) {\n\t\t\t\tcase 'y': /* always accept the remote hostkey */\n\t\t\t\t\tif (cli_opts.always_accept_key) {\n\t\t\t\t\t\t/* twice means no checking at all */\n\t\t\t\t\t\tcli_opts.no_hostkey_check = 1;\n\t\t\t\t\t}\n\t\t\t\t\tcli_opts.always_accept_key = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'p': /* remoteport */\n\t\t\t\t\tnext = (char**)&cli_opts.remoteport;\n\t\t\t\t\tbreak;\n#if DROPBEAR_CLI_PUBKEY_AUTH\n\t\t\t\tcase 'i': /* an identityfile */\n\t\t\t\t\topt = OPT_AUTHKEY;\n\t\t\t\t\tbreak;\n#endif\n\t\t\t\tcase 't': /* we want a pty */\n\t\t\t\t\tcli_opts.wantpty = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'T': /* don't want a pty */\n\t\t\t\t\tcli_opts.wantpty = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'N':\n\t\t\t\t\tcli_opts.no_cmd = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'f':\n\t\t\t\t\tcli_opts.backgrounded = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 's':\n\t\t\t\t\tcli_opts.is_subsystem = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'o':\n\t\t\t\t\topt = OPT_EXTENDED_OPTIONS;\n\t\t\t\t\tbreak;\n#if DROPBEAR_CLI_LOCALTCPFWD\n\t\t\t\tcase 'L':\n\t\t\t\t\topt = OPT_LOCALTCPFWD;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'g':\n\t\t\t\t\topts.listen_fwd_all = 1;\n\t\t\t\t\tbreak;\n#endif\n#if DROPBEAR_CLI_REMOTETCPFWD\n\t\t\t\tcase 'R':\n\t\t\t\t\topt = OPT_REMOTETCPFWD;\n\t\t\t\t\tbreak;\n#endif\n#if DROPBEAR_CLI_NETCAT\n\t\t\t\tcase 'B':\n\t\t\t\t\topt = OPT_NETCAT;\n\t\t\t\t\tbreak;\n#endif\n#if DROPBEAR_CLI_PROXYCMD\n\t\t\t\tcase 'J':\n\t\t\t\t\tnext = &cli_opts.proxycmd;\n\t\t\t\t\tbreak;\n#endif\n\t\t\t\tcase 'l':\n\t\t\t\t\tnext = &cli_opts.username;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'h':\n\t\t\t\t\tprinthelp();\n\t\t\t\t\texit(EXIT_SUCCESS);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'u':\n\t\t\t\t\t/* backwards compatibility with old urandom option */\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'W':\n\t\t\t\t\tnext = &recv_window_arg;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'K':\n\t\t\t\t\tnext = &keepalive_arg;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'I':\n\t\t\t\t\tnext = &idle_timeout_arg;\n\t\t\t\t\tbreak;\n#if DROPBEAR_CLI_AGENTFWD\n\t\t\t\tcase 'A':\n\t\t\t\t\tcli_opts.agent_fwd = 1;\n\t\t\t\t\tbreak;\n#endif\n#if DROPBEAR_USER_ALGO_LIST\n\t\t\t\tcase 'c':\n\t\t\t\t\tnext = &opts.cipher_list;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'm':\n\t\t\t\t\tnext = &opts.mac_list;\n\t\t\t\t\tbreak;\n#endif\n#if DEBUG_TRACE\n\t\t\t\tcase 'v':\n\t\t\t\t\tdebug_trace = 1;\n\t\t\t\t\tbreak;\n#endif\n\t\t\t\tcase 'F':\n\t\t\t\tcase 'e':\n#if !DROPBEAR_USER_ALGO_LIST\n\t\t\t\tcase 'c':\n\t\t\t\tcase 'm':\n#endif\n\t\t\t\tcase 'D':\n#if !DROPBEAR_CLI_REMOTETCPFWD\n\t\t\t\tcase 'R':\n#endif\n#if !DROPBEAR_CLI_LOCALTCPFWD\n\t\t\t\tcase 'L':\n#endif\n\t\t\t\tcase 'V':\n\t\t\t\t\tprint_version();\n\t\t\t\t\texit(EXIT_SUCCESS);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'b':\n\t\t\t\t\tnext = &bind_arg;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\t\"WARNING: Ignoring unknown option -%c\\n\", c);\n\t\t\t\t\tbreak;\n\t\t\t} /* Switch */\n\t\t}\n\n\t\tif (!next && opt == OPT_OTHER) /* got a flag */\n\t\t\tcontinue;\n\n\t\tif (c == '\\0') {\n\t\t\ti++;\n\t\t\tj = 0;\n\t\t\tif (!argv[i])\n\t\t\t\tdropbear_exit(\"Missing argument\");\n\t\t}\n\n\t\tif (opt == OPT_EXTENDED_OPTIONS) {\n\t\t\tTRACE((\"opt extended\"))\n\t\t\tadd_extendedopt(&argv[i][j]);\n\t\t}\n\t\telse\n#if DROPBEAR_CLI_PUBKEY_AUTH\n\t\tif (opt == OPT_AUTHKEY) {\n\t\t\tTRACE((\"opt authkey\"))\n\t\t\tloadidentityfile(&argv[i][j], 1);\n\t\t}\n\t\telse\n#endif\n#if DROPBEAR_CLI_REMOTETCPFWD\n\t\tif (opt == OPT_REMOTETCPFWD) {\n\t\t\tTRACE((\"opt remotetcpfwd\"))\n\t\t\taddforward(&argv[i][j], cli_opts.remotefwds);\n\t\t}\n\t\telse\n#endif\n#if DROPBEAR_CLI_LOCALTCPFWD\n\t\tif (opt == OPT_LOCALTCPFWD) {\n\t\t\tTRACE((\"opt localtcpfwd\"))\n\t\t\taddforward(&argv[i][j], cli_opts.localfwds);\n\t\t}\n\t\telse\n#endif\n#if DROPBEAR_CLI_NETCAT\n\t\tif (opt == OPT_NETCAT) {\n\t\t\tTRACE((\"opt netcat\"))\n\t\t\tadd_netcat(&argv[i][j]);\n\t\t}\n\t\telse\n#endif\n\t\tif (next) {\n\t\t\t/* The previous flag set a value to assign */\n\t\t\t*next = &argv[i][j];\n\t\t\tif (*next == NULL)\n\t\t\t\tdropbear_exit(\"Invalid null argument\");\n\t\t\tnext = NULL;\n\t\t}\n\t}\n\n#if DROPBEAR_USER_ALGO_LIST\n\t/* -c help doesn't need a hostname */\n\tparse_ciphers_macs();\n#endif\n\n\t/* Done with options/flags; now handle the hostname (which may not\n\t * start with a hyphen) and optional command */\n\n\tif (host_arg == NULL) { /* missing hostname */\n\t\tprinthelp();\n\t\texit(EXIT_FAILURE);\n\t}\n\tTRACE((\"host is: %s\", host_arg))\n\n\tif (i < (unsigned int)argc) {\n\t\t/* Build the command to send */\n\t\tcmdlen = 0;\n\t\tfor (j = i; j < (unsigned int)argc; j++)\n\t\t\tcmdlen += strlen(argv[j]) + 1; /* +1 for spaces */\n\n\t\t/* Allocate the space */\n\t\tcli_opts.cmd = (char*)m_malloc(cmdlen);\n\t\tcli_opts.cmd[0] = '\\0';\n\n\t\t/* Append all the bits */\n\t\tfor (j = i; j < (unsigned int)argc; j++) {\n\t\t\tstrlcat(cli_opts.cmd, argv[j], cmdlen);\n\t\t\tstrlcat(cli_opts.cmd, \" \", cmdlen);\n\t\t}\n\t\t/* It'll be null-terminated here */\n\t\tTRACE((\"cmd is: %s\", cli_opts.cmd))\n\t}\n\n\t/* And now a few sanity checks and setup */\n\n#if DROPBEAR_CLI_PROXYCMD                                                                                                                                   \n\tif (cli_opts.proxycmd) {\n\t\t/* To match the common path of m_freeing it */\n\t\tcli_opts.proxycmd = m_strdup(cli_opts.proxycmd);\n\t}\n#endif\n\n\tif (cli_opts.remoteport == NULL) {\n\t\tcli_opts.remoteport = \"22\";\n\t}\n\n\tif (bind_arg) {\n\t\t/* split [host][:port] */\n\t\tchar *port = strrchr(bind_arg, ':');\n\t\tif (port) {\n\t\t\tcli_opts.bind_port = m_strdup(port+1);\n\t\t\t*port = '\\0';\n\t\t}\n\t\tif (strlen(bind_arg) > 0) {\n\t\t\tcli_opts.bind_address = m_strdup(bind_arg);\n\t\t}\n\t}\n\n\t/* If not explicitly specified with -t or -T, we don't want a pty if\n\t * there's a command, but we do otherwise */\n\tif (cli_opts.wantpty == 9) {\n\t\tif (cli_opts.cmd == NULL) {\n\t\t\tcli_opts.wantpty = 1;\n\t\t} else {\n\t\t\tcli_opts.wantpty = 0;\n\t\t}\n\t}\n\n\tif (cli_opts.backgrounded && cli_opts.cmd == NULL\n\t\t\t&& cli_opts.no_cmd == 0) {\n\t\tdropbear_exit(\"Command required for -f\");\n\t}\n\t\n\tif (recv_window_arg) {\n\t\topts.recv_window = atol(recv_window_arg);\n\t\tif (opts.recv_window == 0 || opts.recv_window > MAX_RECV_WINDOW) {\n\t\t\tdropbear_exit(\"Bad recv window '%s'\", recv_window_arg);\n\t\t}\n\t}\n\tif (keepalive_arg) {\n\t\tunsigned int val;\n\t\tif (m_str_to_uint(keepalive_arg, &val) == DROPBEAR_FAILURE) {\n\t\t\tdropbear_exit(\"Bad keepalive '%s'\", keepalive_arg);\n\t\t}\n\t\topts.keepalive_secs = val;\n\t}\n\n\tif (idle_timeout_arg) {\n\t\tunsigned int val;\n\t\tif (m_str_to_uint(idle_timeout_arg, &val) == DROPBEAR_FAILURE) {\n\t\t\tdropbear_exit(\"Bad idle_timeout '%s'\", idle_timeout_arg);\n\t\t}\n\t\topts.idle_timeout_secs = val;\n\t}\n\n#if DROPBEAR_CLI_NETCAT\n\tif (cli_opts.cmd && cli_opts.netcat_host) {\n\t\tdropbear_log(LOG_INFO, \"Ignoring command '%s' in netcat mode\", cli_opts.cmd);\n\t}\n#endif\n\n#if (DROPBEAR_CLI_PUBKEY_AUTH)\n\t{\n\t\tchar *expand_path = expand_homedir_path(DROPBEAR_DEFAULT_CLI_AUTHKEY);\n\t\tloadidentityfile(expand_path, 0);\n\t\tm_free(expand_path);\n\t}\n#endif\n\n\t/* The hostname gets set up last, since\n\t * in multi-hop mode it will require knowledge\n\t * of other flags such as -i */\n#if DROPBEAR_CLI_MULTIHOP\n\tparse_multihop_hostname(host_arg, argv[0]);\n#else\n\tparse_hostname(host_arg);\n#endif\n}",
        "func": "void cli_getopts(int argc, char ** argv) {\n\tunsigned int i, j;\n\tchar ** next = NULL;\n\tenum {\n\t\tOPT_EXTENDED_OPTIONS,\n#if DROPBEAR_CLI_PUBKEY_AUTH\n\t\tOPT_AUTHKEY,\n#endif\n#if DROPBEAR_CLI_LOCALTCPFWD\n\t\tOPT_LOCALTCPFWD,\n#endif\n#if DROPBEAR_CLI_REMOTETCPFWD\n\t\tOPT_REMOTETCPFWD,\n#endif\n#if DROPBEAR_CLI_NETCAT\n\t\tOPT_NETCAT,\n#endif\n\t\t/* a flag (no arg) if 'next' is NULL, a string-valued option otherwise */\n\t\tOPT_OTHER\n\t} opt;\n\tunsigned int cmdlen;\n\n\tchar* recv_window_arg = NULL;\n\tchar* keepalive_arg = NULL;\n\tchar* idle_timeout_arg = NULL;\n\tchar *host_arg = NULL;\n\tchar *bind_arg = NULL;\n\tchar c;\n\n\t/* see printhelp() for options */\n\tcli_opts.progname = argv[0];\n\tcli_opts.remotehost = NULL;\n\tcli_opts.remoteport = NULL;\n\tcli_opts.username = NULL;\n\tcli_opts.cmd = NULL;\n\tcli_opts.no_cmd = 0;\n\tcli_opts.backgrounded = 0;\n\tcli_opts.wantpty = 9; /* 9 means \"it hasn't been touched\", gets set later */\n\tcli_opts.always_accept_key = 0;\n\tcli_opts.no_hostkey_check = 0;\n\tcli_opts.is_subsystem = 0;\n#if DROPBEAR_CLI_PUBKEY_AUTH\n\tcli_opts.privkeys = list_new();\n#endif\n#if DROPBEAR_CLI_ANYTCPFWD\n\tcli_opts.exit_on_fwd_failure = 0;\n#endif\n\tcli_opts.disable_trivial_auth = 0;\n#if DROPBEAR_CLI_LOCALTCPFWD\n\tcli_opts.localfwds = list_new();\n\topts.listen_fwd_all = 0;\n#endif\n#if DROPBEAR_CLI_REMOTETCPFWD\n\tcli_opts.remotefwds = list_new();\n#endif\n#if DROPBEAR_CLI_AGENTFWD\n\tcli_opts.agent_fwd = 0;\n\tcli_opts.agent_fd = -1;\n\tcli_opts.agent_keys_loaded = 0;\n#endif\n#if DROPBEAR_CLI_PROXYCMD\n\tcli_opts.proxycmd = NULL;\n#endif\n\tcli_opts.bind_address = NULL;\n\tcli_opts.bind_port = NULL;\n#ifndef DISABLE_ZLIB\n\topts.compress_mode = DROPBEAR_COMPRESS_ON;\n#endif\n#if DROPBEAR_USER_ALGO_LIST\n\topts.cipher_list = NULL;\n\topts.mac_list = NULL;\n#endif\n#ifndef DISABLE_SYSLOG\n\topts.usingsyslog = 0;\n#endif\n\t/* not yet\n\topts.ipv4 = 1;\n\topts.ipv6 = 1;\n\t*/\n\topts.recv_window = DEFAULT_RECV_WINDOW;\n\topts.keepalive_secs = DEFAULT_KEEPALIVE;\n\topts.idle_timeout_secs = DEFAULT_IDLE_TIMEOUT;\n\n\tfill_own_user();\n\n\tfor (i = 1; i < (unsigned int)argc; i++) {\n\t\t/* Handle non-flag arguments such as hostname or commands for the remote host */\n\t\tif (argv[i][0] != '-')\n\t\t{\n\t\t\tif (host_arg == NULL) {\n\t\t\t\thost_arg = argv[i];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* Commands to pass to the remote host. No more flag handling,\n\t\t\tcommands are consumed below */\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Begins with '-' */\n\t\topt = OPT_OTHER;\n\t\tfor (j = 1; (c = argv[i][j]) != '\\0' && !next && opt == OPT_OTHER; j++) {\n\t\t\tswitch (c) {\n\t\t\t\tcase 'y': /* always accept the remote hostkey */\n\t\t\t\t\tif (cli_opts.always_accept_key) {\n\t\t\t\t\t\t/* twice means no checking at all */\n\t\t\t\t\t\tcli_opts.no_hostkey_check = 1;\n\t\t\t\t\t}\n\t\t\t\t\tcli_opts.always_accept_key = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'p': /* remoteport */\n\t\t\t\t\tnext = (char**)&cli_opts.remoteport;\n\t\t\t\t\tbreak;\n#if DROPBEAR_CLI_PUBKEY_AUTH\n\t\t\t\tcase 'i': /* an identityfile */\n\t\t\t\t\topt = OPT_AUTHKEY;\n\t\t\t\t\tbreak;\n#endif\n\t\t\t\tcase 't': /* we want a pty */\n\t\t\t\t\tcli_opts.wantpty = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'T': /* don't want a pty */\n\t\t\t\t\tcli_opts.wantpty = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'N':\n\t\t\t\t\tcli_opts.no_cmd = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'f':\n\t\t\t\t\tcli_opts.backgrounded = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 's':\n\t\t\t\t\tcli_opts.is_subsystem = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'o':\n\t\t\t\t\topt = OPT_EXTENDED_OPTIONS;\n\t\t\t\t\tbreak;\n#if DROPBEAR_CLI_LOCALTCPFWD\n\t\t\t\tcase 'L':\n\t\t\t\t\topt = OPT_LOCALTCPFWD;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'g':\n\t\t\t\t\topts.listen_fwd_all = 1;\n\t\t\t\t\tbreak;\n#endif\n#if DROPBEAR_CLI_REMOTETCPFWD\n\t\t\t\tcase 'R':\n\t\t\t\t\topt = OPT_REMOTETCPFWD;\n\t\t\t\t\tbreak;\n#endif\n#if DROPBEAR_CLI_NETCAT\n\t\t\t\tcase 'B':\n\t\t\t\t\topt = OPT_NETCAT;\n\t\t\t\t\tbreak;\n#endif\n#if DROPBEAR_CLI_PROXYCMD\n\t\t\t\tcase 'J':\n\t\t\t\t\tnext = &cli_opts.proxycmd;\n\t\t\t\t\tbreak;\n#endif\n\t\t\t\tcase 'l':\n\t\t\t\t\tnext = &cli_opts.username;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'h':\n\t\t\t\t\tprinthelp();\n\t\t\t\t\texit(EXIT_SUCCESS);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'u':\n\t\t\t\t\t/* backwards compatibility with old urandom option */\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'W':\n\t\t\t\t\tnext = &recv_window_arg;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'K':\n\t\t\t\t\tnext = &keepalive_arg;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'I':\n\t\t\t\t\tnext = &idle_timeout_arg;\n\t\t\t\t\tbreak;\n#if DROPBEAR_CLI_AGENTFWD\n\t\t\t\tcase 'A':\n\t\t\t\t\tcli_opts.agent_fwd = 1;\n\t\t\t\t\tbreak;\n#endif\n#if DROPBEAR_USER_ALGO_LIST\n\t\t\t\tcase 'c':\n\t\t\t\t\tnext = &opts.cipher_list;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'm':\n\t\t\t\t\tnext = &opts.mac_list;\n\t\t\t\t\tbreak;\n#endif\n#if DEBUG_TRACE\n\t\t\t\tcase 'v':\n\t\t\t\t\tdebug_trace = 1;\n\t\t\t\t\tbreak;\n#endif\n\t\t\t\tcase 'F':\n\t\t\t\tcase 'e':\n#if !DROPBEAR_USER_ALGO_LIST\n\t\t\t\tcase 'c':\n\t\t\t\tcase 'm':\n#endif\n\t\t\t\tcase 'D':\n#if !DROPBEAR_CLI_REMOTETCPFWD\n\t\t\t\tcase 'R':\n#endif\n#if !DROPBEAR_CLI_LOCALTCPFWD\n\t\t\t\tcase 'L':\n#endif\n\t\t\t\tcase 'V':\n\t\t\t\t\tprint_version();\n\t\t\t\t\texit(EXIT_SUCCESS);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'b':\n\t\t\t\t\tnext = &bind_arg;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\t\"WARNING: Ignoring unknown option -%c\\n\", c);\n\t\t\t\t\tbreak;\n\t\t\t} /* Switch */\n\t\t}\n\n\t\tif (!next && opt == OPT_OTHER) /* got a flag */\n\t\t\tcontinue;\n\n\t\tif (c == '\\0') {\n\t\t\ti++;\n\t\t\tj = 0;\n\t\t\tif (!argv[i])\n\t\t\t\tdropbear_exit(\"Missing argument\");\n\t\t}\n\n\t\tif (opt == OPT_EXTENDED_OPTIONS) {\n\t\t\tTRACE((\"opt extended\"))\n\t\t\tadd_extendedopt(&argv[i][j]);\n\t\t}\n\t\telse\n#if DROPBEAR_CLI_PUBKEY_AUTH\n\t\tif (opt == OPT_AUTHKEY) {\n\t\t\tTRACE((\"opt authkey\"))\n\t\t\tloadidentityfile(&argv[i][j], 1);\n\t\t}\n\t\telse\n#endif\n#if DROPBEAR_CLI_REMOTETCPFWD\n\t\tif (opt == OPT_REMOTETCPFWD) {\n\t\t\tTRACE((\"opt remotetcpfwd\"))\n\t\t\taddforward(&argv[i][j], cli_opts.remotefwds);\n\t\t}\n\t\telse\n#endif\n#if DROPBEAR_CLI_LOCALTCPFWD\n\t\tif (opt == OPT_LOCALTCPFWD) {\n\t\t\tTRACE((\"opt localtcpfwd\"))\n\t\t\taddforward(&argv[i][j], cli_opts.localfwds);\n\t\t}\n\t\telse\n#endif\n#if DROPBEAR_CLI_NETCAT\n\t\tif (opt == OPT_NETCAT) {\n\t\t\tTRACE((\"opt netcat\"))\n\t\t\tadd_netcat(&argv[i][j]);\n\t\t}\n\t\telse\n#endif\n\t\tif (next) {\n\t\t\t/* The previous flag set a value to assign */\n\t\t\t*next = &argv[i][j];\n\t\t\tif (*next == NULL)\n\t\t\t\tdropbear_exit(\"Invalid null argument\");\n\t\t\tnext = NULL;\n\t\t}\n\t}\n\n#if DROPBEAR_USER_ALGO_LIST\n\t/* -c help doesn't need a hostname */\n\tparse_ciphers_macs();\n#endif\n\n\t/* Done with options/flags; now handle the hostname (which may not\n\t * start with a hyphen) and optional command */\n\n\tif (host_arg == NULL) { /* missing hostname */\n\t\tprinthelp();\n\t\texit(EXIT_FAILURE);\n\t}\n\tTRACE((\"host is: %s\", host_arg))\n\n\tif (i < (unsigned int)argc) {\n\t\t/* Build the command to send */\n\t\tcmdlen = 0;\n\t\tfor (j = i; j < (unsigned int)argc; j++)\n\t\t\tcmdlen += strlen(argv[j]) + 1; /* +1 for spaces */\n\n\t\t/* Allocate the space */\n\t\tcli_opts.cmd = (char*)m_malloc(cmdlen);\n\t\tcli_opts.cmd[0] = '\\0';\n\n\t\t/* Append all the bits */\n\t\tfor (j = i; j < (unsigned int)argc; j++) {\n\t\t\tstrlcat(cli_opts.cmd, argv[j], cmdlen);\n\t\t\tstrlcat(cli_opts.cmd, \" \", cmdlen);\n\t\t}\n\t\t/* It'll be null-terminated here */\n\t\tTRACE((\"cmd is: %s\", cli_opts.cmd))\n\t}\n\n\t/* And now a few sanity checks and setup */\n\n#if DROPBEAR_CLI_PROXYCMD                                                                                                                                   \n\tif (cli_opts.proxycmd) {\n\t\t/* To match the common path of m_freeing it */\n\t\tcli_opts.proxycmd = m_strdup(cli_opts.proxycmd);\n\t}\n#endif\n\n\tif (cli_opts.remoteport == NULL) {\n\t\tcli_opts.remoteport = \"22\";\n\t}\n\n\tif (bind_arg) {\n\t\t/* split [host][:port] */\n\t\tchar *port = strrchr(bind_arg, ':');\n\t\tif (port) {\n\t\t\tcli_opts.bind_port = m_strdup(port+1);\n\t\t\t*port = '\\0';\n\t\t}\n\t\tif (strlen(bind_arg) > 0) {\n\t\t\tcli_opts.bind_address = m_strdup(bind_arg);\n\t\t}\n\t}\n\n\t/* If not explicitly specified with -t or -T, we don't want a pty if\n\t * there's a command, but we do otherwise */\n\tif (cli_opts.wantpty == 9) {\n\t\tif (cli_opts.cmd == NULL) {\n\t\t\tcli_opts.wantpty = 1;\n\t\t} else {\n\t\t\tcli_opts.wantpty = 0;\n\t\t}\n\t}\n\n\tif (cli_opts.backgrounded && cli_opts.cmd == NULL\n\t\t\t&& cli_opts.no_cmd == 0) {\n\t\tdropbear_exit(\"Command required for -f\");\n\t}\n\t\n\tif (recv_window_arg) {\n\t\topts.recv_window = atol(recv_window_arg);\n\t\tif (opts.recv_window == 0 || opts.recv_window > MAX_RECV_WINDOW) {\n\t\t\tdropbear_exit(\"Bad recv window '%s'\", recv_window_arg);\n\t\t}\n\t}\n\tif (keepalive_arg) {\n\t\tunsigned int val;\n\t\tif (m_str_to_uint(keepalive_arg, &val) == DROPBEAR_FAILURE) {\n\t\t\tdropbear_exit(\"Bad keepalive '%s'\", keepalive_arg);\n\t\t}\n\t\topts.keepalive_secs = val;\n\t}\n\n\tif (idle_timeout_arg) {\n\t\tunsigned int val;\n\t\tif (m_str_to_uint(idle_timeout_arg, &val) == DROPBEAR_FAILURE) {\n\t\t\tdropbear_exit(\"Bad idle_timeout '%s'\", idle_timeout_arg);\n\t\t}\n\t\topts.idle_timeout_secs = val;\n\t}\n\n#if DROPBEAR_CLI_NETCAT\n\tif (cli_opts.cmd && cli_opts.netcat_host) {\n\t\tdropbear_log(LOG_INFO, \"Ignoring command '%s' in netcat mode\", cli_opts.cmd);\n\t}\n#endif\n\n#if (DROPBEAR_CLI_PUBKEY_AUTH)\n\t{\n\t\tchar *expand_path = expand_homedir_path(DROPBEAR_DEFAULT_CLI_AUTHKEY);\n\t\tloadidentityfile(expand_path, 0);\n\t\tm_free(expand_path);\n\t}\n#endif\n\n\t/* The hostname gets set up last, since\n\t * in multi-hop mode it will require knowledge\n\t * of other flags such as -i */\n#if DROPBEAR_CLI_MULTIHOP\n\tparse_multihop_hostname(host_arg, argv[0]);\n#else\n\tparse_hostname(host_arg);\n#endif\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -45,7 +45,7 @@\n #if DROPBEAR_CLI_ANYTCPFWD\n \tcli_opts.exit_on_fwd_failure = 0;\n #endif\n-\tcli_opts.exit_on_trivial_auth = 0;\n+\tcli_opts.disable_trivial_auth = 0;\n #if DROPBEAR_CLI_LOCALTCPFWD\n \tcli_opts.localfwds = list_new();\n \topts.listen_fwd_all = 0;",
        "diff_line_info": {
            "deleted_lines": [
                "\tcli_opts.exit_on_trivial_auth = 0;"
            ],
            "added_lines": [
                "\tcli_opts.disable_trivial_auth = 0;"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-36369",
        "func_name": "mkj/dropbear/recv_msg_userauth_success",
        "description": "An issue was discovered in Dropbear through 2020.81. Due to a non-RFC-compliant check of the available authentication methods in the client-side SSH code, it is possible for an SSH server to change the login process in its favor. This attack can bypass additional security measures such as FIDO2 tokens or SSH-Askpass. Thus, it allows an attacker to abuse a forwarded agent for logging on to another server unnoticed.",
        "git_url": "https://github.com/mkj/dropbear/commit/adbdb213eb0fe3e982cc57d7ae882c1915bef818",
        "commit_title": "rename argument to match with other ssh clients",
        "commit_text": "",
        "func_before": "void recv_msg_userauth_success() {\n\t/* This function can validly get called multiple times\n\tif DROPBEAR_CLI_IMMEDIATE_AUTH is set */\n\n\tTRACE((\"received msg_userauth_success\"))\n\tif (cli_opts.exit_on_trivial_auth && cli_ses.is_trivial_auth) {\n\t\tdropbear_exit(\"trivial authentication not allowed\");\n\t}\n\t/* Note: in delayed-zlib mode, setting authdone here \n\t * will enable compression in the transport layer */\n\tses.authstate.authdone = 1;\n\tcli_ses.state = USERAUTH_SUCCESS_RCVD;\n\tcli_ses.lastauthtype = AUTH_TYPE_NONE;\n\n#if DROPBEAR_CLI_PUBKEY_AUTH\n\tcli_auth_pubkey_cleanup();\n#endif\n}",
        "func": "void recv_msg_userauth_success() {\n\t/* This function can validly get called multiple times\n\tif DROPBEAR_CLI_IMMEDIATE_AUTH is set */\n\n\tTRACE((\"received msg_userauth_success\"))\n\tif (cli_opts.disable_trivial_auth && cli_ses.is_trivial_auth) {\n\t\tdropbear_exit(\"trivial authentication not allowed\");\n\t}\n\t/* Note: in delayed-zlib mode, setting authdone here \n\t * will enable compression in the transport layer */\n\tses.authstate.authdone = 1;\n\tcli_ses.state = USERAUTH_SUCCESS_RCVD;\n\tcli_ses.lastauthtype = AUTH_TYPE_NONE;\n\n#if DROPBEAR_CLI_PUBKEY_AUTH\n\tcli_auth_pubkey_cleanup();\n#endif\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,7 +3,7 @@\n \tif DROPBEAR_CLI_IMMEDIATE_AUTH is set */\n \n \tTRACE((\"received msg_userauth_success\"))\n-\tif (cli_opts.exit_on_trivial_auth && cli_ses.is_trivial_auth) {\n+\tif (cli_opts.disable_trivial_auth && cli_ses.is_trivial_auth) {\n \t\tdropbear_exit(\"trivial authentication not allowed\");\n \t}\n \t/* Note: in delayed-zlib mode, setting authdone here ",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (cli_opts.exit_on_trivial_auth && cli_ses.is_trivial_auth) {"
            ],
            "added_lines": [
                "\tif (cli_opts.disable_trivial_auth && cli_ses.is_trivial_auth) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-36369",
        "func_name": "mkj/dropbear/recv_msg_userauth_info_request",
        "description": "An issue was discovered in Dropbear through 2020.81. Due to a non-RFC-compliant check of the available authentication methods in the client-side SSH code, it is possible for an SSH server to change the login process in its favor. This attack can bypass additional security measures such as FIDO2 tokens or SSH-Askpass. Thus, it allows an attacker to abuse a forwarded agent for logging on to another server unnoticed.",
        "git_url": "https://github.com/mkj/dropbear/commit/7c2e8fcd0d162d2ba9fac116f96a5e82ac77f11c",
        "commit_title": "added option to disable trivial auth methods",
        "commit_text": "",
        "func_before": "void recv_msg_userauth_info_request() {\n\n\tchar *name = NULL;\n\tchar *instruction = NULL;\n\tunsigned int num_prompts = 0;\n\tunsigned int i;\n\n\tchar *prompt = NULL;\n\tunsigned int echo = 0;\n\tchar *response = NULL;\n\n\tTRACE((\"enter recv_msg_recv_userauth_info_request\"))\n\n\t/* Let the user know what password/host they are authing for */\n\tif (!cli_ses.interact_request_received) {\n\t\tfprintf(stderr, \"Login for %s@%s\\n\", cli_opts.username,\n\t\t\t\tcli_opts.remotehost);\n\t}\n\tcli_ses.interact_request_received = 1;\n\n\tname = buf_getstring(ses.payload, NULL);\n\tinstruction = buf_getstring(ses.payload, NULL);\n\n\t/* language tag */\n\tbuf_eatstring(ses.payload);\n\n\tnum_prompts = buf_getint(ses.payload);\n\t\n\tif (num_prompts >= DROPBEAR_MAX_CLI_INTERACT_PROMPTS) {\n\t\tdropbear_exit(\"Too many prompts received for keyboard-interactive\");\n\t}\n\n\t/* we'll build the response as we go */\n\tCHECKCLEARTOWRITE();\n\tbuf_putbyte(ses.writepayload, SSH_MSG_USERAUTH_INFO_RESPONSE);\n\tbuf_putint(ses.writepayload, num_prompts);\n\n\tif (strlen(name) > 0) {\n\t\tcleantext(name);\n\t\tfprintf(stderr, \"%s\", name);\n\t}\n\tm_free(name);\n\n\tif (strlen(instruction) > 0) {\n\t\tcleantext(instruction);\n\t\tfprintf(stderr, \"%s\", instruction);\n\t}\n\tm_free(instruction);\n\n\tfor (i = 0; i < num_prompts; i++) {\n\t\tunsigned int response_len = 0;\n\t\tprompt = buf_getstring(ses.payload, NULL);\n\t\tcleantext(prompt);\n\n\t\techo = buf_getbool(ses.payload);\n\n\t\tif (!echo) {\n\t\t\tchar* p = getpass_or_cancel(prompt);\n\t\t\tresponse = m_strdup(p);\n\t\t\tm_burn(p, strlen(p));\n\t\t} else {\n\t\t\tresponse = get_response(prompt);\n\t\t}\n\n\t\tresponse_len = strlen(response);\n\t\tbuf_putstring(ses.writepayload, response, response_len);\n\t\tm_burn(response, response_len);\n\t\tm_free(prompt);\n\t\tm_free(response);\n\t}\n\n\tencrypt_packet();\n\n\n\tTRACE((\"leave recv_msg_recv_userauth_info_request\"))\n}",
        "func": "void recv_msg_userauth_info_request() {\n\n\tchar *name = NULL;\n\tchar *instruction = NULL;\n\tunsigned int num_prompts = 0;\n\tunsigned int i;\n\n\tchar *prompt = NULL;\n\tunsigned int echo = 0;\n\tchar *response = NULL;\n\n\tTRACE((\"enter recv_msg_recv_userauth_info_request\"))\n\n\t/* Let the user know what password/host they are authing for */\n\tif (!cli_ses.interact_request_received) {\n\t\tfprintf(stderr, \"Login for %s@%s\\n\", cli_opts.username,\n\t\t\t\tcli_opts.remotehost);\n\t}\n\tcli_ses.interact_request_received = 1;\n\n\tname = buf_getstring(ses.payload, NULL);\n\tinstruction = buf_getstring(ses.payload, NULL);\n\n\t/* language tag */\n\tbuf_eatstring(ses.payload);\n\n\tnum_prompts = buf_getint(ses.payload);\n\t\n\tif (num_prompts >= DROPBEAR_MAX_CLI_INTERACT_PROMPTS) {\n\t\tdropbear_exit(\"Too many prompts received for keyboard-interactive\");\n\t}\n\n\t/* we'll build the response as we go */\n\tCHECKCLEARTOWRITE();\n\tbuf_putbyte(ses.writepayload, SSH_MSG_USERAUTH_INFO_RESPONSE);\n\tbuf_putint(ses.writepayload, num_prompts);\n\n\tif (strlen(name) > 0) {\n\t\tcleantext(name);\n\t\tfprintf(stderr, \"%s\", name);\n\t}\n\tm_free(name);\n\n\tif (strlen(instruction) > 0) {\n\t\tcleantext(instruction);\n\t\tfprintf(stderr, \"%s\", instruction);\n\t}\n\tm_free(instruction);\n\n\tfor (i = 0; i < num_prompts; i++) {\n\t\tcli_ses.is_trivial_auth = 0;\n\t\tunsigned int response_len = 0;\n\t\tprompt = buf_getstring(ses.payload, NULL);\n\t\tcleantext(prompt);\n\n\t\techo = buf_getbool(ses.payload);\n\n\t\tif (!echo) {\n\t\t\tchar* p = getpass_or_cancel(prompt);\n\t\t\tresponse = m_strdup(p);\n\t\t\tm_burn(p, strlen(p));\n\t\t} else {\n\t\t\tresponse = get_response(prompt);\n\t\t}\n\n\t\tresponse_len = strlen(response);\n\t\tbuf_putstring(ses.writepayload, response, response_len);\n\t\tm_burn(response, response_len);\n\t\tm_free(prompt);\n\t\tm_free(response);\n\t}\n\n\tencrypt_packet();\n\n\n\tTRACE((\"leave recv_msg_recv_userauth_info_request\"))\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -48,6 +48,7 @@\n \tm_free(instruction);\n \n \tfor (i = 0; i < num_prompts; i++) {\n+\t\tcli_ses.is_trivial_auth = 0;\n \t\tunsigned int response_len = 0;\n \t\tprompt = buf_getstring(ses.payload, NULL);\n \t\tcleantext(prompt);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\tcli_ses.is_trivial_auth = 0;"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-36369",
        "func_name": "mkj/dropbear/cli_auth_pubkey",
        "description": "An issue was discovered in Dropbear through 2020.81. Due to a non-RFC-compliant check of the available authentication methods in the client-side SSH code, it is possible for an SSH server to change the login process in its favor. This attack can bypass additional security measures such as FIDO2 tokens or SSH-Askpass. Thus, it allows an attacker to abuse a forwarded agent for logging on to another server unnoticed.",
        "git_url": "https://github.com/mkj/dropbear/commit/7c2e8fcd0d162d2ba9fac116f96a5e82ac77f11c",
        "commit_title": "added option to disable trivial auth methods",
        "commit_text": "",
        "func_before": "int cli_auth_pubkey() {\n\tenum signature_type sigtype = DROPBEAR_SIGNATURE_NONE;\n\tTRACE((\"enter cli_auth_pubkey\"))\n\n#if DROPBEAR_CLI_AGENTFWD\n\tif (!cli_opts.agent_keys_loaded) {\n\t\t/* get the list of available keys from the agent */\n\t\tcli_load_agent_keys(cli_opts.privkeys);\n\t\tcli_opts.agent_keys_loaded = 1;\n\t\tTRACE((\"cli_auth_pubkey: agent keys loaded\"))\n\t}\n#endif\n\n\t/* iterate through privkeys to remove ones not allowed in server-sig-algs */\n \twhile (cli_opts.privkeys->first) {\n\t\tsign_key * key = (sign_key*)cli_opts.privkeys->first->item;\n\t\tif (cli_ses.server_sig_algs) {\n#if DROPBEAR_RSA\n\t\t\tif (key->type == DROPBEAR_SIGNKEY_RSA) {\n#if DROPBEAR_RSA_SHA256\n\t\t\t\tif (buf_has_algo(cli_ses.server_sig_algs, SSH_SIGNATURE_RSA_SHA256) \n\t\t\t\t\t\t== DROPBEAR_SUCCESS) {\n\t\t\t\t\tsigtype = DROPBEAR_SIGNATURE_RSA_SHA256;\n\t\t\t\t\tTRACE((\"server-sig-algs allows rsa sha256\"))\n\t\t\t\t\tbreak;\n\t\t\t\t}\n#endif /* DROPBEAR_RSA_SHA256 */\n#if DROPBEAR_RSA_SHA1\n\t\t\t\tif (buf_has_algo(cli_ses.server_sig_algs, SSH_SIGNKEY_RSA)\n\t\t\t\t\t\t== DROPBEAR_SUCCESS) {\n\t\t\t\t\tsigtype = DROPBEAR_SIGNATURE_RSA_SHA1;\n\t\t\t\t\tTRACE((\"server-sig-algs allows rsa sha1\"))\n\t\t\t\t\tbreak;\n\t\t\t\t}\n#endif /* DROPBEAR_RSA_SHA256 */\n\t\t\t} else\n#endif /* DROPBEAR_RSA */\n\t\t\t{\n\t\t\t\t/* Not RSA */\n\t\t\t\tconst char *name = NULL;\n\t\t\t\tsigtype = signature_type_from_signkey(key->type);\n\t\t\t\tname = signature_name_from_type(sigtype, NULL);\n\t\t\t\tif (buf_has_algo(cli_ses.server_sig_algs, name)\n\t\t\t\t\t\t== DROPBEAR_SUCCESS) {\n\t\t\t\t\tTRACE((\"server-sig-algs allows %s\", name))\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* No match, skip this key */\n\t\t\tTRACE((\"server-sig-algs no match keytype %d, skipping\", key->type))\n\t\t\tkey = list_remove(cli_opts.privkeys->first);\n\t\t\tsign_key_free(key); \n\t\t\tcontinue;\n\t\t} else {\n\t\t\t/* Server didn't provide a server-sig-algs list, we'll \n\t\t\t   assume all except rsa-sha256 are OK. */\n#if DROPBEAR_RSA\n\t\t\tif (key->type == DROPBEAR_SIGNKEY_RSA) {\n#if DROPBEAR_RSA_SHA1\n\t\t\t\tsigtype = DROPBEAR_SIGNATURE_RSA_SHA1;\n\t\t\t\tTRACE((\"no server-sig-algs, using rsa sha1\"))\n\t\t\t\tbreak;\n#else\n\t\t\t\t/* only support rsa-sha256, skip this key */\n\t\t\t\tTRACE((\"no server-sig-algs, skipping rsa sha256\"))\n\t\t\t\tkey = list_remove(cli_opts.privkeys->first);\n\t\t\t\tsign_key_free(key); \n\t\t\t\tcontinue;\n#endif\n\t\t\t} /* key->type == DROPBEAR_SIGNKEY_RSA */\n#endif /* DROPBEAR_RSA */\n\t\t\tsigtype = signature_type_from_signkey(key->type);\n\t\t\tTRACE((\"no server-sig-algs, using key\"))\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (cli_opts.privkeys->first) {\n\t\tsign_key * key = (sign_key*)cli_opts.privkeys->first->item;\n\t\t/* Send a trial request */\n\t\tsend_msg_userauth_pubkey(key, sigtype, 0);\n\t\tcli_ses.lastprivkey = key;\n\t\tTRACE((\"leave cli_auth_pubkey-success\"))\n\t\treturn 1;\n\t} else {\n\t\t/* no more keys left */\n\t\tTRACE((\"leave cli_auth_pubkey-failure\"))\n\t\treturn 0;\n\t}\n}",
        "func": "int cli_auth_pubkey() {\n\tenum signature_type sigtype = DROPBEAR_SIGNATURE_NONE;\n\tTRACE((\"enter cli_auth_pubkey\"))\n\n#if DROPBEAR_CLI_AGENTFWD\n\tif (!cli_opts.agent_keys_loaded) {\n\t\t/* get the list of available keys from the agent */\n\t\tcli_load_agent_keys(cli_opts.privkeys);\n\t\tcli_opts.agent_keys_loaded = 1;\n\t\tTRACE((\"cli_auth_pubkey: agent keys loaded\"))\n\t}\n#endif\n\n\t/* iterate through privkeys to remove ones not allowed in server-sig-algs */\n \twhile (cli_opts.privkeys->first) {\n\t\tsign_key * key = (sign_key*)cli_opts.privkeys->first->item;\n\t\tif (cli_ses.server_sig_algs) {\n#if DROPBEAR_RSA\n\t\t\tif (key->type == DROPBEAR_SIGNKEY_RSA) {\n#if DROPBEAR_RSA_SHA256\n\t\t\t\tif (buf_has_algo(cli_ses.server_sig_algs, SSH_SIGNATURE_RSA_SHA256) \n\t\t\t\t\t\t== DROPBEAR_SUCCESS) {\n\t\t\t\t\tsigtype = DROPBEAR_SIGNATURE_RSA_SHA256;\n\t\t\t\t\tTRACE((\"server-sig-algs allows rsa sha256\"))\n\t\t\t\t\tbreak;\n\t\t\t\t}\n#endif /* DROPBEAR_RSA_SHA256 */\n#if DROPBEAR_RSA_SHA1\n\t\t\t\tif (buf_has_algo(cli_ses.server_sig_algs, SSH_SIGNKEY_RSA)\n\t\t\t\t\t\t== DROPBEAR_SUCCESS) {\n\t\t\t\t\tsigtype = DROPBEAR_SIGNATURE_RSA_SHA1;\n\t\t\t\t\tTRACE((\"server-sig-algs allows rsa sha1\"))\n\t\t\t\t\tbreak;\n\t\t\t\t}\n#endif /* DROPBEAR_RSA_SHA256 */\n\t\t\t} else\n#endif /* DROPBEAR_RSA */\n\t\t\t{\n\t\t\t\t/* Not RSA */\n\t\t\t\tconst char *name = NULL;\n\t\t\t\tsigtype = signature_type_from_signkey(key->type);\n\t\t\t\tname = signature_name_from_type(sigtype, NULL);\n\t\t\t\tif (buf_has_algo(cli_ses.server_sig_algs, name)\n\t\t\t\t\t\t== DROPBEAR_SUCCESS) {\n\t\t\t\t\tTRACE((\"server-sig-algs allows %s\", name))\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* No match, skip this key */\n\t\t\tTRACE((\"server-sig-algs no match keytype %d, skipping\", key->type))\n\t\t\tkey = list_remove(cli_opts.privkeys->first);\n\t\t\tsign_key_free(key); \n\t\t\tcontinue;\n\t\t} else {\n\t\t\t/* Server didn't provide a server-sig-algs list, we'll \n\t\t\t   assume all except rsa-sha256 are OK. */\n#if DROPBEAR_RSA\n\t\t\tif (key->type == DROPBEAR_SIGNKEY_RSA) {\n#if DROPBEAR_RSA_SHA1\n\t\t\t\tsigtype = DROPBEAR_SIGNATURE_RSA_SHA1;\n\t\t\t\tTRACE((\"no server-sig-algs, using rsa sha1\"))\n\t\t\t\tbreak;\n#else\n\t\t\t\t/* only support rsa-sha256, skip this key */\n\t\t\t\tTRACE((\"no server-sig-algs, skipping rsa sha256\"))\n\t\t\t\tkey = list_remove(cli_opts.privkeys->first);\n\t\t\t\tsign_key_free(key); \n\t\t\t\tcontinue;\n#endif\n\t\t\t} /* key->type == DROPBEAR_SIGNKEY_RSA */\n#endif /* DROPBEAR_RSA */\n\t\t\tsigtype = signature_type_from_signkey(key->type);\n\t\t\tTRACE((\"no server-sig-algs, using key\"))\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (cli_opts.privkeys->first) {\n\t\tsign_key * key = (sign_key*)cli_opts.privkeys->first->item;\n\t\t/* Send a trial request */\n\t\tsend_msg_userauth_pubkey(key, sigtype, 0);\n\t\tcli_ses.lastprivkey = key;\n\t\tcli_ses.is_trivial_auth = 0;\n\t\tTRACE((\"leave cli_auth_pubkey-success\"))\n\t\treturn 1;\n\t} else {\n\t\t/* no more keys left */\n\t\tTRACE((\"leave cli_auth_pubkey-failure\"))\n\t\treturn 0;\n\t}\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -81,6 +81,7 @@\n \t\t/* Send a trial request */\n \t\tsend_msg_userauth_pubkey(key, sigtype, 0);\n \t\tcli_ses.lastprivkey = key;\n+\t\tcli_ses.is_trivial_auth = 0;\n \t\tTRACE((\"leave cli_auth_pubkey-success\"))\n \t\treturn 1;\n \t} else {",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\tcli_ses.is_trivial_auth = 0;"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-36369",
        "func_name": "mkj/dropbear/recv_msg_userauth_success",
        "description": "An issue was discovered in Dropbear through 2020.81. Due to a non-RFC-compliant check of the available authentication methods in the client-side SSH code, it is possible for an SSH server to change the login process in its favor. This attack can bypass additional security measures such as FIDO2 tokens or SSH-Askpass. Thus, it allows an attacker to abuse a forwarded agent for logging on to another server unnoticed.",
        "git_url": "https://github.com/mkj/dropbear/commit/7c2e8fcd0d162d2ba9fac116f96a5e82ac77f11c",
        "commit_title": "added option to disable trivial auth methods",
        "commit_text": "",
        "func_before": "void recv_msg_userauth_success() {\n\t/* This function can validly get called multiple times\n\tif DROPBEAR_CLI_IMMEDIATE_AUTH is set */\n\n\tTRACE((\"received msg_userauth_success\"))\n\t/* Note: in delayed-zlib mode, setting authdone here \n\t * will enable compression in the transport layer */\n\tses.authstate.authdone = 1;\n\tcli_ses.state = USERAUTH_SUCCESS_RCVD;\n\tcli_ses.lastauthtype = AUTH_TYPE_NONE;\n\n#if DROPBEAR_CLI_PUBKEY_AUTH\n\tcli_auth_pubkey_cleanup();\n#endif\n}",
        "func": "void recv_msg_userauth_success() {\n\t/* This function can validly get called multiple times\n\tif DROPBEAR_CLI_IMMEDIATE_AUTH is set */\n\n\tTRACE((\"received msg_userauth_success\"))\n\tif (cli_opts.exit_on_trivial_auth && cli_ses.is_trivial_auth) {\n\t\tdropbear_exit(\"trivial authentication not allowed\");\n\t}\n\t/* Note: in delayed-zlib mode, setting authdone here \n\t * will enable compression in the transport layer */\n\tses.authstate.authdone = 1;\n\tcli_ses.state = USERAUTH_SUCCESS_RCVD;\n\tcli_ses.lastauthtype = AUTH_TYPE_NONE;\n\n#if DROPBEAR_CLI_PUBKEY_AUTH\n\tcli_auth_pubkey_cleanup();\n#endif\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,6 +3,9 @@\n \tif DROPBEAR_CLI_IMMEDIATE_AUTH is set */\n \n \tTRACE((\"received msg_userauth_success\"))\n+\tif (cli_opts.exit_on_trivial_auth && cli_ses.is_trivial_auth) {\n+\t\tdropbear_exit(\"trivial authentication not allowed\");\n+\t}\n \t/* Note: in delayed-zlib mode, setting authdone here \n \t * will enable compression in the transport layer */\n \tses.authstate.authdone = 1;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tif (cli_opts.exit_on_trivial_auth && cli_ses.is_trivial_auth) {",
                "\t\tdropbear_exit(\"trivial authentication not allowed\");",
                "\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-36369",
        "func_name": "mkj/dropbear/add_extendedopt",
        "description": "An issue was discovered in Dropbear through 2020.81. Due to a non-RFC-compliant check of the available authentication methods in the client-side SSH code, it is possible for an SSH server to change the login process in its favor. This attack can bypass additional security measures such as FIDO2 tokens or SSH-Askpass. Thus, it allows an attacker to abuse a forwarded agent for logging on to another server unnoticed.",
        "git_url": "https://github.com/mkj/dropbear/commit/7c2e8fcd0d162d2ba9fac116f96a5e82ac77f11c",
        "commit_title": "added option to disable trivial auth methods",
        "commit_text": "",
        "func_before": "static void add_extendedopt(const char* origstr) {\n\tconst char *optstr = origstr;\n\n\tif (strcmp(origstr, \"help\") == 0) {\n\t\tdropbear_log(LOG_INFO, \"Available options:\\n\"\n#if DROPBEAR_CLI_ANYTCPFWD\n\t\t\t\"\\tExitOnForwardFailure\\n\"\n#endif\n#ifndef DISABLE_SYSLOG\n\t\t\t\"\\tUseSyslog\\n\"\n#endif\n\t\t\t\"\\tPort\\n\"\n\t\t);\n\t\texit(EXIT_SUCCESS);\n\t}\n\n#if DROPBEAR_CLI_ANYTCPFWD\n\tif (match_extendedopt(&optstr, \"ExitOnForwardFailure\") == DROPBEAR_SUCCESS) {\n\t\tcli_opts.exit_on_fwd_failure = parse_flag_value(optstr);\n\t\treturn;\n\t}\n#endif\n\n#ifndef DISABLE_SYSLOG\n\tif (match_extendedopt(&optstr, \"UseSyslog\") == DROPBEAR_SUCCESS) {\n\t\topts.usingsyslog = parse_flag_value(optstr);\n\t\treturn;\n\t}\n#endif\n\n\tif (match_extendedopt(&optstr, \"Port\") == DROPBEAR_SUCCESS) {\n\t\tcli_opts.remoteport = optstr;\n\t\treturn;\n\t}\n\n\tdropbear_log(LOG_WARNING, \"Ignoring unknown configuration option '%s'\", origstr);\n}",
        "func": "static void add_extendedopt(const char* origstr) {\n\tconst char *optstr = origstr;\n\n\tif (strcmp(origstr, \"help\") == 0) {\n\t\tdropbear_log(LOG_INFO, \"Available options:\\n\"\n#if DROPBEAR_CLI_ANYTCPFWD\n\t\t\t\"\\tExitOnForwardFailure\\n\"\n#endif\n\t\t\t\"\\tExitOnTrivialAuth\\n\"\n#ifndef DISABLE_SYSLOG\n\t\t\t\"\\tUseSyslog\\n\"\n#endif\n\t\t\t\"\\tPort\\n\"\n\t\t);\n\t\texit(EXIT_SUCCESS);\n\t}\n\n#if DROPBEAR_CLI_ANYTCPFWD\n\tif (match_extendedopt(&optstr, \"ExitOnForwardFailure\") == DROPBEAR_SUCCESS) {\n\t\tcli_opts.exit_on_fwd_failure = parse_flag_value(optstr);\n\t\treturn;\n\t}\n#endif\n\n#ifndef DISABLE_SYSLOG\n\tif (match_extendedopt(&optstr, \"UseSyslog\") == DROPBEAR_SUCCESS) {\n\t\topts.usingsyslog = parse_flag_value(optstr);\n\t\treturn;\n\t}\n#endif\n\n\tif (match_extendedopt(&optstr, \"Port\") == DROPBEAR_SUCCESS) {\n\t\tcli_opts.remoteport = optstr;\n\t\treturn;\n\t}\n\n\tif (match_extendedopt(&optstr, \"ExitOnTrivialAuth\") == DROPBEAR_SUCCESS) {\n\t\tcli_opts.exit_on_trivial_auth = parse_flag_value(optstr);\n\t\treturn;\n\t}\n\n\tdropbear_log(LOG_WARNING, \"Ignoring unknown configuration option '%s'\", origstr);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,6 +6,7 @@\n #if DROPBEAR_CLI_ANYTCPFWD\n \t\t\t\"\\tExitOnForwardFailure\\n\"\n #endif\n+\t\t\t\"\\tExitOnTrivialAuth\\n\"\n #ifndef DISABLE_SYSLOG\n \t\t\t\"\\tUseSyslog\\n\"\n #endif\n@@ -33,5 +34,10 @@\n \t\treturn;\n \t}\n \n+\tif (match_extendedopt(&optstr, \"ExitOnTrivialAuth\") == DROPBEAR_SUCCESS) {\n+\t\tcli_opts.exit_on_trivial_auth = parse_flag_value(optstr);\n+\t\treturn;\n+\t}\n+\n \tdropbear_log(LOG_WARNING, \"Ignoring unknown configuration option '%s'\", origstr);\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\t\t\"\\tExitOnTrivialAuth\\n\"",
                "\tif (match_extendedopt(&optstr, \"ExitOnTrivialAuth\") == DROPBEAR_SUCCESS) {",
                "\t\tcli_opts.exit_on_trivial_auth = parse_flag_value(optstr);",
                "\t\treturn;",
                "\t}",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2021-36369",
        "func_name": "mkj/dropbear/cli_getopts",
        "description": "An issue was discovered in Dropbear through 2020.81. Due to a non-RFC-compliant check of the available authentication methods in the client-side SSH code, it is possible for an SSH server to change the login process in its favor. This attack can bypass additional security measures such as FIDO2 tokens or SSH-Askpass. Thus, it allows an attacker to abuse a forwarded agent for logging on to another server unnoticed.",
        "git_url": "https://github.com/mkj/dropbear/commit/7c2e8fcd0d162d2ba9fac116f96a5e82ac77f11c",
        "commit_title": "added option to disable trivial auth methods",
        "commit_text": "",
        "func_before": "void cli_getopts(int argc, char ** argv) {\n\tunsigned int i, j;\n\tchar ** next = NULL;\n\tenum {\n\t\tOPT_EXTENDED_OPTIONS,\n#if DROPBEAR_CLI_PUBKEY_AUTH\n\t\tOPT_AUTHKEY,\n#endif\n#if DROPBEAR_CLI_LOCALTCPFWD\n\t\tOPT_LOCALTCPFWD,\n#endif\n#if DROPBEAR_CLI_REMOTETCPFWD\n\t\tOPT_REMOTETCPFWD,\n#endif\n#if DROPBEAR_CLI_NETCAT\n\t\tOPT_NETCAT,\n#endif\n\t\t/* a flag (no arg) if 'next' is NULL, a string-valued option otherwise */\n\t\tOPT_OTHER\n\t} opt;\n\tunsigned int cmdlen;\n\n\tchar* recv_window_arg = NULL;\n\tchar* keepalive_arg = NULL;\n\tchar* idle_timeout_arg = NULL;\n\tchar *host_arg = NULL;\n\tchar *bind_arg = NULL;\n\tchar c;\n\n\t/* see printhelp() for options */\n\tcli_opts.progname = argv[0];\n\tcli_opts.remotehost = NULL;\n\tcli_opts.remoteport = NULL;\n\tcli_opts.username = NULL;\n\tcli_opts.cmd = NULL;\n\tcli_opts.no_cmd = 0;\n\tcli_opts.backgrounded = 0;\n\tcli_opts.wantpty = 9; /* 9 means \"it hasn't been touched\", gets set later */\n\tcli_opts.always_accept_key = 0;\n\tcli_opts.no_hostkey_check = 0;\n\tcli_opts.is_subsystem = 0;\n#if DROPBEAR_CLI_PUBKEY_AUTH\n\tcli_opts.privkeys = list_new();\n#endif\n#if DROPBEAR_CLI_ANYTCPFWD\n\tcli_opts.exit_on_fwd_failure = 0;\n#endif\n#if DROPBEAR_CLI_LOCALTCPFWD\n\tcli_opts.localfwds = list_new();\n\topts.listen_fwd_all = 0;\n#endif\n#if DROPBEAR_CLI_REMOTETCPFWD\n\tcli_opts.remotefwds = list_new();\n#endif\n#if DROPBEAR_CLI_AGENTFWD\n\tcli_opts.agent_fwd = 0;\n\tcli_opts.agent_fd = -1;\n\tcli_opts.agent_keys_loaded = 0;\n#endif\n#if DROPBEAR_CLI_PROXYCMD\n\tcli_opts.proxycmd = NULL;\n#endif\n\tcli_opts.bind_address = NULL;\n\tcli_opts.bind_port = NULL;\n#ifndef DISABLE_ZLIB\n\topts.compress_mode = DROPBEAR_COMPRESS_ON;\n#endif\n#if DROPBEAR_USER_ALGO_LIST\n\topts.cipher_list = NULL;\n\topts.mac_list = NULL;\n#endif\n#ifndef DISABLE_SYSLOG\n\topts.usingsyslog = 0;\n#endif\n\t/* not yet\n\topts.ipv4 = 1;\n\topts.ipv6 = 1;\n\t*/\n\topts.recv_window = DEFAULT_RECV_WINDOW;\n\topts.keepalive_secs = DEFAULT_KEEPALIVE;\n\topts.idle_timeout_secs = DEFAULT_IDLE_TIMEOUT;\n\n\tfill_own_user();\n\n\tfor (i = 1; i < (unsigned int)argc; i++) {\n\t\t/* Handle non-flag arguments such as hostname or commands for the remote host */\n\t\tif (argv[i][0] != '-')\n\t\t{\n\t\t\tif (host_arg == NULL) {\n\t\t\t\thost_arg = argv[i];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* Commands to pass to the remote host. No more flag handling,\n\t\t\tcommands are consumed below */\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Begins with '-' */\n\t\topt = OPT_OTHER;\n\t\tfor (j = 1; (c = argv[i][j]) != '\\0' && !next && opt == OPT_OTHER; j++) {\n\t\t\tswitch (c) {\n\t\t\t\tcase 'y': /* always accept the remote hostkey */\n\t\t\t\t\tif (cli_opts.always_accept_key) {\n\t\t\t\t\t\t/* twice means no checking at all */\n\t\t\t\t\t\tcli_opts.no_hostkey_check = 1;\n\t\t\t\t\t}\n\t\t\t\t\tcli_opts.always_accept_key = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'p': /* remoteport */\n\t\t\t\t\tnext = (char**)&cli_opts.remoteport;\n\t\t\t\t\tbreak;\n#if DROPBEAR_CLI_PUBKEY_AUTH\n\t\t\t\tcase 'i': /* an identityfile */\n\t\t\t\t\topt = OPT_AUTHKEY;\n\t\t\t\t\tbreak;\n#endif\n\t\t\t\tcase 't': /* we want a pty */\n\t\t\t\t\tcli_opts.wantpty = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'T': /* don't want a pty */\n\t\t\t\t\tcli_opts.wantpty = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'N':\n\t\t\t\t\tcli_opts.no_cmd = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'f':\n\t\t\t\t\tcli_opts.backgrounded = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 's':\n\t\t\t\t\tcli_opts.is_subsystem = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'o':\n\t\t\t\t\topt = OPT_EXTENDED_OPTIONS;\n\t\t\t\t\tbreak;\n#if DROPBEAR_CLI_LOCALTCPFWD\n\t\t\t\tcase 'L':\n\t\t\t\t\topt = OPT_LOCALTCPFWD;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'g':\n\t\t\t\t\topts.listen_fwd_all = 1;\n\t\t\t\t\tbreak;\n#endif\n#if DROPBEAR_CLI_REMOTETCPFWD\n\t\t\t\tcase 'R':\n\t\t\t\t\topt = OPT_REMOTETCPFWD;\n\t\t\t\t\tbreak;\n#endif\n#if DROPBEAR_CLI_NETCAT\n\t\t\t\tcase 'B':\n\t\t\t\t\topt = OPT_NETCAT;\n\t\t\t\t\tbreak;\n#endif\n#if DROPBEAR_CLI_PROXYCMD\n\t\t\t\tcase 'J':\n\t\t\t\t\tnext = &cli_opts.proxycmd;\n\t\t\t\t\tbreak;\n#endif\n\t\t\t\tcase 'l':\n\t\t\t\t\tnext = &cli_opts.username;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'h':\n\t\t\t\t\tprinthelp();\n\t\t\t\t\texit(EXIT_SUCCESS);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'u':\n\t\t\t\t\t/* backwards compatibility with old urandom option */\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'W':\n\t\t\t\t\tnext = &recv_window_arg;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'K':\n\t\t\t\t\tnext = &keepalive_arg;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'I':\n\t\t\t\t\tnext = &idle_timeout_arg;\n\t\t\t\t\tbreak;\n#if DROPBEAR_CLI_AGENTFWD\n\t\t\t\tcase 'A':\n\t\t\t\t\tcli_opts.agent_fwd = 1;\n\t\t\t\t\tbreak;\n#endif\n#if DROPBEAR_USER_ALGO_LIST\n\t\t\t\tcase 'c':\n\t\t\t\t\tnext = &opts.cipher_list;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'm':\n\t\t\t\t\tnext = &opts.mac_list;\n\t\t\t\t\tbreak;\n#endif\n#if DEBUG_TRACE\n\t\t\t\tcase 'v':\n\t\t\t\t\tdebug_trace = 1;\n\t\t\t\t\tbreak;\n#endif\n\t\t\t\tcase 'F':\n\t\t\t\tcase 'e':\n#if !DROPBEAR_USER_ALGO_LIST\n\t\t\t\tcase 'c':\n\t\t\t\tcase 'm':\n#endif\n\t\t\t\tcase 'D':\n#if !DROPBEAR_CLI_REMOTETCPFWD\n\t\t\t\tcase 'R':\n#endif\n#if !DROPBEAR_CLI_LOCALTCPFWD\n\t\t\t\tcase 'L':\n#endif\n\t\t\t\tcase 'V':\n\t\t\t\t\tprint_version();\n\t\t\t\t\texit(EXIT_SUCCESS);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'b':\n\t\t\t\t\tnext = &bind_arg;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\t\"WARNING: Ignoring unknown option -%c\\n\", c);\n\t\t\t\t\tbreak;\n\t\t\t} /* Switch */\n\t\t}\n\n\t\tif (!next && opt == OPT_OTHER) /* got a flag */\n\t\t\tcontinue;\n\n\t\tif (c == '\\0') {\n\t\t\ti++;\n\t\t\tj = 0;\n\t\t\tif (!argv[i])\n\t\t\t\tdropbear_exit(\"Missing argument\");\n\t\t}\n\n\t\tif (opt == OPT_EXTENDED_OPTIONS) {\n\t\t\tTRACE((\"opt extended\"))\n\t\t\tadd_extendedopt(&argv[i][j]);\n\t\t}\n\t\telse\n#if DROPBEAR_CLI_PUBKEY_AUTH\n\t\tif (opt == OPT_AUTHKEY) {\n\t\t\tTRACE((\"opt authkey\"))\n\t\t\tloadidentityfile(&argv[i][j], 1);\n\t\t}\n\t\telse\n#endif\n#if DROPBEAR_CLI_REMOTETCPFWD\n\t\tif (opt == OPT_REMOTETCPFWD) {\n\t\t\tTRACE((\"opt remotetcpfwd\"))\n\t\t\taddforward(&argv[i][j], cli_opts.remotefwds);\n\t\t}\n\t\telse\n#endif\n#if DROPBEAR_CLI_LOCALTCPFWD\n\t\tif (opt == OPT_LOCALTCPFWD) {\n\t\t\tTRACE((\"opt localtcpfwd\"))\n\t\t\taddforward(&argv[i][j], cli_opts.localfwds);\n\t\t}\n\t\telse\n#endif\n#if DROPBEAR_CLI_NETCAT\n\t\tif (opt == OPT_NETCAT) {\n\t\t\tTRACE((\"opt netcat\"))\n\t\t\tadd_netcat(&argv[i][j]);\n\t\t}\n\t\telse\n#endif\n\t\tif (next) {\n\t\t\t/* The previous flag set a value to assign */\n\t\t\t*next = &argv[i][j];\n\t\t\tif (*next == NULL)\n\t\t\t\tdropbear_exit(\"Invalid null argument\");\n\t\t\tnext = NULL;\n\t\t}\n\t}\n\n#if DROPBEAR_USER_ALGO_LIST\n\t/* -c help doesn't need a hostname */\n\tparse_ciphers_macs();\n#endif\n\n\t/* Done with options/flags; now handle the hostname (which may not\n\t * start with a hyphen) and optional command */\n\n\tif (host_arg == NULL) { /* missing hostname */\n\t\tprinthelp();\n\t\texit(EXIT_FAILURE);\n\t}\n\tTRACE((\"host is: %s\", host_arg))\n\n\tif (i < (unsigned int)argc) {\n\t\t/* Build the command to send */\n\t\tcmdlen = 0;\n\t\tfor (j = i; j < (unsigned int)argc; j++)\n\t\t\tcmdlen += strlen(argv[j]) + 1; /* +1 for spaces */\n\n\t\t/* Allocate the space */\n\t\tcli_opts.cmd = (char*)m_malloc(cmdlen);\n\t\tcli_opts.cmd[0] = '\\0';\n\n\t\t/* Append all the bits */\n\t\tfor (j = i; j < (unsigned int)argc; j++) {\n\t\t\tstrlcat(cli_opts.cmd, argv[j], cmdlen);\n\t\t\tstrlcat(cli_opts.cmd, \" \", cmdlen);\n\t\t}\n\t\t/* It'll be null-terminated here */\n\t\tTRACE((\"cmd is: %s\", cli_opts.cmd))\n\t}\n\n\t/* And now a few sanity checks and setup */\n\n#if DROPBEAR_CLI_PROXYCMD                                                                                                                                   \n\tif (cli_opts.proxycmd) {\n\t\t/* To match the common path of m_freeing it */\n\t\tcli_opts.proxycmd = m_strdup(cli_opts.proxycmd);\n\t}\n#endif\n\n\tif (cli_opts.remoteport == NULL) {\n\t\tcli_opts.remoteport = \"22\";\n\t}\n\n\tif (bind_arg) {\n\t\t/* split [host][:port] */\n\t\tchar *port = strrchr(bind_arg, ':');\n\t\tif (port) {\n\t\t\tcli_opts.bind_port = m_strdup(port+1);\n\t\t\t*port = '\\0';\n\t\t}\n\t\tif (strlen(bind_arg) > 0) {\n\t\t\tcli_opts.bind_address = m_strdup(bind_arg);\n\t\t}\n\t}\n\n\t/* If not explicitly specified with -t or -T, we don't want a pty if\n\t * there's a command, but we do otherwise */\n\tif (cli_opts.wantpty == 9) {\n\t\tif (cli_opts.cmd == NULL) {\n\t\t\tcli_opts.wantpty = 1;\n\t\t} else {\n\t\t\tcli_opts.wantpty = 0;\n\t\t}\n\t}\n\n\tif (cli_opts.backgrounded && cli_opts.cmd == NULL\n\t\t\t&& cli_opts.no_cmd == 0) {\n\t\tdropbear_exit(\"Command required for -f\");\n\t}\n\t\n\tif (recv_window_arg) {\n\t\topts.recv_window = atol(recv_window_arg);\n\t\tif (opts.recv_window == 0 || opts.recv_window > MAX_RECV_WINDOW) {\n\t\t\tdropbear_exit(\"Bad recv window '%s'\", recv_window_arg);\n\t\t}\n\t}\n\tif (keepalive_arg) {\n\t\tunsigned int val;\n\t\tif (m_str_to_uint(keepalive_arg, &val) == DROPBEAR_FAILURE) {\n\t\t\tdropbear_exit(\"Bad keepalive '%s'\", keepalive_arg);\n\t\t}\n\t\topts.keepalive_secs = val;\n\t}\n\n\tif (idle_timeout_arg) {\n\t\tunsigned int val;\n\t\tif (m_str_to_uint(idle_timeout_arg, &val) == DROPBEAR_FAILURE) {\n\t\t\tdropbear_exit(\"Bad idle_timeout '%s'\", idle_timeout_arg);\n\t\t}\n\t\topts.idle_timeout_secs = val;\n\t}\n\n#if DROPBEAR_CLI_NETCAT\n\tif (cli_opts.cmd && cli_opts.netcat_host) {\n\t\tdropbear_log(LOG_INFO, \"Ignoring command '%s' in netcat mode\", cli_opts.cmd);\n\t}\n#endif\n\n#if (DROPBEAR_CLI_PUBKEY_AUTH)\n\t{\n\t\tchar *expand_path = expand_homedir_path(DROPBEAR_DEFAULT_CLI_AUTHKEY);\n\t\tloadidentityfile(expand_path, 0);\n\t\tm_free(expand_path);\n\t}\n#endif\n\n\t/* The hostname gets set up last, since\n\t * in multi-hop mode it will require knowledge\n\t * of other flags such as -i */\n#if DROPBEAR_CLI_MULTIHOP\n\tparse_multihop_hostname(host_arg, argv[0]);\n#else\n\tparse_hostname(host_arg);\n#endif\n}",
        "func": "void cli_getopts(int argc, char ** argv) {\n\tunsigned int i, j;\n\tchar ** next = NULL;\n\tenum {\n\t\tOPT_EXTENDED_OPTIONS,\n#if DROPBEAR_CLI_PUBKEY_AUTH\n\t\tOPT_AUTHKEY,\n#endif\n#if DROPBEAR_CLI_LOCALTCPFWD\n\t\tOPT_LOCALTCPFWD,\n#endif\n#if DROPBEAR_CLI_REMOTETCPFWD\n\t\tOPT_REMOTETCPFWD,\n#endif\n#if DROPBEAR_CLI_NETCAT\n\t\tOPT_NETCAT,\n#endif\n\t\t/* a flag (no arg) if 'next' is NULL, a string-valued option otherwise */\n\t\tOPT_OTHER\n\t} opt;\n\tunsigned int cmdlen;\n\n\tchar* recv_window_arg = NULL;\n\tchar* keepalive_arg = NULL;\n\tchar* idle_timeout_arg = NULL;\n\tchar *host_arg = NULL;\n\tchar *bind_arg = NULL;\n\tchar c;\n\n\t/* see printhelp() for options */\n\tcli_opts.progname = argv[0];\n\tcli_opts.remotehost = NULL;\n\tcli_opts.remoteport = NULL;\n\tcli_opts.username = NULL;\n\tcli_opts.cmd = NULL;\n\tcli_opts.no_cmd = 0;\n\tcli_opts.backgrounded = 0;\n\tcli_opts.wantpty = 9; /* 9 means \"it hasn't been touched\", gets set later */\n\tcli_opts.always_accept_key = 0;\n\tcli_opts.no_hostkey_check = 0;\n\tcli_opts.is_subsystem = 0;\n#if DROPBEAR_CLI_PUBKEY_AUTH\n\tcli_opts.privkeys = list_new();\n#endif\n#if DROPBEAR_CLI_ANYTCPFWD\n\tcli_opts.exit_on_fwd_failure = 0;\n#endif\n\tcli_opts.exit_on_trivial_auth = 0;\n#if DROPBEAR_CLI_LOCALTCPFWD\n\tcli_opts.localfwds = list_new();\n\topts.listen_fwd_all = 0;\n#endif\n#if DROPBEAR_CLI_REMOTETCPFWD\n\tcli_opts.remotefwds = list_new();\n#endif\n#if DROPBEAR_CLI_AGENTFWD\n\tcli_opts.agent_fwd = 0;\n\tcli_opts.agent_fd = -1;\n\tcli_opts.agent_keys_loaded = 0;\n#endif\n#if DROPBEAR_CLI_PROXYCMD\n\tcli_opts.proxycmd = NULL;\n#endif\n\tcli_opts.bind_address = NULL;\n\tcli_opts.bind_port = NULL;\n#ifndef DISABLE_ZLIB\n\topts.compress_mode = DROPBEAR_COMPRESS_ON;\n#endif\n#if DROPBEAR_USER_ALGO_LIST\n\topts.cipher_list = NULL;\n\topts.mac_list = NULL;\n#endif\n#ifndef DISABLE_SYSLOG\n\topts.usingsyslog = 0;\n#endif\n\t/* not yet\n\topts.ipv4 = 1;\n\topts.ipv6 = 1;\n\t*/\n\topts.recv_window = DEFAULT_RECV_WINDOW;\n\topts.keepalive_secs = DEFAULT_KEEPALIVE;\n\topts.idle_timeout_secs = DEFAULT_IDLE_TIMEOUT;\n\n\tfill_own_user();\n\n\tfor (i = 1; i < (unsigned int)argc; i++) {\n\t\t/* Handle non-flag arguments such as hostname or commands for the remote host */\n\t\tif (argv[i][0] != '-')\n\t\t{\n\t\t\tif (host_arg == NULL) {\n\t\t\t\thost_arg = argv[i];\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* Commands to pass to the remote host. No more flag handling,\n\t\t\tcommands are consumed below */\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Begins with '-' */\n\t\topt = OPT_OTHER;\n\t\tfor (j = 1; (c = argv[i][j]) != '\\0' && !next && opt == OPT_OTHER; j++) {\n\t\t\tswitch (c) {\n\t\t\t\tcase 'y': /* always accept the remote hostkey */\n\t\t\t\t\tif (cli_opts.always_accept_key) {\n\t\t\t\t\t\t/* twice means no checking at all */\n\t\t\t\t\t\tcli_opts.no_hostkey_check = 1;\n\t\t\t\t\t}\n\t\t\t\t\tcli_opts.always_accept_key = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'p': /* remoteport */\n\t\t\t\t\tnext = (char**)&cli_opts.remoteport;\n\t\t\t\t\tbreak;\n#if DROPBEAR_CLI_PUBKEY_AUTH\n\t\t\t\tcase 'i': /* an identityfile */\n\t\t\t\t\topt = OPT_AUTHKEY;\n\t\t\t\t\tbreak;\n#endif\n\t\t\t\tcase 't': /* we want a pty */\n\t\t\t\t\tcli_opts.wantpty = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'T': /* don't want a pty */\n\t\t\t\t\tcli_opts.wantpty = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'N':\n\t\t\t\t\tcli_opts.no_cmd = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'f':\n\t\t\t\t\tcli_opts.backgrounded = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 's':\n\t\t\t\t\tcli_opts.is_subsystem = 1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'o':\n\t\t\t\t\topt = OPT_EXTENDED_OPTIONS;\n\t\t\t\t\tbreak;\n#if DROPBEAR_CLI_LOCALTCPFWD\n\t\t\t\tcase 'L':\n\t\t\t\t\topt = OPT_LOCALTCPFWD;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'g':\n\t\t\t\t\topts.listen_fwd_all = 1;\n\t\t\t\t\tbreak;\n#endif\n#if DROPBEAR_CLI_REMOTETCPFWD\n\t\t\t\tcase 'R':\n\t\t\t\t\topt = OPT_REMOTETCPFWD;\n\t\t\t\t\tbreak;\n#endif\n#if DROPBEAR_CLI_NETCAT\n\t\t\t\tcase 'B':\n\t\t\t\t\topt = OPT_NETCAT;\n\t\t\t\t\tbreak;\n#endif\n#if DROPBEAR_CLI_PROXYCMD\n\t\t\t\tcase 'J':\n\t\t\t\t\tnext = &cli_opts.proxycmd;\n\t\t\t\t\tbreak;\n#endif\n\t\t\t\tcase 'l':\n\t\t\t\t\tnext = &cli_opts.username;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'h':\n\t\t\t\t\tprinthelp();\n\t\t\t\t\texit(EXIT_SUCCESS);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'u':\n\t\t\t\t\t/* backwards compatibility with old urandom option */\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'W':\n\t\t\t\t\tnext = &recv_window_arg;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'K':\n\t\t\t\t\tnext = &keepalive_arg;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'I':\n\t\t\t\t\tnext = &idle_timeout_arg;\n\t\t\t\t\tbreak;\n#if DROPBEAR_CLI_AGENTFWD\n\t\t\t\tcase 'A':\n\t\t\t\t\tcli_opts.agent_fwd = 1;\n\t\t\t\t\tbreak;\n#endif\n#if DROPBEAR_USER_ALGO_LIST\n\t\t\t\tcase 'c':\n\t\t\t\t\tnext = &opts.cipher_list;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'm':\n\t\t\t\t\tnext = &opts.mac_list;\n\t\t\t\t\tbreak;\n#endif\n#if DEBUG_TRACE\n\t\t\t\tcase 'v':\n\t\t\t\t\tdebug_trace = 1;\n\t\t\t\t\tbreak;\n#endif\n\t\t\t\tcase 'F':\n\t\t\t\tcase 'e':\n#if !DROPBEAR_USER_ALGO_LIST\n\t\t\t\tcase 'c':\n\t\t\t\tcase 'm':\n#endif\n\t\t\t\tcase 'D':\n#if !DROPBEAR_CLI_REMOTETCPFWD\n\t\t\t\tcase 'R':\n#endif\n#if !DROPBEAR_CLI_LOCALTCPFWD\n\t\t\t\tcase 'L':\n#endif\n\t\t\t\tcase 'V':\n\t\t\t\t\tprint_version();\n\t\t\t\t\texit(EXIT_SUCCESS);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'b':\n\t\t\t\t\tnext = &bind_arg;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tfprintf(stderr,\n\t\t\t\t\t\t\"WARNING: Ignoring unknown option -%c\\n\", c);\n\t\t\t\t\tbreak;\n\t\t\t} /* Switch */\n\t\t}\n\n\t\tif (!next && opt == OPT_OTHER) /* got a flag */\n\t\t\tcontinue;\n\n\t\tif (c == '\\0') {\n\t\t\ti++;\n\t\t\tj = 0;\n\t\t\tif (!argv[i])\n\t\t\t\tdropbear_exit(\"Missing argument\");\n\t\t}\n\n\t\tif (opt == OPT_EXTENDED_OPTIONS) {\n\t\t\tTRACE((\"opt extended\"))\n\t\t\tadd_extendedopt(&argv[i][j]);\n\t\t}\n\t\telse\n#if DROPBEAR_CLI_PUBKEY_AUTH\n\t\tif (opt == OPT_AUTHKEY) {\n\t\t\tTRACE((\"opt authkey\"))\n\t\t\tloadidentityfile(&argv[i][j], 1);\n\t\t}\n\t\telse\n#endif\n#if DROPBEAR_CLI_REMOTETCPFWD\n\t\tif (opt == OPT_REMOTETCPFWD) {\n\t\t\tTRACE((\"opt remotetcpfwd\"))\n\t\t\taddforward(&argv[i][j], cli_opts.remotefwds);\n\t\t}\n\t\telse\n#endif\n#if DROPBEAR_CLI_LOCALTCPFWD\n\t\tif (opt == OPT_LOCALTCPFWD) {\n\t\t\tTRACE((\"opt localtcpfwd\"))\n\t\t\taddforward(&argv[i][j], cli_opts.localfwds);\n\t\t}\n\t\telse\n#endif\n#if DROPBEAR_CLI_NETCAT\n\t\tif (opt == OPT_NETCAT) {\n\t\t\tTRACE((\"opt netcat\"))\n\t\t\tadd_netcat(&argv[i][j]);\n\t\t}\n\t\telse\n#endif\n\t\tif (next) {\n\t\t\t/* The previous flag set a value to assign */\n\t\t\t*next = &argv[i][j];\n\t\t\tif (*next == NULL)\n\t\t\t\tdropbear_exit(\"Invalid null argument\");\n\t\t\tnext = NULL;\n\t\t}\n\t}\n\n#if DROPBEAR_USER_ALGO_LIST\n\t/* -c help doesn't need a hostname */\n\tparse_ciphers_macs();\n#endif\n\n\t/* Done with options/flags; now handle the hostname (which may not\n\t * start with a hyphen) and optional command */\n\n\tif (host_arg == NULL) { /* missing hostname */\n\t\tprinthelp();\n\t\texit(EXIT_FAILURE);\n\t}\n\tTRACE((\"host is: %s\", host_arg))\n\n\tif (i < (unsigned int)argc) {\n\t\t/* Build the command to send */\n\t\tcmdlen = 0;\n\t\tfor (j = i; j < (unsigned int)argc; j++)\n\t\t\tcmdlen += strlen(argv[j]) + 1; /* +1 for spaces */\n\n\t\t/* Allocate the space */\n\t\tcli_opts.cmd = (char*)m_malloc(cmdlen);\n\t\tcli_opts.cmd[0] = '\\0';\n\n\t\t/* Append all the bits */\n\t\tfor (j = i; j < (unsigned int)argc; j++) {\n\t\t\tstrlcat(cli_opts.cmd, argv[j], cmdlen);\n\t\t\tstrlcat(cli_opts.cmd, \" \", cmdlen);\n\t\t}\n\t\t/* It'll be null-terminated here */\n\t\tTRACE((\"cmd is: %s\", cli_opts.cmd))\n\t}\n\n\t/* And now a few sanity checks and setup */\n\n#if DROPBEAR_CLI_PROXYCMD                                                                                                                                   \n\tif (cli_opts.proxycmd) {\n\t\t/* To match the common path of m_freeing it */\n\t\tcli_opts.proxycmd = m_strdup(cli_opts.proxycmd);\n\t}\n#endif\n\n\tif (cli_opts.remoteport == NULL) {\n\t\tcli_opts.remoteport = \"22\";\n\t}\n\n\tif (bind_arg) {\n\t\t/* split [host][:port] */\n\t\tchar *port = strrchr(bind_arg, ':');\n\t\tif (port) {\n\t\t\tcli_opts.bind_port = m_strdup(port+1);\n\t\t\t*port = '\\0';\n\t\t}\n\t\tif (strlen(bind_arg) > 0) {\n\t\t\tcli_opts.bind_address = m_strdup(bind_arg);\n\t\t}\n\t}\n\n\t/* If not explicitly specified with -t or -T, we don't want a pty if\n\t * there's a command, but we do otherwise */\n\tif (cli_opts.wantpty == 9) {\n\t\tif (cli_opts.cmd == NULL) {\n\t\t\tcli_opts.wantpty = 1;\n\t\t} else {\n\t\t\tcli_opts.wantpty = 0;\n\t\t}\n\t}\n\n\tif (cli_opts.backgrounded && cli_opts.cmd == NULL\n\t\t\t&& cli_opts.no_cmd == 0) {\n\t\tdropbear_exit(\"Command required for -f\");\n\t}\n\t\n\tif (recv_window_arg) {\n\t\topts.recv_window = atol(recv_window_arg);\n\t\tif (opts.recv_window == 0 || opts.recv_window > MAX_RECV_WINDOW) {\n\t\t\tdropbear_exit(\"Bad recv window '%s'\", recv_window_arg);\n\t\t}\n\t}\n\tif (keepalive_arg) {\n\t\tunsigned int val;\n\t\tif (m_str_to_uint(keepalive_arg, &val) == DROPBEAR_FAILURE) {\n\t\t\tdropbear_exit(\"Bad keepalive '%s'\", keepalive_arg);\n\t\t}\n\t\topts.keepalive_secs = val;\n\t}\n\n\tif (idle_timeout_arg) {\n\t\tunsigned int val;\n\t\tif (m_str_to_uint(idle_timeout_arg, &val) == DROPBEAR_FAILURE) {\n\t\t\tdropbear_exit(\"Bad idle_timeout '%s'\", idle_timeout_arg);\n\t\t}\n\t\topts.idle_timeout_secs = val;\n\t}\n\n#if DROPBEAR_CLI_NETCAT\n\tif (cli_opts.cmd && cli_opts.netcat_host) {\n\t\tdropbear_log(LOG_INFO, \"Ignoring command '%s' in netcat mode\", cli_opts.cmd);\n\t}\n#endif\n\n#if (DROPBEAR_CLI_PUBKEY_AUTH)\n\t{\n\t\tchar *expand_path = expand_homedir_path(DROPBEAR_DEFAULT_CLI_AUTHKEY);\n\t\tloadidentityfile(expand_path, 0);\n\t\tm_free(expand_path);\n\t}\n#endif\n\n\t/* The hostname gets set up last, since\n\t * in multi-hop mode it will require knowledge\n\t * of other flags such as -i */\n#if DROPBEAR_CLI_MULTIHOP\n\tparse_multihop_hostname(host_arg, argv[0]);\n#else\n\tparse_hostname(host_arg);\n#endif\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -45,6 +45,7 @@\n #if DROPBEAR_CLI_ANYTCPFWD\n \tcli_opts.exit_on_fwd_failure = 0;\n #endif\n+\tcli_opts.exit_on_trivial_auth = 0;\n #if DROPBEAR_CLI_LOCALTCPFWD\n \tcli_opts.localfwds = list_new();\n \topts.listen_fwd_all = 0;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tcli_opts.exit_on_trivial_auth = 0;"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-36369",
        "func_name": "mkj/dropbear/cli_auth_password",
        "description": "An issue was discovered in Dropbear through 2020.81. Due to a non-RFC-compliant check of the available authentication methods in the client-side SSH code, it is possible for an SSH server to change the login process in its favor. This attack can bypass additional security measures such as FIDO2 tokens or SSH-Askpass. Thus, it allows an attacker to abuse a forwarded agent for logging on to another server unnoticed.",
        "git_url": "https://github.com/mkj/dropbear/commit/7c2e8fcd0d162d2ba9fac116f96a5e82ac77f11c",
        "commit_title": "added option to disable trivial auth methods",
        "commit_text": "",
        "func_before": "void cli_auth_password() {\n\n\tchar* password = NULL;\n\tchar prompt[80];\n\n\tTRACE((\"enter cli_auth_password\"))\n\tCHECKCLEARTOWRITE();\n\n\tsnprintf(prompt, sizeof(prompt), \"%s@%s's password: \", \n\t\t\t\tcli_opts.username, cli_opts.remotehost);\n#if DROPBEAR_CLI_ASKPASS_HELPER\n\tif (want_askpass())\n\t{\n\t\tpassword = gui_getpass(prompt);\n\t\tif (!password) {\n\t\t\tdropbear_exit(\"No password\");\n\t\t}\n\t} else\n#endif\n\t{\n\t\tpassword = getpass_or_cancel(prompt);\n\t}\n\n\tbuf_putbyte(ses.writepayload, SSH_MSG_USERAUTH_REQUEST);\n\n\tbuf_putstring(ses.writepayload, cli_opts.username,\n\t\t\tstrlen(cli_opts.username));\n\n\tbuf_putstring(ses.writepayload, SSH_SERVICE_CONNECTION,\n\t\t\tSSH_SERVICE_CONNECTION_LEN);\n\n\tbuf_putstring(ses.writepayload, AUTH_METHOD_PASSWORD,\n\t\t\tAUTH_METHOD_PASSWORD_LEN);\n\n\tbuf_putbyte(ses.writepayload, 0); /* FALSE - so says the spec */\n\n\tbuf_putstring(ses.writepayload, password, strlen(password));\n\n\tencrypt_packet();\n\tm_burn(password, strlen(password));\n\n\tTRACE((\"leave cli_auth_password\"))\n}",
        "func": "void cli_auth_password() {\n\n\tchar* password = NULL;\n\tchar prompt[80];\n\n\tTRACE((\"enter cli_auth_password\"))\n\tCHECKCLEARTOWRITE();\n\n\tsnprintf(prompt, sizeof(prompt), \"%s@%s's password: \", \n\t\t\t\tcli_opts.username, cli_opts.remotehost);\n#if DROPBEAR_CLI_ASKPASS_HELPER\n\tif (want_askpass())\n\t{\n\t\tpassword = gui_getpass(prompt);\n\t\tif (!password) {\n\t\t\tdropbear_exit(\"No password\");\n\t\t}\n\t} else\n#endif\n\t{\n\t\tpassword = getpass_or_cancel(prompt);\n\t}\n\n\tbuf_putbyte(ses.writepayload, SSH_MSG_USERAUTH_REQUEST);\n\n\tbuf_putstring(ses.writepayload, cli_opts.username,\n\t\t\tstrlen(cli_opts.username));\n\n\tbuf_putstring(ses.writepayload, SSH_SERVICE_CONNECTION,\n\t\t\tSSH_SERVICE_CONNECTION_LEN);\n\n\tbuf_putstring(ses.writepayload, AUTH_METHOD_PASSWORD,\n\t\t\tAUTH_METHOD_PASSWORD_LEN);\n\n\tbuf_putbyte(ses.writepayload, 0); /* FALSE - so says the spec */\n\n\tbuf_putstring(ses.writepayload, password, strlen(password));\n\n\tencrypt_packet();\n\tm_burn(password, strlen(password));\n\tcli_ses.is_trivial_auth = 0;\n\tTRACE((\"leave cli_auth_password\"))\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -38,6 +38,6 @@\n \n \tencrypt_packet();\n \tm_burn(password, strlen(password));\n-\n+\tcli_ses.is_trivial_auth = 0;\n \tTRACE((\"leave cli_auth_password\"))\n }",
        "diff_line_info": {
            "deleted_lines": [
                ""
            ],
            "added_lines": [
                "\tcli_ses.is_trivial_auth = 0;"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-36369",
        "func_name": "mkj/dropbear/cli_session_init",
        "description": "An issue was discovered in Dropbear through 2020.81. Due to a non-RFC-compliant check of the available authentication methods in the client-side SSH code, it is possible for an SSH server to change the login process in its favor. This attack can bypass additional security measures such as FIDO2 tokens or SSH-Askpass. Thus, it allows an attacker to abuse a forwarded agent for logging on to another server unnoticed.",
        "git_url": "https://github.com/mkj/dropbear/commit/7c2e8fcd0d162d2ba9fac116f96a5e82ac77f11c",
        "commit_title": "added option to disable trivial auth methods",
        "commit_text": "",
        "func_before": "static void cli_session_init(pid_t proxy_cmd_pid) {\n\n\tcli_ses.state = STATE_NOTHING;\n\tcli_ses.kex_state = KEX_NOTHING;\n\n\tcli_ses.tty_raw_mode = 0;\n\tcli_ses.winchange = 0;\n\n\t/* We store std{in,out,err}'s flags, so we can set them back on exit\n\t * (otherwise busybox's ash isn't happy */\n\tcli_ses.stdincopy = dup(STDIN_FILENO);\n\tcli_ses.stdinflags = fcntl(STDIN_FILENO, F_GETFL, 0);\n\tcli_ses.stdoutcopy = dup(STDOUT_FILENO);\n\tcli_ses.stdoutflags = fcntl(STDOUT_FILENO, F_GETFL, 0);\n\tcli_ses.stderrcopy = dup(STDERR_FILENO);\n\tcli_ses.stderrflags = fcntl(STDERR_FILENO, F_GETFL, 0);\n\n\tcli_ses.retval = EXIT_SUCCESS; /* Assume it's clean if we don't get a\n\t\t\t\t\t\t\t\t\t  specific exit status */\n\tcli_ses.proxy_cmd_pid = proxy_cmd_pid;\n\tTRACE((\"proxy command PID='%d'\", proxy_cmd_pid));\n\n\t/* Auth */\n\tcli_ses.lastprivkey = NULL;\n\tcli_ses.lastauthtype = 0;\n\n\t/* For printing \"remote host closed\" for the user */\n\tses.remoteclosed = cli_remoteclosed;\n\n\tses.extra_session_cleanup = cli_session_cleanup;\n\n\t/* packet handlers */\n\tses.packettypes = cli_packettypes;\n\n\tses.isserver = 0;\n\n#if DROPBEAR_KEX_FIRST_FOLLOWS\n\tses.send_kex_first_guess = cli_send_kex_first_guess;\n#endif\n\n}",
        "func": "static void cli_session_init(pid_t proxy_cmd_pid) {\n\n\tcli_ses.state = STATE_NOTHING;\n\tcli_ses.kex_state = KEX_NOTHING;\n\n\tcli_ses.tty_raw_mode = 0;\n\tcli_ses.winchange = 0;\n\n\t/* We store std{in,out,err}'s flags, so we can set them back on exit\n\t * (otherwise busybox's ash isn't happy */\n\tcli_ses.stdincopy = dup(STDIN_FILENO);\n\tcli_ses.stdinflags = fcntl(STDIN_FILENO, F_GETFL, 0);\n\tcli_ses.stdoutcopy = dup(STDOUT_FILENO);\n\tcli_ses.stdoutflags = fcntl(STDOUT_FILENO, F_GETFL, 0);\n\tcli_ses.stderrcopy = dup(STDERR_FILENO);\n\tcli_ses.stderrflags = fcntl(STDERR_FILENO, F_GETFL, 0);\n\n\tcli_ses.retval = EXIT_SUCCESS; /* Assume it's clean if we don't get a\n\t\t\t\t\t\t\t\t\t  specific exit status */\n\tcli_ses.proxy_cmd_pid = proxy_cmd_pid;\n\tTRACE((\"proxy command PID='%d'\", proxy_cmd_pid));\n\n\t/* Auth */\n\tcli_ses.lastprivkey = NULL;\n\tcli_ses.lastauthtype = 0;\n\tcli_ses.is_trivial_auth = 1;\n\n\t/* For printing \"remote host closed\" for the user */\n\tses.remoteclosed = cli_remoteclosed;\n\n\tses.extra_session_cleanup = cli_session_cleanup;\n\n\t/* packet handlers */\n\tses.packettypes = cli_packettypes;\n\n\tses.isserver = 0;\n\n#if DROPBEAR_KEX_FIRST_FOLLOWS\n\tses.send_kex_first_guess = cli_send_kex_first_guess;\n#endif\n\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -23,6 +23,7 @@\n \t/* Auth */\n \tcli_ses.lastprivkey = NULL;\n \tcli_ses.lastauthtype = 0;\n+\tcli_ses.is_trivial_auth = 1;\n \n \t/* For printing \"remote host closed\" for the user */\n \tses.remoteclosed = cli_remoteclosed;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tcli_ses.is_trivial_auth = 1;"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-36369",
        "func_name": "mkj/dropbear/send_msg_userauth_pubkey",
        "description": "An issue was discovered in Dropbear through 2020.81. Due to a non-RFC-compliant check of the available authentication methods in the client-side SSH code, it is possible for an SSH server to change the login process in its favor. This attack can bypass additional security measures such as FIDO2 tokens or SSH-Askpass. Thus, it allows an attacker to abuse a forwarded agent for logging on to another server unnoticed.",
        "git_url": "https://github.com/mkj/dropbear/commit/318109125e747f0bc256a6d94d5756030ea2f5a0",
        "commit_title": "fixed trivial auth detection for pubkeys",
        "commit_text": "",
        "func_before": "static void send_msg_userauth_pubkey(sign_key *key, enum signature_type sigtype, int realsign) {\n\n\tconst char *algoname = NULL;\n\tunsigned int algolen;\n\tbuffer* sigbuf = NULL;\n\tenum signkey_type keytype = signkey_type_from_signature(sigtype);\n\n\tTRACE((\"enter send_msg_userauth_pubkey sigtype %d\", sigtype))\n\tCHECKCLEARTOWRITE();\n\n\tbuf_putbyte(ses.writepayload, SSH_MSG_USERAUTH_REQUEST);\n\n\tbuf_putstring(ses.writepayload, cli_opts.username,\n\t\t\tstrlen(cli_opts.username));\n\n\tbuf_putstring(ses.writepayload, SSH_SERVICE_CONNECTION,\n\t\t\tSSH_SERVICE_CONNECTION_LEN);\n\n\tbuf_putstring(ses.writepayload, AUTH_METHOD_PUBKEY,\n\t\t\tAUTH_METHOD_PUBKEY_LEN);\n\n\tbuf_putbyte(ses.writepayload, realsign);\n\n\talgoname = signature_name_from_type(sigtype, &algolen);\n\tbuf_putstring(ses.writepayload, algoname, algolen);\n\tbuf_put_pub_key(ses.writepayload, key, keytype);\n\n\tif (realsign) {\n\t\tTRACE((\"realsign\"))\n\t\t/* We put the signature as well - this contains string(session id), then\n\t\t * the contents of the write payload to this point */\n\t\tsigbuf = buf_new(4 + ses.session_id->len + ses.writepayload->len);\n\t\tbuf_putbufstring(sigbuf, ses.session_id);\n\t\tbuf_putbytes(sigbuf, ses.writepayload->data, ses.writepayload->len);\n\t\tcli_buf_put_sign(ses.writepayload, key, sigtype, sigbuf);\n\t\tbuf_free(sigbuf); /* Nothing confidential in the buffer */\n\t}\n\n\tencrypt_packet();\n\tTRACE((\"leave send_msg_userauth_pubkey\"))\n}",
        "func": "static void send_msg_userauth_pubkey(sign_key *key, enum signature_type sigtype, int realsign) {\n\n\tconst char *algoname = NULL;\n\tunsigned int algolen;\n\tbuffer* sigbuf = NULL;\n\tenum signkey_type keytype = signkey_type_from_signature(sigtype);\n\n\tTRACE((\"enter send_msg_userauth_pubkey sigtype %d\", sigtype))\n\tCHECKCLEARTOWRITE();\n\n\tbuf_putbyte(ses.writepayload, SSH_MSG_USERAUTH_REQUEST);\n\n\tbuf_putstring(ses.writepayload, cli_opts.username,\n\t\t\tstrlen(cli_opts.username));\n\n\tbuf_putstring(ses.writepayload, SSH_SERVICE_CONNECTION,\n\t\t\tSSH_SERVICE_CONNECTION_LEN);\n\n\tbuf_putstring(ses.writepayload, AUTH_METHOD_PUBKEY,\n\t\t\tAUTH_METHOD_PUBKEY_LEN);\n\n\tbuf_putbyte(ses.writepayload, realsign);\n\n\talgoname = signature_name_from_type(sigtype, &algolen);\n\tbuf_putstring(ses.writepayload, algoname, algolen);\n\tbuf_put_pub_key(ses.writepayload, key, keytype);\n\n\tif (realsign) {\n\t\tTRACE((\"realsign\"))\n\t\t/* We put the signature as well - this contains string(session id), then\n\t\t * the contents of the write payload to this point */\n\t\tsigbuf = buf_new(4 + ses.session_id->len + ses.writepayload->len);\n\t\tbuf_putbufstring(sigbuf, ses.session_id);\n\t\tbuf_putbytes(sigbuf, ses.writepayload->data, ses.writepayload->len);\n\t\tcli_buf_put_sign(ses.writepayload, key, sigtype, sigbuf);\n\t\tbuf_free(sigbuf); /* Nothing confidential in the buffer */\n\t\tcli_ses.is_trivial_auth = 0;\n\t}\n\n\tencrypt_packet();\n\tTRACE((\"leave send_msg_userauth_pubkey\"))\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -34,6 +34,7 @@\n \t\tbuf_putbytes(sigbuf, ses.writepayload->data, ses.writepayload->len);\n \t\tcli_buf_put_sign(ses.writepayload, key, sigtype, sigbuf);\n \t\tbuf_free(sigbuf); /* Nothing confidential in the buffer */\n+\t\tcli_ses.is_trivial_auth = 0;\n \t}\n \n \tencrypt_packet();",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\tcli_ses.is_trivial_auth = 0;"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-36369",
        "func_name": "mkj/dropbear/cli_auth_pubkey",
        "description": "An issue was discovered in Dropbear through 2020.81. Due to a non-RFC-compliant check of the available authentication methods in the client-side SSH code, it is possible for an SSH server to change the login process in its favor. This attack can bypass additional security measures such as FIDO2 tokens or SSH-Askpass. Thus, it allows an attacker to abuse a forwarded agent for logging on to another server unnoticed.",
        "git_url": "https://github.com/mkj/dropbear/commit/318109125e747f0bc256a6d94d5756030ea2f5a0",
        "commit_title": "fixed trivial auth detection for pubkeys",
        "commit_text": "",
        "func_before": "int cli_auth_pubkey() {\n\tenum signature_type sigtype = DROPBEAR_SIGNATURE_NONE;\n\tTRACE((\"enter cli_auth_pubkey\"))\n\n#if DROPBEAR_CLI_AGENTFWD\n\tif (!cli_opts.agent_keys_loaded) {\n\t\t/* get the list of available keys from the agent */\n\t\tcli_load_agent_keys(cli_opts.privkeys);\n\t\tcli_opts.agent_keys_loaded = 1;\n\t\tTRACE((\"cli_auth_pubkey: agent keys loaded\"))\n\t}\n#endif\n\n\t/* iterate through privkeys to remove ones not allowed in server-sig-algs */\n \twhile (cli_opts.privkeys->first) {\n\t\tsign_key * key = (sign_key*)cli_opts.privkeys->first->item;\n\t\tif (cli_ses.server_sig_algs) {\n#if DROPBEAR_RSA\n\t\t\tif (key->type == DROPBEAR_SIGNKEY_RSA) {\n#if DROPBEAR_RSA_SHA256\n\t\t\t\tif (buf_has_algo(cli_ses.server_sig_algs, SSH_SIGNATURE_RSA_SHA256) \n\t\t\t\t\t\t== DROPBEAR_SUCCESS) {\n\t\t\t\t\tsigtype = DROPBEAR_SIGNATURE_RSA_SHA256;\n\t\t\t\t\tTRACE((\"server-sig-algs allows rsa sha256\"))\n\t\t\t\t\tbreak;\n\t\t\t\t}\n#endif /* DROPBEAR_RSA_SHA256 */\n#if DROPBEAR_RSA_SHA1\n\t\t\t\tif (buf_has_algo(cli_ses.server_sig_algs, SSH_SIGNKEY_RSA)\n\t\t\t\t\t\t== DROPBEAR_SUCCESS) {\n\t\t\t\t\tsigtype = DROPBEAR_SIGNATURE_RSA_SHA1;\n\t\t\t\t\tTRACE((\"server-sig-algs allows rsa sha1\"))\n\t\t\t\t\tbreak;\n\t\t\t\t}\n#endif /* DROPBEAR_RSA_SHA256 */\n\t\t\t} else\n#endif /* DROPBEAR_RSA */\n\t\t\t{\n\t\t\t\t/* Not RSA */\n\t\t\t\tconst char *name = NULL;\n\t\t\t\tsigtype = signature_type_from_signkey(key->type);\n\t\t\t\tname = signature_name_from_type(sigtype, NULL);\n\t\t\t\tif (buf_has_algo(cli_ses.server_sig_algs, name)\n\t\t\t\t\t\t== DROPBEAR_SUCCESS) {\n\t\t\t\t\tTRACE((\"server-sig-algs allows %s\", name))\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* No match, skip this key */\n\t\t\tTRACE((\"server-sig-algs no match keytype %d, skipping\", key->type))\n\t\t\tkey = list_remove(cli_opts.privkeys->first);\n\t\t\tsign_key_free(key); \n\t\t\tcontinue;\n\t\t} else {\n\t\t\t/* Server didn't provide a server-sig-algs list, we'll \n\t\t\t   assume all except rsa-sha256 are OK. */\n#if DROPBEAR_RSA\n\t\t\tif (key->type == DROPBEAR_SIGNKEY_RSA) {\n#if DROPBEAR_RSA_SHA1\n\t\t\t\tsigtype = DROPBEAR_SIGNATURE_RSA_SHA1;\n\t\t\t\tTRACE((\"no server-sig-algs, using rsa sha1\"))\n\t\t\t\tbreak;\n#else\n\t\t\t\t/* only support rsa-sha256, skip this key */\n\t\t\t\tTRACE((\"no server-sig-algs, skipping rsa sha256\"))\n\t\t\t\tkey = list_remove(cli_opts.privkeys->first);\n\t\t\t\tsign_key_free(key); \n\t\t\t\tcontinue;\n#endif\n\t\t\t} /* key->type == DROPBEAR_SIGNKEY_RSA */\n#endif /* DROPBEAR_RSA */\n\t\t\tsigtype = signature_type_from_signkey(key->type);\n\t\t\tTRACE((\"no server-sig-algs, using key\"))\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (cli_opts.privkeys->first) {\n\t\tsign_key * key = (sign_key*)cli_opts.privkeys->first->item;\n\t\t/* Send a trial request */\n\t\tsend_msg_userauth_pubkey(key, sigtype, 0);\n\t\tcli_ses.lastprivkey = key;\n\t\tcli_ses.is_trivial_auth = 0;\n\t\tTRACE((\"leave cli_auth_pubkey-success\"))\n\t\treturn 1;\n\t} else {\n\t\t/* no more keys left */\n\t\tTRACE((\"leave cli_auth_pubkey-failure\"))\n\t\treturn 0;\n\t}\n}",
        "func": "int cli_auth_pubkey() {\n\tenum signature_type sigtype = DROPBEAR_SIGNATURE_NONE;\n\tTRACE((\"enter cli_auth_pubkey\"))\n\n#if DROPBEAR_CLI_AGENTFWD\n\tif (!cli_opts.agent_keys_loaded) {\n\t\t/* get the list of available keys from the agent */\n\t\tcli_load_agent_keys(cli_opts.privkeys);\n\t\tcli_opts.agent_keys_loaded = 1;\n\t\tTRACE((\"cli_auth_pubkey: agent keys loaded\"))\n\t}\n#endif\n\n\t/* iterate through privkeys to remove ones not allowed in server-sig-algs */\n \twhile (cli_opts.privkeys->first) {\n\t\tsign_key * key = (sign_key*)cli_opts.privkeys->first->item;\n\t\tif (cli_ses.server_sig_algs) {\n#if DROPBEAR_RSA\n\t\t\tif (key->type == DROPBEAR_SIGNKEY_RSA) {\n#if DROPBEAR_RSA_SHA256\n\t\t\t\tif (buf_has_algo(cli_ses.server_sig_algs, SSH_SIGNATURE_RSA_SHA256) \n\t\t\t\t\t\t== DROPBEAR_SUCCESS) {\n\t\t\t\t\tsigtype = DROPBEAR_SIGNATURE_RSA_SHA256;\n\t\t\t\t\tTRACE((\"server-sig-algs allows rsa sha256\"))\n\t\t\t\t\tbreak;\n\t\t\t\t}\n#endif /* DROPBEAR_RSA_SHA256 */\n#if DROPBEAR_RSA_SHA1\n\t\t\t\tif (buf_has_algo(cli_ses.server_sig_algs, SSH_SIGNKEY_RSA)\n\t\t\t\t\t\t== DROPBEAR_SUCCESS) {\n\t\t\t\t\tsigtype = DROPBEAR_SIGNATURE_RSA_SHA1;\n\t\t\t\t\tTRACE((\"server-sig-algs allows rsa sha1\"))\n\t\t\t\t\tbreak;\n\t\t\t\t}\n#endif /* DROPBEAR_RSA_SHA256 */\n\t\t\t} else\n#endif /* DROPBEAR_RSA */\n\t\t\t{\n\t\t\t\t/* Not RSA */\n\t\t\t\tconst char *name = NULL;\n\t\t\t\tsigtype = signature_type_from_signkey(key->type);\n\t\t\t\tname = signature_name_from_type(sigtype, NULL);\n\t\t\t\tif (buf_has_algo(cli_ses.server_sig_algs, name)\n\t\t\t\t\t\t== DROPBEAR_SUCCESS) {\n\t\t\t\t\tTRACE((\"server-sig-algs allows %s\", name))\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* No match, skip this key */\n\t\t\tTRACE((\"server-sig-algs no match keytype %d, skipping\", key->type))\n\t\t\tkey = list_remove(cli_opts.privkeys->first);\n\t\t\tsign_key_free(key); \n\t\t\tcontinue;\n\t\t} else {\n\t\t\t/* Server didn't provide a server-sig-algs list, we'll \n\t\t\t   assume all except rsa-sha256 are OK. */\n#if DROPBEAR_RSA\n\t\t\tif (key->type == DROPBEAR_SIGNKEY_RSA) {\n#if DROPBEAR_RSA_SHA1\n\t\t\t\tsigtype = DROPBEAR_SIGNATURE_RSA_SHA1;\n\t\t\t\tTRACE((\"no server-sig-algs, using rsa sha1\"))\n\t\t\t\tbreak;\n#else\n\t\t\t\t/* only support rsa-sha256, skip this key */\n\t\t\t\tTRACE((\"no server-sig-algs, skipping rsa sha256\"))\n\t\t\t\tkey = list_remove(cli_opts.privkeys->first);\n\t\t\t\tsign_key_free(key); \n\t\t\t\tcontinue;\n#endif\n\t\t\t} /* key->type == DROPBEAR_SIGNKEY_RSA */\n#endif /* DROPBEAR_RSA */\n\t\t\tsigtype = signature_type_from_signkey(key->type);\n\t\t\tTRACE((\"no server-sig-algs, using key\"))\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (cli_opts.privkeys->first) {\n\t\tsign_key * key = (sign_key*)cli_opts.privkeys->first->item;\n\t\t/* Send a trial request */\n\t\tsend_msg_userauth_pubkey(key, sigtype, 0);\n\t\tcli_ses.lastprivkey = key;\n\t\tTRACE((\"leave cli_auth_pubkey-success\"))\n\t\treturn 1;\n\t} else {\n\t\t/* no more keys left */\n\t\tTRACE((\"leave cli_auth_pubkey-failure\"))\n\t\treturn 0;\n\t}\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -81,7 +81,6 @@\n \t\t/* Send a trial request */\n \t\tsend_msg_userauth_pubkey(key, sigtype, 0);\n \t\tcli_ses.lastprivkey = key;\n-\t\tcli_ses.is_trivial_auth = 0;\n \t\tTRACE((\"leave cli_auth_pubkey-success\"))\n \t\treturn 1;\n \t} else {",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tcli_ses.is_trivial_auth = 0;"
            ],
            "added_lines": []
        }
    },
    {
        "cve_id": "CVE-2012-3520",
        "func_name": "torvalds/linux/netlink_sendmsg",
        "description": "The Netlink implementation in the Linux kernel before 3.2.30 does not properly handle messages that lack SCM_CREDENTIALS data, which might allow local users to spoof Netlink communication via a crafted message, as demonstrated by a message to (1) Avahi or (2) NetworkManager.",
        "git_url": "https://github.com/torvalds/linux/commit/e0e3cea46d31d23dc40df0a49a7a2c04fe8edfea",
        "commit_title": "af_netlink: force credentials passing [CVE-2012-3520]",
        "commit_text": " Pablo Neira Ayuso discovered that avahi and potentially NetworkManager accept spoofed Netlink messages because of a kernel bug.  The kernel passes all-zero SCM_CREDENTIALS ancillary data to the receiver if the sender did not provide such data, instead of not including any such data at all or including the correct data from the peer (as it is the case with AF_UNIX).  This bug was introduced in commit 16e572626961 (af_unix: dont send SCM_CREDENTIALS by default)  This patch forces passing credentials for netlink, as before the regression.  Another fix would be to not add SCM_CREDENTIALS in netlink messages if not provided by the sender, but it might break some programs.  With help from Florian Weimer & Petr Matousek  This issue is designated as CVE-2012-3520  Cc: Petr Matousek <pmatouse@redhat.com> Cc: Florian Weimer <fweimer@redhat.com> Cc: Pablo Neira Ayuso <pablo@netfilter.org>",
        "func_before": "static int netlink_sendmsg(struct kiocb *kiocb, struct socket *sock,\n\t\t\t   struct msghdr *msg, size_t len)\n{\n\tstruct sock_iocb *siocb = kiocb_to_siocb(kiocb);\n\tstruct sock *sk = sock->sk;\n\tstruct netlink_sock *nlk = nlk_sk(sk);\n\tstruct sockaddr_nl *addr = msg->msg_name;\n\tu32 dst_pid;\n\tu32 dst_group;\n\tstruct sk_buff *skb;\n\tint err;\n\tstruct scm_cookie scm;\n\n\tif (msg->msg_flags&MSG_OOB)\n\t\treturn -EOPNOTSUPP;\n\n\tif (NULL == siocb->scm)\n\t\tsiocb->scm = &scm;\n\n\terr = scm_send(sock, msg, siocb->scm);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (msg->msg_namelen) {\n\t\terr = -EINVAL;\n\t\tif (addr->nl_family != AF_NETLINK)\n\t\t\tgoto out;\n\t\tdst_pid = addr->nl_pid;\n\t\tdst_group = ffs(addr->nl_groups);\n\t\terr =  -EPERM;\n\t\tif (dst_group && !netlink_capable(sock, NL_NONROOT_SEND))\n\t\t\tgoto out;\n\t} else {\n\t\tdst_pid = nlk->dst_pid;\n\t\tdst_group = nlk->dst_group;\n\t}\n\n\tif (!nlk->pid) {\n\t\terr = netlink_autobind(sock);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\terr = -EMSGSIZE;\n\tif (len > sk->sk_sndbuf - 32)\n\t\tgoto out;\n\terr = -ENOBUFS;\n\tskb = alloc_skb(len, GFP_KERNEL);\n\tif (skb == NULL)\n\t\tgoto out;\n\n\tNETLINK_CB(skb).pid\t= nlk->pid;\n\tNETLINK_CB(skb).dst_group = dst_group;\n\tmemcpy(NETLINK_CREDS(skb), &siocb->scm->creds, sizeof(struct ucred));\n\n\terr = -EFAULT;\n\tif (memcpy_fromiovec(skb_put(skb, len), msg->msg_iov, len)) {\n\t\tkfree_skb(skb);\n\t\tgoto out;\n\t}\n\n\terr = security_netlink_send(sk, skb);\n\tif (err) {\n\t\tkfree_skb(skb);\n\t\tgoto out;\n\t}\n\n\tif (dst_group) {\n\t\tatomic_inc(&skb->users);\n\t\tnetlink_broadcast(sk, skb, dst_pid, dst_group, GFP_KERNEL);\n\t}\n\terr = netlink_unicast(sk, skb, dst_pid, msg->msg_flags&MSG_DONTWAIT);\n\nout:\n\tscm_destroy(siocb->scm);\n\treturn err;\n}",
        "func": "static int netlink_sendmsg(struct kiocb *kiocb, struct socket *sock,\n\t\t\t   struct msghdr *msg, size_t len)\n{\n\tstruct sock_iocb *siocb = kiocb_to_siocb(kiocb);\n\tstruct sock *sk = sock->sk;\n\tstruct netlink_sock *nlk = nlk_sk(sk);\n\tstruct sockaddr_nl *addr = msg->msg_name;\n\tu32 dst_pid;\n\tu32 dst_group;\n\tstruct sk_buff *skb;\n\tint err;\n\tstruct scm_cookie scm;\n\n\tif (msg->msg_flags&MSG_OOB)\n\t\treturn -EOPNOTSUPP;\n\n\tif (NULL == siocb->scm)\n\t\tsiocb->scm = &scm;\n\n\terr = scm_send(sock, msg, siocb->scm, true);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (msg->msg_namelen) {\n\t\terr = -EINVAL;\n\t\tif (addr->nl_family != AF_NETLINK)\n\t\t\tgoto out;\n\t\tdst_pid = addr->nl_pid;\n\t\tdst_group = ffs(addr->nl_groups);\n\t\terr =  -EPERM;\n\t\tif (dst_group && !netlink_capable(sock, NL_NONROOT_SEND))\n\t\t\tgoto out;\n\t} else {\n\t\tdst_pid = nlk->dst_pid;\n\t\tdst_group = nlk->dst_group;\n\t}\n\n\tif (!nlk->pid) {\n\t\terr = netlink_autobind(sock);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\terr = -EMSGSIZE;\n\tif (len > sk->sk_sndbuf - 32)\n\t\tgoto out;\n\terr = -ENOBUFS;\n\tskb = alloc_skb(len, GFP_KERNEL);\n\tif (skb == NULL)\n\t\tgoto out;\n\n\tNETLINK_CB(skb).pid\t= nlk->pid;\n\tNETLINK_CB(skb).dst_group = dst_group;\n\tmemcpy(NETLINK_CREDS(skb), &siocb->scm->creds, sizeof(struct ucred));\n\n\terr = -EFAULT;\n\tif (memcpy_fromiovec(skb_put(skb, len), msg->msg_iov, len)) {\n\t\tkfree_skb(skb);\n\t\tgoto out;\n\t}\n\n\terr = security_netlink_send(sk, skb);\n\tif (err) {\n\t\tkfree_skb(skb);\n\t\tgoto out;\n\t}\n\n\tif (dst_group) {\n\t\tatomic_inc(&skb->users);\n\t\tnetlink_broadcast(sk, skb, dst_pid, dst_group, GFP_KERNEL);\n\t}\n\terr = netlink_unicast(sk, skb, dst_pid, msg->msg_flags&MSG_DONTWAIT);\n\nout:\n\tscm_destroy(siocb->scm);\n\treturn err;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -17,7 +17,7 @@\n \tif (NULL == siocb->scm)\n \t\tsiocb->scm = &scm;\n \n-\terr = scm_send(sock, msg, siocb->scm);\n+\terr = scm_send(sock, msg, siocb->scm, true);\n \tif (err < 0)\n \t\treturn err;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\terr = scm_send(sock, msg, siocb->scm);"
            ],
            "added_lines": [
                "\terr = scm_send(sock, msg, siocb->scm, true);"
            ]
        }
    },
    {
        "cve_id": "CVE-2012-3520",
        "func_name": "torvalds/linux/scm_send",
        "description": "The Netlink implementation in the Linux kernel before 3.2.30 does not properly handle messages that lack SCM_CREDENTIALS data, which might allow local users to spoof Netlink communication via a crafted message, as demonstrated by a message to (1) Avahi or (2) NetworkManager.",
        "git_url": "https://github.com/torvalds/linux/commit/e0e3cea46d31d23dc40df0a49a7a2c04fe8edfea",
        "commit_title": "af_netlink: force credentials passing [CVE-2012-3520]",
        "commit_text": " Pablo Neira Ayuso discovered that avahi and potentially NetworkManager accept spoofed Netlink messages because of a kernel bug.  The kernel passes all-zero SCM_CREDENTIALS ancillary data to the receiver if the sender did not provide such data, instead of not including any such data at all or including the correct data from the peer (as it is the case with AF_UNIX).  This bug was introduced in commit 16e572626961 (af_unix: dont send SCM_CREDENTIALS by default)  This patch forces passing credentials for netlink, as before the regression.  Another fix would be to not add SCM_CREDENTIALS in netlink messages if not provided by the sender, but it might break some programs.  With help from Florian Weimer & Petr Matousek  This issue is designated as CVE-2012-3520  Cc: Petr Matousek <pmatouse@redhat.com> Cc: Florian Weimer <fweimer@redhat.com> Cc: Pablo Neira Ayuso <pablo@netfilter.org>",
        "func_before": "static __inline__ int scm_send(struct socket *sock, struct msghdr *msg,\n\t\t\t       struct scm_cookie *scm)\n{\n\tmemset(scm, 0, sizeof(*scm));\n\tunix_get_peersec_dgram(sock, scm);\n\tif (msg->msg_controllen <= 0)\n\t\treturn 0;\n\treturn __scm_send(sock, msg, scm);\n}",
        "func": "static __inline__ int scm_send(struct socket *sock, struct msghdr *msg,\n\t\t\t       struct scm_cookie *scm, bool forcecreds)\n{\n\tmemset(scm, 0, sizeof(*scm));\n\tif (forcecreds)\n\t\tscm_set_cred(scm, task_tgid(current), current_cred());\n\tunix_get_peersec_dgram(sock, scm);\n\tif (msg->msg_controllen <= 0)\n\t\treturn 0;\n\treturn __scm_send(sock, msg, scm);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,7 +1,9 @@\n static __inline__ int scm_send(struct socket *sock, struct msghdr *msg,\n-\t\t\t       struct scm_cookie *scm)\n+\t\t\t       struct scm_cookie *scm, bool forcecreds)\n {\n \tmemset(scm, 0, sizeof(*scm));\n+\tif (forcecreds)\n+\t\tscm_set_cred(scm, task_tgid(current), current_cred());\n \tunix_get_peersec_dgram(sock, scm);\n \tif (msg->msg_controllen <= 0)\n \t\treturn 0;",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\t       struct scm_cookie *scm)"
            ],
            "added_lines": [
                "\t\t\t       struct scm_cookie *scm, bool forcecreds)",
                "\tif (forcecreds)",
                "\t\tscm_set_cred(scm, task_tgid(current), current_cred());"
            ]
        }
    },
    {
        "cve_id": "CVE-2012-3520",
        "func_name": "torvalds/linux/unix_dgram_sendmsg",
        "description": "The Netlink implementation in the Linux kernel before 3.2.30 does not properly handle messages that lack SCM_CREDENTIALS data, which might allow local users to spoof Netlink communication via a crafted message, as demonstrated by a message to (1) Avahi or (2) NetworkManager.",
        "git_url": "https://github.com/torvalds/linux/commit/e0e3cea46d31d23dc40df0a49a7a2c04fe8edfea",
        "commit_title": "af_netlink: force credentials passing [CVE-2012-3520]",
        "commit_text": " Pablo Neira Ayuso discovered that avahi and potentially NetworkManager accept spoofed Netlink messages because of a kernel bug.  The kernel passes all-zero SCM_CREDENTIALS ancillary data to the receiver if the sender did not provide such data, instead of not including any such data at all or including the correct data from the peer (as it is the case with AF_UNIX).  This bug was introduced in commit 16e572626961 (af_unix: dont send SCM_CREDENTIALS by default)  This patch forces passing credentials for netlink, as before the regression.  Another fix would be to not add SCM_CREDENTIALS in netlink messages if not provided by the sender, but it might break some programs.  With help from Florian Weimer & Petr Matousek  This issue is designated as CVE-2012-3520  Cc: Petr Matousek <pmatouse@redhat.com> Cc: Florian Weimer <fweimer@redhat.com> Cc: Pablo Neira Ayuso <pablo@netfilter.org>",
        "func_before": "static int unix_dgram_sendmsg(struct kiocb *kiocb, struct socket *sock,\n\t\t\t      struct msghdr *msg, size_t len)\n{\n\tstruct sock_iocb *siocb = kiocb_to_siocb(kiocb);\n\tstruct sock *sk = sock->sk;\n\tstruct net *net = sock_net(sk);\n\tstruct unix_sock *u = unix_sk(sk);\n\tstruct sockaddr_un *sunaddr = msg->msg_name;\n\tstruct sock *other = NULL;\n\tint namelen = 0; /* fake GCC */\n\tint err;\n\tunsigned int hash;\n\tstruct sk_buff *skb;\n\tlong timeo;\n\tstruct scm_cookie tmp_scm;\n\tint max_level;\n\tint data_len = 0;\n\n\tif (NULL == siocb->scm)\n\t\tsiocb->scm = &tmp_scm;\n\twait_for_unix_gc();\n\terr = scm_send(sock, msg, siocb->scm);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = -EOPNOTSUPP;\n\tif (msg->msg_flags&MSG_OOB)\n\t\tgoto out;\n\n\tif (msg->msg_namelen) {\n\t\terr = unix_mkname(sunaddr, msg->msg_namelen, &hash);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t\tnamelen = err;\n\t} else {\n\t\tsunaddr = NULL;\n\t\terr = -ENOTCONN;\n\t\tother = unix_peer_get(sk);\n\t\tif (!other)\n\t\t\tgoto out;\n\t}\n\n\tif (test_bit(SOCK_PASSCRED, &sock->flags) && !u->addr\n\t    && (err = unix_autobind(sock)) != 0)\n\t\tgoto out;\n\n\terr = -EMSGSIZE;\n\tif (len > sk->sk_sndbuf - 32)\n\t\tgoto out;\n\n\tif (len > SKB_MAX_ALLOC)\n\t\tdata_len = min_t(size_t,\n\t\t\t\t len - SKB_MAX_ALLOC,\n\t\t\t\t MAX_SKB_FRAGS * PAGE_SIZE);\n\n\tskb = sock_alloc_send_pskb(sk, len - data_len, data_len,\n\t\t\t\t   msg->msg_flags & MSG_DONTWAIT, &err);\n\tif (skb == NULL)\n\t\tgoto out;\n\n\terr = unix_scm_to_skb(siocb->scm, skb, true);\n\tif (err < 0)\n\t\tgoto out_free;\n\tmax_level = err + 1;\n\tunix_get_secdata(siocb->scm, skb);\n\n\tskb_put(skb, len - data_len);\n\tskb->data_len = data_len;\n\tskb->len = len;\n\terr = skb_copy_datagram_from_iovec(skb, 0, msg->msg_iov, 0, len);\n\tif (err)\n\t\tgoto out_free;\n\n\ttimeo = sock_sndtimeo(sk, msg->msg_flags & MSG_DONTWAIT);\n\nrestart:\n\tif (!other) {\n\t\terr = -ECONNRESET;\n\t\tif (sunaddr == NULL)\n\t\t\tgoto out_free;\n\n\t\tother = unix_find_other(net, sunaddr, namelen, sk->sk_type,\n\t\t\t\t\thash, &err);\n\t\tif (other == NULL)\n\t\t\tgoto out_free;\n\t}\n\n\tif (sk_filter(other, skb) < 0) {\n\t\t/* Toss the packet but do not return any error to the sender */\n\t\terr = len;\n\t\tgoto out_free;\n\t}\n\n\tunix_state_lock(other);\n\terr = -EPERM;\n\tif (!unix_may_send(sk, other))\n\t\tgoto out_unlock;\n\n\tif (sock_flag(other, SOCK_DEAD)) {\n\t\t/*\n\t\t *\tCheck with 1003.1g - what should\n\t\t *\tdatagram error\n\t\t */\n\t\tunix_state_unlock(other);\n\t\tsock_put(other);\n\n\t\terr = 0;\n\t\tunix_state_lock(sk);\n\t\tif (unix_peer(sk) == other) {\n\t\t\tunix_peer(sk) = NULL;\n\t\t\tunix_state_unlock(sk);\n\n\t\t\tunix_dgram_disconnected(sk, other);\n\t\t\tsock_put(other);\n\t\t\terr = -ECONNREFUSED;\n\t\t} else {\n\t\t\tunix_state_unlock(sk);\n\t\t}\n\n\t\tother = NULL;\n\t\tif (err)\n\t\t\tgoto out_free;\n\t\tgoto restart;\n\t}\n\n\terr = -EPIPE;\n\tif (other->sk_shutdown & RCV_SHUTDOWN)\n\t\tgoto out_unlock;\n\n\tif (sk->sk_type != SOCK_SEQPACKET) {\n\t\terr = security_unix_may_send(sk->sk_socket, other->sk_socket);\n\t\tif (err)\n\t\t\tgoto out_unlock;\n\t}\n\n\tif (unix_peer(other) != sk && unix_recvq_full(other)) {\n\t\tif (!timeo) {\n\t\t\terr = -EAGAIN;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\ttimeo = unix_wait_for_peer(other, timeo);\n\n\t\terr = sock_intr_errno(timeo);\n\t\tif (signal_pending(current))\n\t\t\tgoto out_free;\n\n\t\tgoto restart;\n\t}\n\n\tif (sock_flag(other, SOCK_RCVTSTAMP))\n\t\t__net_timestamp(skb);\n\tmaybe_add_creds(skb, sock, other);\n\tskb_queue_tail(&other->sk_receive_queue, skb);\n\tif (max_level > unix_sk(other)->recursion_level)\n\t\tunix_sk(other)->recursion_level = max_level;\n\tunix_state_unlock(other);\n\tother->sk_data_ready(other, len);\n\tsock_put(other);\n\tscm_destroy(siocb->scm);\n\treturn len;\n\nout_unlock:\n\tunix_state_unlock(other);\nout_free:\n\tkfree_skb(skb);\nout:\n\tif (other)\n\t\tsock_put(other);\n\tscm_destroy(siocb->scm);\n\treturn err;\n}",
        "func": "static int unix_dgram_sendmsg(struct kiocb *kiocb, struct socket *sock,\n\t\t\t      struct msghdr *msg, size_t len)\n{\n\tstruct sock_iocb *siocb = kiocb_to_siocb(kiocb);\n\tstruct sock *sk = sock->sk;\n\tstruct net *net = sock_net(sk);\n\tstruct unix_sock *u = unix_sk(sk);\n\tstruct sockaddr_un *sunaddr = msg->msg_name;\n\tstruct sock *other = NULL;\n\tint namelen = 0; /* fake GCC */\n\tint err;\n\tunsigned int hash;\n\tstruct sk_buff *skb;\n\tlong timeo;\n\tstruct scm_cookie tmp_scm;\n\tint max_level;\n\tint data_len = 0;\n\n\tif (NULL == siocb->scm)\n\t\tsiocb->scm = &tmp_scm;\n\twait_for_unix_gc();\n\terr = scm_send(sock, msg, siocb->scm, false);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = -EOPNOTSUPP;\n\tif (msg->msg_flags&MSG_OOB)\n\t\tgoto out;\n\n\tif (msg->msg_namelen) {\n\t\terr = unix_mkname(sunaddr, msg->msg_namelen, &hash);\n\t\tif (err < 0)\n\t\t\tgoto out;\n\t\tnamelen = err;\n\t} else {\n\t\tsunaddr = NULL;\n\t\terr = -ENOTCONN;\n\t\tother = unix_peer_get(sk);\n\t\tif (!other)\n\t\t\tgoto out;\n\t}\n\n\tif (test_bit(SOCK_PASSCRED, &sock->flags) && !u->addr\n\t    && (err = unix_autobind(sock)) != 0)\n\t\tgoto out;\n\n\terr = -EMSGSIZE;\n\tif (len > sk->sk_sndbuf - 32)\n\t\tgoto out;\n\n\tif (len > SKB_MAX_ALLOC)\n\t\tdata_len = min_t(size_t,\n\t\t\t\t len - SKB_MAX_ALLOC,\n\t\t\t\t MAX_SKB_FRAGS * PAGE_SIZE);\n\n\tskb = sock_alloc_send_pskb(sk, len - data_len, data_len,\n\t\t\t\t   msg->msg_flags & MSG_DONTWAIT, &err);\n\tif (skb == NULL)\n\t\tgoto out;\n\n\terr = unix_scm_to_skb(siocb->scm, skb, true);\n\tif (err < 0)\n\t\tgoto out_free;\n\tmax_level = err + 1;\n\tunix_get_secdata(siocb->scm, skb);\n\n\tskb_put(skb, len - data_len);\n\tskb->data_len = data_len;\n\tskb->len = len;\n\terr = skb_copy_datagram_from_iovec(skb, 0, msg->msg_iov, 0, len);\n\tif (err)\n\t\tgoto out_free;\n\n\ttimeo = sock_sndtimeo(sk, msg->msg_flags & MSG_DONTWAIT);\n\nrestart:\n\tif (!other) {\n\t\terr = -ECONNRESET;\n\t\tif (sunaddr == NULL)\n\t\t\tgoto out_free;\n\n\t\tother = unix_find_other(net, sunaddr, namelen, sk->sk_type,\n\t\t\t\t\thash, &err);\n\t\tif (other == NULL)\n\t\t\tgoto out_free;\n\t}\n\n\tif (sk_filter(other, skb) < 0) {\n\t\t/* Toss the packet but do not return any error to the sender */\n\t\terr = len;\n\t\tgoto out_free;\n\t}\n\n\tunix_state_lock(other);\n\terr = -EPERM;\n\tif (!unix_may_send(sk, other))\n\t\tgoto out_unlock;\n\n\tif (sock_flag(other, SOCK_DEAD)) {\n\t\t/*\n\t\t *\tCheck with 1003.1g - what should\n\t\t *\tdatagram error\n\t\t */\n\t\tunix_state_unlock(other);\n\t\tsock_put(other);\n\n\t\terr = 0;\n\t\tunix_state_lock(sk);\n\t\tif (unix_peer(sk) == other) {\n\t\t\tunix_peer(sk) = NULL;\n\t\t\tunix_state_unlock(sk);\n\n\t\t\tunix_dgram_disconnected(sk, other);\n\t\t\tsock_put(other);\n\t\t\terr = -ECONNREFUSED;\n\t\t} else {\n\t\t\tunix_state_unlock(sk);\n\t\t}\n\n\t\tother = NULL;\n\t\tif (err)\n\t\t\tgoto out_free;\n\t\tgoto restart;\n\t}\n\n\terr = -EPIPE;\n\tif (other->sk_shutdown & RCV_SHUTDOWN)\n\t\tgoto out_unlock;\n\n\tif (sk->sk_type != SOCK_SEQPACKET) {\n\t\terr = security_unix_may_send(sk->sk_socket, other->sk_socket);\n\t\tif (err)\n\t\t\tgoto out_unlock;\n\t}\n\n\tif (unix_peer(other) != sk && unix_recvq_full(other)) {\n\t\tif (!timeo) {\n\t\t\terr = -EAGAIN;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\ttimeo = unix_wait_for_peer(other, timeo);\n\n\t\terr = sock_intr_errno(timeo);\n\t\tif (signal_pending(current))\n\t\t\tgoto out_free;\n\n\t\tgoto restart;\n\t}\n\n\tif (sock_flag(other, SOCK_RCVTSTAMP))\n\t\t__net_timestamp(skb);\n\tmaybe_add_creds(skb, sock, other);\n\tskb_queue_tail(&other->sk_receive_queue, skb);\n\tif (max_level > unix_sk(other)->recursion_level)\n\t\tunix_sk(other)->recursion_level = max_level;\n\tunix_state_unlock(other);\n\tother->sk_data_ready(other, len);\n\tsock_put(other);\n\tscm_destroy(siocb->scm);\n\treturn len;\n\nout_unlock:\n\tunix_state_unlock(other);\nout_free:\n\tkfree_skb(skb);\nout:\n\tif (other)\n\t\tsock_put(other);\n\tscm_destroy(siocb->scm);\n\treturn err;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -19,7 +19,7 @@\n \tif (NULL == siocb->scm)\n \t\tsiocb->scm = &tmp_scm;\n \twait_for_unix_gc();\n-\terr = scm_send(sock, msg, siocb->scm);\n+\terr = scm_send(sock, msg, siocb->scm, false);\n \tif (err < 0)\n \t\treturn err;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\terr = scm_send(sock, msg, siocb->scm);"
            ],
            "added_lines": [
                "\terr = scm_send(sock, msg, siocb->scm, false);"
            ]
        }
    },
    {
        "cve_id": "CVE-2012-3520",
        "func_name": "torvalds/linux/unix_stream_sendmsg",
        "description": "The Netlink implementation in the Linux kernel before 3.2.30 does not properly handle messages that lack SCM_CREDENTIALS data, which might allow local users to spoof Netlink communication via a crafted message, as demonstrated by a message to (1) Avahi or (2) NetworkManager.",
        "git_url": "https://github.com/torvalds/linux/commit/e0e3cea46d31d23dc40df0a49a7a2c04fe8edfea",
        "commit_title": "af_netlink: force credentials passing [CVE-2012-3520]",
        "commit_text": " Pablo Neira Ayuso discovered that avahi and potentially NetworkManager accept spoofed Netlink messages because of a kernel bug.  The kernel passes all-zero SCM_CREDENTIALS ancillary data to the receiver if the sender did not provide such data, instead of not including any such data at all or including the correct data from the peer (as it is the case with AF_UNIX).  This bug was introduced in commit 16e572626961 (af_unix: dont send SCM_CREDENTIALS by default)  This patch forces passing credentials for netlink, as before the regression.  Another fix would be to not add SCM_CREDENTIALS in netlink messages if not provided by the sender, but it might break some programs.  With help from Florian Weimer & Petr Matousek  This issue is designated as CVE-2012-3520  Cc: Petr Matousek <pmatouse@redhat.com> Cc: Florian Weimer <fweimer@redhat.com> Cc: Pablo Neira Ayuso <pablo@netfilter.org>",
        "func_before": "static int unix_stream_sendmsg(struct kiocb *kiocb, struct socket *sock,\n\t\t\t       struct msghdr *msg, size_t len)\n{\n\tstruct sock_iocb *siocb = kiocb_to_siocb(kiocb);\n\tstruct sock *sk = sock->sk;\n\tstruct sock *other = NULL;\n\tint err, size;\n\tstruct sk_buff *skb;\n\tint sent = 0;\n\tstruct scm_cookie tmp_scm;\n\tbool fds_sent = false;\n\tint max_level;\n\n\tif (NULL == siocb->scm)\n\t\tsiocb->scm = &tmp_scm;\n\twait_for_unix_gc();\n\terr = scm_send(sock, msg, siocb->scm);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = -EOPNOTSUPP;\n\tif (msg->msg_flags&MSG_OOB)\n\t\tgoto out_err;\n\n\tif (msg->msg_namelen) {\n\t\terr = sk->sk_state == TCP_ESTABLISHED ? -EISCONN : -EOPNOTSUPP;\n\t\tgoto out_err;\n\t} else {\n\t\terr = -ENOTCONN;\n\t\tother = unix_peer(sk);\n\t\tif (!other)\n\t\t\tgoto out_err;\n\t}\n\n\tif (sk->sk_shutdown & SEND_SHUTDOWN)\n\t\tgoto pipe_err;\n\n\twhile (sent < len) {\n\t\t/*\n\t\t *\tOptimisation for the fact that under 0.01% of X\n\t\t *\tmessages typically need breaking up.\n\t\t */\n\n\t\tsize = len-sent;\n\n\t\t/* Keep two messages in the pipe so it schedules better */\n\t\tif (size > ((sk->sk_sndbuf >> 1) - 64))\n\t\t\tsize = (sk->sk_sndbuf >> 1) - 64;\n\n\t\tif (size > SKB_MAX_ALLOC)\n\t\t\tsize = SKB_MAX_ALLOC;\n\n\t\t/*\n\t\t *\tGrab a buffer\n\t\t */\n\n\t\tskb = sock_alloc_send_skb(sk, size, msg->msg_flags&MSG_DONTWAIT,\n\t\t\t\t\t  &err);\n\n\t\tif (skb == NULL)\n\t\t\tgoto out_err;\n\n\t\t/*\n\t\t *\tIf you pass two values to the sock_alloc_send_skb\n\t\t *\tit tries to grab the large buffer with GFP_NOFS\n\t\t *\t(which can fail easily), and if it fails grab the\n\t\t *\tfallback size buffer which is under a page and will\n\t\t *\tsucceed. [Alan]\n\t\t */\n\t\tsize = min_t(int, size, skb_tailroom(skb));\n\n\n\t\t/* Only send the fds in the first buffer */\n\t\terr = unix_scm_to_skb(siocb->scm, skb, !fds_sent);\n\t\tif (err < 0) {\n\t\t\tkfree_skb(skb);\n\t\t\tgoto out_err;\n\t\t}\n\t\tmax_level = err + 1;\n\t\tfds_sent = true;\n\n\t\terr = memcpy_fromiovec(skb_put(skb, size), msg->msg_iov, size);\n\t\tif (err) {\n\t\t\tkfree_skb(skb);\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tunix_state_lock(other);\n\n\t\tif (sock_flag(other, SOCK_DEAD) ||\n\t\t    (other->sk_shutdown & RCV_SHUTDOWN))\n\t\t\tgoto pipe_err_free;\n\n\t\tmaybe_add_creds(skb, sock, other);\n\t\tskb_queue_tail(&other->sk_receive_queue, skb);\n\t\tif (max_level > unix_sk(other)->recursion_level)\n\t\t\tunix_sk(other)->recursion_level = max_level;\n\t\tunix_state_unlock(other);\n\t\tother->sk_data_ready(other, size);\n\t\tsent += size;\n\t}\n\n\tscm_destroy(siocb->scm);\n\tsiocb->scm = NULL;\n\n\treturn sent;\n\npipe_err_free:\n\tunix_state_unlock(other);\n\tkfree_skb(skb);\npipe_err:\n\tif (sent == 0 && !(msg->msg_flags&MSG_NOSIGNAL))\n\t\tsend_sig(SIGPIPE, current, 0);\n\terr = -EPIPE;\nout_err:\n\tscm_destroy(siocb->scm);\n\tsiocb->scm = NULL;\n\treturn sent ? : err;\n}",
        "func": "static int unix_stream_sendmsg(struct kiocb *kiocb, struct socket *sock,\n\t\t\t       struct msghdr *msg, size_t len)\n{\n\tstruct sock_iocb *siocb = kiocb_to_siocb(kiocb);\n\tstruct sock *sk = sock->sk;\n\tstruct sock *other = NULL;\n\tint err, size;\n\tstruct sk_buff *skb;\n\tint sent = 0;\n\tstruct scm_cookie tmp_scm;\n\tbool fds_sent = false;\n\tint max_level;\n\n\tif (NULL == siocb->scm)\n\t\tsiocb->scm = &tmp_scm;\n\twait_for_unix_gc();\n\terr = scm_send(sock, msg, siocb->scm, false);\n\tif (err < 0)\n\t\treturn err;\n\n\terr = -EOPNOTSUPP;\n\tif (msg->msg_flags&MSG_OOB)\n\t\tgoto out_err;\n\n\tif (msg->msg_namelen) {\n\t\terr = sk->sk_state == TCP_ESTABLISHED ? -EISCONN : -EOPNOTSUPP;\n\t\tgoto out_err;\n\t} else {\n\t\terr = -ENOTCONN;\n\t\tother = unix_peer(sk);\n\t\tif (!other)\n\t\t\tgoto out_err;\n\t}\n\n\tif (sk->sk_shutdown & SEND_SHUTDOWN)\n\t\tgoto pipe_err;\n\n\twhile (sent < len) {\n\t\t/*\n\t\t *\tOptimisation for the fact that under 0.01% of X\n\t\t *\tmessages typically need breaking up.\n\t\t */\n\n\t\tsize = len-sent;\n\n\t\t/* Keep two messages in the pipe so it schedules better */\n\t\tif (size > ((sk->sk_sndbuf >> 1) - 64))\n\t\t\tsize = (sk->sk_sndbuf >> 1) - 64;\n\n\t\tif (size > SKB_MAX_ALLOC)\n\t\t\tsize = SKB_MAX_ALLOC;\n\n\t\t/*\n\t\t *\tGrab a buffer\n\t\t */\n\n\t\tskb = sock_alloc_send_skb(sk, size, msg->msg_flags&MSG_DONTWAIT,\n\t\t\t\t\t  &err);\n\n\t\tif (skb == NULL)\n\t\t\tgoto out_err;\n\n\t\t/*\n\t\t *\tIf you pass two values to the sock_alloc_send_skb\n\t\t *\tit tries to grab the large buffer with GFP_NOFS\n\t\t *\t(which can fail easily), and if it fails grab the\n\t\t *\tfallback size buffer which is under a page and will\n\t\t *\tsucceed. [Alan]\n\t\t */\n\t\tsize = min_t(int, size, skb_tailroom(skb));\n\n\n\t\t/* Only send the fds in the first buffer */\n\t\terr = unix_scm_to_skb(siocb->scm, skb, !fds_sent);\n\t\tif (err < 0) {\n\t\t\tkfree_skb(skb);\n\t\t\tgoto out_err;\n\t\t}\n\t\tmax_level = err + 1;\n\t\tfds_sent = true;\n\n\t\terr = memcpy_fromiovec(skb_put(skb, size), msg->msg_iov, size);\n\t\tif (err) {\n\t\t\tkfree_skb(skb);\n\t\t\tgoto out_err;\n\t\t}\n\n\t\tunix_state_lock(other);\n\n\t\tif (sock_flag(other, SOCK_DEAD) ||\n\t\t    (other->sk_shutdown & RCV_SHUTDOWN))\n\t\t\tgoto pipe_err_free;\n\n\t\tmaybe_add_creds(skb, sock, other);\n\t\tskb_queue_tail(&other->sk_receive_queue, skb);\n\t\tif (max_level > unix_sk(other)->recursion_level)\n\t\t\tunix_sk(other)->recursion_level = max_level;\n\t\tunix_state_unlock(other);\n\t\tother->sk_data_ready(other, size);\n\t\tsent += size;\n\t}\n\n\tscm_destroy(siocb->scm);\n\tsiocb->scm = NULL;\n\n\treturn sent;\n\npipe_err_free:\n\tunix_state_unlock(other);\n\tkfree_skb(skb);\npipe_err:\n\tif (sent == 0 && !(msg->msg_flags&MSG_NOSIGNAL))\n\t\tsend_sig(SIGPIPE, current, 0);\n\terr = -EPIPE;\nout_err:\n\tscm_destroy(siocb->scm);\n\tsiocb->scm = NULL;\n\treturn sent ? : err;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -14,7 +14,7 @@\n \tif (NULL == siocb->scm)\n \t\tsiocb->scm = &tmp_scm;\n \twait_for_unix_gc();\n-\terr = scm_send(sock, msg, siocb->scm);\n+\terr = scm_send(sock, msg, siocb->scm, false);\n \tif (err < 0)\n \t\treturn err;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\terr = scm_send(sock, msg, siocb->scm);"
            ],
            "added_lines": [
                "\terr = scm_send(sock, msg, siocb->scm, false);"
            ]
        }
    },
    {
        "cve_id": "CVE-2013-6643",
        "func_name": "chromium/OneClickSigninBubbleView::WindowClosing",
        "description": "The OneClickSigninBubbleView::WindowClosing function in browser/ui/views/sync/one_click_signin_bubble_view.cc in Google Chrome before 32.0.1700.76 on Windows and before 32.0.1700.77 on Mac OS X and Linux allows attackers to trigger a sync with an arbitrary Google account by leveraging improper handling of the closing of an untrusted signin confirm dialog.",
        "git_url": "https://github.com/chromium/chromium/commit/d2ca8f4fb2eae277b26b3015332be5cf1b8bdb5e",
        "commit_title": "Security fix for untrusted signin confirm dialog",
        "commit_text": " When the window associated with the confirm dialog is closed without user clicking 'ok got it', chrome starts sync with default settings. This could be exploited to sign a user's Chrome into an attacker's account, as reported in crbug 321940.   ",
        "func_before": "void OneClickSigninBubbleView::WindowClosing() {\n  // We have to reset |bubble_view_| here, not in our destructor, because\n  // we'll be destroyed asynchronously and the shown state will be checked\n  // before then.\n  DCHECK_EQ(bubble_view_, this);\n  bubble_view_ = NULL;\n\n  if (is_sync_dialog_ && !start_sync_callback_.is_null()) {\n    base::ResetAndReturn(&start_sync_callback_).Run(\n        OneClickSigninSyncStarter::SYNC_WITH_DEFAULT_SETTINGS);\n  }\n}",
        "func": "void OneClickSigninBubbleView::WindowClosing() {\n  // We have to reset |bubble_view_| here, not in our destructor, because\n  // we'll be destroyed asynchronously and the shown state will be checked\n  // before then.\n  DCHECK_EQ(bubble_view_, this);\n  bubble_view_ = NULL;\n\n  if (is_sync_dialog_ && !start_sync_callback_.is_null()) {\n    base::ResetAndReturn(&start_sync_callback_).Run(\n        OneClickSigninSyncStarter::UNDO_SYNC);\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -7,6 +7,6 @@\n \n   if (is_sync_dialog_ && !start_sync_callback_.is_null()) {\n     base::ResetAndReturn(&start_sync_callback_).Run(\n-        OneClickSigninSyncStarter::SYNC_WITH_DEFAULT_SETTINGS);\n+        OneClickSigninSyncStarter::UNDO_SYNC);\n   }\n }",
        "diff_line_info": {
            "deleted_lines": [
                "        OneClickSigninSyncStarter::SYNC_WITH_DEFAULT_SETTINGS);"
            ],
            "added_lines": [
                "        OneClickSigninSyncStarter::UNDO_SYNC);"
            ]
        }
    },
    {
        "cve_id": "CVE-2014-4668",
        "func_name": "cherokee/webserver/cherokee_validator_ldap_check",
        "description": "The cherokee_validator_ldap_check function in validator_ldap.c in Cherokee 1.2.103 and earlier, when LDAP is used, does not properly consider unauthenticated-bind semantics, which allows remote attackers to bypass authentication via an empty password.",
        "git_url": "https://github.com/cherokee/webserver/commit/fbda667221c51f0aa476a02366e0cf66cb012f88",
        "commit_title": "Prevent the LDAP validator from accepting an empty password.",
        "commit_text": "",
        "func_before": "ret_t\ncherokee_validator_ldap_check (cherokee_validator_ldap_t *ldap,\n                               cherokee_connection_t     *conn)\n{\n\tint                              re;\n\tret_t                            ret;\n\tsize_t                           size;\n\tchar                            *dn;\n\tLDAPMessage                     *message;\n\tLDAPMessage                     *first;\n\tchar                            *attrs[] = { LDAP_NO_ATTRS, NULL };\n\tcherokee_validator_ldap_props_t *props   = VAL_LDAP_PROP(ldap);\n\n\t/* Sanity checks\n\t */\n\tif ((conn->validator == NULL) ||\n\t    cherokee_buffer_is_empty (&conn->validator->user))\n\t\treturn ret_error;\n\n\tsize = cherokee_buffer_cnt_cspn (&conn->validator->user, 0, \"*()\");\n\tif (size != conn->validator->user.len)\n\t\treturn ret_error;\n\n\t/* Build filter\n\t */\n\tret = init_filter (ldap, props, conn);\n\tif (ret != ret_ok)\n\t\treturn ret;\n\n\t/* Search\n\t */\n\tre = ldap_search_s (ldap->conn, props->basedn.buf, LDAP_SCOPE_SUBTREE, ldap->filter.buf, attrs, 0, &message);\n\tif (re != LDAP_SUCCESS) {\n\t\tLOG_ERROR (CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH,\n\t\t           props->filter.buf ? props->filter.buf : \"\");\n\t\treturn ret_error;\n\t}\n\n\tTRACE (ENTRIES, \"subtree search (%s): done\\n\", ldap->filter.buf ? ldap->filter.buf : \"\");\n\n\t/* Check that there a single entry\n\t */\n\tre = ldap_count_entries (ldap->conn, message);\n\tif (re != 1) {\n\t\tldap_msgfree (message);\n\t\treturn ret_not_found;\n\t}\n\n\t/* Pick up the first one\n\t */\n\tfirst = ldap_first_entry (ldap->conn, message);\n\tif (first == NULL) {\n\t\tldap_msgfree (message);\n\t\treturn ret_not_found;\n\t}\n\n\t/* Get DN\n\t */\n\tdn = ldap_get_dn (ldap->conn, first);\n\tif (dn == NULL) {\n\t\tldap_msgfree (message);\n\t\treturn ret_error;\n\t}\n\n\tldap_msgfree (message);\n\n\t/* Check that it's right\n\t */\n\tret = validate_dn (props, dn, conn->validator->passwd.buf);\n\tif (ret != ret_ok)\n\t\treturn ret;\n\n\t/* Disconnect from the LDAP server\n\t */\n\tre = ldap_unbind_s (ldap->conn);\n\tif (re != LDAP_SUCCESS)\n\t\treturn ret_error;\n\n\t/* Validated!\n\t */\n\tTRACE (ENTRIES, \"Access to use %s has been granted\\n\", conn->validator->user.buf);\n\n\treturn ret_ok;\n}",
        "func": "ret_t\ncherokee_validator_ldap_check (cherokee_validator_ldap_t *ldap,\n                               cherokee_connection_t     *conn)\n{\n\tint                              re;\n\tret_t                            ret;\n\tsize_t                           size;\n\tchar                            *dn;\n\tLDAPMessage                     *message;\n\tLDAPMessage                     *first;\n\tchar                            *attrs[] = { LDAP_NO_ATTRS, NULL };\n\tcherokee_validator_ldap_props_t *props   = VAL_LDAP_PROP(ldap);\n\n\t/* Sanity checks\n\t */\n\tif ((conn->validator == NULL) ||\n\t    cherokee_buffer_is_empty (&conn->validator->user) ||\n\t    cherokee_buffer_is_empty (&conn->validator->passwd))\n\t\treturn ret_error;\n\n\tsize = cherokee_buffer_cnt_cspn (&conn->validator->user, 0, \"*()\");\n\tif (size != conn->validator->user.len)\n\t\treturn ret_error;\n\n\t/* Build filter\n\t */\n\tret = init_filter (ldap, props, conn);\n\tif (ret != ret_ok)\n\t\treturn ret;\n\n\t/* Search\n\t */\n\tre = ldap_search_s (ldap->conn, props->basedn.buf, LDAP_SCOPE_SUBTREE, ldap->filter.buf, attrs, 0, &message);\n\tif (re != LDAP_SUCCESS) {\n\t\tLOG_ERROR (CHEROKEE_ERROR_VALIDATOR_LDAP_SEARCH,\n\t\t           props->filter.buf ? props->filter.buf : \"\");\n\t\treturn ret_error;\n\t}\n\n\tTRACE (ENTRIES, \"subtree search (%s): done\\n\", ldap->filter.buf ? ldap->filter.buf : \"\");\n\n\t/* Check that there a single entry\n\t */\n\tre = ldap_count_entries (ldap->conn, message);\n\tif (re != 1) {\n\t\tldap_msgfree (message);\n\t\treturn ret_not_found;\n\t}\n\n\t/* Pick up the first one\n\t */\n\tfirst = ldap_first_entry (ldap->conn, message);\n\tif (first == NULL) {\n\t\tldap_msgfree (message);\n\t\treturn ret_not_found;\n\t}\n\n\t/* Get DN\n\t */\n\tdn = ldap_get_dn (ldap->conn, first);\n\tif (dn == NULL) {\n\t\tldap_msgfree (message);\n\t\treturn ret_error;\n\t}\n\n\tldap_msgfree (message);\n\n\t/* Check that it's right\n\t */\n\tret = validate_dn (props, dn, conn->validator->passwd.buf);\n\tif (ret != ret_ok)\n\t\treturn ret;\n\n\t/* Disconnect from the LDAP server\n\t */\n\tre = ldap_unbind_s (ldap->conn);\n\tif (re != LDAP_SUCCESS)\n\t\treturn ret_error;\n\n\t/* Validated!\n\t */\n\tTRACE (ENTRIES, \"Access to use %s has been granted\\n\", conn->validator->user.buf);\n\n\treturn ret_ok;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -14,7 +14,8 @@\n \t/* Sanity checks\n \t */\n \tif ((conn->validator == NULL) ||\n-\t    cherokee_buffer_is_empty (&conn->validator->user))\n+\t    cherokee_buffer_is_empty (&conn->validator->user) ||\n+\t    cherokee_buffer_is_empty (&conn->validator->passwd))\n \t\treturn ret_error;\n \n \tsize = cherokee_buffer_cnt_cspn (&conn->validator->user, 0, \"*()\");",
        "diff_line_info": {
            "deleted_lines": [
                "\t    cherokee_buffer_is_empty (&conn->validator->user))"
            ],
            "added_lines": [
                "\t    cherokee_buffer_is_empty (&conn->validator->user) ||",
                "\t    cherokee_buffer_is_empty (&conn->validator->passwd))"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-16088",
        "func_name": "openbsd/src/ca_validate_pubkey",
        "description": "iked in OpenIKED, as used in OpenBSD through 6.7, allows authentication bypass because ca.c has the wrong logic for checking whether a public key matches.",
        "git_url": "https://github.com/openbsd/src/commit/7afb2d41c6d373cf965285840b85c45011357115",
        "commit_title": "Fix return value check for openssl API used during pubkey validation.",
        "commit_text": " Found thanks to bug report by Michael Scheibel <m.Scheibel (at) tuvit (dot) de> ok patrick@, markus@, tb@",
        "func_before": "int\nca_validate_pubkey(struct iked *env, struct iked_static_id *id,\n    void *data, size_t len, struct iked_id *out)\n{\n\tBIO\t\t*rawcert = NULL;\n\tRSA\t\t*peerrsa = NULL, *localrsa = NULL;\n\tEC_KEY\t\t*peerec = NULL;\n\tEVP_PKEY\t*peerkey = NULL, *localkey = NULL;\n\tint\t\t ret = -1;\n\tFILE\t\t*fp = NULL;\n\tchar\t\t idstr[IKED_ID_SIZE];\n\tchar\t\t file[PATH_MAX];\n\tstruct iked_id\t idp;\n\n\tswitch (id->id_type) {\n\tcase IKEV2_ID_IPV4:\n\tcase IKEV2_ID_FQDN:\n\tcase IKEV2_ID_UFQDN:\n\tcase IKEV2_ID_IPV6:\n\t\tbreak;\n\tdefault:\n\t\t/* Some types like ASN1_DN will not be mapped to file names */\n\t\tlog_debug(\"%s: unsupported public key type %s\",\n\t\t    __func__, print_map(id->id_type, ikev2_id_map));\n\t\treturn (-1);\n\t}\n\n\tbzero(&idp, sizeof(idp));\n\tif ((idp.id_buf = ibuf_new(id->id_data, id->id_length)) == NULL)\n\t\tgoto done;\n\n\tidp.id_type = id->id_type;\n\tidp.id_offset = id->id_offset;\n\tif (ikev2_print_id(&idp, idstr, sizeof(idstr)) == -1)\n\t\tgoto done;\n\n\tif (len == 0 && data) {\n\t\t/* Data is already an public key */\n\t\tpeerkey = (EVP_PKEY *)data;\n\t}\n\tif (len > 0) {\n\t\tif ((rawcert = BIO_new_mem_buf(data, len)) == NULL)\n\t\t\tgoto done;\n\n\t\tif ((peerkey = EVP_PKEY_new()) == NULL)\n\t\t\tgoto sslerr;\n\t\tif ((peerrsa = d2i_RSAPublicKey_bio(rawcert, NULL))) {\n\t\t\tif (!EVP_PKEY_set1_RSA(peerkey, peerrsa)) {\n\t\t\t\tgoto sslerr;\n\t\t\t}\n\t\t} else if (BIO_reset(rawcert) == 1 &&\n\t\t    (peerec = d2i_EC_PUBKEY_bio(rawcert, NULL))) {\n\t\t\tif (!EVP_PKEY_set1_EC_KEY(peerkey, peerec)) {\n\t\t\t\tgoto sslerr;\n\t\t\t}\n\t\t} else {\n\t\t\tlog_debug(\"%s: unknown key type received\", __func__);\n\t\t\tgoto sslerr;\n\t\t}\n\t}\n\n\tlc_idtype(idstr);\n\tif (strlcpy(file, IKED_PUBKEY_DIR, sizeof(file)) >= sizeof(file) ||\n\t    strlcat(file, idstr, sizeof(file)) >= sizeof(file)) {\n\t\tlog_debug(\"%s: public key id too long %s\", __func__, idstr);\n\t\tgoto done;\n\t}\n\n\tif ((fp = fopen(file, \"r\")) == NULL) {\n\t\t/* Log to debug when called from ca_validate_cert */\n\t\tlogit(len == 0 ? LOG_DEBUG : LOG_INFO,\n\t\t    \"%s: could not open public key %s\", __func__, file);\n\t\tgoto done;\n\t}\n\tlocalkey = PEM_read_PUBKEY(fp, NULL, NULL, NULL);\n\tif (localkey == NULL) {\n\t\t/* reading PKCS #8 failed, try PEM RSA */\n\t\trewind(fp);\n\t\tlocalrsa = PEM_read_RSAPublicKey(fp, NULL, NULL, NULL);\n\t\tfclose(fp);\n\t\tif (localrsa == NULL)\n\t\t\tgoto sslerr;\n\t\tif ((localkey = EVP_PKEY_new()) == NULL)\n\t\t\tgoto sslerr;\n\t\tif (!EVP_PKEY_set1_RSA(localkey, localrsa))\n\t\t\tgoto sslerr;\n\t} else {\n\t\tfclose(fp);\n\t}\n\tif (localkey == NULL)\n\t\tgoto sslerr;\n\n\tif (peerkey && !EVP_PKEY_cmp(peerkey, localkey)) {\n\t\tlog_debug(\"%s: public key does not match %s\", __func__, file);\n\t\tgoto done;\n\t}\n\n\tlog_debug(\"%s: valid public key in file %s\", __func__, file);\n\n\tif (out && ca_pubkey_serialize(localkey, out))\n\t\tgoto done;\n\n\tret = 0;\n sslerr:\n\tif (ret != 0)\n\t\tca_sslerror(__func__);\n done:\n\tibuf_release(idp.id_buf);\n\tif (localkey != NULL)\n\t\tEVP_PKEY_free(localkey);\n\tif (peerrsa != NULL)\n\t\tRSA_free(peerrsa);\n\tif (peerec != NULL)\n\t\tEC_KEY_free(peerec);\n\tif (localrsa != NULL)\n\t\tRSA_free(localrsa);\n\tif (rawcert != NULL) {\n\t\tBIO_free(rawcert);\n\t\tif (peerkey != NULL)\n\t\t\tEVP_PKEY_free(peerkey);\n\t}\n\n\treturn (ret);\n}",
        "func": "int\nca_validate_pubkey(struct iked *env, struct iked_static_id *id,\n    void *data, size_t len, struct iked_id *out)\n{\n\tBIO\t\t*rawcert = NULL;\n\tRSA\t\t*peerrsa = NULL, *localrsa = NULL;\n\tEC_KEY\t\t*peerec = NULL;\n\tEVP_PKEY\t*peerkey = NULL, *localkey = NULL;\n\tint\t\t ret = -1;\n\tFILE\t\t*fp = NULL;\n\tchar\t\t idstr[IKED_ID_SIZE];\n\tchar\t\t file[PATH_MAX];\n\tstruct iked_id\t idp;\n\n\tswitch (id->id_type) {\n\tcase IKEV2_ID_IPV4:\n\tcase IKEV2_ID_FQDN:\n\tcase IKEV2_ID_UFQDN:\n\tcase IKEV2_ID_IPV6:\n\t\tbreak;\n\tdefault:\n\t\t/* Some types like ASN1_DN will not be mapped to file names */\n\t\tlog_debug(\"%s: unsupported public key type %s\",\n\t\t    __func__, print_map(id->id_type, ikev2_id_map));\n\t\treturn (-1);\n\t}\n\n\tbzero(&idp, sizeof(idp));\n\tif ((idp.id_buf = ibuf_new(id->id_data, id->id_length)) == NULL)\n\t\tgoto done;\n\n\tidp.id_type = id->id_type;\n\tidp.id_offset = id->id_offset;\n\tif (ikev2_print_id(&idp, idstr, sizeof(idstr)) == -1)\n\t\tgoto done;\n\n\tif (len == 0 && data) {\n\t\t/* Data is already an public key */\n\t\tpeerkey = (EVP_PKEY *)data;\n\t}\n\tif (len > 0) {\n\t\tif ((rawcert = BIO_new_mem_buf(data, len)) == NULL)\n\t\t\tgoto done;\n\n\t\tif ((peerkey = EVP_PKEY_new()) == NULL)\n\t\t\tgoto sslerr;\n\t\tif ((peerrsa = d2i_RSAPublicKey_bio(rawcert, NULL))) {\n\t\t\tif (!EVP_PKEY_set1_RSA(peerkey, peerrsa)) {\n\t\t\t\tgoto sslerr;\n\t\t\t}\n\t\t} else if (BIO_reset(rawcert) == 1 &&\n\t\t    (peerec = d2i_EC_PUBKEY_bio(rawcert, NULL))) {\n\t\t\tif (!EVP_PKEY_set1_EC_KEY(peerkey, peerec)) {\n\t\t\t\tgoto sslerr;\n\t\t\t}\n\t\t} else {\n\t\t\tlog_debug(\"%s: unknown key type received\", __func__);\n\t\t\tgoto sslerr;\n\t\t}\n\t}\n\n\tlc_idtype(idstr);\n\tif (strlcpy(file, IKED_PUBKEY_DIR, sizeof(file)) >= sizeof(file) ||\n\t    strlcat(file, idstr, sizeof(file)) >= sizeof(file)) {\n\t\tlog_debug(\"%s: public key id too long %s\", __func__, idstr);\n\t\tgoto done;\n\t}\n\n\tif ((fp = fopen(file, \"r\")) == NULL) {\n\t\t/* Log to debug when called from ca_validate_cert */\n\t\tlogit(len == 0 ? LOG_DEBUG : LOG_INFO,\n\t\t    \"%s: could not open public key %s\", __func__, file);\n\t\tgoto done;\n\t}\n\tlocalkey = PEM_read_PUBKEY(fp, NULL, NULL, NULL);\n\tif (localkey == NULL) {\n\t\t/* reading PKCS #8 failed, try PEM RSA */\n\t\trewind(fp);\n\t\tlocalrsa = PEM_read_RSAPublicKey(fp, NULL, NULL, NULL);\n\t\tfclose(fp);\n\t\tif (localrsa == NULL)\n\t\t\tgoto sslerr;\n\t\tif ((localkey = EVP_PKEY_new()) == NULL)\n\t\t\tgoto sslerr;\n\t\tif (!EVP_PKEY_set1_RSA(localkey, localrsa))\n\t\t\tgoto sslerr;\n\t} else {\n\t\tfclose(fp);\n\t}\n\tif (localkey == NULL)\n\t\tgoto sslerr;\n\n\tif (peerkey && EVP_PKEY_cmp(peerkey, localkey) != 1) {\n\t\tlog_debug(\"%s: public key does not match %s\", __func__, file);\n\t\tgoto done;\n\t}\n\n\tlog_debug(\"%s: valid public key in file %s\", __func__, file);\n\n\tif (out && ca_pubkey_serialize(localkey, out))\n\t\tgoto done;\n\n\tret = 0;\n sslerr:\n\tif (ret != 0)\n\t\tca_sslerror(__func__);\n done:\n\tibuf_release(idp.id_buf);\n\tif (localkey != NULL)\n\t\tEVP_PKEY_free(localkey);\n\tif (peerrsa != NULL)\n\t\tRSA_free(peerrsa);\n\tif (peerec != NULL)\n\t\tEC_KEY_free(peerec);\n\tif (localrsa != NULL)\n\t\tRSA_free(localrsa);\n\tif (rawcert != NULL) {\n\t\tBIO_free(rawcert);\n\t\tif (peerkey != NULL)\n\t\t\tEVP_PKEY_free(peerkey);\n\t}\n\n\treturn (ret);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -90,7 +90,7 @@\n \tif (localkey == NULL)\n \t\tgoto sslerr;\n \n-\tif (peerkey && !EVP_PKEY_cmp(peerkey, localkey)) {\n+\tif (peerkey && EVP_PKEY_cmp(peerkey, localkey) != 1) {\n \t\tlog_debug(\"%s: public key does not match %s\", __func__, file);\n \t\tgoto done;\n \t}",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (peerkey && !EVP_PKEY_cmp(peerkey, localkey)) {"
            ],
            "added_lines": [
                "\tif (peerkey && EVP_PKEY_cmp(peerkey, localkey) != 1) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-2975",
        "func_name": "openssl/siv_cipher",
        "description": "Issue summary: The AES-SIV cipher implementation contains a bug that causes\nit to ignore empty associated data entries which are unauthenticated as\na consequence.\n\nImpact summary: Applications that use the AES-SIV algorithm and want to\nauthenticate empty data entries as associated data can be mislead by removing\nadding or reordering such empty entries as these are ignored by the OpenSSL\nimplementation. We are currently unaware of any such applications.\n\nThe AES-SIV algorithm allows for authentication of multiple associated\ndata entries along with the encryption. To authenticate empty data the\napplication has to call EVP_EncryptUpdate() (or EVP_CipherUpdate()) with\nNULL pointer as the output buffer and 0 as the input buffer length.\nThe AES-SIV implementation in OpenSSL just returns success for such a call\ninstead of performing the associated data authentication operation.\nThe empty data thus will not be authenticated.\n\nAs this issue does not affect non-empty associated data authentication and\nwe expect it to be rare for an application to use empty associated data\nentries this is qualified as Low severity issue.",
        "git_url": "https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=6a83f0c958811f07e0d11dfc6b5a6a98edfd5bdc",
        "commit_title": "",
        "commit_text": "Do not ignore empty associated data with AES-SIV mode  The AES-SIV mode allows for multiple associated data items authenticated separately with any of these being 0 length.  The provided implementation ignores such empty associated data which is incorrect in regards to the RFC 5297 and is also a security issue because such empty associated data then become unauthenticated if an application expects to authenticate them.  Fixes CVE-2023-2975  (Merged from https://github.com/openssl/openssl/pull/21384)  (cherry picked from commit c426c281cfc23ab182f7d7d7a35229e7db1494d9) ",
        "func_before": "static int siv_cipher(void *vctx, unsigned char *out, size_t *outl,\n                      size_t outsize, const unsigned char *in, size_t inl)\n{\n    PROV_AES_SIV_CTX *ctx = (PROV_AES_SIV_CTX *)vctx;\n\n    if (!ossl_prov_is_running())\n        return 0;\n\n    if (inl == 0) {\n        *outl = 0;\n        return 1;\n    }\n\n    if (outsize < inl) {\n        ERR_raise(ERR_LIB_PROV, PROV_R_OUTPUT_BUFFER_TOO_SMALL);\n        return 0;\n    }\n\n    if (ctx->hw->cipher(ctx, out, in, inl) <= 0)\n        return 0;\n\n    if (outl != NULL)\n        *outl = inl;\n    return 1;\n}",
        "func": "static int siv_cipher(void *vctx, unsigned char *out, size_t *outl,\n                      size_t outsize, const unsigned char *in, size_t inl)\n{\n    PROV_AES_SIV_CTX *ctx = (PROV_AES_SIV_CTX *)vctx;\n\n    if (!ossl_prov_is_running())\n        return 0;\n\n    /* Ignore just empty encryption/decryption call and not AAD. */\n    if (out != NULL) {\n        if (inl == 0) {\n            if (outl != NULL)\n                *outl = 0;\n            return 1;\n        }\n\n        if (outsize < inl) {\n            ERR_raise(ERR_LIB_PROV, PROV_R_OUTPUT_BUFFER_TOO_SMALL);\n            return 0;\n        }\n    }\n\n    if (ctx->hw->cipher(ctx, out, in, inl) <= 0)\n        return 0;\n\n    if (outl != NULL)\n        *outl = inl;\n    return 1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,14 +6,18 @@\n     if (!ossl_prov_is_running())\n         return 0;\n \n-    if (inl == 0) {\n-        *outl = 0;\n-        return 1;\n-    }\n+    /* Ignore just empty encryption/decryption call and not AAD. */\n+    if (out != NULL) {\n+        if (inl == 0) {\n+            if (outl != NULL)\n+                *outl = 0;\n+            return 1;\n+        }\n \n-    if (outsize < inl) {\n-        ERR_raise(ERR_LIB_PROV, PROV_R_OUTPUT_BUFFER_TOO_SMALL);\n-        return 0;\n+        if (outsize < inl) {\n+            ERR_raise(ERR_LIB_PROV, PROV_R_OUTPUT_BUFFER_TOO_SMALL);\n+            return 0;\n+        }\n     }\n \n     if (ctx->hw->cipher(ctx, out, in, inl) <= 0)",
        "diff_line_info": {
            "deleted_lines": [
                "    if (inl == 0) {",
                "        *outl = 0;",
                "        return 1;",
                "    }",
                "    if (outsize < inl) {",
                "        ERR_raise(ERR_LIB_PROV, PROV_R_OUTPUT_BUFFER_TOO_SMALL);",
                "        return 0;"
            ],
            "added_lines": [
                "    /* Ignore just empty encryption/decryption call and not AAD. */",
                "    if (out != NULL) {",
                "        if (inl == 0) {",
                "            if (outl != NULL)",
                "                *outl = 0;",
                "            return 1;",
                "        }",
                "        if (outsize < inl) {",
                "            ERR_raise(ERR_LIB_PROV, PROV_R_OUTPUT_BUFFER_TOO_SMALL);",
                "            return 0;",
                "        }"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-3878",
        "func_name": "Uninett/mod_auth_mellon/register_hooks",
        "description": "A vulnerability was found in mod_auth_mellon before v0.14.2. If Apache is configured as a reverse proxy and mod_auth_mellon is configured to only let through authenticated users (with the require valid-user directive), adding special HTTP headers that are normally used to start the special SAML ECP (non-browser based) can be used to bypass authentication.",
        "git_url": "https://github.com/Uninett/mod_auth_mellon/commit/e09a28a30e13e5c22b481010f26b4a7743a09280",
        "commit_title": "Modify am_handler setup to run before mod_proxy",
        "commit_text": " The way the ECP flow works is that when a client initiates the flow, the SP's response is HTTP 200, but not the requested content, but a signed XML document that contains the \"samlp:AuthnRequest\" element. The idea is that the ECP client would then determine the IDP and send the document to the IDP, get a samlp:Response and convey that to the SP to get access to the protected resource.  Internally, the auth check which is normally done with am_check_uid() set to apache's ap_hook_check_user_id() hook, just responds with OK, so it pretends to authenticate the user. Then in the usual flow, the request reaches the ap_hook_handler which handles the request. There in the pipeline, mellon registers functions am_handler() which should run first (APR_HOOK_FIRST), determine that this request is an ECP one and return the ECP AuthnRequest document. But in case the proxy module is also in the picture, the proxy module \"races\" for who gets to be the first to handle the request in the pipeline and wins. Therefore, the request reaches the protected resource via mod_proxy and returns it.  This fix modifies the ap_hook_handler() call to explicitly run before handlers from mod_proxy.c  To reproduce the bug: 0) Have a SP with mellon connected to a Keycloak IDP (or any other IDP I    guess). In the example below, my SAML SP is saml.federation.test 1) Set a Location protected by mellon that proxies requests to another    URL. For example:      ProxyPass         /sp-proxy  http://app.federation.test/example_app/     <Location /sp-proxy>         AuthType Mellon         MellonEnable auth         Require valid-user     </Location>  2) call:  curl -L -H \"Accept: application/vnd.paos+xml\" \\          -H 'PAOS: ver=\"urn:liberty:paos:2003-08\";\"urn:oasis:names:tc:SAML:2.0:profiles:SSO:ecp\"' \\           http://saml.federation.test/sp-proxy  Before the patch, you would see whatever is served from the proxied page. With the patch, you should get back a XML document with a samlp:AuthnRequest.",
        "func_before": "static void register_hooks(apr_pool_t *p)\n{\n    ap_hook_access_checker(am_auth_mellon_user, NULL, NULL, APR_HOOK_MIDDLE);\n    ap_hook_check_user_id(am_check_uid, NULL, NULL, APR_HOOK_MIDDLE);\n    ap_hook_post_config(am_global_init, NULL, NULL, APR_HOOK_MIDDLE);\n    ap_hook_child_init(am_child_init, NULL, NULL, APR_HOOK_MIDDLE);\n    ap_hook_create_request(am_create_request, NULL, NULL, APR_HOOK_MIDDLE);\n\n    /* Add the hook to handle requests to the mod_auth_mellon endpoint.\n     *\n     * This is APR_HOOK_FIRST because we do not expect nor require users\n     * to add a SetHandler option for the endpoint. Instead, simply\n     * setting MellonEndpointPath should be enough.\n     *\n     * Therefore this hook must run before any handler that may check\n     * r->handler and decide that it is the only handler for this URL.\n     */\n    ap_hook_handler(am_handler, NULL, NULL, APR_HOOK_FIRST);\n\n#ifdef ENABLE_DIAGNOSTICS\n    ap_hook_open_logs(am_diag_log_init,NULL,NULL,APR_HOOK_MIDDLE);\n    ap_hook_log_transaction(am_diag_finalize_request,NULL,NULL,APR_HOOK_REALLY_LAST);\n#endif\n}",
        "func": "static void register_hooks(apr_pool_t *p)\n{\n    /* Our handler needs to run before mod_proxy so that it can properly\n     * return ECP AuthnRequest messages when running as a reverse proxy.\n     * See: https://github.com/Uninett/mod_auth_mellon/pull/196\n     */\n    static const char * const run_handler_before[]={ \"mod_proxy.c\", NULL };\n\n    ap_hook_access_checker(am_auth_mellon_user, NULL, NULL, APR_HOOK_MIDDLE);\n    ap_hook_check_user_id(am_check_uid, NULL, NULL, APR_HOOK_MIDDLE);\n    ap_hook_post_config(am_global_init, NULL, NULL, APR_HOOK_MIDDLE);\n    ap_hook_child_init(am_child_init, NULL, NULL, APR_HOOK_MIDDLE);\n    ap_hook_create_request(am_create_request, NULL, NULL, APR_HOOK_MIDDLE);\n\n    /* Add the hook to handle requests to the mod_auth_mellon endpoint.\n     *\n     * This is APR_HOOK_FIRST because we do not expect nor require users\n     * to add a SetHandler option for the endpoint. Instead, simply\n     * setting MellonEndpointPath should be enough.\n     *\n     * Therefore this hook must run before any handler that may check\n     * r->handler and decide that it is the only handler for this URL.\n     */\n    ap_hook_handler(am_handler, NULL, run_handler_before, APR_HOOK_FIRST);\n\n#ifdef ENABLE_DIAGNOSTICS\n    ap_hook_open_logs(am_diag_log_init,NULL,NULL,APR_HOOK_MIDDLE);\n    ap_hook_log_transaction(am_diag_finalize_request,NULL,NULL,APR_HOOK_REALLY_LAST);\n#endif\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,11 @@\n static void register_hooks(apr_pool_t *p)\n {\n+    /* Our handler needs to run before mod_proxy so that it can properly\n+     * return ECP AuthnRequest messages when running as a reverse proxy.\n+     * See: https://github.com/Uninett/mod_auth_mellon/pull/196\n+     */\n+    static const char * const run_handler_before[]={ \"mod_proxy.c\", NULL };\n+\n     ap_hook_access_checker(am_auth_mellon_user, NULL, NULL, APR_HOOK_MIDDLE);\n     ap_hook_check_user_id(am_check_uid, NULL, NULL, APR_HOOK_MIDDLE);\n     ap_hook_post_config(am_global_init, NULL, NULL, APR_HOOK_MIDDLE);\n@@ -15,7 +21,7 @@\n      * Therefore this hook must run before any handler that may check\n      * r->handler and decide that it is the only handler for this URL.\n      */\n-    ap_hook_handler(am_handler, NULL, NULL, APR_HOOK_FIRST);\n+    ap_hook_handler(am_handler, NULL, run_handler_before, APR_HOOK_FIRST);\n \n #ifdef ENABLE_DIAGNOSTICS\n     ap_hook_open_logs(am_diag_log_init,NULL,NULL,APR_HOOK_MIDDLE);",
        "diff_line_info": {
            "deleted_lines": [
                "    ap_hook_handler(am_handler, NULL, NULL, APR_HOOK_FIRST);"
            ],
            "added_lines": [
                "    /* Our handler needs to run before mod_proxy so that it can properly",
                "     * return ECP AuthnRequest messages when running as a reverse proxy.",
                "     * See: https://github.com/Uninett/mod_auth_mellon/pull/196",
                "     */",
                "    static const char * const run_handler_before[]={ \"mod_proxy.c\", NULL };",
                "",
                "    ap_hook_handler(am_handler, NULL, run_handler_before, APR_HOOK_FIRST);"
            ]
        }
    },
    {
        "cve_id": "CVE-2014-125060",
        "func_name": "holdennb/CollabCal/handleGet",
        "description": "A vulnerability, which was classified as critical, was found in holdennb CollabCal. Affected is the function handleGet of the file calenderServer.cpp. The manipulation leads to improper authentication. It is possible to launch the attack remotely. The patch is identified as b80f6d1893607c99e5113967592417d0fe310ce6. It is recommended to apply a patch to fix this issue. VDB-217614 is the identifier assigned to this vulnerability.",
        "git_url": "https://github.com/holdennb/CollabCal/commit/b80f6d1893607c99e5113967592417d0fe310ce6",
        "commit_title": "Fixed Login Exploit",
        "commit_text": "",
        "func_before": "string handleGet(map<string, string>* reqHeaders) {\n  long long sessionId = -1;\n  long uid = -1;\n  string uri = (*reqHeaders)[\"uri\"];\n  string body;\n  if (reqHeaders->count(\"Cookie\") != 0) {\n    string cookies = (*reqHeaders)[\"Cookie\"];\n    string sessionIdString = cookies.substr(cookies.find(\"=\") + 1);\n    sessionId = stoll(sessionIdString, nullptr);\n    auto usersessionIt = sessionMap.find(sessionId);\n    if (usersessionIt == sessionMap.end()){\n      cout << \"Bad session ID, redirecting to login.\" << endl;\n      body = getLogin();\n    } else\n      uid = sessionMap[sessionId];\n  }\n  map<string, string> resHeaders;\n  resHeaders[\"Server\"] = \"CSE461\";\n  resHeaders[\"Content-Type\"] = \"text/html; charset=UTF-8\";\n\n  if (uri.compare(\"/cal\") == 0 && uid == -1) {\n    cout << \"login page\" << endl;\n    // login page\n    body = getLogin();\n  } else if (uri.compare(\"/cal\") == 0 && uid != -1) {\n    cout << \"cal page\" << endl;\n    // cal page\n    string username = userNameById(uid);\n    body = getHeader(username);\n    body += getEmptyCalendar();\n    body += getFooter();\n\n  } else if (uri.compare(\"/getEvents\") == 0 && uid != -1) {\n    //cout << \"getevents\" << endl;\n    // getEvents, has uid\n    body = getEventsJson(uid);\n    resHeaders[\"Content-Type\"] = \"application/json; charset=UTF-8\";\n  } else {\n    // 404\n    cout << \"error page\" << endl;\n\n    string message = \"404 Page Not Found\";\n    return getResponseHeader(\"HTTP/1.1 404 Not Found\", &resHeaders, body.size())\n      + \"\\r\\n\" + message;\n  }\n  \n  return getResponseHeader(\"HTTP/1.1 200 OK\", &resHeaders, body.size()) + \"\\r\\n\" + body;\n}",
        "func": "string handleGet(map<string, string>* reqHeaders) {\n  long long sessionId = -1;\n  long uid = -1;\n  string uri = (*reqHeaders)[\"uri\"];\n  string body;\n  if (reqHeaders->count(\"Cookie\") != 0) {\n    string cookies = (*reqHeaders)[\"Cookie\"];\n    string sessionIdString = cookies.substr(cookies.find(\"=\") + 1);\n    sessionId = stoll(sessionIdString, nullptr);\n    auto usersessionIt = sessionMap.find(sessionId);\n    if (usersessionIt == sessionMap.end()){\n      cout << \"Bad session ID, redirecting to login.\" << endl;\n      body = getLogin();\n    } else\n      uid = usersessionIt->second;\n  }\n  map<string, string> resHeaders;\n  resHeaders[\"Server\"] = \"CSE461\";\n  resHeaders[\"Content-Type\"] = \"text/html; charset=UTF-8\";\n\n  if (uri.compare(\"/cal\") == 0 && uid == -1) {\n    cout << \"login page\" << endl;\n    // login page\n    body = getLogin();\n  } else if (uri.compare(\"/cal\") == 0 && uid != -1) {\n    cout << \"cal page\" << endl;\n    // cal page\n    string username = userNameById(uid);\n    body = getHeader(username);\n    body += getEmptyCalendar();\n    body += getFooter();\n\n  } else if (uri.compare(\"/getEvents\") == 0 && uid != -1) {\n    //cout << \"getevents\" << endl;\n    // getEvents, has uid\n    body = getEventsJson(uid);\n    resHeaders[\"Content-Type\"] = \"application/json; charset=UTF-8\";\n  } else {\n    // 404\n    cout << \"error page\" << endl;\n\n    string message = \"404 Page Not Found\";\n    return getResponseHeader(\"HTTP/1.1 404 Not Found\", &resHeaders, body.size())\n      + \"\\r\\n\" + message;\n  }\n  \n  return getResponseHeader(\"HTTP/1.1 200 OK\", &resHeaders, body.size()) + \"\\r\\n\" + body;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -12,7 +12,7 @@\n       cout << \"Bad session ID, redirecting to login.\" << endl;\n       body = getLogin();\n     } else\n-      uid = sessionMap[sessionId];\n+      uid = usersessionIt->second;\n   }\n   map<string, string> resHeaders;\n   resHeaders[\"Server\"] = \"CSE461\";",
        "diff_line_info": {
            "deleted_lines": [
                "      uid = sessionMap[sessionId];"
            ],
            "added_lines": [
                "      uid = usersessionIt->second;"
            ]
        }
    },
    {
        "cve_id": "CVE-2014-125060",
        "func_name": "holdennb/CollabCal/handlePost",
        "description": "A vulnerability, which was classified as critical, was found in holdennb CollabCal. Affected is the function handleGet of the file calenderServer.cpp. The manipulation leads to improper authentication. It is possible to launch the attack remotely. The patch is identified as b80f6d1893607c99e5113967592417d0fe310ce6. It is recommended to apply a patch to fix this issue. VDB-217614 is the identifier assigned to this vulnerability.",
        "git_url": "https://github.com/holdennb/CollabCal/commit/b80f6d1893607c99e5113967592417d0fe310ce6",
        "commit_title": "Fixed Login Exploit",
        "commit_text": "",
        "func_before": "string handlePost(map<string, string>* reqHeaders) {\n  long long sessionId = -1;\n  long uid = -1;\n  string uri = (*reqHeaders)[\"uri\"];\n  cout << \"handling post\" << endl;\n  if (reqHeaders->count(\"Cookie\") != 0) {\n    string cookies = (*reqHeaders)[\"Cookie\"];\n    string sessionIdString = cookies.substr(cookies.find(\"=\") + 1);\n    sessionId = stoll(sessionIdString, nullptr);\n    uid = sessionMap[sessionId];\n  }\n  map<string, string> resHeaders;\n  resHeaders[\"Server\"] = \"CSE461\";\n  resHeaders[\"Content-Type\"] = \"text/html; charset=UTF-8\";\n\n  //cout << \"uri is \" << uri << \", uid is \" << uid << endl;\n\n  string body;\n  if (uri.compare(\"/createUser\") == 0) {\n    cout << \"create user\" << endl;\n    string params = (*reqHeaders)[\"params\"];\n    string username = params.substr(9, params.find(\"&\") - 9);\n    string password = params.substr(params.find(\"&\") + 10);\n\n    cout << \"username is \" << username << \" password is \" << password << endl;\n\n    long newId = makeUser(username, password);\n    stringstream bodyStream;\n\n    if (newId == -1) {\n      bodyStream << \"Error: Could not create user '\" << username << \"'\" << endl;\n    } else {\n      bodyStream << \"Successfully created user '\" << username << \"'! Please log in.\" << endl;\n    }\n\n    body = bodyStream.str();\n  } else if (uri.compare(\"/login\") == 0) {\n    if (uid != -1)\n      logout(uid);\n    cout << \"login\" << endl;\n    string params = (*reqHeaders)[\"params\"];\n    string username = params.substr(9, params.find(\"&\") - 9);\n    string password = params.substr(params.find(\"&\") + 10);\n\n    cout << \"username is \" << username << \" password is \" << password << endl;\n\n    long long sess = login(username, password);\n\n    stringstream bodyStream;\n    if (sess == -1) {\n      bodyStream << getLogin();\n    } else {\n      stringstream cookie;\n      cookie << \"sessionId=\" << sess;\n      resHeaders[\"Set-Cookie\"] = cookie.str();\n\n      bodyStream << getHeader(username);\n      bodyStream << getEmptyCalendar();\n      bodyStream << getFooter();\n    }\n\n\n    body = bodyStream.str();\n    \n\n  } else if (uri.compare(\"/createGroup\") == 0 && uid != -1) {\n    cout << \"createGroup\" << endl;\n    string params = (*reqHeaders)[\"params\"];\n    string groupName = params.substr(11);\n    replace(groupName.begin(), groupName.end(), '+', ' ');\n\n    stringstream bodyStream;\n    long groupId = makeGroup(uid, groupName);\n    if (groupId != -1) {\n      cout << \"made group!\" << endl;\n      bodyStream << \"Successfully created group '\" << groupName << \"'\";\n    } else {\n      cout << \"makeGroup was -1.\" << endl;\n      bodyStream << \"Error: could not create group '\" << groupName << \"'\";\n    }\n\n    body = bodyStream.str();\n    \n  } else if (uri.compare(\"/addToGroup\") == 0 && uid != -1) {\n    cout << \"addToGroup\" << endl;\n    string params = (*reqHeaders)[\"params\"];\n    string groupName = params.substr(11, params.find(\"&\") - 11);\n    params = params.substr(params.find(\"&\") + 1);\n    string addedName = params.substr(11, params.find(\"&\") - 11);\n    params = params.substr(params.find(\"&\") + 1);\n    bool admin = params.find(\"admin\") != string::npos;\n    long groupId = groupIdByName(groupName);\n    long addedId = userIdByName(addedName);\n\n    stringstream bodyStream;\n    bool added = addToGroup(uid, addedId, groupId, admin);\n\n    if (added) {\n      cout << \"added to group!\" << endl;\n      bodyStream << \"Successfully added '\" << addedName << \"' to '\" << groupName << \"'\";\n    } else {\n      cout << \"Error: could not add '\" << addedName << \"' to '\" << groupName << \"'\";\n      bodyStream << \"Error: could not add '\" << addedName << \"' to '\" << groupName << \"'\";\n    }\n\n    body = bodyStream.str();\n    \n  } else if (uri.compare(\"/createEvent\") == 0 && uid != -1) {\n    cout << \"createEvent\" << endl;\n    string params = (*reqHeaders)[\"params\"];\n    string eventName = params.substr(5, params.find(\"&\") - 5);\n    replace(eventName.begin(), eventName.end(), '+', ' ');\n    params = params.substr(params.find(\"&\") + 1);\n    string timeString = params.substr(9, params.find(\"&\") - 9);\n    params = params.substr(params.find(\"&\") + 1);\n    bool withGroup = params.size() > 11;\n\n    cout << \"eName: \" << eventName << \" tS: \" << timeString << \" wG: \" << withGroup << endl;\n\n    stringstream timeStream;\n    time_t eventTime;\n    timeStream << timeString;\n    timeStream >> eventTime;\n\n    long eventId;\n    if (withGroup) {\n      string groupName = params.substr(11);\n      long groupId = groupIdByName(groupName);\n      cout << \"gName: \" << groupName << \" gID: \" << groupId << endl;\n\n      eventId = makeEvent(uid, eventName, eventTime, groupId, true);\n    } else {\n      eventId = makeEvent(uid, eventName, eventTime);\n    }\n\n    stringstream bodyStream;\n    if (eventId != -1) {\n      cout << \"made event!\" << endl;\n      bodyStream << \"Successfully created event '\" << eventName << \"'\";\n    } else {\n      cout << \"couldn't make event.\" << endl;\n      bodyStream << \"Error: could not create event '\" << eventName << \"'\";\n    }\n\n    body = bodyStream.str();\n    \n  } else if (uri.compare(\"/editEvent\") == 0 && uid != -1) {\n    cout << \"editEvent\" << endl;\n    string params = (*reqHeaders)[\"params\"];\n    long eventId = stol(params.substr(3, params.find(\"&\") - 3), nullptr);\n    params = params.substr(params.find(\"&\") + 1);\n    string eventName = params.substr(5, params.find(\"&\") - 5);\n    params = params.substr(params.find(\"&\") + 1);\n    string timeString = params.substr(9, params.find(\"&\") - 9);\n\n    cout << \"eID: \" << eventId << \" eName: \" << eventName << \" dt: \" << timeString << endl;\n\n    stringstream timeStream;\n    time_t eventTime;\n    timeStream << timeString;\n    timeStream >> eventTime;\n\n    renameEvent(uid, eventId, eventName);\n    rescheduleEvent(uid, eventId, eventTime);\n\n    stringstream bodyStream;\n    cout << \"edited event!\" << endl;\n    bodyStream << \"Successfully edited event.\";\n\n    body = bodyStream.str();\n  } else {\n    // 404\n    cout << \"error page\" << endl;\n\n    string message = \"404 Page Not Found\";\n    return getResponseHeader(\"HTTP/1.1 404 Not Found\", &resHeaders, body.size())\n      + \"\\r\\n\" + message;\n  }\n  \n  return getResponseHeader(\"HTTP/1.1 200 OK\", &resHeaders, body.size()) + \"\\r\\n\" + body;\n}",
        "func": "string handlePost(map<string, string>* reqHeaders) {\n  long long sessionId = -1;\n  long uid = -1;\n  string uri = (*reqHeaders)[\"uri\"];\n  cout << \"handling post\" << endl;\n  if (reqHeaders->count(\"Cookie\") != 0) {\n    string cookies = (*reqHeaders)[\"Cookie\"];\n    string sessionIdString = cookies.substr(cookies.find(\"=\") + 1);\n    sessionId = stoll(sessionIdString, nullptr);\n    auto sessionIt = sessionMap.find(sessionId);\n    if(sessionIt != sessionMap.end())\n      uid = sessionIt->second;\n  }\n  map<string, string> resHeaders;\n  resHeaders[\"Server\"] = \"CSE461\";\n  resHeaders[\"Content-Type\"] = \"text/html; charset=UTF-8\";\n\n  //cout << \"uri is \" << uri << \", uid is \" << uid << endl;\n\n  string body;\n  if (uri.compare(\"/createUser\") == 0) {\n    cout << \"create user\" << endl;\n    string params = (*reqHeaders)[\"params\"];\n    string username = params.substr(9, params.find(\"&\") - 9);\n    string password = params.substr(params.find(\"&\") + 10);\n\n    cout << \"username is \" << username << \" password is \" << password << endl;\n\n    long newId = makeUser(username, password);\n    stringstream bodyStream;\n\n    if (newId == -1) {\n      bodyStream << \"Error: Could not create user '\" << username << \"'\" << endl;\n    } else {\n      bodyStream << \"Successfully created user '\" << username << \"'! Please log in.\" << endl;\n    }\n\n    body = bodyStream.str();\n  } else if (uri.compare(\"/login\") == 0) {\n    if (uid != -1)\n      logout(uid);\n    cout << \"login\" << endl;\n    string params = (*reqHeaders)[\"params\"];\n    string username = params.substr(9, params.find(\"&\") - 9);\n    string password = params.substr(params.find(\"&\") + 10);\n\n    cout << \"username is \" << username << \" password is \" << password << endl;\n\n    long long sess = login(username, password);\n\n    stringstream bodyStream;\n    if (sess == -1) {\n      bodyStream << getLogin();\n    } else {\n      stringstream cookie;\n      cookie << \"sessionId=\" << sess;\n      resHeaders[\"Set-Cookie\"] = cookie.str();\n\n      bodyStream << getHeader(username);\n      bodyStream << getEmptyCalendar();\n      bodyStream << getFooter();\n    }\n\n\n    body = bodyStream.str();\n    \n\n  } else if (uri.compare(\"/createGroup\") == 0 && uid != -1) {\n    cout << \"createGroup\" << endl;\n    string params = (*reqHeaders)[\"params\"];\n    string groupName = params.substr(11);\n    replace(groupName.begin(), groupName.end(), '+', ' ');\n\n    stringstream bodyStream;\n    long groupId = makeGroup(uid, groupName);\n    if (groupId != -1) {\n      cout << \"made group!\" << endl;\n      bodyStream << \"Successfully created group '\" << groupName << \"'\";\n    } else {\n      cout << \"makeGroup was -1.\" << endl;\n      bodyStream << \"Error: could not create group '\" << groupName << \"'\";\n    }\n\n    body = bodyStream.str();\n    \n  } else if (uri.compare(\"/addToGroup\") == 0 && uid != -1) {\n    cout << \"addToGroup\" << endl;\n    string params = (*reqHeaders)[\"params\"];\n    string groupName = params.substr(11, params.find(\"&\") - 11);\n    params = params.substr(params.find(\"&\") + 1);\n    string addedName = params.substr(11, params.find(\"&\") - 11);\n    params = params.substr(params.find(\"&\") + 1);\n    bool admin = params.find(\"admin\") != string::npos;\n    long groupId = groupIdByName(groupName);\n    long addedId = userIdByName(addedName);\n\n    stringstream bodyStream;\n    bool added = addToGroup(uid, addedId, groupId, admin);\n\n    if (added) {\n      cout << \"added to group!\" << endl;\n      bodyStream << \"Successfully added '\" << addedName << \"' to '\" << groupName << \"'\";\n    } else {\n      cout << \"Error: could not add '\" << addedName << \"' to '\" << groupName << \"'\";\n      bodyStream << \"Error: could not add '\" << addedName << \"' to '\" << groupName << \"'\";\n    }\n\n    body = bodyStream.str();\n    \n  } else if (uri.compare(\"/createEvent\") == 0 && uid != -1) {\n    cout << \"createEvent\" << endl;\n    string params = (*reqHeaders)[\"params\"];\n    string eventName = params.substr(5, params.find(\"&\") - 5);\n    replace(eventName.begin(), eventName.end(), '+', ' ');\n    params = params.substr(params.find(\"&\") + 1);\n    string timeString = params.substr(9, params.find(\"&\") - 9);\n    params = params.substr(params.find(\"&\") + 1);\n    bool withGroup = params.size() > 11;\n\n    cout << \"eName: \" << eventName << \" tS: \" << timeString << \" wG: \" << withGroup << endl;\n\n    stringstream timeStream;\n    time_t eventTime;\n    timeStream << timeString;\n    timeStream >> eventTime;\n\n    long eventId;\n    if (withGroup) {\n      string groupName = params.substr(11);\n      long groupId = groupIdByName(groupName);\n      cout << \"gName: \" << groupName << \" gID: \" << groupId << endl;\n\n      eventId = makeEvent(uid, eventName, eventTime, groupId, true);\n    } else {\n      eventId = makeEvent(uid, eventName, eventTime);\n    }\n\n    stringstream bodyStream;\n    if (eventId != -1) {\n      cout << \"made event!\" << endl;\n      bodyStream << \"Successfully created event '\" << eventName << \"'\";\n    } else {\n      cout << \"couldn't make event.\" << endl;\n      bodyStream << \"Error: could not create event '\" << eventName << \"'\";\n    }\n\n    body = bodyStream.str();\n    \n  } else if (uri.compare(\"/editEvent\") == 0 && uid != -1) {\n    cout << \"editEvent\" << endl;\n    string params = (*reqHeaders)[\"params\"];\n    long eventId = stol(params.substr(3, params.find(\"&\") - 3), nullptr);\n    params = params.substr(params.find(\"&\") + 1);\n    string eventName = params.substr(5, params.find(\"&\") - 5);\n    params = params.substr(params.find(\"&\") + 1);\n    string timeString = params.substr(9, params.find(\"&\") - 9);\n\n    cout << \"eID: \" << eventId << \" eName: \" << eventName << \" dt: \" << timeString << endl;\n\n    stringstream timeStream;\n    time_t eventTime;\n    timeStream << timeString;\n    timeStream >> eventTime;\n\n    renameEvent(uid, eventId, eventName);\n    rescheduleEvent(uid, eventId, eventTime);\n\n    stringstream bodyStream;\n    cout << \"edited event!\" << endl;\n    bodyStream << \"Successfully edited event.\";\n\n    body = bodyStream.str();\n  } else {\n    // 404\n    cout << \"error page\" << endl;\n\n    string message = \"404 Page Not Found\";\n    return getResponseHeader(\"HTTP/1.1 404 Not Found\", &resHeaders, body.size())\n      + \"\\r\\n\" + message;\n  }\n  \n  return getResponseHeader(\"HTTP/1.1 200 OK\", &resHeaders, body.size()) + \"\\r\\n\" + body;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -7,7 +7,9 @@\n     string cookies = (*reqHeaders)[\"Cookie\"];\n     string sessionIdString = cookies.substr(cookies.find(\"=\") + 1);\n     sessionId = stoll(sessionIdString, nullptr);\n-    uid = sessionMap[sessionId];\n+    auto sessionIt = sessionMap.find(sessionId);\n+    if(sessionIt != sessionMap.end())\n+      uid = sessionIt->second;\n   }\n   map<string, string> resHeaders;\n   resHeaders[\"Server\"] = \"CSE461\";",
        "diff_line_info": {
            "deleted_lines": [
                "    uid = sessionMap[sessionId];"
            ],
            "added_lines": [
                "    auto sessionIt = sessionMap.find(sessionId);",
                "    if(sessionIt != sessionMap.end())",
                "      uid = sessionIt->second;"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-36368",
        "func_name": "openssh/openssh-portable/userauth_passwd",
        "description": "An issue was discovered in OpenSSH before 8.9. If a client is using public-key authentication with agent forwarding but without -oLogLevel=verbose, and an attacker has silently modified the server to support the None authentication option, then the user cannot determine whether FIDO authentication is going to confirm that the user wishes to connect to that server, or that the user wishes to allow that server to connect to a different server on the user's behalf. NOTE: the vendor's position is \"this is not an authentication bypass, since nothing is being bypassed.",
        "git_url": "https://github.com/openssh/openssh-portable/commit/a54ee9431e4632469786c013b9714265e1183457",
        "commit_title": "removed empty line",
        "commit_text": "",
        "func_before": "static int\nuserauth_passwd(struct ssh *ssh)\n{\n\tAuthctxt *authctxt = (Authctxt *)ssh->authctxt;\n\tauthctxt->is_trivial_auth = 0;\n\tchar *password, *prompt = NULL;\n\tconst char *host = options.host_key_alias ?  options.host_key_alias :\n\t    authctxt->host;\n\tint r;\n\n\tif (authctxt->attempt_passwd++ >= options.number_of_password_prompts)\n\t\treturn 0;\n\n\tif (authctxt->attempt_passwd != 1)\n\t\terror(\"Permission denied, please try again.\");\n\n\txasprintf(&prompt, \"%s@%s's password: \", authctxt->server_user, host);\n\tpassword = read_passphrase(prompt, 0);\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_USERAUTH_REQUEST)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, authctxt->server_user)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, authctxt->service)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, authctxt->method->name)) != 0 ||\n\t    (r = sshpkt_put_u8(ssh, 0)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, password)) != 0 ||\n\t    (r = sshpkt_add_padding(ssh, 64)) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0)\n\t\tfatal_fr(r, \"send packet\");\n\n\tfree(prompt);\n\tif (password != NULL)\n\t\tfreezero(password, strlen(password));\n\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_PASSWD_CHANGEREQ,\n\t    &input_userauth_passwd_changereq);\n\t\t\n\treturn 1;\n}",
        "func": "static int\nuserauth_passwd(struct ssh *ssh)\n{\n\tAuthctxt *authctxt = (Authctxt *)ssh->authctxt;\n\tauthctxt->is_trivial_auth = 0;\n\tchar *password, *prompt = NULL;\n\tconst char *host = options.host_key_alias ?  options.host_key_alias :\n\t    authctxt->host;\n\tint r;\n\n\tif (authctxt->attempt_passwd++ >= options.number_of_password_prompts)\n\t\treturn 0;\n\n\tif (authctxt->attempt_passwd != 1)\n\t\terror(\"Permission denied, please try again.\");\n\n\txasprintf(&prompt, \"%s@%s's password: \", authctxt->server_user, host);\n\tpassword = read_passphrase(prompt, 0);\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_USERAUTH_REQUEST)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, authctxt->server_user)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, authctxt->service)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, authctxt->method->name)) != 0 ||\n\t    (r = sshpkt_put_u8(ssh, 0)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, password)) != 0 ||\n\t    (r = sshpkt_add_padding(ssh, 64)) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0)\n\t\tfatal_fr(r, \"send packet\");\n\n\tfree(prompt);\n\tif (password != NULL)\n\t\tfreezero(password, strlen(password));\n\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_PASSWD_CHANGEREQ,\n\t    &input_userauth_passwd_changereq);\n\treturn 1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -32,6 +32,5 @@\n \n \tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_PASSWD_CHANGEREQ,\n \t    &input_userauth_passwd_changereq);\n-\t\t\n \treturn 1;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t"
            ],
            "added_lines": []
        }
    },
    {
        "cve_id": "CVE-2021-36368",
        "func_name": "openssh/openssh-portable/fill_default_options",
        "description": "An issue was discovered in OpenSSH before 8.9. If a client is using public-key authentication with agent forwarding but without -oLogLevel=verbose, and an attacker has silently modified the server to support the None authentication option, then the user cannot determine whether FIDO authentication is going to confirm that the user wishes to connect to that server, or that the user wishes to allow that server to connect to a different server on the user's behalf. NOTE: the vendor's position is \"this is not an authentication bypass, since nothing is being bypassed.",
        "git_url": "https://github.com/openssh/openssh-portable/commit/1c9963955eb769e25dd8f2cec7f8bceb169c8753",
        "commit_title": "added option to disable trivial auth methods",
        "commit_text": "",
        "func_before": "int\nfill_default_options(Options * options)\n{\n\tchar *all_cipher, *all_mac, *all_kex, *all_key, *all_sig;\n\tchar *def_cipher, *def_mac, *def_kex, *def_key, *def_sig;\n\tint ret = 0, r;\n\n\tif (options->forward_agent == -1)\n\t\toptions->forward_agent = 0;\n\tif (options->forward_x11 == -1)\n\t\toptions->forward_x11 = 0;\n\tif (options->forward_x11_trusted == -1)\n\t\toptions->forward_x11_trusted = 0;\n\tif (options->forward_x11_timeout == -1)\n\t\toptions->forward_x11_timeout = 1200;\n\t/*\n\t * stdio forwarding (-W) changes the default for these but we defer\n\t * setting the values so they can be overridden.\n\t */\n\tif (options->exit_on_forward_failure == -1)\n\t\toptions->exit_on_forward_failure =\n\t\t    options->stdio_forward_host != NULL ? 1 : 0;\n\tif (options->clear_forwardings == -1)\n\t\toptions->clear_forwardings =\n\t\t    options->stdio_forward_host != NULL ? 1 : 0;\n\tif (options->clear_forwardings == 1)\n\t\tclear_forwardings(options);\n\n\tif (options->xauth_location == NULL)\n\t\toptions->xauth_location = xstrdup(_PATH_XAUTH);\n\tif (options->fwd_opts.gateway_ports == -1)\n\t\toptions->fwd_opts.gateway_ports = 0;\n\tif (options->fwd_opts.streamlocal_bind_mask == (mode_t)-1)\n\t\toptions->fwd_opts.streamlocal_bind_mask = 0177;\n\tif (options->fwd_opts.streamlocal_bind_unlink == -1)\n\t\toptions->fwd_opts.streamlocal_bind_unlink = 0;\n\tif (options->pubkey_authentication == -1)\n\t\toptions->pubkey_authentication = 1;\n\tif (options->challenge_response_authentication == -1)\n\t\toptions->challenge_response_authentication = 1;\n\tif (options->gss_authentication == -1)\n\t\toptions->gss_authentication = 0;\n\tif (options->gss_deleg_creds == -1)\n\t\toptions->gss_deleg_creds = 0;\n\tif (options->password_authentication == -1)\n\t\toptions->password_authentication = 1;\n\tif (options->kbd_interactive_authentication == -1)\n\t\toptions->kbd_interactive_authentication = 1;\n\tif (options->hostbased_authentication == -1)\n\t\toptions->hostbased_authentication = 0;\n\tif (options->batch_mode == -1)\n\t\toptions->batch_mode = 0;\n\tif (options->check_host_ip == -1)\n\t\toptions->check_host_ip = 0;\n\tif (options->strict_host_key_checking == -1)\n\t\toptions->strict_host_key_checking = SSH_STRICT_HOSTKEY_ASK;\n\tif (options->compression == -1)\n\t\toptions->compression = 0;\n\tif (options->tcp_keep_alive == -1)\n\t\toptions->tcp_keep_alive = 1;\n\tif (options->port == -1)\n\t\toptions->port = 0;\t/* Filled in ssh_connect. */\n\tif (options->address_family == -1)\n\t\toptions->address_family = AF_UNSPEC;\n\tif (options->connection_attempts == -1)\n\t\toptions->connection_attempts = 1;\n\tif (options->number_of_password_prompts == -1)\n\t\toptions->number_of_password_prompts = 3;\n\t/* options->hostkeyalgorithms, default set in myproposals.h */\n\tif (options->add_keys_to_agent == -1) {\n\t\toptions->add_keys_to_agent = 0;\n\t\toptions->add_keys_to_agent_lifespan = 0;\n\t}\n\tif (options->num_identity_files == 0) {\n\t\tadd_identity_file(options, \"~/\", _PATH_SSH_CLIENT_ID_RSA, 0);\n\t\tadd_identity_file(options, \"~/\", _PATH_SSH_CLIENT_ID_DSA, 0);\n#ifdef OPENSSL_HAS_ECC\n\t\tadd_identity_file(options, \"~/\", _PATH_SSH_CLIENT_ID_ECDSA, 0);\n\t\tadd_identity_file(options, \"~/\",\n\t\t    _PATH_SSH_CLIENT_ID_ECDSA_SK, 0);\n#endif\n\t\tadd_identity_file(options, \"~/\",\n\t\t    _PATH_SSH_CLIENT_ID_ED25519, 0);\n\t\tadd_identity_file(options, \"~/\",\n\t\t    _PATH_SSH_CLIENT_ID_ED25519_SK, 0);\n\t\tadd_identity_file(options, \"~/\", _PATH_SSH_CLIENT_ID_XMSS, 0);\n\t}\n\tif (options->escape_char == -1)\n\t\toptions->escape_char = '~';\n\tif (options->num_system_hostfiles == 0) {\n\t\toptions->system_hostfiles[options->num_system_hostfiles++] =\n\t\t    xstrdup(_PATH_SSH_SYSTEM_HOSTFILE);\n\t\toptions->system_hostfiles[options->num_system_hostfiles++] =\n\t\t    xstrdup(_PATH_SSH_SYSTEM_HOSTFILE2);\n\t}\n\tif (options->update_hostkeys == -1) {\n\t\tif (options->verify_host_key_dns <= 0 &&\n\t\t    (options->num_user_hostfiles == 0 ||\n\t\t    (options->num_user_hostfiles == 1 && strcmp(options->\n\t\t    user_hostfiles[0], _PATH_SSH_USER_HOSTFILE) == 0)))\n\t\t\toptions->update_hostkeys = SSH_UPDATE_HOSTKEYS_YES;\n\t\telse\n\t\t\toptions->update_hostkeys = SSH_UPDATE_HOSTKEYS_NO;\n\t}\n\tif (options->num_user_hostfiles == 0) {\n\t\toptions->user_hostfiles[options->num_user_hostfiles++] =\n\t\t    xstrdup(_PATH_SSH_USER_HOSTFILE);\n\t\toptions->user_hostfiles[options->num_user_hostfiles++] =\n\t\t    xstrdup(_PATH_SSH_USER_HOSTFILE2);\n\t}\n\tif (options->log_level == SYSLOG_LEVEL_NOT_SET)\n\t\toptions->log_level = SYSLOG_LEVEL_INFO;\n\tif (options->log_facility == SYSLOG_FACILITY_NOT_SET)\n\t\toptions->log_facility = SYSLOG_FACILITY_USER;\n\tif (options->no_host_authentication_for_localhost == - 1)\n\t\toptions->no_host_authentication_for_localhost = 0;\n\tif (options->identities_only == -1)\n\t\toptions->identities_only = 0;\n\tif (options->enable_ssh_keysign == -1)\n\t\toptions->enable_ssh_keysign = 0;\n\tif (options->rekey_limit == -1)\n\t\toptions->rekey_limit = 0;\n\tif (options->rekey_interval == -1)\n\t\toptions->rekey_interval = 0;\n\tif (options->verify_host_key_dns == -1)\n\t\toptions->verify_host_key_dns = 0;\n\tif (options->server_alive_interval == -1)\n\t\toptions->server_alive_interval = 0;\n\tif (options->server_alive_count_max == -1)\n\t\toptions->server_alive_count_max = 3;\n\tif (options->control_master == -1)\n\t\toptions->control_master = 0;\n\tif (options->control_persist == -1) {\n\t\toptions->control_persist = 0;\n\t\toptions->control_persist_timeout = 0;\n\t}\n\tif (options->hash_known_hosts == -1)\n\t\toptions->hash_known_hosts = 0;\n\tif (options->tun_open == -1)\n\t\toptions->tun_open = SSH_TUNMODE_NO;\n\tif (options->tun_local == -1)\n\t\toptions->tun_local = SSH_TUNID_ANY;\n\tif (options->tun_remote == -1)\n\t\toptions->tun_remote = SSH_TUNID_ANY;\n\tif (options->permit_local_command == -1)\n\t\toptions->permit_local_command = 0;\n\tif (options->visual_host_key == -1)\n\t\toptions->visual_host_key = 0;\n\tif (options->ip_qos_interactive == -1)\n\t\toptions->ip_qos_interactive = IPTOS_DSCP_AF21;\n\tif (options->ip_qos_bulk == -1)\n\t\toptions->ip_qos_bulk = IPTOS_DSCP_CS1;\n\tif (options->request_tty == -1)\n\t\toptions->request_tty = REQUEST_TTY_AUTO;\n\tif (options->proxy_use_fdpass == -1)\n\t\toptions->proxy_use_fdpass = 0;\n\tif (options->canonicalize_max_dots == -1)\n\t\toptions->canonicalize_max_dots = 1;\n\tif (options->canonicalize_fallback_local == -1)\n\t\toptions->canonicalize_fallback_local = 1;\n\tif (options->canonicalize_hostname == -1)\n\t\toptions->canonicalize_hostname = SSH_CANONICALISE_NO;\n\tif (options->fingerprint_hash == -1)\n\t\toptions->fingerprint_hash = SSH_FP_HASH_DEFAULT;\n#ifdef ENABLE_SK_INTERNAL\n\tif (options->sk_provider == NULL)\n\t\toptions->sk_provider = xstrdup(\"internal\");\n#else\n\tif (options->sk_provider == NULL)\n\t\toptions->sk_provider = xstrdup(\"$SSH_SK_PROVIDER\");\n#endif\n\n\t/* Expand KEX name lists */\n\tall_cipher = cipher_alg_list(',', 0);\n\tall_mac = mac_alg_list(',');\n\tall_kex = kex_alg_list(',');\n\tall_key = sshkey_alg_list(0, 0, 1, ',');\n\tall_sig = sshkey_alg_list(0, 1, 1, ',');\n\t/* remove unsupported algos from default lists */\n\tdef_cipher = match_filter_allowlist(KEX_CLIENT_ENCRYPT, all_cipher);\n\tdef_mac = match_filter_allowlist(KEX_CLIENT_MAC, all_mac);\n\tdef_kex = match_filter_allowlist(KEX_CLIENT_KEX, all_kex);\n\tdef_key = match_filter_allowlist(KEX_DEFAULT_PK_ALG, all_key);\n\tdef_sig = match_filter_allowlist(SSH_ALLOWED_CA_SIGALGS, all_sig);\n#define ASSEMBLE(what, defaults, all) \\\n\tdo { \\\n\t\tif ((r = kex_assemble_names(&options->what, \\\n\t\t    defaults, all)) != 0) { \\\n\t\t\terror_fr(r, \"%s\", #what); \\\n\t\t\tgoto fail; \\\n\t\t} \\\n\t} while (0)\n\tASSEMBLE(ciphers, def_cipher, all_cipher);\n\tASSEMBLE(macs, def_mac, all_mac);\n\tASSEMBLE(kex_algorithms, def_kex, all_kex);\n\tASSEMBLE(hostbased_accepted_algos, def_key, all_key);\n\tASSEMBLE(pubkey_accepted_algos, def_key, all_key);\n\tASSEMBLE(ca_sign_algorithms, def_sig, all_sig);\n#undef ASSEMBLE\n\n#define CLEAR_ON_NONE(v) \\\n\tdo { \\\n\t\tif (option_clear_or_none(v)) { \\\n\t\t\tfree(v); \\\n\t\t\tv = NULL; \\\n\t\t} \\\n\t} while(0)\n\tCLEAR_ON_NONE(options->local_command);\n\tCLEAR_ON_NONE(options->remote_command);\n\tCLEAR_ON_NONE(options->proxy_command);\n\tCLEAR_ON_NONE(options->control_path);\n\tCLEAR_ON_NONE(options->revoked_host_keys);\n\tCLEAR_ON_NONE(options->pkcs11_provider);\n\tCLEAR_ON_NONE(options->sk_provider);\n\tCLEAR_ON_NONE(options->known_hosts_command);\n\tif (options->jump_host != NULL &&\n\t    strcmp(options->jump_host, \"none\") == 0 &&\n\t    options->jump_port == 0 && options->jump_user == NULL) {\n\t\tfree(options->jump_host);\n\t\toptions->jump_host = NULL;\n\t}\n\t/* options->identity_agent distinguishes NULL from 'none' */\n\t/* options->user will be set in the main program if appropriate */\n\t/* options->hostname will be set in the main program if appropriate */\n\t/* options->host_key_alias should not be set by default */\n\t/* options->preferred_authentications will be set in ssh */\n\n\t/* success */\n\tret = 0;\n fail:\n\tfree(all_cipher);\n\tfree(all_mac);\n\tfree(all_kex);\n\tfree(all_key);\n\tfree(all_sig);\n\tfree(def_cipher);\n\tfree(def_mac);\n\tfree(def_kex);\n\tfree(def_key);\n\tfree(def_sig);\n\treturn ret;\n}",
        "func": "int\nfill_default_options(Options * options)\n{\n\tchar *all_cipher, *all_mac, *all_kex, *all_key, *all_sig;\n\tchar *def_cipher, *def_mac, *def_kex, *def_key, *def_sig;\n\tint ret = 0, r;\n\n\tif (options->forward_agent == -1)\n\t\toptions->forward_agent = 0;\n\tif (options->forward_x11 == -1)\n\t\toptions->forward_x11 = 0;\n\tif (options->forward_x11_trusted == -1)\n\t\toptions->forward_x11_trusted = 0;\n\tif (options->forward_x11_timeout == -1)\n\t\toptions->forward_x11_timeout = 1200;\n\t/*\n\t * stdio forwarding (-W) changes the default for these but we defer\n\t * setting the values so they can be overridden.\n\t */\n\tif (options->exit_on_forward_failure == -1)\n\t\toptions->exit_on_forward_failure =\n\t\t    options->stdio_forward_host != NULL ? 1 : 0;\n\tif (options->clear_forwardings == -1)\n\t\toptions->clear_forwardings =\n\t\t    options->stdio_forward_host != NULL ? 1 : 0;\n\tif (options->clear_forwardings == 1)\n\t\tclear_forwardings(options);\n\n\tif (options->xauth_location == NULL)\n\t\toptions->xauth_location = xstrdup(_PATH_XAUTH);\n\tif (options->fwd_opts.gateway_ports == -1)\n\t\toptions->fwd_opts.gateway_ports = 0;\n\tif (options->fwd_opts.streamlocal_bind_mask == (mode_t)-1)\n\t\toptions->fwd_opts.streamlocal_bind_mask = 0177;\n\tif (options->fwd_opts.streamlocal_bind_unlink == -1)\n\t\toptions->fwd_opts.streamlocal_bind_unlink = 0;\n\tif (options->pubkey_authentication == -1)\n\t\toptions->pubkey_authentication = 1;\n\tif (options->challenge_response_authentication == -1)\n\t\toptions->challenge_response_authentication = 1;\n\tif (options->gss_authentication == -1)\n\t\toptions->gss_authentication = 0;\n\tif (options->gss_deleg_creds == -1)\n\t\toptions->gss_deleg_creds = 0;\n\tif (options->password_authentication == -1)\n\t\toptions->password_authentication = 1;\n\tif (options->kbd_interactive_authentication == -1)\n\t\toptions->kbd_interactive_authentication = 1;\n\tif (options->hostbased_authentication == -1)\n\t\toptions->hostbased_authentication = 0;\n\tif (options->disable_trivial_auth == -1)\n\t\toptions->disable_trivial_auth = 0;\n\tif (options->batch_mode == -1)\n\t\toptions->batch_mode = 0;\n\tif (options->check_host_ip == -1)\n\t\toptions->check_host_ip = 0;\n\tif (options->strict_host_key_checking == -1)\n\t\toptions->strict_host_key_checking = SSH_STRICT_HOSTKEY_ASK;\n\tif (options->compression == -1)\n\t\toptions->compression = 0;\n\tif (options->tcp_keep_alive == -1)\n\t\toptions->tcp_keep_alive = 1;\n\tif (options->port == -1)\n\t\toptions->port = 0;\t/* Filled in ssh_connect. */\n\tif (options->address_family == -1)\n\t\toptions->address_family = AF_UNSPEC;\n\tif (options->connection_attempts == -1)\n\t\toptions->connection_attempts = 1;\n\tif (options->number_of_password_prompts == -1)\n\t\toptions->number_of_password_prompts = 3;\n\t/* options->hostkeyalgorithms, default set in myproposals.h */\n\tif (options->add_keys_to_agent == -1) {\n\t\toptions->add_keys_to_agent = 0;\n\t\toptions->add_keys_to_agent_lifespan = 0;\n\t}\n\tif (options->num_identity_files == 0) {\n\t\tadd_identity_file(options, \"~/\", _PATH_SSH_CLIENT_ID_RSA, 0);\n\t\tadd_identity_file(options, \"~/\", _PATH_SSH_CLIENT_ID_DSA, 0);\n#ifdef OPENSSL_HAS_ECC\n\t\tadd_identity_file(options, \"~/\", _PATH_SSH_CLIENT_ID_ECDSA, 0);\n\t\tadd_identity_file(options, \"~/\",\n\t\t    _PATH_SSH_CLIENT_ID_ECDSA_SK, 0);\n#endif\n\t\tadd_identity_file(options, \"~/\",\n\t\t    _PATH_SSH_CLIENT_ID_ED25519, 0);\n\t\tadd_identity_file(options, \"~/\",\n\t\t    _PATH_SSH_CLIENT_ID_ED25519_SK, 0);\n\t\tadd_identity_file(options, \"~/\", _PATH_SSH_CLIENT_ID_XMSS, 0);\n\t}\n\tif (options->escape_char == -1)\n\t\toptions->escape_char = '~';\n\tif (options->num_system_hostfiles == 0) {\n\t\toptions->system_hostfiles[options->num_system_hostfiles++] =\n\t\t    xstrdup(_PATH_SSH_SYSTEM_HOSTFILE);\n\t\toptions->system_hostfiles[options->num_system_hostfiles++] =\n\t\t    xstrdup(_PATH_SSH_SYSTEM_HOSTFILE2);\n\t}\n\tif (options->update_hostkeys == -1) {\n\t\tif (options->verify_host_key_dns <= 0 &&\n\t\t    (options->num_user_hostfiles == 0 ||\n\t\t    (options->num_user_hostfiles == 1 && strcmp(options->\n\t\t    user_hostfiles[0], _PATH_SSH_USER_HOSTFILE) == 0)))\n\t\t\toptions->update_hostkeys = SSH_UPDATE_HOSTKEYS_YES;\n\t\telse\n\t\t\toptions->update_hostkeys = SSH_UPDATE_HOSTKEYS_NO;\n\t}\n\tif (options->num_user_hostfiles == 0) {\n\t\toptions->user_hostfiles[options->num_user_hostfiles++] =\n\t\t    xstrdup(_PATH_SSH_USER_HOSTFILE);\n\t\toptions->user_hostfiles[options->num_user_hostfiles++] =\n\t\t    xstrdup(_PATH_SSH_USER_HOSTFILE2);\n\t}\n\tif (options->log_level == SYSLOG_LEVEL_NOT_SET)\n\t\toptions->log_level = SYSLOG_LEVEL_INFO;\n\tif (options->log_facility == SYSLOG_FACILITY_NOT_SET)\n\t\toptions->log_facility = SYSLOG_FACILITY_USER;\n\tif (options->no_host_authentication_for_localhost == - 1)\n\t\toptions->no_host_authentication_for_localhost = 0;\n\tif (options->identities_only == -1)\n\t\toptions->identities_only = 0;\n\tif (options->enable_ssh_keysign == -1)\n\t\toptions->enable_ssh_keysign = 0;\n\tif (options->rekey_limit == -1)\n\t\toptions->rekey_limit = 0;\n\tif (options->rekey_interval == -1)\n\t\toptions->rekey_interval = 0;\n\tif (options->verify_host_key_dns == -1)\n\t\toptions->verify_host_key_dns = 0;\n\tif (options->server_alive_interval == -1)\n\t\toptions->server_alive_interval = 0;\n\tif (options->server_alive_count_max == -1)\n\t\toptions->server_alive_count_max = 3;\n\tif (options->control_master == -1)\n\t\toptions->control_master = 0;\n\tif (options->control_persist == -1) {\n\t\toptions->control_persist = 0;\n\t\toptions->control_persist_timeout = 0;\n\t}\n\tif (options->hash_known_hosts == -1)\n\t\toptions->hash_known_hosts = 0;\n\tif (options->tun_open == -1)\n\t\toptions->tun_open = SSH_TUNMODE_NO;\n\tif (options->tun_local == -1)\n\t\toptions->tun_local = SSH_TUNID_ANY;\n\tif (options->tun_remote == -1)\n\t\toptions->tun_remote = SSH_TUNID_ANY;\n\tif (options->permit_local_command == -1)\n\t\toptions->permit_local_command = 0;\n\tif (options->visual_host_key == -1)\n\t\toptions->visual_host_key = 0;\n\tif (options->ip_qos_interactive == -1)\n\t\toptions->ip_qos_interactive = IPTOS_DSCP_AF21;\n\tif (options->ip_qos_bulk == -1)\n\t\toptions->ip_qos_bulk = IPTOS_DSCP_CS1;\n\tif (options->request_tty == -1)\n\t\toptions->request_tty = REQUEST_TTY_AUTO;\n\tif (options->proxy_use_fdpass == -1)\n\t\toptions->proxy_use_fdpass = 0;\n\tif (options->canonicalize_max_dots == -1)\n\t\toptions->canonicalize_max_dots = 1;\n\tif (options->canonicalize_fallback_local == -1)\n\t\toptions->canonicalize_fallback_local = 1;\n\tif (options->canonicalize_hostname == -1)\n\t\toptions->canonicalize_hostname = SSH_CANONICALISE_NO;\n\tif (options->fingerprint_hash == -1)\n\t\toptions->fingerprint_hash = SSH_FP_HASH_DEFAULT;\n#ifdef ENABLE_SK_INTERNAL\n\tif (options->sk_provider == NULL)\n\t\toptions->sk_provider = xstrdup(\"internal\");\n#else\n\tif (options->sk_provider == NULL)\n\t\toptions->sk_provider = xstrdup(\"$SSH_SK_PROVIDER\");\n#endif\n\n\t/* Expand KEX name lists */\n\tall_cipher = cipher_alg_list(',', 0);\n\tall_mac = mac_alg_list(',');\n\tall_kex = kex_alg_list(',');\n\tall_key = sshkey_alg_list(0, 0, 1, ',');\n\tall_sig = sshkey_alg_list(0, 1, 1, ',');\n\t/* remove unsupported algos from default lists */\n\tdef_cipher = match_filter_allowlist(KEX_CLIENT_ENCRYPT, all_cipher);\n\tdef_mac = match_filter_allowlist(KEX_CLIENT_MAC, all_mac);\n\tdef_kex = match_filter_allowlist(KEX_CLIENT_KEX, all_kex);\n\tdef_key = match_filter_allowlist(KEX_DEFAULT_PK_ALG, all_key);\n\tdef_sig = match_filter_allowlist(SSH_ALLOWED_CA_SIGALGS, all_sig);\n#define ASSEMBLE(what, defaults, all) \\\n\tdo { \\\n\t\tif ((r = kex_assemble_names(&options->what, \\\n\t\t    defaults, all)) != 0) { \\\n\t\t\terror_fr(r, \"%s\", #what); \\\n\t\t\tgoto fail; \\\n\t\t} \\\n\t} while (0)\n\tASSEMBLE(ciphers, def_cipher, all_cipher);\n\tASSEMBLE(macs, def_mac, all_mac);\n\tASSEMBLE(kex_algorithms, def_kex, all_kex);\n\tASSEMBLE(hostbased_accepted_algos, def_key, all_key);\n\tASSEMBLE(pubkey_accepted_algos, def_key, all_key);\n\tASSEMBLE(ca_sign_algorithms, def_sig, all_sig);\n#undef ASSEMBLE\n\n#define CLEAR_ON_NONE(v) \\\n\tdo { \\\n\t\tif (option_clear_or_none(v)) { \\\n\t\t\tfree(v); \\\n\t\t\tv = NULL; \\\n\t\t} \\\n\t} while(0)\n\tCLEAR_ON_NONE(options->local_command);\n\tCLEAR_ON_NONE(options->remote_command);\n\tCLEAR_ON_NONE(options->proxy_command);\n\tCLEAR_ON_NONE(options->control_path);\n\tCLEAR_ON_NONE(options->revoked_host_keys);\n\tCLEAR_ON_NONE(options->pkcs11_provider);\n\tCLEAR_ON_NONE(options->sk_provider);\n\tCLEAR_ON_NONE(options->known_hosts_command);\n\tif (options->jump_host != NULL &&\n\t    strcmp(options->jump_host, \"none\") == 0 &&\n\t    options->jump_port == 0 && options->jump_user == NULL) {\n\t\tfree(options->jump_host);\n\t\toptions->jump_host = NULL;\n\t}\n\t/* options->identity_agent distinguishes NULL from 'none' */\n\t/* options->user will be set in the main program if appropriate */\n\t/* options->hostname will be set in the main program if appropriate */\n\t/* options->host_key_alias should not be set by default */\n\t/* options->preferred_authentications will be set in ssh */\n\n\t/* success */\n\tret = 0;\n fail:\n\tfree(all_cipher);\n\tfree(all_mac);\n\tfree(all_kex);\n\tfree(all_key);\n\tfree(all_sig);\n\tfree(def_cipher);\n\tfree(def_mac);\n\tfree(def_kex);\n\tfree(def_key);\n\tfree(def_sig);\n\treturn ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -48,6 +48,8 @@\n \t\toptions->kbd_interactive_authentication = 1;\n \tif (options->hostbased_authentication == -1)\n \t\toptions->hostbased_authentication = 0;\n+\tif (options->disable_trivial_auth == -1)\n+\t\toptions->disable_trivial_auth = 0;\n \tif (options->batch_mode == -1)\n \t\toptions->batch_mode = 0;\n \tif (options->check_host_ip == -1)",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tif (options->disable_trivial_auth == -1)",
                "\t\toptions->disable_trivial_auth = 0;"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-36368",
        "func_name": "openssh/openssh-portable/dump_client_config",
        "description": "An issue was discovered in OpenSSH before 8.9. If a client is using public-key authentication with agent forwarding but without -oLogLevel=verbose, and an attacker has silently modified the server to support the None authentication option, then the user cannot determine whether FIDO authentication is going to confirm that the user wishes to connect to that server, or that the user wishes to allow that server to connect to a different server on the user's behalf. NOTE: the vendor's position is \"this is not an authentication bypass, since nothing is being bypassed.",
        "git_url": "https://github.com/openssh/openssh-portable/commit/1c9963955eb769e25dd8f2cec7f8bceb169c8753",
        "commit_title": "added option to disable trivial auth methods",
        "commit_text": "",
        "func_before": "void\ndump_client_config(Options *o, const char *host)\n{\n\tint i, r;\n\tchar buf[8], *all_key;\n\n\t/*\n\t * Expand HostKeyAlgorithms name lists. This isn't handled in\n\t * fill_default_options() like the other algorithm lists because\n\t * the host key algorithms are by default dynamically chosen based\n\t * on the host's keys found in known_hosts.\n\t */\n\tall_key = sshkey_alg_list(0, 0, 1, ',');\n\tif ((r = kex_assemble_names(&o->hostkeyalgorithms, kex_default_pk_alg(),\n\t    all_key)) != 0)\n\t\tfatal_fr(r, \"expand HostKeyAlgorithms\");\n\tfree(all_key);\n\n\t/* Most interesting options first: user, host, port */\n\tdump_cfg_string(oUser, o->user);\n\tdump_cfg_string(oHostname, host);\n\tdump_cfg_int(oPort, o->port);\n\n\t/* Flag options */\n\tdump_cfg_fmtint(oAddressFamily, o->address_family);\n\tdump_cfg_fmtint(oBatchMode, o->batch_mode);\n\tdump_cfg_fmtint(oCanonicalizeFallbackLocal, o->canonicalize_fallback_local);\n\tdump_cfg_fmtint(oCanonicalizeHostname, o->canonicalize_hostname);\n\tdump_cfg_fmtint(oChallengeResponseAuthentication, o->challenge_response_authentication);\n\tdump_cfg_fmtint(oCheckHostIP, o->check_host_ip);\n\tdump_cfg_fmtint(oCompression, o->compression);\n\tdump_cfg_fmtint(oControlMaster, o->control_master);\n\tdump_cfg_fmtint(oEnableSSHKeysign, o->enable_ssh_keysign);\n\tdump_cfg_fmtint(oClearAllForwardings, o->clear_forwardings);\n\tdump_cfg_fmtint(oExitOnForwardFailure, o->exit_on_forward_failure);\n\tdump_cfg_fmtint(oFingerprintHash, o->fingerprint_hash);\n\tdump_cfg_fmtint(oForwardX11, o->forward_x11);\n\tdump_cfg_fmtint(oForwardX11Trusted, o->forward_x11_trusted);\n\tdump_cfg_fmtint(oGatewayPorts, o->fwd_opts.gateway_ports);\n#ifdef GSSAPI\n\tdump_cfg_fmtint(oGssAuthentication, o->gss_authentication);\n\tdump_cfg_fmtint(oGssDelegateCreds, o->gss_deleg_creds);\n#endif /* GSSAPI */\n\tdump_cfg_fmtint(oHashKnownHosts, o->hash_known_hosts);\n\tdump_cfg_fmtint(oHostbasedAuthentication, o->hostbased_authentication);\n\tdump_cfg_fmtint(oIdentitiesOnly, o->identities_only);\n\tdump_cfg_fmtint(oKbdInteractiveAuthentication, o->kbd_interactive_authentication);\n\tdump_cfg_fmtint(oNoHostAuthenticationForLocalhost, o->no_host_authentication_for_localhost);\n\tdump_cfg_fmtint(oPasswordAuthentication, o->password_authentication);\n\tdump_cfg_fmtint(oPermitLocalCommand, o->permit_local_command);\n\tdump_cfg_fmtint(oProxyUseFdpass, o->proxy_use_fdpass);\n\tdump_cfg_fmtint(oPubkeyAuthentication, o->pubkey_authentication);\n\tdump_cfg_fmtint(oRequestTTY, o->request_tty);\n\tdump_cfg_fmtint(oStreamLocalBindUnlink, o->fwd_opts.streamlocal_bind_unlink);\n\tdump_cfg_fmtint(oStrictHostKeyChecking, o->strict_host_key_checking);\n\tdump_cfg_fmtint(oTCPKeepAlive, o->tcp_keep_alive);\n\tdump_cfg_fmtint(oTunnel, o->tun_open);\n\tdump_cfg_fmtint(oVerifyHostKeyDNS, o->verify_host_key_dns);\n\tdump_cfg_fmtint(oVisualHostKey, o->visual_host_key);\n\tdump_cfg_fmtint(oUpdateHostkeys, o->update_hostkeys);\n\n\t/* Integer options */\n\tdump_cfg_int(oCanonicalizeMaxDots, o->canonicalize_max_dots);\n\tdump_cfg_int(oConnectionAttempts, o->connection_attempts);\n\tdump_cfg_int(oForwardX11Timeout, o->forward_x11_timeout);\n\tdump_cfg_int(oNumberOfPasswordPrompts, o->number_of_password_prompts);\n\tdump_cfg_int(oServerAliveCountMax, o->server_alive_count_max);\n\tdump_cfg_int(oServerAliveInterval, o->server_alive_interval);\n\n\t/* String options */\n\tdump_cfg_string(oBindAddress, o->bind_address);\n\tdump_cfg_string(oBindInterface, o->bind_interface);\n\tdump_cfg_string(oCiphers, o->ciphers);\n\tdump_cfg_string(oControlPath, o->control_path);\n\tdump_cfg_string(oHostKeyAlgorithms, o->hostkeyalgorithms);\n\tdump_cfg_string(oHostKeyAlias, o->host_key_alias);\n\tdump_cfg_string(oHostbasedAcceptedAlgorithms, o->hostbased_accepted_algos);\n\tdump_cfg_string(oIdentityAgent, o->identity_agent);\n\tdump_cfg_string(oIgnoreUnknown, o->ignored_unknown);\n\tdump_cfg_string(oKbdInteractiveDevices, o->kbd_interactive_devices);\n\tdump_cfg_string(oKexAlgorithms, o->kex_algorithms);\n\tdump_cfg_string(oCASignatureAlgorithms, o->ca_sign_algorithms);\n\tdump_cfg_string(oLocalCommand, o->local_command);\n\tdump_cfg_string(oRemoteCommand, o->remote_command);\n\tdump_cfg_string(oLogLevel, log_level_name(o->log_level));\n\tdump_cfg_string(oMacs, o->macs);\n#ifdef ENABLE_PKCS11\n\tdump_cfg_string(oPKCS11Provider, o->pkcs11_provider);\n#endif\n\tdump_cfg_string(oSecurityKeyProvider, o->sk_provider);\n\tdump_cfg_string(oPreferredAuthentications, o->preferred_authentications);\n\tdump_cfg_string(oPubkeyAcceptedAlgorithms, o->pubkey_accepted_algos);\n\tdump_cfg_string(oRevokedHostKeys, o->revoked_host_keys);\n\tdump_cfg_string(oXAuthLocation, o->xauth_location);\n\tdump_cfg_string(oKnownHostsCommand, o->known_hosts_command);\n\n\t/* Forwards */\n\tdump_cfg_forwards(oDynamicForward, o->num_local_forwards, o->local_forwards);\n\tdump_cfg_forwards(oLocalForward, o->num_local_forwards, o->local_forwards);\n\tdump_cfg_forwards(oRemoteForward, o->num_remote_forwards, o->remote_forwards);\n\n\t/* String array options */\n\tdump_cfg_strarray(oIdentityFile, o->num_identity_files, o->identity_files);\n\tdump_cfg_strarray_oneline(oCanonicalDomains, o->num_canonical_domains, o->canonical_domains);\n\tdump_cfg_strarray(oCertificateFile, o->num_certificate_files, o->certificate_files);\n\tdump_cfg_strarray_oneline(oGlobalKnownHostsFile, o->num_system_hostfiles, o->system_hostfiles);\n\tdump_cfg_strarray_oneline(oUserKnownHostsFile, o->num_user_hostfiles, o->user_hostfiles);\n\tdump_cfg_strarray(oSendEnv, o->num_send_env, o->send_env);\n\tdump_cfg_strarray(oSetEnv, o->num_setenv, o->setenv);\n\tdump_cfg_strarray_oneline(oLogVerbose,\n\t    o->num_log_verbose, o->log_verbose);\n\n\t/* Special cases */\n\n\t/* PermitRemoteOpen */\n\tif (o->num_permitted_remote_opens == 0)\n\t\tprintf(\"%s any\\n\", lookup_opcode_name(oPermitRemoteOpen));\n\telse\n\t\tdump_cfg_strarray_oneline(oPermitRemoteOpen,\n\t\t    o->num_permitted_remote_opens, o->permitted_remote_opens);\n\n\t/* AddKeysToAgent */\n\tif (o->add_keys_to_agent_lifespan <= 0)\n\t\tdump_cfg_fmtint(oAddKeysToAgent, o->add_keys_to_agent);\n\telse {\n\t\tprintf(\"addkeystoagent%s %d\\n\",\n\t\t    o->add_keys_to_agent == 3 ? \" confirm\" : \"\",\n\t\t    o->add_keys_to_agent_lifespan);\n\t}\n\n\t/* oForwardAgent */\n\tif (o->forward_agent_sock_path == NULL)\n\t\tdump_cfg_fmtint(oForwardAgent, o->forward_agent);\n\telse\n\t\tdump_cfg_string(oForwardAgent, o->forward_agent_sock_path);\n\n\t/* oConnectTimeout */\n\tif (o->connection_timeout == -1)\n\t\tprintf(\"connecttimeout none\\n\");\n\telse\n\t\tdump_cfg_int(oConnectTimeout, o->connection_timeout);\n\n\t/* oTunnelDevice */\n\tprintf(\"tunneldevice\");\n\tif (o->tun_local == SSH_TUNID_ANY)\n\t\tprintf(\" any\");\n\telse\n\t\tprintf(\" %d\", o->tun_local);\n\tif (o->tun_remote == SSH_TUNID_ANY)\n\t\tprintf(\":any\");\n\telse\n\t\tprintf(\":%d\", o->tun_remote);\n\tprintf(\"\\n\");\n\n\t/* oCanonicalizePermittedCNAMEs */\n\tif ( o->num_permitted_cnames > 0) {\n\t\tprintf(\"canonicalizePermittedcnames\");\n\t\tfor (i = 0; i < o->num_permitted_cnames; i++) {\n\t\t\tprintf(\" %s:%s\", o->permitted_cnames[i].source_list,\n\t\t\t    o->permitted_cnames[i].target_list);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\n\t/* oControlPersist */\n\tif (o->control_persist == 0 || o->control_persist_timeout == 0)\n\t\tdump_cfg_fmtint(oControlPersist, o->control_persist);\n\telse\n\t\tdump_cfg_int(oControlPersist, o->control_persist_timeout);\n\n\t/* oEscapeChar */\n\tif (o->escape_char == SSH_ESCAPECHAR_NONE)\n\t\tprintf(\"escapechar none\\n\");\n\telse {\n\t\tvis(buf, o->escape_char, VIS_WHITE, 0);\n\t\tprintf(\"escapechar %s\\n\", buf);\n\t}\n\n\t/* oIPQoS */\n\tprintf(\"ipqos %s \", iptos2str(o->ip_qos_interactive));\n\tprintf(\"%s\\n\", iptos2str(o->ip_qos_bulk));\n\n\t/* oRekeyLimit */\n\tprintf(\"rekeylimit %llu %d\\n\",\n\t    (unsigned long long)o->rekey_limit, o->rekey_interval);\n\n\t/* oStreamLocalBindMask */\n\tprintf(\"streamlocalbindmask 0%o\\n\",\n\t    o->fwd_opts.streamlocal_bind_mask);\n\n\t/* oLogFacility */\n\tprintf(\"syslogfacility %s\\n\", log_facility_name(o->log_facility));\n\n\t/* oProxyCommand / oProxyJump */\n\tif (o->jump_host == NULL)\n\t\tdump_cfg_string(oProxyCommand, o->proxy_command);\n\telse {\n\t\t/* Check for numeric addresses */\n\t\ti = strchr(o->jump_host, ':') != NULL ||\n\t\t    strspn(o->jump_host, \"1234567890.\") == strlen(o->jump_host);\n\t\tsnprintf(buf, sizeof(buf), \"%d\", o->jump_port);\n\t\tprintf(\"proxyjump %s%s%s%s%s%s%s%s%s\\n\",\n\t\t    /* optional additional jump spec */\n\t\t    o->jump_extra == NULL ? \"\" : o->jump_extra,\n\t\t    o->jump_extra == NULL ? \"\" : \",\",\n\t\t    /* optional user */\n\t\t    o->jump_user == NULL ? \"\" : o->jump_user,\n\t\t    o->jump_user == NULL ? \"\" : \"@\",\n\t\t    /* opening [ if hostname is numeric */\n\t\t    i ? \"[\" : \"\",\n\t\t    /* mandatory hostname */\n\t\t    o->jump_host,\n\t\t    /* closing ] if hostname is numeric */\n\t\t    i ? \"]\" : \"\",\n\t\t    /* optional port number */\n\t\t    o->jump_port <= 0 ? \"\" : \":\",\n\t\t    o->jump_port <= 0 ? \"\" : buf);\n\t}\n}",
        "func": "void\ndump_client_config(Options *o, const char *host)\n{\n\tint i, r;\n\tchar buf[8], *all_key;\n\n\t/*\n\t * Expand HostKeyAlgorithms name lists. This isn't handled in\n\t * fill_default_options() like the other algorithm lists because\n\t * the host key algorithms are by default dynamically chosen based\n\t * on the host's keys found in known_hosts.\n\t */\n\tall_key = sshkey_alg_list(0, 0, 1, ',');\n\tif ((r = kex_assemble_names(&o->hostkeyalgorithms, kex_default_pk_alg(),\n\t    all_key)) != 0)\n\t\tfatal_fr(r, \"expand HostKeyAlgorithms\");\n\tfree(all_key);\n\n\t/* Most interesting options first: user, host, port */\n\tdump_cfg_string(oUser, o->user);\n\tdump_cfg_string(oHostname, host);\n\tdump_cfg_int(oPort, o->port);\n\n\t/* Flag options */\n\tdump_cfg_fmtint(oAddressFamily, o->address_family);\n\tdump_cfg_fmtint(oBatchMode, o->batch_mode);\n\tdump_cfg_fmtint(oCanonicalizeFallbackLocal, o->canonicalize_fallback_local);\n\tdump_cfg_fmtint(oCanonicalizeHostname, o->canonicalize_hostname);\n\tdump_cfg_fmtint(oChallengeResponseAuthentication, o->challenge_response_authentication);\n\tdump_cfg_fmtint(oCheckHostIP, o->check_host_ip);\n\tdump_cfg_fmtint(oCompression, o->compression);\n\tdump_cfg_fmtint(oControlMaster, o->control_master);\n\tdump_cfg_fmtint(oEnableSSHKeysign, o->enable_ssh_keysign);\n\tdump_cfg_fmtint(oClearAllForwardings, o->clear_forwardings);\n\tdump_cfg_fmtint(oExitOnForwardFailure, o->exit_on_forward_failure);\n\tdump_cfg_fmtint(oFingerprintHash, o->fingerprint_hash);\n\tdump_cfg_fmtint(oForwardX11, o->forward_x11);\n\tdump_cfg_fmtint(oForwardX11Trusted, o->forward_x11_trusted);\n\tdump_cfg_fmtint(oGatewayPorts, o->fwd_opts.gateway_ports);\n#ifdef GSSAPI\n\tdump_cfg_fmtint(oGssAuthentication, o->gss_authentication);\n\tdump_cfg_fmtint(oGssDelegateCreds, o->gss_deleg_creds);\n#endif /* GSSAPI */\n\tdump_cfg_fmtint(oHashKnownHosts, o->hash_known_hosts);\n\tdump_cfg_fmtint(oHostbasedAuthentication, o->hostbased_authentication);\n\tdump_cfg_fmtint(oDisableTrivialAuth, o->disable_trivial_auth);\n\tdump_cfg_fmtint(oIdentitiesOnly, o->identities_only);\n\tdump_cfg_fmtint(oKbdInteractiveAuthentication, o->kbd_interactive_authentication);\n\tdump_cfg_fmtint(oNoHostAuthenticationForLocalhost, o->no_host_authentication_for_localhost);\n\tdump_cfg_fmtint(oPasswordAuthentication, o->password_authentication);\n\tdump_cfg_fmtint(oPermitLocalCommand, o->permit_local_command);\n\tdump_cfg_fmtint(oProxyUseFdpass, o->proxy_use_fdpass);\n\tdump_cfg_fmtint(oPubkeyAuthentication, o->pubkey_authentication);\n\tdump_cfg_fmtint(oRequestTTY, o->request_tty);\n\tdump_cfg_fmtint(oStreamLocalBindUnlink, o->fwd_opts.streamlocal_bind_unlink);\n\tdump_cfg_fmtint(oStrictHostKeyChecking, o->strict_host_key_checking);\n\tdump_cfg_fmtint(oTCPKeepAlive, o->tcp_keep_alive);\n\tdump_cfg_fmtint(oTunnel, o->tun_open);\n\tdump_cfg_fmtint(oVerifyHostKeyDNS, o->verify_host_key_dns);\n\tdump_cfg_fmtint(oVisualHostKey, o->visual_host_key);\n\tdump_cfg_fmtint(oUpdateHostkeys, o->update_hostkeys);\n\n\t/* Integer options */\n\tdump_cfg_int(oCanonicalizeMaxDots, o->canonicalize_max_dots);\n\tdump_cfg_int(oConnectionAttempts, o->connection_attempts);\n\tdump_cfg_int(oForwardX11Timeout, o->forward_x11_timeout);\n\tdump_cfg_int(oNumberOfPasswordPrompts, o->number_of_password_prompts);\n\tdump_cfg_int(oServerAliveCountMax, o->server_alive_count_max);\n\tdump_cfg_int(oServerAliveInterval, o->server_alive_interval);\n\n\t/* String options */\n\tdump_cfg_string(oBindAddress, o->bind_address);\n\tdump_cfg_string(oBindInterface, o->bind_interface);\n\tdump_cfg_string(oCiphers, o->ciphers);\n\tdump_cfg_string(oControlPath, o->control_path);\n\tdump_cfg_string(oHostKeyAlgorithms, o->hostkeyalgorithms);\n\tdump_cfg_string(oHostKeyAlias, o->host_key_alias);\n\tdump_cfg_string(oHostbasedAcceptedAlgorithms, o->hostbased_accepted_algos);\n\tdump_cfg_string(oIdentityAgent, o->identity_agent);\n\tdump_cfg_string(oIgnoreUnknown, o->ignored_unknown);\n\tdump_cfg_string(oKbdInteractiveDevices, o->kbd_interactive_devices);\n\tdump_cfg_string(oKexAlgorithms, o->kex_algorithms);\n\tdump_cfg_string(oCASignatureAlgorithms, o->ca_sign_algorithms);\n\tdump_cfg_string(oLocalCommand, o->local_command);\n\tdump_cfg_string(oRemoteCommand, o->remote_command);\n\tdump_cfg_string(oLogLevel, log_level_name(o->log_level));\n\tdump_cfg_string(oMacs, o->macs);\n#ifdef ENABLE_PKCS11\n\tdump_cfg_string(oPKCS11Provider, o->pkcs11_provider);\n#endif\n\tdump_cfg_string(oSecurityKeyProvider, o->sk_provider);\n\tdump_cfg_string(oPreferredAuthentications, o->preferred_authentications);\n\tdump_cfg_string(oPubkeyAcceptedAlgorithms, o->pubkey_accepted_algos);\n\tdump_cfg_string(oRevokedHostKeys, o->revoked_host_keys);\n\tdump_cfg_string(oXAuthLocation, o->xauth_location);\n\tdump_cfg_string(oKnownHostsCommand, o->known_hosts_command);\n\n\t/* Forwards */\n\tdump_cfg_forwards(oDynamicForward, o->num_local_forwards, o->local_forwards);\n\tdump_cfg_forwards(oLocalForward, o->num_local_forwards, o->local_forwards);\n\tdump_cfg_forwards(oRemoteForward, o->num_remote_forwards, o->remote_forwards);\n\n\t/* String array options */\n\tdump_cfg_strarray(oIdentityFile, o->num_identity_files, o->identity_files);\n\tdump_cfg_strarray_oneline(oCanonicalDomains, o->num_canonical_domains, o->canonical_domains);\n\tdump_cfg_strarray(oCertificateFile, o->num_certificate_files, o->certificate_files);\n\tdump_cfg_strarray_oneline(oGlobalKnownHostsFile, o->num_system_hostfiles, o->system_hostfiles);\n\tdump_cfg_strarray_oneline(oUserKnownHostsFile, o->num_user_hostfiles, o->user_hostfiles);\n\tdump_cfg_strarray(oSendEnv, o->num_send_env, o->send_env);\n\tdump_cfg_strarray(oSetEnv, o->num_setenv, o->setenv);\n\tdump_cfg_strarray_oneline(oLogVerbose,\n\t    o->num_log_verbose, o->log_verbose);\n\n\t/* Special cases */\n\n\t/* PermitRemoteOpen */\n\tif (o->num_permitted_remote_opens == 0)\n\t\tprintf(\"%s any\\n\", lookup_opcode_name(oPermitRemoteOpen));\n\telse\n\t\tdump_cfg_strarray_oneline(oPermitRemoteOpen,\n\t\t    o->num_permitted_remote_opens, o->permitted_remote_opens);\n\n\t/* AddKeysToAgent */\n\tif (o->add_keys_to_agent_lifespan <= 0)\n\t\tdump_cfg_fmtint(oAddKeysToAgent, o->add_keys_to_agent);\n\telse {\n\t\tprintf(\"addkeystoagent%s %d\\n\",\n\t\t    o->add_keys_to_agent == 3 ? \" confirm\" : \"\",\n\t\t    o->add_keys_to_agent_lifespan);\n\t}\n\n\t/* oForwardAgent */\n\tif (o->forward_agent_sock_path == NULL)\n\t\tdump_cfg_fmtint(oForwardAgent, o->forward_agent);\n\telse\n\t\tdump_cfg_string(oForwardAgent, o->forward_agent_sock_path);\n\n\t/* oConnectTimeout */\n\tif (o->connection_timeout == -1)\n\t\tprintf(\"connecttimeout none\\n\");\n\telse\n\t\tdump_cfg_int(oConnectTimeout, o->connection_timeout);\n\n\t/* oTunnelDevice */\n\tprintf(\"tunneldevice\");\n\tif (o->tun_local == SSH_TUNID_ANY)\n\t\tprintf(\" any\");\n\telse\n\t\tprintf(\" %d\", o->tun_local);\n\tif (o->tun_remote == SSH_TUNID_ANY)\n\t\tprintf(\":any\");\n\telse\n\t\tprintf(\":%d\", o->tun_remote);\n\tprintf(\"\\n\");\n\n\t/* oCanonicalizePermittedCNAMEs */\n\tif ( o->num_permitted_cnames > 0) {\n\t\tprintf(\"canonicalizePermittedcnames\");\n\t\tfor (i = 0; i < o->num_permitted_cnames; i++) {\n\t\t\tprintf(\" %s:%s\", o->permitted_cnames[i].source_list,\n\t\t\t    o->permitted_cnames[i].target_list);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\n\t/* oControlPersist */\n\tif (o->control_persist == 0 || o->control_persist_timeout == 0)\n\t\tdump_cfg_fmtint(oControlPersist, o->control_persist);\n\telse\n\t\tdump_cfg_int(oControlPersist, o->control_persist_timeout);\n\n\t/* oEscapeChar */\n\tif (o->escape_char == SSH_ESCAPECHAR_NONE)\n\t\tprintf(\"escapechar none\\n\");\n\telse {\n\t\tvis(buf, o->escape_char, VIS_WHITE, 0);\n\t\tprintf(\"escapechar %s\\n\", buf);\n\t}\n\n\t/* oIPQoS */\n\tprintf(\"ipqos %s \", iptos2str(o->ip_qos_interactive));\n\tprintf(\"%s\\n\", iptos2str(o->ip_qos_bulk));\n\n\t/* oRekeyLimit */\n\tprintf(\"rekeylimit %llu %d\\n\",\n\t    (unsigned long long)o->rekey_limit, o->rekey_interval);\n\n\t/* oStreamLocalBindMask */\n\tprintf(\"streamlocalbindmask 0%o\\n\",\n\t    o->fwd_opts.streamlocal_bind_mask);\n\n\t/* oLogFacility */\n\tprintf(\"syslogfacility %s\\n\", log_facility_name(o->log_facility));\n\n\t/* oProxyCommand / oProxyJump */\n\tif (o->jump_host == NULL)\n\t\tdump_cfg_string(oProxyCommand, o->proxy_command);\n\telse {\n\t\t/* Check for numeric addresses */\n\t\ti = strchr(o->jump_host, ':') != NULL ||\n\t\t    strspn(o->jump_host, \"1234567890.\") == strlen(o->jump_host);\n\t\tsnprintf(buf, sizeof(buf), \"%d\", o->jump_port);\n\t\tprintf(\"proxyjump %s%s%s%s%s%s%s%s%s\\n\",\n\t\t    /* optional additional jump spec */\n\t\t    o->jump_extra == NULL ? \"\" : o->jump_extra,\n\t\t    o->jump_extra == NULL ? \"\" : \",\",\n\t\t    /* optional user */\n\t\t    o->jump_user == NULL ? \"\" : o->jump_user,\n\t\t    o->jump_user == NULL ? \"\" : \"@\",\n\t\t    /* opening [ if hostname is numeric */\n\t\t    i ? \"[\" : \"\",\n\t\t    /* mandatory hostname */\n\t\t    o->jump_host,\n\t\t    /* closing ] if hostname is numeric */\n\t\t    i ? \"]\" : \"\",\n\t\t    /* optional port number */\n\t\t    o->jump_port <= 0 ? \"\" : \":\",\n\t\t    o->jump_port <= 0 ? \"\" : buf);\n\t}\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -43,6 +43,7 @@\n #endif /* GSSAPI */\n \tdump_cfg_fmtint(oHashKnownHosts, o->hash_known_hosts);\n \tdump_cfg_fmtint(oHostbasedAuthentication, o->hostbased_authentication);\n+\tdump_cfg_fmtint(oDisableTrivialAuth, o->disable_trivial_auth);\n \tdump_cfg_fmtint(oIdentitiesOnly, o->identities_only);\n \tdump_cfg_fmtint(oKbdInteractiveAuthentication, o->kbd_interactive_authentication);\n \tdump_cfg_fmtint(oNoHostAuthenticationForLocalhost, o->no_host_authentication_for_localhost);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tdump_cfg_fmtint(oDisableTrivialAuth, o->disable_trivial_auth);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-36368",
        "func_name": "openssh/openssh-portable/initialize_options",
        "description": "An issue was discovered in OpenSSH before 8.9. If a client is using public-key authentication with agent forwarding but without -oLogLevel=verbose, and an attacker has silently modified the server to support the None authentication option, then the user cannot determine whether FIDO authentication is going to confirm that the user wishes to connect to that server, or that the user wishes to allow that server to connect to a different server on the user's behalf. NOTE: the vendor's position is \"this is not an authentication bypass, since nothing is being bypassed.",
        "git_url": "https://github.com/openssh/openssh-portable/commit/1c9963955eb769e25dd8f2cec7f8bceb169c8753",
        "commit_title": "added option to disable trivial auth methods",
        "commit_text": "",
        "func_before": "void\ninitialize_options(Options * options)\n{\n\tmemset(options, 'X', sizeof(*options));\n\toptions->forward_agent = -1;\n\toptions->forward_agent_sock_path = NULL;\n\toptions->forward_x11 = -1;\n\toptions->forward_x11_trusted = -1;\n\toptions->forward_x11_timeout = -1;\n\toptions->stdio_forward_host = NULL;\n\toptions->stdio_forward_port = 0;\n\toptions->clear_forwardings = -1;\n\toptions->exit_on_forward_failure = -1;\n\toptions->xauth_location = NULL;\n\toptions->fwd_opts.gateway_ports = -1;\n\toptions->fwd_opts.streamlocal_bind_mask = (mode_t)-1;\n\toptions->fwd_opts.streamlocal_bind_unlink = -1;\n\toptions->pubkey_authentication = -1;\n\toptions->challenge_response_authentication = -1;\n\toptions->gss_authentication = -1;\n\toptions->gss_deleg_creds = -1;\n\toptions->password_authentication = -1;\n\toptions->kbd_interactive_authentication = -1;\n\toptions->kbd_interactive_devices = NULL;\n\toptions->hostbased_authentication = -1;\n\toptions->batch_mode = -1;\n\toptions->check_host_ip = -1;\n\toptions->strict_host_key_checking = -1;\n\toptions->compression = -1;\n\toptions->tcp_keep_alive = -1;\n\toptions->port = -1;\n\toptions->address_family = -1;\n\toptions->connection_attempts = -1;\n\toptions->connection_timeout = -1;\n\toptions->number_of_password_prompts = -1;\n\toptions->ciphers = NULL;\n\toptions->macs = NULL;\n\toptions->kex_algorithms = NULL;\n\toptions->hostkeyalgorithms = NULL;\n\toptions->ca_sign_algorithms = NULL;\n\toptions->num_identity_files = 0;\n\tmemset(options->identity_keys, 0, sizeof(options->identity_keys));\n\toptions->num_certificate_files = 0;\n\tmemset(options->certificates, 0, sizeof(options->certificates));\n\toptions->hostname = NULL;\n\toptions->host_key_alias = NULL;\n\toptions->proxy_command = NULL;\n\toptions->jump_user = NULL;\n\toptions->jump_host = NULL;\n\toptions->jump_port = -1;\n\toptions->jump_extra = NULL;\n\toptions->user = NULL;\n\toptions->escape_char = -1;\n\toptions->num_system_hostfiles = 0;\n\toptions->num_user_hostfiles = 0;\n\toptions->local_forwards = NULL;\n\toptions->num_local_forwards = 0;\n\toptions->remote_forwards = NULL;\n\toptions->num_remote_forwards = 0;\n\toptions->permitted_remote_opens = NULL;\n\toptions->num_permitted_remote_opens = 0;\n\toptions->log_facility = SYSLOG_FACILITY_NOT_SET;\n\toptions->log_level = SYSLOG_LEVEL_NOT_SET;\n\toptions->num_log_verbose = 0;\n\toptions->log_verbose = NULL;\n\toptions->preferred_authentications = NULL;\n\toptions->bind_address = NULL;\n\toptions->bind_interface = NULL;\n\toptions->pkcs11_provider = NULL;\n\toptions->sk_provider = NULL;\n\toptions->enable_ssh_keysign = - 1;\n\toptions->no_host_authentication_for_localhost = - 1;\n\toptions->identities_only = - 1;\n\toptions->rekey_limit = - 1;\n\toptions->rekey_interval = -1;\n\toptions->verify_host_key_dns = -1;\n\toptions->server_alive_interval = -1;\n\toptions->server_alive_count_max = -1;\n\toptions->send_env = NULL;\n\toptions->num_send_env = 0;\n\toptions->setenv = NULL;\n\toptions->num_setenv = 0;\n\toptions->control_path = NULL;\n\toptions->control_master = -1;\n\toptions->control_persist = -1;\n\toptions->control_persist_timeout = 0;\n\toptions->hash_known_hosts = -1;\n\toptions->tun_open = -1;\n\toptions->tun_local = -1;\n\toptions->tun_remote = -1;\n\toptions->local_command = NULL;\n\toptions->permit_local_command = -1;\n\toptions->remote_command = NULL;\n\toptions->add_keys_to_agent = -1;\n\toptions->add_keys_to_agent_lifespan = -1;\n\toptions->identity_agent = NULL;\n\toptions->visual_host_key = -1;\n\toptions->ip_qos_interactive = -1;\n\toptions->ip_qos_bulk = -1;\n\toptions->request_tty = -1;\n\toptions->proxy_use_fdpass = -1;\n\toptions->ignored_unknown = NULL;\n\toptions->num_canonical_domains = 0;\n\toptions->num_permitted_cnames = 0;\n\toptions->canonicalize_max_dots = -1;\n\toptions->canonicalize_fallback_local = -1;\n\toptions->canonicalize_hostname = -1;\n\toptions->revoked_host_keys = NULL;\n\toptions->fingerprint_hash = -1;\n\toptions->update_hostkeys = -1;\n\toptions->hostbased_accepted_algos = NULL;\n\toptions->pubkey_accepted_algos = NULL;\n\toptions->known_hosts_command = NULL;\n}",
        "func": "void\ninitialize_options(Options * options)\n{\n\tmemset(options, 'X', sizeof(*options));\n\toptions->forward_agent = -1;\n\toptions->forward_agent_sock_path = NULL;\n\toptions->forward_x11 = -1;\n\toptions->forward_x11_trusted = -1;\n\toptions->forward_x11_timeout = -1;\n\toptions->stdio_forward_host = NULL;\n\toptions->stdio_forward_port = 0;\n\toptions->clear_forwardings = -1;\n\toptions->exit_on_forward_failure = -1;\n\toptions->xauth_location = NULL;\n\toptions->fwd_opts.gateway_ports = -1;\n\toptions->fwd_opts.streamlocal_bind_mask = (mode_t)-1;\n\toptions->fwd_opts.streamlocal_bind_unlink = -1;\n\toptions->pubkey_authentication = -1;\n\toptions->challenge_response_authentication = -1;\n\toptions->gss_authentication = -1;\n\toptions->gss_deleg_creds = -1;\n\toptions->password_authentication = -1;\n\toptions->kbd_interactive_authentication = -1;\n\toptions->kbd_interactive_devices = NULL;\n\toptions->hostbased_authentication = -1;\n\toptions->disable_trivial_auth = -1;\n\toptions->batch_mode = -1;\n\toptions->check_host_ip = -1;\n\toptions->strict_host_key_checking = -1;\n\toptions->compression = -1;\n\toptions->tcp_keep_alive = -1;\n\toptions->port = -1;\n\toptions->address_family = -1;\n\toptions->connection_attempts = -1;\n\toptions->connection_timeout = -1;\n\toptions->number_of_password_prompts = -1;\n\toptions->ciphers = NULL;\n\toptions->macs = NULL;\n\toptions->kex_algorithms = NULL;\n\toptions->hostkeyalgorithms = NULL;\n\toptions->ca_sign_algorithms = NULL;\n\toptions->num_identity_files = 0;\n\tmemset(options->identity_keys, 0, sizeof(options->identity_keys));\n\toptions->num_certificate_files = 0;\n\tmemset(options->certificates, 0, sizeof(options->certificates));\n\toptions->hostname = NULL;\n\toptions->host_key_alias = NULL;\n\toptions->proxy_command = NULL;\n\toptions->jump_user = NULL;\n\toptions->jump_host = NULL;\n\toptions->jump_port = -1;\n\toptions->jump_extra = NULL;\n\toptions->user = NULL;\n\toptions->escape_char = -1;\n\toptions->num_system_hostfiles = 0;\n\toptions->num_user_hostfiles = 0;\n\toptions->local_forwards = NULL;\n\toptions->num_local_forwards = 0;\n\toptions->remote_forwards = NULL;\n\toptions->num_remote_forwards = 0;\n\toptions->permitted_remote_opens = NULL;\n\toptions->num_permitted_remote_opens = 0;\n\toptions->log_facility = SYSLOG_FACILITY_NOT_SET;\n\toptions->log_level = SYSLOG_LEVEL_NOT_SET;\n\toptions->num_log_verbose = 0;\n\toptions->log_verbose = NULL;\n\toptions->preferred_authentications = NULL;\n\toptions->bind_address = NULL;\n\toptions->bind_interface = NULL;\n\toptions->pkcs11_provider = NULL;\n\toptions->sk_provider = NULL;\n\toptions->enable_ssh_keysign = - 1;\n\toptions->no_host_authentication_for_localhost = - 1;\n\toptions->identities_only = - 1;\n\toptions->rekey_limit = - 1;\n\toptions->rekey_interval = -1;\n\toptions->verify_host_key_dns = -1;\n\toptions->server_alive_interval = -1;\n\toptions->server_alive_count_max = -1;\n\toptions->send_env = NULL;\n\toptions->num_send_env = 0;\n\toptions->setenv = NULL;\n\toptions->num_setenv = 0;\n\toptions->control_path = NULL;\n\toptions->control_master = -1;\n\toptions->control_persist = -1;\n\toptions->control_persist_timeout = 0;\n\toptions->hash_known_hosts = -1;\n\toptions->tun_open = -1;\n\toptions->tun_local = -1;\n\toptions->tun_remote = -1;\n\toptions->local_command = NULL;\n\toptions->permit_local_command = -1;\n\toptions->remote_command = NULL;\n\toptions->add_keys_to_agent = -1;\n\toptions->add_keys_to_agent_lifespan = -1;\n\toptions->identity_agent = NULL;\n\toptions->visual_host_key = -1;\n\toptions->ip_qos_interactive = -1;\n\toptions->ip_qos_bulk = -1;\n\toptions->request_tty = -1;\n\toptions->proxy_use_fdpass = -1;\n\toptions->ignored_unknown = NULL;\n\toptions->num_canonical_domains = 0;\n\toptions->num_permitted_cnames = 0;\n\toptions->canonicalize_max_dots = -1;\n\toptions->canonicalize_fallback_local = -1;\n\toptions->canonicalize_hostname = -1;\n\toptions->revoked_host_keys = NULL;\n\toptions->fingerprint_hash = -1;\n\toptions->update_hostkeys = -1;\n\toptions->hostbased_accepted_algos = NULL;\n\toptions->pubkey_accepted_algos = NULL;\n\toptions->known_hosts_command = NULL;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -23,6 +23,7 @@\n \toptions->kbd_interactive_authentication = -1;\n \toptions->kbd_interactive_devices = NULL;\n \toptions->hostbased_authentication = -1;\n+\toptions->disable_trivial_auth = -1;\n \toptions->batch_mode = -1;\n \toptions->check_host_ip = -1;\n \toptions->strict_host_key_checking = -1;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\toptions->disable_trivial_auth = -1;"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-36368",
        "func_name": "openssh/openssh-portable/userauth_passwd",
        "description": "An issue was discovered in OpenSSH before 8.9. If a client is using public-key authentication with agent forwarding but without -oLogLevel=verbose, and an attacker has silently modified the server to support the None authentication option, then the user cannot determine whether FIDO authentication is going to confirm that the user wishes to connect to that server, or that the user wishes to allow that server to connect to a different server on the user's behalf. NOTE: the vendor's position is \"this is not an authentication bypass, since nothing is being bypassed.",
        "git_url": "https://github.com/openssh/openssh-portable/commit/1c9963955eb769e25dd8f2cec7f8bceb169c8753",
        "commit_title": "added option to disable trivial auth methods",
        "commit_text": "",
        "func_before": "static int\nuserauth_passwd(struct ssh *ssh)\n{\n\tAuthctxt *authctxt = (Authctxt *)ssh->authctxt;\n\tchar *password, *prompt = NULL;\n\tconst char *host = options.host_key_alias ?  options.host_key_alias :\n\t    authctxt->host;\n\tint r;\n\n\tif (authctxt->attempt_passwd++ >= options.number_of_password_prompts)\n\t\treturn 0;\n\n\tif (authctxt->attempt_passwd != 1)\n\t\terror(\"Permission denied, please try again.\");\n\n\txasprintf(&prompt, \"%s@%s's password: \", authctxt->server_user, host);\n\tpassword = read_passphrase(prompt, 0);\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_USERAUTH_REQUEST)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, authctxt->server_user)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, authctxt->service)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, authctxt->method->name)) != 0 ||\n\t    (r = sshpkt_put_u8(ssh, 0)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, password)) != 0 ||\n\t    (r = sshpkt_add_padding(ssh, 64)) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0)\n\t\tfatal_fr(r, \"send packet\");\n\n\tfree(prompt);\n\tif (password != NULL)\n\t\tfreezero(password, strlen(password));\n\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_PASSWD_CHANGEREQ,\n\t    &input_userauth_passwd_changereq);\n\n\treturn 1;\n}",
        "func": "static int\nuserauth_passwd(struct ssh *ssh)\n{\n\tAuthctxt *authctxt = (Authctxt *)ssh->authctxt;\n\tauthctxt->is_trivial_auth = 0;\n\tchar *password, *prompt = NULL;\n\tconst char *host = options.host_key_alias ?  options.host_key_alias :\n\t    authctxt->host;\n\tint r;\n\n\tif (authctxt->attempt_passwd++ >= options.number_of_password_prompts)\n\t\treturn 0;\n\n\tif (authctxt->attempt_passwd != 1)\n\t\terror(\"Permission denied, please try again.\");\n\n\txasprintf(&prompt, \"%s@%s's password: \", authctxt->server_user, host);\n\tpassword = read_passphrase(prompt, 0);\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_USERAUTH_REQUEST)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, authctxt->server_user)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, authctxt->service)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, authctxt->method->name)) != 0 ||\n\t    (r = sshpkt_put_u8(ssh, 0)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, password)) != 0 ||\n\t    (r = sshpkt_add_padding(ssh, 64)) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0)\n\t\tfatal_fr(r, \"send packet\");\n\n\tfree(prompt);\n\tif (password != NULL)\n\t\tfreezero(password, strlen(password));\n\n\tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_PASSWD_CHANGEREQ,\n\t    &input_userauth_passwd_changereq);\n\t\t\n\treturn 1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,6 +2,7 @@\n userauth_passwd(struct ssh *ssh)\n {\n \tAuthctxt *authctxt = (Authctxt *)ssh->authctxt;\n+\tauthctxt->is_trivial_auth = 0;\n \tchar *password, *prompt = NULL;\n \tconst char *host = options.host_key_alias ?  options.host_key_alias :\n \t    authctxt->host;\n@@ -31,6 +32,6 @@\n \n \tssh_dispatch_set(ssh, SSH2_MSG_USERAUTH_PASSWD_CHANGEREQ,\n \t    &input_userauth_passwd_changereq);\n-\n+\t\t\n \treturn 1;\n }",
        "diff_line_info": {
            "deleted_lines": [
                ""
            ],
            "added_lines": [
                "\tauthctxt->is_trivial_auth = 0;",
                "\t\t"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-36368",
        "func_name": "openssh/openssh-portable/input_userauth_info_req",
        "description": "An issue was discovered in OpenSSH before 8.9. If a client is using public-key authentication with agent forwarding but without -oLogLevel=verbose, and an attacker has silently modified the server to support the None authentication option, then the user cannot determine whether FIDO authentication is going to confirm that the user wishes to connect to that server, or that the user wishes to allow that server to connect to a different server on the user's behalf. NOTE: the vendor's position is \"this is not an authentication bypass, since nothing is being bypassed.",
        "git_url": "https://github.com/openssh/openssh-portable/commit/1c9963955eb769e25dd8f2cec7f8bceb169c8753",
        "commit_title": "added option to disable trivial auth methods",
        "commit_text": "",
        "func_before": "static int\ninput_userauth_info_req(int type, u_int32_t seq, struct ssh *ssh)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tchar *name = NULL, *inst = NULL, *lang = NULL, *prompt = NULL;\n\tchar *display_prompt = NULL, *response = NULL;\n\tu_char echo = 0;\n\tu_int num_prompts, i;\n\tint r;\n\n\tdebug2_f(\"entering\");\n\n\tif (authctxt == NULL)\n\t\tfatal_f(\"no authentication context\");\n\n\tauthctxt->info_req_seen = 1;\n\n\tif ((r = sshpkt_get_cstring(ssh, &name, NULL)) != 0 ||\n\t    (r = sshpkt_get_cstring(ssh, &inst, NULL)) != 0 ||\n\t    (r = sshpkt_get_cstring(ssh, &lang, NULL)) != 0)\n\t\tgoto out;\n\tif (strlen(name) > 0)\n\t\tlogit(\"%s\", name);\n\tif (strlen(inst) > 0)\n\t\tlogit(\"%s\", inst);\n\n\tif ((r = sshpkt_get_u32(ssh, &num_prompts)) != 0)\n\t\tgoto out;\n\t/*\n\t * Begin to build info response packet based on prompts requested.\n\t * We commit to providing the correct number of responses, so if\n\t * further on we run into a problem that prevents this, we have to\n\t * be sure and clean this up and send a correct error response.\n\t */\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_USERAUTH_INFO_RESPONSE)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, num_prompts)) != 0)\n\t\tgoto out;\n\n\tdebug2_f(\"num_prompts %d\", num_prompts);\n\tfor (i = 0; i < num_prompts; i++) {\n\t\tif ((r = sshpkt_get_cstring(ssh, &prompt, NULL)) != 0 ||\n\t\t    (r = sshpkt_get_u8(ssh, &echo)) != 0)\n\t\t\tgoto out;\n\t\tif (asmprintf(&display_prompt, INT_MAX, NULL, \"(%s@%s) %s\",\n\t\t    authctxt->server_user, options.host_key_alias ?\n\t\t    options.host_key_alias : authctxt->host, prompt) == -1)\n\t\t\tfatal_f(\"asmprintf failed\");\n\t\tresponse = read_passphrase(display_prompt, echo ? RP_ECHO : 0);\n\t\tif ((r = sshpkt_put_cstring(ssh, response)) != 0)\n\t\t\tgoto out;\n\t\tfreezero(response, strlen(response));\n\t\tfree(prompt);\n\t\tfree(display_prompt);\n\t\tdisplay_prompt = response = prompt = NULL;\n\t}\n\t/* done with parsing incoming message. */\n\tif ((r = sshpkt_get_end(ssh)) != 0 ||\n\t    (r = sshpkt_add_padding(ssh, 64)) != 0)\n\t\tgoto out;\n\tr = sshpkt_send(ssh);\n out:\n\tif (response)\n\t\tfreezero(response, strlen(response));\n\tfree(prompt);\n\tfree(display_prompt);\n\tfree(name);\n\tfree(inst);\n\tfree(lang);\n\treturn r;\n}",
        "func": "static int\ninput_userauth_info_req(int type, u_int32_t seq, struct ssh *ssh)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tchar *name = NULL, *inst = NULL, *lang = NULL, *prompt = NULL;\n\tchar *display_prompt = NULL, *response = NULL;\n\tu_char echo = 0;\n\tu_int num_prompts, i;\n\tint r;\n\n\tdebug2_f(\"entering\");\n\n\tif (authctxt == NULL)\n\t\tfatal_f(\"no authentication context\");\n\n\tauthctxt->info_req_seen = 1;\n\n\tif ((r = sshpkt_get_cstring(ssh, &name, NULL)) != 0 ||\n\t    (r = sshpkt_get_cstring(ssh, &inst, NULL)) != 0 ||\n\t    (r = sshpkt_get_cstring(ssh, &lang, NULL)) != 0)\n\t\tgoto out;\n\tif (strlen(name) > 0)\n\t\tlogit(\"%s\", name);\n\tif (strlen(inst) > 0)\n\t\tlogit(\"%s\", inst);\n\n\tif ((r = sshpkt_get_u32(ssh, &num_prompts)) != 0)\n\t\tgoto out;\n\t/*\n\t * Begin to build info response packet based on prompts requested.\n\t * We commit to providing the correct number of responses, so if\n\t * further on we run into a problem that prevents this, we have to\n\t * be sure and clean this up and send a correct error response.\n\t */\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_USERAUTH_INFO_RESPONSE)) != 0 ||\n\t    (r = sshpkt_put_u32(ssh, num_prompts)) != 0)\n\t\tgoto out;\n\n\tdebug2_f(\"num_prompts %d\", num_prompts);\n\tfor (i = 0; i < num_prompts; i++) {\n\t\tauthctxt->is_trivial_auth = 0;\n\t\tif ((r = sshpkt_get_cstring(ssh, &prompt, NULL)) != 0 ||\n\t\t    (r = sshpkt_get_u8(ssh, &echo)) != 0)\n\t\t\tgoto out;\n\t\tif (asmprintf(&display_prompt, INT_MAX, NULL, \"(%s@%s) %s\",\n\t\t    authctxt->server_user, options.host_key_alias ?\n\t\t    options.host_key_alias : authctxt->host, prompt) == -1)\n\t\t\tfatal_f(\"asmprintf failed\");\n\t\tresponse = read_passphrase(display_prompt, echo ? RP_ECHO : 0);\n\t\tif ((r = sshpkt_put_cstring(ssh, response)) != 0)\n\t\t\tgoto out;\n\t\tfreezero(response, strlen(response));\n\t\tfree(prompt);\n\t\tfree(display_prompt);\n\t\tdisplay_prompt = response = prompt = NULL;\n\t}\n\t/* done with parsing incoming message. */\n\tif ((r = sshpkt_get_end(ssh)) != 0 ||\n\t    (r = sshpkt_add_padding(ssh, 64)) != 0)\n\t\tgoto out;\n\tr = sshpkt_send(ssh);\n out:\n\tif (response)\n\t\tfreezero(response, strlen(response));\n\tfree(prompt);\n\tfree(display_prompt);\n\tfree(name);\n\tfree(inst);\n\tfree(lang);\n\treturn r;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -38,6 +38,7 @@\n \n \tdebug2_f(\"num_prompts %d\", num_prompts);\n \tfor (i = 0; i < num_prompts; i++) {\n+\t\tauthctxt->is_trivial_auth = 0;\n \t\tif ((r = sshpkt_get_cstring(ssh, &prompt, NULL)) != 0 ||\n \t\t    (r = sshpkt_get_u8(ssh, &echo)) != 0)\n \t\t\tgoto out;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\tauthctxt->is_trivial_auth = 0;"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-36368",
        "func_name": "openssh/openssh-portable/userauth_pubkey",
        "description": "An issue was discovered in OpenSSH before 8.9. If a client is using public-key authentication with agent forwarding but without -oLogLevel=verbose, and an attacker has silently modified the server to support the None authentication option, then the user cannot determine whether FIDO authentication is going to confirm that the user wishes to connect to that server, or that the user wishes to allow that server to connect to a different server on the user's behalf. NOTE: the vendor's position is \"this is not an authentication bypass, since nothing is being bypassed.",
        "git_url": "https://github.com/openssh/openssh-portable/commit/1c9963955eb769e25dd8f2cec7f8bceb169c8753",
        "commit_title": "added option to disable trivial auth methods",
        "commit_text": "",
        "func_before": "static int\nuserauth_pubkey(struct ssh *ssh)\n{\n\tAuthctxt *authctxt = (Authctxt *)ssh->authctxt;\n\tIdentity *id;\n\tint sent = 0;\n\tchar *ident;\n\n\twhile ((id = TAILQ_FIRST(&authctxt->keys))) {\n\t\tif (id->tried++)\n\t\t\treturn (0);\n\t\t/* move key to the end of the queue */\n\t\tTAILQ_REMOVE(&authctxt->keys, id, next);\n\t\tTAILQ_INSERT_TAIL(&authctxt->keys, id, next);\n\t\t/*\n\t\t * send a test message if we have the public key. for\n\t\t * encrypted keys we cannot do this and have to load the\n\t\t * private key instead\n\t\t */\n\t\tif (id->key != NULL) {\n\t\t\tif (try_identity(ssh, id)) {\n\t\t\t\tident = format_identity(id);\n\t\t\t\tdebug(\"Offering public key: %s\", ident);\n\t\t\t\tfree(ident);\n\t\t\t\tsent = send_pubkey_test(ssh, id);\n\t\t\t}\n\t\t} else {\n\t\t\tdebug(\"Trying private key: %s\", id->filename);\n\t\t\tid->key = load_identity_file(id);\n\t\t\tif (id->key != NULL) {\n\t\t\t\tif (try_identity(ssh, id)) {\n\t\t\t\t\tid->isprivate = 1;\n\t\t\t\t\tsent = sign_and_send_pubkey(ssh, id);\n\t\t\t\t}\n\t\t\t\tsshkey_free(id->key);\n\t\t\t\tid->key = NULL;\n\t\t\t\tid->isprivate = 0;\n\t\t\t}\n\t\t}\n\t\tif (sent)\n\t\t\treturn (sent);\n\t}\n\treturn (0);\n}",
        "func": "static int\nuserauth_pubkey(struct ssh *ssh)\n{\n\tAuthctxt *authctxt = (Authctxt *)ssh->authctxt;\n\tIdentity *id;\n\tint sent = 0;\n\tchar *ident;\n\n\twhile ((id = TAILQ_FIRST(&authctxt->keys))) {\n\t\tif (id->tried++)\n\t\t\treturn (0);\n\t\t/* move key to the end of the queue */\n\t\tTAILQ_REMOVE(&authctxt->keys, id, next);\n\t\tTAILQ_INSERT_TAIL(&authctxt->keys, id, next);\n\t\t/*\n\t\t * send a test message if we have the public key. for\n\t\t * encrypted keys we cannot do this and have to load the\n\t\t * private key instead\n\t\t */\n\t\tif (id->key != NULL) {\n\t\t\tif (try_identity(ssh, id)) {\n\t\t\t\tident = format_identity(id);\n\t\t\t\tdebug(\"Offering public key: %s\", ident);\n\t\t\t\tfree(ident);\n\t\t\t\tsent = send_pubkey_test(ssh, id);\n\t\t\t}\n\t\t} else {\n\t\t\tdebug(\"Trying private key: %s\", id->filename);\n\t\t\tid->key = load_identity_file(id);\n\t\t\tif (id->key != NULL) {\n\t\t\t\tif (try_identity(ssh, id)) {\n\t\t\t\t\tid->isprivate = 1;\n\t\t\t\t\tsent = sign_and_send_pubkey(ssh, id);\n\t\t\t\t}\n\t\t\t\tsshkey_free(id->key);\n\t\t\t\tid->key = NULL;\n\t\t\t\tid->isprivate = 0;\n\t\t\t}\n\t\t}\n\t\tif (sent) {\n\t\t\tauthctxt->is_trivial_auth = 0;\n\t\t\treturn (sent);\n\t\t}\n\t}\n\treturn (0);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -37,8 +37,10 @@\n \t\t\t\tid->isprivate = 0;\n \t\t\t}\n \t\t}\n-\t\tif (sent)\n+\t\tif (sent) {\n+\t\t\tauthctxt->is_trivial_auth = 0;\n \t\t\treturn (sent);\n+\t\t}\n \t}\n \treturn (0);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tif (sent)"
            ],
            "added_lines": [
                "\t\tif (sent) {",
                "\t\t\tauthctxt->is_trivial_auth = 0;",
                "\t\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-36368",
        "func_name": "openssh/openssh-portable/ssh_userauth2",
        "description": "An issue was discovered in OpenSSH before 8.9. If a client is using public-key authentication with agent forwarding but without -oLogLevel=verbose, and an attacker has silently modified the server to support the None authentication option, then the user cannot determine whether FIDO authentication is going to confirm that the user wishes to connect to that server, or that the user wishes to allow that server to connect to a different server on the user's behalf. NOTE: the vendor's position is \"this is not an authentication bypass, since nothing is being bypassed.",
        "git_url": "https://github.com/openssh/openssh-portable/commit/1c9963955eb769e25dd8f2cec7f8bceb169c8753",
        "commit_title": "added option to disable trivial auth methods",
        "commit_text": "",
        "func_before": "void\nssh_userauth2(struct ssh *ssh, const char *local_user,\n    const char *server_user, char *host, Sensitive *sensitive)\n{\n\tAuthctxt authctxt;\n\tint r;\n\n\tif (options.challenge_response_authentication)\n\t\toptions.kbd_interactive_authentication = 1;\n\tif (options.preferred_authentications == NULL)\n\t\toptions.preferred_authentications = authmethods_get();\n\n\t/* setup authentication context */\n\tmemset(&authctxt, 0, sizeof(authctxt));\n\tauthctxt.server_user = server_user;\n\tauthctxt.local_user = local_user;\n\tauthctxt.host = host;\n\tauthctxt.service = \"ssh-connection\";\t\t/* service name */\n\tauthctxt.success = 0;\n\tauthctxt.method = authmethod_lookup(\"none\");\n\tauthctxt.authlist = NULL;\n\tauthctxt.methoddata = NULL;\n\tauthctxt.sensitive = sensitive;\n\tauthctxt.active_ktype = authctxt.oktypes = authctxt.ktypes = NULL;\n\tauthctxt.info_req_seen = 0;\n\tauthctxt.attempt_kbdint = 0;\n\tauthctxt.attempt_passwd = 0;\n#if GSSAPI\n\tauthctxt.gss_supported_mechs = NULL;\n\tauthctxt.mech_tried = 0;\n#endif\n\tauthctxt.agent_fd = -1;\n\tpubkey_prepare(&authctxt);\n\tif (authctxt.method == NULL) {\n\t\tfatal_f(\"internal error: cannot send userauth none request\");\n\t}\n\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_SERVICE_REQUEST)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, \"ssh-userauth\")) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0)\n\t\tfatal_fr(r, \"send packet\");\n\n\tssh->authctxt = &authctxt;\n\tssh_dispatch_init(ssh, &input_userauth_error);\n\tssh_dispatch_set(ssh, SSH2_MSG_EXT_INFO, &input_userauth_ext_info);\n\tssh_dispatch_set(ssh, SSH2_MSG_SERVICE_ACCEPT, &input_userauth_service_accept);\n\tssh_dispatch_run_fatal(ssh, DISPATCH_BLOCK, &authctxt.success);\t/* loop until success */\n\tpubkey_cleanup(ssh);\n\tssh->authctxt = NULL;\n\n\tssh_dispatch_range(ssh, SSH2_MSG_USERAUTH_MIN, SSH2_MSG_USERAUTH_MAX, NULL);\n\n\tif (!authctxt.success)\n\t\tfatal(\"Authentication failed.\");\n\tdebug(\"Authentication succeeded (%s).\", authctxt.method->name);\n}",
        "func": "void\nssh_userauth2(struct ssh *ssh, const char *local_user,\n    const char *server_user, char *host, Sensitive *sensitive)\n{\n\tAuthctxt authctxt;\n\tint r;\n\n\tif (options.challenge_response_authentication)\n\t\toptions.kbd_interactive_authentication = 1;\n\tif (options.preferred_authentications == NULL)\n\t\toptions.preferred_authentications = authmethods_get();\n\n\t/* setup authentication context */\n\tmemset(&authctxt, 0, sizeof(authctxt));\n\tauthctxt.server_user = server_user;\t\n\tauthctxt.is_trivial_auth = 1;\n\tauthctxt.local_user = local_user;\n\tauthctxt.host = host;\n\tauthctxt.service = \"ssh-connection\";\t\t/* service name */\n\tauthctxt.success = 0;\n\tauthctxt.method = authmethod_lookup(\"none\");\n\tauthctxt.authlist = NULL;\n\tauthctxt.methoddata = NULL;\n\tauthctxt.sensitive = sensitive;\n\tauthctxt.active_ktype = authctxt.oktypes = authctxt.ktypes = NULL;\n\tauthctxt.info_req_seen = 0;\n\tauthctxt.attempt_kbdint = 0;\n\tauthctxt.attempt_passwd = 0;\n#if GSSAPI\n\tauthctxt.gss_supported_mechs = NULL;\n\tauthctxt.mech_tried = 0;\n#endif\n\tauthctxt.agent_fd = -1;\n\tpubkey_prepare(&authctxt);\n\tif (authctxt.method == NULL) {\n\t\tfatal_f(\"internal error: cannot send userauth none request\");\n\t}\n\n\tif ((r = sshpkt_start(ssh, SSH2_MSG_SERVICE_REQUEST)) != 0 ||\n\t    (r = sshpkt_put_cstring(ssh, \"ssh-userauth\")) != 0 ||\n\t    (r = sshpkt_send(ssh)) != 0)\n\t\tfatal_fr(r, \"send packet\");\n\n\tssh->authctxt = &authctxt;\n\tssh_dispatch_init(ssh, &input_userauth_error);\n\tssh_dispatch_set(ssh, SSH2_MSG_EXT_INFO, &input_userauth_ext_info);\n\tssh_dispatch_set(ssh, SSH2_MSG_SERVICE_ACCEPT, &input_userauth_service_accept);\n\tssh_dispatch_run_fatal(ssh, DISPATCH_BLOCK, &authctxt.success);\t/* loop until success */\n\tpubkey_cleanup(ssh);\n\tssh->authctxt = NULL;\n\n\tssh_dispatch_range(ssh, SSH2_MSG_USERAUTH_MIN, SSH2_MSG_USERAUTH_MAX, NULL);\n\n\tif (!authctxt.success)\n\t\tfatal(\"Authentication failed.\");\n\tif (authctxt.is_trivial_auth == 1 && options.disable_trivial_auth == 1) {\n\t\tfatal(\"Trivial authentication disabled.\");\n\t}\n\tdebug(\"Authentication succeeded (%s).\", authctxt.method->name);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -12,7 +12,8 @@\n \n \t/* setup authentication context */\n \tmemset(&authctxt, 0, sizeof(authctxt));\n-\tauthctxt.server_user = server_user;\n+\tauthctxt.server_user = server_user;\t\n+\tauthctxt.is_trivial_auth = 1;\n \tauthctxt.local_user = local_user;\n \tauthctxt.host = host;\n \tauthctxt.service = \"ssh-connection\";\t\t/* service name */\n@@ -52,5 +53,8 @@\n \n \tif (!authctxt.success)\n \t\tfatal(\"Authentication failed.\");\n+\tif (authctxt.is_trivial_auth == 1 && options.disable_trivial_auth == 1) {\n+\t\tfatal(\"Trivial authentication disabled.\");\n+\t}\n \tdebug(\"Authentication succeeded (%s).\", authctxt.method->name);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tauthctxt.server_user = server_user;"
            ],
            "added_lines": [
                "\tauthctxt.server_user = server_user;\t",
                "\tauthctxt.is_trivial_auth = 1;",
                "\tif (authctxt.is_trivial_auth == 1 && options.disable_trivial_auth == 1) {",
                "\t\tfatal(\"Trivial authentication disabled.\");",
                "\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-36368",
        "func_name": "openssh/openssh-portable/process_gssapi_token",
        "description": "An issue was discovered in OpenSSH before 8.9. If a client is using public-key authentication with agent forwarding but without -oLogLevel=verbose, and an attacker has silently modified the server to support the None authentication option, then the user cannot determine whether FIDO authentication is going to confirm that the user wishes to connect to that server, or that the user wishes to allow that server to connect to a different server on the user's behalf. NOTE: the vendor's position is \"this is not an authentication bypass, since nothing is being bypassed.",
        "git_url": "https://github.com/openssh/openssh-portable/commit/1c9963955eb769e25dd8f2cec7f8bceb169c8753",
        "commit_title": "added option to disable trivial auth methods",
        "commit_text": "",
        "func_before": "static OM_uint32\nprocess_gssapi_token(struct ssh *ssh, gss_buffer_t recv_tok)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tGssctxt *gssctxt = authctxt->methoddata;\n\tgss_buffer_desc send_tok = GSS_C_EMPTY_BUFFER;\n\tgss_buffer_desc mic = GSS_C_EMPTY_BUFFER;\n\tgss_buffer_desc gssbuf;\n\tOM_uint32 status, ms, flags;\n\tint r;\n\n\tstatus = ssh_gssapi_init_ctx(gssctxt, options.gss_deleg_creds,\n\t    recv_tok, &send_tok, &flags);\n\n\tif (send_tok.length > 0) {\n\t\tu_char type = GSS_ERROR(status) ?\n\t\t    SSH2_MSG_USERAUTH_GSSAPI_ERRTOK :\n\t\t    SSH2_MSG_USERAUTH_GSSAPI_TOKEN;\n\n\t\tif ((r = sshpkt_start(ssh, type)) != 0 ||\n\t\t    (r = sshpkt_put_string(ssh, send_tok.value,\n\t\t    send_tok.length)) != 0 ||\n\t\t    (r = sshpkt_send(ssh)) != 0)\n\t\t\tfatal_fr(r, \"send %u packet\", type);\n\n\t\tgss_release_buffer(&ms, &send_tok);\n\t}\n\n\tif (status == GSS_S_COMPLETE) {\n\t\t/* send either complete or MIC, depending on mechanism */\n\t\tif (!(flags & GSS_C_INTEG_FLAG)) {\n\t\t\tif ((r = sshpkt_start(ssh,\n\t\t\t    SSH2_MSG_USERAUTH_GSSAPI_EXCHANGE_COMPLETE)) != 0 ||\n\t\t\t    (r = sshpkt_send(ssh)) != 0)\n\t\t\t\tfatal_fr(r, \"send completion\");\n\t\t} else {\n\t\t\tstruct sshbuf *b;\n\n\t\t\tif ((b = sshbuf_new()) == NULL)\n\t\t\t\tfatal_f(\"sshbuf_new failed\");\n\t\t\tssh_gssapi_buildmic(b, authctxt->server_user,\n\t\t\t    authctxt->service, \"gssapi-with-mic\",\n\t\t\t    ssh->kex->session_id);\n\n\t\t\tif ((gssbuf.value = sshbuf_mutable_ptr(b)) == NULL)\n\t\t\t\tfatal_f(\"sshbuf_mutable_ptr failed\");\n\t\t\tgssbuf.length = sshbuf_len(b);\n\n\t\t\tstatus = ssh_gssapi_sign(gssctxt, &gssbuf, &mic);\n\n\t\t\tif (!GSS_ERROR(status)) {\n\t\t\t\tif ((r = sshpkt_start(ssh,\n\t\t\t\t    SSH2_MSG_USERAUTH_GSSAPI_MIC)) != 0 ||\n\t\t\t\t    (r = sshpkt_put_string(ssh, mic.value,\n\t\t\t\t    mic.length)) != 0 ||\n\t\t\t\t    (r = sshpkt_send(ssh)) != 0)\n\t\t\t\t\tfatal_fr(r, \"send MIC\");\n\t\t\t}\n\n\t\t\tsshbuf_free(b);\n\t\t\tgss_release_buffer(&ms, &mic);\n\t\t}\n\t}\n\n\treturn status;\n}",
        "func": "static OM_uint32\nprocess_gssapi_token(struct ssh *ssh, gss_buffer_t recv_tok)\n{\n\tAuthctxt *authctxt = ssh->authctxt;\n\tGssctxt *gssctxt = authctxt->methoddata;\n\tgss_buffer_desc send_tok = GSS_C_EMPTY_BUFFER;\n\tgss_buffer_desc mic = GSS_C_EMPTY_BUFFER;\n\tgss_buffer_desc gssbuf;\n\tOM_uint32 status, ms, flags;\n\tint r;\n\n\tstatus = ssh_gssapi_init_ctx(gssctxt, options.gss_deleg_creds,\n\t    recv_tok, &send_tok, &flags);\n\n\tif (send_tok.length > 0) {\n\t\tu_char type = GSS_ERROR(status) ?\n\t\t    SSH2_MSG_USERAUTH_GSSAPI_ERRTOK :\n\t\t    SSH2_MSG_USERAUTH_GSSAPI_TOKEN;\n\n\t\tif ((r = sshpkt_start(ssh, type)) != 0 ||\n\t\t    (r = sshpkt_put_string(ssh, send_tok.value,\n\t\t    send_tok.length)) != 0 ||\n\t\t    (r = sshpkt_send(ssh)) != 0)\n\t\t\tfatal_fr(r, \"send %u packet\", type);\n\n\t\tgss_release_buffer(&ms, &send_tok);\n\t\tauthctxt->is_trivial_auth = 0;\n\t}\n\n\tif (status == GSS_S_COMPLETE) {\n\t\t/* send either complete or MIC, depending on mechanism */\n\t\tif (!(flags & GSS_C_INTEG_FLAG)) {\n\t\t\tif ((r = sshpkt_start(ssh,\n\t\t\t    SSH2_MSG_USERAUTH_GSSAPI_EXCHANGE_COMPLETE)) != 0 ||\n\t\t\t    (r = sshpkt_send(ssh)) != 0)\n\t\t\t\tfatal_fr(r, \"send completion\");\n\t\t} else {\n\t\t\tstruct sshbuf *b;\n\n\t\t\tif ((b = sshbuf_new()) == NULL)\n\t\t\t\tfatal_f(\"sshbuf_new failed\");\n\t\t\tssh_gssapi_buildmic(b, authctxt->server_user,\n\t\t\t    authctxt->service, \"gssapi-with-mic\",\n\t\t\t    ssh->kex->session_id);\n\n\t\t\tif ((gssbuf.value = sshbuf_mutable_ptr(b)) == NULL)\n\t\t\t\tfatal_f(\"sshbuf_mutable_ptr failed\");\n\t\t\tgssbuf.length = sshbuf_len(b);\n\n\t\t\tstatus = ssh_gssapi_sign(gssctxt, &gssbuf, &mic);\n\n\t\t\tif (!GSS_ERROR(status)) {\n\t\t\t\tif ((r = sshpkt_start(ssh,\n\t\t\t\t    SSH2_MSG_USERAUTH_GSSAPI_MIC)) != 0 ||\n\t\t\t\t    (r = sshpkt_put_string(ssh, mic.value,\n\t\t\t\t    mic.length)) != 0 ||\n\t\t\t\t    (r = sshpkt_send(ssh)) != 0)\n\t\t\t\t\tfatal_fr(r, \"send MIC\");\n\t\t\t}\n\n\t\t\tsshbuf_free(b);\n\t\t\tgss_release_buffer(&ms, &mic);\n\t\t}\n\t}\n\n\treturn status;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -24,6 +24,7 @@\n \t\t\tfatal_fr(r, \"send %u packet\", type);\n \n \t\tgss_release_buffer(&ms, &send_tok);\n+\t\tauthctxt->is_trivial_auth = 0;\n \t}\n \n \tif (status == GSS_S_COMPLETE) {",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\tauthctxt->is_trivial_auth = 0;"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-3652",
        "func_name": "389ds/389-ds-base/crypt_pw_cmp",
        "description": "A flaw was found in 389-ds-base. If an asterisk is imported as password hashes, either accidentally or maliciously, then instead of being inactive, any password will successfully match during authentication. This flaw allows an attacker to successfully authenticate as a user whose password was disabled.",
        "git_url": "https://github.com/389ds/389-ds-base/commit/ec4d65e5d6c5310c990a2cfe161d52f5f574f337",
        "commit_title": "Issue 4817 - BUG - locked crypt accounts on import may allow all passwords",
        "commit_text": " Bug Description: Due to mishanding of short dbpwd hashes, the crypt_r algorithm was misused and was only comparing salts in some cases, rather than checking the actual content of the password.  Fix Description: Stricter checks on dbpwd lengths to ensure that content passed to crypt_r has at least 2 salt bytes and 1 hash byte, as well as stricter checks on ct_memcmp to ensure that compared values are the same length, rather than potentially allowing overruns/short comparisons.  fixes: https://github.com/389ds/389-ds-base/issues/4817  Author: William Brown <william@blackhats.net.au>  Review by: ???",
        "func_before": "int\ncrypt_pw_cmp(const char *userpwd, const char *dbpwd)\n{\n    int rc;\n    char *cp;\n    struct crypt_data data;\n    data.initialized = 0;\n\n    /* we use salt (first 2 chars) of encoded password in call to crypt_r() */\n    cp = crypt_r(userpwd, dbpwd, &data);\n    if (cp) {\n        rc = slapi_ct_memcmp(dbpwd, cp, strlen(dbpwd));\n    } else {\n        rc = -1;\n    }\n    return rc;\n}",
        "func": "int\ncrypt_pw_cmp(const char *userpwd, const char *dbpwd)\n{\n    int rc = -1;\n    char *cp = NULL;\n    size_t dbpwd_len = strlen(dbpwd);\n    struct crypt_data data;\n    data.initialized = 0;\n\n    /*\n     * there MUST be at least 2 chars of salt and some pw bytes, else this is INVALID and will\n     * allow any password to bind as we then only compare SALTS.\n     */\n    if (dbpwd_len >= 3) {\n        /* we use salt (first 2 chars) of encoded password in call to crypt_r() */\n        cp = crypt_r(userpwd, dbpwd, &data);\n    }\n    /* If these are not the same length, we can not proceed safely with memcmp. */\n    if (cp && dbpwd_len == strlen(cp)) {\n        rc = slapi_ct_memcmp(dbpwd, cp, dbpwd_len);\n    } else {\n        rc = -1;\n    }\n    return rc;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,15 +1,23 @@\n int\n crypt_pw_cmp(const char *userpwd, const char *dbpwd)\n {\n-    int rc;\n-    char *cp;\n+    int rc = -1;\n+    char *cp = NULL;\n+    size_t dbpwd_len = strlen(dbpwd);\n     struct crypt_data data;\n     data.initialized = 0;\n \n-    /* we use salt (first 2 chars) of encoded password in call to crypt_r() */\n-    cp = crypt_r(userpwd, dbpwd, &data);\n-    if (cp) {\n-        rc = slapi_ct_memcmp(dbpwd, cp, strlen(dbpwd));\n+    /*\n+     * there MUST be at least 2 chars of salt and some pw bytes, else this is INVALID and will\n+     * allow any password to bind as we then only compare SALTS.\n+     */\n+    if (dbpwd_len >= 3) {\n+        /* we use salt (first 2 chars) of encoded password in call to crypt_r() */\n+        cp = crypt_r(userpwd, dbpwd, &data);\n+    }\n+    /* If these are not the same length, we can not proceed safely with memcmp. */\n+    if (cp && dbpwd_len == strlen(cp)) {\n+        rc = slapi_ct_memcmp(dbpwd, cp, dbpwd_len);\n     } else {\n         rc = -1;\n     }",
        "diff_line_info": {
            "deleted_lines": [
                "    int rc;",
                "    char *cp;",
                "    /* we use salt (first 2 chars) of encoded password in call to crypt_r() */",
                "    cp = crypt_r(userpwd, dbpwd, &data);",
                "    if (cp) {",
                "        rc = slapi_ct_memcmp(dbpwd, cp, strlen(dbpwd));"
            ],
            "added_lines": [
                "    int rc = -1;",
                "    char *cp = NULL;",
                "    size_t dbpwd_len = strlen(dbpwd);",
                "    /*",
                "     * there MUST be at least 2 chars of salt and some pw bytes, else this is INVALID and will",
                "     * allow any password to bind as we then only compare SALTS.",
                "     */",
                "    if (dbpwd_len >= 3) {",
                "        /* we use salt (first 2 chars) of encoded password in call to crypt_r() */",
                "        cp = crypt_r(userpwd, dbpwd, &data);",
                "    }",
                "    /* If these are not the same length, we can not proceed safely with memcmp. */",
                "    if (cp && dbpwd_len == strlen(cp)) {",
                "        rc = slapi_ct_memcmp(dbpwd, cp, dbpwd_len);"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-24883",
        "func_name": "FreeRDP/ntlm_fetch_ntlm_v2_hash",
        "description": "FreeRDP is a free implementation of the Remote Desktop Protocol (RDP). Prior to version 2.7.0, server side authentication against a `SAM` file might be successful for invalid credentials if the server has configured an invalid `SAM` file path. FreeRDP based clients are not affected. RDP server implementations using FreeRDP to authenticate against a `SAM` file are affected. Version 2.7.0 contains a fix for this issue. As a workaround, use custom authentication via `HashCallback` and/or ensure the `SAM` database path configured is valid and the application has file handles left.",
        "git_url": "https://github.com/FreeRDP/FreeRDP/commit/4661492e5a617199457c8074bad22f766a116cdc",
        "commit_title": "Cleaned up ntlm_fetch_ntlm_v2_hash",
        "commit_text": "",
        "func_before": "static int ntlm_fetch_ntlm_v2_hash(NTLM_CONTEXT* context, BYTE* hash)\n{\n\tWINPR_SAM* sam;\n\tWINPR_SAM_ENTRY* entry;\n\tSSPI_CREDENTIALS* credentials;\n\n\tWINPR_ASSERT(context);\n\tWINPR_ASSERT(hash);\n\n\tcredentials = context->credentials;\n\tsam = SamOpen(context->SamFile, TRUE);\n\n\tif (!sam)\n\t\treturn -1;\n\n\tentry = SamLookupUserW(\n\t    sam, (LPWSTR)credentials->identity.User, credentials->identity.UserLength * 2,\n\t    (LPWSTR)credentials->identity.Domain, credentials->identity.DomainLength * 2);\n\n\tif (entry)\n\t{\n#ifdef WITH_DEBUG_NTLM\n\t\tWLog_VRB(TAG, \"NTLM Hash:\");\n\t\twinpr_HexDump(TAG, WLOG_DEBUG, entry->NtHash, 16);\n#endif\n\t\tNTOWFv2FromHashW(entry->NtHash, (LPWSTR)credentials->identity.User,\n\t\t                 credentials->identity.UserLength * 2, (LPWSTR)credentials->identity.Domain,\n\t\t                 credentials->identity.DomainLength * 2, (BYTE*)hash);\n\t\tSamFreeEntry(sam, entry);\n\t\tSamClose(sam);\n\t\treturn 1;\n\t}\n\n\tentry = SamLookupUserW(sam, (LPWSTR)credentials->identity.User,\n\t                       credentials->identity.UserLength * 2, NULL, 0);\n\n\tif (entry)\n\t{\n#ifdef WITH_DEBUG_NTLM\n\t\tWLog_VRB(TAG, \"NTLM Hash:\");\n\t\twinpr_HexDump(TAG, WLOG_DEBUG, entry->NtHash, 16);\n#endif\n\t\tNTOWFv2FromHashW(entry->NtHash, (LPWSTR)credentials->identity.User,\n\t\t                 credentials->identity.UserLength * 2, (LPWSTR)credentials->identity.Domain,\n\t\t                 credentials->identity.DomainLength * 2, (BYTE*)hash);\n\t\tSamFreeEntry(sam, entry);\n\t\tSamClose(sam);\n\t\treturn 1;\n\t}\n\telse\n\t{\n\t\tSamClose(sam);\n\t\tWLog_ERR(TAG, \"Error: Could not find user in SAM database\");\n\t\treturn 0;\n\t}\n}",
        "func": "static BOOL ntlm_fetch_ntlm_v2_hash(NTLM_CONTEXT* context, BYTE* hash)\n{\n\tBOOL rc = FALSE;\n\tWINPR_SAM* sam = NULL;\n\tWINPR_SAM_ENTRY* entry = NULL;\n\tSSPI_CREDENTIALS* credentials;\n\n\tWINPR_ASSERT(context);\n\tWINPR_ASSERT(hash);\n\n\tcredentials = context->credentials;\n\tsam = SamOpen(context->SamFile, TRUE);\n\n\tif (!sam)\n\t\tgoto fail;\n\n\tentry = SamLookupUserW(\n\t    sam, (LPWSTR)credentials->identity.User, credentials->identity.UserLength * sizeof(WCHAR),\n\t    (LPWSTR)credentials->identity.Domain, credentials->identity.DomainLength * sizeof(WCHAR));\n\n\tif (!entry)\n\t{\n\t\tentry = SamLookupUserW(sam, (LPWSTR)credentials->identity.User,\n\t\t                       credentials->identity.UserLength * sizeof(WCHAR), NULL, 0);\n\t}\n\n\tif (!entry)\n\t\tgoto fail;\n\n#ifdef WITH_DEBUG_NTLM\n\t\tWLog_VRB(TAG, \"NTLM Hash:\");\n\t\twinpr_HexDump(TAG, WLOG_DEBUG, entry->NtHash, 16);\n#endif\n\t    NTOWFv2FromHashW(entry->NtHash, (LPWSTR)credentials->identity.User,\n\t                     credentials->identity.UserLength * sizeof(WCHAR),\n\t                     (LPWSTR)credentials->identity.Domain,\n\t                     credentials->identity.DomainLength * sizeof(WCHAR), (BYTE*)hash);\n\n\t    rc = TRUE;\n\nfail:\n\tSamFreeEntry(sam, entry);\n\tSamClose(sam);\n\tif (!rc)\n\t\tWLog_ERR(TAG, \"Error: Could not find user in SAM database\");\n\n\treturn rc;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,7 +1,8 @@\n-static int ntlm_fetch_ntlm_v2_hash(NTLM_CONTEXT* context, BYTE* hash)\n+static BOOL ntlm_fetch_ntlm_v2_hash(NTLM_CONTEXT* context, BYTE* hash)\n {\n-\tWINPR_SAM* sam;\n-\tWINPR_SAM_ENTRY* entry;\n+\tBOOL rc = FALSE;\n+\tWINPR_SAM* sam = NULL;\n+\tWINPR_SAM_ENTRY* entry = NULL;\n \tSSPI_CREDENTIALS* credentials;\n \n \tWINPR_ASSERT(context);\n@@ -11,46 +12,37 @@\n \tsam = SamOpen(context->SamFile, TRUE);\n \n \tif (!sam)\n-\t\treturn -1;\n+\t\tgoto fail;\n \n \tentry = SamLookupUserW(\n-\t    sam, (LPWSTR)credentials->identity.User, credentials->identity.UserLength * 2,\n-\t    (LPWSTR)credentials->identity.Domain, credentials->identity.DomainLength * 2);\n+\t    sam, (LPWSTR)credentials->identity.User, credentials->identity.UserLength * sizeof(WCHAR),\n+\t    (LPWSTR)credentials->identity.Domain, credentials->identity.DomainLength * sizeof(WCHAR));\n \n-\tif (entry)\n+\tif (!entry)\n \t{\n+\t\tentry = SamLookupUserW(sam, (LPWSTR)credentials->identity.User,\n+\t\t                       credentials->identity.UserLength * sizeof(WCHAR), NULL, 0);\n+\t}\n+\n+\tif (!entry)\n+\t\tgoto fail;\n+\n #ifdef WITH_DEBUG_NTLM\n \t\tWLog_VRB(TAG, \"NTLM Hash:\");\n \t\twinpr_HexDump(TAG, WLOG_DEBUG, entry->NtHash, 16);\n #endif\n-\t\tNTOWFv2FromHashW(entry->NtHash, (LPWSTR)credentials->identity.User,\n-\t\t                 credentials->identity.UserLength * 2, (LPWSTR)credentials->identity.Domain,\n-\t\t                 credentials->identity.DomainLength * 2, (BYTE*)hash);\n-\t\tSamFreeEntry(sam, entry);\n-\t\tSamClose(sam);\n-\t\treturn 1;\n-\t}\n+\t    NTOWFv2FromHashW(entry->NtHash, (LPWSTR)credentials->identity.User,\n+\t                     credentials->identity.UserLength * sizeof(WCHAR),\n+\t                     (LPWSTR)credentials->identity.Domain,\n+\t                     credentials->identity.DomainLength * sizeof(WCHAR), (BYTE*)hash);\n \n-\tentry = SamLookupUserW(sam, (LPWSTR)credentials->identity.User,\n-\t                       credentials->identity.UserLength * 2, NULL, 0);\n+\t    rc = TRUE;\n \n-\tif (entry)\n-\t{\n-#ifdef WITH_DEBUG_NTLM\n-\t\tWLog_VRB(TAG, \"NTLM Hash:\");\n-\t\twinpr_HexDump(TAG, WLOG_DEBUG, entry->NtHash, 16);\n-#endif\n-\t\tNTOWFv2FromHashW(entry->NtHash, (LPWSTR)credentials->identity.User,\n-\t\t                 credentials->identity.UserLength * 2, (LPWSTR)credentials->identity.Domain,\n-\t\t                 credentials->identity.DomainLength * 2, (BYTE*)hash);\n-\t\tSamFreeEntry(sam, entry);\n-\t\tSamClose(sam);\n-\t\treturn 1;\n-\t}\n-\telse\n-\t{\n-\t\tSamClose(sam);\n+fail:\n+\tSamFreeEntry(sam, entry);\n+\tSamClose(sam);\n+\tif (!rc)\n \t\tWLog_ERR(TAG, \"Error: Could not find user in SAM database\");\n-\t\treturn 0;\n-\t}\n+\n+\treturn rc;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "static int ntlm_fetch_ntlm_v2_hash(NTLM_CONTEXT* context, BYTE* hash)",
                "\tWINPR_SAM* sam;",
                "\tWINPR_SAM_ENTRY* entry;",
                "\t\treturn -1;",
                "\t    sam, (LPWSTR)credentials->identity.User, credentials->identity.UserLength * 2,",
                "\t    (LPWSTR)credentials->identity.Domain, credentials->identity.DomainLength * 2);",
                "\tif (entry)",
                "\t\tNTOWFv2FromHashW(entry->NtHash, (LPWSTR)credentials->identity.User,",
                "\t\t                 credentials->identity.UserLength * 2, (LPWSTR)credentials->identity.Domain,",
                "\t\t                 credentials->identity.DomainLength * 2, (BYTE*)hash);",
                "\t\tSamFreeEntry(sam, entry);",
                "\t\tSamClose(sam);",
                "\t\treturn 1;",
                "\t}",
                "\tentry = SamLookupUserW(sam, (LPWSTR)credentials->identity.User,",
                "\t                       credentials->identity.UserLength * 2, NULL, 0);",
                "\tif (entry)",
                "\t{",
                "#ifdef WITH_DEBUG_NTLM",
                "\t\tWLog_VRB(TAG, \"NTLM Hash:\");",
                "\t\twinpr_HexDump(TAG, WLOG_DEBUG, entry->NtHash, 16);",
                "#endif",
                "\t\tNTOWFv2FromHashW(entry->NtHash, (LPWSTR)credentials->identity.User,",
                "\t\t                 credentials->identity.UserLength * 2, (LPWSTR)credentials->identity.Domain,",
                "\t\t                 credentials->identity.DomainLength * 2, (BYTE*)hash);",
                "\t\tSamFreeEntry(sam, entry);",
                "\t\tSamClose(sam);",
                "\t\treturn 1;",
                "\t}",
                "\telse",
                "\t{",
                "\t\tSamClose(sam);",
                "\t\treturn 0;",
                "\t}"
            ],
            "added_lines": [
                "static BOOL ntlm_fetch_ntlm_v2_hash(NTLM_CONTEXT* context, BYTE* hash)",
                "\tBOOL rc = FALSE;",
                "\tWINPR_SAM* sam = NULL;",
                "\tWINPR_SAM_ENTRY* entry = NULL;",
                "\t\tgoto fail;",
                "\t    sam, (LPWSTR)credentials->identity.User, credentials->identity.UserLength * sizeof(WCHAR),",
                "\t    (LPWSTR)credentials->identity.Domain, credentials->identity.DomainLength * sizeof(WCHAR));",
                "\tif (!entry)",
                "\t\tentry = SamLookupUserW(sam, (LPWSTR)credentials->identity.User,",
                "\t\t                       credentials->identity.UserLength * sizeof(WCHAR), NULL, 0);",
                "\t}",
                "",
                "\tif (!entry)",
                "\t\tgoto fail;",
                "",
                "\t    NTOWFv2FromHashW(entry->NtHash, (LPWSTR)credentials->identity.User,",
                "\t                     credentials->identity.UserLength * sizeof(WCHAR),",
                "\t                     (LPWSTR)credentials->identity.Domain,",
                "\t                     credentials->identity.DomainLength * sizeof(WCHAR), (BYTE*)hash);",
                "\t    rc = TRUE;",
                "fail:",
                "\tSamFreeEntry(sam, entry);",
                "\tSamClose(sam);",
                "\tif (!rc)",
                "",
                "\treturn rc;"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-5133",
        "func_name": "chromium/AuthChallengeInfo::Equals",
        "description": "Google Chrome before 52.0.2743.82 mishandles origin information during proxy authentication, which allows man-in-the-middle attackers to spoof a proxy-authentication login prompt or trigger incorrect credential storage by modifying the client-server data stream.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/098c009df7a4ddc5c23d4d3c9dccf5eff1f24c98",
        "commit_title": "Use correct origin when prompting for proxy authentication.",
        "commit_text": " Since M49, Chrome has been prompting for proxy authentication credentials using the target origin instead of the origin of the proxy server. Even if the proxy origin was displayed correctly, a mischievous network operator could still spoof the proxy server origin. To mitigate these problems, this CL:  * Fixes the origin used in the proxy authentication login prompt to use   the origin of the proxy server.  * Indicate if the proxy server connection is insecure.  * Always throw up an interstitial and clear the omnibox when showing a   proxy auth prompt.  * Use the correct origin when saving proxy authentication credentials.   Review-Url: https://codereview.chromium.org/2067933002 ",
        "func_before": "bool AuthChallengeInfo::Equals(const AuthChallengeInfo& that) const {\n  return (this->is_proxy == that.is_proxy &&\n          this->challenger.Equals(that.challenger) &&\n          this->scheme == that.scheme &&\n          this->realm == that.realm);\n}",
        "func": "bool AuthChallengeInfo::Equals(const AuthChallengeInfo& that) const {\n  return (this->is_proxy == that.is_proxy &&\n          this->challenger == that.challenger && this->scheme == that.scheme &&\n          this->realm == that.realm);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,5 @@\n bool AuthChallengeInfo::Equals(const AuthChallengeInfo& that) const {\n   return (this->is_proxy == that.is_proxy &&\n-          this->challenger.Equals(that.challenger) &&\n-          this->scheme == that.scheme &&\n+          this->challenger == that.challenger && this->scheme == that.scheme &&\n           this->realm == that.realm);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "          this->challenger.Equals(that.challenger) &&",
                "          this->scheme == that.scheme &&"
            ],
            "added_lines": [
                "          this->challenger == that.challenger && this->scheme == that.scheme &&"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-5133",
        "func_name": "chromium/CreateLoginPrompt",
        "description": "Google Chrome before 52.0.2743.82 mishandles origin information during proxy authentication, which allows man-in-the-middle attackers to spoof a proxy-authentication login prompt or trigger incorrect credential storage by modifying the client-server data stream.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/098c009df7a4ddc5c23d4d3c9dccf5eff1f24c98",
        "commit_title": "Use correct origin when prompting for proxy authentication.",
        "commit_text": " Since M49, Chrome has been prompting for proxy authentication credentials using the target origin instead of the origin of the proxy server. Even if the proxy origin was displayed correctly, a mischievous network operator could still spoof the proxy server origin. To mitigate these problems, this CL:  * Fixes the origin used in the proxy authentication login prompt to use   the origin of the proxy server.  * Indicate if the proxy server connection is insecure.  * Always throw up an interstitial and clear the omnibox when showing a   proxy auth prompt.  * Use the correct origin when saving proxy authentication credentials.   Review-Url: https://codereview.chromium.org/2067933002 ",
        "func_before": "LoginHandler* CreateLoginPrompt(net::AuthChallengeInfo* auth_info,\n                                net::URLRequest* request) {\n  bool is_main_frame = (request->load_flags() & net::LOAD_MAIN_FRAME) != 0;\n  LoginHandler* handler = LoginHandler::Create(auth_info, request);\n  BrowserThread::PostTask(\n      BrowserThread::UI, FROM_HERE,\n      base::Bind(&LoginDialogCallback, request->url(),\n                 base::RetainedRef(auth_info), base::RetainedRef(handler),\n                 is_main_frame));\n  return handler;\n}",
        "func": "LoginHandler* CreateLoginPrompt(net::AuthChallengeInfo* auth_info,\n                                net::URLRequest* request) {\n  bool is_main_frame = (request->load_flags() & net::LOAD_MAIN_FRAME) != 0;\n  LoginHandler* handler = LoginHandler::Create(auth_info, request);\n  BrowserThread::PostTask(\n      BrowserThread::UI, FROM_HERE,\n      base::Bind(&LoginHandler::LoginDialogCallback, request->url(),\n                 base::RetainedRef(auth_info), base::RetainedRef(handler),\n                 is_main_frame));\n  return handler;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,7 +4,7 @@\n   LoginHandler* handler = LoginHandler::Create(auth_info, request);\n   BrowserThread::PostTask(\n       BrowserThread::UI, FROM_HERE,\n-      base::Bind(&LoginDialogCallback, request->url(),\n+      base::Bind(&LoginHandler::LoginDialogCallback, request->url(),\n                  base::RetainedRef(auth_info), base::RetainedRef(handler),\n                  is_main_frame));\n   return handler;",
        "diff_line_info": {
            "deleted_lines": [
                "      base::Bind(&LoginDialogCallback, request->url(),"
            ],
            "added_lines": [
                "      base::Bind(&LoginHandler::LoginDialogCallback, request->url(),"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-5133",
        "func_name": "chromium/HttpAuthController::PopulateAuthChallenge",
        "description": "Google Chrome before 52.0.2743.82 mishandles origin information during proxy authentication, which allows man-in-the-middle attackers to spoof a proxy-authentication login prompt or trigger incorrect credential storage by modifying the client-server data stream.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/098c009df7a4ddc5c23d4d3c9dccf5eff1f24c98",
        "commit_title": "Use correct origin when prompting for proxy authentication.",
        "commit_text": " Since M49, Chrome has been prompting for proxy authentication credentials using the target origin instead of the origin of the proxy server. Even if the proxy origin was displayed correctly, a mischievous network operator could still spoof the proxy server origin. To mitigate these problems, this CL:  * Fixes the origin used in the proxy authentication login prompt to use   the origin of the proxy server.  * Indicate if the proxy server connection is insecure.  * Always throw up an interstitial and clear the omnibox when showing a   proxy auth prompt.  * Use the correct origin when saving proxy authentication credentials.   Review-Url: https://codereview.chromium.org/2067933002 ",
        "func_before": "void HttpAuthController::PopulateAuthChallenge() {\n  DCHECK(CalledOnValidThread());\n\n  // Populates response_.auth_challenge with the authentication challenge info.\n  // This info is consumed by URLRequestHttpJob::GetAuthChallengeInfo().\n\n  auth_info_ = new AuthChallengeInfo;\n  auth_info_->is_proxy = (target_ == HttpAuth::AUTH_PROXY);\n  auth_info_->challenger = HostPortPair::FromURL(auth_origin_);\n  auth_info_->scheme = HttpAuth::SchemeToString(handler_->auth_scheme());\n  auth_info_->realm = handler_->realm();\n}",
        "func": "void HttpAuthController::PopulateAuthChallenge() {\n  DCHECK(CalledOnValidThread());\n\n  // Populates response_.auth_challenge with the authentication challenge info.\n  // This info is consumed by URLRequestHttpJob::GetAuthChallengeInfo().\n\n  auth_info_ = new AuthChallengeInfo;\n  auth_info_->is_proxy = (target_ == HttpAuth::AUTH_PROXY);\n  auth_info_->challenger = url::Origin(auth_origin_);\n  auth_info_->scheme = HttpAuth::SchemeToString(handler_->auth_scheme());\n  auth_info_->realm = handler_->realm();\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,7 +6,7 @@\n \n   auth_info_ = new AuthChallengeInfo;\n   auth_info_->is_proxy = (target_ == HttpAuth::AUTH_PROXY);\n-  auth_info_->challenger = HostPortPair::FromURL(auth_origin_);\n+  auth_info_->challenger = url::Origin(auth_origin_);\n   auth_info_->scheme = HttpAuth::SchemeToString(handler_->auth_scheme());\n   auth_info_->realm = handler_->realm();\n }",
        "diff_line_info": {
            "deleted_lines": [
                "  auth_info_->challenger = HostPortPair::FromURL(auth_origin_);"
            ],
            "added_lines": [
                "  auth_info_->challenger = url::Origin(auth_origin_);"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-5133",
        "func_name": "chromium/URLRequestFtpJob::GetAuthChallengeInfo",
        "description": "Google Chrome before 52.0.2743.82 mishandles origin information during proxy authentication, which allows man-in-the-middle attackers to spoof a proxy-authentication login prompt or trigger incorrect credential storage by modifying the client-server data stream.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/098c009df7a4ddc5c23d4d3c9dccf5eff1f24c98",
        "commit_title": "Use correct origin when prompting for proxy authentication.",
        "commit_text": " Since M49, Chrome has been prompting for proxy authentication credentials using the target origin instead of the origin of the proxy server. Even if the proxy origin was displayed correctly, a mischievous network operator could still spoof the proxy server origin. To mitigate these problems, this CL:  * Fixes the origin used in the proxy authentication login prompt to use   the origin of the proxy server.  * Indicate if the proxy server connection is insecure.  * Always throw up an interstitial and clear the omnibox when showing a   proxy auth prompt.  * Use the correct origin when saving proxy authentication credentials.   Review-Url: https://codereview.chromium.org/2067933002 ",
        "func_before": "void URLRequestFtpJob::GetAuthChallengeInfo(\n    scoped_refptr<AuthChallengeInfo>* result) {\n  DCHECK(NeedsAuth());\n\n  if (http_response_info_) {\n    *result = http_response_info_->auth_challenge;\n    return;\n  }\n\n  scoped_refptr<AuthChallengeInfo> auth_info(new AuthChallengeInfo);\n  auth_info->is_proxy = false;\n  auth_info->challenger = HostPortPair::FromURL(request_->url());\n  // scheme and realm are kept empty.\n  DCHECK(auth_info->scheme.empty());\n  DCHECK(auth_info->realm.empty());\n  result->swap(auth_info);\n}",
        "func": "void URLRequestFtpJob::GetAuthChallengeInfo(\n    scoped_refptr<AuthChallengeInfo>* result) {\n  DCHECK(NeedsAuth());\n\n  if (http_response_info_) {\n    *result = http_response_info_->auth_challenge;\n    return;\n  }\n\n  scoped_refptr<AuthChallengeInfo> auth_info(new AuthChallengeInfo);\n  auth_info->is_proxy = false;\n  auth_info->challenger = url::Origin(request_->url());\n  // scheme and realm are kept empty.\n  DCHECK(auth_info->scheme.empty());\n  DCHECK(auth_info->realm.empty());\n  result->swap(auth_info);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -9,7 +9,7 @@\n \n   scoped_refptr<AuthChallengeInfo> auth_info(new AuthChallengeInfo);\n   auth_info->is_proxy = false;\n-  auth_info->challenger = HostPortPair::FromURL(request_->url());\n+  auth_info->challenger = url::Origin(request_->url());\n   // scheme and realm are kept empty.\n   DCHECK(auth_info->scheme.empty());\n   DCHECK(auth_info->realm.empty());",
        "diff_line_info": {
            "deleted_lines": [
                "  auth_info->challenger = HostPortPair::FromURL(request_->url());"
            ],
            "added_lines": [
                "  auth_info->challenger = url::Origin(request_->url());"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-5133",
        "func_name": "chromium/ShellLoginDialog::ShellLoginDialog",
        "description": "Google Chrome before 52.0.2743.82 mishandles origin information during proxy authentication, which allows man-in-the-middle attackers to spoof a proxy-authentication login prompt or trigger incorrect credential storage by modifying the client-server data stream.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/098c009df7a4ddc5c23d4d3c9dccf5eff1f24c98",
        "commit_title": "Use correct origin when prompting for proxy authentication.",
        "commit_text": " Since M49, Chrome has been prompting for proxy authentication credentials using the target origin instead of the origin of the proxy server. Even if the proxy origin was displayed correctly, a mischievous network operator could still spoof the proxy server origin. To mitigate these problems, this CL:  * Fixes the origin used in the proxy authentication login prompt to use   the origin of the proxy server.  * Indicate if the proxy server connection is insecure.  * Always throw up an interstitial and clear the omnibox when showing a   proxy auth prompt.  * Use the correct origin when saving proxy authentication credentials.   Review-Url: https://codereview.chromium.org/2067933002 ",
        "func_before": "ShellLoginDialog::ShellLoginDialog(\n    net::AuthChallengeInfo* auth_info,\n    net::URLRequest* request) : auth_info_(auth_info),\n                                request_(request) {\n  DCHECK_CURRENTLY_ON(BrowserThread::IO);\n  BrowserThread::PostTask(\n      BrowserThread::UI, FROM_HERE,\n      base::Bind(&ShellLoginDialog::PrepDialog, this,\n                 base::ASCIIToUTF16(auth_info->challenger.ToString()),\n                 base::UTF8ToUTF16(auth_info->realm)));\n}",
        "func": "ShellLoginDialog::ShellLoginDialog(\n    net::AuthChallengeInfo* auth_info,\n    net::URLRequest* request) : auth_info_(auth_info),\n                                request_(request) {\n  DCHECK_CURRENTLY_ON(BrowserThread::IO);\n  BrowserThread::PostTask(\n      BrowserThread::UI, FROM_HERE,\n      base::Bind(\n          &ShellLoginDialog::PrepDialog, this,\n          url_formatter::FormatOriginForSecurityDisplay(auth_info->challenger),\n          base::UTF8ToUTF16(auth_info->realm)));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,7 +5,8 @@\n   DCHECK_CURRENTLY_ON(BrowserThread::IO);\n   BrowserThread::PostTask(\n       BrowserThread::UI, FROM_HERE,\n-      base::Bind(&ShellLoginDialog::PrepDialog, this,\n-                 base::ASCIIToUTF16(auth_info->challenger.ToString()),\n-                 base::UTF8ToUTF16(auth_info->realm)));\n+      base::Bind(\n+          &ShellLoginDialog::PrepDialog, this,\n+          url_formatter::FormatOriginForSecurityDisplay(auth_info->challenger),\n+          base::UTF8ToUTF16(auth_info->realm)));\n }",
        "diff_line_info": {
            "deleted_lines": [
                "      base::Bind(&ShellLoginDialog::PrepDialog, this,",
                "                 base::ASCIIToUTF16(auth_info->challenger.ToString()),",
                "                 base::UTF8ToUTF16(auth_info->realm)));"
            ],
            "added_lines": [
                "      base::Bind(",
                "          &ShellLoginDialog::PrepDialog, this,",
                "          url_formatter::FormatOriginForSecurityDisplay(auth_info->challenger),",
                "          base::UTF8ToUTF16(auth_info->realm)));"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-7145",
        "func_name": "evilnet/nefarious2/m_authenticate",
        "description": "The m_authenticate function in ircd/m_authenticate.c in nefarious2 allows remote attackers to spoof certificate fingerprints and consequently log in as another user via a crafted AUTHENTICATE parameter.",
        "git_url": "https://github.com/evilnet/nefarious2/commit/f50a84bad996d438e7b31b9e74c32a41e43f8be5",
        "commit_title": "Fix to prevent SASL security vulnerability",
        "commit_text": "",
        "func_before": "int m_authenticate(struct Client* cptr, struct Client* sptr, int parc, char* parv[])\n{\n  struct Client* acptr;\n  int first = 0;\n  char realhost[HOSTLEN + 3];\n  char *hoststr = (cli_sockhost(cptr) ? cli_sockhost(cptr) : cli_sock_ip(cptr));\n\n  if (!CapActive(cptr, CAP_SASL))\n    return 0;\n\n  if (parc < 2) /* have enough parameters? */\n    return need_more_params(cptr, \"AUTHENTICATE\");\n\n  if (strlen(parv[1]) > 400)\n    return send_reply(cptr, ERR_SASLTOOLONG);\n\n  if (IsSASLComplete(cptr))\n    return send_reply(cptr, ERR_SASLALREADY);\n\n  /* Look up the target server */\n  if (!(acptr = cli_saslagent(cptr))) {\n    if (strcmp(feature_str(FEAT_SASL_SERVER), \"*\"))\n      acptr = find_match_server((char *)feature_str(FEAT_SASL_SERVER));\n    else\n      acptr = NULL;\n  }\n\n  if (!acptr && strcmp(feature_str(FEAT_SASL_SERVER), \"*\"))\n    return send_reply(cptr, ERR_SASLFAIL, \": service unavailable\");\n\n  /* If it's to us, do nothing; otherwise, forward the query */\n  if (acptr && IsMe(acptr))\n    return 0;\n\n  /* Generate an SASL session cookie if not already generated */\n  if (!cli_saslcookie(cptr)) {\n    do {\n      cli_saslcookie(cptr) = ircrandom() & 0x7fffffff;\n    } while (!cli_saslcookie(cptr));\n    first = 1;\n  }\n\n  if (strchr(hoststr, ':') != NULL)\n    ircd_snprintf(0, realhost, sizeof(realhost), \"[%s]\", hoststr);\n  else\n    ircd_strncpy(realhost, hoststr, sizeof(realhost));\n\n  if (acptr) {\n    if (first) {\n      if (!EmptyString(cli_sslclifp(cptr)))\n        sendcmdto_one(&me, CMD_SASL, acptr, \"%C %C!%u.%u S %s :%s\", acptr, &me,\n                      cli_fd(cptr), cli_saslcookie(cptr),\n                      parv[1], cli_sslclifp(cptr));\n      else\n        sendcmdto_one(&me, CMD_SASL, acptr, \"%C %C!%u.%u S :%s\", acptr, &me,\n                      cli_fd(cptr), cli_saslcookie(cptr), parv[1]);\n      if (feature_bool(FEAT_SASL_SENDHOST))\n        sendcmdto_one(&me, CMD_SASL, acptr, \"%C %C!%u.%u H :%s@%s:%s\", acptr, &me,\n                      cli_fd(cptr), cli_saslcookie(cptr), cli_username(cptr),\n                      realhost, cli_sock_ip(cptr));\n    } else {\n      sendcmdto_one(&me, CMD_SASL, acptr, \"%C %C!%u.%u C :%s\", acptr, &me,\n                    cli_fd(cptr), cli_saslcookie(cptr), parv[1]);\n    }\n  } else {\n    if (first) {\n      if (!EmptyString(cli_sslclifp(cptr)))\n        sendcmdto_serv_butone(&me, CMD_SASL, cptr, \"* %C!%u.%u S %s :%s\", &me,\n                              cli_fd(cptr), cli_saslcookie(cptr),\n                              parv[1], cli_sslclifp(cptr));\n      else\n        sendcmdto_serv_butone(&me, CMD_SASL, cptr, \"* %C!%u.%u S :%s\", &me,\n                              cli_fd(cptr), cli_saslcookie(cptr), parv[1]);\n      if (feature_bool(FEAT_SASL_SENDHOST))\n        sendcmdto_serv_butone(&me, CMD_SASL, cptr, \"* %C!%u.%u H :%s@%s:%s\", &me,\n                              cli_fd(cptr), cli_saslcookie(cptr), cli_username(cptr),\n                              realhost, cli_sock_ip(cptr));\n    } else {\n      sendcmdto_serv_butone(&me, CMD_SASL, cptr, \"* %C!%u.%u C :%s\", &me,\n                            cli_fd(cptr), cli_saslcookie(cptr), parv[1]);\n    }\n  }\n\n  if (!t_active(&cli_sasltimeout(cptr)))\n    timer_add(timer_init(&cli_sasltimeout(cptr)), sasl_timeout_callback, (void*) cptr,\n              TT_RELATIVE, feature_int(FEAT_SASL_TIMEOUT));\n\n  return 0;\n}",
        "func": "int m_authenticate(struct Client* cptr, struct Client* sptr, int parc, char* parv[])\n{\n  struct Client* acptr;\n  int first = 0;\n  char realhost[HOSTLEN + 3];\n  char *hoststr = (cli_sockhost(cptr) ? cli_sockhost(cptr) : cli_sock_ip(cptr));\n\n  if (!CapActive(cptr, CAP_SASL))\n    return 0;\n\n  if (parc < 2) /* have enough parameters? */\n    return need_more_params(cptr, \"AUTHENTICATE\");\n\n  if (strlen(parv[1]) > 400)\n    return send_reply(cptr, ERR_SASLTOOLONG);\n\n  if (IsSASLComplete(cptr))\n    return send_reply(cptr, ERR_SASLALREADY);\n\n  /* Look up the target server */\n  if (!(acptr = cli_saslagent(cptr))) {\n    if (strcmp(feature_str(FEAT_SASL_SERVER), \"*\"))\n      acptr = find_match_server((char *)feature_str(FEAT_SASL_SERVER));\n    else\n      acptr = NULL;\n  }\n\n  if (!acptr && strcmp(feature_str(FEAT_SASL_SERVER), \"*\"))\n    return send_reply(cptr, ERR_SASLFAIL, \": service unavailable\");\n\n  /* If it's to us, do nothing; otherwise, forward the query */\n  if (acptr && IsMe(acptr))\n    return 0;\n\n  /* Generate an SASL session cookie if not already generated */\n  if (!cli_saslcookie(cptr)) {\n    do {\n      cli_saslcookie(cptr) = ircrandom() & 0x7fffffff;\n    } while (!cli_saslcookie(cptr));\n    first = 1;\n  }\n\n  if (strchr(hoststr, ':') != NULL)\n    ircd_snprintf(0, realhost, sizeof(realhost), \"[%s]\", hoststr);\n  else\n    ircd_strncpy(realhost, hoststr, sizeof(realhost));\n\n  if (acptr) {\n    if (first) {\n      if (*parv[1] == ':' || strchr(parv[1], ' '))\n\t\treturn exit_client(cptr, sptr, sptr, \"Malformed AUTHENTICATE\");\n      if (!EmptyString(cli_sslclifp(cptr)))\n        sendcmdto_one(&me, CMD_SASL, acptr, \"%C %C!%u.%u S %s :%s\", acptr, &me,\n                      cli_fd(cptr), cli_saslcookie(cptr),\n                      parv[1], cli_sslclifp(cptr));\n      else\n        sendcmdto_one(&me, CMD_SASL, acptr, \"%C %C!%u.%u S :%s\", acptr, &me,\n                      cli_fd(cptr), cli_saslcookie(cptr), parv[1]);\n      if (feature_bool(FEAT_SASL_SENDHOST))\n        sendcmdto_one(&me, CMD_SASL, acptr, \"%C %C!%u.%u H :%s@%s:%s\", acptr, &me,\n                      cli_fd(cptr), cli_saslcookie(cptr), cli_username(cptr),\n                      realhost, cli_sock_ip(cptr));\n    } else {\n      sendcmdto_one(&me, CMD_SASL, acptr, \"%C %C!%u.%u C :%s\", acptr, &me,\n                    cli_fd(cptr), cli_saslcookie(cptr), parv[1]);\n    }\n  } else {\n    if (first) {\n      if (*parv[1] == ':' || strchr(parv[1], ' '))\n        return exit_client(cptr, sptr, sptr, \"Malformed AUTHENTICATE\");\n      if (!EmptyString(cli_sslclifp(cptr)))\n        sendcmdto_serv_butone(&me, CMD_SASL, cptr, \"* %C!%u.%u S %s :%s\", &me,\n                              cli_fd(cptr), cli_saslcookie(cptr),\n                              parv[1], cli_sslclifp(cptr));\n      else\n        sendcmdto_serv_butone(&me, CMD_SASL, cptr, \"* %C!%u.%u S :%s\", &me,\n                              cli_fd(cptr), cli_saslcookie(cptr), parv[1]);\n      if (feature_bool(FEAT_SASL_SENDHOST))\n        sendcmdto_serv_butone(&me, CMD_SASL, cptr, \"* %C!%u.%u H :%s@%s:%s\", &me,\n                              cli_fd(cptr), cli_saslcookie(cptr), cli_username(cptr),\n                              realhost, cli_sock_ip(cptr));\n    } else {\n      sendcmdto_serv_butone(&me, CMD_SASL, cptr, \"* %C!%u.%u C :%s\", &me,\n                            cli_fd(cptr), cli_saslcookie(cptr), parv[1]);\n    }\n  }\n\n  if (!t_active(&cli_sasltimeout(cptr)))\n    timer_add(timer_init(&cli_sasltimeout(cptr)), sasl_timeout_callback, (void*) cptr,\n              TT_RELATIVE, feature_int(FEAT_SASL_TIMEOUT));\n\n  return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -47,6 +47,8 @@\n \n   if (acptr) {\n     if (first) {\n+      if (*parv[1] == ':' || strchr(parv[1], ' '))\n+\t\treturn exit_client(cptr, sptr, sptr, \"Malformed AUTHENTICATE\");\n       if (!EmptyString(cli_sslclifp(cptr)))\n         sendcmdto_one(&me, CMD_SASL, acptr, \"%C %C!%u.%u S %s :%s\", acptr, &me,\n                       cli_fd(cptr), cli_saslcookie(cptr),\n@@ -64,6 +66,8 @@\n     }\n   } else {\n     if (first) {\n+      if (*parv[1] == ':' || strchr(parv[1], ' '))\n+        return exit_client(cptr, sptr, sptr, \"Malformed AUTHENTICATE\");\n       if (!EmptyString(cli_sslclifp(cptr)))\n         sendcmdto_serv_butone(&me, CMD_SASL, cptr, \"* %C!%u.%u S %s :%s\", &me,\n                               cli_fd(cptr), cli_saslcookie(cptr),",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "      if (*parv[1] == ':' || strchr(parv[1], ' '))",
                "\t\treturn exit_client(cptr, sptr, sptr, \"Malformed AUTHENTICATE\");",
                "      if (*parv[1] == ':' || strchr(parv[1], ' '))",
                "        return exit_client(cptr, sptr, sptr, \"Malformed AUTHENTICATE\");"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-6817",
        "func_name": "pgbouncer/start_auth_request",
        "description": "PgBouncer 1.6.x before 1.6.1, when configured with auth_user, allows remote attackers to gain login access as auth_user via an unknown username.",
        "git_url": "https://github.com/pgbouncer/pgbouncer/commit/7ca3e5279d05fceb1e8a043c6f5b6f58dea3ed38",
        "commit_title": "Remove too early set of auth_user",
        "commit_text": " When query returns 0 rows (user not found), this user stays as login user...  Should fix #69.",
        "func_before": "static void start_auth_request(PgSocket *client, const char *username)\n{\n\tint res;\n\tPktBuf *buf;\n\n\tclient->auth_user = client->db->auth_user;\n\t/* have to fetch user info from db */\n\tclient->pool = get_pool(client->db, client->db->auth_user);\n\tif (!find_server(client)) {\n\t\tclient->wait_for_user_conn = true;\n\t\treturn;\n\t}\n\tslog_noise(client, \"Doing auth_conn query\");\n\tclient->wait_for_user_conn = false;\n\tclient->wait_for_user = true;\n\tif (!sbuf_pause(&client->sbuf)) {\n\t\trelease_server(client->link);\n\t\tdisconnect_client(client, true, \"pause failed\");\n\t\treturn;\n\t}\n\tclient->link->ready = 0;\n\n\tres = 0;\n\tbuf = pktbuf_dynamic(512);\n\tif (buf) {\n\t\tpktbuf_write_ExtQuery(buf, cf_auth_query, 1, username);\n\t\tres = pktbuf_send_immediate(buf, client->link);\n\t\tpktbuf_free(buf);\n\t\t/*\n\t\t * Should do instead:\n\t\t *   res = pktbuf_send_queued(buf, client->link);\n\t\t * but that needs better integration with SBuf.\n\t\t */\n\t}\n\tif (!res)\n\t\tdisconnect_server(client->link, false, \"unable to send login query\");\n}",
        "func": "static void start_auth_request(PgSocket *client, const char *username)\n{\n\tint res;\n\tPktBuf *buf;\n\n\t/* have to fetch user info from db */\n\tclient->pool = get_pool(client->db, client->db->auth_user);\n\tif (!find_server(client)) {\n\t\tclient->wait_for_user_conn = true;\n\t\treturn;\n\t}\n\tslog_noise(client, \"Doing auth_conn query\");\n\tclient->wait_for_user_conn = false;\n\tclient->wait_for_user = true;\n\tif (!sbuf_pause(&client->sbuf)) {\n\t\trelease_server(client->link);\n\t\tdisconnect_client(client, true, \"pause failed\");\n\t\treturn;\n\t}\n\tclient->link->ready = 0;\n\n\tres = 0;\n\tbuf = pktbuf_dynamic(512);\n\tif (buf) {\n\t\tpktbuf_write_ExtQuery(buf, cf_auth_query, 1, username);\n\t\tres = pktbuf_send_immediate(buf, client->link);\n\t\tpktbuf_free(buf);\n\t\t/*\n\t\t * Should do instead:\n\t\t *   res = pktbuf_send_queued(buf, client->link);\n\t\t * but that needs better integration with SBuf.\n\t\t */\n\t}\n\tif (!res)\n\t\tdisconnect_server(client->link, false, \"unable to send login query\");\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,7 +3,6 @@\n \tint res;\n \tPktBuf *buf;\n \n-\tclient->auth_user = client->db->auth_user;\n \t/* have to fetch user info from db */\n \tclient->pool = get_pool(client->db, client->db->auth_user);\n \tif (!find_server(client)) {",
        "diff_line_info": {
            "deleted_lines": [
                "\tclient->auth_user = client->db->auth_user;"
            ],
            "added_lines": []
        }
    },
    {
        "cve_id": "CVE-2017-10807",
        "func_name": "jabberd2/_c2s_sx_sasl_callback",
        "description": "JabberD 2.x (aka jabberd2) before 2.6.1 allows anyone to authenticate using SASL ANONYMOUS, even when the sasl.anonymous c2s.xml option is not enabled.",
        "git_url": "https://github.com/jabberd2/jabberd2/commit/8416ae54ecefa670534f27a31db71d048b9c7f16",
        "commit_title": "Fixed offered SASL mechanism check",
        "commit_text": "",
        "func_before": "static int _c2s_sx_sasl_callback(int cb, void *arg, void **res, sx_t s, void *cbarg) {\n    c2s_t c2s = (c2s_t) cbarg;\n    const char *my_realm, *mech;\n    sx_sasl_creds_t creds;\n    static char buf[3072];\n    char mechbuf[256];\n    struct jid_st jid;\n    jid_static_buf jid_buf;\n    int i, r;\n    sess_t sess;\n    char skey[44];\n    host_t host;\n\n    /* init static jid */\n    jid_static(&jid,&jid_buf);\n\n    /* retrieve our session */\n    assert(s != NULL);\n    sprintf(skey, \"%d\", s->tag);\n\n    /*\n     * Retrieve the session, note that depending on the operation,\n     * session may be null.\n     */\n    sess = xhash_get(c2s->sessions, skey);\n\n    switch(cb) {\n        case sx_sasl_cb_GET_REALM:\n\n            if(s->req_to == NULL)   /* this shouldn't happen */\n                my_realm = \"\";\n\n            else {\n                /* get host for request */\n                host = xhash_get(c2s->hosts, s->req_to);\n                if(host == NULL) {\n                    log_write(c2s->log, LOG_ERR, \"SASL callback for non-existing host: %s\", s->req_to);\n                    *res = (void *)NULL;\n                    return sx_sasl_ret_FAIL;\n                }\n\n                my_realm = host->realm;\n                if(my_realm == NULL)\n                    my_realm = s->req_to;\n            }\n\n            strncpy(buf, my_realm, 256);\n            *res = (void *)buf;\n\n            log_debug(ZONE, \"sx sasl callback: get realm: realm is '%s'\", buf);\n            return sx_sasl_ret_OK;\n            break;\n\n        case sx_sasl_cb_GET_PASS:\n            assert(sess != NULL);\n            creds = (sx_sasl_creds_t) arg;\n\n            log_debug(ZONE, \"sx sasl callback: get pass (authnid=%s, realm=%s)\", creds->authnid, creds->realm);\n\n            if(sess->host->ar->get_password && (sess->host->ar->get_password)(\n                        sess->host->ar, sess, (char *)creds->authnid, (creds->realm != NULL) ? (char *)creds->realm: \"\", buf) == 0) {\n                *res = buf;\n                return sx_sasl_ret_OK;\n            }\n\n            return sx_sasl_ret_FAIL;\n\n        case sx_sasl_cb_CHECK_PASS:\n            assert(sess != NULL);\n            creds = (sx_sasl_creds_t) arg;\n\n            log_debug(ZONE, \"sx sasl callback: check pass (authnid=%s, realm=%s)\", creds->authnid, creds->realm);\n\n            if(sess->host->ar->check_password != NULL) {\n                if ((sess->host->ar->check_password)(\n                            sess->host->ar, sess, (char *)creds->authnid, (creds->realm != NULL) ? (char *)creds->realm : \"\", (char *)creds->pass) == 0)\n                    return sx_sasl_ret_OK;\n                else\n                    return sx_sasl_ret_FAIL;\n            }\n\n            if(sess->host->ar->get_password != NULL) {\n                if ((sess->host->ar->get_password)(sess->host->ar, sess, (char *)creds->authnid, (creds->realm != NULL) ? (char *)creds->realm : \"\", buf) != 0)\n                    return sx_sasl_ret_FAIL;\n\n                if (strcmp(creds->pass, buf)==0)\n                    return sx_sasl_ret_OK;\n            }\n\n            return sx_sasl_ret_FAIL;\n            break;\n\n        case sx_sasl_cb_CHECK_AUTHZID:\n            assert(sess != NULL);\n            creds = (sx_sasl_creds_t) arg;\n\n            /* we need authzid to validate */\n            if(creds->authzid == NULL || creds->authzid[0] == '\\0')\n                return sx_sasl_ret_FAIL;\n\n            /* authzid must be a valid jid */\n            if(jid_reset(&jid, creds->authzid, -1) == NULL)\n                return sx_sasl_ret_FAIL;\n\n            /* and have domain == stream to addr */\n            if(!s->req_to || (strcmp(jid.domain, s->req_to) != 0))\n                return sx_sasl_ret_FAIL;\n\n            /* and have no resource */\n            if(jid.resource[0] != '\\0')\n                return sx_sasl_ret_FAIL;\n\n            /* and user has right to authorize as */\n            if (sess->host->ar->user_authz_allowed) {\n                if (sess->host->ar->user_authz_allowed(sess->host->ar, sess, (char *)creds->authnid, (char *)creds->realm, (char *)creds->authzid))\n                        return sx_sasl_ret_OK;\n            } else {\n                if (strcmp(creds->authnid, jid.node) == 0 &&\n                    (sess->host->ar->user_exists)(sess->host->ar, sess, jid.node, jid.domain))\n                    return sx_sasl_ret_OK;\n            }\n\n            return sx_sasl_ret_FAIL;\n\n        case sx_sasl_cb_GEN_AUTHZID:\n            /* generate a jid for SASL ANONYMOUS */\n            jid_reset(&jid, s->req_to, -1);\n\n            /* make node a random string */\n            jid_random_part(&jid, jid_NODE);\n\n            strcpy(buf, jid.node);\n\n            *res = (void *)buf;\n\n            return sx_sasl_ret_OK;\n            break;\n\n        case sx_sasl_cb_CHECK_MECH:\n            mech = (char *)arg;\n\n            strncpy(mechbuf, mech, sizeof(mechbuf));\n            mechbuf[sizeof(mechbuf)-1]='\\0';\n            for(i = 0; mechbuf[i]; i++) mechbuf[i] = tolower(mechbuf[i]);\n\n            /* get host for request */\n            host = xhash_get(c2s->hosts, s->req_to);\n            if(host == NULL) {\n                log_write(c2s->log, LOG_WARNING, \"SASL callback for non-existing host: %s\", s->req_to);\n                return sx_sasl_ret_FAIL;\n            }\n\n            /* Determine if our configuration will let us use this mechanism.\n             * We support different mechanisms for both SSL and normal use */\n            if (strcmp(mechbuf, \"digest-md5\") == 0) {\n                /* digest-md5 requires that our authreg support get_password */\n                if (host->ar->get_password == NULL)\n                    return sx_sasl_ret_FAIL;\n            } else if (strcmp(mechbuf, \"plain\") == 0) {\n                /* plain requires either get_password or check_password */\n                if (host->ar->get_password == NULL && host->ar->check_password == NULL)\n                    return sx_sasl_ret_FAIL;\n            }\n\n            /* Using SSF is potentially dangerous, as SASL can also set the\n             * SSF of the connection. However, SASL shouldn't do so until after\n             * we've finished mechanism establishment\n             */\n            if (s->ssf>0) {\n                r = snprintf(buf, sizeof(buf), \"authreg.ssl-mechanisms.sasl.%s\",mechbuf);\n                if (r < -1 || r > sizeof(buf))\n                    return sx_sasl_ret_FAIL;\n                if(config_get(c2s->config,buf) != NULL)\n                    return sx_sasl_ret_OK;\n            }\n\n            r = snprintf(buf, sizeof(buf), \"authreg.mechanisms.sasl.%s\",mechbuf);\n            if (r < -1 || r > sizeof(buf))\n                return sx_sasl_ret_FAIL;\n\n            /* Work out if our configuration will let us use this mechanism */\n            if(config_get(c2s->config,buf) != NULL)\n                return sx_sasl_ret_OK;\n            else\n                return sx_sasl_ret_FAIL;\n        default:\n            break;\n    }\n\n    return sx_sasl_ret_FAIL;\n}",
        "func": "static int _c2s_sx_sasl_callback(int cb, void *arg, void **res, sx_t s, void *cbarg) {\n    c2s_t c2s = (c2s_t) cbarg;\n    const char *my_realm, *mech;\n    sx_sasl_creds_t creds;\n    static char buf[3072];\n    char mechbuf[256];\n    struct jid_st jid;\n    jid_static_buf jid_buf;\n    int i, r;\n    sess_t sess;\n    char skey[44];\n    host_t host;\n\n    /* init static jid */\n    jid_static(&jid,&jid_buf);\n\n    /* retrieve our session */\n    assert(s != NULL);\n    sprintf(skey, \"%d\", s->tag);\n\n    /*\n     * Retrieve the session, note that depending on the operation,\n     * session may be null.\n     */\n    sess = xhash_get(c2s->sessions, skey);\n\n    switch(cb) {\n        case sx_sasl_cb_GET_REALM:\n\n            if(s->req_to == NULL)   /* this shouldn't happen */\n                my_realm = \"\";\n\n            else {\n                /* get host for request */\n                host = xhash_get(c2s->hosts, s->req_to);\n                if(host == NULL) {\n                    log_write(c2s->log, LOG_ERR, \"SASL callback for non-existing host: %s\", s->req_to);\n                    *res = (void *)NULL;\n                    return sx_sasl_ret_FAIL;\n                }\n\n                my_realm = host->realm;\n                if(my_realm == NULL)\n                    my_realm = s->req_to;\n            }\n\n            strncpy(buf, my_realm, 256);\n            *res = (void *)buf;\n\n            log_debug(ZONE, \"sx sasl callback: get realm: realm is '%s'\", buf);\n            return sx_sasl_ret_OK;\n            break;\n\n        case sx_sasl_cb_GET_PASS:\n            assert(sess != NULL);\n            creds = (sx_sasl_creds_t) arg;\n\n            log_debug(ZONE, \"sx sasl callback: get pass (authnid=%s, realm=%s)\", creds->authnid, creds->realm);\n\n            if(sess->host->ar->get_password && (sess->host->ar->get_password)(\n                        sess->host->ar, sess, (char *)creds->authnid, (creds->realm != NULL) ? (char *)creds->realm: \"\", buf) == 0) {\n                *res = buf;\n                return sx_sasl_ret_OK;\n            }\n\n            return sx_sasl_ret_FAIL;\n\n        case sx_sasl_cb_CHECK_PASS:\n            assert(sess != NULL);\n            creds = (sx_sasl_creds_t) arg;\n\n            log_debug(ZONE, \"sx sasl callback: check pass (authnid=%s, realm=%s)\", creds->authnid, creds->realm);\n\n            if(sess->host->ar->check_password != NULL) {\n                if ((sess->host->ar->check_password)(\n                            sess->host->ar, sess, (char *)creds->authnid, (creds->realm != NULL) ? (char *)creds->realm : \"\", (char *)creds->pass) == 0)\n                    return sx_sasl_ret_OK;\n                else\n                    return sx_sasl_ret_FAIL;\n            }\n\n            if(sess->host->ar->get_password != NULL) {\n                if ((sess->host->ar->get_password)(sess->host->ar, sess, (char *)creds->authnid, (creds->realm != NULL) ? (char *)creds->realm : \"\", buf) != 0)\n                    return sx_sasl_ret_FAIL;\n\n                if (strcmp(creds->pass, buf)==0)\n                    return sx_sasl_ret_OK;\n            }\n\n            return sx_sasl_ret_FAIL;\n            break;\n\n        case sx_sasl_cb_CHECK_AUTHZID:\n            assert(sess != NULL);\n            creds = (sx_sasl_creds_t) arg;\n\n            /* we need authzid to validate */\n            if(creds->authzid == NULL || creds->authzid[0] == '\\0')\n                return sx_sasl_ret_FAIL;\n\n            /* authzid must be a valid jid */\n            if(jid_reset(&jid, creds->authzid, -1) == NULL)\n                return sx_sasl_ret_FAIL;\n\n            /* and have domain == stream to addr */\n            if(!s->req_to || (strcmp(jid.domain, s->req_to) != 0))\n                return sx_sasl_ret_FAIL;\n\n            /* and have no resource */\n            if(jid.resource[0] != '\\0')\n                return sx_sasl_ret_FAIL;\n\n            /* and user has right to authorize as */\n            if (sess->host->ar->user_authz_allowed) {\n                if (sess->host->ar->user_authz_allowed(sess->host->ar, sess, (char *)creds->authnid, (char *)creds->realm, (char *)creds->authzid))\n                        return sx_sasl_ret_OK;\n            } else {\n                if (strcmp(creds->authnid, jid.node) == 0 &&\n                    (sess->host->ar->user_exists)(sess->host->ar, sess, jid.node, jid.domain))\n                    return sx_sasl_ret_OK;\n            }\n\n            return sx_sasl_ret_FAIL;\n\n        case sx_sasl_cb_GEN_AUTHZID:\n            /* generate a jid for SASL ANONYMOUS */\n            jid_reset(&jid, s->req_to, -1);\n\n            /* make node a random string */\n            jid_random_part(&jid, jid_NODE);\n\n            strcpy(buf, jid.node);\n\n            *res = (void *)buf;\n\n            return sx_sasl_ret_OK;\n            break;\n\n        case sx_sasl_cb_CHECK_MECH:\n            mech = (char *)arg;\n\n            strncpy(mechbuf, mech, sizeof(mechbuf));\n            mechbuf[sizeof(mechbuf)-1]='\\0';\n            for(i = 0; mechbuf[i]; i++) mechbuf[i] = tolower(mechbuf[i]);\n\n            log_debug(ZONE, \"sx sasl callback: check mech (mech=%s)\", mechbuf);\n\n            /* get host for request */\n            host = xhash_get(c2s->hosts, s->req_to);\n            if(host == NULL) {\n                log_write(c2s->log, LOG_WARNING, \"SASL callback for non-existing host: %s\", s->req_to);\n                return sx_sasl_ret_FAIL;\n            }\n\n            /* Determine if our configuration will let us use this mechanism.\n             * We support different mechanisms for both SSL and normal use */\n            if (strcmp(mechbuf, \"digest-md5\") == 0) {\n                /* digest-md5 requires that our authreg support get_password */\n                if (host->ar->get_password == NULL)\n                    return sx_sasl_ret_FAIL;\n            } else if (strcmp(mechbuf, \"plain\") == 0) {\n                /* plain requires either get_password or check_password */\n                if (host->ar->get_password == NULL && host->ar->check_password == NULL)\n                    return sx_sasl_ret_FAIL;\n            }\n\n            /* Using SSF is potentially dangerous, as SASL can also set the\n             * SSF of the connection. However, SASL shouldn't do so until after\n             * we've finished mechanism establishment\n             */\n            if (s->ssf>0) {\n                r = snprintf(buf, sizeof(buf), \"authreg.ssl-mechanisms.sasl.%s\",mechbuf);\n                if (r < -1 || r > sizeof(buf))\n                    return sx_sasl_ret_FAIL;\n                if(config_get(c2s->config,buf) != NULL)\n                    return sx_sasl_ret_OK;\n            }\n\n            r = snprintf(buf, sizeof(buf), \"authreg.mechanisms.sasl.%s\",mechbuf);\n            if (r < -1 || r > sizeof(buf))\n                return sx_sasl_ret_FAIL;\n\n            /* Work out if our configuration will let us use this mechanism */\n            if(config_get(c2s->config,buf) != NULL)\n                return sx_sasl_ret_OK;\n            else\n                return sx_sasl_ret_FAIL;\n        default:\n            break;\n    }\n\n    return sx_sasl_ret_FAIL;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -143,6 +143,8 @@\n             mechbuf[sizeof(mechbuf)-1]='\\0';\n             for(i = 0; mechbuf[i]; i++) mechbuf[i] = tolower(mechbuf[i]);\n \n+            log_debug(ZONE, \"sx sasl callback: check mech (mech=%s)\", mechbuf);\n+\n             /* get host for request */\n             host = xhash_get(c2s->hosts, s->req_to);\n             if(host == NULL) {",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "            log_debug(ZONE, \"sx sasl callback: check mech (mech=%s)\", mechbuf);",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2017-10807",
        "func_name": "jabberd2/_sx_sasl_client_process",
        "description": "JabberD 2.x (aka jabberd2) before 2.6.1 allows anyone to authenticate using SASL ANONYMOUS, even when the sasl.anonymous c2s.xml option is not enabled.",
        "git_url": "https://github.com/jabberd2/jabberd2/commit/8416ae54ecefa670534f27a31db71d048b9c7f16",
        "commit_title": "Fixed offered SASL mechanism check",
        "commit_text": "",
        "func_before": "static void _sx_sasl_client_process(sx_t s, sx_plugin_t p, Gsasl_session *sd, const char *mech, const char *in, int inlen) {\n    _sx_sasl_t ctx = (_sx_sasl_t) p->private;\n    _sx_sasl_sess_t sctx = NULL;\n    char *buf = NULL, *out = NULL, *realm = NULL, **ext_id;\n    char hostname[256];\n    int ret;\n#ifdef HAVE_SSL\n    int i;\n#endif\n    size_t buflen, outlen;\n\n    assert(ctx);\n    assert(ctx->cb);\n\n    if(mech != NULL) {\n        _sx_debug(ZONE, \"auth request from client (mechanism=%s)\", mech);\n\n        if(!gsasl_server_support_p(ctx->gsasl_ctx, mech)) {\n             _sx_debug(ZONE, \"client requested mechanism (%s) that we didn't offer\", mech);\n             _sx_nad_write(s, _sx_sasl_failure(s, _sasl_err_INVALID_MECHANISM, NULL), 0);\n             return;\n        }\n\n        /* startup */\n        ret = gsasl_server_start(ctx->gsasl_ctx, mech, &sd);\n        if(ret != GSASL_OK) {\n            _sx_debug(ZONE, \"gsasl_server_start failed, no sasl for this conn; (%d): %s\", ret, gsasl_strerror(ret));\n            _sx_nad_write(s, _sx_sasl_failure(s, _sasl_err_TEMPORARY_FAILURE, gsasl_strerror(ret)), 0);\n            return;\n        }\n\n        /* get the realm */\n        (ctx->cb)(sx_sasl_cb_GET_REALM, NULL, (void **) &realm, s, ctx->cbarg);\n\n        /* cleanup any existing session context */\n        sctx = gsasl_session_hook_get(sd);\n        if (sctx != NULL) free(sctx);\n\n        /* allocate and initialize our per session context */\n        sctx = (_sx_sasl_sess_t) calloc(1, sizeof(struct _sx_sasl_sess_st));\n        sctx->s = s;\n        sctx->ctx = ctx;\n        gsasl_session_hook_set(sd, (void *) sctx);\n        gsasl_property_set(sd, GSASL_SERVICE, ctx->appname);\n        gsasl_property_set(sd, GSASL_REALM, realm);\n\n        /* get hostname */\n        hostname[0] = '\\0';\n        gethostname(hostname, 256);\n        hostname[255] = '\\0';\n        gsasl_property_set(sd, GSASL_HOSTNAME, hostname);\n\n        /* get EXTERNAL data from the ssl plugin */\n        ext_id = NULL;\n#ifdef HAVE_SSL\n        for(i = 0; i < s->env->nplugins; i++)\n            if(s->env->plugins[i]->magic == SX_SSL_MAGIC && s->plugin_data[s->env->plugins[i]->index] != NULL)\n                ext_id = ((_sx_ssl_conn_t) s->plugin_data[s->env->plugins[i]->index])->external_id;\n        if (ext_id != NULL) {\n            //_sx_debug(ZONE, \"sasl context ext id '%s'\", ext_id);\n            /* if there is, store it for later */\n            for (i = 0; i < SX_CONN_EXTERNAL_ID_MAX_COUNT; i++)\n                if (ext_id[i] != NULL) {\n                    ctx->ext_id[i] = strdup(ext_id[i]);\n                } else {\n                    ctx->ext_id[i] = NULL;\n                    break;\n                }\n        }\n#endif\n\n        _sx_debug(ZONE, \"sasl context initialised for %d\", s->tag);\n\n        s->plugin_data[p->index] = (void *) sd;\n\n        if(strcmp(mech, \"ANONYMOUS\") == 0) {\n            /*\n             * special case for SASL ANONYMOUS: ignore the initial\n             * response provided by the client and generate a random\n             * authid to use as the jid node for the user, as\n             * specified in XEP-0175\n             */\n            (ctx->cb)(sx_sasl_cb_GEN_AUTHZID, NULL, (void **)&out, s, ctx->cbarg);\n            buf = strdup(out);\n            buflen = strlen(buf);\n        } else if (strstr(in, \"<\") != NULL && strncmp(in, \"=\", strstr(in, \"<\") - in ) == 0) {\n            /* XXX The above check is hackish, but `in` is just weird */\n            /* This is a special case for SASL External c2s. See XEP-0178 */\n            _sx_debug(ZONE, \"gsasl auth string is empty\");\n            buf = strdup(\"\");\n            buflen = strlen(buf);\n        } else {\n            /* decode and process */\n            ret = gsasl_base64_from(in, inlen, &buf, &buflen);\n            if (ret != GSASL_OK) {\n                _sx_debug(ZONE, \"gsasl_base64_from failed, no sasl for this conn; (%d): %s\", ret, gsasl_strerror(ret));\n                _sx_nad_write(s, _sx_sasl_failure(s, _sasl_err_INCORRECT_ENCODING, gsasl_strerror(ret)), 0);\n                if(buf != NULL) free(buf);\n                return;\n            }\n        }\n\n        ret = gsasl_step(sd, buf, buflen, &out, &outlen);\n    }\n\n    else {\n        /* decode and process */\n        ret = gsasl_base64_from(in, inlen, &buf, &buflen);\n        if (ret != GSASL_OK) {\n            _sx_debug(ZONE, \"gsasl_base64_from failed, no sasl for this conn; (%d): %s\", ret, gsasl_strerror(ret));\n            _sx_nad_write(s, _sx_sasl_failure(s, _sasl_err_INCORRECT_ENCODING, gsasl_strerror(ret)), 0);\n            return;\n        }\n\n        if(!sd) {\n            _sx_debug(ZONE, \"response send before auth request enabling mechanism (decoded: %.*s)\", buflen, buf);\n            _sx_nad_write(s, _sx_sasl_failure(s, _sasl_err_MECH_TOO_WEAK, \"response send before auth request enabling mechanism\"), 0);\n            if(buf != NULL) free(buf);\n            return;\n        }\n        _sx_debug(ZONE, \"response from client (decoded: %.*s)\", buflen, buf);\n        ret = gsasl_step(sd, buf, buflen, &out, &outlen);\n    }\n\n    if(buf != NULL) free(buf);\n\n    /* auth completed */\n    if(ret == GSASL_OK) {\n        _sx_debug(ZONE, \"sasl handshake completed\");\n\n        /* encode the leftover response */\n        ret = gsasl_base64_to(out, outlen, &buf, &buflen);\n        if (ret == GSASL_OK) {\n            /* send success */\n            _sx_nad_write(s, _sx_sasl_success(s, buf, buflen), 0);\n            free(buf);\n\n            /* set a notify on the success nad buffer */\n            ((sx_buf_t) s->wbufq->front->data)->notify = _sx_sasl_notify_success;\n            ((sx_buf_t) s->wbufq->front->data)->notify_arg = (void *) p;\n        }\n        else {\n            _sx_debug(ZONE, \"gsasl_base64_to failed, no sasl for this conn; (%d): %s\", ret, gsasl_strerror(ret));\n            _sx_nad_write(s, _sx_sasl_failure(s, _sasl_err_INCORRECT_ENCODING, gsasl_strerror(ret)), 0);\n            if(buf != NULL) free(buf);\n        }\n\n        if(out != NULL) free(out);\n\n        return;\n    }\n\n    /* in progress */\n    if(ret == GSASL_NEEDS_MORE) {\n        _sx_debug(ZONE, \"sasl handshake in progress (challenge: %.*s)\", outlen, out);\n\n        /* encode the challenge */\n        ret = gsasl_base64_to(out, outlen, &buf, &buflen);\n        if (ret == GSASL_OK) {\n            _sx_nad_write(s, _sx_sasl_challenge(s, buf, buflen), 0);\n            free(buf);\n        }\n        else {\n            _sx_debug(ZONE, \"gsasl_base64_to failed, no sasl for this conn; (%d): %s\", ret, gsasl_strerror(ret));\n            _sx_nad_write(s, _sx_sasl_failure(s, _sasl_err_INCORRECT_ENCODING, gsasl_strerror(ret)), 0);\n            if(buf != NULL) free(buf);\n        }\n\n        if(out != NULL) free(out);\n\n        return;\n    }\n\n    if(out != NULL) free(out);\n\n    /* its over */\n    _sx_debug(ZONE, \"sasl handshake failed; (%d): %s\", ret, gsasl_strerror(ret));\n\n    switch (ret) {\n        case GSASL_AUTHENTICATION_ERROR:\n\tcase GSASL_NO_ANONYMOUS_TOKEN:\n\tcase GSASL_NO_AUTHID:\n\tcase GSASL_NO_AUTHZID:\n\tcase GSASL_NO_PASSWORD:\n\tcase GSASL_NO_PASSCODE:\n\tcase GSASL_NO_PIN:\n\tcase GSASL_NO_SERVICE:\n\tcase GSASL_NO_HOSTNAME:\n            out = _sasl_err_NOT_AUTHORIZED;\n            break;\n\tcase GSASL_UNKNOWN_MECHANISM:\n\tcase GSASL_MECHANISM_PARSE_ERROR:\n            out = _sasl_err_INVALID_MECHANISM;\n            break;\n\tcase GSASL_BASE64_ERROR:\n            out = _sasl_err_INCORRECT_ENCODING;\n            break;\n        default:\n            out = _sasl_err_MALFORMED_REQUEST;\n    }\n    _sx_nad_write(s, _sx_sasl_failure(s, out, gsasl_strerror(ret)), 0);\n}",
        "func": "static void _sx_sasl_client_process(sx_t s, sx_plugin_t p, Gsasl_session *sd, const char *mech, const char *in, int inlen) {\n    _sx_sasl_t ctx = (_sx_sasl_t) p->private;\n    _sx_sasl_sess_t sctx = NULL;\n    char *buf = NULL, *out = NULL, *realm = NULL, **ext_id;\n    char hostname[256];\n    int ret;\n#ifdef HAVE_SSL\n    int i;\n#endif\n    size_t buflen, outlen;\n\n    assert(ctx);\n    assert(ctx->cb);\n\n    if(mech != NULL) {\n        _sx_debug(ZONE, \"auth request from client (mechanism=%s)\", mech);\n\n        if(!gsasl_server_support_p(ctx->gsasl_ctx, mech) || (ctx->cb)(sx_sasl_cb_CHECK_MECH, (void*)mech, NULL, s, ctx->cbarg) != sx_sasl_ret_OK) {\n             _sx_debug(ZONE, \"client requested mechanism (%s) that we didn't offer\", mech);\n             _sx_nad_write(s, _sx_sasl_failure(s, _sasl_err_INVALID_MECHANISM, NULL), 0);\n             return;\n        }\n\n        /* startup */\n        ret = gsasl_server_start(ctx->gsasl_ctx, mech, &sd);\n        if(ret != GSASL_OK) {\n            _sx_debug(ZONE, \"gsasl_server_start failed, no sasl for this conn; (%d): %s\", ret, gsasl_strerror(ret));\n            _sx_nad_write(s, _sx_sasl_failure(s, _sasl_err_TEMPORARY_FAILURE, gsasl_strerror(ret)), 0);\n            return;\n        }\n\n        /* get the realm */\n        (ctx->cb)(sx_sasl_cb_GET_REALM, NULL, (void **) &realm, s, ctx->cbarg);\n\n        /* cleanup any existing session context */\n        sctx = gsasl_session_hook_get(sd);\n        if (sctx != NULL) free(sctx);\n\n        /* allocate and initialize our per session context */\n        sctx = (_sx_sasl_sess_t) calloc(1, sizeof(struct _sx_sasl_sess_st));\n        sctx->s = s;\n        sctx->ctx = ctx;\n        gsasl_session_hook_set(sd, (void *) sctx);\n        gsasl_property_set(sd, GSASL_SERVICE, ctx->appname);\n        gsasl_property_set(sd, GSASL_REALM, realm);\n\n        /* get hostname */\n        hostname[0] = '\\0';\n        gethostname(hostname, 256);\n        hostname[255] = '\\0';\n        gsasl_property_set(sd, GSASL_HOSTNAME, hostname);\n\n        /* get EXTERNAL data from the ssl plugin */\n        ext_id = NULL;\n#ifdef HAVE_SSL\n        for(i = 0; i < s->env->nplugins; i++)\n            if(s->env->plugins[i]->magic == SX_SSL_MAGIC && s->plugin_data[s->env->plugins[i]->index] != NULL)\n                ext_id = ((_sx_ssl_conn_t) s->plugin_data[s->env->plugins[i]->index])->external_id;\n        if (ext_id != NULL) {\n            //_sx_debug(ZONE, \"sasl context ext id '%s'\", ext_id);\n            /* if there is, store it for later */\n            for (i = 0; i < SX_CONN_EXTERNAL_ID_MAX_COUNT; i++)\n                if (ext_id[i] != NULL) {\n                    ctx->ext_id[i] = strdup(ext_id[i]);\n                } else {\n                    ctx->ext_id[i] = NULL;\n                    break;\n                }\n        }\n#endif\n\n        _sx_debug(ZONE, \"sasl context initialised for %d\", s->tag);\n\n        s->plugin_data[p->index] = (void *) sd;\n\n        if(strcmp(mech, \"ANONYMOUS\") == 0) {\n            /*\n             * special case for SASL ANONYMOUS: ignore the initial\n             * response provided by the client and generate a random\n             * authid to use as the jid node for the user, as\n             * specified in XEP-0175\n             */\n            (ctx->cb)(sx_sasl_cb_GEN_AUTHZID, NULL, (void **)&out, s, ctx->cbarg);\n            buf = strdup(out);\n            buflen = strlen(buf);\n        } else if (strstr(in, \"<\") != NULL && strncmp(in, \"=\", strstr(in, \"<\") - in ) == 0) {\n            /* XXX The above check is hackish, but `in` is just weird */\n            /* This is a special case for SASL External c2s. See XEP-0178 */\n            _sx_debug(ZONE, \"gsasl auth string is empty\");\n            buf = strdup(\"\");\n            buflen = strlen(buf);\n        } else {\n            /* decode and process */\n            ret = gsasl_base64_from(in, inlen, &buf, &buflen);\n            if (ret != GSASL_OK) {\n                _sx_debug(ZONE, \"gsasl_base64_from failed, no sasl for this conn; (%d): %s\", ret, gsasl_strerror(ret));\n                _sx_nad_write(s, _sx_sasl_failure(s, _sasl_err_INCORRECT_ENCODING, gsasl_strerror(ret)), 0);\n                if(buf != NULL) free(buf);\n                return;\n            }\n        }\n\n        ret = gsasl_step(sd, buf, buflen, &out, &outlen);\n    }\n\n    else {\n        /* decode and process */\n        ret = gsasl_base64_from(in, inlen, &buf, &buflen);\n        if (ret != GSASL_OK) {\n            _sx_debug(ZONE, \"gsasl_base64_from failed, no sasl for this conn; (%d): %s\", ret, gsasl_strerror(ret));\n            _sx_nad_write(s, _sx_sasl_failure(s, _sasl_err_INCORRECT_ENCODING, gsasl_strerror(ret)), 0);\n            return;\n        }\n\n        if(!sd) {\n            _sx_debug(ZONE, \"response send before auth request enabling mechanism (decoded: %.*s)\", buflen, buf);\n            _sx_nad_write(s, _sx_sasl_failure(s, _sasl_err_MECH_TOO_WEAK, \"response send before auth request enabling mechanism\"), 0);\n            if(buf != NULL) free(buf);\n            return;\n        }\n        _sx_debug(ZONE, \"response from client (decoded: %.*s)\", buflen, buf);\n        ret = gsasl_step(sd, buf, buflen, &out, &outlen);\n    }\n\n    if(buf != NULL) free(buf);\n\n    /* auth completed */\n    if(ret == GSASL_OK) {\n        _sx_debug(ZONE, \"sasl handshake completed\");\n\n        /* encode the leftover response */\n        ret = gsasl_base64_to(out, outlen, &buf, &buflen);\n        if (ret == GSASL_OK) {\n            /* send success */\n            _sx_nad_write(s, _sx_sasl_success(s, buf, buflen), 0);\n            free(buf);\n\n            /* set a notify on the success nad buffer */\n            ((sx_buf_t) s->wbufq->front->data)->notify = _sx_sasl_notify_success;\n            ((sx_buf_t) s->wbufq->front->data)->notify_arg = (void *) p;\n        }\n        else {\n            _sx_debug(ZONE, \"gsasl_base64_to failed, no sasl for this conn; (%d): %s\", ret, gsasl_strerror(ret));\n            _sx_nad_write(s, _sx_sasl_failure(s, _sasl_err_INCORRECT_ENCODING, gsasl_strerror(ret)), 0);\n            if(buf != NULL) free(buf);\n        }\n\n        if(out != NULL) free(out);\n\n        return;\n    }\n\n    /* in progress */\n    if(ret == GSASL_NEEDS_MORE) {\n        _sx_debug(ZONE, \"sasl handshake in progress (challenge: %.*s)\", outlen, out);\n\n        /* encode the challenge */\n        ret = gsasl_base64_to(out, outlen, &buf, &buflen);\n        if (ret == GSASL_OK) {\n            _sx_nad_write(s, _sx_sasl_challenge(s, buf, buflen), 0);\n            free(buf);\n        }\n        else {\n            _sx_debug(ZONE, \"gsasl_base64_to failed, no sasl for this conn; (%d): %s\", ret, gsasl_strerror(ret));\n            _sx_nad_write(s, _sx_sasl_failure(s, _sasl_err_INCORRECT_ENCODING, gsasl_strerror(ret)), 0);\n            if(buf != NULL) free(buf);\n        }\n\n        if(out != NULL) free(out);\n\n        return;\n    }\n\n    if(out != NULL) free(out);\n\n    /* its over */\n    _sx_debug(ZONE, \"sasl handshake failed; (%d): %s\", ret, gsasl_strerror(ret));\n\n    switch (ret) {\n        case GSASL_AUTHENTICATION_ERROR:\n\tcase GSASL_NO_ANONYMOUS_TOKEN:\n\tcase GSASL_NO_AUTHID:\n\tcase GSASL_NO_AUTHZID:\n\tcase GSASL_NO_PASSWORD:\n\tcase GSASL_NO_PASSCODE:\n\tcase GSASL_NO_PIN:\n\tcase GSASL_NO_SERVICE:\n\tcase GSASL_NO_HOSTNAME:\n            out = _sasl_err_NOT_AUTHORIZED;\n            break;\n\tcase GSASL_UNKNOWN_MECHANISM:\n\tcase GSASL_MECHANISM_PARSE_ERROR:\n            out = _sasl_err_INVALID_MECHANISM;\n            break;\n\tcase GSASL_BASE64_ERROR:\n            out = _sasl_err_INCORRECT_ENCODING;\n            break;\n        default:\n            out = _sasl_err_MALFORMED_REQUEST;\n    }\n    _sx_nad_write(s, _sx_sasl_failure(s, out, gsasl_strerror(ret)), 0);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -15,7 +15,7 @@\n     if(mech != NULL) {\n         _sx_debug(ZONE, \"auth request from client (mechanism=%s)\", mech);\n \n-        if(!gsasl_server_support_p(ctx->gsasl_ctx, mech)) {\n+        if(!gsasl_server_support_p(ctx->gsasl_ctx, mech) || (ctx->cb)(sx_sasl_cb_CHECK_MECH, (void*)mech, NULL, s, ctx->cbarg) != sx_sasl_ret_OK) {\n              _sx_debug(ZONE, \"client requested mechanism (%s) that we didn't offer\", mech);\n              _sx_nad_write(s, _sx_sasl_failure(s, _sasl_err_INVALID_MECHANISM, NULL), 0);\n              return;",
        "diff_line_info": {
            "deleted_lines": [
                "        if(!gsasl_server_support_p(ctx->gsasl_ctx, mech)) {"
            ],
            "added_lines": [
                "        if(!gsasl_server_support_p(ctx->gsasl_ctx, mech) || (ctx->cb)(sx_sasl_cb_CHECK_MECH, (void*)mech, NULL, s, ctx->cbarg) != sx_sasl_ret_OK) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-5108",
        "func_name": "torvalds/linux/ieee80211_add_station",
        "description": "An exploitable denial-of-service vulnerability exists in the Linux kernel prior to mainline 5.3. An attacker could exploit this vulnerability by triggering AP to send IAPP location updates for stations before the required authentication process has completed. This could lead to different denial-of-service scenarios, either by causing CAM table attacks, or by leading to traffic flapping if faking already existing clients in other nearby APs of the same wireless infrastructure. An attacker can forge Authentication and Association Request packets to trigger this vulnerability.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=3e493173b7841259a08c5c8e5cbe90adb349da7e",
        "commit_title": "The Layer 2 Update frame is used to update bridges when a station roams",
        "commit_text": "to another AP even if that STA does not transmit any frames after the reassociation. This behavior was described in IEEE Std 802.11F-2003 as something that would happen based on MLME-ASSOCIATE.indication, i.e., before completing 4-way handshake. However, this IEEE trial-use recommended practice document was published before RSN (IEEE Std 802.11i-2004) and as such, did not consider RSN use cases. Furthermore, IEEE Std 802.11F-2003 was withdrawn in 2006 and as such, has not been maintained amd should not be used anymore.  Sending out the Layer 2 Update frame immediately after association is fine for open networks (and also when using SAE, FT protocol, or FILS authentication when the station is actually authenticated by the time association completes). However, it is not appropriate for cases where RSN is used with PSK or EAP authentication since the station is actually fully authenticated only once the 4-way handshake completes after authentication and attackers might be able to use the unauthenticated triggering of Layer 2 Update frame transmission to disrupt bridge behavior.  Fix this by postponing transmission of the Layer 2 Update frame from station entry addition to the point when the station entry is marked authorized. Similarly, send out the VLAN binding update only if the STA entry has already been authorized.  ",
        "func_before": "static int ieee80211_add_station(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t\t const u8 *mac,\n\t\t\t\t struct station_parameters *params)\n{\n\tstruct ieee80211_local *local = wiphy_priv(wiphy);\n\tstruct sta_info *sta;\n\tstruct ieee80211_sub_if_data *sdata;\n\tint err;\n\tint layer2_update;\n\n\tif (params->vlan) {\n\t\tsdata = IEEE80211_DEV_TO_SUB_IF(params->vlan);\n\n\t\tif (sdata->vif.type != NL80211_IFTYPE_AP_VLAN &&\n\t\t    sdata->vif.type != NL80211_IFTYPE_AP)\n\t\t\treturn -EINVAL;\n\t} else\n\t\tsdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\n\tif (ether_addr_equal(mac, sdata->vif.addr))\n\t\treturn -EINVAL;\n\n\tif (is_multicast_ether_addr(mac))\n\t\treturn -EINVAL;\n\n\tif (params->sta_flags_set & BIT(NL80211_STA_FLAG_TDLS_PEER) &&\n\t    sdata->vif.type == NL80211_IFTYPE_STATION &&\n\t    !sdata->u.mgd.associated)\n\t\treturn -EINVAL;\n\n\tsta = sta_info_alloc(sdata, mac, GFP_KERNEL);\n\tif (!sta)\n\t\treturn -ENOMEM;\n\n\tif (params->sta_flags_set & BIT(NL80211_STA_FLAG_TDLS_PEER))\n\t\tsta->sta.tdls = true;\n\n\terr = sta_apply_parameters(local, sta, params);\n\tif (err) {\n\t\tsta_info_free(local, sta);\n\t\treturn err;\n\t}\n\n\t/*\n\t * for TDLS and for unassociated station, rate control should be\n\t * initialized only when rates are known and station is marked\n\t * authorized/associated\n\t */\n\tif (!test_sta_flag(sta, WLAN_STA_TDLS_PEER) &&\n\t    test_sta_flag(sta, WLAN_STA_ASSOC))\n\t\trate_control_rate_init(sta);\n\n\tlayer2_update = sdata->vif.type == NL80211_IFTYPE_AP_VLAN ||\n\t\tsdata->vif.type == NL80211_IFTYPE_AP;\n\n\terr = sta_info_insert_rcu(sta);\n\tif (err) {\n\t\trcu_read_unlock();\n\t\treturn err;\n\t}\n\n\tif (layer2_update)\n\t\tcfg80211_send_layer2_update(sta->sdata->dev, sta->sta.addr);\n\n\trcu_read_unlock();\n\n\treturn 0;\n}",
        "func": "static int ieee80211_add_station(struct wiphy *wiphy, struct net_device *dev,\n\t\t\t\t const u8 *mac,\n\t\t\t\t struct station_parameters *params)\n{\n\tstruct ieee80211_local *local = wiphy_priv(wiphy);\n\tstruct sta_info *sta;\n\tstruct ieee80211_sub_if_data *sdata;\n\tint err;\n\n\tif (params->vlan) {\n\t\tsdata = IEEE80211_DEV_TO_SUB_IF(params->vlan);\n\n\t\tif (sdata->vif.type != NL80211_IFTYPE_AP_VLAN &&\n\t\t    sdata->vif.type != NL80211_IFTYPE_AP)\n\t\t\treturn -EINVAL;\n\t} else\n\t\tsdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\n\tif (ether_addr_equal(mac, sdata->vif.addr))\n\t\treturn -EINVAL;\n\n\tif (is_multicast_ether_addr(mac))\n\t\treturn -EINVAL;\n\n\tif (params->sta_flags_set & BIT(NL80211_STA_FLAG_TDLS_PEER) &&\n\t    sdata->vif.type == NL80211_IFTYPE_STATION &&\n\t    !sdata->u.mgd.associated)\n\t\treturn -EINVAL;\n\n\tsta = sta_info_alloc(sdata, mac, GFP_KERNEL);\n\tif (!sta)\n\t\treturn -ENOMEM;\n\n\tif (params->sta_flags_set & BIT(NL80211_STA_FLAG_TDLS_PEER))\n\t\tsta->sta.tdls = true;\n\n\terr = sta_apply_parameters(local, sta, params);\n\tif (err) {\n\t\tsta_info_free(local, sta);\n\t\treturn err;\n\t}\n\n\t/*\n\t * for TDLS and for unassociated station, rate control should be\n\t * initialized only when rates are known and station is marked\n\t * authorized/associated\n\t */\n\tif (!test_sta_flag(sta, WLAN_STA_TDLS_PEER) &&\n\t    test_sta_flag(sta, WLAN_STA_ASSOC))\n\t\trate_control_rate_init(sta);\n\n\terr = sta_info_insert_rcu(sta);\n\tif (err) {\n\t\trcu_read_unlock();\n\t\treturn err;\n\t}\n\n\trcu_read_unlock();\n\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,7 +6,6 @@\n \tstruct sta_info *sta;\n \tstruct ieee80211_sub_if_data *sdata;\n \tint err;\n-\tint layer2_update;\n \n \tif (params->vlan) {\n \t\tsdata = IEEE80211_DEV_TO_SUB_IF(params->vlan);\n@@ -50,18 +49,12 @@\n \t    test_sta_flag(sta, WLAN_STA_ASSOC))\n \t\trate_control_rate_init(sta);\n \n-\tlayer2_update = sdata->vif.type == NL80211_IFTYPE_AP_VLAN ||\n-\t\tsdata->vif.type == NL80211_IFTYPE_AP;\n-\n \terr = sta_info_insert_rcu(sta);\n \tif (err) {\n \t\trcu_read_unlock();\n \t\treturn err;\n \t}\n \n-\tif (layer2_update)\n-\t\tcfg80211_send_layer2_update(sta->sdata->dev, sta->sta.addr);\n-\n \trcu_read_unlock();\n \n \treturn 0;",
        "diff_line_info": {
            "deleted_lines": [
                "\tint layer2_update;",
                "\tlayer2_update = sdata->vif.type == NL80211_IFTYPE_AP_VLAN ||",
                "\t\tsdata->vif.type == NL80211_IFTYPE_AP;",
                "",
                "\tif (layer2_update)",
                "\t\tcfg80211_send_layer2_update(sta->sdata->dev, sta->sta.addr);",
                ""
            ],
            "added_lines": []
        }
    },
    {
        "cve_id": "CVE-2019-5108",
        "func_name": "torvalds/linux/ieee80211_change_station",
        "description": "An exploitable denial-of-service vulnerability exists in the Linux kernel prior to mainline 5.3. An attacker could exploit this vulnerability by triggering AP to send IAPP location updates for stations before the required authentication process has completed. This could lead to different denial-of-service scenarios, either by causing CAM table attacks, or by leading to traffic flapping if faking already existing clients in other nearby APs of the same wireless infrastructure. An attacker can forge Authentication and Association Request packets to trigger this vulnerability.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=3e493173b7841259a08c5c8e5cbe90adb349da7e",
        "commit_title": "The Layer 2 Update frame is used to update bridges when a station roams",
        "commit_text": "to another AP even if that STA does not transmit any frames after the reassociation. This behavior was described in IEEE Std 802.11F-2003 as something that would happen based on MLME-ASSOCIATE.indication, i.e., before completing 4-way handshake. However, this IEEE trial-use recommended practice document was published before RSN (IEEE Std 802.11i-2004) and as such, did not consider RSN use cases. Furthermore, IEEE Std 802.11F-2003 was withdrawn in 2006 and as such, has not been maintained amd should not be used anymore.  Sending out the Layer 2 Update frame immediately after association is fine for open networks (and also when using SAE, FT protocol, or FILS authentication when the station is actually authenticated by the time association completes). However, it is not appropriate for cases where RSN is used with PSK or EAP authentication since the station is actually fully authenticated only once the 4-way handshake completes after authentication and attackers might be able to use the unauthenticated triggering of Layer 2 Update frame transmission to disrupt bridge behavior.  Fix this by postponing transmission of the Layer 2 Update frame from station entry addition to the point when the station entry is marked authorized. Similarly, send out the VLAN binding update only if the STA entry has already been authorized.  ",
        "func_before": "static int ieee80211_change_station(struct wiphy *wiphy,\n\t\t\t\t    struct net_device *dev, const u8 *mac,\n\t\t\t\t    struct station_parameters *params)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\tstruct ieee80211_local *local = wiphy_priv(wiphy);\n\tstruct sta_info *sta;\n\tstruct ieee80211_sub_if_data *vlansdata;\n\tenum cfg80211_station_type statype;\n\tint err;\n\n\tmutex_lock(&local->sta_mtx);\n\n\tsta = sta_info_get_bss(sdata, mac);\n\tif (!sta) {\n\t\terr = -ENOENT;\n\t\tgoto out_err;\n\t}\n\n\tswitch (sdata->vif.type) {\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\tif (sdata->u.mesh.user_mpm)\n\t\t\tstatype = CFG80211_STA_MESH_PEER_USER;\n\t\telse\n\t\t\tstatype = CFG80211_STA_MESH_PEER_KERNEL;\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\t\tstatype = CFG80211_STA_IBSS;\n\t\tbreak;\n\tcase NL80211_IFTYPE_STATION:\n\t\tif (!test_sta_flag(sta, WLAN_STA_TDLS_PEER)) {\n\t\t\tstatype = CFG80211_STA_AP_STA;\n\t\t\tbreak;\n\t\t}\n\t\tif (test_sta_flag(sta, WLAN_STA_AUTHORIZED))\n\t\t\tstatype = CFG80211_STA_TDLS_PEER_ACTIVE;\n\t\telse\n\t\t\tstatype = CFG80211_STA_TDLS_PEER_SETUP;\n\t\tbreak;\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_AP_VLAN:\n\t\tif (test_sta_flag(sta, WLAN_STA_ASSOC))\n\t\t\tstatype = CFG80211_STA_AP_CLIENT;\n\t\telse\n\t\t\tstatype = CFG80211_STA_AP_CLIENT_UNASSOC;\n\t\tbreak;\n\tdefault:\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out_err;\n\t}\n\n\terr = cfg80211_check_station_change(wiphy, params, statype);\n\tif (err)\n\t\tgoto out_err;\n\n\tif (params->vlan && params->vlan != sta->sdata->dev) {\n\t\tvlansdata = IEEE80211_DEV_TO_SUB_IF(params->vlan);\n\n\t\tif (params->vlan->ieee80211_ptr->use_4addr) {\n\t\t\tif (vlansdata->u.vlan.sta) {\n\t\t\t\terr = -EBUSY;\n\t\t\t\tgoto out_err;\n\t\t\t}\n\n\t\t\trcu_assign_pointer(vlansdata->u.vlan.sta, sta);\n\t\t\t__ieee80211_check_fast_rx_iface(vlansdata);\n\t\t}\n\n\t\tif (sta->sdata->vif.type == NL80211_IFTYPE_AP_VLAN &&\n\t\t    sta->sdata->u.vlan.sta)\n\t\t\tRCU_INIT_POINTER(sta->sdata->u.vlan.sta, NULL);\n\n\t\tif (test_sta_flag(sta, WLAN_STA_AUTHORIZED))\n\t\t\tieee80211_vif_dec_num_mcast(sta->sdata);\n\n\t\tsta->sdata = vlansdata;\n\t\tieee80211_check_fast_xmit(sta);\n\n\t\tif (test_sta_flag(sta, WLAN_STA_AUTHORIZED))\n\t\t\tieee80211_vif_inc_num_mcast(sta->sdata);\n\n\t\tcfg80211_send_layer2_update(sta->sdata->dev, sta->sta.addr);\n\t}\n\n\terr = sta_apply_parameters(local, sta, params);\n\tif (err)\n\t\tgoto out_err;\n\n\tmutex_unlock(&local->sta_mtx);\n\n\tif ((sdata->vif.type == NL80211_IFTYPE_AP ||\n\t     sdata->vif.type == NL80211_IFTYPE_AP_VLAN) &&\n\t    sta->known_smps_mode != sta->sdata->bss->req_smps &&\n\t    test_sta_flag(sta, WLAN_STA_AUTHORIZED) &&\n\t    sta_info_tx_streams(sta) != 1) {\n\t\tht_dbg(sta->sdata,\n\t\t       \"%pM just authorized and MIMO capable - update SMPS\\n\",\n\t\t       sta->sta.addr);\n\t\tieee80211_send_smps_action(sta->sdata,\n\t\t\tsta->sdata->bss->req_smps,\n\t\t\tsta->sta.addr,\n\t\t\tsta->sdata->vif.bss_conf.bssid);\n\t}\n\n\tif (sdata->vif.type == NL80211_IFTYPE_STATION &&\n\t    params->sta_flags_mask & BIT(NL80211_STA_FLAG_AUTHORIZED)) {\n\t\tieee80211_recalc_ps(local);\n\t\tieee80211_recalc_ps_vif(sdata);\n\t}\n\n\treturn 0;\nout_err:\n\tmutex_unlock(&local->sta_mtx);\n\treturn err;\n}",
        "func": "static int ieee80211_change_station(struct wiphy *wiphy,\n\t\t\t\t    struct net_device *dev, const u8 *mac,\n\t\t\t\t    struct station_parameters *params)\n{\n\tstruct ieee80211_sub_if_data *sdata = IEEE80211_DEV_TO_SUB_IF(dev);\n\tstruct ieee80211_local *local = wiphy_priv(wiphy);\n\tstruct sta_info *sta;\n\tstruct ieee80211_sub_if_data *vlansdata;\n\tenum cfg80211_station_type statype;\n\tint err;\n\n\tmutex_lock(&local->sta_mtx);\n\n\tsta = sta_info_get_bss(sdata, mac);\n\tif (!sta) {\n\t\terr = -ENOENT;\n\t\tgoto out_err;\n\t}\n\n\tswitch (sdata->vif.type) {\n\tcase NL80211_IFTYPE_MESH_POINT:\n\t\tif (sdata->u.mesh.user_mpm)\n\t\t\tstatype = CFG80211_STA_MESH_PEER_USER;\n\t\telse\n\t\t\tstatype = CFG80211_STA_MESH_PEER_KERNEL;\n\t\tbreak;\n\tcase NL80211_IFTYPE_ADHOC:\n\t\tstatype = CFG80211_STA_IBSS;\n\t\tbreak;\n\tcase NL80211_IFTYPE_STATION:\n\t\tif (!test_sta_flag(sta, WLAN_STA_TDLS_PEER)) {\n\t\t\tstatype = CFG80211_STA_AP_STA;\n\t\t\tbreak;\n\t\t}\n\t\tif (test_sta_flag(sta, WLAN_STA_AUTHORIZED))\n\t\t\tstatype = CFG80211_STA_TDLS_PEER_ACTIVE;\n\t\telse\n\t\t\tstatype = CFG80211_STA_TDLS_PEER_SETUP;\n\t\tbreak;\n\tcase NL80211_IFTYPE_AP:\n\tcase NL80211_IFTYPE_AP_VLAN:\n\t\tif (test_sta_flag(sta, WLAN_STA_ASSOC))\n\t\t\tstatype = CFG80211_STA_AP_CLIENT;\n\t\telse\n\t\t\tstatype = CFG80211_STA_AP_CLIENT_UNASSOC;\n\t\tbreak;\n\tdefault:\n\t\terr = -EOPNOTSUPP;\n\t\tgoto out_err;\n\t}\n\n\terr = cfg80211_check_station_change(wiphy, params, statype);\n\tif (err)\n\t\tgoto out_err;\n\n\tif (params->vlan && params->vlan != sta->sdata->dev) {\n\t\tvlansdata = IEEE80211_DEV_TO_SUB_IF(params->vlan);\n\n\t\tif (params->vlan->ieee80211_ptr->use_4addr) {\n\t\t\tif (vlansdata->u.vlan.sta) {\n\t\t\t\terr = -EBUSY;\n\t\t\t\tgoto out_err;\n\t\t\t}\n\n\t\t\trcu_assign_pointer(vlansdata->u.vlan.sta, sta);\n\t\t\t__ieee80211_check_fast_rx_iface(vlansdata);\n\t\t}\n\n\t\tif (sta->sdata->vif.type == NL80211_IFTYPE_AP_VLAN &&\n\t\t    sta->sdata->u.vlan.sta)\n\t\t\tRCU_INIT_POINTER(sta->sdata->u.vlan.sta, NULL);\n\n\t\tif (test_sta_flag(sta, WLAN_STA_AUTHORIZED))\n\t\t\tieee80211_vif_dec_num_mcast(sta->sdata);\n\n\t\tsta->sdata = vlansdata;\n\t\tieee80211_check_fast_xmit(sta);\n\n\t\tif (test_sta_flag(sta, WLAN_STA_AUTHORIZED)) {\n\t\t\tieee80211_vif_inc_num_mcast(sta->sdata);\n\t\t\tcfg80211_send_layer2_update(sta->sdata->dev,\n\t\t\t\t\t\t    sta->sta.addr);\n\t\t}\n\t}\n\n\terr = sta_apply_parameters(local, sta, params);\n\tif (err)\n\t\tgoto out_err;\n\n\tmutex_unlock(&local->sta_mtx);\n\n\tif ((sdata->vif.type == NL80211_IFTYPE_AP ||\n\t     sdata->vif.type == NL80211_IFTYPE_AP_VLAN) &&\n\t    sta->known_smps_mode != sta->sdata->bss->req_smps &&\n\t    test_sta_flag(sta, WLAN_STA_AUTHORIZED) &&\n\t    sta_info_tx_streams(sta) != 1) {\n\t\tht_dbg(sta->sdata,\n\t\t       \"%pM just authorized and MIMO capable - update SMPS\\n\",\n\t\t       sta->sta.addr);\n\t\tieee80211_send_smps_action(sta->sdata,\n\t\t\tsta->sdata->bss->req_smps,\n\t\t\tsta->sta.addr,\n\t\t\tsta->sdata->vif.bss_conf.bssid);\n\t}\n\n\tif (sdata->vif.type == NL80211_IFTYPE_STATION &&\n\t    params->sta_flags_mask & BIT(NL80211_STA_FLAG_AUTHORIZED)) {\n\t\tieee80211_recalc_ps(local);\n\t\tieee80211_recalc_ps_vif(sdata);\n\t}\n\n\treturn 0;\nout_err:\n\tmutex_unlock(&local->sta_mtx);\n\treturn err;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -76,10 +76,11 @@\n \t\tsta->sdata = vlansdata;\n \t\tieee80211_check_fast_xmit(sta);\n \n-\t\tif (test_sta_flag(sta, WLAN_STA_AUTHORIZED))\n+\t\tif (test_sta_flag(sta, WLAN_STA_AUTHORIZED)) {\n \t\t\tieee80211_vif_inc_num_mcast(sta->sdata);\n-\n-\t\tcfg80211_send_layer2_update(sta->sdata->dev, sta->sta.addr);\n+\t\t\tcfg80211_send_layer2_update(sta->sdata->dev,\n+\t\t\t\t\t\t    sta->sta.addr);\n+\t\t}\n \t}\n \n \terr = sta_apply_parameters(local, sta, params);",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tif (test_sta_flag(sta, WLAN_STA_AUTHORIZED))",
                "",
                "\t\tcfg80211_send_layer2_update(sta->sdata->dev, sta->sta.addr);"
            ],
            "added_lines": [
                "\t\tif (test_sta_flag(sta, WLAN_STA_AUTHORIZED)) {",
                "\t\t\tcfg80211_send_layer2_update(sta->sdata->dev,",
                "\t\t\t\t\t\t    sta->sta.addr);",
                "\t\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-5108",
        "func_name": "torvalds/linux/sta_info_move_state",
        "description": "An exploitable denial-of-service vulnerability exists in the Linux kernel prior to mainline 5.3. An attacker could exploit this vulnerability by triggering AP to send IAPP location updates for stations before the required authentication process has completed. This could lead to different denial-of-service scenarios, either by causing CAM table attacks, or by leading to traffic flapping if faking already existing clients in other nearby APs of the same wireless infrastructure. An attacker can forge Authentication and Association Request packets to trigger this vulnerability.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=3e493173b7841259a08c5c8e5cbe90adb349da7e",
        "commit_title": "The Layer 2 Update frame is used to update bridges when a station roams",
        "commit_text": "to another AP even if that STA does not transmit any frames after the reassociation. This behavior was described in IEEE Std 802.11F-2003 as something that would happen based on MLME-ASSOCIATE.indication, i.e., before completing 4-way handshake. However, this IEEE trial-use recommended practice document was published before RSN (IEEE Std 802.11i-2004) and as such, did not consider RSN use cases. Furthermore, IEEE Std 802.11F-2003 was withdrawn in 2006 and as such, has not been maintained amd should not be used anymore.  Sending out the Layer 2 Update frame immediately after association is fine for open networks (and also when using SAE, FT protocol, or FILS authentication when the station is actually authenticated by the time association completes). However, it is not appropriate for cases where RSN is used with PSK or EAP authentication since the station is actually fully authenticated only once the 4-way handshake completes after authentication and attackers might be able to use the unauthenticated triggering of Layer 2 Update frame transmission to disrupt bridge behavior.  Fix this by postponing transmission of the Layer 2 Update frame from station entry addition to the point when the station entry is marked authorized. Similarly, send out the VLAN binding update only if the STA entry has already been authorized.  ",
        "func_before": "int sta_info_move_state(struct sta_info *sta,\n\t\t\tenum ieee80211_sta_state new_state)\n{\n\tmight_sleep();\n\n\tif (sta->sta_state == new_state)\n\t\treturn 0;\n\n\t/* check allowed transitions first */\n\n\tswitch (new_state) {\n\tcase IEEE80211_STA_NONE:\n\t\tif (sta->sta_state != IEEE80211_STA_AUTH)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase IEEE80211_STA_AUTH:\n\t\tif (sta->sta_state != IEEE80211_STA_NONE &&\n\t\t    sta->sta_state != IEEE80211_STA_ASSOC)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase IEEE80211_STA_ASSOC:\n\t\tif (sta->sta_state != IEEE80211_STA_AUTH &&\n\t\t    sta->sta_state != IEEE80211_STA_AUTHORIZED)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase IEEE80211_STA_AUTHORIZED:\n\t\tif (sta->sta_state != IEEE80211_STA_ASSOC)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\tWARN(1, \"invalid state %d\", new_state);\n\t\treturn -EINVAL;\n\t}\n\n\tsta_dbg(sta->sdata, \"moving STA %pM to state %d\\n\",\n\t\tsta->sta.addr, new_state);\n\n\t/*\n\t * notify the driver before the actual changes so it can\n\t * fail the transition\n\t */\n\tif (test_sta_flag(sta, WLAN_STA_INSERTED)) {\n\t\tint err = drv_sta_state(sta->local, sta->sdata, sta,\n\t\t\t\t\tsta->sta_state, new_state);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t/* reflect the change in all state variables */\n\n\tswitch (new_state) {\n\tcase IEEE80211_STA_NONE:\n\t\tif (sta->sta_state == IEEE80211_STA_AUTH)\n\t\t\tclear_bit(WLAN_STA_AUTH, &sta->_flags);\n\t\tbreak;\n\tcase IEEE80211_STA_AUTH:\n\t\tif (sta->sta_state == IEEE80211_STA_NONE) {\n\t\t\tset_bit(WLAN_STA_AUTH, &sta->_flags);\n\t\t} else if (sta->sta_state == IEEE80211_STA_ASSOC) {\n\t\t\tclear_bit(WLAN_STA_ASSOC, &sta->_flags);\n\t\t\tieee80211_recalc_min_chandef(sta->sdata);\n\t\t\tif (!sta->sta.support_p2p_ps)\n\t\t\t\tieee80211_recalc_p2p_go_ps_allowed(sta->sdata);\n\t\t}\n\t\tbreak;\n\tcase IEEE80211_STA_ASSOC:\n\t\tif (sta->sta_state == IEEE80211_STA_AUTH) {\n\t\t\tset_bit(WLAN_STA_ASSOC, &sta->_flags);\n\t\t\tieee80211_recalc_min_chandef(sta->sdata);\n\t\t\tif (!sta->sta.support_p2p_ps)\n\t\t\t\tieee80211_recalc_p2p_go_ps_allowed(sta->sdata);\n\t\t} else if (sta->sta_state == IEEE80211_STA_AUTHORIZED) {\n\t\t\tieee80211_vif_dec_num_mcast(sta->sdata);\n\t\t\tclear_bit(WLAN_STA_AUTHORIZED, &sta->_flags);\n\t\t\tieee80211_clear_fast_xmit(sta);\n\t\t\tieee80211_clear_fast_rx(sta);\n\t\t}\n\t\tbreak;\n\tcase IEEE80211_STA_AUTHORIZED:\n\t\tif (sta->sta_state == IEEE80211_STA_ASSOC) {\n\t\t\tieee80211_vif_inc_num_mcast(sta->sdata);\n\t\t\tset_bit(WLAN_STA_AUTHORIZED, &sta->_flags);\n\t\t\tieee80211_check_fast_xmit(sta);\n\t\t\tieee80211_check_fast_rx(sta);\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tsta->sta_state = new_state;\n\n\treturn 0;\n}",
        "func": "int sta_info_move_state(struct sta_info *sta,\n\t\t\tenum ieee80211_sta_state new_state)\n{\n\tmight_sleep();\n\n\tif (sta->sta_state == new_state)\n\t\treturn 0;\n\n\t/* check allowed transitions first */\n\n\tswitch (new_state) {\n\tcase IEEE80211_STA_NONE:\n\t\tif (sta->sta_state != IEEE80211_STA_AUTH)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase IEEE80211_STA_AUTH:\n\t\tif (sta->sta_state != IEEE80211_STA_NONE &&\n\t\t    sta->sta_state != IEEE80211_STA_ASSOC)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase IEEE80211_STA_ASSOC:\n\t\tif (sta->sta_state != IEEE80211_STA_AUTH &&\n\t\t    sta->sta_state != IEEE80211_STA_AUTHORIZED)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tcase IEEE80211_STA_AUTHORIZED:\n\t\tif (sta->sta_state != IEEE80211_STA_ASSOC)\n\t\t\treturn -EINVAL;\n\t\tbreak;\n\tdefault:\n\t\tWARN(1, \"invalid state %d\", new_state);\n\t\treturn -EINVAL;\n\t}\n\n\tsta_dbg(sta->sdata, \"moving STA %pM to state %d\\n\",\n\t\tsta->sta.addr, new_state);\n\n\t/*\n\t * notify the driver before the actual changes so it can\n\t * fail the transition\n\t */\n\tif (test_sta_flag(sta, WLAN_STA_INSERTED)) {\n\t\tint err = drv_sta_state(sta->local, sta->sdata, sta,\n\t\t\t\t\tsta->sta_state, new_state);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\t/* reflect the change in all state variables */\n\n\tswitch (new_state) {\n\tcase IEEE80211_STA_NONE:\n\t\tif (sta->sta_state == IEEE80211_STA_AUTH)\n\t\t\tclear_bit(WLAN_STA_AUTH, &sta->_flags);\n\t\tbreak;\n\tcase IEEE80211_STA_AUTH:\n\t\tif (sta->sta_state == IEEE80211_STA_NONE) {\n\t\t\tset_bit(WLAN_STA_AUTH, &sta->_flags);\n\t\t} else if (sta->sta_state == IEEE80211_STA_ASSOC) {\n\t\t\tclear_bit(WLAN_STA_ASSOC, &sta->_flags);\n\t\t\tieee80211_recalc_min_chandef(sta->sdata);\n\t\t\tif (!sta->sta.support_p2p_ps)\n\t\t\t\tieee80211_recalc_p2p_go_ps_allowed(sta->sdata);\n\t\t}\n\t\tbreak;\n\tcase IEEE80211_STA_ASSOC:\n\t\tif (sta->sta_state == IEEE80211_STA_AUTH) {\n\t\t\tset_bit(WLAN_STA_ASSOC, &sta->_flags);\n\t\t\tieee80211_recalc_min_chandef(sta->sdata);\n\t\t\tif (!sta->sta.support_p2p_ps)\n\t\t\t\tieee80211_recalc_p2p_go_ps_allowed(sta->sdata);\n\t\t} else if (sta->sta_state == IEEE80211_STA_AUTHORIZED) {\n\t\t\tieee80211_vif_dec_num_mcast(sta->sdata);\n\t\t\tclear_bit(WLAN_STA_AUTHORIZED, &sta->_flags);\n\t\t\tieee80211_clear_fast_xmit(sta);\n\t\t\tieee80211_clear_fast_rx(sta);\n\t\t}\n\t\tbreak;\n\tcase IEEE80211_STA_AUTHORIZED:\n\t\tif (sta->sta_state == IEEE80211_STA_ASSOC) {\n\t\t\tieee80211_vif_inc_num_mcast(sta->sdata);\n\t\t\tset_bit(WLAN_STA_AUTHORIZED, &sta->_flags);\n\t\t\tieee80211_check_fast_xmit(sta);\n\t\t\tieee80211_check_fast_rx(sta);\n\t\t}\n\t\tif (sta->sdata->vif.type == NL80211_IFTYPE_AP_VLAN ||\n\t\t    sta->sdata->vif.type == NL80211_IFTYPE_AP)\n\t\t\tcfg80211_send_layer2_update(sta->sdata->dev,\n\t\t\t\t\t\t    sta->sta.addr);\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tsta->sta_state = new_state;\n\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -83,6 +83,10 @@\n \t\t\tieee80211_check_fast_xmit(sta);\n \t\t\tieee80211_check_fast_rx(sta);\n \t\t}\n+\t\tif (sta->sdata->vif.type == NL80211_IFTYPE_AP_VLAN ||\n+\t\t    sta->sdata->vif.type == NL80211_IFTYPE_AP)\n+\t\t\tcfg80211_send_layer2_update(sta->sdata->dev,\n+\t\t\t\t\t\t    sta->sta.addr);\n \t\tbreak;\n \tdefault:\n \t\tbreak;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\tif (sta->sdata->vif.type == NL80211_IFTYPE_AP_VLAN ||",
                "\t\t    sta->sdata->vif.type == NL80211_IFTYPE_AP)",
                "\t\t\tcfg80211_send_layer2_update(sta->sdata->dev,",
                "\t\t\t\t\t\t    sta->sta.addr);"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-1129",
        "func_name": "ceph/CephxSessionHandler::_calc_signature",
        "description": "A flaw was found in the way signature calculation was handled by cephx authentication protocol. An attacker having access to ceph cluster network who is able to alter the message payload was able to bypass signature checks done by cephx protocol. Ceph branches master, mimic, luminous and jewel are believed to be vulnerable.",
        "git_url": "https://github.com/ceph/ceph/commit/8f396cf35a3826044b089141667a196454c0a587",
        "commit_title": "auth/cephx/CephxSessionHandler: implement CEPHX_V2 calculation mode",
        "commit_text": " Derive the signature from the entire buffer (both cipher blocks). ",
        "func_before": "int CephxSessionHandler::_calc_signature(Message *m, uint64_t *psig)\n{\n  const ceph_msg_header& header = m->get_header();\n  const ceph_msg_footer& footer = m->get_footer();\n\n  // optimized signature calculation\n  // - avoid temporary allocated buffers from encode_encrypt[_enc_bl]\n  // - skip the leading 4 byte wrapper from encode_encrypt\n  struct {\n    __u8 v;\n    __le64 magic;\n    __le32 len;\n    __le32 header_crc;\n    __le32 front_crc;\n    __le32 middle_crc;\n    __le32 data_crc;\n  } __attribute__ ((packed)) sigblock = {\n    1, mswab(AUTH_ENC_MAGIC), mswab<uint32_t>(4*4),\n    mswab<uint32_t>(header.crc), mswab<uint32_t>(footer.front_crc),\n    mswab<uint32_t>(footer.middle_crc), mswab<uint32_t>(footer.data_crc)\n  };\n\n  char exp_buf[CryptoKey::get_max_outbuf_size(sizeof(sigblock))];\n\n  try {\n    const CryptoKey::in_slice_t in {\n      sizeof(sigblock),\n      reinterpret_cast<const unsigned char*>(&sigblock)\n    };\n    const CryptoKey::out_slice_t out {\n      sizeof(exp_buf),\n      reinterpret_cast<unsigned char*>(&exp_buf)\n    };\n\n    key.encrypt(cct, in, out);\n  } catch (std::exception& e) {\n    lderr(cct) << __func__ << \" failed to encrypt signature block\" << dendl;\n    return -1;\n  }\n\n  *psig = *reinterpret_cast<__le64*>(exp_buf);\n\n  ldout(cct, 10) << __func__ << \" seq \" << m->get_seq()\n\t\t << \" front_crc_ = \" << footer.front_crc\n\t\t << \" middle_crc = \" << footer.middle_crc\n\t\t << \" data_crc = \" << footer.data_crc\n\t\t << \" sig = \" << *psig\n\t\t << dendl;\n  return 0;\n}",
        "func": "int CephxSessionHandler::_calc_signature(Message *m, uint64_t *psig)\n{\n  const ceph_msg_header& header = m->get_header();\n  const ceph_msg_footer& footer = m->get_footer();\n\n  if (!HAVE_FEATURE(features, CEPHX_V2)) {\n    // legacy pre-mimic behavior for compatibility\n\n    // optimized signature calculation\n    // - avoid temporary allocated buffers from encode_encrypt[_enc_bl]\n    // - skip the leading 4 byte wrapper from encode_encrypt\n    struct {\n      __u8 v;\n      __le64 magic;\n      __le32 len;\n      __le32 header_crc;\n      __le32 front_crc;\n      __le32 middle_crc;\n      __le32 data_crc;\n    } __attribute__ ((packed)) sigblock = {\n      1, mswab(AUTH_ENC_MAGIC), mswab<uint32_t>(4*4),\n      mswab<uint32_t>(header.crc), mswab<uint32_t>(footer.front_crc),\n      mswab<uint32_t>(footer.middle_crc), mswab<uint32_t>(footer.data_crc)\n    };\n\n    char exp_buf[CryptoKey::get_max_outbuf_size(sizeof(sigblock))];\n\n    try {\n      const CryptoKey::in_slice_t in {\n\tsizeof(sigblock),\n\treinterpret_cast<const unsigned char*>(&sigblock)\n      };\n      const CryptoKey::out_slice_t out {\n\tsizeof(exp_buf),\n\treinterpret_cast<unsigned char*>(&exp_buf)\n      };\n      key.encrypt(cct, in, out);\n    } catch (std::exception& e) {\n      lderr(cct) << __func__ << \" failed to encrypt signature block\" << dendl;\n      return -1;\n    }\n\n    *psig = *reinterpret_cast<__le64*>(exp_buf);\n  } else {\n    // newer mimic+ signatures\n    struct {\n      __le32 header_crc;\n      __le32 front_crc;\n      __le32 front_len;\n      __le32 middle_crc;\n      __le32 middle_len;\n      __le32 data_crc;\n      __le32 data_len;\n      __le32 seq_lower_word;\n    } __attribute__ ((packed)) sigblock = {\n      mswab<uint32_t>(header.crc),\n      mswab<uint32_t>(footer.front_crc),\n      mswab<uint32_t>(header.front_len),\n      mswab<uint32_t>(footer.middle_crc),\n      mswab<uint32_t>(header.middle_len),\n      mswab<uint32_t>(footer.data_crc),\n      mswab<uint32_t>(header.data_len),\n      mswab<uint32_t>(header.seq)\n    };\n\n    char exp_buf[CryptoKey::get_max_outbuf_size(sizeof(sigblock))];\n\n    try {\n      const CryptoKey::in_slice_t in {\n\tsizeof(sigblock),\n\treinterpret_cast<const unsigned char*>(&sigblock)\n      };\n      const CryptoKey::out_slice_t out {\n\tsizeof(exp_buf),\n\treinterpret_cast<unsigned char*>(&exp_buf)\n      };\n      key.encrypt(cct, in, out);\n    } catch (std::exception& e) {\n      lderr(cct) << __func__ << \" failed to encrypt signature block\" << dendl;\n      return -1;\n    }\n\n    struct enc {\n      __le64 a, b, c, d;\n    } *penc = reinterpret_cast<enc*>(exp_buf);\n    *psig = penc->a ^ penc->b ^ penc->c ^ penc->d;\n  }\n\n  ldout(cct, 10) << __func__ << \" seq \" << m->get_seq()\n\t\t << \" front_crc_ = \" << footer.front_crc\n\t\t << \" middle_crc = \" << footer.middle_crc\n\t\t << \" data_crc = \" << footer.data_crc\n\t\t << \" sig = \" << *psig\n\t\t << dendl;\n  return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,42 +3,88 @@\n   const ceph_msg_header& header = m->get_header();\n   const ceph_msg_footer& footer = m->get_footer();\n \n-  // optimized signature calculation\n-  // - avoid temporary allocated buffers from encode_encrypt[_enc_bl]\n-  // - skip the leading 4 byte wrapper from encode_encrypt\n-  struct {\n-    __u8 v;\n-    __le64 magic;\n-    __le32 len;\n-    __le32 header_crc;\n-    __le32 front_crc;\n-    __le32 middle_crc;\n-    __le32 data_crc;\n-  } __attribute__ ((packed)) sigblock = {\n-    1, mswab(AUTH_ENC_MAGIC), mswab<uint32_t>(4*4),\n-    mswab<uint32_t>(header.crc), mswab<uint32_t>(footer.front_crc),\n-    mswab<uint32_t>(footer.middle_crc), mswab<uint32_t>(footer.data_crc)\n-  };\n+  if (!HAVE_FEATURE(features, CEPHX_V2)) {\n+    // legacy pre-mimic behavior for compatibility\n \n-  char exp_buf[CryptoKey::get_max_outbuf_size(sizeof(sigblock))];\n-\n-  try {\n-    const CryptoKey::in_slice_t in {\n-      sizeof(sigblock),\n-      reinterpret_cast<const unsigned char*>(&sigblock)\n-    };\n-    const CryptoKey::out_slice_t out {\n-      sizeof(exp_buf),\n-      reinterpret_cast<unsigned char*>(&exp_buf)\n+    // optimized signature calculation\n+    // - avoid temporary allocated buffers from encode_encrypt[_enc_bl]\n+    // - skip the leading 4 byte wrapper from encode_encrypt\n+    struct {\n+      __u8 v;\n+      __le64 magic;\n+      __le32 len;\n+      __le32 header_crc;\n+      __le32 front_crc;\n+      __le32 middle_crc;\n+      __le32 data_crc;\n+    } __attribute__ ((packed)) sigblock = {\n+      1, mswab(AUTH_ENC_MAGIC), mswab<uint32_t>(4*4),\n+      mswab<uint32_t>(header.crc), mswab<uint32_t>(footer.front_crc),\n+      mswab<uint32_t>(footer.middle_crc), mswab<uint32_t>(footer.data_crc)\n     };\n \n-    key.encrypt(cct, in, out);\n-  } catch (std::exception& e) {\n-    lderr(cct) << __func__ << \" failed to encrypt signature block\" << dendl;\n-    return -1;\n+    char exp_buf[CryptoKey::get_max_outbuf_size(sizeof(sigblock))];\n+\n+    try {\n+      const CryptoKey::in_slice_t in {\n+\tsizeof(sigblock),\n+\treinterpret_cast<const unsigned char*>(&sigblock)\n+      };\n+      const CryptoKey::out_slice_t out {\n+\tsizeof(exp_buf),\n+\treinterpret_cast<unsigned char*>(&exp_buf)\n+      };\n+      key.encrypt(cct, in, out);\n+    } catch (std::exception& e) {\n+      lderr(cct) << __func__ << \" failed to encrypt signature block\" << dendl;\n+      return -1;\n+    }\n+\n+    *psig = *reinterpret_cast<__le64*>(exp_buf);\n+  } else {\n+    // newer mimic+ signatures\n+    struct {\n+      __le32 header_crc;\n+      __le32 front_crc;\n+      __le32 front_len;\n+      __le32 middle_crc;\n+      __le32 middle_len;\n+      __le32 data_crc;\n+      __le32 data_len;\n+      __le32 seq_lower_word;\n+    } __attribute__ ((packed)) sigblock = {\n+      mswab<uint32_t>(header.crc),\n+      mswab<uint32_t>(footer.front_crc),\n+      mswab<uint32_t>(header.front_len),\n+      mswab<uint32_t>(footer.middle_crc),\n+      mswab<uint32_t>(header.middle_len),\n+      mswab<uint32_t>(footer.data_crc),\n+      mswab<uint32_t>(header.data_len),\n+      mswab<uint32_t>(header.seq)\n+    };\n+\n+    char exp_buf[CryptoKey::get_max_outbuf_size(sizeof(sigblock))];\n+\n+    try {\n+      const CryptoKey::in_slice_t in {\n+\tsizeof(sigblock),\n+\treinterpret_cast<const unsigned char*>(&sigblock)\n+      };\n+      const CryptoKey::out_slice_t out {\n+\tsizeof(exp_buf),\n+\treinterpret_cast<unsigned char*>(&exp_buf)\n+      };\n+      key.encrypt(cct, in, out);\n+    } catch (std::exception& e) {\n+      lderr(cct) << __func__ << \" failed to encrypt signature block\" << dendl;\n+      return -1;\n+    }\n+\n+    struct enc {\n+      __le64 a, b, c, d;\n+    } *penc = reinterpret_cast<enc*>(exp_buf);\n+    *psig = penc->a ^ penc->b ^ penc->c ^ penc->d;\n   }\n-\n-  *psig = *reinterpret_cast<__le64*>(exp_buf);\n \n   ldout(cct, 10) << __func__ << \" seq \" << m->get_seq()\n \t\t << \" front_crc_ = \" << footer.front_crc",
        "diff_line_info": {
            "deleted_lines": [
                "  // optimized signature calculation",
                "  // - avoid temporary allocated buffers from encode_encrypt[_enc_bl]",
                "  // - skip the leading 4 byte wrapper from encode_encrypt",
                "  struct {",
                "    __u8 v;",
                "    __le64 magic;",
                "    __le32 len;",
                "    __le32 header_crc;",
                "    __le32 front_crc;",
                "    __le32 middle_crc;",
                "    __le32 data_crc;",
                "  } __attribute__ ((packed)) sigblock = {",
                "    1, mswab(AUTH_ENC_MAGIC), mswab<uint32_t>(4*4),",
                "    mswab<uint32_t>(header.crc), mswab<uint32_t>(footer.front_crc),",
                "    mswab<uint32_t>(footer.middle_crc), mswab<uint32_t>(footer.data_crc)",
                "  };",
                "  char exp_buf[CryptoKey::get_max_outbuf_size(sizeof(sigblock))];",
                "",
                "  try {",
                "    const CryptoKey::in_slice_t in {",
                "      sizeof(sigblock),",
                "      reinterpret_cast<const unsigned char*>(&sigblock)",
                "    };",
                "    const CryptoKey::out_slice_t out {",
                "      sizeof(exp_buf),",
                "      reinterpret_cast<unsigned char*>(&exp_buf)",
                "    key.encrypt(cct, in, out);",
                "  } catch (std::exception& e) {",
                "    lderr(cct) << __func__ << \" failed to encrypt signature block\" << dendl;",
                "    return -1;",
                "",
                "  *psig = *reinterpret_cast<__le64*>(exp_buf);"
            ],
            "added_lines": [
                "  if (!HAVE_FEATURE(features, CEPHX_V2)) {",
                "    // legacy pre-mimic behavior for compatibility",
                "    // optimized signature calculation",
                "    // - avoid temporary allocated buffers from encode_encrypt[_enc_bl]",
                "    // - skip the leading 4 byte wrapper from encode_encrypt",
                "    struct {",
                "      __u8 v;",
                "      __le64 magic;",
                "      __le32 len;",
                "      __le32 header_crc;",
                "      __le32 front_crc;",
                "      __le32 middle_crc;",
                "      __le32 data_crc;",
                "    } __attribute__ ((packed)) sigblock = {",
                "      1, mswab(AUTH_ENC_MAGIC), mswab<uint32_t>(4*4),",
                "      mswab<uint32_t>(header.crc), mswab<uint32_t>(footer.front_crc),",
                "      mswab<uint32_t>(footer.middle_crc), mswab<uint32_t>(footer.data_crc)",
                "    char exp_buf[CryptoKey::get_max_outbuf_size(sizeof(sigblock))];",
                "",
                "    try {",
                "      const CryptoKey::in_slice_t in {",
                "\tsizeof(sigblock),",
                "\treinterpret_cast<const unsigned char*>(&sigblock)",
                "      };",
                "      const CryptoKey::out_slice_t out {",
                "\tsizeof(exp_buf),",
                "\treinterpret_cast<unsigned char*>(&exp_buf)",
                "      };",
                "      key.encrypt(cct, in, out);",
                "    } catch (std::exception& e) {",
                "      lderr(cct) << __func__ << \" failed to encrypt signature block\" << dendl;",
                "      return -1;",
                "    }",
                "",
                "    *psig = *reinterpret_cast<__le64*>(exp_buf);",
                "  } else {",
                "    // newer mimic+ signatures",
                "    struct {",
                "      __le32 header_crc;",
                "      __le32 front_crc;",
                "      __le32 front_len;",
                "      __le32 middle_crc;",
                "      __le32 middle_len;",
                "      __le32 data_crc;",
                "      __le32 data_len;",
                "      __le32 seq_lower_word;",
                "    } __attribute__ ((packed)) sigblock = {",
                "      mswab<uint32_t>(header.crc),",
                "      mswab<uint32_t>(footer.front_crc),",
                "      mswab<uint32_t>(header.front_len),",
                "      mswab<uint32_t>(footer.middle_crc),",
                "      mswab<uint32_t>(header.middle_len),",
                "      mswab<uint32_t>(footer.data_crc),",
                "      mswab<uint32_t>(header.data_len),",
                "      mswab<uint32_t>(header.seq)",
                "    };",
                "",
                "    char exp_buf[CryptoKey::get_max_outbuf_size(sizeof(sigblock))];",
                "",
                "    try {",
                "      const CryptoKey::in_slice_t in {",
                "\tsizeof(sigblock),",
                "\treinterpret_cast<const unsigned char*>(&sigblock)",
                "      };",
                "      const CryptoKey::out_slice_t out {",
                "\tsizeof(exp_buf),",
                "\treinterpret_cast<unsigned char*>(&exp_buf)",
                "      };",
                "      key.encrypt(cct, in, out);",
                "    } catch (std::exception& e) {",
                "      lderr(cct) << __func__ << \" failed to encrypt signature block\" << dendl;",
                "      return -1;",
                "    }",
                "",
                "    struct enc {",
                "      __le64 a, b, c, d;",
                "    } *penc = reinterpret_cast<enc*>(exp_buf);",
                "    *psig = penc->a ^ penc->b ^ penc->c ^ penc->d;"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-14345",
        "func_name": "sddm/Display::startAuth",
        "description": "An issue was discovered in SDDM through 0.17.0. If configured with ReuseSession=true, the password is not checked for users with an already existing session. Any user with access to the system D-Bus can therefore unlock any graphical session. This is related to daemon/Display.cpp and helper/backend/PamBackend.cpp.",
        "git_url": "https://github.com/sddm/sddm/commit/147cec383892d143b5e02daa70f1e7def50f5d98",
        "commit_title": "Fix authentication when reusing an existing session",
        "commit_text": " - Check the success value before unlocking the session - Don't attempt to use the nonexistant \"sddm-check\" PAM service",
        "func_before": "void Display::startAuth(const QString &user, const QString &password, const Session &session) {\n        m_passPhrase = password;\n\n        // sanity check\n        if (!session.isValid()) {\n            qCritical() << \"Invalid session\" << session.fileName();\n            return;\n        }\n        if (session.xdgSessionType().isEmpty()) {\n            qCritical() << \"Failed to find XDG session type for session\" << session.fileName();\n            return;\n        }\n        if (session.exec().isEmpty()) {\n            qCritical() << \"Failed to find command for session\" << session.fileName();\n            return;\n        }\n\n        QString existingSessionId;\n\n        if (Logind::isAvailable() && mainConfig.Users.ReuseSession.get()) {\n            OrgFreedesktopLogin1ManagerInterface manager(Logind::serviceName(), Logind::managerPath(), QDBusConnection::systemBus());\n            auto reply = manager.ListSessions();\n            reply.waitForFinished();\n\n            foreach(const SessionInfo &s, reply.value()) {\n                if (s.userName == user) {\n                    OrgFreedesktopLogin1SessionInterface session(Logind::serviceName(), s.sessionPath.path(), QDBusConnection::systemBus());\n                    if (session.service() == QLatin1String(\"sddm\")) {\n                        existingSessionId =  s.sessionId;\n                        break;\n                    }\n                }\n            }\n        }\n\n        // cache last session\n        m_lastSession = session;\n\n        // save session desktop file name, we'll use it to set the\n        // last session later, in slotAuthenticationFinished()\n        m_sessionName = session.fileName();\n\n        // some information\n        qDebug() << \"Session\" << m_sessionName << \"selected, command:\" << session.exec();\n\n        // create new VT for Wayland sessions otherwise use greeter vt\n        int vt = terminalId();\n        if (session.xdgSessionType() == QLatin1String(\"wayland\"))\n            vt = VirtualTerminal::setUpNewVt();\n        m_lastSession.setVt(vt);\n\n        QProcessEnvironment env;\n        env.insert(QStringLiteral(\"PATH\"), mainConfig.Users.DefaultPath.get());\n        if (session.xdgSessionType() == QLatin1String(\"x11\"))\n            env.insert(QStringLiteral(\"DISPLAY\"), name());\n        env.insert(QStringLiteral(\"XDG_SEAT_PATH\"), daemonApp->displayManager()->seatPath(seat()->name()));\n        env.insert(QStringLiteral(\"XDG_SESSION_PATH\"), daemonApp->displayManager()->sessionPath(QStringLiteral(\"Session%1\").arg(daemonApp->newSessionId())));\n        env.insert(QStringLiteral(\"DESKTOP_SESSION\"), session.desktopSession());\n        env.insert(QStringLiteral(\"XDG_CURRENT_DESKTOP\"), session.desktopNames());\n        env.insert(QStringLiteral(\"XDG_SESSION_CLASS\"), QStringLiteral(\"user\"));\n        env.insert(QStringLiteral(\"XDG_SESSION_TYPE\"), session.xdgSessionType());\n        env.insert(QStringLiteral(\"XDG_SEAT\"), seat()->name());\n\n        env.insert(QStringLiteral(\"XDG_SESSION_DESKTOP\"), session.desktopNames());\n        if (seat()->name() == QLatin1String(\"seat0\")) {\n            env.insert(QStringLiteral(\"XDG_VTNR\"), QString::number(vt));\n        }\n\n        m_auth->insertEnvironment(env);\n\n        m_auth->setUser(user);\n        if (existingSessionId.isNull()) {\n            m_auth->setSession(session.exec());\n        } else {\n            //we only want to unlock the session if we can lock in, so we want to go via PAM auth, but not start a new session\n            //by not setting the session and the helper will emit authentication and then quit\n            connect(m_auth, &Auth::authentication, this, [=](){\n                qDebug() << \"activating existing seat\";\n                OrgFreedesktopLogin1ManagerInterface manager(Logind::serviceName(), Logind::managerPath(), QDBusConnection::systemBus());\n                manager.UnlockSession(existingSessionId);\n                manager.ActivateSession(existingSessionId);\n            });\n        }\n        m_auth->start();\n    }",
        "func": "void Display::startAuth(const QString &user, const QString &password, const Session &session) {\n        m_passPhrase = password;\n\n        // sanity check\n        if (!session.isValid()) {\n            qCritical() << \"Invalid session\" << session.fileName();\n            return;\n        }\n        if (session.xdgSessionType().isEmpty()) {\n            qCritical() << \"Failed to find XDG session type for session\" << session.fileName();\n            return;\n        }\n        if (session.exec().isEmpty()) {\n            qCritical() << \"Failed to find command for session\" << session.fileName();\n            return;\n        }\n\n        QString existingSessionId;\n\n        if (Logind::isAvailable() && mainConfig.Users.ReuseSession.get()) {\n            OrgFreedesktopLogin1ManagerInterface manager(Logind::serviceName(), Logind::managerPath(), QDBusConnection::systemBus());\n            auto reply = manager.ListSessions();\n            reply.waitForFinished();\n\n            foreach(const SessionInfo &s, reply.value()) {\n                if (s.userName == user) {\n                    OrgFreedesktopLogin1SessionInterface session(Logind::serviceName(), s.sessionPath.path(), QDBusConnection::systemBus());\n                    if (session.service() == QLatin1String(\"sddm\")) {\n                        existingSessionId =  s.sessionId;\n                        break;\n                    }\n                }\n            }\n        }\n\n        // cache last session\n        m_lastSession = session;\n\n        // save session desktop file name, we'll use it to set the\n        // last session later, in slotAuthenticationFinished()\n        m_sessionName = session.fileName();\n\n        // some information\n        qDebug() << \"Session\" << m_sessionName << \"selected, command:\" << session.exec();\n\n        // create new VT for Wayland sessions otherwise use greeter vt\n        int vt = terminalId();\n        if (session.xdgSessionType() == QLatin1String(\"wayland\"))\n            vt = VirtualTerminal::setUpNewVt();\n        m_lastSession.setVt(vt);\n\n        QProcessEnvironment env;\n        env.insert(QStringLiteral(\"PATH\"), mainConfig.Users.DefaultPath.get());\n        if (session.xdgSessionType() == QLatin1String(\"x11\"))\n            env.insert(QStringLiteral(\"DISPLAY\"), name());\n        env.insert(QStringLiteral(\"XDG_SEAT_PATH\"), daemonApp->displayManager()->seatPath(seat()->name()));\n        env.insert(QStringLiteral(\"XDG_SESSION_PATH\"), daemonApp->displayManager()->sessionPath(QStringLiteral(\"Session%1\").arg(daemonApp->newSessionId())));\n        env.insert(QStringLiteral(\"DESKTOP_SESSION\"), session.desktopSession());\n        env.insert(QStringLiteral(\"XDG_CURRENT_DESKTOP\"), session.desktopNames());\n        env.insert(QStringLiteral(\"XDG_SESSION_CLASS\"), QStringLiteral(\"user\"));\n        env.insert(QStringLiteral(\"XDG_SESSION_TYPE\"), session.xdgSessionType());\n        env.insert(QStringLiteral(\"XDG_SEAT\"), seat()->name());\n\n        env.insert(QStringLiteral(\"XDG_SESSION_DESKTOP\"), session.desktopNames());\n        if (seat()->name() == QLatin1String(\"seat0\")) {\n            env.insert(QStringLiteral(\"XDG_VTNR\"), QString::number(vt));\n        }\n\n        m_auth->insertEnvironment(env);\n\n        m_auth->setUser(user);\n        if (existingSessionId.isNull()) {\n            m_auth->setSession(session.exec());\n        } else {\n            //we only want to unlock the session if we can lock in, so we want to go via PAM auth, but not start a new session\n            //by not setting the session and the helper will emit authentication and then quit\n            connect(m_auth, &Auth::authentication, this, [=](const QString &, bool success){\n                if(!success)\n                    return;\n                qDebug() << \"activating existing seat\";\n                OrgFreedesktopLogin1ManagerInterface manager(Logind::serviceName(), Logind::managerPath(), QDBusConnection::systemBus());\n                manager.UnlockSession(existingSessionId);\n                manager.ActivateSession(existingSessionId);\n            });\n        }\n        m_auth->start();\n    }",
        "diff_func": "--- func_before\n+++ func_after\n@@ -74,7 +74,9 @@\n         } else {\n             //we only want to unlock the session if we can lock in, so we want to go via PAM auth, but not start a new session\n             //by not setting the session and the helper will emit authentication and then quit\n-            connect(m_auth, &Auth::authentication, this, [=](){\n+            connect(m_auth, &Auth::authentication, this, [=](const QString &, bool success){\n+                if(!success)\n+                    return;\n                 qDebug() << \"activating existing seat\";\n                 OrgFreedesktopLogin1ManagerInterface manager(Logind::serviceName(), Logind::managerPath(), QDBusConnection::systemBus());\n                 manager.UnlockSession(existingSessionId);",
        "diff_line_info": {
            "deleted_lines": [
                "            connect(m_auth, &Auth::authentication, this, [=](){"
            ],
            "added_lines": [
                "            connect(m_auth, &Auth::authentication, this, [=](const QString &, bool success){",
                "                if(!success)",
                "                    return;"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-14345",
        "func_name": "sddm/PamBackend::start",
        "description": "An issue was discovered in SDDM through 0.17.0. If configured with ReuseSession=true, the password is not checked for users with an already existing session. Any user with access to the system D-Bus can therefore unlock any graphical session. This is related to daemon/Display.cpp and helper/backend/PamBackend.cpp.",
        "git_url": "https://github.com/sddm/sddm/commit/147cec383892d143b5e02daa70f1e7def50f5d98",
        "commit_title": "Fix authentication when reusing an existing session",
        "commit_text": " - Check the success value before unlocking the session - Don't attempt to use the nonexistant \"sddm-check\" PAM service",
        "func_before": "bool PamBackend::start(const QString &user) {\n        bool result;\n\n        QString service = QStringLiteral(\"sddm\");\n\n        if (user == QStringLiteral(\"sddm\") && m_greeter)\n            service = QStringLiteral(\"sddm-greeter\");\n        else if (m_app->session()->path().isEmpty())\n            service = QStringLiteral(\"sddm-check\");\n        else if (m_autologin)\n            service = QStringLiteral(\"sddm-autologin\");\n        result = m_pam->start(service, user);\n\n        if (!result)\n            m_app->error(m_pam->errorString(), Auth::ERROR_INTERNAL);\n\n        return result;\n    }",
        "func": "bool PamBackend::start(const QString &user) {\n        bool result;\n\n        QString service = QStringLiteral(\"sddm\");\n\n        if (user == QStringLiteral(\"sddm\") && m_greeter)\n            service = QStringLiteral(\"sddm-greeter\");\n        else if (m_autologin)\n            service = QStringLiteral(\"sddm-autologin\");\n        result = m_pam->start(service, user);\n\n        if (!result)\n            m_app->error(m_pam->errorString(), Auth::ERROR_INTERNAL);\n\n        return result;\n    }",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,8 +5,6 @@\n \n         if (user == QStringLiteral(\"sddm\") && m_greeter)\n             service = QStringLiteral(\"sddm-greeter\");\n-        else if (m_app->session()->path().isEmpty())\n-            service = QStringLiteral(\"sddm-check\");\n         else if (m_autologin)\n             service = QStringLiteral(\"sddm-autologin\");\n         result = m_pam->start(service, user);",
        "diff_line_info": {
            "deleted_lines": [
                "        else if (m_app->session()->path().isEmpty())",
                "            service = QStringLiteral(\"sddm-check\");"
            ],
            "added_lines": []
        }
    },
    {
        "cve_id": "CVE-2017-7562",
        "func_name": "krb5/crypto_retrieve_X509_sans",
        "description": "An authentication bypass flaw was found in the way krb5's certauth interface before 1.16.1 handled the validation of client certificates. A remote attacker able to communicate with the KDC could potentially use this flaw to impersonate arbitrary principals under rare and erroneous circumstances.",
        "git_url": "https://github.com/krb5/krb5/commit/50fe4074f188c2d4da0c421e96553acea8378db2",
        "commit_title": "Fix certauth built-in module returns",
        "commit_text": " The PKINIT certauth eku module should never authoritatively authorize a certificate, because an extended key usage does not establish a relationship between the certificate and any specific user; it only establishes that the certificate was created for PKINIT client authentication.  Therefore, pkinit_eku_authorize() should return KRB5_PLUGIN_NO_HANDLE on success, not 0.  The certauth san module should pass if it does not find any SANs of the types it can match against; the presence of other types of SANs should not cause it to explicitly deny a certificate.  Check for an empty result from crypto_retrieve_cert_sans() in verify_client_san(), instead of returning ENOENT from crypto_retrieve_cert_sans() when there are no SANs at all.  ticket: 8561",
        "func_before": "static krb5_error_code\ncrypto_retrieve_X509_sans(krb5_context context,\n                          pkinit_plg_crypto_context plgctx,\n                          pkinit_req_crypto_context reqctx,\n                          X509 *cert,\n                          krb5_principal **princs_ret,\n                          krb5_principal **upn_ret,\n                          unsigned char ***dns_ret)\n{\n    krb5_error_code retval = EINVAL;\n    char buf[DN_BUF_LEN];\n    int p = 0, u = 0, d = 0, ret = 0, l;\n    krb5_principal *princs = NULL;\n    krb5_principal *upns = NULL;\n    unsigned char **dnss = NULL;\n    unsigned int i, num_found = 0, num_sans = 0;\n    X509_EXTENSION *ext = NULL;\n    GENERAL_NAMES *ialt = NULL;\n    GENERAL_NAME *gen = NULL;\n\n    if (princs_ret != NULL)\n        *princs_ret = NULL;\n    if (upn_ret != NULL)\n        *upn_ret = NULL;\n    if (dns_ret != NULL)\n        *dns_ret = NULL;\n\n    if (princs_ret == NULL && upn_ret == NULL && dns_ret == NULL) {\n        pkiDebug(\"%s: nowhere to return any values!\\n\", __FUNCTION__);\n        return retval;\n    }\n\n    if (cert == NULL) {\n        pkiDebug(\"%s: no certificate!\\n\", __FUNCTION__);\n        return retval;\n    }\n\n    X509_NAME_oneline(X509_get_subject_name(cert),\n                      buf, sizeof(buf));\n    pkiDebug(\"%s: looking for SANs in cert = %s\\n\", __FUNCTION__, buf);\n\n    l = X509_get_ext_by_NID(cert, NID_subject_alt_name, -1);\n    if (l < 0)\n        return 0;\n\n    if (!(ext = X509_get_ext(cert, l)) || !(ialt = X509V3_EXT_d2i(ext))) {\n        pkiDebug(\"%s: found no subject alt name extensions\\n\", __FUNCTION__);\n        retval = ENOENT;\n        goto cleanup;\n    }\n    num_sans = sk_GENERAL_NAME_num(ialt);\n\n    pkiDebug(\"%s: found %d subject alt name extension(s)\\n\", __FUNCTION__,\n             num_sans);\n\n    /* OK, we're likely returning something. Allocate return values */\n    if (princs_ret != NULL) {\n        princs = calloc(num_sans + 1, sizeof(krb5_principal));\n        if (princs == NULL) {\n            retval = ENOMEM;\n            goto cleanup;\n        }\n    }\n    if (upn_ret != NULL) {\n        upns = calloc(num_sans + 1, sizeof(krb5_principal));\n        if (upns == NULL) {\n            retval = ENOMEM;\n            goto cleanup;\n        }\n    }\n    if (dns_ret != NULL) {\n        dnss = calloc(num_sans + 1, sizeof(*dnss));\n        if (dnss == NULL) {\n            retval = ENOMEM;\n            goto cleanup;\n        }\n    }\n\n    for (i = 0; i < num_sans; i++) {\n        krb5_data name = { 0, 0, NULL };\n\n        gen = sk_GENERAL_NAME_value(ialt, i);\n        switch (gen->type) {\n        case GEN_OTHERNAME:\n            name.length = gen->d.otherName->value->value.sequence->length;\n            name.data = (char *)gen->d.otherName->value->value.sequence->data;\n            if (princs != NULL &&\n                OBJ_cmp(plgctx->id_pkinit_san,\n                        gen->d.otherName->type_id) == 0) {\n#ifdef DEBUG_ASN1\n                print_buffer_bin((unsigned char *)name.data, name.length,\n                                 \"/tmp/pkinit_san\");\n#endif\n                ret = k5int_decode_krb5_principal_name(&name, &princs[p]);\n                if (ret) {\n                    pkiDebug(\"%s: failed decoding pkinit san value\\n\",\n                             __FUNCTION__);\n                } else {\n                    p++;\n                    num_found++;\n                }\n            } else if (upns != NULL &&\n                       OBJ_cmp(plgctx->id_ms_san_upn,\n                               gen->d.otherName->type_id) == 0) {\n                /* Prevent abuse of embedded null characters. */\n                if (memchr(name.data, '\\0', name.length))\n                    break;\n                ret = krb5_parse_name_flags(context, name.data,\n                                            KRB5_PRINCIPAL_PARSE_ENTERPRISE,\n                                            &upns[u]);\n                if (ret) {\n                    pkiDebug(\"%s: failed parsing ms-upn san value\\n\",\n                             __FUNCTION__);\n                } else {\n                    u++;\n                    num_found++;\n                }\n            } else {\n                pkiDebug(\"%s: unrecognized othername oid in SAN\\n\",\n                         __FUNCTION__);\n                continue;\n            }\n\n            break;\n        case GEN_DNS:\n            if (dnss != NULL) {\n                /* Prevent abuse of embedded null characters. */\n                if (memchr(gen->d.dNSName->data, '\\0', gen->d.dNSName->length))\n                    break;\n                pkiDebug(\"%s: found dns name = %s\\n\", __FUNCTION__,\n                         gen->d.dNSName->data);\n                dnss[d] = (unsigned char *)\n                    strdup((char *)gen->d.dNSName->data);\n                if (dnss[d] == NULL) {\n                    pkiDebug(\"%s: failed to duplicate dns name\\n\",\n                             __FUNCTION__);\n                } else {\n                    d++;\n                    num_found++;\n                }\n            }\n            break;\n        default:\n            pkiDebug(\"%s: SAN type = %d expecting %d\\n\", __FUNCTION__,\n                     gen->type, GEN_OTHERNAME);\n        }\n    }\n    sk_GENERAL_NAME_pop_free(ialt, GENERAL_NAME_free);\n\n    retval = 0;\n    if (princs)\n        *princs_ret = princs;\n    if (upns)\n        *upn_ret = upns;\n    if (dnss)\n        *dns_ret = dnss;\n\ncleanup:\n    if (retval) {\n        if (princs != NULL) {\n            for (i = 0; princs[i] != NULL; i++)\n                krb5_free_principal(context, princs[i]);\n            free(princs);\n        }\n        if (upns != NULL) {\n            for (i = 0; upns[i] != NULL; i++)\n                krb5_free_principal(context, upns[i]);\n            free(upns);\n        }\n        if (dnss != NULL) {\n            for (i = 0; dnss[i] != NULL; i++)\n                free(dnss[i]);\n            free(dnss);\n        }\n    }\n    return retval;\n}",
        "func": "static krb5_error_code\ncrypto_retrieve_X509_sans(krb5_context context,\n                          pkinit_plg_crypto_context plgctx,\n                          pkinit_req_crypto_context reqctx,\n                          X509 *cert,\n                          krb5_principal **princs_ret,\n                          krb5_principal **upn_ret,\n                          unsigned char ***dns_ret)\n{\n    krb5_error_code retval = EINVAL;\n    char buf[DN_BUF_LEN];\n    int p = 0, u = 0, d = 0, ret = 0, l;\n    krb5_principal *princs = NULL;\n    krb5_principal *upns = NULL;\n    unsigned char **dnss = NULL;\n    unsigned int i, num_found = 0, num_sans = 0;\n    X509_EXTENSION *ext = NULL;\n    GENERAL_NAMES *ialt = NULL;\n    GENERAL_NAME *gen = NULL;\n\n    if (princs_ret != NULL)\n        *princs_ret = NULL;\n    if (upn_ret != NULL)\n        *upn_ret = NULL;\n    if (dns_ret != NULL)\n        *dns_ret = NULL;\n\n    if (princs_ret == NULL && upn_ret == NULL && dns_ret == NULL) {\n        pkiDebug(\"%s: nowhere to return any values!\\n\", __FUNCTION__);\n        return retval;\n    }\n\n    if (cert == NULL) {\n        pkiDebug(\"%s: no certificate!\\n\", __FUNCTION__);\n        return retval;\n    }\n\n    X509_NAME_oneline(X509_get_subject_name(cert),\n                      buf, sizeof(buf));\n    pkiDebug(\"%s: looking for SANs in cert = %s\\n\", __FUNCTION__, buf);\n\n    l = X509_get_ext_by_NID(cert, NID_subject_alt_name, -1);\n    if (l < 0)\n        return 0;\n\n    if (!(ext = X509_get_ext(cert, l)) || !(ialt = X509V3_EXT_d2i(ext))) {\n        pkiDebug(\"%s: found no subject alt name extensions\\n\", __FUNCTION__);\n        goto cleanup;\n    }\n    num_sans = sk_GENERAL_NAME_num(ialt);\n\n    pkiDebug(\"%s: found %d subject alt name extension(s)\\n\", __FUNCTION__,\n             num_sans);\n\n    /* OK, we're likely returning something. Allocate return values */\n    if (princs_ret != NULL) {\n        princs = calloc(num_sans + 1, sizeof(krb5_principal));\n        if (princs == NULL) {\n            retval = ENOMEM;\n            goto cleanup;\n        }\n    }\n    if (upn_ret != NULL) {\n        upns = calloc(num_sans + 1, sizeof(krb5_principal));\n        if (upns == NULL) {\n            retval = ENOMEM;\n            goto cleanup;\n        }\n    }\n    if (dns_ret != NULL) {\n        dnss = calloc(num_sans + 1, sizeof(*dnss));\n        if (dnss == NULL) {\n            retval = ENOMEM;\n            goto cleanup;\n        }\n    }\n\n    for (i = 0; i < num_sans; i++) {\n        krb5_data name = { 0, 0, NULL };\n\n        gen = sk_GENERAL_NAME_value(ialt, i);\n        switch (gen->type) {\n        case GEN_OTHERNAME:\n            name.length = gen->d.otherName->value->value.sequence->length;\n            name.data = (char *)gen->d.otherName->value->value.sequence->data;\n            if (princs != NULL &&\n                OBJ_cmp(plgctx->id_pkinit_san,\n                        gen->d.otherName->type_id) == 0) {\n#ifdef DEBUG_ASN1\n                print_buffer_bin((unsigned char *)name.data, name.length,\n                                 \"/tmp/pkinit_san\");\n#endif\n                ret = k5int_decode_krb5_principal_name(&name, &princs[p]);\n                if (ret) {\n                    pkiDebug(\"%s: failed decoding pkinit san value\\n\",\n                             __FUNCTION__);\n                } else {\n                    p++;\n                    num_found++;\n                }\n            } else if (upns != NULL &&\n                       OBJ_cmp(plgctx->id_ms_san_upn,\n                               gen->d.otherName->type_id) == 0) {\n                /* Prevent abuse of embedded null characters. */\n                if (memchr(name.data, '\\0', name.length))\n                    break;\n                ret = krb5_parse_name_flags(context, name.data,\n                                            KRB5_PRINCIPAL_PARSE_ENTERPRISE,\n                                            &upns[u]);\n                if (ret) {\n                    pkiDebug(\"%s: failed parsing ms-upn san value\\n\",\n                             __FUNCTION__);\n                } else {\n                    u++;\n                    num_found++;\n                }\n            } else {\n                pkiDebug(\"%s: unrecognized othername oid in SAN\\n\",\n                         __FUNCTION__);\n                continue;\n            }\n\n            break;\n        case GEN_DNS:\n            if (dnss != NULL) {\n                /* Prevent abuse of embedded null characters. */\n                if (memchr(gen->d.dNSName->data, '\\0', gen->d.dNSName->length))\n                    break;\n                pkiDebug(\"%s: found dns name = %s\\n\", __FUNCTION__,\n                         gen->d.dNSName->data);\n                dnss[d] = (unsigned char *)\n                    strdup((char *)gen->d.dNSName->data);\n                if (dnss[d] == NULL) {\n                    pkiDebug(\"%s: failed to duplicate dns name\\n\",\n                             __FUNCTION__);\n                } else {\n                    d++;\n                    num_found++;\n                }\n            }\n            break;\n        default:\n            pkiDebug(\"%s: SAN type = %d expecting %d\\n\", __FUNCTION__,\n                     gen->type, GEN_OTHERNAME);\n        }\n    }\n    sk_GENERAL_NAME_pop_free(ialt, GENERAL_NAME_free);\n\n    retval = 0;\n    if (princs != NULL && *princs != NULL) {\n        *princs_ret = princs;\n        princs = NULL;\n    }\n    if (upns != NULL && *upns != NULL) {\n        *upn_ret = upns;\n        upns = NULL;\n    }\n    if (dnss != NULL && *dnss != NULL) {\n        *dns_ret = dnss;\n        dnss = NULL;\n    }\n\ncleanup:\n    for (i = 0; princs != NULL && princs[i] != NULL; i++)\n        krb5_free_principal(context, princs[i]);\n    free(princs);\n    for (i = 0; upns != NULL && upns[i] != NULL; i++)\n        krb5_free_principal(context, upns[i]);\n    free(upns);\n    for (i = 0; dnss != NULL && dnss[i] != NULL; i++)\n        free(dnss[i]);\n    free(dnss);\n    return retval;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -45,7 +45,6 @@\n \n     if (!(ext = X509_get_ext(cert, l)) || !(ialt = X509V3_EXT_d2i(ext))) {\n         pkiDebug(\"%s: found no subject alt name extensions\\n\", __FUNCTION__);\n-        retval = ENOENT;\n         goto cleanup;\n     }\n     num_sans = sk_GENERAL_NAME_num(ialt);\n@@ -148,30 +147,28 @@\n     sk_GENERAL_NAME_pop_free(ialt, GENERAL_NAME_free);\n \n     retval = 0;\n-    if (princs)\n+    if (princs != NULL && *princs != NULL) {\n         *princs_ret = princs;\n-    if (upns)\n+        princs = NULL;\n+    }\n+    if (upns != NULL && *upns != NULL) {\n         *upn_ret = upns;\n-    if (dnss)\n+        upns = NULL;\n+    }\n+    if (dnss != NULL && *dnss != NULL) {\n         *dns_ret = dnss;\n+        dnss = NULL;\n+    }\n \n cleanup:\n-    if (retval) {\n-        if (princs != NULL) {\n-            for (i = 0; princs[i] != NULL; i++)\n-                krb5_free_principal(context, princs[i]);\n-            free(princs);\n-        }\n-        if (upns != NULL) {\n-            for (i = 0; upns[i] != NULL; i++)\n-                krb5_free_principal(context, upns[i]);\n-            free(upns);\n-        }\n-        if (dnss != NULL) {\n-            for (i = 0; dnss[i] != NULL; i++)\n-                free(dnss[i]);\n-            free(dnss);\n-        }\n-    }\n+    for (i = 0; princs != NULL && princs[i] != NULL; i++)\n+        krb5_free_principal(context, princs[i]);\n+    free(princs);\n+    for (i = 0; upns != NULL && upns[i] != NULL; i++)\n+        krb5_free_principal(context, upns[i]);\n+    free(upns);\n+    for (i = 0; dnss != NULL && dnss[i] != NULL; i++)\n+        free(dnss[i]);\n+    free(dnss);\n     return retval;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "        retval = ENOENT;",
                "    if (princs)",
                "    if (upns)",
                "    if (dnss)",
                "    if (retval) {",
                "        if (princs != NULL) {",
                "            for (i = 0; princs[i] != NULL; i++)",
                "                krb5_free_principal(context, princs[i]);",
                "            free(princs);",
                "        }",
                "        if (upns != NULL) {",
                "            for (i = 0; upns[i] != NULL; i++)",
                "                krb5_free_principal(context, upns[i]);",
                "            free(upns);",
                "        }",
                "        if (dnss != NULL) {",
                "            for (i = 0; dnss[i] != NULL; i++)",
                "                free(dnss[i]);",
                "            free(dnss);",
                "        }",
                "    }"
            ],
            "added_lines": [
                "    if (princs != NULL && *princs != NULL) {",
                "        princs = NULL;",
                "    }",
                "    if (upns != NULL && *upns != NULL) {",
                "        upns = NULL;",
                "    }",
                "    if (dnss != NULL && *dnss != NULL) {",
                "        dnss = NULL;",
                "    }",
                "    for (i = 0; princs != NULL && princs[i] != NULL; i++)",
                "        krb5_free_principal(context, princs[i]);",
                "    free(princs);",
                "    for (i = 0; upns != NULL && upns[i] != NULL; i++)",
                "        krb5_free_principal(context, upns[i]);",
                "    free(upns);",
                "    for (i = 0; dnss != NULL && dnss[i] != NULL; i++)",
                "        free(dnss[i]);",
                "    free(dnss);"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-7562",
        "func_name": "krb5/verify_client_san",
        "description": "An authentication bypass flaw was found in the way krb5's certauth interface before 1.16.1 handled the validation of client certificates. A remote attacker able to communicate with the KDC could potentially use this flaw to impersonate arbitrary principals under rare and erroneous circumstances.",
        "git_url": "https://github.com/krb5/krb5/commit/50fe4074f188c2d4da0c421e96553acea8378db2",
        "commit_title": "Fix certauth built-in module returns",
        "commit_text": " The PKINIT certauth eku module should never authoritatively authorize a certificate, because an extended key usage does not establish a relationship between the certificate and any specific user; it only establishes that the certificate was created for PKINIT client authentication.  Therefore, pkinit_eku_authorize() should return KRB5_PLUGIN_NO_HANDLE on success, not 0.  The certauth san module should pass if it does not find any SANs of the types it can match against; the presence of other types of SANs should not cause it to explicitly deny a certificate.  Check for an empty result from crypto_retrieve_cert_sans() in verify_client_san(), instead of returning ENOENT from crypto_retrieve_cert_sans() when there are no SANs at all.  ticket: 8561",
        "func_before": "static krb5_error_code\nverify_client_san(krb5_context context,\n                  pkinit_kdc_context plgctx,\n                  pkinit_kdc_req_context reqctx,\n                  krb5_kdcpreauth_callbacks cb,\n                  krb5_kdcpreauth_rock rock,\n                  krb5_const_principal client,\n                  int *valid_san)\n{\n    krb5_error_code retval;\n    krb5_principal *princs = NULL;\n    krb5_principal *upns = NULL;\n    int i;\n#ifdef DEBUG_SAN_INFO\n    char *client_string = NULL, *san_string;\n#endif\n\n    *valid_san = 0;\n    retval = crypto_retrieve_cert_sans(context, plgctx->cryptoctx,\n                                       reqctx->cryptoctx, plgctx->idctx,\n                                       &princs,\n                                       plgctx->opts->allow_upn ? &upns : NULL,\n                                       NULL);\n    if (retval == ENOENT) {\n        TRACE_PKINIT_SERVER_NO_SAN(context);\n        goto out;\n    } else if (retval) {\n        pkiDebug(\"%s: error from retrieve_certificate_sans()\\n\", __FUNCTION__);\n        retval = KRB5KDC_ERR_CLIENT_NAME_MISMATCH;\n        goto out;\n    }\n    /* XXX Verify this is consistent with client side XXX */\n#if 0\n    retval = call_san_checking_plugins(context, plgctx, reqctx, princs,\n                                       upns, NULL, &plugin_decision, &ignore);\n    pkiDebug(\"%s: call_san_checking_plugins() returned retval %d\\n\",\n             __FUNCTION__);\n    if (retval) {\n        retval = KRB5KDC_ERR_CLIENT_NAME_MISMATCH;\n        goto cleanup;\n    }\n    pkiDebug(\"%s: call_san_checking_plugins() returned decision %d\\n\",\n             __FUNCTION__, plugin_decision);\n    if (plugin_decision != NO_DECISION) {\n        retval = plugin_decision;\n        goto out;\n    }\n#endif\n\n#ifdef DEBUG_SAN_INFO\n    krb5_unparse_name(context, client, &client_string);\n#endif\n    pkiDebug(\"%s: Checking pkinit sans\\n\", __FUNCTION__);\n    for (i = 0; princs != NULL && princs[i] != NULL; i++) {\n#ifdef DEBUG_SAN_INFO\n        krb5_unparse_name(context, princs[i], &san_string);\n        pkiDebug(\"%s: Comparing client '%s' to pkinit san value '%s'\\n\",\n                 __FUNCTION__, client_string, san_string);\n        krb5_free_unparsed_name(context, san_string);\n#endif\n        if (cb->match_client(context, rock, princs[i])) {\n            TRACE_PKINIT_SERVER_MATCHING_SAN_FOUND(context);\n            *valid_san = 1;\n            retval = 0;\n            goto out;\n        }\n    }\n    pkiDebug(\"%s: no pkinit san match found\\n\", __FUNCTION__);\n    /*\n     * XXX if cert has names but none match, should we\n     * be returning KRB5KDC_ERR_CLIENT_NAME_MISMATCH here?\n     */\n\n    if (upns == NULL) {\n        pkiDebug(\"%s: no upn sans (or we wouldn't accept them anyway)\\n\",\n                 __FUNCTION__);\n        retval = KRB5KDC_ERR_CLIENT_NAME_MISMATCH;\n        goto out;\n    }\n\n    pkiDebug(\"%s: Checking upn sans\\n\", __FUNCTION__);\n    for (i = 0; upns[i] != NULL; i++) {\n#ifdef DEBUG_SAN_INFO\n        krb5_unparse_name(context, upns[i], &san_string);\n        pkiDebug(\"%s: Comparing client '%s' to upn san value '%s'\\n\",\n                 __FUNCTION__, client_string, san_string);\n        krb5_free_unparsed_name(context, san_string);\n#endif\n        if (cb->match_client(context, rock, upns[i])) {\n            TRACE_PKINIT_SERVER_MATCHING_UPN_FOUND(context);\n            *valid_san = 1;\n            retval = 0;\n            goto out;\n        }\n    }\n    pkiDebug(\"%s: no upn san match found\\n\", __FUNCTION__);\n\n    /* We found no match */\n    if (princs != NULL || upns != NULL) {\n        *valid_san = 0;\n        /* XXX ??? If there was one or more name in the cert, but\n         * none matched the client name, then return mismatch? */\n        retval = KRB5KDC_ERR_CLIENT_NAME_MISMATCH;\n    }\n    retval = 0;\n\nout:\n    if (princs != NULL) {\n        for (i = 0; princs[i] != NULL; i++)\n            krb5_free_principal(context, princs[i]);\n        free(princs);\n    }\n    if (upns != NULL) {\n        for (i = 0; upns[i] != NULL; i++)\n            krb5_free_principal(context, upns[i]);\n        free(upns);\n    }\n#ifdef DEBUG_SAN_INFO\n    if (client_string != NULL)\n        krb5_free_unparsed_name(context, client_string);\n#endif\n    pkiDebug(\"%s: returning retval %d, valid_san %d\\n\",\n             __FUNCTION__, retval, *valid_san);\n    return retval;\n}",
        "func": "static krb5_error_code\nverify_client_san(krb5_context context,\n                  pkinit_kdc_context plgctx,\n                  pkinit_kdc_req_context reqctx,\n                  krb5_kdcpreauth_callbacks cb,\n                  krb5_kdcpreauth_rock rock,\n                  krb5_const_principal client,\n                  int *valid_san)\n{\n    krb5_error_code retval;\n    krb5_principal *princs = NULL;\n    krb5_principal *upns = NULL;\n    int i;\n#ifdef DEBUG_SAN_INFO\n    char *client_string = NULL, *san_string;\n#endif\n\n    *valid_san = 0;\n    retval = crypto_retrieve_cert_sans(context, plgctx->cryptoctx,\n                                       reqctx->cryptoctx, plgctx->idctx,\n                                       &princs,\n                                       plgctx->opts->allow_upn ? &upns : NULL,\n                                       NULL);\n    if (retval) {\n        pkiDebug(\"%s: error from retrieve_certificate_sans()\\n\", __FUNCTION__);\n        retval = KRB5KDC_ERR_CLIENT_NAME_MISMATCH;\n        goto out;\n    }\n\n    if (princs == NULL && upns == NULL) {\n        TRACE_PKINIT_SERVER_NO_SAN(context);\n        retval = ENOENT;\n        goto out;\n    }\n\n    /* XXX Verify this is consistent with client side XXX */\n#if 0\n    retval = call_san_checking_plugins(context, plgctx, reqctx, princs,\n                                       upns, NULL, &plugin_decision, &ignore);\n    pkiDebug(\"%s: call_san_checking_plugins() returned retval %d\\n\",\n             __FUNCTION__);\n    if (retval) {\n        retval = KRB5KDC_ERR_CLIENT_NAME_MISMATCH;\n        goto cleanup;\n    }\n    pkiDebug(\"%s: call_san_checking_plugins() returned decision %d\\n\",\n             __FUNCTION__, plugin_decision);\n    if (plugin_decision != NO_DECISION) {\n        retval = plugin_decision;\n        goto out;\n    }\n#endif\n\n#ifdef DEBUG_SAN_INFO\n    krb5_unparse_name(context, client, &client_string);\n#endif\n    pkiDebug(\"%s: Checking pkinit sans\\n\", __FUNCTION__);\n    for (i = 0; princs != NULL && princs[i] != NULL; i++) {\n#ifdef DEBUG_SAN_INFO\n        krb5_unparse_name(context, princs[i], &san_string);\n        pkiDebug(\"%s: Comparing client '%s' to pkinit san value '%s'\\n\",\n                 __FUNCTION__, client_string, san_string);\n        krb5_free_unparsed_name(context, san_string);\n#endif\n        if (cb->match_client(context, rock, princs[i])) {\n            TRACE_PKINIT_SERVER_MATCHING_SAN_FOUND(context);\n            *valid_san = 1;\n            retval = 0;\n            goto out;\n        }\n    }\n    pkiDebug(\"%s: no pkinit san match found\\n\", __FUNCTION__);\n    /*\n     * XXX if cert has names but none match, should we\n     * be returning KRB5KDC_ERR_CLIENT_NAME_MISMATCH here?\n     */\n\n    if (upns == NULL) {\n        pkiDebug(\"%s: no upn sans (or we wouldn't accept them anyway)\\n\",\n                 __FUNCTION__);\n        retval = KRB5KDC_ERR_CLIENT_NAME_MISMATCH;\n        goto out;\n    }\n\n    pkiDebug(\"%s: Checking upn sans\\n\", __FUNCTION__);\n    for (i = 0; upns[i] != NULL; i++) {\n#ifdef DEBUG_SAN_INFO\n        krb5_unparse_name(context, upns[i], &san_string);\n        pkiDebug(\"%s: Comparing client '%s' to upn san value '%s'\\n\",\n                 __FUNCTION__, client_string, san_string);\n        krb5_free_unparsed_name(context, san_string);\n#endif\n        if (cb->match_client(context, rock, upns[i])) {\n            TRACE_PKINIT_SERVER_MATCHING_UPN_FOUND(context);\n            *valid_san = 1;\n            retval = 0;\n            goto out;\n        }\n    }\n    pkiDebug(\"%s: no upn san match found\\n\", __FUNCTION__);\n\n    /* We found no match */\n    if (princs != NULL || upns != NULL) {\n        *valid_san = 0;\n        /* XXX ??? If there was one or more name in the cert, but\n         * none matched the client name, then return mismatch? */\n        retval = KRB5KDC_ERR_CLIENT_NAME_MISMATCH;\n    }\n    retval = 0;\n\nout:\n    if (princs != NULL) {\n        for (i = 0; princs[i] != NULL; i++)\n            krb5_free_principal(context, princs[i]);\n        free(princs);\n    }\n    if (upns != NULL) {\n        for (i = 0; upns[i] != NULL; i++)\n            krb5_free_principal(context, upns[i]);\n        free(upns);\n    }\n#ifdef DEBUG_SAN_INFO\n    if (client_string != NULL)\n        krb5_free_unparsed_name(context, client_string);\n#endif\n    pkiDebug(\"%s: returning retval %d, valid_san %d\\n\",\n             __FUNCTION__, retval, *valid_san);\n    return retval;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -21,14 +21,18 @@\n                                        &princs,\n                                        plgctx->opts->allow_upn ? &upns : NULL,\n                                        NULL);\n-    if (retval == ENOENT) {\n-        TRACE_PKINIT_SERVER_NO_SAN(context);\n-        goto out;\n-    } else if (retval) {\n+    if (retval) {\n         pkiDebug(\"%s: error from retrieve_certificate_sans()\\n\", __FUNCTION__);\n         retval = KRB5KDC_ERR_CLIENT_NAME_MISMATCH;\n         goto out;\n     }\n+\n+    if (princs == NULL && upns == NULL) {\n+        TRACE_PKINIT_SERVER_NO_SAN(context);\n+        retval = ENOENT;\n+        goto out;\n+    }\n+\n     /* XXX Verify this is consistent with client side XXX */\n #if 0\n     retval = call_san_checking_plugins(context, plgctx, reqctx, princs,",
        "diff_line_info": {
            "deleted_lines": [
                "    if (retval == ENOENT) {",
                "        TRACE_PKINIT_SERVER_NO_SAN(context);",
                "        goto out;",
                "    } else if (retval) {"
            ],
            "added_lines": [
                "    if (retval) {",
                "",
                "    if (princs == NULL && upns == NULL) {",
                "        TRACE_PKINIT_SERVER_NO_SAN(context);",
                "        retval = ENOENT;",
                "        goto out;",
                "    }",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2017-7562",
        "func_name": "krb5/pkinit_eku_authorize",
        "description": "An authentication bypass flaw was found in the way krb5's certauth interface before 1.16.1 handled the validation of client certificates. A remote attacker able to communicate with the KDC could potentially use this flaw to impersonate arbitrary principals under rare and erroneous circumstances.",
        "git_url": "https://github.com/krb5/krb5/commit/50fe4074f188c2d4da0c421e96553acea8378db2",
        "commit_title": "Fix certauth built-in module returns",
        "commit_text": " The PKINIT certauth eku module should never authoritatively authorize a certificate, because an extended key usage does not establish a relationship between the certificate and any specific user; it only establishes that the certificate was created for PKINIT client authentication.  Therefore, pkinit_eku_authorize() should return KRB5_PLUGIN_NO_HANDLE on success, not 0.  The certauth san module should pass if it does not find any SANs of the types it can match against; the presence of other types of SANs should not cause it to explicitly deny a certificate.  Check for an empty result from crypto_retrieve_cert_sans() in verify_client_san(), instead of returning ENOENT from crypto_retrieve_cert_sans() when there are no SANs at all.  ticket: 8561",
        "func_before": "static krb5_error_code\npkinit_eku_authorize(krb5_context context, krb5_certauth_moddata moddata,\n                     const uint8_t *cert, size_t cert_len,\n                     krb5_const_principal princ, const void *opts,\n                     const struct _krb5_db_entry_new *db_entry,\n                     char ***authinds_out)\n{\n    krb5_error_code ret;\n    int valid_eku;\n    const struct certauth_req_opts *req_opts = opts;\n\n    *authinds_out = NULL;\n\n    /* Verify the client EKU. */\n    ret = verify_client_eku(context, req_opts->plgctx, req_opts->reqctx,\n                            &valid_eku);\n    if (ret)\n        return ret;\n\n    if (!valid_eku) {\n        TRACE_PKINIT_SERVER_EKU_REJECT(context);\n        return KRB5KDC_ERR_INCONSISTENT_KEY_PURPOSE;\n    }\n\n    return 0;\n}",
        "func": "static krb5_error_code\npkinit_eku_authorize(krb5_context context, krb5_certauth_moddata moddata,\n                     const uint8_t *cert, size_t cert_len,\n                     krb5_const_principal princ, const void *opts,\n                     const struct _krb5_db_entry_new *db_entry,\n                     char ***authinds_out)\n{\n    krb5_error_code ret;\n    int valid_eku;\n    const struct certauth_req_opts *req_opts = opts;\n\n    *authinds_out = NULL;\n\n    /* Verify the client EKU. */\n    ret = verify_client_eku(context, req_opts->plgctx, req_opts->reqctx,\n                            &valid_eku);\n    if (ret)\n        return ret;\n\n    if (!valid_eku) {\n        TRACE_PKINIT_SERVER_EKU_REJECT(context);\n        return KRB5KDC_ERR_INCONSISTENT_KEY_PURPOSE;\n    }\n\n    return KRB5_PLUGIN_NO_HANDLE;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -22,5 +22,5 @@\n         return KRB5KDC_ERR_INCONSISTENT_KEY_PURPOSE;\n     }\n \n-    return 0;\n+    return KRB5_PLUGIN_NO_HANDLE;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    return 0;"
            ],
            "added_lines": [
                "    return KRB5_PLUGIN_NO_HANDLE;"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-30845",
        "func_name": "GoogleCloudPlatform/esp-v2/ServiceControlFilter::decodeHeaders",
        "description": "ESPv2 is a service proxy that provides API management capabilities using Google Service Infrastructure. ESPv2 2.20.0 through 2.42.0 contains an authentication bypass vulnerability. API clients can craft a malicious `X-HTTP-Method-Override` header value to bypass JWT authentication in specific cases.\n\nESPv2 allows malicious requests to bypass authentication if both the conditions are true: The requested HTTP method is **not** in the API service definition (OpenAPI spec or gRPC `google.api.http` proto annotations, and the specified `X-HTTP-Method-Override` is a valid HTTP method in the API service definition. ESPv2 will forward the request to your backend without checking the JWT. Attackers can craft requests with a malicious `X-HTTP-Method-Override` value that allows them to bypass specifying JWTs. Restricting API access with API keys works as intended and is not affected by this vulnerability.\n\nUpgrade deployments to release v2.43.0 or higher to receive a patch. This release ensures that JWT authentication occurs, even when the caller specifies `x-http-method-override`. `x-http-method-override` is still supported by v2.43.0+. API clients can continue sending this header to ESPv2.",
        "git_url": "https://github.com/GoogleCloudPlatform/esp-v2/commit/e98061ee4527a564506ba4e814c0ecf324dc2c6f",
        "commit_title": "Add back in HTTP method override in service control filter (#802)",
        "commit_text": " This is NOT used by ESPv2, but it is needed for CAG temporarily. We can remove once their rollout is complete.\r \r",
        "func_before": "Envoy::Http::FilterHeadersStatus ServiceControlFilter::decodeHeaders(\n    Envoy::Http::RequestHeaderMap& headers, bool) {\n  ENVOY_LOG(debug, \"Called ServiceControl Filter : {}\", __func__);\n\n  if (!headers.Method()) {\n    rejectRequest(Envoy::Http::Code::BadRequest,\n                  \"No method in request headers.\",\n                  utils::generateRcDetails(utils::kRcDetailFilterServiceControl,\n                                           utils::kRcDetailErrorTypeBadRequest,\n                                           utils::kRcDetailErrorMissingMethod));\n    return Envoy::Http::FilterHeadersStatus::StopIteration;\n  } else if (!headers.Path()) {\n    rejectRequest(Envoy::Http::Code::BadRequest, \"No path in request headers.\",\n                  utils::generateRcDetails(utils::kRcDetailFilterServiceControl,\n                                           utils::kRcDetailErrorTypeBadRequest,\n                                           utils::kRcDetailErrorMissingPath));\n    return Envoy::Http::FilterHeadersStatus::StopIteration;\n  }\n\n  // Make sure route is calculated\n  auto route = decoder_callbacks_->route();\n\n  // This shouldn't happen as the catch-all route match should catch all\n  // the undefined requests.\n  if (route == nullptr) {\n    return Envoy::Http::FilterHeadersStatus::Continue;\n  }\n\n  handler_ = factory_.createHandler(headers, decoder_callbacks_, stats_);\n  handler_->fillFilterState(*decoder_callbacks_->streamInfo().filterState());\n  state_ = Calling;\n  stopped_ = false;\n\n  Envoy::Tracing::Span& parent_span = decoder_callbacks_->activeSpan();\n\n  handler_->callCheck(headers, parent_span, *this);\n\n  // If success happens synchronously, continue now.\n  if (state_ == Complete) {\n    return Envoy::Http::FilterHeadersStatus::Continue;\n  }\n\n  // Stop for now. If an async request is made, it will continue in onCheckDone.\n  ENVOY_LOG(debug, \"Called ServiceControl filter : Stop\");\n  stopped_ = true;\n  return Envoy::Http::FilterHeadersStatus::StopIteration;\n}",
        "func": "Envoy::Http::FilterHeadersStatus ServiceControlFilter::decodeHeaders(\n    Envoy::Http::RequestHeaderMap& headers, bool) {\n  ENVOY_LOG(debug, \"Called ServiceControl Filter : {}\", __func__);\n\n  if (!headers.Method()) {\n    rejectRequest(Envoy::Http::Code::BadRequest,\n                  \"No method in request headers.\",\n                  utils::generateRcDetails(utils::kRcDetailFilterServiceControl,\n                                           utils::kRcDetailErrorTypeBadRequest,\n                                           utils::kRcDetailErrorMissingMethod));\n    return Envoy::Http::FilterHeadersStatus::StopIteration;\n  } else if (!headers.Path()) {\n    rejectRequest(Envoy::Http::Code::BadRequest, \"No path in request headers.\",\n                  utils::generateRcDetails(utils::kRcDetailFilterServiceControl,\n                                           utils::kRcDetailErrorTypeBadRequest,\n                                           utils::kRcDetailErrorMissingPath));\n    return Envoy::Http::FilterHeadersStatus::StopIteration;\n  }\n\n  // TODO(b/273531500): Temporary until CAG rollout is complete.\n  if (utils::handleHttpMethodOverride(headers)) {\n    // Update later filters that the HTTP method has changed by clearing the\n    // route cache.\n    ENVOY_LOG(debug, \"HTTP method override occurred, recalculating route\");\n    decoder_callbacks_->downstreamCallbacks()->clearRouteCache();\n  }\n\n  // Make sure route is calculated\n  auto route = decoder_callbacks_->route();\n\n  // This shouldn't happen as the catch-all route match should catch all\n  // the undefined requests.\n  if (route == nullptr) {\n    return Envoy::Http::FilterHeadersStatus::Continue;\n  }\n\n  handler_ = factory_.createHandler(headers, decoder_callbacks_, stats_);\n  handler_->fillFilterState(*decoder_callbacks_->streamInfo().filterState());\n  state_ = Calling;\n  stopped_ = false;\n\n  Envoy::Tracing::Span& parent_span = decoder_callbacks_->activeSpan();\n\n  handler_->callCheck(headers, parent_span, *this);\n\n  // If success happens synchronously, continue now.\n  if (state_ == Complete) {\n    return Envoy::Http::FilterHeadersStatus::Continue;\n  }\n\n  // Stop for now. If an async request is made, it will continue in onCheckDone.\n  ENVOY_LOG(debug, \"Called ServiceControl filter : Stop\");\n  stopped_ = true;\n  return Envoy::Http::FilterHeadersStatus::StopIteration;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -15,6 +15,14 @@\n                                            utils::kRcDetailErrorTypeBadRequest,\n                                            utils::kRcDetailErrorMissingPath));\n     return Envoy::Http::FilterHeadersStatus::StopIteration;\n+  }\n+\n+  // TODO(b/273531500): Temporary until CAG rollout is complete.\n+  if (utils::handleHttpMethodOverride(headers)) {\n+    // Update later filters that the HTTP method has changed by clearing the\n+    // route cache.\n+    ENVOY_LOG(debug, \"HTTP method override occurred, recalculating route\");\n+    decoder_callbacks_->downstreamCallbacks()->clearRouteCache();\n   }\n \n   // Make sure route is calculated",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "  }",
                "",
                "  // TODO(b/273531500): Temporary until CAG rollout is complete.",
                "  if (utils::handleHttpMethodOverride(headers)) {",
                "    // Update later filters that the HTTP method has changed by clearing the",
                "    // route cache.",
                "    ENVOY_LOG(debug, \"HTTP method override occurred, recalculating route\");",
                "    decoder_callbacks_->downstreamCallbacks()->clearRouteCache();"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-31127",
        "func_name": "DMTF/libspdm/libspdm_get_response_finish",
        "description": "libspdm is a sample implementation that follows the DMTF SPDM specifications. A vulnerability has been identified in SPDM session establishment in libspdm prior to version 2.3.1. If a device supports both DHE session and PSK session with mutual\nauthentication, the attacker may be able to establish the session with `KEY_EXCHANGE` and `PSK_FINISH` to bypass the mutual authentication. This is most likely to happen when the Requester begins a session using one method (DHE, for example) and then uses the other method's finish (PSK_FINISH in this example) to establish the session. The session hashes would be expected to fail in this case, but the condition was not detected.\n\nThis issue only impacts the SPDM responder, which supports `KEY_EX_CAP=1 and `PSK_CAP=10b` at same time with mutual authentication requirement. The SPDM requester is not impacted. The SPDM responder is not impacted if `KEY_EX_CAP=0` or `PSK_CAP=0` or `PSK_CAP=01b`. The SPDM responder is not impacted if mutual authentication is not required.\n\nlibspdm 1.0, 2.0, 2.1, 2.2, 2.3 are all impacted. Older branches are not maintained, but users of the 2.3 branch may receive a patch in version 2.3.2. The SPDM specification (DSP0274) does not contain this vulnerability.",
        "git_url": "https://github.com/DMTF/libspdm/commit/8426a309c1de246ac13012246e44b6249a43d081",
        "commit_title": "Add handshake mode switch check in FINISH and PSK_FINISH.",
        "commit_text": " Reference: DMTF-2023-0001  Fix: https://github.com/DMTF/libspdm/issues/2005 ",
        "func_before": "libspdm_return_t libspdm_get_response_finish(void *context, size_t request_size,\n                                             const void *request,\n                                             size_t *response_size,\n                                             void *response)\n{\n    uint32_t session_id;\n    bool result;\n    uint32_t hmac_size;\n    uint32_t signature_size;\n    uint8_t req_slot_id;\n    const spdm_finish_request_t *spdm_request;\n    spdm_finish_response_t *spdm_response;\n    libspdm_context_t *spdm_context;\n    libspdm_session_info_t *session_info;\n    uint8_t th2_hash_data[LIBSPDM_MAX_HASH_SIZE];\n    libspdm_return_t status;\n    libspdm_session_state_t session_state;\n\n    spdm_context = context;\n    spdm_request = request;\n\n    if (spdm_request->header.spdm_version != libspdm_get_connection_version(spdm_context)) {\n        return libspdm_generate_error_response(spdm_context,\n                                               SPDM_ERROR_CODE_VERSION_MISMATCH, 0,\n                                               response_size, response);\n    }\n    if (spdm_context->response_state != LIBSPDM_RESPONSE_STATE_NORMAL) {\n        return libspdm_responder_handle_response_state(\n            spdm_context,\n            spdm_request->header.request_response_code,\n            response_size, response);\n    }\n    if (!libspdm_is_capabilities_flag_supported(\n            spdm_context, false,\n            SPDM_GET_CAPABILITIES_REQUEST_FLAGS_KEY_EX_CAP,\n            SPDM_GET_CAPABILITIES_RESPONSE_FLAGS_KEY_EX_CAP)) {\n        return libspdm_generate_error_response(\n            spdm_context, SPDM_ERROR_CODE_UNSUPPORTED_REQUEST,\n            SPDM_KEY_EXCHANGE, response_size, response);\n    }\n    if (spdm_context->connection_info.connection_state < LIBSPDM_CONNECTION_STATE_NEGOTIATED) {\n        return libspdm_generate_error_response(spdm_context,\n                                               SPDM_ERROR_CODE_UNEXPECTED_REQUEST,\n                                               0, response_size, response);\n    }\n    if (!libspdm_is_capabilities_flag_supported(\n            spdm_context, false,\n            SPDM_GET_CAPABILITIES_REQUEST_FLAGS_HANDSHAKE_IN_THE_CLEAR_CAP,\n            SPDM_GET_CAPABILITIES_RESPONSE_FLAGS_HANDSHAKE_IN_THE_CLEAR_CAP)) {\n        /* No handshake in clear, then it must be in a session.*/\n        if (!spdm_context->last_spdm_request_session_id_valid) {\n            return libspdm_generate_error_response(\n                context, SPDM_ERROR_CODE_SESSION_REQUIRED, 0, response_size, response);\n        }\n    } else {\n        /* handshake in clear, then it must not be in a session.*/\n        if (spdm_context->last_spdm_request_session_id_valid) {\n            return libspdm_generate_error_response(\n                context, SPDM_ERROR_CODE_SESSION_REQUIRED, 0,\n                response_size, response);\n        }\n    }\n    if (spdm_context->last_spdm_request_session_id_valid) {\n        session_id = spdm_context->last_spdm_request_session_id;\n    } else {\n        session_id = spdm_context->latest_session_id;\n    }\n    session_info = libspdm_get_session_info_via_session_id(spdm_context, session_id);\n    if (session_info == NULL) {\n        return libspdm_generate_error_response(spdm_context,\n                                               SPDM_ERROR_CODE_SESSION_REQUIRED, 0,\n                                               response_size, response);\n    }\n    session_state = libspdm_secured_message_get_session_state(\n        session_info->secured_message_context);\n    if (session_state != LIBSPDM_SESSION_STATE_HANDSHAKING) {\n        return libspdm_generate_error_response(spdm_context,\n                                               SPDM_ERROR_CODE_UNEXPECTED_REQUEST, 0,\n                                               response_size, response);\n    }\n\n    if (((session_info->mut_auth_requested == 0) &&\n         (spdm_request->header.param1 != 0)) ||\n        ((session_info->mut_auth_requested != 0) &&\n         (spdm_request->header.param1 == 0))) {\n        return libspdm_generate_error_response(spdm_context,\n                                               SPDM_ERROR_CODE_INVALID_REQUEST, 0,\n                                               response_size, response);\n    }\n\n    hmac_size = libspdm_get_hash_size(spdm_context->connection_info.algorithm.base_hash_algo);\n    signature_size = 0;\n#if LIBSPDM_ENABLE_CAPABILITY_MUT_AUTH_CAP\n    if (session_info->mut_auth_requested) {\n        signature_size = libspdm_get_req_asym_signature_size(\n            spdm_context->connection_info.algorithm.req_base_asym_alg);\n    }\n#endif\n\n    if (request_size !=\n        sizeof(spdm_finish_request_t) + signature_size + hmac_size) {\n        return libspdm_generate_error_response(spdm_context,\n                                               SPDM_ERROR_CODE_INVALID_REQUEST, 0,\n                                               response_size, response);\n    }\n\n    req_slot_id = spdm_request->header.param2;\n    if ((req_slot_id != 0xFF) &&\n        (req_slot_id >= SPDM_MAX_SLOT_COUNT)) {\n        return libspdm_generate_error_response(spdm_context,\n                                               SPDM_ERROR_CODE_INVALID_REQUEST, 0,\n                                               response_size, response);\n    }\n    if (req_slot_id == 0xFF) {\n        req_slot_id = spdm_context->encap_context.req_slot_id;\n    }\n    if (req_slot_id != spdm_context->encap_context.req_slot_id) {\n        return libspdm_generate_error_response(spdm_context,\n                                               SPDM_ERROR_CODE_INVALID_REQUEST, 0,\n                                               response_size, response);\n    }\n\n    libspdm_reset_message_buffer_via_request_code(spdm_context, session_info,\n                                                  spdm_request->header.request_response_code);\n\n    status = libspdm_append_message_f(spdm_context, session_info, false, request,\n                                      sizeof(spdm_finish_request_t));\n    if (LIBSPDM_STATUS_IS_ERROR(status)) {\n        return libspdm_generate_error_response(spdm_context,\n                                               SPDM_ERROR_CODE_UNSPECIFIED, 0,\n                                               response_size, response);\n    }\n#if LIBSPDM_ENABLE_CAPABILITY_MUT_AUTH_CAP\n    if (session_info->mut_auth_requested) {\n        result = libspdm_verify_finish_req_signature(\n            spdm_context, session_info,\n            (const uint8_t *)request + sizeof(spdm_finish_request_t), signature_size);\n        if (!result) {\n            if((spdm_context->handle_error_return_policy &\n                LIBSPDM_DATA_HANDLE_ERROR_RETURN_POLICY_DROP_ON_DECRYPT_ERROR) == 0) {\n                return libspdm_generate_error_response(\n                    spdm_context, SPDM_ERROR_CODE_DECRYPT_ERROR, 0,\n                    response_size, response);\n            } else {\n                /**\n                 * just ignore this message\n                 * return UNSUPPORTED and clear response_size to continue the dispatch without send response.\n                 **/\n                *response_size = 0;\n                return LIBSPDM_STATUS_UNSUPPORTED_CAP;\n            }\n        }\n        status = libspdm_append_message_f(\n            spdm_context, session_info, false,\n            (const uint8_t *)request + sizeof(spdm_finish_request_t),\n            signature_size);\n        if (LIBSPDM_STATUS_IS_ERROR(status)) {\n            return libspdm_generate_error_response(\n                spdm_context, SPDM_ERROR_CODE_UNSPECIFIED,\n                0, response_size, response);\n        }\n    }\n#endif\n\n    result = libspdm_verify_finish_req_hmac(\n        spdm_context, session_info, (const uint8_t *)request + signature_size +\n        sizeof(spdm_finish_request_t), hmac_size);\n    if (!result) {\n        if((spdm_context->handle_error_return_policy &\n            LIBSPDM_DATA_HANDLE_ERROR_RETURN_POLICY_DROP_ON_DECRYPT_ERROR) == 0) {\n            return libspdm_generate_error_response(\n                spdm_context, SPDM_ERROR_CODE_DECRYPT_ERROR, 0,\n                response_size, response);\n        } else {\n            /**\n             * just ignore this message\n             * return UNSUPPORTED and clear response_size to continue the dispatch without send response\n             **/\n            *response_size = 0;\n            return LIBSPDM_STATUS_UNSUPPORTED_CAP;\n        }\n    }\n\n    status = libspdm_append_message_f(spdm_context, session_info, false,\n                                      (const uint8_t *)request + signature_size +\n                                      sizeof(spdm_finish_request_t),\n                                      hmac_size);\n    if (LIBSPDM_STATUS_IS_ERROR(status)) {\n        return libspdm_generate_error_response(spdm_context,\n                                               SPDM_ERROR_CODE_UNSPECIFIED, 0,\n                                               response_size, response);\n    }\n\n    if (!libspdm_is_capabilities_flag_supported(\n            spdm_context, false,\n            SPDM_GET_CAPABILITIES_REQUEST_FLAGS_HANDSHAKE_IN_THE_CLEAR_CAP,\n            SPDM_GET_CAPABILITIES_RESPONSE_FLAGS_HANDSHAKE_IN_THE_CLEAR_CAP)) {\n        hmac_size = 0;\n    }\n\n    LIBSPDM_ASSERT(*response_size >= sizeof(spdm_finish_response_t) + hmac_size);\n    *response_size = sizeof(spdm_finish_response_t) + hmac_size;\n    libspdm_zero_mem(response, *response_size);\n    spdm_response = response;\n\n    spdm_response->header.spdm_version = spdm_request->header.spdm_version;\n    spdm_response->header.request_response_code = SPDM_FINISH_RSP;\n    spdm_response->header.param1 = 0;\n    spdm_response->header.param2 = 0;\n\n    status = libspdm_append_message_f(spdm_context, session_info, false, spdm_response,\n                                      sizeof(spdm_finish_response_t));\n    if (LIBSPDM_STATUS_IS_ERROR(status)) {\n        return libspdm_generate_error_response(spdm_context,\n                                               SPDM_ERROR_CODE_UNSPECIFIED, 0,\n                                               response_size, response);\n    }\n\n    if (libspdm_is_capabilities_flag_supported(\n            spdm_context, false,\n            SPDM_GET_CAPABILITIES_REQUEST_FLAGS_HANDSHAKE_IN_THE_CLEAR_CAP,\n            SPDM_GET_CAPABILITIES_RESPONSE_FLAGS_HANDSHAKE_IN_THE_CLEAR_CAP)) {\n        result = libspdm_generate_finish_rsp_hmac(\n            spdm_context, session_info,\n            (uint8_t *)spdm_response + sizeof(spdm_finish_request_t));\n        if (!result) {\n            return libspdm_generate_error_response(\n                spdm_context,\n                SPDM_ERROR_CODE_UNSPECIFIED,\n                0, response_size, response);\n        }\n\n        status = libspdm_append_message_f(\n            spdm_context, session_info, false,\n            (uint8_t *)spdm_response + sizeof(spdm_finish_request_t),\n            hmac_size);\n        if (LIBSPDM_STATUS_IS_ERROR(status)) {\n            return libspdm_generate_error_response(\n                spdm_context, SPDM_ERROR_CODE_UNSPECIFIED,\n                0, response_size, response);\n        }\n    }\n\n    LIBSPDM_DEBUG((LIBSPDM_DEBUG_INFO, \"libspdm_generate_session_data_key[%x]\\n\", session_id));\n    result = libspdm_calculate_th2_hash(spdm_context, session_info, false, th2_hash_data);\n    if (!result) {\n        return libspdm_generate_error_response(spdm_context,\n                                               SPDM_ERROR_CODE_UNSPECIFIED, 0,\n                                               response_size, response);\n    }\n    result = libspdm_generate_session_data_key(\n        session_info->secured_message_context, th2_hash_data);\n    if (!result) {\n        return libspdm_generate_error_response(spdm_context,\n                                               SPDM_ERROR_CODE_UNSPECIFIED, 0,\n                                               response_size, response);\n    }\n\n    #if LIBSPDM_ENABLE_CAPABILITY_HBEAT_CAP\n    if (libspdm_is_capabilities_flag_supported(\n            spdm_context, false,\n            SPDM_GET_CAPABILITIES_REQUEST_FLAGS_HBEAT_CAP,\n            SPDM_GET_CAPABILITIES_RESPONSE_FLAGS_HBEAT_CAP)) {\n        result = libspdm_start_watchdog(\n            session_id, spdm_context->local_context.heartbeat_period * 2);\n        if (!result) {\n            return libspdm_generate_error_response(spdm_context,\n                                                   SPDM_ERROR_CODE_UNSPECIFIED, 0,\n                                                   response_size, response);\n        }\n    }\n    #endif /* LIBSPDM_ENABLE_CAPABILITY_HBEAT_CAP */\n\n    return LIBSPDM_STATUS_SUCCESS;\n}",
        "func": "libspdm_return_t libspdm_get_response_finish(void *context, size_t request_size,\n                                             const void *request,\n                                             size_t *response_size,\n                                             void *response)\n{\n    uint32_t session_id;\n    bool result;\n    uint32_t hmac_size;\n    uint32_t signature_size;\n    uint8_t req_slot_id;\n    const spdm_finish_request_t *spdm_request;\n    spdm_finish_response_t *spdm_response;\n    libspdm_context_t *spdm_context;\n    libspdm_session_info_t *session_info;\n    uint8_t th2_hash_data[LIBSPDM_MAX_HASH_SIZE];\n    libspdm_return_t status;\n    libspdm_session_state_t session_state;\n\n    spdm_context = context;\n    spdm_request = request;\n\n    if (spdm_request->header.spdm_version != libspdm_get_connection_version(spdm_context)) {\n        return libspdm_generate_error_response(spdm_context,\n                                               SPDM_ERROR_CODE_VERSION_MISMATCH, 0,\n                                               response_size, response);\n    }\n    if (spdm_context->response_state != LIBSPDM_RESPONSE_STATE_NORMAL) {\n        return libspdm_responder_handle_response_state(\n            spdm_context,\n            spdm_request->header.request_response_code,\n            response_size, response);\n    }\n    if (!libspdm_is_capabilities_flag_supported(\n            spdm_context, false,\n            SPDM_GET_CAPABILITIES_REQUEST_FLAGS_KEY_EX_CAP,\n            SPDM_GET_CAPABILITIES_RESPONSE_FLAGS_KEY_EX_CAP)) {\n        return libspdm_generate_error_response(\n            spdm_context, SPDM_ERROR_CODE_UNSUPPORTED_REQUEST,\n            SPDM_KEY_EXCHANGE, response_size, response);\n    }\n    if (spdm_context->connection_info.connection_state < LIBSPDM_CONNECTION_STATE_NEGOTIATED) {\n        return libspdm_generate_error_response(spdm_context,\n                                               SPDM_ERROR_CODE_UNEXPECTED_REQUEST,\n                                               0, response_size, response);\n    }\n    if (!libspdm_is_capabilities_flag_supported(\n            spdm_context, false,\n            SPDM_GET_CAPABILITIES_REQUEST_FLAGS_HANDSHAKE_IN_THE_CLEAR_CAP,\n            SPDM_GET_CAPABILITIES_RESPONSE_FLAGS_HANDSHAKE_IN_THE_CLEAR_CAP)) {\n        /* No handshake in clear, then it must be in a session.*/\n        if (!spdm_context->last_spdm_request_session_id_valid) {\n            return libspdm_generate_error_response(\n                context, SPDM_ERROR_CODE_SESSION_REQUIRED, 0, response_size, response);\n        }\n    } else {\n        /* handshake in clear, then it must not be in a session.*/\n        if (spdm_context->last_spdm_request_session_id_valid) {\n            return libspdm_generate_error_response(\n                context, SPDM_ERROR_CODE_SESSION_REQUIRED, 0,\n                response_size, response);\n        }\n    }\n    if (spdm_context->last_spdm_request_session_id_valid) {\n        session_id = spdm_context->last_spdm_request_session_id;\n    } else {\n        session_id = spdm_context->latest_session_id;\n    }\n    session_info = libspdm_get_session_info_via_session_id(spdm_context, session_id);\n    if (session_info == NULL) {\n        return libspdm_generate_error_response(spdm_context,\n                                               SPDM_ERROR_CODE_SESSION_REQUIRED, 0,\n                                               response_size, response);\n    }\n    if (session_info->use_psk) {\n        return libspdm_generate_error_response(spdm_context,\n                                               SPDM_ERROR_CODE_UNEXPECTED_REQUEST, 0,\n                                               response_size, response);\n    }\n    session_state = libspdm_secured_message_get_session_state(\n        session_info->secured_message_context);\n    if (session_state != LIBSPDM_SESSION_STATE_HANDSHAKING) {\n        return libspdm_generate_error_response(spdm_context,\n                                               SPDM_ERROR_CODE_UNEXPECTED_REQUEST, 0,\n                                               response_size, response);\n    }\n\n    if (((session_info->mut_auth_requested == 0) &&\n         (spdm_request->header.param1 != 0)) ||\n        ((session_info->mut_auth_requested != 0) &&\n         (spdm_request->header.param1 == 0))) {\n        return libspdm_generate_error_response(spdm_context,\n                                               SPDM_ERROR_CODE_INVALID_REQUEST, 0,\n                                               response_size, response);\n    }\n\n    hmac_size = libspdm_get_hash_size(spdm_context->connection_info.algorithm.base_hash_algo);\n    signature_size = 0;\n#if LIBSPDM_ENABLE_CAPABILITY_MUT_AUTH_CAP\n    if (session_info->mut_auth_requested) {\n        signature_size = libspdm_get_req_asym_signature_size(\n            spdm_context->connection_info.algorithm.req_base_asym_alg);\n    }\n#endif\n\n    if (request_size !=\n        sizeof(spdm_finish_request_t) + signature_size + hmac_size) {\n        return libspdm_generate_error_response(spdm_context,\n                                               SPDM_ERROR_CODE_INVALID_REQUEST, 0,\n                                               response_size, response);\n    }\n\n    req_slot_id = spdm_request->header.param2;\n    if ((req_slot_id != 0xFF) &&\n        (req_slot_id >= SPDM_MAX_SLOT_COUNT)) {\n        return libspdm_generate_error_response(spdm_context,\n                                               SPDM_ERROR_CODE_INVALID_REQUEST, 0,\n                                               response_size, response);\n    }\n    if (req_slot_id == 0xFF) {\n        req_slot_id = spdm_context->encap_context.req_slot_id;\n    }\n    if (req_slot_id != spdm_context->encap_context.req_slot_id) {\n        return libspdm_generate_error_response(spdm_context,\n                                               SPDM_ERROR_CODE_INVALID_REQUEST, 0,\n                                               response_size, response);\n    }\n\n    libspdm_reset_message_buffer_via_request_code(spdm_context, session_info,\n                                                  spdm_request->header.request_response_code);\n\n    status = libspdm_append_message_f(spdm_context, session_info, false, request,\n                                      sizeof(spdm_finish_request_t));\n    if (LIBSPDM_STATUS_IS_ERROR(status)) {\n        return libspdm_generate_error_response(spdm_context,\n                                               SPDM_ERROR_CODE_UNSPECIFIED, 0,\n                                               response_size, response);\n    }\n#if LIBSPDM_ENABLE_CAPABILITY_MUT_AUTH_CAP\n    if (session_info->mut_auth_requested) {\n        result = libspdm_verify_finish_req_signature(\n            spdm_context, session_info,\n            (const uint8_t *)request + sizeof(spdm_finish_request_t), signature_size);\n        if (!result) {\n            if((spdm_context->handle_error_return_policy &\n                LIBSPDM_DATA_HANDLE_ERROR_RETURN_POLICY_DROP_ON_DECRYPT_ERROR) == 0) {\n                return libspdm_generate_error_response(\n                    spdm_context, SPDM_ERROR_CODE_DECRYPT_ERROR, 0,\n                    response_size, response);\n            } else {\n                /**\n                 * just ignore this message\n                 * return UNSUPPORTED and clear response_size to continue the dispatch without send response.\n                 **/\n                *response_size = 0;\n                return LIBSPDM_STATUS_UNSUPPORTED_CAP;\n            }\n        }\n        status = libspdm_append_message_f(\n            spdm_context, session_info, false,\n            (const uint8_t *)request + sizeof(spdm_finish_request_t),\n            signature_size);\n        if (LIBSPDM_STATUS_IS_ERROR(status)) {\n            return libspdm_generate_error_response(\n                spdm_context, SPDM_ERROR_CODE_UNSPECIFIED,\n                0, response_size, response);\n        }\n    }\n#endif\n\n    result = libspdm_verify_finish_req_hmac(\n        spdm_context, session_info, (const uint8_t *)request + signature_size +\n        sizeof(spdm_finish_request_t), hmac_size);\n    if (!result) {\n        if((spdm_context->handle_error_return_policy &\n            LIBSPDM_DATA_HANDLE_ERROR_RETURN_POLICY_DROP_ON_DECRYPT_ERROR) == 0) {\n            return libspdm_generate_error_response(\n                spdm_context, SPDM_ERROR_CODE_DECRYPT_ERROR, 0,\n                response_size, response);\n        } else {\n            /**\n             * just ignore this message\n             * return UNSUPPORTED and clear response_size to continue the dispatch without send response\n             **/\n            *response_size = 0;\n            return LIBSPDM_STATUS_UNSUPPORTED_CAP;\n        }\n    }\n\n    status = libspdm_append_message_f(spdm_context, session_info, false,\n                                      (const uint8_t *)request + signature_size +\n                                      sizeof(spdm_finish_request_t),\n                                      hmac_size);\n    if (LIBSPDM_STATUS_IS_ERROR(status)) {\n        return libspdm_generate_error_response(spdm_context,\n                                               SPDM_ERROR_CODE_UNSPECIFIED, 0,\n                                               response_size, response);\n    }\n\n    if (!libspdm_is_capabilities_flag_supported(\n            spdm_context, false,\n            SPDM_GET_CAPABILITIES_REQUEST_FLAGS_HANDSHAKE_IN_THE_CLEAR_CAP,\n            SPDM_GET_CAPABILITIES_RESPONSE_FLAGS_HANDSHAKE_IN_THE_CLEAR_CAP)) {\n        hmac_size = 0;\n    }\n\n    LIBSPDM_ASSERT(*response_size >= sizeof(spdm_finish_response_t) + hmac_size);\n    *response_size = sizeof(spdm_finish_response_t) + hmac_size;\n    libspdm_zero_mem(response, *response_size);\n    spdm_response = response;\n\n    spdm_response->header.spdm_version = spdm_request->header.spdm_version;\n    spdm_response->header.request_response_code = SPDM_FINISH_RSP;\n    spdm_response->header.param1 = 0;\n    spdm_response->header.param2 = 0;\n\n    status = libspdm_append_message_f(spdm_context, session_info, false, spdm_response,\n                                      sizeof(spdm_finish_response_t));\n    if (LIBSPDM_STATUS_IS_ERROR(status)) {\n        return libspdm_generate_error_response(spdm_context,\n                                               SPDM_ERROR_CODE_UNSPECIFIED, 0,\n                                               response_size, response);\n    }\n\n    if (libspdm_is_capabilities_flag_supported(\n            spdm_context, false,\n            SPDM_GET_CAPABILITIES_REQUEST_FLAGS_HANDSHAKE_IN_THE_CLEAR_CAP,\n            SPDM_GET_CAPABILITIES_RESPONSE_FLAGS_HANDSHAKE_IN_THE_CLEAR_CAP)) {\n        result = libspdm_generate_finish_rsp_hmac(\n            spdm_context, session_info,\n            (uint8_t *)spdm_response + sizeof(spdm_finish_request_t));\n        if (!result) {\n            return libspdm_generate_error_response(\n                spdm_context,\n                SPDM_ERROR_CODE_UNSPECIFIED,\n                0, response_size, response);\n        }\n\n        status = libspdm_append_message_f(\n            spdm_context, session_info, false,\n            (uint8_t *)spdm_response + sizeof(spdm_finish_request_t),\n            hmac_size);\n        if (LIBSPDM_STATUS_IS_ERROR(status)) {\n            return libspdm_generate_error_response(\n                spdm_context, SPDM_ERROR_CODE_UNSPECIFIED,\n                0, response_size, response);\n        }\n    }\n\n    LIBSPDM_DEBUG((LIBSPDM_DEBUG_INFO, \"libspdm_generate_session_data_key[%x]\\n\", session_id));\n    result = libspdm_calculate_th2_hash(spdm_context, session_info, false, th2_hash_data);\n    if (!result) {\n        return libspdm_generate_error_response(spdm_context,\n                                               SPDM_ERROR_CODE_UNSPECIFIED, 0,\n                                               response_size, response);\n    }\n    result = libspdm_generate_session_data_key(\n        session_info->secured_message_context, th2_hash_data);\n    if (!result) {\n        return libspdm_generate_error_response(spdm_context,\n                                               SPDM_ERROR_CODE_UNSPECIFIED, 0,\n                                               response_size, response);\n    }\n\n    #if LIBSPDM_ENABLE_CAPABILITY_HBEAT_CAP\n    if (libspdm_is_capabilities_flag_supported(\n            spdm_context, false,\n            SPDM_GET_CAPABILITIES_REQUEST_FLAGS_HBEAT_CAP,\n            SPDM_GET_CAPABILITIES_RESPONSE_FLAGS_HBEAT_CAP)) {\n        result = libspdm_start_watchdog(\n            session_id, spdm_context->local_context.heartbeat_period * 2);\n        if (!result) {\n            return libspdm_generate_error_response(spdm_context,\n                                                   SPDM_ERROR_CODE_UNSPECIFIED, 0,\n                                                   response_size, response);\n        }\n    }\n    #endif /* LIBSPDM_ENABLE_CAPABILITY_HBEAT_CAP */\n\n    return LIBSPDM_STATUS_SUCCESS;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -69,6 +69,11 @@\n     if (session_info == NULL) {\n         return libspdm_generate_error_response(spdm_context,\n                                                SPDM_ERROR_CODE_SESSION_REQUIRED, 0,\n+                                               response_size, response);\n+    }\n+    if (session_info->use_psk) {\n+        return libspdm_generate_error_response(spdm_context,\n+                                               SPDM_ERROR_CODE_UNEXPECTED_REQUEST, 0,\n                                                response_size, response);\n     }\n     session_state = libspdm_secured_message_get_session_state(",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "                                               response_size, response);",
                "    }",
                "    if (session_info->use_psk) {",
                "        return libspdm_generate_error_response(spdm_context,",
                "                                               SPDM_ERROR_CODE_UNEXPECTED_REQUEST, 0,"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-31127",
        "func_name": "DMTF/libspdm/libspdm_get_response_psk_finish",
        "description": "libspdm is a sample implementation that follows the DMTF SPDM specifications. A vulnerability has been identified in SPDM session establishment in libspdm prior to version 2.3.1. If a device supports both DHE session and PSK session with mutual\nauthentication, the attacker may be able to establish the session with `KEY_EXCHANGE` and `PSK_FINISH` to bypass the mutual authentication. This is most likely to happen when the Requester begins a session using one method (DHE, for example) and then uses the other method's finish (PSK_FINISH in this example) to establish the session. The session hashes would be expected to fail in this case, but the condition was not detected.\n\nThis issue only impacts the SPDM responder, which supports `KEY_EX_CAP=1 and `PSK_CAP=10b` at same time with mutual authentication requirement. The SPDM requester is not impacted. The SPDM responder is not impacted if `KEY_EX_CAP=0` or `PSK_CAP=0` or `PSK_CAP=01b`. The SPDM responder is not impacted if mutual authentication is not required.\n\nlibspdm 1.0, 2.0, 2.1, 2.2, 2.3 are all impacted. Older branches are not maintained, but users of the 2.3 branch may receive a patch in version 2.3.2. The SPDM specification (DSP0274) does not contain this vulnerability.",
        "git_url": "https://github.com/DMTF/libspdm/commit/8426a309c1de246ac13012246e44b6249a43d081",
        "commit_title": "Add handshake mode switch check in FINISH and PSK_FINISH.",
        "commit_text": " Reference: DMTF-2023-0001  Fix: https://github.com/DMTF/libspdm/issues/2005 ",
        "func_before": "libspdm_return_t libspdm_get_response_psk_finish(void *context,\n                                                 size_t request_size,\n                                                 const void *request,\n                                                 size_t *response_size,\n                                                 void *response)\n{\n    uint32_t session_id;\n    bool result;\n    uint32_t hmac_size;\n    spdm_psk_finish_response_t *spdm_response;\n    libspdm_context_t *spdm_context;\n    libspdm_session_info_t *session_info;\n    uint8_t th2_hash_data[LIBSPDM_MAX_HASH_SIZE];\n    const spdm_psk_finish_request_t *spdm_request;\n    libspdm_return_t status;\n    libspdm_session_state_t session_state;\n\n    spdm_context = context;\n    spdm_request = request;\n\n    if (spdm_request->header.spdm_version != libspdm_get_connection_version(spdm_context)) {\n        return libspdm_generate_error_response(spdm_context,\n                                               SPDM_ERROR_CODE_VERSION_MISMATCH, 0,\n                                               response_size, response);\n    }\n    if (spdm_context->response_state != LIBSPDM_RESPONSE_STATE_NORMAL) {\n        return libspdm_responder_handle_response_state(\n            spdm_context,\n            spdm_request->header.request_response_code,\n            response_size, response);\n    }\n    if (!libspdm_is_capabilities_flag_supported(\n            spdm_context, false,\n            SPDM_GET_CAPABILITIES_REQUEST_FLAGS_PSK_CAP,\n            SPDM_GET_CAPABILITIES_RESPONSE_FLAGS_PSK_CAP_RESPONDER_WITH_CONTEXT)) {\n        return libspdm_generate_error_response(\n            spdm_context, SPDM_ERROR_CODE_UNSUPPORTED_REQUEST,\n            SPDM_PSK_EXCHANGE, response_size, response);\n    }\n    if (spdm_context->connection_info.connection_state < LIBSPDM_CONNECTION_STATE_NEGOTIATED) {\n        return libspdm_generate_error_response(spdm_context,\n                                               SPDM_ERROR_CODE_UNEXPECTED_REQUEST,\n                                               0, response_size, response);\n    }\n\n    if (!spdm_context->last_spdm_request_session_id_valid) {\n        return libspdm_generate_error_response(context,\n                                               SPDM_ERROR_CODE_SESSION_REQUIRED, 0,\n                                               response_size, response);\n    }\n    session_id = spdm_context->last_spdm_request_session_id;\n    session_info =\n        libspdm_get_session_info_via_session_id(spdm_context, session_id);\n    if (session_info == NULL) {\n        return libspdm_generate_error_response(spdm_context,\n                                               SPDM_ERROR_CODE_SESSION_REQUIRED, 0,\n                                               response_size, response);\n    }\n    session_state = libspdm_secured_message_get_session_state(\n        session_info->secured_message_context);\n    if (session_state != LIBSPDM_SESSION_STATE_HANDSHAKING) {\n        return libspdm_generate_error_response(spdm_context,\n                                               SPDM_ERROR_CODE_UNEXPECTED_REQUEST, 0,\n                                               response_size, response);\n    }\n\n    /* remove HMAC*/\n    hmac_size = libspdm_get_hash_size(\n        spdm_context->connection_info.algorithm.base_hash_algo);\n\n    if (request_size != sizeof(spdm_psk_finish_request_t) + hmac_size) {\n        return libspdm_generate_error_response(spdm_context,\n                                               SPDM_ERROR_CODE_INVALID_REQUEST, 0,\n                                               response_size, response);\n    }\n\n    libspdm_reset_message_buffer_via_request_code(spdm_context, session_info,\n                                                  spdm_request->header.request_response_code);\n\n    status = libspdm_append_message_f(spdm_context, session_info, false, request,\n                                      request_size - hmac_size);\n    if (LIBSPDM_STATUS_IS_ERROR(status)) {\n        return libspdm_generate_error_response(spdm_context,\n                                               SPDM_ERROR_CODE_UNSPECIFIED, 0,\n                                               response_size, response);\n    }\n\n    LIBSPDM_ASSERT(*response_size >= sizeof(spdm_psk_finish_response_t));\n    *response_size = sizeof(spdm_psk_finish_response_t);\n    libspdm_zero_mem(response, *response_size);\n    spdm_response = response;\n\n    spdm_response->header.spdm_version = spdm_request->header.spdm_version;\n    spdm_response->header.request_response_code = SPDM_PSK_FINISH_RSP;\n    spdm_response->header.param1 = 0;\n    spdm_response->header.param2 = 0;\n\n    result = libspdm_verify_psk_finish_req_hmac(\n        spdm_context, session_info,\n        (const uint8_t *)request + sizeof(spdm_psk_finish_request_t),\n        hmac_size);\n    if (!result) {\n        if((spdm_context->handle_error_return_policy &\n            LIBSPDM_DATA_HANDLE_ERROR_RETURN_POLICY_DROP_ON_DECRYPT_ERROR) == 0) {\n            return libspdm_generate_error_response(\n                spdm_context, SPDM_ERROR_CODE_DECRYPT_ERROR, 0,\n                response_size, response);\n        } else {\n            /**\n             * just ignore this message\n             * return UNSUPPORTED and clear response_size to continue the dispatch without send response\n             **/\n            *response_size = 0;\n            return LIBSPDM_STATUS_UNSUPPORTED_CAP;\n        }\n    }\n    status = libspdm_append_message_f(\n        spdm_context, session_info, false,\n        (const uint8_t *)request + request_size - hmac_size,\n        hmac_size);\n    if (LIBSPDM_STATUS_IS_ERROR(status)) {\n        return libspdm_generate_error_response(spdm_context,\n                                               SPDM_ERROR_CODE_UNSPECIFIED, 0,\n                                               response_size, response);\n    }\n\n    status = libspdm_append_message_f(spdm_context, session_info, false, spdm_response,\n                                      *response_size);\n    if (LIBSPDM_STATUS_IS_ERROR(status)) {\n        return libspdm_generate_error_response(spdm_context,\n                                               SPDM_ERROR_CODE_UNSPECIFIED, 0,\n                                               response_size, response);\n    }\n\n    LIBSPDM_DEBUG((LIBSPDM_DEBUG_INFO, \"libspdm_generate_session_data_key[%x]\\n\", session_id));\n    result = libspdm_calculate_th2_hash(spdm_context, session_info, false,\n                                        th2_hash_data);\n    if (!result) {\n        return libspdm_generate_error_response(spdm_context,\n                                               SPDM_ERROR_CODE_UNSPECIFIED, 0,\n                                               response_size, response);\n    }\n    result = libspdm_generate_session_data_key(\n        session_info->secured_message_context, th2_hash_data);\n    if (!result) {\n        return libspdm_generate_error_response(spdm_context,\n                                               SPDM_ERROR_CODE_UNSPECIFIED, 0,\n                                               response_size, response);\n    }\n\n    #if LIBSPDM_ENABLE_CAPABILITY_HBEAT_CAP\n    if (libspdm_is_capabilities_flag_supported(\n            spdm_context, false,\n            SPDM_GET_CAPABILITIES_REQUEST_FLAGS_HBEAT_CAP,\n            SPDM_GET_CAPABILITIES_RESPONSE_FLAGS_HBEAT_CAP)) {\n        result = libspdm_start_watchdog(\n            session_id, spdm_context->local_context.heartbeat_period * 2);\n        if (!result) {\n            return libspdm_generate_error_response(spdm_context,\n                                                   SPDM_ERROR_CODE_UNSPECIFIED, 0,\n                                                   response_size, response);\n        }\n    }\n    #endif /* LIBSPDM_ENABLE_CAPABILITY_HBEAT_CAP */\n\n    return LIBSPDM_STATUS_SUCCESS;\n}",
        "func": "libspdm_return_t libspdm_get_response_psk_finish(void *context,\n                                                 size_t request_size,\n                                                 const void *request,\n                                                 size_t *response_size,\n                                                 void *response)\n{\n    uint32_t session_id;\n    bool result;\n    uint32_t hmac_size;\n    spdm_psk_finish_response_t *spdm_response;\n    libspdm_context_t *spdm_context;\n    libspdm_session_info_t *session_info;\n    uint8_t th2_hash_data[LIBSPDM_MAX_HASH_SIZE];\n    const spdm_psk_finish_request_t *spdm_request;\n    libspdm_return_t status;\n    libspdm_session_state_t session_state;\n\n    spdm_context = context;\n    spdm_request = request;\n\n    if (spdm_request->header.spdm_version != libspdm_get_connection_version(spdm_context)) {\n        return libspdm_generate_error_response(spdm_context,\n                                               SPDM_ERROR_CODE_VERSION_MISMATCH, 0,\n                                               response_size, response);\n    }\n    if (spdm_context->response_state != LIBSPDM_RESPONSE_STATE_NORMAL) {\n        return libspdm_responder_handle_response_state(\n            spdm_context,\n            spdm_request->header.request_response_code,\n            response_size, response);\n    }\n    if (!libspdm_is_capabilities_flag_supported(\n            spdm_context, false,\n            SPDM_GET_CAPABILITIES_REQUEST_FLAGS_PSK_CAP,\n            SPDM_GET_CAPABILITIES_RESPONSE_FLAGS_PSK_CAP_RESPONDER_WITH_CONTEXT)) {\n        return libspdm_generate_error_response(\n            spdm_context, SPDM_ERROR_CODE_UNSUPPORTED_REQUEST,\n            SPDM_PSK_EXCHANGE, response_size, response);\n    }\n    if (spdm_context->connection_info.connection_state < LIBSPDM_CONNECTION_STATE_NEGOTIATED) {\n        return libspdm_generate_error_response(spdm_context,\n                                               SPDM_ERROR_CODE_UNEXPECTED_REQUEST,\n                                               0, response_size, response);\n    }\n\n    if (!spdm_context->last_spdm_request_session_id_valid) {\n        return libspdm_generate_error_response(context,\n                                               SPDM_ERROR_CODE_SESSION_REQUIRED, 0,\n                                               response_size, response);\n    }\n    session_id = spdm_context->last_spdm_request_session_id;\n    session_info =\n        libspdm_get_session_info_via_session_id(spdm_context, session_id);\n    if (session_info == NULL) {\n        return libspdm_generate_error_response(spdm_context,\n                                               SPDM_ERROR_CODE_SESSION_REQUIRED, 0,\n                                               response_size, response);\n    }\n    if (!session_info->use_psk) {\n        return libspdm_generate_error_response(spdm_context,\n                                               SPDM_ERROR_CODE_UNEXPECTED_REQUEST, 0,\n                                               response_size, response);\n    }\n    session_state = libspdm_secured_message_get_session_state(\n        session_info->secured_message_context);\n    if (session_state != LIBSPDM_SESSION_STATE_HANDSHAKING) {\n        return libspdm_generate_error_response(spdm_context,\n                                               SPDM_ERROR_CODE_UNEXPECTED_REQUEST, 0,\n                                               response_size, response);\n    }\n\n    /* remove HMAC*/\n    hmac_size = libspdm_get_hash_size(\n        spdm_context->connection_info.algorithm.base_hash_algo);\n\n    if (request_size != sizeof(spdm_psk_finish_request_t) + hmac_size) {\n        return libspdm_generate_error_response(spdm_context,\n                                               SPDM_ERROR_CODE_INVALID_REQUEST, 0,\n                                               response_size, response);\n    }\n\n    libspdm_reset_message_buffer_via_request_code(spdm_context, session_info,\n                                                  spdm_request->header.request_response_code);\n\n    status = libspdm_append_message_f(spdm_context, session_info, false, request,\n                                      request_size - hmac_size);\n    if (LIBSPDM_STATUS_IS_ERROR(status)) {\n        return libspdm_generate_error_response(spdm_context,\n                                               SPDM_ERROR_CODE_UNSPECIFIED, 0,\n                                               response_size, response);\n    }\n\n    LIBSPDM_ASSERT(*response_size >= sizeof(spdm_psk_finish_response_t));\n    *response_size = sizeof(spdm_psk_finish_response_t);\n    libspdm_zero_mem(response, *response_size);\n    spdm_response = response;\n\n    spdm_response->header.spdm_version = spdm_request->header.spdm_version;\n    spdm_response->header.request_response_code = SPDM_PSK_FINISH_RSP;\n    spdm_response->header.param1 = 0;\n    spdm_response->header.param2 = 0;\n\n    result = libspdm_verify_psk_finish_req_hmac(\n        spdm_context, session_info,\n        (const uint8_t *)request + sizeof(spdm_psk_finish_request_t),\n        hmac_size);\n    if (!result) {\n        if((spdm_context->handle_error_return_policy &\n            LIBSPDM_DATA_HANDLE_ERROR_RETURN_POLICY_DROP_ON_DECRYPT_ERROR) == 0) {\n            return libspdm_generate_error_response(\n                spdm_context, SPDM_ERROR_CODE_DECRYPT_ERROR, 0,\n                response_size, response);\n        } else {\n            /**\n             * just ignore this message\n             * return UNSUPPORTED and clear response_size to continue the dispatch without send response\n             **/\n            *response_size = 0;\n            return LIBSPDM_STATUS_UNSUPPORTED_CAP;\n        }\n    }\n    status = libspdm_append_message_f(\n        spdm_context, session_info, false,\n        (const uint8_t *)request + request_size - hmac_size,\n        hmac_size);\n    if (LIBSPDM_STATUS_IS_ERROR(status)) {\n        return libspdm_generate_error_response(spdm_context,\n                                               SPDM_ERROR_CODE_UNSPECIFIED, 0,\n                                               response_size, response);\n    }\n\n    status = libspdm_append_message_f(spdm_context, session_info, false, spdm_response,\n                                      *response_size);\n    if (LIBSPDM_STATUS_IS_ERROR(status)) {\n        return libspdm_generate_error_response(spdm_context,\n                                               SPDM_ERROR_CODE_UNSPECIFIED, 0,\n                                               response_size, response);\n    }\n\n    LIBSPDM_DEBUG((LIBSPDM_DEBUG_INFO, \"libspdm_generate_session_data_key[%x]\\n\", session_id));\n    result = libspdm_calculate_th2_hash(spdm_context, session_info, false,\n                                        th2_hash_data);\n    if (!result) {\n        return libspdm_generate_error_response(spdm_context,\n                                               SPDM_ERROR_CODE_UNSPECIFIED, 0,\n                                               response_size, response);\n    }\n    result = libspdm_generate_session_data_key(\n        session_info->secured_message_context, th2_hash_data);\n    if (!result) {\n        return libspdm_generate_error_response(spdm_context,\n                                               SPDM_ERROR_CODE_UNSPECIFIED, 0,\n                                               response_size, response);\n    }\n\n    #if LIBSPDM_ENABLE_CAPABILITY_HBEAT_CAP\n    if (libspdm_is_capabilities_flag_supported(\n            spdm_context, false,\n            SPDM_GET_CAPABILITIES_REQUEST_FLAGS_HBEAT_CAP,\n            SPDM_GET_CAPABILITIES_RESPONSE_FLAGS_HBEAT_CAP)) {\n        result = libspdm_start_watchdog(\n            session_id, spdm_context->local_context.heartbeat_period * 2);\n        if (!result) {\n            return libspdm_generate_error_response(spdm_context,\n                                                   SPDM_ERROR_CODE_UNSPECIFIED, 0,\n                                                   response_size, response);\n        }\n    }\n    #endif /* LIBSPDM_ENABLE_CAPABILITY_HBEAT_CAP */\n\n    return LIBSPDM_STATUS_SUCCESS;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -54,6 +54,11 @@\n     if (session_info == NULL) {\n         return libspdm_generate_error_response(spdm_context,\n                                                SPDM_ERROR_CODE_SESSION_REQUIRED, 0,\n+                                               response_size, response);\n+    }\n+    if (!session_info->use_psk) {\n+        return libspdm_generate_error_response(spdm_context,\n+                                               SPDM_ERROR_CODE_UNEXPECTED_REQUEST, 0,\n                                                response_size, response);\n     }\n     session_state = libspdm_secured_message_get_session_state(",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "                                               response_size, response);",
                "    }",
                "    if (!session_info->use_psk) {",
                "        return libspdm_generate_error_response(spdm_context,",
                "                                               SPDM_ERROR_CODE_UNEXPECTED_REQUEST, 0,"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-41985",
        "func_name": "weston-embedded/uC-FTPs/FTPs_CtrlTask",
        "description": "An authentication bypass vulnerability exists in the Authentication functionality of Weston Embedded uC-FTPs v 1.98.00. A specially crafted set of network packets can lead to authentication bypass and denial of service. An attacker can send a sequence of unauthenticated packets to trigger this vulnerability.",
        "git_url": "https://github.com/weston-embedded/uC-FTPs/commit/83393f6129fc5a77cbdf287c6fd9745cb53d8d04",
        "commit_title": "Patched DoS vulnerability CVE-2022-41985 / TALOS-2022-1680. Fixed bug",
        "commit_text": "within FTPs_Init() that could cause an invalid socket ID to be pased to the FTPs Server Task.",
        "func_before": "void  FTPs_CtrlTask (void  *p_arg)\n{\n    FTPs_SESSION_STRUCT   ftp_session;\n    NET_SOCK_ID          *p_sock_id;\n\n    CPU_INT32U            net_buf_len;\n    CPU_CHAR             *p_net_buf;\n    CPU_CHAR             *p_net_buf2;\n    CPU_CHAR             *p_cmd;\n\n    NET_ERR               net_err;\n    CPU_INT32S            pkt_len;\n    CPU_INT16S            cmp_val;\n    CPU_INT32U            i;\n\n\n    FTPs_CtrlTasks++;\n\n    ftp_session.DtpSockAddr.AddrFamily = NET_SOCK_ADDR_FAMILY_IP_V4;\n    ftp_session.DtpSockAddr.Addr       = NET_UTIL_HOST_TO_NET_32(NET_IPv4_ADDR_ANY);\n\n    if (FTPs_SecureCfgPtr != DEF_NULL) {                        /* Set the port according to the secure mode cfg.       */\n        ftp_session.DtpSockAddr.Port       = NET_UTIL_HOST_TO_NET_16(FTPs_CFG_DATA_IPPORT_SECURE);\n    } else {\n        ftp_session.DtpSockAddr.Port       = NET_UTIL_HOST_TO_NET_16(FTPs_CFG_DATA_IPPORT);\n    }\n\n    p_sock_id                          = (NET_SOCK_ID *)p_arg;\n    ftp_session.CtrlSockID             = *p_sock_id;\n    ftp_session.CtrlState              =  FTPs_STATE_LOGOUT;\n    ftp_session.CtrlCmd                =  FTP_CMD_NOOP;\n\n    ftp_session.DtpSockID              = -1;\n    ftp_session.DtpPasv                = DEF_NO;\n\n                                                                /* Defaults specified in RFC959.                        */\n    ftp_session.DtpMode                = FTP_MODE_STREAM;\n    ftp_session.DtpType                = FTP_TYPE_ASCII;\n    ftp_session.DtpForm                = FTP_FORM_NONPRINT;\n    ftp_session.DtpStru                = FTP_STRU_FILE;\n\n    ftp_session.DtpCmd                 = FTP_CMD_NOOP;\n\n    ftp_session.DtpOffset              = 0;\n\n    FTPs_SendReply(ftp_session.CtrlSockID, FTP_REPLY_SERVERREADY, (CPU_CHAR *)0);\n\n    while (DEF_TRUE) {\n                                                                /* Receive data until NEWLINE and replace it by a NULL. */\n        p_net_buf   = FTPs_NetBufCtrlTaskPtr;\n        net_buf_len = FTPs_NET_BUF_LEN;\n\n        NetSock_CfgTimeoutRxQ_Set((NET_SOCK_ID  ) ftp_session.CtrlSockID,\n                                  (CPU_INT32U   ) FTPs_CFG_CTRL_MAX_RX_TIMEOUT_MS,\n                                  (NET_ERR     *)&net_err);\n\n        while (DEF_TRUE) {\n            pkt_len = NetSock_RxData( ftp_session.CtrlSockID,\n                                      p_net_buf,\n                                      net_buf_len,\n                                      NET_SOCK_FLAG_NONE,\n                                     &net_err);\n            if ((net_err != NET_SOCK_ERR_NONE) &&\n                (net_err != NET_SOCK_ERR_RX_Q_EMPTY)) {\n                FTPs_TRACE_DBG((\"FTPs NetSock_RxData() failed: error #%u, line #%u.\\n\", (unsigned int)net_err, (unsigned int)__LINE__));\n                break;\n            }\n            if (net_err == NET_SOCK_ERR_RX_Q_EMPTY) {\n                FTPs_TRACE_DBG((\"FTPs NetSock_RxData() timeout, line #%u.\\n\", (unsigned int)__LINE__));\n                break;\n            }\n\n            p_net_buf2 = (CPU_CHAR *)Str_Char_N(p_net_buf, pkt_len, '\\n');\n            if ( p_net_buf2  != (CPU_CHAR *)0) {\n                *p_net_buf2   = (CPU_CHAR)0;\n                 net_buf_len  = p_net_buf2 - FTPs_NetBufCtrlTaskPtr;\n                 break;\n            }\n\n            net_buf_len -= pkt_len;\n            p_net_buf   += pkt_len;\n        }\n\n        if (net_err != NET_SOCK_ERR_NONE) {\n            FTPs_StopPasvMode(&ftp_session);\n            FTPs_SendReply(ftp_session.CtrlSockID, FTP_REPLY_SERVERCLOSING, (CPU_CHAR *)0);\n            break;\n        }\n\n                                                                /* Process the received line.                           */\n                                                                /*                                                      */\n                                                                /* The line will be a command of the format             */\n                                                                /* <COMMAND> [<ARG1>] [...]                             */\n                                                                /*                                                      */\n                                                                /* Where:                                               */\n                                                                /* COMMAND is a 3 or 4 letter command.                  */\n                                                                /* ARG1 is command specific.                            */\n                                                                /* ARG2 is command specific.                            */\n                                                                /* ...                                                  */\n\n                                                                /* Find the command.                                    */\n        FTPs_TRACE_INFO((\"FTPs RX: %s\\n\", FTPs_NetBufCtrlTaskPtr));\n\n        p_net_buf = FTPs_NetBufCtrlTaskPtr;\n        p_cmd     = FTPs_FindArg(&p_net_buf);\n        if (*p_cmd == (CPU_CHAR)0) {\n            continue;\n        }\n\n                                                                /* Convert command to uppercase.                        */\n        p_net_buf2 = p_cmd;\n        while (*p_net_buf2 != (CPU_CHAR)0) {\n            *p_net_buf2 = ASCII_ToUpper(*p_net_buf2);\n             p_net_buf2++;\n        }\n\n                                                                /* Find the command code.                               */\n        i = 0;\n        while (FTPs_Cmd[i].CmdCode != FTP_CMD_MAX) {\n            cmp_val = Str_Cmp((CPU_CHAR *)p_cmd,\n                              (CPU_CHAR *)FTPs_Cmd[i].CmdStr);\n            if (cmp_val == 0) {\n                ftp_session.CtrlCmd = FTPs_Cmd[i].CmdCode;\n                break;\n            }\n            i++;\n        }\n        if (FTPs_Cmd[i].CmdCode == FTP_CMD_MAX) {\n            FTPs_SendReply(ftp_session.CtrlSockID, FTP_REPLY_CMDNOSUPPORT, (CPU_CHAR *)0);\n            continue;\n        }\n\n                                                                /* Determine if the command entered is compatible with  */\n                                                                /* the current state (context check).                   */\n        if (FTPs_Cmd[ftp_session.CtrlCmd].CmdCntxt[ftp_session.CtrlState] == DEF_OFF) {\n            if (ftp_session.CtrlState == FTPs_STATE_LOGOUT) {\n                FTPs_SendReply(ftp_session.CtrlSockID, FTP_REPLY_NOTLOGGEDIN, (CPU_CHAR *)0);\n            } else {\n                FTPs_SendReply(ftp_session.CtrlSockID, FTP_REPLY_CMDBADSEQUENCE, (CPU_CHAR *)0);\n                ftp_session.CtrlState = FTPs_STATE_LOGIN;\n            }\n            continue;\n        }\n\n        ftp_session.CtrlCmdArgs = p_net_buf;\n        FTPs_ProcessCtrlCmd(&ftp_session);\n\n        if (ftp_session.CtrlCmd == FTP_CMD_QUIT) {\n            break;\n        }\n    }\n\n    FTPs_TRACE_INFO((\"FTPs CLOSE CTRL socket.\\n\"));\n    NetSock_Close(ftp_session.CtrlSockID, &net_err);\n\n    FTPs_TRACE_INFO((\"FTPs DELETE CTRL task.\\n\"));\n    FTPs_CtrlTasks--;\n    FTPs_OS_TaskDel();\n}",
        "func": "void  FTPs_CtrlTask (void  *p_arg)\n{\n    FTPs_SESSION_STRUCT   ftp_session;\n    NET_SOCK_ID          *p_sock_id;\n\n    CPU_INT32U            net_buf_len;\n    CPU_CHAR             *p_net_buf;\n    CPU_CHAR             *p_net_buf2;\n    CPU_CHAR             *p_cmd;\n\n    NET_ERR               net_err;\n    CPU_INT32S            pkt_len;\n    CPU_INT16S            cmp_val;\n    CPU_INT32U            i;\n\n\n    FTPs_CtrlTasks++;\n\n    ftp_session.DtpSockAddr.AddrFamily = NET_SOCK_ADDR_FAMILY_IP_V4;\n    ftp_session.DtpSockAddr.Addr       = NET_UTIL_HOST_TO_NET_32(NET_IPv4_ADDR_ANY);\n\n    if (FTPs_SecureCfgPtr != DEF_NULL) {                        /* Set the port according to the secure mode cfg.       */\n        ftp_session.DtpSockAddr.Port       = NET_UTIL_HOST_TO_NET_16(FTPs_CFG_DATA_IPPORT_SECURE);\n    } else {\n        ftp_session.DtpSockAddr.Port       = NET_UTIL_HOST_TO_NET_16(FTPs_CFG_DATA_IPPORT);\n    }\n\n    p_sock_id                          = (NET_SOCK_ID *)p_arg;\n    ftp_session.CtrlSockID             = *p_sock_id;\n    ftp_session.CtrlState              =  FTPs_STATE_LOGOUT;\n    ftp_session.CtrlCmd                =  FTP_CMD_NOOP;\n\n    ftp_session.DtpSockID              = -1;\n    ftp_session.DtpPasv                = DEF_NO;\n\n                                                                /* Defaults specified in RFC959.                        */\n    ftp_session.DtpMode                = FTP_MODE_STREAM;\n    ftp_session.DtpType                = FTP_TYPE_ASCII;\n    ftp_session.DtpForm                = FTP_FORM_NONPRINT;\n    ftp_session.DtpStru                = FTP_STRU_FILE;\n\n    ftp_session.DtpCmd                 = FTP_CMD_NOOP;\n\n    ftp_session.DtpOffset              = 0;\n\n    FTPs_SendReply(ftp_session.CtrlSockID, FTP_REPLY_SERVERREADY, (CPU_CHAR *)0);\n\n    while (DEF_TRUE) {\n                                                                /* Receive data until NEWLINE and replace it by a NULL. */\n        p_net_buf   = FTPs_NetBufCtrlTaskPtr;\n        net_buf_len = FTPs_NET_BUF_LEN;\n\n        NetSock_CfgTimeoutRxQ_Set((NET_SOCK_ID  ) ftp_session.CtrlSockID,\n                                  (CPU_INT32U   ) FTPs_CFG_CTRL_MAX_RX_TIMEOUT_MS,\n                                  (NET_ERR     *)&net_err);\n\n        while (DEF_TRUE) {\n            pkt_len = NetSock_RxData( ftp_session.CtrlSockID,\n                                      p_net_buf,\n                                      net_buf_len,\n                                      NET_SOCK_FLAG_NONE,\n                                     &net_err);\n            if ((net_err != NET_SOCK_ERR_NONE) &&\n                (net_err != NET_SOCK_ERR_RX_Q_EMPTY)) {\n                FTPs_TRACE_DBG((\"FTPs NetSock_RxData() failed: error #%u, line #%u.\\n\", (unsigned int)net_err, (unsigned int)__LINE__));\n                break;\n            }\n            if (net_err == NET_SOCK_ERR_RX_Q_EMPTY) {\n                FTPs_TRACE_DBG((\"FTPs NetSock_RxData() timeout, line #%u.\\n\", (unsigned int)__LINE__));\n                break;\n            }\n\n            p_net_buf2 = (CPU_CHAR *)Str_Char_N(p_net_buf, pkt_len, '\\n');\n            if ( p_net_buf2  != (CPU_CHAR *)0) {\n                *p_net_buf2   = (CPU_CHAR)0;\n                 net_buf_len  = p_net_buf2 - FTPs_NetBufCtrlTaskPtr;\n                 break;\n            }\n\n            net_buf_len -= pkt_len;\n            p_net_buf   += pkt_len;\n        }\n\n        if (net_err != NET_SOCK_ERR_NONE) {\n            FTPs_StopPasvMode(&ftp_session);\n            FTPs_SendReply(ftp_session.CtrlSockID, FTP_REPLY_SERVERCLOSING, (CPU_CHAR *)0);\n            break;\n        }\n\n                                                                /* Process the received line.                           */\n                                                                /*                                                      */\n                                                                /* The line will be a command of the format             */\n                                                                /* <COMMAND> [<ARG1>] [...]                             */\n                                                                /*                                                      */\n                                                                /* Where:                                               */\n                                                                /* COMMAND is a 3 or 4 letter command.                  */\n                                                                /* ARG1 is command specific.                            */\n                                                                /* ARG2 is command specific.                            */\n                                                                /* ...                                                  */\n\n                                                                /* Find the command.                                    */\n        FTPs_TRACE_INFO((\"FTPs RX: %s\\n\", FTPs_NetBufCtrlTaskPtr));\n\n        p_net_buf = FTPs_NetBufCtrlTaskPtr;\n        p_cmd     = FTPs_FindArg(&p_net_buf);\n        if (*p_cmd == (CPU_CHAR)0) {\n            continue;\n        }\n\n                                                                /* Convert command to uppercase.                        */\n        p_net_buf2 = p_cmd;\n        while (*p_net_buf2 != (CPU_CHAR)0) {\n            *p_net_buf2 = ASCII_ToUpper(*p_net_buf2);\n             p_net_buf2++;\n        }\n\n                                                                /* Find the command code.                               */\n        i = 0;\n        while (FTPs_Cmd[i].CmdCode != FTP_CMD_MAX) {\n            cmp_val = Str_Cmp((CPU_CHAR *)p_cmd,\n                              (CPU_CHAR *)FTPs_Cmd[i].CmdStr);\n            if (cmp_val == 0) {\n                ftp_session.CtrlCmd = FTPs_Cmd[i].CmdCode;\n                break;\n            }\n            i++;\n        }\n        if (FTPs_Cmd[i].CmdCode == FTP_CMD_MAX) {\n            FTPs_SendReply(ftp_session.CtrlSockID, FTP_REPLY_CMDNOSUPPORT, (CPU_CHAR *)0);\n            continue;\n        }\n\n                                                                /* Determine if the command entered is compatible with  */\n                                                                /* the current state (context check).                   */\n        if (FTPs_Cmd[ftp_session.CtrlCmd].CmdCntxt[ftp_session.CtrlState] == DEF_OFF) {\n            if (ftp_session.CtrlState != FTPs_STATE_LOGIN) {\n                FTPs_SendReply(ftp_session.CtrlSockID, FTP_REPLY_NOTLOGGEDIN, (CPU_CHAR *)0);\n            } else {\n                FTPs_SendReply(ftp_session.CtrlSockID, FTP_REPLY_CMDBADSEQUENCE, (CPU_CHAR *)0);\n                ftp_session.CtrlState = FTPs_STATE_LOGIN;\n            }\n            continue;\n        }\n\n        ftp_session.CtrlCmdArgs = p_net_buf;\n        FTPs_ProcessCtrlCmd(&ftp_session);\n\n        if (ftp_session.CtrlCmd == FTP_CMD_QUIT) {\n            break;\n        }\n    }\n\n    FTPs_TRACE_INFO((\"FTPs CLOSE CTRL socket.\\n\"));\n    NetSock_Close(ftp_session.CtrlSockID, &net_err);\n\n    FTPs_TRACE_INFO((\"FTPs DELETE CTRL task.\\n\"));\n    FTPs_CtrlTasks--;\n    FTPs_OS_TaskDel();\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -133,7 +133,7 @@\n                                                                 /* Determine if the command entered is compatible with  */\n                                                                 /* the current state (context check).                   */\n         if (FTPs_Cmd[ftp_session.CtrlCmd].CmdCntxt[ftp_session.CtrlState] == DEF_OFF) {\n-            if (ftp_session.CtrlState == FTPs_STATE_LOGOUT) {\n+            if (ftp_session.CtrlState != FTPs_STATE_LOGIN) {\n                 FTPs_SendReply(ftp_session.CtrlSockID, FTP_REPLY_NOTLOGGEDIN, (CPU_CHAR *)0);\n             } else {\n                 FTPs_SendReply(ftp_session.CtrlSockID, FTP_REPLY_CMDBADSEQUENCE, (CPU_CHAR *)0);",
        "diff_line_info": {
            "deleted_lines": [
                "            if (ftp_session.CtrlState == FTPs_STATE_LOGOUT) {"
            ],
            "added_lines": [
                "            if (ftp_session.CtrlState != FTPs_STATE_LOGIN) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-41985",
        "func_name": "weston-embedded/uC-FTPs/FTPs_Init",
        "description": "An authentication bypass vulnerability exists in the Authentication functionality of Weston Embedded uC-FTPs v 1.98.00. A specially crafted set of network packets can lead to authentication bypass and denial of service. An attacker can send a sequence of unauthenticated packets to trigger this vulnerability.",
        "git_url": "https://github.com/weston-embedded/uC-FTPs/commit/83393f6129fc5a77cbdf287c6fd9745cb53d8d04",
        "commit_title": "Patched DoS vulnerability CVE-2022-41985 / TALOS-2022-1680. Fixed bug",
        "commit_text": "within FTPs_Init() that could cause an invalid socket ID to be pased to the FTPs Server Task.",
        "func_before": "CPU_BOOLEAN  FTPs_Init (       NET_IPv4_ADDR     public_addr,\n                               NET_PORT_NBR      public_port,\n                        const  FTPs_SECURE_CFG  *p_secure_cfg)\n{\n    CPU_BOOLEAN  rtn_val;\n    CPU_INT32U   path_len_max;\n    NET_SOCK_ID  ctrl_sock_id;\n    CPU_INT32U   max_path_name_len;\n    CPU_SIZE_T   heap_rem_size;\n    LIB_ERR      lib_err;\n    CPU_SR_ALLOC();\n\n\n#ifndef  NET_SECURE_MODULE_PRESENT                              /* See Note #1.                                         */\n    if (p_secure_cfg != (FTPs_SECURE_CFG *)0) {\n        FTPs_TRACE_DBG((\"FTPs init failed. Security manager NOT available.\\n\"));\n        return (DEF_FAIL);\n    }\n#endif\n\n    FTPs_CtrlTasks  = 0;\n    FTPs_PublicAddr = public_addr;\n    FTPs_PublicPort = public_port;\n\n\n    path_len_max = NetFS_CfgPathGetLenMax();\n\n    if (FTPs_CFG_FS_PATH_LEN_MAX > path_len_max) {\n        FTPs_TRACE_DBG((\"FTPs init failed. FTPs_CFG_FS_PATH_LEN_MAX is larger than the File System allows.\\n\"));\n        return (DEF_FAIL);\n    }\n\n    FTPs_FS_SepChar = NetFS_CfgPathGetSepChar();\n\n    max_path_name_len = NetFS_CfgPathGetLenMax();\n\n    heap_rem_size = Mem_HeapGetSizeRem(sizeof(CPU_CHAR),\n                                      &lib_err);\n\n    if ((heap_rem_size  > max_path_name_len) &&\n        (lib_err       == LIB_MEM_ERR_NONE)) {\n        FTPs_FullAbsPathPtr = (CPU_CHAR *)Mem_HeapAlloc(max_path_name_len + 1,\n                                                        sizeof(CPU_CHAR),\n                                                        0,\n                                                       &lib_err);\n\n        if (lib_err != LIB_MEM_ERR_NONE) {\n            FTPs_TRACE_DBG((\"FTPs init failed. Memory heap size insufficient.\\n\"));\n            return (DEF_FAIL);\n        }\n\n    } else {\n        FTPs_TRACE_DBG((\"FTPs init failed. Memory heap size insufficient.\\n\"));\n        return (DEF_FAIL);\n    }\n\n    heap_rem_size = Mem_HeapGetSizeRem(sizeof(CPU_CHAR),\n                                      &lib_err);\n\n    if ((heap_rem_size  > max_path_name_len) &&\n        (lib_err       == LIB_MEM_ERR_NONE)) {\n        FTPs_FullRelPathPtr = (CPU_CHAR *)Mem_HeapAlloc(max_path_name_len + 1,\n                                                        sizeof(CPU_CHAR),\n                                                        0,\n                                                       &lib_err);\n\n        if (lib_err != LIB_MEM_ERR_NONE) {\n            FTPs_TRACE_DBG((\"FTPs init failed. Memory heap size insufficient.\\n\"));\n            return (DEF_FAIL);\n        }\n\n    } else {\n        FTPs_TRACE_DBG((\"FTPs init failed. Memory heap size insufficient.\\n\"));\n        return (DEF_FAIL);\n    }\n\n    heap_rem_size = Mem_HeapGetSizeRem(sizeof(CPU_CHAR),\n                                      &lib_err);\n\n    if ((heap_rem_size  > max_path_name_len) &&\n        (lib_err       == LIB_MEM_ERR_NONE)) {\n        FTPs_ParentAbsPathPtr = (CPU_CHAR *)Mem_HeapAlloc(max_path_name_len + 1,\n                                                          sizeof(CPU_CHAR),\n                                                          0,\n                                                         &lib_err);\n\n        if (lib_err != LIB_MEM_ERR_NONE) {\n            FTPs_TRACE_DBG((\"FTPs init failed. Memory heap size insufficient.\\n\"));\n            return (DEF_FAIL);\n        }\n\n    } else {\n        FTPs_TRACE_DBG((\"FTPs init failed. Memory heap size insufficient.\\n\"));\n        return (DEF_FAIL);\n    }\n\n    heap_rem_size = Mem_HeapGetSizeRem(sizeof(CPU_CHAR),\n                                      &lib_err);\n\n    if ((heap_rem_size  > max_path_name_len) &&\n        (lib_err       == LIB_MEM_ERR_NONE)) {\n        FTPs_CurEntryPtr = (CPU_CHAR *)Mem_HeapAlloc(max_path_name_len + 1,\n                                                     sizeof(CPU_CHAR),\n                                                     0,\n                                                    &lib_err);\n\n        if (lib_err != LIB_MEM_ERR_NONE) {\n            FTPs_TRACE_DBG((\"FTPs init failed. Memory heap size insufficient.\\n\"));\n            return (DEF_FAIL);\n        }\n\n    } else {\n        FTPs_TRACE_DBG((\"FTPs init failed. Memory heap size insufficient.\\n\"));\n        return (DEF_FAIL);\n    }\n\n    heap_rem_size = Mem_HeapGetSizeRem(sizeof(CPU_CHAR),\n                                      &lib_err);\n\n    if ((heap_rem_size  > max_path_name_len) &&\n        (lib_err       == LIB_MEM_ERR_NONE)) {\n        FTPs_RenAbsPathPtr = (CPU_CHAR *)Mem_HeapAlloc(max_path_name_len + 1,\n                                                       sizeof(CPU_CHAR),\n                                                       0,\n                                                      &lib_err);\n\n        if (lib_err != LIB_MEM_ERR_NONE) {\n            FTPs_TRACE_DBG((\"FTPs init failed. Memory heap size insufficient.\\n\"));\n            return (DEF_FAIL);\n        }\n\n    } else {\n        FTPs_TRACE_DBG((\"FTPs init failed. Memory heap size insufficient.\\n\"));\n        return (DEF_FAIL);\n    }\n\n    heap_rem_size = Mem_HeapGetSizeRem(sizeof(CPU_CHAR),\n                                      &lib_err);\n\n    if ((heap_rem_size  > max_path_name_len) &&\n        (lib_err       == LIB_MEM_ERR_NONE)) {\n        FTPs_RenRelPathPtr = (CPU_CHAR *)Mem_HeapAlloc(max_path_name_len + 1,\n                                                       sizeof(CPU_CHAR),\n                                                       0,\n                                                      &lib_err);\n\n        if (lib_err != LIB_MEM_ERR_NONE) {\n            FTPs_TRACE_DBG((\"FTPs init failed. Memory heap size insufficient.\\n\"));\n            return (DEF_FAIL);\n        }\n\n    } else {\n        FTPs_TRACE_DBG((\"FTPs init failed. Memory heap size insufficient.\\n\"));\n        return (DEF_FAIL);\n    }\n\n    heap_rem_size = Mem_HeapGetSizeRem(sizeof(CPU_CHAR),\n                                      &lib_err);\n\n    if ((heap_rem_size >= FTPs_NET_BUF_LEN) &&\n        (lib_err       == LIB_MEM_ERR_NONE)) {\n        FTPs_NetBufCtrlCmdPtr = (CPU_CHAR *)Mem_HeapAlloc(FTPs_NET_BUF_LEN,\n                                                   sizeof(CPU_CHAR),\n                                                   0,\n                                                  &lib_err);\n\n        if (lib_err != LIB_MEM_ERR_NONE) {\n            FTPs_TRACE_DBG((\"FTPs init failed. Memory heap size insufficient.\\n\"));\n            return (DEF_FAIL);\n        }\n\n    } else {\n        FTPs_TRACE_DBG((\"FTPs init failed. Memory heap size insufficient.\\n\"));\n        return (DEF_FAIL);\n    }\n\n    heap_rem_size = Mem_HeapGetSizeRem(sizeof(CPU_CHAR),\n                                      &lib_err);\n\n    if ((heap_rem_size >= FTPs_NET_BUF_LEN) &&\n        (lib_err       == LIB_MEM_ERR_NONE)) {\n        FTPs_NetBufCtrlTaskPtr = (CPU_CHAR *)Mem_HeapAlloc(FTPs_NET_BUF_LEN,\n                                                       sizeof(CPU_CHAR),\n                                                       0,\n                                                      &lib_err);\n\n        if (lib_err != LIB_MEM_ERR_NONE) {\n            FTPs_TRACE_DBG((\"FTPs init failed. Memory heap size insufficient.\\n\"));\n            return (DEF_FAIL);\n        }\n\n    } else {\n        FTPs_TRACE_DBG((\"FTPs init failed. Memory heap size insufficient.\\n\"));\n        return (DEF_FAIL);\n    }\n\n    heap_rem_size = Mem_HeapGetSizeRem(sizeof(CPU_CHAR),\n                                      &lib_err);\n\n    if ((heap_rem_size >= FTPs_NET_BUF_LEN) &&\n        (lib_err       == LIB_MEM_ERR_NONE)) {\n        FTPs_NetBufDtpCmdPtr = (CPU_CHAR *)Mem_HeapAlloc(FTPs_NET_BUF_LEN,\n                                                         sizeof(CPU_CHAR),\n                                                         0,\n                                                        &lib_err);\n\n        if (lib_err != LIB_MEM_ERR_NONE) {\n            FTPs_TRACE_DBG((\"FTPs init failed. Memory heap size insufficient.\\n\"));\n            return (DEF_FAIL);\n        }\n\n    } else {\n        FTPs_TRACE_DBG((\"FTPs init failed. Memory heap size insufficient.\\n\"));\n        return (DEF_FAIL);\n    }\n\n    heap_rem_size = Mem_HeapGetSizeRem(sizeof(CPU_CHAR),\n                                      &lib_err);\n\n    if ((heap_rem_size >= FTPs_NET_BUF_LEN) &&\n        (lib_err       == LIB_MEM_ERR_NONE)) {\n        FTPs_NetBufSendReplyPtr = (CPU_CHAR *)Mem_HeapAlloc(FTPs_NET_BUF_LEN,\n                                                            sizeof(CPU_CHAR),\n                                                            0,\n                                                           &lib_err);\n\n        if (lib_err != LIB_MEM_ERR_NONE) {\n            FTPs_TRACE_DBG((\"FTPs init failed. Memory heap size insufficient.\\n\"));\n            return (DEF_FAIL);\n        }\n\n    } else {\n        FTPs_TRACE_DBG((\"FTPs init failed. Memory heap size insufficient.\\n\"));\n        return (DEF_FAIL);\n    }\n\n\n    if (p_secure_cfg != DEF_NULL) {\n#ifdef  NET_SECURE_MODULE_PRESENT                               /* See Note #1.                                         */\n\n        if (p_secure_cfg->CertPtr == DEF_NULL) {\n            FTPs_TRACE_DBG((\"FTPs init failed. Invalid Certificate pointer.\\n\"));\n            return (DEF_FAIL);\n        }\n\n        if (p_secure_cfg->CertLen == 0u) {\n            FTPs_TRACE_DBG((\"FTPs init failed. Invalid Certificate lenght.\\n\"));\n            return (DEF_FAIL);\n        }\n\n        if (p_secure_cfg->KeyPtr == DEF_NULL) {\n            FTPs_TRACE_DBG((\"FTPs init failed. Invalid Key pointer.\\n\"));\n            return (DEF_FAIL);\n        }\n\n        if (p_secure_cfg->KeyLen == 0u) {\n            FTPs_TRACE_DBG((\"FTPs init failed. Invalid Key lenght.\\n\"));\n            return (DEF_FAIL);\n        }\n\n        CPU_CRITICAL_ENTER();\n        FTPs_SecureCfgPtr = p_secure_cfg;                       /* Save secure mode cfg.                                */\n        CPU_CRITICAL_EXIT();\n#else\n        FTPs_TRACE_DBG((\"FTPs init failed. Security NOT available.\\n\"));\n        return (DEF_FAIL);\n#endif\n    }\n\n    FTPs_TRACE_INFO((\"FTPs INIT Control socket.\\n\"));\n    ctrl_sock_id = FTPs_ServerSockInit();\n    if (ctrl_sock_id == NET_SOCK_ID_NONE) {\n        FTPs_TRACE_DBG((\"FTPs FTPs_SockCtrlInit() failed.\\n\"));\n        return (DEF_FAIL);\n    }\n\n\n    FTPs_TRACE_INFO((\"FTPs CREATE SERVER Task.\\n\"));\n    rtn_val = FTPs_OS_ServerTaskInit((void *)&ctrl_sock_id);\n    if (rtn_val == DEF_FAIL) {\n        FTPs_TRACE_DBG((\"FTPs FTPs_Srv_OS_TaskCreate() failed.\\n\"));\n    }\n\n    return (rtn_val);\n}",
        "func": "CPU_BOOLEAN  FTPs_Init (       NET_IPv4_ADDR     public_addr,\n                               NET_PORT_NBR      public_port,\n                        const  FTPs_SECURE_CFG  *p_secure_cfg)\n{\n            CPU_BOOLEAN  rtn_val;\n            CPU_INT32U   path_len_max;\n    static  NET_SOCK_ID  ctrl_sock_id;\n            CPU_INT32U   max_path_name_len;\n            CPU_SIZE_T   heap_rem_size;\n            LIB_ERR      lib_err;\n    CPU_SR_ALLOC();\n\n\n#ifndef  NET_SECURE_MODULE_PRESENT                              /* See Note #1.                                         */\n    if (p_secure_cfg != (FTPs_SECURE_CFG *)0) {\n        FTPs_TRACE_DBG((\"FTPs init failed. Security manager NOT available.\\n\"));\n        return (DEF_FAIL);\n    }\n#endif\n\n    FTPs_CtrlTasks  = 0;\n    FTPs_PublicAddr = public_addr;\n    FTPs_PublicPort = public_port;\n\n\n    path_len_max = NetFS_CfgPathGetLenMax();\n\n    if (FTPs_CFG_FS_PATH_LEN_MAX > path_len_max) {\n        FTPs_TRACE_DBG((\"FTPs init failed. FTPs_CFG_FS_PATH_LEN_MAX is larger than the File System allows.\\n\"));\n        return (DEF_FAIL);\n    }\n\n    FTPs_FS_SepChar = NetFS_CfgPathGetSepChar();\n\n    max_path_name_len = NetFS_CfgPathGetLenMax();\n\n    heap_rem_size = Mem_HeapGetSizeRem(sizeof(CPU_CHAR),\n                                      &lib_err);\n\n    if ((heap_rem_size  > max_path_name_len) &&\n        (lib_err       == LIB_MEM_ERR_NONE)) {\n        FTPs_FullAbsPathPtr = (CPU_CHAR *)Mem_HeapAlloc(max_path_name_len + 1,\n                                                        sizeof(CPU_CHAR),\n                                                        0,\n                                                       &lib_err);\n\n        if (lib_err != LIB_MEM_ERR_NONE) {\n            FTPs_TRACE_DBG((\"FTPs init failed. Memory heap size insufficient.\\n\"));\n            return (DEF_FAIL);\n        }\n\n    } else {\n        FTPs_TRACE_DBG((\"FTPs init failed. Memory heap size insufficient.\\n\"));\n        return (DEF_FAIL);\n    }\n\n    heap_rem_size = Mem_HeapGetSizeRem(sizeof(CPU_CHAR),\n                                      &lib_err);\n\n    if ((heap_rem_size  > max_path_name_len) &&\n        (lib_err       == LIB_MEM_ERR_NONE)) {\n        FTPs_FullRelPathPtr = (CPU_CHAR *)Mem_HeapAlloc(max_path_name_len + 1,\n                                                        sizeof(CPU_CHAR),\n                                                        0,\n                                                       &lib_err);\n\n        if (lib_err != LIB_MEM_ERR_NONE) {\n            FTPs_TRACE_DBG((\"FTPs init failed. Memory heap size insufficient.\\n\"));\n            return (DEF_FAIL);\n        }\n\n    } else {\n        FTPs_TRACE_DBG((\"FTPs init failed. Memory heap size insufficient.\\n\"));\n        return (DEF_FAIL);\n    }\n\n    heap_rem_size = Mem_HeapGetSizeRem(sizeof(CPU_CHAR),\n                                      &lib_err);\n\n    if ((heap_rem_size  > max_path_name_len) &&\n        (lib_err       == LIB_MEM_ERR_NONE)) {\n        FTPs_ParentAbsPathPtr = (CPU_CHAR *)Mem_HeapAlloc(max_path_name_len + 1,\n                                                          sizeof(CPU_CHAR),\n                                                          0,\n                                                         &lib_err);\n\n        if (lib_err != LIB_MEM_ERR_NONE) {\n            FTPs_TRACE_DBG((\"FTPs init failed. Memory heap size insufficient.\\n\"));\n            return (DEF_FAIL);\n        }\n\n    } else {\n        FTPs_TRACE_DBG((\"FTPs init failed. Memory heap size insufficient.\\n\"));\n        return (DEF_FAIL);\n    }\n\n    heap_rem_size = Mem_HeapGetSizeRem(sizeof(CPU_CHAR),\n                                      &lib_err);\n\n    if ((heap_rem_size  > max_path_name_len) &&\n        (lib_err       == LIB_MEM_ERR_NONE)) {\n        FTPs_CurEntryPtr = (CPU_CHAR *)Mem_HeapAlloc(max_path_name_len + 1,\n                                                     sizeof(CPU_CHAR),\n                                                     0,\n                                                    &lib_err);\n\n        if (lib_err != LIB_MEM_ERR_NONE) {\n            FTPs_TRACE_DBG((\"FTPs init failed. Memory heap size insufficient.\\n\"));\n            return (DEF_FAIL);\n        }\n\n    } else {\n        FTPs_TRACE_DBG((\"FTPs init failed. Memory heap size insufficient.\\n\"));\n        return (DEF_FAIL);\n    }\n\n    heap_rem_size = Mem_HeapGetSizeRem(sizeof(CPU_CHAR),\n                                      &lib_err);\n\n    if ((heap_rem_size  > max_path_name_len) &&\n        (lib_err       == LIB_MEM_ERR_NONE)) {\n        FTPs_RenAbsPathPtr = (CPU_CHAR *)Mem_HeapAlloc(max_path_name_len + 1,\n                                                       sizeof(CPU_CHAR),\n                                                       0,\n                                                      &lib_err);\n\n        if (lib_err != LIB_MEM_ERR_NONE) {\n            FTPs_TRACE_DBG((\"FTPs init failed. Memory heap size insufficient.\\n\"));\n            return (DEF_FAIL);\n        }\n\n    } else {\n        FTPs_TRACE_DBG((\"FTPs init failed. Memory heap size insufficient.\\n\"));\n        return (DEF_FAIL);\n    }\n\n    heap_rem_size = Mem_HeapGetSizeRem(sizeof(CPU_CHAR),\n                                      &lib_err);\n\n    if ((heap_rem_size  > max_path_name_len) &&\n        (lib_err       == LIB_MEM_ERR_NONE)) {\n        FTPs_RenRelPathPtr = (CPU_CHAR *)Mem_HeapAlloc(max_path_name_len + 1,\n                                                       sizeof(CPU_CHAR),\n                                                       0,\n                                                      &lib_err);\n\n        if (lib_err != LIB_MEM_ERR_NONE) {\n            FTPs_TRACE_DBG((\"FTPs init failed. Memory heap size insufficient.\\n\"));\n            return (DEF_FAIL);\n        }\n\n    } else {\n        FTPs_TRACE_DBG((\"FTPs init failed. Memory heap size insufficient.\\n\"));\n        return (DEF_FAIL);\n    }\n\n    heap_rem_size = Mem_HeapGetSizeRem(sizeof(CPU_CHAR),\n                                      &lib_err);\n\n    if ((heap_rem_size >= FTPs_NET_BUF_LEN) &&\n        (lib_err       == LIB_MEM_ERR_NONE)) {\n        FTPs_NetBufCtrlCmdPtr = (CPU_CHAR *)Mem_HeapAlloc(FTPs_NET_BUF_LEN,\n                                                   sizeof(CPU_CHAR),\n                                                   0,\n                                                  &lib_err);\n\n        if (lib_err != LIB_MEM_ERR_NONE) {\n            FTPs_TRACE_DBG((\"FTPs init failed. Memory heap size insufficient.\\n\"));\n            return (DEF_FAIL);\n        }\n\n    } else {\n        FTPs_TRACE_DBG((\"FTPs init failed. Memory heap size insufficient.\\n\"));\n        return (DEF_FAIL);\n    }\n\n    heap_rem_size = Mem_HeapGetSizeRem(sizeof(CPU_CHAR),\n                                      &lib_err);\n\n    if ((heap_rem_size >= FTPs_NET_BUF_LEN) &&\n        (lib_err       == LIB_MEM_ERR_NONE)) {\n        FTPs_NetBufCtrlTaskPtr = (CPU_CHAR *)Mem_HeapAlloc(FTPs_NET_BUF_LEN,\n                                                       sizeof(CPU_CHAR),\n                                                       0,\n                                                      &lib_err);\n\n        if (lib_err != LIB_MEM_ERR_NONE) {\n            FTPs_TRACE_DBG((\"FTPs init failed. Memory heap size insufficient.\\n\"));\n            return (DEF_FAIL);\n        }\n\n    } else {\n        FTPs_TRACE_DBG((\"FTPs init failed. Memory heap size insufficient.\\n\"));\n        return (DEF_FAIL);\n    }\n\n    heap_rem_size = Mem_HeapGetSizeRem(sizeof(CPU_CHAR),\n                                      &lib_err);\n\n    if ((heap_rem_size >= FTPs_NET_BUF_LEN) &&\n        (lib_err       == LIB_MEM_ERR_NONE)) {\n        FTPs_NetBufDtpCmdPtr = (CPU_CHAR *)Mem_HeapAlloc(FTPs_NET_BUF_LEN,\n                                                         sizeof(CPU_CHAR),\n                                                         0,\n                                                        &lib_err);\n\n        if (lib_err != LIB_MEM_ERR_NONE) {\n            FTPs_TRACE_DBG((\"FTPs init failed. Memory heap size insufficient.\\n\"));\n            return (DEF_FAIL);\n        }\n\n    } else {\n        FTPs_TRACE_DBG((\"FTPs init failed. Memory heap size insufficient.\\n\"));\n        return (DEF_FAIL);\n    }\n\n    heap_rem_size = Mem_HeapGetSizeRem(sizeof(CPU_CHAR),\n                                      &lib_err);\n\n    if ((heap_rem_size >= FTPs_NET_BUF_LEN) &&\n        (lib_err       == LIB_MEM_ERR_NONE)) {\n        FTPs_NetBufSendReplyPtr = (CPU_CHAR *)Mem_HeapAlloc(FTPs_NET_BUF_LEN,\n                                                            sizeof(CPU_CHAR),\n                                                            0,\n                                                           &lib_err);\n\n        if (lib_err != LIB_MEM_ERR_NONE) {\n            FTPs_TRACE_DBG((\"FTPs init failed. Memory heap size insufficient.\\n\"));\n            return (DEF_FAIL);\n        }\n\n    } else {\n        FTPs_TRACE_DBG((\"FTPs init failed. Memory heap size insufficient.\\n\"));\n        return (DEF_FAIL);\n    }\n\n\n    if (p_secure_cfg != DEF_NULL) {\n#ifdef  NET_SECURE_MODULE_PRESENT                               /* See Note #1.                                         */\n\n        if (p_secure_cfg->CertPtr == DEF_NULL) {\n            FTPs_TRACE_DBG((\"FTPs init failed. Invalid Certificate pointer.\\n\"));\n            return (DEF_FAIL);\n        }\n\n        if (p_secure_cfg->CertLen == 0u) {\n            FTPs_TRACE_DBG((\"FTPs init failed. Invalid Certificate lenght.\\n\"));\n            return (DEF_FAIL);\n        }\n\n        if (p_secure_cfg->KeyPtr == DEF_NULL) {\n            FTPs_TRACE_DBG((\"FTPs init failed. Invalid Key pointer.\\n\"));\n            return (DEF_FAIL);\n        }\n\n        if (p_secure_cfg->KeyLen == 0u) {\n            FTPs_TRACE_DBG((\"FTPs init failed. Invalid Key lenght.\\n\"));\n            return (DEF_FAIL);\n        }\n\n        CPU_CRITICAL_ENTER();\n        FTPs_SecureCfgPtr = p_secure_cfg;                       /* Save secure mode cfg.                                */\n        CPU_CRITICAL_EXIT();\n#else\n        FTPs_TRACE_DBG((\"FTPs init failed. Security NOT available.\\n\"));\n        return (DEF_FAIL);\n#endif\n    }\n\n    FTPs_TRACE_INFO((\"FTPs INIT Control socket.\\n\"));\n    ctrl_sock_id = FTPs_ServerSockInit();\n    if (ctrl_sock_id == NET_SOCK_ID_NONE) {\n        FTPs_TRACE_DBG((\"FTPs FTPs_SockCtrlInit() failed.\\n\"));\n        return (DEF_FAIL);\n    }\n\n\n    FTPs_TRACE_INFO((\"FTPs CREATE SERVER Task.\\n\"));\n    rtn_val = FTPs_OS_ServerTaskInit((void *)&ctrl_sock_id);\n    if (rtn_val == DEF_FAIL) {\n        FTPs_TRACE_DBG((\"FTPs FTPs_Srv_OS_TaskCreate() failed.\\n\"));\n    }\n\n    return (rtn_val);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,12 +2,12 @@\n                                NET_PORT_NBR      public_port,\n                         const  FTPs_SECURE_CFG  *p_secure_cfg)\n {\n-    CPU_BOOLEAN  rtn_val;\n-    CPU_INT32U   path_len_max;\n-    NET_SOCK_ID  ctrl_sock_id;\n-    CPU_INT32U   max_path_name_len;\n-    CPU_SIZE_T   heap_rem_size;\n-    LIB_ERR      lib_err;\n+            CPU_BOOLEAN  rtn_val;\n+            CPU_INT32U   path_len_max;\n+    static  NET_SOCK_ID  ctrl_sock_id;\n+            CPU_INT32U   max_path_name_len;\n+            CPU_SIZE_T   heap_rem_size;\n+            LIB_ERR      lib_err;\n     CPU_SR_ALLOC();\n \n ",
        "diff_line_info": {
            "deleted_lines": [
                "    CPU_BOOLEAN  rtn_val;",
                "    CPU_INT32U   path_len_max;",
                "    NET_SOCK_ID  ctrl_sock_id;",
                "    CPU_INT32U   max_path_name_len;",
                "    CPU_SIZE_T   heap_rem_size;",
                "    LIB_ERR      lib_err;"
            ],
            "added_lines": [
                "            CPU_BOOLEAN  rtn_val;",
                "            CPU_INT32U   path_len_max;",
                "    static  NET_SOCK_ID  ctrl_sock_id;",
                "            CPU_INT32U   max_path_name_len;",
                "            CPU_SIZE_T   heap_rem_size;",
                "            LIB_ERR      lib_err;"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-14032",
        "func_name": "Mbed-TLS/mbedtls/mbedtls_x509_crt_verify_with_profile",
        "description": "ARM mbed TLS before 1.3.21 and 2.x before 2.1.9, if optional authentication is configured, allows remote attackers to bypass peer authentication via an X.509 certificate chain with many intermediates. NOTE: although mbed TLS was formerly known as PolarSSL, the releases shipped with the PolarSSL name are not affected.",
        "git_url": "https://github.com/Mbed-TLS/mbedtls/commit/d15795acd5074e0b44e71f7ede8bdfe1b48591fc",
        "commit_title": "Improve behaviour on fatal errors",
        "commit_text": " If we didn't walk the whole chain, then there may be any kind of errors in the part of the chain we didn't check, so setting all flags looks like the safe thing to do.",
        "func_before": "int mbedtls_x509_crt_verify_with_profile( mbedtls_x509_crt *crt,\n                     mbedtls_x509_crt *trust_ca,\n                     mbedtls_x509_crl *ca_crl,\n                     const mbedtls_x509_crt_profile *profile,\n                     const char *cn, uint32_t *flags,\n                     int (*f_vrfy)(void *, mbedtls_x509_crt *, int, uint32_t *),\n                     void *p_vrfy )\n{\n    size_t cn_len;\n    int ret;\n    int pathlen = 0, selfsigned = 0;\n    mbedtls_x509_crt *parent;\n    mbedtls_x509_name *name;\n    mbedtls_x509_sequence *cur = NULL;\n    mbedtls_pk_type_t pk_type;\n\n    if( profile == NULL )\n        return( MBEDTLS_ERR_X509_BAD_INPUT_DATA );\n\n    *flags = 0;\n\n    if( cn != NULL )\n    {\n        name = &crt->subject;\n        cn_len = strlen( cn );\n\n        if( crt->ext_types & MBEDTLS_X509_EXT_SUBJECT_ALT_NAME )\n        {\n            cur = &crt->subject_alt_names;\n\n            while( cur != NULL )\n            {\n                if( cur->buf.len == cn_len &&\n                    x509_memcasecmp( cn, cur->buf.p, cn_len ) == 0 )\n                    break;\n\n                if( cur->buf.len > 2 &&\n                    memcmp( cur->buf.p, \"*.\", 2 ) == 0 &&\n                    x509_check_wildcard( cn, &cur->buf ) == 0 )\n                {\n                    break;\n                }\n\n                cur = cur->next;\n            }\n\n            if( cur == NULL )\n                *flags |= MBEDTLS_X509_BADCERT_CN_MISMATCH;\n        }\n        else\n        {\n            while( name != NULL )\n            {\n                if( MBEDTLS_OID_CMP( MBEDTLS_OID_AT_CN, &name->oid ) == 0 )\n                {\n                    if( name->val.len == cn_len &&\n                        x509_memcasecmp( name->val.p, cn, cn_len ) == 0 )\n                        break;\n\n                    if( name->val.len > 2 &&\n                        memcmp( name->val.p, \"*.\", 2 ) == 0 &&\n                        x509_check_wildcard( cn, &name->val ) == 0 )\n                        break;\n                }\n\n                name = name->next;\n            }\n\n            if( name == NULL )\n                *flags |= MBEDTLS_X509_BADCERT_CN_MISMATCH;\n        }\n    }\n\n    /* Check the type and size of the key */\n    pk_type = mbedtls_pk_get_type( &crt->pk );\n\n    if( x509_profile_check_pk_alg( profile, pk_type ) != 0 )\n        *flags |= MBEDTLS_X509_BADCERT_BAD_PK;\n\n    if( x509_profile_check_key( profile, pk_type, &crt->pk ) != 0 )\n        *flags |= MBEDTLS_X509_BADCERT_BAD_KEY;\n\n    /* Look for a parent in trusted CAs */\n    for( parent = trust_ca; parent != NULL; parent = parent->next )\n    {\n        if( x509_crt_check_parent( crt, parent, 0, pathlen == 0 ) == 0 )\n            break;\n    }\n\n    if( parent != NULL )\n    {\n        ret = x509_crt_verify_top( crt, parent, ca_crl, profile,\n                                   pathlen, selfsigned, flags, f_vrfy, p_vrfy );\n        if( ret != 0 )\n            return( ret );\n    }\n    else\n    {\n        /* Look for a parent upwards the chain */\n        for( parent = crt->next; parent != NULL; parent = parent->next )\n            if( x509_crt_check_parent( crt, parent, 0, pathlen == 0 ) == 0 )\n                break;\n\n        /* Are we part of the chain or at the top? */\n        if( parent != NULL )\n        {\n            ret = x509_crt_verify_child( crt, parent, trust_ca, ca_crl, profile,\n                                         pathlen, selfsigned, flags, f_vrfy, p_vrfy );\n            if( ret != 0 )\n                return( ret );\n        }\n        else\n        {\n            ret = x509_crt_verify_top( crt, trust_ca, ca_crl, profile,\n                                       pathlen, selfsigned, flags, f_vrfy, p_vrfy );\n            if( ret != 0 )\n                return( ret );\n        }\n    }\n\n    if( *flags != 0 )\n        return( MBEDTLS_ERR_X509_CERT_VERIFY_FAILED );\n\n    return( 0 );\n}",
        "func": "int mbedtls_x509_crt_verify_with_profile( mbedtls_x509_crt *crt,\n                     mbedtls_x509_crt *trust_ca,\n                     mbedtls_x509_crl *ca_crl,\n                     const mbedtls_x509_crt_profile *profile,\n                     const char *cn, uint32_t *flags,\n                     int (*f_vrfy)(void *, mbedtls_x509_crt *, int, uint32_t *),\n                     void *p_vrfy )\n{\n    size_t cn_len;\n    int ret;\n    int pathlen = 0, selfsigned = 0;\n    mbedtls_x509_crt *parent;\n    mbedtls_x509_name *name;\n    mbedtls_x509_sequence *cur = NULL;\n    mbedtls_pk_type_t pk_type;\n\n    *flags = 0;\n\n    if( profile == NULL )\n    {\n        ret = MBEDTLS_ERR_X509_BAD_INPUT_DATA;\n        goto exit;\n    }\n\n    if( cn != NULL )\n    {\n        name = &crt->subject;\n        cn_len = strlen( cn );\n\n        if( crt->ext_types & MBEDTLS_X509_EXT_SUBJECT_ALT_NAME )\n        {\n            cur = &crt->subject_alt_names;\n\n            while( cur != NULL )\n            {\n                if( cur->buf.len == cn_len &&\n                    x509_memcasecmp( cn, cur->buf.p, cn_len ) == 0 )\n                    break;\n\n                if( cur->buf.len > 2 &&\n                    memcmp( cur->buf.p, \"*.\", 2 ) == 0 &&\n                    x509_check_wildcard( cn, &cur->buf ) == 0 )\n                {\n                    break;\n                }\n\n                cur = cur->next;\n            }\n\n            if( cur == NULL )\n                *flags |= MBEDTLS_X509_BADCERT_CN_MISMATCH;\n        }\n        else\n        {\n            while( name != NULL )\n            {\n                if( MBEDTLS_OID_CMP( MBEDTLS_OID_AT_CN, &name->oid ) == 0 )\n                {\n                    if( name->val.len == cn_len &&\n                        x509_memcasecmp( name->val.p, cn, cn_len ) == 0 )\n                        break;\n\n                    if( name->val.len > 2 &&\n                        memcmp( name->val.p, \"*.\", 2 ) == 0 &&\n                        x509_check_wildcard( cn, &name->val ) == 0 )\n                        break;\n                }\n\n                name = name->next;\n            }\n\n            if( name == NULL )\n                *flags |= MBEDTLS_X509_BADCERT_CN_MISMATCH;\n        }\n    }\n\n    /* Check the type and size of the key */\n    pk_type = mbedtls_pk_get_type( &crt->pk );\n\n    if( x509_profile_check_pk_alg( profile, pk_type ) != 0 )\n        *flags |= MBEDTLS_X509_BADCERT_BAD_PK;\n\n    if( x509_profile_check_key( profile, pk_type, &crt->pk ) != 0 )\n        *flags |= MBEDTLS_X509_BADCERT_BAD_KEY;\n\n    /* Look for a parent in trusted CAs */\n    for( parent = trust_ca; parent != NULL; parent = parent->next )\n    {\n        if( x509_crt_check_parent( crt, parent, 0, pathlen == 0 ) == 0 )\n            break;\n    }\n\n    if( parent != NULL )\n    {\n        ret = x509_crt_verify_top( crt, parent, ca_crl, profile,\n                                   pathlen, selfsigned, flags, f_vrfy, p_vrfy );\n        if( ret != 0 )\n            goto exit;\n    }\n    else\n    {\n        /* Look for a parent upwards the chain */\n        for( parent = crt->next; parent != NULL; parent = parent->next )\n            if( x509_crt_check_parent( crt, parent, 0, pathlen == 0 ) == 0 )\n                break;\n\n        /* Are we part of the chain or at the top? */\n        if( parent != NULL )\n        {\n            ret = x509_crt_verify_child( crt, parent, trust_ca, ca_crl, profile,\n                                         pathlen, selfsigned, flags, f_vrfy, p_vrfy );\n            if( ret != 0 )\n                goto exit;\n        }\n        else\n        {\n            ret = x509_crt_verify_top( crt, trust_ca, ca_crl, profile,\n                                       pathlen, selfsigned, flags, f_vrfy, p_vrfy );\n            if( ret != 0 )\n                goto exit;\n        }\n    }\n\nexit:\n    if( ret != 0 )\n    {\n        *flags = (uint32_t) -1;\n        return( ret );\n    }\n\n    if( *flags != 0 )\n        return( MBEDTLS_ERR_X509_CERT_VERIFY_FAILED );\n\n    return( 0 );\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -14,10 +14,13 @@\n     mbedtls_x509_sequence *cur = NULL;\n     mbedtls_pk_type_t pk_type;\n \n+    *flags = 0;\n+\n     if( profile == NULL )\n-        return( MBEDTLS_ERR_X509_BAD_INPUT_DATA );\n-\n-    *flags = 0;\n+    {\n+        ret = MBEDTLS_ERR_X509_BAD_INPUT_DATA;\n+        goto exit;\n+    }\n \n     if( cn != NULL )\n     {\n@@ -92,7 +95,7 @@\n         ret = x509_crt_verify_top( crt, parent, ca_crl, profile,\n                                    pathlen, selfsigned, flags, f_vrfy, p_vrfy );\n         if( ret != 0 )\n-            return( ret );\n+            goto exit;\n     }\n     else\n     {\n@@ -107,15 +110,22 @@\n             ret = x509_crt_verify_child( crt, parent, trust_ca, ca_crl, profile,\n                                          pathlen, selfsigned, flags, f_vrfy, p_vrfy );\n             if( ret != 0 )\n-                return( ret );\n+                goto exit;\n         }\n         else\n         {\n             ret = x509_crt_verify_top( crt, trust_ca, ca_crl, profile,\n                                        pathlen, selfsigned, flags, f_vrfy, p_vrfy );\n             if( ret != 0 )\n-                return( ret );\n+                goto exit;\n         }\n+    }\n+\n+exit:\n+    if( ret != 0 )\n+    {\n+        *flags = (uint32_t) -1;\n+        return( ret );\n     }\n \n     if( *flags != 0 )",
        "diff_line_info": {
            "deleted_lines": [
                "        return( MBEDTLS_ERR_X509_BAD_INPUT_DATA );",
                "",
                "    *flags = 0;",
                "            return( ret );",
                "                return( ret );",
                "                return( ret );"
            ],
            "added_lines": [
                "    *flags = 0;",
                "",
                "    {",
                "        ret = MBEDTLS_ERR_X509_BAD_INPUT_DATA;",
                "        goto exit;",
                "    }",
                "            goto exit;",
                "                goto exit;",
                "                goto exit;",
                "    }",
                "",
                "exit:",
                "    if( ret != 0 )",
                "    {",
                "        *flags = (uint32_t) -1;",
                "        return( ret );"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-14032",
        "func_name": "Mbed-TLS/mbedtls/x509_crt_verify_child",
        "description": "ARM mbed TLS before 1.3.21 and 2.x before 2.1.9, if optional authentication is configured, allows remote attackers to bypass peer authentication via an X.509 certificate chain with many intermediates. NOTE: although mbed TLS was formerly known as PolarSSL, the releases shipped with the PolarSSL name are not affected.",
        "git_url": "https://github.com/Mbed-TLS/mbedtls/commit/31458a18788b0cf0b722acda9bb2f2fe13a3fb32",
        "commit_title": "Only return VERIFY_FAILED from a single point",
        "commit_text": " Everything else is a fatal error. Also improve documentation about that for the vrfy callback.",
        "func_before": "static int x509_crt_verify_child(\n                mbedtls_x509_crt *child, mbedtls_x509_crt *parent,\n                mbedtls_x509_crt *trust_ca, mbedtls_x509_crl *ca_crl,\n                const mbedtls_x509_crt_profile *profile,\n                int path_cnt, int self_cnt, uint32_t *flags,\n                int (*f_vrfy)(void *, mbedtls_x509_crt *, int, uint32_t *),\n                void *p_vrfy )\n{\n    int ret;\n    uint32_t parent_flags = 0;\n    unsigned char hash[MBEDTLS_MD_MAX_SIZE];\n    mbedtls_x509_crt *grandparent;\n    const mbedtls_md_info_t *md_info;\n\n    /* Counting intermediate self signed certificates */\n    if( ( path_cnt != 0 ) && x509_name_cmp( &child->issuer, &child->subject ) == 0 )\n        self_cnt++;\n\n    /* path_cnt is 0 for the first intermediate CA */\n    if( 1 + path_cnt > MBEDTLS_X509_MAX_INTERMEDIATE_CA )\n    {\n        *flags |= MBEDTLS_X509_BADCERT_NOT_TRUSTED;\n        return( MBEDTLS_ERR_X509_CERT_VERIFY_FAILED );\n    }\n\n    if( mbedtls_x509_time_is_past( &child->valid_to ) )\n        *flags |= MBEDTLS_X509_BADCERT_EXPIRED;\n\n    if( mbedtls_x509_time_is_future( &child->valid_from ) )\n        *flags |= MBEDTLS_X509_BADCERT_FUTURE;\n\n    if( x509_profile_check_md_alg( profile, child->sig_md ) != 0 )\n        *flags |= MBEDTLS_X509_BADCERT_BAD_MD;\n\n    if( x509_profile_check_pk_alg( profile, child->sig_pk ) != 0 )\n        *flags |= MBEDTLS_X509_BADCERT_BAD_PK;\n\n    md_info = mbedtls_md_info_from_type( child->sig_md );\n    if( md_info == NULL )\n    {\n        /*\n         * Cannot check 'unknown' hash\n         */\n        *flags |= MBEDTLS_X509_BADCERT_NOT_TRUSTED;\n    }\n    else\n    {\n        mbedtls_md( md_info, child->tbs.p, child->tbs.len, hash );\n\n        if( x509_profile_check_key( profile, child->sig_pk, &parent->pk ) != 0 )\n            *flags |= MBEDTLS_X509_BADCERT_BAD_KEY;\n\n        if( mbedtls_pk_verify_ext( child->sig_pk, child->sig_opts, &parent->pk,\n                           child->sig_md, hash, mbedtls_md_get_size( md_info ),\n                           child->sig.p, child->sig.len ) != 0 )\n        {\n            *flags |= MBEDTLS_X509_BADCERT_NOT_TRUSTED;\n        }\n    }\n\n#if defined(MBEDTLS_X509_CRL_PARSE_C)\n    /* Check trusted CA's CRL for the given crt */\n    *flags |= x509_crt_verifycrl(child, parent, ca_crl, profile );\n#endif\n\n    /* Look for a grandparent in trusted CAs */\n    for( grandparent = trust_ca;\n         grandparent != NULL;\n         grandparent = grandparent->next )\n    {\n        if( x509_crt_check_parent( parent, grandparent,\n                                   0, path_cnt == 0 ) == 0 )\n            break;\n    }\n\n    if( grandparent != NULL )\n    {\n        ret = x509_crt_verify_top( parent, grandparent, ca_crl, profile,\n                                path_cnt + 1, self_cnt, &parent_flags, f_vrfy, p_vrfy );\n        if( ret != 0 )\n            return( ret );\n    }\n    else\n    {\n        /* Look for a grandparent upwards the chain */\n        for( grandparent = parent->next;\n             grandparent != NULL;\n             grandparent = grandparent->next )\n        {\n            /* +2 because the current step is not yet accounted for\n             * and because max_pathlen is one higher than it should be.\n             * Also self signed certificates do not count to the limit. */\n            if( grandparent->max_pathlen > 0 &&\n                grandparent->max_pathlen < 2 + path_cnt - self_cnt )\n            {\n                continue;\n            }\n\n            if( x509_crt_check_parent( parent, grandparent,\n                                       0, path_cnt == 0 ) == 0 )\n                break;\n        }\n\n        /* Is our parent part of the chain or at the top? */\n        if( grandparent != NULL )\n        {\n            ret = x509_crt_verify_child( parent, grandparent, trust_ca, ca_crl,\n                                         profile, path_cnt + 1, self_cnt, &parent_flags,\n                                         f_vrfy, p_vrfy );\n            if( ret != 0 )\n                return( ret );\n        }\n        else\n        {\n            ret = x509_crt_verify_top( parent, trust_ca, ca_crl, profile,\n                                       path_cnt + 1, self_cnt, &parent_flags,\n                                       f_vrfy, p_vrfy );\n            if( ret != 0 )\n                return( ret );\n        }\n    }\n\n    /* child is verified to be a child of the parent, call verify callback */\n    if( NULL != f_vrfy )\n        if( ( ret = f_vrfy( p_vrfy, child, path_cnt, flags ) ) != 0 )\n            return( ret );\n\n    *flags |= parent_flags;\n\n    return( 0 );\n}",
        "func": "static int x509_crt_verify_child(\n                mbedtls_x509_crt *child, mbedtls_x509_crt *parent,\n                mbedtls_x509_crt *trust_ca, mbedtls_x509_crl *ca_crl,\n                const mbedtls_x509_crt_profile *profile,\n                int path_cnt, int self_cnt, uint32_t *flags,\n                int (*f_vrfy)(void *, mbedtls_x509_crt *, int, uint32_t *),\n                void *p_vrfy )\n{\n    int ret;\n    uint32_t parent_flags = 0;\n    unsigned char hash[MBEDTLS_MD_MAX_SIZE];\n    mbedtls_x509_crt *grandparent;\n    const mbedtls_md_info_t *md_info;\n\n    /* Counting intermediate self signed certificates */\n    if( ( path_cnt != 0 ) && x509_name_cmp( &child->issuer, &child->subject ) == 0 )\n        self_cnt++;\n\n    /* path_cnt is 0 for the first intermediate CA */\n    if( 1 + path_cnt > MBEDTLS_X509_MAX_INTERMEDIATE_CA )\n    {\n        /* return immediately as the goal is to avoid unbounded recursion */\n        return( MBEDTLS_ERR_X509_FATAL_ERROR );\n    }\n\n    if( mbedtls_x509_time_is_past( &child->valid_to ) )\n        *flags |= MBEDTLS_X509_BADCERT_EXPIRED;\n\n    if( mbedtls_x509_time_is_future( &child->valid_from ) )\n        *flags |= MBEDTLS_X509_BADCERT_FUTURE;\n\n    if( x509_profile_check_md_alg( profile, child->sig_md ) != 0 )\n        *flags |= MBEDTLS_X509_BADCERT_BAD_MD;\n\n    if( x509_profile_check_pk_alg( profile, child->sig_pk ) != 0 )\n        *flags |= MBEDTLS_X509_BADCERT_BAD_PK;\n\n    md_info = mbedtls_md_info_from_type( child->sig_md );\n    if( md_info == NULL )\n    {\n        /*\n         * Cannot check 'unknown' hash\n         */\n        *flags |= MBEDTLS_X509_BADCERT_NOT_TRUSTED;\n    }\n    else\n    {\n        mbedtls_md( md_info, child->tbs.p, child->tbs.len, hash );\n\n        if( x509_profile_check_key( profile, child->sig_pk, &parent->pk ) != 0 )\n            *flags |= MBEDTLS_X509_BADCERT_BAD_KEY;\n\n        if( mbedtls_pk_verify_ext( child->sig_pk, child->sig_opts, &parent->pk,\n                           child->sig_md, hash, mbedtls_md_get_size( md_info ),\n                           child->sig.p, child->sig.len ) != 0 )\n        {\n            *flags |= MBEDTLS_X509_BADCERT_NOT_TRUSTED;\n        }\n    }\n\n#if defined(MBEDTLS_X509_CRL_PARSE_C)\n    /* Check trusted CA's CRL for the given crt */\n    *flags |= x509_crt_verifycrl(child, parent, ca_crl, profile );\n#endif\n\n    /* Look for a grandparent in trusted CAs */\n    for( grandparent = trust_ca;\n         grandparent != NULL;\n         grandparent = grandparent->next )\n    {\n        if( x509_crt_check_parent( parent, grandparent,\n                                   0, path_cnt == 0 ) == 0 )\n            break;\n    }\n\n    if( grandparent != NULL )\n    {\n        ret = x509_crt_verify_top( parent, grandparent, ca_crl, profile,\n                                path_cnt + 1, self_cnt, &parent_flags, f_vrfy, p_vrfy );\n        if( ret != 0 )\n            return( ret );\n    }\n    else\n    {\n        /* Look for a grandparent upwards the chain */\n        for( grandparent = parent->next;\n             grandparent != NULL;\n             grandparent = grandparent->next )\n        {\n            /* +2 because the current step is not yet accounted for\n             * and because max_pathlen is one higher than it should be.\n             * Also self signed certificates do not count to the limit. */\n            if( grandparent->max_pathlen > 0 &&\n                grandparent->max_pathlen < 2 + path_cnt - self_cnt )\n            {\n                continue;\n            }\n\n            if( x509_crt_check_parent( parent, grandparent,\n                                       0, path_cnt == 0 ) == 0 )\n                break;\n        }\n\n        /* Is our parent part of the chain or at the top? */\n        if( grandparent != NULL )\n        {\n            ret = x509_crt_verify_child( parent, grandparent, trust_ca, ca_crl,\n                                         profile, path_cnt + 1, self_cnt, &parent_flags,\n                                         f_vrfy, p_vrfy );\n            if( ret != 0 )\n                return( ret );\n        }\n        else\n        {\n            ret = x509_crt_verify_top( parent, trust_ca, ca_crl, profile,\n                                       path_cnt + 1, self_cnt, &parent_flags,\n                                       f_vrfy, p_vrfy );\n            if( ret != 0 )\n                return( ret );\n        }\n    }\n\n    /* child is verified to be a child of the parent, call verify callback */\n    if( NULL != f_vrfy )\n        if( ( ret = f_vrfy( p_vrfy, child, path_cnt, flags ) ) != 0 )\n            return( ret );\n\n    *flags |= parent_flags;\n\n    return( 0 );\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -19,8 +19,8 @@\n     /* path_cnt is 0 for the first intermediate CA */\n     if( 1 + path_cnt > MBEDTLS_X509_MAX_INTERMEDIATE_CA )\n     {\n-        *flags |= MBEDTLS_X509_BADCERT_NOT_TRUSTED;\n-        return( MBEDTLS_ERR_X509_CERT_VERIFY_FAILED );\n+        /* return immediately as the goal is to avoid unbounded recursion */\n+        return( MBEDTLS_ERR_X509_FATAL_ERROR );\n     }\n \n     if( mbedtls_x509_time_is_past( &child->valid_to ) )",
        "diff_line_info": {
            "deleted_lines": [
                "        *flags |= MBEDTLS_X509_BADCERT_NOT_TRUSTED;",
                "        return( MBEDTLS_ERR_X509_CERT_VERIFY_FAILED );"
            ],
            "added_lines": [
                "        /* return immediately as the goal is to avoid unbounded recursion */",
                "        return( MBEDTLS_ERR_X509_FATAL_ERROR );"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-14032",
        "func_name": "Mbed-TLS/mbedtls/mbedtls_x509_crt_verify_with_profile",
        "description": "ARM mbed TLS before 1.3.21 and 2.x before 2.1.9, if optional authentication is configured, allows remote attackers to bypass peer authentication via an X.509 certificate chain with many intermediates. NOTE: although mbed TLS was formerly known as PolarSSL, the releases shipped with the PolarSSL name are not affected.",
        "git_url": "https://github.com/Mbed-TLS/mbedtls/commit/31458a18788b0cf0b722acda9bb2f2fe13a3fb32",
        "commit_title": "Only return VERIFY_FAILED from a single point",
        "commit_text": " Everything else is a fatal error. Also improve documentation about that for the vrfy callback.",
        "func_before": "int mbedtls_x509_crt_verify_with_profile( mbedtls_x509_crt *crt,\n                     mbedtls_x509_crt *trust_ca,\n                     mbedtls_x509_crl *ca_crl,\n                     const mbedtls_x509_crt_profile *profile,\n                     const char *cn, uint32_t *flags,\n                     int (*f_vrfy)(void *, mbedtls_x509_crt *, int, uint32_t *),\n                     void *p_vrfy )\n{\n    size_t cn_len;\n    int ret;\n    int pathlen = 0, selfsigned = 0;\n    mbedtls_x509_crt *parent;\n    mbedtls_x509_name *name;\n    mbedtls_x509_sequence *cur = NULL;\n    mbedtls_pk_type_t pk_type;\n\n    *flags = 0;\n\n    if( profile == NULL )\n    {\n        ret = MBEDTLS_ERR_X509_BAD_INPUT_DATA;\n        goto exit;\n    }\n\n    if( cn != NULL )\n    {\n        name = &crt->subject;\n        cn_len = strlen( cn );\n\n        if( crt->ext_types & MBEDTLS_X509_EXT_SUBJECT_ALT_NAME )\n        {\n            cur = &crt->subject_alt_names;\n\n            while( cur != NULL )\n            {\n                if( cur->buf.len == cn_len &&\n                    x509_memcasecmp( cn, cur->buf.p, cn_len ) == 0 )\n                    break;\n\n                if( cur->buf.len > 2 &&\n                    memcmp( cur->buf.p, \"*.\", 2 ) == 0 &&\n                    x509_check_wildcard( cn, &cur->buf ) == 0 )\n                {\n                    break;\n                }\n\n                cur = cur->next;\n            }\n\n            if( cur == NULL )\n                *flags |= MBEDTLS_X509_BADCERT_CN_MISMATCH;\n        }\n        else\n        {\n            while( name != NULL )\n            {\n                if( MBEDTLS_OID_CMP( MBEDTLS_OID_AT_CN, &name->oid ) == 0 )\n                {\n                    if( name->val.len == cn_len &&\n                        x509_memcasecmp( name->val.p, cn, cn_len ) == 0 )\n                        break;\n\n                    if( name->val.len > 2 &&\n                        memcmp( name->val.p, \"*.\", 2 ) == 0 &&\n                        x509_check_wildcard( cn, &name->val ) == 0 )\n                        break;\n                }\n\n                name = name->next;\n            }\n\n            if( name == NULL )\n                *flags |= MBEDTLS_X509_BADCERT_CN_MISMATCH;\n        }\n    }\n\n    /* Check the type and size of the key */\n    pk_type = mbedtls_pk_get_type( &crt->pk );\n\n    if( x509_profile_check_pk_alg( profile, pk_type ) != 0 )\n        *flags |= MBEDTLS_X509_BADCERT_BAD_PK;\n\n    if( x509_profile_check_key( profile, pk_type, &crt->pk ) != 0 )\n        *flags |= MBEDTLS_X509_BADCERT_BAD_KEY;\n\n    /* Look for a parent in trusted CAs */\n    for( parent = trust_ca; parent != NULL; parent = parent->next )\n    {\n        if( x509_crt_check_parent( crt, parent, 0, pathlen == 0 ) == 0 )\n            break;\n    }\n\n    if( parent != NULL )\n    {\n        ret = x509_crt_verify_top( crt, parent, ca_crl, profile,\n                                   pathlen, selfsigned, flags, f_vrfy, p_vrfy );\n        if( ret != 0 )\n            goto exit;\n    }\n    else\n    {\n        /* Look for a parent upwards the chain */\n        for( parent = crt->next; parent != NULL; parent = parent->next )\n            if( x509_crt_check_parent( crt, parent, 0, pathlen == 0 ) == 0 )\n                break;\n\n        /* Are we part of the chain or at the top? */\n        if( parent != NULL )\n        {\n            ret = x509_crt_verify_child( crt, parent, trust_ca, ca_crl, profile,\n                                         pathlen, selfsigned, flags, f_vrfy, p_vrfy );\n            if( ret != 0 )\n                goto exit;\n        }\n        else\n        {\n            ret = x509_crt_verify_top( crt, trust_ca, ca_crl, profile,\n                                       pathlen, selfsigned, flags, f_vrfy, p_vrfy );\n            if( ret != 0 )\n                goto exit;\n        }\n    }\n\nexit:\n    if( ret != 0 )\n    {\n        *flags = (uint32_t) -1;\n        return( ret );\n    }\n\n    if( *flags != 0 )\n        return( MBEDTLS_ERR_X509_CERT_VERIFY_FAILED );\n\n    return( 0 );\n}",
        "func": "int mbedtls_x509_crt_verify_with_profile( mbedtls_x509_crt *crt,\n                     mbedtls_x509_crt *trust_ca,\n                     mbedtls_x509_crl *ca_crl,\n                     const mbedtls_x509_crt_profile *profile,\n                     const char *cn, uint32_t *flags,\n                     int (*f_vrfy)(void *, mbedtls_x509_crt *, int, uint32_t *),\n                     void *p_vrfy )\n{\n    size_t cn_len;\n    int ret;\n    int pathlen = 0, selfsigned = 0;\n    mbedtls_x509_crt *parent;\n    mbedtls_x509_name *name;\n    mbedtls_x509_sequence *cur = NULL;\n    mbedtls_pk_type_t pk_type;\n\n    *flags = 0;\n\n    if( profile == NULL )\n    {\n        ret = MBEDTLS_ERR_X509_BAD_INPUT_DATA;\n        goto exit;\n    }\n\n    if( cn != NULL )\n    {\n        name = &crt->subject;\n        cn_len = strlen( cn );\n\n        if( crt->ext_types & MBEDTLS_X509_EXT_SUBJECT_ALT_NAME )\n        {\n            cur = &crt->subject_alt_names;\n\n            while( cur != NULL )\n            {\n                if( cur->buf.len == cn_len &&\n                    x509_memcasecmp( cn, cur->buf.p, cn_len ) == 0 )\n                    break;\n\n                if( cur->buf.len > 2 &&\n                    memcmp( cur->buf.p, \"*.\", 2 ) == 0 &&\n                    x509_check_wildcard( cn, &cur->buf ) == 0 )\n                {\n                    break;\n                }\n\n                cur = cur->next;\n            }\n\n            if( cur == NULL )\n                *flags |= MBEDTLS_X509_BADCERT_CN_MISMATCH;\n        }\n        else\n        {\n            while( name != NULL )\n            {\n                if( MBEDTLS_OID_CMP( MBEDTLS_OID_AT_CN, &name->oid ) == 0 )\n                {\n                    if( name->val.len == cn_len &&\n                        x509_memcasecmp( name->val.p, cn, cn_len ) == 0 )\n                        break;\n\n                    if( name->val.len > 2 &&\n                        memcmp( name->val.p, \"*.\", 2 ) == 0 &&\n                        x509_check_wildcard( cn, &name->val ) == 0 )\n                        break;\n                }\n\n                name = name->next;\n            }\n\n            if( name == NULL )\n                *flags |= MBEDTLS_X509_BADCERT_CN_MISMATCH;\n        }\n    }\n\n    /* Check the type and size of the key */\n    pk_type = mbedtls_pk_get_type( &crt->pk );\n\n    if( x509_profile_check_pk_alg( profile, pk_type ) != 0 )\n        *flags |= MBEDTLS_X509_BADCERT_BAD_PK;\n\n    if( x509_profile_check_key( profile, pk_type, &crt->pk ) != 0 )\n        *flags |= MBEDTLS_X509_BADCERT_BAD_KEY;\n\n    /* Look for a parent in trusted CAs */\n    for( parent = trust_ca; parent != NULL; parent = parent->next )\n    {\n        if( x509_crt_check_parent( crt, parent, 0, pathlen == 0 ) == 0 )\n            break;\n    }\n\n    if( parent != NULL )\n    {\n        ret = x509_crt_verify_top( crt, parent, ca_crl, profile,\n                                   pathlen, selfsigned, flags, f_vrfy, p_vrfy );\n        if( ret != 0 )\n            goto exit;\n    }\n    else\n    {\n        /* Look for a parent upwards the chain */\n        for( parent = crt->next; parent != NULL; parent = parent->next )\n            if( x509_crt_check_parent( crt, parent, 0, pathlen == 0 ) == 0 )\n                break;\n\n        /* Are we part of the chain or at the top? */\n        if( parent != NULL )\n        {\n            ret = x509_crt_verify_child( crt, parent, trust_ca, ca_crl, profile,\n                                         pathlen, selfsigned, flags, f_vrfy, p_vrfy );\n            if( ret != 0 )\n                goto exit;\n        }\n        else\n        {\n            ret = x509_crt_verify_top( crt, trust_ca, ca_crl, profile,\n                                       pathlen, selfsigned, flags, f_vrfy, p_vrfy );\n            if( ret != 0 )\n                goto exit;\n        }\n    }\n\nexit:\n    /* prevent misuse of the vrfy callback */\n    if( ret == MBEDTLS_ERR_X509_CERT_VERIFY_FAILED )\n        ret = MBEDTLS_ERR_X509_FATAL_ERROR;\n\n    if( ret != 0 )\n    {\n        *flags = (uint32_t) -1;\n        return( ret );\n    }\n\n    if( *flags != 0 )\n        return( MBEDTLS_ERR_X509_CERT_VERIFY_FAILED );\n\n    return( 0 );\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -122,6 +122,10 @@\n     }\n \n exit:\n+    /* prevent misuse of the vrfy callback */\n+    if( ret == MBEDTLS_ERR_X509_CERT_VERIFY_FAILED )\n+        ret = MBEDTLS_ERR_X509_FATAL_ERROR;\n+\n     if( ret != 0 )\n     {\n         *flags = (uint32_t) -1;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    /* prevent misuse of the vrfy callback */",
                "    if( ret == MBEDTLS_ERR_X509_CERT_VERIFY_FAILED )",
                "        ret = MBEDTLS_ERR_X509_FATAL_ERROR;",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2021-45379",
        "func_name": "babelouest/glewlwyd/callback_glewlwyd_user_auth",
        "description": "Glewlwyd 2.0.0, fixed in 2.6.1 is affected by an incorrect access control vulnerability. One user can attempt to log in as another user without its password.",
        "git_url": "https://github.com/babelouest/glewlwyd/commit/125281f1c0d4b6a8b49f7e55a757205a2ef01fbe",
        "commit_title": "Fix update session when auth fail",
        "commit_text": "",
        "func_before": "int callback_glewlwyd_user_auth (const struct _u_request * request, struct _u_response * response, void * user_data) {\n  struct config_elements * config = (struct config_elements *)user_data;\n  json_t * j_param = ulfius_get_json_body_request(request, NULL), * j_result = NULL;\n  const char * ip_source = get_ip_source(request);\n  char * issued_for = get_client_hostname(request);\n  char * session_uid, expires[129];\n  time_t now;\n  struct tm ts;\n  \n  time(&now);\n  now += GLEWLWYD_DEFAULT_SESSION_EXPIRATION_COOKIE;\n  gmtime_r(&now, &ts);\n  strftime(expires, 128, \"%a, %d %b %Y %T %Z\", &ts);\n  if (j_param != NULL) {\n    if (json_string_length(json_object_get(j_param, \"username\"))) {\n      if (json_object_get(j_param, \"scheme_type\") == NULL || 0 == o_strcmp(json_string_value(json_object_get(j_param, \"scheme_type\")), \"password\")) {\n        if (json_string_length(json_object_get(j_param, \"password\"))) {\n          j_result = auth_check_user_credentials(config, json_string_value(json_object_get(j_param, \"username\")), json_string_value(json_object_get(j_param, \"password\")));\n          if (check_result_value(j_result, G_OK)) {\n            if ((session_uid = get_session_id(config, request)) == NULL) {\n              session_uid = generate_session_id();\n            }\n            if (user_session_update(config, session_uid, u_map_get_case(request->map_header, \"user-agent\"), issued_for, json_string_value(json_object_get(j_param, \"username\")), NULL, 1) != G_OK) {\n              y_log_message(Y_LOG_LEVEL_ERROR, \"callback_glewlwyd_user_auth - Error user_session_update (1)\");\n              response->status = 500;\n            } else {\n              ulfius_add_cookie_to_response(response, config->session_key, session_uid, expires, 0, config->cookie_domain, \"/\", config->cookie_secure, 0);\n              y_log_message(Y_LOG_LEVEL_INFO, \"Event - User '%s' authenticated with password\", json_string_value(json_object_get(j_param, \"username\")));\n            }\n            o_free(session_uid);\n            glewlwyd_metrics_increment_counter_va(config, GLWD_METRICS_AUTH_USER_VALID, 1, NULL);\n            glewlwyd_metrics_increment_counter_va(config, GLWD_METRICS_AUTH_USER_VALID_SCHEME, 1, \"scheme_type\", \"password\", NULL);\n          } else {\n            if (check_result_value(j_result, G_ERROR_UNAUTHORIZED)) {\n              y_log_message(Y_LOG_LEVEL_WARNING, \"Security - Authorization invalid for username %s at IP Address %s\", json_string_value(json_object_get(j_param, \"username\")), ip_source);\n            }\n            if ((session_uid = get_session_id(config, request)) != NULL && user_session_update(config, session_uid, u_map_get_case(request->map_header, \"user-agent\"), issued_for, json_string_value(json_object_get(j_param, \"username\")), NULL, 1) != G_OK) {\n              y_log_message(Y_LOG_LEVEL_ERROR, \"callback_glewlwyd_user_auth - Error user_session_update (2)\");\n            }\n            o_free(session_uid);\n            response->status = 401;\n            glewlwyd_metrics_increment_counter_va(config, GLWD_METRICS_AUTH_USER_INVALID, 1, NULL);\n            glewlwyd_metrics_increment_counter_va(config, GLWD_METRICS_AUTH_USER_INVALID_SCHEME, 1, \"scheme_type\", \"password\", NULL);\n          }\n          json_decref(j_result);\n        } else if (json_object_get(j_param, \"password\") != NULL && !json_is_string(json_object_get(j_param, \"password\"))) {\n          ulfius_set_string_body_response(response, 400, \"password must be a string\");\n        } else {\n          session_uid = get_session_id(config, request);\n          j_result = get_users_for_session(config, session_uid);\n          if (check_result_value(j_result, G_OK)) {\n            // Refresh username to set as default\n            if (user_session_update(config, u_map_get(request->map_cookie, config->session_key), u_map_get_case(request->map_header, \"user-agent\"), issued_for, json_string_value(json_object_get(j_param, \"username\")), NULL, 0) != G_OK) {\n              y_log_message(Y_LOG_LEVEL_ERROR, \"callback_glewlwyd_user_auth - Error user_session_update (3)\");\n              response->status = 500;\n            } else {\n              ulfius_add_cookie_to_response(response, config->session_key, session_uid, expires, 0, config->cookie_domain, \"/\", config->cookie_secure, 0);\n            }\n          } else if (check_result_value(j_result, G_ERROR_NOT_FOUND)) {\n            response->status = 401;\n          } else {\n            y_log_message(Y_LOG_LEVEL_ERROR, \"callback_glewlwyd_user_auth - Error get_users_for_session\");\n            response->status = 500;\n          }\n          o_free(session_uid);\n          json_decref(j_result);\n        }\n      } else {\n        if (json_string_length(json_object_get(j_param, \"scheme_type\")) && json_string_length(json_object_get(j_param, \"scheme_name\")) && json_is_object(json_object_get(j_param, \"value\"))) {\n          j_result = auth_check_user_scheme(config, json_string_value(json_object_get(j_param, \"scheme_type\")), json_string_value(json_object_get(j_param, \"scheme_name\")), json_string_value(json_object_get(j_param, \"username\")), json_object_get(j_param, \"value\"), request);\n          if (check_result_value(j_result, G_ERROR_PARAM)) {\n            ulfius_set_string_body_response(response, 400, \"bad scheme response\");\n          } else if (check_result_value(j_result, G_ERROR_UNAUTHORIZED)) {\n            y_log_message(Y_LOG_LEVEL_WARNING, \"Security - Authorization invalid for username %s at IP Address %s\", json_string_value(json_object_get(j_param, \"username\")), ip_source);\n            response->status = 401;\n            glewlwyd_metrics_increment_counter_va(config, GLWD_METRICS_AUTH_USER_INVALID, 1, NULL);\n            glewlwyd_metrics_increment_counter_va(config, GLWD_METRICS_AUTH_USER_INVALID_SCHEME, 1, \"scheme_type\", json_string_value(json_object_get(j_param, \"scheme_type\")), \"scheme_name\", json_string_value(json_object_get(j_param, \"scheme_name\")), NULL);\n          } else if (check_result_value(j_result, G_ERROR_NOT_FOUND)) {\n            response->status = 404;\n          } else if (check_result_value(j_result, G_OK)) {\n            if ((session_uid = get_session_id(config, request)) == NULL) {\n              session_uid = generate_session_id();\n            }\n            if (user_session_update(config, session_uid, u_map_get_case(request->map_header, \"user-agent\"), issued_for, json_string_value(json_object_get(j_param, \"username\")), json_string_value(json_object_get(j_param, \"scheme_name\")), 1) != G_OK) {\n              y_log_message(Y_LOG_LEVEL_ERROR, \"callback_glewlwyd_user_auth - Error user_session_update (4)\");\n              response->status = 500;\n            } else {\n              ulfius_add_cookie_to_response(response, config->session_key, session_uid, expires, 0, config->cookie_domain, \"/\", config->cookie_secure, 0);\n              y_log_message(Y_LOG_LEVEL_INFO, \"Event - User '%s' authenticated with scheme '%s/%s'\", json_string_value(json_object_get(j_param, \"username\")), json_string_value(json_object_get(j_param, \"scheme_type\")), json_string_value(json_object_get(j_param, \"scheme_name\")));\n            }\n            o_free(session_uid);\n            glewlwyd_metrics_increment_counter_va(config, GLWD_METRICS_AUTH_USER_VALID, 1, NULL);\n            glewlwyd_metrics_increment_counter_va(config, GLWD_METRICS_AUTH_USER_VALID_SCHEME, 1, \"scheme_type\", json_string_value(json_object_get(j_param, \"scheme_type\")), \"scheme_name\", json_string_value(json_object_get(j_param, \"scheme_name\")), NULL);\n          } else {\n            y_log_message(Y_LOG_LEVEL_ERROR, \"callback_glewlwyd_user_auth - Error auth_check_user_scheme\");\n            response->status = 500;\n          }\n          json_decref(j_result);\n        } else {\n          ulfius_set_string_body_response(response, 400, \"scheme_type, scheme_name and value are mandatory\");\n        }\n      }\n    } else {\n      if (json_string_length(json_object_get(j_param, \"scheme_type\")) && json_string_length(json_object_get(j_param, \"scheme_name\")) && json_is_object(json_object_get(j_param, \"value\"))) {\n        j_result = auth_check_identify_scheme(config, json_string_value(json_object_get(j_param, \"scheme_type\")), json_string_value(json_object_get(j_param, \"scheme_name\")), json_object_get(j_param, \"value\"), request);\n        if (check_result_value(j_result, G_ERROR_PARAM)) {\n          ulfius_set_string_body_response(response, 400, \"bad scheme response\");\n        } else if (check_result_value(j_result, G_ERROR_UNAUTHORIZED)) {\n          y_log_message(Y_LOG_LEVEL_WARNING, \"Security - Authorization invalid for username <UNKNOWN> at IP Address %s\", ip_source);\n          response->status = 401;\n        } else if (check_result_value(j_result, G_ERROR_NOT_FOUND)) {\n          response->status = 404;\n        } else if (check_result_value(j_result, G_OK)) {\n          if ((session_uid = get_session_id(config, request)) == NULL) {\n            session_uid = generate_session_id();\n          }\n          if (user_session_update(config, session_uid, u_map_get_case(request->map_header, \"user-agent\"), issued_for, json_string_value(json_object_get(j_result, \"username\")), json_string_value(json_object_get(j_param, \"scheme_name\")), 1) != G_OK) {\n            y_log_message(Y_LOG_LEVEL_ERROR, \"callback_glewlwyd_user_auth - Error user_session_update (4)\");\n            response->status = 500;\n          } else {\n            ulfius_add_cookie_to_response(response, config->session_key, session_uid, expires, 0, config->cookie_domain, \"/\", config->cookie_secure, 0);\n            y_log_message(Y_LOG_LEVEL_INFO, \"Event - User '%s' authenticated with scheme '%s/%s'\", json_string_value(json_object_get(j_result, \"username\")), json_string_value(json_object_get(j_param, \"scheme_type\")), json_string_value(json_object_get(j_param, \"scheme_name\")));\n          }\n          o_free(session_uid);\n        } else {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"callback_glewlwyd_user_auth - Error auth_check_user_scheme\");\n          response->status = 500;\n        }\n        json_decref(j_result);\n      } else {\n        ulfius_set_string_body_response(response, 400, \"username is mandatory\");\n      }\n    }\n  } else {\n    ulfius_set_string_body_response(response, 400, \"Input parameters must be in JSON format\");\n  }\n  json_decref(j_param);\n  o_free(issued_for);\n\n  return U_CALLBACK_CONTINUE;\n}",
        "func": "int callback_glewlwyd_user_auth (const struct _u_request * request, struct _u_response * response, void * user_data) {\n  struct config_elements * config = (struct config_elements *)user_data;\n  json_t * j_param = ulfius_get_json_body_request(request, NULL), * j_result = NULL;\n  const char * ip_source = get_ip_source(request);\n  char * issued_for = get_client_hostname(request);\n  char * session_uid, expires[129];\n  time_t now;\n  struct tm ts;\n  \n  time(&now);\n  now += GLEWLWYD_DEFAULT_SESSION_EXPIRATION_COOKIE;\n  gmtime_r(&now, &ts);\n  strftime(expires, 128, \"%a, %d %b %Y %T %Z\", &ts);\n  if (j_param != NULL) {\n    if (json_string_length(json_object_get(j_param, \"username\"))) {\n      if (json_object_get(j_param, \"scheme_type\") == NULL || 0 == o_strcmp(json_string_value(json_object_get(j_param, \"scheme_type\")), \"password\")) {\n        if (json_string_length(json_object_get(j_param, \"password\"))) {\n          j_result = auth_check_user_credentials(config, json_string_value(json_object_get(j_param, \"username\")), json_string_value(json_object_get(j_param, \"password\")));\n          if (check_result_value(j_result, G_OK)) {\n            if ((session_uid = get_session_id(config, request)) == NULL) {\n              session_uid = generate_session_id();\n            }\n            if (user_session_update(config, session_uid, u_map_get_case(request->map_header, \"user-agent\"), issued_for, json_string_value(json_object_get(j_param, \"username\")), NULL, 1) != G_OK) {\n              y_log_message(Y_LOG_LEVEL_ERROR, \"callback_glewlwyd_user_auth - Error user_session_update (1)\");\n              response->status = 500;\n            } else {\n              ulfius_add_cookie_to_response(response, config->session_key, session_uid, expires, 0, config->cookie_domain, \"/\", config->cookie_secure, 0);\n              y_log_message(Y_LOG_LEVEL_INFO, \"Event - User '%s' authenticated with password\", json_string_value(json_object_get(j_param, \"username\")));\n            }\n            o_free(session_uid);\n            glewlwyd_metrics_increment_counter_va(config, GLWD_METRICS_AUTH_USER_VALID, 1, NULL);\n            glewlwyd_metrics_increment_counter_va(config, GLWD_METRICS_AUTH_USER_VALID_SCHEME, 1, \"scheme_type\", \"password\", NULL);\n          } else {\n            if (check_result_value(j_result, G_ERROR_UNAUTHORIZED)) {\n              y_log_message(Y_LOG_LEVEL_WARNING, \"Security - Authorization invalid for username %s at IP Address %s\", json_string_value(json_object_get(j_param, \"username\")), ip_source);\n            }\n            response->status = 401;\n            glewlwyd_metrics_increment_counter_va(config, GLWD_METRICS_AUTH_USER_INVALID, 1, NULL);\n            glewlwyd_metrics_increment_counter_va(config, GLWD_METRICS_AUTH_USER_INVALID_SCHEME, 1, \"scheme_type\", \"password\", NULL);\n          }\n          json_decref(j_result);\n        } else if (json_object_get(j_param, \"password\") != NULL && !json_is_string(json_object_get(j_param, \"password\"))) {\n          ulfius_set_string_body_response(response, 400, \"password must be a string\");\n        } else {\n          session_uid = get_session_id(config, request);\n          j_result = get_users_for_session(config, session_uid);\n          if (check_result_value(j_result, G_OK)) {\n            // Refresh username to set as default\n            if (user_session_update(config, u_map_get(request->map_cookie, config->session_key), u_map_get_case(request->map_header, \"user-agent\"), issued_for, json_string_value(json_object_get(j_param, \"username\")), NULL, 0) != G_OK) {\n              y_log_message(Y_LOG_LEVEL_ERROR, \"callback_glewlwyd_user_auth - Error user_session_update (3)\");\n              response->status = 500;\n            } else {\n              ulfius_add_cookie_to_response(response, config->session_key, session_uid, expires, 0, config->cookie_domain, \"/\", config->cookie_secure, 0);\n            }\n          } else if (check_result_value(j_result, G_ERROR_NOT_FOUND)) {\n            response->status = 401;\n          } else {\n            y_log_message(Y_LOG_LEVEL_ERROR, \"callback_glewlwyd_user_auth - Error get_users_for_session\");\n            response->status = 500;\n          }\n          o_free(session_uid);\n          json_decref(j_result);\n        }\n      } else {\n        if (json_string_length(json_object_get(j_param, \"scheme_type\")) && json_string_length(json_object_get(j_param, \"scheme_name\")) && json_is_object(json_object_get(j_param, \"value\"))) {\n          j_result = auth_check_user_scheme(config, json_string_value(json_object_get(j_param, \"scheme_type\")), json_string_value(json_object_get(j_param, \"scheme_name\")), json_string_value(json_object_get(j_param, \"username\")), json_object_get(j_param, \"value\"), request);\n          if (check_result_value(j_result, G_ERROR_PARAM)) {\n            ulfius_set_string_body_response(response, 400, \"bad scheme response\");\n          } else if (check_result_value(j_result, G_ERROR_UNAUTHORIZED)) {\n            y_log_message(Y_LOG_LEVEL_WARNING, \"Security - Authorization invalid for username %s at IP Address %s\", json_string_value(json_object_get(j_param, \"username\")), ip_source);\n            response->status = 401;\n            glewlwyd_metrics_increment_counter_va(config, GLWD_METRICS_AUTH_USER_INVALID, 1, NULL);\n            glewlwyd_metrics_increment_counter_va(config, GLWD_METRICS_AUTH_USER_INVALID_SCHEME, 1, \"scheme_type\", json_string_value(json_object_get(j_param, \"scheme_type\")), \"scheme_name\", json_string_value(json_object_get(j_param, \"scheme_name\")), NULL);\n          } else if (check_result_value(j_result, G_ERROR_NOT_FOUND)) {\n            response->status = 404;\n          } else if (check_result_value(j_result, G_OK)) {\n            if ((session_uid = get_session_id(config, request)) == NULL) {\n              session_uid = generate_session_id();\n            }\n            if (user_session_update(config, session_uid, u_map_get_case(request->map_header, \"user-agent\"), issued_for, json_string_value(json_object_get(j_param, \"username\")), json_string_value(json_object_get(j_param, \"scheme_name\")), 1) != G_OK) {\n              y_log_message(Y_LOG_LEVEL_ERROR, \"callback_glewlwyd_user_auth - Error user_session_update (4)\");\n              response->status = 500;\n            } else {\n              ulfius_add_cookie_to_response(response, config->session_key, session_uid, expires, 0, config->cookie_domain, \"/\", config->cookie_secure, 0);\n              y_log_message(Y_LOG_LEVEL_INFO, \"Event - User '%s' authenticated with scheme '%s/%s'\", json_string_value(json_object_get(j_param, \"username\")), json_string_value(json_object_get(j_param, \"scheme_type\")), json_string_value(json_object_get(j_param, \"scheme_name\")));\n            }\n            o_free(session_uid);\n            glewlwyd_metrics_increment_counter_va(config, GLWD_METRICS_AUTH_USER_VALID, 1, NULL);\n            glewlwyd_metrics_increment_counter_va(config, GLWD_METRICS_AUTH_USER_VALID_SCHEME, 1, \"scheme_type\", json_string_value(json_object_get(j_param, \"scheme_type\")), \"scheme_name\", json_string_value(json_object_get(j_param, \"scheme_name\")), NULL);\n          } else {\n            y_log_message(Y_LOG_LEVEL_ERROR, \"callback_glewlwyd_user_auth - Error auth_check_user_scheme\");\n            response->status = 500;\n          }\n          json_decref(j_result);\n        } else {\n          ulfius_set_string_body_response(response, 400, \"scheme_type, scheme_name and value are mandatory\");\n        }\n      }\n    } else {\n      if (json_string_length(json_object_get(j_param, \"scheme_type\")) && json_string_length(json_object_get(j_param, \"scheme_name\")) && json_is_object(json_object_get(j_param, \"value\"))) {\n        j_result = auth_check_identify_scheme(config, json_string_value(json_object_get(j_param, \"scheme_type\")), json_string_value(json_object_get(j_param, \"scheme_name\")), json_object_get(j_param, \"value\"), request);\n        if (check_result_value(j_result, G_ERROR_PARAM)) {\n          ulfius_set_string_body_response(response, 400, \"bad scheme response\");\n        } else if (check_result_value(j_result, G_ERROR_UNAUTHORIZED)) {\n          y_log_message(Y_LOG_LEVEL_WARNING, \"Security - Authorization invalid for username <UNKNOWN> at IP Address %s\", ip_source);\n          response->status = 401;\n        } else if (check_result_value(j_result, G_ERROR_NOT_FOUND)) {\n          response->status = 404;\n        } else if (check_result_value(j_result, G_OK)) {\n          if ((session_uid = get_session_id(config, request)) == NULL) {\n            session_uid = generate_session_id();\n          }\n          if (user_session_update(config, session_uid, u_map_get_case(request->map_header, \"user-agent\"), issued_for, json_string_value(json_object_get(j_result, \"username\")), json_string_value(json_object_get(j_param, \"scheme_name\")), 1) != G_OK) {\n            y_log_message(Y_LOG_LEVEL_ERROR, \"callback_glewlwyd_user_auth - Error user_session_update (4)\");\n            response->status = 500;\n          } else {\n            ulfius_add_cookie_to_response(response, config->session_key, session_uid, expires, 0, config->cookie_domain, \"/\", config->cookie_secure, 0);\n            y_log_message(Y_LOG_LEVEL_INFO, \"Event - User '%s' authenticated with scheme '%s/%s'\", json_string_value(json_object_get(j_result, \"username\")), json_string_value(json_object_get(j_param, \"scheme_type\")), json_string_value(json_object_get(j_param, \"scheme_name\")));\n          }\n          o_free(session_uid);\n        } else {\n          y_log_message(Y_LOG_LEVEL_ERROR, \"callback_glewlwyd_user_auth - Error auth_check_user_scheme\");\n          response->status = 500;\n        }\n        json_decref(j_result);\n      } else {\n        ulfius_set_string_body_response(response, 400, \"username is mandatory\");\n      }\n    }\n  } else {\n    ulfius_set_string_body_response(response, 400, \"Input parameters must be in JSON format\");\n  }\n  json_decref(j_param);\n  o_free(issued_for);\n\n  return U_CALLBACK_CONTINUE;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -34,10 +34,6 @@\n             if (check_result_value(j_result, G_ERROR_UNAUTHORIZED)) {\n               y_log_message(Y_LOG_LEVEL_WARNING, \"Security - Authorization invalid for username %s at IP Address %s\", json_string_value(json_object_get(j_param, \"username\")), ip_source);\n             }\n-            if ((session_uid = get_session_id(config, request)) != NULL && user_session_update(config, session_uid, u_map_get_case(request->map_header, \"user-agent\"), issued_for, json_string_value(json_object_get(j_param, \"username\")), NULL, 1) != G_OK) {\n-              y_log_message(Y_LOG_LEVEL_ERROR, \"callback_glewlwyd_user_auth - Error user_session_update (2)\");\n-            }\n-            o_free(session_uid);\n             response->status = 401;\n             glewlwyd_metrics_increment_counter_va(config, GLWD_METRICS_AUTH_USER_INVALID, 1, NULL);\n             glewlwyd_metrics_increment_counter_va(config, GLWD_METRICS_AUTH_USER_INVALID_SCHEME, 1, \"scheme_type\", \"password\", NULL);",
        "diff_line_info": {
            "deleted_lines": [
                "            if ((session_uid = get_session_id(config, request)) != NULL && user_session_update(config, session_uid, u_map_get_case(request->map_header, \"user-agent\"), issued_for, json_string_value(json_object_get(j_param, \"username\")), NULL, 1) != G_OK) {",
                "              y_log_message(Y_LOG_LEVEL_ERROR, \"callback_glewlwyd_user_auth - Error user_session_update (2)\");",
                "            }",
                "            o_free(session_uid);"
            ],
            "added_lines": []
        }
    },
    {
        "cve_id": "CVE-2017-6413",
        "func_name": "OpenIDC/mod_auth_openidc/oidc_scrub_headers",
        "description": "The \"OpenID Connect Relying Party and OAuth 2.0 Resource Server\" (aka mod_auth_openidc) module before 2.1.6 for the Apache HTTP Server does not skip OIDC_CLAIM_ and OIDCAuthNHeader headers in an \"AuthType oauth20\" configuration, which allows remote attackers to bypass authentication via crafted HTTP traffic.",
        "git_url": "https://github.com/OpenIDC/mod_auth_openidc/commit/21e3728a825c41ab41efa75e664108051bb9665e",
        "commit_title": "release 2.1.6 : security fix: scrub headers for \"AuthType oauth20\"",
        "commit_text": "",
        "func_before": "static void oidc_scrub_headers(request_rec *r) {\n\toidc_cfg *cfg = ap_get_module_config(r->server->module_config,\n\t\t\t&auth_openidc_module);\n\n\tif (cfg->scrub_request_headers != 0) {\n\n\t\t/* scrub all headers starting with OIDC_ first */\n\t\toidc_scrub_request_headers(r, OIDC_DEFAULT_HEADER_PREFIX,\n\t\t\t\toidc_cfg_dir_authn_header(r));\n\n\t\t/*\n\t\t * then see if the claim headers need to be removed on top of that\n\t\t * (i.e. the prefix does not start with the default OIDC_)\n\t\t */\n\t\tif ((strstr(cfg->claim_prefix, OIDC_DEFAULT_HEADER_PREFIX)\n\t\t\t\t!= cfg->claim_prefix)) {\n\t\t\toidc_scrub_request_headers(r, cfg->claim_prefix, NULL);\n\t\t}\n\t}\n}",
        "func": "void oidc_scrub_headers(request_rec *r) {\n\toidc_cfg *cfg = ap_get_module_config(r->server->module_config,\n\t\t\t&auth_openidc_module);\n\n\tif (cfg->scrub_request_headers != 0) {\n\n\t\t/* scrub all headers starting with OIDC_ first */\n\t\toidc_scrub_request_headers(r, OIDC_DEFAULT_HEADER_PREFIX,\n\t\t\t\toidc_cfg_dir_authn_header(r));\n\n\t\t/*\n\t\t * then see if the claim headers need to be removed on top of that\n\t\t * (i.e. the prefix does not start with the default OIDC_)\n\t\t */\n\t\tif ((strstr(cfg->claim_prefix, OIDC_DEFAULT_HEADER_PREFIX)\n\t\t\t\t!= cfg->claim_prefix)) {\n\t\t\toidc_scrub_request_headers(r, cfg->claim_prefix, NULL);\n\t\t}\n\t}\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,4 @@\n-static void oidc_scrub_headers(request_rec *r) {\n+void oidc_scrub_headers(request_rec *r) {\n \toidc_cfg *cfg = ap_get_module_config(r->server->module_config,\n \t\t\t&auth_openidc_module);\n ",
        "diff_line_info": {
            "deleted_lines": [
                "static void oidc_scrub_headers(request_rec *r) {"
            ],
            "added_lines": [
                "void oidc_scrub_headers(request_rec *r) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-6413",
        "func_name": "OpenIDC/mod_auth_openidc/oidc_oauth_check_userid",
        "description": "The \"OpenID Connect Relying Party and OAuth 2.0 Resource Server\" (aka mod_auth_openidc) module before 2.1.6 for the Apache HTTP Server does not skip OIDC_CLAIM_ and OIDCAuthNHeader headers in an \"AuthType oauth20\" configuration, which allows remote attackers to bypass authentication via crafted HTTP traffic.",
        "git_url": "https://github.com/OpenIDC/mod_auth_openidc/commit/21e3728a825c41ab41efa75e664108051bb9665e",
        "commit_title": "release 2.1.6 : security fix: scrub headers for \"AuthType oauth20\"",
        "commit_text": "",
        "func_before": "int oidc_oauth_check_userid(request_rec *r, oidc_cfg *c) {\n\n\t/* check if this is a sub-request or an initial request */\n\tif (!ap_is_initial_req(r)) {\n\n\t\tif (r->main != NULL)\n\t\t\tr->user = r->main->user;\n\t\telse if (r->prev != NULL)\n\t\t\tr->user = r->prev->user;\n\n\t\tif (r->user != NULL) {\n\n\t\t\t/* this is a sub-request and we have a session */\n\t\t\toidc_debug(r,\n\t\t\t\t\t\"recycling user '%s' from initial request for sub-request\",\n\t\t\t\t\tr->user);\n\n\t\t\treturn OK;\n\t\t}\n\n\t\t/* check if this is a request for the public (encryption) keys */\n\t} else if ((c->redirect_uri != NULL)\n\t\t\t&& (oidc_util_request_matches_url(r, c->redirect_uri))) {\n\n\t\tif (oidc_util_request_has_parameter(r, \"jwks\")) {\n\n\t\t\treturn oidc_handle_jwks(r, c);\n\n\t\t}\n\n\t}\n\n\t/* we don't have a session yet */\n\n\t/* get the bearer access token from the Authorization header */\n\tconst char *access_token = NULL;\n\tif (oidc_oauth_get_bearer_token(r, &access_token) == FALSE)\n\t\treturn oidc_oauth_return_www_authenticate(r, \"invalid_request\",\n\t\t\t\t\"No bearer token found in the request\");\n\n\t/* validate the obtained access token against the OAuth AS validation endpoint */\n\tjson_t *token = NULL;\n\tchar *s_token = NULL;\n\n\t/* check if an introspection endpoint is set */\n\tif (c->oauth.introspection_endpoint_url != NULL) {\n\t\t/* we'll validate the token remotely */\n\t\tif (oidc_oauth_resolve_access_token(r, c, access_token, &token,\n\t\t\t\t&s_token) == FALSE)\n\t\t\treturn oidc_oauth_return_www_authenticate(r, \"invalid_token\",\n\t\t\t\t\t\"Reference token could not be introspected\");\n\t} else {\n\t\t/* no introspection endpoint is set, assume the token is a JWT and validate it locally */\n\t\tif (oidc_oauth_validate_jwt_access_token(r, c, access_token, &token,\n\t\t\t\t&s_token) == FALSE)\n\t\t\treturn oidc_oauth_return_www_authenticate(r, \"invalid_token\",\n\t\t\t\t\t\"JWT token could not be validated\");\n\t}\n\n\t/* check that we've got something back */\n\tif (token == NULL) {\n\t\toidc_error(r, \"could not resolve claims (token == NULL)\");\n\t\treturn oidc_oauth_return_www_authenticate(r, \"invalid_token\",\n\t\t\t\t\"No claims could be parsed from the token\");\n\t}\n\n\t/* store the parsed token (cq. the claims from the response) in the request state so it can be accessed by the authz routines */\n\toidc_request_state_set(r, OIDC_CLAIMS_SESSION_KEY, (const char *) s_token);\n\n\t/* set the REMOTE_USER variable */\n\tif (oidc_oauth_set_remote_user(r, c, token) == FALSE) {\n\t\toidc_error(r,\n\t\t\t\t\"remote user could not be set, aborting with HTTP_UNAUTHORIZED\");\n\t\treturn oidc_oauth_return_www_authenticate(r, \"invalid_token\",\n\t\t\t\t\"Could not set remote user\");\n\t}\n\n\t/* set the user authentication HTTP header if set and required */\n\tchar *authn_header = oidc_cfg_dir_authn_header(r);\n\tint pass_headers = oidc_cfg_dir_pass_info_in_headers(r);\n\tint pass_envvars = oidc_cfg_dir_pass_info_in_envvars(r);\n\n\tif ((r->user != NULL) && (authn_header != NULL)) {\n\t\toidc_debug(r, \"setting authn header (%s) to: %s\", authn_header,\n\t\t\t\tr->user);\n\t\tapr_table_set(r->headers_in, authn_header, r->user);\n\t}\n\n\t/* set the resolved claims in the HTTP headers for the target application */\n\toidc_util_set_app_infos(r, token, c->claim_prefix, c->claim_delimiter,\n\t\t\tpass_headers, pass_envvars);\n\n\t/* set the access_token in the app headers */\n\tif (access_token != NULL) {\n\t\toidc_util_set_app_info(r, \"access_token\", access_token,\n\t\t\t\tOIDC_DEFAULT_HEADER_PREFIX, pass_headers, pass_envvars);\n\t}\n\n\t/* free JSON resources */\n\tjson_decref(token);\n\n\treturn OK;\n}",
        "func": "int oidc_oauth_check_userid(request_rec *r, oidc_cfg *c) {\n\n\t/* check if this is a sub-request or an initial request */\n\tif (!ap_is_initial_req(r)) {\n\n\t\tif (r->main != NULL)\n\t\t\tr->user = r->main->user;\n\t\telse if (r->prev != NULL)\n\t\t\tr->user = r->prev->user;\n\n\t\tif (r->user != NULL) {\n\n\t\t\t/* this is a sub-request and we have a session */\n\t\t\toidc_debug(r,\n\t\t\t\t\t\"recycling user '%s' from initial request for sub-request\",\n\t\t\t\t\tr->user);\n\n\t\t\treturn OK;\n\t\t}\n\n\t\t/* check if this is a request for the public (encryption) keys */\n\t} else if ((c->redirect_uri != NULL)\n\t\t\t&& (oidc_util_request_matches_url(r, c->redirect_uri))) {\n\n\t\tif (oidc_util_request_has_parameter(r, \"jwks\")) {\n\n\t\t\treturn oidc_handle_jwks(r, c);\n\n\t\t}\n\n\t}\n\n\t/* we don't have a session yet */\n\n\t/* get the bearer access token from the Authorization header */\n\tconst char *access_token = NULL;\n\tif (oidc_oauth_get_bearer_token(r, &access_token) == FALSE)\n\t\treturn oidc_oauth_return_www_authenticate(r, \"invalid_request\",\n\t\t\t\t\"No bearer token found in the request\");\n\n\t/* validate the obtained access token against the OAuth AS validation endpoint */\n\tjson_t *token = NULL;\n\tchar *s_token = NULL;\n\n\t/* check if an introspection endpoint is set */\n\tif (c->oauth.introspection_endpoint_url != NULL) {\n\t\t/* we'll validate the token remotely */\n\t\tif (oidc_oauth_resolve_access_token(r, c, access_token, &token,\n\t\t\t\t&s_token) == FALSE)\n\t\t\treturn oidc_oauth_return_www_authenticate(r, \"invalid_token\",\n\t\t\t\t\t\"Reference token could not be introspected\");\n\t} else {\n\t\t/* no introspection endpoint is set, assume the token is a JWT and validate it locally */\n\t\tif (oidc_oauth_validate_jwt_access_token(r, c, access_token, &token,\n\t\t\t\t&s_token) == FALSE)\n\t\t\treturn oidc_oauth_return_www_authenticate(r, \"invalid_token\",\n\t\t\t\t\t\"JWT token could not be validated\");\n\t}\n\n\t/* check that we've got something back */\n\tif (token == NULL) {\n\t\toidc_error(r, \"could not resolve claims (token == NULL)\");\n\t\treturn oidc_oauth_return_www_authenticate(r, \"invalid_token\",\n\t\t\t\t\"No claims could be parsed from the token\");\n\t}\n\n\t/* store the parsed token (cq. the claims from the response) in the request state so it can be accessed by the authz routines */\n\toidc_request_state_set(r, OIDC_CLAIMS_SESSION_KEY, (const char *) s_token);\n\n\t/* set the REMOTE_USER variable */\n\tif (oidc_oauth_set_remote_user(r, c, token) == FALSE) {\n\t\toidc_error(r,\n\t\t\t\t\"remote user could not be set, aborting with HTTP_UNAUTHORIZED\");\n\t\treturn oidc_oauth_return_www_authenticate(r, \"invalid_token\",\n\t\t\t\t\"Could not set remote user\");\n\t}\n\n\t/*\n\t * we're going to pass the information that we have to the application,\n\t * but first we need to scrub the headers that we're going to use for security reasons\n\t */\n\toidc_scrub_headers(r);\n\n\t/* set the user authentication HTTP header if set and required */\n\tchar *authn_header = oidc_cfg_dir_authn_header(r);\n\tint pass_headers = oidc_cfg_dir_pass_info_in_headers(r);\n\tint pass_envvars = oidc_cfg_dir_pass_info_in_envvars(r);\n\n\tif ((r->user != NULL) && (authn_header != NULL)) {\n\t\toidc_debug(r, \"setting authn header (%s) to: %s\", authn_header,\n\t\t\t\tr->user);\n\t\tapr_table_set(r->headers_in, authn_header, r->user);\n\t}\n\n\t/* set the resolved claims in the HTTP headers for the target application */\n\toidc_util_set_app_infos(r, token, c->claim_prefix, c->claim_delimiter,\n\t\t\tpass_headers, pass_envvars);\n\n\t/* set the access_token in the app headers */\n\tif (access_token != NULL) {\n\t\toidc_util_set_app_info(r, \"access_token\", access_token,\n\t\t\t\tOIDC_DEFAULT_HEADER_PREFIX, pass_headers, pass_envvars);\n\t}\n\n\t/* free JSON resources */\n\tjson_decref(token);\n\n\treturn OK;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -75,6 +75,12 @@\n \t\t\t\t\"Could not set remote user\");\n \t}\n \n+\t/*\n+\t * we're going to pass the information that we have to the application,\n+\t * but first we need to scrub the headers that we're going to use for security reasons\n+\t */\n+\toidc_scrub_headers(r);\n+\n \t/* set the user authentication HTTP header if set and required */\n \tchar *authn_header = oidc_cfg_dir_authn_header(r);\n \tint pass_headers = oidc_cfg_dir_pass_info_in_headers(r);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t/*",
                "\t * we're going to pass the information that we have to the application,",
                "\t * but first we need to scrub the headers that we're going to use for security reasons",
                "\t */",
                "\toidc_scrub_headers(r);",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2008-1897",
        "func_name": "xrg/asterisk-xrg/find_callno",
        "description": "The IAX2 channel driver (chan_iax2) in Asterisk Open Source 1.0.x, 1.2.x before 1.2.28, and 1.4.x before 1.4.19.1; Business Edition A.x.x, B.x.x before B.2.5.2, and C.x.x before C.1.8.1; AsteriskNOW before 1.0.3; Appliance Developer Kit 0.x.x; and s800i before 1.1.0.3, when configured to allow unauthenticated calls, does not verify that an ACK response contains a call number matching the server's reply to a NEW message, which allows remote attackers to cause a denial of service (traffic amplification) via a spoofed ACK response that does not complete a 3-way handshake.  NOTE: this issue exists because of an incomplete fix for CVE-2008-1923.",
        "git_url": "https://github.com/xrg/asterisk-xrg/commit/10da3dab24e8ca08cf2c983f8d0206e383535b5a",
        "commit_title": "When we receive a full frame that is supposed to contain our call number,",
        "commit_text": "ensure that it has the correct one. (closes issue #10078) (AST-2008-006)",
        "func_before": "static int find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd) {\n\n\treturn __find_callno(callno, dcallno, sin, new, sockfd, 0);\n}",
        "func": "static int find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int full_frame) {\n\n\treturn __find_callno(callno, dcallno, sin, new, sockfd, 0, full_frame);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,4 @@\n-static int find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd) {\n+static int find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int full_frame) {\n \n-\treturn __find_callno(callno, dcallno, sin, new, sockfd, 0);\n+\treturn __find_callno(callno, dcallno, sin, new, sockfd, 0, full_frame);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "static int find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd) {",
                "\treturn __find_callno(callno, dcallno, sin, new, sockfd, 0);"
            ],
            "added_lines": [
                "static int find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int full_frame) {",
                "\treturn __find_callno(callno, dcallno, sin, new, sockfd, 0, full_frame);"
            ]
        }
    },
    {
        "cve_id": "CVE-2008-1897",
        "func_name": "xrg/asterisk-xrg/iax2_do_register",
        "description": "The IAX2 channel driver (chan_iax2) in Asterisk Open Source 1.0.x, 1.2.x before 1.2.28, and 1.4.x before 1.4.19.1; Business Edition A.x.x, B.x.x before B.2.5.2, and C.x.x before C.1.8.1; AsteriskNOW before 1.0.3; Appliance Developer Kit 0.x.x; and s800i before 1.1.0.3, when configured to allow unauthenticated calls, does not verify that an ACK response contains a call number matching the server's reply to a NEW message, which allows remote attackers to cause a denial of service (traffic amplification) via a spoofed ACK response that does not complete a 3-way handshake.  NOTE: this issue exists because of an incomplete fix for CVE-2008-1923.",
        "git_url": "https://github.com/xrg/asterisk-xrg/commit/10da3dab24e8ca08cf2c983f8d0206e383535b5a",
        "commit_title": "When we receive a full frame that is supposed to contain our call number,",
        "commit_text": "ensure that it has the correct one. (closes issue #10078) (AST-2008-006)",
        "func_before": "static int iax2_do_register(struct iax2_registry *reg)\n{\n\tstruct iax_ie_data ied;\n\tif (option_debug && iaxdebug)\n\t\tast_log(LOG_DEBUG, \"Sending registration request for '%s'\\n\", reg->username);\n\n\tif (reg->dnsmgr && \n\t    ((reg->regstate == REG_STATE_TIMEOUT) || !reg->addr.sin_addr.s_addr)) {\n\t\t/* Maybe the IP has changed, force DNS refresh */\n\t\tast_dnsmgr_refresh(reg->dnsmgr);\n\t}\n\t\n\t/*\n\t * if IP has Changed, free allocated call to create a new one with new IP\n\t * call has the pointer to IP and must be updated to the new one\n\t */\n\tif (reg->dnsmgr && ast_dnsmgr_changed(reg->dnsmgr) && (reg->callno > 0)) {\n\t\tast_mutex_lock(&iaxsl[reg->callno]);\n\t\tiax2_destroy(reg->callno);\n\t\tast_mutex_unlock(&iaxsl[reg->callno]);\n\t\treg->callno = 0;\n\t}\n\tif (!reg->addr.sin_addr.s_addr) {\n\t\tif (option_debug && iaxdebug)\n\t\t\tast_log(LOG_DEBUG, \"Unable to send registration request for '%s' without IP address\\n\", reg->username);\n\t\t/* Setup the next registration attempt */\n\t\tAST_SCHED_DEL(sched, reg->expire);\n\t\treg->expire  = iax2_sched_add(sched, (5 * reg->refresh / 6) * 1000, iax2_do_register_s, reg);\n\t\treturn -1;\n\t}\n\n\tif (!reg->callno) {\n\t\tif (option_debug)\n\t\t\tast_log(LOG_DEBUG, \"Allocate call number\\n\");\n\t\treg->callno = find_callno_locked(0, 0, &reg->addr, NEW_FORCE, defaultsockfd);\n\t\tif (reg->callno < 1) {\n\t\t\tast_log(LOG_WARNING, \"Unable to create call for registration\\n\");\n\t\t\treturn -1;\n\t\t} else if (option_debug)\n\t\t\tast_log(LOG_DEBUG, \"Registration created on call %d\\n\", reg->callno);\n\t\tiaxs[reg->callno]->reg = reg;\n\t\tast_mutex_unlock(&iaxsl[reg->callno]);\n\t}\n\t/* Schedule the next registration attempt */\n\tAST_SCHED_DEL(sched, reg->expire);\n\t/* Setup the next registration a little early */\n\treg->expire  = iax2_sched_add(sched, (5 * reg->refresh / 6) * 1000, iax2_do_register_s, reg);\n\t/* Send the request */\n\tmemset(&ied, 0, sizeof(ied));\n\tiax_ie_append_str(&ied, IAX_IE_USERNAME, reg->username);\n\tiax_ie_append_short(&ied, IAX_IE_REFRESH, reg->refresh);\n\tsend_command(iaxs[reg->callno],AST_FRAME_IAX, IAX_COMMAND_REGREQ, 0, ied.buf, ied.pos, -1);\n\treg->regstate = REG_STATE_REGSENT;\n\treturn 0;\n}",
        "func": "static int iax2_do_register(struct iax2_registry *reg)\n{\n\tstruct iax_ie_data ied;\n\tif (option_debug && iaxdebug)\n\t\tast_log(LOG_DEBUG, \"Sending registration request for '%s'\\n\", reg->username);\n\n\tif (reg->dnsmgr && \n\t    ((reg->regstate == REG_STATE_TIMEOUT) || !reg->addr.sin_addr.s_addr)) {\n\t\t/* Maybe the IP has changed, force DNS refresh */\n\t\tast_dnsmgr_refresh(reg->dnsmgr);\n\t}\n\t\n\t/*\n\t * if IP has Changed, free allocated call to create a new one with new IP\n\t * call has the pointer to IP and must be updated to the new one\n\t */\n\tif (reg->dnsmgr && ast_dnsmgr_changed(reg->dnsmgr) && (reg->callno > 0)) {\n\t\tast_mutex_lock(&iaxsl[reg->callno]);\n\t\tiax2_destroy(reg->callno);\n\t\tast_mutex_unlock(&iaxsl[reg->callno]);\n\t\treg->callno = 0;\n\t}\n\tif (!reg->addr.sin_addr.s_addr) {\n\t\tif (option_debug && iaxdebug)\n\t\t\tast_log(LOG_DEBUG, \"Unable to send registration request for '%s' without IP address\\n\", reg->username);\n\t\t/* Setup the next registration attempt */\n\t\tAST_SCHED_DEL(sched, reg->expire);\n\t\treg->expire  = iax2_sched_add(sched, (5 * reg->refresh / 6) * 1000, iax2_do_register_s, reg);\n\t\treturn -1;\n\t}\n\n\tif (!reg->callno) {\n\t\tif (option_debug)\n\t\t\tast_log(LOG_DEBUG, \"Allocate call number\\n\");\n\t\treg->callno = find_callno_locked(0, 0, &reg->addr, NEW_FORCE, defaultsockfd, 0);\n\t\tif (reg->callno < 1) {\n\t\t\tast_log(LOG_WARNING, \"Unable to create call for registration\\n\");\n\t\t\treturn -1;\n\t\t} else if (option_debug)\n\t\t\tast_log(LOG_DEBUG, \"Registration created on call %d\\n\", reg->callno);\n\t\tiaxs[reg->callno]->reg = reg;\n\t\tast_mutex_unlock(&iaxsl[reg->callno]);\n\t}\n\t/* Schedule the next registration attempt */\n\tAST_SCHED_DEL(sched, reg->expire);\n\t/* Setup the next registration a little early */\n\treg->expire  = iax2_sched_add(sched, (5 * reg->refresh / 6) * 1000, iax2_do_register_s, reg);\n\t/* Send the request */\n\tmemset(&ied, 0, sizeof(ied));\n\tiax_ie_append_str(&ied, IAX_IE_USERNAME, reg->username);\n\tiax_ie_append_short(&ied, IAX_IE_REFRESH, reg->refresh);\n\tsend_command(iaxs[reg->callno],AST_FRAME_IAX, IAX_COMMAND_REGREQ, 0, ied.buf, ied.pos, -1);\n\treg->regstate = REG_STATE_REGSENT;\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -32,7 +32,7 @@\n \tif (!reg->callno) {\n \t\tif (option_debug)\n \t\t\tast_log(LOG_DEBUG, \"Allocate call number\\n\");\n-\t\treg->callno = find_callno_locked(0, 0, &reg->addr, NEW_FORCE, defaultsockfd);\n+\t\treg->callno = find_callno_locked(0, 0, &reg->addr, NEW_FORCE, defaultsockfd, 0);\n \t\tif (reg->callno < 1) {\n \t\t\tast_log(LOG_WARNING, \"Unable to create call for registration\\n\");\n \t\t\treturn -1;",
        "diff_line_info": {
            "deleted_lines": [
                "\t\treg->callno = find_callno_locked(0, 0, &reg->addr, NEW_FORCE, defaultsockfd);"
            ],
            "added_lines": [
                "\t\treg->callno = find_callno_locked(0, 0, &reg->addr, NEW_FORCE, defaultsockfd, 0);"
            ]
        }
    },
    {
        "cve_id": "CVE-2008-1897",
        "func_name": "xrg/asterisk-xrg/iax2_poke_peer",
        "description": "The IAX2 channel driver (chan_iax2) in Asterisk Open Source 1.0.x, 1.2.x before 1.2.28, and 1.4.x before 1.4.19.1; Business Edition A.x.x, B.x.x before B.2.5.2, and C.x.x before C.1.8.1; AsteriskNOW before 1.0.3; Appliance Developer Kit 0.x.x; and s800i before 1.1.0.3, when configured to allow unauthenticated calls, does not verify that an ACK response contains a call number matching the server's reply to a NEW message, which allows remote attackers to cause a denial of service (traffic amplification) via a spoofed ACK response that does not complete a 3-way handshake.  NOTE: this issue exists because of an incomplete fix for CVE-2008-1923.",
        "git_url": "https://github.com/xrg/asterisk-xrg/commit/10da3dab24e8ca08cf2c983f8d0206e383535b5a",
        "commit_title": "When we receive a full frame that is supposed to contain our call number,",
        "commit_text": "ensure that it has the correct one. (closes issue #10078) (AST-2008-006)",
        "func_before": "static int iax2_poke_peer(struct iax2_peer *peer, int heldcall)\n{\n\tif (!peer->maxms || (!peer->addr.sin_addr.s_addr && !peer->dnsmgr)) {\n\t\t/* IF we have no IP without dnsmgr, or this isn't to be monitored, return\n\t\t  immediately after clearing things out */\n\t\tpeer->lastms = 0;\n\t\tpeer->historicms = 0;\n\t\tpeer->pokeexpire = -1;\n\t\tpeer->callno = 0;\n\t\treturn 0;\n\t}\n\tif (peer->callno > 0) {\n\t\tast_log(LOG_NOTICE, \"Still have a callno...\\n\");\n\t\tast_mutex_lock(&iaxsl[peer->callno]);\n\t\tiax2_destroy(peer->callno);\n\t\tast_mutex_unlock(&iaxsl[peer->callno]);\n\t}\n\tif (heldcall)\n\t\tast_mutex_unlock(&iaxsl[heldcall]);\n\tpeer->callno = find_callno(0, 0, &peer->addr, NEW_FORCE, peer->sockfd);\n\tif (heldcall)\n\t\tast_mutex_lock(&iaxsl[heldcall]);\n\tif (peer->callno < 1) {\n\t\tast_log(LOG_WARNING, \"Unable to allocate call for poking peer '%s'\\n\", peer->name);\n\t\treturn -1;\n\t}\n\n\t/* Speed up retransmission times for this qualify call */\n\tiaxs[peer->callno]->pingtime = peer->maxms / 4 + 1;\n\tiaxs[peer->callno]->peerpoke = peer;\n\t\n\t/* Remove any pending pokeexpire task */\n\tif (peer->pokeexpire > -1) {\n\t\tif (!ast_sched_del(sched, peer->pokeexpire)) {\n\t\t\tpeer->pokeexpire = -1;\n\t\t\tpeer_unref(peer);\n\t\t}\n\t}\n\n\t/* Queue up a new task to handle no reply */\n\t/* If the host is already unreachable then use the unreachable interval instead */\n\tif (peer->lastms < 0) {\n\t\tpeer->pokeexpire = iax2_sched_add(sched, peer->pokefreqnotok, iax2_poke_noanswer, peer_ref(peer));\n\t} else\n\t\tpeer->pokeexpire = iax2_sched_add(sched, DEFAULT_MAXMS * 2, iax2_poke_noanswer, peer_ref(peer));\n\n\tif (peer->pokeexpire == -1)\n\t\tpeer_unref(peer);\n\n\t/* And send the poke */\n\tsend_command(iaxs[peer->callno], AST_FRAME_IAX, IAX_COMMAND_POKE, 0, NULL, 0, -1);\n\n\treturn 0;\n}",
        "func": "static int iax2_poke_peer(struct iax2_peer *peer, int heldcall)\n{\n\tif (!peer->maxms || (!peer->addr.sin_addr.s_addr && !peer->dnsmgr)) {\n\t\t/* IF we have no IP without dnsmgr, or this isn't to be monitored, return\n\t\t  immediately after clearing things out */\n\t\tpeer->lastms = 0;\n\t\tpeer->historicms = 0;\n\t\tpeer->pokeexpire = -1;\n\t\tpeer->callno = 0;\n\t\treturn 0;\n\t}\n\tif (peer->callno > 0) {\n\t\tast_log(LOG_NOTICE, \"Still have a callno...\\n\");\n\t\tast_mutex_lock(&iaxsl[peer->callno]);\n\t\tiax2_destroy(peer->callno);\n\t\tast_mutex_unlock(&iaxsl[peer->callno]);\n\t}\n\tif (heldcall)\n\t\tast_mutex_unlock(&iaxsl[heldcall]);\n\tpeer->callno = find_callno(0, 0, &peer->addr, NEW_FORCE, peer->sockfd, 0);\n\tif (heldcall)\n\t\tast_mutex_lock(&iaxsl[heldcall]);\n\tif (peer->callno < 1) {\n\t\tast_log(LOG_WARNING, \"Unable to allocate call for poking peer '%s'\\n\", peer->name);\n\t\treturn -1;\n\t}\n\n\t/* Speed up retransmission times for this qualify call */\n\tiaxs[peer->callno]->pingtime = peer->maxms / 4 + 1;\n\tiaxs[peer->callno]->peerpoke = peer;\n\t\n\t/* Remove any pending pokeexpire task */\n\tif (peer->pokeexpire > -1) {\n\t\tif (!ast_sched_del(sched, peer->pokeexpire)) {\n\t\t\tpeer->pokeexpire = -1;\n\t\t\tpeer_unref(peer);\n\t\t}\n\t}\n\n\t/* Queue up a new task to handle no reply */\n\t/* If the host is already unreachable then use the unreachable interval instead */\n\tif (peer->lastms < 0) {\n\t\tpeer->pokeexpire = iax2_sched_add(sched, peer->pokefreqnotok, iax2_poke_noanswer, peer_ref(peer));\n\t} else\n\t\tpeer->pokeexpire = iax2_sched_add(sched, DEFAULT_MAXMS * 2, iax2_poke_noanswer, peer_ref(peer));\n\n\tif (peer->pokeexpire == -1)\n\t\tpeer_unref(peer);\n\n\t/* And send the poke */\n\tsend_command(iaxs[peer->callno], AST_FRAME_IAX, IAX_COMMAND_POKE, 0, NULL, 0, -1);\n\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -17,7 +17,7 @@\n \t}\n \tif (heldcall)\n \t\tast_mutex_unlock(&iaxsl[heldcall]);\n-\tpeer->callno = find_callno(0, 0, &peer->addr, NEW_FORCE, peer->sockfd);\n+\tpeer->callno = find_callno(0, 0, &peer->addr, NEW_FORCE, peer->sockfd, 0);\n \tif (heldcall)\n \t\tast_mutex_lock(&iaxsl[heldcall]);\n \tif (peer->callno < 1) {",
        "diff_line_info": {
            "deleted_lines": [
                "\tpeer->callno = find_callno(0, 0, &peer->addr, NEW_FORCE, peer->sockfd);"
            ],
            "added_lines": [
                "\tpeer->callno = find_callno(0, 0, &peer->addr, NEW_FORCE, peer->sockfd, 0);"
            ]
        }
    },
    {
        "cve_id": "CVE-2008-1897",
        "func_name": "xrg/asterisk-xrg/cache_get_callno_locked",
        "description": "The IAX2 channel driver (chan_iax2) in Asterisk Open Source 1.0.x, 1.2.x before 1.2.28, and 1.4.x before 1.4.19.1; Business Edition A.x.x, B.x.x before B.2.5.2, and C.x.x before C.1.8.1; AsteriskNOW before 1.0.3; Appliance Developer Kit 0.x.x; and s800i before 1.1.0.3, when configured to allow unauthenticated calls, does not verify that an ACK response contains a call number matching the server's reply to a NEW message, which allows remote attackers to cause a denial of service (traffic amplification) via a spoofed ACK response that does not complete a 3-way handshake.  NOTE: this issue exists because of an incomplete fix for CVE-2008-1923.",
        "git_url": "https://github.com/xrg/asterisk-xrg/commit/10da3dab24e8ca08cf2c983f8d0206e383535b5a",
        "commit_title": "When we receive a full frame that is supposed to contain our call number,",
        "commit_text": "ensure that it has the correct one. (closes issue #10078) (AST-2008-006)",
        "func_before": "static int cache_get_callno_locked(const char *data)\n{\n\tstruct sockaddr_in sin;\n\tint x;\n\tint callno;\n\tstruct iax_ie_data ied;\n\tstruct create_addr_info cai;\n\tstruct parsed_dial_string pds;\n\tchar *tmpstr;\n\n\tfor (x=0; x<IAX_MAX_CALLS; x++) {\n\t\t/* Look for an *exact match* call.  Once a call is negotiated, it can only\n\t\t   look up entries for a single context */\n\t\tif (!ast_mutex_trylock(&iaxsl[x])) {\n\t\t\tif (iaxs[x] && !strcasecmp(data, iaxs[x]->dproot))\n\t\t\t\treturn x;\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t}\n\t}\n\n\t/* No match found, we need to create a new one */\n\n\tmemset(&cai, 0, sizeof(cai));\n\tmemset(&ied, 0, sizeof(ied));\n\tmemset(&pds, 0, sizeof(pds));\n\n\ttmpstr = ast_strdupa(data);\n\tparse_dial_string(tmpstr, &pds);\n\n\tif (ast_strlen_zero(pds.peer)) {\n\t\tast_log(LOG_WARNING, \"No peer provided in the IAX2 dial string '%s'\\n\", data);\n\t\treturn -1;\n\t}\n\n\t/* Populate our address from the given */\n\tif (create_addr(pds.peer, NULL, &sin, &cai))\n\t\treturn -1;\n\n\tif (option_debug)\n\t\tast_log(LOG_DEBUG, \"peer: %s, username: %s, password: %s, context: %s\\n\",\n\t\t\tpds.peer, pds.username, pds.password, pds.context);\n\n\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd);\n\tif (callno < 1) {\n\t\tast_log(LOG_WARNING, \"Unable to create call\\n\");\n\t\treturn -1;\n\t}\n\n\tast_string_field_set(iaxs[callno], dproot, data);\n\tiaxs[callno]->capability = IAX_CAPABILITY_FULLBANDWIDTH;\n\n\tiax_ie_append_short(&ied, IAX_IE_VERSION, IAX_PROTO_VERSION);\n\tiax_ie_append_str(&ied, IAX_IE_CALLED_NUMBER, \"TBD\");\n\t/* the string format is slightly different from a standard dial string,\n\t   because the context appears in the 'exten' position\n\t*/\n\tif (pds.exten)\n\t\tiax_ie_append_str(&ied, IAX_IE_CALLED_CONTEXT, pds.exten);\n\tif (pds.username)\n\t\tiax_ie_append_str(&ied, IAX_IE_USERNAME, pds.username);\n\tiax_ie_append_int(&ied, IAX_IE_FORMAT, IAX_CAPABILITY_FULLBANDWIDTH);\n\tiax_ie_append_int(&ied, IAX_IE_CAPABILITY, IAX_CAPABILITY_FULLBANDWIDTH);\n\t/* Keep password handy */\n\tif (pds.password)\n\t\tast_string_field_set(iaxs[callno], secret, pds.password);\n\tif (pds.key)\n\t\tast_string_field_set(iaxs[callno], outkey, pds.key);\n\t/* Start the call going */\n\tsend_command(iaxs[callno], AST_FRAME_IAX, IAX_COMMAND_NEW, 0, ied.buf, ied.pos, -1);\n\n\treturn callno;\n}",
        "func": "static int cache_get_callno_locked(const char *data)\n{\n\tstruct sockaddr_in sin;\n\tint x;\n\tint callno;\n\tstruct iax_ie_data ied;\n\tstruct create_addr_info cai;\n\tstruct parsed_dial_string pds;\n\tchar *tmpstr;\n\n\tfor (x=0; x<IAX_MAX_CALLS; x++) {\n\t\t/* Look for an *exact match* call.  Once a call is negotiated, it can only\n\t\t   look up entries for a single context */\n\t\tif (!ast_mutex_trylock(&iaxsl[x])) {\n\t\t\tif (iaxs[x] && !strcasecmp(data, iaxs[x]->dproot))\n\t\t\t\treturn x;\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t}\n\t}\n\n\t/* No match found, we need to create a new one */\n\n\tmemset(&cai, 0, sizeof(cai));\n\tmemset(&ied, 0, sizeof(ied));\n\tmemset(&pds, 0, sizeof(pds));\n\n\ttmpstr = ast_strdupa(data);\n\tparse_dial_string(tmpstr, &pds);\n\n\tif (ast_strlen_zero(pds.peer)) {\n\t\tast_log(LOG_WARNING, \"No peer provided in the IAX2 dial string '%s'\\n\", data);\n\t\treturn -1;\n\t}\n\n\t/* Populate our address from the given */\n\tif (create_addr(pds.peer, NULL, &sin, &cai))\n\t\treturn -1;\n\n\tif (option_debug)\n\t\tast_log(LOG_DEBUG, \"peer: %s, username: %s, password: %s, context: %s\\n\",\n\t\t\tpds.peer, pds.username, pds.password, pds.context);\n\n\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd, 0);\n\tif (callno < 1) {\n\t\tast_log(LOG_WARNING, \"Unable to create call\\n\");\n\t\treturn -1;\n\t}\n\n\tast_string_field_set(iaxs[callno], dproot, data);\n\tiaxs[callno]->capability = IAX_CAPABILITY_FULLBANDWIDTH;\n\n\tiax_ie_append_short(&ied, IAX_IE_VERSION, IAX_PROTO_VERSION);\n\tiax_ie_append_str(&ied, IAX_IE_CALLED_NUMBER, \"TBD\");\n\t/* the string format is slightly different from a standard dial string,\n\t   because the context appears in the 'exten' position\n\t*/\n\tif (pds.exten)\n\t\tiax_ie_append_str(&ied, IAX_IE_CALLED_CONTEXT, pds.exten);\n\tif (pds.username)\n\t\tiax_ie_append_str(&ied, IAX_IE_USERNAME, pds.username);\n\tiax_ie_append_int(&ied, IAX_IE_FORMAT, IAX_CAPABILITY_FULLBANDWIDTH);\n\tiax_ie_append_int(&ied, IAX_IE_CAPABILITY, IAX_CAPABILITY_FULLBANDWIDTH);\n\t/* Keep password handy */\n\tif (pds.password)\n\t\tast_string_field_set(iaxs[callno], secret, pds.password);\n\tif (pds.key)\n\t\tast_string_field_set(iaxs[callno], outkey, pds.key);\n\t/* Start the call going */\n\tsend_command(iaxs[callno], AST_FRAME_IAX, IAX_COMMAND_NEW, 0, ied.buf, ied.pos, -1);\n\n\treturn callno;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -40,7 +40,7 @@\n \t\tast_log(LOG_DEBUG, \"peer: %s, username: %s, password: %s, context: %s\\n\",\n \t\t\tpds.peer, pds.username, pds.password, pds.context);\n \n-\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd);\n+\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd, 0);\n \tif (callno < 1) {\n \t\tast_log(LOG_WARNING, \"Unable to create call\\n\");\n \t\treturn -1;",
        "diff_line_info": {
            "deleted_lines": [
                "\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd);"
            ],
            "added_lines": [
                "\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd, 0);"
            ]
        }
    },
    {
        "cve_id": "CVE-2008-1897",
        "func_name": "xrg/asterisk-xrg/iax2_provision",
        "description": "The IAX2 channel driver (chan_iax2) in Asterisk Open Source 1.0.x, 1.2.x before 1.2.28, and 1.4.x before 1.4.19.1; Business Edition A.x.x, B.x.x before B.2.5.2, and C.x.x before C.1.8.1; AsteriskNOW before 1.0.3; Appliance Developer Kit 0.x.x; and s800i before 1.1.0.3, when configured to allow unauthenticated calls, does not verify that an ACK response contains a call number matching the server's reply to a NEW message, which allows remote attackers to cause a denial of service (traffic amplification) via a spoofed ACK response that does not complete a 3-way handshake.  NOTE: this issue exists because of an incomplete fix for CVE-2008-1923.",
        "git_url": "https://github.com/xrg/asterisk-xrg/commit/10da3dab24e8ca08cf2c983f8d0206e383535b5a",
        "commit_title": "When we receive a full frame that is supposed to contain our call number,",
        "commit_text": "ensure that it has the correct one. (closes issue #10078) (AST-2008-006)",
        "func_before": "static int iax2_provision(struct sockaddr_in *end, int sockfd, char *dest, const char *template, int force)\n{\n\t/* Returns 1 if provisioned, -1 if not able to find destination, or 0 if no provisioning\n\t   is found for template */\n\tstruct iax_ie_data provdata;\n\tstruct iax_ie_data ied;\n\tunsigned int sig;\n\tstruct sockaddr_in sin;\n\tint callno;\n\tstruct create_addr_info cai;\n\n\tmemset(&cai, 0, sizeof(cai));\n\n\tif (option_debug)\n\t\tast_log(LOG_DEBUG, \"Provisioning '%s' from template '%s'\\n\", dest, template);\n\n\tif (iax_provision_build(&provdata, &sig, template, force)) {\n\t\tif (option_debug)\n\t\t\tast_log(LOG_DEBUG, \"No provisioning found for template '%s'\\n\", template);\n\t\treturn 0;\n\t}\n\n\tif (end) {\n\t\tmemcpy(&sin, end, sizeof(sin));\n\t\tcai.sockfd = sockfd;\n\t} else if (create_addr(dest, NULL, &sin, &cai))\n\t\treturn -1;\n\n\t/* Build the rest of the message */\n\tmemset(&ied, 0, sizeof(ied));\n\tiax_ie_append_raw(&ied, IAX_IE_PROVISIONING, provdata.buf, provdata.pos);\n\n\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd);\n\tif (!callno)\n\t\treturn -1;\n\n\tif (iaxs[callno]) {\n\t\t/* Schedule autodestruct in case they don't ever give us anything back */\n\t\tAST_SCHED_DEL(sched, iaxs[callno]->autoid);\n\t\tiaxs[callno]->autoid = iax2_sched_add(sched, 15000, auto_hangup, (void *)(long)callno);\n\t\tast_set_flag(iaxs[callno], IAX_PROVISION);\n\t\t/* Got a call number now, so go ahead and send the provisioning information */\n\t\tsend_command(iaxs[callno], AST_FRAME_IAX, IAX_COMMAND_PROVISION, 0, ied.buf, ied.pos, -1);\n\t}\n\tast_mutex_unlock(&iaxsl[callno]);\n\n\treturn 1;\n}",
        "func": "static int iax2_provision(struct sockaddr_in *end, int sockfd, char *dest, const char *template, int force)\n{\n\t/* Returns 1 if provisioned, -1 if not able to find destination, or 0 if no provisioning\n\t   is found for template */\n\tstruct iax_ie_data provdata;\n\tstruct iax_ie_data ied;\n\tunsigned int sig;\n\tstruct sockaddr_in sin;\n\tint callno;\n\tstruct create_addr_info cai;\n\n\tmemset(&cai, 0, sizeof(cai));\n\n\tif (option_debug)\n\t\tast_log(LOG_DEBUG, \"Provisioning '%s' from template '%s'\\n\", dest, template);\n\n\tif (iax_provision_build(&provdata, &sig, template, force)) {\n\t\tif (option_debug)\n\t\t\tast_log(LOG_DEBUG, \"No provisioning found for template '%s'\\n\", template);\n\t\treturn 0;\n\t}\n\n\tif (end) {\n\t\tmemcpy(&sin, end, sizeof(sin));\n\t\tcai.sockfd = sockfd;\n\t} else if (create_addr(dest, NULL, &sin, &cai))\n\t\treturn -1;\n\n\t/* Build the rest of the message */\n\tmemset(&ied, 0, sizeof(ied));\n\tiax_ie_append_raw(&ied, IAX_IE_PROVISIONING, provdata.buf, provdata.pos);\n\n\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd, 0);\n\tif (!callno)\n\t\treturn -1;\n\n\tif (iaxs[callno]) {\n\t\t/* Schedule autodestruct in case they don't ever give us anything back */\n\t\tAST_SCHED_DEL(sched, iaxs[callno]->autoid);\n\t\tiaxs[callno]->autoid = iax2_sched_add(sched, 15000, auto_hangup, (void *)(long)callno);\n\t\tast_set_flag(iaxs[callno], IAX_PROVISION);\n\t\t/* Got a call number now, so go ahead and send the provisioning information */\n\t\tsend_command(iaxs[callno], AST_FRAME_IAX, IAX_COMMAND_PROVISION, 0, ied.buf, ied.pos, -1);\n\t}\n\tast_mutex_unlock(&iaxsl[callno]);\n\n\treturn 1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -30,7 +30,7 @@\n \tmemset(&ied, 0, sizeof(ied));\n \tiax_ie_append_raw(&ied, IAX_IE_PROVISIONING, provdata.buf, provdata.pos);\n \n-\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd);\n+\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd, 0);\n \tif (!callno)\n \t\treturn -1;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd);"
            ],
            "added_lines": [
                "\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd, 0);"
            ]
        }
    },
    {
        "cve_id": "CVE-2008-1897",
        "func_name": "xrg/asterisk-xrg/match",
        "description": "The IAX2 channel driver (chan_iax2) in Asterisk Open Source 1.0.x, 1.2.x before 1.2.28, and 1.4.x before 1.4.19.1; Business Edition A.x.x, B.x.x before B.2.5.2, and C.x.x before C.1.8.1; AsteriskNOW before 1.0.3; Appliance Developer Kit 0.x.x; and s800i before 1.1.0.3, when configured to allow unauthenticated calls, does not verify that an ACK response contains a call number matching the server's reply to a NEW message, which allows remote attackers to cause a denial of service (traffic amplification) via a spoofed ACK response that does not complete a 3-way handshake.  NOTE: this issue exists because of an incomplete fix for CVE-2008-1923.",
        "git_url": "https://github.com/xrg/asterisk-xrg/commit/10da3dab24e8ca08cf2c983f8d0206e383535b5a",
        "commit_title": "When we receive a full frame that is supposed to contain our call number,",
        "commit_text": "ensure that it has the correct one. (closes issue #10078) (AST-2008-006)",
        "func_before": "static int match(struct sockaddr_in *sin, unsigned short callno, unsigned short dcallno, struct chan_iax2_pvt *cur)\n{\n\tif ((cur->addr.sin_addr.s_addr == sin->sin_addr.s_addr) &&\n\t\t(cur->addr.sin_port == sin->sin_port)) {\n\t\t/* This is the main host */\n\t\tif ((cur->peercallno == callno) ||\n\t\t\t((dcallno == cur->callno) && !cur->peercallno)) {\n\t\t\t/* That's us.  Be sure we keep track of the peer call number */\n\t\t\treturn 1;\n\t\t}\n\t}\n\tif ((cur->transfer.sin_addr.s_addr == sin->sin_addr.s_addr) &&\n\t    (cur->transfer.sin_port == sin->sin_port) && (cur->transferring)) {\n\t\t/* We're transferring */\n\t\tif ((dcallno == cur->callno) || (cur->transferring == TRANSFER_MEDIAPASS && cur->transfercallno == callno))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
        "func": "static int match(struct sockaddr_in *sin, unsigned short callno, unsigned short dcallno, struct chan_iax2_pvt *cur, int full_frame)\n{\n\tif ((cur->addr.sin_addr.s_addr == sin->sin_addr.s_addr) &&\n\t\t(cur->addr.sin_port == sin->sin_port)) {\n\t\t/* This is the main host */\n\t\tif ( (cur->peercallno == 0 || cur->peercallno == callno) &&\n\t\t\t (full_frame ? dcallno == cur->callno : 1) ) {\n\t\t\t/* That's us.  Be sure we keep track of the peer call number */\n\t\t\treturn 1;\n\t\t}\n\t}\n\tif ((cur->transfer.sin_addr.s_addr == sin->sin_addr.s_addr) &&\n\t    (cur->transfer.sin_port == sin->sin_port) && (cur->transferring)) {\n\t\t/* We're transferring */\n\t\tif ((dcallno == cur->callno) || (cur->transferring == TRANSFER_MEDIAPASS && cur->transfercallno == callno))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,10 +1,10 @@\n-static int match(struct sockaddr_in *sin, unsigned short callno, unsigned short dcallno, struct chan_iax2_pvt *cur)\n+static int match(struct sockaddr_in *sin, unsigned short callno, unsigned short dcallno, struct chan_iax2_pvt *cur, int full_frame)\n {\n \tif ((cur->addr.sin_addr.s_addr == sin->sin_addr.s_addr) &&\n \t\t(cur->addr.sin_port == sin->sin_port)) {\n \t\t/* This is the main host */\n-\t\tif ((cur->peercallno == callno) ||\n-\t\t\t((dcallno == cur->callno) && !cur->peercallno)) {\n+\t\tif ( (cur->peercallno == 0 || cur->peercallno == callno) &&\n+\t\t\t (full_frame ? dcallno == cur->callno : 1) ) {\n \t\t\t/* That's us.  Be sure we keep track of the peer call number */\n \t\t\treturn 1;\n \t\t}",
        "diff_line_info": {
            "deleted_lines": [
                "static int match(struct sockaddr_in *sin, unsigned short callno, unsigned short dcallno, struct chan_iax2_pvt *cur)",
                "\t\tif ((cur->peercallno == callno) ||",
                "\t\t\t((dcallno == cur->callno) && !cur->peercallno)) {"
            ],
            "added_lines": [
                "static int match(struct sockaddr_in *sin, unsigned short callno, unsigned short dcallno, struct chan_iax2_pvt *cur, int full_frame)",
                "\t\tif ( (cur->peercallno == 0 || cur->peercallno == callno) &&",
                "\t\t\t (full_frame ? dcallno == cur->callno : 1) ) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2008-1897",
        "func_name": "xrg/asterisk-xrg/find_callno_locked",
        "description": "The IAX2 channel driver (chan_iax2) in Asterisk Open Source 1.0.x, 1.2.x before 1.2.28, and 1.4.x before 1.4.19.1; Business Edition A.x.x, B.x.x before B.2.5.2, and C.x.x before C.1.8.1; AsteriskNOW before 1.0.3; Appliance Developer Kit 0.x.x; and s800i before 1.1.0.3, when configured to allow unauthenticated calls, does not verify that an ACK response contains a call number matching the server's reply to a NEW message, which allows remote attackers to cause a denial of service (traffic amplification) via a spoofed ACK response that does not complete a 3-way handshake.  NOTE: this issue exists because of an incomplete fix for CVE-2008-1923.",
        "git_url": "https://github.com/xrg/asterisk-xrg/commit/10da3dab24e8ca08cf2c983f8d0206e383535b5a",
        "commit_title": "When we receive a full frame that is supposed to contain our call number,",
        "commit_text": "ensure that it has the correct one. (closes issue #10078) (AST-2008-006)",
        "func_before": "static int find_callno_locked(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd) {\n\n\treturn __find_callno(callno, dcallno, sin, new, sockfd, 1);\n}",
        "func": "static int find_callno_locked(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int full_frame) {\n\n\treturn __find_callno(callno, dcallno, sin, new, sockfd, 1, full_frame);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,4 @@\n-static int find_callno_locked(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd) {\n+static int find_callno_locked(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int full_frame) {\n \n-\treturn __find_callno(callno, dcallno, sin, new, sockfd, 1);\n+\treturn __find_callno(callno, dcallno, sin, new, sockfd, 1, full_frame);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "static int find_callno_locked(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd) {",
                "\treturn __find_callno(callno, dcallno, sin, new, sockfd, 1);"
            ],
            "added_lines": [
                "static int find_callno_locked(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int full_frame) {",
                "\treturn __find_callno(callno, dcallno, sin, new, sockfd, 1, full_frame);"
            ]
        }
    },
    {
        "cve_id": "CVE-2008-1897",
        "func_name": "xrg/asterisk-xrg/iax2_request",
        "description": "The IAX2 channel driver (chan_iax2) in Asterisk Open Source 1.0.x, 1.2.x before 1.2.28, and 1.4.x before 1.4.19.1; Business Edition A.x.x, B.x.x before B.2.5.2, and C.x.x before C.1.8.1; AsteriskNOW before 1.0.3; Appliance Developer Kit 0.x.x; and s800i before 1.1.0.3, when configured to allow unauthenticated calls, does not verify that an ACK response contains a call number matching the server's reply to a NEW message, which allows remote attackers to cause a denial of service (traffic amplification) via a spoofed ACK response that does not complete a 3-way handshake.  NOTE: this issue exists because of an incomplete fix for CVE-2008-1923.",
        "git_url": "https://github.com/xrg/asterisk-xrg/commit/10da3dab24e8ca08cf2c983f8d0206e383535b5a",
        "commit_title": "When we receive a full frame that is supposed to contain our call number,",
        "commit_text": "ensure that it has the correct one. (closes issue #10078) (AST-2008-006)",
        "func_before": "static struct ast_channel *iax2_request(const char *type, int format, void *data, int *cause)\n{\n\tint callno;\n\tint res;\n\tint fmt, native;\n\tstruct sockaddr_in sin;\n\tstruct ast_channel *c;\n\tstruct parsed_dial_string pds;\n\tstruct create_addr_info cai;\n\tchar *tmpstr;\n\n\tmemset(&pds, 0, sizeof(pds));\n\ttmpstr = ast_strdupa(data);\n\tparse_dial_string(tmpstr, &pds);\n\n\tif (ast_strlen_zero(pds.peer)) {\n\t\tast_log(LOG_WARNING, \"No peer provided in the IAX2 dial string '%s'\\n\", (char *) data);\n\t\treturn NULL;\n\t}\n\t       \n\tmemset(&cai, 0, sizeof(cai));\n\tcai.capability = iax2_capability;\n\n\tast_copy_flags(&cai, &globalflags, IAX_NOTRANSFER | IAX_TRANSFERMEDIA | IAX_USEJITTERBUF | IAX_FORCEJITTERBUF);\n\t\n\t/* Populate our address from the given */\n\tif (create_addr(pds.peer, NULL, &sin, &cai)) {\n\t\t*cause = AST_CAUSE_UNREGISTERED;\n\t\treturn NULL;\n\t}\n\n\tif (pds.port)\n\t\tsin.sin_port = htons(atoi(pds.port));\n\n\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd);\n\tif (callno < 1) {\n\t\tast_log(LOG_WARNING, \"Unable to create call\\n\");\n\t\t*cause = AST_CAUSE_CONGESTION;\n\t\treturn NULL;\n\t}\n\n\t/* If this is a trunk, update it now */\n\tast_copy_flags(iaxs[callno], &cai, IAX_TRUNK | IAX_SENDANI | IAX_NOTRANSFER | IAX_TRANSFERMEDIA | IAX_USEJITTERBUF | IAX_FORCEJITTERBUF);\t\n\tif (ast_test_flag(&cai, IAX_TRUNK)) {\n\t\tint new_callno;\n\t\tif ((new_callno = make_trunk(callno, 1)) != -1)\n\t\t\tcallno = new_callno;\n\t}\n\tiaxs[callno]->maxtime = cai.maxtime;\n\tif (cai.found)\n\t\tast_string_field_set(iaxs[callno], host, pds.peer);\n\n\tc = ast_iax2_new(callno, AST_STATE_DOWN, cai.capability);\n\n\tast_mutex_unlock(&iaxsl[callno]);\n\n\tif (c) {\n\t\t/* Choose a format we can live with */\n\t\tif (c->nativeformats & format) \n\t\t\tc->nativeformats &= format;\n\t\telse {\n\t\t\tnative = c->nativeformats;\n\t\t\tfmt = format;\n\t\t\tres = ast_translator_best_choice(&fmt, &native);\n\t\t\tif (res < 0) {\n\t\t\t\tast_log(LOG_WARNING, \"Unable to create translator path for %s to %s on %s\\n\",\n\t\t\t\t\tast_getformatname(c->nativeformats), ast_getformatname(fmt), c->name);\n\t\t\t\tast_hangup(c);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tc->nativeformats = native;\n\t\t}\n\t\tc->readformat = ast_best_codec(c->nativeformats);\n\t\tc->writeformat = c->readformat;\n\t}\n\n\treturn c;\n}",
        "func": "static struct ast_channel *iax2_request(const char *type, int format, void *data, int *cause)\n{\n\tint callno;\n\tint res;\n\tint fmt, native;\n\tstruct sockaddr_in sin;\n\tstruct ast_channel *c;\n\tstruct parsed_dial_string pds;\n\tstruct create_addr_info cai;\n\tchar *tmpstr;\n\n\tmemset(&pds, 0, sizeof(pds));\n\ttmpstr = ast_strdupa(data);\n\tparse_dial_string(tmpstr, &pds);\n\n\tif (ast_strlen_zero(pds.peer)) {\n\t\tast_log(LOG_WARNING, \"No peer provided in the IAX2 dial string '%s'\\n\", (char *) data);\n\t\treturn NULL;\n\t}\n\t       \n\tmemset(&cai, 0, sizeof(cai));\n\tcai.capability = iax2_capability;\n\n\tast_copy_flags(&cai, &globalflags, IAX_NOTRANSFER | IAX_TRANSFERMEDIA | IAX_USEJITTERBUF | IAX_FORCEJITTERBUF);\n\t\n\t/* Populate our address from the given */\n\tif (create_addr(pds.peer, NULL, &sin, &cai)) {\n\t\t*cause = AST_CAUSE_UNREGISTERED;\n\t\treturn NULL;\n\t}\n\n\tif (pds.port)\n\t\tsin.sin_port = htons(atoi(pds.port));\n\n\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd, 0);\n\tif (callno < 1) {\n\t\tast_log(LOG_WARNING, \"Unable to create call\\n\");\n\t\t*cause = AST_CAUSE_CONGESTION;\n\t\treturn NULL;\n\t}\n\n\t/* If this is a trunk, update it now */\n\tast_copy_flags(iaxs[callno], &cai, IAX_TRUNK | IAX_SENDANI | IAX_NOTRANSFER | IAX_TRANSFERMEDIA | IAX_USEJITTERBUF | IAX_FORCEJITTERBUF);\t\n\tif (ast_test_flag(&cai, IAX_TRUNK)) {\n\t\tint new_callno;\n\t\tif ((new_callno = make_trunk(callno, 1)) != -1)\n\t\t\tcallno = new_callno;\n\t}\n\tiaxs[callno]->maxtime = cai.maxtime;\n\tif (cai.found)\n\t\tast_string_field_set(iaxs[callno], host, pds.peer);\n\n\tc = ast_iax2_new(callno, AST_STATE_DOWN, cai.capability);\n\n\tast_mutex_unlock(&iaxsl[callno]);\n\n\tif (c) {\n\t\t/* Choose a format we can live with */\n\t\tif (c->nativeformats & format) \n\t\t\tc->nativeformats &= format;\n\t\telse {\n\t\t\tnative = c->nativeformats;\n\t\t\tfmt = format;\n\t\t\tres = ast_translator_best_choice(&fmt, &native);\n\t\t\tif (res < 0) {\n\t\t\t\tast_log(LOG_WARNING, \"Unable to create translator path for %s to %s on %s\\n\",\n\t\t\t\t\tast_getformatname(c->nativeformats), ast_getformatname(fmt), c->name);\n\t\t\t\tast_hangup(c);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tc->nativeformats = native;\n\t\t}\n\t\tc->readformat = ast_best_codec(c->nativeformats);\n\t\tc->writeformat = c->readformat;\n\t}\n\n\treturn c;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -32,7 +32,7 @@\n \tif (pds.port)\n \t\tsin.sin_port = htons(atoi(pds.port));\n \n-\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd);\n+\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd, 0);\n \tif (callno < 1) {\n \t\tast_log(LOG_WARNING, \"Unable to create call\\n\");\n \t\t*cause = AST_CAUSE_CONGESTION;",
        "diff_line_info": {
            "deleted_lines": [
                "\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd);"
            ],
            "added_lines": [
                "\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd, 0);"
            ]
        }
    },
    {
        "cve_id": "CVE-2008-1897",
        "func_name": "xrg/asterisk-xrg/__find_callno",
        "description": "The IAX2 channel driver (chan_iax2) in Asterisk Open Source 1.0.x, 1.2.x before 1.2.28, and 1.4.x before 1.4.19.1; Business Edition A.x.x, B.x.x before B.2.5.2, and C.x.x before C.1.8.1; AsteriskNOW before 1.0.3; Appliance Developer Kit 0.x.x; and s800i before 1.1.0.3, when configured to allow unauthenticated calls, does not verify that an ACK response contains a call number matching the server's reply to a NEW message, which allows remote attackers to cause a denial of service (traffic amplification) via a spoofed ACK response that does not complete a 3-way handshake.  NOTE: this issue exists because of an incomplete fix for CVE-2008-1923.",
        "git_url": "https://github.com/xrg/asterisk-xrg/commit/10da3dab24e8ca08cf2c983f8d0206e383535b5a",
        "commit_title": "When we receive a full frame that is supposed to contain our call number,",
        "commit_text": "ensure that it has the correct one. (closes issue #10078) (AST-2008-006)",
        "func_before": "static int __find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int return_locked)\n{\n\tint res = 0;\n\tint x;\n\tstruct timeval now;\n\tchar host[80];\n\n\tif (new <= NEW_ALLOW) {\n\t\t/* Look for an existing connection first */\n\t\tfor (x=1;(res < 1) && (x<maxnontrunkcall);x++) {\n\t\t\tast_mutex_lock(&iaxsl[x]);\n\t\t\tif (iaxs[x]) {\n\t\t\t\t/* Look for an exact match */\n\t\t\t\tif (match(sin, callno, dcallno, iaxs[x])) {\n\t\t\t\t\tres = x;\n\t\t\t\t}\n\t\t\t}\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t}\n\t\tfor (x=TRUNK_CALL_START;(res < 1) && (x<maxtrunkcall);x++) {\n\t\t\tast_mutex_lock(&iaxsl[x]);\n\t\t\tif (iaxs[x]) {\n\t\t\t\t/* Look for an exact match */\n\t\t\t\tif (match(sin, callno, dcallno, iaxs[x])) {\n\t\t\t\t\tres = x;\n\t\t\t\t}\n\t\t\t}\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t}\n\t}\n\tif ((res < 1) && (new >= NEW_ALLOW)) {\n\t\t/* It may seem odd that we look through the peer list for a name for\n\t\t * this *incoming* call.  Well, it is weird.  However, users don't\n\t\t * have an IP address/port number that we can match against.  So,\n\t\t * this is just checking for a peer that has that IP/port and\n\t\t * assuming that we have a user of the same name.  This isn't always\n\t\t * correct, but it will be changed if needed after authentication. */\n\t\tif (!iax2_getpeername(*sin, host, sizeof(host)))\n\t\t\tsnprintf(host, sizeof(host), \"%s:%d\", ast_inet_ntoa(sin->sin_addr), ntohs(sin->sin_port));\n\t\tgettimeofday(&now, NULL);\n\t\tfor (x=1;x<TRUNK_CALL_START;x++) {\n\t\t\t/* Find first unused call number that hasn't been used in a while */\n\t\t\tast_mutex_lock(&iaxsl[x]);\n\t\t\tif (!iaxs[x] && ((now.tv_sec - lastused[x].tv_sec) > MIN_REUSE_TIME)) break;\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t}\n\t\t/* We've still got lock held if we found a spot */\n\t\tif (x >= TRUNK_CALL_START) {\n\t\t\tast_log(LOG_WARNING, \"No more space\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tiaxs[x] = new_iax(sin, host);\n\t\tupdate_max_nontrunk();\n\t\tif (iaxs[x]) {\n\t\t\tif (option_debug && iaxdebug)\n\t\t\t\tast_log(LOG_DEBUG, \"Creating new call structure %d\\n\", x);\n\t\t\tiaxs[x]->sockfd = sockfd;\n\t\t\tiaxs[x]->addr.sin_port = sin->sin_port;\n\t\t\tiaxs[x]->addr.sin_family = sin->sin_family;\n\t\t\tiaxs[x]->addr.sin_addr.s_addr = sin->sin_addr.s_addr;\n\t\t\tiaxs[x]->peercallno = callno;\n\t\t\tiaxs[x]->callno = x;\n\t\t\tiaxs[x]->pingtime = DEFAULT_RETRY_TIME;\n\t\t\tiaxs[x]->expiry = min_reg_expire;\n\t\t\tiaxs[x]->pingid = iax2_sched_add(sched, ping_time * 1000, send_ping, (void *)(long)x);\n\t\t\tiaxs[x]->lagid = iax2_sched_add(sched, lagrq_time * 1000, send_lagrq, (void *)(long)x);\n\t\t\tiaxs[x]->amaflags = amaflags;\n\t\t\tast_copy_flags(iaxs[x], (&globalflags), IAX_NOTRANSFER | IAX_TRANSFERMEDIA | IAX_USEJITTERBUF | IAX_FORCEJITTERBUF);\n\t\t\t\n\t\t\tast_string_field_set(iaxs[x], accountcode, accountcode);\n\t\t\tast_string_field_set(iaxs[x], mohinterpret, mohinterpret);\n\t\t\tast_string_field_set(iaxs[x], mohsuggest, mohsuggest);\n\t\t} else {\n\t\t\tast_log(LOG_WARNING, \"Out of resources\\n\");\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t\treturn 0;\n\t\t}\n\t\tif (!return_locked)\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\tres = x;\n\t}\n\treturn res;\n}",
        "func": "static int __find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int return_locked, int full_frame)\n{\n\tint res = 0;\n\tint x;\n\tstruct timeval now;\n\tchar host[80];\n\n\tif (new <= NEW_ALLOW) {\n\t\t/* Look for an existing connection first */\n\t\tfor (x=1;(res < 1) && (x<maxnontrunkcall);x++) {\n\t\t\tast_mutex_lock(&iaxsl[x]);\n\t\t\tif (iaxs[x]) {\n\t\t\t\t/* Look for an exact match */\n\t\t\t\tif (match(sin, callno, dcallno, iaxs[x], full_frame)) {\n\t\t\t\t\tres = x;\n\t\t\t\t}\n\t\t\t}\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t}\n\t\tfor (x=TRUNK_CALL_START;(res < 1) && (x<maxtrunkcall);x++) {\n\t\t\tast_mutex_lock(&iaxsl[x]);\n\t\t\tif (iaxs[x]) {\n\t\t\t\t/* Look for an exact match */\n\t\t\t\tif (match(sin, callno, dcallno, iaxs[x], full_frame)) {\n\t\t\t\t\tres = x;\n\t\t\t\t}\n\t\t\t}\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t}\n\t}\n\tif ((res < 1) && (new >= NEW_ALLOW)) {\n\t\tint start, found = 0;\n\n\t\t/* It may seem odd that we look through the peer list for a name for\n\t\t * this *incoming* call.  Well, it is weird.  However, users don't\n\t\t * have an IP address/port number that we can match against.  So,\n\t\t * this is just checking for a peer that has that IP/port and\n\t\t * assuming that we have a user of the same name.  This isn't always\n\t\t * correct, but it will be changed if needed after authentication. */\n\t\tif (!iax2_getpeername(*sin, host, sizeof(host)))\n\t\t\tsnprintf(host, sizeof(host), \"%s:%d\", ast_inet_ntoa(sin->sin_addr), ntohs(sin->sin_port));\n\n\t\tnow = ast_tvnow();\n\t\tstart = 1 + (ast_random() % (TRUNK_CALL_START - 1));\n\t\tfor (x = start; 1; x++) {\n\t\t\tif (x == TRUNK_CALL_START) {\n\t\t\t\tx = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* Find first unused call number that hasn't been used in a while */\n\t\t\tast_mutex_lock(&iaxsl[x]);\n\t\t\tif (!iaxs[x] && ((now.tv_sec - lastused[x].tv_sec) > MIN_REUSE_TIME)) {\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t\t\n\t\t\tif (x == start - 1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/* We've still got lock held if we found a spot */\n\t\tif (x == start - 1 && !found) {\n\t\t\tast_log(LOG_WARNING, \"No more space\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tiaxs[x] = new_iax(sin, host);\n\t\tupdate_max_nontrunk();\n\t\tif (iaxs[x]) {\n\t\t\tif (option_debug && iaxdebug)\n\t\t\t\tast_log(LOG_DEBUG, \"Creating new call structure %d\\n\", x);\n\t\t\tiaxs[x]->sockfd = sockfd;\n\t\t\tiaxs[x]->addr.sin_port = sin->sin_port;\n\t\t\tiaxs[x]->addr.sin_family = sin->sin_family;\n\t\t\tiaxs[x]->addr.sin_addr.s_addr = sin->sin_addr.s_addr;\n\t\t\tiaxs[x]->peercallno = callno;\n\t\t\tiaxs[x]->callno = x;\n\t\t\tiaxs[x]->pingtime = DEFAULT_RETRY_TIME;\n\t\t\tiaxs[x]->expiry = min_reg_expire;\n\t\t\tiaxs[x]->pingid = iax2_sched_add(sched, ping_time * 1000, send_ping, (void *)(long)x);\n\t\t\tiaxs[x]->lagid = iax2_sched_add(sched, lagrq_time * 1000, send_lagrq, (void *)(long)x);\n\t\t\tiaxs[x]->amaflags = amaflags;\n\t\t\tast_copy_flags(iaxs[x], (&globalflags), IAX_NOTRANSFER | IAX_TRANSFERMEDIA | IAX_USEJITTERBUF | IAX_FORCEJITTERBUF);\n\t\t\t\n\t\t\tast_string_field_set(iaxs[x], accountcode, accountcode);\n\t\t\tast_string_field_set(iaxs[x], mohinterpret, mohinterpret);\n\t\t\tast_string_field_set(iaxs[x], mohsuggest, mohsuggest);\n\t\t} else {\n\t\t\tast_log(LOG_WARNING, \"Out of resources\\n\");\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t\treturn 0;\n\t\t}\n\t\tif (!return_locked)\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\tres = x;\n\t}\n\treturn res;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,4 @@\n-static int __find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int return_locked)\n+static int __find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int return_locked, int full_frame)\n {\n \tint res = 0;\n \tint x;\n@@ -11,7 +11,7 @@\n \t\t\tast_mutex_lock(&iaxsl[x]);\n \t\t\tif (iaxs[x]) {\n \t\t\t\t/* Look for an exact match */\n-\t\t\t\tif (match(sin, callno, dcallno, iaxs[x])) {\n+\t\t\t\tif (match(sin, callno, dcallno, iaxs[x], full_frame)) {\n \t\t\t\t\tres = x;\n \t\t\t\t}\n \t\t\t}\n@@ -21,7 +21,7 @@\n \t\t\tast_mutex_lock(&iaxsl[x]);\n \t\t\tif (iaxs[x]) {\n \t\t\t\t/* Look for an exact match */\n-\t\t\t\tif (match(sin, callno, dcallno, iaxs[x])) {\n+\t\t\t\tif (match(sin, callno, dcallno, iaxs[x], full_frame)) {\n \t\t\t\t\tres = x;\n \t\t\t\t}\n \t\t\t}\n@@ -29,6 +29,8 @@\n \t\t}\n \t}\n \tif ((res < 1) && (new >= NEW_ALLOW)) {\n+\t\tint start, found = 0;\n+\n \t\t/* It may seem odd that we look through the peer list for a name for\n \t\t * this *incoming* call.  Well, it is weird.  However, users don't\n \t\t * have an IP address/port number that we can match against.  So,\n@@ -37,15 +39,29 @@\n \t\t * correct, but it will be changed if needed after authentication. */\n \t\tif (!iax2_getpeername(*sin, host, sizeof(host)))\n \t\t\tsnprintf(host, sizeof(host), \"%s:%d\", ast_inet_ntoa(sin->sin_addr), ntohs(sin->sin_port));\n-\t\tgettimeofday(&now, NULL);\n-\t\tfor (x=1;x<TRUNK_CALL_START;x++) {\n+\n+\t\tnow = ast_tvnow();\n+\t\tstart = 1 + (ast_random() % (TRUNK_CALL_START - 1));\n+\t\tfor (x = start; 1; x++) {\n+\t\t\tif (x == TRUNK_CALL_START) {\n+\t\t\t\tx = 0;\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\n \t\t\t/* Find first unused call number that hasn't been used in a while */\n \t\t\tast_mutex_lock(&iaxsl[x]);\n-\t\t\tif (!iaxs[x] && ((now.tv_sec - lastused[x].tv_sec) > MIN_REUSE_TIME)) break;\n+\t\t\tif (!iaxs[x] && ((now.tv_sec - lastused[x].tv_sec) > MIN_REUSE_TIME)) {\n+\t\t\t\tfound = 1;\n+\t\t\t\tbreak;\n+\t\t\t}\n \t\t\tast_mutex_unlock(&iaxsl[x]);\n+\t\t\t\n+\t\t\tif (x == start - 1) {\n+\t\t\t\tbreak;\n+\t\t\t}\n \t\t}\n \t\t/* We've still got lock held if we found a spot */\n-\t\tif (x >= TRUNK_CALL_START) {\n+\t\tif (x == start - 1 && !found) {\n \t\t\tast_log(LOG_WARNING, \"No more space\\n\");\n \t\t\treturn 0;\n \t\t}",
        "diff_line_info": {
            "deleted_lines": [
                "static int __find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int return_locked)",
                "\t\t\t\tif (match(sin, callno, dcallno, iaxs[x])) {",
                "\t\t\t\tif (match(sin, callno, dcallno, iaxs[x])) {",
                "\t\tgettimeofday(&now, NULL);",
                "\t\tfor (x=1;x<TRUNK_CALL_START;x++) {",
                "\t\t\tif (!iaxs[x] && ((now.tv_sec - lastused[x].tv_sec) > MIN_REUSE_TIME)) break;",
                "\t\tif (x >= TRUNK_CALL_START) {"
            ],
            "added_lines": [
                "static int __find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int return_locked, int full_frame)",
                "\t\t\t\tif (match(sin, callno, dcallno, iaxs[x], full_frame)) {",
                "\t\t\t\tif (match(sin, callno, dcallno, iaxs[x], full_frame)) {",
                "\t\tint start, found = 0;",
                "",
                "",
                "\t\tnow = ast_tvnow();",
                "\t\tstart = 1 + (ast_random() % (TRUNK_CALL_START - 1));",
                "\t\tfor (x = start; 1; x++) {",
                "\t\t\tif (x == TRUNK_CALL_START) {",
                "\t\t\t\tx = 0;",
                "\t\t\t\tcontinue;",
                "\t\t\t}",
                "",
                "\t\t\tif (!iaxs[x] && ((now.tv_sec - lastused[x].tv_sec) > MIN_REUSE_TIME)) {",
                "\t\t\t\tfound = 1;",
                "\t\t\t\tbreak;",
                "\t\t\t}",
                "\t\t\t",
                "\t\t\tif (x == start - 1) {",
                "\t\t\t\tbreak;",
                "\t\t\t}",
                "\t\tif (x == start - 1 && !found) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2008-1897",
        "func_name": "pruiz/asterisk/find_callno",
        "description": "The IAX2 channel driver (chan_iax2) in Asterisk Open Source 1.0.x, 1.2.x before 1.2.28, and 1.4.x before 1.4.19.1; Business Edition A.x.x, B.x.x before B.2.5.2, and C.x.x before C.1.8.1; AsteriskNOW before 1.0.3; Appliance Developer Kit 0.x.x; and s800i before 1.1.0.3, when configured to allow unauthenticated calls, does not verify that an ACK response contains a call number matching the server's reply to a NEW message, which allows remote attackers to cause a denial of service (traffic amplification) via a spoofed ACK response that does not complete a 3-way handshake.  NOTE: this issue exists because of an incomplete fix for CVE-2008-1923.",
        "git_url": "https://github.com/pruiz/asterisk/commit/e0ef9bd22810c6969a7f222eec04798f19a7e2d6",
        "commit_title": "Merged revisions 114558 via svnmerge from ",
        "commit_text": "https://origsvn.digium.com/svn/asterisk/branches/1.4  ........ r114558 | russell | 2008-04-22 17:15:36 -0500 (Tue, 22 Apr 2008) | 5 lines  When we receive a full frame that is supposed to contain our call number, ensure that it has the correct one. (closes issue #10078) (AST-2008-006)  ........  ",
        "func_before": "static int find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd) {\n\n\treturn __find_callno(callno, dcallno, sin, new, sockfd, 0);\n}",
        "func": "static int find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int full_frame) {\n\n\treturn __find_callno(callno, dcallno, sin, new, sockfd, 0, full_frame);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,4 @@\n-static int find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd) {\n+static int find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int full_frame) {\n \n-\treturn __find_callno(callno, dcallno, sin, new, sockfd, 0);\n+\treturn __find_callno(callno, dcallno, sin, new, sockfd, 0, full_frame);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "static int find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd) {",
                "\treturn __find_callno(callno, dcallno, sin, new, sockfd, 0);"
            ],
            "added_lines": [
                "static int find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int full_frame) {",
                "\treturn __find_callno(callno, dcallno, sin, new, sockfd, 0, full_frame);"
            ]
        }
    },
    {
        "cve_id": "CVE-2008-1897",
        "func_name": "pruiz/asterisk/iax2_do_register",
        "description": "The IAX2 channel driver (chan_iax2) in Asterisk Open Source 1.0.x, 1.2.x before 1.2.28, and 1.4.x before 1.4.19.1; Business Edition A.x.x, B.x.x before B.2.5.2, and C.x.x before C.1.8.1; AsteriskNOW before 1.0.3; Appliance Developer Kit 0.x.x; and s800i before 1.1.0.3, when configured to allow unauthenticated calls, does not verify that an ACK response contains a call number matching the server's reply to a NEW message, which allows remote attackers to cause a denial of service (traffic amplification) via a spoofed ACK response that does not complete a 3-way handshake.  NOTE: this issue exists because of an incomplete fix for CVE-2008-1923.",
        "git_url": "https://github.com/pruiz/asterisk/commit/e0ef9bd22810c6969a7f222eec04798f19a7e2d6",
        "commit_title": "Merged revisions 114558 via svnmerge from ",
        "commit_text": "https://origsvn.digium.com/svn/asterisk/branches/1.4  ........ r114558 | russell | 2008-04-22 17:15:36 -0500 (Tue, 22 Apr 2008) | 5 lines  When we receive a full frame that is supposed to contain our call number, ensure that it has the correct one. (closes issue #10078) (AST-2008-006)  ........  ",
        "func_before": "static int iax2_do_register(struct iax2_registry *reg)\n{\n\tstruct iax_ie_data ied;\n\tif (iaxdebug)\n\t\tast_debug(1, \"Sending registration request for '%s'\\n\", reg->username);\n\n\tif (reg->dnsmgr && \n\t    ((reg->regstate == REG_STATE_TIMEOUT) || !reg->addr.sin_addr.s_addr)) {\n\t\t/* Maybe the IP has changed, force DNS refresh */\n\t\tast_dnsmgr_refresh(reg->dnsmgr);\n\t}\n\t\n\t/*\n\t * if IP has Changed, free allocated call to create a new one with new IP\n\t * call has the pointer to IP and must be updated to the new one\n\t */\n\tif (reg->dnsmgr && ast_dnsmgr_changed(reg->dnsmgr) && (reg->callno > 0)) {\n\t\tast_mutex_lock(&iaxsl[reg->callno]);\n\t\tiax2_destroy(reg->callno);\n\t\tast_mutex_unlock(&iaxsl[reg->callno]);\n\t\treg->callno = 0;\n\t}\n\tif (!reg->addr.sin_addr.s_addr) {\n\t\tif (iaxdebug)\n\t\t\tast_debug(1, \"Unable to send registration request for '%s' without IP address\\n\", reg->username);\n\t\t/* Setup the next registration attempt */\n\t\treg->expire = iax2_sched_replace(reg->expire, sched, \n\t\t\t(5 * reg->refresh / 6) * 1000, iax2_do_register_s, reg);\n\t\treturn -1;\n\t}\n\n\tif (!reg->callno) {\n\t\tast_debug(1, \"Allocate call number\\n\");\n\t\treg->callno = find_callno_locked(0, 0, &reg->addr, NEW_FORCE, defaultsockfd);\n\t\tif (reg->callno < 1) {\n\t\t\tast_log(LOG_WARNING, \"Unable to create call for registration\\n\");\n\t\t\treturn -1;\n\t\t} else\n\t\t\tast_debug(1, \"Registration created on call %d\\n\", reg->callno);\n\t\tiaxs[reg->callno]->reg = reg;\n\t\tast_mutex_unlock(&iaxsl[reg->callno]);\n\t}\n\t/* Setup the next registration a little early */\n\treg->expire = iax2_sched_replace(reg->expire, sched, \n\t\t(5 * reg->refresh / 6) * 1000, iax2_do_register_s, reg);\n\t/* Send the request */\n\tmemset(&ied, 0, sizeof(ied));\n\tiax_ie_append_str(&ied, IAX_IE_USERNAME, reg->username);\n\tiax_ie_append_short(&ied, IAX_IE_REFRESH, reg->refresh);\n\tsend_command(iaxs[reg->callno],AST_FRAME_IAX, IAX_COMMAND_REGREQ, 0, ied.buf, ied.pos, -1);\n\treg->regstate = REG_STATE_REGSENT;\n\treturn 0;\n}",
        "func": "static int iax2_do_register(struct iax2_registry *reg)\n{\n\tstruct iax_ie_data ied;\n\tif (iaxdebug)\n\t\tast_debug(1, \"Sending registration request for '%s'\\n\", reg->username);\n\n\tif (reg->dnsmgr && \n\t    ((reg->regstate == REG_STATE_TIMEOUT) || !reg->addr.sin_addr.s_addr)) {\n\t\t/* Maybe the IP has changed, force DNS refresh */\n\t\tast_dnsmgr_refresh(reg->dnsmgr);\n\t}\n\t\n\t/*\n\t * if IP has Changed, free allocated call to create a new one with new IP\n\t * call has the pointer to IP and must be updated to the new one\n\t */\n\tif (reg->dnsmgr && ast_dnsmgr_changed(reg->dnsmgr) && (reg->callno > 0)) {\n\t\tast_mutex_lock(&iaxsl[reg->callno]);\n\t\tiax2_destroy(reg->callno);\n\t\tast_mutex_unlock(&iaxsl[reg->callno]);\n\t\treg->callno = 0;\n\t}\n\tif (!reg->addr.sin_addr.s_addr) {\n\t\tif (iaxdebug)\n\t\t\tast_debug(1, \"Unable to send registration request for '%s' without IP address\\n\", reg->username);\n\t\t/* Setup the next registration attempt */\n\t\treg->expire = iax2_sched_replace(reg->expire, sched, \n\t\t\t(5 * reg->refresh / 6) * 1000, iax2_do_register_s, reg);\n\t\treturn -1;\n\t}\n\n\tif (!reg->callno) {\n\t\tast_debug(1, \"Allocate call number\\n\");\n\t\treg->callno = find_callno_locked(0, 0, &reg->addr, NEW_FORCE, defaultsockfd, 0);\n\t\tif (reg->callno < 1) {\n\t\t\tast_log(LOG_WARNING, \"Unable to create call for registration\\n\");\n\t\t\treturn -1;\n\t\t} else\n\t\t\tast_debug(1, \"Registration created on call %d\\n\", reg->callno);\n\t\tiaxs[reg->callno]->reg = reg;\n\t\tast_mutex_unlock(&iaxsl[reg->callno]);\n\t}\n\t/* Setup the next registration a little early */\n\treg->expire = iax2_sched_replace(reg->expire, sched, \n\t\t(5 * reg->refresh / 6) * 1000, iax2_do_register_s, reg);\n\t/* Send the request */\n\tmemset(&ied, 0, sizeof(ied));\n\tiax_ie_append_str(&ied, IAX_IE_USERNAME, reg->username);\n\tiax_ie_append_short(&ied, IAX_IE_REFRESH, reg->refresh);\n\tsend_command(iaxs[reg->callno],AST_FRAME_IAX, IAX_COMMAND_REGREQ, 0, ied.buf, ied.pos, -1);\n\treg->regstate = REG_STATE_REGSENT;\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -31,7 +31,7 @@\n \n \tif (!reg->callno) {\n \t\tast_debug(1, \"Allocate call number\\n\");\n-\t\treg->callno = find_callno_locked(0, 0, &reg->addr, NEW_FORCE, defaultsockfd);\n+\t\treg->callno = find_callno_locked(0, 0, &reg->addr, NEW_FORCE, defaultsockfd, 0);\n \t\tif (reg->callno < 1) {\n \t\t\tast_log(LOG_WARNING, \"Unable to create call for registration\\n\");\n \t\t\treturn -1;",
        "diff_line_info": {
            "deleted_lines": [
                "\t\treg->callno = find_callno_locked(0, 0, &reg->addr, NEW_FORCE, defaultsockfd);"
            ],
            "added_lines": [
                "\t\treg->callno = find_callno_locked(0, 0, &reg->addr, NEW_FORCE, defaultsockfd, 0);"
            ]
        }
    },
    {
        "cve_id": "CVE-2008-1897",
        "func_name": "pruiz/asterisk/iax2_poke_peer",
        "description": "The IAX2 channel driver (chan_iax2) in Asterisk Open Source 1.0.x, 1.2.x before 1.2.28, and 1.4.x before 1.4.19.1; Business Edition A.x.x, B.x.x before B.2.5.2, and C.x.x before C.1.8.1; AsteriskNOW before 1.0.3; Appliance Developer Kit 0.x.x; and s800i before 1.1.0.3, when configured to allow unauthenticated calls, does not verify that an ACK response contains a call number matching the server's reply to a NEW message, which allows remote attackers to cause a denial of service (traffic amplification) via a spoofed ACK response that does not complete a 3-way handshake.  NOTE: this issue exists because of an incomplete fix for CVE-2008-1923.",
        "git_url": "https://github.com/pruiz/asterisk/commit/e0ef9bd22810c6969a7f222eec04798f19a7e2d6",
        "commit_title": "Merged revisions 114558 via svnmerge from ",
        "commit_text": "https://origsvn.digium.com/svn/asterisk/branches/1.4  ........ r114558 | russell | 2008-04-22 17:15:36 -0500 (Tue, 22 Apr 2008) | 5 lines  When we receive a full frame that is supposed to contain our call number, ensure that it has the correct one. (closes issue #10078) (AST-2008-006)  ........  ",
        "func_before": "static int iax2_poke_peer(struct iax2_peer *peer, int heldcall)\n{\n\tif (!peer->maxms || (!peer->addr.sin_addr.s_addr && !peer->dnsmgr)) {\n\t\t/* IF we have no IP without dnsmgr, or this isn't to be monitored, return\n\t\t  immediately after clearing things out */\n\t\tpeer->lastms = 0;\n\t\tpeer->historicms = 0;\n\t\tpeer->pokeexpire = -1;\n\t\tpeer->callno = 0;\n\t\treturn 0;\n\t}\n\tif (peer->callno > 0) {\n\t\tast_log(LOG_NOTICE, \"Still have a callno...\\n\");\n\t\tast_mutex_lock(&iaxsl[peer->callno]);\n\t\tiax2_destroy(peer->callno);\n\t\tast_mutex_unlock(&iaxsl[peer->callno]);\n\t}\n\tif (heldcall)\n\t\tast_mutex_unlock(&iaxsl[heldcall]);\n\tpeer->callno = find_callno(0, 0, &peer->addr, NEW_FORCE, peer->sockfd);\n\tif (heldcall)\n\t\tast_mutex_lock(&iaxsl[heldcall]);\n\tif (peer->callno < 1) {\n\t\tast_log(LOG_WARNING, \"Unable to allocate call for poking peer '%s'\\n\", peer->name);\n\t\treturn -1;\n\t}\n\n\t/* Speed up retransmission times for this qualify call */\n\tiaxs[peer->callno]->pingtime = peer->maxms / 4 + 1;\n\tiaxs[peer->callno]->peerpoke = peer;\n\n \tif (peer->pokeexpire > -1) {\n \t\tif (!ast_sched_del(sched, peer->pokeexpire)) {\n \t\t\tpeer->pokeexpire = -1;\n \t\t\tpeer_unref(peer);\n \t\t}\n \t}\n \n\t/* Queue up a new task to handle no reply */\n\t/* If the host is already unreachable then use the unreachable interval instead */\n\tif (peer->lastms < 0)\n \t\tpeer->pokeexpire = iax2_sched_add(sched, peer->pokefreqnotok, iax2_poke_noanswer, peer_ref(peer));\n\telse\n \t\tpeer->pokeexpire = iax2_sched_add(sched, DEFAULT_MAXMS * 2, iax2_poke_noanswer, peer_ref(peer));\n\n \tif (peer->pokeexpire == -1)\n \t\tpeer_unref(peer);\n\n\t/* And send the poke */\n\tsend_command(iaxs[peer->callno], AST_FRAME_IAX, IAX_COMMAND_POKE, 0, NULL, 0, -1);\n\n\treturn 0;\n}",
        "func": "static int iax2_poke_peer(struct iax2_peer *peer, int heldcall)\n{\n\tif (!peer->maxms || (!peer->addr.sin_addr.s_addr && !peer->dnsmgr)) {\n\t\t/* IF we have no IP without dnsmgr, or this isn't to be monitored, return\n\t\t  immediately after clearing things out */\n\t\tpeer->lastms = 0;\n\t\tpeer->historicms = 0;\n\t\tpeer->pokeexpire = -1;\n\t\tpeer->callno = 0;\n\t\treturn 0;\n\t}\n\tif (peer->callno > 0) {\n\t\tast_log(LOG_NOTICE, \"Still have a callno...\\n\");\n\t\tast_mutex_lock(&iaxsl[peer->callno]);\n\t\tiax2_destroy(peer->callno);\n\t\tast_mutex_unlock(&iaxsl[peer->callno]);\n\t}\n\tif (heldcall)\n\t\tast_mutex_unlock(&iaxsl[heldcall]);\n\tpeer->callno = find_callno(0, 0, &peer->addr, NEW_FORCE, peer->sockfd, 0);\n\tif (heldcall)\n\t\tast_mutex_lock(&iaxsl[heldcall]);\n\tif (peer->callno < 1) {\n\t\tast_log(LOG_WARNING, \"Unable to allocate call for poking peer '%s'\\n\", peer->name);\n\t\treturn -1;\n\t}\n\n\t/* Speed up retransmission times for this qualify call */\n\tiaxs[peer->callno]->pingtime = peer->maxms / 4 + 1;\n\tiaxs[peer->callno]->peerpoke = peer;\n\n \tif (peer->pokeexpire > -1) {\n \t\tif (!ast_sched_del(sched, peer->pokeexpire)) {\n \t\t\tpeer->pokeexpire = -1;\n \t\t\tpeer_unref(peer);\n \t\t}\n \t}\n \n\t/* Queue up a new task to handle no reply */\n\t/* If the host is already unreachable then use the unreachable interval instead */\n\tif (peer->lastms < 0)\n \t\tpeer->pokeexpire = iax2_sched_add(sched, peer->pokefreqnotok, iax2_poke_noanswer, peer_ref(peer));\n\telse\n \t\tpeer->pokeexpire = iax2_sched_add(sched, DEFAULT_MAXMS * 2, iax2_poke_noanswer, peer_ref(peer));\n\n \tif (peer->pokeexpire == -1)\n \t\tpeer_unref(peer);\n\n\t/* And send the poke */\n\tsend_command(iaxs[peer->callno], AST_FRAME_IAX, IAX_COMMAND_POKE, 0, NULL, 0, -1);\n\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -17,7 +17,7 @@\n \t}\n \tif (heldcall)\n \t\tast_mutex_unlock(&iaxsl[heldcall]);\n-\tpeer->callno = find_callno(0, 0, &peer->addr, NEW_FORCE, peer->sockfd);\n+\tpeer->callno = find_callno(0, 0, &peer->addr, NEW_FORCE, peer->sockfd, 0);\n \tif (heldcall)\n \t\tast_mutex_lock(&iaxsl[heldcall]);\n \tif (peer->callno < 1) {",
        "diff_line_info": {
            "deleted_lines": [
                "\tpeer->callno = find_callno(0, 0, &peer->addr, NEW_FORCE, peer->sockfd);"
            ],
            "added_lines": [
                "\tpeer->callno = find_callno(0, 0, &peer->addr, NEW_FORCE, peer->sockfd, 0);"
            ]
        }
    },
    {
        "cve_id": "CVE-2008-1897",
        "func_name": "pruiz/asterisk/cache_get_callno_locked",
        "description": "The IAX2 channel driver (chan_iax2) in Asterisk Open Source 1.0.x, 1.2.x before 1.2.28, and 1.4.x before 1.4.19.1; Business Edition A.x.x, B.x.x before B.2.5.2, and C.x.x before C.1.8.1; AsteriskNOW before 1.0.3; Appliance Developer Kit 0.x.x; and s800i before 1.1.0.3, when configured to allow unauthenticated calls, does not verify that an ACK response contains a call number matching the server's reply to a NEW message, which allows remote attackers to cause a denial of service (traffic amplification) via a spoofed ACK response that does not complete a 3-way handshake.  NOTE: this issue exists because of an incomplete fix for CVE-2008-1923.",
        "git_url": "https://github.com/pruiz/asterisk/commit/e0ef9bd22810c6969a7f222eec04798f19a7e2d6",
        "commit_title": "Merged revisions 114558 via svnmerge from ",
        "commit_text": "https://origsvn.digium.com/svn/asterisk/branches/1.4  ........ r114558 | russell | 2008-04-22 17:15:36 -0500 (Tue, 22 Apr 2008) | 5 lines  When we receive a full frame that is supposed to contain our call number, ensure that it has the correct one. (closes issue #10078) (AST-2008-006)  ........  ",
        "func_before": "static int cache_get_callno_locked(const char *data)\n{\n\tstruct sockaddr_in sin;\n\tint x;\n\tint callno;\n\tstruct iax_ie_data ied;\n\tstruct create_addr_info cai;\n\tstruct parsed_dial_string pds;\n\tchar *tmpstr;\n\n\tfor (x=0; x<IAX_MAX_CALLS; x++) {\n\t\t/* Look for an *exact match* call.  Once a call is negotiated, it can only\n\t\t   look up entries for a single context */\n\t\tif (!ast_mutex_trylock(&iaxsl[x])) {\n\t\t\tif (iaxs[x] && !strcasecmp(data, iaxs[x]->dproot))\n\t\t\t\treturn x;\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t}\n\t}\n\n\t/* No match found, we need to create a new one */\n\n\tmemset(&cai, 0, sizeof(cai));\n\tmemset(&ied, 0, sizeof(ied));\n\tmemset(&pds, 0, sizeof(pds));\n\n\ttmpstr = ast_strdupa(data);\n\tparse_dial_string(tmpstr, &pds);\n\n\tif (ast_strlen_zero(pds.peer)) {\n\t\tast_log(LOG_WARNING, \"No peer provided in the IAX2 dial string '%s'\\n\", data);\n\t\treturn -1;\n\t}\n\n\t/* Populate our address from the given */\n\tif (create_addr(pds.peer, NULL, &sin, &cai))\n\t\treturn -1;\n\n\tast_debug(1, \"peer: %s, username: %s, password: %s, context: %s\\n\",\n\t\tpds.peer, pds.username, pds.password, pds.context);\n\n\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd);\n\tif (callno < 1) {\n\t\tast_log(LOG_WARNING, \"Unable to create call\\n\");\n\t\treturn -1;\n\t}\n\n\tast_string_field_set(iaxs[callno], dproot, data);\n\tiaxs[callno]->capability = IAX_CAPABILITY_FULLBANDWIDTH;\n\n\tiax_ie_append_short(&ied, IAX_IE_VERSION, IAX_PROTO_VERSION);\n\tiax_ie_append_str(&ied, IAX_IE_CALLED_NUMBER, \"TBD\");\n\t/* the string format is slightly different from a standard dial string,\n\t   because the context appears in the 'exten' position\n\t*/\n\tif (pds.exten)\n\t\tiax_ie_append_str(&ied, IAX_IE_CALLED_CONTEXT, pds.exten);\n\tif (pds.username)\n\t\tiax_ie_append_str(&ied, IAX_IE_USERNAME, pds.username);\n\tiax_ie_append_int(&ied, IAX_IE_FORMAT, IAX_CAPABILITY_FULLBANDWIDTH);\n\tiax_ie_append_int(&ied, IAX_IE_CAPABILITY, IAX_CAPABILITY_FULLBANDWIDTH);\n\t/* Keep password handy */\n\tif (pds.password)\n\t\tast_string_field_set(iaxs[callno], secret, pds.password);\n\tif (pds.key)\n\t\tast_string_field_set(iaxs[callno], outkey, pds.key);\n\t/* Start the call going */\n\tsend_command(iaxs[callno], AST_FRAME_IAX, IAX_COMMAND_NEW, 0, ied.buf, ied.pos, -1);\n\n\treturn callno;\n}",
        "func": "static int cache_get_callno_locked(const char *data)\n{\n\tstruct sockaddr_in sin;\n\tint x;\n\tint callno;\n\tstruct iax_ie_data ied;\n\tstruct create_addr_info cai;\n\tstruct parsed_dial_string pds;\n\tchar *tmpstr;\n\n\tfor (x=0; x<IAX_MAX_CALLS; x++) {\n\t\t/* Look for an *exact match* call.  Once a call is negotiated, it can only\n\t\t   look up entries for a single context */\n\t\tif (!ast_mutex_trylock(&iaxsl[x])) {\n\t\t\tif (iaxs[x] && !strcasecmp(data, iaxs[x]->dproot))\n\t\t\t\treturn x;\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t}\n\t}\n\n\t/* No match found, we need to create a new one */\n\n\tmemset(&cai, 0, sizeof(cai));\n\tmemset(&ied, 0, sizeof(ied));\n\tmemset(&pds, 0, sizeof(pds));\n\n\ttmpstr = ast_strdupa(data);\n\tparse_dial_string(tmpstr, &pds);\n\n\tif (ast_strlen_zero(pds.peer)) {\n\t\tast_log(LOG_WARNING, \"No peer provided in the IAX2 dial string '%s'\\n\", data);\n\t\treturn -1;\n\t}\n\n\t/* Populate our address from the given */\n\tif (create_addr(pds.peer, NULL, &sin, &cai))\n\t\treturn -1;\n\n\tast_debug(1, \"peer: %s, username: %s, password: %s, context: %s\\n\",\n\t\tpds.peer, pds.username, pds.password, pds.context);\n\n\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd, 0);\n\tif (callno < 1) {\n\t\tast_log(LOG_WARNING, \"Unable to create call\\n\");\n\t\treturn -1;\n\t}\n\n\tast_string_field_set(iaxs[callno], dproot, data);\n\tiaxs[callno]->capability = IAX_CAPABILITY_FULLBANDWIDTH;\n\n\tiax_ie_append_short(&ied, IAX_IE_VERSION, IAX_PROTO_VERSION);\n\tiax_ie_append_str(&ied, IAX_IE_CALLED_NUMBER, \"TBD\");\n\t/* the string format is slightly different from a standard dial string,\n\t   because the context appears in the 'exten' position\n\t*/\n\tif (pds.exten)\n\t\tiax_ie_append_str(&ied, IAX_IE_CALLED_CONTEXT, pds.exten);\n\tif (pds.username)\n\t\tiax_ie_append_str(&ied, IAX_IE_USERNAME, pds.username);\n\tiax_ie_append_int(&ied, IAX_IE_FORMAT, IAX_CAPABILITY_FULLBANDWIDTH);\n\tiax_ie_append_int(&ied, IAX_IE_CAPABILITY, IAX_CAPABILITY_FULLBANDWIDTH);\n\t/* Keep password handy */\n\tif (pds.password)\n\t\tast_string_field_set(iaxs[callno], secret, pds.password);\n\tif (pds.key)\n\t\tast_string_field_set(iaxs[callno], outkey, pds.key);\n\t/* Start the call going */\n\tsend_command(iaxs[callno], AST_FRAME_IAX, IAX_COMMAND_NEW, 0, ied.buf, ied.pos, -1);\n\n\treturn callno;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -39,7 +39,7 @@\n \tast_debug(1, \"peer: %s, username: %s, password: %s, context: %s\\n\",\n \t\tpds.peer, pds.username, pds.password, pds.context);\n \n-\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd);\n+\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd, 0);\n \tif (callno < 1) {\n \t\tast_log(LOG_WARNING, \"Unable to create call\\n\");\n \t\treturn -1;",
        "diff_line_info": {
            "deleted_lines": [
                "\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd);"
            ],
            "added_lines": [
                "\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd, 0);"
            ]
        }
    },
    {
        "cve_id": "CVE-2008-1897",
        "func_name": "pruiz/asterisk/iax2_provision",
        "description": "The IAX2 channel driver (chan_iax2) in Asterisk Open Source 1.0.x, 1.2.x before 1.2.28, and 1.4.x before 1.4.19.1; Business Edition A.x.x, B.x.x before B.2.5.2, and C.x.x before C.1.8.1; AsteriskNOW before 1.0.3; Appliance Developer Kit 0.x.x; and s800i before 1.1.0.3, when configured to allow unauthenticated calls, does not verify that an ACK response contains a call number matching the server's reply to a NEW message, which allows remote attackers to cause a denial of service (traffic amplification) via a spoofed ACK response that does not complete a 3-way handshake.  NOTE: this issue exists because of an incomplete fix for CVE-2008-1923.",
        "git_url": "https://github.com/pruiz/asterisk/commit/e0ef9bd22810c6969a7f222eec04798f19a7e2d6",
        "commit_title": "Merged revisions 114558 via svnmerge from ",
        "commit_text": "https://origsvn.digium.com/svn/asterisk/branches/1.4  ........ r114558 | russell | 2008-04-22 17:15:36 -0500 (Tue, 22 Apr 2008) | 5 lines  When we receive a full frame that is supposed to contain our call number, ensure that it has the correct one. (closes issue #10078) (AST-2008-006)  ........  ",
        "func_before": "static int iax2_provision(struct sockaddr_in *end, int sockfd, char *dest, const char *template, int force)\n{\n\t/* Returns 1 if provisioned, -1 if not able to find destination, or 0 if no provisioning\n\t   is found for template */\n\tstruct iax_ie_data provdata;\n\tstruct iax_ie_data ied;\n\tunsigned int sig;\n\tstruct sockaddr_in sin;\n\tint callno;\n\tstruct create_addr_info cai;\n\n\tmemset(&cai, 0, sizeof(cai));\n\n\tast_debug(1, \"Provisioning '%s' from template '%s'\\n\", dest, template);\n\n\tif (iax_provision_build(&provdata, &sig, template, force)) {\n\t\tast_debug(1, \"No provisioning found for template '%s'\\n\", template);\n\t\treturn 0;\n\t}\n\n\tif (end) {\n\t\tmemcpy(&sin, end, sizeof(sin));\n\t\tcai.sockfd = sockfd;\n\t} else if (create_addr(dest, NULL, &sin, &cai))\n\t\treturn -1;\n\n\t/* Build the rest of the message */\n\tmemset(&ied, 0, sizeof(ied));\n\tiax_ie_append_raw(&ied, IAX_IE_PROVISIONING, provdata.buf, provdata.pos);\n\n\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd);\n\tif (!callno)\n\t\treturn -1;\n\n\tif (iaxs[callno]) {\n\t\t/* Schedule autodestruct in case they don't ever give us anything back */\n\t\tiaxs[callno]->autoid = iax2_sched_replace(iaxs[callno]->autoid, \n\t\t\tsched, 15000, auto_hangup, (void *)(long)callno);\n\t\tast_set_flag(iaxs[callno], IAX_PROVISION);\n\t\t/* Got a call number now, so go ahead and send the provisioning information */\n\t\tsend_command(iaxs[callno], AST_FRAME_IAX, IAX_COMMAND_PROVISION, 0, ied.buf, ied.pos, -1);\n\t}\n\tast_mutex_unlock(&iaxsl[callno]);\n\n\treturn 1;\n}",
        "func": "static int iax2_provision(struct sockaddr_in *end, int sockfd, char *dest, const char *template, int force)\n{\n\t/* Returns 1 if provisioned, -1 if not able to find destination, or 0 if no provisioning\n\t   is found for template */\n\tstruct iax_ie_data provdata;\n\tstruct iax_ie_data ied;\n\tunsigned int sig;\n\tstruct sockaddr_in sin;\n\tint callno;\n\tstruct create_addr_info cai;\n\n\tmemset(&cai, 0, sizeof(cai));\n\n\tast_debug(1, \"Provisioning '%s' from template '%s'\\n\", dest, template);\n\n\tif (iax_provision_build(&provdata, &sig, template, force)) {\n\t\tast_debug(1, \"No provisioning found for template '%s'\\n\", template);\n\t\treturn 0;\n\t}\n\n\tif (end) {\n\t\tmemcpy(&sin, end, sizeof(sin));\n\t\tcai.sockfd = sockfd;\n\t} else if (create_addr(dest, NULL, &sin, &cai))\n\t\treturn -1;\n\n\t/* Build the rest of the message */\n\tmemset(&ied, 0, sizeof(ied));\n\tiax_ie_append_raw(&ied, IAX_IE_PROVISIONING, provdata.buf, provdata.pos);\n\n\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd, 0);\n\tif (!callno)\n\t\treturn -1;\n\n\tif (iaxs[callno]) {\n\t\t/* Schedule autodestruct in case they don't ever give us anything back */\n\t\tiaxs[callno]->autoid = iax2_sched_replace(iaxs[callno]->autoid, \n\t\t\tsched, 15000, auto_hangup, (void *)(long)callno);\n\t\tast_set_flag(iaxs[callno], IAX_PROVISION);\n\t\t/* Got a call number now, so go ahead and send the provisioning information */\n\t\tsend_command(iaxs[callno], AST_FRAME_IAX, IAX_COMMAND_PROVISION, 0, ied.buf, ied.pos, -1);\n\t}\n\tast_mutex_unlock(&iaxsl[callno]);\n\n\treturn 1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -28,7 +28,7 @@\n \tmemset(&ied, 0, sizeof(ied));\n \tiax_ie_append_raw(&ied, IAX_IE_PROVISIONING, provdata.buf, provdata.pos);\n \n-\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd);\n+\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd, 0);\n \tif (!callno)\n \t\treturn -1;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd);"
            ],
            "added_lines": [
                "\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd, 0);"
            ]
        }
    },
    {
        "cve_id": "CVE-2008-1897",
        "func_name": "pruiz/asterisk/match",
        "description": "The IAX2 channel driver (chan_iax2) in Asterisk Open Source 1.0.x, 1.2.x before 1.2.28, and 1.4.x before 1.4.19.1; Business Edition A.x.x, B.x.x before B.2.5.2, and C.x.x before C.1.8.1; AsteriskNOW before 1.0.3; Appliance Developer Kit 0.x.x; and s800i before 1.1.0.3, when configured to allow unauthenticated calls, does not verify that an ACK response contains a call number matching the server's reply to a NEW message, which allows remote attackers to cause a denial of service (traffic amplification) via a spoofed ACK response that does not complete a 3-way handshake.  NOTE: this issue exists because of an incomplete fix for CVE-2008-1923.",
        "git_url": "https://github.com/pruiz/asterisk/commit/e0ef9bd22810c6969a7f222eec04798f19a7e2d6",
        "commit_title": "Merged revisions 114558 via svnmerge from ",
        "commit_text": "https://origsvn.digium.com/svn/asterisk/branches/1.4  ........ r114558 | russell | 2008-04-22 17:15:36 -0500 (Tue, 22 Apr 2008) | 5 lines  When we receive a full frame that is supposed to contain our call number, ensure that it has the correct one. (closes issue #10078) (AST-2008-006)  ........  ",
        "func_before": "static int match(struct sockaddr_in *sin, unsigned short callno, unsigned short dcallno, const struct chan_iax2_pvt *cur)\n{\n\tif ((cur->addr.sin_addr.s_addr == sin->sin_addr.s_addr) &&\n\t\t(cur->addr.sin_port == sin->sin_port)) {\n\t\t/* This is the main host */\n\t\tif ((cur->peercallno == callno) ||\n\t\t\t((dcallno == cur->callno) && !cur->peercallno)) {\n\t\t\t/* That's us.  Be sure we keep track of the peer call number */\n\t\t\treturn 1;\n\t\t}\n\t}\n\tif ((cur->transfer.sin_addr.s_addr == sin->sin_addr.s_addr) &&\n\t    (cur->transfer.sin_port == sin->sin_port) && (cur->transferring)) {\n\t\t/* We're transferring */\n\t\tif ((dcallno == cur->callno) || (cur->transferring == TRANSFER_MEDIAPASS && cur->transfercallno == callno))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
        "func": "static int match(struct sockaddr_in *sin, unsigned short callno, unsigned short dcallno, const struct chan_iax2_pvt *cur, int full_frame)\n{\n\tif ((cur->addr.sin_addr.s_addr == sin->sin_addr.s_addr) &&\n\t\t(cur->addr.sin_port == sin->sin_port)) {\n\t\t/* This is the main host */\n\t\tif ( (cur->peercallno == 0 || cur->peercallno == callno) &&\n\t\t\t (full_frame ? dcallno == cur->callno : 1) ) {\n\t\t\t/* That's us.  Be sure we keep track of the peer call number */\n\t\t\treturn 1;\n\t\t}\n\t}\n\tif ((cur->transfer.sin_addr.s_addr == sin->sin_addr.s_addr) &&\n\t    (cur->transfer.sin_port == sin->sin_port) && (cur->transferring)) {\n\t\t/* We're transferring */\n\t\tif ((dcallno == cur->callno) || (cur->transferring == TRANSFER_MEDIAPASS && cur->transfercallno == callno))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,10 +1,10 @@\n-static int match(struct sockaddr_in *sin, unsigned short callno, unsigned short dcallno, const struct chan_iax2_pvt *cur)\n+static int match(struct sockaddr_in *sin, unsigned short callno, unsigned short dcallno, const struct chan_iax2_pvt *cur, int full_frame)\n {\n \tif ((cur->addr.sin_addr.s_addr == sin->sin_addr.s_addr) &&\n \t\t(cur->addr.sin_port == sin->sin_port)) {\n \t\t/* This is the main host */\n-\t\tif ((cur->peercallno == callno) ||\n-\t\t\t((dcallno == cur->callno) && !cur->peercallno)) {\n+\t\tif ( (cur->peercallno == 0 || cur->peercallno == callno) &&\n+\t\t\t (full_frame ? dcallno == cur->callno : 1) ) {\n \t\t\t/* That's us.  Be sure we keep track of the peer call number */\n \t\t\treturn 1;\n \t\t}",
        "diff_line_info": {
            "deleted_lines": [
                "static int match(struct sockaddr_in *sin, unsigned short callno, unsigned short dcallno, const struct chan_iax2_pvt *cur)",
                "\t\tif ((cur->peercallno == callno) ||",
                "\t\t\t((dcallno == cur->callno) && !cur->peercallno)) {"
            ],
            "added_lines": [
                "static int match(struct sockaddr_in *sin, unsigned short callno, unsigned short dcallno, const struct chan_iax2_pvt *cur, int full_frame)",
                "\t\tif ( (cur->peercallno == 0 || cur->peercallno == callno) &&",
                "\t\t\t (full_frame ? dcallno == cur->callno : 1) ) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2008-1897",
        "func_name": "pruiz/asterisk/socket_process_meta",
        "description": "The IAX2 channel driver (chan_iax2) in Asterisk Open Source 1.0.x, 1.2.x before 1.2.28, and 1.4.x before 1.4.19.1; Business Edition A.x.x, B.x.x before B.2.5.2, and C.x.x before C.1.8.1; AsteriskNOW before 1.0.3; Appliance Developer Kit 0.x.x; and s800i before 1.1.0.3, when configured to allow unauthenticated calls, does not verify that an ACK response contains a call number matching the server's reply to a NEW message, which allows remote attackers to cause a denial of service (traffic amplification) via a spoofed ACK response that does not complete a 3-way handshake.  NOTE: this issue exists because of an incomplete fix for CVE-2008-1923.",
        "git_url": "https://github.com/pruiz/asterisk/commit/e0ef9bd22810c6969a7f222eec04798f19a7e2d6",
        "commit_title": "Merged revisions 114558 via svnmerge from ",
        "commit_text": "https://origsvn.digium.com/svn/asterisk/branches/1.4  ........ r114558 | russell | 2008-04-22 17:15:36 -0500 (Tue, 22 Apr 2008) | 5 lines  When we receive a full frame that is supposed to contain our call number, ensure that it has the correct one. (closes issue #10078) (AST-2008-006)  ........  ",
        "func_before": "static int socket_process_meta(int packet_len, struct ast_iax2_meta_hdr *meta, struct sockaddr_in *sin, int sockfd,\n\tstruct iax_frame *fr)\n{\n\tunsigned char metatype;\n\tstruct ast_iax2_meta_trunk_mini *mtm;\n\tstruct ast_iax2_meta_trunk_hdr *mth;\n\tstruct ast_iax2_meta_trunk_entry *mte;\n\tstruct iax2_trunk_peer *tpeer;\n\tunsigned int ts;\n\tvoid *ptr;\n\tstruct timeval rxtrunktime;\n\tstruct ast_frame f = { 0, };\n\n\tif (packet_len < sizeof(*meta)) {\n\t\tast_log(LOG_WARNING, \"Rejecting packet from '%s.%d' that is flagged as a meta frame but is too short\\n\", \n\t\t\tast_inet_ntoa(sin->sin_addr), ntohs(sin->sin_port));\n\t\treturn 1;\n\t}\n\n\tif (meta->metacmd != IAX_META_TRUNK)\n\t\treturn 1;\n\n\tif (packet_len < (sizeof(*meta) + sizeof(*mth))) {\n\t\tast_log(LOG_WARNING, \"midget meta trunk packet received (%d of %d min)\\n\", packet_len,\n\t\t\t(int) (sizeof(*meta) + sizeof(*mth)));\n\t\treturn 1;\n\t}\n\tmth = (struct ast_iax2_meta_trunk_hdr *)(meta->data);\n\tts = ntohl(mth->ts);\n\tmetatype = meta->cmddata;\n\tpacket_len -= (sizeof(*meta) + sizeof(*mth));\n\tptr = mth->data;\n\ttpeer = find_tpeer(sin, sockfd);\n\tif (!tpeer) {\n\t\tast_log(LOG_WARNING, \"Unable to accept trunked packet from '%s:%d': No matching peer\\n\", \n\t\t\tast_inet_ntoa(sin->sin_addr), ntohs(sin->sin_port));\n\t\treturn 1;\n\t}\n\ttpeer->trunkact = ast_tvnow();\n\tif (!ts || ast_tvzero(tpeer->rxtrunktime))\n\t\ttpeer->rxtrunktime = tpeer->trunkact;\n\trxtrunktime = tpeer->rxtrunktime;\n\tast_mutex_unlock(&tpeer->lock);\n\twhile (packet_len >= sizeof(*mte)) {\n\t\t/* Process channels */\n\t\tunsigned short callno, trunked_ts, len;\n\n\t\tif (metatype == IAX_META_TRUNK_MINI) {\n\t\t\tmtm = (struct ast_iax2_meta_trunk_mini *) ptr;\n\t\t\tptr += sizeof(*mtm);\n\t\t\tpacket_len -= sizeof(*mtm);\n\t\t\tlen = ntohs(mtm->len);\n\t\t\tcallno = ntohs(mtm->mini.callno);\n\t\t\ttrunked_ts = ntohs(mtm->mini.ts);\n\t\t} else if (metatype == IAX_META_TRUNK_SUPERMINI) {\n\t\t\tmte = (struct ast_iax2_meta_trunk_entry *)ptr;\n\t\t\tptr += sizeof(*mte);\n\t\t\tpacket_len -= sizeof(*mte);\n\t\t\tlen = ntohs(mte->len);\n\t\t\tcallno = ntohs(mte->callno);\n\t\t\ttrunked_ts = 0;\n\t\t} else {\n\t\t\tast_log(LOG_WARNING, \"Unknown meta trunk cmd from '%s:%d': dropping\\n\", ast_inet_ntoa(sin->sin_addr), ntohs(sin->sin_port));\n\t\t\tbreak;\n\t\t}\n\t\t/* Stop if we don't have enough data */\n\t\tif (len > packet_len)\n\t\t\tbreak;\n\t\tfr->callno = find_callno_locked(callno & ~IAX_FLAG_FULL, 0, sin, NEW_PREVENT, sockfd);\n\t\tif (!fr->callno)\n\t\t\tcontinue;\n\n\t\t/* If it's a valid call, deliver the contents.  If not, we\n\t\t   drop it, since we don't have a scallno to use for an INVAL */\n\t\t/* Process as a mini frame */\n\t\tmemset(&f, 0, sizeof(f));\n\t\tf.frametype = AST_FRAME_VOICE;\n\t\tif (!iaxs[fr->callno]) {\n\t\t\t/* drop it */\n\t\t} else if (iaxs[fr->callno]->voiceformat == 0) {\n\t\t\tast_log(LOG_WARNING, \"Received trunked frame before first full voice frame\\n \");\n\t\t\tiax2_vnak(fr->callno);\n\t\t} else {\n\t\t\tf.subclass = iaxs[fr->callno]->voiceformat;\n\t\t\tf.datalen = len;\n\t\t\tif (f.datalen >= 0) {\n\t\t\t\tif (f.datalen)\n\t\t\t\t\tf.data = ptr;\n\t\t\t\telse\n\t\t\t\t\tf.data = NULL;\n\t\t\t\tif (trunked_ts)\n\t\t\t\t\tfr->ts = (iaxs[fr->callno]->last & 0xFFFF0000L) | (trunked_ts & 0xffff);\n\t\t\t\telse\n\t\t\t\t\tfr->ts = fix_peerts(&rxtrunktime, fr->callno, ts);\n\t\t\t\t/* Don't pass any packets until we're started */\n\t\t\t\tif (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)) {\n\t\t\t\t\tstruct iax_frame *duped_fr;\n\n\t\t\t\t\t/* Common things */\n\t\t\t\t\tf.src = \"IAX2\";\n\t\t\t\t\tf.mallocd = 0;\n\t\t\t\t\tf.offset = 0;\n\t\t\t\t\tif (f.datalen && (f.frametype == AST_FRAME_VOICE)) \n\t\t\t\t\t\tf.samples = ast_codec_get_samples(&f);\n\t\t\t\t\telse\n\t\t\t\t\t\tf.samples = 0;\n\t\t\t\t\tfr->outoforder = 0;\n\t\t\t\t\tiax_frame_wrap(fr, &f);\n\t\t\t\t\tduped_fr = iaxfrdup2(fr);\n\t\t\t\t\tif (duped_fr)\n\t\t\t\t\t\tschedule_delivery(duped_fr, 1, 1, &fr->ts);\n\t\t\t\t\tif (iaxs[fr->callno] && iaxs[fr->callno]->last < fr->ts)\n\t\t\t\t\t\tiaxs[fr->callno]->last = fr->ts;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tast_log(LOG_WARNING, \"Datalen < 0?\\n\");\n\t\t\t}\n\t\t}\n\t\tast_mutex_unlock(&iaxsl[fr->callno]);\n\t\tptr += len;\n\t\tpacket_len -= len;\n\t}\n\n\treturn 1;\n}",
        "func": "static int socket_process_meta(int packet_len, struct ast_iax2_meta_hdr *meta, struct sockaddr_in *sin, int sockfd,\n\tstruct iax_frame *fr)\n{\n\tunsigned char metatype;\n\tstruct ast_iax2_meta_trunk_mini *mtm;\n\tstruct ast_iax2_meta_trunk_hdr *mth;\n\tstruct ast_iax2_meta_trunk_entry *mte;\n\tstruct iax2_trunk_peer *tpeer;\n\tunsigned int ts;\n\tvoid *ptr;\n\tstruct timeval rxtrunktime;\n\tstruct ast_frame f = { 0, };\n\n\tif (packet_len < sizeof(*meta)) {\n\t\tast_log(LOG_WARNING, \"Rejecting packet from '%s.%d' that is flagged as a meta frame but is too short\\n\", \n\t\t\tast_inet_ntoa(sin->sin_addr), ntohs(sin->sin_port));\n\t\treturn 1;\n\t}\n\n\tif (meta->metacmd != IAX_META_TRUNK)\n\t\treturn 1;\n\n\tif (packet_len < (sizeof(*meta) + sizeof(*mth))) {\n\t\tast_log(LOG_WARNING, \"midget meta trunk packet received (%d of %d min)\\n\", packet_len,\n\t\t\t(int) (sizeof(*meta) + sizeof(*mth)));\n\t\treturn 1;\n\t}\n\tmth = (struct ast_iax2_meta_trunk_hdr *)(meta->data);\n\tts = ntohl(mth->ts);\n\tmetatype = meta->cmddata;\n\tpacket_len -= (sizeof(*meta) + sizeof(*mth));\n\tptr = mth->data;\n\ttpeer = find_tpeer(sin, sockfd);\n\tif (!tpeer) {\n\t\tast_log(LOG_WARNING, \"Unable to accept trunked packet from '%s:%d': No matching peer\\n\", \n\t\t\tast_inet_ntoa(sin->sin_addr), ntohs(sin->sin_port));\n\t\treturn 1;\n\t}\n\ttpeer->trunkact = ast_tvnow();\n\tif (!ts || ast_tvzero(tpeer->rxtrunktime))\n\t\ttpeer->rxtrunktime = tpeer->trunkact;\n\trxtrunktime = tpeer->rxtrunktime;\n\tast_mutex_unlock(&tpeer->lock);\n\twhile (packet_len >= sizeof(*mte)) {\n\t\t/* Process channels */\n\t\tunsigned short callno, trunked_ts, len;\n\n\t\tif (metatype == IAX_META_TRUNK_MINI) {\n\t\t\tmtm = (struct ast_iax2_meta_trunk_mini *) ptr;\n\t\t\tptr += sizeof(*mtm);\n\t\t\tpacket_len -= sizeof(*mtm);\n\t\t\tlen = ntohs(mtm->len);\n\t\t\tcallno = ntohs(mtm->mini.callno);\n\t\t\ttrunked_ts = ntohs(mtm->mini.ts);\n\t\t} else if (metatype == IAX_META_TRUNK_SUPERMINI) {\n\t\t\tmte = (struct ast_iax2_meta_trunk_entry *)ptr;\n\t\t\tptr += sizeof(*mte);\n\t\t\tpacket_len -= sizeof(*mte);\n\t\t\tlen = ntohs(mte->len);\n\t\t\tcallno = ntohs(mte->callno);\n\t\t\ttrunked_ts = 0;\n\t\t} else {\n\t\t\tast_log(LOG_WARNING, \"Unknown meta trunk cmd from '%s:%d': dropping\\n\", ast_inet_ntoa(sin->sin_addr), ntohs(sin->sin_port));\n\t\t\tbreak;\n\t\t}\n\t\t/* Stop if we don't have enough data */\n\t\tif (len > packet_len)\n\t\t\tbreak;\n\t\tfr->callno = find_callno_locked(callno & ~IAX_FLAG_FULL, 0, sin, NEW_PREVENT, sockfd, 0);\n\t\tif (!fr->callno)\n\t\t\tcontinue;\n\n\t\t/* If it's a valid call, deliver the contents.  If not, we\n\t\t   drop it, since we don't have a scallno to use for an INVAL */\n\t\t/* Process as a mini frame */\n\t\tmemset(&f, 0, sizeof(f));\n\t\tf.frametype = AST_FRAME_VOICE;\n\t\tif (!iaxs[fr->callno]) {\n\t\t\t/* drop it */\n\t\t} else if (iaxs[fr->callno]->voiceformat == 0) {\n\t\t\tast_log(LOG_WARNING, \"Received trunked frame before first full voice frame\\n \");\n\t\t\tiax2_vnak(fr->callno);\n\t\t} else {\n\t\t\tf.subclass = iaxs[fr->callno]->voiceformat;\n\t\t\tf.datalen = len;\n\t\t\tif (f.datalen >= 0) {\n\t\t\t\tif (f.datalen)\n\t\t\t\t\tf.data = ptr;\n\t\t\t\telse\n\t\t\t\t\tf.data = NULL;\n\t\t\t\tif (trunked_ts)\n\t\t\t\t\tfr->ts = (iaxs[fr->callno]->last & 0xFFFF0000L) | (trunked_ts & 0xffff);\n\t\t\t\telse\n\t\t\t\t\tfr->ts = fix_peerts(&rxtrunktime, fr->callno, ts);\n\t\t\t\t/* Don't pass any packets until we're started */\n\t\t\t\tif (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)) {\n\t\t\t\t\tstruct iax_frame *duped_fr;\n\n\t\t\t\t\t/* Common things */\n\t\t\t\t\tf.src = \"IAX2\";\n\t\t\t\t\tf.mallocd = 0;\n\t\t\t\t\tf.offset = 0;\n\t\t\t\t\tif (f.datalen && (f.frametype == AST_FRAME_VOICE)) \n\t\t\t\t\t\tf.samples = ast_codec_get_samples(&f);\n\t\t\t\t\telse\n\t\t\t\t\t\tf.samples = 0;\n\t\t\t\t\tfr->outoforder = 0;\n\t\t\t\t\tiax_frame_wrap(fr, &f);\n\t\t\t\t\tduped_fr = iaxfrdup2(fr);\n\t\t\t\t\tif (duped_fr)\n\t\t\t\t\t\tschedule_delivery(duped_fr, 1, 1, &fr->ts);\n\t\t\t\t\tif (iaxs[fr->callno] && iaxs[fr->callno]->last < fr->ts)\n\t\t\t\t\t\tiaxs[fr->callno]->last = fr->ts;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tast_log(LOG_WARNING, \"Datalen < 0?\\n\");\n\t\t\t}\n\t\t}\n\t\tast_mutex_unlock(&iaxsl[fr->callno]);\n\t\tptr += len;\n\t\tpacket_len -= len;\n\t}\n\n\treturn 1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -66,7 +66,7 @@\n \t\t/* Stop if we don't have enough data */\n \t\tif (len > packet_len)\n \t\t\tbreak;\n-\t\tfr->callno = find_callno_locked(callno & ~IAX_FLAG_FULL, 0, sin, NEW_PREVENT, sockfd);\n+\t\tfr->callno = find_callno_locked(callno & ~IAX_FLAG_FULL, 0, sin, NEW_PREVENT, sockfd, 0);\n \t\tif (!fr->callno)\n \t\t\tcontinue;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tfr->callno = find_callno_locked(callno & ~IAX_FLAG_FULL, 0, sin, NEW_PREVENT, sockfd);"
            ],
            "added_lines": [
                "\t\tfr->callno = find_callno_locked(callno & ~IAX_FLAG_FULL, 0, sin, NEW_PREVENT, sockfd, 0);"
            ]
        }
    },
    {
        "cve_id": "CVE-2008-1897",
        "func_name": "pruiz/asterisk/find_callno_locked",
        "description": "The IAX2 channel driver (chan_iax2) in Asterisk Open Source 1.0.x, 1.2.x before 1.2.28, and 1.4.x before 1.4.19.1; Business Edition A.x.x, B.x.x before B.2.5.2, and C.x.x before C.1.8.1; AsteriskNOW before 1.0.3; Appliance Developer Kit 0.x.x; and s800i before 1.1.0.3, when configured to allow unauthenticated calls, does not verify that an ACK response contains a call number matching the server's reply to a NEW message, which allows remote attackers to cause a denial of service (traffic amplification) via a spoofed ACK response that does not complete a 3-way handshake.  NOTE: this issue exists because of an incomplete fix for CVE-2008-1923.",
        "git_url": "https://github.com/pruiz/asterisk/commit/e0ef9bd22810c6969a7f222eec04798f19a7e2d6",
        "commit_title": "Merged revisions 114558 via svnmerge from ",
        "commit_text": "https://origsvn.digium.com/svn/asterisk/branches/1.4  ........ r114558 | russell | 2008-04-22 17:15:36 -0500 (Tue, 22 Apr 2008) | 5 lines  When we receive a full frame that is supposed to contain our call number, ensure that it has the correct one. (closes issue #10078) (AST-2008-006)  ........  ",
        "func_before": "static int find_callno_locked(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd) {\n\n\treturn __find_callno(callno, dcallno, sin, new, sockfd, 1);\n}",
        "func": "static int find_callno_locked(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int full_frame) {\n\n\treturn __find_callno(callno, dcallno, sin, new, sockfd, 1, full_frame);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,4 @@\n-static int find_callno_locked(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd) {\n+static int find_callno_locked(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int full_frame) {\n \n-\treturn __find_callno(callno, dcallno, sin, new, sockfd, 1);\n+\treturn __find_callno(callno, dcallno, sin, new, sockfd, 1, full_frame);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "static int find_callno_locked(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd) {",
                "\treturn __find_callno(callno, dcallno, sin, new, sockfd, 1);"
            ],
            "added_lines": [
                "static int find_callno_locked(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int full_frame) {",
                "\treturn __find_callno(callno, dcallno, sin, new, sockfd, 1, full_frame);"
            ]
        }
    },
    {
        "cve_id": "CVE-2008-1897",
        "func_name": "pruiz/asterisk/iax2_request",
        "description": "The IAX2 channel driver (chan_iax2) in Asterisk Open Source 1.0.x, 1.2.x before 1.2.28, and 1.4.x before 1.4.19.1; Business Edition A.x.x, B.x.x before B.2.5.2, and C.x.x before C.1.8.1; AsteriskNOW before 1.0.3; Appliance Developer Kit 0.x.x; and s800i before 1.1.0.3, when configured to allow unauthenticated calls, does not verify that an ACK response contains a call number matching the server's reply to a NEW message, which allows remote attackers to cause a denial of service (traffic amplification) via a spoofed ACK response that does not complete a 3-way handshake.  NOTE: this issue exists because of an incomplete fix for CVE-2008-1923.",
        "git_url": "https://github.com/pruiz/asterisk/commit/e0ef9bd22810c6969a7f222eec04798f19a7e2d6",
        "commit_title": "Merged revisions 114558 via svnmerge from ",
        "commit_text": "https://origsvn.digium.com/svn/asterisk/branches/1.4  ........ r114558 | russell | 2008-04-22 17:15:36 -0500 (Tue, 22 Apr 2008) | 5 lines  When we receive a full frame that is supposed to contain our call number, ensure that it has the correct one. (closes issue #10078) (AST-2008-006)  ........  ",
        "func_before": "static struct ast_channel *iax2_request(const char *type, int format, void *data, int *cause)\n{\n\tint callno;\n\tint res;\n\tint fmt, native;\n\tstruct sockaddr_in sin;\n\tstruct ast_channel *c;\n\tstruct parsed_dial_string pds;\n\tstruct create_addr_info cai;\n\tchar *tmpstr;\n\n\tmemset(&pds, 0, sizeof(pds));\n\ttmpstr = ast_strdupa(data);\n\tparse_dial_string(tmpstr, &pds);\n\n\tif (ast_strlen_zero(pds.peer)) {\n\t\tast_log(LOG_WARNING, \"No peer provided in the IAX2 dial string '%s'\\n\", (char *) data);\n\t\treturn NULL;\n\t}\n\t       \n\tmemset(&cai, 0, sizeof(cai));\n\tcai.capability = iax2_capability;\n\n\tast_copy_flags(&cai, &globalflags, IAX_NOTRANSFER | IAX_TRANSFERMEDIA | IAX_USEJITTERBUF | IAX_FORCEJITTERBUF);\n\t\n\t/* Populate our address from the given */\n\tif (create_addr(pds.peer, NULL, &sin, &cai)) {\n\t\t*cause = AST_CAUSE_UNREGISTERED;\n\t\treturn NULL;\n\t}\n\n\tif (pds.port)\n\t\tsin.sin_port = htons(atoi(pds.port));\n\n\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd);\n\tif (callno < 1) {\n\t\tast_log(LOG_WARNING, \"Unable to create call\\n\");\n\t\t*cause = AST_CAUSE_CONGESTION;\n\t\treturn NULL;\n\t}\n\n\t/* If this is a trunk, update it now */\n\tast_copy_flags(iaxs[callno], &cai, IAX_TRUNK | IAX_SENDANI | IAX_NOTRANSFER | IAX_TRANSFERMEDIA | IAX_USEJITTERBUF | IAX_FORCEJITTERBUF);\t\n\tif (ast_test_flag(&cai, IAX_TRUNK)) {\n\t\tint new_callno;\n\t\tif ((new_callno = make_trunk(callno, 1)) != -1)\n\t\t\tcallno = new_callno;\n\t}\n\tiaxs[callno]->maxtime = cai.maxtime;\n\tif (cai.found)\n\t\tast_string_field_set(iaxs[callno], host, pds.peer);\n\n\tc = ast_iax2_new(callno, AST_STATE_DOWN, cai.capability);\n\n\tast_mutex_unlock(&iaxsl[callno]);\n\n\tif (c) {\n\t\t/* Choose a format we can live with */\n\t\tif (c->nativeformats & format) \n\t\t\tc->nativeformats &= format;\n\t\telse {\n\t\t\tnative = c->nativeformats;\n\t\t\tfmt = format;\n\t\t\tres = ast_translator_best_choice(&fmt, &native);\n\t\t\tif (res < 0) {\n\t\t\t\tast_log(LOG_WARNING, \"Unable to create translator path for %s to %s on %s\\n\",\n\t\t\t\t\tast_getformatname(c->nativeformats), ast_getformatname(fmt), c->name);\n\t\t\t\tast_hangup(c);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tc->nativeformats = native;\n\t\t}\n\t\tc->readformat = ast_best_codec(c->nativeformats);\n\t\tc->writeformat = c->readformat;\n\t}\n\n\treturn c;\n}",
        "func": "static struct ast_channel *iax2_request(const char *type, int format, void *data, int *cause)\n{\n\tint callno;\n\tint res;\n\tint fmt, native;\n\tstruct sockaddr_in sin;\n\tstruct ast_channel *c;\n\tstruct parsed_dial_string pds;\n\tstruct create_addr_info cai;\n\tchar *tmpstr;\n\n\tmemset(&pds, 0, sizeof(pds));\n\ttmpstr = ast_strdupa(data);\n\tparse_dial_string(tmpstr, &pds);\n\n\tif (ast_strlen_zero(pds.peer)) {\n\t\tast_log(LOG_WARNING, \"No peer provided in the IAX2 dial string '%s'\\n\", (char *) data);\n\t\treturn NULL;\n\t}\n\t       \n\tmemset(&cai, 0, sizeof(cai));\n\tcai.capability = iax2_capability;\n\n\tast_copy_flags(&cai, &globalflags, IAX_NOTRANSFER | IAX_TRANSFERMEDIA | IAX_USEJITTERBUF | IAX_FORCEJITTERBUF);\n\t\n\t/* Populate our address from the given */\n\tif (create_addr(pds.peer, NULL, &sin, &cai)) {\n\t\t*cause = AST_CAUSE_UNREGISTERED;\n\t\treturn NULL;\n\t}\n\n\tif (pds.port)\n\t\tsin.sin_port = htons(atoi(pds.port));\n\n\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd, 0);\n\tif (callno < 1) {\n\t\tast_log(LOG_WARNING, \"Unable to create call\\n\");\n\t\t*cause = AST_CAUSE_CONGESTION;\n\t\treturn NULL;\n\t}\n\n\t/* If this is a trunk, update it now */\n\tast_copy_flags(iaxs[callno], &cai, IAX_TRUNK | IAX_SENDANI | IAX_NOTRANSFER | IAX_TRANSFERMEDIA | IAX_USEJITTERBUF | IAX_FORCEJITTERBUF);\t\n\tif (ast_test_flag(&cai, IAX_TRUNK)) {\n\t\tint new_callno;\n\t\tif ((new_callno = make_trunk(callno, 1)) != -1)\n\t\t\tcallno = new_callno;\n\t}\n\tiaxs[callno]->maxtime = cai.maxtime;\n\tif (cai.found)\n\t\tast_string_field_set(iaxs[callno], host, pds.peer);\n\n\tc = ast_iax2_new(callno, AST_STATE_DOWN, cai.capability);\n\n\tast_mutex_unlock(&iaxsl[callno]);\n\n\tif (c) {\n\t\t/* Choose a format we can live with */\n\t\tif (c->nativeformats & format) \n\t\t\tc->nativeformats &= format;\n\t\telse {\n\t\t\tnative = c->nativeformats;\n\t\t\tfmt = format;\n\t\t\tres = ast_translator_best_choice(&fmt, &native);\n\t\t\tif (res < 0) {\n\t\t\t\tast_log(LOG_WARNING, \"Unable to create translator path for %s to %s on %s\\n\",\n\t\t\t\t\tast_getformatname(c->nativeformats), ast_getformatname(fmt), c->name);\n\t\t\t\tast_hangup(c);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tc->nativeformats = native;\n\t\t}\n\t\tc->readformat = ast_best_codec(c->nativeformats);\n\t\tc->writeformat = c->readformat;\n\t}\n\n\treturn c;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -32,7 +32,7 @@\n \tif (pds.port)\n \t\tsin.sin_port = htons(atoi(pds.port));\n \n-\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd);\n+\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd, 0);\n \tif (callno < 1) {\n \t\tast_log(LOG_WARNING, \"Unable to create call\\n\");\n \t\t*cause = AST_CAUSE_CONGESTION;",
        "diff_line_info": {
            "deleted_lines": [
                "\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd);"
            ],
            "added_lines": [
                "\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd, 0);"
            ]
        }
    },
    {
        "cve_id": "CVE-2008-1897",
        "func_name": "pruiz/asterisk/__find_callno",
        "description": "The IAX2 channel driver (chan_iax2) in Asterisk Open Source 1.0.x, 1.2.x before 1.2.28, and 1.4.x before 1.4.19.1; Business Edition A.x.x, B.x.x before B.2.5.2, and C.x.x before C.1.8.1; AsteriskNOW before 1.0.3; Appliance Developer Kit 0.x.x; and s800i before 1.1.0.3, when configured to allow unauthenticated calls, does not verify that an ACK response contains a call number matching the server's reply to a NEW message, which allows remote attackers to cause a denial of service (traffic amplification) via a spoofed ACK response that does not complete a 3-way handshake.  NOTE: this issue exists because of an incomplete fix for CVE-2008-1923.",
        "git_url": "https://github.com/pruiz/asterisk/commit/e0ef9bd22810c6969a7f222eec04798f19a7e2d6",
        "commit_title": "Merged revisions 114558 via svnmerge from ",
        "commit_text": "https://origsvn.digium.com/svn/asterisk/branches/1.4  ........ r114558 | russell | 2008-04-22 17:15:36 -0500 (Tue, 22 Apr 2008) | 5 lines  When we receive a full frame that is supposed to contain our call number, ensure that it has the correct one. (closes issue #10078) (AST-2008-006)  ........  ",
        "func_before": "static int __find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int return_locked)\n{\n\tint res = 0;\n\tint x;\n\tstruct timeval now;\n\tchar host[80];\n\n\tif (new <= NEW_ALLOW) {\n\t\tfor (x=1;(res < 1) && (x<maxnontrunkcall);x++) {\n\t\t\tast_mutex_lock(&iaxsl[x]);\n\t\t\tif (iaxs[x]) {\n\t\t\t\t/* Look for an exact match */\n\t\t\t\tif (match(sin, callno, dcallno, iaxs[x])) {\n\t\t\t\t\tres = x;\n\t\t\t\t}\n\t\t\t}\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t}\n\t\tfor (x=TRUNK_CALL_START;(res < 1) && (x<maxtrunkcall);x++) {\n\t\t\tast_mutex_lock(&iaxsl[x]);\n\t\t\tif (iaxs[x]) {\n\t\t\t\t/* Look for an exact match */\n\t\t\t\tif (match(sin, callno, dcallno, iaxs[x])) {\n\t\t\t\t\tres = x;\n\t\t\t\t}\n\t\t\t}\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t}\n\t}\n\tif ((res < 1) && (new >= NEW_ALLOW)) {\n\t\t/* It may seem odd that we look through the peer list for a name for\n\t\t * this *incoming* call.  Well, it is weird.  However, users don't\n\t\t * have an IP address/port number that we can match against.  So,\n\t\t * this is just checking for a peer that has that IP/port and\n\t\t * assuming that we have a user of the same name.  This isn't always\n\t\t * correct, but it will be changed if needed after authentication. */\n\t\tif (!iax2_getpeername(*sin, host, sizeof(host)))\n\t\t\tsnprintf(host, sizeof(host), \"%s:%d\", ast_inet_ntoa(sin->sin_addr), ntohs(sin->sin_port));\n\t\tnow = ast_tvnow();\n\t\tfor (x=1;x<TRUNK_CALL_START;x++) {\n\t\t\t/* Find first unused call number that hasn't been used in a while */\n\t\t\tast_mutex_lock(&iaxsl[x]);\n\t\t\tif (!iaxs[x] && ((now.tv_sec - lastused[x].tv_sec) > MIN_REUSE_TIME)) break;\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t}\n\t\t/* We've still got lock held if we found a spot */\n\t\tif (x >= TRUNK_CALL_START) {\n\t\t\tast_log(LOG_WARNING, \"No more space\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tiaxs[x] = new_iax(sin, host);\n\t\tupdate_max_nontrunk();\n\t\tif (iaxs[x]) {\n\t\t\tif (iaxdebug)\n\t\t\t\tast_debug(1, \"Creating new call structure %d\\n\", x);\n\t\t\tiaxs[x]->sockfd = sockfd;\n\t\t\tiaxs[x]->addr.sin_port = sin->sin_port;\n\t\t\tiaxs[x]->addr.sin_family = sin->sin_family;\n\t\t\tiaxs[x]->addr.sin_addr.s_addr = sin->sin_addr.s_addr;\n\t\t\tiaxs[x]->peercallno = callno;\n\t\t\tiaxs[x]->callno = x;\n\t\t\tiaxs[x]->pingtime = DEFAULT_RETRY_TIME;\n\t\t\tiaxs[x]->expiry = min_reg_expire;\n\t\t\tiaxs[x]->pingid = iax2_sched_add(sched, ping_time * 1000, send_ping, (void *)(long)x);\n\t\t\tiaxs[x]->lagid = iax2_sched_add(sched, lagrq_time * 1000, send_lagrq, (void *)(long)x);\n\t\t\tiaxs[x]->amaflags = amaflags;\n\t\t\tast_copy_flags(iaxs[x], (&globalflags), IAX_NOTRANSFER | IAX_TRANSFERMEDIA | IAX_USEJITTERBUF | IAX_FORCEJITTERBUF);\n\t\t\t\n\t\t\tast_string_field_set(iaxs[x], accountcode, accountcode);\n\t\t\tast_string_field_set(iaxs[x], mohinterpret, mohinterpret);\n\t\t\tast_string_field_set(iaxs[x], mohsuggest, mohsuggest);\n\t\t\tast_string_field_set(iaxs[x], parkinglot, default_parkinglot);\n\t\t} else {\n\t\t\tast_log(LOG_WARNING, \"Out of resources\\n\");\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t\treturn 0;\n\t\t}\n\t\tif (!return_locked)\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\tres = x;\n\t}\n\treturn res;\n}",
        "func": "static int __find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int return_locked, int full_frame)\n{\n\tint res = 0;\n\tint x;\n\tstruct timeval now;\n\tchar host[80];\n\n\tif (new <= NEW_ALLOW) {\n\t\tfor (x=1;(res < 1) && (x<maxnontrunkcall);x++) {\n\t\t\tast_mutex_lock(&iaxsl[x]);\n\t\t\tif (iaxs[x]) {\n\t\t\t\t/* Look for an exact match */\n\t\t\t\tif (match(sin, callno, dcallno, iaxs[x], full_frame)) {\n\t\t\t\t\tres = x;\n\t\t\t\t}\n\t\t\t}\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t}\n\t\tfor (x=TRUNK_CALL_START;(res < 1) && (x<maxtrunkcall);x++) {\n\t\t\tast_mutex_lock(&iaxsl[x]);\n\t\t\tif (iaxs[x]) {\n\t\t\t\t/* Look for an exact match */\n\t\t\t\tif (match(sin, callno, dcallno, iaxs[x], full_frame)) {\n\t\t\t\t\tres = x;\n\t\t\t\t}\n\t\t\t}\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t}\n\t}\n\tif ((res < 1) && (new >= NEW_ALLOW)) {\n\t\tint start, found = 0;\n\n\t\t/* It may seem odd that we look through the peer list for a name for\n\t\t * this *incoming* call.  Well, it is weird.  However, users don't\n\t\t * have an IP address/port number that we can match against.  So,\n\t\t * this is just checking for a peer that has that IP/port and\n\t\t * assuming that we have a user of the same name.  This isn't always\n\t\t * correct, but it will be changed if needed after authentication. */\n\t\tif (!iax2_getpeername(*sin, host, sizeof(host)))\n\t\t\tsnprintf(host, sizeof(host), \"%s:%d\", ast_inet_ntoa(sin->sin_addr), ntohs(sin->sin_port));\n\n\t\tnow = ast_tvnow();\n\t\tstart = 1 + (ast_random() % (TRUNK_CALL_START - 1));\n\t\tfor (x = start; 1; x++) {\n\t\t\tif (x == TRUNK_CALL_START) {\n\t\t\t\tx = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* Find first unused call number that hasn't been used in a while */\n\t\t\tast_mutex_lock(&iaxsl[x]);\n\t\t\tif (!iaxs[x] && ((now.tv_sec - lastused[x].tv_sec) > MIN_REUSE_TIME)) {\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t\t\n\t\t\tif (x == start - 1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/* We've still got lock held if we found a spot */\n\t\tif (x == start - 1 && !found) {\n\t\t\tast_log(LOG_WARNING, \"No more space\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tiaxs[x] = new_iax(sin, host);\n\t\tupdate_max_nontrunk();\n\t\tif (iaxs[x]) {\n\t\t\tif (iaxdebug)\n\t\t\t\tast_debug(1, \"Creating new call structure %d\\n\", x);\n\t\t\tiaxs[x]->sockfd = sockfd;\n\t\t\tiaxs[x]->addr.sin_port = sin->sin_port;\n\t\t\tiaxs[x]->addr.sin_family = sin->sin_family;\n\t\t\tiaxs[x]->addr.sin_addr.s_addr = sin->sin_addr.s_addr;\n\t\t\tiaxs[x]->peercallno = callno;\n\t\t\tiaxs[x]->callno = x;\n\t\t\tiaxs[x]->pingtime = DEFAULT_RETRY_TIME;\n\t\t\tiaxs[x]->expiry = min_reg_expire;\n\t\t\tiaxs[x]->pingid = iax2_sched_add(sched, ping_time * 1000, send_ping, (void *)(long)x);\n\t\t\tiaxs[x]->lagid = iax2_sched_add(sched, lagrq_time * 1000, send_lagrq, (void *)(long)x);\n\t\t\tiaxs[x]->amaflags = amaflags;\n\t\t\tast_copy_flags(iaxs[x], (&globalflags), IAX_NOTRANSFER | IAX_TRANSFERMEDIA | IAX_USEJITTERBUF | IAX_FORCEJITTERBUF);\n\t\t\t\n\t\t\tast_string_field_set(iaxs[x], accountcode, accountcode);\n\t\t\tast_string_field_set(iaxs[x], mohinterpret, mohinterpret);\n\t\t\tast_string_field_set(iaxs[x], mohsuggest, mohsuggest);\n\t\t\tast_string_field_set(iaxs[x], parkinglot, default_parkinglot);\n\t\t} else {\n\t\t\tast_log(LOG_WARNING, \"Out of resources\\n\");\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t\treturn 0;\n\t\t}\n\t\tif (!return_locked)\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\tres = x;\n\t}\n\treturn res;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,4 @@\n-static int __find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int return_locked)\n+static int __find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int return_locked, int full_frame)\n {\n \tint res = 0;\n \tint x;\n@@ -10,7 +10,7 @@\n \t\t\tast_mutex_lock(&iaxsl[x]);\n \t\t\tif (iaxs[x]) {\n \t\t\t\t/* Look for an exact match */\n-\t\t\t\tif (match(sin, callno, dcallno, iaxs[x])) {\n+\t\t\t\tif (match(sin, callno, dcallno, iaxs[x], full_frame)) {\n \t\t\t\t\tres = x;\n \t\t\t\t}\n \t\t\t}\n@@ -20,7 +20,7 @@\n \t\t\tast_mutex_lock(&iaxsl[x]);\n \t\t\tif (iaxs[x]) {\n \t\t\t\t/* Look for an exact match */\n-\t\t\t\tif (match(sin, callno, dcallno, iaxs[x])) {\n+\t\t\t\tif (match(sin, callno, dcallno, iaxs[x], full_frame)) {\n \t\t\t\t\tres = x;\n \t\t\t\t}\n \t\t\t}\n@@ -28,6 +28,8 @@\n \t\t}\n \t}\n \tif ((res < 1) && (new >= NEW_ALLOW)) {\n+\t\tint start, found = 0;\n+\n \t\t/* It may seem odd that we look through the peer list for a name for\n \t\t * this *incoming* call.  Well, it is weird.  However, users don't\n \t\t * have an IP address/port number that we can match against.  So,\n@@ -36,15 +38,29 @@\n \t\t * correct, but it will be changed if needed after authentication. */\n \t\tif (!iax2_getpeername(*sin, host, sizeof(host)))\n \t\t\tsnprintf(host, sizeof(host), \"%s:%d\", ast_inet_ntoa(sin->sin_addr), ntohs(sin->sin_port));\n+\n \t\tnow = ast_tvnow();\n-\t\tfor (x=1;x<TRUNK_CALL_START;x++) {\n+\t\tstart = 1 + (ast_random() % (TRUNK_CALL_START - 1));\n+\t\tfor (x = start; 1; x++) {\n+\t\t\tif (x == TRUNK_CALL_START) {\n+\t\t\t\tx = 0;\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\n \t\t\t/* Find first unused call number that hasn't been used in a while */\n \t\t\tast_mutex_lock(&iaxsl[x]);\n-\t\t\tif (!iaxs[x] && ((now.tv_sec - lastused[x].tv_sec) > MIN_REUSE_TIME)) break;\n+\t\t\tif (!iaxs[x] && ((now.tv_sec - lastused[x].tv_sec) > MIN_REUSE_TIME)) {\n+\t\t\t\tfound = 1;\n+\t\t\t\tbreak;\n+\t\t\t}\n \t\t\tast_mutex_unlock(&iaxsl[x]);\n+\t\t\t\n+\t\t\tif (x == start - 1) {\n+\t\t\t\tbreak;\n+\t\t\t}\n \t\t}\n \t\t/* We've still got lock held if we found a spot */\n-\t\tif (x >= TRUNK_CALL_START) {\n+\t\tif (x == start - 1 && !found) {\n \t\t\tast_log(LOG_WARNING, \"No more space\\n\");\n \t\t\treturn 0;\n \t\t}",
        "diff_line_info": {
            "deleted_lines": [
                "static int __find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int return_locked)",
                "\t\t\t\tif (match(sin, callno, dcallno, iaxs[x])) {",
                "\t\t\t\tif (match(sin, callno, dcallno, iaxs[x])) {",
                "\t\tfor (x=1;x<TRUNK_CALL_START;x++) {",
                "\t\t\tif (!iaxs[x] && ((now.tv_sec - lastused[x].tv_sec) > MIN_REUSE_TIME)) break;",
                "\t\tif (x >= TRUNK_CALL_START) {"
            ],
            "added_lines": [
                "static int __find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int return_locked, int full_frame)",
                "\t\t\t\tif (match(sin, callno, dcallno, iaxs[x], full_frame)) {",
                "\t\t\t\tif (match(sin, callno, dcallno, iaxs[x], full_frame)) {",
                "\t\tint start, found = 0;",
                "",
                "",
                "\t\tstart = 1 + (ast_random() % (TRUNK_CALL_START - 1));",
                "\t\tfor (x = start; 1; x++) {",
                "\t\t\tif (x == TRUNK_CALL_START) {",
                "\t\t\t\tx = 0;",
                "\t\t\t\tcontinue;",
                "\t\t\t}",
                "",
                "\t\t\tif (!iaxs[x] && ((now.tv_sec - lastused[x].tv_sec) > MIN_REUSE_TIME)) {",
                "\t\t\t\tfound = 1;",
                "\t\t\t\tbreak;",
                "\t\t\t}",
                "\t\t\t",
                "\t\t\tif (x == start - 1) {",
                "\t\t\t\tbreak;",
                "\t\t\t}",
                "\t\tif (x == start - 1 && !found) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2008-1897",
        "func_name": "jcollie/asterisk/find_callno",
        "description": "The IAX2 channel driver (chan_iax2) in Asterisk Open Source 1.0.x, 1.2.x before 1.2.28, and 1.4.x before 1.4.19.1; Business Edition A.x.x, B.x.x before B.2.5.2, and C.x.x before C.1.8.1; AsteriskNOW before 1.0.3; Appliance Developer Kit 0.x.x; and s800i before 1.1.0.3, when configured to allow unauthenticated calls, does not verify that an ACK response contains a call number matching the server's reply to a NEW message, which allows remote attackers to cause a denial of service (traffic amplification) via a spoofed ACK response that does not complete a 3-way handshake.  NOTE: this issue exists because of an incomplete fix for CVE-2008-1923.",
        "git_url": "https://github.com/jcollie/asterisk/commit/a8b180875b037b8da26f6a3bcc8e5e98b8c904d2",
        "commit_title": "Merged revisions 114558 via svnmerge from ",
        "commit_text": "https://origsvn.digium.com/svn/asterisk/branches/1.4  ........ r114558 | russell | 2008-04-22 17:15:36 -0500 (Tue, 22 Apr 2008) | 5 lines  When we receive a full frame that is supposed to contain our call number, ensure that it has the correct one. (closes issue #10078) (AST-2008-006)  ........  ",
        "func_before": "static int find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd) {\n\n\treturn __find_callno(callno, dcallno, sin, new, sockfd, 0);\n}",
        "func": "static int find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int full_frame) {\n\n\treturn __find_callno(callno, dcallno, sin, new, sockfd, 0, full_frame);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,4 @@\n-static int find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd) {\n+static int find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int full_frame) {\n \n-\treturn __find_callno(callno, dcallno, sin, new, sockfd, 0);\n+\treturn __find_callno(callno, dcallno, sin, new, sockfd, 0, full_frame);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "static int find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd) {",
                "\treturn __find_callno(callno, dcallno, sin, new, sockfd, 0);"
            ],
            "added_lines": [
                "static int find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int full_frame) {",
                "\treturn __find_callno(callno, dcallno, sin, new, sockfd, 0, full_frame);"
            ]
        }
    },
    {
        "cve_id": "CVE-2008-1897",
        "func_name": "jcollie/asterisk/iax2_do_register",
        "description": "The IAX2 channel driver (chan_iax2) in Asterisk Open Source 1.0.x, 1.2.x before 1.2.28, and 1.4.x before 1.4.19.1; Business Edition A.x.x, B.x.x before B.2.5.2, and C.x.x before C.1.8.1; AsteriskNOW before 1.0.3; Appliance Developer Kit 0.x.x; and s800i before 1.1.0.3, when configured to allow unauthenticated calls, does not verify that an ACK response contains a call number matching the server's reply to a NEW message, which allows remote attackers to cause a denial of service (traffic amplification) via a spoofed ACK response that does not complete a 3-way handshake.  NOTE: this issue exists because of an incomplete fix for CVE-2008-1923.",
        "git_url": "https://github.com/jcollie/asterisk/commit/a8b180875b037b8da26f6a3bcc8e5e98b8c904d2",
        "commit_title": "Merged revisions 114558 via svnmerge from ",
        "commit_text": "https://origsvn.digium.com/svn/asterisk/branches/1.4  ........ r114558 | russell | 2008-04-22 17:15:36 -0500 (Tue, 22 Apr 2008) | 5 lines  When we receive a full frame that is supposed to contain our call number, ensure that it has the correct one. (closes issue #10078) (AST-2008-006)  ........  ",
        "func_before": "static int iax2_do_register(struct iax2_registry *reg)\n{\n\tstruct iax_ie_data ied;\n\tif (iaxdebug)\n\t\tast_debug(1, \"Sending registration request for '%s'\\n\", reg->username);\n\n\tif (reg->dnsmgr && \n\t    ((reg->regstate == REG_STATE_TIMEOUT) || !reg->addr.sin_addr.s_addr)) {\n\t\t/* Maybe the IP has changed, force DNS refresh */\n\t\tast_dnsmgr_refresh(reg->dnsmgr);\n\t}\n\t\n\t/*\n\t * if IP has Changed, free allocated call to create a new one with new IP\n\t * call has the pointer to IP and must be updated to the new one\n\t */\n\tif (reg->dnsmgr && ast_dnsmgr_changed(reg->dnsmgr) && (reg->callno > 0)) {\n\t\tast_mutex_lock(&iaxsl[reg->callno]);\n\t\tiax2_destroy(reg->callno);\n\t\tast_mutex_unlock(&iaxsl[reg->callno]);\n\t\treg->callno = 0;\n\t}\n\tif (!reg->addr.sin_addr.s_addr) {\n\t\tif (iaxdebug)\n\t\t\tast_debug(1, \"Unable to send registration request for '%s' without IP address\\n\", reg->username);\n\t\t/* Setup the next registration attempt */\n\t\treg->expire = iax2_sched_replace(reg->expire, sched, \n\t\t\t(5 * reg->refresh / 6) * 1000, iax2_do_register_s, reg);\n\t\treturn -1;\n\t}\n\n\tif (!reg->callno) {\n\t\tast_debug(1, \"Allocate call number\\n\");\n\t\treg->callno = find_callno_locked(0, 0, &reg->addr, NEW_FORCE, defaultsockfd);\n\t\tif (reg->callno < 1) {\n\t\t\tast_log(LOG_WARNING, \"Unable to create call for registration\\n\");\n\t\t\treturn -1;\n\t\t} else\n\t\t\tast_debug(1, \"Registration created on call %d\\n\", reg->callno);\n\t\tiaxs[reg->callno]->reg = reg;\n\t\tast_mutex_unlock(&iaxsl[reg->callno]);\n\t}\n\t/* Setup the next registration a little early */\n\treg->expire = iax2_sched_replace(reg->expire, sched, \n\t\t(5 * reg->refresh / 6) * 1000, iax2_do_register_s, reg);\n\t/* Send the request */\n\tmemset(&ied, 0, sizeof(ied));\n\tiax_ie_append_str(&ied, IAX_IE_USERNAME, reg->username);\n\tiax_ie_append_short(&ied, IAX_IE_REFRESH, reg->refresh);\n\tsend_command(iaxs[reg->callno],AST_FRAME_IAX, IAX_COMMAND_REGREQ, 0, ied.buf, ied.pos, -1);\n\treg->regstate = REG_STATE_REGSENT;\n\treturn 0;\n}",
        "func": "static int iax2_do_register(struct iax2_registry *reg)\n{\n\tstruct iax_ie_data ied;\n\tif (iaxdebug)\n\t\tast_debug(1, \"Sending registration request for '%s'\\n\", reg->username);\n\n\tif (reg->dnsmgr && \n\t    ((reg->regstate == REG_STATE_TIMEOUT) || !reg->addr.sin_addr.s_addr)) {\n\t\t/* Maybe the IP has changed, force DNS refresh */\n\t\tast_dnsmgr_refresh(reg->dnsmgr);\n\t}\n\t\n\t/*\n\t * if IP has Changed, free allocated call to create a new one with new IP\n\t * call has the pointer to IP and must be updated to the new one\n\t */\n\tif (reg->dnsmgr && ast_dnsmgr_changed(reg->dnsmgr) && (reg->callno > 0)) {\n\t\tast_mutex_lock(&iaxsl[reg->callno]);\n\t\tiax2_destroy(reg->callno);\n\t\tast_mutex_unlock(&iaxsl[reg->callno]);\n\t\treg->callno = 0;\n\t}\n\tif (!reg->addr.sin_addr.s_addr) {\n\t\tif (iaxdebug)\n\t\t\tast_debug(1, \"Unable to send registration request for '%s' without IP address\\n\", reg->username);\n\t\t/* Setup the next registration attempt */\n\t\treg->expire = iax2_sched_replace(reg->expire, sched, \n\t\t\t(5 * reg->refresh / 6) * 1000, iax2_do_register_s, reg);\n\t\treturn -1;\n\t}\n\n\tif (!reg->callno) {\n\t\tast_debug(1, \"Allocate call number\\n\");\n\t\treg->callno = find_callno_locked(0, 0, &reg->addr, NEW_FORCE, defaultsockfd, 0);\n\t\tif (reg->callno < 1) {\n\t\t\tast_log(LOG_WARNING, \"Unable to create call for registration\\n\");\n\t\t\treturn -1;\n\t\t} else\n\t\t\tast_debug(1, \"Registration created on call %d\\n\", reg->callno);\n\t\tiaxs[reg->callno]->reg = reg;\n\t\tast_mutex_unlock(&iaxsl[reg->callno]);\n\t}\n\t/* Setup the next registration a little early */\n\treg->expire = iax2_sched_replace(reg->expire, sched, \n\t\t(5 * reg->refresh / 6) * 1000, iax2_do_register_s, reg);\n\t/* Send the request */\n\tmemset(&ied, 0, sizeof(ied));\n\tiax_ie_append_str(&ied, IAX_IE_USERNAME, reg->username);\n\tiax_ie_append_short(&ied, IAX_IE_REFRESH, reg->refresh);\n\tsend_command(iaxs[reg->callno],AST_FRAME_IAX, IAX_COMMAND_REGREQ, 0, ied.buf, ied.pos, -1);\n\treg->regstate = REG_STATE_REGSENT;\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -31,7 +31,7 @@\n \n \tif (!reg->callno) {\n \t\tast_debug(1, \"Allocate call number\\n\");\n-\t\treg->callno = find_callno_locked(0, 0, &reg->addr, NEW_FORCE, defaultsockfd);\n+\t\treg->callno = find_callno_locked(0, 0, &reg->addr, NEW_FORCE, defaultsockfd, 0);\n \t\tif (reg->callno < 1) {\n \t\t\tast_log(LOG_WARNING, \"Unable to create call for registration\\n\");\n \t\t\treturn -1;",
        "diff_line_info": {
            "deleted_lines": [
                "\t\treg->callno = find_callno_locked(0, 0, &reg->addr, NEW_FORCE, defaultsockfd);"
            ],
            "added_lines": [
                "\t\treg->callno = find_callno_locked(0, 0, &reg->addr, NEW_FORCE, defaultsockfd, 0);"
            ]
        }
    },
    {
        "cve_id": "CVE-2008-1897",
        "func_name": "jcollie/asterisk/iax2_poke_peer",
        "description": "The IAX2 channel driver (chan_iax2) in Asterisk Open Source 1.0.x, 1.2.x before 1.2.28, and 1.4.x before 1.4.19.1; Business Edition A.x.x, B.x.x before B.2.5.2, and C.x.x before C.1.8.1; AsteriskNOW before 1.0.3; Appliance Developer Kit 0.x.x; and s800i before 1.1.0.3, when configured to allow unauthenticated calls, does not verify that an ACK response contains a call number matching the server's reply to a NEW message, which allows remote attackers to cause a denial of service (traffic amplification) via a spoofed ACK response that does not complete a 3-way handshake.  NOTE: this issue exists because of an incomplete fix for CVE-2008-1923.",
        "git_url": "https://github.com/jcollie/asterisk/commit/a8b180875b037b8da26f6a3bcc8e5e98b8c904d2",
        "commit_title": "Merged revisions 114558 via svnmerge from ",
        "commit_text": "https://origsvn.digium.com/svn/asterisk/branches/1.4  ........ r114558 | russell | 2008-04-22 17:15:36 -0500 (Tue, 22 Apr 2008) | 5 lines  When we receive a full frame that is supposed to contain our call number, ensure that it has the correct one. (closes issue #10078) (AST-2008-006)  ........  ",
        "func_before": "static int iax2_poke_peer(struct iax2_peer *peer, int heldcall)\n{\n\tif (!peer->maxms || (!peer->addr.sin_addr.s_addr && !peer->dnsmgr)) {\n\t\t/* IF we have no IP without dnsmgr, or this isn't to be monitored, return\n\t\t  immediately after clearing things out */\n\t\tpeer->lastms = 0;\n\t\tpeer->historicms = 0;\n\t\tpeer->pokeexpire = -1;\n\t\tpeer->callno = 0;\n\t\treturn 0;\n\t}\n\tif (peer->callno > 0) {\n\t\tast_log(LOG_NOTICE, \"Still have a callno...\\n\");\n\t\tast_mutex_lock(&iaxsl[peer->callno]);\n\t\tiax2_destroy(peer->callno);\n\t\tast_mutex_unlock(&iaxsl[peer->callno]);\n\t}\n\tif (heldcall)\n\t\tast_mutex_unlock(&iaxsl[heldcall]);\n\tpeer->callno = find_callno(0, 0, &peer->addr, NEW_FORCE, peer->sockfd);\n\tif (heldcall)\n\t\tast_mutex_lock(&iaxsl[heldcall]);\n\tif (peer->callno < 1) {\n\t\tast_log(LOG_WARNING, \"Unable to allocate call for poking peer '%s'\\n\", peer->name);\n\t\treturn -1;\n\t}\n\n\t/* Speed up retransmission times for this qualify call */\n\tiaxs[peer->callno]->pingtime = peer->maxms / 4 + 1;\n\tiaxs[peer->callno]->peerpoke = peer;\n\n \tif (peer->pokeexpire > -1) {\n \t\tif (!ast_sched_del(sched, peer->pokeexpire)) {\n \t\t\tpeer->pokeexpire = -1;\n \t\t\tpeer_unref(peer);\n \t\t}\n \t}\n \n\t/* Queue up a new task to handle no reply */\n\t/* If the host is already unreachable then use the unreachable interval instead */\n\tif (peer->lastms < 0)\n \t\tpeer->pokeexpire = iax2_sched_add(sched, peer->pokefreqnotok, iax2_poke_noanswer, peer_ref(peer));\n\telse\n \t\tpeer->pokeexpire = iax2_sched_add(sched, DEFAULT_MAXMS * 2, iax2_poke_noanswer, peer_ref(peer));\n\n \tif (peer->pokeexpire == -1)\n \t\tpeer_unref(peer);\n\n\t/* And send the poke */\n\tsend_command(iaxs[peer->callno], AST_FRAME_IAX, IAX_COMMAND_POKE, 0, NULL, 0, -1);\n\n\treturn 0;\n}",
        "func": "static int iax2_poke_peer(struct iax2_peer *peer, int heldcall)\n{\n\tif (!peer->maxms || (!peer->addr.sin_addr.s_addr && !peer->dnsmgr)) {\n\t\t/* IF we have no IP without dnsmgr, or this isn't to be monitored, return\n\t\t  immediately after clearing things out */\n\t\tpeer->lastms = 0;\n\t\tpeer->historicms = 0;\n\t\tpeer->pokeexpire = -1;\n\t\tpeer->callno = 0;\n\t\treturn 0;\n\t}\n\tif (peer->callno > 0) {\n\t\tast_log(LOG_NOTICE, \"Still have a callno...\\n\");\n\t\tast_mutex_lock(&iaxsl[peer->callno]);\n\t\tiax2_destroy(peer->callno);\n\t\tast_mutex_unlock(&iaxsl[peer->callno]);\n\t}\n\tif (heldcall)\n\t\tast_mutex_unlock(&iaxsl[heldcall]);\n\tpeer->callno = find_callno(0, 0, &peer->addr, NEW_FORCE, peer->sockfd, 0);\n\tif (heldcall)\n\t\tast_mutex_lock(&iaxsl[heldcall]);\n\tif (peer->callno < 1) {\n\t\tast_log(LOG_WARNING, \"Unable to allocate call for poking peer '%s'\\n\", peer->name);\n\t\treturn -1;\n\t}\n\n\t/* Speed up retransmission times for this qualify call */\n\tiaxs[peer->callno]->pingtime = peer->maxms / 4 + 1;\n\tiaxs[peer->callno]->peerpoke = peer;\n\n \tif (peer->pokeexpire > -1) {\n \t\tif (!ast_sched_del(sched, peer->pokeexpire)) {\n \t\t\tpeer->pokeexpire = -1;\n \t\t\tpeer_unref(peer);\n \t\t}\n \t}\n \n\t/* Queue up a new task to handle no reply */\n\t/* If the host is already unreachable then use the unreachable interval instead */\n\tif (peer->lastms < 0)\n \t\tpeer->pokeexpire = iax2_sched_add(sched, peer->pokefreqnotok, iax2_poke_noanswer, peer_ref(peer));\n\telse\n \t\tpeer->pokeexpire = iax2_sched_add(sched, DEFAULT_MAXMS * 2, iax2_poke_noanswer, peer_ref(peer));\n\n \tif (peer->pokeexpire == -1)\n \t\tpeer_unref(peer);\n\n\t/* And send the poke */\n\tsend_command(iaxs[peer->callno], AST_FRAME_IAX, IAX_COMMAND_POKE, 0, NULL, 0, -1);\n\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -17,7 +17,7 @@\n \t}\n \tif (heldcall)\n \t\tast_mutex_unlock(&iaxsl[heldcall]);\n-\tpeer->callno = find_callno(0, 0, &peer->addr, NEW_FORCE, peer->sockfd);\n+\tpeer->callno = find_callno(0, 0, &peer->addr, NEW_FORCE, peer->sockfd, 0);\n \tif (heldcall)\n \t\tast_mutex_lock(&iaxsl[heldcall]);\n \tif (peer->callno < 1) {",
        "diff_line_info": {
            "deleted_lines": [
                "\tpeer->callno = find_callno(0, 0, &peer->addr, NEW_FORCE, peer->sockfd);"
            ],
            "added_lines": [
                "\tpeer->callno = find_callno(0, 0, &peer->addr, NEW_FORCE, peer->sockfd, 0);"
            ]
        }
    },
    {
        "cve_id": "CVE-2008-1897",
        "func_name": "jcollie/asterisk/cache_get_callno_locked",
        "description": "The IAX2 channel driver (chan_iax2) in Asterisk Open Source 1.0.x, 1.2.x before 1.2.28, and 1.4.x before 1.4.19.1; Business Edition A.x.x, B.x.x before B.2.5.2, and C.x.x before C.1.8.1; AsteriskNOW before 1.0.3; Appliance Developer Kit 0.x.x; and s800i before 1.1.0.3, when configured to allow unauthenticated calls, does not verify that an ACK response contains a call number matching the server's reply to a NEW message, which allows remote attackers to cause a denial of service (traffic amplification) via a spoofed ACK response that does not complete a 3-way handshake.  NOTE: this issue exists because of an incomplete fix for CVE-2008-1923.",
        "git_url": "https://github.com/jcollie/asterisk/commit/a8b180875b037b8da26f6a3bcc8e5e98b8c904d2",
        "commit_title": "Merged revisions 114558 via svnmerge from ",
        "commit_text": "https://origsvn.digium.com/svn/asterisk/branches/1.4  ........ r114558 | russell | 2008-04-22 17:15:36 -0500 (Tue, 22 Apr 2008) | 5 lines  When we receive a full frame that is supposed to contain our call number, ensure that it has the correct one. (closes issue #10078) (AST-2008-006)  ........  ",
        "func_before": "static int cache_get_callno_locked(const char *data)\n{\n\tstruct sockaddr_in sin;\n\tint x;\n\tint callno;\n\tstruct iax_ie_data ied;\n\tstruct create_addr_info cai;\n\tstruct parsed_dial_string pds;\n\tchar *tmpstr;\n\n\tfor (x=0; x<IAX_MAX_CALLS; x++) {\n\t\t/* Look for an *exact match* call.  Once a call is negotiated, it can only\n\t\t   look up entries for a single context */\n\t\tif (!ast_mutex_trylock(&iaxsl[x])) {\n\t\t\tif (iaxs[x] && !strcasecmp(data, iaxs[x]->dproot))\n\t\t\t\treturn x;\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t}\n\t}\n\n\t/* No match found, we need to create a new one */\n\n\tmemset(&cai, 0, sizeof(cai));\n\tmemset(&ied, 0, sizeof(ied));\n\tmemset(&pds, 0, sizeof(pds));\n\n\ttmpstr = ast_strdupa(data);\n\tparse_dial_string(tmpstr, &pds);\n\n\tif (ast_strlen_zero(pds.peer)) {\n\t\tast_log(LOG_WARNING, \"No peer provided in the IAX2 dial string '%s'\\n\", data);\n\t\treturn -1;\n\t}\n\n\t/* Populate our address from the given */\n\tif (create_addr(pds.peer, NULL, &sin, &cai))\n\t\treturn -1;\n\n\tast_debug(1, \"peer: %s, username: %s, password: %s, context: %s\\n\",\n\t\tpds.peer, pds.username, pds.password, pds.context);\n\n\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd);\n\tif (callno < 1) {\n\t\tast_log(LOG_WARNING, \"Unable to create call\\n\");\n\t\treturn -1;\n\t}\n\n\tast_string_field_set(iaxs[callno], dproot, data);\n\tiaxs[callno]->capability = IAX_CAPABILITY_FULLBANDWIDTH;\n\n\tiax_ie_append_short(&ied, IAX_IE_VERSION, IAX_PROTO_VERSION);\n\tiax_ie_append_str(&ied, IAX_IE_CALLED_NUMBER, \"TBD\");\n\t/* the string format is slightly different from a standard dial string,\n\t   because the context appears in the 'exten' position\n\t*/\n\tif (pds.exten)\n\t\tiax_ie_append_str(&ied, IAX_IE_CALLED_CONTEXT, pds.exten);\n\tif (pds.username)\n\t\tiax_ie_append_str(&ied, IAX_IE_USERNAME, pds.username);\n\tiax_ie_append_int(&ied, IAX_IE_FORMAT, IAX_CAPABILITY_FULLBANDWIDTH);\n\tiax_ie_append_int(&ied, IAX_IE_CAPABILITY, IAX_CAPABILITY_FULLBANDWIDTH);\n\t/* Keep password handy */\n\tif (pds.password)\n\t\tast_string_field_set(iaxs[callno], secret, pds.password);\n\tif (pds.key)\n\t\tast_string_field_set(iaxs[callno], outkey, pds.key);\n\t/* Start the call going */\n\tsend_command(iaxs[callno], AST_FRAME_IAX, IAX_COMMAND_NEW, 0, ied.buf, ied.pos, -1);\n\n\treturn callno;\n}",
        "func": "static int cache_get_callno_locked(const char *data)\n{\n\tstruct sockaddr_in sin;\n\tint x;\n\tint callno;\n\tstruct iax_ie_data ied;\n\tstruct create_addr_info cai;\n\tstruct parsed_dial_string pds;\n\tchar *tmpstr;\n\n\tfor (x=0; x<IAX_MAX_CALLS; x++) {\n\t\t/* Look for an *exact match* call.  Once a call is negotiated, it can only\n\t\t   look up entries for a single context */\n\t\tif (!ast_mutex_trylock(&iaxsl[x])) {\n\t\t\tif (iaxs[x] && !strcasecmp(data, iaxs[x]->dproot))\n\t\t\t\treturn x;\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t}\n\t}\n\n\t/* No match found, we need to create a new one */\n\n\tmemset(&cai, 0, sizeof(cai));\n\tmemset(&ied, 0, sizeof(ied));\n\tmemset(&pds, 0, sizeof(pds));\n\n\ttmpstr = ast_strdupa(data);\n\tparse_dial_string(tmpstr, &pds);\n\n\tif (ast_strlen_zero(pds.peer)) {\n\t\tast_log(LOG_WARNING, \"No peer provided in the IAX2 dial string '%s'\\n\", data);\n\t\treturn -1;\n\t}\n\n\t/* Populate our address from the given */\n\tif (create_addr(pds.peer, NULL, &sin, &cai))\n\t\treturn -1;\n\n\tast_debug(1, \"peer: %s, username: %s, password: %s, context: %s\\n\",\n\t\tpds.peer, pds.username, pds.password, pds.context);\n\n\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd, 0);\n\tif (callno < 1) {\n\t\tast_log(LOG_WARNING, \"Unable to create call\\n\");\n\t\treturn -1;\n\t}\n\n\tast_string_field_set(iaxs[callno], dproot, data);\n\tiaxs[callno]->capability = IAX_CAPABILITY_FULLBANDWIDTH;\n\n\tiax_ie_append_short(&ied, IAX_IE_VERSION, IAX_PROTO_VERSION);\n\tiax_ie_append_str(&ied, IAX_IE_CALLED_NUMBER, \"TBD\");\n\t/* the string format is slightly different from a standard dial string,\n\t   because the context appears in the 'exten' position\n\t*/\n\tif (pds.exten)\n\t\tiax_ie_append_str(&ied, IAX_IE_CALLED_CONTEXT, pds.exten);\n\tif (pds.username)\n\t\tiax_ie_append_str(&ied, IAX_IE_USERNAME, pds.username);\n\tiax_ie_append_int(&ied, IAX_IE_FORMAT, IAX_CAPABILITY_FULLBANDWIDTH);\n\tiax_ie_append_int(&ied, IAX_IE_CAPABILITY, IAX_CAPABILITY_FULLBANDWIDTH);\n\t/* Keep password handy */\n\tif (pds.password)\n\t\tast_string_field_set(iaxs[callno], secret, pds.password);\n\tif (pds.key)\n\t\tast_string_field_set(iaxs[callno], outkey, pds.key);\n\t/* Start the call going */\n\tsend_command(iaxs[callno], AST_FRAME_IAX, IAX_COMMAND_NEW, 0, ied.buf, ied.pos, -1);\n\n\treturn callno;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -39,7 +39,7 @@\n \tast_debug(1, \"peer: %s, username: %s, password: %s, context: %s\\n\",\n \t\tpds.peer, pds.username, pds.password, pds.context);\n \n-\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd);\n+\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd, 0);\n \tif (callno < 1) {\n \t\tast_log(LOG_WARNING, \"Unable to create call\\n\");\n \t\treturn -1;",
        "diff_line_info": {
            "deleted_lines": [
                "\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd);"
            ],
            "added_lines": [
                "\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd, 0);"
            ]
        }
    },
    {
        "cve_id": "CVE-2008-1897",
        "func_name": "jcollie/asterisk/iax2_provision",
        "description": "The IAX2 channel driver (chan_iax2) in Asterisk Open Source 1.0.x, 1.2.x before 1.2.28, and 1.4.x before 1.4.19.1; Business Edition A.x.x, B.x.x before B.2.5.2, and C.x.x before C.1.8.1; AsteriskNOW before 1.0.3; Appliance Developer Kit 0.x.x; and s800i before 1.1.0.3, when configured to allow unauthenticated calls, does not verify that an ACK response contains a call number matching the server's reply to a NEW message, which allows remote attackers to cause a denial of service (traffic amplification) via a spoofed ACK response that does not complete a 3-way handshake.  NOTE: this issue exists because of an incomplete fix for CVE-2008-1923.",
        "git_url": "https://github.com/jcollie/asterisk/commit/a8b180875b037b8da26f6a3bcc8e5e98b8c904d2",
        "commit_title": "Merged revisions 114558 via svnmerge from ",
        "commit_text": "https://origsvn.digium.com/svn/asterisk/branches/1.4  ........ r114558 | russell | 2008-04-22 17:15:36 -0500 (Tue, 22 Apr 2008) | 5 lines  When we receive a full frame that is supposed to contain our call number, ensure that it has the correct one. (closes issue #10078) (AST-2008-006)  ........  ",
        "func_before": "static int iax2_provision(struct sockaddr_in *end, int sockfd, char *dest, const char *template, int force)\n{\n\t/* Returns 1 if provisioned, -1 if not able to find destination, or 0 if no provisioning\n\t   is found for template */\n\tstruct iax_ie_data provdata;\n\tstruct iax_ie_data ied;\n\tunsigned int sig;\n\tstruct sockaddr_in sin;\n\tint callno;\n\tstruct create_addr_info cai;\n\n\tmemset(&cai, 0, sizeof(cai));\n\n\tast_debug(1, \"Provisioning '%s' from template '%s'\\n\", dest, template);\n\n\tif (iax_provision_build(&provdata, &sig, template, force)) {\n\t\tast_debug(1, \"No provisioning found for template '%s'\\n\", template);\n\t\treturn 0;\n\t}\n\n\tif (end) {\n\t\tmemcpy(&sin, end, sizeof(sin));\n\t\tcai.sockfd = sockfd;\n\t} else if (create_addr(dest, NULL, &sin, &cai))\n\t\treturn -1;\n\n\t/* Build the rest of the message */\n\tmemset(&ied, 0, sizeof(ied));\n\tiax_ie_append_raw(&ied, IAX_IE_PROVISIONING, provdata.buf, provdata.pos);\n\n\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd);\n\tif (!callno)\n\t\treturn -1;\n\n\tif (iaxs[callno]) {\n\t\t/* Schedule autodestruct in case they don't ever give us anything back */\n\t\tiaxs[callno]->autoid = iax2_sched_replace(iaxs[callno]->autoid, \n\t\t\tsched, 15000, auto_hangup, (void *)(long)callno);\n\t\tast_set_flag(iaxs[callno], IAX_PROVISION);\n\t\t/* Got a call number now, so go ahead and send the provisioning information */\n\t\tsend_command(iaxs[callno], AST_FRAME_IAX, IAX_COMMAND_PROVISION, 0, ied.buf, ied.pos, -1);\n\t}\n\tast_mutex_unlock(&iaxsl[callno]);\n\n\treturn 1;\n}",
        "func": "static int iax2_provision(struct sockaddr_in *end, int sockfd, char *dest, const char *template, int force)\n{\n\t/* Returns 1 if provisioned, -1 if not able to find destination, or 0 if no provisioning\n\t   is found for template */\n\tstruct iax_ie_data provdata;\n\tstruct iax_ie_data ied;\n\tunsigned int sig;\n\tstruct sockaddr_in sin;\n\tint callno;\n\tstruct create_addr_info cai;\n\n\tmemset(&cai, 0, sizeof(cai));\n\n\tast_debug(1, \"Provisioning '%s' from template '%s'\\n\", dest, template);\n\n\tif (iax_provision_build(&provdata, &sig, template, force)) {\n\t\tast_debug(1, \"No provisioning found for template '%s'\\n\", template);\n\t\treturn 0;\n\t}\n\n\tif (end) {\n\t\tmemcpy(&sin, end, sizeof(sin));\n\t\tcai.sockfd = sockfd;\n\t} else if (create_addr(dest, NULL, &sin, &cai))\n\t\treturn -1;\n\n\t/* Build the rest of the message */\n\tmemset(&ied, 0, sizeof(ied));\n\tiax_ie_append_raw(&ied, IAX_IE_PROVISIONING, provdata.buf, provdata.pos);\n\n\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd, 0);\n\tif (!callno)\n\t\treturn -1;\n\n\tif (iaxs[callno]) {\n\t\t/* Schedule autodestruct in case they don't ever give us anything back */\n\t\tiaxs[callno]->autoid = iax2_sched_replace(iaxs[callno]->autoid, \n\t\t\tsched, 15000, auto_hangup, (void *)(long)callno);\n\t\tast_set_flag(iaxs[callno], IAX_PROVISION);\n\t\t/* Got a call number now, so go ahead and send the provisioning information */\n\t\tsend_command(iaxs[callno], AST_FRAME_IAX, IAX_COMMAND_PROVISION, 0, ied.buf, ied.pos, -1);\n\t}\n\tast_mutex_unlock(&iaxsl[callno]);\n\n\treturn 1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -28,7 +28,7 @@\n \tmemset(&ied, 0, sizeof(ied));\n \tiax_ie_append_raw(&ied, IAX_IE_PROVISIONING, provdata.buf, provdata.pos);\n \n-\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd);\n+\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd, 0);\n \tif (!callno)\n \t\treturn -1;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd);"
            ],
            "added_lines": [
                "\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd, 0);"
            ]
        }
    },
    {
        "cve_id": "CVE-2008-1897",
        "func_name": "jcollie/asterisk/match",
        "description": "The IAX2 channel driver (chan_iax2) in Asterisk Open Source 1.0.x, 1.2.x before 1.2.28, and 1.4.x before 1.4.19.1; Business Edition A.x.x, B.x.x before B.2.5.2, and C.x.x before C.1.8.1; AsteriskNOW before 1.0.3; Appliance Developer Kit 0.x.x; and s800i before 1.1.0.3, when configured to allow unauthenticated calls, does not verify that an ACK response contains a call number matching the server's reply to a NEW message, which allows remote attackers to cause a denial of service (traffic amplification) via a spoofed ACK response that does not complete a 3-way handshake.  NOTE: this issue exists because of an incomplete fix for CVE-2008-1923.",
        "git_url": "https://github.com/jcollie/asterisk/commit/a8b180875b037b8da26f6a3bcc8e5e98b8c904d2",
        "commit_title": "Merged revisions 114558 via svnmerge from ",
        "commit_text": "https://origsvn.digium.com/svn/asterisk/branches/1.4  ........ r114558 | russell | 2008-04-22 17:15:36 -0500 (Tue, 22 Apr 2008) | 5 lines  When we receive a full frame that is supposed to contain our call number, ensure that it has the correct one. (closes issue #10078) (AST-2008-006)  ........  ",
        "func_before": "static int match(struct sockaddr_in *sin, unsigned short callno, unsigned short dcallno, const struct chan_iax2_pvt *cur)\n{\n\tif ((cur->addr.sin_addr.s_addr == sin->sin_addr.s_addr) &&\n\t\t(cur->addr.sin_port == sin->sin_port)) {\n\t\t/* This is the main host */\n\t\tif ((cur->peercallno == callno) ||\n\t\t\t((dcallno == cur->callno) && !cur->peercallno)) {\n\t\t\t/* That's us.  Be sure we keep track of the peer call number */\n\t\t\treturn 1;\n\t\t}\n\t}\n\tif ((cur->transfer.sin_addr.s_addr == sin->sin_addr.s_addr) &&\n\t    (cur->transfer.sin_port == sin->sin_port) && (cur->transferring)) {\n\t\t/* We're transferring */\n\t\tif ((dcallno == cur->callno) || (cur->transferring == TRANSFER_MEDIAPASS && cur->transfercallno == callno))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
        "func": "static int match(struct sockaddr_in *sin, unsigned short callno, unsigned short dcallno, const struct chan_iax2_pvt *cur, int full_frame)\n{\n\tif ((cur->addr.sin_addr.s_addr == sin->sin_addr.s_addr) &&\n\t\t(cur->addr.sin_port == sin->sin_port)) {\n\t\t/* This is the main host */\n\t\tif ( (cur->peercallno == 0 || cur->peercallno == callno) &&\n\t\t\t (full_frame ? dcallno == cur->callno : 1) ) {\n\t\t\t/* That's us.  Be sure we keep track of the peer call number */\n\t\t\treturn 1;\n\t\t}\n\t}\n\tif ((cur->transfer.sin_addr.s_addr == sin->sin_addr.s_addr) &&\n\t    (cur->transfer.sin_port == sin->sin_port) && (cur->transferring)) {\n\t\t/* We're transferring */\n\t\tif ((dcallno == cur->callno) || (cur->transferring == TRANSFER_MEDIAPASS && cur->transfercallno == callno))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,10 +1,10 @@\n-static int match(struct sockaddr_in *sin, unsigned short callno, unsigned short dcallno, const struct chan_iax2_pvt *cur)\n+static int match(struct sockaddr_in *sin, unsigned short callno, unsigned short dcallno, const struct chan_iax2_pvt *cur, int full_frame)\n {\n \tif ((cur->addr.sin_addr.s_addr == sin->sin_addr.s_addr) &&\n \t\t(cur->addr.sin_port == sin->sin_port)) {\n \t\t/* This is the main host */\n-\t\tif ((cur->peercallno == callno) ||\n-\t\t\t((dcallno == cur->callno) && !cur->peercallno)) {\n+\t\tif ( (cur->peercallno == 0 || cur->peercallno == callno) &&\n+\t\t\t (full_frame ? dcallno == cur->callno : 1) ) {\n \t\t\t/* That's us.  Be sure we keep track of the peer call number */\n \t\t\treturn 1;\n \t\t}",
        "diff_line_info": {
            "deleted_lines": [
                "static int match(struct sockaddr_in *sin, unsigned short callno, unsigned short dcallno, const struct chan_iax2_pvt *cur)",
                "\t\tif ((cur->peercallno == callno) ||",
                "\t\t\t((dcallno == cur->callno) && !cur->peercallno)) {"
            ],
            "added_lines": [
                "static int match(struct sockaddr_in *sin, unsigned short callno, unsigned short dcallno, const struct chan_iax2_pvt *cur, int full_frame)",
                "\t\tif ( (cur->peercallno == 0 || cur->peercallno == callno) &&",
                "\t\t\t (full_frame ? dcallno == cur->callno : 1) ) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2008-1897",
        "func_name": "jcollie/asterisk/socket_process_meta",
        "description": "The IAX2 channel driver (chan_iax2) in Asterisk Open Source 1.0.x, 1.2.x before 1.2.28, and 1.4.x before 1.4.19.1; Business Edition A.x.x, B.x.x before B.2.5.2, and C.x.x before C.1.8.1; AsteriskNOW before 1.0.3; Appliance Developer Kit 0.x.x; and s800i before 1.1.0.3, when configured to allow unauthenticated calls, does not verify that an ACK response contains a call number matching the server's reply to a NEW message, which allows remote attackers to cause a denial of service (traffic amplification) via a spoofed ACK response that does not complete a 3-way handshake.  NOTE: this issue exists because of an incomplete fix for CVE-2008-1923.",
        "git_url": "https://github.com/jcollie/asterisk/commit/a8b180875b037b8da26f6a3bcc8e5e98b8c904d2",
        "commit_title": "Merged revisions 114558 via svnmerge from ",
        "commit_text": "https://origsvn.digium.com/svn/asterisk/branches/1.4  ........ r114558 | russell | 2008-04-22 17:15:36 -0500 (Tue, 22 Apr 2008) | 5 lines  When we receive a full frame that is supposed to contain our call number, ensure that it has the correct one. (closes issue #10078) (AST-2008-006)  ........  ",
        "func_before": "static int socket_process_meta(int packet_len, struct ast_iax2_meta_hdr *meta, struct sockaddr_in *sin, int sockfd,\n\tstruct iax_frame *fr)\n{\n\tunsigned char metatype;\n\tstruct ast_iax2_meta_trunk_mini *mtm;\n\tstruct ast_iax2_meta_trunk_hdr *mth;\n\tstruct ast_iax2_meta_trunk_entry *mte;\n\tstruct iax2_trunk_peer *tpeer;\n\tunsigned int ts;\n\tvoid *ptr;\n\tstruct timeval rxtrunktime;\n\tstruct ast_frame f = { 0, };\n\n\tif (packet_len < sizeof(*meta)) {\n\t\tast_log(LOG_WARNING, \"Rejecting packet from '%s.%d' that is flagged as a meta frame but is too short\\n\", \n\t\t\tast_inet_ntoa(sin->sin_addr), ntohs(sin->sin_port));\n\t\treturn 1;\n\t}\n\n\tif (meta->metacmd != IAX_META_TRUNK)\n\t\treturn 1;\n\n\tif (packet_len < (sizeof(*meta) + sizeof(*mth))) {\n\t\tast_log(LOG_WARNING, \"midget meta trunk packet received (%d of %d min)\\n\", packet_len,\n\t\t\t(int) (sizeof(*meta) + sizeof(*mth)));\n\t\treturn 1;\n\t}\n\tmth = (struct ast_iax2_meta_trunk_hdr *)(meta->data);\n\tts = ntohl(mth->ts);\n\tmetatype = meta->cmddata;\n\tpacket_len -= (sizeof(*meta) + sizeof(*mth));\n\tptr = mth->data;\n\ttpeer = find_tpeer(sin, sockfd);\n\tif (!tpeer) {\n\t\tast_log(LOG_WARNING, \"Unable to accept trunked packet from '%s:%d': No matching peer\\n\", \n\t\t\tast_inet_ntoa(sin->sin_addr), ntohs(sin->sin_port));\n\t\treturn 1;\n\t}\n\ttpeer->trunkact = ast_tvnow();\n\tif (!ts || ast_tvzero(tpeer->rxtrunktime))\n\t\ttpeer->rxtrunktime = tpeer->trunkact;\n\trxtrunktime = tpeer->rxtrunktime;\n\tast_mutex_unlock(&tpeer->lock);\n\twhile (packet_len >= sizeof(*mte)) {\n\t\t/* Process channels */\n\t\tunsigned short callno, trunked_ts, len;\n\n\t\tif (metatype == IAX_META_TRUNK_MINI) {\n\t\t\tmtm = (struct ast_iax2_meta_trunk_mini *) ptr;\n\t\t\tptr += sizeof(*mtm);\n\t\t\tpacket_len -= sizeof(*mtm);\n\t\t\tlen = ntohs(mtm->len);\n\t\t\tcallno = ntohs(mtm->mini.callno);\n\t\t\ttrunked_ts = ntohs(mtm->mini.ts);\n\t\t} else if (metatype == IAX_META_TRUNK_SUPERMINI) {\n\t\t\tmte = (struct ast_iax2_meta_trunk_entry *)ptr;\n\t\t\tptr += sizeof(*mte);\n\t\t\tpacket_len -= sizeof(*mte);\n\t\t\tlen = ntohs(mte->len);\n\t\t\tcallno = ntohs(mte->callno);\n\t\t\ttrunked_ts = 0;\n\t\t} else {\n\t\t\tast_log(LOG_WARNING, \"Unknown meta trunk cmd from '%s:%d': dropping\\n\", ast_inet_ntoa(sin->sin_addr), ntohs(sin->sin_port));\n\t\t\tbreak;\n\t\t}\n\t\t/* Stop if we don't have enough data */\n\t\tif (len > packet_len)\n\t\t\tbreak;\n\t\tfr->callno = find_callno_locked(callno & ~IAX_FLAG_FULL, 0, sin, NEW_PREVENT, sockfd);\n\t\tif (!fr->callno)\n\t\t\tcontinue;\n\n\t\t/* If it's a valid call, deliver the contents.  If not, we\n\t\t   drop it, since we don't have a scallno to use for an INVAL */\n\t\t/* Process as a mini frame */\n\t\tmemset(&f, 0, sizeof(f));\n\t\tf.frametype = AST_FRAME_VOICE;\n\t\tif (!iaxs[fr->callno]) {\n\t\t\t/* drop it */\n\t\t} else if (iaxs[fr->callno]->voiceformat == 0) {\n\t\t\tast_log(LOG_WARNING, \"Received trunked frame before first full voice frame\\n \");\n\t\t\tiax2_vnak(fr->callno);\n\t\t} else {\n\t\t\tf.subclass = iaxs[fr->callno]->voiceformat;\n\t\t\tf.datalen = len;\n\t\t\tif (f.datalen >= 0) {\n\t\t\t\tif (f.datalen)\n\t\t\t\t\tf.data = ptr;\n\t\t\t\telse\n\t\t\t\t\tf.data = NULL;\n\t\t\t\tif (trunked_ts)\n\t\t\t\t\tfr->ts = (iaxs[fr->callno]->last & 0xFFFF0000L) | (trunked_ts & 0xffff);\n\t\t\t\telse\n\t\t\t\t\tfr->ts = fix_peerts(&rxtrunktime, fr->callno, ts);\n\t\t\t\t/* Don't pass any packets until we're started */\n\t\t\t\tif (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)) {\n\t\t\t\t\tstruct iax_frame *duped_fr;\n\n\t\t\t\t\t/* Common things */\n\t\t\t\t\tf.src = \"IAX2\";\n\t\t\t\t\tf.mallocd = 0;\n\t\t\t\t\tf.offset = 0;\n\t\t\t\t\tif (f.datalen && (f.frametype == AST_FRAME_VOICE)) \n\t\t\t\t\t\tf.samples = ast_codec_get_samples(&f);\n\t\t\t\t\telse\n\t\t\t\t\t\tf.samples = 0;\n\t\t\t\t\tfr->outoforder = 0;\n\t\t\t\t\tiax_frame_wrap(fr, &f);\n\t\t\t\t\tduped_fr = iaxfrdup2(fr);\n\t\t\t\t\tif (duped_fr)\n\t\t\t\t\t\tschedule_delivery(duped_fr, 1, 1, &fr->ts);\n\t\t\t\t\tif (iaxs[fr->callno] && iaxs[fr->callno]->last < fr->ts)\n\t\t\t\t\t\tiaxs[fr->callno]->last = fr->ts;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tast_log(LOG_WARNING, \"Datalen < 0?\\n\");\n\t\t\t}\n\t\t}\n\t\tast_mutex_unlock(&iaxsl[fr->callno]);\n\t\tptr += len;\n\t\tpacket_len -= len;\n\t}\n\n\treturn 1;\n}",
        "func": "static int socket_process_meta(int packet_len, struct ast_iax2_meta_hdr *meta, struct sockaddr_in *sin, int sockfd,\n\tstruct iax_frame *fr)\n{\n\tunsigned char metatype;\n\tstruct ast_iax2_meta_trunk_mini *mtm;\n\tstruct ast_iax2_meta_trunk_hdr *mth;\n\tstruct ast_iax2_meta_trunk_entry *mte;\n\tstruct iax2_trunk_peer *tpeer;\n\tunsigned int ts;\n\tvoid *ptr;\n\tstruct timeval rxtrunktime;\n\tstruct ast_frame f = { 0, };\n\n\tif (packet_len < sizeof(*meta)) {\n\t\tast_log(LOG_WARNING, \"Rejecting packet from '%s.%d' that is flagged as a meta frame but is too short\\n\", \n\t\t\tast_inet_ntoa(sin->sin_addr), ntohs(sin->sin_port));\n\t\treturn 1;\n\t}\n\n\tif (meta->metacmd != IAX_META_TRUNK)\n\t\treturn 1;\n\n\tif (packet_len < (sizeof(*meta) + sizeof(*mth))) {\n\t\tast_log(LOG_WARNING, \"midget meta trunk packet received (%d of %d min)\\n\", packet_len,\n\t\t\t(int) (sizeof(*meta) + sizeof(*mth)));\n\t\treturn 1;\n\t}\n\tmth = (struct ast_iax2_meta_trunk_hdr *)(meta->data);\n\tts = ntohl(mth->ts);\n\tmetatype = meta->cmddata;\n\tpacket_len -= (sizeof(*meta) + sizeof(*mth));\n\tptr = mth->data;\n\ttpeer = find_tpeer(sin, sockfd);\n\tif (!tpeer) {\n\t\tast_log(LOG_WARNING, \"Unable to accept trunked packet from '%s:%d': No matching peer\\n\", \n\t\t\tast_inet_ntoa(sin->sin_addr), ntohs(sin->sin_port));\n\t\treturn 1;\n\t}\n\ttpeer->trunkact = ast_tvnow();\n\tif (!ts || ast_tvzero(tpeer->rxtrunktime))\n\t\ttpeer->rxtrunktime = tpeer->trunkact;\n\trxtrunktime = tpeer->rxtrunktime;\n\tast_mutex_unlock(&tpeer->lock);\n\twhile (packet_len >= sizeof(*mte)) {\n\t\t/* Process channels */\n\t\tunsigned short callno, trunked_ts, len;\n\n\t\tif (metatype == IAX_META_TRUNK_MINI) {\n\t\t\tmtm = (struct ast_iax2_meta_trunk_mini *) ptr;\n\t\t\tptr += sizeof(*mtm);\n\t\t\tpacket_len -= sizeof(*mtm);\n\t\t\tlen = ntohs(mtm->len);\n\t\t\tcallno = ntohs(mtm->mini.callno);\n\t\t\ttrunked_ts = ntohs(mtm->mini.ts);\n\t\t} else if (metatype == IAX_META_TRUNK_SUPERMINI) {\n\t\t\tmte = (struct ast_iax2_meta_trunk_entry *)ptr;\n\t\t\tptr += sizeof(*mte);\n\t\t\tpacket_len -= sizeof(*mte);\n\t\t\tlen = ntohs(mte->len);\n\t\t\tcallno = ntohs(mte->callno);\n\t\t\ttrunked_ts = 0;\n\t\t} else {\n\t\t\tast_log(LOG_WARNING, \"Unknown meta trunk cmd from '%s:%d': dropping\\n\", ast_inet_ntoa(sin->sin_addr), ntohs(sin->sin_port));\n\t\t\tbreak;\n\t\t}\n\t\t/* Stop if we don't have enough data */\n\t\tif (len > packet_len)\n\t\t\tbreak;\n\t\tfr->callno = find_callno_locked(callno & ~IAX_FLAG_FULL, 0, sin, NEW_PREVENT, sockfd, 0);\n\t\tif (!fr->callno)\n\t\t\tcontinue;\n\n\t\t/* If it's a valid call, deliver the contents.  If not, we\n\t\t   drop it, since we don't have a scallno to use for an INVAL */\n\t\t/* Process as a mini frame */\n\t\tmemset(&f, 0, sizeof(f));\n\t\tf.frametype = AST_FRAME_VOICE;\n\t\tif (!iaxs[fr->callno]) {\n\t\t\t/* drop it */\n\t\t} else if (iaxs[fr->callno]->voiceformat == 0) {\n\t\t\tast_log(LOG_WARNING, \"Received trunked frame before first full voice frame\\n \");\n\t\t\tiax2_vnak(fr->callno);\n\t\t} else {\n\t\t\tf.subclass = iaxs[fr->callno]->voiceformat;\n\t\t\tf.datalen = len;\n\t\t\tif (f.datalen >= 0) {\n\t\t\t\tif (f.datalen)\n\t\t\t\t\tf.data = ptr;\n\t\t\t\telse\n\t\t\t\t\tf.data = NULL;\n\t\t\t\tif (trunked_ts)\n\t\t\t\t\tfr->ts = (iaxs[fr->callno]->last & 0xFFFF0000L) | (trunked_ts & 0xffff);\n\t\t\t\telse\n\t\t\t\t\tfr->ts = fix_peerts(&rxtrunktime, fr->callno, ts);\n\t\t\t\t/* Don't pass any packets until we're started */\n\t\t\t\tif (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)) {\n\t\t\t\t\tstruct iax_frame *duped_fr;\n\n\t\t\t\t\t/* Common things */\n\t\t\t\t\tf.src = \"IAX2\";\n\t\t\t\t\tf.mallocd = 0;\n\t\t\t\t\tf.offset = 0;\n\t\t\t\t\tif (f.datalen && (f.frametype == AST_FRAME_VOICE)) \n\t\t\t\t\t\tf.samples = ast_codec_get_samples(&f);\n\t\t\t\t\telse\n\t\t\t\t\t\tf.samples = 0;\n\t\t\t\t\tfr->outoforder = 0;\n\t\t\t\t\tiax_frame_wrap(fr, &f);\n\t\t\t\t\tduped_fr = iaxfrdup2(fr);\n\t\t\t\t\tif (duped_fr)\n\t\t\t\t\t\tschedule_delivery(duped_fr, 1, 1, &fr->ts);\n\t\t\t\t\tif (iaxs[fr->callno] && iaxs[fr->callno]->last < fr->ts)\n\t\t\t\t\t\tiaxs[fr->callno]->last = fr->ts;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tast_log(LOG_WARNING, \"Datalen < 0?\\n\");\n\t\t\t}\n\t\t}\n\t\tast_mutex_unlock(&iaxsl[fr->callno]);\n\t\tptr += len;\n\t\tpacket_len -= len;\n\t}\n\n\treturn 1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -66,7 +66,7 @@\n \t\t/* Stop if we don't have enough data */\n \t\tif (len > packet_len)\n \t\t\tbreak;\n-\t\tfr->callno = find_callno_locked(callno & ~IAX_FLAG_FULL, 0, sin, NEW_PREVENT, sockfd);\n+\t\tfr->callno = find_callno_locked(callno & ~IAX_FLAG_FULL, 0, sin, NEW_PREVENT, sockfd, 0);\n \t\tif (!fr->callno)\n \t\t\tcontinue;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tfr->callno = find_callno_locked(callno & ~IAX_FLAG_FULL, 0, sin, NEW_PREVENT, sockfd);"
            ],
            "added_lines": [
                "\t\tfr->callno = find_callno_locked(callno & ~IAX_FLAG_FULL, 0, sin, NEW_PREVENT, sockfd, 0);"
            ]
        }
    },
    {
        "cve_id": "CVE-2008-1897",
        "func_name": "jcollie/asterisk/find_callno_locked",
        "description": "The IAX2 channel driver (chan_iax2) in Asterisk Open Source 1.0.x, 1.2.x before 1.2.28, and 1.4.x before 1.4.19.1; Business Edition A.x.x, B.x.x before B.2.5.2, and C.x.x before C.1.8.1; AsteriskNOW before 1.0.3; Appliance Developer Kit 0.x.x; and s800i before 1.1.0.3, when configured to allow unauthenticated calls, does not verify that an ACK response contains a call number matching the server's reply to a NEW message, which allows remote attackers to cause a denial of service (traffic amplification) via a spoofed ACK response that does not complete a 3-way handshake.  NOTE: this issue exists because of an incomplete fix for CVE-2008-1923.",
        "git_url": "https://github.com/jcollie/asterisk/commit/a8b180875b037b8da26f6a3bcc8e5e98b8c904d2",
        "commit_title": "Merged revisions 114558 via svnmerge from ",
        "commit_text": "https://origsvn.digium.com/svn/asterisk/branches/1.4  ........ r114558 | russell | 2008-04-22 17:15:36 -0500 (Tue, 22 Apr 2008) | 5 lines  When we receive a full frame that is supposed to contain our call number, ensure that it has the correct one. (closes issue #10078) (AST-2008-006)  ........  ",
        "func_before": "static int find_callno_locked(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd) {\n\n\treturn __find_callno(callno, dcallno, sin, new, sockfd, 1);\n}",
        "func": "static int find_callno_locked(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int full_frame) {\n\n\treturn __find_callno(callno, dcallno, sin, new, sockfd, 1, full_frame);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,4 @@\n-static int find_callno_locked(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd) {\n+static int find_callno_locked(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int full_frame) {\n \n-\treturn __find_callno(callno, dcallno, sin, new, sockfd, 1);\n+\treturn __find_callno(callno, dcallno, sin, new, sockfd, 1, full_frame);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "static int find_callno_locked(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd) {",
                "\treturn __find_callno(callno, dcallno, sin, new, sockfd, 1);"
            ],
            "added_lines": [
                "static int find_callno_locked(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int full_frame) {",
                "\treturn __find_callno(callno, dcallno, sin, new, sockfd, 1, full_frame);"
            ]
        }
    },
    {
        "cve_id": "CVE-2008-1897",
        "func_name": "jcollie/asterisk/iax2_request",
        "description": "The IAX2 channel driver (chan_iax2) in Asterisk Open Source 1.0.x, 1.2.x before 1.2.28, and 1.4.x before 1.4.19.1; Business Edition A.x.x, B.x.x before B.2.5.2, and C.x.x before C.1.8.1; AsteriskNOW before 1.0.3; Appliance Developer Kit 0.x.x; and s800i before 1.1.0.3, when configured to allow unauthenticated calls, does not verify that an ACK response contains a call number matching the server's reply to a NEW message, which allows remote attackers to cause a denial of service (traffic amplification) via a spoofed ACK response that does not complete a 3-way handshake.  NOTE: this issue exists because of an incomplete fix for CVE-2008-1923.",
        "git_url": "https://github.com/jcollie/asterisk/commit/a8b180875b037b8da26f6a3bcc8e5e98b8c904d2",
        "commit_title": "Merged revisions 114558 via svnmerge from ",
        "commit_text": "https://origsvn.digium.com/svn/asterisk/branches/1.4  ........ r114558 | russell | 2008-04-22 17:15:36 -0500 (Tue, 22 Apr 2008) | 5 lines  When we receive a full frame that is supposed to contain our call number, ensure that it has the correct one. (closes issue #10078) (AST-2008-006)  ........  ",
        "func_before": "static struct ast_channel *iax2_request(const char *type, int format, void *data, int *cause)\n{\n\tint callno;\n\tint res;\n\tint fmt, native;\n\tstruct sockaddr_in sin;\n\tstruct ast_channel *c;\n\tstruct parsed_dial_string pds;\n\tstruct create_addr_info cai;\n\tchar *tmpstr;\n\n\tmemset(&pds, 0, sizeof(pds));\n\ttmpstr = ast_strdupa(data);\n\tparse_dial_string(tmpstr, &pds);\n\n\tif (ast_strlen_zero(pds.peer)) {\n\t\tast_log(LOG_WARNING, \"No peer provided in the IAX2 dial string '%s'\\n\", (char *) data);\n\t\treturn NULL;\n\t}\n\t       \n\tmemset(&cai, 0, sizeof(cai));\n\tcai.capability = iax2_capability;\n\n\tast_copy_flags(&cai, &globalflags, IAX_NOTRANSFER | IAX_TRANSFERMEDIA | IAX_USEJITTERBUF | IAX_FORCEJITTERBUF);\n\t\n\t/* Populate our address from the given */\n\tif (create_addr(pds.peer, NULL, &sin, &cai)) {\n\t\t*cause = AST_CAUSE_UNREGISTERED;\n\t\treturn NULL;\n\t}\n\n\tif (pds.port)\n\t\tsin.sin_port = htons(atoi(pds.port));\n\n\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd);\n\tif (callno < 1) {\n\t\tast_log(LOG_WARNING, \"Unable to create call\\n\");\n\t\t*cause = AST_CAUSE_CONGESTION;\n\t\treturn NULL;\n\t}\n\n\t/* If this is a trunk, update it now */\n\tast_copy_flags(iaxs[callno], &cai, IAX_TRUNK | IAX_SENDANI | IAX_NOTRANSFER | IAX_TRANSFERMEDIA | IAX_USEJITTERBUF | IAX_FORCEJITTERBUF);\t\n\tif (ast_test_flag(&cai, IAX_TRUNK)) {\n\t\tint new_callno;\n\t\tif ((new_callno = make_trunk(callno, 1)) != -1)\n\t\t\tcallno = new_callno;\n\t}\n\tiaxs[callno]->maxtime = cai.maxtime;\n\tif (cai.found)\n\t\tast_string_field_set(iaxs[callno], host, pds.peer);\n\n\tc = ast_iax2_new(callno, AST_STATE_DOWN, cai.capability);\n\n\tast_mutex_unlock(&iaxsl[callno]);\n\n\tif (c) {\n\t\t/* Choose a format we can live with */\n\t\tif (c->nativeformats & format) \n\t\t\tc->nativeformats &= format;\n\t\telse {\n\t\t\tnative = c->nativeformats;\n\t\t\tfmt = format;\n\t\t\tres = ast_translator_best_choice(&fmt, &native);\n\t\t\tif (res < 0) {\n\t\t\t\tast_log(LOG_WARNING, \"Unable to create translator path for %s to %s on %s\\n\",\n\t\t\t\t\tast_getformatname(c->nativeformats), ast_getformatname(fmt), c->name);\n\t\t\t\tast_hangup(c);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tc->nativeformats = native;\n\t\t}\n\t\tc->readformat = ast_best_codec(c->nativeformats);\n\t\tc->writeformat = c->readformat;\n\t}\n\n\treturn c;\n}",
        "func": "static struct ast_channel *iax2_request(const char *type, int format, void *data, int *cause)\n{\n\tint callno;\n\tint res;\n\tint fmt, native;\n\tstruct sockaddr_in sin;\n\tstruct ast_channel *c;\n\tstruct parsed_dial_string pds;\n\tstruct create_addr_info cai;\n\tchar *tmpstr;\n\n\tmemset(&pds, 0, sizeof(pds));\n\ttmpstr = ast_strdupa(data);\n\tparse_dial_string(tmpstr, &pds);\n\n\tif (ast_strlen_zero(pds.peer)) {\n\t\tast_log(LOG_WARNING, \"No peer provided in the IAX2 dial string '%s'\\n\", (char *) data);\n\t\treturn NULL;\n\t}\n\t       \n\tmemset(&cai, 0, sizeof(cai));\n\tcai.capability = iax2_capability;\n\n\tast_copy_flags(&cai, &globalflags, IAX_NOTRANSFER | IAX_TRANSFERMEDIA | IAX_USEJITTERBUF | IAX_FORCEJITTERBUF);\n\t\n\t/* Populate our address from the given */\n\tif (create_addr(pds.peer, NULL, &sin, &cai)) {\n\t\t*cause = AST_CAUSE_UNREGISTERED;\n\t\treturn NULL;\n\t}\n\n\tif (pds.port)\n\t\tsin.sin_port = htons(atoi(pds.port));\n\n\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd, 0);\n\tif (callno < 1) {\n\t\tast_log(LOG_WARNING, \"Unable to create call\\n\");\n\t\t*cause = AST_CAUSE_CONGESTION;\n\t\treturn NULL;\n\t}\n\n\t/* If this is a trunk, update it now */\n\tast_copy_flags(iaxs[callno], &cai, IAX_TRUNK | IAX_SENDANI | IAX_NOTRANSFER | IAX_TRANSFERMEDIA | IAX_USEJITTERBUF | IAX_FORCEJITTERBUF);\t\n\tif (ast_test_flag(&cai, IAX_TRUNK)) {\n\t\tint new_callno;\n\t\tif ((new_callno = make_trunk(callno, 1)) != -1)\n\t\t\tcallno = new_callno;\n\t}\n\tiaxs[callno]->maxtime = cai.maxtime;\n\tif (cai.found)\n\t\tast_string_field_set(iaxs[callno], host, pds.peer);\n\n\tc = ast_iax2_new(callno, AST_STATE_DOWN, cai.capability);\n\n\tast_mutex_unlock(&iaxsl[callno]);\n\n\tif (c) {\n\t\t/* Choose a format we can live with */\n\t\tif (c->nativeformats & format) \n\t\t\tc->nativeformats &= format;\n\t\telse {\n\t\t\tnative = c->nativeformats;\n\t\t\tfmt = format;\n\t\t\tres = ast_translator_best_choice(&fmt, &native);\n\t\t\tif (res < 0) {\n\t\t\t\tast_log(LOG_WARNING, \"Unable to create translator path for %s to %s on %s\\n\",\n\t\t\t\t\tast_getformatname(c->nativeformats), ast_getformatname(fmt), c->name);\n\t\t\t\tast_hangup(c);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tc->nativeformats = native;\n\t\t}\n\t\tc->readformat = ast_best_codec(c->nativeformats);\n\t\tc->writeformat = c->readformat;\n\t}\n\n\treturn c;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -32,7 +32,7 @@\n \tif (pds.port)\n \t\tsin.sin_port = htons(atoi(pds.port));\n \n-\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd);\n+\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd, 0);\n \tif (callno < 1) {\n \t\tast_log(LOG_WARNING, \"Unable to create call\\n\");\n \t\t*cause = AST_CAUSE_CONGESTION;",
        "diff_line_info": {
            "deleted_lines": [
                "\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd);"
            ],
            "added_lines": [
                "\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd, 0);"
            ]
        }
    },
    {
        "cve_id": "CVE-2008-1897",
        "func_name": "jcollie/asterisk/__find_callno",
        "description": "The IAX2 channel driver (chan_iax2) in Asterisk Open Source 1.0.x, 1.2.x before 1.2.28, and 1.4.x before 1.4.19.1; Business Edition A.x.x, B.x.x before B.2.5.2, and C.x.x before C.1.8.1; AsteriskNOW before 1.0.3; Appliance Developer Kit 0.x.x; and s800i before 1.1.0.3, when configured to allow unauthenticated calls, does not verify that an ACK response contains a call number matching the server's reply to a NEW message, which allows remote attackers to cause a denial of service (traffic amplification) via a spoofed ACK response that does not complete a 3-way handshake.  NOTE: this issue exists because of an incomplete fix for CVE-2008-1923.",
        "git_url": "https://github.com/jcollie/asterisk/commit/a8b180875b037b8da26f6a3bcc8e5e98b8c904d2",
        "commit_title": "Merged revisions 114558 via svnmerge from ",
        "commit_text": "https://origsvn.digium.com/svn/asterisk/branches/1.4  ........ r114558 | russell | 2008-04-22 17:15:36 -0500 (Tue, 22 Apr 2008) | 5 lines  When we receive a full frame that is supposed to contain our call number, ensure that it has the correct one. (closes issue #10078) (AST-2008-006)  ........  ",
        "func_before": "static int __find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int return_locked)\n{\n\tint res = 0;\n\tint x;\n\tstruct timeval now;\n\tchar host[80];\n\n\tif (new <= NEW_ALLOW) {\n\t\tfor (x=1;(res < 1) && (x<maxnontrunkcall);x++) {\n\t\t\tast_mutex_lock(&iaxsl[x]);\n\t\t\tif (iaxs[x]) {\n\t\t\t\t/* Look for an exact match */\n\t\t\t\tif (match(sin, callno, dcallno, iaxs[x])) {\n\t\t\t\t\tres = x;\n\t\t\t\t}\n\t\t\t}\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t}\n\t\tfor (x=TRUNK_CALL_START;(res < 1) && (x<maxtrunkcall);x++) {\n\t\t\tast_mutex_lock(&iaxsl[x]);\n\t\t\tif (iaxs[x]) {\n\t\t\t\t/* Look for an exact match */\n\t\t\t\tif (match(sin, callno, dcallno, iaxs[x])) {\n\t\t\t\t\tres = x;\n\t\t\t\t}\n\t\t\t}\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t}\n\t}\n\tif ((res < 1) && (new >= NEW_ALLOW)) {\n\t\t/* It may seem odd that we look through the peer list for a name for\n\t\t * this *incoming* call.  Well, it is weird.  However, users don't\n\t\t * have an IP address/port number that we can match against.  So,\n\t\t * this is just checking for a peer that has that IP/port and\n\t\t * assuming that we have a user of the same name.  This isn't always\n\t\t * correct, but it will be changed if needed after authentication. */\n\t\tif (!iax2_getpeername(*sin, host, sizeof(host)))\n\t\t\tsnprintf(host, sizeof(host), \"%s:%d\", ast_inet_ntoa(sin->sin_addr), ntohs(sin->sin_port));\n\t\tnow = ast_tvnow();\n\t\tfor (x=1;x<TRUNK_CALL_START;x++) {\n\t\t\t/* Find first unused call number that hasn't been used in a while */\n\t\t\tast_mutex_lock(&iaxsl[x]);\n\t\t\tif (!iaxs[x] && ((now.tv_sec - lastused[x].tv_sec) > MIN_REUSE_TIME)) break;\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t}\n\t\t/* We've still got lock held if we found a spot */\n\t\tif (x >= TRUNK_CALL_START) {\n\t\t\tast_log(LOG_WARNING, \"No more space\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tiaxs[x] = new_iax(sin, host);\n\t\tupdate_max_nontrunk();\n\t\tif (iaxs[x]) {\n\t\t\tif (iaxdebug)\n\t\t\t\tast_debug(1, \"Creating new call structure %d\\n\", x);\n\t\t\tiaxs[x]->sockfd = sockfd;\n\t\t\tiaxs[x]->addr.sin_port = sin->sin_port;\n\t\t\tiaxs[x]->addr.sin_family = sin->sin_family;\n\t\t\tiaxs[x]->addr.sin_addr.s_addr = sin->sin_addr.s_addr;\n\t\t\tiaxs[x]->peercallno = callno;\n\t\t\tiaxs[x]->callno = x;\n\t\t\tiaxs[x]->pingtime = DEFAULT_RETRY_TIME;\n\t\t\tiaxs[x]->expiry = min_reg_expire;\n\t\t\tiaxs[x]->pingid = iax2_sched_add(sched, ping_time * 1000, send_ping, (void *)(long)x);\n\t\t\tiaxs[x]->lagid = iax2_sched_add(sched, lagrq_time * 1000, send_lagrq, (void *)(long)x);\n\t\t\tiaxs[x]->amaflags = amaflags;\n\t\t\tast_copy_flags(iaxs[x], (&globalflags), IAX_NOTRANSFER | IAX_TRANSFERMEDIA | IAX_USEJITTERBUF | IAX_FORCEJITTERBUF);\n\t\t\t\n\t\t\tast_string_field_set(iaxs[x], accountcode, accountcode);\n\t\t\tast_string_field_set(iaxs[x], mohinterpret, mohinterpret);\n\t\t\tast_string_field_set(iaxs[x], mohsuggest, mohsuggest);\n\t\t\tast_string_field_set(iaxs[x], parkinglot, default_parkinglot);\n\t\t} else {\n\t\t\tast_log(LOG_WARNING, \"Out of resources\\n\");\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t\treturn 0;\n\t\t}\n\t\tif (!return_locked)\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\tres = x;\n\t}\n\treturn res;\n}",
        "func": "static int __find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int return_locked, int full_frame)\n{\n\tint res = 0;\n\tint x;\n\tstruct timeval now;\n\tchar host[80];\n\n\tif (new <= NEW_ALLOW) {\n\t\tfor (x=1;(res < 1) && (x<maxnontrunkcall);x++) {\n\t\t\tast_mutex_lock(&iaxsl[x]);\n\t\t\tif (iaxs[x]) {\n\t\t\t\t/* Look for an exact match */\n\t\t\t\tif (match(sin, callno, dcallno, iaxs[x], full_frame)) {\n\t\t\t\t\tres = x;\n\t\t\t\t}\n\t\t\t}\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t}\n\t\tfor (x=TRUNK_CALL_START;(res < 1) && (x<maxtrunkcall);x++) {\n\t\t\tast_mutex_lock(&iaxsl[x]);\n\t\t\tif (iaxs[x]) {\n\t\t\t\t/* Look for an exact match */\n\t\t\t\tif (match(sin, callno, dcallno, iaxs[x], full_frame)) {\n\t\t\t\t\tres = x;\n\t\t\t\t}\n\t\t\t}\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t}\n\t}\n\tif ((res < 1) && (new >= NEW_ALLOW)) {\n\t\tint start, found = 0;\n\n\t\t/* It may seem odd that we look through the peer list for a name for\n\t\t * this *incoming* call.  Well, it is weird.  However, users don't\n\t\t * have an IP address/port number that we can match against.  So,\n\t\t * this is just checking for a peer that has that IP/port and\n\t\t * assuming that we have a user of the same name.  This isn't always\n\t\t * correct, but it will be changed if needed after authentication. */\n\t\tif (!iax2_getpeername(*sin, host, sizeof(host)))\n\t\t\tsnprintf(host, sizeof(host), \"%s:%d\", ast_inet_ntoa(sin->sin_addr), ntohs(sin->sin_port));\n\n\t\tnow = ast_tvnow();\n\t\tstart = 1 + (ast_random() % (TRUNK_CALL_START - 1));\n\t\tfor (x = start; 1; x++) {\n\t\t\tif (x == TRUNK_CALL_START) {\n\t\t\t\tx = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* Find first unused call number that hasn't been used in a while */\n\t\t\tast_mutex_lock(&iaxsl[x]);\n\t\t\tif (!iaxs[x] && ((now.tv_sec - lastused[x].tv_sec) > MIN_REUSE_TIME)) {\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t\t\n\t\t\tif (x == start - 1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/* We've still got lock held if we found a spot */\n\t\tif (x == start - 1 && !found) {\n\t\t\tast_log(LOG_WARNING, \"No more space\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tiaxs[x] = new_iax(sin, host);\n\t\tupdate_max_nontrunk();\n\t\tif (iaxs[x]) {\n\t\t\tif (iaxdebug)\n\t\t\t\tast_debug(1, \"Creating new call structure %d\\n\", x);\n\t\t\tiaxs[x]->sockfd = sockfd;\n\t\t\tiaxs[x]->addr.sin_port = sin->sin_port;\n\t\t\tiaxs[x]->addr.sin_family = sin->sin_family;\n\t\t\tiaxs[x]->addr.sin_addr.s_addr = sin->sin_addr.s_addr;\n\t\t\tiaxs[x]->peercallno = callno;\n\t\t\tiaxs[x]->callno = x;\n\t\t\tiaxs[x]->pingtime = DEFAULT_RETRY_TIME;\n\t\t\tiaxs[x]->expiry = min_reg_expire;\n\t\t\tiaxs[x]->pingid = iax2_sched_add(sched, ping_time * 1000, send_ping, (void *)(long)x);\n\t\t\tiaxs[x]->lagid = iax2_sched_add(sched, lagrq_time * 1000, send_lagrq, (void *)(long)x);\n\t\t\tiaxs[x]->amaflags = amaflags;\n\t\t\tast_copy_flags(iaxs[x], (&globalflags), IAX_NOTRANSFER | IAX_TRANSFERMEDIA | IAX_USEJITTERBUF | IAX_FORCEJITTERBUF);\n\t\t\t\n\t\t\tast_string_field_set(iaxs[x], accountcode, accountcode);\n\t\t\tast_string_field_set(iaxs[x], mohinterpret, mohinterpret);\n\t\t\tast_string_field_set(iaxs[x], mohsuggest, mohsuggest);\n\t\t\tast_string_field_set(iaxs[x], parkinglot, default_parkinglot);\n\t\t} else {\n\t\t\tast_log(LOG_WARNING, \"Out of resources\\n\");\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t\treturn 0;\n\t\t}\n\t\tif (!return_locked)\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\tres = x;\n\t}\n\treturn res;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,4 @@\n-static int __find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int return_locked)\n+static int __find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int return_locked, int full_frame)\n {\n \tint res = 0;\n \tint x;\n@@ -10,7 +10,7 @@\n \t\t\tast_mutex_lock(&iaxsl[x]);\n \t\t\tif (iaxs[x]) {\n \t\t\t\t/* Look for an exact match */\n-\t\t\t\tif (match(sin, callno, dcallno, iaxs[x])) {\n+\t\t\t\tif (match(sin, callno, dcallno, iaxs[x], full_frame)) {\n \t\t\t\t\tres = x;\n \t\t\t\t}\n \t\t\t}\n@@ -20,7 +20,7 @@\n \t\t\tast_mutex_lock(&iaxsl[x]);\n \t\t\tif (iaxs[x]) {\n \t\t\t\t/* Look for an exact match */\n-\t\t\t\tif (match(sin, callno, dcallno, iaxs[x])) {\n+\t\t\t\tif (match(sin, callno, dcallno, iaxs[x], full_frame)) {\n \t\t\t\t\tres = x;\n \t\t\t\t}\n \t\t\t}\n@@ -28,6 +28,8 @@\n \t\t}\n \t}\n \tif ((res < 1) && (new >= NEW_ALLOW)) {\n+\t\tint start, found = 0;\n+\n \t\t/* It may seem odd that we look through the peer list for a name for\n \t\t * this *incoming* call.  Well, it is weird.  However, users don't\n \t\t * have an IP address/port number that we can match against.  So,\n@@ -36,15 +38,29 @@\n \t\t * correct, but it will be changed if needed after authentication. */\n \t\tif (!iax2_getpeername(*sin, host, sizeof(host)))\n \t\t\tsnprintf(host, sizeof(host), \"%s:%d\", ast_inet_ntoa(sin->sin_addr), ntohs(sin->sin_port));\n+\n \t\tnow = ast_tvnow();\n-\t\tfor (x=1;x<TRUNK_CALL_START;x++) {\n+\t\tstart = 1 + (ast_random() % (TRUNK_CALL_START - 1));\n+\t\tfor (x = start; 1; x++) {\n+\t\t\tif (x == TRUNK_CALL_START) {\n+\t\t\t\tx = 0;\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\n \t\t\t/* Find first unused call number that hasn't been used in a while */\n \t\t\tast_mutex_lock(&iaxsl[x]);\n-\t\t\tif (!iaxs[x] && ((now.tv_sec - lastused[x].tv_sec) > MIN_REUSE_TIME)) break;\n+\t\t\tif (!iaxs[x] && ((now.tv_sec - lastused[x].tv_sec) > MIN_REUSE_TIME)) {\n+\t\t\t\tfound = 1;\n+\t\t\t\tbreak;\n+\t\t\t}\n \t\t\tast_mutex_unlock(&iaxsl[x]);\n+\t\t\t\n+\t\t\tif (x == start - 1) {\n+\t\t\t\tbreak;\n+\t\t\t}\n \t\t}\n \t\t/* We've still got lock held if we found a spot */\n-\t\tif (x >= TRUNK_CALL_START) {\n+\t\tif (x == start - 1 && !found) {\n \t\t\tast_log(LOG_WARNING, \"No more space\\n\");\n \t\t\treturn 0;\n \t\t}",
        "diff_line_info": {
            "deleted_lines": [
                "static int __find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int return_locked)",
                "\t\t\t\tif (match(sin, callno, dcallno, iaxs[x])) {",
                "\t\t\t\tif (match(sin, callno, dcallno, iaxs[x])) {",
                "\t\tfor (x=1;x<TRUNK_CALL_START;x++) {",
                "\t\t\tif (!iaxs[x] && ((now.tv_sec - lastused[x].tv_sec) > MIN_REUSE_TIME)) break;",
                "\t\tif (x >= TRUNK_CALL_START) {"
            ],
            "added_lines": [
                "static int __find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int return_locked, int full_frame)",
                "\t\t\t\tif (match(sin, callno, dcallno, iaxs[x], full_frame)) {",
                "\t\t\t\tif (match(sin, callno, dcallno, iaxs[x], full_frame)) {",
                "\t\tint start, found = 0;",
                "",
                "",
                "\t\tstart = 1 + (ast_random() % (TRUNK_CALL_START - 1));",
                "\t\tfor (x = start; 1; x++) {",
                "\t\t\tif (x == TRUNK_CALL_START) {",
                "\t\t\t\tx = 0;",
                "\t\t\t\tcontinue;",
                "\t\t\t}",
                "",
                "\t\t\tif (!iaxs[x] && ((now.tv_sec - lastused[x].tv_sec) > MIN_REUSE_TIME)) {",
                "\t\t\t\tfound = 1;",
                "\t\t\t\tbreak;",
                "\t\t\t}",
                "\t\t\t",
                "\t\t\tif (x == start - 1) {",
                "\t\t\t\tbreak;",
                "\t\t\t}",
                "\t\tif (x == start - 1 && !found) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2008-1897",
        "func_name": "xrg/asterisk-xrg/find_callno",
        "description": "The IAX2 channel driver (chan_iax2) in Asterisk Open Source 1.0.x, 1.2.x before 1.2.28, and 1.4.x before 1.4.19.1; Business Edition A.x.x, B.x.x before B.2.5.2, and C.x.x before C.1.8.1; AsteriskNOW before 1.0.3; Appliance Developer Kit 0.x.x; and s800i before 1.1.0.3, when configured to allow unauthenticated calls, does not verify that an ACK response contains a call number matching the server's reply to a NEW message, which allows remote attackers to cause a denial of service (traffic amplification) via a spoofed ACK response that does not complete a 3-way handshake.  NOTE: this issue exists because of an incomplete fix for CVE-2008-1923.",
        "git_url": "https://github.com/xrg/asterisk-xrg/commit/51714a24347dc57f9a208a4a8af84115ef407b83",
        "commit_title": "Merged revisions 114558 via svnmerge from ",
        "commit_text": "https://origsvn.digium.com/svn/asterisk/branches/1.4  ........ r114558 | russell | 2008-04-22 17:15:36 -0500 (Tue, 22 Apr 2008) | 5 lines  When we receive a full frame that is supposed to contain our call number, ensure that it has the correct one. (closes issue #10078) (AST-2008-006)  ........",
        "func_before": "static int find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd) {\n\n\treturn __find_callno(callno, dcallno, sin, new, sockfd, 0);\n}",
        "func": "static int find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int full_frame) {\n\n\treturn __find_callno(callno, dcallno, sin, new, sockfd, 0, full_frame);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,4 @@\n-static int find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd) {\n+static int find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int full_frame) {\n \n-\treturn __find_callno(callno, dcallno, sin, new, sockfd, 0);\n+\treturn __find_callno(callno, dcallno, sin, new, sockfd, 0, full_frame);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "static int find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd) {",
                "\treturn __find_callno(callno, dcallno, sin, new, sockfd, 0);"
            ],
            "added_lines": [
                "static int find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int full_frame) {",
                "\treturn __find_callno(callno, dcallno, sin, new, sockfd, 0, full_frame);"
            ]
        }
    },
    {
        "cve_id": "CVE-2008-1897",
        "func_name": "xrg/asterisk-xrg/iax2_do_register",
        "description": "The IAX2 channel driver (chan_iax2) in Asterisk Open Source 1.0.x, 1.2.x before 1.2.28, and 1.4.x before 1.4.19.1; Business Edition A.x.x, B.x.x before B.2.5.2, and C.x.x before C.1.8.1; AsteriskNOW before 1.0.3; Appliance Developer Kit 0.x.x; and s800i before 1.1.0.3, when configured to allow unauthenticated calls, does not verify that an ACK response contains a call number matching the server's reply to a NEW message, which allows remote attackers to cause a denial of service (traffic amplification) via a spoofed ACK response that does not complete a 3-way handshake.  NOTE: this issue exists because of an incomplete fix for CVE-2008-1923.",
        "git_url": "https://github.com/xrg/asterisk-xrg/commit/51714a24347dc57f9a208a4a8af84115ef407b83",
        "commit_title": "Merged revisions 114558 via svnmerge from ",
        "commit_text": "https://origsvn.digium.com/svn/asterisk/branches/1.4  ........ r114558 | russell | 2008-04-22 17:15:36 -0500 (Tue, 22 Apr 2008) | 5 lines  When we receive a full frame that is supposed to contain our call number, ensure that it has the correct one. (closes issue #10078) (AST-2008-006)  ........",
        "func_before": "static int iax2_do_register(struct iax2_registry *reg)\n{\n\tstruct iax_ie_data ied;\n\tif (iaxdebug)\n\t\tast_debug(1, \"Sending registration request for '%s'\\n\", reg->username);\n\n\tif (reg->dnsmgr && \n\t    ((reg->regstate == REG_STATE_TIMEOUT) || !reg->addr.sin_addr.s_addr)) {\n\t\t/* Maybe the IP has changed, force DNS refresh */\n\t\tast_dnsmgr_refresh(reg->dnsmgr);\n\t}\n\t\n\t/*\n\t * if IP has Changed, free allocated call to create a new one with new IP\n\t * call has the pointer to IP and must be updated to the new one\n\t */\n\tif (reg->dnsmgr && ast_dnsmgr_changed(reg->dnsmgr) && (reg->callno > 0)) {\n\t\tast_mutex_lock(&iaxsl[reg->callno]);\n\t\tiax2_destroy(reg->callno);\n\t\tast_mutex_unlock(&iaxsl[reg->callno]);\n\t\treg->callno = 0;\n\t}\n\tif (!reg->addr.sin_addr.s_addr) {\n\t\tif (iaxdebug)\n\t\t\tast_debug(1, \"Unable to send registration request for '%s' without IP address\\n\", reg->username);\n\t\t/* Setup the next registration attempt */\n\t\treg->expire = iax2_sched_replace(reg->expire, sched, \n\t\t\t(5 * reg->refresh / 6) * 1000, iax2_do_register_s, reg);\n\t\treturn -1;\n\t}\n\n\tif (!reg->callno) {\n\t\tast_debug(1, \"Allocate call number\\n\");\n\t\treg->callno = find_callno_locked(0, 0, &reg->addr, NEW_FORCE, defaultsockfd);\n\t\tif (reg->callno < 1) {\n\t\t\tast_log(LOG_WARNING, \"Unable to create call for registration\\n\");\n\t\t\treturn -1;\n\t\t} else\n\t\t\tast_debug(1, \"Registration created on call %d\\n\", reg->callno);\n\t\tiaxs[reg->callno]->reg = reg;\n\t\tast_mutex_unlock(&iaxsl[reg->callno]);\n\t}\n\t/* Setup the next registration a little early */\n\treg->expire = iax2_sched_replace(reg->expire, sched, \n\t\t(5 * reg->refresh / 6) * 1000, iax2_do_register_s, reg);\n\t/* Send the request */\n\tmemset(&ied, 0, sizeof(ied));\n\tiax_ie_append_str(&ied, IAX_IE_USERNAME, reg->username);\n\tiax_ie_append_short(&ied, IAX_IE_REFRESH, reg->refresh);\n\tsend_command(iaxs[reg->callno],AST_FRAME_IAX, IAX_COMMAND_REGREQ, 0, ied.buf, ied.pos, -1);\n\treg->regstate = REG_STATE_REGSENT;\n\treturn 0;\n}",
        "func": "static int iax2_do_register(struct iax2_registry *reg)\n{\n\tstruct iax_ie_data ied;\n\tif (iaxdebug)\n\t\tast_debug(1, \"Sending registration request for '%s'\\n\", reg->username);\n\n\tif (reg->dnsmgr && \n\t    ((reg->regstate == REG_STATE_TIMEOUT) || !reg->addr.sin_addr.s_addr)) {\n\t\t/* Maybe the IP has changed, force DNS refresh */\n\t\tast_dnsmgr_refresh(reg->dnsmgr);\n\t}\n\t\n\t/*\n\t * if IP has Changed, free allocated call to create a new one with new IP\n\t * call has the pointer to IP and must be updated to the new one\n\t */\n\tif (reg->dnsmgr && ast_dnsmgr_changed(reg->dnsmgr) && (reg->callno > 0)) {\n\t\tast_mutex_lock(&iaxsl[reg->callno]);\n\t\tiax2_destroy(reg->callno);\n\t\tast_mutex_unlock(&iaxsl[reg->callno]);\n\t\treg->callno = 0;\n\t}\n\tif (!reg->addr.sin_addr.s_addr) {\n\t\tif (iaxdebug)\n\t\t\tast_debug(1, \"Unable to send registration request for '%s' without IP address\\n\", reg->username);\n\t\t/* Setup the next registration attempt */\n\t\treg->expire = iax2_sched_replace(reg->expire, sched, \n\t\t\t(5 * reg->refresh / 6) * 1000, iax2_do_register_s, reg);\n\t\treturn -1;\n\t}\n\n\tif (!reg->callno) {\n\t\tast_debug(1, \"Allocate call number\\n\");\n\t\treg->callno = find_callno_locked(0, 0, &reg->addr, NEW_FORCE, defaultsockfd, 0);\n\t\tif (reg->callno < 1) {\n\t\t\tast_log(LOG_WARNING, \"Unable to create call for registration\\n\");\n\t\t\treturn -1;\n\t\t} else\n\t\t\tast_debug(1, \"Registration created on call %d\\n\", reg->callno);\n\t\tiaxs[reg->callno]->reg = reg;\n\t\tast_mutex_unlock(&iaxsl[reg->callno]);\n\t}\n\t/* Setup the next registration a little early */\n\treg->expire = iax2_sched_replace(reg->expire, sched, \n\t\t(5 * reg->refresh / 6) * 1000, iax2_do_register_s, reg);\n\t/* Send the request */\n\tmemset(&ied, 0, sizeof(ied));\n\tiax_ie_append_str(&ied, IAX_IE_USERNAME, reg->username);\n\tiax_ie_append_short(&ied, IAX_IE_REFRESH, reg->refresh);\n\tsend_command(iaxs[reg->callno],AST_FRAME_IAX, IAX_COMMAND_REGREQ, 0, ied.buf, ied.pos, -1);\n\treg->regstate = REG_STATE_REGSENT;\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -31,7 +31,7 @@\n \n \tif (!reg->callno) {\n \t\tast_debug(1, \"Allocate call number\\n\");\n-\t\treg->callno = find_callno_locked(0, 0, &reg->addr, NEW_FORCE, defaultsockfd);\n+\t\treg->callno = find_callno_locked(0, 0, &reg->addr, NEW_FORCE, defaultsockfd, 0);\n \t\tif (reg->callno < 1) {\n \t\t\tast_log(LOG_WARNING, \"Unable to create call for registration\\n\");\n \t\t\treturn -1;",
        "diff_line_info": {
            "deleted_lines": [
                "\t\treg->callno = find_callno_locked(0, 0, &reg->addr, NEW_FORCE, defaultsockfd);"
            ],
            "added_lines": [
                "\t\treg->callno = find_callno_locked(0, 0, &reg->addr, NEW_FORCE, defaultsockfd, 0);"
            ]
        }
    },
    {
        "cve_id": "CVE-2008-1897",
        "func_name": "xrg/asterisk-xrg/iax2_poke_peer",
        "description": "The IAX2 channel driver (chan_iax2) in Asterisk Open Source 1.0.x, 1.2.x before 1.2.28, and 1.4.x before 1.4.19.1; Business Edition A.x.x, B.x.x before B.2.5.2, and C.x.x before C.1.8.1; AsteriskNOW before 1.0.3; Appliance Developer Kit 0.x.x; and s800i before 1.1.0.3, when configured to allow unauthenticated calls, does not verify that an ACK response contains a call number matching the server's reply to a NEW message, which allows remote attackers to cause a denial of service (traffic amplification) via a spoofed ACK response that does not complete a 3-way handshake.  NOTE: this issue exists because of an incomplete fix for CVE-2008-1923.",
        "git_url": "https://github.com/xrg/asterisk-xrg/commit/51714a24347dc57f9a208a4a8af84115ef407b83",
        "commit_title": "Merged revisions 114558 via svnmerge from ",
        "commit_text": "https://origsvn.digium.com/svn/asterisk/branches/1.4  ........ r114558 | russell | 2008-04-22 17:15:36 -0500 (Tue, 22 Apr 2008) | 5 lines  When we receive a full frame that is supposed to contain our call number, ensure that it has the correct one. (closes issue #10078) (AST-2008-006)  ........",
        "func_before": "static int iax2_poke_peer(struct iax2_peer *peer, int heldcall)\n{\n\tif (!peer->maxms || (!peer->addr.sin_addr.s_addr && !peer->dnsmgr)) {\n\t\t/* IF we have no IP without dnsmgr, or this isn't to be monitored, return\n\t\t  immediately after clearing things out */\n\t\tpeer->lastms = 0;\n\t\tpeer->historicms = 0;\n\t\tpeer->pokeexpire = -1;\n\t\tpeer->callno = 0;\n\t\treturn 0;\n\t}\n\tif (peer->callno > 0) {\n\t\tast_log(LOG_NOTICE, \"Still have a callno...\\n\");\n\t\tast_mutex_lock(&iaxsl[peer->callno]);\n\t\tiax2_destroy(peer->callno);\n\t\tast_mutex_unlock(&iaxsl[peer->callno]);\n\t}\n\tif (heldcall)\n\t\tast_mutex_unlock(&iaxsl[heldcall]);\n\tpeer->callno = find_callno(0, 0, &peer->addr, NEW_FORCE, peer->sockfd);\n\tif (heldcall)\n\t\tast_mutex_lock(&iaxsl[heldcall]);\n\tif (peer->callno < 1) {\n\t\tast_log(LOG_WARNING, \"Unable to allocate call for poking peer '%s'\\n\", peer->name);\n\t\treturn -1;\n\t}\n\n\t/* Speed up retransmission times for this qualify call */\n\tiaxs[peer->callno]->pingtime = peer->maxms / 4 + 1;\n\tiaxs[peer->callno]->peerpoke = peer;\n\n \tif (peer->pokeexpire > -1) {\n \t\tif (!ast_sched_del(sched, peer->pokeexpire)) {\n \t\t\tpeer->pokeexpire = -1;\n \t\t\tpeer_unref(peer);\n \t\t}\n \t}\n \n\t/* Queue up a new task to handle no reply */\n\t/* If the host is already unreachable then use the unreachable interval instead */\n\tif (peer->lastms < 0)\n \t\tpeer->pokeexpire = iax2_sched_add(sched, peer->pokefreqnotok, iax2_poke_noanswer, peer_ref(peer));\n\telse\n \t\tpeer->pokeexpire = iax2_sched_add(sched, DEFAULT_MAXMS * 2, iax2_poke_noanswer, peer_ref(peer));\n\n \tif (peer->pokeexpire == -1)\n \t\tpeer_unref(peer);\n\n\t/* And send the poke */\n\tsend_command(iaxs[peer->callno], AST_FRAME_IAX, IAX_COMMAND_POKE, 0, NULL, 0, -1);\n\n\treturn 0;\n}",
        "func": "static int iax2_poke_peer(struct iax2_peer *peer, int heldcall)\n{\n\tif (!peer->maxms || (!peer->addr.sin_addr.s_addr && !peer->dnsmgr)) {\n\t\t/* IF we have no IP without dnsmgr, or this isn't to be monitored, return\n\t\t  immediately after clearing things out */\n\t\tpeer->lastms = 0;\n\t\tpeer->historicms = 0;\n\t\tpeer->pokeexpire = -1;\n\t\tpeer->callno = 0;\n\t\treturn 0;\n\t}\n\tif (peer->callno > 0) {\n\t\tast_log(LOG_NOTICE, \"Still have a callno...\\n\");\n\t\tast_mutex_lock(&iaxsl[peer->callno]);\n\t\tiax2_destroy(peer->callno);\n\t\tast_mutex_unlock(&iaxsl[peer->callno]);\n\t}\n\tif (heldcall)\n\t\tast_mutex_unlock(&iaxsl[heldcall]);\n\tpeer->callno = find_callno(0, 0, &peer->addr, NEW_FORCE, peer->sockfd, 0);\n\tif (heldcall)\n\t\tast_mutex_lock(&iaxsl[heldcall]);\n\tif (peer->callno < 1) {\n\t\tast_log(LOG_WARNING, \"Unable to allocate call for poking peer '%s'\\n\", peer->name);\n\t\treturn -1;\n\t}\n\n\t/* Speed up retransmission times for this qualify call */\n\tiaxs[peer->callno]->pingtime = peer->maxms / 4 + 1;\n\tiaxs[peer->callno]->peerpoke = peer;\n\n \tif (peer->pokeexpire > -1) {\n \t\tif (!ast_sched_del(sched, peer->pokeexpire)) {\n \t\t\tpeer->pokeexpire = -1;\n \t\t\tpeer_unref(peer);\n \t\t}\n \t}\n \n\t/* Queue up a new task to handle no reply */\n\t/* If the host is already unreachable then use the unreachable interval instead */\n\tif (peer->lastms < 0)\n \t\tpeer->pokeexpire = iax2_sched_add(sched, peer->pokefreqnotok, iax2_poke_noanswer, peer_ref(peer));\n\telse\n \t\tpeer->pokeexpire = iax2_sched_add(sched, DEFAULT_MAXMS * 2, iax2_poke_noanswer, peer_ref(peer));\n\n \tif (peer->pokeexpire == -1)\n \t\tpeer_unref(peer);\n\n\t/* And send the poke */\n\tsend_command(iaxs[peer->callno], AST_FRAME_IAX, IAX_COMMAND_POKE, 0, NULL, 0, -1);\n\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -17,7 +17,7 @@\n \t}\n \tif (heldcall)\n \t\tast_mutex_unlock(&iaxsl[heldcall]);\n-\tpeer->callno = find_callno(0, 0, &peer->addr, NEW_FORCE, peer->sockfd);\n+\tpeer->callno = find_callno(0, 0, &peer->addr, NEW_FORCE, peer->sockfd, 0);\n \tif (heldcall)\n \t\tast_mutex_lock(&iaxsl[heldcall]);\n \tif (peer->callno < 1) {",
        "diff_line_info": {
            "deleted_lines": [
                "\tpeer->callno = find_callno(0, 0, &peer->addr, NEW_FORCE, peer->sockfd);"
            ],
            "added_lines": [
                "\tpeer->callno = find_callno(0, 0, &peer->addr, NEW_FORCE, peer->sockfd, 0);"
            ]
        }
    },
    {
        "cve_id": "CVE-2008-1897",
        "func_name": "xrg/asterisk-xrg/cache_get_callno_locked",
        "description": "The IAX2 channel driver (chan_iax2) in Asterisk Open Source 1.0.x, 1.2.x before 1.2.28, and 1.4.x before 1.4.19.1; Business Edition A.x.x, B.x.x before B.2.5.2, and C.x.x before C.1.8.1; AsteriskNOW before 1.0.3; Appliance Developer Kit 0.x.x; and s800i before 1.1.0.3, when configured to allow unauthenticated calls, does not verify that an ACK response contains a call number matching the server's reply to a NEW message, which allows remote attackers to cause a denial of service (traffic amplification) via a spoofed ACK response that does not complete a 3-way handshake.  NOTE: this issue exists because of an incomplete fix for CVE-2008-1923.",
        "git_url": "https://github.com/xrg/asterisk-xrg/commit/51714a24347dc57f9a208a4a8af84115ef407b83",
        "commit_title": "Merged revisions 114558 via svnmerge from ",
        "commit_text": "https://origsvn.digium.com/svn/asterisk/branches/1.4  ........ r114558 | russell | 2008-04-22 17:15:36 -0500 (Tue, 22 Apr 2008) | 5 lines  When we receive a full frame that is supposed to contain our call number, ensure that it has the correct one. (closes issue #10078) (AST-2008-006)  ........",
        "func_before": "static int cache_get_callno_locked(const char *data)\n{\n\tstruct sockaddr_in sin;\n\tint x;\n\tint callno;\n\tstruct iax_ie_data ied;\n\tstruct create_addr_info cai;\n\tstruct parsed_dial_string pds;\n\tchar *tmpstr;\n\n\tfor (x=0; x<IAX_MAX_CALLS; x++) {\n\t\t/* Look for an *exact match* call.  Once a call is negotiated, it can only\n\t\t   look up entries for a single context */\n\t\tif (!ast_mutex_trylock(&iaxsl[x])) {\n\t\t\tif (iaxs[x] && !strcasecmp(data, iaxs[x]->dproot))\n\t\t\t\treturn x;\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t}\n\t}\n\n\t/* No match found, we need to create a new one */\n\n\tmemset(&cai, 0, sizeof(cai));\n\tmemset(&ied, 0, sizeof(ied));\n\tmemset(&pds, 0, sizeof(pds));\n\n\ttmpstr = ast_strdupa(data);\n\tparse_dial_string(tmpstr, &pds);\n\n\tif (ast_strlen_zero(pds.peer)) {\n\t\tast_log(LOG_WARNING, \"No peer provided in the IAX2 dial string '%s'\\n\", data);\n\t\treturn -1;\n\t}\n\n\t/* Populate our address from the given */\n\tif (create_addr(pds.peer, NULL, &sin, &cai))\n\t\treturn -1;\n\n\tast_debug(1, \"peer: %s, username: %s, password: %s, context: %s\\n\",\n\t\tpds.peer, pds.username, pds.password, pds.context);\n\n\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd);\n\tif (callno < 1) {\n\t\tast_log(LOG_WARNING, \"Unable to create call\\n\");\n\t\treturn -1;\n\t}\n\n\tast_string_field_set(iaxs[callno], dproot, data);\n\tiaxs[callno]->capability = IAX_CAPABILITY_FULLBANDWIDTH;\n\n\tiax_ie_append_short(&ied, IAX_IE_VERSION, IAX_PROTO_VERSION);\n\tiax_ie_append_str(&ied, IAX_IE_CALLED_NUMBER, \"TBD\");\n\t/* the string format is slightly different from a standard dial string,\n\t   because the context appears in the 'exten' position\n\t*/\n\tif (pds.exten)\n\t\tiax_ie_append_str(&ied, IAX_IE_CALLED_CONTEXT, pds.exten);\n\tif (pds.username)\n\t\tiax_ie_append_str(&ied, IAX_IE_USERNAME, pds.username);\n\tiax_ie_append_int(&ied, IAX_IE_FORMAT, IAX_CAPABILITY_FULLBANDWIDTH);\n\tiax_ie_append_int(&ied, IAX_IE_CAPABILITY, IAX_CAPABILITY_FULLBANDWIDTH);\n\t/* Keep password handy */\n\tif (pds.password)\n\t\tast_string_field_set(iaxs[callno], secret, pds.password);\n\tif (pds.key)\n\t\tast_string_field_set(iaxs[callno], outkey, pds.key);\n\t/* Start the call going */\n\tsend_command(iaxs[callno], AST_FRAME_IAX, IAX_COMMAND_NEW, 0, ied.buf, ied.pos, -1);\n\n\treturn callno;\n}",
        "func": "static int cache_get_callno_locked(const char *data)\n{\n\tstruct sockaddr_in sin;\n\tint x;\n\tint callno;\n\tstruct iax_ie_data ied;\n\tstruct create_addr_info cai;\n\tstruct parsed_dial_string pds;\n\tchar *tmpstr;\n\n\tfor (x=0; x<IAX_MAX_CALLS; x++) {\n\t\t/* Look for an *exact match* call.  Once a call is negotiated, it can only\n\t\t   look up entries for a single context */\n\t\tif (!ast_mutex_trylock(&iaxsl[x])) {\n\t\t\tif (iaxs[x] && !strcasecmp(data, iaxs[x]->dproot))\n\t\t\t\treturn x;\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t}\n\t}\n\n\t/* No match found, we need to create a new one */\n\n\tmemset(&cai, 0, sizeof(cai));\n\tmemset(&ied, 0, sizeof(ied));\n\tmemset(&pds, 0, sizeof(pds));\n\n\ttmpstr = ast_strdupa(data);\n\tparse_dial_string(tmpstr, &pds);\n\n\tif (ast_strlen_zero(pds.peer)) {\n\t\tast_log(LOG_WARNING, \"No peer provided in the IAX2 dial string '%s'\\n\", data);\n\t\treturn -1;\n\t}\n\n\t/* Populate our address from the given */\n\tif (create_addr(pds.peer, NULL, &sin, &cai))\n\t\treturn -1;\n\n\tast_debug(1, \"peer: %s, username: %s, password: %s, context: %s\\n\",\n\t\tpds.peer, pds.username, pds.password, pds.context);\n\n\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd, 0);\n\tif (callno < 1) {\n\t\tast_log(LOG_WARNING, \"Unable to create call\\n\");\n\t\treturn -1;\n\t}\n\n\tast_string_field_set(iaxs[callno], dproot, data);\n\tiaxs[callno]->capability = IAX_CAPABILITY_FULLBANDWIDTH;\n\n\tiax_ie_append_short(&ied, IAX_IE_VERSION, IAX_PROTO_VERSION);\n\tiax_ie_append_str(&ied, IAX_IE_CALLED_NUMBER, \"TBD\");\n\t/* the string format is slightly different from a standard dial string,\n\t   because the context appears in the 'exten' position\n\t*/\n\tif (pds.exten)\n\t\tiax_ie_append_str(&ied, IAX_IE_CALLED_CONTEXT, pds.exten);\n\tif (pds.username)\n\t\tiax_ie_append_str(&ied, IAX_IE_USERNAME, pds.username);\n\tiax_ie_append_int(&ied, IAX_IE_FORMAT, IAX_CAPABILITY_FULLBANDWIDTH);\n\tiax_ie_append_int(&ied, IAX_IE_CAPABILITY, IAX_CAPABILITY_FULLBANDWIDTH);\n\t/* Keep password handy */\n\tif (pds.password)\n\t\tast_string_field_set(iaxs[callno], secret, pds.password);\n\tif (pds.key)\n\t\tast_string_field_set(iaxs[callno], outkey, pds.key);\n\t/* Start the call going */\n\tsend_command(iaxs[callno], AST_FRAME_IAX, IAX_COMMAND_NEW, 0, ied.buf, ied.pos, -1);\n\n\treturn callno;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -39,7 +39,7 @@\n \tast_debug(1, \"peer: %s, username: %s, password: %s, context: %s\\n\",\n \t\tpds.peer, pds.username, pds.password, pds.context);\n \n-\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd);\n+\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd, 0);\n \tif (callno < 1) {\n \t\tast_log(LOG_WARNING, \"Unable to create call\\n\");\n \t\treturn -1;",
        "diff_line_info": {
            "deleted_lines": [
                "\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd);"
            ],
            "added_lines": [
                "\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd, 0);"
            ]
        }
    },
    {
        "cve_id": "CVE-2008-1897",
        "func_name": "xrg/asterisk-xrg/iax2_provision",
        "description": "The IAX2 channel driver (chan_iax2) in Asterisk Open Source 1.0.x, 1.2.x before 1.2.28, and 1.4.x before 1.4.19.1; Business Edition A.x.x, B.x.x before B.2.5.2, and C.x.x before C.1.8.1; AsteriskNOW before 1.0.3; Appliance Developer Kit 0.x.x; and s800i before 1.1.0.3, when configured to allow unauthenticated calls, does not verify that an ACK response contains a call number matching the server's reply to a NEW message, which allows remote attackers to cause a denial of service (traffic amplification) via a spoofed ACK response that does not complete a 3-way handshake.  NOTE: this issue exists because of an incomplete fix for CVE-2008-1923.",
        "git_url": "https://github.com/xrg/asterisk-xrg/commit/51714a24347dc57f9a208a4a8af84115ef407b83",
        "commit_title": "Merged revisions 114558 via svnmerge from ",
        "commit_text": "https://origsvn.digium.com/svn/asterisk/branches/1.4  ........ r114558 | russell | 2008-04-22 17:15:36 -0500 (Tue, 22 Apr 2008) | 5 lines  When we receive a full frame that is supposed to contain our call number, ensure that it has the correct one. (closes issue #10078) (AST-2008-006)  ........",
        "func_before": "static int iax2_provision(struct sockaddr_in *end, int sockfd, char *dest, const char *template, int force)\n{\n\t/* Returns 1 if provisioned, -1 if not able to find destination, or 0 if no provisioning\n\t   is found for template */\n\tstruct iax_ie_data provdata;\n\tstruct iax_ie_data ied;\n\tunsigned int sig;\n\tstruct sockaddr_in sin;\n\tint callno;\n\tstruct create_addr_info cai;\n\n\tmemset(&cai, 0, sizeof(cai));\n\n\tast_debug(1, \"Provisioning '%s' from template '%s'\\n\", dest, template);\n\n\tif (iax_provision_build(&provdata, &sig, template, force)) {\n\t\tast_debug(1, \"No provisioning found for template '%s'\\n\", template);\n\t\treturn 0;\n\t}\n\n\tif (end) {\n\t\tmemcpy(&sin, end, sizeof(sin));\n\t\tcai.sockfd = sockfd;\n\t} else if (create_addr(dest, NULL, &sin, &cai))\n\t\treturn -1;\n\n\t/* Build the rest of the message */\n\tmemset(&ied, 0, sizeof(ied));\n\tiax_ie_append_raw(&ied, IAX_IE_PROVISIONING, provdata.buf, provdata.pos);\n\n\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd);\n\tif (!callno)\n\t\treturn -1;\n\n\tif (iaxs[callno]) {\n\t\t/* Schedule autodestruct in case they don't ever give us anything back */\n\t\tiaxs[callno]->autoid = iax2_sched_replace(iaxs[callno]->autoid, \n\t\t\tsched, 15000, auto_hangup, (void *)(long)callno);\n\t\tast_set_flag(iaxs[callno], IAX_PROVISION);\n\t\t/* Got a call number now, so go ahead and send the provisioning information */\n\t\tsend_command(iaxs[callno], AST_FRAME_IAX, IAX_COMMAND_PROVISION, 0, ied.buf, ied.pos, -1);\n\t}\n\tast_mutex_unlock(&iaxsl[callno]);\n\n\treturn 1;\n}",
        "func": "static int iax2_provision(struct sockaddr_in *end, int sockfd, char *dest, const char *template, int force)\n{\n\t/* Returns 1 if provisioned, -1 if not able to find destination, or 0 if no provisioning\n\t   is found for template */\n\tstruct iax_ie_data provdata;\n\tstruct iax_ie_data ied;\n\tunsigned int sig;\n\tstruct sockaddr_in sin;\n\tint callno;\n\tstruct create_addr_info cai;\n\n\tmemset(&cai, 0, sizeof(cai));\n\n\tast_debug(1, \"Provisioning '%s' from template '%s'\\n\", dest, template);\n\n\tif (iax_provision_build(&provdata, &sig, template, force)) {\n\t\tast_debug(1, \"No provisioning found for template '%s'\\n\", template);\n\t\treturn 0;\n\t}\n\n\tif (end) {\n\t\tmemcpy(&sin, end, sizeof(sin));\n\t\tcai.sockfd = sockfd;\n\t} else if (create_addr(dest, NULL, &sin, &cai))\n\t\treturn -1;\n\n\t/* Build the rest of the message */\n\tmemset(&ied, 0, sizeof(ied));\n\tiax_ie_append_raw(&ied, IAX_IE_PROVISIONING, provdata.buf, provdata.pos);\n\n\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd, 0);\n\tif (!callno)\n\t\treturn -1;\n\n\tif (iaxs[callno]) {\n\t\t/* Schedule autodestruct in case they don't ever give us anything back */\n\t\tiaxs[callno]->autoid = iax2_sched_replace(iaxs[callno]->autoid, \n\t\t\tsched, 15000, auto_hangup, (void *)(long)callno);\n\t\tast_set_flag(iaxs[callno], IAX_PROVISION);\n\t\t/* Got a call number now, so go ahead and send the provisioning information */\n\t\tsend_command(iaxs[callno], AST_FRAME_IAX, IAX_COMMAND_PROVISION, 0, ied.buf, ied.pos, -1);\n\t}\n\tast_mutex_unlock(&iaxsl[callno]);\n\n\treturn 1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -28,7 +28,7 @@\n \tmemset(&ied, 0, sizeof(ied));\n \tiax_ie_append_raw(&ied, IAX_IE_PROVISIONING, provdata.buf, provdata.pos);\n \n-\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd);\n+\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd, 0);\n \tif (!callno)\n \t\treturn -1;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd);"
            ],
            "added_lines": [
                "\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd, 0);"
            ]
        }
    },
    {
        "cve_id": "CVE-2008-1897",
        "func_name": "xrg/asterisk-xrg/match",
        "description": "The IAX2 channel driver (chan_iax2) in Asterisk Open Source 1.0.x, 1.2.x before 1.2.28, and 1.4.x before 1.4.19.1; Business Edition A.x.x, B.x.x before B.2.5.2, and C.x.x before C.1.8.1; AsteriskNOW before 1.0.3; Appliance Developer Kit 0.x.x; and s800i before 1.1.0.3, when configured to allow unauthenticated calls, does not verify that an ACK response contains a call number matching the server's reply to a NEW message, which allows remote attackers to cause a denial of service (traffic amplification) via a spoofed ACK response that does not complete a 3-way handshake.  NOTE: this issue exists because of an incomplete fix for CVE-2008-1923.",
        "git_url": "https://github.com/xrg/asterisk-xrg/commit/51714a24347dc57f9a208a4a8af84115ef407b83",
        "commit_title": "Merged revisions 114558 via svnmerge from ",
        "commit_text": "https://origsvn.digium.com/svn/asterisk/branches/1.4  ........ r114558 | russell | 2008-04-22 17:15:36 -0500 (Tue, 22 Apr 2008) | 5 lines  When we receive a full frame that is supposed to contain our call number, ensure that it has the correct one. (closes issue #10078) (AST-2008-006)  ........",
        "func_before": "static int match(struct sockaddr_in *sin, unsigned short callno, unsigned short dcallno, const struct chan_iax2_pvt *cur)\n{\n\tif ((cur->addr.sin_addr.s_addr == sin->sin_addr.s_addr) &&\n\t\t(cur->addr.sin_port == sin->sin_port)) {\n\t\t/* This is the main host */\n\t\tif ((cur->peercallno == callno) ||\n\t\t\t((dcallno == cur->callno) && !cur->peercallno)) {\n\t\t\t/* That's us.  Be sure we keep track of the peer call number */\n\t\t\treturn 1;\n\t\t}\n\t}\n\tif ((cur->transfer.sin_addr.s_addr == sin->sin_addr.s_addr) &&\n\t    (cur->transfer.sin_port == sin->sin_port) && (cur->transferring)) {\n\t\t/* We're transferring */\n\t\tif ((dcallno == cur->callno) || (cur->transferring == TRANSFER_MEDIAPASS && cur->transfercallno == callno))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
        "func": "static int match(struct sockaddr_in *sin, unsigned short callno, unsigned short dcallno, const struct chan_iax2_pvt *cur, int full_frame)\n{\n\tif ((cur->addr.sin_addr.s_addr == sin->sin_addr.s_addr) &&\n\t\t(cur->addr.sin_port == sin->sin_port)) {\n\t\t/* This is the main host */\n\t\tif ( (cur->peercallno == 0 || cur->peercallno == callno) &&\n\t\t\t (full_frame ? dcallno == cur->callno : 1) ) {\n\t\t\t/* That's us.  Be sure we keep track of the peer call number */\n\t\t\treturn 1;\n\t\t}\n\t}\n\tif ((cur->transfer.sin_addr.s_addr == sin->sin_addr.s_addr) &&\n\t    (cur->transfer.sin_port == sin->sin_port) && (cur->transferring)) {\n\t\t/* We're transferring */\n\t\tif ((dcallno == cur->callno) || (cur->transferring == TRANSFER_MEDIAPASS && cur->transfercallno == callno))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,10 +1,10 @@\n-static int match(struct sockaddr_in *sin, unsigned short callno, unsigned short dcallno, const struct chan_iax2_pvt *cur)\n+static int match(struct sockaddr_in *sin, unsigned short callno, unsigned short dcallno, const struct chan_iax2_pvt *cur, int full_frame)\n {\n \tif ((cur->addr.sin_addr.s_addr == sin->sin_addr.s_addr) &&\n \t\t(cur->addr.sin_port == sin->sin_port)) {\n \t\t/* This is the main host */\n-\t\tif ((cur->peercallno == callno) ||\n-\t\t\t((dcallno == cur->callno) && !cur->peercallno)) {\n+\t\tif ( (cur->peercallno == 0 || cur->peercallno == callno) &&\n+\t\t\t (full_frame ? dcallno == cur->callno : 1) ) {\n \t\t\t/* That's us.  Be sure we keep track of the peer call number */\n \t\t\treturn 1;\n \t\t}",
        "diff_line_info": {
            "deleted_lines": [
                "static int match(struct sockaddr_in *sin, unsigned short callno, unsigned short dcallno, const struct chan_iax2_pvt *cur)",
                "\t\tif ((cur->peercallno == callno) ||",
                "\t\t\t((dcallno == cur->callno) && !cur->peercallno)) {"
            ],
            "added_lines": [
                "static int match(struct sockaddr_in *sin, unsigned short callno, unsigned short dcallno, const struct chan_iax2_pvt *cur, int full_frame)",
                "\t\tif ( (cur->peercallno == 0 || cur->peercallno == callno) &&",
                "\t\t\t (full_frame ? dcallno == cur->callno : 1) ) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2008-1897",
        "func_name": "xrg/asterisk-xrg/socket_process_meta",
        "description": "The IAX2 channel driver (chan_iax2) in Asterisk Open Source 1.0.x, 1.2.x before 1.2.28, and 1.4.x before 1.4.19.1; Business Edition A.x.x, B.x.x before B.2.5.2, and C.x.x before C.1.8.1; AsteriskNOW before 1.0.3; Appliance Developer Kit 0.x.x; and s800i before 1.1.0.3, when configured to allow unauthenticated calls, does not verify that an ACK response contains a call number matching the server's reply to a NEW message, which allows remote attackers to cause a denial of service (traffic amplification) via a spoofed ACK response that does not complete a 3-way handshake.  NOTE: this issue exists because of an incomplete fix for CVE-2008-1923.",
        "git_url": "https://github.com/xrg/asterisk-xrg/commit/51714a24347dc57f9a208a4a8af84115ef407b83",
        "commit_title": "Merged revisions 114558 via svnmerge from ",
        "commit_text": "https://origsvn.digium.com/svn/asterisk/branches/1.4  ........ r114558 | russell | 2008-04-22 17:15:36 -0500 (Tue, 22 Apr 2008) | 5 lines  When we receive a full frame that is supposed to contain our call number, ensure that it has the correct one. (closes issue #10078) (AST-2008-006)  ........",
        "func_before": "static int socket_process_meta(int packet_len, struct ast_iax2_meta_hdr *meta, struct sockaddr_in *sin, int sockfd,\n\tstruct iax_frame *fr)\n{\n\tunsigned char metatype;\n\tstruct ast_iax2_meta_trunk_mini *mtm;\n\tstruct ast_iax2_meta_trunk_hdr *mth;\n\tstruct ast_iax2_meta_trunk_entry *mte;\n\tstruct iax2_trunk_peer *tpeer;\n\tunsigned int ts;\n\tvoid *ptr;\n\tstruct timeval rxtrunktime;\n\tstruct ast_frame f = { 0, };\n\n\tif (packet_len < sizeof(*meta)) {\n\t\tast_log(LOG_WARNING, \"Rejecting packet from '%s.%d' that is flagged as a meta frame but is too short\\n\", \n\t\t\tast_inet_ntoa(sin->sin_addr), ntohs(sin->sin_port));\n\t\treturn 1;\n\t}\n\n\tif (meta->metacmd != IAX_META_TRUNK)\n\t\treturn 1;\n\n\tif (packet_len < (sizeof(*meta) + sizeof(*mth))) {\n\t\tast_log(LOG_WARNING, \"midget meta trunk packet received (%d of %d min)\\n\", packet_len,\n\t\t\t(int) (sizeof(*meta) + sizeof(*mth)));\n\t\treturn 1;\n\t}\n\tmth = (struct ast_iax2_meta_trunk_hdr *)(meta->data);\n\tts = ntohl(mth->ts);\n\tmetatype = meta->cmddata;\n\tpacket_len -= (sizeof(*meta) + sizeof(*mth));\n\tptr = mth->data;\n\ttpeer = find_tpeer(sin, sockfd);\n\tif (!tpeer) {\n\t\tast_log(LOG_WARNING, \"Unable to accept trunked packet from '%s:%d': No matching peer\\n\", \n\t\t\tast_inet_ntoa(sin->sin_addr), ntohs(sin->sin_port));\n\t\treturn 1;\n\t}\n\ttpeer->trunkact = ast_tvnow();\n\tif (!ts || ast_tvzero(tpeer->rxtrunktime))\n\t\ttpeer->rxtrunktime = tpeer->trunkact;\n\trxtrunktime = tpeer->rxtrunktime;\n\tast_mutex_unlock(&tpeer->lock);\n\twhile (packet_len >= sizeof(*mte)) {\n\t\t/* Process channels */\n\t\tunsigned short callno, trunked_ts, len;\n\n\t\tif (metatype == IAX_META_TRUNK_MINI) {\n\t\t\tmtm = (struct ast_iax2_meta_trunk_mini *) ptr;\n\t\t\tptr += sizeof(*mtm);\n\t\t\tpacket_len -= sizeof(*mtm);\n\t\t\tlen = ntohs(mtm->len);\n\t\t\tcallno = ntohs(mtm->mini.callno);\n\t\t\ttrunked_ts = ntohs(mtm->mini.ts);\n\t\t} else if (metatype == IAX_META_TRUNK_SUPERMINI) {\n\t\t\tmte = (struct ast_iax2_meta_trunk_entry *)ptr;\n\t\t\tptr += sizeof(*mte);\n\t\t\tpacket_len -= sizeof(*mte);\n\t\t\tlen = ntohs(mte->len);\n\t\t\tcallno = ntohs(mte->callno);\n\t\t\ttrunked_ts = 0;\n\t\t} else {\n\t\t\tast_log(LOG_WARNING, \"Unknown meta trunk cmd from '%s:%d': dropping\\n\", ast_inet_ntoa(sin->sin_addr), ntohs(sin->sin_port));\n\t\t\tbreak;\n\t\t}\n\t\t/* Stop if we don't have enough data */\n\t\tif (len > packet_len)\n\t\t\tbreak;\n\t\tfr->callno = find_callno_locked(callno & ~IAX_FLAG_FULL, 0, sin, NEW_PREVENT, sockfd);\n\t\tif (!fr->callno)\n\t\t\tcontinue;\n\n\t\t/* If it's a valid call, deliver the contents.  If not, we\n\t\t   drop it, since we don't have a scallno to use for an INVAL */\n\t\t/* Process as a mini frame */\n\t\tmemset(&f, 0, sizeof(f));\n\t\tf.frametype = AST_FRAME_VOICE;\n\t\tif (!iaxs[fr->callno]) {\n\t\t\t/* drop it */\n\t\t} else if (iaxs[fr->callno]->voiceformat == 0) {\n\t\t\tast_log(LOG_WARNING, \"Received trunked frame before first full voice frame\\n \");\n\t\t\tiax2_vnak(fr->callno);\n\t\t} else {\n\t\t\tf.subclass = iaxs[fr->callno]->voiceformat;\n\t\t\tf.datalen = len;\n\t\t\tif (f.datalen >= 0) {\n\t\t\t\tif (f.datalen)\n\t\t\t\t\tf.data = ptr;\n\t\t\t\telse\n\t\t\t\t\tf.data = NULL;\n\t\t\t\tif (trunked_ts)\n\t\t\t\t\tfr->ts = (iaxs[fr->callno]->last & 0xFFFF0000L) | (trunked_ts & 0xffff);\n\t\t\t\telse\n\t\t\t\t\tfr->ts = fix_peerts(&rxtrunktime, fr->callno, ts);\n\t\t\t\t/* Don't pass any packets until we're started */\n\t\t\t\tif (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)) {\n\t\t\t\t\tstruct iax_frame *duped_fr;\n\n\t\t\t\t\t/* Common things */\n\t\t\t\t\tf.src = \"IAX2\";\n\t\t\t\t\tf.mallocd = 0;\n\t\t\t\t\tf.offset = 0;\n\t\t\t\t\tif (f.datalen && (f.frametype == AST_FRAME_VOICE)) \n\t\t\t\t\t\tf.samples = ast_codec_get_samples(&f);\n\t\t\t\t\telse\n\t\t\t\t\t\tf.samples = 0;\n\t\t\t\t\tfr->outoforder = 0;\n\t\t\t\t\tiax_frame_wrap(fr, &f);\n\t\t\t\t\tduped_fr = iaxfrdup2(fr);\n\t\t\t\t\tif (duped_fr)\n\t\t\t\t\t\tschedule_delivery(duped_fr, 1, 1, &fr->ts);\n\t\t\t\t\tif (iaxs[fr->callno] && iaxs[fr->callno]->last < fr->ts)\n\t\t\t\t\t\tiaxs[fr->callno]->last = fr->ts;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tast_log(LOG_WARNING, \"Datalen < 0?\\n\");\n\t\t\t}\n\t\t}\n\t\tast_mutex_unlock(&iaxsl[fr->callno]);\n\t\tptr += len;\n\t\tpacket_len -= len;\n\t}\n\n\treturn 1;\n}",
        "func": "static int socket_process_meta(int packet_len, struct ast_iax2_meta_hdr *meta, struct sockaddr_in *sin, int sockfd,\n\tstruct iax_frame *fr)\n{\n\tunsigned char metatype;\n\tstruct ast_iax2_meta_trunk_mini *mtm;\n\tstruct ast_iax2_meta_trunk_hdr *mth;\n\tstruct ast_iax2_meta_trunk_entry *mte;\n\tstruct iax2_trunk_peer *tpeer;\n\tunsigned int ts;\n\tvoid *ptr;\n\tstruct timeval rxtrunktime;\n\tstruct ast_frame f = { 0, };\n\n\tif (packet_len < sizeof(*meta)) {\n\t\tast_log(LOG_WARNING, \"Rejecting packet from '%s.%d' that is flagged as a meta frame but is too short\\n\", \n\t\t\tast_inet_ntoa(sin->sin_addr), ntohs(sin->sin_port));\n\t\treturn 1;\n\t}\n\n\tif (meta->metacmd != IAX_META_TRUNK)\n\t\treturn 1;\n\n\tif (packet_len < (sizeof(*meta) + sizeof(*mth))) {\n\t\tast_log(LOG_WARNING, \"midget meta trunk packet received (%d of %d min)\\n\", packet_len,\n\t\t\t(int) (sizeof(*meta) + sizeof(*mth)));\n\t\treturn 1;\n\t}\n\tmth = (struct ast_iax2_meta_trunk_hdr *)(meta->data);\n\tts = ntohl(mth->ts);\n\tmetatype = meta->cmddata;\n\tpacket_len -= (sizeof(*meta) + sizeof(*mth));\n\tptr = mth->data;\n\ttpeer = find_tpeer(sin, sockfd);\n\tif (!tpeer) {\n\t\tast_log(LOG_WARNING, \"Unable to accept trunked packet from '%s:%d': No matching peer\\n\", \n\t\t\tast_inet_ntoa(sin->sin_addr), ntohs(sin->sin_port));\n\t\treturn 1;\n\t}\n\ttpeer->trunkact = ast_tvnow();\n\tif (!ts || ast_tvzero(tpeer->rxtrunktime))\n\t\ttpeer->rxtrunktime = tpeer->trunkact;\n\trxtrunktime = tpeer->rxtrunktime;\n\tast_mutex_unlock(&tpeer->lock);\n\twhile (packet_len >= sizeof(*mte)) {\n\t\t/* Process channels */\n\t\tunsigned short callno, trunked_ts, len;\n\n\t\tif (metatype == IAX_META_TRUNK_MINI) {\n\t\t\tmtm = (struct ast_iax2_meta_trunk_mini *) ptr;\n\t\t\tptr += sizeof(*mtm);\n\t\t\tpacket_len -= sizeof(*mtm);\n\t\t\tlen = ntohs(mtm->len);\n\t\t\tcallno = ntohs(mtm->mini.callno);\n\t\t\ttrunked_ts = ntohs(mtm->mini.ts);\n\t\t} else if (metatype == IAX_META_TRUNK_SUPERMINI) {\n\t\t\tmte = (struct ast_iax2_meta_trunk_entry *)ptr;\n\t\t\tptr += sizeof(*mte);\n\t\t\tpacket_len -= sizeof(*mte);\n\t\t\tlen = ntohs(mte->len);\n\t\t\tcallno = ntohs(mte->callno);\n\t\t\ttrunked_ts = 0;\n\t\t} else {\n\t\t\tast_log(LOG_WARNING, \"Unknown meta trunk cmd from '%s:%d': dropping\\n\", ast_inet_ntoa(sin->sin_addr), ntohs(sin->sin_port));\n\t\t\tbreak;\n\t\t}\n\t\t/* Stop if we don't have enough data */\n\t\tif (len > packet_len)\n\t\t\tbreak;\n\t\tfr->callno = find_callno_locked(callno & ~IAX_FLAG_FULL, 0, sin, NEW_PREVENT, sockfd, 0);\n\t\tif (!fr->callno)\n\t\t\tcontinue;\n\n\t\t/* If it's a valid call, deliver the contents.  If not, we\n\t\t   drop it, since we don't have a scallno to use for an INVAL */\n\t\t/* Process as a mini frame */\n\t\tmemset(&f, 0, sizeof(f));\n\t\tf.frametype = AST_FRAME_VOICE;\n\t\tif (!iaxs[fr->callno]) {\n\t\t\t/* drop it */\n\t\t} else if (iaxs[fr->callno]->voiceformat == 0) {\n\t\t\tast_log(LOG_WARNING, \"Received trunked frame before first full voice frame\\n \");\n\t\t\tiax2_vnak(fr->callno);\n\t\t} else {\n\t\t\tf.subclass = iaxs[fr->callno]->voiceformat;\n\t\t\tf.datalen = len;\n\t\t\tif (f.datalen >= 0) {\n\t\t\t\tif (f.datalen)\n\t\t\t\t\tf.data = ptr;\n\t\t\t\telse\n\t\t\t\t\tf.data = NULL;\n\t\t\t\tif (trunked_ts)\n\t\t\t\t\tfr->ts = (iaxs[fr->callno]->last & 0xFFFF0000L) | (trunked_ts & 0xffff);\n\t\t\t\telse\n\t\t\t\t\tfr->ts = fix_peerts(&rxtrunktime, fr->callno, ts);\n\t\t\t\t/* Don't pass any packets until we're started */\n\t\t\t\tif (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)) {\n\t\t\t\t\tstruct iax_frame *duped_fr;\n\n\t\t\t\t\t/* Common things */\n\t\t\t\t\tf.src = \"IAX2\";\n\t\t\t\t\tf.mallocd = 0;\n\t\t\t\t\tf.offset = 0;\n\t\t\t\t\tif (f.datalen && (f.frametype == AST_FRAME_VOICE)) \n\t\t\t\t\t\tf.samples = ast_codec_get_samples(&f);\n\t\t\t\t\telse\n\t\t\t\t\t\tf.samples = 0;\n\t\t\t\t\tfr->outoforder = 0;\n\t\t\t\t\tiax_frame_wrap(fr, &f);\n\t\t\t\t\tduped_fr = iaxfrdup2(fr);\n\t\t\t\t\tif (duped_fr)\n\t\t\t\t\t\tschedule_delivery(duped_fr, 1, 1, &fr->ts);\n\t\t\t\t\tif (iaxs[fr->callno] && iaxs[fr->callno]->last < fr->ts)\n\t\t\t\t\t\tiaxs[fr->callno]->last = fr->ts;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tast_log(LOG_WARNING, \"Datalen < 0?\\n\");\n\t\t\t}\n\t\t}\n\t\tast_mutex_unlock(&iaxsl[fr->callno]);\n\t\tptr += len;\n\t\tpacket_len -= len;\n\t}\n\n\treturn 1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -66,7 +66,7 @@\n \t\t/* Stop if we don't have enough data */\n \t\tif (len > packet_len)\n \t\t\tbreak;\n-\t\tfr->callno = find_callno_locked(callno & ~IAX_FLAG_FULL, 0, sin, NEW_PREVENT, sockfd);\n+\t\tfr->callno = find_callno_locked(callno & ~IAX_FLAG_FULL, 0, sin, NEW_PREVENT, sockfd, 0);\n \t\tif (!fr->callno)\n \t\t\tcontinue;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tfr->callno = find_callno_locked(callno & ~IAX_FLAG_FULL, 0, sin, NEW_PREVENT, sockfd);"
            ],
            "added_lines": [
                "\t\tfr->callno = find_callno_locked(callno & ~IAX_FLAG_FULL, 0, sin, NEW_PREVENT, sockfd, 0);"
            ]
        }
    },
    {
        "cve_id": "CVE-2008-1897",
        "func_name": "xrg/asterisk-xrg/find_callno_locked",
        "description": "The IAX2 channel driver (chan_iax2) in Asterisk Open Source 1.0.x, 1.2.x before 1.2.28, and 1.4.x before 1.4.19.1; Business Edition A.x.x, B.x.x before B.2.5.2, and C.x.x before C.1.8.1; AsteriskNOW before 1.0.3; Appliance Developer Kit 0.x.x; and s800i before 1.1.0.3, when configured to allow unauthenticated calls, does not verify that an ACK response contains a call number matching the server's reply to a NEW message, which allows remote attackers to cause a denial of service (traffic amplification) via a spoofed ACK response that does not complete a 3-way handshake.  NOTE: this issue exists because of an incomplete fix for CVE-2008-1923.",
        "git_url": "https://github.com/xrg/asterisk-xrg/commit/51714a24347dc57f9a208a4a8af84115ef407b83",
        "commit_title": "Merged revisions 114558 via svnmerge from ",
        "commit_text": "https://origsvn.digium.com/svn/asterisk/branches/1.4  ........ r114558 | russell | 2008-04-22 17:15:36 -0500 (Tue, 22 Apr 2008) | 5 lines  When we receive a full frame that is supposed to contain our call number, ensure that it has the correct one. (closes issue #10078) (AST-2008-006)  ........",
        "func_before": "static int find_callno_locked(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd) {\n\n\treturn __find_callno(callno, dcallno, sin, new, sockfd, 1);\n}",
        "func": "static int find_callno_locked(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int full_frame) {\n\n\treturn __find_callno(callno, dcallno, sin, new, sockfd, 1, full_frame);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,4 @@\n-static int find_callno_locked(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd) {\n+static int find_callno_locked(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int full_frame) {\n \n-\treturn __find_callno(callno, dcallno, sin, new, sockfd, 1);\n+\treturn __find_callno(callno, dcallno, sin, new, sockfd, 1, full_frame);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "static int find_callno_locked(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd) {",
                "\treturn __find_callno(callno, dcallno, sin, new, sockfd, 1);"
            ],
            "added_lines": [
                "static int find_callno_locked(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int full_frame) {",
                "\treturn __find_callno(callno, dcallno, sin, new, sockfd, 1, full_frame);"
            ]
        }
    },
    {
        "cve_id": "CVE-2008-1897",
        "func_name": "xrg/asterisk-xrg/iax2_request",
        "description": "The IAX2 channel driver (chan_iax2) in Asterisk Open Source 1.0.x, 1.2.x before 1.2.28, and 1.4.x before 1.4.19.1; Business Edition A.x.x, B.x.x before B.2.5.2, and C.x.x before C.1.8.1; AsteriskNOW before 1.0.3; Appliance Developer Kit 0.x.x; and s800i before 1.1.0.3, when configured to allow unauthenticated calls, does not verify that an ACK response contains a call number matching the server's reply to a NEW message, which allows remote attackers to cause a denial of service (traffic amplification) via a spoofed ACK response that does not complete a 3-way handshake.  NOTE: this issue exists because of an incomplete fix for CVE-2008-1923.",
        "git_url": "https://github.com/xrg/asterisk-xrg/commit/51714a24347dc57f9a208a4a8af84115ef407b83",
        "commit_title": "Merged revisions 114558 via svnmerge from ",
        "commit_text": "https://origsvn.digium.com/svn/asterisk/branches/1.4  ........ r114558 | russell | 2008-04-22 17:15:36 -0500 (Tue, 22 Apr 2008) | 5 lines  When we receive a full frame that is supposed to contain our call number, ensure that it has the correct one. (closes issue #10078) (AST-2008-006)  ........",
        "func_before": "static struct ast_channel *iax2_request(const char *type, int format, void *data, int *cause)\n{\n\tint callno;\n\tint res;\n\tint fmt, native;\n\tstruct sockaddr_in sin;\n\tstruct ast_channel *c;\n\tstruct parsed_dial_string pds;\n\tstruct create_addr_info cai;\n\tchar *tmpstr;\n\n\tmemset(&pds, 0, sizeof(pds));\n\ttmpstr = ast_strdupa(data);\n\tparse_dial_string(tmpstr, &pds);\n\n\tif (ast_strlen_zero(pds.peer)) {\n\t\tast_log(LOG_WARNING, \"No peer provided in the IAX2 dial string '%s'\\n\", (char *) data);\n\t\treturn NULL;\n\t}\n\t       \n\tmemset(&cai, 0, sizeof(cai));\n\tcai.capability = iax2_capability;\n\n\tast_copy_flags(&cai, &globalflags, IAX_NOTRANSFER | IAX_TRANSFERMEDIA | IAX_USEJITTERBUF | IAX_FORCEJITTERBUF);\n\t\n\t/* Populate our address from the given */\n\tif (create_addr(pds.peer, NULL, &sin, &cai)) {\n\t\t*cause = AST_CAUSE_UNREGISTERED;\n\t\treturn NULL;\n\t}\n\n\tif (pds.port)\n\t\tsin.sin_port = htons(atoi(pds.port));\n\n\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd);\n\tif (callno < 1) {\n\t\tast_log(LOG_WARNING, \"Unable to create call\\n\");\n\t\t*cause = AST_CAUSE_CONGESTION;\n\t\treturn NULL;\n\t}\n\n\t/* If this is a trunk, update it now */\n\tast_copy_flags(iaxs[callno], &cai, IAX_TRUNK | IAX_SENDANI | IAX_NOTRANSFER | IAX_TRANSFERMEDIA | IAX_USEJITTERBUF | IAX_FORCEJITTERBUF);\t\n\tif (ast_test_flag(&cai, IAX_TRUNK)) {\n\t\tint new_callno;\n\t\tif ((new_callno = make_trunk(callno, 1)) != -1)\n\t\t\tcallno = new_callno;\n\t}\n\tiaxs[callno]->maxtime = cai.maxtime;\n\tif (cai.found)\n\t\tast_string_field_set(iaxs[callno], host, pds.peer);\n\n\tc = ast_iax2_new(callno, AST_STATE_DOWN, cai.capability);\n\n\tast_mutex_unlock(&iaxsl[callno]);\n\n\tif (c) {\n\t\t/* Choose a format we can live with */\n\t\tif (c->nativeformats & format) \n\t\t\tc->nativeformats &= format;\n\t\telse {\n\t\t\tnative = c->nativeformats;\n\t\t\tfmt = format;\n\t\t\tres = ast_translator_best_choice(&fmt, &native);\n\t\t\tif (res < 0) {\n\t\t\t\tast_log(LOG_WARNING, \"Unable to create translator path for %s to %s on %s\\n\",\n\t\t\t\t\tast_getformatname(c->nativeformats), ast_getformatname(fmt), c->name);\n\t\t\t\tast_hangup(c);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tc->nativeformats = native;\n\t\t}\n\t\tc->readformat = ast_best_codec(c->nativeformats);\n\t\tc->writeformat = c->readformat;\n\t}\n\n\treturn c;\n}",
        "func": "static struct ast_channel *iax2_request(const char *type, int format, void *data, int *cause)\n{\n\tint callno;\n\tint res;\n\tint fmt, native;\n\tstruct sockaddr_in sin;\n\tstruct ast_channel *c;\n\tstruct parsed_dial_string pds;\n\tstruct create_addr_info cai;\n\tchar *tmpstr;\n\n\tmemset(&pds, 0, sizeof(pds));\n\ttmpstr = ast_strdupa(data);\n\tparse_dial_string(tmpstr, &pds);\n\n\tif (ast_strlen_zero(pds.peer)) {\n\t\tast_log(LOG_WARNING, \"No peer provided in the IAX2 dial string '%s'\\n\", (char *) data);\n\t\treturn NULL;\n\t}\n\t       \n\tmemset(&cai, 0, sizeof(cai));\n\tcai.capability = iax2_capability;\n\n\tast_copy_flags(&cai, &globalflags, IAX_NOTRANSFER | IAX_TRANSFERMEDIA | IAX_USEJITTERBUF | IAX_FORCEJITTERBUF);\n\t\n\t/* Populate our address from the given */\n\tif (create_addr(pds.peer, NULL, &sin, &cai)) {\n\t\t*cause = AST_CAUSE_UNREGISTERED;\n\t\treturn NULL;\n\t}\n\n\tif (pds.port)\n\t\tsin.sin_port = htons(atoi(pds.port));\n\n\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd, 0);\n\tif (callno < 1) {\n\t\tast_log(LOG_WARNING, \"Unable to create call\\n\");\n\t\t*cause = AST_CAUSE_CONGESTION;\n\t\treturn NULL;\n\t}\n\n\t/* If this is a trunk, update it now */\n\tast_copy_flags(iaxs[callno], &cai, IAX_TRUNK | IAX_SENDANI | IAX_NOTRANSFER | IAX_TRANSFERMEDIA | IAX_USEJITTERBUF | IAX_FORCEJITTERBUF);\t\n\tif (ast_test_flag(&cai, IAX_TRUNK)) {\n\t\tint new_callno;\n\t\tif ((new_callno = make_trunk(callno, 1)) != -1)\n\t\t\tcallno = new_callno;\n\t}\n\tiaxs[callno]->maxtime = cai.maxtime;\n\tif (cai.found)\n\t\tast_string_field_set(iaxs[callno], host, pds.peer);\n\n\tc = ast_iax2_new(callno, AST_STATE_DOWN, cai.capability);\n\n\tast_mutex_unlock(&iaxsl[callno]);\n\n\tif (c) {\n\t\t/* Choose a format we can live with */\n\t\tif (c->nativeformats & format) \n\t\t\tc->nativeformats &= format;\n\t\telse {\n\t\t\tnative = c->nativeformats;\n\t\t\tfmt = format;\n\t\t\tres = ast_translator_best_choice(&fmt, &native);\n\t\t\tif (res < 0) {\n\t\t\t\tast_log(LOG_WARNING, \"Unable to create translator path for %s to %s on %s\\n\",\n\t\t\t\t\tast_getformatname(c->nativeformats), ast_getformatname(fmt), c->name);\n\t\t\t\tast_hangup(c);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tc->nativeformats = native;\n\t\t}\n\t\tc->readformat = ast_best_codec(c->nativeformats);\n\t\tc->writeformat = c->readformat;\n\t}\n\n\treturn c;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -32,7 +32,7 @@\n \tif (pds.port)\n \t\tsin.sin_port = htons(atoi(pds.port));\n \n-\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd);\n+\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd, 0);\n \tif (callno < 1) {\n \t\tast_log(LOG_WARNING, \"Unable to create call\\n\");\n \t\t*cause = AST_CAUSE_CONGESTION;",
        "diff_line_info": {
            "deleted_lines": [
                "\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd);"
            ],
            "added_lines": [
                "\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd, 0);"
            ]
        }
    },
    {
        "cve_id": "CVE-2008-1897",
        "func_name": "xrg/asterisk-xrg/__find_callno",
        "description": "The IAX2 channel driver (chan_iax2) in Asterisk Open Source 1.0.x, 1.2.x before 1.2.28, and 1.4.x before 1.4.19.1; Business Edition A.x.x, B.x.x before B.2.5.2, and C.x.x before C.1.8.1; AsteriskNOW before 1.0.3; Appliance Developer Kit 0.x.x; and s800i before 1.1.0.3, when configured to allow unauthenticated calls, does not verify that an ACK response contains a call number matching the server's reply to a NEW message, which allows remote attackers to cause a denial of service (traffic amplification) via a spoofed ACK response that does not complete a 3-way handshake.  NOTE: this issue exists because of an incomplete fix for CVE-2008-1923.",
        "git_url": "https://github.com/xrg/asterisk-xrg/commit/51714a24347dc57f9a208a4a8af84115ef407b83",
        "commit_title": "Merged revisions 114558 via svnmerge from ",
        "commit_text": "https://origsvn.digium.com/svn/asterisk/branches/1.4  ........ r114558 | russell | 2008-04-22 17:15:36 -0500 (Tue, 22 Apr 2008) | 5 lines  When we receive a full frame that is supposed to contain our call number, ensure that it has the correct one. (closes issue #10078) (AST-2008-006)  ........",
        "func_before": "static int __find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int return_locked)\n{\n\tint res = 0;\n\tint x;\n\tstruct timeval now;\n\tchar host[80];\n\n\tif (new <= NEW_ALLOW) {\n\t\tfor (x=1;(res < 1) && (x<maxnontrunkcall);x++) {\n\t\t\tast_mutex_lock(&iaxsl[x]);\n\t\t\tif (iaxs[x]) {\n\t\t\t\t/* Look for an exact match */\n\t\t\t\tif (match(sin, callno, dcallno, iaxs[x])) {\n\t\t\t\t\tres = x;\n\t\t\t\t}\n\t\t\t}\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t}\n\t\tfor (x=TRUNK_CALL_START;(res < 1) && (x<maxtrunkcall);x++) {\n\t\t\tast_mutex_lock(&iaxsl[x]);\n\t\t\tif (iaxs[x]) {\n\t\t\t\t/* Look for an exact match */\n\t\t\t\tif (match(sin, callno, dcallno, iaxs[x])) {\n\t\t\t\t\tres = x;\n\t\t\t\t}\n\t\t\t}\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t}\n\t}\n\tif ((res < 1) && (new >= NEW_ALLOW)) {\n\t\t/* It may seem odd that we look through the peer list for a name for\n\t\t * this *incoming* call.  Well, it is weird.  However, users don't\n\t\t * have an IP address/port number that we can match against.  So,\n\t\t * this is just checking for a peer that has that IP/port and\n\t\t * assuming that we have a user of the same name.  This isn't always\n\t\t * correct, but it will be changed if needed after authentication. */\n\t\tif (!iax2_getpeername(*sin, host, sizeof(host)))\n\t\t\tsnprintf(host, sizeof(host), \"%s:%d\", ast_inet_ntoa(sin->sin_addr), ntohs(sin->sin_port));\n\t\tnow = ast_tvnow();\n\t\tfor (x=1;x<TRUNK_CALL_START;x++) {\n\t\t\t/* Find first unused call number that hasn't been used in a while */\n\t\t\tast_mutex_lock(&iaxsl[x]);\n\t\t\tif (!iaxs[x] && ((now.tv_sec - lastused[x].tv_sec) > MIN_REUSE_TIME)) break;\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t}\n\t\t/* We've still got lock held if we found a spot */\n\t\tif (x >= TRUNK_CALL_START) {\n\t\t\tast_log(LOG_WARNING, \"No more space\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tiaxs[x] = new_iax(sin, host);\n\t\tupdate_max_nontrunk();\n\t\tif (iaxs[x]) {\n\t\t\tif (iaxdebug)\n\t\t\t\tast_debug(1, \"Creating new call structure %d\\n\", x);\n\t\t\tiaxs[x]->sockfd = sockfd;\n\t\t\tiaxs[x]->addr.sin_port = sin->sin_port;\n\t\t\tiaxs[x]->addr.sin_family = sin->sin_family;\n\t\t\tiaxs[x]->addr.sin_addr.s_addr = sin->sin_addr.s_addr;\n\t\t\tiaxs[x]->peercallno = callno;\n\t\t\tiaxs[x]->callno = x;\n\t\t\tiaxs[x]->pingtime = DEFAULT_RETRY_TIME;\n\t\t\tiaxs[x]->expiry = min_reg_expire;\n\t\t\tiaxs[x]->pingid = iax2_sched_add(sched, ping_time * 1000, send_ping, (void *)(long)x);\n\t\t\tiaxs[x]->lagid = iax2_sched_add(sched, lagrq_time * 1000, send_lagrq, (void *)(long)x);\n\t\t\tiaxs[x]->amaflags = amaflags;\n\t\t\tast_copy_flags(iaxs[x], (&globalflags), IAX_NOTRANSFER | IAX_TRANSFERMEDIA | IAX_USEJITTERBUF | IAX_FORCEJITTERBUF);\n\t\t\t\n\t\t\tast_string_field_set(iaxs[x], accountcode, accountcode);\n\t\t\tast_string_field_set(iaxs[x], mohinterpret, mohinterpret);\n\t\t\tast_string_field_set(iaxs[x], mohsuggest, mohsuggest);\n\t\t\tast_string_field_set(iaxs[x], parkinglot, default_parkinglot);\n\t\t} else {\n\t\t\tast_log(LOG_WARNING, \"Out of resources\\n\");\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t\treturn 0;\n\t\t}\n\t\tif (!return_locked)\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\tres = x;\n\t}\n\treturn res;\n}",
        "func": "static int __find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int return_locked, int full_frame)\n{\n\tint res = 0;\n\tint x;\n\tstruct timeval now;\n\tchar host[80];\n\n\tif (new <= NEW_ALLOW) {\n\t\tfor (x=1;(res < 1) && (x<maxnontrunkcall);x++) {\n\t\t\tast_mutex_lock(&iaxsl[x]);\n\t\t\tif (iaxs[x]) {\n\t\t\t\t/* Look for an exact match */\n\t\t\t\tif (match(sin, callno, dcallno, iaxs[x], full_frame)) {\n\t\t\t\t\tres = x;\n\t\t\t\t}\n\t\t\t}\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t}\n\t\tfor (x=TRUNK_CALL_START;(res < 1) && (x<maxtrunkcall);x++) {\n\t\t\tast_mutex_lock(&iaxsl[x]);\n\t\t\tif (iaxs[x]) {\n\t\t\t\t/* Look for an exact match */\n\t\t\t\tif (match(sin, callno, dcallno, iaxs[x], full_frame)) {\n\t\t\t\t\tres = x;\n\t\t\t\t}\n\t\t\t}\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t}\n\t}\n\tif ((res < 1) && (new >= NEW_ALLOW)) {\n\t\tint start, found = 0;\n\n\t\t/* It may seem odd that we look through the peer list for a name for\n\t\t * this *incoming* call.  Well, it is weird.  However, users don't\n\t\t * have an IP address/port number that we can match against.  So,\n\t\t * this is just checking for a peer that has that IP/port and\n\t\t * assuming that we have a user of the same name.  This isn't always\n\t\t * correct, but it will be changed if needed after authentication. */\n\t\tif (!iax2_getpeername(*sin, host, sizeof(host)))\n\t\t\tsnprintf(host, sizeof(host), \"%s:%d\", ast_inet_ntoa(sin->sin_addr), ntohs(sin->sin_port));\n\n\t\tnow = ast_tvnow();\n\t\tstart = 1 + (ast_random() % (TRUNK_CALL_START - 1));\n\t\tfor (x = start; 1; x++) {\n\t\t\tif (x == TRUNK_CALL_START) {\n\t\t\t\tx = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* Find first unused call number that hasn't been used in a while */\n\t\t\tast_mutex_lock(&iaxsl[x]);\n\t\t\tif (!iaxs[x] && ((now.tv_sec - lastused[x].tv_sec) > MIN_REUSE_TIME)) {\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t\t\n\t\t\tif (x == start - 1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/* We've still got lock held if we found a spot */\n\t\tif (x == start - 1 && !found) {\n\t\t\tast_log(LOG_WARNING, \"No more space\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tiaxs[x] = new_iax(sin, host);\n\t\tupdate_max_nontrunk();\n\t\tif (iaxs[x]) {\n\t\t\tif (iaxdebug)\n\t\t\t\tast_debug(1, \"Creating new call structure %d\\n\", x);\n\t\t\tiaxs[x]->sockfd = sockfd;\n\t\t\tiaxs[x]->addr.sin_port = sin->sin_port;\n\t\t\tiaxs[x]->addr.sin_family = sin->sin_family;\n\t\t\tiaxs[x]->addr.sin_addr.s_addr = sin->sin_addr.s_addr;\n\t\t\tiaxs[x]->peercallno = callno;\n\t\t\tiaxs[x]->callno = x;\n\t\t\tiaxs[x]->pingtime = DEFAULT_RETRY_TIME;\n\t\t\tiaxs[x]->expiry = min_reg_expire;\n\t\t\tiaxs[x]->pingid = iax2_sched_add(sched, ping_time * 1000, send_ping, (void *)(long)x);\n\t\t\tiaxs[x]->lagid = iax2_sched_add(sched, lagrq_time * 1000, send_lagrq, (void *)(long)x);\n\t\t\tiaxs[x]->amaflags = amaflags;\n\t\t\tast_copy_flags(iaxs[x], (&globalflags), IAX_NOTRANSFER | IAX_TRANSFERMEDIA | IAX_USEJITTERBUF | IAX_FORCEJITTERBUF);\n\t\t\t\n\t\t\tast_string_field_set(iaxs[x], accountcode, accountcode);\n\t\t\tast_string_field_set(iaxs[x], mohinterpret, mohinterpret);\n\t\t\tast_string_field_set(iaxs[x], mohsuggest, mohsuggest);\n\t\t\tast_string_field_set(iaxs[x], parkinglot, default_parkinglot);\n\t\t} else {\n\t\t\tast_log(LOG_WARNING, \"Out of resources\\n\");\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t\treturn 0;\n\t\t}\n\t\tif (!return_locked)\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\tres = x;\n\t}\n\treturn res;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,4 @@\n-static int __find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int return_locked)\n+static int __find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int return_locked, int full_frame)\n {\n \tint res = 0;\n \tint x;\n@@ -10,7 +10,7 @@\n \t\t\tast_mutex_lock(&iaxsl[x]);\n \t\t\tif (iaxs[x]) {\n \t\t\t\t/* Look for an exact match */\n-\t\t\t\tif (match(sin, callno, dcallno, iaxs[x])) {\n+\t\t\t\tif (match(sin, callno, dcallno, iaxs[x], full_frame)) {\n \t\t\t\t\tres = x;\n \t\t\t\t}\n \t\t\t}\n@@ -20,7 +20,7 @@\n \t\t\tast_mutex_lock(&iaxsl[x]);\n \t\t\tif (iaxs[x]) {\n \t\t\t\t/* Look for an exact match */\n-\t\t\t\tif (match(sin, callno, dcallno, iaxs[x])) {\n+\t\t\t\tif (match(sin, callno, dcallno, iaxs[x], full_frame)) {\n \t\t\t\t\tres = x;\n \t\t\t\t}\n \t\t\t}\n@@ -28,6 +28,8 @@\n \t\t}\n \t}\n \tif ((res < 1) && (new >= NEW_ALLOW)) {\n+\t\tint start, found = 0;\n+\n \t\t/* It may seem odd that we look through the peer list for a name for\n \t\t * this *incoming* call.  Well, it is weird.  However, users don't\n \t\t * have an IP address/port number that we can match against.  So,\n@@ -36,15 +38,29 @@\n \t\t * correct, but it will be changed if needed after authentication. */\n \t\tif (!iax2_getpeername(*sin, host, sizeof(host)))\n \t\t\tsnprintf(host, sizeof(host), \"%s:%d\", ast_inet_ntoa(sin->sin_addr), ntohs(sin->sin_port));\n+\n \t\tnow = ast_tvnow();\n-\t\tfor (x=1;x<TRUNK_CALL_START;x++) {\n+\t\tstart = 1 + (ast_random() % (TRUNK_CALL_START - 1));\n+\t\tfor (x = start; 1; x++) {\n+\t\t\tif (x == TRUNK_CALL_START) {\n+\t\t\t\tx = 0;\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\n \t\t\t/* Find first unused call number that hasn't been used in a while */\n \t\t\tast_mutex_lock(&iaxsl[x]);\n-\t\t\tif (!iaxs[x] && ((now.tv_sec - lastused[x].tv_sec) > MIN_REUSE_TIME)) break;\n+\t\t\tif (!iaxs[x] && ((now.tv_sec - lastused[x].tv_sec) > MIN_REUSE_TIME)) {\n+\t\t\t\tfound = 1;\n+\t\t\t\tbreak;\n+\t\t\t}\n \t\t\tast_mutex_unlock(&iaxsl[x]);\n+\t\t\t\n+\t\t\tif (x == start - 1) {\n+\t\t\t\tbreak;\n+\t\t\t}\n \t\t}\n \t\t/* We've still got lock held if we found a spot */\n-\t\tif (x >= TRUNK_CALL_START) {\n+\t\tif (x == start - 1 && !found) {\n \t\t\tast_log(LOG_WARNING, \"No more space\\n\");\n \t\t\treturn 0;\n \t\t}",
        "diff_line_info": {
            "deleted_lines": [
                "static int __find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int return_locked)",
                "\t\t\t\tif (match(sin, callno, dcallno, iaxs[x])) {",
                "\t\t\t\tif (match(sin, callno, dcallno, iaxs[x])) {",
                "\t\tfor (x=1;x<TRUNK_CALL_START;x++) {",
                "\t\t\tif (!iaxs[x] && ((now.tv_sec - lastused[x].tv_sec) > MIN_REUSE_TIME)) break;",
                "\t\tif (x >= TRUNK_CALL_START) {"
            ],
            "added_lines": [
                "static int __find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int return_locked, int full_frame)",
                "\t\t\t\tif (match(sin, callno, dcallno, iaxs[x], full_frame)) {",
                "\t\t\t\tif (match(sin, callno, dcallno, iaxs[x], full_frame)) {",
                "\t\tint start, found = 0;",
                "",
                "",
                "\t\tstart = 1 + (ast_random() % (TRUNK_CALL_START - 1));",
                "\t\tfor (x = start; 1; x++) {",
                "\t\t\tif (x == TRUNK_CALL_START) {",
                "\t\t\t\tx = 0;",
                "\t\t\t\tcontinue;",
                "\t\t\t}",
                "",
                "\t\t\tif (!iaxs[x] && ((now.tv_sec - lastused[x].tv_sec) > MIN_REUSE_TIME)) {",
                "\t\t\t\tfound = 1;",
                "\t\t\t\tbreak;",
                "\t\t\t}",
                "\t\t\t",
                "\t\t\tif (x == start - 1) {",
                "\t\t\t\tbreak;",
                "\t\t\t}",
                "\t\tif (x == start - 1 && !found) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2008-1897",
        "func_name": "jcollie/asterisk/find_callno",
        "description": "The IAX2 channel driver (chan_iax2) in Asterisk Open Source 1.0.x, 1.2.x before 1.2.28, and 1.4.x before 1.4.19.1; Business Edition A.x.x, B.x.x before B.2.5.2, and C.x.x before C.1.8.1; AsteriskNOW before 1.0.3; Appliance Developer Kit 0.x.x; and s800i before 1.1.0.3, when configured to allow unauthenticated calls, does not verify that an ACK response contains a call number matching the server's reply to a NEW message, which allows remote attackers to cause a denial of service (traffic amplification) via a spoofed ACK response that does not complete a 3-way handshake.  NOTE: this issue exists because of an incomplete fix for CVE-2008-1923.",
        "git_url": "https://github.com/jcollie/asterisk/commit/60de4fbbdf3ede49f158e23a9e3b679f2e519c1e",
        "commit_title": "Merged revisions 114558 via svnmerge from ",
        "commit_text": "https://origsvn.digium.com/svn/asterisk/branches/1.4  ........ r114558 | russell | 2008-04-22 17:15:36 -0500 (Tue, 22 Apr 2008) | 5 lines  When we receive a full frame that is supposed to contain our call number, ensure that it has the correct one. (closes issue #10078) (AST-2008-006)  ........  ",
        "func_before": "static int find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd) {\n\n\treturn __find_callno(callno, dcallno, sin, new, sockfd, 0);\n}",
        "func": "static int find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int full_frame) {\n\n\treturn __find_callno(callno, dcallno, sin, new, sockfd, 0, full_frame);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,4 @@\n-static int find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd) {\n+static int find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int full_frame) {\n \n-\treturn __find_callno(callno, dcallno, sin, new, sockfd, 0);\n+\treturn __find_callno(callno, dcallno, sin, new, sockfd, 0, full_frame);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "static int find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd) {",
                "\treturn __find_callno(callno, dcallno, sin, new, sockfd, 0);"
            ],
            "added_lines": [
                "static int find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int full_frame) {",
                "\treturn __find_callno(callno, dcallno, sin, new, sockfd, 0, full_frame);"
            ]
        }
    },
    {
        "cve_id": "CVE-2008-1897",
        "func_name": "jcollie/asterisk/iax2_do_register",
        "description": "The IAX2 channel driver (chan_iax2) in Asterisk Open Source 1.0.x, 1.2.x before 1.2.28, and 1.4.x before 1.4.19.1; Business Edition A.x.x, B.x.x before B.2.5.2, and C.x.x before C.1.8.1; AsteriskNOW before 1.0.3; Appliance Developer Kit 0.x.x; and s800i before 1.1.0.3, when configured to allow unauthenticated calls, does not verify that an ACK response contains a call number matching the server's reply to a NEW message, which allows remote attackers to cause a denial of service (traffic amplification) via a spoofed ACK response that does not complete a 3-way handshake.  NOTE: this issue exists because of an incomplete fix for CVE-2008-1923.",
        "git_url": "https://github.com/jcollie/asterisk/commit/60de4fbbdf3ede49f158e23a9e3b679f2e519c1e",
        "commit_title": "Merged revisions 114558 via svnmerge from ",
        "commit_text": "https://origsvn.digium.com/svn/asterisk/branches/1.4  ........ r114558 | russell | 2008-04-22 17:15:36 -0500 (Tue, 22 Apr 2008) | 5 lines  When we receive a full frame that is supposed to contain our call number, ensure that it has the correct one. (closes issue #10078) (AST-2008-006)  ........  ",
        "func_before": "static int iax2_do_register(struct iax2_registry *reg)\n{\n\tstruct iax_ie_data ied;\n\tif (iaxdebug)\n\t\tast_debug(1, \"Sending registration request for '%s'\\n\", reg->username);\n\n\tif (reg->dnsmgr && \n\t    ((reg->regstate == REG_STATE_TIMEOUT) || !reg->addr.sin_addr.s_addr)) {\n\t\t/* Maybe the IP has changed, force DNS refresh */\n\t\tast_dnsmgr_refresh(reg->dnsmgr);\n\t}\n\t\n\t/*\n\t * if IP has Changed, free allocated call to create a new one with new IP\n\t * call has the pointer to IP and must be updated to the new one\n\t */\n\tif (reg->dnsmgr && ast_dnsmgr_changed(reg->dnsmgr) && (reg->callno > 0)) {\n\t\tast_mutex_lock(&iaxsl[reg->callno]);\n\t\tiax2_destroy(reg->callno);\n\t\tast_mutex_unlock(&iaxsl[reg->callno]);\n\t\treg->callno = 0;\n\t}\n\tif (!reg->addr.sin_addr.s_addr) {\n\t\tif (iaxdebug)\n\t\t\tast_debug(1, \"Unable to send registration request for '%s' without IP address\\n\", reg->username);\n\t\t/* Setup the next registration attempt */\n\t\treg->expire = iax2_sched_replace(reg->expire, sched, \n\t\t\t(5 * reg->refresh / 6) * 1000, iax2_do_register_s, reg);\n\t\treturn -1;\n\t}\n\n\tif (!reg->callno) {\n\t\tast_debug(1, \"Allocate call number\\n\");\n\t\treg->callno = find_callno_locked(0, 0, &reg->addr, NEW_FORCE, defaultsockfd);\n\t\tif (reg->callno < 1) {\n\t\t\tast_log(LOG_WARNING, \"Unable to create call for registration\\n\");\n\t\t\treturn -1;\n\t\t} else\n\t\t\tast_debug(1, \"Registration created on call %d\\n\", reg->callno);\n\t\tiaxs[reg->callno]->reg = reg;\n\t\tast_mutex_unlock(&iaxsl[reg->callno]);\n\t}\n\t/* Setup the next registration a little early */\n\treg->expire = iax2_sched_replace(reg->expire, sched, \n\t\t(5 * reg->refresh / 6) * 1000, iax2_do_register_s, reg);\n\t/* Send the request */\n\tmemset(&ied, 0, sizeof(ied));\n\tiax_ie_append_str(&ied, IAX_IE_USERNAME, reg->username);\n\tiax_ie_append_short(&ied, IAX_IE_REFRESH, reg->refresh);\n\tsend_command(iaxs[reg->callno],AST_FRAME_IAX, IAX_COMMAND_REGREQ, 0, ied.buf, ied.pos, -1);\n\treg->regstate = REG_STATE_REGSENT;\n\treturn 0;\n}",
        "func": "static int iax2_do_register(struct iax2_registry *reg)\n{\n\tstruct iax_ie_data ied;\n\tif (iaxdebug)\n\t\tast_debug(1, \"Sending registration request for '%s'\\n\", reg->username);\n\n\tif (reg->dnsmgr && \n\t    ((reg->regstate == REG_STATE_TIMEOUT) || !reg->addr.sin_addr.s_addr)) {\n\t\t/* Maybe the IP has changed, force DNS refresh */\n\t\tast_dnsmgr_refresh(reg->dnsmgr);\n\t}\n\t\n\t/*\n\t * if IP has Changed, free allocated call to create a new one with new IP\n\t * call has the pointer to IP and must be updated to the new one\n\t */\n\tif (reg->dnsmgr && ast_dnsmgr_changed(reg->dnsmgr) && (reg->callno > 0)) {\n\t\tast_mutex_lock(&iaxsl[reg->callno]);\n\t\tiax2_destroy(reg->callno);\n\t\tast_mutex_unlock(&iaxsl[reg->callno]);\n\t\treg->callno = 0;\n\t}\n\tif (!reg->addr.sin_addr.s_addr) {\n\t\tif (iaxdebug)\n\t\t\tast_debug(1, \"Unable to send registration request for '%s' without IP address\\n\", reg->username);\n\t\t/* Setup the next registration attempt */\n\t\treg->expire = iax2_sched_replace(reg->expire, sched, \n\t\t\t(5 * reg->refresh / 6) * 1000, iax2_do_register_s, reg);\n\t\treturn -1;\n\t}\n\n\tif (!reg->callno) {\n\t\tast_debug(1, \"Allocate call number\\n\");\n\t\treg->callno = find_callno_locked(0, 0, &reg->addr, NEW_FORCE, defaultsockfd, 0);\n\t\tif (reg->callno < 1) {\n\t\t\tast_log(LOG_WARNING, \"Unable to create call for registration\\n\");\n\t\t\treturn -1;\n\t\t} else\n\t\t\tast_debug(1, \"Registration created on call %d\\n\", reg->callno);\n\t\tiaxs[reg->callno]->reg = reg;\n\t\tast_mutex_unlock(&iaxsl[reg->callno]);\n\t}\n\t/* Setup the next registration a little early */\n\treg->expire = iax2_sched_replace(reg->expire, sched, \n\t\t(5 * reg->refresh / 6) * 1000, iax2_do_register_s, reg);\n\t/* Send the request */\n\tmemset(&ied, 0, sizeof(ied));\n\tiax_ie_append_str(&ied, IAX_IE_USERNAME, reg->username);\n\tiax_ie_append_short(&ied, IAX_IE_REFRESH, reg->refresh);\n\tsend_command(iaxs[reg->callno],AST_FRAME_IAX, IAX_COMMAND_REGREQ, 0, ied.buf, ied.pos, -1);\n\treg->regstate = REG_STATE_REGSENT;\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -31,7 +31,7 @@\n \n \tif (!reg->callno) {\n \t\tast_debug(1, \"Allocate call number\\n\");\n-\t\treg->callno = find_callno_locked(0, 0, &reg->addr, NEW_FORCE, defaultsockfd);\n+\t\treg->callno = find_callno_locked(0, 0, &reg->addr, NEW_FORCE, defaultsockfd, 0);\n \t\tif (reg->callno < 1) {\n \t\t\tast_log(LOG_WARNING, \"Unable to create call for registration\\n\");\n \t\t\treturn -1;",
        "diff_line_info": {
            "deleted_lines": [
                "\t\treg->callno = find_callno_locked(0, 0, &reg->addr, NEW_FORCE, defaultsockfd);"
            ],
            "added_lines": [
                "\t\treg->callno = find_callno_locked(0, 0, &reg->addr, NEW_FORCE, defaultsockfd, 0);"
            ]
        }
    },
    {
        "cve_id": "CVE-2008-1897",
        "func_name": "jcollie/asterisk/iax2_poke_peer",
        "description": "The IAX2 channel driver (chan_iax2) in Asterisk Open Source 1.0.x, 1.2.x before 1.2.28, and 1.4.x before 1.4.19.1; Business Edition A.x.x, B.x.x before B.2.5.2, and C.x.x before C.1.8.1; AsteriskNOW before 1.0.3; Appliance Developer Kit 0.x.x; and s800i before 1.1.0.3, when configured to allow unauthenticated calls, does not verify that an ACK response contains a call number matching the server's reply to a NEW message, which allows remote attackers to cause a denial of service (traffic amplification) via a spoofed ACK response that does not complete a 3-way handshake.  NOTE: this issue exists because of an incomplete fix for CVE-2008-1923.",
        "git_url": "https://github.com/jcollie/asterisk/commit/60de4fbbdf3ede49f158e23a9e3b679f2e519c1e",
        "commit_title": "Merged revisions 114558 via svnmerge from ",
        "commit_text": "https://origsvn.digium.com/svn/asterisk/branches/1.4  ........ r114558 | russell | 2008-04-22 17:15:36 -0500 (Tue, 22 Apr 2008) | 5 lines  When we receive a full frame that is supposed to contain our call number, ensure that it has the correct one. (closes issue #10078) (AST-2008-006)  ........  ",
        "func_before": "static int iax2_poke_peer(struct iax2_peer *peer, int heldcall)\n{\n\tif (!peer->maxms || (!peer->addr.sin_addr.s_addr && !peer->dnsmgr)) {\n\t\t/* IF we have no IP without dnsmgr, or this isn't to be monitored, return\n\t\t  immediately after clearing things out */\n\t\tpeer->lastms = 0;\n\t\tpeer->historicms = 0;\n\t\tpeer->pokeexpire = -1;\n\t\tpeer->callno = 0;\n\t\treturn 0;\n\t}\n\tif (peer->callno > 0) {\n\t\tast_log(LOG_NOTICE, \"Still have a callno...\\n\");\n\t\tast_mutex_lock(&iaxsl[peer->callno]);\n\t\tiax2_destroy(peer->callno);\n\t\tast_mutex_unlock(&iaxsl[peer->callno]);\n\t}\n\tif (heldcall)\n\t\tast_mutex_unlock(&iaxsl[heldcall]);\n\tpeer->callno = find_callno(0, 0, &peer->addr, NEW_FORCE, peer->sockfd);\n\tif (heldcall)\n\t\tast_mutex_lock(&iaxsl[heldcall]);\n\tif (peer->callno < 1) {\n\t\tast_log(LOG_WARNING, \"Unable to allocate call for poking peer '%s'\\n\", peer->name);\n\t\treturn -1;\n\t}\n\n\t/* Speed up retransmission times for this qualify call */\n\tiaxs[peer->callno]->pingtime = peer->maxms / 4 + 1;\n\tiaxs[peer->callno]->peerpoke = peer;\n\n \tif (peer->pokeexpire > -1) {\n \t\tif (!ast_sched_del(sched, peer->pokeexpire)) {\n \t\t\tpeer->pokeexpire = -1;\n \t\t\tpeer_unref(peer);\n \t\t}\n \t}\n \n\t/* Queue up a new task to handle no reply */\n\t/* If the host is already unreachable then use the unreachable interval instead */\n\tif (peer->lastms < 0)\n \t\tpeer->pokeexpire = iax2_sched_add(sched, peer->pokefreqnotok, iax2_poke_noanswer, peer_ref(peer));\n\telse\n \t\tpeer->pokeexpire = iax2_sched_add(sched, DEFAULT_MAXMS * 2, iax2_poke_noanswer, peer_ref(peer));\n\n \tif (peer->pokeexpire == -1)\n \t\tpeer_unref(peer);\n\n\t/* And send the poke */\n\tsend_command(iaxs[peer->callno], AST_FRAME_IAX, IAX_COMMAND_POKE, 0, NULL, 0, -1);\n\n\treturn 0;\n}",
        "func": "static int iax2_poke_peer(struct iax2_peer *peer, int heldcall)\n{\n\tif (!peer->maxms || (!peer->addr.sin_addr.s_addr && !peer->dnsmgr)) {\n\t\t/* IF we have no IP without dnsmgr, or this isn't to be monitored, return\n\t\t  immediately after clearing things out */\n\t\tpeer->lastms = 0;\n\t\tpeer->historicms = 0;\n\t\tpeer->pokeexpire = -1;\n\t\tpeer->callno = 0;\n\t\treturn 0;\n\t}\n\tif (peer->callno > 0) {\n\t\tast_log(LOG_NOTICE, \"Still have a callno...\\n\");\n\t\tast_mutex_lock(&iaxsl[peer->callno]);\n\t\tiax2_destroy(peer->callno);\n\t\tast_mutex_unlock(&iaxsl[peer->callno]);\n\t}\n\tif (heldcall)\n\t\tast_mutex_unlock(&iaxsl[heldcall]);\n\tpeer->callno = find_callno(0, 0, &peer->addr, NEW_FORCE, peer->sockfd, 0);\n\tif (heldcall)\n\t\tast_mutex_lock(&iaxsl[heldcall]);\n\tif (peer->callno < 1) {\n\t\tast_log(LOG_WARNING, \"Unable to allocate call for poking peer '%s'\\n\", peer->name);\n\t\treturn -1;\n\t}\n\n\t/* Speed up retransmission times for this qualify call */\n\tiaxs[peer->callno]->pingtime = peer->maxms / 4 + 1;\n\tiaxs[peer->callno]->peerpoke = peer;\n\n \tif (peer->pokeexpire > -1) {\n \t\tif (!ast_sched_del(sched, peer->pokeexpire)) {\n \t\t\tpeer->pokeexpire = -1;\n \t\t\tpeer_unref(peer);\n \t\t}\n \t}\n \n\t/* Queue up a new task to handle no reply */\n\t/* If the host is already unreachable then use the unreachable interval instead */\n\tif (peer->lastms < 0)\n \t\tpeer->pokeexpire = iax2_sched_add(sched, peer->pokefreqnotok, iax2_poke_noanswer, peer_ref(peer));\n\telse\n \t\tpeer->pokeexpire = iax2_sched_add(sched, DEFAULT_MAXMS * 2, iax2_poke_noanswer, peer_ref(peer));\n\n \tif (peer->pokeexpire == -1)\n \t\tpeer_unref(peer);\n\n\t/* And send the poke */\n\tsend_command(iaxs[peer->callno], AST_FRAME_IAX, IAX_COMMAND_POKE, 0, NULL, 0, -1);\n\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -17,7 +17,7 @@\n \t}\n \tif (heldcall)\n \t\tast_mutex_unlock(&iaxsl[heldcall]);\n-\tpeer->callno = find_callno(0, 0, &peer->addr, NEW_FORCE, peer->sockfd);\n+\tpeer->callno = find_callno(0, 0, &peer->addr, NEW_FORCE, peer->sockfd, 0);\n \tif (heldcall)\n \t\tast_mutex_lock(&iaxsl[heldcall]);\n \tif (peer->callno < 1) {",
        "diff_line_info": {
            "deleted_lines": [
                "\tpeer->callno = find_callno(0, 0, &peer->addr, NEW_FORCE, peer->sockfd);"
            ],
            "added_lines": [
                "\tpeer->callno = find_callno(0, 0, &peer->addr, NEW_FORCE, peer->sockfd, 0);"
            ]
        }
    },
    {
        "cve_id": "CVE-2008-1897",
        "func_name": "jcollie/asterisk/cache_get_callno_locked",
        "description": "The IAX2 channel driver (chan_iax2) in Asterisk Open Source 1.0.x, 1.2.x before 1.2.28, and 1.4.x before 1.4.19.1; Business Edition A.x.x, B.x.x before B.2.5.2, and C.x.x before C.1.8.1; AsteriskNOW before 1.0.3; Appliance Developer Kit 0.x.x; and s800i before 1.1.0.3, when configured to allow unauthenticated calls, does not verify that an ACK response contains a call number matching the server's reply to a NEW message, which allows remote attackers to cause a denial of service (traffic amplification) via a spoofed ACK response that does not complete a 3-way handshake.  NOTE: this issue exists because of an incomplete fix for CVE-2008-1923.",
        "git_url": "https://github.com/jcollie/asterisk/commit/60de4fbbdf3ede49f158e23a9e3b679f2e519c1e",
        "commit_title": "Merged revisions 114558 via svnmerge from ",
        "commit_text": "https://origsvn.digium.com/svn/asterisk/branches/1.4  ........ r114558 | russell | 2008-04-22 17:15:36 -0500 (Tue, 22 Apr 2008) | 5 lines  When we receive a full frame that is supposed to contain our call number, ensure that it has the correct one. (closes issue #10078) (AST-2008-006)  ........  ",
        "func_before": "static int cache_get_callno_locked(const char *data)\n{\n\tstruct sockaddr_in sin;\n\tint x;\n\tint callno;\n\tstruct iax_ie_data ied;\n\tstruct create_addr_info cai;\n\tstruct parsed_dial_string pds;\n\tchar *tmpstr;\n\n\tfor (x=0; x<IAX_MAX_CALLS; x++) {\n\t\t/* Look for an *exact match* call.  Once a call is negotiated, it can only\n\t\t   look up entries for a single context */\n\t\tif (!ast_mutex_trylock(&iaxsl[x])) {\n\t\t\tif (iaxs[x] && !strcasecmp(data, iaxs[x]->dproot))\n\t\t\t\treturn x;\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t}\n\t}\n\n\t/* No match found, we need to create a new one */\n\n\tmemset(&cai, 0, sizeof(cai));\n\tmemset(&ied, 0, sizeof(ied));\n\tmemset(&pds, 0, sizeof(pds));\n\n\ttmpstr = ast_strdupa(data);\n\tparse_dial_string(tmpstr, &pds);\n\n\tif (ast_strlen_zero(pds.peer)) {\n\t\tast_log(LOG_WARNING, \"No peer provided in the IAX2 dial string '%s'\\n\", data);\n\t\treturn -1;\n\t}\n\n\t/* Populate our address from the given */\n\tif (create_addr(pds.peer, NULL, &sin, &cai))\n\t\treturn -1;\n\n\tast_debug(1, \"peer: %s, username: %s, password: %s, context: %s\\n\",\n\t\tpds.peer, pds.username, pds.password, pds.context);\n\n\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd);\n\tif (callno < 1) {\n\t\tast_log(LOG_WARNING, \"Unable to create call\\n\");\n\t\treturn -1;\n\t}\n\n\tast_string_field_set(iaxs[callno], dproot, data);\n\tiaxs[callno]->capability = IAX_CAPABILITY_FULLBANDWIDTH;\n\n\tiax_ie_append_short(&ied, IAX_IE_VERSION, IAX_PROTO_VERSION);\n\tiax_ie_append_str(&ied, IAX_IE_CALLED_NUMBER, \"TBD\");\n\t/* the string format is slightly different from a standard dial string,\n\t   because the context appears in the 'exten' position\n\t*/\n\tif (pds.exten)\n\t\tiax_ie_append_str(&ied, IAX_IE_CALLED_CONTEXT, pds.exten);\n\tif (pds.username)\n\t\tiax_ie_append_str(&ied, IAX_IE_USERNAME, pds.username);\n\tiax_ie_append_int(&ied, IAX_IE_FORMAT, IAX_CAPABILITY_FULLBANDWIDTH);\n\tiax_ie_append_int(&ied, IAX_IE_CAPABILITY, IAX_CAPABILITY_FULLBANDWIDTH);\n\t/* Keep password handy */\n\tif (pds.password)\n\t\tast_string_field_set(iaxs[callno], secret, pds.password);\n\tif (pds.key)\n\t\tast_string_field_set(iaxs[callno], outkey, pds.key);\n\t/* Start the call going */\n\tsend_command(iaxs[callno], AST_FRAME_IAX, IAX_COMMAND_NEW, 0, ied.buf, ied.pos, -1);\n\n\treturn callno;\n}",
        "func": "static int cache_get_callno_locked(const char *data)\n{\n\tstruct sockaddr_in sin;\n\tint x;\n\tint callno;\n\tstruct iax_ie_data ied;\n\tstruct create_addr_info cai;\n\tstruct parsed_dial_string pds;\n\tchar *tmpstr;\n\n\tfor (x=0; x<IAX_MAX_CALLS; x++) {\n\t\t/* Look for an *exact match* call.  Once a call is negotiated, it can only\n\t\t   look up entries for a single context */\n\t\tif (!ast_mutex_trylock(&iaxsl[x])) {\n\t\t\tif (iaxs[x] && !strcasecmp(data, iaxs[x]->dproot))\n\t\t\t\treturn x;\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t}\n\t}\n\n\t/* No match found, we need to create a new one */\n\n\tmemset(&cai, 0, sizeof(cai));\n\tmemset(&ied, 0, sizeof(ied));\n\tmemset(&pds, 0, sizeof(pds));\n\n\ttmpstr = ast_strdupa(data);\n\tparse_dial_string(tmpstr, &pds);\n\n\tif (ast_strlen_zero(pds.peer)) {\n\t\tast_log(LOG_WARNING, \"No peer provided in the IAX2 dial string '%s'\\n\", data);\n\t\treturn -1;\n\t}\n\n\t/* Populate our address from the given */\n\tif (create_addr(pds.peer, NULL, &sin, &cai))\n\t\treturn -1;\n\n\tast_debug(1, \"peer: %s, username: %s, password: %s, context: %s\\n\",\n\t\tpds.peer, pds.username, pds.password, pds.context);\n\n\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd, 0);\n\tif (callno < 1) {\n\t\tast_log(LOG_WARNING, \"Unable to create call\\n\");\n\t\treturn -1;\n\t}\n\n\tast_string_field_set(iaxs[callno], dproot, data);\n\tiaxs[callno]->capability = IAX_CAPABILITY_FULLBANDWIDTH;\n\n\tiax_ie_append_short(&ied, IAX_IE_VERSION, IAX_PROTO_VERSION);\n\tiax_ie_append_str(&ied, IAX_IE_CALLED_NUMBER, \"TBD\");\n\t/* the string format is slightly different from a standard dial string,\n\t   because the context appears in the 'exten' position\n\t*/\n\tif (pds.exten)\n\t\tiax_ie_append_str(&ied, IAX_IE_CALLED_CONTEXT, pds.exten);\n\tif (pds.username)\n\t\tiax_ie_append_str(&ied, IAX_IE_USERNAME, pds.username);\n\tiax_ie_append_int(&ied, IAX_IE_FORMAT, IAX_CAPABILITY_FULLBANDWIDTH);\n\tiax_ie_append_int(&ied, IAX_IE_CAPABILITY, IAX_CAPABILITY_FULLBANDWIDTH);\n\t/* Keep password handy */\n\tif (pds.password)\n\t\tast_string_field_set(iaxs[callno], secret, pds.password);\n\tif (pds.key)\n\t\tast_string_field_set(iaxs[callno], outkey, pds.key);\n\t/* Start the call going */\n\tsend_command(iaxs[callno], AST_FRAME_IAX, IAX_COMMAND_NEW, 0, ied.buf, ied.pos, -1);\n\n\treturn callno;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -39,7 +39,7 @@\n \tast_debug(1, \"peer: %s, username: %s, password: %s, context: %s\\n\",\n \t\tpds.peer, pds.username, pds.password, pds.context);\n \n-\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd);\n+\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd, 0);\n \tif (callno < 1) {\n \t\tast_log(LOG_WARNING, \"Unable to create call\\n\");\n \t\treturn -1;",
        "diff_line_info": {
            "deleted_lines": [
                "\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd);"
            ],
            "added_lines": [
                "\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd, 0);"
            ]
        }
    },
    {
        "cve_id": "CVE-2008-1897",
        "func_name": "jcollie/asterisk/iax2_provision",
        "description": "The IAX2 channel driver (chan_iax2) in Asterisk Open Source 1.0.x, 1.2.x before 1.2.28, and 1.4.x before 1.4.19.1; Business Edition A.x.x, B.x.x before B.2.5.2, and C.x.x before C.1.8.1; AsteriskNOW before 1.0.3; Appliance Developer Kit 0.x.x; and s800i before 1.1.0.3, when configured to allow unauthenticated calls, does not verify that an ACK response contains a call number matching the server's reply to a NEW message, which allows remote attackers to cause a denial of service (traffic amplification) via a spoofed ACK response that does not complete a 3-way handshake.  NOTE: this issue exists because of an incomplete fix for CVE-2008-1923.",
        "git_url": "https://github.com/jcollie/asterisk/commit/60de4fbbdf3ede49f158e23a9e3b679f2e519c1e",
        "commit_title": "Merged revisions 114558 via svnmerge from ",
        "commit_text": "https://origsvn.digium.com/svn/asterisk/branches/1.4  ........ r114558 | russell | 2008-04-22 17:15:36 -0500 (Tue, 22 Apr 2008) | 5 lines  When we receive a full frame that is supposed to contain our call number, ensure that it has the correct one. (closes issue #10078) (AST-2008-006)  ........  ",
        "func_before": "static int iax2_provision(struct sockaddr_in *end, int sockfd, char *dest, const char *template, int force)\n{\n\t/* Returns 1 if provisioned, -1 if not able to find destination, or 0 if no provisioning\n\t   is found for template */\n\tstruct iax_ie_data provdata;\n\tstruct iax_ie_data ied;\n\tunsigned int sig;\n\tstruct sockaddr_in sin;\n\tint callno;\n\tstruct create_addr_info cai;\n\n\tmemset(&cai, 0, sizeof(cai));\n\n\tast_debug(1, \"Provisioning '%s' from template '%s'\\n\", dest, template);\n\n\tif (iax_provision_build(&provdata, &sig, template, force)) {\n\t\tast_debug(1, \"No provisioning found for template '%s'\\n\", template);\n\t\treturn 0;\n\t}\n\n\tif (end) {\n\t\tmemcpy(&sin, end, sizeof(sin));\n\t\tcai.sockfd = sockfd;\n\t} else if (create_addr(dest, NULL, &sin, &cai))\n\t\treturn -1;\n\n\t/* Build the rest of the message */\n\tmemset(&ied, 0, sizeof(ied));\n\tiax_ie_append_raw(&ied, IAX_IE_PROVISIONING, provdata.buf, provdata.pos);\n\n\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd);\n\tif (!callno)\n\t\treturn -1;\n\n\tif (iaxs[callno]) {\n\t\t/* Schedule autodestruct in case they don't ever give us anything back */\n\t\tiaxs[callno]->autoid = iax2_sched_replace(iaxs[callno]->autoid, \n\t\t\tsched, 15000, auto_hangup, (void *)(long)callno);\n\t\tast_set_flag(iaxs[callno], IAX_PROVISION);\n\t\t/* Got a call number now, so go ahead and send the provisioning information */\n\t\tsend_command(iaxs[callno], AST_FRAME_IAX, IAX_COMMAND_PROVISION, 0, ied.buf, ied.pos, -1);\n\t}\n\tast_mutex_unlock(&iaxsl[callno]);\n\n\treturn 1;\n}",
        "func": "static int iax2_provision(struct sockaddr_in *end, int sockfd, char *dest, const char *template, int force)\n{\n\t/* Returns 1 if provisioned, -1 if not able to find destination, or 0 if no provisioning\n\t   is found for template */\n\tstruct iax_ie_data provdata;\n\tstruct iax_ie_data ied;\n\tunsigned int sig;\n\tstruct sockaddr_in sin;\n\tint callno;\n\tstruct create_addr_info cai;\n\n\tmemset(&cai, 0, sizeof(cai));\n\n\tast_debug(1, \"Provisioning '%s' from template '%s'\\n\", dest, template);\n\n\tif (iax_provision_build(&provdata, &sig, template, force)) {\n\t\tast_debug(1, \"No provisioning found for template '%s'\\n\", template);\n\t\treturn 0;\n\t}\n\n\tif (end) {\n\t\tmemcpy(&sin, end, sizeof(sin));\n\t\tcai.sockfd = sockfd;\n\t} else if (create_addr(dest, NULL, &sin, &cai))\n\t\treturn -1;\n\n\t/* Build the rest of the message */\n\tmemset(&ied, 0, sizeof(ied));\n\tiax_ie_append_raw(&ied, IAX_IE_PROVISIONING, provdata.buf, provdata.pos);\n\n\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd, 0);\n\tif (!callno)\n\t\treturn -1;\n\n\tif (iaxs[callno]) {\n\t\t/* Schedule autodestruct in case they don't ever give us anything back */\n\t\tiaxs[callno]->autoid = iax2_sched_replace(iaxs[callno]->autoid, \n\t\t\tsched, 15000, auto_hangup, (void *)(long)callno);\n\t\tast_set_flag(iaxs[callno], IAX_PROVISION);\n\t\t/* Got a call number now, so go ahead and send the provisioning information */\n\t\tsend_command(iaxs[callno], AST_FRAME_IAX, IAX_COMMAND_PROVISION, 0, ied.buf, ied.pos, -1);\n\t}\n\tast_mutex_unlock(&iaxsl[callno]);\n\n\treturn 1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -28,7 +28,7 @@\n \tmemset(&ied, 0, sizeof(ied));\n \tiax_ie_append_raw(&ied, IAX_IE_PROVISIONING, provdata.buf, provdata.pos);\n \n-\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd);\n+\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd, 0);\n \tif (!callno)\n \t\treturn -1;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd);"
            ],
            "added_lines": [
                "\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd, 0);"
            ]
        }
    },
    {
        "cve_id": "CVE-2008-1897",
        "func_name": "jcollie/asterisk/match",
        "description": "The IAX2 channel driver (chan_iax2) in Asterisk Open Source 1.0.x, 1.2.x before 1.2.28, and 1.4.x before 1.4.19.1; Business Edition A.x.x, B.x.x before B.2.5.2, and C.x.x before C.1.8.1; AsteriskNOW before 1.0.3; Appliance Developer Kit 0.x.x; and s800i before 1.1.0.3, when configured to allow unauthenticated calls, does not verify that an ACK response contains a call number matching the server's reply to a NEW message, which allows remote attackers to cause a denial of service (traffic amplification) via a spoofed ACK response that does not complete a 3-way handshake.  NOTE: this issue exists because of an incomplete fix for CVE-2008-1923.",
        "git_url": "https://github.com/jcollie/asterisk/commit/60de4fbbdf3ede49f158e23a9e3b679f2e519c1e",
        "commit_title": "Merged revisions 114558 via svnmerge from ",
        "commit_text": "https://origsvn.digium.com/svn/asterisk/branches/1.4  ........ r114558 | russell | 2008-04-22 17:15:36 -0500 (Tue, 22 Apr 2008) | 5 lines  When we receive a full frame that is supposed to contain our call number, ensure that it has the correct one. (closes issue #10078) (AST-2008-006)  ........  ",
        "func_before": "static int match(struct sockaddr_in *sin, unsigned short callno, unsigned short dcallno, const struct chan_iax2_pvt *cur)\n{\n\tif ((cur->addr.sin_addr.s_addr == sin->sin_addr.s_addr) &&\n\t\t(cur->addr.sin_port == sin->sin_port)) {\n\t\t/* This is the main host */\n\t\tif ((cur->peercallno == callno) ||\n\t\t\t((dcallno == cur->callno) && !cur->peercallno)) {\n\t\t\t/* That's us.  Be sure we keep track of the peer call number */\n\t\t\treturn 1;\n\t\t}\n\t}\n\tif ((cur->transfer.sin_addr.s_addr == sin->sin_addr.s_addr) &&\n\t    (cur->transfer.sin_port == sin->sin_port) && (cur->transferring)) {\n\t\t/* We're transferring */\n\t\tif ((dcallno == cur->callno) || (cur->transferring == TRANSFER_MEDIAPASS && cur->transfercallno == callno))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
        "func": "static int match(struct sockaddr_in *sin, unsigned short callno, unsigned short dcallno, const struct chan_iax2_pvt *cur, int full_frame)\n{\n\tif ((cur->addr.sin_addr.s_addr == sin->sin_addr.s_addr) &&\n\t\t(cur->addr.sin_port == sin->sin_port)) {\n\t\t/* This is the main host */\n\t\tif ( (cur->peercallno == 0 || cur->peercallno == callno) &&\n\t\t\t (full_frame ? dcallno == cur->callno : 1) ) {\n\t\t\t/* That's us.  Be sure we keep track of the peer call number */\n\t\t\treturn 1;\n\t\t}\n\t}\n\tif ((cur->transfer.sin_addr.s_addr == sin->sin_addr.s_addr) &&\n\t    (cur->transfer.sin_port == sin->sin_port) && (cur->transferring)) {\n\t\t/* We're transferring */\n\t\tif ((dcallno == cur->callno) || (cur->transferring == TRANSFER_MEDIAPASS && cur->transfercallno == callno))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,10 +1,10 @@\n-static int match(struct sockaddr_in *sin, unsigned short callno, unsigned short dcallno, const struct chan_iax2_pvt *cur)\n+static int match(struct sockaddr_in *sin, unsigned short callno, unsigned short dcallno, const struct chan_iax2_pvt *cur, int full_frame)\n {\n \tif ((cur->addr.sin_addr.s_addr == sin->sin_addr.s_addr) &&\n \t\t(cur->addr.sin_port == sin->sin_port)) {\n \t\t/* This is the main host */\n-\t\tif ((cur->peercallno == callno) ||\n-\t\t\t((dcallno == cur->callno) && !cur->peercallno)) {\n+\t\tif ( (cur->peercallno == 0 || cur->peercallno == callno) &&\n+\t\t\t (full_frame ? dcallno == cur->callno : 1) ) {\n \t\t\t/* That's us.  Be sure we keep track of the peer call number */\n \t\t\treturn 1;\n \t\t}",
        "diff_line_info": {
            "deleted_lines": [
                "static int match(struct sockaddr_in *sin, unsigned short callno, unsigned short dcallno, const struct chan_iax2_pvt *cur)",
                "\t\tif ((cur->peercallno == callno) ||",
                "\t\t\t((dcallno == cur->callno) && !cur->peercallno)) {"
            ],
            "added_lines": [
                "static int match(struct sockaddr_in *sin, unsigned short callno, unsigned short dcallno, const struct chan_iax2_pvt *cur, int full_frame)",
                "\t\tif ( (cur->peercallno == 0 || cur->peercallno == callno) &&",
                "\t\t\t (full_frame ? dcallno == cur->callno : 1) ) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2008-1897",
        "func_name": "jcollie/asterisk/socket_process_meta",
        "description": "The IAX2 channel driver (chan_iax2) in Asterisk Open Source 1.0.x, 1.2.x before 1.2.28, and 1.4.x before 1.4.19.1; Business Edition A.x.x, B.x.x before B.2.5.2, and C.x.x before C.1.8.1; AsteriskNOW before 1.0.3; Appliance Developer Kit 0.x.x; and s800i before 1.1.0.3, when configured to allow unauthenticated calls, does not verify that an ACK response contains a call number matching the server's reply to a NEW message, which allows remote attackers to cause a denial of service (traffic amplification) via a spoofed ACK response that does not complete a 3-way handshake.  NOTE: this issue exists because of an incomplete fix for CVE-2008-1923.",
        "git_url": "https://github.com/jcollie/asterisk/commit/60de4fbbdf3ede49f158e23a9e3b679f2e519c1e",
        "commit_title": "Merged revisions 114558 via svnmerge from ",
        "commit_text": "https://origsvn.digium.com/svn/asterisk/branches/1.4  ........ r114558 | russell | 2008-04-22 17:15:36 -0500 (Tue, 22 Apr 2008) | 5 lines  When we receive a full frame that is supposed to contain our call number, ensure that it has the correct one. (closes issue #10078) (AST-2008-006)  ........  ",
        "func_before": "static int socket_process_meta(int packet_len, struct ast_iax2_meta_hdr *meta, struct sockaddr_in *sin, int sockfd,\n\tstruct iax_frame *fr)\n{\n\tunsigned char metatype;\n\tstruct ast_iax2_meta_trunk_mini *mtm;\n\tstruct ast_iax2_meta_trunk_hdr *mth;\n\tstruct ast_iax2_meta_trunk_entry *mte;\n\tstruct iax2_trunk_peer *tpeer;\n\tunsigned int ts;\n\tvoid *ptr;\n\tstruct timeval rxtrunktime;\n\tstruct ast_frame f = { 0, };\n\n\tif (packet_len < sizeof(*meta)) {\n\t\tast_log(LOG_WARNING, \"Rejecting packet from '%s.%d' that is flagged as a meta frame but is too short\\n\", \n\t\t\tast_inet_ntoa(sin->sin_addr), ntohs(sin->sin_port));\n\t\treturn 1;\n\t}\n\n\tif (meta->metacmd != IAX_META_TRUNK)\n\t\treturn 1;\n\n\tif (packet_len < (sizeof(*meta) + sizeof(*mth))) {\n\t\tast_log(LOG_WARNING, \"midget meta trunk packet received (%d of %d min)\\n\", packet_len,\n\t\t\t(int) (sizeof(*meta) + sizeof(*mth)));\n\t\treturn 1;\n\t}\n\tmth = (struct ast_iax2_meta_trunk_hdr *)(meta->data);\n\tts = ntohl(mth->ts);\n\tmetatype = meta->cmddata;\n\tpacket_len -= (sizeof(*meta) + sizeof(*mth));\n\tptr = mth->data;\n\ttpeer = find_tpeer(sin, sockfd);\n\tif (!tpeer) {\n\t\tast_log(LOG_WARNING, \"Unable to accept trunked packet from '%s:%d': No matching peer\\n\", \n\t\t\tast_inet_ntoa(sin->sin_addr), ntohs(sin->sin_port));\n\t\treturn 1;\n\t}\n\ttpeer->trunkact = ast_tvnow();\n\tif (!ts || ast_tvzero(tpeer->rxtrunktime))\n\t\ttpeer->rxtrunktime = tpeer->trunkact;\n\trxtrunktime = tpeer->rxtrunktime;\n\tast_mutex_unlock(&tpeer->lock);\n\twhile (packet_len >= sizeof(*mte)) {\n\t\t/* Process channels */\n\t\tunsigned short callno, trunked_ts, len;\n\n\t\tif (metatype == IAX_META_TRUNK_MINI) {\n\t\t\tmtm = (struct ast_iax2_meta_trunk_mini *) ptr;\n\t\t\tptr += sizeof(*mtm);\n\t\t\tpacket_len -= sizeof(*mtm);\n\t\t\tlen = ntohs(mtm->len);\n\t\t\tcallno = ntohs(mtm->mini.callno);\n\t\t\ttrunked_ts = ntohs(mtm->mini.ts);\n\t\t} else if (metatype == IAX_META_TRUNK_SUPERMINI) {\n\t\t\tmte = (struct ast_iax2_meta_trunk_entry *)ptr;\n\t\t\tptr += sizeof(*mte);\n\t\t\tpacket_len -= sizeof(*mte);\n\t\t\tlen = ntohs(mte->len);\n\t\t\tcallno = ntohs(mte->callno);\n\t\t\ttrunked_ts = 0;\n\t\t} else {\n\t\t\tast_log(LOG_WARNING, \"Unknown meta trunk cmd from '%s:%d': dropping\\n\", ast_inet_ntoa(sin->sin_addr), ntohs(sin->sin_port));\n\t\t\tbreak;\n\t\t}\n\t\t/* Stop if we don't have enough data */\n\t\tif (len > packet_len)\n\t\t\tbreak;\n\t\tfr->callno = find_callno_locked(callno & ~IAX_FLAG_FULL, 0, sin, NEW_PREVENT, sockfd);\n\t\tif (!fr->callno)\n\t\t\tcontinue;\n\n\t\t/* If it's a valid call, deliver the contents.  If not, we\n\t\t   drop it, since we don't have a scallno to use for an INVAL */\n\t\t/* Process as a mini frame */\n\t\tmemset(&f, 0, sizeof(f));\n\t\tf.frametype = AST_FRAME_VOICE;\n\t\tif (!iaxs[fr->callno]) {\n\t\t\t/* drop it */\n\t\t} else if (iaxs[fr->callno]->voiceformat == 0) {\n\t\t\tast_log(LOG_WARNING, \"Received trunked frame before first full voice frame\\n \");\n\t\t\tiax2_vnak(fr->callno);\n\t\t} else {\n\t\t\tf.subclass = iaxs[fr->callno]->voiceformat;\n\t\t\tf.datalen = len;\n\t\t\tif (f.datalen >= 0) {\n\t\t\t\tif (f.datalen)\n\t\t\t\t\tf.data = ptr;\n\t\t\t\telse\n\t\t\t\t\tf.data = NULL;\n\t\t\t\tif (trunked_ts)\n\t\t\t\t\tfr->ts = (iaxs[fr->callno]->last & 0xFFFF0000L) | (trunked_ts & 0xffff);\n\t\t\t\telse\n\t\t\t\t\tfr->ts = fix_peerts(&rxtrunktime, fr->callno, ts);\n\t\t\t\t/* Don't pass any packets until we're started */\n\t\t\t\tif (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)) {\n\t\t\t\t\tstruct iax_frame *duped_fr;\n\n\t\t\t\t\t/* Common things */\n\t\t\t\t\tf.src = \"IAX2\";\n\t\t\t\t\tf.mallocd = 0;\n\t\t\t\t\tf.offset = 0;\n\t\t\t\t\tif (f.datalen && (f.frametype == AST_FRAME_VOICE)) \n\t\t\t\t\t\tf.samples = ast_codec_get_samples(&f);\n\t\t\t\t\telse\n\t\t\t\t\t\tf.samples = 0;\n\t\t\t\t\tfr->outoforder = 0;\n\t\t\t\t\tiax_frame_wrap(fr, &f);\n\t\t\t\t\tduped_fr = iaxfrdup2(fr);\n\t\t\t\t\tif (duped_fr)\n\t\t\t\t\t\tschedule_delivery(duped_fr, 1, 1, &fr->ts);\n\t\t\t\t\tif (iaxs[fr->callno] && iaxs[fr->callno]->last < fr->ts)\n\t\t\t\t\t\tiaxs[fr->callno]->last = fr->ts;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tast_log(LOG_WARNING, \"Datalen < 0?\\n\");\n\t\t\t}\n\t\t}\n\t\tast_mutex_unlock(&iaxsl[fr->callno]);\n\t\tptr += len;\n\t\tpacket_len -= len;\n\t}\n\n\treturn 1;\n}",
        "func": "static int socket_process_meta(int packet_len, struct ast_iax2_meta_hdr *meta, struct sockaddr_in *sin, int sockfd,\n\tstruct iax_frame *fr)\n{\n\tunsigned char metatype;\n\tstruct ast_iax2_meta_trunk_mini *mtm;\n\tstruct ast_iax2_meta_trunk_hdr *mth;\n\tstruct ast_iax2_meta_trunk_entry *mte;\n\tstruct iax2_trunk_peer *tpeer;\n\tunsigned int ts;\n\tvoid *ptr;\n\tstruct timeval rxtrunktime;\n\tstruct ast_frame f = { 0, };\n\n\tif (packet_len < sizeof(*meta)) {\n\t\tast_log(LOG_WARNING, \"Rejecting packet from '%s.%d' that is flagged as a meta frame but is too short\\n\", \n\t\t\tast_inet_ntoa(sin->sin_addr), ntohs(sin->sin_port));\n\t\treturn 1;\n\t}\n\n\tif (meta->metacmd != IAX_META_TRUNK)\n\t\treturn 1;\n\n\tif (packet_len < (sizeof(*meta) + sizeof(*mth))) {\n\t\tast_log(LOG_WARNING, \"midget meta trunk packet received (%d of %d min)\\n\", packet_len,\n\t\t\t(int) (sizeof(*meta) + sizeof(*mth)));\n\t\treturn 1;\n\t}\n\tmth = (struct ast_iax2_meta_trunk_hdr *)(meta->data);\n\tts = ntohl(mth->ts);\n\tmetatype = meta->cmddata;\n\tpacket_len -= (sizeof(*meta) + sizeof(*mth));\n\tptr = mth->data;\n\ttpeer = find_tpeer(sin, sockfd);\n\tif (!tpeer) {\n\t\tast_log(LOG_WARNING, \"Unable to accept trunked packet from '%s:%d': No matching peer\\n\", \n\t\t\tast_inet_ntoa(sin->sin_addr), ntohs(sin->sin_port));\n\t\treturn 1;\n\t}\n\ttpeer->trunkact = ast_tvnow();\n\tif (!ts || ast_tvzero(tpeer->rxtrunktime))\n\t\ttpeer->rxtrunktime = tpeer->trunkact;\n\trxtrunktime = tpeer->rxtrunktime;\n\tast_mutex_unlock(&tpeer->lock);\n\twhile (packet_len >= sizeof(*mte)) {\n\t\t/* Process channels */\n\t\tunsigned short callno, trunked_ts, len;\n\n\t\tif (metatype == IAX_META_TRUNK_MINI) {\n\t\t\tmtm = (struct ast_iax2_meta_trunk_mini *) ptr;\n\t\t\tptr += sizeof(*mtm);\n\t\t\tpacket_len -= sizeof(*mtm);\n\t\t\tlen = ntohs(mtm->len);\n\t\t\tcallno = ntohs(mtm->mini.callno);\n\t\t\ttrunked_ts = ntohs(mtm->mini.ts);\n\t\t} else if (metatype == IAX_META_TRUNK_SUPERMINI) {\n\t\t\tmte = (struct ast_iax2_meta_trunk_entry *)ptr;\n\t\t\tptr += sizeof(*mte);\n\t\t\tpacket_len -= sizeof(*mte);\n\t\t\tlen = ntohs(mte->len);\n\t\t\tcallno = ntohs(mte->callno);\n\t\t\ttrunked_ts = 0;\n\t\t} else {\n\t\t\tast_log(LOG_WARNING, \"Unknown meta trunk cmd from '%s:%d': dropping\\n\", ast_inet_ntoa(sin->sin_addr), ntohs(sin->sin_port));\n\t\t\tbreak;\n\t\t}\n\t\t/* Stop if we don't have enough data */\n\t\tif (len > packet_len)\n\t\t\tbreak;\n\t\tfr->callno = find_callno_locked(callno & ~IAX_FLAG_FULL, 0, sin, NEW_PREVENT, sockfd, 0);\n\t\tif (!fr->callno)\n\t\t\tcontinue;\n\n\t\t/* If it's a valid call, deliver the contents.  If not, we\n\t\t   drop it, since we don't have a scallno to use for an INVAL */\n\t\t/* Process as a mini frame */\n\t\tmemset(&f, 0, sizeof(f));\n\t\tf.frametype = AST_FRAME_VOICE;\n\t\tif (!iaxs[fr->callno]) {\n\t\t\t/* drop it */\n\t\t} else if (iaxs[fr->callno]->voiceformat == 0) {\n\t\t\tast_log(LOG_WARNING, \"Received trunked frame before first full voice frame\\n \");\n\t\t\tiax2_vnak(fr->callno);\n\t\t} else {\n\t\t\tf.subclass = iaxs[fr->callno]->voiceformat;\n\t\t\tf.datalen = len;\n\t\t\tif (f.datalen >= 0) {\n\t\t\t\tif (f.datalen)\n\t\t\t\t\tf.data = ptr;\n\t\t\t\telse\n\t\t\t\t\tf.data = NULL;\n\t\t\t\tif (trunked_ts)\n\t\t\t\t\tfr->ts = (iaxs[fr->callno]->last & 0xFFFF0000L) | (trunked_ts & 0xffff);\n\t\t\t\telse\n\t\t\t\t\tfr->ts = fix_peerts(&rxtrunktime, fr->callno, ts);\n\t\t\t\t/* Don't pass any packets until we're started */\n\t\t\t\tif (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)) {\n\t\t\t\t\tstruct iax_frame *duped_fr;\n\n\t\t\t\t\t/* Common things */\n\t\t\t\t\tf.src = \"IAX2\";\n\t\t\t\t\tf.mallocd = 0;\n\t\t\t\t\tf.offset = 0;\n\t\t\t\t\tif (f.datalen && (f.frametype == AST_FRAME_VOICE)) \n\t\t\t\t\t\tf.samples = ast_codec_get_samples(&f);\n\t\t\t\t\telse\n\t\t\t\t\t\tf.samples = 0;\n\t\t\t\t\tfr->outoforder = 0;\n\t\t\t\t\tiax_frame_wrap(fr, &f);\n\t\t\t\t\tduped_fr = iaxfrdup2(fr);\n\t\t\t\t\tif (duped_fr)\n\t\t\t\t\t\tschedule_delivery(duped_fr, 1, 1, &fr->ts);\n\t\t\t\t\tif (iaxs[fr->callno] && iaxs[fr->callno]->last < fr->ts)\n\t\t\t\t\t\tiaxs[fr->callno]->last = fr->ts;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tast_log(LOG_WARNING, \"Datalen < 0?\\n\");\n\t\t\t}\n\t\t}\n\t\tast_mutex_unlock(&iaxsl[fr->callno]);\n\t\tptr += len;\n\t\tpacket_len -= len;\n\t}\n\n\treturn 1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -66,7 +66,7 @@\n \t\t/* Stop if we don't have enough data */\n \t\tif (len > packet_len)\n \t\t\tbreak;\n-\t\tfr->callno = find_callno_locked(callno & ~IAX_FLAG_FULL, 0, sin, NEW_PREVENT, sockfd);\n+\t\tfr->callno = find_callno_locked(callno & ~IAX_FLAG_FULL, 0, sin, NEW_PREVENT, sockfd, 0);\n \t\tif (!fr->callno)\n \t\t\tcontinue;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tfr->callno = find_callno_locked(callno & ~IAX_FLAG_FULL, 0, sin, NEW_PREVENT, sockfd);"
            ],
            "added_lines": [
                "\t\tfr->callno = find_callno_locked(callno & ~IAX_FLAG_FULL, 0, sin, NEW_PREVENT, sockfd, 0);"
            ]
        }
    },
    {
        "cve_id": "CVE-2008-1897",
        "func_name": "jcollie/asterisk/find_callno_locked",
        "description": "The IAX2 channel driver (chan_iax2) in Asterisk Open Source 1.0.x, 1.2.x before 1.2.28, and 1.4.x before 1.4.19.1; Business Edition A.x.x, B.x.x before B.2.5.2, and C.x.x before C.1.8.1; AsteriskNOW before 1.0.3; Appliance Developer Kit 0.x.x; and s800i before 1.1.0.3, when configured to allow unauthenticated calls, does not verify that an ACK response contains a call number matching the server's reply to a NEW message, which allows remote attackers to cause a denial of service (traffic amplification) via a spoofed ACK response that does not complete a 3-way handshake.  NOTE: this issue exists because of an incomplete fix for CVE-2008-1923.",
        "git_url": "https://github.com/jcollie/asterisk/commit/60de4fbbdf3ede49f158e23a9e3b679f2e519c1e",
        "commit_title": "Merged revisions 114558 via svnmerge from ",
        "commit_text": "https://origsvn.digium.com/svn/asterisk/branches/1.4  ........ r114558 | russell | 2008-04-22 17:15:36 -0500 (Tue, 22 Apr 2008) | 5 lines  When we receive a full frame that is supposed to contain our call number, ensure that it has the correct one. (closes issue #10078) (AST-2008-006)  ........  ",
        "func_before": "static int find_callno_locked(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd) {\n\n\treturn __find_callno(callno, dcallno, sin, new, sockfd, 1);\n}",
        "func": "static int find_callno_locked(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int full_frame) {\n\n\treturn __find_callno(callno, dcallno, sin, new, sockfd, 1, full_frame);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,4 @@\n-static int find_callno_locked(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd) {\n+static int find_callno_locked(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int full_frame) {\n \n-\treturn __find_callno(callno, dcallno, sin, new, sockfd, 1);\n+\treturn __find_callno(callno, dcallno, sin, new, sockfd, 1, full_frame);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "static int find_callno_locked(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd) {",
                "\treturn __find_callno(callno, dcallno, sin, new, sockfd, 1);"
            ],
            "added_lines": [
                "static int find_callno_locked(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int full_frame) {",
                "\treturn __find_callno(callno, dcallno, sin, new, sockfd, 1, full_frame);"
            ]
        }
    },
    {
        "cve_id": "CVE-2008-1897",
        "func_name": "jcollie/asterisk/iax2_request",
        "description": "The IAX2 channel driver (chan_iax2) in Asterisk Open Source 1.0.x, 1.2.x before 1.2.28, and 1.4.x before 1.4.19.1; Business Edition A.x.x, B.x.x before B.2.5.2, and C.x.x before C.1.8.1; AsteriskNOW before 1.0.3; Appliance Developer Kit 0.x.x; and s800i before 1.1.0.3, when configured to allow unauthenticated calls, does not verify that an ACK response contains a call number matching the server's reply to a NEW message, which allows remote attackers to cause a denial of service (traffic amplification) via a spoofed ACK response that does not complete a 3-way handshake.  NOTE: this issue exists because of an incomplete fix for CVE-2008-1923.",
        "git_url": "https://github.com/jcollie/asterisk/commit/60de4fbbdf3ede49f158e23a9e3b679f2e519c1e",
        "commit_title": "Merged revisions 114558 via svnmerge from ",
        "commit_text": "https://origsvn.digium.com/svn/asterisk/branches/1.4  ........ r114558 | russell | 2008-04-22 17:15:36 -0500 (Tue, 22 Apr 2008) | 5 lines  When we receive a full frame that is supposed to contain our call number, ensure that it has the correct one. (closes issue #10078) (AST-2008-006)  ........  ",
        "func_before": "static struct ast_channel *iax2_request(const char *type, int format, void *data, int *cause)\n{\n\tint callno;\n\tint res;\n\tint fmt, native;\n\tstruct sockaddr_in sin;\n\tstruct ast_channel *c;\n\tstruct parsed_dial_string pds;\n\tstruct create_addr_info cai;\n\tchar *tmpstr;\n\n\tmemset(&pds, 0, sizeof(pds));\n\ttmpstr = ast_strdupa(data);\n\tparse_dial_string(tmpstr, &pds);\n\n\tif (ast_strlen_zero(pds.peer)) {\n\t\tast_log(LOG_WARNING, \"No peer provided in the IAX2 dial string '%s'\\n\", (char *) data);\n\t\treturn NULL;\n\t}\n\t       \n\tmemset(&cai, 0, sizeof(cai));\n\tcai.capability = iax2_capability;\n\n\tast_copy_flags(&cai, &globalflags, IAX_NOTRANSFER | IAX_TRANSFERMEDIA | IAX_USEJITTERBUF | IAX_FORCEJITTERBUF);\n\t\n\t/* Populate our address from the given */\n\tif (create_addr(pds.peer, NULL, &sin, &cai)) {\n\t\t*cause = AST_CAUSE_UNREGISTERED;\n\t\treturn NULL;\n\t}\n\n\tif (pds.port)\n\t\tsin.sin_port = htons(atoi(pds.port));\n\n\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd);\n\tif (callno < 1) {\n\t\tast_log(LOG_WARNING, \"Unable to create call\\n\");\n\t\t*cause = AST_CAUSE_CONGESTION;\n\t\treturn NULL;\n\t}\n\n\t/* If this is a trunk, update it now */\n\tast_copy_flags(iaxs[callno], &cai, IAX_TRUNK | IAX_SENDANI | IAX_NOTRANSFER | IAX_TRANSFERMEDIA | IAX_USEJITTERBUF | IAX_FORCEJITTERBUF);\t\n\tif (ast_test_flag(&cai, IAX_TRUNK)) {\n\t\tint new_callno;\n\t\tif ((new_callno = make_trunk(callno, 1)) != -1)\n\t\t\tcallno = new_callno;\n\t}\n\tiaxs[callno]->maxtime = cai.maxtime;\n\tif (cai.found)\n\t\tast_string_field_set(iaxs[callno], host, pds.peer);\n\n\tc = ast_iax2_new(callno, AST_STATE_DOWN, cai.capability);\n\n\tast_mutex_unlock(&iaxsl[callno]);\n\n\tif (c) {\n\t\t/* Choose a format we can live with */\n\t\tif (c->nativeformats & format) \n\t\t\tc->nativeformats &= format;\n\t\telse {\n\t\t\tnative = c->nativeformats;\n\t\t\tfmt = format;\n\t\t\tres = ast_translator_best_choice(&fmt, &native);\n\t\t\tif (res < 0) {\n\t\t\t\tast_log(LOG_WARNING, \"Unable to create translator path for %s to %s on %s\\n\",\n\t\t\t\t\tast_getformatname(c->nativeformats), ast_getformatname(fmt), c->name);\n\t\t\t\tast_hangup(c);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tc->nativeformats = native;\n\t\t}\n\t\tc->readformat = ast_best_codec(c->nativeformats);\n\t\tc->writeformat = c->readformat;\n\t}\n\n\treturn c;\n}",
        "func": "static struct ast_channel *iax2_request(const char *type, int format, void *data, int *cause)\n{\n\tint callno;\n\tint res;\n\tint fmt, native;\n\tstruct sockaddr_in sin;\n\tstruct ast_channel *c;\n\tstruct parsed_dial_string pds;\n\tstruct create_addr_info cai;\n\tchar *tmpstr;\n\n\tmemset(&pds, 0, sizeof(pds));\n\ttmpstr = ast_strdupa(data);\n\tparse_dial_string(tmpstr, &pds);\n\n\tif (ast_strlen_zero(pds.peer)) {\n\t\tast_log(LOG_WARNING, \"No peer provided in the IAX2 dial string '%s'\\n\", (char *) data);\n\t\treturn NULL;\n\t}\n\t       \n\tmemset(&cai, 0, sizeof(cai));\n\tcai.capability = iax2_capability;\n\n\tast_copy_flags(&cai, &globalflags, IAX_NOTRANSFER | IAX_TRANSFERMEDIA | IAX_USEJITTERBUF | IAX_FORCEJITTERBUF);\n\t\n\t/* Populate our address from the given */\n\tif (create_addr(pds.peer, NULL, &sin, &cai)) {\n\t\t*cause = AST_CAUSE_UNREGISTERED;\n\t\treturn NULL;\n\t}\n\n\tif (pds.port)\n\t\tsin.sin_port = htons(atoi(pds.port));\n\n\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd, 0);\n\tif (callno < 1) {\n\t\tast_log(LOG_WARNING, \"Unable to create call\\n\");\n\t\t*cause = AST_CAUSE_CONGESTION;\n\t\treturn NULL;\n\t}\n\n\t/* If this is a trunk, update it now */\n\tast_copy_flags(iaxs[callno], &cai, IAX_TRUNK | IAX_SENDANI | IAX_NOTRANSFER | IAX_TRANSFERMEDIA | IAX_USEJITTERBUF | IAX_FORCEJITTERBUF);\t\n\tif (ast_test_flag(&cai, IAX_TRUNK)) {\n\t\tint new_callno;\n\t\tif ((new_callno = make_trunk(callno, 1)) != -1)\n\t\t\tcallno = new_callno;\n\t}\n\tiaxs[callno]->maxtime = cai.maxtime;\n\tif (cai.found)\n\t\tast_string_field_set(iaxs[callno], host, pds.peer);\n\n\tc = ast_iax2_new(callno, AST_STATE_DOWN, cai.capability);\n\n\tast_mutex_unlock(&iaxsl[callno]);\n\n\tif (c) {\n\t\t/* Choose a format we can live with */\n\t\tif (c->nativeformats & format) \n\t\t\tc->nativeformats &= format;\n\t\telse {\n\t\t\tnative = c->nativeformats;\n\t\t\tfmt = format;\n\t\t\tres = ast_translator_best_choice(&fmt, &native);\n\t\t\tif (res < 0) {\n\t\t\t\tast_log(LOG_WARNING, \"Unable to create translator path for %s to %s on %s\\n\",\n\t\t\t\t\tast_getformatname(c->nativeformats), ast_getformatname(fmt), c->name);\n\t\t\t\tast_hangup(c);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tc->nativeformats = native;\n\t\t}\n\t\tc->readformat = ast_best_codec(c->nativeformats);\n\t\tc->writeformat = c->readformat;\n\t}\n\n\treturn c;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -32,7 +32,7 @@\n \tif (pds.port)\n \t\tsin.sin_port = htons(atoi(pds.port));\n \n-\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd);\n+\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd, 0);\n \tif (callno < 1) {\n \t\tast_log(LOG_WARNING, \"Unable to create call\\n\");\n \t\t*cause = AST_CAUSE_CONGESTION;",
        "diff_line_info": {
            "deleted_lines": [
                "\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd);"
            ],
            "added_lines": [
                "\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd, 0);"
            ]
        }
    },
    {
        "cve_id": "CVE-2008-1897",
        "func_name": "jcollie/asterisk/__find_callno",
        "description": "The IAX2 channel driver (chan_iax2) in Asterisk Open Source 1.0.x, 1.2.x before 1.2.28, and 1.4.x before 1.4.19.1; Business Edition A.x.x, B.x.x before B.2.5.2, and C.x.x before C.1.8.1; AsteriskNOW before 1.0.3; Appliance Developer Kit 0.x.x; and s800i before 1.1.0.3, when configured to allow unauthenticated calls, does not verify that an ACK response contains a call number matching the server's reply to a NEW message, which allows remote attackers to cause a denial of service (traffic amplification) via a spoofed ACK response that does not complete a 3-way handshake.  NOTE: this issue exists because of an incomplete fix for CVE-2008-1923.",
        "git_url": "https://github.com/jcollie/asterisk/commit/60de4fbbdf3ede49f158e23a9e3b679f2e519c1e",
        "commit_title": "Merged revisions 114558 via svnmerge from ",
        "commit_text": "https://origsvn.digium.com/svn/asterisk/branches/1.4  ........ r114558 | russell | 2008-04-22 17:15:36 -0500 (Tue, 22 Apr 2008) | 5 lines  When we receive a full frame that is supposed to contain our call number, ensure that it has the correct one. (closes issue #10078) (AST-2008-006)  ........  ",
        "func_before": "static int __find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int return_locked)\n{\n\tint res = 0;\n\tint x;\n\tstruct timeval now;\n\tchar host[80];\n\n\tif (new <= NEW_ALLOW) {\n\t\tfor (x=1;(res < 1) && (x<maxnontrunkcall);x++) {\n\t\t\tast_mutex_lock(&iaxsl[x]);\n\t\t\tif (iaxs[x]) {\n\t\t\t\t/* Look for an exact match */\n\t\t\t\tif (match(sin, callno, dcallno, iaxs[x])) {\n\t\t\t\t\tres = x;\n\t\t\t\t}\n\t\t\t}\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t}\n\t\tfor (x=TRUNK_CALL_START;(res < 1) && (x<maxtrunkcall);x++) {\n\t\t\tast_mutex_lock(&iaxsl[x]);\n\t\t\tif (iaxs[x]) {\n\t\t\t\t/* Look for an exact match */\n\t\t\t\tif (match(sin, callno, dcallno, iaxs[x])) {\n\t\t\t\t\tres = x;\n\t\t\t\t}\n\t\t\t}\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t}\n\t}\n\tif ((res < 1) && (new >= NEW_ALLOW)) {\n\t\t/* It may seem odd that we look through the peer list for a name for\n\t\t * this *incoming* call.  Well, it is weird.  However, users don't\n\t\t * have an IP address/port number that we can match against.  So,\n\t\t * this is just checking for a peer that has that IP/port and\n\t\t * assuming that we have a user of the same name.  This isn't always\n\t\t * correct, but it will be changed if needed after authentication. */\n\t\tif (!iax2_getpeername(*sin, host, sizeof(host)))\n\t\t\tsnprintf(host, sizeof(host), \"%s:%d\", ast_inet_ntoa(sin->sin_addr), ntohs(sin->sin_port));\n\t\tnow = ast_tvnow();\n\t\tfor (x=1;x<TRUNK_CALL_START;x++) {\n\t\t\t/* Find first unused call number that hasn't been used in a while */\n\t\t\tast_mutex_lock(&iaxsl[x]);\n\t\t\tif (!iaxs[x] && ((now.tv_sec - lastused[x].tv_sec) > MIN_REUSE_TIME)) break;\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t}\n\t\t/* We've still got lock held if we found a spot */\n\t\tif (x >= TRUNK_CALL_START) {\n\t\t\tast_log(LOG_WARNING, \"No more space\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tiaxs[x] = new_iax(sin, host);\n\t\tupdate_max_nontrunk();\n\t\tif (iaxs[x]) {\n\t\t\tif (iaxdebug)\n\t\t\t\tast_debug(1, \"Creating new call structure %d\\n\", x);\n\t\t\tiaxs[x]->sockfd = sockfd;\n\t\t\tiaxs[x]->addr.sin_port = sin->sin_port;\n\t\t\tiaxs[x]->addr.sin_family = sin->sin_family;\n\t\t\tiaxs[x]->addr.sin_addr.s_addr = sin->sin_addr.s_addr;\n\t\t\tiaxs[x]->peercallno = callno;\n\t\t\tiaxs[x]->callno = x;\n\t\t\tiaxs[x]->pingtime = DEFAULT_RETRY_TIME;\n\t\t\tiaxs[x]->expiry = min_reg_expire;\n\t\t\tiaxs[x]->pingid = iax2_sched_add(sched, ping_time * 1000, send_ping, (void *)(long)x);\n\t\t\tiaxs[x]->lagid = iax2_sched_add(sched, lagrq_time * 1000, send_lagrq, (void *)(long)x);\n\t\t\tiaxs[x]->amaflags = amaflags;\n\t\t\tast_copy_flags(iaxs[x], (&globalflags), IAX_NOTRANSFER | IAX_TRANSFERMEDIA | IAX_USEJITTERBUF | IAX_FORCEJITTERBUF);\n\t\t\t\n\t\t\tast_string_field_set(iaxs[x], accountcode, accountcode);\n\t\t\tast_string_field_set(iaxs[x], mohinterpret, mohinterpret);\n\t\t\tast_string_field_set(iaxs[x], mohsuggest, mohsuggest);\n\t\t\tast_string_field_set(iaxs[x], parkinglot, default_parkinglot);\n\t\t} else {\n\t\t\tast_log(LOG_WARNING, \"Out of resources\\n\");\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t\treturn 0;\n\t\t}\n\t\tif (!return_locked)\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\tres = x;\n\t}\n\treturn res;\n}",
        "func": "static int __find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int return_locked, int full_frame)\n{\n\tint res = 0;\n\tint x;\n\tstruct timeval now;\n\tchar host[80];\n\n\tif (new <= NEW_ALLOW) {\n\t\tfor (x=1;(res < 1) && (x<maxnontrunkcall);x++) {\n\t\t\tast_mutex_lock(&iaxsl[x]);\n\t\t\tif (iaxs[x]) {\n\t\t\t\t/* Look for an exact match */\n\t\t\t\tif (match(sin, callno, dcallno, iaxs[x], full_frame)) {\n\t\t\t\t\tres = x;\n\t\t\t\t}\n\t\t\t}\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t}\n\t\tfor (x=TRUNK_CALL_START;(res < 1) && (x<maxtrunkcall);x++) {\n\t\t\tast_mutex_lock(&iaxsl[x]);\n\t\t\tif (iaxs[x]) {\n\t\t\t\t/* Look for an exact match */\n\t\t\t\tif (match(sin, callno, dcallno, iaxs[x], full_frame)) {\n\t\t\t\t\tres = x;\n\t\t\t\t}\n\t\t\t}\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t}\n\t}\n\tif ((res < 1) && (new >= NEW_ALLOW)) {\n\t\tint start, found = 0;\n\n\t\t/* It may seem odd that we look through the peer list for a name for\n\t\t * this *incoming* call.  Well, it is weird.  However, users don't\n\t\t * have an IP address/port number that we can match against.  So,\n\t\t * this is just checking for a peer that has that IP/port and\n\t\t * assuming that we have a user of the same name.  This isn't always\n\t\t * correct, but it will be changed if needed after authentication. */\n\t\tif (!iax2_getpeername(*sin, host, sizeof(host)))\n\t\t\tsnprintf(host, sizeof(host), \"%s:%d\", ast_inet_ntoa(sin->sin_addr), ntohs(sin->sin_port));\n\n\t\tnow = ast_tvnow();\n\t\tstart = 1 + (ast_random() % (TRUNK_CALL_START - 1));\n\t\tfor (x = start; 1; x++) {\n\t\t\tif (x == TRUNK_CALL_START) {\n\t\t\t\tx = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* Find first unused call number that hasn't been used in a while */\n\t\t\tast_mutex_lock(&iaxsl[x]);\n\t\t\tif (!iaxs[x] && ((now.tv_sec - lastused[x].tv_sec) > MIN_REUSE_TIME)) {\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t\t\n\t\t\tif (x == start - 1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/* We've still got lock held if we found a spot */\n\t\tif (x == start - 1 && !found) {\n\t\t\tast_log(LOG_WARNING, \"No more space\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tiaxs[x] = new_iax(sin, host);\n\t\tupdate_max_nontrunk();\n\t\tif (iaxs[x]) {\n\t\t\tif (iaxdebug)\n\t\t\t\tast_debug(1, \"Creating new call structure %d\\n\", x);\n\t\t\tiaxs[x]->sockfd = sockfd;\n\t\t\tiaxs[x]->addr.sin_port = sin->sin_port;\n\t\t\tiaxs[x]->addr.sin_family = sin->sin_family;\n\t\t\tiaxs[x]->addr.sin_addr.s_addr = sin->sin_addr.s_addr;\n\t\t\tiaxs[x]->peercallno = callno;\n\t\t\tiaxs[x]->callno = x;\n\t\t\tiaxs[x]->pingtime = DEFAULT_RETRY_TIME;\n\t\t\tiaxs[x]->expiry = min_reg_expire;\n\t\t\tiaxs[x]->pingid = iax2_sched_add(sched, ping_time * 1000, send_ping, (void *)(long)x);\n\t\t\tiaxs[x]->lagid = iax2_sched_add(sched, lagrq_time * 1000, send_lagrq, (void *)(long)x);\n\t\t\tiaxs[x]->amaflags = amaflags;\n\t\t\tast_copy_flags(iaxs[x], (&globalflags), IAX_NOTRANSFER | IAX_TRANSFERMEDIA | IAX_USEJITTERBUF | IAX_FORCEJITTERBUF);\n\t\t\t\n\t\t\tast_string_field_set(iaxs[x], accountcode, accountcode);\n\t\t\tast_string_field_set(iaxs[x], mohinterpret, mohinterpret);\n\t\t\tast_string_field_set(iaxs[x], mohsuggest, mohsuggest);\n\t\t\tast_string_field_set(iaxs[x], parkinglot, default_parkinglot);\n\t\t} else {\n\t\t\tast_log(LOG_WARNING, \"Out of resources\\n\");\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t\treturn 0;\n\t\t}\n\t\tif (!return_locked)\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\tres = x;\n\t}\n\treturn res;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,4 @@\n-static int __find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int return_locked)\n+static int __find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int return_locked, int full_frame)\n {\n \tint res = 0;\n \tint x;\n@@ -10,7 +10,7 @@\n \t\t\tast_mutex_lock(&iaxsl[x]);\n \t\t\tif (iaxs[x]) {\n \t\t\t\t/* Look for an exact match */\n-\t\t\t\tif (match(sin, callno, dcallno, iaxs[x])) {\n+\t\t\t\tif (match(sin, callno, dcallno, iaxs[x], full_frame)) {\n \t\t\t\t\tres = x;\n \t\t\t\t}\n \t\t\t}\n@@ -20,7 +20,7 @@\n \t\t\tast_mutex_lock(&iaxsl[x]);\n \t\t\tif (iaxs[x]) {\n \t\t\t\t/* Look for an exact match */\n-\t\t\t\tif (match(sin, callno, dcallno, iaxs[x])) {\n+\t\t\t\tif (match(sin, callno, dcallno, iaxs[x], full_frame)) {\n \t\t\t\t\tres = x;\n \t\t\t\t}\n \t\t\t}\n@@ -28,6 +28,8 @@\n \t\t}\n \t}\n \tif ((res < 1) && (new >= NEW_ALLOW)) {\n+\t\tint start, found = 0;\n+\n \t\t/* It may seem odd that we look through the peer list for a name for\n \t\t * this *incoming* call.  Well, it is weird.  However, users don't\n \t\t * have an IP address/port number that we can match against.  So,\n@@ -36,15 +38,29 @@\n \t\t * correct, but it will be changed if needed after authentication. */\n \t\tif (!iax2_getpeername(*sin, host, sizeof(host)))\n \t\t\tsnprintf(host, sizeof(host), \"%s:%d\", ast_inet_ntoa(sin->sin_addr), ntohs(sin->sin_port));\n+\n \t\tnow = ast_tvnow();\n-\t\tfor (x=1;x<TRUNK_CALL_START;x++) {\n+\t\tstart = 1 + (ast_random() % (TRUNK_CALL_START - 1));\n+\t\tfor (x = start; 1; x++) {\n+\t\t\tif (x == TRUNK_CALL_START) {\n+\t\t\t\tx = 0;\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\n \t\t\t/* Find first unused call number that hasn't been used in a while */\n \t\t\tast_mutex_lock(&iaxsl[x]);\n-\t\t\tif (!iaxs[x] && ((now.tv_sec - lastused[x].tv_sec) > MIN_REUSE_TIME)) break;\n+\t\t\tif (!iaxs[x] && ((now.tv_sec - lastused[x].tv_sec) > MIN_REUSE_TIME)) {\n+\t\t\t\tfound = 1;\n+\t\t\t\tbreak;\n+\t\t\t}\n \t\t\tast_mutex_unlock(&iaxsl[x]);\n+\t\t\t\n+\t\t\tif (x == start - 1) {\n+\t\t\t\tbreak;\n+\t\t\t}\n \t\t}\n \t\t/* We've still got lock held if we found a spot */\n-\t\tif (x >= TRUNK_CALL_START) {\n+\t\tif (x == start - 1 && !found) {\n \t\t\tast_log(LOG_WARNING, \"No more space\\n\");\n \t\t\treturn 0;\n \t\t}",
        "diff_line_info": {
            "deleted_lines": [
                "static int __find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int return_locked)",
                "\t\t\t\tif (match(sin, callno, dcallno, iaxs[x])) {",
                "\t\t\t\tif (match(sin, callno, dcallno, iaxs[x])) {",
                "\t\tfor (x=1;x<TRUNK_CALL_START;x++) {",
                "\t\t\tif (!iaxs[x] && ((now.tv_sec - lastused[x].tv_sec) > MIN_REUSE_TIME)) break;",
                "\t\tif (x >= TRUNK_CALL_START) {"
            ],
            "added_lines": [
                "static int __find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int return_locked, int full_frame)",
                "\t\t\t\tif (match(sin, callno, dcallno, iaxs[x], full_frame)) {",
                "\t\t\t\tif (match(sin, callno, dcallno, iaxs[x], full_frame)) {",
                "\t\tint start, found = 0;",
                "",
                "",
                "\t\tstart = 1 + (ast_random() % (TRUNK_CALL_START - 1));",
                "\t\tfor (x = start; 1; x++) {",
                "\t\t\tif (x == TRUNK_CALL_START) {",
                "\t\t\t\tx = 0;",
                "\t\t\t\tcontinue;",
                "\t\t\t}",
                "",
                "\t\t\tif (!iaxs[x] && ((now.tv_sec - lastused[x].tv_sec) > MIN_REUSE_TIME)) {",
                "\t\t\t\tfound = 1;",
                "\t\t\t\tbreak;",
                "\t\t\t}",
                "\t\t\t",
                "\t\t\tif (x == start - 1) {",
                "\t\t\t\tbreak;",
                "\t\t\t}",
                "\t\tif (x == start - 1 && !found) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2008-1897",
        "func_name": "jcollie/asterisk/find_callno",
        "description": "The IAX2 channel driver (chan_iax2) in Asterisk Open Source 1.0.x, 1.2.x before 1.2.28, and 1.4.x before 1.4.19.1; Business Edition A.x.x, B.x.x before B.2.5.2, and C.x.x before C.1.8.1; AsteriskNOW before 1.0.3; Appliance Developer Kit 0.x.x; and s800i before 1.1.0.3, when configured to allow unauthenticated calls, does not verify that an ACK response contains a call number matching the server's reply to a NEW message, which allows remote attackers to cause a denial of service (traffic amplification) via a spoofed ACK response that does not complete a 3-way handshake.  NOTE: this issue exists because of an incomplete fix for CVE-2008-1923.",
        "git_url": "https://github.com/jcollie/asterisk/commit/771b3d8749b34b6eea4e03a2e514380da9582f90",
        "commit_title": "Merged revisions 114558 via svnmerge from ",
        "commit_text": "https://origsvn.digium.com/svn/asterisk/branches/1.4  ........ r114558 | russell | 2008-04-22 17:15:36 -0500 (Tue, 22 Apr 2008) | 5 lines  When we receive a full frame that is supposed to contain our call number, ensure that it has the correct one. (closes issue #10078) (AST-2008-006)  ........  ",
        "func_before": "static int find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd) {\n\n\treturn __find_callno(callno, dcallno, sin, new, sockfd, 0);\n}",
        "func": "static int find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int full_frame) {\n\n\treturn __find_callno(callno, dcallno, sin, new, sockfd, 0, full_frame);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,4 @@\n-static int find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd) {\n+static int find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int full_frame) {\n \n-\treturn __find_callno(callno, dcallno, sin, new, sockfd, 0);\n+\treturn __find_callno(callno, dcallno, sin, new, sockfd, 0, full_frame);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "static int find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd) {",
                "\treturn __find_callno(callno, dcallno, sin, new, sockfd, 0);"
            ],
            "added_lines": [
                "static int find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int full_frame) {",
                "\treturn __find_callno(callno, dcallno, sin, new, sockfd, 0, full_frame);"
            ]
        }
    },
    {
        "cve_id": "CVE-2008-1897",
        "func_name": "jcollie/asterisk/iax2_do_register",
        "description": "The IAX2 channel driver (chan_iax2) in Asterisk Open Source 1.0.x, 1.2.x before 1.2.28, and 1.4.x before 1.4.19.1; Business Edition A.x.x, B.x.x before B.2.5.2, and C.x.x before C.1.8.1; AsteriskNOW before 1.0.3; Appliance Developer Kit 0.x.x; and s800i before 1.1.0.3, when configured to allow unauthenticated calls, does not verify that an ACK response contains a call number matching the server's reply to a NEW message, which allows remote attackers to cause a denial of service (traffic amplification) via a spoofed ACK response that does not complete a 3-way handshake.  NOTE: this issue exists because of an incomplete fix for CVE-2008-1923.",
        "git_url": "https://github.com/jcollie/asterisk/commit/771b3d8749b34b6eea4e03a2e514380da9582f90",
        "commit_title": "Merged revisions 114558 via svnmerge from ",
        "commit_text": "https://origsvn.digium.com/svn/asterisk/branches/1.4  ........ r114558 | russell | 2008-04-22 17:15:36 -0500 (Tue, 22 Apr 2008) | 5 lines  When we receive a full frame that is supposed to contain our call number, ensure that it has the correct one. (closes issue #10078) (AST-2008-006)  ........  ",
        "func_before": "static int iax2_do_register(struct iax2_registry *reg)\n{\n\tstruct iax_ie_data ied;\n\tif (iaxdebug)\n\t\tast_debug(1, \"Sending registration request for '%s'\\n\", reg->username);\n\n\tif (reg->dnsmgr && \n\t    ((reg->regstate == REG_STATE_TIMEOUT) || !reg->addr.sin_addr.s_addr)) {\n\t\t/* Maybe the IP has changed, force DNS refresh */\n\t\tast_dnsmgr_refresh(reg->dnsmgr);\n\t}\n\t\n\t/*\n\t * if IP has Changed, free allocated call to create a new one with new IP\n\t * call has the pointer to IP and must be updated to the new one\n\t */\n\tif (reg->dnsmgr && ast_dnsmgr_changed(reg->dnsmgr) && (reg->callno > 0)) {\n\t\tast_mutex_lock(&iaxsl[reg->callno]);\n\t\tiax2_destroy(reg->callno);\n\t\tast_mutex_unlock(&iaxsl[reg->callno]);\n\t\treg->callno = 0;\n\t}\n\tif (!reg->addr.sin_addr.s_addr) {\n\t\tif (iaxdebug)\n\t\t\tast_debug(1, \"Unable to send registration request for '%s' without IP address\\n\", reg->username);\n\t\t/* Setup the next registration attempt */\n\t\treg->expire = iax2_sched_replace(reg->expire, sched, \n\t\t\t(5 * reg->refresh / 6) * 1000, iax2_do_register_s, reg);\n\t\treturn -1;\n\t}\n\n\tif (!reg->callno) {\n\t\tast_debug(1, \"Allocate call number\\n\");\n\t\treg->callno = find_callno_locked(0, 0, &reg->addr, NEW_FORCE, defaultsockfd);\n\t\tif (reg->callno < 1) {\n\t\t\tast_log(LOG_WARNING, \"Unable to create call for registration\\n\");\n\t\t\treturn -1;\n\t\t} else\n\t\t\tast_debug(1, \"Registration created on call %d\\n\", reg->callno);\n\t\tiaxs[reg->callno]->reg = reg;\n\t\tast_mutex_unlock(&iaxsl[reg->callno]);\n\t}\n\t/* Setup the next registration a little early */\n\treg->expire = iax2_sched_replace(reg->expire, sched, \n\t\t(5 * reg->refresh / 6) * 1000, iax2_do_register_s, reg);\n\t/* Send the request */\n\tmemset(&ied, 0, sizeof(ied));\n\tiax_ie_append_str(&ied, IAX_IE_USERNAME, reg->username);\n\tiax_ie_append_short(&ied, IAX_IE_REFRESH, reg->refresh);\n\tsend_command(iaxs[reg->callno],AST_FRAME_IAX, IAX_COMMAND_REGREQ, 0, ied.buf, ied.pos, -1);\n\treg->regstate = REG_STATE_REGSENT;\n\treturn 0;\n}",
        "func": "static int iax2_do_register(struct iax2_registry *reg)\n{\n\tstruct iax_ie_data ied;\n\tif (iaxdebug)\n\t\tast_debug(1, \"Sending registration request for '%s'\\n\", reg->username);\n\n\tif (reg->dnsmgr && \n\t    ((reg->regstate == REG_STATE_TIMEOUT) || !reg->addr.sin_addr.s_addr)) {\n\t\t/* Maybe the IP has changed, force DNS refresh */\n\t\tast_dnsmgr_refresh(reg->dnsmgr);\n\t}\n\t\n\t/*\n\t * if IP has Changed, free allocated call to create a new one with new IP\n\t * call has the pointer to IP and must be updated to the new one\n\t */\n\tif (reg->dnsmgr && ast_dnsmgr_changed(reg->dnsmgr) && (reg->callno > 0)) {\n\t\tast_mutex_lock(&iaxsl[reg->callno]);\n\t\tiax2_destroy(reg->callno);\n\t\tast_mutex_unlock(&iaxsl[reg->callno]);\n\t\treg->callno = 0;\n\t}\n\tif (!reg->addr.sin_addr.s_addr) {\n\t\tif (iaxdebug)\n\t\t\tast_debug(1, \"Unable to send registration request for '%s' without IP address\\n\", reg->username);\n\t\t/* Setup the next registration attempt */\n\t\treg->expire = iax2_sched_replace(reg->expire, sched, \n\t\t\t(5 * reg->refresh / 6) * 1000, iax2_do_register_s, reg);\n\t\treturn -1;\n\t}\n\n\tif (!reg->callno) {\n\t\tast_debug(1, \"Allocate call number\\n\");\n\t\treg->callno = find_callno_locked(0, 0, &reg->addr, NEW_FORCE, defaultsockfd, 0);\n\t\tif (reg->callno < 1) {\n\t\t\tast_log(LOG_WARNING, \"Unable to create call for registration\\n\");\n\t\t\treturn -1;\n\t\t} else\n\t\t\tast_debug(1, \"Registration created on call %d\\n\", reg->callno);\n\t\tiaxs[reg->callno]->reg = reg;\n\t\tast_mutex_unlock(&iaxsl[reg->callno]);\n\t}\n\t/* Setup the next registration a little early */\n\treg->expire = iax2_sched_replace(reg->expire, sched, \n\t\t(5 * reg->refresh / 6) * 1000, iax2_do_register_s, reg);\n\t/* Send the request */\n\tmemset(&ied, 0, sizeof(ied));\n\tiax_ie_append_str(&ied, IAX_IE_USERNAME, reg->username);\n\tiax_ie_append_short(&ied, IAX_IE_REFRESH, reg->refresh);\n\tsend_command(iaxs[reg->callno],AST_FRAME_IAX, IAX_COMMAND_REGREQ, 0, ied.buf, ied.pos, -1);\n\treg->regstate = REG_STATE_REGSENT;\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -31,7 +31,7 @@\n \n \tif (!reg->callno) {\n \t\tast_debug(1, \"Allocate call number\\n\");\n-\t\treg->callno = find_callno_locked(0, 0, &reg->addr, NEW_FORCE, defaultsockfd);\n+\t\treg->callno = find_callno_locked(0, 0, &reg->addr, NEW_FORCE, defaultsockfd, 0);\n \t\tif (reg->callno < 1) {\n \t\t\tast_log(LOG_WARNING, \"Unable to create call for registration\\n\");\n \t\t\treturn -1;",
        "diff_line_info": {
            "deleted_lines": [
                "\t\treg->callno = find_callno_locked(0, 0, &reg->addr, NEW_FORCE, defaultsockfd);"
            ],
            "added_lines": [
                "\t\treg->callno = find_callno_locked(0, 0, &reg->addr, NEW_FORCE, defaultsockfd, 0);"
            ]
        }
    },
    {
        "cve_id": "CVE-2008-1897",
        "func_name": "jcollie/asterisk/iax2_poke_peer",
        "description": "The IAX2 channel driver (chan_iax2) in Asterisk Open Source 1.0.x, 1.2.x before 1.2.28, and 1.4.x before 1.4.19.1; Business Edition A.x.x, B.x.x before B.2.5.2, and C.x.x before C.1.8.1; AsteriskNOW before 1.0.3; Appliance Developer Kit 0.x.x; and s800i before 1.1.0.3, when configured to allow unauthenticated calls, does not verify that an ACK response contains a call number matching the server's reply to a NEW message, which allows remote attackers to cause a denial of service (traffic amplification) via a spoofed ACK response that does not complete a 3-way handshake.  NOTE: this issue exists because of an incomplete fix for CVE-2008-1923.",
        "git_url": "https://github.com/jcollie/asterisk/commit/771b3d8749b34b6eea4e03a2e514380da9582f90",
        "commit_title": "Merged revisions 114558 via svnmerge from ",
        "commit_text": "https://origsvn.digium.com/svn/asterisk/branches/1.4  ........ r114558 | russell | 2008-04-22 17:15:36 -0500 (Tue, 22 Apr 2008) | 5 lines  When we receive a full frame that is supposed to contain our call number, ensure that it has the correct one. (closes issue #10078) (AST-2008-006)  ........  ",
        "func_before": "static int iax2_poke_peer(struct iax2_peer *peer, int heldcall)\n{\n\tif (!peer->maxms || (!peer->addr.sin_addr.s_addr && !peer->dnsmgr)) {\n\t\t/* IF we have no IP without dnsmgr, or this isn't to be monitored, return\n\t\t  immediately after clearing things out */\n\t\tpeer->lastms = 0;\n\t\tpeer->historicms = 0;\n\t\tpeer->pokeexpire = -1;\n\t\tpeer->callno = 0;\n\t\treturn 0;\n\t}\n\tif (peer->callno > 0) {\n\t\tast_log(LOG_NOTICE, \"Still have a callno...\\n\");\n\t\tast_mutex_lock(&iaxsl[peer->callno]);\n\t\tiax2_destroy(peer->callno);\n\t\tast_mutex_unlock(&iaxsl[peer->callno]);\n\t}\n\tif (heldcall)\n\t\tast_mutex_unlock(&iaxsl[heldcall]);\n\tpeer->callno = find_callno(0, 0, &peer->addr, NEW_FORCE, peer->sockfd);\n\tif (heldcall)\n\t\tast_mutex_lock(&iaxsl[heldcall]);\n\tif (peer->callno < 1) {\n\t\tast_log(LOG_WARNING, \"Unable to allocate call for poking peer '%s'\\n\", peer->name);\n\t\treturn -1;\n\t}\n\n\t/* Speed up retransmission times for this qualify call */\n\tiaxs[peer->callno]->pingtime = peer->maxms / 4 + 1;\n\tiaxs[peer->callno]->peerpoke = peer;\n\n \tif (peer->pokeexpire > -1) {\n \t\tif (!ast_sched_del(sched, peer->pokeexpire)) {\n \t\t\tpeer->pokeexpire = -1;\n \t\t\tpeer_unref(peer);\n \t\t}\n \t}\n \n\t/* Queue up a new task to handle no reply */\n\t/* If the host is already unreachable then use the unreachable interval instead */\n\tif (peer->lastms < 0)\n \t\tpeer->pokeexpire = iax2_sched_add(sched, peer->pokefreqnotok, iax2_poke_noanswer, peer_ref(peer));\n\telse\n \t\tpeer->pokeexpire = iax2_sched_add(sched, DEFAULT_MAXMS * 2, iax2_poke_noanswer, peer_ref(peer));\n\n \tif (peer->pokeexpire == -1)\n \t\tpeer_unref(peer);\n\n\t/* And send the poke */\n\tsend_command(iaxs[peer->callno], AST_FRAME_IAX, IAX_COMMAND_POKE, 0, NULL, 0, -1);\n\n\treturn 0;\n}",
        "func": "static int iax2_poke_peer(struct iax2_peer *peer, int heldcall)\n{\n\tif (!peer->maxms || (!peer->addr.sin_addr.s_addr && !peer->dnsmgr)) {\n\t\t/* IF we have no IP without dnsmgr, or this isn't to be monitored, return\n\t\t  immediately after clearing things out */\n\t\tpeer->lastms = 0;\n\t\tpeer->historicms = 0;\n\t\tpeer->pokeexpire = -1;\n\t\tpeer->callno = 0;\n\t\treturn 0;\n\t}\n\tif (peer->callno > 0) {\n\t\tast_log(LOG_NOTICE, \"Still have a callno...\\n\");\n\t\tast_mutex_lock(&iaxsl[peer->callno]);\n\t\tiax2_destroy(peer->callno);\n\t\tast_mutex_unlock(&iaxsl[peer->callno]);\n\t}\n\tif (heldcall)\n\t\tast_mutex_unlock(&iaxsl[heldcall]);\n\tpeer->callno = find_callno(0, 0, &peer->addr, NEW_FORCE, peer->sockfd, 0);\n\tif (heldcall)\n\t\tast_mutex_lock(&iaxsl[heldcall]);\n\tif (peer->callno < 1) {\n\t\tast_log(LOG_WARNING, \"Unable to allocate call for poking peer '%s'\\n\", peer->name);\n\t\treturn -1;\n\t}\n\n\t/* Speed up retransmission times for this qualify call */\n\tiaxs[peer->callno]->pingtime = peer->maxms / 4 + 1;\n\tiaxs[peer->callno]->peerpoke = peer;\n\n \tif (peer->pokeexpire > -1) {\n \t\tif (!ast_sched_del(sched, peer->pokeexpire)) {\n \t\t\tpeer->pokeexpire = -1;\n \t\t\tpeer_unref(peer);\n \t\t}\n \t}\n \n\t/* Queue up a new task to handle no reply */\n\t/* If the host is already unreachable then use the unreachable interval instead */\n\tif (peer->lastms < 0)\n \t\tpeer->pokeexpire = iax2_sched_add(sched, peer->pokefreqnotok, iax2_poke_noanswer, peer_ref(peer));\n\telse\n \t\tpeer->pokeexpire = iax2_sched_add(sched, DEFAULT_MAXMS * 2, iax2_poke_noanswer, peer_ref(peer));\n\n \tif (peer->pokeexpire == -1)\n \t\tpeer_unref(peer);\n\n\t/* And send the poke */\n\tsend_command(iaxs[peer->callno], AST_FRAME_IAX, IAX_COMMAND_POKE, 0, NULL, 0, -1);\n\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -17,7 +17,7 @@\n \t}\n \tif (heldcall)\n \t\tast_mutex_unlock(&iaxsl[heldcall]);\n-\tpeer->callno = find_callno(0, 0, &peer->addr, NEW_FORCE, peer->sockfd);\n+\tpeer->callno = find_callno(0, 0, &peer->addr, NEW_FORCE, peer->sockfd, 0);\n \tif (heldcall)\n \t\tast_mutex_lock(&iaxsl[heldcall]);\n \tif (peer->callno < 1) {",
        "diff_line_info": {
            "deleted_lines": [
                "\tpeer->callno = find_callno(0, 0, &peer->addr, NEW_FORCE, peer->sockfd);"
            ],
            "added_lines": [
                "\tpeer->callno = find_callno(0, 0, &peer->addr, NEW_FORCE, peer->sockfd, 0);"
            ]
        }
    },
    {
        "cve_id": "CVE-2008-1897",
        "func_name": "jcollie/asterisk/cache_get_callno_locked",
        "description": "The IAX2 channel driver (chan_iax2) in Asterisk Open Source 1.0.x, 1.2.x before 1.2.28, and 1.4.x before 1.4.19.1; Business Edition A.x.x, B.x.x before B.2.5.2, and C.x.x before C.1.8.1; AsteriskNOW before 1.0.3; Appliance Developer Kit 0.x.x; and s800i before 1.1.0.3, when configured to allow unauthenticated calls, does not verify that an ACK response contains a call number matching the server's reply to a NEW message, which allows remote attackers to cause a denial of service (traffic amplification) via a spoofed ACK response that does not complete a 3-way handshake.  NOTE: this issue exists because of an incomplete fix for CVE-2008-1923.",
        "git_url": "https://github.com/jcollie/asterisk/commit/771b3d8749b34b6eea4e03a2e514380da9582f90",
        "commit_title": "Merged revisions 114558 via svnmerge from ",
        "commit_text": "https://origsvn.digium.com/svn/asterisk/branches/1.4  ........ r114558 | russell | 2008-04-22 17:15:36 -0500 (Tue, 22 Apr 2008) | 5 lines  When we receive a full frame that is supposed to contain our call number, ensure that it has the correct one. (closes issue #10078) (AST-2008-006)  ........  ",
        "func_before": "static int cache_get_callno_locked(const char *data)\n{\n\tstruct sockaddr_in sin;\n\tint x;\n\tint callno;\n\tstruct iax_ie_data ied;\n\tstruct create_addr_info cai;\n\tstruct parsed_dial_string pds;\n\tchar *tmpstr;\n\n\tfor (x=0; x<IAX_MAX_CALLS; x++) {\n\t\t/* Look for an *exact match* call.  Once a call is negotiated, it can only\n\t\t   look up entries for a single context */\n\t\tif (!ast_mutex_trylock(&iaxsl[x])) {\n\t\t\tif (iaxs[x] && !strcasecmp(data, iaxs[x]->dproot))\n\t\t\t\treturn x;\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t}\n\t}\n\n\t/* No match found, we need to create a new one */\n\n\tmemset(&cai, 0, sizeof(cai));\n\tmemset(&ied, 0, sizeof(ied));\n\tmemset(&pds, 0, sizeof(pds));\n\n\ttmpstr = ast_strdupa(data);\n\tparse_dial_string(tmpstr, &pds);\n\n\tif (ast_strlen_zero(pds.peer)) {\n\t\tast_log(LOG_WARNING, \"No peer provided in the IAX2 dial string '%s'\\n\", data);\n\t\treturn -1;\n\t}\n\n\t/* Populate our address from the given */\n\tif (create_addr(pds.peer, NULL, &sin, &cai))\n\t\treturn -1;\n\n\tast_debug(1, \"peer: %s, username: %s, password: %s, context: %s\\n\",\n\t\tpds.peer, pds.username, pds.password, pds.context);\n\n\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd);\n\tif (callno < 1) {\n\t\tast_log(LOG_WARNING, \"Unable to create call\\n\");\n\t\treturn -1;\n\t}\n\n\tast_string_field_set(iaxs[callno], dproot, data);\n\tiaxs[callno]->capability = IAX_CAPABILITY_FULLBANDWIDTH;\n\n\tiax_ie_append_short(&ied, IAX_IE_VERSION, IAX_PROTO_VERSION);\n\tiax_ie_append_str(&ied, IAX_IE_CALLED_NUMBER, \"TBD\");\n\t/* the string format is slightly different from a standard dial string,\n\t   because the context appears in the 'exten' position\n\t*/\n\tif (pds.exten)\n\t\tiax_ie_append_str(&ied, IAX_IE_CALLED_CONTEXT, pds.exten);\n\tif (pds.username)\n\t\tiax_ie_append_str(&ied, IAX_IE_USERNAME, pds.username);\n\tiax_ie_append_int(&ied, IAX_IE_FORMAT, IAX_CAPABILITY_FULLBANDWIDTH);\n\tiax_ie_append_int(&ied, IAX_IE_CAPABILITY, IAX_CAPABILITY_FULLBANDWIDTH);\n\t/* Keep password handy */\n\tif (pds.password)\n\t\tast_string_field_set(iaxs[callno], secret, pds.password);\n\tif (pds.key)\n\t\tast_string_field_set(iaxs[callno], outkey, pds.key);\n\t/* Start the call going */\n\tsend_command(iaxs[callno], AST_FRAME_IAX, IAX_COMMAND_NEW, 0, ied.buf, ied.pos, -1);\n\n\treturn callno;\n}",
        "func": "static int cache_get_callno_locked(const char *data)\n{\n\tstruct sockaddr_in sin;\n\tint x;\n\tint callno;\n\tstruct iax_ie_data ied;\n\tstruct create_addr_info cai;\n\tstruct parsed_dial_string pds;\n\tchar *tmpstr;\n\n\tfor (x=0; x<IAX_MAX_CALLS; x++) {\n\t\t/* Look for an *exact match* call.  Once a call is negotiated, it can only\n\t\t   look up entries for a single context */\n\t\tif (!ast_mutex_trylock(&iaxsl[x])) {\n\t\t\tif (iaxs[x] && !strcasecmp(data, iaxs[x]->dproot))\n\t\t\t\treturn x;\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t}\n\t}\n\n\t/* No match found, we need to create a new one */\n\n\tmemset(&cai, 0, sizeof(cai));\n\tmemset(&ied, 0, sizeof(ied));\n\tmemset(&pds, 0, sizeof(pds));\n\n\ttmpstr = ast_strdupa(data);\n\tparse_dial_string(tmpstr, &pds);\n\n\tif (ast_strlen_zero(pds.peer)) {\n\t\tast_log(LOG_WARNING, \"No peer provided in the IAX2 dial string '%s'\\n\", data);\n\t\treturn -1;\n\t}\n\n\t/* Populate our address from the given */\n\tif (create_addr(pds.peer, NULL, &sin, &cai))\n\t\treturn -1;\n\n\tast_debug(1, \"peer: %s, username: %s, password: %s, context: %s\\n\",\n\t\tpds.peer, pds.username, pds.password, pds.context);\n\n\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd, 0);\n\tif (callno < 1) {\n\t\tast_log(LOG_WARNING, \"Unable to create call\\n\");\n\t\treturn -1;\n\t}\n\n\tast_string_field_set(iaxs[callno], dproot, data);\n\tiaxs[callno]->capability = IAX_CAPABILITY_FULLBANDWIDTH;\n\n\tiax_ie_append_short(&ied, IAX_IE_VERSION, IAX_PROTO_VERSION);\n\tiax_ie_append_str(&ied, IAX_IE_CALLED_NUMBER, \"TBD\");\n\t/* the string format is slightly different from a standard dial string,\n\t   because the context appears in the 'exten' position\n\t*/\n\tif (pds.exten)\n\t\tiax_ie_append_str(&ied, IAX_IE_CALLED_CONTEXT, pds.exten);\n\tif (pds.username)\n\t\tiax_ie_append_str(&ied, IAX_IE_USERNAME, pds.username);\n\tiax_ie_append_int(&ied, IAX_IE_FORMAT, IAX_CAPABILITY_FULLBANDWIDTH);\n\tiax_ie_append_int(&ied, IAX_IE_CAPABILITY, IAX_CAPABILITY_FULLBANDWIDTH);\n\t/* Keep password handy */\n\tif (pds.password)\n\t\tast_string_field_set(iaxs[callno], secret, pds.password);\n\tif (pds.key)\n\t\tast_string_field_set(iaxs[callno], outkey, pds.key);\n\t/* Start the call going */\n\tsend_command(iaxs[callno], AST_FRAME_IAX, IAX_COMMAND_NEW, 0, ied.buf, ied.pos, -1);\n\n\treturn callno;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -39,7 +39,7 @@\n \tast_debug(1, \"peer: %s, username: %s, password: %s, context: %s\\n\",\n \t\tpds.peer, pds.username, pds.password, pds.context);\n \n-\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd);\n+\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd, 0);\n \tif (callno < 1) {\n \t\tast_log(LOG_WARNING, \"Unable to create call\\n\");\n \t\treturn -1;",
        "diff_line_info": {
            "deleted_lines": [
                "\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd);"
            ],
            "added_lines": [
                "\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd, 0);"
            ]
        }
    },
    {
        "cve_id": "CVE-2008-1897",
        "func_name": "jcollie/asterisk/iax2_provision",
        "description": "The IAX2 channel driver (chan_iax2) in Asterisk Open Source 1.0.x, 1.2.x before 1.2.28, and 1.4.x before 1.4.19.1; Business Edition A.x.x, B.x.x before B.2.5.2, and C.x.x before C.1.8.1; AsteriskNOW before 1.0.3; Appliance Developer Kit 0.x.x; and s800i before 1.1.0.3, when configured to allow unauthenticated calls, does not verify that an ACK response contains a call number matching the server's reply to a NEW message, which allows remote attackers to cause a denial of service (traffic amplification) via a spoofed ACK response that does not complete a 3-way handshake.  NOTE: this issue exists because of an incomplete fix for CVE-2008-1923.",
        "git_url": "https://github.com/jcollie/asterisk/commit/771b3d8749b34b6eea4e03a2e514380da9582f90",
        "commit_title": "Merged revisions 114558 via svnmerge from ",
        "commit_text": "https://origsvn.digium.com/svn/asterisk/branches/1.4  ........ r114558 | russell | 2008-04-22 17:15:36 -0500 (Tue, 22 Apr 2008) | 5 lines  When we receive a full frame that is supposed to contain our call number, ensure that it has the correct one. (closes issue #10078) (AST-2008-006)  ........  ",
        "func_before": "static int iax2_provision(struct sockaddr_in *end, int sockfd, char *dest, const char *template, int force)\n{\n\t/* Returns 1 if provisioned, -1 if not able to find destination, or 0 if no provisioning\n\t   is found for template */\n\tstruct iax_ie_data provdata;\n\tstruct iax_ie_data ied;\n\tunsigned int sig;\n\tstruct sockaddr_in sin;\n\tint callno;\n\tstruct create_addr_info cai;\n\n\tmemset(&cai, 0, sizeof(cai));\n\n\tast_debug(1, \"Provisioning '%s' from template '%s'\\n\", dest, template);\n\n\tif (iax_provision_build(&provdata, &sig, template, force)) {\n\t\tast_debug(1, \"No provisioning found for template '%s'\\n\", template);\n\t\treturn 0;\n\t}\n\n\tif (end) {\n\t\tmemcpy(&sin, end, sizeof(sin));\n\t\tcai.sockfd = sockfd;\n\t} else if (create_addr(dest, NULL, &sin, &cai))\n\t\treturn -1;\n\n\t/* Build the rest of the message */\n\tmemset(&ied, 0, sizeof(ied));\n\tiax_ie_append_raw(&ied, IAX_IE_PROVISIONING, provdata.buf, provdata.pos);\n\n\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd);\n\tif (!callno)\n\t\treturn -1;\n\n\tif (iaxs[callno]) {\n\t\t/* Schedule autodestruct in case they don't ever give us anything back */\n\t\tiaxs[callno]->autoid = iax2_sched_replace(iaxs[callno]->autoid, \n\t\t\tsched, 15000, auto_hangup, (void *)(long)callno);\n\t\tast_set_flag(iaxs[callno], IAX_PROVISION);\n\t\t/* Got a call number now, so go ahead and send the provisioning information */\n\t\tsend_command(iaxs[callno], AST_FRAME_IAX, IAX_COMMAND_PROVISION, 0, ied.buf, ied.pos, -1);\n\t}\n\tast_mutex_unlock(&iaxsl[callno]);\n\n\treturn 1;\n}",
        "func": "static int iax2_provision(struct sockaddr_in *end, int sockfd, char *dest, const char *template, int force)\n{\n\t/* Returns 1 if provisioned, -1 if not able to find destination, or 0 if no provisioning\n\t   is found for template */\n\tstruct iax_ie_data provdata;\n\tstruct iax_ie_data ied;\n\tunsigned int sig;\n\tstruct sockaddr_in sin;\n\tint callno;\n\tstruct create_addr_info cai;\n\n\tmemset(&cai, 0, sizeof(cai));\n\n\tast_debug(1, \"Provisioning '%s' from template '%s'\\n\", dest, template);\n\n\tif (iax_provision_build(&provdata, &sig, template, force)) {\n\t\tast_debug(1, \"No provisioning found for template '%s'\\n\", template);\n\t\treturn 0;\n\t}\n\n\tif (end) {\n\t\tmemcpy(&sin, end, sizeof(sin));\n\t\tcai.sockfd = sockfd;\n\t} else if (create_addr(dest, NULL, &sin, &cai))\n\t\treturn -1;\n\n\t/* Build the rest of the message */\n\tmemset(&ied, 0, sizeof(ied));\n\tiax_ie_append_raw(&ied, IAX_IE_PROVISIONING, provdata.buf, provdata.pos);\n\n\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd, 0);\n\tif (!callno)\n\t\treturn -1;\n\n\tif (iaxs[callno]) {\n\t\t/* Schedule autodestruct in case they don't ever give us anything back */\n\t\tiaxs[callno]->autoid = iax2_sched_replace(iaxs[callno]->autoid, \n\t\t\tsched, 15000, auto_hangup, (void *)(long)callno);\n\t\tast_set_flag(iaxs[callno], IAX_PROVISION);\n\t\t/* Got a call number now, so go ahead and send the provisioning information */\n\t\tsend_command(iaxs[callno], AST_FRAME_IAX, IAX_COMMAND_PROVISION, 0, ied.buf, ied.pos, -1);\n\t}\n\tast_mutex_unlock(&iaxsl[callno]);\n\n\treturn 1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -28,7 +28,7 @@\n \tmemset(&ied, 0, sizeof(ied));\n \tiax_ie_append_raw(&ied, IAX_IE_PROVISIONING, provdata.buf, provdata.pos);\n \n-\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd);\n+\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd, 0);\n \tif (!callno)\n \t\treturn -1;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd);"
            ],
            "added_lines": [
                "\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd, 0);"
            ]
        }
    },
    {
        "cve_id": "CVE-2008-1897",
        "func_name": "jcollie/asterisk/match",
        "description": "The IAX2 channel driver (chan_iax2) in Asterisk Open Source 1.0.x, 1.2.x before 1.2.28, and 1.4.x before 1.4.19.1; Business Edition A.x.x, B.x.x before B.2.5.2, and C.x.x before C.1.8.1; AsteriskNOW before 1.0.3; Appliance Developer Kit 0.x.x; and s800i before 1.1.0.3, when configured to allow unauthenticated calls, does not verify that an ACK response contains a call number matching the server's reply to a NEW message, which allows remote attackers to cause a denial of service (traffic amplification) via a spoofed ACK response that does not complete a 3-way handshake.  NOTE: this issue exists because of an incomplete fix for CVE-2008-1923.",
        "git_url": "https://github.com/jcollie/asterisk/commit/771b3d8749b34b6eea4e03a2e514380da9582f90",
        "commit_title": "Merged revisions 114558 via svnmerge from ",
        "commit_text": "https://origsvn.digium.com/svn/asterisk/branches/1.4  ........ r114558 | russell | 2008-04-22 17:15:36 -0500 (Tue, 22 Apr 2008) | 5 lines  When we receive a full frame that is supposed to contain our call number, ensure that it has the correct one. (closes issue #10078) (AST-2008-006)  ........  ",
        "func_before": "static int match(struct sockaddr_in *sin, unsigned short callno, unsigned short dcallno, const struct chan_iax2_pvt *cur)\n{\n\tif ((cur->addr.sin_addr.s_addr == sin->sin_addr.s_addr) &&\n\t\t(cur->addr.sin_port == sin->sin_port)) {\n\t\t/* This is the main host */\n\t\tif ((cur->peercallno == callno) ||\n\t\t\t((dcallno == cur->callno) && !cur->peercallno)) {\n\t\t\t/* That's us.  Be sure we keep track of the peer call number */\n\t\t\treturn 1;\n\t\t}\n\t}\n\tif ((cur->transfer.sin_addr.s_addr == sin->sin_addr.s_addr) &&\n\t    (cur->transfer.sin_port == sin->sin_port) && (cur->transferring)) {\n\t\t/* We're transferring */\n\t\tif ((dcallno == cur->callno) || (cur->transferring == TRANSFER_MEDIAPASS && cur->transfercallno == callno))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
        "func": "static int match(struct sockaddr_in *sin, unsigned short callno, unsigned short dcallno, const struct chan_iax2_pvt *cur, int full_frame)\n{\n\tif ((cur->addr.sin_addr.s_addr == sin->sin_addr.s_addr) &&\n\t\t(cur->addr.sin_port == sin->sin_port)) {\n\t\t/* This is the main host */\n\t\tif ( (cur->peercallno == 0 || cur->peercallno == callno) &&\n\t\t\t (full_frame ? dcallno == cur->callno : 1) ) {\n\t\t\t/* That's us.  Be sure we keep track of the peer call number */\n\t\t\treturn 1;\n\t\t}\n\t}\n\tif ((cur->transfer.sin_addr.s_addr == sin->sin_addr.s_addr) &&\n\t    (cur->transfer.sin_port == sin->sin_port) && (cur->transferring)) {\n\t\t/* We're transferring */\n\t\tif ((dcallno == cur->callno) || (cur->transferring == TRANSFER_MEDIAPASS && cur->transfercallno == callno))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,10 +1,10 @@\n-static int match(struct sockaddr_in *sin, unsigned short callno, unsigned short dcallno, const struct chan_iax2_pvt *cur)\n+static int match(struct sockaddr_in *sin, unsigned short callno, unsigned short dcallno, const struct chan_iax2_pvt *cur, int full_frame)\n {\n \tif ((cur->addr.sin_addr.s_addr == sin->sin_addr.s_addr) &&\n \t\t(cur->addr.sin_port == sin->sin_port)) {\n \t\t/* This is the main host */\n-\t\tif ((cur->peercallno == callno) ||\n-\t\t\t((dcallno == cur->callno) && !cur->peercallno)) {\n+\t\tif ( (cur->peercallno == 0 || cur->peercallno == callno) &&\n+\t\t\t (full_frame ? dcallno == cur->callno : 1) ) {\n \t\t\t/* That's us.  Be sure we keep track of the peer call number */\n \t\t\treturn 1;\n \t\t}",
        "diff_line_info": {
            "deleted_lines": [
                "static int match(struct sockaddr_in *sin, unsigned short callno, unsigned short dcallno, const struct chan_iax2_pvt *cur)",
                "\t\tif ((cur->peercallno == callno) ||",
                "\t\t\t((dcallno == cur->callno) && !cur->peercallno)) {"
            ],
            "added_lines": [
                "static int match(struct sockaddr_in *sin, unsigned short callno, unsigned short dcallno, const struct chan_iax2_pvt *cur, int full_frame)",
                "\t\tif ( (cur->peercallno == 0 || cur->peercallno == callno) &&",
                "\t\t\t (full_frame ? dcallno == cur->callno : 1) ) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2008-1897",
        "func_name": "jcollie/asterisk/socket_process_meta",
        "description": "The IAX2 channel driver (chan_iax2) in Asterisk Open Source 1.0.x, 1.2.x before 1.2.28, and 1.4.x before 1.4.19.1; Business Edition A.x.x, B.x.x before B.2.5.2, and C.x.x before C.1.8.1; AsteriskNOW before 1.0.3; Appliance Developer Kit 0.x.x; and s800i before 1.1.0.3, when configured to allow unauthenticated calls, does not verify that an ACK response contains a call number matching the server's reply to a NEW message, which allows remote attackers to cause a denial of service (traffic amplification) via a spoofed ACK response that does not complete a 3-way handshake.  NOTE: this issue exists because of an incomplete fix for CVE-2008-1923.",
        "git_url": "https://github.com/jcollie/asterisk/commit/771b3d8749b34b6eea4e03a2e514380da9582f90",
        "commit_title": "Merged revisions 114558 via svnmerge from ",
        "commit_text": "https://origsvn.digium.com/svn/asterisk/branches/1.4  ........ r114558 | russell | 2008-04-22 17:15:36 -0500 (Tue, 22 Apr 2008) | 5 lines  When we receive a full frame that is supposed to contain our call number, ensure that it has the correct one. (closes issue #10078) (AST-2008-006)  ........  ",
        "func_before": "static int socket_process_meta(int packet_len, struct ast_iax2_meta_hdr *meta, struct sockaddr_in *sin, int sockfd,\n\tstruct iax_frame *fr)\n{\n\tunsigned char metatype;\n\tstruct ast_iax2_meta_trunk_mini *mtm;\n\tstruct ast_iax2_meta_trunk_hdr *mth;\n\tstruct ast_iax2_meta_trunk_entry *mte;\n\tstruct iax2_trunk_peer *tpeer;\n\tunsigned int ts;\n\tvoid *ptr;\n\tstruct timeval rxtrunktime;\n\tstruct ast_frame f = { 0, };\n\n\tif (packet_len < sizeof(*meta)) {\n\t\tast_log(LOG_WARNING, \"Rejecting packet from '%s.%d' that is flagged as a meta frame but is too short\\n\", \n\t\t\tast_inet_ntoa(sin->sin_addr), ntohs(sin->sin_port));\n\t\treturn 1;\n\t}\n\n\tif (meta->metacmd != IAX_META_TRUNK)\n\t\treturn 1;\n\n\tif (packet_len < (sizeof(*meta) + sizeof(*mth))) {\n\t\tast_log(LOG_WARNING, \"midget meta trunk packet received (%d of %d min)\\n\", packet_len,\n\t\t\t(int) (sizeof(*meta) + sizeof(*mth)));\n\t\treturn 1;\n\t}\n\tmth = (struct ast_iax2_meta_trunk_hdr *)(meta->data);\n\tts = ntohl(mth->ts);\n\tmetatype = meta->cmddata;\n\tpacket_len -= (sizeof(*meta) + sizeof(*mth));\n\tptr = mth->data;\n\ttpeer = find_tpeer(sin, sockfd);\n\tif (!tpeer) {\n\t\tast_log(LOG_WARNING, \"Unable to accept trunked packet from '%s:%d': No matching peer\\n\", \n\t\t\tast_inet_ntoa(sin->sin_addr), ntohs(sin->sin_port));\n\t\treturn 1;\n\t}\n\ttpeer->trunkact = ast_tvnow();\n\tif (!ts || ast_tvzero(tpeer->rxtrunktime))\n\t\ttpeer->rxtrunktime = tpeer->trunkact;\n\trxtrunktime = tpeer->rxtrunktime;\n\tast_mutex_unlock(&tpeer->lock);\n\twhile (packet_len >= sizeof(*mte)) {\n\t\t/* Process channels */\n\t\tunsigned short callno, trunked_ts, len;\n\n\t\tif (metatype == IAX_META_TRUNK_MINI) {\n\t\t\tmtm = (struct ast_iax2_meta_trunk_mini *) ptr;\n\t\t\tptr += sizeof(*mtm);\n\t\t\tpacket_len -= sizeof(*mtm);\n\t\t\tlen = ntohs(mtm->len);\n\t\t\tcallno = ntohs(mtm->mini.callno);\n\t\t\ttrunked_ts = ntohs(mtm->mini.ts);\n\t\t} else if (metatype == IAX_META_TRUNK_SUPERMINI) {\n\t\t\tmte = (struct ast_iax2_meta_trunk_entry *)ptr;\n\t\t\tptr += sizeof(*mte);\n\t\t\tpacket_len -= sizeof(*mte);\n\t\t\tlen = ntohs(mte->len);\n\t\t\tcallno = ntohs(mte->callno);\n\t\t\ttrunked_ts = 0;\n\t\t} else {\n\t\t\tast_log(LOG_WARNING, \"Unknown meta trunk cmd from '%s:%d': dropping\\n\", ast_inet_ntoa(sin->sin_addr), ntohs(sin->sin_port));\n\t\t\tbreak;\n\t\t}\n\t\t/* Stop if we don't have enough data */\n\t\tif (len > packet_len)\n\t\t\tbreak;\n\t\tfr->callno = find_callno_locked(callno & ~IAX_FLAG_FULL, 0, sin, NEW_PREVENT, sockfd);\n\t\tif (!fr->callno)\n\t\t\tcontinue;\n\n\t\t/* If it's a valid call, deliver the contents.  If not, we\n\t\t   drop it, since we don't have a scallno to use for an INVAL */\n\t\t/* Process as a mini frame */\n\t\tmemset(&f, 0, sizeof(f));\n\t\tf.frametype = AST_FRAME_VOICE;\n\t\tif (!iaxs[fr->callno]) {\n\t\t\t/* drop it */\n\t\t} else if (iaxs[fr->callno]->voiceformat == 0) {\n\t\t\tast_log(LOG_WARNING, \"Received trunked frame before first full voice frame\\n \");\n\t\t\tiax2_vnak(fr->callno);\n\t\t} else {\n\t\t\tf.subclass = iaxs[fr->callno]->voiceformat;\n\t\t\tf.datalen = len;\n\t\t\tif (f.datalen >= 0) {\n\t\t\t\tif (f.datalen)\n\t\t\t\t\tf.data = ptr;\n\t\t\t\telse\n\t\t\t\t\tf.data = NULL;\n\t\t\t\tif (trunked_ts)\n\t\t\t\t\tfr->ts = (iaxs[fr->callno]->last & 0xFFFF0000L) | (trunked_ts & 0xffff);\n\t\t\t\telse\n\t\t\t\t\tfr->ts = fix_peerts(&rxtrunktime, fr->callno, ts);\n\t\t\t\t/* Don't pass any packets until we're started */\n\t\t\t\tif (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)) {\n\t\t\t\t\tstruct iax_frame *duped_fr;\n\n\t\t\t\t\t/* Common things */\n\t\t\t\t\tf.src = \"IAX2\";\n\t\t\t\t\tf.mallocd = 0;\n\t\t\t\t\tf.offset = 0;\n\t\t\t\t\tif (f.datalen && (f.frametype == AST_FRAME_VOICE)) \n\t\t\t\t\t\tf.samples = ast_codec_get_samples(&f);\n\t\t\t\t\telse\n\t\t\t\t\t\tf.samples = 0;\n\t\t\t\t\tfr->outoforder = 0;\n\t\t\t\t\tiax_frame_wrap(fr, &f);\n\t\t\t\t\tduped_fr = iaxfrdup2(fr);\n\t\t\t\t\tif (duped_fr)\n\t\t\t\t\t\tschedule_delivery(duped_fr, 1, 1, &fr->ts);\n\t\t\t\t\tif (iaxs[fr->callno] && iaxs[fr->callno]->last < fr->ts)\n\t\t\t\t\t\tiaxs[fr->callno]->last = fr->ts;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tast_log(LOG_WARNING, \"Datalen < 0?\\n\");\n\t\t\t}\n\t\t}\n\t\tast_mutex_unlock(&iaxsl[fr->callno]);\n\t\tptr += len;\n\t\tpacket_len -= len;\n\t}\n\n\treturn 1;\n}",
        "func": "static int socket_process_meta(int packet_len, struct ast_iax2_meta_hdr *meta, struct sockaddr_in *sin, int sockfd,\n\tstruct iax_frame *fr)\n{\n\tunsigned char metatype;\n\tstruct ast_iax2_meta_trunk_mini *mtm;\n\tstruct ast_iax2_meta_trunk_hdr *mth;\n\tstruct ast_iax2_meta_trunk_entry *mte;\n\tstruct iax2_trunk_peer *tpeer;\n\tunsigned int ts;\n\tvoid *ptr;\n\tstruct timeval rxtrunktime;\n\tstruct ast_frame f = { 0, };\n\n\tif (packet_len < sizeof(*meta)) {\n\t\tast_log(LOG_WARNING, \"Rejecting packet from '%s.%d' that is flagged as a meta frame but is too short\\n\", \n\t\t\tast_inet_ntoa(sin->sin_addr), ntohs(sin->sin_port));\n\t\treturn 1;\n\t}\n\n\tif (meta->metacmd != IAX_META_TRUNK)\n\t\treturn 1;\n\n\tif (packet_len < (sizeof(*meta) + sizeof(*mth))) {\n\t\tast_log(LOG_WARNING, \"midget meta trunk packet received (%d of %d min)\\n\", packet_len,\n\t\t\t(int) (sizeof(*meta) + sizeof(*mth)));\n\t\treturn 1;\n\t}\n\tmth = (struct ast_iax2_meta_trunk_hdr *)(meta->data);\n\tts = ntohl(mth->ts);\n\tmetatype = meta->cmddata;\n\tpacket_len -= (sizeof(*meta) + sizeof(*mth));\n\tptr = mth->data;\n\ttpeer = find_tpeer(sin, sockfd);\n\tif (!tpeer) {\n\t\tast_log(LOG_WARNING, \"Unable to accept trunked packet from '%s:%d': No matching peer\\n\", \n\t\t\tast_inet_ntoa(sin->sin_addr), ntohs(sin->sin_port));\n\t\treturn 1;\n\t}\n\ttpeer->trunkact = ast_tvnow();\n\tif (!ts || ast_tvzero(tpeer->rxtrunktime))\n\t\ttpeer->rxtrunktime = tpeer->trunkact;\n\trxtrunktime = tpeer->rxtrunktime;\n\tast_mutex_unlock(&tpeer->lock);\n\twhile (packet_len >= sizeof(*mte)) {\n\t\t/* Process channels */\n\t\tunsigned short callno, trunked_ts, len;\n\n\t\tif (metatype == IAX_META_TRUNK_MINI) {\n\t\t\tmtm = (struct ast_iax2_meta_trunk_mini *) ptr;\n\t\t\tptr += sizeof(*mtm);\n\t\t\tpacket_len -= sizeof(*mtm);\n\t\t\tlen = ntohs(mtm->len);\n\t\t\tcallno = ntohs(mtm->mini.callno);\n\t\t\ttrunked_ts = ntohs(mtm->mini.ts);\n\t\t} else if (metatype == IAX_META_TRUNK_SUPERMINI) {\n\t\t\tmte = (struct ast_iax2_meta_trunk_entry *)ptr;\n\t\t\tptr += sizeof(*mte);\n\t\t\tpacket_len -= sizeof(*mte);\n\t\t\tlen = ntohs(mte->len);\n\t\t\tcallno = ntohs(mte->callno);\n\t\t\ttrunked_ts = 0;\n\t\t} else {\n\t\t\tast_log(LOG_WARNING, \"Unknown meta trunk cmd from '%s:%d': dropping\\n\", ast_inet_ntoa(sin->sin_addr), ntohs(sin->sin_port));\n\t\t\tbreak;\n\t\t}\n\t\t/* Stop if we don't have enough data */\n\t\tif (len > packet_len)\n\t\t\tbreak;\n\t\tfr->callno = find_callno_locked(callno & ~IAX_FLAG_FULL, 0, sin, NEW_PREVENT, sockfd, 0);\n\t\tif (!fr->callno)\n\t\t\tcontinue;\n\n\t\t/* If it's a valid call, deliver the contents.  If not, we\n\t\t   drop it, since we don't have a scallno to use for an INVAL */\n\t\t/* Process as a mini frame */\n\t\tmemset(&f, 0, sizeof(f));\n\t\tf.frametype = AST_FRAME_VOICE;\n\t\tif (!iaxs[fr->callno]) {\n\t\t\t/* drop it */\n\t\t} else if (iaxs[fr->callno]->voiceformat == 0) {\n\t\t\tast_log(LOG_WARNING, \"Received trunked frame before first full voice frame\\n \");\n\t\t\tiax2_vnak(fr->callno);\n\t\t} else {\n\t\t\tf.subclass = iaxs[fr->callno]->voiceformat;\n\t\t\tf.datalen = len;\n\t\t\tif (f.datalen >= 0) {\n\t\t\t\tif (f.datalen)\n\t\t\t\t\tf.data = ptr;\n\t\t\t\telse\n\t\t\t\t\tf.data = NULL;\n\t\t\t\tif (trunked_ts)\n\t\t\t\t\tfr->ts = (iaxs[fr->callno]->last & 0xFFFF0000L) | (trunked_ts & 0xffff);\n\t\t\t\telse\n\t\t\t\t\tfr->ts = fix_peerts(&rxtrunktime, fr->callno, ts);\n\t\t\t\t/* Don't pass any packets until we're started */\n\t\t\t\tif (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)) {\n\t\t\t\t\tstruct iax_frame *duped_fr;\n\n\t\t\t\t\t/* Common things */\n\t\t\t\t\tf.src = \"IAX2\";\n\t\t\t\t\tf.mallocd = 0;\n\t\t\t\t\tf.offset = 0;\n\t\t\t\t\tif (f.datalen && (f.frametype == AST_FRAME_VOICE)) \n\t\t\t\t\t\tf.samples = ast_codec_get_samples(&f);\n\t\t\t\t\telse\n\t\t\t\t\t\tf.samples = 0;\n\t\t\t\t\tfr->outoforder = 0;\n\t\t\t\t\tiax_frame_wrap(fr, &f);\n\t\t\t\t\tduped_fr = iaxfrdup2(fr);\n\t\t\t\t\tif (duped_fr)\n\t\t\t\t\t\tschedule_delivery(duped_fr, 1, 1, &fr->ts);\n\t\t\t\t\tif (iaxs[fr->callno] && iaxs[fr->callno]->last < fr->ts)\n\t\t\t\t\t\tiaxs[fr->callno]->last = fr->ts;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tast_log(LOG_WARNING, \"Datalen < 0?\\n\");\n\t\t\t}\n\t\t}\n\t\tast_mutex_unlock(&iaxsl[fr->callno]);\n\t\tptr += len;\n\t\tpacket_len -= len;\n\t}\n\n\treturn 1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -66,7 +66,7 @@\n \t\t/* Stop if we don't have enough data */\n \t\tif (len > packet_len)\n \t\t\tbreak;\n-\t\tfr->callno = find_callno_locked(callno & ~IAX_FLAG_FULL, 0, sin, NEW_PREVENT, sockfd);\n+\t\tfr->callno = find_callno_locked(callno & ~IAX_FLAG_FULL, 0, sin, NEW_PREVENT, sockfd, 0);\n \t\tif (!fr->callno)\n \t\t\tcontinue;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tfr->callno = find_callno_locked(callno & ~IAX_FLAG_FULL, 0, sin, NEW_PREVENT, sockfd);"
            ],
            "added_lines": [
                "\t\tfr->callno = find_callno_locked(callno & ~IAX_FLAG_FULL, 0, sin, NEW_PREVENT, sockfd, 0);"
            ]
        }
    },
    {
        "cve_id": "CVE-2008-1897",
        "func_name": "jcollie/asterisk/find_callno_locked",
        "description": "The IAX2 channel driver (chan_iax2) in Asterisk Open Source 1.0.x, 1.2.x before 1.2.28, and 1.4.x before 1.4.19.1; Business Edition A.x.x, B.x.x before B.2.5.2, and C.x.x before C.1.8.1; AsteriskNOW before 1.0.3; Appliance Developer Kit 0.x.x; and s800i before 1.1.0.3, when configured to allow unauthenticated calls, does not verify that an ACK response contains a call number matching the server's reply to a NEW message, which allows remote attackers to cause a denial of service (traffic amplification) via a spoofed ACK response that does not complete a 3-way handshake.  NOTE: this issue exists because of an incomplete fix for CVE-2008-1923.",
        "git_url": "https://github.com/jcollie/asterisk/commit/771b3d8749b34b6eea4e03a2e514380da9582f90",
        "commit_title": "Merged revisions 114558 via svnmerge from ",
        "commit_text": "https://origsvn.digium.com/svn/asterisk/branches/1.4  ........ r114558 | russell | 2008-04-22 17:15:36 -0500 (Tue, 22 Apr 2008) | 5 lines  When we receive a full frame that is supposed to contain our call number, ensure that it has the correct one. (closes issue #10078) (AST-2008-006)  ........  ",
        "func_before": "static int find_callno_locked(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd) {\n\n\treturn __find_callno(callno, dcallno, sin, new, sockfd, 1);\n}",
        "func": "static int find_callno_locked(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int full_frame) {\n\n\treturn __find_callno(callno, dcallno, sin, new, sockfd, 1, full_frame);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,4 @@\n-static int find_callno_locked(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd) {\n+static int find_callno_locked(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int full_frame) {\n \n-\treturn __find_callno(callno, dcallno, sin, new, sockfd, 1);\n+\treturn __find_callno(callno, dcallno, sin, new, sockfd, 1, full_frame);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "static int find_callno_locked(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd) {",
                "\treturn __find_callno(callno, dcallno, sin, new, sockfd, 1);"
            ],
            "added_lines": [
                "static int find_callno_locked(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int full_frame) {",
                "\treturn __find_callno(callno, dcallno, sin, new, sockfd, 1, full_frame);"
            ]
        }
    },
    {
        "cve_id": "CVE-2008-1897",
        "func_name": "jcollie/asterisk/iax2_request",
        "description": "The IAX2 channel driver (chan_iax2) in Asterisk Open Source 1.0.x, 1.2.x before 1.2.28, and 1.4.x before 1.4.19.1; Business Edition A.x.x, B.x.x before B.2.5.2, and C.x.x before C.1.8.1; AsteriskNOW before 1.0.3; Appliance Developer Kit 0.x.x; and s800i before 1.1.0.3, when configured to allow unauthenticated calls, does not verify that an ACK response contains a call number matching the server's reply to a NEW message, which allows remote attackers to cause a denial of service (traffic amplification) via a spoofed ACK response that does not complete a 3-way handshake.  NOTE: this issue exists because of an incomplete fix for CVE-2008-1923.",
        "git_url": "https://github.com/jcollie/asterisk/commit/771b3d8749b34b6eea4e03a2e514380da9582f90",
        "commit_title": "Merged revisions 114558 via svnmerge from ",
        "commit_text": "https://origsvn.digium.com/svn/asterisk/branches/1.4  ........ r114558 | russell | 2008-04-22 17:15:36 -0500 (Tue, 22 Apr 2008) | 5 lines  When we receive a full frame that is supposed to contain our call number, ensure that it has the correct one. (closes issue #10078) (AST-2008-006)  ........  ",
        "func_before": "static struct ast_channel *iax2_request(const char *type, int format, void *data, int *cause)\n{\n\tint callno;\n\tint res;\n\tint fmt, native;\n\tstruct sockaddr_in sin;\n\tstruct ast_channel *c;\n\tstruct parsed_dial_string pds;\n\tstruct create_addr_info cai;\n\tchar *tmpstr;\n\n\tmemset(&pds, 0, sizeof(pds));\n\ttmpstr = ast_strdupa(data);\n\tparse_dial_string(tmpstr, &pds);\n\n\tif (ast_strlen_zero(pds.peer)) {\n\t\tast_log(LOG_WARNING, \"No peer provided in the IAX2 dial string '%s'\\n\", (char *) data);\n\t\treturn NULL;\n\t}\n\t       \n\tmemset(&cai, 0, sizeof(cai));\n\tcai.capability = iax2_capability;\n\n\tast_copy_flags(&cai, &globalflags, IAX_NOTRANSFER | IAX_TRANSFERMEDIA | IAX_USEJITTERBUF | IAX_FORCEJITTERBUF);\n\t\n\t/* Populate our address from the given */\n\tif (create_addr(pds.peer, NULL, &sin, &cai)) {\n\t\t*cause = AST_CAUSE_UNREGISTERED;\n\t\treturn NULL;\n\t}\n\n\tif (pds.port)\n\t\tsin.sin_port = htons(atoi(pds.port));\n\n\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd);\n\tif (callno < 1) {\n\t\tast_log(LOG_WARNING, \"Unable to create call\\n\");\n\t\t*cause = AST_CAUSE_CONGESTION;\n\t\treturn NULL;\n\t}\n\n\t/* If this is a trunk, update it now */\n\tast_copy_flags(iaxs[callno], &cai, IAX_TRUNK | IAX_SENDANI | IAX_NOTRANSFER | IAX_TRANSFERMEDIA | IAX_USEJITTERBUF | IAX_FORCEJITTERBUF);\t\n\tif (ast_test_flag(&cai, IAX_TRUNK)) {\n\t\tint new_callno;\n\t\tif ((new_callno = make_trunk(callno, 1)) != -1)\n\t\t\tcallno = new_callno;\n\t}\n\tiaxs[callno]->maxtime = cai.maxtime;\n\tif (cai.found)\n\t\tast_string_field_set(iaxs[callno], host, pds.peer);\n\n\tc = ast_iax2_new(callno, AST_STATE_DOWN, cai.capability);\n\n\tast_mutex_unlock(&iaxsl[callno]);\n\n\tif (c) {\n\t\t/* Choose a format we can live with */\n\t\tif (c->nativeformats & format) \n\t\t\tc->nativeformats &= format;\n\t\telse {\n\t\t\tnative = c->nativeformats;\n\t\t\tfmt = format;\n\t\t\tres = ast_translator_best_choice(&fmt, &native);\n\t\t\tif (res < 0) {\n\t\t\t\tast_log(LOG_WARNING, \"Unable to create translator path for %s to %s on %s\\n\",\n\t\t\t\t\tast_getformatname(c->nativeformats), ast_getformatname(fmt), c->name);\n\t\t\t\tast_hangup(c);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tc->nativeformats = native;\n\t\t}\n\t\tc->readformat = ast_best_codec(c->nativeformats);\n\t\tc->writeformat = c->readformat;\n\t}\n\n\treturn c;\n}",
        "func": "static struct ast_channel *iax2_request(const char *type, int format, void *data, int *cause)\n{\n\tint callno;\n\tint res;\n\tint fmt, native;\n\tstruct sockaddr_in sin;\n\tstruct ast_channel *c;\n\tstruct parsed_dial_string pds;\n\tstruct create_addr_info cai;\n\tchar *tmpstr;\n\n\tmemset(&pds, 0, sizeof(pds));\n\ttmpstr = ast_strdupa(data);\n\tparse_dial_string(tmpstr, &pds);\n\n\tif (ast_strlen_zero(pds.peer)) {\n\t\tast_log(LOG_WARNING, \"No peer provided in the IAX2 dial string '%s'\\n\", (char *) data);\n\t\treturn NULL;\n\t}\n\t       \n\tmemset(&cai, 0, sizeof(cai));\n\tcai.capability = iax2_capability;\n\n\tast_copy_flags(&cai, &globalflags, IAX_NOTRANSFER | IAX_TRANSFERMEDIA | IAX_USEJITTERBUF | IAX_FORCEJITTERBUF);\n\t\n\t/* Populate our address from the given */\n\tif (create_addr(pds.peer, NULL, &sin, &cai)) {\n\t\t*cause = AST_CAUSE_UNREGISTERED;\n\t\treturn NULL;\n\t}\n\n\tif (pds.port)\n\t\tsin.sin_port = htons(atoi(pds.port));\n\n\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd, 0);\n\tif (callno < 1) {\n\t\tast_log(LOG_WARNING, \"Unable to create call\\n\");\n\t\t*cause = AST_CAUSE_CONGESTION;\n\t\treturn NULL;\n\t}\n\n\t/* If this is a trunk, update it now */\n\tast_copy_flags(iaxs[callno], &cai, IAX_TRUNK | IAX_SENDANI | IAX_NOTRANSFER | IAX_TRANSFERMEDIA | IAX_USEJITTERBUF | IAX_FORCEJITTERBUF);\t\n\tif (ast_test_flag(&cai, IAX_TRUNK)) {\n\t\tint new_callno;\n\t\tif ((new_callno = make_trunk(callno, 1)) != -1)\n\t\t\tcallno = new_callno;\n\t}\n\tiaxs[callno]->maxtime = cai.maxtime;\n\tif (cai.found)\n\t\tast_string_field_set(iaxs[callno], host, pds.peer);\n\n\tc = ast_iax2_new(callno, AST_STATE_DOWN, cai.capability);\n\n\tast_mutex_unlock(&iaxsl[callno]);\n\n\tif (c) {\n\t\t/* Choose a format we can live with */\n\t\tif (c->nativeformats & format) \n\t\t\tc->nativeformats &= format;\n\t\telse {\n\t\t\tnative = c->nativeformats;\n\t\t\tfmt = format;\n\t\t\tres = ast_translator_best_choice(&fmt, &native);\n\t\t\tif (res < 0) {\n\t\t\t\tast_log(LOG_WARNING, \"Unable to create translator path for %s to %s on %s\\n\",\n\t\t\t\t\tast_getformatname(c->nativeformats), ast_getformatname(fmt), c->name);\n\t\t\t\tast_hangup(c);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tc->nativeformats = native;\n\t\t}\n\t\tc->readformat = ast_best_codec(c->nativeformats);\n\t\tc->writeformat = c->readformat;\n\t}\n\n\treturn c;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -32,7 +32,7 @@\n \tif (pds.port)\n \t\tsin.sin_port = htons(atoi(pds.port));\n \n-\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd);\n+\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd, 0);\n \tif (callno < 1) {\n \t\tast_log(LOG_WARNING, \"Unable to create call\\n\");\n \t\t*cause = AST_CAUSE_CONGESTION;",
        "diff_line_info": {
            "deleted_lines": [
                "\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd);"
            ],
            "added_lines": [
                "\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd, 0);"
            ]
        }
    },
    {
        "cve_id": "CVE-2008-1897",
        "func_name": "jcollie/asterisk/__find_callno",
        "description": "The IAX2 channel driver (chan_iax2) in Asterisk Open Source 1.0.x, 1.2.x before 1.2.28, and 1.4.x before 1.4.19.1; Business Edition A.x.x, B.x.x before B.2.5.2, and C.x.x before C.1.8.1; AsteriskNOW before 1.0.3; Appliance Developer Kit 0.x.x; and s800i before 1.1.0.3, when configured to allow unauthenticated calls, does not verify that an ACK response contains a call number matching the server's reply to a NEW message, which allows remote attackers to cause a denial of service (traffic amplification) via a spoofed ACK response that does not complete a 3-way handshake.  NOTE: this issue exists because of an incomplete fix for CVE-2008-1923.",
        "git_url": "https://github.com/jcollie/asterisk/commit/771b3d8749b34b6eea4e03a2e514380da9582f90",
        "commit_title": "Merged revisions 114558 via svnmerge from ",
        "commit_text": "https://origsvn.digium.com/svn/asterisk/branches/1.4  ........ r114558 | russell | 2008-04-22 17:15:36 -0500 (Tue, 22 Apr 2008) | 5 lines  When we receive a full frame that is supposed to contain our call number, ensure that it has the correct one. (closes issue #10078) (AST-2008-006)  ........  ",
        "func_before": "static int __find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int return_locked)\n{\n\tint res = 0;\n\tint x;\n\tstruct timeval now;\n\tchar host[80];\n\n\tif (new <= NEW_ALLOW) {\n\t\tfor (x=1;(res < 1) && (x<maxnontrunkcall);x++) {\n\t\t\tast_mutex_lock(&iaxsl[x]);\n\t\t\tif (iaxs[x]) {\n\t\t\t\t/* Look for an exact match */\n\t\t\t\tif (match(sin, callno, dcallno, iaxs[x])) {\n\t\t\t\t\tres = x;\n\t\t\t\t}\n\t\t\t}\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t}\n\t\tfor (x=TRUNK_CALL_START;(res < 1) && (x<maxtrunkcall);x++) {\n\t\t\tast_mutex_lock(&iaxsl[x]);\n\t\t\tif (iaxs[x]) {\n\t\t\t\t/* Look for an exact match */\n\t\t\t\tif (match(sin, callno, dcallno, iaxs[x])) {\n\t\t\t\t\tres = x;\n\t\t\t\t}\n\t\t\t}\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t}\n\t}\n\tif ((res < 1) && (new >= NEW_ALLOW)) {\n\t\t/* It may seem odd that we look through the peer list for a name for\n\t\t * this *incoming* call.  Well, it is weird.  However, users don't\n\t\t * have an IP address/port number that we can match against.  So,\n\t\t * this is just checking for a peer that has that IP/port and\n\t\t * assuming that we have a user of the same name.  This isn't always\n\t\t * correct, but it will be changed if needed after authentication. */\n\t\tif (!iax2_getpeername(*sin, host, sizeof(host)))\n\t\t\tsnprintf(host, sizeof(host), \"%s:%d\", ast_inet_ntoa(sin->sin_addr), ntohs(sin->sin_port));\n\t\tnow = ast_tvnow();\n\t\tfor (x=1;x<TRUNK_CALL_START;x++) {\n\t\t\t/* Find first unused call number that hasn't been used in a while */\n\t\t\tast_mutex_lock(&iaxsl[x]);\n\t\t\tif (!iaxs[x] && ((now.tv_sec - lastused[x].tv_sec) > MIN_REUSE_TIME)) break;\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t}\n\t\t/* We've still got lock held if we found a spot */\n\t\tif (x >= TRUNK_CALL_START) {\n\t\t\tast_log(LOG_WARNING, \"No more space\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tiaxs[x] = new_iax(sin, host);\n\t\tupdate_max_nontrunk();\n\t\tif (iaxs[x]) {\n\t\t\tif (iaxdebug)\n\t\t\t\tast_debug(1, \"Creating new call structure %d\\n\", x);\n\t\t\tiaxs[x]->sockfd = sockfd;\n\t\t\tiaxs[x]->addr.sin_port = sin->sin_port;\n\t\t\tiaxs[x]->addr.sin_family = sin->sin_family;\n\t\t\tiaxs[x]->addr.sin_addr.s_addr = sin->sin_addr.s_addr;\n\t\t\tiaxs[x]->peercallno = callno;\n\t\t\tiaxs[x]->callno = x;\n\t\t\tiaxs[x]->pingtime = DEFAULT_RETRY_TIME;\n\t\t\tiaxs[x]->expiry = min_reg_expire;\n\t\t\tiaxs[x]->pingid = iax2_sched_add(sched, ping_time * 1000, send_ping, (void *)(long)x);\n\t\t\tiaxs[x]->lagid = iax2_sched_add(sched, lagrq_time * 1000, send_lagrq, (void *)(long)x);\n\t\t\tiaxs[x]->amaflags = amaflags;\n\t\t\tast_copy_flags(iaxs[x], (&globalflags), IAX_NOTRANSFER | IAX_TRANSFERMEDIA | IAX_USEJITTERBUF | IAX_FORCEJITTERBUF);\n\t\t\t\n\t\t\tast_string_field_set(iaxs[x], accountcode, accountcode);\n\t\t\tast_string_field_set(iaxs[x], mohinterpret, mohinterpret);\n\t\t\tast_string_field_set(iaxs[x], mohsuggest, mohsuggest);\n\t\t\tast_string_field_set(iaxs[x], parkinglot, default_parkinglot);\n\t\t} else {\n\t\t\tast_log(LOG_WARNING, \"Out of resources\\n\");\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t\treturn 0;\n\t\t}\n\t\tif (!return_locked)\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\tres = x;\n\t}\n\treturn res;\n}",
        "func": "static int __find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int return_locked, int full_frame)\n{\n\tint res = 0;\n\tint x;\n\tstruct timeval now;\n\tchar host[80];\n\n\tif (new <= NEW_ALLOW) {\n\t\tfor (x=1;(res < 1) && (x<maxnontrunkcall);x++) {\n\t\t\tast_mutex_lock(&iaxsl[x]);\n\t\t\tif (iaxs[x]) {\n\t\t\t\t/* Look for an exact match */\n\t\t\t\tif (match(sin, callno, dcallno, iaxs[x], full_frame)) {\n\t\t\t\t\tres = x;\n\t\t\t\t}\n\t\t\t}\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t}\n\t\tfor (x=TRUNK_CALL_START;(res < 1) && (x<maxtrunkcall);x++) {\n\t\t\tast_mutex_lock(&iaxsl[x]);\n\t\t\tif (iaxs[x]) {\n\t\t\t\t/* Look for an exact match */\n\t\t\t\tif (match(sin, callno, dcallno, iaxs[x], full_frame)) {\n\t\t\t\t\tres = x;\n\t\t\t\t}\n\t\t\t}\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t}\n\t}\n\tif ((res < 1) && (new >= NEW_ALLOW)) {\n\t\tint start, found = 0;\n\n\t\t/* It may seem odd that we look through the peer list for a name for\n\t\t * this *incoming* call.  Well, it is weird.  However, users don't\n\t\t * have an IP address/port number that we can match against.  So,\n\t\t * this is just checking for a peer that has that IP/port and\n\t\t * assuming that we have a user of the same name.  This isn't always\n\t\t * correct, but it will be changed if needed after authentication. */\n\t\tif (!iax2_getpeername(*sin, host, sizeof(host)))\n\t\t\tsnprintf(host, sizeof(host), \"%s:%d\", ast_inet_ntoa(sin->sin_addr), ntohs(sin->sin_port));\n\n\t\tnow = ast_tvnow();\n\t\tstart = 1 + (ast_random() % (TRUNK_CALL_START - 1));\n\t\tfor (x = start; 1; x++) {\n\t\t\tif (x == TRUNK_CALL_START) {\n\t\t\t\tx = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* Find first unused call number that hasn't been used in a while */\n\t\t\tast_mutex_lock(&iaxsl[x]);\n\t\t\tif (!iaxs[x] && ((now.tv_sec - lastused[x].tv_sec) > MIN_REUSE_TIME)) {\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t\t\n\t\t\tif (x == start - 1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/* We've still got lock held if we found a spot */\n\t\tif (x == start - 1 && !found) {\n\t\t\tast_log(LOG_WARNING, \"No more space\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tiaxs[x] = new_iax(sin, host);\n\t\tupdate_max_nontrunk();\n\t\tif (iaxs[x]) {\n\t\t\tif (iaxdebug)\n\t\t\t\tast_debug(1, \"Creating new call structure %d\\n\", x);\n\t\t\tiaxs[x]->sockfd = sockfd;\n\t\t\tiaxs[x]->addr.sin_port = sin->sin_port;\n\t\t\tiaxs[x]->addr.sin_family = sin->sin_family;\n\t\t\tiaxs[x]->addr.sin_addr.s_addr = sin->sin_addr.s_addr;\n\t\t\tiaxs[x]->peercallno = callno;\n\t\t\tiaxs[x]->callno = x;\n\t\t\tiaxs[x]->pingtime = DEFAULT_RETRY_TIME;\n\t\t\tiaxs[x]->expiry = min_reg_expire;\n\t\t\tiaxs[x]->pingid = iax2_sched_add(sched, ping_time * 1000, send_ping, (void *)(long)x);\n\t\t\tiaxs[x]->lagid = iax2_sched_add(sched, lagrq_time * 1000, send_lagrq, (void *)(long)x);\n\t\t\tiaxs[x]->amaflags = amaflags;\n\t\t\tast_copy_flags(iaxs[x], (&globalflags), IAX_NOTRANSFER | IAX_TRANSFERMEDIA | IAX_USEJITTERBUF | IAX_FORCEJITTERBUF);\n\t\t\t\n\t\t\tast_string_field_set(iaxs[x], accountcode, accountcode);\n\t\t\tast_string_field_set(iaxs[x], mohinterpret, mohinterpret);\n\t\t\tast_string_field_set(iaxs[x], mohsuggest, mohsuggest);\n\t\t\tast_string_field_set(iaxs[x], parkinglot, default_parkinglot);\n\t\t} else {\n\t\t\tast_log(LOG_WARNING, \"Out of resources\\n\");\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t\treturn 0;\n\t\t}\n\t\tif (!return_locked)\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\tres = x;\n\t}\n\treturn res;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,4 @@\n-static int __find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int return_locked)\n+static int __find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int return_locked, int full_frame)\n {\n \tint res = 0;\n \tint x;\n@@ -10,7 +10,7 @@\n \t\t\tast_mutex_lock(&iaxsl[x]);\n \t\t\tif (iaxs[x]) {\n \t\t\t\t/* Look for an exact match */\n-\t\t\t\tif (match(sin, callno, dcallno, iaxs[x])) {\n+\t\t\t\tif (match(sin, callno, dcallno, iaxs[x], full_frame)) {\n \t\t\t\t\tres = x;\n \t\t\t\t}\n \t\t\t}\n@@ -20,7 +20,7 @@\n \t\t\tast_mutex_lock(&iaxsl[x]);\n \t\t\tif (iaxs[x]) {\n \t\t\t\t/* Look for an exact match */\n-\t\t\t\tif (match(sin, callno, dcallno, iaxs[x])) {\n+\t\t\t\tif (match(sin, callno, dcallno, iaxs[x], full_frame)) {\n \t\t\t\t\tres = x;\n \t\t\t\t}\n \t\t\t}\n@@ -28,6 +28,8 @@\n \t\t}\n \t}\n \tif ((res < 1) && (new >= NEW_ALLOW)) {\n+\t\tint start, found = 0;\n+\n \t\t/* It may seem odd that we look through the peer list for a name for\n \t\t * this *incoming* call.  Well, it is weird.  However, users don't\n \t\t * have an IP address/port number that we can match against.  So,\n@@ -36,15 +38,29 @@\n \t\t * correct, but it will be changed if needed after authentication. */\n \t\tif (!iax2_getpeername(*sin, host, sizeof(host)))\n \t\t\tsnprintf(host, sizeof(host), \"%s:%d\", ast_inet_ntoa(sin->sin_addr), ntohs(sin->sin_port));\n+\n \t\tnow = ast_tvnow();\n-\t\tfor (x=1;x<TRUNK_CALL_START;x++) {\n+\t\tstart = 1 + (ast_random() % (TRUNK_CALL_START - 1));\n+\t\tfor (x = start; 1; x++) {\n+\t\t\tif (x == TRUNK_CALL_START) {\n+\t\t\t\tx = 0;\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\n \t\t\t/* Find first unused call number that hasn't been used in a while */\n \t\t\tast_mutex_lock(&iaxsl[x]);\n-\t\t\tif (!iaxs[x] && ((now.tv_sec - lastused[x].tv_sec) > MIN_REUSE_TIME)) break;\n+\t\t\tif (!iaxs[x] && ((now.tv_sec - lastused[x].tv_sec) > MIN_REUSE_TIME)) {\n+\t\t\t\tfound = 1;\n+\t\t\t\tbreak;\n+\t\t\t}\n \t\t\tast_mutex_unlock(&iaxsl[x]);\n+\t\t\t\n+\t\t\tif (x == start - 1) {\n+\t\t\t\tbreak;\n+\t\t\t}\n \t\t}\n \t\t/* We've still got lock held if we found a spot */\n-\t\tif (x >= TRUNK_CALL_START) {\n+\t\tif (x == start - 1 && !found) {\n \t\t\tast_log(LOG_WARNING, \"No more space\\n\");\n \t\t\treturn 0;\n \t\t}",
        "diff_line_info": {
            "deleted_lines": [
                "static int __find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int return_locked)",
                "\t\t\t\tif (match(sin, callno, dcallno, iaxs[x])) {",
                "\t\t\t\tif (match(sin, callno, dcallno, iaxs[x])) {",
                "\t\tfor (x=1;x<TRUNK_CALL_START;x++) {",
                "\t\t\tif (!iaxs[x] && ((now.tv_sec - lastused[x].tv_sec) > MIN_REUSE_TIME)) break;",
                "\t\tif (x >= TRUNK_CALL_START) {"
            ],
            "added_lines": [
                "static int __find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int return_locked, int full_frame)",
                "\t\t\t\tif (match(sin, callno, dcallno, iaxs[x], full_frame)) {",
                "\t\t\t\tif (match(sin, callno, dcallno, iaxs[x], full_frame)) {",
                "\t\tint start, found = 0;",
                "",
                "",
                "\t\tstart = 1 + (ast_random() % (TRUNK_CALL_START - 1));",
                "\t\tfor (x = start; 1; x++) {",
                "\t\t\tif (x == TRUNK_CALL_START) {",
                "\t\t\t\tx = 0;",
                "\t\t\t\tcontinue;",
                "\t\t\t}",
                "",
                "\t\t\tif (!iaxs[x] && ((now.tv_sec - lastused[x].tv_sec) > MIN_REUSE_TIME)) {",
                "\t\t\t\tfound = 1;",
                "\t\t\t\tbreak;",
                "\t\t\t}",
                "\t\t\t",
                "\t\t\tif (x == start - 1) {",
                "\t\t\t\tbreak;",
                "\t\t\t}",
                "\t\tif (x == start - 1 && !found) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2008-1897",
        "func_name": "silentindark/asterisk-1/find_callno",
        "description": "The IAX2 channel driver (chan_iax2) in Asterisk Open Source 1.0.x, 1.2.x before 1.2.28, and 1.4.x before 1.4.19.1; Business Edition A.x.x, B.x.x before B.2.5.2, and C.x.x before C.1.8.1; AsteriskNOW before 1.0.3; Appliance Developer Kit 0.x.x; and s800i before 1.1.0.3, when configured to allow unauthenticated calls, does not verify that an ACK response contains a call number matching the server's reply to a NEW message, which allows remote attackers to cause a denial of service (traffic amplification) via a spoofed ACK response that does not complete a 3-way handshake.  NOTE: this issue exists because of an incomplete fix for CVE-2008-1923.",
        "git_url": "https://github.com/silentindark/asterisk-1/commit/fe8b7f31db687f8b9992864b82c93d22833019c7",
        "commit_title": "Merged revisions 114558 via svnmerge from ",
        "commit_text": "https://origsvn.digium.com/svn/asterisk/branches/1.4  ........ r114558 | russell | 2008-04-22 17:15:36 -0500 (Tue, 22 Apr 2008) | 5 lines  When we receive a full frame that is supposed to contain our call number, ensure that it has the correct one. (closes issue #10078) (AST-2008-006)  ........  ",
        "func_before": "static int find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd) {\n\n\treturn __find_callno(callno, dcallno, sin, new, sockfd, 0);\n}",
        "func": "static int find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int full_frame) {\n\n\treturn __find_callno(callno, dcallno, sin, new, sockfd, 0, full_frame);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,4 @@\n-static int find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd) {\n+static int find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int full_frame) {\n \n-\treturn __find_callno(callno, dcallno, sin, new, sockfd, 0);\n+\treturn __find_callno(callno, dcallno, sin, new, sockfd, 0, full_frame);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "static int find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd) {",
                "\treturn __find_callno(callno, dcallno, sin, new, sockfd, 0);"
            ],
            "added_lines": [
                "static int find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int full_frame) {",
                "\treturn __find_callno(callno, dcallno, sin, new, sockfd, 0, full_frame);"
            ]
        }
    },
    {
        "cve_id": "CVE-2008-1897",
        "func_name": "silentindark/asterisk-1/iax2_do_register",
        "description": "The IAX2 channel driver (chan_iax2) in Asterisk Open Source 1.0.x, 1.2.x before 1.2.28, and 1.4.x before 1.4.19.1; Business Edition A.x.x, B.x.x before B.2.5.2, and C.x.x before C.1.8.1; AsteriskNOW before 1.0.3; Appliance Developer Kit 0.x.x; and s800i before 1.1.0.3, when configured to allow unauthenticated calls, does not verify that an ACK response contains a call number matching the server's reply to a NEW message, which allows remote attackers to cause a denial of service (traffic amplification) via a spoofed ACK response that does not complete a 3-way handshake.  NOTE: this issue exists because of an incomplete fix for CVE-2008-1923.",
        "git_url": "https://github.com/silentindark/asterisk-1/commit/fe8b7f31db687f8b9992864b82c93d22833019c7",
        "commit_title": "Merged revisions 114558 via svnmerge from ",
        "commit_text": "https://origsvn.digium.com/svn/asterisk/branches/1.4  ........ r114558 | russell | 2008-04-22 17:15:36 -0500 (Tue, 22 Apr 2008) | 5 lines  When we receive a full frame that is supposed to contain our call number, ensure that it has the correct one. (closes issue #10078) (AST-2008-006)  ........  ",
        "func_before": "static int iax2_do_register(struct iax2_registry *reg)\n{\n\tstruct iax_ie_data ied;\n\tif (iaxdebug)\n\t\tast_debug(1, \"Sending registration request for '%s'\\n\", reg->username);\n\n\tif (reg->dnsmgr && \n\t    ((reg->regstate == REG_STATE_TIMEOUT) || !reg->addr.sin_addr.s_addr)) {\n\t\t/* Maybe the IP has changed, force DNS refresh */\n\t\tast_dnsmgr_refresh(reg->dnsmgr);\n\t}\n\t\n\t/*\n\t * if IP has Changed, free allocated call to create a new one with new IP\n\t * call has the pointer to IP and must be updated to the new one\n\t */\n\tif (reg->dnsmgr && ast_dnsmgr_changed(reg->dnsmgr) && (reg->callno > 0)) {\n\t\tast_mutex_lock(&iaxsl[reg->callno]);\n\t\tiax2_destroy(reg->callno);\n\t\tast_mutex_unlock(&iaxsl[reg->callno]);\n\t\treg->callno = 0;\n\t}\n\tif (!reg->addr.sin_addr.s_addr) {\n\t\tif (iaxdebug)\n\t\t\tast_debug(1, \"Unable to send registration request for '%s' without IP address\\n\", reg->username);\n\t\t/* Setup the next registration attempt */\n\t\treg->expire = iax2_sched_replace(reg->expire, sched, \n\t\t\t(5 * reg->refresh / 6) * 1000, iax2_do_register_s, reg);\n\t\treturn -1;\n\t}\n\n\tif (!reg->callno) {\n\t\tast_debug(1, \"Allocate call number\\n\");\n\t\treg->callno = find_callno_locked(0, 0, &reg->addr, NEW_FORCE, defaultsockfd);\n\t\tif (reg->callno < 1) {\n\t\t\tast_log(LOG_WARNING, \"Unable to create call for registration\\n\");\n\t\t\treturn -1;\n\t\t} else\n\t\t\tast_debug(1, \"Registration created on call %d\\n\", reg->callno);\n\t\tiaxs[reg->callno]->reg = reg;\n\t\tast_mutex_unlock(&iaxsl[reg->callno]);\n\t}\n\t/* Setup the next registration a little early */\n\treg->expire = iax2_sched_replace(reg->expire, sched, \n\t\t(5 * reg->refresh / 6) * 1000, iax2_do_register_s, reg);\n\t/* Send the request */\n\tmemset(&ied, 0, sizeof(ied));\n\tiax_ie_append_str(&ied, IAX_IE_USERNAME, reg->username);\n\tiax_ie_append_short(&ied, IAX_IE_REFRESH, reg->refresh);\n\tsend_command(iaxs[reg->callno],AST_FRAME_IAX, IAX_COMMAND_REGREQ, 0, ied.buf, ied.pos, -1);\n\treg->regstate = REG_STATE_REGSENT;\n\treturn 0;\n}",
        "func": "static int iax2_do_register(struct iax2_registry *reg)\n{\n\tstruct iax_ie_data ied;\n\tif (iaxdebug)\n\t\tast_debug(1, \"Sending registration request for '%s'\\n\", reg->username);\n\n\tif (reg->dnsmgr && \n\t    ((reg->regstate == REG_STATE_TIMEOUT) || !reg->addr.sin_addr.s_addr)) {\n\t\t/* Maybe the IP has changed, force DNS refresh */\n\t\tast_dnsmgr_refresh(reg->dnsmgr);\n\t}\n\t\n\t/*\n\t * if IP has Changed, free allocated call to create a new one with new IP\n\t * call has the pointer to IP and must be updated to the new one\n\t */\n\tif (reg->dnsmgr && ast_dnsmgr_changed(reg->dnsmgr) && (reg->callno > 0)) {\n\t\tast_mutex_lock(&iaxsl[reg->callno]);\n\t\tiax2_destroy(reg->callno);\n\t\tast_mutex_unlock(&iaxsl[reg->callno]);\n\t\treg->callno = 0;\n\t}\n\tif (!reg->addr.sin_addr.s_addr) {\n\t\tif (iaxdebug)\n\t\t\tast_debug(1, \"Unable to send registration request for '%s' without IP address\\n\", reg->username);\n\t\t/* Setup the next registration attempt */\n\t\treg->expire = iax2_sched_replace(reg->expire, sched, \n\t\t\t(5 * reg->refresh / 6) * 1000, iax2_do_register_s, reg);\n\t\treturn -1;\n\t}\n\n\tif (!reg->callno) {\n\t\tast_debug(1, \"Allocate call number\\n\");\n\t\treg->callno = find_callno_locked(0, 0, &reg->addr, NEW_FORCE, defaultsockfd, 0);\n\t\tif (reg->callno < 1) {\n\t\t\tast_log(LOG_WARNING, \"Unable to create call for registration\\n\");\n\t\t\treturn -1;\n\t\t} else\n\t\t\tast_debug(1, \"Registration created on call %d\\n\", reg->callno);\n\t\tiaxs[reg->callno]->reg = reg;\n\t\tast_mutex_unlock(&iaxsl[reg->callno]);\n\t}\n\t/* Setup the next registration a little early */\n\treg->expire = iax2_sched_replace(reg->expire, sched, \n\t\t(5 * reg->refresh / 6) * 1000, iax2_do_register_s, reg);\n\t/* Send the request */\n\tmemset(&ied, 0, sizeof(ied));\n\tiax_ie_append_str(&ied, IAX_IE_USERNAME, reg->username);\n\tiax_ie_append_short(&ied, IAX_IE_REFRESH, reg->refresh);\n\tsend_command(iaxs[reg->callno],AST_FRAME_IAX, IAX_COMMAND_REGREQ, 0, ied.buf, ied.pos, -1);\n\treg->regstate = REG_STATE_REGSENT;\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -31,7 +31,7 @@\n \n \tif (!reg->callno) {\n \t\tast_debug(1, \"Allocate call number\\n\");\n-\t\treg->callno = find_callno_locked(0, 0, &reg->addr, NEW_FORCE, defaultsockfd);\n+\t\treg->callno = find_callno_locked(0, 0, &reg->addr, NEW_FORCE, defaultsockfd, 0);\n \t\tif (reg->callno < 1) {\n \t\t\tast_log(LOG_WARNING, \"Unable to create call for registration\\n\");\n \t\t\treturn -1;",
        "diff_line_info": {
            "deleted_lines": [
                "\t\treg->callno = find_callno_locked(0, 0, &reg->addr, NEW_FORCE, defaultsockfd);"
            ],
            "added_lines": [
                "\t\treg->callno = find_callno_locked(0, 0, &reg->addr, NEW_FORCE, defaultsockfd, 0);"
            ]
        }
    },
    {
        "cve_id": "CVE-2008-1897",
        "func_name": "silentindark/asterisk-1/iax2_poke_peer",
        "description": "The IAX2 channel driver (chan_iax2) in Asterisk Open Source 1.0.x, 1.2.x before 1.2.28, and 1.4.x before 1.4.19.1; Business Edition A.x.x, B.x.x before B.2.5.2, and C.x.x before C.1.8.1; AsteriskNOW before 1.0.3; Appliance Developer Kit 0.x.x; and s800i before 1.1.0.3, when configured to allow unauthenticated calls, does not verify that an ACK response contains a call number matching the server's reply to a NEW message, which allows remote attackers to cause a denial of service (traffic amplification) via a spoofed ACK response that does not complete a 3-way handshake.  NOTE: this issue exists because of an incomplete fix for CVE-2008-1923.",
        "git_url": "https://github.com/silentindark/asterisk-1/commit/fe8b7f31db687f8b9992864b82c93d22833019c7",
        "commit_title": "Merged revisions 114558 via svnmerge from ",
        "commit_text": "https://origsvn.digium.com/svn/asterisk/branches/1.4  ........ r114558 | russell | 2008-04-22 17:15:36 -0500 (Tue, 22 Apr 2008) | 5 lines  When we receive a full frame that is supposed to contain our call number, ensure that it has the correct one. (closes issue #10078) (AST-2008-006)  ........  ",
        "func_before": "static int iax2_poke_peer(struct iax2_peer *peer, int heldcall)\n{\n\tif (!peer->maxms || (!peer->addr.sin_addr.s_addr && !peer->dnsmgr)) {\n\t\t/* IF we have no IP without dnsmgr, or this isn't to be monitored, return\n\t\t  immediately after clearing things out */\n\t\tpeer->lastms = 0;\n\t\tpeer->historicms = 0;\n\t\tpeer->pokeexpire = -1;\n\t\tpeer->callno = 0;\n\t\treturn 0;\n\t}\n\tif (peer->callno > 0) {\n\t\tast_log(LOG_NOTICE, \"Still have a callno...\\n\");\n\t\tast_mutex_lock(&iaxsl[peer->callno]);\n\t\tiax2_destroy(peer->callno);\n\t\tast_mutex_unlock(&iaxsl[peer->callno]);\n\t}\n\tif (heldcall)\n\t\tast_mutex_unlock(&iaxsl[heldcall]);\n\tpeer->callno = find_callno(0, 0, &peer->addr, NEW_FORCE, peer->sockfd);\n\tif (heldcall)\n\t\tast_mutex_lock(&iaxsl[heldcall]);\n\tif (peer->callno < 1) {\n\t\tast_log(LOG_WARNING, \"Unable to allocate call for poking peer '%s'\\n\", peer->name);\n\t\treturn -1;\n\t}\n\n\t/* Speed up retransmission times for this qualify call */\n\tiaxs[peer->callno]->pingtime = peer->maxms / 4 + 1;\n\tiaxs[peer->callno]->peerpoke = peer;\n\n \tif (peer->pokeexpire > -1) {\n \t\tif (!ast_sched_del(sched, peer->pokeexpire)) {\n \t\t\tpeer->pokeexpire = -1;\n \t\t\tpeer_unref(peer);\n \t\t}\n \t}\n \n\t/* Queue up a new task to handle no reply */\n\t/* If the host is already unreachable then use the unreachable interval instead */\n\tif (peer->lastms < 0)\n \t\tpeer->pokeexpire = iax2_sched_add(sched, peer->pokefreqnotok, iax2_poke_noanswer, peer_ref(peer));\n\telse\n \t\tpeer->pokeexpire = iax2_sched_add(sched, DEFAULT_MAXMS * 2, iax2_poke_noanswer, peer_ref(peer));\n\n \tif (peer->pokeexpire == -1)\n \t\tpeer_unref(peer);\n\n\t/* And send the poke */\n\tsend_command(iaxs[peer->callno], AST_FRAME_IAX, IAX_COMMAND_POKE, 0, NULL, 0, -1);\n\n\treturn 0;\n}",
        "func": "static int iax2_poke_peer(struct iax2_peer *peer, int heldcall)\n{\n\tif (!peer->maxms || (!peer->addr.sin_addr.s_addr && !peer->dnsmgr)) {\n\t\t/* IF we have no IP without dnsmgr, or this isn't to be monitored, return\n\t\t  immediately after clearing things out */\n\t\tpeer->lastms = 0;\n\t\tpeer->historicms = 0;\n\t\tpeer->pokeexpire = -1;\n\t\tpeer->callno = 0;\n\t\treturn 0;\n\t}\n\tif (peer->callno > 0) {\n\t\tast_log(LOG_NOTICE, \"Still have a callno...\\n\");\n\t\tast_mutex_lock(&iaxsl[peer->callno]);\n\t\tiax2_destroy(peer->callno);\n\t\tast_mutex_unlock(&iaxsl[peer->callno]);\n\t}\n\tif (heldcall)\n\t\tast_mutex_unlock(&iaxsl[heldcall]);\n\tpeer->callno = find_callno(0, 0, &peer->addr, NEW_FORCE, peer->sockfd, 0);\n\tif (heldcall)\n\t\tast_mutex_lock(&iaxsl[heldcall]);\n\tif (peer->callno < 1) {\n\t\tast_log(LOG_WARNING, \"Unable to allocate call for poking peer '%s'\\n\", peer->name);\n\t\treturn -1;\n\t}\n\n\t/* Speed up retransmission times for this qualify call */\n\tiaxs[peer->callno]->pingtime = peer->maxms / 4 + 1;\n\tiaxs[peer->callno]->peerpoke = peer;\n\n \tif (peer->pokeexpire > -1) {\n \t\tif (!ast_sched_del(sched, peer->pokeexpire)) {\n \t\t\tpeer->pokeexpire = -1;\n \t\t\tpeer_unref(peer);\n \t\t}\n \t}\n \n\t/* Queue up a new task to handle no reply */\n\t/* If the host is already unreachable then use the unreachable interval instead */\n\tif (peer->lastms < 0)\n \t\tpeer->pokeexpire = iax2_sched_add(sched, peer->pokefreqnotok, iax2_poke_noanswer, peer_ref(peer));\n\telse\n \t\tpeer->pokeexpire = iax2_sched_add(sched, DEFAULT_MAXMS * 2, iax2_poke_noanswer, peer_ref(peer));\n\n \tif (peer->pokeexpire == -1)\n \t\tpeer_unref(peer);\n\n\t/* And send the poke */\n\tsend_command(iaxs[peer->callno], AST_FRAME_IAX, IAX_COMMAND_POKE, 0, NULL, 0, -1);\n\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -17,7 +17,7 @@\n \t}\n \tif (heldcall)\n \t\tast_mutex_unlock(&iaxsl[heldcall]);\n-\tpeer->callno = find_callno(0, 0, &peer->addr, NEW_FORCE, peer->sockfd);\n+\tpeer->callno = find_callno(0, 0, &peer->addr, NEW_FORCE, peer->sockfd, 0);\n \tif (heldcall)\n \t\tast_mutex_lock(&iaxsl[heldcall]);\n \tif (peer->callno < 1) {",
        "diff_line_info": {
            "deleted_lines": [
                "\tpeer->callno = find_callno(0, 0, &peer->addr, NEW_FORCE, peer->sockfd);"
            ],
            "added_lines": [
                "\tpeer->callno = find_callno(0, 0, &peer->addr, NEW_FORCE, peer->sockfd, 0);"
            ]
        }
    },
    {
        "cve_id": "CVE-2008-1897",
        "func_name": "silentindark/asterisk-1/cache_get_callno_locked",
        "description": "The IAX2 channel driver (chan_iax2) in Asterisk Open Source 1.0.x, 1.2.x before 1.2.28, and 1.4.x before 1.4.19.1; Business Edition A.x.x, B.x.x before B.2.5.2, and C.x.x before C.1.8.1; AsteriskNOW before 1.0.3; Appliance Developer Kit 0.x.x; and s800i before 1.1.0.3, when configured to allow unauthenticated calls, does not verify that an ACK response contains a call number matching the server's reply to a NEW message, which allows remote attackers to cause a denial of service (traffic amplification) via a spoofed ACK response that does not complete a 3-way handshake.  NOTE: this issue exists because of an incomplete fix for CVE-2008-1923.",
        "git_url": "https://github.com/silentindark/asterisk-1/commit/fe8b7f31db687f8b9992864b82c93d22833019c7",
        "commit_title": "Merged revisions 114558 via svnmerge from ",
        "commit_text": "https://origsvn.digium.com/svn/asterisk/branches/1.4  ........ r114558 | russell | 2008-04-22 17:15:36 -0500 (Tue, 22 Apr 2008) | 5 lines  When we receive a full frame that is supposed to contain our call number, ensure that it has the correct one. (closes issue #10078) (AST-2008-006)  ........  ",
        "func_before": "static int cache_get_callno_locked(const char *data)\n{\n\tstruct sockaddr_in sin;\n\tint x;\n\tint callno;\n\tstruct iax_ie_data ied;\n\tstruct create_addr_info cai;\n\tstruct parsed_dial_string pds;\n\tchar *tmpstr;\n\n\tfor (x=0; x<IAX_MAX_CALLS; x++) {\n\t\t/* Look for an *exact match* call.  Once a call is negotiated, it can only\n\t\t   look up entries for a single context */\n\t\tif (!ast_mutex_trylock(&iaxsl[x])) {\n\t\t\tif (iaxs[x] && !strcasecmp(data, iaxs[x]->dproot))\n\t\t\t\treturn x;\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t}\n\t}\n\n\t/* No match found, we need to create a new one */\n\n\tmemset(&cai, 0, sizeof(cai));\n\tmemset(&ied, 0, sizeof(ied));\n\tmemset(&pds, 0, sizeof(pds));\n\n\ttmpstr = ast_strdupa(data);\n\tparse_dial_string(tmpstr, &pds);\n\n\tif (ast_strlen_zero(pds.peer)) {\n\t\tast_log(LOG_WARNING, \"No peer provided in the IAX2 dial string '%s'\\n\", data);\n\t\treturn -1;\n\t}\n\n\t/* Populate our address from the given */\n\tif (create_addr(pds.peer, NULL, &sin, &cai))\n\t\treturn -1;\n\n\tast_debug(1, \"peer: %s, username: %s, password: %s, context: %s\\n\",\n\t\tpds.peer, pds.username, pds.password, pds.context);\n\n\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd);\n\tif (callno < 1) {\n\t\tast_log(LOG_WARNING, \"Unable to create call\\n\");\n\t\treturn -1;\n\t}\n\n\tast_string_field_set(iaxs[callno], dproot, data);\n\tiaxs[callno]->capability = IAX_CAPABILITY_FULLBANDWIDTH;\n\n\tiax_ie_append_short(&ied, IAX_IE_VERSION, IAX_PROTO_VERSION);\n\tiax_ie_append_str(&ied, IAX_IE_CALLED_NUMBER, \"TBD\");\n\t/* the string format is slightly different from a standard dial string,\n\t   because the context appears in the 'exten' position\n\t*/\n\tif (pds.exten)\n\t\tiax_ie_append_str(&ied, IAX_IE_CALLED_CONTEXT, pds.exten);\n\tif (pds.username)\n\t\tiax_ie_append_str(&ied, IAX_IE_USERNAME, pds.username);\n\tiax_ie_append_int(&ied, IAX_IE_FORMAT, IAX_CAPABILITY_FULLBANDWIDTH);\n\tiax_ie_append_int(&ied, IAX_IE_CAPABILITY, IAX_CAPABILITY_FULLBANDWIDTH);\n\t/* Keep password handy */\n\tif (pds.password)\n\t\tast_string_field_set(iaxs[callno], secret, pds.password);\n\tif (pds.key)\n\t\tast_string_field_set(iaxs[callno], outkey, pds.key);\n\t/* Start the call going */\n\tsend_command(iaxs[callno], AST_FRAME_IAX, IAX_COMMAND_NEW, 0, ied.buf, ied.pos, -1);\n\n\treturn callno;\n}",
        "func": "static int cache_get_callno_locked(const char *data)\n{\n\tstruct sockaddr_in sin;\n\tint x;\n\tint callno;\n\tstruct iax_ie_data ied;\n\tstruct create_addr_info cai;\n\tstruct parsed_dial_string pds;\n\tchar *tmpstr;\n\n\tfor (x=0; x<IAX_MAX_CALLS; x++) {\n\t\t/* Look for an *exact match* call.  Once a call is negotiated, it can only\n\t\t   look up entries for a single context */\n\t\tif (!ast_mutex_trylock(&iaxsl[x])) {\n\t\t\tif (iaxs[x] && !strcasecmp(data, iaxs[x]->dproot))\n\t\t\t\treturn x;\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t}\n\t}\n\n\t/* No match found, we need to create a new one */\n\n\tmemset(&cai, 0, sizeof(cai));\n\tmemset(&ied, 0, sizeof(ied));\n\tmemset(&pds, 0, sizeof(pds));\n\n\ttmpstr = ast_strdupa(data);\n\tparse_dial_string(tmpstr, &pds);\n\n\tif (ast_strlen_zero(pds.peer)) {\n\t\tast_log(LOG_WARNING, \"No peer provided in the IAX2 dial string '%s'\\n\", data);\n\t\treturn -1;\n\t}\n\n\t/* Populate our address from the given */\n\tif (create_addr(pds.peer, NULL, &sin, &cai))\n\t\treturn -1;\n\n\tast_debug(1, \"peer: %s, username: %s, password: %s, context: %s\\n\",\n\t\tpds.peer, pds.username, pds.password, pds.context);\n\n\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd, 0);\n\tif (callno < 1) {\n\t\tast_log(LOG_WARNING, \"Unable to create call\\n\");\n\t\treturn -1;\n\t}\n\n\tast_string_field_set(iaxs[callno], dproot, data);\n\tiaxs[callno]->capability = IAX_CAPABILITY_FULLBANDWIDTH;\n\n\tiax_ie_append_short(&ied, IAX_IE_VERSION, IAX_PROTO_VERSION);\n\tiax_ie_append_str(&ied, IAX_IE_CALLED_NUMBER, \"TBD\");\n\t/* the string format is slightly different from a standard dial string,\n\t   because the context appears in the 'exten' position\n\t*/\n\tif (pds.exten)\n\t\tiax_ie_append_str(&ied, IAX_IE_CALLED_CONTEXT, pds.exten);\n\tif (pds.username)\n\t\tiax_ie_append_str(&ied, IAX_IE_USERNAME, pds.username);\n\tiax_ie_append_int(&ied, IAX_IE_FORMAT, IAX_CAPABILITY_FULLBANDWIDTH);\n\tiax_ie_append_int(&ied, IAX_IE_CAPABILITY, IAX_CAPABILITY_FULLBANDWIDTH);\n\t/* Keep password handy */\n\tif (pds.password)\n\t\tast_string_field_set(iaxs[callno], secret, pds.password);\n\tif (pds.key)\n\t\tast_string_field_set(iaxs[callno], outkey, pds.key);\n\t/* Start the call going */\n\tsend_command(iaxs[callno], AST_FRAME_IAX, IAX_COMMAND_NEW, 0, ied.buf, ied.pos, -1);\n\n\treturn callno;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -39,7 +39,7 @@\n \tast_debug(1, \"peer: %s, username: %s, password: %s, context: %s\\n\",\n \t\tpds.peer, pds.username, pds.password, pds.context);\n \n-\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd);\n+\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd, 0);\n \tif (callno < 1) {\n \t\tast_log(LOG_WARNING, \"Unable to create call\\n\");\n \t\treturn -1;",
        "diff_line_info": {
            "deleted_lines": [
                "\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd);"
            ],
            "added_lines": [
                "\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd, 0);"
            ]
        }
    },
    {
        "cve_id": "CVE-2008-1897",
        "func_name": "silentindark/asterisk-1/iax2_provision",
        "description": "The IAX2 channel driver (chan_iax2) in Asterisk Open Source 1.0.x, 1.2.x before 1.2.28, and 1.4.x before 1.4.19.1; Business Edition A.x.x, B.x.x before B.2.5.2, and C.x.x before C.1.8.1; AsteriskNOW before 1.0.3; Appliance Developer Kit 0.x.x; and s800i before 1.1.0.3, when configured to allow unauthenticated calls, does not verify that an ACK response contains a call number matching the server's reply to a NEW message, which allows remote attackers to cause a denial of service (traffic amplification) via a spoofed ACK response that does not complete a 3-way handshake.  NOTE: this issue exists because of an incomplete fix for CVE-2008-1923.",
        "git_url": "https://github.com/silentindark/asterisk-1/commit/fe8b7f31db687f8b9992864b82c93d22833019c7",
        "commit_title": "Merged revisions 114558 via svnmerge from ",
        "commit_text": "https://origsvn.digium.com/svn/asterisk/branches/1.4  ........ r114558 | russell | 2008-04-22 17:15:36 -0500 (Tue, 22 Apr 2008) | 5 lines  When we receive a full frame that is supposed to contain our call number, ensure that it has the correct one. (closes issue #10078) (AST-2008-006)  ........  ",
        "func_before": "static int iax2_provision(struct sockaddr_in *end, int sockfd, char *dest, const char *template, int force)\n{\n\t/* Returns 1 if provisioned, -1 if not able to find destination, or 0 if no provisioning\n\t   is found for template */\n\tstruct iax_ie_data provdata;\n\tstruct iax_ie_data ied;\n\tunsigned int sig;\n\tstruct sockaddr_in sin;\n\tint callno;\n\tstruct create_addr_info cai;\n\n\tmemset(&cai, 0, sizeof(cai));\n\n\tast_debug(1, \"Provisioning '%s' from template '%s'\\n\", dest, template);\n\n\tif (iax_provision_build(&provdata, &sig, template, force)) {\n\t\tast_debug(1, \"No provisioning found for template '%s'\\n\", template);\n\t\treturn 0;\n\t}\n\n\tif (end) {\n\t\tmemcpy(&sin, end, sizeof(sin));\n\t\tcai.sockfd = sockfd;\n\t} else if (create_addr(dest, NULL, &sin, &cai))\n\t\treturn -1;\n\n\t/* Build the rest of the message */\n\tmemset(&ied, 0, sizeof(ied));\n\tiax_ie_append_raw(&ied, IAX_IE_PROVISIONING, provdata.buf, provdata.pos);\n\n\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd);\n\tif (!callno)\n\t\treturn -1;\n\n\tif (iaxs[callno]) {\n\t\t/* Schedule autodestruct in case they don't ever give us anything back */\n\t\tiaxs[callno]->autoid = iax2_sched_replace(iaxs[callno]->autoid, \n\t\t\tsched, 15000, auto_hangup, (void *)(long)callno);\n\t\tast_set_flag(iaxs[callno], IAX_PROVISION);\n\t\t/* Got a call number now, so go ahead and send the provisioning information */\n\t\tsend_command(iaxs[callno], AST_FRAME_IAX, IAX_COMMAND_PROVISION, 0, ied.buf, ied.pos, -1);\n\t}\n\tast_mutex_unlock(&iaxsl[callno]);\n\n\treturn 1;\n}",
        "func": "static int iax2_provision(struct sockaddr_in *end, int sockfd, char *dest, const char *template, int force)\n{\n\t/* Returns 1 if provisioned, -1 if not able to find destination, or 0 if no provisioning\n\t   is found for template */\n\tstruct iax_ie_data provdata;\n\tstruct iax_ie_data ied;\n\tunsigned int sig;\n\tstruct sockaddr_in sin;\n\tint callno;\n\tstruct create_addr_info cai;\n\n\tmemset(&cai, 0, sizeof(cai));\n\n\tast_debug(1, \"Provisioning '%s' from template '%s'\\n\", dest, template);\n\n\tif (iax_provision_build(&provdata, &sig, template, force)) {\n\t\tast_debug(1, \"No provisioning found for template '%s'\\n\", template);\n\t\treturn 0;\n\t}\n\n\tif (end) {\n\t\tmemcpy(&sin, end, sizeof(sin));\n\t\tcai.sockfd = sockfd;\n\t} else if (create_addr(dest, NULL, &sin, &cai))\n\t\treturn -1;\n\n\t/* Build the rest of the message */\n\tmemset(&ied, 0, sizeof(ied));\n\tiax_ie_append_raw(&ied, IAX_IE_PROVISIONING, provdata.buf, provdata.pos);\n\n\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd, 0);\n\tif (!callno)\n\t\treturn -1;\n\n\tif (iaxs[callno]) {\n\t\t/* Schedule autodestruct in case they don't ever give us anything back */\n\t\tiaxs[callno]->autoid = iax2_sched_replace(iaxs[callno]->autoid, \n\t\t\tsched, 15000, auto_hangup, (void *)(long)callno);\n\t\tast_set_flag(iaxs[callno], IAX_PROVISION);\n\t\t/* Got a call number now, so go ahead and send the provisioning information */\n\t\tsend_command(iaxs[callno], AST_FRAME_IAX, IAX_COMMAND_PROVISION, 0, ied.buf, ied.pos, -1);\n\t}\n\tast_mutex_unlock(&iaxsl[callno]);\n\n\treturn 1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -28,7 +28,7 @@\n \tmemset(&ied, 0, sizeof(ied));\n \tiax_ie_append_raw(&ied, IAX_IE_PROVISIONING, provdata.buf, provdata.pos);\n \n-\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd);\n+\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd, 0);\n \tif (!callno)\n \t\treturn -1;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd);"
            ],
            "added_lines": [
                "\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd, 0);"
            ]
        }
    },
    {
        "cve_id": "CVE-2008-1897",
        "func_name": "silentindark/asterisk-1/match",
        "description": "The IAX2 channel driver (chan_iax2) in Asterisk Open Source 1.0.x, 1.2.x before 1.2.28, and 1.4.x before 1.4.19.1; Business Edition A.x.x, B.x.x before B.2.5.2, and C.x.x before C.1.8.1; AsteriskNOW before 1.0.3; Appliance Developer Kit 0.x.x; and s800i before 1.1.0.3, when configured to allow unauthenticated calls, does not verify that an ACK response contains a call number matching the server's reply to a NEW message, which allows remote attackers to cause a denial of service (traffic amplification) via a spoofed ACK response that does not complete a 3-way handshake.  NOTE: this issue exists because of an incomplete fix for CVE-2008-1923.",
        "git_url": "https://github.com/silentindark/asterisk-1/commit/fe8b7f31db687f8b9992864b82c93d22833019c7",
        "commit_title": "Merged revisions 114558 via svnmerge from ",
        "commit_text": "https://origsvn.digium.com/svn/asterisk/branches/1.4  ........ r114558 | russell | 2008-04-22 17:15:36 -0500 (Tue, 22 Apr 2008) | 5 lines  When we receive a full frame that is supposed to contain our call number, ensure that it has the correct one. (closes issue #10078) (AST-2008-006)  ........  ",
        "func_before": "static int match(struct sockaddr_in *sin, unsigned short callno, unsigned short dcallno, const struct chan_iax2_pvt *cur)\n{\n\tif ((cur->addr.sin_addr.s_addr == sin->sin_addr.s_addr) &&\n\t\t(cur->addr.sin_port == sin->sin_port)) {\n\t\t/* This is the main host */\n\t\tif ((cur->peercallno == callno) ||\n\t\t\t((dcallno == cur->callno) && !cur->peercallno)) {\n\t\t\t/* That's us.  Be sure we keep track of the peer call number */\n\t\t\treturn 1;\n\t\t}\n\t}\n\tif ((cur->transfer.sin_addr.s_addr == sin->sin_addr.s_addr) &&\n\t    (cur->transfer.sin_port == sin->sin_port) && (cur->transferring)) {\n\t\t/* We're transferring */\n\t\tif ((dcallno == cur->callno) || (cur->transferring == TRANSFER_MEDIAPASS && cur->transfercallno == callno))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
        "func": "static int match(struct sockaddr_in *sin, unsigned short callno, unsigned short dcallno, const struct chan_iax2_pvt *cur, int full_frame)\n{\n\tif ((cur->addr.sin_addr.s_addr == sin->sin_addr.s_addr) &&\n\t\t(cur->addr.sin_port == sin->sin_port)) {\n\t\t/* This is the main host */\n\t\tif ( (cur->peercallno == 0 || cur->peercallno == callno) &&\n\t\t\t (full_frame ? dcallno == cur->callno : 1) ) {\n\t\t\t/* That's us.  Be sure we keep track of the peer call number */\n\t\t\treturn 1;\n\t\t}\n\t}\n\tif ((cur->transfer.sin_addr.s_addr == sin->sin_addr.s_addr) &&\n\t    (cur->transfer.sin_port == sin->sin_port) && (cur->transferring)) {\n\t\t/* We're transferring */\n\t\tif ((dcallno == cur->callno) || (cur->transferring == TRANSFER_MEDIAPASS && cur->transfercallno == callno))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,10 +1,10 @@\n-static int match(struct sockaddr_in *sin, unsigned short callno, unsigned short dcallno, const struct chan_iax2_pvt *cur)\n+static int match(struct sockaddr_in *sin, unsigned short callno, unsigned short dcallno, const struct chan_iax2_pvt *cur, int full_frame)\n {\n \tif ((cur->addr.sin_addr.s_addr == sin->sin_addr.s_addr) &&\n \t\t(cur->addr.sin_port == sin->sin_port)) {\n \t\t/* This is the main host */\n-\t\tif ((cur->peercallno == callno) ||\n-\t\t\t((dcallno == cur->callno) && !cur->peercallno)) {\n+\t\tif ( (cur->peercallno == 0 || cur->peercallno == callno) &&\n+\t\t\t (full_frame ? dcallno == cur->callno : 1) ) {\n \t\t\t/* That's us.  Be sure we keep track of the peer call number */\n \t\t\treturn 1;\n \t\t}",
        "diff_line_info": {
            "deleted_lines": [
                "static int match(struct sockaddr_in *sin, unsigned short callno, unsigned short dcallno, const struct chan_iax2_pvt *cur)",
                "\t\tif ((cur->peercallno == callno) ||",
                "\t\t\t((dcallno == cur->callno) && !cur->peercallno)) {"
            ],
            "added_lines": [
                "static int match(struct sockaddr_in *sin, unsigned short callno, unsigned short dcallno, const struct chan_iax2_pvt *cur, int full_frame)",
                "\t\tif ( (cur->peercallno == 0 || cur->peercallno == callno) &&",
                "\t\t\t (full_frame ? dcallno == cur->callno : 1) ) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2008-1897",
        "func_name": "silentindark/asterisk-1/socket_process_meta",
        "description": "The IAX2 channel driver (chan_iax2) in Asterisk Open Source 1.0.x, 1.2.x before 1.2.28, and 1.4.x before 1.4.19.1; Business Edition A.x.x, B.x.x before B.2.5.2, and C.x.x before C.1.8.1; AsteriskNOW before 1.0.3; Appliance Developer Kit 0.x.x; and s800i before 1.1.0.3, when configured to allow unauthenticated calls, does not verify that an ACK response contains a call number matching the server's reply to a NEW message, which allows remote attackers to cause a denial of service (traffic amplification) via a spoofed ACK response that does not complete a 3-way handshake.  NOTE: this issue exists because of an incomplete fix for CVE-2008-1923.",
        "git_url": "https://github.com/silentindark/asterisk-1/commit/fe8b7f31db687f8b9992864b82c93d22833019c7",
        "commit_title": "Merged revisions 114558 via svnmerge from ",
        "commit_text": "https://origsvn.digium.com/svn/asterisk/branches/1.4  ........ r114558 | russell | 2008-04-22 17:15:36 -0500 (Tue, 22 Apr 2008) | 5 lines  When we receive a full frame that is supposed to contain our call number, ensure that it has the correct one. (closes issue #10078) (AST-2008-006)  ........  ",
        "func_before": "static int socket_process_meta(int packet_len, struct ast_iax2_meta_hdr *meta, struct sockaddr_in *sin, int sockfd,\n\tstruct iax_frame *fr)\n{\n\tunsigned char metatype;\n\tstruct ast_iax2_meta_trunk_mini *mtm;\n\tstruct ast_iax2_meta_trunk_hdr *mth;\n\tstruct ast_iax2_meta_trunk_entry *mte;\n\tstruct iax2_trunk_peer *tpeer;\n\tunsigned int ts;\n\tvoid *ptr;\n\tstruct timeval rxtrunktime;\n\tstruct ast_frame f = { 0, };\n\n\tif (packet_len < sizeof(*meta)) {\n\t\tast_log(LOG_WARNING, \"Rejecting packet from '%s.%d' that is flagged as a meta frame but is too short\\n\", \n\t\t\tast_inet_ntoa(sin->sin_addr), ntohs(sin->sin_port));\n\t\treturn 1;\n\t}\n\n\tif (meta->metacmd != IAX_META_TRUNK)\n\t\treturn 1;\n\n\tif (packet_len < (sizeof(*meta) + sizeof(*mth))) {\n\t\tast_log(LOG_WARNING, \"midget meta trunk packet received (%d of %d min)\\n\", packet_len,\n\t\t\t(int) (sizeof(*meta) + sizeof(*mth)));\n\t\treturn 1;\n\t}\n\tmth = (struct ast_iax2_meta_trunk_hdr *)(meta->data);\n\tts = ntohl(mth->ts);\n\tmetatype = meta->cmddata;\n\tpacket_len -= (sizeof(*meta) + sizeof(*mth));\n\tptr = mth->data;\n\ttpeer = find_tpeer(sin, sockfd);\n\tif (!tpeer) {\n\t\tast_log(LOG_WARNING, \"Unable to accept trunked packet from '%s:%d': No matching peer\\n\", \n\t\t\tast_inet_ntoa(sin->sin_addr), ntohs(sin->sin_port));\n\t\treturn 1;\n\t}\n\ttpeer->trunkact = ast_tvnow();\n\tif (!ts || ast_tvzero(tpeer->rxtrunktime))\n\t\ttpeer->rxtrunktime = tpeer->trunkact;\n\trxtrunktime = tpeer->rxtrunktime;\n\tast_mutex_unlock(&tpeer->lock);\n\twhile (packet_len >= sizeof(*mte)) {\n\t\t/* Process channels */\n\t\tunsigned short callno, trunked_ts, len;\n\n\t\tif (metatype == IAX_META_TRUNK_MINI) {\n\t\t\tmtm = (struct ast_iax2_meta_trunk_mini *) ptr;\n\t\t\tptr += sizeof(*mtm);\n\t\t\tpacket_len -= sizeof(*mtm);\n\t\t\tlen = ntohs(mtm->len);\n\t\t\tcallno = ntohs(mtm->mini.callno);\n\t\t\ttrunked_ts = ntohs(mtm->mini.ts);\n\t\t} else if (metatype == IAX_META_TRUNK_SUPERMINI) {\n\t\t\tmte = (struct ast_iax2_meta_trunk_entry *)ptr;\n\t\t\tptr += sizeof(*mte);\n\t\t\tpacket_len -= sizeof(*mte);\n\t\t\tlen = ntohs(mte->len);\n\t\t\tcallno = ntohs(mte->callno);\n\t\t\ttrunked_ts = 0;\n\t\t} else {\n\t\t\tast_log(LOG_WARNING, \"Unknown meta trunk cmd from '%s:%d': dropping\\n\", ast_inet_ntoa(sin->sin_addr), ntohs(sin->sin_port));\n\t\t\tbreak;\n\t\t}\n\t\t/* Stop if we don't have enough data */\n\t\tif (len > packet_len)\n\t\t\tbreak;\n\t\tfr->callno = find_callno_locked(callno & ~IAX_FLAG_FULL, 0, sin, NEW_PREVENT, sockfd);\n\t\tif (!fr->callno)\n\t\t\tcontinue;\n\n\t\t/* If it's a valid call, deliver the contents.  If not, we\n\t\t   drop it, since we don't have a scallno to use for an INVAL */\n\t\t/* Process as a mini frame */\n\t\tmemset(&f, 0, sizeof(f));\n\t\tf.frametype = AST_FRAME_VOICE;\n\t\tif (!iaxs[fr->callno]) {\n\t\t\t/* drop it */\n\t\t} else if (iaxs[fr->callno]->voiceformat == 0) {\n\t\t\tast_log(LOG_WARNING, \"Received trunked frame before first full voice frame\\n \");\n\t\t\tiax2_vnak(fr->callno);\n\t\t} else {\n\t\t\tf.subclass = iaxs[fr->callno]->voiceformat;\n\t\t\tf.datalen = len;\n\t\t\tif (f.datalen >= 0) {\n\t\t\t\tif (f.datalen)\n\t\t\t\t\tf.data = ptr;\n\t\t\t\telse\n\t\t\t\t\tf.data = NULL;\n\t\t\t\tif (trunked_ts)\n\t\t\t\t\tfr->ts = (iaxs[fr->callno]->last & 0xFFFF0000L) | (trunked_ts & 0xffff);\n\t\t\t\telse\n\t\t\t\t\tfr->ts = fix_peerts(&rxtrunktime, fr->callno, ts);\n\t\t\t\t/* Don't pass any packets until we're started */\n\t\t\t\tif (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)) {\n\t\t\t\t\tstruct iax_frame *duped_fr;\n\n\t\t\t\t\t/* Common things */\n\t\t\t\t\tf.src = \"IAX2\";\n\t\t\t\t\tf.mallocd = 0;\n\t\t\t\t\tf.offset = 0;\n\t\t\t\t\tif (f.datalen && (f.frametype == AST_FRAME_VOICE)) \n\t\t\t\t\t\tf.samples = ast_codec_get_samples(&f);\n\t\t\t\t\telse\n\t\t\t\t\t\tf.samples = 0;\n\t\t\t\t\tfr->outoforder = 0;\n\t\t\t\t\tiax_frame_wrap(fr, &f);\n\t\t\t\t\tduped_fr = iaxfrdup2(fr);\n\t\t\t\t\tif (duped_fr)\n\t\t\t\t\t\tschedule_delivery(duped_fr, 1, 1, &fr->ts);\n\t\t\t\t\tif (iaxs[fr->callno] && iaxs[fr->callno]->last < fr->ts)\n\t\t\t\t\t\tiaxs[fr->callno]->last = fr->ts;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tast_log(LOG_WARNING, \"Datalen < 0?\\n\");\n\t\t\t}\n\t\t}\n\t\tast_mutex_unlock(&iaxsl[fr->callno]);\n\t\tptr += len;\n\t\tpacket_len -= len;\n\t}\n\n\treturn 1;\n}",
        "func": "static int socket_process_meta(int packet_len, struct ast_iax2_meta_hdr *meta, struct sockaddr_in *sin, int sockfd,\n\tstruct iax_frame *fr)\n{\n\tunsigned char metatype;\n\tstruct ast_iax2_meta_trunk_mini *mtm;\n\tstruct ast_iax2_meta_trunk_hdr *mth;\n\tstruct ast_iax2_meta_trunk_entry *mte;\n\tstruct iax2_trunk_peer *tpeer;\n\tunsigned int ts;\n\tvoid *ptr;\n\tstruct timeval rxtrunktime;\n\tstruct ast_frame f = { 0, };\n\n\tif (packet_len < sizeof(*meta)) {\n\t\tast_log(LOG_WARNING, \"Rejecting packet from '%s.%d' that is flagged as a meta frame but is too short\\n\", \n\t\t\tast_inet_ntoa(sin->sin_addr), ntohs(sin->sin_port));\n\t\treturn 1;\n\t}\n\n\tif (meta->metacmd != IAX_META_TRUNK)\n\t\treturn 1;\n\n\tif (packet_len < (sizeof(*meta) + sizeof(*mth))) {\n\t\tast_log(LOG_WARNING, \"midget meta trunk packet received (%d of %d min)\\n\", packet_len,\n\t\t\t(int) (sizeof(*meta) + sizeof(*mth)));\n\t\treturn 1;\n\t}\n\tmth = (struct ast_iax2_meta_trunk_hdr *)(meta->data);\n\tts = ntohl(mth->ts);\n\tmetatype = meta->cmddata;\n\tpacket_len -= (sizeof(*meta) + sizeof(*mth));\n\tptr = mth->data;\n\ttpeer = find_tpeer(sin, sockfd);\n\tif (!tpeer) {\n\t\tast_log(LOG_WARNING, \"Unable to accept trunked packet from '%s:%d': No matching peer\\n\", \n\t\t\tast_inet_ntoa(sin->sin_addr), ntohs(sin->sin_port));\n\t\treturn 1;\n\t}\n\ttpeer->trunkact = ast_tvnow();\n\tif (!ts || ast_tvzero(tpeer->rxtrunktime))\n\t\ttpeer->rxtrunktime = tpeer->trunkact;\n\trxtrunktime = tpeer->rxtrunktime;\n\tast_mutex_unlock(&tpeer->lock);\n\twhile (packet_len >= sizeof(*mte)) {\n\t\t/* Process channels */\n\t\tunsigned short callno, trunked_ts, len;\n\n\t\tif (metatype == IAX_META_TRUNK_MINI) {\n\t\t\tmtm = (struct ast_iax2_meta_trunk_mini *) ptr;\n\t\t\tptr += sizeof(*mtm);\n\t\t\tpacket_len -= sizeof(*mtm);\n\t\t\tlen = ntohs(mtm->len);\n\t\t\tcallno = ntohs(mtm->mini.callno);\n\t\t\ttrunked_ts = ntohs(mtm->mini.ts);\n\t\t} else if (metatype == IAX_META_TRUNK_SUPERMINI) {\n\t\t\tmte = (struct ast_iax2_meta_trunk_entry *)ptr;\n\t\t\tptr += sizeof(*mte);\n\t\t\tpacket_len -= sizeof(*mte);\n\t\t\tlen = ntohs(mte->len);\n\t\t\tcallno = ntohs(mte->callno);\n\t\t\ttrunked_ts = 0;\n\t\t} else {\n\t\t\tast_log(LOG_WARNING, \"Unknown meta trunk cmd from '%s:%d': dropping\\n\", ast_inet_ntoa(sin->sin_addr), ntohs(sin->sin_port));\n\t\t\tbreak;\n\t\t}\n\t\t/* Stop if we don't have enough data */\n\t\tif (len > packet_len)\n\t\t\tbreak;\n\t\tfr->callno = find_callno_locked(callno & ~IAX_FLAG_FULL, 0, sin, NEW_PREVENT, sockfd, 0);\n\t\tif (!fr->callno)\n\t\t\tcontinue;\n\n\t\t/* If it's a valid call, deliver the contents.  If not, we\n\t\t   drop it, since we don't have a scallno to use for an INVAL */\n\t\t/* Process as a mini frame */\n\t\tmemset(&f, 0, sizeof(f));\n\t\tf.frametype = AST_FRAME_VOICE;\n\t\tif (!iaxs[fr->callno]) {\n\t\t\t/* drop it */\n\t\t} else if (iaxs[fr->callno]->voiceformat == 0) {\n\t\t\tast_log(LOG_WARNING, \"Received trunked frame before first full voice frame\\n \");\n\t\t\tiax2_vnak(fr->callno);\n\t\t} else {\n\t\t\tf.subclass = iaxs[fr->callno]->voiceformat;\n\t\t\tf.datalen = len;\n\t\t\tif (f.datalen >= 0) {\n\t\t\t\tif (f.datalen)\n\t\t\t\t\tf.data = ptr;\n\t\t\t\telse\n\t\t\t\t\tf.data = NULL;\n\t\t\t\tif (trunked_ts)\n\t\t\t\t\tfr->ts = (iaxs[fr->callno]->last & 0xFFFF0000L) | (trunked_ts & 0xffff);\n\t\t\t\telse\n\t\t\t\t\tfr->ts = fix_peerts(&rxtrunktime, fr->callno, ts);\n\t\t\t\t/* Don't pass any packets until we're started */\n\t\t\t\tif (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)) {\n\t\t\t\t\tstruct iax_frame *duped_fr;\n\n\t\t\t\t\t/* Common things */\n\t\t\t\t\tf.src = \"IAX2\";\n\t\t\t\t\tf.mallocd = 0;\n\t\t\t\t\tf.offset = 0;\n\t\t\t\t\tif (f.datalen && (f.frametype == AST_FRAME_VOICE)) \n\t\t\t\t\t\tf.samples = ast_codec_get_samples(&f);\n\t\t\t\t\telse\n\t\t\t\t\t\tf.samples = 0;\n\t\t\t\t\tfr->outoforder = 0;\n\t\t\t\t\tiax_frame_wrap(fr, &f);\n\t\t\t\t\tduped_fr = iaxfrdup2(fr);\n\t\t\t\t\tif (duped_fr)\n\t\t\t\t\t\tschedule_delivery(duped_fr, 1, 1, &fr->ts);\n\t\t\t\t\tif (iaxs[fr->callno] && iaxs[fr->callno]->last < fr->ts)\n\t\t\t\t\t\tiaxs[fr->callno]->last = fr->ts;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tast_log(LOG_WARNING, \"Datalen < 0?\\n\");\n\t\t\t}\n\t\t}\n\t\tast_mutex_unlock(&iaxsl[fr->callno]);\n\t\tptr += len;\n\t\tpacket_len -= len;\n\t}\n\n\treturn 1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -66,7 +66,7 @@\n \t\t/* Stop if we don't have enough data */\n \t\tif (len > packet_len)\n \t\t\tbreak;\n-\t\tfr->callno = find_callno_locked(callno & ~IAX_FLAG_FULL, 0, sin, NEW_PREVENT, sockfd);\n+\t\tfr->callno = find_callno_locked(callno & ~IAX_FLAG_FULL, 0, sin, NEW_PREVENT, sockfd, 0);\n \t\tif (!fr->callno)\n \t\t\tcontinue;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tfr->callno = find_callno_locked(callno & ~IAX_FLAG_FULL, 0, sin, NEW_PREVENT, sockfd);"
            ],
            "added_lines": [
                "\t\tfr->callno = find_callno_locked(callno & ~IAX_FLAG_FULL, 0, sin, NEW_PREVENT, sockfd, 0);"
            ]
        }
    },
    {
        "cve_id": "CVE-2008-1897",
        "func_name": "silentindark/asterisk-1/find_callno_locked",
        "description": "The IAX2 channel driver (chan_iax2) in Asterisk Open Source 1.0.x, 1.2.x before 1.2.28, and 1.4.x before 1.4.19.1; Business Edition A.x.x, B.x.x before B.2.5.2, and C.x.x before C.1.8.1; AsteriskNOW before 1.0.3; Appliance Developer Kit 0.x.x; and s800i before 1.1.0.3, when configured to allow unauthenticated calls, does not verify that an ACK response contains a call number matching the server's reply to a NEW message, which allows remote attackers to cause a denial of service (traffic amplification) via a spoofed ACK response that does not complete a 3-way handshake.  NOTE: this issue exists because of an incomplete fix for CVE-2008-1923.",
        "git_url": "https://github.com/silentindark/asterisk-1/commit/fe8b7f31db687f8b9992864b82c93d22833019c7",
        "commit_title": "Merged revisions 114558 via svnmerge from ",
        "commit_text": "https://origsvn.digium.com/svn/asterisk/branches/1.4  ........ r114558 | russell | 2008-04-22 17:15:36 -0500 (Tue, 22 Apr 2008) | 5 lines  When we receive a full frame that is supposed to contain our call number, ensure that it has the correct one. (closes issue #10078) (AST-2008-006)  ........  ",
        "func_before": "static int find_callno_locked(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd) {\n\n\treturn __find_callno(callno, dcallno, sin, new, sockfd, 1);\n}",
        "func": "static int find_callno_locked(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int full_frame) {\n\n\treturn __find_callno(callno, dcallno, sin, new, sockfd, 1, full_frame);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,4 @@\n-static int find_callno_locked(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd) {\n+static int find_callno_locked(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int full_frame) {\n \n-\treturn __find_callno(callno, dcallno, sin, new, sockfd, 1);\n+\treturn __find_callno(callno, dcallno, sin, new, sockfd, 1, full_frame);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "static int find_callno_locked(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd) {",
                "\treturn __find_callno(callno, dcallno, sin, new, sockfd, 1);"
            ],
            "added_lines": [
                "static int find_callno_locked(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int full_frame) {",
                "\treturn __find_callno(callno, dcallno, sin, new, sockfd, 1, full_frame);"
            ]
        }
    },
    {
        "cve_id": "CVE-2008-1897",
        "func_name": "silentindark/asterisk-1/iax2_request",
        "description": "The IAX2 channel driver (chan_iax2) in Asterisk Open Source 1.0.x, 1.2.x before 1.2.28, and 1.4.x before 1.4.19.1; Business Edition A.x.x, B.x.x before B.2.5.2, and C.x.x before C.1.8.1; AsteriskNOW before 1.0.3; Appliance Developer Kit 0.x.x; and s800i before 1.1.0.3, when configured to allow unauthenticated calls, does not verify that an ACK response contains a call number matching the server's reply to a NEW message, which allows remote attackers to cause a denial of service (traffic amplification) via a spoofed ACK response that does not complete a 3-way handshake.  NOTE: this issue exists because of an incomplete fix for CVE-2008-1923.",
        "git_url": "https://github.com/silentindark/asterisk-1/commit/fe8b7f31db687f8b9992864b82c93d22833019c7",
        "commit_title": "Merged revisions 114558 via svnmerge from ",
        "commit_text": "https://origsvn.digium.com/svn/asterisk/branches/1.4  ........ r114558 | russell | 2008-04-22 17:15:36 -0500 (Tue, 22 Apr 2008) | 5 lines  When we receive a full frame that is supposed to contain our call number, ensure that it has the correct one. (closes issue #10078) (AST-2008-006)  ........  ",
        "func_before": "static struct ast_channel *iax2_request(const char *type, int format, void *data, int *cause)\n{\n\tint callno;\n\tint res;\n\tint fmt, native;\n\tstruct sockaddr_in sin;\n\tstruct ast_channel *c;\n\tstruct parsed_dial_string pds;\n\tstruct create_addr_info cai;\n\tchar *tmpstr;\n\n\tmemset(&pds, 0, sizeof(pds));\n\ttmpstr = ast_strdupa(data);\n\tparse_dial_string(tmpstr, &pds);\n\n\tif (ast_strlen_zero(pds.peer)) {\n\t\tast_log(LOG_WARNING, \"No peer provided in the IAX2 dial string '%s'\\n\", (char *) data);\n\t\treturn NULL;\n\t}\n\t       \n\tmemset(&cai, 0, sizeof(cai));\n\tcai.capability = iax2_capability;\n\n\tast_copy_flags(&cai, &globalflags, IAX_NOTRANSFER | IAX_TRANSFERMEDIA | IAX_USEJITTERBUF | IAX_FORCEJITTERBUF);\n\t\n\t/* Populate our address from the given */\n\tif (create_addr(pds.peer, NULL, &sin, &cai)) {\n\t\t*cause = AST_CAUSE_UNREGISTERED;\n\t\treturn NULL;\n\t}\n\n\tif (pds.port)\n\t\tsin.sin_port = htons(atoi(pds.port));\n\n\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd);\n\tif (callno < 1) {\n\t\tast_log(LOG_WARNING, \"Unable to create call\\n\");\n\t\t*cause = AST_CAUSE_CONGESTION;\n\t\treturn NULL;\n\t}\n\n\t/* If this is a trunk, update it now */\n\tast_copy_flags(iaxs[callno], &cai, IAX_TRUNK | IAX_SENDANI | IAX_NOTRANSFER | IAX_TRANSFERMEDIA | IAX_USEJITTERBUF | IAX_FORCEJITTERBUF);\t\n\tif (ast_test_flag(&cai, IAX_TRUNK)) {\n\t\tint new_callno;\n\t\tif ((new_callno = make_trunk(callno, 1)) != -1)\n\t\t\tcallno = new_callno;\n\t}\n\tiaxs[callno]->maxtime = cai.maxtime;\n\tif (cai.found)\n\t\tast_string_field_set(iaxs[callno], host, pds.peer);\n\n\tc = ast_iax2_new(callno, AST_STATE_DOWN, cai.capability);\n\n\tast_mutex_unlock(&iaxsl[callno]);\n\n\tif (c) {\n\t\t/* Choose a format we can live with */\n\t\tif (c->nativeformats & format) \n\t\t\tc->nativeformats &= format;\n\t\telse {\n\t\t\tnative = c->nativeformats;\n\t\t\tfmt = format;\n\t\t\tres = ast_translator_best_choice(&fmt, &native);\n\t\t\tif (res < 0) {\n\t\t\t\tast_log(LOG_WARNING, \"Unable to create translator path for %s to %s on %s\\n\",\n\t\t\t\t\tast_getformatname(c->nativeformats), ast_getformatname(fmt), c->name);\n\t\t\t\tast_hangup(c);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tc->nativeformats = native;\n\t\t}\n\t\tc->readformat = ast_best_codec(c->nativeformats);\n\t\tc->writeformat = c->readformat;\n\t}\n\n\treturn c;\n}",
        "func": "static struct ast_channel *iax2_request(const char *type, int format, void *data, int *cause)\n{\n\tint callno;\n\tint res;\n\tint fmt, native;\n\tstruct sockaddr_in sin;\n\tstruct ast_channel *c;\n\tstruct parsed_dial_string pds;\n\tstruct create_addr_info cai;\n\tchar *tmpstr;\n\n\tmemset(&pds, 0, sizeof(pds));\n\ttmpstr = ast_strdupa(data);\n\tparse_dial_string(tmpstr, &pds);\n\n\tif (ast_strlen_zero(pds.peer)) {\n\t\tast_log(LOG_WARNING, \"No peer provided in the IAX2 dial string '%s'\\n\", (char *) data);\n\t\treturn NULL;\n\t}\n\t       \n\tmemset(&cai, 0, sizeof(cai));\n\tcai.capability = iax2_capability;\n\n\tast_copy_flags(&cai, &globalflags, IAX_NOTRANSFER | IAX_TRANSFERMEDIA | IAX_USEJITTERBUF | IAX_FORCEJITTERBUF);\n\t\n\t/* Populate our address from the given */\n\tif (create_addr(pds.peer, NULL, &sin, &cai)) {\n\t\t*cause = AST_CAUSE_UNREGISTERED;\n\t\treturn NULL;\n\t}\n\n\tif (pds.port)\n\t\tsin.sin_port = htons(atoi(pds.port));\n\n\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd, 0);\n\tif (callno < 1) {\n\t\tast_log(LOG_WARNING, \"Unable to create call\\n\");\n\t\t*cause = AST_CAUSE_CONGESTION;\n\t\treturn NULL;\n\t}\n\n\t/* If this is a trunk, update it now */\n\tast_copy_flags(iaxs[callno], &cai, IAX_TRUNK | IAX_SENDANI | IAX_NOTRANSFER | IAX_TRANSFERMEDIA | IAX_USEJITTERBUF | IAX_FORCEJITTERBUF);\t\n\tif (ast_test_flag(&cai, IAX_TRUNK)) {\n\t\tint new_callno;\n\t\tif ((new_callno = make_trunk(callno, 1)) != -1)\n\t\t\tcallno = new_callno;\n\t}\n\tiaxs[callno]->maxtime = cai.maxtime;\n\tif (cai.found)\n\t\tast_string_field_set(iaxs[callno], host, pds.peer);\n\n\tc = ast_iax2_new(callno, AST_STATE_DOWN, cai.capability);\n\n\tast_mutex_unlock(&iaxsl[callno]);\n\n\tif (c) {\n\t\t/* Choose a format we can live with */\n\t\tif (c->nativeformats & format) \n\t\t\tc->nativeformats &= format;\n\t\telse {\n\t\t\tnative = c->nativeformats;\n\t\t\tfmt = format;\n\t\t\tres = ast_translator_best_choice(&fmt, &native);\n\t\t\tif (res < 0) {\n\t\t\t\tast_log(LOG_WARNING, \"Unable to create translator path for %s to %s on %s\\n\",\n\t\t\t\t\tast_getformatname(c->nativeformats), ast_getformatname(fmt), c->name);\n\t\t\t\tast_hangup(c);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tc->nativeformats = native;\n\t\t}\n\t\tc->readformat = ast_best_codec(c->nativeformats);\n\t\tc->writeformat = c->readformat;\n\t}\n\n\treturn c;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -32,7 +32,7 @@\n \tif (pds.port)\n \t\tsin.sin_port = htons(atoi(pds.port));\n \n-\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd);\n+\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd, 0);\n \tif (callno < 1) {\n \t\tast_log(LOG_WARNING, \"Unable to create call\\n\");\n \t\t*cause = AST_CAUSE_CONGESTION;",
        "diff_line_info": {
            "deleted_lines": [
                "\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd);"
            ],
            "added_lines": [
                "\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd, 0);"
            ]
        }
    },
    {
        "cve_id": "CVE-2008-1897",
        "func_name": "silentindark/asterisk-1/__find_callno",
        "description": "The IAX2 channel driver (chan_iax2) in Asterisk Open Source 1.0.x, 1.2.x before 1.2.28, and 1.4.x before 1.4.19.1; Business Edition A.x.x, B.x.x before B.2.5.2, and C.x.x before C.1.8.1; AsteriskNOW before 1.0.3; Appliance Developer Kit 0.x.x; and s800i before 1.1.0.3, when configured to allow unauthenticated calls, does not verify that an ACK response contains a call number matching the server's reply to a NEW message, which allows remote attackers to cause a denial of service (traffic amplification) via a spoofed ACK response that does not complete a 3-way handshake.  NOTE: this issue exists because of an incomplete fix for CVE-2008-1923.",
        "git_url": "https://github.com/silentindark/asterisk-1/commit/fe8b7f31db687f8b9992864b82c93d22833019c7",
        "commit_title": "Merged revisions 114558 via svnmerge from ",
        "commit_text": "https://origsvn.digium.com/svn/asterisk/branches/1.4  ........ r114558 | russell | 2008-04-22 17:15:36 -0500 (Tue, 22 Apr 2008) | 5 lines  When we receive a full frame that is supposed to contain our call number, ensure that it has the correct one. (closes issue #10078) (AST-2008-006)  ........  ",
        "func_before": "static int __find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int return_locked)\n{\n\tint res = 0;\n\tint x;\n\tstruct timeval now;\n\tchar host[80];\n\n\tif (new <= NEW_ALLOW) {\n\t\tfor (x=1;(res < 1) && (x<maxnontrunkcall);x++) {\n\t\t\tast_mutex_lock(&iaxsl[x]);\n\t\t\tif (iaxs[x]) {\n\t\t\t\t/* Look for an exact match */\n\t\t\t\tif (match(sin, callno, dcallno, iaxs[x])) {\n\t\t\t\t\tres = x;\n\t\t\t\t}\n\t\t\t}\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t}\n\t\tfor (x=TRUNK_CALL_START;(res < 1) && (x<maxtrunkcall);x++) {\n\t\t\tast_mutex_lock(&iaxsl[x]);\n\t\t\tif (iaxs[x]) {\n\t\t\t\t/* Look for an exact match */\n\t\t\t\tif (match(sin, callno, dcallno, iaxs[x])) {\n\t\t\t\t\tres = x;\n\t\t\t\t}\n\t\t\t}\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t}\n\t}\n\tif ((res < 1) && (new >= NEW_ALLOW)) {\n\t\t/* It may seem odd that we look through the peer list for a name for\n\t\t * this *incoming* call.  Well, it is weird.  However, users don't\n\t\t * have an IP address/port number that we can match against.  So,\n\t\t * this is just checking for a peer that has that IP/port and\n\t\t * assuming that we have a user of the same name.  This isn't always\n\t\t * correct, but it will be changed if needed after authentication. */\n\t\tif (!iax2_getpeername(*sin, host, sizeof(host)))\n\t\t\tsnprintf(host, sizeof(host), \"%s:%d\", ast_inet_ntoa(sin->sin_addr), ntohs(sin->sin_port));\n\t\tnow = ast_tvnow();\n\t\tfor (x=1;x<TRUNK_CALL_START;x++) {\n\t\t\t/* Find first unused call number that hasn't been used in a while */\n\t\t\tast_mutex_lock(&iaxsl[x]);\n\t\t\tif (!iaxs[x] && ((now.tv_sec - lastused[x].tv_sec) > MIN_REUSE_TIME)) break;\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t}\n\t\t/* We've still got lock held if we found a spot */\n\t\tif (x >= TRUNK_CALL_START) {\n\t\t\tast_log(LOG_WARNING, \"No more space\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tiaxs[x] = new_iax(sin, host);\n\t\tupdate_max_nontrunk();\n\t\tif (iaxs[x]) {\n\t\t\tif (iaxdebug)\n\t\t\t\tast_debug(1, \"Creating new call structure %d\\n\", x);\n\t\t\tiaxs[x]->sockfd = sockfd;\n\t\t\tiaxs[x]->addr.sin_port = sin->sin_port;\n\t\t\tiaxs[x]->addr.sin_family = sin->sin_family;\n\t\t\tiaxs[x]->addr.sin_addr.s_addr = sin->sin_addr.s_addr;\n\t\t\tiaxs[x]->peercallno = callno;\n\t\t\tiaxs[x]->callno = x;\n\t\t\tiaxs[x]->pingtime = DEFAULT_RETRY_TIME;\n\t\t\tiaxs[x]->expiry = min_reg_expire;\n\t\t\tiaxs[x]->pingid = iax2_sched_add(sched, ping_time * 1000, send_ping, (void *)(long)x);\n\t\t\tiaxs[x]->lagid = iax2_sched_add(sched, lagrq_time * 1000, send_lagrq, (void *)(long)x);\n\t\t\tiaxs[x]->amaflags = amaflags;\n\t\t\tast_copy_flags(iaxs[x], (&globalflags), IAX_NOTRANSFER | IAX_TRANSFERMEDIA | IAX_USEJITTERBUF | IAX_FORCEJITTERBUF);\n\t\t\t\n\t\t\tast_string_field_set(iaxs[x], accountcode, accountcode);\n\t\t\tast_string_field_set(iaxs[x], mohinterpret, mohinterpret);\n\t\t\tast_string_field_set(iaxs[x], mohsuggest, mohsuggest);\n\t\t\tast_string_field_set(iaxs[x], parkinglot, default_parkinglot);\n\t\t} else {\n\t\t\tast_log(LOG_WARNING, \"Out of resources\\n\");\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t\treturn 0;\n\t\t}\n\t\tif (!return_locked)\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\tres = x;\n\t}\n\treturn res;\n}",
        "func": "static int __find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int return_locked, int full_frame)\n{\n\tint res = 0;\n\tint x;\n\tstruct timeval now;\n\tchar host[80];\n\n\tif (new <= NEW_ALLOW) {\n\t\tfor (x=1;(res < 1) && (x<maxnontrunkcall);x++) {\n\t\t\tast_mutex_lock(&iaxsl[x]);\n\t\t\tif (iaxs[x]) {\n\t\t\t\t/* Look for an exact match */\n\t\t\t\tif (match(sin, callno, dcallno, iaxs[x], full_frame)) {\n\t\t\t\t\tres = x;\n\t\t\t\t}\n\t\t\t}\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t}\n\t\tfor (x=TRUNK_CALL_START;(res < 1) && (x<maxtrunkcall);x++) {\n\t\t\tast_mutex_lock(&iaxsl[x]);\n\t\t\tif (iaxs[x]) {\n\t\t\t\t/* Look for an exact match */\n\t\t\t\tif (match(sin, callno, dcallno, iaxs[x], full_frame)) {\n\t\t\t\t\tres = x;\n\t\t\t\t}\n\t\t\t}\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t}\n\t}\n\tif ((res < 1) && (new >= NEW_ALLOW)) {\n\t\tint start, found = 0;\n\n\t\t/* It may seem odd that we look through the peer list for a name for\n\t\t * this *incoming* call.  Well, it is weird.  However, users don't\n\t\t * have an IP address/port number that we can match against.  So,\n\t\t * this is just checking for a peer that has that IP/port and\n\t\t * assuming that we have a user of the same name.  This isn't always\n\t\t * correct, but it will be changed if needed after authentication. */\n\t\tif (!iax2_getpeername(*sin, host, sizeof(host)))\n\t\t\tsnprintf(host, sizeof(host), \"%s:%d\", ast_inet_ntoa(sin->sin_addr), ntohs(sin->sin_port));\n\n\t\tnow = ast_tvnow();\n\t\tstart = 1 + (ast_random() % (TRUNK_CALL_START - 1));\n\t\tfor (x = start; 1; x++) {\n\t\t\tif (x == TRUNK_CALL_START) {\n\t\t\t\tx = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* Find first unused call number that hasn't been used in a while */\n\t\t\tast_mutex_lock(&iaxsl[x]);\n\t\t\tif (!iaxs[x] && ((now.tv_sec - lastused[x].tv_sec) > MIN_REUSE_TIME)) {\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t\t\n\t\t\tif (x == start - 1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/* We've still got lock held if we found a spot */\n\t\tif (x == start - 1 && !found) {\n\t\t\tast_log(LOG_WARNING, \"No more space\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tiaxs[x] = new_iax(sin, host);\n\t\tupdate_max_nontrunk();\n\t\tif (iaxs[x]) {\n\t\t\tif (iaxdebug)\n\t\t\t\tast_debug(1, \"Creating new call structure %d\\n\", x);\n\t\t\tiaxs[x]->sockfd = sockfd;\n\t\t\tiaxs[x]->addr.sin_port = sin->sin_port;\n\t\t\tiaxs[x]->addr.sin_family = sin->sin_family;\n\t\t\tiaxs[x]->addr.sin_addr.s_addr = sin->sin_addr.s_addr;\n\t\t\tiaxs[x]->peercallno = callno;\n\t\t\tiaxs[x]->callno = x;\n\t\t\tiaxs[x]->pingtime = DEFAULT_RETRY_TIME;\n\t\t\tiaxs[x]->expiry = min_reg_expire;\n\t\t\tiaxs[x]->pingid = iax2_sched_add(sched, ping_time * 1000, send_ping, (void *)(long)x);\n\t\t\tiaxs[x]->lagid = iax2_sched_add(sched, lagrq_time * 1000, send_lagrq, (void *)(long)x);\n\t\t\tiaxs[x]->amaflags = amaflags;\n\t\t\tast_copy_flags(iaxs[x], (&globalflags), IAX_NOTRANSFER | IAX_TRANSFERMEDIA | IAX_USEJITTERBUF | IAX_FORCEJITTERBUF);\n\t\t\t\n\t\t\tast_string_field_set(iaxs[x], accountcode, accountcode);\n\t\t\tast_string_field_set(iaxs[x], mohinterpret, mohinterpret);\n\t\t\tast_string_field_set(iaxs[x], mohsuggest, mohsuggest);\n\t\t\tast_string_field_set(iaxs[x], parkinglot, default_parkinglot);\n\t\t} else {\n\t\t\tast_log(LOG_WARNING, \"Out of resources\\n\");\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t\treturn 0;\n\t\t}\n\t\tif (!return_locked)\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\tres = x;\n\t}\n\treturn res;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,4 @@\n-static int __find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int return_locked)\n+static int __find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int return_locked, int full_frame)\n {\n \tint res = 0;\n \tint x;\n@@ -10,7 +10,7 @@\n \t\t\tast_mutex_lock(&iaxsl[x]);\n \t\t\tif (iaxs[x]) {\n \t\t\t\t/* Look for an exact match */\n-\t\t\t\tif (match(sin, callno, dcallno, iaxs[x])) {\n+\t\t\t\tif (match(sin, callno, dcallno, iaxs[x], full_frame)) {\n \t\t\t\t\tres = x;\n \t\t\t\t}\n \t\t\t}\n@@ -20,7 +20,7 @@\n \t\t\tast_mutex_lock(&iaxsl[x]);\n \t\t\tif (iaxs[x]) {\n \t\t\t\t/* Look for an exact match */\n-\t\t\t\tif (match(sin, callno, dcallno, iaxs[x])) {\n+\t\t\t\tif (match(sin, callno, dcallno, iaxs[x], full_frame)) {\n \t\t\t\t\tres = x;\n \t\t\t\t}\n \t\t\t}\n@@ -28,6 +28,8 @@\n \t\t}\n \t}\n \tif ((res < 1) && (new >= NEW_ALLOW)) {\n+\t\tint start, found = 0;\n+\n \t\t/* It may seem odd that we look through the peer list for a name for\n \t\t * this *incoming* call.  Well, it is weird.  However, users don't\n \t\t * have an IP address/port number that we can match against.  So,\n@@ -36,15 +38,29 @@\n \t\t * correct, but it will be changed if needed after authentication. */\n \t\tif (!iax2_getpeername(*sin, host, sizeof(host)))\n \t\t\tsnprintf(host, sizeof(host), \"%s:%d\", ast_inet_ntoa(sin->sin_addr), ntohs(sin->sin_port));\n+\n \t\tnow = ast_tvnow();\n-\t\tfor (x=1;x<TRUNK_CALL_START;x++) {\n+\t\tstart = 1 + (ast_random() % (TRUNK_CALL_START - 1));\n+\t\tfor (x = start; 1; x++) {\n+\t\t\tif (x == TRUNK_CALL_START) {\n+\t\t\t\tx = 0;\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\n \t\t\t/* Find first unused call number that hasn't been used in a while */\n \t\t\tast_mutex_lock(&iaxsl[x]);\n-\t\t\tif (!iaxs[x] && ((now.tv_sec - lastused[x].tv_sec) > MIN_REUSE_TIME)) break;\n+\t\t\tif (!iaxs[x] && ((now.tv_sec - lastused[x].tv_sec) > MIN_REUSE_TIME)) {\n+\t\t\t\tfound = 1;\n+\t\t\t\tbreak;\n+\t\t\t}\n \t\t\tast_mutex_unlock(&iaxsl[x]);\n+\t\t\t\n+\t\t\tif (x == start - 1) {\n+\t\t\t\tbreak;\n+\t\t\t}\n \t\t}\n \t\t/* We've still got lock held if we found a spot */\n-\t\tif (x >= TRUNK_CALL_START) {\n+\t\tif (x == start - 1 && !found) {\n \t\t\tast_log(LOG_WARNING, \"No more space\\n\");\n \t\t\treturn 0;\n \t\t}",
        "diff_line_info": {
            "deleted_lines": [
                "static int __find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int return_locked)",
                "\t\t\t\tif (match(sin, callno, dcallno, iaxs[x])) {",
                "\t\t\t\tif (match(sin, callno, dcallno, iaxs[x])) {",
                "\t\tfor (x=1;x<TRUNK_CALL_START;x++) {",
                "\t\t\tif (!iaxs[x] && ((now.tv_sec - lastused[x].tv_sec) > MIN_REUSE_TIME)) break;",
                "\t\tif (x >= TRUNK_CALL_START) {"
            ],
            "added_lines": [
                "static int __find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int return_locked, int full_frame)",
                "\t\t\t\tif (match(sin, callno, dcallno, iaxs[x], full_frame)) {",
                "\t\t\t\tif (match(sin, callno, dcallno, iaxs[x], full_frame)) {",
                "\t\tint start, found = 0;",
                "",
                "",
                "\t\tstart = 1 + (ast_random() % (TRUNK_CALL_START - 1));",
                "\t\tfor (x = start; 1; x++) {",
                "\t\t\tif (x == TRUNK_CALL_START) {",
                "\t\t\t\tx = 0;",
                "\t\t\t\tcontinue;",
                "\t\t\t}",
                "",
                "\t\t\tif (!iaxs[x] && ((now.tv_sec - lastused[x].tv_sec) > MIN_REUSE_TIME)) {",
                "\t\t\t\tfound = 1;",
                "\t\t\t\tbreak;",
                "\t\t\t}",
                "\t\t\t",
                "\t\t\tif (x == start - 1) {",
                "\t\t\t\tbreak;",
                "\t\t\t}",
                "\t\tif (x == start - 1 && !found) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2008-1897",
        "func_name": "kaoru6/asterisk/find_callno",
        "description": "The IAX2 channel driver (chan_iax2) in Asterisk Open Source 1.0.x, 1.2.x before 1.2.28, and 1.4.x before 1.4.19.1; Business Edition A.x.x, B.x.x before B.2.5.2, and C.x.x before C.1.8.1; AsteriskNOW before 1.0.3; Appliance Developer Kit 0.x.x; and s800i before 1.1.0.3, when configured to allow unauthenticated calls, does not verify that an ACK response contains a call number matching the server's reply to a NEW message, which allows remote attackers to cause a denial of service (traffic amplification) via a spoofed ACK response that does not complete a 3-way handshake.  NOTE: this issue exists because of an incomplete fix for CVE-2008-1923.",
        "git_url": "https://github.com/kaoru6/asterisk/commit/1fe14f38dd43dc894d21f85762b51208ba5c8acb",
        "commit_title": "Merged revisions 114558 via svnmerge from ",
        "commit_text": "https://origsvn.digium.com/svn/asterisk/branches/1.4  ........ r114558 | russell | 2008-04-22 17:15:36 -0500 (Tue, 22 Apr 2008) | 5 lines  When we receive a full frame that is supposed to contain our call number, ensure that it has the correct one. (closes issue #10078) (AST-2008-006)  ........  ",
        "func_before": "static int find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd) {\n\n\treturn __find_callno(callno, dcallno, sin, new, sockfd, 0);\n}",
        "func": "static int find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int full_frame) {\n\n\treturn __find_callno(callno, dcallno, sin, new, sockfd, 0, full_frame);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,4 @@\n-static int find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd) {\n+static int find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int full_frame) {\n \n-\treturn __find_callno(callno, dcallno, sin, new, sockfd, 0);\n+\treturn __find_callno(callno, dcallno, sin, new, sockfd, 0, full_frame);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "static int find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd) {",
                "\treturn __find_callno(callno, dcallno, sin, new, sockfd, 0);"
            ],
            "added_lines": [
                "static int find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int full_frame) {",
                "\treturn __find_callno(callno, dcallno, sin, new, sockfd, 0, full_frame);"
            ]
        }
    },
    {
        "cve_id": "CVE-2008-1897",
        "func_name": "kaoru6/asterisk/iax2_do_register",
        "description": "The IAX2 channel driver (chan_iax2) in Asterisk Open Source 1.0.x, 1.2.x before 1.2.28, and 1.4.x before 1.4.19.1; Business Edition A.x.x, B.x.x before B.2.5.2, and C.x.x before C.1.8.1; AsteriskNOW before 1.0.3; Appliance Developer Kit 0.x.x; and s800i before 1.1.0.3, when configured to allow unauthenticated calls, does not verify that an ACK response contains a call number matching the server's reply to a NEW message, which allows remote attackers to cause a denial of service (traffic amplification) via a spoofed ACK response that does not complete a 3-way handshake.  NOTE: this issue exists because of an incomplete fix for CVE-2008-1923.",
        "git_url": "https://github.com/kaoru6/asterisk/commit/1fe14f38dd43dc894d21f85762b51208ba5c8acb",
        "commit_title": "Merged revisions 114558 via svnmerge from ",
        "commit_text": "https://origsvn.digium.com/svn/asterisk/branches/1.4  ........ r114558 | russell | 2008-04-22 17:15:36 -0500 (Tue, 22 Apr 2008) | 5 lines  When we receive a full frame that is supposed to contain our call number, ensure that it has the correct one. (closes issue #10078) (AST-2008-006)  ........  ",
        "func_before": "static int iax2_do_register(struct iax2_registry *reg)\n{\n\tstruct iax_ie_data ied;\n\tif (iaxdebug)\n\t\tast_debug(1, \"Sending registration request for '%s'\\n\", reg->username);\n\n\tif (reg->dnsmgr && \n\t    ((reg->regstate == REG_STATE_TIMEOUT) || !reg->addr.sin_addr.s_addr)) {\n\t\t/* Maybe the IP has changed, force DNS refresh */\n\t\tast_dnsmgr_refresh(reg->dnsmgr);\n\t}\n\t\n\t/*\n\t * if IP has Changed, free allocated call to create a new one with new IP\n\t * call has the pointer to IP and must be updated to the new one\n\t */\n\tif (reg->dnsmgr && ast_dnsmgr_changed(reg->dnsmgr) && (reg->callno > 0)) {\n\t\tast_mutex_lock(&iaxsl[reg->callno]);\n\t\tiax2_destroy(reg->callno);\n\t\tast_mutex_unlock(&iaxsl[reg->callno]);\n\t\treg->callno = 0;\n\t}\n\tif (!reg->addr.sin_addr.s_addr) {\n\t\tif (iaxdebug)\n\t\t\tast_debug(1, \"Unable to send registration request for '%s' without IP address\\n\", reg->username);\n\t\t/* Setup the next registration attempt */\n\t\treg->expire = iax2_sched_replace(reg->expire, sched, \n\t\t\t(5 * reg->refresh / 6) * 1000, iax2_do_register_s, reg);\n\t\treturn -1;\n\t}\n\n\tif (!reg->callno) {\n\t\tast_debug(1, \"Allocate call number\\n\");\n\t\treg->callno = find_callno_locked(0, 0, &reg->addr, NEW_FORCE, defaultsockfd);\n\t\tif (reg->callno < 1) {\n\t\t\tast_log(LOG_WARNING, \"Unable to create call for registration\\n\");\n\t\t\treturn -1;\n\t\t} else\n\t\t\tast_debug(1, \"Registration created on call %d\\n\", reg->callno);\n\t\tiaxs[reg->callno]->reg = reg;\n\t\tast_mutex_unlock(&iaxsl[reg->callno]);\n\t}\n\t/* Setup the next registration a little early */\n\treg->expire = iax2_sched_replace(reg->expire, sched, \n\t\t(5 * reg->refresh / 6) * 1000, iax2_do_register_s, reg);\n\t/* Send the request */\n\tmemset(&ied, 0, sizeof(ied));\n\tiax_ie_append_str(&ied, IAX_IE_USERNAME, reg->username);\n\tiax_ie_append_short(&ied, IAX_IE_REFRESH, reg->refresh);\n\tsend_command(iaxs[reg->callno],AST_FRAME_IAX, IAX_COMMAND_REGREQ, 0, ied.buf, ied.pos, -1);\n\treg->regstate = REG_STATE_REGSENT;\n\treturn 0;\n}",
        "func": "static int iax2_do_register(struct iax2_registry *reg)\n{\n\tstruct iax_ie_data ied;\n\tif (iaxdebug)\n\t\tast_debug(1, \"Sending registration request for '%s'\\n\", reg->username);\n\n\tif (reg->dnsmgr && \n\t    ((reg->regstate == REG_STATE_TIMEOUT) || !reg->addr.sin_addr.s_addr)) {\n\t\t/* Maybe the IP has changed, force DNS refresh */\n\t\tast_dnsmgr_refresh(reg->dnsmgr);\n\t}\n\t\n\t/*\n\t * if IP has Changed, free allocated call to create a new one with new IP\n\t * call has the pointer to IP and must be updated to the new one\n\t */\n\tif (reg->dnsmgr && ast_dnsmgr_changed(reg->dnsmgr) && (reg->callno > 0)) {\n\t\tast_mutex_lock(&iaxsl[reg->callno]);\n\t\tiax2_destroy(reg->callno);\n\t\tast_mutex_unlock(&iaxsl[reg->callno]);\n\t\treg->callno = 0;\n\t}\n\tif (!reg->addr.sin_addr.s_addr) {\n\t\tif (iaxdebug)\n\t\t\tast_debug(1, \"Unable to send registration request for '%s' without IP address\\n\", reg->username);\n\t\t/* Setup the next registration attempt */\n\t\treg->expire = iax2_sched_replace(reg->expire, sched, \n\t\t\t(5 * reg->refresh / 6) * 1000, iax2_do_register_s, reg);\n\t\treturn -1;\n\t}\n\n\tif (!reg->callno) {\n\t\tast_debug(1, \"Allocate call number\\n\");\n\t\treg->callno = find_callno_locked(0, 0, &reg->addr, NEW_FORCE, defaultsockfd, 0);\n\t\tif (reg->callno < 1) {\n\t\t\tast_log(LOG_WARNING, \"Unable to create call for registration\\n\");\n\t\t\treturn -1;\n\t\t} else\n\t\t\tast_debug(1, \"Registration created on call %d\\n\", reg->callno);\n\t\tiaxs[reg->callno]->reg = reg;\n\t\tast_mutex_unlock(&iaxsl[reg->callno]);\n\t}\n\t/* Setup the next registration a little early */\n\treg->expire = iax2_sched_replace(reg->expire, sched, \n\t\t(5 * reg->refresh / 6) * 1000, iax2_do_register_s, reg);\n\t/* Send the request */\n\tmemset(&ied, 0, sizeof(ied));\n\tiax_ie_append_str(&ied, IAX_IE_USERNAME, reg->username);\n\tiax_ie_append_short(&ied, IAX_IE_REFRESH, reg->refresh);\n\tsend_command(iaxs[reg->callno],AST_FRAME_IAX, IAX_COMMAND_REGREQ, 0, ied.buf, ied.pos, -1);\n\treg->regstate = REG_STATE_REGSENT;\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -31,7 +31,7 @@\n \n \tif (!reg->callno) {\n \t\tast_debug(1, \"Allocate call number\\n\");\n-\t\treg->callno = find_callno_locked(0, 0, &reg->addr, NEW_FORCE, defaultsockfd);\n+\t\treg->callno = find_callno_locked(0, 0, &reg->addr, NEW_FORCE, defaultsockfd, 0);\n \t\tif (reg->callno < 1) {\n \t\t\tast_log(LOG_WARNING, \"Unable to create call for registration\\n\");\n \t\t\treturn -1;",
        "diff_line_info": {
            "deleted_lines": [
                "\t\treg->callno = find_callno_locked(0, 0, &reg->addr, NEW_FORCE, defaultsockfd);"
            ],
            "added_lines": [
                "\t\treg->callno = find_callno_locked(0, 0, &reg->addr, NEW_FORCE, defaultsockfd, 0);"
            ]
        }
    },
    {
        "cve_id": "CVE-2008-1897",
        "func_name": "kaoru6/asterisk/iax2_poke_peer",
        "description": "The IAX2 channel driver (chan_iax2) in Asterisk Open Source 1.0.x, 1.2.x before 1.2.28, and 1.4.x before 1.4.19.1; Business Edition A.x.x, B.x.x before B.2.5.2, and C.x.x before C.1.8.1; AsteriskNOW before 1.0.3; Appliance Developer Kit 0.x.x; and s800i before 1.1.0.3, when configured to allow unauthenticated calls, does not verify that an ACK response contains a call number matching the server's reply to a NEW message, which allows remote attackers to cause a denial of service (traffic amplification) via a spoofed ACK response that does not complete a 3-way handshake.  NOTE: this issue exists because of an incomplete fix for CVE-2008-1923.",
        "git_url": "https://github.com/kaoru6/asterisk/commit/1fe14f38dd43dc894d21f85762b51208ba5c8acb",
        "commit_title": "Merged revisions 114558 via svnmerge from ",
        "commit_text": "https://origsvn.digium.com/svn/asterisk/branches/1.4  ........ r114558 | russell | 2008-04-22 17:15:36 -0500 (Tue, 22 Apr 2008) | 5 lines  When we receive a full frame that is supposed to contain our call number, ensure that it has the correct one. (closes issue #10078) (AST-2008-006)  ........  ",
        "func_before": "static int iax2_poke_peer(struct iax2_peer *peer, int heldcall)\n{\n\tif (!peer->maxms || (!peer->addr.sin_addr.s_addr && !peer->dnsmgr)) {\n\t\t/* IF we have no IP without dnsmgr, or this isn't to be monitored, return\n\t\t  immediately after clearing things out */\n\t\tpeer->lastms = 0;\n\t\tpeer->historicms = 0;\n\t\tpeer->pokeexpire = -1;\n\t\tpeer->callno = 0;\n\t\treturn 0;\n\t}\n\tif (peer->callno > 0) {\n\t\tast_log(LOG_NOTICE, \"Still have a callno...\\n\");\n\t\tast_mutex_lock(&iaxsl[peer->callno]);\n\t\tiax2_destroy(peer->callno);\n\t\tast_mutex_unlock(&iaxsl[peer->callno]);\n\t}\n\tif (heldcall)\n\t\tast_mutex_unlock(&iaxsl[heldcall]);\n\tpeer->callno = find_callno(0, 0, &peer->addr, NEW_FORCE, peer->sockfd);\n\tif (heldcall)\n\t\tast_mutex_lock(&iaxsl[heldcall]);\n\tif (peer->callno < 1) {\n\t\tast_log(LOG_WARNING, \"Unable to allocate call for poking peer '%s'\\n\", peer->name);\n\t\treturn -1;\n\t}\n\n\t/* Speed up retransmission times for this qualify call */\n\tiaxs[peer->callno]->pingtime = peer->maxms / 4 + 1;\n\tiaxs[peer->callno]->peerpoke = peer;\n\n \tif (peer->pokeexpire > -1) {\n \t\tif (!ast_sched_del(sched, peer->pokeexpire)) {\n \t\t\tpeer->pokeexpire = -1;\n \t\t\tpeer_unref(peer);\n \t\t}\n \t}\n \n\t/* Queue up a new task to handle no reply */\n\t/* If the host is already unreachable then use the unreachable interval instead */\n\tif (peer->lastms < 0)\n \t\tpeer->pokeexpire = iax2_sched_add(sched, peer->pokefreqnotok, iax2_poke_noanswer, peer_ref(peer));\n\telse\n \t\tpeer->pokeexpire = iax2_sched_add(sched, DEFAULT_MAXMS * 2, iax2_poke_noanswer, peer_ref(peer));\n\n \tif (peer->pokeexpire == -1)\n \t\tpeer_unref(peer);\n\n\t/* And send the poke */\n\tsend_command(iaxs[peer->callno], AST_FRAME_IAX, IAX_COMMAND_POKE, 0, NULL, 0, -1);\n\n\treturn 0;\n}",
        "func": "static int iax2_poke_peer(struct iax2_peer *peer, int heldcall)\n{\n\tif (!peer->maxms || (!peer->addr.sin_addr.s_addr && !peer->dnsmgr)) {\n\t\t/* IF we have no IP without dnsmgr, or this isn't to be monitored, return\n\t\t  immediately after clearing things out */\n\t\tpeer->lastms = 0;\n\t\tpeer->historicms = 0;\n\t\tpeer->pokeexpire = -1;\n\t\tpeer->callno = 0;\n\t\treturn 0;\n\t}\n\tif (peer->callno > 0) {\n\t\tast_log(LOG_NOTICE, \"Still have a callno...\\n\");\n\t\tast_mutex_lock(&iaxsl[peer->callno]);\n\t\tiax2_destroy(peer->callno);\n\t\tast_mutex_unlock(&iaxsl[peer->callno]);\n\t}\n\tif (heldcall)\n\t\tast_mutex_unlock(&iaxsl[heldcall]);\n\tpeer->callno = find_callno(0, 0, &peer->addr, NEW_FORCE, peer->sockfd, 0);\n\tif (heldcall)\n\t\tast_mutex_lock(&iaxsl[heldcall]);\n\tif (peer->callno < 1) {\n\t\tast_log(LOG_WARNING, \"Unable to allocate call for poking peer '%s'\\n\", peer->name);\n\t\treturn -1;\n\t}\n\n\t/* Speed up retransmission times for this qualify call */\n\tiaxs[peer->callno]->pingtime = peer->maxms / 4 + 1;\n\tiaxs[peer->callno]->peerpoke = peer;\n\n \tif (peer->pokeexpire > -1) {\n \t\tif (!ast_sched_del(sched, peer->pokeexpire)) {\n \t\t\tpeer->pokeexpire = -1;\n \t\t\tpeer_unref(peer);\n \t\t}\n \t}\n \n\t/* Queue up a new task to handle no reply */\n\t/* If the host is already unreachable then use the unreachable interval instead */\n\tif (peer->lastms < 0)\n \t\tpeer->pokeexpire = iax2_sched_add(sched, peer->pokefreqnotok, iax2_poke_noanswer, peer_ref(peer));\n\telse\n \t\tpeer->pokeexpire = iax2_sched_add(sched, DEFAULT_MAXMS * 2, iax2_poke_noanswer, peer_ref(peer));\n\n \tif (peer->pokeexpire == -1)\n \t\tpeer_unref(peer);\n\n\t/* And send the poke */\n\tsend_command(iaxs[peer->callno], AST_FRAME_IAX, IAX_COMMAND_POKE, 0, NULL, 0, -1);\n\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -17,7 +17,7 @@\n \t}\n \tif (heldcall)\n \t\tast_mutex_unlock(&iaxsl[heldcall]);\n-\tpeer->callno = find_callno(0, 0, &peer->addr, NEW_FORCE, peer->sockfd);\n+\tpeer->callno = find_callno(0, 0, &peer->addr, NEW_FORCE, peer->sockfd, 0);\n \tif (heldcall)\n \t\tast_mutex_lock(&iaxsl[heldcall]);\n \tif (peer->callno < 1) {",
        "diff_line_info": {
            "deleted_lines": [
                "\tpeer->callno = find_callno(0, 0, &peer->addr, NEW_FORCE, peer->sockfd);"
            ],
            "added_lines": [
                "\tpeer->callno = find_callno(0, 0, &peer->addr, NEW_FORCE, peer->sockfd, 0);"
            ]
        }
    },
    {
        "cve_id": "CVE-2008-1897",
        "func_name": "kaoru6/asterisk/cache_get_callno_locked",
        "description": "The IAX2 channel driver (chan_iax2) in Asterisk Open Source 1.0.x, 1.2.x before 1.2.28, and 1.4.x before 1.4.19.1; Business Edition A.x.x, B.x.x before B.2.5.2, and C.x.x before C.1.8.1; AsteriskNOW before 1.0.3; Appliance Developer Kit 0.x.x; and s800i before 1.1.0.3, when configured to allow unauthenticated calls, does not verify that an ACK response contains a call number matching the server's reply to a NEW message, which allows remote attackers to cause a denial of service (traffic amplification) via a spoofed ACK response that does not complete a 3-way handshake.  NOTE: this issue exists because of an incomplete fix for CVE-2008-1923.",
        "git_url": "https://github.com/kaoru6/asterisk/commit/1fe14f38dd43dc894d21f85762b51208ba5c8acb",
        "commit_title": "Merged revisions 114558 via svnmerge from ",
        "commit_text": "https://origsvn.digium.com/svn/asterisk/branches/1.4  ........ r114558 | russell | 2008-04-22 17:15:36 -0500 (Tue, 22 Apr 2008) | 5 lines  When we receive a full frame that is supposed to contain our call number, ensure that it has the correct one. (closes issue #10078) (AST-2008-006)  ........  ",
        "func_before": "static int cache_get_callno_locked(const char *data)\n{\n\tstruct sockaddr_in sin;\n\tint x;\n\tint callno;\n\tstruct iax_ie_data ied;\n\tstruct create_addr_info cai;\n\tstruct parsed_dial_string pds;\n\tchar *tmpstr;\n\n\tfor (x=0; x<IAX_MAX_CALLS; x++) {\n\t\t/* Look for an *exact match* call.  Once a call is negotiated, it can only\n\t\t   look up entries for a single context */\n\t\tif (!ast_mutex_trylock(&iaxsl[x])) {\n\t\t\tif (iaxs[x] && !strcasecmp(data, iaxs[x]->dproot))\n\t\t\t\treturn x;\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t}\n\t}\n\n\t/* No match found, we need to create a new one */\n\n\tmemset(&cai, 0, sizeof(cai));\n\tmemset(&ied, 0, sizeof(ied));\n\tmemset(&pds, 0, sizeof(pds));\n\n\ttmpstr = ast_strdupa(data);\n\tparse_dial_string(tmpstr, &pds);\n\n\tif (ast_strlen_zero(pds.peer)) {\n\t\tast_log(LOG_WARNING, \"No peer provided in the IAX2 dial string '%s'\\n\", data);\n\t\treturn -1;\n\t}\n\n\t/* Populate our address from the given */\n\tif (create_addr(pds.peer, NULL, &sin, &cai))\n\t\treturn -1;\n\n\tast_debug(1, \"peer: %s, username: %s, password: %s, context: %s\\n\",\n\t\tpds.peer, pds.username, pds.password, pds.context);\n\n\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd);\n\tif (callno < 1) {\n\t\tast_log(LOG_WARNING, \"Unable to create call\\n\");\n\t\treturn -1;\n\t}\n\n\tast_string_field_set(iaxs[callno], dproot, data);\n\tiaxs[callno]->capability = IAX_CAPABILITY_FULLBANDWIDTH;\n\n\tiax_ie_append_short(&ied, IAX_IE_VERSION, IAX_PROTO_VERSION);\n\tiax_ie_append_str(&ied, IAX_IE_CALLED_NUMBER, \"TBD\");\n\t/* the string format is slightly different from a standard dial string,\n\t   because the context appears in the 'exten' position\n\t*/\n\tif (pds.exten)\n\t\tiax_ie_append_str(&ied, IAX_IE_CALLED_CONTEXT, pds.exten);\n\tif (pds.username)\n\t\tiax_ie_append_str(&ied, IAX_IE_USERNAME, pds.username);\n\tiax_ie_append_int(&ied, IAX_IE_FORMAT, IAX_CAPABILITY_FULLBANDWIDTH);\n\tiax_ie_append_int(&ied, IAX_IE_CAPABILITY, IAX_CAPABILITY_FULLBANDWIDTH);\n\t/* Keep password handy */\n\tif (pds.password)\n\t\tast_string_field_set(iaxs[callno], secret, pds.password);\n\tif (pds.key)\n\t\tast_string_field_set(iaxs[callno], outkey, pds.key);\n\t/* Start the call going */\n\tsend_command(iaxs[callno], AST_FRAME_IAX, IAX_COMMAND_NEW, 0, ied.buf, ied.pos, -1);\n\n\treturn callno;\n}",
        "func": "static int cache_get_callno_locked(const char *data)\n{\n\tstruct sockaddr_in sin;\n\tint x;\n\tint callno;\n\tstruct iax_ie_data ied;\n\tstruct create_addr_info cai;\n\tstruct parsed_dial_string pds;\n\tchar *tmpstr;\n\n\tfor (x=0; x<IAX_MAX_CALLS; x++) {\n\t\t/* Look for an *exact match* call.  Once a call is negotiated, it can only\n\t\t   look up entries for a single context */\n\t\tif (!ast_mutex_trylock(&iaxsl[x])) {\n\t\t\tif (iaxs[x] && !strcasecmp(data, iaxs[x]->dproot))\n\t\t\t\treturn x;\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t}\n\t}\n\n\t/* No match found, we need to create a new one */\n\n\tmemset(&cai, 0, sizeof(cai));\n\tmemset(&ied, 0, sizeof(ied));\n\tmemset(&pds, 0, sizeof(pds));\n\n\ttmpstr = ast_strdupa(data);\n\tparse_dial_string(tmpstr, &pds);\n\n\tif (ast_strlen_zero(pds.peer)) {\n\t\tast_log(LOG_WARNING, \"No peer provided in the IAX2 dial string '%s'\\n\", data);\n\t\treturn -1;\n\t}\n\n\t/* Populate our address from the given */\n\tif (create_addr(pds.peer, NULL, &sin, &cai))\n\t\treturn -1;\n\n\tast_debug(1, \"peer: %s, username: %s, password: %s, context: %s\\n\",\n\t\tpds.peer, pds.username, pds.password, pds.context);\n\n\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd, 0);\n\tif (callno < 1) {\n\t\tast_log(LOG_WARNING, \"Unable to create call\\n\");\n\t\treturn -1;\n\t}\n\n\tast_string_field_set(iaxs[callno], dproot, data);\n\tiaxs[callno]->capability = IAX_CAPABILITY_FULLBANDWIDTH;\n\n\tiax_ie_append_short(&ied, IAX_IE_VERSION, IAX_PROTO_VERSION);\n\tiax_ie_append_str(&ied, IAX_IE_CALLED_NUMBER, \"TBD\");\n\t/* the string format is slightly different from a standard dial string,\n\t   because the context appears in the 'exten' position\n\t*/\n\tif (pds.exten)\n\t\tiax_ie_append_str(&ied, IAX_IE_CALLED_CONTEXT, pds.exten);\n\tif (pds.username)\n\t\tiax_ie_append_str(&ied, IAX_IE_USERNAME, pds.username);\n\tiax_ie_append_int(&ied, IAX_IE_FORMAT, IAX_CAPABILITY_FULLBANDWIDTH);\n\tiax_ie_append_int(&ied, IAX_IE_CAPABILITY, IAX_CAPABILITY_FULLBANDWIDTH);\n\t/* Keep password handy */\n\tif (pds.password)\n\t\tast_string_field_set(iaxs[callno], secret, pds.password);\n\tif (pds.key)\n\t\tast_string_field_set(iaxs[callno], outkey, pds.key);\n\t/* Start the call going */\n\tsend_command(iaxs[callno], AST_FRAME_IAX, IAX_COMMAND_NEW, 0, ied.buf, ied.pos, -1);\n\n\treturn callno;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -39,7 +39,7 @@\n \tast_debug(1, \"peer: %s, username: %s, password: %s, context: %s\\n\",\n \t\tpds.peer, pds.username, pds.password, pds.context);\n \n-\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd);\n+\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd, 0);\n \tif (callno < 1) {\n \t\tast_log(LOG_WARNING, \"Unable to create call\\n\");\n \t\treturn -1;",
        "diff_line_info": {
            "deleted_lines": [
                "\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd);"
            ],
            "added_lines": [
                "\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd, 0);"
            ]
        }
    },
    {
        "cve_id": "CVE-2008-1897",
        "func_name": "kaoru6/asterisk/iax2_provision",
        "description": "The IAX2 channel driver (chan_iax2) in Asterisk Open Source 1.0.x, 1.2.x before 1.2.28, and 1.4.x before 1.4.19.1; Business Edition A.x.x, B.x.x before B.2.5.2, and C.x.x before C.1.8.1; AsteriskNOW before 1.0.3; Appliance Developer Kit 0.x.x; and s800i before 1.1.0.3, when configured to allow unauthenticated calls, does not verify that an ACK response contains a call number matching the server's reply to a NEW message, which allows remote attackers to cause a denial of service (traffic amplification) via a spoofed ACK response that does not complete a 3-way handshake.  NOTE: this issue exists because of an incomplete fix for CVE-2008-1923.",
        "git_url": "https://github.com/kaoru6/asterisk/commit/1fe14f38dd43dc894d21f85762b51208ba5c8acb",
        "commit_title": "Merged revisions 114558 via svnmerge from ",
        "commit_text": "https://origsvn.digium.com/svn/asterisk/branches/1.4  ........ r114558 | russell | 2008-04-22 17:15:36 -0500 (Tue, 22 Apr 2008) | 5 lines  When we receive a full frame that is supposed to contain our call number, ensure that it has the correct one. (closes issue #10078) (AST-2008-006)  ........  ",
        "func_before": "static int iax2_provision(struct sockaddr_in *end, int sockfd, char *dest, const char *template, int force)\n{\n\t/* Returns 1 if provisioned, -1 if not able to find destination, or 0 if no provisioning\n\t   is found for template */\n\tstruct iax_ie_data provdata;\n\tstruct iax_ie_data ied;\n\tunsigned int sig;\n\tstruct sockaddr_in sin;\n\tint callno;\n\tstruct create_addr_info cai;\n\n\tmemset(&cai, 0, sizeof(cai));\n\n\tast_debug(1, \"Provisioning '%s' from template '%s'\\n\", dest, template);\n\n\tif (iax_provision_build(&provdata, &sig, template, force)) {\n\t\tast_debug(1, \"No provisioning found for template '%s'\\n\", template);\n\t\treturn 0;\n\t}\n\n\tif (end) {\n\t\tmemcpy(&sin, end, sizeof(sin));\n\t\tcai.sockfd = sockfd;\n\t} else if (create_addr(dest, NULL, &sin, &cai))\n\t\treturn -1;\n\n\t/* Build the rest of the message */\n\tmemset(&ied, 0, sizeof(ied));\n\tiax_ie_append_raw(&ied, IAX_IE_PROVISIONING, provdata.buf, provdata.pos);\n\n\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd);\n\tif (!callno)\n\t\treturn -1;\n\n\tif (iaxs[callno]) {\n\t\t/* Schedule autodestruct in case they don't ever give us anything back */\n\t\tiaxs[callno]->autoid = iax2_sched_replace(iaxs[callno]->autoid, \n\t\t\tsched, 15000, auto_hangup, (void *)(long)callno);\n\t\tast_set_flag(iaxs[callno], IAX_PROVISION);\n\t\t/* Got a call number now, so go ahead and send the provisioning information */\n\t\tsend_command(iaxs[callno], AST_FRAME_IAX, IAX_COMMAND_PROVISION, 0, ied.buf, ied.pos, -1);\n\t}\n\tast_mutex_unlock(&iaxsl[callno]);\n\n\treturn 1;\n}",
        "func": "static int iax2_provision(struct sockaddr_in *end, int sockfd, char *dest, const char *template, int force)\n{\n\t/* Returns 1 if provisioned, -1 if not able to find destination, or 0 if no provisioning\n\t   is found for template */\n\tstruct iax_ie_data provdata;\n\tstruct iax_ie_data ied;\n\tunsigned int sig;\n\tstruct sockaddr_in sin;\n\tint callno;\n\tstruct create_addr_info cai;\n\n\tmemset(&cai, 0, sizeof(cai));\n\n\tast_debug(1, \"Provisioning '%s' from template '%s'\\n\", dest, template);\n\n\tif (iax_provision_build(&provdata, &sig, template, force)) {\n\t\tast_debug(1, \"No provisioning found for template '%s'\\n\", template);\n\t\treturn 0;\n\t}\n\n\tif (end) {\n\t\tmemcpy(&sin, end, sizeof(sin));\n\t\tcai.sockfd = sockfd;\n\t} else if (create_addr(dest, NULL, &sin, &cai))\n\t\treturn -1;\n\n\t/* Build the rest of the message */\n\tmemset(&ied, 0, sizeof(ied));\n\tiax_ie_append_raw(&ied, IAX_IE_PROVISIONING, provdata.buf, provdata.pos);\n\n\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd, 0);\n\tif (!callno)\n\t\treturn -1;\n\n\tif (iaxs[callno]) {\n\t\t/* Schedule autodestruct in case they don't ever give us anything back */\n\t\tiaxs[callno]->autoid = iax2_sched_replace(iaxs[callno]->autoid, \n\t\t\tsched, 15000, auto_hangup, (void *)(long)callno);\n\t\tast_set_flag(iaxs[callno], IAX_PROVISION);\n\t\t/* Got a call number now, so go ahead and send the provisioning information */\n\t\tsend_command(iaxs[callno], AST_FRAME_IAX, IAX_COMMAND_PROVISION, 0, ied.buf, ied.pos, -1);\n\t}\n\tast_mutex_unlock(&iaxsl[callno]);\n\n\treturn 1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -28,7 +28,7 @@\n \tmemset(&ied, 0, sizeof(ied));\n \tiax_ie_append_raw(&ied, IAX_IE_PROVISIONING, provdata.buf, provdata.pos);\n \n-\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd);\n+\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd, 0);\n \tif (!callno)\n \t\treturn -1;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd);"
            ],
            "added_lines": [
                "\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd, 0);"
            ]
        }
    },
    {
        "cve_id": "CVE-2008-1897",
        "func_name": "kaoru6/asterisk/match",
        "description": "The IAX2 channel driver (chan_iax2) in Asterisk Open Source 1.0.x, 1.2.x before 1.2.28, and 1.4.x before 1.4.19.1; Business Edition A.x.x, B.x.x before B.2.5.2, and C.x.x before C.1.8.1; AsteriskNOW before 1.0.3; Appliance Developer Kit 0.x.x; and s800i before 1.1.0.3, when configured to allow unauthenticated calls, does not verify that an ACK response contains a call number matching the server's reply to a NEW message, which allows remote attackers to cause a denial of service (traffic amplification) via a spoofed ACK response that does not complete a 3-way handshake.  NOTE: this issue exists because of an incomplete fix for CVE-2008-1923.",
        "git_url": "https://github.com/kaoru6/asterisk/commit/1fe14f38dd43dc894d21f85762b51208ba5c8acb",
        "commit_title": "Merged revisions 114558 via svnmerge from ",
        "commit_text": "https://origsvn.digium.com/svn/asterisk/branches/1.4  ........ r114558 | russell | 2008-04-22 17:15:36 -0500 (Tue, 22 Apr 2008) | 5 lines  When we receive a full frame that is supposed to contain our call number, ensure that it has the correct one. (closes issue #10078) (AST-2008-006)  ........  ",
        "func_before": "static int match(struct sockaddr_in *sin, unsigned short callno, unsigned short dcallno, const struct chan_iax2_pvt *cur)\n{\n\tif ((cur->addr.sin_addr.s_addr == sin->sin_addr.s_addr) &&\n\t\t(cur->addr.sin_port == sin->sin_port)) {\n\t\t/* This is the main host */\n\t\tif ((cur->peercallno == callno) ||\n\t\t\t((dcallno == cur->callno) && !cur->peercallno)) {\n\t\t\t/* That's us.  Be sure we keep track of the peer call number */\n\t\t\treturn 1;\n\t\t}\n\t}\n\tif ((cur->transfer.sin_addr.s_addr == sin->sin_addr.s_addr) &&\n\t    (cur->transfer.sin_port == sin->sin_port) && (cur->transferring)) {\n\t\t/* We're transferring */\n\t\tif ((dcallno == cur->callno) || (cur->transferring == TRANSFER_MEDIAPASS && cur->transfercallno == callno))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
        "func": "static int match(struct sockaddr_in *sin, unsigned short callno, unsigned short dcallno, const struct chan_iax2_pvt *cur, int full_frame)\n{\n\tif ((cur->addr.sin_addr.s_addr == sin->sin_addr.s_addr) &&\n\t\t(cur->addr.sin_port == sin->sin_port)) {\n\t\t/* This is the main host */\n\t\tif ( (cur->peercallno == 0 || cur->peercallno == callno) &&\n\t\t\t (full_frame ? dcallno == cur->callno : 1) ) {\n\t\t\t/* That's us.  Be sure we keep track of the peer call number */\n\t\t\treturn 1;\n\t\t}\n\t}\n\tif ((cur->transfer.sin_addr.s_addr == sin->sin_addr.s_addr) &&\n\t    (cur->transfer.sin_port == sin->sin_port) && (cur->transferring)) {\n\t\t/* We're transferring */\n\t\tif ((dcallno == cur->callno) || (cur->transferring == TRANSFER_MEDIAPASS && cur->transfercallno == callno))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,10 +1,10 @@\n-static int match(struct sockaddr_in *sin, unsigned short callno, unsigned short dcallno, const struct chan_iax2_pvt *cur)\n+static int match(struct sockaddr_in *sin, unsigned short callno, unsigned short dcallno, const struct chan_iax2_pvt *cur, int full_frame)\n {\n \tif ((cur->addr.sin_addr.s_addr == sin->sin_addr.s_addr) &&\n \t\t(cur->addr.sin_port == sin->sin_port)) {\n \t\t/* This is the main host */\n-\t\tif ((cur->peercallno == callno) ||\n-\t\t\t((dcallno == cur->callno) && !cur->peercallno)) {\n+\t\tif ( (cur->peercallno == 0 || cur->peercallno == callno) &&\n+\t\t\t (full_frame ? dcallno == cur->callno : 1) ) {\n \t\t\t/* That's us.  Be sure we keep track of the peer call number */\n \t\t\treturn 1;\n \t\t}",
        "diff_line_info": {
            "deleted_lines": [
                "static int match(struct sockaddr_in *sin, unsigned short callno, unsigned short dcallno, const struct chan_iax2_pvt *cur)",
                "\t\tif ((cur->peercallno == callno) ||",
                "\t\t\t((dcallno == cur->callno) && !cur->peercallno)) {"
            ],
            "added_lines": [
                "static int match(struct sockaddr_in *sin, unsigned short callno, unsigned short dcallno, const struct chan_iax2_pvt *cur, int full_frame)",
                "\t\tif ( (cur->peercallno == 0 || cur->peercallno == callno) &&",
                "\t\t\t (full_frame ? dcallno == cur->callno : 1) ) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2008-1897",
        "func_name": "kaoru6/asterisk/socket_process_meta",
        "description": "The IAX2 channel driver (chan_iax2) in Asterisk Open Source 1.0.x, 1.2.x before 1.2.28, and 1.4.x before 1.4.19.1; Business Edition A.x.x, B.x.x before B.2.5.2, and C.x.x before C.1.8.1; AsteriskNOW before 1.0.3; Appliance Developer Kit 0.x.x; and s800i before 1.1.0.3, when configured to allow unauthenticated calls, does not verify that an ACK response contains a call number matching the server's reply to a NEW message, which allows remote attackers to cause a denial of service (traffic amplification) via a spoofed ACK response that does not complete a 3-way handshake.  NOTE: this issue exists because of an incomplete fix for CVE-2008-1923.",
        "git_url": "https://github.com/kaoru6/asterisk/commit/1fe14f38dd43dc894d21f85762b51208ba5c8acb",
        "commit_title": "Merged revisions 114558 via svnmerge from ",
        "commit_text": "https://origsvn.digium.com/svn/asterisk/branches/1.4  ........ r114558 | russell | 2008-04-22 17:15:36 -0500 (Tue, 22 Apr 2008) | 5 lines  When we receive a full frame that is supposed to contain our call number, ensure that it has the correct one. (closes issue #10078) (AST-2008-006)  ........  ",
        "func_before": "static int socket_process_meta(int packet_len, struct ast_iax2_meta_hdr *meta, struct sockaddr_in *sin, int sockfd,\n\tstruct iax_frame *fr)\n{\n\tunsigned char metatype;\n\tstruct ast_iax2_meta_trunk_mini *mtm;\n\tstruct ast_iax2_meta_trunk_hdr *mth;\n\tstruct ast_iax2_meta_trunk_entry *mte;\n\tstruct iax2_trunk_peer *tpeer;\n\tunsigned int ts;\n\tvoid *ptr;\n\tstruct timeval rxtrunktime;\n\tstruct ast_frame f = { 0, };\n\n\tif (packet_len < sizeof(*meta)) {\n\t\tast_log(LOG_WARNING, \"Rejecting packet from '%s.%d' that is flagged as a meta frame but is too short\\n\", \n\t\t\tast_inet_ntoa(sin->sin_addr), ntohs(sin->sin_port));\n\t\treturn 1;\n\t}\n\n\tif (meta->metacmd != IAX_META_TRUNK)\n\t\treturn 1;\n\n\tif (packet_len < (sizeof(*meta) + sizeof(*mth))) {\n\t\tast_log(LOG_WARNING, \"midget meta trunk packet received (%d of %d min)\\n\", packet_len,\n\t\t\t(int) (sizeof(*meta) + sizeof(*mth)));\n\t\treturn 1;\n\t}\n\tmth = (struct ast_iax2_meta_trunk_hdr *)(meta->data);\n\tts = ntohl(mth->ts);\n\tmetatype = meta->cmddata;\n\tpacket_len -= (sizeof(*meta) + sizeof(*mth));\n\tptr = mth->data;\n\ttpeer = find_tpeer(sin, sockfd);\n\tif (!tpeer) {\n\t\tast_log(LOG_WARNING, \"Unable to accept trunked packet from '%s:%d': No matching peer\\n\", \n\t\t\tast_inet_ntoa(sin->sin_addr), ntohs(sin->sin_port));\n\t\treturn 1;\n\t}\n\ttpeer->trunkact = ast_tvnow();\n\tif (!ts || ast_tvzero(tpeer->rxtrunktime))\n\t\ttpeer->rxtrunktime = tpeer->trunkact;\n\trxtrunktime = tpeer->rxtrunktime;\n\tast_mutex_unlock(&tpeer->lock);\n\twhile (packet_len >= sizeof(*mte)) {\n\t\t/* Process channels */\n\t\tunsigned short callno, trunked_ts, len;\n\n\t\tif (metatype == IAX_META_TRUNK_MINI) {\n\t\t\tmtm = (struct ast_iax2_meta_trunk_mini *) ptr;\n\t\t\tptr += sizeof(*mtm);\n\t\t\tpacket_len -= sizeof(*mtm);\n\t\t\tlen = ntohs(mtm->len);\n\t\t\tcallno = ntohs(mtm->mini.callno);\n\t\t\ttrunked_ts = ntohs(mtm->mini.ts);\n\t\t} else if (metatype == IAX_META_TRUNK_SUPERMINI) {\n\t\t\tmte = (struct ast_iax2_meta_trunk_entry *)ptr;\n\t\t\tptr += sizeof(*mte);\n\t\t\tpacket_len -= sizeof(*mte);\n\t\t\tlen = ntohs(mte->len);\n\t\t\tcallno = ntohs(mte->callno);\n\t\t\ttrunked_ts = 0;\n\t\t} else {\n\t\t\tast_log(LOG_WARNING, \"Unknown meta trunk cmd from '%s:%d': dropping\\n\", ast_inet_ntoa(sin->sin_addr), ntohs(sin->sin_port));\n\t\t\tbreak;\n\t\t}\n\t\t/* Stop if we don't have enough data */\n\t\tif (len > packet_len)\n\t\t\tbreak;\n\t\tfr->callno = find_callno_locked(callno & ~IAX_FLAG_FULL, 0, sin, NEW_PREVENT, sockfd);\n\t\tif (!fr->callno)\n\t\t\tcontinue;\n\n\t\t/* If it's a valid call, deliver the contents.  If not, we\n\t\t   drop it, since we don't have a scallno to use for an INVAL */\n\t\t/* Process as a mini frame */\n\t\tmemset(&f, 0, sizeof(f));\n\t\tf.frametype = AST_FRAME_VOICE;\n\t\tif (!iaxs[fr->callno]) {\n\t\t\t/* drop it */\n\t\t} else if (iaxs[fr->callno]->voiceformat == 0) {\n\t\t\tast_log(LOG_WARNING, \"Received trunked frame before first full voice frame\\n \");\n\t\t\tiax2_vnak(fr->callno);\n\t\t} else {\n\t\t\tf.subclass = iaxs[fr->callno]->voiceformat;\n\t\t\tf.datalen = len;\n\t\t\tif (f.datalen >= 0) {\n\t\t\t\tif (f.datalen)\n\t\t\t\t\tf.data = ptr;\n\t\t\t\telse\n\t\t\t\t\tf.data = NULL;\n\t\t\t\tif (trunked_ts)\n\t\t\t\t\tfr->ts = (iaxs[fr->callno]->last & 0xFFFF0000L) | (trunked_ts & 0xffff);\n\t\t\t\telse\n\t\t\t\t\tfr->ts = fix_peerts(&rxtrunktime, fr->callno, ts);\n\t\t\t\t/* Don't pass any packets until we're started */\n\t\t\t\tif (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)) {\n\t\t\t\t\tstruct iax_frame *duped_fr;\n\n\t\t\t\t\t/* Common things */\n\t\t\t\t\tf.src = \"IAX2\";\n\t\t\t\t\tf.mallocd = 0;\n\t\t\t\t\tf.offset = 0;\n\t\t\t\t\tif (f.datalen && (f.frametype == AST_FRAME_VOICE)) \n\t\t\t\t\t\tf.samples = ast_codec_get_samples(&f);\n\t\t\t\t\telse\n\t\t\t\t\t\tf.samples = 0;\n\t\t\t\t\tfr->outoforder = 0;\n\t\t\t\t\tiax_frame_wrap(fr, &f);\n\t\t\t\t\tduped_fr = iaxfrdup2(fr);\n\t\t\t\t\tif (duped_fr)\n\t\t\t\t\t\tschedule_delivery(duped_fr, 1, 1, &fr->ts);\n\t\t\t\t\tif (iaxs[fr->callno] && iaxs[fr->callno]->last < fr->ts)\n\t\t\t\t\t\tiaxs[fr->callno]->last = fr->ts;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tast_log(LOG_WARNING, \"Datalen < 0?\\n\");\n\t\t\t}\n\t\t}\n\t\tast_mutex_unlock(&iaxsl[fr->callno]);\n\t\tptr += len;\n\t\tpacket_len -= len;\n\t}\n\n\treturn 1;\n}",
        "func": "static int socket_process_meta(int packet_len, struct ast_iax2_meta_hdr *meta, struct sockaddr_in *sin, int sockfd,\n\tstruct iax_frame *fr)\n{\n\tunsigned char metatype;\n\tstruct ast_iax2_meta_trunk_mini *mtm;\n\tstruct ast_iax2_meta_trunk_hdr *mth;\n\tstruct ast_iax2_meta_trunk_entry *mte;\n\tstruct iax2_trunk_peer *tpeer;\n\tunsigned int ts;\n\tvoid *ptr;\n\tstruct timeval rxtrunktime;\n\tstruct ast_frame f = { 0, };\n\n\tif (packet_len < sizeof(*meta)) {\n\t\tast_log(LOG_WARNING, \"Rejecting packet from '%s.%d' that is flagged as a meta frame but is too short\\n\", \n\t\t\tast_inet_ntoa(sin->sin_addr), ntohs(sin->sin_port));\n\t\treturn 1;\n\t}\n\n\tif (meta->metacmd != IAX_META_TRUNK)\n\t\treturn 1;\n\n\tif (packet_len < (sizeof(*meta) + sizeof(*mth))) {\n\t\tast_log(LOG_WARNING, \"midget meta trunk packet received (%d of %d min)\\n\", packet_len,\n\t\t\t(int) (sizeof(*meta) + sizeof(*mth)));\n\t\treturn 1;\n\t}\n\tmth = (struct ast_iax2_meta_trunk_hdr *)(meta->data);\n\tts = ntohl(mth->ts);\n\tmetatype = meta->cmddata;\n\tpacket_len -= (sizeof(*meta) + sizeof(*mth));\n\tptr = mth->data;\n\ttpeer = find_tpeer(sin, sockfd);\n\tif (!tpeer) {\n\t\tast_log(LOG_WARNING, \"Unable to accept trunked packet from '%s:%d': No matching peer\\n\", \n\t\t\tast_inet_ntoa(sin->sin_addr), ntohs(sin->sin_port));\n\t\treturn 1;\n\t}\n\ttpeer->trunkact = ast_tvnow();\n\tif (!ts || ast_tvzero(tpeer->rxtrunktime))\n\t\ttpeer->rxtrunktime = tpeer->trunkact;\n\trxtrunktime = tpeer->rxtrunktime;\n\tast_mutex_unlock(&tpeer->lock);\n\twhile (packet_len >= sizeof(*mte)) {\n\t\t/* Process channels */\n\t\tunsigned short callno, trunked_ts, len;\n\n\t\tif (metatype == IAX_META_TRUNK_MINI) {\n\t\t\tmtm = (struct ast_iax2_meta_trunk_mini *) ptr;\n\t\t\tptr += sizeof(*mtm);\n\t\t\tpacket_len -= sizeof(*mtm);\n\t\t\tlen = ntohs(mtm->len);\n\t\t\tcallno = ntohs(mtm->mini.callno);\n\t\t\ttrunked_ts = ntohs(mtm->mini.ts);\n\t\t} else if (metatype == IAX_META_TRUNK_SUPERMINI) {\n\t\t\tmte = (struct ast_iax2_meta_trunk_entry *)ptr;\n\t\t\tptr += sizeof(*mte);\n\t\t\tpacket_len -= sizeof(*mte);\n\t\t\tlen = ntohs(mte->len);\n\t\t\tcallno = ntohs(mte->callno);\n\t\t\ttrunked_ts = 0;\n\t\t} else {\n\t\t\tast_log(LOG_WARNING, \"Unknown meta trunk cmd from '%s:%d': dropping\\n\", ast_inet_ntoa(sin->sin_addr), ntohs(sin->sin_port));\n\t\t\tbreak;\n\t\t}\n\t\t/* Stop if we don't have enough data */\n\t\tif (len > packet_len)\n\t\t\tbreak;\n\t\tfr->callno = find_callno_locked(callno & ~IAX_FLAG_FULL, 0, sin, NEW_PREVENT, sockfd, 0);\n\t\tif (!fr->callno)\n\t\t\tcontinue;\n\n\t\t/* If it's a valid call, deliver the contents.  If not, we\n\t\t   drop it, since we don't have a scallno to use for an INVAL */\n\t\t/* Process as a mini frame */\n\t\tmemset(&f, 0, sizeof(f));\n\t\tf.frametype = AST_FRAME_VOICE;\n\t\tif (!iaxs[fr->callno]) {\n\t\t\t/* drop it */\n\t\t} else if (iaxs[fr->callno]->voiceformat == 0) {\n\t\t\tast_log(LOG_WARNING, \"Received trunked frame before first full voice frame\\n \");\n\t\t\tiax2_vnak(fr->callno);\n\t\t} else {\n\t\t\tf.subclass = iaxs[fr->callno]->voiceformat;\n\t\t\tf.datalen = len;\n\t\t\tif (f.datalen >= 0) {\n\t\t\t\tif (f.datalen)\n\t\t\t\t\tf.data = ptr;\n\t\t\t\telse\n\t\t\t\t\tf.data = NULL;\n\t\t\t\tif (trunked_ts)\n\t\t\t\t\tfr->ts = (iaxs[fr->callno]->last & 0xFFFF0000L) | (trunked_ts & 0xffff);\n\t\t\t\telse\n\t\t\t\t\tfr->ts = fix_peerts(&rxtrunktime, fr->callno, ts);\n\t\t\t\t/* Don't pass any packets until we're started */\n\t\t\t\tif (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)) {\n\t\t\t\t\tstruct iax_frame *duped_fr;\n\n\t\t\t\t\t/* Common things */\n\t\t\t\t\tf.src = \"IAX2\";\n\t\t\t\t\tf.mallocd = 0;\n\t\t\t\t\tf.offset = 0;\n\t\t\t\t\tif (f.datalen && (f.frametype == AST_FRAME_VOICE)) \n\t\t\t\t\t\tf.samples = ast_codec_get_samples(&f);\n\t\t\t\t\telse\n\t\t\t\t\t\tf.samples = 0;\n\t\t\t\t\tfr->outoforder = 0;\n\t\t\t\t\tiax_frame_wrap(fr, &f);\n\t\t\t\t\tduped_fr = iaxfrdup2(fr);\n\t\t\t\t\tif (duped_fr)\n\t\t\t\t\t\tschedule_delivery(duped_fr, 1, 1, &fr->ts);\n\t\t\t\t\tif (iaxs[fr->callno] && iaxs[fr->callno]->last < fr->ts)\n\t\t\t\t\t\tiaxs[fr->callno]->last = fr->ts;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tast_log(LOG_WARNING, \"Datalen < 0?\\n\");\n\t\t\t}\n\t\t}\n\t\tast_mutex_unlock(&iaxsl[fr->callno]);\n\t\tptr += len;\n\t\tpacket_len -= len;\n\t}\n\n\treturn 1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -66,7 +66,7 @@\n \t\t/* Stop if we don't have enough data */\n \t\tif (len > packet_len)\n \t\t\tbreak;\n-\t\tfr->callno = find_callno_locked(callno & ~IAX_FLAG_FULL, 0, sin, NEW_PREVENT, sockfd);\n+\t\tfr->callno = find_callno_locked(callno & ~IAX_FLAG_FULL, 0, sin, NEW_PREVENT, sockfd, 0);\n \t\tif (!fr->callno)\n \t\t\tcontinue;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tfr->callno = find_callno_locked(callno & ~IAX_FLAG_FULL, 0, sin, NEW_PREVENT, sockfd);"
            ],
            "added_lines": [
                "\t\tfr->callno = find_callno_locked(callno & ~IAX_FLAG_FULL, 0, sin, NEW_PREVENT, sockfd, 0);"
            ]
        }
    },
    {
        "cve_id": "CVE-2008-1897",
        "func_name": "kaoru6/asterisk/find_callno_locked",
        "description": "The IAX2 channel driver (chan_iax2) in Asterisk Open Source 1.0.x, 1.2.x before 1.2.28, and 1.4.x before 1.4.19.1; Business Edition A.x.x, B.x.x before B.2.5.2, and C.x.x before C.1.8.1; AsteriskNOW before 1.0.3; Appliance Developer Kit 0.x.x; and s800i before 1.1.0.3, when configured to allow unauthenticated calls, does not verify that an ACK response contains a call number matching the server's reply to a NEW message, which allows remote attackers to cause a denial of service (traffic amplification) via a spoofed ACK response that does not complete a 3-way handshake.  NOTE: this issue exists because of an incomplete fix for CVE-2008-1923.",
        "git_url": "https://github.com/kaoru6/asterisk/commit/1fe14f38dd43dc894d21f85762b51208ba5c8acb",
        "commit_title": "Merged revisions 114558 via svnmerge from ",
        "commit_text": "https://origsvn.digium.com/svn/asterisk/branches/1.4  ........ r114558 | russell | 2008-04-22 17:15:36 -0500 (Tue, 22 Apr 2008) | 5 lines  When we receive a full frame that is supposed to contain our call number, ensure that it has the correct one. (closes issue #10078) (AST-2008-006)  ........  ",
        "func_before": "static int find_callno_locked(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd) {\n\n\treturn __find_callno(callno, dcallno, sin, new, sockfd, 1);\n}",
        "func": "static int find_callno_locked(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int full_frame) {\n\n\treturn __find_callno(callno, dcallno, sin, new, sockfd, 1, full_frame);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,4 @@\n-static int find_callno_locked(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd) {\n+static int find_callno_locked(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int full_frame) {\n \n-\treturn __find_callno(callno, dcallno, sin, new, sockfd, 1);\n+\treturn __find_callno(callno, dcallno, sin, new, sockfd, 1, full_frame);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "static int find_callno_locked(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd) {",
                "\treturn __find_callno(callno, dcallno, sin, new, sockfd, 1);"
            ],
            "added_lines": [
                "static int find_callno_locked(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int full_frame) {",
                "\treturn __find_callno(callno, dcallno, sin, new, sockfd, 1, full_frame);"
            ]
        }
    },
    {
        "cve_id": "CVE-2008-1897",
        "func_name": "kaoru6/asterisk/iax2_request",
        "description": "The IAX2 channel driver (chan_iax2) in Asterisk Open Source 1.0.x, 1.2.x before 1.2.28, and 1.4.x before 1.4.19.1; Business Edition A.x.x, B.x.x before B.2.5.2, and C.x.x before C.1.8.1; AsteriskNOW before 1.0.3; Appliance Developer Kit 0.x.x; and s800i before 1.1.0.3, when configured to allow unauthenticated calls, does not verify that an ACK response contains a call number matching the server's reply to a NEW message, which allows remote attackers to cause a denial of service (traffic amplification) via a spoofed ACK response that does not complete a 3-way handshake.  NOTE: this issue exists because of an incomplete fix for CVE-2008-1923.",
        "git_url": "https://github.com/kaoru6/asterisk/commit/1fe14f38dd43dc894d21f85762b51208ba5c8acb",
        "commit_title": "Merged revisions 114558 via svnmerge from ",
        "commit_text": "https://origsvn.digium.com/svn/asterisk/branches/1.4  ........ r114558 | russell | 2008-04-22 17:15:36 -0500 (Tue, 22 Apr 2008) | 5 lines  When we receive a full frame that is supposed to contain our call number, ensure that it has the correct one. (closes issue #10078) (AST-2008-006)  ........  ",
        "func_before": "static struct ast_channel *iax2_request(const char *type, int format, void *data, int *cause)\n{\n\tint callno;\n\tint res;\n\tint fmt, native;\n\tstruct sockaddr_in sin;\n\tstruct ast_channel *c;\n\tstruct parsed_dial_string pds;\n\tstruct create_addr_info cai;\n\tchar *tmpstr;\n\n\tmemset(&pds, 0, sizeof(pds));\n\ttmpstr = ast_strdupa(data);\n\tparse_dial_string(tmpstr, &pds);\n\n\tif (ast_strlen_zero(pds.peer)) {\n\t\tast_log(LOG_WARNING, \"No peer provided in the IAX2 dial string '%s'\\n\", (char *) data);\n\t\treturn NULL;\n\t}\n\t       \n\tmemset(&cai, 0, sizeof(cai));\n\tcai.capability = iax2_capability;\n\n\tast_copy_flags(&cai, &globalflags, IAX_NOTRANSFER | IAX_TRANSFERMEDIA | IAX_USEJITTERBUF | IAX_FORCEJITTERBUF);\n\t\n\t/* Populate our address from the given */\n\tif (create_addr(pds.peer, NULL, &sin, &cai)) {\n\t\t*cause = AST_CAUSE_UNREGISTERED;\n\t\treturn NULL;\n\t}\n\n\tif (pds.port)\n\t\tsin.sin_port = htons(atoi(pds.port));\n\n\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd);\n\tif (callno < 1) {\n\t\tast_log(LOG_WARNING, \"Unable to create call\\n\");\n\t\t*cause = AST_CAUSE_CONGESTION;\n\t\treturn NULL;\n\t}\n\n\t/* If this is a trunk, update it now */\n\tast_copy_flags(iaxs[callno], &cai, IAX_TRUNK | IAX_SENDANI | IAX_NOTRANSFER | IAX_TRANSFERMEDIA | IAX_USEJITTERBUF | IAX_FORCEJITTERBUF);\t\n\tif (ast_test_flag(&cai, IAX_TRUNK)) {\n\t\tint new_callno;\n\t\tif ((new_callno = make_trunk(callno, 1)) != -1)\n\t\t\tcallno = new_callno;\n\t}\n\tiaxs[callno]->maxtime = cai.maxtime;\n\tif (cai.found)\n\t\tast_string_field_set(iaxs[callno], host, pds.peer);\n\n\tc = ast_iax2_new(callno, AST_STATE_DOWN, cai.capability);\n\n\tast_mutex_unlock(&iaxsl[callno]);\n\n\tif (c) {\n\t\t/* Choose a format we can live with */\n\t\tif (c->nativeformats & format) \n\t\t\tc->nativeformats &= format;\n\t\telse {\n\t\t\tnative = c->nativeformats;\n\t\t\tfmt = format;\n\t\t\tres = ast_translator_best_choice(&fmt, &native);\n\t\t\tif (res < 0) {\n\t\t\t\tast_log(LOG_WARNING, \"Unable to create translator path for %s to %s on %s\\n\",\n\t\t\t\t\tast_getformatname(c->nativeformats), ast_getformatname(fmt), c->name);\n\t\t\t\tast_hangup(c);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tc->nativeformats = native;\n\t\t}\n\t\tc->readformat = ast_best_codec(c->nativeformats);\n\t\tc->writeformat = c->readformat;\n\t}\n\n\treturn c;\n}",
        "func": "static struct ast_channel *iax2_request(const char *type, int format, void *data, int *cause)\n{\n\tint callno;\n\tint res;\n\tint fmt, native;\n\tstruct sockaddr_in sin;\n\tstruct ast_channel *c;\n\tstruct parsed_dial_string pds;\n\tstruct create_addr_info cai;\n\tchar *tmpstr;\n\n\tmemset(&pds, 0, sizeof(pds));\n\ttmpstr = ast_strdupa(data);\n\tparse_dial_string(tmpstr, &pds);\n\n\tif (ast_strlen_zero(pds.peer)) {\n\t\tast_log(LOG_WARNING, \"No peer provided in the IAX2 dial string '%s'\\n\", (char *) data);\n\t\treturn NULL;\n\t}\n\t       \n\tmemset(&cai, 0, sizeof(cai));\n\tcai.capability = iax2_capability;\n\n\tast_copy_flags(&cai, &globalflags, IAX_NOTRANSFER | IAX_TRANSFERMEDIA | IAX_USEJITTERBUF | IAX_FORCEJITTERBUF);\n\t\n\t/* Populate our address from the given */\n\tif (create_addr(pds.peer, NULL, &sin, &cai)) {\n\t\t*cause = AST_CAUSE_UNREGISTERED;\n\t\treturn NULL;\n\t}\n\n\tif (pds.port)\n\t\tsin.sin_port = htons(atoi(pds.port));\n\n\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd, 0);\n\tif (callno < 1) {\n\t\tast_log(LOG_WARNING, \"Unable to create call\\n\");\n\t\t*cause = AST_CAUSE_CONGESTION;\n\t\treturn NULL;\n\t}\n\n\t/* If this is a trunk, update it now */\n\tast_copy_flags(iaxs[callno], &cai, IAX_TRUNK | IAX_SENDANI | IAX_NOTRANSFER | IAX_TRANSFERMEDIA | IAX_USEJITTERBUF | IAX_FORCEJITTERBUF);\t\n\tif (ast_test_flag(&cai, IAX_TRUNK)) {\n\t\tint new_callno;\n\t\tif ((new_callno = make_trunk(callno, 1)) != -1)\n\t\t\tcallno = new_callno;\n\t}\n\tiaxs[callno]->maxtime = cai.maxtime;\n\tif (cai.found)\n\t\tast_string_field_set(iaxs[callno], host, pds.peer);\n\n\tc = ast_iax2_new(callno, AST_STATE_DOWN, cai.capability);\n\n\tast_mutex_unlock(&iaxsl[callno]);\n\n\tif (c) {\n\t\t/* Choose a format we can live with */\n\t\tif (c->nativeformats & format) \n\t\t\tc->nativeformats &= format;\n\t\telse {\n\t\t\tnative = c->nativeformats;\n\t\t\tfmt = format;\n\t\t\tres = ast_translator_best_choice(&fmt, &native);\n\t\t\tif (res < 0) {\n\t\t\t\tast_log(LOG_WARNING, \"Unable to create translator path for %s to %s on %s\\n\",\n\t\t\t\t\tast_getformatname(c->nativeformats), ast_getformatname(fmt), c->name);\n\t\t\t\tast_hangup(c);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tc->nativeformats = native;\n\t\t}\n\t\tc->readformat = ast_best_codec(c->nativeformats);\n\t\tc->writeformat = c->readformat;\n\t}\n\n\treturn c;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -32,7 +32,7 @@\n \tif (pds.port)\n \t\tsin.sin_port = htons(atoi(pds.port));\n \n-\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd);\n+\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd, 0);\n \tif (callno < 1) {\n \t\tast_log(LOG_WARNING, \"Unable to create call\\n\");\n \t\t*cause = AST_CAUSE_CONGESTION;",
        "diff_line_info": {
            "deleted_lines": [
                "\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd);"
            ],
            "added_lines": [
                "\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd, 0);"
            ]
        }
    },
    {
        "cve_id": "CVE-2008-1897",
        "func_name": "kaoru6/asterisk/__find_callno",
        "description": "The IAX2 channel driver (chan_iax2) in Asterisk Open Source 1.0.x, 1.2.x before 1.2.28, and 1.4.x before 1.4.19.1; Business Edition A.x.x, B.x.x before B.2.5.2, and C.x.x before C.1.8.1; AsteriskNOW before 1.0.3; Appliance Developer Kit 0.x.x; and s800i before 1.1.0.3, when configured to allow unauthenticated calls, does not verify that an ACK response contains a call number matching the server's reply to a NEW message, which allows remote attackers to cause a denial of service (traffic amplification) via a spoofed ACK response that does not complete a 3-way handshake.  NOTE: this issue exists because of an incomplete fix for CVE-2008-1923.",
        "git_url": "https://github.com/kaoru6/asterisk/commit/1fe14f38dd43dc894d21f85762b51208ba5c8acb",
        "commit_title": "Merged revisions 114558 via svnmerge from ",
        "commit_text": "https://origsvn.digium.com/svn/asterisk/branches/1.4  ........ r114558 | russell | 2008-04-22 17:15:36 -0500 (Tue, 22 Apr 2008) | 5 lines  When we receive a full frame that is supposed to contain our call number, ensure that it has the correct one. (closes issue #10078) (AST-2008-006)  ........  ",
        "func_before": "static int __find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int return_locked)\n{\n\tint res = 0;\n\tint x;\n\tstruct timeval now;\n\tchar host[80];\n\n\tif (new <= NEW_ALLOW) {\n\t\tfor (x=1;(res < 1) && (x<maxnontrunkcall);x++) {\n\t\t\tast_mutex_lock(&iaxsl[x]);\n\t\t\tif (iaxs[x]) {\n\t\t\t\t/* Look for an exact match */\n\t\t\t\tif (match(sin, callno, dcallno, iaxs[x])) {\n\t\t\t\t\tres = x;\n\t\t\t\t}\n\t\t\t}\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t}\n\t\tfor (x=TRUNK_CALL_START;(res < 1) && (x<maxtrunkcall);x++) {\n\t\t\tast_mutex_lock(&iaxsl[x]);\n\t\t\tif (iaxs[x]) {\n\t\t\t\t/* Look for an exact match */\n\t\t\t\tif (match(sin, callno, dcallno, iaxs[x])) {\n\t\t\t\t\tres = x;\n\t\t\t\t}\n\t\t\t}\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t}\n\t}\n\tif ((res < 1) && (new >= NEW_ALLOW)) {\n\t\t/* It may seem odd that we look through the peer list for a name for\n\t\t * this *incoming* call.  Well, it is weird.  However, users don't\n\t\t * have an IP address/port number that we can match against.  So,\n\t\t * this is just checking for a peer that has that IP/port and\n\t\t * assuming that we have a user of the same name.  This isn't always\n\t\t * correct, but it will be changed if needed after authentication. */\n\t\tif (!iax2_getpeername(*sin, host, sizeof(host)))\n\t\t\tsnprintf(host, sizeof(host), \"%s:%d\", ast_inet_ntoa(sin->sin_addr), ntohs(sin->sin_port));\n\t\tnow = ast_tvnow();\n\t\tfor (x=1;x<TRUNK_CALL_START;x++) {\n\t\t\t/* Find first unused call number that hasn't been used in a while */\n\t\t\tast_mutex_lock(&iaxsl[x]);\n\t\t\tif (!iaxs[x] && ((now.tv_sec - lastused[x].tv_sec) > MIN_REUSE_TIME)) break;\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t}\n\t\t/* We've still got lock held if we found a spot */\n\t\tif (x >= TRUNK_CALL_START) {\n\t\t\tast_log(LOG_WARNING, \"No more space\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tiaxs[x] = new_iax(sin, host);\n\t\tupdate_max_nontrunk();\n\t\tif (iaxs[x]) {\n\t\t\tif (iaxdebug)\n\t\t\t\tast_debug(1, \"Creating new call structure %d\\n\", x);\n\t\t\tiaxs[x]->sockfd = sockfd;\n\t\t\tiaxs[x]->addr.sin_port = sin->sin_port;\n\t\t\tiaxs[x]->addr.sin_family = sin->sin_family;\n\t\t\tiaxs[x]->addr.sin_addr.s_addr = sin->sin_addr.s_addr;\n\t\t\tiaxs[x]->peercallno = callno;\n\t\t\tiaxs[x]->callno = x;\n\t\t\tiaxs[x]->pingtime = DEFAULT_RETRY_TIME;\n\t\t\tiaxs[x]->expiry = min_reg_expire;\n\t\t\tiaxs[x]->pingid = iax2_sched_add(sched, ping_time * 1000, send_ping, (void *)(long)x);\n\t\t\tiaxs[x]->lagid = iax2_sched_add(sched, lagrq_time * 1000, send_lagrq, (void *)(long)x);\n\t\t\tiaxs[x]->amaflags = amaflags;\n\t\t\tast_copy_flags(iaxs[x], (&globalflags), IAX_NOTRANSFER | IAX_TRANSFERMEDIA | IAX_USEJITTERBUF | IAX_FORCEJITTERBUF);\n\t\t\t\n\t\t\tast_string_field_set(iaxs[x], accountcode, accountcode);\n\t\t\tast_string_field_set(iaxs[x], mohinterpret, mohinterpret);\n\t\t\tast_string_field_set(iaxs[x], mohsuggest, mohsuggest);\n\t\t\tast_string_field_set(iaxs[x], parkinglot, default_parkinglot);\n\t\t} else {\n\t\t\tast_log(LOG_WARNING, \"Out of resources\\n\");\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t\treturn 0;\n\t\t}\n\t\tif (!return_locked)\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\tres = x;\n\t}\n\treturn res;\n}",
        "func": "static int __find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int return_locked, int full_frame)\n{\n\tint res = 0;\n\tint x;\n\tstruct timeval now;\n\tchar host[80];\n\n\tif (new <= NEW_ALLOW) {\n\t\tfor (x=1;(res < 1) && (x<maxnontrunkcall);x++) {\n\t\t\tast_mutex_lock(&iaxsl[x]);\n\t\t\tif (iaxs[x]) {\n\t\t\t\t/* Look for an exact match */\n\t\t\t\tif (match(sin, callno, dcallno, iaxs[x], full_frame)) {\n\t\t\t\t\tres = x;\n\t\t\t\t}\n\t\t\t}\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t}\n\t\tfor (x=TRUNK_CALL_START;(res < 1) && (x<maxtrunkcall);x++) {\n\t\t\tast_mutex_lock(&iaxsl[x]);\n\t\t\tif (iaxs[x]) {\n\t\t\t\t/* Look for an exact match */\n\t\t\t\tif (match(sin, callno, dcallno, iaxs[x], full_frame)) {\n\t\t\t\t\tres = x;\n\t\t\t\t}\n\t\t\t}\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t}\n\t}\n\tif ((res < 1) && (new >= NEW_ALLOW)) {\n\t\tint start, found = 0;\n\n\t\t/* It may seem odd that we look through the peer list for a name for\n\t\t * this *incoming* call.  Well, it is weird.  However, users don't\n\t\t * have an IP address/port number that we can match against.  So,\n\t\t * this is just checking for a peer that has that IP/port and\n\t\t * assuming that we have a user of the same name.  This isn't always\n\t\t * correct, but it will be changed if needed after authentication. */\n\t\tif (!iax2_getpeername(*sin, host, sizeof(host)))\n\t\t\tsnprintf(host, sizeof(host), \"%s:%d\", ast_inet_ntoa(sin->sin_addr), ntohs(sin->sin_port));\n\n\t\tnow = ast_tvnow();\n\t\tstart = 1 + (ast_random() % (TRUNK_CALL_START - 1));\n\t\tfor (x = start; 1; x++) {\n\t\t\tif (x == TRUNK_CALL_START) {\n\t\t\t\tx = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* Find first unused call number that hasn't been used in a while */\n\t\t\tast_mutex_lock(&iaxsl[x]);\n\t\t\tif (!iaxs[x] && ((now.tv_sec - lastused[x].tv_sec) > MIN_REUSE_TIME)) {\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t\t\n\t\t\tif (x == start - 1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/* We've still got lock held if we found a spot */\n\t\tif (x == start - 1 && !found) {\n\t\t\tast_log(LOG_WARNING, \"No more space\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tiaxs[x] = new_iax(sin, host);\n\t\tupdate_max_nontrunk();\n\t\tif (iaxs[x]) {\n\t\t\tif (iaxdebug)\n\t\t\t\tast_debug(1, \"Creating new call structure %d\\n\", x);\n\t\t\tiaxs[x]->sockfd = sockfd;\n\t\t\tiaxs[x]->addr.sin_port = sin->sin_port;\n\t\t\tiaxs[x]->addr.sin_family = sin->sin_family;\n\t\t\tiaxs[x]->addr.sin_addr.s_addr = sin->sin_addr.s_addr;\n\t\t\tiaxs[x]->peercallno = callno;\n\t\t\tiaxs[x]->callno = x;\n\t\t\tiaxs[x]->pingtime = DEFAULT_RETRY_TIME;\n\t\t\tiaxs[x]->expiry = min_reg_expire;\n\t\t\tiaxs[x]->pingid = iax2_sched_add(sched, ping_time * 1000, send_ping, (void *)(long)x);\n\t\t\tiaxs[x]->lagid = iax2_sched_add(sched, lagrq_time * 1000, send_lagrq, (void *)(long)x);\n\t\t\tiaxs[x]->amaflags = amaflags;\n\t\t\tast_copy_flags(iaxs[x], (&globalflags), IAX_NOTRANSFER | IAX_TRANSFERMEDIA | IAX_USEJITTERBUF | IAX_FORCEJITTERBUF);\n\t\t\t\n\t\t\tast_string_field_set(iaxs[x], accountcode, accountcode);\n\t\t\tast_string_field_set(iaxs[x], mohinterpret, mohinterpret);\n\t\t\tast_string_field_set(iaxs[x], mohsuggest, mohsuggest);\n\t\t\tast_string_field_set(iaxs[x], parkinglot, default_parkinglot);\n\t\t} else {\n\t\t\tast_log(LOG_WARNING, \"Out of resources\\n\");\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t\treturn 0;\n\t\t}\n\t\tif (!return_locked)\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\tres = x;\n\t}\n\treturn res;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,4 @@\n-static int __find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int return_locked)\n+static int __find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int return_locked, int full_frame)\n {\n \tint res = 0;\n \tint x;\n@@ -10,7 +10,7 @@\n \t\t\tast_mutex_lock(&iaxsl[x]);\n \t\t\tif (iaxs[x]) {\n \t\t\t\t/* Look for an exact match */\n-\t\t\t\tif (match(sin, callno, dcallno, iaxs[x])) {\n+\t\t\t\tif (match(sin, callno, dcallno, iaxs[x], full_frame)) {\n \t\t\t\t\tres = x;\n \t\t\t\t}\n \t\t\t}\n@@ -20,7 +20,7 @@\n \t\t\tast_mutex_lock(&iaxsl[x]);\n \t\t\tif (iaxs[x]) {\n \t\t\t\t/* Look for an exact match */\n-\t\t\t\tif (match(sin, callno, dcallno, iaxs[x])) {\n+\t\t\t\tif (match(sin, callno, dcallno, iaxs[x], full_frame)) {\n \t\t\t\t\tres = x;\n \t\t\t\t}\n \t\t\t}\n@@ -28,6 +28,8 @@\n \t\t}\n \t}\n \tif ((res < 1) && (new >= NEW_ALLOW)) {\n+\t\tint start, found = 0;\n+\n \t\t/* It may seem odd that we look through the peer list for a name for\n \t\t * this *incoming* call.  Well, it is weird.  However, users don't\n \t\t * have an IP address/port number that we can match against.  So,\n@@ -36,15 +38,29 @@\n \t\t * correct, but it will be changed if needed after authentication. */\n \t\tif (!iax2_getpeername(*sin, host, sizeof(host)))\n \t\t\tsnprintf(host, sizeof(host), \"%s:%d\", ast_inet_ntoa(sin->sin_addr), ntohs(sin->sin_port));\n+\n \t\tnow = ast_tvnow();\n-\t\tfor (x=1;x<TRUNK_CALL_START;x++) {\n+\t\tstart = 1 + (ast_random() % (TRUNK_CALL_START - 1));\n+\t\tfor (x = start; 1; x++) {\n+\t\t\tif (x == TRUNK_CALL_START) {\n+\t\t\t\tx = 0;\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\n \t\t\t/* Find first unused call number that hasn't been used in a while */\n \t\t\tast_mutex_lock(&iaxsl[x]);\n-\t\t\tif (!iaxs[x] && ((now.tv_sec - lastused[x].tv_sec) > MIN_REUSE_TIME)) break;\n+\t\t\tif (!iaxs[x] && ((now.tv_sec - lastused[x].tv_sec) > MIN_REUSE_TIME)) {\n+\t\t\t\tfound = 1;\n+\t\t\t\tbreak;\n+\t\t\t}\n \t\t\tast_mutex_unlock(&iaxsl[x]);\n+\t\t\t\n+\t\t\tif (x == start - 1) {\n+\t\t\t\tbreak;\n+\t\t\t}\n \t\t}\n \t\t/* We've still got lock held if we found a spot */\n-\t\tif (x >= TRUNK_CALL_START) {\n+\t\tif (x == start - 1 && !found) {\n \t\t\tast_log(LOG_WARNING, \"No more space\\n\");\n \t\t\treturn 0;\n \t\t}",
        "diff_line_info": {
            "deleted_lines": [
                "static int __find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int return_locked)",
                "\t\t\t\tif (match(sin, callno, dcallno, iaxs[x])) {",
                "\t\t\t\tif (match(sin, callno, dcallno, iaxs[x])) {",
                "\t\tfor (x=1;x<TRUNK_CALL_START;x++) {",
                "\t\t\tif (!iaxs[x] && ((now.tv_sec - lastused[x].tv_sec) > MIN_REUSE_TIME)) break;",
                "\t\tif (x >= TRUNK_CALL_START) {"
            ],
            "added_lines": [
                "static int __find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int return_locked, int full_frame)",
                "\t\t\t\tif (match(sin, callno, dcallno, iaxs[x], full_frame)) {",
                "\t\t\t\tif (match(sin, callno, dcallno, iaxs[x], full_frame)) {",
                "\t\tint start, found = 0;",
                "",
                "",
                "\t\tstart = 1 + (ast_random() % (TRUNK_CALL_START - 1));",
                "\t\tfor (x = start; 1; x++) {",
                "\t\t\tif (x == TRUNK_CALL_START) {",
                "\t\t\t\tx = 0;",
                "\t\t\t\tcontinue;",
                "\t\t\t}",
                "",
                "\t\t\tif (!iaxs[x] && ((now.tv_sec - lastused[x].tv_sec) > MIN_REUSE_TIME)) {",
                "\t\t\t\tfound = 1;",
                "\t\t\t\tbreak;",
                "\t\t\t}",
                "\t\t\t",
                "\t\t\tif (x == start - 1) {",
                "\t\t\t\tbreak;",
                "\t\t\t}",
                "\t\tif (x == start - 1 && !found) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2008-1897",
        "func_name": "mojolingo/asterisk/find_callno",
        "description": "The IAX2 channel driver (chan_iax2) in Asterisk Open Source 1.0.x, 1.2.x before 1.2.28, and 1.4.x before 1.4.19.1; Business Edition A.x.x, B.x.x before B.2.5.2, and C.x.x before C.1.8.1; AsteriskNOW before 1.0.3; Appliance Developer Kit 0.x.x; and s800i before 1.1.0.3, when configured to allow unauthenticated calls, does not verify that an ACK response contains a call number matching the server's reply to a NEW message, which allows remote attackers to cause a denial of service (traffic amplification) via a spoofed ACK response that does not complete a 3-way handshake.  NOTE: this issue exists because of an incomplete fix for CVE-2008-1923.",
        "git_url": "https://github.com/mojolingo/asterisk/commit/20ac3662f137dbf7f42d5295590069a7d3b1166b",
        "commit_title": "Merged revisions 114558 via svnmerge from ",
        "commit_text": "https://origsvn.digium.com/svn/asterisk/branches/1.4  ........ r114558 | russell | 2008-04-22 17:15:36 -0500 (Tue, 22 Apr 2008) | 5 lines  When we receive a full frame that is supposed to contain our call number, ensure that it has the correct one. (closes issue #10078) (AST-2008-006)  ........  ",
        "func_before": "static int find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd) {\n\n\treturn __find_callno(callno, dcallno, sin, new, sockfd, 0);\n}",
        "func": "static int find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int full_frame) {\n\n\treturn __find_callno(callno, dcallno, sin, new, sockfd, 0, full_frame);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,4 @@\n-static int find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd) {\n+static int find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int full_frame) {\n \n-\treturn __find_callno(callno, dcallno, sin, new, sockfd, 0);\n+\treturn __find_callno(callno, dcallno, sin, new, sockfd, 0, full_frame);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "static int find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd) {",
                "\treturn __find_callno(callno, dcallno, sin, new, sockfd, 0);"
            ],
            "added_lines": [
                "static int find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int full_frame) {",
                "\treturn __find_callno(callno, dcallno, sin, new, sockfd, 0, full_frame);"
            ]
        }
    },
    {
        "cve_id": "CVE-2008-1897",
        "func_name": "mojolingo/asterisk/iax2_do_register",
        "description": "The IAX2 channel driver (chan_iax2) in Asterisk Open Source 1.0.x, 1.2.x before 1.2.28, and 1.4.x before 1.4.19.1; Business Edition A.x.x, B.x.x before B.2.5.2, and C.x.x before C.1.8.1; AsteriskNOW before 1.0.3; Appliance Developer Kit 0.x.x; and s800i before 1.1.0.3, when configured to allow unauthenticated calls, does not verify that an ACK response contains a call number matching the server's reply to a NEW message, which allows remote attackers to cause a denial of service (traffic amplification) via a spoofed ACK response that does not complete a 3-way handshake.  NOTE: this issue exists because of an incomplete fix for CVE-2008-1923.",
        "git_url": "https://github.com/mojolingo/asterisk/commit/20ac3662f137dbf7f42d5295590069a7d3b1166b",
        "commit_title": "Merged revisions 114558 via svnmerge from ",
        "commit_text": "https://origsvn.digium.com/svn/asterisk/branches/1.4  ........ r114558 | russell | 2008-04-22 17:15:36 -0500 (Tue, 22 Apr 2008) | 5 lines  When we receive a full frame that is supposed to contain our call number, ensure that it has the correct one. (closes issue #10078) (AST-2008-006)  ........  ",
        "func_before": "static int iax2_do_register(struct iax2_registry *reg)\n{\n\tstruct iax_ie_data ied;\n\tif (iaxdebug)\n\t\tast_debug(1, \"Sending registration request for '%s'\\n\", reg->username);\n\n\tif (reg->dnsmgr && \n\t    ((reg->regstate == REG_STATE_TIMEOUT) || !reg->addr.sin_addr.s_addr)) {\n\t\t/* Maybe the IP has changed, force DNS refresh */\n\t\tast_dnsmgr_refresh(reg->dnsmgr);\n\t}\n\t\n\t/*\n\t * if IP has Changed, free allocated call to create a new one with new IP\n\t * call has the pointer to IP and must be updated to the new one\n\t */\n\tif (reg->dnsmgr && ast_dnsmgr_changed(reg->dnsmgr) && (reg->callno > 0)) {\n\t\tast_mutex_lock(&iaxsl[reg->callno]);\n\t\tiax2_destroy(reg->callno);\n\t\tast_mutex_unlock(&iaxsl[reg->callno]);\n\t\treg->callno = 0;\n\t}\n\tif (!reg->addr.sin_addr.s_addr) {\n\t\tif (iaxdebug)\n\t\t\tast_debug(1, \"Unable to send registration request for '%s' without IP address\\n\", reg->username);\n\t\t/* Setup the next registration attempt */\n\t\treg->expire = iax2_sched_replace(reg->expire, sched, \n\t\t\t(5 * reg->refresh / 6) * 1000, iax2_do_register_s, reg);\n\t\treturn -1;\n\t}\n\n\tif (!reg->callno) {\n\t\tast_debug(1, \"Allocate call number\\n\");\n\t\treg->callno = find_callno_locked(0, 0, &reg->addr, NEW_FORCE, defaultsockfd);\n\t\tif (reg->callno < 1) {\n\t\t\tast_log(LOG_WARNING, \"Unable to create call for registration\\n\");\n\t\t\treturn -1;\n\t\t} else\n\t\t\tast_debug(1, \"Registration created on call %d\\n\", reg->callno);\n\t\tiaxs[reg->callno]->reg = reg;\n\t\tast_mutex_unlock(&iaxsl[reg->callno]);\n\t}\n\t/* Setup the next registration a little early */\n\treg->expire = iax2_sched_replace(reg->expire, sched, \n\t\t(5 * reg->refresh / 6) * 1000, iax2_do_register_s, reg);\n\t/* Send the request */\n\tmemset(&ied, 0, sizeof(ied));\n\tiax_ie_append_str(&ied, IAX_IE_USERNAME, reg->username);\n\tiax_ie_append_short(&ied, IAX_IE_REFRESH, reg->refresh);\n\tsend_command(iaxs[reg->callno],AST_FRAME_IAX, IAX_COMMAND_REGREQ, 0, ied.buf, ied.pos, -1);\n\treg->regstate = REG_STATE_REGSENT;\n\treturn 0;\n}",
        "func": "static int iax2_do_register(struct iax2_registry *reg)\n{\n\tstruct iax_ie_data ied;\n\tif (iaxdebug)\n\t\tast_debug(1, \"Sending registration request for '%s'\\n\", reg->username);\n\n\tif (reg->dnsmgr && \n\t    ((reg->regstate == REG_STATE_TIMEOUT) || !reg->addr.sin_addr.s_addr)) {\n\t\t/* Maybe the IP has changed, force DNS refresh */\n\t\tast_dnsmgr_refresh(reg->dnsmgr);\n\t}\n\t\n\t/*\n\t * if IP has Changed, free allocated call to create a new one with new IP\n\t * call has the pointer to IP and must be updated to the new one\n\t */\n\tif (reg->dnsmgr && ast_dnsmgr_changed(reg->dnsmgr) && (reg->callno > 0)) {\n\t\tast_mutex_lock(&iaxsl[reg->callno]);\n\t\tiax2_destroy(reg->callno);\n\t\tast_mutex_unlock(&iaxsl[reg->callno]);\n\t\treg->callno = 0;\n\t}\n\tif (!reg->addr.sin_addr.s_addr) {\n\t\tif (iaxdebug)\n\t\t\tast_debug(1, \"Unable to send registration request for '%s' without IP address\\n\", reg->username);\n\t\t/* Setup the next registration attempt */\n\t\treg->expire = iax2_sched_replace(reg->expire, sched, \n\t\t\t(5 * reg->refresh / 6) * 1000, iax2_do_register_s, reg);\n\t\treturn -1;\n\t}\n\n\tif (!reg->callno) {\n\t\tast_debug(1, \"Allocate call number\\n\");\n\t\treg->callno = find_callno_locked(0, 0, &reg->addr, NEW_FORCE, defaultsockfd, 0);\n\t\tif (reg->callno < 1) {\n\t\t\tast_log(LOG_WARNING, \"Unable to create call for registration\\n\");\n\t\t\treturn -1;\n\t\t} else\n\t\t\tast_debug(1, \"Registration created on call %d\\n\", reg->callno);\n\t\tiaxs[reg->callno]->reg = reg;\n\t\tast_mutex_unlock(&iaxsl[reg->callno]);\n\t}\n\t/* Setup the next registration a little early */\n\treg->expire = iax2_sched_replace(reg->expire, sched, \n\t\t(5 * reg->refresh / 6) * 1000, iax2_do_register_s, reg);\n\t/* Send the request */\n\tmemset(&ied, 0, sizeof(ied));\n\tiax_ie_append_str(&ied, IAX_IE_USERNAME, reg->username);\n\tiax_ie_append_short(&ied, IAX_IE_REFRESH, reg->refresh);\n\tsend_command(iaxs[reg->callno],AST_FRAME_IAX, IAX_COMMAND_REGREQ, 0, ied.buf, ied.pos, -1);\n\treg->regstate = REG_STATE_REGSENT;\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -31,7 +31,7 @@\n \n \tif (!reg->callno) {\n \t\tast_debug(1, \"Allocate call number\\n\");\n-\t\treg->callno = find_callno_locked(0, 0, &reg->addr, NEW_FORCE, defaultsockfd);\n+\t\treg->callno = find_callno_locked(0, 0, &reg->addr, NEW_FORCE, defaultsockfd, 0);\n \t\tif (reg->callno < 1) {\n \t\t\tast_log(LOG_WARNING, \"Unable to create call for registration\\n\");\n \t\t\treturn -1;",
        "diff_line_info": {
            "deleted_lines": [
                "\t\treg->callno = find_callno_locked(0, 0, &reg->addr, NEW_FORCE, defaultsockfd);"
            ],
            "added_lines": [
                "\t\treg->callno = find_callno_locked(0, 0, &reg->addr, NEW_FORCE, defaultsockfd, 0);"
            ]
        }
    },
    {
        "cve_id": "CVE-2008-1897",
        "func_name": "mojolingo/asterisk/iax2_poke_peer",
        "description": "The IAX2 channel driver (chan_iax2) in Asterisk Open Source 1.0.x, 1.2.x before 1.2.28, and 1.4.x before 1.4.19.1; Business Edition A.x.x, B.x.x before B.2.5.2, and C.x.x before C.1.8.1; AsteriskNOW before 1.0.3; Appliance Developer Kit 0.x.x; and s800i before 1.1.0.3, when configured to allow unauthenticated calls, does not verify that an ACK response contains a call number matching the server's reply to a NEW message, which allows remote attackers to cause a denial of service (traffic amplification) via a spoofed ACK response that does not complete a 3-way handshake.  NOTE: this issue exists because of an incomplete fix for CVE-2008-1923.",
        "git_url": "https://github.com/mojolingo/asterisk/commit/20ac3662f137dbf7f42d5295590069a7d3b1166b",
        "commit_title": "Merged revisions 114558 via svnmerge from ",
        "commit_text": "https://origsvn.digium.com/svn/asterisk/branches/1.4  ........ r114558 | russell | 2008-04-22 17:15:36 -0500 (Tue, 22 Apr 2008) | 5 lines  When we receive a full frame that is supposed to contain our call number, ensure that it has the correct one. (closes issue #10078) (AST-2008-006)  ........  ",
        "func_before": "static int iax2_poke_peer(struct iax2_peer *peer, int heldcall)\n{\n\tif (!peer->maxms || (!peer->addr.sin_addr.s_addr && !peer->dnsmgr)) {\n\t\t/* IF we have no IP without dnsmgr, or this isn't to be monitored, return\n\t\t  immediately after clearing things out */\n\t\tpeer->lastms = 0;\n\t\tpeer->historicms = 0;\n\t\tpeer->pokeexpire = -1;\n\t\tpeer->callno = 0;\n\t\treturn 0;\n\t}\n\tif (peer->callno > 0) {\n\t\tast_log(LOG_NOTICE, \"Still have a callno...\\n\");\n\t\tast_mutex_lock(&iaxsl[peer->callno]);\n\t\tiax2_destroy(peer->callno);\n\t\tast_mutex_unlock(&iaxsl[peer->callno]);\n\t}\n\tif (heldcall)\n\t\tast_mutex_unlock(&iaxsl[heldcall]);\n\tpeer->callno = find_callno(0, 0, &peer->addr, NEW_FORCE, peer->sockfd);\n\tif (heldcall)\n\t\tast_mutex_lock(&iaxsl[heldcall]);\n\tif (peer->callno < 1) {\n\t\tast_log(LOG_WARNING, \"Unable to allocate call for poking peer '%s'\\n\", peer->name);\n\t\treturn -1;\n\t}\n\n\t/* Speed up retransmission times for this qualify call */\n\tiaxs[peer->callno]->pingtime = peer->maxms / 4 + 1;\n\tiaxs[peer->callno]->peerpoke = peer;\n\n \tif (peer->pokeexpire > -1) {\n \t\tif (!ast_sched_del(sched, peer->pokeexpire)) {\n \t\t\tpeer->pokeexpire = -1;\n \t\t\tpeer_unref(peer);\n \t\t}\n \t}\n \n\t/* Queue up a new task to handle no reply */\n\t/* If the host is already unreachable then use the unreachable interval instead */\n\tif (peer->lastms < 0)\n \t\tpeer->pokeexpire = iax2_sched_add(sched, peer->pokefreqnotok, iax2_poke_noanswer, peer_ref(peer));\n\telse\n \t\tpeer->pokeexpire = iax2_sched_add(sched, DEFAULT_MAXMS * 2, iax2_poke_noanswer, peer_ref(peer));\n\n \tif (peer->pokeexpire == -1)\n \t\tpeer_unref(peer);\n\n\t/* And send the poke */\n\tsend_command(iaxs[peer->callno], AST_FRAME_IAX, IAX_COMMAND_POKE, 0, NULL, 0, -1);\n\n\treturn 0;\n}",
        "func": "static int iax2_poke_peer(struct iax2_peer *peer, int heldcall)\n{\n\tif (!peer->maxms || (!peer->addr.sin_addr.s_addr && !peer->dnsmgr)) {\n\t\t/* IF we have no IP without dnsmgr, or this isn't to be monitored, return\n\t\t  immediately after clearing things out */\n\t\tpeer->lastms = 0;\n\t\tpeer->historicms = 0;\n\t\tpeer->pokeexpire = -1;\n\t\tpeer->callno = 0;\n\t\treturn 0;\n\t}\n\tif (peer->callno > 0) {\n\t\tast_log(LOG_NOTICE, \"Still have a callno...\\n\");\n\t\tast_mutex_lock(&iaxsl[peer->callno]);\n\t\tiax2_destroy(peer->callno);\n\t\tast_mutex_unlock(&iaxsl[peer->callno]);\n\t}\n\tif (heldcall)\n\t\tast_mutex_unlock(&iaxsl[heldcall]);\n\tpeer->callno = find_callno(0, 0, &peer->addr, NEW_FORCE, peer->sockfd, 0);\n\tif (heldcall)\n\t\tast_mutex_lock(&iaxsl[heldcall]);\n\tif (peer->callno < 1) {\n\t\tast_log(LOG_WARNING, \"Unable to allocate call for poking peer '%s'\\n\", peer->name);\n\t\treturn -1;\n\t}\n\n\t/* Speed up retransmission times for this qualify call */\n\tiaxs[peer->callno]->pingtime = peer->maxms / 4 + 1;\n\tiaxs[peer->callno]->peerpoke = peer;\n\n \tif (peer->pokeexpire > -1) {\n \t\tif (!ast_sched_del(sched, peer->pokeexpire)) {\n \t\t\tpeer->pokeexpire = -1;\n \t\t\tpeer_unref(peer);\n \t\t}\n \t}\n \n\t/* Queue up a new task to handle no reply */\n\t/* If the host is already unreachable then use the unreachable interval instead */\n\tif (peer->lastms < 0)\n \t\tpeer->pokeexpire = iax2_sched_add(sched, peer->pokefreqnotok, iax2_poke_noanswer, peer_ref(peer));\n\telse\n \t\tpeer->pokeexpire = iax2_sched_add(sched, DEFAULT_MAXMS * 2, iax2_poke_noanswer, peer_ref(peer));\n\n \tif (peer->pokeexpire == -1)\n \t\tpeer_unref(peer);\n\n\t/* And send the poke */\n\tsend_command(iaxs[peer->callno], AST_FRAME_IAX, IAX_COMMAND_POKE, 0, NULL, 0, -1);\n\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -17,7 +17,7 @@\n \t}\n \tif (heldcall)\n \t\tast_mutex_unlock(&iaxsl[heldcall]);\n-\tpeer->callno = find_callno(0, 0, &peer->addr, NEW_FORCE, peer->sockfd);\n+\tpeer->callno = find_callno(0, 0, &peer->addr, NEW_FORCE, peer->sockfd, 0);\n \tif (heldcall)\n \t\tast_mutex_lock(&iaxsl[heldcall]);\n \tif (peer->callno < 1) {",
        "diff_line_info": {
            "deleted_lines": [
                "\tpeer->callno = find_callno(0, 0, &peer->addr, NEW_FORCE, peer->sockfd);"
            ],
            "added_lines": [
                "\tpeer->callno = find_callno(0, 0, &peer->addr, NEW_FORCE, peer->sockfd, 0);"
            ]
        }
    },
    {
        "cve_id": "CVE-2008-1897",
        "func_name": "mojolingo/asterisk/cache_get_callno_locked",
        "description": "The IAX2 channel driver (chan_iax2) in Asterisk Open Source 1.0.x, 1.2.x before 1.2.28, and 1.4.x before 1.4.19.1; Business Edition A.x.x, B.x.x before B.2.5.2, and C.x.x before C.1.8.1; AsteriskNOW before 1.0.3; Appliance Developer Kit 0.x.x; and s800i before 1.1.0.3, when configured to allow unauthenticated calls, does not verify that an ACK response contains a call number matching the server's reply to a NEW message, which allows remote attackers to cause a denial of service (traffic amplification) via a spoofed ACK response that does not complete a 3-way handshake.  NOTE: this issue exists because of an incomplete fix for CVE-2008-1923.",
        "git_url": "https://github.com/mojolingo/asterisk/commit/20ac3662f137dbf7f42d5295590069a7d3b1166b",
        "commit_title": "Merged revisions 114558 via svnmerge from ",
        "commit_text": "https://origsvn.digium.com/svn/asterisk/branches/1.4  ........ r114558 | russell | 2008-04-22 17:15:36 -0500 (Tue, 22 Apr 2008) | 5 lines  When we receive a full frame that is supposed to contain our call number, ensure that it has the correct one. (closes issue #10078) (AST-2008-006)  ........  ",
        "func_before": "static int cache_get_callno_locked(const char *data)\n{\n\tstruct sockaddr_in sin;\n\tint x;\n\tint callno;\n\tstruct iax_ie_data ied;\n\tstruct create_addr_info cai;\n\tstruct parsed_dial_string pds;\n\tchar *tmpstr;\n\n\tfor (x=0; x<IAX_MAX_CALLS; x++) {\n\t\t/* Look for an *exact match* call.  Once a call is negotiated, it can only\n\t\t   look up entries for a single context */\n\t\tif (!ast_mutex_trylock(&iaxsl[x])) {\n\t\t\tif (iaxs[x] && !strcasecmp(data, iaxs[x]->dproot))\n\t\t\t\treturn x;\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t}\n\t}\n\n\t/* No match found, we need to create a new one */\n\n\tmemset(&cai, 0, sizeof(cai));\n\tmemset(&ied, 0, sizeof(ied));\n\tmemset(&pds, 0, sizeof(pds));\n\n\ttmpstr = ast_strdupa(data);\n\tparse_dial_string(tmpstr, &pds);\n\n\tif (ast_strlen_zero(pds.peer)) {\n\t\tast_log(LOG_WARNING, \"No peer provided in the IAX2 dial string '%s'\\n\", data);\n\t\treturn -1;\n\t}\n\n\t/* Populate our address from the given */\n\tif (create_addr(pds.peer, NULL, &sin, &cai))\n\t\treturn -1;\n\n\tast_debug(1, \"peer: %s, username: %s, password: %s, context: %s\\n\",\n\t\tpds.peer, pds.username, pds.password, pds.context);\n\n\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd);\n\tif (callno < 1) {\n\t\tast_log(LOG_WARNING, \"Unable to create call\\n\");\n\t\treturn -1;\n\t}\n\n\tast_string_field_set(iaxs[callno], dproot, data);\n\tiaxs[callno]->capability = IAX_CAPABILITY_FULLBANDWIDTH;\n\n\tiax_ie_append_short(&ied, IAX_IE_VERSION, IAX_PROTO_VERSION);\n\tiax_ie_append_str(&ied, IAX_IE_CALLED_NUMBER, \"TBD\");\n\t/* the string format is slightly different from a standard dial string,\n\t   because the context appears in the 'exten' position\n\t*/\n\tif (pds.exten)\n\t\tiax_ie_append_str(&ied, IAX_IE_CALLED_CONTEXT, pds.exten);\n\tif (pds.username)\n\t\tiax_ie_append_str(&ied, IAX_IE_USERNAME, pds.username);\n\tiax_ie_append_int(&ied, IAX_IE_FORMAT, IAX_CAPABILITY_FULLBANDWIDTH);\n\tiax_ie_append_int(&ied, IAX_IE_CAPABILITY, IAX_CAPABILITY_FULLBANDWIDTH);\n\t/* Keep password handy */\n\tif (pds.password)\n\t\tast_string_field_set(iaxs[callno], secret, pds.password);\n\tif (pds.key)\n\t\tast_string_field_set(iaxs[callno], outkey, pds.key);\n\t/* Start the call going */\n\tsend_command(iaxs[callno], AST_FRAME_IAX, IAX_COMMAND_NEW, 0, ied.buf, ied.pos, -1);\n\n\treturn callno;\n}",
        "func": "static int cache_get_callno_locked(const char *data)\n{\n\tstruct sockaddr_in sin;\n\tint x;\n\tint callno;\n\tstruct iax_ie_data ied;\n\tstruct create_addr_info cai;\n\tstruct parsed_dial_string pds;\n\tchar *tmpstr;\n\n\tfor (x=0; x<IAX_MAX_CALLS; x++) {\n\t\t/* Look for an *exact match* call.  Once a call is negotiated, it can only\n\t\t   look up entries for a single context */\n\t\tif (!ast_mutex_trylock(&iaxsl[x])) {\n\t\t\tif (iaxs[x] && !strcasecmp(data, iaxs[x]->dproot))\n\t\t\t\treturn x;\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t}\n\t}\n\n\t/* No match found, we need to create a new one */\n\n\tmemset(&cai, 0, sizeof(cai));\n\tmemset(&ied, 0, sizeof(ied));\n\tmemset(&pds, 0, sizeof(pds));\n\n\ttmpstr = ast_strdupa(data);\n\tparse_dial_string(tmpstr, &pds);\n\n\tif (ast_strlen_zero(pds.peer)) {\n\t\tast_log(LOG_WARNING, \"No peer provided in the IAX2 dial string '%s'\\n\", data);\n\t\treturn -1;\n\t}\n\n\t/* Populate our address from the given */\n\tif (create_addr(pds.peer, NULL, &sin, &cai))\n\t\treturn -1;\n\n\tast_debug(1, \"peer: %s, username: %s, password: %s, context: %s\\n\",\n\t\tpds.peer, pds.username, pds.password, pds.context);\n\n\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd, 0);\n\tif (callno < 1) {\n\t\tast_log(LOG_WARNING, \"Unable to create call\\n\");\n\t\treturn -1;\n\t}\n\n\tast_string_field_set(iaxs[callno], dproot, data);\n\tiaxs[callno]->capability = IAX_CAPABILITY_FULLBANDWIDTH;\n\n\tiax_ie_append_short(&ied, IAX_IE_VERSION, IAX_PROTO_VERSION);\n\tiax_ie_append_str(&ied, IAX_IE_CALLED_NUMBER, \"TBD\");\n\t/* the string format is slightly different from a standard dial string,\n\t   because the context appears in the 'exten' position\n\t*/\n\tif (pds.exten)\n\t\tiax_ie_append_str(&ied, IAX_IE_CALLED_CONTEXT, pds.exten);\n\tif (pds.username)\n\t\tiax_ie_append_str(&ied, IAX_IE_USERNAME, pds.username);\n\tiax_ie_append_int(&ied, IAX_IE_FORMAT, IAX_CAPABILITY_FULLBANDWIDTH);\n\tiax_ie_append_int(&ied, IAX_IE_CAPABILITY, IAX_CAPABILITY_FULLBANDWIDTH);\n\t/* Keep password handy */\n\tif (pds.password)\n\t\tast_string_field_set(iaxs[callno], secret, pds.password);\n\tif (pds.key)\n\t\tast_string_field_set(iaxs[callno], outkey, pds.key);\n\t/* Start the call going */\n\tsend_command(iaxs[callno], AST_FRAME_IAX, IAX_COMMAND_NEW, 0, ied.buf, ied.pos, -1);\n\n\treturn callno;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -39,7 +39,7 @@\n \tast_debug(1, \"peer: %s, username: %s, password: %s, context: %s\\n\",\n \t\tpds.peer, pds.username, pds.password, pds.context);\n \n-\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd);\n+\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd, 0);\n \tif (callno < 1) {\n \t\tast_log(LOG_WARNING, \"Unable to create call\\n\");\n \t\treturn -1;",
        "diff_line_info": {
            "deleted_lines": [
                "\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd);"
            ],
            "added_lines": [
                "\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd, 0);"
            ]
        }
    },
    {
        "cve_id": "CVE-2008-1897",
        "func_name": "mojolingo/asterisk/iax2_provision",
        "description": "The IAX2 channel driver (chan_iax2) in Asterisk Open Source 1.0.x, 1.2.x before 1.2.28, and 1.4.x before 1.4.19.1; Business Edition A.x.x, B.x.x before B.2.5.2, and C.x.x before C.1.8.1; AsteriskNOW before 1.0.3; Appliance Developer Kit 0.x.x; and s800i before 1.1.0.3, when configured to allow unauthenticated calls, does not verify that an ACK response contains a call number matching the server's reply to a NEW message, which allows remote attackers to cause a denial of service (traffic amplification) via a spoofed ACK response that does not complete a 3-way handshake.  NOTE: this issue exists because of an incomplete fix for CVE-2008-1923.",
        "git_url": "https://github.com/mojolingo/asterisk/commit/20ac3662f137dbf7f42d5295590069a7d3b1166b",
        "commit_title": "Merged revisions 114558 via svnmerge from ",
        "commit_text": "https://origsvn.digium.com/svn/asterisk/branches/1.4  ........ r114558 | russell | 2008-04-22 17:15:36 -0500 (Tue, 22 Apr 2008) | 5 lines  When we receive a full frame that is supposed to contain our call number, ensure that it has the correct one. (closes issue #10078) (AST-2008-006)  ........  ",
        "func_before": "static int iax2_provision(struct sockaddr_in *end, int sockfd, char *dest, const char *template, int force)\n{\n\t/* Returns 1 if provisioned, -1 if not able to find destination, or 0 if no provisioning\n\t   is found for template */\n\tstruct iax_ie_data provdata;\n\tstruct iax_ie_data ied;\n\tunsigned int sig;\n\tstruct sockaddr_in sin;\n\tint callno;\n\tstruct create_addr_info cai;\n\n\tmemset(&cai, 0, sizeof(cai));\n\n\tast_debug(1, \"Provisioning '%s' from template '%s'\\n\", dest, template);\n\n\tif (iax_provision_build(&provdata, &sig, template, force)) {\n\t\tast_debug(1, \"No provisioning found for template '%s'\\n\", template);\n\t\treturn 0;\n\t}\n\n\tif (end) {\n\t\tmemcpy(&sin, end, sizeof(sin));\n\t\tcai.sockfd = sockfd;\n\t} else if (create_addr(dest, NULL, &sin, &cai))\n\t\treturn -1;\n\n\t/* Build the rest of the message */\n\tmemset(&ied, 0, sizeof(ied));\n\tiax_ie_append_raw(&ied, IAX_IE_PROVISIONING, provdata.buf, provdata.pos);\n\n\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd);\n\tif (!callno)\n\t\treturn -1;\n\n\tif (iaxs[callno]) {\n\t\t/* Schedule autodestruct in case they don't ever give us anything back */\n\t\tiaxs[callno]->autoid = iax2_sched_replace(iaxs[callno]->autoid, \n\t\t\tsched, 15000, auto_hangup, (void *)(long)callno);\n\t\tast_set_flag(iaxs[callno], IAX_PROVISION);\n\t\t/* Got a call number now, so go ahead and send the provisioning information */\n\t\tsend_command(iaxs[callno], AST_FRAME_IAX, IAX_COMMAND_PROVISION, 0, ied.buf, ied.pos, -1);\n\t}\n\tast_mutex_unlock(&iaxsl[callno]);\n\n\treturn 1;\n}",
        "func": "static int iax2_provision(struct sockaddr_in *end, int sockfd, char *dest, const char *template, int force)\n{\n\t/* Returns 1 if provisioned, -1 if not able to find destination, or 0 if no provisioning\n\t   is found for template */\n\tstruct iax_ie_data provdata;\n\tstruct iax_ie_data ied;\n\tunsigned int sig;\n\tstruct sockaddr_in sin;\n\tint callno;\n\tstruct create_addr_info cai;\n\n\tmemset(&cai, 0, sizeof(cai));\n\n\tast_debug(1, \"Provisioning '%s' from template '%s'\\n\", dest, template);\n\n\tif (iax_provision_build(&provdata, &sig, template, force)) {\n\t\tast_debug(1, \"No provisioning found for template '%s'\\n\", template);\n\t\treturn 0;\n\t}\n\n\tif (end) {\n\t\tmemcpy(&sin, end, sizeof(sin));\n\t\tcai.sockfd = sockfd;\n\t} else if (create_addr(dest, NULL, &sin, &cai))\n\t\treturn -1;\n\n\t/* Build the rest of the message */\n\tmemset(&ied, 0, sizeof(ied));\n\tiax_ie_append_raw(&ied, IAX_IE_PROVISIONING, provdata.buf, provdata.pos);\n\n\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd, 0);\n\tif (!callno)\n\t\treturn -1;\n\n\tif (iaxs[callno]) {\n\t\t/* Schedule autodestruct in case they don't ever give us anything back */\n\t\tiaxs[callno]->autoid = iax2_sched_replace(iaxs[callno]->autoid, \n\t\t\tsched, 15000, auto_hangup, (void *)(long)callno);\n\t\tast_set_flag(iaxs[callno], IAX_PROVISION);\n\t\t/* Got a call number now, so go ahead and send the provisioning information */\n\t\tsend_command(iaxs[callno], AST_FRAME_IAX, IAX_COMMAND_PROVISION, 0, ied.buf, ied.pos, -1);\n\t}\n\tast_mutex_unlock(&iaxsl[callno]);\n\n\treturn 1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -28,7 +28,7 @@\n \tmemset(&ied, 0, sizeof(ied));\n \tiax_ie_append_raw(&ied, IAX_IE_PROVISIONING, provdata.buf, provdata.pos);\n \n-\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd);\n+\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd, 0);\n \tif (!callno)\n \t\treturn -1;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd);"
            ],
            "added_lines": [
                "\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd, 0);"
            ]
        }
    },
    {
        "cve_id": "CVE-2008-1897",
        "func_name": "mojolingo/asterisk/match",
        "description": "The IAX2 channel driver (chan_iax2) in Asterisk Open Source 1.0.x, 1.2.x before 1.2.28, and 1.4.x before 1.4.19.1; Business Edition A.x.x, B.x.x before B.2.5.2, and C.x.x before C.1.8.1; AsteriskNOW before 1.0.3; Appliance Developer Kit 0.x.x; and s800i before 1.1.0.3, when configured to allow unauthenticated calls, does not verify that an ACK response contains a call number matching the server's reply to a NEW message, which allows remote attackers to cause a denial of service (traffic amplification) via a spoofed ACK response that does not complete a 3-way handshake.  NOTE: this issue exists because of an incomplete fix for CVE-2008-1923.",
        "git_url": "https://github.com/mojolingo/asterisk/commit/20ac3662f137dbf7f42d5295590069a7d3b1166b",
        "commit_title": "Merged revisions 114558 via svnmerge from ",
        "commit_text": "https://origsvn.digium.com/svn/asterisk/branches/1.4  ........ r114558 | russell | 2008-04-22 17:15:36 -0500 (Tue, 22 Apr 2008) | 5 lines  When we receive a full frame that is supposed to contain our call number, ensure that it has the correct one. (closes issue #10078) (AST-2008-006)  ........  ",
        "func_before": "static int match(struct sockaddr_in *sin, unsigned short callno, unsigned short dcallno, const struct chan_iax2_pvt *cur)\n{\n\tif ((cur->addr.sin_addr.s_addr == sin->sin_addr.s_addr) &&\n\t\t(cur->addr.sin_port == sin->sin_port)) {\n\t\t/* This is the main host */\n\t\tif ((cur->peercallno == callno) ||\n\t\t\t((dcallno == cur->callno) && !cur->peercallno)) {\n\t\t\t/* That's us.  Be sure we keep track of the peer call number */\n\t\t\treturn 1;\n\t\t}\n\t}\n\tif ((cur->transfer.sin_addr.s_addr == sin->sin_addr.s_addr) &&\n\t    (cur->transfer.sin_port == sin->sin_port) && (cur->transferring)) {\n\t\t/* We're transferring */\n\t\tif ((dcallno == cur->callno) || (cur->transferring == TRANSFER_MEDIAPASS && cur->transfercallno == callno))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
        "func": "static int match(struct sockaddr_in *sin, unsigned short callno, unsigned short dcallno, const struct chan_iax2_pvt *cur, int full_frame)\n{\n\tif ((cur->addr.sin_addr.s_addr == sin->sin_addr.s_addr) &&\n\t\t(cur->addr.sin_port == sin->sin_port)) {\n\t\t/* This is the main host */\n\t\tif ( (cur->peercallno == 0 || cur->peercallno == callno) &&\n\t\t\t (full_frame ? dcallno == cur->callno : 1) ) {\n\t\t\t/* That's us.  Be sure we keep track of the peer call number */\n\t\t\treturn 1;\n\t\t}\n\t}\n\tif ((cur->transfer.sin_addr.s_addr == sin->sin_addr.s_addr) &&\n\t    (cur->transfer.sin_port == sin->sin_port) && (cur->transferring)) {\n\t\t/* We're transferring */\n\t\tif ((dcallno == cur->callno) || (cur->transferring == TRANSFER_MEDIAPASS && cur->transfercallno == callno))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,10 +1,10 @@\n-static int match(struct sockaddr_in *sin, unsigned short callno, unsigned short dcallno, const struct chan_iax2_pvt *cur)\n+static int match(struct sockaddr_in *sin, unsigned short callno, unsigned short dcallno, const struct chan_iax2_pvt *cur, int full_frame)\n {\n \tif ((cur->addr.sin_addr.s_addr == sin->sin_addr.s_addr) &&\n \t\t(cur->addr.sin_port == sin->sin_port)) {\n \t\t/* This is the main host */\n-\t\tif ((cur->peercallno == callno) ||\n-\t\t\t((dcallno == cur->callno) && !cur->peercallno)) {\n+\t\tif ( (cur->peercallno == 0 || cur->peercallno == callno) &&\n+\t\t\t (full_frame ? dcallno == cur->callno : 1) ) {\n \t\t\t/* That's us.  Be sure we keep track of the peer call number */\n \t\t\treturn 1;\n \t\t}",
        "diff_line_info": {
            "deleted_lines": [
                "static int match(struct sockaddr_in *sin, unsigned short callno, unsigned short dcallno, const struct chan_iax2_pvt *cur)",
                "\t\tif ((cur->peercallno == callno) ||",
                "\t\t\t((dcallno == cur->callno) && !cur->peercallno)) {"
            ],
            "added_lines": [
                "static int match(struct sockaddr_in *sin, unsigned short callno, unsigned short dcallno, const struct chan_iax2_pvt *cur, int full_frame)",
                "\t\tif ( (cur->peercallno == 0 || cur->peercallno == callno) &&",
                "\t\t\t (full_frame ? dcallno == cur->callno : 1) ) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2008-1897",
        "func_name": "mojolingo/asterisk/socket_process_meta",
        "description": "The IAX2 channel driver (chan_iax2) in Asterisk Open Source 1.0.x, 1.2.x before 1.2.28, and 1.4.x before 1.4.19.1; Business Edition A.x.x, B.x.x before B.2.5.2, and C.x.x before C.1.8.1; AsteriskNOW before 1.0.3; Appliance Developer Kit 0.x.x; and s800i before 1.1.0.3, when configured to allow unauthenticated calls, does not verify that an ACK response contains a call number matching the server's reply to a NEW message, which allows remote attackers to cause a denial of service (traffic amplification) via a spoofed ACK response that does not complete a 3-way handshake.  NOTE: this issue exists because of an incomplete fix for CVE-2008-1923.",
        "git_url": "https://github.com/mojolingo/asterisk/commit/20ac3662f137dbf7f42d5295590069a7d3b1166b",
        "commit_title": "Merged revisions 114558 via svnmerge from ",
        "commit_text": "https://origsvn.digium.com/svn/asterisk/branches/1.4  ........ r114558 | russell | 2008-04-22 17:15:36 -0500 (Tue, 22 Apr 2008) | 5 lines  When we receive a full frame that is supposed to contain our call number, ensure that it has the correct one. (closes issue #10078) (AST-2008-006)  ........  ",
        "func_before": "static int socket_process_meta(int packet_len, struct ast_iax2_meta_hdr *meta, struct sockaddr_in *sin, int sockfd,\n\tstruct iax_frame *fr)\n{\n\tunsigned char metatype;\n\tstruct ast_iax2_meta_trunk_mini *mtm;\n\tstruct ast_iax2_meta_trunk_hdr *mth;\n\tstruct ast_iax2_meta_trunk_entry *mte;\n\tstruct iax2_trunk_peer *tpeer;\n\tunsigned int ts;\n\tvoid *ptr;\n\tstruct timeval rxtrunktime;\n\tstruct ast_frame f = { 0, };\n\n\tif (packet_len < sizeof(*meta)) {\n\t\tast_log(LOG_WARNING, \"Rejecting packet from '%s.%d' that is flagged as a meta frame but is too short\\n\", \n\t\t\tast_inet_ntoa(sin->sin_addr), ntohs(sin->sin_port));\n\t\treturn 1;\n\t}\n\n\tif (meta->metacmd != IAX_META_TRUNK)\n\t\treturn 1;\n\n\tif (packet_len < (sizeof(*meta) + sizeof(*mth))) {\n\t\tast_log(LOG_WARNING, \"midget meta trunk packet received (%d of %d min)\\n\", packet_len,\n\t\t\t(int) (sizeof(*meta) + sizeof(*mth)));\n\t\treturn 1;\n\t}\n\tmth = (struct ast_iax2_meta_trunk_hdr *)(meta->data);\n\tts = ntohl(mth->ts);\n\tmetatype = meta->cmddata;\n\tpacket_len -= (sizeof(*meta) + sizeof(*mth));\n\tptr = mth->data;\n\ttpeer = find_tpeer(sin, sockfd);\n\tif (!tpeer) {\n\t\tast_log(LOG_WARNING, \"Unable to accept trunked packet from '%s:%d': No matching peer\\n\", \n\t\t\tast_inet_ntoa(sin->sin_addr), ntohs(sin->sin_port));\n\t\treturn 1;\n\t}\n\ttpeer->trunkact = ast_tvnow();\n\tif (!ts || ast_tvzero(tpeer->rxtrunktime))\n\t\ttpeer->rxtrunktime = tpeer->trunkact;\n\trxtrunktime = tpeer->rxtrunktime;\n\tast_mutex_unlock(&tpeer->lock);\n\twhile (packet_len >= sizeof(*mte)) {\n\t\t/* Process channels */\n\t\tunsigned short callno, trunked_ts, len;\n\n\t\tif (metatype == IAX_META_TRUNK_MINI) {\n\t\t\tmtm = (struct ast_iax2_meta_trunk_mini *) ptr;\n\t\t\tptr += sizeof(*mtm);\n\t\t\tpacket_len -= sizeof(*mtm);\n\t\t\tlen = ntohs(mtm->len);\n\t\t\tcallno = ntohs(mtm->mini.callno);\n\t\t\ttrunked_ts = ntohs(mtm->mini.ts);\n\t\t} else if (metatype == IAX_META_TRUNK_SUPERMINI) {\n\t\t\tmte = (struct ast_iax2_meta_trunk_entry *)ptr;\n\t\t\tptr += sizeof(*mte);\n\t\t\tpacket_len -= sizeof(*mte);\n\t\t\tlen = ntohs(mte->len);\n\t\t\tcallno = ntohs(mte->callno);\n\t\t\ttrunked_ts = 0;\n\t\t} else {\n\t\t\tast_log(LOG_WARNING, \"Unknown meta trunk cmd from '%s:%d': dropping\\n\", ast_inet_ntoa(sin->sin_addr), ntohs(sin->sin_port));\n\t\t\tbreak;\n\t\t}\n\t\t/* Stop if we don't have enough data */\n\t\tif (len > packet_len)\n\t\t\tbreak;\n\t\tfr->callno = find_callno_locked(callno & ~IAX_FLAG_FULL, 0, sin, NEW_PREVENT, sockfd);\n\t\tif (!fr->callno)\n\t\t\tcontinue;\n\n\t\t/* If it's a valid call, deliver the contents.  If not, we\n\t\t   drop it, since we don't have a scallno to use for an INVAL */\n\t\t/* Process as a mini frame */\n\t\tmemset(&f, 0, sizeof(f));\n\t\tf.frametype = AST_FRAME_VOICE;\n\t\tif (!iaxs[fr->callno]) {\n\t\t\t/* drop it */\n\t\t} else if (iaxs[fr->callno]->voiceformat == 0) {\n\t\t\tast_log(LOG_WARNING, \"Received trunked frame before first full voice frame\\n \");\n\t\t\tiax2_vnak(fr->callno);\n\t\t} else {\n\t\t\tf.subclass = iaxs[fr->callno]->voiceformat;\n\t\t\tf.datalen = len;\n\t\t\tif (f.datalen >= 0) {\n\t\t\t\tif (f.datalen)\n\t\t\t\t\tf.data = ptr;\n\t\t\t\telse\n\t\t\t\t\tf.data = NULL;\n\t\t\t\tif (trunked_ts)\n\t\t\t\t\tfr->ts = (iaxs[fr->callno]->last & 0xFFFF0000L) | (trunked_ts & 0xffff);\n\t\t\t\telse\n\t\t\t\t\tfr->ts = fix_peerts(&rxtrunktime, fr->callno, ts);\n\t\t\t\t/* Don't pass any packets until we're started */\n\t\t\t\tif (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)) {\n\t\t\t\t\tstruct iax_frame *duped_fr;\n\n\t\t\t\t\t/* Common things */\n\t\t\t\t\tf.src = \"IAX2\";\n\t\t\t\t\tf.mallocd = 0;\n\t\t\t\t\tf.offset = 0;\n\t\t\t\t\tif (f.datalen && (f.frametype == AST_FRAME_VOICE)) \n\t\t\t\t\t\tf.samples = ast_codec_get_samples(&f);\n\t\t\t\t\telse\n\t\t\t\t\t\tf.samples = 0;\n\t\t\t\t\tfr->outoforder = 0;\n\t\t\t\t\tiax_frame_wrap(fr, &f);\n\t\t\t\t\tduped_fr = iaxfrdup2(fr);\n\t\t\t\t\tif (duped_fr)\n\t\t\t\t\t\tschedule_delivery(duped_fr, 1, 1, &fr->ts);\n\t\t\t\t\tif (iaxs[fr->callno] && iaxs[fr->callno]->last < fr->ts)\n\t\t\t\t\t\tiaxs[fr->callno]->last = fr->ts;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tast_log(LOG_WARNING, \"Datalen < 0?\\n\");\n\t\t\t}\n\t\t}\n\t\tast_mutex_unlock(&iaxsl[fr->callno]);\n\t\tptr += len;\n\t\tpacket_len -= len;\n\t}\n\n\treturn 1;\n}",
        "func": "static int socket_process_meta(int packet_len, struct ast_iax2_meta_hdr *meta, struct sockaddr_in *sin, int sockfd,\n\tstruct iax_frame *fr)\n{\n\tunsigned char metatype;\n\tstruct ast_iax2_meta_trunk_mini *mtm;\n\tstruct ast_iax2_meta_trunk_hdr *mth;\n\tstruct ast_iax2_meta_trunk_entry *mte;\n\tstruct iax2_trunk_peer *tpeer;\n\tunsigned int ts;\n\tvoid *ptr;\n\tstruct timeval rxtrunktime;\n\tstruct ast_frame f = { 0, };\n\n\tif (packet_len < sizeof(*meta)) {\n\t\tast_log(LOG_WARNING, \"Rejecting packet from '%s.%d' that is flagged as a meta frame but is too short\\n\", \n\t\t\tast_inet_ntoa(sin->sin_addr), ntohs(sin->sin_port));\n\t\treturn 1;\n\t}\n\n\tif (meta->metacmd != IAX_META_TRUNK)\n\t\treturn 1;\n\n\tif (packet_len < (sizeof(*meta) + sizeof(*mth))) {\n\t\tast_log(LOG_WARNING, \"midget meta trunk packet received (%d of %d min)\\n\", packet_len,\n\t\t\t(int) (sizeof(*meta) + sizeof(*mth)));\n\t\treturn 1;\n\t}\n\tmth = (struct ast_iax2_meta_trunk_hdr *)(meta->data);\n\tts = ntohl(mth->ts);\n\tmetatype = meta->cmddata;\n\tpacket_len -= (sizeof(*meta) + sizeof(*mth));\n\tptr = mth->data;\n\ttpeer = find_tpeer(sin, sockfd);\n\tif (!tpeer) {\n\t\tast_log(LOG_WARNING, \"Unable to accept trunked packet from '%s:%d': No matching peer\\n\", \n\t\t\tast_inet_ntoa(sin->sin_addr), ntohs(sin->sin_port));\n\t\treturn 1;\n\t}\n\ttpeer->trunkact = ast_tvnow();\n\tif (!ts || ast_tvzero(tpeer->rxtrunktime))\n\t\ttpeer->rxtrunktime = tpeer->trunkact;\n\trxtrunktime = tpeer->rxtrunktime;\n\tast_mutex_unlock(&tpeer->lock);\n\twhile (packet_len >= sizeof(*mte)) {\n\t\t/* Process channels */\n\t\tunsigned short callno, trunked_ts, len;\n\n\t\tif (metatype == IAX_META_TRUNK_MINI) {\n\t\t\tmtm = (struct ast_iax2_meta_trunk_mini *) ptr;\n\t\t\tptr += sizeof(*mtm);\n\t\t\tpacket_len -= sizeof(*mtm);\n\t\t\tlen = ntohs(mtm->len);\n\t\t\tcallno = ntohs(mtm->mini.callno);\n\t\t\ttrunked_ts = ntohs(mtm->mini.ts);\n\t\t} else if (metatype == IAX_META_TRUNK_SUPERMINI) {\n\t\t\tmte = (struct ast_iax2_meta_trunk_entry *)ptr;\n\t\t\tptr += sizeof(*mte);\n\t\t\tpacket_len -= sizeof(*mte);\n\t\t\tlen = ntohs(mte->len);\n\t\t\tcallno = ntohs(mte->callno);\n\t\t\ttrunked_ts = 0;\n\t\t} else {\n\t\t\tast_log(LOG_WARNING, \"Unknown meta trunk cmd from '%s:%d': dropping\\n\", ast_inet_ntoa(sin->sin_addr), ntohs(sin->sin_port));\n\t\t\tbreak;\n\t\t}\n\t\t/* Stop if we don't have enough data */\n\t\tif (len > packet_len)\n\t\t\tbreak;\n\t\tfr->callno = find_callno_locked(callno & ~IAX_FLAG_FULL, 0, sin, NEW_PREVENT, sockfd, 0);\n\t\tif (!fr->callno)\n\t\t\tcontinue;\n\n\t\t/* If it's a valid call, deliver the contents.  If not, we\n\t\t   drop it, since we don't have a scallno to use for an INVAL */\n\t\t/* Process as a mini frame */\n\t\tmemset(&f, 0, sizeof(f));\n\t\tf.frametype = AST_FRAME_VOICE;\n\t\tif (!iaxs[fr->callno]) {\n\t\t\t/* drop it */\n\t\t} else if (iaxs[fr->callno]->voiceformat == 0) {\n\t\t\tast_log(LOG_WARNING, \"Received trunked frame before first full voice frame\\n \");\n\t\t\tiax2_vnak(fr->callno);\n\t\t} else {\n\t\t\tf.subclass = iaxs[fr->callno]->voiceformat;\n\t\t\tf.datalen = len;\n\t\t\tif (f.datalen >= 0) {\n\t\t\t\tif (f.datalen)\n\t\t\t\t\tf.data = ptr;\n\t\t\t\telse\n\t\t\t\t\tf.data = NULL;\n\t\t\t\tif (trunked_ts)\n\t\t\t\t\tfr->ts = (iaxs[fr->callno]->last & 0xFFFF0000L) | (trunked_ts & 0xffff);\n\t\t\t\telse\n\t\t\t\t\tfr->ts = fix_peerts(&rxtrunktime, fr->callno, ts);\n\t\t\t\t/* Don't pass any packets until we're started */\n\t\t\t\tif (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)) {\n\t\t\t\t\tstruct iax_frame *duped_fr;\n\n\t\t\t\t\t/* Common things */\n\t\t\t\t\tf.src = \"IAX2\";\n\t\t\t\t\tf.mallocd = 0;\n\t\t\t\t\tf.offset = 0;\n\t\t\t\t\tif (f.datalen && (f.frametype == AST_FRAME_VOICE)) \n\t\t\t\t\t\tf.samples = ast_codec_get_samples(&f);\n\t\t\t\t\telse\n\t\t\t\t\t\tf.samples = 0;\n\t\t\t\t\tfr->outoforder = 0;\n\t\t\t\t\tiax_frame_wrap(fr, &f);\n\t\t\t\t\tduped_fr = iaxfrdup2(fr);\n\t\t\t\t\tif (duped_fr)\n\t\t\t\t\t\tschedule_delivery(duped_fr, 1, 1, &fr->ts);\n\t\t\t\t\tif (iaxs[fr->callno] && iaxs[fr->callno]->last < fr->ts)\n\t\t\t\t\t\tiaxs[fr->callno]->last = fr->ts;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tast_log(LOG_WARNING, \"Datalen < 0?\\n\");\n\t\t\t}\n\t\t}\n\t\tast_mutex_unlock(&iaxsl[fr->callno]);\n\t\tptr += len;\n\t\tpacket_len -= len;\n\t}\n\n\treturn 1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -66,7 +66,7 @@\n \t\t/* Stop if we don't have enough data */\n \t\tif (len > packet_len)\n \t\t\tbreak;\n-\t\tfr->callno = find_callno_locked(callno & ~IAX_FLAG_FULL, 0, sin, NEW_PREVENT, sockfd);\n+\t\tfr->callno = find_callno_locked(callno & ~IAX_FLAG_FULL, 0, sin, NEW_PREVENT, sockfd, 0);\n \t\tif (!fr->callno)\n \t\t\tcontinue;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tfr->callno = find_callno_locked(callno & ~IAX_FLAG_FULL, 0, sin, NEW_PREVENT, sockfd);"
            ],
            "added_lines": [
                "\t\tfr->callno = find_callno_locked(callno & ~IAX_FLAG_FULL, 0, sin, NEW_PREVENT, sockfd, 0);"
            ]
        }
    },
    {
        "cve_id": "CVE-2008-1897",
        "func_name": "mojolingo/asterisk/find_callno_locked",
        "description": "The IAX2 channel driver (chan_iax2) in Asterisk Open Source 1.0.x, 1.2.x before 1.2.28, and 1.4.x before 1.4.19.1; Business Edition A.x.x, B.x.x before B.2.5.2, and C.x.x before C.1.8.1; AsteriskNOW before 1.0.3; Appliance Developer Kit 0.x.x; and s800i before 1.1.0.3, when configured to allow unauthenticated calls, does not verify that an ACK response contains a call number matching the server's reply to a NEW message, which allows remote attackers to cause a denial of service (traffic amplification) via a spoofed ACK response that does not complete a 3-way handshake.  NOTE: this issue exists because of an incomplete fix for CVE-2008-1923.",
        "git_url": "https://github.com/mojolingo/asterisk/commit/20ac3662f137dbf7f42d5295590069a7d3b1166b",
        "commit_title": "Merged revisions 114558 via svnmerge from ",
        "commit_text": "https://origsvn.digium.com/svn/asterisk/branches/1.4  ........ r114558 | russell | 2008-04-22 17:15:36 -0500 (Tue, 22 Apr 2008) | 5 lines  When we receive a full frame that is supposed to contain our call number, ensure that it has the correct one. (closes issue #10078) (AST-2008-006)  ........  ",
        "func_before": "static int find_callno_locked(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd) {\n\n\treturn __find_callno(callno, dcallno, sin, new, sockfd, 1);\n}",
        "func": "static int find_callno_locked(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int full_frame) {\n\n\treturn __find_callno(callno, dcallno, sin, new, sockfd, 1, full_frame);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,4 @@\n-static int find_callno_locked(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd) {\n+static int find_callno_locked(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int full_frame) {\n \n-\treturn __find_callno(callno, dcallno, sin, new, sockfd, 1);\n+\treturn __find_callno(callno, dcallno, sin, new, sockfd, 1, full_frame);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "static int find_callno_locked(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd) {",
                "\treturn __find_callno(callno, dcallno, sin, new, sockfd, 1);"
            ],
            "added_lines": [
                "static int find_callno_locked(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int full_frame) {",
                "\treturn __find_callno(callno, dcallno, sin, new, sockfd, 1, full_frame);"
            ]
        }
    },
    {
        "cve_id": "CVE-2008-1897",
        "func_name": "mojolingo/asterisk/iax2_request",
        "description": "The IAX2 channel driver (chan_iax2) in Asterisk Open Source 1.0.x, 1.2.x before 1.2.28, and 1.4.x before 1.4.19.1; Business Edition A.x.x, B.x.x before B.2.5.2, and C.x.x before C.1.8.1; AsteriskNOW before 1.0.3; Appliance Developer Kit 0.x.x; and s800i before 1.1.0.3, when configured to allow unauthenticated calls, does not verify that an ACK response contains a call number matching the server's reply to a NEW message, which allows remote attackers to cause a denial of service (traffic amplification) via a spoofed ACK response that does not complete a 3-way handshake.  NOTE: this issue exists because of an incomplete fix for CVE-2008-1923.",
        "git_url": "https://github.com/mojolingo/asterisk/commit/20ac3662f137dbf7f42d5295590069a7d3b1166b",
        "commit_title": "Merged revisions 114558 via svnmerge from ",
        "commit_text": "https://origsvn.digium.com/svn/asterisk/branches/1.4  ........ r114558 | russell | 2008-04-22 17:15:36 -0500 (Tue, 22 Apr 2008) | 5 lines  When we receive a full frame that is supposed to contain our call number, ensure that it has the correct one. (closes issue #10078) (AST-2008-006)  ........  ",
        "func_before": "static struct ast_channel *iax2_request(const char *type, int format, void *data, int *cause)\n{\n\tint callno;\n\tint res;\n\tint fmt, native;\n\tstruct sockaddr_in sin;\n\tstruct ast_channel *c;\n\tstruct parsed_dial_string pds;\n\tstruct create_addr_info cai;\n\tchar *tmpstr;\n\n\tmemset(&pds, 0, sizeof(pds));\n\ttmpstr = ast_strdupa(data);\n\tparse_dial_string(tmpstr, &pds);\n\n\tif (ast_strlen_zero(pds.peer)) {\n\t\tast_log(LOG_WARNING, \"No peer provided in the IAX2 dial string '%s'\\n\", (char *) data);\n\t\treturn NULL;\n\t}\n\t       \n\tmemset(&cai, 0, sizeof(cai));\n\tcai.capability = iax2_capability;\n\n\tast_copy_flags(&cai, &globalflags, IAX_NOTRANSFER | IAX_TRANSFERMEDIA | IAX_USEJITTERBUF | IAX_FORCEJITTERBUF);\n\t\n\t/* Populate our address from the given */\n\tif (create_addr(pds.peer, NULL, &sin, &cai)) {\n\t\t*cause = AST_CAUSE_UNREGISTERED;\n\t\treturn NULL;\n\t}\n\n\tif (pds.port)\n\t\tsin.sin_port = htons(atoi(pds.port));\n\n\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd);\n\tif (callno < 1) {\n\t\tast_log(LOG_WARNING, \"Unable to create call\\n\");\n\t\t*cause = AST_CAUSE_CONGESTION;\n\t\treturn NULL;\n\t}\n\n\t/* If this is a trunk, update it now */\n\tast_copy_flags(iaxs[callno], &cai, IAX_TRUNK | IAX_SENDANI | IAX_NOTRANSFER | IAX_TRANSFERMEDIA | IAX_USEJITTERBUF | IAX_FORCEJITTERBUF);\t\n\tif (ast_test_flag(&cai, IAX_TRUNK)) {\n\t\tint new_callno;\n\t\tif ((new_callno = make_trunk(callno, 1)) != -1)\n\t\t\tcallno = new_callno;\n\t}\n\tiaxs[callno]->maxtime = cai.maxtime;\n\tif (cai.found)\n\t\tast_string_field_set(iaxs[callno], host, pds.peer);\n\n\tc = ast_iax2_new(callno, AST_STATE_DOWN, cai.capability);\n\n\tast_mutex_unlock(&iaxsl[callno]);\n\n\tif (c) {\n\t\t/* Choose a format we can live with */\n\t\tif (c->nativeformats & format) \n\t\t\tc->nativeformats &= format;\n\t\telse {\n\t\t\tnative = c->nativeformats;\n\t\t\tfmt = format;\n\t\t\tres = ast_translator_best_choice(&fmt, &native);\n\t\t\tif (res < 0) {\n\t\t\t\tast_log(LOG_WARNING, \"Unable to create translator path for %s to %s on %s\\n\",\n\t\t\t\t\tast_getformatname(c->nativeformats), ast_getformatname(fmt), c->name);\n\t\t\t\tast_hangup(c);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tc->nativeformats = native;\n\t\t}\n\t\tc->readformat = ast_best_codec(c->nativeformats);\n\t\tc->writeformat = c->readformat;\n\t}\n\n\treturn c;\n}",
        "func": "static struct ast_channel *iax2_request(const char *type, int format, void *data, int *cause)\n{\n\tint callno;\n\tint res;\n\tint fmt, native;\n\tstruct sockaddr_in sin;\n\tstruct ast_channel *c;\n\tstruct parsed_dial_string pds;\n\tstruct create_addr_info cai;\n\tchar *tmpstr;\n\n\tmemset(&pds, 0, sizeof(pds));\n\ttmpstr = ast_strdupa(data);\n\tparse_dial_string(tmpstr, &pds);\n\n\tif (ast_strlen_zero(pds.peer)) {\n\t\tast_log(LOG_WARNING, \"No peer provided in the IAX2 dial string '%s'\\n\", (char *) data);\n\t\treturn NULL;\n\t}\n\t       \n\tmemset(&cai, 0, sizeof(cai));\n\tcai.capability = iax2_capability;\n\n\tast_copy_flags(&cai, &globalflags, IAX_NOTRANSFER | IAX_TRANSFERMEDIA | IAX_USEJITTERBUF | IAX_FORCEJITTERBUF);\n\t\n\t/* Populate our address from the given */\n\tif (create_addr(pds.peer, NULL, &sin, &cai)) {\n\t\t*cause = AST_CAUSE_UNREGISTERED;\n\t\treturn NULL;\n\t}\n\n\tif (pds.port)\n\t\tsin.sin_port = htons(atoi(pds.port));\n\n\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd, 0);\n\tif (callno < 1) {\n\t\tast_log(LOG_WARNING, \"Unable to create call\\n\");\n\t\t*cause = AST_CAUSE_CONGESTION;\n\t\treturn NULL;\n\t}\n\n\t/* If this is a trunk, update it now */\n\tast_copy_flags(iaxs[callno], &cai, IAX_TRUNK | IAX_SENDANI | IAX_NOTRANSFER | IAX_TRANSFERMEDIA | IAX_USEJITTERBUF | IAX_FORCEJITTERBUF);\t\n\tif (ast_test_flag(&cai, IAX_TRUNK)) {\n\t\tint new_callno;\n\t\tif ((new_callno = make_trunk(callno, 1)) != -1)\n\t\t\tcallno = new_callno;\n\t}\n\tiaxs[callno]->maxtime = cai.maxtime;\n\tif (cai.found)\n\t\tast_string_field_set(iaxs[callno], host, pds.peer);\n\n\tc = ast_iax2_new(callno, AST_STATE_DOWN, cai.capability);\n\n\tast_mutex_unlock(&iaxsl[callno]);\n\n\tif (c) {\n\t\t/* Choose a format we can live with */\n\t\tif (c->nativeformats & format) \n\t\t\tc->nativeformats &= format;\n\t\telse {\n\t\t\tnative = c->nativeformats;\n\t\t\tfmt = format;\n\t\t\tres = ast_translator_best_choice(&fmt, &native);\n\t\t\tif (res < 0) {\n\t\t\t\tast_log(LOG_WARNING, \"Unable to create translator path for %s to %s on %s\\n\",\n\t\t\t\t\tast_getformatname(c->nativeformats), ast_getformatname(fmt), c->name);\n\t\t\t\tast_hangup(c);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tc->nativeformats = native;\n\t\t}\n\t\tc->readformat = ast_best_codec(c->nativeformats);\n\t\tc->writeformat = c->readformat;\n\t}\n\n\treturn c;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -32,7 +32,7 @@\n \tif (pds.port)\n \t\tsin.sin_port = htons(atoi(pds.port));\n \n-\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd);\n+\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd, 0);\n \tif (callno < 1) {\n \t\tast_log(LOG_WARNING, \"Unable to create call\\n\");\n \t\t*cause = AST_CAUSE_CONGESTION;",
        "diff_line_info": {
            "deleted_lines": [
                "\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd);"
            ],
            "added_lines": [
                "\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd, 0);"
            ]
        }
    },
    {
        "cve_id": "CVE-2008-1897",
        "func_name": "mojolingo/asterisk/__find_callno",
        "description": "The IAX2 channel driver (chan_iax2) in Asterisk Open Source 1.0.x, 1.2.x before 1.2.28, and 1.4.x before 1.4.19.1; Business Edition A.x.x, B.x.x before B.2.5.2, and C.x.x before C.1.8.1; AsteriskNOW before 1.0.3; Appliance Developer Kit 0.x.x; and s800i before 1.1.0.3, when configured to allow unauthenticated calls, does not verify that an ACK response contains a call number matching the server's reply to a NEW message, which allows remote attackers to cause a denial of service (traffic amplification) via a spoofed ACK response that does not complete a 3-way handshake.  NOTE: this issue exists because of an incomplete fix for CVE-2008-1923.",
        "git_url": "https://github.com/mojolingo/asterisk/commit/20ac3662f137dbf7f42d5295590069a7d3b1166b",
        "commit_title": "Merged revisions 114558 via svnmerge from ",
        "commit_text": "https://origsvn.digium.com/svn/asterisk/branches/1.4  ........ r114558 | russell | 2008-04-22 17:15:36 -0500 (Tue, 22 Apr 2008) | 5 lines  When we receive a full frame that is supposed to contain our call number, ensure that it has the correct one. (closes issue #10078) (AST-2008-006)  ........  ",
        "func_before": "static int __find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int return_locked)\n{\n\tint res = 0;\n\tint x;\n\tstruct timeval now;\n\tchar host[80];\n\n\tif (new <= NEW_ALLOW) {\n\t\tfor (x=1;(res < 1) && (x<maxnontrunkcall);x++) {\n\t\t\tast_mutex_lock(&iaxsl[x]);\n\t\t\tif (iaxs[x]) {\n\t\t\t\t/* Look for an exact match */\n\t\t\t\tif (match(sin, callno, dcallno, iaxs[x])) {\n\t\t\t\t\tres = x;\n\t\t\t\t}\n\t\t\t}\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t}\n\t\tfor (x=TRUNK_CALL_START;(res < 1) && (x<maxtrunkcall);x++) {\n\t\t\tast_mutex_lock(&iaxsl[x]);\n\t\t\tif (iaxs[x]) {\n\t\t\t\t/* Look for an exact match */\n\t\t\t\tif (match(sin, callno, dcallno, iaxs[x])) {\n\t\t\t\t\tres = x;\n\t\t\t\t}\n\t\t\t}\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t}\n\t}\n\tif ((res < 1) && (new >= NEW_ALLOW)) {\n\t\t/* It may seem odd that we look through the peer list for a name for\n\t\t * this *incoming* call.  Well, it is weird.  However, users don't\n\t\t * have an IP address/port number that we can match against.  So,\n\t\t * this is just checking for a peer that has that IP/port and\n\t\t * assuming that we have a user of the same name.  This isn't always\n\t\t * correct, but it will be changed if needed after authentication. */\n\t\tif (!iax2_getpeername(*sin, host, sizeof(host)))\n\t\t\tsnprintf(host, sizeof(host), \"%s:%d\", ast_inet_ntoa(sin->sin_addr), ntohs(sin->sin_port));\n\t\tnow = ast_tvnow();\n\t\tfor (x=1;x<TRUNK_CALL_START;x++) {\n\t\t\t/* Find first unused call number that hasn't been used in a while */\n\t\t\tast_mutex_lock(&iaxsl[x]);\n\t\t\tif (!iaxs[x] && ((now.tv_sec - lastused[x].tv_sec) > MIN_REUSE_TIME)) break;\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t}\n\t\t/* We've still got lock held if we found a spot */\n\t\tif (x >= TRUNK_CALL_START) {\n\t\t\tast_log(LOG_WARNING, \"No more space\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tiaxs[x] = new_iax(sin, host);\n\t\tupdate_max_nontrunk();\n\t\tif (iaxs[x]) {\n\t\t\tif (iaxdebug)\n\t\t\t\tast_debug(1, \"Creating new call structure %d\\n\", x);\n\t\t\tiaxs[x]->sockfd = sockfd;\n\t\t\tiaxs[x]->addr.sin_port = sin->sin_port;\n\t\t\tiaxs[x]->addr.sin_family = sin->sin_family;\n\t\t\tiaxs[x]->addr.sin_addr.s_addr = sin->sin_addr.s_addr;\n\t\t\tiaxs[x]->peercallno = callno;\n\t\t\tiaxs[x]->callno = x;\n\t\t\tiaxs[x]->pingtime = DEFAULT_RETRY_TIME;\n\t\t\tiaxs[x]->expiry = min_reg_expire;\n\t\t\tiaxs[x]->pingid = iax2_sched_add(sched, ping_time * 1000, send_ping, (void *)(long)x);\n\t\t\tiaxs[x]->lagid = iax2_sched_add(sched, lagrq_time * 1000, send_lagrq, (void *)(long)x);\n\t\t\tiaxs[x]->amaflags = amaflags;\n\t\t\tast_copy_flags(iaxs[x], (&globalflags), IAX_NOTRANSFER | IAX_TRANSFERMEDIA | IAX_USEJITTERBUF | IAX_FORCEJITTERBUF);\n\t\t\t\n\t\t\tast_string_field_set(iaxs[x], accountcode, accountcode);\n\t\t\tast_string_field_set(iaxs[x], mohinterpret, mohinterpret);\n\t\t\tast_string_field_set(iaxs[x], mohsuggest, mohsuggest);\n\t\t\tast_string_field_set(iaxs[x], parkinglot, default_parkinglot);\n\t\t} else {\n\t\t\tast_log(LOG_WARNING, \"Out of resources\\n\");\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t\treturn 0;\n\t\t}\n\t\tif (!return_locked)\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\tres = x;\n\t}\n\treturn res;\n}",
        "func": "static int __find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int return_locked, int full_frame)\n{\n\tint res = 0;\n\tint x;\n\tstruct timeval now;\n\tchar host[80];\n\n\tif (new <= NEW_ALLOW) {\n\t\tfor (x=1;(res < 1) && (x<maxnontrunkcall);x++) {\n\t\t\tast_mutex_lock(&iaxsl[x]);\n\t\t\tif (iaxs[x]) {\n\t\t\t\t/* Look for an exact match */\n\t\t\t\tif (match(sin, callno, dcallno, iaxs[x], full_frame)) {\n\t\t\t\t\tres = x;\n\t\t\t\t}\n\t\t\t}\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t}\n\t\tfor (x=TRUNK_CALL_START;(res < 1) && (x<maxtrunkcall);x++) {\n\t\t\tast_mutex_lock(&iaxsl[x]);\n\t\t\tif (iaxs[x]) {\n\t\t\t\t/* Look for an exact match */\n\t\t\t\tif (match(sin, callno, dcallno, iaxs[x], full_frame)) {\n\t\t\t\t\tres = x;\n\t\t\t\t}\n\t\t\t}\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t}\n\t}\n\tif ((res < 1) && (new >= NEW_ALLOW)) {\n\t\tint start, found = 0;\n\n\t\t/* It may seem odd that we look through the peer list for a name for\n\t\t * this *incoming* call.  Well, it is weird.  However, users don't\n\t\t * have an IP address/port number that we can match against.  So,\n\t\t * this is just checking for a peer that has that IP/port and\n\t\t * assuming that we have a user of the same name.  This isn't always\n\t\t * correct, but it will be changed if needed after authentication. */\n\t\tif (!iax2_getpeername(*sin, host, sizeof(host)))\n\t\t\tsnprintf(host, sizeof(host), \"%s:%d\", ast_inet_ntoa(sin->sin_addr), ntohs(sin->sin_port));\n\n\t\tnow = ast_tvnow();\n\t\tstart = 1 + (ast_random() % (TRUNK_CALL_START - 1));\n\t\tfor (x = start; 1; x++) {\n\t\t\tif (x == TRUNK_CALL_START) {\n\t\t\t\tx = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* Find first unused call number that hasn't been used in a while */\n\t\t\tast_mutex_lock(&iaxsl[x]);\n\t\t\tif (!iaxs[x] && ((now.tv_sec - lastused[x].tv_sec) > MIN_REUSE_TIME)) {\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t\t\n\t\t\tif (x == start - 1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/* We've still got lock held if we found a spot */\n\t\tif (x == start - 1 && !found) {\n\t\t\tast_log(LOG_WARNING, \"No more space\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tiaxs[x] = new_iax(sin, host);\n\t\tupdate_max_nontrunk();\n\t\tif (iaxs[x]) {\n\t\t\tif (iaxdebug)\n\t\t\t\tast_debug(1, \"Creating new call structure %d\\n\", x);\n\t\t\tiaxs[x]->sockfd = sockfd;\n\t\t\tiaxs[x]->addr.sin_port = sin->sin_port;\n\t\t\tiaxs[x]->addr.sin_family = sin->sin_family;\n\t\t\tiaxs[x]->addr.sin_addr.s_addr = sin->sin_addr.s_addr;\n\t\t\tiaxs[x]->peercallno = callno;\n\t\t\tiaxs[x]->callno = x;\n\t\t\tiaxs[x]->pingtime = DEFAULT_RETRY_TIME;\n\t\t\tiaxs[x]->expiry = min_reg_expire;\n\t\t\tiaxs[x]->pingid = iax2_sched_add(sched, ping_time * 1000, send_ping, (void *)(long)x);\n\t\t\tiaxs[x]->lagid = iax2_sched_add(sched, lagrq_time * 1000, send_lagrq, (void *)(long)x);\n\t\t\tiaxs[x]->amaflags = amaflags;\n\t\t\tast_copy_flags(iaxs[x], (&globalflags), IAX_NOTRANSFER | IAX_TRANSFERMEDIA | IAX_USEJITTERBUF | IAX_FORCEJITTERBUF);\n\t\t\t\n\t\t\tast_string_field_set(iaxs[x], accountcode, accountcode);\n\t\t\tast_string_field_set(iaxs[x], mohinterpret, mohinterpret);\n\t\t\tast_string_field_set(iaxs[x], mohsuggest, mohsuggest);\n\t\t\tast_string_field_set(iaxs[x], parkinglot, default_parkinglot);\n\t\t} else {\n\t\t\tast_log(LOG_WARNING, \"Out of resources\\n\");\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t\treturn 0;\n\t\t}\n\t\tif (!return_locked)\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\tres = x;\n\t}\n\treturn res;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,4 @@\n-static int __find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int return_locked)\n+static int __find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int return_locked, int full_frame)\n {\n \tint res = 0;\n \tint x;\n@@ -10,7 +10,7 @@\n \t\t\tast_mutex_lock(&iaxsl[x]);\n \t\t\tif (iaxs[x]) {\n \t\t\t\t/* Look for an exact match */\n-\t\t\t\tif (match(sin, callno, dcallno, iaxs[x])) {\n+\t\t\t\tif (match(sin, callno, dcallno, iaxs[x], full_frame)) {\n \t\t\t\t\tres = x;\n \t\t\t\t}\n \t\t\t}\n@@ -20,7 +20,7 @@\n \t\t\tast_mutex_lock(&iaxsl[x]);\n \t\t\tif (iaxs[x]) {\n \t\t\t\t/* Look for an exact match */\n-\t\t\t\tif (match(sin, callno, dcallno, iaxs[x])) {\n+\t\t\t\tif (match(sin, callno, dcallno, iaxs[x], full_frame)) {\n \t\t\t\t\tres = x;\n \t\t\t\t}\n \t\t\t}\n@@ -28,6 +28,8 @@\n \t\t}\n \t}\n \tif ((res < 1) && (new >= NEW_ALLOW)) {\n+\t\tint start, found = 0;\n+\n \t\t/* It may seem odd that we look through the peer list for a name for\n \t\t * this *incoming* call.  Well, it is weird.  However, users don't\n \t\t * have an IP address/port number that we can match against.  So,\n@@ -36,15 +38,29 @@\n \t\t * correct, but it will be changed if needed after authentication. */\n \t\tif (!iax2_getpeername(*sin, host, sizeof(host)))\n \t\t\tsnprintf(host, sizeof(host), \"%s:%d\", ast_inet_ntoa(sin->sin_addr), ntohs(sin->sin_port));\n+\n \t\tnow = ast_tvnow();\n-\t\tfor (x=1;x<TRUNK_CALL_START;x++) {\n+\t\tstart = 1 + (ast_random() % (TRUNK_CALL_START - 1));\n+\t\tfor (x = start; 1; x++) {\n+\t\t\tif (x == TRUNK_CALL_START) {\n+\t\t\t\tx = 0;\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\n \t\t\t/* Find first unused call number that hasn't been used in a while */\n \t\t\tast_mutex_lock(&iaxsl[x]);\n-\t\t\tif (!iaxs[x] && ((now.tv_sec - lastused[x].tv_sec) > MIN_REUSE_TIME)) break;\n+\t\t\tif (!iaxs[x] && ((now.tv_sec - lastused[x].tv_sec) > MIN_REUSE_TIME)) {\n+\t\t\t\tfound = 1;\n+\t\t\t\tbreak;\n+\t\t\t}\n \t\t\tast_mutex_unlock(&iaxsl[x]);\n+\t\t\t\n+\t\t\tif (x == start - 1) {\n+\t\t\t\tbreak;\n+\t\t\t}\n \t\t}\n \t\t/* We've still got lock held if we found a spot */\n-\t\tif (x >= TRUNK_CALL_START) {\n+\t\tif (x == start - 1 && !found) {\n \t\t\tast_log(LOG_WARNING, \"No more space\\n\");\n \t\t\treturn 0;\n \t\t}",
        "diff_line_info": {
            "deleted_lines": [
                "static int __find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int return_locked)",
                "\t\t\t\tif (match(sin, callno, dcallno, iaxs[x])) {",
                "\t\t\t\tif (match(sin, callno, dcallno, iaxs[x])) {",
                "\t\tfor (x=1;x<TRUNK_CALL_START;x++) {",
                "\t\t\tif (!iaxs[x] && ((now.tv_sec - lastused[x].tv_sec) > MIN_REUSE_TIME)) break;",
                "\t\tif (x >= TRUNK_CALL_START) {"
            ],
            "added_lines": [
                "static int __find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int return_locked, int full_frame)",
                "\t\t\t\tif (match(sin, callno, dcallno, iaxs[x], full_frame)) {",
                "\t\t\t\tif (match(sin, callno, dcallno, iaxs[x], full_frame)) {",
                "\t\tint start, found = 0;",
                "",
                "",
                "\t\tstart = 1 + (ast_random() % (TRUNK_CALL_START - 1));",
                "\t\tfor (x = start; 1; x++) {",
                "\t\t\tif (x == TRUNK_CALL_START) {",
                "\t\t\t\tx = 0;",
                "\t\t\t\tcontinue;",
                "\t\t\t}",
                "",
                "\t\t\tif (!iaxs[x] && ((now.tv_sec - lastused[x].tv_sec) > MIN_REUSE_TIME)) {",
                "\t\t\t\tfound = 1;",
                "\t\t\t\tbreak;",
                "\t\t\t}",
                "\t\t\t",
                "\t\t\tif (x == start - 1) {",
                "\t\t\t\tbreak;",
                "\t\t\t}",
                "\t\tif (x == start - 1 && !found) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2008-1897",
        "func_name": "lyx2014/Asterisk/find_callno",
        "description": "The IAX2 channel driver (chan_iax2) in Asterisk Open Source 1.0.x, 1.2.x before 1.2.28, and 1.4.x before 1.4.19.1; Business Edition A.x.x, B.x.x before B.2.5.2, and C.x.x before C.1.8.1; AsteriskNOW before 1.0.3; Appliance Developer Kit 0.x.x; and s800i before 1.1.0.3, when configured to allow unauthenticated calls, does not verify that an ACK response contains a call number matching the server's reply to a NEW message, which allows remote attackers to cause a denial of service (traffic amplification) via a spoofed ACK response that does not complete a 3-way handshake.  NOTE: this issue exists because of an incomplete fix for CVE-2008-1923.",
        "git_url": "https://github.com/lyx2014/Asterisk/commit/0670e43c30135044e25cca7f80e1833e2c128653",
        "commit_title": "Merged revisions 114558 via svnmerge from ",
        "commit_text": "https://origsvn.digium.com/svn/asterisk/branches/1.4  ........ r114558 | russell | 2008-04-22 17:15:36 -0500 (Tue, 22 Apr 2008) | 5 lines  When we receive a full frame that is supposed to contain our call number, ensure that it has the correct one. (closes issue #10078) (AST-2008-006)  ........",
        "func_before": "static int find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd) {\n\n\treturn __find_callno(callno, dcallno, sin, new, sockfd, 0);\n}",
        "func": "static int find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int full_frame) {\n\n\treturn __find_callno(callno, dcallno, sin, new, sockfd, 0, full_frame);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,4 @@\n-static int find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd) {\n+static int find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int full_frame) {\n \n-\treturn __find_callno(callno, dcallno, sin, new, sockfd, 0);\n+\treturn __find_callno(callno, dcallno, sin, new, sockfd, 0, full_frame);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "static int find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd) {",
                "\treturn __find_callno(callno, dcallno, sin, new, sockfd, 0);"
            ],
            "added_lines": [
                "static int find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int full_frame) {",
                "\treturn __find_callno(callno, dcallno, sin, new, sockfd, 0, full_frame);"
            ]
        }
    },
    {
        "cve_id": "CVE-2008-1897",
        "func_name": "lyx2014/Asterisk/iax2_do_register",
        "description": "The IAX2 channel driver (chan_iax2) in Asterisk Open Source 1.0.x, 1.2.x before 1.2.28, and 1.4.x before 1.4.19.1; Business Edition A.x.x, B.x.x before B.2.5.2, and C.x.x before C.1.8.1; AsteriskNOW before 1.0.3; Appliance Developer Kit 0.x.x; and s800i before 1.1.0.3, when configured to allow unauthenticated calls, does not verify that an ACK response contains a call number matching the server's reply to a NEW message, which allows remote attackers to cause a denial of service (traffic amplification) via a spoofed ACK response that does not complete a 3-way handshake.  NOTE: this issue exists because of an incomplete fix for CVE-2008-1923.",
        "git_url": "https://github.com/lyx2014/Asterisk/commit/0670e43c30135044e25cca7f80e1833e2c128653",
        "commit_title": "Merged revisions 114558 via svnmerge from ",
        "commit_text": "https://origsvn.digium.com/svn/asterisk/branches/1.4  ........ r114558 | russell | 2008-04-22 17:15:36 -0500 (Tue, 22 Apr 2008) | 5 lines  When we receive a full frame that is supposed to contain our call number, ensure that it has the correct one. (closes issue #10078) (AST-2008-006)  ........",
        "func_before": "static int iax2_do_register(struct iax2_registry *reg)\n{\n\tstruct iax_ie_data ied;\n\tif (iaxdebug)\n\t\tast_debug(1, \"Sending registration request for '%s'\\n\", reg->username);\n\n\tif (reg->dnsmgr && \n\t    ((reg->regstate == REG_STATE_TIMEOUT) || !reg->addr.sin_addr.s_addr)) {\n\t\t/* Maybe the IP has changed, force DNS refresh */\n\t\tast_dnsmgr_refresh(reg->dnsmgr);\n\t}\n\t\n\t/*\n\t * if IP has Changed, free allocated call to create a new one with new IP\n\t * call has the pointer to IP and must be updated to the new one\n\t */\n\tif (reg->dnsmgr && ast_dnsmgr_changed(reg->dnsmgr) && (reg->callno > 0)) {\n\t\tast_mutex_lock(&iaxsl[reg->callno]);\n\t\tiax2_destroy(reg->callno);\n\t\tast_mutex_unlock(&iaxsl[reg->callno]);\n\t\treg->callno = 0;\n\t}\n\tif (!reg->addr.sin_addr.s_addr) {\n\t\tif (iaxdebug)\n\t\t\tast_debug(1, \"Unable to send registration request for '%s' without IP address\\n\", reg->username);\n\t\t/* Setup the next registration attempt */\n\t\treg->expire = iax2_sched_replace(reg->expire, sched, \n\t\t\t(5 * reg->refresh / 6) * 1000, iax2_do_register_s, reg);\n\t\treturn -1;\n\t}\n\n\tif (!reg->callno) {\n\t\tast_debug(1, \"Allocate call number\\n\");\n\t\treg->callno = find_callno_locked(0, 0, &reg->addr, NEW_FORCE, defaultsockfd);\n\t\tif (reg->callno < 1) {\n\t\t\tast_log(LOG_WARNING, \"Unable to create call for registration\\n\");\n\t\t\treturn -1;\n\t\t} else\n\t\t\tast_debug(1, \"Registration created on call %d\\n\", reg->callno);\n\t\tiaxs[reg->callno]->reg = reg;\n\t\tast_mutex_unlock(&iaxsl[reg->callno]);\n\t}\n\t/* Setup the next registration a little early */\n\treg->expire = iax2_sched_replace(reg->expire, sched, \n\t\t(5 * reg->refresh / 6) * 1000, iax2_do_register_s, reg);\n\t/* Send the request */\n\tmemset(&ied, 0, sizeof(ied));\n\tiax_ie_append_str(&ied, IAX_IE_USERNAME, reg->username);\n\tiax_ie_append_short(&ied, IAX_IE_REFRESH, reg->refresh);\n\tsend_command(iaxs[reg->callno],AST_FRAME_IAX, IAX_COMMAND_REGREQ, 0, ied.buf, ied.pos, -1);\n\treg->regstate = REG_STATE_REGSENT;\n\treturn 0;\n}",
        "func": "static int iax2_do_register(struct iax2_registry *reg)\n{\n\tstruct iax_ie_data ied;\n\tif (iaxdebug)\n\t\tast_debug(1, \"Sending registration request for '%s'\\n\", reg->username);\n\n\tif (reg->dnsmgr && \n\t    ((reg->regstate == REG_STATE_TIMEOUT) || !reg->addr.sin_addr.s_addr)) {\n\t\t/* Maybe the IP has changed, force DNS refresh */\n\t\tast_dnsmgr_refresh(reg->dnsmgr);\n\t}\n\t\n\t/*\n\t * if IP has Changed, free allocated call to create a new one with new IP\n\t * call has the pointer to IP and must be updated to the new one\n\t */\n\tif (reg->dnsmgr && ast_dnsmgr_changed(reg->dnsmgr) && (reg->callno > 0)) {\n\t\tast_mutex_lock(&iaxsl[reg->callno]);\n\t\tiax2_destroy(reg->callno);\n\t\tast_mutex_unlock(&iaxsl[reg->callno]);\n\t\treg->callno = 0;\n\t}\n\tif (!reg->addr.sin_addr.s_addr) {\n\t\tif (iaxdebug)\n\t\t\tast_debug(1, \"Unable to send registration request for '%s' without IP address\\n\", reg->username);\n\t\t/* Setup the next registration attempt */\n\t\treg->expire = iax2_sched_replace(reg->expire, sched, \n\t\t\t(5 * reg->refresh / 6) * 1000, iax2_do_register_s, reg);\n\t\treturn -1;\n\t}\n\n\tif (!reg->callno) {\n\t\tast_debug(1, \"Allocate call number\\n\");\n\t\treg->callno = find_callno_locked(0, 0, &reg->addr, NEW_FORCE, defaultsockfd, 0);\n\t\tif (reg->callno < 1) {\n\t\t\tast_log(LOG_WARNING, \"Unable to create call for registration\\n\");\n\t\t\treturn -1;\n\t\t} else\n\t\t\tast_debug(1, \"Registration created on call %d\\n\", reg->callno);\n\t\tiaxs[reg->callno]->reg = reg;\n\t\tast_mutex_unlock(&iaxsl[reg->callno]);\n\t}\n\t/* Setup the next registration a little early */\n\treg->expire = iax2_sched_replace(reg->expire, sched, \n\t\t(5 * reg->refresh / 6) * 1000, iax2_do_register_s, reg);\n\t/* Send the request */\n\tmemset(&ied, 0, sizeof(ied));\n\tiax_ie_append_str(&ied, IAX_IE_USERNAME, reg->username);\n\tiax_ie_append_short(&ied, IAX_IE_REFRESH, reg->refresh);\n\tsend_command(iaxs[reg->callno],AST_FRAME_IAX, IAX_COMMAND_REGREQ, 0, ied.buf, ied.pos, -1);\n\treg->regstate = REG_STATE_REGSENT;\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -31,7 +31,7 @@\n \n \tif (!reg->callno) {\n \t\tast_debug(1, \"Allocate call number\\n\");\n-\t\treg->callno = find_callno_locked(0, 0, &reg->addr, NEW_FORCE, defaultsockfd);\n+\t\treg->callno = find_callno_locked(0, 0, &reg->addr, NEW_FORCE, defaultsockfd, 0);\n \t\tif (reg->callno < 1) {\n \t\t\tast_log(LOG_WARNING, \"Unable to create call for registration\\n\");\n \t\t\treturn -1;",
        "diff_line_info": {
            "deleted_lines": [
                "\t\treg->callno = find_callno_locked(0, 0, &reg->addr, NEW_FORCE, defaultsockfd);"
            ],
            "added_lines": [
                "\t\treg->callno = find_callno_locked(0, 0, &reg->addr, NEW_FORCE, defaultsockfd, 0);"
            ]
        }
    },
    {
        "cve_id": "CVE-2008-1897",
        "func_name": "lyx2014/Asterisk/iax2_poke_peer",
        "description": "The IAX2 channel driver (chan_iax2) in Asterisk Open Source 1.0.x, 1.2.x before 1.2.28, and 1.4.x before 1.4.19.1; Business Edition A.x.x, B.x.x before B.2.5.2, and C.x.x before C.1.8.1; AsteriskNOW before 1.0.3; Appliance Developer Kit 0.x.x; and s800i before 1.1.0.3, when configured to allow unauthenticated calls, does not verify that an ACK response contains a call number matching the server's reply to a NEW message, which allows remote attackers to cause a denial of service (traffic amplification) via a spoofed ACK response that does not complete a 3-way handshake.  NOTE: this issue exists because of an incomplete fix for CVE-2008-1923.",
        "git_url": "https://github.com/lyx2014/Asterisk/commit/0670e43c30135044e25cca7f80e1833e2c128653",
        "commit_title": "Merged revisions 114558 via svnmerge from ",
        "commit_text": "https://origsvn.digium.com/svn/asterisk/branches/1.4  ........ r114558 | russell | 2008-04-22 17:15:36 -0500 (Tue, 22 Apr 2008) | 5 lines  When we receive a full frame that is supposed to contain our call number, ensure that it has the correct one. (closes issue #10078) (AST-2008-006)  ........",
        "func_before": "static int iax2_poke_peer(struct iax2_peer *peer, int heldcall)\n{\n\tif (!peer->maxms || (!peer->addr.sin_addr.s_addr && !peer->dnsmgr)) {\n\t\t/* IF we have no IP without dnsmgr, or this isn't to be monitored, return\n\t\t  immediately after clearing things out */\n\t\tpeer->lastms = 0;\n\t\tpeer->historicms = 0;\n\t\tpeer->pokeexpire = -1;\n\t\tpeer->callno = 0;\n\t\treturn 0;\n\t}\n\tif (peer->callno > 0) {\n\t\tast_log(LOG_NOTICE, \"Still have a callno...\\n\");\n\t\tast_mutex_lock(&iaxsl[peer->callno]);\n\t\tiax2_destroy(peer->callno);\n\t\tast_mutex_unlock(&iaxsl[peer->callno]);\n\t}\n\tif (heldcall)\n\t\tast_mutex_unlock(&iaxsl[heldcall]);\n\tpeer->callno = find_callno(0, 0, &peer->addr, NEW_FORCE, peer->sockfd);\n\tif (heldcall)\n\t\tast_mutex_lock(&iaxsl[heldcall]);\n\tif (peer->callno < 1) {\n\t\tast_log(LOG_WARNING, \"Unable to allocate call for poking peer '%s'\\n\", peer->name);\n\t\treturn -1;\n\t}\n\n\t/* Speed up retransmission times for this qualify call */\n\tiaxs[peer->callno]->pingtime = peer->maxms / 4 + 1;\n\tiaxs[peer->callno]->peerpoke = peer;\n\n \tif (peer->pokeexpire > -1) {\n \t\tif (!ast_sched_del(sched, peer->pokeexpire)) {\n \t\t\tpeer->pokeexpire = -1;\n \t\t\tpeer_unref(peer);\n \t\t}\n \t}\n \n\t/* Queue up a new task to handle no reply */\n\t/* If the host is already unreachable then use the unreachable interval instead */\n\tif (peer->lastms < 0)\n \t\tpeer->pokeexpire = iax2_sched_add(sched, peer->pokefreqnotok, iax2_poke_noanswer, peer_ref(peer));\n\telse\n \t\tpeer->pokeexpire = iax2_sched_add(sched, DEFAULT_MAXMS * 2, iax2_poke_noanswer, peer_ref(peer));\n\n \tif (peer->pokeexpire == -1)\n \t\tpeer_unref(peer);\n\n\t/* And send the poke */\n\tsend_command(iaxs[peer->callno], AST_FRAME_IAX, IAX_COMMAND_POKE, 0, NULL, 0, -1);\n\n\treturn 0;\n}",
        "func": "static int iax2_poke_peer(struct iax2_peer *peer, int heldcall)\n{\n\tif (!peer->maxms || (!peer->addr.sin_addr.s_addr && !peer->dnsmgr)) {\n\t\t/* IF we have no IP without dnsmgr, or this isn't to be monitored, return\n\t\t  immediately after clearing things out */\n\t\tpeer->lastms = 0;\n\t\tpeer->historicms = 0;\n\t\tpeer->pokeexpire = -1;\n\t\tpeer->callno = 0;\n\t\treturn 0;\n\t}\n\tif (peer->callno > 0) {\n\t\tast_log(LOG_NOTICE, \"Still have a callno...\\n\");\n\t\tast_mutex_lock(&iaxsl[peer->callno]);\n\t\tiax2_destroy(peer->callno);\n\t\tast_mutex_unlock(&iaxsl[peer->callno]);\n\t}\n\tif (heldcall)\n\t\tast_mutex_unlock(&iaxsl[heldcall]);\n\tpeer->callno = find_callno(0, 0, &peer->addr, NEW_FORCE, peer->sockfd, 0);\n\tif (heldcall)\n\t\tast_mutex_lock(&iaxsl[heldcall]);\n\tif (peer->callno < 1) {\n\t\tast_log(LOG_WARNING, \"Unable to allocate call for poking peer '%s'\\n\", peer->name);\n\t\treturn -1;\n\t}\n\n\t/* Speed up retransmission times for this qualify call */\n\tiaxs[peer->callno]->pingtime = peer->maxms / 4 + 1;\n\tiaxs[peer->callno]->peerpoke = peer;\n\n \tif (peer->pokeexpire > -1) {\n \t\tif (!ast_sched_del(sched, peer->pokeexpire)) {\n \t\t\tpeer->pokeexpire = -1;\n \t\t\tpeer_unref(peer);\n \t\t}\n \t}\n \n\t/* Queue up a new task to handle no reply */\n\t/* If the host is already unreachable then use the unreachable interval instead */\n\tif (peer->lastms < 0)\n \t\tpeer->pokeexpire = iax2_sched_add(sched, peer->pokefreqnotok, iax2_poke_noanswer, peer_ref(peer));\n\telse\n \t\tpeer->pokeexpire = iax2_sched_add(sched, DEFAULT_MAXMS * 2, iax2_poke_noanswer, peer_ref(peer));\n\n \tif (peer->pokeexpire == -1)\n \t\tpeer_unref(peer);\n\n\t/* And send the poke */\n\tsend_command(iaxs[peer->callno], AST_FRAME_IAX, IAX_COMMAND_POKE, 0, NULL, 0, -1);\n\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -17,7 +17,7 @@\n \t}\n \tif (heldcall)\n \t\tast_mutex_unlock(&iaxsl[heldcall]);\n-\tpeer->callno = find_callno(0, 0, &peer->addr, NEW_FORCE, peer->sockfd);\n+\tpeer->callno = find_callno(0, 0, &peer->addr, NEW_FORCE, peer->sockfd, 0);\n \tif (heldcall)\n \t\tast_mutex_lock(&iaxsl[heldcall]);\n \tif (peer->callno < 1) {",
        "diff_line_info": {
            "deleted_lines": [
                "\tpeer->callno = find_callno(0, 0, &peer->addr, NEW_FORCE, peer->sockfd);"
            ],
            "added_lines": [
                "\tpeer->callno = find_callno(0, 0, &peer->addr, NEW_FORCE, peer->sockfd, 0);"
            ]
        }
    },
    {
        "cve_id": "CVE-2008-1897",
        "func_name": "lyx2014/Asterisk/cache_get_callno_locked",
        "description": "The IAX2 channel driver (chan_iax2) in Asterisk Open Source 1.0.x, 1.2.x before 1.2.28, and 1.4.x before 1.4.19.1; Business Edition A.x.x, B.x.x before B.2.5.2, and C.x.x before C.1.8.1; AsteriskNOW before 1.0.3; Appliance Developer Kit 0.x.x; and s800i before 1.1.0.3, when configured to allow unauthenticated calls, does not verify that an ACK response contains a call number matching the server's reply to a NEW message, which allows remote attackers to cause a denial of service (traffic amplification) via a spoofed ACK response that does not complete a 3-way handshake.  NOTE: this issue exists because of an incomplete fix for CVE-2008-1923.",
        "git_url": "https://github.com/lyx2014/Asterisk/commit/0670e43c30135044e25cca7f80e1833e2c128653",
        "commit_title": "Merged revisions 114558 via svnmerge from ",
        "commit_text": "https://origsvn.digium.com/svn/asterisk/branches/1.4  ........ r114558 | russell | 2008-04-22 17:15:36 -0500 (Tue, 22 Apr 2008) | 5 lines  When we receive a full frame that is supposed to contain our call number, ensure that it has the correct one. (closes issue #10078) (AST-2008-006)  ........",
        "func_before": "static int cache_get_callno_locked(const char *data)\n{\n\tstruct sockaddr_in sin;\n\tint x;\n\tint callno;\n\tstruct iax_ie_data ied;\n\tstruct create_addr_info cai;\n\tstruct parsed_dial_string pds;\n\tchar *tmpstr;\n\n\tfor (x=0; x<IAX_MAX_CALLS; x++) {\n\t\t/* Look for an *exact match* call.  Once a call is negotiated, it can only\n\t\t   look up entries for a single context */\n\t\tif (!ast_mutex_trylock(&iaxsl[x])) {\n\t\t\tif (iaxs[x] && !strcasecmp(data, iaxs[x]->dproot))\n\t\t\t\treturn x;\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t}\n\t}\n\n\t/* No match found, we need to create a new one */\n\n\tmemset(&cai, 0, sizeof(cai));\n\tmemset(&ied, 0, sizeof(ied));\n\tmemset(&pds, 0, sizeof(pds));\n\n\ttmpstr = ast_strdupa(data);\n\tparse_dial_string(tmpstr, &pds);\n\n\tif (ast_strlen_zero(pds.peer)) {\n\t\tast_log(LOG_WARNING, \"No peer provided in the IAX2 dial string '%s'\\n\", data);\n\t\treturn -1;\n\t}\n\n\t/* Populate our address from the given */\n\tif (create_addr(pds.peer, NULL, &sin, &cai))\n\t\treturn -1;\n\n\tast_debug(1, \"peer: %s, username: %s, password: %s, context: %s\\n\",\n\t\tpds.peer, pds.username, pds.password, pds.context);\n\n\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd);\n\tif (callno < 1) {\n\t\tast_log(LOG_WARNING, \"Unable to create call\\n\");\n\t\treturn -1;\n\t}\n\n\tast_string_field_set(iaxs[callno], dproot, data);\n\tiaxs[callno]->capability = IAX_CAPABILITY_FULLBANDWIDTH;\n\n\tiax_ie_append_short(&ied, IAX_IE_VERSION, IAX_PROTO_VERSION);\n\tiax_ie_append_str(&ied, IAX_IE_CALLED_NUMBER, \"TBD\");\n\t/* the string format is slightly different from a standard dial string,\n\t   because the context appears in the 'exten' position\n\t*/\n\tif (pds.exten)\n\t\tiax_ie_append_str(&ied, IAX_IE_CALLED_CONTEXT, pds.exten);\n\tif (pds.username)\n\t\tiax_ie_append_str(&ied, IAX_IE_USERNAME, pds.username);\n\tiax_ie_append_int(&ied, IAX_IE_FORMAT, IAX_CAPABILITY_FULLBANDWIDTH);\n\tiax_ie_append_int(&ied, IAX_IE_CAPABILITY, IAX_CAPABILITY_FULLBANDWIDTH);\n\t/* Keep password handy */\n\tif (pds.password)\n\t\tast_string_field_set(iaxs[callno], secret, pds.password);\n\tif (pds.key)\n\t\tast_string_field_set(iaxs[callno], outkey, pds.key);\n\t/* Start the call going */\n\tsend_command(iaxs[callno], AST_FRAME_IAX, IAX_COMMAND_NEW, 0, ied.buf, ied.pos, -1);\n\n\treturn callno;\n}",
        "func": "static int cache_get_callno_locked(const char *data)\n{\n\tstruct sockaddr_in sin;\n\tint x;\n\tint callno;\n\tstruct iax_ie_data ied;\n\tstruct create_addr_info cai;\n\tstruct parsed_dial_string pds;\n\tchar *tmpstr;\n\n\tfor (x=0; x<IAX_MAX_CALLS; x++) {\n\t\t/* Look for an *exact match* call.  Once a call is negotiated, it can only\n\t\t   look up entries for a single context */\n\t\tif (!ast_mutex_trylock(&iaxsl[x])) {\n\t\t\tif (iaxs[x] && !strcasecmp(data, iaxs[x]->dproot))\n\t\t\t\treturn x;\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t}\n\t}\n\n\t/* No match found, we need to create a new one */\n\n\tmemset(&cai, 0, sizeof(cai));\n\tmemset(&ied, 0, sizeof(ied));\n\tmemset(&pds, 0, sizeof(pds));\n\n\ttmpstr = ast_strdupa(data);\n\tparse_dial_string(tmpstr, &pds);\n\n\tif (ast_strlen_zero(pds.peer)) {\n\t\tast_log(LOG_WARNING, \"No peer provided in the IAX2 dial string '%s'\\n\", data);\n\t\treturn -1;\n\t}\n\n\t/* Populate our address from the given */\n\tif (create_addr(pds.peer, NULL, &sin, &cai))\n\t\treturn -1;\n\n\tast_debug(1, \"peer: %s, username: %s, password: %s, context: %s\\n\",\n\t\tpds.peer, pds.username, pds.password, pds.context);\n\n\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd, 0);\n\tif (callno < 1) {\n\t\tast_log(LOG_WARNING, \"Unable to create call\\n\");\n\t\treturn -1;\n\t}\n\n\tast_string_field_set(iaxs[callno], dproot, data);\n\tiaxs[callno]->capability = IAX_CAPABILITY_FULLBANDWIDTH;\n\n\tiax_ie_append_short(&ied, IAX_IE_VERSION, IAX_PROTO_VERSION);\n\tiax_ie_append_str(&ied, IAX_IE_CALLED_NUMBER, \"TBD\");\n\t/* the string format is slightly different from a standard dial string,\n\t   because the context appears in the 'exten' position\n\t*/\n\tif (pds.exten)\n\t\tiax_ie_append_str(&ied, IAX_IE_CALLED_CONTEXT, pds.exten);\n\tif (pds.username)\n\t\tiax_ie_append_str(&ied, IAX_IE_USERNAME, pds.username);\n\tiax_ie_append_int(&ied, IAX_IE_FORMAT, IAX_CAPABILITY_FULLBANDWIDTH);\n\tiax_ie_append_int(&ied, IAX_IE_CAPABILITY, IAX_CAPABILITY_FULLBANDWIDTH);\n\t/* Keep password handy */\n\tif (pds.password)\n\t\tast_string_field_set(iaxs[callno], secret, pds.password);\n\tif (pds.key)\n\t\tast_string_field_set(iaxs[callno], outkey, pds.key);\n\t/* Start the call going */\n\tsend_command(iaxs[callno], AST_FRAME_IAX, IAX_COMMAND_NEW, 0, ied.buf, ied.pos, -1);\n\n\treturn callno;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -39,7 +39,7 @@\n \tast_debug(1, \"peer: %s, username: %s, password: %s, context: %s\\n\",\n \t\tpds.peer, pds.username, pds.password, pds.context);\n \n-\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd);\n+\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd, 0);\n \tif (callno < 1) {\n \t\tast_log(LOG_WARNING, \"Unable to create call\\n\");\n \t\treturn -1;",
        "diff_line_info": {
            "deleted_lines": [
                "\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd);"
            ],
            "added_lines": [
                "\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd, 0);"
            ]
        }
    },
    {
        "cve_id": "CVE-2008-1897",
        "func_name": "lyx2014/Asterisk/iax2_provision",
        "description": "The IAX2 channel driver (chan_iax2) in Asterisk Open Source 1.0.x, 1.2.x before 1.2.28, and 1.4.x before 1.4.19.1; Business Edition A.x.x, B.x.x before B.2.5.2, and C.x.x before C.1.8.1; AsteriskNOW before 1.0.3; Appliance Developer Kit 0.x.x; and s800i before 1.1.0.3, when configured to allow unauthenticated calls, does not verify that an ACK response contains a call number matching the server's reply to a NEW message, which allows remote attackers to cause a denial of service (traffic amplification) via a spoofed ACK response that does not complete a 3-way handshake.  NOTE: this issue exists because of an incomplete fix for CVE-2008-1923.",
        "git_url": "https://github.com/lyx2014/Asterisk/commit/0670e43c30135044e25cca7f80e1833e2c128653",
        "commit_title": "Merged revisions 114558 via svnmerge from ",
        "commit_text": "https://origsvn.digium.com/svn/asterisk/branches/1.4  ........ r114558 | russell | 2008-04-22 17:15:36 -0500 (Tue, 22 Apr 2008) | 5 lines  When we receive a full frame that is supposed to contain our call number, ensure that it has the correct one. (closes issue #10078) (AST-2008-006)  ........",
        "func_before": "static int iax2_provision(struct sockaddr_in *end, int sockfd, char *dest, const char *template, int force)\n{\n\t/* Returns 1 if provisioned, -1 if not able to find destination, or 0 if no provisioning\n\t   is found for template */\n\tstruct iax_ie_data provdata;\n\tstruct iax_ie_data ied;\n\tunsigned int sig;\n\tstruct sockaddr_in sin;\n\tint callno;\n\tstruct create_addr_info cai;\n\n\tmemset(&cai, 0, sizeof(cai));\n\n\tast_debug(1, \"Provisioning '%s' from template '%s'\\n\", dest, template);\n\n\tif (iax_provision_build(&provdata, &sig, template, force)) {\n\t\tast_debug(1, \"No provisioning found for template '%s'\\n\", template);\n\t\treturn 0;\n\t}\n\n\tif (end) {\n\t\tmemcpy(&sin, end, sizeof(sin));\n\t\tcai.sockfd = sockfd;\n\t} else if (create_addr(dest, NULL, &sin, &cai))\n\t\treturn -1;\n\n\t/* Build the rest of the message */\n\tmemset(&ied, 0, sizeof(ied));\n\tiax_ie_append_raw(&ied, IAX_IE_PROVISIONING, provdata.buf, provdata.pos);\n\n\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd);\n\tif (!callno)\n\t\treturn -1;\n\n\tif (iaxs[callno]) {\n\t\t/* Schedule autodestruct in case they don't ever give us anything back */\n\t\tiaxs[callno]->autoid = iax2_sched_replace(iaxs[callno]->autoid, \n\t\t\tsched, 15000, auto_hangup, (void *)(long)callno);\n\t\tast_set_flag(iaxs[callno], IAX_PROVISION);\n\t\t/* Got a call number now, so go ahead and send the provisioning information */\n\t\tsend_command(iaxs[callno], AST_FRAME_IAX, IAX_COMMAND_PROVISION, 0, ied.buf, ied.pos, -1);\n\t}\n\tast_mutex_unlock(&iaxsl[callno]);\n\n\treturn 1;\n}",
        "func": "static int iax2_provision(struct sockaddr_in *end, int sockfd, char *dest, const char *template, int force)\n{\n\t/* Returns 1 if provisioned, -1 if not able to find destination, or 0 if no provisioning\n\t   is found for template */\n\tstruct iax_ie_data provdata;\n\tstruct iax_ie_data ied;\n\tunsigned int sig;\n\tstruct sockaddr_in sin;\n\tint callno;\n\tstruct create_addr_info cai;\n\n\tmemset(&cai, 0, sizeof(cai));\n\n\tast_debug(1, \"Provisioning '%s' from template '%s'\\n\", dest, template);\n\n\tif (iax_provision_build(&provdata, &sig, template, force)) {\n\t\tast_debug(1, \"No provisioning found for template '%s'\\n\", template);\n\t\treturn 0;\n\t}\n\n\tif (end) {\n\t\tmemcpy(&sin, end, sizeof(sin));\n\t\tcai.sockfd = sockfd;\n\t} else if (create_addr(dest, NULL, &sin, &cai))\n\t\treturn -1;\n\n\t/* Build the rest of the message */\n\tmemset(&ied, 0, sizeof(ied));\n\tiax_ie_append_raw(&ied, IAX_IE_PROVISIONING, provdata.buf, provdata.pos);\n\n\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd, 0);\n\tif (!callno)\n\t\treturn -1;\n\n\tif (iaxs[callno]) {\n\t\t/* Schedule autodestruct in case they don't ever give us anything back */\n\t\tiaxs[callno]->autoid = iax2_sched_replace(iaxs[callno]->autoid, \n\t\t\tsched, 15000, auto_hangup, (void *)(long)callno);\n\t\tast_set_flag(iaxs[callno], IAX_PROVISION);\n\t\t/* Got a call number now, so go ahead and send the provisioning information */\n\t\tsend_command(iaxs[callno], AST_FRAME_IAX, IAX_COMMAND_PROVISION, 0, ied.buf, ied.pos, -1);\n\t}\n\tast_mutex_unlock(&iaxsl[callno]);\n\n\treturn 1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -28,7 +28,7 @@\n \tmemset(&ied, 0, sizeof(ied));\n \tiax_ie_append_raw(&ied, IAX_IE_PROVISIONING, provdata.buf, provdata.pos);\n \n-\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd);\n+\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd, 0);\n \tif (!callno)\n \t\treturn -1;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd);"
            ],
            "added_lines": [
                "\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd, 0);"
            ]
        }
    },
    {
        "cve_id": "CVE-2008-1897",
        "func_name": "lyx2014/Asterisk/match",
        "description": "The IAX2 channel driver (chan_iax2) in Asterisk Open Source 1.0.x, 1.2.x before 1.2.28, and 1.4.x before 1.4.19.1; Business Edition A.x.x, B.x.x before B.2.5.2, and C.x.x before C.1.8.1; AsteriskNOW before 1.0.3; Appliance Developer Kit 0.x.x; and s800i before 1.1.0.3, when configured to allow unauthenticated calls, does not verify that an ACK response contains a call number matching the server's reply to a NEW message, which allows remote attackers to cause a denial of service (traffic amplification) via a spoofed ACK response that does not complete a 3-way handshake.  NOTE: this issue exists because of an incomplete fix for CVE-2008-1923.",
        "git_url": "https://github.com/lyx2014/Asterisk/commit/0670e43c30135044e25cca7f80e1833e2c128653",
        "commit_title": "Merged revisions 114558 via svnmerge from ",
        "commit_text": "https://origsvn.digium.com/svn/asterisk/branches/1.4  ........ r114558 | russell | 2008-04-22 17:15:36 -0500 (Tue, 22 Apr 2008) | 5 lines  When we receive a full frame that is supposed to contain our call number, ensure that it has the correct one. (closes issue #10078) (AST-2008-006)  ........",
        "func_before": "static int match(struct sockaddr_in *sin, unsigned short callno, unsigned short dcallno, const struct chan_iax2_pvt *cur)\n{\n\tif ((cur->addr.sin_addr.s_addr == sin->sin_addr.s_addr) &&\n\t\t(cur->addr.sin_port == sin->sin_port)) {\n\t\t/* This is the main host */\n\t\tif ((cur->peercallno == callno) ||\n\t\t\t((dcallno == cur->callno) && !cur->peercallno)) {\n\t\t\t/* That's us.  Be sure we keep track of the peer call number */\n\t\t\treturn 1;\n\t\t}\n\t}\n\tif ((cur->transfer.sin_addr.s_addr == sin->sin_addr.s_addr) &&\n\t    (cur->transfer.sin_port == sin->sin_port) && (cur->transferring)) {\n\t\t/* We're transferring */\n\t\tif ((dcallno == cur->callno) || (cur->transferring == TRANSFER_MEDIAPASS && cur->transfercallno == callno))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
        "func": "static int match(struct sockaddr_in *sin, unsigned short callno, unsigned short dcallno, const struct chan_iax2_pvt *cur, int full_frame)\n{\n\tif ((cur->addr.sin_addr.s_addr == sin->sin_addr.s_addr) &&\n\t\t(cur->addr.sin_port == sin->sin_port)) {\n\t\t/* This is the main host */\n\t\tif ( (cur->peercallno == 0 || cur->peercallno == callno) &&\n\t\t\t (full_frame ? dcallno == cur->callno : 1) ) {\n\t\t\t/* That's us.  Be sure we keep track of the peer call number */\n\t\t\treturn 1;\n\t\t}\n\t}\n\tif ((cur->transfer.sin_addr.s_addr == sin->sin_addr.s_addr) &&\n\t    (cur->transfer.sin_port == sin->sin_port) && (cur->transferring)) {\n\t\t/* We're transferring */\n\t\tif ((dcallno == cur->callno) || (cur->transferring == TRANSFER_MEDIAPASS && cur->transfercallno == callno))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,10 +1,10 @@\n-static int match(struct sockaddr_in *sin, unsigned short callno, unsigned short dcallno, const struct chan_iax2_pvt *cur)\n+static int match(struct sockaddr_in *sin, unsigned short callno, unsigned short dcallno, const struct chan_iax2_pvt *cur, int full_frame)\n {\n \tif ((cur->addr.sin_addr.s_addr == sin->sin_addr.s_addr) &&\n \t\t(cur->addr.sin_port == sin->sin_port)) {\n \t\t/* This is the main host */\n-\t\tif ((cur->peercallno == callno) ||\n-\t\t\t((dcallno == cur->callno) && !cur->peercallno)) {\n+\t\tif ( (cur->peercallno == 0 || cur->peercallno == callno) &&\n+\t\t\t (full_frame ? dcallno == cur->callno : 1) ) {\n \t\t\t/* That's us.  Be sure we keep track of the peer call number */\n \t\t\treturn 1;\n \t\t}",
        "diff_line_info": {
            "deleted_lines": [
                "static int match(struct sockaddr_in *sin, unsigned short callno, unsigned short dcallno, const struct chan_iax2_pvt *cur)",
                "\t\tif ((cur->peercallno == callno) ||",
                "\t\t\t((dcallno == cur->callno) && !cur->peercallno)) {"
            ],
            "added_lines": [
                "static int match(struct sockaddr_in *sin, unsigned short callno, unsigned short dcallno, const struct chan_iax2_pvt *cur, int full_frame)",
                "\t\tif ( (cur->peercallno == 0 || cur->peercallno == callno) &&",
                "\t\t\t (full_frame ? dcallno == cur->callno : 1) ) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2008-1897",
        "func_name": "lyx2014/Asterisk/socket_process_meta",
        "description": "The IAX2 channel driver (chan_iax2) in Asterisk Open Source 1.0.x, 1.2.x before 1.2.28, and 1.4.x before 1.4.19.1; Business Edition A.x.x, B.x.x before B.2.5.2, and C.x.x before C.1.8.1; AsteriskNOW before 1.0.3; Appliance Developer Kit 0.x.x; and s800i before 1.1.0.3, when configured to allow unauthenticated calls, does not verify that an ACK response contains a call number matching the server's reply to a NEW message, which allows remote attackers to cause a denial of service (traffic amplification) via a spoofed ACK response that does not complete a 3-way handshake.  NOTE: this issue exists because of an incomplete fix for CVE-2008-1923.",
        "git_url": "https://github.com/lyx2014/Asterisk/commit/0670e43c30135044e25cca7f80e1833e2c128653",
        "commit_title": "Merged revisions 114558 via svnmerge from ",
        "commit_text": "https://origsvn.digium.com/svn/asterisk/branches/1.4  ........ r114558 | russell | 2008-04-22 17:15:36 -0500 (Tue, 22 Apr 2008) | 5 lines  When we receive a full frame that is supposed to contain our call number, ensure that it has the correct one. (closes issue #10078) (AST-2008-006)  ........",
        "func_before": "static int socket_process_meta(int packet_len, struct ast_iax2_meta_hdr *meta, struct sockaddr_in *sin, int sockfd,\n\tstruct iax_frame *fr)\n{\n\tunsigned char metatype;\n\tstruct ast_iax2_meta_trunk_mini *mtm;\n\tstruct ast_iax2_meta_trunk_hdr *mth;\n\tstruct ast_iax2_meta_trunk_entry *mte;\n\tstruct iax2_trunk_peer *tpeer;\n\tunsigned int ts;\n\tvoid *ptr;\n\tstruct timeval rxtrunktime;\n\tstruct ast_frame f = { 0, };\n\n\tif (packet_len < sizeof(*meta)) {\n\t\tast_log(LOG_WARNING, \"Rejecting packet from '%s.%d' that is flagged as a meta frame but is too short\\n\", \n\t\t\tast_inet_ntoa(sin->sin_addr), ntohs(sin->sin_port));\n\t\treturn 1;\n\t}\n\n\tif (meta->metacmd != IAX_META_TRUNK)\n\t\treturn 1;\n\n\tif (packet_len < (sizeof(*meta) + sizeof(*mth))) {\n\t\tast_log(LOG_WARNING, \"midget meta trunk packet received (%d of %d min)\\n\", packet_len,\n\t\t\t(int) (sizeof(*meta) + sizeof(*mth)));\n\t\treturn 1;\n\t}\n\tmth = (struct ast_iax2_meta_trunk_hdr *)(meta->data);\n\tts = ntohl(mth->ts);\n\tmetatype = meta->cmddata;\n\tpacket_len -= (sizeof(*meta) + sizeof(*mth));\n\tptr = mth->data;\n\ttpeer = find_tpeer(sin, sockfd);\n\tif (!tpeer) {\n\t\tast_log(LOG_WARNING, \"Unable to accept trunked packet from '%s:%d': No matching peer\\n\", \n\t\t\tast_inet_ntoa(sin->sin_addr), ntohs(sin->sin_port));\n\t\treturn 1;\n\t}\n\ttpeer->trunkact = ast_tvnow();\n\tif (!ts || ast_tvzero(tpeer->rxtrunktime))\n\t\ttpeer->rxtrunktime = tpeer->trunkact;\n\trxtrunktime = tpeer->rxtrunktime;\n\tast_mutex_unlock(&tpeer->lock);\n\twhile (packet_len >= sizeof(*mte)) {\n\t\t/* Process channels */\n\t\tunsigned short callno, trunked_ts, len;\n\n\t\tif (metatype == IAX_META_TRUNK_MINI) {\n\t\t\tmtm = (struct ast_iax2_meta_trunk_mini *) ptr;\n\t\t\tptr += sizeof(*mtm);\n\t\t\tpacket_len -= sizeof(*mtm);\n\t\t\tlen = ntohs(mtm->len);\n\t\t\tcallno = ntohs(mtm->mini.callno);\n\t\t\ttrunked_ts = ntohs(mtm->mini.ts);\n\t\t} else if (metatype == IAX_META_TRUNK_SUPERMINI) {\n\t\t\tmte = (struct ast_iax2_meta_trunk_entry *)ptr;\n\t\t\tptr += sizeof(*mte);\n\t\t\tpacket_len -= sizeof(*mte);\n\t\t\tlen = ntohs(mte->len);\n\t\t\tcallno = ntohs(mte->callno);\n\t\t\ttrunked_ts = 0;\n\t\t} else {\n\t\t\tast_log(LOG_WARNING, \"Unknown meta trunk cmd from '%s:%d': dropping\\n\", ast_inet_ntoa(sin->sin_addr), ntohs(sin->sin_port));\n\t\t\tbreak;\n\t\t}\n\t\t/* Stop if we don't have enough data */\n\t\tif (len > packet_len)\n\t\t\tbreak;\n\t\tfr->callno = find_callno_locked(callno & ~IAX_FLAG_FULL, 0, sin, NEW_PREVENT, sockfd);\n\t\tif (!fr->callno)\n\t\t\tcontinue;\n\n\t\t/* If it's a valid call, deliver the contents.  If not, we\n\t\t   drop it, since we don't have a scallno to use for an INVAL */\n\t\t/* Process as a mini frame */\n\t\tmemset(&f, 0, sizeof(f));\n\t\tf.frametype = AST_FRAME_VOICE;\n\t\tif (!iaxs[fr->callno]) {\n\t\t\t/* drop it */\n\t\t} else if (iaxs[fr->callno]->voiceformat == 0) {\n\t\t\tast_log(LOG_WARNING, \"Received trunked frame before first full voice frame\\n \");\n\t\t\tiax2_vnak(fr->callno);\n\t\t} else {\n\t\t\tf.subclass = iaxs[fr->callno]->voiceformat;\n\t\t\tf.datalen = len;\n\t\t\tif (f.datalen >= 0) {\n\t\t\t\tif (f.datalen)\n\t\t\t\t\tf.data = ptr;\n\t\t\t\telse\n\t\t\t\t\tf.data = NULL;\n\t\t\t\tif (trunked_ts)\n\t\t\t\t\tfr->ts = (iaxs[fr->callno]->last & 0xFFFF0000L) | (trunked_ts & 0xffff);\n\t\t\t\telse\n\t\t\t\t\tfr->ts = fix_peerts(&rxtrunktime, fr->callno, ts);\n\t\t\t\t/* Don't pass any packets until we're started */\n\t\t\t\tif (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)) {\n\t\t\t\t\tstruct iax_frame *duped_fr;\n\n\t\t\t\t\t/* Common things */\n\t\t\t\t\tf.src = \"IAX2\";\n\t\t\t\t\tf.mallocd = 0;\n\t\t\t\t\tf.offset = 0;\n\t\t\t\t\tif (f.datalen && (f.frametype == AST_FRAME_VOICE)) \n\t\t\t\t\t\tf.samples = ast_codec_get_samples(&f);\n\t\t\t\t\telse\n\t\t\t\t\t\tf.samples = 0;\n\t\t\t\t\tfr->outoforder = 0;\n\t\t\t\t\tiax_frame_wrap(fr, &f);\n\t\t\t\t\tduped_fr = iaxfrdup2(fr);\n\t\t\t\t\tif (duped_fr)\n\t\t\t\t\t\tschedule_delivery(duped_fr, 1, 1, &fr->ts);\n\t\t\t\t\tif (iaxs[fr->callno] && iaxs[fr->callno]->last < fr->ts)\n\t\t\t\t\t\tiaxs[fr->callno]->last = fr->ts;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tast_log(LOG_WARNING, \"Datalen < 0?\\n\");\n\t\t\t}\n\t\t}\n\t\tast_mutex_unlock(&iaxsl[fr->callno]);\n\t\tptr += len;\n\t\tpacket_len -= len;\n\t}\n\n\treturn 1;\n}",
        "func": "static int socket_process_meta(int packet_len, struct ast_iax2_meta_hdr *meta, struct sockaddr_in *sin, int sockfd,\n\tstruct iax_frame *fr)\n{\n\tunsigned char metatype;\n\tstruct ast_iax2_meta_trunk_mini *mtm;\n\tstruct ast_iax2_meta_trunk_hdr *mth;\n\tstruct ast_iax2_meta_trunk_entry *mte;\n\tstruct iax2_trunk_peer *tpeer;\n\tunsigned int ts;\n\tvoid *ptr;\n\tstruct timeval rxtrunktime;\n\tstruct ast_frame f = { 0, };\n\n\tif (packet_len < sizeof(*meta)) {\n\t\tast_log(LOG_WARNING, \"Rejecting packet from '%s.%d' that is flagged as a meta frame but is too short\\n\", \n\t\t\tast_inet_ntoa(sin->sin_addr), ntohs(sin->sin_port));\n\t\treturn 1;\n\t}\n\n\tif (meta->metacmd != IAX_META_TRUNK)\n\t\treturn 1;\n\n\tif (packet_len < (sizeof(*meta) + sizeof(*mth))) {\n\t\tast_log(LOG_WARNING, \"midget meta trunk packet received (%d of %d min)\\n\", packet_len,\n\t\t\t(int) (sizeof(*meta) + sizeof(*mth)));\n\t\treturn 1;\n\t}\n\tmth = (struct ast_iax2_meta_trunk_hdr *)(meta->data);\n\tts = ntohl(mth->ts);\n\tmetatype = meta->cmddata;\n\tpacket_len -= (sizeof(*meta) + sizeof(*mth));\n\tptr = mth->data;\n\ttpeer = find_tpeer(sin, sockfd);\n\tif (!tpeer) {\n\t\tast_log(LOG_WARNING, \"Unable to accept trunked packet from '%s:%d': No matching peer\\n\", \n\t\t\tast_inet_ntoa(sin->sin_addr), ntohs(sin->sin_port));\n\t\treturn 1;\n\t}\n\ttpeer->trunkact = ast_tvnow();\n\tif (!ts || ast_tvzero(tpeer->rxtrunktime))\n\t\ttpeer->rxtrunktime = tpeer->trunkact;\n\trxtrunktime = tpeer->rxtrunktime;\n\tast_mutex_unlock(&tpeer->lock);\n\twhile (packet_len >= sizeof(*mte)) {\n\t\t/* Process channels */\n\t\tunsigned short callno, trunked_ts, len;\n\n\t\tif (metatype == IAX_META_TRUNK_MINI) {\n\t\t\tmtm = (struct ast_iax2_meta_trunk_mini *) ptr;\n\t\t\tptr += sizeof(*mtm);\n\t\t\tpacket_len -= sizeof(*mtm);\n\t\t\tlen = ntohs(mtm->len);\n\t\t\tcallno = ntohs(mtm->mini.callno);\n\t\t\ttrunked_ts = ntohs(mtm->mini.ts);\n\t\t} else if (metatype == IAX_META_TRUNK_SUPERMINI) {\n\t\t\tmte = (struct ast_iax2_meta_trunk_entry *)ptr;\n\t\t\tptr += sizeof(*mte);\n\t\t\tpacket_len -= sizeof(*mte);\n\t\t\tlen = ntohs(mte->len);\n\t\t\tcallno = ntohs(mte->callno);\n\t\t\ttrunked_ts = 0;\n\t\t} else {\n\t\t\tast_log(LOG_WARNING, \"Unknown meta trunk cmd from '%s:%d': dropping\\n\", ast_inet_ntoa(sin->sin_addr), ntohs(sin->sin_port));\n\t\t\tbreak;\n\t\t}\n\t\t/* Stop if we don't have enough data */\n\t\tif (len > packet_len)\n\t\t\tbreak;\n\t\tfr->callno = find_callno_locked(callno & ~IAX_FLAG_FULL, 0, sin, NEW_PREVENT, sockfd, 0);\n\t\tif (!fr->callno)\n\t\t\tcontinue;\n\n\t\t/* If it's a valid call, deliver the contents.  If not, we\n\t\t   drop it, since we don't have a scallno to use for an INVAL */\n\t\t/* Process as a mini frame */\n\t\tmemset(&f, 0, sizeof(f));\n\t\tf.frametype = AST_FRAME_VOICE;\n\t\tif (!iaxs[fr->callno]) {\n\t\t\t/* drop it */\n\t\t} else if (iaxs[fr->callno]->voiceformat == 0) {\n\t\t\tast_log(LOG_WARNING, \"Received trunked frame before first full voice frame\\n \");\n\t\t\tiax2_vnak(fr->callno);\n\t\t} else {\n\t\t\tf.subclass = iaxs[fr->callno]->voiceformat;\n\t\t\tf.datalen = len;\n\t\t\tif (f.datalen >= 0) {\n\t\t\t\tif (f.datalen)\n\t\t\t\t\tf.data = ptr;\n\t\t\t\telse\n\t\t\t\t\tf.data = NULL;\n\t\t\t\tif (trunked_ts)\n\t\t\t\t\tfr->ts = (iaxs[fr->callno]->last & 0xFFFF0000L) | (trunked_ts & 0xffff);\n\t\t\t\telse\n\t\t\t\t\tfr->ts = fix_peerts(&rxtrunktime, fr->callno, ts);\n\t\t\t\t/* Don't pass any packets until we're started */\n\t\t\t\tif (ast_test_flag(&iaxs[fr->callno]->state, IAX_STATE_STARTED)) {\n\t\t\t\t\tstruct iax_frame *duped_fr;\n\n\t\t\t\t\t/* Common things */\n\t\t\t\t\tf.src = \"IAX2\";\n\t\t\t\t\tf.mallocd = 0;\n\t\t\t\t\tf.offset = 0;\n\t\t\t\t\tif (f.datalen && (f.frametype == AST_FRAME_VOICE)) \n\t\t\t\t\t\tf.samples = ast_codec_get_samples(&f);\n\t\t\t\t\telse\n\t\t\t\t\t\tf.samples = 0;\n\t\t\t\t\tfr->outoforder = 0;\n\t\t\t\t\tiax_frame_wrap(fr, &f);\n\t\t\t\t\tduped_fr = iaxfrdup2(fr);\n\t\t\t\t\tif (duped_fr)\n\t\t\t\t\t\tschedule_delivery(duped_fr, 1, 1, &fr->ts);\n\t\t\t\t\tif (iaxs[fr->callno] && iaxs[fr->callno]->last < fr->ts)\n\t\t\t\t\t\tiaxs[fr->callno]->last = fr->ts;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tast_log(LOG_WARNING, \"Datalen < 0?\\n\");\n\t\t\t}\n\t\t}\n\t\tast_mutex_unlock(&iaxsl[fr->callno]);\n\t\tptr += len;\n\t\tpacket_len -= len;\n\t}\n\n\treturn 1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -66,7 +66,7 @@\n \t\t/* Stop if we don't have enough data */\n \t\tif (len > packet_len)\n \t\t\tbreak;\n-\t\tfr->callno = find_callno_locked(callno & ~IAX_FLAG_FULL, 0, sin, NEW_PREVENT, sockfd);\n+\t\tfr->callno = find_callno_locked(callno & ~IAX_FLAG_FULL, 0, sin, NEW_PREVENT, sockfd, 0);\n \t\tif (!fr->callno)\n \t\t\tcontinue;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tfr->callno = find_callno_locked(callno & ~IAX_FLAG_FULL, 0, sin, NEW_PREVENT, sockfd);"
            ],
            "added_lines": [
                "\t\tfr->callno = find_callno_locked(callno & ~IAX_FLAG_FULL, 0, sin, NEW_PREVENT, sockfd, 0);"
            ]
        }
    },
    {
        "cve_id": "CVE-2008-1897",
        "func_name": "lyx2014/Asterisk/find_callno_locked",
        "description": "The IAX2 channel driver (chan_iax2) in Asterisk Open Source 1.0.x, 1.2.x before 1.2.28, and 1.4.x before 1.4.19.1; Business Edition A.x.x, B.x.x before B.2.5.2, and C.x.x before C.1.8.1; AsteriskNOW before 1.0.3; Appliance Developer Kit 0.x.x; and s800i before 1.1.0.3, when configured to allow unauthenticated calls, does not verify that an ACK response contains a call number matching the server's reply to a NEW message, which allows remote attackers to cause a denial of service (traffic amplification) via a spoofed ACK response that does not complete a 3-way handshake.  NOTE: this issue exists because of an incomplete fix for CVE-2008-1923.",
        "git_url": "https://github.com/lyx2014/Asterisk/commit/0670e43c30135044e25cca7f80e1833e2c128653",
        "commit_title": "Merged revisions 114558 via svnmerge from ",
        "commit_text": "https://origsvn.digium.com/svn/asterisk/branches/1.4  ........ r114558 | russell | 2008-04-22 17:15:36 -0500 (Tue, 22 Apr 2008) | 5 lines  When we receive a full frame that is supposed to contain our call number, ensure that it has the correct one. (closes issue #10078) (AST-2008-006)  ........",
        "func_before": "static int find_callno_locked(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd) {\n\n\treturn __find_callno(callno, dcallno, sin, new, sockfd, 1);\n}",
        "func": "static int find_callno_locked(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int full_frame) {\n\n\treturn __find_callno(callno, dcallno, sin, new, sockfd, 1, full_frame);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,4 @@\n-static int find_callno_locked(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd) {\n+static int find_callno_locked(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int full_frame) {\n \n-\treturn __find_callno(callno, dcallno, sin, new, sockfd, 1);\n+\treturn __find_callno(callno, dcallno, sin, new, sockfd, 1, full_frame);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "static int find_callno_locked(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd) {",
                "\treturn __find_callno(callno, dcallno, sin, new, sockfd, 1);"
            ],
            "added_lines": [
                "static int find_callno_locked(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int full_frame) {",
                "\treturn __find_callno(callno, dcallno, sin, new, sockfd, 1, full_frame);"
            ]
        }
    },
    {
        "cve_id": "CVE-2008-1897",
        "func_name": "lyx2014/Asterisk/iax2_request",
        "description": "The IAX2 channel driver (chan_iax2) in Asterisk Open Source 1.0.x, 1.2.x before 1.2.28, and 1.4.x before 1.4.19.1; Business Edition A.x.x, B.x.x before B.2.5.2, and C.x.x before C.1.8.1; AsteriskNOW before 1.0.3; Appliance Developer Kit 0.x.x; and s800i before 1.1.0.3, when configured to allow unauthenticated calls, does not verify that an ACK response contains a call number matching the server's reply to a NEW message, which allows remote attackers to cause a denial of service (traffic amplification) via a spoofed ACK response that does not complete a 3-way handshake.  NOTE: this issue exists because of an incomplete fix for CVE-2008-1923.",
        "git_url": "https://github.com/lyx2014/Asterisk/commit/0670e43c30135044e25cca7f80e1833e2c128653",
        "commit_title": "Merged revisions 114558 via svnmerge from ",
        "commit_text": "https://origsvn.digium.com/svn/asterisk/branches/1.4  ........ r114558 | russell | 2008-04-22 17:15:36 -0500 (Tue, 22 Apr 2008) | 5 lines  When we receive a full frame that is supposed to contain our call number, ensure that it has the correct one. (closes issue #10078) (AST-2008-006)  ........",
        "func_before": "static struct ast_channel *iax2_request(const char *type, int format, void *data, int *cause)\n{\n\tint callno;\n\tint res;\n\tint fmt, native;\n\tstruct sockaddr_in sin;\n\tstruct ast_channel *c;\n\tstruct parsed_dial_string pds;\n\tstruct create_addr_info cai;\n\tchar *tmpstr;\n\n\tmemset(&pds, 0, sizeof(pds));\n\ttmpstr = ast_strdupa(data);\n\tparse_dial_string(tmpstr, &pds);\n\n\tif (ast_strlen_zero(pds.peer)) {\n\t\tast_log(LOG_WARNING, \"No peer provided in the IAX2 dial string '%s'\\n\", (char *) data);\n\t\treturn NULL;\n\t}\n\t       \n\tmemset(&cai, 0, sizeof(cai));\n\tcai.capability = iax2_capability;\n\n\tast_copy_flags(&cai, &globalflags, IAX_NOTRANSFER | IAX_TRANSFERMEDIA | IAX_USEJITTERBUF | IAX_FORCEJITTERBUF);\n\t\n\t/* Populate our address from the given */\n\tif (create_addr(pds.peer, NULL, &sin, &cai)) {\n\t\t*cause = AST_CAUSE_UNREGISTERED;\n\t\treturn NULL;\n\t}\n\n\tif (pds.port)\n\t\tsin.sin_port = htons(atoi(pds.port));\n\n\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd);\n\tif (callno < 1) {\n\t\tast_log(LOG_WARNING, \"Unable to create call\\n\");\n\t\t*cause = AST_CAUSE_CONGESTION;\n\t\treturn NULL;\n\t}\n\n\t/* If this is a trunk, update it now */\n\tast_copy_flags(iaxs[callno], &cai, IAX_TRUNK | IAX_SENDANI | IAX_NOTRANSFER | IAX_TRANSFERMEDIA | IAX_USEJITTERBUF | IAX_FORCEJITTERBUF);\t\n\tif (ast_test_flag(&cai, IAX_TRUNK)) {\n\t\tint new_callno;\n\t\tif ((new_callno = make_trunk(callno, 1)) != -1)\n\t\t\tcallno = new_callno;\n\t}\n\tiaxs[callno]->maxtime = cai.maxtime;\n\tif (cai.found)\n\t\tast_string_field_set(iaxs[callno], host, pds.peer);\n\n\tc = ast_iax2_new(callno, AST_STATE_DOWN, cai.capability);\n\n\tast_mutex_unlock(&iaxsl[callno]);\n\n\tif (c) {\n\t\t/* Choose a format we can live with */\n\t\tif (c->nativeformats & format) \n\t\t\tc->nativeformats &= format;\n\t\telse {\n\t\t\tnative = c->nativeformats;\n\t\t\tfmt = format;\n\t\t\tres = ast_translator_best_choice(&fmt, &native);\n\t\t\tif (res < 0) {\n\t\t\t\tast_log(LOG_WARNING, \"Unable to create translator path for %s to %s on %s\\n\",\n\t\t\t\t\tast_getformatname(c->nativeformats), ast_getformatname(fmt), c->name);\n\t\t\t\tast_hangup(c);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tc->nativeformats = native;\n\t\t}\n\t\tc->readformat = ast_best_codec(c->nativeformats);\n\t\tc->writeformat = c->readformat;\n\t}\n\n\treturn c;\n}",
        "func": "static struct ast_channel *iax2_request(const char *type, int format, void *data, int *cause)\n{\n\tint callno;\n\tint res;\n\tint fmt, native;\n\tstruct sockaddr_in sin;\n\tstruct ast_channel *c;\n\tstruct parsed_dial_string pds;\n\tstruct create_addr_info cai;\n\tchar *tmpstr;\n\n\tmemset(&pds, 0, sizeof(pds));\n\ttmpstr = ast_strdupa(data);\n\tparse_dial_string(tmpstr, &pds);\n\n\tif (ast_strlen_zero(pds.peer)) {\n\t\tast_log(LOG_WARNING, \"No peer provided in the IAX2 dial string '%s'\\n\", (char *) data);\n\t\treturn NULL;\n\t}\n\t       \n\tmemset(&cai, 0, sizeof(cai));\n\tcai.capability = iax2_capability;\n\n\tast_copy_flags(&cai, &globalflags, IAX_NOTRANSFER | IAX_TRANSFERMEDIA | IAX_USEJITTERBUF | IAX_FORCEJITTERBUF);\n\t\n\t/* Populate our address from the given */\n\tif (create_addr(pds.peer, NULL, &sin, &cai)) {\n\t\t*cause = AST_CAUSE_UNREGISTERED;\n\t\treturn NULL;\n\t}\n\n\tif (pds.port)\n\t\tsin.sin_port = htons(atoi(pds.port));\n\n\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd, 0);\n\tif (callno < 1) {\n\t\tast_log(LOG_WARNING, \"Unable to create call\\n\");\n\t\t*cause = AST_CAUSE_CONGESTION;\n\t\treturn NULL;\n\t}\n\n\t/* If this is a trunk, update it now */\n\tast_copy_flags(iaxs[callno], &cai, IAX_TRUNK | IAX_SENDANI | IAX_NOTRANSFER | IAX_TRANSFERMEDIA | IAX_USEJITTERBUF | IAX_FORCEJITTERBUF);\t\n\tif (ast_test_flag(&cai, IAX_TRUNK)) {\n\t\tint new_callno;\n\t\tif ((new_callno = make_trunk(callno, 1)) != -1)\n\t\t\tcallno = new_callno;\n\t}\n\tiaxs[callno]->maxtime = cai.maxtime;\n\tif (cai.found)\n\t\tast_string_field_set(iaxs[callno], host, pds.peer);\n\n\tc = ast_iax2_new(callno, AST_STATE_DOWN, cai.capability);\n\n\tast_mutex_unlock(&iaxsl[callno]);\n\n\tif (c) {\n\t\t/* Choose a format we can live with */\n\t\tif (c->nativeformats & format) \n\t\t\tc->nativeformats &= format;\n\t\telse {\n\t\t\tnative = c->nativeformats;\n\t\t\tfmt = format;\n\t\t\tres = ast_translator_best_choice(&fmt, &native);\n\t\t\tif (res < 0) {\n\t\t\t\tast_log(LOG_WARNING, \"Unable to create translator path for %s to %s on %s\\n\",\n\t\t\t\t\tast_getformatname(c->nativeformats), ast_getformatname(fmt), c->name);\n\t\t\t\tast_hangup(c);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tc->nativeformats = native;\n\t\t}\n\t\tc->readformat = ast_best_codec(c->nativeformats);\n\t\tc->writeformat = c->readformat;\n\t}\n\n\treturn c;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -32,7 +32,7 @@\n \tif (pds.port)\n \t\tsin.sin_port = htons(atoi(pds.port));\n \n-\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd);\n+\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd, 0);\n \tif (callno < 1) {\n \t\tast_log(LOG_WARNING, \"Unable to create call\\n\");\n \t\t*cause = AST_CAUSE_CONGESTION;",
        "diff_line_info": {
            "deleted_lines": [
                "\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd);"
            ],
            "added_lines": [
                "\tcallno = find_callno_locked(0, 0, &sin, NEW_FORCE, cai.sockfd, 0);"
            ]
        }
    },
    {
        "cve_id": "CVE-2008-1897",
        "func_name": "lyx2014/Asterisk/__find_callno",
        "description": "The IAX2 channel driver (chan_iax2) in Asterisk Open Source 1.0.x, 1.2.x before 1.2.28, and 1.4.x before 1.4.19.1; Business Edition A.x.x, B.x.x before B.2.5.2, and C.x.x before C.1.8.1; AsteriskNOW before 1.0.3; Appliance Developer Kit 0.x.x; and s800i before 1.1.0.3, when configured to allow unauthenticated calls, does not verify that an ACK response contains a call number matching the server's reply to a NEW message, which allows remote attackers to cause a denial of service (traffic amplification) via a spoofed ACK response that does not complete a 3-way handshake.  NOTE: this issue exists because of an incomplete fix for CVE-2008-1923.",
        "git_url": "https://github.com/lyx2014/Asterisk/commit/0670e43c30135044e25cca7f80e1833e2c128653",
        "commit_title": "Merged revisions 114558 via svnmerge from ",
        "commit_text": "https://origsvn.digium.com/svn/asterisk/branches/1.4  ........ r114558 | russell | 2008-04-22 17:15:36 -0500 (Tue, 22 Apr 2008) | 5 lines  When we receive a full frame that is supposed to contain our call number, ensure that it has the correct one. (closes issue #10078) (AST-2008-006)  ........",
        "func_before": "static int __find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int return_locked)\n{\n\tint res = 0;\n\tint x;\n\tstruct timeval now;\n\tchar host[80];\n\n\tif (new <= NEW_ALLOW) {\n\t\tfor (x=1;(res < 1) && (x<maxnontrunkcall);x++) {\n\t\t\tast_mutex_lock(&iaxsl[x]);\n\t\t\tif (iaxs[x]) {\n\t\t\t\t/* Look for an exact match */\n\t\t\t\tif (match(sin, callno, dcallno, iaxs[x])) {\n\t\t\t\t\tres = x;\n\t\t\t\t}\n\t\t\t}\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t}\n\t\tfor (x=TRUNK_CALL_START;(res < 1) && (x<maxtrunkcall);x++) {\n\t\t\tast_mutex_lock(&iaxsl[x]);\n\t\t\tif (iaxs[x]) {\n\t\t\t\t/* Look for an exact match */\n\t\t\t\tif (match(sin, callno, dcallno, iaxs[x])) {\n\t\t\t\t\tres = x;\n\t\t\t\t}\n\t\t\t}\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t}\n\t}\n\tif ((res < 1) && (new >= NEW_ALLOW)) {\n\t\t/* It may seem odd that we look through the peer list for a name for\n\t\t * this *incoming* call.  Well, it is weird.  However, users don't\n\t\t * have an IP address/port number that we can match against.  So,\n\t\t * this is just checking for a peer that has that IP/port and\n\t\t * assuming that we have a user of the same name.  This isn't always\n\t\t * correct, but it will be changed if needed after authentication. */\n\t\tif (!iax2_getpeername(*sin, host, sizeof(host)))\n\t\t\tsnprintf(host, sizeof(host), \"%s:%d\", ast_inet_ntoa(sin->sin_addr), ntohs(sin->sin_port));\n\t\tnow = ast_tvnow();\n\t\tfor (x=1;x<TRUNK_CALL_START;x++) {\n\t\t\t/* Find first unused call number that hasn't been used in a while */\n\t\t\tast_mutex_lock(&iaxsl[x]);\n\t\t\tif (!iaxs[x] && ((now.tv_sec - lastused[x].tv_sec) > MIN_REUSE_TIME)) break;\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t}\n\t\t/* We've still got lock held if we found a spot */\n\t\tif (x >= TRUNK_CALL_START) {\n\t\t\tast_log(LOG_WARNING, \"No more space\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tiaxs[x] = new_iax(sin, host);\n\t\tupdate_max_nontrunk();\n\t\tif (iaxs[x]) {\n\t\t\tif (iaxdebug)\n\t\t\t\tast_debug(1, \"Creating new call structure %d\\n\", x);\n\t\t\tiaxs[x]->sockfd = sockfd;\n\t\t\tiaxs[x]->addr.sin_port = sin->sin_port;\n\t\t\tiaxs[x]->addr.sin_family = sin->sin_family;\n\t\t\tiaxs[x]->addr.sin_addr.s_addr = sin->sin_addr.s_addr;\n\t\t\tiaxs[x]->peercallno = callno;\n\t\t\tiaxs[x]->callno = x;\n\t\t\tiaxs[x]->pingtime = DEFAULT_RETRY_TIME;\n\t\t\tiaxs[x]->expiry = min_reg_expire;\n\t\t\tiaxs[x]->pingid = iax2_sched_add(sched, ping_time * 1000, send_ping, (void *)(long)x);\n\t\t\tiaxs[x]->lagid = iax2_sched_add(sched, lagrq_time * 1000, send_lagrq, (void *)(long)x);\n\t\t\tiaxs[x]->amaflags = amaflags;\n\t\t\tast_copy_flags(iaxs[x], (&globalflags), IAX_NOTRANSFER | IAX_TRANSFERMEDIA | IAX_USEJITTERBUF | IAX_FORCEJITTERBUF);\n\t\t\t\n\t\t\tast_string_field_set(iaxs[x], accountcode, accountcode);\n\t\t\tast_string_field_set(iaxs[x], mohinterpret, mohinterpret);\n\t\t\tast_string_field_set(iaxs[x], mohsuggest, mohsuggest);\n\t\t\tast_string_field_set(iaxs[x], parkinglot, default_parkinglot);\n\t\t} else {\n\t\t\tast_log(LOG_WARNING, \"Out of resources\\n\");\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t\treturn 0;\n\t\t}\n\t\tif (!return_locked)\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\tres = x;\n\t}\n\treturn res;\n}",
        "func": "static int __find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int return_locked, int full_frame)\n{\n\tint res = 0;\n\tint x;\n\tstruct timeval now;\n\tchar host[80];\n\n\tif (new <= NEW_ALLOW) {\n\t\tfor (x=1;(res < 1) && (x<maxnontrunkcall);x++) {\n\t\t\tast_mutex_lock(&iaxsl[x]);\n\t\t\tif (iaxs[x]) {\n\t\t\t\t/* Look for an exact match */\n\t\t\t\tif (match(sin, callno, dcallno, iaxs[x], full_frame)) {\n\t\t\t\t\tres = x;\n\t\t\t\t}\n\t\t\t}\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t}\n\t\tfor (x=TRUNK_CALL_START;(res < 1) && (x<maxtrunkcall);x++) {\n\t\t\tast_mutex_lock(&iaxsl[x]);\n\t\t\tif (iaxs[x]) {\n\t\t\t\t/* Look for an exact match */\n\t\t\t\tif (match(sin, callno, dcallno, iaxs[x], full_frame)) {\n\t\t\t\t\tres = x;\n\t\t\t\t}\n\t\t\t}\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t}\n\t}\n\tif ((res < 1) && (new >= NEW_ALLOW)) {\n\t\tint start, found = 0;\n\n\t\t/* It may seem odd that we look through the peer list for a name for\n\t\t * this *incoming* call.  Well, it is weird.  However, users don't\n\t\t * have an IP address/port number that we can match against.  So,\n\t\t * this is just checking for a peer that has that IP/port and\n\t\t * assuming that we have a user of the same name.  This isn't always\n\t\t * correct, but it will be changed if needed after authentication. */\n\t\tif (!iax2_getpeername(*sin, host, sizeof(host)))\n\t\t\tsnprintf(host, sizeof(host), \"%s:%d\", ast_inet_ntoa(sin->sin_addr), ntohs(sin->sin_port));\n\n\t\tnow = ast_tvnow();\n\t\tstart = 1 + (ast_random() % (TRUNK_CALL_START - 1));\n\t\tfor (x = start; 1; x++) {\n\t\t\tif (x == TRUNK_CALL_START) {\n\t\t\t\tx = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* Find first unused call number that hasn't been used in a while */\n\t\t\tast_mutex_lock(&iaxsl[x]);\n\t\t\tif (!iaxs[x] && ((now.tv_sec - lastused[x].tv_sec) > MIN_REUSE_TIME)) {\n\t\t\t\tfound = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t\t\n\t\t\tif (x == start - 1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/* We've still got lock held if we found a spot */\n\t\tif (x == start - 1 && !found) {\n\t\t\tast_log(LOG_WARNING, \"No more space\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tiaxs[x] = new_iax(sin, host);\n\t\tupdate_max_nontrunk();\n\t\tif (iaxs[x]) {\n\t\t\tif (iaxdebug)\n\t\t\t\tast_debug(1, \"Creating new call structure %d\\n\", x);\n\t\t\tiaxs[x]->sockfd = sockfd;\n\t\t\tiaxs[x]->addr.sin_port = sin->sin_port;\n\t\t\tiaxs[x]->addr.sin_family = sin->sin_family;\n\t\t\tiaxs[x]->addr.sin_addr.s_addr = sin->sin_addr.s_addr;\n\t\t\tiaxs[x]->peercallno = callno;\n\t\t\tiaxs[x]->callno = x;\n\t\t\tiaxs[x]->pingtime = DEFAULT_RETRY_TIME;\n\t\t\tiaxs[x]->expiry = min_reg_expire;\n\t\t\tiaxs[x]->pingid = iax2_sched_add(sched, ping_time * 1000, send_ping, (void *)(long)x);\n\t\t\tiaxs[x]->lagid = iax2_sched_add(sched, lagrq_time * 1000, send_lagrq, (void *)(long)x);\n\t\t\tiaxs[x]->amaflags = amaflags;\n\t\t\tast_copy_flags(iaxs[x], (&globalflags), IAX_NOTRANSFER | IAX_TRANSFERMEDIA | IAX_USEJITTERBUF | IAX_FORCEJITTERBUF);\n\t\t\t\n\t\t\tast_string_field_set(iaxs[x], accountcode, accountcode);\n\t\t\tast_string_field_set(iaxs[x], mohinterpret, mohinterpret);\n\t\t\tast_string_field_set(iaxs[x], mohsuggest, mohsuggest);\n\t\t\tast_string_field_set(iaxs[x], parkinglot, default_parkinglot);\n\t\t} else {\n\t\t\tast_log(LOG_WARNING, \"Out of resources\\n\");\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\t\treturn 0;\n\t\t}\n\t\tif (!return_locked)\n\t\t\tast_mutex_unlock(&iaxsl[x]);\n\t\tres = x;\n\t}\n\treturn res;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,4 @@\n-static int __find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int return_locked)\n+static int __find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int return_locked, int full_frame)\n {\n \tint res = 0;\n \tint x;\n@@ -10,7 +10,7 @@\n \t\t\tast_mutex_lock(&iaxsl[x]);\n \t\t\tif (iaxs[x]) {\n \t\t\t\t/* Look for an exact match */\n-\t\t\t\tif (match(sin, callno, dcallno, iaxs[x])) {\n+\t\t\t\tif (match(sin, callno, dcallno, iaxs[x], full_frame)) {\n \t\t\t\t\tres = x;\n \t\t\t\t}\n \t\t\t}\n@@ -20,7 +20,7 @@\n \t\t\tast_mutex_lock(&iaxsl[x]);\n \t\t\tif (iaxs[x]) {\n \t\t\t\t/* Look for an exact match */\n-\t\t\t\tif (match(sin, callno, dcallno, iaxs[x])) {\n+\t\t\t\tif (match(sin, callno, dcallno, iaxs[x], full_frame)) {\n \t\t\t\t\tres = x;\n \t\t\t\t}\n \t\t\t}\n@@ -28,6 +28,8 @@\n \t\t}\n \t}\n \tif ((res < 1) && (new >= NEW_ALLOW)) {\n+\t\tint start, found = 0;\n+\n \t\t/* It may seem odd that we look through the peer list for a name for\n \t\t * this *incoming* call.  Well, it is weird.  However, users don't\n \t\t * have an IP address/port number that we can match against.  So,\n@@ -36,15 +38,29 @@\n \t\t * correct, but it will be changed if needed after authentication. */\n \t\tif (!iax2_getpeername(*sin, host, sizeof(host)))\n \t\t\tsnprintf(host, sizeof(host), \"%s:%d\", ast_inet_ntoa(sin->sin_addr), ntohs(sin->sin_port));\n+\n \t\tnow = ast_tvnow();\n-\t\tfor (x=1;x<TRUNK_CALL_START;x++) {\n+\t\tstart = 1 + (ast_random() % (TRUNK_CALL_START - 1));\n+\t\tfor (x = start; 1; x++) {\n+\t\t\tif (x == TRUNK_CALL_START) {\n+\t\t\t\tx = 0;\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\n \t\t\t/* Find first unused call number that hasn't been used in a while */\n \t\t\tast_mutex_lock(&iaxsl[x]);\n-\t\t\tif (!iaxs[x] && ((now.tv_sec - lastused[x].tv_sec) > MIN_REUSE_TIME)) break;\n+\t\t\tif (!iaxs[x] && ((now.tv_sec - lastused[x].tv_sec) > MIN_REUSE_TIME)) {\n+\t\t\t\tfound = 1;\n+\t\t\t\tbreak;\n+\t\t\t}\n \t\t\tast_mutex_unlock(&iaxsl[x]);\n+\t\t\t\n+\t\t\tif (x == start - 1) {\n+\t\t\t\tbreak;\n+\t\t\t}\n \t\t}\n \t\t/* We've still got lock held if we found a spot */\n-\t\tif (x >= TRUNK_CALL_START) {\n+\t\tif (x == start - 1 && !found) {\n \t\t\tast_log(LOG_WARNING, \"No more space\\n\");\n \t\t\treturn 0;\n \t\t}",
        "diff_line_info": {
            "deleted_lines": [
                "static int __find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int return_locked)",
                "\t\t\t\tif (match(sin, callno, dcallno, iaxs[x])) {",
                "\t\t\t\tif (match(sin, callno, dcallno, iaxs[x])) {",
                "\t\tfor (x=1;x<TRUNK_CALL_START;x++) {",
                "\t\t\tif (!iaxs[x] && ((now.tv_sec - lastused[x].tv_sec) > MIN_REUSE_TIME)) break;",
                "\t\tif (x >= TRUNK_CALL_START) {"
            ],
            "added_lines": [
                "static int __find_callno(unsigned short callno, unsigned short dcallno, struct sockaddr_in *sin, int new, int sockfd, int return_locked, int full_frame)",
                "\t\t\t\tif (match(sin, callno, dcallno, iaxs[x], full_frame)) {",
                "\t\t\t\tif (match(sin, callno, dcallno, iaxs[x], full_frame)) {",
                "\t\tint start, found = 0;",
                "",
                "",
                "\t\tstart = 1 + (ast_random() % (TRUNK_CALL_START - 1));",
                "\t\tfor (x = start; 1; x++) {",
                "\t\t\tif (x == TRUNK_CALL_START) {",
                "\t\t\t\tx = 0;",
                "\t\t\t\tcontinue;",
                "\t\t\t}",
                "",
                "\t\t\tif (!iaxs[x] && ((now.tv_sec - lastused[x].tv_sec) > MIN_REUSE_TIME)) {",
                "\t\t\t\tfound = 1;",
                "\t\t\t\tbreak;",
                "\t\t\t}",
                "\t\t\t",
                "\t\t\tif (x == start - 1) {",
                "\t\t\t\tbreak;",
                "\t\t\t}",
                "\t\tif (x == start - 1 && !found) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2008-1948",
        "func_name": "gnutls/_gnutls_server_name_recv_params",
        "description": "The _gnutls_server_name_recv_params function in lib/ext_server_name.c in libgnutls in gnutls-serv in GnuTLS before 2.2.4 does not properly calculate the number of Server Names in a TLS 1.0 Client Hello message during extension handling, which allows remote attackers to cause a denial of service (crash) or possibly execute arbitrary code via a zero value for the length of Server Names, which leads to a buffer overflow in session resumption data in the pack_security_parameters function, aka GNUTLS-SA-2008-1-1.",
        "git_url": "http://git.savannah.gnu.org/gitweb/?p=gnutls.git;a=commit;h=bc8102405fda11ea00ca3b42acc4f4bce9d6e97b",
        "commit_title": "",
        "commit_text": "Fix GNUTLS-SA-2008-1 security vulnerabilities. See http://www.gnu.org/software/gnutls/security.html for updates. ",
        "func_before": "int\n_gnutls_server_name_recv_params (gnutls_session_t session,\n\t\t\t\t const opaque * data, size_t _data_size)\n{\n  int i;\n  const unsigned char *p;\n  uint16_t len, type;\n  ssize_t data_size = _data_size;\n  int server_names = 0;\n\n  if (session->security_parameters.entity == GNUTLS_SERVER)\n    {\n      DECR_LENGTH_RET (data_size, 2, 0);\n      len = _gnutls_read_uint16 (data);\n\n      if (len != data_size)\n\t{\n\t  /* This is unexpected packet length, but\n\t   * just ignore it, for now.\n\t   */\n\t  gnutls_assert ();\n\t  return 0;\n\t}\n\n      p = data + 2;\n\n      /* Count all server_names in the packet. */\n      while (data_size > 0)\n\t{\n\t  DECR_LENGTH_RET (data_size, 1, 0);\n\t  p++;\n\n\t  DECR_LEN (data_size, 2);\n\t  len = _gnutls_read_uint16 (p);\n\t  p += 2;\n\n\t  DECR_LENGTH_RET (data_size, len, 0);\n\t  server_names++;\n\n\t  p += len;\n\t}\n\n      session->security_parameters.extensions.server_names_size =\n\tserver_names;\n      if (server_names == 0)\n\treturn 0;\t\t/* no names found */\n\n      /* we cannot accept more server names.\n       */\n      if (server_names > MAX_SERVER_NAME_EXTENSIONS)\n\tserver_names = MAX_SERVER_NAME_EXTENSIONS;\n\n      p = data + 2;\n      for (i = 0; i < server_names; i++)\n\t{\n\t  type = *p;\n\t  p++;\n\n\t  len = _gnutls_read_uint16 (p);\n\t  p += 2;\n\n\t  switch (type)\n\t    {\n\t    case 0:\t\t/* NAME_DNS */\n\t      if (len <= MAX_SERVER_NAME_SIZE)\n\t\t{\n\t\t  memcpy (session->security_parameters.extensions.\n\t\t\t  server_names[i].name, p, len);\n\t\t  session->security_parameters.extensions.\n\t\t    server_names[i].name_length = len;\n\t\t  session->security_parameters.extensions.\n\t\t    server_names[i].type = GNUTLS_NAME_DNS;\n\t\t  break;\n\t\t}\n\t    }\n\n\t  /* move to next record */\n\t  p += len;\n\t}\n    }\n  return 0;\n}",
        "func": "int\n_gnutls_server_name_recv_params (gnutls_session_t session,\n\t\t\t\t const opaque * data, size_t _data_size)\n{\n  int i;\n  const unsigned char *p;\n  uint16_t len, type;\n  ssize_t data_size = _data_size;\n  int server_names = 0;\n\n  if (session->security_parameters.entity == GNUTLS_SERVER)\n    {\n      DECR_LENGTH_RET (data_size, 2, 0);\n      len = _gnutls_read_uint16 (data);\n\n      if (len != data_size)\n\t{\n\t  /* This is unexpected packet length, but\n\t   * just ignore it, for now.\n\t   */\n\t  gnutls_assert ();\n\t  return 0;\n\t}\n\n      p = data + 2;\n\n      /* Count all server_names in the packet. */\n      while (data_size > 0)\n\t{\n\t  DECR_LENGTH_RET (data_size, 1, 0);\n\t  p++;\n\n\t  DECR_LEN (data_size, 2);\n\t  len = _gnutls_read_uint16 (p);\n\t  p += 2;\n\n\t  if (len > 0)\n\t    {\n\t      DECR_LENGTH_RET (data_size, len, 0);\n\t      server_names++;\n\t      p += len;\n\t    }\n\t  else\n\t    _gnutls_handshake_log\n\t      (\"HSK[%x]: Received zero size server name (under attack?)\\n\",\n\t       session);\n\n\t}\n\n      /* we cannot accept more server names.\n       */\n      if (server_names > MAX_SERVER_NAME_EXTENSIONS)\n\t{\n\t  _gnutls_handshake_log\n\t    (\"HSK[%x]: Too many server names received (under attack?)\\n\",\n\t     session);\n\t  server_names = MAX_SERVER_NAME_EXTENSIONS;\n\t}\n\n      session->security_parameters.extensions.server_names_size =\n\tserver_names;\n      if (server_names == 0)\n\treturn 0;\t\t/* no names found */\n\n\n      p = data + 2;\n      for (i = 0; i < server_names; i++)\n\t{\n\t  type = *p;\n\t  p++;\n\n\t  len = _gnutls_read_uint16 (p);\n\t  p += 2;\n\n\t  switch (type)\n\t    {\n\t    case 0:\t\t/* NAME_DNS */\n\t      if (len <= MAX_SERVER_NAME_SIZE)\n\t\t{\n\t\t  memcpy (session->security_parameters.extensions.\n\t\t\t  server_names[i].name, p, len);\n\t\t  session->security_parameters.extensions.\n\t\t    server_names[i].name_length = len;\n\t\t  session->security_parameters.extensions.\n\t\t    server_names[i].type = GNUTLS_NAME_DNS;\n\t\t  break;\n\t\t}\n\t    }\n\n\t  /* move to next record */\n\t  p += len;\n\t}\n    }\n  return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -34,10 +34,27 @@\n \t  len = _gnutls_read_uint16 (p);\n \t  p += 2;\n \n-\t  DECR_LENGTH_RET (data_size, len, 0);\n-\t  server_names++;\n+\t  if (len > 0)\n+\t    {\n+\t      DECR_LENGTH_RET (data_size, len, 0);\n+\t      server_names++;\n+\t      p += len;\n+\t    }\n+\t  else\n+\t    _gnutls_handshake_log\n+\t      (\"HSK[%x]: Received zero size server name (under attack?)\\n\",\n+\t       session);\n \n-\t  p += len;\n+\t}\n+\n+      /* we cannot accept more server names.\n+       */\n+      if (server_names > MAX_SERVER_NAME_EXTENSIONS)\n+\t{\n+\t  _gnutls_handshake_log\n+\t    (\"HSK[%x]: Too many server names received (under attack?)\\n\",\n+\t     session);\n+\t  server_names = MAX_SERVER_NAME_EXTENSIONS;\n \t}\n \n       session->security_parameters.extensions.server_names_size =\n@@ -45,10 +62,6 @@\n       if (server_names == 0)\n \treturn 0;\t\t/* no names found */\n \n-      /* we cannot accept more server names.\n-       */\n-      if (server_names > MAX_SERVER_NAME_EXTENSIONS)\n-\tserver_names = MAX_SERVER_NAME_EXTENSIONS;\n \n       p = data + 2;\n       for (i = 0; i < server_names; i++)",
        "diff_line_info": {
            "deleted_lines": [
                "\t  DECR_LENGTH_RET (data_size, len, 0);",
                "\t  server_names++;",
                "\t  p += len;",
                "      /* we cannot accept more server names.",
                "       */",
                "      if (server_names > MAX_SERVER_NAME_EXTENSIONS)",
                "\tserver_names = MAX_SERVER_NAME_EXTENSIONS;"
            ],
            "added_lines": [
                "\t  if (len > 0)",
                "\t    {",
                "\t      DECR_LENGTH_RET (data_size, len, 0);",
                "\t      server_names++;",
                "\t      p += len;",
                "\t    }",
                "\t  else",
                "\t    _gnutls_handshake_log",
                "\t      (\"HSK[%x]: Received zero size server name (under attack?)\\n\",",
                "\t       session);",
                "\t}",
                "",
                "      /* we cannot accept more server names.",
                "       */",
                "      if (server_names > MAX_SERVER_NAME_EXTENSIONS)",
                "\t{",
                "\t  _gnutls_handshake_log",
                "\t    (\"HSK[%x]: Too many server names received (under attack?)\\n\",",
                "\t     session);",
                "\t  server_names = MAX_SERVER_NAME_EXTENSIONS;"
            ]
        }
    },
    {
        "cve_id": "CVE-2008-1948",
        "func_name": "gnutls/_gnutls_ciphertext2compressed",
        "description": "The _gnutls_server_name_recv_params function in lib/ext_server_name.c in libgnutls in gnutls-serv in GnuTLS before 2.2.4 does not properly calculate the number of Server Names in a TLS 1.0 Client Hello message during extension handling, which allows remote attackers to cause a denial of service (crash) or possibly execute arbitrary code via a zero value for the length of Server Names, which leads to a buffer overflow in session resumption data in the pack_security_parameters function, aka GNUTLS-SA-2008-1-1.",
        "git_url": "http://git.savannah.gnu.org/gitweb/?p=gnutls.git;a=commit;h=bc8102405fda11ea00ca3b42acc4f4bce9d6e97b",
        "commit_title": "",
        "commit_text": "Fix GNUTLS-SA-2008-1 security vulnerabilities. See http://www.gnu.org/software/gnutls/security.html for updates. ",
        "func_before": "int\n_gnutls_ciphertext2compressed (gnutls_session_t session,\n\t\t\t       opaque * compress_data,\n\t\t\t       int compress_size,\n\t\t\t       gnutls_datum_t ciphertext, uint8_t type)\n{\n  uint8_t MAC[MAX_HASH_SIZE];\n  uint16_t c_length;\n  uint8_t pad;\n  int length;\n  digest_hd_st td;\n  uint16_t blocksize;\n  int ret, i, pad_failed = 0;\n  uint8_t major, minor;\n  gnutls_protocol_t ver;\n  int hash_size =\n    _gnutls_hash_get_algo_len (session->security_parameters.\n\t\t\t       read_mac_algorithm);\n\n  ver = gnutls_protocol_get_version (session);\n  minor = _gnutls_version_get_minor (ver);\n  major = _gnutls_version_get_major (ver);\n\n  blocksize = _gnutls_cipher_get_block_size (session->security_parameters.\n\t\t\t\t\t     read_bulk_cipher_algorithm);\n\n  /* initialize MAC \n   */\n  ret = mac_init (&td, session->security_parameters.read_mac_algorithm,\n\t\t session->connection_state.read_mac_secret.data,\n\t\t session->connection_state.read_mac_secret.size, ver);\n\n  if (ret < 0\n      && session->security_parameters.read_mac_algorithm != GNUTLS_MAC_NULL)\n    {\n      gnutls_assert ();\n      return GNUTLS_E_INTERNAL_ERROR;\n    }\n\n\n  /* actual decryption (inplace)\n   */\n  switch (_gnutls_cipher_is_block\n\t  (session->security_parameters.read_bulk_cipher_algorithm))\n    {\n    case CIPHER_STREAM:\n      if ((ret = _gnutls_cipher_decrypt (&session->connection_state.\n\t\t\t\t\t read_cipher_state,\n\t\t\t\t\t ciphertext.data,\n\t\t\t\t\t ciphertext.size)) < 0)\n\t{\n\t  gnutls_assert ();\n\t  return ret;\n\t}\n\n      length = ciphertext.size - hash_size;\n\n      break;\n    case CIPHER_BLOCK:\n      if ((ciphertext.size < blocksize) || (ciphertext.size % blocksize != 0))\n\t{\n\t  gnutls_assert ();\n\t  return GNUTLS_E_DECRYPTION_FAILED;\n\t}\n\n      if ((ret = _gnutls_cipher_decrypt (&session->connection_state.\n\t\t\t\t\t read_cipher_state,\n\t\t\t\t\t ciphertext.data,\n\t\t\t\t\t ciphertext.size)) < 0)\n\t{\n\t  gnutls_assert ();\n\t  return ret;\n\t}\n\n      /* ignore the IV in TLS 1.1.\n       */\n      if (session->security_parameters.version >= GNUTLS_TLS1_1)\n\t{\n\t  ciphertext.size -= blocksize;\n\t  ciphertext.data += blocksize;\n\n\t  if (ciphertext.size == 0)\n\t    {\n\t      gnutls_assert ();\n\t      return GNUTLS_E_DECRYPTION_FAILED;\n\t    }\n\t}\n\n      pad = ciphertext.data[ciphertext.size - 1] + 1;\t/* pad */\n\n      length = ciphertext.size - hash_size - pad;\n\n      if (pad > ciphertext.size - hash_size)\n\t{\n\t  gnutls_assert ();\n\t  /* We do not fail here. We check below for the\n\t   * the pad_failed. If zero means success.\n\t   */\n\t  pad_failed = GNUTLS_E_DECRYPTION_FAILED;\n\t}\n\n      /* Check the pading bytes (TLS 1.x)\n       */\n      if (ver >= GNUTLS_TLS1 && pad_failed == 0)\n\tfor (i = 2; i < pad; i++)\n\t  {\n\t    if (ciphertext.data[ciphertext.size - i] !=\n\t\tciphertext.data[ciphertext.size - 1])\n\t      pad_failed = GNUTLS_E_DECRYPTION_FAILED;\n\t  }\n      break;\n    default:\n      gnutls_assert ();\n      return GNUTLS_E_INTERNAL_ERROR;\n    }\n\n  if (length < 0)\n    length = 0;\n  c_length = _gnutls_conv_uint16 ((uint16_t) length);\n\n  /* Pass the type, version, length and compressed through\n   * MAC.\n   */\n  if (session->security_parameters.read_mac_algorithm != GNUTLS_MAC_NULL)\n    {\n      _gnutls_hmac (&td,\n\t\t    UINT64DATA (session->connection_state.\n\t\t\t\tread_sequence_number), 8);\n\n      _gnutls_hmac (&td, &type, 1);\n      if (ver >= GNUTLS_TLS1)\n\t{\t\t\t/* TLS 1.x */\n\t  _gnutls_hmac (&td, &major, 1);\n\t  _gnutls_hmac (&td, &minor, 1);\n\t}\n      _gnutls_hmac (&td, &c_length, 2);\n\n      if (length > 0)\n\t_gnutls_hmac (&td, ciphertext.data, length);\n\n      mac_deinit (&td, MAC, ver);\n    }\n\n  /* This one was introduced to avoid a timing attack against the TLS\n   * 1.0 protocol.\n   */\n  if (pad_failed != 0)\n    return pad_failed;\n\n  /* HMAC was not the same. \n   */\n  if (memcmp (MAC, &ciphertext.data[length], hash_size) != 0)\n    {\n      gnutls_assert ();\n      return GNUTLS_E_DECRYPTION_FAILED;\n    }\n\n  /* copy the decrypted stuff to compress_data.\n   */\n  if (compress_size < length)\n    {\n      gnutls_assert ();\n      return GNUTLS_E_DECOMPRESSION_FAILED;\n    }\n  memcpy (compress_data, ciphertext.data, length);\n\n  return length;\n}",
        "func": "int\n_gnutls_ciphertext2compressed (gnutls_session_t session,\n\t\t\t       opaque * compress_data,\n\t\t\t       int compress_size,\n\t\t\t       gnutls_datum_t ciphertext, uint8_t type)\n{\n  uint8_t MAC[MAX_HASH_SIZE];\n  uint16_t c_length;\n  uint8_t pad;\n  int length;\n  digest_hd_st td;\n  uint16_t blocksize;\n  int ret, i, pad_failed = 0;\n  uint8_t major, minor;\n  gnutls_protocol_t ver;\n  int hash_size =\n    _gnutls_hash_get_algo_len (session->security_parameters.\n\t\t\t       read_mac_algorithm);\n\n  ver = gnutls_protocol_get_version (session);\n  minor = _gnutls_version_get_minor (ver);\n  major = _gnutls_version_get_major (ver);\n\n  blocksize = _gnutls_cipher_get_block_size (session->security_parameters.\n\t\t\t\t\t     read_bulk_cipher_algorithm);\n\n  /* initialize MAC \n   */\n  ret = mac_init (&td, session->security_parameters.read_mac_algorithm,\n\t\t session->connection_state.read_mac_secret.data,\n\t\t session->connection_state.read_mac_secret.size, ver);\n\n  if (ret < 0\n      && session->security_parameters.read_mac_algorithm != GNUTLS_MAC_NULL)\n    {\n      gnutls_assert ();\n      return GNUTLS_E_INTERNAL_ERROR;\n    }\n\n  if (ciphertext.size < (unsigned) blocksize + hash_size)\n    {\n      _gnutls_record_log\n\t(\"REC[%x]: Short record length %d < %d + %d (under attack?)\\n\",\n\t session, ciphertext.size, blocksize, hash_size);\n      gnutls_assert ();\n      return GNUTLS_E_DECRYPTION_FAILED;\n    }\n\n  /* actual decryption (inplace)\n   */\n  switch (_gnutls_cipher_is_block\n\t  (session->security_parameters.read_bulk_cipher_algorithm))\n    {\n    case CIPHER_STREAM:\n      if ((ret = _gnutls_cipher_decrypt (&session->connection_state.\n\t\t\t\t\t read_cipher_state,\n\t\t\t\t\t ciphertext.data,\n\t\t\t\t\t ciphertext.size)) < 0)\n\t{\n\t  gnutls_assert ();\n\t  return ret;\n\t}\n\n      length = ciphertext.size - hash_size;\n\n      break;\n    case CIPHER_BLOCK:\n      if ((ciphertext.size < blocksize) || (ciphertext.size % blocksize != 0))\n\t{\n\t  gnutls_assert ();\n\t  return GNUTLS_E_DECRYPTION_FAILED;\n\t}\n\n      if ((ret = _gnutls_cipher_decrypt (&session->connection_state.\n\t\t\t\t\t read_cipher_state,\n\t\t\t\t\t ciphertext.data,\n\t\t\t\t\t ciphertext.size)) < 0)\n\t{\n\t  gnutls_assert ();\n\t  return ret;\n\t}\n\n      /* ignore the IV in TLS 1.1.\n       */\n      if (session->security_parameters.version >= GNUTLS_TLS1_1)\n\t{\n\t  ciphertext.size -= blocksize;\n\t  ciphertext.data += blocksize;\n\n\t  if (ciphertext.size == 0)\n\t    {\n\t      gnutls_assert ();\n\t      return GNUTLS_E_DECRYPTION_FAILED;\n\t    }\n\t}\n\n      pad = ciphertext.data[ciphertext.size - 1] + 1;\t/* pad */\n\n      if ((int)pad > (int)ciphertext.size - hash_size)\n\t{\n\t  gnutls_assert ();\n\t  /* We do not fail here. We check below for the\n\t   * the pad_failed. If zero means success.\n\t   */\n\t  pad_failed = GNUTLS_E_DECRYPTION_FAILED;\n\t}\n\n      length = ciphertext.size - hash_size - pad;\n\n      /* Check the pading bytes (TLS 1.x)\n       */\n      if (ver >= GNUTLS_TLS1 && pad_failed == 0)\n\tfor (i = 2; i < pad; i++)\n\t  {\n\t    if (ciphertext.data[ciphertext.size - i] !=\n\t\tciphertext.data[ciphertext.size - 1])\n\t      pad_failed = GNUTLS_E_DECRYPTION_FAILED;\n\t  }\n      break;\n    default:\n      gnutls_assert ();\n      return GNUTLS_E_INTERNAL_ERROR;\n    }\n\n  if (length < 0)\n    length = 0;\n  c_length = _gnutls_conv_uint16 ((uint16_t) length);\n\n  /* Pass the type, version, length and compressed through\n   * MAC.\n   */\n  if (session->security_parameters.read_mac_algorithm != GNUTLS_MAC_NULL)\n    {\n      _gnutls_hmac (&td,\n\t\t    UINT64DATA (session->connection_state.\n\t\t\t\tread_sequence_number), 8);\n\n      _gnutls_hmac (&td, &type, 1);\n      if (ver >= GNUTLS_TLS1)\n\t{\t\t\t/* TLS 1.x */\n\t  _gnutls_hmac (&td, &major, 1);\n\t  _gnutls_hmac (&td, &minor, 1);\n\t}\n      _gnutls_hmac (&td, &c_length, 2);\n\n      if (length > 0)\n\t_gnutls_hmac (&td, ciphertext.data, length);\n\n      mac_deinit (&td, MAC, ver);\n    }\n\n  /* This one was introduced to avoid a timing attack against the TLS\n   * 1.0 protocol.\n   */\n  if (pad_failed != 0)\n    return pad_failed;\n\n  /* HMAC was not the same. \n   */\n  if (memcmp (MAC, &ciphertext.data[length], hash_size) != 0)\n    {\n      gnutls_assert ();\n      return GNUTLS_E_DECRYPTION_FAILED;\n    }\n\n  /* copy the decrypted stuff to compress_data.\n   */\n  if (compress_size < length)\n    {\n      gnutls_assert ();\n      return GNUTLS_E_DECOMPRESSION_FAILED;\n    }\n  memcpy (compress_data, ciphertext.data, length);\n\n  return length;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -37,6 +37,14 @@\n       return GNUTLS_E_INTERNAL_ERROR;\n     }\n \n+  if (ciphertext.size < (unsigned) blocksize + hash_size)\n+    {\n+      _gnutls_record_log\n+\t(\"REC[%x]: Short record length %d < %d + %d (under attack?)\\n\",\n+\t session, ciphertext.size, blocksize, hash_size);\n+      gnutls_assert ();\n+      return GNUTLS_E_DECRYPTION_FAILED;\n+    }\n \n   /* actual decryption (inplace)\n    */\n@@ -88,9 +96,7 @@\n \n       pad = ciphertext.data[ciphertext.size - 1] + 1;\t/* pad */\n \n-      length = ciphertext.size - hash_size - pad;\n-\n-      if (pad > ciphertext.size - hash_size)\n+      if ((int)pad > (int)ciphertext.size - hash_size)\n \t{\n \t  gnutls_assert ();\n \t  /* We do not fail here. We check below for the\n@@ -98,6 +104,8 @@\n \t   */\n \t  pad_failed = GNUTLS_E_DECRYPTION_FAILED;\n \t}\n+\n+      length = ciphertext.size - hash_size - pad;\n \n       /* Check the pading bytes (TLS 1.x)\n        */",
        "diff_line_info": {
            "deleted_lines": [
                "      length = ciphertext.size - hash_size - pad;",
                "",
                "      if (pad > ciphertext.size - hash_size)"
            ],
            "added_lines": [
                "  if (ciphertext.size < (unsigned) blocksize + hash_size)",
                "    {",
                "      _gnutls_record_log",
                "\t(\"REC[%x]: Short record length %d < %d + %d (under attack?)\\n\",",
                "\t session, ciphertext.size, blocksize, hash_size);",
                "      gnutls_assert ();",
                "      return GNUTLS_E_DECRYPTION_FAILED;",
                "    }",
                "      if ((int)pad > (int)ciphertext.size - hash_size)",
                "",
                "      length = ciphertext.size - hash_size - pad;"
            ]
        }
    },
    {
        "cve_id": "CVE-2008-1948",
        "func_name": "gnutls/_gnutls_recv_handshake_header",
        "description": "The _gnutls_server_name_recv_params function in lib/ext_server_name.c in libgnutls in gnutls-serv in GnuTLS before 2.2.4 does not properly calculate the number of Server Names in a TLS 1.0 Client Hello message during extension handling, which allows remote attackers to cause a denial of service (crash) or possibly execute arbitrary code via a zero value for the length of Server Names, which leads to a buffer overflow in session resumption data in the pack_security_parameters function, aka GNUTLS-SA-2008-1-1.",
        "git_url": "http://git.savannah.gnu.org/gitweb/?p=gnutls.git;a=commit;h=bc8102405fda11ea00ca3b42acc4f4bce9d6e97b",
        "commit_title": "",
        "commit_text": "Fix GNUTLS-SA-2008-1 security vulnerabilities. See http://www.gnu.org/software/gnutls/security.html for updates. ",
        "func_before": "static int\n_gnutls_recv_handshake_header (gnutls_session_t session,\n\t\t\t       gnutls_handshake_description_t type,\n\t\t\t       gnutls_handshake_description_t * recv_type)\n{\n  int ret;\n  uint32_t length32 = 0;\n  uint8_t *dataptr = NULL;\t/* for realloc */\n  size_t handshake_header_size = HANDSHAKE_HEADER_SIZE;\n\n  /* if we have data into the buffer then return them, do not read the next packet.\n   * In order to return we need a full TLS handshake header, or in case of a version 2\n   * packet, then we return the first byte.\n   */\n  if (session->internals.handshake_header_buffer.header_size ==\n      handshake_header_size || (session->internals.v2_hello != 0\n\t\t\t\t&& type == GNUTLS_HANDSHAKE_CLIENT_HELLO\n\t\t\t\t&& session->internals.\n\t\t\t\thandshake_header_buffer.packet_length > 0))\n    {\n\n      *recv_type = session->internals.handshake_header_buffer.recv_type;\n\n      return session->internals.handshake_header_buffer.packet_length;\n    }\n\n  /* Note: SSL2_HEADERS == 1 */\n\n  dataptr = session->internals.handshake_header_buffer.header;\n\n  /* If we haven't already read the handshake headers.\n   */\n  if (session->internals.handshake_header_buffer.header_size < SSL2_HEADERS)\n    {\n      ret =\n\t_gnutls_handshake_io_recv_int (session, GNUTLS_HANDSHAKE,\n\t\t\t\t       type, dataptr, SSL2_HEADERS);\n\n      if (ret < 0)\n\t{\n\t  gnutls_assert ();\n\t  return ret;\n\t}\n\n      /* The case ret==0 is caught here.\n       */\n      if (ret != SSL2_HEADERS)\n\t{\n\t  gnutls_assert ();\n\t  return GNUTLS_E_UNEXPECTED_PACKET_LENGTH;\n\t}\n      session->internals.handshake_header_buffer.header_size = SSL2_HEADERS;\n    }\n\n  if (session->internals.v2_hello == 0\n      || type != GNUTLS_HANDSHAKE_CLIENT_HELLO)\n    {\n      ret =\n\t_gnutls_handshake_io_recv_int (session, GNUTLS_HANDSHAKE,\n\t\t\t\t       type,\n\t\t\t\t       &dataptr[session->\n\t\t\t\t\t\tinternals.\n\t\t\t\t\t\thandshake_header_buffer.\n\t\t\t\t\t\theader_size],\n\t\t\t\t       HANDSHAKE_HEADER_SIZE -\n\t\t\t\t       session->internals.\n\t\t\t\t       handshake_header_buffer.header_size);\n      if (ret <= 0)\n\t{\n\t  gnutls_assert ();\n\t  return (ret < 0) ? ret : GNUTLS_E_UNEXPECTED_PACKET_LENGTH;\n\t}\n      if ((size_t) ret !=\n\t  HANDSHAKE_HEADER_SIZE -\n\t  session->internals.handshake_header_buffer.header_size)\n\t{\n\t  gnutls_assert ();\n\t  return GNUTLS_E_UNEXPECTED_PACKET_LENGTH;\n\t}\n      *recv_type = dataptr[0];\n\n      /* we do not use DECR_LEN because we know\n       * that the packet has enough data.\n       */\n      length32 = _gnutls_read_uint24 (&dataptr[1]);\n      handshake_header_size = HANDSHAKE_HEADER_SIZE;\n\n      _gnutls_handshake_log (\"HSK[%x]: %s was received [%ld bytes]\\n\",\n\t\t\t     session, _gnutls_handshake2str (dataptr[0]),\n\t\t\t     length32 + HANDSHAKE_HEADER_SIZE);\n\n    }\n  else\n    {\t\t\t\t/* v2 hello */\n      length32 = session->internals.v2_hello - SSL2_HEADERS;\t/* we've read the first byte */\n\n      handshake_header_size = SSL2_HEADERS;\t/* we've already read one byte */\n\n      *recv_type = dataptr[0];\n\n      _gnutls_handshake_log (\"HSK[%x]: %s(v2) was received [%ld bytes]\\n\",\n\t\t\t     session, _gnutls_handshake2str (*recv_type),\n\t\t\t     length32 + handshake_header_size);\n\n      if (*recv_type != GNUTLS_HANDSHAKE_CLIENT_HELLO)\n\t{\t\t\t/* it should be one or nothing */\n\t  gnutls_assert ();\n\t  return GNUTLS_E_UNEXPECTED_HANDSHAKE_PACKET;\n\t}\n    }\n\n  /* put the packet into the buffer */\n  session->internals.handshake_header_buffer.header_size =\n    handshake_header_size;\n  session->internals.handshake_header_buffer.packet_length = length32;\n  session->internals.handshake_header_buffer.recv_type = *recv_type;\n\n  if (*recv_type != type)\n    {\n      gnutls_assert ();\n      return GNUTLS_E_UNEXPECTED_HANDSHAKE_PACKET;\n    }\n\n  return length32;\n}",
        "func": "static int\n_gnutls_recv_handshake_header (gnutls_session_t session,\n\t\t\t       gnutls_handshake_description_t type,\n\t\t\t       gnutls_handshake_description_t * recv_type)\n{\n  int ret;\n  uint32_t length32 = 0;\n  uint8_t *dataptr = NULL;\t/* for realloc */\n  size_t handshake_header_size = HANDSHAKE_HEADER_SIZE;\n\n  /* if we have data into the buffer then return them, do not read the next packet.\n   * In order to return we need a full TLS handshake header, or in case of a version 2\n   * packet, then we return the first byte.\n   */\n  if (session->internals.handshake_header_buffer.header_size ==\n      handshake_header_size || (session->internals.v2_hello != 0\n\t\t\t\t&& type == GNUTLS_HANDSHAKE_CLIENT_HELLO\n\t\t\t\t&& session->internals.\n\t\t\t\thandshake_header_buffer.packet_length > 0))\n    {\n\n      *recv_type = session->internals.handshake_header_buffer.recv_type;\n\n      if (*recv_type != type)\n\t{\n\t  gnutls_assert ();\n\t  _gnutls_handshake_log\n\t    (\"HSK[%x]: Handshake type mismatch (under attack?)\\n\", session);\n\t  return GNUTLS_E_UNEXPECTED_HANDSHAKE_PACKET;\n\t}\n\n      return session->internals.handshake_header_buffer.packet_length;\n    }\n\n  /* Note: SSL2_HEADERS == 1 */\n\n  dataptr = session->internals.handshake_header_buffer.header;\n\n  /* If we haven't already read the handshake headers.\n   */\n  if (session->internals.handshake_header_buffer.header_size < SSL2_HEADERS)\n    {\n      ret =\n\t_gnutls_handshake_io_recv_int (session, GNUTLS_HANDSHAKE,\n\t\t\t\t       type, dataptr, SSL2_HEADERS);\n\n      if (ret < 0)\n\t{\n\t  gnutls_assert ();\n\t  return ret;\n\t}\n\n      /* The case ret==0 is caught here.\n       */\n      if (ret != SSL2_HEADERS)\n\t{\n\t  gnutls_assert ();\n\t  return GNUTLS_E_UNEXPECTED_PACKET_LENGTH;\n\t}\n      session->internals.handshake_header_buffer.header_size = SSL2_HEADERS;\n    }\n\n  if (session->internals.v2_hello == 0\n      || type != GNUTLS_HANDSHAKE_CLIENT_HELLO)\n    {\n      ret =\n\t_gnutls_handshake_io_recv_int (session, GNUTLS_HANDSHAKE,\n\t\t\t\t       type,\n\t\t\t\t       &dataptr[session->\n\t\t\t\t\t\tinternals.\n\t\t\t\t\t\thandshake_header_buffer.\n\t\t\t\t\t\theader_size],\n\t\t\t\t       HANDSHAKE_HEADER_SIZE -\n\t\t\t\t       session->internals.\n\t\t\t\t       handshake_header_buffer.header_size);\n      if (ret <= 0)\n\t{\n\t  gnutls_assert ();\n\t  return (ret < 0) ? ret : GNUTLS_E_UNEXPECTED_PACKET_LENGTH;\n\t}\n      if ((size_t) ret !=\n\t  HANDSHAKE_HEADER_SIZE -\n\t  session->internals.handshake_header_buffer.header_size)\n\t{\n\t  gnutls_assert ();\n\t  return GNUTLS_E_UNEXPECTED_PACKET_LENGTH;\n\t}\n      *recv_type = dataptr[0];\n\n      /* we do not use DECR_LEN because we know\n       * that the packet has enough data.\n       */\n      length32 = _gnutls_read_uint24 (&dataptr[1]);\n      handshake_header_size = HANDSHAKE_HEADER_SIZE;\n\n      _gnutls_handshake_log (\"HSK[%x]: %s was received [%ld bytes]\\n\",\n\t\t\t     session, _gnutls_handshake2str (dataptr[0]),\n\t\t\t     length32 + HANDSHAKE_HEADER_SIZE);\n\n    }\n  else\n    {\t\t\t\t/* v2 hello */\n      length32 = session->internals.v2_hello - SSL2_HEADERS;\t/* we've read the first byte */\n\n      handshake_header_size = SSL2_HEADERS;\t/* we've already read one byte */\n\n      *recv_type = dataptr[0];\n\n      _gnutls_handshake_log (\"HSK[%x]: %s(v2) was received [%ld bytes]\\n\",\n\t\t\t     session, _gnutls_handshake2str (*recv_type),\n\t\t\t     length32 + handshake_header_size);\n\n      if (*recv_type != GNUTLS_HANDSHAKE_CLIENT_HELLO)\n\t{\t\t\t/* it should be one or nothing */\n\t  gnutls_assert ();\n\t  return GNUTLS_E_UNEXPECTED_HANDSHAKE_PACKET;\n\t}\n    }\n\n  /* put the packet into the buffer */\n  session->internals.handshake_header_buffer.header_size =\n    handshake_header_size;\n  session->internals.handshake_header_buffer.packet_length = length32;\n  session->internals.handshake_header_buffer.recv_type = *recv_type;\n\n  if (*recv_type != type)\n    {\n      gnutls_assert ();\n      return GNUTLS_E_UNEXPECTED_HANDSHAKE_PACKET;\n    }\n\n  return length32;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -20,6 +20,14 @@\n     {\n \n       *recv_type = session->internals.handshake_header_buffer.recv_type;\n+\n+      if (*recv_type != type)\n+\t{\n+\t  gnutls_assert ();\n+\t  _gnutls_handshake_log\n+\t    (\"HSK[%x]: Handshake type mismatch (under attack?)\\n\", session);\n+\t  return GNUTLS_E_UNEXPECTED_HANDSHAKE_PACKET;\n+\t}\n \n       return session->internals.handshake_header_buffer.packet_length;\n     }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "      if (*recv_type != type)",
                "\t{",
                "\t  gnutls_assert ();",
                "\t  _gnutls_handshake_log",
                "\t    (\"HSK[%x]: Handshake type mismatch (under attack?)\\n\", session);",
                "\t  return GNUTLS_E_UNEXPECTED_HANDSHAKE_PACKET;",
                "\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2009-3623",
        "func_name": "torvalds/linux/lookup_cb_cred",
        "description": "The lookup_cb_cred function in fs/nfsd/nfs4callback.c in the nfsd4 subsystem in the Linux kernel before 2.6.31.2 attempts to access a credentials cache even when a client specifies the AUTH_NULL authentication flavor, which allows remote attackers to cause a denial of service (NULL pointer dereference and system crash) via an NFSv4 mount request.",
        "git_url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux.git;a=commit;h=886e3b7fe6054230c89ae078a09565ed183ecc73",
        "commit_title": "On setting up the callback to the client, we attempt to use the same",
        "commit_text": "authentication flavor the client did.  We find an rpc cred to use by calling rpcauth_lookup_credcache(), which assumes that the given authentication flavor has a credentials cache.  However, this is not required to be true--in particular, auth_null does not use one. Instead, we should call the auth's lookup_cred() method.  Without this, a client attempting to mount using nfsv4 and auth_null triggers a null dereference.  Cc: stable@kernel.org ",
        "func_before": "static struct rpc_cred *lookup_cb_cred(struct nfs4_cb_conn *cb)\n{\n\tstruct auth_cred acred = {\n\t\t.machine_cred = 1\n\t};\n\n\t/*\n\t * Note in the gss case this doesn't actually have to wait for a\n\t * gss upcall (or any calls to the client); this just creates a\n\t * non-uptodate cred which the rpc state machine will fill in with\n\t * a refresh_upcall later.\n\t */\n\treturn rpcauth_lookup_credcache(cb->cb_client->cl_auth, &acred,\n\t\t\t\t\t\t\tRPCAUTH_LOOKUP_NEW);\n}",
        "func": "static struct rpc_cred *lookup_cb_cred(struct nfs4_cb_conn *cb)\n{\n\tstruct auth_cred acred = {\n\t\t.machine_cred = 1\n\t};\n\tstruct rpc_auth *auth = cb->cb_client->cl_auth;\n\n\t/*\n\t * Note in the gss case this doesn't actually have to wait for a\n\t * gss upcall (or any calls to the client); this just creates a\n\t * non-uptodate cred which the rpc state machine will fill in with\n\t * a refresh_upcall later.\n\t */\n\treturn auth->au_ops->lookup_cred(auth, &acred, RPCAUTH_LOOKUP_NEW);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,6 +3,7 @@\n \tstruct auth_cred acred = {\n \t\t.machine_cred = 1\n \t};\n+\tstruct rpc_auth *auth = cb->cb_client->cl_auth;\n \n \t/*\n \t * Note in the gss case this doesn't actually have to wait for a\n@@ -10,6 +11,5 @@\n \t * non-uptodate cred which the rpc state machine will fill in with\n \t * a refresh_upcall later.\n \t */\n-\treturn rpcauth_lookup_credcache(cb->cb_client->cl_auth, &acred,\n-\t\t\t\t\t\t\tRPCAUTH_LOOKUP_NEW);\n+\treturn auth->au_ops->lookup_cred(auth, &acred, RPCAUTH_LOOKUP_NEW);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\treturn rpcauth_lookup_credcache(cb->cb_client->cl_auth, &acred,",
                "\t\t\t\t\t\t\tRPCAUTH_LOOKUP_NEW);"
            ],
            "added_lines": [
                "\tstruct rpc_auth *auth = cb->cb_client->cl_auth;",
                "\treturn auth->au_ops->lookup_cred(auth, &acred, RPCAUTH_LOOKUP_NEW);"
            ]
        }
    },
    {
        "cve_id": "CVE-2009-3623",
        "func_name": "torvalds/linux/__nfs4_state_start",
        "description": "The lookup_cb_cred function in fs/nfsd/nfs4callback.c in the nfsd4 subsystem in the Linux kernel before 2.6.31.2 attempts to access a credentials cache even when a client specifies the AUTH_NULL authentication flavor, which allows remote attackers to cause a denial of service (NULL pointer dereference and system crash) via an NFSv4 mount request.",
        "git_url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux.git;a=commit;h=80fc015bdfe1f5b870c1e1ee02d78e709523fee7",
        "commit_title": "Callbacks are always made using the machine's identity, so we can use a",
        "commit_text": "single auth_generic credential shared among callbacks to all clients and let the rpc code take care of the rest.  ",
        "func_before": "static int\n__nfs4_state_start(void)\n{\n\tunsigned long grace_time;\n\n\tboot_time = get_seconds();\n\tgrace_time = get_nfs4_grace_period();\n\tlease_time = user_lease_time;\n\tlocks_start_grace(&nfsd4_manager);\n\tprintk(KERN_INFO \"NFSD: starting %ld-second grace period\\n\",\n\t       grace_time/HZ);\n\tlaundry_wq = create_singlethread_workqueue(\"nfsd4\");\n\tif (laundry_wq == NULL)\n\t\treturn -ENOMEM;\n\tqueue_delayed_work(laundry_wq, &laundromat_work, grace_time);\n\tset_max_delegations();\n\treturn 0;\n}",
        "func": "static int\n__nfs4_state_start(void)\n{\n\tunsigned long grace_time;\n\n\tboot_time = get_seconds();\n\tgrace_time = get_nfs4_grace_period();\n\tlease_time = user_lease_time;\n\tlocks_start_grace(&nfsd4_manager);\n\tprintk(KERN_INFO \"NFSD: starting %ld-second grace period\\n\",\n\t       grace_time/HZ);\n\tlaundry_wq = create_singlethread_workqueue(\"nfsd4\");\n\tif (laundry_wq == NULL)\n\t\treturn -ENOMEM;\n\tqueue_delayed_work(laundry_wq, &laundromat_work, grace_time);\n\tset_max_delegations();\n\treturn set_callback_cred();\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -14,5 +14,5 @@\n \t\treturn -ENOMEM;\n \tqueue_delayed_work(laundry_wq, &laundromat_work, grace_time);\n \tset_max_delegations();\n-\treturn 0;\n+\treturn set_callback_cred();\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\treturn 0;"
            ],
            "added_lines": [
                "\treturn set_callback_cred();"
            ]
        }
    },
    {
        "cve_id": "CVE-2009-3623",
        "func_name": "torvalds/linux/shutdown_callback_client",
        "description": "The lookup_cb_cred function in fs/nfsd/nfs4callback.c in the nfsd4 subsystem in the Linux kernel before 2.6.31.2 attempts to access a credentials cache even when a client specifies the AUTH_NULL authentication flavor, which allows remote attackers to cause a denial of service (NULL pointer dereference and system crash) via an NFSv4 mount request.",
        "git_url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux.git;a=commit;h=80fc015bdfe1f5b870c1e1ee02d78e709523fee7",
        "commit_title": "Callbacks are always made using the machine's identity, so we can use a",
        "commit_text": "single auth_generic credential shared among callbacks to all clients and let the rpc code take care of the rest.  ",
        "func_before": "static void\nshutdown_callback_client(struct nfs4_client *clp)\n{\n\tstruct rpc_clnt *clnt = clp->cl_cb_conn.cb_client;\n\n\tif (clnt) {\n\t\t/*\n\t\t * Callback threads take a reference on the client, so there\n\t\t * should be no outstanding callbacks at this point.\n\t\t */\n\t\tclp->cl_cb_conn.cb_client = NULL;\n\t\trpc_shutdown_client(clnt);\n\t}\n\tif (clp->cl_cb_conn.cb_cred) {\n\t\tput_rpccred(clp->cl_cb_conn.cb_cred);\n\t\tclp->cl_cb_conn.cb_cred = NULL;\n\t}\n}",
        "func": "static void\nshutdown_callback_client(struct nfs4_client *clp)\n{\n\tstruct rpc_clnt *clnt = clp->cl_cb_conn.cb_client;\n\n\tif (clnt) {\n\t\t/*\n\t\t * Callback threads take a reference on the client, so there\n\t\t * should be no outstanding callbacks at this point.\n\t\t */\n\t\tclp->cl_cb_conn.cb_client = NULL;\n\t\trpc_shutdown_client(clnt);\n\t}\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -11,8 +11,4 @@\n \t\tclp->cl_cb_conn.cb_client = NULL;\n \t\trpc_shutdown_client(clnt);\n \t}\n-\tif (clp->cl_cb_conn.cb_cred) {\n-\t\tput_rpccred(clp->cl_cb_conn.cb_cred);\n-\t\tclp->cl_cb_conn.cb_cred = NULL;\n-\t}\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (clp->cl_cb_conn.cb_cred) {",
                "\t\tput_rpccred(clp->cl_cb_conn.cb_cred);",
                "\t\tclp->cl_cb_conn.cb_cred = NULL;",
                "\t}"
            ],
            "added_lines": []
        }
    },
    {
        "cve_id": "CVE-2009-3623",
        "func_name": "torvalds/linux/nfsd4_cb_recall",
        "description": "The lookup_cb_cred function in fs/nfsd/nfs4callback.c in the nfsd4 subsystem in the Linux kernel before 2.6.31.2 attempts to access a credentials cache even when a client specifies the AUTH_NULL authentication flavor, which allows remote attackers to cause a denial of service (NULL pointer dereference and system crash) via an NFSv4 mount request.",
        "git_url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux.git;a=commit;h=80fc015bdfe1f5b870c1e1ee02d78e709523fee7",
        "commit_title": "Callbacks are always made using the machine's identity, so we can use a",
        "commit_text": "single auth_generic credential shared among callbacks to all clients and let the rpc code take care of the rest.  ",
        "func_before": "void\nnfsd4_cb_recall(struct nfs4_delegation *dp)\n{\n\tstruct nfs4_client *clp = dp->dl_client;\n\tstruct rpc_clnt *clnt = clp->cl_cb_conn.cb_client;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_cb_procedures[NFSPROC4_CLNT_CB_RECALL],\n\t\t.rpc_argp = dp,\n\t\t.rpc_cred = clp->cl_cb_conn.cb_cred\n\t};\n\tint status;\n\n\tdp->dl_retries = 1;\n\tstatus = rpc_call_async(clnt, &msg, RPC_TASK_SOFT,\n\t\t\t\t&nfsd4_cb_recall_ops, dp);\n\tif (status) {\n\t\tput_nfs4_client(clp);\n\t\tnfs4_put_delegation(dp);\n\t}\n}",
        "func": "void\nnfsd4_cb_recall(struct nfs4_delegation *dp)\n{\n\tstruct nfs4_client *clp = dp->dl_client;\n\tstruct rpc_clnt *clnt = clp->cl_cb_conn.cb_client;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_cb_procedures[NFSPROC4_CLNT_CB_RECALL],\n\t\t.rpc_argp = dp,\n\t\t.rpc_cred = callback_cred\n\t};\n\tint status;\n\n\tdp->dl_retries = 1;\n\tstatus = rpc_call_async(clnt, &msg, RPC_TASK_SOFT,\n\t\t\t\t&nfsd4_cb_recall_ops, dp);\n\tif (status) {\n\t\tput_nfs4_client(clp);\n\t\tnfs4_put_delegation(dp);\n\t}\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,7 +6,7 @@\n \tstruct rpc_message msg = {\n \t\t.rpc_proc = &nfs4_cb_procedures[NFSPROC4_CLNT_CB_RECALL],\n \t\t.rpc_argp = dp,\n-\t\t.rpc_cred = clp->cl_cb_conn.cb_cred\n+\t\t.rpc_cred = callback_cred\n \t};\n \tint status;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t.rpc_cred = clp->cl_cb_conn.cb_cred"
            ],
            "added_lines": [
                "\t\t.rpc_cred = callback_cred"
            ]
        }
    },
    {
        "cve_id": "CVE-2009-3623",
        "func_name": "torvalds/linux/do_probe_callback",
        "description": "The lookup_cb_cred function in fs/nfsd/nfs4callback.c in the nfsd4 subsystem in the Linux kernel before 2.6.31.2 attempts to access a credentials cache even when a client specifies the AUTH_NULL authentication flavor, which allows remote attackers to cause a denial of service (NULL pointer dereference and system crash) via an NFSv4 mount request.",
        "git_url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux.git;a=commit;h=80fc015bdfe1f5b870c1e1ee02d78e709523fee7",
        "commit_title": "Callbacks are always made using the machine's identity, so we can use a",
        "commit_text": "single auth_generic credential shared among callbacks to all clients and let the rpc code take care of the rest.  ",
        "func_before": "void do_probe_callback(struct nfs4_client *clp)\n{\n\tstruct nfs4_cb_conn *cb = &clp->cl_cb_conn;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc       = &nfs4_cb_procedures[NFSPROC4_CLNT_CB_NULL],\n\t\t.rpc_argp       = clp,\n\t};\n\tstruct rpc_cred *cred;\n\tint status;\n\n\tcred = lookup_cb_cred(cb);\n\tif (IS_ERR(cred)) {\n\t\tstatus = PTR_ERR(cred);\n\t\tgoto out;\n\t}\n\tcb->cb_cred = cred;\n\tmsg.rpc_cred = cb->cb_cred;\n\tstatus = rpc_call_async(cb->cb_client, &msg, RPC_TASK_SOFT,\n\t\t\t\t&nfsd4_cb_probe_ops, (void *)clp);\nout:\n\tif (status) {\n\t\twarn_no_callback_path(clp, status);\n\t\tput_nfs4_client(clp);\n\t}\n}",
        "func": "void do_probe_callback(struct nfs4_client *clp)\n{\n\tstruct nfs4_cb_conn *cb = &clp->cl_cb_conn;\n\tstruct rpc_message msg = {\n\t\t.rpc_proc       = &nfs4_cb_procedures[NFSPROC4_CLNT_CB_NULL],\n\t\t.rpc_argp       = clp,\n\t\t.rpc_cred\t= callback_cred\n\t};\n\tint status;\n\n\tstatus = rpc_call_async(cb->cb_client, &msg, RPC_TASK_SOFT,\n\t\t\t\t&nfsd4_cb_probe_ops, (void *)clp);\n\tif (status) {\n\t\twarn_no_callback_path(clp, status);\n\t\tput_nfs4_client(clp);\n\t}\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,20 +4,12 @@\n \tstruct rpc_message msg = {\n \t\t.rpc_proc       = &nfs4_cb_procedures[NFSPROC4_CLNT_CB_NULL],\n \t\t.rpc_argp       = clp,\n+\t\t.rpc_cred\t= callback_cred\n \t};\n-\tstruct rpc_cred *cred;\n \tint status;\n \n-\tcred = lookup_cb_cred(cb);\n-\tif (IS_ERR(cred)) {\n-\t\tstatus = PTR_ERR(cred);\n-\t\tgoto out;\n-\t}\n-\tcb->cb_cred = cred;\n-\tmsg.rpc_cred = cb->cb_cred;\n \tstatus = rpc_call_async(cb->cb_client, &msg, RPC_TASK_SOFT,\n \t\t\t\t&nfsd4_cb_probe_ops, (void *)clp);\n-out:\n \tif (status) {\n \t\twarn_no_callback_path(clp, status);\n \t\tput_nfs4_client(clp);",
        "diff_line_info": {
            "deleted_lines": [
                "\tstruct rpc_cred *cred;",
                "\tcred = lookup_cb_cred(cb);",
                "\tif (IS_ERR(cred)) {",
                "\t\tstatus = PTR_ERR(cred);",
                "\t\tgoto out;",
                "\t}",
                "\tcb->cb_cred = cred;",
                "\tmsg.rpc_cred = cb->cb_cred;",
                "out:"
            ],
            "added_lines": [
                "\t\t.rpc_cred\t= callback_cred"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-52161",
        "func_name": "wireless/iwd/eapol_handle_ptk_4_of_4",
        "description": "The Access Point functionality in eapol_auth_key_handle in eapol.c in iNet wireless daemon (IWD) before 2.14 allows attackers to gain unauthorized access to a protected Wi-Fi network. An attacker can complete the EAPOL handshake by skipping Msg2/4 and instead sending Msg4/4 with an all-zero key.",
        "git_url": "https://git.kernel.org/pub/scm/network/wireless/iwd.git/commit/?h=6415420f1c92012f64063c131480ffcef58e60ca",
        "commit_title": "When operating as an AP, drop message 4 of the 4-way handshake if the AP",
        "commit_text": "has not yet received message 2. Otherwise an attacker can skip message 2 and immediately send message 4 to bypass authentication (the AP would be using an all-zero ptk to verify the authenticity of message 4). ",
        "func_before": "static void eapol_handle_ptk_4_of_4(struct eapol_sm *sm,\n\t\t\t\t\tconst struct eapol_key *ek)\n{\n\tconst uint8_t *kck;\n\n\tl_debug(\"ifindex=%u\", sm->handshake->ifindex);\n\n\tif (!eapol_verify_ptk_4_of_4(ek, false))\n\t\treturn;\n\n\tif (L_BE64_TO_CPU(ek->key_replay_counter) != sm->replay_counter)\n\t\treturn;\n\n\tkck = handshake_state_get_kck(sm->handshake);\n\n\tif (!eapol_verify_mic(sm->handshake->akm_suite, kck, ek,\n\t\t\t\tsm->mic_len))\n\t\treturn;\n\n\tl_timeout_remove(sm->timeout);\n\tsm->timeout = NULL;\n\n\t/*\n\t * If ptk_complete is set, then we are receiving Message 4 again.\n\t * This might be a retransmission, so accept but don't install\n\t * the keys again.\n\t */\n\tif (!sm->handshake->ptk_complete)\n\t\thandshake_state_install_ptk(sm->handshake);\n\n\tsm->handshake->ptk_complete = true;\n}",
        "func": "static void eapol_handle_ptk_4_of_4(struct eapol_sm *sm,\n\t\t\t\t\tconst struct eapol_key *ek)\n{\n\tconst uint8_t *kck;\n\n\tl_debug(\"ifindex=%u\", sm->handshake->ifindex);\n\n\tif (!eapol_verify_ptk_4_of_4(ek, false))\n\t\treturn;\n\n\tif (L_BE64_TO_CPU(ek->key_replay_counter) != sm->replay_counter)\n\t\treturn;\n\n\t/* Ensure we received Message 2 and thus have a PTK to verify MIC */\n\tif (!sm->handshake->have_snonce)\n\t\treturn;\n\n\tkck = handshake_state_get_kck(sm->handshake);\n\n\tif (!eapol_verify_mic(sm->handshake->akm_suite, kck, ek,\n\t\t\t\tsm->mic_len))\n\t\treturn;\n\n\tl_timeout_remove(sm->timeout);\n\tsm->timeout = NULL;\n\n\t/*\n\t * If ptk_complete is set, then we are receiving Message 4 again.\n\t * This might be a retransmission, so accept but don't install\n\t * the keys again.\n\t */\n\tif (!sm->handshake->ptk_complete)\n\t\thandshake_state_install_ptk(sm->handshake);\n\n\tsm->handshake->ptk_complete = true;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -9,6 +9,10 @@\n \t\treturn;\n \n \tif (L_BE64_TO_CPU(ek->key_replay_counter) != sm->replay_counter)\n+\t\treturn;\n+\n+\t/* Ensure we received Message 2 and thus have a PTK to verify MIC */\n+\tif (!sm->handshake->have_snonce)\n \t\treturn;\n \n \tkck = handshake_state_get_kck(sm->handshake);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\treturn;",
                "",
                "\t/* Ensure we received Message 2 and thus have a PTK to verify MIC */",
                "\tif (!sm->handshake->have_snonce)"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-28896",
        "func_name": "neomutt/imap_open_connection",
        "description": "Mutt before 2.0.2 and NeoMutt before 2020-11-20 did not ensure that $ssl_force_tls was processed if an IMAP server's initial server response was invalid. The connection was not properly closed, and the code could continue attempting to authenticate. This could result in authentication credentials being exposed on an unencrypted connection, or to a machine-in-the-middle.",
        "git_url": "https://github.com/neomutt/neomutt/commit/9c36717a3e2af1f2c1b7242035455ec8112b4b06",
        "commit_title": "imap: close connection on all failures",
        "commit_text": " Thanks to Gabriel Salles-Loustau for spotting the problem.  Co-authored-by: Kevin McCarthy <kevin@8t8.us>",
        "func_before": "int imap_open_connection(struct ImapAccountData *adata)\n{\n  if (mutt_socket_open(adata->conn) < 0)\n    return -1;\n\n  adata->state = IMAP_CONNECTED;\n\n  if (imap_cmd_step(adata) != IMAP_RES_OK)\n  {\n    imap_close_connection(adata);\n    return -1;\n  }\n\n  if (mutt_istr_startswith(adata->buf, \"* OK\"))\n  {\n    if (!mutt_istr_startswith(adata->buf, \"* OK [CAPABILITY\") && check_capabilities(adata))\n    {\n      goto bail;\n    }\n#ifdef USE_SSL\n    /* Attempt STARTTLS if available and desired. */\n    if ((adata->conn->ssf == 0) && (C_SslForceTls || (adata->capabilities & IMAP_CAP_STARTTLS)))\n    {\n      enum QuadOption ans;\n\n      if (C_SslForceTls)\n        ans = MUTT_YES;\n      else if ((ans = query_quadoption(C_SslStarttls,\n                                       _(\"Secure connection with TLS?\"))) == MUTT_ABORT)\n      {\n        goto err_close_conn;\n      }\n      if (ans == MUTT_YES)\n      {\n        enum ImapExecResult rc = imap_exec(adata, \"STARTTLS\", IMAP_CMD_SINGLE);\n        // Clear any data after the STARTTLS acknowledgement\n        mutt_socket_empty(adata->conn);\n\n        if (rc == IMAP_EXEC_FATAL)\n          goto bail;\n        if (rc != IMAP_EXEC_ERROR)\n        {\n          if (mutt_ssl_starttls(adata->conn))\n          {\n            mutt_error(_(\"Could not negotiate TLS connection\"));\n            goto err_close_conn;\n          }\n          else\n          {\n            /* RFC2595 demands we recheck CAPABILITY after TLS completes. */\n            if (imap_exec(adata, \"CAPABILITY\", IMAP_CMD_NO_FLAGS))\n              goto bail;\n          }\n        }\n      }\n    }\n\n    if (C_SslForceTls && (adata->conn->ssf == 0))\n    {\n      mutt_error(_(\"Encrypted connection unavailable\"));\n      goto err_close_conn;\n    }\n#endif\n  }\n  else if (mutt_istr_startswith(adata->buf, \"* PREAUTH\"))\n  {\n#ifdef USE_SSL\n    /* Unless using a secure $tunnel, an unencrypted PREAUTH response may be a\n     * MITM attack.  The only way to stop \"STARTTLS\" MITM attacks is via\n     * $ssl_force_tls: an attacker can easily spoof \"* OK\" and strip the\n     * STARTTLS capability.  So consult $ssl_force_tls, not $ssl_starttls, to\n     * decide whether to abort. Note that if using $tunnel and\n     * $tunnel_is_secure, adata->conn->ssf will be set to 1. */\n    if ((adata->conn->ssf == 0) && C_SslForceTls)\n    {\n      mutt_error(_(\"Encrypted connection unavailable\"));\n      goto err_close_conn;\n    }\n#endif\n\n    adata->state = IMAP_AUTHENTICATED;\n    if (check_capabilities(adata) != 0)\n      goto bail;\n    FREE(&adata->capstr);\n  }\n  else\n  {\n    imap_error(\"imap_open_connection()\", adata->buf);\n    goto bail;\n  }\n\n  return 0;\n\n#ifdef USE_SSL\nerr_close_conn:\n  imap_close_connection(adata);\n#endif\nbail:\n  FREE(&adata->capstr);\n  return -1;\n}",
        "func": "int imap_open_connection(struct ImapAccountData *adata)\n{\n  if (mutt_socket_open(adata->conn) < 0)\n    return -1;\n\n  adata->state = IMAP_CONNECTED;\n\n  if (imap_cmd_step(adata) != IMAP_RES_OK)\n  {\n    imap_close_connection(adata);\n    return -1;\n  }\n\n  if (mutt_istr_startswith(adata->buf, \"* OK\"))\n  {\n    if (!mutt_istr_startswith(adata->buf, \"* OK [CAPABILITY\") && check_capabilities(adata))\n    {\n      goto bail;\n    }\n#ifdef USE_SSL\n    /* Attempt STARTTLS if available and desired. */\n    if ((adata->conn->ssf == 0) && (C_SslForceTls || (adata->capabilities & IMAP_CAP_STARTTLS)))\n    {\n      enum QuadOption ans;\n\n      if (C_SslForceTls)\n        ans = MUTT_YES;\n      else if ((ans = query_quadoption(C_SslStarttls,\n                                       _(\"Secure connection with TLS?\"))) == MUTT_ABORT)\n      {\n        goto bail;\n      }\n      if (ans == MUTT_YES)\n      {\n        enum ImapExecResult rc = imap_exec(adata, \"STARTTLS\", IMAP_CMD_SINGLE);\n        // Clear any data after the STARTTLS acknowledgement\n        mutt_socket_empty(adata->conn);\n\n        if (rc == IMAP_EXEC_FATAL)\n          goto bail;\n        if (rc != IMAP_EXEC_ERROR)\n        {\n          if (mutt_ssl_starttls(adata->conn))\n          {\n            mutt_error(_(\"Could not negotiate TLS connection\"));\n            goto bail;\n          }\n          else\n          {\n            /* RFC2595 demands we recheck CAPABILITY after TLS completes. */\n            if (imap_exec(adata, \"CAPABILITY\", IMAP_CMD_NO_FLAGS))\n              goto bail;\n          }\n        }\n      }\n    }\n\n    if (C_SslForceTls && (adata->conn->ssf == 0))\n    {\n      mutt_error(_(\"Encrypted connection unavailable\"));\n      goto bail;\n    }\n#endif\n  }\n  else if (mutt_istr_startswith(adata->buf, \"* PREAUTH\"))\n  {\n#ifdef USE_SSL\n    /* Unless using a secure $tunnel, an unencrypted PREAUTH response may be a\n     * MITM attack.  The only way to stop \"STARTTLS\" MITM attacks is via\n     * $ssl_force_tls: an attacker can easily spoof \"* OK\" and strip the\n     * STARTTLS capability.  So consult $ssl_force_tls, not $ssl_starttls, to\n     * decide whether to abort. Note that if using $tunnel and\n     * $tunnel_is_secure, adata->conn->ssf will be set to 1. */\n    if ((adata->conn->ssf == 0) && C_SslForceTls)\n    {\n      mutt_error(_(\"Encrypted connection unavailable\"));\n      goto bail;\n    }\n#endif\n\n    adata->state = IMAP_AUTHENTICATED;\n    if (check_capabilities(adata) != 0)\n      goto bail;\n    FREE(&adata->capstr);\n  }\n  else\n  {\n    imap_error(\"imap_open_connection()\", adata->buf);\n    goto bail;\n  }\n\n  return 0;\n\nbail:\n  imap_close_connection(adata);\n  FREE(&adata->capstr);\n  return -1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -28,7 +28,7 @@\n       else if ((ans = query_quadoption(C_SslStarttls,\n                                        _(\"Secure connection with TLS?\"))) == MUTT_ABORT)\n       {\n-        goto err_close_conn;\n+        goto bail;\n       }\n       if (ans == MUTT_YES)\n       {\n@@ -43,7 +43,7 @@\n           if (mutt_ssl_starttls(adata->conn))\n           {\n             mutt_error(_(\"Could not negotiate TLS connection\"));\n-            goto err_close_conn;\n+            goto bail;\n           }\n           else\n           {\n@@ -58,7 +58,7 @@\n     if (C_SslForceTls && (adata->conn->ssf == 0))\n     {\n       mutt_error(_(\"Encrypted connection unavailable\"));\n-      goto err_close_conn;\n+      goto bail;\n     }\n #endif\n   }\n@@ -74,7 +74,7 @@\n     if ((adata->conn->ssf == 0) && C_SslForceTls)\n     {\n       mutt_error(_(\"Encrypted connection unavailable\"));\n-      goto err_close_conn;\n+      goto bail;\n     }\n #endif\n \n@@ -91,11 +91,8 @@\n \n   return 0;\n \n-#ifdef USE_SSL\n-err_close_conn:\n+bail:\n   imap_close_connection(adata);\n-#endif\n-bail:\n   FREE(&adata->capstr);\n   return -1;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "        goto err_close_conn;",
                "            goto err_close_conn;",
                "      goto err_close_conn;",
                "      goto err_close_conn;",
                "#ifdef USE_SSL",
                "err_close_conn:",
                "#endif",
                "bail:"
            ],
            "added_lines": [
                "        goto bail;",
                "            goto bail;",
                "      goto bail;",
                "      goto bail;",
                "bail:"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-28896",
        "func_name": "muttmua/mutt/imap_open_connection",
        "description": "Mutt before 2.0.2 and NeoMutt before 2020-11-20 did not ensure that $ssl_force_tls was processed if an IMAP server's initial server response was invalid. The connection was not properly closed, and the code could continue attempting to authenticate. This could result in authentication credentials being exposed on an unencrypted connection, or to a machine-in-the-middle.",
        "git_url": "https://gitlab.com/muttmua/mutt/-/commit/04b06aaa3e0cc0022b9b01dbca2863756ebbf59a",
        "commit_title": "Ensure IMAP connection is closed after a connection error.",
        "commit_text": " During connection, if the server provided an illegal initial response, Mutt \"bailed\", but did not actually close the connection.  The calling code unfortunately relied on the connection status to decide to continue with authentication, instead of checking the \"bail\" return value.  This could result in authentication credentials being sent over an unencrypted connection, without $ssl_force_tls being consulted.  Fix this by strictly closing the connection on any invalid response during connection.  The fix is intentionally small, to ease backporting.  A better fix would include removing the 'err_close_conn' label, and perhaps adding return value checking in the caller (though this change obviates the need for that).  This addresses CVE-2020-28896.  Thanks to Gabriel Salles-Loustau for reporting the problem, and providing test cases to reproduce. ",
        "func_before": "int imap_open_connection (IMAP_DATA* idata)\n{\n  if (mutt_socket_open (idata->conn) < 0)\n    return -1;\n\n  idata->state = IMAP_CONNECTED;\n\n  if (imap_cmd_step (idata) != IMAP_CMD_OK)\n  {\n    imap_close_connection (idata);\n    return -1;\n  }\n\n  if (ascii_strncasecmp (\"* OK\", idata->buf, 4) == 0)\n  {\n    if (ascii_strncasecmp (\"* OK [CAPABILITY\", idata->buf, 16)\n        && imap_check_capabilities (idata))\n      goto bail;\n#if defined(USE_SSL)\n    /* Attempt STARTTLS if available and desired. */\n    if (!idata->conn->ssf && (option(OPTSSLFORCETLS) ||\n                              mutt_bit_isset (idata->capabilities, STARTTLS)))\n    {\n      int rc;\n\n      if (option(OPTSSLFORCETLS))\n        rc = MUTT_YES;\n      else if ((rc = query_quadoption (OPT_SSLSTARTTLS,\n                                       _(\"Secure connection with TLS?\"))) == -1)\n\tgoto err_close_conn;\n      if (rc == MUTT_YES)\n      {\n\tif ((rc = imap_exec (idata, \"STARTTLS\", IMAP_CMD_FAIL_OK)) == -1)\n\t  goto bail;\n\tif (rc != -2)\n\t{\n\t  if (mutt_ssl_starttls (idata->conn))\n\t  {\n\t    mutt_error (_(\"Could not negotiate TLS connection\"));\n\t    mutt_sleep (1);\n\t    goto err_close_conn;\n\t  }\n\t  else\n\t  {\n\t    /* RFC 2595 demands we recheck CAPABILITY after TLS completes. */\n\t    if (imap_exec (idata, \"CAPABILITY\", 0))\n\t      goto bail;\n\t  }\n\t}\n      }\n    }\n\n    if (option(OPTSSLFORCETLS) && ! idata->conn->ssf)\n    {\n      mutt_error _(\"Encrypted connection unavailable\");\n      mutt_sleep (1);\n      goto err_close_conn;\n    }\n#endif\n  }\n  else if (ascii_strncasecmp (\"* PREAUTH\", idata->buf, 9) == 0)\n  {\n#if defined(USE_SSL)\n    /* Unless using a secure $tunnel, an unencrypted PREAUTH response\n     * may be a MITM attack.  The only way to stop \"STARTTLS\" MITM\n     * attacks is via $ssl_force_tls: an attacker can easily spoof\n     * \"* OK\" and strip the STARTTLS capability.  So consult\n     * $ssl_force_tls, not $ssl_starttls, to decide whether to\n     * abort. Note that if using $tunnel and $tunnel_is_secure,\n     * conn->ssf will be set to 1. */\n    if (!idata->conn->ssf && option(OPTSSLFORCETLS))\n    {\n      mutt_error _(\"Encrypted connection unavailable\");\n      mutt_sleep (1);\n      goto err_close_conn;\n    }\n#endif\n\n    idata->state = IMAP_AUTHENTICATED;\n    if (imap_check_capabilities (idata) != 0)\n      goto bail;\n    FREE (&idata->capstr);\n  }\n  else\n  {\n    imap_error (\"imap_open_connection()\", idata->buf);\n    goto bail;\n  }\n\n  return 0;\n\n#if defined(USE_SSL)\nerr_close_conn:\n  imap_close_connection (idata);\n#endif\nbail:\n  FREE (&idata->capstr);\n  return -1;\n}",
        "func": "int imap_open_connection (IMAP_DATA* idata)\n{\n  if (mutt_socket_open (idata->conn) < 0)\n    return -1;\n\n  idata->state = IMAP_CONNECTED;\n\n  if (imap_cmd_step (idata) != IMAP_CMD_OK)\n  {\n    imap_close_connection (idata);\n    return -1;\n  }\n\n  if (ascii_strncasecmp (\"* OK\", idata->buf, 4) == 0)\n  {\n    if (ascii_strncasecmp (\"* OK [CAPABILITY\", idata->buf, 16)\n        && imap_check_capabilities (idata))\n      goto bail;\n#if defined(USE_SSL)\n    /* Attempt STARTTLS if available and desired. */\n    if (!idata->conn->ssf && (option(OPTSSLFORCETLS) ||\n                              mutt_bit_isset (idata->capabilities, STARTTLS)))\n    {\n      int rc;\n\n      if (option(OPTSSLFORCETLS))\n        rc = MUTT_YES;\n      else if ((rc = query_quadoption (OPT_SSLSTARTTLS,\n                                       _(\"Secure connection with TLS?\"))) == -1)\n\tgoto err_close_conn;\n      if (rc == MUTT_YES)\n      {\n\tif ((rc = imap_exec (idata, \"STARTTLS\", IMAP_CMD_FAIL_OK)) == -1)\n\t  goto bail;\n\tif (rc != -2)\n\t{\n\t  if (mutt_ssl_starttls (idata->conn))\n\t  {\n\t    mutt_error (_(\"Could not negotiate TLS connection\"));\n\t    mutt_sleep (1);\n\t    goto err_close_conn;\n\t  }\n\t  else\n\t  {\n\t    /* RFC 2595 demands we recheck CAPABILITY after TLS completes. */\n\t    if (imap_exec (idata, \"CAPABILITY\", 0))\n\t      goto bail;\n\t  }\n\t}\n      }\n    }\n\n    if (option(OPTSSLFORCETLS) && ! idata->conn->ssf)\n    {\n      mutt_error _(\"Encrypted connection unavailable\");\n      mutt_sleep (1);\n      goto err_close_conn;\n    }\n#endif\n  }\n  else if (ascii_strncasecmp (\"* PREAUTH\", idata->buf, 9) == 0)\n  {\n#if defined(USE_SSL)\n    /* Unless using a secure $tunnel, an unencrypted PREAUTH response\n     * may be a MITM attack.  The only way to stop \"STARTTLS\" MITM\n     * attacks is via $ssl_force_tls: an attacker can easily spoof\n     * \"* OK\" and strip the STARTTLS capability.  So consult\n     * $ssl_force_tls, not $ssl_starttls, to decide whether to\n     * abort. Note that if using $tunnel and $tunnel_is_secure,\n     * conn->ssf will be set to 1. */\n    if (!idata->conn->ssf && option(OPTSSLFORCETLS))\n    {\n      mutt_error _(\"Encrypted connection unavailable\");\n      mutt_sleep (1);\n      goto err_close_conn;\n    }\n#endif\n\n    idata->state = IMAP_AUTHENTICATED;\n    if (imap_check_capabilities (idata) != 0)\n      goto bail;\n    FREE (&idata->capstr);\n  }\n  else\n  {\n    imap_error (\"imap_open_connection()\", idata->buf);\n    goto bail;\n  }\n\n  return 0;\n\n#if defined(USE_SSL)\nerr_close_conn:\n#endif\nbail:\n  imap_close_connection (idata);\n  FREE (&idata->capstr);\n  return -1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -91,9 +91,9 @@\n \n #if defined(USE_SSL)\n err_close_conn:\n-  imap_close_connection (idata);\n #endif\n bail:\n+  imap_close_connection (idata);\n   FREE (&idata->capstr);\n   return -1;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "  imap_close_connection (idata);"
            ],
            "added_lines": [
                "  imap_close_connection (idata);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-21335",
        "func_name": "stnoonan/spnego-http-auth-nginx-module/ngx_http_auth_spnego_handler",
        "description": "In the SPNEGO HTTP Authentication Module for nginx (spnego-http-auth-nginx-module) before version 1.1.1 basic Authentication can be bypassed using a malformed username. This affects users of spnego-http-auth-nginx-module that have enabled basic authentication. This is fixed in version 1.1.1 of spnego-http-auth-nginx-module. As a workaround, one may disable basic authentication.",
        "git_url": "https://github.com/stnoonan/spnego-http-auth-nginx-module/commit/a06f9efca373e25328b1c53639a48decd0854570",
        "commit_title": "Check basic auth result against != NGX_OK rather than == NGX_DECLINED",
        "commit_text": " This corrects the error handling case when ngx_http_auth_spnego_basic is called with a bad configuration or bad username. These cases return NGX_ERROR, which allowed basic auth to proceed.\r \r Thanks to Prakapovich Pavel aka Flyguy.by for pointing this out.",
        "func_before": "static ngx_int_t\nngx_http_auth_spnego_handler(\n        ngx_http_request_t * r)\n{\n    ngx_int_t ret = NGX_DECLINED;\n    ngx_http_auth_spnego_ctx_t *ctx;\n    ngx_http_auth_spnego_loc_conf_t *alcf;\n\n    alcf = ngx_http_get_module_loc_conf(r, ngx_http_auth_spnego_module);\n\n    if (alcf->protect == 0) {\n        return NGX_DECLINED;\n    }\n\n    ctx = ngx_http_get_module_ctx(r, ngx_http_auth_spnego_module);\n    if (NULL == ctx) {\n        ctx = ngx_palloc(r->pool, sizeof(ngx_http_auth_spnego_ctx_t));\n        if (NULL == ctx) {\n            return NGX_HTTP_INTERNAL_SERVER_ERROR;\n        }\n        ctx->token.len = 0;\n        ctx->token.data = NULL;\n        ctx->head = 0;\n        ctx->ret = NGX_HTTP_UNAUTHORIZED;\n        ngx_http_set_ctx(r, ctx, ngx_http_auth_spnego_module);\n    }\n\n    spnego_debug3(\"SSO auth handling IN: token.len=%d, head=%d, ret=%d\",\n            ctx->token.len, ctx->head, ctx->ret);\n\n    if (ctx->token.len && ctx->head) {\n        spnego_debug1(\"Found token and head, returning %d\", ctx->ret);\n        return ctx->ret;\n    }\n\n    if (NULL != r->headers_in.user.data) {\n        spnego_debug0(\"User header set\");\n        return NGX_OK;\n    }\n\n    spnego_debug0(\"Begin auth\");\n\n    if (alcf->allow_basic) {\n        spnego_debug0(\"Detect basic auth\");\n        ret = ngx_http_auth_basic_user(r);\n        if (NGX_OK == ret) {\n            spnego_debug0(\"Basic auth credentials supplied by client\");\n            /* If basic auth is enabled and basic creds are supplied\n             * attempt basic auth.  If we attempt basic auth, we do\n             * not fall through to real SPNEGO */\n            if (NGX_DECLINED == ngx_http_auth_spnego_basic(r, ctx, alcf)) {\n                spnego_debug0(\"Basic auth failed\");\n                if (NGX_ERROR == ngx_http_auth_spnego_headers_basic_only(r, ctx, alcf)) {\n                    spnego_debug0(\"Error setting headers\");\n                    return (ctx->ret = NGX_HTTP_INTERNAL_SERVER_ERROR);\n                }\n                return (ctx->ret = NGX_HTTP_UNAUTHORIZED);\n            }\n\n            if (!ngx_spnego_authorized_principal(r, &r->headers_in.user, alcf)) {\n                spnego_debug0(\"User not authorized\");\n                return (ctx->ret = NGX_HTTP_FORBIDDEN);\n            }\n\n            spnego_debug0(\"Basic auth succeeded\");\n            return (ctx->ret = NGX_OK);\n        }\n    }\n\n    /* Basic auth either disabled or not supplied by client */\n    spnego_debug0(\"Detect SPNEGO token\");\n    ret = ngx_http_auth_spnego_token(r, ctx);\n    if (NGX_OK == ret) {\n        spnego_debug0(\"Client sent a reasonable Negotiate header\");\n        ret = ngx_http_auth_spnego_auth_user_gss(r, ctx, alcf);\n        if (NGX_ERROR == ret) {\n            spnego_debug0(\"GSSAPI failed\");\n            return (ctx->ret = NGX_HTTP_INTERNAL_SERVER_ERROR);\n        }\n        /* There are chances that client knows about Negotiate\n         * but doesn't support GSSAPI. We could attempt to fall\n         * back to basic here... */\n        if (NGX_DECLINED == ret) {\n            spnego_debug0(\"GSSAPI failed\");\n            if(!alcf->allow_basic) {\n                return (ctx->ret = NGX_HTTP_FORBIDDEN);\n            }\n            if (NGX_ERROR == ngx_http_auth_spnego_headers_basic_only(r, ctx, alcf)) {\n                spnego_debug0(\"Error setting headers\");\n                return (ctx->ret = NGX_HTTP_INTERNAL_SERVER_ERROR);\n            }\n            return (ctx->ret = NGX_HTTP_UNAUTHORIZED);\n        }\n\n        if (!ngx_spnego_authorized_principal(r, &r->headers_in.user, alcf)) {\n            spnego_debug0(\"User not authorized\");\n            return (ctx->ret = NGX_HTTP_FORBIDDEN);\n        }\n\n        spnego_debug0(\"GSSAPI auth succeeded\");\n    }\n\n    ngx_str_t *token_out_b64 = NULL;\n    switch(ret) {\n        case NGX_DECLINED: /* DECLINED, but not yet FORBIDDEN */\n            ctx->ret = NGX_HTTP_UNAUTHORIZED;\n            break;\n        case NGX_OK:\n            ctx->ret = NGX_OK;\n            token_out_b64 = &ctx->token_out_b64;\n            break;\n        case NGX_ERROR:\n        default:\n            ctx->ret = NGX_HTTP_INTERNAL_SERVER_ERROR;\n            break;\n    }\n\n    if (NGX_ERROR == ngx_http_auth_spnego_headers(r, ctx, token_out_b64, alcf)) {\n        spnego_debug0(\"Error setting headers\");\n        ctx->ret = NGX_HTTP_INTERNAL_SERVER_ERROR;\n    }\n\n    spnego_debug3(\"SSO auth handling OUT: token.len=%d, head=%d, ret=%d\",\n            ctx->token.len, ctx->head, ctx->ret);\n    return ctx->ret;\n}",
        "func": "static ngx_int_t\nngx_http_auth_spnego_handler(\n        ngx_http_request_t * r)\n{\n    ngx_int_t ret = NGX_DECLINED;\n    ngx_http_auth_spnego_ctx_t *ctx;\n    ngx_http_auth_spnego_loc_conf_t *alcf;\n\n    alcf = ngx_http_get_module_loc_conf(r, ngx_http_auth_spnego_module);\n\n    if (alcf->protect == 0) {\n        return NGX_DECLINED;\n    }\n\n    ctx = ngx_http_get_module_ctx(r, ngx_http_auth_spnego_module);\n    if (NULL == ctx) {\n        ctx = ngx_palloc(r->pool, sizeof(ngx_http_auth_spnego_ctx_t));\n        if (NULL == ctx) {\n            return NGX_HTTP_INTERNAL_SERVER_ERROR;\n        }\n        ctx->token.len = 0;\n        ctx->token.data = NULL;\n        ctx->head = 0;\n        ctx->ret = NGX_HTTP_UNAUTHORIZED;\n        ngx_http_set_ctx(r, ctx, ngx_http_auth_spnego_module);\n    }\n\n    spnego_debug3(\"SSO auth handling IN: token.len=%d, head=%d, ret=%d\",\n            ctx->token.len, ctx->head, ctx->ret);\n\n    if (ctx->token.len && ctx->head) {\n        spnego_debug1(\"Found token and head, returning %d\", ctx->ret);\n        return ctx->ret;\n    }\n\n    if (NULL != r->headers_in.user.data) {\n        spnego_debug0(\"User header set\");\n        return NGX_OK;\n    }\n\n    spnego_debug0(\"Begin auth\");\n\n    if (alcf->allow_basic) {\n        spnego_debug0(\"Detect basic auth\");\n        ret = ngx_http_auth_basic_user(r);\n        if (NGX_OK == ret) {\n            spnego_debug0(\"Basic auth credentials supplied by client\");\n            /* If basic auth is enabled and basic creds are supplied\n             * attempt basic auth.  If we attempt basic auth, we do\n             * not fall through to real SPNEGO */\n            if (NGX_OK != ngx_http_auth_spnego_basic(r, ctx, alcf)) {\n                spnego_debug0(\"Basic auth failed\");\n                if (NGX_ERROR == ngx_http_auth_spnego_headers_basic_only(r, ctx, alcf)) {\n                    spnego_debug0(\"Error setting headers\");\n                    return (ctx->ret = NGX_HTTP_INTERNAL_SERVER_ERROR);\n                }\n                return (ctx->ret = NGX_HTTP_UNAUTHORIZED);\n            }\n\n            if (!ngx_spnego_authorized_principal(r, &r->headers_in.user, alcf)) {\n                spnego_debug0(\"User not authorized\");\n                return (ctx->ret = NGX_HTTP_FORBIDDEN);\n            }\n\n            spnego_debug0(\"Basic auth succeeded\");\n            return (ctx->ret = NGX_OK);\n        }\n    }\n\n    /* Basic auth either disabled or not supplied by client */\n    spnego_debug0(\"Detect SPNEGO token\");\n    ret = ngx_http_auth_spnego_token(r, ctx);\n    if (NGX_OK == ret) {\n        spnego_debug0(\"Client sent a reasonable Negotiate header\");\n        ret = ngx_http_auth_spnego_auth_user_gss(r, ctx, alcf);\n        if (NGX_ERROR == ret) {\n            spnego_debug0(\"GSSAPI failed\");\n            return (ctx->ret = NGX_HTTP_INTERNAL_SERVER_ERROR);\n        }\n        /* There are chances that client knows about Negotiate\n         * but doesn't support GSSAPI. We could attempt to fall\n         * back to basic here... */\n        if (NGX_DECLINED == ret) {\n            spnego_debug0(\"GSSAPI failed\");\n            if(!alcf->allow_basic) {\n                return (ctx->ret = NGX_HTTP_FORBIDDEN);\n            }\n            if (NGX_ERROR == ngx_http_auth_spnego_headers_basic_only(r, ctx, alcf)) {\n                spnego_debug0(\"Error setting headers\");\n                return (ctx->ret = NGX_HTTP_INTERNAL_SERVER_ERROR);\n            }\n            return (ctx->ret = NGX_HTTP_UNAUTHORIZED);\n        }\n\n        if (!ngx_spnego_authorized_principal(r, &r->headers_in.user, alcf)) {\n            spnego_debug0(\"User not authorized\");\n            return (ctx->ret = NGX_HTTP_FORBIDDEN);\n        }\n\n        spnego_debug0(\"GSSAPI auth succeeded\");\n    }\n\n    ngx_str_t *token_out_b64 = NULL;\n    switch(ret) {\n        case NGX_DECLINED: /* DECLINED, but not yet FORBIDDEN */\n            ctx->ret = NGX_HTTP_UNAUTHORIZED;\n            break;\n        case NGX_OK:\n            ctx->ret = NGX_OK;\n            token_out_b64 = &ctx->token_out_b64;\n            break;\n        case NGX_ERROR:\n        default:\n            ctx->ret = NGX_HTTP_INTERNAL_SERVER_ERROR;\n            break;\n    }\n\n    if (NGX_ERROR == ngx_http_auth_spnego_headers(r, ctx, token_out_b64, alcf)) {\n        spnego_debug0(\"Error setting headers\");\n        ctx->ret = NGX_HTTP_INTERNAL_SERVER_ERROR;\n    }\n\n    spnego_debug3(\"SSO auth handling OUT: token.len=%d, head=%d, ret=%d\",\n            ctx->token.len, ctx->head, ctx->ret);\n    return ctx->ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -48,7 +48,7 @@\n             /* If basic auth is enabled and basic creds are supplied\n              * attempt basic auth.  If we attempt basic auth, we do\n              * not fall through to real SPNEGO */\n-            if (NGX_DECLINED == ngx_http_auth_spnego_basic(r, ctx, alcf)) {\n+            if (NGX_OK != ngx_http_auth_spnego_basic(r, ctx, alcf)) {\n                 spnego_debug0(\"Basic auth failed\");\n                 if (NGX_ERROR == ngx_http_auth_spnego_headers_basic_only(r, ctx, alcf)) {\n                     spnego_debug0(\"Error setting headers\");",
        "diff_line_info": {
            "deleted_lines": [
                "            if (NGX_DECLINED == ngx_http_auth_spnego_basic(r, ctx, alcf)) {"
            ],
            "added_lines": [
                "            if (NGX_OK != ngx_http_auth_spnego_basic(r, ctx, alcf)) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-2553",
        "func_name": "ClusterLabs/booth/setup_config",
        "description": "The authfile directive in the booth config file is ignored, preventing use of authentication in communications from node to node. As a result, nodes that do not have the correct authentication key are not prevented from communicating with other nodes in the cluster.",
        "git_url": "https://github.com/ClusterLabs/booth/commit/35bf0b7b048d715f671eb68974fb6b4af6528c67",
        "commit_title": "Revert \"Refactor: main: substitute is_auth_req macro\"",
        "commit_text": " This reverts commit da79b8ba28ad4837a0fee13e5f8fb6f89fe0e24c.  authfile != authkey ",
        "func_before": "static int setup_config(int type)\n{\n\tint rv;\n\n\trv = read_config(cl.configfile, type);\n\tif (rv < 0)\n\t\tgoto out;\n\n\tif (is_auth_req()) {\n\t\trv = read_authkey();\n\t\tif (rv < 0)\n\t\t\tgoto out;\n#if HAVE_LIBGCRYPT\n\t\tif (!gcry_check_version(NULL)) {\n\t\t\tlog_error(\"gcry_check_version\");\n\t\t\trv = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\t\tgcry_control(GCRYCTL_DISABLE_SECMEM, 0);\n\t\tgcry_control(GCRYCTL_INITIALIZATION_FINISHED, 0);\n#endif\n\t}\n\n\t/* Set \"local\" pointer, ignoring errors. */\n\tif (cl.type == DAEMON && cl.site[0]) {\n\t\tif (!find_site_by_name(cl.site, &local, 1)) {\n\t\t\tlog_error(\"Cannot find \\\"%s\\\" in the configuration.\",\n\t\t\t\t\tcl.site);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tlocal->local = 1;\n\t} else\n\t\tfind_myself(NULL, type == CLIENT || type == GEOSTORE);\n\n\n\trv = check_config(type);\n\tif (rv < 0)\n\t\tgoto out;\n\n\n\t/* Per default the PID file name is derived from the\n\t * configuration name. */\n\tif (!cl.lockfile[0]) {\n\t\tsnprintf(cl.lockfile, sizeof(cl.lockfile)-1,\n\t\t\t\t\"%s/%s.pid\", BOOTH_RUN_DIR, booth_conf->name);\n\t}\n\nout:\n\treturn rv;\n}",
        "func": "static int setup_config(int type)\n{\n\tint rv;\n\n\trv = read_config(cl.configfile, type);\n\tif (rv < 0)\n\t\tgoto out;\n\n\tif (booth_conf->authfile[0] != '\\0') {\n\t\trv = read_authkey();\n\t\tif (rv < 0)\n\t\t\tgoto out;\n#if HAVE_LIBGCRYPT\n\t\tif (!gcry_check_version(NULL)) {\n\t\t\tlog_error(\"gcry_check_version\");\n\t\t\trv = -ENOENT;\n\t\t\tgoto out;\n\t\t}\n\t\tgcry_control(GCRYCTL_DISABLE_SECMEM, 0);\n\t\tgcry_control(GCRYCTL_INITIALIZATION_FINISHED, 0);\n#endif\n\t}\n\n\t/* Set \"local\" pointer, ignoring errors. */\n\tif (cl.type == DAEMON && cl.site[0]) {\n\t\tif (!find_site_by_name(cl.site, &local, 1)) {\n\t\t\tlog_error(\"Cannot find \\\"%s\\\" in the configuration.\",\n\t\t\t\t\tcl.site);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tlocal->local = 1;\n\t} else\n\t\tfind_myself(NULL, type == CLIENT || type == GEOSTORE);\n\n\n\trv = check_config(type);\n\tif (rv < 0)\n\t\tgoto out;\n\n\n\t/* Per default the PID file name is derived from the\n\t * configuration name. */\n\tif (!cl.lockfile[0]) {\n\t\tsnprintf(cl.lockfile, sizeof(cl.lockfile)-1,\n\t\t\t\t\"%s/%s.pid\", BOOTH_RUN_DIR, booth_conf->name);\n\t}\n\nout:\n\treturn rv;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,7 +6,7 @@\n \tif (rv < 0)\n \t\tgoto out;\n \n-\tif (is_auth_req()) {\n+\tif (booth_conf->authfile[0] != '\\0') {\n \t\trv = read_authkey();\n \t\tif (rv < 0)\n \t\t\tgoto out;",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (is_auth_req()) {"
            ],
            "added_lines": [
                "\tif (booth_conf->authfile[0] != '\\0') {"
            ]
        }
    }
]