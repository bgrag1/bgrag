[
    {
        "cve_id": "CVE-2022-0554",
        "func_name": "vim/do_buffer_ext",
        "description": "Use of Out-of-range Pointer Offset in GitHub repository vim/vim prior to 8.2.",
        "git_url": "https://github.com/vim/vim/commit/e3537aec2f8d6470010547af28dcbd83d41461b8",
        "commit_title": "patch 8.2.4327: may end up with no current buffer",
        "commit_text": " Problem:    May end up with no current buffer. Solution:   When deleting the current buffer to not pick a quickfix buffer as             the new current buffer.",
        "func_before": "static int\ndo_buffer_ext(\n    int\t\taction,\n    int\t\tstart,\n    int\t\tdir,\t\t// FORWARD or BACKWARD\n    int\t\tcount,\t\t// buffer number or number of buffers\n    int\t\tflags)\t\t// DOBUF_FORCEIT etc.\n{\n    buf_T\t*buf;\n    buf_T\t*bp;\n    int\t\tunload = (action == DOBUF_UNLOAD || action == DOBUF_DEL\n\t\t\t|| action == DOBUF_WIPE || action == DOBUF_WIPE_REUSE);\n\n    switch (start)\n    {\n\tcase DOBUF_FIRST:   buf = firstbuf; break;\n\tcase DOBUF_LAST:    buf = lastbuf;  break;\n\tdefault:\t    buf = curbuf;   break;\n    }\n    if (start == DOBUF_MOD)\t    // find next modified buffer\n    {\n\twhile (count-- > 0)\n\t{\n\t    do\n\t    {\n\t\tbuf = buf->b_next;\n\t\tif (buf == NULL)\n\t\t    buf = firstbuf;\n\t    }\n\t    while (buf != curbuf && !bufIsChanged(buf));\n\t}\n\tif (!bufIsChanged(buf))\n\t{\n\t    emsg(_(e_no_modified_buffer_found));\n\t    return FAIL;\n\t}\n    }\n    else if (start == DOBUF_FIRST && count) // find specified buffer number\n    {\n\twhile (buf != NULL && buf->b_fnum != count)\n\t    buf = buf->b_next;\n    }\n    else\n    {\n\tbp = NULL;\n\twhile (count > 0 || (!unload && !buf->b_p_bl && bp != buf))\n\t{\n\t    // remember the buffer where we start, we come back there when all\n\t    // buffers are unlisted.\n\t    if (bp == NULL)\n\t\tbp = buf;\n\t    if (dir == FORWARD)\n\t    {\n\t\tbuf = buf->b_next;\n\t\tif (buf == NULL)\n\t\t    buf = firstbuf;\n\t    }\n\t    else\n\t    {\n\t\tbuf = buf->b_prev;\n\t\tif (buf == NULL)\n\t\t    buf = lastbuf;\n\t    }\n\t    // don't count unlisted buffers\n\t    if (unload || buf->b_p_bl)\n\t    {\n\t\t --count;\n\t\t bp = NULL;\t// use this buffer as new starting point\n\t    }\n\t    if (bp == buf)\n\t    {\n\t\t// back where we started, didn't find anything.\n\t\temsg(_(e_there_is_no_listed_buffer));\n\t\treturn FAIL;\n\t    }\n\t}\n    }\n\n    if (buf == NULL)\t    // could not find it\n    {\n\tif (start == DOBUF_FIRST)\n\t{\n\t    // don't warn when deleting\n\t    if (!unload)\n\t\tsemsg(_(e_buffer_nr_does_not_exist), count);\n\t}\n\telse if (dir == FORWARD)\n\t    emsg(_(e_cannot_go_beyond_last_buffer));\n\telse\n\t    emsg(_(e_cannot_go_before_first_buffer));\n\treturn FAIL;\n    }\n#ifdef FEAT_PROP_POPUP\n    if ((flags & DOBUF_NOPOPUP) && bt_popup(buf)\n# ifdef FEAT_TERMINAL\n\t\t\t\t&& !bt_terminal(buf)\n#endif\n       )\n\treturn OK;\n#endif\n\n#ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n#endif\n\n    /*\n     * delete buffer \"buf\" from memory and/or the list\n     */\n    if (unload)\n    {\n\tint\tforward;\n\tbufref_T bufref;\n\n\tif (!can_unload_buffer(buf))\n\t    return FAIL;\n\n\tset_bufref(&bufref, buf);\n\n\t// When unloading or deleting a buffer that's already unloaded and\n\t// unlisted: fail silently.\n\tif (action != DOBUF_WIPE && action != DOBUF_WIPE_REUSE\n\t\t\t\t   && buf->b_ml.ml_mfp == NULL && !buf->b_p_bl)\n\t    return FAIL;\n\n\tif ((flags & DOBUF_FORCEIT) == 0 && bufIsChanged(buf))\n\t{\n#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)\n\t    if ((p_confirm || (cmdmod.cmod_flags & CMOD_CONFIRM)) && p_write)\n\t    {\n\t\tdialog_changed(buf, FALSE);\n\t\tif (!bufref_valid(&bufref))\n\t\t    // Autocommand deleted buffer, oops!  It's not changed\n\t\t    // now.\n\t\t    return FAIL;\n\t\t// If it's still changed fail silently, the dialog already\n\t\t// mentioned why it fails.\n\t\tif (bufIsChanged(buf))\n\t\t    return FAIL;\n\t    }\n\t    else\n#endif\n\t    {\n\t\tsemsg(_(e_no_write_since_last_change_for_buffer_nr_add_bang_to_override),\n\t\t\t\t\t\t\t\t buf->b_fnum);\n\t\treturn FAIL;\n\t    }\n\t}\n\n\t// When closing the current buffer stop Visual mode.\n\tif (buf == curbuf && VIsual_active)\n\t    end_visual_mode();\n\n\t// If deleting the last (listed) buffer, make it empty.\n\t// The last (listed) buffer cannot be unloaded.\n\tFOR_ALL_BUFFERS(bp)\n\t    if (bp->b_p_bl && bp != buf)\n\t\tbreak;\n\tif (bp == NULL && buf == curbuf)\n\t    return empty_curbuf(TRUE, (flags & DOBUF_FORCEIT), action);\n\n\t// If the deleted buffer is the current one, close the current window\n\t// (unless it's the only window).  Repeat this so long as we end up in\n\t// a window with this buffer.\n\twhile (buf == curbuf\n\t\t   && !(curwin->w_closing || curwin->w_buffer->b_locked > 0)\n\t\t   && (!ONE_WINDOW || first_tabpage->tp_next != NULL))\n\t{\n\t    if (win_close(curwin, FALSE) == FAIL)\n\t\tbreak;\n\t}\n\n\t// If the buffer to be deleted is not the current one, delete it here.\n\tif (buf != curbuf)\n\t{\n\t    close_windows(buf, FALSE);\n\t    if (buf != curbuf && bufref_valid(&bufref) && buf->b_nwindows <= 0)\n\t\t    close_buffer(NULL, buf, action, FALSE, FALSE);\n\t    return OK;\n\t}\n\n\t/*\n\t * Deleting the current buffer: Need to find another buffer to go to.\n\t * There should be another, otherwise it would have been handled\n\t * above.  However, autocommands may have deleted all buffers.\n\t * First use au_new_curbuf.br_buf, if it is valid.\n\t * Then prefer the buffer we most recently visited.\n\t * Else try to find one that is loaded, after the current buffer,\n\t * then before the current buffer.\n\t * Finally use any buffer.\n\t */\n\tbuf = NULL;\t// selected buffer\n\tbp = NULL;\t// used when no loaded buffer found\n\tif (au_new_curbuf.br_buf != NULL && bufref_valid(&au_new_curbuf))\n\t    buf = au_new_curbuf.br_buf;\n\telse if (curwin->w_jumplistlen > 0)\n\t{\n\t    int     jumpidx;\n\n\t    jumpidx = curwin->w_jumplistidx - 1;\n\t    if (jumpidx < 0)\n\t\tjumpidx = curwin->w_jumplistlen - 1;\n\n\t    forward = jumpidx;\n\t    while (jumpidx != curwin->w_jumplistidx)\n\t    {\n\t\tbuf = buflist_findnr(curwin->w_jumplist[jumpidx].fmark.fnum);\n\t\tif (buf != NULL)\n\t\t{\n\t\t    if (buf == curbuf || !buf->b_p_bl)\n\t\t\tbuf = NULL;\t// skip current and unlisted bufs\n\t\t    else if (buf->b_ml.ml_mfp == NULL)\n\t\t    {\n\t\t\t// skip unloaded buf, but may keep it for later\n\t\t\tif (bp == NULL)\n\t\t\t    bp = buf;\n\t\t\tbuf = NULL;\n\t\t    }\n\t\t}\n\t\tif (buf != NULL)   // found a valid buffer: stop searching\n\t\t    break;\n\t\t// advance to older entry in jump list\n\t\tif (!jumpidx && curwin->w_jumplistidx == curwin->w_jumplistlen)\n\t\t    break;\n\t\tif (--jumpidx < 0)\n\t\t    jumpidx = curwin->w_jumplistlen - 1;\n\t\tif (jumpidx == forward)\t\t// List exhausted for sure\n\t\t    break;\n\t    }\n\t}\n\n\tif (buf == NULL)\t// No previous buffer, Try 2'nd approach\n\t{\n\t    forward = TRUE;\n\t    buf = curbuf->b_next;\n\t    for (;;)\n\t    {\n\t\tif (buf == NULL)\n\t\t{\n\t\t    if (!forward)\t// tried both directions\n\t\t\tbreak;\n\t\t    buf = curbuf->b_prev;\n\t\t    forward = FALSE;\n\t\t    continue;\n\t\t}\n\t\t// in non-help buffer, try to skip help buffers, and vv\n\t\tif (buf->b_help == curbuf->b_help && buf->b_p_bl)\n\t\t{\n\t\t    if (buf->b_ml.ml_mfp != NULL)   // found loaded buffer\n\t\t\tbreak;\n\t\t    if (bp == NULL)\t// remember unloaded buf for later\n\t\t\tbp = buf;\n\t\t}\n\t\tif (forward)\n\t\t    buf = buf->b_next;\n\t\telse\n\t\t    buf = buf->b_prev;\n\t    }\n\t}\n\tif (buf == NULL)\t// No loaded buffer, use unloaded one\n\t    buf = bp;\n\tif (buf == NULL)\t// No loaded buffer, find listed one\n\t{\n\t    FOR_ALL_BUFFERS(buf)\n\t\tif (buf->b_p_bl && buf != curbuf)\n\t\t    break;\n\t}\n\tif (buf == NULL)\t// Still no buffer, just take one\n\t{\n\t    if (curbuf->b_next != NULL)\n\t\tbuf = curbuf->b_next;\n\t    else\n\t\tbuf = curbuf->b_prev;\n\t}\n    }\n\n    if (buf == NULL)\n    {\n\t// Autocommands must have wiped out all other buffers.  Only option\n\t// now is to make the current buffer empty.\n\treturn empty_curbuf(FALSE, (flags & DOBUF_FORCEIT), action);\n    }\n\n    /*\n     * make \"buf\" the current buffer\n     */\n    if (action == DOBUF_SPLIT)\t    // split window first\n    {\n\t// If 'switchbuf' contains \"useopen\": jump to first window containing\n\t// \"buf\" if one exists\n\tif ((swb_flags & SWB_USEOPEN) && buf_jump_open_win(buf))\n\t    return OK;\n\t// If 'switchbuf' contains \"usetab\": jump to first window in any tab\n\t// page containing \"buf\" if one exists\n\tif ((swb_flags & SWB_USETAB) && buf_jump_open_tab(buf))\n\t    return OK;\n\tif (win_split(0, 0) == FAIL)\n\t    return FAIL;\n    }\n\n    // go to current buffer - nothing to do\n    if (buf == curbuf)\n\treturn OK;\n\n    // Check if the current buffer may be abandoned.\n    if (action == DOBUF_GOTO && !can_abandon(curbuf, (flags & DOBUF_FORCEIT)))\n    {\n#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)\n\tif ((p_confirm || (cmdmod.cmod_flags & CMOD_CONFIRM)) && p_write)\n\t{\n\t    bufref_T bufref;\n\n\t    set_bufref(&bufref, buf);\n\t    dialog_changed(curbuf, FALSE);\n\t    if (!bufref_valid(&bufref))\n\t\t// Autocommand deleted buffer, oops!\n\t\treturn FAIL;\n\t}\n\tif (bufIsChanged(curbuf))\n#endif\n\t{\n\t    no_write_message();\n\t    return FAIL;\n\t}\n    }\n\n    // Go to the other buffer.\n    set_curbuf(buf, action);\n\n    if (action == DOBUF_SPLIT)\n\tRESET_BINDING(curwin);\t// reset 'scrollbind' and 'cursorbind'\n\n#if defined(FEAT_EVAL)\n    if (aborting())\t    // autocmds may abort script processing\n\treturn FAIL;\n#endif\n\n    return OK;\n}",
        "func": "static int\ndo_buffer_ext(\n    int\t\taction,\n    int\t\tstart,\n    int\t\tdir,\t\t// FORWARD or BACKWARD\n    int\t\tcount,\t\t// buffer number or number of buffers\n    int\t\tflags)\t\t// DOBUF_FORCEIT etc.\n{\n    buf_T\t*buf;\n    buf_T\t*bp;\n    int\t\tunload = (action == DOBUF_UNLOAD || action == DOBUF_DEL\n\t\t\t|| action == DOBUF_WIPE || action == DOBUF_WIPE_REUSE);\n\n    switch (start)\n    {\n\tcase DOBUF_FIRST:   buf = firstbuf; break;\n\tcase DOBUF_LAST:    buf = lastbuf;  break;\n\tdefault:\t    buf = curbuf;   break;\n    }\n    if (start == DOBUF_MOD)\t    // find next modified buffer\n    {\n\twhile (count-- > 0)\n\t{\n\t    do\n\t    {\n\t\tbuf = buf->b_next;\n\t\tif (buf == NULL)\n\t\t    buf = firstbuf;\n\t    }\n\t    while (buf != curbuf && !bufIsChanged(buf));\n\t}\n\tif (!bufIsChanged(buf))\n\t{\n\t    emsg(_(e_no_modified_buffer_found));\n\t    return FAIL;\n\t}\n    }\n    else if (start == DOBUF_FIRST && count) // find specified buffer number\n    {\n\twhile (buf != NULL && buf->b_fnum != count)\n\t    buf = buf->b_next;\n    }\n    else\n    {\n\tbp = NULL;\n\twhile (count > 0 || (!unload && !buf->b_p_bl && bp != buf))\n\t{\n\t    // remember the buffer where we start, we come back there when all\n\t    // buffers are unlisted.\n\t    if (bp == NULL)\n\t\tbp = buf;\n\t    if (dir == FORWARD)\n\t    {\n\t\tbuf = buf->b_next;\n\t\tif (buf == NULL)\n\t\t    buf = firstbuf;\n\t    }\n\t    else\n\t    {\n\t\tbuf = buf->b_prev;\n\t\tif (buf == NULL)\n\t\t    buf = lastbuf;\n\t    }\n\t    // don't count unlisted buffers\n\t    if (unload || buf->b_p_bl)\n\t    {\n\t\t --count;\n\t\t bp = NULL;\t// use this buffer as new starting point\n\t    }\n\t    if (bp == buf)\n\t    {\n\t\t// back where we started, didn't find anything.\n\t\temsg(_(e_there_is_no_listed_buffer));\n\t\treturn FAIL;\n\t    }\n\t}\n    }\n\n    if (buf == NULL)\t    // could not find it\n    {\n\tif (start == DOBUF_FIRST)\n\t{\n\t    // don't warn when deleting\n\t    if (!unload)\n\t\tsemsg(_(e_buffer_nr_does_not_exist), count);\n\t}\n\telse if (dir == FORWARD)\n\t    emsg(_(e_cannot_go_beyond_last_buffer));\n\telse\n\t    emsg(_(e_cannot_go_before_first_buffer));\n\treturn FAIL;\n    }\n#ifdef FEAT_PROP_POPUP\n    if ((flags & DOBUF_NOPOPUP) && bt_popup(buf)\n# ifdef FEAT_TERMINAL\n\t\t\t\t&& !bt_terminal(buf)\n#endif\n       )\n\treturn OK;\n#endif\n\n#ifdef FEAT_GUI\n    need_mouse_correct = TRUE;\n#endif\n\n    /*\n     * delete buffer \"buf\" from memory and/or the list\n     */\n    if (unload)\n    {\n\tint\tforward;\n\tbufref_T bufref;\n\n\tif (!can_unload_buffer(buf))\n\t    return FAIL;\n\n\tset_bufref(&bufref, buf);\n\n\t// When unloading or deleting a buffer that's already unloaded and\n\t// unlisted: fail silently.\n\tif (action != DOBUF_WIPE && action != DOBUF_WIPE_REUSE\n\t\t\t\t   && buf->b_ml.ml_mfp == NULL && !buf->b_p_bl)\n\t    return FAIL;\n\n\tif ((flags & DOBUF_FORCEIT) == 0 && bufIsChanged(buf))\n\t{\n#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)\n\t    if ((p_confirm || (cmdmod.cmod_flags & CMOD_CONFIRM)) && p_write)\n\t    {\n\t\tdialog_changed(buf, FALSE);\n\t\tif (!bufref_valid(&bufref))\n\t\t    // Autocommand deleted buffer, oops!  It's not changed\n\t\t    // now.\n\t\t    return FAIL;\n\t\t// If it's still changed fail silently, the dialog already\n\t\t// mentioned why it fails.\n\t\tif (bufIsChanged(buf))\n\t\t    return FAIL;\n\t    }\n\t    else\n#endif\n\t    {\n\t\tsemsg(_(e_no_write_since_last_change_for_buffer_nr_add_bang_to_override),\n\t\t\t\t\t\t\t\t buf->b_fnum);\n\t\treturn FAIL;\n\t    }\n\t}\n\n\t// When closing the current buffer stop Visual mode.\n\tif (buf == curbuf && VIsual_active)\n\t    end_visual_mode();\n\n\t// If deleting the last (listed) buffer, make it empty.\n\t// The last (listed) buffer cannot be unloaded.\n\tFOR_ALL_BUFFERS(bp)\n\t    if (bp->b_p_bl && bp != buf)\n\t\tbreak;\n\tif (bp == NULL && buf == curbuf)\n\t    return empty_curbuf(TRUE, (flags & DOBUF_FORCEIT), action);\n\n\t// If the deleted buffer is the current one, close the current window\n\t// (unless it's the only window).  Repeat this so long as we end up in\n\t// a window with this buffer.\n\twhile (buf == curbuf\n\t\t   && !(curwin->w_closing || curwin->w_buffer->b_locked > 0)\n\t\t   && (!ONE_WINDOW || first_tabpage->tp_next != NULL))\n\t{\n\t    if (win_close(curwin, FALSE) == FAIL)\n\t\tbreak;\n\t}\n\n\t// If the buffer to be deleted is not the current one, delete it here.\n\tif (buf != curbuf)\n\t{\n\t    close_windows(buf, FALSE);\n\t    if (buf != curbuf && bufref_valid(&bufref) && buf->b_nwindows <= 0)\n\t\t    close_buffer(NULL, buf, action, FALSE, FALSE);\n\t    return OK;\n\t}\n\n\t/*\n\t * Deleting the current buffer: Need to find another buffer to go to.\n\t * There should be another, otherwise it would have been handled\n\t * above.  However, autocommands may have deleted all buffers.\n\t * First use au_new_curbuf.br_buf, if it is valid.\n\t * Then prefer the buffer we most recently visited.\n\t * Else try to find one that is loaded, after the current buffer,\n\t * then before the current buffer.\n\t * Finally use any buffer.\n\t */\n\tbuf = NULL;\t// selected buffer\n\tbp = NULL;\t// used when no loaded buffer found\n\tif (au_new_curbuf.br_buf != NULL && bufref_valid(&au_new_curbuf))\n\t    buf = au_new_curbuf.br_buf;\n\telse if (curwin->w_jumplistlen > 0)\n\t{\n\t    int     jumpidx;\n\n\t    jumpidx = curwin->w_jumplistidx - 1;\n\t    if (jumpidx < 0)\n\t\tjumpidx = curwin->w_jumplistlen - 1;\n\n\t    forward = jumpidx;\n\t    while (jumpidx != curwin->w_jumplistidx)\n\t    {\n\t\tbuf = buflist_findnr(curwin->w_jumplist[jumpidx].fmark.fnum);\n\t\tif (buf != NULL)\n\t\t{\n\t\t    // Skip current and unlisted bufs.  Also skip a quickfix\n\t\t    // buffer, it might be deleted soon.\n\t\t    if (buf == curbuf || !buf->b_p_bl\n#if defined(FEAT_QUICKFIX)\n\t\t\t    || bt_quickfix(buf)\n#endif\n\t\t\t    )\n\t\t\tbuf = NULL;\n\t\t    else if (buf->b_ml.ml_mfp == NULL)\n\t\t    {\n\t\t\t// skip unloaded buf, but may keep it for later\n\t\t\tif (bp == NULL)\n\t\t\t    bp = buf;\n\t\t\tbuf = NULL;\n\t\t    }\n\t\t}\n\t\tif (buf != NULL)   // found a valid buffer: stop searching\n\t\t    break;\n\t\t// advance to older entry in jump list\n\t\tif (!jumpidx && curwin->w_jumplistidx == curwin->w_jumplistlen)\n\t\t    break;\n\t\tif (--jumpidx < 0)\n\t\t    jumpidx = curwin->w_jumplistlen - 1;\n\t\tif (jumpidx == forward)\t\t// List exhausted for sure\n\t\t    break;\n\t    }\n\t}\n\n\tif (buf == NULL)\t// No previous buffer, Try 2'nd approach\n\t{\n\t    forward = TRUE;\n\t    buf = curbuf->b_next;\n\t    for (;;)\n\t    {\n\t\tif (buf == NULL)\n\t\t{\n\t\t    if (!forward)\t// tried both directions\n\t\t\tbreak;\n\t\t    buf = curbuf->b_prev;\n\t\t    forward = FALSE;\n\t\t    continue;\n\t\t}\n\t\t// in non-help buffer, try to skip help buffers, and vv\n\t\tif (buf->b_help == curbuf->b_help && buf->b_p_bl\n#if defined(FEAT_QUICKFIX)\n\t\t\t    && !bt_quickfix(buf)\n#endif\n\t\t\t   )\n\t\t{\n\t\t    if (buf->b_ml.ml_mfp != NULL)   // found loaded buffer\n\t\t\tbreak;\n\t\t    if (bp == NULL)\t// remember unloaded buf for later\n\t\t\tbp = buf;\n\t\t}\n\t\tif (forward)\n\t\t    buf = buf->b_next;\n\t\telse\n\t\t    buf = buf->b_prev;\n\t    }\n\t}\n\tif (buf == NULL)\t// No loaded buffer, use unloaded one\n\t    buf = bp;\n\tif (buf == NULL)\t// No loaded buffer, find listed one\n\t{\n\t    FOR_ALL_BUFFERS(buf)\n\t\tif (buf->b_p_bl && buf != curbuf\n#if defined(FEAT_QUICKFIX)\n\t\t\t    && !bt_quickfix(buf)\n#endif\n\t\t       )\n\t\t    break;\n\t}\n\tif (buf == NULL)\t// Still no buffer, just take one\n\t{\n\t    if (curbuf->b_next != NULL)\n\t\tbuf = curbuf->b_next;\n\t    else\n\t\tbuf = curbuf->b_prev;\n#if defined(FEAT_QUICKFIX)\n\t    if (bt_quickfix(buf))\n\t\tbuf = NULL;\n#endif\n\t}\n    }\n\n    if (buf == NULL)\n    {\n\t// Autocommands must have wiped out all other buffers.  Only option\n\t// now is to make the current buffer empty.\n\treturn empty_curbuf(FALSE, (flags & DOBUF_FORCEIT), action);\n    }\n\n    /*\n     * make \"buf\" the current buffer\n     */\n    if (action == DOBUF_SPLIT)\t    // split window first\n    {\n\t// If 'switchbuf' contains \"useopen\": jump to first window containing\n\t// \"buf\" if one exists\n\tif ((swb_flags & SWB_USEOPEN) && buf_jump_open_win(buf))\n\t    return OK;\n\t// If 'switchbuf' contains \"usetab\": jump to first window in any tab\n\t// page containing \"buf\" if one exists\n\tif ((swb_flags & SWB_USETAB) && buf_jump_open_tab(buf))\n\t    return OK;\n\tif (win_split(0, 0) == FAIL)\n\t    return FAIL;\n    }\n\n    // go to current buffer - nothing to do\n    if (buf == curbuf)\n\treturn OK;\n\n    // Check if the current buffer may be abandoned.\n    if (action == DOBUF_GOTO && !can_abandon(curbuf, (flags & DOBUF_FORCEIT)))\n    {\n#if defined(FEAT_GUI_DIALOG) || defined(FEAT_CON_DIALOG)\n\tif ((p_confirm || (cmdmod.cmod_flags & CMOD_CONFIRM)) && p_write)\n\t{\n\t    bufref_T bufref;\n\n\t    set_bufref(&bufref, buf);\n\t    dialog_changed(curbuf, FALSE);\n\t    if (!bufref_valid(&bufref))\n\t\t// Autocommand deleted buffer, oops!\n\t\treturn FAIL;\n\t}\n\tif (bufIsChanged(curbuf))\n#endif\n\t{\n\t    no_write_message();\n\t    return FAIL;\n\t}\n    }\n\n    // Go to the other buffer.\n    set_curbuf(buf, action);\n\n    if (action == DOBUF_SPLIT)\n\tRESET_BINDING(curwin);\t// reset 'scrollbind' and 'cursorbind'\n\n#if defined(FEAT_EVAL)\n    if (aborting())\t    // autocmds may abort script processing\n\treturn FAIL;\n#endif\n\n    return OK;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -206,8 +206,14 @@\n \t\tbuf = buflist_findnr(curwin->w_jumplist[jumpidx].fmark.fnum);\n \t\tif (buf != NULL)\n \t\t{\n-\t\t    if (buf == curbuf || !buf->b_p_bl)\n-\t\t\tbuf = NULL;\t// skip current and unlisted bufs\n+\t\t    // Skip current and unlisted bufs.  Also skip a quickfix\n+\t\t    // buffer, it might be deleted soon.\n+\t\t    if (buf == curbuf || !buf->b_p_bl\n+#if defined(FEAT_QUICKFIX)\n+\t\t\t    || bt_quickfix(buf)\n+#endif\n+\t\t\t    )\n+\t\t\tbuf = NULL;\n \t\t    else if (buf->b_ml.ml_mfp == NULL)\n \t\t    {\n \t\t\t// skip unloaded buf, but may keep it for later\n@@ -243,7 +249,11 @@\n \t\t    continue;\n \t\t}\n \t\t// in non-help buffer, try to skip help buffers, and vv\n-\t\tif (buf->b_help == curbuf->b_help && buf->b_p_bl)\n+\t\tif (buf->b_help == curbuf->b_help && buf->b_p_bl\n+#if defined(FEAT_QUICKFIX)\n+\t\t\t    && !bt_quickfix(buf)\n+#endif\n+\t\t\t   )\n \t\t{\n \t\t    if (buf->b_ml.ml_mfp != NULL)   // found loaded buffer\n \t\t\tbreak;\n@@ -261,7 +271,11 @@\n \tif (buf == NULL)\t// No loaded buffer, find listed one\n \t{\n \t    FOR_ALL_BUFFERS(buf)\n-\t\tif (buf->b_p_bl && buf != curbuf)\n+\t\tif (buf->b_p_bl && buf != curbuf\n+#if defined(FEAT_QUICKFIX)\n+\t\t\t    && !bt_quickfix(buf)\n+#endif\n+\t\t       )\n \t\t    break;\n \t}\n \tif (buf == NULL)\t// Still no buffer, just take one\n@@ -270,6 +284,10 @@\n \t\tbuf = curbuf->b_next;\n \t    else\n \t\tbuf = curbuf->b_prev;\n+#if defined(FEAT_QUICKFIX)\n+\t    if (bt_quickfix(buf))\n+\t\tbuf = NULL;\n+#endif\n \t}\n     }\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t    if (buf == curbuf || !buf->b_p_bl)",
                "\t\t\tbuf = NULL;\t// skip current and unlisted bufs",
                "\t\tif (buf->b_help == curbuf->b_help && buf->b_p_bl)",
                "\t\tif (buf->b_p_bl && buf != curbuf)"
            ],
            "added_lines": [
                "\t\t    // Skip current and unlisted bufs.  Also skip a quickfix",
                "\t\t    // buffer, it might be deleted soon.",
                "\t\t    if (buf == curbuf || !buf->b_p_bl",
                "#if defined(FEAT_QUICKFIX)",
                "\t\t\t    || bt_quickfix(buf)",
                "#endif",
                "\t\t\t    )",
                "\t\t\tbuf = NULL;",
                "\t\tif (buf->b_help == curbuf->b_help && buf->b_p_bl",
                "#if defined(FEAT_QUICKFIX)",
                "\t\t\t    && !bt_quickfix(buf)",
                "#endif",
                "\t\t\t   )",
                "\t\tif (buf->b_p_bl && buf != curbuf",
                "#if defined(FEAT_QUICKFIX)",
                "\t\t\t    && !bt_quickfix(buf)",
                "#endif",
                "\t\t       )",
                "#if defined(FEAT_QUICKFIX)",
                "\t    if (bt_quickfix(buf))",
                "\t\tbuf = NULL;",
                "#endif"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-0685",
        "func_name": "vim/unix_expandpath",
        "description": "Use of Out-of-range Pointer Offset in GitHub repository vim/vim prior to 8.2.4418.",
        "git_url": "https://github.com/vim/vim/commit/5921aeb5741fc6e84c870d68c7c35b93ad0c9f87",
        "commit_title": "patch 8.2.4418: crash when using special multi-byte character",
        "commit_text": " Problem:    Crash when using special multi-byte character. Solution:   Don't use isalpha() for an arbitrary character.",
        "func_before": "int\nunix_expandpath(\n    garray_T\t*gap,\n    char_u\t*path,\n    int\t\twildoff,\n    int\t\tflags,\t\t// EW_* flags\n    int\t\tdidstar)\t// expanded \"**\" once already\n{\n    char_u\t*buf;\n    char_u\t*path_end;\n    char_u\t*p, *s, *e;\n    int\t\tstart_len = gap->ga_len;\n    char_u\t*pat;\n    regmatch_T\tregmatch;\n    int\t\tstarts_with_dot;\n    int\t\tmatches;\n    int\t\tlen;\n    int\t\tstarstar = FALSE;\n    static int\tstardepth = 0;\t    // depth for \"**\" expansion\n\n    DIR\t\t*dirp;\n    struct dirent *dp;\n\n    // Expanding \"**\" may take a long time, check for CTRL-C.\n    if (stardepth > 0)\n    {\n\tui_breakcheck();\n\tif (got_int)\n\t    return 0;\n    }\n\n    // make room for file name\n    buf = alloc(STRLEN(path) + BASENAMELEN + 5);\n    if (buf == NULL)\n\treturn 0;\n\n    /*\n     * Find the first part in the path name that contains a wildcard.\n     * When EW_ICASE is set every letter is considered to be a wildcard.\n     * Copy it into \"buf\", including the preceding characters.\n     */\n    p = buf;\n    s = buf;\n    e = NULL;\n    path_end = path;\n    while (*path_end != NUL)\n    {\n\t// May ignore a wildcard that has a backslash before it; it will\n\t// be removed by rem_backslash() or file_pat_to_reg_pat() below.\n\tif (path_end >= path + wildoff && rem_backslash(path_end))\n\t    *p++ = *path_end++;\n\telse if (*path_end == '/')\n\t{\n\t    if (e != NULL)\n\t\tbreak;\n\t    s = p + 1;\n\t}\n\telse if (path_end >= path + wildoff\n\t\t\t && (vim_strchr((char_u *)\"*?[{~$\", *path_end) != NULL\n\t\t\t     || (!p_fic && (flags & EW_ICASE)\n\t\t\t\t\t     && isalpha(PTR2CHAR(path_end)))))\n\t    e = p;\n\tif (has_mbyte)\n\t{\n\t    len = (*mb_ptr2len)(path_end);\n\t    STRNCPY(p, path_end, len);\n\t    p += len;\n\t    path_end += len;\n\t}\n\telse\n\t    *p++ = *path_end++;\n    }\n    e = p;\n    *e = NUL;\n\n    // Now we have one wildcard component between \"s\" and \"e\".\n    // Remove backslashes between \"wildoff\" and the start of the wildcard\n    // component.\n    for (p = buf + wildoff; p < s; ++p)\n\tif (rem_backslash(p))\n\t{\n\t    STRMOVE(p, p + 1);\n\t    --e;\n\t    --s;\n\t}\n\n    // Check for \"**\" between \"s\" and \"e\".\n    for (p = s; p < e; ++p)\n\tif (p[0] == '*' && p[1] == '*')\n\t    starstar = TRUE;\n\n    // convert the file pattern to a regexp pattern\n    starts_with_dot = *s == '.';\n    pat = file_pat_to_reg_pat(s, e, NULL, FALSE);\n    if (pat == NULL)\n    {\n\tvim_free(buf);\n\treturn 0;\n    }\n\n    // compile the regexp into a program\n    if (flags & EW_ICASE)\n\tregmatch.rm_ic = TRUE;\t\t// 'wildignorecase' set\n    else\n\tregmatch.rm_ic = p_fic;\t// ignore case when 'fileignorecase' is set\n    if (flags & (EW_NOERROR | EW_NOTWILD))\n\t++emsg_silent;\n    regmatch.regprog = vim_regcomp(pat, RE_MAGIC);\n    if (flags & (EW_NOERROR | EW_NOTWILD))\n\t--emsg_silent;\n    vim_free(pat);\n\n    if (regmatch.regprog == NULL && (flags & EW_NOTWILD) == 0)\n    {\n\tvim_free(buf);\n\treturn 0;\n    }\n\n    // If \"**\" is by itself, this is the first time we encounter it and more\n    // is following then find matches without any directory.\n    if (!didstar && stardepth < 100 && starstar && e - s == 2\n\t\t\t\t\t\t\t  && *path_end == '/')\n    {\n\tSTRCPY(s, path_end + 1);\n\t++stardepth;\n\t(void)unix_expandpath(gap, buf, (int)(s - buf), flags, TRUE);\n\t--stardepth;\n    }\n\n    // open the directory for scanning\n    *s = NUL;\n    dirp = opendir(*buf == NUL ? \".\" : (char *)buf);\n\n    // Find all matching entries\n    if (dirp != NULL)\n    {\n\tfor (;;)\n\t{\n\t    dp = readdir(dirp);\n\t    if (dp == NULL)\n\t\tbreak;\n\t    if ((dp->d_name[0] != '.' || starts_with_dot\n\t\t\t|| ((flags & EW_DODOT)\n\t\t\t    && dp->d_name[1] != NUL\n\t\t\t    && (dp->d_name[1] != '.' || dp->d_name[2] != NUL)))\n\t\t && ((regmatch.regprog != NULL && vim_regexec(&regmatch,\n\t\t\t\t\t     (char_u *)dp->d_name, (colnr_T)0))\n\t\t   || ((flags & EW_NOTWILD)\n\t\t     && fnamencmp(path + (s - buf), dp->d_name, e - s) == 0)))\n\t    {\n\t\tSTRCPY(s, dp->d_name);\n\t\tlen = STRLEN(buf);\n\n\t\tif (starstar && stardepth < 100)\n\t\t{\n\t\t    // For \"**\" in the pattern first go deeper in the tree to\n\t\t    // find matches.\n\t\t    STRCPY(buf + len, \"/**\");\n\t\t    STRCPY(buf + len + 3, path_end);\n\t\t    ++stardepth;\n\t\t    (void)unix_expandpath(gap, buf, len + 1, flags, TRUE);\n\t\t    --stardepth;\n\t\t}\n\n\t\tSTRCPY(buf + len, path_end);\n\t\tif (mch_has_exp_wildcard(path_end)) // handle more wildcards\n\t\t{\n\t\t    // need to expand another component of the path\n\t\t    // remove backslashes for the remaining components only\n\t\t    (void)unix_expandpath(gap, buf, len + 1, flags, FALSE);\n\t\t}\n\t\telse\n\t\t{\n\t\t    stat_T  sb;\n\n\t\t    // no more wildcards, check if there is a match\n\t\t    // remove backslashes for the remaining components only\n\t\t    if (*path_end != NUL)\n\t\t\tbackslash_halve(buf + len + 1);\n\t\t    // add existing file or symbolic link\n\t\t    if ((flags & EW_ALLLINKS) ? mch_lstat((char *)buf, &sb) >= 0\n\t\t\t\t\t\t      : mch_getperm(buf) >= 0)\n\t\t    {\n#ifdef MACOS_CONVERT\n\t\t\tsize_t precomp_len = STRLEN(buf)+1;\n\t\t\tchar_u *precomp_buf =\n\t\t\t    mac_precompose_path(buf, precomp_len, &precomp_len);\n\n\t\t\tif (precomp_buf)\n\t\t\t{\n\t\t\t    mch_memmove(buf, precomp_buf, precomp_len);\n\t\t\t    vim_free(precomp_buf);\n\t\t\t}\n#endif\n\t\t\taddfile(gap, buf, flags);\n\t\t    }\n\t\t}\n\t    }\n\t}\n\n\tclosedir(dirp);\n    }\n\n    vim_free(buf);\n    vim_regfree(regmatch.regprog);\n\n    matches = gap->ga_len - start_len;\n    if (matches > 0)\n\tqsort(((char_u **)gap->ga_data) + start_len, matches,\n\t\t\t\t\t\t   sizeof(char_u *), pstrcmp);\n    return matches;\n}",
        "func": "int\nunix_expandpath(\n    garray_T\t*gap,\n    char_u\t*path,\n    int\t\twildoff,\n    int\t\tflags,\t\t// EW_* flags\n    int\t\tdidstar)\t// expanded \"**\" once already\n{\n    char_u\t*buf;\n    char_u\t*path_end;\n    char_u\t*p, *s, *e;\n    int\t\tstart_len = gap->ga_len;\n    char_u\t*pat;\n    regmatch_T\tregmatch;\n    int\t\tstarts_with_dot;\n    int\t\tmatches;\n    int\t\tlen;\n    int\t\tstarstar = FALSE;\n    static int\tstardepth = 0;\t    // depth for \"**\" expansion\n\n    DIR\t\t*dirp;\n    struct dirent *dp;\n\n    // Expanding \"**\" may take a long time, check for CTRL-C.\n    if (stardepth > 0)\n    {\n\tui_breakcheck();\n\tif (got_int)\n\t    return 0;\n    }\n\n    // make room for file name\n    buf = alloc(STRLEN(path) + BASENAMELEN + 5);\n    if (buf == NULL)\n\treturn 0;\n\n    /*\n     * Find the first part in the path name that contains a wildcard.\n     * When EW_ICASE is set every letter is considered to be a wildcard.\n     * Copy it into \"buf\", including the preceding characters.\n     */\n    p = buf;\n    s = buf;\n    e = NULL;\n    path_end = path;\n    while (*path_end != NUL)\n    {\n\t// May ignore a wildcard that has a backslash before it; it will\n\t// be removed by rem_backslash() or file_pat_to_reg_pat() below.\n\tif (path_end >= path + wildoff && rem_backslash(path_end))\n\t    *p++ = *path_end++;\n\telse if (*path_end == '/')\n\t{\n\t    if (e != NULL)\n\t\tbreak;\n\t    s = p + 1;\n\t}\n\telse if (path_end >= path + wildoff\n\t\t\t && (vim_strchr((char_u *)\"*?[{~$\", *path_end) != NULL\n\t\t\t     || (!p_fic && (flags & EW_ICASE)\n\t\t\t\t\t  && vim_isalpha(PTR2CHAR(path_end)))))\n\t    e = p;\n\tif (has_mbyte)\n\t{\n\t    len = (*mb_ptr2len)(path_end);\n\t    STRNCPY(p, path_end, len);\n\t    p += len;\n\t    path_end += len;\n\t}\n\telse\n\t    *p++ = *path_end++;\n    }\n    e = p;\n    *e = NUL;\n\n    // Now we have one wildcard component between \"s\" and \"e\".\n    // Remove backslashes between \"wildoff\" and the start of the wildcard\n    // component.\n    for (p = buf + wildoff; p < s; ++p)\n\tif (rem_backslash(p))\n\t{\n\t    STRMOVE(p, p + 1);\n\t    --e;\n\t    --s;\n\t}\n\n    // Check for \"**\" between \"s\" and \"e\".\n    for (p = s; p < e; ++p)\n\tif (p[0] == '*' && p[1] == '*')\n\t    starstar = TRUE;\n\n    // convert the file pattern to a regexp pattern\n    starts_with_dot = *s == '.';\n    pat = file_pat_to_reg_pat(s, e, NULL, FALSE);\n    if (pat == NULL)\n    {\n\tvim_free(buf);\n\treturn 0;\n    }\n\n    // compile the regexp into a program\n    if (flags & EW_ICASE)\n\tregmatch.rm_ic = TRUE;\t\t// 'wildignorecase' set\n    else\n\tregmatch.rm_ic = p_fic;\t// ignore case when 'fileignorecase' is set\n    if (flags & (EW_NOERROR | EW_NOTWILD))\n\t++emsg_silent;\n    regmatch.regprog = vim_regcomp(pat, RE_MAGIC);\n    if (flags & (EW_NOERROR | EW_NOTWILD))\n\t--emsg_silent;\n    vim_free(pat);\n\n    if (regmatch.regprog == NULL && (flags & EW_NOTWILD) == 0)\n    {\n\tvim_free(buf);\n\treturn 0;\n    }\n\n    // If \"**\" is by itself, this is the first time we encounter it and more\n    // is following then find matches without any directory.\n    if (!didstar && stardepth < 100 && starstar && e - s == 2\n\t\t\t\t\t\t\t  && *path_end == '/')\n    {\n\tSTRCPY(s, path_end + 1);\n\t++stardepth;\n\t(void)unix_expandpath(gap, buf, (int)(s - buf), flags, TRUE);\n\t--stardepth;\n    }\n\n    // open the directory for scanning\n    *s = NUL;\n    dirp = opendir(*buf == NUL ? \".\" : (char *)buf);\n\n    // Find all matching entries\n    if (dirp != NULL)\n    {\n\tfor (;;)\n\t{\n\t    dp = readdir(dirp);\n\t    if (dp == NULL)\n\t\tbreak;\n\t    if ((dp->d_name[0] != '.' || starts_with_dot\n\t\t\t|| ((flags & EW_DODOT)\n\t\t\t    && dp->d_name[1] != NUL\n\t\t\t    && (dp->d_name[1] != '.' || dp->d_name[2] != NUL)))\n\t\t && ((regmatch.regprog != NULL && vim_regexec(&regmatch,\n\t\t\t\t\t     (char_u *)dp->d_name, (colnr_T)0))\n\t\t   || ((flags & EW_NOTWILD)\n\t\t     && fnamencmp(path + (s - buf), dp->d_name, e - s) == 0)))\n\t    {\n\t\tSTRCPY(s, dp->d_name);\n\t\tlen = STRLEN(buf);\n\n\t\tif (starstar && stardepth < 100)\n\t\t{\n\t\t    // For \"**\" in the pattern first go deeper in the tree to\n\t\t    // find matches.\n\t\t    STRCPY(buf + len, \"/**\");\n\t\t    STRCPY(buf + len + 3, path_end);\n\t\t    ++stardepth;\n\t\t    (void)unix_expandpath(gap, buf, len + 1, flags, TRUE);\n\t\t    --stardepth;\n\t\t}\n\n\t\tSTRCPY(buf + len, path_end);\n\t\tif (mch_has_exp_wildcard(path_end)) // handle more wildcards\n\t\t{\n\t\t    // need to expand another component of the path\n\t\t    // remove backslashes for the remaining components only\n\t\t    (void)unix_expandpath(gap, buf, len + 1, flags, FALSE);\n\t\t}\n\t\telse\n\t\t{\n\t\t    stat_T  sb;\n\n\t\t    // no more wildcards, check if there is a match\n\t\t    // remove backslashes for the remaining components only\n\t\t    if (*path_end != NUL)\n\t\t\tbackslash_halve(buf + len + 1);\n\t\t    // add existing file or symbolic link\n\t\t    if ((flags & EW_ALLLINKS) ? mch_lstat((char *)buf, &sb) >= 0\n\t\t\t\t\t\t      : mch_getperm(buf) >= 0)\n\t\t    {\n#ifdef MACOS_CONVERT\n\t\t\tsize_t precomp_len = STRLEN(buf)+1;\n\t\t\tchar_u *precomp_buf =\n\t\t\t    mac_precompose_path(buf, precomp_len, &precomp_len);\n\n\t\t\tif (precomp_buf)\n\t\t\t{\n\t\t\t    mch_memmove(buf, precomp_buf, precomp_len);\n\t\t\t    vim_free(precomp_buf);\n\t\t\t}\n#endif\n\t\t\taddfile(gap, buf, flags);\n\t\t    }\n\t\t}\n\t    }\n\t}\n\n\tclosedir(dirp);\n    }\n\n    vim_free(buf);\n    vim_regfree(regmatch.regprog);\n\n    matches = gap->ga_len - start_len;\n    if (matches > 0)\n\tqsort(((char_u **)gap->ga_data) + start_len, matches,\n\t\t\t\t\t\t   sizeof(char_u *), pstrcmp);\n    return matches;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -58,7 +58,7 @@\n \telse if (path_end >= path + wildoff\n \t\t\t && (vim_strchr((char_u *)\"*?[{~$\", *path_end) != NULL\n \t\t\t     || (!p_fic && (flags & EW_ICASE)\n-\t\t\t\t\t     && isalpha(PTR2CHAR(path_end)))))\n+\t\t\t\t\t  && vim_isalpha(PTR2CHAR(path_end)))))\n \t    e = p;\n \tif (has_mbyte)\n \t{",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\t\t\t     && isalpha(PTR2CHAR(path_end)))))"
            ],
            "added_lines": [
                "\t\t\t\t\t  && vim_isalpha(PTR2CHAR(path_end)))))"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-1420",
        "func_name": "vim/eval_lambda",
        "description": "Use of Out-of-range Pointer Offset in GitHub repository vim/vim prior to 8.2.4774.",
        "git_url": "https://github.com/vim/vim/commit/8b91e71441069b1dde9ac9ff9d9a829b1b4aecca",
        "commit_title": "patch 8.2.4774: crash when using a number for lambda name",
        "commit_text": " Problem:    Crash when using a number for lambda name. Solution:   Check the type of the lambda reference.",
        "func_before": "static int\neval_lambda(\n    char_u\t**arg,\n    typval_T\t*rettv,\n    evalarg_T\t*evalarg,\n    int\t\tverbose)\t// give error messages\n{\n    int\t\tevaluate = evalarg != NULL\n\t\t\t\t      && (evalarg->eval_flags & EVAL_EVALUATE);\n    typval_T\tbase = *rettv;\n    int\t\tret;\n\n    rettv->v_type = VAR_UNKNOWN;\n\n    if (**arg == '{')\n    {\n\t// ->{lambda}()\n\tret = get_lambda_tv(arg, rettv, FALSE, evalarg);\n    }\n    else\n    {\n\t// ->(lambda)()\n\t++*arg;\n\tret = eval1(arg, rettv, evalarg);\n\t*arg = skipwhite_and_linebreak(*arg, evalarg);\n\tif (**arg == ')')\n\t{\n\t    ++*arg;\n\t}\n\telse\n\t{\n\t    emsg(_(e_missing_closing_paren));\n\t    ret = FAIL;\n\t}\n    }\n    if (ret != OK)\n\treturn FAIL;\n    else if (**arg != '(')\n    {\n\tif (verbose)\n\t{\n\t    if (*skipwhite(*arg) == '(')\n\t\temsg(_(e_no_white_space_allowed_before_parenthesis));\n\t    else\n\t\tsemsg(_(e_missing_parenthesis_str), \"lambda\");\n\t}\n\tclear_tv(rettv);\n\tret = FAIL;\n    }\n    else\n\tret = call_func_rettv(arg, evalarg, rettv, evaluate, NULL, &base);\n\n    // Clear the funcref afterwards, so that deleting it while\n    // evaluating the arguments is possible (see test55).\n    if (evaluate)\n\tclear_tv(&base);\n\n    return ret;\n}",
        "func": "static int\neval_lambda(\n    char_u\t**arg,\n    typval_T\t*rettv,\n    evalarg_T\t*evalarg,\n    int\t\tverbose)\t// give error messages\n{\n    int\t\tevaluate = evalarg != NULL\n\t\t\t\t      && (evalarg->eval_flags & EVAL_EVALUATE);\n    typval_T\tbase = *rettv;\n    int\t\tret;\n\n    rettv->v_type = VAR_UNKNOWN;\n\n    if (**arg == '{')\n    {\n\t// ->{lambda}()\n\tret = get_lambda_tv(arg, rettv, FALSE, evalarg);\n    }\n    else\n    {\n\t// ->(lambda)()\n\t++*arg;\n\tret = eval1(arg, rettv, evalarg);\n\t*arg = skipwhite_and_linebreak(*arg, evalarg);\n\tif (**arg != ')')\n\t{\n\t    emsg(_(e_missing_closing_paren));\n\t    return FAIL;\n\t}\n\tif (rettv->v_type != VAR_STRING && rettv->v_type != VAR_FUNC\n\t\t\t\t\t       && rettv->v_type != VAR_PARTIAL)\n\t{\n\t    emsg(_(e_string_or_function_required_for_arrow_parens_expr));\n\t    return FAIL;\n\t}\n\t++*arg;\n    }\n    if (ret != OK)\n\treturn FAIL;\n\n    if (**arg != '(')\n    {\n\tif (verbose)\n\t{\n\t    if (*skipwhite(*arg) == '(')\n\t\temsg(_(e_no_white_space_allowed_before_parenthesis));\n\t    else\n\t\tsemsg(_(e_missing_parenthesis_str), \"lambda\");\n\t}\n\tclear_tv(rettv);\n\tret = FAIL;\n    }\n    else\n\tret = call_func_rettv(arg, evalarg, rettv, evaluate, NULL, &base);\n\n    // Clear the funcref afterwards, so that deleting it while\n    // evaluating the arguments is possible (see test55).\n    if (evaluate)\n\tclear_tv(&base);\n\n    return ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -23,19 +23,23 @@\n \t++*arg;\n \tret = eval1(arg, rettv, evalarg);\n \t*arg = skipwhite_and_linebreak(*arg, evalarg);\n-\tif (**arg == ')')\n-\t{\n-\t    ++*arg;\n-\t}\n-\telse\n+\tif (**arg != ')')\n \t{\n \t    emsg(_(e_missing_closing_paren));\n-\t    ret = FAIL;\n+\t    return FAIL;\n \t}\n+\tif (rettv->v_type != VAR_STRING && rettv->v_type != VAR_FUNC\n+\t\t\t\t\t       && rettv->v_type != VAR_PARTIAL)\n+\t{\n+\t    emsg(_(e_string_or_function_required_for_arrow_parens_expr));\n+\t    return FAIL;\n+\t}\n+\t++*arg;\n     }\n     if (ret != OK)\n \treturn FAIL;\n-    else if (**arg != '(')\n+\n+    if (**arg != '(')\n     {\n \tif (verbose)\n \t{",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (**arg == ')')",
                "\t{",
                "\t    ++*arg;",
                "\t}",
                "\telse",
                "\t    ret = FAIL;",
                "    else if (**arg != '(')"
            ],
            "added_lines": [
                "\tif (**arg != ')')",
                "\t    return FAIL;",
                "\tif (rettv->v_type != VAR_STRING && rettv->v_type != VAR_FUNC",
                "\t\t\t\t\t       && rettv->v_type != VAR_PARTIAL)",
                "\t{",
                "\t    emsg(_(e_string_or_function_required_for_arrow_parens_expr));",
                "\t    return FAIL;",
                "\t}",
                "\t++*arg;",
                "",
                "    if (**arg != '(')"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-2426",
        "func_name": "vim/vgr_match_buflines",
        "description": "Use of Out-of-range Pointer Offset in GitHub repository vim/vim prior to 9.0.1499.",
        "git_url": "https://github.com/vim/vim/commit/caf642c25de526229264cab9425e7c9979f3509b",
        "commit_title": "patch 9.0.1499: using uninitialized memory with fuzzy matching",
        "commit_text": " Problem:    Using uninitialized memory with fuzzy matching. Solution:   Initialize the arrays used to store match positions.",
        "func_before": "static int\nvgr_match_buflines(\n\tqf_list_T   *qfl,\n\tchar_u\t    *fname,\n\tbuf_T\t    *buf,\n\tchar_u\t    *spat,\n\tregmmatch_T *regmatch,\n\tlong\t    *tomatch,\n\tint\t    duplicate_name,\n\tint\t    flags)\n{\n    int\t\tfound_match = FALSE;\n    long\tlnum;\n    colnr_T\tcol;\n    int\t\tpat_len = (int)STRLEN(spat);\n\n    for (lnum = 1; lnum <= buf->b_ml.ml_line_count && *tomatch > 0; ++lnum)\n    {\n\tcol = 0;\n\tif (!(flags & VGR_FUZZY))\n\t{\n\t    // Regular expression match\n\t    while (vim_regexec_multi(regmatch, curwin, buf, lnum,\n\t\t\tcol, NULL) > 0)\n\t    {\n\t\t// Pass the buffer number so that it gets used even for a\n\t\t// dummy buffer, unless duplicate_name is set, then the\n\t\t// buffer will be wiped out below.\n\t\tif (qf_add_entry(qfl,\n\t\t\t    NULL,\t// dir\n\t\t\t    fname,\n\t\t\t    NULL,\n\t\t\t    duplicate_name ? 0 : buf->b_fnum,\n\t\t\t    ml_get_buf(buf,\n\t\t\t\tregmatch->startpos[0].lnum + lnum, FALSE),\n\t\t\t    regmatch->startpos[0].lnum + lnum,\n\t\t\t    regmatch->endpos[0].lnum + lnum,\n\t\t\t    regmatch->startpos[0].col + 1,\n\t\t\t    regmatch->endpos[0].col + 1,\n\t\t\t    FALSE,\t// vis_col\n\t\t\t    NULL,\t// search pattern\n\t\t\t    0,\t\t// nr\n\t\t\t    0,\t\t// type\n\t\t\t    TRUE\t// valid\n\t\t\t    ) == QF_FAIL)\n\t\t{\n\t\t    got_int = TRUE;\n\t\t    break;\n\t\t}\n\t\tfound_match = TRUE;\n\t\tif (--*tomatch == 0)\n\t\t    break;\n\t\tif ((flags & VGR_GLOBAL) == 0\n\t\t\t|| regmatch->endpos[0].lnum > 0)\n\t\t    break;\n\t\tcol = regmatch->endpos[0].col\n\t\t    + (col == regmatch->endpos[0].col);\n\t\tif (col > (colnr_T)STRLEN(ml_get_buf(buf, lnum, FALSE)))\n\t\t    break;\n\t    }\n\t}\n\telse\n\t{\n\t    char_u  *str = ml_get_buf(buf, lnum, FALSE);\n\t    int\t    score;\n\t    int_u   matches[MAX_FUZZY_MATCHES];\n\t    int_u   sz = ARRAY_LENGTH(matches);\n\n\t    // Fuzzy string match\n\t    while (fuzzy_match(str + col, spat, FALSE, &score, matches, sz) > 0)\n\t    {\n\t\t// Pass the buffer number so that it gets used even for a\n\t\t// dummy buffer, unless duplicate_name is set, then the\n\t\t// buffer will be wiped out below.\n\t\tif (qf_add_entry(qfl,\n\t\t\t    NULL,\t// dir\n\t\t\t    fname,\n\t\t\t    NULL,\n\t\t\t    duplicate_name ? 0 : buf->b_fnum,\n\t\t\t    str,\n\t\t\t    lnum,\n\t\t\t    0,\n\t\t\t    matches[0] + col + 1,\n\t\t\t    0,\n\t\t\t    FALSE,\t// vis_col\n\t\t\t    NULL,\t// search pattern\n\t\t\t    0,\t\t// nr\n\t\t\t    0,\t\t// type\n\t\t\t    TRUE\t// valid\n\t\t\t    ) == QF_FAIL)\n\t\t{\n\t\t    got_int = TRUE;\n\t\t    break;\n\t\t}\n\t\tfound_match = TRUE;\n\t\tif (--*tomatch == 0)\n\t\t    break;\n\t\tif ((flags & VGR_GLOBAL) == 0)\n\t\t    break;\n\t\tcol = matches[pat_len - 1] + col + 1;\n\t\tif (col > (colnr_T)STRLEN(str))\n\t\t    break;\n\t    }\n\t}\n\tline_breakcheck();\n\tif (got_int)\n\t    break;\n    }\n\n    return found_match;\n}",
        "func": "static int\nvgr_match_buflines(\n\tqf_list_T   *qfl,\n\tchar_u\t    *fname,\n\tbuf_T\t    *buf,\n\tchar_u\t    *spat,\n\tregmmatch_T *regmatch,\n\tlong\t    *tomatch,\n\tint\t    duplicate_name,\n\tint\t    flags)\n{\n    int\t\tfound_match = FALSE;\n    long\tlnum;\n    colnr_T\tcol;\n    int\t\tpat_len = (int)STRLEN(spat);\n    if (pat_len > MAX_FUZZY_MATCHES)\n\tpat_len = MAX_FUZZY_MATCHES;\n\n    for (lnum = 1; lnum <= buf->b_ml.ml_line_count && *tomatch > 0; ++lnum)\n    {\n\tcol = 0;\n\tif (!(flags & VGR_FUZZY))\n\t{\n\t    // Regular expression match\n\t    while (vim_regexec_multi(regmatch, curwin, buf, lnum,\n\t\t\t\t\t\t\t\tcol, NULL) > 0)\n\t    {\n\t\t// Pass the buffer number so that it gets used even for a\n\t\t// dummy buffer, unless duplicate_name is set, then the\n\t\t// buffer will be wiped out below.\n\t\tif (qf_add_entry(qfl,\n\t\t\t    NULL,\t// dir\n\t\t\t    fname,\n\t\t\t    NULL,\n\t\t\t    duplicate_name ? 0 : buf->b_fnum,\n\t\t\t    ml_get_buf(buf,\n\t\t\t\tregmatch->startpos[0].lnum + lnum, FALSE),\n\t\t\t    regmatch->startpos[0].lnum + lnum,\n\t\t\t    regmatch->endpos[0].lnum + lnum,\n\t\t\t    regmatch->startpos[0].col + 1,\n\t\t\t    regmatch->endpos[0].col + 1,\n\t\t\t    FALSE,\t// vis_col\n\t\t\t    NULL,\t// search pattern\n\t\t\t    0,\t\t// nr\n\t\t\t    0,\t\t// type\n\t\t\t    TRUE\t// valid\n\t\t\t    ) == QF_FAIL)\n\t\t{\n\t\t    got_int = TRUE;\n\t\t    break;\n\t\t}\n\t\tfound_match = TRUE;\n\t\tif (--*tomatch == 0)\n\t\t    break;\n\t\tif ((flags & VGR_GLOBAL) == 0\n\t\t\t|| regmatch->endpos[0].lnum > 0)\n\t\t    break;\n\t\tcol = regmatch->endpos[0].col\n\t\t    + (col == regmatch->endpos[0].col);\n\t\tif (col > (colnr_T)STRLEN(ml_get_buf(buf, lnum, FALSE)))\n\t\t    break;\n\t    }\n\t}\n\telse\n\t{\n\t    char_u  *str = ml_get_buf(buf, lnum, FALSE);\n\t    int\t    score;\n\t    int_u   matches[MAX_FUZZY_MATCHES];\n\t    int_u   sz = ARRAY_LENGTH(matches);\n\n\t    // Fuzzy string match\n\t    CLEAR_FIELD(matches);\n\t    while (fuzzy_match(str + col, spat, FALSE, &score, matches, sz) > 0)\n\t    {\n\t\t// Pass the buffer number so that it gets used even for a\n\t\t// dummy buffer, unless duplicate_name is set, then the\n\t\t// buffer will be wiped out below.\n\t\tif (qf_add_entry(qfl,\n\t\t\t    NULL,\t// dir\n\t\t\t    fname,\n\t\t\t    NULL,\n\t\t\t    duplicate_name ? 0 : buf->b_fnum,\n\t\t\t    str,\n\t\t\t    lnum,\n\t\t\t    0,\n\t\t\t    matches[0] + col + 1,\n\t\t\t    0,\n\t\t\t    FALSE,\t// vis_col\n\t\t\t    NULL,\t// search pattern\n\t\t\t    0,\t\t// nr\n\t\t\t    0,\t\t// type\n\t\t\t    TRUE\t// valid\n\t\t\t    ) == QF_FAIL)\n\t\t{\n\t\t    got_int = TRUE;\n\t\t    break;\n\t\t}\n\t\tfound_match = TRUE;\n\t\tif (--*tomatch == 0)\n\t\t    break;\n\t\tif ((flags & VGR_GLOBAL) == 0)\n\t\t    break;\n\t\tcol = matches[pat_len - 1] + col + 1;\n\t\tif (col > (colnr_T)STRLEN(str))\n\t\t    break;\n\t    }\n\t}\n\tline_breakcheck();\n\tif (got_int)\n\t    break;\n    }\n\n    return found_match;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -13,6 +13,8 @@\n     long\tlnum;\n     colnr_T\tcol;\n     int\t\tpat_len = (int)STRLEN(spat);\n+    if (pat_len > MAX_FUZZY_MATCHES)\n+\tpat_len = MAX_FUZZY_MATCHES;\n \n     for (lnum = 1; lnum <= buf->b_ml.ml_line_count && *tomatch > 0; ++lnum)\n     {\n@@ -21,7 +23,7 @@\n \t{\n \t    // Regular expression match\n \t    while (vim_regexec_multi(regmatch, curwin, buf, lnum,\n-\t\t\tcol, NULL) > 0)\n+\t\t\t\t\t\t\t\tcol, NULL) > 0)\n \t    {\n \t\t// Pass the buffer number so that it gets used even for a\n \t\t// dummy buffer, unless duplicate_name is set, then the\n@@ -67,6 +69,7 @@\n \t    int_u   sz = ARRAY_LENGTH(matches);\n \n \t    // Fuzzy string match\n+\t    CLEAR_FIELD(matches);\n \t    while (fuzzy_match(str + col, spat, FALSE, &score, matches, sz) > 0)\n \t    {\n \t\t// Pass the buffer number so that it gets used even for a",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\tcol, NULL) > 0)"
            ],
            "added_lines": [
                "    if (pat_len > MAX_FUZZY_MATCHES)",
                "\tpat_len = MAX_FUZZY_MATCHES;",
                "\t\t\t\t\t\t\t\tcol, NULL) > 0)",
                "\t    CLEAR_FIELD(matches);"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-2426",
        "func_name": "vim/fuzzy_match_recursive",
        "description": "Use of Out-of-range Pointer Offset in GitHub repository vim/vim prior to 9.0.1499.",
        "git_url": "https://github.com/vim/vim/commit/caf642c25de526229264cab9425e7c9979f3509b",
        "commit_title": "patch 9.0.1499: using uninitialized memory with fuzzy matching",
        "commit_text": " Problem:    Using uninitialized memory with fuzzy matching. Solution:   Initialize the arrays used to store match positions.",
        "func_before": "static int\nfuzzy_match_recursive(\n\tchar_u\t\t*fuzpat,\n\tchar_u\t\t*str,\n\tint_u\t\tstrIdx,\n\tint\t\t*outScore,\n\tchar_u\t\t*strBegin,\n\tint\t\tstrLen,\n\tint_u\t\t*srcMatches,\n\tint_u\t\t*matches,\n\tint\t\tmaxMatches,\n\tint\t\tnextMatch,\n\tint\t\t*recursionCount)\n{\n    // Recursion params\n    int\t\trecursiveMatch = FALSE;\n    int_u\tbestRecursiveMatches[MAX_FUZZY_MATCHES];\n    int\t\tbestRecursiveScore = 0;\n    int\t\tfirst_match;\n    int\t\tmatched;\n\n    // Count recursions\n    ++*recursionCount;\n    if (*recursionCount >= FUZZY_MATCH_RECURSION_LIMIT)\n\treturn 0;\n\n    // Detect end of strings\n    if (*fuzpat == NUL || *str == NUL)\n\treturn 0;\n\n    // Loop through fuzpat and str looking for a match\n    first_match = TRUE;\n    while (*fuzpat != NUL && *str != NUL)\n    {\n\tint\tc1;\n\tint\tc2;\n\n\tc1 = PTR2CHAR(fuzpat);\n\tc2 = PTR2CHAR(str);\n\n\t// Found match\n\tif (vim_tolower(c1) == vim_tolower(c2))\n\t{\n\t    int_u\trecursiveMatches[MAX_FUZZY_MATCHES];\n\t    int\t\trecursiveScore = 0;\n\t    char_u\t*next_char;\n\n\t    // Supplied matches buffer was too short\n\t    if (nextMatch >= maxMatches)\n\t\treturn 0;\n\n\t    // \"Copy-on-Write\" srcMatches into matches\n\t    if (first_match && srcMatches)\n\t    {\n\t\tmemcpy(matches, srcMatches, nextMatch * sizeof(srcMatches[0]));\n\t\tfirst_match = FALSE;\n\t    }\n\n\t    // Recursive call that \"skips\" this match\n\t    if (has_mbyte)\n\t\tnext_char = str + (*mb_ptr2len)(str);\n\t    else\n\t\tnext_char = str + 1;\n\t    if (fuzzy_match_recursive(fuzpat, next_char, strIdx + 1,\n\t\t\t&recursiveScore, strBegin, strLen, matches,\n\t\t\trecursiveMatches,\n\t\t\tARRAY_LENGTH(recursiveMatches),\n\t\t\tnextMatch, recursionCount))\n\t    {\n\t\t// Pick best recursive score\n\t\tif (!recursiveMatch || recursiveScore > bestRecursiveScore)\n\t\t{\n\t\t    memcpy(bestRecursiveMatches, recursiveMatches,\n\t\t\t    MAX_FUZZY_MATCHES * sizeof(recursiveMatches[0]));\n\t\t    bestRecursiveScore = recursiveScore;\n\t\t}\n\t\trecursiveMatch = TRUE;\n\t    }\n\n\t    // Advance\n\t    matches[nextMatch++] = strIdx;\n\t    if (has_mbyte)\n\t\tMB_PTR_ADV(fuzpat);\n\t    else\n\t\t++fuzpat;\n\t}\n\tif (has_mbyte)\n\t    MB_PTR_ADV(str);\n\telse\n\t    ++str;\n\tstrIdx++;\n    }\n\n    // Determine if full fuzpat was matched\n    matched = *fuzpat == NUL ? TRUE : FALSE;\n\n    // Calculate score\n    if (matched)\n\t*outScore = fuzzy_match_compute_score(strBegin, strLen, matches,\n\t\tnextMatch);\n\n    // Return best result\n    if (recursiveMatch && (!matched || bestRecursiveScore > *outScore))\n    {\n\t// Recursive score is better than \"this\"\n\tmemcpy(matches, bestRecursiveMatches, maxMatches * sizeof(matches[0]));\n\t*outScore = bestRecursiveScore;\n\treturn nextMatch;\n    }\n    else if (matched)\n\treturn nextMatch;\t// \"this\" score is better than recursive\n\n    return 0;\t\t// no match\n}",
        "func": "static int\nfuzzy_match_recursive(\n\tchar_u\t\t*fuzpat,\n\tchar_u\t\t*str,\n\tint_u\t\tstrIdx,\n\tint\t\t*outScore,\n\tchar_u\t\t*strBegin,\n\tint\t\tstrLen,\n\tint_u\t\t*srcMatches,\n\tint_u\t\t*matches,\n\tint\t\tmaxMatches,\n\tint\t\tnextMatch,\n\tint\t\t*recursionCount)\n{\n    // Recursion params\n    int\t\trecursiveMatch = FALSE;\n    int_u\tbestRecursiveMatches[MAX_FUZZY_MATCHES];\n    int\t\tbestRecursiveScore = 0;\n    int\t\tfirst_match;\n    int\t\tmatched;\n\n    // Count recursions\n    ++*recursionCount;\n    if (*recursionCount >= FUZZY_MATCH_RECURSION_LIMIT)\n\treturn 0;\n\n    // Detect end of strings\n    if (*fuzpat == NUL || *str == NUL)\n\treturn 0;\n\n    // Loop through fuzpat and str looking for a match\n    first_match = TRUE;\n    while (*fuzpat != NUL && *str != NUL)\n    {\n\tint\tc1;\n\tint\tc2;\n\n\tc1 = PTR2CHAR(fuzpat);\n\tc2 = PTR2CHAR(str);\n\n\t// Found match\n\tif (vim_tolower(c1) == vim_tolower(c2))\n\t{\n\t    // Supplied matches buffer was too short\n\t    if (nextMatch >= maxMatches)\n\t\treturn 0;\n\n\t    int\t\trecursiveScore = 0;\n\t    int_u\trecursiveMatches[MAX_FUZZY_MATCHES];\n\t    CLEAR_FIELD(recursiveMatches);\n\n\t    // \"Copy-on-Write\" srcMatches into matches\n\t    if (first_match && srcMatches)\n\t    {\n\t\tmemcpy(matches, srcMatches, nextMatch * sizeof(srcMatches[0]));\n\t\tfirst_match = FALSE;\n\t    }\n\n\t    // Recursive call that \"skips\" this match\n\t    char_u *next_char = str + (has_mbyte ? (*mb_ptr2len)(str) : 1);\n\t    if (fuzzy_match_recursive(fuzpat, next_char, strIdx + 1,\n\t\t\t&recursiveScore, strBegin, strLen, matches,\n\t\t\trecursiveMatches,\n\t\t\tARRAY_LENGTH(recursiveMatches),\n\t\t\tnextMatch, recursionCount))\n\t    {\n\t\t// Pick best recursive score\n\t\tif (!recursiveMatch || recursiveScore > bestRecursiveScore)\n\t\t{\n\t\t    memcpy(bestRecursiveMatches, recursiveMatches,\n\t\t\t    MAX_FUZZY_MATCHES * sizeof(recursiveMatches[0]));\n\t\t    bestRecursiveScore = recursiveScore;\n\t\t}\n\t\trecursiveMatch = TRUE;\n\t    }\n\n\t    // Advance\n\t    matches[nextMatch++] = strIdx;\n\t    if (has_mbyte)\n\t\tMB_PTR_ADV(fuzpat);\n\t    else\n\t\t++fuzpat;\n\t}\n\tif (has_mbyte)\n\t    MB_PTR_ADV(str);\n\telse\n\t    ++str;\n\tstrIdx++;\n    }\n\n    // Determine if full fuzpat was matched\n    matched = *fuzpat == NUL ? TRUE : FALSE;\n\n    // Calculate score\n    if (matched)\n\t*outScore = fuzzy_match_compute_score(strBegin, strLen, matches,\n\t\tnextMatch);\n\n    // Return best result\n    if (recursiveMatch && (!matched || bestRecursiveScore > *outScore))\n    {\n\t// Recursive score is better than \"this\"\n\tmemcpy(matches, bestRecursiveMatches, maxMatches * sizeof(matches[0]));\n\t*outScore = bestRecursiveScore;\n\treturn nextMatch;\n    }\n    else if (matched)\n\treturn nextMatch;\t// \"this\" score is better than recursive\n\n    return 0;\t\t// no match\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -41,13 +41,13 @@\n \t// Found match\n \tif (vim_tolower(c1) == vim_tolower(c2))\n \t{\n-\t    int_u\trecursiveMatches[MAX_FUZZY_MATCHES];\n-\t    int\t\trecursiveScore = 0;\n-\t    char_u\t*next_char;\n-\n \t    // Supplied matches buffer was too short\n \t    if (nextMatch >= maxMatches)\n \t\treturn 0;\n+\n+\t    int\t\trecursiveScore = 0;\n+\t    int_u\trecursiveMatches[MAX_FUZZY_MATCHES];\n+\t    CLEAR_FIELD(recursiveMatches);\n \n \t    // \"Copy-on-Write\" srcMatches into matches\n \t    if (first_match && srcMatches)\n@@ -57,10 +57,7 @@\n \t    }\n \n \t    // Recursive call that \"skips\" this match\n-\t    if (has_mbyte)\n-\t\tnext_char = str + (*mb_ptr2len)(str);\n-\t    else\n-\t\tnext_char = str + 1;\n+\t    char_u *next_char = str + (has_mbyte ? (*mb_ptr2len)(str) : 1);\n \t    if (fuzzy_match_recursive(fuzpat, next_char, strIdx + 1,\n \t\t\t&recursiveScore, strBegin, strLen, matches,\n \t\t\trecursiveMatches,",
        "diff_line_info": {
            "deleted_lines": [
                "\t    int_u\trecursiveMatches[MAX_FUZZY_MATCHES];",
                "\t    int\t\trecursiveScore = 0;",
                "\t    char_u\t*next_char;",
                "",
                "\t    if (has_mbyte)",
                "\t\tnext_char = str + (*mb_ptr2len)(str);",
                "\t    else",
                "\t\tnext_char = str + 1;"
            ],
            "added_lines": [
                "",
                "\t    int\t\trecursiveScore = 0;",
                "\t    int_u\trecursiveMatches[MAX_FUZZY_MATCHES];",
                "\t    CLEAR_FIELD(recursiveMatches);",
                "\t    char_u *next_char = str + (has_mbyte ? (*mb_ptr2len)(str) : 1);"
            ]
        }
    }
]