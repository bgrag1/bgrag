[
    {
        "cve_id": "CVE-2016-2496",
        "func_name": "android/InputDispatcher::findTouchedWindowTargetsLocked",
        "description": "The Framework UI permission-dialog implementation in Android 6.x before 2016-06-01 allows attackers to conduct tapjacking attacks and access arbitrary private-storage files by creating a partially overlapping window, aka internal bug 26677796.",
        "git_url": "https://android.googlesource.com/platform/frameworks/native/+/03a53d1c7765eeb3af0bc34c3dff02ada1953fbf",
        "commit_title": "Add new MotionEvent flag for partially obscured windows.",
        "commit_text": " Due to more complex window layouts resulting in lots of overlapping windows, the policy around FLAG_WINDOW_IS_OBSCURED has changed to only be set when the point at which the window was touched is obscured. Unfortunately, this doesn't prevent tapjacking attacks that overlay the dialog's text, making a potentially dangerous operation seem innocuous. To avoid this on particularly sensitive dialogs, introduce a new flag that really does tell you when your window is being even partially overlapped.  We aren't exposing this as API since we plan on making the original flag more robust. This is really a workaround for system dialogs since we generally know their layout and screen position, and that they're unlikely to be overlapped by other applications.  Bug: 26677796 ",
        "func_before": "int32_t InputDispatcher::findTouchedWindowTargetsLocked(nsecs_t currentTime,\n        const MotionEntry* entry, Vector<InputTarget>& inputTargets, nsecs_t* nextWakeupTime,\n        bool* outConflictingPointerActions) {\n    enum InjectionPermission {\n        INJECTION_PERMISSION_UNKNOWN,\n        INJECTION_PERMISSION_GRANTED,\n        INJECTION_PERMISSION_DENIED\n    };\n\n    nsecs_t startTime = now();\n\n    // For security reasons, we defer updating the touch state until we are sure that\n    // event injection will be allowed.\n    int32_t displayId = entry->displayId;\n    int32_t action = entry->action;\n    int32_t maskedAction = action & AMOTION_EVENT_ACTION_MASK;\n\n    // Update the touch state as needed based on the properties of the touch event.\n    int32_t injectionResult = INPUT_EVENT_INJECTION_PENDING;\n    InjectionPermission injectionPermission = INJECTION_PERMISSION_UNKNOWN;\n    sp<InputWindowHandle> newHoverWindowHandle;\n\n    // Copy current touch state into mTempTouchState.\n    // This state is always reset at the end of this function, so if we don't find state\n    // for the specified display then our initial state will be empty.\n    const TouchState* oldState = NULL;\n    ssize_t oldStateIndex = mTouchStatesByDisplay.indexOfKey(displayId);\n    if (oldStateIndex >= 0) {\n        oldState = &mTouchStatesByDisplay.valueAt(oldStateIndex);\n        mTempTouchState.copyFrom(*oldState);\n    }\n\n    bool isSplit = mTempTouchState.split;\n    bool switchedDevice = mTempTouchState.deviceId >= 0 && mTempTouchState.displayId >= 0\n            && (mTempTouchState.deviceId != entry->deviceId\n                    || mTempTouchState.source != entry->source\n                    || mTempTouchState.displayId != displayId);\n    bool isHoverAction = (maskedAction == AMOTION_EVENT_ACTION_HOVER_MOVE\n            || maskedAction == AMOTION_EVENT_ACTION_HOVER_ENTER\n            || maskedAction == AMOTION_EVENT_ACTION_HOVER_EXIT);\n    bool newGesture = (maskedAction == AMOTION_EVENT_ACTION_DOWN\n            || maskedAction == AMOTION_EVENT_ACTION_SCROLL\n            || isHoverAction);\n    bool wrongDevice = false;\n    if (newGesture) {\n        bool down = maskedAction == AMOTION_EVENT_ACTION_DOWN;\n        if (switchedDevice && mTempTouchState.down && !down) {\n#if DEBUG_FOCUS\n            ALOGD(\"Dropping event because a pointer for a different device is already down.\");\n#endif\n            injectionResult = INPUT_EVENT_INJECTION_FAILED;\n            switchedDevice = false;\n            wrongDevice = true;\n            goto Failed;\n        }\n        mTempTouchState.reset();\n        mTempTouchState.down = down;\n        mTempTouchState.deviceId = entry->deviceId;\n        mTempTouchState.source = entry->source;\n        mTempTouchState.displayId = displayId;\n        isSplit = false;\n    }\n\n    if (newGesture || (isSplit && maskedAction == AMOTION_EVENT_ACTION_POINTER_DOWN)) {\n        /* Case 1: New splittable pointer going down, or need target for hover or scroll. */\n\n        int32_t pointerIndex = getMotionEventActionPointerIndex(action);\n        int32_t x = int32_t(entry->pointerCoords[pointerIndex].\n                getAxisValue(AMOTION_EVENT_AXIS_X));\n        int32_t y = int32_t(entry->pointerCoords[pointerIndex].\n                getAxisValue(AMOTION_EVENT_AXIS_Y));\n        sp<InputWindowHandle> newTouchedWindowHandle;\n        bool isTouchModal = false;\n\n        // Traverse windows from front to back to find touched window and outside targets.\n        size_t numWindows = mWindowHandles.size();\n        for (size_t i = 0; i < numWindows; i++) {\n            sp<InputWindowHandle> windowHandle = mWindowHandles.itemAt(i);\n            const InputWindowInfo* windowInfo = windowHandle->getInfo();\n            if (windowInfo->displayId != displayId) {\n                continue; // wrong display\n            }\n\n            int32_t flags = windowInfo->layoutParamsFlags;\n            if (windowInfo->visible) {\n                if (! (flags & InputWindowInfo::FLAG_NOT_TOUCHABLE)) {\n                    isTouchModal = (flags & (InputWindowInfo::FLAG_NOT_FOCUSABLE\n                            | InputWindowInfo::FLAG_NOT_TOUCH_MODAL)) == 0;\n                    if (isTouchModal || windowInfo->touchableRegionContainsPoint(x, y)) {\n                        newTouchedWindowHandle = windowHandle;\n                        break; // found touched window, exit window loop\n                    }\n                }\n\n                if (maskedAction == AMOTION_EVENT_ACTION_DOWN\n                        && (flags & InputWindowInfo::FLAG_WATCH_OUTSIDE_TOUCH)) {\n                    int32_t outsideTargetFlags = InputTarget::FLAG_DISPATCH_AS_OUTSIDE;\n                    if (isWindowObscuredAtPointLocked(windowHandle, x, y)) {\n                        outsideTargetFlags |= InputTarget::FLAG_WINDOW_IS_OBSCURED;\n                    }\n\n                    mTempTouchState.addOrUpdateWindow(\n                            windowHandle, outsideTargetFlags, BitSet32(0));\n                }\n            }\n        }\n\n        // Figure out whether splitting will be allowed for this window.\n        if (newTouchedWindowHandle != NULL\n                && newTouchedWindowHandle->getInfo()->supportsSplitTouch()) {\n            // New window supports splitting.\n            isSplit = true;\n        } else if (isSplit) {\n            // New window does not support splitting but we have already split events.\n            // Ignore the new window.\n            newTouchedWindowHandle = NULL;\n        }\n\n        // Handle the case where we did not find a window.\n        if (newTouchedWindowHandle == NULL) {\n            // Try to assign the pointer to the first foreground window we find, if there is one.\n            newTouchedWindowHandle = mTempTouchState.getFirstForegroundWindowHandle();\n            if (newTouchedWindowHandle == NULL) {\n                ALOGI(\"Dropping event because there is no touchable window at (%d, %d).\", x, y);\n                injectionResult = INPUT_EVENT_INJECTION_FAILED;\n                goto Failed;\n            }\n        }\n\n        // Set target flags.\n        int32_t targetFlags = InputTarget::FLAG_FOREGROUND | InputTarget::FLAG_DISPATCH_AS_IS;\n        if (isSplit) {\n            targetFlags |= InputTarget::FLAG_SPLIT;\n        }\n        if (isWindowObscuredAtPointLocked(newTouchedWindowHandle, x, y)) {\n            targetFlags |= InputTarget::FLAG_WINDOW_IS_OBSCURED;\n        }\n\n        // Update hover state.\n        if (isHoverAction) {\n            newHoverWindowHandle = newTouchedWindowHandle;\n        } else if (maskedAction == AMOTION_EVENT_ACTION_SCROLL) {\n            newHoverWindowHandle = mLastHoverWindowHandle;\n        }\n\n        // Update the temporary touch state.\n        BitSet32 pointerIds;\n        if (isSplit) {\n            uint32_t pointerId = entry->pointerProperties[pointerIndex].id;\n            pointerIds.markBit(pointerId);\n        }\n        mTempTouchState.addOrUpdateWindow(newTouchedWindowHandle, targetFlags, pointerIds);\n    } else {\n        /* Case 2: Pointer move, up, cancel or non-splittable pointer down. */\n\n        // If the pointer is not currently down, then ignore the event.\n        if (! mTempTouchState.down) {\n#if DEBUG_FOCUS\n            ALOGD(\"Dropping event because the pointer is not down or we previously \"\n                    \"dropped the pointer down event.\");\n#endif\n            injectionResult = INPUT_EVENT_INJECTION_FAILED;\n            goto Failed;\n        }\n\n        // Check whether touches should slip outside of the current foreground window.\n        if (maskedAction == AMOTION_EVENT_ACTION_MOVE\n                && entry->pointerCount == 1\n                && mTempTouchState.isSlippery()) {\n            int32_t x = int32_t(entry->pointerCoords[0].getAxisValue(AMOTION_EVENT_AXIS_X));\n            int32_t y = int32_t(entry->pointerCoords[0].getAxisValue(AMOTION_EVENT_AXIS_Y));\n\n            sp<InputWindowHandle> oldTouchedWindowHandle =\n                    mTempTouchState.getFirstForegroundWindowHandle();\n            sp<InputWindowHandle> newTouchedWindowHandle =\n                    findTouchedWindowAtLocked(displayId, x, y);\n            if (oldTouchedWindowHandle != newTouchedWindowHandle\n                    && newTouchedWindowHandle != NULL) {\n#if DEBUG_FOCUS\n                ALOGD(\"Touch is slipping out of window %s into window %s.\",\n                        oldTouchedWindowHandle->getName().string(),\n                        newTouchedWindowHandle->getName().string());\n#endif\n                // Make a slippery exit from the old window.\n                mTempTouchState.addOrUpdateWindow(oldTouchedWindowHandle,\n                        InputTarget::FLAG_DISPATCH_AS_SLIPPERY_EXIT, BitSet32(0));\n\n                // Make a slippery entrance into the new window.\n                if (newTouchedWindowHandle->getInfo()->supportsSplitTouch()) {\n                    isSplit = true;\n                }\n\n                int32_t targetFlags = InputTarget::FLAG_FOREGROUND\n                        | InputTarget::FLAG_DISPATCH_AS_SLIPPERY_ENTER;\n                if (isSplit) {\n                    targetFlags |= InputTarget::FLAG_SPLIT;\n                }\n                if (isWindowObscuredAtPointLocked(newTouchedWindowHandle, x, y)) {\n                    targetFlags |= InputTarget::FLAG_WINDOW_IS_OBSCURED;\n                }\n\n                BitSet32 pointerIds;\n                if (isSplit) {\n                    pointerIds.markBit(entry->pointerProperties[0].id);\n                }\n                mTempTouchState.addOrUpdateWindow(newTouchedWindowHandle, targetFlags, pointerIds);\n            }\n        }\n    }\n\n    if (newHoverWindowHandle != mLastHoverWindowHandle) {\n        // Let the previous window know that the hover sequence is over.\n        if (mLastHoverWindowHandle != NULL) {\n#if DEBUG_HOVER\n            ALOGD(\"Sending hover exit event to window %s.\",\n                    mLastHoverWindowHandle->getName().string());\n#endif\n            mTempTouchState.addOrUpdateWindow(mLastHoverWindowHandle,\n                    InputTarget::FLAG_DISPATCH_AS_HOVER_EXIT, BitSet32(0));\n        }\n\n        // Let the new window know that the hover sequence is starting.\n        if (newHoverWindowHandle != NULL) {\n#if DEBUG_HOVER\n            ALOGD(\"Sending hover enter event to window %s.\",\n                    newHoverWindowHandle->getName().string());\n#endif\n            mTempTouchState.addOrUpdateWindow(newHoverWindowHandle,\n                    InputTarget::FLAG_DISPATCH_AS_HOVER_ENTER, BitSet32(0));\n        }\n    }\n\n    // Check permission to inject into all touched foreground windows and ensure there\n    // is at least one touched foreground window.\n    {\n        bool haveForegroundWindow = false;\n        for (size_t i = 0; i < mTempTouchState.windows.size(); i++) {\n            const TouchedWindow& touchedWindow = mTempTouchState.windows[i];\n            if (touchedWindow.targetFlags & InputTarget::FLAG_FOREGROUND) {\n                haveForegroundWindow = true;\n                if (! checkInjectionPermission(touchedWindow.windowHandle,\n                        entry->injectionState)) {\n                    injectionResult = INPUT_EVENT_INJECTION_PERMISSION_DENIED;\n                    injectionPermission = INJECTION_PERMISSION_DENIED;\n                    goto Failed;\n                }\n            }\n        }\n        if (! haveForegroundWindow) {\n#if DEBUG_FOCUS\n            ALOGD(\"Dropping event because there is no touched foreground window to receive it.\");\n#endif\n            injectionResult = INPUT_EVENT_INJECTION_FAILED;\n            goto Failed;\n        }\n\n        // Permission granted to injection into all touched foreground windows.\n        injectionPermission = INJECTION_PERMISSION_GRANTED;\n    }\n\n    // Check whether windows listening for outside touches are owned by the same UID. If it is\n    // set the policy flag that we will not reveal coordinate information to this window.\n    if (maskedAction == AMOTION_EVENT_ACTION_DOWN) {\n        sp<InputWindowHandle> foregroundWindowHandle =\n                mTempTouchState.getFirstForegroundWindowHandle();\n        const int32_t foregroundWindowUid = foregroundWindowHandle->getInfo()->ownerUid;\n        for (size_t i = 0; i < mTempTouchState.windows.size(); i++) {\n            const TouchedWindow& touchedWindow = mTempTouchState.windows[i];\n            if (touchedWindow.targetFlags & InputTarget::FLAG_DISPATCH_AS_OUTSIDE) {\n                sp<InputWindowHandle> inputWindowHandle = touchedWindow.windowHandle;\n                if (inputWindowHandle->getInfo()->ownerUid != foregroundWindowUid) {\n                    mTempTouchState.addOrUpdateWindow(inputWindowHandle,\n                            InputTarget::FLAG_ZERO_COORDS, BitSet32(0));\n                }\n            }\n        }\n    }\n\n    // Ensure all touched foreground windows are ready for new input.\n    for (size_t i = 0; i < mTempTouchState.windows.size(); i++) {\n        const TouchedWindow& touchedWindow = mTempTouchState.windows[i];\n        if (touchedWindow.targetFlags & InputTarget::FLAG_FOREGROUND) {\n            // Check whether the window is ready for more input.\n            String8 reason = checkWindowReadyForMoreInputLocked(currentTime,\n                    touchedWindow.windowHandle, entry, \"touched\");\n            if (!reason.isEmpty()) {\n                injectionResult = handleTargetsNotReadyLocked(currentTime, entry,\n                        NULL, touchedWindow.windowHandle, nextWakeupTime, reason.string());\n                goto Unresponsive;\n            }\n        }\n    }\n\n    // If this is the first pointer going down and the touched window has a wallpaper\n    // then also add the touched wallpaper windows so they are locked in for the duration\n    // of the touch gesture.\n    // We do not collect wallpapers during HOVER_MOVE or SCROLL because the wallpaper\n    // engine only supports touch events.  We would need to add a mechanism similar\n    // to View.onGenericMotionEvent to enable wallpapers to handle these events.\n    if (maskedAction == AMOTION_EVENT_ACTION_DOWN) {\n        sp<InputWindowHandle> foregroundWindowHandle =\n                mTempTouchState.getFirstForegroundWindowHandle();\n        if (foregroundWindowHandle->getInfo()->hasWallpaper) {\n            for (size_t i = 0; i < mWindowHandles.size(); i++) {\n                sp<InputWindowHandle> windowHandle = mWindowHandles.itemAt(i);\n                const InputWindowInfo* info = windowHandle->getInfo();\n                if (info->displayId == displayId\n                        && windowHandle->getInfo()->layoutParamsType\n                                == InputWindowInfo::TYPE_WALLPAPER) {\n                    mTempTouchState.addOrUpdateWindow(windowHandle,\n                            InputTarget::FLAG_WINDOW_IS_OBSCURED\n                                    | InputTarget::FLAG_DISPATCH_AS_IS,\n                            BitSet32(0));\n                }\n            }\n        }\n    }\n\n    // Success!  Output targets.\n    injectionResult = INPUT_EVENT_INJECTION_SUCCEEDED;\n\n    for (size_t i = 0; i < mTempTouchState.windows.size(); i++) {\n        const TouchedWindow& touchedWindow = mTempTouchState.windows.itemAt(i);\n        addWindowTargetLocked(touchedWindow.windowHandle, touchedWindow.targetFlags,\n                touchedWindow.pointerIds, inputTargets);\n    }\n\n    // Drop the outside or hover touch windows since we will not care about them\n    // in the next iteration.\n    mTempTouchState.filterNonAsIsTouchWindows();\n\nFailed:\n    // Check injection permission once and for all.\n    if (injectionPermission == INJECTION_PERMISSION_UNKNOWN) {\n        if (checkInjectionPermission(NULL, entry->injectionState)) {\n            injectionPermission = INJECTION_PERMISSION_GRANTED;\n        } else {\n            injectionPermission = INJECTION_PERMISSION_DENIED;\n        }\n    }\n\n    // Update final pieces of touch state if the injector had permission.\n    if (injectionPermission == INJECTION_PERMISSION_GRANTED) {\n        if (!wrongDevice) {\n            if (switchedDevice) {\n#if DEBUG_FOCUS\n                ALOGD(\"Conflicting pointer actions: Switched to a different device.\");\n#endif\n                *outConflictingPointerActions = true;\n            }\n\n            if (isHoverAction) {\n                // Started hovering, therefore no longer down.\n                if (oldState && oldState->down) {\n#if DEBUG_FOCUS\n                    ALOGD(\"Conflicting pointer actions: Hover received while pointer was down.\");\n#endif\n                    *outConflictingPointerActions = true;\n                }\n                mTempTouchState.reset();\n                if (maskedAction == AMOTION_EVENT_ACTION_HOVER_ENTER\n                        || maskedAction == AMOTION_EVENT_ACTION_HOVER_MOVE) {\n                    mTempTouchState.deviceId = entry->deviceId;\n                    mTempTouchState.source = entry->source;\n                    mTempTouchState.displayId = displayId;\n                }\n            } else if (maskedAction == AMOTION_EVENT_ACTION_UP\n                    || maskedAction == AMOTION_EVENT_ACTION_CANCEL) {\n                // All pointers up or canceled.\n                mTempTouchState.reset();\n            } else if (maskedAction == AMOTION_EVENT_ACTION_DOWN) {\n                // First pointer went down.\n                if (oldState && oldState->down) {\n#if DEBUG_FOCUS\n                    ALOGD(\"Conflicting pointer actions: Down received while already down.\");\n#endif\n                    *outConflictingPointerActions = true;\n                }\n            } else if (maskedAction == AMOTION_EVENT_ACTION_POINTER_UP) {\n                // One pointer went up.\n                if (isSplit) {\n                    int32_t pointerIndex = getMotionEventActionPointerIndex(action);\n                    uint32_t pointerId = entry->pointerProperties[pointerIndex].id;\n\n                    for (size_t i = 0; i < mTempTouchState.windows.size(); ) {\n                        TouchedWindow& touchedWindow = mTempTouchState.windows.editItemAt(i);\n                        if (touchedWindow.targetFlags & InputTarget::FLAG_SPLIT) {\n                            touchedWindow.pointerIds.clearBit(pointerId);\n                            if (touchedWindow.pointerIds.isEmpty()) {\n                                mTempTouchState.windows.removeAt(i);\n                                continue;\n                            }\n                        }\n                        i += 1;\n                    }\n                }\n            }\n\n            // Save changes unless the action was scroll in which case the temporary touch\n            // state was only valid for this one action.\n            if (maskedAction != AMOTION_EVENT_ACTION_SCROLL) {\n                if (mTempTouchState.displayId >= 0) {\n                    if (oldStateIndex >= 0) {\n                        mTouchStatesByDisplay.editValueAt(oldStateIndex).copyFrom(mTempTouchState);\n                    } else {\n                        mTouchStatesByDisplay.add(displayId, mTempTouchState);\n                    }\n                } else if (oldStateIndex >= 0) {\n                    mTouchStatesByDisplay.removeItemsAt(oldStateIndex);\n                }\n            }\n\n            // Update hover state.\n            mLastHoverWindowHandle = newHoverWindowHandle;\n        }\n    } else {\n#if DEBUG_FOCUS\n        ALOGD(\"Not updating touch focus because injection was denied.\");\n#endif\n    }\n\nUnresponsive:\n    // Reset temporary touch state to ensure we release unnecessary references to input channels.\n    mTempTouchState.reset();\n\n    nsecs_t timeSpentWaitingForApplication = getTimeSpentWaitingForApplicationLocked(currentTime);\n    updateDispatchStatisticsLocked(currentTime, entry,\n            injectionResult, timeSpentWaitingForApplication);\n#if DEBUG_FOCUS\n    ALOGD(\"findTouchedWindow finished: injectionResult=%d, injectionPermission=%d, \"\n            \"timeSpentWaitingForApplication=%0.1fms\",\n            injectionResult, injectionPermission, timeSpentWaitingForApplication / 1000000.0);\n#endif\n    return injectionResult;\n}",
        "func": "int32_t InputDispatcher::findTouchedWindowTargetsLocked(nsecs_t currentTime,\n        const MotionEntry* entry, Vector<InputTarget>& inputTargets, nsecs_t* nextWakeupTime,\n        bool* outConflictingPointerActions) {\n    enum InjectionPermission {\n        INJECTION_PERMISSION_UNKNOWN,\n        INJECTION_PERMISSION_GRANTED,\n        INJECTION_PERMISSION_DENIED\n    };\n\n    nsecs_t startTime = now();\n\n    // For security reasons, we defer updating the touch state until we are sure that\n    // event injection will be allowed.\n    int32_t displayId = entry->displayId;\n    int32_t action = entry->action;\n    int32_t maskedAction = action & AMOTION_EVENT_ACTION_MASK;\n\n    // Update the touch state as needed based on the properties of the touch event.\n    int32_t injectionResult = INPUT_EVENT_INJECTION_PENDING;\n    InjectionPermission injectionPermission = INJECTION_PERMISSION_UNKNOWN;\n    sp<InputWindowHandle> newHoverWindowHandle;\n\n    // Copy current touch state into mTempTouchState.\n    // This state is always reset at the end of this function, so if we don't find state\n    // for the specified display then our initial state will be empty.\n    const TouchState* oldState = NULL;\n    ssize_t oldStateIndex = mTouchStatesByDisplay.indexOfKey(displayId);\n    if (oldStateIndex >= 0) {\n        oldState = &mTouchStatesByDisplay.valueAt(oldStateIndex);\n        mTempTouchState.copyFrom(*oldState);\n    }\n\n    bool isSplit = mTempTouchState.split;\n    bool switchedDevice = mTempTouchState.deviceId >= 0 && mTempTouchState.displayId >= 0\n            && (mTempTouchState.deviceId != entry->deviceId\n                    || mTempTouchState.source != entry->source\n                    || mTempTouchState.displayId != displayId);\n    bool isHoverAction = (maskedAction == AMOTION_EVENT_ACTION_HOVER_MOVE\n            || maskedAction == AMOTION_EVENT_ACTION_HOVER_ENTER\n            || maskedAction == AMOTION_EVENT_ACTION_HOVER_EXIT);\n    bool newGesture = (maskedAction == AMOTION_EVENT_ACTION_DOWN\n            || maskedAction == AMOTION_EVENT_ACTION_SCROLL\n            || isHoverAction);\n    bool wrongDevice = false;\n    if (newGesture) {\n        bool down = maskedAction == AMOTION_EVENT_ACTION_DOWN;\n        if (switchedDevice && mTempTouchState.down && !down) {\n#if DEBUG_FOCUS\n            ALOGD(\"Dropping event because a pointer for a different device is already down.\");\n#endif\n            injectionResult = INPUT_EVENT_INJECTION_FAILED;\n            switchedDevice = false;\n            wrongDevice = true;\n            goto Failed;\n        }\n        mTempTouchState.reset();\n        mTempTouchState.down = down;\n        mTempTouchState.deviceId = entry->deviceId;\n        mTempTouchState.source = entry->source;\n        mTempTouchState.displayId = displayId;\n        isSplit = false;\n    }\n\n    if (newGesture || (isSplit && maskedAction == AMOTION_EVENT_ACTION_POINTER_DOWN)) {\n        /* Case 1: New splittable pointer going down, or need target for hover or scroll. */\n\n        int32_t pointerIndex = getMotionEventActionPointerIndex(action);\n        int32_t x = int32_t(entry->pointerCoords[pointerIndex].\n                getAxisValue(AMOTION_EVENT_AXIS_X));\n        int32_t y = int32_t(entry->pointerCoords[pointerIndex].\n                getAxisValue(AMOTION_EVENT_AXIS_Y));\n        sp<InputWindowHandle> newTouchedWindowHandle;\n        bool isTouchModal = false;\n\n        // Traverse windows from front to back to find touched window and outside targets.\n        size_t numWindows = mWindowHandles.size();\n        for (size_t i = 0; i < numWindows; i++) {\n            sp<InputWindowHandle> windowHandle = mWindowHandles.itemAt(i);\n            const InputWindowInfo* windowInfo = windowHandle->getInfo();\n            if (windowInfo->displayId != displayId) {\n                continue; // wrong display\n            }\n\n            int32_t flags = windowInfo->layoutParamsFlags;\n            if (windowInfo->visible) {\n                if (! (flags & InputWindowInfo::FLAG_NOT_TOUCHABLE)) {\n                    isTouchModal = (flags & (InputWindowInfo::FLAG_NOT_FOCUSABLE\n                            | InputWindowInfo::FLAG_NOT_TOUCH_MODAL)) == 0;\n                    if (isTouchModal || windowInfo->touchableRegionContainsPoint(x, y)) {\n                        newTouchedWindowHandle = windowHandle;\n                        break; // found touched window, exit window loop\n                    }\n                }\n\n                if (maskedAction == AMOTION_EVENT_ACTION_DOWN\n                        && (flags & InputWindowInfo::FLAG_WATCH_OUTSIDE_TOUCH)) {\n                    int32_t outsideTargetFlags = InputTarget::FLAG_DISPATCH_AS_OUTSIDE;\n                    if (isWindowObscuredAtPointLocked(windowHandle, x, y)) {\n                        outsideTargetFlags |= InputTarget::FLAG_WINDOW_IS_OBSCURED;\n                    } else if (isWindowObscuredLocked(windowHandle)) {\n                        outsideTargetFlags |= InputTarget::FLAG_WINDOW_IS_PARTIALLY_OBSCURED;\n                    }\n\n                    mTempTouchState.addOrUpdateWindow(\n                            windowHandle, outsideTargetFlags, BitSet32(0));\n                }\n            }\n        }\n\n        // Figure out whether splitting will be allowed for this window.\n        if (newTouchedWindowHandle != NULL\n                && newTouchedWindowHandle->getInfo()->supportsSplitTouch()) {\n            // New window supports splitting.\n            isSplit = true;\n        } else if (isSplit) {\n            // New window does not support splitting but we have already split events.\n            // Ignore the new window.\n            newTouchedWindowHandle = NULL;\n        }\n\n        // Handle the case where we did not find a window.\n        if (newTouchedWindowHandle == NULL) {\n            // Try to assign the pointer to the first foreground window we find, if there is one.\n            newTouchedWindowHandle = mTempTouchState.getFirstForegroundWindowHandle();\n            if (newTouchedWindowHandle == NULL) {\n                ALOGI(\"Dropping event because there is no touchable window at (%d, %d).\", x, y);\n                injectionResult = INPUT_EVENT_INJECTION_FAILED;\n                goto Failed;\n            }\n        }\n\n        // Set target flags.\n        int32_t targetFlags = InputTarget::FLAG_FOREGROUND | InputTarget::FLAG_DISPATCH_AS_IS;\n        if (isSplit) {\n            targetFlags |= InputTarget::FLAG_SPLIT;\n        }\n        if (isWindowObscuredAtPointLocked(newTouchedWindowHandle, x, y)) {\n            targetFlags |= InputTarget::FLAG_WINDOW_IS_OBSCURED;\n        } else if (isWindowObscuredLocked(newTouchedWindowHandle)) {\n            targetFlags |= InputTarget::FLAG_WINDOW_IS_PARTIALLY_OBSCURED;\n        }\n\n        // Update hover state.\n        if (isHoverAction) {\n            newHoverWindowHandle = newTouchedWindowHandle;\n        } else if (maskedAction == AMOTION_EVENT_ACTION_SCROLL) {\n            newHoverWindowHandle = mLastHoverWindowHandle;\n        }\n\n        // Update the temporary touch state.\n        BitSet32 pointerIds;\n        if (isSplit) {\n            uint32_t pointerId = entry->pointerProperties[pointerIndex].id;\n            pointerIds.markBit(pointerId);\n        }\n        mTempTouchState.addOrUpdateWindow(newTouchedWindowHandle, targetFlags, pointerIds);\n    } else {\n        /* Case 2: Pointer move, up, cancel or non-splittable pointer down. */\n\n        // If the pointer is not currently down, then ignore the event.\n        if (! mTempTouchState.down) {\n#if DEBUG_FOCUS\n            ALOGD(\"Dropping event because the pointer is not down or we previously \"\n                    \"dropped the pointer down event.\");\n#endif\n            injectionResult = INPUT_EVENT_INJECTION_FAILED;\n            goto Failed;\n        }\n\n        // Check whether touches should slip outside of the current foreground window.\n        if (maskedAction == AMOTION_EVENT_ACTION_MOVE\n                && entry->pointerCount == 1\n                && mTempTouchState.isSlippery()) {\n            int32_t x = int32_t(entry->pointerCoords[0].getAxisValue(AMOTION_EVENT_AXIS_X));\n            int32_t y = int32_t(entry->pointerCoords[0].getAxisValue(AMOTION_EVENT_AXIS_Y));\n\n            sp<InputWindowHandle> oldTouchedWindowHandle =\n                    mTempTouchState.getFirstForegroundWindowHandle();\n            sp<InputWindowHandle> newTouchedWindowHandle =\n                    findTouchedWindowAtLocked(displayId, x, y);\n            if (oldTouchedWindowHandle != newTouchedWindowHandle\n                    && newTouchedWindowHandle != NULL) {\n#if DEBUG_FOCUS\n                ALOGD(\"Touch is slipping out of window %s into window %s.\",\n                        oldTouchedWindowHandle->getName().string(),\n                        newTouchedWindowHandle->getName().string());\n#endif\n                // Make a slippery exit from the old window.\n                mTempTouchState.addOrUpdateWindow(oldTouchedWindowHandle,\n                        InputTarget::FLAG_DISPATCH_AS_SLIPPERY_EXIT, BitSet32(0));\n\n                // Make a slippery entrance into the new window.\n                if (newTouchedWindowHandle->getInfo()->supportsSplitTouch()) {\n                    isSplit = true;\n                }\n\n                int32_t targetFlags = InputTarget::FLAG_FOREGROUND\n                        | InputTarget::FLAG_DISPATCH_AS_SLIPPERY_ENTER;\n                if (isSplit) {\n                    targetFlags |= InputTarget::FLAG_SPLIT;\n                }\n                if (isWindowObscuredAtPointLocked(newTouchedWindowHandle, x, y)) {\n                    targetFlags |= InputTarget::FLAG_WINDOW_IS_OBSCURED;\n                }\n\n                BitSet32 pointerIds;\n                if (isSplit) {\n                    pointerIds.markBit(entry->pointerProperties[0].id);\n                }\n                mTempTouchState.addOrUpdateWindow(newTouchedWindowHandle, targetFlags, pointerIds);\n            }\n        }\n    }\n\n    if (newHoverWindowHandle != mLastHoverWindowHandle) {\n        // Let the previous window know that the hover sequence is over.\n        if (mLastHoverWindowHandle != NULL) {\n#if DEBUG_HOVER\n            ALOGD(\"Sending hover exit event to window %s.\",\n                    mLastHoverWindowHandle->getName().string());\n#endif\n            mTempTouchState.addOrUpdateWindow(mLastHoverWindowHandle,\n                    InputTarget::FLAG_DISPATCH_AS_HOVER_EXIT, BitSet32(0));\n        }\n\n        // Let the new window know that the hover sequence is starting.\n        if (newHoverWindowHandle != NULL) {\n#if DEBUG_HOVER\n            ALOGD(\"Sending hover enter event to window %s.\",\n                    newHoverWindowHandle->getName().string());\n#endif\n            mTempTouchState.addOrUpdateWindow(newHoverWindowHandle,\n                    InputTarget::FLAG_DISPATCH_AS_HOVER_ENTER, BitSet32(0));\n        }\n    }\n\n    // Check permission to inject into all touched foreground windows and ensure there\n    // is at least one touched foreground window.\n    {\n        bool haveForegroundWindow = false;\n        for (size_t i = 0; i < mTempTouchState.windows.size(); i++) {\n            const TouchedWindow& touchedWindow = mTempTouchState.windows[i];\n            if (touchedWindow.targetFlags & InputTarget::FLAG_FOREGROUND) {\n                haveForegroundWindow = true;\n                if (! checkInjectionPermission(touchedWindow.windowHandle,\n                        entry->injectionState)) {\n                    injectionResult = INPUT_EVENT_INJECTION_PERMISSION_DENIED;\n                    injectionPermission = INJECTION_PERMISSION_DENIED;\n                    goto Failed;\n                }\n            }\n        }\n        if (! haveForegroundWindow) {\n#if DEBUG_FOCUS\n            ALOGD(\"Dropping event because there is no touched foreground window to receive it.\");\n#endif\n            injectionResult = INPUT_EVENT_INJECTION_FAILED;\n            goto Failed;\n        }\n\n        // Permission granted to injection into all touched foreground windows.\n        injectionPermission = INJECTION_PERMISSION_GRANTED;\n    }\n\n    // Check whether windows listening for outside touches are owned by the same UID. If it is\n    // set the policy flag that we will not reveal coordinate information to this window.\n    if (maskedAction == AMOTION_EVENT_ACTION_DOWN) {\n        sp<InputWindowHandle> foregroundWindowHandle =\n                mTempTouchState.getFirstForegroundWindowHandle();\n        const int32_t foregroundWindowUid = foregroundWindowHandle->getInfo()->ownerUid;\n        for (size_t i = 0; i < mTempTouchState.windows.size(); i++) {\n            const TouchedWindow& touchedWindow = mTempTouchState.windows[i];\n            if (touchedWindow.targetFlags & InputTarget::FLAG_DISPATCH_AS_OUTSIDE) {\n                sp<InputWindowHandle> inputWindowHandle = touchedWindow.windowHandle;\n                if (inputWindowHandle->getInfo()->ownerUid != foregroundWindowUid) {\n                    mTempTouchState.addOrUpdateWindow(inputWindowHandle,\n                            InputTarget::FLAG_ZERO_COORDS, BitSet32(0));\n                }\n            }\n        }\n    }\n\n    // Ensure all touched foreground windows are ready for new input.\n    for (size_t i = 0; i < mTempTouchState.windows.size(); i++) {\n        const TouchedWindow& touchedWindow = mTempTouchState.windows[i];\n        if (touchedWindow.targetFlags & InputTarget::FLAG_FOREGROUND) {\n            // Check whether the window is ready for more input.\n            String8 reason = checkWindowReadyForMoreInputLocked(currentTime,\n                    touchedWindow.windowHandle, entry, \"touched\");\n            if (!reason.isEmpty()) {\n                injectionResult = handleTargetsNotReadyLocked(currentTime, entry,\n                        NULL, touchedWindow.windowHandle, nextWakeupTime, reason.string());\n                goto Unresponsive;\n            }\n        }\n    }\n\n    // If this is the first pointer going down and the touched window has a wallpaper\n    // then also add the touched wallpaper windows so they are locked in for the duration\n    // of the touch gesture.\n    // We do not collect wallpapers during HOVER_MOVE or SCROLL because the wallpaper\n    // engine only supports touch events.  We would need to add a mechanism similar\n    // to View.onGenericMotionEvent to enable wallpapers to handle these events.\n    if (maskedAction == AMOTION_EVENT_ACTION_DOWN) {\n        sp<InputWindowHandle> foregroundWindowHandle =\n                mTempTouchState.getFirstForegroundWindowHandle();\n        if (foregroundWindowHandle->getInfo()->hasWallpaper) {\n            for (size_t i = 0; i < mWindowHandles.size(); i++) {\n                sp<InputWindowHandle> windowHandle = mWindowHandles.itemAt(i);\n                const InputWindowInfo* info = windowHandle->getInfo();\n                if (info->displayId == displayId\n                        && windowHandle->getInfo()->layoutParamsType\n                                == InputWindowInfo::TYPE_WALLPAPER) {\n                    mTempTouchState.addOrUpdateWindow(windowHandle,\n                            InputTarget::FLAG_WINDOW_IS_OBSCURED\n                                    | InputTarget::FLAG_WINDOW_IS_PARTIALLY_OBSCURED\n                                    | InputTarget::FLAG_DISPATCH_AS_IS,\n                            BitSet32(0));\n                }\n            }\n        }\n    }\n\n    // Success!  Output targets.\n    injectionResult = INPUT_EVENT_INJECTION_SUCCEEDED;\n\n    for (size_t i = 0; i < mTempTouchState.windows.size(); i++) {\n        const TouchedWindow& touchedWindow = mTempTouchState.windows.itemAt(i);\n        addWindowTargetLocked(touchedWindow.windowHandle, touchedWindow.targetFlags,\n                touchedWindow.pointerIds, inputTargets);\n    }\n\n    // Drop the outside or hover touch windows since we will not care about them\n    // in the next iteration.\n    mTempTouchState.filterNonAsIsTouchWindows();\n\nFailed:\n    // Check injection permission once and for all.\n    if (injectionPermission == INJECTION_PERMISSION_UNKNOWN) {\n        if (checkInjectionPermission(NULL, entry->injectionState)) {\n            injectionPermission = INJECTION_PERMISSION_GRANTED;\n        } else {\n            injectionPermission = INJECTION_PERMISSION_DENIED;\n        }\n    }\n\n    // Update final pieces of touch state if the injector had permission.\n    if (injectionPermission == INJECTION_PERMISSION_GRANTED) {\n        if (!wrongDevice) {\n            if (switchedDevice) {\n#if DEBUG_FOCUS\n                ALOGD(\"Conflicting pointer actions: Switched to a different device.\");\n#endif\n                *outConflictingPointerActions = true;\n            }\n\n            if (isHoverAction) {\n                // Started hovering, therefore no longer down.\n                if (oldState && oldState->down) {\n#if DEBUG_FOCUS\n                    ALOGD(\"Conflicting pointer actions: Hover received while pointer was down.\");\n#endif\n                    *outConflictingPointerActions = true;\n                }\n                mTempTouchState.reset();\n                if (maskedAction == AMOTION_EVENT_ACTION_HOVER_ENTER\n                        || maskedAction == AMOTION_EVENT_ACTION_HOVER_MOVE) {\n                    mTempTouchState.deviceId = entry->deviceId;\n                    mTempTouchState.source = entry->source;\n                    mTempTouchState.displayId = displayId;\n                }\n            } else if (maskedAction == AMOTION_EVENT_ACTION_UP\n                    || maskedAction == AMOTION_EVENT_ACTION_CANCEL) {\n                // All pointers up or canceled.\n                mTempTouchState.reset();\n            } else if (maskedAction == AMOTION_EVENT_ACTION_DOWN) {\n                // First pointer went down.\n                if (oldState && oldState->down) {\n#if DEBUG_FOCUS\n                    ALOGD(\"Conflicting pointer actions: Down received while already down.\");\n#endif\n                    *outConflictingPointerActions = true;\n                }\n            } else if (maskedAction == AMOTION_EVENT_ACTION_POINTER_UP) {\n                // One pointer went up.\n                if (isSplit) {\n                    int32_t pointerIndex = getMotionEventActionPointerIndex(action);\n                    uint32_t pointerId = entry->pointerProperties[pointerIndex].id;\n\n                    for (size_t i = 0; i < mTempTouchState.windows.size(); ) {\n                        TouchedWindow& touchedWindow = mTempTouchState.windows.editItemAt(i);\n                        if (touchedWindow.targetFlags & InputTarget::FLAG_SPLIT) {\n                            touchedWindow.pointerIds.clearBit(pointerId);\n                            if (touchedWindow.pointerIds.isEmpty()) {\n                                mTempTouchState.windows.removeAt(i);\n                                continue;\n                            }\n                        }\n                        i += 1;\n                    }\n                }\n            }\n\n            // Save changes unless the action was scroll in which case the temporary touch\n            // state was only valid for this one action.\n            if (maskedAction != AMOTION_EVENT_ACTION_SCROLL) {\n                if (mTempTouchState.displayId >= 0) {\n                    if (oldStateIndex >= 0) {\n                        mTouchStatesByDisplay.editValueAt(oldStateIndex).copyFrom(mTempTouchState);\n                    } else {\n                        mTouchStatesByDisplay.add(displayId, mTempTouchState);\n                    }\n                } else if (oldStateIndex >= 0) {\n                    mTouchStatesByDisplay.removeItemsAt(oldStateIndex);\n                }\n            }\n\n            // Update hover state.\n            mLastHoverWindowHandle = newHoverWindowHandle;\n        }\n    } else {\n#if DEBUG_FOCUS\n        ALOGD(\"Not updating touch focus because injection was denied.\");\n#endif\n    }\n\nUnresponsive:\n    // Reset temporary touch state to ensure we release unnecessary references to input channels.\n    mTempTouchState.reset();\n\n    nsecs_t timeSpentWaitingForApplication = getTimeSpentWaitingForApplicationLocked(currentTime);\n    updateDispatchStatisticsLocked(currentTime, entry,\n            injectionResult, timeSpentWaitingForApplication);\n#if DEBUG_FOCUS\n    ALOGD(\"findTouchedWindow finished: injectionResult=%d, injectionPermission=%d, \"\n            \"timeSpentWaitingForApplication=%0.1fms\",\n            injectionResult, injectionPermission, timeSpentWaitingForApplication / 1000000.0);\n#endif\n    return injectionResult;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -97,6 +97,8 @@\n                     int32_t outsideTargetFlags = InputTarget::FLAG_DISPATCH_AS_OUTSIDE;\n                     if (isWindowObscuredAtPointLocked(windowHandle, x, y)) {\n                         outsideTargetFlags |= InputTarget::FLAG_WINDOW_IS_OBSCURED;\n+                    } else if (isWindowObscuredLocked(windowHandle)) {\n+                        outsideTargetFlags |= InputTarget::FLAG_WINDOW_IS_PARTIALLY_OBSCURED;\n                     }\n \n                     mTempTouchState.addOrUpdateWindow(\n@@ -134,6 +136,8 @@\n         }\n         if (isWindowObscuredAtPointLocked(newTouchedWindowHandle, x, y)) {\n             targetFlags |= InputTarget::FLAG_WINDOW_IS_OBSCURED;\n+        } else if (isWindowObscuredLocked(newTouchedWindowHandle)) {\n+            targetFlags |= InputTarget::FLAG_WINDOW_IS_PARTIALLY_OBSCURED;\n         }\n \n         // Update hover state.\n@@ -309,6 +313,7 @@\n                                 == InputWindowInfo::TYPE_WALLPAPER) {\n                     mTempTouchState.addOrUpdateWindow(windowHandle,\n                             InputTarget::FLAG_WINDOW_IS_OBSCURED\n+                                    | InputTarget::FLAG_WINDOW_IS_PARTIALLY_OBSCURED\n                                     | InputTarget::FLAG_DISPATCH_AS_IS,\n                             BitSet32(0));\n                 }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "                    } else if (isWindowObscuredLocked(windowHandle)) {",
                "                        outsideTargetFlags |= InputTarget::FLAG_WINDOW_IS_PARTIALLY_OBSCURED;",
                "        } else if (isWindowObscuredLocked(newTouchedWindowHandle)) {",
                "            targetFlags |= InputTarget::FLAG_WINDOW_IS_PARTIALLY_OBSCURED;",
                "                                    | InputTarget::FLAG_WINDOW_IS_PARTIALLY_OBSCURED"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-2496",
        "func_name": "android/InputDispatcher::enqueueDispatchEntryLocked",
        "description": "The Framework UI permission-dialog implementation in Android 6.x before 2016-06-01 allows attackers to conduct tapjacking attacks and access arbitrary private-storage files by creating a partially overlapping window, aka internal bug 26677796.",
        "git_url": "https://android.googlesource.com/platform/frameworks/native/+/03a53d1c7765eeb3af0bc34c3dff02ada1953fbf",
        "commit_title": "Add new MotionEvent flag for partially obscured windows.",
        "commit_text": " Due to more complex window layouts resulting in lots of overlapping windows, the policy around FLAG_WINDOW_IS_OBSCURED has changed to only be set when the point at which the window was touched is obscured. Unfortunately, this doesn't prevent tapjacking attacks that overlay the dialog's text, making a potentially dangerous operation seem innocuous. To avoid this on particularly sensitive dialogs, introduce a new flag that really does tell you when your window is being even partially overlapped.  We aren't exposing this as API since we plan on making the original flag more robust. This is really a workaround for system dialogs since we generally know their layout and screen position, and that they're unlikely to be overlapped by other applications.  Bug: 26677796 ",
        "func_before": "void InputDispatcher::enqueueDispatchEntryLocked(\n        const sp<Connection>& connection, EventEntry* eventEntry, const InputTarget* inputTarget,\n        int32_t dispatchMode) {\n    int32_t inputTargetFlags = inputTarget->flags;\n    if (!(inputTargetFlags & dispatchMode)) {\n        return;\n    }\n    inputTargetFlags = (inputTargetFlags & ~InputTarget::FLAG_DISPATCH_MASK) | dispatchMode;\n\n    // This is a new event.\n    // Enqueue a new dispatch entry onto the outbound queue for this connection.\n    DispatchEntry* dispatchEntry = new DispatchEntry(eventEntry, // increments ref\n            inputTargetFlags, inputTarget->xOffset, inputTarget->yOffset,\n            inputTarget->scaleFactor);\n\n    // Apply target flags and update the connection's input state.\n    switch (eventEntry->type) {\n    case EventEntry::TYPE_KEY: {\n        KeyEntry* keyEntry = static_cast<KeyEntry*>(eventEntry);\n        dispatchEntry->resolvedAction = keyEntry->action;\n        dispatchEntry->resolvedFlags = keyEntry->flags;\n\n        if (!connection->inputState.trackKey(keyEntry,\n                dispatchEntry->resolvedAction, dispatchEntry->resolvedFlags)) {\n#if DEBUG_DISPATCH_CYCLE\n            ALOGD(\"channel '%s' ~ enqueueDispatchEntryLocked: skipping inconsistent key event\",\n                    connection->getInputChannelName());\n#endif\n            delete dispatchEntry;\n            return; // skip the inconsistent event\n        }\n        break;\n    }\n\n    case EventEntry::TYPE_MOTION: {\n        MotionEntry* motionEntry = static_cast<MotionEntry*>(eventEntry);\n        if (dispatchMode & InputTarget::FLAG_DISPATCH_AS_OUTSIDE) {\n            dispatchEntry->resolvedAction = AMOTION_EVENT_ACTION_OUTSIDE;\n        } else if (dispatchMode & InputTarget::FLAG_DISPATCH_AS_HOVER_EXIT) {\n            dispatchEntry->resolvedAction = AMOTION_EVENT_ACTION_HOVER_EXIT;\n        } else if (dispatchMode & InputTarget::FLAG_DISPATCH_AS_HOVER_ENTER) {\n            dispatchEntry->resolvedAction = AMOTION_EVENT_ACTION_HOVER_ENTER;\n        } else if (dispatchMode & InputTarget::FLAG_DISPATCH_AS_SLIPPERY_EXIT) {\n            dispatchEntry->resolvedAction = AMOTION_EVENT_ACTION_CANCEL;\n        } else if (dispatchMode & InputTarget::FLAG_DISPATCH_AS_SLIPPERY_ENTER) {\n            dispatchEntry->resolvedAction = AMOTION_EVENT_ACTION_DOWN;\n        } else {\n            dispatchEntry->resolvedAction = motionEntry->action;\n        }\n        if (dispatchEntry->resolvedAction == AMOTION_EVENT_ACTION_HOVER_MOVE\n                && !connection->inputState.isHovering(\n                        motionEntry->deviceId, motionEntry->source, motionEntry->displayId)) {\n#if DEBUG_DISPATCH_CYCLE\n        ALOGD(\"channel '%s' ~ enqueueDispatchEntryLocked: filling in missing hover enter event\",\n                connection->getInputChannelName());\n#endif\n            dispatchEntry->resolvedAction = AMOTION_EVENT_ACTION_HOVER_ENTER;\n        }\n\n        dispatchEntry->resolvedFlags = motionEntry->flags;\n        if (dispatchEntry->targetFlags & InputTarget::FLAG_WINDOW_IS_OBSCURED) {\n            dispatchEntry->resolvedFlags |= AMOTION_EVENT_FLAG_WINDOW_IS_OBSCURED;\n        }\n\n        if (!connection->inputState.trackMotion(motionEntry,\n                dispatchEntry->resolvedAction, dispatchEntry->resolvedFlags)) {\n#if DEBUG_DISPATCH_CYCLE\n            ALOGD(\"channel '%s' ~ enqueueDispatchEntryLocked: skipping inconsistent motion event\",\n                    connection->getInputChannelName());\n#endif\n            delete dispatchEntry;\n            return; // skip the inconsistent event\n        }\n        break;\n    }\n    }\n\n    // Remember that we are waiting for this dispatch to complete.\n    if (dispatchEntry->hasForegroundTarget()) {\n        incrementPendingForegroundDispatchesLocked(eventEntry);\n    }\n\n    // Enqueue the dispatch entry.\n    connection->outboundQueue.enqueueAtTail(dispatchEntry);\n    traceOutboundQueueLengthLocked(connection);\n}",
        "func": "void InputDispatcher::enqueueDispatchEntryLocked(\n        const sp<Connection>& connection, EventEntry* eventEntry, const InputTarget* inputTarget,\n        int32_t dispatchMode) {\n    int32_t inputTargetFlags = inputTarget->flags;\n    if (!(inputTargetFlags & dispatchMode)) {\n        return;\n    }\n    inputTargetFlags = (inputTargetFlags & ~InputTarget::FLAG_DISPATCH_MASK) | dispatchMode;\n\n    // This is a new event.\n    // Enqueue a new dispatch entry onto the outbound queue for this connection.\n    DispatchEntry* dispatchEntry = new DispatchEntry(eventEntry, // increments ref\n            inputTargetFlags, inputTarget->xOffset, inputTarget->yOffset,\n            inputTarget->scaleFactor);\n\n    // Apply target flags and update the connection's input state.\n    switch (eventEntry->type) {\n    case EventEntry::TYPE_KEY: {\n        KeyEntry* keyEntry = static_cast<KeyEntry*>(eventEntry);\n        dispatchEntry->resolvedAction = keyEntry->action;\n        dispatchEntry->resolvedFlags = keyEntry->flags;\n\n        if (!connection->inputState.trackKey(keyEntry,\n                dispatchEntry->resolvedAction, dispatchEntry->resolvedFlags)) {\n#if DEBUG_DISPATCH_CYCLE\n            ALOGD(\"channel '%s' ~ enqueueDispatchEntryLocked: skipping inconsistent key event\",\n                    connection->getInputChannelName());\n#endif\n            delete dispatchEntry;\n            return; // skip the inconsistent event\n        }\n        break;\n    }\n\n    case EventEntry::TYPE_MOTION: {\n        MotionEntry* motionEntry = static_cast<MotionEntry*>(eventEntry);\n        if (dispatchMode & InputTarget::FLAG_DISPATCH_AS_OUTSIDE) {\n            dispatchEntry->resolvedAction = AMOTION_EVENT_ACTION_OUTSIDE;\n        } else if (dispatchMode & InputTarget::FLAG_DISPATCH_AS_HOVER_EXIT) {\n            dispatchEntry->resolvedAction = AMOTION_EVENT_ACTION_HOVER_EXIT;\n        } else if (dispatchMode & InputTarget::FLAG_DISPATCH_AS_HOVER_ENTER) {\n            dispatchEntry->resolvedAction = AMOTION_EVENT_ACTION_HOVER_ENTER;\n        } else if (dispatchMode & InputTarget::FLAG_DISPATCH_AS_SLIPPERY_EXIT) {\n            dispatchEntry->resolvedAction = AMOTION_EVENT_ACTION_CANCEL;\n        } else if (dispatchMode & InputTarget::FLAG_DISPATCH_AS_SLIPPERY_ENTER) {\n            dispatchEntry->resolvedAction = AMOTION_EVENT_ACTION_DOWN;\n        } else {\n            dispatchEntry->resolvedAction = motionEntry->action;\n        }\n        if (dispatchEntry->resolvedAction == AMOTION_EVENT_ACTION_HOVER_MOVE\n                && !connection->inputState.isHovering(\n                        motionEntry->deviceId, motionEntry->source, motionEntry->displayId)) {\n#if DEBUG_DISPATCH_CYCLE\n        ALOGD(\"channel '%s' ~ enqueueDispatchEntryLocked: filling in missing hover enter event\",\n                connection->getInputChannelName());\n#endif\n            dispatchEntry->resolvedAction = AMOTION_EVENT_ACTION_HOVER_ENTER;\n        }\n\n        dispatchEntry->resolvedFlags = motionEntry->flags;\n        if (dispatchEntry->targetFlags & InputTarget::FLAG_WINDOW_IS_OBSCURED) {\n            dispatchEntry->resolvedFlags |= AMOTION_EVENT_FLAG_WINDOW_IS_OBSCURED;\n        }\n        if (dispatchEntry->targetFlags & InputTarget::FLAG_WINDOW_IS_PARTIALLY_OBSCURED) {\n            dispatchEntry->resolvedFlags |= AMOTION_EVENT_FLAG_WINDOW_IS_PARTIALLY_OBSCURED;\n        }\n\n        if (!connection->inputState.trackMotion(motionEntry,\n                dispatchEntry->resolvedAction, dispatchEntry->resolvedFlags)) {\n#if DEBUG_DISPATCH_CYCLE\n            ALOGD(\"channel '%s' ~ enqueueDispatchEntryLocked: skipping inconsistent motion event\",\n                    connection->getInputChannelName());\n#endif\n            delete dispatchEntry;\n            return; // skip the inconsistent event\n        }\n        break;\n    }\n    }\n\n    // Remember that we are waiting for this dispatch to complete.\n    if (dispatchEntry->hasForegroundTarget()) {\n        incrementPendingForegroundDispatchesLocked(eventEntry);\n    }\n\n    // Enqueue the dispatch entry.\n    connection->outboundQueue.enqueueAtTail(dispatchEntry);\n    traceOutboundQueueLengthLocked(connection);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -61,6 +61,9 @@\n         if (dispatchEntry->targetFlags & InputTarget::FLAG_WINDOW_IS_OBSCURED) {\n             dispatchEntry->resolvedFlags |= AMOTION_EVENT_FLAG_WINDOW_IS_OBSCURED;\n         }\n+        if (dispatchEntry->targetFlags & InputTarget::FLAG_WINDOW_IS_PARTIALLY_OBSCURED) {\n+            dispatchEntry->resolvedFlags |= AMOTION_EVENT_FLAG_WINDOW_IS_PARTIALLY_OBSCURED;\n+        }\n \n         if (!connection->inputState.trackMotion(motionEntry,\n                 dispatchEntry->resolvedAction, dispatchEntry->resolvedFlags)) {",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "        if (dispatchEntry->targetFlags & InputTarget::FLAG_WINDOW_IS_PARTIALLY_OBSCURED) {",
                "            dispatchEntry->resolvedFlags |= AMOTION_EVENT_FLAG_WINDOW_IS_PARTIALLY_OBSCURED;",
                "        }"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-2496",
        "func_name": "android/InputWindowInfo::frameContainsPoint",
        "description": "The Framework UI permission-dialog implementation in Android 6.x before 2016-06-01 allows attackers to conduct tapjacking attacks and access arbitrary private-storage files by creating a partially overlapping window, aka internal bug 26677796.",
        "git_url": "https://android.googlesource.com/platform/frameworks/native/+/03a53d1c7765eeb3af0bc34c3dff02ada1953fbf",
        "commit_title": "Add new MotionEvent flag for partially obscured windows.",
        "commit_text": " Due to more complex window layouts resulting in lots of overlapping windows, the policy around FLAG_WINDOW_IS_OBSCURED has changed to only be set when the point at which the window was touched is obscured. Unfortunately, this doesn't prevent tapjacking attacks that overlay the dialog's text, making a potentially dangerous operation seem innocuous. To avoid this on particularly sensitive dialogs, introduce a new flag that really does tell you when your window is being even partially overlapped.  We aren't exposing this as API since we plan on making the original flag more robust. This is really a workaround for system dialogs since we generally know their layout and screen position, and that they're unlikely to be overlapped by other applications.  Bug: 26677796 ",
        "func_before": "bool InputWindowInfo::frameContainsPoint(int32_t x, int32_t y) const {\n    return x >= frameLeft && x <= frameRight\n            && y >= frameTop && y <= frameBottom;\n}",
        "func": "bool InputWindowInfo::frameContainsPoint(int32_t x, int32_t y) const {\n    return x >= frameLeft && x < frameRight\n            && y >= frameTop && y < frameBottom;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,4 @@\n bool InputWindowInfo::frameContainsPoint(int32_t x, int32_t y) const {\n-    return x >= frameLeft && x <= frameRight\n-            && y >= frameTop && y <= frameBottom;\n+    return x >= frameLeft && x < frameRight\n+            && y >= frameTop && y < frameBottom;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    return x >= frameLeft && x <= frameRight",
                "            && y >= frameTop && y <= frameBottom;"
            ],
            "added_lines": [
                "    return x >= frameLeft && x < frameRight",
                "            && y >= frameTop && y < frameBottom;"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-2496",
        "func_name": "android/InputWindowInfo::isTrustedOverlay",
        "description": "The Framework UI permission-dialog implementation in Android 6.x before 2016-06-01 allows attackers to conduct tapjacking attacks and access arbitrary private-storage files by creating a partially overlapping window, aka internal bug 26677796.",
        "git_url": "https://android.googlesource.com/platform/frameworks/native/+/03a53d1c7765eeb3af0bc34c3dff02ada1953fbf",
        "commit_title": "Add new MotionEvent flag for partially obscured windows.",
        "commit_text": " Due to more complex window layouts resulting in lots of overlapping windows, the policy around FLAG_WINDOW_IS_OBSCURED has changed to only be set when the point at which the window was touched is obscured. Unfortunately, this doesn't prevent tapjacking attacks that overlay the dialog's text, making a potentially dangerous operation seem innocuous. To avoid this on particularly sensitive dialogs, introduce a new flag that really does tell you when your window is being even partially overlapped.  We aren't exposing this as API since we plan on making the original flag more robust. This is really a workaround for system dialogs since we generally know their layout and screen position, and that they're unlikely to be overlapped by other applications.  Bug: 26677796 ",
        "func_before": "bool InputWindowInfo::isTrustedOverlay() const {\n    return layoutParamsType == TYPE_INPUT_METHOD\n            || layoutParamsType == TYPE_INPUT_METHOD_DIALOG\n            || layoutParamsType == TYPE_MAGNIFICATION_OVERLAY\n            || layoutParamsType == TYPE_SECURE_SYSTEM_OVERLAY;\n}",
        "func": "bool InputWindowInfo::isTrustedOverlay() const {\n    return layoutParamsType == TYPE_INPUT_METHOD\n            || layoutParamsType == TYPE_INPUT_METHOD_DIALOG\n            || layoutParamsType == TYPE_MAGNIFICATION_OVERLAY\n            || layoutParamsType == TYPE_STATUS_BAR\n            || layoutParamsType == TYPE_NAVIGATION_BAR\n            || layoutParamsType == TYPE_SECURE_SYSTEM_OVERLAY;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,5 +2,7 @@\n     return layoutParamsType == TYPE_INPUT_METHOD\n             || layoutParamsType == TYPE_INPUT_METHOD_DIALOG\n             || layoutParamsType == TYPE_MAGNIFICATION_OVERLAY\n+            || layoutParamsType == TYPE_STATUS_BAR\n+            || layoutParamsType == TYPE_NAVIGATION_BAR\n             || layoutParamsType == TYPE_SECURE_SYSTEM_OVERLAY;\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "            || layoutParamsType == TYPE_STATUS_BAR",
                "            || layoutParamsType == TYPE_NAVIGATION_BAR"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-1241",
        "func_name": "chromium/RenderWidgetHostViewAndroid::ResetGestureDetection",
        "description": "Google Chrome before 42.0.2311.90 does not properly consider the interaction of page navigation with the handling of touch events and gesture events, which allows remote attackers to trigger unintended UI actions via a crafted web site that conducts a \"tapjacking\" attack.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/d47c1e4b6bb7e9b485f6dfede0236ddd5c823878",
        "commit_title": "[Android] Thoroughly reset gesture detection upon page navigation",
        "commit_text": " The current gesture reset logic on Android uses a cancellation event synthesized from the active touch sequence. However, this fails to reset detection for timeout-based events, e.g. delayed tap and double-tap, just after the pointer has just been released. Expose an explicit gesture detection reset hook on the GestureProvider, called when the main frame navigates or the window loses focus.    ",
        "func_before": "void RenderWidgetHostViewAndroid::ResetGestureDetection() {\n  const ui::MotionEvent* current_down_event =\n      gesture_provider_.GetCurrentDownEvent();\n  if (!current_down_event)\n    return;\n\n  scoped_ptr<ui::MotionEvent> cancel_event = current_down_event->Cancel();\n  DCHECK(cancel_event);\n  OnTouchEvent(*cancel_event);\n}",
        "func": "void RenderWidgetHostViewAndroid::ResetGestureDetection() {\n  const ui::MotionEvent* current_down_event =\n      gesture_provider_.GetCurrentDownEvent();\n  if (current_down_event) {\n    scoped_ptr<ui::MotionEvent> cancel_event = current_down_event->Cancel();\n    OnTouchEvent(*cancel_event);\n  }\n\n  // A hard reset ensures prevention of any timer-based events.\n  gesture_provider_.ResetDetection();\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,10 +1,11 @@\n void RenderWidgetHostViewAndroid::ResetGestureDetection() {\n   const ui::MotionEvent* current_down_event =\n       gesture_provider_.GetCurrentDownEvent();\n-  if (!current_down_event)\n-    return;\n+  if (current_down_event) {\n+    scoped_ptr<ui::MotionEvent> cancel_event = current_down_event->Cancel();\n+    OnTouchEvent(*cancel_event);\n+  }\n \n-  scoped_ptr<ui::MotionEvent> cancel_event = current_down_event->Cancel();\n-  DCHECK(cancel_event);\n-  OnTouchEvent(*cancel_event);\n+  // A hard reset ensures prevention of any timer-based events.\n+  gesture_provider_.ResetDetection();\n }",
        "diff_line_info": {
            "deleted_lines": [
                "  if (!current_down_event)",
                "    return;",
                "  scoped_ptr<ui::MotionEvent> cancel_event = current_down_event->Cancel();",
                "  DCHECK(cancel_event);",
                "  OnTouchEvent(*cancel_event);"
            ],
            "added_lines": [
                "  if (current_down_event) {",
                "    scoped_ptr<ui::MotionEvent> cancel_event = current_down_event->Cancel();",
                "    OnTouchEvent(*cancel_event);",
                "  }",
                "  // A hard reset ensures prevention of any timer-based events.",
                "  gesture_provider_.ResetDetection();"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-1241",
        "func_name": "chromium/WebContentsImpl::DidNavigateMainFramePostCommit",
        "description": "Google Chrome before 42.0.2311.90 does not properly consider the interaction of page navigation with the handling of touch events and gesture events, which allows remote attackers to trigger unintended UI actions via a crafted web site that conducts a \"tapjacking\" attack.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/9d343ad2ea6ec395c377a4efa266057155bfa9c1",
        "commit_title": "Reset gesture detection upon page navigation for Aura",
        "commit_text": " In order to stop the gesture events to be generated and sent while navigating to a different page on the main frame or the window loses focus, we decide to cancel all the active touch events on the current Aura window before the touch release event.    ",
        "func_before": "void WebContentsImpl::DidNavigateMainFramePostCommit(\n    RenderFrameHostImpl* render_frame_host,\n    const LoadCommittedDetails& details,\n    const FrameHostMsg_DidCommitProvisionalLoad_Params& params) {\n  if (details.is_navigation_to_different_page()) {\n    // Clear the status bubble. This is a workaround for a bug where WebKit\n    // doesn't let us know that the cursor left an element during a\n    // transition (this is also why the mouse cursor remains as a hand after\n    // clicking on a link); see bugs 1184641 and 980803. We don't want to\n    // clear the bubble when a user navigates to a named anchor in the same\n    // page.\n    UpdateTargetURL(render_frame_host->GetRenderViewHost(), GURL());\n  }\n\n  if (!details.is_in_page) {\n    // Once the main frame is navigated, we're no longer considered to have\n    // displayed insecure content.\n    displayed_insecure_content_ = false;\n    SSLManager::NotifySSLInternalStateChanged(\n        GetController().GetBrowserContext());\n  }\n\n  // Notify observers about navigation.\n  FOR_EACH_OBSERVER(WebContentsObserver, observers_,\n                    DidNavigateMainFrame(details, params));\n\n  if (delegate_)\n    delegate_->DidNavigateMainFramePostCommit(this);\n  view_->SetOverscrollControllerEnabled(CanOverscrollContent());\n}",
        "func": "void WebContentsImpl::DidNavigateMainFramePostCommit(\n    RenderFrameHostImpl* render_frame_host,\n    const LoadCommittedDetails& details,\n    const FrameHostMsg_DidCommitProvisionalLoad_Params& params) {\n  if (details.is_navigation_to_different_page()) {\n    // Clear the status bubble. This is a workaround for a bug where WebKit\n    // doesn't let us know that the cursor left an element during a\n    // transition (this is also why the mouse cursor remains as a hand after\n    // clicking on a link); see bugs 1184641 and 980803. We don't want to\n    // clear the bubble when a user navigates to a named anchor in the same\n    // page.\n    UpdateTargetURL(render_frame_host->GetRenderViewHost(), GURL());\n\n    RenderWidgetHostViewBase* rwhvb =\n        static_cast<RenderWidgetHostViewBase*>(GetRenderWidgetHostView());\n    if (rwhvb)\n      rwhvb->OnDidNavigateMainFrameToNewPage();\n  }\n\n  if (!details.is_in_page) {\n    // Once the main frame is navigated, we're no longer considered to have\n    // displayed insecure content.\n    displayed_insecure_content_ = false;\n    SSLManager::NotifySSLInternalStateChanged(\n        GetController().GetBrowserContext());\n  }\n\n  // Notify observers about navigation.\n  FOR_EACH_OBSERVER(WebContentsObserver, observers_,\n                    DidNavigateMainFrame(details, params));\n\n  if (delegate_)\n    delegate_->DidNavigateMainFramePostCommit(this);\n  view_->SetOverscrollControllerEnabled(CanOverscrollContent());\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -10,6 +10,11 @@\n     // clear the bubble when a user navigates to a named anchor in the same\n     // page.\n     UpdateTargetURL(render_frame_host->GetRenderViewHost(), GURL());\n+\n+    RenderWidgetHostViewBase* rwhvb =\n+        static_cast<RenderWidgetHostViewBase*>(GetRenderWidgetHostView());\n+    if (rwhvb)\n+      rwhvb->OnDidNavigateMainFrameToNewPage();\n   }\n \n   if (!details.is_in_page) {",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "    RenderWidgetHostViewBase* rwhvb =",
                "        static_cast<RenderWidgetHostViewBase*>(GetRenderWidgetHostView());",
                "    if (rwhvb)",
                "      rwhvb->OnDidNavigateMainFrameToNewPage();"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-3660",
        "func_name": "cockpit-project/cockpit/append_header",
        "description": "Cockpit (and its plugins) do not seem to protect itself against clickjacking. It is possible to render a page from a cockpit server via another website, inside an <iFrame> HTML entry. This may be used by a malicious website in clickjacking or similar attacks.",
        "git_url": "https://github.com/cockpit-project/cockpit/commit/8d9bc10d8128aae03dfde62fd00075fe492ead10",
        "commit_title": "common: Restrict frame embedding to same origin",
        "commit_text": " Declare `X-Frame-Options: sameorigin` [1] so that cockpit frames can only be embedded into pages coming from the same origin. This is similar to setting CORP in commit 2b38b8de92f9a (which applies to `<script>`, `<img>`, etc.).  The main use case for embedding is to run cockpit-ws behind a reverse proxy, while also serving other pages. Cross-origin embedding is discouraged these days to prevent \"clickjacking\".  Cross-origin embedding already did not work in most cases: Frames would always just show the login page.  However, this looks confusing and is unclean. With X-Frame-Options, the browser instead shows an explanatory error page.  Mention the same origin requirement in the embedding documentation.  Fixes #16122 https://bugzilla.redhat.com/show_bug.cgi?id=1980688 CVE-2021-3660  [1] https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options",
        "func_before": "static guint\nappend_header (GString *string,\n               const gchar *name,\n               const gchar *value)\n{\n  if (value)\n    {\n      g_return_val_if_fail (cockpit_web_response_is_simple_token (name), 0);\n      g_return_val_if_fail (cockpit_web_response_is_header_value (value), 0);\n      g_string_append_printf (string, \"%s: %s\\r\\n\", name, value);\n    }\n  if (g_ascii_strcasecmp (\"Content-Type\", name) == 0)\n    return HEADER_CONTENT_TYPE;\n  if (g_ascii_strcasecmp (\"Cache-Control\", name) == 0)\n    return HEADER_CACHE_CONTROL;\n  if (g_ascii_strcasecmp (\"Vary\", name) == 0)\n    return HEADER_VARY;\n  if (g_ascii_strcasecmp (\"Content-Encoding\", name) == 0)\n    return HEADER_CONTENT_ENCODING;\n  if (g_ascii_strcasecmp (\"X-DNS-Prefetch-Control\", name) == 0)\n    return HEADER_DNS_PREFETCH_CONTROL;\n  if (g_ascii_strcasecmp (\"Referrer-Policy\", name) == 0)\n    return HEADER_REFERRER_POLICY;\n  if (g_ascii_strcasecmp (\"X-Content-Type-Options\", name) == 0)\n    return HEADER_CONTENT_TYPE_OPTIONS;\n  if (g_ascii_strcasecmp (\"Cross-Origin-Resource-Policy\", name) == 0)\n    return HEADER_CROSS_ORIGIN_RESOURCE_POLICY;\n  if (g_ascii_strcasecmp (\"Content-Length\", name) == 0 ||\n      g_ascii_strcasecmp (\"Transfer-Encoding\", name) == 0 ||\n      g_ascii_strcasecmp (\"Connection\", name) == 0)\n    {\n      g_critical (\"Don't set %s header manually. This is a programmer error.\", name);\n    }\n  return 0;\n}",
        "func": "static guint\nappend_header (GString *string,\n               const gchar *name,\n               const gchar *value)\n{\n  if (value)\n    {\n      g_return_val_if_fail (cockpit_web_response_is_simple_token (name), 0);\n      g_return_val_if_fail (cockpit_web_response_is_header_value (value), 0);\n      g_string_append_printf (string, \"%s: %s\\r\\n\", name, value);\n    }\n  if (g_ascii_strcasecmp (\"Content-Type\", name) == 0)\n    return HEADER_CONTENT_TYPE;\n  if (g_ascii_strcasecmp (\"Cache-Control\", name) == 0)\n    return HEADER_CACHE_CONTROL;\n  if (g_ascii_strcasecmp (\"Vary\", name) == 0)\n    return HEADER_VARY;\n  if (g_ascii_strcasecmp (\"Content-Encoding\", name) == 0)\n    return HEADER_CONTENT_ENCODING;\n  if (g_ascii_strcasecmp (\"X-DNS-Prefetch-Control\", name) == 0)\n    return HEADER_DNS_PREFETCH_CONTROL;\n  if (g_ascii_strcasecmp (\"Referrer-Policy\", name) == 0)\n    return HEADER_REFERRER_POLICY;\n  if (g_ascii_strcasecmp (\"X-Content-Type-Options\", name) == 0)\n    return HEADER_CONTENT_TYPE_OPTIONS;\n  if (g_ascii_strcasecmp (\"Cross-Origin-Resource-Policy\", name) == 0)\n    return HEADER_CROSS_ORIGIN_RESOURCE_POLICY;\n  if (g_ascii_strcasecmp (\"X-Frame-Options\", name) == 0)\n    return HEADER_X_FRAME_OPTIONS;\n  if (g_ascii_strcasecmp (\"Content-Length\", name) == 0 ||\n      g_ascii_strcasecmp (\"Transfer-Encoding\", name) == 0 ||\n      g_ascii_strcasecmp (\"Connection\", name) == 0)\n    {\n      g_critical (\"Don't set %s header manually. This is a programmer error.\", name);\n    }\n  return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -25,6 +25,8 @@\n     return HEADER_CONTENT_TYPE_OPTIONS;\n   if (g_ascii_strcasecmp (\"Cross-Origin-Resource-Policy\", name) == 0)\n     return HEADER_CROSS_ORIGIN_RESOURCE_POLICY;\n+  if (g_ascii_strcasecmp (\"X-Frame-Options\", name) == 0)\n+    return HEADER_X_FRAME_OPTIONS;\n   if (g_ascii_strcasecmp (\"Content-Length\", name) == 0 ||\n       g_ascii_strcasecmp (\"Transfer-Encoding\", name) == 0 ||\n       g_ascii_strcasecmp (\"Connection\", name) == 0)",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "  if (g_ascii_strcasecmp (\"X-Frame-Options\", name) == 0)",
                "    return HEADER_X_FRAME_OPTIONS;"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-3660",
        "func_name": "cockpit-project/cockpit/finish_headers",
        "description": "Cockpit (and its plugins) do not seem to protect itself against clickjacking. It is possible to render a page from a cockpit server via another website, inside an <iFrame> HTML entry. This may be used by a malicious website in clickjacking or similar attacks.",
        "git_url": "https://github.com/cockpit-project/cockpit/commit/8d9bc10d8128aae03dfde62fd00075fe492ead10",
        "commit_title": "common: Restrict frame embedding to same origin",
        "commit_text": " Declare `X-Frame-Options: sameorigin` [1] so that cockpit frames can only be embedded into pages coming from the same origin. This is similar to setting CORP in commit 2b38b8de92f9a (which applies to `<script>`, `<img>`, etc.).  The main use case for embedding is to run cockpit-ws behind a reverse proxy, while also serving other pages. Cross-origin embedding is discouraged these days to prevent \"clickjacking\".  Cross-origin embedding already did not work in most cases: Frames would always just show the login page.  However, this looks confusing and is unclean. With X-Frame-Options, the browser instead shows an explanatory error page.  Mention the same origin requirement in the embedding documentation.  Fixes #16122 https://bugzilla.redhat.com/show_bug.cgi?id=1980688 CVE-2021-3660  [1] https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Frame-Options",
        "func_before": "static GBytes *\nfinish_headers (CockpitWebResponse *self,\n                GString *string,\n                gssize length,\n                gint status,\n                guint seen)\n{\n  const gchar *content_type;\n\n  /* Automatically figure out content type */\n  if ((seen & HEADER_CONTENT_TYPE) == 0 &&\n      self->full_path != NULL && status >= 200 && status <= 299)\n    {\n      content_type = cockpit_web_response_content_type (self->full_path);\n      if (content_type)\n        g_string_append_printf (string, \"Content-Type: %s\\r\\n\", content_type);\n    }\n\n  if (status != 304)\n    {\n      if (length < 0 || seen & HEADER_CONTENT_ENCODING || self->filters)\n        {\n          self->chunked = TRUE;\n          g_string_append_printf (string, \"Transfer-Encoding: chunked\\r\\n\");\n        }\n      else\n        {\n          self->chunked = FALSE;\n          g_string_append_printf (string, \"Content-Length: %\" G_GSSIZE_FORMAT \"\\r\\n\", length);\n          self->out_queueable = length;\n        }\n    }\n\n  if ((seen & HEADER_CACHE_CONTROL) == 0 && status >= 200 && status <= 299)\n    {\n      if (self->cache_type == COCKPIT_WEB_RESPONSE_CACHE_FOREVER)\n        g_string_append (string, \"Cache-Control: max-age=31556926, public\\r\\n\");\n      else if (self->cache_type == COCKPIT_WEB_RESPONSE_NO_CACHE)\n        g_string_append (string, \"Cache-Control: no-cache, no-store\\r\\n\");\n      else if (self->cache_type == COCKPIT_WEB_RESPONSE_CACHE_PRIVATE)\n        g_string_append (string, \"Cache-Control: max-age=86400, private\\r\\n\");\n    }\n\n  if ((seen & HEADER_VARY) == 0 && status >= 200 && status <= 299 &&\n      self->cache_type == COCKPIT_WEB_RESPONSE_CACHE_PRIVATE)\n    {\n      g_string_append (string, \"Vary: Cookie\\r\\n\");\n    }\n\n  if (!self->keep_alive)\n    g_string_append (string, \"Connection: close\\r\\n\");\n\n  /* Some blanket security headers */\n  if ((seen & HEADER_DNS_PREFETCH_CONTROL) == 0)\n    g_string_append (string, \"X-DNS-Prefetch-Control: off\\r\\n\");\n  if ((seen & HEADER_REFERRER_POLICY) == 0)\n    g_string_append (string, \"Referrer-Policy: no-referrer\\r\\n\");\n  if ((seen & HEADER_CONTENT_TYPE_OPTIONS) == 0)\n    g_string_append (string, \"X-Content-Type-Options: nosniff\\r\\n\");\n  /* Be very strict here -- there is no reason that external web sites should\n   * be able to read any resource. This does *not* affect embedding with <iframe> */\n  if ((seen & HEADER_CROSS_ORIGIN_RESOURCE_POLICY) == 0)\n    g_string_append (string, \"Cross-Origin-Resource-Policy: same-origin\\r\\n\");\n\n  g_string_append (string, \"\\r\\n\");\n  return g_string_free_to_bytes (string);\n}",
        "func": "static GBytes *\nfinish_headers (CockpitWebResponse *self,\n                GString *string,\n                gssize length,\n                gint status,\n                guint seen)\n{\n  const gchar *content_type;\n\n  /* Automatically figure out content type */\n  if ((seen & HEADER_CONTENT_TYPE) == 0 &&\n      self->full_path != NULL && status >= 200 && status <= 299)\n    {\n      content_type = cockpit_web_response_content_type (self->full_path);\n      if (content_type)\n        g_string_append_printf (string, \"Content-Type: %s\\r\\n\", content_type);\n    }\n\n  if (status != 304)\n    {\n      if (length < 0 || seen & HEADER_CONTENT_ENCODING || self->filters)\n        {\n          self->chunked = TRUE;\n          g_string_append_printf (string, \"Transfer-Encoding: chunked\\r\\n\");\n        }\n      else\n        {\n          self->chunked = FALSE;\n          g_string_append_printf (string, \"Content-Length: %\" G_GSSIZE_FORMAT \"\\r\\n\", length);\n          self->out_queueable = length;\n        }\n    }\n\n  if ((seen & HEADER_CACHE_CONTROL) == 0 && status >= 200 && status <= 299)\n    {\n      if (self->cache_type == COCKPIT_WEB_RESPONSE_CACHE_FOREVER)\n        g_string_append (string, \"Cache-Control: max-age=31556926, public\\r\\n\");\n      else if (self->cache_type == COCKPIT_WEB_RESPONSE_NO_CACHE)\n        g_string_append (string, \"Cache-Control: no-cache, no-store\\r\\n\");\n      else if (self->cache_type == COCKPIT_WEB_RESPONSE_CACHE_PRIVATE)\n        g_string_append (string, \"Cache-Control: max-age=86400, private\\r\\n\");\n    }\n\n  if ((seen & HEADER_VARY) == 0 && status >= 200 && status <= 299 &&\n      self->cache_type == COCKPIT_WEB_RESPONSE_CACHE_PRIVATE)\n    {\n      g_string_append (string, \"Vary: Cookie\\r\\n\");\n    }\n\n  if (!self->keep_alive)\n    g_string_append (string, \"Connection: close\\r\\n\");\n\n  /* Some blanket security headers */\n  if ((seen & HEADER_DNS_PREFETCH_CONTROL) == 0)\n    g_string_append (string, \"X-DNS-Prefetch-Control: off\\r\\n\");\n  if ((seen & HEADER_REFERRER_POLICY) == 0)\n    g_string_append (string, \"Referrer-Policy: no-referrer\\r\\n\");\n  if ((seen & HEADER_CONTENT_TYPE_OPTIONS) == 0)\n    g_string_append (string, \"X-Content-Type-Options: nosniff\\r\\n\");\n  /* Be very strict here -- there is no reason that external web sites should\n   * be able to read any resource. This does *not* affect embedding with <iframe> */\n  if ((seen & HEADER_CROSS_ORIGIN_RESOURCE_POLICY) == 0)\n    g_string_append (string, \"Cross-Origin-Resource-Policy: same-origin\\r\\n\");\n  /* This is the counterpart for iframe embedding, line of defence against clickjacking */\n  if ((seen & HEADER_X_FRAME_OPTIONS) == 0)\n    g_string_append (string, \"X-Frame-Options: sameorigin\\r\\n\");\n\n  g_string_append (string, \"\\r\\n\");\n  return g_string_free_to_bytes (string);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -61,6 +61,9 @@\n    * be able to read any resource. This does *not* affect embedding with <iframe> */\n   if ((seen & HEADER_CROSS_ORIGIN_RESOURCE_POLICY) == 0)\n     g_string_append (string, \"Cross-Origin-Resource-Policy: same-origin\\r\\n\");\n+  /* This is the counterpart for iframe embedding, line of defence against clickjacking */\n+  if ((seen & HEADER_X_FRAME_OPTIONS) == 0)\n+    g_string_append (string, \"X-Frame-Options: sameorigin\\r\\n\");\n \n   g_string_append (string, \"\\r\\n\");\n   return g_string_free_to_bytes (string);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "  /* This is the counterpart for iframe embedding, line of defence against clickjacking */",
                "  if ((seen & HEADER_X_FRAME_OPTIONS) == 0)",
                "    g_string_append (string, \"X-Frame-Options: sameorigin\\r\\n\");"
            ]
        }
    }
]