[
    {
        "cve_id": "CVE-2021-4037",
        "func_name": "torvalds/linux/xfs_init_new_inode",
        "description": "A vulnerability was found in the fs/inode.c:inode_init_owner() function logic of the LInux kernel that allows local users to create files for the XFS file-system with an unintended group ownership and with group execution and SGID permission bits set, in a scenario where a directory is SGID and belongs to a certain group and is writable by a user who is not a member of this group. This can lead to excessive permissions granted in case when they should not. This vulnerability is similar to the previous CVE-2018-13405 and adds the missed fix for the XFS.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=01ea173e103e",
        "commit_title": "XFS always inherits the SGID bit if it is set on the parent inode, while",
        "commit_text": "the generic inode_init_owner does not do this in a few cases where it can create a possible security problem, see commit 0fa3ecd87848 (\"Fix up non-directory creation in SGID directories\") for details.  Switch XFS to use the generic helper for the normal path to fix this, just keeping the simple field inheritance open coded for the case of the non-sgid case with the bsdgrpid mount option.  ",
        "func_before": "static int\nxfs_init_new_inode(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*pip,\n\txfs_ino_t\t\tino,\n\tumode_t\t\t\tmode,\n\txfs_nlink_t\t\tnlink,\n\tdev_t\t\t\trdev,\n\tprid_t\t\t\tprid,\n\tstruct xfs_inode\t**ipp)\n{\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\tstruct xfs_inode\t*ip;\n\tunsigned int\t\tflags;\n\tint\t\t\terror;\n\tstruct timespec64\ttv;\n\tstruct inode\t\t*inode;\n\n\t/*\n\t * Protect against obviously corrupt allocation btree records. Later\n\t * xfs_iget checks will catch re-allocation of other active in-memory\n\t * and on-disk inodes. If we don't catch reallocating the parent inode\n\t * here we will deadlock in xfs_iget() so we have to do these checks\n\t * first.\n\t */\n\tif ((pip && ino == pip->i_ino) || !xfs_verify_dir_ino(mp, ino)) {\n\t\txfs_alert(mp, \"Allocated a known in-use inode 0x%llx!\", ino);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\t/*\n\t * Get the in-core inode with the lock held exclusively to prevent\n\t * others from looking at until we're done.\n\t */\n\terror = xfs_iget(mp, tp, ino, XFS_IGET_CREATE, XFS_ILOCK_EXCL, &ip);\n\tif (error)\n\t\treturn error;\n\n\tASSERT(ip != NULL);\n\tinode = VFS_I(ip);\n\tinode->i_mode = mode;\n\tset_nlink(inode, nlink);\n\tinode->i_uid = current_fsuid();\n\tinode->i_rdev = rdev;\n\tip->i_d.di_projid = prid;\n\n\tif (pip && XFS_INHERIT_GID(pip)) {\n\t\tinode->i_gid = VFS_I(pip)->i_gid;\n\t\tif ((VFS_I(pip)->i_mode & S_ISGID) && S_ISDIR(mode))\n\t\t\tinode->i_mode |= S_ISGID;\n\t} else {\n\t\tinode->i_gid = current_fsgid();\n\t}\n\n\t/*\n\t * If the group ID of the new file does not match the effective group\n\t * ID or one of the supplementary group IDs, the S_ISGID bit is cleared\n\t * (and only if the irix_sgid_inherit compatibility variable is set).\n\t */\n\tif (irix_sgid_inherit &&\n\t    (inode->i_mode & S_ISGID) && !in_group_p(inode->i_gid))\n\t\tinode->i_mode &= ~S_ISGID;\n\n\tip->i_d.di_size = 0;\n\tip->i_df.if_nextents = 0;\n\tASSERT(ip->i_d.di_nblocks == 0);\n\n\ttv = current_time(inode);\n\tinode->i_mtime = tv;\n\tinode->i_atime = tv;\n\tinode->i_ctime = tv;\n\n\tip->i_d.di_extsize = 0;\n\tip->i_d.di_dmevmask = 0;\n\tip->i_d.di_dmstate = 0;\n\tip->i_d.di_flags = 0;\n\n\tif (xfs_sb_version_has_v3inode(&mp->m_sb)) {\n\t\tinode_set_iversion(inode, 1);\n\t\tip->i_d.di_flags2 = mp->m_ino_geo.new_diflags2;\n\t\tip->i_d.di_cowextsize = 0;\n\t\tip->i_d.di_crtime = tv;\n\t}\n\n\tflags = XFS_ILOG_CORE;\n\tswitch (mode & S_IFMT) {\n\tcase S_IFIFO:\n\tcase S_IFCHR:\n\tcase S_IFBLK:\n\tcase S_IFSOCK:\n\t\tip->i_df.if_format = XFS_DINODE_FMT_DEV;\n\t\tip->i_df.if_flags = 0;\n\t\tflags |= XFS_ILOG_DEV;\n\t\tbreak;\n\tcase S_IFREG:\n\tcase S_IFDIR:\n\t\tif (pip && (pip->i_d.di_flags & XFS_DIFLAG_ANY))\n\t\t\txfs_inode_inherit_flags(ip, pip);\n\t\tif (pip && (pip->i_d.di_flags2 & XFS_DIFLAG2_ANY))\n\t\t\txfs_inode_inherit_flags2(ip, pip);\n\t\t/* FALLTHROUGH */\n\tcase S_IFLNK:\n\t\tip->i_df.if_format = XFS_DINODE_FMT_EXTENTS;\n\t\tip->i_df.if_flags = XFS_IFEXTENTS;\n\t\tip->i_df.if_bytes = 0;\n\t\tip->i_df.if_u1.if_root = NULL;\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t}\n\n\t/*\n\t * Log the new values stuffed into the inode.\n\t */\n\txfs_trans_ijoin(tp, ip, XFS_ILOCK_EXCL);\n\txfs_trans_log_inode(tp, ip, flags);\n\n\t/* now that we have an i_mode we can setup the inode structure */\n\txfs_setup_inode(ip);\n\n\t*ipp = ip;\n\treturn 0;\n}",
        "func": "static int\nxfs_init_new_inode(\n\tstruct xfs_trans\t*tp,\n\tstruct xfs_inode\t*pip,\n\txfs_ino_t\t\tino,\n\tumode_t\t\t\tmode,\n\txfs_nlink_t\t\tnlink,\n\tdev_t\t\t\trdev,\n\tprid_t\t\t\tprid,\n\tstruct xfs_inode\t**ipp)\n{\n\tstruct inode\t\t*dir = pip ? VFS_I(pip) : NULL;\n\tstruct xfs_mount\t*mp = tp->t_mountp;\n\tstruct xfs_inode\t*ip;\n\tunsigned int\t\tflags;\n\tint\t\t\terror;\n\tstruct timespec64\ttv;\n\tstruct inode\t\t*inode;\n\n\t/*\n\t * Protect against obviously corrupt allocation btree records. Later\n\t * xfs_iget checks will catch re-allocation of other active in-memory\n\t * and on-disk inodes. If we don't catch reallocating the parent inode\n\t * here we will deadlock in xfs_iget() so we have to do these checks\n\t * first.\n\t */\n\tif ((pip && ino == pip->i_ino) || !xfs_verify_dir_ino(mp, ino)) {\n\t\txfs_alert(mp, \"Allocated a known in-use inode 0x%llx!\", ino);\n\t\treturn -EFSCORRUPTED;\n\t}\n\n\t/*\n\t * Get the in-core inode with the lock held exclusively to prevent\n\t * others from looking at until we're done.\n\t */\n\terror = xfs_iget(mp, tp, ino, XFS_IGET_CREATE, XFS_ILOCK_EXCL, &ip);\n\tif (error)\n\t\treturn error;\n\n\tASSERT(ip != NULL);\n\tinode = VFS_I(ip);\n\tset_nlink(inode, nlink);\n\tinode->i_rdev = rdev;\n\tip->i_d.di_projid = prid;\n\n\tif (dir && !(dir->i_mode & S_ISGID) &&\n\t    (mp->m_flags & XFS_MOUNT_GRPID)) {\n\t\tinode->i_uid = current_fsuid();\n\t\tinode->i_gid = dir->i_gid;\n\t\tinode->i_mode = mode;\n\t} else {\n\t\tinode_init_owner(inode, dir, mode);\n\t}\n\n\t/*\n\t * If the group ID of the new file does not match the effective group\n\t * ID or one of the supplementary group IDs, the S_ISGID bit is cleared\n\t * (and only if the irix_sgid_inherit compatibility variable is set).\n\t */\n\tif (irix_sgid_inherit &&\n\t    (inode->i_mode & S_ISGID) && !in_group_p(inode->i_gid))\n\t\tinode->i_mode &= ~S_ISGID;\n\n\tip->i_d.di_size = 0;\n\tip->i_df.if_nextents = 0;\n\tASSERT(ip->i_d.di_nblocks == 0);\n\n\ttv = current_time(inode);\n\tinode->i_mtime = tv;\n\tinode->i_atime = tv;\n\tinode->i_ctime = tv;\n\n\tip->i_d.di_extsize = 0;\n\tip->i_d.di_dmevmask = 0;\n\tip->i_d.di_dmstate = 0;\n\tip->i_d.di_flags = 0;\n\n\tif (xfs_sb_version_has_v3inode(&mp->m_sb)) {\n\t\tinode_set_iversion(inode, 1);\n\t\tip->i_d.di_flags2 = mp->m_ino_geo.new_diflags2;\n\t\tip->i_d.di_cowextsize = 0;\n\t\tip->i_d.di_crtime = tv;\n\t}\n\n\tflags = XFS_ILOG_CORE;\n\tswitch (mode & S_IFMT) {\n\tcase S_IFIFO:\n\tcase S_IFCHR:\n\tcase S_IFBLK:\n\tcase S_IFSOCK:\n\t\tip->i_df.if_format = XFS_DINODE_FMT_DEV;\n\t\tip->i_df.if_flags = 0;\n\t\tflags |= XFS_ILOG_DEV;\n\t\tbreak;\n\tcase S_IFREG:\n\tcase S_IFDIR:\n\t\tif (pip && (pip->i_d.di_flags & XFS_DIFLAG_ANY))\n\t\t\txfs_inode_inherit_flags(ip, pip);\n\t\tif (pip && (pip->i_d.di_flags2 & XFS_DIFLAG2_ANY))\n\t\t\txfs_inode_inherit_flags2(ip, pip);\n\t\t/* FALLTHROUGH */\n\tcase S_IFLNK:\n\t\tip->i_df.if_format = XFS_DINODE_FMT_EXTENTS;\n\t\tip->i_df.if_flags = XFS_IFEXTENTS;\n\t\tip->i_df.if_bytes = 0;\n\t\tip->i_df.if_u1.if_root = NULL;\n\t\tbreak;\n\tdefault:\n\t\tASSERT(0);\n\t}\n\n\t/*\n\t * Log the new values stuffed into the inode.\n\t */\n\txfs_trans_ijoin(tp, ip, XFS_ILOCK_EXCL);\n\txfs_trans_log_inode(tp, ip, flags);\n\n\t/* now that we have an i_mode we can setup the inode structure */\n\txfs_setup_inode(ip);\n\n\t*ipp = ip;\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -9,6 +9,7 @@\n \tprid_t\t\t\tprid,\n \tstruct xfs_inode\t**ipp)\n {\n+\tstruct inode\t\t*dir = pip ? VFS_I(pip) : NULL;\n \tstruct xfs_mount\t*mp = tp->t_mountp;\n \tstruct xfs_inode\t*ip;\n \tunsigned int\t\tflags;\n@@ -38,18 +39,17 @@\n \n \tASSERT(ip != NULL);\n \tinode = VFS_I(ip);\n-\tinode->i_mode = mode;\n \tset_nlink(inode, nlink);\n-\tinode->i_uid = current_fsuid();\n \tinode->i_rdev = rdev;\n \tip->i_d.di_projid = prid;\n \n-\tif (pip && XFS_INHERIT_GID(pip)) {\n-\t\tinode->i_gid = VFS_I(pip)->i_gid;\n-\t\tif ((VFS_I(pip)->i_mode & S_ISGID) && S_ISDIR(mode))\n-\t\t\tinode->i_mode |= S_ISGID;\n+\tif (dir && !(dir->i_mode & S_ISGID) &&\n+\t    (mp->m_flags & XFS_MOUNT_GRPID)) {\n+\t\tinode->i_uid = current_fsuid();\n+\t\tinode->i_gid = dir->i_gid;\n+\t\tinode->i_mode = mode;\n \t} else {\n-\t\tinode->i_gid = current_fsgid();\n+\t\tinode_init_owner(inode, dir, mode);\n \t}\n \n \t/*",
        "diff_line_info": {
            "deleted_lines": [
                "\tinode->i_mode = mode;",
                "\tinode->i_uid = current_fsuid();",
                "\tif (pip && XFS_INHERIT_GID(pip)) {",
                "\t\tinode->i_gid = VFS_I(pip)->i_gid;",
                "\t\tif ((VFS_I(pip)->i_mode & S_ISGID) && S_ISDIR(mode))",
                "\t\t\tinode->i_mode |= S_ISGID;",
                "\t\tinode->i_gid = current_fsgid();"
            ],
            "added_lines": [
                "\tstruct inode\t\t*dir = pip ? VFS_I(pip) : NULL;",
                "\tif (dir && !(dir->i_mode & S_ISGID) &&",
                "\t    (mp->m_flags & XFS_MOUNT_GRPID)) {",
                "\t\tinode->i_uid = current_fsuid();",
                "\t\tinode->i_gid = dir->i_gid;",
                "\t\tinode->i_mode = mode;",
                "\t\tinode_init_owner(inode, dir, mode);"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-1652",
        "func_name": "chromium/ModuleSystem::RequireForJsInner",
        "description": "Cross-site scripting (XSS) vulnerability in the ModuleSystem::RequireForJsInner function in extensions/renderer/module_system.cc in the Extensions subsystem in Google Chrome before 50.0.2661.75 allows remote attackers to inject arbitrary web script or HTML via a crafted web site, aka \"Universal XSS (UXSS).\"",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/75b803b1c81ed9fa5513cbff550232b4fb915e7b",
        "commit_title": "[Extensions] Harden against bindings interception",
        "commit_text": " There's more we can do but this is a start.    ",
        "func_before": "v8::Local<v8::Value> ModuleSystem::RequireForJsInner(\n    v8::Local<v8::String> module_name) {\n  v8::EscapableHandleScope handle_scope(GetIsolate());\n  v8::Local<v8::Context> v8_context = context()->v8_context();\n  v8::Context::Scope context_scope(v8_context);\n\n  v8::Local<v8::Object> global(context()->v8_context()->Global());\n\n  // The module system might have been deleted. This can happen if a different\n  // context keeps a reference to us, but our frame is destroyed (e.g.\n  // background page keeps reference to chrome object in a closed popup).\n  v8::Local<v8::Value> modules_value;\n  if (!GetPrivate(global, kModulesField, &modules_value) ||\n      modules_value->IsUndefined()) {\n    Warn(GetIsolate(), \"Extension view no longer exists\");\n    return v8::Undefined(GetIsolate());\n  }\n\n  v8::Local<v8::Object> modules(v8::Local<v8::Object>::Cast(modules_value));\n  v8::Local<v8::Value> exports;\n  if (!GetProperty(v8_context, modules, module_name, &exports) ||\n      !exports->IsUndefined())\n    return handle_scope.Escape(exports);\n\n  exports = LoadModule(*v8::String::Utf8Value(module_name));\n  SetProperty(v8_context, modules, module_name, exports);\n  return handle_scope.Escape(exports);\n}",
        "func": "v8::Local<v8::Value> ModuleSystem::RequireForJsInner(\n    v8::Local<v8::String> module_name) {\n  v8::EscapableHandleScope handle_scope(GetIsolate());\n  v8::Local<v8::Context> v8_context = context()->v8_context();\n  v8::Context::Scope context_scope(v8_context);\n\n  v8::Local<v8::Object> global(context()->v8_context()->Global());\n\n  // The module system might have been deleted. This can happen if a different\n  // context keeps a reference to us, but our frame is destroyed (e.g.\n  // background page keeps reference to chrome object in a closed popup).\n  v8::Local<v8::Value> modules_value;\n  if (!GetPrivate(global, kModulesField, &modules_value) ||\n      modules_value->IsUndefined()) {\n    Warn(GetIsolate(), \"Extension view no longer exists\");\n    return v8::Undefined(GetIsolate());\n  }\n\n  v8::Local<v8::Object> modules(v8::Local<v8::Object>::Cast(modules_value));\n  v8::Local<v8::Value> exports;\n  if (!GetPrivateProperty(v8_context, modules, module_name, &exports) ||\n      !exports->IsUndefined())\n    return handle_scope.Escape(exports);\n\n  exports = LoadModule(*v8::String::Utf8Value(module_name));\n  SetPrivateProperty(v8_context, modules, module_name, exports);\n  return handle_scope.Escape(exports);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -18,11 +18,11 @@\n \n   v8::Local<v8::Object> modules(v8::Local<v8::Object>::Cast(modules_value));\n   v8::Local<v8::Value> exports;\n-  if (!GetProperty(v8_context, modules, module_name, &exports) ||\n+  if (!GetPrivateProperty(v8_context, modules, module_name, &exports) ||\n       !exports->IsUndefined())\n     return handle_scope.Escape(exports);\n \n   exports = LoadModule(*v8::String::Utf8Value(module_name));\n-  SetProperty(v8_context, modules, module_name, exports);\n+  SetPrivateProperty(v8_context, modules, module_name, exports);\n   return handle_scope.Escape(exports);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "  if (!GetProperty(v8_context, modules, module_name, &exports) ||",
                "  SetProperty(v8_context, modules, module_name, exports);"
            ],
            "added_lines": [
                "  if (!GetPrivateProperty(v8_context, modules, module_name, &exports) ||",
                "  SetPrivateProperty(v8_context, modules, module_name, exports);"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-1658",
        "func_name": "chromium/ProgrammaticScriptInjector::OnWillNotInject",
        "description": "The Extensions subsystem in Google Chrome before 50.0.2661.75 incorrectly relies on GetOrigin method calls for origin comparisons, which allows remote attackers to bypass the Same Origin Policy and obtain sensitive information via a crafted extension.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/5c437bcc7a51edbef45242c5173cf7871fde2866",
        "commit_title": "Make extensions use a correct same-origin check.",
        "commit_text": " GURL::GetOrigin does not do the right thing for all types of URLs.    ",
        "func_before": "void ProgrammaticScriptInjector::OnWillNotInject(\n    InjectFailureReason reason,\n    content::RenderFrame* render_frame) {\n  std::string error;\n  switch (reason) {\n    case NOT_ALLOWED:\n      if (url_.SchemeIs(url::kAboutScheme)) {\n        error = ErrorUtils::FormatErrorMessage(\n            manifest_errors::kCannotAccessAboutUrl, url_.spec(),\n            effective_url_.GetOrigin().spec());\n      } else {\n        // TODO(?) It would be nice to show kCannotAccessPageWithUrl here if\n        // this is triggered by an extension with tabs permission. See\n        // https://codereview.chromium.org/1414223005/diff/1/extensions/\n        // common/manifest_constants.cc#newcode269\n        error = manifest_errors::kCannotAccessPage;\n      }\n      break;\n    case EXTENSION_REMOVED:  // no special error here.\n    case WONT_INJECT:\n      break;\n  }\n  Finish(error, render_frame);\n}",
        "func": "void ProgrammaticScriptInjector::OnWillNotInject(\n    InjectFailureReason reason,\n    content::RenderFrame* render_frame) {\n  std::string error;\n  switch (reason) {\n    case NOT_ALLOWED:\n      if (url_.SchemeIs(url::kAboutScheme)) {\n        error = ErrorUtils::FormatErrorMessage(\n            manifest_errors::kCannotAccessAboutUrl, url_.spec(),\n            url::Origin(effective_url_).Serialize());\n      } else {\n        // TODO(?) It would be nice to show kCannotAccessPageWithUrl here if\n        // this is triggered by an extension with tabs permission. See\n        // https://codereview.chromium.org/1414223005/diff/1/extensions/\n        // common/manifest_constants.cc#newcode269\n        error = manifest_errors::kCannotAccessPage;\n      }\n      break;\n    case EXTENSION_REMOVED:  // no special error here.\n    case WONT_INJECT:\n      break;\n  }\n  Finish(error, render_frame);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -7,7 +7,7 @@\n       if (url_.SchemeIs(url::kAboutScheme)) {\n         error = ErrorUtils::FormatErrorMessage(\n             manifest_errors::kCannotAccessAboutUrl, url_.spec(),\n-            effective_url_.GetOrigin().spec());\n+            url::Origin(effective_url_).Serialize());\n       } else {\n         // TODO(?) It would be nice to show kCannotAccessPageWithUrl here if\n         // this is triggered by an extension with tabs permission. See",
        "diff_line_info": {
            "deleted_lines": [
                "            effective_url_.GetOrigin().spec());"
            ],
            "added_lines": [
                "            url::Origin(effective_url_).Serialize());"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-1658",
        "func_name": "chromium/WebRequestPermissions::CanExtensionAccessURL",
        "description": "The Extensions subsystem in Google Chrome before 50.0.2661.75 incorrectly relies on GetOrigin method calls for origin comparisons, which allows remote attackers to bypass the Same Origin Policy and obtain sensitive information via a crafted extension.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/5c437bcc7a51edbef45242c5173cf7871fde2866",
        "commit_title": "Make extensions use a correct same-origin check.",
        "commit_text": " GURL::GetOrigin does not do the right thing for all types of URLs.    ",
        "func_before": "bool WebRequestPermissions::CanExtensionAccessURL(\n    const extensions::InfoMap* extension_info_map,\n    const std::string& extension_id,\n    const GURL& url,\n    bool crosses_incognito,\n    HostPermissionsCheck host_permissions_check) {\n  // extension_info_map can be NULL in testing.\n  if (!extension_info_map)\n    return true;\n\n  const extensions::Extension* extension =\n      extension_info_map->extensions().GetByID(extension_id);\n  if (!extension)\n    return false;\n\n  // Check if this event crosses incognito boundaries when it shouldn't.\n  if (crosses_incognito && !extension_info_map->CanCrossIncognito(extension))\n    return false;\n\n  switch (host_permissions_check) {\n    case DO_NOT_CHECK_HOST:\n      break;\n    case REQUIRE_HOST_PERMISSION:\n      // about: URLs are not covered in host permissions, but are allowed\n      // anyway.\n      if (!((url.SchemeIs(url::kAboutScheme) ||\n             extension->permissions_data()->HasHostPermission(url) ||\n             url.GetOrigin() == extension->url()))) {\n        return false;\n      }\n      break;\n    case REQUIRE_ALL_URLS:\n      if (!extension->permissions_data()->HasEffectiveAccessToAllHosts())\n        return false;\n      break;\n  }\n\n  return true;\n}",
        "func": "bool WebRequestPermissions::CanExtensionAccessURL(\n    const extensions::InfoMap* extension_info_map,\n    const std::string& extension_id,\n    const GURL& url,\n    bool crosses_incognito,\n    HostPermissionsCheck host_permissions_check) {\n  // extension_info_map can be NULL in testing.\n  if (!extension_info_map)\n    return true;\n\n  const extensions::Extension* extension =\n      extension_info_map->extensions().GetByID(extension_id);\n  if (!extension)\n    return false;\n\n  // Check if this event crosses incognito boundaries when it shouldn't.\n  if (crosses_incognito && !extension_info_map->CanCrossIncognito(extension))\n    return false;\n\n  switch (host_permissions_check) {\n    case DO_NOT_CHECK_HOST:\n      break;\n    case REQUIRE_HOST_PERMISSION:\n      // about: URLs are not covered in host permissions, but are allowed\n      // anyway.\n      if (!url.SchemeIs(url::kAboutScheme) &&\n          !extension->permissions_data()->HasHostPermission(url) &&\n          !url::IsSameOriginWith(url, extension->url())) {\n        return false;\n      }\n      break;\n    case REQUIRE_ALL_URLS:\n      if (!extension->permissions_data()->HasEffectiveAccessToAllHosts())\n        return false;\n      break;\n  }\n\n  return true;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -23,9 +23,9 @@\n     case REQUIRE_HOST_PERMISSION:\n       // about: URLs are not covered in host permissions, but are allowed\n       // anyway.\n-      if (!((url.SchemeIs(url::kAboutScheme) ||\n-             extension->permissions_data()->HasHostPermission(url) ||\n-             url.GetOrigin() == extension->url()))) {\n+      if (!url.SchemeIs(url::kAboutScheme) &&\n+          !extension->permissions_data()->HasHostPermission(url) &&\n+          !url::IsSameOriginWith(url, extension->url())) {\n         return false;\n       }\n       break;",
        "diff_line_info": {
            "deleted_lines": [
                "      if (!((url.SchemeIs(url::kAboutScheme) ||",
                "             extension->permissions_data()->HasHostPermission(url) ||",
                "             url.GetOrigin() == extension->url()))) {"
            ],
            "added_lines": [
                "      if (!url.SchemeIs(url::kAboutScheme) &&",
                "          !extension->permissions_data()->HasHostPermission(url) &&",
                "          !url::IsSameOriginWith(url, extension->url())) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-1658",
        "func_name": "chromium/URLPatternSet::AddOrigin",
        "description": "The Extensions subsystem in Google Chrome before 50.0.2661.75 incorrectly relies on GetOrigin method calls for origin comparisons, which allows remote attackers to bypass the Same Origin Policy and obtain sensitive information via a crafted extension.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/5c437bcc7a51edbef45242c5173cf7871fde2866",
        "commit_title": "Make extensions use a correct same-origin check.",
        "commit_text": " GURL::GetOrigin does not do the right thing for all types of URLs.    ",
        "func_before": "bool URLPatternSet::AddOrigin(int valid_schemes, const GURL& origin) {\n  DCHECK_EQ(origin.GetOrigin(), origin);\n  URLPattern origin_pattern(valid_schemes);\n  // Origin adding could fail if |origin| does not match |valid_schemes|.\n  if (origin_pattern.Parse(origin.GetOrigin().spec()) !=\n      URLPattern::PARSE_SUCCESS) {\n    return false;\n  }\n  origin_pattern.SetPath(\"/*\");\n  return AddPattern(origin_pattern);\n}",
        "func": "bool URLPatternSet::AddOrigin(int valid_schemes, const GURL& origin) {\n  if (origin.is_empty())\n    return false;\n  const url::Origin real_origin(origin);\n  DCHECK(real_origin.IsSameOriginWith(url::Origin(origin.GetOrigin())));\n  URLPattern origin_pattern(valid_schemes);\n  // Origin adding could fail if |origin| does not match |valid_schemes|.\n  if (origin_pattern.Parse(origin.spec()) != URLPattern::PARSE_SUCCESS) {\n    return false;\n  }\n  origin_pattern.SetPath(\"/*\");\n  return AddPattern(origin_pattern);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,9 +1,11 @@\n bool URLPatternSet::AddOrigin(int valid_schemes, const GURL& origin) {\n-  DCHECK_EQ(origin.GetOrigin(), origin);\n+  if (origin.is_empty())\n+    return false;\n+  const url::Origin real_origin(origin);\n+  DCHECK(real_origin.IsSameOriginWith(url::Origin(origin.GetOrigin())));\n   URLPattern origin_pattern(valid_schemes);\n   // Origin adding could fail if |origin| does not match |valid_schemes|.\n-  if (origin_pattern.Parse(origin.GetOrigin().spec()) !=\n-      URLPattern::PARSE_SUCCESS) {\n+  if (origin_pattern.Parse(origin.spec()) != URLPattern::PARSE_SUCCESS) {\n     return false;\n   }\n   origin_pattern.SetPath(\"/*\");",
        "diff_line_info": {
            "deleted_lines": [
                "  DCHECK_EQ(origin.GetOrigin(), origin);",
                "  if (origin_pattern.Parse(origin.GetOrigin().spec()) !=",
                "      URLPattern::PARSE_SUCCESS) {"
            ],
            "added_lines": [
                "  if (origin.is_empty())",
                "    return false;",
                "  const url::Origin real_origin(origin);",
                "  DCHECK(real_origin.IsSameOriginWith(url::Origin(origin.GetOrigin())));",
                "  if (origin_pattern.Parse(origin.spec()) != URLPattern::PARSE_SUCCESS) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-1658",
        "func_name": "chromium/GetExtensionName",
        "description": "The Extensions subsystem in Google Chrome before 50.0.2661.75 incorrectly relies on GetOrigin method calls for origin comparisons, which allows remote attackers to bypass the Same Origin Policy and obtain sensitive information via a crafted extension.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/5c437bcc7a51edbef45242c5173cf7871fde2866",
        "commit_title": "Make extensions use a correct same-origin check.",
        "commit_text": " GURL::GetOrigin does not do the right thing for all types of URLs.    ",
        "func_before": "bool GetExtensionName(content::WebContents* web_contents,\n                        const GURL& origin_url,\n                        std::string* name_out) override {\n    const Extension* extension = GetExtensionForWebContents(web_contents);\n    if (extension &&\n        web_contents->GetLastCommittedURL().GetOrigin() == origin_url) {\n      *name_out = extension->name();\n      return true;\n    }\n    return false;\n  }",
        "func": "bool GetExtensionName(content::WebContents* web_contents,\n                        const GURL& origin_url,\n                        std::string* name_out) override {\n    const Extension* extension = GetExtensionForWebContents(web_contents);\n    if (extension && url::IsSameOriginWith(\n                         origin_url, web_contents->GetLastCommittedURL())) {\n      *name_out = extension->name();\n      return true;\n    }\n    return false;\n  }",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,8 +2,8 @@\n                         const GURL& origin_url,\n                         std::string* name_out) override {\n     const Extension* extension = GetExtensionForWebContents(web_contents);\n-    if (extension &&\n-        web_contents->GetLastCommittedURL().GetOrigin() == origin_url) {\n+    if (extension && url::IsSameOriginWith(\n+                         origin_url, web_contents->GetLastCommittedURL())) {\n       *name_out = extension->name();\n       return true;\n     }",
        "diff_line_info": {
            "deleted_lines": [
                "    if (extension &&",
                "        web_contents->GetLastCommittedURL().GetOrigin() == origin_url) {"
            ],
            "added_lines": [
                "    if (extension && url::IsSameOriginWith(",
                "                         origin_url, web_contents->GetLastCommittedURL())) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-1658",
        "func_name": "chromium/ExtensionViewGuest::DidNavigateMainFrame",
        "description": "The Extensions subsystem in Google Chrome before 50.0.2661.75 incorrectly relies on GetOrigin method calls for origin comparisons, which allows remote attackers to bypass the Same Origin Policy and obtain sensitive information via a crafted extension.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/5c437bcc7a51edbef45242c5173cf7871fde2866",
        "commit_title": "Make extensions use a correct same-origin check.",
        "commit_text": " GURL::GetOrigin does not do the right thing for all types of URLs.    ",
        "func_before": "void ExtensionViewGuest::DidNavigateMainFrame(\n    const content::LoadCommittedDetails& details,\n    const content::FrameNavigateParams& params) {\n  if (attached() && (params.url.GetOrigin() != url_.GetOrigin())) {\n    bad_message::ReceivedBadMessage(web_contents()->GetRenderProcessHost(),\n                                    bad_message::EVG_BAD_ORIGIN);\n  }\n}",
        "func": "void ExtensionViewGuest::DidNavigateMainFrame(\n    const content::LoadCommittedDetails& details,\n    const content::FrameNavigateParams& params) {\n  if (attached() && !url::IsSameOriginWith(params.url, url_)) {\n    bad_message::ReceivedBadMessage(web_contents()->GetRenderProcessHost(),\n                                    bad_message::EVG_BAD_ORIGIN);\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,7 +1,7 @@\n void ExtensionViewGuest::DidNavigateMainFrame(\n     const content::LoadCommittedDetails& details,\n     const content::FrameNavigateParams& params) {\n-  if (attached() && (params.url.GetOrigin() != url_.GetOrigin())) {\n+  if (attached() && !url::IsSameOriginWith(params.url, url_)) {\n     bad_message::ReceivedBadMessage(web_contents()->GetRenderProcessHost(),\n                                     bad_message::EVG_BAD_ORIGIN);\n   }",
        "diff_line_info": {
            "deleted_lines": [
                "  if (attached() && (params.url.GetOrigin() != url_.GetOrigin())) {"
            ],
            "added_lines": [
                "  if (attached() && !url::IsSameOriginWith(params.url, url_)) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-1658",
        "func_name": "chromium/ExtensionViewGuest::NavigateGuest",
        "description": "The Extensions subsystem in Google Chrome before 50.0.2661.75 incorrectly relies on GetOrigin method calls for origin comparisons, which allows remote attackers to bypass the Same Origin Policy and obtain sensitive information via a crafted extension.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/5c437bcc7a51edbef45242c5173cf7871fde2866",
        "commit_title": "Make extensions use a correct same-origin check.",
        "commit_text": " GURL::GetOrigin does not do the right thing for all types of URLs.    ",
        "func_before": "bool ExtensionViewGuest::NavigateGuest(const std::string& src,\n                                       bool force_navigation) {\n  GURL url = extension_url_.Resolve(src);\n\n  // If the URL is not valid, about:blank, or the same origin as the extension,\n  // then navigate to about:blank.\n  bool url_not_allowed = (url != GURL(url::kAboutBlankURL)) &&\n      (url.GetOrigin() != extension_url_.GetOrigin());\n  if (!url.is_valid() || url_not_allowed)\n    return NavigateGuest(url::kAboutBlankURL, true /* force_navigation */);\n\n  if (!force_navigation && (url_ == url))\n    return false;\n\n  web_contents()->GetRenderProcessHost()->FilterURL(false, &url);\n  web_contents()->GetController().LoadURL(url, content::Referrer(),\n                                          ui::PAGE_TRANSITION_AUTO_TOPLEVEL,\n                                          std::string());\n\n  url_ = url;\n  return true;\n}",
        "func": "bool ExtensionViewGuest::NavigateGuest(const std::string& src,\n                                       bool force_navigation) {\n  GURL url = extension_url_.Resolve(src);\n\n  // If the URL is not valid, about:blank, or the same origin as the extension,\n  // then navigate to about:blank.\n  bool url_not_allowed = url != GURL(url::kAboutBlankURL) &&\n                         !url::IsSameOriginWith(url, extension_url_);\n  if (!url.is_valid() || url_not_allowed)\n    return NavigateGuest(url::kAboutBlankURL, true /* force_navigation */);\n\n  if (!force_navigation && (url_ == url))\n    return false;\n\n  web_contents()->GetRenderProcessHost()->FilterURL(false, &url);\n  web_contents()->GetController().LoadURL(url, content::Referrer(),\n                                          ui::PAGE_TRANSITION_AUTO_TOPLEVEL,\n                                          std::string());\n\n  url_ = url;\n  return true;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,8 +4,8 @@\n \n   // If the URL is not valid, about:blank, or the same origin as the extension,\n   // then navigate to about:blank.\n-  bool url_not_allowed = (url != GURL(url::kAboutBlankURL)) &&\n-      (url.GetOrigin() != extension_url_.GetOrigin());\n+  bool url_not_allowed = url != GURL(url::kAboutBlankURL) &&\n+                         !url::IsSameOriginWith(url, extension_url_);\n   if (!url.is_valid() || url_not_allowed)\n     return NavigateGuest(url::kAboutBlankURL, true /* force_navigation */);\n ",
        "diff_line_info": {
            "deleted_lines": [
                "  bool url_not_allowed = (url != GURL(url::kAboutBlankURL)) &&",
                "      (url.GetOrigin() != extension_url_.GetOrigin());"
            ],
            "added_lines": [
                "  bool url_not_allowed = url != GURL(url::kAboutBlankURL) &&",
                "                         !url::IsSameOriginWith(url, extension_url_);"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-1658",
        "func_name": "chromium/ExtensionOptionsGuest::DidNavigateMainFrame",
        "description": "The Extensions subsystem in Google Chrome before 50.0.2661.75 incorrectly relies on GetOrigin method calls for origin comparisons, which allows remote attackers to bypass the Same Origin Policy and obtain sensitive information via a crafted extension.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/5c437bcc7a51edbef45242c5173cf7871fde2866",
        "commit_title": "Make extensions use a correct same-origin check.",
        "commit_text": " GURL::GetOrigin does not do the right thing for all types of URLs.    ",
        "func_before": "void ExtensionOptionsGuest::DidNavigateMainFrame(\n    const content::LoadCommittedDetails& details,\n    const content::FrameNavigateParams& params) {\n  if (attached()) {\n    auto guest_zoom_controller =\n        ui_zoom::ZoomController::FromWebContents(web_contents());\n    guest_zoom_controller->SetZoomMode(\n        ui_zoom::ZoomController::ZOOM_MODE_ISOLATED);\n    SetGuestZoomLevelToMatchEmbedder();\n\n    if (params.url.GetOrigin() != options_page_.GetOrigin()) {\n      bad_message::ReceivedBadMessage(web_contents()->GetRenderProcessHost(),\n                                      bad_message::EOG_BAD_ORIGIN);\n    }\n  }\n}",
        "func": "void ExtensionOptionsGuest::DidNavigateMainFrame(\n    const content::LoadCommittedDetails& details,\n    const content::FrameNavigateParams& params) {\n  if (attached()) {\n    auto guest_zoom_controller =\n        ui_zoom::ZoomController::FromWebContents(web_contents());\n    guest_zoom_controller->SetZoomMode(\n        ui_zoom::ZoomController::ZOOM_MODE_ISOLATED);\n    SetGuestZoomLevelToMatchEmbedder();\n\n    if (!url::IsSameOriginWith(params.url, options_page_)) {\n      bad_message::ReceivedBadMessage(web_contents()->GetRenderProcessHost(),\n                                      bad_message::EOG_BAD_ORIGIN);\n    }\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -8,7 +8,7 @@\n         ui_zoom::ZoomController::ZOOM_MODE_ISOLATED);\n     SetGuestZoomLevelToMatchEmbedder();\n \n-    if (params.url.GetOrigin() != options_page_.GetOrigin()) {\n+    if (!url::IsSameOriginWith(params.url, options_page_)) {\n       bad_message::ReceivedBadMessage(web_contents()->GetRenderProcessHost(),\n                                       bad_message::EOG_BAD_ORIGIN);\n     }",
        "diff_line_info": {
            "deleted_lines": [
                "    if (params.url.GetOrigin() != options_page_.GetOrigin()) {"
            ],
            "added_lines": [
                "    if (!url::IsSameOriginWith(params.url, options_page_)) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-1658",
        "func_name": "chromium/FileSystemNatives::GetIsolatedFileSystem",
        "description": "The Extensions subsystem in Google Chrome before 50.0.2661.75 incorrectly relies on GetOrigin method calls for origin comparisons, which allows remote attackers to bypass the Same Origin Policy and obtain sensitive information via a crafted extension.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/5c437bcc7a51edbef45242c5173cf7871fde2866",
        "commit_title": "Make extensions use a correct same-origin check.",
        "commit_text": " GURL::GetOrigin does not do the right thing for all types of URLs.    ",
        "func_before": "void FileSystemNatives::GetIsolatedFileSystem(\n    const v8::FunctionCallbackInfo<v8::Value>& args) {\n  CHECK(args.Length() == 1 || args.Length() == 2);\n  CHECK(args[0]->IsString());\n  std::string file_system_id(*v8::String::Utf8Value(args[0]));\n  blink::WebLocalFrame* webframe =\n      blink::WebLocalFrame::frameForContext(context()->v8_context());\n  DCHECK(webframe);\n\n  GURL context_url =\n      extensions::ScriptContext::GetDataSourceURLForFrame(webframe);\n  CHECK(context_url.SchemeIs(extensions::kExtensionScheme));\n\n  std::string name(storage::GetIsolatedFileSystemName(context_url.GetOrigin(),\n                                                      file_system_id));\n\n  // The optional second argument is the subfolder within the isolated file\n  // system at which to root the DOMFileSystem we're returning to the caller.\n  std::string optional_root_name;\n  if (args.Length() == 2) {\n    CHECK(args[1]->IsString());\n    optional_root_name = *v8::String::Utf8Value(args[1]);\n  }\n\n  GURL root_url(storage::GetIsolatedFileSystemRootURIString(\n      context_url.GetOrigin(), file_system_id, optional_root_name));\n\n  args.GetReturnValue().Set(\n      blink::WebDOMFileSystem::create(webframe,\n                                      blink::WebFileSystemTypeIsolated,\n                                      blink::WebString::fromUTF8(name),\n                                      root_url)\n          .toV8Value(context()->v8_context()->Global(), args.GetIsolate()));\n}",
        "func": "void FileSystemNatives::GetIsolatedFileSystem(\n    const v8::FunctionCallbackInfo<v8::Value>& args) {\n  CHECK(args.Length() == 1 || args.Length() == 2);\n  CHECK(args[0]->IsString());\n  std::string file_system_id(*v8::String::Utf8Value(args[0]));\n  blink::WebLocalFrame* webframe =\n      blink::WebLocalFrame::frameForContext(context()->v8_context());\n  DCHECK(webframe);\n\n  GURL context_url =\n      extensions::ScriptContext::GetDataSourceURLForFrame(webframe);\n  CHECK(context_url.SchemeIs(extensions::kExtensionScheme));\n\n  const GURL origin(url::Origin(context_url).Serialize());\n  std::string name(storage::GetIsolatedFileSystemName(origin, file_system_id));\n\n  // The optional second argument is the subfolder within the isolated file\n  // system at which to root the DOMFileSystem we're returning to the caller.\n  std::string optional_root_name;\n  if (args.Length() == 2) {\n    CHECK(args[1]->IsString());\n    optional_root_name = *v8::String::Utf8Value(args[1]);\n  }\n\n  GURL root_url(storage::GetIsolatedFileSystemRootURIString(\n      origin, file_system_id, optional_root_name));\n\n  args.GetReturnValue().Set(\n      blink::WebDOMFileSystem::create(webframe,\n                                      blink::WebFileSystemTypeIsolated,\n                                      blink::WebString::fromUTF8(name),\n                                      root_url)\n          .toV8Value(context()->v8_context()->Global(), args.GetIsolate()));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -11,8 +11,8 @@\n       extensions::ScriptContext::GetDataSourceURLForFrame(webframe);\n   CHECK(context_url.SchemeIs(extensions::kExtensionScheme));\n \n-  std::string name(storage::GetIsolatedFileSystemName(context_url.GetOrigin(),\n-                                                      file_system_id));\n+  const GURL origin(url::Origin(context_url).Serialize());\n+  std::string name(storage::GetIsolatedFileSystemName(origin, file_system_id));\n \n   // The optional second argument is the subfolder within the isolated file\n   // system at which to root the DOMFileSystem we're returning to the caller.\n@@ -23,7 +23,7 @@\n   }\n \n   GURL root_url(storage::GetIsolatedFileSystemRootURIString(\n-      context_url.GetOrigin(), file_system_id, optional_root_name));\n+      origin, file_system_id, optional_root_name));\n \n   args.GetReturnValue().Set(\n       blink::WebDOMFileSystem::create(webframe,",
        "diff_line_info": {
            "deleted_lines": [
                "  std::string name(storage::GetIsolatedFileSystemName(context_url.GetOrigin(),",
                "                                                      file_system_id));",
                "      context_url.GetOrigin(), file_system_id, optional_root_name));"
            ],
            "added_lines": [
                "  const GURL origin(url::Origin(context_url).Serialize());",
                "  std::string name(storage::GetIsolatedFileSystemName(origin, file_system_id));",
                "      origin, file_system_id, optional_root_name));"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-4081",
        "func_name": "wireshark/iax2_add_ts_fields",
        "description": "epan/dissectors/packet-iax2.c in the IAX2 dissector in Wireshark 1.12.x before 1.12.11 and 2.0.x before 2.0.3 uses an incorrect integer data type, which allows remote attackers to cause a denial of service (infinite loop) via a crafted packet.",
        "git_url": "https://github.com/wireshark/wireshark/commit/42f299be6abb302f32cec78b1c0812364c9f9285",
        "commit_title": "IAX2: fix an infinite loop",
        "commit_text": " Bug: 12260",
        "func_before": "static void iax2_add_ts_fields(packet_info *pinfo, proto_tree *iax2_tree, iax_packet_data *iax_packet, guint16 shortts)\n{\n  guint32     longts =shortts;\n  nstime_t    ts;\n  proto_item *item;\n\n  if (iax_packet->call_data == NULL) {\n    /* no call info for this frame; perhaps we missed the NEW packet */\n    return;\n  }\n\n  if (iax_packet->abstime.secs == -1) {\n    time_t start_secs = iax_packet->call_data->start_time.secs;\n    gint32 abs_secs = (gint32)(start_secs + longts/1000);\n\n    /* deal with short timestamps by assuming that packets are never more than\n     * 16 seconds late */\n    while(abs_secs < pinfo->abs_ts.secs - 16) {\n      longts += 32768;\n      abs_secs = (gint32)(start_secs + longts/1000);\n    }\n\n    iax_packet->abstime.secs=abs_secs;\n    iax_packet->abstime.nsecs=iax_packet->call_data->start_time.nsecs + (longts % 1000) * 1000000;\n    if (iax_packet->abstime.nsecs >= 1000000000) {\n      iax_packet->abstime.nsecs -= 1000000000;\n      iax_packet->abstime.secs ++;\n    }\n  }\n  iax2_info->timestamp = longts;\n\n  if (iax2_tree) {\n    item = proto_tree_add_time(iax2_tree, hf_iax2_absts, NULL, 0, 0, &iax_packet->abstime);\n    PROTO_ITEM_SET_GENERATED(item);\n\n    ts  = pinfo->abs_ts;\n    nstime_delta(&ts, &ts, &iax_packet->abstime);\n\n    item = proto_tree_add_time(iax2_tree, hf_iax2_lateness, NULL, 0, 0, &ts);\n    PROTO_ITEM_SET_GENERATED(item);\n  }\n}",
        "func": "static void iax2_add_ts_fields(packet_info *pinfo, proto_tree *iax2_tree, iax_packet_data *iax_packet, guint16 shortts)\n{\n  guint32     longts =shortts;\n  nstime_t    ts;\n  proto_item *item;\n\n  if (iax_packet->call_data == NULL) {\n    /* no call info for this frame; perhaps we missed the NEW packet */\n    return;\n  }\n\n  if (iax_packet->abstime.secs == -1) {\n    time_t start_secs = iax_packet->call_data->start_time.secs;\n    time_t abs_secs = start_secs + longts/1000;\n\n    /* deal with short timestamps by assuming that packets are never more than\n     * 16 seconds late */\n    while(abs_secs < pinfo->abs_ts.secs - 16) {\n      longts += 32768;\n      abs_secs = start_secs + longts/1000;\n    }\n\n    iax_packet->abstime.secs=abs_secs;\n    iax_packet->abstime.nsecs=iax_packet->call_data->start_time.nsecs + (longts % 1000) * 1000000;\n    if (iax_packet->abstime.nsecs >= 1000000000) {\n      iax_packet->abstime.nsecs -= 1000000000;\n      iax_packet->abstime.secs ++;\n    }\n  }\n  iax2_info->timestamp = longts;\n\n  if (iax2_tree) {\n    item = proto_tree_add_time(iax2_tree, hf_iax2_absts, NULL, 0, 0, &iax_packet->abstime);\n    PROTO_ITEM_SET_GENERATED(item);\n\n    ts  = pinfo->abs_ts;\n    nstime_delta(&ts, &ts, &iax_packet->abstime);\n\n    item = proto_tree_add_time(iax2_tree, hf_iax2_lateness, NULL, 0, 0, &ts);\n    PROTO_ITEM_SET_GENERATED(item);\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -11,13 +11,13 @@\n \n   if (iax_packet->abstime.secs == -1) {\n     time_t start_secs = iax_packet->call_data->start_time.secs;\n-    gint32 abs_secs = (gint32)(start_secs + longts/1000);\n+    time_t abs_secs = start_secs + longts/1000;\n \n     /* deal with short timestamps by assuming that packets are never more than\n      * 16 seconds late */\n     while(abs_secs < pinfo->abs_ts.secs - 16) {\n       longts += 32768;\n-      abs_secs = (gint32)(start_secs + longts/1000);\n+      abs_secs = start_secs + longts/1000;\n     }\n \n     iax_packet->abstime.secs=abs_secs;",
        "diff_line_info": {
            "deleted_lines": [
                "    gint32 abs_secs = (gint32)(start_secs + longts/1000);",
                "      abs_secs = (gint32)(start_secs + longts/1000);"
            ],
            "added_lines": [
                "    time_t abs_secs = start_secs + longts/1000;",
                "      abs_secs = start_secs + longts/1000;"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-8845",
        "func_name": "torvalds/linux/tm_reclaim_thread",
        "description": "The tm_reclaim_thread function in arch/powerpc/kernel/process.c in the Linux kernel before 4.4.1 on powerpc platforms does not ensure that TM suspend mode exists before proceeding with a tm_reclaim call, which allows local users to cause a denial of service (TM Bad Thing exception and panic) via a crafted application.",
        "git_url": "https://github.com/torvalds/linux/commit/7f821fc9c77a9b01fe7b1d6e72717b33d8d64142",
        "commit_title": "powerpc/tm: Check for already reclaimed tasks",
        "commit_text": " Currently we can hit a scenario where we'll tm_reclaim() twice.  This results in a TM bad thing exception because the second reclaim occurs when not in suspend mode.  The scenario in which this can happen is the following.  We attempt to deliver a signal to userspace.  To do this we need obtain the stack pointer to write the signal context.  To get this stack pointer we must tm_reclaim() in case we need to use the checkpointed stack pointer (see get_tm_stackpointer()).  Normally we'd then return directly to userspace to deliver the signal without going through __switch_to().  Unfortunatley, if at this point we get an error (such as a bad userspace stack pointer), we need to exit the process.  The exit will result in a __switch_to().  __switch_to() will attempt to save the process state which results in another tm_reclaim().  This tm_reclaim() now causes a TM Bad Thing exception as this state has already been saved and the processor is no longer in TM suspend mode. Whee!  This patch checks the state of the MSR to ensure we are TM suspended before we attempt the tm_reclaim().  If we've already saved the state away, we should no longer be in TM suspend mode.  This has the additional advantage of checking for a potential TM Bad Thing exception.  Found using syscall fuzzer.  Cc: stable@vger.kernel.org # v3.9+",
        "func_before": "static void tm_reclaim_thread(struct thread_struct *thr,\n\t\t\t      struct thread_info *ti, uint8_t cause)\n{\n\tunsigned long msr_diff = 0;\n\n\t/*\n\t * If FP/VSX registers have been already saved to the\n\t * thread_struct, move them to the transact_fp array.\n\t * We clear the TIF_RESTORE_TM bit since after the reclaim\n\t * the thread will no longer be transactional.\n\t */\n\tif (test_ti_thread_flag(ti, TIF_RESTORE_TM)) {\n\t\tmsr_diff = thr->ckpt_regs.msr & ~thr->regs->msr;\n\t\tif (msr_diff & MSR_FP)\n\t\t\tmemcpy(&thr->transact_fp, &thr->fp_state,\n\t\t\t       sizeof(struct thread_fp_state));\n\t\tif (msr_diff & MSR_VEC)\n\t\t\tmemcpy(&thr->transact_vr, &thr->vr_state,\n\t\t\t       sizeof(struct thread_vr_state));\n\t\tclear_ti_thread_flag(ti, TIF_RESTORE_TM);\n\t\tmsr_diff &= MSR_FP | MSR_VEC | MSR_VSX | MSR_FE0 | MSR_FE1;\n\t}\n\n\ttm_reclaim(thr, thr->regs->msr, cause);\n\n\t/* Having done the reclaim, we now have the checkpointed\n\t * FP/VSX values in the registers.  These might be valid\n\t * even if we have previously called enable_kernel_fp() or\n\t * flush_fp_to_thread(), so update thr->regs->msr to\n\t * indicate their current validity.\n\t */\n\tthr->regs->msr |= msr_diff;\n}",
        "func": "static void tm_reclaim_thread(struct thread_struct *thr,\n\t\t\t      struct thread_info *ti, uint8_t cause)\n{\n\tunsigned long msr_diff = 0;\n\n\t/*\n\t * If FP/VSX registers have been already saved to the\n\t * thread_struct, move them to the transact_fp array.\n\t * We clear the TIF_RESTORE_TM bit since after the reclaim\n\t * the thread will no longer be transactional.\n\t */\n\tif (test_ti_thread_flag(ti, TIF_RESTORE_TM)) {\n\t\tmsr_diff = thr->ckpt_regs.msr & ~thr->regs->msr;\n\t\tif (msr_diff & MSR_FP)\n\t\t\tmemcpy(&thr->transact_fp, &thr->fp_state,\n\t\t\t       sizeof(struct thread_fp_state));\n\t\tif (msr_diff & MSR_VEC)\n\t\t\tmemcpy(&thr->transact_vr, &thr->vr_state,\n\t\t\t       sizeof(struct thread_vr_state));\n\t\tclear_ti_thread_flag(ti, TIF_RESTORE_TM);\n\t\tmsr_diff &= MSR_FP | MSR_VEC | MSR_VSX | MSR_FE0 | MSR_FE1;\n\t}\n\n\t/*\n\t * Use the current MSR TM suspended bit to track if we have\n\t * checkpointed state outstanding.\n\t * On signal delivery, we'd normally reclaim the checkpointed\n\t * state to obtain stack pointer (see:get_tm_stackpointer()).\n\t * This will then directly return to userspace without going\n\t * through __switch_to(). However, if the stack frame is bad,\n\t * we need to exit this thread which calls __switch_to() which\n\t * will again attempt to reclaim the already saved tm state.\n\t * Hence we need to check that we've not already reclaimed\n\t * this state.\n\t * We do this using the current MSR, rather tracking it in\n\t * some specific thread_struct bit, as it has the additional\n\t * benifit of checking for a potential TM bad thing exception.\n\t */\n\tif (!MSR_TM_SUSPENDED(mfmsr()))\n\t\treturn;\n\n\ttm_reclaim(thr, thr->regs->msr, cause);\n\n\t/* Having done the reclaim, we now have the checkpointed\n\t * FP/VSX values in the registers.  These might be valid\n\t * even if we have previously called enable_kernel_fp() or\n\t * flush_fp_to_thread(), so update thr->regs->msr to\n\t * indicate their current validity.\n\t */\n\tthr->regs->msr |= msr_diff;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -21,6 +21,24 @@\n \t\tmsr_diff &= MSR_FP | MSR_VEC | MSR_VSX | MSR_FE0 | MSR_FE1;\n \t}\n \n+\t/*\n+\t * Use the current MSR TM suspended bit to track if we have\n+\t * checkpointed state outstanding.\n+\t * On signal delivery, we'd normally reclaim the checkpointed\n+\t * state to obtain stack pointer (see:get_tm_stackpointer()).\n+\t * This will then directly return to userspace without going\n+\t * through __switch_to(). However, if the stack frame is bad,\n+\t * we need to exit this thread which calls __switch_to() which\n+\t * will again attempt to reclaim the already saved tm state.\n+\t * Hence we need to check that we've not already reclaimed\n+\t * this state.\n+\t * We do this using the current MSR, rather tracking it in\n+\t * some specific thread_struct bit, as it has the additional\n+\t * benifit of checking for a potential TM bad thing exception.\n+\t */\n+\tif (!MSR_TM_SUSPENDED(mfmsr()))\n+\t\treturn;\n+\n \ttm_reclaim(thr, thr->regs->msr, cause);\n \n \t/* Having done the reclaim, we now have the checkpointed",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t/*",
                "\t * Use the current MSR TM suspended bit to track if we have",
                "\t * checkpointed state outstanding.",
                "\t * On signal delivery, we'd normally reclaim the checkpointed",
                "\t * state to obtain stack pointer (see:get_tm_stackpointer()).",
                "\t * This will then directly return to userspace without going",
                "\t * through __switch_to(). However, if the stack frame is bad,",
                "\t * we need to exit this thread which calls __switch_to() which",
                "\t * will again attempt to reclaim the already saved tm state.",
                "\t * Hence we need to check that we've not already reclaimed",
                "\t * this state.",
                "\t * We do this using the current MSR, rather tracking it in",
                "\t * some specific thread_struct bit, as it has the additional",
                "\t * benifit of checking for a potential TM bad thing exception.",
                "\t */",
                "\tif (!MSR_TM_SUSPENDED(mfmsr()))",
                "\t\treturn;",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2012-6689",
        "func_name": "torvalds/linux/netlink_add_usersock_entry",
        "description": "The netlink_sendmsg function in net/netlink/af_netlink.c in the Linux kernel before 3.5.5 does not validate the dst_pid field, which allows local users to have an unspecified impact by spoofing Netlink messages.",
        "git_url": "https://github.com/torvalds/linux/commit/20e1db19db5d6b9e4e83021595eab0dc8f107bef",
        "commit_title": "netlink: fix possible spoofing from non-root processes",
        "commit_text": " Non-root user-space processes can send Netlink messages to other processes that are well-known for being subscribed to Netlink asynchronous notifications. This allows ilegitimate non-root process to send forged messages to Netlink subscribers.  The userspace process usually verifies the legitimate origin in two ways:  a) Socket credentials. If UID != 0, then the message comes from    some ilegitimate process and the message needs to be dropped.  b) Netlink portID. In general, portID == 0 means that the origin    of the messages comes from the kernel. Thus, discarding any    message not coming from the kernel.  However, ctnetlink sets the portID in event messages that has been triggered by some user-space process, eg. conntrack utility. So other processes subscribed to ctnetlink events, eg. conntrackd, know that the event was triggered by some user-space action.  Neither of the two ways to discard ilegitimate messages coming from non-root processes can help for ctnetlink.  This patch adds capability validation in case that dst_pid is set in netlink_sendmsg(). This approach is aggressive since existing applications using any Netlink bus to deliver messages between two user-space processes will break. Note that the exception is NETLINK_USERSOCK, since it is reserved for netlink-to-netlink userspace communication.  Still, if anyone wants that his Netlink bus allows netlink-to-netlink userspace, then they can set NL_NONROOT_SEND. However, by default, I don't think it makes sense to allow to use NETLINK_ROUTE to communicate two processes that are sending no matter what information that is not related to link/neighbouring/routing. They should be using NETLINK_USERSOCK instead for that. ",
        "func_before": "static void __init netlink_add_usersock_entry(void)\n{\n\tstruct listeners *listeners;\n\tint groups = 32;\n\n\tlisteners = kzalloc(sizeof(*listeners) + NLGRPSZ(groups), GFP_KERNEL);\n\tif (!listeners)\n\t\tpanic(\"netlink_add_usersock_entry: Cannot allocate listeners\\n\");\n\n\tnetlink_table_grab();\n\n\tnl_table[NETLINK_USERSOCK].groups = groups;\n\trcu_assign_pointer(nl_table[NETLINK_USERSOCK].listeners, listeners);\n\tnl_table[NETLINK_USERSOCK].module = THIS_MODULE;\n\tnl_table[NETLINK_USERSOCK].registered = 1;\n\n\tnetlink_table_ungrab();\n}",
        "func": "static void __init netlink_add_usersock_entry(void)\n{\n\tstruct listeners *listeners;\n\tint groups = 32;\n\n\tlisteners = kzalloc(sizeof(*listeners) + NLGRPSZ(groups), GFP_KERNEL);\n\tif (!listeners)\n\t\tpanic(\"netlink_add_usersock_entry: Cannot allocate listeners\\n\");\n\n\tnetlink_table_grab();\n\n\tnl_table[NETLINK_USERSOCK].groups = groups;\n\trcu_assign_pointer(nl_table[NETLINK_USERSOCK].listeners, listeners);\n\tnl_table[NETLINK_USERSOCK].module = THIS_MODULE;\n\tnl_table[NETLINK_USERSOCK].registered = 1;\n\tnl_table[NETLINK_USERSOCK].nl_nonroot = NL_NONROOT_SEND;\n\n\tnetlink_table_ungrab();\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -13,6 +13,7 @@\n \trcu_assign_pointer(nl_table[NETLINK_USERSOCK].listeners, listeners);\n \tnl_table[NETLINK_USERSOCK].module = THIS_MODULE;\n \tnl_table[NETLINK_USERSOCK].registered = 1;\n+\tnl_table[NETLINK_USERSOCK].nl_nonroot = NL_NONROOT_SEND;\n \n \tnetlink_table_ungrab();\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tnl_table[NETLINK_USERSOCK].nl_nonroot = NL_NONROOT_SEND;"
            ]
        }
    },
    {
        "cve_id": "CVE-2012-6689",
        "func_name": "torvalds/linux/netlink_sendmsg",
        "description": "The netlink_sendmsg function in net/netlink/af_netlink.c in the Linux kernel before 3.5.5 does not validate the dst_pid field, which allows local users to have an unspecified impact by spoofing Netlink messages.",
        "git_url": "https://github.com/torvalds/linux/commit/20e1db19db5d6b9e4e83021595eab0dc8f107bef",
        "commit_title": "netlink: fix possible spoofing from non-root processes",
        "commit_text": " Non-root user-space processes can send Netlink messages to other processes that are well-known for being subscribed to Netlink asynchronous notifications. This allows ilegitimate non-root process to send forged messages to Netlink subscribers.  The userspace process usually verifies the legitimate origin in two ways:  a) Socket credentials. If UID != 0, then the message comes from    some ilegitimate process and the message needs to be dropped.  b) Netlink portID. In general, portID == 0 means that the origin    of the messages comes from the kernel. Thus, discarding any    message not coming from the kernel.  However, ctnetlink sets the portID in event messages that has been triggered by some user-space process, eg. conntrack utility. So other processes subscribed to ctnetlink events, eg. conntrackd, know that the event was triggered by some user-space action.  Neither of the two ways to discard ilegitimate messages coming from non-root processes can help for ctnetlink.  This patch adds capability validation in case that dst_pid is set in netlink_sendmsg(). This approach is aggressive since existing applications using any Netlink bus to deliver messages between two user-space processes will break. Note that the exception is NETLINK_USERSOCK, since it is reserved for netlink-to-netlink userspace communication.  Still, if anyone wants that his Netlink bus allows netlink-to-netlink userspace, then they can set NL_NONROOT_SEND. However, by default, I don't think it makes sense to allow to use NETLINK_ROUTE to communicate two processes that are sending no matter what information that is not related to link/neighbouring/routing. They should be using NETLINK_USERSOCK instead for that. ",
        "func_before": "static int netlink_sendmsg(struct kiocb *kiocb, struct socket *sock,\n\t\t\t   struct msghdr *msg, size_t len)\n{\n\tstruct sock_iocb *siocb = kiocb_to_siocb(kiocb);\n\tstruct sock *sk = sock->sk;\n\tstruct netlink_sock *nlk = nlk_sk(sk);\n\tstruct sockaddr_nl *addr = msg->msg_name;\n\tu32 dst_pid;\n\tu32 dst_group;\n\tstruct sk_buff *skb;\n\tint err;\n\tstruct scm_cookie scm;\n\n\tif (msg->msg_flags&MSG_OOB)\n\t\treturn -EOPNOTSUPP;\n\n\tif (NULL == siocb->scm)\n\t\tsiocb->scm = &scm;\n\n\terr = scm_send(sock, msg, siocb->scm, true);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (msg->msg_namelen) {\n\t\terr = -EINVAL;\n\t\tif (addr->nl_family != AF_NETLINK)\n\t\t\tgoto out;\n\t\tdst_pid = addr->nl_pid;\n\t\tdst_group = ffs(addr->nl_groups);\n\t\terr =  -EPERM;\n\t\tif (dst_group && !netlink_capable(sock, NL_NONROOT_SEND))\n\t\t\tgoto out;\n\t} else {\n\t\tdst_pid = nlk->dst_pid;\n\t\tdst_group = nlk->dst_group;\n\t}\n\n\tif (!nlk->pid) {\n\t\terr = netlink_autobind(sock);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\terr = -EMSGSIZE;\n\tif (len > sk->sk_sndbuf - 32)\n\t\tgoto out;\n\terr = -ENOBUFS;\n\tskb = alloc_skb(len, GFP_KERNEL);\n\tif (skb == NULL)\n\t\tgoto out;\n\n\tNETLINK_CB(skb).pid\t= nlk->pid;\n\tNETLINK_CB(skb).dst_group = dst_group;\n\tmemcpy(NETLINK_CREDS(skb), &siocb->scm->creds, sizeof(struct ucred));\n\n\terr = -EFAULT;\n\tif (memcpy_fromiovec(skb_put(skb, len), msg->msg_iov, len)) {\n\t\tkfree_skb(skb);\n\t\tgoto out;\n\t}\n\n\terr = security_netlink_send(sk, skb);\n\tif (err) {\n\t\tkfree_skb(skb);\n\t\tgoto out;\n\t}\n\n\tif (dst_group) {\n\t\tatomic_inc(&skb->users);\n\t\tnetlink_broadcast(sk, skb, dst_pid, dst_group, GFP_KERNEL);\n\t}\n\terr = netlink_unicast(sk, skb, dst_pid, msg->msg_flags&MSG_DONTWAIT);\n\nout:\n\tscm_destroy(siocb->scm);\n\treturn err;\n}",
        "func": "static int netlink_sendmsg(struct kiocb *kiocb, struct socket *sock,\n\t\t\t   struct msghdr *msg, size_t len)\n{\n\tstruct sock_iocb *siocb = kiocb_to_siocb(kiocb);\n\tstruct sock *sk = sock->sk;\n\tstruct netlink_sock *nlk = nlk_sk(sk);\n\tstruct sockaddr_nl *addr = msg->msg_name;\n\tu32 dst_pid;\n\tu32 dst_group;\n\tstruct sk_buff *skb;\n\tint err;\n\tstruct scm_cookie scm;\n\n\tif (msg->msg_flags&MSG_OOB)\n\t\treturn -EOPNOTSUPP;\n\n\tif (NULL == siocb->scm)\n\t\tsiocb->scm = &scm;\n\n\terr = scm_send(sock, msg, siocb->scm, true);\n\tif (err < 0)\n\t\treturn err;\n\n\tif (msg->msg_namelen) {\n\t\terr = -EINVAL;\n\t\tif (addr->nl_family != AF_NETLINK)\n\t\t\tgoto out;\n\t\tdst_pid = addr->nl_pid;\n\t\tdst_group = ffs(addr->nl_groups);\n\t\terr =  -EPERM;\n\t\tif ((dst_group || dst_pid) &&\n\t\t    !netlink_capable(sock, NL_NONROOT_SEND))\n\t\t\tgoto out;\n\t} else {\n\t\tdst_pid = nlk->dst_pid;\n\t\tdst_group = nlk->dst_group;\n\t}\n\n\tif (!nlk->pid) {\n\t\terr = netlink_autobind(sock);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\terr = -EMSGSIZE;\n\tif (len > sk->sk_sndbuf - 32)\n\t\tgoto out;\n\terr = -ENOBUFS;\n\tskb = alloc_skb(len, GFP_KERNEL);\n\tif (skb == NULL)\n\t\tgoto out;\n\n\tNETLINK_CB(skb).pid\t= nlk->pid;\n\tNETLINK_CB(skb).dst_group = dst_group;\n\tmemcpy(NETLINK_CREDS(skb), &siocb->scm->creds, sizeof(struct ucred));\n\n\terr = -EFAULT;\n\tif (memcpy_fromiovec(skb_put(skb, len), msg->msg_iov, len)) {\n\t\tkfree_skb(skb);\n\t\tgoto out;\n\t}\n\n\terr = security_netlink_send(sk, skb);\n\tif (err) {\n\t\tkfree_skb(skb);\n\t\tgoto out;\n\t}\n\n\tif (dst_group) {\n\t\tatomic_inc(&skb->users);\n\t\tnetlink_broadcast(sk, skb, dst_pid, dst_group, GFP_KERNEL);\n\t}\n\terr = netlink_unicast(sk, skb, dst_pid, msg->msg_flags&MSG_DONTWAIT);\n\nout:\n\tscm_destroy(siocb->scm);\n\treturn err;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -28,7 +28,8 @@\n \t\tdst_pid = addr->nl_pid;\n \t\tdst_group = ffs(addr->nl_groups);\n \t\terr =  -EPERM;\n-\t\tif (dst_group && !netlink_capable(sock, NL_NONROOT_SEND))\n+\t\tif ((dst_group || dst_pid) &&\n+\t\t    !netlink_capable(sock, NL_NONROOT_SEND))\n \t\t\tgoto out;\n \t} else {\n \t\tdst_pid = nlk->dst_pid;",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tif (dst_group && !netlink_capable(sock, NL_NONROOT_SEND))"
            ],
            "added_lines": [
                "\t\tif ((dst_group || dst_pid) &&",
                "\t\t    !netlink_capable(sock, NL_NONROOT_SEND))"
            ]
        }
    },
    {
        "cve_id": "CVE-2014-9717",
        "func_name": "torvalds/linux/__detach_mounts",
        "description": "fs/namespace.c in the Linux kernel before 4.0.2 processes MNT_DETACH umount2 system calls without verifying that the MNT_LOCKED flag is unset, which allows local users to bypass intended access restrictions and navigate to filesystem locations beneath a mount by calling umount2 within a user namespace.",
        "git_url": "https://github.com/torvalds/linux/commit/ce07d891a0891d3c0d0c2d73d577490486b809e1",
        "commit_title": "mnt: Honor MNT_LOCKED when detaching mounts",
        "commit_text": " Modify umount(MNT_DETACH) to keep mounts in the hash table that are locked to their parent mounts, when the parent is lazily unmounted.  In mntput_no_expire detach the children from the hash table, depending on mnt_pin_kill in cleanup_mnt to decrement the mnt_count of the children.  In __detach_mounts if there are any mounts that have been unmounted but still are on the list of mounts of a mountpoint, remove their children from the mount hash table and those children to the unmounted list so they won't linger potentially indefinitely waiting for their final mntput, now that the mounts serve no purpose.  Cc: stable@vger.kernel.org",
        "func_before": "void __detach_mounts(struct dentry *dentry)\n{\n\tstruct mountpoint *mp;\n\tstruct mount *mnt;\n\n\tnamespace_lock();\n\tmp = lookup_mountpoint(dentry);\n\tif (!mp)\n\t\tgoto out_unlock;\n\n\tlock_mount_hash();\n\twhile (!hlist_empty(&mp->m_list)) {\n\t\tmnt = hlist_entry(mp->m_list.first, struct mount, mnt_mp_list);\n\t\tumount_tree(mnt, 0);\n\t}\n\tunlock_mount_hash();\n\tput_mountpoint(mp);\nout_unlock:\n\tnamespace_unlock();\n}",
        "func": "void __detach_mounts(struct dentry *dentry)\n{\n\tstruct mountpoint *mp;\n\tstruct mount *mnt;\n\n\tnamespace_lock();\n\tmp = lookup_mountpoint(dentry);\n\tif (!mp)\n\t\tgoto out_unlock;\n\n\tlock_mount_hash();\n\twhile (!hlist_empty(&mp->m_list)) {\n\t\tmnt = hlist_entry(mp->m_list.first, struct mount, mnt_mp_list);\n\t\tif (mnt->mnt.mnt_flags & MNT_UMOUNT) {\n\t\t\tstruct mount *p, *tmp;\n\t\t\tlist_for_each_entry_safe(p, tmp, &mnt->mnt_mounts,  mnt_child) {\n\t\t\t\thlist_add_head(&p->mnt_umount.s_list, &unmounted);\n\t\t\t\tumount_mnt(p);\n\t\t\t}\n\t\t}\n\t\telse umount_tree(mnt, 0);\n\t}\n\tunlock_mount_hash();\n\tput_mountpoint(mp);\nout_unlock:\n\tnamespace_unlock();\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -11,7 +11,14 @@\n \tlock_mount_hash();\n \twhile (!hlist_empty(&mp->m_list)) {\n \t\tmnt = hlist_entry(mp->m_list.first, struct mount, mnt_mp_list);\n-\t\tumount_tree(mnt, 0);\n+\t\tif (mnt->mnt.mnt_flags & MNT_UMOUNT) {\n+\t\t\tstruct mount *p, *tmp;\n+\t\t\tlist_for_each_entry_safe(p, tmp, &mnt->mnt_mounts,  mnt_child) {\n+\t\t\t\thlist_add_head(&p->mnt_umount.s_list, &unmounted);\n+\t\t\t\tumount_mnt(p);\n+\t\t\t}\n+\t\t}\n+\t\telse umount_tree(mnt, 0);\n \t}\n \tunlock_mount_hash();\n \tput_mountpoint(mp);",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tumount_tree(mnt, 0);"
            ],
            "added_lines": [
                "\t\tif (mnt->mnt.mnt_flags & MNT_UMOUNT) {",
                "\t\t\tstruct mount *p, *tmp;",
                "\t\t\tlist_for_each_entry_safe(p, tmp, &mnt->mnt_mounts,  mnt_child) {",
                "\t\t\t\thlist_add_head(&p->mnt_umount.s_list, &unmounted);",
                "\t\t\t\tumount_mnt(p);",
                "\t\t\t}",
                "\t\t}",
                "\t\telse umount_tree(mnt, 0);"
            ]
        }
    },
    {
        "cve_id": "CVE-2014-9717",
        "func_name": "torvalds/linux/umount_tree",
        "description": "fs/namespace.c in the Linux kernel before 4.0.2 processes MNT_DETACH umount2 system calls without verifying that the MNT_LOCKED flag is unset, which allows local users to bypass intended access restrictions and navigate to filesystem locations beneath a mount by calling umount2 within a user namespace.",
        "git_url": "https://github.com/torvalds/linux/commit/ce07d891a0891d3c0d0c2d73d577490486b809e1",
        "commit_title": "mnt: Honor MNT_LOCKED when detaching mounts",
        "commit_text": " Modify umount(MNT_DETACH) to keep mounts in the hash table that are locked to their parent mounts, when the parent is lazily unmounted.  In mntput_no_expire detach the children from the hash table, depending on mnt_pin_kill in cleanup_mnt to decrement the mnt_count of the children.  In __detach_mounts if there are any mounts that have been unmounted but still are on the list of mounts of a mountpoint, remove their children from the mount hash table and those children to the unmounted list so they won't linger potentially indefinitely waiting for their final mntput, now that the mounts serve no purpose.  Cc: stable@vger.kernel.org",
        "func_before": "static void umount_tree(struct mount *mnt, enum umount_tree_flags how)\n{\n\tLIST_HEAD(tmp_list);\n\tstruct mount *p;\n\n\tif (how & UMOUNT_PROPAGATE)\n\t\tpropagate_mount_unlock(mnt);\n\n\t/* Gather the mounts to umount */\n\tfor (p = mnt; p; p = next_mnt(p, mnt)) {\n\t\tp->mnt.mnt_flags |= MNT_UMOUNT;\n\t\tlist_move(&p->mnt_list, &tmp_list);\n\t}\n\n\t/* Hide the mounts from mnt_mounts */\n\tlist_for_each_entry(p, &tmp_list, mnt_list) {\n\t\tlist_del_init(&p->mnt_child);\n\t}\n\n\t/* Add propogated mounts to the tmp_list */\n\tif (how & UMOUNT_PROPAGATE)\n\t\tpropagate_umount(&tmp_list);\n\n\twhile (!list_empty(&tmp_list)) {\n\t\tp = list_first_entry(&tmp_list, struct mount, mnt_list);\n\t\tlist_del_init(&p->mnt_expire);\n\t\tlist_del_init(&p->mnt_list);\n\t\t__touch_mnt_namespace(p->mnt_ns);\n\t\tp->mnt_ns = NULL;\n\t\tif (how & UMOUNT_SYNC)\n\t\t\tp->mnt.mnt_flags |= MNT_SYNC_UMOUNT;\n\n\t\tpin_insert_group(&p->mnt_umount, &p->mnt_parent->mnt, &unmounted);\n\t\tif (mnt_has_parent(p)) {\n\t\t\tmnt_add_count(p->mnt_parent, -1);\n\t\t\tumount_mnt(p);\n\t\t}\n\t\tchange_mnt_propagation(p, MS_PRIVATE);\n\t}\n}",
        "func": "static void umount_tree(struct mount *mnt, enum umount_tree_flags how)\n{\n\tLIST_HEAD(tmp_list);\n\tstruct mount *p;\n\n\tif (how & UMOUNT_PROPAGATE)\n\t\tpropagate_mount_unlock(mnt);\n\n\t/* Gather the mounts to umount */\n\tfor (p = mnt; p; p = next_mnt(p, mnt)) {\n\t\tp->mnt.mnt_flags |= MNT_UMOUNT;\n\t\tlist_move(&p->mnt_list, &tmp_list);\n\t}\n\n\t/* Hide the mounts from mnt_mounts */\n\tlist_for_each_entry(p, &tmp_list, mnt_list) {\n\t\tlist_del_init(&p->mnt_child);\n\t}\n\n\t/* Add propogated mounts to the tmp_list */\n\tif (how & UMOUNT_PROPAGATE)\n\t\tpropagate_umount(&tmp_list);\n\n\twhile (!list_empty(&tmp_list)) {\n\t\tbool disconnect;\n\t\tp = list_first_entry(&tmp_list, struct mount, mnt_list);\n\t\tlist_del_init(&p->mnt_expire);\n\t\tlist_del_init(&p->mnt_list);\n\t\t__touch_mnt_namespace(p->mnt_ns);\n\t\tp->mnt_ns = NULL;\n\t\tif (how & UMOUNT_SYNC)\n\t\t\tp->mnt.mnt_flags |= MNT_SYNC_UMOUNT;\n\n\t\tdisconnect = !IS_MNT_LOCKED_AND_LAZY(p);\n\n\t\tpin_insert_group(&p->mnt_umount, &p->mnt_parent->mnt,\n\t\t\t\t disconnect ? &unmounted : NULL);\n\t\tif (mnt_has_parent(p)) {\n\t\t\tmnt_add_count(p->mnt_parent, -1);\n\t\t\tif (!disconnect) {\n\t\t\t\t/* Don't forget about p */\n\t\t\t\tlist_add_tail(&p->mnt_child, &p->mnt_parent->mnt_mounts);\n\t\t\t} else {\n\t\t\t\tumount_mnt(p);\n\t\t\t}\n\t\t}\n\t\tchange_mnt_propagation(p, MS_PRIVATE);\n\t}\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -22,6 +22,7 @@\n \t\tpropagate_umount(&tmp_list);\n \n \twhile (!list_empty(&tmp_list)) {\n+\t\tbool disconnect;\n \t\tp = list_first_entry(&tmp_list, struct mount, mnt_list);\n \t\tlist_del_init(&p->mnt_expire);\n \t\tlist_del_init(&p->mnt_list);\n@@ -30,10 +31,18 @@\n \t\tif (how & UMOUNT_SYNC)\n \t\t\tp->mnt.mnt_flags |= MNT_SYNC_UMOUNT;\n \n-\t\tpin_insert_group(&p->mnt_umount, &p->mnt_parent->mnt, &unmounted);\n+\t\tdisconnect = !IS_MNT_LOCKED_AND_LAZY(p);\n+\n+\t\tpin_insert_group(&p->mnt_umount, &p->mnt_parent->mnt,\n+\t\t\t\t disconnect ? &unmounted : NULL);\n \t\tif (mnt_has_parent(p)) {\n \t\t\tmnt_add_count(p->mnt_parent, -1);\n-\t\t\tumount_mnt(p);\n+\t\t\tif (!disconnect) {\n+\t\t\t\t/* Don't forget about p */\n+\t\t\t\tlist_add_tail(&p->mnt_child, &p->mnt_parent->mnt_mounts);\n+\t\t\t} else {\n+\t\t\t\tumount_mnt(p);\n+\t\t\t}\n \t\t}\n \t\tchange_mnt_propagation(p, MS_PRIVATE);\n \t}",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tpin_insert_group(&p->mnt_umount, &p->mnt_parent->mnt, &unmounted);",
                "\t\t\tumount_mnt(p);"
            ],
            "added_lines": [
                "\t\tbool disconnect;",
                "\t\tdisconnect = !IS_MNT_LOCKED_AND_LAZY(p);",
                "",
                "\t\tpin_insert_group(&p->mnt_umount, &p->mnt_parent->mnt,",
                "\t\t\t\t disconnect ? &unmounted : NULL);",
                "\t\t\tif (!disconnect) {",
                "\t\t\t\t/* Don't forget about p */",
                "\t\t\t\tlist_add_tail(&p->mnt_child, &p->mnt_parent->mnt_mounts);",
                "\t\t\t} else {",
                "\t\t\t\tumount_mnt(p);",
                "\t\t\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2014-9717",
        "func_name": "torvalds/linux/mntput_no_expire",
        "description": "fs/namespace.c in the Linux kernel before 4.0.2 processes MNT_DETACH umount2 system calls without verifying that the MNT_LOCKED flag is unset, which allows local users to bypass intended access restrictions and navigate to filesystem locations beneath a mount by calling umount2 within a user namespace.",
        "git_url": "https://github.com/torvalds/linux/commit/ce07d891a0891d3c0d0c2d73d577490486b809e1",
        "commit_title": "mnt: Honor MNT_LOCKED when detaching mounts",
        "commit_text": " Modify umount(MNT_DETACH) to keep mounts in the hash table that are locked to their parent mounts, when the parent is lazily unmounted.  In mntput_no_expire detach the children from the hash table, depending on mnt_pin_kill in cleanup_mnt to decrement the mnt_count of the children.  In __detach_mounts if there are any mounts that have been unmounted but still are on the list of mounts of a mountpoint, remove their children from the mount hash table and those children to the unmounted list so they won't linger potentially indefinitely waiting for their final mntput, now that the mounts serve no purpose.  Cc: stable@vger.kernel.org",
        "func_before": "static void mntput_no_expire(struct mount *mnt)\n{\n\trcu_read_lock();\n\tmnt_add_count(mnt, -1);\n\tif (likely(mnt->mnt_ns)) { /* shouldn't be the last one */\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\tlock_mount_hash();\n\tif (mnt_get_count(mnt)) {\n\t\trcu_read_unlock();\n\t\tunlock_mount_hash();\n\t\treturn;\n\t}\n\tif (unlikely(mnt->mnt.mnt_flags & MNT_DOOMED)) {\n\t\trcu_read_unlock();\n\t\tunlock_mount_hash();\n\t\treturn;\n\t}\n\tmnt->mnt.mnt_flags |= MNT_DOOMED;\n\trcu_read_unlock();\n\n\tlist_del(&mnt->mnt_instance);\n\tunlock_mount_hash();\n\n\tif (likely(!(mnt->mnt.mnt_flags & MNT_INTERNAL))) {\n\t\tstruct task_struct *task = current;\n\t\tif (likely(!(task->flags & PF_KTHREAD))) {\n\t\t\tinit_task_work(&mnt->mnt_rcu, __cleanup_mnt);\n\t\t\tif (!task_work_add(task, &mnt->mnt_rcu, true))\n\t\t\t\treturn;\n\t\t}\n\t\tif (llist_add(&mnt->mnt_llist, &delayed_mntput_list))\n\t\t\tschedule_delayed_work(&delayed_mntput_work, 1);\n\t\treturn;\n\t}\n\tcleanup_mnt(mnt);\n}",
        "func": "static void mntput_no_expire(struct mount *mnt)\n{\n\trcu_read_lock();\n\tmnt_add_count(mnt, -1);\n\tif (likely(mnt->mnt_ns)) { /* shouldn't be the last one */\n\t\trcu_read_unlock();\n\t\treturn;\n\t}\n\tlock_mount_hash();\n\tif (mnt_get_count(mnt)) {\n\t\trcu_read_unlock();\n\t\tunlock_mount_hash();\n\t\treturn;\n\t}\n\tif (unlikely(mnt->mnt.mnt_flags & MNT_DOOMED)) {\n\t\trcu_read_unlock();\n\t\tunlock_mount_hash();\n\t\treturn;\n\t}\n\tmnt->mnt.mnt_flags |= MNT_DOOMED;\n\trcu_read_unlock();\n\n\tlist_del(&mnt->mnt_instance);\n\n\tif (unlikely(!list_empty(&mnt->mnt_mounts))) {\n\t\tstruct mount *p, *tmp;\n\t\tlist_for_each_entry_safe(p, tmp, &mnt->mnt_mounts,  mnt_child) {\n\t\t\tumount_mnt(p);\n\t\t}\n\t}\n\tunlock_mount_hash();\n\n\tif (likely(!(mnt->mnt.mnt_flags & MNT_INTERNAL))) {\n\t\tstruct task_struct *task = current;\n\t\tif (likely(!(task->flags & PF_KTHREAD))) {\n\t\t\tinit_task_work(&mnt->mnt_rcu, __cleanup_mnt);\n\t\t\tif (!task_work_add(task, &mnt->mnt_rcu, true))\n\t\t\t\treturn;\n\t\t}\n\t\tif (llist_add(&mnt->mnt_llist, &delayed_mntput_list))\n\t\t\tschedule_delayed_work(&delayed_mntput_work, 1);\n\t\treturn;\n\t}\n\tcleanup_mnt(mnt);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -21,6 +21,13 @@\n \trcu_read_unlock();\n \n \tlist_del(&mnt->mnt_instance);\n+\n+\tif (unlikely(!list_empty(&mnt->mnt_mounts))) {\n+\t\tstruct mount *p, *tmp;\n+\t\tlist_for_each_entry_safe(p, tmp, &mnt->mnt_mounts,  mnt_child) {\n+\t\t\tumount_mnt(p);\n+\t\t}\n+\t}\n \tunlock_mount_hash();\n \n \tif (likely(!(mnt->mnt.mnt_flags & MNT_INTERNAL))) {",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "\tif (unlikely(!list_empty(&mnt->mnt_mounts))) {",
                "\t\tstruct mount *p, *tmp;",
                "\t\tlist_for_each_entry_safe(p, tmp, &mnt->mnt_mounts,  mnt_child) {",
                "\t\t\tumount_mnt(p);",
                "\t\t}",
                "\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-1667",
        "func_name": "chromium/TreeScope::adoptIfNeeded",
        "description": "The TreeScope::adoptIfNeeded function in WebKit/Source/core/dom/TreeScope.cpp in the DOM implementation in Blink, as used in Google Chrome before 50.0.2661.102, does not prevent script execution during node-adoption operations, which allows remote attackers to bypass the Same Origin Policy via a crafted web site.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/73dd06077821b2beba42165c484913601d9e8643",
        "commit_title": "Don't allow scripts to run when a node is being adopted.",
        "commit_text": " Running a script in the middle of rescoping nodes can break a lot of invariants and leave DOM in an inconsistent state.  This patch adds a ScriptForbiddenScope in TreeScope::adoptIfNeeded to ensure it never happens.    (cherry picked from commit 146ff1bb11c88778d466bd7a49b544f2b5806ee0)  TBR=dominicc@chromium.org,esprehn@chromium.org   ",
        "func_before": "void TreeScope::adoptIfNeeded(Node& node)\n{\n    ASSERT(this);\n    ASSERT(!node.isDocumentNode());\n#if !ENABLE(OILPAN)\n    ASSERT_WITH_SECURITY_IMPLICATION(!node.m_deletionHasBegun);\n#endif\n    TreeScopeAdopter adopter(node, *this);\n    if (adopter.needsScopeChange())\n        adopter.execute();\n}",
        "func": "void TreeScope::adoptIfNeeded(Node& node)\n{\n    ASSERT(this);\n    ASSERT(!node.isDocumentNode());\n#if !ENABLE(OILPAN)\n    ASSERT_WITH_SECURITY_IMPLICATION(!node.m_deletionHasBegun);\n#endif\n    TreeScopeAdopter adopter(node, *this);\n    if (adopter.needsScopeChange()) {\n        ScriptForbiddenScope forbidScript;\n        adopter.execute();\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,6 +6,8 @@\n     ASSERT_WITH_SECURITY_IMPLICATION(!node.m_deletionHasBegun);\n #endif\n     TreeScopeAdopter adopter(node, *this);\n-    if (adopter.needsScopeChange())\n+    if (adopter.needsScopeChange()) {\n+        ScriptForbiddenScope forbidScript;\n         adopter.execute();\n+    }\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    if (adopter.needsScopeChange())"
            ],
            "added_lines": [
                "    if (adopter.needsScopeChange()) {",
                "        ScriptForbiddenScope forbidScript;",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-1668",
        "func_name": "chromium/forEachForBinding",
        "description": "The forEachForBinding function in WebKit/Source/bindings/core/v8/Iterable.h in the V8 bindings in Blink, as used in Google Chrome before 50.0.2661.102, uses an improper creation context, which allows remote attackers to bypass the Same Origin Policy via a crafted web site.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/cfb182b8d5cdc104ba1e9c09125c918b00e850bb",
        "commit_title": "Use correct creation context during Iterable.forEach iteration",
        "commit_text": " Use |thisValue| instead of |scriptState->context()->Global()|, since this is simpler and since Global() actually returns a WindowProxy object that may change and become incorrect to use as creation context depending on what the callback function does.    (cherry picked from commit 0cd7a9f853e3cb7c035b4ab9e07a503552267f9d)   ",
        "func_before": "void forEachForBinding(ScriptState* scriptState, const ScriptValue& thisValue, const ScriptValue& callback, const ScriptValue& thisArg, ExceptionState& exceptionState)\n    {\n        IterationSource* source = this->startIteration(scriptState, exceptionState);\n\n        v8::Isolate* isolate = scriptState->isolate();\n        v8::TryCatch tryCatch(isolate);\n\n        v8::Local<v8::Object> creationContext(scriptState->context()->Global());\n        v8::Local<v8::Function> v8Callback(callback.v8Value().As<v8::Function>());\n        v8::Local<v8::Value> v8ThisArg(thisArg.v8Value());\n        v8::Local<v8::Value> args[3];\n\n        args[2] = thisValue.v8Value();\n\n        while (true) {\n            KeyType key;\n            ValueType value;\n\n            if (!source->next(scriptState, key, value, exceptionState))\n                return;\n\n            ASSERT(!exceptionState.hadException());\n\n            args[0] = toV8(value, creationContext, isolate);\n            args[1] = toV8(key, creationContext, isolate);\n            if (args[0].IsEmpty() || args[1].IsEmpty()) {\n                if (tryCatch.HasCaught())\n                    exceptionState.rethrowV8Exception(tryCatch.Exception());\n                return;\n            }\n\n            v8::Local<v8::Value> result;\n            if (!V8ScriptRunner::callFunction(v8Callback, scriptState->executionContext(), v8ThisArg, 3, args, isolate).ToLocal(&result)) {\n                exceptionState.rethrowV8Exception(tryCatch.Exception());\n                return;\n            }\n        }\n    }",
        "func": "void forEachForBinding(ScriptState* scriptState, const ScriptValue& thisValue, const ScriptValue& callback, const ScriptValue& thisArg, ExceptionState& exceptionState)\n    {\n        IterationSource* source = this->startIteration(scriptState, exceptionState);\n\n        v8::Isolate* isolate = scriptState->isolate();\n        v8::TryCatch tryCatch(isolate);\n\n        v8::Local<v8::Object> creationContext(thisValue.v8Value().As<v8::Object>());\n        v8::Local<v8::Function> v8Callback(callback.v8Value().As<v8::Function>());\n        v8::Local<v8::Value> v8ThisArg(thisArg.v8Value());\n        v8::Local<v8::Value> args[3];\n\n        args[2] = thisValue.v8Value();\n\n        while (true) {\n            KeyType key;\n            ValueType value;\n\n            if (!source->next(scriptState, key, value, exceptionState))\n                return;\n\n            ASSERT(!exceptionState.hadException());\n\n            args[0] = toV8(value, creationContext, isolate);\n            args[1] = toV8(key, creationContext, isolate);\n            if (args[0].IsEmpty() || args[1].IsEmpty()) {\n                if (tryCatch.HasCaught())\n                    exceptionState.rethrowV8Exception(tryCatch.Exception());\n                return;\n            }\n\n            v8::Local<v8::Value> result;\n            if (!V8ScriptRunner::callFunction(v8Callback, scriptState->executionContext(), v8ThisArg, 3, args, isolate).ToLocal(&result)) {\n                exceptionState.rethrowV8Exception(tryCatch.Exception());\n                return;\n            }\n        }\n    }",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,7 +5,7 @@\n         v8::Isolate* isolate = scriptState->isolate();\n         v8::TryCatch tryCatch(isolate);\n \n-        v8::Local<v8::Object> creationContext(scriptState->context()->Global());\n+        v8::Local<v8::Object> creationContext(thisValue.v8Value().As<v8::Object>());\n         v8::Local<v8::Function> v8Callback(callback.v8Value().As<v8::Function>());\n         v8::Local<v8::Value> v8ThisArg(thisArg.v8Value());\n         v8::Local<v8::Value> args[3];",
        "diff_line_info": {
            "deleted_lines": [
                "        v8::Local<v8::Object> creationContext(scriptState->context()->Global());"
            ],
            "added_lines": [
                "        v8::Local<v8::Object> creationContext(thisValue.v8Value().As<v8::Object>());"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-8838",
        "func_name": "php/php-src/mysqlnd_switch_to_ssl_if_needed",
        "description": "ext/mysqlnd/mysqlnd.c in PHP before 5.4.43, 5.5.x before 5.5.27, and 5.6.x before 5.6.11 uses a client SSL option to mean that SSL is optional, which allows man-in-the-middle attackers to spoof servers via a cleartext-downgrade attack, a related issue to CVE-2015-3152.",
        "git_url": "https://github.com/php/php-src/commit/97aa752fee61fccdec361279adbfb17a3c60f3f4",
        "commit_title": "Fix bug #69669 (mysqlnd is vulnerable to BACKRONYM)",
        "commit_text": "",
        "func_before": "static enum_func_status\nmysqlnd_switch_to_ssl_if_needed(\n\t\t\tMYSQLND_CONN_DATA * conn,\n\t\t\tconst MYSQLND_PACKET_GREET * const greet_packet,\n\t\t\tconst MYSQLND_OPTIONS * const options,\n\t\t\tunsigned long mysql_flags\n\t\t\tTSRMLS_DC\n\t\t)\n{\n\tenum_func_status ret = FAIL;\n\tconst MYSQLND_CHARSET * charset;\n\tMYSQLND_PACKET_AUTH * auth_packet;\n\tDBG_ENTER(\"mysqlnd_switch_to_ssl_if_needed\");\n\n\tauth_packet = conn->protocol->m.get_auth_packet(conn->protocol, FALSE TSRMLS_CC);\n\tif (!auth_packet) {\n\t\tSET_OOM_ERROR(*conn->error_info);\n\t\tgoto end;\n\t}\n\tauth_packet->client_flags = mysql_flags;\n\tauth_packet->max_packet_size = MYSQLND_ASSEMBLED_PACKET_MAX_SIZE;\n\n\tif (options->charset_name && (charset = mysqlnd_find_charset_name(options->charset_name))) {\n\t\tauth_packet->charset_no\t= charset->nr;\n\t} else {\n#if MYSQLND_UNICODE\n\t\tauth_packet->charset_no\t= 200;/* utf8 - swedish collation, check mysqlnd_charset.c */\n#else\n\t\tauth_packet->charset_no\t= greet_packet->charset_no;\n#endif\n\t}\n\n#ifdef MYSQLND_SSL_SUPPORTED\n\tif ((greet_packet->server_capabilities & CLIENT_SSL) && (mysql_flags & CLIENT_SSL)) {\n\t\tzend_bool verify = mysql_flags & CLIENT_SSL_VERIFY_SERVER_CERT? TRUE:FALSE;\n\t\tDBG_INF(\"Switching to SSL\");\n\t\tif (!PACKET_WRITE(auth_packet, conn)) {\n\t\t\tCONN_SET_STATE(conn, CONN_QUIT_SENT);\n\t\t\tSET_CLIENT_ERROR(*conn->error_info, CR_SERVER_GONE_ERROR, UNKNOWN_SQLSTATE, mysqlnd_server_gone);\n\t\t\tgoto end;\n\t\t}\n\n\t\tconn->net->m.set_client_option(conn->net, MYSQL_OPT_SSL_VERIFY_SERVER_CERT, (const char *) &verify TSRMLS_CC);\n\n\t\tif (FAIL == conn->net->m.enable_ssl(conn->net TSRMLS_CC)) {\n\t\t\tgoto end;\n\t\t}\n\t}\n#endif\n\tret = PASS;\nend:\n\tPACKET_FREE(auth_packet);\n\tDBG_RETURN(ret);\n}",
        "func": "static enum_func_status\nmysqlnd_switch_to_ssl_if_needed(\n\t\t\tMYSQLND_CONN_DATA * conn,\n\t\t\tconst MYSQLND_PACKET_GREET * const greet_packet,\n\t\t\tconst MYSQLND_OPTIONS * const options,\n\t\t\tunsigned long mysql_flags\n\t\t\tTSRMLS_DC\n\t\t)\n{\n\tenum_func_status ret = FAIL;\n\tconst MYSQLND_CHARSET * charset;\n\tMYSQLND_PACKET_AUTH * auth_packet;\n\tDBG_ENTER(\"mysqlnd_switch_to_ssl_if_needed\");\n\n\tauth_packet = conn->protocol->m.get_auth_packet(conn->protocol, FALSE TSRMLS_CC);\n\tif (!auth_packet) {\n\t\tSET_OOM_ERROR(*conn->error_info);\n\t\tgoto end;\n\t}\n\tauth_packet->client_flags = mysql_flags;\n\tauth_packet->max_packet_size = MYSQLND_ASSEMBLED_PACKET_MAX_SIZE;\n\n\tif (options->charset_name && (charset = mysqlnd_find_charset_name(options->charset_name))) {\n\t\tauth_packet->charset_no\t= charset->nr;\n\t} else {\n#if MYSQLND_UNICODE\n\t\tauth_packet->charset_no\t= 200;/* utf8 - swedish collation, check mysqlnd_charset.c */\n#else\n\t\tauth_packet->charset_no\t= greet_packet->charset_no;\n#endif\n\t}\n\n#ifdef MYSQLND_SSL_SUPPORTED\n\tif (mysql_flags & CLIENT_SSL) {\n\t\tzend_bool server_has_ssl = (greet_packet->server_capabilities & CLIENT_SSL)? TRUE:FALSE;\n\t\tif (server_has_ssl == FALSE) {\n\t\t\tgoto close_conn;\n\t\t} else {\n\t\t\tzend_bool verify = mysql_flags & CLIENT_SSL_VERIFY_SERVER_CERT? TRUE:FALSE;\n\t\t\tDBG_INF(\"Switching to SSL\");\n\t\t\tif (!PACKET_WRITE(auth_packet, conn)) {\n\t\t\t\tgoto close_conn;\n\t\t\t}\n\n\t\t\tconn->net->m.set_client_option(conn->net, MYSQL_OPT_SSL_VERIFY_SERVER_CERT, (const char *) &verify TSRMLS_CC);\n\n\t\t\tif (FAIL == conn->net->m.enable_ssl(conn->net TSRMLS_CC)) {\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t}\n\t}\n#else\n\tauth_packet->client_flags &= ~CLIENT_SSL;\n\tif (!PACKET_WRITE(auth_packet, conn)) {\n\t\tgoto close_conn;\n\t}\n#endif\n\tret = PASS;\nend:\n\tPACKET_FREE(auth_packet);\n\tDBG_RETURN(ret);\n\nclose_conn:\n\tCONN_SET_STATE(conn, CONN_QUIT_SENT);\n\tconn->m->send_close(conn TSRMLS_CC);\n\tSET_CLIENT_ERROR(*conn->error_info, CR_SERVER_GONE_ERROR, UNKNOWN_SQLSTATE, mysqlnd_server_gone);\n\tPACKET_FREE(auth_packet);\n\tDBG_RETURN(ret);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -31,24 +31,39 @@\n \t}\n \n #ifdef MYSQLND_SSL_SUPPORTED\n-\tif ((greet_packet->server_capabilities & CLIENT_SSL) && (mysql_flags & CLIENT_SSL)) {\n-\t\tzend_bool verify = mysql_flags & CLIENT_SSL_VERIFY_SERVER_CERT? TRUE:FALSE;\n-\t\tDBG_INF(\"Switching to SSL\");\n-\t\tif (!PACKET_WRITE(auth_packet, conn)) {\n-\t\t\tCONN_SET_STATE(conn, CONN_QUIT_SENT);\n-\t\t\tSET_CLIENT_ERROR(*conn->error_info, CR_SERVER_GONE_ERROR, UNKNOWN_SQLSTATE, mysqlnd_server_gone);\n-\t\t\tgoto end;\n+\tif (mysql_flags & CLIENT_SSL) {\n+\t\tzend_bool server_has_ssl = (greet_packet->server_capabilities & CLIENT_SSL)? TRUE:FALSE;\n+\t\tif (server_has_ssl == FALSE) {\n+\t\t\tgoto close_conn;\n+\t\t} else {\n+\t\t\tzend_bool verify = mysql_flags & CLIENT_SSL_VERIFY_SERVER_CERT? TRUE:FALSE;\n+\t\t\tDBG_INF(\"Switching to SSL\");\n+\t\t\tif (!PACKET_WRITE(auth_packet, conn)) {\n+\t\t\t\tgoto close_conn;\n+\t\t\t}\n+\n+\t\t\tconn->net->m.set_client_option(conn->net, MYSQL_OPT_SSL_VERIFY_SERVER_CERT, (const char *) &verify TSRMLS_CC);\n+\n+\t\t\tif (FAIL == conn->net->m.enable_ssl(conn->net TSRMLS_CC)) {\n+\t\t\t\tgoto end;\n+\t\t\t}\n \t\t}\n-\n-\t\tconn->net->m.set_client_option(conn->net, MYSQL_OPT_SSL_VERIFY_SERVER_CERT, (const char *) &verify TSRMLS_CC);\n-\n-\t\tif (FAIL == conn->net->m.enable_ssl(conn->net TSRMLS_CC)) {\n-\t\t\tgoto end;\n-\t\t}\n+\t}\n+#else\n+\tauth_packet->client_flags &= ~CLIENT_SSL;\n+\tif (!PACKET_WRITE(auth_packet, conn)) {\n+\t\tgoto close_conn;\n \t}\n #endif\n \tret = PASS;\n end:\n \tPACKET_FREE(auth_packet);\n \tDBG_RETURN(ret);\n+\n+close_conn:\n+\tCONN_SET_STATE(conn, CONN_QUIT_SENT);\n+\tconn->m->send_close(conn TSRMLS_CC);\n+\tSET_CLIENT_ERROR(*conn->error_info, CR_SERVER_GONE_ERROR, UNKNOWN_SQLSTATE, mysqlnd_server_gone);\n+\tPACKET_FREE(auth_packet);\n+\tDBG_RETURN(ret);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tif ((greet_packet->server_capabilities & CLIENT_SSL) && (mysql_flags & CLIENT_SSL)) {",
                "\t\tzend_bool verify = mysql_flags & CLIENT_SSL_VERIFY_SERVER_CERT? TRUE:FALSE;",
                "\t\tDBG_INF(\"Switching to SSL\");",
                "\t\tif (!PACKET_WRITE(auth_packet, conn)) {",
                "\t\t\tCONN_SET_STATE(conn, CONN_QUIT_SENT);",
                "\t\t\tSET_CLIENT_ERROR(*conn->error_info, CR_SERVER_GONE_ERROR, UNKNOWN_SQLSTATE, mysqlnd_server_gone);",
                "\t\t\tgoto end;",
                "",
                "\t\tconn->net->m.set_client_option(conn->net, MYSQL_OPT_SSL_VERIFY_SERVER_CERT, (const char *) &verify TSRMLS_CC);",
                "",
                "\t\tif (FAIL == conn->net->m.enable_ssl(conn->net TSRMLS_CC)) {",
                "\t\t\tgoto end;",
                "\t\t}"
            ],
            "added_lines": [
                "\tif (mysql_flags & CLIENT_SSL) {",
                "\t\tzend_bool server_has_ssl = (greet_packet->server_capabilities & CLIENT_SSL)? TRUE:FALSE;",
                "\t\tif (server_has_ssl == FALSE) {",
                "\t\t\tgoto close_conn;",
                "\t\t} else {",
                "\t\t\tzend_bool verify = mysql_flags & CLIENT_SSL_VERIFY_SERVER_CERT? TRUE:FALSE;",
                "\t\t\tDBG_INF(\"Switching to SSL\");",
                "\t\t\tif (!PACKET_WRITE(auth_packet, conn)) {",
                "\t\t\t\tgoto close_conn;",
                "\t\t\t}",
                "",
                "\t\t\tconn->net->m.set_client_option(conn->net, MYSQL_OPT_SSL_VERIFY_SERVER_CERT, (const char *) &verify TSRMLS_CC);",
                "",
                "\t\t\tif (FAIL == conn->net->m.enable_ssl(conn->net TSRMLS_CC)) {",
                "\t\t\t\tgoto end;",
                "\t\t\t}",
                "\t}",
                "#else",
                "\tauth_packet->client_flags &= ~CLIENT_SSL;",
                "\tif (!PACKET_WRITE(auth_packet, conn)) {",
                "\t\tgoto close_conn;",
                "",
                "close_conn:",
                "\tCONN_SET_STATE(conn, CONN_QUIT_SENT);",
                "\tconn->m->send_close(conn TSRMLS_CC);",
                "\tSET_CLIENT_ERROR(*conn->error_info, CR_SERVER_GONE_ERROR, UNKNOWN_SQLSTATE, mysqlnd_server_gone);",
                "\tPACKET_FREE(auth_packet);",
                "\tDBG_RETURN(ret);"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-8838",
        "func_name": "php/php-src/mysqlnd_old_escape_string",
        "description": "ext/mysqlnd/mysqlnd.c in PHP before 5.4.43, 5.5.x before 5.5.27, and 5.6.x before 5.6.11 uses a client SSL option to mean that SSL is optional, which allows man-in-the-middle attackers to spoof servers via a cleartext-downgrade attack, a related issue to CVE-2015-3152.",
        "git_url": "https://github.com/php/php-src/commit/97aa752fee61fccdec361279adbfb17a3c60f3f4",
        "commit_title": "Fix bug #69669 (mysqlnd is vulnerable to BACKRONYM)",
        "commit_text": "",
        "func_before": "PHPAPI ulong \nmysqlnd_old_escape_string(char * newstr, const char * escapestr, size_t escapestr_len TSRMLS_DC)\n{\n\tDBG_ENTER(\"mysqlnd_old_escape_string\");\n\tDBG_RETURN(mysqlnd_cset_escape_slashes(mysqlnd_find_charset_name(\"latin1\"), newstr, escapestr, escapestr_len TSRMLS_CC));\n}",
        "func": "PHPAPI ulong\nmysqlnd_old_escape_string(char * newstr, const char * escapestr, size_t escapestr_len TSRMLS_DC)\n{\n\tDBG_ENTER(\"mysqlnd_old_escape_string\");\n\tDBG_RETURN(mysqlnd_cset_escape_slashes(mysqlnd_find_charset_name(\"latin1\"), newstr, escapestr, escapestr_len TSRMLS_CC));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,4 @@\n-PHPAPI ulong \n+PHPAPI ulong\n mysqlnd_old_escape_string(char * newstr, const char * escapestr, size_t escapestr_len TSRMLS_DC)\n {\n \tDBG_ENTER(\"mysqlnd_old_escape_string\");",
        "diff_line_info": {
            "deleted_lines": [
                "PHPAPI ulong "
            ],
            "added_lines": [
                "PHPAPI ulong"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-8838",
        "func_name": "php/php-src/mysqlnd_connect_run_authentication",
        "description": "ext/mysqlnd/mysqlnd.c in PHP before 5.4.43, 5.5.x before 5.5.27, and 5.6.x before 5.6.11 uses a client SSL option to mean that SSL is optional, which allows man-in-the-middle attackers to spoof servers via a cleartext-downgrade attack, a related issue to CVE-2015-3152.",
        "git_url": "https://github.com/php/php-src/commit/97aa752fee61fccdec361279adbfb17a3c60f3f4",
        "commit_title": "Fix bug #69669 (mysqlnd is vulnerable to BACKRONYM)",
        "commit_text": "",
        "func_before": "static enum_func_status\nmysqlnd_connect_run_authentication(\n\t\t\tMYSQLND_CONN_DATA * conn,\n\t\t\tconst char * const user,\n\t\t\tconst char * const passwd,\n\t\t\tconst char * const db,\n\t\t\tsize_t db_len,\n\t\t\tsize_t passwd_len,\n\t\t\tconst MYSQLND_PACKET_GREET * const greet_packet,\n\t\t\tconst MYSQLND_OPTIONS * const options,\n\t\t\tunsigned long mysql_flags\n\t\t\tTSRMLS_DC)\n{\n\tenum_func_status ret = FAIL;\n\tDBG_ENTER(\"mysqlnd_connect_run_authentication\");\n\n\tret = mysqlnd_switch_to_ssl_if_needed(conn, greet_packet, options, mysql_flags TSRMLS_CC);\n\tif (PASS == ret) {\n\t\tzend_bool first_call = TRUE;\n\n\t\tchar * switch_to_auth_protocol = NULL;\n\t\tsize_t switch_to_auth_protocol_len = 0;\n\t\tchar * requested_protocol = NULL;\n\t\tzend_uchar * plugin_data;\n\t\tsize_t plugin_data_len;\n\n\t\tplugin_data_len = greet_packet->auth_plugin_data_len;\n\t\tplugin_data = mnd_emalloc(plugin_data_len + 1);\n\t\tif (!plugin_data) {\n\t\t\tret = FAIL;\n\t\t\tgoto end;\n\t\t}\n\t\tmemcpy(plugin_data, greet_packet->auth_plugin_data, plugin_data_len);\n\t\tplugin_data[plugin_data_len] = '\\0';\n\n\t\trequested_protocol = mnd_pestrdup(greet_packet->auth_protocol? greet_packet->auth_protocol: \"mysql_native_password\", FALSE);\n\t\tif (!requested_protocol) {\n\t\t\tret = FAIL;\n\t\t\tgoto end;\n\t\t}\n\n\t\tdo {\n\t\t\tstruct st_mysqlnd_authentication_plugin * auth_plugin;\n\t\t\t{\n\t\t\t\tchar * plugin_name = NULL;\n\n\t\t\t\tmnd_sprintf(&plugin_name, 0, \"auth_plugin_%s\", requested_protocol);\n\n\t\t\t\tDBG_INF_FMT(\"looking for %s auth plugin\", plugin_name);\n\t\t\t\tauth_plugin = mysqlnd_plugin_find(plugin_name);\n\t\t\t\tmnd_sprintf_free(plugin_name);\n\n\t\t\t\tif (!auth_plugin) {\n\t\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"The server requested authentication method unknown to the client [%s]\", requested_protocol);\n\t\t\t\t\tSET_CLIENT_ERROR(*conn->error_info, CR_NOT_IMPLEMENTED, UNKNOWN_SQLSTATE, \"The server requested authentication method unknown to the client\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tDBG_INF(\"plugin found\");\n\n\t\t\t{\n\t\t\t\tzend_uchar * switch_to_auth_protocol_data = NULL;\n\t\t\t\tsize_t switch_to_auth_protocol_data_len = 0;\n\t\t\t\tzend_uchar * scrambled_data = NULL;\n\t\t\t\tsize_t scrambled_data_len = 0;\n\n\t\t\t\tswitch_to_auth_protocol = NULL;\n\t\t\t\tswitch_to_auth_protocol_len = 0;\n\n\t\t\t\tif (conn->auth_plugin_data) {\n\t\t\t\t\tmnd_pefree(conn->auth_plugin_data, conn->persistent);\n\t\t\t\t\tconn->auth_plugin_data = NULL;\n\t\t\t\t}\n\t\t\t\tconn->auth_plugin_data_len = plugin_data_len;\n\t\t\t\tconn->auth_plugin_data = mnd_pemalloc(conn->auth_plugin_data_len, conn->persistent);\n\t\t\t\tif (!conn->auth_plugin_data) {\n\t\t\t\t\tSET_OOM_ERROR(*conn->error_info);\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t\tmemcpy(conn->auth_plugin_data, plugin_data, plugin_data_len);\n\n\t\t\t\tDBG_INF_FMT(\"salt=[%*s]\", plugin_data_len - 1, plugin_data);\n\t\t\t\t/* The data should be allocated with malloc() */\n\t\t\t\tscrambled_data =\n\t\t\t\t\tauth_plugin->methods.get_auth_data(NULL, &scrambled_data_len, conn, user, passwd, passwd_len,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   plugin_data, plugin_data_len, options, mysql_flags TSRMLS_CC);\n\n\n\t\t\t\tret = mysqlnd_auth_handshake(conn, user, passwd, passwd_len, db, db_len, options, mysql_flags,\n\t\t\t\t\t\t\t\t\t\t\tgreet_packet->charset_no,\n\t\t\t\t\t\t\t\t\t\t\tfirst_call,\n\t\t\t\t\t\t\t\t\t\t\trequested_protocol,\n\t\t\t\t\t\t\t\t\t\t\tscrambled_data, scrambled_data_len,\n\t\t\t\t\t\t\t\t\t\t\t&switch_to_auth_protocol, &switch_to_auth_protocol_len,\n\t\t\t\t\t\t\t\t\t\t\t&switch_to_auth_protocol_data, &switch_to_auth_protocol_data_len\n\t\t\t\t\t\t\t\t\t\t\tTSRMLS_CC);\n\t\t\t\tfirst_call = FALSE;\n\t\t\t\tfree(scrambled_data);\n\n\t\t\t\tDBG_INF_FMT(\"switch_to_auth_protocol=%s\", switch_to_auth_protocol? switch_to_auth_protocol:\"n/a\");\n\t\t\t\tif (requested_protocol && switch_to_auth_protocol) {\n\t\t\t\t\tmnd_efree(requested_protocol);\n\t\t\t\t\trequested_protocol = switch_to_auth_protocol;\n\t\t\t\t}\n\n\t\t\t\tif (plugin_data) {\n\t\t\t\t\tmnd_efree(plugin_data);\n\t\t\t\t}\n\t\t\t\tplugin_data_len = switch_to_auth_protocol_data_len;\n\t\t\t\tplugin_data = switch_to_auth_protocol_data;\n\t\t\t}\n\t\t\tDBG_INF_FMT(\"conn->error_info->error_no = %d\", conn->error_info->error_no);\n\t\t} while (ret == FAIL && conn->error_info->error_no == 0 && switch_to_auth_protocol != NULL);\n\t\tif (plugin_data) {\n\t\t\tmnd_efree(plugin_data);\n\t\t}\n\t\t\n\t\tif (ret == PASS) {\n\t\t\tDBG_INF_FMT(\"saving requested_protocol=%s\", requested_protocol);\n\t\t\tconn->m->set_client_option(conn, MYSQLND_OPT_AUTH_PROTOCOL, requested_protocol TSRMLS_CC);\n\t\t}\n\n\t\tif (requested_protocol) {\n\t\t\tmnd_efree(requested_protocol);\n\t\t}\n\t}\nend:\n\tDBG_RETURN(ret);\n}",
        "func": "static enum_func_status\nmysqlnd_connect_run_authentication(\n\t\t\tMYSQLND_CONN_DATA * conn,\n\t\t\tconst char * const user,\n\t\t\tconst char * const passwd,\n\t\t\tconst char * const db,\n\t\t\tsize_t db_len,\n\t\t\tsize_t passwd_len,\n\t\t\tconst MYSQLND_PACKET_GREET * const greet_packet,\n\t\t\tconst MYSQLND_OPTIONS * const options,\n\t\t\tunsigned long mysql_flags\n\t\t\tTSRMLS_DC)\n{\n\tenum_func_status ret = FAIL;\n\tDBG_ENTER(\"mysqlnd_connect_run_authentication\");\n\n\tret = mysqlnd_switch_to_ssl_if_needed(conn, greet_packet, options, mysql_flags TSRMLS_CC);\n\tif (PASS == ret) {\n\t\tzend_bool first_call = TRUE;\n\n\t\tchar * switch_to_auth_protocol = NULL;\n\t\tsize_t switch_to_auth_protocol_len = 0;\n\t\tchar * requested_protocol = NULL;\n\t\tzend_uchar * plugin_data;\n\t\tsize_t plugin_data_len;\n\n\t\tplugin_data_len = greet_packet->auth_plugin_data_len;\n\t\tplugin_data = mnd_emalloc(plugin_data_len + 1);\n\t\tif (!plugin_data) {\n\t\t\tret = FAIL;\n\t\t\tgoto end;\n\t\t}\n\t\tmemcpy(plugin_data, greet_packet->auth_plugin_data, plugin_data_len);\n\t\tplugin_data[plugin_data_len] = '\\0';\n\n\t\trequested_protocol = mnd_pestrdup(greet_packet->auth_protocol? greet_packet->auth_protocol: \"mysql_native_password\", FALSE);\n\t\tif (!requested_protocol) {\n\t\t\tret = FAIL;\n\t\t\tgoto end;\n\t\t}\n\n\t\tdo {\n\t\t\tstruct st_mysqlnd_authentication_plugin * auth_plugin;\n\t\t\t{\n\t\t\t\tchar * plugin_name = NULL;\n\n\t\t\t\tmnd_sprintf(&plugin_name, 0, \"auth_plugin_%s\", requested_protocol);\n\n\t\t\t\tDBG_INF_FMT(\"looking for %s auth plugin\", plugin_name);\n\t\t\t\tauth_plugin = mysqlnd_plugin_find(plugin_name);\n\t\t\t\tmnd_sprintf_free(plugin_name);\n\n\t\t\t\tif (!auth_plugin) {\n\t\t\t\t\tphp_error_docref(NULL TSRMLS_CC, E_WARNING, \"The server requested authentication method unknown to the client [%s]\", requested_protocol);\n\t\t\t\t\tSET_CLIENT_ERROR(*conn->error_info, CR_NOT_IMPLEMENTED, UNKNOWN_SQLSTATE, \"The server requested authentication method unknown to the client\");\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tDBG_INF(\"plugin found\");\n\n\t\t\t{\n\t\t\t\tzend_uchar * switch_to_auth_protocol_data = NULL;\n\t\t\t\tsize_t switch_to_auth_protocol_data_len = 0;\n\t\t\t\tzend_uchar * scrambled_data = NULL;\n\t\t\t\tsize_t scrambled_data_len = 0;\n\n\t\t\t\tswitch_to_auth_protocol = NULL;\n\t\t\t\tswitch_to_auth_protocol_len = 0;\n\n\t\t\t\tif (conn->auth_plugin_data) {\n\t\t\t\t\tmnd_pefree(conn->auth_plugin_data, conn->persistent);\n\t\t\t\t\tconn->auth_plugin_data = NULL;\n\t\t\t\t}\n\t\t\t\tconn->auth_plugin_data_len = plugin_data_len;\n\t\t\t\tconn->auth_plugin_data = mnd_pemalloc(conn->auth_plugin_data_len, conn->persistent);\n\t\t\t\tif (!conn->auth_plugin_data) {\n\t\t\t\t\tSET_OOM_ERROR(*conn->error_info);\n\t\t\t\t\tgoto end;\n\t\t\t\t}\n\t\t\t\tmemcpy(conn->auth_plugin_data, plugin_data, plugin_data_len);\n\n\t\t\t\tDBG_INF_FMT(\"salt=[%*s]\", plugin_data_len - 1, plugin_data);\n\t\t\t\t/* The data should be allocated with malloc() */\n\t\t\t\tscrambled_data =\n\t\t\t\t\tauth_plugin->methods.get_auth_data(NULL, &scrambled_data_len, conn, user, passwd, passwd_len,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   plugin_data, plugin_data_len, options, mysql_flags TSRMLS_CC);\n\n\n\t\t\t\tret = mysqlnd_auth_handshake(conn, user, passwd, passwd_len, db, db_len, options, mysql_flags,\n\t\t\t\t\t\t\t\t\t\t\tgreet_packet->charset_no,\n\t\t\t\t\t\t\t\t\t\t\tfirst_call,\n\t\t\t\t\t\t\t\t\t\t\trequested_protocol,\n\t\t\t\t\t\t\t\t\t\t\tscrambled_data, scrambled_data_len,\n\t\t\t\t\t\t\t\t\t\t\t&switch_to_auth_protocol, &switch_to_auth_protocol_len,\n\t\t\t\t\t\t\t\t\t\t\t&switch_to_auth_protocol_data, &switch_to_auth_protocol_data_len\n\t\t\t\t\t\t\t\t\t\t\tTSRMLS_CC);\n\t\t\t\tfirst_call = FALSE;\n\t\t\t\tfree(scrambled_data);\n\n\t\t\t\tDBG_INF_FMT(\"switch_to_auth_protocol=%s\", switch_to_auth_protocol? switch_to_auth_protocol:\"n/a\");\n\t\t\t\tif (requested_protocol && switch_to_auth_protocol) {\n\t\t\t\t\tmnd_efree(requested_protocol);\n\t\t\t\t\trequested_protocol = switch_to_auth_protocol;\n\t\t\t\t}\n\n\t\t\t\tif (plugin_data) {\n\t\t\t\t\tmnd_efree(plugin_data);\n\t\t\t\t}\n\t\t\t\tplugin_data_len = switch_to_auth_protocol_data_len;\n\t\t\t\tplugin_data = switch_to_auth_protocol_data;\n\t\t\t}\n\t\t\tDBG_INF_FMT(\"conn->error_info->error_no = %d\", conn->error_info->error_no);\n\t\t} while (ret == FAIL && conn->error_info->error_no == 0 && switch_to_auth_protocol != NULL);\n\t\tif (plugin_data) {\n\t\t\tmnd_efree(plugin_data);\n\t\t}\n\n\t\tif (ret == PASS) {\n\t\t\tDBG_INF_FMT(\"saving requested_protocol=%s\", requested_protocol);\n\t\t\tconn->m->set_client_option(conn, MYSQLND_OPT_AUTH_PROTOCOL, requested_protocol TSRMLS_CC);\n\t\t}\n\n\t\tif (requested_protocol) {\n\t\t\tmnd_efree(requested_protocol);\n\t\t}\n\t}\nend:\n\tDBG_RETURN(ret);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -114,7 +114,7 @@\n \t\tif (plugin_data) {\n \t\t\tmnd_efree(plugin_data);\n \t\t}\n-\t\t\n+\n \t\tif (ret == PASS) {\n \t\t\tDBG_INF_FMT(\"saving requested_protocol=%s\", requested_protocol);\n \t\t\tconn->m->set_client_option(conn, MYSQLND_OPT_AUTH_PROTOCOL, requested_protocol TSRMLS_CC);",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t"
            ],
            "added_lines": [
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2016-1675",
        "func_name": "chromium/LocalFrame::navigate",
        "description": "Blink, as used in Google Chrome before 51.0.2704.63, allows remote attackers to bypass the Same Origin Policy by leveraging the mishandling of Document reattachment during destruction, related to FrameLoader.cpp and LocalFrame.cpp.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/73563fee12defb21a8f955993b68907169e1ea6d",
        "commit_title": "Move isNavigationAllowed() check to main entry point for loads.",
        "commit_text": " Also document the difference between the two types of navigation disablers and how they should be used.    ",
        "func_before": "void LocalFrame::navigate(const FrameLoadRequest& request)\n{\n    if (!isNavigationAllowed())\n        return;\n    m_loader.load(request);\n}",
        "func": "void LocalFrame::navigate(const FrameLoadRequest& request)\n{\n    m_loader.load(request);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,4 @@\n void LocalFrame::navigate(const FrameLoadRequest& request)\n {\n-    if (!isNavigationAllowed())\n-        return;\n     m_loader.load(request);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    if (!isNavigationAllowed())",
                "        return;"
            ],
            "added_lines": []
        }
    },
    {
        "cve_id": "CVE-2016-1675",
        "func_name": "chromium/FrameLoader::load",
        "description": "Blink, as used in Google Chrome before 51.0.2704.63, allows remote attackers to bypass the Same Origin Policy by leveraging the mishandling of Document reattachment during destruction, related to FrameLoader.cpp and LocalFrame.cpp.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/73563fee12defb21a8f955993b68907169e1ea6d",
        "commit_title": "Move isNavigationAllowed() check to main entry point for loads.",
        "commit_text": " Also document the difference between the two types of navigation disablers and how they should be used.    ",
        "func_before": "void FrameLoader::load(const FrameLoadRequest& passedRequest, FrameLoadType frameLoadType,\n    HistoryItem* historyItem, HistoryLoadType historyLoadType)\n{\n    ASSERT(m_frame->document());\n\n    if (m_inStopAllLoaders)\n        return;\n\n    if (m_frame->page()->defersLoading() && isBackForwardLoadType(frameLoadType)) {\n        m_deferredHistoryLoad = DeferredHistoryLoad::create(passedRequest.resourceRequest(), historyItem, frameLoadType, historyLoadType);\n        return;\n    }\n\n    FrameLoadRequest request(passedRequest);\n    request.resourceRequest().setHasUserGesture(UserGestureIndicator::processingUserGesture());\n\n    if (!prepareRequestForThisFrame(request))\n        return;\n\n    Frame* targetFrame = request.form() ? nullptr : m_frame->findFrameForNavigation(AtomicString(request.frameName()), *m_frame);\n\n    if (isBackForwardLoadType(frameLoadType)) {\n        ASSERT(historyItem);\n        m_provisionalItem = historyItem;\n    }\n\n    if (targetFrame && targetFrame != m_frame) {\n        bool wasInSamePage = targetFrame->page() == m_frame->page();\n\n        request.setFrameName(\"_self\");\n        targetFrame->navigate(request);\n        Page* page = targetFrame->page();\n        if (!wasInSamePage && page)\n            page->chromeClient().focus();\n        return;\n    }\n\n    setReferrerForFrameRequest(request.resourceRequest(), request.getShouldSendReferrer(), request.originDocument());\n\n    FrameLoadType newLoadType = (frameLoadType == FrameLoadTypeStandard) ?\n        determineFrameLoadType(request) : frameLoadType;\n    NavigationPolicy policy = navigationPolicyForRequest(request);\n    if (shouldOpenInNewWindow(targetFrame, request, policy)) {\n        if (policy == NavigationPolicyDownload) {\n            client()->loadURLExternally(request.resourceRequest(), NavigationPolicyDownload, String(), false);\n        } else {\n            request.resourceRequest().setFrameType(WebURLRequest::FrameTypeAuxiliary);\n            createWindowForRequest(request, *m_frame, policy, request.getShouldSendReferrer(), request.getShouldSetOpener());\n        }\n        return;\n    }\n\n    const KURL& url = request.resourceRequest().url();\n    bool sameDocumentHistoryNavigation =\n        isBackForwardLoadType(newLoadType) && historyLoadType == HistorySameDocumentLoad;\n    bool sameDocumentNavigation = policy == NavigationPolicyCurrentTab\n        && shouldPerformFragmentNavigation(\n            request.form(), request.resourceRequest().httpMethod(), newLoadType, url);\n\n    // Perform same document navigation.\n    if (sameDocumentHistoryNavigation || sameDocumentNavigation) {\n        ASSERT(historyItem || !sameDocumentHistoryNavigation);\n        RefPtr<SerializedScriptValue> stateObject = sameDocumentHistoryNavigation ?\n            historyItem->stateObject() : nullptr;\n\n        if (!sameDocumentHistoryNavigation) {\n            m_documentLoader->setNavigationType(determineNavigationType(\n                newLoadType, false, request.triggeringEvent()));\n            if (shouldTreatURLAsSameAsCurrent(url))\n                newLoadType = FrameLoadTypeReplaceCurrentItem;\n        }\n\n        loadInSameDocument(url, stateObject, newLoadType, historyLoadType, request.clientRedirect());\n        return;\n    }\n\n    startLoad(request, newLoadType, policy);\n}",
        "func": "void FrameLoader::load(const FrameLoadRequest& passedRequest, FrameLoadType frameLoadType,\n    HistoryItem* historyItem, HistoryLoadType historyLoadType)\n{\n    ASSERT(m_frame->document());\n\n    if (!m_frame->isNavigationAllowed())\n        return;\n\n    if (m_inStopAllLoaders)\n        return;\n\n    if (m_frame->page()->defersLoading() && isBackForwardLoadType(frameLoadType)) {\n        m_deferredHistoryLoad = DeferredHistoryLoad::create(passedRequest.resourceRequest(), historyItem, frameLoadType, historyLoadType);\n        return;\n    }\n\n    FrameLoadRequest request(passedRequest);\n    request.resourceRequest().setHasUserGesture(UserGestureIndicator::processingUserGesture());\n\n    if (!prepareRequestForThisFrame(request))\n        return;\n\n    Frame* targetFrame = request.form() ? nullptr : m_frame->findFrameForNavigation(AtomicString(request.frameName()), *m_frame);\n\n    if (isBackForwardLoadType(frameLoadType)) {\n        ASSERT(historyItem);\n        m_provisionalItem = historyItem;\n    }\n\n    if (targetFrame && targetFrame != m_frame) {\n        bool wasInSamePage = targetFrame->page() == m_frame->page();\n\n        request.setFrameName(\"_self\");\n        targetFrame->navigate(request);\n        Page* page = targetFrame->page();\n        if (!wasInSamePage && page)\n            page->chromeClient().focus();\n        return;\n    }\n\n    setReferrerForFrameRequest(request.resourceRequest(), request.getShouldSendReferrer(), request.originDocument());\n\n    FrameLoadType newLoadType = (frameLoadType == FrameLoadTypeStandard) ?\n        determineFrameLoadType(request) : frameLoadType;\n    NavigationPolicy policy = navigationPolicyForRequest(request);\n    if (shouldOpenInNewWindow(targetFrame, request, policy)) {\n        if (policy == NavigationPolicyDownload) {\n            client()->loadURLExternally(request.resourceRequest(), NavigationPolicyDownload, String(), false);\n        } else {\n            request.resourceRequest().setFrameType(WebURLRequest::FrameTypeAuxiliary);\n            createWindowForRequest(request, *m_frame, policy, request.getShouldSendReferrer(), request.getShouldSetOpener());\n        }\n        return;\n    }\n\n    const KURL& url = request.resourceRequest().url();\n    bool sameDocumentHistoryNavigation =\n        isBackForwardLoadType(newLoadType) && historyLoadType == HistorySameDocumentLoad;\n    bool sameDocumentNavigation = policy == NavigationPolicyCurrentTab\n        && shouldPerformFragmentNavigation(\n            request.form(), request.resourceRequest().httpMethod(), newLoadType, url);\n\n    // Perform same document navigation.\n    if (sameDocumentHistoryNavigation || sameDocumentNavigation) {\n        ASSERT(historyItem || !sameDocumentHistoryNavigation);\n        RefPtr<SerializedScriptValue> stateObject = sameDocumentHistoryNavigation ?\n            historyItem->stateObject() : nullptr;\n\n        if (!sameDocumentHistoryNavigation) {\n            m_documentLoader->setNavigationType(determineNavigationType(\n                newLoadType, false, request.triggeringEvent()));\n            if (shouldTreatURLAsSameAsCurrent(url))\n                newLoadType = FrameLoadTypeReplaceCurrentItem;\n        }\n\n        loadInSameDocument(url, stateObject, newLoadType, historyLoadType, request.clientRedirect());\n        return;\n    }\n\n    startLoad(request, newLoadType, policy);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,6 +2,9 @@\n     HistoryItem* historyItem, HistoryLoadType historyLoadType)\n {\n     ASSERT(m_frame->document());\n+\n+    if (!m_frame->isNavigationAllowed())\n+        return;\n \n     if (m_inStopAllLoaders)\n         return;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "    if (!m_frame->isNavigationAllowed())",
                "        return;"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-1682",
        "func_name": "chromium/ServiceWorkerContainer::registerServiceWorkerImpl",
        "description": "The ServiceWorkerContainer::registerServiceWorkerImpl function in WebKit/Source/modules/serviceworkers/ServiceWorkerContainer.cpp in Blink, as used in Google Chrome before 51.0.2704.63, allows remote attackers to bypass the Content Security Policy (CSP) protection mechanism via a ServiceWorker registration.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/5289a5d4c98681e9a0f2d28da0c7aa35e282db57",
        "commit_title": "Check CSP before registering ServiceWorkers",
        "commit_text": " Service Worker registrations should be subject to the same CSP checks as other workers. The spec doesn't say this explicitly (https://www.w3.org/TR/CSP2/#directive-child-src-workers says \"Worker or SharedWorker constructors\"), but it seems to be in the spirit of things, and it matches Firefox's behavior.    ",
        "func_before": "void ServiceWorkerContainer::registerServiceWorkerImpl(ExecutionContext* executionContext, const KURL& rawScriptURL, const KURL& scope, PassOwnPtr<RegistrationCallbacks> callbacks)\n{\n    if (!m_provider) {\n        callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeState, \"Failed to register a ServiceWorker: The document is in an invalid state.\"));\n        return;\n    }\n\n    RefPtr<SecurityOrigin> documentOrigin = executionContext->getSecurityOrigin();\n    String errorMessage;\n    // Restrict to secure origins: https://w3c.github.io/webappsec/specs/powerfulfeatures/#settings-privileged\n    if (!executionContext->isSecureContext(errorMessage)) {\n        callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeSecurity, errorMessage));\n        return;\n    }\n\n    KURL pageURL = KURL(KURL(), documentOrigin->toString());\n    if (!SchemeRegistry::shouldTreatURLSchemeAsAllowingServiceWorkers(pageURL.protocol())) {\n        callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeSecurity, String(\"Failed to register a ServiceWorker: The URL protocol of the current origin ('\" + documentOrigin->toString() + \"') is not supported.\")));\n        return;\n    }\n\n    KURL scriptURL = rawScriptURL;\n    scriptURL.removeFragmentIdentifier();\n    if (!documentOrigin->canRequest(scriptURL)) {\n        RefPtr<SecurityOrigin> scriptOrigin = SecurityOrigin::create(scriptURL);\n        callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeSecurity, String(\"Failed to register a ServiceWorker: The origin of the provided scriptURL ('\" + scriptOrigin->toString() + \"') does not match the current origin ('\" + documentOrigin->toString() + \"').\")));\n        return;\n    }\n    if (!SchemeRegistry::shouldTreatURLSchemeAsAllowingServiceWorkers(scriptURL.protocol())) {\n        callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeSecurity, String(\"Failed to register a ServiceWorker: The URL protocol of the script ('\" + scriptURL.getString() + \"') is not supported.\")));\n        return;\n    }\n\n    KURL patternURL = scope;\n    patternURL.removeFragmentIdentifier();\n\n    if (!documentOrigin->canRequest(patternURL)) {\n        RefPtr<SecurityOrigin> patternOrigin = SecurityOrigin::create(patternURL);\n        callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeSecurity, String(\"Failed to register a ServiceWorker: The origin of the provided scope ('\" + patternOrigin->toString() + \"') does not match the current origin ('\" + documentOrigin->toString() + \"').\")));\n        return;\n    }\n    if (!SchemeRegistry::shouldTreatURLSchemeAsAllowingServiceWorkers(patternURL.protocol())) {\n        callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeSecurity, String(\"Failed to register a ServiceWorker: The URL protocol of the scope ('\" + patternURL.getString() + \"') is not supported.\")));\n        return;\n    }\n\n    WebString webErrorMessage;\n    if (!m_provider->validateScopeAndScriptURL(patternURL, scriptURL, &webErrorMessage)) {\n        callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeType, WebString::fromUTF8(\"Failed to register a ServiceWorker: \" + webErrorMessage.utf8())));\n        return;\n    }\n\n    m_provider->registerServiceWorker(patternURL, scriptURL, callbacks.leakPtr());\n}",
        "func": "void ServiceWorkerContainer::registerServiceWorkerImpl(ExecutionContext* executionContext, const KURL& rawScriptURL, const KURL& scope, PassOwnPtr<RegistrationCallbacks> callbacks)\n{\n    if (!m_provider) {\n        callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeState, \"Failed to register a ServiceWorker: The document is in an invalid state.\"));\n        return;\n    }\n\n    RefPtr<SecurityOrigin> documentOrigin = executionContext->getSecurityOrigin();\n    String errorMessage;\n    // Restrict to secure origins: https://w3c.github.io/webappsec/specs/powerfulfeatures/#settings-privileged\n    if (!executionContext->isSecureContext(errorMessage)) {\n        callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeSecurity, errorMessage));\n        return;\n    }\n\n    KURL pageURL = KURL(KURL(), documentOrigin->toString());\n    if (!SchemeRegistry::shouldTreatURLSchemeAsAllowingServiceWorkers(pageURL.protocol())) {\n        callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeSecurity, String(\"Failed to register a ServiceWorker: The URL protocol of the current origin ('\" + documentOrigin->toString() + \"') is not supported.\")));\n        return;\n    }\n\n    KURL scriptURL = rawScriptURL;\n    scriptURL.removeFragmentIdentifier();\n    if (!documentOrigin->canRequest(scriptURL)) {\n        RefPtr<SecurityOrigin> scriptOrigin = SecurityOrigin::create(scriptURL);\n        callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeSecurity, String(\"Failed to register a ServiceWorker: The origin of the provided scriptURL ('\" + scriptOrigin->toString() + \"') does not match the current origin ('\" + documentOrigin->toString() + \"').\")));\n        return;\n    }\n    if (!SchemeRegistry::shouldTreatURLSchemeAsAllowingServiceWorkers(scriptURL.protocol())) {\n        callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeSecurity, String(\"Failed to register a ServiceWorker: The URL protocol of the script ('\" + scriptURL.getString() + \"') is not supported.\")));\n        return;\n    }\n\n    KURL patternURL = scope;\n    patternURL.removeFragmentIdentifier();\n\n    if (!documentOrigin->canRequest(patternURL)) {\n        RefPtr<SecurityOrigin> patternOrigin = SecurityOrigin::create(patternURL);\n        callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeSecurity, String(\"Failed to register a ServiceWorker: The origin of the provided scope ('\" + patternOrigin->toString() + \"') does not match the current origin ('\" + documentOrigin->toString() + \"').\")));\n        return;\n    }\n    if (!SchemeRegistry::shouldTreatURLSchemeAsAllowingServiceWorkers(patternURL.protocol())) {\n        callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeSecurity, String(\"Failed to register a ServiceWorker: The URL protocol of the scope ('\" + patternURL.getString() + \"') is not supported.\")));\n        return;\n    }\n\n    WebString webErrorMessage;\n    if (!m_provider->validateScopeAndScriptURL(patternURL, scriptURL, &webErrorMessage)) {\n        callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeType, WebString::fromUTF8(\"Failed to register a ServiceWorker: \" + webErrorMessage.utf8())));\n        return;\n    }\n\n    ContentSecurityPolicy* csp = executionContext->contentSecurityPolicy();\n    if (csp) {\n        if (!csp->allowWorkerContextFromSource(scriptURL, ContentSecurityPolicy::DidNotRedirect, ContentSecurityPolicy::SendReport)) {\n            callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeSecurity, String(\"Failed to register a ServiceWorker: The provided scriptURL ('\" + scriptURL.getString() + \"') violates the Content Security Policy.\")));\n            return;\n        }\n    }\n\n    m_provider->registerServiceWorker(patternURL, scriptURL, callbacks.leakPtr());\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -50,5 +50,13 @@\n         return;\n     }\n \n+    ContentSecurityPolicy* csp = executionContext->contentSecurityPolicy();\n+    if (csp) {\n+        if (!csp->allowWorkerContextFromSource(scriptURL, ContentSecurityPolicy::DidNotRedirect, ContentSecurityPolicy::SendReport)) {\n+            callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeSecurity, String(\"Failed to register a ServiceWorker: The provided scriptURL ('\" + scriptURL.getString() + \"') violates the Content Security Policy.\")));\n+            return;\n+        }\n+    }\n+\n     m_provider->registerServiceWorker(patternURL, scriptURL, callbacks.leakPtr());\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    ContentSecurityPolicy* csp = executionContext->contentSecurityPolicy();",
                "    if (csp) {",
                "        if (!csp->allowWorkerContextFromSource(scriptURL, ContentSecurityPolicy::DidNotRedirect, ContentSecurityPolicy::SendReport)) {",
                "            callbacks->onError(WebServiceWorkerError(WebServiceWorkerError::ErrorTypeSecurity, String(\"Failed to register a ServiceWorker: The provided scriptURL ('\" + scriptURL.getString() + \"') violates the Content Security Policy.\")));",
                "            return;",
                "        }",
                "    }",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2016-1692",
        "func_name": "chromium/StyleSheetContents::parseAuthorStyleSheet",
        "description": "WebKit/Source/core/css/StyleSheetContents.cpp in Blink, as used in Google Chrome before 51.0.2704.63, permits cross-origin loading of CSS stylesheets by a ServiceWorker even when the stylesheet download has an incorrect MIME type, which allows remote attackers to bypass the Same Origin Policy via a crafted web site.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/3d9fa8719b092361eb0a6baec91d378599e74b75",
        "commit_title": "Check the mime type of cross-origin CSS fetched via the Service Worker.",
        "commit_text": "   ",
        "func_before": "void StyleSheetContents::parseAuthorStyleSheet(const CSSStyleSheetResource* cachedStyleSheet, const SecurityOrigin* securityOrigin)\n{\n    TRACE_EVENT1(\"blink,devtools.timeline\", \"ParseAuthorStyleSheet\", \"data\", InspectorParseAuthorStyleSheetEvent::data(cachedStyleSheet));\n\n    bool isSameOriginRequest = securityOrigin && securityOrigin->canRequest(baseURL());\n    CSSStyleSheetResource::MIMETypeCheck mimeTypeCheck = isQuirksModeBehavior(m_parserContext.mode()) && isSameOriginRequest ? CSSStyleSheetResource::MIMETypeCheck::Lax : CSSStyleSheetResource::MIMETypeCheck::Strict;\n    String sheetText = cachedStyleSheet->sheetText(mimeTypeCheck);\n\n    const ResourceResponse& response = cachedStyleSheet->response();\n    m_sourceMapURL = response.httpHeaderField(HTTPNames::SourceMap);\n    if (m_sourceMapURL.isEmpty()) {\n        // Try to get deprecated header.\n        m_sourceMapURL = response.httpHeaderField(HTTPNames::X_SourceMap);\n    }\n\n    CSSParserContext context(parserContext(), UseCounter::getFrom(this));\n    CSSParser::parseSheet(context, this, sheetText);\n}",
        "func": "void StyleSheetContents::parseAuthorStyleSheet(const CSSStyleSheetResource* cachedStyleSheet, const SecurityOrigin* securityOrigin)\n{\n    TRACE_EVENT1(\"blink,devtools.timeline\", \"ParseAuthorStyleSheet\", \"data\", InspectorParseAuthorStyleSheetEvent::data(cachedStyleSheet));\n\n    bool isSameOriginRequest = securityOrigin && securityOrigin->canRequest(baseURL());\n\n    // When the response was fetched via the Service Worker, the original URL may not be same as the base URL.\n    // TODO(horo): When we will use the original URL as the base URL, we can remove this check. crbug.com/553535\n    if (cachedStyleSheet->response().wasFetchedViaServiceWorker()) {\n        const KURL originalURL(cachedStyleSheet->response().originalURLViaServiceWorker());\n        // |originalURL| is empty when the response is created in the SW.\n        if (!originalURL.isEmpty() && !securityOrigin->canRequest(originalURL))\n            isSameOriginRequest = false;\n    }\n\n    CSSStyleSheetResource::MIMETypeCheck mimeTypeCheck = isQuirksModeBehavior(m_parserContext.mode()) && isSameOriginRequest ? CSSStyleSheetResource::MIMETypeCheck::Lax : CSSStyleSheetResource::MIMETypeCheck::Strict;\n    String sheetText = cachedStyleSheet->sheetText(mimeTypeCheck);\n\n    const ResourceResponse& response = cachedStyleSheet->response();\n    m_sourceMapURL = response.httpHeaderField(HTTPNames::SourceMap);\n    if (m_sourceMapURL.isEmpty()) {\n        // Try to get deprecated header.\n        m_sourceMapURL = response.httpHeaderField(HTTPNames::X_SourceMap);\n    }\n\n    CSSParserContext context(parserContext(), UseCounter::getFrom(this));\n    CSSParser::parseSheet(context, this, sheetText);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,6 +3,16 @@\n     TRACE_EVENT1(\"blink,devtools.timeline\", \"ParseAuthorStyleSheet\", \"data\", InspectorParseAuthorStyleSheetEvent::data(cachedStyleSheet));\n \n     bool isSameOriginRequest = securityOrigin && securityOrigin->canRequest(baseURL());\n+\n+    // When the response was fetched via the Service Worker, the original URL may not be same as the base URL.\n+    // TODO(horo): When we will use the original URL as the base URL, we can remove this check. crbug.com/553535\n+    if (cachedStyleSheet->response().wasFetchedViaServiceWorker()) {\n+        const KURL originalURL(cachedStyleSheet->response().originalURLViaServiceWorker());\n+        // |originalURL| is empty when the response is created in the SW.\n+        if (!originalURL.isEmpty() && !securityOrigin->canRequest(originalURL))\n+            isSameOriginRequest = false;\n+    }\n+\n     CSSStyleSheetResource::MIMETypeCheck mimeTypeCheck = isQuirksModeBehavior(m_parserContext.mode()) && isSameOriginRequest ? CSSStyleSheetResource::MIMETypeCheck::Lax : CSSStyleSheetResource::MIMETypeCheck::Strict;\n     String sheetText = cachedStyleSheet->sheetText(mimeTypeCheck);\n ",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "    // When the response was fetched via the Service Worker, the original URL may not be same as the base URL.",
                "    // TODO(horo): When we will use the original URL as the base URL, we can remove this check. crbug.com/553535",
                "    if (cachedStyleSheet->response().wasFetchedViaServiceWorker()) {",
                "        const KURL originalURL(cachedStyleSheet->response().originalURLViaServiceWorker());",
                "        // |originalURL| is empty when the response is created in the SW.",
                "        if (!originalURL.isEmpty() && !securityOrigin->canRequest(originalURL))",
                "            isSameOriginRequest = false;",
                "    }",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2016-1694",
        "func_name": "chromium/BrowsingDataRemover::RemoveImpl",
        "description": "browser/browsing_data/browsing_data_remover.cc in Google Chrome before 51.0.2704.63 deletes HPKP pins during cache clearing, which makes it easier for remote attackers to spoof web sites via a valid certificate from an arbitrary recognized Certification Authority.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/c686e3083ac8b46b2b8ce6c036554bf05a7ed9ec",
        "commit_title": "Clear network state only when REMOVE_CACHE is set, not unconditionally",
        "commit_text": " Previously, network state like HSTS data was cleared whenever BrowsingDataRemover::Remove() was called. Some archaeology (https://codereview.chromium.org/7717023/) reveals that the original intention was to clear this state when REMOVE_CACHE was set, but due to a curly brace mishap, we've been clearing it over-aggressively for years.  When I changed this behavior to remove network state only when REMOVE_CACHE is set, it revealed that a number of tests are relying on state being asynchronously cleared. This is no longer the case, as for example when only REMOVE_DOWNLOADS is set. This CL fixes that by calling NotifyIfDone() at the end of RemoveImpl(), to catch cases where no state is being wiped asynchronously. This is a little weird since download removal does appear to be async -- but it matches the documentation of BrowsingDataRemover::Observer, which says that the observer fires when \"keywords have been deleted, cache cleared and all other tasks scheduled\".   Review-Url: https://codereview.chromium.org/1941073002 ",
        "func_before": "void BrowsingDataRemover::RemoveImpl(\n    const TimeRange& time_range,\n    int remove_mask,\n    const BrowsingDataFilterBuilder& filter_builder,\n    int origin_type_mask) {\n  DCHECK_CURRENTLY_ON(BrowserThread::UI);\n\n  // crbug.com/140910: Many places were calling this with base::Time() as\n  // delete_end, even though they should've used base::Time::Max().\n  DCHECK_NE(base::Time(), time_range.end);\n\n  SetRemoving(true);\n  delete_begin_ = time_range.begin;\n  delete_end_ = time_range.end;\n  remove_mask_ = remove_mask;\n  origin_type_mask_ = origin_type_mask;\n\n  base::Callback<bool(const GURL& url)> filter =\n      filter_builder.BuildGeneralFilter();\n  base::Callback<bool(const ContentSettingsPattern& url)> same_pattern_filter =\n      filter_builder.BuildWebsiteSettingsPatternMatchesFilter();\n\n  PrefService* prefs = profile_->GetPrefs();\n  bool may_delete_history = prefs->GetBoolean(\n      prefs::kAllowDeletingBrowserHistory);\n\n  // All the UI entry points into the BrowsingDataRemover should be disabled,\n  // but this will fire if something was missed or added.\n  DCHECK(may_delete_history || (remove_mask & REMOVE_NOCHECKS) ||\n      (!(remove_mask & REMOVE_HISTORY) && !(remove_mask & REMOVE_DOWNLOADS)));\n\n  if (origin_type_mask_ & BrowsingDataHelper::UNPROTECTED_WEB) {\n    content::RecordAction(\n        UserMetricsAction(\"ClearBrowsingData_MaskContainsUnprotectedWeb\"));\n  }\n  if (origin_type_mask_ & BrowsingDataHelper::PROTECTED_WEB) {\n    content::RecordAction(\n        UserMetricsAction(\"ClearBrowsingData_MaskContainsProtectedWeb\"));\n  }\n  if (origin_type_mask_ & BrowsingDataHelper::EXTENSION) {\n    content::RecordAction(\n        UserMetricsAction(\"ClearBrowsingData_MaskContainsExtension\"));\n  }\n  // If this fires, we added a new BrowsingDataHelper::OriginTypeMask without\n  // updating the user metrics above.\n  static_assert(\n      BrowsingDataHelper::ALL == (BrowsingDataHelper::UNPROTECTED_WEB |\n                                  BrowsingDataHelper::PROTECTED_WEB |\n                                  BrowsingDataHelper::EXTENSION),\n      \"OriginTypeMask has been updated without updating user metrics\");\n\n  if ((remove_mask & REMOVE_HISTORY) && may_delete_history) {\n    history::HistoryService* history_service =\n        HistoryServiceFactory::GetForProfile(\n            profile_, ServiceAccessType::EXPLICIT_ACCESS);\n    if (history_service) {\n      // TODO(dmurph): Support all backends with filter (crbug.com/113621).\n      content::RecordAction(UserMetricsAction(\"ClearBrowsingData_History\"));\n      waiting_for_clear_history_ = true;\n      history_service->ExpireLocalAndRemoteHistoryBetween(\n          WebHistoryServiceFactory::GetForProfile(profile_), std::set<GURL>(),\n          delete_begin_, delete_end_,\n          base::Bind(&BrowsingDataRemover::OnHistoryDeletionDone,\n                     weak_ptr_factory_.GetWeakPtr()),\n          &history_task_tracker_);\n\n#if defined(ENABLE_EXTENSIONS)\n      // The extension activity contains details of which websites extensions\n      // were active on. It therefore indirectly stores details of websites a\n      // user has visited so best clean from here as well.\n      extensions::ActivityLog::GetInstance(profile_)->RemoveURLs(\n          std::set<GURL>());\n#endif\n    }\n\n#if defined(ENABLE_EXTENSIONS)\n    // Clear launch times as they are a form of history.\n    extensions::ExtensionPrefs* extension_prefs =\n        extensions::ExtensionPrefs::Get(profile_);\n    extension_prefs->ClearLastLaunchTimes();\n#endif\n\n    // The power consumption history by origin contains details of websites\n    // that were visited.\n    // TODO(dmurph): Support all backends with filter (crbug.com/113621).\n    power::OriginPowerMap* origin_power_map =\n        power::OriginPowerMapFactory::GetForBrowserContext(profile_);\n    if (origin_power_map)\n      origin_power_map->ClearOriginMap();\n\n    // Need to clear the host cache and accumulated speculative data, as it also\n    // reveals some history: we have no mechanism to track when these items were\n    // created, so we'll clear them all. Better safe than sorry.\n    if (g_browser_process->io_thread()) {\n      // TODO(dmurph): Support all backends with filter (crbug.com/113621).\n      waiting_for_clear_hostname_resolution_cache_ = true;\n      BrowserThread::PostTaskAndReply(\n          BrowserThread::IO, FROM_HERE,\n          base::Bind(&ClearHostnameResolutionCacheOnIOThread,\n                     g_browser_process->io_thread()),\n          base::Bind(&BrowsingDataRemover::OnClearedHostnameResolutionCache,\n                     weak_ptr_factory_.GetWeakPtr()));\n    }\n    if (profile_->GetNetworkPredictor()) {\n      // TODO(dmurph): Support all backends with filter (crbug.com/113621).\n      waiting_for_clear_network_predictor_ = true;\n      BrowserThread::PostTaskAndReply(\n          BrowserThread::IO, FROM_HERE,\n          base::Bind(&ClearNetworkPredictorOnIOThread,\n                     profile_->GetNetworkPredictor()),\n          base::Bind(&BrowsingDataRemover::OnClearedNetworkPredictor,\n                     weak_ptr_factory_.GetWeakPtr()));\n    }\n\n    // As part of history deletion we also delete the auto-generated keywords.\n    TemplateURLService* keywords_model =\n        TemplateURLServiceFactory::GetForProfile(profile_);\n\n    if (keywords_model && !keywords_model->loaded()) {\n      template_url_sub_ = keywords_model->RegisterOnLoadedCallback(\n          base::Bind(&BrowsingDataRemover::OnKeywordsLoaded,\n                     weak_ptr_factory_.GetWeakPtr()));\n      keywords_model->Load();\n      waiting_for_clear_keyword_data_ = true;\n    } else if (keywords_model) {\n      // TODO(dmurph): Support all backends with filter (crbug.com/113621).\n      keywords_model->RemoveAutoGeneratedForOriginBetween(GURL(), delete_begin_,\n                                                          delete_end_);\n    }\n\n    // The PrerenderManager keeps history of prerendered pages, so clear that.\n    // It also may have a prerendered page. If so, the page could be\n    // considered to have a small amount of historical information, so delete\n    // it, too.\n    prerender::PrerenderManager* prerender_manager =\n        prerender::PrerenderManagerFactory::GetForProfile(profile_);\n    if (prerender_manager) {\n      // TODO(dmurph): Support all backends with filter (crbug.com/113621).\n      prerender_manager->ClearData(\n          prerender::PrerenderManager::CLEAR_PRERENDER_CONTENTS |\n          prerender::PrerenderManager::CLEAR_PRERENDER_HISTORY);\n    }\n\n    // If the caller is removing history for all hosts, then clear ancillary\n    // historical information.\n    if (filter_builder.IsEmptyBlacklist()) {\n      // We also delete the list of recently closed tabs. Since these expire,\n      // they can't be more than a day old, so we can simply clear them all.\n      sessions::TabRestoreService* tab_service =\n          TabRestoreServiceFactory::GetForProfile(profile_);\n      if (tab_service) {\n        tab_service->ClearEntries();\n        tab_service->DeleteLastSession();\n      }\n\n#if defined(ENABLE_SESSION_SERVICE)\n      // We also delete the last session when we delete the history.\n      SessionService* session_service =\n          SessionServiceFactory::GetForProfile(profile_);\n      if (session_service)\n        session_service->DeleteLastSession();\n#endif\n    }\n\n    // The saved Autofill profiles and credit cards can include the origin from\n    // which these profiles and credit cards were learned.  These are a form of\n    // history, so clear them as well.\n    // TODO(dmurph): Support all backends with filter (crbug.com/113621).\n    scoped_refptr<autofill::AutofillWebDataService> web_data_service =\n        WebDataServiceFactory::GetAutofillWebDataForProfile(\n            profile_, ServiceAccessType::EXPLICIT_ACCESS);\n    if (web_data_service.get()) {\n      waiting_for_clear_autofill_origin_urls_ = true;\n      web_data_service->RemoveOriginURLsModifiedBetween(\n          delete_begin_, delete_end_);\n      // The above calls are done on the UI thread but do their work on the DB\n      // thread. So wait for it.\n      BrowserThread::PostTaskAndReply(\n          BrowserThread::DB, FROM_HERE, base::Bind(&base::DoNothing),\n          base::Bind(&BrowsingDataRemover::OnClearedAutofillOriginURLs,\n                     weak_ptr_factory_.GetWeakPtr()));\n\n      autofill::PersonalDataManager* data_manager =\n          autofill::PersonalDataManagerFactory::GetForProfile(profile_);\n      if (data_manager)\n        data_manager->Refresh();\n    }\n\n#if defined(ENABLE_WEBRTC)\n    waiting_for_clear_webrtc_logs_ = true;\n    BrowserThread::PostTaskAndReply(\n        BrowserThread::FILE, FROM_HERE,\n        base::Bind(\n            &WebRtcLogUtil::DeleteOldAndRecentWebRtcLogFiles,\n            WebRtcLogList::GetWebRtcLogDirectoryForProfile(profile_->GetPath()),\n            delete_begin_),\n        base::Bind(&BrowsingDataRemover::OnClearedWebRtcLogs,\n                   weak_ptr_factory_.GetWeakPtr()));\n#endif\n\n    // The SSL Host State that tracks SSL interstitial \"proceed\" decisions may\n    // include origins that the user has visited, so it must be cleared.\n    if (profile_->GetSSLHostStateDelegate())\n      profile_->GetSSLHostStateDelegate()->Clear();\n\n#if BUILDFLAG(ANDROID_JAVA_UI)\n    precache::PrecacheManager* precache_manager =\n        precache::PrecacheManagerFactory::GetForBrowserContext(profile_);\n    // |precache_manager| could be nullptr if the profile is off the record.\n    if (!precache_manager) {\n      waiting_for_clear_precache_history_ = true;\n      precache_manager->ClearHistory();\n      // The above calls are done on the UI thread but do their work on the DB\n      // thread. So wait for it.\n      BrowserThread::PostTaskAndReply(\n          BrowserThread::DB, FROM_HERE, base::Bind(&base::DoNothing),\n          base::Bind(&BrowsingDataRemover::OnClearedPrecacheHistory,\n                     weak_ptr_factory_.GetWeakPtr()));\n    }\n\n    // Clear the history information (last launch time and origin URL) of any\n    // registered webapps. The webapp_registry makes a JNI call into a Java-side\n    // AsyncTask, so don't wait for the reply.\n    waiting_for_clear_webapp_history_ = true;\n    webapp_registry_->ClearWebappHistory(\n        base::Bind(&BrowsingDataRemover::OnClearedWebappHistory,\n          weak_ptr_factory_.GetWeakPtr()));\n#endif\n\n    data_reduction_proxy::DataReductionProxySettings*\n        data_reduction_proxy_settings =\n            DataReductionProxyChromeSettingsFactory::GetForBrowserContext(\n                profile_);\n    // |data_reduction_proxy_settings| is null if |profile_| is off the record.\n    if (data_reduction_proxy_settings) {\n      data_reduction_proxy::DataReductionProxyService*\n          data_reduction_proxy_service =\n              data_reduction_proxy_settings->data_reduction_proxy_service();\n      if (data_reduction_proxy_service) {\n        data_reduction_proxy_service->compression_stats()\n            ->DeleteBrowsingHistory(delete_begin_, delete_end_);\n      }\n    }\n  }\n\n  if ((remove_mask & REMOVE_DOWNLOADS) && may_delete_history) {\n    content::RecordAction(UserMetricsAction(\"ClearBrowsingData_Downloads\"));\n    content::DownloadManager* download_manager =\n        BrowserContext::GetDownloadManager(profile_);\n    download_manager->RemoveDownloadsByURLAndTime(filter,\n                                                  delete_begin_, delete_end_);\n    DownloadPrefs* download_prefs = DownloadPrefs::FromDownloadManager(\n        download_manager);\n    download_prefs->SetSaveFilePath(download_prefs->DownloadPath());\n  }\n\n  uint32_t storage_partition_remove_mask = 0;\n\n  // We ignore the REMOVE_COOKIES request if UNPROTECTED_WEB is not set,\n  // so that callers who request REMOVE_SITE_DATA with PROTECTED_WEB\n  // don't accidentally remove the cookies that are associated with the\n  // UNPROTECTED_WEB origin. This is necessary because cookies are not separated\n  // between UNPROTECTED_WEB and PROTECTED_WEB.\n  if (remove_mask & REMOVE_COOKIES &&\n      origin_type_mask_ & BrowsingDataHelper::UNPROTECTED_WEB) {\n    content::RecordAction(UserMetricsAction(\"ClearBrowsingData_Cookies\"));\n\n    storage_partition_remove_mask |=\n        content::StoragePartition::REMOVE_DATA_MASK_COOKIES;\n\n    // Clear the safebrowsing cookies only if time period is for \"all time\".  It\n    // doesn't make sense to apply the time period of deleting in the last X\n    // hours/days to the safebrowsing cookies since they aren't the result of\n    // any user action.\n    if (delete_begin_ == base::Time()) {\n      safe_browsing::SafeBrowsingService* sb_service =\n          g_browser_process->safe_browsing_service();\n      if (sb_service) {\n        scoped_refptr<net::URLRequestContextGetter> sb_context =\n            sb_service->url_request_context();\n        ++waiting_for_clear_cookies_count_;\n        if (filter_builder.IsEmptyBlacklist()) {\n          BrowserThread::PostTask(\n              BrowserThread::IO, FROM_HERE,\n              base::Bind(&ClearCookiesOnIOThread, delete_begin_, delete_end_,\n                         base::RetainedRef(std::move(sb_context)),\n                         UIThreadTrampoline(\n                             base::Bind(&BrowsingDataRemover::OnClearedCookies,\n                                        weak_ptr_factory_.GetWeakPtr()))));\n        } else {\n          BrowserThread::PostTask(\n              BrowserThread::IO, FROM_HERE,\n              base::Bind(&ClearCookiesWithPredicateOnIOThread, delete_begin_,\n                         delete_end_, filter_builder.BuildCookieFilter(),\n                         base::RetainedRef(std::move(sb_context)),\n                         UIThreadTrampoline(\n                             base::Bind(&BrowsingDataRemover::OnClearedCookies,\n                                        weak_ptr_factory_.GetWeakPtr()))));\n        }\n      }\n    }\n\n    MediaDeviceIDSalt::Reset(profile_->GetPrefs());\n  }\n\n  // Channel IDs are not separated for protected and unprotected web\n  // origins. We check the origin_type_mask_ to prevent unintended deletion.\n  if (remove_mask & REMOVE_CHANNEL_IDS &&\n      origin_type_mask_ & BrowsingDataHelper::UNPROTECTED_WEB) {\n    content::RecordAction(\n        UserMetricsAction(\"ClearBrowsingData_ChannelIDs\"));\n    // Since we are running on the UI thread don't call GetURLRequestContext().\n    scoped_refptr<net::URLRequestContextGetter> rq_context =\n        content::BrowserContext::GetDefaultStoragePartition(profile_)->\n          GetURLRequestContext();\n    waiting_for_clear_channel_ids_ = true;\n    BrowserThread::PostTask(\n        BrowserThread::IO, FROM_HERE,\n        base::Bind(&ClearChannelIDsOnIOThread,\n                   filter_builder.BuildChannelIDFilter(),\n                   delete_begin_, delete_end_, std::move(rq_context),\n                   base::Bind(&BrowsingDataRemover::OnClearedChannelIDs,\n                              weak_ptr_factory_.GetWeakPtr())));\n  }\n\n  if (remove_mask & REMOVE_LOCAL_STORAGE) {\n    storage_partition_remove_mask |=\n        content::StoragePartition::REMOVE_DATA_MASK_LOCAL_STORAGE;\n  }\n\n  if (remove_mask & REMOVE_INDEXEDDB) {\n    storage_partition_remove_mask |=\n        content::StoragePartition::REMOVE_DATA_MASK_INDEXEDDB;\n  }\n  if (remove_mask & REMOVE_WEBSQL) {\n    storage_partition_remove_mask |=\n        content::StoragePartition::REMOVE_DATA_MASK_WEBSQL;\n  }\n  if (remove_mask & REMOVE_APPCACHE) {\n    storage_partition_remove_mask |=\n        content::StoragePartition::REMOVE_DATA_MASK_APPCACHE;\n  }\n  if (remove_mask & REMOVE_SERVICE_WORKERS) {\n    storage_partition_remove_mask |=\n        content::StoragePartition::REMOVE_DATA_MASK_SERVICE_WORKERS;\n  }\n  if (remove_mask & REMOVE_CACHE_STORAGE) {\n    storage_partition_remove_mask |=\n        content::StoragePartition::REMOVE_DATA_MASK_CACHE_STORAGE;\n  }\n  if (remove_mask & REMOVE_FILE_SYSTEMS) {\n    storage_partition_remove_mask |=\n        content::StoragePartition::REMOVE_DATA_MASK_FILE_SYSTEMS;\n  }\n\n#if defined(ENABLE_PLUGINS)\n  // Plugin is data not separated for protected and unprotected web origins. We\n  // check the origin_type_mask_ to prevent unintended deletion.\n  if (remove_mask & REMOVE_PLUGIN_DATA &&\n      origin_type_mask_ & BrowsingDataHelper::UNPROTECTED_WEB) {\n    content::RecordAction(UserMetricsAction(\"ClearBrowsingData_LSOData\"));\n\n    waiting_for_clear_plugin_data_ = true;\n    DCHECK(!plugin_data_remover_);\n    plugin_data_remover_.reset(content::PluginDataRemover::Create(profile_));\n    base::WaitableEvent* event =\n        plugin_data_remover_->StartRemoving(delete_begin_);\n\n    base::WaitableEventWatcher::EventCallback watcher_callback =\n        base::Bind(&BrowsingDataRemover::OnWaitableEventSignaled,\n                   weak_ptr_factory_.GetWeakPtr());\n    watcher_.StartWatching(event, watcher_callback);\n  }\n#endif\n\n  if (remove_mask & REMOVE_SITE_USAGE_DATA) {\n    ClearSettingsForOneTypeWithPredicate(\n        HostContentSettingsMapFactory::GetForProfile(profile_),\n        CONTENT_SETTINGS_TYPE_SITE_ENGAGEMENT,\n        base::Bind(&ForwardPrimaryPatternCallback, same_pattern_filter));\n  }\n\n  if (remove_mask & REMOVE_SITE_USAGE_DATA || remove_mask & REMOVE_HISTORY) {\n    ClearSettingsForOneTypeWithPredicate(\n        HostContentSettingsMapFactory::GetForProfile(profile_),\n        CONTENT_SETTINGS_TYPE_APP_BANNER,\n        base::Bind(&ForwardPrimaryPatternCallback, same_pattern_filter));\n  }\n\n  if (remove_mask & REMOVE_PASSWORDS) {\n    content::RecordAction(UserMetricsAction(\"ClearBrowsingData_Passwords\"));\n    password_manager::PasswordStore* password_store =\n        PasswordStoreFactory::GetForProfile(\n            profile_, ServiceAccessType::EXPLICIT_ACCESS).get();\n\n    if (password_store) {\n      waiting_for_clear_passwords_ = true;\n      auto on_cleared_passwords =\n          base::Bind(&BrowsingDataRemover::OnClearedPasswords,\n                     weak_ptr_factory_.GetWeakPtr());\n      password_store->RemoveLoginsByURLAndTime(\n          filter, delete_begin_, delete_end_, on_cleared_passwords);\n    }\n  }\n\n  if (remove_mask & REMOVE_COOKIES) {\n    password_manager::PasswordStore* password_store =\n        PasswordStoreFactory::GetForProfile(profile_,\n                                            ServiceAccessType::EXPLICIT_ACCESS)\n            .get();\n\n    if (password_store) {\n      waiting_for_clear_auto_sign_in_ = true;\n      base::Closure on_cleared_auto_sign_in =\n          base::Bind(&BrowsingDataRemover::OnClearedAutoSignIn,\n                     weak_ptr_factory_.GetWeakPtr());\n      password_store->DisableAutoSignInForAllLogins(on_cleared_auto_sign_in);\n    }\n  }\n\n  if (remove_mask & REMOVE_HISTORY) {\n    password_manager::PasswordStore* password_store =\n        PasswordStoreFactory::GetForProfile(\n            profile_, ServiceAccessType::EXPLICIT_ACCESS).get();\n\n    if (password_store) {\n      waiting_for_clear_passwords_stats_ = true;\n      password_store->RemoveStatisticsCreatedBetween(\n          delete_begin_, delete_end_,\n          base::Bind(&BrowsingDataRemover::OnClearedPasswordsStats,\n                     weak_ptr_factory_.GetWeakPtr()));\n    }\n  }\n\n  // TODO(dmurph): Support all backends with filter (crbug.com/113621).\n  if (remove_mask & REMOVE_FORM_DATA) {\n    content::RecordAction(UserMetricsAction(\"ClearBrowsingData_Autofill\"));\n    scoped_refptr<autofill::AutofillWebDataService> web_data_service =\n        WebDataServiceFactory::GetAutofillWebDataForProfile(\n            profile_, ServiceAccessType::EXPLICIT_ACCESS);\n\n    if (web_data_service.get()) {\n      waiting_for_clear_form_ = true;\n      web_data_service->RemoveFormElementsAddedBetween(delete_begin_,\n          delete_end_);\n      web_data_service->RemoveAutofillDataModifiedBetween(\n          delete_begin_, delete_end_);\n      // The above calls are done on the UI thread but do their work on the DB\n      // thread. So wait for it.\n      BrowserThread::PostTaskAndReply(\n          BrowserThread::DB, FROM_HERE, base::Bind(&base::DoNothing),\n          base::Bind(&BrowsingDataRemover::OnClearedFormData,\n                     weak_ptr_factory_.GetWeakPtr()));\n\n      autofill::PersonalDataManager* data_manager =\n          autofill::PersonalDataManagerFactory::GetForProfile(profile_);\n      if (data_manager)\n        data_manager->Refresh();\n    }\n  }\n\n  if (remove_mask & REMOVE_CACHE) {\n    // Tell the renderers to clear their cache.\n    web_cache::WebCacheManager::GetInstance()->ClearCache();\n\n    content::RecordAction(UserMetricsAction(\"ClearBrowsingData_Cache\"));\n\n    waiting_for_clear_cache_ = true;\n    // StoragePartitionHttpCacheDataRemover deletes itself when it is done.\n    browsing_data::StoragePartitionHttpCacheDataRemover::CreateForRange(\n        BrowserContext::GetDefaultStoragePartition(profile_), delete_begin_,\n        delete_end_)\n        ->Remove(base::Bind(&BrowsingDataRemover::ClearedCache,\n                            weak_ptr_factory_.GetWeakPtr()));\n\n#if !defined(DISABLE_NACL)\n    waiting_for_clear_nacl_cache_ = true;\n\n    BrowserThread::PostTask(\n        BrowserThread::IO, FROM_HERE,\n        base::Bind(&ClearNaClCacheOnIOThread,\n                   UIThreadTrampoline(\n                       base::Bind(&BrowsingDataRemover::ClearedNaClCache,\n                                  weak_ptr_factory_.GetWeakPtr()))));\n\n    waiting_for_clear_pnacl_cache_ = true;\n    BrowserThread::PostTask(\n        BrowserThread::IO, FROM_HERE,\n        base::Bind(&ClearPnaclCacheOnIOThread, delete_begin_, delete_end_,\n                   UIThreadTrampoline(\n                       base::Bind(&BrowsingDataRemover::ClearedPnaclCache,\n                                  weak_ptr_factory_.GetWeakPtr()))));\n#endif\n\n    // The PrerenderManager may have a page actively being prerendered, which\n    // is essentially a preemptively cached page.\n    prerender::PrerenderManager* prerender_manager =\n        prerender::PrerenderManagerFactory::GetForProfile(profile_);\n    if (prerender_manager) {\n      prerender_manager->ClearData(\n          prerender::PrerenderManager::CLEAR_PRERENDER_CONTENTS);\n    }\n\n    // Tell the shader disk cache to clear.\n    content::RecordAction(UserMetricsAction(\"ClearBrowsingData_ShaderCache\"));\n    storage_partition_remove_mask |=\n        content::StoragePartition::REMOVE_DATA_MASK_SHADER_CACHE;\n\n    storage_partition_remove_mask |=\n        content::StoragePartition::REMOVE_DATA_MASK_WEBRTC_IDENTITY;\n  }\n\n  if (remove_mask & REMOVE_WEBRTC_IDENTITY) {\n    storage_partition_remove_mask |=\n        content::StoragePartition::REMOVE_DATA_MASK_WEBRTC_IDENTITY;\n  }\n\n  if (storage_partition_remove_mask) {\n    waiting_for_clear_storage_partition_data_ = true;\n\n    content::StoragePartition* storage_partition;\n    if (storage_partition_for_testing_)\n      storage_partition = storage_partition_for_testing_;\n    else\n      storage_partition = BrowserContext::GetDefaultStoragePartition(profile_);\n\n    uint32_t quota_storage_remove_mask =\n        ~content::StoragePartition::QUOTA_MANAGED_STORAGE_MASK_PERSISTENT;\n\n    if (delete_begin_ == base::Time() ||\n        origin_type_mask_ &\n          (BrowsingDataHelper::PROTECTED_WEB | BrowsingDataHelper::EXTENSION)) {\n      // If we're deleting since the beginning of time, or we're removing\n      // protected origins, then remove persistent quota data.\n      quota_storage_remove_mask |=\n          content::StoragePartition::QUOTA_MANAGED_STORAGE_MASK_PERSISTENT;\n    }\n\n    content::StoragePartition::CookieMatcherFunction cookie_matcher;\n    if (!filter_builder.IsEmptyBlacklist()) {\n      cookie_matcher = filter_builder.BuildCookieFilter();\n    }\n    storage_partition->ClearData(\n        storage_partition_remove_mask, quota_storage_remove_mask,\n        base::Bind(&DoesOriginMatchMaskAndUrls, origin_type_mask_, filter),\n        cookie_matcher, delete_begin_, delete_end_,\n        base::Bind(&BrowsingDataRemover::OnClearedStoragePartitionData,\n                   weak_ptr_factory_.GetWeakPtr()));\n  }\n\n#if defined(ENABLE_PLUGINS)\n  if (remove_mask & REMOVE_CONTENT_LICENSES) {\n    content::RecordAction(\n        UserMetricsAction(\"ClearBrowsingData_ContentLicenses\"));\n\n    waiting_for_clear_content_licenses_ = true;\n    if (!pepper_flash_settings_manager_.get()) {\n      pepper_flash_settings_manager_.reset(\n          new PepperFlashSettingsManager(this, profile_));\n    }\n    deauthorize_content_licenses_request_id_ =\n        pepper_flash_settings_manager_->DeauthorizeContentLicenses(prefs);\n#if defined(OS_CHROMEOS)\n    // On Chrome OS, also delete any content protection platform keys.\n    const user_manager::User* user =\n        chromeos::ProfileHelper::Get()->GetUserByProfile(profile_);\n    if (!user) {\n      LOG(WARNING) << \"Failed to find user for current profile.\";\n    } else {\n      chromeos::DBusThreadManager::Get()\n          ->GetCryptohomeClient()\n          ->TpmAttestationDeleteKeys(\n              chromeos::attestation::KEY_USER,\n              cryptohome::Identification(user->GetAccountId()),\n              chromeos::attestation::kContentProtectionKeyPrefix,\n              base::Bind(&BrowsingDataRemover::OnClearPlatformKeys,\n                         weak_ptr_factory_.GetWeakPtr()));\n      waiting_for_clear_platform_keys_ = true;\n    }\n#endif\n  }\n#endif\n\n  // Remove omnibox zero-suggest cache results.\n  if ((remove_mask & (REMOVE_CACHE | REMOVE_COOKIES)))\n    prefs->SetString(omnibox::kZeroSuggestCachedResults, std::string());\n\n  // Always wipe accumulated network related data (TransportSecurityState and\n  // HttpServerPropertiesManager data).\n  waiting_for_clear_networking_history_ = true;\n  profile_->ClearNetworkingHistorySince(\n      delete_begin_,\n      base::Bind(&BrowsingDataRemover::OnClearedNetworkingHistory,\n                 weak_ptr_factory_.GetWeakPtr()));\n\n  if (remove_mask & (REMOVE_COOKIES | REMOVE_HISTORY)) {\n    domain_reliability::DomainReliabilityService* service =\n      domain_reliability::DomainReliabilityServiceFactory::\n          GetForBrowserContext(profile_);\n    if (service) {\n      domain_reliability::DomainReliabilityClearMode mode;\n      if (remove_mask & REMOVE_COOKIES)\n        mode = domain_reliability::CLEAR_CONTEXTS;\n      else\n        mode = domain_reliability::CLEAR_BEACONS;\n\n      waiting_for_clear_domain_reliability_monitor_ = true;\n      service->ClearBrowsingData(\n          mode,\n          base::Bind(&BrowsingDataRemover::OnClearedDomainReliabilityMonitor,\n                     weak_ptr_factory_.GetWeakPtr()));\n    }\n  }\n\n#if BUILDFLAG(ANDROID_JAVA_UI)\n  if (remove_mask & REMOVE_WEBAPP_DATA) {\n    // Clear all data associated with registered webapps. The webapp_registry\n    // makes a JNI call into a Java-side AsyncTask, so don't wait for the reply.\n    waiting_for_clear_webapp_data_ = true;\n    webapp_registry_->UnregisterWebapps(\n        base::Bind(&BrowsingDataRemover::OnClearedWebappData,\n                   weak_ptr_factory_.GetWeakPtr()));\n  }\n\n  if ((remove_mask & REMOVE_OFFLINE_PAGE_DATA) &&\n      offline_pages::IsOfflinePagesEnabled()) {\n    waiting_for_clear_offline_page_data_ = true;\n    offline_pages::OfflinePageModelFactory::GetForBrowserContext(profile_)\n        ->DeletePagesByURLPredicate(\n            filter,\n            base::Bind(&BrowsingDataRemover::OnClearedOfflinePageData,\n                       weak_ptr_factory_.GetWeakPtr()));\n  }\n#endif\n\n  // Record the combined deletion of cookies and cache.\n  CookieOrCacheDeletionChoice choice = NEITHER_COOKIES_NOR_CACHE;\n  if (remove_mask & REMOVE_COOKIES &&\n      origin_type_mask_ & BrowsingDataHelper::UNPROTECTED_WEB) {\n    choice = remove_mask & REMOVE_CACHE ? BOTH_COOKIES_AND_CACHE\n                                        : ONLY_COOKIES;\n  } else if (remove_mask & REMOVE_CACHE) {\n    choice = ONLY_CACHE;\n  }\n\n  UMA_HISTOGRAM_ENUMERATION(\n      \"History.ClearBrowsingData.UserDeletedCookieOrCache\",\n      choice, MAX_CHOICE_VALUE);\n}",
        "func": "void BrowsingDataRemover::RemoveImpl(\n    const TimeRange& time_range,\n    int remove_mask,\n    const BrowsingDataFilterBuilder& filter_builder,\n    int origin_type_mask) {\n  DCHECK_CURRENTLY_ON(BrowserThread::UI);\n\n  // crbug.com/140910: Many places were calling this with base::Time() as\n  // delete_end, even though they should've used base::Time::Max().\n  DCHECK_NE(base::Time(), time_range.end);\n\n  SetRemoving(true);\n  delete_begin_ = time_range.begin;\n  delete_end_ = time_range.end;\n  remove_mask_ = remove_mask;\n  origin_type_mask_ = origin_type_mask;\n\n  base::Callback<bool(const GURL& url)> filter =\n      filter_builder.BuildGeneralFilter();\n  base::Callback<bool(const ContentSettingsPattern& url)> same_pattern_filter =\n      filter_builder.BuildWebsiteSettingsPatternMatchesFilter();\n\n  PrefService* prefs = profile_->GetPrefs();\n  bool may_delete_history = prefs->GetBoolean(\n      prefs::kAllowDeletingBrowserHistory);\n\n  // All the UI entry points into the BrowsingDataRemover should be disabled,\n  // but this will fire if something was missed or added.\n  DCHECK(may_delete_history || (remove_mask & REMOVE_NOCHECKS) ||\n      (!(remove_mask & REMOVE_HISTORY) && !(remove_mask & REMOVE_DOWNLOADS)));\n\n  if (origin_type_mask_ & BrowsingDataHelper::UNPROTECTED_WEB) {\n    content::RecordAction(\n        UserMetricsAction(\"ClearBrowsingData_MaskContainsUnprotectedWeb\"));\n  }\n  if (origin_type_mask_ & BrowsingDataHelper::PROTECTED_WEB) {\n    content::RecordAction(\n        UserMetricsAction(\"ClearBrowsingData_MaskContainsProtectedWeb\"));\n  }\n  if (origin_type_mask_ & BrowsingDataHelper::EXTENSION) {\n    content::RecordAction(\n        UserMetricsAction(\"ClearBrowsingData_MaskContainsExtension\"));\n  }\n  // If this fires, we added a new BrowsingDataHelper::OriginTypeMask without\n  // updating the user metrics above.\n  static_assert(\n      BrowsingDataHelper::ALL == (BrowsingDataHelper::UNPROTECTED_WEB |\n                                  BrowsingDataHelper::PROTECTED_WEB |\n                                  BrowsingDataHelper::EXTENSION),\n      \"OriginTypeMask has been updated without updating user metrics\");\n\n  if ((remove_mask & REMOVE_HISTORY) && may_delete_history) {\n    history::HistoryService* history_service =\n        HistoryServiceFactory::GetForProfile(\n            profile_, ServiceAccessType::EXPLICIT_ACCESS);\n    if (history_service) {\n      // TODO(dmurph): Support all backends with filter (crbug.com/113621).\n      content::RecordAction(UserMetricsAction(\"ClearBrowsingData_History\"));\n      waiting_for_clear_history_ = true;\n      history_service->ExpireLocalAndRemoteHistoryBetween(\n          WebHistoryServiceFactory::GetForProfile(profile_), std::set<GURL>(),\n          delete_begin_, delete_end_,\n          base::Bind(&BrowsingDataRemover::OnHistoryDeletionDone,\n                     weak_ptr_factory_.GetWeakPtr()),\n          &history_task_tracker_);\n\n#if defined(ENABLE_EXTENSIONS)\n      // The extension activity contains details of which websites extensions\n      // were active on. It therefore indirectly stores details of websites a\n      // user has visited so best clean from here as well.\n      extensions::ActivityLog::GetInstance(profile_)->RemoveURLs(\n          std::set<GURL>());\n#endif\n    }\n\n#if defined(ENABLE_EXTENSIONS)\n    // Clear launch times as they are a form of history.\n    extensions::ExtensionPrefs* extension_prefs =\n        extensions::ExtensionPrefs::Get(profile_);\n    extension_prefs->ClearLastLaunchTimes();\n#endif\n\n    // The power consumption history by origin contains details of websites\n    // that were visited.\n    // TODO(dmurph): Support all backends with filter (crbug.com/113621).\n    power::OriginPowerMap* origin_power_map =\n        power::OriginPowerMapFactory::GetForBrowserContext(profile_);\n    if (origin_power_map)\n      origin_power_map->ClearOriginMap();\n\n    // Need to clear the host cache and accumulated speculative data, as it also\n    // reveals some history: we have no mechanism to track when these items were\n    // created, so we'll clear them all. Better safe than sorry.\n    if (g_browser_process->io_thread()) {\n      // TODO(dmurph): Support all backends with filter (crbug.com/113621).\n      waiting_for_clear_hostname_resolution_cache_ = true;\n      BrowserThread::PostTaskAndReply(\n          BrowserThread::IO, FROM_HERE,\n          base::Bind(&ClearHostnameResolutionCacheOnIOThread,\n                     g_browser_process->io_thread()),\n          base::Bind(&BrowsingDataRemover::OnClearedHostnameResolutionCache,\n                     weak_ptr_factory_.GetWeakPtr()));\n    }\n    if (profile_->GetNetworkPredictor()) {\n      // TODO(dmurph): Support all backends with filter (crbug.com/113621).\n      waiting_for_clear_network_predictor_ = true;\n      BrowserThread::PostTaskAndReply(\n          BrowserThread::IO, FROM_HERE,\n          base::Bind(&ClearNetworkPredictorOnIOThread,\n                     profile_->GetNetworkPredictor()),\n          base::Bind(&BrowsingDataRemover::OnClearedNetworkPredictor,\n                     weak_ptr_factory_.GetWeakPtr()));\n    }\n\n    // As part of history deletion we also delete the auto-generated keywords.\n    TemplateURLService* keywords_model =\n        TemplateURLServiceFactory::GetForProfile(profile_);\n\n    if (keywords_model && !keywords_model->loaded()) {\n      template_url_sub_ = keywords_model->RegisterOnLoadedCallback(\n          base::Bind(&BrowsingDataRemover::OnKeywordsLoaded,\n                     weak_ptr_factory_.GetWeakPtr()));\n      keywords_model->Load();\n      waiting_for_clear_keyword_data_ = true;\n    } else if (keywords_model) {\n      // TODO(dmurph): Support all backends with filter (crbug.com/113621).\n      keywords_model->RemoveAutoGeneratedForOriginBetween(GURL(), delete_begin_,\n                                                          delete_end_);\n    }\n\n    // The PrerenderManager keeps history of prerendered pages, so clear that.\n    // It also may have a prerendered page. If so, the page could be\n    // considered to have a small amount of historical information, so delete\n    // it, too.\n    prerender::PrerenderManager* prerender_manager =\n        prerender::PrerenderManagerFactory::GetForProfile(profile_);\n    if (prerender_manager) {\n      // TODO(dmurph): Support all backends with filter (crbug.com/113621).\n      prerender_manager->ClearData(\n          prerender::PrerenderManager::CLEAR_PRERENDER_CONTENTS |\n          prerender::PrerenderManager::CLEAR_PRERENDER_HISTORY);\n    }\n\n    // If the caller is removing history for all hosts, then clear ancillary\n    // historical information.\n    if (filter_builder.IsEmptyBlacklist()) {\n      // We also delete the list of recently closed tabs. Since these expire,\n      // they can't be more than a day old, so we can simply clear them all.\n      sessions::TabRestoreService* tab_service =\n          TabRestoreServiceFactory::GetForProfile(profile_);\n      if (tab_service) {\n        tab_service->ClearEntries();\n        tab_service->DeleteLastSession();\n      }\n\n#if defined(ENABLE_SESSION_SERVICE)\n      // We also delete the last session when we delete the history.\n      SessionService* session_service =\n          SessionServiceFactory::GetForProfile(profile_);\n      if (session_service)\n        session_service->DeleteLastSession();\n#endif\n    }\n\n    // The saved Autofill profiles and credit cards can include the origin from\n    // which these profiles and credit cards were learned.  These are a form of\n    // history, so clear them as well.\n    // TODO(dmurph): Support all backends with filter (crbug.com/113621).\n    scoped_refptr<autofill::AutofillWebDataService> web_data_service =\n        WebDataServiceFactory::GetAutofillWebDataForProfile(\n            profile_, ServiceAccessType::EXPLICIT_ACCESS);\n    if (web_data_service.get()) {\n      waiting_for_clear_autofill_origin_urls_ = true;\n      web_data_service->RemoveOriginURLsModifiedBetween(\n          delete_begin_, delete_end_);\n      // The above calls are done on the UI thread but do their work on the DB\n      // thread. So wait for it.\n      BrowserThread::PostTaskAndReply(\n          BrowserThread::DB, FROM_HERE, base::Bind(&base::DoNothing),\n          base::Bind(&BrowsingDataRemover::OnClearedAutofillOriginURLs,\n                     weak_ptr_factory_.GetWeakPtr()));\n\n      autofill::PersonalDataManager* data_manager =\n          autofill::PersonalDataManagerFactory::GetForProfile(profile_);\n      if (data_manager)\n        data_manager->Refresh();\n    }\n\n#if defined(ENABLE_WEBRTC)\n    waiting_for_clear_webrtc_logs_ = true;\n    BrowserThread::PostTaskAndReply(\n        BrowserThread::FILE, FROM_HERE,\n        base::Bind(\n            &WebRtcLogUtil::DeleteOldAndRecentWebRtcLogFiles,\n            WebRtcLogList::GetWebRtcLogDirectoryForProfile(profile_->GetPath()),\n            delete_begin_),\n        base::Bind(&BrowsingDataRemover::OnClearedWebRtcLogs,\n                   weak_ptr_factory_.GetWeakPtr()));\n#endif\n\n    // The SSL Host State that tracks SSL interstitial \"proceed\" decisions may\n    // include origins that the user has visited, so it must be cleared.\n    if (profile_->GetSSLHostStateDelegate())\n      profile_->GetSSLHostStateDelegate()->Clear();\n\n#if BUILDFLAG(ANDROID_JAVA_UI)\n    precache::PrecacheManager* precache_manager =\n        precache::PrecacheManagerFactory::GetForBrowserContext(profile_);\n    // |precache_manager| could be nullptr if the profile is off the record.\n    if (!precache_manager) {\n      waiting_for_clear_precache_history_ = true;\n      precache_manager->ClearHistory();\n      // The above calls are done on the UI thread but do their work on the DB\n      // thread. So wait for it.\n      BrowserThread::PostTaskAndReply(\n          BrowserThread::DB, FROM_HERE, base::Bind(&base::DoNothing),\n          base::Bind(&BrowsingDataRemover::OnClearedPrecacheHistory,\n                     weak_ptr_factory_.GetWeakPtr()));\n    }\n\n    // Clear the history information (last launch time and origin URL) of any\n    // registered webapps. The webapp_registry makes a JNI call into a Java-side\n    // AsyncTask, so don't wait for the reply.\n    waiting_for_clear_webapp_history_ = true;\n    webapp_registry_->ClearWebappHistory(\n        base::Bind(&BrowsingDataRemover::OnClearedWebappHistory,\n          weak_ptr_factory_.GetWeakPtr()));\n#endif\n\n    data_reduction_proxy::DataReductionProxySettings*\n        data_reduction_proxy_settings =\n            DataReductionProxyChromeSettingsFactory::GetForBrowserContext(\n                profile_);\n    // |data_reduction_proxy_settings| is null if |profile_| is off the record.\n    if (data_reduction_proxy_settings) {\n      data_reduction_proxy::DataReductionProxyService*\n          data_reduction_proxy_service =\n              data_reduction_proxy_settings->data_reduction_proxy_service();\n      if (data_reduction_proxy_service) {\n        data_reduction_proxy_service->compression_stats()\n            ->DeleteBrowsingHistory(delete_begin_, delete_end_);\n      }\n    }\n  }\n\n  if ((remove_mask & REMOVE_DOWNLOADS) && may_delete_history) {\n    content::RecordAction(UserMetricsAction(\"ClearBrowsingData_Downloads\"));\n    content::DownloadManager* download_manager =\n        BrowserContext::GetDownloadManager(profile_);\n    download_manager->RemoveDownloadsByURLAndTime(filter,\n                                                  delete_begin_, delete_end_);\n    DownloadPrefs* download_prefs = DownloadPrefs::FromDownloadManager(\n        download_manager);\n    download_prefs->SetSaveFilePath(download_prefs->DownloadPath());\n  }\n\n  uint32_t storage_partition_remove_mask = 0;\n\n  // We ignore the REMOVE_COOKIES request if UNPROTECTED_WEB is not set,\n  // so that callers who request REMOVE_SITE_DATA with PROTECTED_WEB\n  // don't accidentally remove the cookies that are associated with the\n  // UNPROTECTED_WEB origin. This is necessary because cookies are not separated\n  // between UNPROTECTED_WEB and PROTECTED_WEB.\n  if (remove_mask & REMOVE_COOKIES &&\n      origin_type_mask_ & BrowsingDataHelper::UNPROTECTED_WEB) {\n    content::RecordAction(UserMetricsAction(\"ClearBrowsingData_Cookies\"));\n\n    storage_partition_remove_mask |=\n        content::StoragePartition::REMOVE_DATA_MASK_COOKIES;\n\n    // Clear the safebrowsing cookies only if time period is for \"all time\".  It\n    // doesn't make sense to apply the time period of deleting in the last X\n    // hours/days to the safebrowsing cookies since they aren't the result of\n    // any user action.\n    if (delete_begin_ == base::Time()) {\n      safe_browsing::SafeBrowsingService* sb_service =\n          g_browser_process->safe_browsing_service();\n      if (sb_service) {\n        scoped_refptr<net::URLRequestContextGetter> sb_context =\n            sb_service->url_request_context();\n        ++waiting_for_clear_cookies_count_;\n        if (filter_builder.IsEmptyBlacklist()) {\n          BrowserThread::PostTask(\n              BrowserThread::IO, FROM_HERE,\n              base::Bind(&ClearCookiesOnIOThread, delete_begin_, delete_end_,\n                         base::RetainedRef(std::move(sb_context)),\n                         UIThreadTrampoline(\n                             base::Bind(&BrowsingDataRemover::OnClearedCookies,\n                                        weak_ptr_factory_.GetWeakPtr()))));\n        } else {\n          BrowserThread::PostTask(\n              BrowserThread::IO, FROM_HERE,\n              base::Bind(&ClearCookiesWithPredicateOnIOThread, delete_begin_,\n                         delete_end_, filter_builder.BuildCookieFilter(),\n                         base::RetainedRef(std::move(sb_context)),\n                         UIThreadTrampoline(\n                             base::Bind(&BrowsingDataRemover::OnClearedCookies,\n                                        weak_ptr_factory_.GetWeakPtr()))));\n        }\n      }\n    }\n\n    MediaDeviceIDSalt::Reset(profile_->GetPrefs());\n  }\n\n  // Channel IDs are not separated for protected and unprotected web\n  // origins. We check the origin_type_mask_ to prevent unintended deletion.\n  if (remove_mask & REMOVE_CHANNEL_IDS &&\n      origin_type_mask_ & BrowsingDataHelper::UNPROTECTED_WEB) {\n    content::RecordAction(\n        UserMetricsAction(\"ClearBrowsingData_ChannelIDs\"));\n    // Since we are running on the UI thread don't call GetURLRequestContext().\n    scoped_refptr<net::URLRequestContextGetter> rq_context =\n        content::BrowserContext::GetDefaultStoragePartition(profile_)->\n          GetURLRequestContext();\n    waiting_for_clear_channel_ids_ = true;\n    BrowserThread::PostTask(\n        BrowserThread::IO, FROM_HERE,\n        base::Bind(&ClearChannelIDsOnIOThread,\n                   filter_builder.BuildChannelIDFilter(),\n                   delete_begin_, delete_end_, std::move(rq_context),\n                   base::Bind(&BrowsingDataRemover::OnClearedChannelIDs,\n                              weak_ptr_factory_.GetWeakPtr())));\n  }\n\n  if (remove_mask & REMOVE_LOCAL_STORAGE) {\n    storage_partition_remove_mask |=\n        content::StoragePartition::REMOVE_DATA_MASK_LOCAL_STORAGE;\n  }\n\n  if (remove_mask & REMOVE_INDEXEDDB) {\n    storage_partition_remove_mask |=\n        content::StoragePartition::REMOVE_DATA_MASK_INDEXEDDB;\n  }\n  if (remove_mask & REMOVE_WEBSQL) {\n    storage_partition_remove_mask |=\n        content::StoragePartition::REMOVE_DATA_MASK_WEBSQL;\n  }\n  if (remove_mask & REMOVE_APPCACHE) {\n    storage_partition_remove_mask |=\n        content::StoragePartition::REMOVE_DATA_MASK_APPCACHE;\n  }\n  if (remove_mask & REMOVE_SERVICE_WORKERS) {\n    storage_partition_remove_mask |=\n        content::StoragePartition::REMOVE_DATA_MASK_SERVICE_WORKERS;\n  }\n  if (remove_mask & REMOVE_CACHE_STORAGE) {\n    storage_partition_remove_mask |=\n        content::StoragePartition::REMOVE_DATA_MASK_CACHE_STORAGE;\n  }\n  if (remove_mask & REMOVE_FILE_SYSTEMS) {\n    storage_partition_remove_mask |=\n        content::StoragePartition::REMOVE_DATA_MASK_FILE_SYSTEMS;\n  }\n\n#if defined(ENABLE_PLUGINS)\n  // Plugin is data not separated for protected and unprotected web origins. We\n  // check the origin_type_mask_ to prevent unintended deletion.\n  if (remove_mask & REMOVE_PLUGIN_DATA &&\n      origin_type_mask_ & BrowsingDataHelper::UNPROTECTED_WEB) {\n    content::RecordAction(UserMetricsAction(\"ClearBrowsingData_LSOData\"));\n\n    waiting_for_clear_plugin_data_ = true;\n    DCHECK(!plugin_data_remover_);\n    plugin_data_remover_.reset(content::PluginDataRemover::Create(profile_));\n    base::WaitableEvent* event =\n        plugin_data_remover_->StartRemoving(delete_begin_);\n\n    base::WaitableEventWatcher::EventCallback watcher_callback =\n        base::Bind(&BrowsingDataRemover::OnWaitableEventSignaled,\n                   weak_ptr_factory_.GetWeakPtr());\n    watcher_.StartWatching(event, watcher_callback);\n  }\n#endif\n\n  if (remove_mask & REMOVE_SITE_USAGE_DATA) {\n    ClearSettingsForOneTypeWithPredicate(\n        HostContentSettingsMapFactory::GetForProfile(profile_),\n        CONTENT_SETTINGS_TYPE_SITE_ENGAGEMENT,\n        base::Bind(&ForwardPrimaryPatternCallback, same_pattern_filter));\n  }\n\n  if (remove_mask & REMOVE_SITE_USAGE_DATA || remove_mask & REMOVE_HISTORY) {\n    ClearSettingsForOneTypeWithPredicate(\n        HostContentSettingsMapFactory::GetForProfile(profile_),\n        CONTENT_SETTINGS_TYPE_APP_BANNER,\n        base::Bind(&ForwardPrimaryPatternCallback, same_pattern_filter));\n  }\n\n  if (remove_mask & REMOVE_PASSWORDS) {\n    content::RecordAction(UserMetricsAction(\"ClearBrowsingData_Passwords\"));\n    password_manager::PasswordStore* password_store =\n        PasswordStoreFactory::GetForProfile(\n            profile_, ServiceAccessType::EXPLICIT_ACCESS).get();\n\n    if (password_store) {\n      waiting_for_clear_passwords_ = true;\n      auto on_cleared_passwords =\n          base::Bind(&BrowsingDataRemover::OnClearedPasswords,\n                     weak_ptr_factory_.GetWeakPtr());\n      password_store->RemoveLoginsByURLAndTime(\n          filter, delete_begin_, delete_end_, on_cleared_passwords);\n    }\n  }\n\n  if (remove_mask & REMOVE_COOKIES) {\n    password_manager::PasswordStore* password_store =\n        PasswordStoreFactory::GetForProfile(profile_,\n                                            ServiceAccessType::EXPLICIT_ACCESS)\n            .get();\n\n    if (password_store) {\n      waiting_for_clear_auto_sign_in_ = true;\n      base::Closure on_cleared_auto_sign_in =\n          base::Bind(&BrowsingDataRemover::OnClearedAutoSignIn,\n                     weak_ptr_factory_.GetWeakPtr());\n      password_store->DisableAutoSignInForAllLogins(on_cleared_auto_sign_in);\n    }\n  }\n\n  if (remove_mask & REMOVE_HISTORY) {\n    password_manager::PasswordStore* password_store =\n        PasswordStoreFactory::GetForProfile(\n            profile_, ServiceAccessType::EXPLICIT_ACCESS).get();\n\n    if (password_store) {\n      waiting_for_clear_passwords_stats_ = true;\n      password_store->RemoveStatisticsCreatedBetween(\n          delete_begin_, delete_end_,\n          base::Bind(&BrowsingDataRemover::OnClearedPasswordsStats,\n                     weak_ptr_factory_.GetWeakPtr()));\n    }\n  }\n\n  // TODO(dmurph): Support all backends with filter (crbug.com/113621).\n  if (remove_mask & REMOVE_FORM_DATA) {\n    content::RecordAction(UserMetricsAction(\"ClearBrowsingData_Autofill\"));\n    scoped_refptr<autofill::AutofillWebDataService> web_data_service =\n        WebDataServiceFactory::GetAutofillWebDataForProfile(\n            profile_, ServiceAccessType::EXPLICIT_ACCESS);\n\n    if (web_data_service.get()) {\n      waiting_for_clear_form_ = true;\n      web_data_service->RemoveFormElementsAddedBetween(delete_begin_,\n          delete_end_);\n      web_data_service->RemoveAutofillDataModifiedBetween(\n          delete_begin_, delete_end_);\n      // The above calls are done on the UI thread but do their work on the DB\n      // thread. So wait for it.\n      BrowserThread::PostTaskAndReply(\n          BrowserThread::DB, FROM_HERE, base::Bind(&base::DoNothing),\n          base::Bind(&BrowsingDataRemover::OnClearedFormData,\n                     weak_ptr_factory_.GetWeakPtr()));\n\n      autofill::PersonalDataManager* data_manager =\n          autofill::PersonalDataManagerFactory::GetForProfile(profile_);\n      if (data_manager)\n        data_manager->Refresh();\n    }\n  }\n\n  if (remove_mask & REMOVE_CACHE) {\n    // Tell the renderers to clear their cache.\n    web_cache::WebCacheManager::GetInstance()->ClearCache();\n\n    content::RecordAction(UserMetricsAction(\"ClearBrowsingData_Cache\"));\n\n    waiting_for_clear_cache_ = true;\n    // StoragePartitionHttpCacheDataRemover deletes itself when it is done.\n    browsing_data::StoragePartitionHttpCacheDataRemover::CreateForRange(\n        BrowserContext::GetDefaultStoragePartition(profile_), delete_begin_,\n        delete_end_)\n        ->Remove(base::Bind(&BrowsingDataRemover::ClearedCache,\n                            weak_ptr_factory_.GetWeakPtr()));\n\n#if !defined(DISABLE_NACL)\n    waiting_for_clear_nacl_cache_ = true;\n\n    BrowserThread::PostTask(\n        BrowserThread::IO, FROM_HERE,\n        base::Bind(&ClearNaClCacheOnIOThread,\n                   UIThreadTrampoline(\n                       base::Bind(&BrowsingDataRemover::ClearedNaClCache,\n                                  weak_ptr_factory_.GetWeakPtr()))));\n\n    waiting_for_clear_pnacl_cache_ = true;\n    BrowserThread::PostTask(\n        BrowserThread::IO, FROM_HERE,\n        base::Bind(&ClearPnaclCacheOnIOThread, delete_begin_, delete_end_,\n                   UIThreadTrampoline(\n                       base::Bind(&BrowsingDataRemover::ClearedPnaclCache,\n                                  weak_ptr_factory_.GetWeakPtr()))));\n#endif\n\n    // The PrerenderManager may have a page actively being prerendered, which\n    // is essentially a preemptively cached page.\n    prerender::PrerenderManager* prerender_manager =\n        prerender::PrerenderManagerFactory::GetForProfile(profile_);\n    if (prerender_manager) {\n      prerender_manager->ClearData(\n          prerender::PrerenderManager::CLEAR_PRERENDER_CONTENTS);\n    }\n\n    // Tell the shader disk cache to clear.\n    content::RecordAction(UserMetricsAction(\"ClearBrowsingData_ShaderCache\"));\n    storage_partition_remove_mask |=\n        content::StoragePartition::REMOVE_DATA_MASK_SHADER_CACHE;\n\n    storage_partition_remove_mask |=\n        content::StoragePartition::REMOVE_DATA_MASK_WEBRTC_IDENTITY;\n\n    // When clearing cache, wipe accumulated network related data\n    // (TransportSecurityState and HttpServerPropertiesManager data).\n    waiting_for_clear_networking_history_ = true;\n    profile_->ClearNetworkingHistorySince(\n        delete_begin_,\n        base::Bind(&BrowsingDataRemover::OnClearedNetworkingHistory,\n                   weak_ptr_factory_.GetWeakPtr()));\n  }\n\n  if (remove_mask & REMOVE_WEBRTC_IDENTITY) {\n    storage_partition_remove_mask |=\n        content::StoragePartition::REMOVE_DATA_MASK_WEBRTC_IDENTITY;\n  }\n\n  if (storage_partition_remove_mask) {\n    waiting_for_clear_storage_partition_data_ = true;\n\n    content::StoragePartition* storage_partition;\n    if (storage_partition_for_testing_)\n      storage_partition = storage_partition_for_testing_;\n    else\n      storage_partition = BrowserContext::GetDefaultStoragePartition(profile_);\n\n    uint32_t quota_storage_remove_mask =\n        ~content::StoragePartition::QUOTA_MANAGED_STORAGE_MASK_PERSISTENT;\n\n    if (delete_begin_ == base::Time() ||\n        origin_type_mask_ &\n          (BrowsingDataHelper::PROTECTED_WEB | BrowsingDataHelper::EXTENSION)) {\n      // If we're deleting since the beginning of time, or we're removing\n      // protected origins, then remove persistent quota data.\n      quota_storage_remove_mask |=\n          content::StoragePartition::QUOTA_MANAGED_STORAGE_MASK_PERSISTENT;\n    }\n\n    content::StoragePartition::CookieMatcherFunction cookie_matcher;\n    if (!filter_builder.IsEmptyBlacklist()) {\n      cookie_matcher = filter_builder.BuildCookieFilter();\n    }\n    storage_partition->ClearData(\n        storage_partition_remove_mask, quota_storage_remove_mask,\n        base::Bind(&DoesOriginMatchMaskAndUrls, origin_type_mask_, filter),\n        cookie_matcher, delete_begin_, delete_end_,\n        base::Bind(&BrowsingDataRemover::OnClearedStoragePartitionData,\n                   weak_ptr_factory_.GetWeakPtr()));\n  }\n\n#if defined(ENABLE_PLUGINS)\n  if (remove_mask & REMOVE_CONTENT_LICENSES) {\n    content::RecordAction(\n        UserMetricsAction(\"ClearBrowsingData_ContentLicenses\"));\n\n    waiting_for_clear_content_licenses_ = true;\n    if (!pepper_flash_settings_manager_.get()) {\n      pepper_flash_settings_manager_.reset(\n          new PepperFlashSettingsManager(this, profile_));\n    }\n    deauthorize_content_licenses_request_id_ =\n        pepper_flash_settings_manager_->DeauthorizeContentLicenses(prefs);\n#if defined(OS_CHROMEOS)\n    // On Chrome OS, also delete any content protection platform keys.\n    const user_manager::User* user =\n        chromeos::ProfileHelper::Get()->GetUserByProfile(profile_);\n    if (!user) {\n      LOG(WARNING) << \"Failed to find user for current profile.\";\n    } else {\n      chromeos::DBusThreadManager::Get()\n          ->GetCryptohomeClient()\n          ->TpmAttestationDeleteKeys(\n              chromeos::attestation::KEY_USER,\n              cryptohome::Identification(user->GetAccountId()),\n              chromeos::attestation::kContentProtectionKeyPrefix,\n              base::Bind(&BrowsingDataRemover::OnClearPlatformKeys,\n                         weak_ptr_factory_.GetWeakPtr()));\n      waiting_for_clear_platform_keys_ = true;\n    }\n#endif\n  }\n#endif\n\n  // Remove omnibox zero-suggest cache results.\n  if ((remove_mask & (REMOVE_CACHE | REMOVE_COOKIES)))\n    prefs->SetString(omnibox::kZeroSuggestCachedResults, std::string());\n\n  if (remove_mask & (REMOVE_COOKIES | REMOVE_HISTORY)) {\n    domain_reliability::DomainReliabilityService* service =\n      domain_reliability::DomainReliabilityServiceFactory::\n          GetForBrowserContext(profile_);\n    if (service) {\n      domain_reliability::DomainReliabilityClearMode mode;\n      if (remove_mask & REMOVE_COOKIES)\n        mode = domain_reliability::CLEAR_CONTEXTS;\n      else\n        mode = domain_reliability::CLEAR_BEACONS;\n\n      waiting_for_clear_domain_reliability_monitor_ = true;\n      service->ClearBrowsingData(\n          mode,\n          base::Bind(&BrowsingDataRemover::OnClearedDomainReliabilityMonitor,\n                     weak_ptr_factory_.GetWeakPtr()));\n    }\n  }\n\n#if BUILDFLAG(ANDROID_JAVA_UI)\n  if (remove_mask & REMOVE_WEBAPP_DATA) {\n    // Clear all data associated with registered webapps. The webapp_registry\n    // makes a JNI call into a Java-side AsyncTask, so don't wait for the reply.\n    waiting_for_clear_webapp_data_ = true;\n    webapp_registry_->UnregisterWebapps(\n        base::Bind(&BrowsingDataRemover::OnClearedWebappData,\n                   weak_ptr_factory_.GetWeakPtr()));\n  }\n\n  if ((remove_mask & REMOVE_OFFLINE_PAGE_DATA) &&\n      offline_pages::IsOfflinePagesEnabled()) {\n    waiting_for_clear_offline_page_data_ = true;\n    offline_pages::OfflinePageModelFactory::GetForBrowserContext(profile_)\n        ->DeletePagesByURLPredicate(\n            filter,\n            base::Bind(&BrowsingDataRemover::OnClearedOfflinePageData,\n                       weak_ptr_factory_.GetWeakPtr()));\n  }\n#endif\n\n  // Record the combined deletion of cookies and cache.\n  CookieOrCacheDeletionChoice choice = NEITHER_COOKIES_NOR_CACHE;\n  if (remove_mask & REMOVE_COOKIES &&\n      origin_type_mask_ & BrowsingDataHelper::UNPROTECTED_WEB) {\n    choice = remove_mask & REMOVE_CACHE ? BOTH_COOKIES_AND_CACHE\n                                        : ONLY_COOKIES;\n  } else if (remove_mask & REMOVE_CACHE) {\n    choice = ONLY_CACHE;\n  }\n\n  // Notify in case all actions taken were synchronous.\n  NotifyIfDone();\n\n  UMA_HISTOGRAM_ENUMERATION(\n      \"History.ClearBrowsingData.UserDeletedCookieOrCache\",\n      choice, MAX_CHOICE_VALUE);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -508,6 +508,14 @@\n \n     storage_partition_remove_mask |=\n         content::StoragePartition::REMOVE_DATA_MASK_WEBRTC_IDENTITY;\n+\n+    // When clearing cache, wipe accumulated network related data\n+    // (TransportSecurityState and HttpServerPropertiesManager data).\n+    waiting_for_clear_networking_history_ = true;\n+    profile_->ClearNetworkingHistorySince(\n+        delete_begin_,\n+        base::Bind(&BrowsingDataRemover::OnClearedNetworkingHistory,\n+                   weak_ptr_factory_.GetWeakPtr()));\n   }\n \n   if (remove_mask & REMOVE_WEBRTC_IDENTITY) {\n@@ -585,14 +593,6 @@\n   if ((remove_mask & (REMOVE_CACHE | REMOVE_COOKIES)))\n     prefs->SetString(omnibox::kZeroSuggestCachedResults, std::string());\n \n-  // Always wipe accumulated network related data (TransportSecurityState and\n-  // HttpServerPropertiesManager data).\n-  waiting_for_clear_networking_history_ = true;\n-  profile_->ClearNetworkingHistorySince(\n-      delete_begin_,\n-      base::Bind(&BrowsingDataRemover::OnClearedNetworkingHistory,\n-                 weak_ptr_factory_.GetWeakPtr()));\n-\n   if (remove_mask & (REMOVE_COOKIES | REMOVE_HISTORY)) {\n     domain_reliability::DomainReliabilityService* service =\n       domain_reliability::DomainReliabilityServiceFactory::\n@@ -643,6 +643,9 @@\n     choice = ONLY_CACHE;\n   }\n \n+  // Notify in case all actions taken were synchronous.\n+  NotifyIfDone();\n+\n   UMA_HISTOGRAM_ENUMERATION(\n       \"History.ClearBrowsingData.UserDeletedCookieOrCache\",\n       choice, MAX_CHOICE_VALUE);",
        "diff_line_info": {
            "deleted_lines": [
                "  // Always wipe accumulated network related data (TransportSecurityState and",
                "  // HttpServerPropertiesManager data).",
                "  waiting_for_clear_networking_history_ = true;",
                "  profile_->ClearNetworkingHistorySince(",
                "      delete_begin_,",
                "      base::Bind(&BrowsingDataRemover::OnClearedNetworkingHistory,",
                "                 weak_ptr_factory_.GetWeakPtr()));",
                ""
            ],
            "added_lines": [
                "",
                "    // When clearing cache, wipe accumulated network related data",
                "    // (TransportSecurityState and HttpServerPropertiesManager data).",
                "    waiting_for_clear_networking_history_ = true;",
                "    profile_->ClearNetworkingHistorySince(",
                "        delete_begin_,",
                "        base::Bind(&BrowsingDataRemover::OnClearedNetworkingHistory,",
                "                   weak_ptr_factory_.GetWeakPtr()));",
                "  // Notify in case all actions taken were synchronous.",
                "  NotifyIfDone();",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2016-1696",
        "func_name": "chromium/RuntimeCustomBindings::RuntimeCustomBindings",
        "description": "The extensions subsystem in Google Chrome before 51.0.2704.79 does not properly restrict bindings access, which allows remote attackers to bypass the Same Origin Policy via unspecified vectors.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/c0569cc04741cccf6548c2169fcc1609d958523f",
        "commit_title": "[Extensions] Expand bindings access checks",
        "commit_text": "   ",
        "func_before": "RuntimeCustomBindings::RuntimeCustomBindings(ScriptContext* context)\n    : ObjectBackedNativeHandler(context) {\n  RouteFunction(\n      \"GetManifest\",\n      base::Bind(&RuntimeCustomBindings::GetManifest, base::Unretained(this)));\n  RouteFunction(\"OpenChannelToExtension\",\n                base::Bind(&RuntimeCustomBindings::OpenChannelToExtension,\n                           base::Unretained(this)));\n  RouteFunction(\"OpenChannelToNativeApp\",\n                base::Bind(&RuntimeCustomBindings::OpenChannelToNativeApp,\n                           base::Unretained(this)));\n  RouteFunction(\"GetExtensionViews\",\n                base::Bind(&RuntimeCustomBindings::GetExtensionViews,\n                           base::Unretained(this)));\n}",
        "func": "RuntimeCustomBindings::RuntimeCustomBindings(ScriptContext* context)\n    : ObjectBackedNativeHandler(context) {\n  RouteFunction(\n      \"GetManifest\",\n      base::Bind(&RuntimeCustomBindings::GetManifest, base::Unretained(this)));\n  RouteFunction(\"OpenChannelToExtension\", \"runtime.connect\",\n                base::Bind(&RuntimeCustomBindings::OpenChannelToExtension,\n                           base::Unretained(this)));\n  RouteFunction(\"OpenChannelToNativeApp\", \"runtime.connectNative\",\n                base::Bind(&RuntimeCustomBindings::OpenChannelToNativeApp,\n                           base::Unretained(this)));\n  RouteFunction(\"GetExtensionViews\",\n                base::Bind(&RuntimeCustomBindings::GetExtensionViews,\n                           base::Unretained(this)));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,10 +3,10 @@\n   RouteFunction(\n       \"GetManifest\",\n       base::Bind(&RuntimeCustomBindings::GetManifest, base::Unretained(this)));\n-  RouteFunction(\"OpenChannelToExtension\",\n+  RouteFunction(\"OpenChannelToExtension\", \"runtime.connect\",\n                 base::Bind(&RuntimeCustomBindings::OpenChannelToExtension,\n                            base::Unretained(this)));\n-  RouteFunction(\"OpenChannelToNativeApp\",\n+  RouteFunction(\"OpenChannelToNativeApp\", \"runtime.connectNative\",\n                 base::Bind(&RuntimeCustomBindings::OpenChannelToNativeApp,\n                            base::Unretained(this)));\n   RouteFunction(\"GetExtensionViews\",",
        "diff_line_info": {
            "deleted_lines": [
                "  RouteFunction(\"OpenChannelToExtension\",",
                "  RouteFunction(\"OpenChannelToNativeApp\","
            ],
            "added_lines": [
                "  RouteFunction(\"OpenChannelToExtension\", \"runtime.connect\",",
                "  RouteFunction(\"OpenChannelToNativeApp\", \"runtime.connectNative\","
            ]
        }
    },
    {
        "cve_id": "CVE-2016-1696",
        "func_name": "chromium/WebstoreBindings::WebstoreBindings",
        "description": "The extensions subsystem in Google Chrome before 51.0.2704.79 does not properly restrict bindings access, which allows remote attackers to bypass the Same Origin Policy via unspecified vectors.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/c0569cc04741cccf6548c2169fcc1609d958523f",
        "commit_title": "[Extensions] Expand bindings access checks",
        "commit_text": "   ",
        "func_before": "WebstoreBindings::WebstoreBindings(ScriptContext* context)\n    : ObjectBackedNativeHandler(context) {\n  RouteFunction(\"Install\",\n                base::Bind(&WebstoreBindings::Install, base::Unretained(this)));\n}",
        "func": "WebstoreBindings::WebstoreBindings(ScriptContext* context)\n    : ObjectBackedNativeHandler(context) {\n  RouteFunction(\"Install\", \"webstore\",\n                base::Bind(&WebstoreBindings::Install, base::Unretained(this)));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,5 @@\n WebstoreBindings::WebstoreBindings(ScriptContext* context)\n     : ObjectBackedNativeHandler(context) {\n-  RouteFunction(\"Install\",\n+  RouteFunction(\"Install\", \"webstore\",\n                 base::Bind(&WebstoreBindings::Install, base::Unretained(this)));\n }",
        "diff_line_info": {
            "deleted_lines": [
                "  RouteFunction(\"Install\","
            ],
            "added_lines": [
                "  RouteFunction(\"Install\", \"webstore\","
            ]
        }
    },
    {
        "cve_id": "CVE-2016-1696",
        "func_name": "chromium/ObjectBackedNativeHandler::Router",
        "description": "The extensions subsystem in Google Chrome before 51.0.2704.79 does not properly restrict bindings access, which allows remote attackers to bypass the Same Origin Policy via unspecified vectors.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/c0569cc04741cccf6548c2169fcc1609d958523f",
        "commit_title": "[Extensions] Expand bindings access checks",
        "commit_text": "   ",
        "func_before": "void ObjectBackedNativeHandler::Router(\n    const v8::FunctionCallbackInfo<v8::Value>& args) {\n  v8::Isolate* isolate = args.GetIsolate();\n  v8::HandleScope handle_scope(isolate);\n  v8::Local<v8::Object> data = args.Data().As<v8::Object>();\n  v8::Local<v8::Context> context = isolate->GetCurrentContext();\n\n  v8::Local<v8::Value> handler_function_value;\n  v8::Local<v8::Value> feature_name_value;\n  // See comment in header file for why we do this.\n  if (!GetPrivate(context, data, kHandlerFunction, &handler_function_value) ||\n      handler_function_value->IsUndefined() ||\n      !GetPrivate(context, data, kFeatureName, &feature_name_value) ||\n      !feature_name_value->IsString()) {\n    ScriptContext* script_context =\n        ScriptContextSet::GetContextByV8Context(context);\n    console::Error(script_context ? script_context->GetRenderFrame() : nullptr,\n                   \"Extension view no longer exists\");\n    return;\n  }\n\n  // We can't access the ScriptContextSet on a worker thread. Luckily, we also\n  // don't inject many bindings into worker threads.\n  // TODO(devlin): Figure out a way around this.\n  if (content::WorkerThread::GetCurrentId() == 0) {\n    ScriptContext* script_context =\n        ScriptContextSet::GetContextByV8Context(context);\n    v8::Local<v8::String> feature_name_string =\n        feature_name_value->ToString(context).ToLocalChecked();\n    std::string feature_name = *v8::String::Utf8Value(feature_name_string);\n    // TODO(devlin): Eventually, we should fail if either script_context is null\n    // or feature_name is empty.\n    if (script_context &&\n        !feature_name.empty() &&\n        !script_context->GetAvailability(feature_name).is_available()) {\n      return;\n    }\n  }\n  // This CHECK is *important*. Otherwise, we'll go around happily executing\n  // something random.  See crbug.com/548273.\n  CHECK(handler_function_value->IsExternal());\n  static_cast<HandlerFunction*>(\n      handler_function_value.As<v8::External>()->Value())->Run(args);\n\n  // Verify that the return value, if any, is accessible by the context.\n  v8::ReturnValue<v8::Value> ret = args.GetReturnValue();\n  v8::Local<v8::Value> ret_value = ret.Get();\n  if (ret_value->IsObject() && !ret_value->IsNull() &&\n      !ContextCanAccessObject(context, v8::Local<v8::Object>::Cast(ret_value),\n                              true)) {\n    NOTREACHED() << \"Insecure return value\";\n    ret.SetUndefined();\n  }\n}",
        "func": "void ObjectBackedNativeHandler::Router(\n    const v8::FunctionCallbackInfo<v8::Value>& args) {\n  v8::Isolate* isolate = args.GetIsolate();\n  v8::HandleScope handle_scope(isolate);\n  v8::Local<v8::Object> data = args.Data().As<v8::Object>();\n  v8::Local<v8::Context> context = isolate->GetCurrentContext();\n\n  v8::Local<v8::Value> handler_function_value;\n  v8::Local<v8::Value> feature_name_value;\n  // See comment in header file for why we do this.\n  if (!GetPrivate(context, data, kHandlerFunction, &handler_function_value) ||\n      handler_function_value->IsUndefined() ||\n      !GetPrivate(context, data, kFeatureName, &feature_name_value) ||\n      !feature_name_value->IsString()) {\n    ScriptContext* script_context =\n        ScriptContextSet::GetContextByV8Context(context);\n    console::Error(script_context ? script_context->GetRenderFrame() : nullptr,\n                   \"Extension view no longer exists\");\n    return;\n  }\n\n  // We can't access the ScriptContextSet on a worker thread. Luckily, we also\n  // don't inject many bindings into worker threads.\n  // TODO(devlin): Figure out a way around this.\n  if (content::WorkerThread::GetCurrentId() == 0) {\n    ScriptContext* script_context =\n        ScriptContextSet::GetContextByV8Context(context);\n    v8::Local<v8::String> feature_name_string =\n        feature_name_value->ToString(context).ToLocalChecked();\n    std::string feature_name = *v8::String::Utf8Value(feature_name_string);\n    // TODO(devlin): Eventually, we should fail if either script_context is null\n    // or feature_name is empty.\n    if (script_context && !feature_name.empty()) {\n      Feature::Availability availability =\n          script_context->GetAvailability(feature_name);\n      if (!availability.is_available()) {\n        DVLOG(1) << feature_name\n                 << \" is not available: \" << availability.message();\n        return;\n      }\n    }\n  }\n  // This CHECK is *important*. Otherwise, we'll go around happily executing\n  // something random.  See crbug.com/548273.\n  CHECK(handler_function_value->IsExternal());\n  static_cast<HandlerFunction*>(\n      handler_function_value.As<v8::External>()->Value())->Run(args);\n\n  // Verify that the return value, if any, is accessible by the context.\n  v8::ReturnValue<v8::Value> ret = args.GetReturnValue();\n  v8::Local<v8::Value> ret_value = ret.Get();\n  if (ret_value->IsObject() && !ret_value->IsNull() &&\n      !ContextCanAccessObject(context, v8::Local<v8::Object>::Cast(ret_value),\n                              true)) {\n    NOTREACHED() << \"Insecure return value\";\n    ret.SetUndefined();\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -30,10 +30,14 @@\n     std::string feature_name = *v8::String::Utf8Value(feature_name_string);\n     // TODO(devlin): Eventually, we should fail if either script_context is null\n     // or feature_name is empty.\n-    if (script_context &&\n-        !feature_name.empty() &&\n-        !script_context->GetAvailability(feature_name).is_available()) {\n-      return;\n+    if (script_context && !feature_name.empty()) {\n+      Feature::Availability availability =\n+          script_context->GetAvailability(feature_name);\n+      if (!availability.is_available()) {\n+        DVLOG(1) << feature_name\n+                 << \" is not available: \" << availability.message();\n+        return;\n+      }\n     }\n   }\n   // This CHECK is *important*. Otherwise, we'll go around happily executing",
        "diff_line_info": {
            "deleted_lines": [
                "    if (script_context &&",
                "        !feature_name.empty() &&",
                "        !script_context->GetAvailability(feature_name).is_available()) {",
                "      return;"
            ],
            "added_lines": [
                "    if (script_context && !feature_name.empty()) {",
                "      Feature::Availability availability =",
                "          script_context->GetAvailability(feature_name);",
                "      if (!availability.is_available()) {",
                "        DVLOG(1) << feature_name",
                "                 << \" is not available: \" << availability.message();",
                "        return;",
                "      }"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-1696",
        "func_name": "chromium/ChromeExtensionsDispatcherDelegate::RegisterNativeHandlers",
        "description": "The extensions subsystem in Google Chrome before 51.0.2704.79 does not properly restrict bindings access, which allows remote attackers to bypass the Same Origin Policy via unspecified vectors.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/c0569cc04741cccf6548c2169fcc1609d958523f",
        "commit_title": "[Extensions] Expand bindings access checks",
        "commit_text": "   ",
        "func_before": "void ChromeExtensionsDispatcherDelegate::RegisterNativeHandlers(\n    extensions::Dispatcher* dispatcher,\n    extensions::ModuleSystem* module_system,\n    extensions::ScriptContext* context) {\n  module_system->RegisterNativeHandler(\n      \"app\", std::unique_ptr<NativeHandler>(\n                 new extensions::AppBindings(dispatcher, context)));\n  module_system->RegisterNativeHandler(\n      \"sync_file_system\",\n      std::unique_ptr<NativeHandler>(\n          new extensions::SyncFileSystemCustomBindings(context)));\n  module_system->RegisterNativeHandler(\n      \"file_browser_handler\",\n      std::unique_ptr<NativeHandler>(\n          new extensions::FileBrowserHandlerCustomBindings(context)));\n  module_system->RegisterNativeHandler(\n      \"file_manager_private\",\n      std::unique_ptr<NativeHandler>(\n          new extensions::FileManagerPrivateCustomBindings(context)));\n  module_system->RegisterNativeHandler(\n      \"notifications_private\",\n      std::unique_ptr<NativeHandler>(\n          new extensions::NotificationsNativeHandler(context)));\n  module_system->RegisterNativeHandler(\n      \"mediaGalleries\",\n      std::unique_ptr<NativeHandler>(\n          new extensions::MediaGalleriesCustomBindings(context)));\n  module_system->RegisterNativeHandler(\n      \"page_capture\", std::unique_ptr<NativeHandler>(\n                          new extensions::PageCaptureCustomBindings(context)));\n  module_system->RegisterNativeHandler(\n      \"platform_keys_natives\",\n      std::unique_ptr<NativeHandler>(\n          new extensions::PlatformKeysNatives(context)));\n  module_system->RegisterNativeHandler(\n      \"tabs\", std::unique_ptr<NativeHandler>(\n                  new extensions::TabsCustomBindings(context)));\n  module_system->RegisterNativeHandler(\n      \"webstore\", std::unique_ptr<NativeHandler>(\n                      new extensions::WebstoreBindings(context)));\n#if defined(ENABLE_WEBRTC)\n  module_system->RegisterNativeHandler(\n      \"cast_streaming_natives\",\n      std::unique_ptr<NativeHandler>(\n          new extensions::CastStreamingNativeHandler(context)));\n#endif\n  module_system->RegisterNativeHandler(\n      \"automationInternal\",\n      std::unique_ptr<NativeHandler>(\n          new extensions::AutomationInternalCustomBindings(context)));\n}",
        "func": "void ChromeExtensionsDispatcherDelegate::RegisterNativeHandlers(\n    extensions::Dispatcher* dispatcher,\n    extensions::ModuleSystem* module_system,\n    extensions::ScriptContext* context) {\n  module_system->RegisterNativeHandler(\n      \"app\", std::unique_ptr<NativeHandler>(\n                 new extensions::AppBindings(dispatcher, context)));\n  module_system->RegisterNativeHandler(\n      \"sync_file_system\",\n      std::unique_ptr<NativeHandler>(\n          new extensions::SyncFileSystemCustomBindings(context)));\n  module_system->RegisterNativeHandler(\n      \"file_browser_handler\",\n      std::unique_ptr<NativeHandler>(\n          new extensions::FileBrowserHandlerCustomBindings(context)));\n  module_system->RegisterNativeHandler(\n      \"file_manager_private\",\n      std::unique_ptr<NativeHandler>(\n          new extensions::FileManagerPrivateCustomBindings(context)));\n  module_system->RegisterNativeHandler(\n      \"notifications_private\",\n      std::unique_ptr<NativeHandler>(\n          new extensions::NotificationsNativeHandler(context)));\n  module_system->RegisterNativeHandler(\n      \"mediaGalleries\",\n      std::unique_ptr<NativeHandler>(\n          new extensions::MediaGalleriesCustomBindings(context)));\n  module_system->RegisterNativeHandler(\n      \"page_capture\", std::unique_ptr<NativeHandler>(\n                          new extensions::PageCaptureCustomBindings(context)));\n  module_system->RegisterNativeHandler(\n      \"platform_keys_natives\",\n      std::unique_ptr<NativeHandler>(\n          new extensions::PlatformKeysNatives(context)));\n  module_system->RegisterNativeHandler(\n      \"tabs\", std::unique_ptr<NativeHandler>(\n                  new extensions::TabsCustomBindings(context)));\n  module_system->RegisterNativeHandler(\n      \"webstore\", std::unique_ptr<NativeHandler>(\n                      new extensions::WebstoreBindings(context)));\n#if defined(ENABLE_WEBRTC)\n  module_system->RegisterNativeHandler(\n      \"cast_streaming_natives\",\n      std::unique_ptr<NativeHandler>(\n          new extensions::CastStreamingNativeHandler(context)));\n#endif\n  module_system->RegisterNativeHandler(\n      \"automationInternal\",\n      std::unique_ptr<NativeHandler>(\n          new extensions::AutomationInternalCustomBindings(context)));\n\n  // The following are native handlers that are defined in //extensions, but\n  // are only used for APIs defined in Chrome.\n  // TODO(devlin): We should clean this up. If an API is defined in Chrome,\n  // there's no reason to have its native handlers residing and being compiled\n  // in //extensions.\n  module_system->RegisterNativeHandler(\n      \"i18n\",\n      scoped_ptr<NativeHandler>(new extensions::I18NCustomBindings(context)));\n  module_system->RegisterNativeHandler(\n      \"lazy_background_page\",\n      scoped_ptr<NativeHandler>(\n          new extensions::LazyBackgroundPageNativeHandler(context)));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -48,4 +48,17 @@\n       \"automationInternal\",\n       std::unique_ptr<NativeHandler>(\n           new extensions::AutomationInternalCustomBindings(context)));\n+\n+  // The following are native handlers that are defined in //extensions, but\n+  // are only used for APIs defined in Chrome.\n+  // TODO(devlin): We should clean this up. If an API is defined in Chrome,\n+  // there's no reason to have its native handlers residing and being compiled\n+  // in //extensions.\n+  module_system->RegisterNativeHandler(\n+      \"i18n\",\n+      scoped_ptr<NativeHandler>(new extensions::I18NCustomBindings(context)));\n+  module_system->RegisterNativeHandler(\n+      \"lazy_background_page\",\n+      scoped_ptr<NativeHandler>(\n+          new extensions::LazyBackgroundPageNativeHandler(context)));\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "  // The following are native handlers that are defined in //extensions, but",
                "  // are only used for APIs defined in Chrome.",
                "  // TODO(devlin): We should clean this up. If an API is defined in Chrome,",
                "  // there's no reason to have its native handlers residing and being compiled",
                "  // in //extensions.",
                "  module_system->RegisterNativeHandler(",
                "      \"i18n\",",
                "      scoped_ptr<NativeHandler>(new extensions::I18NCustomBindings(context)));",
                "  module_system->RegisterNativeHandler(",
                "      \"lazy_background_page\",",
                "      scoped_ptr<NativeHandler>(",
                "          new extensions::LazyBackgroundPageNativeHandler(context)));"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-1696",
        "func_name": "chromium/I18NCustomBindings::I18NCustomBindings",
        "description": "The extensions subsystem in Google Chrome before 51.0.2704.79 does not properly restrict bindings access, which allows remote attackers to bypass the Same Origin Policy via unspecified vectors.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/c0569cc04741cccf6548c2169fcc1609d958523f",
        "commit_title": "[Extensions] Expand bindings access checks",
        "commit_text": "   ",
        "func_before": "I18NCustomBindings::I18NCustomBindings(ScriptContext* context)\n    : ObjectBackedNativeHandler(context) {\n  RouteFunction(\n      \"GetL10nMessage\",\n      base::Bind(&I18NCustomBindings::GetL10nMessage, base::Unretained(this)));\n  RouteFunction(\"GetL10nUILanguage\",\n                base::Bind(&I18NCustomBindings::GetL10nUILanguage,\n                           base::Unretained(this)));\n  RouteFunction(\"DetectTextLanguage\",\n                base::Bind(&I18NCustomBindings::DetectTextLanguage,\n                           base::Unretained(this)));\n}",
        "func": "I18NCustomBindings::I18NCustomBindings(ScriptContext* context)\n    : ObjectBackedNativeHandler(context) {\n  RouteFunction(\n      \"GetL10nMessage\", \"i18n\",\n      base::Bind(&I18NCustomBindings::GetL10nMessage, base::Unretained(this)));\n  RouteFunction(\"GetL10nUILanguage\", \"i18n\",\n                base::Bind(&I18NCustomBindings::GetL10nUILanguage,\n                           base::Unretained(this)));\n  RouteFunction(\"DetectTextLanguage\", \"i18n\",\n                base::Bind(&I18NCustomBindings::DetectTextLanguage,\n                           base::Unretained(this)));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,12 +1,12 @@\n I18NCustomBindings::I18NCustomBindings(ScriptContext* context)\n     : ObjectBackedNativeHandler(context) {\n   RouteFunction(\n-      \"GetL10nMessage\",\n+      \"GetL10nMessage\", \"i18n\",\n       base::Bind(&I18NCustomBindings::GetL10nMessage, base::Unretained(this)));\n-  RouteFunction(\"GetL10nUILanguage\",\n+  RouteFunction(\"GetL10nUILanguage\", \"i18n\",\n                 base::Bind(&I18NCustomBindings::GetL10nUILanguage,\n                            base::Unretained(this)));\n-  RouteFunction(\"DetectTextLanguage\",\n+  RouteFunction(\"DetectTextLanguage\", \"i18n\",\n                 base::Bind(&I18NCustomBindings::DetectTextLanguage,\n                            base::Unretained(this)));\n }",
        "diff_line_info": {
            "deleted_lines": [
                "      \"GetL10nMessage\",",
                "  RouteFunction(\"GetL10nUILanguage\",",
                "  RouteFunction(\"DetectTextLanguage\","
            ],
            "added_lines": [
                "      \"GetL10nMessage\", \"i18n\",",
                "  RouteFunction(\"GetL10nUILanguage\", \"i18n\",",
                "  RouteFunction(\"DetectTextLanguage\", \"i18n\","
            ]
        }
    },
    {
        "cve_id": "CVE-2016-1696",
        "func_name": "chromium/DisplaySourceCustomBindings::DisplaySourceCustomBindings",
        "description": "The extensions subsystem in Google Chrome before 51.0.2704.79 does not properly restrict bindings access, which allows remote attackers to bypass the Same Origin Policy via unspecified vectors.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/c0569cc04741cccf6548c2169fcc1609d958523f",
        "commit_title": "[Extensions] Expand bindings access checks",
        "commit_text": "   ",
        "func_before": "DisplaySourceCustomBindings::DisplaySourceCustomBindings(ScriptContext* context)\n    : ObjectBackedNativeHandler(context),\n      weak_factory_(this) {\n  RouteFunction(\"StartSession\",\n                base::Bind(&DisplaySourceCustomBindings::StartSession,\n                           weak_factory_.GetWeakPtr()));\n  RouteFunction(\"TerminateSession\",\n                base::Bind(&DisplaySourceCustomBindings::TerminateSession,\n                           weak_factory_.GetWeakPtr()));\n}",
        "func": "DisplaySourceCustomBindings::DisplaySourceCustomBindings(ScriptContext* context)\n    : ObjectBackedNativeHandler(context),\n      weak_factory_(this) {\n  RouteFunction(\"StartSession\", \"displaySource\",\n                base::Bind(&DisplaySourceCustomBindings::StartSession,\n                           weak_factory_.GetWeakPtr()));\n  RouteFunction(\"TerminateSession\", \"displaySource\",\n                base::Bind(&DisplaySourceCustomBindings::TerminateSession,\n                           weak_factory_.GetWeakPtr()));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,10 +1,10 @@\n DisplaySourceCustomBindings::DisplaySourceCustomBindings(ScriptContext* context)\n     : ObjectBackedNativeHandler(context),\n       weak_factory_(this) {\n-  RouteFunction(\"StartSession\",\n+  RouteFunction(\"StartSession\", \"displaySource\",\n                 base::Bind(&DisplaySourceCustomBindings::StartSession,\n                            weak_factory_.GetWeakPtr()));\n-  RouteFunction(\"TerminateSession\",\n+  RouteFunction(\"TerminateSession\", \"displaySource\",\n                 base::Bind(&DisplaySourceCustomBindings::TerminateSession,\n                            weak_factory_.GetWeakPtr()));\n }",
        "diff_line_info": {
            "deleted_lines": [
                "  RouteFunction(\"StartSession\",",
                "  RouteFunction(\"TerminateSession\","
            ],
            "added_lines": [
                "  RouteFunction(\"StartSession\", \"displaySource\",",
                "  RouteFunction(\"TerminateSession\", \"displaySource\","
            ]
        }
    },
    {
        "cve_id": "CVE-2016-1696",
        "func_name": "chromium/ApiDefinitionsNatives::ApiDefinitionsNatives",
        "description": "The extensions subsystem in Google Chrome before 51.0.2704.79 does not properly restrict bindings access, which allows remote attackers to bypass the Same Origin Policy via unspecified vectors.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/c0569cc04741cccf6548c2169fcc1609d958523f",
        "commit_title": "[Extensions] Expand bindings access checks",
        "commit_text": "   ",
        "func_before": "ApiDefinitionsNatives::ApiDefinitionsNatives(Dispatcher* dispatcher,\n                                             ScriptContext* context)\n    : ObjectBackedNativeHandler(context), dispatcher_(dispatcher) {\n  RouteFunction(\n      \"GetExtensionAPIDefinitionsForTest\",\n      base::Bind(&ApiDefinitionsNatives::GetExtensionAPIDefinitionsForTest,\n                 base::Unretained(this)));\n}",
        "func": "ApiDefinitionsNatives::ApiDefinitionsNatives(Dispatcher* dispatcher,\n                                             ScriptContext* context)\n    : ObjectBackedNativeHandler(context), dispatcher_(dispatcher) {\n  RouteFunction(\n      \"GetExtensionAPIDefinitionsForTest\", \"test\",\n      base::Bind(&ApiDefinitionsNatives::GetExtensionAPIDefinitionsForTest,\n                 base::Unretained(this)));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,7 +2,7 @@\n                                              ScriptContext* context)\n     : ObjectBackedNativeHandler(context), dispatcher_(dispatcher) {\n   RouteFunction(\n-      \"GetExtensionAPIDefinitionsForTest\",\n+      \"GetExtensionAPIDefinitionsForTest\", \"test\",\n       base::Bind(&ApiDefinitionsNatives::GetExtensionAPIDefinitionsForTest,\n                  base::Unretained(this)));\n }",
        "diff_line_info": {
            "deleted_lines": [
                "      \"GetExtensionAPIDefinitionsForTest\","
            ],
            "added_lines": [
                "      \"GetExtensionAPIDefinitionsForTest\", \"test\","
            ]
        }
    },
    {
        "cve_id": "CVE-2016-1696",
        "func_name": "chromium/TabsCustomBindings::TabsCustomBindings",
        "description": "The extensions subsystem in Google Chrome before 51.0.2704.79 does not properly restrict bindings access, which allows remote attackers to bypass the Same Origin Policy via unspecified vectors.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/c0569cc04741cccf6548c2169fcc1609d958523f",
        "commit_title": "[Extensions] Expand bindings access checks",
        "commit_text": "   ",
        "func_before": "TabsCustomBindings::TabsCustomBindings(ScriptContext* context)\n    : ObjectBackedNativeHandler(context) {\n  RouteFunction(\"OpenChannelToTab\",\n      base::Bind(&TabsCustomBindings::OpenChannelToTab,\n                 base::Unretained(this)));\n}",
        "func": "TabsCustomBindings::TabsCustomBindings(ScriptContext* context)\n    : ObjectBackedNativeHandler(context) {\n  RouteFunction(\"OpenChannelToTab\", \"tabs\",\n                base::Bind(&TabsCustomBindings::OpenChannelToTab,\n                           base::Unretained(this)));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,6 @@\n TabsCustomBindings::TabsCustomBindings(ScriptContext* context)\n     : ObjectBackedNativeHandler(context) {\n-  RouteFunction(\"OpenChannelToTab\",\n-      base::Bind(&TabsCustomBindings::OpenChannelToTab,\n-                 base::Unretained(this)));\n+  RouteFunction(\"OpenChannelToTab\", \"tabs\",\n+                base::Bind(&TabsCustomBindings::OpenChannelToTab,\n+                           base::Unretained(this)));\n }",
        "diff_line_info": {
            "deleted_lines": [
                "  RouteFunction(\"OpenChannelToTab\",",
                "      base::Bind(&TabsCustomBindings::OpenChannelToTab,",
                "                 base::Unretained(this)));"
            ],
            "added_lines": [
                "  RouteFunction(\"OpenChannelToTab\", \"tabs\",",
                "                base::Bind(&TabsCustomBindings::OpenChannelToTab,",
                "                           base::Unretained(this)));"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-1696",
        "func_name": "chromium/V8ContextNativeHandler::V8ContextNativeHandler",
        "description": "The extensions subsystem in Google Chrome before 51.0.2704.79 does not properly restrict bindings access, which allows remote attackers to bypass the Same Origin Policy via unspecified vectors.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/c0569cc04741cccf6548c2169fcc1609d958523f",
        "commit_title": "[Extensions] Expand bindings access checks",
        "commit_text": "   ",
        "func_before": "V8ContextNativeHandler::V8ContextNativeHandler(ScriptContext* context)\n    : ObjectBackedNativeHandler(context), context_(context) {\n  RouteFunction(\"GetAvailability\",\n                base::Bind(&V8ContextNativeHandler::GetAvailability,\n                           base::Unretained(this)));\n  RouteFunction(\"GetModuleSystem\",\n                base::Bind(&V8ContextNativeHandler::GetModuleSystem,\n                           base::Unretained(this)));\n  RouteFunction(\n      \"RunWithNativesEnabled\",\n      base::Bind(&V8ContextNativeHandler::RunWithNativesEnabled,\n                 base::Unretained(this)));\n}",
        "func": "V8ContextNativeHandler::V8ContextNativeHandler(ScriptContext* context)\n    : ObjectBackedNativeHandler(context), context_(context) {\n  RouteFunction(\"GetAvailability\",\n                base::Bind(&V8ContextNativeHandler::GetAvailability,\n                           base::Unretained(this)));\n  RouteFunction(\"GetModuleSystem\",\n                base::Bind(&V8ContextNativeHandler::GetModuleSystem,\n                           base::Unretained(this)));\n  RouteFunction(\"RunWithNativesEnabled\", \"test\",\n                base::Bind(&V8ContextNativeHandler::RunWithNativesEnabled,\n                           base::Unretained(this)));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,8 +6,7 @@\n   RouteFunction(\"GetModuleSystem\",\n                 base::Bind(&V8ContextNativeHandler::GetModuleSystem,\n                            base::Unretained(this)));\n-  RouteFunction(\n-      \"RunWithNativesEnabled\",\n-      base::Bind(&V8ContextNativeHandler::RunWithNativesEnabled,\n-                 base::Unretained(this)));\n+  RouteFunction(\"RunWithNativesEnabled\", \"test\",\n+                base::Bind(&V8ContextNativeHandler::RunWithNativesEnabled,\n+                           base::Unretained(this)));\n }",
        "diff_line_info": {
            "deleted_lines": [
                "  RouteFunction(",
                "      \"RunWithNativesEnabled\",",
                "      base::Bind(&V8ContextNativeHandler::RunWithNativesEnabled,",
                "                 base::Unretained(this)));"
            ],
            "added_lines": [
                "  RouteFunction(\"RunWithNativesEnabled\", \"test\",",
                "                base::Bind(&V8ContextNativeHandler::RunWithNativesEnabled,",
                "                           base::Unretained(this)));"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-1696",
        "func_name": "chromium/LazyBackgroundPageNativeHandler::LazyBackgroundPageNativeHandler",
        "description": "The extensions subsystem in Google Chrome before 51.0.2704.79 does not properly restrict bindings access, which allows remote attackers to bypass the Same Origin Policy via unspecified vectors.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/c0569cc04741cccf6548c2169fcc1609d958523f",
        "commit_title": "[Extensions] Expand bindings access checks",
        "commit_text": "   ",
        "func_before": "LazyBackgroundPageNativeHandler::LazyBackgroundPageNativeHandler(\n    ScriptContext* context)\n    : ObjectBackedNativeHandler(context) {\n  RouteFunction(\n      \"IncrementKeepaliveCount\",\n      base::Bind(&LazyBackgroundPageNativeHandler::IncrementKeepaliveCount,\n                 base::Unretained(this)));\n  RouteFunction(\n      \"DecrementKeepaliveCount\",\n      base::Bind(&LazyBackgroundPageNativeHandler::DecrementKeepaliveCount,\n                 base::Unretained(this)));\n}",
        "func": "LazyBackgroundPageNativeHandler::LazyBackgroundPageNativeHandler(\n    ScriptContext* context)\n    : ObjectBackedNativeHandler(context) {\n  RouteFunction(\n      \"IncrementKeepaliveCount\", \"tts\",\n      base::Bind(&LazyBackgroundPageNativeHandler::IncrementKeepaliveCount,\n                 base::Unretained(this)));\n  RouteFunction(\n      \"DecrementKeepaliveCount\", \"tts\",\n      base::Bind(&LazyBackgroundPageNativeHandler::DecrementKeepaliveCount,\n                 base::Unretained(this)));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,11 +2,11 @@\n     ScriptContext* context)\n     : ObjectBackedNativeHandler(context) {\n   RouteFunction(\n-      \"IncrementKeepaliveCount\",\n+      \"IncrementKeepaliveCount\", \"tts\",\n       base::Bind(&LazyBackgroundPageNativeHandler::IncrementKeepaliveCount,\n                  base::Unretained(this)));\n   RouteFunction(\n-      \"DecrementKeepaliveCount\",\n+      \"DecrementKeepaliveCount\", \"tts\",\n       base::Bind(&LazyBackgroundPageNativeHandler::DecrementKeepaliveCount,\n                  base::Unretained(this)));\n }",
        "diff_line_info": {
            "deleted_lines": [
                "      \"IncrementKeepaliveCount\",",
                "      \"DecrementKeepaliveCount\","
            ],
            "added_lines": [
                "      \"IncrementKeepaliveCount\", \"tts\",",
                "      \"DecrementKeepaliveCount\", \"tts\","
            ]
        }
    },
    {
        "cve_id": "CVE-2016-1696",
        "func_name": "chromium/RenderFrameObserverNatives::RenderFrameObserverNatives",
        "description": "The extensions subsystem in Google Chrome before 51.0.2704.79 does not properly restrict bindings access, which allows remote attackers to bypass the Same Origin Policy via unspecified vectors.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/c0569cc04741cccf6548c2169fcc1609d958523f",
        "commit_title": "[Extensions] Expand bindings access checks",
        "commit_text": "   ",
        "func_before": "RenderFrameObserverNatives::RenderFrameObserverNatives(ScriptContext* context)\n    : ObjectBackedNativeHandler(context), weak_ptr_factory_(this) {\n  RouteFunction(\n      \"OnDocumentElementCreated\",\n      base::Bind(&RenderFrameObserverNatives::OnDocumentElementCreated,\n                 base::Unretained(this)));\n}",
        "func": "RenderFrameObserverNatives::RenderFrameObserverNatives(ScriptContext* context)\n    : ObjectBackedNativeHandler(context), weak_ptr_factory_(this) {\n  RouteFunction(\n      \"OnDocumentElementCreated\", \"app.window\",\n      base::Bind(&RenderFrameObserverNatives::OnDocumentElementCreated,\n                 base::Unretained(this)));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,7 +1,7 @@\n RenderFrameObserverNatives::RenderFrameObserverNatives(ScriptContext* context)\n     : ObjectBackedNativeHandler(context), weak_ptr_factory_(this) {\n   RouteFunction(\n-      \"OnDocumentElementCreated\",\n+      \"OnDocumentElementCreated\", \"app.window\",\n       base::Bind(&RenderFrameObserverNatives::OnDocumentElementCreated,\n                  base::Unretained(this)));\n }",
        "diff_line_info": {
            "deleted_lines": [
                "      \"OnDocumentElementCreated\","
            ],
            "added_lines": [
                "      \"OnDocumentElementCreated\", \"app.window\","
            ]
        }
    },
    {
        "cve_id": "CVE-2016-1696",
        "func_name": "chromium/Dispatcher::RegisterNativeHandlers",
        "description": "The extensions subsystem in Google Chrome before 51.0.2704.79 does not properly restrict bindings access, which allows remote attackers to bypass the Same Origin Policy via unspecified vectors.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/c0569cc04741cccf6548c2169fcc1609d958523f",
        "commit_title": "[Extensions] Expand bindings access checks",
        "commit_text": "   ",
        "func_before": "void Dispatcher::RegisterNativeHandlers(ModuleSystem* module_system,\n                                        ScriptContext* context,\n                                        Dispatcher* dispatcher,\n                                        RequestSender* request_sender,\n                                        V8SchemaRegistry* v8_schema_registry) {\n  module_system->RegisterNativeHandler(\n      \"chrome\", scoped_ptr<NativeHandler>(new ChromeNativeHandler(context)));\n  module_system->RegisterNativeHandler(\n      \"lazy_background_page\",\n      scoped_ptr<NativeHandler>(new LazyBackgroundPageNativeHandler(context)));\n  module_system->RegisterNativeHandler(\n      \"logging\", scoped_ptr<NativeHandler>(new LoggingNativeHandler(context)));\n  module_system->RegisterNativeHandler(\"schema_registry\",\n                                       v8_schema_registry->AsNativeHandler());\n  module_system->RegisterNativeHandler(\n      \"print\", scoped_ptr<NativeHandler>(new PrintNativeHandler(context)));\n  module_system->RegisterNativeHandler(\n      \"test_features\",\n      scoped_ptr<NativeHandler>(new TestFeaturesNativeHandler(context)));\n  module_system->RegisterNativeHandler(\n      \"test_native_handler\",\n      scoped_ptr<NativeHandler>(new TestNativeHandler(context)));\n  module_system->RegisterNativeHandler(\n      \"user_gestures\",\n      scoped_ptr<NativeHandler>(new UserGesturesNativeHandler(context)));\n  module_system->RegisterNativeHandler(\n      \"utils\", scoped_ptr<NativeHandler>(new UtilsNativeHandler(context)));\n  module_system->RegisterNativeHandler(\n      \"v8_context\",\n      scoped_ptr<NativeHandler>(new V8ContextNativeHandler(context)));\n  module_system->RegisterNativeHandler(\n      \"event_natives\", scoped_ptr<NativeHandler>(new EventBindings(context)));\n  module_system->RegisterNativeHandler(\n      \"messaging_natives\",\n      scoped_ptr<NativeHandler>(MessagingBindings::Get(dispatcher, context)));\n  module_system->RegisterNativeHandler(\n      \"apiDefinitions\",\n      scoped_ptr<NativeHandler>(\n          new ApiDefinitionsNatives(dispatcher, context)));\n  module_system->RegisterNativeHandler(\n      \"sendRequest\",\n      scoped_ptr<NativeHandler>(\n          new SendRequestNatives(request_sender, context)));\n  module_system->RegisterNativeHandler(\n      \"setIcon\",\n      scoped_ptr<NativeHandler>(new SetIconNatives(context)));\n  module_system->RegisterNativeHandler(\n      \"activityLogger\",\n      scoped_ptr<NativeHandler>(new APIActivityLogger(context)));\n  module_system->RegisterNativeHandler(\n      \"renderFrameObserverNatives\",\n      scoped_ptr<NativeHandler>(new RenderFrameObserverNatives(context)));\n\n  // Natives used by multiple APIs.\n  module_system->RegisterNativeHandler(\n      \"file_system_natives\",\n      scoped_ptr<NativeHandler>(new FileSystemNatives(context)));\n\n  // Custom bindings.\n  module_system->RegisterNativeHandler(\n      \"app_window_natives\",\n      scoped_ptr<NativeHandler>(new AppWindowCustomBindings(context)));\n  module_system->RegisterNativeHandler(\n      \"blob_natives\",\n      scoped_ptr<NativeHandler>(new BlobNativeHandler(context)));\n  module_system->RegisterNativeHandler(\n      \"context_menus\",\n      scoped_ptr<NativeHandler>(new ContextMenusCustomBindings(context)));\n  module_system->RegisterNativeHandler(\n      \"css_natives\", scoped_ptr<NativeHandler>(new CssNativeHandler(context)));\n  module_system->RegisterNativeHandler(\n      \"document_natives\",\n      scoped_ptr<NativeHandler>(new DocumentCustomBindings(context)));\n  module_system->RegisterNativeHandler(\n      \"guest_view_internal\",\n      scoped_ptr<NativeHandler>(\n          new GuestViewInternalCustomBindings(context)));\n  module_system->RegisterNativeHandler(\n      \"i18n\", scoped_ptr<NativeHandler>(new I18NCustomBindings(context)));\n  module_system->RegisterNativeHandler(\n      \"id_generator\",\n      scoped_ptr<NativeHandler>(new IdGeneratorCustomBindings(context)));\n  module_system->RegisterNativeHandler(\n      \"runtime\", scoped_ptr<NativeHandler>(new RuntimeCustomBindings(context)));\n  module_system->RegisterNativeHandler(\n      \"display_source\",\n      scoped_ptr<NativeHandler>(new DisplaySourceCustomBindings(context)));\n}",
        "func": "void Dispatcher::RegisterNativeHandlers(ModuleSystem* module_system,\n                                        ScriptContext* context,\n                                        Dispatcher* dispatcher,\n                                        RequestSender* request_sender,\n                                        V8SchemaRegistry* v8_schema_registry) {\n  module_system->RegisterNativeHandler(\n      \"chrome\", scoped_ptr<NativeHandler>(new ChromeNativeHandler(context)));\n  module_system->RegisterNativeHandler(\n      \"logging\", scoped_ptr<NativeHandler>(new LoggingNativeHandler(context)));\n  module_system->RegisterNativeHandler(\"schema_registry\",\n                                       v8_schema_registry->AsNativeHandler());\n  module_system->RegisterNativeHandler(\n      \"test_features\",\n      scoped_ptr<NativeHandler>(new TestFeaturesNativeHandler(context)));\n  module_system->RegisterNativeHandler(\n      \"test_native_handler\",\n      scoped_ptr<NativeHandler>(new TestNativeHandler(context)));\n  module_system->RegisterNativeHandler(\n      \"user_gestures\",\n      scoped_ptr<NativeHandler>(new UserGesturesNativeHandler(context)));\n  module_system->RegisterNativeHandler(\n      \"utils\", scoped_ptr<NativeHandler>(new UtilsNativeHandler(context)));\n  module_system->RegisterNativeHandler(\n      \"v8_context\",\n      scoped_ptr<NativeHandler>(new V8ContextNativeHandler(context)));\n  module_system->RegisterNativeHandler(\n      \"event_natives\", scoped_ptr<NativeHandler>(new EventBindings(context)));\n  module_system->RegisterNativeHandler(\n      \"messaging_natives\",\n      scoped_ptr<NativeHandler>(MessagingBindings::Get(dispatcher, context)));\n  module_system->RegisterNativeHandler(\n      \"apiDefinitions\",\n      scoped_ptr<NativeHandler>(\n          new ApiDefinitionsNatives(dispatcher, context)));\n  module_system->RegisterNativeHandler(\n      \"sendRequest\",\n      scoped_ptr<NativeHandler>(\n          new SendRequestNatives(request_sender, context)));\n  module_system->RegisterNativeHandler(\n      \"setIcon\",\n      scoped_ptr<NativeHandler>(new SetIconNatives(context)));\n  module_system->RegisterNativeHandler(\n      \"activityLogger\",\n      scoped_ptr<NativeHandler>(new APIActivityLogger(context)));\n  module_system->RegisterNativeHandler(\n      \"renderFrameObserverNatives\",\n      scoped_ptr<NativeHandler>(new RenderFrameObserverNatives(context)));\n\n  // Natives used by multiple APIs.\n  module_system->RegisterNativeHandler(\n      \"file_system_natives\",\n      scoped_ptr<NativeHandler>(new FileSystemNatives(context)));\n\n  // Custom bindings.\n  module_system->RegisterNativeHandler(\n      \"app_window_natives\",\n      scoped_ptr<NativeHandler>(new AppWindowCustomBindings(context)));\n  module_system->RegisterNativeHandler(\n      \"blob_natives\",\n      scoped_ptr<NativeHandler>(new BlobNativeHandler(context)));\n  module_system->RegisterNativeHandler(\n      \"context_menus\",\n      scoped_ptr<NativeHandler>(new ContextMenusCustomBindings(context)));\n  module_system->RegisterNativeHandler(\n      \"css_natives\", scoped_ptr<NativeHandler>(new CssNativeHandler(context)));\n  module_system->RegisterNativeHandler(\n      \"document_natives\",\n      scoped_ptr<NativeHandler>(new DocumentCustomBindings(context)));\n  module_system->RegisterNativeHandler(\n      \"guest_view_internal\",\n      scoped_ptr<NativeHandler>(\n          new GuestViewInternalCustomBindings(context)));\n  module_system->RegisterNativeHandler(\n      \"id_generator\",\n      scoped_ptr<NativeHandler>(new IdGeneratorCustomBindings(context)));\n  module_system->RegisterNativeHandler(\n      \"runtime\", scoped_ptr<NativeHandler>(new RuntimeCustomBindings(context)));\n  module_system->RegisterNativeHandler(\n      \"display_source\",\n      scoped_ptr<NativeHandler>(new DisplaySourceCustomBindings(context)));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,14 +6,9 @@\n   module_system->RegisterNativeHandler(\n       \"chrome\", scoped_ptr<NativeHandler>(new ChromeNativeHandler(context)));\n   module_system->RegisterNativeHandler(\n-      \"lazy_background_page\",\n-      scoped_ptr<NativeHandler>(new LazyBackgroundPageNativeHandler(context)));\n-  module_system->RegisterNativeHandler(\n       \"logging\", scoped_ptr<NativeHandler>(new LoggingNativeHandler(context)));\n   module_system->RegisterNativeHandler(\"schema_registry\",\n                                        v8_schema_registry->AsNativeHandler());\n-  module_system->RegisterNativeHandler(\n-      \"print\", scoped_ptr<NativeHandler>(new PrintNativeHandler(context)));\n   module_system->RegisterNativeHandler(\n       \"test_features\",\n       scoped_ptr<NativeHandler>(new TestFeaturesNativeHandler(context)));\n@@ -76,8 +71,6 @@\n       scoped_ptr<NativeHandler>(\n           new GuestViewInternalCustomBindings(context)));\n   module_system->RegisterNativeHandler(\n-      \"i18n\", scoped_ptr<NativeHandler>(new I18NCustomBindings(context)));\n-  module_system->RegisterNativeHandler(\n       \"id_generator\",\n       scoped_ptr<NativeHandler>(new IdGeneratorCustomBindings(context)));\n   module_system->RegisterNativeHandler(",
        "diff_line_info": {
            "deleted_lines": [
                "      \"lazy_background_page\",",
                "      scoped_ptr<NativeHandler>(new LazyBackgroundPageNativeHandler(context)));",
                "  module_system->RegisterNativeHandler(",
                "  module_system->RegisterNativeHandler(",
                "      \"print\", scoped_ptr<NativeHandler>(new PrintNativeHandler(context)));",
                "      \"i18n\", scoped_ptr<NativeHandler>(new I18NCustomBindings(context)));",
                "  module_system->RegisterNativeHandler("
            ],
            "added_lines": []
        }
    },
    {
        "cve_id": "CVE-2016-1697",
        "func_name": "chromium/FrameLoader::startLoad",
        "description": "The FrameLoader::startLoad function in WebKit/Source/core/loader/FrameLoader.cpp in Blink, as used in Google Chrome before 51.0.2704.79, does not prevent frame navigations during DocumentLoader detach operations, which allows remote attackers to bypass the Same Origin Policy via crafted JavaScript code.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/0a0e03cf8a52aab2ad2d1fe3bc0d3dcbe57911bd",
        "commit_title": "Disable frame navigations during DocumentLoader detach in FrameLoader::startLoad",
        "commit_text": "  Review-Url: https://codereview.chromium.org/2006033002 (cherry picked from commit 1948aefa8901dca0ccb993753fca00b15d2a6e25)   ",
        "func_before": "void FrameLoader::startLoad(FrameLoadRequest& frameLoadRequest, FrameLoadType type, NavigationPolicy navigationPolicy)\n{\n    ASSERT(client()->hasWebView());\n    if (m_frame->document()->pageDismissalEventBeingDispatched() != Document::NoDismissal)\n        return;\n\n    NavigationType navigationType = determineNavigationType(type, frameLoadRequest.resourceRequest().httpBody() || frameLoadRequest.form(), frameLoadRequest.triggeringEvent());\n    frameLoadRequest.resourceRequest().setRequestContext(determineRequestContextFromNavigationType(navigationType));\n    frameLoadRequest.resourceRequest().setFrameType(m_frame->isMainFrame() ? WebURLRequest::FrameTypeTopLevel : WebURLRequest::FrameTypeNested);\n    ResourceRequest& request = frameLoadRequest.resourceRequest();\n    if (!shouldContinueForNavigationPolicy(request, frameLoadRequest.substituteData(), nullptr, frameLoadRequest.shouldCheckMainWorldContentSecurityPolicy(), navigationType, navigationPolicy, type == FrameLoadTypeReplaceCurrentItem, frameLoadRequest.clientRedirect() == ClientRedirectPolicy::ClientRedirect))\n        return;\n    if (!shouldClose(navigationType == NavigationTypeReload))\n        return;\n\n    m_frame->document()->cancelParsing();\n    detachDocumentLoader(m_provisionalDocumentLoader);\n\n    // beforeunload fired above, and detaching a DocumentLoader can fire\n    // events, which can detach this frame.\n    if (!m_frame->host())\n        return;\n\n    m_provisionalDocumentLoader = client()->createDocumentLoader(m_frame, request, frameLoadRequest.substituteData().isValid() ? frameLoadRequest.substituteData() : defaultSubstituteDataForURL(request.url()));\n    m_provisionalDocumentLoader->setNavigationType(navigationType);\n    m_provisionalDocumentLoader->setReplacesCurrentHistoryItem(type == FrameLoadTypeReplaceCurrentItem);\n    m_provisionalDocumentLoader->setIsClientRedirect(frameLoadRequest.clientRedirect() == ClientRedirectPolicy::ClientRedirect);\n\n    InspectorInstrumentation::didStartProvisionalLoad(m_frame);\n\n    m_frame->navigationScheduler().cancel();\n    m_checkTimer.stop();\n\n    m_loadType = type;\n\n    if (frameLoadRequest.form())\n        client()->dispatchWillSubmitForm(frameLoadRequest.form());\n\n    m_progressTracker->progressStarted();\n    if (m_provisionalDocumentLoader->isClientRedirect())\n        m_provisionalDocumentLoader->appendRedirect(m_frame->document()->url());\n    m_provisionalDocumentLoader->appendRedirect(m_provisionalDocumentLoader->request().url());\n    double triggeringEventTime = frameLoadRequest.triggeringEvent() ? frameLoadRequest.triggeringEvent()->platformTimeStamp() : 0;\n    client()->dispatchDidStartProvisionalLoad(triggeringEventTime);\n    ASSERT(m_provisionalDocumentLoader);\n    m_provisionalDocumentLoader->startLoadingMainResource();\n}",
        "func": "void FrameLoader::startLoad(FrameLoadRequest& frameLoadRequest, FrameLoadType type, NavigationPolicy navigationPolicy)\n{\n    ASSERT(client()->hasWebView());\n    if (m_frame->document()->pageDismissalEventBeingDispatched() != Document::NoDismissal)\n        return;\n\n    NavigationType navigationType = determineNavigationType(type, frameLoadRequest.resourceRequest().httpBody() || frameLoadRequest.form(), frameLoadRequest.triggeringEvent());\n    frameLoadRequest.resourceRequest().setRequestContext(determineRequestContextFromNavigationType(navigationType));\n    frameLoadRequest.resourceRequest().setFrameType(m_frame->isMainFrame() ? WebURLRequest::FrameTypeTopLevel : WebURLRequest::FrameTypeNested);\n    ResourceRequest& request = frameLoadRequest.resourceRequest();\n    if (!shouldContinueForNavigationPolicy(request, frameLoadRequest.substituteData(), nullptr, frameLoadRequest.shouldCheckMainWorldContentSecurityPolicy(), navigationType, navigationPolicy, type == FrameLoadTypeReplaceCurrentItem, frameLoadRequest.clientRedirect() == ClientRedirectPolicy::ClientRedirect))\n        return;\n    if (!shouldClose(navigationType == NavigationTypeReload))\n        return;\n\n    m_frame->document()->cancelParsing();\n    if (m_provisionalDocumentLoader) {\n        FrameNavigationDisabler navigationDisabler(*m_frame);\n        detachDocumentLoader(m_provisionalDocumentLoader);\n    }\n\n    // beforeunload fired above, and detaching a DocumentLoader can fire\n    // events, which can detach this frame.\n    if (!m_frame->host())\n        return;\n\n    m_provisionalDocumentLoader = client()->createDocumentLoader(m_frame, request, frameLoadRequest.substituteData().isValid() ? frameLoadRequest.substituteData() : defaultSubstituteDataForURL(request.url()));\n    m_provisionalDocumentLoader->setNavigationType(navigationType);\n    m_provisionalDocumentLoader->setReplacesCurrentHistoryItem(type == FrameLoadTypeReplaceCurrentItem);\n    m_provisionalDocumentLoader->setIsClientRedirect(frameLoadRequest.clientRedirect() == ClientRedirectPolicy::ClientRedirect);\n\n    InspectorInstrumentation::didStartProvisionalLoad(m_frame);\n\n    m_frame->navigationScheduler().cancel();\n    m_checkTimer.stop();\n\n    m_loadType = type;\n\n    if (frameLoadRequest.form())\n        client()->dispatchWillSubmitForm(frameLoadRequest.form());\n\n    m_progressTracker->progressStarted();\n    if (m_provisionalDocumentLoader->isClientRedirect())\n        m_provisionalDocumentLoader->appendRedirect(m_frame->document()->url());\n    m_provisionalDocumentLoader->appendRedirect(m_provisionalDocumentLoader->request().url());\n    double triggeringEventTime = frameLoadRequest.triggeringEvent() ? frameLoadRequest.triggeringEvent()->platformTimeStamp() : 0;\n    client()->dispatchDidStartProvisionalLoad(triggeringEventTime);\n    ASSERT(m_provisionalDocumentLoader);\n    m_provisionalDocumentLoader->startLoadingMainResource();\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -14,7 +14,10 @@\n         return;\n \n     m_frame->document()->cancelParsing();\n-    detachDocumentLoader(m_provisionalDocumentLoader);\n+    if (m_provisionalDocumentLoader) {\n+        FrameNavigationDisabler navigationDisabler(*m_frame);\n+        detachDocumentLoader(m_provisionalDocumentLoader);\n+    }\n \n     // beforeunload fired above, and detaching a DocumentLoader can fire\n     // events, which can detach this frame.",
        "diff_line_info": {
            "deleted_lines": [
                "    detachDocumentLoader(m_provisionalDocumentLoader);"
            ],
            "added_lines": [
                "    if (m_provisionalDocumentLoader) {",
                "        FrameNavigationDisabler navigationDisabler(*m_frame);",
                "        detachDocumentLoader(m_provisionalDocumentLoader);",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-1697",
        "func_name": "chromium/HTMLAnchorElement::handleClick",
        "description": "The FrameLoader::startLoad function in WebKit/Source/core/loader/FrameLoader.cpp in Blink, as used in Google Chrome before 51.0.2704.79, does not prevent frame navigations during DocumentLoader detach operations, which allows remote attackers to bypass the Same Origin Policy via crafted JavaScript code.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/0a0e03cf8a52aab2ad2d1fe3bc0d3dcbe57911bd",
        "commit_title": "Disable frame navigations during DocumentLoader detach in FrameLoader::startLoad",
        "commit_text": "  Review-Url: https://codereview.chromium.org/2006033002 (cherry picked from commit 1948aefa8901dca0ccb993753fca00b15d2a6e25)   ",
        "func_before": "void HTMLAnchorElement::handleClick(Event* event)\n{\n    event->setDefaultHandled();\n\n    LocalFrame* frame = document().frame();\n    if (!frame)\n        return;\n\n    StringBuilder url;\n    url.append(stripLeadingAndTrailingHTMLSpaces(fastGetAttribute(hrefAttr)));\n    appendServerMapMousePosition(url, event);\n    KURL completedURL = document().completeURL(url.toString());\n\n    // Schedule the ping before the frame load. Prerender in Chrome may kill the renderer as soon as the navigation is\n    // sent out.\n    sendPings(completedURL);\n\n    ResourceRequest request(completedURL);\n    request.setUIStartTime(event->platformTimeStamp());\n    request.setInputPerfMetricReportPolicy(InputToLoadPerfMetricReportPolicy::ReportLink);\n\n    ReferrerPolicy policy;\n    if (hasAttribute(referrerpolicyAttr) && SecurityPolicy::referrerPolicyFromString(fastGetAttribute(referrerpolicyAttr), &policy) && !hasRel(RelationNoReferrer)) {\n        request.setHTTPReferrer(SecurityPolicy::generateReferrer(policy, completedURL, document().outgoingReferrer()));\n    }\n\n    if (hasAttribute(downloadAttr)) {\n        request.setRequestContext(WebURLRequest::RequestContextDownload);\n        bool isSameOrigin = completedURL.protocolIsData() || document().getSecurityOrigin()->canRequest(completedURL);\n        const AtomicString& suggestedName = (isSameOrigin ? fastGetAttribute(downloadAttr) : nullAtom);\n\n        frame->loader().client()->loadURLExternally(request, NavigationPolicyDownload, suggestedName, false);\n    } else {\n        request.setRequestContext(WebURLRequest::RequestContextHyperlink);\n        FrameLoadRequest frameRequest(&document(), request, getAttribute(targetAttr));\n        frameRequest.setTriggeringEvent(event);\n        if (hasRel(RelationNoReferrer)) {\n            frameRequest.setShouldSendReferrer(NeverSendReferrer);\n            frameRequest.setShouldSetOpener(NeverSetOpener);\n        }\n        if (hasRel(RelationNoOpener))\n            frameRequest.setShouldSetOpener(NeverSetOpener);\n        frame->loader().load(frameRequest);\n    }\n}",
        "func": "void HTMLAnchorElement::handleClick(Event* event)\n{\n    event->setDefaultHandled();\n\n    LocalFrame* frame = document().frame();\n    if (!frame)\n        return;\n\n    StringBuilder url;\n    url.append(stripLeadingAndTrailingHTMLSpaces(fastGetAttribute(hrefAttr)));\n    appendServerMapMousePosition(url, event);\n    KURL completedURL = document().completeURL(url.toString());\n\n    // Schedule the ping before the frame load. Prerender in Chrome may kill the renderer as soon as the navigation is\n    // sent out.\n    sendPings(completedURL);\n\n    ResourceRequest request(completedURL);\n    request.setUIStartTime(event->platformTimeStamp());\n    request.setInputPerfMetricReportPolicy(InputToLoadPerfMetricReportPolicy::ReportLink);\n\n    ReferrerPolicy policy;\n    if (hasAttribute(referrerpolicyAttr) && SecurityPolicy::referrerPolicyFromString(fastGetAttribute(referrerpolicyAttr), &policy) && !hasRel(RelationNoReferrer)) {\n        request.setHTTPReferrer(SecurityPolicy::generateReferrer(policy, completedURL, document().outgoingReferrer()));\n    }\n\n    if (hasAttribute(downloadAttr)) {\n        request.setRequestContext(WebURLRequest::RequestContextDownload);\n        bool isSameOrigin = completedURL.protocolIsData() || document().getSecurityOrigin()->canRequest(completedURL);\n        const AtomicString& suggestedName = (isSameOrigin ? fastGetAttribute(downloadAttr) : nullAtom);\n\n        frame->loader().client()->loadURLExternally(request, NavigationPolicyDownload, suggestedName, false);\n    } else {\n        request.setRequestContext(WebURLRequest::RequestContextHyperlink);\n        FrameLoadRequest frameRequest(&document(), request, getAttribute(targetAttr));\n        frameRequest.setTriggeringEvent(event);\n        if (hasRel(RelationNoReferrer)) {\n            frameRequest.setShouldSendReferrer(NeverSendReferrer);\n            frameRequest.setShouldSetOpener(NeverSetOpener);\n        }\n        if (hasRel(RelationNoOpener))\n            frameRequest.setShouldSetOpener(NeverSetOpener);\n        // TODO(japhet): Link clicks can be emulated via JS without a user gesture.\n        // Why doesn't this go through NavigationScheduler?\n        frame->loader().load(frameRequest);\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -40,6 +40,8 @@\n         }\n         if (hasRel(RelationNoOpener))\n             frameRequest.setShouldSetOpener(NeverSetOpener);\n+        // TODO(japhet): Link clicks can be emulated via JS without a user gesture.\n+        // Why doesn't this go through NavigationScheduler?\n         frame->loader().load(frameRequest);\n     }\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "        // TODO(japhet): Link clicks can be emulated via JS without a user gesture.",
                "        // Why doesn't this go through NavigationScheduler?"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-5104",
        "func_name": "libimobiledevice/socket_accept",
        "description": "The socket_create function in common/socket.c in libimobiledevice and libusbmuxd allows remote attackers to bypass intended access restrictions and communicate with services on iOS devices by connecting to an IPv4 TCP socket.",
        "git_url": "https://github.com/libimobiledevice/libimobiledevice/commit/df1f5c4d70d0c19ad40072f5246ca457e7f9849e",
        "commit_title": "common: [security fix] Make sure sockets only listen locally",
        "commit_text": "",
        "func_before": "int socket_accept(int fd, uint16_t port)\n{\n#ifdef WIN32\n\tint addr_len;\n#else\n\tsocklen_t addr_len;\n#endif\n\tint result;\n\tstruct sockaddr_in addr;\n\n\tmemset(&addr, 0, sizeof(addr));\n\taddr.sin_family = AF_INET;\n\taddr.sin_addr.s_addr = htonl(INADDR_ANY);\n\taddr.sin_port = htons(port);\n\n\taddr_len = sizeof(addr);\n\tresult = accept(fd, (struct sockaddr*)&addr, &addr_len);\n\n\treturn result;\n}",
        "func": "int socket_accept(int fd, uint16_t port)\n{\n#ifdef WIN32\n\tint addr_len;\n#else\n\tsocklen_t addr_len;\n#endif\n\tint result;\n\tstruct sockaddr_in addr;\n\n\tmemset(&addr, 0, sizeof(addr));\n\taddr.sin_family = AF_INET;\n\taddr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);\n\taddr.sin_port = htons(port);\n\n\taddr_len = sizeof(addr);\n\tresult = accept(fd, (struct sockaddr*)&addr, &addr_len);\n\n\treturn result;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -10,7 +10,7 @@\n \n \tmemset(&addr, 0, sizeof(addr));\n \taddr.sin_family = AF_INET;\n-\taddr.sin_addr.s_addr = htonl(INADDR_ANY);\n+\taddr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);\n \taddr.sin_port = htons(port);\n \n \taddr_len = sizeof(addr);",
        "diff_line_info": {
            "deleted_lines": [
                "\taddr.sin_addr.s_addr = htonl(INADDR_ANY);"
            ],
            "added_lines": [
                "\taddr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-5104",
        "func_name": "libimobiledevice/socket_create",
        "description": "The socket_create function in common/socket.c in libimobiledevice and libusbmuxd allows remote attackers to bypass intended access restrictions and communicate with services on iOS devices by connecting to an IPv4 TCP socket.",
        "git_url": "https://github.com/libimobiledevice/libimobiledevice/commit/df1f5c4d70d0c19ad40072f5246ca457e7f9849e",
        "commit_title": "common: [security fix] Make sure sockets only listen locally",
        "commit_text": "",
        "func_before": "int socket_create(uint16_t port)\n{\n\tint sfd = -1;\n\tint yes = 1;\n#ifdef WIN32\n\tWSADATA wsa_data;\n\tif (!wsa_init) {\n\t\tif (WSAStartup(MAKEWORD(2,2), &wsa_data) != ERROR_SUCCESS) {\n\t\t\tfprintf(stderr, \"WSAStartup failed!\\n\");\n\t\t\tExitProcess(-1);\n\t\t}\n\t\twsa_init = 1;\n\t}\n#endif\n\tstruct sockaddr_in saddr;\n\n\tif (0 > (sfd = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP))) {\n\t\tperror(\"socket()\");\n\t\treturn -1;\n\t}\n\n\tif (setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, (void*)&yes, sizeof(int)) == -1) {\n\t\tperror(\"setsockopt()\");\n\t\tsocket_close(sfd);\n\t\treturn -1;\n\t}\n\n\tmemset((void *) &saddr, 0, sizeof(saddr));\n\tsaddr.sin_family = AF_INET;\n\tsaddr.sin_addr.s_addr = htonl(INADDR_ANY);\n\tsaddr.sin_port = htons(port);\n\n\tif (0 > bind(sfd, (struct sockaddr *) &saddr, sizeof(saddr))) {\n\t\tperror(\"bind()\");\n\t\tsocket_close(sfd);\n\t\treturn -1;\n\t}\n\n\tif (listen(sfd, 1) == -1) {\n\t\tperror(\"listen()\");\n\t\tsocket_close(sfd);\n\t\treturn -1;\n\t}\n\n\treturn sfd;\n}",
        "func": "int socket_create(uint16_t port)\n{\n\tint sfd = -1;\n\tint yes = 1;\n#ifdef WIN32\n\tWSADATA wsa_data;\n\tif (!wsa_init) {\n\t\tif (WSAStartup(MAKEWORD(2,2), &wsa_data) != ERROR_SUCCESS) {\n\t\t\tfprintf(stderr, \"WSAStartup failed!\\n\");\n\t\t\tExitProcess(-1);\n\t\t}\n\t\twsa_init = 1;\n\t}\n#endif\n\tstruct sockaddr_in saddr;\n\n\tif (0 > (sfd = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP))) {\n\t\tperror(\"socket()\");\n\t\treturn -1;\n\t}\n\n\tif (setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, (void*)&yes, sizeof(int)) == -1) {\n\t\tperror(\"setsockopt()\");\n\t\tsocket_close(sfd);\n\t\treturn -1;\n\t}\n\n\tmemset((void *) &saddr, 0, sizeof(saddr));\n\tsaddr.sin_family = AF_INET;\n\tsaddr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);\n\tsaddr.sin_port = htons(port);\n\n\tif (0 > bind(sfd, (struct sockaddr *) &saddr, sizeof(saddr))) {\n\t\tperror(\"bind()\");\n\t\tsocket_close(sfd);\n\t\treturn -1;\n\t}\n\n\tif (listen(sfd, 1) == -1) {\n\t\tperror(\"listen()\");\n\t\tsocket_close(sfd);\n\t\treturn -1;\n\t}\n\n\treturn sfd;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -27,7 +27,7 @@\n \n \tmemset((void *) &saddr, 0, sizeof(saddr));\n \tsaddr.sin_family = AF_INET;\n-\tsaddr.sin_addr.s_addr = htonl(INADDR_ANY);\n+\tsaddr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);\n \tsaddr.sin_port = htons(port);\n \n \tif (0 > bind(sfd, (struct sockaddr *) &saddr, sizeof(saddr))) {",
        "diff_line_info": {
            "deleted_lines": [
                "\tsaddr.sin_addr.s_addr = htonl(INADDR_ANY);"
            ],
            "added_lines": [
                "\tsaddr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);"
            ]
        }
    },
    {
        "cve_id": "CVE-2014-9773",
        "func_name": "atheme/_modinit",
        "description": "modules/chanserv/flags.c in Atheme before 7.2.7 allows remote attackers to modify the Anope FLAGS behavior by registering and dropping the (1) LIST, (2) CLEAR, or (3) MODIFY keyword nicks.",
        "git_url": "https://github.com/atheme/atheme/commit/c597156adc60a45b5f827793cd420945f47bc03b",
        "commit_title": "chanserv/flags: make Anope FLAGS compatibility an option",
        "commit_text": " Previously, ChanServ FLAGS behavior could be modified by registering or dropping the keyword nicks \"LIST\", \"CLEAR\", and \"MODIFY\". Now, a configuration option is available that when turned on (default), disables registration of these keyword nicks and enables this compatibility feature. When turned off, registration of these keyword nicks is possible, and compatibility to Anope's FLAGS command is disabled.  Fixes atheme/atheme#397",
        "func_before": "void _modinit(module_t *m)\n{\n\tservice_named_bind_command(\"chanserv\", &cs_flags);\n}",
        "func": "void _modinit(module_t *m)\n{\n\tservice_named_bind_command(\"chanserv\", &cs_flags);\n\n\tadd_bool_conf_item(\"ANOPE_FLAGS_COMPAT\", &chansvs.me->conf_table, 0, &anope_flags_compat, true);\n\n\thook_add_event(\"nick_can_register\");\n\thook_add_nick_can_register(check_registration_keywords);\n\n\thook_add_event(\"user_can_register\");\n\thook_add_user_can_register(check_registration_keywords);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,12 @@\n void _modinit(module_t *m)\n {\n \tservice_named_bind_command(\"chanserv\", &cs_flags);\n+\n+\tadd_bool_conf_item(\"ANOPE_FLAGS_COMPAT\", &chansvs.me->conf_table, 0, &anope_flags_compat, true);\n+\n+\thook_add_event(\"nick_can_register\");\n+\thook_add_nick_can_register(check_registration_keywords);\n+\n+\thook_add_event(\"user_can_register\");\n+\thook_add_user_can_register(check_registration_keywords);\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "\tadd_bool_conf_item(\"ANOPE_FLAGS_COMPAT\", &chansvs.me->conf_table, 0, &anope_flags_compat, true);",
                "",
                "\thook_add_event(\"nick_can_register\");",
                "\thook_add_nick_can_register(check_registration_keywords);",
                "",
                "\thook_add_event(\"user_can_register\");",
                "\thook_add_user_can_register(check_registration_keywords);"
            ]
        }
    },
    {
        "cve_id": "CVE-2014-9773",
        "func_name": "atheme/_moddeinit",
        "description": "modules/chanserv/flags.c in Atheme before 7.2.7 allows remote attackers to modify the Anope FLAGS behavior by registering and dropping the (1) LIST, (2) CLEAR, or (3) MODIFY keyword nicks.",
        "git_url": "https://github.com/atheme/atheme/commit/c597156adc60a45b5f827793cd420945f47bc03b",
        "commit_title": "chanserv/flags: make Anope FLAGS compatibility an option",
        "commit_text": " Previously, ChanServ FLAGS behavior could be modified by registering or dropping the keyword nicks \"LIST\", \"CLEAR\", and \"MODIFY\". Now, a configuration option is available that when turned on (default), disables registration of these keyword nicks and enables this compatibility feature. When turned off, registration of these keyword nicks is possible, and compatibility to Anope's FLAGS command is disabled.  Fixes atheme/atheme#397",
        "func_before": "void _moddeinit(module_unload_intent_t intent)\n{\n\tservice_named_unbind_command(\"chanserv\", &cs_flags);\n}",
        "func": "void _moddeinit(module_unload_intent_t intent)\n{\n\tservice_named_unbind_command(\"chanserv\", &cs_flags);\n\n\thook_del_nick_can_register(check_registration_keywords);\n\n\thook_del_user_can_register(check_registration_keywords);\n\n\tdel_conf_item(\"ANOPE_FLAGS_COMPAT\", &chansvs.me->conf_table);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,10 @@\n void _moddeinit(module_unload_intent_t intent)\n {\n \tservice_named_unbind_command(\"chanserv\", &cs_flags);\n+\n+\thook_del_nick_can_register(check_registration_keywords);\n+\n+\thook_del_user_can_register(check_registration_keywords);\n+\n+\tdel_conf_item(\"ANOPE_FLAGS_COMPAT\", &chansvs.me->conf_table);\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "\thook_del_nick_can_register(check_registration_keywords);",
                "",
                "\thook_del_user_can_register(check_registration_keywords);",
                "",
                "\tdel_conf_item(\"ANOPE_FLAGS_COMPAT\", &chansvs.me->conf_table);"
            ]
        }
    },
    {
        "cve_id": "CVE-2014-9773",
        "func_name": "atheme/cs_cmd_flags",
        "description": "modules/chanserv/flags.c in Atheme before 7.2.7 allows remote attackers to modify the Anope FLAGS behavior by registering and dropping the (1) LIST, (2) CLEAR, or (3) MODIFY keyword nicks.",
        "git_url": "https://github.com/atheme/atheme/commit/c597156adc60a45b5f827793cd420945f47bc03b",
        "commit_title": "chanserv/flags: make Anope FLAGS compatibility an option",
        "commit_text": " Previously, ChanServ FLAGS behavior could be modified by registering or dropping the keyword nicks \"LIST\", \"CLEAR\", and \"MODIFY\". Now, a configuration option is available that when turned on (default), disables registration of these keyword nicks and enables this compatibility feature. When turned off, registration of these keyword nicks is possible, and compatibility to Anope's FLAGS command is disabled.  Fixes atheme/atheme#397",
        "func_before": "static void cs_cmd_flags(sourceinfo_t *si, int parc, char *parv[])\n{\n\tchanacs_t *ca;\n\tmowgli_node_t *n;\n\tchar *channel = parv[0];\n\tchar *target = sstrdup(parv[1]);\n\tchar *flagstr = parv[2];\n\tconst char *str1;\n\tunsigned int addflags, removeflags, restrictflags;\n\thook_channel_acl_req_t req;\n\tmychan_t *mc;\n\n\tif (parc < 1)\n\t{\n\t\tcommand_fail(si, fault_needmoreparams, STR_INSUFFICIENT_PARAMS, \"FLAGS\");\n\t\tcommand_fail(si, fault_needmoreparams, _(\"Syntax: FLAGS <channel> [target] [flags]\"));\n\t\treturn;\n\t}\n\n\tmc = mychan_find(channel);\n\tif (!mc)\n\t{\n\t\tcommand_fail(si, fault_nosuch_target, _(\"Channel \\2%s\\2 is not registered.\"), channel);\n\t\treturn;\n\t}\n\n\tif (metadata_find(mc, \"private:close:closer\") && (target || !has_priv(si, PRIV_CHAN_AUSPEX)))\n\t{\n\t\tcommand_fail(si, fault_noprivs, _(\"\\2%s\\2 is closed.\"), channel);\n\t\treturn;\n\t}\n\n\tif (!target || (target && target[0] == '+' && flagstr == NULL))\n\t{\n\t\tunsigned int flags = (target != NULL) ? flags_to_bitmask(target, 0) : 0;\n\n\t\tdo_list(si, mc, flags);\n\t\treturn;\n\t}\n\n\t/*\n\t * following conditions are for compatibility with Anope just to avoid a whole clusterfuck\n\t * of confused users caused by their 'innovation.'  yeah, that's a word for it alright.\n\t *\n\t * anope 1.9's shiny new FLAGS command has:\n\t *\n\t * FLAGS #channel LIST\n\t * FLAGS #channel MODIFY user flagspec\n\t * FLAGS #channel CLEAR\n\t *\n\t * obviously they do not support the atheme syntax, because lets face it, they like to\n\t * 'innovate.'  this is, of course, hilarious for obvious reasons.  never mind that we\n\t * *invented* the FLAGS system for channel ACLs, so you would think they would find it\n\t * worthwhile to be compatible here.  i guess that would have been too obvious or something\n\t * about their whole 'stealing our design' thing that they have been doing in 1.9 since the\n\t * beginning...  or do i mean 'innovating?'\n\t *\n\t * anyway we rewrite the commands as appropriate in the two if blocks below so that they\n\t * are processed by the flags code as the user would intend.  obviously, we're not really\n\t * capable of handling the anope flag model (which makes honestly zero sense to me, and is\n\t * extremely complex which kind of misses the entire point of the flags UI design...) so if\n\t * some user tries passing anope flags, it will probably be hilarious.  the good news is\n\t * most of the anope flags tie up to atheme flags in some weird way anyway (probably because,\n\t * i don't know, they copied the entire design and then fucked it up?  yeah.  probably that.)\n\t *\n\t *   --nenolod\n\t */\n\telse if (!strcasecmp(target, \"LIST\") && myentity_find_ext(target) == NULL)\n\t{\n\t\tdo_list(si, mc, 0);\n\t\tfree(target);\n\n\t\treturn;\n\t}\n\telse if (!strcasecmp(target, \"CLEAR\") && myentity_find_ext(target) == NULL)\n\t{\n\t\tfree(target);\n\n\t\tif (!chanacs_source_has_flag(mc, si, CA_FOUNDER))\n\t\t{\n\t\t\tcommand_fail(si, fault_noprivs, \"You are not authorized to perform this operation.\");\n\t\t\treturn;\n\t\t}\n\n\t\tmowgli_node_t *tn;\n\n\t\tMOWGLI_ITER_FOREACH_SAFE(n, tn, mc->chanacs.head)\n\t\t{\n\t\t\tca = n->data;\n\n\t\t\tif (ca->level & CA_FOUNDER)\n\t\t\t\tcontinue;\n\n\t\t\tobject_unref(ca);\n\t\t}\n\n\t\tlogcommand(si, CMDLOG_DO, \"CLEAR:FLAGS: \\2%s\\2\", mc->name);\n\t\tcommand_success_nodata(si, _(\"Cleared flags in \\2%s\\2.\"), mc->name);\n\t\treturn;\n\t}\n\telse if (!strcasecmp(target, \"MODIFY\") && myentity_find_ext(target) == NULL)\n\t{\n\t\tfree(target);\n\n\t\tif (parc < 3)\n\t\t{\n\t\t\tcommand_fail(si, fault_needmoreparams, STR_INSUFFICIENT_PARAMS, \"FLAGS\");\n\t\t\tcommand_fail(si, fault_needmoreparams, _(\"Syntax: FLAGS <#channel> MODIFY [target] <flags>\"));\n\t\t\treturn;\n\t\t}\n\n\t\tflagstr = strchr(parv[2], ' ');\n\t\tif (flagstr)\n\t\t\t*flagstr++ = '\\0';\n\n\t\ttarget = strdup(parv[2]);\n\t}\n\n\t{\n\t\tmyentity_t *mt;\n\n\t\tif (!si->smu)\n\t\t{\n\t\t\tcommand_fail(si, fault_noprivs, _(\"You are not logged in.\"));\n\t\t\treturn;\n\t\t}\n\n\t\tif (!flagstr)\n\t\t{\n\t\t\tif (!(mc->flags & MC_PUBACL) && !chanacs_source_has_flag(mc, si, CA_ACLVIEW))\n\t\t\t{\n\t\t\t\tcommand_fail(si, fault_noprivs, _(\"You are not authorized to execute this command.\"));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (validhostmask(target))\n\t\t\t\tca = chanacs_find_host_literal(mc, target, 0);\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (!(mt = myentity_find_ext(target)))\n\t\t\t\t{\n\t\t\t\t\tcommand_fail(si, fault_nosuch_target, _(\"\\2%s\\2 is not registered.\"), target);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tfree(target);\n\t\t\t\ttarget = sstrdup(mt->name);\n\t\t\t\tca = chanacs_find_literal(mc, mt, 0);\n\t\t\t}\n\t\t\tif (ca != NULL)\n\t\t\t{\n\t\t\t\tstr1 = bitmask_to_flags2(ca->level, 0);\n\t\t\t\tcommand_success_string(si, str1, _(\"Flags for \\2%s\\2 in \\2%s\\2 are \\2%s\\2.\"),\n\t\t\t\t\t\ttarget, channel,\n\t\t\t\t\t\tstr1);\n\t\t\t}\n\t\t\telse\n\t\t\t\tcommand_success_string(si, \"\", _(\"No flags for \\2%s\\2 in \\2%s\\2.\"),\n\t\t\t\t\t\ttarget, channel);\n\t\t\tlogcommand(si, CMDLOG_GET, \"FLAGS: \\2%s\\2 on \\2%s\\2\", mc->name, target);\n\t\t\treturn;\n\t\t}\n\n\t\t/* founder may always set flags -- jilles */\n\t\trestrictflags = chanacs_source_flags(mc, si);\n\t\tif (restrictflags & CA_FOUNDER)\n\t\t\trestrictflags = ca_all;\n\t\telse\n\t\t{\n\t\t\tif (!(restrictflags & CA_FLAGS))\n\t\t\t{\n\t\t\t\t/* allow a user to remove their own access\n\t\t\t\t * even without +f */\n\t\t\t\tif (restrictflags & CA_AKICK ||\n\t\t\t\t\t\tsi->smu == NULL ||\n\t\t\t\t\t\tirccasecmp(target, entity(si->smu)->name) ||\n\t\t\t\t\t\tstrcmp(flagstr, \"-*\"))\n\t\t\t\t{\n\t\t\t\t\tcommand_fail(si, fault_noprivs, _(\"You are not authorized to execute this command.\"));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (irccasecmp(target, entity(si->smu)->name))\n\t\t\t\trestrictflags = allow_flags(mc, restrictflags);\n\t\t\telse\n\t\t\t\trestrictflags |= allow_flags(mc, restrictflags);\n\t\t}\n\n\t\tif (*flagstr == '+' || *flagstr == '-' || *flagstr == '=')\n\t\t{\n\t\t\tflags_make_bitmasks(flagstr, &addflags, &removeflags);\n\t\t\tif (addflags == 0 && removeflags == 0)\n\t\t\t{\n\t\t\t\tcommand_fail(si, fault_badparams, _(\"No valid flags given, use /%s%s HELP FLAGS for a list\"), ircd->uses_rcommand ? \"\" : \"msg \", chansvs.me->disp);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\taddflags = get_template_flags(mc, flagstr);\n\t\t\tif (addflags == 0)\n\t\t\t{\n\t\t\t\t/* Hack -- jilles */\n\t\t\t\tif (*target == '+' || *target == '-' || *target == '=')\n\t\t\t\t\tcommand_fail(si, fault_badparams, _(\"Usage: FLAGS %s [target] [flags]\"), mc->name);\n\t\t\t\telse\n\t\t\t\t\tcommand_fail(si, fault_badparams, _(\"Invalid template name given, use /%s%s TEMPLATE %s for a list\"), ircd->uses_rcommand ? \"\" : \"msg \", chansvs.me->disp, mc->name);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tremoveflags = ca_all & ~addflags;\n\t\t}\n\n\t\tif (!validhostmask(target))\n\t\t{\n\t\t\tif (!(mt = myentity_find_ext(target)))\n\t\t\t{\n\t\t\t\tcommand_fail(si, fault_nosuch_target, _(\"\\2%s\\2 is not registered.\"), target);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfree(target);\n\t\t\ttarget = sstrdup(mt->name);\n\n\t\t\tca = chanacs_open(mc, mt, NULL, true, entity(si->smu));\n\n\t\t\tif (ca->level & CA_FOUNDER && removeflags & CA_FLAGS && !(removeflags & CA_FOUNDER))\n\t\t\t{\n\t\t\t\tcommand_fail(si, fault_noprivs, _(\"You may not remove a founder's +f access.\"));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (ca->level & CA_FOUNDER && removeflags & CA_FOUNDER && mychan_num_founders(mc) == 1)\n\t\t\t{\n\t\t\t\tcommand_fail(si, fault_noprivs, _(\"You may not remove the last founder.\"));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (!(ca->level & CA_FOUNDER) && addflags & CA_FOUNDER)\n\t\t\t{\n\t\t\t\tif (mychan_num_founders(mc) >= chansvs.maxfounders)\n\t\t\t\t{\n\t\t\t\t\tcommand_fail(si, fault_noprivs, _(\"Only %d founders allowed per channel.\"), chansvs.maxfounders);\n\t\t\t\t\tchanacs_close(ca);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (!myentity_can_register_channel(mt))\n\t\t\t\t{\n\t\t\t\t\tcommand_fail(si, fault_toomany, _(\"\\2%s\\2 has too many channels registered.\"), mt->name);\n\t\t\t\t\tchanacs_close(ca);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (!myentity_allow_foundership(mt))\n\t\t\t\t{\n\t\t\t\t\tcommand_fail(si, fault_toomany, _(\"\\2%s\\2 cannot take foundership of a channel.\"), mt->name);\n\t\t\t\t\tchanacs_close(ca);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (addflags & CA_FOUNDER)\n\t\t\t\taddflags |= CA_FLAGS, removeflags &= ~CA_FLAGS;\n\n\t\t\t/* If NEVEROP is set, don't allow adding new entries\n\t\t\t * except sole +b. Adding flags if the current level\n\t\t\t * is +b counts as adding an entry.\n\t\t\t * -- jilles */\n\t\t\t/* XXX: not all entities are users */\n\t\t\tif (isuser(mt) && (MU_NEVEROP & user(mt)->flags && addflags != CA_AKICK && addflags != 0 && (ca->level == 0 || ca->level == CA_AKICK)))\n\t\t\t{\n\t\t\t\tcommand_fail(si, fault_noprivs, _(\"\\2%s\\2 does not wish to be added to channel access lists (NEVEROP set).\"), mt->name);\n\t\t\t\tchanacs_close(ca);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (ca->level == 0 && chanacs_is_table_full(ca))\n\t\t\t{\n\t\t\t\tcommand_fail(si, fault_toomany, _(\"Channel %s access list is full.\"), mc->name);\n\t\t\t\tchanacs_close(ca);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\treq.ca = ca;\n\t\t\treq.oldlevel = ca->level;\n\n\t\t\tif (!chanacs_modify(ca, &addflags, &removeflags, restrictflags))\n\t\t\t{\n\t\t\t\tcommand_fail(si, fault_noprivs, _(\"You are not allowed to set \\2%s\\2 on \\2%s\\2 in \\2%s\\2.\"), bitmask_to_flags2(addflags, removeflags), mt->name, mc->name);\n\t\t\t\tchanacs_close(ca);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\treq.newlevel = ca->level;\n\n\t\t\thook_call_channel_acl_change(&req);\n\t\t\tchanacs_close(ca);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (addflags & CA_FOUNDER)\n\t\t\t{\n\t\t                command_fail(si, fault_badparams, _(\"You may not set founder status on a hostmask.\"));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tca = chanacs_open(mc, NULL, target, true, entity(si->smu));\n\t\t\tif (ca->level == 0 && chanacs_is_table_full(ca))\n\t\t\t{\n\t\t\t\tcommand_fail(si, fault_toomany, _(\"Channel %s access list is full.\"), mc->name);\n\t\t\t\tchanacs_close(ca);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\treq.ca = ca;\n\t\t\treq.oldlevel = ca->level;\n\n\t\t\tif (!chanacs_modify(ca, &addflags, &removeflags, restrictflags))\n\t\t\t{\n\t\t                command_fail(si, fault_noprivs, _(\"You are not allowed to set \\2%s\\2 on \\2%s\\2 in \\2%s\\2.\"), bitmask_to_flags2(addflags, removeflags), target, mc->name);\n\t\t\t\tchanacs_close(ca);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\treq.newlevel = ca->level;\n\n\t\t\thook_call_channel_acl_change(&req);\n\t\t\tchanacs_close(ca);\n\t\t}\n\n\t\tif ((addflags | removeflags) == 0)\n\t\t{\n\t\t\tcommand_fail(si, fault_nochange, _(\"Channel access to \\2%s\\2 for \\2%s\\2 unchanged.\"), channel, target);\n\t\t\treturn;\n\t\t}\n\t\tflagstr = bitmask_to_flags2(addflags, removeflags);\n\t\tcommand_success_nodata(si, _(\"Flags \\2%s\\2 were set on \\2%s\\2 in \\2%s\\2.\"), flagstr, target, channel);\n\t\tlogcommand(si, CMDLOG_SET, \"FLAGS: \\2%s\\2 \\2%s\\2 \\2%s\\2\", mc->name, target, flagstr);\n\t\tverbose(mc, \"\\2%s\\2 set flags \\2%s\\2 on \\2%s\\2\", get_source_name(si), flagstr, target);\n\t}\n\n\tfree(target);\n}",
        "func": "static void cs_cmd_flags(sourceinfo_t *si, int parc, char *parv[])\n{\n\tchanacs_t *ca;\n\tmowgli_node_t *n;\n\tchar *channel = parv[0];\n\tchar *target = sstrdup(parv[1]);\n\tchar *flagstr = parv[2];\n\tconst char *str1;\n\tunsigned int addflags, removeflags, restrictflags;\n\thook_channel_acl_req_t req;\n\tmychan_t *mc;\n\n\tif (parc < 1)\n\t{\n\t\tcommand_fail(si, fault_needmoreparams, STR_INSUFFICIENT_PARAMS, \"FLAGS\");\n\t\tcommand_fail(si, fault_needmoreparams, _(\"Syntax: FLAGS <channel> [target] [flags]\"));\n\t\treturn;\n\t}\n\n\tmc = mychan_find(channel);\n\tif (!mc)\n\t{\n\t\tcommand_fail(si, fault_nosuch_target, _(\"Channel \\2%s\\2 is not registered.\"), channel);\n\t\treturn;\n\t}\n\n\tif (metadata_find(mc, \"private:close:closer\") && (target || !has_priv(si, PRIV_CHAN_AUSPEX)))\n\t{\n\t\tcommand_fail(si, fault_noprivs, _(\"\\2%s\\2 is closed.\"), channel);\n\t\treturn;\n\t}\n\n\tif (!target || (target && target[0] == '+' && flagstr == NULL))\n\t{\n\t\tunsigned int flags = (target != NULL) ? flags_to_bitmask(target, 0) : 0;\n\n\t\tdo_list(si, mc, flags);\n\t\treturn;\n\t}\n\n\t/*\n\t * following conditions are for compatibility with Anope just to avoid a whole clusterfuck\n\t * of confused users caused by their 'innovation.'  yeah, that's a word for it alright.\n\t *\n\t * anope 1.9's shiny new FLAGS command has:\n\t *\n\t * FLAGS #channel LIST\n\t * FLAGS #channel MODIFY user flagspec\n\t * FLAGS #channel CLEAR\n\t *\n\t * obviously they do not support the atheme syntax, because lets face it, they like to\n\t * 'innovate.'  this is, of course, hilarious for obvious reasons.  never mind that we\n\t * *invented* the FLAGS system for channel ACLs, so you would think they would find it\n\t * worthwhile to be compatible here.  i guess that would have been too obvious or something\n\t * about their whole 'stealing our design' thing that they have been doing in 1.9 since the\n\t * beginning...  or do i mean 'innovating?'\n\t *\n\t * anyway we rewrite the commands as appropriate in the two if blocks below so that they\n\t * are processed by the flags code as the user would intend.  obviously, we're not really\n\t * capable of handling the anope flag model (which makes honestly zero sense to me, and is\n\t * extremely complex which kind of misses the entire point of the flags UI design...) so if\n\t * some user tries passing anope flags, it will probably be hilarious.  the good news is\n\t * most of the anope flags tie up to atheme flags in some weird way anyway (probably because,\n\t * i don't know, they copied the entire design and then fucked it up?  yeah.  probably that.)\n\t *\n\t *   --nenolod\n\t */\n\telse if (anope_flags_compat && !strcasecmp(target, \"LIST\") && myentity_find_ext(target) == NULL)\n\t{\n\t\tdo_list(si, mc, 0);\n\t\tfree(target);\n\n\t\treturn;\n\t}\n\telse if (anope_flags_compat && !strcasecmp(target, \"CLEAR\") && myentity_find_ext(target) == NULL)\n\t{\n\t\tfree(target);\n\n\t\tif (!chanacs_source_has_flag(mc, si, CA_FOUNDER))\n\t\t{\n\t\t\tcommand_fail(si, fault_noprivs, \"You are not authorized to perform this operation.\");\n\t\t\treturn;\n\t\t}\n\n\t\tmowgli_node_t *tn;\n\n\t\tMOWGLI_ITER_FOREACH_SAFE(n, tn, mc->chanacs.head)\n\t\t{\n\t\t\tca = n->data;\n\n\t\t\tif (ca->level & CA_FOUNDER)\n\t\t\t\tcontinue;\n\n\t\t\tobject_unref(ca);\n\t\t}\n\n\t\tlogcommand(si, CMDLOG_DO, \"CLEAR:FLAGS: \\2%s\\2\", mc->name);\n\t\tcommand_success_nodata(si, _(\"Cleared flags in \\2%s\\2.\"), mc->name);\n\t\treturn;\n\t}\n\telse if (anope_flags_compat && !strcasecmp(target, \"MODIFY\") && myentity_find_ext(target) == NULL)\n\t{\n\t\tfree(target);\n\n\t\tif (parc < 3)\n\t\t{\n\t\t\tcommand_fail(si, fault_needmoreparams, STR_INSUFFICIENT_PARAMS, \"FLAGS\");\n\t\t\tcommand_fail(si, fault_needmoreparams, _(\"Syntax: FLAGS <#channel> MODIFY [target] <flags>\"));\n\t\t\treturn;\n\t\t}\n\n\t\tflagstr = strchr(parv[2], ' ');\n\t\tif (flagstr)\n\t\t\t*flagstr++ = '\\0';\n\n\t\ttarget = strdup(parv[2]);\n\t}\n\n\t{\n\t\tmyentity_t *mt;\n\n\t\tif (!si->smu)\n\t\t{\n\t\t\tcommand_fail(si, fault_noprivs, _(\"You are not logged in.\"));\n\t\t\treturn;\n\t\t}\n\n\t\tif (!flagstr)\n\t\t{\n\t\t\tif (!(mc->flags & MC_PUBACL) && !chanacs_source_has_flag(mc, si, CA_ACLVIEW))\n\t\t\t{\n\t\t\t\tcommand_fail(si, fault_noprivs, _(\"You are not authorized to execute this command.\"));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (validhostmask(target))\n\t\t\t\tca = chanacs_find_host_literal(mc, target, 0);\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (!(mt = myentity_find_ext(target)))\n\t\t\t\t{\n\t\t\t\t\tcommand_fail(si, fault_nosuch_target, _(\"\\2%s\\2 is not registered.\"), target);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tfree(target);\n\t\t\t\ttarget = sstrdup(mt->name);\n\t\t\t\tca = chanacs_find_literal(mc, mt, 0);\n\t\t\t}\n\t\t\tif (ca != NULL)\n\t\t\t{\n\t\t\t\tstr1 = bitmask_to_flags2(ca->level, 0);\n\t\t\t\tcommand_success_string(si, str1, _(\"Flags for \\2%s\\2 in \\2%s\\2 are \\2%s\\2.\"),\n\t\t\t\t\t\ttarget, channel,\n\t\t\t\t\t\tstr1);\n\t\t\t}\n\t\t\telse\n\t\t\t\tcommand_success_string(si, \"\", _(\"No flags for \\2%s\\2 in \\2%s\\2.\"),\n\t\t\t\t\t\ttarget, channel);\n\t\t\tlogcommand(si, CMDLOG_GET, \"FLAGS: \\2%s\\2 on \\2%s\\2\", mc->name, target);\n\t\t\treturn;\n\t\t}\n\n\t\t/* founder may always set flags -- jilles */\n\t\trestrictflags = chanacs_source_flags(mc, si);\n\t\tif (restrictflags & CA_FOUNDER)\n\t\t\trestrictflags = ca_all;\n\t\telse\n\t\t{\n\t\t\tif (!(restrictflags & CA_FLAGS))\n\t\t\t{\n\t\t\t\t/* allow a user to remove their own access\n\t\t\t\t * even without +f */\n\t\t\t\tif (restrictflags & CA_AKICK ||\n\t\t\t\t\t\tsi->smu == NULL ||\n\t\t\t\t\t\tirccasecmp(target, entity(si->smu)->name) ||\n\t\t\t\t\t\tstrcmp(flagstr, \"-*\"))\n\t\t\t\t{\n\t\t\t\t\tcommand_fail(si, fault_noprivs, _(\"You are not authorized to execute this command.\"));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (irccasecmp(target, entity(si->smu)->name))\n\t\t\t\trestrictflags = allow_flags(mc, restrictflags);\n\t\t\telse\n\t\t\t\trestrictflags |= allow_flags(mc, restrictflags);\n\t\t}\n\n\t\tif (*flagstr == '+' || *flagstr == '-' || *flagstr == '=')\n\t\t{\n\t\t\tflags_make_bitmasks(flagstr, &addflags, &removeflags);\n\t\t\tif (addflags == 0 && removeflags == 0)\n\t\t\t{\n\t\t\t\tcommand_fail(si, fault_badparams, _(\"No valid flags given, use /%s%s HELP FLAGS for a list\"), ircd->uses_rcommand ? \"\" : \"msg \", chansvs.me->disp);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\taddflags = get_template_flags(mc, flagstr);\n\t\t\tif (addflags == 0)\n\t\t\t{\n\t\t\t\t/* Hack -- jilles */\n\t\t\t\tif (*target == '+' || *target == '-' || *target == '=')\n\t\t\t\t\tcommand_fail(si, fault_badparams, _(\"Usage: FLAGS %s [target] [flags]\"), mc->name);\n\t\t\t\telse\n\t\t\t\t\tcommand_fail(si, fault_badparams, _(\"Invalid template name given, use /%s%s TEMPLATE %s for a list\"), ircd->uses_rcommand ? \"\" : \"msg \", chansvs.me->disp, mc->name);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tremoveflags = ca_all & ~addflags;\n\t\t}\n\n\t\tif (!validhostmask(target))\n\t\t{\n\t\t\tif (!(mt = myentity_find_ext(target)))\n\t\t\t{\n\t\t\t\tcommand_fail(si, fault_nosuch_target, _(\"\\2%s\\2 is not registered.\"), target);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfree(target);\n\t\t\ttarget = sstrdup(mt->name);\n\n\t\t\tca = chanacs_open(mc, mt, NULL, true, entity(si->smu));\n\n\t\t\tif (ca->level & CA_FOUNDER && removeflags & CA_FLAGS && !(removeflags & CA_FOUNDER))\n\t\t\t{\n\t\t\t\tcommand_fail(si, fault_noprivs, _(\"You may not remove a founder's +f access.\"));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (ca->level & CA_FOUNDER && removeflags & CA_FOUNDER && mychan_num_founders(mc) == 1)\n\t\t\t{\n\t\t\t\tcommand_fail(si, fault_noprivs, _(\"You may not remove the last founder.\"));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (!(ca->level & CA_FOUNDER) && addflags & CA_FOUNDER)\n\t\t\t{\n\t\t\t\tif (mychan_num_founders(mc) >= chansvs.maxfounders)\n\t\t\t\t{\n\t\t\t\t\tcommand_fail(si, fault_noprivs, _(\"Only %d founders allowed per channel.\"), chansvs.maxfounders);\n\t\t\t\t\tchanacs_close(ca);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (!myentity_can_register_channel(mt))\n\t\t\t\t{\n\t\t\t\t\tcommand_fail(si, fault_toomany, _(\"\\2%s\\2 has too many channels registered.\"), mt->name);\n\t\t\t\t\tchanacs_close(ca);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (!myentity_allow_foundership(mt))\n\t\t\t\t{\n\t\t\t\t\tcommand_fail(si, fault_toomany, _(\"\\2%s\\2 cannot take foundership of a channel.\"), mt->name);\n\t\t\t\t\tchanacs_close(ca);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (addflags & CA_FOUNDER)\n\t\t\t\taddflags |= CA_FLAGS, removeflags &= ~CA_FLAGS;\n\n\t\t\t/* If NEVEROP is set, don't allow adding new entries\n\t\t\t * except sole +b. Adding flags if the current level\n\t\t\t * is +b counts as adding an entry.\n\t\t\t * -- jilles */\n\t\t\t/* XXX: not all entities are users */\n\t\t\tif (isuser(mt) && (MU_NEVEROP & user(mt)->flags && addflags != CA_AKICK && addflags != 0 && (ca->level == 0 || ca->level == CA_AKICK)))\n\t\t\t{\n\t\t\t\tcommand_fail(si, fault_noprivs, _(\"\\2%s\\2 does not wish to be added to channel access lists (NEVEROP set).\"), mt->name);\n\t\t\t\tchanacs_close(ca);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (ca->level == 0 && chanacs_is_table_full(ca))\n\t\t\t{\n\t\t\t\tcommand_fail(si, fault_toomany, _(\"Channel %s access list is full.\"), mc->name);\n\t\t\t\tchanacs_close(ca);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\treq.ca = ca;\n\t\t\treq.oldlevel = ca->level;\n\n\t\t\tif (!chanacs_modify(ca, &addflags, &removeflags, restrictflags))\n\t\t\t{\n\t\t\t\tcommand_fail(si, fault_noprivs, _(\"You are not allowed to set \\2%s\\2 on \\2%s\\2 in \\2%s\\2.\"), bitmask_to_flags2(addflags, removeflags), mt->name, mc->name);\n\t\t\t\tchanacs_close(ca);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\treq.newlevel = ca->level;\n\n\t\t\thook_call_channel_acl_change(&req);\n\t\t\tchanacs_close(ca);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (addflags & CA_FOUNDER)\n\t\t\t{\n\t\t                command_fail(si, fault_badparams, _(\"You may not set founder status on a hostmask.\"));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tca = chanacs_open(mc, NULL, target, true, entity(si->smu));\n\t\t\tif (ca->level == 0 && chanacs_is_table_full(ca))\n\t\t\t{\n\t\t\t\tcommand_fail(si, fault_toomany, _(\"Channel %s access list is full.\"), mc->name);\n\t\t\t\tchanacs_close(ca);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\treq.ca = ca;\n\t\t\treq.oldlevel = ca->level;\n\n\t\t\tif (!chanacs_modify(ca, &addflags, &removeflags, restrictflags))\n\t\t\t{\n\t\t                command_fail(si, fault_noprivs, _(\"You are not allowed to set \\2%s\\2 on \\2%s\\2 in \\2%s\\2.\"), bitmask_to_flags2(addflags, removeflags), target, mc->name);\n\t\t\t\tchanacs_close(ca);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\treq.newlevel = ca->level;\n\n\t\t\thook_call_channel_acl_change(&req);\n\t\t\tchanacs_close(ca);\n\t\t}\n\n\t\tif ((addflags | removeflags) == 0)\n\t\t{\n\t\t\tcommand_fail(si, fault_nochange, _(\"Channel access to \\2%s\\2 for \\2%s\\2 unchanged.\"), channel, target);\n\t\t\treturn;\n\t\t}\n\t\tflagstr = bitmask_to_flags2(addflags, removeflags);\n\t\tcommand_success_nodata(si, _(\"Flags \\2%s\\2 were set on \\2%s\\2 in \\2%s\\2.\"), flagstr, target, channel);\n\t\tlogcommand(si, CMDLOG_SET, \"FLAGS: \\2%s\\2 \\2%s\\2 \\2%s\\2\", mc->name, target, flagstr);\n\t\tverbose(mc, \"\\2%s\\2 set flags \\2%s\\2 on \\2%s\\2\", get_source_name(si), flagstr, target);\n\t}\n\n\tfree(target);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -65,14 +65,14 @@\n \t *\n \t *   --nenolod\n \t */\n-\telse if (!strcasecmp(target, \"LIST\") && myentity_find_ext(target) == NULL)\n+\telse if (anope_flags_compat && !strcasecmp(target, \"LIST\") && myentity_find_ext(target) == NULL)\n \t{\n \t\tdo_list(si, mc, 0);\n \t\tfree(target);\n \n \t\treturn;\n \t}\n-\telse if (!strcasecmp(target, \"CLEAR\") && myentity_find_ext(target) == NULL)\n+\telse if (anope_flags_compat && !strcasecmp(target, \"CLEAR\") && myentity_find_ext(target) == NULL)\n \t{\n \t\tfree(target);\n \n@@ -98,7 +98,7 @@\n \t\tcommand_success_nodata(si, _(\"Cleared flags in \\2%s\\2.\"), mc->name);\n \t\treturn;\n \t}\n-\telse if (!strcasecmp(target, \"MODIFY\") && myentity_find_ext(target) == NULL)\n+\telse if (anope_flags_compat && !strcasecmp(target, \"MODIFY\") && myentity_find_ext(target) == NULL)\n \t{\n \t\tfree(target);\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\telse if (!strcasecmp(target, \"LIST\") && myentity_find_ext(target) == NULL)",
                "\telse if (!strcasecmp(target, \"CLEAR\") && myentity_find_ext(target) == NULL)",
                "\telse if (!strcasecmp(target, \"MODIFY\") && myentity_find_ext(target) == NULL)"
            ],
            "added_lines": [
                "\telse if (anope_flags_compat && !strcasecmp(target, \"LIST\") && myentity_find_ext(target) == NULL)",
                "\telse if (anope_flags_compat && !strcasecmp(target, \"CLEAR\") && myentity_find_ext(target) == NULL)",
                "\telse if (anope_flags_compat && !strcasecmp(target, \"MODIFY\") && myentity_find_ext(target) == NULL)"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-3698",
        "func_name": "jpirko/libndp/ndp_msg_check_valid",
        "description": "libndp before 1.6, as used in NetworkManager, does not properly validate the origin of Neighbor Discovery Protocol (NDP) messages, which allows remote attackers to conduct man-in-the-middle attacks or cause a denial of service (network connectivity disruption) by advertising a node as a router from a non-local network.",
        "git_url": "https://github.com/jpirko/libndp/commit/2af9a55b38b55abbf05fd116ec097d4029115839",
        "commit_title": "libndb: reject redirect and router advertisements from non-link-local",
        "commit_text": " RFC4861 suggests that these messages should only originate from link-local addresses in 6.1.2 (RA) and 8.1. (redirect):  Mitigates CVE-2016-3698. ",
        "func_before": "static bool ndp_msg_check_valid(struct ndp_msg *msg)\n{\n\tsize_t len = ndp_msg_payload_len(msg);\n\tenum ndp_msg_type msg_type = ndp_msg_type(msg);\n\n\tif (len < ndp_msg_type_info(msg_type)->raw_struct_size)\n\t\treturn false;\n\treturn true;\n}",
        "func": "static bool ndp_msg_check_valid(struct ndp_msg *msg)\n{\n\tsize_t len = ndp_msg_payload_len(msg);\n\tenum ndp_msg_type msg_type = ndp_msg_type(msg);\n\n\tif (len < ndp_msg_type_info(msg_type)->raw_struct_size)\n\t\treturn false;\n\n\tif (ndp_msg_type_info(msg_type)->addrto_validate)\n\t\treturn ndp_msg_type_info(msg_type)->addrto_validate(&msg->addrto);\n\telse\n\t\treturn true;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,5 +5,9 @@\n \n \tif (len < ndp_msg_type_info(msg_type)->raw_struct_size)\n \t\treturn false;\n-\treturn true;\n+\n+\tif (ndp_msg_type_info(msg_type)->addrto_validate)\n+\t\treturn ndp_msg_type_info(msg_type)->addrto_validate(&msg->addrto);\n+\telse\n+\t\treturn true;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\treturn true;"
            ],
            "added_lines": [
                "",
                "\tif (ndp_msg_type_info(msg_type)->addrto_validate)",
                "\t\treturn ndp_msg_type_info(msg_type)->addrto_validate(&msg->addrto);",
                "\telse",
                "\t\treturn true;"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-3698",
        "func_name": "jpirko/libndp/myrecvfrom6",
        "description": "libndp before 1.6, as used in NetworkManager, does not properly validate the origin of Neighbor Discovery Protocol (NDP) messages, which allows remote attackers to conduct man-in-the-middle attacks or cause a denial of service (network connectivity disruption) by advertising a node as a router from a non-local network.",
        "git_url": "https://github.com/jpirko/libndp/commit/a4892df306e0532487f1634ba6d4c6d4bb381c7f",
        "commit_title": "libndp: validate the IPv6 hop limit",
        "commit_text": " None of the NDP messages should ever come from a non-local network; as stated in RFC4861's 6.1.1 (RS), 6.1.2 (RA), 7.1.1 (NS), 7.1.2 (NA), and 8.1. (redirect):    - The IP Hop Limit field has a value of 255, i.e., the packet     could not possibly have been forwarded by a router.  This fixes CVE-2016-3698.  Reported by: Julien BERNARD <julien.bernard@viagenie.ca>",
        "func_before": "static int myrecvfrom6(int sockfd, void *buf, size_t *buflen, int flags,\n\t\t       struct in6_addr *addr, uint32_t *ifindex)\n{\n\tstruct sockaddr_in6 sin6;\n\tunsigned char cbuf[CMSG_SPACE(sizeof(struct in6_pktinfo))];\n\tstruct iovec iovec;\n\tstruct msghdr msghdr;\n\tstruct cmsghdr *cmsghdr;\n\tssize_t len;\n\n\tiovec.iov_len = *buflen;\n\tiovec.iov_base = buf;\n\tmemset(&msghdr, 0, sizeof(msghdr));\n\tmsghdr.msg_name = &sin6;\n\tmsghdr.msg_namelen = sizeof(sin6);\n\tmsghdr.msg_iov = &iovec;\n\tmsghdr.msg_iovlen = 1;\n\tmsghdr.msg_control = cbuf;\n\tmsghdr.msg_controllen = sizeof(cbuf);\n\n\tlen = recvmsg(sockfd, &msghdr, flags);\n\tif (len == -1)\n\t\treturn -errno;\n\t*buflen = len;\n\n\t/* Set ifindex to scope_id now. But since scope_id gets not\n\t * set by kernel for linklocal addresses, use pktinfo to obtain that\n\t * value right after.\n\t */\n\t*ifindex = sin6.sin6_scope_id;\n        for (cmsghdr = CMSG_FIRSTHDR(&msghdr); cmsghdr;\n\t     cmsghdr = CMSG_NXTHDR(&msghdr, cmsghdr)) {\n\t\tif (cmsghdr->cmsg_level == IPPROTO_IPV6 &&\n\t\t    cmsghdr->cmsg_type == IPV6_PKTINFO &&\n\t\t    cmsghdr->cmsg_len == CMSG_LEN(sizeof(struct in6_pktinfo))) {\n\t\t\tstruct in6_pktinfo *pktinfo;\n\n\t\t\tpktinfo = (struct in6_pktinfo *) CMSG_DATA(cmsghdr);\n\t\t\t*ifindex = pktinfo->ipi6_ifindex;\n\t\t}\n\t}\n\t*addr = sin6.sin6_addr;\n\n\treturn 0;\n}",
        "func": "static int myrecvfrom6(int sockfd, void *buf, size_t *buflen, int flags,\n\t\t       struct in6_addr *addr, uint32_t *ifindex, int *hoplimit)\n{\n\tstruct sockaddr_in6 sin6;\n\tunsigned char cbuf[2 * CMSG_SPACE(sizeof(struct in6_pktinfo))];\n\tstruct iovec iovec;\n\tstruct msghdr msghdr;\n\tstruct cmsghdr *cmsghdr;\n\tssize_t len;\n\n\tiovec.iov_len = *buflen;\n\tiovec.iov_base = buf;\n\tmemset(&msghdr, 0, sizeof(msghdr));\n\tmsghdr.msg_name = &sin6;\n\tmsghdr.msg_namelen = sizeof(sin6);\n\tmsghdr.msg_iov = &iovec;\n\tmsghdr.msg_iovlen = 1;\n\tmsghdr.msg_control = cbuf;\n\tmsghdr.msg_controllen = sizeof(cbuf);\n\n\tlen = recvmsg(sockfd, &msghdr, flags);\n\tif (len == -1)\n\t\treturn -errno;\n\t*buflen = len;\n\n\t/* Set ifindex to scope_id now. But since scope_id gets not\n\t * set by kernel for linklocal addresses, use pktinfo to obtain that\n\t * value right after.\n\t */\n\t*ifindex = sin6.sin6_scope_id;\n        for (cmsghdr = CMSG_FIRSTHDR(&msghdr); cmsghdr;\n\t     cmsghdr = CMSG_NXTHDR(&msghdr, cmsghdr)) {\n\t\tif (cmsghdr->cmsg_level != IPPROTO_IPV6)\n\t\t\tcontinue;\n\n\t\tswitch(cmsghdr->cmsg_type) {\n\t\tcase IPV6_PKTINFO:\n\t\t\tif (cmsghdr->cmsg_len == CMSG_LEN(sizeof(struct in6_pktinfo))) {\n\t\t\t\tstruct in6_pktinfo *pktinfo;\n\n\t\t\t\tpktinfo = (struct in6_pktinfo *) CMSG_DATA(cmsghdr);\n\t\t\t\t*ifindex = pktinfo->ipi6_ifindex;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase IPV6_HOPLIMIT:\n\t\t\tif (cmsghdr->cmsg_len == CMSG_LEN(sizeof(int))) {\n\t\t\t\tint *val;\n\n\t\t\t\tval = (int *) CMSG_DATA(cmsghdr);\n\t\t\t\t*hoplimit = *val;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\t*addr = sin6.sin6_addr;\n\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,8 +1,8 @@\n static int myrecvfrom6(int sockfd, void *buf, size_t *buflen, int flags,\n-\t\t       struct in6_addr *addr, uint32_t *ifindex)\n+\t\t       struct in6_addr *addr, uint32_t *ifindex, int *hoplimit)\n {\n \tstruct sockaddr_in6 sin6;\n-\tunsigned char cbuf[CMSG_SPACE(sizeof(struct in6_pktinfo))];\n+\tunsigned char cbuf[2 * CMSG_SPACE(sizeof(struct in6_pktinfo))];\n \tstruct iovec iovec;\n \tstruct msghdr msghdr;\n \tstruct cmsghdr *cmsghdr;\n@@ -30,13 +30,26 @@\n \t*ifindex = sin6.sin6_scope_id;\n         for (cmsghdr = CMSG_FIRSTHDR(&msghdr); cmsghdr;\n \t     cmsghdr = CMSG_NXTHDR(&msghdr, cmsghdr)) {\n-\t\tif (cmsghdr->cmsg_level == IPPROTO_IPV6 &&\n-\t\t    cmsghdr->cmsg_type == IPV6_PKTINFO &&\n-\t\t    cmsghdr->cmsg_len == CMSG_LEN(sizeof(struct in6_pktinfo))) {\n-\t\t\tstruct in6_pktinfo *pktinfo;\n+\t\tif (cmsghdr->cmsg_level != IPPROTO_IPV6)\n+\t\t\tcontinue;\n \n-\t\t\tpktinfo = (struct in6_pktinfo *) CMSG_DATA(cmsghdr);\n-\t\t\t*ifindex = pktinfo->ipi6_ifindex;\n+\t\tswitch(cmsghdr->cmsg_type) {\n+\t\tcase IPV6_PKTINFO:\n+\t\t\tif (cmsghdr->cmsg_len == CMSG_LEN(sizeof(struct in6_pktinfo))) {\n+\t\t\t\tstruct in6_pktinfo *pktinfo;\n+\n+\t\t\t\tpktinfo = (struct in6_pktinfo *) CMSG_DATA(cmsghdr);\n+\t\t\t\t*ifindex = pktinfo->ipi6_ifindex;\n+\t\t\t}\n+\t\t\tbreak;\n+\t\tcase IPV6_HOPLIMIT:\n+\t\t\tif (cmsghdr->cmsg_len == CMSG_LEN(sizeof(int))) {\n+\t\t\t\tint *val;\n+\n+\t\t\t\tval = (int *) CMSG_DATA(cmsghdr);\n+\t\t\t\t*hoplimit = *val;\n+\t\t\t}\n+\t\t\tbreak;\n \t\t}\n \t}\n \t*addr = sin6.sin6_addr;",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t       struct in6_addr *addr, uint32_t *ifindex)",
                "\tunsigned char cbuf[CMSG_SPACE(sizeof(struct in6_pktinfo))];",
                "\t\tif (cmsghdr->cmsg_level == IPPROTO_IPV6 &&",
                "\t\t    cmsghdr->cmsg_type == IPV6_PKTINFO &&",
                "\t\t    cmsghdr->cmsg_len == CMSG_LEN(sizeof(struct in6_pktinfo))) {",
                "\t\t\tstruct in6_pktinfo *pktinfo;",
                "\t\t\tpktinfo = (struct in6_pktinfo *) CMSG_DATA(cmsghdr);",
                "\t\t\t*ifindex = pktinfo->ipi6_ifindex;"
            ],
            "added_lines": [
                "\t\t       struct in6_addr *addr, uint32_t *ifindex, int *hoplimit)",
                "\tunsigned char cbuf[2 * CMSG_SPACE(sizeof(struct in6_pktinfo))];",
                "\t\tif (cmsghdr->cmsg_level != IPPROTO_IPV6)",
                "\t\t\tcontinue;",
                "\t\tswitch(cmsghdr->cmsg_type) {",
                "\t\tcase IPV6_PKTINFO:",
                "\t\t\tif (cmsghdr->cmsg_len == CMSG_LEN(sizeof(struct in6_pktinfo))) {",
                "\t\t\t\tstruct in6_pktinfo *pktinfo;",
                "",
                "\t\t\t\tpktinfo = (struct in6_pktinfo *) CMSG_DATA(cmsghdr);",
                "\t\t\t\t*ifindex = pktinfo->ipi6_ifindex;",
                "\t\t\t}",
                "\t\t\tbreak;",
                "\t\tcase IPV6_HOPLIMIT:",
                "\t\t\tif (cmsghdr->cmsg_len == CMSG_LEN(sizeof(int))) {",
                "\t\t\t\tint *val;",
                "",
                "\t\t\t\tval = (int *) CMSG_DATA(cmsghdr);",
                "\t\t\t\t*hoplimit = *val;",
                "\t\t\t}",
                "\t\t\tbreak;"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-3698",
        "func_name": "jpirko/libndp/ndp_sock_open",
        "description": "libndp before 1.6, as used in NetworkManager, does not properly validate the origin of Neighbor Discovery Protocol (NDP) messages, which allows remote attackers to conduct man-in-the-middle attacks or cause a denial of service (network connectivity disruption) by advertising a node as a router from a non-local network.",
        "git_url": "https://github.com/jpirko/libndp/commit/a4892df306e0532487f1634ba6d4c6d4bb381c7f",
        "commit_title": "libndp: validate the IPv6 hop limit",
        "commit_text": " None of the NDP messages should ever come from a non-local network; as stated in RFC4861's 6.1.1 (RS), 6.1.2 (RA), 7.1.1 (NS), 7.1.2 (NA), and 8.1. (redirect):    - The IP Hop Limit field has a value of 255, i.e., the packet     could not possibly have been forwarded by a router.  This fixes CVE-2016-3698.  Reported by: Julien BERNARD <julien.bernard@viagenie.ca>",
        "func_before": "static int ndp_sock_open(struct ndp *ndp)\n{\n\tint sock;\n\t//struct icmp6_filter flt;\n\tint ret;\n\tint err;\n\tint val;\n\n\tsock = socket(PF_INET6, SOCK_RAW, IPPROTO_ICMPV6);\n\tif (sock == -1) {\n\t\terr(ndp, \"Failed to create ICMP6 socket.\");\n\t\treturn -errno;\n\t}\n\n\tval = 1;\n\tret = setsockopt(sock, IPPROTO_IPV6, IPV6_RECVPKTINFO,\n\t\t\t &val, sizeof(val));\n\tif (ret == -1) {\n\t\terr(ndp, \"Failed to setsockopt IPV6_RECVPKTINFO.\");\n\t\terr = -errno;\n\t\tgoto close_sock;\n\t}\n\n\tval = 255;\n\tret = setsockopt(sock, IPPROTO_IPV6, IPV6_MULTICAST_HOPS,\n\t\t\t &val, sizeof(val));\n\tif (ret == -1) {\n\t\terr(ndp, \"Failed to setsockopt IPV6_MULTICAST_HOPS.\");\n\t\terr = -errno;\n\t\tgoto close_sock;\n\t}\n\n\tndp->sock = sock;\n\treturn 0;\nclose_sock:\n\tclose(sock);\n\treturn err;\n}",
        "func": "static int ndp_sock_open(struct ndp *ndp)\n{\n\tint sock;\n\t//struct icmp6_filter flt;\n\tint ret;\n\tint err;\n\tint val;\n\n\tsock = socket(PF_INET6, SOCK_RAW, IPPROTO_ICMPV6);\n\tif (sock == -1) {\n\t\terr(ndp, \"Failed to create ICMP6 socket.\");\n\t\treturn -errno;\n\t}\n\n\tval = 1;\n\tret = setsockopt(sock, IPPROTO_IPV6, IPV6_RECVPKTINFO,\n\t\t\t &val, sizeof(val));\n\tif (ret == -1) {\n\t\terr(ndp, \"Failed to setsockopt IPV6_RECVPKTINFO.\");\n\t\terr = -errno;\n\t\tgoto close_sock;\n\t}\n\n\tval = 255;\n\tret = setsockopt(sock, IPPROTO_IPV6, IPV6_MULTICAST_HOPS,\n\t\t\t &val, sizeof(val));\n\tif (ret == -1) {\n\t\terr(ndp, \"Failed to setsockopt IPV6_MULTICAST_HOPS.\");\n\t\terr = -errno;\n\t\tgoto close_sock;\n\t}\n\n\tval = 1;\n\tret = setsockopt(sock, IPPROTO_IPV6, IPV6_RECVHOPLIMIT,\n\t\t\t &val, sizeof(val));\n\tif (ret == -1) {\n\t\terr(ndp, \"Failed to setsockopt IPV6_RECVHOPLIMIT,.\");\n\t\terr = -errno;\n\t\tgoto close_sock;\n\t}\n\n\tndp->sock = sock;\n\treturn 0;\nclose_sock:\n\tclose(sock);\n\treturn err;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -30,6 +30,15 @@\n \t\tgoto close_sock;\n \t}\n \n+\tval = 1;\n+\tret = setsockopt(sock, IPPROTO_IPV6, IPV6_RECVHOPLIMIT,\n+\t\t\t &val, sizeof(val));\n+\tif (ret == -1) {\n+\t\terr(ndp, \"Failed to setsockopt IPV6_RECVHOPLIMIT,.\");\n+\t\terr = -errno;\n+\t\tgoto close_sock;\n+\t}\n+\n \tndp->sock = sock;\n \treturn 0;\n close_sock:",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tval = 1;",
                "\tret = setsockopt(sock, IPPROTO_IPV6, IPV6_RECVHOPLIMIT,",
                "\t\t\t &val, sizeof(val));",
                "\tif (ret == -1) {",
                "\t\terr(ndp, \"Failed to setsockopt IPV6_RECVHOPLIMIT,.\");",
                "\t\terr = -errno;",
                "\t\tgoto close_sock;",
                "\t}",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2016-3698",
        "func_name": "jpirko/libndp/ndp_sock_recv",
        "description": "libndp before 1.6, as used in NetworkManager, does not properly validate the origin of Neighbor Discovery Protocol (NDP) messages, which allows remote attackers to conduct man-in-the-middle attacks or cause a denial of service (network connectivity disruption) by advertising a node as a router from a non-local network.",
        "git_url": "https://github.com/jpirko/libndp/commit/a4892df306e0532487f1634ba6d4c6d4bb381c7f",
        "commit_title": "libndp: validate the IPv6 hop limit",
        "commit_text": " None of the NDP messages should ever come from a non-local network; as stated in RFC4861's 6.1.1 (RS), 6.1.2 (RA), 7.1.1 (NS), 7.1.2 (NA), and 8.1. (redirect):    - The IP Hop Limit field has a value of 255, i.e., the packet     could not possibly have been forwarded by a router.  This fixes CVE-2016-3698.  Reported by: Julien BERNARD <julien.bernard@viagenie.ca>",
        "func_before": "static int ndp_sock_recv(struct ndp *ndp)\n{\n\tstruct ndp_msg *msg;\n\tenum ndp_msg_type msg_type;\n\tsize_t len;\n\tint err;\n\n\tmsg = ndp_msg_alloc();\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tlen = ndp_msg_payload_maxlen(msg);\n\terr = myrecvfrom6(ndp->sock, msg->buf, &len, 0,\n\t\t\t  &msg->addrto, &msg->ifindex);\n\tif (err) {\n\t\terr(ndp, \"Failed to receive message\");\n\t\tgoto free_msg;\n\t}\n\tdbg(ndp, \"rcvd from: %s, ifindex: %u\",\n\t\t str_in6_addr(&msg->addrto), msg->ifindex);\n\n\tif (len < sizeof(*msg->icmp6_hdr)) {\n\t\twarn(ndp, \"rcvd icmp6 packet too short (%luB)\", len);\n\t\terr = 0;\n\t\tgoto free_msg;\n\t}\n\terr = ndp_msg_type_by_raw_type(&msg_type, msg->icmp6_hdr->icmp6_type);\n\tif (err) {\n\t\terr = 0;\n\t\tgoto free_msg;\n\t}\n\tndp_msg_init(msg, msg_type);\n\tndp_msg_payload_len_set(msg, len);\n\n\tif (!ndp_msg_check_valid(msg)) {\n\t\twarn(ndp, \"rcvd invalid ND message\");\n\t\terr = 0;\n\t\tgoto free_msg;\n\t}\n\n\tdbg(ndp, \"rcvd %s, len: %zuB\",\n\t\t ndp_msg_type_info(msg_type)->strabbr, len);\n\n\tif (!ndp_msg_check_opts(msg)) {\n\t\terr = 0;\n\t\tgoto free_msg;\n\t}\n\n\terr = ndp_call_handlers(ndp, msg);;\n\nfree_msg:\n\tndp_msg_destroy(msg);\n\treturn err;\n}",
        "func": "static int ndp_sock_recv(struct ndp *ndp)\n{\n\tstruct ndp_msg *msg;\n\tenum ndp_msg_type msg_type;\n\tsize_t len;\n\tint err;\n\n\tmsg = ndp_msg_alloc();\n\tif (!msg)\n\t\treturn -ENOMEM;\n\n\tlen = ndp_msg_payload_maxlen(msg);\n\terr = myrecvfrom6(ndp->sock, msg->buf, &len, 0,\n\t\t\t  &msg->addrto, &msg->ifindex, &msg->hoplimit);\n\tif (err) {\n\t\terr(ndp, \"Failed to receive message\");\n\t\tgoto free_msg;\n\t}\n\tdbg(ndp, \"rcvd from: %s, ifindex: %u, hoplimit: %d\",\n\t\t str_in6_addr(&msg->addrto), msg->ifindex, msg->hoplimit);\n\n\tif (msg->hoplimit != 255) {\n\t\twarn(ndp, \"ignoring packet with bad hop limit (%d)\", msg->hoplimit);\n\t\terr = 0;\n\t\tgoto free_msg;\n\t}\n\n\tif (len < sizeof(*msg->icmp6_hdr)) {\n\t\twarn(ndp, \"rcvd icmp6 packet too short (%luB)\", len);\n\t\terr = 0;\n\t\tgoto free_msg;\n\t}\n\terr = ndp_msg_type_by_raw_type(&msg_type, msg->icmp6_hdr->icmp6_type);\n\tif (err) {\n\t\terr = 0;\n\t\tgoto free_msg;\n\t}\n\tndp_msg_init(msg, msg_type);\n\tndp_msg_payload_len_set(msg, len);\n\n\tif (!ndp_msg_check_valid(msg)) {\n\t\twarn(ndp, \"rcvd invalid ND message\");\n\t\terr = 0;\n\t\tgoto free_msg;\n\t}\n\n\tdbg(ndp, \"rcvd %s, len: %zuB\",\n\t\t ndp_msg_type_info(msg_type)->strabbr, len);\n\n\tif (!ndp_msg_check_opts(msg)) {\n\t\terr = 0;\n\t\tgoto free_msg;\n\t}\n\n\terr = ndp_call_handlers(ndp, msg);;\n\nfree_msg:\n\tndp_msg_destroy(msg);\n\treturn err;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -11,13 +11,19 @@\n \n \tlen = ndp_msg_payload_maxlen(msg);\n \terr = myrecvfrom6(ndp->sock, msg->buf, &len, 0,\n-\t\t\t  &msg->addrto, &msg->ifindex);\n+\t\t\t  &msg->addrto, &msg->ifindex, &msg->hoplimit);\n \tif (err) {\n \t\terr(ndp, \"Failed to receive message\");\n \t\tgoto free_msg;\n \t}\n-\tdbg(ndp, \"rcvd from: %s, ifindex: %u\",\n-\t\t str_in6_addr(&msg->addrto), msg->ifindex);\n+\tdbg(ndp, \"rcvd from: %s, ifindex: %u, hoplimit: %d\",\n+\t\t str_in6_addr(&msg->addrto), msg->ifindex, msg->hoplimit);\n+\n+\tif (msg->hoplimit != 255) {\n+\t\twarn(ndp, \"ignoring packet with bad hop limit (%d)\", msg->hoplimit);\n+\t\terr = 0;\n+\t\tgoto free_msg;\n+\t}\n \n \tif (len < sizeof(*msg->icmp6_hdr)) {\n \t\twarn(ndp, \"rcvd icmp6 packet too short (%luB)\", len);",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\t  &msg->addrto, &msg->ifindex);",
                "\tdbg(ndp, \"rcvd from: %s, ifindex: %u\",",
                "\t\t str_in6_addr(&msg->addrto), msg->ifindex);"
            ],
            "added_lines": [
                "\t\t\t  &msg->addrto, &msg->ifindex, &msg->hoplimit);",
                "\tdbg(ndp, \"rcvd from: %s, ifindex: %u, hoplimit: %d\",",
                "\t\t str_in6_addr(&msg->addrto), msg->ifindex, msg->hoplimit);",
                "",
                "\tif (msg->hoplimit != 255) {",
                "\t\twarn(ndp, \"ignoring packet with bad hop limit (%d)\", msg->hoplimit);",
                "\t\terr = 0;",
                "\t\tgoto free_msg;",
                "\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2014-9422",
        "func_name": "krb5/check_rpcsec_auth",
        "description": "The check_rpcsec_auth function in kadmin/server/kadm_rpc_svc.c in kadmind in MIT Kerberos 5 (aka krb5) through 1.11.5, 1.12.x through 1.12.2, and 1.13.x before 1.13.1 allows remote authenticated users to bypass a kadmin/* authorization check and obtain administrative access by leveraging access to a two-component principal with an initial \"kadmind\" substring, as demonstrated by a \"ka/x\" principal.",
        "git_url": "https://github.com/krb5/krb5/commit/6609658db0799053fbef0d7d0aa2f1fd68ef32d8",
        "commit_title": "Fix kadmind server validation [CVE-2014-9422]",
        "commit_text": " [MITKRB5-SA-2015-001] In kadmind's check_rpcsec_auth(), use data_eq_string() instead of strncmp() to check components of the server principal, so that we don't erroneously match left substrings of \"kadmin\", \"history\", or the realm.  ticket: 8057 (new) target_version: 1.13.1 tags: pullup",
        "func_before": "static int\ncheck_rpcsec_auth(struct svc_req *rqstp)\n{\n     gss_ctx_id_t ctx;\n     krb5_context kctx;\n     OM_uint32 maj_stat, min_stat;\n     gss_name_t name;\n     krb5_principal princ;\n     int ret, success;\n     krb5_data *c1, *c2, *realm;\n     gss_buffer_desc gss_str;\n     kadm5_server_handle_t handle;\n     size_t slen;\n     char *sdots;\n\n     success = 0;\n     handle = (kadm5_server_handle_t)global_server_handle;\n\n     if (rqstp->rq_cred.oa_flavor != RPCSEC_GSS)\n\t  return 0;\n\n     ctx = rqstp->rq_svccred;\n\n     maj_stat = gss_inquire_context(&min_stat, ctx, NULL, &name,\n\t\t\t\t    NULL, NULL, NULL, NULL, NULL);\n     if (maj_stat != GSS_S_COMPLETE) {\n\t  krb5_klog_syslog(LOG_ERR, _(\"check_rpcsec_auth: failed \"\n\t\t\t\t      \"inquire_context, stat=%u\"), maj_stat);\n\t  log_badauth(maj_stat, min_stat, rqstp->rq_xprt, NULL);\n\t  goto fail_name;\n     }\n\n     kctx = handle->context;\n     ret = gss_to_krb5_name_1(rqstp, kctx, name, &princ, &gss_str);\n     if (ret == 0)\n\t  goto fail_name;\n\n     slen = gss_str.length;\n     trunc_name(&slen, &sdots);\n     /*\n      * Since we accept with GSS_C_NO_NAME, the client can authenticate\n      * against the entire kdb.  Therefore, ensure that the service\n      * name is something reasonable.\n      */\n     if (krb5_princ_size(kctx, princ) != 2)\n\t  goto fail_princ;\n\n     c1 = krb5_princ_component(kctx, princ, 0);\n     c2 = krb5_princ_component(kctx, princ, 1);\n     realm = krb5_princ_realm(kctx, princ);\n     if (strncmp(handle->params.realm, realm->data, realm->length) == 0\n\t && strncmp(\"kadmin\", c1->data, c1->length) == 0) {\n\n\t  if (strncmp(\"history\", c2->data, c2->length) == 0)\n\t       goto fail_princ;\n\t  else\n\t       success = 1;\n     }\n\nfail_princ:\n     if (!success) {\n\t krb5_klog_syslog(LOG_ERR, _(\"bad service principal %.*s%s\"),\n\t\t\t  (int) slen, (char *) gss_str.value, sdots);\n     }\n     gss_release_buffer(&min_stat, &gss_str);\n     krb5_free_principal(kctx, princ);\nfail_name:\n     gss_release_name(&min_stat, &name);\n     return success;\n}",
        "func": "static int\ncheck_rpcsec_auth(struct svc_req *rqstp)\n{\n     gss_ctx_id_t ctx;\n     krb5_context kctx;\n     OM_uint32 maj_stat, min_stat;\n     gss_name_t name;\n     krb5_principal princ;\n     int ret, success;\n     krb5_data *c1, *c2, *realm;\n     gss_buffer_desc gss_str;\n     kadm5_server_handle_t handle;\n     size_t slen;\n     char *sdots;\n\n     success = 0;\n     handle = (kadm5_server_handle_t)global_server_handle;\n\n     if (rqstp->rq_cred.oa_flavor != RPCSEC_GSS)\n\t  return 0;\n\n     ctx = rqstp->rq_svccred;\n\n     maj_stat = gss_inquire_context(&min_stat, ctx, NULL, &name,\n\t\t\t\t    NULL, NULL, NULL, NULL, NULL);\n     if (maj_stat != GSS_S_COMPLETE) {\n\t  krb5_klog_syslog(LOG_ERR, _(\"check_rpcsec_auth: failed \"\n\t\t\t\t      \"inquire_context, stat=%u\"), maj_stat);\n\t  log_badauth(maj_stat, min_stat, rqstp->rq_xprt, NULL);\n\t  goto fail_name;\n     }\n\n     kctx = handle->context;\n     ret = gss_to_krb5_name_1(rqstp, kctx, name, &princ, &gss_str);\n     if (ret == 0)\n\t  goto fail_name;\n\n     slen = gss_str.length;\n     trunc_name(&slen, &sdots);\n     /*\n      * Since we accept with GSS_C_NO_NAME, the client can authenticate\n      * against the entire kdb.  Therefore, ensure that the service\n      * name is something reasonable.\n      */\n     if (krb5_princ_size(kctx, princ) != 2)\n\t  goto fail_princ;\n\n     c1 = krb5_princ_component(kctx, princ, 0);\n     c2 = krb5_princ_component(kctx, princ, 1);\n     realm = krb5_princ_realm(kctx, princ);\n     success = data_eq_string(*realm, handle->params.realm) &&\n\t     data_eq_string(*c1, \"kadmin\") && !data_eq_string(*c2, \"history\");\n\nfail_princ:\n     if (!success) {\n\t krb5_klog_syslog(LOG_ERR, _(\"bad service principal %.*s%s\"),\n\t\t\t  (int) slen, (char *) gss_str.value, sdots);\n     }\n     gss_release_buffer(&min_stat, &gss_str);\n     krb5_free_principal(kctx, princ);\nfail_name:\n     gss_release_name(&min_stat, &name);\n     return success;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -48,14 +48,8 @@\n      c1 = krb5_princ_component(kctx, princ, 0);\n      c2 = krb5_princ_component(kctx, princ, 1);\n      realm = krb5_princ_realm(kctx, princ);\n-     if (strncmp(handle->params.realm, realm->data, realm->length) == 0\n-\t && strncmp(\"kadmin\", c1->data, c1->length) == 0) {\n-\n-\t  if (strncmp(\"history\", c2->data, c2->length) == 0)\n-\t       goto fail_princ;\n-\t  else\n-\t       success = 1;\n-     }\n+     success = data_eq_string(*realm, handle->params.realm) &&\n+\t     data_eq_string(*c1, \"kadmin\") && !data_eq_string(*c2, \"history\");\n \n fail_princ:\n      if (!success) {",
        "diff_line_info": {
            "deleted_lines": [
                "     if (strncmp(handle->params.realm, realm->data, realm->length) == 0",
                "\t && strncmp(\"kadmin\", c1->data, c1->length) == 0) {",
                "",
                "\t  if (strncmp(\"history\", c2->data, c2->length) == 0)",
                "\t       goto fail_princ;",
                "\t  else",
                "\t       success = 1;",
                "     }"
            ],
            "added_lines": [
                "     success = data_eq_string(*realm, handle->params.realm) &&",
                "\t     data_eq_string(*c1, \"kadmin\") && !data_eq_string(*c2, \"history\");"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-1253",
        "func_name": "chromium/insert",
        "description": "core/html/parser/HTMLConstructionSite.cpp in the DOM implementation in Blink, as used in Google Chrome before 43.0.2357.65, allows remote attackers to bypass the Same Origin Policy via crafted JavaScript code that appends a child to a SCRIPT element, related to the insert and executeReparentTask functions.",
        "git_url": "https://github.com/chromium/chromium/commit/ad6d56fe76a49244896156182c30d8e9ff3afbf2",
        "commit_title": "Supress script during parser adjusting DOM node location",
        "commit_text": " This attack uses HTML parser's tree tweaking operation to trigger a script execution. This CL supresses it. This should be acceptable because:   * It never happens with well-formed markup.  * It only happens to a node being a child of <script>, which is unusual.   ",
        "func_before": "static inline void insert(HTMLConstructionSiteTask& task)\n{\n    if (isHTMLTemplateElement(*task.parent))\n        task.parent = toHTMLTemplateElement(task.parent.get())->content();\n\n    if (ContainerNode* parent = task.child->parentNode())\n        parent->parserRemoveChild(*task.child);\n\n    if (task.nextChild)\n        task.parent->parserInsertBefore(task.child.get(), *task.nextChild);\n    else\n        task.parent->parserAppendChild(task.child.get());\n}",
        "func": "static inline void insert(HTMLConstructionSiteTask& task)\n{\n    if (isHTMLTemplateElement(*task.parent))\n        task.parent = toHTMLTemplateElement(task.parent.get())->content();\n\n    if (ContainerNode* parent = task.child->parentNode()) {\n        ScriptForbiddenScope forbidScript;\n        parent->parserRemoveChild(*task.child);\n    }\n\n    if (task.nextChild)\n        task.parent->parserInsertBefore(task.child.get(), *task.nextChild);\n    else\n        task.parent->parserAppendChild(task.child.get());\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,8 +3,10 @@\n     if (isHTMLTemplateElement(*task.parent))\n         task.parent = toHTMLTemplateElement(task.parent.get())->content();\n \n-    if (ContainerNode* parent = task.child->parentNode())\n+    if (ContainerNode* parent = task.child->parentNode()) {\n+        ScriptForbiddenScope forbidScript;\n         parent->parserRemoveChild(*task.child);\n+    }\n \n     if (task.nextChild)\n         task.parent->parserInsertBefore(task.child.get(), *task.nextChild);",
        "diff_line_info": {
            "deleted_lines": [
                "    if (ContainerNode* parent = task.child->parentNode())"
            ],
            "added_lines": [
                "    if (ContainerNode* parent = task.child->parentNode()) {",
                "        ScriptForbiddenScope forbidScript;",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-1253",
        "func_name": "chromium/executeReparentTask",
        "description": "core/html/parser/HTMLConstructionSite.cpp in the DOM implementation in Blink, as used in Google Chrome before 43.0.2357.65, allows remote attackers to bypass the Same Origin Policy via crafted JavaScript code that appends a child to a SCRIPT element, related to the insert and executeReparentTask functions.",
        "git_url": "https://github.com/chromium/chromium/commit/ad6d56fe76a49244896156182c30d8e9ff3afbf2",
        "commit_title": "Supress script during parser adjusting DOM node location",
        "commit_text": " This attack uses HTML parser's tree tweaking operation to trigger a script execution. This CL supresses it. This should be acceptable because:   * It never happens with well-formed markup.  * It only happens to a node being a child of <script>, which is unusual.   ",
        "func_before": "static inline void executeReparentTask(HTMLConstructionSiteTask& task)\n{\n    ASSERT(task.operation == HTMLConstructionSiteTask::Reparent);\n\n    if (ContainerNode* parent = task.child->parentNode())\n        parent->parserRemoveChild(*task.child);\n\n    task.parent->parserAppendChild(task.child);\n}",
        "func": "static inline void executeReparentTask(HTMLConstructionSiteTask& task)\n{\n    ASSERT(task.operation == HTMLConstructionSiteTask::Reparent);\n\n    if (ContainerNode* parent = task.child->parentNode()) {\n        ScriptForbiddenScope forbidScript;\n        parent->parserRemoveChild(*task.child);\n    }\n\n    task.parent->parserAppendChild(task.child);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,8 +2,10 @@\n {\n     ASSERT(task.operation == HTMLConstructionSiteTask::Reparent);\n \n-    if (ContainerNode* parent = task.child->parentNode())\n+    if (ContainerNode* parent = task.child->parentNode()) {\n+        ScriptForbiddenScope forbidScript;\n         parent->parserRemoveChild(*task.child);\n+    }\n \n     task.parent->parserAppendChild(task.child);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    if (ContainerNode* parent = task.child->parentNode())"
            ],
            "added_lines": [
                "    if (ContainerNode* parent = task.child->parentNode()) {",
                "        ScriptForbiddenScope forbidScript;",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-4300",
        "func_name": "ghostlander/Halcyon/CBlock::CheckBlock",
        "description": "A vulnerability has been found in ghostlander Halcyon and classified as critical. Affected by this vulnerability is the function CBlock::AddToBlockIndex of the file src/main.cpp of the component Block Verification. The manipulation leads to improper access controls. The attack can be launched remotely. Upgrading to version 1.1.1.0-hal is able to address this issue. The identifier of the patch is 0675b25ae9cc10b5fdc8ea3a32c642979762d45e. It is recommended to upgrade the affected component. The identifier VDB-217417 was assigned to this vulnerability.",
        "git_url": "https://github.com/ghostlander/Halcyon/commit/0675b25ae9cc10b5fdc8ea3a32c642979762d45e",
        "commit_title": "Block Verification Vulnerability Eliminated",
        "commit_text": " Fixed a critical vulnerability allowing to accept a proof-of-work block containing one or more coin stake transactions in addition to a valid coin base. Output values of such coin stakes were out of control.",
        "func_before": "bool CBlock::CheckBlock() const {\n\n    // These are checks that are independent of context\n    // that can be verified before saving an orphan block.\n\n    // Size limits\n    if (vtx.empty() || vtx.size() > MAX_BLOCK_SIZE || ::GetSerializeSize(*this, SER_NETWORK, PROTOCOL_VERSION) > MAX_BLOCK_SIZE)\n        return DoS(100, error(\"CheckBlock() : size limits failed\"));\n\n    if(IsProofOfWork()) {\n\n        /* Proof-of-work verification against target */\n        if(!CheckProofOfWork(GetHashPoW(), nBits))\n          return(DoS(50, error(\"CheckBlock() : proof-of-work verification failed\")));\n\n        /* Proof-of-work block signature verification */\n        if(!CheckBlockSignature())\n          return(DoS(100, error(\"CheckBlock() : bad proof-of-work block signature\")));\n    }\n\n    // Check timestamp\n    if (GetBlockTime() > FutureDrift(GetAdjustedTime()))\n        return error(\"CheckBlock() : block timestamp too far in the future\");\n\n    // First transaction must be coinbase, the rest must not be\n    if (vtx.empty() || !vtx[0].IsCoinBase())\n        return DoS(100, error(\"CheckBlock() : first tx is not coinbase\"));\n    for (unsigned int i = 1; i < vtx.size(); i++)\n        if (vtx[i].IsCoinBase())\n            return DoS(100, error(\"CheckBlock() : more than one coinbase\"));\n\n    // Check coinbase timestamp\n    if (GetBlockTime() > FutureDrift((int64_t)vtx[0].nTime))\n        return DoS(50, error(\"CheckBlock() : coinbase timestamp is too early\"));\n\n    if (IsProofOfStake())\n    {\n        // Coinbase output should be empty if proof-of-stake block\n        if (vtx[0].vout.size() != 1 || !vtx[0].vout[0].IsEmpty())\n            return DoS(100, error(\"CheckBlock() : coinbase output not empty for proof-of-stake block\"));\n\n        // Second transaction must be coinstake, the rest must not be\n        if (vtx.empty() || !vtx[1].IsCoinStake())\n            return DoS(100, error(\"CheckBlock() : second tx is not coinstake\"));\n        for (unsigned int i = 2; i < vtx.size(); i++)\n            if (vtx[i].IsCoinStake())\n                return DoS(100, error(\"CheckBlock() : more than one coinstake\"));\n\n        // Check coinstake timestamp\n        if (!CheckCoinStakeTimestamp(GetBlockTime(), (int64_t)vtx[1].nTime))\n            return DoS(50, error(\"CheckBlock() : coinstake timestamp violation nTimeBlock=%\"PRId64\" nTimeTx=%u\", GetBlockTime(), vtx[1].nTime));\n\n        // NovaCoin: check proof-of-stake block signature\n        if(!CheckBlockSignature())\n            return DoS(100, error(\"CheckBlock() : bad proof-of-stake block signature\"));\n    }\n\n    // Check transactions\n    BOOST_FOREACH(const CTransaction& tx, vtx)\n    {\n        if (!tx.CheckTransaction())\n            return DoS(tx.nDoS, error(\"CheckBlock() : CheckTransaction failed\"));\n\n        // ppcoin: check transaction timestamp\n        if (GetBlockTime() < (int64_t)tx.nTime)\n            return DoS(50, error(\"CheckBlock() : block timestamp earlier than transaction timestamp\"));\n    }\n\n    /* Merkle root verification */\n    if(hashMerkleRoot != BuildMerkleTree())\n      return(DoS(100, error(\"CheckBlock() : merkle root verification failed\")));\n\n    /* Check for duplicate transactions */\n    set<uint256> uniqueTx;\n    BOOST_FOREACH(const CTransaction& tx, vtx) {\n        uniqueTx.insert(tx.GetHash());\n    }\n    if(uniqueTx.size() != vtx.size())\n      return(DoS(100, error(\"CheckBlock() : duplicate transaction found\")));\n\n    unsigned int nSigOps = 0;\n    BOOST_FOREACH(const CTransaction& tx, vtx)\n    {\n        nSigOps += tx.GetLegacySigOpCount();\n    }\n    if (nSigOps > MAX_BLOCK_SIGOPS)\n        return DoS(100, error(\"CheckBlock() : out-of-bounds SigOpCount\"));\n\n    return(true);\n}",
        "func": "bool CBlock::CheckBlock() const {\n    uint i;\n\n    // These are checks that are independent of context\n    // that can be verified before saving an orphan block.\n\n    // Size limits\n    if (vtx.empty() || vtx.size() > MAX_BLOCK_SIZE || ::GetSerializeSize(*this, SER_NETWORK, PROTOCOL_VERSION) > MAX_BLOCK_SIZE)\n        return DoS(100, error(\"CheckBlock() : size limits failed\"));\n\n    // Check timestamp\n    if (GetBlockTime() > FutureDrift(GetAdjustedTime()))\n        return error(\"CheckBlock() : block timestamp too far in the future\");\n\n    // First transaction must be coinbase, the rest must not be\n    if (vtx.empty() || !vtx[0].IsCoinBase())\n        return DoS(100, error(\"CheckBlock() : first tx is not coinbase\"));\n    for(i = 1; i < vtx.size(); i++) {\n        if(vtx[i].IsCoinBase())\n          return(DoS(100, error(\"CheckBlock() : more than one coin base\")));\n    }\n\n    // Check coinbase timestamp\n    if (GetBlockTime() > FutureDrift((int64_t)vtx[0].nTime))\n        return DoS(50, error(\"CheckBlock() : coinbase timestamp is too early\"));\n\n    if(IsProofOfStake()) {\n\n        // Coinbase output should be empty if proof-of-stake block\n        if (vtx[0].vout.size() != 1 || !vtx[0].vout[0].IsEmpty())\n            return DoS(100, error(\"CheckBlock() : coinbase output not empty for proof-of-stake block\"));\n\n        // Second transaction must be coinstake, the rest must not be\n        if (vtx.empty() || !vtx[1].IsCoinStake())\n            return DoS(100, error(\"CheckBlock() : second tx is not coinstake\"));\n        for(i = 2; i < vtx.size(); i++) {\n            if(vtx[i].IsCoinStake())\n              return(DoS(100, error(\"CheckBlock() : more than one coin stake\")));\n        }\n\n        // Check coinstake timestamp\n        if (!CheckCoinStakeTimestamp(GetBlockTime(), (int64_t)vtx[1].nTime))\n            return DoS(50, error(\"CheckBlock() : coinstake timestamp violation nTimeBlock=%\"PRId64\" nTimeTx=%u\", GetBlockTime(), vtx[1].nTime));\n\n        // NovaCoin: check proof-of-stake block signature\n        if(!CheckBlockSignature())\n            return DoS(100, error(\"CheckBlock() : bad proof-of-stake block signature\"));\n\n    } else {\n\n        /* No coin stakes in PoW blocks */\n        for(i = 1; i < vtx.size(); i++) {\n            if(vtx[i].IsCoinStake() && (vtx[i].nTime > 1626307200))\n              return(DoS(100, error(\"CheckBlock() : rogue coin stake\")));\n        }\n\n        /* Proof-of-work verification against target */\n        if(!CheckProofOfWork(GetHashPoW(), nBits))\n          return(DoS(50, error(\"CheckBlock() : proof-of-work verification failed\")));\n\n        /* Proof-of-work block signature verification */\n        if(!CheckBlockSignature())\n          return(DoS(100, error(\"CheckBlock() : bad proof-of-work block signature\")));\n    }\n\n    // Check transactions\n    BOOST_FOREACH(const CTransaction& tx, vtx)\n    {\n        if (!tx.CheckTransaction())\n            return DoS(tx.nDoS, error(\"CheckBlock() : CheckTransaction failed\"));\n\n        // ppcoin: check transaction timestamp\n        if (GetBlockTime() < (int64_t)tx.nTime)\n            return DoS(50, error(\"CheckBlock() : block timestamp earlier than transaction timestamp\"));\n    }\n\n    /* Merkle root verification */\n    if(hashMerkleRoot != BuildMerkleTree())\n      return(DoS(100, error(\"CheckBlock() : merkle root verification failed\")));\n\n    /* Check for duplicate transactions */\n    set<uint256> uniqueTx;\n    BOOST_FOREACH(const CTransaction& tx, vtx) {\n        uniqueTx.insert(tx.GetHash());\n    }\n    if(uniqueTx.size() != vtx.size())\n      return(DoS(100, error(\"CheckBlock() : duplicate transaction found\")));\n\n    unsigned int nSigOps = 0;\n    BOOST_FOREACH(const CTransaction& tx, vtx)\n    {\n        nSigOps += tx.GetLegacySigOpCount();\n    }\n    if (nSigOps > MAX_BLOCK_SIGOPS)\n        return DoS(100, error(\"CheckBlock() : out-of-bounds SigOpCount\"));\n\n    return(true);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,5 @@\n bool CBlock::CheckBlock() const {\n+    uint i;\n \n     // These are checks that are independent of context\n     // that can be verified before saving an orphan block.\n@@ -7,7 +8,51 @@\n     if (vtx.empty() || vtx.size() > MAX_BLOCK_SIZE || ::GetSerializeSize(*this, SER_NETWORK, PROTOCOL_VERSION) > MAX_BLOCK_SIZE)\n         return DoS(100, error(\"CheckBlock() : size limits failed\"));\n \n-    if(IsProofOfWork()) {\n+    // Check timestamp\n+    if (GetBlockTime() > FutureDrift(GetAdjustedTime()))\n+        return error(\"CheckBlock() : block timestamp too far in the future\");\n+\n+    // First transaction must be coinbase, the rest must not be\n+    if (vtx.empty() || !vtx[0].IsCoinBase())\n+        return DoS(100, error(\"CheckBlock() : first tx is not coinbase\"));\n+    for(i = 1; i < vtx.size(); i++) {\n+        if(vtx[i].IsCoinBase())\n+          return(DoS(100, error(\"CheckBlock() : more than one coin base\")));\n+    }\n+\n+    // Check coinbase timestamp\n+    if (GetBlockTime() > FutureDrift((int64_t)vtx[0].nTime))\n+        return DoS(50, error(\"CheckBlock() : coinbase timestamp is too early\"));\n+\n+    if(IsProofOfStake()) {\n+\n+        // Coinbase output should be empty if proof-of-stake block\n+        if (vtx[0].vout.size() != 1 || !vtx[0].vout[0].IsEmpty())\n+            return DoS(100, error(\"CheckBlock() : coinbase output not empty for proof-of-stake block\"));\n+\n+        // Second transaction must be coinstake, the rest must not be\n+        if (vtx.empty() || !vtx[1].IsCoinStake())\n+            return DoS(100, error(\"CheckBlock() : second tx is not coinstake\"));\n+        for(i = 2; i < vtx.size(); i++) {\n+            if(vtx[i].IsCoinStake())\n+              return(DoS(100, error(\"CheckBlock() : more than one coin stake\")));\n+        }\n+\n+        // Check coinstake timestamp\n+        if (!CheckCoinStakeTimestamp(GetBlockTime(), (int64_t)vtx[1].nTime))\n+            return DoS(50, error(\"CheckBlock() : coinstake timestamp violation nTimeBlock=%\"PRId64\" nTimeTx=%u\", GetBlockTime(), vtx[1].nTime));\n+\n+        // NovaCoin: check proof-of-stake block signature\n+        if(!CheckBlockSignature())\n+            return DoS(100, error(\"CheckBlock() : bad proof-of-stake block signature\"));\n+\n+    } else {\n+\n+        /* No coin stakes in PoW blocks */\n+        for(i = 1; i < vtx.size(); i++) {\n+            if(vtx[i].IsCoinStake() && (vtx[i].nTime > 1626307200))\n+              return(DoS(100, error(\"CheckBlock() : rogue coin stake\")));\n+        }\n \n         /* Proof-of-work verification against target */\n         if(!CheckProofOfWork(GetHashPoW(), nBits))\n@@ -16,43 +61,6 @@\n         /* Proof-of-work block signature verification */\n         if(!CheckBlockSignature())\n           return(DoS(100, error(\"CheckBlock() : bad proof-of-work block signature\")));\n-    }\n-\n-    // Check timestamp\n-    if (GetBlockTime() > FutureDrift(GetAdjustedTime()))\n-        return error(\"CheckBlock() : block timestamp too far in the future\");\n-\n-    // First transaction must be coinbase, the rest must not be\n-    if (vtx.empty() || !vtx[0].IsCoinBase())\n-        return DoS(100, error(\"CheckBlock() : first tx is not coinbase\"));\n-    for (unsigned int i = 1; i < vtx.size(); i++)\n-        if (vtx[i].IsCoinBase())\n-            return DoS(100, error(\"CheckBlock() : more than one coinbase\"));\n-\n-    // Check coinbase timestamp\n-    if (GetBlockTime() > FutureDrift((int64_t)vtx[0].nTime))\n-        return DoS(50, error(\"CheckBlock() : coinbase timestamp is too early\"));\n-\n-    if (IsProofOfStake())\n-    {\n-        // Coinbase output should be empty if proof-of-stake block\n-        if (vtx[0].vout.size() != 1 || !vtx[0].vout[0].IsEmpty())\n-            return DoS(100, error(\"CheckBlock() : coinbase output not empty for proof-of-stake block\"));\n-\n-        // Second transaction must be coinstake, the rest must not be\n-        if (vtx.empty() || !vtx[1].IsCoinStake())\n-            return DoS(100, error(\"CheckBlock() : second tx is not coinstake\"));\n-        for (unsigned int i = 2; i < vtx.size(); i++)\n-            if (vtx[i].IsCoinStake())\n-                return DoS(100, error(\"CheckBlock() : more than one coinstake\"));\n-\n-        // Check coinstake timestamp\n-        if (!CheckCoinStakeTimestamp(GetBlockTime(), (int64_t)vtx[1].nTime))\n-            return DoS(50, error(\"CheckBlock() : coinstake timestamp violation nTimeBlock=%\"PRId64\" nTimeTx=%u\", GetBlockTime(), vtx[1].nTime));\n-\n-        // NovaCoin: check proof-of-stake block signature\n-        if(!CheckBlockSignature())\n-            return DoS(100, error(\"CheckBlock() : bad proof-of-stake block signature\"));\n     }\n \n     // Check transactions",
        "diff_line_info": {
            "deleted_lines": [
                "    if(IsProofOfWork()) {",
                "    }",
                "",
                "    // Check timestamp",
                "    if (GetBlockTime() > FutureDrift(GetAdjustedTime()))",
                "        return error(\"CheckBlock() : block timestamp too far in the future\");",
                "",
                "    // First transaction must be coinbase, the rest must not be",
                "    if (vtx.empty() || !vtx[0].IsCoinBase())",
                "        return DoS(100, error(\"CheckBlock() : first tx is not coinbase\"));",
                "    for (unsigned int i = 1; i < vtx.size(); i++)",
                "        if (vtx[i].IsCoinBase())",
                "            return DoS(100, error(\"CheckBlock() : more than one coinbase\"));",
                "",
                "    // Check coinbase timestamp",
                "    if (GetBlockTime() > FutureDrift((int64_t)vtx[0].nTime))",
                "        return DoS(50, error(\"CheckBlock() : coinbase timestamp is too early\"));",
                "",
                "    if (IsProofOfStake())",
                "    {",
                "        // Coinbase output should be empty if proof-of-stake block",
                "        if (vtx[0].vout.size() != 1 || !vtx[0].vout[0].IsEmpty())",
                "            return DoS(100, error(\"CheckBlock() : coinbase output not empty for proof-of-stake block\"));",
                "",
                "        // Second transaction must be coinstake, the rest must not be",
                "        if (vtx.empty() || !vtx[1].IsCoinStake())",
                "            return DoS(100, error(\"CheckBlock() : second tx is not coinstake\"));",
                "        for (unsigned int i = 2; i < vtx.size(); i++)",
                "            if (vtx[i].IsCoinStake())",
                "                return DoS(100, error(\"CheckBlock() : more than one coinstake\"));",
                "",
                "        // Check coinstake timestamp",
                "        if (!CheckCoinStakeTimestamp(GetBlockTime(), (int64_t)vtx[1].nTime))",
                "            return DoS(50, error(\"CheckBlock() : coinstake timestamp violation nTimeBlock=%\"PRId64\" nTimeTx=%u\", GetBlockTime(), vtx[1].nTime));",
                "",
                "        // NovaCoin: check proof-of-stake block signature",
                "        if(!CheckBlockSignature())",
                "            return DoS(100, error(\"CheckBlock() : bad proof-of-stake block signature\"));"
            ],
            "added_lines": [
                "    uint i;",
                "    // Check timestamp",
                "    if (GetBlockTime() > FutureDrift(GetAdjustedTime()))",
                "        return error(\"CheckBlock() : block timestamp too far in the future\");",
                "",
                "    // First transaction must be coinbase, the rest must not be",
                "    if (vtx.empty() || !vtx[0].IsCoinBase())",
                "        return DoS(100, error(\"CheckBlock() : first tx is not coinbase\"));",
                "    for(i = 1; i < vtx.size(); i++) {",
                "        if(vtx[i].IsCoinBase())",
                "          return(DoS(100, error(\"CheckBlock() : more than one coin base\")));",
                "    }",
                "",
                "    // Check coinbase timestamp",
                "    if (GetBlockTime() > FutureDrift((int64_t)vtx[0].nTime))",
                "        return DoS(50, error(\"CheckBlock() : coinbase timestamp is too early\"));",
                "",
                "    if(IsProofOfStake()) {",
                "",
                "        // Coinbase output should be empty if proof-of-stake block",
                "        if (vtx[0].vout.size() != 1 || !vtx[0].vout[0].IsEmpty())",
                "            return DoS(100, error(\"CheckBlock() : coinbase output not empty for proof-of-stake block\"));",
                "",
                "        // Second transaction must be coinstake, the rest must not be",
                "        if (vtx.empty() || !vtx[1].IsCoinStake())",
                "            return DoS(100, error(\"CheckBlock() : second tx is not coinstake\"));",
                "        for(i = 2; i < vtx.size(); i++) {",
                "            if(vtx[i].IsCoinStake())",
                "              return(DoS(100, error(\"CheckBlock() : more than one coin stake\")));",
                "        }",
                "",
                "        // Check coinstake timestamp",
                "        if (!CheckCoinStakeTimestamp(GetBlockTime(), (int64_t)vtx[1].nTime))",
                "            return DoS(50, error(\"CheckBlock() : coinstake timestamp violation nTimeBlock=%\"PRId64\" nTimeTx=%u\", GetBlockTime(), vtx[1].nTime));",
                "",
                "        // NovaCoin: check proof-of-stake block signature",
                "        if(!CheckBlockSignature())",
                "            return DoS(100, error(\"CheckBlock() : bad proof-of-stake block signature\"));",
                "",
                "    } else {",
                "",
                "        /* No coin stakes in PoW blocks */",
                "        for(i = 1; i < vtx.size(); i++) {",
                "            if(vtx[i].IsCoinStake() && (vtx[i].nTime > 1626307200))",
                "              return(DoS(100, error(\"CheckBlock() : rogue coin stake\")));",
                "        }"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-3713",
        "func_name": "torvalds/linux/msr_mtrr_valid",
        "description": "The msr_mtrr_valid function in arch/x86/kvm/mtrr.c in the Linux kernel before 4.6.1 supports MSR 0x2f8, which allows guest OS users to read or write to the kvm_arch_vcpu data structure, and consequently obtain sensitive information or cause a denial of service (system crash), via a crafted ioctl call.",
        "git_url": "https://github.com/torvalds/linux/commit/9842df62004f366b9fed2423e24df10542ee0dc5",
        "commit_title": "KVM: MTRR: remove MSR 0x2f8",
        "commit_text": " MSR 0x2f8 accessed the 124th Variable Range MTRR ever since MTRR support was introduced by 9ba075a664df (\"KVM: MTRR support\").  0x2f8 became harmful when 910a6aae4e2e (\"KVM: MTRR: exactly define the size of variable MTRRs\") shrinked the array of VR MTRRs from 256 to 8, which made access to index 124 out of bounds.  The surrounding code only WARNs in this situation, thus the guest gained a limited read/write access to struct kvm_arch_vcpu.  0x2f8 is not a valid VR MTRR MSR, because KVM has/advertises only 16 VR MTRR MSRs, 0x200-0x20f.  Every VR MTRR is set up using two MSRs, 0x2f8 was treated as a PHYSBASE and 0x2f9 would be its PHYSMASK, but 0x2f9 was not implemented in KVM, therefore 0x2f8 could never do anything useful and getting rid of it is safe.  This fixes CVE-2016-3713.  Cc: stable@vger.kernel.org",
        "func_before": "static bool msr_mtrr_valid(unsigned msr)\n{\n\tswitch (msr) {\n\tcase 0x200 ... 0x200 + 2 * KVM_NR_VAR_MTRR - 1:\n\tcase MSR_MTRRfix64K_00000:\n\tcase MSR_MTRRfix16K_80000:\n\tcase MSR_MTRRfix16K_A0000:\n\tcase MSR_MTRRfix4K_C0000:\n\tcase MSR_MTRRfix4K_C8000:\n\tcase MSR_MTRRfix4K_D0000:\n\tcase MSR_MTRRfix4K_D8000:\n\tcase MSR_MTRRfix4K_E0000:\n\tcase MSR_MTRRfix4K_E8000:\n\tcase MSR_MTRRfix4K_F0000:\n\tcase MSR_MTRRfix4K_F8000:\n\tcase MSR_MTRRdefType:\n\tcase MSR_IA32_CR_PAT:\n\t\treturn true;\n\tcase 0x2f8:\n\t\treturn true;\n\t}\n\treturn false;\n}",
        "func": "static bool msr_mtrr_valid(unsigned msr)\n{\n\tswitch (msr) {\n\tcase 0x200 ... 0x200 + 2 * KVM_NR_VAR_MTRR - 1:\n\tcase MSR_MTRRfix64K_00000:\n\tcase MSR_MTRRfix16K_80000:\n\tcase MSR_MTRRfix16K_A0000:\n\tcase MSR_MTRRfix4K_C0000:\n\tcase MSR_MTRRfix4K_C8000:\n\tcase MSR_MTRRfix4K_D0000:\n\tcase MSR_MTRRfix4K_D8000:\n\tcase MSR_MTRRfix4K_E0000:\n\tcase MSR_MTRRfix4K_E8000:\n\tcase MSR_MTRRfix4K_F0000:\n\tcase MSR_MTRRfix4K_F8000:\n\tcase MSR_MTRRdefType:\n\tcase MSR_IA32_CR_PAT:\n\t\treturn true;\n\t}\n\treturn false;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -16,8 +16,6 @@\n \tcase MSR_MTRRdefType:\n \tcase MSR_IA32_CR_PAT:\n \t\treturn true;\n-\tcase 0x2f8:\n-\t\treturn true;\n \t}\n \treturn false;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tcase 0x2f8:",
                "\t\treturn true;"
            ],
            "added_lines": []
        }
    },
    {
        "cve_id": "CVE-2016-1237",
        "func_name": "torvalds/linux/nfsacld_proc_setacl",
        "description": "nfsd in the Linux kernel through 4.6.3 allows local users to bypass intended file-permission restrictions by setting a POSIX ACL, related to nfs2acl.c, nfs3acl.c, and nfs4acl.c.",
        "git_url": "https://github.com/torvalds/linux/commit/999653786df6954a31044528ac3f7a5dadca08f4",
        "commit_title": "nfsd: check permissions when setting ACLs",
        "commit_text": " Use set_posix_acl, which includes proper permission checks, instead of calling ->set_acl directly.  Without this anyone may be able to grant themselves permissions to a file by setting the ACL.  Lock the inode to make the new checks atomic with respect to set_acl. (Also, nfsd was the only caller of set_acl not locking the inode, so I suspect this may fix other races.)  This also simplifies the code, and ensures our ACLs are checked by posix_acl_valid.  The permission checks and the inode locking were lost with commit 4ac7249e, which changed nfsd to use the set_acl inode operation directly instead of going through xattr handlers.  [agreunba@redhat.com: use set_posix_acl] Cc: Christoph Hellwig <hch@infradead.org> Cc: Al Viro <viro@zeniv.linux.org.uk> Cc: stable@vger.kernel.org",
        "func_before": "static __be32 nfsacld_proc_setacl(struct svc_rqst * rqstp,\n\t\tstruct nfsd3_setaclargs *argp,\n\t\tstruct nfsd_attrstat *resp)\n{\n\tstruct inode *inode;\n\tsvc_fh *fh;\n\t__be32 nfserr = 0;\n\tint error;\n\n\tdprintk(\"nfsd: SETACL(2acl)   %s\\n\", SVCFH_fmt(&argp->fh));\n\n\tfh = fh_copy(&resp->fh, &argp->fh);\n\tnfserr = fh_verify(rqstp, &resp->fh, 0, NFSD_MAY_SATTR);\n\tif (nfserr)\n\t\tgoto out;\n\n\tinode = d_inode(fh->fh_dentry);\n\tif (!IS_POSIXACL(inode) || !inode->i_op->set_acl) {\n\t\terror = -EOPNOTSUPP;\n\t\tgoto out_errno;\n\t}\n\n\terror = fh_want_write(fh);\n\tif (error)\n\t\tgoto out_errno;\n\n\terror = inode->i_op->set_acl(inode, argp->acl_access, ACL_TYPE_ACCESS);\n\tif (error)\n\t\tgoto out_drop_write;\n\terror = inode->i_op->set_acl(inode, argp->acl_default,\n\t\t\t\t     ACL_TYPE_DEFAULT);\n\tif (error)\n\t\tgoto out_drop_write;\n\n\tfh_drop_write(fh);\n\n\tnfserr = fh_getattr(fh, &resp->stat);\n\nout:\n\t/* argp->acl_{access,default} may have been allocated in\n\t   nfssvc_decode_setaclargs. */\n\tposix_acl_release(argp->acl_access);\n\tposix_acl_release(argp->acl_default);\n\treturn nfserr;\nout_drop_write:\n\tfh_drop_write(fh);\nout_errno:\n\tnfserr = nfserrno(error);\n\tgoto out;\n}",
        "func": "static __be32 nfsacld_proc_setacl(struct svc_rqst * rqstp,\n\t\tstruct nfsd3_setaclargs *argp,\n\t\tstruct nfsd_attrstat *resp)\n{\n\tstruct inode *inode;\n\tsvc_fh *fh;\n\t__be32 nfserr = 0;\n\tint error;\n\n\tdprintk(\"nfsd: SETACL(2acl)   %s\\n\", SVCFH_fmt(&argp->fh));\n\n\tfh = fh_copy(&resp->fh, &argp->fh);\n\tnfserr = fh_verify(rqstp, &resp->fh, 0, NFSD_MAY_SATTR);\n\tif (nfserr)\n\t\tgoto out;\n\n\tinode = d_inode(fh->fh_dentry);\n\n\terror = fh_want_write(fh);\n\tif (error)\n\t\tgoto out_errno;\n\n\tfh_lock(fh);\n\n\terror = set_posix_acl(inode, ACL_TYPE_ACCESS, argp->acl_access);\n\tif (error)\n\t\tgoto out_drop_lock;\n\terror = set_posix_acl(inode, ACL_TYPE_DEFAULT, argp->acl_default);\n\tif (error)\n\t\tgoto out_drop_lock;\n\n\tfh_unlock(fh);\n\n\tfh_drop_write(fh);\n\n\tnfserr = fh_getattr(fh, &resp->stat);\n\nout:\n\t/* argp->acl_{access,default} may have been allocated in\n\t   nfssvc_decode_setaclargs. */\n\tposix_acl_release(argp->acl_access);\n\tposix_acl_release(argp->acl_default);\n\treturn nfserr;\nout_drop_lock:\n\tfh_unlock(fh);\n\tfh_drop_write(fh);\nout_errno:\n\tnfserr = nfserrno(error);\n\tgoto out;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -15,22 +15,21 @@\n \t\tgoto out;\n \n \tinode = d_inode(fh->fh_dentry);\n-\tif (!IS_POSIXACL(inode) || !inode->i_op->set_acl) {\n-\t\terror = -EOPNOTSUPP;\n-\t\tgoto out_errno;\n-\t}\n \n \terror = fh_want_write(fh);\n \tif (error)\n \t\tgoto out_errno;\n \n-\terror = inode->i_op->set_acl(inode, argp->acl_access, ACL_TYPE_ACCESS);\n+\tfh_lock(fh);\n+\n+\terror = set_posix_acl(inode, ACL_TYPE_ACCESS, argp->acl_access);\n \tif (error)\n-\t\tgoto out_drop_write;\n-\terror = inode->i_op->set_acl(inode, argp->acl_default,\n-\t\t\t\t     ACL_TYPE_DEFAULT);\n+\t\tgoto out_drop_lock;\n+\terror = set_posix_acl(inode, ACL_TYPE_DEFAULT, argp->acl_default);\n \tif (error)\n-\t\tgoto out_drop_write;\n+\t\tgoto out_drop_lock;\n+\n+\tfh_unlock(fh);\n \n \tfh_drop_write(fh);\n \n@@ -42,7 +41,8 @@\n \tposix_acl_release(argp->acl_access);\n \tposix_acl_release(argp->acl_default);\n \treturn nfserr;\n-out_drop_write:\n+out_drop_lock:\n+\tfh_unlock(fh);\n \tfh_drop_write(fh);\n out_errno:\n \tnfserr = nfserrno(error);",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (!IS_POSIXACL(inode) || !inode->i_op->set_acl) {",
                "\t\terror = -EOPNOTSUPP;",
                "\t\tgoto out_errno;",
                "\t}",
                "\terror = inode->i_op->set_acl(inode, argp->acl_access, ACL_TYPE_ACCESS);",
                "\t\tgoto out_drop_write;",
                "\terror = inode->i_op->set_acl(inode, argp->acl_default,",
                "\t\t\t\t     ACL_TYPE_DEFAULT);",
                "\t\tgoto out_drop_write;",
                "out_drop_write:"
            ],
            "added_lines": [
                "\tfh_lock(fh);",
                "",
                "\terror = set_posix_acl(inode, ACL_TYPE_ACCESS, argp->acl_access);",
                "\t\tgoto out_drop_lock;",
                "\terror = set_posix_acl(inode, ACL_TYPE_DEFAULT, argp->acl_default);",
                "\t\tgoto out_drop_lock;",
                "",
                "\tfh_unlock(fh);",
                "out_drop_lock:",
                "\tfh_unlock(fh);"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-1237",
        "func_name": "torvalds/linux/nfsd4_set_nfs4_acl",
        "description": "nfsd in the Linux kernel through 4.6.3 allows local users to bypass intended file-permission restrictions by setting a POSIX ACL, related to nfs2acl.c, nfs3acl.c, and nfs4acl.c.",
        "git_url": "https://github.com/torvalds/linux/commit/999653786df6954a31044528ac3f7a5dadca08f4",
        "commit_title": "nfsd: check permissions when setting ACLs",
        "commit_text": " Use set_posix_acl, which includes proper permission checks, instead of calling ->set_acl directly.  Without this anyone may be able to grant themselves permissions to a file by setting the ACL.  Lock the inode to make the new checks atomic with respect to set_acl. (Also, nfsd was the only caller of set_acl not locking the inode, so I suspect this may fix other races.)  This also simplifies the code, and ensures our ACLs are checked by posix_acl_valid.  The permission checks and the inode locking were lost with commit 4ac7249e, which changed nfsd to use the set_acl inode operation directly instead of going through xattr handlers.  [agreunba@redhat.com: use set_posix_acl] Cc: Christoph Hellwig <hch@infradead.org> Cc: Al Viro <viro@zeniv.linux.org.uk> Cc: stable@vger.kernel.org",
        "func_before": "__be32\nnfsd4_set_nfs4_acl(struct svc_rqst *rqstp, struct svc_fh *fhp,\n\t\tstruct nfs4_acl *acl)\n{\n\t__be32 error;\n\tint host_error;\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\tstruct posix_acl *pacl = NULL, *dpacl = NULL;\n\tunsigned int flags = 0;\n\n\t/* Get inode */\n\terror = fh_verify(rqstp, fhp, 0, NFSD_MAY_SATTR);\n\tif (error)\n\t\treturn error;\n\n\tdentry = fhp->fh_dentry;\n\tinode = d_inode(dentry);\n\n\tif (!inode->i_op->set_acl || !IS_POSIXACL(inode))\n\t\treturn nfserr_attrnotsupp;\n\n\tif (S_ISDIR(inode->i_mode))\n\t\tflags = NFS4_ACL_DIR;\n\n\thost_error = nfs4_acl_nfsv4_to_posix(acl, &pacl, &dpacl, flags);\n\tif (host_error == -EINVAL)\n\t\treturn nfserr_attrnotsupp;\n\tif (host_error < 0)\n\t\tgoto out_nfserr;\n\n\thost_error = inode->i_op->set_acl(inode, pacl, ACL_TYPE_ACCESS);\n\tif (host_error < 0)\n\t\tgoto out_release;\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\thost_error = inode->i_op->set_acl(inode, dpacl,\n\t\t\t\t\t\t  ACL_TYPE_DEFAULT);\n\t}\n\nout_release:\n\tposix_acl_release(pacl);\n\tposix_acl_release(dpacl);\nout_nfserr:\n\tif (host_error == -EOPNOTSUPP)\n\t\treturn nfserr_attrnotsupp;\n\telse\n\t\treturn nfserrno(host_error);\n}",
        "func": "__be32\nnfsd4_set_nfs4_acl(struct svc_rqst *rqstp, struct svc_fh *fhp,\n\t\tstruct nfs4_acl *acl)\n{\n\t__be32 error;\n\tint host_error;\n\tstruct dentry *dentry;\n\tstruct inode *inode;\n\tstruct posix_acl *pacl = NULL, *dpacl = NULL;\n\tunsigned int flags = 0;\n\n\t/* Get inode */\n\terror = fh_verify(rqstp, fhp, 0, NFSD_MAY_SATTR);\n\tif (error)\n\t\treturn error;\n\n\tdentry = fhp->fh_dentry;\n\tinode = d_inode(dentry);\n\n\tif (S_ISDIR(inode->i_mode))\n\t\tflags = NFS4_ACL_DIR;\n\n\thost_error = nfs4_acl_nfsv4_to_posix(acl, &pacl, &dpacl, flags);\n\tif (host_error == -EINVAL)\n\t\treturn nfserr_attrnotsupp;\n\tif (host_error < 0)\n\t\tgoto out_nfserr;\n\n\tfh_lock(fhp);\n\n\thost_error = set_posix_acl(inode, ACL_TYPE_ACCESS, pacl);\n\tif (host_error < 0)\n\t\tgoto out_drop_lock;\n\n\tif (S_ISDIR(inode->i_mode)) {\n\t\thost_error = set_posix_acl(inode, ACL_TYPE_DEFAULT, dpacl);\n\t}\n\nout_drop_lock:\n\tfh_unlock(fhp);\n\n\tposix_acl_release(pacl);\n\tposix_acl_release(dpacl);\nout_nfserr:\n\tif (host_error == -EOPNOTSUPP)\n\t\treturn nfserr_attrnotsupp;\n\telse\n\t\treturn nfserrno(host_error);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -17,9 +17,6 @@\n \tdentry = fhp->fh_dentry;\n \tinode = d_inode(dentry);\n \n-\tif (!inode->i_op->set_acl || !IS_POSIXACL(inode))\n-\t\treturn nfserr_attrnotsupp;\n-\n \tif (S_ISDIR(inode->i_mode))\n \t\tflags = NFS4_ACL_DIR;\n \n@@ -29,16 +26,19 @@\n \tif (host_error < 0)\n \t\tgoto out_nfserr;\n \n-\thost_error = inode->i_op->set_acl(inode, pacl, ACL_TYPE_ACCESS);\n+\tfh_lock(fhp);\n+\n+\thost_error = set_posix_acl(inode, ACL_TYPE_ACCESS, pacl);\n \tif (host_error < 0)\n-\t\tgoto out_release;\n+\t\tgoto out_drop_lock;\n \n \tif (S_ISDIR(inode->i_mode)) {\n-\t\thost_error = inode->i_op->set_acl(inode, dpacl,\n-\t\t\t\t\t\t  ACL_TYPE_DEFAULT);\n+\t\thost_error = set_posix_acl(inode, ACL_TYPE_DEFAULT, dpacl);\n \t}\n \n-out_release:\n+out_drop_lock:\n+\tfh_unlock(fhp);\n+\n \tposix_acl_release(pacl);\n \tposix_acl_release(dpacl);\n out_nfserr:",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (!inode->i_op->set_acl || !IS_POSIXACL(inode))",
                "\t\treturn nfserr_attrnotsupp;",
                "",
                "\thost_error = inode->i_op->set_acl(inode, pacl, ACL_TYPE_ACCESS);",
                "\t\tgoto out_release;",
                "\t\thost_error = inode->i_op->set_acl(inode, dpacl,",
                "\t\t\t\t\t\t  ACL_TYPE_DEFAULT);",
                "out_release:"
            ],
            "added_lines": [
                "\tfh_lock(fhp);",
                "",
                "\thost_error = set_posix_acl(inode, ACL_TYPE_ACCESS, pacl);",
                "\t\tgoto out_drop_lock;",
                "\t\thost_error = set_posix_acl(inode, ACL_TYPE_DEFAULT, dpacl);",
                "out_drop_lock:",
                "\tfh_unlock(fhp);",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2016-1237",
        "func_name": "torvalds/linux/nfsd3_proc_setacl",
        "description": "nfsd in the Linux kernel through 4.6.3 allows local users to bypass intended file-permission restrictions by setting a POSIX ACL, related to nfs2acl.c, nfs3acl.c, and nfs4acl.c.",
        "git_url": "https://github.com/torvalds/linux/commit/999653786df6954a31044528ac3f7a5dadca08f4",
        "commit_title": "nfsd: check permissions when setting ACLs",
        "commit_text": " Use set_posix_acl, which includes proper permission checks, instead of calling ->set_acl directly.  Without this anyone may be able to grant themselves permissions to a file by setting the ACL.  Lock the inode to make the new checks atomic with respect to set_acl. (Also, nfsd was the only caller of set_acl not locking the inode, so I suspect this may fix other races.)  This also simplifies the code, and ensures our ACLs are checked by posix_acl_valid.  The permission checks and the inode locking were lost with commit 4ac7249e, which changed nfsd to use the set_acl inode operation directly instead of going through xattr handlers.  [agreunba@redhat.com: use set_posix_acl] Cc: Christoph Hellwig <hch@infradead.org> Cc: Al Viro <viro@zeniv.linux.org.uk> Cc: stable@vger.kernel.org",
        "func_before": "static __be32 nfsd3_proc_setacl(struct svc_rqst * rqstp,\n\t\tstruct nfsd3_setaclargs *argp,\n\t\tstruct nfsd3_attrstat *resp)\n{\n\tstruct inode *inode;\n\tsvc_fh *fh;\n\t__be32 nfserr = 0;\n\tint error;\n\n\tfh = fh_copy(&resp->fh, &argp->fh);\n\tnfserr = fh_verify(rqstp, &resp->fh, 0, NFSD_MAY_SATTR);\n\tif (nfserr)\n\t\tgoto out;\n\n\tinode = d_inode(fh->fh_dentry);\n\tif (!IS_POSIXACL(inode) || !inode->i_op->set_acl) {\n\t\terror = -EOPNOTSUPP;\n\t\tgoto out_errno;\n\t}\n\n\terror = fh_want_write(fh);\n\tif (error)\n\t\tgoto out_errno;\n\n\terror = inode->i_op->set_acl(inode, argp->acl_access, ACL_TYPE_ACCESS);\n\tif (error)\n\t\tgoto out_drop_write;\n\terror = inode->i_op->set_acl(inode, argp->acl_default,\n\t\t\t\t     ACL_TYPE_DEFAULT);\n\nout_drop_write:\n\tfh_drop_write(fh);\nout_errno:\n\tnfserr = nfserrno(error);\nout:\n\t/* argp->acl_{access,default} may have been allocated in\n\t   nfs3svc_decode_setaclargs. */\n\tposix_acl_release(argp->acl_access);\n\tposix_acl_release(argp->acl_default);\n\tRETURN_STATUS(nfserr);\n}",
        "func": "static __be32 nfsd3_proc_setacl(struct svc_rqst * rqstp,\n\t\tstruct nfsd3_setaclargs *argp,\n\t\tstruct nfsd3_attrstat *resp)\n{\n\tstruct inode *inode;\n\tsvc_fh *fh;\n\t__be32 nfserr = 0;\n\tint error;\n\n\tfh = fh_copy(&resp->fh, &argp->fh);\n\tnfserr = fh_verify(rqstp, &resp->fh, 0, NFSD_MAY_SATTR);\n\tif (nfserr)\n\t\tgoto out;\n\n\tinode = d_inode(fh->fh_dentry);\n\n\terror = fh_want_write(fh);\n\tif (error)\n\t\tgoto out_errno;\n\n\tfh_lock(fh);\n\n\terror = set_posix_acl(inode, ACL_TYPE_ACCESS, argp->acl_access);\n\tif (error)\n\t\tgoto out_drop_lock;\n\terror = set_posix_acl(inode, ACL_TYPE_DEFAULT, argp->acl_default);\n\nout_drop_lock:\n\tfh_unlock(fh);\n\tfh_drop_write(fh);\nout_errno:\n\tnfserr = nfserrno(error);\nout:\n\t/* argp->acl_{access,default} may have been allocated in\n\t   nfs3svc_decode_setaclargs. */\n\tposix_acl_release(argp->acl_access);\n\tposix_acl_release(argp->acl_default);\n\tRETURN_STATUS(nfserr);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -13,22 +13,20 @@\n \t\tgoto out;\n \n \tinode = d_inode(fh->fh_dentry);\n-\tif (!IS_POSIXACL(inode) || !inode->i_op->set_acl) {\n-\t\terror = -EOPNOTSUPP;\n-\t\tgoto out_errno;\n-\t}\n \n \terror = fh_want_write(fh);\n \tif (error)\n \t\tgoto out_errno;\n \n-\terror = inode->i_op->set_acl(inode, argp->acl_access, ACL_TYPE_ACCESS);\n+\tfh_lock(fh);\n+\n+\terror = set_posix_acl(inode, ACL_TYPE_ACCESS, argp->acl_access);\n \tif (error)\n-\t\tgoto out_drop_write;\n-\terror = inode->i_op->set_acl(inode, argp->acl_default,\n-\t\t\t\t     ACL_TYPE_DEFAULT);\n+\t\tgoto out_drop_lock;\n+\terror = set_posix_acl(inode, ACL_TYPE_DEFAULT, argp->acl_default);\n \n-out_drop_write:\n+out_drop_lock:\n+\tfh_unlock(fh);\n \tfh_drop_write(fh);\n out_errno:\n \tnfserr = nfserrno(error);",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (!IS_POSIXACL(inode) || !inode->i_op->set_acl) {",
                "\t\terror = -EOPNOTSUPP;",
                "\t\tgoto out_errno;",
                "\t}",
                "\terror = inode->i_op->set_acl(inode, argp->acl_access, ACL_TYPE_ACCESS);",
                "\t\tgoto out_drop_write;",
                "\terror = inode->i_op->set_acl(inode, argp->acl_default,",
                "\t\t\t\t     ACL_TYPE_DEFAULT);",
                "out_drop_write:"
            ],
            "added_lines": [
                "\tfh_lock(fh);",
                "",
                "\terror = set_posix_acl(inode, ACL_TYPE_ACCESS, argp->acl_access);",
                "\t\tgoto out_drop_lock;",
                "\terror = set_posix_acl(inode, ACL_TYPE_DEFAULT, argp->acl_default);",
                "out_drop_lock:",
                "\tfh_unlock(fh);"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-4979",
        "func_name": "apache/httpd/ssl_hook_Access",
        "description": "The Apache HTTP Server 2.4.18 through 2.4.20, when mod_http2 and mod_ssl are enabled, does not properly recognize the \"SSLVerifyClient require\" directive for HTTP/2 request authorization, which allows remote attackers to bypass intended access restrictions by leveraging the ability to send multiple requests over a single connection and aborting a renegotiation.",
        "git_url": "https://github.com/apache/httpd/commit/2d0e4eff04ea963128a41faaef21f987272e05a2",
        "commit_title": "modssl: reset client-verify state when renegotiation is aborted",
        "commit_text": "",
        "func_before": "int ssl_hook_Access(request_rec *r)\n{\n    SSLDirConfigRec *dc         = myDirConfig(r);\n    SSLSrvConfigRec *sc         = mySrvConfig(r->server);\n    SSLConnRec *sslconn         = myConnConfig(r->connection);\n    SSL *ssl                    = sslconn ? sslconn->ssl : NULL;\n    server_rec *handshakeserver = sslconn ? sslconn->server : NULL;\n    SSLSrvConfigRec *hssc       = handshakeserver? mySrvConfig(handshakeserver) : NULL;\n    SSL_CTX *ctx = NULL;\n    apr_array_header_t *requires;\n    ssl_require_t *ssl_requires;\n    int ok, i;\n    BOOL renegotiate = FALSE, renegotiate_quick = FALSE;\n    X509 *cert;\n    X509 *peercert;\n    X509_STORE *cert_store = NULL;\n    X509_STORE_CTX *cert_store_ctx;\n    STACK_OF(SSL_CIPHER) *cipher_list_old = NULL, *cipher_list = NULL;\n    const SSL_CIPHER *cipher = NULL;\n    int depth, verify_old, verify, n, is_slave = 0;\n    const char *ncipher_suite;\n\n    /* On a slave connection, we do not expect to have an SSLConnRec, but\n     * our master connection might have one. */\n    if (!(sslconn && ssl) && r->connection->master) {\n        sslconn         = myConnConfig(r->connection->master);\n        ssl             = sslconn ? sslconn->ssl : NULL;\n        handshakeserver = sslconn ? sslconn->server : NULL;\n        hssc            = handshakeserver? mySrvConfig(handshakeserver) : NULL;\n        is_slave        = 1;\n    }\n    \n    if (ssl) {\n        /*\n         * We should have handshaken here (on handshakeserver),\n         * otherwise we are being redirected (ErrorDocument) from\n         * a renegotiation failure below. The access is still \n         * forbidden in the latter case, let ap_die() handle\n         * this recursive (same) error.\n         */\n        if (!SSL_is_init_finished(ssl)) {\n            return HTTP_FORBIDDEN;\n        }\n        ctx = SSL_get_SSL_CTX(ssl);\n    }\n\n    /*\n     * Support for SSLRequireSSL directive\n     */\n    if (dc->bSSLRequired && !ssl) {\n        if ((sc->enabled == SSL_ENABLED_OPTIONAL) && !is_slave) {\n            /* This vhost was configured for optional SSL, just tell the\n             * client that we need to upgrade.\n             */\n            apr_table_setn(r->err_headers_out, \"Upgrade\", \"TLS/1.0, HTTP/1.1\");\n            apr_table_setn(r->err_headers_out, \"Connection\", \"Upgrade\");\n\n            return HTTP_UPGRADE_REQUIRED;\n        }\n\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02219)\n                      \"access to %s failed, reason: %s\",\n                      r->filename, \"SSL connection required\");\n\n        /* remember forbidden access for strict require option */\n        apr_table_setn(r->notes, \"ssl-access-forbidden\", \"1\");\n\n        return HTTP_FORBIDDEN;\n    }\n\n    /*\n     * Check to see whether SSL is in use; if it's not, then no\n     * further access control checks are relevant.  (the test for\n     * sc->enabled is probably strictly unnecessary)\n     */\n    if (sc->enabled == SSL_ENABLED_FALSE || !ssl) {\n        return DECLINED;\n    }\n\n#ifdef HAVE_SRP\n    /*\n     * Support for per-directory reconfigured SSL connection parameters\n     *\n     * We do not force any renegotiation if the user is already authenticated\n     * via SRP.\n     *\n     */\n    if (SSL_get_srp_username(ssl)) {\n        return DECLINED;\n    }\n#endif\n\n    /*\n     * Support for per-directory reconfigured SSL connection parameters.\n     *\n     * This is implemented by forcing an SSL renegotiation with the\n     * reconfigured parameter suite. But Apache's internal API processing\n     * makes our life very hard here, because when internal sub-requests occur\n     * we nevertheless should avoid multiple unnecessary SSL handshakes (they\n     * require extra network I/O and especially time to perform).\n     *\n     * But the optimization for filtering out the unnecessary handshakes isn't\n     * obvious and trivial.  Especially because while Apache is in its\n     * sub-request processing the client could force additional handshakes,\n     * too. And these take place perhaps without our notice. So the only\n     * possibility is to explicitly _ask_ OpenSSL whether the renegotiation\n     * has to be performed or not. It has to performed when some parameters\n     * which were previously known (by us) are not those we've now\n     * reconfigured (as known by OpenSSL) or (in optimized way) at least when\n     * the reconfigured parameter suite is stronger (more restrictions) than\n     * the currently active one.\n     */\n\n    /*\n     * Override of SSLCipherSuite\n     *\n     * We provide two options here:\n     *\n     * o The paranoid and default approach where we force a renegotiation when\n     *   the cipher suite changed in _any_ way (which is straight-forward but\n     *   often forces renegotiations too often and is perhaps not what the\n     *   user actually wanted).\n     *\n     * o The optimized and still secure way where we force a renegotiation\n     *   only if the currently active cipher is no longer contained in the\n     *   reconfigured/new cipher suite. Any other changes are not important\n     *   because it's the servers choice to select a cipher from the ones the\n     *   client supports. So as long as the current cipher is still in the new\n     *   cipher suite we're happy. Because we can assume we would have\n     *   selected it again even when other (better) ciphers exists now in the\n     *   new cipher suite. This approach is fine because the user explicitly\n     *   has to enable this via ``SSLOptions +OptRenegotiate''. So we do no\n     *   implicit optimizations.\n     */     \n    ncipher_suite = (dc->szCipherSuite? \n                     dc->szCipherSuite : (r->server != handshakeserver)?\n                     sc->server->auth.cipher_suite : NULL);\n    \n    if (ncipher_suite && (!sslconn->cipher_suite \n                          || strcmp(ncipher_suite, sslconn->cipher_suite))) {\n        /* remember old state */\n\n        if (dc->nOptions & SSL_OPT_OPTRENEGOTIATE) {\n            cipher = SSL_get_current_cipher(ssl);\n        }\n        else {\n            cipher_list_old = (STACK_OF(SSL_CIPHER) *)SSL_get_ciphers(ssl);\n\n            if (cipher_list_old) {\n                cipher_list_old = sk_SSL_CIPHER_dup(cipher_list_old);\n            }\n        }\n\n        /* configure new state */\n        if (is_slave) {\n            /* TODO: this categorically fails changed cipher suite settings\n             * on slave connections. We could do better by\n             * - create a new SSL* from our SSL_CTX and set cipher suite there,\n             *   and retrieve ciphers, free afterwards\n             * Modifying the SSL on a slave connection is no good.\n             */\n            apr_table_setn(r->notes, \"ssl-renegotiate-forbidden\", \"cipher-suite\");\n            return HTTP_FORBIDDEN;\n        }\n\n        if (!SSL_set_cipher_list(ssl, ncipher_suite)) {\n            ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(02253)\n                          \"Unable to reconfigure (per-directory) \"\n                          \"permitted SSL ciphers\");\n            ssl_log_ssl_error(SSLLOG_MARK, APLOG_ERR, r->server);\n\n            if (cipher_list_old) {\n                sk_SSL_CIPHER_free(cipher_list_old);\n            }\n\n            return HTTP_FORBIDDEN;\n        }\n\n        /* determine whether a renegotiation has to be forced */\n        cipher_list = (STACK_OF(SSL_CIPHER) *)SSL_get_ciphers(ssl);\n\n        if (dc->nOptions & SSL_OPT_OPTRENEGOTIATE) {\n            /* optimized way */\n            if ((!cipher && cipher_list) ||\n                (cipher && !cipher_list))\n            {\n                renegotiate = TRUE;\n            }\n            else if (cipher && cipher_list &&\n                     (sk_SSL_CIPHER_find(cipher_list, cipher) < 0))\n            {\n                renegotiate = TRUE;\n            }\n        }\n        else {\n            /* paranoid way */\n            if ((!cipher_list_old && cipher_list) ||\n                (cipher_list_old && !cipher_list))\n            {\n                renegotiate = TRUE;\n            }\n            else if (cipher_list_old && cipher_list) {\n                for (n = 0;\n                     !renegotiate && (n < sk_SSL_CIPHER_num(cipher_list));\n                     n++)\n                {\n                    const SSL_CIPHER *value = sk_SSL_CIPHER_value(cipher_list, n);\n\n                    if (sk_SSL_CIPHER_find(cipher_list_old, value) < 0) {\n                        renegotiate = TRUE;\n                    }\n                }\n\n                for (n = 0;\n                     !renegotiate && (n < sk_SSL_CIPHER_num(cipher_list_old));\n                     n++)\n                {\n                    const SSL_CIPHER *value = sk_SSL_CIPHER_value(cipher_list_old, n);\n\n                    if (sk_SSL_CIPHER_find(cipher_list, value) < 0) {\n                        renegotiate = TRUE;\n                    }\n                }\n            }\n        }\n\n        /* cleanup */\n        if (cipher_list_old) {\n            sk_SSL_CIPHER_free(cipher_list_old);\n        }\n\n        if (renegotiate) {\n            if (is_slave) {\n                /* The request causes renegotiation on a slave connection.\n                 * This is not allowed since we might have concurrent requests\n                 * on this connection.\n                 */\n                apr_table_setn(r->notes, \"ssl-renegotiate-forbidden\", \"cipher-suite\");\n                return HTTP_FORBIDDEN;\n            }\n            \n#ifdef SSL_OP_CIPHER_SERVER_PREFERENCE\n            if (sc->cipher_server_pref == TRUE) {\n                SSL_set_options(ssl, SSL_OP_CIPHER_SERVER_PREFERENCE);\n            }\n#endif\n            /* tracing */\n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02220)\n                         \"Reconfigured cipher suite will force renegotiation\");\n        }\n    }\n\n    /*\n     * override of SSLVerifyClient\n     *\n     * We force a renegotiation if the reconfigured/new verify type is\n     * stronger than the currently active verify type.\n     *\n     * The order is: none << optional_no_ca << optional << require\n     *\n     * Additionally the following optimization is possible here: When the\n     * currently active verify type is \"none\" but a client certificate is\n     * already known/present, it's enough to manually force a client\n     * verification but at least skip the I/O-intensive renegotiation\n     * handshake.\n     */\n    if ((dc->nVerifyClient != SSL_CVERIFY_UNSET) ||\n        (sc->server->auth.verify_mode != SSL_CVERIFY_UNSET)) {\n\n        /* remember old state */\n        verify_old = SSL_get_verify_mode(ssl);\n        /* configure new state */\n        verify = SSL_VERIFY_NONE;\n\n        if ((dc->nVerifyClient == SSL_CVERIFY_REQUIRE) ||\n            (sc->server->auth.verify_mode == SSL_CVERIFY_REQUIRE)) {\n            verify |= SSL_VERIFY_PEER_STRICT;\n        }\n\n        if ((dc->nVerifyClient == SSL_CVERIFY_OPTIONAL) ||\n            (dc->nVerifyClient == SSL_CVERIFY_OPTIONAL_NO_CA) ||\n            (sc->server->auth.verify_mode == SSL_CVERIFY_OPTIONAL) ||\n            (sc->server->auth.verify_mode == SSL_CVERIFY_OPTIONAL_NO_CA))\n        {\n            verify |= SSL_VERIFY_PEER;\n        }\n\n        /* TODO: this seems premature since we do not know if there\n         *       are any changes required.\n         */\n        SSL_set_verify(ssl, verify, ssl_callback_SSLVerify);\n        SSL_set_verify_result(ssl, X509_V_OK);\n\n        /* determine whether we've to force a renegotiation */\n        if (!renegotiate && verify != verify_old) {\n            if (((verify_old == SSL_VERIFY_NONE) &&\n                 (verify     != SSL_VERIFY_NONE)) ||\n\n                (!(verify_old & SSL_VERIFY_PEER) &&\n                  (verify     & SSL_VERIFY_PEER)) ||\n\n                (!(verify_old & SSL_VERIFY_FAIL_IF_NO_PEER_CERT) &&\n                  (verify     & SSL_VERIFY_FAIL_IF_NO_PEER_CERT)))\n            {\n                renegotiate = TRUE;\n                if (is_slave) {\n                    /* The request causes renegotiation on a slave connection.\n                     * This is not allowed since we might have concurrent requests\n                     * on this connection.\n                     */\n                    apr_table_setn(r->notes, \"ssl-renegotiate-forbidden\", \"verify-client\");\n                    return HTTP_FORBIDDEN;\n                }\n                /* optimization */\n\n                if ((dc->nOptions & SSL_OPT_OPTRENEGOTIATE) &&\n                    (verify_old == SSL_VERIFY_NONE) &&\n                    ((peercert = SSL_get_peer_certificate(ssl)) != NULL))\n                {\n                    renegotiate_quick = TRUE;\n                    X509_free(peercert);\n                }\n\n                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02255)\n                              \"Changed client verification type will force \"\n                              \"%srenegotiation\",\n                              renegotiate_quick ? \"quick \" : \"\");\n            }\n            else if (verify != SSL_VERIFY_NONE) {\n                /*\n                 * override of SSLVerifyDepth\n                 *\n                 * The depth checks are handled by us manually inside the\n                 * verify callback function and not by OpenSSL internally\n                 * (and our function is aware of both the per-server and\n                 * per-directory contexts). So we cannot ask OpenSSL about\n                 * the currently verify depth. Instead we remember it in our\n                 * SSLConnRec attached to the SSL* of OpenSSL.  We've to force\n                 * the renegotiation if the reconfigured/new verify depth is\n                 * less than the currently active/remembered verify depth\n                 * (because this means more restriction on the certificate\n                 * chain).\n                 */\n                n = (sslconn->verify_depth != UNSET)\n                    ? sslconn->verify_depth\n                    : hssc->server->auth.verify_depth;\n                /* determine the new depth */\n                sslconn->verify_depth = (dc->nVerifyDepth != UNSET)\n                                        ? dc->nVerifyDepth\n                                        : sc->server->auth.verify_depth;\n                if (sslconn->verify_depth < n) {\n                    renegotiate = TRUE;\n                    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02254)\n                                  \"Reduced client verification depth will \"\n                                  \"force renegotiation\");\n                }\n            }\n        }\n        /* If we're handling a request for a vhost other than the default one,\n         * then we need to make sure that client authentication is properly\n         * enforced. For clients supplying an SNI extension, the peer\n         * certificate verification has happened in the handshake already\n         * (and r->server == handshakeserver). For non-SNI requests,\n         * an additional check is needed here. If client authentication\n         * is configured as mandatory, then we can only proceed if the\n         * CA list doesn't have to be changed (OpenSSL doesn't provide\n         * an option to change the list for an existing session).\n         */\n        if ((r->server != handshakeserver)\n            && renegotiate\n            && ((verify & SSL_VERIFY_PEER) ||\n                (verify & SSL_VERIFY_FAIL_IF_NO_PEER_CERT))) {\n#define MODSSL_CFG_CA_NE(f, sc1, sc2) \\\n            (sc1->server->auth.f && \\\n             (!sc2->server->auth.f || \\\n              strNE(sc1->server->auth.f, sc2->server->auth.f)))\n\n            if (MODSSL_CFG_CA_NE(ca_cert_file, sc, hssc) ||\n                MODSSL_CFG_CA_NE(ca_cert_path, sc, hssc)) {\n                if (verify & SSL_VERIFY_FAIL_IF_NO_PEER_CERT) {\n                    ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(02256)\n                         \"Non-default virtual host with SSLVerify set to \"\n                         \"'require' and VirtualHost-specific CA certificate \"\n                         \"list is only available to clients with TLS server \"\n                         \"name indication (SNI) support\");\n                    SSL_set_verify(ssl, verify_old, NULL);\n                    return HTTP_FORBIDDEN;\n                } else\n                    /* let it pass, possibly with an \"incorrect\" peer cert,\n                     * so make sure the SSL_CLIENT_VERIFY environment variable\n                     * will indicate partial success only, later on.\n                     */\n                    sslconn->verify_info = \"GENEROUS\";\n            }\n        }\n    }\n\n    /* If a renegotiation is now required for this location, and the\n     * request includes a message body (and the client has not\n     * requested a \"100 Continue\" response), then the client will be\n     * streaming the request body over the wire already.  In that\n     * case, it is not possible to stop and perform a new SSL\n     * handshake immediately; once the SSL library moves to the\n     * \"accept\" state, it will reject the SSL packets which the client\n     * is sending for the request body.\n     *\n     * To allow authentication to complete in this auth hook, the\n     * solution used here is to fill a (bounded) buffer with the\n     * request body, and then to reinject that request body later.\n     */\n    if (renegotiate && !renegotiate_quick\n        && (apr_table_get(r->headers_in, \"transfer-encoding\")\n            || (apr_table_get(r->headers_in, \"content-length\")\n                && strcmp(apr_table_get(r->headers_in, \"content-length\"), \"0\")))\n        && !r->expecting_100) {\n        int rv;\n        apr_size_t rsize;\n\n        rsize = dc->nRenegBufferSize == UNSET ? DEFAULT_RENEG_BUFFER_SIZE :\n                                                dc->nRenegBufferSize;\n        if (rsize > 0) {\n            /* Fill the I/O buffer with the request body if possible. */\n            rv = ssl_io_buffer_fill(r, rsize);\n        }\n        else {\n            /* If the reneg buffer size is set to zero, just fail. */\n            rv = HTTP_REQUEST_ENTITY_TOO_LARGE;\n        }\n\n        if (rv) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02257)\n                          \"could not buffer message body to allow \"\n                          \"SSL renegotiation to proceed\");\n            return rv;\n        }\n    }\n\n    /*\n     * now do the renegotiation if anything was actually reconfigured\n     */\n    if (renegotiate) {\n        /*\n         * Now we force the SSL renegotiation by sending the Hello Request\n         * message to the client. Here we have to do a workaround: Actually\n         * OpenSSL returns immediately after sending the Hello Request (the\n         * intent AFAIK is because the SSL/TLS protocol says it's not a must\n         * that the client replies to a Hello Request). But because we insist\n         * on a reply (anything else is an error for us) we have to go to the\n         * ACCEPT state manually. Using SSL_set_accept_state() doesn't work\n         * here because it resets too much of the connection.  So we set the\n         * state explicitly and continue the handshake manually.\n         */\n        ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(02221)\n                      \"Requesting connection re-negotiation\");\n\n        if (renegotiate_quick) {\n            STACK_OF(X509) *cert_stack;\n\n            /* perform just a manual re-verification of the peer */\n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02258)\n                         \"Performing quick renegotiation: \"\n                         \"just re-verifying the peer\");\n\n            cert_stack = (STACK_OF(X509) *)SSL_get_peer_cert_chain(ssl);\n\n            cert = SSL_get_peer_certificate(ssl);\n\n            if (!cert_stack && cert) {\n                /* client cert is in the session cache, but there is\n                 * no chain, since ssl3_get_client_certificate()\n                 * sk_X509_shift-ed the peer cert out of the chain.\n                 * we put it back here for the purpose of quick_renegotiation.\n                 */\n                cert_stack = sk_X509_new_null();\n                sk_X509_push(cert_stack, cert);\n            }\n\n            if (!cert_stack || (sk_X509_num(cert_stack) == 0)) {\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02222)\n                              \"Cannot find peer certificate chain\");\n\n                return HTTP_FORBIDDEN;\n            }\n\n            if (!(cert_store ||\n                  (cert_store = SSL_CTX_get_cert_store(ctx))))\n            {\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02223)\n                              \"Cannot find certificate storage\");\n\n                return HTTP_FORBIDDEN;\n            }\n\n            if (!cert) {\n                cert = sk_X509_value(cert_stack, 0);\n            }\n\n            cert_store_ctx = X509_STORE_CTX_new();\n            X509_STORE_CTX_init(cert_store_ctx, cert_store, cert, cert_stack);\n            depth = SSL_get_verify_depth(ssl);\n\n            if (depth >= 0) {\n                X509_STORE_CTX_set_depth(cert_store_ctx, depth);\n            }\n\n            X509_STORE_CTX_set_ex_data(cert_store_ctx,\n                                       SSL_get_ex_data_X509_STORE_CTX_idx(),\n                                       (char *)ssl);\n\n            if (!X509_verify_cert(cert_store_ctx)) {\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02224)\n                              \"Re-negotiation verification step failed\");\n                ssl_log_ssl_error(SSLLOG_MARK, APLOG_ERR, r->server);\n            }\n\n            SSL_set_verify_result(ssl, X509_STORE_CTX_get_error(cert_store_ctx));\n            X509_STORE_CTX_cleanup(cert_store_ctx);\n            X509_STORE_CTX_free(cert_store_ctx);\n\n            if (cert_stack != SSL_get_peer_cert_chain(ssl)) {\n                /* we created this ourselves, so free it */\n                sk_X509_pop_free(cert_stack, X509_free);\n            }\n        }\n        else {\n            char peekbuf[1];\n            const char *reneg_support;\n            request_rec *id = r->main ? r->main : r;\n\n            /* Additional mitigation for CVE-2009-3555: At this point,\n             * before renegotiating, an (entire) request has been read\n             * from the connection.  An attacker may have sent further\n             * data to \"prefix\" any subsequent request by the victim's\n             * client after the renegotiation; this data may already\n             * have been read and buffered.  Forcing a connection\n             * closure after the response ensures such data will be\n             * discarded.  Legimately pipelined HTTP requests will be\n             * retried anyway with this approach. */\n            if (has_buffered_data(r)) {\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02259)\n                              \"insecure SSL re-negotiation required, but \"\n                              \"a pipelined request is present; keepalive \"\n                              \"disabled\");\n                r->connection->keepalive = AP_CONN_CLOSE;\n            }\n\n#if defined(SSL_get_secure_renegotiation_support)\n            reneg_support = SSL_get_secure_renegotiation_support(ssl) ?\n                            \"client does\" : \"client does not\";\n#else\n            reneg_support = \"server does not\";\n#endif\n            /* Perform a full renegotiation. */\n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02260)\n                          \"Performing full renegotiation: complete handshake \"\n                          \"protocol (%s support secure renegotiation)\",\n                          reneg_support);\n\n            SSL_set_session_id_context(ssl,\n                                       (unsigned char *)&id,\n                                       sizeof(id));\n\n            /* Toggle the renegotiation state to allow the new\n             * handshake to proceed. */\n            sslconn->reneg_state = RENEG_ALLOW;\n\n            SSL_renegotiate(ssl);\n            SSL_do_handshake(ssl);\n\n            if (!SSL_is_init_finished(ssl)) {\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02225)\n                              \"Re-negotiation request failed\");\n                ssl_log_ssl_error(SSLLOG_MARK, APLOG_ERR, r->server);\n\n                r->connection->keepalive = AP_CONN_CLOSE;\n                return HTTP_FORBIDDEN;\n            }\n\n            ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(02226)\n                          \"Awaiting re-negotiation handshake\");\n\n            /* XXX: Should replace setting state with SSL_renegotiate(ssl);\n             * However, this causes failures in perl-framework currently,\n             * perhaps pre-test if we have already negotiated?\n             */\n            /* Need to trigger renegotiation handshake by reading.\n             * Peeking 0 bytes actually works.\n             * See: http://marc.info/?t=145493359200002&r=1&w=2\n             */\n            SSL_peek(ssl, peekbuf, 0);\n\n            sslconn->reneg_state = RENEG_REJECT;\n\n            if (!SSL_is_init_finished(ssl)) {\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02261)\n                              \"Re-negotiation handshake failed\");\n                ssl_log_ssl_error(SSLLOG_MARK, APLOG_ERR, r->server);\n\n                r->connection->keepalive = AP_CONN_CLOSE;\n                return HTTP_FORBIDDEN;\n            }\n\n            /* Full renegotiation successfull, we now have handshaken with\n             * this server's parameters.\n             */\n            sslconn->server = r->server;\n        }\n\n        /*\n         * Remember the peer certificate's DN\n         */\n        if ((cert = SSL_get_peer_certificate(ssl))) {\n            if (sslconn->client_cert) {\n                X509_free(sslconn->client_cert);\n            }\n            sslconn->client_cert = cert;\n            sslconn->client_dn = NULL;\n        }\n\n        /*\n         * Finally check for acceptable renegotiation results\n         */\n        if ((dc->nVerifyClient != SSL_CVERIFY_NONE) ||\n            (sc->server->auth.verify_mode != SSL_CVERIFY_NONE)) {\n            BOOL do_verify = ((dc->nVerifyClient == SSL_CVERIFY_REQUIRE) ||\n                              (sc->server->auth.verify_mode == SSL_CVERIFY_REQUIRE));\n\n            if (do_verify && (SSL_get_verify_result(ssl) != X509_V_OK)) {\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02262)\n                              \"Re-negotiation handshake failed: \"\n                              \"Client verification failed\");\n\n                return HTTP_FORBIDDEN;\n            }\n\n            if (do_verify) {\n                if ((peercert = SSL_get_peer_certificate(ssl)) == NULL) {\n                    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02263)\n                                  \"Re-negotiation handshake failed: \"\n                                  \"Client certificate missing\");\n\n                    return HTTP_FORBIDDEN;\n                }\n\n                X509_free(peercert);\n            }\n        }\n\n        /*\n         * Also check that SSLCipherSuite has been enforced as expected.\n         */\n        if (cipher_list) {\n            cipher = SSL_get_current_cipher(ssl);\n            if (sk_SSL_CIPHER_find(cipher_list, cipher) < 0) {\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02264)\n                             \"SSL cipher suite not renegotiated: \"\n                             \"access to %s denied using cipher %s\",\n                              r->filename,\n                              SSL_CIPHER_get_name(cipher));\n                return HTTP_FORBIDDEN;\n            }\n        }\n        /* remember any new cipher suite used in renegotiation */\n        if (ncipher_suite) {\n            sslconn->cipher_suite = ncipher_suite;\n        }\n    }\n\n    /* If we're trying to have the user name set from a client\n     * certificate then we need to set it here. This should be safe as\n     * the user name probably isn't important from an auth checking point\n     * of view as the certificate supplied acts in that capacity.\n     * However, if FakeAuth is being used then this isn't the case so\n     * we need to postpone setting the username until later.\n     */\n    if ((dc->nOptions & SSL_OPT_FAKEBASICAUTH) == 0 && dc->szUserName) {\n        char *val = ssl_var_lookup(r->pool, r->server, r->connection,\n                                   r, (char *)dc->szUserName);\n        if (val && val[0])\n            r->user = val;\n        else\n            ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(02227)\n                          \"Failed to set r->user to '%s'\", dc->szUserName);\n    }\n\n    /*\n     * Check SSLRequire boolean expressions\n     */\n    requires = dc->aRequirement;\n    ssl_requires = (ssl_require_t *)requires->elts;\n\n    for (i = 0; i < requires->nelts; i++) {\n        ssl_require_t *req = &ssl_requires[i];\n        const char *errstring;\n        ok = ap_expr_exec(r, req->mpExpr, &errstring);\n\n        if (ok < 0) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02265)\n                          \"access to %s failed, reason: Failed to execute \"\n                          \"SSL requirement expression: %s\",\n                          r->filename, errstring);\n\n            /* remember forbidden access for strict require option */\n            apr_table_setn(r->notes, \"ssl-access-forbidden\", \"1\");\n\n            return HTTP_FORBIDDEN;\n        }\n\n        if (ok != 1) {\n            ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(02266)\n                          \"Access to %s denied for %s \"\n                          \"(requirement expression not fulfilled)\",\n                          r->filename, r->useragent_ip);\n\n            ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(02228)\n                          \"Failed expression: %s\", req->cpExpr);\n\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02229)\n                          \"access to %s failed, reason: %s\",\n                          r->filename,\n                          \"SSL requirement expression not fulfilled\");\n\n            /* remember forbidden access for strict require option */\n            apr_table_setn(r->notes, \"ssl-access-forbidden\", \"1\");\n\n            return HTTP_FORBIDDEN;\n        }\n    }\n\n    /*\n     * Else access is granted from our point of view (except vendor\n     * handlers override). But we have to return DECLINED here instead\n     * of OK, because mod_auth and other modules still might want to\n     * deny access.\n     */\n\n    return DECLINED;\n}",
        "func": "int ssl_hook_Access(request_rec *r)\n{\n    SSLDirConfigRec *dc         = myDirConfig(r);\n    SSLSrvConfigRec *sc         = mySrvConfig(r->server);\n    SSLConnRec *sslconn         = myConnConfig(r->connection);\n    SSL *ssl                    = sslconn ? sslconn->ssl : NULL;\n    server_rec *handshakeserver = sslconn ? sslconn->server : NULL;\n    SSLSrvConfigRec *hssc       = handshakeserver? mySrvConfig(handshakeserver) : NULL;\n    SSL_CTX *ctx = NULL;\n    apr_array_header_t *requires;\n    ssl_require_t *ssl_requires;\n    int ok, i;\n    BOOL renegotiate = FALSE, renegotiate_quick = FALSE;\n    X509 *cert;\n    X509 *peercert;\n    X509_STORE *cert_store = NULL;\n    X509_STORE_CTX *cert_store_ctx;\n    STACK_OF(SSL_CIPHER) *cipher_list_old = NULL, *cipher_list = NULL;\n    const SSL_CIPHER *cipher = NULL;\n    int depth, verify_old, verify, n, is_slave = 0;\n    const char *ncipher_suite;\n\n    /* On a slave connection, we do not expect to have an SSLConnRec, but\n     * our master connection might have one. */\n    if (!(sslconn && ssl) && r->connection->master) {\n        sslconn         = myConnConfig(r->connection->master);\n        ssl             = sslconn ? sslconn->ssl : NULL;\n        handshakeserver = sslconn ? sslconn->server : NULL;\n        hssc            = handshakeserver? mySrvConfig(handshakeserver) : NULL;\n        is_slave        = 1;\n    }\n    \n    if (ssl) {\n        /*\n         * We should have handshaken here (on handshakeserver),\n         * otherwise we are being redirected (ErrorDocument) from\n         * a renegotiation failure below. The access is still \n         * forbidden in the latter case, let ap_die() handle\n         * this recursive (same) error.\n         */\n        if (!SSL_is_init_finished(ssl)) {\n            return HTTP_FORBIDDEN;\n        }\n        ctx = SSL_get_SSL_CTX(ssl);\n    }\n\n    /*\n     * Support for SSLRequireSSL directive\n     */\n    if (dc->bSSLRequired && !ssl) {\n        if ((sc->enabled == SSL_ENABLED_OPTIONAL) && !is_slave) {\n            /* This vhost was configured for optional SSL, just tell the\n             * client that we need to upgrade.\n             */\n            apr_table_setn(r->err_headers_out, \"Upgrade\", \"TLS/1.0, HTTP/1.1\");\n            apr_table_setn(r->err_headers_out, \"Connection\", \"Upgrade\");\n\n            return HTTP_UPGRADE_REQUIRED;\n        }\n\n        ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02219)\n                      \"access to %s failed, reason: %s\",\n                      r->filename, \"SSL connection required\");\n\n        /* remember forbidden access for strict require option */\n        apr_table_setn(r->notes, \"ssl-access-forbidden\", \"1\");\n\n        return HTTP_FORBIDDEN;\n    }\n\n    /*\n     * Check to see whether SSL is in use; if it's not, then no\n     * further access control checks are relevant.  (the test for\n     * sc->enabled is probably strictly unnecessary)\n     */\n    if (sc->enabled == SSL_ENABLED_FALSE || !ssl) {\n        return DECLINED;\n    }\n\n#ifdef HAVE_SRP\n    /*\n     * Support for per-directory reconfigured SSL connection parameters\n     *\n     * We do not force any renegotiation if the user is already authenticated\n     * via SRP.\n     *\n     */\n    if (SSL_get_srp_username(ssl)) {\n        return DECLINED;\n    }\n#endif\n\n    /*\n     * Support for per-directory reconfigured SSL connection parameters.\n     *\n     * This is implemented by forcing an SSL renegotiation with the\n     * reconfigured parameter suite. But Apache's internal API processing\n     * makes our life very hard here, because when internal sub-requests occur\n     * we nevertheless should avoid multiple unnecessary SSL handshakes (they\n     * require extra network I/O and especially time to perform).\n     *\n     * But the optimization for filtering out the unnecessary handshakes isn't\n     * obvious and trivial.  Especially because while Apache is in its\n     * sub-request processing the client could force additional handshakes,\n     * too. And these take place perhaps without our notice. So the only\n     * possibility is to explicitly _ask_ OpenSSL whether the renegotiation\n     * has to be performed or not. It has to performed when some parameters\n     * which were previously known (by us) are not those we've now\n     * reconfigured (as known by OpenSSL) or (in optimized way) at least when\n     * the reconfigured parameter suite is stronger (more restrictions) than\n     * the currently active one.\n     */\n\n    /*\n     * Override of SSLCipherSuite\n     *\n     * We provide two options here:\n     *\n     * o The paranoid and default approach where we force a renegotiation when\n     *   the cipher suite changed in _any_ way (which is straight-forward but\n     *   often forces renegotiations too often and is perhaps not what the\n     *   user actually wanted).\n     *\n     * o The optimized and still secure way where we force a renegotiation\n     *   only if the currently active cipher is no longer contained in the\n     *   reconfigured/new cipher suite. Any other changes are not important\n     *   because it's the servers choice to select a cipher from the ones the\n     *   client supports. So as long as the current cipher is still in the new\n     *   cipher suite we're happy. Because we can assume we would have\n     *   selected it again even when other (better) ciphers exists now in the\n     *   new cipher suite. This approach is fine because the user explicitly\n     *   has to enable this via ``SSLOptions +OptRenegotiate''. So we do no\n     *   implicit optimizations.\n     */     \n    ncipher_suite = (dc->szCipherSuite? \n                     dc->szCipherSuite : (r->server != handshakeserver)?\n                     sc->server->auth.cipher_suite : NULL);\n    \n    if (ncipher_suite && (!sslconn->cipher_suite \n                          || strcmp(ncipher_suite, sslconn->cipher_suite))) {\n        /* remember old state */\n\n        if (dc->nOptions & SSL_OPT_OPTRENEGOTIATE) {\n            cipher = SSL_get_current_cipher(ssl);\n        }\n        else {\n            cipher_list_old = (STACK_OF(SSL_CIPHER) *)SSL_get_ciphers(ssl);\n\n            if (cipher_list_old) {\n                cipher_list_old = sk_SSL_CIPHER_dup(cipher_list_old);\n            }\n        }\n\n        /* configure new state */\n        if (is_slave) {\n            /* TODO: this categorically fails changed cipher suite settings\n             * on slave connections. We could do better by\n             * - create a new SSL* from our SSL_CTX and set cipher suite there,\n             *   and retrieve ciphers, free afterwards\n             * Modifying the SSL on a slave connection is no good.\n             */\n            apr_table_setn(r->notes, \"ssl-renegotiate-forbidden\", \"cipher-suite\");\n            return HTTP_FORBIDDEN;\n        }\n\n        if (!SSL_set_cipher_list(ssl, ncipher_suite)) {\n            ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(02253)\n                          \"Unable to reconfigure (per-directory) \"\n                          \"permitted SSL ciphers\");\n            ssl_log_ssl_error(SSLLOG_MARK, APLOG_ERR, r->server);\n\n            if (cipher_list_old) {\n                sk_SSL_CIPHER_free(cipher_list_old);\n            }\n\n            return HTTP_FORBIDDEN;\n        }\n\n        /* determine whether a renegotiation has to be forced */\n        cipher_list = (STACK_OF(SSL_CIPHER) *)SSL_get_ciphers(ssl);\n\n        if (dc->nOptions & SSL_OPT_OPTRENEGOTIATE) {\n            /* optimized way */\n            if ((!cipher && cipher_list) ||\n                (cipher && !cipher_list))\n            {\n                renegotiate = TRUE;\n            }\n            else if (cipher && cipher_list &&\n                     (sk_SSL_CIPHER_find(cipher_list, cipher) < 0))\n            {\n                renegotiate = TRUE;\n            }\n        }\n        else {\n            /* paranoid way */\n            if ((!cipher_list_old && cipher_list) ||\n                (cipher_list_old && !cipher_list))\n            {\n                renegotiate = TRUE;\n            }\n            else if (cipher_list_old && cipher_list) {\n                for (n = 0;\n                     !renegotiate && (n < sk_SSL_CIPHER_num(cipher_list));\n                     n++)\n                {\n                    const SSL_CIPHER *value = sk_SSL_CIPHER_value(cipher_list, n);\n\n                    if (sk_SSL_CIPHER_find(cipher_list_old, value) < 0) {\n                        renegotiate = TRUE;\n                    }\n                }\n\n                for (n = 0;\n                     !renegotiate && (n < sk_SSL_CIPHER_num(cipher_list_old));\n                     n++)\n                {\n                    const SSL_CIPHER *value = sk_SSL_CIPHER_value(cipher_list_old, n);\n\n                    if (sk_SSL_CIPHER_find(cipher_list, value) < 0) {\n                        renegotiate = TRUE;\n                    }\n                }\n            }\n        }\n\n        /* cleanup */\n        if (cipher_list_old) {\n            sk_SSL_CIPHER_free(cipher_list_old);\n        }\n\n        if (renegotiate) {\n            if (is_slave) {\n                /* The request causes renegotiation on a slave connection.\n                 * This is not allowed since we might have concurrent requests\n                 * on this connection.\n                 */\n                apr_table_setn(r->notes, \"ssl-renegotiate-forbidden\", \"cipher-suite\");\n                return HTTP_FORBIDDEN;\n            }\n            \n#ifdef SSL_OP_CIPHER_SERVER_PREFERENCE\n            if (sc->cipher_server_pref == TRUE) {\n                SSL_set_options(ssl, SSL_OP_CIPHER_SERVER_PREFERENCE);\n            }\n#endif\n            /* tracing */\n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02220)\n                         \"Reconfigured cipher suite will force renegotiation\");\n        }\n    }\n\n    /*\n     * override of SSLVerifyClient\n     *\n     * We force a renegotiation if the reconfigured/new verify type is\n     * stronger than the currently active verify type.\n     *\n     * The order is: none << optional_no_ca << optional << require\n     *\n     * Additionally the following optimization is possible here: When the\n     * currently active verify type is \"none\" but a client certificate is\n     * already known/present, it's enough to manually force a client\n     * verification but at least skip the I/O-intensive renegotiation\n     * handshake.\n     */\n    if ((dc->nVerifyClient != SSL_CVERIFY_UNSET) ||\n        (sc->server->auth.verify_mode != SSL_CVERIFY_UNSET)) {\n\n        /* remember old state */\n        verify_old = SSL_get_verify_mode(ssl);\n        /* configure new state */\n        verify = SSL_VERIFY_NONE;\n\n        if ((dc->nVerifyClient == SSL_CVERIFY_REQUIRE) ||\n            (sc->server->auth.verify_mode == SSL_CVERIFY_REQUIRE)) {\n            verify |= SSL_VERIFY_PEER_STRICT;\n        }\n\n        if ((dc->nVerifyClient == SSL_CVERIFY_OPTIONAL) ||\n            (dc->nVerifyClient == SSL_CVERIFY_OPTIONAL_NO_CA) ||\n            (sc->server->auth.verify_mode == SSL_CVERIFY_OPTIONAL) ||\n            (sc->server->auth.verify_mode == SSL_CVERIFY_OPTIONAL_NO_CA))\n        {\n            verify |= SSL_VERIFY_PEER;\n        }\n\n        /* TODO: this seems premature since we do not know if there\n         *       are any changes required.\n         */\n        SSL_set_verify(ssl, verify, ssl_callback_SSLVerify);\n        SSL_set_verify_result(ssl, X509_V_OK);\n\n        /* determine whether we've to force a renegotiation */\n        if (!renegotiate && verify != verify_old) {\n            if (((verify_old == SSL_VERIFY_NONE) &&\n                 (verify     != SSL_VERIFY_NONE)) ||\n\n                (!(verify_old & SSL_VERIFY_PEER) &&\n                  (verify     & SSL_VERIFY_PEER)) ||\n\n                (!(verify_old & SSL_VERIFY_FAIL_IF_NO_PEER_CERT) &&\n                  (verify     & SSL_VERIFY_FAIL_IF_NO_PEER_CERT)))\n            {\n                renegotiate = TRUE;\n                if (is_slave) {\n                    /* The request causes renegotiation on a slave connection.\n                     * This is not allowed since we might have concurrent requests\n                     * on this connection.\n                     */\n                    apr_table_setn(r->notes, \"ssl-renegotiate-forbidden\", \"verify-client\");\n                    SSL_set_verify(ssl, verify_old, ssl_callback_SSLVerify);\n                    return HTTP_FORBIDDEN;\n                }\n                /* optimization */\n\n                if ((dc->nOptions & SSL_OPT_OPTRENEGOTIATE) &&\n                    (verify_old == SSL_VERIFY_NONE) &&\n                    ((peercert = SSL_get_peer_certificate(ssl)) != NULL))\n                {\n                    renegotiate_quick = TRUE;\n                    X509_free(peercert);\n                }\n\n                ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02255)\n                              \"Changed client verification type will force \"\n                              \"%srenegotiation\",\n                              renegotiate_quick ? \"quick \" : \"\");\n            }\n            else if (verify != SSL_VERIFY_NONE) {\n                /*\n                 * override of SSLVerifyDepth\n                 *\n                 * The depth checks are handled by us manually inside the\n                 * verify callback function and not by OpenSSL internally\n                 * (and our function is aware of both the per-server and\n                 * per-directory contexts). So we cannot ask OpenSSL about\n                 * the currently verify depth. Instead we remember it in our\n                 * SSLConnRec attached to the SSL* of OpenSSL.  We've to force\n                 * the renegotiation if the reconfigured/new verify depth is\n                 * less than the currently active/remembered verify depth\n                 * (because this means more restriction on the certificate\n                 * chain).\n                 */\n                n = (sslconn->verify_depth != UNSET)\n                    ? sslconn->verify_depth\n                    : hssc->server->auth.verify_depth;\n                /* determine the new depth */\n                sslconn->verify_depth = (dc->nVerifyDepth != UNSET)\n                                        ? dc->nVerifyDepth\n                                        : sc->server->auth.verify_depth;\n                if (sslconn->verify_depth < n) {\n                    renegotiate = TRUE;\n                    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02254)\n                                  \"Reduced client verification depth will \"\n                                  \"force renegotiation\");\n                }\n            }\n        }\n        /* If we're handling a request for a vhost other than the default one,\n         * then we need to make sure that client authentication is properly\n         * enforced. For clients supplying an SNI extension, the peer\n         * certificate verification has happened in the handshake already\n         * (and r->server == handshakeserver). For non-SNI requests,\n         * an additional check is needed here. If client authentication\n         * is configured as mandatory, then we can only proceed if the\n         * CA list doesn't have to be changed (OpenSSL doesn't provide\n         * an option to change the list for an existing session).\n         */\n        if ((r->server != handshakeserver)\n            && renegotiate\n            && ((verify & SSL_VERIFY_PEER) ||\n                (verify & SSL_VERIFY_FAIL_IF_NO_PEER_CERT))) {\n#define MODSSL_CFG_CA_NE(f, sc1, sc2) \\\n            (sc1->server->auth.f && \\\n             (!sc2->server->auth.f || \\\n              strNE(sc1->server->auth.f, sc2->server->auth.f)))\n\n            if (MODSSL_CFG_CA_NE(ca_cert_file, sc, hssc) ||\n                MODSSL_CFG_CA_NE(ca_cert_path, sc, hssc)) {\n                if (verify & SSL_VERIFY_FAIL_IF_NO_PEER_CERT) {\n                    ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(02256)\n                         \"Non-default virtual host with SSLVerify set to \"\n                         \"'require' and VirtualHost-specific CA certificate \"\n                         \"list is only available to clients with TLS server \"\n                         \"name indication (SNI) support\");\n                    SSL_set_verify(ssl, verify_old, NULL);\n                    return HTTP_FORBIDDEN;\n                } else\n                    /* let it pass, possibly with an \"incorrect\" peer cert,\n                     * so make sure the SSL_CLIENT_VERIFY environment variable\n                     * will indicate partial success only, later on.\n                     */\n                    sslconn->verify_info = \"GENEROUS\";\n            }\n        }\n    }\n\n    /* If a renegotiation is now required for this location, and the\n     * request includes a message body (and the client has not\n     * requested a \"100 Continue\" response), then the client will be\n     * streaming the request body over the wire already.  In that\n     * case, it is not possible to stop and perform a new SSL\n     * handshake immediately; once the SSL library moves to the\n     * \"accept\" state, it will reject the SSL packets which the client\n     * is sending for the request body.\n     *\n     * To allow authentication to complete in this auth hook, the\n     * solution used here is to fill a (bounded) buffer with the\n     * request body, and then to reinject that request body later.\n     */\n    if (renegotiate && !renegotiate_quick\n        && (apr_table_get(r->headers_in, \"transfer-encoding\")\n            || (apr_table_get(r->headers_in, \"content-length\")\n                && strcmp(apr_table_get(r->headers_in, \"content-length\"), \"0\")))\n        && !r->expecting_100) {\n        int rv;\n        apr_size_t rsize;\n\n        rsize = dc->nRenegBufferSize == UNSET ? DEFAULT_RENEG_BUFFER_SIZE :\n                                                dc->nRenegBufferSize;\n        if (rsize > 0) {\n            /* Fill the I/O buffer with the request body if possible. */\n            rv = ssl_io_buffer_fill(r, rsize);\n        }\n        else {\n            /* If the reneg buffer size is set to zero, just fail. */\n            rv = HTTP_REQUEST_ENTITY_TOO_LARGE;\n        }\n\n        if (rv) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02257)\n                          \"could not buffer message body to allow \"\n                          \"SSL renegotiation to proceed\");\n            return rv;\n        }\n    }\n\n    /*\n     * now do the renegotiation if anything was actually reconfigured\n     */\n    if (renegotiate) {\n        /*\n         * Now we force the SSL renegotiation by sending the Hello Request\n         * message to the client. Here we have to do a workaround: Actually\n         * OpenSSL returns immediately after sending the Hello Request (the\n         * intent AFAIK is because the SSL/TLS protocol says it's not a must\n         * that the client replies to a Hello Request). But because we insist\n         * on a reply (anything else is an error for us) we have to go to the\n         * ACCEPT state manually. Using SSL_set_accept_state() doesn't work\n         * here because it resets too much of the connection.  So we set the\n         * state explicitly and continue the handshake manually.\n         */\n        ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(02221)\n                      \"Requesting connection re-negotiation\");\n\n        if (renegotiate_quick) {\n            STACK_OF(X509) *cert_stack;\n\n            /* perform just a manual re-verification of the peer */\n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02258)\n                         \"Performing quick renegotiation: \"\n                         \"just re-verifying the peer\");\n\n            cert_stack = (STACK_OF(X509) *)SSL_get_peer_cert_chain(ssl);\n\n            cert = SSL_get_peer_certificate(ssl);\n\n            if (!cert_stack && cert) {\n                /* client cert is in the session cache, but there is\n                 * no chain, since ssl3_get_client_certificate()\n                 * sk_X509_shift-ed the peer cert out of the chain.\n                 * we put it back here for the purpose of quick_renegotiation.\n                 */\n                cert_stack = sk_X509_new_null();\n                sk_X509_push(cert_stack, cert);\n            }\n\n            if (!cert_stack || (sk_X509_num(cert_stack) == 0)) {\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02222)\n                              \"Cannot find peer certificate chain\");\n\n                return HTTP_FORBIDDEN;\n            }\n\n            if (!(cert_store ||\n                  (cert_store = SSL_CTX_get_cert_store(ctx))))\n            {\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02223)\n                              \"Cannot find certificate storage\");\n\n                return HTTP_FORBIDDEN;\n            }\n\n            if (!cert) {\n                cert = sk_X509_value(cert_stack, 0);\n            }\n\n            cert_store_ctx = X509_STORE_CTX_new();\n            X509_STORE_CTX_init(cert_store_ctx, cert_store, cert, cert_stack);\n            depth = SSL_get_verify_depth(ssl);\n\n            if (depth >= 0) {\n                X509_STORE_CTX_set_depth(cert_store_ctx, depth);\n            }\n\n            X509_STORE_CTX_set_ex_data(cert_store_ctx,\n                                       SSL_get_ex_data_X509_STORE_CTX_idx(),\n                                       (char *)ssl);\n\n            if (!X509_verify_cert(cert_store_ctx)) {\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02224)\n                              \"Re-negotiation verification step failed\");\n                ssl_log_ssl_error(SSLLOG_MARK, APLOG_ERR, r->server);\n            }\n\n            SSL_set_verify_result(ssl, X509_STORE_CTX_get_error(cert_store_ctx));\n            X509_STORE_CTX_cleanup(cert_store_ctx);\n            X509_STORE_CTX_free(cert_store_ctx);\n\n            if (cert_stack != SSL_get_peer_cert_chain(ssl)) {\n                /* we created this ourselves, so free it */\n                sk_X509_pop_free(cert_stack, X509_free);\n            }\n        }\n        else {\n            char peekbuf[1];\n            const char *reneg_support;\n            request_rec *id = r->main ? r->main : r;\n\n            /* Additional mitigation for CVE-2009-3555: At this point,\n             * before renegotiating, an (entire) request has been read\n             * from the connection.  An attacker may have sent further\n             * data to \"prefix\" any subsequent request by the victim's\n             * client after the renegotiation; this data may already\n             * have been read and buffered.  Forcing a connection\n             * closure after the response ensures such data will be\n             * discarded.  Legimately pipelined HTTP requests will be\n             * retried anyway with this approach. */\n            if (has_buffered_data(r)) {\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02259)\n                              \"insecure SSL re-negotiation required, but \"\n                              \"a pipelined request is present; keepalive \"\n                              \"disabled\");\n                r->connection->keepalive = AP_CONN_CLOSE;\n            }\n\n#if defined(SSL_get_secure_renegotiation_support)\n            reneg_support = SSL_get_secure_renegotiation_support(ssl) ?\n                            \"client does\" : \"client does not\";\n#else\n            reneg_support = \"server does not\";\n#endif\n            /* Perform a full renegotiation. */\n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(02260)\n                          \"Performing full renegotiation: complete handshake \"\n                          \"protocol (%s support secure renegotiation)\",\n                          reneg_support);\n\n            SSL_set_session_id_context(ssl,\n                                       (unsigned char *)&id,\n                                       sizeof(id));\n\n            /* Toggle the renegotiation state to allow the new\n             * handshake to proceed. */\n            sslconn->reneg_state = RENEG_ALLOW;\n\n            SSL_renegotiate(ssl);\n            SSL_do_handshake(ssl);\n\n            if (!SSL_is_init_finished(ssl)) {\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02225)\n                              \"Re-negotiation request failed\");\n                ssl_log_ssl_error(SSLLOG_MARK, APLOG_ERR, r->server);\n\n                r->connection->keepalive = AP_CONN_CLOSE;\n                return HTTP_FORBIDDEN;\n            }\n\n            ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(02226)\n                          \"Awaiting re-negotiation handshake\");\n\n            /* XXX: Should replace setting state with SSL_renegotiate(ssl);\n             * However, this causes failures in perl-framework currently,\n             * perhaps pre-test if we have already negotiated?\n             */\n            /* Need to trigger renegotiation handshake by reading.\n             * Peeking 0 bytes actually works.\n             * See: http://marc.info/?t=145493359200002&r=1&w=2\n             */\n            SSL_peek(ssl, peekbuf, 0);\n\n            sslconn->reneg_state = RENEG_REJECT;\n\n            if (!SSL_is_init_finished(ssl)) {\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02261)\n                              \"Re-negotiation handshake failed\");\n                ssl_log_ssl_error(SSLLOG_MARK, APLOG_ERR, r->server);\n\n                r->connection->keepalive = AP_CONN_CLOSE;\n                return HTTP_FORBIDDEN;\n            }\n\n            /* Full renegotiation successfull, we now have handshaken with\n             * this server's parameters.\n             */\n            sslconn->server = r->server;\n        }\n\n        /*\n         * Remember the peer certificate's DN\n         */\n        if ((cert = SSL_get_peer_certificate(ssl))) {\n            if (sslconn->client_cert) {\n                X509_free(sslconn->client_cert);\n            }\n            sslconn->client_cert = cert;\n            sslconn->client_dn = NULL;\n        }\n\n        /*\n         * Finally check for acceptable renegotiation results\n         */\n        if ((dc->nVerifyClient != SSL_CVERIFY_NONE) ||\n            (sc->server->auth.verify_mode != SSL_CVERIFY_NONE)) {\n            BOOL do_verify = ((dc->nVerifyClient == SSL_CVERIFY_REQUIRE) ||\n                              (sc->server->auth.verify_mode == SSL_CVERIFY_REQUIRE));\n\n            if (do_verify && (SSL_get_verify_result(ssl) != X509_V_OK)) {\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02262)\n                              \"Re-negotiation handshake failed: \"\n                              \"Client verification failed\");\n\n                return HTTP_FORBIDDEN;\n            }\n\n            if (do_verify) {\n                if ((peercert = SSL_get_peer_certificate(ssl)) == NULL) {\n                    ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02263)\n                                  \"Re-negotiation handshake failed: \"\n                                  \"Client certificate missing\");\n\n                    return HTTP_FORBIDDEN;\n                }\n\n                X509_free(peercert);\n            }\n        }\n\n        /*\n         * Also check that SSLCipherSuite has been enforced as expected.\n         */\n        if (cipher_list) {\n            cipher = SSL_get_current_cipher(ssl);\n            if (sk_SSL_CIPHER_find(cipher_list, cipher) < 0) {\n                ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02264)\n                             \"SSL cipher suite not renegotiated: \"\n                             \"access to %s denied using cipher %s\",\n                              r->filename,\n                              SSL_CIPHER_get_name(cipher));\n                return HTTP_FORBIDDEN;\n            }\n        }\n        /* remember any new cipher suite used in renegotiation */\n        if (ncipher_suite) {\n            sslconn->cipher_suite = ncipher_suite;\n        }\n    }\n\n    /* If we're trying to have the user name set from a client\n     * certificate then we need to set it here. This should be safe as\n     * the user name probably isn't important from an auth checking point\n     * of view as the certificate supplied acts in that capacity.\n     * However, if FakeAuth is being used then this isn't the case so\n     * we need to postpone setting the username until later.\n     */\n    if ((dc->nOptions & SSL_OPT_FAKEBASICAUTH) == 0 && dc->szUserName) {\n        char *val = ssl_var_lookup(r->pool, r->server, r->connection,\n                                   r, (char *)dc->szUserName);\n        if (val && val[0])\n            r->user = val;\n        else\n            ap_log_rerror(APLOG_MARK, APLOG_WARNING, 0, r, APLOGNO(02227)\n                          \"Failed to set r->user to '%s'\", dc->szUserName);\n    }\n\n    /*\n     * Check SSLRequire boolean expressions\n     */\n    requires = dc->aRequirement;\n    ssl_requires = (ssl_require_t *)requires->elts;\n\n    for (i = 0; i < requires->nelts; i++) {\n        ssl_require_t *req = &ssl_requires[i];\n        const char *errstring;\n        ok = ap_expr_exec(r, req->mpExpr, &errstring);\n\n        if (ok < 0) {\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02265)\n                          \"access to %s failed, reason: Failed to execute \"\n                          \"SSL requirement expression: %s\",\n                          r->filename, errstring);\n\n            /* remember forbidden access for strict require option */\n            apr_table_setn(r->notes, \"ssl-access-forbidden\", \"1\");\n\n            return HTTP_FORBIDDEN;\n        }\n\n        if (ok != 1) {\n            ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(02266)\n                          \"Access to %s denied for %s \"\n                          \"(requirement expression not fulfilled)\",\n                          r->filename, r->useragent_ip);\n\n            ap_log_rerror(APLOG_MARK, APLOG_INFO, 0, r, APLOGNO(02228)\n                          \"Failed expression: %s\", req->cpExpr);\n\n            ap_log_rerror(APLOG_MARK, APLOG_ERR, 0, r, APLOGNO(02229)\n                          \"access to %s failed, reason: %s\",\n                          r->filename,\n                          \"SSL requirement expression not fulfilled\");\n\n            /* remember forbidden access for strict require option */\n            apr_table_setn(r->notes, \"ssl-access-forbidden\", \"1\");\n\n            return HTTP_FORBIDDEN;\n        }\n    }\n\n    /*\n     * Else access is granted from our point of view (except vendor\n     * handlers override). But we have to return DECLINED here instead\n     * of OK, because mod_auth and other modules still might want to\n     * deny access.\n     */\n\n    return DECLINED;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -309,6 +309,7 @@\n                      * on this connection.\n                      */\n                     apr_table_setn(r->notes, \"ssl-renegotiate-forbidden\", \"verify-client\");\n+                    SSL_set_verify(ssl, verify_old, ssl_callback_SSLVerify);\n                     return HTTP_FORBIDDEN;\n                 }\n                 /* optimization */",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "                    SSL_set_verify(ssl, verify_old, ssl_callback_SSLVerify);"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-5130",
        "func_name": "chromium/HistoryController::UpdateForCommit",
        "description": "content/renderer/history_controller.cc in Google Chrome before 52.0.2743.82 does not properly restrict multiple uses of a JavaScript forward method, which allows remote attackers to spoof the URL display via a crafted web site.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/ab22bdfc5cb681f2f4dc789171e97618a9657486",
        "commit_title": "Update HistoryController::current_entry_ on all main frame back/forwards.",
        "commit_text": " This fixes a case where it was left stale on a cross-origin commit because the provisional_entry_ had been cleared by a different commit.  CQ_INCLUDE_TRYBOTS=tryserver.chromium.linux:linux_site_isolation  Review-Url: https://codereview.chromium.org/2134493002 ",
        "func_before": "void HistoryController::UpdateForCommit(RenderFrameImpl* frame,\n                                        const WebHistoryItem& item,\n                                        WebHistoryCommitType commit_type,\n                                        bool navigation_within_page) {\n  switch (commit_type) {\n    case blink::WebBackForwardCommit:\n      if (!provisional_entry_)\n        return;\n\n      // If the current entry is null, this must be a main frame commit.\n      DCHECK(current_entry_ || frame->IsMainFrame());\n\n      // Commit the provisional entry, but only if it is a plausible transition.\n      // Do not commit it if the navigation is in a subframe and the provisional\n      // entry's main frame item does not match the current entry's main frame,\n      // which can happen if multiple forward navigations occur.  In that case,\n      // committing the provisional entry would corrupt it, leading to a URL\n      // spoof.  See https://crbug.com/597322.  (Note that the race in this bug\n      // does not affect main frame navigations, only navigations in subframes.)\n      //\n      // Note that we cannot compare the provisional entry against |item|, since\n      // |item| may have redirected to a different URL and ISN.  We also cannot\n      // compare against the main frame's URL, since that may have changed due\n      // to a replaceState.  (Even origin can change on replaceState in certain\n      // modes.)\n      //\n      // It would be safe to additionally check the ISNs of all parent frames\n      // (and not just the root), but that is less critical because it won't\n      // lead to a URL spoof.\n      if (frame->IsMainFrame() ||\n          current_entry_->root().itemSequenceNumber() ==\n              provisional_entry_->root().itemSequenceNumber()) {\n        current_entry_.reset(provisional_entry_.release());\n      }\n\n      // We're guaranteed to have a current entry now.\n      DCHECK(current_entry_);\n\n      if (HistoryEntry::HistoryNode* node =\n              current_entry_->GetHistoryNodeForFrame(frame)) {\n        node->set_item(item);\n      }\n      break;\n    case blink::WebStandardCommit:\n      CreateNewBackForwardItem(frame, item, navigation_within_page);\n      break;\n    case blink::WebInitialCommitInChildFrame:\n      UpdateForInitialLoadInChildFrame(frame, item);\n      break;\n    case blink::WebHistoryInertCommit:\n      // Even for inert commits (e.g., location.replace, client redirects), make\n      // sure the current entry gets updated, if there is one.\n      if (current_entry_) {\n        if (HistoryEntry::HistoryNode* node =\n                current_entry_->GetHistoryNodeForFrame(frame)) {\n          // Inert commits that reset the page without changing the item (e.g.,\n          // reloads, location.replace) shouldn't keep the old subtree.\n          if (!navigation_within_page)\n            node->RemoveChildren();\n          node->set_item(item);\n        }\n      }\n      break;\n    default:\n      NOTREACHED() << \"Invalid commit type: \" << commit_type;\n  }\n}",
        "func": "void HistoryController::UpdateForCommit(RenderFrameImpl* frame,\n                                        const WebHistoryItem& item,\n                                        WebHistoryCommitType commit_type,\n                                        bool navigation_within_page) {\n  switch (commit_type) {\n    case blink::WebBackForwardCommit:\n      if (!provisional_entry_) {\n        // The provisional entry may have been discarded due to a navigation in\n        // a different frame.  For main frames, it is not safe to leave the\n        // current_entry_ in place, which may have a cross-site page and will be\n        // included in the PageState for this commit.  Replace it with a new\n        // HistoryEntry corresponding to the commit.\n        //\n        // This will lack any subframe history items that were in the original\n        // provisional entry, but we don't know what those were after discarding\n        // it.  We'll load the default URL in those subframes instead.\n        //\n        // TODO(creis): It's also possible to get here for subframe commits.\n        // We'll leave a stale current_entry_ in that case, but that only causes\n        // an earlier URL to load in the subframe when leaving and coming back,\n        // and only in rare cases.  It does not risk a URL spoof, unlike the\n        // main frame case.  Since this bug is not present in the new\n        // FrameNavigationEntry-based navigation path (https://crbug.com/236848)\n        // we'll wait for that to fix the subframe case.\n        if (frame->IsMainFrame())\n          current_entry_.reset(new HistoryEntry(item));\n\n        return;\n      }\n\n      // If the current entry is null, this must be a main frame commit.\n      DCHECK(current_entry_ || frame->IsMainFrame());\n\n      // Commit the provisional entry, but only if it is a plausible transition.\n      // Do not commit it if the navigation is in a subframe and the provisional\n      // entry's main frame item does not match the current entry's main frame,\n      // which can happen if multiple forward navigations occur.  In that case,\n      // committing the provisional entry would corrupt it, leading to a URL\n      // spoof.  See https://crbug.com/597322.  (Note that the race in this bug\n      // does not affect main frame navigations, only navigations in subframes.)\n      //\n      // Note that we cannot compare the provisional entry against |item|, since\n      // |item| may have redirected to a different URL and ISN.  We also cannot\n      // compare against the main frame's URL, since that may have changed due\n      // to a replaceState.  (Even origin can change on replaceState in certain\n      // modes.)\n      //\n      // It would be safe to additionally check the ISNs of all parent frames\n      // (and not just the root), but that is less critical because it won't\n      // lead to a URL spoof.\n      if (frame->IsMainFrame() ||\n          current_entry_->root().itemSequenceNumber() ==\n              provisional_entry_->root().itemSequenceNumber()) {\n        current_entry_.reset(provisional_entry_.release());\n      }\n\n      // We're guaranteed to have a current entry now.\n      DCHECK(current_entry_);\n\n      if (HistoryEntry::HistoryNode* node =\n              current_entry_->GetHistoryNodeForFrame(frame)) {\n        node->set_item(item);\n      }\n      break;\n    case blink::WebStandardCommit:\n      CreateNewBackForwardItem(frame, item, navigation_within_page);\n      break;\n    case blink::WebInitialCommitInChildFrame:\n      UpdateForInitialLoadInChildFrame(frame, item);\n      break;\n    case blink::WebHistoryInertCommit:\n      // Even for inert commits (e.g., location.replace, client redirects), make\n      // sure the current entry gets updated, if there is one.\n      if (current_entry_) {\n        if (HistoryEntry::HistoryNode* node =\n                current_entry_->GetHistoryNodeForFrame(frame)) {\n          // Inert commits that reset the page without changing the item (e.g.,\n          // reloads, location.replace) shouldn't keep the old subtree.\n          if (!navigation_within_page)\n            node->RemoveChildren();\n          node->set_item(item);\n        }\n      }\n      break;\n    default:\n      NOTREACHED() << \"Invalid commit type: \" << commit_type;\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,8 +4,29 @@\n                                         bool navigation_within_page) {\n   switch (commit_type) {\n     case blink::WebBackForwardCommit:\n-      if (!provisional_entry_)\n+      if (!provisional_entry_) {\n+        // The provisional entry may have been discarded due to a navigation in\n+        // a different frame.  For main frames, it is not safe to leave the\n+        // current_entry_ in place, which may have a cross-site page and will be\n+        // included in the PageState for this commit.  Replace it with a new\n+        // HistoryEntry corresponding to the commit.\n+        //\n+        // This will lack any subframe history items that were in the original\n+        // provisional entry, but we don't know what those were after discarding\n+        // it.  We'll load the default URL in those subframes instead.\n+        //\n+        // TODO(creis): It's also possible to get here for subframe commits.\n+        // We'll leave a stale current_entry_ in that case, but that only causes\n+        // an earlier URL to load in the subframe when leaving and coming back,\n+        // and only in rare cases.  It does not risk a URL spoof, unlike the\n+        // main frame case.  Since this bug is not present in the new\n+        // FrameNavigationEntry-based navigation path (https://crbug.com/236848)\n+        // we'll wait for that to fix the subframe case.\n+        if (frame->IsMainFrame())\n+          current_entry_.reset(new HistoryEntry(item));\n+\n         return;\n+      }\n \n       // If the current entry is null, this must be a main frame commit.\n       DCHECK(current_entry_ || frame->IsMainFrame());",
        "diff_line_info": {
            "deleted_lines": [
                "      if (!provisional_entry_)"
            ],
            "added_lines": [
                "      if (!provisional_entry_) {",
                "        // The provisional entry may have been discarded due to a navigation in",
                "        // a different frame.  For main frames, it is not safe to leave the",
                "        // current_entry_ in place, which may have a cross-site page and will be",
                "        // included in the PageState for this commit.  Replace it with a new",
                "        // HistoryEntry corresponding to the commit.",
                "        //",
                "        // This will lack any subframe history items that were in the original",
                "        // provisional entry, but we don't know what those were after discarding",
                "        // it.  We'll load the default URL in those subframes instead.",
                "        //",
                "        // TODO(creis): It's also possible to get here for subframe commits.",
                "        // We'll leave a stale current_entry_ in that case, but that only causes",
                "        // an earlier URL to load in the subframe when leaving and coming back,",
                "        // and only in rare cases.  It does not risk a URL spoof, unlike the",
                "        // main frame case.  Since this bug is not present in the new",
                "        // FrameNavigationEntry-based navigation path (https://crbug.com/236848)",
                "        // we'll wait for that to fix the subframe case.",
                "        if (frame->IsMainFrame())",
                "          current_entry_.reset(new HistoryEntry(item));",
                "",
                "      }"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-5130",
        "func_name": "chromium/HistoryController::UpdateForCommit",
        "description": "content/renderer/history_controller.cc in Google Chrome before 52.0.2743.82 does not properly restrict multiple uses of a JavaScript forward method, which allows remote attackers to spoof the URL display via a crafted web site.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/4d78d33cb1852e7d487f1d327517c4c4044a3ca3",
        "commit_title": "Clear stale NavigationParams from HistoryController.",
        "commit_text": " This prevents newly created iframes during a back/forward from targeting the wrong NavigationEntry.  CQ_INCLUDE_TRYBOTS=tryserver.chromium.linux:linux_site_isolation  Review-Url: https://codereview.chromium.org/2144823002 ",
        "func_before": "void HistoryController::UpdateForCommit(RenderFrameImpl* frame,\n                                        const WebHistoryItem& item,\n                                        WebHistoryCommitType commit_type,\n                                        bool navigation_within_page) {\n  switch (commit_type) {\n    case blink::WebBackForwardCommit:\n      if (!provisional_entry_) {\n        // The provisional entry may have been discarded due to a navigation in\n        // a different frame.  For main frames, it is not safe to leave the\n        // current_entry_ in place, which may have a cross-site page and will be\n        // included in the PageState for this commit.  Replace it with a new\n        // HistoryEntry corresponding to the commit.\n        //\n        // This will lack any subframe history items that were in the original\n        // provisional entry, but we don't know what those were after discarding\n        // it.  We'll load the default URL in those subframes instead.\n        //\n        // TODO(creis): It's also possible to get here for subframe commits.\n        // We'll leave a stale current_entry_ in that case, but that only causes\n        // an earlier URL to load in the subframe when leaving and coming back,\n        // and only in rare cases.  It does not risk a URL spoof, unlike the\n        // main frame case.  Since this bug is not present in the new\n        // FrameNavigationEntry-based navigation path (https://crbug.com/236848)\n        // we'll wait for that to fix the subframe case.\n        if (frame->IsMainFrame())\n          current_entry_.reset(new HistoryEntry(item));\n\n        return;\n      }\n\n      // If the current entry is null, this must be a main frame commit.\n      DCHECK(current_entry_ || frame->IsMainFrame());\n\n      // Commit the provisional entry, but only if it is a plausible transition.\n      // Do not commit it if the navigation is in a subframe and the provisional\n      // entry's main frame item does not match the current entry's main frame,\n      // which can happen if multiple forward navigations occur.  In that case,\n      // committing the provisional entry would corrupt it, leading to a URL\n      // spoof.  See https://crbug.com/597322.  (Note that the race in this bug\n      // does not affect main frame navigations, only navigations in subframes.)\n      //\n      // Note that we cannot compare the provisional entry against |item|, since\n      // |item| may have redirected to a different URL and ISN.  We also cannot\n      // compare against the main frame's URL, since that may have changed due\n      // to a replaceState.  (Even origin can change on replaceState in certain\n      // modes.)\n      //\n      // It would be safe to additionally check the ISNs of all parent frames\n      // (and not just the root), but that is less critical because it won't\n      // lead to a URL spoof.\n      if (frame->IsMainFrame() ||\n          current_entry_->root().itemSequenceNumber() ==\n              provisional_entry_->root().itemSequenceNumber()) {\n        current_entry_.reset(provisional_entry_.release());\n      }\n\n      // We're guaranteed to have a current entry now.\n      DCHECK(current_entry_);\n\n      if (HistoryEntry::HistoryNode* node =\n              current_entry_->GetHistoryNodeForFrame(frame)) {\n        node->set_item(item);\n      }\n      break;\n    case blink::WebStandardCommit:\n      CreateNewBackForwardItem(frame, item, navigation_within_page);\n      break;\n    case blink::WebInitialCommitInChildFrame:\n      UpdateForInitialLoadInChildFrame(frame, item);\n      break;\n    case blink::WebHistoryInertCommit:\n      // Even for inert commits (e.g., location.replace, client redirects), make\n      // sure the current entry gets updated, if there is one.\n      if (current_entry_) {\n        if (HistoryEntry::HistoryNode* node =\n                current_entry_->GetHistoryNodeForFrame(frame)) {\n          // Inert commits that reset the page without changing the item (e.g.,\n          // reloads, location.replace) shouldn't keep the old subtree.\n          if (!navigation_within_page)\n            node->RemoveChildren();\n          node->set_item(item);\n        }\n      }\n      break;\n    default:\n      NOTREACHED() << \"Invalid commit type: \" << commit_type;\n  }\n}",
        "func": "void HistoryController::UpdateForCommit(RenderFrameImpl* frame,\n                                        const WebHistoryItem& item,\n                                        WebHistoryCommitType commit_type,\n                                        bool navigation_within_page) {\n  switch (commit_type) {\n    case blink::WebBackForwardCommit:\n      if (!provisional_entry_) {\n        // The provisional entry may have been discarded due to a navigation in\n        // a different frame.  For main frames, it is not safe to leave the\n        // current_entry_ in place, which may have a cross-site page and will be\n        // included in the PageState for this commit.  Replace it with a new\n        // HistoryEntry corresponding to the commit, and clear any stale\n        // NavigationParams which might point to the wrong entry.\n        //\n        // This will lack any subframe history items that were in the original\n        // provisional entry, but we don't know what those were after discarding\n        // it.  We'll load the default URL in those subframes instead.\n        //\n        // TODO(creis): It's also possible to get here for subframe commits.\n        // We'll leave a stale current_entry_ in that case, but that only causes\n        // an earlier URL to load in the subframe when leaving and coming back,\n        // and only in rare cases.  It does not risk a URL spoof, unlike the\n        // main frame case.  Since this bug is not present in the new\n        // FrameNavigationEntry-based navigation path (https://crbug.com/236848)\n        // we'll wait for that to fix the subframe case.\n        if (frame->IsMainFrame()) {\n          current_entry_.reset(new HistoryEntry(item));\n          navigation_params_.reset();\n        }\n\n        return;\n      }\n\n      // If the current entry is null, this must be a main frame commit.\n      DCHECK(current_entry_ || frame->IsMainFrame());\n\n      // Commit the provisional entry, but only if it is a plausible transition.\n      // Do not commit it if the navigation is in a subframe and the provisional\n      // entry's main frame item does not match the current entry's main frame,\n      // which can happen if multiple forward navigations occur.  In that case,\n      // committing the provisional entry would corrupt it, leading to a URL\n      // spoof.  See https://crbug.com/597322.  (Note that the race in this bug\n      // does not affect main frame navigations, only navigations in subframes.)\n      //\n      // Note that we cannot compare the provisional entry against |item|, since\n      // |item| may have redirected to a different URL and ISN.  We also cannot\n      // compare against the main frame's URL, since that may have changed due\n      // to a replaceState.  (Even origin can change on replaceState in certain\n      // modes.)\n      //\n      // It would be safe to additionally check the ISNs of all parent frames\n      // (and not just the root), but that is less critical because it won't\n      // lead to a URL spoof.\n      if (frame->IsMainFrame() ||\n          current_entry_->root().itemSequenceNumber() ==\n              provisional_entry_->root().itemSequenceNumber()) {\n        current_entry_.reset(provisional_entry_.release());\n      }\n\n      // We're guaranteed to have a current entry now.\n      DCHECK(current_entry_);\n\n      if (HistoryEntry::HistoryNode* node =\n              current_entry_->GetHistoryNodeForFrame(frame)) {\n        // Clear the children and any NavigationParams if this commit isn't for\n        // the same item.  Otherwise we might have stale data from a race.\n        if (node->item().itemSequenceNumber() != item.itemSequenceNumber()) {\n          node->RemoveChildren();\n          navigation_params_.reset();\n        }\n\n        node->set_item(item);\n      }\n      break;\n    case blink::WebStandardCommit:\n      CreateNewBackForwardItem(frame, item, navigation_within_page);\n      break;\n    case blink::WebInitialCommitInChildFrame:\n      UpdateForInitialLoadInChildFrame(frame, item);\n      break;\n    case blink::WebHistoryInertCommit:\n      // Even for inert commits (e.g., location.replace, client redirects), make\n      // sure the current entry gets updated, if there is one.\n      if (current_entry_) {\n        if (HistoryEntry::HistoryNode* node =\n                current_entry_->GetHistoryNodeForFrame(frame)) {\n          // Inert commits that reset the page without changing the item (e.g.,\n          // reloads, location.replace) shouldn't keep the old subtree.\n          if (!navigation_within_page)\n            node->RemoveChildren();\n          node->set_item(item);\n        }\n      }\n      break;\n    default:\n      NOTREACHED() << \"Invalid commit type: \" << commit_type;\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -9,7 +9,8 @@\n         // a different frame.  For main frames, it is not safe to leave the\n         // current_entry_ in place, which may have a cross-site page and will be\n         // included in the PageState for this commit.  Replace it with a new\n-        // HistoryEntry corresponding to the commit.\n+        // HistoryEntry corresponding to the commit, and clear any stale\n+        // NavigationParams which might point to the wrong entry.\n         //\n         // This will lack any subframe history items that were in the original\n         // provisional entry, but we don't know what those were after discarding\n@@ -22,8 +23,10 @@\n         // main frame case.  Since this bug is not present in the new\n         // FrameNavigationEntry-based navigation path (https://crbug.com/236848)\n         // we'll wait for that to fix the subframe case.\n-        if (frame->IsMainFrame())\n+        if (frame->IsMainFrame()) {\n           current_entry_.reset(new HistoryEntry(item));\n+          navigation_params_.reset();\n+        }\n \n         return;\n       }\n@@ -59,6 +62,13 @@\n \n       if (HistoryEntry::HistoryNode* node =\n               current_entry_->GetHistoryNodeForFrame(frame)) {\n+        // Clear the children and any NavigationParams if this commit isn't for\n+        // the same item.  Otherwise we might have stale data from a race.\n+        if (node->item().itemSequenceNumber() != item.itemSequenceNumber()) {\n+          node->RemoveChildren();\n+          navigation_params_.reset();\n+        }\n+\n         node->set_item(item);\n       }\n       break;",
        "diff_line_info": {
            "deleted_lines": [
                "        // HistoryEntry corresponding to the commit.",
                "        if (frame->IsMainFrame())"
            ],
            "added_lines": [
                "        // HistoryEntry corresponding to the commit, and clear any stale",
                "        // NavigationParams which might point to the wrong entry.",
                "        if (frame->IsMainFrame()) {",
                "          navigation_params_.reset();",
                "        }",
                "        // Clear the children and any NavigationParams if this commit isn't for",
                "        // the same item.  Otherwise we might have stale data from a race.",
                "        if (node->item().itemSequenceNumber() != item.itemSequenceNumber()) {",
                "          node->RemoveChildren();",
                "          navigation_params_.reset();",
                "        }",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2016-6258",
        "func_name": "xen-project/xen/mod_l1_entry",
        "description": "The PV pagetable code in arch/x86/mm.c in Xen 4.7.x and earlier allows local 32-bit PV guest OS administrators to gain host OS privileges by leveraging fast-paths for updating pagetable entries.",
        "git_url": "https://github.com/xen-project/xen/commit/e1bff4c2ea3b32464510ac00c320bba28a8dbcca",
        "commit_title": "x86/pv: Remove unsafe bits from the mod_l?_entry() fastpath",
        "commit_text": " All changes in writeability and cacheability must go through full re-validation.  Rework the logic as a whitelist, to make it clearer to follow.  This is XSA-182 ",
        "func_before": "static int mod_l1_entry(l1_pgentry_t *pl1e, l1_pgentry_t nl1e,\n                        unsigned long gl1mfn, int preserve_ad,\n                        struct vcpu *pt_vcpu, struct domain *pg_dom)\n{\n    l1_pgentry_t ol1e;\n    struct domain *pt_dom = pt_vcpu->domain;\n    int rc = 0;\n\n    if ( unlikely(__copy_from_user(&ol1e, pl1e, sizeof(ol1e)) != 0) )\n        return -EFAULT;\n\n    if ( unlikely(paging_mode_refcounts(pt_dom)) )\n    {\n        if ( UPDATE_ENTRY(l1, pl1e, ol1e, nl1e, gl1mfn, pt_vcpu, preserve_ad) )\n            return 0;\n        return -EBUSY;\n    }\n\n    if ( l1e_get_flags(nl1e) & _PAGE_PRESENT )\n    {\n        /* Translate foreign guest addresses. */\n        struct page_info *page = NULL;\n\n        if ( unlikely(l1e_get_flags(nl1e) & l1_disallow_mask(pt_dom)) )\n        {\n            MEM_LOG(\"Bad L1 flags %x\",\n                    l1e_get_flags(nl1e) & l1_disallow_mask(pt_dom));\n            return -EINVAL;\n        }\n\n        if ( paging_mode_translate(pg_dom) )\n        {\n            page = get_page_from_gfn(pg_dom, l1e_get_pfn(nl1e), NULL, P2M_ALLOC);\n            if ( !page )\n                return -EINVAL;\n            nl1e = l1e_from_pfn(page_to_mfn(page), l1e_get_flags(nl1e));\n        }\n\n        /* Fast path for identical mapping, r/w, presence, and cachability. */\n        if ( !l1e_has_changed(ol1e, nl1e,\n                              PAGE_CACHE_ATTRS | _PAGE_RW | _PAGE_PRESENT) )\n        {\n            adjust_guest_l1e(nl1e, pt_dom);\n            rc = UPDATE_ENTRY(l1, pl1e, ol1e, nl1e, gl1mfn, pt_vcpu,\n                              preserve_ad);\n            if ( page )\n                put_page(page);\n            return rc ? 0 : -EBUSY;\n        }\n\n        switch ( rc = get_page_from_l1e(nl1e, pt_dom, pg_dom) )\n        {\n        default:\n            if ( page )\n                put_page(page);\n            return rc;\n        case 0:\n            break;\n        case _PAGE_RW ... _PAGE_RW | PAGE_CACHE_ATTRS:\n            ASSERT(!(rc & ~(_PAGE_RW | PAGE_CACHE_ATTRS)));\n            l1e_flip_flags(nl1e, rc);\n            rc = 0;\n            break;\n        }\n        if ( page )\n            put_page(page);\n\n        adjust_guest_l1e(nl1e, pt_dom);\n        if ( unlikely(!UPDATE_ENTRY(l1, pl1e, ol1e, nl1e, gl1mfn, pt_vcpu,\n                                    preserve_ad)) )\n        {\n            ol1e = nl1e;\n            rc = -EBUSY;\n        }\n    }\n    else if ( unlikely(!UPDATE_ENTRY(l1, pl1e, ol1e, nl1e, gl1mfn, pt_vcpu,\n                                     preserve_ad)) )\n    {\n        return -EBUSY;\n    }\n\n    put_page_from_l1e(ol1e, pt_dom);\n    return rc;\n}",
        "func": "static int mod_l1_entry(l1_pgentry_t *pl1e, l1_pgentry_t nl1e,\n                        unsigned long gl1mfn, int preserve_ad,\n                        struct vcpu *pt_vcpu, struct domain *pg_dom)\n{\n    l1_pgentry_t ol1e;\n    struct domain *pt_dom = pt_vcpu->domain;\n    int rc = 0;\n\n    if ( unlikely(__copy_from_user(&ol1e, pl1e, sizeof(ol1e)) != 0) )\n        return -EFAULT;\n\n    if ( unlikely(paging_mode_refcounts(pt_dom)) )\n    {\n        if ( UPDATE_ENTRY(l1, pl1e, ol1e, nl1e, gl1mfn, pt_vcpu, preserve_ad) )\n            return 0;\n        return -EBUSY;\n    }\n\n    if ( l1e_get_flags(nl1e) & _PAGE_PRESENT )\n    {\n        /* Translate foreign guest addresses. */\n        struct page_info *page = NULL;\n\n        if ( unlikely(l1e_get_flags(nl1e) & l1_disallow_mask(pt_dom)) )\n        {\n            MEM_LOG(\"Bad L1 flags %x\",\n                    l1e_get_flags(nl1e) & l1_disallow_mask(pt_dom));\n            return -EINVAL;\n        }\n\n        if ( paging_mode_translate(pg_dom) )\n        {\n            page = get_page_from_gfn(pg_dom, l1e_get_pfn(nl1e), NULL, P2M_ALLOC);\n            if ( !page )\n                return -EINVAL;\n            nl1e = l1e_from_pfn(page_to_mfn(page), l1e_get_flags(nl1e));\n        }\n\n        /* Fast path for sufficiently-similar mappings. */\n        if ( !l1e_has_changed(ol1e, nl1e, ~FASTPATH_FLAG_WHITELIST) )\n        {\n            adjust_guest_l1e(nl1e, pt_dom);\n            rc = UPDATE_ENTRY(l1, pl1e, ol1e, nl1e, gl1mfn, pt_vcpu,\n                              preserve_ad);\n            if ( page )\n                put_page(page);\n            return rc ? 0 : -EBUSY;\n        }\n\n        switch ( rc = get_page_from_l1e(nl1e, pt_dom, pg_dom) )\n        {\n        default:\n            if ( page )\n                put_page(page);\n            return rc;\n        case 0:\n            break;\n        case _PAGE_RW ... _PAGE_RW | PAGE_CACHE_ATTRS:\n            ASSERT(!(rc & ~(_PAGE_RW | PAGE_CACHE_ATTRS)));\n            l1e_flip_flags(nl1e, rc);\n            rc = 0;\n            break;\n        }\n        if ( page )\n            put_page(page);\n\n        adjust_guest_l1e(nl1e, pt_dom);\n        if ( unlikely(!UPDATE_ENTRY(l1, pl1e, ol1e, nl1e, gl1mfn, pt_vcpu,\n                                    preserve_ad)) )\n        {\n            ol1e = nl1e;\n            rc = -EBUSY;\n        }\n    }\n    else if ( unlikely(!UPDATE_ENTRY(l1, pl1e, ol1e, nl1e, gl1mfn, pt_vcpu,\n                                     preserve_ad)) )\n    {\n        return -EBUSY;\n    }\n\n    put_page_from_l1e(ol1e, pt_dom);\n    return rc;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -36,9 +36,8 @@\n             nl1e = l1e_from_pfn(page_to_mfn(page), l1e_get_flags(nl1e));\n         }\n \n-        /* Fast path for identical mapping, r/w, presence, and cachability. */\n-        if ( !l1e_has_changed(ol1e, nl1e,\n-                              PAGE_CACHE_ATTRS | _PAGE_RW | _PAGE_PRESENT) )\n+        /* Fast path for sufficiently-similar mappings. */\n+        if ( !l1e_has_changed(ol1e, nl1e, ~FASTPATH_FLAG_WHITELIST) )\n         {\n             adjust_guest_l1e(nl1e, pt_dom);\n             rc = UPDATE_ENTRY(l1, pl1e, ol1e, nl1e, gl1mfn, pt_vcpu,",
        "diff_line_info": {
            "deleted_lines": [
                "        /* Fast path for identical mapping, r/w, presence, and cachability. */",
                "        if ( !l1e_has_changed(ol1e, nl1e,",
                "                              PAGE_CACHE_ATTRS | _PAGE_RW | _PAGE_PRESENT) )"
            ],
            "added_lines": [
                "        /* Fast path for sufficiently-similar mappings. */",
                "        if ( !l1e_has_changed(ol1e, nl1e, ~FASTPATH_FLAG_WHITELIST) )"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-6258",
        "func_name": "xen-project/xen/mod_l2_entry",
        "description": "The PV pagetable code in arch/x86/mm.c in Xen 4.7.x and earlier allows local 32-bit PV guest OS administrators to gain host OS privileges by leveraging fast-paths for updating pagetable entries.",
        "git_url": "https://github.com/xen-project/xen/commit/e1bff4c2ea3b32464510ac00c320bba28a8dbcca",
        "commit_title": "x86/pv: Remove unsafe bits from the mod_l?_entry() fastpath",
        "commit_text": " All changes in writeability and cacheability must go through full re-validation.  Rework the logic as a whitelist, to make it clearer to follow.  This is XSA-182 ",
        "func_before": "static int mod_l2_entry(l2_pgentry_t *pl2e, \n                        l2_pgentry_t nl2e, \n                        unsigned long pfn,\n                        int preserve_ad,\n                        struct vcpu *vcpu)\n{\n    l2_pgentry_t ol2e;\n    struct domain *d = vcpu->domain;\n    struct page_info *l2pg = mfn_to_page(pfn);\n    unsigned long type = l2pg->u.inuse.type_info;\n    int rc = 0;\n\n    if ( unlikely(!is_guest_l2_slot(d, type, pgentry_ptr_to_slot(pl2e))) )\n    {\n        MEM_LOG(\"Illegal L2 update attempt in Xen-private area %p\", pl2e);\n        return -EPERM;\n    }\n\n    if ( unlikely(__copy_from_user(&ol2e, pl2e, sizeof(ol2e)) != 0) )\n        return -EFAULT;\n\n    if ( l2e_get_flags(nl2e) & _PAGE_PRESENT )\n    {\n        if ( unlikely(l2e_get_flags(nl2e) & L2_DISALLOW_MASK) )\n        {\n            MEM_LOG(\"Bad L2 flags %x\",\n                    l2e_get_flags(nl2e) & L2_DISALLOW_MASK);\n            return -EINVAL;\n        }\n\n        /* Fast path for identical mapping and presence. */\n        if ( !l2e_has_changed(ol2e, nl2e,\n                              unlikely(opt_allow_superpage)\n                              ? _PAGE_PSE | _PAGE_RW | _PAGE_PRESENT\n                              : _PAGE_PRESENT) )\n        {\n            adjust_guest_l2e(nl2e, d);\n            if ( UPDATE_ENTRY(l2, pl2e, ol2e, nl2e, pfn, vcpu, preserve_ad) )\n                return 0;\n            return -EBUSY;\n        }\n\n        if ( unlikely((rc = get_page_from_l2e(nl2e, pfn, d)) < 0) )\n            return rc;\n\n        adjust_guest_l2e(nl2e, d);\n        if ( unlikely(!UPDATE_ENTRY(l2, pl2e, ol2e, nl2e, pfn, vcpu,\n                                    preserve_ad)) )\n        {\n            ol2e = nl2e;\n            rc = -EBUSY;\n        }\n    }\n    else if ( unlikely(!UPDATE_ENTRY(l2, pl2e, ol2e, nl2e, pfn, vcpu,\n                                     preserve_ad)) )\n    {\n        return -EBUSY;\n    }\n\n    put_page_from_l2e(ol2e, pfn);\n    return rc;\n}",
        "func": "static int mod_l2_entry(l2_pgentry_t *pl2e, \n                        l2_pgentry_t nl2e, \n                        unsigned long pfn,\n                        int preserve_ad,\n                        struct vcpu *vcpu)\n{\n    l2_pgentry_t ol2e;\n    struct domain *d = vcpu->domain;\n    struct page_info *l2pg = mfn_to_page(pfn);\n    unsigned long type = l2pg->u.inuse.type_info;\n    int rc = 0;\n\n    if ( unlikely(!is_guest_l2_slot(d, type, pgentry_ptr_to_slot(pl2e))) )\n    {\n        MEM_LOG(\"Illegal L2 update attempt in Xen-private area %p\", pl2e);\n        return -EPERM;\n    }\n\n    if ( unlikely(__copy_from_user(&ol2e, pl2e, sizeof(ol2e)) != 0) )\n        return -EFAULT;\n\n    if ( l2e_get_flags(nl2e) & _PAGE_PRESENT )\n    {\n        if ( unlikely(l2e_get_flags(nl2e) & L2_DISALLOW_MASK) )\n        {\n            MEM_LOG(\"Bad L2 flags %x\",\n                    l2e_get_flags(nl2e) & L2_DISALLOW_MASK);\n            return -EINVAL;\n        }\n\n        /* Fast path for sufficiently-similar mappings. */\n        if ( !l2e_has_changed(ol2e, nl2e, ~FASTPATH_FLAG_WHITELIST) )\n        {\n            adjust_guest_l2e(nl2e, d);\n            if ( UPDATE_ENTRY(l2, pl2e, ol2e, nl2e, pfn, vcpu, preserve_ad) )\n                return 0;\n            return -EBUSY;\n        }\n\n        if ( unlikely((rc = get_page_from_l2e(nl2e, pfn, d)) < 0) )\n            return rc;\n\n        adjust_guest_l2e(nl2e, d);\n        if ( unlikely(!UPDATE_ENTRY(l2, pl2e, ol2e, nl2e, pfn, vcpu,\n                                    preserve_ad)) )\n        {\n            ol2e = nl2e;\n            rc = -EBUSY;\n        }\n    }\n    else if ( unlikely(!UPDATE_ENTRY(l2, pl2e, ol2e, nl2e, pfn, vcpu,\n                                     preserve_ad)) )\n    {\n        return -EBUSY;\n    }\n\n    put_page_from_l2e(ol2e, pfn);\n    return rc;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -28,11 +28,8 @@\n             return -EINVAL;\n         }\n \n-        /* Fast path for identical mapping and presence. */\n-        if ( !l2e_has_changed(ol2e, nl2e,\n-                              unlikely(opt_allow_superpage)\n-                              ? _PAGE_PSE | _PAGE_RW | _PAGE_PRESENT\n-                              : _PAGE_PRESENT) )\n+        /* Fast path for sufficiently-similar mappings. */\n+        if ( !l2e_has_changed(ol2e, nl2e, ~FASTPATH_FLAG_WHITELIST) )\n         {\n             adjust_guest_l2e(nl2e, d);\n             if ( UPDATE_ENTRY(l2, pl2e, ol2e, nl2e, pfn, vcpu, preserve_ad) )",
        "diff_line_info": {
            "deleted_lines": [
                "        /* Fast path for identical mapping and presence. */",
                "        if ( !l2e_has_changed(ol2e, nl2e,",
                "                              unlikely(opt_allow_superpage)",
                "                              ? _PAGE_PSE | _PAGE_RW | _PAGE_PRESENT",
                "                              : _PAGE_PRESENT) )"
            ],
            "added_lines": [
                "        /* Fast path for sufficiently-similar mappings. */",
                "        if ( !l2e_has_changed(ol2e, nl2e, ~FASTPATH_FLAG_WHITELIST) )"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-6258",
        "func_name": "xen-project/xen/mod_l4_entry",
        "description": "The PV pagetable code in arch/x86/mm.c in Xen 4.7.x and earlier allows local 32-bit PV guest OS administrators to gain host OS privileges by leveraging fast-paths for updating pagetable entries.",
        "git_url": "https://github.com/xen-project/xen/commit/e1bff4c2ea3b32464510ac00c320bba28a8dbcca",
        "commit_title": "x86/pv: Remove unsafe bits from the mod_l?_entry() fastpath",
        "commit_text": " All changes in writeability and cacheability must go through full re-validation.  Rework the logic as a whitelist, to make it clearer to follow.  This is XSA-182 ",
        "func_before": "static int mod_l4_entry(l4_pgentry_t *pl4e, \n                        l4_pgentry_t nl4e, \n                        unsigned long pfn,\n                        int preserve_ad,\n                        struct vcpu *vcpu)\n{\n    struct domain *d = vcpu->domain;\n    l4_pgentry_t ol4e;\n    int rc = 0;\n\n    if ( unlikely(!is_guest_l4_slot(d, pgentry_ptr_to_slot(pl4e))) )\n    {\n        MEM_LOG(\"Illegal L4 update attempt in Xen-private area %p\", pl4e);\n        return -EINVAL;\n    }\n\n    if ( unlikely(__copy_from_user(&ol4e, pl4e, sizeof(ol4e)) != 0) )\n        return -EFAULT;\n\n    if ( l4e_get_flags(nl4e) & _PAGE_PRESENT )\n    {\n        if ( unlikely(l4e_get_flags(nl4e) & L4_DISALLOW_MASK) )\n        {\n            MEM_LOG(\"Bad L4 flags %x\",\n                    l4e_get_flags(nl4e) & L4_DISALLOW_MASK);\n            return -EINVAL;\n        }\n\n        /* Fast path for identical mapping and presence. */\n        if ( !l4e_has_changed(ol4e, nl4e, _PAGE_PRESENT) )\n        {\n            adjust_guest_l4e(nl4e, d);\n            rc = UPDATE_ENTRY(l4, pl4e, ol4e, nl4e, pfn, vcpu, preserve_ad);\n            return rc ? 0 : -EFAULT;\n        }\n\n        rc = get_page_from_l4e(nl4e, pfn, d, 0);\n        if ( unlikely(rc < 0) )\n            return rc;\n        rc = 0;\n\n        adjust_guest_l4e(nl4e, d);\n        if ( unlikely(!UPDATE_ENTRY(l4, pl4e, ol4e, nl4e, pfn, vcpu,\n                                    preserve_ad)) )\n        {\n            ol4e = nl4e;\n            rc = -EFAULT;\n        }\n    }\n    else if ( unlikely(!UPDATE_ENTRY(l4, pl4e, ol4e, nl4e, pfn, vcpu,\n                                     preserve_ad)) )\n    {\n        return -EFAULT;\n    }\n\n    put_page_from_l4e(ol4e, pfn, 0, 1);\n    return rc;\n}",
        "func": "static int mod_l4_entry(l4_pgentry_t *pl4e, \n                        l4_pgentry_t nl4e, \n                        unsigned long pfn,\n                        int preserve_ad,\n                        struct vcpu *vcpu)\n{\n    struct domain *d = vcpu->domain;\n    l4_pgentry_t ol4e;\n    int rc = 0;\n\n    if ( unlikely(!is_guest_l4_slot(d, pgentry_ptr_to_slot(pl4e))) )\n    {\n        MEM_LOG(\"Illegal L4 update attempt in Xen-private area %p\", pl4e);\n        return -EINVAL;\n    }\n\n    if ( unlikely(__copy_from_user(&ol4e, pl4e, sizeof(ol4e)) != 0) )\n        return -EFAULT;\n\n    if ( l4e_get_flags(nl4e) & _PAGE_PRESENT )\n    {\n        if ( unlikely(l4e_get_flags(nl4e) & L4_DISALLOW_MASK) )\n        {\n            MEM_LOG(\"Bad L4 flags %x\",\n                    l4e_get_flags(nl4e) & L4_DISALLOW_MASK);\n            return -EINVAL;\n        }\n\n        /* Fast path for sufficiently-similar mappings. */\n        if ( !l4e_has_changed(ol4e, nl4e, ~FASTPATH_FLAG_WHITELIST) )\n        {\n            adjust_guest_l4e(nl4e, d);\n            rc = UPDATE_ENTRY(l4, pl4e, ol4e, nl4e, pfn, vcpu, preserve_ad);\n            return rc ? 0 : -EFAULT;\n        }\n\n        rc = get_page_from_l4e(nl4e, pfn, d, 0);\n        if ( unlikely(rc < 0) )\n            return rc;\n        rc = 0;\n\n        adjust_guest_l4e(nl4e, d);\n        if ( unlikely(!UPDATE_ENTRY(l4, pl4e, ol4e, nl4e, pfn, vcpu,\n                                    preserve_ad)) )\n        {\n            ol4e = nl4e;\n            rc = -EFAULT;\n        }\n    }\n    else if ( unlikely(!UPDATE_ENTRY(l4, pl4e, ol4e, nl4e, pfn, vcpu,\n                                     preserve_ad)) )\n    {\n        return -EFAULT;\n    }\n\n    put_page_from_l4e(ol4e, pfn, 0, 1);\n    return rc;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -26,8 +26,8 @@\n             return -EINVAL;\n         }\n \n-        /* Fast path for identical mapping and presence. */\n-        if ( !l4e_has_changed(ol4e, nl4e, _PAGE_PRESENT) )\n+        /* Fast path for sufficiently-similar mappings. */\n+        if ( !l4e_has_changed(ol4e, nl4e, ~FASTPATH_FLAG_WHITELIST) )\n         {\n             adjust_guest_l4e(nl4e, d);\n             rc = UPDATE_ENTRY(l4, pl4e, ol4e, nl4e, pfn, vcpu, preserve_ad);",
        "diff_line_info": {
            "deleted_lines": [
                "        /* Fast path for identical mapping and presence. */",
                "        if ( !l4e_has_changed(ol4e, nl4e, _PAGE_PRESENT) )"
            ],
            "added_lines": [
                "        /* Fast path for sufficiently-similar mappings. */",
                "        if ( !l4e_has_changed(ol4e, nl4e, ~FASTPATH_FLAG_WHITELIST) )"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-6258",
        "func_name": "xen-project/xen/mod_l3_entry",
        "description": "The PV pagetable code in arch/x86/mm.c in Xen 4.7.x and earlier allows local 32-bit PV guest OS administrators to gain host OS privileges by leveraging fast-paths for updating pagetable entries.",
        "git_url": "https://github.com/xen-project/xen/commit/e1bff4c2ea3b32464510ac00c320bba28a8dbcca",
        "commit_title": "x86/pv: Remove unsafe bits from the mod_l?_entry() fastpath",
        "commit_text": " All changes in writeability and cacheability must go through full re-validation.  Rework the logic as a whitelist, to make it clearer to follow.  This is XSA-182 ",
        "func_before": "static int mod_l3_entry(l3_pgentry_t *pl3e, \n                        l3_pgentry_t nl3e, \n                        unsigned long pfn,\n                        int preserve_ad,\n                        struct vcpu *vcpu)\n{\n    l3_pgentry_t ol3e;\n    struct domain *d = vcpu->domain;\n    int rc = 0;\n\n    if ( unlikely(!is_guest_l3_slot(pgentry_ptr_to_slot(pl3e))) )\n    {\n        MEM_LOG(\"Illegal L3 update attempt in Xen-private area %p\", pl3e);\n        return -EINVAL;\n    }\n\n    /*\n     * Disallow updates to final L3 slot. It contains Xen mappings, and it\n     * would be a pain to ensure they remain continuously valid throughout.\n     */\n    if ( is_pv_32bit_domain(d) && (pgentry_ptr_to_slot(pl3e) >= 3) )\n        return -EINVAL;\n\n    if ( unlikely(__copy_from_user(&ol3e, pl3e, sizeof(ol3e)) != 0) )\n        return -EFAULT;\n\n    if ( l3e_get_flags(nl3e) & _PAGE_PRESENT )\n    {\n        if ( unlikely(l3e_get_flags(nl3e) & l3_disallow_mask(d)) )\n        {\n            MEM_LOG(\"Bad L3 flags %x\",\n                    l3e_get_flags(nl3e) & l3_disallow_mask(d));\n            return -EINVAL;\n        }\n\n        /* Fast path for identical mapping and presence. */\n        if ( !l3e_has_changed(ol3e, nl3e, _PAGE_PRESENT) )\n        {\n            adjust_guest_l3e(nl3e, d);\n            rc = UPDATE_ENTRY(l3, pl3e, ol3e, nl3e, pfn, vcpu, preserve_ad);\n            return rc ? 0 : -EFAULT;\n        }\n\n        rc = get_page_from_l3e(nl3e, pfn, d, 0);\n        if ( unlikely(rc < 0) )\n            return rc;\n        rc = 0;\n\n        adjust_guest_l3e(nl3e, d);\n        if ( unlikely(!UPDATE_ENTRY(l3, pl3e, ol3e, nl3e, pfn, vcpu,\n                                    preserve_ad)) )\n        {\n            ol3e = nl3e;\n            rc = -EFAULT;\n        }\n    }\n    else if ( unlikely(!UPDATE_ENTRY(l3, pl3e, ol3e, nl3e, pfn, vcpu,\n                                     preserve_ad)) )\n    {\n        return -EFAULT;\n    }\n\n    if ( likely(rc == 0) )\n        if ( !create_pae_xen_mappings(d, pl3e) )\n            BUG();\n\n    put_page_from_l3e(ol3e, pfn, 0, 1);\n    return rc;\n}",
        "func": "static int mod_l3_entry(l3_pgentry_t *pl3e, \n                        l3_pgentry_t nl3e, \n                        unsigned long pfn,\n                        int preserve_ad,\n                        struct vcpu *vcpu)\n{\n    l3_pgentry_t ol3e;\n    struct domain *d = vcpu->domain;\n    int rc = 0;\n\n    if ( unlikely(!is_guest_l3_slot(pgentry_ptr_to_slot(pl3e))) )\n    {\n        MEM_LOG(\"Illegal L3 update attempt in Xen-private area %p\", pl3e);\n        return -EINVAL;\n    }\n\n    /*\n     * Disallow updates to final L3 slot. It contains Xen mappings, and it\n     * would be a pain to ensure they remain continuously valid throughout.\n     */\n    if ( is_pv_32bit_domain(d) && (pgentry_ptr_to_slot(pl3e) >= 3) )\n        return -EINVAL;\n\n    if ( unlikely(__copy_from_user(&ol3e, pl3e, sizeof(ol3e)) != 0) )\n        return -EFAULT;\n\n    if ( l3e_get_flags(nl3e) & _PAGE_PRESENT )\n    {\n        if ( unlikely(l3e_get_flags(nl3e) & l3_disallow_mask(d)) )\n        {\n            MEM_LOG(\"Bad L3 flags %x\",\n                    l3e_get_flags(nl3e) & l3_disallow_mask(d));\n            return -EINVAL;\n        }\n\n        /* Fast path for sufficiently-similar mappings. */\n        if ( !l3e_has_changed(ol3e, nl3e, ~FASTPATH_FLAG_WHITELIST) )\n        {\n            adjust_guest_l3e(nl3e, d);\n            rc = UPDATE_ENTRY(l3, pl3e, ol3e, nl3e, pfn, vcpu, preserve_ad);\n            return rc ? 0 : -EFAULT;\n        }\n\n        rc = get_page_from_l3e(nl3e, pfn, d, 0);\n        if ( unlikely(rc < 0) )\n            return rc;\n        rc = 0;\n\n        adjust_guest_l3e(nl3e, d);\n        if ( unlikely(!UPDATE_ENTRY(l3, pl3e, ol3e, nl3e, pfn, vcpu,\n                                    preserve_ad)) )\n        {\n            ol3e = nl3e;\n            rc = -EFAULT;\n        }\n    }\n    else if ( unlikely(!UPDATE_ENTRY(l3, pl3e, ol3e, nl3e, pfn, vcpu,\n                                     preserve_ad)) )\n    {\n        return -EFAULT;\n    }\n\n    if ( likely(rc == 0) )\n        if ( !create_pae_xen_mappings(d, pl3e) )\n            BUG();\n\n    put_page_from_l3e(ol3e, pfn, 0, 1);\n    return rc;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -33,8 +33,8 @@\n             return -EINVAL;\n         }\n \n-        /* Fast path for identical mapping and presence. */\n-        if ( !l3e_has_changed(ol3e, nl3e, _PAGE_PRESENT) )\n+        /* Fast path for sufficiently-similar mappings. */\n+        if ( !l3e_has_changed(ol3e, nl3e, ~FASTPATH_FLAG_WHITELIST) )\n         {\n             adjust_guest_l3e(nl3e, d);\n             rc = UPDATE_ENTRY(l3, pl3e, ol3e, nl3e, pfn, vcpu, preserve_ad);",
        "diff_line_info": {
            "deleted_lines": [
                "        /* Fast path for identical mapping and presence. */",
                "        if ( !l3e_has_changed(ol3e, nl3e, _PAGE_PRESENT) )"
            ],
            "added_lines": [
                "        /* Fast path for sufficiently-similar mappings. */",
                "        if ( !l3e_has_changed(ol3e, nl3e, ~FASTPATH_FLAG_WHITELIST) )"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-6198",
        "func_name": "torvalds/linux/vfs_rename",
        "description": "The filesystem layer in the Linux kernel before 4.5.5 proceeds with post-rename operations after an OverlayFS file is renamed to a self-hardlink, which allows local users to cause a denial of service (system crash) via a rename system call, related to fs/namei.c and fs/open.c.",
        "git_url": "https://github.com/torvalds/linux/commit/9409e22acdfc9153f88d9b1ed2bd2a5b34d2d3ca",
        "commit_title": "vfs: rename: check backing inode being equal",
        "commit_text": " If a file is renamed to a hardlink of itself POSIX specifies that rename(2) should do nothing and return success.  This condition is checked in vfs_rename().  However it won't detect hard links on overlayfs where these are given separate inodes on the overlayfs layer.  Overlayfs itself detects this condition and returns success without doing anything, but then vfs_rename() will proceed as if this was a successful rename (detach_mounts(), d_move()).  The correct thing to do is to detect this condition before even calling into overlayfs.  This patch does this by calling vfs_select_inode() to get the underlying inodes.  Cc: <stable@vger.kernel.org> # v4.2+",
        "func_before": "int vfs_rename(struct inode *old_dir, struct dentry *old_dentry,\n\t       struct inode *new_dir, struct dentry *new_dentry,\n\t       struct inode **delegated_inode, unsigned int flags)\n{\n\tint error;\n\tbool is_dir = d_is_dir(old_dentry);\n\tconst unsigned char *old_name;\n\tstruct inode *source = old_dentry->d_inode;\n\tstruct inode *target = new_dentry->d_inode;\n\tbool new_is_dir = false;\n\tunsigned max_links = new_dir->i_sb->s_max_links;\n\n\tif (source == target)\n\t\treturn 0;\n\n\terror = may_delete(old_dir, old_dentry, is_dir);\n\tif (error)\n\t\treturn error;\n\n\tif (!target) {\n\t\terror = may_create(new_dir, new_dentry);\n\t} else {\n\t\tnew_is_dir = d_is_dir(new_dentry);\n\n\t\tif (!(flags & RENAME_EXCHANGE))\n\t\t\terror = may_delete(new_dir, new_dentry, is_dir);\n\t\telse\n\t\t\terror = may_delete(new_dir, new_dentry, new_is_dir);\n\t}\n\tif (error)\n\t\treturn error;\n\n\tif (!old_dir->i_op->rename && !old_dir->i_op->rename2)\n\t\treturn -EPERM;\n\n\tif (flags && !old_dir->i_op->rename2)\n\t\treturn -EINVAL;\n\n\t/*\n\t * If we are going to change the parent - check write permissions,\n\t * we'll need to flip '..'.\n\t */\n\tif (new_dir != old_dir) {\n\t\tif (is_dir) {\n\t\t\terror = inode_permission(source, MAY_WRITE);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t\tif ((flags & RENAME_EXCHANGE) && new_is_dir) {\n\t\t\terror = inode_permission(target, MAY_WRITE);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t}\n\n\terror = security_inode_rename(old_dir, old_dentry, new_dir, new_dentry,\n\t\t\t\t      flags);\n\tif (error)\n\t\treturn error;\n\n\told_name = fsnotify_oldname_init(old_dentry->d_name.name);\n\tdget(new_dentry);\n\tif (!is_dir || (flags & RENAME_EXCHANGE))\n\t\tlock_two_nondirectories(source, target);\n\telse if (target)\n\t\tinode_lock(target);\n\n\terror = -EBUSY;\n\tif (is_local_mountpoint(old_dentry) || is_local_mountpoint(new_dentry))\n\t\tgoto out;\n\n\tif (max_links && new_dir != old_dir) {\n\t\terror = -EMLINK;\n\t\tif (is_dir && !new_is_dir && new_dir->i_nlink >= max_links)\n\t\t\tgoto out;\n\t\tif ((flags & RENAME_EXCHANGE) && !is_dir && new_is_dir &&\n\t\t    old_dir->i_nlink >= max_links)\n\t\t\tgoto out;\n\t}\n\tif (is_dir && !(flags & RENAME_EXCHANGE) && target)\n\t\tshrink_dcache_parent(new_dentry);\n\tif (!is_dir) {\n\t\terror = try_break_deleg(source, delegated_inode);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\tif (target && !new_is_dir) {\n\t\terror = try_break_deleg(target, delegated_inode);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\tif (!old_dir->i_op->rename2) {\n\t\terror = old_dir->i_op->rename(old_dir, old_dentry,\n\t\t\t\t\t      new_dir, new_dentry);\n\t} else {\n\t\tWARN_ON(old_dir->i_op->rename != NULL);\n\t\terror = old_dir->i_op->rename2(old_dir, old_dentry,\n\t\t\t\t\t       new_dir, new_dentry, flags);\n\t}\n\tif (error)\n\t\tgoto out;\n\n\tif (!(flags & RENAME_EXCHANGE) && target) {\n\t\tif (is_dir)\n\t\t\ttarget->i_flags |= S_DEAD;\n\t\tdont_mount(new_dentry);\n\t\tdetach_mounts(new_dentry);\n\t}\n\tif (!(old_dir->i_sb->s_type->fs_flags & FS_RENAME_DOES_D_MOVE)) {\n\t\tif (!(flags & RENAME_EXCHANGE))\n\t\t\td_move(old_dentry, new_dentry);\n\t\telse\n\t\t\td_exchange(old_dentry, new_dentry);\n\t}\nout:\n\tif (!is_dir || (flags & RENAME_EXCHANGE))\n\t\tunlock_two_nondirectories(source, target);\n\telse if (target)\n\t\tinode_unlock(target);\n\tdput(new_dentry);\n\tif (!error) {\n\t\tfsnotify_move(old_dir, new_dir, old_name, is_dir,\n\t\t\t      !(flags & RENAME_EXCHANGE) ? target : NULL, old_dentry);\n\t\tif (flags & RENAME_EXCHANGE) {\n\t\t\tfsnotify_move(new_dir, old_dir, old_dentry->d_name.name,\n\t\t\t\t      new_is_dir, NULL, new_dentry);\n\t\t}\n\t}\n\tfsnotify_oldname_free(old_name);\n\n\treturn error;\n}",
        "func": "int vfs_rename(struct inode *old_dir, struct dentry *old_dentry,\n\t       struct inode *new_dir, struct dentry *new_dentry,\n\t       struct inode **delegated_inode, unsigned int flags)\n{\n\tint error;\n\tbool is_dir = d_is_dir(old_dentry);\n\tconst unsigned char *old_name;\n\tstruct inode *source = old_dentry->d_inode;\n\tstruct inode *target = new_dentry->d_inode;\n\tbool new_is_dir = false;\n\tunsigned max_links = new_dir->i_sb->s_max_links;\n\n\t/*\n\t * Check source == target.\n\t * On overlayfs need to look at underlying inodes.\n\t */\n\tif (vfs_select_inode(old_dentry, 0) == vfs_select_inode(new_dentry, 0))\n\t\treturn 0;\n\n\terror = may_delete(old_dir, old_dentry, is_dir);\n\tif (error)\n\t\treturn error;\n\n\tif (!target) {\n\t\terror = may_create(new_dir, new_dentry);\n\t} else {\n\t\tnew_is_dir = d_is_dir(new_dentry);\n\n\t\tif (!(flags & RENAME_EXCHANGE))\n\t\t\terror = may_delete(new_dir, new_dentry, is_dir);\n\t\telse\n\t\t\terror = may_delete(new_dir, new_dentry, new_is_dir);\n\t}\n\tif (error)\n\t\treturn error;\n\n\tif (!old_dir->i_op->rename && !old_dir->i_op->rename2)\n\t\treturn -EPERM;\n\n\tif (flags && !old_dir->i_op->rename2)\n\t\treturn -EINVAL;\n\n\t/*\n\t * If we are going to change the parent - check write permissions,\n\t * we'll need to flip '..'.\n\t */\n\tif (new_dir != old_dir) {\n\t\tif (is_dir) {\n\t\t\terror = inode_permission(source, MAY_WRITE);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t\tif ((flags & RENAME_EXCHANGE) && new_is_dir) {\n\t\t\terror = inode_permission(target, MAY_WRITE);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t}\n\t}\n\n\terror = security_inode_rename(old_dir, old_dentry, new_dir, new_dentry,\n\t\t\t\t      flags);\n\tif (error)\n\t\treturn error;\n\n\told_name = fsnotify_oldname_init(old_dentry->d_name.name);\n\tdget(new_dentry);\n\tif (!is_dir || (flags & RENAME_EXCHANGE))\n\t\tlock_two_nondirectories(source, target);\n\telse if (target)\n\t\tinode_lock(target);\n\n\terror = -EBUSY;\n\tif (is_local_mountpoint(old_dentry) || is_local_mountpoint(new_dentry))\n\t\tgoto out;\n\n\tif (max_links && new_dir != old_dir) {\n\t\terror = -EMLINK;\n\t\tif (is_dir && !new_is_dir && new_dir->i_nlink >= max_links)\n\t\t\tgoto out;\n\t\tif ((flags & RENAME_EXCHANGE) && !is_dir && new_is_dir &&\n\t\t    old_dir->i_nlink >= max_links)\n\t\t\tgoto out;\n\t}\n\tif (is_dir && !(flags & RENAME_EXCHANGE) && target)\n\t\tshrink_dcache_parent(new_dentry);\n\tif (!is_dir) {\n\t\terror = try_break_deleg(source, delegated_inode);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\tif (target && !new_is_dir) {\n\t\terror = try_break_deleg(target, delegated_inode);\n\t\tif (error)\n\t\t\tgoto out;\n\t}\n\tif (!old_dir->i_op->rename2) {\n\t\terror = old_dir->i_op->rename(old_dir, old_dentry,\n\t\t\t\t\t      new_dir, new_dentry);\n\t} else {\n\t\tWARN_ON(old_dir->i_op->rename != NULL);\n\t\terror = old_dir->i_op->rename2(old_dir, old_dentry,\n\t\t\t\t\t       new_dir, new_dentry, flags);\n\t}\n\tif (error)\n\t\tgoto out;\n\n\tif (!(flags & RENAME_EXCHANGE) && target) {\n\t\tif (is_dir)\n\t\t\ttarget->i_flags |= S_DEAD;\n\t\tdont_mount(new_dentry);\n\t\tdetach_mounts(new_dentry);\n\t}\n\tif (!(old_dir->i_sb->s_type->fs_flags & FS_RENAME_DOES_D_MOVE)) {\n\t\tif (!(flags & RENAME_EXCHANGE))\n\t\t\td_move(old_dentry, new_dentry);\n\t\telse\n\t\t\td_exchange(old_dentry, new_dentry);\n\t}\nout:\n\tif (!is_dir || (flags & RENAME_EXCHANGE))\n\t\tunlock_two_nondirectories(source, target);\n\telse if (target)\n\t\tinode_unlock(target);\n\tdput(new_dentry);\n\tif (!error) {\n\t\tfsnotify_move(old_dir, new_dir, old_name, is_dir,\n\t\t\t      !(flags & RENAME_EXCHANGE) ? target : NULL, old_dentry);\n\t\tif (flags & RENAME_EXCHANGE) {\n\t\t\tfsnotify_move(new_dir, old_dir, old_dentry->d_name.name,\n\t\t\t\t      new_is_dir, NULL, new_dentry);\n\t\t}\n\t}\n\tfsnotify_oldname_free(old_name);\n\n\treturn error;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -10,7 +10,11 @@\n \tbool new_is_dir = false;\n \tunsigned max_links = new_dir->i_sb->s_max_links;\n \n-\tif (source == target)\n+\t/*\n+\t * Check source == target.\n+\t * On overlayfs need to look at underlying inodes.\n+\t */\n+\tif (vfs_select_inode(old_dentry, 0) == vfs_select_inode(new_dentry, 0))\n \t\treturn 0;\n \n \terror = may_delete(old_dir, old_dentry, is_dir);",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (source == target)"
            ],
            "added_lines": [
                "\t/*",
                "\t * Check source == target.",
                "\t * On overlayfs need to look at underlying inodes.",
                "\t */",
                "\tif (vfs_select_inode(old_dentry, 0) == vfs_select_inode(new_dentry, 0))"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-6198",
        "func_name": "torvalds/linux/vfs_open",
        "description": "The filesystem layer in the Linux kernel before 4.5.5 proceeds with post-rename operations after an OverlayFS file is renamed to a self-hardlink, which allows local users to cause a denial of service (system crash) via a rename system call, related to fs/namei.c and fs/open.c.",
        "git_url": "https://github.com/torvalds/linux/commit/54d5ca871e72f2bb172ec9323497f01cd5091ec7",
        "commit_title": "vfs: add vfs_select_inode() helper",
        "commit_text": " Cc: <stable@vger.kernel.org> # v4.2+",
        "func_before": "int vfs_open(const struct path *path, struct file *file,\n\t     const struct cred *cred)\n{\n\tstruct dentry *dentry = path->dentry;\n\tstruct inode *inode = dentry->d_inode;\n\n\tfile->f_path = *path;\n\tif (dentry->d_flags & DCACHE_OP_SELECT_INODE) {\n\t\tinode = dentry->d_op->d_select_inode(dentry, file->f_flags);\n\t\tif (IS_ERR(inode))\n\t\t\treturn PTR_ERR(inode);\n\t}\n\n\treturn do_dentry_open(file, inode, NULL, cred);\n}",
        "func": "int vfs_open(const struct path *path, struct file *file,\n\t     const struct cred *cred)\n{\n\tstruct inode *inode = vfs_select_inode(path->dentry, file->f_flags);\n\n\tif (IS_ERR(inode))\n\t\treturn PTR_ERR(inode);\n\n\tfile->f_path = *path;\n\treturn do_dentry_open(file, inode, NULL, cred);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,15 +1,11 @@\n int vfs_open(const struct path *path, struct file *file,\n \t     const struct cred *cred)\n {\n-\tstruct dentry *dentry = path->dentry;\n-\tstruct inode *inode = dentry->d_inode;\n+\tstruct inode *inode = vfs_select_inode(path->dentry, file->f_flags);\n+\n+\tif (IS_ERR(inode))\n+\t\treturn PTR_ERR(inode);\n \n \tfile->f_path = *path;\n-\tif (dentry->d_flags & DCACHE_OP_SELECT_INODE) {\n-\t\tinode = dentry->d_op->d_select_inode(dentry, file->f_flags);\n-\t\tif (IS_ERR(inode))\n-\t\t\treturn PTR_ERR(inode);\n-\t}\n-\n \treturn do_dentry_open(file, inode, NULL, cred);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tstruct dentry *dentry = path->dentry;",
                "\tstruct inode *inode = dentry->d_inode;",
                "\tif (dentry->d_flags & DCACHE_OP_SELECT_INODE) {",
                "\t\tinode = dentry->d_op->d_select_inode(dentry, file->f_flags);",
                "\t\tif (IS_ERR(inode))",
                "\t\t\treturn PTR_ERR(inode);",
                "\t}",
                ""
            ],
            "added_lines": [
                "\tstruct inode *inode = vfs_select_inode(path->dentry, file->f_flags);",
                "",
                "\tif (IS_ERR(inode))",
                "\t\treturn PTR_ERR(inode);"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-3863",
        "func_name": "android/convertMessageToMetaData",
        "description": "Multiple stack-based buffer overflows in the AVCC reassembly implementation in Utils.cpp in libstagefright in MediaMuxer in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, 6.x before 2016-09-01, and 7.0 before 2016-09-01 allow remote attackers to execute arbitrary code via a crafted media file, aka internal bug 29161888.",
        "git_url": "https://android.googlesource.com/platform/frameworks/av/+/119a012b2a9a186655da4bef3ed4ed8dd9b94c26",
        "commit_title": "stagefright: fix possible stack overflow in AVCC reassemble",
        "commit_text": " Additionally, remove use of variable length array which is non-standard in C++.  Bug: 29161888 ",
        "func_before": "void convertMessageToMetaData(const sp<AMessage> &msg, sp<MetaData> &meta) {\n    AString mime;\n    if (msg->findString(\"mime\", &mime)) {\n        meta->setCString(kKeyMIMEType, mime.c_str());\n    } else {\n        ALOGW(\"did not find mime type\");\n    }\n\n    int64_t durationUs;\n    if (msg->findInt64(\"durationUs\", &durationUs)) {\n        meta->setInt64(kKeyDuration, durationUs);\n    }\n\n    int32_t isSync;\n    if (msg->findInt32(\"is-sync-frame\", &isSync) && isSync != 0) {\n        meta->setInt32(kKeyIsSyncFrame, 1);\n    }\n\n    int32_t avgBitrate = 0;\n    int32_t maxBitrate;\n    if (msg->findInt32(\"bitrate\", &avgBitrate) && avgBitrate > 0) {\n        meta->setInt32(kKeyBitRate, avgBitrate);\n    }\n    if (msg->findInt32(\"max-bitrate\", &maxBitrate) && maxBitrate > 0 && maxBitrate >= avgBitrate) {\n        meta->setInt32(kKeyMaxBitRate, maxBitrate);\n    }\n\n    if (mime.startsWith(\"video/\")) {\n        int32_t width;\n        int32_t height;\n        if (msg->findInt32(\"width\", &width) && msg->findInt32(\"height\", &height)) {\n            meta->setInt32(kKeyWidth, width);\n            meta->setInt32(kKeyHeight, height);\n        } else {\n            ALOGW(\"did not find width and/or height\");\n        }\n\n        int32_t sarWidth, sarHeight;\n        if (msg->findInt32(\"sar-width\", &sarWidth)\n                && msg->findInt32(\"sar-height\", &sarHeight)) {\n            meta->setInt32(kKeySARWidth, sarWidth);\n            meta->setInt32(kKeySARHeight, sarHeight);\n        }\n\n        int32_t colorFormat;\n        if (msg->findInt32(\"color-format\", &colorFormat)) {\n            meta->setInt32(kKeyColorFormat, colorFormat);\n        }\n\n        int32_t cropLeft, cropTop, cropRight, cropBottom;\n        if (msg->findRect(\"crop\",\n                          &cropLeft,\n                          &cropTop,\n                          &cropRight,\n                          &cropBottom)) {\n            meta->setRect(kKeyCropRect, cropLeft, cropTop, cropRight, cropBottom);\n        }\n\n        int32_t rotationDegrees;\n        if (msg->findInt32(\"rotation-degrees\", &rotationDegrees)) {\n            meta->setInt32(kKeyRotation, rotationDegrees);\n        }\n\n        if (msg->contains(\"hdr-static-info\")) {\n            HDRStaticInfo info;\n            if (ColorUtils::getHDRStaticInfoFromFormat(msg, &info)) {\n                meta->setData(kKeyHdrStaticInfo, 'hdrS', &info, sizeof(info));\n            }\n        }\n\n        convertMessageToMetaDataColorAspects(msg, meta);\n    } else if (mime.startsWith(\"audio/\")) {\n        int32_t numChannels;\n        if (msg->findInt32(\"channel-count\", &numChannels)) {\n            meta->setInt32(kKeyChannelCount, numChannels);\n        }\n        int32_t sampleRate;\n        if (msg->findInt32(\"sample-rate\", &sampleRate)) {\n            meta->setInt32(kKeySampleRate, sampleRate);\n        }\n        int32_t channelMask;\n        if (msg->findInt32(\"channel-mask\", &channelMask)) {\n            meta->setInt32(kKeyChannelMask, channelMask);\n        }\n        int32_t delay = 0;\n        if (msg->findInt32(\"encoder-delay\", &delay)) {\n            meta->setInt32(kKeyEncoderDelay, delay);\n        }\n        int32_t padding = 0;\n        if (msg->findInt32(\"encoder-padding\", &padding)) {\n            meta->setInt32(kKeyEncoderPadding, padding);\n        }\n\n        int32_t isADTS;\n        if (msg->findInt32(\"is-adts\", &isADTS)) {\n            meta->setInt32(kKeyIsADTS, isADTS);\n        }\n\n        int32_t pcmEncoding;\n        if (msg->findInt32(\"pcm-encoding\", &pcmEncoding)) {\n            meta->setInt32(kKeyPcmEncoding, pcmEncoding);\n        }\n    }\n\n    int32_t maxInputSize;\n    if (msg->findInt32(\"max-input-size\", &maxInputSize)) {\n        meta->setInt32(kKeyMaxInputSize, maxInputSize);\n    }\n\n    int32_t maxWidth;\n    if (msg->findInt32(\"max-width\", &maxWidth)) {\n        meta->setInt32(kKeyMaxWidth, maxWidth);\n    }\n\n    int32_t maxHeight;\n    if (msg->findInt32(\"max-height\", &maxHeight)) {\n        meta->setInt32(kKeyMaxHeight, maxHeight);\n    }\n\n    int32_t fps;\n    float fpsFloat;\n    if (msg->findInt32(\"frame-rate\", &fps) && fps > 0) {\n        meta->setInt32(kKeyFrameRate, fps);\n    } else if (msg->findFloat(\"frame-rate\", &fpsFloat)\n            && fpsFloat >= 1 && fpsFloat <= INT32_MAX) {\n        // truncate values to distinguish between e.g. 24 vs 23.976 fps\n        meta->setInt32(kKeyFrameRate, (int32_t)fpsFloat);\n    }\n\n    // reassemble the csd data into its original form\n    sp<ABuffer> csd0, csd1, csd2;\n    if (msg->findBuffer(\"csd-0\", &csd0)) {\n        if (mime == MEDIA_MIMETYPE_VIDEO_AVC) {\n            sp<ABuffer> csd1;\n            if (msg->findBuffer(\"csd-1\", &csd1)) {\n                char avcc[1024]; // that oughta be enough, right?\n                size_t outsize = reassembleAVCC(csd0, csd1, avcc);\n                meta->setData(kKeyAVCC, kKeyAVCC, avcc, outsize);\n            }\n        } else if (mime == MEDIA_MIMETYPE_AUDIO_AAC || mime == MEDIA_MIMETYPE_VIDEO_MPEG4) {\n            int csd0size = csd0->size();\n            char esds[csd0size + 31];\n            // The written ESDS is actually for an audio stream, but it's enough\n            // for transporting the CSD to muxers.\n            reassembleESDS(csd0, esds);\n            meta->setData(kKeyESDS, kKeyESDS, esds, sizeof(esds));\n        } else if (mime == MEDIA_MIMETYPE_VIDEO_HEVC) {\n            uint8_t hvcc[1024]; // that oughta be enough, right?\n            size_t outsize = reassembleHVCC(csd0, hvcc, 1024, 4);\n            meta->setData(kKeyHVCC, kKeyHVCC, hvcc, outsize);\n        } else if (mime == MEDIA_MIMETYPE_VIDEO_VP9) {\n            meta->setData(kKeyVp9CodecPrivate, 0, csd0->data(), csd0->size());\n        } else if (mime == MEDIA_MIMETYPE_AUDIO_OPUS) {\n            meta->setData(kKeyOpusHeader, 0, csd0->data(), csd0->size());\n            if (msg->findBuffer(\"csd-1\", &csd1)) {\n                meta->setData(kKeyOpusCodecDelay, 0, csd1->data(), csd1->size());\n            }\n            if (msg->findBuffer(\"csd-2\", &csd2)) {\n                meta->setData(kKeyOpusSeekPreRoll, 0, csd2->data(), csd2->size());\n            }\n        } else if (mime == MEDIA_MIMETYPE_AUDIO_VORBIS) {\n            meta->setData(kKeyVorbisInfo, 0, csd0->data(), csd0->size());\n            if (msg->findBuffer(\"csd-1\", &csd1)) {\n                meta->setData(kKeyVorbisBooks, 0, csd1->data(), csd1->size());\n            }\n        }\n    }\n\n    int32_t timeScale;\n    if (msg->findInt32(\"time-scale\", &timeScale)) {\n        meta->setInt32(kKeyTimeScale, timeScale);\n    }\n\n    // XXX TODO add whatever other keys there are\n\n#if 0\n    ALOGI(\"converted %s to:\", msg->debugString(0).c_str());\n    meta->dumpToLog();\n#endif\n}",
        "func": "void convertMessageToMetaData(const sp<AMessage> &msg, sp<MetaData> &meta) {\n    AString mime;\n    if (msg->findString(\"mime\", &mime)) {\n        meta->setCString(kKeyMIMEType, mime.c_str());\n    } else {\n        ALOGW(\"did not find mime type\");\n    }\n\n    int64_t durationUs;\n    if (msg->findInt64(\"durationUs\", &durationUs)) {\n        meta->setInt64(kKeyDuration, durationUs);\n    }\n\n    int32_t isSync;\n    if (msg->findInt32(\"is-sync-frame\", &isSync) && isSync != 0) {\n        meta->setInt32(kKeyIsSyncFrame, 1);\n    }\n\n    int32_t avgBitrate = 0;\n    int32_t maxBitrate;\n    if (msg->findInt32(\"bitrate\", &avgBitrate) && avgBitrate > 0) {\n        meta->setInt32(kKeyBitRate, avgBitrate);\n    }\n    if (msg->findInt32(\"max-bitrate\", &maxBitrate) && maxBitrate > 0 && maxBitrate >= avgBitrate) {\n        meta->setInt32(kKeyMaxBitRate, maxBitrate);\n    }\n\n    if (mime.startsWith(\"video/\")) {\n        int32_t width;\n        int32_t height;\n        if (msg->findInt32(\"width\", &width) && msg->findInt32(\"height\", &height)) {\n            meta->setInt32(kKeyWidth, width);\n            meta->setInt32(kKeyHeight, height);\n        } else {\n            ALOGW(\"did not find width and/or height\");\n        }\n\n        int32_t sarWidth, sarHeight;\n        if (msg->findInt32(\"sar-width\", &sarWidth)\n                && msg->findInt32(\"sar-height\", &sarHeight)) {\n            meta->setInt32(kKeySARWidth, sarWidth);\n            meta->setInt32(kKeySARHeight, sarHeight);\n        }\n\n        int32_t colorFormat;\n        if (msg->findInt32(\"color-format\", &colorFormat)) {\n            meta->setInt32(kKeyColorFormat, colorFormat);\n        }\n\n        int32_t cropLeft, cropTop, cropRight, cropBottom;\n        if (msg->findRect(\"crop\",\n                          &cropLeft,\n                          &cropTop,\n                          &cropRight,\n                          &cropBottom)) {\n            meta->setRect(kKeyCropRect, cropLeft, cropTop, cropRight, cropBottom);\n        }\n\n        int32_t rotationDegrees;\n        if (msg->findInt32(\"rotation-degrees\", &rotationDegrees)) {\n            meta->setInt32(kKeyRotation, rotationDegrees);\n        }\n\n        if (msg->contains(\"hdr-static-info\")) {\n            HDRStaticInfo info;\n            if (ColorUtils::getHDRStaticInfoFromFormat(msg, &info)) {\n                meta->setData(kKeyHdrStaticInfo, 'hdrS', &info, sizeof(info));\n            }\n        }\n\n        convertMessageToMetaDataColorAspects(msg, meta);\n    } else if (mime.startsWith(\"audio/\")) {\n        int32_t numChannels;\n        if (msg->findInt32(\"channel-count\", &numChannels)) {\n            meta->setInt32(kKeyChannelCount, numChannels);\n        }\n        int32_t sampleRate;\n        if (msg->findInt32(\"sample-rate\", &sampleRate)) {\n            meta->setInt32(kKeySampleRate, sampleRate);\n        }\n        int32_t channelMask;\n        if (msg->findInt32(\"channel-mask\", &channelMask)) {\n            meta->setInt32(kKeyChannelMask, channelMask);\n        }\n        int32_t delay = 0;\n        if (msg->findInt32(\"encoder-delay\", &delay)) {\n            meta->setInt32(kKeyEncoderDelay, delay);\n        }\n        int32_t padding = 0;\n        if (msg->findInt32(\"encoder-padding\", &padding)) {\n            meta->setInt32(kKeyEncoderPadding, padding);\n        }\n\n        int32_t isADTS;\n        if (msg->findInt32(\"is-adts\", &isADTS)) {\n            meta->setInt32(kKeyIsADTS, isADTS);\n        }\n\n        int32_t pcmEncoding;\n        if (msg->findInt32(\"pcm-encoding\", &pcmEncoding)) {\n            meta->setInt32(kKeyPcmEncoding, pcmEncoding);\n        }\n    }\n\n    int32_t maxInputSize;\n    if (msg->findInt32(\"max-input-size\", &maxInputSize)) {\n        meta->setInt32(kKeyMaxInputSize, maxInputSize);\n    }\n\n    int32_t maxWidth;\n    if (msg->findInt32(\"max-width\", &maxWidth)) {\n        meta->setInt32(kKeyMaxWidth, maxWidth);\n    }\n\n    int32_t maxHeight;\n    if (msg->findInt32(\"max-height\", &maxHeight)) {\n        meta->setInt32(kKeyMaxHeight, maxHeight);\n    }\n\n    int32_t fps;\n    float fpsFloat;\n    if (msg->findInt32(\"frame-rate\", &fps) && fps > 0) {\n        meta->setInt32(kKeyFrameRate, fps);\n    } else if (msg->findFloat(\"frame-rate\", &fpsFloat)\n            && fpsFloat >= 1 && fpsFloat <= INT32_MAX) {\n        // truncate values to distinguish between e.g. 24 vs 23.976 fps\n        meta->setInt32(kKeyFrameRate, (int32_t)fpsFloat);\n    }\n\n    // reassemble the csd data into its original form\n    sp<ABuffer> csd0, csd1, csd2;\n    if (msg->findBuffer(\"csd-0\", &csd0)) {\n        int csd0size = csd0->size();\n        if (mime == MEDIA_MIMETYPE_VIDEO_AVC) {\n            sp<ABuffer> csd1;\n            if (msg->findBuffer(\"csd-1\", &csd1)) {\n                std::vector<char> avcc(csd0size + csd1->size() + 1024);\n                size_t outsize = reassembleAVCC(csd0, csd1, avcc.data());\n                meta->setData(kKeyAVCC, kKeyAVCC, avcc.data(), outsize);\n            }\n        } else if (mime == MEDIA_MIMETYPE_AUDIO_AAC || mime == MEDIA_MIMETYPE_VIDEO_MPEG4) {\n            std::vector<char> esds(csd0size + 31);\n            // The written ESDS is actually for an audio stream, but it's enough\n            // for transporting the CSD to muxers.\n            reassembleESDS(csd0, esds.data());\n            meta->setData(kKeyESDS, kKeyESDS, esds.data(), esds.size());\n        } else if (mime == MEDIA_MIMETYPE_VIDEO_HEVC) {\n            std::vector<uint8_t> hvcc(csd0size + 1024);\n            size_t outsize = reassembleHVCC(csd0, hvcc.data(), hvcc.size(), 4);\n            meta->setData(kKeyHVCC, kKeyHVCC, hvcc.data(), outsize);\n        } else if (mime == MEDIA_MIMETYPE_VIDEO_VP9) {\n            meta->setData(kKeyVp9CodecPrivate, 0, csd0->data(), csd0->size());\n        } else if (mime == MEDIA_MIMETYPE_AUDIO_OPUS) {\n            meta->setData(kKeyOpusHeader, 0, csd0->data(), csd0->size());\n            if (msg->findBuffer(\"csd-1\", &csd1)) {\n                meta->setData(kKeyOpusCodecDelay, 0, csd1->data(), csd1->size());\n            }\n            if (msg->findBuffer(\"csd-2\", &csd2)) {\n                meta->setData(kKeyOpusSeekPreRoll, 0, csd2->data(), csd2->size());\n            }\n        } else if (mime == MEDIA_MIMETYPE_AUDIO_VORBIS) {\n            meta->setData(kKeyVorbisInfo, 0, csd0->data(), csd0->size());\n            if (msg->findBuffer(\"csd-1\", &csd1)) {\n                meta->setData(kKeyVorbisBooks, 0, csd1->data(), csd1->size());\n            }\n        }\n    }\n\n    int32_t timeScale;\n    if (msg->findInt32(\"time-scale\", &timeScale)) {\n        meta->setInt32(kKeyTimeScale, timeScale);\n    }\n\n    // XXX TODO add whatever other keys there are\n\n#if 0\n    ALOGI(\"converted %s to:\", msg->debugString(0).c_str());\n    meta->dumpToLog();\n#endif\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -130,24 +130,24 @@\n     // reassemble the csd data into its original form\n     sp<ABuffer> csd0, csd1, csd2;\n     if (msg->findBuffer(\"csd-0\", &csd0)) {\n+        int csd0size = csd0->size();\n         if (mime == MEDIA_MIMETYPE_VIDEO_AVC) {\n             sp<ABuffer> csd1;\n             if (msg->findBuffer(\"csd-1\", &csd1)) {\n-                char avcc[1024]; // that oughta be enough, right?\n-                size_t outsize = reassembleAVCC(csd0, csd1, avcc);\n-                meta->setData(kKeyAVCC, kKeyAVCC, avcc, outsize);\n+                std::vector<char> avcc(csd0size + csd1->size() + 1024);\n+                size_t outsize = reassembleAVCC(csd0, csd1, avcc.data());\n+                meta->setData(kKeyAVCC, kKeyAVCC, avcc.data(), outsize);\n             }\n         } else if (mime == MEDIA_MIMETYPE_AUDIO_AAC || mime == MEDIA_MIMETYPE_VIDEO_MPEG4) {\n-            int csd0size = csd0->size();\n-            char esds[csd0size + 31];\n+            std::vector<char> esds(csd0size + 31);\n             // The written ESDS is actually for an audio stream, but it's enough\n             // for transporting the CSD to muxers.\n-            reassembleESDS(csd0, esds);\n-            meta->setData(kKeyESDS, kKeyESDS, esds, sizeof(esds));\n+            reassembleESDS(csd0, esds.data());\n+            meta->setData(kKeyESDS, kKeyESDS, esds.data(), esds.size());\n         } else if (mime == MEDIA_MIMETYPE_VIDEO_HEVC) {\n-            uint8_t hvcc[1024]; // that oughta be enough, right?\n-            size_t outsize = reassembleHVCC(csd0, hvcc, 1024, 4);\n-            meta->setData(kKeyHVCC, kKeyHVCC, hvcc, outsize);\n+            std::vector<uint8_t> hvcc(csd0size + 1024);\n+            size_t outsize = reassembleHVCC(csd0, hvcc.data(), hvcc.size(), 4);\n+            meta->setData(kKeyHVCC, kKeyHVCC, hvcc.data(), outsize);\n         } else if (mime == MEDIA_MIMETYPE_VIDEO_VP9) {\n             meta->setData(kKeyVp9CodecPrivate, 0, csd0->data(), csd0->size());\n         } else if (mime == MEDIA_MIMETYPE_AUDIO_OPUS) {",
        "diff_line_info": {
            "deleted_lines": [
                "                char avcc[1024]; // that oughta be enough, right?",
                "                size_t outsize = reassembleAVCC(csd0, csd1, avcc);",
                "                meta->setData(kKeyAVCC, kKeyAVCC, avcc, outsize);",
                "            int csd0size = csd0->size();",
                "            char esds[csd0size + 31];",
                "            reassembleESDS(csd0, esds);",
                "            meta->setData(kKeyESDS, kKeyESDS, esds, sizeof(esds));",
                "            uint8_t hvcc[1024]; // that oughta be enough, right?",
                "            size_t outsize = reassembleHVCC(csd0, hvcc, 1024, 4);",
                "            meta->setData(kKeyHVCC, kKeyHVCC, hvcc, outsize);"
            ],
            "added_lines": [
                "        int csd0size = csd0->size();",
                "                std::vector<char> avcc(csd0size + csd1->size() + 1024);",
                "                size_t outsize = reassembleAVCC(csd0, csd1, avcc.data());",
                "                meta->setData(kKeyAVCC, kKeyAVCC, avcc.data(), outsize);",
                "            std::vector<char> esds(csd0size + 31);",
                "            reassembleESDS(csd0, esds.data());",
                "            meta->setData(kKeyESDS, kKeyESDS, esds.data(), esds.size());",
                "            std::vector<uint8_t> hvcc(csd0size + 1024);",
                "            size_t outsize = reassembleHVCC(csd0, hvcc.data(), hvcc.size(), 4);",
                "            meta->setData(kKeyHVCC, kKeyHVCC, hvcc.data(), outsize);"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-3878",
        "func_name": "android/ih264d_video_decode",
        "description": "decoder/ih264d_api.c in mediaserver in Android 6.x before 2016-09-01 mishandles the case of decoding zero MBs, which allows remote attackers to cause a denial of service (device hang or reboot) via a crafted media file, aka internal bug 29493002.",
        "git_url": "https://android.googlesource.com/platform/external/libavc/+/7109ce3f8f90a28ca9f0ee6e14f6ac5e414c62cf",
        "commit_title": "Fixed error concealment when no MBs are decoded in the current pic",
        "commit_text": " Bug: 29493002 ",
        "func_before": "WORD32 ih264d_video_decode(iv_obj_t *dec_hdl, void *pv_api_ip, void *pv_api_op)\n{\n    /* ! */\n\n    dec_struct_t * ps_dec = (dec_struct_t *)(dec_hdl->pv_codec_handle);\n\n    WORD32 i4_err_status = 0;\n    UWORD8 *pu1_buf = NULL;\n    WORD32 buflen;\n    UWORD32 u4_max_ofst, u4_length_of_start_code = 0;\n\n    UWORD32 bytes_consumed = 0;\n    UWORD32 cur_slice_is_nonref = 0;\n    UWORD32 u4_next_is_aud;\n    UWORD32 u4_first_start_code_found = 0;\n    WORD32 ret = 0,api_ret_value = IV_SUCCESS;\n    WORD32 header_data_left = 0,frame_data_left = 0;\n    UWORD8 *pu1_bitstrm_buf;\n    ivd_video_decode_ip_t *ps_dec_ip;\n    ivd_video_decode_op_t *ps_dec_op;\n\n    ithread_set_name((void*)\"Parse_thread\");\n\n    ps_dec_ip = (ivd_video_decode_ip_t *)pv_api_ip;\n    ps_dec_op = (ivd_video_decode_op_t *)pv_api_op;\n\n    {\n        UWORD32 u4_size;\n        u4_size = ps_dec_op->u4_size;\n        memset(ps_dec_op, 0, sizeof(ivd_video_decode_op_t));\n        ps_dec_op->u4_size = u4_size;\n    }\n\n    ps_dec->pv_dec_out = ps_dec_op;\n    if(ps_dec->init_done != 1)\n    {\n        return IV_FAIL;\n    }\n\n    /*Data memory barries instruction,so that bitstream write by the application is complete*/\n    DATA_SYNC();\n\n    if(0 == ps_dec->u1_flushfrm)\n    {\n        if(ps_dec_ip->pv_stream_buffer == NULL)\n        {\n            ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;\n            ps_dec_op->u4_error_code |= IVD_DEC_FRM_BS_BUF_NULL;\n            return IV_FAIL;\n        }\n        if(ps_dec_ip->u4_num_Bytes <= 0)\n        {\n            ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;\n            ps_dec_op->u4_error_code |= IVD_DEC_NUMBYTES_INV;\n            return IV_FAIL;\n\n        }\n    }\n    ps_dec->u1_pic_decode_done = 0;\n\n    ps_dec_op->u4_num_bytes_consumed = 0;\n\n    ps_dec->ps_out_buffer = NULL;\n\n    if(ps_dec_ip->u4_size\n                    >= offsetof(ivd_video_decode_ip_t, s_out_buffer))\n        ps_dec->ps_out_buffer = &ps_dec_ip->s_out_buffer;\n\n    ps_dec->u4_fmt_conv_cur_row = 0;\n\n    ps_dec->u4_output_present = 0;\n    ps_dec->s_disp_op.u4_error_code = 1;\n    ps_dec->u4_fmt_conv_num_rows = FMT_CONV_NUM_ROWS;\n    if(0 == ps_dec->u4_share_disp_buf\n                    && ps_dec->i4_decode_header == 0)\n    {\n        UWORD32 i;\n        if(ps_dec->ps_out_buffer->u4_num_bufs == 0)\n        {\n            ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;\n            ps_dec_op->u4_error_code |= IVD_DISP_FRM_ZERO_OP_BUFS;\n            return IV_FAIL;\n        }\n\n        for(i = 0; i < ps_dec->ps_out_buffer->u4_num_bufs; i++)\n        {\n            if(ps_dec->ps_out_buffer->pu1_bufs[i] == NULL)\n            {\n                ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;\n                ps_dec_op->u4_error_code |= IVD_DISP_FRM_OP_BUF_NULL;\n                return IV_FAIL;\n            }\n\n            if(ps_dec->ps_out_buffer->u4_min_out_buf_size[i] == 0)\n            {\n                ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;\n                ps_dec_op->u4_error_code |=\n                                IVD_DISP_FRM_ZERO_OP_BUF_SIZE;\n                return IV_FAIL;\n            }\n        }\n    }\n\n    if(ps_dec->u4_total_frames_decoded >= NUM_FRAMES_LIMIT)\n    {\n        ps_dec_op->u4_error_code = ERROR_FRAME_LIMIT_OVER;\n        return IV_FAIL;\n    }\n\n    /* ! */\n    ps_dec->u4_ts = ps_dec_ip->u4_ts;\n\n    ps_dec_op->u4_error_code = 0;\n    ps_dec_op->e_pic_type = -1;\n    ps_dec_op->u4_output_present = 0;\n    ps_dec_op->u4_frame_decoded_flag = 0;\n\n    ps_dec->i4_frametype = -1;\n    ps_dec->i4_content_type = -1;\n    /*\n     * For field pictures, set the bottom and top picture decoded u4_flag correctly.\n     */\n    {\n        if((TOP_FIELD_ONLY | BOT_FIELD_ONLY) == ps_dec->u1_top_bottom_decoded)\n        {\n            ps_dec->u1_top_bottom_decoded = 0;\n        }\n    }\n    ps_dec->u4_slice_start_code_found = 0;\n\n    /* In case the deocder is not in flush mode(in shared mode),\n     then decoder has to pick up a buffer to write current frame.\n     Check if a frame is available in such cases */\n\n    if(ps_dec->u1_init_dec_flag == 1 && ps_dec->u4_share_disp_buf == 1\n                    && ps_dec->u1_flushfrm == 0)\n    {\n        UWORD32 i;\n\n        WORD32 disp_avail = 0, free_id;\n\n        /* Check if at least one buffer is available with the codec */\n        /* If not then return to application with error */\n        for(i = 0; i < ps_dec->u1_pic_bufs; i++)\n        {\n            if(0 == ps_dec->u4_disp_buf_mapping[i]\n                            || 1 == ps_dec->u4_disp_buf_to_be_freed[i])\n            {\n                disp_avail = 1;\n                break;\n            }\n\n        }\n\n        if(0 == disp_avail)\n        {\n            /* If something is queued for display wait for that buffer to be returned */\n\n            ps_dec_op->u4_error_code = IVD_DEC_REF_BUF_NULL;\n            ps_dec_op->u4_error_code |= (1 << IVD_UNSUPPORTEDPARAM);\n            return (IV_FAIL);\n        }\n\n        while(1)\n        {\n            pic_buffer_t *ps_pic_buf;\n            ps_pic_buf = (pic_buffer_t *)ih264_buf_mgr_get_next_free(\n                            (buf_mgr_t *)ps_dec->pv_pic_buf_mgr, &free_id);\n\n            if(ps_pic_buf == NULL)\n            {\n                UWORD32 i, display_queued = 0;\n\n                /* check if any buffer was given for display which is not returned yet */\n                for(i = 0; i < (MAX_DISP_BUFS_NEW); i++)\n                {\n                    if(0 != ps_dec->u4_disp_buf_mapping[i])\n                    {\n                        display_queued = 1;\n                        break;\n                    }\n                }\n                /* If some buffer is queued for display, then codec has to singal an error and wait\n                 for that buffer to be returned.\n                 If nothing is queued for display then codec has ownership of all display buffers\n                 and it can reuse any of the existing buffers and continue decoding */\n\n                if(1 == display_queued)\n                {\n                    /* If something is queued for display wait for that buffer to be returned */\n                    ps_dec_op->u4_error_code = IVD_DEC_REF_BUF_NULL;\n                    ps_dec_op->u4_error_code |= (1\n                                    << IVD_UNSUPPORTEDPARAM);\n                    return (IV_FAIL);\n                }\n            }\n            else\n            {\n                /* If the buffer is with display, then mark it as in use and then look for a buffer again */\n                if(1 == ps_dec->u4_disp_buf_mapping[free_id])\n                {\n                    ih264_buf_mgr_set_status(\n                                    (buf_mgr_t *)ps_dec->pv_pic_buf_mgr,\n                                    free_id,\n                                    BUF_MGR_IO);\n                }\n                else\n                {\n                    /**\n                     *  Found a free buffer for present call. Release it now.\n                     *  Will be again obtained later.\n                     */\n                    ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr,\n                                          free_id,\n                                          BUF_MGR_IO);\n                    break;\n                }\n            }\n        }\n\n    }\n\n    if(ps_dec->u1_flushfrm && ps_dec->u1_init_dec_flag)\n    {\n\n        ih264d_get_next_display_field(ps_dec, ps_dec->ps_out_buffer,\n                                      &(ps_dec->s_disp_op));\n        if(0 == ps_dec->s_disp_op.u4_error_code)\n        {\n            ps_dec->u4_fmt_conv_cur_row = 0;\n            ps_dec->u4_fmt_conv_num_rows = ps_dec->s_disp_frame_info.u4_y_ht;\n            ih264d_format_convert(ps_dec, &(ps_dec->s_disp_op),\n                                  ps_dec->u4_fmt_conv_cur_row,\n                                  ps_dec->u4_fmt_conv_num_rows);\n            ps_dec->u4_fmt_conv_cur_row += ps_dec->u4_fmt_conv_num_rows;\n            ps_dec->u4_output_present = 1;\n\n        }\n        ih264d_release_display_field(ps_dec, &(ps_dec->s_disp_op));\n\n        ps_dec_op->u4_pic_wd = (UWORD32)ps_dec->u2_disp_width;\n        ps_dec_op->u4_pic_ht = (UWORD32)ps_dec->u2_disp_height;\n\n        ps_dec_op->u4_new_seq = 0;\n\n        ps_dec_op->u4_output_present = ps_dec->u4_output_present;\n        ps_dec_op->u4_progressive_frame_flag =\n                        ps_dec->s_disp_op.u4_progressive_frame_flag;\n        ps_dec_op->e_output_format =\n                        ps_dec->s_disp_op.e_output_format;\n        ps_dec_op->s_disp_frm_buf = ps_dec->s_disp_op.s_disp_frm_buf;\n        ps_dec_op->e4_fld_type = ps_dec->s_disp_op.e4_fld_type;\n        ps_dec_op->u4_ts = ps_dec->s_disp_op.u4_ts;\n        ps_dec_op->u4_disp_buf_id = ps_dec->s_disp_op.u4_disp_buf_id;\n\n        /*In the case of flush ,since no frame is decoded set pic type as invalid*/\n        ps_dec_op->u4_is_ref_flag = -1;\n        ps_dec_op->e_pic_type = IV_NA_FRAME;\n        ps_dec_op->u4_frame_decoded_flag = 0;\n\n        if(0 == ps_dec->s_disp_op.u4_error_code)\n        {\n            return (IV_SUCCESS);\n        }\n        else\n            return (IV_FAIL);\n\n    }\n    if(ps_dec->u1_res_changed == 1)\n    {\n        /*if resolution has changed and all buffers have been flushed, reset decoder*/\n        ih264d_init_decoder(ps_dec);\n    }\n\n    ps_dec->u4_prev_nal_skipped = 0;\n\n    ps_dec->u2_cur_mb_addr = 0;\n    ps_dec->u2_total_mbs_coded = 0;\n    ps_dec->u2_cur_slice_num = 0;\n    ps_dec->cur_dec_mb_num = 0;\n    ps_dec->cur_recon_mb_num = 0;\n    ps_dec->u4_first_slice_in_pic = 2;\n    ps_dec->u1_first_pb_nal_in_pic = 1;\n    ps_dec->u1_slice_header_done = 0;\n    ps_dec->u1_dangling_field = 0;\n\n    ps_dec->u4_dec_thread_created = 0;\n    ps_dec->u4_bs_deblk_thread_created = 0;\n    ps_dec->u4_cur_bs_mb_num = 0;\n    ps_dec->u4_start_recon_deblk  = 0;\n\n    DEBUG_THREADS_PRINTF(\" Starting process call\\n\");\n\n\n    ps_dec->u4_pic_buf_got = 0;\n\n    do\n    {\n        WORD32 buf_size;\n\n        pu1_buf = (UWORD8*)ps_dec_ip->pv_stream_buffer\n                        + ps_dec_op->u4_num_bytes_consumed;\n\n        u4_max_ofst = ps_dec_ip->u4_num_Bytes\n                        - ps_dec_op->u4_num_bytes_consumed;\n\n        /* If dynamic bitstream buffer is not allocated and\n         * header decode is done, then allocate dynamic bitstream buffer\n         */\n        if((NULL == ps_dec->pu1_bits_buf_dynamic) &&\n           (ps_dec->i4_header_decoded & 1))\n        {\n            WORD32 size;\n\n            void *pv_buf;\n            void *pv_mem_ctxt = ps_dec->pv_mem_ctxt;\n            size = MAX(256000, ps_dec->u2_pic_wd * ps_dec->u2_pic_ht * 3 / 2);\n            pv_buf = ps_dec->pf_aligned_alloc(pv_mem_ctxt, 128, size);\n            RETURN_IF((NULL == pv_buf), IV_FAIL);\n            ps_dec->pu1_bits_buf_dynamic = pv_buf;\n            ps_dec->u4_dynamic_bits_buf_size = size;\n        }\n\n        if(ps_dec->pu1_bits_buf_dynamic)\n        {\n            pu1_bitstrm_buf = ps_dec->pu1_bits_buf_dynamic;\n            buf_size = ps_dec->u4_dynamic_bits_buf_size;\n        }\n        else\n        {\n            pu1_bitstrm_buf = ps_dec->pu1_bits_buf_static;\n            buf_size = ps_dec->u4_static_bits_buf_size;\n        }\n\n        u4_next_is_aud = 0;\n\n        buflen = ih264d_find_start_code(pu1_buf, 0, u4_max_ofst,\n                                               &u4_length_of_start_code,\n                                               &u4_next_is_aud);\n\n        if(buflen == -1)\n            buflen = 0;\n        /* Ignore bytes beyond the allocated size of intermediate buffer */\n        buflen = MIN(buflen, buf_size);\n\n        bytes_consumed = buflen + u4_length_of_start_code;\n        ps_dec_op->u4_num_bytes_consumed += bytes_consumed;\n\n        {\n            UWORD8 u1_firstbyte, u1_nal_ref_idc;\n\n            if(ps_dec->i4_app_skip_mode == IVD_SKIP_B)\n            {\n                u1_firstbyte = *(pu1_buf + u4_length_of_start_code);\n                u1_nal_ref_idc = (UWORD8)(NAL_REF_IDC(u1_firstbyte));\n                if(u1_nal_ref_idc == 0)\n                {\n                    /*skip non reference frames*/\n                    cur_slice_is_nonref = 1;\n                    continue;\n                }\n                else\n                {\n                    if(1 == cur_slice_is_nonref)\n                    {\n                        /*We have encountered a referenced frame,return to app*/\n                        ps_dec_op->u4_num_bytes_consumed -=\n                                        bytes_consumed;\n                        ps_dec_op->e_pic_type = IV_B_FRAME;\n                        ps_dec_op->u4_error_code =\n                                        IVD_DEC_FRM_SKIPPED;\n                        ps_dec_op->u4_error_code |= (1\n                                        << IVD_UNSUPPORTEDPARAM);\n                        ps_dec_op->u4_frame_decoded_flag = 0;\n                        ps_dec_op->u4_size =\n                                        sizeof(ivd_video_decode_op_t);\n                        /*signal the decode thread*/\n                        ih264d_signal_decode_thread(ps_dec);\n                        /* close deblock thread if it is not closed yet*/\n                        if(ps_dec->u4_num_cores == 3)\n                        {\n                            ih264d_signal_bs_deblk_thread(ps_dec);\n                        }\n\n                        return (IV_FAIL);\n                    }\n                }\n\n            }\n\n        }\n\n\n        if(buflen)\n        {\n            memcpy(pu1_bitstrm_buf, pu1_buf + u4_length_of_start_code,\n                   buflen);\n            /* Decoder may read extra 8 bytes near end of the frame */\n            if((buflen + 8) < buf_size)\n            {\n                memset(pu1_bitstrm_buf + buflen, 0, 8);\n            }\n            u4_first_start_code_found = 1;\n\n        }\n        else\n        {\n            /*start code not found*/\n\n            if(u4_first_start_code_found == 0)\n            {\n                /*no start codes found in current process call*/\n\n                ps_dec->i4_error_code = ERROR_START_CODE_NOT_FOUND;\n                ps_dec_op->u4_error_code |= 1 << IVD_INSUFFICIENTDATA;\n\n                if(ps_dec->u4_pic_buf_got == 0)\n                {\n\n                    ih264d_fill_output_struct_from_context(ps_dec,\n                                                           ps_dec_op);\n\n                    ps_dec_op->u4_error_code = ps_dec->i4_error_code;\n                    ps_dec_op->u4_frame_decoded_flag = 0;\n\n                    return (IV_FAIL);\n                }\n                else\n                {\n                    ps_dec->u1_pic_decode_done = 1;\n                    continue;\n                }\n            }\n            else\n            {\n                /* a start code has already been found earlier in the same process call*/\n                frame_data_left = 0;\n                continue;\n            }\n\n        }\n\n        ps_dec->u4_return_to_app = 0;\n        ret = ih264d_parse_nal_unit(dec_hdl, ps_dec_op,\n                              pu1_bitstrm_buf, buflen);\n        if(ret != OK)\n        {\n            UWORD32 error =  ih264d_map_error(ret);\n            ps_dec_op->u4_error_code = error | ret;\n            api_ret_value = IV_FAIL;\n\n            if((ret == IVD_RES_CHANGED)\n                            || (ret == IVD_MEM_ALLOC_FAILED)\n                            || (ret == ERROR_UNAVAIL_PICBUF_T)\n                            || (ret == ERROR_UNAVAIL_MVBUF_T)\n                            || (ret == ERROR_INV_SPS_PPS_T))\n            {\n                ps_dec->u4_slice_start_code_found = 0;\n                break;\n            }\n\n            if((ret == ERROR_INCOMPLETE_FRAME) || (ret == ERROR_DANGLING_FIELD_IN_PIC))\n            {\n                ps_dec_op->u4_num_bytes_consumed -= bytes_consumed;\n                api_ret_value = IV_FAIL;\n                break;\n            }\n\n            if(ret == ERROR_IN_LAST_SLICE_OF_PIC)\n            {\n                api_ret_value = IV_FAIL;\n                break;\n            }\n\n        }\n\n        if(ps_dec->u4_return_to_app)\n        {\n            /*We have encountered a referenced frame,return to app*/\n            ps_dec_op->u4_num_bytes_consumed -= bytes_consumed;\n            ps_dec_op->u4_error_code = IVD_DEC_FRM_SKIPPED;\n            ps_dec_op->u4_error_code |= (1 << IVD_UNSUPPORTEDPARAM);\n            ps_dec_op->u4_frame_decoded_flag = 0;\n            ps_dec_op->u4_size = sizeof(ivd_video_decode_op_t);\n            /*signal the decode thread*/\n            ih264d_signal_decode_thread(ps_dec);\n            /* close deblock thread if it is not closed yet*/\n            if(ps_dec->u4_num_cores == 3)\n            {\n                ih264d_signal_bs_deblk_thread(ps_dec);\n            }\n            return (IV_FAIL);\n\n        }\n\n\n\n        header_data_left = ((ps_dec->i4_decode_header == 1)\n                        && (ps_dec->i4_header_decoded != 3)\n                        && (ps_dec_op->u4_num_bytes_consumed\n                                        < ps_dec_ip->u4_num_Bytes));\n        frame_data_left = (((ps_dec->i4_decode_header == 0)\n                        && ((ps_dec->u1_pic_decode_done == 0)\n                                        || (u4_next_is_aud == 1)))\n                        && (ps_dec_op->u4_num_bytes_consumed\n                                        < ps_dec_ip->u4_num_Bytes));\n    }\n    while(( header_data_left == 1)||(frame_data_left == 1));\n\n    if((ps_dec->u4_slice_start_code_found == 1)\n            && (ret != IVD_MEM_ALLOC_FAILED)\n            && ps_dec->u2_total_mbs_coded < ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)\n    {\n        // last slice - missing/corruption\n        WORD32 num_mb_skipped;\n        WORD32 prev_slice_err;\n        pocstruct_t temp_poc;\n        WORD32 ret1;\n\n        num_mb_skipped = (ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)\n                            - ps_dec->u2_total_mbs_coded;\n\n        if(ps_dec->u4_first_slice_in_pic && (ps_dec->u4_pic_buf_got == 0))\n            prev_slice_err = 1;\n        else\n            prev_slice_err = 2;\n\n        ret1 = ih264d_mark_err_slice_skip(ps_dec, num_mb_skipped, ps_dec->u1_nal_unit_type == IDR_SLICE_NAL, ps_dec->ps_cur_slice->u2_frame_num,\n                                   &temp_poc, prev_slice_err);\n\n        if((ret1 == ERROR_UNAVAIL_PICBUF_T) || (ret1 == ERROR_UNAVAIL_MVBUF_T))\n        {\n            return IV_FAIL;\n        }\n    }\n\n    if((ret == IVD_RES_CHANGED)\n                    || (ret == IVD_MEM_ALLOC_FAILED)\n                    || (ret == ERROR_UNAVAIL_PICBUF_T)\n                    || (ret == ERROR_UNAVAIL_MVBUF_T)\n                    || (ret == ERROR_INV_SPS_PPS_T))\n    {\n\n        /* signal the decode thread */\n        ih264d_signal_decode_thread(ps_dec);\n        /* close deblock thread if it is not closed yet */\n        if(ps_dec->u4_num_cores == 3)\n        {\n            ih264d_signal_bs_deblk_thread(ps_dec);\n        }\n        /* dont consume bitstream for change in resolution case */\n        if(ret == IVD_RES_CHANGED)\n        {\n            ps_dec_op->u4_num_bytes_consumed -= bytes_consumed;\n        }\n        return IV_FAIL;\n    }\n\n\n    if(ps_dec->u1_separate_parse)\n    {\n        /* If Format conversion is not complete,\n         complete it here */\n        if(ps_dec->u4_num_cores == 2)\n        {\n\n            /*do deblocking of all mbs*/\n            if((ps_dec->u4_nmb_deblk == 0) &&(ps_dec->u4_start_recon_deblk == 1) && (ps_dec->ps_cur_sps->u1_mb_aff_flag == 0))\n            {\n                UWORD32 u4_num_mbs,u4_max_addr;\n                tfr_ctxt_t s_tfr_ctxt;\n                tfr_ctxt_t *ps_tfr_cxt = &s_tfr_ctxt;\n                pad_mgr_t *ps_pad_mgr = &ps_dec->s_pad_mgr;\n\n                /*BS is done for all mbs while parsing*/\n                u4_max_addr = (ps_dec->u2_frm_wd_in_mbs * ps_dec->u2_frm_ht_in_mbs) - 1;\n                ps_dec->u4_cur_bs_mb_num = u4_max_addr + 1;\n\n\n                ih264d_init_deblk_tfr_ctxt(ps_dec, ps_pad_mgr, ps_tfr_cxt,\n                                           ps_dec->u2_frm_wd_in_mbs, 0);\n\n\n                u4_num_mbs = u4_max_addr\n                                - ps_dec->u4_cur_deblk_mb_num + 1;\n\n                DEBUG_PERF_PRINTF(\"mbs left for deblocking= %d \\n\",u4_num_mbs);\n\n                if(u4_num_mbs != 0)\n                    ih264d_check_mb_map_deblk(ps_dec, u4_num_mbs,\n                                                   ps_tfr_cxt,1);\n\n                ps_dec->u4_start_recon_deblk  = 0;\n\n            }\n\n        }\n\n        /*signal the decode thread*/\n        ih264d_signal_decode_thread(ps_dec);\n        /* close deblock thread if it is not closed yet*/\n        if(ps_dec->u4_num_cores == 3)\n        {\n            ih264d_signal_bs_deblk_thread(ps_dec);\n        }\n    }\n\n\n    DATA_SYNC();\n\n\n    if((ps_dec_op->u4_error_code & 0xff)\n                    != ERROR_DYNAMIC_RESOLUTION_NOT_SUPPORTED)\n    {\n        ps_dec_op->u4_pic_wd = (UWORD32)ps_dec->u2_disp_width;\n        ps_dec_op->u4_pic_ht = (UWORD32)ps_dec->u2_disp_height;\n    }\n\n//Report if header (sps and pps) has not been decoded yet\n    if(ps_dec->i4_header_decoded != 3)\n    {\n        ps_dec_op->u4_error_code |= (1 << IVD_INSUFFICIENTDATA);\n\n    }\n\n    if(ps_dec->i4_decode_header == 1 && ps_dec->i4_header_decoded != 3)\n    {\n        ps_dec_op->u4_error_code |= (1 << IVD_INSUFFICIENTDATA);\n\n    }\n    if(ps_dec->u4_prev_nal_skipped)\n    {\n        /*We have encountered a referenced frame,return to app*/\n        ps_dec_op->u4_error_code = IVD_DEC_FRM_SKIPPED;\n        ps_dec_op->u4_error_code |= (1 << IVD_UNSUPPORTEDPARAM);\n        ps_dec_op->u4_frame_decoded_flag = 0;\n        ps_dec_op->u4_size = sizeof(ivd_video_decode_op_t);\n        /* close deblock thread if it is not closed yet*/\n        if(ps_dec->u4_num_cores == 3)\n        {\n            ih264d_signal_bs_deblk_thread(ps_dec);\n        }\n        return (IV_FAIL);\n\n    }\n\n    if((ps_dec->u4_slice_start_code_found == 1)\n                    && (ERROR_DANGLING_FIELD_IN_PIC != i4_err_status))\n    {\n        /*\n         * For field pictures, set the bottom and top picture decoded u4_flag correctly.\n         */\n\n        if(ps_dec->ps_cur_slice->u1_field_pic_flag)\n        {\n            if(1 == ps_dec->ps_cur_slice->u1_bottom_field_flag)\n            {\n                ps_dec->u1_top_bottom_decoded |= BOT_FIELD_ONLY;\n            }\n            else\n            {\n                ps_dec->u1_top_bottom_decoded |= TOP_FIELD_ONLY;\n            }\n        }\n\n        /* if new frame in not found (if we are still getting slices from previous frame)\n         * ih264d_deblock_display is not called. Such frames will not be added to reference /display\n         */\n        if((ps_dec->ps_dec_err_status->u1_err_flag & REJECT_CUR_PIC) == 0)\n        {\n            /* Calling Function to deblock Picture and Display */\n            ret = ih264d_deblock_display(ps_dec);\n            if(ret != 0)\n            {\n                return IV_FAIL;\n            }\n        }\n\n\n        /*set to complete ,as we dont support partial frame decode*/\n        if(ps_dec->i4_header_decoded == 3)\n        {\n            ps_dec->u2_total_mbs_coded = ps_dec->ps_cur_sps->u2_max_mb_addr + 1;\n        }\n\n        /*Update the i4_frametype at the end of picture*/\n        if(ps_dec->ps_cur_slice->u1_nal_unit_type == IDR_SLICE_NAL)\n        {\n            ps_dec->i4_frametype = IV_IDR_FRAME;\n        }\n        else if(ps_dec->i4_pic_type == B_SLICE)\n        {\n            ps_dec->i4_frametype = IV_B_FRAME;\n        }\n        else if(ps_dec->i4_pic_type == P_SLICE)\n        {\n            ps_dec->i4_frametype = IV_P_FRAME;\n        }\n        else if(ps_dec->i4_pic_type == I_SLICE)\n        {\n            ps_dec->i4_frametype = IV_I_FRAME;\n        }\n        else\n        {\n            H264_DEC_DEBUG_PRINT(\"Shouldn't come here\\n\");\n        }\n\n        //Update the content type\n        ps_dec->i4_content_type = ps_dec->ps_cur_slice->u1_field_pic_flag;\n\n        ps_dec->u4_total_frames_decoded = ps_dec->u4_total_frames_decoded + 2;\n        ps_dec->u4_total_frames_decoded = ps_dec->u4_total_frames_decoded\n                        - ps_dec->ps_cur_slice->u1_field_pic_flag;\n\n    }\n\n    /* close deblock thread if it is not closed yet*/\n    if(ps_dec->u4_num_cores == 3)\n    {\n        ih264d_signal_bs_deblk_thread(ps_dec);\n    }\n\n\n    {\n        /* In case the decoder is configured to run in low delay mode,\n         * then get display buffer and then format convert.\n         * Note in this mode, format conversion does not run paralelly in a thread and adds to the codec cycles\n         */\n\n        if((IVD_DECODE_FRAME_OUT == ps_dec->e_frm_out_mode)\n                        && ps_dec->u1_init_dec_flag)\n        {\n\n            ih264d_get_next_display_field(ps_dec, ps_dec->ps_out_buffer,\n                                          &(ps_dec->s_disp_op));\n            if(0 == ps_dec->s_disp_op.u4_error_code)\n            {\n                ps_dec->u4_fmt_conv_cur_row = 0;\n                ps_dec->u4_output_present = 1;\n            }\n        }\n\n        ih264d_fill_output_struct_from_context(ps_dec, ps_dec_op);\n\n        /* If Format conversion is not complete,\n         complete it here */\n        if(ps_dec->u4_output_present &&\n          (ps_dec->u4_fmt_conv_cur_row < ps_dec->s_disp_frame_info.u4_y_ht))\n        {\n            ps_dec->u4_fmt_conv_num_rows = ps_dec->s_disp_frame_info.u4_y_ht\n                            - ps_dec->u4_fmt_conv_cur_row;\n            ih264d_format_convert(ps_dec, &(ps_dec->s_disp_op),\n                                  ps_dec->u4_fmt_conv_cur_row,\n                                  ps_dec->u4_fmt_conv_num_rows);\n            ps_dec->u4_fmt_conv_cur_row += ps_dec->u4_fmt_conv_num_rows;\n        }\n\n        ih264d_release_display_field(ps_dec, &(ps_dec->s_disp_op));\n    }\n\n    if(ps_dec->i4_decode_header == 1 && (ps_dec->i4_header_decoded & 1) == 1)\n    {\n        ps_dec_op->u4_progressive_frame_flag = 1;\n        if((NULL != ps_dec->ps_cur_sps) && (1 == (ps_dec->ps_cur_sps->u1_is_valid)))\n        {\n            if((0 == ps_dec->ps_sps->u1_frame_mbs_only_flag)\n                            && (0 == ps_dec->ps_sps->u1_mb_aff_flag))\n                ps_dec_op->u4_progressive_frame_flag = 0;\n\n        }\n    }\n\n    /*Data memory barrier instruction,so that yuv write by the library is complete*/\n    DATA_SYNC();\n\n    H264_DEC_DEBUG_PRINT(\"The num bytes consumed: %d\\n\",\n                         ps_dec_op->u4_num_bytes_consumed);\n    return api_ret_value;\n}",
        "func": "WORD32 ih264d_video_decode(iv_obj_t *dec_hdl, void *pv_api_ip, void *pv_api_op)\n{\n    /* ! */\n\n    dec_struct_t * ps_dec = (dec_struct_t *)(dec_hdl->pv_codec_handle);\n\n    WORD32 i4_err_status = 0;\n    UWORD8 *pu1_buf = NULL;\n    WORD32 buflen;\n    UWORD32 u4_max_ofst, u4_length_of_start_code = 0;\n\n    UWORD32 bytes_consumed = 0;\n    UWORD32 cur_slice_is_nonref = 0;\n    UWORD32 u4_next_is_aud;\n    UWORD32 u4_first_start_code_found = 0;\n    WORD32 ret = 0,api_ret_value = IV_SUCCESS;\n    WORD32 header_data_left = 0,frame_data_left = 0;\n    UWORD8 *pu1_bitstrm_buf;\n    ivd_video_decode_ip_t *ps_dec_ip;\n    ivd_video_decode_op_t *ps_dec_op;\n\n    ithread_set_name((void*)\"Parse_thread\");\n\n    ps_dec_ip = (ivd_video_decode_ip_t *)pv_api_ip;\n    ps_dec_op = (ivd_video_decode_op_t *)pv_api_op;\n\n    {\n        UWORD32 u4_size;\n        u4_size = ps_dec_op->u4_size;\n        memset(ps_dec_op, 0, sizeof(ivd_video_decode_op_t));\n        ps_dec_op->u4_size = u4_size;\n    }\n\n    ps_dec->pv_dec_out = ps_dec_op;\n    if(ps_dec->init_done != 1)\n    {\n        return IV_FAIL;\n    }\n\n    /*Data memory barries instruction,so that bitstream write by the application is complete*/\n    DATA_SYNC();\n\n    if(0 == ps_dec->u1_flushfrm)\n    {\n        if(ps_dec_ip->pv_stream_buffer == NULL)\n        {\n            ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;\n            ps_dec_op->u4_error_code |= IVD_DEC_FRM_BS_BUF_NULL;\n            return IV_FAIL;\n        }\n        if(ps_dec_ip->u4_num_Bytes <= 0)\n        {\n            ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;\n            ps_dec_op->u4_error_code |= IVD_DEC_NUMBYTES_INV;\n            return IV_FAIL;\n\n        }\n    }\n    ps_dec->u1_pic_decode_done = 0;\n\n    ps_dec_op->u4_num_bytes_consumed = 0;\n\n    ps_dec->ps_out_buffer = NULL;\n\n    if(ps_dec_ip->u4_size\n                    >= offsetof(ivd_video_decode_ip_t, s_out_buffer))\n        ps_dec->ps_out_buffer = &ps_dec_ip->s_out_buffer;\n\n    ps_dec->u4_fmt_conv_cur_row = 0;\n\n    ps_dec->u4_output_present = 0;\n    ps_dec->s_disp_op.u4_error_code = 1;\n    ps_dec->u4_fmt_conv_num_rows = FMT_CONV_NUM_ROWS;\n    if(0 == ps_dec->u4_share_disp_buf\n                    && ps_dec->i4_decode_header == 0)\n    {\n        UWORD32 i;\n        if(ps_dec->ps_out_buffer->u4_num_bufs == 0)\n        {\n            ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;\n            ps_dec_op->u4_error_code |= IVD_DISP_FRM_ZERO_OP_BUFS;\n            return IV_FAIL;\n        }\n\n        for(i = 0; i < ps_dec->ps_out_buffer->u4_num_bufs; i++)\n        {\n            if(ps_dec->ps_out_buffer->pu1_bufs[i] == NULL)\n            {\n                ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;\n                ps_dec_op->u4_error_code |= IVD_DISP_FRM_OP_BUF_NULL;\n                return IV_FAIL;\n            }\n\n            if(ps_dec->ps_out_buffer->u4_min_out_buf_size[i] == 0)\n            {\n                ps_dec_op->u4_error_code |= 1 << IVD_UNSUPPORTEDPARAM;\n                ps_dec_op->u4_error_code |=\n                                IVD_DISP_FRM_ZERO_OP_BUF_SIZE;\n                return IV_FAIL;\n            }\n        }\n    }\n\n    if(ps_dec->u4_total_frames_decoded >= NUM_FRAMES_LIMIT)\n    {\n        ps_dec_op->u4_error_code = ERROR_FRAME_LIMIT_OVER;\n        return IV_FAIL;\n    }\n\n    /* ! */\n    ps_dec->u4_ts = ps_dec_ip->u4_ts;\n\n    ps_dec_op->u4_error_code = 0;\n    ps_dec_op->e_pic_type = -1;\n    ps_dec_op->u4_output_present = 0;\n    ps_dec_op->u4_frame_decoded_flag = 0;\n\n    ps_dec->i4_frametype = -1;\n    ps_dec->i4_content_type = -1;\n    /*\n     * For field pictures, set the bottom and top picture decoded u4_flag correctly.\n     */\n    {\n        if((TOP_FIELD_ONLY | BOT_FIELD_ONLY) == ps_dec->u1_top_bottom_decoded)\n        {\n            ps_dec->u1_top_bottom_decoded = 0;\n        }\n    }\n    ps_dec->u4_slice_start_code_found = 0;\n\n    /* In case the deocder is not in flush mode(in shared mode),\n     then decoder has to pick up a buffer to write current frame.\n     Check if a frame is available in such cases */\n\n    if(ps_dec->u1_init_dec_flag == 1 && ps_dec->u4_share_disp_buf == 1\n                    && ps_dec->u1_flushfrm == 0)\n    {\n        UWORD32 i;\n\n        WORD32 disp_avail = 0, free_id;\n\n        /* Check if at least one buffer is available with the codec */\n        /* If not then return to application with error */\n        for(i = 0; i < ps_dec->u1_pic_bufs; i++)\n        {\n            if(0 == ps_dec->u4_disp_buf_mapping[i]\n                            || 1 == ps_dec->u4_disp_buf_to_be_freed[i])\n            {\n                disp_avail = 1;\n                break;\n            }\n\n        }\n\n        if(0 == disp_avail)\n        {\n            /* If something is queued for display wait for that buffer to be returned */\n\n            ps_dec_op->u4_error_code = IVD_DEC_REF_BUF_NULL;\n            ps_dec_op->u4_error_code |= (1 << IVD_UNSUPPORTEDPARAM);\n            return (IV_FAIL);\n        }\n\n        while(1)\n        {\n            pic_buffer_t *ps_pic_buf;\n            ps_pic_buf = (pic_buffer_t *)ih264_buf_mgr_get_next_free(\n                            (buf_mgr_t *)ps_dec->pv_pic_buf_mgr, &free_id);\n\n            if(ps_pic_buf == NULL)\n            {\n                UWORD32 i, display_queued = 0;\n\n                /* check if any buffer was given for display which is not returned yet */\n                for(i = 0; i < (MAX_DISP_BUFS_NEW); i++)\n                {\n                    if(0 != ps_dec->u4_disp_buf_mapping[i])\n                    {\n                        display_queued = 1;\n                        break;\n                    }\n                }\n                /* If some buffer is queued for display, then codec has to singal an error and wait\n                 for that buffer to be returned.\n                 If nothing is queued for display then codec has ownership of all display buffers\n                 and it can reuse any of the existing buffers and continue decoding */\n\n                if(1 == display_queued)\n                {\n                    /* If something is queued for display wait for that buffer to be returned */\n                    ps_dec_op->u4_error_code = IVD_DEC_REF_BUF_NULL;\n                    ps_dec_op->u4_error_code |= (1\n                                    << IVD_UNSUPPORTEDPARAM);\n                    return (IV_FAIL);\n                }\n            }\n            else\n            {\n                /* If the buffer is with display, then mark it as in use and then look for a buffer again */\n                if(1 == ps_dec->u4_disp_buf_mapping[free_id])\n                {\n                    ih264_buf_mgr_set_status(\n                                    (buf_mgr_t *)ps_dec->pv_pic_buf_mgr,\n                                    free_id,\n                                    BUF_MGR_IO);\n                }\n                else\n                {\n                    /**\n                     *  Found a free buffer for present call. Release it now.\n                     *  Will be again obtained later.\n                     */\n                    ih264_buf_mgr_release((buf_mgr_t *)ps_dec->pv_pic_buf_mgr,\n                                          free_id,\n                                          BUF_MGR_IO);\n                    break;\n                }\n            }\n        }\n\n    }\n\n    if(ps_dec->u1_flushfrm && ps_dec->u1_init_dec_flag)\n    {\n\n        ih264d_get_next_display_field(ps_dec, ps_dec->ps_out_buffer,\n                                      &(ps_dec->s_disp_op));\n        if(0 == ps_dec->s_disp_op.u4_error_code)\n        {\n            ps_dec->u4_fmt_conv_cur_row = 0;\n            ps_dec->u4_fmt_conv_num_rows = ps_dec->s_disp_frame_info.u4_y_ht;\n            ih264d_format_convert(ps_dec, &(ps_dec->s_disp_op),\n                                  ps_dec->u4_fmt_conv_cur_row,\n                                  ps_dec->u4_fmt_conv_num_rows);\n            ps_dec->u4_fmt_conv_cur_row += ps_dec->u4_fmt_conv_num_rows;\n            ps_dec->u4_output_present = 1;\n\n        }\n        ih264d_release_display_field(ps_dec, &(ps_dec->s_disp_op));\n\n        ps_dec_op->u4_pic_wd = (UWORD32)ps_dec->u2_disp_width;\n        ps_dec_op->u4_pic_ht = (UWORD32)ps_dec->u2_disp_height;\n\n        ps_dec_op->u4_new_seq = 0;\n\n        ps_dec_op->u4_output_present = ps_dec->u4_output_present;\n        ps_dec_op->u4_progressive_frame_flag =\n                        ps_dec->s_disp_op.u4_progressive_frame_flag;\n        ps_dec_op->e_output_format =\n                        ps_dec->s_disp_op.e_output_format;\n        ps_dec_op->s_disp_frm_buf = ps_dec->s_disp_op.s_disp_frm_buf;\n        ps_dec_op->e4_fld_type = ps_dec->s_disp_op.e4_fld_type;\n        ps_dec_op->u4_ts = ps_dec->s_disp_op.u4_ts;\n        ps_dec_op->u4_disp_buf_id = ps_dec->s_disp_op.u4_disp_buf_id;\n\n        /*In the case of flush ,since no frame is decoded set pic type as invalid*/\n        ps_dec_op->u4_is_ref_flag = -1;\n        ps_dec_op->e_pic_type = IV_NA_FRAME;\n        ps_dec_op->u4_frame_decoded_flag = 0;\n\n        if(0 == ps_dec->s_disp_op.u4_error_code)\n        {\n            return (IV_SUCCESS);\n        }\n        else\n            return (IV_FAIL);\n\n    }\n    if(ps_dec->u1_res_changed == 1)\n    {\n        /*if resolution has changed and all buffers have been flushed, reset decoder*/\n        ih264d_init_decoder(ps_dec);\n    }\n\n    ps_dec->u4_prev_nal_skipped = 0;\n\n    ps_dec->u2_cur_mb_addr = 0;\n    ps_dec->u2_total_mbs_coded = 0;\n    ps_dec->u2_cur_slice_num = 0;\n    ps_dec->cur_dec_mb_num = 0;\n    ps_dec->cur_recon_mb_num = 0;\n    ps_dec->u4_first_slice_in_pic = 2;\n    ps_dec->u1_first_pb_nal_in_pic = 1;\n    ps_dec->u1_slice_header_done = 0;\n    ps_dec->u1_dangling_field = 0;\n\n    ps_dec->u4_dec_thread_created = 0;\n    ps_dec->u4_bs_deblk_thread_created = 0;\n    ps_dec->u4_cur_bs_mb_num = 0;\n    ps_dec->u4_start_recon_deblk  = 0;\n\n    DEBUG_THREADS_PRINTF(\" Starting process call\\n\");\n\n\n    ps_dec->u4_pic_buf_got = 0;\n\n    do\n    {\n        WORD32 buf_size;\n\n        pu1_buf = (UWORD8*)ps_dec_ip->pv_stream_buffer\n                        + ps_dec_op->u4_num_bytes_consumed;\n\n        u4_max_ofst = ps_dec_ip->u4_num_Bytes\n                        - ps_dec_op->u4_num_bytes_consumed;\n\n        /* If dynamic bitstream buffer is not allocated and\n         * header decode is done, then allocate dynamic bitstream buffer\n         */\n        if((NULL == ps_dec->pu1_bits_buf_dynamic) &&\n           (ps_dec->i4_header_decoded & 1))\n        {\n            WORD32 size;\n\n            void *pv_buf;\n            void *pv_mem_ctxt = ps_dec->pv_mem_ctxt;\n            size = MAX(256000, ps_dec->u2_pic_wd * ps_dec->u2_pic_ht * 3 / 2);\n            pv_buf = ps_dec->pf_aligned_alloc(pv_mem_ctxt, 128, size);\n            RETURN_IF((NULL == pv_buf), IV_FAIL);\n            ps_dec->pu1_bits_buf_dynamic = pv_buf;\n            ps_dec->u4_dynamic_bits_buf_size = size;\n        }\n\n        if(ps_dec->pu1_bits_buf_dynamic)\n        {\n            pu1_bitstrm_buf = ps_dec->pu1_bits_buf_dynamic;\n            buf_size = ps_dec->u4_dynamic_bits_buf_size;\n        }\n        else\n        {\n            pu1_bitstrm_buf = ps_dec->pu1_bits_buf_static;\n            buf_size = ps_dec->u4_static_bits_buf_size;\n        }\n\n        u4_next_is_aud = 0;\n\n        buflen = ih264d_find_start_code(pu1_buf, 0, u4_max_ofst,\n                                               &u4_length_of_start_code,\n                                               &u4_next_is_aud);\n\n        if(buflen == -1)\n            buflen = 0;\n        /* Ignore bytes beyond the allocated size of intermediate buffer */\n        buflen = MIN(buflen, buf_size);\n\n        bytes_consumed = buflen + u4_length_of_start_code;\n        ps_dec_op->u4_num_bytes_consumed += bytes_consumed;\n\n        {\n            UWORD8 u1_firstbyte, u1_nal_ref_idc;\n\n            if(ps_dec->i4_app_skip_mode == IVD_SKIP_B)\n            {\n                u1_firstbyte = *(pu1_buf + u4_length_of_start_code);\n                u1_nal_ref_idc = (UWORD8)(NAL_REF_IDC(u1_firstbyte));\n                if(u1_nal_ref_idc == 0)\n                {\n                    /*skip non reference frames*/\n                    cur_slice_is_nonref = 1;\n                    continue;\n                }\n                else\n                {\n                    if(1 == cur_slice_is_nonref)\n                    {\n                        /*We have encountered a referenced frame,return to app*/\n                        ps_dec_op->u4_num_bytes_consumed -=\n                                        bytes_consumed;\n                        ps_dec_op->e_pic_type = IV_B_FRAME;\n                        ps_dec_op->u4_error_code =\n                                        IVD_DEC_FRM_SKIPPED;\n                        ps_dec_op->u4_error_code |= (1\n                                        << IVD_UNSUPPORTEDPARAM);\n                        ps_dec_op->u4_frame_decoded_flag = 0;\n                        ps_dec_op->u4_size =\n                                        sizeof(ivd_video_decode_op_t);\n                        /*signal the decode thread*/\n                        ih264d_signal_decode_thread(ps_dec);\n                        /* close deblock thread if it is not closed yet*/\n                        if(ps_dec->u4_num_cores == 3)\n                        {\n                            ih264d_signal_bs_deblk_thread(ps_dec);\n                        }\n\n                        return (IV_FAIL);\n                    }\n                }\n\n            }\n\n        }\n\n\n        if(buflen)\n        {\n            memcpy(pu1_bitstrm_buf, pu1_buf + u4_length_of_start_code,\n                   buflen);\n            /* Decoder may read extra 8 bytes near end of the frame */\n            if((buflen + 8) < buf_size)\n            {\n                memset(pu1_bitstrm_buf + buflen, 0, 8);\n            }\n            u4_first_start_code_found = 1;\n\n        }\n        else\n        {\n            /*start code not found*/\n\n            if(u4_first_start_code_found == 0)\n            {\n                /*no start codes found in current process call*/\n\n                ps_dec->i4_error_code = ERROR_START_CODE_NOT_FOUND;\n                ps_dec_op->u4_error_code |= 1 << IVD_INSUFFICIENTDATA;\n\n                if(ps_dec->u4_pic_buf_got == 0)\n                {\n\n                    ih264d_fill_output_struct_from_context(ps_dec,\n                                                           ps_dec_op);\n\n                    ps_dec_op->u4_error_code = ps_dec->i4_error_code;\n                    ps_dec_op->u4_frame_decoded_flag = 0;\n\n                    return (IV_FAIL);\n                }\n                else\n                {\n                    ps_dec->u1_pic_decode_done = 1;\n                    continue;\n                }\n            }\n            else\n            {\n                /* a start code has already been found earlier in the same process call*/\n                frame_data_left = 0;\n                continue;\n            }\n\n        }\n\n        ps_dec->u4_return_to_app = 0;\n        ret = ih264d_parse_nal_unit(dec_hdl, ps_dec_op,\n                              pu1_bitstrm_buf, buflen);\n        if(ret != OK)\n        {\n            UWORD32 error =  ih264d_map_error(ret);\n            ps_dec_op->u4_error_code = error | ret;\n            api_ret_value = IV_FAIL;\n\n            if((ret == IVD_RES_CHANGED)\n                            || (ret == IVD_MEM_ALLOC_FAILED)\n                            || (ret == ERROR_UNAVAIL_PICBUF_T)\n                            || (ret == ERROR_UNAVAIL_MVBUF_T)\n                            || (ret == ERROR_INV_SPS_PPS_T))\n            {\n                ps_dec->u4_slice_start_code_found = 0;\n                break;\n            }\n\n            if((ret == ERROR_INCOMPLETE_FRAME) || (ret == ERROR_DANGLING_FIELD_IN_PIC))\n            {\n                ps_dec_op->u4_num_bytes_consumed -= bytes_consumed;\n                api_ret_value = IV_FAIL;\n                break;\n            }\n\n            if(ret == ERROR_IN_LAST_SLICE_OF_PIC)\n            {\n                api_ret_value = IV_FAIL;\n                break;\n            }\n\n        }\n\n        if(ps_dec->u4_return_to_app)\n        {\n            /*We have encountered a referenced frame,return to app*/\n            ps_dec_op->u4_num_bytes_consumed -= bytes_consumed;\n            ps_dec_op->u4_error_code = IVD_DEC_FRM_SKIPPED;\n            ps_dec_op->u4_error_code |= (1 << IVD_UNSUPPORTEDPARAM);\n            ps_dec_op->u4_frame_decoded_flag = 0;\n            ps_dec_op->u4_size = sizeof(ivd_video_decode_op_t);\n            /*signal the decode thread*/\n            ih264d_signal_decode_thread(ps_dec);\n            /* close deblock thread if it is not closed yet*/\n            if(ps_dec->u4_num_cores == 3)\n            {\n                ih264d_signal_bs_deblk_thread(ps_dec);\n            }\n            return (IV_FAIL);\n\n        }\n\n\n\n        header_data_left = ((ps_dec->i4_decode_header == 1)\n                        && (ps_dec->i4_header_decoded != 3)\n                        && (ps_dec_op->u4_num_bytes_consumed\n                                        < ps_dec_ip->u4_num_Bytes));\n        frame_data_left = (((ps_dec->i4_decode_header == 0)\n                        && ((ps_dec->u1_pic_decode_done == 0)\n                                        || (u4_next_is_aud == 1)))\n                        && (ps_dec_op->u4_num_bytes_consumed\n                                        < ps_dec_ip->u4_num_Bytes));\n    }\n    while(( header_data_left == 1)||(frame_data_left == 1));\n\n    if((ps_dec->u4_slice_start_code_found == 1)\n            && (ret != IVD_MEM_ALLOC_FAILED)\n            && ps_dec->u2_total_mbs_coded < ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)\n    {\n        // last slice - missing/corruption\n        WORD32 num_mb_skipped;\n        WORD32 prev_slice_err;\n        pocstruct_t temp_poc;\n        WORD32 ret1;\n\n        num_mb_skipped = (ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)\n                            - ps_dec->u2_total_mbs_coded;\n\n        if(ps_dec->u4_first_slice_in_pic && (ps_dec->u4_pic_buf_got == 0))\n            prev_slice_err = 1;\n        else\n            prev_slice_err = 2;\n\n        if(ps_dec->u4_first_slice_in_pic && (ps_dec->u2_total_mbs_coded == 0))\n            prev_slice_err = 1;\n\n        ret1 = ih264d_mark_err_slice_skip(ps_dec, num_mb_skipped, ps_dec->u1_nal_unit_type == IDR_SLICE_NAL, ps_dec->ps_cur_slice->u2_frame_num,\n                                   &temp_poc, prev_slice_err);\n\n        if((ret1 == ERROR_UNAVAIL_PICBUF_T) || (ret1 == ERROR_UNAVAIL_MVBUF_T))\n        {\n            return IV_FAIL;\n        }\n    }\n\n    if((ret == IVD_RES_CHANGED)\n                    || (ret == IVD_MEM_ALLOC_FAILED)\n                    || (ret == ERROR_UNAVAIL_PICBUF_T)\n                    || (ret == ERROR_UNAVAIL_MVBUF_T)\n                    || (ret == ERROR_INV_SPS_PPS_T))\n    {\n\n        /* signal the decode thread */\n        ih264d_signal_decode_thread(ps_dec);\n        /* close deblock thread if it is not closed yet */\n        if(ps_dec->u4_num_cores == 3)\n        {\n            ih264d_signal_bs_deblk_thread(ps_dec);\n        }\n        /* dont consume bitstream for change in resolution case */\n        if(ret == IVD_RES_CHANGED)\n        {\n            ps_dec_op->u4_num_bytes_consumed -= bytes_consumed;\n        }\n        return IV_FAIL;\n    }\n\n\n    if(ps_dec->u1_separate_parse)\n    {\n        /* If Format conversion is not complete,\n         complete it here */\n        if(ps_dec->u4_num_cores == 2)\n        {\n\n            /*do deblocking of all mbs*/\n            if((ps_dec->u4_nmb_deblk == 0) &&(ps_dec->u4_start_recon_deblk == 1) && (ps_dec->ps_cur_sps->u1_mb_aff_flag == 0))\n            {\n                UWORD32 u4_num_mbs,u4_max_addr;\n                tfr_ctxt_t s_tfr_ctxt;\n                tfr_ctxt_t *ps_tfr_cxt = &s_tfr_ctxt;\n                pad_mgr_t *ps_pad_mgr = &ps_dec->s_pad_mgr;\n\n                /*BS is done for all mbs while parsing*/\n                u4_max_addr = (ps_dec->u2_frm_wd_in_mbs * ps_dec->u2_frm_ht_in_mbs) - 1;\n                ps_dec->u4_cur_bs_mb_num = u4_max_addr + 1;\n\n\n                ih264d_init_deblk_tfr_ctxt(ps_dec, ps_pad_mgr, ps_tfr_cxt,\n                                           ps_dec->u2_frm_wd_in_mbs, 0);\n\n\n                u4_num_mbs = u4_max_addr\n                                - ps_dec->u4_cur_deblk_mb_num + 1;\n\n                DEBUG_PERF_PRINTF(\"mbs left for deblocking= %d \\n\",u4_num_mbs);\n\n                if(u4_num_mbs != 0)\n                    ih264d_check_mb_map_deblk(ps_dec, u4_num_mbs,\n                                                   ps_tfr_cxt,1);\n\n                ps_dec->u4_start_recon_deblk  = 0;\n\n            }\n\n        }\n\n        /*signal the decode thread*/\n        ih264d_signal_decode_thread(ps_dec);\n        /* close deblock thread if it is not closed yet*/\n        if(ps_dec->u4_num_cores == 3)\n        {\n            ih264d_signal_bs_deblk_thread(ps_dec);\n        }\n    }\n\n\n    DATA_SYNC();\n\n\n    if((ps_dec_op->u4_error_code & 0xff)\n                    != ERROR_DYNAMIC_RESOLUTION_NOT_SUPPORTED)\n    {\n        ps_dec_op->u4_pic_wd = (UWORD32)ps_dec->u2_disp_width;\n        ps_dec_op->u4_pic_ht = (UWORD32)ps_dec->u2_disp_height;\n    }\n\n//Report if header (sps and pps) has not been decoded yet\n    if(ps_dec->i4_header_decoded != 3)\n    {\n        ps_dec_op->u4_error_code |= (1 << IVD_INSUFFICIENTDATA);\n\n    }\n\n    if(ps_dec->i4_decode_header == 1 && ps_dec->i4_header_decoded != 3)\n    {\n        ps_dec_op->u4_error_code |= (1 << IVD_INSUFFICIENTDATA);\n\n    }\n    if(ps_dec->u4_prev_nal_skipped)\n    {\n        /*We have encountered a referenced frame,return to app*/\n        ps_dec_op->u4_error_code = IVD_DEC_FRM_SKIPPED;\n        ps_dec_op->u4_error_code |= (1 << IVD_UNSUPPORTEDPARAM);\n        ps_dec_op->u4_frame_decoded_flag = 0;\n        ps_dec_op->u4_size = sizeof(ivd_video_decode_op_t);\n        /* close deblock thread if it is not closed yet*/\n        if(ps_dec->u4_num_cores == 3)\n        {\n            ih264d_signal_bs_deblk_thread(ps_dec);\n        }\n        return (IV_FAIL);\n\n    }\n\n    if((ps_dec->u4_slice_start_code_found == 1)\n                    && (ERROR_DANGLING_FIELD_IN_PIC != i4_err_status))\n    {\n        /*\n         * For field pictures, set the bottom and top picture decoded u4_flag correctly.\n         */\n\n        if(ps_dec->ps_cur_slice->u1_field_pic_flag)\n        {\n            if(1 == ps_dec->ps_cur_slice->u1_bottom_field_flag)\n            {\n                ps_dec->u1_top_bottom_decoded |= BOT_FIELD_ONLY;\n            }\n            else\n            {\n                ps_dec->u1_top_bottom_decoded |= TOP_FIELD_ONLY;\n            }\n        }\n\n        /* if new frame in not found (if we are still getting slices from previous frame)\n         * ih264d_deblock_display is not called. Such frames will not be added to reference /display\n         */\n        if((ps_dec->ps_dec_err_status->u1_err_flag & REJECT_CUR_PIC) == 0)\n        {\n            /* Calling Function to deblock Picture and Display */\n            ret = ih264d_deblock_display(ps_dec);\n            if(ret != 0)\n            {\n                return IV_FAIL;\n            }\n        }\n\n\n        /*set to complete ,as we dont support partial frame decode*/\n        if(ps_dec->i4_header_decoded == 3)\n        {\n            ps_dec->u2_total_mbs_coded = ps_dec->ps_cur_sps->u2_max_mb_addr + 1;\n        }\n\n        /*Update the i4_frametype at the end of picture*/\n        if(ps_dec->ps_cur_slice->u1_nal_unit_type == IDR_SLICE_NAL)\n        {\n            ps_dec->i4_frametype = IV_IDR_FRAME;\n        }\n        else if(ps_dec->i4_pic_type == B_SLICE)\n        {\n            ps_dec->i4_frametype = IV_B_FRAME;\n        }\n        else if(ps_dec->i4_pic_type == P_SLICE)\n        {\n            ps_dec->i4_frametype = IV_P_FRAME;\n        }\n        else if(ps_dec->i4_pic_type == I_SLICE)\n        {\n            ps_dec->i4_frametype = IV_I_FRAME;\n        }\n        else\n        {\n            H264_DEC_DEBUG_PRINT(\"Shouldn't come here\\n\");\n        }\n\n        //Update the content type\n        ps_dec->i4_content_type = ps_dec->ps_cur_slice->u1_field_pic_flag;\n\n        ps_dec->u4_total_frames_decoded = ps_dec->u4_total_frames_decoded + 2;\n        ps_dec->u4_total_frames_decoded = ps_dec->u4_total_frames_decoded\n                        - ps_dec->ps_cur_slice->u1_field_pic_flag;\n\n    }\n\n    /* close deblock thread if it is not closed yet*/\n    if(ps_dec->u4_num_cores == 3)\n    {\n        ih264d_signal_bs_deblk_thread(ps_dec);\n    }\n\n\n    {\n        /* In case the decoder is configured to run in low delay mode,\n         * then get display buffer and then format convert.\n         * Note in this mode, format conversion does not run paralelly in a thread and adds to the codec cycles\n         */\n\n        if((IVD_DECODE_FRAME_OUT == ps_dec->e_frm_out_mode)\n                        && ps_dec->u1_init_dec_flag)\n        {\n\n            ih264d_get_next_display_field(ps_dec, ps_dec->ps_out_buffer,\n                                          &(ps_dec->s_disp_op));\n            if(0 == ps_dec->s_disp_op.u4_error_code)\n            {\n                ps_dec->u4_fmt_conv_cur_row = 0;\n                ps_dec->u4_output_present = 1;\n            }\n        }\n\n        ih264d_fill_output_struct_from_context(ps_dec, ps_dec_op);\n\n        /* If Format conversion is not complete,\n         complete it here */\n        if(ps_dec->u4_output_present &&\n          (ps_dec->u4_fmt_conv_cur_row < ps_dec->s_disp_frame_info.u4_y_ht))\n        {\n            ps_dec->u4_fmt_conv_num_rows = ps_dec->s_disp_frame_info.u4_y_ht\n                            - ps_dec->u4_fmt_conv_cur_row;\n            ih264d_format_convert(ps_dec, &(ps_dec->s_disp_op),\n                                  ps_dec->u4_fmt_conv_cur_row,\n                                  ps_dec->u4_fmt_conv_num_rows);\n            ps_dec->u4_fmt_conv_cur_row += ps_dec->u4_fmt_conv_num_rows;\n        }\n\n        ih264d_release_display_field(ps_dec, &(ps_dec->s_disp_op));\n    }\n\n    if(ps_dec->i4_decode_header == 1 && (ps_dec->i4_header_decoded & 1) == 1)\n    {\n        ps_dec_op->u4_progressive_frame_flag = 1;\n        if((NULL != ps_dec->ps_cur_sps) && (1 == (ps_dec->ps_cur_sps->u1_is_valid)))\n        {\n            if((0 == ps_dec->ps_sps->u1_frame_mbs_only_flag)\n                            && (0 == ps_dec->ps_sps->u1_mb_aff_flag))\n                ps_dec_op->u4_progressive_frame_flag = 0;\n\n        }\n    }\n\n    /*Data memory barrier instruction,so that yuv write by the library is complete*/\n    DATA_SYNC();\n\n    H264_DEC_DEBUG_PRINT(\"The num bytes consumed: %d\\n\",\n                         ps_dec_op->u4_num_bytes_consumed);\n    return api_ret_value;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -525,6 +525,9 @@\n         else\n             prev_slice_err = 2;\n \n+        if(ps_dec->u4_first_slice_in_pic && (ps_dec->u2_total_mbs_coded == 0))\n+            prev_slice_err = 1;\n+\n         ret1 = ih264d_mark_err_slice_skip(ps_dec, num_mb_skipped, ps_dec->u1_nal_unit_type == IDR_SLICE_NAL, ps_dec->ps_cur_slice->u2_frame_num,\n                                    &temp_poc, prev_slice_err);\n ",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "        if(ps_dec->u4_first_slice_in_pic && (ps_dec->u2_total_mbs_coded == 0))",
                "            prev_slice_err = 1;",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2016-3879",
        "func_name": "android/DLSParser",
        "description": "arm-wt-22k/lib_src/eas_mdls.c in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, and 6.x before 2016-09-01 allows remote attackers to cause a denial of service (NULL pointer dereference, and device hang or reboot) via a crafted media file, aka internal bug 29770686.",
        "git_url": "https://android.googlesource.com/platform/external/sonivox/+/cadfb7a3c96d4fef06656cf37143e1b3e62cae86",
        "commit_title": "Fix NULL pointer dereference",
        "commit_text": " Bug: 29770686 Bug: 23304983 ",
        "func_before": "EAS_RESULT DLSParser (EAS_HW_DATA_HANDLE hwInstData, EAS_FILE_HANDLE fileHandle, EAS_I32 offset, EAS_DLSLIB_HANDLE *ppDLS)\n{\n    EAS_RESULT result;\n    SDLS_SYNTHESIZER_DATA dls;\n    EAS_U32 temp;\n    EAS_I32 pos;\n    EAS_I32 chunkPos;\n    EAS_I32 size;\n    EAS_I32 instSize;\n    EAS_I32 rgnPoolSize;\n    EAS_I32 artPoolSize;\n    EAS_I32 waveLenSize;\n    EAS_I32 endDLS;\n    EAS_I32 wvplPos;\n    EAS_I32 wvplSize;\n    EAS_I32 linsPos;\n    EAS_I32 linsSize;\n    EAS_I32 ptblPos;\n    EAS_I32 ptblSize;\n    void *p;\n\n    /* zero counts and pointers */\n    EAS_HWMemSet(&dls, 0, sizeof(dls));\n\n    /* save file handle and hwInstData to save copying pointers around */\n    dls.hwInstData = hwInstData;\n    dls.fileHandle = fileHandle;\n\n    /* NULL return value in case of error */\n    *ppDLS = NULL;\n\n    /* seek to start of DLS and read in RIFF tag and set processor endian flag */\n    if ((result = EAS_HWFileSeek(dls.hwInstData, dls.fileHandle, offset)) != EAS_SUCCESS)\n        return result;\n    if ((result = EAS_HWReadFile(dls.hwInstData, dls.fileHandle, &temp, sizeof(temp), &size)) != EAS_SUCCESS)\n        return result;\n\n    /* check for processor endian-ness */\n    dls.bigEndian = (temp == CHUNK_RIFF);\n\n    /* first chunk should be DLS */\n    pos = offset;\n    if ((result = NextChunk(&dls, &pos, &temp, &size)) != EAS_SUCCESS)\n        return result;\n    if (temp != CHUNK_DLS)\n    {\n        { /* dpp: EAS_ReportEx(_EAS_SEVERITY_ERROR, \"Expected DLS chunk, got %08lx\\n\", temp); */ }\n        return EAS_ERROR_FILE_FORMAT;\n    }\n\n    /* no instrument or wavepool chunks */\n    linsSize = wvplSize = ptblSize = linsPos = wvplPos = ptblPos = 0;\n\n    /* scan the chunks in the DLS list */\n    endDLS = offset + size;\n    pos = offset + 12;\n    while (pos < endDLS)\n    {\n        chunkPos = pos;\n\n        /* get the next chunk type */\n        if ((result = NextChunk(&dls, &pos, &temp, &size)) != EAS_SUCCESS)\n            return result;\n\n        /* parse useful chunks */\n        switch (temp)\n        {\n            case CHUNK_CDL:\n                if ((result = Parse_cdl(&dls, size, &temp)) != EAS_SUCCESS)\n                    return result;\n                if (!temp)\n                    return EAS_ERROR_UNRECOGNIZED_FORMAT;\n                break;\n\n            case CHUNK_LINS:\n                linsPos = chunkPos + 12;\n                linsSize = size - 4;\n                break;\n\n            case CHUNK_WVPL:\n                wvplPos = chunkPos + 12;\n                wvplSize = size - 4;\n                break;\n\n            case CHUNK_PTBL:\n                ptblPos = chunkPos + 8;\n                ptblSize = size - 4;\n                break;\n\n            default:\n                break;\n        }\n    }\n\n    /* must have a lins chunk */\n    if (linsSize == 0)\n    {\n        { /* dpp: EAS_ReportEx(_EAS_SEVERITY_ERROR, \"No lins chunk found\"); */ }\n        return EAS_ERROR_UNRECOGNIZED_FORMAT;\n    }\n\n    /* must have a wvpl chunk */\n    if (wvplSize == 0)\n    {\n        { /* dpp: EAS_ReportEx(_EAS_SEVERITY_ERROR, \"No wvpl chunk found\"); */ }\n        return EAS_ERROR_UNRECOGNIZED_FORMAT;\n    }\n\n    /* must have a ptbl chunk */\n    if ((ptblSize == 0) || (ptblSize > DLS_MAX_WAVE_COUNT * sizeof(POOLCUE) + sizeof(POOLTABLE)))\n    {\n        { /* dpp: EAS_ReportEx(_EAS_SEVERITY_ERROR, \"No ptbl chunk found\"); */ }\n        return EAS_ERROR_UNRECOGNIZED_FORMAT;\n    }\n\n    /* pre-parse the wave pool chunk */\n    if ((result = Parse_ptbl(&dls, ptblPos, wvplPos, wvplSize)) != EAS_SUCCESS)\n        return result;\n\n    /* limit check  */\n    if ((dls.waveCount == 0) || (dls.waveCount > DLS_MAX_WAVE_COUNT))\n    {\n        { /* dpp: EAS_ReportEx(_EAS_SEVERITY_ERROR, \"DLS file contains invalid #waves [%u]\\n\", dls.waveCount); */ }\n        return EAS_ERROR_FILE_FORMAT;\n    }\n\n    /* allocate memory for wsmp data */\n    dls.wsmpData = EAS_HWMalloc(dls.hwInstData, (EAS_I32) (sizeof(S_WSMP_DATA) * dls.waveCount));\n    if (dls.wsmpData == NULL)\n    {\n        { /* dpp: EAS_ReportEx(_EAS_SEVERITY_ERROR, \"EAS_HWMalloc for wsmp data failed\\n\"); */ }\n        return EAS_ERROR_MALLOC_FAILED;\n    }\n    EAS_HWMemSet(dls.wsmpData, 0, (EAS_I32) (sizeof(S_WSMP_DATA) * dls.waveCount));\n\n    /* pre-parse the lins chunk */\n    result = Parse_lins(&dls, linsPos, linsSize);\n    if (result == EAS_SUCCESS)\n    {\n\n        /* limit check  */\n        if ((dls.regionCount == 0) || (dls.regionCount > DLS_MAX_REGION_COUNT))\n        {\n            { /* dpp: EAS_ReportEx(_EAS_SEVERITY_ERROR, \"DLS file contains invalid #regions [%u]\\n\", dls.regionCount); */ }\n            return EAS_ERROR_FILE_FORMAT;\n        }\n\n        /* limit check  */\n        if ((dls.artCount == 0) || (dls.artCount > DLS_MAX_ART_COUNT))\n        {\n            { /* dpp: EAS_ReportEx(_EAS_SEVERITY_ERROR, \"DLS file contains invalid #articulations [%u]\\n\", dls.regionCount); */ }\n            return EAS_ERROR_FILE_FORMAT;\n        }\n\n        /* limit check  */\n        if ((dls.instCount == 0) || (dls.instCount > DLS_MAX_INST_COUNT))\n        {\n            { /* dpp: EAS_ReportEx(_EAS_SEVERITY_ERROR, \"DLS file contains invalid #instruments [%u]\\n\", dls.instCount); */ }\n            return EAS_ERROR_FILE_FORMAT;\n        }\n\n        /* Allocate memory for the converted DLS data */\n        /* calculate size of instrument data */\n        instSize = (EAS_I32) (sizeof(S_PROGRAM) * dls.instCount);\n\n        /* calculate size of region pool */\n        rgnPoolSize = (EAS_I32) (sizeof(S_DLS_REGION) * dls.regionCount);\n\n        /* calculate size of articulation pool, add one for default articulation */\n        dls.artCount++;\n        artPoolSize = (EAS_I32) (sizeof(S_DLS_ARTICULATION) * dls.artCount);\n\n        /* calculate size of wave length and offset arrays */\n        waveLenSize = (EAS_I32) (dls.waveCount * sizeof(EAS_U32));\n\n        /* calculate final memory size */\n        size = (EAS_I32) sizeof(S_EAS) + instSize + rgnPoolSize + artPoolSize + (2 * waveLenSize) + (EAS_I32) dls.wavePoolSize;\n        if (size <= 0) {\n            return EAS_ERROR_FILE_FORMAT;\n        }\n\n        /* allocate the main EAS chunk */\n        dls.pDLS = EAS_HWMalloc(dls.hwInstData, size);\n        if (dls.pDLS == NULL)\n        {\n            { /* dpp: EAS_ReportEx(_EAS_SEVERITY_ERROR, \"EAS_HWMalloc failed for DLS memory allocation size %ld\\n\", size); */ }\n            return EAS_ERROR_MALLOC_FAILED;\n        }\n        EAS_HWMemSet(dls.pDLS, 0, size);\n        dls.pDLS->refCount = 1;\n        p = PtrOfs(dls.pDLS, sizeof(S_EAS));\n\n        /* setup pointer to programs */\n        dls.pDLS->numDLSPrograms = (EAS_U16) dls.instCount;\n        dls.pDLS->pDLSPrograms = p;\n        p = PtrOfs(p, instSize);\n\n        /* setup pointer to regions */\n        dls.pDLS->pDLSRegions = p;\n        dls.pDLS->numDLSRegions = (EAS_U16) dls.regionCount;\n        p = PtrOfs(p, rgnPoolSize);\n\n        /* setup pointer to articulations */\n        dls.pDLS->numDLSArticulations = (EAS_U16) dls.artCount;\n        dls.pDLS->pDLSArticulations = p;\n        p = PtrOfs(p, artPoolSize);\n\n        /* setup pointer to wave length table */\n        dls.pDLS->numDLSSamples = (EAS_U16) dls.waveCount;\n        dls.pDLS->pDLSSampleLen = p;\n        p = PtrOfs(p, waveLenSize);\n\n        /* setup pointer to wave offsets table */\n        dls.pDLS->pDLSSampleOffsets = p;\n        p = PtrOfs(p, waveLenSize);\n\n        /* setup pointer to wave pool */\n        dls.pDLS->pDLSSamples = p;\n\n        /* clear filter flag */\n        dls.filterUsed = EAS_FALSE;\n\n        /* parse the wave pool and load samples */\n        result = Parse_ptbl(&dls, ptblPos, wvplPos, wvplSize);\n    }\n\n    /* create the default articulation */\n    Convert_art(&dls, &defaultArt, 0);\n    dls.artCount = 1;\n\n    /* parse the lins chunk and load instruments */\n    dls.regionCount = dls.instCount = 0;\n    if (result == EAS_SUCCESS)\n        result = Parse_lins(&dls, linsPos, linsSize);\n\n    /* clean up any temporary objects that were allocated */\n    if (dls.wsmpData)\n        EAS_HWFree(dls.hwInstData, dls.wsmpData);\n\n    /* if successful, return a pointer to the EAS collection */\n    if (result == EAS_SUCCESS)\n    {\n        *ppDLS = dls.pDLS;\n#ifdef _DEBUG_DLS\n        DumpDLS(dls.pDLS);\n#endif\n    }\n\n    /* something went wrong, deallocate the EAS collection */\n    else\n        DLSCleanup(dls.hwInstData, dls.pDLS);\n\n    return result;\n}",
        "func": "EAS_RESULT DLSParser (EAS_HW_DATA_HANDLE hwInstData, EAS_FILE_HANDLE fileHandle, EAS_I32 offset, EAS_DLSLIB_HANDLE *ppDLS)\n{\n    EAS_RESULT result;\n    SDLS_SYNTHESIZER_DATA dls;\n    EAS_U32 temp;\n    EAS_I32 pos;\n    EAS_I32 chunkPos;\n    EAS_I32 size;\n    EAS_I32 instSize;\n    EAS_I32 rgnPoolSize;\n    EAS_I32 artPoolSize;\n    EAS_I32 waveLenSize;\n    EAS_I32 endDLS;\n    EAS_I32 wvplPos;\n    EAS_I32 wvplSize;\n    EAS_I32 linsPos;\n    EAS_I32 linsSize;\n    EAS_I32 ptblPos;\n    EAS_I32 ptblSize;\n    void *p;\n\n    /* zero counts and pointers */\n    EAS_HWMemSet(&dls, 0, sizeof(dls));\n\n    /* save file handle and hwInstData to save copying pointers around */\n    dls.hwInstData = hwInstData;\n    dls.fileHandle = fileHandle;\n\n    /* NULL return value in case of error */\n    *ppDLS = NULL;\n\n    /* seek to start of DLS and read in RIFF tag and set processor endian flag */\n    if ((result = EAS_HWFileSeek(dls.hwInstData, dls.fileHandle, offset)) != EAS_SUCCESS)\n        return result;\n    if ((result = EAS_HWReadFile(dls.hwInstData, dls.fileHandle, &temp, sizeof(temp), &size)) != EAS_SUCCESS)\n        return result;\n\n    /* check for processor endian-ness */\n    dls.bigEndian = (temp == CHUNK_RIFF);\n\n    /* first chunk should be DLS */\n    pos = offset;\n    if ((result = NextChunk(&dls, &pos, &temp, &size)) != EAS_SUCCESS)\n        return result;\n    if (temp != CHUNK_DLS)\n    {\n        { /* dpp: EAS_ReportEx(_EAS_SEVERITY_ERROR, \"Expected DLS chunk, got %08lx\\n\", temp); */ }\n        return EAS_ERROR_FILE_FORMAT;\n    }\n\n    /* no instrument or wavepool chunks */\n    linsSize = wvplSize = ptblSize = linsPos = wvplPos = ptblPos = 0;\n\n    /* scan the chunks in the DLS list */\n    endDLS = offset + size;\n    pos = offset + 12;\n    while (pos < endDLS)\n    {\n        chunkPos = pos;\n\n        /* get the next chunk type */\n        if ((result = NextChunk(&dls, &pos, &temp, &size)) != EAS_SUCCESS)\n            return result;\n\n        /* parse useful chunks */\n        switch (temp)\n        {\n            case CHUNK_CDL:\n                if ((result = Parse_cdl(&dls, size, &temp)) != EAS_SUCCESS)\n                    return result;\n                if (!temp)\n                    return EAS_ERROR_UNRECOGNIZED_FORMAT;\n                break;\n\n            case CHUNK_LINS:\n                linsPos = chunkPos + 12;\n                linsSize = size - 4;\n                break;\n\n            case CHUNK_WVPL:\n                wvplPos = chunkPos + 12;\n                wvplSize = size - 4;\n                break;\n\n            case CHUNK_PTBL:\n                ptblPos = chunkPos + 8;\n                ptblSize = size - 4;\n                break;\n\n            default:\n                break;\n        }\n    }\n\n    /* must have a lins chunk */\n    if (linsSize == 0)\n    {\n        { /* dpp: EAS_ReportEx(_EAS_SEVERITY_ERROR, \"No lins chunk found\"); */ }\n        return EAS_ERROR_UNRECOGNIZED_FORMAT;\n    }\n\n    /* must have a wvpl chunk */\n    if (wvplSize == 0)\n    {\n        { /* dpp: EAS_ReportEx(_EAS_SEVERITY_ERROR, \"No wvpl chunk found\"); */ }\n        return EAS_ERROR_UNRECOGNIZED_FORMAT;\n    }\n\n    /* must have a ptbl chunk */\n    if ((ptblSize == 0) || (ptblSize > DLS_MAX_WAVE_COUNT * sizeof(POOLCUE) + sizeof(POOLTABLE)))\n    {\n        { /* dpp: EAS_ReportEx(_EAS_SEVERITY_ERROR, \"No ptbl chunk found\"); */ }\n        return EAS_ERROR_UNRECOGNIZED_FORMAT;\n    }\n\n    /* pre-parse the wave pool chunk */\n    if ((result = Parse_ptbl(&dls, ptblPos, wvplPos, wvplSize)) != EAS_SUCCESS)\n        return result;\n\n    /* limit check  */\n    if ((dls.waveCount == 0) || (dls.waveCount > DLS_MAX_WAVE_COUNT))\n    {\n        { /* dpp: EAS_ReportEx(_EAS_SEVERITY_ERROR, \"DLS file contains invalid #waves [%u]\\n\", dls.waveCount); */ }\n        return EAS_ERROR_FILE_FORMAT;\n    }\n\n    /* allocate memory for wsmp data */\n    dls.wsmpData = EAS_HWMalloc(dls.hwInstData, (EAS_I32) (sizeof(S_WSMP_DATA) * dls.waveCount));\n    if (dls.wsmpData == NULL)\n    {\n        { /* dpp: EAS_ReportEx(_EAS_SEVERITY_ERROR, \"EAS_HWMalloc for wsmp data failed\\n\"); */ }\n        return EAS_ERROR_MALLOC_FAILED;\n    }\n    EAS_HWMemSet(dls.wsmpData, 0, (EAS_I32) (sizeof(S_WSMP_DATA) * dls.waveCount));\n\n    /* pre-parse the lins chunk */\n    result = Parse_lins(&dls, linsPos, linsSize);\n    if (result == EAS_SUCCESS)\n    {\n\n        /* limit check  */\n        if ((dls.regionCount == 0) || (dls.regionCount > DLS_MAX_REGION_COUNT))\n        {\n            { /* dpp: EAS_ReportEx(_EAS_SEVERITY_ERROR, \"DLS file contains invalid #regions [%u]\\n\", dls.regionCount); */ }\n            return EAS_ERROR_FILE_FORMAT;\n        }\n\n        /* limit check  */\n        if ((dls.artCount == 0) || (dls.artCount > DLS_MAX_ART_COUNT))\n        {\n            { /* dpp: EAS_ReportEx(_EAS_SEVERITY_ERROR, \"DLS file contains invalid #articulations [%u]\\n\", dls.regionCount); */ }\n            return EAS_ERROR_FILE_FORMAT;\n        }\n\n        /* limit check  */\n        if ((dls.instCount == 0) || (dls.instCount > DLS_MAX_INST_COUNT))\n        {\n            { /* dpp: EAS_ReportEx(_EAS_SEVERITY_ERROR, \"DLS file contains invalid #instruments [%u]\\n\", dls.instCount); */ }\n            return EAS_ERROR_FILE_FORMAT;\n        }\n\n        /* Allocate memory for the converted DLS data */\n        /* calculate size of instrument data */\n        instSize = (EAS_I32) (sizeof(S_PROGRAM) * dls.instCount);\n\n        /* calculate size of region pool */\n        rgnPoolSize = (EAS_I32) (sizeof(S_DLS_REGION) * dls.regionCount);\n\n        /* calculate size of articulation pool, add one for default articulation */\n        dls.artCount++;\n        artPoolSize = (EAS_I32) (sizeof(S_DLS_ARTICULATION) * dls.artCount);\n\n        /* calculate size of wave length and offset arrays */\n        waveLenSize = (EAS_I32) (dls.waveCount * sizeof(EAS_U32));\n\n        /* calculate final memory size */\n        size = (EAS_I32) sizeof(S_EAS) + instSize + rgnPoolSize + artPoolSize + (2 * waveLenSize) + (EAS_I32) dls.wavePoolSize;\n        if (size <= 0) {\n            return EAS_ERROR_FILE_FORMAT;\n        }\n\n        /* allocate the main EAS chunk */\n        dls.pDLS = EAS_HWMalloc(dls.hwInstData, size);\n        if (dls.pDLS == NULL)\n        {\n            { /* dpp: EAS_ReportEx(_EAS_SEVERITY_ERROR, \"EAS_HWMalloc failed for DLS memory allocation size %ld\\n\", size); */ }\n            return EAS_ERROR_MALLOC_FAILED;\n        }\n        EAS_HWMemSet(dls.pDLS, 0, size);\n        dls.pDLS->refCount = 1;\n        p = PtrOfs(dls.pDLS, sizeof(S_EAS));\n\n        /* setup pointer to programs */\n        dls.pDLS->numDLSPrograms = (EAS_U16) dls.instCount;\n        dls.pDLS->pDLSPrograms = p;\n        p = PtrOfs(p, instSize);\n\n        /* setup pointer to regions */\n        dls.pDLS->pDLSRegions = p;\n        dls.pDLS->numDLSRegions = (EAS_U16) dls.regionCount;\n        p = PtrOfs(p, rgnPoolSize);\n\n        /* setup pointer to articulations */\n        dls.pDLS->numDLSArticulations = (EAS_U16) dls.artCount;\n        dls.pDLS->pDLSArticulations = p;\n        p = PtrOfs(p, artPoolSize);\n\n        /* setup pointer to wave length table */\n        dls.pDLS->numDLSSamples = (EAS_U16) dls.waveCount;\n        dls.pDLS->pDLSSampleLen = p;\n        p = PtrOfs(p, waveLenSize);\n\n        /* setup pointer to wave offsets table */\n        dls.pDLS->pDLSSampleOffsets = p;\n        p = PtrOfs(p, waveLenSize);\n\n        /* setup pointer to wave pool */\n        dls.pDLS->pDLSSamples = p;\n\n        /* clear filter flag */\n        dls.filterUsed = EAS_FALSE;\n\n        /* parse the wave pool and load samples */\n        result = Parse_ptbl(&dls, ptblPos, wvplPos, wvplSize);\n    }\n\n    /* create the default articulation */\n    if (dls.pDLS) {\n        Convert_art(&dls, &defaultArt, 0);\n        dls.artCount = 1;\n    }\n\n    /* parse the lins chunk and load instruments */\n    dls.regionCount = dls.instCount = 0;\n    if (result == EAS_SUCCESS)\n        result = Parse_lins(&dls, linsPos, linsSize);\n\n    /* clean up any temporary objects that were allocated */\n    if (dls.wsmpData)\n        EAS_HWFree(dls.hwInstData, dls.wsmpData);\n\n    /* if successful, return a pointer to the EAS collection */\n    if (result == EAS_SUCCESS)\n    {\n        *ppDLS = dls.pDLS;\n#ifdef _DEBUG_DLS\n        DumpDLS(dls.pDLS);\n#endif\n    }\n\n    /* something went wrong, deallocate the EAS collection */\n    else\n        DLSCleanup(dls.hwInstData, dls.pDLS);\n\n    return result;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -225,8 +225,10 @@\n     }\n \n     /* create the default articulation */\n-    Convert_art(&dls, &defaultArt, 0);\n-    dls.artCount = 1;\n+    if (dls.pDLS) {\n+        Convert_art(&dls, &defaultArt, 0);\n+        dls.artCount = 1;\n+    }\n \n     /* parse the lins chunk and load instruments */\n     dls.regionCount = dls.instCount = 0;",
        "diff_line_info": {
            "deleted_lines": [
                "    Convert_art(&dls, &defaultArt, 0);",
                "    dls.artCount = 1;"
            ],
            "added_lines": [
                "    if (dls.pDLS) {",
                "        Convert_art(&dls, &defaultArt, 0);",
                "        dls.artCount = 1;",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-3880",
        "func_name": "android/ASessionDescription::getFormatType",
        "description": "Multiple buffer overflows in rtsp/ASessionDescription.cpp in libstagefright in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, 6.x before 2016-09-01, and 7.0 before 2016-09-01 allow remote attackers to cause a denial of service (device hang or reboot) via a crafted media file, aka internal bug 25747670.",
        "git_url": "https://android.googlesource.com/platform/frameworks/av/+/68f67ef6cf1f41e77337be3bc4bff91f3a3c6324",
        "commit_title": "Fix corruption via buffer overflow in mediaserver",
        "commit_text": " change unbound sprintf() to snprintf() so network-provided values can't overflow the buffers.  Applicable to all K/L/M/N branches.  Bug: 25747670 ",
        "func_before": "void ASessionDescription::getFormatType(\n        size_t index, unsigned long *PT,\n        AString *desc, AString *params) const {\n    AString format;\n    getFormat(index, &format);\n\n    const char *lastSpacePos = strrchr(format.c_str(), ' ');\n    CHECK(lastSpacePos != NULL);\n\n    char *end;\n    unsigned long x = strtoul(lastSpacePos + 1, &end, 10);\n    CHECK_GT(end, lastSpacePos + 1);\n    CHECK_EQ(*end, '\\0');\n\n    *PT = x;\n\n    char key[20];\n    sprintf(key, \"a=rtpmap:%lu\", x);\n\n    CHECK(findAttribute(index, key, desc));\n\n    sprintf(key, \"a=fmtp:%lu\", x);\n    if (!findAttribute(index, key, params)) {\n        params->clear();\n    }\n}",
        "func": "void ASessionDescription::getFormatType(\n        size_t index, unsigned long *PT,\n        AString *desc, AString *params) const {\n    AString format;\n    getFormat(index, &format);\n\n    const char *lastSpacePos = strrchr(format.c_str(), ' ');\n    CHECK(lastSpacePos != NULL);\n\n    char *end;\n    unsigned long x = strtoul(lastSpacePos + 1, &end, 10);\n    CHECK_GT(end, lastSpacePos + 1);\n    CHECK_EQ(*end, '\\0');\n\n    *PT = x;\n\n    char key[32];\n    snprintf(key, sizeof(key), \"a=rtpmap:%lu\", x);\n\n    CHECK(findAttribute(index, key, desc));\n\n    snprintf(key, sizeof(key), \"a=fmtp:%lu\", x);\n    if (!findAttribute(index, key, params)) {\n        params->clear();\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -14,12 +14,12 @@\n \n     *PT = x;\n \n-    char key[20];\n-    sprintf(key, \"a=rtpmap:%lu\", x);\n+    char key[32];\n+    snprintf(key, sizeof(key), \"a=rtpmap:%lu\", x);\n \n     CHECK(findAttribute(index, key, desc));\n \n-    sprintf(key, \"a=fmtp:%lu\", x);\n+    snprintf(key, sizeof(key), \"a=fmtp:%lu\", x);\n     if (!findAttribute(index, key, params)) {\n         params->clear();\n     }",
        "diff_line_info": {
            "deleted_lines": [
                "    char key[20];",
                "    sprintf(key, \"a=rtpmap:%lu\", x);",
                "    sprintf(key, \"a=fmtp:%lu\", x);"
            ],
            "added_lines": [
                "    char key[32];",
                "    snprintf(key, sizeof(key), \"a=rtpmap:%lu\", x);",
                "    snprintf(key, sizeof(key), \"a=fmtp:%lu\", x);"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-3880",
        "func_name": "android/ASessionDescription::getDimensions",
        "description": "Multiple buffer overflows in rtsp/ASessionDescription.cpp in libstagefright in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, 6.x before 2016-09-01, and 7.0 before 2016-09-01 allow remote attackers to cause a denial of service (device hang or reboot) via a crafted media file, aka internal bug 25747670.",
        "git_url": "https://android.googlesource.com/platform/frameworks/av/+/68f67ef6cf1f41e77337be3bc4bff91f3a3c6324",
        "commit_title": "Fix corruption via buffer overflow in mediaserver",
        "commit_text": " change unbound sprintf() to snprintf() so network-provided values can't overflow the buffers.  Applicable to all K/L/M/N branches.  Bug: 25747670 ",
        "func_before": "bool ASessionDescription::getDimensions(\n        size_t index, unsigned long PT,\n        int32_t *width, int32_t *height) const {\n    *width = 0;\n    *height = 0;\n\n    char key[20];\n    sprintf(key, \"a=framesize:%lu\", PT);\n    AString value;\n    if (!findAttribute(index, key, &value)) {\n        return false;\n    }\n\n    const char *s = value.c_str();\n    char *end;\n    *width = strtoul(s, &end, 10);\n    CHECK_GT(end, s);\n    CHECK_EQ(*end, '-');\n\n    s = end + 1;\n    *height = strtoul(s, &end, 10);\n    CHECK_GT(end, s);\n    CHECK_EQ(*end, '\\0');\n\n    return true;\n}",
        "func": "bool ASessionDescription::getDimensions(\n        size_t index, unsigned long PT,\n        int32_t *width, int32_t *height) const {\n    *width = 0;\n    *height = 0;\n\n    char key[33];\n    snprintf(key, sizeof(key), \"a=framesize:%lu\", PT);\n    if (PT > 9999999) {\n        android_errorWriteLog(0x534e4554, \"25747670\");\n    }\n    AString value;\n    if (!findAttribute(index, key, &value)) {\n        return false;\n    }\n\n    const char *s = value.c_str();\n    char *end;\n    *width = strtoul(s, &end, 10);\n    CHECK_GT(end, s);\n    CHECK_EQ(*end, '-');\n\n    s = end + 1;\n    *height = strtoul(s, &end, 10);\n    CHECK_GT(end, s);\n    CHECK_EQ(*end, '\\0');\n\n    return true;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,8 +4,11 @@\n     *width = 0;\n     *height = 0;\n \n-    char key[20];\n-    sprintf(key, \"a=framesize:%lu\", PT);\n+    char key[33];\n+    snprintf(key, sizeof(key), \"a=framesize:%lu\", PT);\n+    if (PT > 9999999) {\n+        android_errorWriteLog(0x534e4554, \"25747670\");\n+    }\n     AString value;\n     if (!findAttribute(index, key, &value)) {\n         return false;",
        "diff_line_info": {
            "deleted_lines": [
                "    char key[20];",
                "    sprintf(key, \"a=framesize:%lu\", PT);"
            ],
            "added_lines": [
                "    char key[33];",
                "    snprintf(key, sizeof(key), \"a=framesize:%lu\", PT);",
                "    if (PT > 9999999) {",
                "        android_errorWriteLog(0x534e4554, \"25747670\");",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-3899",
        "func_name": "android/OMXCodec::allocateBuffersOnPort",
        "description": "OMXCodec.cpp in libstagefright in mediaserver in Android 4.x before 4.4.4, 5.0.x before 5.0.2, 5.1.x before 5.1.1, 6.x before 2016-09-01, and 7.0 before 2016-09-01 does not validate a certain pointer, which allows remote attackers to cause a denial of service (device hang or reboot) via a crafted media file, aka internal bug 29421811.",
        "git_url": "https://android.googlesource.com/platform/frameworks/av/+/97837bb6cbac21ea679843a0037779d3834bed64",
        "commit_title": "OMXCodec: check IMemory::pointer() before using allocation",
        "commit_text": " Bug: 29421811 ",
        "func_before": "status_t OMXCodec::allocateBuffersOnPort(OMX_U32 portIndex) {\n    if (mNativeWindow != NULL && portIndex == kPortIndexOutput) {\n        return allocateOutputBuffersFromNativeWindow();\n    }\n\n    if ((mFlags & kEnableGrallocUsageProtected) && portIndex == kPortIndexOutput) {\n        ALOGE(\"protected output buffers must be stent to an ANativeWindow\");\n        return PERMISSION_DENIED;\n    }\n\n    status_t err = OK;\n    if ((mFlags & kStoreMetaDataInVideoBuffers)\n            && portIndex == kPortIndexInput) {\n        err = mOMX->storeMetaDataInBuffers(mNode, kPortIndexInput, OMX_TRUE);\n        if (err != OK) {\n            ALOGE(\"Storing meta data in video buffers is not supported\");\n            return err;\n        }\n    }\n\n    OMX_PARAM_PORTDEFINITIONTYPE def;\n    InitOMXParams(&def);\n    def.nPortIndex = portIndex;\n\n    err = mOMX->getParameter(\n            mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));\n\n    if (err != OK) {\n        return err;\n    }\n\n    CODEC_LOGV(\"allocating %u buffers of size %u on %s port\",\n            def.nBufferCountActual, def.nBufferSize,\n            portIndex == kPortIndexInput ? \"input\" : \"output\");\n\n    if (def.nBufferSize != 0 && def.nBufferCountActual > SIZE_MAX / def.nBufferSize) {\n        return BAD_VALUE;\n    }\n    size_t totalSize = def.nBufferCountActual * def.nBufferSize;\n    mDealer[portIndex] = new MemoryDealer(totalSize, \"OMXCodec\");\n\n    for (OMX_U32 i = 0; i < def.nBufferCountActual; ++i) {\n        sp<IMemory> mem = mDealer[portIndex]->allocate(def.nBufferSize);\n        CHECK(mem.get() != NULL);\n\n        BufferInfo info;\n        info.mData = NULL;\n        info.mSize = def.nBufferSize;\n\n        IOMX::buffer_id buffer;\n        if (portIndex == kPortIndexInput\n                && ((mQuirks & kRequiresAllocateBufferOnInputPorts)\n                    || (mFlags & kUseSecureInputBuffers))) {\n            if (mOMXLivesLocally) {\n                mem.clear();\n\n                err = mOMX->allocateBuffer(\n                        mNode, portIndex, def.nBufferSize, &buffer,\n                        &info.mData);\n            } else {\n                err = mOMX->allocateBufferWithBackup(\n                        mNode, portIndex, mem, &buffer, mem->size());\n            }\n        } else if (portIndex == kPortIndexOutput\n                && (mQuirks & kRequiresAllocateBufferOnOutputPorts)) {\n            if (mOMXLivesLocally) {\n                mem.clear();\n\n                err = mOMX->allocateBuffer(\n                        mNode, portIndex, def.nBufferSize, &buffer,\n                        &info.mData);\n            } else {\n                err = mOMX->allocateBufferWithBackup(\n                        mNode, portIndex, mem, &buffer, mem->size());\n            }\n        } else {\n            err = mOMX->useBuffer(mNode, portIndex, mem, &buffer, mem->size());\n        }\n\n        if (err != OK) {\n            ALOGE(\"allocate_buffer_with_backup failed\");\n            return err;\n        }\n\n        if (mem != NULL) {\n            info.mData = mem->pointer();\n        }\n\n        info.mBuffer = buffer;\n        info.mStatus = OWNED_BY_US;\n        info.mMem = mem;\n        info.mMediaBuffer = NULL;\n\n        if (portIndex == kPortIndexOutput) {\n            // Fail deferred MediaBuffer creation until FILL_BUFFER_DONE;\n            // this legacy mode is no longer supported.\n            LOG_ALWAYS_FATAL_IF((mOMXLivesLocally\n                    && (mQuirks & kRequiresAllocateBufferOnOutputPorts)\n                    && (mQuirks & kDefersOutputBufferAllocation)),\n                    \"allocateBuffersOnPort cannot defer buffer allocation\");\n\n            info.mMediaBuffer = new MediaBuffer(info.mData, info.mSize);\n            info.mMediaBuffer->setObserver(this);\n        }\n\n        mPortBuffers[portIndex].push(info);\n\n        CODEC_LOGV(\"allocated buffer %u on %s port\", buffer,\n             portIndex == kPortIndexInput ? \"input\" : \"output\");\n    }\n\n    if (portIndex == kPortIndexOutput) {\n\n        sp<MetaData> meta = mSource->getFormat();\n        int32_t delay = 0;\n        if (!meta->findInt32(kKeyEncoderDelay, &delay)) {\n            delay = 0;\n        }\n        int32_t padding = 0;\n        if (!meta->findInt32(kKeyEncoderPadding, &padding)) {\n            padding = 0;\n        }\n        int32_t numchannels = 0;\n        if (delay + padding) {\n            if (mOutputFormat->findInt32(kKeyChannelCount, &numchannels)) {\n                size_t frameSize = numchannels * sizeof(int16_t);\n                if (mSkipCutBuffer != NULL) {\n                    size_t prevbuffersize = mSkipCutBuffer->size();\n                    if (prevbuffersize != 0) {\n                        ALOGW(\"Replacing SkipCutBuffer holding %zu bytes\", prevbuffersize);\n                    }\n                }\n                mSkipCutBuffer = new SkipCutBuffer(delay * frameSize, padding * frameSize);\n            }\n        }\n    }\n\n    // dumpPortStatus(portIndex);\n\n    if (portIndex == kPortIndexInput && (mFlags & kUseSecureInputBuffers)) {\n        Vector<MediaBuffer *> buffers;\n        for (size_t i = 0; i < def.nBufferCountActual; ++i) {\n            const BufferInfo &info = mPortBuffers[kPortIndexInput].itemAt(i);\n\n            MediaBuffer *mbuf = new MediaBuffer(info.mData, info.mSize);\n            buffers.push(mbuf);\n        }\n\n        status_t err = mSource->setBuffers(buffers);\n\n        if (err != OK) {\n            for (size_t i = 0; i < def.nBufferCountActual; ++i) {\n                buffers.editItemAt(i)->release();\n            }\n            buffers.clear();\n\n            CODEC_LOGE(\n                    \"Codec requested to use secure input buffers but \"\n                    \"upstream source didn't support that.\");\n\n            return err;\n        }\n    }\n\n    return OK;\n}",
        "func": "status_t OMXCodec::allocateBuffersOnPort(OMX_U32 portIndex) {\n    if (mNativeWindow != NULL && portIndex == kPortIndexOutput) {\n        return allocateOutputBuffersFromNativeWindow();\n    }\n\n    if ((mFlags & kEnableGrallocUsageProtected) && portIndex == kPortIndexOutput) {\n        ALOGE(\"protected output buffers must be stent to an ANativeWindow\");\n        return PERMISSION_DENIED;\n    }\n\n    status_t err = OK;\n    if ((mFlags & kStoreMetaDataInVideoBuffers)\n            && portIndex == kPortIndexInput) {\n        err = mOMX->storeMetaDataInBuffers(mNode, kPortIndexInput, OMX_TRUE);\n        if (err != OK) {\n            ALOGE(\"Storing meta data in video buffers is not supported\");\n            return err;\n        }\n    }\n\n    OMX_PARAM_PORTDEFINITIONTYPE def;\n    InitOMXParams(&def);\n    def.nPortIndex = portIndex;\n\n    err = mOMX->getParameter(\n            mNode, OMX_IndexParamPortDefinition, &def, sizeof(def));\n\n    if (err != OK) {\n        return err;\n    }\n\n    CODEC_LOGV(\"allocating %u buffers of size %u on %s port\",\n            def.nBufferCountActual, def.nBufferSize,\n            portIndex == kPortIndexInput ? \"input\" : \"output\");\n\n    if (def.nBufferSize != 0 && def.nBufferCountActual > SIZE_MAX / def.nBufferSize) {\n        return BAD_VALUE;\n    }\n    size_t totalSize = def.nBufferCountActual * def.nBufferSize;\n    mDealer[portIndex] = new MemoryDealer(totalSize, \"OMXCodec\");\n\n    for (OMX_U32 i = 0; i < def.nBufferCountActual; ++i) {\n        sp<IMemory> mem = mDealer[portIndex]->allocate(def.nBufferSize);\n        if (mem == NULL || mem->pointer() == NULL) {\n            return NO_MEMORY;\n        }\n\n        BufferInfo info;\n        info.mData = NULL;\n        info.mSize = def.nBufferSize;\n\n        IOMX::buffer_id buffer;\n        if (portIndex == kPortIndexInput\n                && ((mQuirks & kRequiresAllocateBufferOnInputPorts)\n                    || (mFlags & kUseSecureInputBuffers))) {\n            if (mOMXLivesLocally) {\n                mem.clear();\n\n                err = mOMX->allocateBuffer(\n                        mNode, portIndex, def.nBufferSize, &buffer,\n                        &info.mData);\n            } else {\n                err = mOMX->allocateBufferWithBackup(\n                        mNode, portIndex, mem, &buffer, mem->size());\n            }\n        } else if (portIndex == kPortIndexOutput\n                && (mQuirks & kRequiresAllocateBufferOnOutputPorts)) {\n            if (mOMXLivesLocally) {\n                mem.clear();\n\n                err = mOMX->allocateBuffer(\n                        mNode, portIndex, def.nBufferSize, &buffer,\n                        &info.mData);\n            } else {\n                err = mOMX->allocateBufferWithBackup(\n                        mNode, portIndex, mem, &buffer, mem->size());\n            }\n        } else {\n            err = mOMX->useBuffer(mNode, portIndex, mem, &buffer, mem->size());\n        }\n\n        if (err != OK) {\n            ALOGE(\"allocate_buffer_with_backup failed\");\n            return err;\n        }\n\n        if (mem != NULL) {\n            info.mData = mem->pointer();\n        }\n\n        info.mBuffer = buffer;\n        info.mStatus = OWNED_BY_US;\n        info.mMem = mem;\n        info.mMediaBuffer = NULL;\n\n        if (portIndex == kPortIndexOutput) {\n            // Fail deferred MediaBuffer creation until FILL_BUFFER_DONE;\n            // this legacy mode is no longer supported.\n            LOG_ALWAYS_FATAL_IF((mOMXLivesLocally\n                    && (mQuirks & kRequiresAllocateBufferOnOutputPorts)\n                    && (mQuirks & kDefersOutputBufferAllocation)),\n                    \"allocateBuffersOnPort cannot defer buffer allocation\");\n\n            info.mMediaBuffer = new MediaBuffer(info.mData, info.mSize);\n            info.mMediaBuffer->setObserver(this);\n        }\n\n        mPortBuffers[portIndex].push(info);\n\n        CODEC_LOGV(\"allocated buffer %u on %s port\", buffer,\n             portIndex == kPortIndexInput ? \"input\" : \"output\");\n    }\n\n    if (portIndex == kPortIndexOutput) {\n\n        sp<MetaData> meta = mSource->getFormat();\n        int32_t delay = 0;\n        if (!meta->findInt32(kKeyEncoderDelay, &delay)) {\n            delay = 0;\n        }\n        int32_t padding = 0;\n        if (!meta->findInt32(kKeyEncoderPadding, &padding)) {\n            padding = 0;\n        }\n        int32_t numchannels = 0;\n        if (delay + padding) {\n            if (mOutputFormat->findInt32(kKeyChannelCount, &numchannels)) {\n                size_t frameSize = numchannels * sizeof(int16_t);\n                if (mSkipCutBuffer != NULL) {\n                    size_t prevbuffersize = mSkipCutBuffer->size();\n                    if (prevbuffersize != 0) {\n                        ALOGW(\"Replacing SkipCutBuffer holding %zu bytes\", prevbuffersize);\n                    }\n                }\n                mSkipCutBuffer = new SkipCutBuffer(delay * frameSize, padding * frameSize);\n            }\n        }\n    }\n\n    // dumpPortStatus(portIndex);\n\n    if (portIndex == kPortIndexInput && (mFlags & kUseSecureInputBuffers)) {\n        Vector<MediaBuffer *> buffers;\n        for (size_t i = 0; i < def.nBufferCountActual; ++i) {\n            const BufferInfo &info = mPortBuffers[kPortIndexInput].itemAt(i);\n\n            MediaBuffer *mbuf = new MediaBuffer(info.mData, info.mSize);\n            buffers.push(mbuf);\n        }\n\n        status_t err = mSource->setBuffers(buffers);\n\n        if (err != OK) {\n            for (size_t i = 0; i < def.nBufferCountActual; ++i) {\n                buffers.editItemAt(i)->release();\n            }\n            buffers.clear();\n\n            CODEC_LOGE(\n                    \"Codec requested to use secure input buffers but \"\n                    \"upstream source didn't support that.\");\n\n            return err;\n        }\n    }\n\n    return OK;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -41,7 +41,9 @@\n \n     for (OMX_U32 i = 0; i < def.nBufferCountActual; ++i) {\n         sp<IMemory> mem = mDealer[portIndex]->allocate(def.nBufferSize);\n-        CHECK(mem.get() != NULL);\n+        if (mem == NULL || mem->pointer() == NULL) {\n+            return NO_MEMORY;\n+        }\n \n         BufferInfo info;\n         info.mData = NULL;",
        "diff_line_info": {
            "deleted_lines": [
                "        CHECK(mem.get() != NULL);"
            ],
            "added_lines": [
                "        if (mem == NULL || mem->pointer() == NULL) {",
                "            return NO_MEMORY;",
                "        }"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-9190",
        "func_name": "python-pillow/Pillow/ImagingNew",
        "description": "Pillow before 3.3.2 allows context-dependent attackers to execute arbitrary code by using the \"crafted image file\" approach, related to an \"Insecure Sign Extension\" issue affecting the ImagingNew in Storage.c component.",
        "git_url": "https://github.com/python-pillow/Pillow/commit/5d8a0be45aad78c5a22c8d099118ee26ef8144af",
        "commit_title": "Memory error in Storage.c when accepting negative image size arguments",
        "commit_text": "",
        "func_before": "Imaging\nImagingNew(const char* mode, int xsize, int ysize)\n{\n    int bytes;\n    Imaging im;\n\n    if (strlen(mode) == 1) {\n        if (mode[0] == 'F' || mode[0] == 'I')\n            bytes = 4;\n        else\n            bytes = 1;\n    } else\n        bytes = strlen(mode); /* close enough */\n\n    if ((int64_t) xsize * (int64_t) ysize <= THRESHOLD / bytes) {\n        im = ImagingNewBlock(mode, xsize, ysize);\n        if (im)\n            return im;\n        /* assume memory error; try allocating in array mode instead */\n        ImagingError_Clear();\n    }\n\n    return ImagingNewArray(mode, xsize, ysize);\n}",
        "func": "Imaging\nImagingNew(const char* mode, int xsize, int ysize)\n{\n    int bytes;\n    Imaging im;\n\n    if (strlen(mode) == 1) {\n        if (mode[0] == 'F' || mode[0] == 'I')\n            bytes = 4;\n        else\n            bytes = 1;\n    } else\n        bytes = strlen(mode); /* close enough */\n\n    if (xsize < 0 || ysize < 0) {\n        return (Imaging) ImagingError_ValueError(\"bad image size\");\n    }\n\n    if ((int64_t) xsize * (int64_t) ysize <= THRESHOLD / bytes) {\n        im = ImagingNewBlock(mode, xsize, ysize);\n        if (im)\n            return im;\n        /* assume memory error; try allocating in array mode instead */\n        ImagingError_Clear();\n    }\n\n    return ImagingNewArray(mode, xsize, ysize);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -12,6 +12,10 @@\n     } else\n         bytes = strlen(mode); /* close enough */\n \n+    if (xsize < 0 || ysize < 0) {\n+        return (Imaging) ImagingError_ValueError(\"bad image size\");\n+    }\n+\n     if ((int64_t) xsize * (int64_t) ysize <= THRESHOLD / bytes) {\n         im = ImagingNewBlock(mode, xsize, ysize);\n         if (im)",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    if (xsize < 0 || ysize < 0) {",
                "        return (Imaging) ImagingError_ValueError(\"bad image size\");",
                "    }",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2016-8630",
        "func_name": "torvalds/linux/x86_decode_insn",
        "description": "The x86_decode_insn function in arch/x86/kvm/emulate.c in the Linux kernel before 4.8.7, when KVM is enabled, allows local users to cause a denial of service (host OS crash) via a certain use of a ModR/M byte in an undefined instruction.",
        "git_url": "https://github.com/torvalds/linux/commit/d9092f52d7e61dd1557f2db2400ddb430e85937e",
        "commit_title": "kvm: x86: Check memopp before dereference (CVE-2016-8630)",
        "commit_text": " Commit 41061cdb98 (\"KVM: emulate: do not initialize memopp\") removes a check for non-NULL under incorrect assumptions. An undefined instruction with a ModR/M byte with Mod=0 and R/M-5 (e.g. 0xc7 0x15) will attempt to dereference a null pointer here.  Message-Id: <1477592752-126650-2-git-send-email-osh@google.com>",
        "func_before": "int x86_decode_insn(struct x86_emulate_ctxt *ctxt, void *insn, int insn_len)\n{\n\tint rc = X86EMUL_CONTINUE;\n\tint mode = ctxt->mode;\n\tint def_op_bytes, def_ad_bytes, goffset, simd_prefix;\n\tbool op_prefix = false;\n\tbool has_seg_override = false;\n\tstruct opcode opcode;\n\n\tctxt->memop.type = OP_NONE;\n\tctxt->memopp = NULL;\n\tctxt->_eip = ctxt->eip;\n\tctxt->fetch.ptr = ctxt->fetch.data;\n\tctxt->fetch.end = ctxt->fetch.data + insn_len;\n\tctxt->opcode_len = 1;\n\tif (insn_len > 0)\n\t\tmemcpy(ctxt->fetch.data, insn, insn_len);\n\telse {\n\t\trc = __do_insn_fetch_bytes(ctxt, 1);\n\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\treturn rc;\n\t}\n\n\tswitch (mode) {\n\tcase X86EMUL_MODE_REAL:\n\tcase X86EMUL_MODE_VM86:\n\tcase X86EMUL_MODE_PROT16:\n\t\tdef_op_bytes = def_ad_bytes = 2;\n\t\tbreak;\n\tcase X86EMUL_MODE_PROT32:\n\t\tdef_op_bytes = def_ad_bytes = 4;\n\t\tbreak;\n#ifdef CONFIG_X86_64\n\tcase X86EMUL_MODE_PROT64:\n\t\tdef_op_bytes = 4;\n\t\tdef_ad_bytes = 8;\n\t\tbreak;\n#endif\n\tdefault:\n\t\treturn EMULATION_FAILED;\n\t}\n\n\tctxt->op_bytes = def_op_bytes;\n\tctxt->ad_bytes = def_ad_bytes;\n\n\t/* Legacy prefixes. */\n\tfor (;;) {\n\t\tswitch (ctxt->b = insn_fetch(u8, ctxt)) {\n\t\tcase 0x66:\t/* operand-size override */\n\t\t\top_prefix = true;\n\t\t\t/* switch between 2/4 bytes */\n\t\t\tctxt->op_bytes = def_op_bytes ^ 6;\n\t\t\tbreak;\n\t\tcase 0x67:\t/* address-size override */\n\t\t\tif (mode == X86EMUL_MODE_PROT64)\n\t\t\t\t/* switch between 4/8 bytes */\n\t\t\t\tctxt->ad_bytes = def_ad_bytes ^ 12;\n\t\t\telse\n\t\t\t\t/* switch between 2/4 bytes */\n\t\t\t\tctxt->ad_bytes = def_ad_bytes ^ 6;\n\t\t\tbreak;\n\t\tcase 0x26:\t/* ES override */\n\t\tcase 0x2e:\t/* CS override */\n\t\tcase 0x36:\t/* SS override */\n\t\tcase 0x3e:\t/* DS override */\n\t\t\thas_seg_override = true;\n\t\t\tctxt->seg_override = (ctxt->b >> 3) & 3;\n\t\t\tbreak;\n\t\tcase 0x64:\t/* FS override */\n\t\tcase 0x65:\t/* GS override */\n\t\t\thas_seg_override = true;\n\t\t\tctxt->seg_override = ctxt->b & 7;\n\t\t\tbreak;\n\t\tcase 0x40 ... 0x4f: /* REX */\n\t\t\tif (mode != X86EMUL_MODE_PROT64)\n\t\t\t\tgoto done_prefixes;\n\t\t\tctxt->rex_prefix = ctxt->b;\n\t\t\tcontinue;\n\t\tcase 0xf0:\t/* LOCK */\n\t\t\tctxt->lock_prefix = 1;\n\t\t\tbreak;\n\t\tcase 0xf2:\t/* REPNE/REPNZ */\n\t\tcase 0xf3:\t/* REP/REPE/REPZ */\n\t\t\tctxt->rep_prefix = ctxt->b;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto done_prefixes;\n\t\t}\n\n\t\t/* Any legacy prefix after a REX prefix nullifies its effect. */\n\n\t\tctxt->rex_prefix = 0;\n\t}\n\ndone_prefixes:\n\n\t/* REX prefix. */\n\tif (ctxt->rex_prefix & 8)\n\t\tctxt->op_bytes = 8;\t/* REX.W */\n\n\t/* Opcode byte(s). */\n\topcode = opcode_table[ctxt->b];\n\t/* Two-byte opcode? */\n\tif (ctxt->b == 0x0f) {\n\t\tctxt->opcode_len = 2;\n\t\tctxt->b = insn_fetch(u8, ctxt);\n\t\topcode = twobyte_table[ctxt->b];\n\n\t\t/* 0F_38 opcode map */\n\t\tif (ctxt->b == 0x38) {\n\t\t\tctxt->opcode_len = 3;\n\t\t\tctxt->b = insn_fetch(u8, ctxt);\n\t\t\topcode = opcode_map_0f_38[ctxt->b];\n\t\t}\n\t}\n\tctxt->d = opcode.flags;\n\n\tif (ctxt->d & ModRM)\n\t\tctxt->modrm = insn_fetch(u8, ctxt);\n\n\t/* vex-prefix instructions are not implemented */\n\tif (ctxt->opcode_len == 1 && (ctxt->b == 0xc5 || ctxt->b == 0xc4) &&\n\t    (mode == X86EMUL_MODE_PROT64 || (ctxt->modrm & 0xc0) == 0xc0)) {\n\t\tctxt->d = NotImpl;\n\t}\n\n\twhile (ctxt->d & GroupMask) {\n\t\tswitch (ctxt->d & GroupMask) {\n\t\tcase Group:\n\t\t\tgoffset = (ctxt->modrm >> 3) & 7;\n\t\t\topcode = opcode.u.group[goffset];\n\t\t\tbreak;\n\t\tcase GroupDual:\n\t\t\tgoffset = (ctxt->modrm >> 3) & 7;\n\t\t\tif ((ctxt->modrm >> 6) == 3)\n\t\t\t\topcode = opcode.u.gdual->mod3[goffset];\n\t\t\telse\n\t\t\t\topcode = opcode.u.gdual->mod012[goffset];\n\t\t\tbreak;\n\t\tcase RMExt:\n\t\t\tgoffset = ctxt->modrm & 7;\n\t\t\topcode = opcode.u.group[goffset];\n\t\t\tbreak;\n\t\tcase Prefix:\n\t\t\tif (ctxt->rep_prefix && op_prefix)\n\t\t\t\treturn EMULATION_FAILED;\n\t\t\tsimd_prefix = op_prefix ? 0x66 : ctxt->rep_prefix;\n\t\t\tswitch (simd_prefix) {\n\t\t\tcase 0x00: opcode = opcode.u.gprefix->pfx_no; break;\n\t\t\tcase 0x66: opcode = opcode.u.gprefix->pfx_66; break;\n\t\t\tcase 0xf2: opcode = opcode.u.gprefix->pfx_f2; break;\n\t\t\tcase 0xf3: opcode = opcode.u.gprefix->pfx_f3; break;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Escape:\n\t\t\tif (ctxt->modrm > 0xbf)\n\t\t\t\topcode = opcode.u.esc->high[ctxt->modrm - 0xc0];\n\t\t\telse\n\t\t\t\topcode = opcode.u.esc->op[(ctxt->modrm >> 3) & 7];\n\t\t\tbreak;\n\t\tcase InstrDual:\n\t\t\tif ((ctxt->modrm >> 6) == 3)\n\t\t\t\topcode = opcode.u.idual->mod3;\n\t\t\telse\n\t\t\t\topcode = opcode.u.idual->mod012;\n\t\t\tbreak;\n\t\tcase ModeDual:\n\t\t\tif (ctxt->mode == X86EMUL_MODE_PROT64)\n\t\t\t\topcode = opcode.u.mdual->mode64;\n\t\t\telse\n\t\t\t\topcode = opcode.u.mdual->mode32;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn EMULATION_FAILED;\n\t\t}\n\n\t\tctxt->d &= ~(u64)GroupMask;\n\t\tctxt->d |= opcode.flags;\n\t}\n\n\t/* Unrecognised? */\n\tif (ctxt->d == 0)\n\t\treturn EMULATION_FAILED;\n\n\tctxt->execute = opcode.u.execute;\n\n\tif (unlikely(ctxt->ud) && likely(!(ctxt->d & EmulateOnUD)))\n\t\treturn EMULATION_FAILED;\n\n\tif (unlikely(ctxt->d &\n\t    (NotImpl|Stack|Op3264|Sse|Mmx|Intercept|CheckPerm|NearBranch|\n\t     No16))) {\n\t\t/*\n\t\t * These are copied unconditionally here, and checked unconditionally\n\t\t * in x86_emulate_insn.\n\t\t */\n\t\tctxt->check_perm = opcode.check_perm;\n\t\tctxt->intercept = opcode.intercept;\n\n\t\tif (ctxt->d & NotImpl)\n\t\t\treturn EMULATION_FAILED;\n\n\t\tif (mode == X86EMUL_MODE_PROT64) {\n\t\t\tif (ctxt->op_bytes == 4 && (ctxt->d & Stack))\n\t\t\t\tctxt->op_bytes = 8;\n\t\t\telse if (ctxt->d & NearBranch)\n\t\t\t\tctxt->op_bytes = 8;\n\t\t}\n\n\t\tif (ctxt->d & Op3264) {\n\t\t\tif (mode == X86EMUL_MODE_PROT64)\n\t\t\t\tctxt->op_bytes = 8;\n\t\t\telse\n\t\t\t\tctxt->op_bytes = 4;\n\t\t}\n\n\t\tif ((ctxt->d & No16) && ctxt->op_bytes == 2)\n\t\t\tctxt->op_bytes = 4;\n\n\t\tif (ctxt->d & Sse)\n\t\t\tctxt->op_bytes = 16;\n\t\telse if (ctxt->d & Mmx)\n\t\t\tctxt->op_bytes = 8;\n\t}\n\n\t/* ModRM and SIB bytes. */\n\tif (ctxt->d & ModRM) {\n\t\trc = decode_modrm(ctxt, &ctxt->memop);\n\t\tif (!has_seg_override) {\n\t\t\thas_seg_override = true;\n\t\t\tctxt->seg_override = ctxt->modrm_seg;\n\t\t}\n\t} else if (ctxt->d & MemAbs)\n\t\trc = decode_abs(ctxt, &ctxt->memop);\n\tif (rc != X86EMUL_CONTINUE)\n\t\tgoto done;\n\n\tif (!has_seg_override)\n\t\tctxt->seg_override = VCPU_SREG_DS;\n\n\tctxt->memop.addr.mem.seg = ctxt->seg_override;\n\n\t/*\n\t * Decode and fetch the source operand: register, memory\n\t * or immediate.\n\t */\n\trc = decode_operand(ctxt, &ctxt->src, (ctxt->d >> SrcShift) & OpMask);\n\tif (rc != X86EMUL_CONTINUE)\n\t\tgoto done;\n\n\t/*\n\t * Decode and fetch the second source operand: register, memory\n\t * or immediate.\n\t */\n\trc = decode_operand(ctxt, &ctxt->src2, (ctxt->d >> Src2Shift) & OpMask);\n\tif (rc != X86EMUL_CONTINUE)\n\t\tgoto done;\n\n\t/* Decode and fetch the destination operand: register or memory. */\n\trc = decode_operand(ctxt, &ctxt->dst, (ctxt->d >> DstShift) & OpMask);\n\n\tif (ctxt->rip_relative)\n\t\tctxt->memopp->addr.mem.ea = address_mask(ctxt,\n\t\t\t\t\tctxt->memopp->addr.mem.ea + ctxt->_eip);\n\ndone:\n\treturn (rc != X86EMUL_CONTINUE) ? EMULATION_FAILED : EMULATION_OK;\n}",
        "func": "int x86_decode_insn(struct x86_emulate_ctxt *ctxt, void *insn, int insn_len)\n{\n\tint rc = X86EMUL_CONTINUE;\n\tint mode = ctxt->mode;\n\tint def_op_bytes, def_ad_bytes, goffset, simd_prefix;\n\tbool op_prefix = false;\n\tbool has_seg_override = false;\n\tstruct opcode opcode;\n\n\tctxt->memop.type = OP_NONE;\n\tctxt->memopp = NULL;\n\tctxt->_eip = ctxt->eip;\n\tctxt->fetch.ptr = ctxt->fetch.data;\n\tctxt->fetch.end = ctxt->fetch.data + insn_len;\n\tctxt->opcode_len = 1;\n\tif (insn_len > 0)\n\t\tmemcpy(ctxt->fetch.data, insn, insn_len);\n\telse {\n\t\trc = __do_insn_fetch_bytes(ctxt, 1);\n\t\tif (rc != X86EMUL_CONTINUE)\n\t\t\treturn rc;\n\t}\n\n\tswitch (mode) {\n\tcase X86EMUL_MODE_REAL:\n\tcase X86EMUL_MODE_VM86:\n\tcase X86EMUL_MODE_PROT16:\n\t\tdef_op_bytes = def_ad_bytes = 2;\n\t\tbreak;\n\tcase X86EMUL_MODE_PROT32:\n\t\tdef_op_bytes = def_ad_bytes = 4;\n\t\tbreak;\n#ifdef CONFIG_X86_64\n\tcase X86EMUL_MODE_PROT64:\n\t\tdef_op_bytes = 4;\n\t\tdef_ad_bytes = 8;\n\t\tbreak;\n#endif\n\tdefault:\n\t\treturn EMULATION_FAILED;\n\t}\n\n\tctxt->op_bytes = def_op_bytes;\n\tctxt->ad_bytes = def_ad_bytes;\n\n\t/* Legacy prefixes. */\n\tfor (;;) {\n\t\tswitch (ctxt->b = insn_fetch(u8, ctxt)) {\n\t\tcase 0x66:\t/* operand-size override */\n\t\t\top_prefix = true;\n\t\t\t/* switch between 2/4 bytes */\n\t\t\tctxt->op_bytes = def_op_bytes ^ 6;\n\t\t\tbreak;\n\t\tcase 0x67:\t/* address-size override */\n\t\t\tif (mode == X86EMUL_MODE_PROT64)\n\t\t\t\t/* switch between 4/8 bytes */\n\t\t\t\tctxt->ad_bytes = def_ad_bytes ^ 12;\n\t\t\telse\n\t\t\t\t/* switch between 2/4 bytes */\n\t\t\t\tctxt->ad_bytes = def_ad_bytes ^ 6;\n\t\t\tbreak;\n\t\tcase 0x26:\t/* ES override */\n\t\tcase 0x2e:\t/* CS override */\n\t\tcase 0x36:\t/* SS override */\n\t\tcase 0x3e:\t/* DS override */\n\t\t\thas_seg_override = true;\n\t\t\tctxt->seg_override = (ctxt->b >> 3) & 3;\n\t\t\tbreak;\n\t\tcase 0x64:\t/* FS override */\n\t\tcase 0x65:\t/* GS override */\n\t\t\thas_seg_override = true;\n\t\t\tctxt->seg_override = ctxt->b & 7;\n\t\t\tbreak;\n\t\tcase 0x40 ... 0x4f: /* REX */\n\t\t\tif (mode != X86EMUL_MODE_PROT64)\n\t\t\t\tgoto done_prefixes;\n\t\t\tctxt->rex_prefix = ctxt->b;\n\t\t\tcontinue;\n\t\tcase 0xf0:\t/* LOCK */\n\t\t\tctxt->lock_prefix = 1;\n\t\t\tbreak;\n\t\tcase 0xf2:\t/* REPNE/REPNZ */\n\t\tcase 0xf3:\t/* REP/REPE/REPZ */\n\t\t\tctxt->rep_prefix = ctxt->b;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tgoto done_prefixes;\n\t\t}\n\n\t\t/* Any legacy prefix after a REX prefix nullifies its effect. */\n\n\t\tctxt->rex_prefix = 0;\n\t}\n\ndone_prefixes:\n\n\t/* REX prefix. */\n\tif (ctxt->rex_prefix & 8)\n\t\tctxt->op_bytes = 8;\t/* REX.W */\n\n\t/* Opcode byte(s). */\n\topcode = opcode_table[ctxt->b];\n\t/* Two-byte opcode? */\n\tif (ctxt->b == 0x0f) {\n\t\tctxt->opcode_len = 2;\n\t\tctxt->b = insn_fetch(u8, ctxt);\n\t\topcode = twobyte_table[ctxt->b];\n\n\t\t/* 0F_38 opcode map */\n\t\tif (ctxt->b == 0x38) {\n\t\t\tctxt->opcode_len = 3;\n\t\t\tctxt->b = insn_fetch(u8, ctxt);\n\t\t\topcode = opcode_map_0f_38[ctxt->b];\n\t\t}\n\t}\n\tctxt->d = opcode.flags;\n\n\tif (ctxt->d & ModRM)\n\t\tctxt->modrm = insn_fetch(u8, ctxt);\n\n\t/* vex-prefix instructions are not implemented */\n\tif (ctxt->opcode_len == 1 && (ctxt->b == 0xc5 || ctxt->b == 0xc4) &&\n\t    (mode == X86EMUL_MODE_PROT64 || (ctxt->modrm & 0xc0) == 0xc0)) {\n\t\tctxt->d = NotImpl;\n\t}\n\n\twhile (ctxt->d & GroupMask) {\n\t\tswitch (ctxt->d & GroupMask) {\n\t\tcase Group:\n\t\t\tgoffset = (ctxt->modrm >> 3) & 7;\n\t\t\topcode = opcode.u.group[goffset];\n\t\t\tbreak;\n\t\tcase GroupDual:\n\t\t\tgoffset = (ctxt->modrm >> 3) & 7;\n\t\t\tif ((ctxt->modrm >> 6) == 3)\n\t\t\t\topcode = opcode.u.gdual->mod3[goffset];\n\t\t\telse\n\t\t\t\topcode = opcode.u.gdual->mod012[goffset];\n\t\t\tbreak;\n\t\tcase RMExt:\n\t\t\tgoffset = ctxt->modrm & 7;\n\t\t\topcode = opcode.u.group[goffset];\n\t\t\tbreak;\n\t\tcase Prefix:\n\t\t\tif (ctxt->rep_prefix && op_prefix)\n\t\t\t\treturn EMULATION_FAILED;\n\t\t\tsimd_prefix = op_prefix ? 0x66 : ctxt->rep_prefix;\n\t\t\tswitch (simd_prefix) {\n\t\t\tcase 0x00: opcode = opcode.u.gprefix->pfx_no; break;\n\t\t\tcase 0x66: opcode = opcode.u.gprefix->pfx_66; break;\n\t\t\tcase 0xf2: opcode = opcode.u.gprefix->pfx_f2; break;\n\t\t\tcase 0xf3: opcode = opcode.u.gprefix->pfx_f3; break;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Escape:\n\t\t\tif (ctxt->modrm > 0xbf)\n\t\t\t\topcode = opcode.u.esc->high[ctxt->modrm - 0xc0];\n\t\t\telse\n\t\t\t\topcode = opcode.u.esc->op[(ctxt->modrm >> 3) & 7];\n\t\t\tbreak;\n\t\tcase InstrDual:\n\t\t\tif ((ctxt->modrm >> 6) == 3)\n\t\t\t\topcode = opcode.u.idual->mod3;\n\t\t\telse\n\t\t\t\topcode = opcode.u.idual->mod012;\n\t\t\tbreak;\n\t\tcase ModeDual:\n\t\t\tif (ctxt->mode == X86EMUL_MODE_PROT64)\n\t\t\t\topcode = opcode.u.mdual->mode64;\n\t\t\telse\n\t\t\t\topcode = opcode.u.mdual->mode32;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn EMULATION_FAILED;\n\t\t}\n\n\t\tctxt->d &= ~(u64)GroupMask;\n\t\tctxt->d |= opcode.flags;\n\t}\n\n\t/* Unrecognised? */\n\tif (ctxt->d == 0)\n\t\treturn EMULATION_FAILED;\n\n\tctxt->execute = opcode.u.execute;\n\n\tif (unlikely(ctxt->ud) && likely(!(ctxt->d & EmulateOnUD)))\n\t\treturn EMULATION_FAILED;\n\n\tif (unlikely(ctxt->d &\n\t    (NotImpl|Stack|Op3264|Sse|Mmx|Intercept|CheckPerm|NearBranch|\n\t     No16))) {\n\t\t/*\n\t\t * These are copied unconditionally here, and checked unconditionally\n\t\t * in x86_emulate_insn.\n\t\t */\n\t\tctxt->check_perm = opcode.check_perm;\n\t\tctxt->intercept = opcode.intercept;\n\n\t\tif (ctxt->d & NotImpl)\n\t\t\treturn EMULATION_FAILED;\n\n\t\tif (mode == X86EMUL_MODE_PROT64) {\n\t\t\tif (ctxt->op_bytes == 4 && (ctxt->d & Stack))\n\t\t\t\tctxt->op_bytes = 8;\n\t\t\telse if (ctxt->d & NearBranch)\n\t\t\t\tctxt->op_bytes = 8;\n\t\t}\n\n\t\tif (ctxt->d & Op3264) {\n\t\t\tif (mode == X86EMUL_MODE_PROT64)\n\t\t\t\tctxt->op_bytes = 8;\n\t\t\telse\n\t\t\t\tctxt->op_bytes = 4;\n\t\t}\n\n\t\tif ((ctxt->d & No16) && ctxt->op_bytes == 2)\n\t\t\tctxt->op_bytes = 4;\n\n\t\tif (ctxt->d & Sse)\n\t\t\tctxt->op_bytes = 16;\n\t\telse if (ctxt->d & Mmx)\n\t\t\tctxt->op_bytes = 8;\n\t}\n\n\t/* ModRM and SIB bytes. */\n\tif (ctxt->d & ModRM) {\n\t\trc = decode_modrm(ctxt, &ctxt->memop);\n\t\tif (!has_seg_override) {\n\t\t\thas_seg_override = true;\n\t\t\tctxt->seg_override = ctxt->modrm_seg;\n\t\t}\n\t} else if (ctxt->d & MemAbs)\n\t\trc = decode_abs(ctxt, &ctxt->memop);\n\tif (rc != X86EMUL_CONTINUE)\n\t\tgoto done;\n\n\tif (!has_seg_override)\n\t\tctxt->seg_override = VCPU_SREG_DS;\n\n\tctxt->memop.addr.mem.seg = ctxt->seg_override;\n\n\t/*\n\t * Decode and fetch the source operand: register, memory\n\t * or immediate.\n\t */\n\trc = decode_operand(ctxt, &ctxt->src, (ctxt->d >> SrcShift) & OpMask);\n\tif (rc != X86EMUL_CONTINUE)\n\t\tgoto done;\n\n\t/*\n\t * Decode and fetch the second source operand: register, memory\n\t * or immediate.\n\t */\n\trc = decode_operand(ctxt, &ctxt->src2, (ctxt->d >> Src2Shift) & OpMask);\n\tif (rc != X86EMUL_CONTINUE)\n\t\tgoto done;\n\n\t/* Decode and fetch the destination operand: register or memory. */\n\trc = decode_operand(ctxt, &ctxt->dst, (ctxt->d >> DstShift) & OpMask);\n\n\tif (ctxt->rip_relative && likely(ctxt->memopp))\n\t\tctxt->memopp->addr.mem.ea = address_mask(ctxt,\n\t\t\t\t\tctxt->memopp->addr.mem.ea + ctxt->_eip);\n\ndone:\n\treturn (rc != X86EMUL_CONTINUE) ? EMULATION_FAILED : EMULATION_OK;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -259,7 +259,7 @@\n \t/* Decode and fetch the destination operand: register or memory. */\n \trc = decode_operand(ctxt, &ctxt->dst, (ctxt->d >> DstShift) & OpMask);\n \n-\tif (ctxt->rip_relative)\n+\tif (ctxt->rip_relative && likely(ctxt->memopp))\n \t\tctxt->memopp->addr.mem.ea = address_mask(ctxt,\n \t\t\t\t\tctxt->memopp->addr.mem.ea + ctxt->_eip);\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (ctxt->rip_relative)"
            ],
            "added_lines": [
                "\tif (ctxt->rip_relative && likely(ctxt->memopp))"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-8633",
        "func_name": "torvalds/linux/fwnet_receive_broadcast",
        "description": "drivers/firewire/net.c in the Linux kernel before 4.8.7, in certain unusual hardware configurations, allows remote attackers to execute arbitrary code via crafted fragmented packets.",
        "git_url": "https://github.com/torvalds/linux/commit/667121ace9dbafb368618dbabcf07901c962ddac",
        "commit_title": "firewire: net: guard against rx buffer overflows",
        "commit_text": " The IP-over-1394 driver firewire-net lacked input validation when handling incoming fragmented datagrams.  A maliciously formed fragment with a respectively large datagram_offset would cause a memcpy past the datagram buffer.  So, drop any packets carrying a fragment with offset + length larger than datagram_size.  In addition, ensure that   - GASP header, unfragmented encapsulation header, or fragment     encapsulation header actually exists before we access it,   - the encapsulated datagram or fragment is of nonzero size.  Cc: stable@vger.kernel.org",
        "func_before": "static void fwnet_receive_broadcast(struct fw_iso_context *context,\n\t\tu32 cycle, size_t header_length, void *header, void *data)\n{\n\tstruct fwnet_device *dev;\n\tstruct fw_iso_packet packet;\n\t__be16 *hdr_ptr;\n\t__be32 *buf_ptr;\n\tint retval;\n\tu32 length;\n\tu16 source_node_id;\n\tu32 specifier_id;\n\tu32 ver;\n\tunsigned long offset;\n\tunsigned long flags;\n\n\tdev = data;\n\thdr_ptr = header;\n\tlength = be16_to_cpup(hdr_ptr);\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\n\toffset = dev->rcv_buffer_size * dev->broadcast_rcv_next_ptr;\n\tbuf_ptr = dev->broadcast_rcv_buffer_ptrs[dev->broadcast_rcv_next_ptr++];\n\tif (dev->broadcast_rcv_next_ptr == dev->num_broadcast_rcv_ptrs)\n\t\tdev->broadcast_rcv_next_ptr = 0;\n\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\tspecifier_id =    (be32_to_cpu(buf_ptr[0]) & 0xffff) << 8\n\t\t\t| (be32_to_cpu(buf_ptr[1]) & 0xff000000) >> 24;\n\tver = be32_to_cpu(buf_ptr[1]) & 0xffffff;\n\tsource_node_id = be32_to_cpu(buf_ptr[0]) >> 16;\n\n\tif (specifier_id == IANA_SPECIFIER_ID &&\n\t    (ver == RFC2734_SW_VERSION\n#if IS_ENABLED(CONFIG_IPV6)\n\t     || ver == RFC3146_SW_VERSION\n#endif\n\t    )) {\n\t\tbuf_ptr += 2;\n\t\tlength -= IEEE1394_GASP_HDR_SIZE;\n\t\tfwnet_incoming_packet(dev, buf_ptr, length, source_node_id,\n\t\t\t\t      context->card->generation, true);\n\t}\n\n\tpacket.payload_length = dev->rcv_buffer_size;\n\tpacket.interrupt = 1;\n\tpacket.skip = 0;\n\tpacket.tag = 3;\n\tpacket.sy = 0;\n\tpacket.header_length = IEEE1394_GASP_HDR_SIZE;\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\n\tretval = fw_iso_context_queue(dev->broadcast_rcv_context, &packet,\n\t\t\t\t      &dev->broadcast_rcv_buffer, offset);\n\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\tif (retval >= 0)\n\t\tfw_iso_context_queue_flush(dev->broadcast_rcv_context);\n\telse\n\t\tdev_err(&dev->netdev->dev, \"requeue failed\\n\");\n}",
        "func": "static void fwnet_receive_broadcast(struct fw_iso_context *context,\n\t\tu32 cycle, size_t header_length, void *header, void *data)\n{\n\tstruct fwnet_device *dev;\n\tstruct fw_iso_packet packet;\n\t__be16 *hdr_ptr;\n\t__be32 *buf_ptr;\n\tint retval;\n\tu32 length;\n\tunsigned long offset;\n\tunsigned long flags;\n\n\tdev = data;\n\thdr_ptr = header;\n\tlength = be16_to_cpup(hdr_ptr);\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\n\toffset = dev->rcv_buffer_size * dev->broadcast_rcv_next_ptr;\n\tbuf_ptr = dev->broadcast_rcv_buffer_ptrs[dev->broadcast_rcv_next_ptr++];\n\tif (dev->broadcast_rcv_next_ptr == dev->num_broadcast_rcv_ptrs)\n\t\tdev->broadcast_rcv_next_ptr = 0;\n\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\tif (length > IEEE1394_GASP_HDR_SIZE &&\n\t    gasp_specifier_id(buf_ptr) == IANA_SPECIFIER_ID &&\n\t    (gasp_version(buf_ptr) == RFC2734_SW_VERSION\n#if IS_ENABLED(CONFIG_IPV6)\n\t     || gasp_version(buf_ptr) == RFC3146_SW_VERSION\n#endif\n\t    ))\n\t\tfwnet_incoming_packet(dev, buf_ptr + 2,\n\t\t\t\t      length - IEEE1394_GASP_HDR_SIZE,\n\t\t\t\t      gasp_source_id(buf_ptr),\n\t\t\t\t      context->card->generation, true);\n\n\tpacket.payload_length = dev->rcv_buffer_size;\n\tpacket.interrupt = 1;\n\tpacket.skip = 0;\n\tpacket.tag = 3;\n\tpacket.sy = 0;\n\tpacket.header_length = IEEE1394_GASP_HDR_SIZE;\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\n\tretval = fw_iso_context_queue(dev->broadcast_rcv_context, &packet,\n\t\t\t\t      &dev->broadcast_rcv_buffer, offset);\n\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\tif (retval >= 0)\n\t\tfw_iso_context_queue_flush(dev->broadcast_rcv_context);\n\telse\n\t\tdev_err(&dev->netdev->dev, \"requeue failed\\n\");\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -7,9 +7,6 @@\n \t__be32 *buf_ptr;\n \tint retval;\n \tu32 length;\n-\tu16 source_node_id;\n-\tu32 specifier_id;\n-\tu32 ver;\n \tunsigned long offset;\n \tunsigned long flags;\n \n@@ -26,22 +23,17 @@\n \n \tspin_unlock_irqrestore(&dev->lock, flags);\n \n-\tspecifier_id =    (be32_to_cpu(buf_ptr[0]) & 0xffff) << 8\n-\t\t\t| (be32_to_cpu(buf_ptr[1]) & 0xff000000) >> 24;\n-\tver = be32_to_cpu(buf_ptr[1]) & 0xffffff;\n-\tsource_node_id = be32_to_cpu(buf_ptr[0]) >> 16;\n-\n-\tif (specifier_id == IANA_SPECIFIER_ID &&\n-\t    (ver == RFC2734_SW_VERSION\n+\tif (length > IEEE1394_GASP_HDR_SIZE &&\n+\t    gasp_specifier_id(buf_ptr) == IANA_SPECIFIER_ID &&\n+\t    (gasp_version(buf_ptr) == RFC2734_SW_VERSION\n #if IS_ENABLED(CONFIG_IPV6)\n-\t     || ver == RFC3146_SW_VERSION\n+\t     || gasp_version(buf_ptr) == RFC3146_SW_VERSION\n #endif\n-\t    )) {\n-\t\tbuf_ptr += 2;\n-\t\tlength -= IEEE1394_GASP_HDR_SIZE;\n-\t\tfwnet_incoming_packet(dev, buf_ptr, length, source_node_id,\n+\t    ))\n+\t\tfwnet_incoming_packet(dev, buf_ptr + 2,\n+\t\t\t\t      length - IEEE1394_GASP_HDR_SIZE,\n+\t\t\t\t      gasp_source_id(buf_ptr),\n \t\t\t\t      context->card->generation, true);\n-\t}\n \n \tpacket.payload_length = dev->rcv_buffer_size;\n \tpacket.interrupt = 1;",
        "diff_line_info": {
            "deleted_lines": [
                "\tu16 source_node_id;",
                "\tu32 specifier_id;",
                "\tu32 ver;",
                "\tspecifier_id =    (be32_to_cpu(buf_ptr[0]) & 0xffff) << 8",
                "\t\t\t| (be32_to_cpu(buf_ptr[1]) & 0xff000000) >> 24;",
                "\tver = be32_to_cpu(buf_ptr[1]) & 0xffffff;",
                "\tsource_node_id = be32_to_cpu(buf_ptr[0]) >> 16;",
                "",
                "\tif (specifier_id == IANA_SPECIFIER_ID &&",
                "\t    (ver == RFC2734_SW_VERSION",
                "\t     || ver == RFC3146_SW_VERSION",
                "\t    )) {",
                "\t\tbuf_ptr += 2;",
                "\t\tlength -= IEEE1394_GASP_HDR_SIZE;",
                "\t\tfwnet_incoming_packet(dev, buf_ptr, length, source_node_id,",
                "\t}"
            ],
            "added_lines": [
                "\tif (length > IEEE1394_GASP_HDR_SIZE &&",
                "\t    gasp_specifier_id(buf_ptr) == IANA_SPECIFIER_ID &&",
                "\t    (gasp_version(buf_ptr) == RFC2734_SW_VERSION",
                "\t     || gasp_version(buf_ptr) == RFC3146_SW_VERSION",
                "\t    ))",
                "\t\tfwnet_incoming_packet(dev, buf_ptr + 2,",
                "\t\t\t\t      length - IEEE1394_GASP_HDR_SIZE,",
                "\t\t\t\t      gasp_source_id(buf_ptr),"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-8633",
        "func_name": "torvalds/linux/fwnet_incoming_packet",
        "description": "drivers/firewire/net.c in the Linux kernel before 4.8.7, in certain unusual hardware configurations, allows remote attackers to execute arbitrary code via crafted fragmented packets.",
        "git_url": "https://github.com/torvalds/linux/commit/667121ace9dbafb368618dbabcf07901c962ddac",
        "commit_title": "firewire: net: guard against rx buffer overflows",
        "commit_text": " The IP-over-1394 driver firewire-net lacked input validation when handling incoming fragmented datagrams.  A maliciously formed fragment with a respectively large datagram_offset would cause a memcpy past the datagram buffer.  So, drop any packets carrying a fragment with offset + length larger than datagram_size.  In addition, ensure that   - GASP header, unfragmented encapsulation header, or fragment     encapsulation header actually exists before we access it,   - the encapsulated datagram or fragment is of nonzero size.  Cc: stable@vger.kernel.org",
        "func_before": "static int fwnet_incoming_packet(struct fwnet_device *dev, __be32 *buf, int len,\n\t\t\t\t int source_node_id, int generation,\n\t\t\t\t bool is_broadcast)\n{\n\tstruct sk_buff *skb;\n\tstruct net_device *net = dev->netdev;\n\tstruct rfc2734_header hdr;\n\tunsigned lf;\n\tunsigned long flags;\n\tstruct fwnet_peer *peer;\n\tstruct fwnet_partial_datagram *pd;\n\tint fg_off;\n\tint dg_size;\n\tu16 datagram_label;\n\tint retval;\n\tu16 ether_type;\n\n\thdr.w0 = be32_to_cpu(buf[0]);\n\tlf = fwnet_get_hdr_lf(&hdr);\n\tif (lf == RFC2374_HDR_UNFRAG) {\n\t\t/*\n\t\t * An unfragmented datagram has been received by the ieee1394\n\t\t * bus. Build an skbuff around it so we can pass it to the\n\t\t * high level network layer.\n\t\t */\n\t\tether_type = fwnet_get_hdr_ether_type(&hdr);\n\t\tbuf++;\n\t\tlen -= RFC2374_UNFRAG_HDR_SIZE;\n\n\t\tskb = dev_alloc_skb(len + LL_RESERVED_SPACE(net));\n\t\tif (unlikely(!skb)) {\n\t\t\tnet->stats.rx_dropped++;\n\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tskb_reserve(skb, LL_RESERVED_SPACE(net));\n\t\tmemcpy(skb_put(skb, len), buf, len);\n\n\t\treturn fwnet_finish_incoming_packet(net, skb, source_node_id,\n\t\t\t\t\t\t    is_broadcast, ether_type);\n\t}\n\t/* A datagram fragment has been received, now the fun begins. */\n\thdr.w1 = ntohl(buf[1]);\n\tbuf += 2;\n\tlen -= RFC2374_FRAG_HDR_SIZE;\n\tif (lf == RFC2374_HDR_FIRSTFRAG) {\n\t\tether_type = fwnet_get_hdr_ether_type(&hdr);\n\t\tfg_off = 0;\n\t} else {\n\t\tether_type = 0;\n\t\tfg_off = fwnet_get_hdr_fg_off(&hdr);\n\t}\n\tdatagram_label = fwnet_get_hdr_dgl(&hdr);\n\tdg_size = fwnet_get_hdr_dg_size(&hdr); /* ??? + 1 */\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\n\tpeer = fwnet_peer_find_by_node_id(dev, source_node_id, generation);\n\tif (!peer) {\n\t\tretval = -ENOENT;\n\t\tgoto fail;\n\t}\n\n\tpd = fwnet_pd_find(peer, datagram_label);\n\tif (pd == NULL) {\n\t\twhile (peer->pdg_size >= FWNET_MAX_FRAGMENTS) {\n\t\t\t/* remove the oldest */\n\t\t\tfwnet_pd_delete(list_first_entry(&peer->pd_list,\n\t\t\t\tstruct fwnet_partial_datagram, pd_link));\n\t\t\tpeer->pdg_size--;\n\t\t}\n\t\tpd = fwnet_pd_new(net, peer, datagram_label,\n\t\t\t\t  dg_size, buf, fg_off, len);\n\t\tif (pd == NULL) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto fail;\n\t\t}\n\t\tpeer->pdg_size++;\n\t} else {\n\t\tif (fwnet_frag_overlap(pd, fg_off, len) ||\n\t\t    pd->datagram_size != dg_size) {\n\t\t\t/*\n\t\t\t * Differing datagram sizes or overlapping fragments,\n\t\t\t * discard old datagram and start a new one.\n\t\t\t */\n\t\t\tfwnet_pd_delete(pd);\n\t\t\tpd = fwnet_pd_new(net, peer, datagram_label,\n\t\t\t\t\t  dg_size, buf, fg_off, len);\n\t\t\tif (pd == NULL) {\n\t\t\t\tpeer->pdg_size--;\n\t\t\t\tretval = -ENOMEM;\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!fwnet_pd_update(peer, pd, buf, fg_off, len)) {\n\t\t\t\t/*\n\t\t\t\t * Couldn't save off fragment anyway\n\t\t\t\t * so might as well obliterate the\n\t\t\t\t * datagram now.\n\t\t\t\t */\n\t\t\t\tfwnet_pd_delete(pd);\n\t\t\t\tpeer->pdg_size--;\n\t\t\t\tretval = -ENOMEM;\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t}\n\t} /* new datagram or add to existing one */\n\n\tif (lf == RFC2374_HDR_FIRSTFRAG)\n\t\tpd->ether_type = ether_type;\n\n\tif (fwnet_pd_is_complete(pd)) {\n\t\tether_type = pd->ether_type;\n\t\tpeer->pdg_size--;\n\t\tskb = skb_get(pd->skb);\n\t\tfwnet_pd_delete(pd);\n\n\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\t\treturn fwnet_finish_incoming_packet(net, skb, source_node_id,\n\t\t\t\t\t\t    false, ether_type);\n\t}\n\t/*\n\t * Datagram is not complete, we're done for the\n\t * moment.\n\t */\n\tretval = 0;\n fail:\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\treturn retval;\n}",
        "func": "static int fwnet_incoming_packet(struct fwnet_device *dev, __be32 *buf, int len,\n\t\t\t\t int source_node_id, int generation,\n\t\t\t\t bool is_broadcast)\n{\n\tstruct sk_buff *skb;\n\tstruct net_device *net = dev->netdev;\n\tstruct rfc2734_header hdr;\n\tunsigned lf;\n\tunsigned long flags;\n\tstruct fwnet_peer *peer;\n\tstruct fwnet_partial_datagram *pd;\n\tint fg_off;\n\tint dg_size;\n\tu16 datagram_label;\n\tint retval;\n\tu16 ether_type;\n\n\tif (len <= RFC2374_UNFRAG_HDR_SIZE)\n\t\treturn 0;\n\n\thdr.w0 = be32_to_cpu(buf[0]);\n\tlf = fwnet_get_hdr_lf(&hdr);\n\tif (lf == RFC2374_HDR_UNFRAG) {\n\t\t/*\n\t\t * An unfragmented datagram has been received by the ieee1394\n\t\t * bus. Build an skbuff around it so we can pass it to the\n\t\t * high level network layer.\n\t\t */\n\t\tether_type = fwnet_get_hdr_ether_type(&hdr);\n\t\tbuf++;\n\t\tlen -= RFC2374_UNFRAG_HDR_SIZE;\n\n\t\tskb = dev_alloc_skb(len + LL_RESERVED_SPACE(net));\n\t\tif (unlikely(!skb)) {\n\t\t\tnet->stats.rx_dropped++;\n\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tskb_reserve(skb, LL_RESERVED_SPACE(net));\n\t\tmemcpy(skb_put(skb, len), buf, len);\n\n\t\treturn fwnet_finish_incoming_packet(net, skb, source_node_id,\n\t\t\t\t\t\t    is_broadcast, ether_type);\n\t}\n\n\t/* A datagram fragment has been received, now the fun begins. */\n\n\tif (len <= RFC2374_FRAG_HDR_SIZE)\n\t\treturn 0;\n\n\thdr.w1 = ntohl(buf[1]);\n\tbuf += 2;\n\tlen -= RFC2374_FRAG_HDR_SIZE;\n\tif (lf == RFC2374_HDR_FIRSTFRAG) {\n\t\tether_type = fwnet_get_hdr_ether_type(&hdr);\n\t\tfg_off = 0;\n\t} else {\n\t\tether_type = 0;\n\t\tfg_off = fwnet_get_hdr_fg_off(&hdr);\n\t}\n\tdatagram_label = fwnet_get_hdr_dgl(&hdr);\n\tdg_size = fwnet_get_hdr_dg_size(&hdr); /* ??? + 1 */\n\n\tif (fg_off + len > dg_size)\n\t\treturn 0;\n\n\tspin_lock_irqsave(&dev->lock, flags);\n\n\tpeer = fwnet_peer_find_by_node_id(dev, source_node_id, generation);\n\tif (!peer) {\n\t\tretval = -ENOENT;\n\t\tgoto fail;\n\t}\n\n\tpd = fwnet_pd_find(peer, datagram_label);\n\tif (pd == NULL) {\n\t\twhile (peer->pdg_size >= FWNET_MAX_FRAGMENTS) {\n\t\t\t/* remove the oldest */\n\t\t\tfwnet_pd_delete(list_first_entry(&peer->pd_list,\n\t\t\t\tstruct fwnet_partial_datagram, pd_link));\n\t\t\tpeer->pdg_size--;\n\t\t}\n\t\tpd = fwnet_pd_new(net, peer, datagram_label,\n\t\t\t\t  dg_size, buf, fg_off, len);\n\t\tif (pd == NULL) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto fail;\n\t\t}\n\t\tpeer->pdg_size++;\n\t} else {\n\t\tif (fwnet_frag_overlap(pd, fg_off, len) ||\n\t\t    pd->datagram_size != dg_size) {\n\t\t\t/*\n\t\t\t * Differing datagram sizes or overlapping fragments,\n\t\t\t * discard old datagram and start a new one.\n\t\t\t */\n\t\t\tfwnet_pd_delete(pd);\n\t\t\tpd = fwnet_pd_new(net, peer, datagram_label,\n\t\t\t\t\t  dg_size, buf, fg_off, len);\n\t\t\tif (pd == NULL) {\n\t\t\t\tpeer->pdg_size--;\n\t\t\t\tretval = -ENOMEM;\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!fwnet_pd_update(peer, pd, buf, fg_off, len)) {\n\t\t\t\t/*\n\t\t\t\t * Couldn't save off fragment anyway\n\t\t\t\t * so might as well obliterate the\n\t\t\t\t * datagram now.\n\t\t\t\t */\n\t\t\t\tfwnet_pd_delete(pd);\n\t\t\t\tpeer->pdg_size--;\n\t\t\t\tretval = -ENOMEM;\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t}\n\t} /* new datagram or add to existing one */\n\n\tif (lf == RFC2374_HDR_FIRSTFRAG)\n\t\tpd->ether_type = ether_type;\n\n\tif (fwnet_pd_is_complete(pd)) {\n\t\tether_type = pd->ether_type;\n\t\tpeer->pdg_size--;\n\t\tskb = skb_get(pd->skb);\n\t\tfwnet_pd_delete(pd);\n\n\t\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\t\treturn fwnet_finish_incoming_packet(net, skb, source_node_id,\n\t\t\t\t\t\t    false, ether_type);\n\t}\n\t/*\n\t * Datagram is not complete, we're done for the\n\t * moment.\n\t */\n\tretval = 0;\n fail:\n\tspin_unlock_irqrestore(&dev->lock, flags);\n\n\treturn retval;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -14,6 +14,9 @@\n \tu16 datagram_label;\n \tint retval;\n \tu16 ether_type;\n+\n+\tif (len <= RFC2374_UNFRAG_HDR_SIZE)\n+\t\treturn 0;\n \n \thdr.w0 = be32_to_cpu(buf[0]);\n \tlf = fwnet_get_hdr_lf(&hdr);\n@@ -39,7 +42,12 @@\n \t\treturn fwnet_finish_incoming_packet(net, skb, source_node_id,\n \t\t\t\t\t\t    is_broadcast, ether_type);\n \t}\n+\n \t/* A datagram fragment has been received, now the fun begins. */\n+\n+\tif (len <= RFC2374_FRAG_HDR_SIZE)\n+\t\treturn 0;\n+\n \thdr.w1 = ntohl(buf[1]);\n \tbuf += 2;\n \tlen -= RFC2374_FRAG_HDR_SIZE;\n@@ -52,6 +60,9 @@\n \t}\n \tdatagram_label = fwnet_get_hdr_dgl(&hdr);\n \tdg_size = fwnet_get_hdr_dg_size(&hdr); /* ??? + 1 */\n+\n+\tif (fg_off + len > dg_size)\n+\t\treturn 0;\n \n \tspin_lock_irqsave(&dev->lock, flags);\n ",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "\tif (len <= RFC2374_UNFRAG_HDR_SIZE)",
                "\t\treturn 0;",
                "",
                "",
                "\tif (len <= RFC2374_FRAG_HDR_SIZE)",
                "\t\treturn 0;",
                "",
                "",
                "\tif (fg_off + len > dg_size)",
                "\t\treturn 0;"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-8645",
        "func_name": "torvalds/linux/tcp_v4_rcv",
        "description": "The TCP stack in the Linux kernel before 4.8.10 mishandles skb truncation, which allows local users to cause a denial of service (system crash) via a crafted application that makes sendto system calls, related to net/ipv4/tcp_ipv4.c and net/ipv6/tcp_ipv6.c.",
        "git_url": "https://github.com/torvalds/linux/commit/ac6e780070e30e4c35bd395acfe9191e6268bdd3",
        "commit_title": "tcp: take care of truncations done by sk_filter()",
        "commit_text": " With syzkaller help, Marco Grassi found a bug in TCP stack, crashing in tcp_collapse()  Root cause is that sk_filter() can truncate the incoming skb, but TCP stack was not really expecting this to happen. It probably was expecting a simple DROP or ACCEPT behavior.  We first need to make sure no part of TCP header could be removed. Then we need to adjust TCP_SKB_CB(skb)->end_seq  Many thanks to syzkaller team and Marco for giving us a reproducer. ",
        "func_before": "int tcp_v4_rcv(struct sk_buff *skb)\n{\n\tstruct net *net = dev_net(skb->dev);\n\tconst struct iphdr *iph;\n\tconst struct tcphdr *th;\n\tbool refcounted;\n\tstruct sock *sk;\n\tint ret;\n\n\tif (skb->pkt_type != PACKET_HOST)\n\t\tgoto discard_it;\n\n\t/* Count it even if it's bad */\n\t__TCP_INC_STATS(net, TCP_MIB_INSEGS);\n\n\tif (!pskb_may_pull(skb, sizeof(struct tcphdr)))\n\t\tgoto discard_it;\n\n\tth = (const struct tcphdr *)skb->data;\n\n\tif (unlikely(th->doff < sizeof(struct tcphdr) / 4))\n\t\tgoto bad_packet;\n\tif (!pskb_may_pull(skb, th->doff * 4))\n\t\tgoto discard_it;\n\n\t/* An explanation is required here, I think.\n\t * Packet length and doff are validated by header prediction,\n\t * provided case of th->doff==0 is eliminated.\n\t * So, we defer the checks. */\n\n\tif (skb_checksum_init(skb, IPPROTO_TCP, inet_compute_pseudo))\n\t\tgoto csum_error;\n\n\tth = (const struct tcphdr *)skb->data;\n\tiph = ip_hdr(skb);\n\t/* This is tricky : We move IPCB at its correct location into TCP_SKB_CB()\n\t * barrier() makes sure compiler wont play fool^Waliasing games.\n\t */\n\tmemmove(&TCP_SKB_CB(skb)->header.h4, IPCB(skb),\n\t\tsizeof(struct inet_skb_parm));\n\tbarrier();\n\n\tTCP_SKB_CB(skb)->seq = ntohl(th->seq);\n\tTCP_SKB_CB(skb)->end_seq = (TCP_SKB_CB(skb)->seq + th->syn + th->fin +\n\t\t\t\t    skb->len - th->doff * 4);\n\tTCP_SKB_CB(skb)->ack_seq = ntohl(th->ack_seq);\n\tTCP_SKB_CB(skb)->tcp_flags = tcp_flag_byte(th);\n\tTCP_SKB_CB(skb)->tcp_tw_isn = 0;\n\tTCP_SKB_CB(skb)->ip_dsfield = ipv4_get_dsfield(iph);\n\tTCP_SKB_CB(skb)->sacked\t = 0;\n\nlookup:\n\tsk = __inet_lookup_skb(&tcp_hashinfo, skb, __tcp_hdrlen(th), th->source,\n\t\t\t       th->dest, &refcounted);\n\tif (!sk)\n\t\tgoto no_tcp_socket;\n\nprocess:\n\tif (sk->sk_state == TCP_TIME_WAIT)\n\t\tgoto do_time_wait;\n\n\tif (sk->sk_state == TCP_NEW_SYN_RECV) {\n\t\tstruct request_sock *req = inet_reqsk(sk);\n\t\tstruct sock *nsk;\n\n\t\tsk = req->rsk_listener;\n\t\tif (unlikely(tcp_v4_inbound_md5_hash(sk, skb))) {\n\t\t\tsk_drops_add(sk, skb);\n\t\t\treqsk_put(req);\n\t\t\tgoto discard_it;\n\t\t}\n\t\tif (unlikely(sk->sk_state != TCP_LISTEN)) {\n\t\t\tinet_csk_reqsk_queue_drop_and_put(sk, req);\n\t\t\tgoto lookup;\n\t\t}\n\t\t/* We own a reference on the listener, increase it again\n\t\t * as we might lose it too soon.\n\t\t */\n\t\tsock_hold(sk);\n\t\trefcounted = true;\n\t\tnsk = tcp_check_req(sk, skb, req, false);\n\t\tif (!nsk) {\n\t\t\treqsk_put(req);\n\t\t\tgoto discard_and_relse;\n\t\t}\n\t\tif (nsk == sk) {\n\t\t\treqsk_put(req);\n\t\t} else if (tcp_child_process(sk, nsk, skb)) {\n\t\t\ttcp_v4_send_reset(nsk, skb);\n\t\t\tgoto discard_and_relse;\n\t\t} else {\n\t\t\tsock_put(sk);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (unlikely(iph->ttl < inet_sk(sk)->min_ttl)) {\n\t\t__NET_INC_STATS(net, LINUX_MIB_TCPMINTTLDROP);\n\t\tgoto discard_and_relse;\n\t}\n\n\tif (!xfrm4_policy_check(sk, XFRM_POLICY_IN, skb))\n\t\tgoto discard_and_relse;\n\n\tif (tcp_v4_inbound_md5_hash(sk, skb))\n\t\tgoto discard_and_relse;\n\n\tnf_reset(skb);\n\n\tif (sk_filter(sk, skb))\n\t\tgoto discard_and_relse;\n\n\tskb->dev = NULL;\n\n\tif (sk->sk_state == TCP_LISTEN) {\n\t\tret = tcp_v4_do_rcv(sk, skb);\n\t\tgoto put_and_return;\n\t}\n\n\tsk_incoming_cpu_update(sk);\n\n\tbh_lock_sock_nested(sk);\n\ttcp_segs_in(tcp_sk(sk), skb);\n\tret = 0;\n\tif (!sock_owned_by_user(sk)) {\n\t\tif (!tcp_prequeue(sk, skb))\n\t\t\tret = tcp_v4_do_rcv(sk, skb);\n\t} else if (tcp_add_backlog(sk, skb)) {\n\t\tgoto discard_and_relse;\n\t}\n\tbh_unlock_sock(sk);\n\nput_and_return:\n\tif (refcounted)\n\t\tsock_put(sk);\n\n\treturn ret;\n\nno_tcp_socket:\n\tif (!xfrm4_policy_check(NULL, XFRM_POLICY_IN, skb))\n\t\tgoto discard_it;\n\n\tif (tcp_checksum_complete(skb)) {\ncsum_error:\n\t\t__TCP_INC_STATS(net, TCP_MIB_CSUMERRORS);\nbad_packet:\n\t\t__TCP_INC_STATS(net, TCP_MIB_INERRS);\n\t} else {\n\t\ttcp_v4_send_reset(NULL, skb);\n\t}\n\ndiscard_it:\n\t/* Discard frame. */\n\tkfree_skb(skb);\n\treturn 0;\n\ndiscard_and_relse:\n\tsk_drops_add(sk, skb);\n\tif (refcounted)\n\t\tsock_put(sk);\n\tgoto discard_it;\n\ndo_time_wait:\n\tif (!xfrm4_policy_check(NULL, XFRM_POLICY_IN, skb)) {\n\t\tinet_twsk_put(inet_twsk(sk));\n\t\tgoto discard_it;\n\t}\n\n\tif (tcp_checksum_complete(skb)) {\n\t\tinet_twsk_put(inet_twsk(sk));\n\t\tgoto csum_error;\n\t}\n\tswitch (tcp_timewait_state_process(inet_twsk(sk), skb, th)) {\n\tcase TCP_TW_SYN: {\n\t\tstruct sock *sk2 = inet_lookup_listener(dev_net(skb->dev),\n\t\t\t\t\t\t\t&tcp_hashinfo, skb,\n\t\t\t\t\t\t\t__tcp_hdrlen(th),\n\t\t\t\t\t\t\tiph->saddr, th->source,\n\t\t\t\t\t\t\tiph->daddr, th->dest,\n\t\t\t\t\t\t\tinet_iif(skb));\n\t\tif (sk2) {\n\t\t\tinet_twsk_deschedule_put(inet_twsk(sk));\n\t\t\tsk = sk2;\n\t\t\trefcounted = false;\n\t\t\tgoto process;\n\t\t}\n\t\t/* Fall through to ACK */\n\t}\n\tcase TCP_TW_ACK:\n\t\ttcp_v4_timewait_ack(sk, skb);\n\t\tbreak;\n\tcase TCP_TW_RST:\n\t\ttcp_v4_send_reset(sk, skb);\n\t\tinet_twsk_deschedule_put(inet_twsk(sk));\n\t\tgoto discard_it;\n\tcase TCP_TW_SUCCESS:;\n\t}\n\tgoto discard_it;\n}",
        "func": "int tcp_v4_rcv(struct sk_buff *skb)\n{\n\tstruct net *net = dev_net(skb->dev);\n\tconst struct iphdr *iph;\n\tconst struct tcphdr *th;\n\tbool refcounted;\n\tstruct sock *sk;\n\tint ret;\n\n\tif (skb->pkt_type != PACKET_HOST)\n\t\tgoto discard_it;\n\n\t/* Count it even if it's bad */\n\t__TCP_INC_STATS(net, TCP_MIB_INSEGS);\n\n\tif (!pskb_may_pull(skb, sizeof(struct tcphdr)))\n\t\tgoto discard_it;\n\n\tth = (const struct tcphdr *)skb->data;\n\n\tif (unlikely(th->doff < sizeof(struct tcphdr) / 4))\n\t\tgoto bad_packet;\n\tif (!pskb_may_pull(skb, th->doff * 4))\n\t\tgoto discard_it;\n\n\t/* An explanation is required here, I think.\n\t * Packet length and doff are validated by header prediction,\n\t * provided case of th->doff==0 is eliminated.\n\t * So, we defer the checks. */\n\n\tif (skb_checksum_init(skb, IPPROTO_TCP, inet_compute_pseudo))\n\t\tgoto csum_error;\n\n\tth = (const struct tcphdr *)skb->data;\n\tiph = ip_hdr(skb);\n\t/* This is tricky : We move IPCB at its correct location into TCP_SKB_CB()\n\t * barrier() makes sure compiler wont play fool^Waliasing games.\n\t */\n\tmemmove(&TCP_SKB_CB(skb)->header.h4, IPCB(skb),\n\t\tsizeof(struct inet_skb_parm));\n\tbarrier();\n\n\tTCP_SKB_CB(skb)->seq = ntohl(th->seq);\n\tTCP_SKB_CB(skb)->end_seq = (TCP_SKB_CB(skb)->seq + th->syn + th->fin +\n\t\t\t\t    skb->len - th->doff * 4);\n\tTCP_SKB_CB(skb)->ack_seq = ntohl(th->ack_seq);\n\tTCP_SKB_CB(skb)->tcp_flags = tcp_flag_byte(th);\n\tTCP_SKB_CB(skb)->tcp_tw_isn = 0;\n\tTCP_SKB_CB(skb)->ip_dsfield = ipv4_get_dsfield(iph);\n\tTCP_SKB_CB(skb)->sacked\t = 0;\n\nlookup:\n\tsk = __inet_lookup_skb(&tcp_hashinfo, skb, __tcp_hdrlen(th), th->source,\n\t\t\t       th->dest, &refcounted);\n\tif (!sk)\n\t\tgoto no_tcp_socket;\n\nprocess:\n\tif (sk->sk_state == TCP_TIME_WAIT)\n\t\tgoto do_time_wait;\n\n\tif (sk->sk_state == TCP_NEW_SYN_RECV) {\n\t\tstruct request_sock *req = inet_reqsk(sk);\n\t\tstruct sock *nsk;\n\n\t\tsk = req->rsk_listener;\n\t\tif (unlikely(tcp_v4_inbound_md5_hash(sk, skb))) {\n\t\t\tsk_drops_add(sk, skb);\n\t\t\treqsk_put(req);\n\t\t\tgoto discard_it;\n\t\t}\n\t\tif (unlikely(sk->sk_state != TCP_LISTEN)) {\n\t\t\tinet_csk_reqsk_queue_drop_and_put(sk, req);\n\t\t\tgoto lookup;\n\t\t}\n\t\t/* We own a reference on the listener, increase it again\n\t\t * as we might lose it too soon.\n\t\t */\n\t\tsock_hold(sk);\n\t\trefcounted = true;\n\t\tnsk = tcp_check_req(sk, skb, req, false);\n\t\tif (!nsk) {\n\t\t\treqsk_put(req);\n\t\t\tgoto discard_and_relse;\n\t\t}\n\t\tif (nsk == sk) {\n\t\t\treqsk_put(req);\n\t\t} else if (tcp_child_process(sk, nsk, skb)) {\n\t\t\ttcp_v4_send_reset(nsk, skb);\n\t\t\tgoto discard_and_relse;\n\t\t} else {\n\t\t\tsock_put(sk);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (unlikely(iph->ttl < inet_sk(sk)->min_ttl)) {\n\t\t__NET_INC_STATS(net, LINUX_MIB_TCPMINTTLDROP);\n\t\tgoto discard_and_relse;\n\t}\n\n\tif (!xfrm4_policy_check(sk, XFRM_POLICY_IN, skb))\n\t\tgoto discard_and_relse;\n\n\tif (tcp_v4_inbound_md5_hash(sk, skb))\n\t\tgoto discard_and_relse;\n\n\tnf_reset(skb);\n\n\tif (tcp_filter(sk, skb))\n\t\tgoto discard_and_relse;\n\tth = (const struct tcphdr *)skb->data;\n\tiph = ip_hdr(skb);\n\n\tskb->dev = NULL;\n\n\tif (sk->sk_state == TCP_LISTEN) {\n\t\tret = tcp_v4_do_rcv(sk, skb);\n\t\tgoto put_and_return;\n\t}\n\n\tsk_incoming_cpu_update(sk);\n\n\tbh_lock_sock_nested(sk);\n\ttcp_segs_in(tcp_sk(sk), skb);\n\tret = 0;\n\tif (!sock_owned_by_user(sk)) {\n\t\tif (!tcp_prequeue(sk, skb))\n\t\t\tret = tcp_v4_do_rcv(sk, skb);\n\t} else if (tcp_add_backlog(sk, skb)) {\n\t\tgoto discard_and_relse;\n\t}\n\tbh_unlock_sock(sk);\n\nput_and_return:\n\tif (refcounted)\n\t\tsock_put(sk);\n\n\treturn ret;\n\nno_tcp_socket:\n\tif (!xfrm4_policy_check(NULL, XFRM_POLICY_IN, skb))\n\t\tgoto discard_it;\n\n\tif (tcp_checksum_complete(skb)) {\ncsum_error:\n\t\t__TCP_INC_STATS(net, TCP_MIB_CSUMERRORS);\nbad_packet:\n\t\t__TCP_INC_STATS(net, TCP_MIB_INERRS);\n\t} else {\n\t\ttcp_v4_send_reset(NULL, skb);\n\t}\n\ndiscard_it:\n\t/* Discard frame. */\n\tkfree_skb(skb);\n\treturn 0;\n\ndiscard_and_relse:\n\tsk_drops_add(sk, skb);\n\tif (refcounted)\n\t\tsock_put(sk);\n\tgoto discard_it;\n\ndo_time_wait:\n\tif (!xfrm4_policy_check(NULL, XFRM_POLICY_IN, skb)) {\n\t\tinet_twsk_put(inet_twsk(sk));\n\t\tgoto discard_it;\n\t}\n\n\tif (tcp_checksum_complete(skb)) {\n\t\tinet_twsk_put(inet_twsk(sk));\n\t\tgoto csum_error;\n\t}\n\tswitch (tcp_timewait_state_process(inet_twsk(sk), skb, th)) {\n\tcase TCP_TW_SYN: {\n\t\tstruct sock *sk2 = inet_lookup_listener(dev_net(skb->dev),\n\t\t\t\t\t\t\t&tcp_hashinfo, skb,\n\t\t\t\t\t\t\t__tcp_hdrlen(th),\n\t\t\t\t\t\t\tiph->saddr, th->source,\n\t\t\t\t\t\t\tiph->daddr, th->dest,\n\t\t\t\t\t\t\tinet_iif(skb));\n\t\tif (sk2) {\n\t\t\tinet_twsk_deschedule_put(inet_twsk(sk));\n\t\t\tsk = sk2;\n\t\t\trefcounted = false;\n\t\t\tgoto process;\n\t\t}\n\t\t/* Fall through to ACK */\n\t}\n\tcase TCP_TW_ACK:\n\t\ttcp_v4_timewait_ack(sk, skb);\n\t\tbreak;\n\tcase TCP_TW_RST:\n\t\ttcp_v4_send_reset(sk, skb);\n\t\tinet_twsk_deschedule_put(inet_twsk(sk));\n\t\tgoto discard_it;\n\tcase TCP_TW_SUCCESS:;\n\t}\n\tgoto discard_it;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -106,8 +106,10 @@\n \n \tnf_reset(skb);\n \n-\tif (sk_filter(sk, skb))\n-\t\tgoto discard_and_relse;\n+\tif (tcp_filter(sk, skb))\n+\t\tgoto discard_and_relse;\n+\tth = (const struct tcphdr *)skb->data;\n+\tiph = ip_hdr(skb);\n \n \tskb->dev = NULL;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (sk_filter(sk, skb))",
                "\t\tgoto discard_and_relse;"
            ],
            "added_lines": [
                "\tif (tcp_filter(sk, skb))",
                "\t\tgoto discard_and_relse;",
                "\tth = (const struct tcphdr *)skb->data;",
                "\tiph = ip_hdr(skb);"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-8645",
        "func_name": "torvalds/linux/tcp_v6_do_rcv",
        "description": "The TCP stack in the Linux kernel before 4.8.10 mishandles skb truncation, which allows local users to cause a denial of service (system crash) via a crafted application that makes sendto system calls, related to net/ipv4/tcp_ipv4.c and net/ipv6/tcp_ipv6.c.",
        "git_url": "https://github.com/torvalds/linux/commit/ac6e780070e30e4c35bd395acfe9191e6268bdd3",
        "commit_title": "tcp: take care of truncations done by sk_filter()",
        "commit_text": " With syzkaller help, Marco Grassi found a bug in TCP stack, crashing in tcp_collapse()  Root cause is that sk_filter() can truncate the incoming skb, but TCP stack was not really expecting this to happen. It probably was expecting a simple DROP or ACCEPT behavior.  We first need to make sure no part of TCP header could be removed. Then we need to adjust TCP_SKB_CB(skb)->end_seq  Many thanks to syzkaller team and Marco for giving us a reproducer. ",
        "func_before": "static int tcp_v6_do_rcv(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct tcp_sock *tp;\n\tstruct sk_buff *opt_skb = NULL;\n\n\t/* Imagine: socket is IPv6. IPv4 packet arrives,\n\t   goes to IPv4 receive handler and backlogged.\n\t   From backlog it always goes here. Kerboom...\n\t   Fortunately, tcp_rcv_established and rcv_established\n\t   handle them correctly, but it is not case with\n\t   tcp_v6_hnd_req and tcp_v6_send_reset().   --ANK\n\t */\n\n\tif (skb->protocol == htons(ETH_P_IP))\n\t\treturn tcp_v4_do_rcv(sk, skb);\n\n\tif (sk_filter(sk, skb))\n\t\tgoto discard;\n\n\t/*\n\t *\tsocket locking is here for SMP purposes as backlog rcv\n\t *\tis currently called with bh processing disabled.\n\t */\n\n\t/* Do Stevens' IPV6_PKTOPTIONS.\n\n\t   Yes, guys, it is the only place in our code, where we\n\t   may make it not affecting IPv4.\n\t   The rest of code is protocol independent,\n\t   and I do not like idea to uglify IPv4.\n\n\t   Actually, all the idea behind IPV6_PKTOPTIONS\n\t   looks not very well thought. For now we latch\n\t   options, received in the last packet, enqueued\n\t   by tcp. Feel free to propose better solution.\n\t\t\t\t\t       --ANK (980728)\n\t */\n\tif (np->rxopt.all)\n\t\topt_skb = skb_clone(skb, sk_gfp_mask(sk, GFP_ATOMIC));\n\n\tif (sk->sk_state == TCP_ESTABLISHED) { /* Fast path */\n\t\tstruct dst_entry *dst = sk->sk_rx_dst;\n\n\t\tsock_rps_save_rxhash(sk, skb);\n\t\tsk_mark_napi_id(sk, skb);\n\t\tif (dst) {\n\t\t\tif (inet_sk(sk)->rx_dst_ifindex != skb->skb_iif ||\n\t\t\t    dst->ops->check(dst, np->rx_dst_cookie) == NULL) {\n\t\t\t\tdst_release(dst);\n\t\t\t\tsk->sk_rx_dst = NULL;\n\t\t\t}\n\t\t}\n\n\t\ttcp_rcv_established(sk, skb, tcp_hdr(skb), skb->len);\n\t\tif (opt_skb)\n\t\t\tgoto ipv6_pktoptions;\n\t\treturn 0;\n\t}\n\n\tif (tcp_checksum_complete(skb))\n\t\tgoto csum_err;\n\n\tif (sk->sk_state == TCP_LISTEN) {\n\t\tstruct sock *nsk = tcp_v6_cookie_check(sk, skb);\n\n\t\tif (!nsk)\n\t\t\tgoto discard;\n\n\t\tif (nsk != sk) {\n\t\t\tsock_rps_save_rxhash(nsk, skb);\n\t\t\tsk_mark_napi_id(nsk, skb);\n\t\t\tif (tcp_child_process(sk, nsk, skb))\n\t\t\t\tgoto reset;\n\t\t\tif (opt_skb)\n\t\t\t\t__kfree_skb(opt_skb);\n\t\t\treturn 0;\n\t\t}\n\t} else\n\t\tsock_rps_save_rxhash(sk, skb);\n\n\tif (tcp_rcv_state_process(sk, skb))\n\t\tgoto reset;\n\tif (opt_skb)\n\t\tgoto ipv6_pktoptions;\n\treturn 0;\n\nreset:\n\ttcp_v6_send_reset(sk, skb);\ndiscard:\n\tif (opt_skb)\n\t\t__kfree_skb(opt_skb);\n\tkfree_skb(skb);\n\treturn 0;\ncsum_err:\n\tTCP_INC_STATS(sock_net(sk), TCP_MIB_CSUMERRORS);\n\tTCP_INC_STATS(sock_net(sk), TCP_MIB_INERRS);\n\tgoto discard;\n\n\nipv6_pktoptions:\n\t/* Do you ask, what is it?\n\n\t   1. skb was enqueued by tcp.\n\t   2. skb is added to tail of read queue, rather than out of order.\n\t   3. socket is not in passive state.\n\t   4. Finally, it really contains options, which user wants to receive.\n\t */\n\ttp = tcp_sk(sk);\n\tif (TCP_SKB_CB(opt_skb)->end_seq == tp->rcv_nxt &&\n\t    !((1 << sk->sk_state) & (TCPF_CLOSE | TCPF_LISTEN))) {\n\t\tif (np->rxopt.bits.rxinfo || np->rxopt.bits.rxoinfo)\n\t\t\tnp->mcast_oif = tcp_v6_iif(opt_skb);\n\t\tif (np->rxopt.bits.rxhlim || np->rxopt.bits.rxohlim)\n\t\t\tnp->mcast_hops = ipv6_hdr(opt_skb)->hop_limit;\n\t\tif (np->rxopt.bits.rxflow || np->rxopt.bits.rxtclass)\n\t\t\tnp->rcv_flowinfo = ip6_flowinfo(ipv6_hdr(opt_skb));\n\t\tif (np->repflow)\n\t\t\tnp->flow_label = ip6_flowlabel(ipv6_hdr(opt_skb));\n\t\tif (ipv6_opt_accepted(sk, opt_skb, &TCP_SKB_CB(opt_skb)->header.h6)) {\n\t\t\tskb_set_owner_r(opt_skb, sk);\n\t\t\ttcp_v6_restore_cb(opt_skb);\n\t\t\topt_skb = xchg(&np->pktoptions, opt_skb);\n\t\t} else {\n\t\t\t__kfree_skb(opt_skb);\n\t\t\topt_skb = xchg(&np->pktoptions, NULL);\n\t\t}\n\t}\n\n\tkfree_skb(opt_skb);\n\treturn 0;\n}",
        "func": "static int tcp_v6_do_rcv(struct sock *sk, struct sk_buff *skb)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct tcp_sock *tp;\n\tstruct sk_buff *opt_skb = NULL;\n\n\t/* Imagine: socket is IPv6. IPv4 packet arrives,\n\t   goes to IPv4 receive handler and backlogged.\n\t   From backlog it always goes here. Kerboom...\n\t   Fortunately, tcp_rcv_established and rcv_established\n\t   handle them correctly, but it is not case with\n\t   tcp_v6_hnd_req and tcp_v6_send_reset().   --ANK\n\t */\n\n\tif (skb->protocol == htons(ETH_P_IP))\n\t\treturn tcp_v4_do_rcv(sk, skb);\n\n\tif (tcp_filter(sk, skb))\n\t\tgoto discard;\n\n\t/*\n\t *\tsocket locking is here for SMP purposes as backlog rcv\n\t *\tis currently called with bh processing disabled.\n\t */\n\n\t/* Do Stevens' IPV6_PKTOPTIONS.\n\n\t   Yes, guys, it is the only place in our code, where we\n\t   may make it not affecting IPv4.\n\t   The rest of code is protocol independent,\n\t   and I do not like idea to uglify IPv4.\n\n\t   Actually, all the idea behind IPV6_PKTOPTIONS\n\t   looks not very well thought. For now we latch\n\t   options, received in the last packet, enqueued\n\t   by tcp. Feel free to propose better solution.\n\t\t\t\t\t       --ANK (980728)\n\t */\n\tif (np->rxopt.all)\n\t\topt_skb = skb_clone(skb, sk_gfp_mask(sk, GFP_ATOMIC));\n\n\tif (sk->sk_state == TCP_ESTABLISHED) { /* Fast path */\n\t\tstruct dst_entry *dst = sk->sk_rx_dst;\n\n\t\tsock_rps_save_rxhash(sk, skb);\n\t\tsk_mark_napi_id(sk, skb);\n\t\tif (dst) {\n\t\t\tif (inet_sk(sk)->rx_dst_ifindex != skb->skb_iif ||\n\t\t\t    dst->ops->check(dst, np->rx_dst_cookie) == NULL) {\n\t\t\t\tdst_release(dst);\n\t\t\t\tsk->sk_rx_dst = NULL;\n\t\t\t}\n\t\t}\n\n\t\ttcp_rcv_established(sk, skb, tcp_hdr(skb), skb->len);\n\t\tif (opt_skb)\n\t\t\tgoto ipv6_pktoptions;\n\t\treturn 0;\n\t}\n\n\tif (tcp_checksum_complete(skb))\n\t\tgoto csum_err;\n\n\tif (sk->sk_state == TCP_LISTEN) {\n\t\tstruct sock *nsk = tcp_v6_cookie_check(sk, skb);\n\n\t\tif (!nsk)\n\t\t\tgoto discard;\n\n\t\tif (nsk != sk) {\n\t\t\tsock_rps_save_rxhash(nsk, skb);\n\t\t\tsk_mark_napi_id(nsk, skb);\n\t\t\tif (tcp_child_process(sk, nsk, skb))\n\t\t\t\tgoto reset;\n\t\t\tif (opt_skb)\n\t\t\t\t__kfree_skb(opt_skb);\n\t\t\treturn 0;\n\t\t}\n\t} else\n\t\tsock_rps_save_rxhash(sk, skb);\n\n\tif (tcp_rcv_state_process(sk, skb))\n\t\tgoto reset;\n\tif (opt_skb)\n\t\tgoto ipv6_pktoptions;\n\treturn 0;\n\nreset:\n\ttcp_v6_send_reset(sk, skb);\ndiscard:\n\tif (opt_skb)\n\t\t__kfree_skb(opt_skb);\n\tkfree_skb(skb);\n\treturn 0;\ncsum_err:\n\tTCP_INC_STATS(sock_net(sk), TCP_MIB_CSUMERRORS);\n\tTCP_INC_STATS(sock_net(sk), TCP_MIB_INERRS);\n\tgoto discard;\n\n\nipv6_pktoptions:\n\t/* Do you ask, what is it?\n\n\t   1. skb was enqueued by tcp.\n\t   2. skb is added to tail of read queue, rather than out of order.\n\t   3. socket is not in passive state.\n\t   4. Finally, it really contains options, which user wants to receive.\n\t */\n\ttp = tcp_sk(sk);\n\tif (TCP_SKB_CB(opt_skb)->end_seq == tp->rcv_nxt &&\n\t    !((1 << sk->sk_state) & (TCPF_CLOSE | TCPF_LISTEN))) {\n\t\tif (np->rxopt.bits.rxinfo || np->rxopt.bits.rxoinfo)\n\t\t\tnp->mcast_oif = tcp_v6_iif(opt_skb);\n\t\tif (np->rxopt.bits.rxhlim || np->rxopt.bits.rxohlim)\n\t\t\tnp->mcast_hops = ipv6_hdr(opt_skb)->hop_limit;\n\t\tif (np->rxopt.bits.rxflow || np->rxopt.bits.rxtclass)\n\t\t\tnp->rcv_flowinfo = ip6_flowinfo(ipv6_hdr(opt_skb));\n\t\tif (np->repflow)\n\t\t\tnp->flow_label = ip6_flowlabel(ipv6_hdr(opt_skb));\n\t\tif (ipv6_opt_accepted(sk, opt_skb, &TCP_SKB_CB(opt_skb)->header.h6)) {\n\t\t\tskb_set_owner_r(opt_skb, sk);\n\t\t\ttcp_v6_restore_cb(opt_skb);\n\t\t\topt_skb = xchg(&np->pktoptions, opt_skb);\n\t\t} else {\n\t\t\t__kfree_skb(opt_skb);\n\t\t\topt_skb = xchg(&np->pktoptions, NULL);\n\t\t}\n\t}\n\n\tkfree_skb(opt_skb);\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -15,7 +15,7 @@\n \tif (skb->protocol == htons(ETH_P_IP))\n \t\treturn tcp_v4_do_rcv(sk, skb);\n \n-\tif (sk_filter(sk, skb))\n+\tif (tcp_filter(sk, skb))\n \t\tgoto discard;\n \n \t/*",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (sk_filter(sk, skb))"
            ],
            "added_lines": [
                "\tif (tcp_filter(sk, skb))"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-8645",
        "func_name": "torvalds/linux/tcp_v6_rcv",
        "description": "The TCP stack in the Linux kernel before 4.8.10 mishandles skb truncation, which allows local users to cause a denial of service (system crash) via a crafted application that makes sendto system calls, related to net/ipv4/tcp_ipv4.c and net/ipv6/tcp_ipv6.c.",
        "git_url": "https://github.com/torvalds/linux/commit/ac6e780070e30e4c35bd395acfe9191e6268bdd3",
        "commit_title": "tcp: take care of truncations done by sk_filter()",
        "commit_text": " With syzkaller help, Marco Grassi found a bug in TCP stack, crashing in tcp_collapse()  Root cause is that sk_filter() can truncate the incoming skb, but TCP stack was not really expecting this to happen. It probably was expecting a simple DROP or ACCEPT behavior.  We first need to make sure no part of TCP header could be removed. Then we need to adjust TCP_SKB_CB(skb)->end_seq  Many thanks to syzkaller team and Marco for giving us a reproducer. ",
        "func_before": "static int tcp_v6_rcv(struct sk_buff *skb)\n{\n\tconst struct tcphdr *th;\n\tconst struct ipv6hdr *hdr;\n\tbool refcounted;\n\tstruct sock *sk;\n\tint ret;\n\tstruct net *net = dev_net(skb->dev);\n\n\tif (skb->pkt_type != PACKET_HOST)\n\t\tgoto discard_it;\n\n\t/*\n\t *\tCount it even if it's bad.\n\t */\n\t__TCP_INC_STATS(net, TCP_MIB_INSEGS);\n\n\tif (!pskb_may_pull(skb, sizeof(struct tcphdr)))\n\t\tgoto discard_it;\n\n\tth = (const struct tcphdr *)skb->data;\n\n\tif (unlikely(th->doff < sizeof(struct tcphdr)/4))\n\t\tgoto bad_packet;\n\tif (!pskb_may_pull(skb, th->doff*4))\n\t\tgoto discard_it;\n\n\tif (skb_checksum_init(skb, IPPROTO_TCP, ip6_compute_pseudo))\n\t\tgoto csum_error;\n\n\tth = (const struct tcphdr *)skb->data;\n\thdr = ipv6_hdr(skb);\n\nlookup:\n\tsk = __inet6_lookup_skb(&tcp_hashinfo, skb, __tcp_hdrlen(th),\n\t\t\t\tth->source, th->dest, inet6_iif(skb),\n\t\t\t\t&refcounted);\n\tif (!sk)\n\t\tgoto no_tcp_socket;\n\nprocess:\n\tif (sk->sk_state == TCP_TIME_WAIT)\n\t\tgoto do_time_wait;\n\n\tif (sk->sk_state == TCP_NEW_SYN_RECV) {\n\t\tstruct request_sock *req = inet_reqsk(sk);\n\t\tstruct sock *nsk;\n\n\t\tsk = req->rsk_listener;\n\t\ttcp_v6_fill_cb(skb, hdr, th);\n\t\tif (tcp_v6_inbound_md5_hash(sk, skb)) {\n\t\t\tsk_drops_add(sk, skb);\n\t\t\treqsk_put(req);\n\t\t\tgoto discard_it;\n\t\t}\n\t\tif (unlikely(sk->sk_state != TCP_LISTEN)) {\n\t\t\tinet_csk_reqsk_queue_drop_and_put(sk, req);\n\t\t\tgoto lookup;\n\t\t}\n\t\tsock_hold(sk);\n\t\trefcounted = true;\n\t\tnsk = tcp_check_req(sk, skb, req, false);\n\t\tif (!nsk) {\n\t\t\treqsk_put(req);\n\t\t\tgoto discard_and_relse;\n\t\t}\n\t\tif (nsk == sk) {\n\t\t\treqsk_put(req);\n\t\t\ttcp_v6_restore_cb(skb);\n\t\t} else if (tcp_child_process(sk, nsk, skb)) {\n\t\t\ttcp_v6_send_reset(nsk, skb);\n\t\t\tgoto discard_and_relse;\n\t\t} else {\n\t\t\tsock_put(sk);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (hdr->hop_limit < inet6_sk(sk)->min_hopcount) {\n\t\t__NET_INC_STATS(net, LINUX_MIB_TCPMINTTLDROP);\n\t\tgoto discard_and_relse;\n\t}\n\n\tif (!xfrm6_policy_check(sk, XFRM_POLICY_IN, skb))\n\t\tgoto discard_and_relse;\n\n\ttcp_v6_fill_cb(skb, hdr, th);\n\n\tif (tcp_v6_inbound_md5_hash(sk, skb))\n\t\tgoto discard_and_relse;\n\n\tif (sk_filter(sk, skb))\n\t\tgoto discard_and_relse;\n\n\tskb->dev = NULL;\n\n\tif (sk->sk_state == TCP_LISTEN) {\n\t\tret = tcp_v6_do_rcv(sk, skb);\n\t\tgoto put_and_return;\n\t}\n\n\tsk_incoming_cpu_update(sk);\n\n\tbh_lock_sock_nested(sk);\n\ttcp_segs_in(tcp_sk(sk), skb);\n\tret = 0;\n\tif (!sock_owned_by_user(sk)) {\n\t\tif (!tcp_prequeue(sk, skb))\n\t\t\tret = tcp_v6_do_rcv(sk, skb);\n\t} else if (tcp_add_backlog(sk, skb)) {\n\t\tgoto discard_and_relse;\n\t}\n\tbh_unlock_sock(sk);\n\nput_and_return:\n\tif (refcounted)\n\t\tsock_put(sk);\n\treturn ret ? -1 : 0;\n\nno_tcp_socket:\n\tif (!xfrm6_policy_check(NULL, XFRM_POLICY_IN, skb))\n\t\tgoto discard_it;\n\n\ttcp_v6_fill_cb(skb, hdr, th);\n\n\tif (tcp_checksum_complete(skb)) {\ncsum_error:\n\t\t__TCP_INC_STATS(net, TCP_MIB_CSUMERRORS);\nbad_packet:\n\t\t__TCP_INC_STATS(net, TCP_MIB_INERRS);\n\t} else {\n\t\ttcp_v6_send_reset(NULL, skb);\n\t}\n\ndiscard_it:\n\tkfree_skb(skb);\n\treturn 0;\n\ndiscard_and_relse:\n\tsk_drops_add(sk, skb);\n\tif (refcounted)\n\t\tsock_put(sk);\n\tgoto discard_it;\n\ndo_time_wait:\n\tif (!xfrm6_policy_check(NULL, XFRM_POLICY_IN, skb)) {\n\t\tinet_twsk_put(inet_twsk(sk));\n\t\tgoto discard_it;\n\t}\n\n\ttcp_v6_fill_cb(skb, hdr, th);\n\n\tif (tcp_checksum_complete(skb)) {\n\t\tinet_twsk_put(inet_twsk(sk));\n\t\tgoto csum_error;\n\t}\n\n\tswitch (tcp_timewait_state_process(inet_twsk(sk), skb, th)) {\n\tcase TCP_TW_SYN:\n\t{\n\t\tstruct sock *sk2;\n\n\t\tsk2 = inet6_lookup_listener(dev_net(skb->dev), &tcp_hashinfo,\n\t\t\t\t\t    skb, __tcp_hdrlen(th),\n\t\t\t\t\t    &ipv6_hdr(skb)->saddr, th->source,\n\t\t\t\t\t    &ipv6_hdr(skb)->daddr,\n\t\t\t\t\t    ntohs(th->dest), tcp_v6_iif(skb));\n\t\tif (sk2) {\n\t\t\tstruct inet_timewait_sock *tw = inet_twsk(sk);\n\t\t\tinet_twsk_deschedule_put(tw);\n\t\t\tsk = sk2;\n\t\t\ttcp_v6_restore_cb(skb);\n\t\t\trefcounted = false;\n\t\t\tgoto process;\n\t\t}\n\t\t/* Fall through to ACK */\n\t}\n\tcase TCP_TW_ACK:\n\t\ttcp_v6_timewait_ack(sk, skb);\n\t\tbreak;\n\tcase TCP_TW_RST:\n\t\ttcp_v6_restore_cb(skb);\n\t\ttcp_v6_send_reset(sk, skb);\n\t\tinet_twsk_deschedule_put(inet_twsk(sk));\n\t\tgoto discard_it;\n\tcase TCP_TW_SUCCESS:\n\t\t;\n\t}\n\tgoto discard_it;\n}",
        "func": "static int tcp_v6_rcv(struct sk_buff *skb)\n{\n\tconst struct tcphdr *th;\n\tconst struct ipv6hdr *hdr;\n\tbool refcounted;\n\tstruct sock *sk;\n\tint ret;\n\tstruct net *net = dev_net(skb->dev);\n\n\tif (skb->pkt_type != PACKET_HOST)\n\t\tgoto discard_it;\n\n\t/*\n\t *\tCount it even if it's bad.\n\t */\n\t__TCP_INC_STATS(net, TCP_MIB_INSEGS);\n\n\tif (!pskb_may_pull(skb, sizeof(struct tcphdr)))\n\t\tgoto discard_it;\n\n\tth = (const struct tcphdr *)skb->data;\n\n\tif (unlikely(th->doff < sizeof(struct tcphdr)/4))\n\t\tgoto bad_packet;\n\tif (!pskb_may_pull(skb, th->doff*4))\n\t\tgoto discard_it;\n\n\tif (skb_checksum_init(skb, IPPROTO_TCP, ip6_compute_pseudo))\n\t\tgoto csum_error;\n\n\tth = (const struct tcphdr *)skb->data;\n\thdr = ipv6_hdr(skb);\n\nlookup:\n\tsk = __inet6_lookup_skb(&tcp_hashinfo, skb, __tcp_hdrlen(th),\n\t\t\t\tth->source, th->dest, inet6_iif(skb),\n\t\t\t\t&refcounted);\n\tif (!sk)\n\t\tgoto no_tcp_socket;\n\nprocess:\n\tif (sk->sk_state == TCP_TIME_WAIT)\n\t\tgoto do_time_wait;\n\n\tif (sk->sk_state == TCP_NEW_SYN_RECV) {\n\t\tstruct request_sock *req = inet_reqsk(sk);\n\t\tstruct sock *nsk;\n\n\t\tsk = req->rsk_listener;\n\t\ttcp_v6_fill_cb(skb, hdr, th);\n\t\tif (tcp_v6_inbound_md5_hash(sk, skb)) {\n\t\t\tsk_drops_add(sk, skb);\n\t\t\treqsk_put(req);\n\t\t\tgoto discard_it;\n\t\t}\n\t\tif (unlikely(sk->sk_state != TCP_LISTEN)) {\n\t\t\tinet_csk_reqsk_queue_drop_and_put(sk, req);\n\t\t\tgoto lookup;\n\t\t}\n\t\tsock_hold(sk);\n\t\trefcounted = true;\n\t\tnsk = tcp_check_req(sk, skb, req, false);\n\t\tif (!nsk) {\n\t\t\treqsk_put(req);\n\t\t\tgoto discard_and_relse;\n\t\t}\n\t\tif (nsk == sk) {\n\t\t\treqsk_put(req);\n\t\t\ttcp_v6_restore_cb(skb);\n\t\t} else if (tcp_child_process(sk, nsk, skb)) {\n\t\t\ttcp_v6_send_reset(nsk, skb);\n\t\t\tgoto discard_and_relse;\n\t\t} else {\n\t\t\tsock_put(sk);\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif (hdr->hop_limit < inet6_sk(sk)->min_hopcount) {\n\t\t__NET_INC_STATS(net, LINUX_MIB_TCPMINTTLDROP);\n\t\tgoto discard_and_relse;\n\t}\n\n\tif (!xfrm6_policy_check(sk, XFRM_POLICY_IN, skb))\n\t\tgoto discard_and_relse;\n\n\ttcp_v6_fill_cb(skb, hdr, th);\n\n\tif (tcp_v6_inbound_md5_hash(sk, skb))\n\t\tgoto discard_and_relse;\n\n\tif (tcp_filter(sk, skb))\n\t\tgoto discard_and_relse;\n\tth = (const struct tcphdr *)skb->data;\n\thdr = ipv6_hdr(skb);\n\n\tskb->dev = NULL;\n\n\tif (sk->sk_state == TCP_LISTEN) {\n\t\tret = tcp_v6_do_rcv(sk, skb);\n\t\tgoto put_and_return;\n\t}\n\n\tsk_incoming_cpu_update(sk);\n\n\tbh_lock_sock_nested(sk);\n\ttcp_segs_in(tcp_sk(sk), skb);\n\tret = 0;\n\tif (!sock_owned_by_user(sk)) {\n\t\tif (!tcp_prequeue(sk, skb))\n\t\t\tret = tcp_v6_do_rcv(sk, skb);\n\t} else if (tcp_add_backlog(sk, skb)) {\n\t\tgoto discard_and_relse;\n\t}\n\tbh_unlock_sock(sk);\n\nput_and_return:\n\tif (refcounted)\n\t\tsock_put(sk);\n\treturn ret ? -1 : 0;\n\nno_tcp_socket:\n\tif (!xfrm6_policy_check(NULL, XFRM_POLICY_IN, skb))\n\t\tgoto discard_it;\n\n\ttcp_v6_fill_cb(skb, hdr, th);\n\n\tif (tcp_checksum_complete(skb)) {\ncsum_error:\n\t\t__TCP_INC_STATS(net, TCP_MIB_CSUMERRORS);\nbad_packet:\n\t\t__TCP_INC_STATS(net, TCP_MIB_INERRS);\n\t} else {\n\t\ttcp_v6_send_reset(NULL, skb);\n\t}\n\ndiscard_it:\n\tkfree_skb(skb);\n\treturn 0;\n\ndiscard_and_relse:\n\tsk_drops_add(sk, skb);\n\tif (refcounted)\n\t\tsock_put(sk);\n\tgoto discard_it;\n\ndo_time_wait:\n\tif (!xfrm6_policy_check(NULL, XFRM_POLICY_IN, skb)) {\n\t\tinet_twsk_put(inet_twsk(sk));\n\t\tgoto discard_it;\n\t}\n\n\ttcp_v6_fill_cb(skb, hdr, th);\n\n\tif (tcp_checksum_complete(skb)) {\n\t\tinet_twsk_put(inet_twsk(sk));\n\t\tgoto csum_error;\n\t}\n\n\tswitch (tcp_timewait_state_process(inet_twsk(sk), skb, th)) {\n\tcase TCP_TW_SYN:\n\t{\n\t\tstruct sock *sk2;\n\n\t\tsk2 = inet6_lookup_listener(dev_net(skb->dev), &tcp_hashinfo,\n\t\t\t\t\t    skb, __tcp_hdrlen(th),\n\t\t\t\t\t    &ipv6_hdr(skb)->saddr, th->source,\n\t\t\t\t\t    &ipv6_hdr(skb)->daddr,\n\t\t\t\t\t    ntohs(th->dest), tcp_v6_iif(skb));\n\t\tif (sk2) {\n\t\t\tstruct inet_timewait_sock *tw = inet_twsk(sk);\n\t\t\tinet_twsk_deschedule_put(tw);\n\t\t\tsk = sk2;\n\t\t\ttcp_v6_restore_cb(skb);\n\t\t\trefcounted = false;\n\t\t\tgoto process;\n\t\t}\n\t\t/* Fall through to ACK */\n\t}\n\tcase TCP_TW_ACK:\n\t\ttcp_v6_timewait_ack(sk, skb);\n\t\tbreak;\n\tcase TCP_TW_RST:\n\t\ttcp_v6_restore_cb(skb);\n\t\ttcp_v6_send_reset(sk, skb);\n\t\tinet_twsk_deschedule_put(inet_twsk(sk));\n\t\tgoto discard_it;\n\tcase TCP_TW_SUCCESS:\n\t\t;\n\t}\n\tgoto discard_it;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -88,8 +88,10 @@\n \tif (tcp_v6_inbound_md5_hash(sk, skb))\n \t\tgoto discard_and_relse;\n \n-\tif (sk_filter(sk, skb))\n+\tif (tcp_filter(sk, skb))\n \t\tgoto discard_and_relse;\n+\tth = (const struct tcphdr *)skb->data;\n+\thdr = ipv6_hdr(skb);\n \n \tskb->dev = NULL;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (sk_filter(sk, skb))"
            ],
            "added_lines": [
                "\tif (tcp_filter(sk, skb))",
                "\tth = (const struct tcphdr *)skb->data;",
                "\thdr = ipv6_hdr(skb);"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-7945",
        "func_name": "xorg/lib/libXi/XGetDeviceControl",
        "description": "Multiple integer overflows in X.org libXi before 1.7.7 allow remote X servers to cause a denial of service (out-of-bounds memory access or infinite loop) via vectors involving length fields.",
        "git_url": "https://cgit.freedesktop.org/xorg/lib/libXi/commit/?id=19a9cd607de73947fcfb104682f203ffe4e1f4e5",
        "commit_title": "By validating length fields from server responses, out of boundary",
        "commit_text": "accesses and endless loops can be mitigated.  ",
        "func_before": "XDeviceControl *\nXGetDeviceControl(\n    register Display\t*dpy,\n    XDevice\t\t*dev,\n    int\t\t\t control)\n{\n    XDeviceControl *Device = NULL;\n    XDeviceControl *Sav = NULL;\n    xDeviceState *d = NULL;\n    xDeviceState *sav = NULL;\n    xGetDeviceControlReq *req;\n    xGetDeviceControlReply rep;\n    XExtDisplayInfo *info = XInput_find_display(dpy);\n\n    LockDisplay(dpy);\n    if (_XiCheckExtInit(dpy, XInput_Add_XChangeDeviceControl, info) == -1)\n        return NULL;\n\n    GetReq(GetDeviceControl, req);\n    req->reqType = info->codes->major_opcode;\n    req->ReqType = X_GetDeviceControl;\n    req->deviceid = dev->device_id;\n    req->control = control;\n\n    if (!_XReply(dpy, (xReply *) & rep, 0, xFalse))\n\tgoto out;\n\n    if (rep.length > 0) {\n\tunsigned long nbytes;\n\tsize_t size = 0;\n\tif (rep.length < (INT_MAX >> 2)) {\n\t    nbytes = (unsigned long) rep.length << 2;\n\t    d = Xmalloc(nbytes);\n\t}\n\tif (!d) {\n\t    _XEatDataWords(dpy, rep.length);\n\t    goto out;\n\t}\n\tsav = d;\n\t_XRead(dpy, (char *)d, nbytes);\n\n        /* In theory, we should just be able to use d->length to get the size.\n         * Turns out that a number of X servers (up to and including server\n         * 1.4) sent the wrong length value down the wire. So to not break\n         * apps that run against older servers, we have to calculate the size\n         * manually.\n         */\n\tswitch (d->control) {\n\tcase DEVICE_RESOLUTION:\n\t{\n\t    xDeviceResolutionState *r;\n\t    size_t val_size;\n\n\t    r = (xDeviceResolutionState *) d;\n\t    if (r->num_valuators >= (INT_MAX / (3 * sizeof(int))))\n\t\tgoto out;\n\t    val_size = 3 * sizeof(int) * r->num_valuators;\n\t    if ((sizeof(xDeviceResolutionState) + val_size) > nbytes)\n\t\tgoto out;\n\t    size = sizeof(XDeviceResolutionState) + val_size;\n\t    break;\n\t}\n        case DEVICE_ABS_CALIB:\n        {\n            if (sizeof(xDeviceAbsCalibState) > nbytes)\n                goto out;\n            size = sizeof(XDeviceAbsCalibState);\n            break;\n        }\n        case DEVICE_ABS_AREA:\n        {\n            if (sizeof(xDeviceAbsAreaState) > nbytes)\n                goto out;\n            size = sizeof(XDeviceAbsAreaState);\n            break;\n        }\n        case DEVICE_CORE:\n        {\n            if (sizeof(xDeviceCoreState) > nbytes)\n                goto out;\n            size = sizeof(XDeviceCoreState);\n            break;\n        }\n\tdefault:\n\t    if (d->length > nbytes)\n\t\tgoto out;\n\t    size = d->length;\n\t    break;\n\t}\n\n\tDevice = Xmalloc(size);\n\tif (!Device)\n\t    goto out;\n\n\tSav = Device;\n\n\td = sav;\n\tswitch (control) {\n\tcase DEVICE_RESOLUTION:\n\t{\n\t    int *iptr, *iptr2;\n\t    xDeviceResolutionState *r;\n\t    XDeviceResolutionState *R;\n\t    unsigned int i;\n\n\t    r = (xDeviceResolutionState *) d;\n\t    R = (XDeviceResolutionState *) Device;\n\n\t    R->control = DEVICE_RESOLUTION;\n\t    R->length = sizeof(XDeviceResolutionState);\n\t    R->num_valuators = r->num_valuators;\n\t    iptr = (int *)(R + 1);\n\t    iptr2 = (int *)(r + 1);\n\t    R->resolutions = iptr;\n\t    R->min_resolutions = iptr + R->num_valuators;\n\t    R->max_resolutions = iptr + (2 * R->num_valuators);\n\t    for (i = 0; i < (3 * R->num_valuators); i++)\n\t\t*iptr++ = *iptr2++;\n\t    break;\n\t}\n        case DEVICE_ABS_CALIB:\n        {\n            xDeviceAbsCalibState *c = (xDeviceAbsCalibState *) d;\n            XDeviceAbsCalibState *C = (XDeviceAbsCalibState *) Device;\n\n            C->control = DEVICE_ABS_CALIB;\n            C->length = sizeof(XDeviceAbsCalibState);\n            C->min_x = c->min_x;\n            C->max_x = c->max_x;\n            C->min_y = c->min_y;\n            C->max_y = c->max_y;\n            C->flip_x = c->flip_x;\n            C->flip_y = c->flip_y;\n            C->rotation = c->rotation;\n            C->button_threshold = c->button_threshold;\n\n            break;\n        }\n        case DEVICE_ABS_AREA:\n        {\n            xDeviceAbsAreaState *a = (xDeviceAbsAreaState *) d;\n            XDeviceAbsAreaState *A = (XDeviceAbsAreaState *) Device;\n\n            A->control = DEVICE_ABS_AREA;\n            A->length = sizeof(XDeviceAbsAreaState);\n            A->offset_x = a->offset_x;\n            A->offset_y = a->offset_y;\n            A->width = a->width;\n            A->height = a->height;\n            A->screen = a->screen;\n            A->following = a->following;\n\n            break;\n        }\n        case DEVICE_CORE:\n        {\n            xDeviceCoreState *c = (xDeviceCoreState *) d;\n            XDeviceCoreState *C = (XDeviceCoreState *) Device;\n\n            C->control = DEVICE_CORE;\n            C->length = sizeof(XDeviceCoreState);\n            C->status = c->status;\n            C->iscore = c->iscore;\n\n            break;\n        }\n        case DEVICE_ENABLE:\n        {\n            xDeviceEnableState *e = (xDeviceEnableState *) d;\n            XDeviceEnableState *E = (XDeviceEnableState *) Device;\n\n            E->control = DEVICE_ENABLE;\n            E->length = sizeof(E);\n            E->enable = e->enable;\n\n            break;\n        }\n\tdefault:\n\t    break;\n\t}\n    }\nout:\n    XFree(sav);\n\n    UnlockDisplay(dpy);\n    SyncHandle();\n    return (Sav);\n}",
        "func": "XDeviceControl *\nXGetDeviceControl(\n    register Display\t*dpy,\n    XDevice\t\t*dev,\n    int\t\t\t control)\n{\n    XDeviceControl *Device = NULL;\n    XDeviceControl *Sav = NULL;\n    xDeviceState *d = NULL;\n    xDeviceState *sav = NULL;\n    xGetDeviceControlReq *req;\n    xGetDeviceControlReply rep;\n    XExtDisplayInfo *info = XInput_find_display(dpy);\n\n    LockDisplay(dpy);\n    if (_XiCheckExtInit(dpy, XInput_Add_XChangeDeviceControl, info) == -1)\n        return NULL;\n\n    GetReq(GetDeviceControl, req);\n    req->reqType = info->codes->major_opcode;\n    req->ReqType = X_GetDeviceControl;\n    req->deviceid = dev->device_id;\n    req->control = control;\n\n    if (!_XReply(dpy, (xReply *) & rep, 0, xFalse))\n\tgoto out;\n\n    if (rep.length > 0) {\n\tunsigned long nbytes;\n\tsize_t size = 0;\n\tif (rep.length < (INT_MAX >> 2) &&\n\t    (rep.length << 2) >= sizeof(xDeviceState)) {\n\t    nbytes = (unsigned long) rep.length << 2;\n\t    d = Xmalloc(nbytes);\n\t}\n\tif (!d) {\n\t    _XEatDataWords(dpy, rep.length);\n\t    goto out;\n\t}\n\tsav = d;\n\t_XRead(dpy, (char *)d, nbytes);\n\n        /* In theory, we should just be able to use d->length to get the size.\n         * Turns out that a number of X servers (up to and including server\n         * 1.4) sent the wrong length value down the wire. So to not break\n         * apps that run against older servers, we have to calculate the size\n         * manually.\n         */\n\tswitch (d->control) {\n\tcase DEVICE_RESOLUTION:\n\t{\n\t    xDeviceResolutionState *r;\n\t    size_t val_size;\n\n\t    r = (xDeviceResolutionState *) d;\n\t    if (sizeof(xDeviceResolutionState) > nbytes ||\n\t\tr->num_valuators >= (INT_MAX / (3 * sizeof(int))))\n\t\tgoto out;\n\t    val_size = 3 * sizeof(int) * r->num_valuators;\n\t    if ((sizeof(xDeviceResolutionState) + val_size) > nbytes)\n\t\tgoto out;\n\t    size = sizeof(XDeviceResolutionState) + val_size;\n\t    break;\n\t}\n        case DEVICE_ABS_CALIB:\n        {\n            if (sizeof(xDeviceAbsCalibState) > nbytes)\n                goto out;\n            size = sizeof(XDeviceAbsCalibState);\n            break;\n        }\n        case DEVICE_ABS_AREA:\n        {\n            if (sizeof(xDeviceAbsAreaState) > nbytes)\n                goto out;\n            size = sizeof(XDeviceAbsAreaState);\n            break;\n        }\n        case DEVICE_CORE:\n        {\n            if (sizeof(xDeviceCoreState) > nbytes)\n                goto out;\n            size = sizeof(XDeviceCoreState);\n            break;\n        }\n\tdefault:\n\t    if (d->length > nbytes)\n\t\tgoto out;\n\t    size = d->length;\n\t    break;\n\t}\n\n\tDevice = Xmalloc(size);\n\tif (!Device)\n\t    goto out;\n\n\tSav = Device;\n\n\td = sav;\n\tswitch (control) {\n\tcase DEVICE_RESOLUTION:\n\t{\n\t    int *iptr, *iptr2;\n\t    xDeviceResolutionState *r;\n\t    XDeviceResolutionState *R;\n\t    unsigned int i;\n\n\t    r = (xDeviceResolutionState *) d;\n\t    R = (XDeviceResolutionState *) Device;\n\n\t    R->control = DEVICE_RESOLUTION;\n\t    R->length = sizeof(XDeviceResolutionState);\n\t    R->num_valuators = r->num_valuators;\n\t    iptr = (int *)(R + 1);\n\t    iptr2 = (int *)(r + 1);\n\t    R->resolutions = iptr;\n\t    R->min_resolutions = iptr + R->num_valuators;\n\t    R->max_resolutions = iptr + (2 * R->num_valuators);\n\t    for (i = 0; i < (3 * R->num_valuators); i++)\n\t\t*iptr++ = *iptr2++;\n\t    break;\n\t}\n        case DEVICE_ABS_CALIB:\n        {\n            xDeviceAbsCalibState *c = (xDeviceAbsCalibState *) d;\n            XDeviceAbsCalibState *C = (XDeviceAbsCalibState *) Device;\n\n            C->control = DEVICE_ABS_CALIB;\n            C->length = sizeof(XDeviceAbsCalibState);\n            C->min_x = c->min_x;\n            C->max_x = c->max_x;\n            C->min_y = c->min_y;\n            C->max_y = c->max_y;\n            C->flip_x = c->flip_x;\n            C->flip_y = c->flip_y;\n            C->rotation = c->rotation;\n            C->button_threshold = c->button_threshold;\n\n            break;\n        }\n        case DEVICE_ABS_AREA:\n        {\n            xDeviceAbsAreaState *a = (xDeviceAbsAreaState *) d;\n            XDeviceAbsAreaState *A = (XDeviceAbsAreaState *) Device;\n\n            A->control = DEVICE_ABS_AREA;\n            A->length = sizeof(XDeviceAbsAreaState);\n            A->offset_x = a->offset_x;\n            A->offset_y = a->offset_y;\n            A->width = a->width;\n            A->height = a->height;\n            A->screen = a->screen;\n            A->following = a->following;\n\n            break;\n        }\n        case DEVICE_CORE:\n        {\n            xDeviceCoreState *c = (xDeviceCoreState *) d;\n            XDeviceCoreState *C = (XDeviceCoreState *) Device;\n\n            C->control = DEVICE_CORE;\n            C->length = sizeof(XDeviceCoreState);\n            C->status = c->status;\n            C->iscore = c->iscore;\n\n            break;\n        }\n        case DEVICE_ENABLE:\n        {\n            xDeviceEnableState *e = (xDeviceEnableState *) d;\n            XDeviceEnableState *E = (XDeviceEnableState *) Device;\n\n            E->control = DEVICE_ENABLE;\n            E->length = sizeof(E);\n            E->enable = e->enable;\n\n            break;\n        }\n\tdefault:\n\t    break;\n\t}\n    }\nout:\n    XFree(sav);\n\n    UnlockDisplay(dpy);\n    SyncHandle();\n    return (Sav);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -28,7 +28,8 @@\n     if (rep.length > 0) {\n \tunsigned long nbytes;\n \tsize_t size = 0;\n-\tif (rep.length < (INT_MAX >> 2)) {\n+\tif (rep.length < (INT_MAX >> 2) &&\n+\t    (rep.length << 2) >= sizeof(xDeviceState)) {\n \t    nbytes = (unsigned long) rep.length << 2;\n \t    d = Xmalloc(nbytes);\n \t}\n@@ -52,7 +53,8 @@\n \t    size_t val_size;\n \n \t    r = (xDeviceResolutionState *) d;\n-\t    if (r->num_valuators >= (INT_MAX / (3 * sizeof(int))))\n+\t    if (sizeof(xDeviceResolutionState) > nbytes ||\n+\t\tr->num_valuators >= (INT_MAX / (3 * sizeof(int))))\n \t\tgoto out;\n \t    val_size = 3 * sizeof(int) * r->num_valuators;\n \t    if ((sizeof(xDeviceResolutionState) + val_size) > nbytes)",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (rep.length < (INT_MAX >> 2)) {",
                "\t    if (r->num_valuators >= (INT_MAX / (3 * sizeof(int))))"
            ],
            "added_lines": [
                "\tif (rep.length < (INT_MAX >> 2) &&",
                "\t    (rep.length << 2) >= sizeof(xDeviceState)) {",
                "\t    if (sizeof(xDeviceResolutionState) > nbytes ||",
                "\t\tr->num_valuators >= (INT_MAX / (3 * sizeof(int))))"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-7945",
        "func_name": "xorg/lib/libXi/XListInputDevices",
        "description": "Multiple integer overflows in X.org libXi before 1.7.7 allow remote X servers to cause a denial of service (out-of-bounds memory access or infinite loop) via vectors involving length fields.",
        "git_url": "https://cgit.freedesktop.org/xorg/lib/libXi/commit/?id=19a9cd607de73947fcfb104682f203ffe4e1f4e5",
        "commit_title": "By validating length fields from server responses, out of boundary",
        "commit_text": "accesses and endless loops can be mitigated.  ",
        "func_before": "XDeviceInfo *\nXListInputDevices(\n    register Display\t*dpy,\n    int\t\t\t*ndevices)\n{\n    size_t size;\n    xListInputDevicesReq *req;\n    xListInputDevicesReply rep;\n    xDeviceInfo *list, *slist = NULL;\n    XDeviceInfo *sclist = NULL;\n    XDeviceInfo *clist = NULL;\n    xAnyClassPtr any, sav_any;\n    XAnyClassPtr Any;\n    unsigned char *nptr, *Nptr;\n    int i;\n    unsigned long rlen;\n    XExtDisplayInfo *info = XInput_find_display(dpy);\n\n    LockDisplay(dpy);\n    if (_XiCheckExtInit(dpy, XInput_Initial_Release, info) == -1)\n\treturn ((XDeviceInfo *) NULL);\n\n    GetReq(ListInputDevices, req);\n    req->reqType = info->codes->major_opcode;\n    req->ReqType = X_ListInputDevices;\n\n    if (!_XReply(dpy, (xReply *) & rep, 0, xFalse)) {\n\tUnlockDisplay(dpy);\n\tSyncHandle();\n\treturn (XDeviceInfo *) NULL;\n    }\n\n    if ((*ndevices = rep.ndevices)) {\t/* at least 1 input device */\n\tsize = *ndevices * sizeof(XDeviceInfo);\n\tif (rep.length < (INT_MAX >> 2)) {\n\t    rlen = rep.length << 2;\t/* multiply length by 4    */\n\t    slist = list = Xmalloc(rlen);\n\t}\n\tif (!slist) {\n\t    _XEatDataWords(dpy, rep.length);\n\t    UnlockDisplay(dpy);\n\t    SyncHandle();\n\t    return (XDeviceInfo *) NULL;\n\t}\n\t_XRead(dpy, (char *)list, rlen);\n\n\tany = (xAnyClassPtr) ((char *)list + (*ndevices * sizeof(xDeviceInfo)));\n\tsav_any = any;\n\tfor (i = 0; i < *ndevices; i++, list++) {\n            size += SizeClassInfo(&any, (int)list->num_classes);\n\t}\n\n\tNptr = ((unsigned char *)list) + rlen + 1;\n\tfor (i = 0, nptr = (unsigned char *)any; i < *ndevices; i++) {\n\t    size += *nptr + 1;\n\t    nptr += (*nptr + 1);\n\t    if (nptr > Nptr)\n\t\tgoto out;\n\t}\n\n\tclist = (XDeviceInfoPtr) Xmalloc(size);\n\tif (!clist) {\n\t    XFree((char *)slist);\n\t    UnlockDisplay(dpy);\n\t    SyncHandle();\n\t    return (XDeviceInfo *) NULL;\n\t}\n\tsclist = clist;\n\tAny = (XAnyClassPtr) ((char *)clist +\n\t\t\t      (*ndevices * sizeof(XDeviceInfo)));\n\tlist = slist;\n\tany = sav_any;\n\tfor (i = 0; i < *ndevices; i++, list++, clist++) {\n\t    clist->type = list->type;\n\t    clist->id = list->id;\n\t    clist->use = list->use;\n\t    clist->num_classes = list->num_classes;\n\t    clist->inputclassinfo = Any;\n\n            ParseClassInfo(&any, &Any, (int)list->num_classes);\n\t}\n\n\tclist = sclist;\n\tnptr = (unsigned char *)any;\n\tNptr = (unsigned char *)Any;\n\tfor (i = 0; i < *ndevices; i++, clist++) {\n\t    clist->name = (char *)Nptr;\n\t    memcpy(Nptr, nptr + 1, *nptr);\n\t    Nptr += (*nptr);\n\t    *Nptr++ = '\\0';\n\t    nptr += (*nptr + 1);\n\t}\n    }\n\n  out:\n    XFree((char *)slist);\n    UnlockDisplay(dpy);\n    SyncHandle();\n    return (sclist);\n}",
        "func": "XDeviceInfo *\nXListInputDevices(\n    register Display\t*dpy,\n    int\t\t\t*ndevices)\n{\n    size_t s, size;\n    xListInputDevicesReq *req;\n    xListInputDevicesReply rep;\n    xDeviceInfo *list, *slist = NULL;\n    XDeviceInfo *sclist = NULL;\n    XDeviceInfo *clist = NULL;\n    xAnyClassPtr any, sav_any;\n    XAnyClassPtr Any;\n    char *end = NULL;\n    unsigned char *nptr, *Nptr;\n    int i;\n    unsigned long rlen;\n    XExtDisplayInfo *info = XInput_find_display(dpy);\n\n    LockDisplay(dpy);\n    if (_XiCheckExtInit(dpy, XInput_Initial_Release, info) == -1)\n\treturn ((XDeviceInfo *) NULL);\n\n    GetReq(ListInputDevices, req);\n    req->reqType = info->codes->major_opcode;\n    req->ReqType = X_ListInputDevices;\n\n    if (!_XReply(dpy, (xReply *) & rep, 0, xFalse)) {\n\tUnlockDisplay(dpy);\n\tSyncHandle();\n\treturn (XDeviceInfo *) NULL;\n    }\n\n    if ((*ndevices = rep.ndevices)) {\t/* at least 1 input device */\n\tsize = *ndevices * sizeof(XDeviceInfo);\n\tif (rep.length < (INT_MAX >> 2)) {\n\t    rlen = rep.length << 2;\t/* multiply length by 4    */\n\t    slist = list = Xmalloc(rlen);\n\t}\n\tif (!slist) {\n\t    _XEatDataWords(dpy, rep.length);\n\t    UnlockDisplay(dpy);\n\t    SyncHandle();\n\t    return (XDeviceInfo *) NULL;\n\t}\n\t_XRead(dpy, (char *)list, rlen);\n\n\tany = (xAnyClassPtr) ((char *)list + (*ndevices * sizeof(xDeviceInfo)));\n\tsav_any = any;\n\tend = (char *)list + rlen;\n\tfor (i = 0; i < *ndevices; i++, list++) {\n            s = SizeClassInfo(&any, end - (char *)any, (int)list->num_classes);\n            if (!s)\n                goto out;\n            size += s;\n\t}\n\n\tNptr = ((unsigned char *)list) + rlen;\n\tfor (i = 0, nptr = (unsigned char *)any; i < *ndevices; i++) {\n\t    if (nptr >= Nptr)\n\t\tgoto out;\n\t    size += *nptr + 1;\n\t    nptr += (*nptr + 1);\n\t}\n\n\tclist = (XDeviceInfoPtr) Xmalloc(size);\n\tif (!clist) {\n\t    XFree((char *)slist);\n\t    UnlockDisplay(dpy);\n\t    SyncHandle();\n\t    return (XDeviceInfo *) NULL;\n\t}\n\tsclist = clist;\n\tAny = (XAnyClassPtr) ((char *)clist +\n\t\t\t      (*ndevices * sizeof(XDeviceInfo)));\n\tlist = slist;\n\tany = sav_any;\n\tfor (i = 0; i < *ndevices; i++, list++, clist++) {\n\t    clist->type = list->type;\n\t    clist->id = list->id;\n\t    clist->use = list->use;\n\t    clist->num_classes = list->num_classes;\n\t    clist->inputclassinfo = Any;\n\n            ParseClassInfo(&any, &Any, (int)list->num_classes);\n\t}\n\n\tclist = sclist;\n\tnptr = (unsigned char *)any;\n\tNptr = (unsigned char *)Any;\n\tfor (i = 0; i < *ndevices; i++, clist++) {\n\t    clist->name = (char *)Nptr;\n\t    memcpy(Nptr, nptr + 1, *nptr);\n\t    Nptr += (*nptr);\n\t    *Nptr++ = '\\0';\n\t    nptr += (*nptr + 1);\n\t}\n    }\n\n  out:\n    XFree((char *)slist);\n    UnlockDisplay(dpy);\n    SyncHandle();\n    return (sclist);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,7 +3,7 @@\n     register Display\t*dpy,\n     int\t\t\t*ndevices)\n {\n-    size_t size;\n+    size_t s, size;\n     xListInputDevicesReq *req;\n     xListInputDevicesReply rep;\n     xDeviceInfo *list, *slist = NULL;\n@@ -11,6 +11,7 @@\n     XDeviceInfo *clist = NULL;\n     xAnyClassPtr any, sav_any;\n     XAnyClassPtr Any;\n+    char *end = NULL;\n     unsigned char *nptr, *Nptr;\n     int i;\n     unsigned long rlen;\n@@ -46,16 +47,20 @@\n \n \tany = (xAnyClassPtr) ((char *)list + (*ndevices * sizeof(xDeviceInfo)));\n \tsav_any = any;\n+\tend = (char *)list + rlen;\n \tfor (i = 0; i < *ndevices; i++, list++) {\n-            size += SizeClassInfo(&any, (int)list->num_classes);\n+            s = SizeClassInfo(&any, end - (char *)any, (int)list->num_classes);\n+            if (!s)\n+                goto out;\n+            size += s;\n \t}\n \n-\tNptr = ((unsigned char *)list) + rlen + 1;\n+\tNptr = ((unsigned char *)list) + rlen;\n \tfor (i = 0, nptr = (unsigned char *)any; i < *ndevices; i++) {\n+\t    if (nptr >= Nptr)\n+\t\tgoto out;\n \t    size += *nptr + 1;\n \t    nptr += (*nptr + 1);\n-\t    if (nptr > Nptr)\n-\t\tgoto out;\n \t}\n \n \tclist = (XDeviceInfoPtr) Xmalloc(size);",
        "diff_line_info": {
            "deleted_lines": [
                "    size_t size;",
                "            size += SizeClassInfo(&any, (int)list->num_classes);",
                "\tNptr = ((unsigned char *)list) + rlen + 1;",
                "\t    if (nptr > Nptr)",
                "\t\tgoto out;"
            ],
            "added_lines": [
                "    size_t s, size;",
                "    char *end = NULL;",
                "\tend = (char *)list + rlen;",
                "            s = SizeClassInfo(&any, end - (char *)any, (int)list->num_classes);",
                "            if (!s)",
                "                goto out;",
                "            size += s;",
                "\tNptr = ((unsigned char *)list) + rlen;",
                "\t    if (nptr >= Nptr)",
                "\t\tgoto out;"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-7945",
        "func_name": "xorg/lib/libXi/SizeClassInfo",
        "description": "Multiple integer overflows in X.org libXi before 1.7.7 allow remote X servers to cause a denial of service (out-of-bounds memory access or infinite loop) via vectors involving length fields.",
        "git_url": "https://cgit.freedesktop.org/xorg/lib/libXi/commit/?id=19a9cd607de73947fcfb104682f203ffe4e1f4e5",
        "commit_title": "By validating length fields from server responses, out of boundary",
        "commit_text": "accesses and endless loops can be mitigated.  ",
        "func_before": "static size_t\nSizeClassInfo(xAnyClassPtr *any, int num_classes)\n{\n    int size = 0;\n    int j;\n    for (j = 0; j < num_classes; j++) {\n        switch ((*any)->class) {\n            case KeyClass:\n                size += pad_to_xid(sizeof(XKeyInfo));\n                break;\n            case ButtonClass:\n                size += pad_to_xid(sizeof(XButtonInfo));\n                break;\n            case ValuatorClass:\n                {\n                    xValuatorInfoPtr v;\n\n                    v = (xValuatorInfoPtr) *any;\n                    size += pad_to_xid(sizeof(XValuatorInfo) +\n                        (v->num_axes * sizeof(XAxisInfo)));\n                    break;\n                }\n            default:\n                break;\n        }\n        *any = (xAnyClassPtr) ((char *)(*any) + (*any)->length);\n    }\n\n    return size;\n}",
        "func": "static size_t\nSizeClassInfo(xAnyClassPtr *any, size_t len, int num_classes)\n{\n    int size = 0;\n    int j;\n    for (j = 0; j < num_classes; j++) {\n        switch ((*any)->class) {\n            case KeyClass:\n                size += pad_to_xid(sizeof(XKeyInfo));\n                break;\n            case ButtonClass:\n                size += pad_to_xid(sizeof(XButtonInfo));\n                break;\n            case ValuatorClass:\n                {\n                    xValuatorInfoPtr v;\n\n                    if (len < sizeof(v))\n                        return 0;\n                    v = (xValuatorInfoPtr) *any;\n                    size += pad_to_xid(sizeof(XValuatorInfo) +\n                        (v->num_axes * sizeof(XAxisInfo)));\n                    break;\n                }\n            default:\n                break;\n        }\n        if ((*any)->length > len)\n            return 0;\n        *any = (xAnyClassPtr) ((char *)(*any) + (*any)->length);\n    }\n\n    return size;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,5 @@\n static size_t\n-SizeClassInfo(xAnyClassPtr *any, int num_classes)\n+SizeClassInfo(xAnyClassPtr *any, size_t len, int num_classes)\n {\n     int size = 0;\n     int j;\n@@ -15,6 +15,8 @@\n                 {\n                     xValuatorInfoPtr v;\n \n+                    if (len < sizeof(v))\n+                        return 0;\n                     v = (xValuatorInfoPtr) *any;\n                     size += pad_to_xid(sizeof(XValuatorInfo) +\n                         (v->num_axes * sizeof(XAxisInfo)));\n@@ -23,6 +25,8 @@\n             default:\n                 break;\n         }\n+        if ((*any)->length > len)\n+            return 0;\n         *any = (xAnyClassPtr) ((char *)(*any) + (*any)->length);\n     }\n ",
        "diff_line_info": {
            "deleted_lines": [
                "SizeClassInfo(xAnyClassPtr *any, int num_classes)"
            ],
            "added_lines": [
                "SizeClassInfo(xAnyClassPtr *any, size_t len, int num_classes)",
                "                    if (len < sizeof(v))",
                "                        return 0;",
                "        if ((*any)->length > len)",
                "            return 0;"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-7945",
        "func_name": "xorg/lib/libXi/XGetFeedbackControl",
        "description": "Multiple integer overflows in X.org libXi before 1.7.7 allow remote X servers to cause a denial of service (out-of-bounds memory access or infinite loop) via vectors involving length fields.",
        "git_url": "https://cgit.freedesktop.org/xorg/lib/libXi/commit/?id=19a9cd607de73947fcfb104682f203ffe4e1f4e5",
        "commit_title": "By validating length fields from server responses, out of boundary",
        "commit_text": "accesses and endless loops can be mitigated.  ",
        "func_before": "XFeedbackState *\nXGetFeedbackControl(\n    register Display\t*dpy,\n    XDevice\t\t*dev,\n    int\t\t\t*num_feedbacks)\n{\n    XFeedbackState *Feedback = NULL;\n    XFeedbackState *Sav = NULL;\n    xFeedbackState *f = NULL;\n    xFeedbackState *sav = NULL;\n    xGetFeedbackControlReq *req;\n    xGetFeedbackControlReply rep;\n    XExtDisplayInfo *info = XInput_find_display(dpy);\n\n    LockDisplay(dpy);\n    if (_XiCheckExtInit(dpy, XInput_Initial_Release, info) == -1)\n        return NULL;\n\n    GetReq(GetFeedbackControl, req);\n    req->reqType = info->codes->major_opcode;\n    req->ReqType = X_GetFeedbackControl;\n    req->deviceid = dev->device_id;\n\n    if (!_XReply(dpy, (xReply *) & rep, 0, xFalse))\n\tgoto out;\n\n    if (rep.length > 0) {\n\tunsigned long nbytes;\n\tsize_t size = 0;\n\tint i;\n\n\t*num_feedbacks = rep.num_feedbacks;\n\n\tif (rep.length < (INT_MAX >> 2)) {\n\t    nbytes = rep.length << 2;\n\t    f = Xmalloc(nbytes);\n\t}\n\tif (!f) {\n\t    _XEatDataWords(dpy, rep.length);\n\t    goto out;\n\t}\n\tsav = f;\n\t_XRead(dpy, (char *)f, nbytes);\n\n\tfor (i = 0; i < *num_feedbacks; i++) {\n\t    if (f->length > nbytes)\n\t\tgoto out;\n\t    nbytes -= f->length;\n\n\t    switch (f->class) {\n\t    case KbdFeedbackClass:\n\t\tsize += sizeof(XKbdFeedbackState);\n\t\tbreak;\n\t    case PtrFeedbackClass:\n\t\tsize += sizeof(XPtrFeedbackState);\n\t\tbreak;\n\t    case IntegerFeedbackClass:\n\t\tsize += sizeof(XIntegerFeedbackState);\n\t\tbreak;\n\t    case StringFeedbackClass:\n\t    {\n\t\txStringFeedbackState *strf = (xStringFeedbackState *) f;\n\t\tsize += sizeof(XStringFeedbackState) +\n\t\t    (strf->num_syms_supported * sizeof(KeySym));\n\t    }\n\t\tbreak;\n\t    case LedFeedbackClass:\n\t\tsize += sizeof(XLedFeedbackState);\n\t\tbreak;\n\t    case BellFeedbackClass:\n\t\tsize += sizeof(XBellFeedbackState);\n\t\tbreak;\n\t    default:\n\t\tsize += f->length;\n\t\tbreak;\n\t    }\n\t    if (size > INT_MAX)\n\t\tgoto out;\n\t    f = (xFeedbackState *) ((char *)f + f->length);\n\t}\n\n\tFeedback = Xmalloc(size);\n\tif (!Feedback)\n\t    goto out;\n\n\tSav = Feedback;\n\n\tf = sav;\n\tfor (i = 0; i < *num_feedbacks; i++) {\n\t    switch (f->class) {\n\t    case KbdFeedbackClass:\n\t    {\n\t\txKbdFeedbackState *k;\n\t\tXKbdFeedbackState *K;\n\n\t\tk = (xKbdFeedbackState *) f;\n\t\tK = (XKbdFeedbackState *) Feedback;\n\n\t\tK->class = k->class;\n\t\tK->length = sizeof(XKbdFeedbackState);\n\t\tK->id = k->id;\n\t\tK->click = k->click;\n\t\tK->percent = k->percent;\n\t\tK->pitch = k->pitch;\n\t\tK->duration = k->duration;\n\t\tK->led_mask = k->led_mask;\n\t\tK->global_auto_repeat = k->global_auto_repeat;\n\t\tmemcpy((char *)&K->auto_repeats[0],\n\t\t       (char *)&k->auto_repeats[0], 32);\n\t\tbreak;\n\t    }\n\t    case PtrFeedbackClass:\n\t    {\n\t\txPtrFeedbackState *p;\n\t\tXPtrFeedbackState *P;\n\n\t\tp = (xPtrFeedbackState *) f;\n\t\tP = (XPtrFeedbackState *) Feedback;\n\n\t\tP->class = p->class;\n\t\tP->length = sizeof(XPtrFeedbackState);\n\t\tP->id = p->id;\n\t\tP->accelNum = p->accelNum;\n\t\tP->accelDenom = p->accelDenom;\n\t\tP->threshold = p->threshold;\n\t\tbreak;\n\t    }\n\t    case IntegerFeedbackClass:\n\t    {\n\t\txIntegerFeedbackState *ifs;\n\t\tXIntegerFeedbackState *I;\n\n\t\tifs = (xIntegerFeedbackState *) f;\n\t\tI = (XIntegerFeedbackState *) Feedback;\n\n\t\tI->class = ifs->class;\n\t\tI->length = sizeof(XIntegerFeedbackState);\n\t\tI->id = ifs->id;\n\t\tI->resolution = ifs->resolution;\n\t\tI->minVal = ifs->min_value;\n\t\tI->maxVal = ifs->max_value;\n\t\tbreak;\n\t    }\n\t    case StringFeedbackClass:\n\t    {\n\t\txStringFeedbackState *s;\n\t\tXStringFeedbackState *S;\n\n\t\ts = (xStringFeedbackState *) f;\n\t\tS = (XStringFeedbackState *) Feedback;\n\n\t\tS->class = s->class;\n\t\tS->length = sizeof(XStringFeedbackState) +\n\t\t    (s->num_syms_supported * sizeof(KeySym));\n\t\tS->id = s->id;\n\t\tS->max_symbols = s->max_symbols;\n\t\tS->num_syms_supported = s->num_syms_supported;\n\t\tS->syms_supported = (KeySym *) (S + 1);\n\t\tmemcpy((char *)S->syms_supported, (char *)(s + 1),\n\t\t       (S->num_syms_supported * sizeof(KeySym)));\n\t\tbreak;\n\t    }\n\t    case LedFeedbackClass:\n\t    {\n\t\txLedFeedbackState *l;\n\t\tXLedFeedbackState *L;\n\n\t\tl = (xLedFeedbackState *) f;\n\t\tL = (XLedFeedbackState *) Feedback;\n\n\t\tL->class = l->class;\n\t\tL->length = sizeof(XLedFeedbackState);\n\t\tL->id = l->id;\n\t\tL->led_values = l->led_values;\n\t\tL->led_mask = l->led_mask;\n\t\tbreak;\n\t    }\n\t    case BellFeedbackClass:\n\t    {\n\t\txBellFeedbackState *b;\n\t\tXBellFeedbackState *B;\n\n\t\tb = (xBellFeedbackState *) f;\n\t\tB = (XBellFeedbackState *) Feedback;\n\n\t\tB->class = b->class;\n\t\tB->length = sizeof(XBellFeedbackState);\n\t\tB->id = b->id;\n\t\tB->percent = b->percent;\n\t\tB->pitch = b->pitch;\n\t\tB->duration = b->duration;\n\t\tbreak;\n\t    }\n\t    default:\n\t\tbreak;\n\t    }\n\t    f = (xFeedbackState *) ((char *)f + f->length);\n\t    Feedback = (XFeedbackState *) ((char *)Feedback + Feedback->length);\n\t}\n    }\nout:\n    XFree((char *)sav);\n\n    UnlockDisplay(dpy);\n    SyncHandle();\n    return (Sav);\n}",
        "func": "XFeedbackState *\nXGetFeedbackControl(\n    register Display\t*dpy,\n    XDevice\t\t*dev,\n    int\t\t\t*num_feedbacks)\n{\n    XFeedbackState *Feedback = NULL;\n    XFeedbackState *Sav = NULL;\n    xFeedbackState *f = NULL;\n    xFeedbackState *sav = NULL;\n    char *end = NULL;\n    xGetFeedbackControlReq *req;\n    xGetFeedbackControlReply rep;\n    XExtDisplayInfo *info = XInput_find_display(dpy);\n\n    LockDisplay(dpy);\n    if (_XiCheckExtInit(dpy, XInput_Initial_Release, info) == -1)\n        return NULL;\n\n    GetReq(GetFeedbackControl, req);\n    req->reqType = info->codes->major_opcode;\n    req->ReqType = X_GetFeedbackControl;\n    req->deviceid = dev->device_id;\n\n    if (!_XReply(dpy, (xReply *) & rep, 0, xFalse))\n\tgoto out;\n\n    if (rep.length > 0) {\n\tunsigned long nbytes;\n\tsize_t size = 0;\n\tint i;\n\n\t*num_feedbacks = rep.num_feedbacks;\n\n\tif (rep.length < (INT_MAX >> 2)) {\n\t    nbytes = rep.length << 2;\n\t    f = Xmalloc(nbytes);\n\t}\n\tif (!f) {\n\t    _XEatDataWords(dpy, rep.length);\n\t    goto out;\n\t}\n\tsav = f;\n\tend = (char *)f + nbytes;\n\t_XRead(dpy, (char *)f, nbytes);\n\n\tfor (i = 0; i < *num_feedbacks; i++) {\n\t    if ((char *)f + sizeof(*f) > end ||\n\t        f->length == 0 || f->length > nbytes)\n\t\tgoto out;\n\t    nbytes -= f->length;\n\n\t    switch (f->class) {\n\t    case KbdFeedbackClass:\n\t\tsize += sizeof(XKbdFeedbackState);\n\t\tbreak;\n\t    case PtrFeedbackClass:\n\t\tsize += sizeof(XPtrFeedbackState);\n\t\tbreak;\n\t    case IntegerFeedbackClass:\n\t\tsize += sizeof(XIntegerFeedbackState);\n\t\tbreak;\n\t    case StringFeedbackClass:\n\t    {\n\t\txStringFeedbackState *strf = (xStringFeedbackState *) f;\n\t\tif ((char *)f + sizeof(*strf) > end)\n\t\t    goto out;\n\t\tsize += sizeof(XStringFeedbackState) +\n\t\t    (strf->num_syms_supported * sizeof(KeySym));\n\t    }\n\t\tbreak;\n\t    case LedFeedbackClass:\n\t\tsize += sizeof(XLedFeedbackState);\n\t\tbreak;\n\t    case BellFeedbackClass:\n\t\tsize += sizeof(XBellFeedbackState);\n\t\tbreak;\n\t    default:\n\t\tsize += f->length;\n\t\tbreak;\n\t    }\n\t    if (size > INT_MAX)\n\t\tgoto out;\n\t    f = (xFeedbackState *) ((char *)f + f->length);\n\t}\n\n\tFeedback = Xmalloc(size);\n\tif (!Feedback)\n\t    goto out;\n\n\tSav = Feedback;\n\n\tf = sav;\n\tfor (i = 0; i < *num_feedbacks; i++) {\n\t    switch (f->class) {\n\t    case KbdFeedbackClass:\n\t    {\n\t\txKbdFeedbackState *k;\n\t\tXKbdFeedbackState *K;\n\n\t\tk = (xKbdFeedbackState *) f;\n\t\tK = (XKbdFeedbackState *) Feedback;\n\n\t\tK->class = k->class;\n\t\tK->length = sizeof(XKbdFeedbackState);\n\t\tK->id = k->id;\n\t\tK->click = k->click;\n\t\tK->percent = k->percent;\n\t\tK->pitch = k->pitch;\n\t\tK->duration = k->duration;\n\t\tK->led_mask = k->led_mask;\n\t\tK->global_auto_repeat = k->global_auto_repeat;\n\t\tmemcpy((char *)&K->auto_repeats[0],\n\t\t       (char *)&k->auto_repeats[0], 32);\n\t\tbreak;\n\t    }\n\t    case PtrFeedbackClass:\n\t    {\n\t\txPtrFeedbackState *p;\n\t\tXPtrFeedbackState *P;\n\n\t\tp = (xPtrFeedbackState *) f;\n\t\tP = (XPtrFeedbackState *) Feedback;\n\n\t\tP->class = p->class;\n\t\tP->length = sizeof(XPtrFeedbackState);\n\t\tP->id = p->id;\n\t\tP->accelNum = p->accelNum;\n\t\tP->accelDenom = p->accelDenom;\n\t\tP->threshold = p->threshold;\n\t\tbreak;\n\t    }\n\t    case IntegerFeedbackClass:\n\t    {\n\t\txIntegerFeedbackState *ifs;\n\t\tXIntegerFeedbackState *I;\n\n\t\tifs = (xIntegerFeedbackState *) f;\n\t\tI = (XIntegerFeedbackState *) Feedback;\n\n\t\tI->class = ifs->class;\n\t\tI->length = sizeof(XIntegerFeedbackState);\n\t\tI->id = ifs->id;\n\t\tI->resolution = ifs->resolution;\n\t\tI->minVal = ifs->min_value;\n\t\tI->maxVal = ifs->max_value;\n\t\tbreak;\n\t    }\n\t    case StringFeedbackClass:\n\t    {\n\t\txStringFeedbackState *s;\n\t\tXStringFeedbackState *S;\n\n\t\ts = (xStringFeedbackState *) f;\n\t\tS = (XStringFeedbackState *) Feedback;\n\n\t\tS->class = s->class;\n\t\tS->length = sizeof(XStringFeedbackState) +\n\t\t    (s->num_syms_supported * sizeof(KeySym));\n\t\tS->id = s->id;\n\t\tS->max_symbols = s->max_symbols;\n\t\tS->num_syms_supported = s->num_syms_supported;\n\t\tS->syms_supported = (KeySym *) (S + 1);\n\t\tmemcpy((char *)S->syms_supported, (char *)(s + 1),\n\t\t       (S->num_syms_supported * sizeof(KeySym)));\n\t\tbreak;\n\t    }\n\t    case LedFeedbackClass:\n\t    {\n\t\txLedFeedbackState *l;\n\t\tXLedFeedbackState *L;\n\n\t\tl = (xLedFeedbackState *) f;\n\t\tL = (XLedFeedbackState *) Feedback;\n\n\t\tL->class = l->class;\n\t\tL->length = sizeof(XLedFeedbackState);\n\t\tL->id = l->id;\n\t\tL->led_values = l->led_values;\n\t\tL->led_mask = l->led_mask;\n\t\tbreak;\n\t    }\n\t    case BellFeedbackClass:\n\t    {\n\t\txBellFeedbackState *b;\n\t\tXBellFeedbackState *B;\n\n\t\tb = (xBellFeedbackState *) f;\n\t\tB = (XBellFeedbackState *) Feedback;\n\n\t\tB->class = b->class;\n\t\tB->length = sizeof(XBellFeedbackState);\n\t\tB->id = b->id;\n\t\tB->percent = b->percent;\n\t\tB->pitch = b->pitch;\n\t\tB->duration = b->duration;\n\t\tbreak;\n\t    }\n\t    default:\n\t\tbreak;\n\t    }\n\t    f = (xFeedbackState *) ((char *)f + f->length);\n\t    Feedback = (XFeedbackState *) ((char *)Feedback + Feedback->length);\n\t}\n    }\nout:\n    XFree((char *)sav);\n\n    UnlockDisplay(dpy);\n    SyncHandle();\n    return (Sav);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -8,6 +8,7 @@\n     XFeedbackState *Sav = NULL;\n     xFeedbackState *f = NULL;\n     xFeedbackState *sav = NULL;\n+    char *end = NULL;\n     xGetFeedbackControlReq *req;\n     xGetFeedbackControlReply rep;\n     XExtDisplayInfo *info = XInput_find_display(dpy);\n@@ -40,10 +41,12 @@\n \t    goto out;\n \t}\n \tsav = f;\n+\tend = (char *)f + nbytes;\n \t_XRead(dpy, (char *)f, nbytes);\n \n \tfor (i = 0; i < *num_feedbacks; i++) {\n-\t    if (f->length > nbytes)\n+\t    if ((char *)f + sizeof(*f) > end ||\n+\t        f->length == 0 || f->length > nbytes)\n \t\tgoto out;\n \t    nbytes -= f->length;\n \n@@ -60,6 +63,8 @@\n \t    case StringFeedbackClass:\n \t    {\n \t\txStringFeedbackState *strf = (xStringFeedbackState *) f;\n+\t\tif ((char *)f + sizeof(*strf) > end)\n+\t\t    goto out;\n \t\tsize += sizeof(XStringFeedbackState) +\n \t\t    (strf->num_syms_supported * sizeof(KeySym));\n \t    }",
        "diff_line_info": {
            "deleted_lines": [
                "\t    if (f->length > nbytes)"
            ],
            "added_lines": [
                "    char *end = NULL;",
                "\tend = (char *)f + nbytes;",
                "\t    if ((char *)f + sizeof(*f) > end ||",
                "\t        f->length == 0 || f->length > nbytes)",
                "\t\tif ((char *)f + sizeof(*strf) > end)",
                "\t\t    goto out;"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-7945",
        "func_name": "xorg/lib/libXi/XGetDeviceModifierMapping",
        "description": "Multiple integer overflows in X.org libXi before 1.7.7 allow remote X servers to cause a denial of service (out-of-bounds memory access or infinite loop) via vectors involving length fields.",
        "git_url": "https://cgit.freedesktop.org/xorg/lib/libXi/commit/?id=19a9cd607de73947fcfb104682f203ffe4e1f4e5",
        "commit_title": "By validating length fields from server responses, out of boundary",
        "commit_text": "accesses and endless loops can be mitigated.  ",
        "func_before": "XModifierKeymap *\nXGetDeviceModifierMapping(\n    register Display\t*dpy,\n    XDevice\t\t*dev)\n{\n    unsigned long nbytes;\n    XModifierKeymap *res;\n    xGetDeviceModifierMappingReq *req;\n    xGetDeviceModifierMappingReply rep;\n    XExtDisplayInfo *info = XInput_find_display(dpy);\n\n    LockDisplay(dpy);\n    if (_XiCheckExtInit(dpy, XInput_Initial_Release, info) == -1)\n        return NULL;\n\n    GetReq(GetDeviceModifierMapping, req);\n    req->reqType = info->codes->major_opcode;\n    req->ReqType = X_GetDeviceModifierMapping;\n    req->deviceid = dev->device_id;\n\n    if (!_XReply(dpy, (xReply *) & rep, 0, xFalse)) {\n\tUnlockDisplay(dpy);\n\tSyncHandle();\n\treturn (XModifierKeymap *) NULL;\n    }\n    nbytes = (unsigned long)rep.length << 2;\n    res = (XModifierKeymap *) Xmalloc(sizeof(XModifierKeymap));\n    if (res) {\n\tres->modifiermap = (KeyCode *) Xmalloc(nbytes);\n\tif (res->modifiermap)\n\t    _XReadPad(dpy, (char *)res->modifiermap, nbytes);\n\telse\n\t    _XEatDataWords(dpy, rep.length);\n\tres->max_keypermod = rep.numKeyPerModifier;\n    }\n\n    UnlockDisplay(dpy);\n    SyncHandle();\n    return (res);\n}",
        "func": "XModifierKeymap *\nXGetDeviceModifierMapping(\n    register Display\t*dpy,\n    XDevice\t\t*dev)\n{\n    unsigned long nbytes;\n    XModifierKeymap *res;\n    xGetDeviceModifierMappingReq *req;\n    xGetDeviceModifierMappingReply rep;\n    XExtDisplayInfo *info = XInput_find_display(dpy);\n\n    LockDisplay(dpy);\n    if (_XiCheckExtInit(dpy, XInput_Initial_Release, info) == -1)\n        return NULL;\n\n    GetReq(GetDeviceModifierMapping, req);\n    req->reqType = info->codes->major_opcode;\n    req->ReqType = X_GetDeviceModifierMapping;\n    req->deviceid = dev->device_id;\n\n    if (!_XReply(dpy, (xReply *) & rep, 0, xFalse)) {\n\tUnlockDisplay(dpy);\n\tSyncHandle();\n\treturn (XModifierKeymap *) NULL;\n    }\n    if (rep.length < (INT_MAX >> 2) &&\n\trep.numKeyPerModifier == rep.length >> 1) {\n\tnbytes = (unsigned long)rep.length << 2;\n\tres = (XModifierKeymap *) Xmalloc(sizeof(XModifierKeymap));\n    } else {\n\tnbytes = 0;\n\tres = NULL;\n    }\n    if (res) {\n\tres->modifiermap = (KeyCode *) Xmalloc(nbytes);\n\tif (res->modifiermap)\n\t    _XReadPad(dpy, (char *)res->modifiermap, nbytes);\n\telse\n\t    _XEatDataWords(dpy, rep.length);\n\tres->max_keypermod = rep.numKeyPerModifier;\n    }\n\n    UnlockDisplay(dpy);\n    SyncHandle();\n    return (res);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -23,8 +23,14 @@\n \tSyncHandle();\n \treturn (XModifierKeymap *) NULL;\n     }\n-    nbytes = (unsigned long)rep.length << 2;\n-    res = (XModifierKeymap *) Xmalloc(sizeof(XModifierKeymap));\n+    if (rep.length < (INT_MAX >> 2) &&\n+\trep.numKeyPerModifier == rep.length >> 1) {\n+\tnbytes = (unsigned long)rep.length << 2;\n+\tres = (XModifierKeymap *) Xmalloc(sizeof(XModifierKeymap));\n+    } else {\n+\tnbytes = 0;\n+\tres = NULL;\n+    }\n     if (res) {\n \tres->modifiermap = (KeyCode *) Xmalloc(nbytes);\n \tif (res->modifiermap)",
        "diff_line_info": {
            "deleted_lines": [
                "    nbytes = (unsigned long)rep.length << 2;",
                "    res = (XModifierKeymap *) Xmalloc(sizeof(XModifierKeymap));"
            ],
            "added_lines": [
                "    if (rep.length < (INT_MAX >> 2) &&",
                "\trep.numKeyPerModifier == rep.length >> 1) {",
                "\tnbytes = (unsigned long)rep.length << 2;",
                "\tres = (XModifierKeymap *) Xmalloc(sizeof(XModifierKeymap));",
                "    } else {",
                "\tnbytes = 0;",
                "\tres = NULL;",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-7945",
        "func_name": "xorg/lib/libXi/XIQueryDevice",
        "description": "Multiple integer overflows in X.org libXi before 1.7.7 allow remote X servers to cause a denial of service (out-of-bounds memory access or infinite loop) via vectors involving length fields.",
        "git_url": "https://cgit.freedesktop.org/xorg/lib/libXi/commit/?id=19a9cd607de73947fcfb104682f203ffe4e1f4e5",
        "commit_title": "By validating length fields from server responses, out of boundary",
        "commit_text": "accesses and endless loops can be mitigated.  ",
        "func_before": "XIDeviceInfo*\nXIQueryDevice(Display *dpy, int deviceid, int *ndevices_return)\n{\n    XIDeviceInfo        *info = NULL;\n    xXIQueryDeviceReq   *req;\n    xXIQueryDeviceReply reply;\n    char                *ptr;\n    int                 i;\n    char                *buf;\n\n    XExtDisplayInfo *extinfo = XInput_find_display(dpy);\n\n    LockDisplay(dpy);\n    if (_XiCheckExtInit(dpy, XInput_2_0, extinfo) == -1)\n        goto error_unlocked;\n\n    GetReq(XIQueryDevice, req);\n    req->reqType  = extinfo->codes->major_opcode;\n    req->ReqType  = X_XIQueryDevice;\n    req->deviceid = deviceid;\n\n    if (!_XReply(dpy, (xReply*) &reply, 0, xFalse))\n        goto error;\n\n    *ndevices_return = reply.num_devices;\n    info = Xmalloc((reply.num_devices + 1) * sizeof(XIDeviceInfo));\n    if (!info)\n        goto error;\n\n    buf = Xmalloc(reply.length * 4);\n    _XRead(dpy, buf, reply.length * 4);\n    ptr = buf;\n\n    /* info is a null-terminated array */\n    info[reply.num_devices].name = NULL;\n\n    for (i = 0; i < reply.num_devices; i++)\n    {\n        int             nclasses;\n        size_t          sz;\n        XIDeviceInfo    *lib = &info[i];\n        xXIDeviceInfo   *wire = (xXIDeviceInfo*)ptr;\n\n        lib->deviceid    = wire->deviceid;\n        lib->use         = wire->use;\n        lib->attachment  = wire->attachment;\n        lib->enabled     = wire->enabled;\n        nclasses         = wire->num_classes;\n\n        ptr += sizeof(xXIDeviceInfo);\n\n        lib->name = Xcalloc(wire->name_len + 1, 1);\n        strncpy(lib->name, ptr, wire->name_len);\n        ptr += ((wire->name_len + 3)/4) * 4;\n\n        sz = size_classes((xXIAnyInfo*)ptr, nclasses);\n        lib->classes = Xmalloc(sz);\n        ptr += copy_classes(lib, (xXIAnyInfo*)ptr, &nclasses);\n        /* We skip over unused classes */\n        lib->num_classes = nclasses;\n    }\n\n    Xfree(buf);\n    UnlockDisplay(dpy);\n    SyncHandle();\n    return info;\n\nerror:\n    UnlockDisplay(dpy);\nerror_unlocked:\n    SyncHandle();\n    *ndevices_return = -1;\n    return NULL;\n}",
        "func": "XIDeviceInfo*\nXIQueryDevice(Display *dpy, int deviceid, int *ndevices_return)\n{\n    XIDeviceInfo        *info = NULL;\n    xXIQueryDeviceReq   *req;\n    xXIQueryDeviceReply reply;\n    char                *ptr;\n    char                *end;\n    int                 i;\n    char                *buf;\n\n    XExtDisplayInfo *extinfo = XInput_find_display(dpy);\n\n    LockDisplay(dpy);\n    if (_XiCheckExtInit(dpy, XInput_2_0, extinfo) == -1)\n        goto error_unlocked;\n\n    GetReq(XIQueryDevice, req);\n    req->reqType  = extinfo->codes->major_opcode;\n    req->ReqType  = X_XIQueryDevice;\n    req->deviceid = deviceid;\n\n    if (!_XReply(dpy, (xReply*) &reply, 0, xFalse))\n        goto error;\n\n    if (reply.length < INT_MAX / 4)\n    {\n\t*ndevices_return = reply.num_devices;\n\tinfo = Xmalloc((reply.num_devices + 1) * sizeof(XIDeviceInfo));\n    }\n    else\n    {\n\t*ndevices_return = 0;\n\tinfo = NULL;\n    }\n\n    if (!info)\n        goto error;\n\n    buf = Xmalloc(reply.length * 4);\n    _XRead(dpy, buf, reply.length * 4);\n    ptr = buf;\n    end = buf + reply.length * 4;\n\n    /* info is a null-terminated array */\n    info[reply.num_devices].name = NULL;\n\n    for (i = 0; i < reply.num_devices; i++)\n    {\n        int             nclasses;\n        size_t          sz;\n        XIDeviceInfo    *lib = &info[i];\n        xXIDeviceInfo   *wire = (xXIDeviceInfo*)ptr;\n\n        if (ptr + sizeof(xXIDeviceInfo) > end)\n            goto error_loop;\n\n        lib->deviceid    = wire->deviceid;\n        lib->use         = wire->use;\n        lib->attachment  = wire->attachment;\n        lib->enabled     = wire->enabled;\n        nclasses         = wire->num_classes;\n\n        ptr += sizeof(xXIDeviceInfo);\n\n        if (ptr + wire->name_len > end)\n            goto error_loop;\n\n        lib->name = Xcalloc(wire->name_len + 1, 1);\n        if (lib->name == NULL)\n            goto error_loop;\n        strncpy(lib->name, ptr, wire->name_len);\n        lib->name[wire->name_len] = '\\0';\n        ptr += ((wire->name_len + 3)/4) * 4;\n\n        sz = size_classes((xXIAnyInfo*)ptr, nclasses);\n        lib->classes = Xmalloc(sz);\n        if (lib->classes == NULL)\n        {\n            Xfree(lib->name);\n            goto error_loop;\n        }\n        ptr += copy_classes(lib, (xXIAnyInfo*)ptr, &nclasses);\n        /* We skip over unused classes */\n        lib->num_classes = nclasses;\n    }\n\n    Xfree(buf);\n    UnlockDisplay(dpy);\n    SyncHandle();\n    return info;\n\nerror_loop:\n    while (--i >= 0)\n    {\n        Xfree(info[i].name);\n        Xfree(info[i].classes);\n    }\nerror:\n    UnlockDisplay(dpy);\nerror_unlocked:\n    SyncHandle();\n    *ndevices_return = -1;\n    return NULL;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,6 +5,7 @@\n     xXIQueryDeviceReq   *req;\n     xXIQueryDeviceReply reply;\n     char                *ptr;\n+    char                *end;\n     int                 i;\n     char                *buf;\n \n@@ -22,14 +23,24 @@\n     if (!_XReply(dpy, (xReply*) &reply, 0, xFalse))\n         goto error;\n \n-    *ndevices_return = reply.num_devices;\n-    info = Xmalloc((reply.num_devices + 1) * sizeof(XIDeviceInfo));\n+    if (reply.length < INT_MAX / 4)\n+    {\n+\t*ndevices_return = reply.num_devices;\n+\tinfo = Xmalloc((reply.num_devices + 1) * sizeof(XIDeviceInfo));\n+    }\n+    else\n+    {\n+\t*ndevices_return = 0;\n+\tinfo = NULL;\n+    }\n+\n     if (!info)\n         goto error;\n \n     buf = Xmalloc(reply.length * 4);\n     _XRead(dpy, buf, reply.length * 4);\n     ptr = buf;\n+    end = buf + reply.length * 4;\n \n     /* info is a null-terminated array */\n     info[reply.num_devices].name = NULL;\n@@ -41,6 +52,9 @@\n         XIDeviceInfo    *lib = &info[i];\n         xXIDeviceInfo   *wire = (xXIDeviceInfo*)ptr;\n \n+        if (ptr + sizeof(xXIDeviceInfo) > end)\n+            goto error_loop;\n+\n         lib->deviceid    = wire->deviceid;\n         lib->use         = wire->use;\n         lib->attachment  = wire->attachment;\n@@ -49,12 +63,23 @@\n \n         ptr += sizeof(xXIDeviceInfo);\n \n+        if (ptr + wire->name_len > end)\n+            goto error_loop;\n+\n         lib->name = Xcalloc(wire->name_len + 1, 1);\n+        if (lib->name == NULL)\n+            goto error_loop;\n         strncpy(lib->name, ptr, wire->name_len);\n+        lib->name[wire->name_len] = '\\0';\n         ptr += ((wire->name_len + 3)/4) * 4;\n \n         sz = size_classes((xXIAnyInfo*)ptr, nclasses);\n         lib->classes = Xmalloc(sz);\n+        if (lib->classes == NULL)\n+        {\n+            Xfree(lib->name);\n+            goto error_loop;\n+        }\n         ptr += copy_classes(lib, (xXIAnyInfo*)ptr, &nclasses);\n         /* We skip over unused classes */\n         lib->num_classes = nclasses;\n@@ -65,6 +90,12 @@\n     SyncHandle();\n     return info;\n \n+error_loop:\n+    while (--i >= 0)\n+    {\n+        Xfree(info[i].name);\n+        Xfree(info[i].classes);\n+    }\n error:\n     UnlockDisplay(dpy);\n error_unlocked:",
        "diff_line_info": {
            "deleted_lines": [
                "    *ndevices_return = reply.num_devices;",
                "    info = Xmalloc((reply.num_devices + 1) * sizeof(XIDeviceInfo));"
            ],
            "added_lines": [
                "    char                *end;",
                "    if (reply.length < INT_MAX / 4)",
                "    {",
                "\t*ndevices_return = reply.num_devices;",
                "\tinfo = Xmalloc((reply.num_devices + 1) * sizeof(XIDeviceInfo));",
                "    }",
                "    else",
                "    {",
                "\t*ndevices_return = 0;",
                "\tinfo = NULL;",
                "    }",
                "",
                "    end = buf + reply.length * 4;",
                "        if (ptr + sizeof(xXIDeviceInfo) > end)",
                "            goto error_loop;",
                "",
                "        if (ptr + wire->name_len > end)",
                "            goto error_loop;",
                "",
                "        if (lib->name == NULL)",
                "            goto error_loop;",
                "        lib->name[wire->name_len] = '\\0';",
                "        if (lib->classes == NULL)",
                "        {",
                "            Xfree(lib->name);",
                "            goto error_loop;",
                "        }",
                "error_loop:",
                "    while (--i >= 0)",
                "    {",
                "        Xfree(info[i].name);",
                "        Xfree(info[i].classes);",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-7945",
        "func_name": "xorg/lib/libXi/XOpenDevice",
        "description": "Multiple integer overflows in X.org libXi before 1.7.7 allow remote X servers to cause a denial of service (out-of-bounds memory access or infinite loop) via vectors involving length fields.",
        "git_url": "https://cgit.freedesktop.org/xorg/lib/libXi/commit/?id=19a9cd607de73947fcfb104682f203ffe4e1f4e5",
        "commit_title": "By validating length fields from server responses, out of boundary",
        "commit_text": "accesses and endless loops can be mitigated.  ",
        "func_before": "XDevice *\nXOpenDevice(\n    register Display\t*dpy,\n    register XID\t id)\n{\n    register long rlen;\t/* raw length */\n    xOpenDeviceReq *req;\n    xOpenDeviceReply rep;\n    XDevice *dev;\n    XExtDisplayInfo *info = XInput_find_display(dpy);\n\n    LockDisplay(dpy);\n    if (_XiCheckExtInit(dpy, XInput_Initial_Release, info) == -1)\n        return NULL;\n\n    GetReq(OpenDevice, req);\n    req->reqType = info->codes->major_opcode;\n    req->ReqType = X_OpenDevice;\n    req->deviceid = id;\n\n    if (!_XReply(dpy, (xReply *) & rep, 0, xFalse)) {\n\tUnlockDisplay(dpy);\n\tSyncHandle();\n\treturn (XDevice *) NULL;\n    }\n\n    rlen = rep.length << 2;\n    dev = (XDevice *) Xmalloc(sizeof(XDevice) + rep.num_classes *\n\t\t\t      sizeof(XInputClassInfo));\n    if (dev) {\n\tint dlen;\t/* data length */\n\n\tdev->device_id = req->deviceid;\n\tdev->num_classes = rep.num_classes;\n\tdev->classes = (XInputClassInfo *) ((char *)dev + sizeof(XDevice));\n\tdlen = rep.num_classes * sizeof(xInputClassInfo);\n\t_XRead(dpy, (char *)dev->classes, dlen);\n\t/* could be padding that we still need to eat (yummy!) */\n\tif (rlen - dlen > 0)\n\t    _XEatData(dpy, (unsigned long)rlen - dlen);\n    } else\n\t_XEatDataWords(dpy, rep.length);\n\n    UnlockDisplay(dpy);\n    SyncHandle();\n    return (dev);\n}",
        "func": "XDevice *\nXOpenDevice(\n    register Display\t*dpy,\n    register XID\t id)\n{\n    register long rlen;\t/* raw length */\n    xOpenDeviceReq *req;\n    xOpenDeviceReply rep;\n    XDevice *dev;\n    XExtDisplayInfo *info = XInput_find_display(dpy);\n\n    LockDisplay(dpy);\n    if (_XiCheckExtInit(dpy, XInput_Initial_Release, info) == -1)\n        return NULL;\n\n    GetReq(OpenDevice, req);\n    req->reqType = info->codes->major_opcode;\n    req->ReqType = X_OpenDevice;\n    req->deviceid = id;\n\n    if (!_XReply(dpy, (xReply *) & rep, 0, xFalse)) {\n\tUnlockDisplay(dpy);\n\tSyncHandle();\n\treturn (XDevice *) NULL;\n    }\n\n    if (rep.length < INT_MAX >> 2 &&\n\t(rep.length << 2) >= rep.num_classes * sizeof(xInputClassInfo)) {\n\trlen = rep.length << 2;\n\tdev = (XDevice *) Xmalloc(sizeof(XDevice) + rep.num_classes *\n\t\t\t\t  sizeof(XInputClassInfo));\n    } else {\n\trlen = 0;\n\tdev = NULL;\n    }\n    if (dev) {\n\tint dlen;\t/* data length */\n\n\tdev->device_id = req->deviceid;\n\tdev->num_classes = rep.num_classes;\n\tdev->classes = (XInputClassInfo *) ((char *)dev + sizeof(XDevice));\n\tdlen = rep.num_classes * sizeof(xInputClassInfo);\n\t_XRead(dpy, (char *)dev->classes, dlen);\n\t/* could be padding that we still need to eat (yummy!) */\n\tif (rlen - dlen > 0)\n\t    _XEatData(dpy, (unsigned long)rlen - dlen);\n    } else\n\t_XEatDataWords(dpy, rep.length);\n\n    UnlockDisplay(dpy);\n    SyncHandle();\n    return (dev);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -24,9 +24,15 @@\n \treturn (XDevice *) NULL;\n     }\n \n-    rlen = rep.length << 2;\n-    dev = (XDevice *) Xmalloc(sizeof(XDevice) + rep.num_classes *\n-\t\t\t      sizeof(XInputClassInfo));\n+    if (rep.length < INT_MAX >> 2 &&\n+\t(rep.length << 2) >= rep.num_classes * sizeof(xInputClassInfo)) {\n+\trlen = rep.length << 2;\n+\tdev = (XDevice *) Xmalloc(sizeof(XDevice) + rep.num_classes *\n+\t\t\t\t  sizeof(XInputClassInfo));\n+    } else {\n+\trlen = 0;\n+\tdev = NULL;\n+    }\n     if (dev) {\n \tint dlen;\t/* data length */\n ",
        "diff_line_info": {
            "deleted_lines": [
                "    rlen = rep.length << 2;",
                "    dev = (XDevice *) Xmalloc(sizeof(XDevice) + rep.num_classes *",
                "\t\t\t      sizeof(XInputClassInfo));"
            ],
            "added_lines": [
                "    if (rep.length < INT_MAX >> 2 &&",
                "\t(rep.length << 2) >= rep.num_classes * sizeof(xInputClassInfo)) {",
                "\trlen = rep.length << 2;",
                "\tdev = (XDevice *) Xmalloc(sizeof(XDevice) + rep.num_classes *",
                "\t\t\t\t  sizeof(XInputClassInfo));",
                "    } else {",
                "\trlen = 0;",
                "\tdev = NULL;",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-7945",
        "func_name": "xorg/lib/libXi/XGetDeviceMotionEvents",
        "description": "Multiple integer overflows in X.org libXi before 1.7.7 allow remote X servers to cause a denial of service (out-of-bounds memory access or infinite loop) via vectors involving length fields.",
        "git_url": "https://cgit.freedesktop.org/xorg/lib/libXi/commit/?id=19a9cd607de73947fcfb104682f203ffe4e1f4e5",
        "commit_title": "By validating length fields from server responses, out of boundary",
        "commit_text": "accesses and endless loops can be mitigated.  ",
        "func_before": "XDeviceTimeCoord *\nXGetDeviceMotionEvents(\n    register Display\t*dpy,\n    XDevice\t\t*dev,\n    Time\t\t start,\n    Time\t\t stop,\n    int\t\t\t*nEvents,\n    int\t\t\t*mode,\n    int\t\t\t*axis_count)\n{\n    xGetDeviceMotionEventsReq *req;\n    xGetDeviceMotionEventsReply rep;\n    XDeviceTimeCoord *tc;\n    int *data, *bufp, *readp, *savp;\n    unsigned long size;\n    int i, j;\n    XExtDisplayInfo *info = XInput_find_display(dpy);\n\n    LockDisplay(dpy);\n    if (_XiCheckExtInit(dpy, XInput_Initial_Release, info) == -1)\n        return NULL;\n\n    GetReq(GetDeviceMotionEvents, req);\n    req->reqType = info->codes->major_opcode;\n    req->ReqType = X_GetDeviceMotionEvents;\n    req->start = start;\n    req->stop = stop;\n    req->deviceid = dev->device_id;\n\n    if (!_XReply(dpy, (xReply *) & rep, 0, xFalse)) {\n\tUnlockDisplay(dpy);\n\tSyncHandle();\n\t*nEvents = 0;\n\treturn (NULL);\n    }\n\n    *mode = rep.mode;\n    *axis_count = rep.axes;\n    *nEvents = rep.nEvents;\n    if (!rep.nEvents) {\n\tUnlockDisplay(dpy);\n\tSyncHandle();\n\treturn (NULL);\n    }\n    if (rep.length < (INT_MAX >> 2)) {\n\tsize = rep.length << 2;\n\tsavp = readp = Xmalloc(size);\n    } else {\n\tsize = 0;\n\tsavp = readp = NULL;\n    }\n    /* rep.axes is a CARD8, so assume max number of axes for bounds check */\n    if (rep.nEvents <\n\t(INT_MAX / (sizeof(XDeviceTimeCoord) + (UCHAR_MAX * sizeof(int))))) {\n\tsize_t bsize = rep.nEvents *\n\t    (sizeof(XDeviceTimeCoord) + (rep.axes * sizeof(int)));\n\tbufp = Xmalloc(bsize);\n    } else\n\tbufp = NULL;\n    if (!bufp || !savp) {\n\tXfree(bufp);\n\tXfree(savp);\n\t*nEvents = 0;\n\t_XEatDataWords(dpy, rep.length);\n\tUnlockDisplay(dpy);\n\tSyncHandle();\n\treturn (NULL);\n    }\n    _XRead(dpy, (char *)readp, size);\n\n    tc = (XDeviceTimeCoord *) bufp;\n    data = (int *)(tc + rep.nEvents);\n    for (i = 0; i < *nEvents; i++, tc++) {\n\ttc->time = *readp++;\n\ttc->data = data;\n\tfor (j = 0; j < *axis_count; j++)\n\t    *data++ = *readp++;\n    }\n    XFree((char *)savp);\n    UnlockDisplay(dpy);\n    SyncHandle();\n    return ((XDeviceTimeCoord *) bufp);\n}",
        "func": "XDeviceTimeCoord *\nXGetDeviceMotionEvents(\n    register Display\t*dpy,\n    XDevice\t\t*dev,\n    Time\t\t start,\n    Time\t\t stop,\n    int\t\t\t*nEvents,\n    int\t\t\t*mode,\n    int\t\t\t*axis_count)\n{\n    xGetDeviceMotionEventsReq *req;\n    xGetDeviceMotionEventsReply rep;\n    XDeviceTimeCoord *tc;\n    int *data, *bufp, *readp, *savp;\n    unsigned long size;\n    int i, j;\n    XExtDisplayInfo *info = XInput_find_display(dpy);\n\n    LockDisplay(dpy);\n    if (_XiCheckExtInit(dpy, XInput_Initial_Release, info) == -1)\n        return NULL;\n\n    GetReq(GetDeviceMotionEvents, req);\n    req->reqType = info->codes->major_opcode;\n    req->ReqType = X_GetDeviceMotionEvents;\n    req->start = start;\n    req->stop = stop;\n    req->deviceid = dev->device_id;\n\n    if (!_XReply(dpy, (xReply *) & rep, 0, xFalse)) {\n\tUnlockDisplay(dpy);\n\tSyncHandle();\n\t*nEvents = 0;\n\treturn (NULL);\n    }\n\n    *mode = rep.mode;\n    *axis_count = rep.axes;\n    *nEvents = rep.nEvents;\n    if (!rep.nEvents) {\n\tUnlockDisplay(dpy);\n\tSyncHandle();\n\treturn (NULL);\n    }\n    if (rep.length < (INT_MAX >> 2)) {\n\tsize = rep.length << 2;\n\tsavp = readp = Xmalloc(size);\n    } else {\n\tsize = 0;\n\tsavp = readp = NULL;\n    }\n    /* rep.axes is a CARD8, so assume max number of axes for bounds check */\n    if (rep.nEvents <\n\t(INT_MAX / (sizeof(XDeviceTimeCoord) + (UCHAR_MAX * sizeof(int)))) &&\n\trep.nEvents * (rep.axes + 1) <= rep.length) {\n\tsize_t bsize = rep.nEvents *\n\t    (sizeof(XDeviceTimeCoord) + (rep.axes * sizeof(int)));\n\tbufp = Xmalloc(bsize);\n    } else\n\tbufp = NULL;\n    if (!bufp || !savp) {\n\tXfree(bufp);\n\tXfree(savp);\n\t*nEvents = 0;\n\t_XEatDataWords(dpy, rep.length);\n\tUnlockDisplay(dpy);\n\tSyncHandle();\n\treturn (NULL);\n    }\n    _XRead(dpy, (char *)readp, size);\n\n    tc = (XDeviceTimeCoord *) bufp;\n    data = (int *)(tc + rep.nEvents);\n    for (i = 0; i < *nEvents; i++, tc++) {\n\ttc->time = *readp++;\n\ttc->data = data;\n\tfor (j = 0; j < *axis_count; j++)\n\t    *data++ = *readp++;\n    }\n    XFree((char *)savp);\n    UnlockDisplay(dpy);\n    SyncHandle();\n    return ((XDeviceTimeCoord *) bufp);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -51,7 +51,8 @@\n     }\n     /* rep.axes is a CARD8, so assume max number of axes for bounds check */\n     if (rep.nEvents <\n-\t(INT_MAX / (sizeof(XDeviceTimeCoord) + (UCHAR_MAX * sizeof(int))))) {\n+\t(INT_MAX / (sizeof(XDeviceTimeCoord) + (UCHAR_MAX * sizeof(int)))) &&\n+\trep.nEvents * (rep.axes + 1) <= rep.length) {\n \tsize_t bsize = rep.nEvents *\n \t    (sizeof(XDeviceTimeCoord) + (rep.axes * sizeof(int)));\n \tbufp = Xmalloc(bsize);",
        "diff_line_info": {
            "deleted_lines": [
                "\t(INT_MAX / (sizeof(XDeviceTimeCoord) + (UCHAR_MAX * sizeof(int))))) {"
            ],
            "added_lines": [
                "\t(INT_MAX / (sizeof(XDeviceTimeCoord) + (UCHAR_MAX * sizeof(int)))) &&",
                "\trep.nEvents * (rep.axes + 1) <= rep.length) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-7945",
        "func_name": "xorg/lib/libXi/XQueryDeviceState",
        "description": "Multiple integer overflows in X.org libXi before 1.7.7 allow remote X servers to cause a denial of service (out-of-bounds memory access or infinite loop) via vectors involving length fields.",
        "git_url": "https://cgit.freedesktop.org/xorg/lib/libXi/commit/?id=19a9cd607de73947fcfb104682f203ffe4e1f4e5",
        "commit_title": "By validating length fields from server responses, out of boundary",
        "commit_text": "accesses and endless loops can be mitigated.  ",
        "func_before": "XDeviceState *\nXQueryDeviceState(\n    register Display\t*dpy,\n    XDevice\t\t*dev)\n{\n    int i, j;\n    unsigned long rlen;\n    size_t size = 0;\n    xQueryDeviceStateReq *req;\n    xQueryDeviceStateReply rep;\n    XDeviceState *state = NULL;\n    XInputClass *any, *Any;\n    char *data = NULL;\n    XExtDisplayInfo *info = XInput_find_display(dpy);\n\n    LockDisplay(dpy);\n    if (_XiCheckExtInit(dpy, XInput_Initial_Release, info) == -1)\n        return NULL;\n\n    GetReq(QueryDeviceState, req);\n    req->reqType = info->codes->major_opcode;\n    req->ReqType = X_QueryDeviceState;\n    req->deviceid = dev->device_id;\n\n    if (!_XReply(dpy, (xReply *) & rep, 0, xFalse))\n        goto out;\n\n    if (rep.length > 0) {\n\tif (rep.length < (INT_MAX >> 2)) {\n\t    rlen = (unsigned long) rep.length << 2;\n\t    data = Xmalloc(rlen);\n\t}\n\tif (!data) {\n\t    _XEatDataWords(dpy, rep.length);\n\t    goto out;\n\t}\n\t_XRead(dpy, data, rlen);\n\n\tfor (i = 0, any = (XInputClass *) data; i < (int)rep.num_classes; i++) {\n\t    if (any->length > rlen)\n\t\tgoto out;\n\t    rlen -= any->length;\n\n\t    switch (any->class) {\n\t    case KeyClass:\n\t\tsize += sizeof(XKeyState);\n\t\tbreak;\n\t    case ButtonClass:\n\t\tsize += sizeof(XButtonState);\n\t\tbreak;\n\t    case ValuatorClass:\n\t    {\n\t\txValuatorState *v = (xValuatorState *) any;\n\t\tsize += (sizeof(XValuatorState) +\n\t\t\t (v->num_valuators * sizeof(int)));\n\t    }\n\t\tbreak;\n\t    }\n\t    any = (XInputClass *) ((char *)any + any->length);\n\t}\n\tstate = (XDeviceState *) Xmalloc(size + sizeof(XDeviceState));\n\tif (!state)\n            goto out;\n\n\tstate->device_id = dev->device_id;\n\tstate->num_classes = rep.num_classes;\n\tstate->data = (XInputClass *) (state + 1);\n\n\tAny = state->data;\n\tfor (i = 0, any = (XInputClass *) data; i < (int)rep.num_classes; i++) {\n\t    switch (any->class) {\n\t    case KeyClass:\n\t    {\n\t\txKeyState *k = (xKeyState *) any;\n\t\tXKeyState *K = (XKeyState *) Any;\n\n\t\tK->class = k->class;\n\t\tK->length = sizeof(XKeyState);\n\t\tK->num_keys = k->num_keys;\n\t\tmemcpy((char *)&K->keys[0], (char *)&k->keys[0], 32);\n\t\tAny = (XInputClass *) (K + 1);\n\t    }\n\t\tbreak;\n\t    case ButtonClass:\n\t    {\n\t\txButtonState *b = (xButtonState *) any;\n\t\tXButtonState *B = (XButtonState *) Any;\n\n\t\tB->class = b->class;\n\t\tB->length = sizeof(XButtonState);\n\t\tB->num_buttons = b->num_buttons;\n\t\tmemcpy((char *)&B->buttons[0], (char *)&b->buttons[0], 32);\n\t\tAny = (XInputClass *) (B + 1);\n\t    }\n\t\tbreak;\n\t    case ValuatorClass:\n\t    {\n\t\txValuatorState *v = (xValuatorState *) any;\n\t\tXValuatorState *V = (XValuatorState *) Any;\n\t\tCARD32 *valuators = (CARD32 *) (v + 1);\n\n\t\tV->class = v->class;\n\t\tV->length = sizeof(XValuatorState) +\n\t\t\t    v->num_valuators * sizeof(int);\n\t\tV->num_valuators = v->num_valuators;\n\t\tV->mode = v->mode;\n\t\tAny = (XInputClass *) (V + 1);\n\t\tV->valuators = (int *)Any;\n\t\tfor (j = 0; j < (int)V->num_valuators; j++)\n\t\t    *(V->valuators + j) = *valuators++;\n\t\tAny = (XInputClass *) ((char *)Any +\n\t\t\t\t       V->num_valuators * sizeof(int));\n\t    }\n\t\tbreak;\n\t    }\n\t    any = (XInputClass *) ((char *)any + any->length);\n\t}\n    }\nout:\n    Xfree(data);\n\n    UnlockDisplay(dpy);\n    SyncHandle();\n    return (state);\n}",
        "func": "XDeviceState *\nXQueryDeviceState(\n    register Display\t*dpy,\n    XDevice\t\t*dev)\n{\n    int i, j;\n    unsigned long rlen;\n    size_t size = 0;\n    xQueryDeviceStateReq *req;\n    xQueryDeviceStateReply rep;\n    XDeviceState *state = NULL;\n    XInputClass *any, *Any;\n    char *data = NULL, *end = NULL;\n    XExtDisplayInfo *info = XInput_find_display(dpy);\n\n    LockDisplay(dpy);\n    if (_XiCheckExtInit(dpy, XInput_Initial_Release, info) == -1)\n        return NULL;\n\n    GetReq(QueryDeviceState, req);\n    req->reqType = info->codes->major_opcode;\n    req->ReqType = X_QueryDeviceState;\n    req->deviceid = dev->device_id;\n\n    if (!_XReply(dpy, (xReply *) & rep, 0, xFalse))\n        goto out;\n\n    if (rep.length > 0) {\n\tif (rep.length < (INT_MAX >> 2)) {\n\t    rlen = (unsigned long) rep.length << 2;\n\t    data = Xmalloc(rlen);\n\t    end = data + rlen;\n\t}\n\tif (!data) {\n\t    _XEatDataWords(dpy, rep.length);\n\t    goto out;\n\t}\n\t_XRead(dpy, data, rlen);\n\n\tfor (i = 0, any = (XInputClass *) data; i < (int)rep.num_classes; i++) {\n\t    if ((char *)any + sizeof(XInputClass) > end ||\n\t\tany->length == 0 || any->length > rlen)\n\t\tgoto out;\n\t    rlen -= any->length;\n\n\t    switch (any->class) {\n\t    case KeyClass:\n\t\tsize += sizeof(XKeyState);\n\t\tbreak;\n\t    case ButtonClass:\n\t\tsize += sizeof(XButtonState);\n\t\tbreak;\n\t    case ValuatorClass:\n\t    {\n\t\txValuatorState *v = (xValuatorState *) any;\n\t\tif ((char *)any + sizeof(xValuatorState) > end)\n\t\t    goto out;\n\t\tsize += (sizeof(XValuatorState) +\n\t\t\t (v->num_valuators * sizeof(int)));\n\t    }\n\t\tbreak;\n\t    }\n\t    any = (XInputClass *) ((char *)any + any->length);\n\t}\n\tstate = (XDeviceState *) Xmalloc(size + sizeof(XDeviceState));\n\tif (!state)\n            goto out;\n\n\tstate->device_id = dev->device_id;\n\tstate->num_classes = rep.num_classes;\n\tstate->data = (XInputClass *) (state + 1);\n\n\tAny = state->data;\n\tfor (i = 0, any = (XInputClass *) data; i < (int)rep.num_classes; i++) {\n\t    switch (any->class) {\n\t    case KeyClass:\n\t    {\n\t\txKeyState *k = (xKeyState *) any;\n\t\tXKeyState *K = (XKeyState *) Any;\n\n\t\tK->class = k->class;\n\t\tK->length = sizeof(XKeyState);\n\t\tK->num_keys = k->num_keys;\n\t\tmemcpy((char *)&K->keys[0], (char *)&k->keys[0], 32);\n\t\tAny = (XInputClass *) (K + 1);\n\t    }\n\t\tbreak;\n\t    case ButtonClass:\n\t    {\n\t\txButtonState *b = (xButtonState *) any;\n\t\tXButtonState *B = (XButtonState *) Any;\n\n\t\tB->class = b->class;\n\t\tB->length = sizeof(XButtonState);\n\t\tB->num_buttons = b->num_buttons;\n\t\tmemcpy((char *)&B->buttons[0], (char *)&b->buttons[0], 32);\n\t\tAny = (XInputClass *) (B + 1);\n\t    }\n\t\tbreak;\n\t    case ValuatorClass:\n\t    {\n\t\txValuatorState *v = (xValuatorState *) any;\n\t\tXValuatorState *V = (XValuatorState *) Any;\n\t\tCARD32 *valuators = (CARD32 *) (v + 1);\n\n\t\tV->class = v->class;\n\t\tV->length = sizeof(XValuatorState) +\n\t\t\t    v->num_valuators * sizeof(int);\n\t\tV->num_valuators = v->num_valuators;\n\t\tV->mode = v->mode;\n\t\tAny = (XInputClass *) (V + 1);\n\t\tV->valuators = (int *)Any;\n\t\tfor (j = 0; j < (int)V->num_valuators; j++)\n\t\t    *(V->valuators + j) = *valuators++;\n\t\tAny = (XInputClass *) ((char *)Any +\n\t\t\t\t       V->num_valuators * sizeof(int));\n\t    }\n\t\tbreak;\n\t    }\n\t    any = (XInputClass *) ((char *)any + any->length);\n\t}\n    }\nout:\n    Xfree(data);\n\n    UnlockDisplay(dpy);\n    SyncHandle();\n    return (state);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -10,7 +10,7 @@\n     xQueryDeviceStateReply rep;\n     XDeviceState *state = NULL;\n     XInputClass *any, *Any;\n-    char *data = NULL;\n+    char *data = NULL, *end = NULL;\n     XExtDisplayInfo *info = XInput_find_display(dpy);\n \n     LockDisplay(dpy);\n@@ -29,6 +29,7 @@\n \tif (rep.length < (INT_MAX >> 2)) {\n \t    rlen = (unsigned long) rep.length << 2;\n \t    data = Xmalloc(rlen);\n+\t    end = data + rlen;\n \t}\n \tif (!data) {\n \t    _XEatDataWords(dpy, rep.length);\n@@ -37,7 +38,8 @@\n \t_XRead(dpy, data, rlen);\n \n \tfor (i = 0, any = (XInputClass *) data; i < (int)rep.num_classes; i++) {\n-\t    if (any->length > rlen)\n+\t    if ((char *)any + sizeof(XInputClass) > end ||\n+\t\tany->length == 0 || any->length > rlen)\n \t\tgoto out;\n \t    rlen -= any->length;\n \n@@ -51,6 +53,8 @@\n \t    case ValuatorClass:\n \t    {\n \t\txValuatorState *v = (xValuatorState *) any;\n+\t\tif ((char *)any + sizeof(xValuatorState) > end)\n+\t\t    goto out;\n \t\tsize += (sizeof(XValuatorState) +\n \t\t\t (v->num_valuators * sizeof(int)));\n \t    }",
        "diff_line_info": {
            "deleted_lines": [
                "    char *data = NULL;",
                "\t    if (any->length > rlen)"
            ],
            "added_lines": [
                "    char *data = NULL, *end = NULL;",
                "\t    end = data + rlen;",
                "\t    if ((char *)any + sizeof(XInputClass) > end ||",
                "\t\tany->length == 0 || any->length > rlen)",
                "\t\tif ((char *)any + sizeof(xValuatorState) > end)",
                "\t\t    goto out;"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-7945",
        "func_name": "xorg/lib/libXi/XGetDeviceButtonMapping",
        "description": "Multiple integer overflows in X.org libXi before 1.7.7 allow remote X servers to cause a denial of service (out-of-bounds memory access or infinite loop) via vectors involving length fields.",
        "git_url": "https://cgit.freedesktop.org/xorg/lib/libXi/commit/?id=19a9cd607de73947fcfb104682f203ffe4e1f4e5",
        "commit_title": "By validating length fields from server responses, out of boundary",
        "commit_text": "accesses and endless loops can be mitigated.  ",
        "func_before": "int\nXGetDeviceButtonMapping(\n    register Display\t*dpy,\n    XDevice\t\t*device,\n    unsigned char\t map[],\n    unsigned int\t nmap)\n{\n    int status = 0;\n    unsigned char mapping[256];\t/* known fixed size */\n    XExtDisplayInfo *info = XInput_find_display(dpy);\n\n    register xGetDeviceButtonMappingReq *req;\n    xGetDeviceButtonMappingReply rep;\n\n    LockDisplay(dpy);\n    if (_XiCheckExtInit(dpy, XInput_Initial_Release, info) == -1)\n\treturn (NoSuchExtension);\n    GetReq(GetDeviceButtonMapping, req);\n\n    req->reqType = info->codes->major_opcode;\n    req->ReqType = X_GetDeviceButtonMapping;\n    req->deviceid = device->device_id;\n\n    status = _XReply(dpy, (xReply *) & rep, 0, xFalse);\n    if (status == 1) {\n\tif (rep.length <= (sizeof(mapping) >> 2)) {\n\t    unsigned long nbytes = rep.length << 2;\n\t    _XRead(dpy, (char *)mapping, nbytes);\n\n\t    /* don't return more data than the user asked for. */\n\t    if (rep.nElts)\n\t\tmemcpy(map, mapping, MIN((int)rep.nElts, nmap));\n\t    status = rep.nElts;\n\t} else {\n\t    _XEatDataWords(dpy, rep.length);\n\t    status = 0;\n\t}\n    } else\n\tstatus = 0;\n    UnlockDisplay(dpy);\n    SyncHandle();\n    return (status);\n}",
        "func": "int\nXGetDeviceButtonMapping(\n    register Display\t*dpy,\n    XDevice\t\t*device,\n    unsigned char\t map[],\n    unsigned int\t nmap)\n{\n    int status = 0;\n    unsigned char mapping[256];\t/* known fixed size */\n    XExtDisplayInfo *info = XInput_find_display(dpy);\n\n    register xGetDeviceButtonMappingReq *req;\n    xGetDeviceButtonMappingReply rep;\n\n    LockDisplay(dpy);\n    if (_XiCheckExtInit(dpy, XInput_Initial_Release, info) == -1)\n\treturn (NoSuchExtension);\n    GetReq(GetDeviceButtonMapping, req);\n\n    req->reqType = info->codes->major_opcode;\n    req->ReqType = X_GetDeviceButtonMapping;\n    req->deviceid = device->device_id;\n\n    status = _XReply(dpy, (xReply *) & rep, 0, xFalse);\n    if (status == 1) {\n\tif (rep.length <= (sizeof(mapping) >> 2) &&\n\t    rep.nElts <= (rep.length << 2)) {\n\t    unsigned long nbytes = rep.length << 2;\n\t    _XRead(dpy, (char *)mapping, nbytes);\n\n\t    /* don't return more data than the user asked for. */\n\t    if (rep.nElts)\n\t\tmemcpy(map, mapping, MIN((int)rep.nElts, nmap));\n\t    status = rep.nElts;\n\t} else {\n\t    _XEatDataWords(dpy, rep.length);\n\t    status = 0;\n\t}\n    } else\n\tstatus = 0;\n    UnlockDisplay(dpy);\n    SyncHandle();\n    return (status);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -23,7 +23,8 @@\n \n     status = _XReply(dpy, (xReply *) & rep, 0, xFalse);\n     if (status == 1) {\n-\tif (rep.length <= (sizeof(mapping) >> 2)) {\n+\tif (rep.length <= (sizeof(mapping) >> 2) &&\n+\t    rep.nElts <= (rep.length << 2)) {\n \t    unsigned long nbytes = rep.length << 2;\n \t    _XRead(dpy, (char *)mapping, nbytes);\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (rep.length <= (sizeof(mapping) >> 2)) {"
            ],
            "added_lines": [
                "\tif (rep.length <= (sizeof(mapping) >> 2) &&",
                "\t    rep.nElts <= (rep.length << 2)) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-7951",
        "func_name": "xorg/lib/libXtst/parse_reply_call_callback",
        "description": "Multiple integer overflows in X.org libXtst before 1.2.3 allow remote X servers to trigger out-of-bounds memory access operations by leveraging the lack of range checks.",
        "git_url": "https://cgit.freedesktop.org/xorg/lib/libXtst/commit/?id=9556ad67af3129ec4a7a4f4b54a0d59701beeae3",
        "commit_title": "A lack of range checks in libXtst allows out of boundary accesses.",
        "commit_text": "The checks have to be done in-place here, because it cannot be done without in-depth knowledge of the read data.  If XRecordStartOfData, XRecordEndOfData, or XRecordClientDied without a client sequence have attached data, an endless loop would occur. The do-while-loop continues until the current index reaches the end. But in these cases, the current index would not be incremented, leading to an endless processing.  ",
        "func_before": "static enum parser_return\nparse_reply_call_callback(\n    Display *dpy,\n    XExtDisplayInfo *info,\n    xRecordEnableContextReply *rep,\n    struct reply_buffer *reply,\n    XRecordInterceptProc callback,\n    XPointer\t\t closure)\n{\n    int current_index;\n    int datum_bytes = 0;\n    XRecordInterceptData *data;\n\n    /* call the callback for each protocol element in the reply */\n    current_index = 0;\n    do {\n\tdata = alloc_inter_data(info);\n\tif (!data)\n\t    return Error;\n\n\tdata->id_base = rep->idBase;\n\tdata->category = rep->category;\n\tdata->client_swapped = rep->clientSwapped;\n\tdata->server_time = rep->serverTime;\n\tdata->client_seq = rep->recordedSequenceNumber;\n\t/*\n\t * compute the size of this protocol element.\n\t */\n\tswitch (rep->category) {\n\tcase XRecordFromServer:\n\t    if (rep->elementHeader&XRecordFromServerTime) {\n\t\tEXTRACT_CARD32(rep->clientSwapped,\n\t\t\t       reply->buf+current_index,\n\t\t\t       data->server_time);\n\t\tcurrent_index += 4;\n\t    }\n\t    switch (reply->buf[current_index]) {\n\t    case X_Reply: /* reply */\n\t\tEXTRACT_CARD32(rep->clientSwapped,\n\t\t\t       reply->buf+current_index+4, datum_bytes);\n\t\tdatum_bytes = (datum_bytes+8) << 2;\n\t\tbreak;\n\t    default: /* error or event */\n\t\tdatum_bytes = 32;\n\t    }\n\t    break;\n\tcase XRecordFromClient:\n\t    if (rep->elementHeader&XRecordFromClientTime) {\n\t\tEXTRACT_CARD32(rep->clientSwapped,\n\t\t\t       reply->buf+current_index,\n\t\t\t       data->server_time);\n\t\tcurrent_index += 4;\n\t    }\n\t    if (rep->elementHeader&XRecordFromClientSequence) {\n\t\tEXTRACT_CARD32(rep->clientSwapped,\n\t\t\t       reply->buf+current_index,\n\t\t\t       data->client_seq);\n\t\tcurrent_index += 4;\n\t    }\n\t    if (reply->buf[current_index+2] == 0\n\t\t&& reply->buf[current_index+3] == 0) /* needn't swap 0 */\n\t    {\t/* BIG-REQUESTS */\n\t\tEXTRACT_CARD32(rep->clientSwapped,\n\t\t\t       reply->buf+current_index+4, datum_bytes);\n\t    } else {\n\t\tEXTRACT_CARD16(rep->clientSwapped,\n\t\t\t       reply->buf+current_index+2, datum_bytes);\n\t    }\n\t    datum_bytes <<= 2;\n\t    break;\n\tcase XRecordClientStarted:\n\t    EXTRACT_CARD16(rep->clientSwapped,\n\t\t\t   reply->buf+current_index+6, datum_bytes);\n\t    datum_bytes = (datum_bytes+2) << 2;\n\t    break;\n\tcase XRecordClientDied:\n\t    if (rep->elementHeader&XRecordFromClientSequence) {\n\t\tEXTRACT_CARD32(rep->clientSwapped,\n\t\t\t       reply->buf+current_index,\n\t\t\t       data->client_seq);\n\t\tcurrent_index += 4;\n\t    }\n\t    /* fall through */\n\tcase XRecordStartOfData:\n\tcase XRecordEndOfData:\n\t    datum_bytes = 0;\n\t}\n\n\tif (datum_bytes > 0) {\n\t    if (current_index + datum_bytes > rep->length << 2)\n\t\tfprintf(stderr,\n\t\t\t\"XRecord: %lu-byte reply claims %d-byte element (seq %lu)\\n\",\n\t\t\t(long)rep->length << 2, current_index + datum_bytes,\n\t\t\tdpy->last_request_read);\n\t    /*\n\t     * This assignment (and indeed the whole buffer sharing\n\t     * scheme) assumes arbitrary 4-byte boundaries are\n\t     * addressable.\n\t     */\n\t    data->data = reply->buf+current_index;\n\t    reply->ref_count++;\n\t} else {\n\t    data->data = NULL;\n\t}\n\tdata->data_len = datum_bytes >> 2;\n\n\t(*callback)(closure, data);\n\n\tcurrent_index += datum_bytes;\n    } while (current_index<rep->length<<2);\n\n    if (rep->category == XRecordEndOfData)\n\treturn End;\n\n    return Continue;\n}",
        "func": "static enum parser_return\nparse_reply_call_callback(\n    Display *dpy,\n    XExtDisplayInfo *info,\n    xRecordEnableContextReply *rep,\n    struct reply_buffer *reply,\n    XRecordInterceptProc callback,\n    XPointer\t\t closure)\n{\n    int current_index;\n    int datum_bytes = 0;\n    XRecordInterceptData *data;\n\n    /* call the callback for each protocol element in the reply */\n    current_index = 0;\n    do {\n\tdata = alloc_inter_data(info);\n\tif (!data)\n\t    return Error;\n\n\tdata->id_base = rep->idBase;\n\tdata->category = rep->category;\n\tdata->client_swapped = rep->clientSwapped;\n\tdata->server_time = rep->serverTime;\n\tdata->client_seq = rep->recordedSequenceNumber;\n\t/*\n\t * compute the size of this protocol element.\n\t */\n\tswitch (rep->category) {\n\tcase XRecordFromServer:\n\t    if (rep->elementHeader&XRecordFromServerTime) {\n\t\tif (current_index + 4 > rep->length << 2)\n\t\t    return Error;\n\t\tEXTRACT_CARD32(rep->clientSwapped,\n\t\t\t       reply->buf+current_index,\n\t\t\t       data->server_time);\n\t\tcurrent_index += 4;\n\t    }\n\t    if (current_index + 1 > rep->length << 2)\n\t\treturn Error;\n\t    switch (reply->buf[current_index]) {\n\t    case X_Reply: /* reply */\n\t\tif (current_index + 8 > rep->length << 2)\n\t\t    return Error;\n\t\tEXTRACT_CARD32(rep->clientSwapped,\n\t\t\t       reply->buf+current_index+4, datum_bytes);\n\t\tif (datum_bytes < 0 || datum_bytes > ((INT_MAX >> 2) - 8))\n\t\t    return Error;\n\t\tdatum_bytes = (datum_bytes+8) << 2;\n\t\tbreak;\n\t    default: /* error or event */\n\t\tdatum_bytes = 32;\n\t    }\n\t    break;\n\tcase XRecordFromClient:\n\t    if (rep->elementHeader&XRecordFromClientTime) {\n\t\tif (current_index + 4 > rep->length << 2)\n\t\t    return Error;\n\t\tEXTRACT_CARD32(rep->clientSwapped,\n\t\t\t       reply->buf+current_index,\n\t\t\t       data->server_time);\n\t\tcurrent_index += 4;\n\t    }\n\t    if (rep->elementHeader&XRecordFromClientSequence) {\n\t\tif (current_index + 4 > rep->length << 2)\n\t\t    return Error;\n\t\tEXTRACT_CARD32(rep->clientSwapped,\n\t\t\t       reply->buf+current_index,\n\t\t\t       data->client_seq);\n\t\tcurrent_index += 4;\n\t    }\n\t    if (current_index + 4 > rep->length<<2)\n\t\treturn Error;\n\t    if (reply->buf[current_index+2] == 0\n\t\t&& reply->buf[current_index+3] == 0) /* needn't swap 0 */\n\t    {\t/* BIG-REQUESTS */\n\t\tif (current_index + 8 > rep->length << 2)\n\t\t    return Error;\n\t\tEXTRACT_CARD32(rep->clientSwapped,\n\t\t\t       reply->buf+current_index+4, datum_bytes);\n\t    } else {\n\t\tEXTRACT_CARD16(rep->clientSwapped,\n\t\t\t       reply->buf+current_index+2, datum_bytes);\n\t    }\n\t    if (datum_bytes < 0 || datum_bytes > INT_MAX >> 2)\n\t\treturn Error;\n\t    datum_bytes <<= 2;\n\t    break;\n\tcase XRecordClientStarted:\n\t    if (current_index + 8 > rep->length << 2)\n\t\treturn Error;\n\t    EXTRACT_CARD16(rep->clientSwapped,\n\t\t\t   reply->buf+current_index+6, datum_bytes);\n\t    datum_bytes = (datum_bytes+2) << 2;\n\t    break;\n\tcase XRecordClientDied:\n\t    if (rep->elementHeader&XRecordFromClientSequence) {\n\t\tif (current_index + 4 > rep->length << 2)\n\t\t    return Error;\n\t\tEXTRACT_CARD32(rep->clientSwapped,\n\t\t\t       reply->buf+current_index,\n\t\t\t       data->client_seq);\n\t\tcurrent_index += 4;\n\t    } else if (current_index < rep->length << 2)\n\t\treturn Error;\n\t    datum_bytes = 0;\n\t    break;\n\tcase XRecordStartOfData:\n\tcase XRecordEndOfData:\n\t    if (current_index < rep->length << 2)\n\t\treturn Error;\n\t    datum_bytes = 0;\n\t    break;\n\t}\n\n\tif (datum_bytes > 0) {\n\t    if (INT_MAX - datum_bytes < (rep->length << 2) - current_index) {\n\t\tfprintf(stderr,\n\t\t\t\"XRecord: %lu-byte reply claims %d-byte element (seq %lu)\\n\",\n\t\t\t(unsigned long)rep->length << 2, current_index + datum_bytes,\n\t\t\tdpy->last_request_read);\n\t\treturn Error;\n\t    }\n\t    /*\n\t     * This assignment (and indeed the whole buffer sharing\n\t     * scheme) assumes arbitrary 4-byte boundaries are\n\t     * addressable.\n\t     */\n\t    data->data = reply->buf+current_index;\n\t    reply->ref_count++;\n\t} else {\n\t    data->data = NULL;\n\t}\n\tdata->data_len = datum_bytes >> 2;\n\n\t(*callback)(closure, data);\n\n\tcurrent_index += datum_bytes;\n    } while (current_index<rep->length<<2);\n\n    if (rep->category == XRecordEndOfData)\n\treturn End;\n\n    return Continue;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -29,15 +29,23 @@\n \tswitch (rep->category) {\n \tcase XRecordFromServer:\n \t    if (rep->elementHeader&XRecordFromServerTime) {\n+\t\tif (current_index + 4 > rep->length << 2)\n+\t\t    return Error;\n \t\tEXTRACT_CARD32(rep->clientSwapped,\n \t\t\t       reply->buf+current_index,\n \t\t\t       data->server_time);\n \t\tcurrent_index += 4;\n \t    }\n+\t    if (current_index + 1 > rep->length << 2)\n+\t\treturn Error;\n \t    switch (reply->buf[current_index]) {\n \t    case X_Reply: /* reply */\n+\t\tif (current_index + 8 > rep->length << 2)\n+\t\t    return Error;\n \t\tEXTRACT_CARD32(rep->clientSwapped,\n \t\t\t       reply->buf+current_index+4, datum_bytes);\n+\t\tif (datum_bytes < 0 || datum_bytes > ((INT_MAX >> 2) - 8))\n+\t\t    return Error;\n \t\tdatum_bytes = (datum_bytes+8) << 2;\n \t\tbreak;\n \t    default: /* error or event */\n@@ -46,52 +54,73 @@\n \t    break;\n \tcase XRecordFromClient:\n \t    if (rep->elementHeader&XRecordFromClientTime) {\n+\t\tif (current_index + 4 > rep->length << 2)\n+\t\t    return Error;\n \t\tEXTRACT_CARD32(rep->clientSwapped,\n \t\t\t       reply->buf+current_index,\n \t\t\t       data->server_time);\n \t\tcurrent_index += 4;\n \t    }\n \t    if (rep->elementHeader&XRecordFromClientSequence) {\n+\t\tif (current_index + 4 > rep->length << 2)\n+\t\t    return Error;\n \t\tEXTRACT_CARD32(rep->clientSwapped,\n \t\t\t       reply->buf+current_index,\n \t\t\t       data->client_seq);\n \t\tcurrent_index += 4;\n \t    }\n+\t    if (current_index + 4 > rep->length<<2)\n+\t\treturn Error;\n \t    if (reply->buf[current_index+2] == 0\n \t\t&& reply->buf[current_index+3] == 0) /* needn't swap 0 */\n \t    {\t/* BIG-REQUESTS */\n+\t\tif (current_index + 8 > rep->length << 2)\n+\t\t    return Error;\n \t\tEXTRACT_CARD32(rep->clientSwapped,\n \t\t\t       reply->buf+current_index+4, datum_bytes);\n \t    } else {\n \t\tEXTRACT_CARD16(rep->clientSwapped,\n \t\t\t       reply->buf+current_index+2, datum_bytes);\n \t    }\n+\t    if (datum_bytes < 0 || datum_bytes > INT_MAX >> 2)\n+\t\treturn Error;\n \t    datum_bytes <<= 2;\n \t    break;\n \tcase XRecordClientStarted:\n+\t    if (current_index + 8 > rep->length << 2)\n+\t\treturn Error;\n \t    EXTRACT_CARD16(rep->clientSwapped,\n \t\t\t   reply->buf+current_index+6, datum_bytes);\n \t    datum_bytes = (datum_bytes+2) << 2;\n \t    break;\n \tcase XRecordClientDied:\n \t    if (rep->elementHeader&XRecordFromClientSequence) {\n+\t\tif (current_index + 4 > rep->length << 2)\n+\t\t    return Error;\n \t\tEXTRACT_CARD32(rep->clientSwapped,\n \t\t\t       reply->buf+current_index,\n \t\t\t       data->client_seq);\n \t\tcurrent_index += 4;\n-\t    }\n-\t    /* fall through */\n+\t    } else if (current_index < rep->length << 2)\n+\t\treturn Error;\n+\t    datum_bytes = 0;\n+\t    break;\n \tcase XRecordStartOfData:\n \tcase XRecordEndOfData:\n+\t    if (current_index < rep->length << 2)\n+\t\treturn Error;\n \t    datum_bytes = 0;\n+\t    break;\n \t}\n \n \tif (datum_bytes > 0) {\n-\t    if (current_index + datum_bytes > rep->length << 2)\n+\t    if (INT_MAX - datum_bytes < (rep->length << 2) - current_index) {\n \t\tfprintf(stderr,\n \t\t\t\"XRecord: %lu-byte reply claims %d-byte element (seq %lu)\\n\",\n-\t\t\t(long)rep->length << 2, current_index + datum_bytes,\n+\t\t\t(unsigned long)rep->length << 2, current_index + datum_bytes,\n \t\t\tdpy->last_request_read);\n+\t\treturn Error;\n+\t    }\n \t    /*\n \t     * This assignment (and indeed the whole buffer sharing\n \t     * scheme) assumes arbitrary 4-byte boundaries are",
        "diff_line_info": {
            "deleted_lines": [
                "\t    }",
                "\t    /* fall through */",
                "\t    if (current_index + datum_bytes > rep->length << 2)",
                "\t\t\t(long)rep->length << 2, current_index + datum_bytes,"
            ],
            "added_lines": [
                "\t\tif (current_index + 4 > rep->length << 2)",
                "\t\t    return Error;",
                "\t    if (current_index + 1 > rep->length << 2)",
                "\t\treturn Error;",
                "\t\tif (current_index + 8 > rep->length << 2)",
                "\t\t    return Error;",
                "\t\tif (datum_bytes < 0 || datum_bytes > ((INT_MAX >> 2) - 8))",
                "\t\t    return Error;",
                "\t\tif (current_index + 4 > rep->length << 2)",
                "\t\t    return Error;",
                "\t\tif (current_index + 4 > rep->length << 2)",
                "\t\t    return Error;",
                "\t    if (current_index + 4 > rep->length<<2)",
                "\t\treturn Error;",
                "\t\tif (current_index + 8 > rep->length << 2)",
                "\t\t    return Error;",
                "\t    if (datum_bytes < 0 || datum_bytes > INT_MAX >> 2)",
                "\t\treturn Error;",
                "\t    if (current_index + 8 > rep->length << 2)",
                "\t\treturn Error;",
                "\t\tif (current_index + 4 > rep->length << 2)",
                "\t\t    return Error;",
                "\t    } else if (current_index < rep->length << 2)",
                "\t\treturn Error;",
                "\t    datum_bytes = 0;",
                "\t    break;",
                "\t    if (current_index < rep->length << 2)",
                "\t\treturn Error;",
                "\t    break;",
                "\t    if (INT_MAX - datum_bytes < (rep->length << 2) - current_index) {",
                "\t\t\t(unsigned long)rep->length << 2, current_index + datum_bytes,",
                "\t\treturn Error;",
                "\t    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-7951",
        "func_name": "xorg/lib/libXtst/XRecordEnableContext",
        "description": "Multiple integer overflows in X.org libXtst before 1.2.3 allow remote X servers to trigger out-of-bounds memory access operations by leveraging the lack of range checks.",
        "git_url": "https://cgit.freedesktop.org/xorg/lib/libXtst/commit/?id=9556ad67af3129ec4a7a4f4b54a0d59701beeae3",
        "commit_title": "A lack of range checks in libXtst allows out of boundary accesses.",
        "commit_text": "The checks have to be done in-place here, because it cannot be done without in-depth knowledge of the read data.  If XRecordStartOfData, XRecordEndOfData, or XRecordClientDied without a client sequence have attached data, an endless loop would occur. The do-while-loop continues until the current index reaches the end. But in these cases, the current index would not be incremented, leading to an endless processing.  ",
        "func_before": "Status\nXRecordEnableContext(Display *dpy, XRecordContext context,\n\t\t     XRecordInterceptProc callback, XPointer closure)\n{\n    XExtDisplayInfo *info = find_display (dpy);\n    register xRecordEnableContextReq   \t*req;\n    xRecordEnableContextReply \trep;\n    struct reply_buffer *reply;\n    enum parser_return status;\n\n    XRecordCheckExtension (dpy, info, 0);\n    LockDisplay(dpy);\n    GetReq(RecordEnableContext, req);\n\n    req->reqType = info->codes->major_opcode;\n    req->recordReqType = X_RecordEnableContext;\n    req->context = context;\n\n    while (1)\n    {\n\t/* This code should match that in XRecordEnableContextAsync */\n\tif (!_XReply (dpy, (xReply *)&rep, 0, xFalse))\n\t{\n\t    UnlockDisplay(dpy);\n\t    SyncHandle();\n\t    return 0;\n\t}\n\n\tif (rep.length > 0) {\n\t    reply = alloc_reply_buffer(info, rep.length<<2);\n\t    if (!reply) {\n\t\tUnlockDisplay(dpy);\n\t\tSyncHandle();\n\t\treturn 0;\n\t    }\n\t    _XRead (dpy, (char *)reply->buf, rep.length<<2);\n\t} else {\n\t    reply = NULL;\n\t}\n\n\tstatus = parse_reply_call_callback(dpy, info, &rep, reply,\n\t\t\t\t\t   callback, closure);\n\tswitch (status) {\n\tcase Continue:\n\t    break;\n\tcase End:\n\t    UnlockDisplay(dpy);\n\t    SyncHandle();\n\t    return 1;\n\tcase Error:\n\t    UnlockDisplay(dpy);\n\t    SyncHandle();\n\t    return 0;\n\t}\n    }\n}",
        "func": "Status\nXRecordEnableContext(Display *dpy, XRecordContext context,\n\t\t     XRecordInterceptProc callback, XPointer closure)\n{\n    XExtDisplayInfo *info = find_display (dpy);\n    register xRecordEnableContextReq   \t*req;\n    xRecordEnableContextReply \trep;\n    struct reply_buffer *reply;\n    enum parser_return status;\n\n    XRecordCheckExtension (dpy, info, 0);\n    LockDisplay(dpy);\n    GetReq(RecordEnableContext, req);\n\n    req->reqType = info->codes->major_opcode;\n    req->recordReqType = X_RecordEnableContext;\n    req->context = context;\n\n    while (1)\n    {\n\t/* This code should match that in XRecordEnableContextAsync */\n\tif (!_XReply (dpy, (xReply *)&rep, 0, xFalse))\n\t{\n\t    UnlockDisplay(dpy);\n\t    SyncHandle();\n\t    return 0;\n\t}\n\n\tif (rep.length > INT_MAX >> 2) {\n\t    UnlockDisplay(dpy);\n\t    SyncHandle();\n\t    return 0;\n\t}\n\n\tif (rep.length > 0) {\n\t    reply = alloc_reply_buffer(info, rep.length<<2);\n\t    if (!reply) {\n\t\tUnlockDisplay(dpy);\n\t\tSyncHandle();\n\t\treturn 0;\n\t    }\n\t    _XRead (dpy, (char *)reply->buf, rep.length<<2);\n\t} else {\n\t    reply = NULL;\n\t}\n\n\tstatus = parse_reply_call_callback(dpy, info, &rep, reply,\n\t\t\t\t\t   callback, closure);\n\tswitch (status) {\n\tcase Continue:\n\t    break;\n\tcase End:\n\t    UnlockDisplay(dpy);\n\t    SyncHandle();\n\t    return 1;\n\tcase Error:\n\t    UnlockDisplay(dpy);\n\t    SyncHandle();\n\t    return 0;\n\t}\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -21,6 +21,12 @@\n \t/* This code should match that in XRecordEnableContextAsync */\n \tif (!_XReply (dpy, (xReply *)&rep, 0, xFalse))\n \t{\n+\t    UnlockDisplay(dpy);\n+\t    SyncHandle();\n+\t    return 0;\n+\t}\n+\n+\tif (rep.length > INT_MAX >> 2) {\n \t    UnlockDisplay(dpy);\n \t    SyncHandle();\n \t    return 0;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t    UnlockDisplay(dpy);",
                "\t    SyncHandle();",
                "\t    return 0;",
                "\t}",
                "",
                "\tif (rep.length > INT_MAX >> 2) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-10030",
        "func_name": "SchedMD/slurm/_prolog_error",
        "description": "The _prolog_error function in slurmd/req.c in Slurm before 15.08.13, 16.x before 16.05.7, and 17.x before 17.02.0-pre4 has a vulnerability in how the slurmd daemon informs users of a Prolog failure on a compute node. That vulnerability could allow a user to assume control of an arbitrary file on the system. Any exploitation of this is dependent on the user being able to cause or anticipate the failure (non-zero return code) of a Prolog script that their job would run on. This issue affects all Slurm versions from 0.6.0 (September 2005) to present. Workarounds to prevent exploitation of this are to either disable your Prolog script, or modify it such that it always returns 0 (\"success\") and adjust it to set the node as down using scontrol instead of relying on the slurmd to handle that automatically. If you do not have a Prolog set you are unaffected by this issue.",
        "git_url": "https://github.com/SchedMD/slurm/commit/92362a92fffe60187df61f99ab11c249d44120ee",
        "commit_title": "Fix security issue in _prolog_error().",
        "commit_text": " Fix security issue caused by insecure file path handling triggered by the failure of a Prolog script. To exploit this a user needs to anticipate or cause the Prolog to fail for their job.  (This commit is slightly different from the fix to the 15.08 branch.)  CVE-2016-10030.",
        "func_before": "static void\n_prolog_error(batch_job_launch_msg_t *req, int rc)\n{\n\tchar *err_name_ptr, err_name[256], path_name[MAXPATHLEN];\n\tchar *fmt_char;\n\tint fd;\n\n\tif (req->std_err || req->std_out) {\n\t\tif (req->std_err)\n\t\t\tstrncpy(err_name, req->std_err, sizeof(err_name));\n\t\telse\n\t\t\tstrncpy(err_name, req->std_out, sizeof(err_name));\n\t\tif ((fmt_char = strchr(err_name, (int) '%')) &&\n\t\t    (fmt_char[1] == 'j') && !strchr(fmt_char+1, (int) '%')) {\n\t\t\tchar tmp_name[256];\n\t\t\tfmt_char[1] = 'u';\n\t\t\tsnprintf(tmp_name, sizeof(tmp_name), err_name,\n\t\t\t\t req->job_id);\n\t\t\tstrncpy(err_name, tmp_name, sizeof(err_name));\n\t\t}\n\t} else {\n\t\tsnprintf(err_name, sizeof(err_name), \"slurm-%u.out\",\n\t\t\t req->job_id);\n\t}\n\terr_name_ptr = err_name;\n\tif (err_name_ptr[0] == '/')\n\t\tsnprintf(path_name, MAXPATHLEN, \"%s\", err_name_ptr);\n\telse if (req->work_dir)\n\t\tsnprintf(path_name, MAXPATHLEN, \"%s/%s\",\n\t\t\treq->work_dir, err_name_ptr);\n\telse\n\t\tsnprintf(path_name, MAXPATHLEN, \"/%s\", err_name_ptr);\n\n\tif ((fd = open(path_name, (O_CREAT|O_APPEND|O_WRONLY), 0644)) == -1) {\n\t\terror(\"Unable to open %s: %s\", path_name,\n\t\t      slurm_strerror(errno));\n\t\treturn;\n\t}\n\tsnprintf(err_name, sizeof(err_name),\n\t\t \"Error running slurm prolog: %d\\n\", WEXITSTATUS(rc));\n\tsafe_write(fd, err_name, strlen(err_name));\n\tif (fchown(fd, (uid_t) req->uid, (gid_t) req->gid) == -1) {\n\t\tsnprintf(err_name, sizeof(err_name),\n\t\t\t \"Couldn't change fd owner to %u:%u: %m\\n\",\n\t\t\t req->uid, req->gid);\n\t}\nrwfail:\n\tclose(fd);\n}",
        "func": "static void\n_prolog_error(batch_job_launch_msg_t *req, int rc)\n{\n\tchar *err_name_ptr, err_name[256], path_name[MAXPATHLEN];\n\tchar *fmt_char;\n\tint fd;\n\n\tif (req->std_err || req->std_out) {\n\t\tif (req->std_err)\n\t\t\tstrncpy(err_name, req->std_err, sizeof(err_name));\n\t\telse\n\t\t\tstrncpy(err_name, req->std_out, sizeof(err_name));\n\t\tif ((fmt_char = strchr(err_name, (int) '%')) &&\n\t\t    (fmt_char[1] == 'j') && !strchr(fmt_char+1, (int) '%')) {\n\t\t\tchar tmp_name[256];\n\t\t\tfmt_char[1] = 'u';\n\t\t\tsnprintf(tmp_name, sizeof(tmp_name), err_name,\n\t\t\t\t req->job_id);\n\t\t\tstrncpy(err_name, tmp_name, sizeof(err_name));\n\t\t}\n\t} else {\n\t\tsnprintf(err_name, sizeof(err_name), \"slurm-%u.out\",\n\t\t\t req->job_id);\n\t}\n\terr_name_ptr = err_name;\n\tif (err_name_ptr[0] == '/')\n\t\tsnprintf(path_name, MAXPATHLEN, \"%s\", err_name_ptr);\n\telse if (req->work_dir)\n\t\tsnprintf(path_name, MAXPATHLEN, \"%s/%s\",\n\t\t\treq->work_dir, err_name_ptr);\n\telse\n\t\tsnprintf(path_name, MAXPATHLEN, \"/%s\", err_name_ptr);\n\tif ((fd = _open_as_other(path_name, req)) == -1) {\n\t\terror(\"Unable to open %s: Permission denied\", path_name);\n\t\treturn;\n\t}\n\tsnprintf(err_name, sizeof(err_name),\n\t\t \"Error running slurm prolog: %d\\n\", WEXITSTATUS(rc));\n\tsafe_write(fd, err_name, strlen(err_name));\n\tif (fchown(fd, (uid_t) req->uid, (gid_t) req->gid) == -1) {\n\t\tsnprintf(err_name, sizeof(err_name),\n\t\t\t \"Couldn't change fd owner to %u:%u: %m\\n\",\n\t\t\t req->uid, req->gid);\n\t}\nrwfail:\n\tclose(fd);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -30,10 +30,8 @@\n \t\t\treq->work_dir, err_name_ptr);\n \telse\n \t\tsnprintf(path_name, MAXPATHLEN, \"/%s\", err_name_ptr);\n-\n-\tif ((fd = open(path_name, (O_CREAT|O_APPEND|O_WRONLY), 0644)) == -1) {\n-\t\terror(\"Unable to open %s: %s\", path_name,\n-\t\t      slurm_strerror(errno));\n+\tif ((fd = _open_as_other(path_name, req)) == -1) {\n+\t\terror(\"Unable to open %s: Permission denied\", path_name);\n \t\treturn;\n \t}\n \tsnprintf(err_name, sizeof(err_name),",
        "diff_line_info": {
            "deleted_lines": [
                "",
                "\tif ((fd = open(path_name, (O_CREAT|O_APPEND|O_WRONLY), 0644)) == -1) {",
                "\t\terror(\"Unable to open %s: %s\", path_name,",
                "\t\t      slurm_strerror(errno));"
            ],
            "added_lines": [
                "\tif ((fd = _open_as_other(path_name, req)) == -1) {",
                "\t\terror(\"Unable to open %s: Permission denied\", path_name);"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-6255",
        "func_name": "mjg59/pupnp-code/http_RecvPostMessage",
        "description": "Portable UPnP SDK (aka libupnp) before 1.6.21 allows remote attackers to write to arbitrary files in the webroot via a POST request without a registered handler.",
        "git_url": "https://github.com/mjg59/pupnp-code/commit/be0a01bdb83395d9f3a5ea09c1308a4f1a972cbd",
        "commit_title": "Don't allow unhandled POSTs to write to the filesystem by default",
        "commit_text": " If there's no registered handler for a POST request, the default behaviour is to write it to the filesystem. Several million deployed devices appear to have this behaviour, making it possible to (at least) store arbitrary data on them. Add a configure option that enables this behaviour, and change the default to just drop POSTs that aren't directly handled.",
        "func_before": "static int http_RecvPostMessage(\n\t/*! HTTP Parser object. */\n\thttp_parser_t *parser,\n\t/*! [in] Socket Information object. */\n\tSOCKINFO *info,\n\t/*! File where received data is copied to. */\n\tchar *filename,\n\t/*! Send Instruction object which gives information whether the file\n\t * is a virtual file or not. */\n\tstruct SendInstruction *Instr)\n{\n\tsize_t Data_Buf_Size = 1024;\n\tchar Buf[1024];\n\tint Timeout = -1;\n\tFILE *Fp;\n\tparse_status_t status = PARSE_OK;\n\tint ok_on_close = FALSE;\n\tsize_t entity_offset = 0;\n\tint num_read = 0;\n\tint ret_code = HTTP_OK;\n\n\tif (Instr && Instr->IsVirtualFile) {\n\t\tFp = (virtualDirCallback.open) (filename, UPNP_WRITE);\n\t\tif (Fp == NULL)\n\t\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t} else {\n\t\tFp = fopen(filename, \"wb\");\n\t\tif (Fp == NULL)\n\t\t\treturn HTTP_UNAUTHORIZED;\n\t}\n\tparser->position = POS_ENTITY;\n\tdo {\n\t\t/* first parse what has already been gotten */\n\t\tif (parser->position != POS_COMPLETE)\n\t\t\tstatus = parser_parse_entity(parser);\n\t\tif (status == PARSE_INCOMPLETE_ENTITY) {\n\t\t\t/* read until close */\n\t\t\tok_on_close = TRUE;\n\t\t} else if ((status != PARSE_SUCCESS)\n\t\t\t   && (status != PARSE_CONTINUE_1)\n\t\t\t   && (status != PARSE_INCOMPLETE)) {\n\t\t\t/* error */\n\t\t\tret_code = HTTP_BAD_REQUEST;\n\t\t\tgoto ExitFunction;\n\t\t}\n\t\t/* read more if necessary entity */\n\t\twhile (entity_offset + Data_Buf_Size > parser->msg.entity.length &&\n\t\t       parser->position != POS_COMPLETE) {\n\t\t\tnum_read = sock_read(info, Buf, sizeof(Buf), &Timeout);\n\t\t\tif (num_read > 0) {\n\t\t\t\t/* append data to buffer */\n\t\t\t\tif (membuffer_append(&parser->msg.msg,\n\t\t\t\t\tBuf, (size_t)num_read) != 0) {\n\t\t\t\t\t/* set failure status */\n\t\t\t\t\tparser->http_error_code =\n\t\t\t\t\t    HTTP_INTERNAL_SERVER_ERROR;\n\t\t\t\t\tret_code = HTTP_INTERNAL_SERVER_ERROR;\n\t\t\t\t\tgoto ExitFunction;\n\t\t\t\t}\n\t\t\t\tstatus = parser_parse_entity(parser);\n\t\t\t\tif (status == PARSE_INCOMPLETE_ENTITY) {\n\t\t\t\t\t/* read until close */\n\t\t\t\t\tok_on_close = TRUE;\n\t\t\t\t} else if ((status != PARSE_SUCCESS)\n\t\t\t\t\t   && (status != PARSE_CONTINUE_1)\n\t\t\t\t\t   && (status != PARSE_INCOMPLETE)) {\n\t\t\t\t\tret_code = HTTP_BAD_REQUEST;\n\t\t\t\t\tgoto ExitFunction;\n\t\t\t\t}\n\t\t\t} else if (num_read == 0) {\n\t\t\t\tif (ok_on_close) {\n\t\t\t\t\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t\t\t\t\"<<< (RECVD) <<<\\n%s\\n-----------------\\n\",\n\t\t\t\t\t\tparser->msg.msg.buf);\n\t\t\t\t\tprint_http_headers(&parser->msg);\n\t\t\t\t\tparser->position = POS_COMPLETE;\n\t\t\t\t} else {\n\t\t\t\t\t/* partial msg or response */\n\t\t\t\t\tparser->http_error_code = HTTP_BAD_REQUEST;\n\t\t\t\t\tret_code = HTTP_BAD_REQUEST;\n\t\t\t\t\tgoto ExitFunction;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tret_code = HTTP_SERVICE_UNAVAILABLE;\n\t\t\t\tgoto ExitFunction;\n\t\t\t}\n\t\t}\n\t\tif ((entity_offset + Data_Buf_Size) > parser->msg.entity.length) {\n\t\t\tData_Buf_Size =\n\t\t\t    parser->msg.entity.length - entity_offset;\n\t\t}\n\t\tmemcpy(Buf,\n\t\t       &parser->msg.msg.buf[parser->entity_start_position + entity_offset],\n\t\t       Data_Buf_Size);\n\t\tentity_offset += Data_Buf_Size;\n\t\tif (Instr && Instr->IsVirtualFile) {\n\t\t\tint n = virtualDirCallback.write(Fp, Buf, Data_Buf_Size);\n\t\t\tif (n < 0) {\n\t\t\t\tret_code = HTTP_INTERNAL_SERVER_ERROR;\n\t\t\t\tgoto ExitFunction;\n\t\t\t}\n\t\t} else {\n\t\t\tsize_t n = fwrite(Buf, 1, Data_Buf_Size, Fp);\n\t\t\tif (n != Data_Buf_Size) {\n\t\t\t\tret_code = HTTP_INTERNAL_SERVER_ERROR;\n\t\t\t\tgoto ExitFunction;\n\t\t\t}\n\t\t}\n\t} while (parser->position != POS_COMPLETE ||\n\t\t entity_offset != parser->msg.entity.length);\nExitFunction:\n\tif (Instr && Instr->IsVirtualFile) {\n\t\tvirtualDirCallback.close(Fp);\n\t} else {\n\t\tfclose(Fp);\n\t}\n\n\treturn ret_code;\n}",
        "func": "static int http_RecvPostMessage(\n\t/*! HTTP Parser object. */\n\thttp_parser_t *parser,\n\t/*! [in] Socket Information object. */\n\tSOCKINFO *info,\n\t/*! File where received data is copied to. */\n\tchar *filename,\n\t/*! Send Instruction object which gives information whether the file\n\t * is a virtual file or not. */\n\tstruct SendInstruction *Instr)\n{\n\tsize_t Data_Buf_Size = 1024;\n\tchar Buf[1024];\n\tint Timeout = -1;\n\tFILE *Fp;\n\tparse_status_t status = PARSE_OK;\n\tint ok_on_close = FALSE;\n\tsize_t entity_offset = 0;\n\tint num_read = 0;\n\tint ret_code = HTTP_OK;\n\n\tif (Instr && Instr->IsVirtualFile) {\n\t\tFp = (virtualDirCallback.open) (filename, UPNP_WRITE);\n\t\tif (Fp == NULL)\n\t\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n\t} else {\n#ifdef UPNP_ENABLE_POST_WRITE\n\t\tFp = fopen(filename, \"wb\");\n\t\tif (Fp == NULL)\n\t\t\treturn HTTP_UNAUTHORIZED;\n#else\n\t\treturn HTTP_NOT_FOUND;\n#endif\n\t}\n\tparser->position = POS_ENTITY;\n\tdo {\n\t\t/* first parse what has already been gotten */\n\t\tif (parser->position != POS_COMPLETE)\n\t\t\tstatus = parser_parse_entity(parser);\n\t\tif (status == PARSE_INCOMPLETE_ENTITY) {\n\t\t\t/* read until close */\n\t\t\tok_on_close = TRUE;\n\t\t} else if ((status != PARSE_SUCCESS)\n\t\t\t   && (status != PARSE_CONTINUE_1)\n\t\t\t   && (status != PARSE_INCOMPLETE)) {\n\t\t\t/* error */\n\t\t\tret_code = HTTP_BAD_REQUEST;\n\t\t\tgoto ExitFunction;\n\t\t}\n\t\t/* read more if necessary entity */\n\t\twhile (entity_offset + Data_Buf_Size > parser->msg.entity.length &&\n\t\t       parser->position != POS_COMPLETE) {\n\t\t\tnum_read = sock_read(info, Buf, sizeof(Buf), &Timeout);\n\t\t\tif (num_read > 0) {\n\t\t\t\t/* append data to buffer */\n\t\t\t\tif (membuffer_append(&parser->msg.msg,\n\t\t\t\t\tBuf, (size_t)num_read) != 0) {\n\t\t\t\t\t/* set failure status */\n\t\t\t\t\tparser->http_error_code =\n\t\t\t\t\t    HTTP_INTERNAL_SERVER_ERROR;\n\t\t\t\t\tret_code = HTTP_INTERNAL_SERVER_ERROR;\n\t\t\t\t\tgoto ExitFunction;\n\t\t\t\t}\n\t\t\t\tstatus = parser_parse_entity(parser);\n\t\t\t\tif (status == PARSE_INCOMPLETE_ENTITY) {\n\t\t\t\t\t/* read until close */\n\t\t\t\t\tok_on_close = TRUE;\n\t\t\t\t} else if ((status != PARSE_SUCCESS)\n\t\t\t\t\t   && (status != PARSE_CONTINUE_1)\n\t\t\t\t\t   && (status != PARSE_INCOMPLETE)) {\n\t\t\t\t\tret_code = HTTP_BAD_REQUEST;\n\t\t\t\t\tgoto ExitFunction;\n\t\t\t\t}\n\t\t\t} else if (num_read == 0) {\n\t\t\t\tif (ok_on_close) {\n\t\t\t\t\tUpnpPrintf(UPNP_INFO, HTTP, __FILE__, __LINE__,\n\t\t\t\t\t\t\"<<< (RECVD) <<<\\n%s\\n-----------------\\n\",\n\t\t\t\t\t\tparser->msg.msg.buf);\n\t\t\t\t\tprint_http_headers(&parser->msg);\n\t\t\t\t\tparser->position = POS_COMPLETE;\n\t\t\t\t} else {\n\t\t\t\t\t/* partial msg or response */\n\t\t\t\t\tparser->http_error_code = HTTP_BAD_REQUEST;\n\t\t\t\t\tret_code = HTTP_BAD_REQUEST;\n\t\t\t\t\tgoto ExitFunction;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tret_code = HTTP_SERVICE_UNAVAILABLE;\n\t\t\t\tgoto ExitFunction;\n\t\t\t}\n\t\t}\n\t\tif ((entity_offset + Data_Buf_Size) > parser->msg.entity.length) {\n\t\t\tData_Buf_Size =\n\t\t\t    parser->msg.entity.length - entity_offset;\n\t\t}\n\t\tmemcpy(Buf,\n\t\t       &parser->msg.msg.buf[parser->entity_start_position + entity_offset],\n\t\t       Data_Buf_Size);\n\t\tentity_offset += Data_Buf_Size;\n\t\tif (Instr && Instr->IsVirtualFile) {\n\t\t\tint n = virtualDirCallback.write(Fp, Buf, Data_Buf_Size);\n\t\t\tif (n < 0) {\n\t\t\t\tret_code = HTTP_INTERNAL_SERVER_ERROR;\n\t\t\t\tgoto ExitFunction;\n\t\t\t}\n\t\t} else {\n\t\t\tsize_t n = fwrite(Buf, 1, Data_Buf_Size, Fp);\n\t\t\tif (n != Data_Buf_Size) {\n\t\t\t\tret_code = HTTP_INTERNAL_SERVER_ERROR;\n\t\t\t\tgoto ExitFunction;\n\t\t\t}\n\t\t}\n\t} while (parser->position != POS_COMPLETE ||\n\t\t entity_offset != parser->msg.entity.length);\nExitFunction:\n\tif (Instr && Instr->IsVirtualFile) {\n\t\tvirtualDirCallback.close(Fp);\n\t} else {\n\t\tfclose(Fp);\n\t}\n\n\treturn ret_code;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -24,9 +24,13 @@\n \t\tif (Fp == NULL)\n \t\t\treturn HTTP_INTERNAL_SERVER_ERROR;\n \t} else {\n+#ifdef UPNP_ENABLE_POST_WRITE\n \t\tFp = fopen(filename, \"wb\");\n \t\tif (Fp == NULL)\n \t\t\treturn HTTP_UNAUTHORIZED;\n+#else\n+\t\treturn HTTP_NOT_FOUND;\n+#endif\n \t}\n \tparser->position = POS_ENTITY;\n \tdo {",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "#ifdef UPNP_ENABLE_POST_WRITE",
                "#else",
                "\t\treturn HTTP_NOT_FOUND;",
                "#endif"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-10130",
        "func_name": "libgit2/http_connect",
        "description": "The http_connect function in transports/http.c in libgit2 before 0.24.6 and 0.25.x before 0.25.1 might allow man-in-the-middle attackers to spoof servers by leveraging clobbering of the error variable.",
        "git_url": "https://github.com/libgit2/libgit2/commit/b5c6a1b407b7f8b952bded2789593b68b1876211",
        "commit_title": "http: check certificate validity before clobbering the error variable",
        "commit_text": "",
        "func_before": "static int http_connect(http_subtransport *t)\n{\n\tint error;\n\tchar *proxy_url;\n\n\tif (t->connected &&\n\t\thttp_should_keep_alive(&t->parser) &&\n\t\tt->parse_finished)\n\t\treturn 0;\n\n\tif (t->io) {\n\t\tgit_stream_close(t->io);\n\t\tgit_stream_free(t->io);\n\t\tt->io = NULL;\n\t\tt->connected = 0;\n\t}\n\n\tif (t->connection_data.use_ssl) {\n\t\terror = git_tls_stream_new(&t->io, t->connection_data.host, t->connection_data.port);\n\t} else {\n#ifdef GIT_CURL\n\t\terror = git_curl_stream_new(&t->io, t->connection_data.host, t->connection_data.port);\n#else\n\t\terror = git_socket_stream_new(&t->io,  t->connection_data.host, t->connection_data.port);\n#endif\n\t}\n\n\tif (error < 0)\n\t\treturn error;\n\n\tGITERR_CHECK_VERSION(t->io, GIT_STREAM_VERSION, \"git_stream\");\n\n\tif (git_stream_supports_proxy(t->io) &&\n\t    !git_remote__get_http_proxy(t->owner->owner, !!t->connection_data.use_ssl, &proxy_url)) {\n\t\terror = git_stream_set_proxy(t->io, proxy_url);\n\t\tgit__free(proxy_url);\n\n\t\tif (error < 0)\n\t\t\treturn error;\n\t}\n\n\terror = git_stream_connect(t->io);\n\n#if defined(GIT_OPENSSL) || defined(GIT_SECURE_TRANSPORT) || defined(GIT_CURL)\n\tif ((!error || error == GIT_ECERTIFICATE) && t->owner->certificate_check_cb != NULL &&\n\t    git_stream_is_encrypted(t->io)) {\n\t\tgit_cert *cert;\n\t\tint is_valid;\n\n\t\tif ((error = git_stream_certificate(&cert, t->io)) < 0)\n\t\t\treturn error;\n\n\t\tgiterr_clear();\n\t\tis_valid = error != GIT_ECERTIFICATE;\n\t\terror = t->owner->certificate_check_cb(cert, is_valid, t->connection_data.host, t->owner->message_cb_payload);\n\n\t\tif (error < 0) {\n\t\t\tif (!giterr_last())\n\t\t\t\tgiterr_set(GITERR_NET, \"user cancelled certificate check\");\n\n\t\t\treturn error;\n\t\t}\n\t}\n#endif\n\tif (error < 0)\n\t\treturn error;\n\n\tt->connected = 1;\n\treturn 0;\n}",
        "func": "static int http_connect(http_subtransport *t)\n{\n\tint error;\n\tchar *proxy_url;\n\n\tif (t->connected &&\n\t\thttp_should_keep_alive(&t->parser) &&\n\t\tt->parse_finished)\n\t\treturn 0;\n\n\tif (t->io) {\n\t\tgit_stream_close(t->io);\n\t\tgit_stream_free(t->io);\n\t\tt->io = NULL;\n\t\tt->connected = 0;\n\t}\n\n\tif (t->connection_data.use_ssl) {\n\t\terror = git_tls_stream_new(&t->io, t->connection_data.host, t->connection_data.port);\n\t} else {\n#ifdef GIT_CURL\n\t\terror = git_curl_stream_new(&t->io, t->connection_data.host, t->connection_data.port);\n#else\n\t\terror = git_socket_stream_new(&t->io,  t->connection_data.host, t->connection_data.port);\n#endif\n\t}\n\n\tif (error < 0)\n\t\treturn error;\n\n\tGITERR_CHECK_VERSION(t->io, GIT_STREAM_VERSION, \"git_stream\");\n\n\tif (git_stream_supports_proxy(t->io) &&\n\t    !git_remote__get_http_proxy(t->owner->owner, !!t->connection_data.use_ssl, &proxy_url)) {\n\t\terror = git_stream_set_proxy(t->io, proxy_url);\n\t\tgit__free(proxy_url);\n\n\t\tif (error < 0)\n\t\t\treturn error;\n\t}\n\n\terror = git_stream_connect(t->io);\n\n#if defined(GIT_OPENSSL) || defined(GIT_SECURE_TRANSPORT) || defined(GIT_CURL)\n\tif ((!error || error == GIT_ECERTIFICATE) && t->owner->certificate_check_cb != NULL &&\n\t    git_stream_is_encrypted(t->io)) {\n\t\tgit_cert *cert;\n\t\tint is_valid = (error == GIT_OK);\n\n\t\tif ((error = git_stream_certificate(&cert, t->io)) < 0)\n\t\t\treturn error;\n\n\t\tgiterr_clear();\n\t\terror = t->owner->certificate_check_cb(cert, is_valid, t->connection_data.host, t->owner->message_cb_payload);\n\n\t\tif (error < 0) {\n\t\t\tif (!giterr_last())\n\t\t\t\tgiterr_set(GITERR_NET, \"user cancelled certificate check\");\n\n\t\t\treturn error;\n\t\t}\n\t}\n#endif\n\tif (error < 0)\n\t\treturn error;\n\n\tt->connected = 1;\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -45,13 +45,12 @@\n \tif ((!error || error == GIT_ECERTIFICATE) && t->owner->certificate_check_cb != NULL &&\n \t    git_stream_is_encrypted(t->io)) {\n \t\tgit_cert *cert;\n-\t\tint is_valid;\n+\t\tint is_valid = (error == GIT_OK);\n \n \t\tif ((error = git_stream_certificate(&cert, t->io)) < 0)\n \t\t\treturn error;\n \n \t\tgiterr_clear();\n-\t\tis_valid = error != GIT_ECERTIFICATE;\n \t\terror = t->owner->certificate_check_cb(cert, is_valid, t->connection_data.host, t->owner->message_cb_payload);\n \n \t\tif (error < 0) {",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tint is_valid;",
                "\t\tis_valid = error != GIT_ECERTIFICATE;"
            ],
            "added_lines": [
                "\t\tint is_valid = (error == GIT_OK);"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-10144",
        "func_name": "ImageMagick/WriteIPLImage",
        "description": "coders/ipl.c in ImageMagick allows remote attackers to have unspecific impact by leveraging a missing malloc check.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/97566cf2806c0a5a86e884c96831a0c3b1ec6c20",
        "commit_title": "...",
        "commit_text": "",
        "func_before": "static MagickBooleanType WriteIPLImage(const ImageInfo *image_info,Image *image)\n{\n  ExceptionInfo\n    *exception;\n\n  IPLInfo\n    ipl_info;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    scene;\n\n  register const PixelPacket\n    *p;\n\n  QuantumInfo\n    *quantum_info;\n\n  ssize_t\n    y;\n\n  unsigned char\n    *pixels;\n\n   /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,&image->exception);\n  if (status == MagickFalse)\n    return(status);\n  scene=0;\n\n  quantum_info=AcquireQuantumInfo(image_info, image);\n  if ((quantum_info->format == UndefinedQuantumFormat) &&\n      (IsHighDynamicRangeImage(image,&image->exception) != MagickFalse))\n    SetQuantumFormat(image,quantum_info,FloatingPointQuantumFormat);\n  switch(quantum_info->depth){\n  case 8:\n    ipl_info.byteType = 0;\n    break;\n  case 16:\n    if(quantum_info->format == SignedQuantumFormat){\n      ipl_info.byteType = 2;\n    }\n    else{\n      ipl_info.byteType = 1;\n    }\n    break;\n  case 32:\n    if(quantum_info->format == FloatingPointQuantumFormat){\n      ipl_info.byteType = 3;\n    }\n    else{\n      ipl_info.byteType = 4;\n    }\n    break;\n  case 64:\n    ipl_info.byteType = 10;\n    break;\n  default:\n    ipl_info.byteType = 2;\n    break;\n\n  }\n  ipl_info.z = (unsigned int) GetImageListLength(image);\n  /* There is no current method for detecting whether we have T or Z stacks */\n  ipl_info.time = 1;\n  ipl_info.width = (unsigned int) image->columns;\n  ipl_info.height = (unsigned int) image->rows;\n  (void) TransformImageColorspace(image,sRGBColorspace);\n  if(IssRGBCompatibleColorspace(image->colorspace) != MagickFalse) { ipl_info.colors = 3; }\n  else{ ipl_info.colors = 1; }\n\n  ipl_info.size = (unsigned int) (28 +\n    ((image->depth)/8)*ipl_info.height*ipl_info.width*ipl_info.colors*ipl_info.z);\n\n  /* Ok!  Calculations are done.  Lets write this puppy down! */\n\n  /*\n    Write IPL header.\n  */\n  /* Shockingly (maybe not if you have used IPLab),  IPLab itself CANNOT read MSBEndian\n  files!   The reader above can, but they cannot.  For compatability reasons, I will leave\n  the code in here, but it is all but useless if you want to use IPLab. */\n\n  if(image_info->endian == MSBEndian)\n    (void) WriteBlob(image, 4, (const unsigned char *) \"mmmm\");\n  else{\n    image->endian = LSBEndian;\n    (void) WriteBlob(image, 4, (const unsigned char *) \"iiii\");\n  }\n  (void) WriteBlobLong(image, 4);\n  (void) WriteBlob(image, 4, (const unsigned char *) \"100f\");\n  (void) WriteBlob(image, 4, (const unsigned char *) \"data\");\n  (void) WriteBlobLong(image, ipl_info.size);\n  (void) WriteBlobLong(image, ipl_info.width);\n  (void) WriteBlobLong(image, ipl_info.height);\n  (void) WriteBlobLong(image, ipl_info.colors);\n  if(image_info->adjoin == MagickFalse)\n  (void) WriteBlobLong(image, 1);\n  else\n  (void) WriteBlobLong(image, ipl_info.z);\n  (void) WriteBlobLong(image, ipl_info.time);\n  (void) WriteBlobLong(image, ipl_info.byteType);\n\n  exception=(&image->exception);\n  do\n    {\n      /*\n  Convert MIFF to IPL raster pixels.\n      */\n      pixels=GetQuantumPixels(quantum_info);\n  if(ipl_info.colors == 1){\n  /* Red frame */\n  for(y = 0; y < (ssize_t) ipl_info.height; y++){\n    p=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n    if (p == (PixelPacket *) NULL)\n      break;\n    (void) ExportQuantumPixels(image,(const CacheView *) NULL, quantum_info,\n      GrayQuantum, pixels,&image->exception);\n    (void) WriteBlob(image, image->columns*image->depth/8, pixels);\n  }\n\n}\n  if(ipl_info.colors == 3){\n  /* Red frame */\n  for(y = 0; y < (ssize_t) ipl_info.height; y++){\n    p=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n    if (p == (PixelPacket *) NULL)\n      break;\n    (void) ExportQuantumPixels(image,(const CacheView *) NULL, quantum_info,\n      RedQuantum, pixels,&image->exception);\n    (void) WriteBlob(image, image->columns*image->depth/8, pixels);\n  }\n\n    /* Green frame */\n    for(y = 0; y < (ssize_t) ipl_info.height; y++){\n      p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);\n      if (p == (PixelPacket *) NULL)\n        break;\n      (void) ExportQuantumPixels(image,(const CacheView *) NULL, quantum_info,\n        GreenQuantum, pixels,&image->exception);\n      (void) WriteBlob(image, image->columns*image->depth/8, pixels);\n    }\n    /* Blue frame */\n    for(y = 0; y < (ssize_t) ipl_info.height; y++){\n      p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);\n      if (p == (PixelPacket *) NULL)\n        break;\n      (void) ExportQuantumPixels(image,(const CacheView *) NULL, quantum_info,\n        BlueQuantum, pixels,&image->exception);\n      (void) WriteBlob(image, image->columns*image->depth/8, pixels);\n      if (image->previous == (Image *) NULL)\n        {\n          status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n          if (status == MagickFalse)\n            break;\n        }\n    }\n  }\n  quantum_info=DestroyQuantumInfo(quantum_info);\n  if (GetNextImageInList(image) == (Image *) NULL)\n    break;\n      image=SyncNextImageInList(image);\n      status=SetImageProgress(image,SaveImagesTag,scene++,\n        GetImageListLength(image));\n      if (status == MagickFalse)\n        break;\n    }while (image_info->adjoin != MagickFalse);\n\n  (void) WriteBlob(image, 4, (const unsigned char *) \"fini\");\n  (void) WriteBlobLong(image, 0);\n\nCloseBlob(image);\nreturn(MagickTrue);\n}",
        "func": "static MagickBooleanType WriteIPLImage(const ImageInfo *image_info,Image *image)\n{\n  ExceptionInfo\n    *exception;\n\n  IPLInfo\n    ipl_info;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    scene;\n\n  register const PixelPacket\n    *p;\n\n  QuantumInfo\n    *quantum_info;\n\n  ssize_t\n    y;\n\n  unsigned char\n    *pixels;\n\n   /*\n    Open output image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,&image->exception);\n  if (status == MagickFalse)\n    return(status);\n  scene=0;\n\n  quantum_info=AcquireQuantumInfo(image_info, image);\n  if (quantum_info == (QuantumInfo *) NULL)\n    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n  if ((quantum_info->format == UndefinedQuantumFormat) &&\n      (IsHighDynamicRangeImage(image,&image->exception) != MagickFalse))\n    SetQuantumFormat(image,quantum_info,FloatingPointQuantumFormat);\n  switch(quantum_info->depth){\n  case 8:\n    ipl_info.byteType = 0;\n    break;\n  case 16:\n    if(quantum_info->format == SignedQuantumFormat){\n      ipl_info.byteType = 2;\n    }\n    else{\n      ipl_info.byteType = 1;\n    }\n    break;\n  case 32:\n    if(quantum_info->format == FloatingPointQuantumFormat){\n      ipl_info.byteType = 3;\n    }\n    else{\n      ipl_info.byteType = 4;\n    }\n    break;\n  case 64:\n    ipl_info.byteType = 10;\n    break;\n  default:\n    ipl_info.byteType = 2;\n    break;\n\n  }\n  ipl_info.z = (unsigned int) GetImageListLength(image);\n  /* There is no current method for detecting whether we have T or Z stacks */\n  ipl_info.time = 1;\n  ipl_info.width = (unsigned int) image->columns;\n  ipl_info.height = (unsigned int) image->rows;\n  (void) TransformImageColorspace(image,sRGBColorspace);\n  if(IssRGBCompatibleColorspace(image->colorspace) != MagickFalse) { ipl_info.colors = 3; }\n  else{ ipl_info.colors = 1; }\n\n  ipl_info.size = (unsigned int) (28 +\n    ((image->depth)/8)*ipl_info.height*ipl_info.width*ipl_info.colors*ipl_info.z);\n\n  /* Ok!  Calculations are done.  Lets write this puppy down! */\n\n  /*\n    Write IPL header.\n  */\n  /* Shockingly (maybe not if you have used IPLab),  IPLab itself CANNOT read MSBEndian\n  files!   The reader above can, but they cannot.  For compatability reasons, I will leave\n  the code in here, but it is all but useless if you want to use IPLab. */\n\n  if(image_info->endian == MSBEndian)\n    (void) WriteBlob(image, 4, (const unsigned char *) \"mmmm\");\n  else{\n    image->endian = LSBEndian;\n    (void) WriteBlob(image, 4, (const unsigned char *) \"iiii\");\n  }\n  (void) WriteBlobLong(image, 4);\n  (void) WriteBlob(image, 4, (const unsigned char *) \"100f\");\n  (void) WriteBlob(image, 4, (const unsigned char *) \"data\");\n  (void) WriteBlobLong(image, ipl_info.size);\n  (void) WriteBlobLong(image, ipl_info.width);\n  (void) WriteBlobLong(image, ipl_info.height);\n  (void) WriteBlobLong(image, ipl_info.colors);\n  if(image_info->adjoin == MagickFalse)\n  (void) WriteBlobLong(image, 1);\n  else\n  (void) WriteBlobLong(image, ipl_info.z);\n  (void) WriteBlobLong(image, ipl_info.time);\n  (void) WriteBlobLong(image, ipl_info.byteType);\n\n  exception=(&image->exception);\n  do\n    {\n      /*\n  Convert MIFF to IPL raster pixels.\n      */\n      pixels=GetQuantumPixels(quantum_info);\n  if(ipl_info.colors == 1){\n  /* Red frame */\n  for(y = 0; y < (ssize_t) ipl_info.height; y++){\n    p=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n    if (p == (PixelPacket *) NULL)\n      break;\n    (void) ExportQuantumPixels(image,(const CacheView *) NULL, quantum_info,\n      GrayQuantum, pixels,&image->exception);\n    (void) WriteBlob(image, image->columns*image->depth/8, pixels);\n  }\n\n}\n  if(ipl_info.colors == 3){\n  /* Red frame */\n  for(y = 0; y < (ssize_t) ipl_info.height; y++){\n    p=GetAuthenticPixels(image,0,y,image->columns,1,exception);\n    if (p == (PixelPacket *) NULL)\n      break;\n    (void) ExportQuantumPixels(image,(const CacheView *) NULL, quantum_info,\n      RedQuantum, pixels,&image->exception);\n    (void) WriteBlob(image, image->columns*image->depth/8, pixels);\n  }\n\n    /* Green frame */\n    for(y = 0; y < (ssize_t) ipl_info.height; y++){\n      p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);\n      if (p == (PixelPacket *) NULL)\n        break;\n      (void) ExportQuantumPixels(image,(const CacheView *) NULL, quantum_info,\n        GreenQuantum, pixels,&image->exception);\n      (void) WriteBlob(image, image->columns*image->depth/8, pixels);\n    }\n    /* Blue frame */\n    for(y = 0; y < (ssize_t) ipl_info.height; y++){\n      p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);\n      if (p == (PixelPacket *) NULL)\n        break;\n      (void) ExportQuantumPixels(image,(const CacheView *) NULL, quantum_info,\n        BlueQuantum, pixels,&image->exception);\n      (void) WriteBlob(image, image->columns*image->depth/8, pixels);\n      if (image->previous == (Image *) NULL)\n        {\n          status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n          if (status == MagickFalse)\n            break;\n        }\n    }\n  }\n  quantum_info=DestroyQuantumInfo(quantum_info);\n  if (GetNextImageInList(image) == (Image *) NULL)\n    break;\n      image=SyncNextImageInList(image);\n      status=SetImageProgress(image,SaveImagesTag,scene++,\n        GetImageListLength(image));\n      if (status == MagickFalse)\n        break;\n    }while (image_info->adjoin != MagickFalse);\n\n  (void) WriteBlob(image, 4, (const unsigned char *) \"fini\");\n  (void) WriteBlobLong(image, 0);\n\nCloseBlob(image);\nreturn(MagickTrue);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -39,6 +39,8 @@\n   scene=0;\n \n   quantum_info=AcquireQuantumInfo(image_info, image);\n+  if (quantum_info == (QuantumInfo *) NULL)\n+    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n   if ((quantum_info->format == UndefinedQuantumFormat) &&\n       (IsHighDynamicRangeImage(image,&image->exception) != MagickFalse))\n     SetQuantumFormat(image,quantum_info,FloatingPointQuantumFormat);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "  if (quantum_info == (QuantumInfo *) NULL)",
                "    ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-13405",
        "func_name": "kernel/git/tip/tip/inode_init_owner",
        "description": "The inode_init_owner function in fs/inode.c in the Linux kernel through 3.16 allows local users to create files with an unintended group ownership, in a scenario where a directory is SGID to a certain group and is writable by a user who is not a member of that group. Here, the non-member can trigger creation of a plain file whose group ownership is that group. The intended behavior was that the non-member can trigger creation of a directory (but not a plain file) whose group ownership is that group. The non-member can escalate privileges by making the plain file executable and SGID.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/tip/tip.git/commit/?h=0b3369840cd61c23e2b9241093737b4c395cb406",
        "commit_title": "commit 0fa3ecd87848c9c93c2c828ef4c3a8ca36ce46c7 upstream.",
        "commit_text": " sgid directories have special semantics, making newly created files in the directory belong to the group of the directory, and newly created subdirectories will also become sgid.  This is historically used for group-shared directories.  But group directories writable by non-group members should not imply that such non-group members can magically join the group, so make sure to clear the sgid bit on non-directories for non-members (but remember that sgid without group execute means \"mandatory locking\", just to confuse things even more).  Cc: Andy Lutomirski <luto@kernel.org> Cc: Al Viro <viro@zeniv.linux.org.uk> ",
        "func_before": "void inode_init_owner(struct inode *inode, const struct inode *dir,\n\t\t\tumode_t mode)\n{\n\tinode->i_uid = current_fsuid();\n\tif (dir && dir->i_mode & S_ISGID) {\n\t\tinode->i_gid = dir->i_gid;\n\t\tif (S_ISDIR(mode))\n\t\t\tmode |= S_ISGID;\n\t} else\n\t\tinode->i_gid = current_fsgid();\n\tinode->i_mode = mode;\n}",
        "func": "void inode_init_owner(struct inode *inode, const struct inode *dir,\n\t\t\tumode_t mode)\n{\n\tinode->i_uid = current_fsuid();\n\tif (dir && dir->i_mode & S_ISGID) {\n\t\tinode->i_gid = dir->i_gid;\n\n\t\t/* Directories are special, and always inherit S_ISGID */\n\t\tif (S_ISDIR(mode))\n\t\t\tmode |= S_ISGID;\n\t\telse if ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP) &&\n\t\t\t !in_group_p(inode->i_gid) &&\n\t\t\t !capable_wrt_inode_uidgid(dir, CAP_FSETID))\n\t\t\tmode &= ~S_ISGID;\n\t} else\n\t\tinode->i_gid = current_fsgid();\n\tinode->i_mode = mode;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,8 +4,14 @@\n \tinode->i_uid = current_fsuid();\n \tif (dir && dir->i_mode & S_ISGID) {\n \t\tinode->i_gid = dir->i_gid;\n+\n+\t\t/* Directories are special, and always inherit S_ISGID */\n \t\tif (S_ISDIR(mode))\n \t\t\tmode |= S_ISGID;\n+\t\telse if ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP) &&\n+\t\t\t !in_group_p(inode->i_gid) &&\n+\t\t\t !capable_wrt_inode_uidgid(dir, CAP_FSETID))\n+\t\t\tmode &= ~S_ISGID;\n \t} else\n \t\tinode->i_gid = current_fsgid();\n \tinode->i_mode = mode;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "\t\t/* Directories are special, and always inherit S_ISGID */",
                "\t\telse if ((mode & (S_ISGID | S_IXGRP)) == (S_ISGID | S_IXGRP) &&",
                "\t\t\t !in_group_p(inode->i_gid) &&",
                "\t\t\t !capable_wrt_inode_uidgid(dir, CAP_FSETID))",
                "\t\t\tmode &= ~S_ISGID;"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-9815",
        "func_name": "xen-project/xen/do_trap_data_abort",
        "description": "Xen through 4.7.x allows local ARM guest OS users to cause a denial of service (host panic) by sending an asynchronous abort.",
        "git_url": "https://github.com/xen-project/xen/commit/6aaff7b407ca76dcfc4fe81f2afe9d1594cb0d6b",
        "commit_title": "arm32: handle async aborts delivered while at HYP",
        "commit_text": " If guest generates an asynchronous abort and then traps into HYP (by HVC or IRQ) before the abort has been delivered, the hypervisor could not catch it, because the PSTATE.A bit is masked all the time in hypervisor. So this asynchronous abort may be slipped to next running guest with PSTATE.A bit unmasked.  In order to avoid this, it is necessary to take the abort at HYP, by clearing the PSTATE.A bit. In this patch, we unmask the PSTATE.A bit to open a window to catch guest-generated asynchronous abort in all Guest -> HYP switch paths. If we caught such asynchronous abort in checking window, the HYP data abort exception will be triggered and the abort source guest will be crashed.  This is part of XSA-201. ",
        "func_before": "asmlinkage void do_trap_data_abort(struct cpu_user_regs *regs)\n{\n    do_unexpected_trap(\"Data Abort\", regs);\n}",
        "func": "asmlinkage void do_trap_data_abort(struct cpu_user_regs *regs)\n{\n    if ( VABORT_GEN_BY_GUEST(regs) )\n        do_trap_guest_error(regs);\n    else\n        do_unexpected_trap(\"Data Abort\", regs);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,7 @@\n asmlinkage void do_trap_data_abort(struct cpu_user_regs *regs)\n {\n-    do_unexpected_trap(\"Data Abort\", regs);\n+    if ( VABORT_GEN_BY_GUEST(regs) )\n+        do_trap_guest_error(regs);\n+    else\n+        do_unexpected_trap(\"Data Abort\", regs);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    do_unexpected_trap(\"Data Abort\", regs);"
            ],
            "added_lines": [
                "    if ( VABORT_GEN_BY_GUEST(regs) )",
                "        do_trap_guest_error(regs);",
                "    else",
                "        do_unexpected_trap(\"Data Abort\", regs);"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-9815",
        "func_name": "xen-project/xen/do_trap_data_abort_guest",
        "description": "Xen through 4.7.x allows local ARM guest OS users to cause a denial of service (host panic) by sending an asynchronous abort.",
        "git_url": "https://github.com/xen-project/xen/commit/f8c6a9334b251d2e78b0873a71b4d369908fb123",
        "commit_title": "arm: crash the guest when it traps on external abort",
        "commit_text": " If we spot a data or prefetch abort bearing the ESR_EL2.EA bit set, we know that this is an external abort, and that should crash the guest.  This is part of XSA-201. ",
        "func_before": "static void do_trap_data_abort_guest(struct cpu_user_regs *regs,\n                                     const union hsr hsr)\n{\n    const struct hsr_dabt dabt = hsr.dabt;\n    int rc;\n    mmio_info_t info;\n    uint8_t fsc = hsr.dabt.dfsc & ~FSC_LL_MASK;\n    mfn_t mfn;\n\n    info.dabt = dabt;\n#ifdef CONFIG_ARM_32\n    info.gva = READ_CP32(HDFAR);\n#else\n    info.gva = READ_SYSREG64(FAR_EL2);\n#endif\n\n    if ( hpfar_is_valid(dabt.s1ptw, fsc) )\n        info.gpa = get_faulting_ipa(info.gva);\n    else\n    {\n        rc = gva_to_ipa(info.gva, &info.gpa, GV2M_READ);\n        /*\n         * We may not be able to translate because someone is\n         * playing with the Stage-2 page table of the domain.\n         * Return to the guest.\n         */\n        if ( rc == -EFAULT )\n            return; /* Try again */\n    }\n\n    switch ( fsc )\n    {\n    case FSC_FLT_PERM:\n    {\n        const struct npfec npfec = {\n            .read_access = !dabt.write,\n            .write_access = dabt.write,\n            .gla_valid = 1,\n            .kind = dabt.s1ptw ? npfec_kind_in_gpt : npfec_kind_with_gla\n        };\n\n        p2m_mem_access_check(info.gpa, info.gva, npfec);\n        /*\n         * The only way to get here right now is because of mem_access,\n         * thus reinjecting the exception to the guest is never required.\n         */\n        return;\n    }\n    case FSC_FLT_TRANS:\n        /*\n         * Attempt first to emulate the MMIO as the data abort will\n         * likely happen in an emulated region.\n         */\n        if ( try_handle_mmio(regs, &info) )\n        {\n            advance_pc(regs, hsr);\n            return;\n        }\n\n        /*\n         * The PT walk may have failed because someone was playing\n         * with the Stage-2 page table. Walk the Stage-2 PT to check\n         * if the entry exists. If it's the case, return to the guest\n         */\n        mfn = p2m_lookup(current->domain, _gfn(paddr_to_pfn(info.gpa)), NULL);\n        if ( !mfn_eq(mfn, INVALID_MFN) )\n            return;\n\n        break;\n    default:\n        gprintk(XENLOG_WARNING, \"Unsupported DFSC: HSR=%#x DFSC=%#x\\n\",\n                hsr.bits, dabt.dfsc);\n    }\n\n    gdprintk(XENLOG_DEBUG, \"HSR=0x%x pc=%#\"PRIregister\" gva=%#\"PRIvaddr\n             \" gpa=%#\"PRIpaddr\"\\n\", hsr.bits, regs->pc, info.gva, info.gpa);\n    inject_dabt_exception(regs, info.gva, hsr.len);\n}",
        "func": "static void do_trap_data_abort_guest(struct cpu_user_regs *regs,\n                                     const union hsr hsr)\n{\n    const struct hsr_dabt dabt = hsr.dabt;\n    int rc;\n    mmio_info_t info;\n    uint8_t fsc = hsr.dabt.dfsc & ~FSC_LL_MASK;\n    mfn_t mfn;\n\n    /*\n     * If this bit has been set, it means that this data abort is caused\n     * by a guest external abort. Currently we crash the guest to protect the\n     * hypervisor. In future one can better handle this by injecting a virtual\n     * abort to the guest.\n     */\n    if ( dabt.eat )\n        domain_crash_synchronous();\n\n    info.dabt = dabt;\n#ifdef CONFIG_ARM_32\n    info.gva = READ_CP32(HDFAR);\n#else\n    info.gva = READ_SYSREG64(FAR_EL2);\n#endif\n\n    if ( hpfar_is_valid(dabt.s1ptw, fsc) )\n        info.gpa = get_faulting_ipa(info.gva);\n    else\n    {\n        rc = gva_to_ipa(info.gva, &info.gpa, GV2M_READ);\n        /*\n         * We may not be able to translate because someone is\n         * playing with the Stage-2 page table of the domain.\n         * Return to the guest.\n         */\n        if ( rc == -EFAULT )\n            return; /* Try again */\n    }\n\n    switch ( fsc )\n    {\n    case FSC_FLT_PERM:\n    {\n        const struct npfec npfec = {\n            .read_access = !dabt.write,\n            .write_access = dabt.write,\n            .gla_valid = 1,\n            .kind = dabt.s1ptw ? npfec_kind_in_gpt : npfec_kind_with_gla\n        };\n\n        p2m_mem_access_check(info.gpa, info.gva, npfec);\n        /*\n         * The only way to get here right now is because of mem_access,\n         * thus reinjecting the exception to the guest is never required.\n         */\n        return;\n    }\n    case FSC_FLT_TRANS:\n        /*\n         * Attempt first to emulate the MMIO as the data abort will\n         * likely happen in an emulated region.\n         */\n        if ( try_handle_mmio(regs, &info) )\n        {\n            advance_pc(regs, hsr);\n            return;\n        }\n\n        /*\n         * The PT walk may have failed because someone was playing\n         * with the Stage-2 page table. Walk the Stage-2 PT to check\n         * if the entry exists. If it's the case, return to the guest\n         */\n        mfn = p2m_lookup(current->domain, _gfn(paddr_to_pfn(info.gpa)), NULL);\n        if ( !mfn_eq(mfn, INVALID_MFN) )\n            return;\n\n        break;\n    default:\n        gprintk(XENLOG_WARNING, \"Unsupported DFSC: HSR=%#x DFSC=%#x\\n\",\n                hsr.bits, dabt.dfsc);\n    }\n\n    gdprintk(XENLOG_DEBUG, \"HSR=0x%x pc=%#\"PRIregister\" gva=%#\"PRIvaddr\n             \" gpa=%#\"PRIpaddr\"\\n\", hsr.bits, regs->pc, info.gva, info.gpa);\n    inject_dabt_exception(regs, info.gva, hsr.len);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,6 +6,15 @@\n     mmio_info_t info;\n     uint8_t fsc = hsr.dabt.dfsc & ~FSC_LL_MASK;\n     mfn_t mfn;\n+\n+    /*\n+     * If this bit has been set, it means that this data abort is caused\n+     * by a guest external abort. Currently we crash the guest to protect the\n+     * hypervisor. In future one can better handle this by injecting a virtual\n+     * abort to the guest.\n+     */\n+    if ( dabt.eat )\n+        domain_crash_synchronous();\n \n     info.dabt = dabt;\n #ifdef CONFIG_ARM_32",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "    /*",
                "     * If this bit has been set, it means that this data abort is caused",
                "     * by a guest external abort. Currently we crash the guest to protect the",
                "     * hypervisor. In future one can better handle this by injecting a virtual",
                "     * abort to the guest.",
                "     */",
                "    if ( dabt.eat )",
                "        domain_crash_synchronous();"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-9815",
        "func_name": "xen-project/xen/do_trap_instr_abort_guest",
        "description": "Xen through 4.7.x allows local ARM guest OS users to cause a denial of service (host panic) by sending an asynchronous abort.",
        "git_url": "https://github.com/xen-project/xen/commit/f8c6a9334b251d2e78b0873a71b4d369908fb123",
        "commit_title": "arm: crash the guest when it traps on external abort",
        "commit_text": " If we spot a data or prefetch abort bearing the ESR_EL2.EA bit set, we know that this is an external abort, and that should crash the guest.  This is part of XSA-201. ",
        "func_before": "static void do_trap_instr_abort_guest(struct cpu_user_regs *regs,\n                                      const union hsr hsr)\n{\n    int rc;\n    register_t gva = READ_SYSREG(FAR_EL2);\n    uint8_t fsc = hsr.iabt.ifsc & ~FSC_LL_MASK;\n    paddr_t gpa;\n    mfn_t mfn;\n\n    if ( hpfar_is_valid(hsr.iabt.s1ptw, fsc) )\n        gpa = get_faulting_ipa(gva);\n    else\n    {\n        /*\n         * Flush the TLB to make sure the DTLB is clear before\n         * doing GVA->IPA translation. If we got here because of\n         * an entry only present in the ITLB, this translation may\n         * still be inaccurate.\n         */\n        flush_tlb_local();\n\n        /*\n         * We may not be able to translate because someone is\n         * playing with the Stage-2 page table of the domain.\n         * Return to the guest.\n         */\n        rc = gva_to_ipa(gva, &gpa, GV2M_READ);\n        if ( rc == -EFAULT )\n            return; /* Try again */\n    }\n\n    switch ( fsc )\n    {\n    case FSC_FLT_PERM:\n    {\n        const struct npfec npfec = {\n            .insn_fetch = 1,\n            .gla_valid = 1,\n            .kind = hsr.iabt.s1ptw ? npfec_kind_in_gpt : npfec_kind_with_gla\n        };\n\n        p2m_mem_access_check(gpa, gva, npfec);\n        /*\n         * The only way to get here right now is because of mem_access,\n         * thus reinjecting the exception to the guest is never required.\n         */\n        return;\n    }\n    case FSC_FLT_TRANS:\n        /*\n         * The PT walk may have failed because someone was playing\n         * with the Stage-2 page table. Walk the Stage-2 PT to check\n         * if the entry exists. If it's the case, return to the guest\n         */\n        mfn = p2m_lookup(current->domain, _gfn(paddr_to_pfn(gpa)), NULL);\n        if ( !mfn_eq(mfn, INVALID_MFN) )\n            return;\n    }\n\n    inject_iabt_exception(regs, gva, hsr.len);\n}",
        "func": "static void do_trap_instr_abort_guest(struct cpu_user_regs *regs,\n                                      const union hsr hsr)\n{\n    int rc;\n    register_t gva = READ_SYSREG(FAR_EL2);\n    uint8_t fsc = hsr.iabt.ifsc & ~FSC_LL_MASK;\n    paddr_t gpa;\n    mfn_t mfn;\n\n    /*\n     * If this bit has been set, it means that this instruction abort is caused\n     * by a guest external abort. Currently we crash the guest to protect the\n     * hypervisor. In future one can better handle this by injecting a virtual\n     * abort to the guest.\n     */\n    if ( hsr.iabt.eat )\n        domain_crash_synchronous();\n\n    if ( hpfar_is_valid(hsr.iabt.s1ptw, fsc) )\n        gpa = get_faulting_ipa(gva);\n    else\n    {\n        /*\n         * Flush the TLB to make sure the DTLB is clear before\n         * doing GVA->IPA translation. If we got here because of\n         * an entry only present in the ITLB, this translation may\n         * still be inaccurate.\n         */\n        flush_tlb_local();\n\n        /*\n         * We may not be able to translate because someone is\n         * playing with the Stage-2 page table of the domain.\n         * Return to the guest.\n         */\n        rc = gva_to_ipa(gva, &gpa, GV2M_READ);\n        if ( rc == -EFAULT )\n            return; /* Try again */\n    }\n\n    switch ( fsc )\n    {\n    case FSC_FLT_PERM:\n    {\n        const struct npfec npfec = {\n            .insn_fetch = 1,\n            .gla_valid = 1,\n            .kind = hsr.iabt.s1ptw ? npfec_kind_in_gpt : npfec_kind_with_gla\n        };\n\n        p2m_mem_access_check(gpa, gva, npfec);\n        /*\n         * The only way to get here right now is because of mem_access,\n         * thus reinjecting the exception to the guest is never required.\n         */\n        return;\n    }\n    case FSC_FLT_TRANS:\n        /*\n         * The PT walk may have failed because someone was playing\n         * with the Stage-2 page table. Walk the Stage-2 PT to check\n         * if the entry exists. If it's the case, return to the guest\n         */\n        mfn = p2m_lookup(current->domain, _gfn(paddr_to_pfn(gpa)), NULL);\n        if ( !mfn_eq(mfn, INVALID_MFN) )\n            return;\n    }\n\n    inject_iabt_exception(regs, gva, hsr.len);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,6 +6,15 @@\n     uint8_t fsc = hsr.iabt.ifsc & ~FSC_LL_MASK;\n     paddr_t gpa;\n     mfn_t mfn;\n+\n+    /*\n+     * If this bit has been set, it means that this instruction abort is caused\n+     * by a guest external abort. Currently we crash the guest to protect the\n+     * hypervisor. In future one can better handle this by injecting a virtual\n+     * abort to the guest.\n+     */\n+    if ( hsr.iabt.eat )\n+        domain_crash_synchronous();\n \n     if ( hpfar_is_valid(hsr.iabt.s1ptw, fsc) )\n         gpa = get_faulting_ipa(gva);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "    /*",
                "     * If this bit has been set, it means that this instruction abort is caused",
                "     * by a guest external abort. Currently we crash the guest to protect the",
                "     * hypervisor. In future one can better handle this by injecting a virtual",
                "     * abort to the guest.",
                "     */",
                "    if ( hsr.iabt.eat )",
                "        domain_crash_synchronous();"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-10065",
        "func_name": "ImageMagick/ImportGrayQuantum",
        "description": "The ReadVIFFImage function in coders/viff.c in ImageMagick before 7.0.1-0 allows remote attackers to cause a denial of service (application crash) or have other unspecified impact via a crafted file.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/134463b926fa965571aa4febd61b810be5e7da05",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/129",
        "commit_text": "",
        "func_before": "static void ImportGrayQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const unsigned char *magick_restrict p,\n  Quantum *magick_restrict q,ExceptionInfo *exception)\n{\n  QuantumAny\n    range;\n\n  register ssize_t\n    x;\n\n  ssize_t\n    bit;\n\n  unsigned int\n    pixel;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  switch (quantum_info->depth)\n  {\n    case 1:\n    {\n      register Quantum\n        black,\n        white;\n\n      black=0;\n      white=QuantumRange;\n      if (quantum_info->min_is_white != MagickFalse)\n        {\n          black=QuantumRange;\n          white=0;\n        }\n      for (x=0; x < ((ssize_t) number_pixels-7); x+=8)\n      {\n        for (bit=0; bit < 8; bit++)\n        {\n          SetPixelGray(image,((*p) & (1 << (7-bit))) == 0 ? black : white,q);\n          q+=GetPixelChannels(image);\n        }\n        p++;\n      }\n      for (bit=0; bit < (ssize_t) (number_pixels % 8); bit++)\n      {\n        SetPixelGray(image,((*p) & (0x01 << (7-bit))) == 0 ? black : white,q);\n        q+=GetPixelChannels(image);\n      }\n      if (bit != 0)\n        p++;\n      break;\n    }\n    case 4:\n    {\n      register unsigned char\n        pixel;\n\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < ((ssize_t) number_pixels-1); x+=2)\n      {\n        pixel=(unsigned char) ((*p >> 4) & 0xf);\n        SetPixelGray(image,ScaleAnyToQuantum(pixel,range),q);\n        q+=GetPixelChannels(image);\n        pixel=(unsigned char) ((*p) & 0xf);\n        SetPixelGray(image,ScaleAnyToQuantum(pixel,range),q);\n        p++;\n        q+=GetPixelChannels(image);\n      }\n      for (bit=0; bit < (ssize_t) (number_pixels % 2); bit++)\n      {\n        pixel=(unsigned char) (*p++ >> 4);\n        SetPixelGray(image,ScaleAnyToQuantum(pixel,range),q);\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 8:\n    {\n      unsigned char\n        pixel;\n\n      if (quantum_info->min_is_white != MagickFalse)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushCharPixel(p,&pixel);\n            SetPixelGray(image,ScaleCharToQuantum(pixel),q);\n            SetPixelAlpha(image,OpaqueAlpha,q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushCharPixel(p,&pixel);\n        SetPixelGray(image,ScaleCharToQuantum(pixel),q);\n        SetPixelAlpha(image,OpaqueAlpha,q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 10:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      if (quantum_info->pack == MagickFalse)\n        {\n          if (image->endian == LSBEndian)\n            {\n              for (x=0; x < (ssize_t) (number_pixels-2); x+=3)\n              {\n                p=PushLongPixel(quantum_info->endian,p,&pixel);\n                SetPixelGray(image,ScaleAnyToQuantum((pixel >> 22) & 0x3ff,\n                  range),q);\n                q+=GetPixelChannels(image);\n                SetPixelGray(image,ScaleAnyToQuantum((pixel >> 12) & 0x3ff,\n                  range),q);\n                q+=GetPixelChannels(image);\n                SetPixelGray(image,ScaleAnyToQuantum((pixel >> 2) & 0x3ff,\n                  range),q);\n                p+=quantum_info->pad;\n                q+=GetPixelChannels(image);\n              }\n              p=PushLongPixel(quantum_info->endian,p,&pixel);\n              if (x++ < (ssize_t) (number_pixels-1))\n                {\n                  SetPixelGray(image,ScaleAnyToQuantum((pixel >> 22) & 0x3ff,\n                    range),q);\n                  q+=GetPixelChannels(image);\n                }\n              if (x++ < (ssize_t) number_pixels)\n                {\n                  SetPixelGray(image,ScaleAnyToQuantum((pixel >> 12) & 0x3ff,\n                    range),q);\n                  q+=GetPixelChannels(image);\n                }\n              break;\n            }\n          for (x=0; x < (ssize_t) (number_pixels-2); x+=3)\n          {\n            p=PushLongPixel(quantum_info->endian,p,&pixel);\n            SetPixelGray(image,ScaleAnyToQuantum((pixel >> 2) & 0x3ff,range),\n              q);\n            q+=GetPixelChannels(image);\n            SetPixelGray(image,ScaleAnyToQuantum((pixel >> 12) & 0x3ff,range),\n              q);\n            q+=GetPixelChannels(image);\n            SetPixelGray(image,ScaleAnyToQuantum((pixel >> 22) & 0x3ff,range),\n              q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          p=PushLongPixel(quantum_info->endian,p,&pixel);\n          if (x++ < (ssize_t) (number_pixels-1))\n            {\n              SetPixelGray(image,ScaleAnyToQuantum((pixel >> 2) & 0x3ff,\n                range),q);\n              q+=GetPixelChannels(image);\n            }\n          if (x++ < (ssize_t) number_pixels)\n            {\n              SetPixelGray(image,ScaleAnyToQuantum((pixel >> 12) & 0x3ff,\n                range),q);\n              q+=GetPixelChannels(image);\n            }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelGray(image,ScaleAnyToQuantum(pixel,range),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 12:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      if (quantum_info->pack == MagickFalse)\n        {\n          unsigned short\n            pixel;\n\n          for (x=0; x < (ssize_t) (number_pixels-1); x+=2)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelGray(image,ScaleAnyToQuantum((QuantumAny) (pixel >> 4),\n              range),q);\n            q+=GetPixelChannels(image);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelGray(image,ScaleAnyToQuantum((QuantumAny) (pixel >> 4),\n              range),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          for (bit=0; bit < (ssize_t) (number_pixels % 2); bit++)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelGray(image,ScaleAnyToQuantum((QuantumAny) (pixel >> 4),\n              range),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          if (bit != 0)\n            p++;\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelGray(image,ScaleAnyToQuantum(pixel,range),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->min_is_white != MagickFalse)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelGray(image,ScaleShortToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelGray(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelGray(image,ScaleShortToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          float\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelGray(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelGray(image,ScaleLongToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          double\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelGray(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n    }\n    default:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelGray(image,ScaleAnyToQuantum(pixel,range),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n  }\n}",
        "func": "static void ImportGrayQuantum(const Image *image,QuantumInfo *quantum_info,\n  const MagickSizeType number_pixels,const unsigned char *magick_restrict p,\n  Quantum *magick_restrict q,ExceptionInfo *exception)\n{\n  QuantumAny\n    range;\n\n  register ssize_t\n    x;\n\n  ssize_t\n    bit;\n\n  unsigned int\n    pixel;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  pixel=0;\n  switch (quantum_info->depth)\n  {\n    case 1:\n    {\n      register Quantum\n        black,\n        white;\n\n      black=0;\n      white=QuantumRange;\n      if (quantum_info->min_is_white != MagickFalse)\n        {\n          black=QuantumRange;\n          white=0;\n        }\n      for (x=0; x < ((ssize_t) number_pixels-7); x+=8)\n      {\n        for (bit=0; bit < 8; bit++)\n        {\n          SetPixelGray(image,((*p) & (1 << (7-bit))) == 0 ? black : white,q);\n          q+=GetPixelChannels(image);\n        }\n        p++;\n      }\n      for (bit=0; bit < (ssize_t) (number_pixels % 8); bit++)\n      {\n        SetPixelGray(image,((*p) & (0x01 << (7-bit))) == 0 ? black : white,q);\n        q+=GetPixelChannels(image);\n      }\n      if (bit != 0)\n        p++;\n      break;\n    }\n    case 4:\n    {\n      register unsigned char\n        pixel;\n\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < ((ssize_t) number_pixels-1); x+=2)\n      {\n        pixel=(unsigned char) ((*p >> 4) & 0xf);\n        SetPixelGray(image,ScaleAnyToQuantum(pixel,range),q);\n        q+=GetPixelChannels(image);\n        pixel=(unsigned char) ((*p) & 0xf);\n        SetPixelGray(image,ScaleAnyToQuantum(pixel,range),q);\n        p++;\n        q+=GetPixelChannels(image);\n      }\n      for (bit=0; bit < (ssize_t) (number_pixels % 2); bit++)\n      {\n        pixel=(unsigned char) (*p++ >> 4);\n        SetPixelGray(image,ScaleAnyToQuantum(pixel,range),q);\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 8:\n    {\n      unsigned char\n        pixel;\n\n      if (quantum_info->min_is_white != MagickFalse)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushCharPixel(p,&pixel);\n            SetPixelGray(image,ScaleCharToQuantum(pixel),q);\n            SetPixelAlpha(image,OpaqueAlpha,q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushCharPixel(p,&pixel);\n        SetPixelGray(image,ScaleCharToQuantum(pixel),q);\n        SetPixelAlpha(image,OpaqueAlpha,q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 10:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      if (quantum_info->pack == MagickFalse)\n        {\n          if (image->endian == LSBEndian)\n            {\n              for (x=0; x < (ssize_t) (number_pixels-2); x+=3)\n              {\n                p=PushLongPixel(quantum_info->endian,p,&pixel);\n                SetPixelGray(image,ScaleAnyToQuantum((pixel >> 22) & 0x3ff,\n                  range),q);\n                q+=GetPixelChannels(image);\n                SetPixelGray(image,ScaleAnyToQuantum((pixel >> 12) & 0x3ff,\n                  range),q);\n                q+=GetPixelChannels(image);\n                SetPixelGray(image,ScaleAnyToQuantum((pixel >> 2) & 0x3ff,\n                  range),q);\n                p+=quantum_info->pad;\n                q+=GetPixelChannels(image);\n              }\n              p=PushLongPixel(quantum_info->endian,p,&pixel);\n              if (x++ < (ssize_t) (number_pixels-1))\n                {\n                  SetPixelGray(image,ScaleAnyToQuantum((pixel >> 22) & 0x3ff,\n                    range),q);\n                  q+=GetPixelChannels(image);\n                }\n              if (x++ < (ssize_t) number_pixels)\n                {\n                  SetPixelGray(image,ScaleAnyToQuantum((pixel >> 12) & 0x3ff,\n                    range),q);\n                  q+=GetPixelChannels(image);\n                }\n              break;\n            }\n          for (x=0; x < (ssize_t) (number_pixels-2); x+=3)\n          {\n            p=PushLongPixel(quantum_info->endian,p,&pixel);\n            SetPixelGray(image,ScaleAnyToQuantum((pixel >> 2) & 0x3ff,range),\n              q);\n            q+=GetPixelChannels(image);\n            SetPixelGray(image,ScaleAnyToQuantum((pixel >> 12) & 0x3ff,range),\n              q);\n            q+=GetPixelChannels(image);\n            SetPixelGray(image,ScaleAnyToQuantum((pixel >> 22) & 0x3ff,range),\n              q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          p=PushLongPixel(quantum_info->endian,p,&pixel);\n          if (x++ < (ssize_t) (number_pixels-1))\n            {\n              SetPixelGray(image,ScaleAnyToQuantum((pixel >> 2) & 0x3ff,\n                range),q);\n              q+=GetPixelChannels(image);\n            }\n          if (x++ < (ssize_t) number_pixels)\n            {\n              SetPixelGray(image,ScaleAnyToQuantum((pixel >> 12) & 0x3ff,\n                range),q);\n              q+=GetPixelChannels(image);\n            }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelGray(image,ScaleAnyToQuantum(pixel,range),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 12:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      if (quantum_info->pack == MagickFalse)\n        {\n          unsigned short\n            pixel;\n\n          for (x=0; x < (ssize_t) (number_pixels-1); x+=2)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelGray(image,ScaleAnyToQuantum((QuantumAny) (pixel >> 4),\n              range),q);\n            q+=GetPixelChannels(image);\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelGray(image,ScaleAnyToQuantum((QuantumAny) (pixel >> 4),\n              range),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          for (bit=0; bit < (ssize_t) (number_pixels % 2); bit++)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelGray(image,ScaleAnyToQuantum((QuantumAny) (pixel >> 4),\n              range),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          if (bit != 0)\n            p++;\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelGray(image,ScaleAnyToQuantum(pixel,range),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 16:\n    {\n      unsigned short\n        pixel;\n\n      if (quantum_info->min_is_white != MagickFalse)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelGray(image,ScaleShortToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushShortPixel(quantum_info->endian,p,&pixel);\n            SetPixelGray(image,ClampToQuantum(QuantumRange*\n              HalfToSinglePrecision(pixel)),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushShortPixel(quantum_info->endian,p,&pixel);\n        SetPixelGray(image,ScaleShortToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 32:\n    {\n      unsigned int\n        pixel;\n\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          float\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushFloatPixel(quantum_info,p,&pixel);\n            SetPixelGray(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushLongPixel(quantum_info->endian,p,&pixel);\n        SetPixelGray(image,ScaleLongToQuantum(pixel),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n    case 64:\n    {\n      if (quantum_info->format == FloatingPointQuantumFormat)\n        {\n          double\n            pixel;\n\n          for (x=0; x < (ssize_t) number_pixels; x++)\n          {\n            p=PushDoublePixel(quantum_info,p,&pixel);\n            SetPixelGray(image,ClampToQuantum(pixel),q);\n            p+=quantum_info->pad;\n            q+=GetPixelChannels(image);\n          }\n          break;\n        }\n    }\n    default:\n    {\n      range=GetQuantumRange(quantum_info->depth);\n      for (x=0; x < (ssize_t) number_pixels; x++)\n      {\n        p=PushQuantumPixel(quantum_info,p,&pixel);\n        SetPixelGray(image,ScaleAnyToQuantum(pixel,range),q);\n        p+=quantum_info->pad;\n        q+=GetPixelChannels(image);\n      }\n      break;\n    }\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -16,6 +16,7 @@\n \n   assert(image != (Image *) NULL);\n   assert(image->signature == MagickCoreSignature);\n+  pixel=0;\n   switch (quantum_info->depth)\n   {\n     case 1:",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "  pixel=0;"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-10065",
        "func_name": "ImageMagick/ReadVIFFImage",
        "description": "The ReadVIFFImage function in coders/viff.c in ImageMagick before 7.0.1-0 allows remote attackers to cause a denial of service (application crash) or have other unspecified impact via a crafted file.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/134463b926fa965571aa4febd61b810be5e7da05",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/129",
        "commit_text": "",
        "func_before": "static Image *ReadVIFFImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n#define VFF_CM_genericRGB  15\n#define VFF_CM_ntscRGB  1\n#define VFF_CM_NONE  0\n#define VFF_DEP_DECORDER  0x4\n#define VFF_DEP_NSORDER  0x8\n#define VFF_DES_RAW  0\n#define VFF_LOC_IMPLICIT  1\n#define VFF_MAPTYP_NONE  0\n#define VFF_MAPTYP_1_BYTE  1\n#define VFF_MAPTYP_2_BYTE  2\n#define VFF_MAPTYP_4_BYTE  4\n#define VFF_MAPTYP_FLOAT  5\n#define VFF_MAPTYP_DOUBLE  7\n#define VFF_MS_NONE  0\n#define VFF_MS_ONEPERBAND  1\n#define VFF_MS_SHARED  3\n#define VFF_TYP_BIT  0\n#define VFF_TYP_1_BYTE  1\n#define VFF_TYP_2_BYTE  2\n#define VFF_TYP_4_BYTE  4\n#define VFF_TYP_FLOAT  5\n#define VFF_TYP_DOUBLE  9\n\n  typedef struct _ViffInfo\n  {\n    unsigned char\n      identifier,\n      file_type,\n      release,\n      version,\n      machine_dependency,\n      reserve[3];\n\n    char\n      comment[512];\n\n    unsigned int\n      rows,\n      columns,\n      subrows;\n\n    int\n      x_offset,\n      y_offset;\n\n    float\n      x_bits_per_pixel,\n      y_bits_per_pixel;\n\n    unsigned int\n      location_type,\n      location_dimension,\n      number_of_images,\n      number_data_bands,\n      data_storage_type,\n      data_encode_scheme,\n      map_scheme,\n      map_storage_type,\n      map_rows,\n      map_columns,\n      map_subrows,\n      map_enable,\n      maps_per_cycle,\n      color_space_model;\n  } ViffInfo;\n\n  double\n    min_value,\n    scale_factor,\n    value;\n\n  Image\n    *image;\n\n  int\n    bit;\n\n  MagickBooleanType\n    status;\n\n  MagickSizeType\n    number_pixels;\n\n  register ssize_t\n    x;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *p;\n\n  size_t\n    bytes_per_pixel,\n    max_packets,\n    quantum;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    *pixels;\n\n  unsigned long\n    lsb_first;\n\n  ViffInfo\n    viff_info;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read VIFF header (1024 bytes).\n  */\n  count=ReadBlob(image,1,&viff_info.identifier);\n  do\n  {\n    /*\n      Verify VIFF identifier.\n    */\n    if ((count != 1) || ((unsigned char) viff_info.identifier != 0xab))\n      ThrowReaderException(CorruptImageError,\"NotAVIFFImage\");\n    /*\n      Initialize VIFF image.\n    */\n    (void) ReadBlob(image,sizeof(viff_info.file_type),&viff_info.file_type);\n    (void) ReadBlob(image,sizeof(viff_info.release),&viff_info.release);\n    (void) ReadBlob(image,sizeof(viff_info.version),&viff_info.version);\n    (void) ReadBlob(image,sizeof(viff_info.machine_dependency),\n      &viff_info.machine_dependency);\n    (void) ReadBlob(image,sizeof(viff_info.reserve),viff_info.reserve);\n    count=ReadBlob(image,512,(unsigned char *) viff_info.comment);\n    viff_info.comment[511]='\\0';\n    if (strlen(viff_info.comment) > 4)\n      (void) SetImageProperty(image,\"comment\",viff_info.comment,exception);\n    if ((viff_info.machine_dependency == VFF_DEP_DECORDER) ||\n        (viff_info.machine_dependency == VFF_DEP_NSORDER))\n      image->endian=LSBEndian;\n    else\n      image->endian=MSBEndian;\n    viff_info.rows=ReadBlobLong(image);\n    viff_info.columns=ReadBlobLong(image);\n    viff_info.subrows=ReadBlobLong(image);\n    viff_info.x_offset=(int) ReadBlobLong(image);\n    viff_info.y_offset=(int) ReadBlobLong(image);\n    viff_info.x_bits_per_pixel=(float) ReadBlobLong(image);\n    viff_info.y_bits_per_pixel=(float) ReadBlobLong(image);\n    viff_info.location_type=ReadBlobLong(image);\n    viff_info.location_dimension=ReadBlobLong(image);\n    viff_info.number_of_images=ReadBlobLong(image);\n    viff_info.number_data_bands=ReadBlobLong(image);\n    viff_info.data_storage_type=ReadBlobLong(image);\n    viff_info.data_encode_scheme=ReadBlobLong(image);\n    viff_info.map_scheme=ReadBlobLong(image);\n    viff_info.map_storage_type=ReadBlobLong(image);\n    viff_info.map_rows=ReadBlobLong(image);\n    viff_info.map_columns=ReadBlobLong(image);\n    viff_info.map_subrows=ReadBlobLong(image);\n    viff_info.map_enable=ReadBlobLong(image);\n    viff_info.maps_per_cycle=ReadBlobLong(image);\n    viff_info.color_space_model=ReadBlobLong(image);\n    for (i=0; i < 420; i++)\n      (void) ReadBlobByte(image);\n    if (EOFBlob(image) != MagickFalse)\n      ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n    image->columns=viff_info.rows;\n    image->rows=viff_info.columns;\n    image->depth=viff_info.x_bits_per_pixel <= 8 ? 8UL :\n      MAGICKCORE_QUANTUM_DEPTH;\n    /*\n      Verify that we can read this VIFF image.\n    */\n    number_pixels=(MagickSizeType) viff_info.columns*viff_info.rows;\n    if (number_pixels != (size_t) number_pixels)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    if (number_pixels == 0)\n      ThrowReaderException(CoderError,\"ImageColumnOrRowSizeIsNotSupported\");\n    if ((viff_info.number_data_bands < 1) || (viff_info.number_data_bands > 4))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if ((viff_info.data_storage_type != VFF_TYP_BIT) &&\n        (viff_info.data_storage_type != VFF_TYP_1_BYTE) &&\n        (viff_info.data_storage_type != VFF_TYP_2_BYTE) &&\n        (viff_info.data_storage_type != VFF_TYP_4_BYTE) &&\n        (viff_info.data_storage_type != VFF_TYP_FLOAT) &&\n        (viff_info.data_storage_type != VFF_TYP_DOUBLE))\n      ThrowReaderException(CoderError,\"DataStorageTypeIsNotSupported\");\n    if (viff_info.data_encode_scheme != VFF_DES_RAW)\n      ThrowReaderException(CoderError,\"DataEncodingSchemeIsNotSupported\");\n    if ((viff_info.map_storage_type != VFF_MAPTYP_NONE) &&\n        (viff_info.map_storage_type != VFF_MAPTYP_1_BYTE) &&\n        (viff_info.map_storage_type != VFF_MAPTYP_2_BYTE) &&\n        (viff_info.map_storage_type != VFF_MAPTYP_4_BYTE) &&\n        (viff_info.map_storage_type != VFF_MAPTYP_FLOAT) &&\n        (viff_info.map_storage_type != VFF_MAPTYP_DOUBLE))\n      ThrowReaderException(CoderError,\"MapStorageTypeIsNotSupported\");\n    if ((viff_info.color_space_model != VFF_CM_NONE) &&\n        (viff_info.color_space_model != VFF_CM_ntscRGB) &&\n        (viff_info.color_space_model != VFF_CM_genericRGB))\n      ThrowReaderException(CoderError,\"ColorspaceModelIsNotSupported\");\n    if (viff_info.location_type != VFF_LOC_IMPLICIT)\n      ThrowReaderException(CoderError,\"LocationTypeIsNotSupported\");\n    if (viff_info.number_of_images != 1)\n      ThrowReaderException(CoderError,\"NumberOfImagesIsNotSupported\");\n    if (viff_info.map_rows == 0)\n      viff_info.map_scheme=VFF_MS_NONE;\n    switch ((int) viff_info.map_scheme)\n    {\n      case VFF_MS_NONE:\n      {\n        if (viff_info.number_data_bands < 3)\n          {\n            /*\n              Create linear color ramp.\n            */\n            if (viff_info.data_storage_type == VFF_TYP_BIT)\n              image->colors=2;\n            else\n              if (viff_info.data_storage_type == VFF_MAPTYP_1_BYTE)\n                image->colors=256UL;\n              else\n                image->colors=image->depth <= 8 ? 256UL : 65536UL;\n            status=AcquireImageColormap(image,image->colors,exception);\n            if (status == MagickFalse)\n              ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n        break;\n      }\n      case VFF_MS_ONEPERBAND:\n      case VFF_MS_SHARED:\n      {\n        unsigned char\n          *viff_colormap;\n\n        /*\n          Allocate VIFF colormap.\n        */\n        switch ((int) viff_info.map_storage_type)\n        {\n          case VFF_MAPTYP_1_BYTE: bytes_per_pixel=1; break;\n          case VFF_MAPTYP_2_BYTE: bytes_per_pixel=2; break;\n          case VFF_MAPTYP_4_BYTE: bytes_per_pixel=4; break;\n          case VFF_MAPTYP_FLOAT: bytes_per_pixel=4; break;\n          case VFF_MAPTYP_DOUBLE: bytes_per_pixel=8; break;\n          default: bytes_per_pixel=1; break;\n        }\n        image->colors=viff_info.map_columns;\n        if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        if (viff_info.map_rows >\n            (viff_info.map_rows*bytes_per_pixel*sizeof(*viff_colormap)))\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n        viff_colormap=(unsigned char *) AcquireQuantumMemory(image->colors,\n          viff_info.map_rows*bytes_per_pixel*sizeof(*viff_colormap));\n        if (viff_colormap == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        /*\n          Read VIFF raster colormap.\n        */\n        count=ReadBlob(image,bytes_per_pixel*image->colors*viff_info.map_rows,\n          viff_colormap);\n        lsb_first=1;\n        if (*(char *) &lsb_first &&\n            ((viff_info.machine_dependency != VFF_DEP_DECORDER) &&\n             (viff_info.machine_dependency != VFF_DEP_NSORDER)))\n          switch ((int) viff_info.map_storage_type)\n          {\n            case VFF_MAPTYP_2_BYTE:\n            {\n              MSBOrderShort(viff_colormap,(bytes_per_pixel*image->colors*\n                viff_info.map_rows));\n              break;\n            }\n            case VFF_MAPTYP_4_BYTE:\n            case VFF_MAPTYP_FLOAT:\n            {\n              MSBOrderLong(viff_colormap,(bytes_per_pixel*image->colors*\n                viff_info.map_rows));\n              break;\n            }\n            default: break;\n          }\n        for (i=0; i < (ssize_t) (viff_info.map_rows*image->colors); i++)\n        {\n          switch ((int) viff_info.map_storage_type)\n          {\n            case VFF_MAPTYP_2_BYTE: value=1.0*((short *) viff_colormap)[i]; break;\n            case VFF_MAPTYP_4_BYTE: value=1.0*((int *) viff_colormap)[i]; break;\n            case VFF_MAPTYP_FLOAT: value=((float *) viff_colormap)[i]; break;\n            case VFF_MAPTYP_DOUBLE: value=((double *) viff_colormap)[i]; break;\n            default: value=1.0*viff_colormap[i]; break;\n          }\n          if (i < (ssize_t) image->colors)\n            {\n              image->colormap[i].red=ScaleCharToQuantum((unsigned char) value);\n              image->colormap[i].green=\n                ScaleCharToQuantum((unsigned char) value);\n              image->colormap[i].blue=ScaleCharToQuantum((unsigned char) value);\n            }\n          else\n            if (i < (ssize_t) (2*image->colors))\n              image->colormap[i % image->colors].green=\n                ScaleCharToQuantum((unsigned char) value);\n            else\n              if (i < (ssize_t) (3*image->colors))\n                image->colormap[i % image->colors].blue=\n                  ScaleCharToQuantum((unsigned char) value);\n        }\n        viff_colormap=(unsigned char *) RelinquishMagickMemory(viff_colormap);\n        break;\n      }\n      default:\n        ThrowReaderException(CoderError,\"ColormapTypeNotSupported\");\n    }\n    /*\n      Initialize image structure.\n    */\n    image->alpha_trait=viff_info.number_data_bands == 4 ? BlendPixelTrait : \n      UndefinedPixelTrait;\n    image->storage_class=(viff_info.number_data_bands < 3 ? PseudoClass :\n      DirectClass);\n    image->columns=viff_info.rows;\n    image->rows=viff_info.columns;\n    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return(DestroyImageList(image));\n    /*\n      Allocate VIFF pixels.\n    */\n    switch ((int) viff_info.data_storage_type)\n    {\n      case VFF_TYP_2_BYTE: bytes_per_pixel=2; break;\n      case VFF_TYP_4_BYTE: bytes_per_pixel=4; break;\n      case VFF_TYP_FLOAT: bytes_per_pixel=4; break;\n      case VFF_TYP_DOUBLE: bytes_per_pixel=8; break;\n      default: bytes_per_pixel=1; break;\n    }\n    if (viff_info.data_storage_type == VFF_TYP_BIT)\n      max_packets=((image->columns+7UL) >> 3UL)*image->rows;\n    else\n      max_packets=(size_t) (number_pixels*viff_info.number_data_bands);\n    pixels=(unsigned char *) AcquireQuantumMemory(MagickMax(number_pixels,\n      max_packets),bytes_per_pixel*sizeof(*pixels));\n    if (pixels == (unsigned char *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    count=ReadBlob(image,bytes_per_pixel*max_packets,pixels);\n    lsb_first=1;\n    if (*(char *) &lsb_first &&\n        ((viff_info.machine_dependency != VFF_DEP_DECORDER) &&\n         (viff_info.machine_dependency != VFF_DEP_NSORDER)))\n      switch ((int) viff_info.data_storage_type)\n      {\n        case VFF_TYP_2_BYTE:\n        {\n          MSBOrderShort(pixels,bytes_per_pixel*max_packets);\n          break;\n        }\n        case VFF_TYP_4_BYTE:\n        case VFF_TYP_FLOAT:\n        {\n          MSBOrderLong(pixels,bytes_per_pixel*max_packets);\n          break;\n        }\n        default: break;\n      }\n    min_value=0.0;\n    scale_factor=1.0;\n    if ((viff_info.data_storage_type != VFF_TYP_1_BYTE) &&\n        (viff_info.map_scheme == VFF_MS_NONE))\n      {\n        double\n          max_value;\n\n        /*\n          Determine scale factor.\n        */\n        switch ((int) viff_info.data_storage_type)\n        {\n          case VFF_TYP_2_BYTE: value=1.0*((short *) pixels)[0]; break;\n          case VFF_TYP_4_BYTE: value=1.0*((int *) pixels)[0]; break;\n          case VFF_TYP_FLOAT: value=((float *) pixels)[0]; break;\n          case VFF_TYP_DOUBLE: value=((double *) pixels)[0]; break;\n          default: value=1.0*pixels[0]; break;\n        }\n        max_value=value;\n        min_value=value;\n        for (i=0; i < (ssize_t) max_packets; i++)\n        {\n          switch ((int) viff_info.data_storage_type)\n          {\n            case VFF_TYP_2_BYTE: value=1.0*((short *) pixels)[i]; break;\n            case VFF_TYP_4_BYTE: value=1.0*((int *) pixels)[i]; break;\n            case VFF_TYP_FLOAT: value=((float *) pixels)[i]; break;\n            case VFF_TYP_DOUBLE: value=((double *) pixels)[i]; break;\n            default: value=1.0*pixels[i]; break;\n          }\n          if (value > max_value)\n            max_value=value;\n          else\n            if (value < min_value)\n              min_value=value;\n        }\n        if ((min_value == 0) && (max_value == 0))\n          scale_factor=0;\n        else\n          if (min_value == max_value)\n            {\n              scale_factor=(double) QuantumRange/min_value;\n              min_value=0;\n            }\n          else\n            scale_factor=(double) QuantumRange/(max_value-min_value);\n      }\n    /*\n      Convert pixels to Quantum size.\n    */\n    p=(unsigned char *) pixels;\n    for (i=0; i < (ssize_t) max_packets; i++)\n    {\n      switch ((int) viff_info.data_storage_type)\n      {\n        case VFF_TYP_2_BYTE: value=1.0*((short *) pixels)[i]; break;\n        case VFF_TYP_4_BYTE: value=1.0*((int *) pixels)[i]; break;\n        case VFF_TYP_FLOAT: value=((float *) pixels)[i]; break;\n        case VFF_TYP_DOUBLE: value=((double *) pixels)[i]; break;\n        default: value=1.0*pixels[i]; break;\n      }\n      if (viff_info.map_scheme == VFF_MS_NONE)\n        {\n          value=(value-min_value)*scale_factor;\n          if (value > QuantumRange)\n            value=QuantumRange;\n          else\n            if (value < 0)\n              value=0;\n        }\n      *p=(unsigned char) ((Quantum) value);\n      p++;\n    }\n    /*\n      Convert VIFF raster image to pixel packets.\n    */\n    p=(unsigned char *) pixels;\n    if (viff_info.data_storage_type == VFF_TYP_BIT)\n      {\n        /*\n          Convert bitmap scanline.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) (image->columns-7); x+=8)\n          {\n            for (bit=0; bit < 8; bit++)\n            {\n              quantum=(size_t) ((*p) & (0x01 << bit) ? 0 : 1);\n              SetPixelRed(image,quantum == 0 ? 0 : QuantumRange,q);\n              SetPixelGreen(image,quantum == 0 ? 0 : QuantumRange,q);\n              SetPixelBlue(image,quantum == 0 ? 0 : QuantumRange,q);\n              if (image->storage_class == PseudoClass)\n                SetPixelIndex(image,(Quantum) quantum,q);\n              q+=GetPixelChannels(image);\n            }\n            p++;\n          }\n          if ((image->columns % 8) != 0)\n            {\n              for (bit=0; bit < (int) (image->columns % 8); bit++)\n              {\n                quantum=(size_t) ((*p) & (0x01 << bit) ? 0 : 1);\n                SetPixelRed(image,quantum == 0 ? 0 : QuantumRange,q);\n                SetPixelGreen(image,quantum == 0 ? 0 : QuantumRange,q);\n                SetPixelBlue(image,quantum == 0 ? 0 : QuantumRange,q);\n                if (image->storage_class == PseudoClass)\n                  SetPixelIndex(image,(Quantum) quantum,q);\n                q+=GetPixelChannels(image);\n              }\n              p++;\n            }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n      }\n    else\n      if (image->storage_class == PseudoClass)\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelIndex(image,*p++,q);\n            q+=GetPixelChannels(image);\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n      else\n        {\n          /*\n            Convert DirectColor scanline.\n          */\n          number_pixels=(MagickSizeType) image->columns*image->rows;\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (Quantum *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              SetPixelRed(image,ScaleCharToQuantum(*p),q);\n              SetPixelGreen(image,ScaleCharToQuantum(*(p+number_pixels)),q);\n              SetPixelBlue(image,ScaleCharToQuantum(*(p+2*number_pixels)),q);\n              if (image->colors != 0)\n                {\n                  ssize_t\n                    index;\n                  \n                  index=(ssize_t) GetPixelRed(image,q);\n                  SetPixelRed(image,image->colormap[\n                    ConstrainColormapIndex(image,index,exception)].red,q);\n                  index=(ssize_t) GetPixelGreen(image,q);\n                  SetPixelGreen(image,image->colormap[\n                    ConstrainColormapIndex(image,index,exception)].green,q);\n                  index=(ssize_t) GetPixelBlue(image,q);\n                  SetPixelBlue(image,image->colormap[\n                    ConstrainColormapIndex(image,index,exception)].blue,q);\n                }\n              SetPixelAlpha(image,image->alpha_trait != UndefinedPixelTrait ?\n                ScaleCharToQuantum(*(p+number_pixels*3)) : OpaqueAlpha,q);\n              p++;\n              q+=GetPixelChannels(image);\n            }\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n        }\n    pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n    if (image->storage_class == PseudoClass)\n      (void) SyncImage(image,exception);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    count=ReadBlob(image,1,&viff_info.identifier);\n    if ((count != 0) && (viff_info.identifier == 0xab))\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while ((count != 0) && (viff_info.identifier == 0xab));\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
        "func": "static Image *ReadVIFFImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n#define VFF_CM_genericRGB  15\n#define VFF_CM_ntscRGB  1\n#define VFF_CM_NONE  0\n#define VFF_DEP_DECORDER  0x4\n#define VFF_DEP_NSORDER  0x8\n#define VFF_DES_RAW  0\n#define VFF_LOC_IMPLICIT  1\n#define VFF_MAPTYP_NONE  0\n#define VFF_MAPTYP_1_BYTE  1\n#define VFF_MAPTYP_2_BYTE  2\n#define VFF_MAPTYP_4_BYTE  4\n#define VFF_MAPTYP_FLOAT  5\n#define VFF_MAPTYP_DOUBLE  7\n#define VFF_MS_NONE  0\n#define VFF_MS_ONEPERBAND  1\n#define VFF_MS_SHARED  3\n#define VFF_TYP_BIT  0\n#define VFF_TYP_1_BYTE  1\n#define VFF_TYP_2_BYTE  2\n#define VFF_TYP_4_BYTE  4\n#define VFF_TYP_FLOAT  5\n#define VFF_TYP_DOUBLE  9\n\n  typedef struct _ViffInfo\n  {\n    unsigned char\n      identifier,\n      file_type,\n      release,\n      version,\n      machine_dependency,\n      reserve[3];\n\n    char\n      comment[512];\n\n    unsigned int\n      rows,\n      columns,\n      subrows;\n\n    int\n      x_offset,\n      y_offset;\n\n    float\n      x_bits_per_pixel,\n      y_bits_per_pixel;\n\n    unsigned int\n      location_type,\n      location_dimension,\n      number_of_images,\n      number_data_bands,\n      data_storage_type,\n      data_encode_scheme,\n      map_scheme,\n      map_storage_type,\n      map_rows,\n      map_columns,\n      map_subrows,\n      map_enable,\n      maps_per_cycle,\n      color_space_model;\n  } ViffInfo;\n\n  double\n    min_value,\n    scale_factor,\n    value;\n\n  Image\n    *image;\n\n  int\n    bit;\n\n  MagickBooleanType\n    status;\n\n  MagickSizeType\n    number_pixels;\n\n  register ssize_t\n    x;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    i;\n\n  register unsigned char\n    *p;\n\n  size_t\n    bytes_per_pixel,\n    max_packets,\n    quantum;\n\n  ssize_t\n    count,\n    y;\n\n  unsigned char\n    *pixels;\n\n  unsigned long\n    lsb_first;\n\n  ViffInfo\n    viff_info;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read VIFF header (1024 bytes).\n  */\n  count=ReadBlob(image,1,&viff_info.identifier);\n  do\n  {\n    /*\n      Verify VIFF identifier.\n    */\n    if ((count != 1) || ((unsigned char) viff_info.identifier != 0xab))\n      ThrowReaderException(CorruptImageError,\"NotAVIFFImage\");\n    /*\n      Initialize VIFF image.\n    */\n    (void) ReadBlob(image,sizeof(viff_info.file_type),&viff_info.file_type);\n    (void) ReadBlob(image,sizeof(viff_info.release),&viff_info.release);\n    (void) ReadBlob(image,sizeof(viff_info.version),&viff_info.version);\n    (void) ReadBlob(image,sizeof(viff_info.machine_dependency),\n      &viff_info.machine_dependency);\n    (void) ReadBlob(image,sizeof(viff_info.reserve),viff_info.reserve);\n    count=ReadBlob(image,512,(unsigned char *) viff_info.comment);\n    viff_info.comment[511]='\\0';\n    if (strlen(viff_info.comment) > 4)\n      (void) SetImageProperty(image,\"comment\",viff_info.comment,exception);\n    if ((viff_info.machine_dependency == VFF_DEP_DECORDER) ||\n        (viff_info.machine_dependency == VFF_DEP_NSORDER))\n      image->endian=LSBEndian;\n    else\n      image->endian=MSBEndian;\n    viff_info.rows=ReadBlobLong(image);\n    viff_info.columns=ReadBlobLong(image);\n    viff_info.subrows=ReadBlobLong(image);\n    viff_info.x_offset=(int) ReadBlobLong(image);\n    viff_info.y_offset=(int) ReadBlobLong(image);\n    viff_info.x_bits_per_pixel=(float) ReadBlobLong(image);\n    viff_info.y_bits_per_pixel=(float) ReadBlobLong(image);\n    viff_info.location_type=ReadBlobLong(image);\n    viff_info.location_dimension=ReadBlobLong(image);\n    viff_info.number_of_images=ReadBlobLong(image);\n    viff_info.number_data_bands=ReadBlobLong(image);\n    viff_info.data_storage_type=ReadBlobLong(image);\n    viff_info.data_encode_scheme=ReadBlobLong(image);\n    viff_info.map_scheme=ReadBlobLong(image);\n    viff_info.map_storage_type=ReadBlobLong(image);\n    viff_info.map_rows=ReadBlobLong(image);\n    viff_info.map_columns=ReadBlobLong(image);\n    viff_info.map_subrows=ReadBlobLong(image);\n    viff_info.map_enable=ReadBlobLong(image);\n    viff_info.maps_per_cycle=ReadBlobLong(image);\n    viff_info.color_space_model=ReadBlobLong(image);\n    for (i=0; i < 420; i++)\n      (void) ReadBlobByte(image);\n    if (EOFBlob(image) != MagickFalse)\n      ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n    image->columns=viff_info.rows;\n    image->rows=viff_info.columns;\n    image->depth=viff_info.x_bits_per_pixel <= 8 ? 8UL :\n      MAGICKCORE_QUANTUM_DEPTH;\n    /*\n      Verify that we can read this VIFF image.\n    */\n    number_pixels=(MagickSizeType) viff_info.columns*viff_info.rows;\n    if (number_pixels != (size_t) number_pixels)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    if (number_pixels == 0)\n      ThrowReaderException(CoderError,\"ImageColumnOrRowSizeIsNotSupported\");\n    if ((viff_info.number_data_bands < 1) || (viff_info.number_data_bands > 4))\n      ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n    if ((viff_info.data_storage_type != VFF_TYP_BIT) &&\n        (viff_info.data_storage_type != VFF_TYP_1_BYTE) &&\n        (viff_info.data_storage_type != VFF_TYP_2_BYTE) &&\n        (viff_info.data_storage_type != VFF_TYP_4_BYTE) &&\n        (viff_info.data_storage_type != VFF_TYP_FLOAT) &&\n        (viff_info.data_storage_type != VFF_TYP_DOUBLE))\n      ThrowReaderException(CoderError,\"DataStorageTypeIsNotSupported\");\n    if (viff_info.data_encode_scheme != VFF_DES_RAW)\n      ThrowReaderException(CoderError,\"DataEncodingSchemeIsNotSupported\");\n    if ((viff_info.map_storage_type != VFF_MAPTYP_NONE) &&\n        (viff_info.map_storage_type != VFF_MAPTYP_1_BYTE) &&\n        (viff_info.map_storage_type != VFF_MAPTYP_2_BYTE) &&\n        (viff_info.map_storage_type != VFF_MAPTYP_4_BYTE) &&\n        (viff_info.map_storage_type != VFF_MAPTYP_FLOAT) &&\n        (viff_info.map_storage_type != VFF_MAPTYP_DOUBLE))\n      ThrowReaderException(CoderError,\"MapStorageTypeIsNotSupported\");\n    if ((viff_info.color_space_model != VFF_CM_NONE) &&\n        (viff_info.color_space_model != VFF_CM_ntscRGB) &&\n        (viff_info.color_space_model != VFF_CM_genericRGB))\n      ThrowReaderException(CoderError,\"ColorspaceModelIsNotSupported\");\n    if (viff_info.location_type != VFF_LOC_IMPLICIT)\n      ThrowReaderException(CoderError,\"LocationTypeIsNotSupported\");\n    if (viff_info.number_of_images != 1)\n      ThrowReaderException(CoderError,\"NumberOfImagesIsNotSupported\");\n    if (viff_info.map_rows == 0)\n      viff_info.map_scheme=VFF_MS_NONE;\n    switch ((int) viff_info.map_scheme)\n    {\n      case VFF_MS_NONE:\n      {\n        if (viff_info.number_data_bands < 3)\n          {\n            /*\n              Create linear color ramp.\n            */\n            if (viff_info.data_storage_type == VFF_TYP_BIT)\n              image->colors=2;\n            else\n              if (viff_info.data_storage_type == VFF_MAPTYP_1_BYTE)\n                image->colors=256UL;\n              else\n                image->colors=image->depth <= 8 ? 256UL : 65536UL;\n            status=AcquireImageColormap(image,image->colors,exception);\n            if (status == MagickFalse)\n              ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n          }\n        break;\n      }\n      case VFF_MS_ONEPERBAND:\n      case VFF_MS_SHARED:\n      {\n        unsigned char\n          *viff_colormap;\n\n        /*\n          Allocate VIFF colormap.\n        */\n        switch ((int) viff_info.map_storage_type)\n        {\n          case VFF_MAPTYP_1_BYTE: bytes_per_pixel=1; break;\n          case VFF_MAPTYP_2_BYTE: bytes_per_pixel=2; break;\n          case VFF_MAPTYP_4_BYTE: bytes_per_pixel=4; break;\n          case VFF_MAPTYP_FLOAT: bytes_per_pixel=4; break;\n          case VFF_MAPTYP_DOUBLE: bytes_per_pixel=8; break;\n          default: bytes_per_pixel=1; break;\n        }\n        image->colors=viff_info.map_columns;\n        if (AcquireImageColormap(image,image->colors,exception) == MagickFalse)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        if (viff_info.map_rows >\n            (viff_info.map_rows*bytes_per_pixel*sizeof(*viff_colormap)))\n          ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n        viff_colormap=(unsigned char *) AcquireQuantumMemory(image->colors,\n          viff_info.map_rows*bytes_per_pixel*sizeof(*viff_colormap));\n        if (viff_colormap == (unsigned char *) NULL)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        /*\n          Read VIFF raster colormap.\n        */\n        count=ReadBlob(image,bytes_per_pixel*image->colors*viff_info.map_rows,\n          viff_colormap);\n        lsb_first=1;\n        if (*(char *) &lsb_first &&\n            ((viff_info.machine_dependency != VFF_DEP_DECORDER) &&\n             (viff_info.machine_dependency != VFF_DEP_NSORDER)))\n          switch ((int) viff_info.map_storage_type)\n          {\n            case VFF_MAPTYP_2_BYTE:\n            {\n              MSBOrderShort(viff_colormap,(bytes_per_pixel*image->colors*\n                viff_info.map_rows));\n              break;\n            }\n            case VFF_MAPTYP_4_BYTE:\n            case VFF_MAPTYP_FLOAT:\n            {\n              MSBOrderLong(viff_colormap,(bytes_per_pixel*image->colors*\n                viff_info.map_rows));\n              break;\n            }\n            default: break;\n          }\n        for (i=0; i < (ssize_t) (viff_info.map_rows*image->colors); i++)\n        {\n          switch ((int) viff_info.map_storage_type)\n          {\n            case VFF_MAPTYP_2_BYTE: value=1.0*((short *) viff_colormap)[i]; break;\n            case VFF_MAPTYP_4_BYTE: value=1.0*((int *) viff_colormap)[i]; break;\n            case VFF_MAPTYP_FLOAT: value=((float *) viff_colormap)[i]; break;\n            case VFF_MAPTYP_DOUBLE: value=((double *) viff_colormap)[i]; break;\n            default: value=1.0*viff_colormap[i]; break;\n          }\n          if (i < (ssize_t) image->colors)\n            {\n              image->colormap[i].red=ScaleCharToQuantum((unsigned char) value);\n              image->colormap[i].green=\n                ScaleCharToQuantum((unsigned char) value);\n              image->colormap[i].blue=ScaleCharToQuantum((unsigned char) value);\n            }\n          else\n            if (i < (ssize_t) (2*image->colors))\n              image->colormap[i % image->colors].green=\n                ScaleCharToQuantum((unsigned char) value);\n            else\n              if (i < (ssize_t) (3*image->colors))\n                image->colormap[i % image->colors].blue=\n                  ScaleCharToQuantum((unsigned char) value);\n        }\n        viff_colormap=(unsigned char *) RelinquishMagickMemory(viff_colormap);\n        break;\n      }\n      default:\n        ThrowReaderException(CoderError,\"ColormapTypeNotSupported\");\n    }\n    /*\n      Initialize image structure.\n    */\n    image->alpha_trait=viff_info.number_data_bands == 4 ? BlendPixelTrait :\n      UndefinedPixelTrait;\n    image->storage_class=(viff_info.number_data_bands < 3 ? PseudoClass :\n      DirectClass);\n    image->columns=viff_info.rows;\n    image->rows=viff_info.columns;\n    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    status=SetImageExtent(image,image->columns,image->rows,exception);\n    if (status == MagickFalse)\n      return(DestroyImageList(image));\n    /*\n      Allocate VIFF pixels.\n    */\n    switch ((int) viff_info.data_storage_type)\n    {\n      case VFF_TYP_2_BYTE: bytes_per_pixel=2; break;\n      case VFF_TYP_4_BYTE: bytes_per_pixel=4; break;\n      case VFF_TYP_FLOAT: bytes_per_pixel=4; break;\n      case VFF_TYP_DOUBLE: bytes_per_pixel=8; break;\n      default: bytes_per_pixel=1; break;\n    }\n    if (viff_info.data_storage_type == VFF_TYP_BIT)\n      {\n        if (CheckMemoryOverflow((image->columns+7UL) >> 3UL,image->rows) != MagickFalse)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        max_packets=((image->columns+7UL) >> 3UL)*image->rows;\n      }\n    else\n      {\n        if (CheckMemoryOverflow(number_pixels,viff_info.number_data_bands) != MagickFalse)\n          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n        max_packets=(size_t) (number_pixels*viff_info.number_data_bands);\n      }\n    pixels=(unsigned char *) AcquireQuantumMemory(MagickMax(number_pixels,\n      max_packets),bytes_per_pixel*sizeof(*pixels));\n    if (pixels == (unsigned char *) NULL)\n      ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n    count=ReadBlob(image,bytes_per_pixel*max_packets,pixels);\n    lsb_first=1;\n    if (*(char *) &lsb_first &&\n        ((viff_info.machine_dependency != VFF_DEP_DECORDER) &&\n         (viff_info.machine_dependency != VFF_DEP_NSORDER)))\n      switch ((int) viff_info.data_storage_type)\n      {\n        case VFF_TYP_2_BYTE:\n        {\n          MSBOrderShort(pixels,bytes_per_pixel*max_packets);\n          break;\n        }\n        case VFF_TYP_4_BYTE:\n        case VFF_TYP_FLOAT:\n        {\n          MSBOrderLong(pixels,bytes_per_pixel*max_packets);\n          break;\n        }\n        default: break;\n      }\n    min_value=0.0;\n    scale_factor=1.0;\n    if ((viff_info.data_storage_type != VFF_TYP_1_BYTE) &&\n        (viff_info.map_scheme == VFF_MS_NONE))\n      {\n        double\n          max_value;\n\n        /*\n          Determine scale factor.\n        */\n        switch ((int) viff_info.data_storage_type)\n        {\n          case VFF_TYP_2_BYTE: value=1.0*((short *) pixels)[0]; break;\n          case VFF_TYP_4_BYTE: value=1.0*((int *) pixels)[0]; break;\n          case VFF_TYP_FLOAT: value=((float *) pixels)[0]; break;\n          case VFF_TYP_DOUBLE: value=((double *) pixels)[0]; break;\n          default: value=1.0*pixels[0]; break;\n        }\n        max_value=value;\n        min_value=value;\n        for (i=0; i < (ssize_t) max_packets; i++)\n        {\n          switch ((int) viff_info.data_storage_type)\n          {\n            case VFF_TYP_2_BYTE: value=1.0*((short *) pixels)[i]; break;\n            case VFF_TYP_4_BYTE: value=1.0*((int *) pixels)[i]; break;\n            case VFF_TYP_FLOAT: value=((float *) pixels)[i]; break;\n            case VFF_TYP_DOUBLE: value=((double *) pixels)[i]; break;\n            default: value=1.0*pixels[i]; break;\n          }\n          if (value > max_value)\n            max_value=value;\n          else\n            if (value < min_value)\n              min_value=value;\n        }\n        if ((min_value == 0) && (max_value == 0))\n          scale_factor=0;\n        else\n          if (min_value == max_value)\n            {\n              scale_factor=(double) QuantumRange/min_value;\n              min_value=0;\n            }\n          else\n            scale_factor=(double) QuantumRange/(max_value-min_value);\n      }\n    /*\n      Convert pixels to Quantum size.\n    */\n    p=(unsigned char *) pixels;\n    for (i=0; i < (ssize_t) max_packets; i++)\n    {\n      switch ((int) viff_info.data_storage_type)\n      {\n        case VFF_TYP_2_BYTE: value=1.0*((short *) pixels)[i]; break;\n        case VFF_TYP_4_BYTE: value=1.0*((int *) pixels)[i]; break;\n        case VFF_TYP_FLOAT: value=((float *) pixels)[i]; break;\n        case VFF_TYP_DOUBLE: value=((double *) pixels)[i]; break;\n        default: value=1.0*pixels[i]; break;\n      }\n      if (viff_info.map_scheme == VFF_MS_NONE)\n        {\n          value=(value-min_value)*scale_factor;\n          if (value > QuantumRange)\n            value=QuantumRange;\n          else\n            if (value < 0)\n              value=0;\n        }\n      *p=(unsigned char) ((Quantum) value);\n      p++;\n    }\n    /*\n      Convert VIFF raster image to pixel packets.\n    */\n    p=(unsigned char *) pixels;\n    if (viff_info.data_storage_type == VFF_TYP_BIT)\n      {\n        /*\n          Convert bitmap scanline.\n        */\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) (image->columns-7); x+=8)\n          {\n            for (bit=0; bit < 8; bit++)\n            {\n              quantum=(size_t) ((*p) & (0x01 << bit) ? 0 : 1);\n              SetPixelRed(image,quantum == 0 ? 0 : QuantumRange,q);\n              SetPixelGreen(image,quantum == 0 ? 0 : QuantumRange,q);\n              SetPixelBlue(image,quantum == 0 ? 0 : QuantumRange,q);\n              if (image->storage_class == PseudoClass)\n                SetPixelIndex(image,(Quantum) quantum,q);\n              q+=GetPixelChannels(image);\n            }\n            p++;\n          }\n          if ((image->columns % 8) != 0)\n            {\n              for (bit=0; bit < (int) (image->columns % 8); bit++)\n              {\n                quantum=(size_t) ((*p) & (0x01 << bit) ? 0 : 1);\n                SetPixelRed(image,quantum == 0 ? 0 : QuantumRange,q);\n                SetPixelGreen(image,quantum == 0 ? 0 : QuantumRange,q);\n                SetPixelBlue(image,quantum == 0 ? 0 : QuantumRange,q);\n                if (image->storage_class == PseudoClass)\n                  SetPixelIndex(image,(Quantum) quantum,q);\n                q+=GetPixelChannels(image);\n              }\n              p++;\n            }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n      }\n    else\n      if (image->storage_class == PseudoClass)\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n          if (q == (Quantum *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            SetPixelIndex(image,*p++,q);\n            q+=GetPixelChannels(image);\n          }\n          if (SyncAuthenticPixels(image,exception) == MagickFalse)\n            break;\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n      else\n        {\n          /*\n            Convert DirectColor scanline.\n          */\n          number_pixels=(MagickSizeType) image->columns*image->rows;\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            q=QueueAuthenticPixels(image,0,y,image->columns,1,exception);\n            if (q == (Quantum *) NULL)\n              break;\n            for (x=0; x < (ssize_t) image->columns; x++)\n            {\n              SetPixelRed(image,ScaleCharToQuantum(*p),q);\n              SetPixelGreen(image,ScaleCharToQuantum(*(p+number_pixels)),q);\n              SetPixelBlue(image,ScaleCharToQuantum(*(p+2*number_pixels)),q);\n              if (image->colors != 0)\n                {\n                  ssize_t\n                    index;\n\n                  index=(ssize_t) GetPixelRed(image,q);\n                  SetPixelRed(image,image->colormap[\n                    ConstrainColormapIndex(image,index,exception)].red,q);\n                  index=(ssize_t) GetPixelGreen(image,q);\n                  SetPixelGreen(image,image->colormap[\n                    ConstrainColormapIndex(image,index,exception)].green,q);\n                  index=(ssize_t) GetPixelBlue(image,q);\n                  SetPixelBlue(image,image->colormap[\n                    ConstrainColormapIndex(image,index,exception)].blue,q);\n                }\n              SetPixelAlpha(image,image->alpha_trait != UndefinedPixelTrait ?\n                ScaleCharToQuantum(*(p+number_pixels*3)) : OpaqueAlpha,q);\n              p++;\n              q+=GetPixelChannels(image);\n            }\n            if (SyncAuthenticPixels(image,exception) == MagickFalse)\n              break;\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n        }\n    pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n    if (image->storage_class == PseudoClass)\n      (void) SyncImage(image,exception);\n    if (EOFBlob(image) != MagickFalse)\n      {\n        ThrowFileException(exception,CorruptImageError,\"UnexpectedEndOfFile\",\n          image->filename);\n        break;\n      }\n    /*\n      Proceed to next image.\n    */\n    if (image_info->number_scenes != 0)\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    count=ReadBlob(image,1,&viff_info.identifier);\n    if ((count != 0) && (viff_info.identifier == 0xab))\n      {\n        /*\n          Allocate next image structure.\n        */\n        AcquireNextImage(image_info,image,exception);\n        if (GetNextImageInList(image) == (Image *) NULL)\n          {\n            image=DestroyImageList(image);\n            return((Image *) NULL);\n          }\n        image=SyncNextImageInList(image);\n        status=SetImageProgress(image,LoadImagesTag,TellBlob(image),\n          GetBlobSize(image));\n        if (status == MagickFalse)\n          break;\n      }\n  } while ((count != 0) && (viff_info.identifier == 0xab));\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -336,7 +336,7 @@\n     /*\n       Initialize image structure.\n     */\n-    image->alpha_trait=viff_info.number_data_bands == 4 ? BlendPixelTrait : \n+    image->alpha_trait=viff_info.number_data_bands == 4 ? BlendPixelTrait :\n       UndefinedPixelTrait;\n     image->storage_class=(viff_info.number_data_bands < 3 ? PseudoClass :\n       DirectClass);\n@@ -360,9 +360,17 @@\n       default: bytes_per_pixel=1; break;\n     }\n     if (viff_info.data_storage_type == VFF_TYP_BIT)\n-      max_packets=((image->columns+7UL) >> 3UL)*image->rows;\n+      {\n+        if (CheckMemoryOverflow((image->columns+7UL) >> 3UL,image->rows) != MagickFalse)\n+          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n+        max_packets=((image->columns+7UL) >> 3UL)*image->rows;\n+      }\n     else\n-      max_packets=(size_t) (number_pixels*viff_info.number_data_bands);\n+      {\n+        if (CheckMemoryOverflow(number_pixels,viff_info.number_data_bands) != MagickFalse)\n+          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");\n+        max_packets=(size_t) (number_pixels*viff_info.number_data_bands);\n+      }\n     pixels=(unsigned char *) AcquireQuantumMemory(MagickMax(number_pixels,\n       max_packets),bytes_per_pixel*sizeof(*pixels));\n     if (pixels == (unsigned char *) NULL)\n@@ -556,7 +564,7 @@\n                 {\n                   ssize_t\n                     index;\n-                  \n+\n                   index=(ssize_t) GetPixelRed(image,q);\n                   SetPixelRed(image,image->colormap[\n                     ConstrainColormapIndex(image,index,exception)].red,q);",
        "diff_line_info": {
            "deleted_lines": [
                "    image->alpha_trait=viff_info.number_data_bands == 4 ? BlendPixelTrait : ",
                "      max_packets=((image->columns+7UL) >> 3UL)*image->rows;",
                "      max_packets=(size_t) (number_pixels*viff_info.number_data_bands);",
                "                  "
            ],
            "added_lines": [
                "    image->alpha_trait=viff_info.number_data_bands == 4 ? BlendPixelTrait :",
                "      {",
                "        if (CheckMemoryOverflow((image->columns+7UL) >> 3UL,image->rows) != MagickFalse)",
                "          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");",
                "        max_packets=((image->columns+7UL) >> 3UL)*image->rows;",
                "      }",
                "      {",
                "        if (CheckMemoryOverflow(number_pixels,viff_info.number_data_bands) != MagickFalse)",
                "          ThrowReaderException(ResourceLimitError,\"MemoryAllocationFailed\");",
                "        max_packets=(size_t) (number_pixels*viff_info.number_data_bands);",
                "      }",
                ""
            ]
        }
    }
]