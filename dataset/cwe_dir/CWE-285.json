[
    {
        "cve_id": "CVE-2016-1710",
        "func_name": "chromium/ChromeClientImpl::createWindow",
        "description": "The ChromeClientImpl::createWindow method in WebKit/Source/web/ChromeClientImpl.cpp in Blink, as used in Google Chrome before 52.0.2743.82, does not prevent window creation by a deferred frame, which allows remote attackers to bypass the Same Origin Policy via a crafted web site.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/25a8ae78165cd8725465d26e02a342d7121c42f4",
        "commit_title": "Don't allow deferred frames to create new windows.",
        "commit_text": " New pages never defer loads, which makes it difficult for ScopedPageLoadDeferrer to protect against synchronous loads.  This patch adds a check in ChromeClientImpl::createWindow.   Review-Url: https://codereview.chromium.org/2035973002 ",
        "func_before": "Page* ChromeClientImpl::createWindow(LocalFrame* frame, const FrameLoadRequest& r, const WindowFeatures& features,\n    NavigationPolicy navigationPolicy)\n{\n    if (!m_webView->client())\n        return nullptr;\n\n    WebNavigationPolicy policy = effectiveNavigationPolicy(navigationPolicy, features);\n    DCHECK(frame->document());\n    Fullscreen::fullyExitFullscreen(*frame->document());\n\n    WebViewImpl* newView = toWebViewImpl(\n        m_webView->client()->createView(WebLocalFrameImpl::fromFrame(frame), WrappedResourceRequest(r.resourceRequest()), features, r.frameName(), policy, r.getShouldSetOpener() == NeverSetOpener || features.noopener));\n    if (!newView)\n        return nullptr;\n    return newView->page();\n}",
        "func": "Page* ChromeClientImpl::createWindow(LocalFrame* frame, const FrameLoadRequest& r, const WindowFeatures& features,\n    NavigationPolicy navigationPolicy)\n{\n    if (!m_webView->client())\n        return nullptr;\n\n    if (!frame->page() || frame->page()->defersLoading())\n        return nullptr;\n\n    WebNavigationPolicy policy = effectiveNavigationPolicy(navigationPolicy, features);\n    DCHECK(frame->document());\n    Fullscreen::fullyExitFullscreen(*frame->document());\n\n    WebViewImpl* newView = toWebViewImpl(\n        m_webView->client()->createView(WebLocalFrameImpl::fromFrame(frame), WrappedResourceRequest(r.resourceRequest()), features, r.frameName(), policy, r.getShouldSetOpener() == NeverSetOpener || features.noopener));\n    if (!newView)\n        return nullptr;\n    return newView->page();\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,6 +2,9 @@\n     NavigationPolicy navigationPolicy)\n {\n     if (!m_webView->client())\n+        return nullptr;\n+\n+    if (!frame->page() || frame->page()->defersLoading())\n         return nullptr;\n \n     WebNavigationPolicy policy = effectiveNavigationPolicy(navigationPolicy, features);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "        return nullptr;",
                "",
                "    if (!frame->page() || frame->page()->defersLoading())"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-1711",
        "func_name": "chromium/FrameLoader::detachDocumentLoader",
        "description": "WebKit/Source/core/loader/FrameLoader.cpp in Blink, as used in Google Chrome before 52.0.2743.82, does not disable frame navigation during a detach operation on a DocumentLoader object, which allows remote attackers to bypass the Same Origin Policy via a crafted web site.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/be655fd4fb9ab3291a855a939496111674037a2f",
        "commit_title": "Always use FrameNavigationDisabler during DocumentLoader detach.",
        "commit_text": "  Review-Url: https://codereview.chromium.org/2079473002 ",
        "func_before": "void FrameLoader::detachDocumentLoader(Member<DocumentLoader>& loader)\n{\n    if (!loader)\n        return;\n\n    loader->detachFromFrame();\n    loader = nullptr;\n}",
        "func": "void FrameLoader::detachDocumentLoader(Member<DocumentLoader>& loader)\n{\n    if (!loader)\n        return;\n\n    FrameNavigationDisabler navigationDisabler(*m_frame);\n    loader->detachFromFrame();\n    loader = nullptr;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,6 +3,7 @@\n     if (!loader)\n         return;\n \n+    FrameNavigationDisabler navigationDisabler(*m_frame);\n     loader->detachFromFrame();\n     loader = nullptr;\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    FrameNavigationDisabler navigationDisabler(*m_frame);"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-1711",
        "func_name": "chromium/FrameLoader::prepareForCommit",
        "description": "WebKit/Source/core/loader/FrameLoader.cpp in Blink, as used in Google Chrome before 52.0.2743.82, does not disable frame navigation during a detach operation on a DocumentLoader object, which allows remote attackers to bypass the Same Origin Policy via a crafted web site.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/be655fd4fb9ab3291a855a939496111674037a2f",
        "commit_title": "Always use FrameNavigationDisabler during DocumentLoader detach.",
        "commit_text": "  Review-Url: https://codereview.chromium.org/2079473002 ",
        "func_before": "bool FrameLoader::prepareForCommit()\n{\n    PluginScriptForbiddenScope forbidPluginDestructorScripting;\n    DocumentLoader* pdl = m_provisionalDocumentLoader;\n\n    if (m_frame->document()) {\n        unsigned nodeCount = 0;\n        for (Frame* frame = m_frame; frame; frame = frame->tree().traverseNext()) {\n            if (frame->isLocalFrame()) {\n                LocalFrame* localFrame = toLocalFrame(frame);\n                nodeCount += localFrame->document()->nodeCount();\n            }\n        }\n        unsigned totalNodeCount = InstanceCounters::counterValue(InstanceCounters::NodeCounter);\n        float ratio = static_cast<float>(nodeCount) / totalNodeCount;\n        ThreadState::current()->schedulePageNavigationGCIfNeeded(ratio);\n    }\n\n    // Don't allow any new child frames to load in this frame: attaching a new\n    // child frame during or after detaching children results in an attached\n    // frame on a detached DOM tree, which is bad.\n    SubframeLoadingDisabler disabler(m_frame->document());\n    if (m_documentLoader) {\n        client()->dispatchWillClose();\n        dispatchUnloadEvent();\n    }\n    m_frame->detachChildren();\n    // The previous calls to dispatchUnloadEvent() and detachChildren() can\n    // execute arbitrary script via things like unload events. If the executed\n    // script intiates a new load or causes the current frame to be detached,\n    // we need to abandon the current load.\n    if (pdl != m_provisionalDocumentLoader)\n        return false;\n    // detachFromFrame() will abort XHRs that haven't completed, which can\n    // trigger event listeners for 'abort'. These event listeners might call\n    // window.stop(), which will in turn detach the provisional document loader.\n    // At this point, the provisional document loader should not detach, because\n    // then the FrameLoader would not have any attached DocumentLoaders.\n    if (m_documentLoader) {\n        FrameNavigationDisabler navigationDisabler(*m_frame);\n        TemporaryChange<bool> inDetachDocumentLoader(m_protectProvisionalLoader, true);\n        detachDocumentLoader(m_documentLoader);\n    }\n    // 'abort' listeners can also detach the frame.\n    if (!m_frame->client())\n        return false;\n    ASSERT(m_provisionalDocumentLoader == pdl);\n    // No more events will be dispatched so detach the Document.\n    // TODO(yoav): Should we also be nullifying domWindow's document (or domWindow) since the doc is now detached?\n    if (m_frame->document())\n        m_frame->document()->detach();\n    m_documentLoader = m_provisionalDocumentLoader.release();\n    takeObjectSnapshot();\n\n    return true;\n}",
        "func": "bool FrameLoader::prepareForCommit()\n{\n    PluginScriptForbiddenScope forbidPluginDestructorScripting;\n    DocumentLoader* pdl = m_provisionalDocumentLoader;\n\n    if (m_frame->document()) {\n        unsigned nodeCount = 0;\n        for (Frame* frame = m_frame; frame; frame = frame->tree().traverseNext()) {\n            if (frame->isLocalFrame()) {\n                LocalFrame* localFrame = toLocalFrame(frame);\n                nodeCount += localFrame->document()->nodeCount();\n            }\n        }\n        unsigned totalNodeCount = InstanceCounters::counterValue(InstanceCounters::NodeCounter);\n        float ratio = static_cast<float>(nodeCount) / totalNodeCount;\n        ThreadState::current()->schedulePageNavigationGCIfNeeded(ratio);\n    }\n\n    // Don't allow any new child frames to load in this frame: attaching a new\n    // child frame during or after detaching children results in an attached\n    // frame on a detached DOM tree, which is bad.\n    SubframeLoadingDisabler disabler(m_frame->document());\n    if (m_documentLoader) {\n        client()->dispatchWillClose();\n        dispatchUnloadEvent();\n    }\n    m_frame->detachChildren();\n    // The previous calls to dispatchUnloadEvent() and detachChildren() can\n    // execute arbitrary script via things like unload events. If the executed\n    // script intiates a new load or causes the current frame to be detached,\n    // we need to abandon the current load.\n    if (pdl != m_provisionalDocumentLoader)\n        return false;\n    // detachFromFrame() will abort XHRs that haven't completed, which can\n    // trigger event listeners for 'abort'. These event listeners might call\n    // window.stop(), which will in turn detach the provisional document loader.\n    // At this point, the provisional document loader should not detach, because\n    // then the FrameLoader would not have any attached DocumentLoaders.\n    if (m_documentLoader) {\n        TemporaryChange<bool> inDetachDocumentLoader(m_protectProvisionalLoader, true);\n        detachDocumentLoader(m_documentLoader);\n    }\n    // 'abort' listeners can also detach the frame.\n    if (!m_frame->client())\n        return false;\n    ASSERT(m_provisionalDocumentLoader == pdl);\n    // No more events will be dispatched so detach the Document.\n    // TODO(yoav): Should we also be nullifying domWindow's document (or domWindow) since the doc is now detached?\n    if (m_frame->document())\n        m_frame->document()->detach();\n    m_documentLoader = m_provisionalDocumentLoader.release();\n    takeObjectSnapshot();\n\n    return true;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -37,7 +37,6 @@\n     // At this point, the provisional document loader should not detach, because\n     // then the FrameLoader would not have any attached DocumentLoaders.\n     if (m_documentLoader) {\n-        FrameNavigationDisabler navigationDisabler(*m_frame);\n         TemporaryChange<bool> inDetachDocumentLoader(m_protectProvisionalLoader, true);\n         detachDocumentLoader(m_documentLoader);\n     }",
        "diff_line_info": {
            "deleted_lines": [
                "        FrameNavigationDisabler navigationDisabler(*m_frame);"
            ],
            "added_lines": []
        }
    },
    {
        "cve_id": "CVE-2016-1711",
        "func_name": "chromium/FrameLoader::startLoad",
        "description": "WebKit/Source/core/loader/FrameLoader.cpp in Blink, as used in Google Chrome before 52.0.2743.82, does not disable frame navigation during a detach operation on a DocumentLoader object, which allows remote attackers to bypass the Same Origin Policy via a crafted web site.",
        "git_url": "https://chromium.googlesource.com/chromium/src/+/be655fd4fb9ab3291a855a939496111674037a2f",
        "commit_title": "Always use FrameNavigationDisabler during DocumentLoader detach.",
        "commit_text": "  Review-Url: https://codereview.chromium.org/2079473002 ",
        "func_before": "void FrameLoader::startLoad(FrameLoadRequest& frameLoadRequest, FrameLoadType type, NavigationPolicy navigationPolicy)\n{\n    ASSERT(client()->hasWebView());\n    if (m_frame->document()->pageDismissalEventBeingDispatched() != Document::NoDismissal)\n        return;\n\n    NavigationType navigationType = determineNavigationType(type, frameLoadRequest.resourceRequest().httpBody() || frameLoadRequest.form(), frameLoadRequest.triggeringEvent());\n    frameLoadRequest.resourceRequest().setRequestContext(determineRequestContextFromNavigationType(navigationType));\n    frameLoadRequest.resourceRequest().setFrameType(m_frame->isMainFrame() ? WebURLRequest::FrameTypeTopLevel : WebURLRequest::FrameTypeNested);\n    ResourceRequest& request = frameLoadRequest.resourceRequest();\n    if (!shouldContinueForNavigationPolicy(request, frameLoadRequest.substituteData(), nullptr, frameLoadRequest.shouldCheckMainWorldContentSecurityPolicy(), navigationType, navigationPolicy, type == FrameLoadTypeReplaceCurrentItem, frameLoadRequest.clientRedirect() == ClientRedirectPolicy::ClientRedirect))\n        return;\n\n    m_frame->document()->cancelParsing();\n    if (m_provisionalDocumentLoader) {\n        FrameNavigationDisabler navigationDisabler(*m_frame);\n        detachDocumentLoader(m_provisionalDocumentLoader);\n    }\n\n    // beforeunload fired above, and detaching a DocumentLoader can fire\n    // events, which can detach this frame.\n    if (!m_frame->host())\n        return;\n\n    m_provisionalDocumentLoader = client()->createDocumentLoader(m_frame, request, frameLoadRequest.substituteData().isValid() ? frameLoadRequest.substituteData() : defaultSubstituteDataForURL(request.url()));\n    m_provisionalDocumentLoader->setNavigationType(navigationType);\n    m_provisionalDocumentLoader->setReplacesCurrentHistoryItem(type == FrameLoadTypeReplaceCurrentItem);\n    m_provisionalDocumentLoader->setIsClientRedirect(frameLoadRequest.clientRedirect() == ClientRedirectPolicy::ClientRedirect);\n\n    InspectorInstrumentation::didStartProvisionalLoad(m_frame);\n\n    m_frame->navigationScheduler().cancel();\n    m_checkTimer.stop();\n\n    m_loadType = type;\n\n    if (frameLoadRequest.form())\n        client()->dispatchWillSubmitForm(frameLoadRequest.form());\n\n    m_progressTracker->progressStarted();\n    if (m_provisionalDocumentLoader->isClientRedirect())\n        m_provisionalDocumentLoader->appendRedirect(m_frame->document()->url());\n    m_provisionalDocumentLoader->appendRedirect(m_provisionalDocumentLoader->request().url());\n    double triggeringEventTime = frameLoadRequest.triggeringEvent() ? frameLoadRequest.triggeringEvent()->platformTimeStamp() : 0;\n    client()->dispatchDidStartProvisionalLoad(triggeringEventTime);\n    ASSERT(m_provisionalDocumentLoader);\n    m_provisionalDocumentLoader->startLoadingMainResource();\n\n    takeObjectSnapshot();\n}",
        "func": "void FrameLoader::startLoad(FrameLoadRequest& frameLoadRequest, FrameLoadType type, NavigationPolicy navigationPolicy)\n{\n    ASSERT(client()->hasWebView());\n    if (m_frame->document()->pageDismissalEventBeingDispatched() != Document::NoDismissal)\n        return;\n\n    NavigationType navigationType = determineNavigationType(type, frameLoadRequest.resourceRequest().httpBody() || frameLoadRequest.form(), frameLoadRequest.triggeringEvent());\n    frameLoadRequest.resourceRequest().setRequestContext(determineRequestContextFromNavigationType(navigationType));\n    frameLoadRequest.resourceRequest().setFrameType(m_frame->isMainFrame() ? WebURLRequest::FrameTypeTopLevel : WebURLRequest::FrameTypeNested);\n    ResourceRequest& request = frameLoadRequest.resourceRequest();\n    if (!shouldContinueForNavigationPolicy(request, frameLoadRequest.substituteData(), nullptr, frameLoadRequest.shouldCheckMainWorldContentSecurityPolicy(), navigationType, navigationPolicy, type == FrameLoadTypeReplaceCurrentItem, frameLoadRequest.clientRedirect() == ClientRedirectPolicy::ClientRedirect))\n        return;\n\n    m_frame->document()->cancelParsing();\n    detachDocumentLoader(m_provisionalDocumentLoader);\n\n    // beforeunload fired above, and detaching a DocumentLoader can fire\n    // events, which can detach this frame.\n    if (!m_frame->host())\n        return;\n\n    m_provisionalDocumentLoader = client()->createDocumentLoader(m_frame, request, frameLoadRequest.substituteData().isValid() ? frameLoadRequest.substituteData() : defaultSubstituteDataForURL(request.url()));\n    m_provisionalDocumentLoader->setNavigationType(navigationType);\n    m_provisionalDocumentLoader->setReplacesCurrentHistoryItem(type == FrameLoadTypeReplaceCurrentItem);\n    m_provisionalDocumentLoader->setIsClientRedirect(frameLoadRequest.clientRedirect() == ClientRedirectPolicy::ClientRedirect);\n\n    InspectorInstrumentation::didStartProvisionalLoad(m_frame);\n\n    m_frame->navigationScheduler().cancel();\n    m_checkTimer.stop();\n\n    m_loadType = type;\n\n    if (frameLoadRequest.form())\n        client()->dispatchWillSubmitForm(frameLoadRequest.form());\n\n    m_progressTracker->progressStarted();\n    if (m_provisionalDocumentLoader->isClientRedirect())\n        m_provisionalDocumentLoader->appendRedirect(m_frame->document()->url());\n    m_provisionalDocumentLoader->appendRedirect(m_provisionalDocumentLoader->request().url());\n    double triggeringEventTime = frameLoadRequest.triggeringEvent() ? frameLoadRequest.triggeringEvent()->platformTimeStamp() : 0;\n    client()->dispatchDidStartProvisionalLoad(triggeringEventTime);\n    ASSERT(m_provisionalDocumentLoader);\n    m_provisionalDocumentLoader->startLoadingMainResource();\n\n    takeObjectSnapshot();\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -12,10 +12,7 @@\n         return;\n \n     m_frame->document()->cancelParsing();\n-    if (m_provisionalDocumentLoader) {\n-        FrameNavigationDisabler navigationDisabler(*m_frame);\n-        detachDocumentLoader(m_provisionalDocumentLoader);\n-    }\n+    detachDocumentLoader(m_provisionalDocumentLoader);\n \n     // beforeunload fired above, and detaching a DocumentLoader can fire\n     // events, which can detach this frame.",
        "diff_line_info": {
            "deleted_lines": [
                "    if (m_provisionalDocumentLoader) {",
                "        FrameNavigationDisabler navigationDisabler(*m_frame);",
                "        detachDocumentLoader(m_provisionalDocumentLoader);",
                "    }"
            ],
            "added_lines": [
                "    detachDocumentLoader(m_provisionalDocumentLoader);"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-7143",
        "func_name": "charybdis-ircd/charybdis/m_authenticate",
        "description": "The m_authenticate function in modules/m_sasl.c in Charybdis before 3.5.3 allows remote attackers to spoof certificate fingerprints and consequently log in as another user via a crafted AUTHENTICATE parameter.",
        "git_url": "https://github.com/charybdis-ircd/charybdis/commit/818a3fda944b26d4814132cee14cfda4ea4aa824",
        "commit_title": "SASL: Disallow beginning : and space anywhere in AUTHENTICATE parameter",
        "commit_text": " This is a FIX FOR A SECURITY VULNERABILITY. All Charybdis users must apply this fix if you support SASL on your servers, or unload m_sasl.so in the meantime.",
        "func_before": "static int\nm_authenticate(struct Client *client_p, struct Client *source_p,\n\tint parc, const char *parv[])\n{\n\tstruct Client *agent_p = NULL;\n\tstruct Client *saslserv_p = NULL;\n\n\t/* They really should use CAP for their own sake. */\n\tif(!IsCapable(source_p, CLICAP_SASL))\n\t\treturn 0;\n\n\tif (strlen(client_p->id) == 3)\n\t{\n\t\texit_client(client_p, client_p, client_p, \"Mixing client and server protocol\");\n\t\treturn 0;\n\t}\n\n\tsaslserv_p = find_named_client(ConfigFileEntry.sasl_service);\n\tif (saslserv_p == NULL || !IsService(saslserv_p))\n\t{\n\t\tsendto_one(source_p, form_str(ERR_SASLABORTED), me.name, EmptyString(source_p->name) ? \"*\" : source_p->name);\n\t\treturn 0;\n\t}\n\n\tif(source_p->localClient->sasl_complete)\n\t{\n\t\t*source_p->localClient->sasl_agent = '\\0';\n\t\tsource_p->localClient->sasl_complete = 0;\n\t}\n\n\tif(strlen(parv[1]) > 400)\n\t{\n\t\tsendto_one(source_p, form_str(ERR_SASLTOOLONG), me.name, EmptyString(source_p->name) ? \"*\" : source_p->name);\n\t\treturn 0;\n\t}\n\n\tif(!*source_p->id)\n\t{\n\t\t/* Allocate a UID. */\n\t\tstrcpy(source_p->id, generate_uid());\n\t\tadd_to_id_hash(source_p->id, source_p);\n\t}\n\n\tif(*source_p->localClient->sasl_agent)\n\t\tagent_p = find_id(source_p->localClient->sasl_agent);\n\n\tif(agent_p == NULL)\n\t{\n\t\tsendto_one(saslserv_p, \":%s ENCAP %s SASL %s %s H %s %s\",\n\t\t\t\t\tme.id, saslserv_p->servptr->name, source_p->id, saslserv_p->id,\n\t\t\t\t\tsource_p->host, source_p->sockhost);\n\n\t\tif (!strcmp(parv[1], \"EXTERNAL\") && source_p->certfp != NULL)\n\t\t\tsendto_one(saslserv_p, \":%s ENCAP %s SASL %s %s S %s %s\",\n\t\t\t\t\t\tme.id, saslserv_p->servptr->name, source_p->id, saslserv_p->id,\n\t\t\t\t\t\tparv[1], source_p->certfp);\n\t\telse\n\t\t\tsendto_one(saslserv_p, \":%s ENCAP %s SASL %s %s S %s\",\n\t\t\t\t\t\tme.id, saslserv_p->servptr->name, source_p->id, saslserv_p->id,\n\t\t\t\t\t\tparv[1]);\n\n\t\trb_strlcpy(source_p->localClient->sasl_agent, saslserv_p->id, IDLEN);\n\t}\n\telse\n\t\tsendto_one(agent_p, \":%s ENCAP %s SASL %s %s C %s\",\n\t\t\t\tme.id, agent_p->servptr->name, source_p->id, agent_p->id,\n\t\t\t\tparv[1]);\n\tsource_p->localClient->sasl_out++;\n\n\treturn 0;\n}",
        "func": "static int\nm_authenticate(struct Client *client_p, struct Client *source_p,\n\tint parc, const char *parv[])\n{\n\tstruct Client *agent_p = NULL;\n\tstruct Client *saslserv_p = NULL;\n\n\t/* They really should use CAP for their own sake. */\n\tif(!IsCapable(source_p, CLICAP_SASL))\n\t\treturn 0;\n\n\tif (strlen(client_p->id) == 3)\n\t{\n\t\texit_client(client_p, client_p, client_p, \"Mixing client and server protocol\");\n\t\treturn 0;\n\t}\n\n\tif (*parv[1] == ':' || strchr(parv[1], ' '))\n\t{\n\t\texit_client(client_p, client_p, client_p, \"Malformed AUTHENTICATE\");\n\t\treturn 0;\n\t}\n\n\tsaslserv_p = find_named_client(ConfigFileEntry.sasl_service);\n\tif (saslserv_p == NULL || !IsService(saslserv_p))\n\t{\n\t\tsendto_one(source_p, form_str(ERR_SASLABORTED), me.name, EmptyString(source_p->name) ? \"*\" : source_p->name);\n\t\treturn 0;\n\t}\n\n\tif(source_p->localClient->sasl_complete)\n\t{\n\t\t*source_p->localClient->sasl_agent = '\\0';\n\t\tsource_p->localClient->sasl_complete = 0;\n\t}\n\n\tif(strlen(parv[1]) > 400)\n\t{\n\t\tsendto_one(source_p, form_str(ERR_SASLTOOLONG), me.name, EmptyString(source_p->name) ? \"*\" : source_p->name);\n\t\treturn 0;\n\t}\n\n\tif(!*source_p->id)\n\t{\n\t\t/* Allocate a UID. */\n\t\tstrcpy(source_p->id, generate_uid());\n\t\tadd_to_id_hash(source_p->id, source_p);\n\t}\n\n\tif(*source_p->localClient->sasl_agent)\n\t\tagent_p = find_id(source_p->localClient->sasl_agent);\n\n\tif(agent_p == NULL)\n\t{\n\t\tsendto_one(saslserv_p, \":%s ENCAP %s SASL %s %s H %s %s\",\n\t\t\t\t\tme.id, saslserv_p->servptr->name, source_p->id, saslserv_p->id,\n\t\t\t\t\tsource_p->host, source_p->sockhost);\n\n\t\tif (!strcmp(parv[1], \"EXTERNAL\") && source_p->certfp != NULL)\n\t\t\tsendto_one(saslserv_p, \":%s ENCAP %s SASL %s %s S %s %s\",\n\t\t\t\t\t\tme.id, saslserv_p->servptr->name, source_p->id, saslserv_p->id,\n\t\t\t\t\t\tparv[1], source_p->certfp);\n\t\telse\n\t\t\tsendto_one(saslserv_p, \":%s ENCAP %s SASL %s %s S %s\",\n\t\t\t\t\t\tme.id, saslserv_p->servptr->name, source_p->id, saslserv_p->id,\n\t\t\t\t\t\tparv[1]);\n\n\t\trb_strlcpy(source_p->localClient->sasl_agent, saslserv_p->id, IDLEN);\n\t}\n\telse\n\t\tsendto_one(agent_p, \":%s ENCAP %s SASL %s %s C %s\",\n\t\t\t\tme.id, agent_p->servptr->name, source_p->id, agent_p->id,\n\t\t\t\tparv[1]);\n\tsource_p->localClient->sasl_out++;\n\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -12,6 +12,12 @@\n \tif (strlen(client_p->id) == 3)\n \t{\n \t\texit_client(client_p, client_p, client_p, \"Mixing client and server protocol\");\n+\t\treturn 0;\n+\t}\n+\n+\tif (*parv[1] == ':' || strchr(parv[1], ' '))\n+\t{\n+\t\texit_client(client_p, client_p, client_p, \"Malformed AUTHENTICATE\");\n \t\treturn 0;\n \t}\n ",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\treturn 0;",
                "\t}",
                "",
                "\tif (*parv[1] == ':' || strchr(parv[1], ' '))",
                "\t{",
                "\t\texit_client(client_p, client_p, client_p, \"Malformed AUTHENTICATE\");"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-7035",
        "func_name": "ClusterLabs/pacemaker/crm_client_new",
        "description": "An authorization flaw was found in Pacemaker before 1.1.16, where it did not properly guard its IPC interface. An attacker with an unprivileged account on a Pacemaker node could use this flaw to, for example, force the Local Resource Manager daemon to execute a script as root and thereby gain root access on the machine.",
        "git_url": "https://github.com/ClusterLabs/pacemaker/commit/5d71e65049d143435b03d6b3709d82900f32276f",
        "commit_title": "High: libcrmcommon: fix CVE-2016-7035 (improper IPC guarding)",
        "commit_text": " It was discovered that at some not so uncommon circumstances, some pacemaker daemons could be talked to, via libqb-facilitated IPC, by unprivileged clients due to flawed authorization decision.  Depending on the capabilities of affected daemons, this might equip unauthorized user with local privilege escalation or up to cluster-wide remote execution of possibly arbitrary commands when such user happens to reside at standard or remote/guest cluster node, respectively.  The original vulnerability was introduced in an attempt to allow unprivileged IPC clients to clean up the file system materialized leftovers in case the server (otherwise responsible for the lifecycle of these files) crashes.  While the intended part of such behavior is now effectively voided (along with the unintended one), a best-effort fix to address this corner case systemically at libqb is coming along (https://github.com/ClusterLabs/libqb/pull/231).  Affected versions:  1.1.10-rc1 (2013-04-17) - 1.1.15 (2016-06-21) Impact:             Important CVSSv3 ranking:     8.8 : AV:L/AC:L/PR:L/UI:N/S:C/C:H/I:H/A:H  Credits for independent findings, in chronological order:   Jan \"poki\" Pokorn√Ω, of Red Hat   Alain Moulle, of ATOS/BULL",
        "func_before": "crm_client_t *\ncrm_client_new(qb_ipcs_connection_t * c, uid_t uid_client, gid_t gid_client)\n{\n    static uid_t uid_server = 0;\n    static gid_t gid_cluster = 0;\n\n    crm_client_t *client = NULL;\n\n    CRM_LOG_ASSERT(c);\n    if (c == NULL) {\n        return NULL;\n    }\n\n    if (gid_cluster == 0) {\n        uid_server = getuid();\n        if(crm_user_lookup(CRM_DAEMON_USER, NULL, &gid_cluster) < 0) {\n            static bool have_error = FALSE;\n            if(have_error == FALSE) {\n                crm_warn(\"Could not find group for user %s\", CRM_DAEMON_USER);\n                have_error = TRUE;\n            }\n        }\n    }\n\n    if(gid_cluster != 0 && gid_client != 0) {\n        uid_t best_uid = -1; /* Passing -1 to chown(2) means don't change */\n\n        if(uid_client == 0 || uid_server == 0) { /* Someone is priveliged, but the other may not be */\n            best_uid = QB_MAX(uid_client, uid_server);\n            crm_trace(\"Allowing user %u to clean up after disconnect\", best_uid);\n        }\n\n        crm_trace(\"Giving access to group %u\", gid_cluster);\n        qb_ipcs_connection_auth_set(c, best_uid, gid_cluster, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP);\n    }\n\n    crm_client_init();\n\n    /* TODO: Do our own auth checking, return NULL if unauthorized */\n    client = calloc(1, sizeof(crm_client_t));\n\n    client->ipcs = c;\n    client->kind = CRM_CLIENT_IPC;\n    client->pid = crm_ipcs_client_pid(c);\n\n    client->id = crm_generate_uuid();\n\n    crm_debug(\"Connecting %p for uid=%d gid=%d pid=%u id=%s\", c, uid_client, gid_client, client->pid, client->id);\n\n#if ENABLE_ACL\n    client->user = uid2username(uid_client);\n#endif\n\n    g_hash_table_insert(client_connections, c, client);\n    return client;\n}",
        "func": "crm_client_t *\ncrm_client_new(qb_ipcs_connection_t * c, uid_t uid_client, gid_t gid_client)\n{\n    static gid_t gid_cluster = 0;\n\n    crm_client_t *client = NULL;\n\n    CRM_LOG_ASSERT(c);\n    if (c == NULL) {\n        return NULL;\n    }\n\n    if (gid_cluster == 0) {\n        if(crm_user_lookup(CRM_DAEMON_USER, NULL, &gid_cluster) < 0) {\n            static bool have_error = FALSE;\n            if(have_error == FALSE) {\n                crm_warn(\"Could not find group for user %s\", CRM_DAEMON_USER);\n                have_error = TRUE;\n            }\n        }\n    }\n\n    if (uid_client != 0) {\n        crm_trace(\"Giving access to group %u\", gid_cluster);\n        /* Passing -1 to chown(2) means don't change */\n        qb_ipcs_connection_auth_set(c, -1, gid_cluster, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP);\n    }\n\n    crm_client_init();\n\n    /* TODO: Do our own auth checking, return NULL if unauthorized */\n    client = calloc(1, sizeof(crm_client_t));\n\n    client->ipcs = c;\n    client->kind = CRM_CLIENT_IPC;\n    client->pid = crm_ipcs_client_pid(c);\n\n    client->id = crm_generate_uuid();\n\n    crm_debug(\"Connecting %p for uid=%d gid=%d pid=%u id=%s\", c, uid_client, gid_client, client->pid, client->id);\n\n#if ENABLE_ACL\n    client->user = uid2username(uid_client);\n#endif\n\n    g_hash_table_insert(client_connections, c, client);\n    return client;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,7 +1,6 @@\n crm_client_t *\n crm_client_new(qb_ipcs_connection_t * c, uid_t uid_client, gid_t gid_client)\n {\n-    static uid_t uid_server = 0;\n     static gid_t gid_cluster = 0;\n \n     crm_client_t *client = NULL;\n@@ -12,7 +11,6 @@\n     }\n \n     if (gid_cluster == 0) {\n-        uid_server = getuid();\n         if(crm_user_lookup(CRM_DAEMON_USER, NULL, &gid_cluster) < 0) {\n             static bool have_error = FALSE;\n             if(have_error == FALSE) {\n@@ -22,16 +20,10 @@\n         }\n     }\n \n-    if(gid_cluster != 0 && gid_client != 0) {\n-        uid_t best_uid = -1; /* Passing -1 to chown(2) means don't change */\n-\n-        if(uid_client == 0 || uid_server == 0) { /* Someone is priveliged, but the other may not be */\n-            best_uid = QB_MAX(uid_client, uid_server);\n-            crm_trace(\"Allowing user %u to clean up after disconnect\", best_uid);\n-        }\n-\n+    if (uid_client != 0) {\n         crm_trace(\"Giving access to group %u\", gid_cluster);\n-        qb_ipcs_connection_auth_set(c, best_uid, gid_cluster, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP);\n+        /* Passing -1 to chown(2) means don't change */\n+        qb_ipcs_connection_auth_set(c, -1, gid_cluster, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP);\n     }\n \n     crm_client_init();",
        "diff_line_info": {
            "deleted_lines": [
                "    static uid_t uid_server = 0;",
                "        uid_server = getuid();",
                "    if(gid_cluster != 0 && gid_client != 0) {",
                "        uid_t best_uid = -1; /* Passing -1 to chown(2) means don't change */",
                "",
                "        if(uid_client == 0 || uid_server == 0) { /* Someone is priveliged, but the other may not be */",
                "            best_uid = QB_MAX(uid_client, uid_server);",
                "            crm_trace(\"Allowing user %u to clean up after disconnect\", best_uid);",
                "        }",
                "",
                "        qb_ipcs_connection_auth_set(c, best_uid, gid_cluster, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP);"
            ],
            "added_lines": [
                "    if (uid_client != 0) {",
                "        /* Passing -1 to chown(2) means don't change */",
                "        qb_ipcs_connection_auth_set(c, -1, gid_cluster, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP);"
            ]
        }
    }
]