[
    {
        "cve_id": "CVE-2020-12278",
        "func_name": "libgit2/only_spaces_and_dots",
        "description": "An issue was discovered in libgit2 before 0.28.4 and 0.9x before 0.99.0. path.c mishandles equivalent filenames that exist because of NTFS Alternate Data Streams. This may allow remote code execution when cloning a repository. This issue is similar to CVE-2019-1352.",
        "git_url": "https://github.com/libgit2/libgit2/commit/e1832eb20a7089f6383cfce474f213157f5300cb",
        "commit_title": "path: also guard `.gitmodules` against NTFS Alternate Data Streams",
        "commit_text": " We just safe-guarded `.git` against NTFS Alternate Data Stream-related attack vectors, and now it is time to do the same for `.gitmodules`.  Note: In the added regression test, we refrain from verifying all kinds of variations between short names and NTFS Alternate Data Streams: as the new code disallows _all_ Alternate Data Streams of `.gitmodules`, it is enough to test one in order to know that all of them are guarded against. ",
        "func_before": "GIT_INLINE(bool) only_spaces_and_dots(const char *path)\n{\n\tconst char *c = path;\n\n\tfor (;; c++) {\n\t\tif (*c == '\\0')\n\t\t\treturn true;\n\t\tif (*c != ' ' && *c != '.')\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}",
        "func": "GIT_INLINE(bool) only_spaces_and_dots(const char *path)\n{\n\tconst char *c = path;\n\n\tfor (;; c++) {\n\t\tif (*c == '\\0' || *c == ':')\n\t\t\treturn true;\n\t\tif (*c != ' ' && *c != '.')\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,7 +3,7 @@\n \tconst char *c = path;\n \n \tfor (;; c++) {\n-\t\tif (*c == '\\0')\n+\t\tif (*c == '\\0' || *c == ':')\n \t\t\treturn true;\n \t\tif (*c != ' ' && *c != '.')\n \t\t\treturn false;",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tif (*c == '\\0')"
            ],
            "added_lines": [
                "\t\tif (*c == '\\0' || *c == ':')"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-12278",
        "func_name": "libgit2/verify_dotgit_ntfs",
        "description": "An issue was discovered in libgit2 before 0.28.4 and 0.9x before 0.99.0. path.c mishandles equivalent filenames that exist because of NTFS Alternate Data Streams. This may allow remote code execution when cloning a repository. This issue is similar to CVE-2019-1352.",
        "git_url": "https://github.com/libgit2/libgit2/commit/3f7851eadca36a99627ad78cbe56a40d3776ed01",
        "commit_title": "Disallow NTFS Alternate Data Stream attacks, even on Linux/macOS",
        "commit_text": " A little-known feature of NTFS is that it offers to store metadata in so-called \"Alternate Data Streams\" (inspired by Apple's \"resource forks\") that are copied together with the file they are associated with. These Alternate Data Streams can be accessed via `<file name>:<stream name>:<stream type>`.  Directories, too, have Alternate Data Streams, and they even have a default stream type `$INDEX_ALLOCATION`. Which means that `abc/` and `abc::$INDEX_ALLOCATION/` are actually equivalent.  This is of course another attack vector on the Git directory that we definitely want to prevent.  On Windows, we already do this incidentally, by disallowing colons in file/directory names.  While it looks as if files'/directories' Alternate Data Streams are not accessible in the Windows Subsystem for Linux, and neither via CIFS/SMB-mounted network shares in Linux, it _is_ possible to access them on SMB-mounted network shares on macOS.  Therefore, let's go the extra mile and prevent this particular attack _everywhere_. To keep things simple, let's just disallow *any* Alternate Data Stream of `.git`.  This is libgit2's variant of CVE-2019-1352. ",
        "func_before": "GIT_INLINE(bool) verify_dotgit_ntfs(git_repository *repo, const char *path, size_t len)\n{\n\tgit_buf *reserved = git_repository__reserved_names_win32;\n\tsize_t reserved_len = git_repository__reserved_names_win32_len;\n\tsize_t start = 0, i;\n\n\tif (repo)\n\t\tgit_repository__reserved_names(&reserved, &reserved_len, repo, true);\n\n\tfor (i = 0; i < reserved_len; i++) {\n\t\tgit_buf *r = &reserved[i];\n\n\t\tif (len >= r->size &&\n\t\t\tstrncasecmp(path, r->ptr, r->size) == 0) {\n\t\t\tstart = r->size;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!start)\n\t\treturn true;\n\n\t/* Reject paths like \".git\\\" */\n\tif (path[start] == '\\\\')\n\t\treturn false;\n\n\t/* Reject paths like '.git ' or '.git.' */\n\tfor (i = start; i < len; i++) {\n\t\tif (path[i] != ' ' && path[i] != '.')\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
        "func": "GIT_INLINE(bool) verify_dotgit_ntfs(git_repository *repo, const char *path, size_t len)\n{\n\tgit_buf *reserved = git_repository__reserved_names_win32;\n\tsize_t reserved_len = git_repository__reserved_names_win32_len;\n\tsize_t start = 0, i;\n\n\tif (repo)\n\t\tgit_repository__reserved_names(&reserved, &reserved_len, repo, true);\n\n\tfor (i = 0; i < reserved_len; i++) {\n\t\tgit_buf *r = &reserved[i];\n\n\t\tif (len >= r->size &&\n\t\t\tstrncasecmp(path, r->ptr, r->size) == 0) {\n\t\t\tstart = r->size;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!start)\n\t\treturn true;\n\n\t/*\n\t * Reject paths that start with Windows-style directory separators\n\t * (\".git\\\") or NTFS alternate streams (\".git:\") and could be used\n\t * to write to the \".git\" directory on Windows platforms.\n\t */\n\tif (path[start] == '\\\\' || path[start] == ':')\n\t\treturn false;\n\n\t/* Reject paths like '.git ' or '.git.' */\n\tfor (i = start; i < len; i++) {\n\t\tif (path[i] != ' ' && path[i] != '.')\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -20,8 +20,12 @@\n \tif (!start)\n \t\treturn true;\n \n-\t/* Reject paths like \".git\\\" */\n-\tif (path[start] == '\\\\')\n+\t/*\n+\t * Reject paths that start with Windows-style directory separators\n+\t * (\".git\\\") or NTFS alternate streams (\".git:\") and could be used\n+\t * to write to the \".git\" directory on Windows platforms.\n+\t */\n+\tif (path[start] == '\\\\' || path[start] == ':')\n \t\treturn false;\n \n \t/* Reject paths like '.git ' or '.git.' */",
        "diff_line_info": {
            "deleted_lines": [
                "\t/* Reject paths like \".git\\\" */",
                "\tif (path[start] == '\\\\')"
            ],
            "added_lines": [
                "\t/*",
                "\t * Reject paths that start with Windows-style directory separators",
                "\t * (\".git\\\") or NTFS alternate streams (\".git:\") and could be used",
                "\t * to write to the \".git\" directory on Windows platforms.",
                "\t */",
                "\tif (path[start] == '\\\\' || path[start] == ':')"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-12279",
        "func_name": "libgit2/checkout_verify_paths",
        "description": "An issue was discovered in libgit2 before 0.28.4 and 0.9x before 0.99.0. checkout.c mishandles equivalent filenames that exist because of NTFS short names. This may allow remote code execution when cloning a repository. This issue is similar to CVE-2019-1353.",
        "git_url": "https://github.com/libgit2/libgit2/commit/64c612cc3e25eff5fb02c59ef5a66ba7a14751e4",
        "commit_title": "Protect against 8.3 \"short name\" attacks also on Linux/macOS",
        "commit_text": " The Windows Subsystem for Linux (WSL) is getting increasingly popular, in particular because it makes it _so_ easy to run Linux software on Windows' files, via the auto-mounted Windows drives (`C:\\` is mapped to `/mnt/c/`, no need to set that up manually).  Unfortunately, files/directories on the Windows drives can be accessed via their _short names_, if that feature is enabled (which it is on the `C:` drive by default).  Which means that we have to safeguard even our Linux users against the short name attacks.  Further, while the default options of CIFS/SMB-mounts seem to disallow accessing files on network shares via their short names on Linux/macOS, it _is_ possible to do so with the right options.  So let's just safe-guard against short name attacks _everywhere_. ",
        "func_before": "static int checkout_verify_paths(\n\tgit_repository *repo,\n\tint action,\n\tgit_diff_delta *delta)\n{\n\tunsigned int flags = GIT_PATH_REJECT_WORKDIR_DEFAULTS;\n\n\tif (action & CHECKOUT_ACTION__REMOVE) {\n\t\tif (!git_path_isvalid(repo, delta->old_file.path, delta->old_file.mode, flags)) {\n\t\t\tgit_error_set(GIT_ERROR_CHECKOUT, \"cannot remove invalid path '%s'\", delta->old_file.path);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (action & ~CHECKOUT_ACTION__REMOVE) {\n\t\tif (!git_path_isvalid(repo, delta->new_file.path, delta->new_file.mode, flags)) {\n\t\t\tgit_error_set(GIT_ERROR_CHECKOUT, \"cannot checkout to invalid path '%s'\", delta->new_file.path);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}",
        "func": "static int checkout_verify_paths(\n\tgit_repository *repo,\n\tint action,\n\tgit_diff_delta *delta)\n{\n\tunsigned int flags = GIT_PATH_REJECT_WORKDIR_DEFAULTS | GIT_PATH_REJECT_DOT_GIT_NTFS;\n\n\tif (action & CHECKOUT_ACTION__REMOVE) {\n\t\tif (!git_path_isvalid(repo, delta->old_file.path, delta->old_file.mode, flags)) {\n\t\t\tgit_error_set(GIT_ERROR_CHECKOUT, \"cannot remove invalid path '%s'\", delta->old_file.path);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif (action & ~CHECKOUT_ACTION__REMOVE) {\n\t\tif (!git_path_isvalid(repo, delta->new_file.path, delta->new_file.mode, flags)) {\n\t\t\tgit_error_set(GIT_ERROR_CHECKOUT, \"cannot checkout to invalid path '%s'\", delta->new_file.path);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,7 +3,7 @@\n \tint action,\n \tgit_diff_delta *delta)\n {\n-\tunsigned int flags = GIT_PATH_REJECT_WORKDIR_DEFAULTS;\n+\tunsigned int flags = GIT_PATH_REJECT_WORKDIR_DEFAULTS | GIT_PATH_REJECT_DOT_GIT_NTFS;\n \n \tif (action & CHECKOUT_ACTION__REMOVE) {\n \t\tif (!git_path_isvalid(repo, delta->old_file.path, delta->old_file.mode, flags)) {",
        "diff_line_info": {
            "deleted_lines": [
                "\tunsigned int flags = GIT_PATH_REJECT_WORKDIR_DEFAULTS;"
            ],
            "added_lines": [
                "\tunsigned int flags = GIT_PATH_REJECT_WORKDIR_DEFAULTS | GIT_PATH_REJECT_DOT_GIT_NTFS;"
            ]
        }
    }
]