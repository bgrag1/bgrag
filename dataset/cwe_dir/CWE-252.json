[
    {
        "cve_id": "CVE-2019-12107",
        "func_name": "miniupnp/upnp_event_prepare",
        "description": "The upnp_event_prepare function in upnpevents.c in MiniUPnP MiniUPnPd through 2.1 allows a remote attacker to leak information from the heap due to improper validation of an snprintf return value.",
        "git_url": "https://github.com/miniupnp/miniupnp/commit/bec6ccec63cadc95655721bc0e1dd49dac759d94",
        "commit_title": "upnp_event_prepare(): check the return value of snprintf()",
        "commit_text": "",
        "func_before": "static void upnp_event_prepare(struct upnp_event_notify * obj)\n{\n\tstatic const char notifymsg[] =\n\t\t\"NOTIFY %s HTTP/1.1\\r\\n\"\n\t\t\"Host: %s%s\\r\\n\"\n#if (UPNP_VERSION_MAJOR == 1) && (UPNP_VERSION_MINOR == 0)\n\t\t\"Content-Type: text/xml\\r\\n\"\t/* UDA v1.0 */\n#else\n\t\t\"Content-Type: text/xml; charset=\\\"utf-8\\\"\\r\\n\"\t/* UDA v1.1 or later */\n#endif\n\t\t\"Content-Length: %d\\r\\n\"\n\t\t\"NT: upnp:event\\r\\n\"\n\t\t\"NTS: upnp:propchange\\r\\n\"\n\t\t\"SID: %s\\r\\n\"\n\t\t\"SEQ: %u\\r\\n\"\n\t\t\"Connection: close\\r\\n\"\n\t\t\"Cache-Control: no-cache\\r\\n\"\n\t\t\"\\r\\n\"\n\t\t\"%.*s\\r\\n\";\n\tchar * xml;\n\tint l;\n\tif(obj->sub == NULL) {\n\t\tobj->state = EError;\n\t\treturn;\n\t}\n\tswitch(obj->sub->service) {\n\tcase EWanCFG:\n\t\txml = getVarsWANCfg(&l);\n\t\tbreak;\n\tcase EWanIPC:\n\t\txml = getVarsWANIPCn(&l);\n\t\tbreak;\n#ifdef ENABLE_L3F_SERVICE\n\tcase EL3F:\n\t\txml = getVarsL3F(&l);\n\t\tbreak;\n#endif\n#ifdef ENABLE_6FC_SERVICE\n\tcase E6FC:\n\t\txml = getVars6FC(&l);\n\t\tbreak;\n#endif\n#ifdef ENABLE_DP_SERVICE\n\tcase EDP:\n\t\txml = getVarsDP(&l);\n\t\tbreak;\n#endif\n\tdefault:\n\t\txml = NULL;\n\t\tl = 0;\n\t}\n\tobj->buffersize = 1024;\n\tobj->buffer = malloc(obj->buffersize);\n\tif(!obj->buffer) {\n\t\tsyslog(LOG_ERR, \"%s: malloc returned NULL\", \"upnp_event_prepare\");\n\t\tif(xml) {\n\t\t\tfree(xml);\n\t\t}\n\t\tobj->state = EError;\n\t\treturn;\n\t}\n\tobj->tosend = snprintf(obj->buffer, obj->buffersize, notifymsg,\n\t                       obj->path, obj->addrstr, obj->portstr, l+2,\n\t                       obj->sub->uuid, obj->sub->seq,\n\t                       l, xml);\n\tif(xml) {\n\t\tfree(xml);\n\t\txml = NULL;\n\t}\n\tobj->state = ESending;\n}",
        "func": "static void upnp_event_prepare(struct upnp_event_notify * obj)\n{\n\tstatic const char notifymsg[] =\n\t\t\"NOTIFY %s HTTP/1.1\\r\\n\"\n\t\t\"Host: %s%s\\r\\n\"\n#if (UPNP_VERSION_MAJOR == 1) && (UPNP_VERSION_MINOR == 0)\n\t\t\"Content-Type: text/xml\\r\\n\"\t/* UDA v1.0 */\n#else\n\t\t\"Content-Type: text/xml; charset=\\\"utf-8\\\"\\r\\n\"\t/* UDA v1.1 or later */\n#endif\n\t\t\"Content-Length: %d\\r\\n\"\n\t\t\"NT: upnp:event\\r\\n\"\n\t\t\"NTS: upnp:propchange\\r\\n\"\n\t\t\"SID: %s\\r\\n\"\n\t\t\"SEQ: %u\\r\\n\"\n\t\t\"Connection: close\\r\\n\"\n\t\t\"Cache-Control: no-cache\\r\\n\"\n\t\t\"\\r\\n\"\n\t\t\"%.*s\\r\\n\";\n\tchar * xml;\n\tint l;\n\tif(obj->sub == NULL) {\n\t\tobj->state = EError;\n\t\treturn;\n\t}\n\tswitch(obj->sub->service) {\n\tcase EWanCFG:\n\t\txml = getVarsWANCfg(&l);\n\t\tbreak;\n\tcase EWanIPC:\n\t\txml = getVarsWANIPCn(&l);\n\t\tbreak;\n#ifdef ENABLE_L3F_SERVICE\n\tcase EL3F:\n\t\txml = getVarsL3F(&l);\n\t\tbreak;\n#endif\n#ifdef ENABLE_6FC_SERVICE\n\tcase E6FC:\n\t\txml = getVars6FC(&l);\n\t\tbreak;\n#endif\n#ifdef ENABLE_DP_SERVICE\n\tcase EDP:\n\t\txml = getVarsDP(&l);\n\t\tbreak;\n#endif\n\tdefault:\n\t\txml = NULL;\n\t\tl = 0;\n\t}\n\tobj->buffersize = 1024;\n\tfor (;;) {\n\t\tobj->buffer = malloc(obj->buffersize);\n\t\tif(!obj->buffer) {\n\t\t\tsyslog(LOG_ERR, \"%s: malloc returned NULL\", \"upnp_event_prepare\");\n\t\t\tif(xml) {\n\t\t\t\tfree(xml);\n\t\t\t}\n\t\t\tobj->state = EError;\n\t\t\treturn;\n\t\t}\n\t\tobj->tosend = snprintf(obj->buffer, obj->buffersize, notifymsg,\n\t\t                       obj->path, obj->addrstr, obj->portstr, l+2,\n\t\t                       obj->sub->uuid, obj->sub->seq,\n\t\t                       l, xml);\n\t\tif (obj->tosend < 0) {\n\t\t\tsyslog(LOG_ERR, \"%s: snprintf() failed\", \"upnp_event_prepare\");\n\t\t\tif(xml) {\n\t\t\t\tfree(xml);\n\t\t\t}\n\t\t\tobj->state = EError;\n\t\t\treturn;\n\t\t} else if (obj->tosend < obj->buffersize) {\n\t\t\tbreak; /* the buffer was large enough */\n\t\t}\n\t\t/* Try again with a buffer big enough */\n\t\tfree(obj->buffer);\n\t\tobj->buffersize = obj->tosend + 1;\t/* reserve space for the final 0 */\n\t}\n\tif(xml) {\n\t\tfree(xml);\n\t\txml = NULL;\n\t}\n\tobj->state = ESending;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -50,19 +50,34 @@\n \t\tl = 0;\n \t}\n \tobj->buffersize = 1024;\n-\tobj->buffer = malloc(obj->buffersize);\n-\tif(!obj->buffer) {\n-\t\tsyslog(LOG_ERR, \"%s: malloc returned NULL\", \"upnp_event_prepare\");\n-\t\tif(xml) {\n-\t\t\tfree(xml);\n+\tfor (;;) {\n+\t\tobj->buffer = malloc(obj->buffersize);\n+\t\tif(!obj->buffer) {\n+\t\t\tsyslog(LOG_ERR, \"%s: malloc returned NULL\", \"upnp_event_prepare\");\n+\t\t\tif(xml) {\n+\t\t\t\tfree(xml);\n+\t\t\t}\n+\t\t\tobj->state = EError;\n+\t\t\treturn;\n \t\t}\n-\t\tobj->state = EError;\n-\t\treturn;\n+\t\tobj->tosend = snprintf(obj->buffer, obj->buffersize, notifymsg,\n+\t\t                       obj->path, obj->addrstr, obj->portstr, l+2,\n+\t\t                       obj->sub->uuid, obj->sub->seq,\n+\t\t                       l, xml);\n+\t\tif (obj->tosend < 0) {\n+\t\t\tsyslog(LOG_ERR, \"%s: snprintf() failed\", \"upnp_event_prepare\");\n+\t\t\tif(xml) {\n+\t\t\t\tfree(xml);\n+\t\t\t}\n+\t\t\tobj->state = EError;\n+\t\t\treturn;\n+\t\t} else if (obj->tosend < obj->buffersize) {\n+\t\t\tbreak; /* the buffer was large enough */\n+\t\t}\n+\t\t/* Try again with a buffer big enough */\n+\t\tfree(obj->buffer);\n+\t\tobj->buffersize = obj->tosend + 1;\t/* reserve space for the final 0 */\n \t}\n-\tobj->tosend = snprintf(obj->buffer, obj->buffersize, notifymsg,\n-\t                       obj->path, obj->addrstr, obj->portstr, l+2,\n-\t                       obj->sub->uuid, obj->sub->seq,\n-\t                       l, xml);\n \tif(xml) {\n \t\tfree(xml);\n \t\txml = NULL;",
        "diff_line_info": {
            "deleted_lines": [
                "\tobj->buffer = malloc(obj->buffersize);",
                "\tif(!obj->buffer) {",
                "\t\tsyslog(LOG_ERR, \"%s: malloc returned NULL\", \"upnp_event_prepare\");",
                "\t\tif(xml) {",
                "\t\t\tfree(xml);",
                "\t\tobj->state = EError;",
                "\t\treturn;",
                "\tobj->tosend = snprintf(obj->buffer, obj->buffersize, notifymsg,",
                "\t                       obj->path, obj->addrstr, obj->portstr, l+2,",
                "\t                       obj->sub->uuid, obj->sub->seq,",
                "\t                       l, xml);"
            ],
            "added_lines": [
                "\tfor (;;) {",
                "\t\tobj->buffer = malloc(obj->buffersize);",
                "\t\tif(!obj->buffer) {",
                "\t\t\tsyslog(LOG_ERR, \"%s: malloc returned NULL\", \"upnp_event_prepare\");",
                "\t\t\tif(xml) {",
                "\t\t\t\tfree(xml);",
                "\t\t\t}",
                "\t\t\tobj->state = EError;",
                "\t\t\treturn;",
                "\t\tobj->tosend = snprintf(obj->buffer, obj->buffersize, notifymsg,",
                "\t\t                       obj->path, obj->addrstr, obj->portstr, l+2,",
                "\t\t                       obj->sub->uuid, obj->sub->seq,",
                "\t\t                       l, xml);",
                "\t\tif (obj->tosend < 0) {",
                "\t\t\tsyslog(LOG_ERR, \"%s: snprintf() failed\", \"upnp_event_prepare\");",
                "\t\t\tif(xml) {",
                "\t\t\t\tfree(xml);",
                "\t\t\t}",
                "\t\t\tobj->state = EError;",
                "\t\t\treturn;",
                "\t\t} else if (obj->tosend < obj->buffersize) {",
                "\t\t\tbreak; /* the buffer was large enough */",
                "\t\t}",
                "\t\t/* Try again with a buffer big enough */",
                "\t\tfree(obj->buffer);",
                "\t\tobj->buffersize = obj->tosend + 1;\t/* reserve space for the final 0 */"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-17177",
        "func_name": "FreeRDP/region16_intersect_rect",
        "description": "libfreerdp/codec/region.c in FreeRDP through 1.1.x and 2.x through 2.0.0-rc4 has memory leaks because a supplied realloc pointer (i.e., the first argument to realloc) is also used for a realloc return value.",
        "git_url": "https://github.com/FreeRDP/FreeRDP/commit/9fee4ae076b1ec97b97efb79ece08d1dab4df29a",
        "commit_title": "Fixed #5645: realloc return handling",
        "commit_text": "",
        "func_before": "BOOL region16_intersect_rect(REGION16* dst, const REGION16* src, const RECTANGLE_16* rect)\n{\n\tREGION16_DATA* newItems;\n\tconst RECTANGLE_16* srcPtr, *endPtr, *srcExtents;\n\tRECTANGLE_16* dstPtr;\n\tUINT32 nbRects, usedRects;\n\tRECTANGLE_16 common, newExtents;\n\tassert(src);\n\tassert(src->data);\n\tsrcPtr = region16_rects(src, &nbRects);\n\n\tif (!nbRects)\n\t{\n\t\tregion16_clear(dst);\n\t\treturn TRUE;\n\t}\n\n\tsrcExtents = region16_extents(src);\n\n\tif (nbRects == 1)\n\t{\n\t\tBOOL intersects = rectangles_intersection(srcExtents, rect, &common);\n\t\tregion16_clear(dst);\n\n\t\tif (intersects)\n\t\t\treturn region16_union_rect(dst, dst, &common);\n\n\t\treturn TRUE;\n\t}\n\n\tnewItems = allocateRegion(nbRects);\n\n\tif (!newItems)\n\t\treturn FALSE;\n\n\tdstPtr = (RECTANGLE_16*)(&newItems[1]);\n\tusedRects = 0;\n\tZeroMemory(&newExtents, sizeof(newExtents));\n\n\t/* accumulate intersecting rectangles, the final region16_simplify_bands() will\n\t * do all the bad job to recreate correct rectangles\n\t */\n\tfor (endPtr = srcPtr + nbRects; (srcPtr < endPtr) && (rect->bottom > srcPtr->top); srcPtr++)\n\t{\n\t\tif (rectangles_intersection(srcPtr, rect, &common))\n\t\t{\n\t\t\t*dstPtr = common;\n\t\t\tusedRects++;\n\t\t\tdstPtr++;\n\n\t\t\tif (rectangle_is_empty(&newExtents))\n\t\t\t{\n\t\t\t\t/* Check if the existing newExtents is empty. If it is empty, use\n\t\t\t\t * new common directly. We do not need to check common rectangle\n\t\t\t\t * because the rectangles_intersection() ensures that it is not empty.\n\t\t\t\t */\n\t\t\t\tnewExtents = common;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tnewExtents.top = MIN(common.top, newExtents.top);\n\t\t\t\tnewExtents.left = MIN(common.left, newExtents.left);\n\t\t\t\tnewExtents.bottom = MAX(common.bottom, newExtents.bottom);\n\t\t\t\tnewExtents.right = MAX(common.right, newExtents.right);\n\t\t\t}\n\t\t}\n\t}\n\n\tnewItems->nbRects = usedRects;\n\tnewItems->size = sizeof(REGION16_DATA) + (usedRects * sizeof(RECTANGLE_16));\n\n\tif ((dst->data->size > 0) && (dst->data != &empty_region))\n\t\tfree(dst->data);\n\n\tdst->data = realloc(newItems, newItems->size);\n\n\tif (!dst->data)\n\t{\n\t\tfree(newItems);\n\t\treturn FALSE;\n\t}\n\n\tdst->extents = newExtents;\n\treturn region16_simplify_bands(dst);\n}",
        "func": "BOOL region16_intersect_rect(REGION16* dst, const REGION16* src, const RECTANGLE_16* rect)\n{\n\tREGION16_DATA* data;\n\tREGION16_DATA* newItems;\n\tconst RECTANGLE_16* srcPtr, *endPtr, *srcExtents;\n\tRECTANGLE_16* dstPtr;\n\tUINT32 nbRects, usedRects;\n\tRECTANGLE_16 common, newExtents;\n\tassert(src);\n\tassert(src->data);\n\tsrcPtr = region16_rects(src, &nbRects);\n\n\tif (!nbRects)\n\t{\n\t\tregion16_clear(dst);\n\t\treturn TRUE;\n\t}\n\n\tsrcExtents = region16_extents(src);\n\n\tif (nbRects == 1)\n\t{\n\t\tBOOL intersects = rectangles_intersection(srcExtents, rect, &common);\n\t\tregion16_clear(dst);\n\n\t\tif (intersects)\n\t\t\treturn region16_union_rect(dst, dst, &common);\n\n\t\treturn TRUE;\n\t}\n\n\tnewItems = allocateRegion(nbRects);\n\n\tif (!newItems)\n\t\treturn FALSE;\n\n\tdstPtr = (RECTANGLE_16*)(&newItems[1]);\n\tusedRects = 0;\n\tZeroMemory(&newExtents, sizeof(newExtents));\n\n\t/* accumulate intersecting rectangles, the final region16_simplify_bands() will\n\t * do all the bad job to recreate correct rectangles\n\t */\n\tfor (endPtr = srcPtr + nbRects; (srcPtr < endPtr) && (rect->bottom > srcPtr->top); srcPtr++)\n\t{\n\t\tif (rectangles_intersection(srcPtr, rect, &common))\n\t\t{\n\t\t\t*dstPtr = common;\n\t\t\tusedRects++;\n\t\t\tdstPtr++;\n\n\t\t\tif (rectangle_is_empty(&newExtents))\n\t\t\t{\n\t\t\t\t/* Check if the existing newExtents is empty. If it is empty, use\n\t\t\t\t * new common directly. We do not need to check common rectangle\n\t\t\t\t * because the rectangles_intersection() ensures that it is not empty.\n\t\t\t\t */\n\t\t\t\tnewExtents = common;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tnewExtents.top = MIN(common.top, newExtents.top);\n\t\t\t\tnewExtents.left = MIN(common.left, newExtents.left);\n\t\t\t\tnewExtents.bottom = MAX(common.bottom, newExtents.bottom);\n\t\t\t\tnewExtents.right = MAX(common.right, newExtents.right);\n\t\t\t}\n\t\t}\n\t}\n\n\tnewItems->nbRects = usedRects;\n\tnewItems->size = sizeof(REGION16_DATA) + (usedRects * sizeof(RECTANGLE_16));\n\n\tif ((dst->data->size > 0) && (dst->data != &empty_region))\n\t\tfree(dst->data);\n\n\tdst->data = realloc(newItems, newItems->size);\n\n\tif (!dst->data)\n\t{\n\t\tfree(newItems);\n\t\treturn FALSE;\n\t}\n\n\tdst->extents = newExtents;\n\treturn region16_simplify_bands(dst);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,6 @@\n BOOL region16_intersect_rect(REGION16* dst, const REGION16* src, const RECTANGLE_16* rect)\n {\n+\tREGION16_DATA* data;\n \tREGION16_DATA* newItems;\n \tconst RECTANGLE_16* srcPtr, *endPtr, *srcExtents;\n \tRECTANGLE_16* dstPtr;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tREGION16_DATA* data;"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-17177",
        "func_name": "FreeRDP/region16_simplify_bands",
        "description": "libfreerdp/codec/region.c in FreeRDP through 1.1.x and 2.x through 2.0.0-rc4 has memory leaks because a supplied realloc pointer (i.e., the first argument to realloc) is also used for a realloc return value.",
        "git_url": "https://github.com/FreeRDP/FreeRDP/commit/9fee4ae076b1ec97b97efb79ece08d1dab4df29a",
        "commit_title": "Fixed #5645: realloc return handling",
        "commit_text": "",
        "func_before": "static BOOL region16_simplify_bands(REGION16* region)\n{\n\t/** Simplify consecutive bands that touch and have the same items\n\t *\n\t *  ====================          ====================\n\t *     | 1 |  | 2   |               |   |  |     |\n\t *  ====================            |   |  |     |\n\t *     | 1 |  | 2   |\t   ====>    | 1 |  |  2  |\n\t *  ====================            |   |  |     |\n\t *     | 1 |  | 2   |               |   |  |     |\n\t *  ====================          ====================\n\t *\n\t */\n\tRECTANGLE_16* band1, *band2, *endPtr, *endBand, *tmp;\n\tint nbRects, finalNbRects;\n\tint bandItems, toMove;\n\tfinalNbRects = nbRects = region16_n_rects(region);\n\n\tif (nbRects < 2)\n\t\treturn TRUE;\n\n\tband1 = region16_rects_noconst(region);\n\tendPtr = band1 + nbRects;\n\n\tdo\n\t{\n\t\tband2 = next_band(band1, endPtr, &bandItems);\n\n\t\tif (band2 == endPtr)\n\t\t\tbreak;\n\n\t\tif ((band1->bottom == band2->top) && band_match(band1, band2, endPtr))\n\t\t{\n\t\t\t/* adjust the bottom of band1 items */\n\t\t\ttmp = band1;\n\n\t\t\twhile (tmp < band2)\n\t\t\t{\n\t\t\t\ttmp->bottom = band2->bottom;\n\t\t\t\ttmp++;\n\t\t\t}\n\n\t\t\t/* override band2, we don't move band1 pointer as the band after band2\n\t\t\t * may be merged too */\n\t\t\tendBand = band2 + bandItems;\n\t\t\ttoMove = (endPtr - endBand) * sizeof(RECTANGLE_16);\n\n\t\t\tif (toMove)\n\t\t\t\tMoveMemory(band2, endBand, toMove);\n\n\t\t\tfinalNbRects -= bandItems;\n\t\t\tendPtr -= bandItems;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tband1 = band2;\n\t\t}\n\t}\n\twhile (TRUE);\n\n\tif (finalNbRects != nbRects)\n\t{\n\t\tint allocSize = sizeof(REGION16_DATA) + (finalNbRects * sizeof(RECTANGLE_16));\n\t\tregion->data = realloc(region->data, allocSize);\n\n\t\tif (!region->data)\n\t\t{\n\t\t\tregion->data = &empty_region;\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tregion->data->nbRects = finalNbRects;\n\t\tregion->data->size = allocSize;\n\t}\n\n\treturn TRUE;\n}",
        "func": "static BOOL region16_simplify_bands(REGION16* region)\n{\n\t/** Simplify consecutive bands that touch and have the same items\n\t *\n\t *  ====================          ====================\n\t *     | 1 |  | 2   |               |   |  |     |\n\t *  ====================            |   |  |     |\n\t *     | 1 |  | 2   |\t   ====>    | 1 |  |  2  |\n\t *  ====================            |   |  |     |\n\t *     | 1 |  | 2   |               |   |  |     |\n\t *  ====================          ====================\n\t *\n\t */\n\tRECTANGLE_16* band1, *band2, *endPtr, *endBand, *tmp;\n\tint nbRects, finalNbRects;\n\tint bandItems, toMove;\n\tfinalNbRects = nbRects = region16_n_rects(region);\n\n\tif (nbRects < 2)\n\t\treturn TRUE;\n\n\tband1 = region16_rects_noconst(region);\n\tendPtr = band1 + nbRects;\n\n\tdo\n\t{\n\t\tband2 = next_band(band1, endPtr, &bandItems);\n\n\t\tif (band2 == endPtr)\n\t\t\tbreak;\n\n\t\tif ((band1->bottom == band2->top) && band_match(band1, band2, endPtr))\n\t\t{\n\t\t\t/* adjust the bottom of band1 items */\n\t\t\ttmp = band1;\n\n\t\t\twhile (tmp < band2)\n\t\t\t{\n\t\t\t\ttmp->bottom = band2->bottom;\n\t\t\t\ttmp++;\n\t\t\t}\n\n\t\t\t/* override band2, we don't move band1 pointer as the band after band2\n\t\t\t * may be merged too */\n\t\t\tendBand = band2 + bandItems;\n\t\t\ttoMove = (endPtr - endBand) * sizeof(RECTANGLE_16);\n\n\t\t\tif (toMove)\n\t\t\t\tMoveMemory(band2, endBand, toMove);\n\n\t\t\tfinalNbRects -= bandItems;\n\t\t\tendPtr -= bandItems;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tband1 = band2;\n\t\t}\n\t}\n\twhile (TRUE);\n\n\tif (finalNbRects != nbRects)\n\t{\n\t\tREGION16_DATA* data;\n\t\tsize_t allocSize = sizeof(REGION16_DATA) + (finalNbRects * sizeof(RECTANGLE_16));\n\t\tdata = realloc(region->data, allocSize);\n\t\tif (!data)\n\t\t\tfree(region->data);\n\t\tregion->data = data;\n\n\t\tif (!region->data)\n\t\t{\n\t\t\tregion->data = &empty_region;\n\t\t\treturn FALSE;\n\t\t}\n\n\t\tregion->data->nbRects = finalNbRects;\n\t\tregion->data->size = allocSize;\n\t}\n\n\treturn TRUE;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -60,8 +60,12 @@\n \n \tif (finalNbRects != nbRects)\n \t{\n-\t\tint allocSize = sizeof(REGION16_DATA) + (finalNbRects * sizeof(RECTANGLE_16));\n-\t\tregion->data = realloc(region->data, allocSize);\n+\t\tREGION16_DATA* data;\n+\t\tsize_t allocSize = sizeof(REGION16_DATA) + (finalNbRects * sizeof(RECTANGLE_16));\n+\t\tdata = realloc(region->data, allocSize);\n+\t\tif (!data)\n+\t\t\tfree(region->data);\n+\t\tregion->data = data;\n \n \t\tif (!region->data)\n \t\t{",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tint allocSize = sizeof(REGION16_DATA) + (finalNbRects * sizeof(RECTANGLE_16));",
                "\t\tregion->data = realloc(region->data, allocSize);"
            ],
            "added_lines": [
                "\t\tREGION16_DATA* data;",
                "\t\tsize_t allocSize = sizeof(REGION16_DATA) + (finalNbRects * sizeof(RECTANGLE_16));",
                "\t\tdata = realloc(region->data, allocSize);",
                "\t\tif (!data)",
                "\t\t\tfree(region->data);",
                "\t\tregion->data = data;"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-17177",
        "func_name": "FreeRDP/region16_union_rect",
        "description": "libfreerdp/codec/region.c in FreeRDP through 1.1.x and 2.x through 2.0.0-rc4 has memory leaks because a supplied realloc pointer (i.e., the first argument to realloc) is also used for a realloc return value.",
        "git_url": "https://github.com/FreeRDP/FreeRDP/commit/9fee4ae076b1ec97b97efb79ece08d1dab4df29a",
        "commit_title": "Fixed #5645: realloc return handling",
        "commit_text": "",
        "func_before": "BOOL region16_union_rect(REGION16* dst, const REGION16* src, const RECTANGLE_16* rect)\n{\n\tconst RECTANGLE_16* srcExtents;\n\tRECTANGLE_16* dstExtents;\n\tconst RECTANGLE_16* currentBand, *endSrcRect, *nextBand;\n\tREGION16_DATA* newItems = NULL;\n\tRECTANGLE_16* dstRect = NULL;\n\tUINT32 usedRects, srcNbRects;\n\tUINT16 topInterBand;\n\tassert(src);\n\tassert(src->data);\n\tassert(dst);\n\tsrcExtents = region16_extents(src);\n\tdstExtents = region16_extents_noconst(dst);\n\n\tif (!region16_n_rects(src))\n\t{\n\t\t/* source is empty, so the union is rect */\n\t\tdst->extents = *rect;\n\t\tdst->data = allocateRegion(1);\n\n\t\tif (!dst->data)\n\t\t\treturn FALSE;\n\n\t\tdstRect = region16_rects_noconst(dst);\n\t\tdstRect->top = rect->top;\n\t\tdstRect->left = rect->left;\n\t\tdstRect->right = rect->right;\n\t\tdstRect->bottom = rect->bottom;\n\t\treturn TRUE;\n\t}\n\n\tnewItems = allocateRegion((1 + region16_n_rects(src)) * 4);\n\n\tif (!newItems)\n\t\treturn FALSE;\n\n\tdstRect = (RECTANGLE_16*)(&newItems[1]);\n\tusedRects = 0;\n\n\t/* adds the piece of rect that is on the top of src */\n\tif (rect->top < srcExtents->top)\n\t{\n\t\tdstRect->top = rect->top;\n\t\tdstRect->left = rect->left;\n\t\tdstRect->right = rect->right;\n\t\tdstRect->bottom = MIN(srcExtents->top, rect->bottom);\n\t\tusedRects++;\n\t\tdstRect++;\n\t}\n\n\t/* treat possibly overlapping region */\n\tcurrentBand = region16_rects(src, &srcNbRects);\n\tendSrcRect = currentBand + srcNbRects;\n\n\twhile (currentBand < endSrcRect)\n\t{\n\t\tif ((currentBand->bottom <= rect->top) || (rect->bottom <= currentBand->top) ||\n\t\t    rectangle_contained_in_band(currentBand, endSrcRect, rect))\n\t\t{\n\t\t\t/* no overlap between rect and the band, rect is totally below or totally above\n\t\t\t * the current band, or rect is already covered by an item of the band.\n\t\t\t * let's copy all the rectangles from this band\n\t\t\t\t\t\t+----+\n\t\t\t\t\t\t|    |   rect (case 1)\n\t\t\t\t\t\t+----+\n\n\t\t\t   =================\n\t\t\tband of srcRect\n\t\t\t =================\n\t\t\t\t\t+----+\n\t\t\t\t\t|    |   rect (case 2)\n\t\t\t\t\t+----+\n\t\t\t*/\n\t\t\tregion16_copy_band_with_union(dstRect,\n\t\t\t                              currentBand, endSrcRect,\n\t\t\t                              currentBand->top, currentBand->bottom,\n\t\t\t                              NULL, &usedRects,\n\t\t\t                              &nextBand, &dstRect);\n\t\t\ttopInterBand = rect->top;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* rect overlaps the band:\n\t\t\t\t\t   |    |  |    |\n\t\t\t====^=================|    |==|    |=========================== band\n\t\t\t|   top split     |    |  |    |\n\t\t\tv                 | 1  |  | 2  |\n\t\t\t^                 |    |  |    |  +----+   +----+\n\t\t\t|   merge zone    |    |  |    |  |    |   | 4  |\n\t\t\tv                 +----+  |    |  |    |   +----+\n\t\t\t^                         |    |  | 3  |\n\t\t\t|   bottom split          |    |  |    |\n\t\t\t====v=========================|    |==|    |===================\n\t\t\t\t\t   |    |  |    |\n\n\t\t\t possible cases:\n\t\t\t 1) no top split, merge zone then a bottom split. The band will be splitted\n\t\t\t  in two\n\t\t\t 2) not band split, only the merge zone, band merged with rect but not splitted\n\t\t\t 3) a top split, the merge zone and no bottom split. The band will be split\n\t\t\t in two\n\t\t\t 4) a top split, the merge zone and also a bottom split. The band will be\n\t\t\t splitted in 3, but the coalesce algorithm may merge the created bands\n\t\t\t */\n\t\t\tUINT16 mergeTop = currentBand->top;\n\t\t\tUINT16 mergeBottom = currentBand->bottom;\n\n\t\t\t/* test if we need a top split, case 3 and 4 */\n\t\t\tif (rect->top > currentBand->top)\n\t\t\t{\n\t\t\t\tregion16_copy_band_with_union(dstRect,\n\t\t\t\t                              currentBand, endSrcRect,\n\t\t\t\t                              currentBand->top, rect->top,\n\t\t\t\t                              NULL, &usedRects,\n\t\t\t\t                              &nextBand, &dstRect);\n\t\t\t\tmergeTop = rect->top;\n\t\t\t}\n\n\t\t\t/* do the merge zone (all cases) */\n\t\t\tif (rect->bottom < currentBand->bottom)\n\t\t\t\tmergeBottom = rect->bottom;\n\n\t\t\tregion16_copy_band_with_union(dstRect,\n\t\t\t                              currentBand, endSrcRect,\n\t\t\t                              mergeTop, mergeBottom,\n\t\t\t                              rect, &usedRects,\n\t\t\t                              &nextBand, &dstRect);\n\n\t\t\t/* test if we need a bottom split, case 1 and 4 */\n\t\t\tif (rect->bottom < currentBand->bottom)\n\t\t\t{\n\t\t\t\tregion16_copy_band_with_union(dstRect,\n\t\t\t\t                              currentBand, endSrcRect,\n\t\t\t\t                              mergeBottom, currentBand->bottom,\n\t\t\t\t                              NULL, &usedRects,\n\t\t\t\t                              &nextBand, &dstRect);\n\t\t\t}\n\n\t\t\ttopInterBand = currentBand->bottom;\n\t\t}\n\n\t\t/* test if a piece of rect should be inserted as a new band between\n\t\t * the current band and the next one. band n and n+1 shouldn't touch.\n\t\t *\n\t\t * ==============================================================\n\t\t *                                                        band n\n\t\t *            +------+                    +------+\n\t\t * ===========| rect |====================|      |===============\n\t\t *            |      |    +------+        |      |\n\t\t *            +------+    | rect |        | rect |\n\t\t *                        +------+        |      |\n\t\t * =======================================|      |================\n\t\t *                                        +------+         band n+1\n\t\t * ===============================================================\n\t\t *\n\t\t */\n\t\tif ((nextBand < endSrcRect) && (nextBand->top != currentBand->bottom) &&\n\t\t    (rect->bottom > currentBand->bottom) && (rect->top < nextBand->top))\n\t\t{\n\t\t\tdstRect->right = rect->right;\n\t\t\tdstRect->left = rect->left;\n\t\t\tdstRect->top = topInterBand;\n\t\t\tdstRect->bottom = MIN(nextBand->top, rect->bottom);\n\t\t\tdstRect++;\n\t\t\tusedRects++;\n\t\t}\n\n\t\tcurrentBand = nextBand;\n\t}\n\n\t/* adds the piece of rect that is below src */\n\tif (srcExtents->bottom < rect->bottom)\n\t{\n\t\tdstRect->top = MAX(srcExtents->bottom, rect->top);\n\t\tdstRect->left = rect->left;\n\t\tdstRect->right = rect->right;\n\t\tdstRect->bottom = rect->bottom;\n\t\tusedRects++;\n\t\tdstRect++;\n\t}\n\n\tif ((src == dst) && (src->data->size > 0) && (src->data != &empty_region))\n\t\tfree(src->data);\n\n\tdstExtents->top = MIN(rect->top, srcExtents->top);\n\tdstExtents->left = MIN(rect->left, srcExtents->left);\n\tdstExtents->bottom = MAX(rect->bottom, srcExtents->bottom);\n\tdstExtents->right = MAX(rect->right, srcExtents->right);\n\tnewItems->size = sizeof(REGION16_DATA) + (usedRects * sizeof(RECTANGLE_16));\n\tdst->data = realloc(newItems, newItems->size);\n\n\tif (!dst->data)\n\t{\n\t\tfree(newItems);\n\t\treturn FALSE;\n\t}\n\n\tdst->data->nbRects = usedRects;\n\treturn region16_simplify_bands(dst);\n}",
        "func": "BOOL region16_union_rect(REGION16* dst, const REGION16* src, const RECTANGLE_16* rect)\n{\n\tREGION16_DATA* data;\n\tconst RECTANGLE_16* srcExtents;\n\tRECTANGLE_16* dstExtents;\n\tconst RECTANGLE_16* currentBand, *endSrcRect, *nextBand;\n\tREGION16_DATA* newItems = NULL;\n\tREGION16_DATA* tmpItems = NULL;\n\tRECTANGLE_16* dstRect = NULL;\n\tUINT32 usedRects, srcNbRects;\n\tUINT16 topInterBand;\n\tassert(src);\n\tassert(src->data);\n\tassert(dst);\n\tsrcExtents = region16_extents(src);\n\tdstExtents = region16_extents_noconst(dst);\n\n\tif (!region16_n_rects(src))\n\t{\n\t\t/* source is empty, so the union is rect */\n\t\tdst->extents = *rect;\n\t\tdst->data = allocateRegion(1);\n\n\t\tif (!dst->data)\n\t\t\treturn FALSE;\n\n\t\tdstRect = region16_rects_noconst(dst);\n\t\tdstRect->top = rect->top;\n\t\tdstRect->left = rect->left;\n\t\tdstRect->right = rect->right;\n\t\tdstRect->bottom = rect->bottom;\n\t\treturn TRUE;\n\t}\n\n\tnewItems = allocateRegion((1 + region16_n_rects(src)) * 4);\n\n\tif (!newItems)\n\t\treturn FALSE;\n\n\tdstRect = (RECTANGLE_16*)(&newItems[1]);\n\tusedRects = 0;\n\n\t/* adds the piece of rect that is on the top of src */\n\tif (rect->top < srcExtents->top)\n\t{\n\t\tdstRect->top = rect->top;\n\t\tdstRect->left = rect->left;\n\t\tdstRect->right = rect->right;\n\t\tdstRect->bottom = MIN(srcExtents->top, rect->bottom);\n\t\tusedRects++;\n\t\tdstRect++;\n\t}\n\n\t/* treat possibly overlapping region */\n\tcurrentBand = region16_rects(src, &srcNbRects);\n\tendSrcRect = currentBand + srcNbRects;\n\n\twhile (currentBand < endSrcRect)\n\t{\n\t\tif ((currentBand->bottom <= rect->top) || (rect->bottom <= currentBand->top) ||\n\t\t    rectangle_contained_in_band(currentBand, endSrcRect, rect))\n\t\t{\n\t\t\t/* no overlap between rect and the band, rect is totally below or totally above\n\t\t\t * the current band, or rect is already covered by an item of the band.\n\t\t\t * let's copy all the rectangles from this band\n\t\t\t\t\t\t+----+\n\t\t\t\t\t\t|    |   rect (case 1)\n\t\t\t\t\t\t+----+\n\n\t\t\t   =================\n\t\t\tband of srcRect\n\t\t\t =================\n\t\t\t\t\t+----+\n\t\t\t\t\t|    |   rect (case 2)\n\t\t\t\t\t+----+\n\t\t\t*/\n\t\t\tregion16_copy_band_with_union(dstRect,\n\t\t\t                              currentBand, endSrcRect,\n\t\t\t                              currentBand->top, currentBand->bottom,\n\t\t\t                              NULL, &usedRects,\n\t\t\t                              &nextBand, &dstRect);\n\t\t\ttopInterBand = rect->top;\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* rect overlaps the band:\n\t\t\t\t\t   |    |  |    |\n\t\t\t====^=================|    |==|    |=========================== band\n\t\t\t|   top split     |    |  |    |\n\t\t\tv                 | 1  |  | 2  |\n\t\t\t^                 |    |  |    |  +----+   +----+\n\t\t\t|   merge zone    |    |  |    |  |    |   | 4  |\n\t\t\tv                 +----+  |    |  |    |   +----+\n\t\t\t^                         |    |  | 3  |\n\t\t\t|   bottom split          |    |  |    |\n\t\t\t====v=========================|    |==|    |===================\n\t\t\t\t\t   |    |  |    |\n\n\t\t\t possible cases:\n\t\t\t 1) no top split, merge zone then a bottom split. The band will be splitted\n\t\t\t  in two\n\t\t\t 2) not band split, only the merge zone, band merged with rect but not splitted\n\t\t\t 3) a top split, the merge zone and no bottom split. The band will be split\n\t\t\t in two\n\t\t\t 4) a top split, the merge zone and also a bottom split. The band will be\n\t\t\t splitted in 3, but the coalesce algorithm may merge the created bands\n\t\t\t */\n\t\t\tUINT16 mergeTop = currentBand->top;\n\t\t\tUINT16 mergeBottom = currentBand->bottom;\n\n\t\t\t/* test if we need a top split, case 3 and 4 */\n\t\t\tif (rect->top > currentBand->top)\n\t\t\t{\n\t\t\t\tregion16_copy_band_with_union(dstRect,\n\t\t\t\t                              currentBand, endSrcRect,\n\t\t\t\t                              currentBand->top, rect->top,\n\t\t\t\t                              NULL, &usedRects,\n\t\t\t\t                              &nextBand, &dstRect);\n\t\t\t\tmergeTop = rect->top;\n\t\t\t}\n\n\t\t\t/* do the merge zone (all cases) */\n\t\t\tif (rect->bottom < currentBand->bottom)\n\t\t\t\tmergeBottom = rect->bottom;\n\n\t\t\tregion16_copy_band_with_union(dstRect,\n\t\t\t                              currentBand, endSrcRect,\n\t\t\t                              mergeTop, mergeBottom,\n\t\t\t                              rect, &usedRects,\n\t\t\t                              &nextBand, &dstRect);\n\n\t\t\t/* test if we need a bottom split, case 1 and 4 */\n\t\t\tif (rect->bottom < currentBand->bottom)\n\t\t\t{\n\t\t\t\tregion16_copy_band_with_union(dstRect,\n\t\t\t\t                              currentBand, endSrcRect,\n\t\t\t\t                              mergeBottom, currentBand->bottom,\n\t\t\t\t                              NULL, &usedRects,\n\t\t\t\t                              &nextBand, &dstRect);\n\t\t\t}\n\n\t\t\ttopInterBand = currentBand->bottom;\n\t\t}\n\n\t\t/* test if a piece of rect should be inserted as a new band between\n\t\t * the current band and the next one. band n and n+1 shouldn't touch.\n\t\t *\n\t\t * ==============================================================\n\t\t *                                                        band n\n\t\t *            +------+                    +------+\n\t\t * ===========| rect |====================|      |===============\n\t\t *            |      |    +------+        |      |\n\t\t *            +------+    | rect |        | rect |\n\t\t *                        +------+        |      |\n\t\t * =======================================|      |================\n\t\t *                                        +------+         band n+1\n\t\t * ===============================================================\n\t\t *\n\t\t */\n\t\tif ((nextBand < endSrcRect) && (nextBand->top != currentBand->bottom) &&\n\t\t    (rect->bottom > currentBand->bottom) && (rect->top < nextBand->top))\n\t\t{\n\t\t\tdstRect->right = rect->right;\n\t\t\tdstRect->left = rect->left;\n\t\t\tdstRect->top = topInterBand;\n\t\t\tdstRect->bottom = MIN(nextBand->top, rect->bottom);\n\t\t\tdstRect++;\n\t\t\tusedRects++;\n\t\t}\n\n\t\tcurrentBand = nextBand;\n\t}\n\n\t/* adds the piece of rect that is below src */\n\tif (srcExtents->bottom < rect->bottom)\n\t{\n\t\tdstRect->top = MAX(srcExtents->bottom, rect->top);\n\t\tdstRect->left = rect->left;\n\t\tdstRect->right = rect->right;\n\t\tdstRect->bottom = rect->bottom;\n\t\tusedRects++;\n\t\tdstRect++;\n\t}\n\n\tif ((src == dst) && (src->data->size > 0) && (src->data != &empty_region))\n\t\tfree(src->data);\n\n\tdstExtents->top = MIN(rect->top, srcExtents->top);\n\tdstExtents->left = MIN(rect->left, srcExtents->left);\n\tdstExtents->bottom = MAX(rect->bottom, srcExtents->bottom);\n\tdstExtents->right = MAX(rect->right, srcExtents->right);\n\tnewItems->size = sizeof(REGION16_DATA) + (usedRects * sizeof(RECTANGLE_16));\n\ttmpItems = realloc(newItems, newItems->size);\n\tif (!tmpItems)\n\t\tfree(newItems);\n\tnewItems = tmpItems;\n\tdst->data = newItems;\n\n\tif (!dst->data)\n\t{\n\t\tfree(newItems);\n\t\treturn FALSE;\n\t}\n\n\tdst->data->nbRects = usedRects;\n\treturn region16_simplify_bands(dst);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,9 +1,11 @@\n BOOL region16_union_rect(REGION16* dst, const REGION16* src, const RECTANGLE_16* rect)\n {\n+\tREGION16_DATA* data;\n \tconst RECTANGLE_16* srcExtents;\n \tRECTANGLE_16* dstExtents;\n \tconst RECTANGLE_16* currentBand, *endSrcRect, *nextBand;\n \tREGION16_DATA* newItems = NULL;\n+\tREGION16_DATA* tmpItems = NULL;\n \tRECTANGLE_16* dstRect = NULL;\n \tUINT32 usedRects, srcNbRects;\n \tUINT16 topInterBand;\n@@ -188,7 +190,11 @@\n \tdstExtents->bottom = MAX(rect->bottom, srcExtents->bottom);\n \tdstExtents->right = MAX(rect->right, srcExtents->right);\n \tnewItems->size = sizeof(REGION16_DATA) + (usedRects * sizeof(RECTANGLE_16));\n-\tdst->data = realloc(newItems, newItems->size);\n+\ttmpItems = realloc(newItems, newItems->size);\n+\tif (!tmpItems)\n+\t\tfree(newItems);\n+\tnewItems = tmpItems;\n+\tdst->data = newItems;\n \n \tif (!dst->data)\n \t{",
        "diff_line_info": {
            "deleted_lines": [
                "\tdst->data = realloc(newItems, newItems->size);"
            ],
            "added_lines": [
                "\tREGION16_DATA* data;",
                "\tREGION16_DATA* tmpItems = NULL;",
                "\ttmpItems = realloc(newItems, newItems->size);",
                "\tif (!tmpItems)",
                "\t\tfree(newItems);",
                "\tnewItems = tmpItems;",
                "\tdst->data = newItems;"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-17177",
        "func_name": "FreeRDP/HuffmanTree_makeFromFrequencies",
        "description": "libfreerdp/codec/region.c in FreeRDP through 1.1.x and 2.x through 2.0.0-rc4 has memory leaks because a supplied realloc pointer (i.e., the first argument to realloc) is also used for a realloc return value.",
        "git_url": "https://github.com/FreeRDP/FreeRDP/commit/9fee4ae076b1ec97b97efb79ece08d1dab4df29a",
        "commit_title": "Fixed #5645: realloc return handling",
        "commit_text": "",
        "func_before": "static unsigned HuffmanTree_makeFromFrequencies(HuffmanTree* tree, const unsigned* frequencies,\n                                                size_t mincodes, size_t numcodes, unsigned maxbitlen)\n{\n  unsigned error = 0;\n  while(!frequencies[numcodes - 1] && numcodes > mincodes) numcodes--; /*trim zeroes*/\n  tree->maxbitlen = maxbitlen;\n  tree->numcodes = (unsigned)numcodes; /*number of symbols*/\n  tree->lengths = (unsigned*)realloc(tree->lengths, numcodes * sizeof(unsigned));\n  if(!tree->lengths) return 83; /*alloc fail*/\n  /*initialize all lengths to 0*/\n  memset(tree->lengths, 0, numcodes * sizeof(unsigned));\n\n  error = lodepng_huffman_code_lengths(tree->lengths, frequencies, numcodes, maxbitlen);\n  if(!error) error = HuffmanTree_makeFromLengths2(tree);\n  return error;\n}",
        "func": "static unsigned HuffmanTree_makeFromFrequencies(HuffmanTree* tree, const unsigned* frequencies,\n                                                size_t mincodes, size_t numcodes, unsigned maxbitlen)\n{\n\tunsigned* lengths;\n  unsigned error = 0;\n  while(!frequencies[numcodes - 1] && numcodes > mincodes) numcodes--; /*trim zeroes*/\n  tree->maxbitlen = maxbitlen;\n  tree->numcodes = (unsigned)numcodes; /*number of symbols*/\n  lengths = (unsigned*)realloc(tree->lengths, numcodes * sizeof(unsigned));\n\tif (!lengths)\n\t\tfree(tree->lengths);\n\ttree->lengths = lengths;\n  if(!tree->lengths) return 83; /*alloc fail*/\n  /*initialize all lengths to 0*/\n  memset(tree->lengths, 0, numcodes * sizeof(unsigned));\n\n  error = lodepng_huffman_code_lengths(tree->lengths, frequencies, numcodes, maxbitlen);\n  if(!error) error = HuffmanTree_makeFromLengths2(tree);\n  return error;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,11 +1,15 @@\n static unsigned HuffmanTree_makeFromFrequencies(HuffmanTree* tree, const unsigned* frequencies,\n                                                 size_t mincodes, size_t numcodes, unsigned maxbitlen)\n {\n+\tunsigned* lengths;\n   unsigned error = 0;\n   while(!frequencies[numcodes - 1] && numcodes > mincodes) numcodes--; /*trim zeroes*/\n   tree->maxbitlen = maxbitlen;\n   tree->numcodes = (unsigned)numcodes; /*number of symbols*/\n-  tree->lengths = (unsigned*)realloc(tree->lengths, numcodes * sizeof(unsigned));\n+  lengths = (unsigned*)realloc(tree->lengths, numcodes * sizeof(unsigned));\n+\tif (!lengths)\n+\t\tfree(tree->lengths);\n+\ttree->lengths = lengths;\n   if(!tree->lengths) return 83; /*alloc fail*/\n   /*initialize all lengths to 0*/\n   memset(tree->lengths, 0, numcodes * sizeof(unsigned));",
        "diff_line_info": {
            "deleted_lines": [
                "  tree->lengths = (unsigned*)realloc(tree->lengths, numcodes * sizeof(unsigned));"
            ],
            "added_lines": [
                "\tunsigned* lengths;",
                "  lengths = (unsigned*)realloc(tree->lengths, numcodes * sizeof(unsigned));",
                "\tif (!lengths)",
                "\t\tfree(tree->lengths);",
                "\ttree->lengths = lengths;"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-17177",
        "func_name": "FreeRDP/tr_esc_str",
        "description": "libfreerdp/codec/region.c in FreeRDP through 1.1.x and 2.x through 2.0.0-rc4 has memory leaks because a supplied realloc pointer (i.e., the first argument to realloc) is also used for a realloc return value.",
        "git_url": "https://github.com/FreeRDP/FreeRDP/commit/9fee4ae076b1ec97b97efb79ece08d1dab4df29a",
        "commit_title": "Fixed #5645: realloc return handling",
        "commit_text": "",
        "func_before": "LPSTR tr_esc_str(LPCSTR arg, bool format)\n{\n\tLPSTR tmp = NULL;\n\tsize_t cs = 0, x, ds, len;\n\tsize_t s;\n\n\tif (NULL == arg)\n\t\treturn NULL;\n\n\ts = strlen(arg);\n\n\t/* Find trailing whitespaces */\n\twhile ((s > 0) && isspace(arg[s - 1]))\n\t\ts--;\n\n\t/* Prepare a initial buffer with the size of the result string. */\n\tds = s + 1;\n\n\tif (s)\n\t\ttmp = (LPSTR)realloc(tmp, ds * sizeof(CHAR));\n\n\tif (NULL == tmp)\n\t{\n\t\tfprintf(stderr,  \"Could not allocate string buffer.\\n\");\n\t\texit(-2);\n\t}\n\n\t/* Copy character for character and check, if it is necessary to escape. */\n\tmemset(tmp, 0, ds * sizeof(CHAR));\n\n\tfor (x = 0; x < s; x++)\n\t{\n\t\tswitch (arg[x])\n\t\t{\n\t\t\tcase '<':\n\t\t\t\tlen = format ? 13 : 4;\n\t\t\t\tds += len - 1;\n\t\t\t\ttmp = (LPSTR)realloc(tmp, ds * sizeof(CHAR));\n\n\t\t\t\tif (NULL == tmp)\n\t\t\t\t{\n\t\t\t\t\tfprintf(stderr,  \"Could not reallocate string buffer.\\n\");\n\t\t\t\t\texit(-3);\n\t\t\t\t}\n\n\t\t\t\tif (format)\n\t\t\t\t\t/* coverity[buffer_size] */\n\t\t\t\t\tstrncpy(&tmp[cs], \"<replaceable>\", len);\n\t\t\t\telse\n\t\t\t\t\t/* coverity[buffer_size] */\n\t\t\t\t\tstrncpy(&tmp[cs], \"&lt;\", len);\n\n\t\t\t\tcs += len;\n\t\t\t\tbreak;\n\n\t\t\tcase '>':\n\t\t\t\tlen = format ? 14 : 4;\n\t\t\t\tds += len - 1;\n\t\t\t\ttmp = (LPSTR)realloc(tmp, ds * sizeof(CHAR));\n\n\t\t\t\tif (NULL == tmp)\n\t\t\t\t{\n\t\t\t\t\tfprintf(stderr,  \"Could not reallocate string buffer.\\n\");\n\t\t\t\t\texit(-4);\n\t\t\t\t}\n\n\t\t\t\tif (format)\n\t\t\t\t\t/* coverity[buffer_size] */\n\t\t\t\t\tstrncpy(&tmp[cs], \"</replaceable>\", len);\n\t\t\t\telse\n\t\t\t\t\t/* coverity[buffer_size] */\n\t\t\t\t\tstrncpy(&tmp[cs], \"&lt;\", len);\n\n\t\t\t\tcs += len;\n\t\t\t\tbreak;\n\n\t\t\tcase '\\'':\n\t\t\t\tds += 5;\n\t\t\t\ttmp = (LPSTR)realloc(tmp, ds * sizeof(CHAR));\n\n\t\t\t\tif (NULL == tmp)\n\t\t\t\t{\n\t\t\t\t\tfprintf(stderr,  \"Could not reallocate string buffer.\\n\");\n\t\t\t\t\texit(-5);\n\t\t\t\t}\n\n\t\t\t\ttmp[cs++] = '&';\n\t\t\t\ttmp[cs++] = 'a';\n\t\t\t\ttmp[cs++] = 'p';\n\t\t\t\ttmp[cs++] = 'o';\n\t\t\t\ttmp[cs++] = 's';\n\t\t\t\ttmp[cs++] = ';';\n\t\t\t\tbreak;\n\n\t\t\tcase '\"':\n\t\t\t\tds += 5;\n\t\t\t\ttmp = (LPSTR)realloc(tmp, ds * sizeof(CHAR));\n\n\t\t\t\tif (NULL == tmp)\n\t\t\t\t{\n\t\t\t\t\tfprintf(stderr,  \"Could not reallocate string buffer.\\n\");\n\t\t\t\t\texit(-6);\n\t\t\t\t}\n\n\t\t\t\ttmp[cs++] = '&';\n\t\t\t\ttmp[cs++] = 'q';\n\t\t\t\ttmp[cs++] = 'u';\n\t\t\t\ttmp[cs++] = 'o';\n\t\t\t\ttmp[cs++] = 't';\n\t\t\t\ttmp[cs++] = ';';\n\t\t\t\tbreak;\n\n\t\t\tcase '&':\n\t\t\t\tds += 4;\n\t\t\t\ttmp = (LPSTR)realloc(tmp, ds * sizeof(CHAR));\n\n\t\t\t\tif (NULL == tmp)\n\t\t\t\t{\n\t\t\t\t\tfprintf(stderr,  \"Could not reallocate string buffer.\\n\");\n\t\t\t\t\texit(-7);\n\t\t\t\t}\n\n\t\t\t\ttmp[cs++] = '&';\n\t\t\t\ttmp[cs++] = 'a';\n\t\t\t\ttmp[cs++] = 'm';\n\t\t\t\ttmp[cs++] = 'p';\n\t\t\t\ttmp[cs++] = ';';\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\ttmp[cs++] = arg[x];\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* Assure, the string is '\\0' terminated. */\n\t\ttmp[ds - 1] = '\\0';\n\t}\n\n\treturn tmp;\n}",
        "func": "LPSTR tr_esc_str(LPCSTR arg, bool format)\n{\n\tLPSTR tmp = NULL;\n\tLPSTR tmp2 = NULL;\n\tsize_t cs = 0, x, ds, len;\n\tsize_t s;\n\n\tif (NULL == arg)\n\t\treturn NULL;\n\n\ts = strlen(arg);\n\n\t/* Find trailing whitespaces */\n\twhile ((s > 0) && isspace(arg[s - 1]))\n\t\ts--;\n\n\t/* Prepare a initial buffer with the size of the result string. */\n\tds = s + 1;\n\n\tif (s)\n\t{\n\t\ttmp2 = (LPSTR)realloc(tmp, ds * sizeof(CHAR));\n\t\tif (!tmp2)\n\t\t\tfree(tmp);\n\t\ttmp = tmp2;\n\t}\n\n\tif (NULL == tmp)\n\t{\n\t\tfprintf(stderr,  \"Could not allocate string buffer.\\n\");\n\t\texit(-2);\n\t}\n\n\t/* Copy character for character and check, if it is necessary to escape. */\n\tmemset(tmp, 0, ds * sizeof(CHAR));\n\n\tfor (x = 0; x < s; x++)\n\t{\n\t\tswitch (arg[x])\n\t\t{\n\t\t\tcase '<':\n\t\t\t\tlen = format ? 13 : 4;\n\t\t\t\tds += len - 1;\n\t\t\t\ttmp2 = (LPSTR)realloc(tmp, ds * sizeof(CHAR));\n\t\t\t\tif (!tmp2)\n\t\t\t\t\tfree(tmp);\n\t\t\t\ttmp = tmp2;\n\n\t\t\t\tif (NULL == tmp)\n\t\t\t\t{\n\t\t\t\t\tfprintf(stderr,  \"Could not reallocate string buffer.\\n\");\n\t\t\t\t\texit(-3);\n\t\t\t\t}\n\n\t\t\t\tif (format)\n\t\t\t\t\t/* coverity[buffer_size] */\n\t\t\t\t\tstrncpy(&tmp[cs], \"<replaceable>\", len);\n\t\t\t\telse\n\t\t\t\t\t/* coverity[buffer_size] */\n\t\t\t\t\tstrncpy(&tmp[cs], \"&lt;\", len);\n\n\t\t\t\tcs += len;\n\t\t\t\tbreak;\n\n\t\t\tcase '>':\n\t\t\t\tlen = format ? 14 : 4;\n\t\t\t\tds += len - 1;\n\t\t\t\ttmp2 = (LPSTR)realloc(tmp, ds * sizeof(CHAR));\n\t\t\t\tif (!tmp2)\n\t\t\t\t\tfree(tmp);\n\t\t\t\ttmp = tmp2;\n\n\t\t\t\tif (NULL == tmp)\n\t\t\t\t{\n\t\t\t\t\tfprintf(stderr,  \"Could not reallocate string buffer.\\n\");\n\t\t\t\t\texit(-4);\n\t\t\t\t}\n\n\t\t\t\tif (format)\n\t\t\t\t\t/* coverity[buffer_size] */\n\t\t\t\t\tstrncpy(&tmp[cs], \"</replaceable>\", len);\n\t\t\t\telse\n\t\t\t\t\t/* coverity[buffer_size] */\n\t\t\t\t\tstrncpy(&tmp[cs], \"&lt;\", len);\n\n\t\t\t\tcs += len;\n\t\t\t\tbreak;\n\n\t\t\tcase '\\'':\n\t\t\t\tds += 5;\n\t\t\t\ttmp2 = (LPSTR)realloc(tmp, ds * sizeof(CHAR));\n\t\t\t\tif (!tmp2)\n\t\t\t\t\tfree(tmp);\n\t\t\t\ttmp = tmp2;\n\n\t\t\t\tif (NULL == tmp)\n\t\t\t\t{\n\t\t\t\t\tfprintf(stderr,  \"Could not reallocate string buffer.\\n\");\n\t\t\t\t\texit(-5);\n\t\t\t\t}\n\n\t\t\t\ttmp[cs++] = '&';\n\t\t\t\ttmp[cs++] = 'a';\n\t\t\t\ttmp[cs++] = 'p';\n\t\t\t\ttmp[cs++] = 'o';\n\t\t\t\ttmp[cs++] = 's';\n\t\t\t\ttmp[cs++] = ';';\n\t\t\t\tbreak;\n\n\t\t\tcase '\"':\n\t\t\t\tds += 5;\n\t\t\t\ttmp2 = (LPSTR)realloc(tmp, ds * sizeof(CHAR));\n\t\t\t\tif (!tmp2)\n\t\t\t\t\tfree(tmp);\n\t\t\t\ttmp = tmp2;\n\n\t\t\t\tif (NULL == tmp)\n\t\t\t\t{\n\t\t\t\t\tfprintf(stderr,  \"Could not reallocate string buffer.\\n\");\n\t\t\t\t\texit(-6);\n\t\t\t\t}\n\n\t\t\t\ttmp[cs++] = '&';\n\t\t\t\ttmp[cs++] = 'q';\n\t\t\t\ttmp[cs++] = 'u';\n\t\t\t\ttmp[cs++] = 'o';\n\t\t\t\ttmp[cs++] = 't';\n\t\t\t\ttmp[cs++] = ';';\n\t\t\t\tbreak;\n\n\t\t\tcase '&':\n\t\t\t\tds += 4;\n\t\t\t\ttmp2 = (LPSTR)realloc(tmp, ds * sizeof(CHAR));\n\t\t\t\tif (!tmp2)\n\t\t\t\t\tfree(tmp);\n\t\t\t\ttmp = tmp2;\n\n\t\t\t\tif (NULL == tmp)\n\t\t\t\t{\n\t\t\t\t\tfprintf(stderr,  \"Could not reallocate string buffer.\\n\");\n\t\t\t\t\texit(-7);\n\t\t\t\t}\n\n\t\t\t\ttmp[cs++] = '&';\n\t\t\t\ttmp[cs++] = 'a';\n\t\t\t\ttmp[cs++] = 'm';\n\t\t\t\ttmp[cs++] = 'p';\n\t\t\t\ttmp[cs++] = ';';\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\ttmp[cs++] = arg[x];\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* Assure, the string is '\\0' terminated. */\n\t\ttmp[ds - 1] = '\\0';\n\t}\n\n\treturn tmp;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,7 @@\n LPSTR tr_esc_str(LPCSTR arg, bool format)\n {\n \tLPSTR tmp = NULL;\n+\tLPSTR tmp2 = NULL;\n \tsize_t cs = 0, x, ds, len;\n \tsize_t s;\n \n@@ -17,7 +18,12 @@\n \tds = s + 1;\n \n \tif (s)\n-\t\ttmp = (LPSTR)realloc(tmp, ds * sizeof(CHAR));\n+\t{\n+\t\ttmp2 = (LPSTR)realloc(tmp, ds * sizeof(CHAR));\n+\t\tif (!tmp2)\n+\t\t\tfree(tmp);\n+\t\ttmp = tmp2;\n+\t}\n \n \tif (NULL == tmp)\n \t{\n@@ -35,7 +41,10 @@\n \t\t\tcase '<':\n \t\t\t\tlen = format ? 13 : 4;\n \t\t\t\tds += len - 1;\n-\t\t\t\ttmp = (LPSTR)realloc(tmp, ds * sizeof(CHAR));\n+\t\t\t\ttmp2 = (LPSTR)realloc(tmp, ds * sizeof(CHAR));\n+\t\t\t\tif (!tmp2)\n+\t\t\t\t\tfree(tmp);\n+\t\t\t\ttmp = tmp2;\n \n \t\t\t\tif (NULL == tmp)\n \t\t\t\t{\n@@ -56,7 +65,10 @@\n \t\t\tcase '>':\n \t\t\t\tlen = format ? 14 : 4;\n \t\t\t\tds += len - 1;\n-\t\t\t\ttmp = (LPSTR)realloc(tmp, ds * sizeof(CHAR));\n+\t\t\t\ttmp2 = (LPSTR)realloc(tmp, ds * sizeof(CHAR));\n+\t\t\t\tif (!tmp2)\n+\t\t\t\t\tfree(tmp);\n+\t\t\t\ttmp = tmp2;\n \n \t\t\t\tif (NULL == tmp)\n \t\t\t\t{\n@@ -76,7 +88,10 @@\n \n \t\t\tcase '\\'':\n \t\t\t\tds += 5;\n-\t\t\t\ttmp = (LPSTR)realloc(tmp, ds * sizeof(CHAR));\n+\t\t\t\ttmp2 = (LPSTR)realloc(tmp, ds * sizeof(CHAR));\n+\t\t\t\tif (!tmp2)\n+\t\t\t\t\tfree(tmp);\n+\t\t\t\ttmp = tmp2;\n \n \t\t\t\tif (NULL == tmp)\n \t\t\t\t{\n@@ -94,7 +109,10 @@\n \n \t\t\tcase '\"':\n \t\t\t\tds += 5;\n-\t\t\t\ttmp = (LPSTR)realloc(tmp, ds * sizeof(CHAR));\n+\t\t\t\ttmp2 = (LPSTR)realloc(tmp, ds * sizeof(CHAR));\n+\t\t\t\tif (!tmp2)\n+\t\t\t\t\tfree(tmp);\n+\t\t\t\ttmp = tmp2;\n \n \t\t\t\tif (NULL == tmp)\n \t\t\t\t{\n@@ -112,7 +130,10 @@\n \n \t\t\tcase '&':\n \t\t\t\tds += 4;\n-\t\t\t\ttmp = (LPSTR)realloc(tmp, ds * sizeof(CHAR));\n+\t\t\t\ttmp2 = (LPSTR)realloc(tmp, ds * sizeof(CHAR));\n+\t\t\t\tif (!tmp2)\n+\t\t\t\t\tfree(tmp);\n+\t\t\t\ttmp = tmp2;\n \n \t\t\t\tif (NULL == tmp)\n \t\t\t\t{",
        "diff_line_info": {
            "deleted_lines": [
                "\t\ttmp = (LPSTR)realloc(tmp, ds * sizeof(CHAR));",
                "\t\t\t\ttmp = (LPSTR)realloc(tmp, ds * sizeof(CHAR));",
                "\t\t\t\ttmp = (LPSTR)realloc(tmp, ds * sizeof(CHAR));",
                "\t\t\t\ttmp = (LPSTR)realloc(tmp, ds * sizeof(CHAR));",
                "\t\t\t\ttmp = (LPSTR)realloc(tmp, ds * sizeof(CHAR));",
                "\t\t\t\ttmp = (LPSTR)realloc(tmp, ds * sizeof(CHAR));"
            ],
            "added_lines": [
                "\tLPSTR tmp2 = NULL;",
                "\t{",
                "\t\ttmp2 = (LPSTR)realloc(tmp, ds * sizeof(CHAR));",
                "\t\tif (!tmp2)",
                "\t\t\tfree(tmp);",
                "\t\ttmp = tmp2;",
                "\t}",
                "\t\t\t\ttmp2 = (LPSTR)realloc(tmp, ds * sizeof(CHAR));",
                "\t\t\t\tif (!tmp2)",
                "\t\t\t\t\tfree(tmp);",
                "\t\t\t\ttmp = tmp2;",
                "\t\t\t\ttmp2 = (LPSTR)realloc(tmp, ds * sizeof(CHAR));",
                "\t\t\t\tif (!tmp2)",
                "\t\t\t\t\tfree(tmp);",
                "\t\t\t\ttmp = tmp2;",
                "\t\t\t\ttmp2 = (LPSTR)realloc(tmp, ds * sizeof(CHAR));",
                "\t\t\t\tif (!tmp2)",
                "\t\t\t\t\tfree(tmp);",
                "\t\t\t\ttmp = tmp2;",
                "\t\t\t\ttmp2 = (LPSTR)realloc(tmp, ds * sizeof(CHAR));",
                "\t\t\t\tif (!tmp2)",
                "\t\t\t\t\tfree(tmp);",
                "\t\t\t\ttmp = tmp2;",
                "\t\t\t\ttmp2 = (LPSTR)realloc(tmp, ds * sizeof(CHAR));",
                "\t\t\t\tif (!tmp2)",
                "\t\t\t\t\tfree(tmp);",
                "\t\t\t\ttmp = tmp2;"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-15900",
        "func_name": "slicer69/doas/parsegid",
        "description": "An issue was discovered in slicer69 doas before 6.2 on certain platforms other than OpenBSD. On platforms without strtonum(3), sscanf was used without checking for error cases. Instead, the uninitialized variable errstr was checked and in some cases returned success even if sscanf failed. The result was that, instead of reporting that the supplied username or group name did not exist, it would execute the command as root.",
        "git_url": "https://github.com/slicer69/doas/commit/2f83222829448e5bc4c9391d607ec265a1e06531",
        "commit_title": "Added optimization to Makefile (can be set/overruled using OPT).",
        "commit_text": "Added flag to display all warnings during compiling. Added status checks when parsing user/group IDs for Linux. Make sure Linux drops original user's groups when running as another user.",
        "func_before": "static int\nparsegid(const char *s, gid_t *gid)\n{\n\tstruct group *gr;\n\tconst char *errstr;\n\n\tif ((gr = getgrnam(s)) != NULL) {\n\t\t*gid = gr->gr_gid;\n\t\treturn 0;\n\t}\n\t#if !defined(__linux__) && !defined(__NetBSD__)\n\t*gid = strtonum(s, 0, GID_MAX, &errstr);\n\t#else\n\tsscanf(s, \"%d\", gid);\n\t#endif\n\tif (errstr)\n\t\treturn -1;\n\treturn 0;\n}",
        "func": "static int\nparsegid(const char *s, gid_t *gid)\n{\n\tstruct group *gr;\n\t#if !defined(__linux__) && !defined(__NetBSD__)\n\tconst char *errstr = NULL;\n        #else\n        int status;\n        #endif\n\n\tif ((gr = getgrnam(s)) != NULL) {\n\t\t*gid = gr->gr_gid;\n\t\treturn 0;\n\t}\n\t#if !defined(__linux__) && !defined(__NetBSD__)\n\t*gid = strtonum(s, 0, GID_MAX, &errstr);\n\tif (errstr)\n\t\treturn -1;\n\t#else\n\tstatus = sscanf(s, \"%d\", gid);\n        if (status != 1)\n            return -1;\n\t#endif\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,7 +2,11 @@\n parsegid(const char *s, gid_t *gid)\n {\n \tstruct group *gr;\n-\tconst char *errstr;\n+\t#if !defined(__linux__) && !defined(__NetBSD__)\n+\tconst char *errstr = NULL;\n+        #else\n+        int status;\n+        #endif\n \n \tif ((gr = getgrnam(s)) != NULL) {\n \t\t*gid = gr->gr_gid;\n@@ -10,10 +14,12 @@\n \t}\n \t#if !defined(__linux__) && !defined(__NetBSD__)\n \t*gid = strtonum(s, 0, GID_MAX, &errstr);\n-\t#else\n-\tsscanf(s, \"%d\", gid);\n-\t#endif\n \tif (errstr)\n \t\treturn -1;\n+\t#else\n+\tstatus = sscanf(s, \"%d\", gid);\n+        if (status != 1)\n+            return -1;\n+\t#endif\n \treturn 0;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tconst char *errstr;",
                "\t#else",
                "\tsscanf(s, \"%d\", gid);",
                "\t#endif"
            ],
            "added_lines": [
                "\t#if !defined(__linux__) && !defined(__NetBSD__)",
                "\tconst char *errstr = NULL;",
                "        #else",
                "        int status;",
                "        #endif",
                "\t#else",
                "\tstatus = sscanf(s, \"%d\", gid);",
                "        if (status != 1)",
                "            return -1;",
                "\t#endif"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-15900",
        "func_name": "slicer69/doas/parseuid",
        "description": "An issue was discovered in slicer69 doas before 6.2 on certain platforms other than OpenBSD. On platforms without strtonum(3), sscanf was used without checking for error cases. Instead, the uninitialized variable errstr was checked and in some cases returned success even if sscanf failed. The result was that, instead of reporting that the supplied username or group name did not exist, it would execute the command as root.",
        "git_url": "https://github.com/slicer69/doas/commit/2f83222829448e5bc4c9391d607ec265a1e06531",
        "commit_title": "Added optimization to Makefile (can be set/overruled using OPT).",
        "commit_text": "Added flag to display all warnings during compiling. Added status checks when parsing user/group IDs for Linux. Make sure Linux drops original user's groups when running as another user.",
        "func_before": "static int\nparseuid(const char *s, uid_t *uid)\n{\n\tstruct passwd *pw;\n\tconst char *errstr;\n\n\tif ((pw = getpwnam(s)) != NULL) {\n\t\t*uid = pw->pw_uid;\n\t\treturn 0;\n\t}\n\t#if !defined(__linux__) && !defined(__NetBSD__)\n\t*uid = strtonum(s, 0, UID_MAX, &errstr);\n\t#else\n\tsscanf(s, \"%d\", uid);\n\t#endif\n\tif (errstr)\n\t\treturn -1;\n\treturn 0;\n}",
        "func": "static int\nparseuid(const char *s, uid_t *uid)\n{\n\tstruct passwd *pw;\n\t#if !defined(__linux__) && !defined(__NetBSD__)\n\tconst char *errstr = NULL;\n        #else\n        int status;\n        #endif\n\n\tif ((pw = getpwnam(s)) != NULL) {\n\t\t*uid = pw->pw_uid;\n\t\treturn 0;\n\t}\n\t#if !defined(__linux__) && !defined(__NetBSD__)\n\t*uid = strtonum(s, 0, UID_MAX, &errstr);\n\tif (errstr)\n\t\treturn -1;\n\t#else\n\tstatus = sscanf(s, \"%d\", uid);\n        if (status != 1)\n           return -1;\n\t#endif\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,7 +2,11 @@\n parseuid(const char *s, uid_t *uid)\n {\n \tstruct passwd *pw;\n-\tconst char *errstr;\n+\t#if !defined(__linux__) && !defined(__NetBSD__)\n+\tconst char *errstr = NULL;\n+        #else\n+        int status;\n+        #endif\n \n \tif ((pw = getpwnam(s)) != NULL) {\n \t\t*uid = pw->pw_uid;\n@@ -10,10 +14,12 @@\n \t}\n \t#if !defined(__linux__) && !defined(__NetBSD__)\n \t*uid = strtonum(s, 0, UID_MAX, &errstr);\n-\t#else\n-\tsscanf(s, \"%d\", uid);\n-\t#endif\n \tif (errstr)\n \t\treturn -1;\n+\t#else\n+\tstatus = sscanf(s, \"%d\", uid);\n+        if (status != 1)\n+           return -1;\n+\t#endif\n \treturn 0;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tconst char *errstr;",
                "\t#else",
                "\tsscanf(s, \"%d\", uid);",
                "\t#endif"
            ],
            "added_lines": [
                "\t#if !defined(__linux__) && !defined(__NetBSD__)",
                "\tconst char *errstr = NULL;",
                "        #else",
                "        int status;",
                "        #endif",
                "\t#else",
                "\tstatus = sscanf(s, \"%d\", uid);",
                "        if (status != 1)",
                "           return -1;",
                "\t#endif"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-0485",
        "func_name": "nbdkit/libnbd/free_command",
        "description": "A flaw was found in the copying tool `nbdcopy` of libnbd. When performing multi-threaded copies using asynchronous nbd calls, nbdcopy was blindly treating the completion of an asynchronous command as successful, rather than checking the *error parameter. This could result in the silent creation of a corrupted destination image.",
        "git_url": "https://gitlab.com/nbdkit/libnbd/-/commit/8d444b41d09a700c7ee6f9182a649f3f2d325abb",
        "commit_title": "copy: CVE-2022-0485: Fail nbdcopy if NBD read or write fails",
        "commit_text": " nbdcopy has a nasty bug when performing multi-threaded copies using asynchronous nbd calls - it was blindly treating the completion of an asynchronous command as successful, rather than checking the *error parameter.  This can result in the silent creation of a corrupted image in two different ways: when a read fails, we blindly wrote garbage to the destination; when a write fails, we did not flag that the destination was not written.  Since nbdcopy already calls exit() on a synchronous read or write failure to a file, doing the same for an asynchronous op to an NBD server is the simplest solution.  A nicer solution, but more invasive to code and thus not done here, might be to allow up to N retries of the transaction (in case the read or write failure was transient), or even having a mode where as much data is copied as possible (portions of the copy that failed would be logged on stderr, and nbdcopy would still fail with a non-zero exit status, but this would copy more than just stopping at the first error, as can be done with rsync or ddrescue).  Note that since we rely on auto-retiring and do NOT call nbd_aio_command_completed, our completion callbacks must always return 1 (if they do not exit() first), even when acting on *error, so as not leave the command allocated until nbd_close.  As such, there is no sane way to return an error to a manual caller of the callback, and therefore we can drop dead code that calls perror() and exit() if the callback \"failed\".  It is also worth documenting the contract on when we must manually call the callback during the asynch_zero callback, so that we do not leak or double-free the command; thankfully, all the existing code paths were correct.  The added testsuite script demonstrates several scenarios, some of which fail without the rest of this patch in place, and others which showcase ways in which sparse images can bypass errors.  Once backports are complete, a followup patch on the main branch will edit docs/libnbd-security.pod with the mailing list announcement of the stable branch commit ids and release versions that incorporate this fix.  Message-Id: <20220203202558.203013-6-eblake@redhat.com> [eblake: fix error message per Nir, tweak requires lines in unit test per Rich] ",
        "func_before": "static int\nfree_command (void *vp, int *error)\n{\n  struct command *command = vp;\n  struct buffer *buffer = command->slice.buffer;\n\n  if (buffer != NULL) {\n    if (--buffer->refs == 0) {\n      free (buffer->data);\n      free (buffer);\n    }\n  }\n\n  free (command);\n\n  return 1; /* auto-retires the command */\n}",
        "func": "static int\nfree_command (void *vp, int *error)\n{\n  struct command *command = vp;\n  struct buffer *buffer = command->slice.buffer;\n\n  if (*error) {\n    fprintf (stderr, \"write at offset %\" PRId64 \" failed: %s\\n\",\n             command->offset, strerror (*error));\n    exit (EXIT_FAILURE);\n  }\n\n  if (buffer != NULL) {\n    if (--buffer->refs == 0) {\n      free (buffer->data);\n      free (buffer);\n    }\n  }\n\n  free (command);\n\n  return 1; /* auto-retires the command */\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,6 +3,12 @@\n {\n   struct command *command = vp;\n   struct buffer *buffer = command->slice.buffer;\n+\n+  if (*error) {\n+    fprintf (stderr, \"write at offset %\" PRId64 \" failed: %s\\n\",\n+             command->offset, strerror (*error));\n+    exit (EXIT_FAILURE);\n+  }\n \n   if (buffer != NULL) {\n     if (--buffer->refs == 0) {",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "  if (*error) {",
                "    fprintf (stderr, \"write at offset %\" PRId64 \" failed: %s\\n\",",
                "             command->offset, strerror (*error));",
                "    exit (EXIT_FAILURE);",
                "  }"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-0485",
        "func_name": "nbdkit/libnbd/finished_read",
        "description": "A flaw was found in the copying tool `nbdcopy` of libnbd. When performing multi-threaded copies using asynchronous nbd calls, nbdcopy was blindly treating the completion of an asynchronous command as successful, rather than checking the *error parameter. This could result in the silent creation of a corrupted destination image.",
        "git_url": "https://gitlab.com/nbdkit/libnbd/-/commit/8d444b41d09a700c7ee6f9182a649f3f2d325abb",
        "commit_title": "copy: CVE-2022-0485: Fail nbdcopy if NBD read or write fails",
        "commit_text": " nbdcopy has a nasty bug when performing multi-threaded copies using asynchronous nbd calls - it was blindly treating the completion of an asynchronous command as successful, rather than checking the *error parameter.  This can result in the silent creation of a corrupted image in two different ways: when a read fails, we blindly wrote garbage to the destination; when a write fails, we did not flag that the destination was not written.  Since nbdcopy already calls exit() on a synchronous read or write failure to a file, doing the same for an asynchronous op to an NBD server is the simplest solution.  A nicer solution, but more invasive to code and thus not done here, might be to allow up to N retries of the transaction (in case the read or write failure was transient), or even having a mode where as much data is copied as possible (portions of the copy that failed would be logged on stderr, and nbdcopy would still fail with a non-zero exit status, but this would copy more than just stopping at the first error, as can be done with rsync or ddrescue).  Note that since we rely on auto-retiring and do NOT call nbd_aio_command_completed, our completion callbacks must always return 1 (if they do not exit() first), even when acting on *error, so as not leave the command allocated until nbd_close.  As such, there is no sane way to return an error to a manual caller of the callback, and therefore we can drop dead code that calls perror() and exit() if the callback \"failed\".  It is also worth documenting the contract on when we must manually call the callback during the asynch_zero callback, so that we do not leak or double-free the command; thankfully, all the existing code paths were correct.  The added testsuite script demonstrates several scenarios, some of which fail without the rest of this patch in place, and others which showcase ways in which sparse images can bypass errors.  Once backports are complete, a followup patch on the main branch will edit docs/libnbd-security.pod with the mailing list announcement of the stable branch commit ids and release versions that incorporate this fix.  Message-Id: <20220203202558.203013-6-eblake@redhat.com> [eblake: fix error message per Nir, tweak requires lines in unit test per Rich] ",
        "func_before": "static int\nfinished_read (void *vp, int *error)\n{\n  struct command *command = vp;\n\n  if (allocated || sparse_size == 0) {\n    /* If sparseness detection (see below) is turned off then we write\n     * the whole command.\n     */\n    dst->ops->asynch_write (dst, command,\n                            (nbd_completion_callback) {\n                              .callback = free_command,\n                              .user_data = command,\n                            });\n  }\n  else {                               /* Sparseness detection. */\n    const uint64_t start = command->offset;\n    const uint64_t end = start + command->slice.len;\n    uint64_t last_offset = start;\n    bool last_is_hole = false;\n    uint64_t i;\n    struct command *newcommand;\n    int dummy = 0;\n\n    /* Iterate over whole blocks in the command, starting on a block\n     * boundary.\n     */\n    for (i = MIN (ROUND_UP (start, sparse_size), end);\n         i + sparse_size <= end;\n         i += sparse_size) {\n      if (is_zero (slice_ptr (command->slice) + i-start, sparse_size)) {\n        /* It's a hole.  If the last was a hole too then we do nothing\n         * here which coalesces.  Otherwise write the last data and\n         * start a new hole.\n         */\n        if (!last_is_hole) {\n          /* Write the last data (if any). */\n          if (i - last_offset > 0) {\n            newcommand = copy_subcommand (command,\n                                          last_offset, i - last_offset,\n                                          false);\n            dst->ops->asynch_write (dst, newcommand,\n                                    (nbd_completion_callback) {\n                                      .callback = free_command,\n                                      .user_data = newcommand,\n                                    });\n          }\n          /* Start the new hole. */\n          last_offset = i;\n          last_is_hole = true;\n        }\n      }\n      else {\n        /* It's data.  If the last was data too, do nothing =>\n         * coalesce.  Otherwise write the last hole and start a new\n         * data.\n         */\n        if (last_is_hole) {\n          /* Write the last hole (if any). */\n          if (i - last_offset > 0) {\n            newcommand = copy_subcommand (command,\n                                          last_offset, i - last_offset,\n                                          true);\n            fill_dst_range_with_zeroes (newcommand);\n          }\n          /* Start the new data. */\n          last_offset = i;\n          last_is_hole = false;\n        }\n      }\n    } /* for i */\n\n    /* Write the last_offset up to i. */\n    if (i - last_offset > 0) {\n      if (!last_is_hole) {\n        newcommand = copy_subcommand (command,\n                                      last_offset, i - last_offset,\n                                      false);\n        dst->ops->asynch_write (dst, newcommand,\n                                (nbd_completion_callback) {\n                                  .callback = free_command,\n                                  .user_data = newcommand,\n                                });\n      }\n      else {\n        newcommand = copy_subcommand (command,\n                                      last_offset, i - last_offset,\n                                      true);\n        fill_dst_range_with_zeroes (newcommand);\n      }\n    }\n\n    /* There may be an unaligned tail, so write that. */\n    if (end - i > 0) {\n      newcommand = copy_subcommand (command, i, end - i, false);\n      dst->ops->asynch_write (dst, newcommand,\n                              (nbd_completion_callback) {\n                                .callback = free_command,\n                                .user_data = newcommand,\n                              });\n    }\n\n    /* Free the original command since it has been split into\n     * subcommands and the original is no longer needed.\n     */\n    free_command (command, &dummy);\n  }\n\n  return 1; /* auto-retires the command */\n}",
        "func": "static int\nfinished_read (void *vp, int *error)\n{\n  struct command *command = vp;\n\n  if (*error) {\n    fprintf (stderr, \"read at offset %\" PRId64 \" failed: %s\\n\",\n             command->offset, strerror (*error));\n    exit (EXIT_FAILURE);\n  }\n\n  if (allocated || sparse_size == 0) {\n    /* If sparseness detection (see below) is turned off then we write\n     * the whole command.\n     */\n    dst->ops->asynch_write (dst, command,\n                            (nbd_completion_callback) {\n                              .callback = free_command,\n                              .user_data = command,\n                            });\n  }\n  else {                               /* Sparseness detection. */\n    const uint64_t start = command->offset;\n    const uint64_t end = start + command->slice.len;\n    uint64_t last_offset = start;\n    bool last_is_hole = false;\n    uint64_t i;\n    struct command *newcommand;\n    int dummy = 0;\n\n    /* Iterate over whole blocks in the command, starting on a block\n     * boundary.\n     */\n    for (i = MIN (ROUND_UP (start, sparse_size), end);\n         i + sparse_size <= end;\n         i += sparse_size) {\n      if (is_zero (slice_ptr (command->slice) + i-start, sparse_size)) {\n        /* It's a hole.  If the last was a hole too then we do nothing\n         * here which coalesces.  Otherwise write the last data and\n         * start a new hole.\n         */\n        if (!last_is_hole) {\n          /* Write the last data (if any). */\n          if (i - last_offset > 0) {\n            newcommand = copy_subcommand (command,\n                                          last_offset, i - last_offset,\n                                          false);\n            dst->ops->asynch_write (dst, newcommand,\n                                    (nbd_completion_callback) {\n                                      .callback = free_command,\n                                      .user_data = newcommand,\n                                    });\n          }\n          /* Start the new hole. */\n          last_offset = i;\n          last_is_hole = true;\n        }\n      }\n      else {\n        /* It's data.  If the last was data too, do nothing =>\n         * coalesce.  Otherwise write the last hole and start a new\n         * data.\n         */\n        if (last_is_hole) {\n          /* Write the last hole (if any). */\n          if (i - last_offset > 0) {\n            newcommand = copy_subcommand (command,\n                                          last_offset, i - last_offset,\n                                          true);\n            fill_dst_range_with_zeroes (newcommand);\n          }\n          /* Start the new data. */\n          last_offset = i;\n          last_is_hole = false;\n        }\n      }\n    } /* for i */\n\n    /* Write the last_offset up to i. */\n    if (i - last_offset > 0) {\n      if (!last_is_hole) {\n        newcommand = copy_subcommand (command,\n                                      last_offset, i - last_offset,\n                                      false);\n        dst->ops->asynch_write (dst, newcommand,\n                                (nbd_completion_callback) {\n                                  .callback = free_command,\n                                  .user_data = newcommand,\n                                });\n      }\n      else {\n        newcommand = copy_subcommand (command,\n                                      last_offset, i - last_offset,\n                                      true);\n        fill_dst_range_with_zeroes (newcommand);\n      }\n    }\n\n    /* There may be an unaligned tail, so write that. */\n    if (end - i > 0) {\n      newcommand = copy_subcommand (command, i, end - i, false);\n      dst->ops->asynch_write (dst, newcommand,\n                              (nbd_completion_callback) {\n                                .callback = free_command,\n                                .user_data = newcommand,\n                              });\n    }\n\n    /* Free the original command since it has been split into\n     * subcommands and the original is no longer needed.\n     */\n    free_command (command, &dummy);\n  }\n\n  return 1; /* auto-retires the command */\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,6 +2,12 @@\n finished_read (void *vp, int *error)\n {\n   struct command *command = vp;\n+\n+  if (*error) {\n+    fprintf (stderr, \"read at offset %\" PRId64 \" failed: %s\\n\",\n+             command->offset, strerror (*error));\n+    exit (EXIT_FAILURE);\n+  }\n \n   if (allocated || sparse_size == 0) {\n     /* If sparseness detection (see below) is turned off then we write",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "  if (*error) {",
                "    fprintf (stderr, \"read at offset %\" PRId64 \" failed: %s\\n\",",
                "             command->offset, strerror (*error));",
                "    exit (EXIT_FAILURE);",
                "  }"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-0485",
        "func_name": "nbdkit/libnbd/file_asynch_write",
        "description": "A flaw was found in the copying tool `nbdcopy` of libnbd. When performing multi-threaded copies using asynchronous nbd calls, nbdcopy was blindly treating the completion of an asynchronous command as successful, rather than checking the *error parameter. This could result in the silent creation of a corrupted destination image.",
        "git_url": "https://gitlab.com/nbdkit/libnbd/-/commit/8d444b41d09a700c7ee6f9182a649f3f2d325abb",
        "commit_title": "copy: CVE-2022-0485: Fail nbdcopy if NBD read or write fails",
        "commit_text": " nbdcopy has a nasty bug when performing multi-threaded copies using asynchronous nbd calls - it was blindly treating the completion of an asynchronous command as successful, rather than checking the *error parameter.  This can result in the silent creation of a corrupted image in two different ways: when a read fails, we blindly wrote garbage to the destination; when a write fails, we did not flag that the destination was not written.  Since nbdcopy already calls exit() on a synchronous read or write failure to a file, doing the same for an asynchronous op to an NBD server is the simplest solution.  A nicer solution, but more invasive to code and thus not done here, might be to allow up to N retries of the transaction (in case the read or write failure was transient), or even having a mode where as much data is copied as possible (portions of the copy that failed would be logged on stderr, and nbdcopy would still fail with a non-zero exit status, but this would copy more than just stopping at the first error, as can be done with rsync or ddrescue).  Note that since we rely on auto-retiring and do NOT call nbd_aio_command_completed, our completion callbacks must always return 1 (if they do not exit() first), even when acting on *error, so as not leave the command allocated until nbd_close.  As such, there is no sane way to return an error to a manual caller of the callback, and therefore we can drop dead code that calls perror() and exit() if the callback \"failed\".  It is also worth documenting the contract on when we must manually call the callback during the asynch_zero callback, so that we do not leak or double-free the command; thankfully, all the existing code paths were correct.  The added testsuite script demonstrates several scenarios, some of which fail without the rest of this patch in place, and others which showcase ways in which sparse images can bypass errors.  Once backports are complete, a followup patch on the main branch will edit docs/libnbd-security.pod with the mailing list announcement of the stable branch commit ids and release versions that incorporate this fix.  Message-Id: <20220203202558.203013-6-eblake@redhat.com> [eblake: fix error message per Nir, tweak requires lines in unit test per Rich] ",
        "func_before": "static void\nfile_asynch_write (struct rw *rw,\n                   struct command *command,\n                   nbd_completion_callback cb)\n{\n  int dummy = 0;\n\n  file_synch_write (rw, slice_ptr (command->slice),\n                    command->slice.len, command->offset);\n  if (cb.callback (cb.user_data, &dummy) == -1) {\n    perror (rw->name);\n    exit (EXIT_FAILURE);\n  }\n}",
        "func": "static void\nfile_asynch_write (struct rw *rw,\n                   struct command *command,\n                   nbd_completion_callback cb)\n{\n  int dummy = 0;\n\n  file_synch_write (rw, slice_ptr (command->slice),\n                    command->slice.len, command->offset);\n  /* file_synch_write called exit() on error */\n  cb.callback (cb.user_data, &dummy);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -7,8 +7,6 @@\n \n   file_synch_write (rw, slice_ptr (command->slice),\n                     command->slice.len, command->offset);\n-  if (cb.callback (cb.user_data, &dummy) == -1) {\n-    perror (rw->name);\n-    exit (EXIT_FAILURE);\n-  }\n+  /* file_synch_write called exit() on error */\n+  cb.callback (cb.user_data, &dummy);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "  if (cb.callback (cb.user_data, &dummy) == -1) {",
                "    perror (rw->name);",
                "    exit (EXIT_FAILURE);",
                "  }"
            ],
            "added_lines": [
                "  /* file_synch_write called exit() on error */",
                "  cb.callback (cb.user_data, &dummy);"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-0485",
        "func_name": "nbdkit/libnbd/file_asynch_zero",
        "description": "A flaw was found in the copying tool `nbdcopy` of libnbd. When performing multi-threaded copies using asynchronous nbd calls, nbdcopy was blindly treating the completion of an asynchronous command as successful, rather than checking the *error parameter. This could result in the silent creation of a corrupted destination image.",
        "git_url": "https://gitlab.com/nbdkit/libnbd/-/commit/8d444b41d09a700c7ee6f9182a649f3f2d325abb",
        "commit_title": "copy: CVE-2022-0485: Fail nbdcopy if NBD read or write fails",
        "commit_text": " nbdcopy has a nasty bug when performing multi-threaded copies using asynchronous nbd calls - it was blindly treating the completion of an asynchronous command as successful, rather than checking the *error parameter.  This can result in the silent creation of a corrupted image in two different ways: when a read fails, we blindly wrote garbage to the destination; when a write fails, we did not flag that the destination was not written.  Since nbdcopy already calls exit() on a synchronous read or write failure to a file, doing the same for an asynchronous op to an NBD server is the simplest solution.  A nicer solution, but more invasive to code and thus not done here, might be to allow up to N retries of the transaction (in case the read or write failure was transient), or even having a mode where as much data is copied as possible (portions of the copy that failed would be logged on stderr, and nbdcopy would still fail with a non-zero exit status, but this would copy more than just stopping at the first error, as can be done with rsync or ddrescue).  Note that since we rely on auto-retiring and do NOT call nbd_aio_command_completed, our completion callbacks must always return 1 (if they do not exit() first), even when acting on *error, so as not leave the command allocated until nbd_close.  As such, there is no sane way to return an error to a manual caller of the callback, and therefore we can drop dead code that calls perror() and exit() if the callback \"failed\".  It is also worth documenting the contract on when we must manually call the callback during the asynch_zero callback, so that we do not leak or double-free the command; thankfully, all the existing code paths were correct.  The added testsuite script demonstrates several scenarios, some of which fail without the rest of this patch in place, and others which showcase ways in which sparse images can bypass errors.  Once backports are complete, a followup patch on the main branch will edit docs/libnbd-security.pod with the mailing list announcement of the stable branch commit ids and release versions that incorporate this fix.  Message-Id: <20220203202558.203013-6-eblake@redhat.com> [eblake: fix error message per Nir, tweak requires lines in unit test per Rich] ",
        "func_before": "static bool\nfile_asynch_zero (struct rw *rw, struct command *command,\n                  nbd_completion_callback cb, bool allocate)\n{\n  int dummy = 0;\n\n  if (!file_synch_zero (rw, command->offset, command->slice.len, allocate))\n    return false;\n  if (cb.callback (cb.user_data, &dummy) == -1) {\n    perror (rw->name);\n    exit (EXIT_FAILURE);\n  }\n  return true;\n}",
        "func": "static bool\nfile_asynch_zero (struct rw *rw, struct command *command,\n                  nbd_completion_callback cb, bool allocate)\n{\n  int dummy = 0;\n\n  if (!file_synch_zero (rw, command->offset, command->slice.len, allocate))\n    return false;\n  cb.callback (cb.user_data, &dummy);\n  return true;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,9 +6,6 @@\n \n   if (!file_synch_zero (rw, command->offset, command->slice.len, allocate))\n     return false;\n-  if (cb.callback (cb.user_data, &dummy) == -1) {\n-    perror (rw->name);\n-    exit (EXIT_FAILURE);\n-  }\n+  cb.callback (cb.user_data, &dummy);\n   return true;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "  if (cb.callback (cb.user_data, &dummy) == -1) {",
                "    perror (rw->name);",
                "    exit (EXIT_FAILURE);",
                "  }"
            ],
            "added_lines": [
                "  cb.callback (cb.user_data, &dummy);"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-0485",
        "func_name": "nbdkit/libnbd/file_asynch_read",
        "description": "A flaw was found in the copying tool `nbdcopy` of libnbd. When performing multi-threaded copies using asynchronous nbd calls, nbdcopy was blindly treating the completion of an asynchronous command as successful, rather than checking the *error parameter. This could result in the silent creation of a corrupted destination image.",
        "git_url": "https://gitlab.com/nbdkit/libnbd/-/commit/8d444b41d09a700c7ee6f9182a649f3f2d325abb",
        "commit_title": "copy: CVE-2022-0485: Fail nbdcopy if NBD read or write fails",
        "commit_text": " nbdcopy has a nasty bug when performing multi-threaded copies using asynchronous nbd calls - it was blindly treating the completion of an asynchronous command as successful, rather than checking the *error parameter.  This can result in the silent creation of a corrupted image in two different ways: when a read fails, we blindly wrote garbage to the destination; when a write fails, we did not flag that the destination was not written.  Since nbdcopy already calls exit() on a synchronous read or write failure to a file, doing the same for an asynchronous op to an NBD server is the simplest solution.  A nicer solution, but more invasive to code and thus not done here, might be to allow up to N retries of the transaction (in case the read or write failure was transient), or even having a mode where as much data is copied as possible (portions of the copy that failed would be logged on stderr, and nbdcopy would still fail with a non-zero exit status, but this would copy more than just stopping at the first error, as can be done with rsync or ddrescue).  Note that since we rely on auto-retiring and do NOT call nbd_aio_command_completed, our completion callbacks must always return 1 (if they do not exit() first), even when acting on *error, so as not leave the command allocated until nbd_close.  As such, there is no sane way to return an error to a manual caller of the callback, and therefore we can drop dead code that calls perror() and exit() if the callback \"failed\".  It is also worth documenting the contract on when we must manually call the callback during the asynch_zero callback, so that we do not leak or double-free the command; thankfully, all the existing code paths were correct.  The added testsuite script demonstrates several scenarios, some of which fail without the rest of this patch in place, and others which showcase ways in which sparse images can bypass errors.  Once backports are complete, a followup patch on the main branch will edit docs/libnbd-security.pod with the mailing list announcement of the stable branch commit ids and release versions that incorporate this fix.  Message-Id: <20220203202558.203013-6-eblake@redhat.com> [eblake: fix error message per Nir, tweak requires lines in unit test per Rich] ",
        "func_before": "static void\nfile_asynch_read (struct rw *rw,\n                  struct command *command,\n                  nbd_completion_callback cb)\n{\n  int dummy = 0;\n\n  file_synch_read (rw, slice_ptr (command->slice),\n                   command->slice.len, command->offset);\n  if (cb.callback (cb.user_data, &dummy) == -1) {\n    perror (rw->name);\n    exit (EXIT_FAILURE);\n  }\n}",
        "func": "static void\nfile_asynch_read (struct rw *rw,\n                  struct command *command,\n                  nbd_completion_callback cb)\n{\n  int dummy = 0;\n\n  file_synch_read (rw, slice_ptr (command->slice),\n                   command->slice.len, command->offset);\n  /* file_synch_read called exit() on error */\n  cb.callback (cb.user_data, &dummy);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -7,8 +7,6 @@\n \n   file_synch_read (rw, slice_ptr (command->slice),\n                    command->slice.len, command->offset);\n-  if (cb.callback (cb.user_data, &dummy) == -1) {\n-    perror (rw->name);\n-    exit (EXIT_FAILURE);\n-  }\n+  /* file_synch_read called exit() on error */\n+  cb.callback (cb.user_data, &dummy);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "  if (cb.callback (cb.user_data, &dummy) == -1) {",
                "    perror (rw->name);",
                "    exit (EXIT_FAILURE);",
                "  }"
            ],
            "added_lines": [
                "  /* file_synch_read called exit() on error */",
                "  cb.callback (cb.user_data, &dummy);"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-0485",
        "func_name": "nbdkit/libnbd/null_asynch_write",
        "description": "A flaw was found in the copying tool `nbdcopy` of libnbd. When performing multi-threaded copies using asynchronous nbd calls, nbdcopy was blindly treating the completion of an asynchronous command as successful, rather than checking the *error parameter. This could result in the silent creation of a corrupted destination image.",
        "git_url": "https://gitlab.com/nbdkit/libnbd/-/commit/8d444b41d09a700c7ee6f9182a649f3f2d325abb",
        "commit_title": "copy: CVE-2022-0485: Fail nbdcopy if NBD read or write fails",
        "commit_text": " nbdcopy has a nasty bug when performing multi-threaded copies using asynchronous nbd calls - it was blindly treating the completion of an asynchronous command as successful, rather than checking the *error parameter.  This can result in the silent creation of a corrupted image in two different ways: when a read fails, we blindly wrote garbage to the destination; when a write fails, we did not flag that the destination was not written.  Since nbdcopy already calls exit() on a synchronous read or write failure to a file, doing the same for an asynchronous op to an NBD server is the simplest solution.  A nicer solution, but more invasive to code and thus not done here, might be to allow up to N retries of the transaction (in case the read or write failure was transient), or even having a mode where as much data is copied as possible (portions of the copy that failed would be logged on stderr, and nbdcopy would still fail with a non-zero exit status, but this would copy more than just stopping at the first error, as can be done with rsync or ddrescue).  Note that since we rely on auto-retiring and do NOT call nbd_aio_command_completed, our completion callbacks must always return 1 (if they do not exit() first), even when acting on *error, so as not leave the command allocated until nbd_close.  As such, there is no sane way to return an error to a manual caller of the callback, and therefore we can drop dead code that calls perror() and exit() if the callback \"failed\".  It is also worth documenting the contract on when we must manually call the callback during the asynch_zero callback, so that we do not leak or double-free the command; thankfully, all the existing code paths were correct.  The added testsuite script demonstrates several scenarios, some of which fail without the rest of this patch in place, and others which showcase ways in which sparse images can bypass errors.  Once backports are complete, a followup patch on the main branch will edit docs/libnbd-security.pod with the mailing list announcement of the stable branch commit ids and release versions that incorporate this fix.  Message-Id: <20220203202558.203013-6-eblake@redhat.com> [eblake: fix error message per Nir, tweak requires lines in unit test per Rich] ",
        "func_before": "static void\nnull_asynch_write (struct rw *rw,\n                   struct command *command,\n                   nbd_completion_callback cb)\n{\n  int dummy = 0;\n\n  if (cb.callback (cb.user_data, &dummy) == -1) {\n    perror (rw->name);\n    exit (EXIT_FAILURE);\n  }\n}",
        "func": "static void\nnull_asynch_write (struct rw *rw,\n                   struct command *command,\n                   nbd_completion_callback cb)\n{\n  int dummy = 0;\n\n  cb.callback (cb.user_data, &dummy);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,8 +5,5 @@\n {\n   int dummy = 0;\n \n-  if (cb.callback (cb.user_data, &dummy) == -1) {\n-    perror (rw->name);\n-    exit (EXIT_FAILURE);\n-  }\n+  cb.callback (cb.user_data, &dummy);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "  if (cb.callback (cb.user_data, &dummy) == -1) {",
                "    perror (rw->name);",
                "    exit (EXIT_FAILURE);",
                "  }"
            ],
            "added_lines": [
                "  cb.callback (cb.user_data, &dummy);"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-0485",
        "func_name": "nbdkit/libnbd/null_asynch_zero",
        "description": "A flaw was found in the copying tool `nbdcopy` of libnbd. When performing multi-threaded copies using asynchronous nbd calls, nbdcopy was blindly treating the completion of an asynchronous command as successful, rather than checking the *error parameter. This could result in the silent creation of a corrupted destination image.",
        "git_url": "https://gitlab.com/nbdkit/libnbd/-/commit/8d444b41d09a700c7ee6f9182a649f3f2d325abb",
        "commit_title": "copy: CVE-2022-0485: Fail nbdcopy if NBD read or write fails",
        "commit_text": " nbdcopy has a nasty bug when performing multi-threaded copies using asynchronous nbd calls - it was blindly treating the completion of an asynchronous command as successful, rather than checking the *error parameter.  This can result in the silent creation of a corrupted image in two different ways: when a read fails, we blindly wrote garbage to the destination; when a write fails, we did not flag that the destination was not written.  Since nbdcopy already calls exit() on a synchronous read or write failure to a file, doing the same for an asynchronous op to an NBD server is the simplest solution.  A nicer solution, but more invasive to code and thus not done here, might be to allow up to N retries of the transaction (in case the read or write failure was transient), or even having a mode where as much data is copied as possible (portions of the copy that failed would be logged on stderr, and nbdcopy would still fail with a non-zero exit status, but this would copy more than just stopping at the first error, as can be done with rsync or ddrescue).  Note that since we rely on auto-retiring and do NOT call nbd_aio_command_completed, our completion callbacks must always return 1 (if they do not exit() first), even when acting on *error, so as not leave the command allocated until nbd_close.  As such, there is no sane way to return an error to a manual caller of the callback, and therefore we can drop dead code that calls perror() and exit() if the callback \"failed\".  It is also worth documenting the contract on when we must manually call the callback during the asynch_zero callback, so that we do not leak or double-free the command; thankfully, all the existing code paths were correct.  The added testsuite script demonstrates several scenarios, some of which fail without the rest of this patch in place, and others which showcase ways in which sparse images can bypass errors.  Once backports are complete, a followup patch on the main branch will edit docs/libnbd-security.pod with the mailing list announcement of the stable branch commit ids and release versions that incorporate this fix.  Message-Id: <20220203202558.203013-6-eblake@redhat.com> [eblake: fix error message per Nir, tweak requires lines in unit test per Rich] ",
        "func_before": "static bool\nnull_asynch_zero (struct rw *rw, struct command *command,\n                  nbd_completion_callback cb, bool allocate)\n{\n  int dummy = 0;\n\n  if (cb.callback (cb.user_data, &dummy) == -1) {\n    perror (rw->name);\n    exit (EXIT_FAILURE);\n  }\n  return true;\n}",
        "func": "static bool\nnull_asynch_zero (struct rw *rw, struct command *command,\n                  nbd_completion_callback cb, bool allocate)\n{\n  int dummy = 0;\n\n  cb.callback (cb.user_data, &dummy);\n  return true;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,9 +4,6 @@\n {\n   int dummy = 0;\n \n-  if (cb.callback (cb.user_data, &dummy) == -1) {\n-    perror (rw->name);\n-    exit (EXIT_FAILURE);\n-  }\n+  cb.callback (cb.user_data, &dummy);\n   return true;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "  if (cb.callback (cb.user_data, &dummy) == -1) {",
                "    perror (rw->name);",
                "    exit (EXIT_FAILURE);",
                "  }"
            ],
            "added_lines": [
                "  cb.callback (cb.user_data, &dummy);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-10902",
        "func_name": "wireshark/dissect_tsdns",
        "description": "In Wireshark 3.0.0, the TSDNS dissector could crash. This was addressed in epan/dissectors/packet-tsdns.c by splitting strings safely.",
        "git_url": "https://github.com/wireshark/wireshark/commit/95571f17d5e2de39735e62e5251583f930c06d51",
        "commit_title": "TSDNS: Add more wmem_strsplit return checks.",
        "commit_text": " wmem_strsplit might return NULL, or it might return fewer tokens than requested. Add checks accordingly. Update the API documentation while we're here.  Bug: 15619 (cherry picked from commit 19d54ac364150cd6c76488d2c2a5b6fd081daa5a)",
        "func_before": "static int dissect_tsdns(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\n{\n\n  int         offset    = 0;\n  gboolean    request   = FALSE;\n\n  if (pinfo->destport == pinfo->match_uint) {\n    request = TRUE;\n  }\n\n  col_set_str(pinfo->cinfo, COL_PROTOCOL, \"TSDNS\");\n\n  int pLen = tvb_reported_length(tvb);\n\n  if (request) {\n    col_set_str(pinfo->cinfo, COL_INFO, \"Request\");\n    col_append_fstr(pinfo->cinfo, COL_INFO, \" %.*s\", pLen - 5, tvb_get_string_enc(wmem_packet_scope(), tvb, 0, pLen - 5, ENC_ASCII|ENC_NA));\n  } else {\n    col_set_str(pinfo->cinfo, COL_INFO, \"Response\");\n    col_append_fstr(pinfo->cinfo, COL_INFO, \" %.*s\", pLen, tvb_get_string_enc(wmem_packet_scope(), tvb, 0, pLen, ENC_ASCII|ENC_NA));\n  }\n\n  proto_tree *tsdns_tree;\n  proto_item *ti, *hidden_item, *address_item;\n\n  ti = proto_tree_add_item(tree, proto_tsdns, tvb, offset, -1, ENC_NA);\n  tsdns_tree = proto_item_add_subtree(ti, ett_tsdns);\n\n  hidden_item = proto_tree_add_item(tsdns_tree, hf_tsdns_data, tvb, offset, -1, ENC_ASCII|ENC_NA);\n  PROTO_ITEM_SET_HIDDEN(hidden_item);\n\n  if (request) { // request is DOMAIN\\n\\r\\r\\r\\n\n    hidden_item = proto_tree_add_boolean(tsdns_tree, hf_tsdns_request, tvb, 0, 0, 1); // using pLen - 5 as the last chars are \\n\\r\\r\\r\\n which are just indicating the end of the request\n    proto_tree_add_item(tsdns_tree, hf_tsdns_request_domain, tvb, offset, pLen - 5, ENC_ASCII|ENC_NA);\n  } else { // response is IP:PORT\n    hidden_item = proto_tree_add_boolean(tsdns_tree, hf_tsdns_response, tvb, 0, 0, 1);\n    address_item = proto_tree_add_item(tsdns_tree, hf_tsdns_response_address, tvb, offset, pLen, ENC_ASCII|ENC_NA);\n    gchar** splitAddress;\n    splitAddress = wmem_strsplit(wmem_packet_scope(), tvb_format_text(tvb, 0, pLen), \":\", 1); // unsure if TSDNS also does IPv6...\n    if (splitAddress[1] == NULL) {\n      expert_add_info(pinfo, address_item, &ei_response_port_malformed);\n    } else {\n      proto_tree_add_string(tsdns_tree, hf_tsdns_response_ip, tvb, 0, pLen, splitAddress[0]);\n      guint32 port;\n      if (ws_strtou32(splitAddress[1], NULL, &port))\n        proto_tree_add_uint(tsdns_tree, hf_tsdns_response_port, tvb, 0, pLen, port);\n    }\n  }\n  PROTO_ITEM_SET_HIDDEN(hidden_item);\n\n  return tvb_captured_length(tvb);\n\n}",
        "func": "static int dissect_tsdns(tvbuff_t *tvb, packet_info *pinfo, proto_tree *tree, void* data _U_)\n{\n\n  int         offset    = 0;\n  gboolean    request   = FALSE;\n\n  if (pinfo->destport == pinfo->match_uint) {\n    request = TRUE;\n  }\n\n  col_set_str(pinfo->cinfo, COL_PROTOCOL, \"TSDNS\");\n\n  int pLen = tvb_reported_length(tvb);\n\n  if (request) {\n    col_set_str(pinfo->cinfo, COL_INFO, \"Request\");\n    col_append_fstr(pinfo->cinfo, COL_INFO, \" %.*s\", pLen - 5, tvb_get_string_enc(wmem_packet_scope(), tvb, 0, pLen - 5, ENC_ASCII|ENC_NA));\n  } else {\n    col_set_str(pinfo->cinfo, COL_INFO, \"Response\");\n    col_append_fstr(pinfo->cinfo, COL_INFO, \" %.*s\", pLen, tvb_get_string_enc(wmem_packet_scope(), tvb, 0, pLen, ENC_ASCII|ENC_NA));\n  }\n\n  proto_tree *tsdns_tree;\n  proto_item *ti, *hidden_item, *address_item;\n\n  ti = proto_tree_add_item(tree, proto_tsdns, tvb, offset, -1, ENC_NA);\n  tsdns_tree = proto_item_add_subtree(ti, ett_tsdns);\n\n  hidden_item = proto_tree_add_item(tsdns_tree, hf_tsdns_data, tvb, offset, -1, ENC_ASCII|ENC_NA);\n  PROTO_ITEM_SET_HIDDEN(hidden_item);\n\n  if (request) { // request is DOMAIN\\n\\r\\r\\r\\n\n    hidden_item = proto_tree_add_boolean(tsdns_tree, hf_tsdns_request, tvb, 0, 0, 1); // using pLen - 5 as the last chars are \\n\\r\\r\\r\\n which are just indicating the end of the request\n    proto_tree_add_item(tsdns_tree, hf_tsdns_request_domain, tvb, offset, pLen - 5, ENC_ASCII|ENC_NA);\n  } else { // response is IP:PORT\n    hidden_item = proto_tree_add_boolean(tsdns_tree, hf_tsdns_response, tvb, 0, 0, 1);\n    address_item = proto_tree_add_item(tsdns_tree, hf_tsdns_response_address, tvb, offset, pLen, ENC_ASCII|ENC_NA);\n    gchar** splitAddress;\n    splitAddress = wmem_strsplit(wmem_packet_scope(), tvb_format_text(tvb, 0, pLen), \":\", 1); // unsure if TSDNS also does IPv6...\n    if (splitAddress == NULL || splitAddress[0] == NULL || splitAddress[1] == NULL) {\n      expert_add_info(pinfo, address_item, &ei_response_port_malformed);\n    } else {\n      proto_tree_add_string(tsdns_tree, hf_tsdns_response_ip, tvb, 0, pLen, splitAddress[0]);\n      guint32 port;\n      if (ws_strtou32(splitAddress[1], NULL, &port))\n        proto_tree_add_uint(tsdns_tree, hf_tsdns_response_port, tvb, 0, pLen, port);\n    }\n  }\n  PROTO_ITEM_SET_HIDDEN(hidden_item);\n\n  return tvb_captured_length(tvb);\n\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -37,7 +37,7 @@\n     address_item = proto_tree_add_item(tsdns_tree, hf_tsdns_response_address, tvb, offset, pLen, ENC_ASCII|ENC_NA);\n     gchar** splitAddress;\n     splitAddress = wmem_strsplit(wmem_packet_scope(), tvb_format_text(tvb, 0, pLen), \":\", 1); // unsure if TSDNS also does IPv6...\n-    if (splitAddress[1] == NULL) {\n+    if (splitAddress == NULL || splitAddress[0] == NULL || splitAddress[1] == NULL) {\n       expert_add_info(pinfo, address_item, &ei_response_port_malformed);\n     } else {\n       proto_tree_add_string(tsdns_tree, hf_tsdns_response_ip, tvb, 0, pLen, splitAddress[0]);",
        "diff_line_info": {
            "deleted_lines": [
                "    if (splitAddress[1] == NULL) {"
            ],
            "added_lines": [
                "    if (splitAddress == NULL || splitAddress[0] == NULL || splitAddress[1] == NULL) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-38114",
        "func_name": "ffmpeg/dnxhd_init_vlc",
        "description": "libavcodec/dnxhddec.c in FFmpeg 4.4 does not check the return value of the init_vlc function, a similar issue to CVE-2013-0868.",
        "git_url": "https://github.com/FFmpeg/FFmpeg/commit/7150f9575671f898382c370acae35f9087a30ba1",
        "commit_title": "avcodec/dnxhddec: check and propagate function return value",
        "commit_text": " Similar to CVE-2013-0868, here return value check for 'init_vlc' is needed. crafted DNxHD data can cause unspecified impact. ",
        "func_before": "static int dnxhd_init_vlc(DNXHDContext *ctx, uint32_t cid, int bitdepth)\n{\n    if (cid != ctx->cid) {\n        const CIDEntry *cid_table = ff_dnxhd_get_cid_table(cid);\n\n        if (!cid_table) {\n            av_log(ctx->avctx, AV_LOG_ERROR, \"unsupported cid %\"PRIu32\"\\n\", cid);\n            return AVERROR(ENOSYS);\n        }\n        if (cid_table->bit_depth != bitdepth &&\n            cid_table->bit_depth != DNXHD_VARIABLE) {\n            av_log(ctx->avctx, AV_LOG_ERROR, \"bit depth mismatches %d %d\\n\",\n                   cid_table->bit_depth, bitdepth);\n            return AVERROR_INVALIDDATA;\n        }\n        ctx->cid_table = cid_table;\n        av_log(ctx->avctx, AV_LOG_VERBOSE, \"Profile cid %\"PRIu32\".\\n\", cid);\n\n        ff_free_vlc(&ctx->ac_vlc);\n        ff_free_vlc(&ctx->dc_vlc);\n        ff_free_vlc(&ctx->run_vlc);\n\n        init_vlc(&ctx->ac_vlc, DNXHD_VLC_BITS, 257,\n                 ctx->cid_table->ac_bits, 1, 1,\n                 ctx->cid_table->ac_codes, 2, 2, 0);\n        init_vlc(&ctx->dc_vlc, DNXHD_DC_VLC_BITS, bitdepth > 8 ? 14 : 12,\n                 ctx->cid_table->dc_bits, 1, 1,\n                 ctx->cid_table->dc_codes, 1, 1, 0);\n        init_vlc(&ctx->run_vlc, DNXHD_VLC_BITS, 62,\n                 ctx->cid_table->run_bits, 1, 1,\n                 ctx->cid_table->run_codes, 2, 2, 0);\n\n        ctx->cid = cid;\n    }\n    return 0;\n}",
        "func": "static int dnxhd_init_vlc(DNXHDContext *ctx, uint32_t cid, int bitdepth)\n{\n    int ret;\n    if (cid != ctx->cid) {\n        const CIDEntry *cid_table = ff_dnxhd_get_cid_table(cid);\n\n        if (!cid_table) {\n            av_log(ctx->avctx, AV_LOG_ERROR, \"unsupported cid %\"PRIu32\"\\n\", cid);\n            return AVERROR(ENOSYS);\n        }\n        if (cid_table->bit_depth != bitdepth &&\n            cid_table->bit_depth != DNXHD_VARIABLE) {\n            av_log(ctx->avctx, AV_LOG_ERROR, \"bit depth mismatches %d %d\\n\",\n                   cid_table->bit_depth, bitdepth);\n            return AVERROR_INVALIDDATA;\n        }\n        ctx->cid_table = cid_table;\n        av_log(ctx->avctx, AV_LOG_VERBOSE, \"Profile cid %\"PRIu32\".\\n\", cid);\n\n        ff_free_vlc(&ctx->ac_vlc);\n        ff_free_vlc(&ctx->dc_vlc);\n        ff_free_vlc(&ctx->run_vlc);\n\n        if ((ret = init_vlc(&ctx->ac_vlc, DNXHD_VLC_BITS, 257,\n                 ctx->cid_table->ac_bits, 1, 1,\n                 ctx->cid_table->ac_codes, 2, 2, 0)) < 0)\n            goto out;\n        if ((ret = init_vlc(&ctx->dc_vlc, DNXHD_DC_VLC_BITS, bitdepth > 8 ? 14 : 12,\n                 ctx->cid_table->dc_bits, 1, 1,\n                 ctx->cid_table->dc_codes, 1, 1, 0)) < 0)\n            goto out;\n        if ((ret = init_vlc(&ctx->run_vlc, DNXHD_VLC_BITS, 62,\n                 ctx->cid_table->run_bits, 1, 1,\n                 ctx->cid_table->run_codes, 2, 2, 0)) < 0)\n            goto out;\n\n        ctx->cid = cid;\n    }\n    ret = 0;\nout:\n    if (ret < 0)\n        av_log(ctx->avctx, AV_LOG_ERROR, \"init_vlc failed\\n\");\n    return ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,6 @@\n static int dnxhd_init_vlc(DNXHDContext *ctx, uint32_t cid, int bitdepth)\n {\n+    int ret;\n     if (cid != ctx->cid) {\n         const CIDEntry *cid_table = ff_dnxhd_get_cid_table(cid);\n \n@@ -20,17 +21,24 @@\n         ff_free_vlc(&ctx->dc_vlc);\n         ff_free_vlc(&ctx->run_vlc);\n \n-        init_vlc(&ctx->ac_vlc, DNXHD_VLC_BITS, 257,\n+        if ((ret = init_vlc(&ctx->ac_vlc, DNXHD_VLC_BITS, 257,\n                  ctx->cid_table->ac_bits, 1, 1,\n-                 ctx->cid_table->ac_codes, 2, 2, 0);\n-        init_vlc(&ctx->dc_vlc, DNXHD_DC_VLC_BITS, bitdepth > 8 ? 14 : 12,\n+                 ctx->cid_table->ac_codes, 2, 2, 0)) < 0)\n+            goto out;\n+        if ((ret = init_vlc(&ctx->dc_vlc, DNXHD_DC_VLC_BITS, bitdepth > 8 ? 14 : 12,\n                  ctx->cid_table->dc_bits, 1, 1,\n-                 ctx->cid_table->dc_codes, 1, 1, 0);\n-        init_vlc(&ctx->run_vlc, DNXHD_VLC_BITS, 62,\n+                 ctx->cid_table->dc_codes, 1, 1, 0)) < 0)\n+            goto out;\n+        if ((ret = init_vlc(&ctx->run_vlc, DNXHD_VLC_BITS, 62,\n                  ctx->cid_table->run_bits, 1, 1,\n-                 ctx->cid_table->run_codes, 2, 2, 0);\n+                 ctx->cid_table->run_codes, 2, 2, 0)) < 0)\n+            goto out;\n \n         ctx->cid = cid;\n     }\n-    return 0;\n+    ret = 0;\n+out:\n+    if (ret < 0)\n+        av_log(ctx->avctx, AV_LOG_ERROR, \"init_vlc failed\\n\");\n+    return ret;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "        init_vlc(&ctx->ac_vlc, DNXHD_VLC_BITS, 257,",
                "                 ctx->cid_table->ac_codes, 2, 2, 0);",
                "        init_vlc(&ctx->dc_vlc, DNXHD_DC_VLC_BITS, bitdepth > 8 ? 14 : 12,",
                "                 ctx->cid_table->dc_codes, 1, 1, 0);",
                "        init_vlc(&ctx->run_vlc, DNXHD_VLC_BITS, 62,",
                "                 ctx->cid_table->run_codes, 2, 2, 0);",
                "    return 0;"
            ],
            "added_lines": [
                "    int ret;",
                "        if ((ret = init_vlc(&ctx->ac_vlc, DNXHD_VLC_BITS, 257,",
                "                 ctx->cid_table->ac_codes, 2, 2, 0)) < 0)",
                "            goto out;",
                "        if ((ret = init_vlc(&ctx->dc_vlc, DNXHD_DC_VLC_BITS, bitdepth > 8 ? 14 : 12,",
                "                 ctx->cid_table->dc_codes, 1, 1, 0)) < 0)",
                "            goto out;",
                "        if ((ret = init_vlc(&ctx->run_vlc, DNXHD_VLC_BITS, 62,",
                "                 ctx->cid_table->run_codes, 2, 2, 0)) < 0)",
                "            goto out;",
                "    ret = 0;",
                "out:",
                "    if (ret < 0)",
                "        av_log(ctx->avctx, AV_LOG_ERROR, \"init_vlc failed\\n\");",
                "    return ret;"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-38171",
        "func_name": "ffmpeg/adts_decode_extradata",
        "description": "adts_decode_extradata in libavformat/adtsenc.c in FFmpeg 4.4 does not check the init_get_bits return value, which is a necessary step because the second argument to init_get_bits can be crafted.",
        "git_url": "https://github.com/FFmpeg/FFmpeg/commit/9ffa49496d1aae4cbbb387aac28a9e061a6ab0a6",
        "commit_title": "avformat/adtsenc: return value check for init_get_bits in adts_decode_extradata",
        "commit_text": " As the second argument for init_get_bits (buf) can be crafted, a return value check for this function call is necessary. 'buf' is  part of  'AVPacket pkt'. replace init_get_bits with init_get_bits8. ",
        "func_before": "static int adts_decode_extradata(AVFormatContext *s, ADTSContext *adts, const uint8_t *buf, int size)\n{\n    GetBitContext gb;\n    PutBitContext pb;\n    MPEG4AudioConfig m4ac;\n    int off;\n\n    init_get_bits(&gb, buf, size * 8);\n    off = avpriv_mpeg4audio_get_config2(&m4ac, buf, size, 1, s);\n    if (off < 0)\n        return off;\n    skip_bits_long(&gb, off);\n    adts->objecttype        = m4ac.object_type - 1;\n    adts->sample_rate_index = m4ac.sampling_index;\n    adts->channel_conf      = m4ac.chan_config;\n\n    if (adts->objecttype > 3U) {\n        av_log(s, AV_LOG_ERROR, \"MPEG-4 AOT %d is not allowed in ADTS\\n\", adts->objecttype+1);\n        return AVERROR_INVALIDDATA;\n    }\n    if (adts->sample_rate_index == 15) {\n        av_log(s, AV_LOG_ERROR, \"Escape sample rate index illegal in ADTS\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    if (get_bits(&gb, 1)) {\n        av_log(s, AV_LOG_ERROR, \"960/120 MDCT window is not allowed in ADTS\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    if (get_bits(&gb, 1)) {\n        av_log(s, AV_LOG_ERROR, \"Scalable configurations are not allowed in ADTS\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    if (get_bits(&gb, 1)) {\n        av_log(s, AV_LOG_ERROR, \"Extension flag is not allowed in ADTS\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    if (!adts->channel_conf) {\n        init_put_bits(&pb, adts->pce_data, MAX_PCE_SIZE);\n\n        put_bits(&pb, 3, 5); //ID_PCE\n        adts->pce_size = (ff_copy_pce_data(&pb, &gb) + 3) / 8;\n        flush_put_bits(&pb);\n    }\n\n    adts->write_adts = 1;\n\n    return 0;\n}",
        "func": "static int adts_decode_extradata(AVFormatContext *s, ADTSContext *adts, const uint8_t *buf, int size)\n{\n    GetBitContext gb;\n    PutBitContext pb;\n    MPEG4AudioConfig m4ac;\n    int off, ret;\n\n    ret = init_get_bits8(&gb, buf, size);\n    if (ret < 0)\n        return ret;\n    off = avpriv_mpeg4audio_get_config2(&m4ac, buf, size, 1, s);\n    if (off < 0)\n        return off;\n    skip_bits_long(&gb, off);\n    adts->objecttype        = m4ac.object_type - 1;\n    adts->sample_rate_index = m4ac.sampling_index;\n    adts->channel_conf      = m4ac.chan_config;\n\n    if (adts->objecttype > 3U) {\n        av_log(s, AV_LOG_ERROR, \"MPEG-4 AOT %d is not allowed in ADTS\\n\", adts->objecttype+1);\n        return AVERROR_INVALIDDATA;\n    }\n    if (adts->sample_rate_index == 15) {\n        av_log(s, AV_LOG_ERROR, \"Escape sample rate index illegal in ADTS\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    if (get_bits(&gb, 1)) {\n        av_log(s, AV_LOG_ERROR, \"960/120 MDCT window is not allowed in ADTS\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    if (get_bits(&gb, 1)) {\n        av_log(s, AV_LOG_ERROR, \"Scalable configurations are not allowed in ADTS\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    if (get_bits(&gb, 1)) {\n        av_log(s, AV_LOG_ERROR, \"Extension flag is not allowed in ADTS\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    if (!adts->channel_conf) {\n        init_put_bits(&pb, adts->pce_data, MAX_PCE_SIZE);\n\n        put_bits(&pb, 3, 5); //ID_PCE\n        adts->pce_size = (ff_copy_pce_data(&pb, &gb) + 3) / 8;\n        flush_put_bits(&pb);\n    }\n\n    adts->write_adts = 1;\n\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,9 +3,11 @@\n     GetBitContext gb;\n     PutBitContext pb;\n     MPEG4AudioConfig m4ac;\n-    int off;\n+    int off, ret;\n \n-    init_get_bits(&gb, buf, size * 8);\n+    ret = init_get_bits8(&gb, buf, size);\n+    if (ret < 0)\n+        return ret;\n     off = avpriv_mpeg4audio_get_config2(&m4ac, buf, size, 1, s);\n     if (off < 0)\n         return off;",
        "diff_line_info": {
            "deleted_lines": [
                "    int off;",
                "    init_get_bits(&gb, buf, size * 8);"
            ],
            "added_lines": [
                "    int off, ret;",
                "    ret = init_get_bits8(&gb, buf, size);",
                "    if (ret < 0)",
                "        return ret;"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-32845",
        "func_name": "moby/hyperkit/pci_vtrnd_notify",
        "description": "HyperKit is a toolkit for embedding hypervisor capabilities in an application. In versions 0.20210107 and prior of HyperKit, the implementation of `qnotify` at `pci_vtrnd_notify` fails to check the return value of `vq_getchain`. This leads to `struct iovec iov;` being uninitialized and used to read memory in `len = (int) read(sc->vrsc_fd, iov.iov_base, iov.iov_len);` when an attacker is able to make `vq_getchain` fail. This issue may lead to a guest crashing the host causing a denial of service and, under certain circumstance, memory corruption. This issue is fixed in commit 41272a980197917df8e58ff90642d14dec8fe948.",
        "git_url": "https://github.com/moby/hyperkit/commit/41272a980197917df8e58ff90642d14dec8fe948",
        "commit_title": "Fix vtrnd pci_vtrnd_notify uninitialized memory use (GHSL-2021-056)",
        "commit_text": "",
        "func_before": "static void\npci_vtrnd_notify(void *vsc, struct vqueue_info *vq)\n{\n\tstruct iovec iov;\n\tstruct pci_vtrnd_softc *sc;\n\tint len;\n\tuint16_t idx;\n\n\tsc = vsc;\n\n\tif (sc->vrsc_fd < 0) {\n\t\tvq_endchains(vq, 0);\n\t\treturn;\n\t}\n\n\twhile (vq_has_descs(vq)) {\n\t\tvq_getchain(vq, &idx, &iov, 1, NULL);\n\n\t\tlen = (int) read(sc->vrsc_fd, iov.iov_base, iov.iov_len);\n\n\t\tDPRINTF((\"vtrnd: vtrnd_notify(): %d\\r\\n\", len));\n\n\t\t/* Catastrophe if unable to read from /dev/random */\n\t\tassert(len > 0);\n\n\t\t/*\n\t\t * Release this chain and handle more\n\t\t */\n\t\tvq_relchain(vq, idx, (uint32_t)len);\n\t}\n\tvq_endchains(vq, 1);\t/* Generate interrupt if appropriate. */\n}",
        "func": "static void\npci_vtrnd_notify(void *vsc, struct vqueue_info *vq)\n{\n\tstruct iovec iov;\n\tstruct pci_vtrnd_softc *sc;\n\tint len, n;\n\tuint16_t idx;\n\n\tsc = vsc;\n\n\tif (sc->vrsc_fd < 0) {\n\t\tvq_endchains(vq, 0);\n\t\treturn;\n\t}\n\n\twhile (vq_has_descs(vq)) {\n\t\tn = vq_getchain(vq, &idx, &iov, 1, NULL);\n\t\tif (n < 0) {\n\t\t\tfprintf(stderr, \"vtrnd: vtrnd_notify(): n %d\\r\\n\", n);\n\t\t\treturn;\n\t\t}\n\n\t\tlen = (int) read(sc->vrsc_fd, iov.iov_base, iov.iov_len);\n\n\t\tDPRINTF((\"vtrnd: vtrnd_notify(): %d\\r\\n\", len));\n\n\t\t/* Catastrophe if unable to read from /dev/random */\n\t\tassert(len > 0);\n\n\t\t/*\n\t\t * Release this chain and handle more\n\t\t */\n\t\tvq_relchain(vq, idx, (uint32_t)len);\n\t}\n\tvq_endchains(vq, 1);\t/* Generate interrupt if appropriate. */\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,7 +3,7 @@\n {\n \tstruct iovec iov;\n \tstruct pci_vtrnd_softc *sc;\n-\tint len;\n+\tint len, n;\n \tuint16_t idx;\n \n \tsc = vsc;\n@@ -14,7 +14,11 @@\n \t}\n \n \twhile (vq_has_descs(vq)) {\n-\t\tvq_getchain(vq, &idx, &iov, 1, NULL);\n+\t\tn = vq_getchain(vq, &idx, &iov, 1, NULL);\n+\t\tif (n < 0) {\n+\t\t\tfprintf(stderr, \"vtrnd: vtrnd_notify(): n %d\\r\\n\", n);\n+\t\t\treturn;\n+\t\t}\n \n \t\tlen = (int) read(sc->vrsc_fd, iov.iov_base, iov.iov_len);\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\tint len;",
                "\t\tvq_getchain(vq, &idx, &iov, 1, NULL);"
            ],
            "added_lines": [
                "\tint len, n;",
                "\t\tn = vq_getchain(vq, &idx, &iov, 1, NULL);",
                "\t\tif (n < 0) {",
                "\t\t\tfprintf(stderr, \"vtrnd: vtrnd_notify(): n %d\\r\\n\", n);",
                "\t\t\treturn;",
                "\t\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-0907",
        "func_name": "libtiff/createImageSection",
        "description": "Unchecked Return Value to NULL Pointer Dereference in tiffcrop in libtiff 4.3.0 allows attackers to cause a denial-of-service via a crafted tiff file. For users that compile libtiff from sources, the fix is available with commit f2b656e2.",
        "git_url": "https://gitlab.com/libtiff/libtiff/-/commit/40b00cfb32256d377608b4d4cd30fac338d0a0bc",
        "commit_title": "add checks for return value of limitMalloc (#392)",
        "commit_text": "",
        "func_before": "static int\ncreateImageSection(uint32_t sectsize, unsigned char **sect_buff_ptr)\n  {\n  unsigned  char *sect_buff = NULL;\n  unsigned  char *new_buff  = NULL;\n  static    uint32_t  prev_sectsize = 0;\n  \n  sect_buff = *sect_buff_ptr;\n\n  if (!sect_buff)\n    {\n    sect_buff = (unsigned char *)limitMalloc(sectsize);\n    *sect_buff_ptr = sect_buff;\n    _TIFFmemset(sect_buff, 0, sectsize);\n    }\n  else\n    {\n    if (prev_sectsize < sectsize)\n      {\n      new_buff = _TIFFrealloc(sect_buff, sectsize);\n      if (!new_buff)\n        {\n          _TIFFfree (sect_buff);\n        sect_buff = (unsigned char *)limitMalloc(sectsize);\n        }\n      else\n        sect_buff = new_buff;\n\n      _TIFFmemset(sect_buff, 0, sectsize);\n      }\n    }\n\n  if (!sect_buff)\n    {\n    TIFFError(\"createImageSection\", \"Unable to allocate/reallocate section buffer\");\n    return (-1);\n    }\n  prev_sectsize = sectsize;\n  *sect_buff_ptr = sect_buff;\n\n  return (0);\n  }",
        "func": "static int\ncreateImageSection(uint32_t sectsize, unsigned char **sect_buff_ptr)\n  {\n  unsigned  char *sect_buff = NULL;\n  unsigned  char *new_buff  = NULL;\n  static    uint32_t  prev_sectsize = 0;\n  \n  sect_buff = *sect_buff_ptr;\n\n  if (!sect_buff)\n    {\n    sect_buff = (unsigned char *)limitMalloc(sectsize);\n    if (!sect_buff)\n    {\n        TIFFError(\"createImageSection\", \"Unable to allocate/reallocate section buffer\");\n        return (-1);\n    }\n    _TIFFmemset(sect_buff, 0, sectsize);\n    }\n  else\n    {\n    if (prev_sectsize < sectsize)\n      {\n      new_buff = _TIFFrealloc(sect_buff, sectsize);\n      if (!new_buff)\n        {\n          _TIFFfree (sect_buff);\n        sect_buff = (unsigned char *)limitMalloc(sectsize);\n        }\n      else\n        sect_buff = new_buff;\n\n      if (!sect_buff)\n      {\n          TIFFError(\"createImageSection\", \"Unable to allocate/reallocate section buffer\");\n          return (-1);\n      }\n      _TIFFmemset(sect_buff, 0, sectsize);\n      }\n    }\n\n  prev_sectsize = sectsize;\n  *sect_buff_ptr = sect_buff;\n\n  return (0);\n  }",
        "diff_func": "--- func_before\n+++ func_after\n@@ -10,7 +10,11 @@\n   if (!sect_buff)\n     {\n     sect_buff = (unsigned char *)limitMalloc(sectsize);\n-    *sect_buff_ptr = sect_buff;\n+    if (!sect_buff)\n+    {\n+        TIFFError(\"createImageSection\", \"Unable to allocate/reallocate section buffer\");\n+        return (-1);\n+    }\n     _TIFFmemset(sect_buff, 0, sectsize);\n     }\n   else\n@@ -26,15 +30,15 @@\n       else\n         sect_buff = new_buff;\n \n+      if (!sect_buff)\n+      {\n+          TIFFError(\"createImageSection\", \"Unable to allocate/reallocate section buffer\");\n+          return (-1);\n+      }\n       _TIFFmemset(sect_buff, 0, sectsize);\n       }\n     }\n \n-  if (!sect_buff)\n-    {\n-    TIFFError(\"createImageSection\", \"Unable to allocate/reallocate section buffer\");\n-    return (-1);\n-    }\n   prev_sectsize = sectsize;\n   *sect_buff_ptr = sect_buff;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "    *sect_buff_ptr = sect_buff;",
                "  if (!sect_buff)",
                "    {",
                "    TIFFError(\"createImageSection\", \"Unable to allocate/reallocate section buffer\");",
                "    return (-1);",
                "    }"
            ],
            "added_lines": [
                "    if (!sect_buff)",
                "    {",
                "        TIFFError(\"createImageSection\", \"Unable to allocate/reallocate section buffer\");",
                "        return (-1);",
                "    }",
                "      if (!sect_buff)",
                "      {",
                "          TIFFError(\"createImageSection\", \"Unable to allocate/reallocate section buffer\");",
                "          return (-1);",
                "      }"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-0907",
        "func_name": "libtiff/createCroppedImage",
        "description": "Unchecked Return Value to NULL Pointer Dereference in tiffcrop in libtiff 4.3.0 allows attackers to cause a denial-of-service via a crafted tiff file. For users that compile libtiff from sources, the fix is available with commit f2b656e2.",
        "git_url": "https://gitlab.com/libtiff/libtiff/-/commit/40b00cfb32256d377608b4d4cd30fac338d0a0bc",
        "commit_title": "add checks for return value of limitMalloc (#392)",
        "commit_text": "",
        "func_before": "static int\ncreateCroppedImage(struct image_data *image, struct crop_mask *crop, \n                   unsigned char **read_buff_ptr, unsigned char **crop_buff_ptr)\n  {\n  tsize_t   cropsize;\n  unsigned  char *read_buff = NULL;\n  unsigned  char *crop_buff = NULL;\n  unsigned  char *new_buff  = NULL;\n  static    tsize_t  prev_cropsize = 0;\n\n  read_buff = *read_buff_ptr;\n\n  /* process full image, no crop buffer needed */\n  crop_buff = read_buff;\n  *crop_buff_ptr = read_buff;\n  crop->combined_width = image->width;\n  crop->combined_length = image->length;\n\n  cropsize = crop->bufftotal;\n  crop_buff = *crop_buff_ptr;\n  if (!crop_buff)\n    {\n    crop_buff = (unsigned char *)limitMalloc(cropsize);\n    *crop_buff_ptr = crop_buff;\n    _TIFFmemset(crop_buff, 0, cropsize);\n    prev_cropsize = cropsize;\n    }\n  else\n    {\n    if (prev_cropsize < cropsize)\n      {\n      new_buff = _TIFFrealloc(crop_buff, cropsize);\n      if (!new_buff)\n        {\n\tfree (crop_buff);\n        crop_buff = (unsigned char *)limitMalloc(cropsize);\n        }\n      else\n        crop_buff = new_buff;\n      _TIFFmemset(crop_buff, 0, cropsize);\n      }\n    }\n\n  if (!crop_buff)\n    {\n    TIFFError(\"createCroppedImage\", \"Unable to allocate/reallocate crop buffer\");\n    return (-1);\n    }\n  *crop_buff_ptr = crop_buff;\n\n  if (crop->crop_mode & CROP_INVERT)\n    {\n    switch (crop->photometric)\n      {\n      /* Just change the interpretation */\n      case PHOTOMETRIC_MINISWHITE:\n      case PHOTOMETRIC_MINISBLACK:\n\t   image->photometric = crop->photometric;\n\t   break;\n      case INVERT_DATA_ONLY:\n      case INVERT_DATA_AND_TAG:\n           if (invertImage(image->photometric, image->spp, image->bps, \n                           crop->combined_width, crop->combined_length, crop_buff))\n             {\n             TIFFError(\"createCroppedImage\", \n                       \"Failed to invert colorspace for image or cropped selection\");\n             return (-1);\n             }\n           if (crop->photometric == INVERT_DATA_AND_TAG)\n             {\n             switch (image->photometric)\n               {\n               case PHOTOMETRIC_MINISWHITE:\n \t            image->photometric = PHOTOMETRIC_MINISBLACK;\n\t            break;\n               case PHOTOMETRIC_MINISBLACK:\n \t            image->photometric = PHOTOMETRIC_MINISWHITE;\n\t            break;\n               default:\n\t            break;\n\t       }\n\t     }\n           break;\n      default: break;\n      }\n    }\n\n  if (crop->crop_mode & CROP_MIRROR)\n    {\n    if (mirrorImage(image->spp, image->bps, crop->mirror, \n                    crop->combined_width, crop->combined_length, crop_buff))\n      {\n      TIFFError(\"createCroppedImage\", \"Failed to mirror image or cropped selection %s\", \n\t       (crop->rotation == MIRROR_HORIZ) ? \"horizontally\" : \"vertically\");\n      return (-1);\n      }\n    }\n\n  if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */\n    {\n    if (rotateImage(crop->rotation, image, &crop->combined_width, \n                    &crop->combined_length, crop_buff_ptr))\n      {\n      TIFFError(\"createCroppedImage\", \n                \"Failed to rotate image or cropped selection by %\"PRIu16\" degrees\", crop->rotation);\n      return (-1);\n      }\n    }\n\n  if (crop_buff == read_buff) /* we used the read buffer for the crop buffer */\n    *read_buff_ptr = NULL;    /* so we don't try to free it later */\n\n  return (0);\n  }",
        "func": "static int\ncreateCroppedImage(struct image_data *image, struct crop_mask *crop, \n                   unsigned char **read_buff_ptr, unsigned char **crop_buff_ptr)\n  {\n  tsize_t   cropsize;\n  unsigned  char *read_buff = NULL;\n  unsigned  char *crop_buff = NULL;\n  unsigned  char *new_buff  = NULL;\n  static    tsize_t  prev_cropsize = 0;\n\n  read_buff = *read_buff_ptr;\n\n  /* process full image, no crop buffer needed */\n  crop_buff = read_buff;\n  *crop_buff_ptr = read_buff;\n  crop->combined_width = image->width;\n  crop->combined_length = image->length;\n\n  cropsize = crop->bufftotal;\n  crop_buff = *crop_buff_ptr;\n  if (!crop_buff)\n    {\n    crop_buff = (unsigned char *)limitMalloc(cropsize);\n    if (!crop_buff)\n    {\n        TIFFError(\"createCroppedImage\", \"Unable to allocate/reallocate crop buffer\");\n        return (-1);\n    }\n    _TIFFmemset(crop_buff, 0, cropsize);\n    prev_cropsize = cropsize;\n    }\n  else\n    {\n    if (prev_cropsize < cropsize)\n      {\n      new_buff = _TIFFrealloc(crop_buff, cropsize);\n      if (!new_buff)\n        {\n\tfree (crop_buff);\n        crop_buff = (unsigned char *)limitMalloc(cropsize);\n        }\n      else\n        crop_buff = new_buff;\n      if (!crop_buff)\n      {\n          TIFFError(\"createCroppedImage\", \"Unable to allocate/reallocate crop buffer\");\n          return (-1);\n      }\n      _TIFFmemset(crop_buff, 0, cropsize);\n      }\n    }\n\n  *crop_buff_ptr = crop_buff;\n\n  if (crop->crop_mode & CROP_INVERT)\n    {\n    switch (crop->photometric)\n      {\n      /* Just change the interpretation */\n      case PHOTOMETRIC_MINISWHITE:\n      case PHOTOMETRIC_MINISBLACK:\n\t   image->photometric = crop->photometric;\n\t   break;\n      case INVERT_DATA_ONLY:\n      case INVERT_DATA_AND_TAG:\n           if (invertImage(image->photometric, image->spp, image->bps, \n                           crop->combined_width, crop->combined_length, crop_buff))\n             {\n             TIFFError(\"createCroppedImage\", \n                       \"Failed to invert colorspace for image or cropped selection\");\n             return (-1);\n             }\n           if (crop->photometric == INVERT_DATA_AND_TAG)\n             {\n             switch (image->photometric)\n               {\n               case PHOTOMETRIC_MINISWHITE:\n \t            image->photometric = PHOTOMETRIC_MINISBLACK;\n\t            break;\n               case PHOTOMETRIC_MINISBLACK:\n \t            image->photometric = PHOTOMETRIC_MINISWHITE;\n\t            break;\n               default:\n\t            break;\n\t       }\n\t     }\n           break;\n      default: break;\n      }\n    }\n\n  if (crop->crop_mode & CROP_MIRROR)\n    {\n    if (mirrorImage(image->spp, image->bps, crop->mirror, \n                    crop->combined_width, crop->combined_length, crop_buff))\n      {\n      TIFFError(\"createCroppedImage\", \"Failed to mirror image or cropped selection %s\", \n\t       (crop->rotation == MIRROR_HORIZ) ? \"horizontally\" : \"vertically\");\n      return (-1);\n      }\n    }\n\n  if (crop->crop_mode & CROP_ROTATE) /* rotate should be last as it can reallocate the buffer */\n    {\n    if (rotateImage(crop->rotation, image, &crop->combined_width, \n                    &crop->combined_length, crop_buff_ptr))\n      {\n      TIFFError(\"createCroppedImage\", \n                \"Failed to rotate image or cropped selection by %\"PRIu16\" degrees\", crop->rotation);\n      return (-1);\n      }\n    }\n\n  if (crop_buff == read_buff) /* we used the read buffer for the crop buffer */\n    *read_buff_ptr = NULL;    /* so we don't try to free it later */\n\n  return (0);\n  }",
        "diff_func": "--- func_before\n+++ func_after\n@@ -21,7 +21,11 @@\n   if (!crop_buff)\n     {\n     crop_buff = (unsigned char *)limitMalloc(cropsize);\n-    *crop_buff_ptr = crop_buff;\n+    if (!crop_buff)\n+    {\n+        TIFFError(\"createCroppedImage\", \"Unable to allocate/reallocate crop buffer\");\n+        return (-1);\n+    }\n     _TIFFmemset(crop_buff, 0, cropsize);\n     prev_cropsize = cropsize;\n     }\n@@ -37,15 +41,15 @@\n         }\n       else\n         crop_buff = new_buff;\n+      if (!crop_buff)\n+      {\n+          TIFFError(\"createCroppedImage\", \"Unable to allocate/reallocate crop buffer\");\n+          return (-1);\n+      }\n       _TIFFmemset(crop_buff, 0, cropsize);\n       }\n     }\n \n-  if (!crop_buff)\n-    {\n-    TIFFError(\"createCroppedImage\", \"Unable to allocate/reallocate crop buffer\");\n-    return (-1);\n-    }\n   *crop_buff_ptr = crop_buff;\n \n   if (crop->crop_mode & CROP_INVERT)",
        "diff_line_info": {
            "deleted_lines": [
                "    *crop_buff_ptr = crop_buff;",
                "  if (!crop_buff)",
                "    {",
                "    TIFFError(\"createCroppedImage\", \"Unable to allocate/reallocate crop buffer\");",
                "    return (-1);",
                "    }"
            ],
            "added_lines": [
                "    if (!crop_buff)",
                "    {",
                "        TIFFError(\"createCroppedImage\", \"Unable to allocate/reallocate crop buffer\");",
                "        return (-1);",
                "    }",
                "      if (!crop_buff)",
                "      {",
                "          TIFFError(\"createCroppedImage\", \"Unable to allocate/reallocate crop buffer\");",
                "          return (-1);",
                "      }"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-42780",
        "func_name": "OpenSC/insert_pin",
        "description": "A use after return issue was found in Opensc before version 0.22.0 in insert_pin function that could potentially crash programs using the library.",
        "git_url": "https://github.com/OpenSC/OpenSC/commit/5df913b7f57ad89b9832555d24c08d23a534311e",
        "commit_title": "tcos: Check bounds in insert_pin()",
        "commit_text": " Thanks oss-fuzz  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=28383",
        "func_before": "static int insert_pin(\n\tsc_pkcs15_card_t *p15card,\n\tconst char       *path,\n\tunsigned char     id,\n\tunsigned char     auth_id,\n\tunsigned char     pin_reference,\n\tint               min_length,\n\tconst char       *label,\n\tint               pin_flags\n){\n\tsc_card_t *card=p15card->card;\n\tsc_context_t *ctx=p15card->card->ctx;\n\tsc_file_t *f = NULL;\n\tstruct sc_pkcs15_auth_info pin_info;\n\tstruct sc_pkcs15_object pin_obj;\n\tint r;\n\n\tmemset(&pin_info, 0, sizeof(pin_info));\n\tpin_info.auth_id.len      = 1;\n\tpin_info.auth_id.value[0] = id;\n\tpin_info.auth_type = SC_PKCS15_PIN_AUTH_TYPE_PIN;\n\tpin_info.attrs.pin.reference        = pin_reference;\n\tpin_info.attrs.pin.flags            = pin_flags;\n\tpin_info.attrs.pin.type             = SC_PKCS15_PIN_TYPE_ASCII_NUMERIC;\n\tpin_info.attrs.pin.min_length       = min_length;\n\tpin_info.attrs.pin.stored_length    = 16;\n\tpin_info.attrs.pin.max_length       = 16;\n\tpin_info.attrs.pin.pad_char         = '\\0';\n\tpin_info.logged_in = SC_PIN_STATE_UNKNOWN;\n\tsc_format_path(path, &pin_info.path);\n\n\tmemset(&pin_obj, 0, sizeof(pin_obj));\n\tstrlcpy(pin_obj.label, label, sizeof(pin_obj.label));\n\tpin_obj.flags            = SC_PKCS15_CO_FLAG_MODIFIABLE | SC_PKCS15_CO_FLAG_PRIVATE;\n\tpin_obj.auth_id.len      = auth_id ? 0 : 1;\n\tpin_obj.auth_id.value[0] = auth_id;\n\n\tif(card->type == SC_CARD_TYPE_TCOS_V3) {\n\t\tunsigned char buf[256];\n\t\tint i, rec_no=0;\n\t\tif (pin_info.path.len >= 2) {\n\t\t\tpin_info.path.len -= 2;\n\t\t}\n\t\tsc_append_file_id(&pin_info.path, 0x5049);\n\t\tif (sc_select_file(card, &pin_info.path, NULL) != SC_SUCCESS) {\n\t\t\tsc_log(ctx, \n\t\t\t\t\"Select(%s) failed\\n\",\n\t\t\t\tsc_print_path(&pin_info.path));\n\t\t\treturn 1;\n\t\t}\n\t\tsc_log(ctx, \n\t\t\t\"Searching for PIN-Ref %02X\\n\", pin_reference);\n\t\twhile ((r = sc_read_record(card, ++rec_no, buf, sizeof(buf), SC_RECORD_BY_REC_NR)) > 0) {\n\t\t\tint found = 0, fbz = -1;\n\t\t\tif (buf[0] != 0xA0)\n\t\t\t\tcontinue;\n\t\t\tfor (i = 2; i < buf[1] + 2; i += 2 + buf[i + 1]) {\n\t\t\t\tif (buf[i] == 0x83 && buf[i + 1] == 1 && buf[i + 2] == pin_reference) {\n\t\t\t\t\t++found;\n\t\t\t\t}\n\t\t\t\tif (buf[i] == 0x90) {\n\t\t\t\t\tfbz = buf[i + 1 + buf[i + 1]];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (found) {\n\t\t\t\tpin_info.tries_left = fbz;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (r <= 0) {\n\t\t\tsc_log(ctx, \"No EF_PWDD-Record found\\n\");\n\t\t\treturn 1;\n\t\t}\n\t} else {\n\t\tif (sc_select_file(card, &pin_info.path, &f) != SC_SUCCESS\n\t\t\t   \t|| !f->prop_attr || f->prop_attr_len < 4){\n\t\t\tsc_log(ctx, \"Select(%s) failed\\n\", path);\n\t\t\tsc_file_free(f);\n\t\t\treturn 1;\n\t\t}\n\t\tpin_info.tries_left = f->prop_attr[3];\n\t\tsc_file_free(f);\n\t}\n\n\tr=sc_pkcs15emu_add_pin_obj(p15card, &pin_obj, &pin_info);\n\tif(r!=SC_SUCCESS){\n\t\tsc_log(ctx,  \"sc_pkcs15emu_add_pin_obj(%s) failed\\n\", path);\n\t\treturn 4;\n\t}\n\tsc_log(ctx,  \"%s: OK, FBZ=%d\\n\", path, pin_info.tries_left);\n\treturn 0;\n}",
        "func": "static int insert_pin(\n\tsc_pkcs15_card_t *p15card,\n\tconst char       *path,\n\tunsigned char     id,\n\tunsigned char     auth_id,\n\tunsigned char     pin_reference,\n\tint               min_length,\n\tconst char       *label,\n\tint               pin_flags\n){\n\tsc_card_t *card=p15card->card;\n\tsc_context_t *ctx=p15card->card->ctx;\n\tsc_file_t *f = NULL;\n\tstruct sc_pkcs15_auth_info pin_info;\n\tstruct sc_pkcs15_object pin_obj;\n\tint r;\n\n\tmemset(&pin_info, 0, sizeof(pin_info));\n\tpin_info.auth_id.len      = 1;\n\tpin_info.auth_id.value[0] = id;\n\tpin_info.auth_type = SC_PKCS15_PIN_AUTH_TYPE_PIN;\n\tpin_info.attrs.pin.reference        = pin_reference;\n\tpin_info.attrs.pin.flags            = pin_flags;\n\tpin_info.attrs.pin.type             = SC_PKCS15_PIN_TYPE_ASCII_NUMERIC;\n\tpin_info.attrs.pin.min_length       = min_length;\n\tpin_info.attrs.pin.stored_length    = 16;\n\tpin_info.attrs.pin.max_length       = 16;\n\tpin_info.attrs.pin.pad_char         = '\\0';\n\tpin_info.logged_in = SC_PIN_STATE_UNKNOWN;\n\tsc_format_path(path, &pin_info.path);\n\n\tmemset(&pin_obj, 0, sizeof(pin_obj));\n\tstrlcpy(pin_obj.label, label, sizeof(pin_obj.label));\n\tpin_obj.flags            = SC_PKCS15_CO_FLAG_MODIFIABLE | SC_PKCS15_CO_FLAG_PRIVATE;\n\tpin_obj.auth_id.len      = auth_id ? 0 : 1;\n\tpin_obj.auth_id.value[0] = auth_id;\n\n\tif(card->type == SC_CARD_TYPE_TCOS_V3) {\n\t\tunsigned char buf[256];\n\t\tint i, rec_no=0;\n\t\tif (pin_info.path.len >= 2) {\n\t\t\tpin_info.path.len -= 2;\n\t\t}\n\t\tsc_append_file_id(&pin_info.path, 0x5049);\n\t\tif (sc_select_file(card, &pin_info.path, NULL) != SC_SUCCESS) {\n\t\t\tsc_log(ctx, \n\t\t\t\t\"Select(%s) failed\\n\",\n\t\t\t\tsc_print_path(&pin_info.path));\n\t\t\treturn 1;\n\t\t}\n\t\tsc_log(ctx, \n\t\t\t\"Searching for PIN-Ref %02X\\n\", pin_reference);\n\t\twhile ((r = sc_read_record(card, ++rec_no, buf, sizeof(buf), SC_RECORD_BY_REC_NR)) > 0) {\n\t\t\tint found = 0, fbz = -1;\n\t\t\tif (r < 2 || buf[0] != 0xA0)\n\t\t\t\tcontinue;\n\t\t\tfor (i = 2; i < buf[1] + 2 && (i + 2) < r; i += 2 + buf[i + 1]) {\n\t\t\t\tif (buf[i] == 0x83 && buf[i + 1] == 1 && buf[i + 2] == pin_reference) {\n\t\t\t\t\t++found;\n\t\t\t\t}\n\t\t\t\tif (buf[i] == 0x90 && (i + 1 + buf[i + 1]) < r) {\n\t\t\t\t\tfbz = buf[i + 1 + buf[i + 1]];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (found) {\n\t\t\t\tpin_info.tries_left = fbz;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (r <= 0) {\n\t\t\tsc_log(ctx, \"No EF_PWDD-Record found\\n\");\n\t\t\treturn 1;\n\t\t}\n\t} else {\n\t\tif (sc_select_file(card, &pin_info.path, &f) != SC_SUCCESS\n\t\t\t   \t|| !f->prop_attr || f->prop_attr_len < 4){\n\t\t\tsc_log(ctx, \"Select(%s) failed\\n\", path);\n\t\t\tsc_file_free(f);\n\t\t\treturn 1;\n\t\t}\n\t\tpin_info.tries_left = f->prop_attr[3];\n\t\tsc_file_free(f);\n\t}\n\n\tr=sc_pkcs15emu_add_pin_obj(p15card, &pin_obj, &pin_info);\n\tif(r!=SC_SUCCESS){\n\t\tsc_log(ctx,  \"sc_pkcs15emu_add_pin_obj(%s) failed\\n\", path);\n\t\treturn 4;\n\t}\n\tsc_log(ctx,  \"%s: OK, FBZ=%d\\n\", path, pin_info.tries_left);\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -52,13 +52,13 @@\n \t\t\t\"Searching for PIN-Ref %02X\\n\", pin_reference);\n \t\twhile ((r = sc_read_record(card, ++rec_no, buf, sizeof(buf), SC_RECORD_BY_REC_NR)) > 0) {\n \t\t\tint found = 0, fbz = -1;\n-\t\t\tif (buf[0] != 0xA0)\n+\t\t\tif (r < 2 || buf[0] != 0xA0)\n \t\t\t\tcontinue;\n-\t\t\tfor (i = 2; i < buf[1] + 2; i += 2 + buf[i + 1]) {\n+\t\t\tfor (i = 2; i < buf[1] + 2 && (i + 2) < r; i += 2 + buf[i + 1]) {\n \t\t\t\tif (buf[i] == 0x83 && buf[i + 1] == 1 && buf[i + 2] == pin_reference) {\n \t\t\t\t\t++found;\n \t\t\t\t}\n-\t\t\t\tif (buf[i] == 0x90) {\n+\t\t\t\tif (buf[i] == 0x90 && (i + 1 + buf[i + 1]) < r) {\n \t\t\t\t\tfbz = buf[i + 1 + buf[i + 1]];\n \t\t\t\t}\n \t\t\t}",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\tif (buf[0] != 0xA0)",
                "\t\t\tfor (i = 2; i < buf[1] + 2; i += 2 + buf[i + 1]) {",
                "\t\t\t\tif (buf[i] == 0x90) {"
            ],
            "added_lines": [
                "\t\t\tif (r < 2 || buf[0] != 0xA0)",
                "\t\t\tfor (i = 2; i < buf[1] + 2 && (i + 2) < r; i += 2 + buf[i + 1]) {",
                "\t\t\t\tif (buf[i] == 0x90 && (i + 1 + buf[i + 1]) < r) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-14367",
        "func_name": "wireshark/dissect_coap",
        "description": "In Wireshark 2.6.0 to 2.6.1 and 2.4.0 to 2.4.7, the CoAP protocol dissector could crash. This was addressed in epan/dissectors/packet-coap.c by properly checking for a NULL condition.",
        "git_url": "https://github.com/wireshark/wireshark/commit/81ce5fcb3e37a0aaeb7532f7a2a09366f16fa310",
        "commit_title": "CoAP: handle per packet data properly",
        "commit_text": " Bug: 14966 (cherry picked from commit b9c18a4188864a5c47d9c9b299cd97cba236a472)",
        "func_before": "static int\ndissect_coap(tvbuff_t *tvb, packet_info *pinfo, proto_tree *parent_tree, void* data _U_)\n{\n\tgint              offset = 0;\n\tproto_item       *coap_root;\n\tproto_item       *pi;\n\tproto_tree       *coap_tree;\n\tguint8            ttype;\n\tguint8            token_len;\n\tguint8            code;\n\tguint8            code_class;\n\tguint16           mid;\n\tgint              coap_length;\n\tgchar            *coap_token_str;\n\tcoap_info        *coinfo;\n\tconversation_t   *conversation;\n\tcoap_conv_info   *ccinfo;\n\tcoap_transaction *coap_trans = NULL;\n\n\t/* Allocate information for upper layers */\n\tif (!PINFO_FD_VISITED(pinfo)) {\n\t\tcoinfo = wmem_new0(wmem_file_scope(), coap_info);\n\t\tp_add_proto_data(wmem_file_scope(), pinfo, proto_coap, 0, coinfo);\n\t} else {\n\t\tcoinfo = (coap_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_coap, 0);\n\t}\n\n\t/* initialize the CoAP length and the content-Format */\n\t/*\n\t * the length of CoAP message is not specified in the CoAP header.\n\t * It has to be from the lower layer.\n\t * Currently, the length is just copied from the reported length of the tvbuffer.\n\t */\n\tcoap_length = tvb_reported_length(tvb);\n\tcoinfo->ctype_str = \"\";\n\tcoinfo->ctype_value = DEFAULT_COAP_CTYPE_VALUE;\n\n\tcol_set_str(pinfo->cinfo, COL_PROTOCOL, \"CoAP\");\n\tcol_clear(pinfo->cinfo, COL_INFO);\n\n\tcoap_root = proto_tree_add_item(parent_tree, proto_coap, tvb, offset, -1, ENC_NA);\n\tcoap_tree = proto_item_add_subtree(coap_root, ett_coap);\n\n\tproto_tree_add_item(coap_tree, hf_coap_version, tvb, offset, 1, ENC_BIG_ENDIAN);\n\n\tproto_tree_add_item(coap_tree, hf_coap_ttype, tvb, offset, 1, ENC_BIG_ENDIAN);\n\tttype = (tvb_get_guint8(tvb, offset) & 0x30) >> 4;\n\n\tproto_tree_add_item(coap_tree, hf_coap_token_len, tvb, offset, 1, ENC_BIG_ENDIAN);\n\ttoken_len = tvb_get_guint8(tvb, offset) & 0x0f;\n\n\toffset += 1;\n\n\tproto_tree_add_item(coap_tree, hf_coap_code, tvb, offset, 1, ENC_BIG_ENDIAN);\n\tcode = tvb_get_guint8(tvb, offset);\n\tcode_class = code >> 5;\n\toffset += 1;\n\n\tproto_tree_add_item(coap_tree, hf_coap_mid, tvb, offset, 2, ENC_BIG_ENDIAN);\n\tmid = tvb_get_ntohs(tvb, offset);\n\n\tcol_add_fstr(pinfo->cinfo, COL_INFO,\n\t\t     \"%s, MID:%u, %s\",\n\t\t     val_to_str(ttype, vals_ttype_short, \"Unknown %u\"),\n\t\t     mid,\n\t\t     val_to_str_ext(code, &vals_code_ext, \"Unknown %u\"));\n\n\t/* append the header information */\n\tproto_item_append_text(coap_root,\n\t\t\t       \", %s, %s, MID:%u\",\n\t\t\t       val_to_str(ttype, vals_ttype, \"Unknown %u\"),\n\t\t\t       val_to_str_ext(code, &vals_code_ext, \"Unknown %u\"),\n\t\t\t       mid);\n\n\toffset += 2;\n\n\t/* initialize the external value */\n\tcoinfo->block_number = DEFAULT_COAP_BLOCK_NUMBER;\n\tcoinfo->block_mflag  = 0;\n\tcoinfo->uri_str_strbuf   = wmem_strbuf_sized_new(wmem_packet_scope(), 0, 1024);\n\tcoinfo->uri_query_strbuf = wmem_strbuf_sized_new(wmem_packet_scope(), 0, 1024);\n\tcoap_token_str = NULL;\n\tif (token_len > 0)\n\t{\n\t\t/* This has to be file scope as the token string is stored in the map\n\t\t* for conversation lookup */\n\t\tcoap_token_str = tvb_bytes_to_str_punct(wmem_file_scope(), tvb, offset, token_len, ' ');\n\t\tproto_tree_add_item(coap_tree, hf_coap_token,\n\t\t\t\t    tvb, offset, token_len, ENC_NA);\n\t\toffset += token_len;\n\t}\n\n\t/* process options */\n\toffset = dissect_coap_options(tvb, pinfo, coap_tree, offset, coap_length, coinfo);\n\tif (offset == -1)\n\t\treturn tvb_captured_length(tvb);\n\n\t/* Use conversations to track state for request/response */\n\tconversation = find_or_create_conversation_noaddrb(pinfo, (code_class == 0));\n\n\t/* Retrieve or create state structure for this conversation */\n\tccinfo = (coap_conv_info *)conversation_get_proto_data(conversation, proto_coap);\n\tif (!ccinfo) {\n\t\t/* No state structure - create it */\n\t\tccinfo = wmem_new(wmem_file_scope(), coap_conv_info);\n\t\tccinfo->messages = wmem_map_new(wmem_file_scope(), g_str_hash, g_str_equal);\n\t\tconversation_add_proto_data(conversation, proto_coap, ccinfo);\n\t}\n\n\t/* Everything based on tokens */\n\tif (coap_token_str != NULL) {\n\t\t/* Process request/response in conversation */\n\t\tif (code != 0) { /* Ignore empty messages */\n\t\t\t/* Try and look up a matching token. If it's the first\n\t\t\t* sight of a request, there shouldn't be one */\n\t\t\tcoap_trans = (coap_transaction *)wmem_map_lookup(ccinfo->messages, coap_token_str);\n\t\t\tif (!coap_trans) {\n\t\t\t\tif ((!PINFO_FD_VISITED(pinfo)) && (code_class == 0)) {\n\t\t\t\t\t/* New request - log it */\n\t\t\t\t\tcoap_trans = wmem_new(wmem_file_scope(), coap_transaction);\n\t\t\t\t\tcoap_trans->req_frame = pinfo->num;\n\t\t\t\t\tcoap_trans->rsp_frame = 0;\n\t\t\t\t\tcoap_trans->req_time = pinfo->fd->abs_ts;\n\t\t\t\t\tif (coinfo->uri_str_strbuf) {\n\t\t\t\t\t\t/* Store the URI into CoAP transaction info */\n\t\t\t\t\t\tcoap_trans->uri_str_strbuf = wmem_strbuf_new(wmem_file_scope(), wmem_strbuf_get_str(coinfo->uri_str_strbuf));\n\t\t\t\t\t}\n\t\t\t\t\twmem_map_insert(ccinfo->messages, coap_token_str, (void *)coap_trans);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif ((code_class >= 2) && (code_class <= 5)) {\n\t\t\t\t\tif (!PINFO_FD_VISITED(pinfo)) {\n\t\t\t\t\t\t/* Log the first matching response frame */\n\t\t\t\t\t\tcoap_trans->rsp_frame = pinfo->num;\n\t\t\t\t\t}\n\t\t\t\t\tif (coap_trans->uri_str_strbuf) {\n\t\t\t\t\t\t/* Copy the URI stored in matching transaction info into CoAP packet info */\n\t\t\t\t\t\tcoinfo->uri_str_strbuf = wmem_strbuf_new(wmem_packet_scope(), wmem_strbuf_get_str(coap_trans->uri_str_strbuf));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (coap_trans != NULL) {\n\t\t/* Print state tracking in the tree */\n\t\tif (code_class == 0) {\n\t\t\t/* This is a request */\n\t\t\tif (coap_trans->rsp_frame) {\n\t\t\t\tproto_item *it;\n\n\t\t\t\tit = proto_tree_add_uint(coap_tree, hf_coap_response_in,\n\t\t\t\t\t\ttvb, 0, 0, coap_trans->rsp_frame);\n\t\t\t\tPROTO_ITEM_SET_GENERATED(it);\n\t\t\t}\n\t\t} else if ((code_class >= 2) && (code_class <= 5)) {\n\t\t\t/* This is a reply */\n\t\t\tif (coap_trans->req_frame) {\n\t\t\t\tproto_item *it;\n\t\t\t\tnstime_t ns;\n\n\t\t\t\tit = proto_tree_add_uint(coap_tree, hf_coap_response_to,\n\t\t\t\t\t\ttvb, 0, 0, coap_trans->req_frame);\n\t\t\t\tPROTO_ITEM_SET_GENERATED(it);\n\n\t\t\t\tnstime_delta(&ns, &pinfo->fd->abs_ts, &coap_trans->req_time);\n\t\t\t\tit = proto_tree_add_time(coap_tree, hf_coap_response_time, tvb, 0, 0, &ns);\n\t\t\t\tPROTO_ITEM_SET_GENERATED(it);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* add informations to the packet list */\n\tif (coap_token_str != NULL)\n\t\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", TKN:%s\", coap_token_str);\n\tif (coinfo->block_number != DEFAULT_COAP_BLOCK_NUMBER)\n\t\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", %sBlock #%u\",\n\t\t\t\tcoinfo->block_mflag ? \"\" : \"End of \", coinfo->block_number);\n\tif (wmem_strbuf_get_len(coinfo->uri_str_strbuf) > 0) {\n\t\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", %s\", wmem_strbuf_get_str(coinfo->uri_str_strbuf));\n\t\t/* Add to hidden protocol item as well */\n\t\tpi = proto_tree_add_string(coap_tree, hf_coap_opt_uri_path_recon, tvb, 0, 0, wmem_strbuf_get_str(coinfo->uri_str_strbuf));\n\t\tPROTO_ITEM_SET_HIDDEN(pi);\n\t}\n\tif (wmem_strbuf_get_len(coinfo->uri_query_strbuf)> 0)\n\t\tcol_append_str(pinfo->cinfo, COL_INFO, wmem_strbuf_get_str(coinfo->uri_query_strbuf));\n\n\t/* dissect the payload */\n\tif (coap_length > offset) {\n\t\tproto_tree *payload_tree;\n\t\tproto_item *payload_item, *length_item;\n\t\ttvbuff_t   *payload_tvb;\n\t\tguint\t    payload_length = coap_length - offset;\n\t\tconst char *coap_ctype_str_dis;\n\t\tchar\t    str_payload[80];\n\n\t\t/* coinfo->ctype_value == DEFAULT_COAP_CTYPE_VALUE: No Content-Format option present */\n\t\t/* coinfo->ctype_value == 0: Content-Format option present with length 0 */\n\t\tif (coinfo->ctype_value == DEFAULT_COAP_CTYPE_VALUE || coinfo->ctype_value == 0) {\n\t\t\t/*\n\t\t\t* 5.5.2.  Diagnostic Payload\n\t\t\t*\n\t\t\t* If no Content-Format option is given, the payload of responses\n\t\t\t* indicating a client or server error is a brief human-readable\n\t\t\t* diagnostic message, explaining the error situation. This diagnostic\n\t\t\t* message MUST be encoded using UTF-8 [RFC3629], more specifically\n\t\t\t* using Net-Unicode form [RFC5198].\n\t\t\t*/\n\t\t\tif ((code_class >= 4) && (code_class <= 5)) {\n\t\t\t\tcoinfo->ctype_str = \"text/plain; charset=utf-8\";\n\t\t\t\tcoap_ctype_str_dis = \"text/plain\";\n\t\t\t} else {\n\t\t\t\t/* Assume no Content-Format is opaque octet stream */\n\t\t\t\tcoinfo->ctype_str = \"application/octet-stream\";\n\t\t\t\tcoap_ctype_str_dis = coinfo->ctype_str;\n\t\t\t}\n\t\t} else {\n\t\t\tcoap_ctype_str_dis = coinfo->ctype_str;\n\t\t}\n\n\t\tg_snprintf(str_payload, sizeof(str_payload),\n\t\t\t\"Payload Content-Format: %s%s, Length: %u\",\n\t\t\tcoinfo->ctype_str, coinfo->ctype_value == DEFAULT_COAP_CTYPE_VALUE ?\n\t\t\t\" (no Content-Format)\" : \"\", payload_length);\n\n\t\tpayload_item = proto_tree_add_string(coap_tree, hf_coap_payload,\n\t\t\t\t\t\t     tvb, offset, payload_length,\n\t\t\t\t\t\t     str_payload);\n\t\tpayload_tree = proto_item_add_subtree(payload_item, ett_coap_payload);\n\n\t\tproto_tree_add_string(payload_tree, hf_coap_payload_desc, tvb, offset, 0, coinfo->ctype_str);\n\t\tlength_item = proto_tree_add_uint(payload_tree, hf_coap_payload_length, tvb, offset, 0, payload_length);\n\t\tPROTO_ITEM_SET_GENERATED(length_item);\n\t\tpayload_tvb = tvb_new_subset_length(tvb, offset, payload_length);\n\n\t\tdissector_try_string(media_type_dissector_table, coap_ctype_str_dis,\n\t\t\t\t     payload_tvb, pinfo, parent_tree, NULL);\n\t}\n\n\treturn tvb_captured_length(tvb);\n}",
        "func": "static int\ndissect_coap(tvbuff_t *tvb, packet_info *pinfo, proto_tree *parent_tree, void* data _U_)\n{\n\tgint              offset = 0;\n\tproto_item       *coap_root;\n\tproto_item       *pi;\n\tproto_tree       *coap_tree;\n\tguint8            ttype;\n\tguint8            token_len;\n\tguint8            code;\n\tguint8            code_class;\n\tguint16           mid;\n\tgint              coap_length;\n\tgchar            *coap_token_str;\n\tcoap_info        *coinfo;\n\tconversation_t   *conversation;\n\tcoap_conv_info   *ccinfo;\n\tcoap_transaction *coap_trans = NULL;\n\n\t/* Allocate information for upper layers */\n\tcoinfo = (coap_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_coap, 0);\n\n\tif (coinfo == NULL)\n\t{\n\t\tcoinfo = wmem_new0(wmem_file_scope(), coap_info);\n\t\tp_add_proto_data(wmem_file_scope(), pinfo, proto_coap, 0, coinfo);\n\t}\n\n\t/* initialize the CoAP length and the content-Format */\n\t/*\n\t * the length of CoAP message is not specified in the CoAP header.\n\t * It has to be from the lower layer.\n\t * Currently, the length is just copied from the reported length of the tvbuffer.\n\t */\n\tcoap_length = tvb_reported_length(tvb);\n\tcoinfo->ctype_str = \"\";\n\tcoinfo->ctype_value = DEFAULT_COAP_CTYPE_VALUE;\n\n\tcol_set_str(pinfo->cinfo, COL_PROTOCOL, \"CoAP\");\n\tcol_clear(pinfo->cinfo, COL_INFO);\n\n\tcoap_root = proto_tree_add_item(parent_tree, proto_coap, tvb, offset, -1, ENC_NA);\n\tcoap_tree = proto_item_add_subtree(coap_root, ett_coap);\n\n\tproto_tree_add_item(coap_tree, hf_coap_version, tvb, offset, 1, ENC_BIG_ENDIAN);\n\n\tproto_tree_add_item(coap_tree, hf_coap_ttype, tvb, offset, 1, ENC_BIG_ENDIAN);\n\tttype = (tvb_get_guint8(tvb, offset) & 0x30) >> 4;\n\n\tproto_tree_add_item(coap_tree, hf_coap_token_len, tvb, offset, 1, ENC_BIG_ENDIAN);\n\ttoken_len = tvb_get_guint8(tvb, offset) & 0x0f;\n\n\toffset += 1;\n\n\tproto_tree_add_item(coap_tree, hf_coap_code, tvb, offset, 1, ENC_BIG_ENDIAN);\n\tcode = tvb_get_guint8(tvb, offset);\n\tcode_class = code >> 5;\n\toffset += 1;\n\n\tproto_tree_add_item(coap_tree, hf_coap_mid, tvb, offset, 2, ENC_BIG_ENDIAN);\n\tmid = tvb_get_ntohs(tvb, offset);\n\n\tcol_add_fstr(pinfo->cinfo, COL_INFO,\n\t\t     \"%s, MID:%u, %s\",\n\t\t     val_to_str(ttype, vals_ttype_short, \"Unknown %u\"),\n\t\t     mid,\n\t\t     val_to_str_ext(code, &vals_code_ext, \"Unknown %u\"));\n\n\t/* append the header information */\n\tproto_item_append_text(coap_root,\n\t\t\t       \", %s, %s, MID:%u\",\n\t\t\t       val_to_str(ttype, vals_ttype, \"Unknown %u\"),\n\t\t\t       val_to_str_ext(code, &vals_code_ext, \"Unknown %u\"),\n\t\t\t       mid);\n\n\toffset += 2;\n\n\t/* initialize the external value */\n\tcoinfo->block_number = DEFAULT_COAP_BLOCK_NUMBER;\n\tcoinfo->block_mflag  = 0;\n\tcoinfo->uri_str_strbuf   = wmem_strbuf_sized_new(wmem_packet_scope(), 0, 1024);\n\tcoinfo->uri_query_strbuf = wmem_strbuf_sized_new(wmem_packet_scope(), 0, 1024);\n\tcoap_token_str = NULL;\n\tif (token_len > 0)\n\t{\n\t\t/* This has to be file scope as the token string is stored in the map\n\t\t* for conversation lookup */\n\t\tcoap_token_str = tvb_bytes_to_str_punct(wmem_file_scope(), tvb, offset, token_len, ' ');\n\t\tproto_tree_add_item(coap_tree, hf_coap_token,\n\t\t\t\t    tvb, offset, token_len, ENC_NA);\n\t\toffset += token_len;\n\t}\n\n\t/* process options */\n\toffset = dissect_coap_options(tvb, pinfo, coap_tree, offset, coap_length, coinfo);\n\tif (offset == -1)\n\t\treturn tvb_captured_length(tvb);\n\n\t/* Use conversations to track state for request/response */\n\tconversation = find_or_create_conversation_noaddrb(pinfo, (code_class == 0));\n\n\t/* Retrieve or create state structure for this conversation */\n\tccinfo = (coap_conv_info *)conversation_get_proto_data(conversation, proto_coap);\n\tif (!ccinfo) {\n\t\t/* No state structure - create it */\n\t\tccinfo = wmem_new(wmem_file_scope(), coap_conv_info);\n\t\tccinfo->messages = wmem_map_new(wmem_file_scope(), g_str_hash, g_str_equal);\n\t\tconversation_add_proto_data(conversation, proto_coap, ccinfo);\n\t}\n\n\t/* Everything based on tokens */\n\tif (coap_token_str != NULL) {\n\t\t/* Process request/response in conversation */\n\t\tif (code != 0) { /* Ignore empty messages */\n\t\t\t/* Try and look up a matching token. If it's the first\n\t\t\t* sight of a request, there shouldn't be one */\n\t\t\tcoap_trans = (coap_transaction *)wmem_map_lookup(ccinfo->messages, coap_token_str);\n\t\t\tif (!coap_trans) {\n\t\t\t\tif ((!PINFO_FD_VISITED(pinfo)) && (code_class == 0)) {\n\t\t\t\t\t/* New request - log it */\n\t\t\t\t\tcoap_trans = wmem_new(wmem_file_scope(), coap_transaction);\n\t\t\t\t\tcoap_trans->req_frame = pinfo->num;\n\t\t\t\t\tcoap_trans->rsp_frame = 0;\n\t\t\t\t\tcoap_trans->req_time = pinfo->fd->abs_ts;\n\t\t\t\t\tif (coinfo->uri_str_strbuf) {\n\t\t\t\t\t\t/* Store the URI into CoAP transaction info */\n\t\t\t\t\t\tcoap_trans->uri_str_strbuf = wmem_strbuf_new(wmem_file_scope(), wmem_strbuf_get_str(coinfo->uri_str_strbuf));\n\t\t\t\t\t}\n\t\t\t\t\twmem_map_insert(ccinfo->messages, coap_token_str, (void *)coap_trans);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif ((code_class >= 2) && (code_class <= 5)) {\n\t\t\t\t\tif (!PINFO_FD_VISITED(pinfo)) {\n\t\t\t\t\t\t/* Log the first matching response frame */\n\t\t\t\t\t\tcoap_trans->rsp_frame = pinfo->num;\n\t\t\t\t\t}\n\t\t\t\t\tif (coap_trans->uri_str_strbuf) {\n\t\t\t\t\t\t/* Copy the URI stored in matching transaction info into CoAP packet info */\n\t\t\t\t\t\tcoinfo->uri_str_strbuf = wmem_strbuf_new(wmem_packet_scope(), wmem_strbuf_get_str(coap_trans->uri_str_strbuf));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (coap_trans != NULL) {\n\t\t/* Print state tracking in the tree */\n\t\tif (code_class == 0) {\n\t\t\t/* This is a request */\n\t\t\tif (coap_trans->rsp_frame) {\n\t\t\t\tproto_item *it;\n\n\t\t\t\tit = proto_tree_add_uint(coap_tree, hf_coap_response_in,\n\t\t\t\t\t\ttvb, 0, 0, coap_trans->rsp_frame);\n\t\t\t\tPROTO_ITEM_SET_GENERATED(it);\n\t\t\t}\n\t\t} else if ((code_class >= 2) && (code_class <= 5)) {\n\t\t\t/* This is a reply */\n\t\t\tif (coap_trans->req_frame) {\n\t\t\t\tproto_item *it;\n\t\t\t\tnstime_t ns;\n\n\t\t\t\tit = proto_tree_add_uint(coap_tree, hf_coap_response_to,\n\t\t\t\t\t\ttvb, 0, 0, coap_trans->req_frame);\n\t\t\t\tPROTO_ITEM_SET_GENERATED(it);\n\n\t\t\t\tnstime_delta(&ns, &pinfo->fd->abs_ts, &coap_trans->req_time);\n\t\t\t\tit = proto_tree_add_time(coap_tree, hf_coap_response_time, tvb, 0, 0, &ns);\n\t\t\t\tPROTO_ITEM_SET_GENERATED(it);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* add informations to the packet list */\n\tif (coap_token_str != NULL)\n\t\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", TKN:%s\", coap_token_str);\n\tif (coinfo->block_number != DEFAULT_COAP_BLOCK_NUMBER)\n\t\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", %sBlock #%u\",\n\t\t\t\tcoinfo->block_mflag ? \"\" : \"End of \", coinfo->block_number);\n\tif (wmem_strbuf_get_len(coinfo->uri_str_strbuf) > 0) {\n\t\tcol_append_fstr(pinfo->cinfo, COL_INFO, \", %s\", wmem_strbuf_get_str(coinfo->uri_str_strbuf));\n\t\t/* Add to hidden protocol item as well */\n\t\tpi = proto_tree_add_string(coap_tree, hf_coap_opt_uri_path_recon, tvb, 0, 0, wmem_strbuf_get_str(coinfo->uri_str_strbuf));\n\t\tPROTO_ITEM_SET_HIDDEN(pi);\n\t}\n\tif (wmem_strbuf_get_len(coinfo->uri_query_strbuf)> 0)\n\t\tcol_append_str(pinfo->cinfo, COL_INFO, wmem_strbuf_get_str(coinfo->uri_query_strbuf));\n\n\t/* dissect the payload */\n\tif (coap_length > offset) {\n\t\tproto_tree *payload_tree;\n\t\tproto_item *payload_item, *length_item;\n\t\ttvbuff_t   *payload_tvb;\n\t\tguint\t    payload_length = coap_length - offset;\n\t\tconst char *coap_ctype_str_dis;\n\t\tchar\t    str_payload[80];\n\n\t\t/* coinfo->ctype_value == DEFAULT_COAP_CTYPE_VALUE: No Content-Format option present */\n\t\t/* coinfo->ctype_value == 0: Content-Format option present with length 0 */\n\t\tif (coinfo->ctype_value == DEFAULT_COAP_CTYPE_VALUE || coinfo->ctype_value == 0) {\n\t\t\t/*\n\t\t\t* 5.5.2.  Diagnostic Payload\n\t\t\t*\n\t\t\t* If no Content-Format option is given, the payload of responses\n\t\t\t* indicating a client or server error is a brief human-readable\n\t\t\t* diagnostic message, explaining the error situation. This diagnostic\n\t\t\t* message MUST be encoded using UTF-8 [RFC3629], more specifically\n\t\t\t* using Net-Unicode form [RFC5198].\n\t\t\t*/\n\t\t\tif ((code_class >= 4) && (code_class <= 5)) {\n\t\t\t\tcoinfo->ctype_str = \"text/plain; charset=utf-8\";\n\t\t\t\tcoap_ctype_str_dis = \"text/plain\";\n\t\t\t} else {\n\t\t\t\t/* Assume no Content-Format is opaque octet stream */\n\t\t\t\tcoinfo->ctype_str = \"application/octet-stream\";\n\t\t\t\tcoap_ctype_str_dis = coinfo->ctype_str;\n\t\t\t}\n\t\t} else {\n\t\t\tcoap_ctype_str_dis = coinfo->ctype_str;\n\t\t}\n\n\t\tg_snprintf(str_payload, sizeof(str_payload),\n\t\t\t\"Payload Content-Format: %s%s, Length: %u\",\n\t\t\tcoinfo->ctype_str, coinfo->ctype_value == DEFAULT_COAP_CTYPE_VALUE ?\n\t\t\t\" (no Content-Format)\" : \"\", payload_length);\n\n\t\tpayload_item = proto_tree_add_string(coap_tree, hf_coap_payload,\n\t\t\t\t\t\t     tvb, offset, payload_length,\n\t\t\t\t\t\t     str_payload);\n\t\tpayload_tree = proto_item_add_subtree(payload_item, ett_coap_payload);\n\n\t\tproto_tree_add_string(payload_tree, hf_coap_payload_desc, tvb, offset, 0, coinfo->ctype_str);\n\t\tlength_item = proto_tree_add_uint(payload_tree, hf_coap_payload_length, tvb, offset, 0, payload_length);\n\t\tPROTO_ITEM_SET_GENERATED(length_item);\n\t\tpayload_tvb = tvb_new_subset_length(tvb, offset, payload_length);\n\n\t\tdissector_try_string(media_type_dissector_table, coap_ctype_str_dis,\n\t\t\t\t     payload_tvb, pinfo, parent_tree, NULL);\n\t}\n\n\treturn tvb_captured_length(tvb);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -18,11 +18,12 @@\n \tcoap_transaction *coap_trans = NULL;\n \n \t/* Allocate information for upper layers */\n-\tif (!PINFO_FD_VISITED(pinfo)) {\n+\tcoinfo = (coap_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_coap, 0);\n+\n+\tif (coinfo == NULL)\n+\t{\n \t\tcoinfo = wmem_new0(wmem_file_scope(), coap_info);\n \t\tp_add_proto_data(wmem_file_scope(), pinfo, proto_coap, 0, coinfo);\n-\t} else {\n-\t\tcoinfo = (coap_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_coap, 0);\n \t}\n \n \t/* initialize the CoAP length and the content-Format */",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (!PINFO_FD_VISITED(pinfo)) {",
                "\t} else {",
                "\t\tcoinfo = (coap_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_coap, 0);"
            ],
            "added_lines": [
                "\tcoinfo = (coap_info *)p_get_proto_data(wmem_file_scope(), pinfo, proto_coap, 0);",
                "",
                "\tif (coinfo == NULL)",
                "\t{"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-16643",
        "func_name": "ImageMagick/ReadCALSImage",
        "description": "The functions ReadDCMImage in coders/dcm.c, ReadPWPImage in coders/pwp.c, ReadCALSImage in coders/cals.c, and ReadPICTImage in coders/pict.c in ImageMagick 7.0.8-4 do not check the return value of the fputc function, which allows remote attackers to cause a denial of service via a crafted image file.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/6b6bff054d569a77973f2140c0e86366e6168a6c",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/1199",
        "commit_text": "",
        "func_before": "static Image *ReadCALSImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  char\n    filename[MagickPathExtent],\n    header[MagickPathExtent],\n    message[MagickPathExtent];\n\n  FILE\n    *file;\n\n  Image\n    *image;\n\n  ImageInfo\n    *read_info;\n\n  int\n    c,\n    unique_file;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i;\n\n  unsigned long\n    density,\n    direction,\n    height,\n    orientation,\n    pel_path,\n    type,\n    width;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read CALS header.\n  */\n  (void) memset(header,0,sizeof(header));\n  density=0;\n  direction=0;\n  orientation=1;\n  pel_path=0;\n  type=1;\n  width=0;\n  height=0;\n  for (i=0; i < 16; i++)\n  {\n    if (ReadBlob(image,128,(unsigned char *) header) != 128)\n      break;\n    switch (*header)\n    {\n      case 'R':\n      case 'r':\n      {\n        if (LocaleNCompare(header,\"rdensty:\",8) == 0)\n          {\n            (void) sscanf(header+8,\"%lu\",&density);\n            break;\n          }\n        if (LocaleNCompare(header,\"rpelcnt:\",8) == 0)\n          {\n            (void) sscanf(header+8,\"%lu,%lu\",&width,&height);\n            break;\n          }\n        if (LocaleNCompare(header,\"rorient:\",8) == 0)\n          {\n            (void) sscanf(header+8,\"%lu,%lu\",&pel_path,&direction);\n            if (pel_path == 90)\n              orientation=5;\n            else\n              if (pel_path == 180)\n                orientation=3;\n              else\n                if (pel_path == 270)\n                  orientation=7;\n            if (direction == 90)\n              orientation++;\n            break;\n          }\n        if (LocaleNCompare(header,\"rtype:\",6) == 0)\n          {\n            (void) sscanf(header+6,\"%lu\",&type);\n            break;\n          }\n        break;\n      }\n    }\n  }\n  /*\n    Read CALS pixels.\n  */\n  file=(FILE *) NULL;\n  unique_file=AcquireUniqueFileResource(filename);\n  if (unique_file != -1)\n    file=fdopen(unique_file,\"wb\");\n  if ((unique_file == -1) || (file == (FILE *) NULL))\n    ThrowImageException(FileOpenError,\"UnableToCreateTemporaryFile\");\n  while ((c=ReadBlobByte(image)) != EOF)\n    (void) fputc(c,file);\n  (void) fclose(file);\n  (void) CloseBlob(image);\n  image=DestroyImage(image);\n  read_info=CloneImageInfo(image_info);\n  SetImageInfoBlob(read_info,(void *) NULL,0);\n  (void) FormatLocaleString(read_info->filename,MagickPathExtent,\"group4:%s\",\n    filename);\n  (void) FormatLocaleString(message,MagickPathExtent,\"%lux%lu\",width,height);\n  (void) CloneString(&read_info->size,message);\n  (void) FormatLocaleString(message,MagickPathExtent,\"%lu\",density);\n  (void) CloneString(&read_info->density,message);\n  read_info->orientation=(OrientationType) orientation;\n  image=ReadImage(read_info,exception);\n  if (image != (Image *) NULL)\n    {\n      (void) CopyMagickString(image->filename,image_info->filename,\n        MagickPathExtent);\n      (void) CopyMagickString(image->magick_filename,image_info->filename,\n        MagickPathExtent);\n      (void) CopyMagickString(image->magick,\"CALS\",MagickPathExtent);\n    }\n  read_info=DestroyImageInfo(read_info);\n  (void) RelinquishUniqueFileResource(filename);\n  return(image);\n}",
        "func": "static Image *ReadCALSImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  char\n    filename[MagickPathExtent],\n    header[MagickPathExtent],\n    message[MagickPathExtent];\n\n  FILE\n    *file;\n\n  Image\n    *image;\n\n  ImageInfo\n    *read_info;\n\n  int\n    c,\n    unique_file;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i;\n\n  unsigned long\n    density,\n    direction,\n    height,\n    orientation,\n    pel_path,\n    type,\n    width;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read CALS header.\n  */\n  (void) memset(header,0,sizeof(header));\n  density=0;\n  direction=0;\n  orientation=1;\n  pel_path=0;\n  type=1;\n  width=0;\n  height=0;\n  for (i=0; i < 16; i++)\n  {\n    if (ReadBlob(image,128,(unsigned char *) header) != 128)\n      break;\n    switch (*header)\n    {\n      case 'R':\n      case 'r':\n      {\n        if (LocaleNCompare(header,\"rdensty:\",8) == 0)\n          {\n            (void) sscanf(header+8,\"%lu\",&density);\n            break;\n          }\n        if (LocaleNCompare(header,\"rpelcnt:\",8) == 0)\n          {\n            (void) sscanf(header+8,\"%lu,%lu\",&width,&height);\n            break;\n          }\n        if (LocaleNCompare(header,\"rorient:\",8) == 0)\n          {\n            (void) sscanf(header+8,\"%lu,%lu\",&pel_path,&direction);\n            if (pel_path == 90)\n              orientation=5;\n            else\n              if (pel_path == 180)\n                orientation=3;\n              else\n                if (pel_path == 270)\n                  orientation=7;\n            if (direction == 90)\n              orientation++;\n            break;\n          }\n        if (LocaleNCompare(header,\"rtype:\",6) == 0)\n          {\n            (void) sscanf(header+6,\"%lu\",&type);\n            break;\n          }\n        break;\n      }\n    }\n  }\n  /*\n    Read CALS pixels.\n  */\n  file=(FILE *) NULL;\n  unique_file=AcquireUniqueFileResource(filename);\n  if (unique_file != -1)\n    file=fdopen(unique_file,\"wb\");\n  if ((unique_file == -1) || (file == (FILE *) NULL))\n    ThrowImageException(FileOpenError,\"UnableToCreateTemporaryFile\");\n  while ((c=ReadBlobByte(image)) != EOF)\n    if (fputc(c,file) != c)\n      break;\n  (void) fclose(file);\n  (void) CloseBlob(image);\n  image=DestroyImage(image);\n  read_info=CloneImageInfo(image_info);\n  SetImageInfoBlob(read_info,(void *) NULL,0);\n  (void) FormatLocaleString(read_info->filename,MagickPathExtent,\"group4:%s\",\n    filename);\n  (void) FormatLocaleString(message,MagickPathExtent,\"%lux%lu\",width,height);\n  (void) CloneString(&read_info->size,message);\n  (void) FormatLocaleString(message,MagickPathExtent,\"%lu\",density);\n  (void) CloneString(&read_info->density,message);\n  read_info->orientation=(OrientationType) orientation;\n  image=ReadImage(read_info,exception);\n  if (image != (Image *) NULL)\n    {\n      (void) CopyMagickString(image->filename,image_info->filename,\n        MagickPathExtent);\n      (void) CopyMagickString(image->magick_filename,image_info->filename,\n        MagickPathExtent);\n      (void) CopyMagickString(image->magick,\"CALS\",MagickPathExtent);\n    }\n  read_info=DestroyImageInfo(read_info);\n  (void) RelinquishUniqueFileResource(filename);\n  return(image);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -115,7 +115,8 @@\n   if ((unique_file == -1) || (file == (FILE *) NULL))\n     ThrowImageException(FileOpenError,\"UnableToCreateTemporaryFile\");\n   while ((c=ReadBlobByte(image)) != EOF)\n-    (void) fputc(c,file);\n+    if (fputc(c,file) != c)\n+      break;\n   (void) fclose(file);\n   (void) CloseBlob(image);\n   image=DestroyImage(image);",
        "diff_line_info": {
            "deleted_lines": [
                "    (void) fputc(c,file);"
            ],
            "added_lines": [
                "    if (fputc(c,file) != c)",
                "      break;"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-16643",
        "func_name": "ImageMagick/ReadPWPImage",
        "description": "The functions ReadDCMImage in coders/dcm.c, ReadPWPImage in coders/pwp.c, ReadCALSImage in coders/cals.c, and ReadPICTImage in coders/pict.c in ImageMagick 7.0.8-4 do not check the return value of the fputc function, which allows remote attackers to cause a denial of service via a crafted image file.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/6b6bff054d569a77973f2140c0e86366e6168a6c",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/1199",
        "commit_text": "",
        "func_before": "static Image *ReadPWPImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    filename[MagickPathExtent];\n\n  FILE\n    *file;\n\n  Image\n    *image,\n    *next_image,\n    *pwp_image;\n\n  ImageInfo\n    *read_info;\n\n  int\n    c,\n    unique_file;\n\n  MagickBooleanType\n    status;\n\n  register Image\n    *p;\n\n  register ssize_t\n    i;\n\n  size_t\n    filesize,\n    length;\n\n  ssize_t\n    count;\n\n  unsigned char\n    magick[MagickPathExtent];\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImage(image);\n      return((Image *) NULL);\n    }\n  pwp_image=image;\n  memset(magick,0,sizeof(magick));\n  count=ReadBlob(pwp_image,5,magick);\n  if ((count != 5) || (LocaleNCompare((char *) magick,\"SFW95\",5) != 0))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  read_info=CloneImageInfo(image_info);\n  (void) SetImageInfoProgressMonitor(read_info,(MagickProgressMonitor) NULL,\n    (void *) NULL);\n  SetImageInfoBlob(read_info,(void *) NULL,0);\n  unique_file=AcquireUniqueFileResource(filename);\n  (void) FormatLocaleString(read_info->filename,MagickPathExtent,\"sfw:%s\",\n    filename);\n  for ( ; ; )\n  {\n    (void) memset(magick,0,sizeof(magick));\n    for (c=ReadBlobByte(pwp_image); c != EOF; c=ReadBlobByte(pwp_image))\n    {\n      for (i=0; i < 17; i++)\n        magick[i]=magick[i+1];\n      magick[17]=(unsigned char) c;\n      if (LocaleNCompare((char *) (magick+12),\"SFW94A\",6) == 0)\n        break;\n    }\n    if (c == EOF)\n      {\n        (void) RelinquishUniqueFileResource(filename);\n        read_info=DestroyImageInfo(read_info);\n        ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n      }\n    if (LocaleNCompare((char *) (magick+12),\"SFW94A\",6) != 0)\n      {\n        (void) RelinquishUniqueFileResource(filename);\n        read_info=DestroyImageInfo(read_info);\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n      }\n    /*\n      Dump SFW image to a temporary file.\n    */\n    file=(FILE *) NULL;\n    if (unique_file != -1)\n      file=fdopen(unique_file,\"wb\");\n    if ((unique_file == -1) || (file == (FILE *) NULL))\n      {\n        (void) RelinquishUniqueFileResource(filename);\n        read_info=DestroyImageInfo(read_info);\n        ThrowFileException(exception,FileOpenError,\"UnableToWriteFile\",\n          image->filename);\n        image=DestroyImageList(image);\n        return((Image *) NULL);\n      }\n    length=fwrite(\"SFW94A\",1,6,file);\n    (void) length;\n    filesize=65535UL*magick[2]+256L*magick[1]+magick[0];\n    for (i=0; i < (ssize_t) filesize; i++)\n    {\n      c=ReadBlobByte(pwp_image);\n      if (c == EOF)\n        break;\n      (void) fputc(c,file);\n    }\n    (void) fclose(file);\n    if (c == EOF)\n      {\n        (void) RelinquishUniqueFileResource(filename);\n        read_info=DestroyImageInfo(read_info);\n        ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n      }\n    next_image=ReadImage(read_info,exception);\n    if (next_image == (Image *) NULL)\n      break;\n    (void) FormatLocaleString(next_image->filename,MagickPathExtent,\n      \"slide_%02ld.sfw\",(long) next_image->scene);\n    if (image == (Image *) NULL)\n      image=next_image;\n    else\n      {\n        /*\n          Link image into image list.\n        */\n        for (p=image; p->next != (Image *) NULL; p=GetNextImageInList(p)) ;\n        next_image->previous=p;\n        next_image->scene=p->scene+1;\n        p->next=next_image;\n      }\n    if (image_info->number_scenes != 0)\n      if (next_image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    status=SetImageProgress(image,LoadImagesTag,TellBlob(pwp_image),\n      GetBlobSize(pwp_image));\n    if (status == MagickFalse)\n      break;\n  }\n  if (unique_file != -1)\n    (void) close(unique_file);\n  (void) RelinquishUniqueFileResource(filename);\n  read_info=DestroyImageInfo(read_info);\n  if (image != (Image *) NULL)\n    {\n      if (EOFBlob(image) != MagickFalse)\n        {\n          char\n            *message;\n\n          message=GetExceptionMessage(errno);\n          (void) ThrowMagickException(exception,GetMagickModule(),\n            CorruptImageError,\"UnexpectedEndOfFile\",\"`%s': %s\",image->filename,\n            message);\n          message=DestroyString(message);\n        }\n      (void) CloseBlob(image);\n    }\n  return(GetFirstImageInList(image));\n}",
        "func": "static Image *ReadPWPImage(const ImageInfo *image_info,ExceptionInfo *exception)\n{\n  char\n    filename[MagickPathExtent];\n\n  FILE\n    *file;\n\n  Image\n    *image,\n    *next_image,\n    *pwp_image;\n\n  ImageInfo\n    *read_info;\n\n  int\n    c,\n    unique_file;\n\n  MagickBooleanType\n    status;\n\n  register Image\n    *p;\n\n  register ssize_t\n    i;\n\n  size_t\n    filesize,\n    length;\n\n  ssize_t\n    count;\n\n  unsigned char\n    magick[MagickPathExtent];\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImage(image);\n      return((Image *) NULL);\n    }\n  pwp_image=image;\n  memset(magick,0,sizeof(magick));\n  count=ReadBlob(pwp_image,5,magick);\n  if ((count != 5) || (LocaleNCompare((char *) magick,\"SFW95\",5) != 0))\n    ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n  read_info=CloneImageInfo(image_info);\n  (void) SetImageInfoProgressMonitor(read_info,(MagickProgressMonitor) NULL,\n    (void *) NULL);\n  SetImageInfoBlob(read_info,(void *) NULL,0);\n  unique_file=AcquireUniqueFileResource(filename);\n  (void) FormatLocaleString(read_info->filename,MagickPathExtent,\"sfw:%s\",\n    filename);\n  for ( ; ; )\n  {\n    (void) memset(magick,0,sizeof(magick));\n    for (c=ReadBlobByte(pwp_image); c != EOF; c=ReadBlobByte(pwp_image))\n    {\n      for (i=0; i < 17; i++)\n        magick[i]=magick[i+1];\n      magick[17]=(unsigned char) c;\n      if (LocaleNCompare((char *) (magick+12),\"SFW94A\",6) == 0)\n        break;\n    }\n    if (c == EOF)\n      {\n        (void) RelinquishUniqueFileResource(filename);\n        read_info=DestroyImageInfo(read_info);\n        ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n      }\n    if (LocaleNCompare((char *) (magick+12),\"SFW94A\",6) != 0)\n      {\n        (void) RelinquishUniqueFileResource(filename);\n        read_info=DestroyImageInfo(read_info);\n        ThrowReaderException(CorruptImageError,\"ImproperImageHeader\");\n      }\n    /*\n      Dump SFW image to a temporary file.\n    */\n    file=(FILE *) NULL;\n    if (unique_file != -1)\n      file=fdopen(unique_file,\"wb\");\n    if ((unique_file == -1) || (file == (FILE *) NULL))\n      {\n        (void) RelinquishUniqueFileResource(filename);\n        read_info=DestroyImageInfo(read_info);\n        ThrowFileException(exception,FileOpenError,\"UnableToWriteFile\",\n          image->filename);\n        image=DestroyImageList(image);\n        return((Image *) NULL);\n      }\n    length=fwrite(\"SFW94A\",1,6,file);\n    (void) length;\n    filesize=65535UL*magick[2]+256L*magick[1]+magick[0];\n    for (i=0; i < (ssize_t) filesize; i++)\n    {\n      c=ReadBlobByte(pwp_image);\n      if (c == EOF)\n        break;\n      if (fputc(c,file) != c)\n        break;\n    }\n    (void) fclose(file);\n    if (c == EOF)\n      {\n        (void) RelinquishUniqueFileResource(filename);\n        read_info=DestroyImageInfo(read_info);\n        ThrowReaderException(CorruptImageError,\"UnexpectedEndOfFile\");\n      }\n    next_image=ReadImage(read_info,exception);\n    if (next_image == (Image *) NULL)\n      break;\n    (void) FormatLocaleString(next_image->filename,MagickPathExtent,\n      \"slide_%02ld.sfw\",(long) next_image->scene);\n    if (image == (Image *) NULL)\n      image=next_image;\n    else\n      {\n        /*\n          Link image into image list.\n        */\n        for (p=image; p->next != (Image *) NULL; p=GetNextImageInList(p)) ;\n        next_image->previous=p;\n        next_image->scene=p->scene+1;\n        p->next=next_image;\n      }\n    if (image_info->number_scenes != 0)\n      if (next_image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    status=SetImageProgress(image,LoadImagesTag,TellBlob(pwp_image),\n      GetBlobSize(pwp_image));\n    if (status == MagickFalse)\n      break;\n  }\n  if (unique_file != -1)\n    (void) close(unique_file);\n  (void) RelinquishUniqueFileResource(filename);\n  read_info=DestroyImageInfo(read_info);\n  if (image != (Image *) NULL)\n    {\n      if (EOFBlob(image) != MagickFalse)\n        {\n          char\n            *message;\n\n          message=GetExceptionMessage(errno);\n          (void) ThrowMagickException(exception,GetMagickModule(),\n            CorruptImageError,\"UnexpectedEndOfFile\",\"`%s': %s\",image->filename,\n            message);\n          message=DestroyString(message);\n        }\n      (void) CloseBlob(image);\n    }\n  return(GetFirstImageInList(image));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -112,7 +112,8 @@\n       c=ReadBlobByte(pwp_image);\n       if (c == EOF)\n         break;\n-      (void) fputc(c,file);\n+      if (fputc(c,file) != c)\n+        break;\n     }\n     (void) fclose(file);\n     if (c == EOF)",
        "diff_line_info": {
            "deleted_lines": [
                "      (void) fputc(c,file);"
            ],
            "added_lines": [
                "      if (fputc(c,file) != c)",
                "        break;"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-16643",
        "func_name": "ImageMagick/ReadPICTImage",
        "description": "The functions ReadDCMImage in coders/dcm.c, ReadPWPImage in coders/pwp.c, ReadCALSImage in coders/cals.c, and ReadPICTImage in coders/pict.c in ImageMagick 7.0.8-4 do not check the return value of the fputc function, which allows remote attackers to cause a denial of service via a crafted image file.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/6b6bff054d569a77973f2140c0e86366e6168a6c",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/1199",
        "commit_text": "",
        "func_before": "static Image *ReadPICTImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n#define ThrowPICTException(exception,message) \\\n{ \\\n  if (tile_image != (Image *) NULL) \\\n    tile_image=DestroyImage(tile_image); \\\n  if (read_info != (ImageInfo *) NULL) \\\n    read_info=DestroyImageInfo(read_info); \\\n  ThrowReaderException((exception),(message)); \\\n}\n\n  char\n    geometry[MagickPathExtent],\n    header_ole[4];\n\n  Image\n    *image,\n    *tile_image;\n\n  ImageInfo\n    *read_info;\n\n  int\n    c,\n    code;\n\n  MagickBooleanType\n    jpeg,\n    status;\n\n  PICTRectangle\n    frame;\n\n  PICTPixmap\n    pixmap;\n\n  Quantum\n    index;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    i,\n    x;\n\n  size_t\n    extent,\n    length;\n\n  ssize_t\n    count,\n    flags,\n    j,\n    version,\n    y;\n\n  StringInfo\n    *profile;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read PICT header.\n  */\n  read_info=(ImageInfo *) NULL;\n  tile_image=(Image *) NULL;\n  pixmap.bits_per_pixel=0;\n  pixmap.component_count=0;\n  /*\n    Skip header : 512 for standard PICT and 4, ie \"PICT\" for OLE2.\n  */\n  header_ole[0]=ReadBlobByte(image);\n  header_ole[1]=ReadBlobByte(image);\n  header_ole[2]=ReadBlobByte(image);\n  header_ole[3]=ReadBlobByte(image);\n  if (!((header_ole[0] == 0x50) && (header_ole[1] == 0x49) &&\n      (header_ole[2] == 0x43) && (header_ole[3] == 0x54 )))\n    for (i=0; i < 508; i++)\n      if (ReadBlobByte(image) == EOF)\n        break;\n  (void) ReadBlobMSBShort(image);  /* skip picture size */\n  if (ReadRectangle(image,&frame) == MagickFalse)\n    ThrowPICTException(CorruptImageError,\"ImproperImageHeader\");\n  while ((c=ReadBlobByte(image)) == 0) ;\n  if (c != 0x11)\n    ThrowPICTException(CorruptImageError,\"ImproperImageHeader\");\n  version=(ssize_t) ReadBlobByte(image);\n  if (version == 2)\n    {\n      c=ReadBlobByte(image);\n      if (c != 0xff)\n        ThrowPICTException(CorruptImageError,\"ImproperImageHeader\");\n    }\n  else\n    if (version != 1)\n      ThrowPICTException(CorruptImageError,\"ImproperImageHeader\");\n  if ((frame.left < 0) || (frame.right < 0) || (frame.top < 0) ||\n      (frame.bottom < 0) || (frame.left >= frame.right) ||\n      (frame.top >= frame.bottom))\n    ThrowPICTException(CorruptImageError,\"ImproperImageHeader\");\n  /*\n    Create black canvas.\n  */\n  flags=0;\n  image->depth=8;\n  image->columns=(size_t) (frame.right-frame.left);\n  image->rows=(size_t) (frame.bottom-frame.top);\n  image->resolution.x=DefaultResolution;\n  image->resolution.y=DefaultResolution;\n  image->units=UndefinedResolution;\n  if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n    if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n      {\n        (void) CloseBlob(image);\n        return(GetFirstImageInList(image));\n      }\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status != MagickFalse)\n    status=ResetImagePixels(image,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  /*\n    Interpret PICT opcodes.\n  */\n  jpeg=MagickFalse;\n  for (code=0; EOFBlob(image) == MagickFalse; )\n  {\n    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    if ((version == 1) || ((TellBlob(image) % 2) != 0))\n      code=ReadBlobByte(image);\n    if (version == 2)\n      code=ReadBlobMSBSignedShort(image);\n    if (code < 0)\n      break;\n    if (code == 0)\n      continue;\n    if (code > 0xa1)\n      {\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"%04X:\",code);\n      }\n    else\n      {\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  %04X %s: %s\",code,codes[code].name,codes[code].description);\n        switch (code)\n        {\n          case 0x01:\n          {\n            /*\n              Clipping rectangle.\n            */\n            length=ReadBlobMSBShort(image);\n            if (length != 0x000a)\n              {\n                for (i=0; i < (ssize_t) (length-2); i++)\n                  if (ReadBlobByte(image) == EOF)\n                    break;\n                break;\n              }\n            if (ReadRectangle(image,&frame) == MagickFalse)\n              ThrowPICTException(CorruptImageError,\"ImproperImageHeader\");\n            if (((frame.left & 0x8000) != 0) || ((frame.top & 0x8000) != 0))\n              break;\n            image->columns=(size_t) (frame.right-frame.left);\n            image->rows=(size_t) (frame.bottom-frame.top);\n            status=SetImageExtent(image,image->columns,image->rows,exception);\n            if (status != MagickFalse)\n              status=ResetImagePixels(image,exception);\n            if (status == MagickFalse)\n              return(DestroyImageList(image));\n            break;\n          }\n          case 0x12:\n          case 0x13:\n          case 0x14:\n          {\n            ssize_t\n              pattern;\n\n            size_t\n              height,\n              width;\n\n            /*\n              Skip pattern definition.\n            */\n            pattern=(ssize_t) ReadBlobMSBShort(image);\n            for (i=0; i < 8; i++)\n              if (ReadBlobByte(image) == EOF)\n                break;\n            if (pattern == 2)\n              {\n                for (i=0; i < 5; i++)\n                  if (ReadBlobByte(image) == EOF)\n                    break;\n                break;\n              }\n            if (pattern != 1)\n              ThrowPICTException(CorruptImageError,\"UnknownPatternType\");\n            length=ReadBlobMSBShort(image);\n            if (ReadRectangle(image,&frame) == MagickFalse)\n              ThrowPICTException(CorruptImageError,\"ImproperImageHeader\");\n            if (ReadPixmap(image,&pixmap) == MagickFalse)\n              ThrowPICTException(CorruptImageError,\"ImproperImageHeader\");\n            image->depth=(size_t) pixmap.component_size;\n            image->resolution.x=1.0*pixmap.horizontal_resolution;\n            image->resolution.y=1.0*pixmap.vertical_resolution;\n            image->units=PixelsPerInchResolution;\n            (void) ReadBlobMSBLong(image);\n            flags=(ssize_t) ReadBlobMSBShort(image);\n            length=ReadBlobMSBShort(image);\n            for (i=0; i <= (ssize_t) length; i++)\n              (void) ReadBlobMSBLong(image);\n            width=(size_t) (frame.bottom-frame.top);\n            height=(size_t) (frame.right-frame.left);\n            if (pixmap.bits_per_pixel <= 8)\n              length&=0x7fff;\n            if (pixmap.bits_per_pixel == 16)\n              width<<=1;\n            if (length == 0)\n              length=width;\n            if (length < 8)\n              {\n                for (i=0; i < (ssize_t) (length*height); i++)\n                  if (ReadBlobByte(image) == EOF)\n                    break;\n              }\n            else\n              for (i=0; i < (ssize_t) height; i++)\n              {\n                if (EOFBlob(image) != MagickFalse)\n                  break;\n                if (length > 200)\n                  {\n                    for (j=0; j < (ssize_t) ReadBlobMSBShort(image); j++)\n                      if (ReadBlobByte(image) == EOF)\n                        break;\n                  }\n                else\n                  for (j=0; j < (ssize_t) ReadBlobByte(image); j++)\n                    if (ReadBlobByte(image) == EOF)\n                      break;\n              }\n            break;\n          }\n          case 0x1b:\n          {\n            /*\n              Initialize image background color.\n            */\n            image->background_color.red=(Quantum)\n              ScaleShortToQuantum(ReadBlobMSBShort(image));\n            image->background_color.green=(Quantum)\n              ScaleShortToQuantum(ReadBlobMSBShort(image));\n            image->background_color.blue=(Quantum)\n              ScaleShortToQuantum(ReadBlobMSBShort(image));\n            break;\n          }\n          case 0x70:\n          case 0x71:\n          case 0x72:\n          case 0x73:\n          case 0x74:\n          case 0x75:\n          case 0x76:\n          case 0x77:\n          {\n            /*\n              Skip polygon or region.\n            */\n            length=ReadBlobMSBShort(image);\n            for (i=0; i < (ssize_t) (length-2); i++)\n              if (ReadBlobByte(image) == EOF)\n                break;\n            break;\n          }\n          case 0x90:\n          case 0x91:\n          case 0x98:\n          case 0x99:\n          case 0x9a:\n          case 0x9b:\n          {\n            PICTRectangle\n              source,\n              destination;\n\n            register unsigned char\n              *p;\n\n            size_t\n              j;\n\n            ssize_t\n              bytes_per_line;\n\n            unsigned char\n              *pixels;\n\n            /*\n              Pixmap clipped by a rectangle.\n            */\n            bytes_per_line=0;\n            if ((code != 0x9a) && (code != 0x9b))\n              bytes_per_line=(ssize_t) ReadBlobMSBShort(image);\n            else\n              {\n                (void) ReadBlobMSBShort(image);\n                (void) ReadBlobMSBShort(image);\n                (void) ReadBlobMSBShort(image);\n              }\n            if (ReadRectangle(image,&frame) == MagickFalse)\n              ThrowPICTException(CorruptImageError,\"ImproperImageHeader\");\n            /*\n              Initialize tile image.\n            */\n            tile_image=CloneImage(image,(size_t) (frame.right-frame.left),\n              (size_t) (frame.bottom-frame.top),MagickTrue,exception);\n            if (tile_image == (Image *) NULL)\n              ThrowPICTException(CorruptImageError,\"ImproperImageHeader\");\n            if ((code == 0x9a) || (code == 0x9b) ||\n                ((bytes_per_line & 0x8000) != 0))\n              {\n                if (ReadPixmap(image,&pixmap) == MagickFalse)\n                  ThrowPICTException(CorruptImageError,\"ImproperImageHeader\");\n                tile_image->depth=(size_t) pixmap.component_size;\n                tile_image->alpha_trait=pixmap.component_count == 4 ?\n                  BlendPixelTrait : UndefinedPixelTrait;\n                tile_image->resolution.x=(double) pixmap.horizontal_resolution;\n                tile_image->resolution.y=(double) pixmap.vertical_resolution;\n                tile_image->units=PixelsPerInchResolution;\n                if (tile_image->alpha_trait != UndefinedPixelTrait)\n                  (void) SetImageAlpha(tile_image,OpaqueAlpha,exception);\n              }\n            if ((code != 0x9a) && (code != 0x9b))\n              {\n                /*\n                  Initialize colormap.\n                */\n                tile_image->colors=2;\n                if ((bytes_per_line & 0x8000) != 0)\n                  {\n                    (void) ReadBlobMSBLong(image);\n                    flags=(ssize_t) ReadBlobMSBShort(image);\n                    tile_image->colors=1UL*ReadBlobMSBShort(image)+1;\n                  }\n                status=AcquireImageColormap(tile_image,tile_image->colors,\n                  exception);\n                if (status == MagickFalse)\n                  ThrowPICTException(ResourceLimitError,\n                    \"MemoryAllocationFailed\");\n                if ((bytes_per_line & 0x8000) != 0)\n                  {\n                    for (i=0; i < (ssize_t) tile_image->colors; i++)\n                    {\n                      j=ReadBlobMSBShort(image) % tile_image->colors;\n                      if ((flags & 0x8000) != 0)\n                        j=(size_t) i;\n                      tile_image->colormap[j].red=(Quantum)\n                        ScaleShortToQuantum(ReadBlobMSBShort(image));\n                      tile_image->colormap[j].green=(Quantum)\n                        ScaleShortToQuantum(ReadBlobMSBShort(image));\n                      tile_image->colormap[j].blue=(Quantum)\n                        ScaleShortToQuantum(ReadBlobMSBShort(image));\n                    }\n                  }\n                else\n                  {\n                    for (i=0; i < (ssize_t) tile_image->colors; i++)\n                    {\n                      tile_image->colormap[i].red=(Quantum) (QuantumRange-\n                        tile_image->colormap[i].red);\n                      tile_image->colormap[i].green=(Quantum) (QuantumRange-\n                        tile_image->colormap[i].green);\n                      tile_image->colormap[i].blue=(Quantum) (QuantumRange-\n                        tile_image->colormap[i].blue);\n                    }\n                  }\n              }\n            if (EOFBlob(image) != MagickFalse)\n              ThrowPICTException(CorruptImageError,\n                \"InsufficientImageDataInFile\");\n            if (ReadRectangle(image,&source) == MagickFalse)\n              ThrowPICTException(CorruptImageError,\"ImproperImageHeader\");\n            if (ReadRectangle(image,&destination) == MagickFalse)\n              ThrowPICTException(CorruptImageError,\"ImproperImageHeader\");\n            (void) ReadBlobMSBShort(image);\n            if ((code == 0x91) || (code == 0x99) || (code == 0x9b))\n              {\n                /*\n                  Skip region.\n                */\n                length=ReadBlobMSBShort(image);\n                for (i=0; i < (ssize_t) (length-2); i++)\n                  if (ReadBlobByte(image) == EOF)\n                    break;\n              }\n            if ((code != 0x9a) && (code != 0x9b) &&\n                (bytes_per_line & 0x8000) == 0)\n              pixels=DecodeImage(image,tile_image,(size_t) bytes_per_line,1,\n                &extent);\n            else\n              pixels=DecodeImage(image,tile_image,(size_t) bytes_per_line,\n                (unsigned int) pixmap.bits_per_pixel,&extent);\n            if (pixels == (unsigned char *) NULL)\n              ThrowPICTException(CorruptImageError,\"UnableToUncompressImage\");\n            /*\n              Convert PICT tile image to pixel packets.\n            */\n            p=pixels;\n            for (y=0; y < (ssize_t) tile_image->rows; y++)\n            {\n              if (p > (pixels+extent+image->columns))\n                {\n                  pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n                  ThrowPICTException(CorruptImageError,\"NotEnoughPixelData\");\n                }\n              q=QueueAuthenticPixels(tile_image,0,y,tile_image->columns,1,\n                exception);\n              if (q == (Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) tile_image->columns; x++)\n              {\n                if (tile_image->storage_class == PseudoClass)\n                  {\n                    index=(Quantum) ConstrainColormapIndex(tile_image,(ssize_t)\n                      *p,exception);\n                    SetPixelIndex(tile_image,index,q);\n                    SetPixelRed(tile_image,\n                      tile_image->colormap[(ssize_t) index].red,q);\n                    SetPixelGreen(tile_image,\n                      tile_image->colormap[(ssize_t) index].green,q);\n                    SetPixelBlue(tile_image,\n                      tile_image->colormap[(ssize_t) index].blue,q);\n                  }\n                else\n                  {\n                    if (pixmap.bits_per_pixel == 16)\n                      {\n                        i=(ssize_t) (*p++);\n                        j=(size_t) (*p);\n                        SetPixelRed(tile_image,ScaleCharToQuantum(\n                          (unsigned char) ((i & 0x7c) << 1)),q);\n                        SetPixelGreen(tile_image,ScaleCharToQuantum(\n                          (unsigned char) (((i & 0x03) << 6) |\n                          ((j & 0xe0) >> 2))),q);\n                        SetPixelBlue(tile_image,ScaleCharToQuantum(\n                          (unsigned char) ((j & 0x1f) << 3)),q);\n                      }\n                    else\n                      if (tile_image->alpha_trait == UndefinedPixelTrait)\n                        {\n                          if (p > (pixels+extent+2*image->columns))\n                            ThrowPICTException(CorruptImageError,\n                              \"NotEnoughPixelData\");\n                          SetPixelRed(tile_image,ScaleCharToQuantum(*p),q);\n                          SetPixelGreen(tile_image,ScaleCharToQuantum(\n                            *(p+tile_image->columns)),q);\n                          SetPixelBlue(tile_image,ScaleCharToQuantum(\n                            *(p+2*tile_image->columns)),q);\n                        }\n                      else\n                        {\n                          if (p > (pixels+extent+3*image->columns))\n                            ThrowPICTException(CorruptImageError,\n                              \"NotEnoughPixelData\");\n                          SetPixelAlpha(tile_image,ScaleCharToQuantum(*p),q);\n                          SetPixelRed(tile_image,ScaleCharToQuantum(\n                            *(p+tile_image->columns)),q);\n                          SetPixelGreen(tile_image,ScaleCharToQuantum(\n                            *(p+2*tile_image->columns)),q);\n                          SetPixelBlue(tile_image,ScaleCharToQuantum(\n                            *(p+3*tile_image->columns)),q);\n                        }\n                  }\n                p++;\n                q+=GetPixelChannels(tile_image);\n              }\n              if (SyncAuthenticPixels(tile_image,exception) == MagickFalse)\n                break;\n              if ((tile_image->storage_class == DirectClass) &&\n                  (pixmap.bits_per_pixel != 16))\n                {\n                  p+=(pixmap.component_count-1)*tile_image->columns;\n                  if (p < pixels)\n                    break;\n                }\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                tile_image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n            pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n            if ((jpeg == MagickFalse) && (EOFBlob(image) == MagickFalse))\n              if ((code == 0x9a) || (code == 0x9b) ||\n                  ((bytes_per_line & 0x8000) != 0))\n                (void) CompositeImage(image,tile_image,CopyCompositeOp,\n                  MagickTrue,(ssize_t) destination.left,(ssize_t)\n                  destination.top,exception);\n            tile_image=DestroyImage(tile_image);\n            break;\n          }\n          case 0xa1:\n          {\n            unsigned char\n              *info;\n\n            size_t\n              type;\n\n            /*\n              Comment.\n            */\n            type=ReadBlobMSBShort(image);\n            length=ReadBlobMSBShort(image);\n            if (length == 0)\n              break;\n            (void) ReadBlobMSBLong(image);\n            length-=MagickMin(length,4);\n            if (length == 0)\n              break;\n            info=(unsigned char *) AcquireQuantumMemory(length,sizeof(*info));\n            if (info == (unsigned char *) NULL)\n              break;\n            count=ReadBlob(image,length,info);\n            if (count != (ssize_t) length)\n              {\n                info=(unsigned char *) RelinquishMagickMemory(info);\n                ThrowPICTException(ResourceLimitError,\"UnableToReadImageData\");\n              }\n            switch (type)\n            {\n              case 0xe0:\n              {\n                profile=BlobToStringInfo((const void *) NULL,length);\n                SetStringInfoDatum(profile,info);\n                status=SetImageProfile(image,\"icc\",profile,exception);\n                profile=DestroyStringInfo(profile);\n                if (status == MagickFalse)\n                  {\n                    info=(unsigned char *) RelinquishMagickMemory(info);\n                    ThrowPICTException(ResourceLimitError,\n                      \"MemoryAllocationFailed\");\n                  }\n                break;\n              }\n              case 0x1f2:\n              {\n                profile=BlobToStringInfo((const void *) NULL,length);\n                SetStringInfoDatum(profile,info);\n                status=SetImageProfile(image,\"iptc\",profile,exception);\n                if (status == MagickFalse)\n                  {\n                    info=(unsigned char *) RelinquishMagickMemory(info);\n                    ThrowPICTException(ResourceLimitError,\n                      \"MemoryAllocationFailed\");\n                  }\n                profile=DestroyStringInfo(profile);\n                break;\n              }\n              default:\n                break;\n            }\n            info=(unsigned char *) RelinquishMagickMemory(info);\n            break;\n          }\n          default:\n          {\n            /*\n              Skip to next op code.\n            */\n            if (codes[code].length == -1)\n              (void) ReadBlobMSBShort(image);\n            else\n              for (i=0; i < (ssize_t) codes[code].length; i++)\n                if (ReadBlobByte(image) == EOF)\n                  break;\n          }\n        }\n      }\n    if (code == 0xc00)\n      {\n        /*\n          Skip header.\n        */\n        for (i=0; i < 24; i++)\n          if (ReadBlobByte(image) == EOF)\n            break;\n        continue;\n      }\n    if (((code >= 0xb0) && (code <= 0xcf)) ||\n        ((code >= 0x8000) && (code <= 0x80ff)))\n      continue;\n    if (code == 0x8200)\n      {\n        char\n          filename[MaxTextExtent];\n\n        FILE\n          *file;\n\n        int\n          unique_file;\n\n        /*\n          Embedded JPEG.\n        */\n        jpeg=MagickTrue;\n        read_info=CloneImageInfo(image_info);\n        SetImageInfoBlob(read_info,(void *) NULL,0);\n        file=(FILE *) NULL;\n        unique_file=AcquireUniqueFileResource(filename);\n        (void) FormatLocaleString(read_info->filename,MaxTextExtent,\"jpeg:%s\",\n          filename);\n        if (unique_file != -1)\n          file=fdopen(unique_file,\"wb\");\n        if ((unique_file == -1) || (file == (FILE *) NULL))\n          {\n            (void) RelinquishUniqueFileResource(read_info->filename);\n            (void) CopyMagickString(image->filename,read_info->filename,\n              MagickPathExtent);\n            ThrowPICTException(FileOpenError,\"UnableToCreateTemporaryFile\");\n          }\n        length=ReadBlobMSBLong(image);\n        if (length > 154)\n          {\n            for (i=0; i < 6; i++)\n              (void) ReadBlobMSBLong(image);\n            if (ReadRectangle(image,&frame) == MagickFalse)\n              {\n                (void) fclose(file);\n                (void) RelinquishUniqueFileResource(read_info->filename);\n                ThrowPICTException(CorruptImageError,\"ImproperImageHeader\");\n              }\n            for (i=0; i < 122; i++)\n              if (ReadBlobByte(image) == EOF)\n                break;\n            for (i=0; i < (ssize_t) (length-154); i++)\n            {\n              c=ReadBlobByte(image);\n              if (c == EOF)\n                break;\n              (void) fputc(c,file);\n            }\n          }\n        (void) fclose(file);\n        (void) close(unique_file);\n        tile_image=ReadImage(read_info,exception);\n        (void) RelinquishUniqueFileResource(filename);\n        read_info=DestroyImageInfo(read_info);\n        if (tile_image == (Image *) NULL)\n          continue;\n        (void) FormatLocaleString(geometry,MagickPathExtent,\"%.20gx%.20g\",\n          (double) MagickMax(image->columns,tile_image->columns),\n          (double) MagickMax(image->rows,tile_image->rows));\n        (void) SetImageExtent(image,\n          MagickMax(image->columns,tile_image->columns),\n          MagickMax(image->rows,tile_image->rows),exception);\n        (void) TransformImageColorspace(image,tile_image->colorspace,exception);\n        (void) CompositeImage(image,tile_image,CopyCompositeOp,MagickTrue,\n          (ssize_t) frame.left,(ssize_t) frame.right,exception);\n        image->compression=tile_image->compression;\n        tile_image=DestroyImage(tile_image);\n        continue;\n      }\n    if ((code == 0xff) || (code == 0xffff))\n      break;\n    if (((code >= 0xd0) && (code <= 0xfe)) ||\n        ((code >= 0x8100) && (code <= 0xffff)))\n      {\n        /*\n          Skip reserved.\n        */\n        length=ReadBlobMSBShort(image);\n        for (i=0; i < (ssize_t) length; i++)\n          if (ReadBlobByte(image) == EOF)\n            break;\n        continue;\n      }\n    if ((code >= 0x100) && (code <= 0x7fff))\n      {\n        /*\n          Skip reserved.\n        */\n        length=(size_t) ((code >> 7) & 0xff);\n        for (i=0; i < (ssize_t) length; i++)\n          if (ReadBlobByte(image) == EOF)\n            break;\n        continue;\n      }\n  }\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
        "func": "static Image *ReadPICTImage(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n#define ThrowPICTException(exception,message) \\\n{ \\\n  if (tile_image != (Image *) NULL) \\\n    tile_image=DestroyImage(tile_image); \\\n  if (read_info != (ImageInfo *) NULL) \\\n    read_info=DestroyImageInfo(read_info); \\\n  ThrowReaderException((exception),(message)); \\\n}\n\n  char\n    geometry[MagickPathExtent],\n    header_ole[4];\n\n  Image\n    *image,\n    *tile_image;\n\n  ImageInfo\n    *read_info;\n\n  int\n    c,\n    code;\n\n  MagickBooleanType\n    jpeg,\n    status;\n\n  PICTRectangle\n    frame;\n\n  PICTPixmap\n    pixmap;\n\n  Quantum\n    index;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    i,\n    x;\n\n  size_t\n    extent,\n    length;\n\n  ssize_t\n    count,\n    flags,\n    j,\n    version,\n    y;\n\n  StringInfo\n    *profile;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Read PICT header.\n  */\n  read_info=(ImageInfo *) NULL;\n  tile_image=(Image *) NULL;\n  pixmap.bits_per_pixel=0;\n  pixmap.component_count=0;\n  /*\n    Skip header : 512 for standard PICT and 4, ie \"PICT\" for OLE2.\n  */\n  header_ole[0]=ReadBlobByte(image);\n  header_ole[1]=ReadBlobByte(image);\n  header_ole[2]=ReadBlobByte(image);\n  header_ole[3]=ReadBlobByte(image);\n  if (!((header_ole[0] == 0x50) && (header_ole[1] == 0x49) &&\n      (header_ole[2] == 0x43) && (header_ole[3] == 0x54 )))\n    for (i=0; i < 508; i++)\n      if (ReadBlobByte(image) == EOF)\n        break;\n  (void) ReadBlobMSBShort(image);  /* skip picture size */\n  if (ReadRectangle(image,&frame) == MagickFalse)\n    ThrowPICTException(CorruptImageError,\"ImproperImageHeader\");\n  while ((c=ReadBlobByte(image)) == 0) ;\n  if (c != 0x11)\n    ThrowPICTException(CorruptImageError,\"ImproperImageHeader\");\n  version=(ssize_t) ReadBlobByte(image);\n  if (version == 2)\n    {\n      c=ReadBlobByte(image);\n      if (c != 0xff)\n        ThrowPICTException(CorruptImageError,\"ImproperImageHeader\");\n    }\n  else\n    if (version != 1)\n      ThrowPICTException(CorruptImageError,\"ImproperImageHeader\");\n  if ((frame.left < 0) || (frame.right < 0) || (frame.top < 0) ||\n      (frame.bottom < 0) || (frame.left >= frame.right) ||\n      (frame.top >= frame.bottom))\n    ThrowPICTException(CorruptImageError,\"ImproperImageHeader\");\n  /*\n    Create black canvas.\n  */\n  flags=0;\n  image->depth=8;\n  image->columns=(size_t) (frame.right-frame.left);\n  image->rows=(size_t) (frame.bottom-frame.top);\n  image->resolution.x=DefaultResolution;\n  image->resolution.y=DefaultResolution;\n  image->units=UndefinedResolution;\n  if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n    if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n      {\n        (void) CloseBlob(image);\n        return(GetFirstImageInList(image));\n      }\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status != MagickFalse)\n    status=ResetImagePixels(image,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  /*\n    Interpret PICT opcodes.\n  */\n  jpeg=MagickFalse;\n  for (code=0; EOFBlob(image) == MagickFalse; )\n  {\n    if ((image_info->ping != MagickFalse) && (image_info->number_scenes != 0))\n      if (image->scene >= (image_info->scene+image_info->number_scenes-1))\n        break;\n    if ((version == 1) || ((TellBlob(image) % 2) != 0))\n      code=ReadBlobByte(image);\n    if (version == 2)\n      code=ReadBlobMSBSignedShort(image);\n    if (code < 0)\n      break;\n    if (code == 0)\n      continue;\n    if (code > 0xa1)\n      {\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\"%04X:\",code);\n      }\n    else\n      {\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  %04X %s: %s\",code,codes[code].name,codes[code].description);\n        switch (code)\n        {\n          case 0x01:\n          {\n            /*\n              Clipping rectangle.\n            */\n            length=ReadBlobMSBShort(image);\n            if (length != 0x000a)\n              {\n                for (i=0; i < (ssize_t) (length-2); i++)\n                  if (ReadBlobByte(image) == EOF)\n                    break;\n                break;\n              }\n            if (ReadRectangle(image,&frame) == MagickFalse)\n              ThrowPICTException(CorruptImageError,\"ImproperImageHeader\");\n            if (((frame.left & 0x8000) != 0) || ((frame.top & 0x8000) != 0))\n              break;\n            image->columns=(size_t) (frame.right-frame.left);\n            image->rows=(size_t) (frame.bottom-frame.top);\n            status=SetImageExtent(image,image->columns,image->rows,exception);\n            if (status != MagickFalse)\n              status=ResetImagePixels(image,exception);\n            if (status == MagickFalse)\n              return(DestroyImageList(image));\n            break;\n          }\n          case 0x12:\n          case 0x13:\n          case 0x14:\n          {\n            ssize_t\n              pattern;\n\n            size_t\n              height,\n              width;\n\n            /*\n              Skip pattern definition.\n            */\n            pattern=(ssize_t) ReadBlobMSBShort(image);\n            for (i=0; i < 8; i++)\n              if (ReadBlobByte(image) == EOF)\n                break;\n            if (pattern == 2)\n              {\n                for (i=0; i < 5; i++)\n                  if (ReadBlobByte(image) == EOF)\n                    break;\n                break;\n              }\n            if (pattern != 1)\n              ThrowPICTException(CorruptImageError,\"UnknownPatternType\");\n            length=ReadBlobMSBShort(image);\n            if (ReadRectangle(image,&frame) == MagickFalse)\n              ThrowPICTException(CorruptImageError,\"ImproperImageHeader\");\n            if (ReadPixmap(image,&pixmap) == MagickFalse)\n              ThrowPICTException(CorruptImageError,\"ImproperImageHeader\");\n            image->depth=(size_t) pixmap.component_size;\n            image->resolution.x=1.0*pixmap.horizontal_resolution;\n            image->resolution.y=1.0*pixmap.vertical_resolution;\n            image->units=PixelsPerInchResolution;\n            (void) ReadBlobMSBLong(image);\n            flags=(ssize_t) ReadBlobMSBShort(image);\n            length=ReadBlobMSBShort(image);\n            for (i=0; i <= (ssize_t) length; i++)\n              (void) ReadBlobMSBLong(image);\n            width=(size_t) (frame.bottom-frame.top);\n            height=(size_t) (frame.right-frame.left);\n            if (pixmap.bits_per_pixel <= 8)\n              length&=0x7fff;\n            if (pixmap.bits_per_pixel == 16)\n              width<<=1;\n            if (length == 0)\n              length=width;\n            if (length < 8)\n              {\n                for (i=0; i < (ssize_t) (length*height); i++)\n                  if (ReadBlobByte(image) == EOF)\n                    break;\n              }\n            else\n              for (i=0; i < (ssize_t) height; i++)\n              {\n                if (EOFBlob(image) != MagickFalse)\n                  break;\n                if (length > 200)\n                  {\n                    for (j=0; j < (ssize_t) ReadBlobMSBShort(image); j++)\n                      if (ReadBlobByte(image) == EOF)\n                        break;\n                  }\n                else\n                  for (j=0; j < (ssize_t) ReadBlobByte(image); j++)\n                    if (ReadBlobByte(image) == EOF)\n                      break;\n              }\n            break;\n          }\n          case 0x1b:\n          {\n            /*\n              Initialize image background color.\n            */\n            image->background_color.red=(Quantum)\n              ScaleShortToQuantum(ReadBlobMSBShort(image));\n            image->background_color.green=(Quantum)\n              ScaleShortToQuantum(ReadBlobMSBShort(image));\n            image->background_color.blue=(Quantum)\n              ScaleShortToQuantum(ReadBlobMSBShort(image));\n            break;\n          }\n          case 0x70:\n          case 0x71:\n          case 0x72:\n          case 0x73:\n          case 0x74:\n          case 0x75:\n          case 0x76:\n          case 0x77:\n          {\n            /*\n              Skip polygon or region.\n            */\n            length=ReadBlobMSBShort(image);\n            for (i=0; i < (ssize_t) (length-2); i++)\n              if (ReadBlobByte(image) == EOF)\n                break;\n            break;\n          }\n          case 0x90:\n          case 0x91:\n          case 0x98:\n          case 0x99:\n          case 0x9a:\n          case 0x9b:\n          {\n            PICTRectangle\n              source,\n              destination;\n\n            register unsigned char\n              *p;\n\n            size_t\n              j;\n\n            ssize_t\n              bytes_per_line;\n\n            unsigned char\n              *pixels;\n\n            /*\n              Pixmap clipped by a rectangle.\n            */\n            bytes_per_line=0;\n            if ((code != 0x9a) && (code != 0x9b))\n              bytes_per_line=(ssize_t) ReadBlobMSBShort(image);\n            else\n              {\n                (void) ReadBlobMSBShort(image);\n                (void) ReadBlobMSBShort(image);\n                (void) ReadBlobMSBShort(image);\n              }\n            if (ReadRectangle(image,&frame) == MagickFalse)\n              ThrowPICTException(CorruptImageError,\"ImproperImageHeader\");\n            /*\n              Initialize tile image.\n            */\n            tile_image=CloneImage(image,(size_t) (frame.right-frame.left),\n              (size_t) (frame.bottom-frame.top),MagickTrue,exception);\n            if (tile_image == (Image *) NULL)\n              ThrowPICTException(CorruptImageError,\"ImproperImageHeader\");\n            if ((code == 0x9a) || (code == 0x9b) ||\n                ((bytes_per_line & 0x8000) != 0))\n              {\n                if (ReadPixmap(image,&pixmap) == MagickFalse)\n                  ThrowPICTException(CorruptImageError,\"ImproperImageHeader\");\n                tile_image->depth=(size_t) pixmap.component_size;\n                tile_image->alpha_trait=pixmap.component_count == 4 ?\n                  BlendPixelTrait : UndefinedPixelTrait;\n                tile_image->resolution.x=(double) pixmap.horizontal_resolution;\n                tile_image->resolution.y=(double) pixmap.vertical_resolution;\n                tile_image->units=PixelsPerInchResolution;\n                if (tile_image->alpha_trait != UndefinedPixelTrait)\n                  (void) SetImageAlpha(tile_image,OpaqueAlpha,exception);\n              }\n            if ((code != 0x9a) && (code != 0x9b))\n              {\n                /*\n                  Initialize colormap.\n                */\n                tile_image->colors=2;\n                if ((bytes_per_line & 0x8000) != 0)\n                  {\n                    (void) ReadBlobMSBLong(image);\n                    flags=(ssize_t) ReadBlobMSBShort(image);\n                    tile_image->colors=1UL*ReadBlobMSBShort(image)+1;\n                  }\n                status=AcquireImageColormap(tile_image,tile_image->colors,\n                  exception);\n                if (status == MagickFalse)\n                  ThrowPICTException(ResourceLimitError,\n                    \"MemoryAllocationFailed\");\n                if ((bytes_per_line & 0x8000) != 0)\n                  {\n                    for (i=0; i < (ssize_t) tile_image->colors; i++)\n                    {\n                      j=ReadBlobMSBShort(image) % tile_image->colors;\n                      if ((flags & 0x8000) != 0)\n                        j=(size_t) i;\n                      tile_image->colormap[j].red=(Quantum)\n                        ScaleShortToQuantum(ReadBlobMSBShort(image));\n                      tile_image->colormap[j].green=(Quantum)\n                        ScaleShortToQuantum(ReadBlobMSBShort(image));\n                      tile_image->colormap[j].blue=(Quantum)\n                        ScaleShortToQuantum(ReadBlobMSBShort(image));\n                    }\n                  }\n                else\n                  {\n                    for (i=0; i < (ssize_t) tile_image->colors; i++)\n                    {\n                      tile_image->colormap[i].red=(Quantum) (QuantumRange-\n                        tile_image->colormap[i].red);\n                      tile_image->colormap[i].green=(Quantum) (QuantumRange-\n                        tile_image->colormap[i].green);\n                      tile_image->colormap[i].blue=(Quantum) (QuantumRange-\n                        tile_image->colormap[i].blue);\n                    }\n                  }\n              }\n            if (EOFBlob(image) != MagickFalse)\n              ThrowPICTException(CorruptImageError,\n                \"InsufficientImageDataInFile\");\n            if (ReadRectangle(image,&source) == MagickFalse)\n              ThrowPICTException(CorruptImageError,\"ImproperImageHeader\");\n            if (ReadRectangle(image,&destination) == MagickFalse)\n              ThrowPICTException(CorruptImageError,\"ImproperImageHeader\");\n            (void) ReadBlobMSBShort(image);\n            if ((code == 0x91) || (code == 0x99) || (code == 0x9b))\n              {\n                /*\n                  Skip region.\n                */\n                length=ReadBlobMSBShort(image);\n                for (i=0; i < (ssize_t) (length-2); i++)\n                  if (ReadBlobByte(image) == EOF)\n                    break;\n              }\n            if ((code != 0x9a) && (code != 0x9b) &&\n                (bytes_per_line & 0x8000) == 0)\n              pixels=DecodeImage(image,tile_image,(size_t) bytes_per_line,1,\n                &extent);\n            else\n              pixels=DecodeImage(image,tile_image,(size_t) bytes_per_line,\n                (unsigned int) pixmap.bits_per_pixel,&extent);\n            if (pixels == (unsigned char *) NULL)\n              ThrowPICTException(CorruptImageError,\"UnableToUncompressImage\");\n            /*\n              Convert PICT tile image to pixel packets.\n            */\n            p=pixels;\n            for (y=0; y < (ssize_t) tile_image->rows; y++)\n            {\n              if (p > (pixels+extent+image->columns))\n                {\n                  pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n                  ThrowPICTException(CorruptImageError,\"NotEnoughPixelData\");\n                }\n              q=QueueAuthenticPixels(tile_image,0,y,tile_image->columns,1,\n                exception);\n              if (q == (Quantum *) NULL)\n                break;\n              for (x=0; x < (ssize_t) tile_image->columns; x++)\n              {\n                if (tile_image->storage_class == PseudoClass)\n                  {\n                    index=(Quantum) ConstrainColormapIndex(tile_image,(ssize_t)\n                      *p,exception);\n                    SetPixelIndex(tile_image,index,q);\n                    SetPixelRed(tile_image,\n                      tile_image->colormap[(ssize_t) index].red,q);\n                    SetPixelGreen(tile_image,\n                      tile_image->colormap[(ssize_t) index].green,q);\n                    SetPixelBlue(tile_image,\n                      tile_image->colormap[(ssize_t) index].blue,q);\n                  }\n                else\n                  {\n                    if (pixmap.bits_per_pixel == 16)\n                      {\n                        i=(ssize_t) (*p++);\n                        j=(size_t) (*p);\n                        SetPixelRed(tile_image,ScaleCharToQuantum(\n                          (unsigned char) ((i & 0x7c) << 1)),q);\n                        SetPixelGreen(tile_image,ScaleCharToQuantum(\n                          (unsigned char) (((i & 0x03) << 6) |\n                          ((j & 0xe0) >> 2))),q);\n                        SetPixelBlue(tile_image,ScaleCharToQuantum(\n                          (unsigned char) ((j & 0x1f) << 3)),q);\n                      }\n                    else\n                      if (tile_image->alpha_trait == UndefinedPixelTrait)\n                        {\n                          if (p > (pixels+extent+2*image->columns))\n                            ThrowPICTException(CorruptImageError,\n                              \"NotEnoughPixelData\");\n                          SetPixelRed(tile_image,ScaleCharToQuantum(*p),q);\n                          SetPixelGreen(tile_image,ScaleCharToQuantum(\n                            *(p+tile_image->columns)),q);\n                          SetPixelBlue(tile_image,ScaleCharToQuantum(\n                            *(p+2*tile_image->columns)),q);\n                        }\n                      else\n                        {\n                          if (p > (pixels+extent+3*image->columns))\n                            ThrowPICTException(CorruptImageError,\n                              \"NotEnoughPixelData\");\n                          SetPixelAlpha(tile_image,ScaleCharToQuantum(*p),q);\n                          SetPixelRed(tile_image,ScaleCharToQuantum(\n                            *(p+tile_image->columns)),q);\n                          SetPixelGreen(tile_image,ScaleCharToQuantum(\n                            *(p+2*tile_image->columns)),q);\n                          SetPixelBlue(tile_image,ScaleCharToQuantum(\n                            *(p+3*tile_image->columns)),q);\n                        }\n                  }\n                p++;\n                q+=GetPixelChannels(tile_image);\n              }\n              if (SyncAuthenticPixels(tile_image,exception) == MagickFalse)\n                break;\n              if ((tile_image->storage_class == DirectClass) &&\n                  (pixmap.bits_per_pixel != 16))\n                {\n                  p+=(pixmap.component_count-1)*tile_image->columns;\n                  if (p < pixels)\n                    break;\n                }\n              status=SetImageProgress(image,LoadImageTag,(MagickOffsetType) y,\n                tile_image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n            pixels=(unsigned char *) RelinquishMagickMemory(pixels);\n            if ((jpeg == MagickFalse) && (EOFBlob(image) == MagickFalse))\n              if ((code == 0x9a) || (code == 0x9b) ||\n                  ((bytes_per_line & 0x8000) != 0))\n                (void) CompositeImage(image,tile_image,CopyCompositeOp,\n                  MagickTrue,(ssize_t) destination.left,(ssize_t)\n                  destination.top,exception);\n            tile_image=DestroyImage(tile_image);\n            break;\n          }\n          case 0xa1:\n          {\n            unsigned char\n              *info;\n\n            size_t\n              type;\n\n            /*\n              Comment.\n            */\n            type=ReadBlobMSBShort(image);\n            length=ReadBlobMSBShort(image);\n            if (length == 0)\n              break;\n            (void) ReadBlobMSBLong(image);\n            length-=MagickMin(length,4);\n            if (length == 0)\n              break;\n            info=(unsigned char *) AcquireQuantumMemory(length,sizeof(*info));\n            if (info == (unsigned char *) NULL)\n              break;\n            count=ReadBlob(image,length,info);\n            if (count != (ssize_t) length)\n              {\n                info=(unsigned char *) RelinquishMagickMemory(info);\n                ThrowPICTException(ResourceLimitError,\"UnableToReadImageData\");\n              }\n            switch (type)\n            {\n              case 0xe0:\n              {\n                profile=BlobToStringInfo((const void *) NULL,length);\n                SetStringInfoDatum(profile,info);\n                status=SetImageProfile(image,\"icc\",profile,exception);\n                profile=DestroyStringInfo(profile);\n                if (status == MagickFalse)\n                  {\n                    info=(unsigned char *) RelinquishMagickMemory(info);\n                    ThrowPICTException(ResourceLimitError,\n                      \"MemoryAllocationFailed\");\n                  }\n                break;\n              }\n              case 0x1f2:\n              {\n                profile=BlobToStringInfo((const void *) NULL,length);\n                SetStringInfoDatum(profile,info);\n                status=SetImageProfile(image,\"iptc\",profile,exception);\n                if (status == MagickFalse)\n                  {\n                    info=(unsigned char *) RelinquishMagickMemory(info);\n                    ThrowPICTException(ResourceLimitError,\n                      \"MemoryAllocationFailed\");\n                  }\n                profile=DestroyStringInfo(profile);\n                break;\n              }\n              default:\n                break;\n            }\n            info=(unsigned char *) RelinquishMagickMemory(info);\n            break;\n          }\n          default:\n          {\n            /*\n              Skip to next op code.\n            */\n            if (codes[code].length == -1)\n              (void) ReadBlobMSBShort(image);\n            else\n              for (i=0; i < (ssize_t) codes[code].length; i++)\n                if (ReadBlobByte(image) == EOF)\n                  break;\n          }\n        }\n      }\n    if (code == 0xc00)\n      {\n        /*\n          Skip header.\n        */\n        for (i=0; i < 24; i++)\n          if (ReadBlobByte(image) == EOF)\n            break;\n        continue;\n      }\n    if (((code >= 0xb0) && (code <= 0xcf)) ||\n        ((code >= 0x8000) && (code <= 0x80ff)))\n      continue;\n    if (code == 0x8200)\n      {\n        char\n          filename[MaxTextExtent];\n\n        FILE\n          *file;\n\n        int\n          unique_file;\n\n        /*\n          Embedded JPEG.\n        */\n        jpeg=MagickTrue;\n        read_info=CloneImageInfo(image_info);\n        SetImageInfoBlob(read_info,(void *) NULL,0);\n        file=(FILE *) NULL;\n        unique_file=AcquireUniqueFileResource(filename);\n        (void) FormatLocaleString(read_info->filename,MaxTextExtent,\"jpeg:%s\",\n          filename);\n        if (unique_file != -1)\n          file=fdopen(unique_file,\"wb\");\n        if ((unique_file == -1) || (file == (FILE *) NULL))\n          {\n            (void) RelinquishUniqueFileResource(read_info->filename);\n            (void) CopyMagickString(image->filename,read_info->filename,\n              MagickPathExtent);\n            ThrowPICTException(FileOpenError,\"UnableToCreateTemporaryFile\");\n          }\n        length=ReadBlobMSBLong(image);\n        if (length > 154)\n          {\n            for (i=0; i < 6; i++)\n              (void) ReadBlobMSBLong(image);\n            if (ReadRectangle(image,&frame) == MagickFalse)\n              {\n                (void) fclose(file);\n                (void) RelinquishUniqueFileResource(read_info->filename);\n                ThrowPICTException(CorruptImageError,\"ImproperImageHeader\");\n              }\n            for (i=0; i < 122; i++)\n              if (ReadBlobByte(image) == EOF)\n                break;\n            for (i=0; i < (ssize_t) (length-154); i++)\n            {\n              c=ReadBlobByte(image);\n              if (c == EOF)\n                break;\n              if (fputc(c,file) != c)\n                break;\n            }\n          }\n        (void) fclose(file);\n        (void) close(unique_file);\n        tile_image=ReadImage(read_info,exception);\n        (void) RelinquishUniqueFileResource(filename);\n        read_info=DestroyImageInfo(read_info);\n        if (tile_image == (Image *) NULL)\n          continue;\n        (void) FormatLocaleString(geometry,MagickPathExtent,\"%.20gx%.20g\",\n          (double) MagickMax(image->columns,tile_image->columns),\n          (double) MagickMax(image->rows,tile_image->rows));\n        (void) SetImageExtent(image,\n          MagickMax(image->columns,tile_image->columns),\n          MagickMax(image->rows,tile_image->rows),exception);\n        (void) TransformImageColorspace(image,tile_image->colorspace,exception);\n        (void) CompositeImage(image,tile_image,CopyCompositeOp,MagickTrue,\n          (ssize_t) frame.left,(ssize_t) frame.right,exception);\n        image->compression=tile_image->compression;\n        tile_image=DestroyImage(tile_image);\n        continue;\n      }\n    if ((code == 0xff) || (code == 0xffff))\n      break;\n    if (((code >= 0xd0) && (code <= 0xfe)) ||\n        ((code >= 0x8100) && (code <= 0xffff)))\n      {\n        /*\n          Skip reserved.\n        */\n        length=ReadBlobMSBShort(image);\n        for (i=0; i < (ssize_t) length; i++)\n          if (ReadBlobByte(image) == EOF)\n            break;\n        continue;\n      }\n    if ((code >= 0x100) && (code <= 0x7fff))\n      {\n        /*\n          Skip reserved.\n        */\n        length=(size_t) ((code >> 7) & 0xff);\n        for (i=0; i < (ssize_t) length; i++)\n          if (ReadBlobByte(image) == EOF)\n            break;\n        continue;\n      }\n  }\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -661,7 +661,8 @@\n               c=ReadBlobByte(image);\n               if (c == EOF)\n                 break;\n-              (void) fputc(c,file);\n+              if (fputc(c,file) != c)\n+                break;\n             }\n           }\n         (void) fclose(file);",
        "diff_line_info": {
            "deleted_lines": [
                "              (void) fputc(c,file);"
            ],
            "added_lines": [
                "              if (fputc(c,file) != c)",
                "                break;"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-28902",
        "func_name": "CESNET/libyang/read_yin_anydata",
        "description": "In function read_yin_container() in libyang <= v1.0.225, it doesn't check whether the value of retval->ext[r] is NULL. In some cases, it can be NULL, which leads to the operation of retval->ext[r]->flags that results in a crash.",
        "git_url": "https://github.com/CESNET/libyang/commit/a3917d95d516e3de267d3cfa5d4d3715a90e8777",
        "commit_title": "yin parser BUGFIX invalid memory access",
        "commit_text": " ... in case there were some unresolved extensions. Fixes #1454 Fixes #1455",
        "func_before": "static struct lys_node *\nread_yin_anydata(struct lys_module *module, struct lys_node *parent, struct lyxml_elem *yin, LYS_NODE type,\n                 int options, struct unres_schema *unres)\n{\n    struct ly_ctx *ctx = module->ctx;\n    struct lys_node *retval;\n    struct lys_node_anydata *anyxml;\n    struct lyxml_elem *sub, *next;\n    const char *value;\n    int r;\n    int f_mand = 0;\n    int c_must = 0, c_ftrs = 0, c_ext = 0;\n    void *reallocated;\n\n    anyxml = calloc(1, sizeof *anyxml);\n    LY_CHECK_ERR_RETURN(!anyxml, LOGMEM(ctx), NULL);\n\n    anyxml->nodetype = type;\n    anyxml->prev = (struct lys_node *)anyxml;\n    retval = (struct lys_node *)anyxml;\n\n    if (read_yin_common(module, parent, retval, LYEXT_PAR_NODE, yin,\n            OPT_IDENT | OPT_MODULE | ((options & LYS_PARSE_OPT_CFG_IGNORE) ? OPT_CFG_IGNORE :\n            (options & LYS_PARSE_OPT_CFG_NOINHERIT) ? OPT_CFG_PARSE : OPT_CFG_PARSE | OPT_CFG_INHERIT), unres)) {\n        goto error;\n    }\n\n    LOGDBG(LY_LDGYIN, \"parsing %s statement \\\"%s\\\"\", yin->name, retval->name);\n\n    /* insert the node into the schema tree */\n    if (lys_node_addchild(parent, lys_main_module(module), retval, options)) {\n        goto error;\n    }\n\n    LY_TREE_FOR_SAFE(yin->child, next, sub) {\n        if (strcmp(sub->ns->value, LY_NSYIN)) {\n            /* extension */\n            YIN_CHECK_ARRAY_OVERFLOW_GOTO(ctx, c_ext, retval->ext_size, \"extensions\", \"anydata\", error);\n            c_ext++;\n        } else if (!strcmp(sub->name, \"mandatory\")) {\n            if (f_mand) {\n                LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_LYS, retval, sub->name, yin->name);\n                goto error;\n            }\n            /* just checking the flags in leaf is not sufficient, we would allow\n             * multiple mandatory statements with the \"false\" value\n             */\n            f_mand = 1;\n\n            GETVAL(ctx, value, sub, \"value\");\n            if (!strcmp(value, \"true\")) {\n                anyxml->flags |= LYS_MAND_TRUE;\n            } else if (!strcmp(value, \"false\")) {\n                anyxml->flags |= LYS_MAND_FALSE;\n            } else {\n                LOGVAL(ctx, LYE_INARG, LY_VLOG_LYS, retval, value, sub->name);\n                goto error;\n            }\n            /* else false is the default value, so we can ignore it */\n\n            if (lyp_yin_parse_subnode_ext(module, retval, LYEXT_PAR_NODE, sub, LYEXT_SUBSTMT_MANDATORY, 0, unres)) {\n                goto error;\n            }\n            lyxml_free(ctx, sub);\n        } else if (!strcmp(sub->name, \"when\")) {\n            if (anyxml->when) {\n                LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_LYS, retval, sub->name, yin->name);\n                goto error;\n            }\n\n            anyxml->when = read_yin_when(module, sub, unres);\n            if (!anyxml->when) {\n                lyxml_free(ctx, sub);\n                goto error;\n            }\n            lyxml_free(ctx, sub);\n        } else if (!strcmp(sub->name, \"must\")) {\n            YIN_CHECK_ARRAY_OVERFLOW_GOTO(ctx, c_must, anyxml->must_size, \"musts\", \"anydata\", error);\n            c_must++;\n        } else if (!strcmp(sub->name, \"if-feature\")) {\n            YIN_CHECK_ARRAY_OVERFLOW_GOTO(ctx, c_ftrs, retval->iffeature_size, \"if-features\", \"anydata\", error);\n            c_ftrs++;\n\n        } else {\n            LOGVAL(ctx, LYE_INSTMT, LY_VLOG_LYS, retval, sub->name);\n            goto error;\n        }\n    }\n\n    /* middle part - process nodes with cardinality of 0..n */\n    if (c_must) {\n        anyxml->must = calloc(c_must, sizeof *anyxml->must);\n        LY_CHECK_ERR_GOTO(!anyxml->must, LOGMEM(ctx), error);\n    }\n    if (c_ftrs) {\n        anyxml->iffeature = calloc(c_ftrs, sizeof *anyxml->iffeature);\n        LY_CHECK_ERR_GOTO(!anyxml->iffeature, LOGMEM(ctx), error);\n    }\n    if (c_ext) {\n        /* some extensions may be already present from the substatements */\n        reallocated = realloc(retval->ext, (c_ext + retval->ext_size) * sizeof *retval->ext);\n        LY_CHECK_ERR_GOTO(!reallocated, LOGMEM(ctx), error);\n        retval->ext = reallocated;\n\n        /* init memory */\n        memset(&retval->ext[retval->ext_size], 0, c_ext * sizeof *retval->ext);\n    }\n\n    LY_TREE_FOR_SAFE(yin->child, next, sub) {\n        if (strcmp(sub->ns->value, LY_NSYIN)) {\n            /* extension */\n            r = lyp_yin_fill_ext(retval, LYEXT_PAR_NODE, 0, 0, module, sub, &retval->ext, &retval->ext_size, unres);\n            if (r) {\n                goto error;\n            }\n        } else if (!strcmp(sub->name, \"must\")) {\n            r = fill_yin_must(module, sub, &anyxml->must[anyxml->must_size], unres);\n            anyxml->must_size++;\n            if (r) {\n                goto error;\n            }\n        } else if (!strcmp(sub->name, \"if-feature\")) {\n            r = fill_yin_iffeature(retval, 0, sub, &anyxml->iffeature[anyxml->iffeature_size], unres);\n            anyxml->iffeature_size++;\n            if (r) {\n                goto error;\n            }\n        }\n    }\n\n    lyp_reduce_ext_list(&retval->ext, retval->ext_size, c_ext + retval->ext_size);\n\n    /* check XPath dependencies */\n    if (!(ctx->models.flags & LY_CTX_TRUSTED) && (anyxml->when || anyxml->must)) {\n        if (options & LYS_PARSE_OPT_INGRP) {\n            if (lyxp_node_check_syntax(retval)) {\n                goto error;\n            }\n        } else {\n            if (unres_schema_add_node(module, unres, retval, UNRES_XPATH, NULL) == -1) {\n                goto error;\n            }\n        }\n    }\n\n    for (r = 0; r < retval->ext_size; ++r) {\n        /* set flag, which represent LYEXT_OPT_VALID */\n        if (retval->ext[r]->flags & LYEXT_OPT_VALID) {\n            retval->flags |= LYS_VALID_EXT;\n            break;\n        }\n    }\n\n    return retval;\n\nerror:\n    lys_node_free(ctx, retval, NULL, 0);\n    return NULL;\n}",
        "func": "static struct lys_node *\nread_yin_anydata(struct lys_module *module, struct lys_node *parent, struct lyxml_elem *yin, LYS_NODE type,\n                 int options, struct unres_schema *unres)\n{\n    struct ly_ctx *ctx = module->ctx;\n    struct lys_node *retval;\n    struct lys_node_anydata *anyxml;\n    struct lyxml_elem *sub, *next;\n    const char *value;\n    int r;\n    int f_mand = 0;\n    int c_must = 0, c_ftrs = 0, c_ext = 0;\n    void *reallocated;\n\n    anyxml = calloc(1, sizeof *anyxml);\n    LY_CHECK_ERR_RETURN(!anyxml, LOGMEM(ctx), NULL);\n\n    anyxml->nodetype = type;\n    anyxml->prev = (struct lys_node *)anyxml;\n    retval = (struct lys_node *)anyxml;\n\n    if (read_yin_common(module, parent, retval, LYEXT_PAR_NODE, yin,\n            OPT_IDENT | OPT_MODULE | ((options & LYS_PARSE_OPT_CFG_IGNORE) ? OPT_CFG_IGNORE :\n            (options & LYS_PARSE_OPT_CFG_NOINHERIT) ? OPT_CFG_PARSE : OPT_CFG_PARSE | OPT_CFG_INHERIT), unres)) {\n        goto error;\n    }\n\n    LOGDBG(LY_LDGYIN, \"parsing %s statement \\\"%s\\\"\", yin->name, retval->name);\n\n    /* insert the node into the schema tree */\n    if (lys_node_addchild(parent, lys_main_module(module), retval, options)) {\n        goto error;\n    }\n\n    LY_TREE_FOR_SAFE(yin->child, next, sub) {\n        if (strcmp(sub->ns->value, LY_NSYIN)) {\n            /* extension */\n            YIN_CHECK_ARRAY_OVERFLOW_GOTO(ctx, c_ext, retval->ext_size, \"extensions\", \"anydata\", error);\n            c_ext++;\n        } else if (!strcmp(sub->name, \"mandatory\")) {\n            if (f_mand) {\n                LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_LYS, retval, sub->name, yin->name);\n                goto error;\n            }\n            /* just checking the flags in leaf is not sufficient, we would allow\n             * multiple mandatory statements with the \"false\" value\n             */\n            f_mand = 1;\n\n            GETVAL(ctx, value, sub, \"value\");\n            if (!strcmp(value, \"true\")) {\n                anyxml->flags |= LYS_MAND_TRUE;\n            } else if (!strcmp(value, \"false\")) {\n                anyxml->flags |= LYS_MAND_FALSE;\n            } else {\n                LOGVAL(ctx, LYE_INARG, LY_VLOG_LYS, retval, value, sub->name);\n                goto error;\n            }\n            /* else false is the default value, so we can ignore it */\n\n            if (lyp_yin_parse_subnode_ext(module, retval, LYEXT_PAR_NODE, sub, LYEXT_SUBSTMT_MANDATORY, 0, unres)) {\n                goto error;\n            }\n            lyxml_free(ctx, sub);\n        } else if (!strcmp(sub->name, \"when\")) {\n            if (anyxml->when) {\n                LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_LYS, retval, sub->name, yin->name);\n                goto error;\n            }\n\n            anyxml->when = read_yin_when(module, sub, unres);\n            if (!anyxml->when) {\n                lyxml_free(ctx, sub);\n                goto error;\n            }\n            lyxml_free(ctx, sub);\n        } else if (!strcmp(sub->name, \"must\")) {\n            YIN_CHECK_ARRAY_OVERFLOW_GOTO(ctx, c_must, anyxml->must_size, \"musts\", \"anydata\", error);\n            c_must++;\n        } else if (!strcmp(sub->name, \"if-feature\")) {\n            YIN_CHECK_ARRAY_OVERFLOW_GOTO(ctx, c_ftrs, retval->iffeature_size, \"if-features\", \"anydata\", error);\n            c_ftrs++;\n\n        } else {\n            LOGVAL(ctx, LYE_INSTMT, LY_VLOG_LYS, retval, sub->name);\n            goto error;\n        }\n    }\n\n    /* middle part - process nodes with cardinality of 0..n */\n    if (c_must) {\n        anyxml->must = calloc(c_must, sizeof *anyxml->must);\n        LY_CHECK_ERR_GOTO(!anyxml->must, LOGMEM(ctx), error);\n    }\n    if (c_ftrs) {\n        anyxml->iffeature = calloc(c_ftrs, sizeof *anyxml->iffeature);\n        LY_CHECK_ERR_GOTO(!anyxml->iffeature, LOGMEM(ctx), error);\n    }\n    if (c_ext) {\n        /* some extensions may be already present from the substatements */\n        reallocated = realloc(retval->ext, (c_ext + retval->ext_size) * sizeof *retval->ext);\n        LY_CHECK_ERR_GOTO(!reallocated, LOGMEM(ctx), error);\n        retval->ext = reallocated;\n\n        /* init memory */\n        memset(&retval->ext[retval->ext_size], 0, c_ext * sizeof *retval->ext);\n    }\n\n    LY_TREE_FOR_SAFE(yin->child, next, sub) {\n        if (strcmp(sub->ns->value, LY_NSYIN)) {\n            /* extension */\n            r = lyp_yin_fill_ext(retval, LYEXT_PAR_NODE, 0, 0, module, sub, &retval->ext, &retval->ext_size, unres);\n            if (r) {\n                goto error;\n            }\n        } else if (!strcmp(sub->name, \"must\")) {\n            r = fill_yin_must(module, sub, &anyxml->must[anyxml->must_size], unres);\n            anyxml->must_size++;\n            if (r) {\n                goto error;\n            }\n        } else if (!strcmp(sub->name, \"if-feature\")) {\n            r = fill_yin_iffeature(retval, 0, sub, &anyxml->iffeature[anyxml->iffeature_size], unres);\n            anyxml->iffeature_size++;\n            if (r) {\n                goto error;\n            }\n        }\n    }\n\n    lyp_reduce_ext_list(&retval->ext, retval->ext_size, c_ext + retval->ext_size);\n\n    /* check XPath dependencies */\n    if (!(ctx->models.flags & LY_CTX_TRUSTED) && (anyxml->when || anyxml->must)) {\n        if (options & LYS_PARSE_OPT_INGRP) {\n            if (lyxp_node_check_syntax(retval)) {\n                goto error;\n            }\n        } else {\n            if (unres_schema_add_node(module, unres, retval, UNRES_XPATH, NULL) == -1) {\n                goto error;\n            }\n        }\n    }\n\n    for (r = 0; r < retval->ext_size; ++r) {\n        /* set flag, which represent LYEXT_OPT_VALID */\n        if (retval->ext[r] && (retval->ext[r]->flags & LYEXT_OPT_VALID)) {\n            retval->flags |= LYS_VALID_EXT;\n            break;\n        }\n    }\n\n    return retval;\n\nerror:\n    lys_node_free(ctx, retval, NULL, 0);\n    return NULL;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -145,7 +145,7 @@\n \n     for (r = 0; r < retval->ext_size; ++r) {\n         /* set flag, which represent LYEXT_OPT_VALID */\n-        if (retval->ext[r]->flags & LYEXT_OPT_VALID) {\n+        if (retval->ext[r] && (retval->ext[r]->flags & LYEXT_OPT_VALID)) {\n             retval->flags |= LYS_VALID_EXT;\n             break;\n         }",
        "diff_line_info": {
            "deleted_lines": [
                "        if (retval->ext[r]->flags & LYEXT_OPT_VALID) {"
            ],
            "added_lines": [
                "        if (retval->ext[r] && (retval->ext[r]->flags & LYEXT_OPT_VALID)) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-28902",
        "func_name": "CESNET/libyang/read_yin_leaf",
        "description": "In function read_yin_container() in libyang <= v1.0.225, it doesn't check whether the value of retval->ext[r] is NULL. In some cases, it can be NULL, which leads to the operation of retval->ext[r]->flags that results in a crash.",
        "git_url": "https://github.com/CESNET/libyang/commit/a3917d95d516e3de267d3cfa5d4d3715a90e8777",
        "commit_title": "yin parser BUGFIX invalid memory access",
        "commit_text": " ... in case there were some unresolved extensions. Fixes #1454 Fixes #1455",
        "func_before": "static struct lys_node *\nread_yin_leaf(struct lys_module *module, struct lys_node *parent, struct lyxml_elem *yin, int options,\n              struct unres_schema *unres)\n{\n    struct ly_ctx *ctx = module->ctx;\n    struct lys_node *retval;\n    struct lys_node_leaf *leaf;\n    struct lyxml_elem *sub, *next;\n    const char *value;\n    int r, has_type = 0;\n    int c_must = 0, c_ftrs = 0, f_mand = 0, c_ext = 0;\n    void *reallocated;\n\n    leaf = calloc(1, sizeof *leaf);\n    LY_CHECK_ERR_RETURN(!leaf, LOGMEM(ctx), NULL);\n\n    leaf->nodetype = LYS_LEAF;\n    leaf->prev = (struct lys_node *)leaf;\n    retval = (struct lys_node *)leaf;\n\n    if (read_yin_common(module, parent, retval, LYEXT_PAR_NODE, yin,\n            OPT_IDENT | OPT_MODULE | ((options & LYS_PARSE_OPT_CFG_IGNORE) ? OPT_CFG_IGNORE :\n                (options & LYS_PARSE_OPT_CFG_NOINHERIT) ? OPT_CFG_PARSE : OPT_CFG_PARSE | OPT_CFG_INHERIT),\n            unres)) {\n        goto error;\n    }\n\n    LOGDBG(LY_LDGYIN, \"parsing %s statement \\\"%s\\\"\", yin->name, retval->name);\n\n    /* insert the node into the schema tree */\n    if (lys_node_addchild(parent, lys_main_module(module), retval, options)) {\n        goto error;\n    }\n\n    LY_TREE_FOR_SAFE(yin->child, next, sub) {\n        if (strcmp(sub->ns->value, LY_NSYIN)) {\n            /* extension */\n            YIN_CHECK_ARRAY_OVERFLOW_GOTO(ctx, c_ext, retval->ext_size, \"extensions\", \"leaf\", error);\n            c_ext++;\n            continue;\n        } else if (!strcmp(sub->name, \"type\")) {\n            if (has_type) {\n                LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_LYS, retval, sub->name, yin->name);\n                goto error;\n            }\n            /* HACK for unres */\n            leaf->type.der = (struct lys_tpdf *)sub;\n            leaf->type.parent = (struct lys_tpdf *)leaf;\n            /* postpone type resolution when if-feature parsing is done since we need\n             * if-feature for check_leafref_features() */\n            has_type = 1;\n        } else if (!strcmp(sub->name, \"default\")) {\n            if (leaf->dflt) {\n                LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_LYS, retval, sub->name, yin->name);\n                goto error;\n            }\n            GETVAL(ctx, value, sub, \"value\");\n            leaf->dflt = lydict_insert(ctx, value, strlen(value));\n\n            if (lyp_yin_parse_subnode_ext(module, retval, LYEXT_PAR_NODE, sub, LYEXT_SUBSTMT_DEFAULT, 0, unres)) {\n                goto error;\n            }\n        } else if (!strcmp(sub->name, \"units\")) {\n            if (leaf->units) {\n                LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_LYS, retval, sub->name, yin->name);\n                goto error;\n            }\n            GETVAL(ctx, value, sub, \"name\");\n            leaf->units = lydict_insert(ctx, value, strlen(value));\n\n            if (lyp_yin_parse_subnode_ext(module, retval, LYEXT_PAR_NODE, sub, LYEXT_SUBSTMT_UNITS, 0, unres)) {\n                goto error;\n            }\n        } else if (!strcmp(sub->name, \"mandatory\")) {\n            if (f_mand) {\n                LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_LYS, retval, sub->name, yin->name);\n                goto error;\n            }\n            /* just checking the flags in leaf is not sufficient, we would allow\n             * multiple mandatory statements with the \"false\" value\n             */\n            f_mand = 1;\n\n            GETVAL(ctx, value, sub, \"value\");\n            if (!strcmp(value, \"true\")) {\n                leaf->flags |= LYS_MAND_TRUE;\n            } else if (!strcmp(value, \"false\")) {\n                leaf->flags |= LYS_MAND_FALSE;\n            } else {\n                LOGVAL(ctx, LYE_INARG, LY_VLOG_LYS, retval, value, sub->name);\n                goto error;\n            }                   /* else false is the default value, so we can ignore it */\n\n            if (lyp_yin_parse_subnode_ext(module, retval, LYEXT_PAR_NODE, sub, LYEXT_SUBSTMT_MANDATORY, 0, unres)) {\n                goto error;\n            }\n        } else if (!strcmp(sub->name, \"when\")) {\n            if (leaf->when) {\n                LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_LYS, retval, sub->name, yin->name);\n                goto error;\n            }\n\n            leaf->when = read_yin_when(module, sub, unres);\n            if (!leaf->when) {\n                goto error;\n            }\n\n        } else if (!strcmp(sub->name, \"must\")) {\n            YIN_CHECK_ARRAY_OVERFLOW_GOTO(ctx, c_must, leaf->must_size, \"musts\", \"leaf\", error);\n            c_must++;\n            continue;\n        } else if (!strcmp(sub->name, \"if-feature\")) {\n            YIN_CHECK_ARRAY_OVERFLOW_GOTO(ctx, c_ftrs, retval->iffeature_size, \"musts\", \"leaf\", error);\n            c_ftrs++;\n            continue;\n\n        } else {\n            LOGVAL(ctx, LYE_INSTMT, LY_VLOG_LYS, retval, sub->name);\n            goto error;\n        }\n\n        /* do not free sub, it could have been unlinked and stored in unres */\n    }\n\n    /* check mandatory parameters */\n    if (!has_type) {\n        LOGVAL(ctx, LYE_MISSCHILDSTMT, LY_VLOG_LYS, retval, \"type\", yin->name);\n        goto error;\n    }\n    if (leaf->dflt && (leaf->flags & LYS_MAND_TRUE)) {\n        LOGVAL(ctx, LYE_INCHILDSTMT, LY_VLOG_LYS, retval, \"mandatory\", \"leaf\");\n        LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL,\n               \"The \\\"mandatory\\\" statement is forbidden on leaf with the \\\"default\\\" statement.\");\n        goto error;\n    }\n\n    /* middle part - process nodes with cardinality of 0..n */\n    if (c_must) {\n        leaf->must = calloc(c_must, sizeof *leaf->must);\n        LY_CHECK_ERR_GOTO(!leaf->must, LOGMEM(ctx), error);\n    }\n    if (c_ftrs) {\n        leaf->iffeature = calloc(c_ftrs, sizeof *leaf->iffeature);\n        LY_CHECK_ERR_GOTO(!leaf->iffeature, LOGMEM(ctx), error);\n    }\n    if (c_ext) {\n        /* some extensions may be already present from the substatements */\n        reallocated = realloc(retval->ext, (c_ext + retval->ext_size) * sizeof *retval->ext);\n        LY_CHECK_ERR_GOTO(!reallocated, LOGMEM(ctx), error);\n        retval->ext = reallocated;\n\n        /* init memory */\n        memset(&retval->ext[retval->ext_size], 0, c_ext * sizeof *retval->ext);\n    }\n\n    LY_TREE_FOR_SAFE(yin->child, next, sub) {\n        if (strcmp(sub->ns->value, LY_NSYIN)) {\n            /* extension */\n            r = lyp_yin_fill_ext(retval, LYEXT_PAR_NODE, 0, 0, module, sub, &retval->ext, &retval->ext_size, unres);\n            if (r) {\n                goto error;\n            }\n        } else if (!strcmp(sub->name, \"must\")) {\n            r = fill_yin_must(module, sub, &leaf->must[leaf->must_size], unres);\n            leaf->must_size++;\n            if (r) {\n                goto error;\n            }\n        } else if (!strcmp(sub->name, \"if-feature\")) {\n            r = fill_yin_iffeature(retval, 0, sub, &leaf->iffeature[leaf->iffeature_size], unres);\n            leaf->iffeature_size++;\n            if (r) {\n                goto error;\n            }\n        }\n    }\n\n    lyp_reduce_ext_list(&retval->ext, retval->ext_size, c_ext + retval->ext_size);\n\n    /* finalize type parsing */\n    if (unres_schema_add_node(module, unres, &leaf->type, UNRES_TYPE_DER, retval) == -1) {\n        leaf->type.der = NULL;\n        goto error;\n    }\n\n    /* check default value (if not defined, there still could be some restrictions\n     * that need to be checked against a default value from a derived type) */\n    if (!(ctx->models.flags & LY_CTX_TRUSTED) &&\n            (unres_schema_add_node(module, unres, &leaf->type, UNRES_TYPE_DFLT,\n                                   (struct lys_node *)(&leaf->dflt)) == -1)) {\n        goto error;\n    }\n\n    /* check XPath dependencies */\n    if (!(ctx->models.flags & LY_CTX_TRUSTED) && (leaf->when || leaf->must)) {\n        if (options & LYS_PARSE_OPT_INGRP) {\n            if (lyxp_node_check_syntax(retval)) {\n                goto error;\n            }\n        } else {\n            if (unres_schema_add_node(module, unres, retval, UNRES_XPATH, NULL) == -1) {\n                goto error;\n            }\n        }\n    }\n\n    for (r = 0; r < retval->ext_size; ++r) {\n        /* set flag, which represent LYEXT_OPT_VALID */\n        if (retval->ext[r]->flags & LYEXT_OPT_VALID) {\n            retval->flags |= LYS_VALID_EXT;\n            break;\n        }\n    }\n\n    return retval;\n\nerror:\n    lys_node_free(ctx, retval, NULL, 0);\n    return NULL;\n}",
        "func": "static struct lys_node *\nread_yin_leaf(struct lys_module *module, struct lys_node *parent, struct lyxml_elem *yin, int options,\n              struct unres_schema *unres)\n{\n    struct ly_ctx *ctx = module->ctx;\n    struct lys_node *retval;\n    struct lys_node_leaf *leaf;\n    struct lyxml_elem *sub, *next;\n    const char *value;\n    int r, has_type = 0;\n    int c_must = 0, c_ftrs = 0, f_mand = 0, c_ext = 0;\n    void *reallocated;\n\n    leaf = calloc(1, sizeof *leaf);\n    LY_CHECK_ERR_RETURN(!leaf, LOGMEM(ctx), NULL);\n\n    leaf->nodetype = LYS_LEAF;\n    leaf->prev = (struct lys_node *)leaf;\n    retval = (struct lys_node *)leaf;\n\n    if (read_yin_common(module, parent, retval, LYEXT_PAR_NODE, yin,\n            OPT_IDENT | OPT_MODULE | ((options & LYS_PARSE_OPT_CFG_IGNORE) ? OPT_CFG_IGNORE :\n                (options & LYS_PARSE_OPT_CFG_NOINHERIT) ? OPT_CFG_PARSE : OPT_CFG_PARSE | OPT_CFG_INHERIT),\n            unres)) {\n        goto error;\n    }\n\n    LOGDBG(LY_LDGYIN, \"parsing %s statement \\\"%s\\\"\", yin->name, retval->name);\n\n    /* insert the node into the schema tree */\n    if (lys_node_addchild(parent, lys_main_module(module), retval, options)) {\n        goto error;\n    }\n\n    LY_TREE_FOR_SAFE(yin->child, next, sub) {\n        if (strcmp(sub->ns->value, LY_NSYIN)) {\n            /* extension */\n            YIN_CHECK_ARRAY_OVERFLOW_GOTO(ctx, c_ext, retval->ext_size, \"extensions\", \"leaf\", error);\n            c_ext++;\n            continue;\n        } else if (!strcmp(sub->name, \"type\")) {\n            if (has_type) {\n                LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_LYS, retval, sub->name, yin->name);\n                goto error;\n            }\n            /* HACK for unres */\n            leaf->type.der = (struct lys_tpdf *)sub;\n            leaf->type.parent = (struct lys_tpdf *)leaf;\n            /* postpone type resolution when if-feature parsing is done since we need\n             * if-feature for check_leafref_features() */\n            has_type = 1;\n        } else if (!strcmp(sub->name, \"default\")) {\n            if (leaf->dflt) {\n                LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_LYS, retval, sub->name, yin->name);\n                goto error;\n            }\n            GETVAL(ctx, value, sub, \"value\");\n            leaf->dflt = lydict_insert(ctx, value, strlen(value));\n\n            if (lyp_yin_parse_subnode_ext(module, retval, LYEXT_PAR_NODE, sub, LYEXT_SUBSTMT_DEFAULT, 0, unres)) {\n                goto error;\n            }\n        } else if (!strcmp(sub->name, \"units\")) {\n            if (leaf->units) {\n                LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_LYS, retval, sub->name, yin->name);\n                goto error;\n            }\n            GETVAL(ctx, value, sub, \"name\");\n            leaf->units = lydict_insert(ctx, value, strlen(value));\n\n            if (lyp_yin_parse_subnode_ext(module, retval, LYEXT_PAR_NODE, sub, LYEXT_SUBSTMT_UNITS, 0, unres)) {\n                goto error;\n            }\n        } else if (!strcmp(sub->name, \"mandatory\")) {\n            if (f_mand) {\n                LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_LYS, retval, sub->name, yin->name);\n                goto error;\n            }\n            /* just checking the flags in leaf is not sufficient, we would allow\n             * multiple mandatory statements with the \"false\" value\n             */\n            f_mand = 1;\n\n            GETVAL(ctx, value, sub, \"value\");\n            if (!strcmp(value, \"true\")) {\n                leaf->flags |= LYS_MAND_TRUE;\n            } else if (!strcmp(value, \"false\")) {\n                leaf->flags |= LYS_MAND_FALSE;\n            } else {\n                LOGVAL(ctx, LYE_INARG, LY_VLOG_LYS, retval, value, sub->name);\n                goto error;\n            }                   /* else false is the default value, so we can ignore it */\n\n            if (lyp_yin_parse_subnode_ext(module, retval, LYEXT_PAR_NODE, sub, LYEXT_SUBSTMT_MANDATORY, 0, unres)) {\n                goto error;\n            }\n        } else if (!strcmp(sub->name, \"when\")) {\n            if (leaf->when) {\n                LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_LYS, retval, sub->name, yin->name);\n                goto error;\n            }\n\n            leaf->when = read_yin_when(module, sub, unres);\n            if (!leaf->when) {\n                goto error;\n            }\n\n        } else if (!strcmp(sub->name, \"must\")) {\n            YIN_CHECK_ARRAY_OVERFLOW_GOTO(ctx, c_must, leaf->must_size, \"musts\", \"leaf\", error);\n            c_must++;\n            continue;\n        } else if (!strcmp(sub->name, \"if-feature\")) {\n            YIN_CHECK_ARRAY_OVERFLOW_GOTO(ctx, c_ftrs, retval->iffeature_size, \"musts\", \"leaf\", error);\n            c_ftrs++;\n            continue;\n\n        } else {\n            LOGVAL(ctx, LYE_INSTMT, LY_VLOG_LYS, retval, sub->name);\n            goto error;\n        }\n\n        /* do not free sub, it could have been unlinked and stored in unres */\n    }\n\n    /* check mandatory parameters */\n    if (!has_type) {\n        LOGVAL(ctx, LYE_MISSCHILDSTMT, LY_VLOG_LYS, retval, \"type\", yin->name);\n        goto error;\n    }\n    if (leaf->dflt && (leaf->flags & LYS_MAND_TRUE)) {\n        LOGVAL(ctx, LYE_INCHILDSTMT, LY_VLOG_LYS, retval, \"mandatory\", \"leaf\");\n        LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL,\n               \"The \\\"mandatory\\\" statement is forbidden on leaf with the \\\"default\\\" statement.\");\n        goto error;\n    }\n\n    /* middle part - process nodes with cardinality of 0..n */\n    if (c_must) {\n        leaf->must = calloc(c_must, sizeof *leaf->must);\n        LY_CHECK_ERR_GOTO(!leaf->must, LOGMEM(ctx), error);\n    }\n    if (c_ftrs) {\n        leaf->iffeature = calloc(c_ftrs, sizeof *leaf->iffeature);\n        LY_CHECK_ERR_GOTO(!leaf->iffeature, LOGMEM(ctx), error);\n    }\n    if (c_ext) {\n        /* some extensions may be already present from the substatements */\n        reallocated = realloc(retval->ext, (c_ext + retval->ext_size) * sizeof *retval->ext);\n        LY_CHECK_ERR_GOTO(!reallocated, LOGMEM(ctx), error);\n        retval->ext = reallocated;\n\n        /* init memory */\n        memset(&retval->ext[retval->ext_size], 0, c_ext * sizeof *retval->ext);\n    }\n\n    LY_TREE_FOR_SAFE(yin->child, next, sub) {\n        if (strcmp(sub->ns->value, LY_NSYIN)) {\n            /* extension */\n            r = lyp_yin_fill_ext(retval, LYEXT_PAR_NODE, 0, 0, module, sub, &retval->ext, &retval->ext_size, unres);\n            if (r) {\n                goto error;\n            }\n        } else if (!strcmp(sub->name, \"must\")) {\n            r = fill_yin_must(module, sub, &leaf->must[leaf->must_size], unres);\n            leaf->must_size++;\n            if (r) {\n                goto error;\n            }\n        } else if (!strcmp(sub->name, \"if-feature\")) {\n            r = fill_yin_iffeature(retval, 0, sub, &leaf->iffeature[leaf->iffeature_size], unres);\n            leaf->iffeature_size++;\n            if (r) {\n                goto error;\n            }\n        }\n    }\n\n    lyp_reduce_ext_list(&retval->ext, retval->ext_size, c_ext + retval->ext_size);\n\n    /* finalize type parsing */\n    if (unres_schema_add_node(module, unres, &leaf->type, UNRES_TYPE_DER, retval) == -1) {\n        leaf->type.der = NULL;\n        goto error;\n    }\n\n    /* check default value (if not defined, there still could be some restrictions\n     * that need to be checked against a default value from a derived type) */\n    if (!(ctx->models.flags & LY_CTX_TRUSTED) &&\n            (unres_schema_add_node(module, unres, &leaf->type, UNRES_TYPE_DFLT,\n                                   (struct lys_node *)(&leaf->dflt)) == -1)) {\n        goto error;\n    }\n\n    /* check XPath dependencies */\n    if (!(ctx->models.flags & LY_CTX_TRUSTED) && (leaf->when || leaf->must)) {\n        if (options & LYS_PARSE_OPT_INGRP) {\n            if (lyxp_node_check_syntax(retval)) {\n                goto error;\n            }\n        } else {\n            if (unres_schema_add_node(module, unres, retval, UNRES_XPATH, NULL) == -1) {\n                goto error;\n            }\n        }\n    }\n\n    for (r = 0; r < retval->ext_size; ++r) {\n        /* set flag, which represent LYEXT_OPT_VALID */\n        if (retval->ext[r] && (retval->ext[r]->flags & LYEXT_OPT_VALID)) {\n            retval->flags |= LYS_VALID_EXT;\n            break;\n        }\n    }\n\n    return retval;\n\nerror:\n    lys_node_free(ctx, retval, NULL, 0);\n    return NULL;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -206,7 +206,7 @@\n \n     for (r = 0; r < retval->ext_size; ++r) {\n         /* set flag, which represent LYEXT_OPT_VALID */\n-        if (retval->ext[r]->flags & LYEXT_OPT_VALID) {\n+        if (retval->ext[r] && (retval->ext[r]->flags & LYEXT_OPT_VALID)) {\n             retval->flags |= LYS_VALID_EXT;\n             break;\n         }",
        "diff_line_info": {
            "deleted_lines": [
                "        if (retval->ext[r]->flags & LYEXT_OPT_VALID) {"
            ],
            "added_lines": [
                "        if (retval->ext[r] && (retval->ext[r]->flags & LYEXT_OPT_VALID)) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-28902",
        "func_name": "CESNET/libyang/read_yin_list",
        "description": "In function read_yin_container() in libyang <= v1.0.225, it doesn't check whether the value of retval->ext[r] is NULL. In some cases, it can be NULL, which leads to the operation of retval->ext[r]->flags that results in a crash.",
        "git_url": "https://github.com/CESNET/libyang/commit/a3917d95d516e3de267d3cfa5d4d3715a90e8777",
        "commit_title": "yin parser BUGFIX invalid memory access",
        "commit_text": " ... in case there were some unresolved extensions. Fixes #1454 Fixes #1455",
        "func_before": "static struct lys_node *\nread_yin_list(struct lys_module *module, struct lys_node *parent, struct lyxml_elem *yin, int options,\n              struct unres_schema *unres)\n{\n    struct ly_ctx *ctx = module->ctx;\n    struct lys_node *retval, *node;\n    struct lys_node_list *list;\n    struct lyxml_elem *sub, *next, root, uniq;\n    int r;\n    int c_tpdf = 0, c_must = 0, c_uniq = 0, c_ftrs = 0, c_ext = 0;\n    int f_ordr = 0, f_max = 0, f_min = 0;\n    const char *value;\n    char *auxs;\n    unsigned long val;\n    void *reallocated;\n\n    /* init */\n    memset(&root, 0, sizeof root);\n    memset(&uniq, 0, sizeof uniq);\n\n    list = calloc(1, sizeof *list);\n    LY_CHECK_ERR_RETURN(!list, LOGMEM(ctx), NULL);\n\n    list->nodetype = LYS_LIST;\n    list->prev = (struct lys_node *)list;\n    retval = (struct lys_node *)list;\n\n    if (read_yin_common(module, parent, retval, LYEXT_PAR_NODE, yin,\n            OPT_IDENT | OPT_MODULE | ((options & LYS_PARSE_OPT_CFG_IGNORE) ? OPT_CFG_IGNORE :\n                (options & LYS_PARSE_OPT_CFG_NOINHERIT) ? OPT_CFG_PARSE : OPT_CFG_PARSE | OPT_CFG_INHERIT),\n            unres)) {\n        goto error;\n    }\n\n    LOGDBG(LY_LDGYIN, \"parsing %s statement \\\"%s\\\"\", yin->name, retval->name);\n\n    /* insert the node into the schema tree */\n    if (lys_node_addchild(parent, lys_main_module(module), retval, options)) {\n        goto error;\n    }\n\n    /* process list's specific children */\n    LY_TREE_FOR_SAFE(yin->child, next, sub) {\n        if (strcmp(sub->ns->value, LY_NSYIN)) {\n            /* extension */\n            YIN_CHECK_ARRAY_OVERFLOW_GOTO(ctx, c_ext, retval->ext_size, \"extensions\", \"list\", error);\n            c_ext++;\n            continue;\n\n        /* data statements */\n        } else if (!strcmp(sub->name, \"container\") ||\n                !strcmp(sub->name, \"leaf-list\") ||\n                !strcmp(sub->name, \"leaf\") ||\n                !strcmp(sub->name, \"list\") ||\n                !strcmp(sub->name, \"choice\") ||\n                !strcmp(sub->name, \"uses\") ||\n                !strcmp(sub->name, \"grouping\") ||\n                !strcmp(sub->name, \"anyxml\") ||\n                !strcmp(sub->name, \"anydata\") ||\n                !strcmp(sub->name, \"action\") ||\n                !strcmp(sub->name, \"notification\")) {\n            lyxml_unlink_elem(ctx, sub, 2);\n            lyxml_add_child(ctx, &root, sub);\n\n            /* array counters */\n        } else if (!strcmp(sub->name, \"key\")) {\n            /* check cardinality 0..1 */\n            if (list->keys_size) {\n                LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_LYS, retval, sub->name, list->name);\n                goto error;\n            }\n\n            /* count the number of keys */\n            GETVAL(ctx, value, sub, \"value\");\n            list->keys_str = lydict_insert(ctx, value, 0);\n            while ((value = strpbrk(value, \" \\t\\n\"))) {\n                list->keys_size++;\n                while (isspace(*value)) {\n                    value++;\n                }\n            }\n            list->keys_size++;\n            list->keys = calloc(list->keys_size, sizeof *list->keys);\n            LY_CHECK_ERR_GOTO(!list->keys, LOGMEM(ctx), error);\n\n            if (lyp_yin_parse_subnode_ext(module, retval, LYEXT_PAR_NODE, sub, LYEXT_SUBSTMT_KEY, 0, unres)) {\n                goto error;\n            }\n            lyxml_free(ctx, sub);\n        } else if (!strcmp(sub->name, \"unique\")) {\n            YIN_CHECK_ARRAY_OVERFLOW_GOTO(ctx, c_uniq, list->unique_size, \"uniques\", \"list\", error);\n            c_uniq++;\n            lyxml_unlink_elem(ctx, sub, 2);\n            lyxml_add_child(ctx, &uniq, sub);\n        } else if (!strcmp(sub->name, \"typedef\")) {\n            YIN_CHECK_ARRAY_OVERFLOW_GOTO(ctx, c_tpdf, list->tpdf_size, \"typedefs\", \"list\", error);\n            c_tpdf++;\n        } else if (!strcmp(sub->name, \"must\")) {\n            YIN_CHECK_ARRAY_OVERFLOW_GOTO(ctx, c_must, list->must_size, \"musts\", \"list\", error);\n            c_must++;\n        } else if (!strcmp(sub->name, \"if-feature\")) {\n            YIN_CHECK_ARRAY_OVERFLOW_GOTO(ctx, c_ftrs, retval->iffeature_size, \"if-features\", \"list\", error);\n            c_ftrs++;\n\n            /* optional stetments */\n        } else if (!strcmp(sub->name, \"ordered-by\")) {\n            if (f_ordr) {\n                LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_LYS, retval, sub->name, yin->name);\n                goto error;\n            }\n            /* just checking the flags in llist is not sufficient, we would\n             * allow multiple ordered-by statements with the \"system\" value\n             */\n            f_ordr = 1;\n\n            if (list->flags & LYS_CONFIG_R) {\n                /* RFC 6020, 7.7.5 - ignore ordering when the list represents\n                 * state data\n                 */\n                lyxml_free(ctx, sub);\n                continue;\n            }\n\n            GETVAL(ctx, value, sub, \"value\");\n            if (!strcmp(value, \"user\")) {\n                list->flags |= LYS_USERORDERED;\n            } else if (strcmp(value, \"system\")) {\n                LOGVAL(ctx, LYE_INARG, LY_VLOG_LYS, retval, value, sub->name);\n                goto error;\n            } /* else system is the default value, so we can ignore it */\n\n            if (lyp_yin_parse_subnode_ext(module, retval, LYEXT_PAR_NODE, sub, LYEXT_SUBSTMT_ORDEREDBY, 0, unres)) {\n                goto error;\n            }\n            lyxml_free(ctx, sub);\n        } else if (!strcmp(sub->name, \"min-elements\")) {\n            if (f_min) {\n                LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_LYS, retval, sub->name, yin->name);\n                goto error;\n            }\n            f_min = 1;\n\n            GETVAL(ctx, value, sub, \"value\");\n            while (isspace(value[0])) {\n                value++;\n            }\n\n            /* convert it to uint32_t */\n            errno = 0;\n            auxs = NULL;\n            val = strtoul(value, &auxs, 10);\n            if (*auxs || value[0] == '-' || errno || val > UINT32_MAX) {\n                LOGVAL(ctx, LYE_INARG, LY_VLOG_LYS, retval, value, sub->name);\n                goto error;\n            }\n            list->min = (uint32_t) val;\n            if (list->max && (list->min > list->max)) {\n                LOGVAL(ctx, LYE_INARG, LY_VLOG_LYS, retval, value, sub->name);\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, \"\\\"min-elements\\\" is bigger than \\\"max-elements\\\".\");\n                lyxml_free(ctx, sub);\n                goto error;\n            }\n            if (lyp_yin_parse_subnode_ext(module, retval, LYEXT_PAR_NODE, sub, LYEXT_SUBSTMT_MIN, 0, unres)) {\n                goto error;\n            }\n            lyxml_free(ctx, sub);\n        } else if (!strcmp(sub->name, \"max-elements\")) {\n            if (f_max) {\n                LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_LYS, retval, sub->name, yin->name);\n                goto error;\n            }\n            f_max = 1;\n\n            GETVAL(ctx, value, sub, \"value\");\n            while (isspace(value[0])) {\n                value++;\n            }\n\n            if (!strcmp(value, \"unbounded\")) {\n                list->max = 0;;\n            } else {\n                /* convert it to uint32_t */\n                errno = 0;\n                auxs = NULL;\n                val = strtoul(value, &auxs, 10);\n                if (*auxs || value[0] == '-' || errno || val == 0 || val > UINT32_MAX) {\n                    LOGVAL(ctx, LYE_INARG, LY_VLOG_LYS, retval, value, sub->name);\n                    goto error;\n                }\n                list->max = (uint32_t) val;\n                if (list->min > list->max) {\n                    LOGVAL(ctx, LYE_INARG, LY_VLOG_LYS, retval, value, sub->name);\n                    LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, \"\\\"max-elements\\\" is smaller than \\\"min-elements\\\".\");\n                    goto error;\n                }\n            }\n            if (lyp_yin_parse_subnode_ext(module, retval, LYEXT_PAR_NODE, sub, LYEXT_SUBSTMT_MAX, 0, unres)) {\n                goto error;\n            }\n            lyxml_free(ctx, sub);\n        } else if (!strcmp(sub->name, \"when\")) {\n            if (list->when) {\n                LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_LYS, retval, sub->name, yin->name);\n                goto error;\n            }\n\n            list->when = read_yin_when(module, sub, unres);\n            if (!list->when) {\n                lyxml_free(ctx, sub);\n                goto error;\n            }\n            lyxml_free(ctx, sub);\n        } else {\n            LOGVAL(ctx, LYE_INSTMT, LY_VLOG_LYS, retval, sub->name);\n            goto error;\n        }\n    }\n\n    /* check - if list is configuration, key statement is mandatory\n     * (but only if we are not in a grouping or augment, then the check is deferred) */\n    for (node = retval; node && !(node->nodetype & (LYS_GROUPING | LYS_AUGMENT | LYS_EXT)); node = node->parent);\n    if (!node && (list->flags & LYS_CONFIG_W) && !list->keys_str) {\n        LOGVAL(ctx, LYE_MISSCHILDSTMT, LY_VLOG_LYS, retval, \"key\", \"list\");\n        goto error;\n    }\n\n    /* middle part - process nodes with cardinality of 0..n except the data nodes */\n    if (c_tpdf) {\n        list->tpdf = calloc(c_tpdf, sizeof *list->tpdf);\n        LY_CHECK_ERR_GOTO(!list->tpdf, LOGMEM(ctx), error);\n    }\n    if (c_must) {\n        list->must = calloc(c_must, sizeof *list->must);\n        LY_CHECK_ERR_GOTO(!list->must, LOGMEM(ctx), error);\n    }\n    if (c_ftrs) {\n        list->iffeature = calloc(c_ftrs, sizeof *list->iffeature);\n        LY_CHECK_ERR_GOTO(!list->iffeature, LOGMEM(ctx), error);\n    }\n    if (c_ext) {\n        /* some extensions may be already present from the substatements */\n        reallocated = realloc(retval->ext, (c_ext + retval->ext_size) * sizeof *retval->ext);\n        LY_CHECK_ERR_GOTO(!reallocated, LOGMEM(ctx), error);\n        retval->ext = reallocated;\n\n        /* init memory */\n        memset(&retval->ext[retval->ext_size], 0, c_ext * sizeof *retval->ext);\n    }\n\n    LY_TREE_FOR_SAFE(yin->child, next, sub) {\n        if (strcmp(sub->ns->value, LY_NSYIN)) {\n            /* extension */\n            r = lyp_yin_fill_ext(retval, LYEXT_PAR_NODE, 0, 0, module, sub, &retval->ext, &retval->ext_size, unres);\n            if (r) {\n                goto error;\n            }\n        } else if (!strcmp(sub->name, \"typedef\")) {\n            r = fill_yin_typedef(module, retval, sub, &list->tpdf[list->tpdf_size], unres);\n            list->tpdf_size++;\n            if (r) {\n                goto error;\n            }\n        } else if (!strcmp(sub->name, \"if-feature\")) {\n            r = fill_yin_iffeature(retval, 0, sub, &list->iffeature[list->iffeature_size], unres);\n            list->iffeature_size++;\n            if (r) {\n                goto error;\n            }\n        } else if (!strcmp(sub->name, \"must\")) {\n            r = fill_yin_must(module, sub, &list->must[list->must_size], unres);\n            list->must_size++;\n            if (r) {\n                goto error;\n            }\n        }\n    }\n\n    lyp_reduce_ext_list(&retval->ext, retval->ext_size, c_ext + retval->ext_size);\n\n    /* last part - process data nodes */\n    LY_TREE_FOR_SAFE(root.child, next, sub) {\n        if (!strcmp(sub->name, \"container\")) {\n            node = read_yin_container(module, retval, sub, options, unres);\n        } else if (!strcmp(sub->name, \"leaf-list\")) {\n            node = read_yin_leaflist(module, retval, sub, options, unres);\n        } else if (!strcmp(sub->name, \"leaf\")) {\n            node = read_yin_leaf(module, retval, sub, options, unres);\n        } else if (!strcmp(sub->name, \"list\")) {\n            node = read_yin_list(module, retval, sub, options, unres);\n        } else if (!strcmp(sub->name, \"choice\")) {\n            node = read_yin_choice(module, retval, sub, options, unres);\n        } else if (!strcmp(sub->name, \"uses\")) {\n            node = read_yin_uses(module, retval, sub, options, unres);\n        } else if (!strcmp(sub->name, \"grouping\")) {\n            node = read_yin_grouping(module, retval, sub, options, unres);\n        } else if (!strcmp(sub->name, \"anyxml\")) {\n            node = read_yin_anydata(module, retval, sub, LYS_ANYXML, options, unres);\n        } else if (!strcmp(sub->name, \"anydata\")) {\n            node = read_yin_anydata(module, retval, sub, LYS_ANYDATA, options, unres);\n        } else if (!strcmp(sub->name, \"action\")) {\n            node = read_yin_rpc_action(module, retval, sub, options, unres);\n        } else if (!strcmp(sub->name, \"notification\")) {\n            node = read_yin_notif(module, retval, sub, options, unres);\n        } else {\n            LOGINT(ctx);\n            goto error;\n        }\n        if (!node) {\n            goto error;\n        }\n\n        lyxml_free(ctx, sub);\n    }\n\n    if (list->keys_str) {\n        if (unres_schema_add_node(module, unres, list, UNRES_LIST_KEYS, NULL) == -1) {\n            goto error;\n        }\n    } /* else config false list without a key, key_str presence in case of config true is checked earlier */\n\n    /* process unique statements */\n    if (c_uniq) {\n        list->unique = calloc(c_uniq, sizeof *list->unique);\n        LY_CHECK_ERR_GOTO(!list->unique, LOGMEM(ctx), error);\n\n        LY_TREE_FOR_SAFE(uniq.child, next, sub) {\n            r = fill_yin_unique(module, retval, sub, &list->unique[list->unique_size], unres);\n            list->unique_size++;\n            if (r) {\n                goto error;\n            }\n\n            if (lyp_yin_parse_subnode_ext(module, retval, LYEXT_PAR_NODE, sub,\n                                     LYEXT_SUBSTMT_UNIQUE, list->unique_size - 1, unres)) {\n                goto error;\n            }\n            lyxml_free(ctx, sub);\n        }\n    }\n\n    /* check XPath dependencies */\n    if (!(ctx->models.flags & LY_CTX_TRUSTED) && (list->when || list->must)) {\n        if (options & LYS_PARSE_OPT_INGRP) {\n            if (lyxp_node_check_syntax(retval)) {\n                goto error;\n            }\n        } else {\n            if (unres_schema_add_node(module, unres, retval, UNRES_XPATH, NULL) == -1) {\n                goto error;\n            }\n        }\n    }\n\n    for (r = 0; r < retval->ext_size; ++r) {\n        /* set flag, which represent LYEXT_OPT_VALID */\n        if (retval->ext[r]->flags & LYEXT_OPT_VALID) {\n            retval->flags |= LYS_VALID_EXT;\n            if (retval->ext[r]->flags & LYEXT_OPT_VALID_SUBTREE) {\n                retval->flags |= LYS_VALID_EXT_SUBTREE;\n                break;\n            }\n        }\n    }\n\n    return retval;\n\nerror:\n\n    lys_node_free(ctx, retval, NULL, 0);\n    while (root.child) {\n        lyxml_free(ctx, root.child);\n    }\n    while (uniq.child) {\n        lyxml_free(ctx, uniq.child);\n    }\n\n    return NULL;\n}",
        "func": "static struct lys_node *\nread_yin_list(struct lys_module *module, struct lys_node *parent, struct lyxml_elem *yin, int options,\n              struct unres_schema *unres)\n{\n    struct ly_ctx *ctx = module->ctx;\n    struct lys_node *retval, *node;\n    struct lys_node_list *list;\n    struct lyxml_elem *sub, *next, root, uniq;\n    int r;\n    int c_tpdf = 0, c_must = 0, c_uniq = 0, c_ftrs = 0, c_ext = 0;\n    int f_ordr = 0, f_max = 0, f_min = 0;\n    const char *value;\n    char *auxs;\n    unsigned long val;\n    void *reallocated;\n\n    /* init */\n    memset(&root, 0, sizeof root);\n    memset(&uniq, 0, sizeof uniq);\n\n    list = calloc(1, sizeof *list);\n    LY_CHECK_ERR_RETURN(!list, LOGMEM(ctx), NULL);\n\n    list->nodetype = LYS_LIST;\n    list->prev = (struct lys_node *)list;\n    retval = (struct lys_node *)list;\n\n    if (read_yin_common(module, parent, retval, LYEXT_PAR_NODE, yin,\n            OPT_IDENT | OPT_MODULE | ((options & LYS_PARSE_OPT_CFG_IGNORE) ? OPT_CFG_IGNORE :\n                (options & LYS_PARSE_OPT_CFG_NOINHERIT) ? OPT_CFG_PARSE : OPT_CFG_PARSE | OPT_CFG_INHERIT),\n            unres)) {\n        goto error;\n    }\n\n    LOGDBG(LY_LDGYIN, \"parsing %s statement \\\"%s\\\"\", yin->name, retval->name);\n\n    /* insert the node into the schema tree */\n    if (lys_node_addchild(parent, lys_main_module(module), retval, options)) {\n        goto error;\n    }\n\n    /* process list's specific children */\n    LY_TREE_FOR_SAFE(yin->child, next, sub) {\n        if (strcmp(sub->ns->value, LY_NSYIN)) {\n            /* extension */\n            YIN_CHECK_ARRAY_OVERFLOW_GOTO(ctx, c_ext, retval->ext_size, \"extensions\", \"list\", error);\n            c_ext++;\n            continue;\n\n        /* data statements */\n        } else if (!strcmp(sub->name, \"container\") ||\n                !strcmp(sub->name, \"leaf-list\") ||\n                !strcmp(sub->name, \"leaf\") ||\n                !strcmp(sub->name, \"list\") ||\n                !strcmp(sub->name, \"choice\") ||\n                !strcmp(sub->name, \"uses\") ||\n                !strcmp(sub->name, \"grouping\") ||\n                !strcmp(sub->name, \"anyxml\") ||\n                !strcmp(sub->name, \"anydata\") ||\n                !strcmp(sub->name, \"action\") ||\n                !strcmp(sub->name, \"notification\")) {\n            lyxml_unlink_elem(ctx, sub, 2);\n            lyxml_add_child(ctx, &root, sub);\n\n            /* array counters */\n        } else if (!strcmp(sub->name, \"key\")) {\n            /* check cardinality 0..1 */\n            if (list->keys_size) {\n                LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_LYS, retval, sub->name, list->name);\n                goto error;\n            }\n\n            /* count the number of keys */\n            GETVAL(ctx, value, sub, \"value\");\n            list->keys_str = lydict_insert(ctx, value, 0);\n            while ((value = strpbrk(value, \" \\t\\n\"))) {\n                list->keys_size++;\n                while (isspace(*value)) {\n                    value++;\n                }\n            }\n            list->keys_size++;\n            list->keys = calloc(list->keys_size, sizeof *list->keys);\n            LY_CHECK_ERR_GOTO(!list->keys, LOGMEM(ctx), error);\n\n            if (lyp_yin_parse_subnode_ext(module, retval, LYEXT_PAR_NODE, sub, LYEXT_SUBSTMT_KEY, 0, unres)) {\n                goto error;\n            }\n            lyxml_free(ctx, sub);\n        } else if (!strcmp(sub->name, \"unique\")) {\n            YIN_CHECK_ARRAY_OVERFLOW_GOTO(ctx, c_uniq, list->unique_size, \"uniques\", \"list\", error);\n            c_uniq++;\n            lyxml_unlink_elem(ctx, sub, 2);\n            lyxml_add_child(ctx, &uniq, sub);\n        } else if (!strcmp(sub->name, \"typedef\")) {\n            YIN_CHECK_ARRAY_OVERFLOW_GOTO(ctx, c_tpdf, list->tpdf_size, \"typedefs\", \"list\", error);\n            c_tpdf++;\n        } else if (!strcmp(sub->name, \"must\")) {\n            YIN_CHECK_ARRAY_OVERFLOW_GOTO(ctx, c_must, list->must_size, \"musts\", \"list\", error);\n            c_must++;\n        } else if (!strcmp(sub->name, \"if-feature\")) {\n            YIN_CHECK_ARRAY_OVERFLOW_GOTO(ctx, c_ftrs, retval->iffeature_size, \"if-features\", \"list\", error);\n            c_ftrs++;\n\n            /* optional stetments */\n        } else if (!strcmp(sub->name, \"ordered-by\")) {\n            if (f_ordr) {\n                LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_LYS, retval, sub->name, yin->name);\n                goto error;\n            }\n            /* just checking the flags in llist is not sufficient, we would\n             * allow multiple ordered-by statements with the \"system\" value\n             */\n            f_ordr = 1;\n\n            if (list->flags & LYS_CONFIG_R) {\n                /* RFC 6020, 7.7.5 - ignore ordering when the list represents\n                 * state data\n                 */\n                lyxml_free(ctx, sub);\n                continue;\n            }\n\n            GETVAL(ctx, value, sub, \"value\");\n            if (!strcmp(value, \"user\")) {\n                list->flags |= LYS_USERORDERED;\n            } else if (strcmp(value, \"system\")) {\n                LOGVAL(ctx, LYE_INARG, LY_VLOG_LYS, retval, value, sub->name);\n                goto error;\n            } /* else system is the default value, so we can ignore it */\n\n            if (lyp_yin_parse_subnode_ext(module, retval, LYEXT_PAR_NODE, sub, LYEXT_SUBSTMT_ORDEREDBY, 0, unres)) {\n                goto error;\n            }\n            lyxml_free(ctx, sub);\n        } else if (!strcmp(sub->name, \"min-elements\")) {\n            if (f_min) {\n                LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_LYS, retval, sub->name, yin->name);\n                goto error;\n            }\n            f_min = 1;\n\n            GETVAL(ctx, value, sub, \"value\");\n            while (isspace(value[0])) {\n                value++;\n            }\n\n            /* convert it to uint32_t */\n            errno = 0;\n            auxs = NULL;\n            val = strtoul(value, &auxs, 10);\n            if (*auxs || value[0] == '-' || errno || val > UINT32_MAX) {\n                LOGVAL(ctx, LYE_INARG, LY_VLOG_LYS, retval, value, sub->name);\n                goto error;\n            }\n            list->min = (uint32_t) val;\n            if (list->max && (list->min > list->max)) {\n                LOGVAL(ctx, LYE_INARG, LY_VLOG_LYS, retval, value, sub->name);\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, \"\\\"min-elements\\\" is bigger than \\\"max-elements\\\".\");\n                lyxml_free(ctx, sub);\n                goto error;\n            }\n            if (lyp_yin_parse_subnode_ext(module, retval, LYEXT_PAR_NODE, sub, LYEXT_SUBSTMT_MIN, 0, unres)) {\n                goto error;\n            }\n            lyxml_free(ctx, sub);\n        } else if (!strcmp(sub->name, \"max-elements\")) {\n            if (f_max) {\n                LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_LYS, retval, sub->name, yin->name);\n                goto error;\n            }\n            f_max = 1;\n\n            GETVAL(ctx, value, sub, \"value\");\n            while (isspace(value[0])) {\n                value++;\n            }\n\n            if (!strcmp(value, \"unbounded\")) {\n                list->max = 0;;\n            } else {\n                /* convert it to uint32_t */\n                errno = 0;\n                auxs = NULL;\n                val = strtoul(value, &auxs, 10);\n                if (*auxs || value[0] == '-' || errno || val == 0 || val > UINT32_MAX) {\n                    LOGVAL(ctx, LYE_INARG, LY_VLOG_LYS, retval, value, sub->name);\n                    goto error;\n                }\n                list->max = (uint32_t) val;\n                if (list->min > list->max) {\n                    LOGVAL(ctx, LYE_INARG, LY_VLOG_LYS, retval, value, sub->name);\n                    LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, \"\\\"max-elements\\\" is smaller than \\\"min-elements\\\".\");\n                    goto error;\n                }\n            }\n            if (lyp_yin_parse_subnode_ext(module, retval, LYEXT_PAR_NODE, sub, LYEXT_SUBSTMT_MAX, 0, unres)) {\n                goto error;\n            }\n            lyxml_free(ctx, sub);\n        } else if (!strcmp(sub->name, \"when\")) {\n            if (list->when) {\n                LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_LYS, retval, sub->name, yin->name);\n                goto error;\n            }\n\n            list->when = read_yin_when(module, sub, unres);\n            if (!list->when) {\n                lyxml_free(ctx, sub);\n                goto error;\n            }\n            lyxml_free(ctx, sub);\n        } else {\n            LOGVAL(ctx, LYE_INSTMT, LY_VLOG_LYS, retval, sub->name);\n            goto error;\n        }\n    }\n\n    /* check - if list is configuration, key statement is mandatory\n     * (but only if we are not in a grouping or augment, then the check is deferred) */\n    for (node = retval; node && !(node->nodetype & (LYS_GROUPING | LYS_AUGMENT | LYS_EXT)); node = node->parent);\n    if (!node && (list->flags & LYS_CONFIG_W) && !list->keys_str) {\n        LOGVAL(ctx, LYE_MISSCHILDSTMT, LY_VLOG_LYS, retval, \"key\", \"list\");\n        goto error;\n    }\n\n    /* middle part - process nodes with cardinality of 0..n except the data nodes */\n    if (c_tpdf) {\n        list->tpdf = calloc(c_tpdf, sizeof *list->tpdf);\n        LY_CHECK_ERR_GOTO(!list->tpdf, LOGMEM(ctx), error);\n    }\n    if (c_must) {\n        list->must = calloc(c_must, sizeof *list->must);\n        LY_CHECK_ERR_GOTO(!list->must, LOGMEM(ctx), error);\n    }\n    if (c_ftrs) {\n        list->iffeature = calloc(c_ftrs, sizeof *list->iffeature);\n        LY_CHECK_ERR_GOTO(!list->iffeature, LOGMEM(ctx), error);\n    }\n    if (c_ext) {\n        /* some extensions may be already present from the substatements */\n        reallocated = realloc(retval->ext, (c_ext + retval->ext_size) * sizeof *retval->ext);\n        LY_CHECK_ERR_GOTO(!reallocated, LOGMEM(ctx), error);\n        retval->ext = reallocated;\n\n        /* init memory */\n        memset(&retval->ext[retval->ext_size], 0, c_ext * sizeof *retval->ext);\n    }\n\n    LY_TREE_FOR_SAFE(yin->child, next, sub) {\n        if (strcmp(sub->ns->value, LY_NSYIN)) {\n            /* extension */\n            r = lyp_yin_fill_ext(retval, LYEXT_PAR_NODE, 0, 0, module, sub, &retval->ext, &retval->ext_size, unres);\n            if (r) {\n                goto error;\n            }\n        } else if (!strcmp(sub->name, \"typedef\")) {\n            r = fill_yin_typedef(module, retval, sub, &list->tpdf[list->tpdf_size], unres);\n            list->tpdf_size++;\n            if (r) {\n                goto error;\n            }\n        } else if (!strcmp(sub->name, \"if-feature\")) {\n            r = fill_yin_iffeature(retval, 0, sub, &list->iffeature[list->iffeature_size], unres);\n            list->iffeature_size++;\n            if (r) {\n                goto error;\n            }\n        } else if (!strcmp(sub->name, \"must\")) {\n            r = fill_yin_must(module, sub, &list->must[list->must_size], unres);\n            list->must_size++;\n            if (r) {\n                goto error;\n            }\n        }\n    }\n\n    lyp_reduce_ext_list(&retval->ext, retval->ext_size, c_ext + retval->ext_size);\n\n    /* last part - process data nodes */\n    LY_TREE_FOR_SAFE(root.child, next, sub) {\n        if (!strcmp(sub->name, \"container\")) {\n            node = read_yin_container(module, retval, sub, options, unres);\n        } else if (!strcmp(sub->name, \"leaf-list\")) {\n            node = read_yin_leaflist(module, retval, sub, options, unres);\n        } else if (!strcmp(sub->name, \"leaf\")) {\n            node = read_yin_leaf(module, retval, sub, options, unres);\n        } else if (!strcmp(sub->name, \"list\")) {\n            node = read_yin_list(module, retval, sub, options, unres);\n        } else if (!strcmp(sub->name, \"choice\")) {\n            node = read_yin_choice(module, retval, sub, options, unres);\n        } else if (!strcmp(sub->name, \"uses\")) {\n            node = read_yin_uses(module, retval, sub, options, unres);\n        } else if (!strcmp(sub->name, \"grouping\")) {\n            node = read_yin_grouping(module, retval, sub, options, unres);\n        } else if (!strcmp(sub->name, \"anyxml\")) {\n            node = read_yin_anydata(module, retval, sub, LYS_ANYXML, options, unres);\n        } else if (!strcmp(sub->name, \"anydata\")) {\n            node = read_yin_anydata(module, retval, sub, LYS_ANYDATA, options, unres);\n        } else if (!strcmp(sub->name, \"action\")) {\n            node = read_yin_rpc_action(module, retval, sub, options, unres);\n        } else if (!strcmp(sub->name, \"notification\")) {\n            node = read_yin_notif(module, retval, sub, options, unres);\n        } else {\n            LOGINT(ctx);\n            goto error;\n        }\n        if (!node) {\n            goto error;\n        }\n\n        lyxml_free(ctx, sub);\n    }\n\n    if (list->keys_str) {\n        if (unres_schema_add_node(module, unres, list, UNRES_LIST_KEYS, NULL) == -1) {\n            goto error;\n        }\n    } /* else config false list without a key, key_str presence in case of config true is checked earlier */\n\n    /* process unique statements */\n    if (c_uniq) {\n        list->unique = calloc(c_uniq, sizeof *list->unique);\n        LY_CHECK_ERR_GOTO(!list->unique, LOGMEM(ctx), error);\n\n        LY_TREE_FOR_SAFE(uniq.child, next, sub) {\n            r = fill_yin_unique(module, retval, sub, &list->unique[list->unique_size], unres);\n            list->unique_size++;\n            if (r) {\n                goto error;\n            }\n\n            if (lyp_yin_parse_subnode_ext(module, retval, LYEXT_PAR_NODE, sub,\n                                     LYEXT_SUBSTMT_UNIQUE, list->unique_size - 1, unres)) {\n                goto error;\n            }\n            lyxml_free(ctx, sub);\n        }\n    }\n\n    /* check XPath dependencies */\n    if (!(ctx->models.flags & LY_CTX_TRUSTED) && (list->when || list->must)) {\n        if (options & LYS_PARSE_OPT_INGRP) {\n            if (lyxp_node_check_syntax(retval)) {\n                goto error;\n            }\n        } else {\n            if (unres_schema_add_node(module, unres, retval, UNRES_XPATH, NULL) == -1) {\n                goto error;\n            }\n        }\n    }\n\n    for (r = 0; r < retval->ext_size; ++r) {\n        /* set flag, which represent LYEXT_OPT_VALID */\n        if (retval->ext[r] && (retval->ext[r]->flags & LYEXT_OPT_VALID)) {\n            retval->flags |= LYS_VALID_EXT;\n            if (retval->ext[r]->flags & LYEXT_OPT_VALID_SUBTREE) {\n                retval->flags |= LYS_VALID_EXT_SUBTREE;\n                break;\n            }\n        }\n    }\n\n    return retval;\n\nerror:\n\n    lys_node_free(ctx, retval, NULL, 0);\n    while (root.child) {\n        lyxml_free(ctx, root.child);\n    }\n    while (uniq.child) {\n        lyxml_free(ctx, uniq.child);\n    }\n\n    return NULL;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -353,7 +353,7 @@\n \n     for (r = 0; r < retval->ext_size; ++r) {\n         /* set flag, which represent LYEXT_OPT_VALID */\n-        if (retval->ext[r]->flags & LYEXT_OPT_VALID) {\n+        if (retval->ext[r] && (retval->ext[r]->flags & LYEXT_OPT_VALID)) {\n             retval->flags |= LYS_VALID_EXT;\n             if (retval->ext[r]->flags & LYEXT_OPT_VALID_SUBTREE) {\n                 retval->flags |= LYS_VALID_EXT_SUBTREE;",
        "diff_line_info": {
            "deleted_lines": [
                "        if (retval->ext[r]->flags & LYEXT_OPT_VALID) {"
            ],
            "added_lines": [
                "        if (retval->ext[r] && (retval->ext[r]->flags & LYEXT_OPT_VALID)) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-28902",
        "func_name": "CESNET/libyang/read_yin_leaflist",
        "description": "In function read_yin_container() in libyang <= v1.0.225, it doesn't check whether the value of retval->ext[r] is NULL. In some cases, it can be NULL, which leads to the operation of retval->ext[r]->flags that results in a crash.",
        "git_url": "https://github.com/CESNET/libyang/commit/a3917d95d516e3de267d3cfa5d4d3715a90e8777",
        "commit_title": "yin parser BUGFIX invalid memory access",
        "commit_text": " ... in case there were some unresolved extensions. Fixes #1454 Fixes #1455",
        "func_before": "static struct lys_node *\nread_yin_leaflist(struct lys_module *module, struct lys_node *parent, struct lyxml_elem *yin, int options,\n                  struct unres_schema *unres)\n{\n    struct ly_ctx *ctx = module->ctx;\n    struct lys_node *retval;\n    struct lys_node_leaflist *llist;\n    struct lyxml_elem *sub, *next;\n    const char *value;\n    char *endptr;\n    unsigned long val;\n    int r, has_type = 0;\n    int c_must = 0, c_ftrs = 0, c_dflt = 0, c_ext = 0;\n    int f_ordr = 0, f_min = 0, f_max = 0;\n    void *reallocated;\n\n    llist = calloc(1, sizeof *llist);\n    LY_CHECK_ERR_RETURN(!llist, LOGMEM(ctx), NULL);\n\n    llist->nodetype = LYS_LEAFLIST;\n    llist->prev = (struct lys_node *)llist;\n    retval = (struct lys_node *)llist;\n\n    if (read_yin_common(module, parent, retval, LYEXT_PAR_NODE, yin,\n            OPT_IDENT | OPT_MODULE | ((options & LYS_PARSE_OPT_CFG_IGNORE) ? OPT_CFG_IGNORE :\n                (options & LYS_PARSE_OPT_CFG_NOINHERIT) ? OPT_CFG_PARSE : OPT_CFG_PARSE | OPT_CFG_INHERIT),\n            unres)) {\n        goto error;\n    }\n\n    LOGDBG(LY_LDGYIN, \"parsing %s statement \\\"%s\\\"\", yin->name, retval->name);\n\n    /* insert the node into the schema tree */\n    if (lys_node_addchild(parent, lys_main_module(module), retval, options)) {\n        goto error;\n    }\n\n    LY_TREE_FOR_SAFE(yin->child, next, sub) {\n        if (strcmp(sub->ns->value, LY_NSYIN)) {\n            /* extension */\n            YIN_CHECK_ARRAY_OVERFLOW_GOTO(ctx, c_ext, retval->ext_size, \"extensions\", \"leaf-list\", error);\n            c_ext++;\n            continue;\n        } else if (!strcmp(sub->name, \"type\")) {\n            if (has_type) {\n                LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_LYS, retval, sub->name, yin->name);\n                goto error;\n            }\n            /* HACK for unres */\n            llist->type.der = (struct lys_tpdf *)sub;\n            llist->type.parent = (struct lys_tpdf *)llist;\n            /* postpone type resolution when if-feature parsing is done since we need\n             * if-feature for check_leafref_features() */\n            has_type = 1;\n        } else if (!strcmp(sub->name, \"units\")) {\n            if (llist->units) {\n                LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_LYS, retval, sub->name, yin->name);\n                goto error;\n            }\n            GETVAL(ctx, value, sub, \"name\");\n            llist->units = lydict_insert(ctx, value, strlen(value));\n\n            if (lyp_yin_parse_subnode_ext(module, retval, LYEXT_PAR_NODE, sub, LYEXT_SUBSTMT_UNITS, 0, unres)) {\n                goto error;\n            }\n        } else if (!strcmp(sub->name, \"ordered-by\")) {\n            if (f_ordr) {\n                LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_LYS, retval, sub->name, yin->name);\n                goto error;\n            }\n            /* just checking the flags in llist is not sufficient, we would\n             * allow multiple ordered-by statements with the \"system\" value\n             */\n            f_ordr = 1;\n\n            if (llist->flags & LYS_CONFIG_R) {\n                /* RFC 6020, 7.7.5 - ignore ordering when the list represents\n                 * state data\n                 */\n                lyxml_free(ctx, sub);\n                continue;\n            }\n\n            GETVAL(ctx, value, sub, \"value\");\n            if (!strcmp(value, \"user\")) {\n                llist->flags |= LYS_USERORDERED;\n            } else if (strcmp(value, \"system\")) {\n                LOGVAL(ctx, LYE_INARG, LY_VLOG_LYS, retval, value, sub->name);\n                goto error;\n            } /* else system is the default value, so we can ignore it */\n\n            if (lyp_yin_parse_subnode_ext(module, retval, LYEXT_PAR_NODE, sub, LYEXT_SUBSTMT_ORDEREDBY, 0, unres)) {\n                goto error;\n            }\n        } else if (!strcmp(sub->name, \"must\")) {\n            YIN_CHECK_ARRAY_OVERFLOW_GOTO(ctx, c_must, llist->must_size, \"musts\", \"leaf-list\", error);\n            c_must++;\n            continue;\n        } else if (!strcmp(sub->name, \"if-feature\")) {\n            YIN_CHECK_ARRAY_OVERFLOW_GOTO(ctx, c_ftrs, retval->iffeature_size, \"if-features\", \"leaf-list\", error);\n            c_ftrs++;\n            continue;\n        } else if ((module->version >= 2) && !strcmp(sub->name, \"default\")) {\n            /* read the default's extension instances */\n            if (lyp_yin_parse_subnode_ext(module, retval, LYEXT_PAR_NODE, sub, LYEXT_SUBSTMT_DEFAULT, c_dflt, unres)) {\n                goto error;\n            }\n\n            YIN_CHECK_ARRAY_OVERFLOW_GOTO(ctx, c_dflt, llist->dflt_size, \"defaults\", \"leaf-list\", error);\n            c_dflt++;\n            continue;\n\n        } else if (!strcmp(sub->name, \"min-elements\")) {\n            if (f_min) {\n                LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_LYS, retval, sub->name, yin->name);\n                goto error;\n            }\n            f_min = 1;\n\n            GETVAL(ctx, value, sub, \"value\");\n            while (isspace(value[0])) {\n                value++;\n            }\n\n            /* convert it to uint32_t */\n            errno = 0;\n            endptr = NULL;\n            val = strtoul(value, &endptr, 10);\n            if (*endptr || value[0] == '-' || errno || val > UINT32_MAX) {\n                LOGVAL(ctx, LYE_INARG, LY_VLOG_LYS, retval, value, sub->name);\n                goto error;\n            }\n            llist->min = (uint32_t) val;\n            if (llist->max && (llist->min > llist->max)) {\n                LOGVAL(ctx, LYE_INARG, LY_VLOG_LYS, retval, value, sub->name);\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, \"\\\"min-elements\\\" is bigger than \\\"max-elements\\\".\");\n                goto error;\n            }\n\n            if (lyp_yin_parse_subnode_ext(module, retval, LYEXT_PAR_NODE, sub, LYEXT_SUBSTMT_MIN, 0, unres)) {\n                goto error;\n            }\n        } else if (!strcmp(sub->name, \"max-elements\")) {\n            if (f_max) {\n                LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_LYS, retval, sub->name, yin->name);\n                goto error;\n            }\n            f_max = 1;\n\n            GETVAL(ctx, value, sub, \"value\");\n            while (isspace(value[0])) {\n                value++;\n            }\n\n            if (!strcmp(value, \"unbounded\")) {\n                llist->max = 0;\n            } else {\n                /* convert it to uint32_t */\n                errno = 0;\n                endptr = NULL;\n                val = strtoul(value, &endptr, 10);\n                if (*endptr || value[0] == '-' || errno || val == 0 || val > UINT32_MAX) {\n                    LOGVAL(ctx, LYE_INARG, LY_VLOG_LYS, retval, value, sub->name);\n                    goto error;\n                }\n                llist->max = (uint32_t) val;\n                if (llist->min > llist->max) {\n                    LOGVAL(ctx, LYE_INARG, LY_VLOG_LYS, retval, value, sub->name);\n                    LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, \"\\\"max-elements\\\" is smaller than \\\"min-elements\\\".\");\n                    goto error;\n                }\n            }\n\n            if (lyp_yin_parse_subnode_ext(module, retval, LYEXT_PAR_NODE, sub, LYEXT_SUBSTMT_MAX, 0, unres)) {\n                goto error;\n            }\n        } else if (!strcmp(sub->name, \"when\")) {\n            if (llist->when) {\n                LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_LYS, retval, sub->name, yin->name);\n                goto error;\n            }\n\n            llist->when = read_yin_when(module, sub, unres);\n            if (!llist->when) {\n                goto error;\n            }\n        } else {\n            LOGVAL(ctx, LYE_INSTMT, LY_VLOG_LYS, retval, sub->name);\n            goto error;\n        }\n\n        /* do not free sub, it could have been unlinked and stored in unres */\n    }\n\n    /* check constraints */\n    if (!has_type) {\n        LOGVAL(ctx, LYE_MISSCHILDSTMT, LY_VLOG_LYS, retval, \"type\", yin->name);\n        goto error;\n    }\n\n    /* middle part - process nodes with cardinality of 0..n */\n    if (c_must) {\n        llist->must = calloc(c_must, sizeof *llist->must);\n        LY_CHECK_ERR_GOTO(!llist->must, LOGMEM(ctx), error);\n    }\n    if (c_ftrs) {\n        llist->iffeature = calloc(c_ftrs, sizeof *llist->iffeature);\n        LY_CHECK_ERR_GOTO(!llist->iffeature, LOGMEM(ctx), error);\n    }\n    if (c_dflt) {\n        llist->dflt = calloc(c_dflt, sizeof *llist->dflt);\n        LY_CHECK_ERR_GOTO(!llist->dflt, LOGMEM(ctx), error);\n    }\n    if (c_ext) {\n        /* some extensions may be already present from the substatements */\n        reallocated = realloc(retval->ext, (c_ext + retval->ext_size) * sizeof *retval->ext);\n        LY_CHECK_ERR_GOTO(!reallocated, LOGMEM(ctx), error);\n        retval->ext = reallocated;\n\n        /* init memory */\n        memset(&retval->ext[retval->ext_size], 0, c_ext * sizeof *retval->ext);\n    }\n\n    LY_TREE_FOR_SAFE(yin->child, next, sub) {\n        if (strcmp(sub->ns->value, LY_NSYIN)) {\n            /* extension */\n            r = lyp_yin_fill_ext(retval, LYEXT_PAR_NODE, 0, 0, module, sub, &retval->ext, &retval->ext_size, unres);\n            if (r) {\n                goto error;\n            }\n        } else if (!strcmp(sub->name, \"must\")) {\n            r = fill_yin_must(module, sub, &llist->must[llist->must_size], unres);\n            llist->must_size++;\n            if (r) {\n                goto error;\n            }\n        } else if (!strcmp(sub->name, \"if-feature\")) {\n            r = fill_yin_iffeature(retval, 0, sub, &llist->iffeature[llist->iffeature_size], unres);\n            llist->iffeature_size++;\n            if (r) {\n                goto error;\n            }\n        } else if (!strcmp(sub->name, \"default\")) {\n            GETVAL(ctx, value, sub, \"value\");\n\n            /* check for duplicity in case of configuration data,\n             * in case of status data duplicities are allowed */\n            if (llist->flags & LYS_CONFIG_W) {\n                for (r = 0; r < llist->dflt_size; r++) {\n                    if (ly_strequal(llist->dflt[r], value, 1)) {\n                        LOGVAL(ctx, LYE_INARG, LY_VLOG_LYS, retval, value, \"default\");\n                        LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, \"Duplicated default value \\\"%s\\\".\", value);\n                        goto error;\n                    }\n                }\n            }\n            llist->dflt[llist->dflt_size++] = lydict_insert(ctx, value, strlen(value));\n        }\n    }\n\n    lyp_reduce_ext_list(&retval->ext, retval->ext_size, c_ext + retval->ext_size);\n\n    /* finalize type parsing */\n    if (unres_schema_add_node(module, unres, &llist->type, UNRES_TYPE_DER, retval) == -1) {\n        llist->type.der = NULL;\n        goto error;\n    }\n\n    if (llist->dflt_size && llist->min) {\n        LOGVAL(ctx, LYE_INCHILDSTMT, LY_VLOG_LYS, retval, \"min-elements\", \"leaf-list\");\n        LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL,\n               \"The \\\"min-elements\\\" statement with non-zero value is forbidden on leaf-lists with the \\\"default\\\" statement.\");\n        goto error;\n    }\n\n    /* check default value (if not defined, there still could be some restrictions\n     * that need to be checked against a default value from a derived type) */\n    for (r = 0; r < llist->dflt_size; r++) {\n        if (!(ctx->models.flags & LY_CTX_TRUSTED) &&\n                (unres_schema_add_node(module, unres, &llist->type, UNRES_TYPE_DFLT,\n                                       (struct lys_node *)(&llist->dflt[r])) == -1)) {\n            goto error;\n        }\n    }\n\n    /* check XPath dependencies */\n    if (!(ctx->models.flags & LY_CTX_TRUSTED) && (llist->when || llist->must)) {\n        if (options & LYS_PARSE_OPT_INGRP) {\n            if (lyxp_node_check_syntax(retval)) {\n                goto error;\n            }\n        } else {\n            if (unres_schema_add_node(module, unres, retval, UNRES_XPATH, NULL) == -1) {\n                goto error;\n            }\n        }\n    }\n\n    for (r = 0; r < retval->ext_size; ++r) {\n        /* set flag, which represent LYEXT_OPT_VALID */\n        if (retval->ext[r]->flags & LYEXT_OPT_VALID) {\n            retval->flags |= LYS_VALID_EXT;\n            break;\n        }\n    }\n\n    return retval;\n\nerror:\n    lys_node_free(ctx, retval, NULL, 0);\n    return NULL;\n}",
        "func": "static struct lys_node *\nread_yin_leaflist(struct lys_module *module, struct lys_node *parent, struct lyxml_elem *yin, int options,\n                  struct unres_schema *unres)\n{\n    struct ly_ctx *ctx = module->ctx;\n    struct lys_node *retval;\n    struct lys_node_leaflist *llist;\n    struct lyxml_elem *sub, *next;\n    const char *value;\n    char *endptr;\n    unsigned long val;\n    int r, has_type = 0;\n    int c_must = 0, c_ftrs = 0, c_dflt = 0, c_ext = 0;\n    int f_ordr = 0, f_min = 0, f_max = 0;\n    void *reallocated;\n\n    llist = calloc(1, sizeof *llist);\n    LY_CHECK_ERR_RETURN(!llist, LOGMEM(ctx), NULL);\n\n    llist->nodetype = LYS_LEAFLIST;\n    llist->prev = (struct lys_node *)llist;\n    retval = (struct lys_node *)llist;\n\n    if (read_yin_common(module, parent, retval, LYEXT_PAR_NODE, yin,\n            OPT_IDENT | OPT_MODULE | ((options & LYS_PARSE_OPT_CFG_IGNORE) ? OPT_CFG_IGNORE :\n                (options & LYS_PARSE_OPT_CFG_NOINHERIT) ? OPT_CFG_PARSE : OPT_CFG_PARSE | OPT_CFG_INHERIT),\n            unres)) {\n        goto error;\n    }\n\n    LOGDBG(LY_LDGYIN, \"parsing %s statement \\\"%s\\\"\", yin->name, retval->name);\n\n    /* insert the node into the schema tree */\n    if (lys_node_addchild(parent, lys_main_module(module), retval, options)) {\n        goto error;\n    }\n\n    LY_TREE_FOR_SAFE(yin->child, next, sub) {\n        if (strcmp(sub->ns->value, LY_NSYIN)) {\n            /* extension */\n            YIN_CHECK_ARRAY_OVERFLOW_GOTO(ctx, c_ext, retval->ext_size, \"extensions\", \"leaf-list\", error);\n            c_ext++;\n            continue;\n        } else if (!strcmp(sub->name, \"type\")) {\n            if (has_type) {\n                LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_LYS, retval, sub->name, yin->name);\n                goto error;\n            }\n            /* HACK for unres */\n            llist->type.der = (struct lys_tpdf *)sub;\n            llist->type.parent = (struct lys_tpdf *)llist;\n            /* postpone type resolution when if-feature parsing is done since we need\n             * if-feature for check_leafref_features() */\n            has_type = 1;\n        } else if (!strcmp(sub->name, \"units\")) {\n            if (llist->units) {\n                LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_LYS, retval, sub->name, yin->name);\n                goto error;\n            }\n            GETVAL(ctx, value, sub, \"name\");\n            llist->units = lydict_insert(ctx, value, strlen(value));\n\n            if (lyp_yin_parse_subnode_ext(module, retval, LYEXT_PAR_NODE, sub, LYEXT_SUBSTMT_UNITS, 0, unres)) {\n                goto error;\n            }\n        } else if (!strcmp(sub->name, \"ordered-by\")) {\n            if (f_ordr) {\n                LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_LYS, retval, sub->name, yin->name);\n                goto error;\n            }\n            /* just checking the flags in llist is not sufficient, we would\n             * allow multiple ordered-by statements with the \"system\" value\n             */\n            f_ordr = 1;\n\n            if (llist->flags & LYS_CONFIG_R) {\n                /* RFC 6020, 7.7.5 - ignore ordering when the list represents\n                 * state data\n                 */\n                lyxml_free(ctx, sub);\n                continue;\n            }\n\n            GETVAL(ctx, value, sub, \"value\");\n            if (!strcmp(value, \"user\")) {\n                llist->flags |= LYS_USERORDERED;\n            } else if (strcmp(value, \"system\")) {\n                LOGVAL(ctx, LYE_INARG, LY_VLOG_LYS, retval, value, sub->name);\n                goto error;\n            } /* else system is the default value, so we can ignore it */\n\n            if (lyp_yin_parse_subnode_ext(module, retval, LYEXT_PAR_NODE, sub, LYEXT_SUBSTMT_ORDEREDBY, 0, unres)) {\n                goto error;\n            }\n        } else if (!strcmp(sub->name, \"must\")) {\n            YIN_CHECK_ARRAY_OVERFLOW_GOTO(ctx, c_must, llist->must_size, \"musts\", \"leaf-list\", error);\n            c_must++;\n            continue;\n        } else if (!strcmp(sub->name, \"if-feature\")) {\n            YIN_CHECK_ARRAY_OVERFLOW_GOTO(ctx, c_ftrs, retval->iffeature_size, \"if-features\", \"leaf-list\", error);\n            c_ftrs++;\n            continue;\n        } else if ((module->version >= 2) && !strcmp(sub->name, \"default\")) {\n            /* read the default's extension instances */\n            if (lyp_yin_parse_subnode_ext(module, retval, LYEXT_PAR_NODE, sub, LYEXT_SUBSTMT_DEFAULT, c_dflt, unres)) {\n                goto error;\n            }\n\n            YIN_CHECK_ARRAY_OVERFLOW_GOTO(ctx, c_dflt, llist->dflt_size, \"defaults\", \"leaf-list\", error);\n            c_dflt++;\n            continue;\n\n        } else if (!strcmp(sub->name, \"min-elements\")) {\n            if (f_min) {\n                LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_LYS, retval, sub->name, yin->name);\n                goto error;\n            }\n            f_min = 1;\n\n            GETVAL(ctx, value, sub, \"value\");\n            while (isspace(value[0])) {\n                value++;\n            }\n\n            /* convert it to uint32_t */\n            errno = 0;\n            endptr = NULL;\n            val = strtoul(value, &endptr, 10);\n            if (*endptr || value[0] == '-' || errno || val > UINT32_MAX) {\n                LOGVAL(ctx, LYE_INARG, LY_VLOG_LYS, retval, value, sub->name);\n                goto error;\n            }\n            llist->min = (uint32_t) val;\n            if (llist->max && (llist->min > llist->max)) {\n                LOGVAL(ctx, LYE_INARG, LY_VLOG_LYS, retval, value, sub->name);\n                LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, \"\\\"min-elements\\\" is bigger than \\\"max-elements\\\".\");\n                goto error;\n            }\n\n            if (lyp_yin_parse_subnode_ext(module, retval, LYEXT_PAR_NODE, sub, LYEXT_SUBSTMT_MIN, 0, unres)) {\n                goto error;\n            }\n        } else if (!strcmp(sub->name, \"max-elements\")) {\n            if (f_max) {\n                LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_LYS, retval, sub->name, yin->name);\n                goto error;\n            }\n            f_max = 1;\n\n            GETVAL(ctx, value, sub, \"value\");\n            while (isspace(value[0])) {\n                value++;\n            }\n\n            if (!strcmp(value, \"unbounded\")) {\n                llist->max = 0;\n            } else {\n                /* convert it to uint32_t */\n                errno = 0;\n                endptr = NULL;\n                val = strtoul(value, &endptr, 10);\n                if (*endptr || value[0] == '-' || errno || val == 0 || val > UINT32_MAX) {\n                    LOGVAL(ctx, LYE_INARG, LY_VLOG_LYS, retval, value, sub->name);\n                    goto error;\n                }\n                llist->max = (uint32_t) val;\n                if (llist->min > llist->max) {\n                    LOGVAL(ctx, LYE_INARG, LY_VLOG_LYS, retval, value, sub->name);\n                    LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, \"\\\"max-elements\\\" is smaller than \\\"min-elements\\\".\");\n                    goto error;\n                }\n            }\n\n            if (lyp_yin_parse_subnode_ext(module, retval, LYEXT_PAR_NODE, sub, LYEXT_SUBSTMT_MAX, 0, unres)) {\n                goto error;\n            }\n        } else if (!strcmp(sub->name, \"when\")) {\n            if (llist->when) {\n                LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_LYS, retval, sub->name, yin->name);\n                goto error;\n            }\n\n            llist->when = read_yin_when(module, sub, unres);\n            if (!llist->when) {\n                goto error;\n            }\n        } else {\n            LOGVAL(ctx, LYE_INSTMT, LY_VLOG_LYS, retval, sub->name);\n            goto error;\n        }\n\n        /* do not free sub, it could have been unlinked and stored in unres */\n    }\n\n    /* check constraints */\n    if (!has_type) {\n        LOGVAL(ctx, LYE_MISSCHILDSTMT, LY_VLOG_LYS, retval, \"type\", yin->name);\n        goto error;\n    }\n\n    /* middle part - process nodes with cardinality of 0..n */\n    if (c_must) {\n        llist->must = calloc(c_must, sizeof *llist->must);\n        LY_CHECK_ERR_GOTO(!llist->must, LOGMEM(ctx), error);\n    }\n    if (c_ftrs) {\n        llist->iffeature = calloc(c_ftrs, sizeof *llist->iffeature);\n        LY_CHECK_ERR_GOTO(!llist->iffeature, LOGMEM(ctx), error);\n    }\n    if (c_dflt) {\n        llist->dflt = calloc(c_dflt, sizeof *llist->dflt);\n        LY_CHECK_ERR_GOTO(!llist->dflt, LOGMEM(ctx), error);\n    }\n    if (c_ext) {\n        /* some extensions may be already present from the substatements */\n        reallocated = realloc(retval->ext, (c_ext + retval->ext_size) * sizeof *retval->ext);\n        LY_CHECK_ERR_GOTO(!reallocated, LOGMEM(ctx), error);\n        retval->ext = reallocated;\n\n        /* init memory */\n        memset(&retval->ext[retval->ext_size], 0, c_ext * sizeof *retval->ext);\n    }\n\n    LY_TREE_FOR_SAFE(yin->child, next, sub) {\n        if (strcmp(sub->ns->value, LY_NSYIN)) {\n            /* extension */\n            r = lyp_yin_fill_ext(retval, LYEXT_PAR_NODE, 0, 0, module, sub, &retval->ext, &retval->ext_size, unres);\n            if (r) {\n                goto error;\n            }\n        } else if (!strcmp(sub->name, \"must\")) {\n            r = fill_yin_must(module, sub, &llist->must[llist->must_size], unres);\n            llist->must_size++;\n            if (r) {\n                goto error;\n            }\n        } else if (!strcmp(sub->name, \"if-feature\")) {\n            r = fill_yin_iffeature(retval, 0, sub, &llist->iffeature[llist->iffeature_size], unres);\n            llist->iffeature_size++;\n            if (r) {\n                goto error;\n            }\n        } else if (!strcmp(sub->name, \"default\")) {\n            GETVAL(ctx, value, sub, \"value\");\n\n            /* check for duplicity in case of configuration data,\n             * in case of status data duplicities are allowed */\n            if (llist->flags & LYS_CONFIG_W) {\n                for (r = 0; r < llist->dflt_size; r++) {\n                    if (ly_strequal(llist->dflt[r], value, 1)) {\n                        LOGVAL(ctx, LYE_INARG, LY_VLOG_LYS, retval, value, \"default\");\n                        LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL, \"Duplicated default value \\\"%s\\\".\", value);\n                        goto error;\n                    }\n                }\n            }\n            llist->dflt[llist->dflt_size++] = lydict_insert(ctx, value, strlen(value));\n        }\n    }\n\n    lyp_reduce_ext_list(&retval->ext, retval->ext_size, c_ext + retval->ext_size);\n\n    /* finalize type parsing */\n    if (unres_schema_add_node(module, unres, &llist->type, UNRES_TYPE_DER, retval) == -1) {\n        llist->type.der = NULL;\n        goto error;\n    }\n\n    if (llist->dflt_size && llist->min) {\n        LOGVAL(ctx, LYE_INCHILDSTMT, LY_VLOG_LYS, retval, \"min-elements\", \"leaf-list\");\n        LOGVAL(ctx, LYE_SPEC, LY_VLOG_PREV, NULL,\n               \"The \\\"min-elements\\\" statement with non-zero value is forbidden on leaf-lists with the \\\"default\\\" statement.\");\n        goto error;\n    }\n\n    /* check default value (if not defined, there still could be some restrictions\n     * that need to be checked against a default value from a derived type) */\n    for (r = 0; r < llist->dflt_size; r++) {\n        if (!(ctx->models.flags & LY_CTX_TRUSTED) &&\n                (unres_schema_add_node(module, unres, &llist->type, UNRES_TYPE_DFLT,\n                                       (struct lys_node *)(&llist->dflt[r])) == -1)) {\n            goto error;\n        }\n    }\n\n    /* check XPath dependencies */\n    if (!(ctx->models.flags & LY_CTX_TRUSTED) && (llist->when || llist->must)) {\n        if (options & LYS_PARSE_OPT_INGRP) {\n            if (lyxp_node_check_syntax(retval)) {\n                goto error;\n            }\n        } else {\n            if (unres_schema_add_node(module, unres, retval, UNRES_XPATH, NULL) == -1) {\n                goto error;\n            }\n        }\n    }\n\n    for (r = 0; r < retval->ext_size; ++r) {\n        /* set flag, which represent LYEXT_OPT_VALID */\n        if (retval->ext[r] && (retval->ext[r]->flags & LYEXT_OPT_VALID)) {\n            retval->flags |= LYS_VALID_EXT;\n            break;\n        }\n    }\n\n    return retval;\n\nerror:\n    lys_node_free(ctx, retval, NULL, 0);\n    return NULL;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -298,7 +298,7 @@\n \n     for (r = 0; r < retval->ext_size; ++r) {\n         /* set flag, which represent LYEXT_OPT_VALID */\n-        if (retval->ext[r]->flags & LYEXT_OPT_VALID) {\n+        if (retval->ext[r] && (retval->ext[r]->flags & LYEXT_OPT_VALID)) {\n             retval->flags |= LYS_VALID_EXT;\n             break;\n         }",
        "diff_line_info": {
            "deleted_lines": [
                "        if (retval->ext[r]->flags & LYEXT_OPT_VALID) {"
            ],
            "added_lines": [
                "        if (retval->ext[r] && (retval->ext[r]->flags & LYEXT_OPT_VALID)) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-28902",
        "func_name": "CESNET/libyang/read_yin_container",
        "description": "In function read_yin_container() in libyang <= v1.0.225, it doesn't check whether the value of retval->ext[r] is NULL. In some cases, it can be NULL, which leads to the operation of retval->ext[r]->flags that results in a crash.",
        "git_url": "https://github.com/CESNET/libyang/commit/a3917d95d516e3de267d3cfa5d4d3715a90e8777",
        "commit_title": "yin parser BUGFIX invalid memory access",
        "commit_text": " ... in case there were some unresolved extensions. Fixes #1454 Fixes #1455",
        "func_before": "static struct lys_node *\nread_yin_container(struct lys_module *module, struct lys_node *parent, struct lyxml_elem *yin, int options,\n                   struct unres_schema *unres)\n{\n    struct ly_ctx *ctx = module->ctx;\n    struct lyxml_elem *sub, *next, root;\n    struct lys_node *node = NULL;\n    struct lys_node *retval;\n    struct lys_node_container *cont;\n    const char *value;\n    void *reallocated;\n    int r;\n    int c_tpdf = 0, c_must = 0, c_ftrs = 0, c_ext = 0;\n\n    /* init */\n    memset(&root, 0, sizeof root);\n\n    cont = calloc(1, sizeof *cont);\n    LY_CHECK_ERR_RETURN(!cont, LOGMEM(ctx), NULL);\n\n    cont->nodetype = LYS_CONTAINER;\n    cont->prev = (struct lys_node *)cont;\n    retval = (struct lys_node *)cont;\n\n    if (read_yin_common(module, parent, retval, LYEXT_PAR_NODE, yin,\n            OPT_IDENT | OPT_MODULE | ((options & LYS_PARSE_OPT_CFG_IGNORE) ? OPT_CFG_IGNORE :\n                (options & LYS_PARSE_OPT_CFG_NOINHERIT) ? OPT_CFG_PARSE : OPT_CFG_PARSE | OPT_CFG_INHERIT),\n            unres)) {\n        goto error;\n    }\n\n    LOGDBG(LY_LDGYIN, \"parsing %s statement \\\"%s\\\"\", yin->name, retval->name);\n\n    /* insert the node into the schema tree */\n    if (lys_node_addchild(parent, lys_main_module(module), retval, options)) {\n        goto error;\n    }\n\n    /* process container's specific children */\n    LY_TREE_FOR_SAFE(yin->child, next, sub) {\n        if (strcmp(sub->ns->value, LY_NSYIN)) {\n            /* extension */\n            YIN_CHECK_ARRAY_OVERFLOW_GOTO(ctx, c_ext, retval->ext_size, \"extensions\", \"container\", error);\n            c_ext++;\n        } else if (!strcmp(sub->name, \"presence\")) {\n            if (cont->presence) {\n                LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_LYS, retval, sub->name, yin->name);\n                goto error;\n            }\n            GETVAL(ctx, value, sub, \"value\");\n            cont->presence = lydict_insert(ctx, value, strlen(value));\n\n            if (lyp_yin_parse_subnode_ext(module, retval, LYEXT_PAR_NODE, sub, LYEXT_SUBSTMT_PRESENCE, 0, unres)) {\n                goto error;\n            }\n            lyxml_free(ctx, sub);\n        } else if (!strcmp(sub->name, \"when\")) {\n            if (cont->when) {\n                LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_LYS, retval, sub->name, yin->name);\n                goto error;\n            }\n\n            cont->when = read_yin_when(module, sub, unres);\n            if (!cont->when) {\n                lyxml_free(ctx, sub);\n                goto error;\n            }\n            lyxml_free(ctx, sub);\n\n            /* data statements */\n        } else if (!strcmp(sub->name, \"container\") ||\n                !strcmp(sub->name, \"leaf-list\") ||\n                !strcmp(sub->name, \"leaf\") ||\n                !strcmp(sub->name, \"list\") ||\n                !strcmp(sub->name, \"choice\") ||\n                !strcmp(sub->name, \"uses\") ||\n                !strcmp(sub->name, \"grouping\") ||\n                !strcmp(sub->name, \"anyxml\") ||\n                !strcmp(sub->name, \"anydata\") ||\n                !strcmp(sub->name, \"action\") ||\n                !strcmp(sub->name, \"notification\")) {\n            lyxml_unlink_elem(ctx, sub, 2);\n            lyxml_add_child(ctx, &root, sub);\n\n            /* array counters */\n        } else if (!strcmp(sub->name, \"typedef\")) {\n            YIN_CHECK_ARRAY_OVERFLOW_GOTO(ctx, c_tpdf, cont->tpdf_size, \"typedefs\", \"container\", error);\n            c_tpdf++;\n        } else if (!strcmp(sub->name, \"must\")) {\n            YIN_CHECK_ARRAY_OVERFLOW_GOTO(ctx, c_must, cont->must_size, \"musts\", \"container\", error);\n            c_must++;\n        } else if (!strcmp(sub->name, \"if-feature\")) {\n            YIN_CHECK_ARRAY_OVERFLOW_GOTO(ctx, c_ftrs, retval->iffeature_size, \"if-features\", \"container\", error);\n            c_ftrs++;\n        } else {\n            LOGVAL(ctx, LYE_INSTMT, LY_VLOG_LYS, retval, sub->name);\n            goto error;\n        }\n    }\n\n    /* middle part - process nodes with cardinality of 0..n except the data nodes */\n    if (c_tpdf) {\n        cont->tpdf = calloc(c_tpdf, sizeof *cont->tpdf);\n        LY_CHECK_ERR_GOTO(!cont->tpdf, LOGMEM(ctx), error);\n    }\n    if (c_must) {\n        cont->must = calloc(c_must, sizeof *cont->must);\n        LY_CHECK_ERR_GOTO(!cont->must, LOGMEM(ctx), error);\n    }\n    if (c_ftrs) {\n        cont->iffeature = calloc(c_ftrs, sizeof *cont->iffeature);\n        LY_CHECK_ERR_GOTO(!cont->iffeature, LOGMEM(ctx), error);\n    }\n    if (c_ext) {\n        /* some extensions may be already present from the substatements */\n        reallocated = realloc(retval->ext, (c_ext + retval->ext_size) * sizeof *retval->ext);\n        LY_CHECK_ERR_GOTO(!reallocated, LOGMEM(ctx), error);\n        retval->ext = reallocated;\n\n        /* init memory */\n        memset(&retval->ext[retval->ext_size], 0, c_ext * sizeof *retval->ext);\n    }\n\n    LY_TREE_FOR_SAFE(yin->child, next, sub) {\n        if (strcmp(sub->ns->value, LY_NSYIN)) {\n            /* extension */\n            r = lyp_yin_fill_ext(retval, LYEXT_PAR_NODE, 0, 0, module, sub, &retval->ext, &retval->ext_size, unres);\n            if (r) {\n                goto error;\n            }\n        } else if (!strcmp(sub->name, \"typedef\")) {\n            r = fill_yin_typedef(module, retval, sub, &cont->tpdf[cont->tpdf_size], unres);\n            cont->tpdf_size++;\n            if (r) {\n                goto error;\n            }\n        } else if (!strcmp(sub->name, \"must\")) {\n            r = fill_yin_must(module, sub, &cont->must[cont->must_size], unres);\n            cont->must_size++;\n            if (r) {\n                goto error;\n            }\n        } else if (!strcmp(sub->name, \"if-feature\")) {\n            r = fill_yin_iffeature(retval, 0, sub, &cont->iffeature[cont->iffeature_size], unres);\n            cont->iffeature_size++;\n            if (r) {\n                goto error;\n            }\n        }\n    }\n\n    lyp_reduce_ext_list(&retval->ext, retval->ext_size, c_ext + retval->ext_size);\n\n    /* last part - process data nodes */\n    LY_TREE_FOR_SAFE(root.child, next, sub) {\n        if (!strcmp(sub->name, \"container\")) {\n            node = read_yin_container(module, retval, sub, options, unres);\n        } else if (!strcmp(sub->name, \"leaf-list\")) {\n            node = read_yin_leaflist(module, retval, sub, options, unres);\n        } else if (!strcmp(sub->name, \"leaf\")) {\n            node = read_yin_leaf(module, retval, sub, options, unres);\n        } else if (!strcmp(sub->name, \"list\")) {\n            node = read_yin_list(module, retval, sub, options, unres);\n        } else if (!strcmp(sub->name, \"choice\")) {\n            node = read_yin_choice(module, retval, sub, options, unres);\n        } else if (!strcmp(sub->name, \"uses\")) {\n            node = read_yin_uses(module, retval, sub, options, unres);\n        } else if (!strcmp(sub->name, \"grouping\")) {\n            node = read_yin_grouping(module, retval, sub, options, unres);\n        } else if (!strcmp(sub->name, \"anyxml\")) {\n            node = read_yin_anydata(module, retval, sub, LYS_ANYXML, options, unres);\n        } else if (!strcmp(sub->name, \"anydata\")) {\n            node = read_yin_anydata(module, retval, sub, LYS_ANYDATA, options, unres);\n        } else if (!strcmp(sub->name, \"action\")) {\n            node = read_yin_rpc_action(module, retval, sub, options, unres);\n        } else if (!strcmp(sub->name, \"notification\")) {\n            node = read_yin_notif(module, retval, sub, options, unres);\n        }\n        if (!node) {\n            goto error;\n        }\n\n        lyxml_free(ctx, sub);\n    }\n\n    /* check XPath dependencies */\n    if (!(ctx->models.flags & LY_CTX_TRUSTED) && (cont->when || cont->must)) {\n        if (options & LYS_PARSE_OPT_INGRP) {\n            if (lyxp_node_check_syntax(retval)) {\n                goto error;\n            }\n        } else {\n            if (unres_schema_add_node(module, unres, retval, UNRES_XPATH, NULL) == -1) {\n                goto error;\n            }\n        }\n    }\n\n    for (r = 0; r < retval->ext_size; ++r) {\n        /* set flag, which represent LYEXT_OPT_VALID */\n        if (retval->ext[r]->flags & LYEXT_OPT_VALID) {\n            retval->flags |= LYS_VALID_EXT;\n            if (retval->ext[r]->flags & LYEXT_OPT_VALID_SUBTREE) {\n                retval->flags |= LYS_VALID_EXT_SUBTREE;\n                break;\n            }\n        }\n    }\n\n    return retval;\n\nerror:\n    lys_node_free(ctx, retval, NULL, 0);\n    while (root.child) {\n        lyxml_free(ctx, root.child);\n    }\n    return NULL;\n}",
        "func": "static struct lys_node *\nread_yin_container(struct lys_module *module, struct lys_node *parent, struct lyxml_elem *yin, int options,\n                   struct unres_schema *unres)\n{\n    struct ly_ctx *ctx = module->ctx;\n    struct lyxml_elem *sub, *next, root;\n    struct lys_node *node = NULL;\n    struct lys_node *retval;\n    struct lys_node_container *cont;\n    const char *value;\n    void *reallocated;\n    int r;\n    int c_tpdf = 0, c_must = 0, c_ftrs = 0, c_ext = 0;\n\n    /* init */\n    memset(&root, 0, sizeof root);\n\n    cont = calloc(1, sizeof *cont);\n    LY_CHECK_ERR_RETURN(!cont, LOGMEM(ctx), NULL);\n\n    cont->nodetype = LYS_CONTAINER;\n    cont->prev = (struct lys_node *)cont;\n    retval = (struct lys_node *)cont;\n\n    if (read_yin_common(module, parent, retval, LYEXT_PAR_NODE, yin,\n            OPT_IDENT | OPT_MODULE | ((options & LYS_PARSE_OPT_CFG_IGNORE) ? OPT_CFG_IGNORE :\n                (options & LYS_PARSE_OPT_CFG_NOINHERIT) ? OPT_CFG_PARSE : OPT_CFG_PARSE | OPT_CFG_INHERIT),\n            unres)) {\n        goto error;\n    }\n\n    LOGDBG(LY_LDGYIN, \"parsing %s statement \\\"%s\\\"\", yin->name, retval->name);\n\n    /* insert the node into the schema tree */\n    if (lys_node_addchild(parent, lys_main_module(module), retval, options)) {\n        goto error;\n    }\n\n    /* process container's specific children */\n    LY_TREE_FOR_SAFE(yin->child, next, sub) {\n        if (strcmp(sub->ns->value, LY_NSYIN)) {\n            /* extension */\n            YIN_CHECK_ARRAY_OVERFLOW_GOTO(ctx, c_ext, retval->ext_size, \"extensions\", \"container\", error);\n            c_ext++;\n        } else if (!strcmp(sub->name, \"presence\")) {\n            if (cont->presence) {\n                LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_LYS, retval, sub->name, yin->name);\n                goto error;\n            }\n            GETVAL(ctx, value, sub, \"value\");\n            cont->presence = lydict_insert(ctx, value, strlen(value));\n\n            if (lyp_yin_parse_subnode_ext(module, retval, LYEXT_PAR_NODE, sub, LYEXT_SUBSTMT_PRESENCE, 0, unres)) {\n                goto error;\n            }\n            lyxml_free(ctx, sub);\n        } else if (!strcmp(sub->name, \"when\")) {\n            if (cont->when) {\n                LOGVAL(ctx, LYE_TOOMANY, LY_VLOG_LYS, retval, sub->name, yin->name);\n                goto error;\n            }\n\n            cont->when = read_yin_when(module, sub, unres);\n            if (!cont->when) {\n                lyxml_free(ctx, sub);\n                goto error;\n            }\n            lyxml_free(ctx, sub);\n\n            /* data statements */\n        } else if (!strcmp(sub->name, \"container\") ||\n                !strcmp(sub->name, \"leaf-list\") ||\n                !strcmp(sub->name, \"leaf\") ||\n                !strcmp(sub->name, \"list\") ||\n                !strcmp(sub->name, \"choice\") ||\n                !strcmp(sub->name, \"uses\") ||\n                !strcmp(sub->name, \"grouping\") ||\n                !strcmp(sub->name, \"anyxml\") ||\n                !strcmp(sub->name, \"anydata\") ||\n                !strcmp(sub->name, \"action\") ||\n                !strcmp(sub->name, \"notification\")) {\n            lyxml_unlink_elem(ctx, sub, 2);\n            lyxml_add_child(ctx, &root, sub);\n\n            /* array counters */\n        } else if (!strcmp(sub->name, \"typedef\")) {\n            YIN_CHECK_ARRAY_OVERFLOW_GOTO(ctx, c_tpdf, cont->tpdf_size, \"typedefs\", \"container\", error);\n            c_tpdf++;\n        } else if (!strcmp(sub->name, \"must\")) {\n            YIN_CHECK_ARRAY_OVERFLOW_GOTO(ctx, c_must, cont->must_size, \"musts\", \"container\", error);\n            c_must++;\n        } else if (!strcmp(sub->name, \"if-feature\")) {\n            YIN_CHECK_ARRAY_OVERFLOW_GOTO(ctx, c_ftrs, retval->iffeature_size, \"if-features\", \"container\", error);\n            c_ftrs++;\n        } else {\n            LOGVAL(ctx, LYE_INSTMT, LY_VLOG_LYS, retval, sub->name);\n            goto error;\n        }\n    }\n\n    /* middle part - process nodes with cardinality of 0..n except the data nodes */\n    if (c_tpdf) {\n        cont->tpdf = calloc(c_tpdf, sizeof *cont->tpdf);\n        LY_CHECK_ERR_GOTO(!cont->tpdf, LOGMEM(ctx), error);\n    }\n    if (c_must) {\n        cont->must = calloc(c_must, sizeof *cont->must);\n        LY_CHECK_ERR_GOTO(!cont->must, LOGMEM(ctx), error);\n    }\n    if (c_ftrs) {\n        cont->iffeature = calloc(c_ftrs, sizeof *cont->iffeature);\n        LY_CHECK_ERR_GOTO(!cont->iffeature, LOGMEM(ctx), error);\n    }\n    if (c_ext) {\n        /* some extensions may be already present from the substatements */\n        reallocated = realloc(retval->ext, (c_ext + retval->ext_size) * sizeof *retval->ext);\n        LY_CHECK_ERR_GOTO(!reallocated, LOGMEM(ctx), error);\n        retval->ext = reallocated;\n\n        /* init memory */\n        memset(&retval->ext[retval->ext_size], 0, c_ext * sizeof *retval->ext);\n    }\n\n    LY_TREE_FOR_SAFE(yin->child, next, sub) {\n        if (strcmp(sub->ns->value, LY_NSYIN)) {\n            /* extension */\n            r = lyp_yin_fill_ext(retval, LYEXT_PAR_NODE, 0, 0, module, sub, &retval->ext, &retval->ext_size, unres);\n            if (r) {\n                goto error;\n            }\n        } else if (!strcmp(sub->name, \"typedef\")) {\n            r = fill_yin_typedef(module, retval, sub, &cont->tpdf[cont->tpdf_size], unres);\n            cont->tpdf_size++;\n            if (r) {\n                goto error;\n            }\n        } else if (!strcmp(sub->name, \"must\")) {\n            r = fill_yin_must(module, sub, &cont->must[cont->must_size], unres);\n            cont->must_size++;\n            if (r) {\n                goto error;\n            }\n        } else if (!strcmp(sub->name, \"if-feature\")) {\n            r = fill_yin_iffeature(retval, 0, sub, &cont->iffeature[cont->iffeature_size], unres);\n            cont->iffeature_size++;\n            if (r) {\n                goto error;\n            }\n        }\n    }\n\n    lyp_reduce_ext_list(&retval->ext, retval->ext_size, c_ext + retval->ext_size);\n\n    /* last part - process data nodes */\n    LY_TREE_FOR_SAFE(root.child, next, sub) {\n        if (!strcmp(sub->name, \"container\")) {\n            node = read_yin_container(module, retval, sub, options, unres);\n        } else if (!strcmp(sub->name, \"leaf-list\")) {\n            node = read_yin_leaflist(module, retval, sub, options, unres);\n        } else if (!strcmp(sub->name, \"leaf\")) {\n            node = read_yin_leaf(module, retval, sub, options, unres);\n        } else if (!strcmp(sub->name, \"list\")) {\n            node = read_yin_list(module, retval, sub, options, unres);\n        } else if (!strcmp(sub->name, \"choice\")) {\n            node = read_yin_choice(module, retval, sub, options, unres);\n        } else if (!strcmp(sub->name, \"uses\")) {\n            node = read_yin_uses(module, retval, sub, options, unres);\n        } else if (!strcmp(sub->name, \"grouping\")) {\n            node = read_yin_grouping(module, retval, sub, options, unres);\n        } else if (!strcmp(sub->name, \"anyxml\")) {\n            node = read_yin_anydata(module, retval, sub, LYS_ANYXML, options, unres);\n        } else if (!strcmp(sub->name, \"anydata\")) {\n            node = read_yin_anydata(module, retval, sub, LYS_ANYDATA, options, unres);\n        } else if (!strcmp(sub->name, \"action\")) {\n            node = read_yin_rpc_action(module, retval, sub, options, unres);\n        } else if (!strcmp(sub->name, \"notification\")) {\n            node = read_yin_notif(module, retval, sub, options, unres);\n        }\n        if (!node) {\n            goto error;\n        }\n\n        lyxml_free(ctx, sub);\n    }\n\n    /* check XPath dependencies */\n    if (!(ctx->models.flags & LY_CTX_TRUSTED) && (cont->when || cont->must)) {\n        if (options & LYS_PARSE_OPT_INGRP) {\n            if (lyxp_node_check_syntax(retval)) {\n                goto error;\n            }\n        } else {\n            if (unres_schema_add_node(module, unres, retval, UNRES_XPATH, NULL) == -1) {\n                goto error;\n            }\n        }\n    }\n\n    for (r = 0; r < retval->ext_size; ++r) {\n        /* extension instance may not yet be resolved */\n        if (retval->ext[r] && (retval->ext[r]->flags & LYEXT_OPT_VALID)) {\n             /* set flag, which represent LYEXT_OPT_VALID */\n            retval->flags |= LYS_VALID_EXT;\n            if (retval->ext[r]->flags & LYEXT_OPT_VALID_SUBTREE) {\n                retval->flags |= LYS_VALID_EXT_SUBTREE;\n                break;\n            }\n        }\n    }\n\n    return retval;\n\nerror:\n    lys_node_free(ctx, retval, NULL, 0);\n    while (root.child) {\n        lyxml_free(ctx, root.child);\n    }\n    return NULL;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -197,8 +197,9 @@\n     }\n \n     for (r = 0; r < retval->ext_size; ++r) {\n-        /* set flag, which represent LYEXT_OPT_VALID */\n-        if (retval->ext[r]->flags & LYEXT_OPT_VALID) {\n+        /* extension instance may not yet be resolved */\n+        if (retval->ext[r] && (retval->ext[r]->flags & LYEXT_OPT_VALID)) {\n+             /* set flag, which represent LYEXT_OPT_VALID */\n             retval->flags |= LYS_VALID_EXT;\n             if (retval->ext[r]->flags & LYEXT_OPT_VALID_SUBTREE) {\n                 retval->flags |= LYS_VALID_EXT_SUBTREE;",
        "diff_line_info": {
            "deleted_lines": [
                "        /* set flag, which represent LYEXT_OPT_VALID */",
                "        if (retval->ext[r]->flags & LYEXT_OPT_VALID) {"
            ],
            "added_lines": [
                "        /* extension instance may not yet be resolved */",
                "        if (retval->ext[r] && (retval->ext[r]->flags & LYEXT_OPT_VALID)) {",
                "             /* set flag, which represent LYEXT_OPT_VALID */"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-28904",
        "func_name": "CESNET/libyang/ext_get_plugin",
        "description": "In function ext_get_plugin() in libyang <= v1.0.225, it doesn't check whether the value of revision is NULL. If revision is NULL, the operation of strcmp(revision, ext_plugins[u].revision) will lead to a crash.",
        "git_url": "https://github.com/CESNET/libyang/commit/59a0bff1a5a2f0a0eac07e4bf94d4aea9dd3708d",
        "commit_title": "plugins BUGFIX handle empty revision correctly",
        "commit_text": " Fixes #1451",
        "func_before": "struct lyext_plugin *\next_get_plugin(const char *name, const char *module, const char *revision)\n{\n    uint16_t u;\n\n    assert(name);\n    assert(module);\n\n    for (u = 0; u < ext_plugins_count; u++) {\n        if (!strcmp(name, ext_plugins[u].name) &&\n                !strcmp(module, ext_plugins[u].module) &&\n                (!ext_plugins[u].revision || !strcmp(revision, ext_plugins[u].revision))) {\n            /* we have the match */\n            return ext_plugins[u].plugin;\n        }\n    }\n\n    /* plugin not found */\n    return NULL;\n}",
        "func": "struct lyext_plugin *\next_get_plugin(const char *name, const char *module, const char *revision)\n{\n    uint16_t u;\n\n    assert(name);\n    assert(module);\n\n    for (u = 0; u < ext_plugins_count; u++) {\n        if (!strcmp(name, ext_plugins[u].name) && !strcmp(module, ext_plugins[u].module) &&\n                ((!revision && !ext_plugins[u].revision) || (revision && !strcmp(revision, ext_plugins[u].revision)))) {\n            /* we have the match */\n            return ext_plugins[u].plugin;\n        }\n    }\n\n    /* plugin not found */\n    return NULL;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -7,9 +7,8 @@\n     assert(module);\n \n     for (u = 0; u < ext_plugins_count; u++) {\n-        if (!strcmp(name, ext_plugins[u].name) &&\n-                !strcmp(module, ext_plugins[u].module) &&\n-                (!ext_plugins[u].revision || !strcmp(revision, ext_plugins[u].revision))) {\n+        if (!strcmp(name, ext_plugins[u].name) && !strcmp(module, ext_plugins[u].module) &&\n+                ((!revision && !ext_plugins[u].revision) || (revision && !strcmp(revision, ext_plugins[u].revision)))) {\n             /* we have the match */\n             return ext_plugins[u].plugin;\n         }",
        "diff_line_info": {
            "deleted_lines": [
                "        if (!strcmp(name, ext_plugins[u].name) &&",
                "                !strcmp(module, ext_plugins[u].module) &&",
                "                (!ext_plugins[u].revision || !strcmp(revision, ext_plugins[u].revision))) {"
            ],
            "added_lines": [
                "        if (!strcmp(name, ext_plugins[u].name) && !strcmp(module, ext_plugins[u].module) &&",
                "                ((!revision && !ext_plugins[u].revision) || (revision && !strcmp(revision, ext_plugins[u].revision)))) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-23003",
        "func_name": "torvalds/linux/expr__ctx_new",
        "description": "In the Linux kernel before 5.16, tools/perf/util/expr.c lacks a check for the hashmap__new return value.",
        "git_url": "https://github.com/torvalds/linux/commit/0a515a06c5ebfa46fee3ac519e418f801e718da4",
        "commit_title": "perf expr: Fix missing check for return value of hashmap__new()",
        "commit_text": " The hashmap__new() function may return ERR_PTR(-ENOMEM) when malloc() fails, add IS_ERR() checking for ctx->ids.  Cc: Alexander Shishkin <alexander.shishkin@linux.intel.com> Cc: Andi Kleen <ak@linux.intel.com> Cc: Ian Rogers <irogers@google.com> Cc: Jiri Olsa <jolsa@redhat.com> Cc: Mark Rutland <mark.rutland@arm.com> Cc: Namhyung Kim <namhyung@kernel.org> Cc: Peter Zijlstra <peterz@infradead.org> Link: http://lore.kernel.org/lkml/20211212062504.25841-1-linmq006@gmail.com [ s/kfree()/free()/ and add missing linux/err.h include ]",
        "func_before": "struct expr_parse_ctx *expr__ctx_new(void)\n{\n\tstruct expr_parse_ctx *ctx;\n\n\tctx = malloc(sizeof(struct expr_parse_ctx));\n\tif (!ctx)\n\t\treturn NULL;\n\n\tctx->ids = hashmap__new(key_hash, key_equal, NULL);\n\tctx->runtime = 0;\n\n\treturn ctx;\n}",
        "func": "struct expr_parse_ctx *expr__ctx_new(void)\n{\n\tstruct expr_parse_ctx *ctx;\n\n\tctx = malloc(sizeof(struct expr_parse_ctx));\n\tif (!ctx)\n\t\treturn NULL;\n\n\tctx->ids = hashmap__new(key_hash, key_equal, NULL);\n\tif (IS_ERR(ctx->ids)) {\n\t\tfree(ctx);\n\t\treturn NULL;\n\t}\n\tctx->runtime = 0;\n\n\treturn ctx;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -7,6 +7,10 @@\n \t\treturn NULL;\n \n \tctx->ids = hashmap__new(key_hash, key_equal, NULL);\n+\tif (IS_ERR(ctx->ids)) {\n+\t\tfree(ctx);\n+\t\treturn NULL;\n+\t}\n \tctx->runtime = 0;\n \n \treturn ctx;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tif (IS_ERR(ctx->ids)) {",
                "\t\tfree(ctx);",
                "\t\treturn NULL;",
                "\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-10060",
        "func_name": "ImageMagick/ConcatenateImages",
        "description": "The ConcatenateImages function in MagickWand/magick-cli.c in ImageMagick before 7.0.1-10 does not check the return value of the fputc function, which allows remote attackers to cause a denial of service (application crash) via a crafted file.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/933e96f01a8c889c7bf5ffd30020e86a02a046e7",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/196",
        "commit_text": "",
        "func_before": "static MagickBooleanType ConcatenateImages(int argc,char **argv,\n     ExceptionInfo *exception )\n{\n  FILE\n    *input,\n    *output;\n\n  int\n    c;\n\n  register ssize_t\n    i;\n\n  if (ExpandFilenames(&argc,&argv) == MagickFalse)\n    ThrowFileException(exception,ResourceLimitError,\"MemoryAllocationFailed\",\n         GetExceptionMessage(errno));\n\n  output=fopen_utf8(argv[argc-1],\"wb\");\n  if (output == (FILE *) NULL) {\n    ThrowFileException(exception,FileOpenError,\"UnableToOpenFile\",argv[argc-1]);\n    return(MagickFalse);\n  }\n  for (i=2; i < (ssize_t) (argc-1); i++) {\n#if 0\n    fprintf(stderr, \"DEBUG: Concatenate Image: \\\"%s\\\"\\n\", argv[i]);\n#endif\n    input=fopen_utf8(argv[i],\"rb\");\n    if (input == (FILE *) NULL) {\n        ThrowFileException(exception,FileOpenError,\"UnableToOpenFile\",argv[i]);\n        continue;\n      }\n    for (c=fgetc(input); c != EOF; c=fgetc(input))\n      (void) fputc((char) c,output);\n    (void) fclose(input);\n    (void) remove_utf8(argv[i]);\n  }\n  (void) fclose(output);\n  return(MagickTrue);\n}",
        "func": "static MagickBooleanType ConcatenateImages(int argc,char **argv,\n  ExceptionInfo *exception )\n{\n  FILE\n    *input,\n    *output;\n\n  MagickBooleanType\n    status;\n\n  int\n    c;\n\n  register ssize_t\n    i;\n\n  if (ExpandFilenames(&argc,&argv) == MagickFalse)\n    ThrowFileException(exception,ResourceLimitError,\"MemoryAllocationFailed\",\n      GetExceptionMessage(errno));\n  output=fopen_utf8(argv[argc-1],\"wb\");\n  if (output == (FILE *) NULL)\n    {\n      ThrowFileException(exception,FileOpenError,\"UnableToOpenFile\",\n        argv[argc-1]);\n      return(MagickFalse);\n    }\n  status=MagickTrue;\n  for (i=2; i < (ssize_t) (argc-1); i++)\n  {\n    input=fopen_utf8(argv[i],\"rb\");\n    if (input == (FILE *) NULL)\n      {\n        ThrowFileException(exception,FileOpenError,\"UnableToOpenFile\",argv[i]);\n        continue;\n      }\n    for (c=fgetc(input); c != EOF; c=fgetc(input))\n      if (fputc((char) c,output) != c)\n        status=MagickFalse;\n    (void) fclose(input);\n    (void) remove_utf8(argv[i]);\n  }\n  (void) fclose(output);\n  return(status);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,9 +1,12 @@\n static MagickBooleanType ConcatenateImages(int argc,char **argv,\n-     ExceptionInfo *exception )\n+  ExceptionInfo *exception )\n {\n   FILE\n     *input,\n     *output;\n+\n+  MagickBooleanType\n+    status;\n \n   int\n     c;\n@@ -13,27 +16,29 @@\n \n   if (ExpandFilenames(&argc,&argv) == MagickFalse)\n     ThrowFileException(exception,ResourceLimitError,\"MemoryAllocationFailed\",\n-         GetExceptionMessage(errno));\n-\n+      GetExceptionMessage(errno));\n   output=fopen_utf8(argv[argc-1],\"wb\");\n-  if (output == (FILE *) NULL) {\n-    ThrowFileException(exception,FileOpenError,\"UnableToOpenFile\",argv[argc-1]);\n-    return(MagickFalse);\n-  }\n-  for (i=2; i < (ssize_t) (argc-1); i++) {\n-#if 0\n-    fprintf(stderr, \"DEBUG: Concatenate Image: \\\"%s\\\"\\n\", argv[i]);\n-#endif\n+  if (output == (FILE *) NULL)\n+    {\n+      ThrowFileException(exception,FileOpenError,\"UnableToOpenFile\",\n+        argv[argc-1]);\n+      return(MagickFalse);\n+    }\n+  status=MagickTrue;\n+  for (i=2; i < (ssize_t) (argc-1); i++)\n+  {\n     input=fopen_utf8(argv[i],\"rb\");\n-    if (input == (FILE *) NULL) {\n+    if (input == (FILE *) NULL)\n+      {\n         ThrowFileException(exception,FileOpenError,\"UnableToOpenFile\",argv[i]);\n         continue;\n       }\n     for (c=fgetc(input); c != EOF; c=fgetc(input))\n-      (void) fputc((char) c,output);\n+      if (fputc((char) c,output) != c)\n+        status=MagickFalse;\n     (void) fclose(input);\n     (void) remove_utf8(argv[i]);\n   }\n   (void) fclose(output);\n-  return(MagickTrue);\n+  return(status);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "     ExceptionInfo *exception )",
                "         GetExceptionMessage(errno));",
                "",
                "  if (output == (FILE *) NULL) {",
                "    ThrowFileException(exception,FileOpenError,\"UnableToOpenFile\",argv[argc-1]);",
                "    return(MagickFalse);",
                "  }",
                "  for (i=2; i < (ssize_t) (argc-1); i++) {",
                "#if 0",
                "    fprintf(stderr, \"DEBUG: Concatenate Image: \\\"%s\\\"\\n\", argv[i]);",
                "#endif",
                "    if (input == (FILE *) NULL) {",
                "      (void) fputc((char) c,output);",
                "  return(MagickTrue);"
            ],
            "added_lines": [
                "  ExceptionInfo *exception )",
                "",
                "  MagickBooleanType",
                "    status;",
                "      GetExceptionMessage(errno));",
                "  if (output == (FILE *) NULL)",
                "    {",
                "      ThrowFileException(exception,FileOpenError,\"UnableToOpenFile\",",
                "        argv[argc-1]);",
                "      return(MagickFalse);",
                "    }",
                "  status=MagickTrue;",
                "  for (i=2; i < (ssize_t) (argc-1); i++)",
                "  {",
                "    if (input == (FILE *) NULL)",
                "      {",
                "      if (fputc((char) c,output) != c)",
                "        status=MagickFalse;",
                "  return(status);"
            ]
        }
    },
    {
        "cve_id": "CVE-2016-10061",
        "func_name": "ImageMagick/ReadGROUP4Image",
        "description": "The ReadGROUP4Image function in coders/tiff.c in ImageMagick before 7.0.1-10 does not check the return value of the fputc function, which allows remote attackers to cause a denial of service (crash) via a crafted image file.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/4e914bbe371433f0590cefdf3bd5f3a5710069f9",
        "commit_title": "https://github.com/ImageMagick/ImageMagick/issues/196",
        "commit_text": "",
        "func_before": "static Image *ReadGROUP4Image(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  char\n    filename[MagickPathExtent];\n\n  FILE\n    *file;\n\n  Image\n    *image;\n\n  ImageInfo\n    *read_info;\n\n  int\n    c,\n    unique_file;\n\n  MagickBooleanType\n    status;\n\n  size_t\n    length;\n\n  ssize_t\n    offset,\n    strip_offset;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Write raw CCITT Group 4 wrapped as a TIFF image file.\n  */\n  file=(FILE *) NULL;\n  unique_file=AcquireUniqueFileResource(filename);\n  if (unique_file != -1)\n    file=fdopen(unique_file,\"wb\");\n  if ((unique_file == -1) || (file == (FILE *) NULL))\n    ThrowImageException(FileOpenError,\"UnableToCreateTemporaryFile\");\n  length=fwrite(\"\\111\\111\\052\\000\\010\\000\\000\\000\\016\\000\",1,10,file);\n  length=fwrite(\"\\376\\000\\003\\000\\001\\000\\000\\000\\000\\000\\000\\000\",1,12,file);\n  length=fwrite(\"\\000\\001\\004\\000\\001\\000\\000\\000\",1,8,file);\n  length=WriteLSBLong(file,image->columns);\n  length=fwrite(\"\\001\\001\\004\\000\\001\\000\\000\\000\",1,8,file);\n  length=WriteLSBLong(file,image->rows);\n  length=fwrite(\"\\002\\001\\003\\000\\001\\000\\000\\000\\001\\000\\000\\000\",1,12,file);\n  length=fwrite(\"\\003\\001\\003\\000\\001\\000\\000\\000\\004\\000\\000\\000\",1,12,file);\n  length=fwrite(\"\\006\\001\\003\\000\\001\\000\\000\\000\\000\\000\\000\\000\",1,12,file);\n  length=fwrite(\"\\021\\001\\003\\000\\001\\000\\000\\000\",1,8,file);\n  strip_offset=10+(12*14)+4+8;\n  length=WriteLSBLong(file,(size_t) strip_offset);\n  length=fwrite(\"\\022\\001\\003\\000\\001\\000\\000\\000\",1,8,file);\n  length=WriteLSBLong(file,(size_t) image_info->orientation);\n  length=fwrite(\"\\025\\001\\003\\000\\001\\000\\000\\000\\001\\000\\000\\000\",1,12,file);\n  length=fwrite(\"\\026\\001\\004\\000\\001\\000\\000\\000\",1,8,file);\n  length=WriteLSBLong(file,image->rows);\n  length=fwrite(\"\\027\\001\\004\\000\\001\\000\\000\\000\\000\\000\\000\\000\",1,12,file);\n  offset=(ssize_t) ftell(file)-4;\n  length=fwrite(\"\\032\\001\\005\\000\\001\\000\\000\\000\",1,8,file);\n  length=WriteLSBLong(file,(size_t) (strip_offset-8));\n  length=fwrite(\"\\033\\001\\005\\000\\001\\000\\000\\000\",1,8,file);\n  length=WriteLSBLong(file,(size_t) (strip_offset-8));\n  length=fwrite(\"\\050\\001\\003\\000\\001\\000\\000\\000\\002\\000\\000\\000\",1,12,file);\n  length=fwrite(\"\\000\\000\\000\\000\",1,4,file);\n  length=WriteLSBLong(file,(long) image->resolution.x);\n  length=WriteLSBLong(file,1);\n  for (length=0; (c=ReadBlobByte(image)) != EOF; length++)\n    (void) fputc(c,file);\n  offset=(ssize_t) fseek(file,(ssize_t) offset,SEEK_SET);\n  length=WriteLSBLong(file,(unsigned int) length);\n  (void) fclose(file);\n  (void) CloseBlob(image);\n  image=DestroyImage(image);\n  /*\n    Read TIFF image.\n  */\n  read_info=CloneImageInfo((ImageInfo *) NULL);\n  (void) FormatLocaleString(read_info->filename,MagickPathExtent,\"%s\",filename);\n  image=ReadTIFFImage(read_info,exception);\n  read_info=DestroyImageInfo(read_info);\n  if (image != (Image *) NULL)\n    {\n      (void) CopyMagickString(image->filename,image_info->filename,\n        MagickPathExtent);\n      (void) CopyMagickString(image->magick_filename,image_info->filename,\n        MagickPathExtent);\n      (void) CopyMagickString(image->magick,\"GROUP4\",MagickPathExtent);\n    }\n  (void) RelinquishUniqueFileResource(filename);\n  return(image);\n}",
        "func": "static Image *ReadGROUP4Image(const ImageInfo *image_info,\n  ExceptionInfo *exception)\n{\n  char\n    filename[MagickPathExtent];\n\n  FILE\n    *file;\n\n  Image\n    *image;\n\n  ImageInfo\n    *read_info;\n\n  int\n    c,\n    unique_file;\n\n  MagickBooleanType\n    status;\n\n  size_t\n    length;\n\n  ssize_t\n    offset,\n    strip_offset;\n\n  /*\n    Open image file.\n  */\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  if (image_info->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Write raw CCITT Group 4 wrapped as a TIFF image file.\n  */\n  file=(FILE *) NULL;\n  unique_file=AcquireUniqueFileResource(filename);\n  if (unique_file != -1)\n    file=fdopen(unique_file,\"wb\");\n  if ((unique_file == -1) || (file == (FILE *) NULL))\n    ThrowImageException(FileOpenError,\"UnableToCreateTemporaryFile\");\n  length=fwrite(\"\\111\\111\\052\\000\\010\\000\\000\\000\\016\\000\",1,10,file);\n  length=fwrite(\"\\376\\000\\003\\000\\001\\000\\000\\000\\000\\000\\000\\000\",1,12,file);\n  length=fwrite(\"\\000\\001\\004\\000\\001\\000\\000\\000\",1,8,file);\n  length=WriteLSBLong(file,image->columns);\n  length=fwrite(\"\\001\\001\\004\\000\\001\\000\\000\\000\",1,8,file);\n  length=WriteLSBLong(file,image->rows);\n  length=fwrite(\"\\002\\001\\003\\000\\001\\000\\000\\000\\001\\000\\000\\000\",1,12,file);\n  length=fwrite(\"\\003\\001\\003\\000\\001\\000\\000\\000\\004\\000\\000\\000\",1,12,file);\n  length=fwrite(\"\\006\\001\\003\\000\\001\\000\\000\\000\\000\\000\\000\\000\",1,12,file);\n  length=fwrite(\"\\021\\001\\003\\000\\001\\000\\000\\000\",1,8,file);\n  strip_offset=10+(12*14)+4+8;\n  length=WriteLSBLong(file,(size_t) strip_offset);\n  length=fwrite(\"\\022\\001\\003\\000\\001\\000\\000\\000\",1,8,file);\n  length=WriteLSBLong(file,(size_t) image_info->orientation);\n  length=fwrite(\"\\025\\001\\003\\000\\001\\000\\000\\000\\001\\000\\000\\000\",1,12,file);\n  length=fwrite(\"\\026\\001\\004\\000\\001\\000\\000\\000\",1,8,file);\n  length=WriteLSBLong(file,image->rows);\n  length=fwrite(\"\\027\\001\\004\\000\\001\\000\\000\\000\\000\\000\\000\\000\",1,12,file);\n  offset=(ssize_t) ftell(file)-4;\n  length=fwrite(\"\\032\\001\\005\\000\\001\\000\\000\\000\",1,8,file);\n  length=WriteLSBLong(file,(size_t) (strip_offset-8));\n  length=fwrite(\"\\033\\001\\005\\000\\001\\000\\000\\000\",1,8,file);\n  length=WriteLSBLong(file,(size_t) (strip_offset-8));\n  length=fwrite(\"\\050\\001\\003\\000\\001\\000\\000\\000\\002\\000\\000\\000\",1,12,file);\n  length=fwrite(\"\\000\\000\\000\\000\",1,4,file);\n  length=WriteLSBLong(file,(long) image->resolution.x);\n  length=WriteLSBLong(file,1);\n  status=MagickTrue;\n  for (length=0; (c=ReadBlobByte(image)) != EOF; length++)\n    if (fputc(c,file) != c)\n      status=MagickFalse;\n  offset=(ssize_t) fseek(file,(ssize_t) offset,SEEK_SET);\n  length=WriteLSBLong(file,(unsigned int) length);\n  (void) fclose(file);\n  (void) CloseBlob(image);\n  image=DestroyImage(image);\n  /*\n    Read TIFF image.\n  */\n  read_info=CloneImageInfo((ImageInfo *) NULL);\n  (void) FormatLocaleString(read_info->filename,MagickPathExtent,\"%s\",filename);\n  image=ReadTIFFImage(read_info,exception);\n  read_info=DestroyImageInfo(read_info);\n  if (image != (Image *) NULL)\n    {\n      (void) CopyMagickString(image->filename,image_info->filename,\n        MagickPathExtent);\n      (void) CopyMagickString(image->magick_filename,image_info->filename,\n        MagickPathExtent);\n      (void) CopyMagickString(image->magick,\"GROUP4\",MagickPathExtent);\n    }\n  (void) RelinquishUniqueFileResource(filename);\n  if (status == MagickFalse)\n    image=DestroyImage(image);\n  return(image);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -80,8 +80,10 @@\n   length=fwrite(\"\\000\\000\\000\\000\",1,4,file);\n   length=WriteLSBLong(file,(long) image->resolution.x);\n   length=WriteLSBLong(file,1);\n+  status=MagickTrue;\n   for (length=0; (c=ReadBlobByte(image)) != EOF; length++)\n-    (void) fputc(c,file);\n+    if (fputc(c,file) != c)\n+      status=MagickFalse;\n   offset=(ssize_t) fseek(file,(ssize_t) offset,SEEK_SET);\n   length=WriteLSBLong(file,(unsigned int) length);\n   (void) fclose(file);\n@@ -103,5 +105,7 @@\n       (void) CopyMagickString(image->magick,\"GROUP4\",MagickPathExtent);\n     }\n   (void) RelinquishUniqueFileResource(filename);\n+  if (status == MagickFalse)\n+    image=DestroyImage(image);\n   return(image);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    (void) fputc(c,file);"
            ],
            "added_lines": [
                "  status=MagickTrue;",
                "    if (fputc(c,file) != c)",
                "      status=MagickFalse;",
                "  if (status == MagickFalse)",
                "    image=DestroyImage(image);"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-23476",
        "func_name": "sparklemotion/nokogiri/rb_xml_reader_attribute_hash",
        "description": "Nokogiri is an open source XML and HTML library for the Ruby programming language. Nokogiri `1.13.8` and `1.13.9` fail to check the return value from `xmlTextReaderExpand` in the method `Nokogiri::XML::Reader#attribute_hash`. This can lead to a null pointer exception when invalid markup is being parsed. For applications using `XML::Reader` to parse untrusted inputs, this may potentially be a vector for a denial of service attack. Users are advised to upgrade to Nokogiri `>= 1.13.10`. Users may be able to search their code for calls to either `XML::Reader#attributes` or `XML::Reader#attribute_hash` to determine if they are affected.",
        "git_url": "https://github.com/sparklemotion/nokogiri/commit/9fe0761c47c0d4270d1a5220cfd25de080350d50",
        "commit_title": "fix(cruby): XML::Reader#attribute_hash returns nil on error",
        "commit_text": " Note that on JRuby, the namespaces are still returned because the parse error would raised on the subsequent node expansion.  This restores the behavior from v1.13.7",
        "func_before": "static VALUE\nrb_xml_reader_attribute_hash(VALUE rb_reader)\n{\n  VALUE rb_attributes = rb_hash_new();\n  xmlTextReaderPtr c_reader;\n  xmlNodePtr c_node;\n  xmlAttrPtr c_property;\n\n  Data_Get_Struct(rb_reader, xmlTextReader, c_reader);\n\n  if (!has_attributes(c_reader)) {\n    return rb_attributes;\n  }\n\n  c_node = xmlTextReaderExpand(c_reader);\n  c_property = c_node->properties;\n  while (c_property != NULL) {\n    VALUE rb_name = NOKOGIRI_STR_NEW2(c_property->name);\n    VALUE rb_value = Qnil;\n    xmlChar *c_value = xmlNodeGetContent((xmlNode *)c_property);\n\n    if (c_value) {\n      rb_value = NOKOGIRI_STR_NEW2(c_value);\n      xmlFree(c_value);\n    }\n\n    rb_hash_aset(rb_attributes, rb_name, rb_value);\n\n    c_property = c_property->next;\n  }\n\n  return rb_attributes;\n}",
        "func": "static VALUE\nrb_xml_reader_attribute_hash(VALUE rb_reader)\n{\n  VALUE rb_attributes = rb_hash_new();\n  xmlTextReaderPtr c_reader;\n  xmlNodePtr c_node;\n  xmlAttrPtr c_property;\n\n  Data_Get_Struct(rb_reader, xmlTextReader, c_reader);\n\n  if (!has_attributes(c_reader)) {\n    return rb_attributes;\n  }\n\n  c_node = xmlTextReaderExpand(c_reader);\n  if (c_node == NULL) {\n    return Qnil;\n  }\n\n  c_property = c_node->properties;\n  while (c_property != NULL) {\n    VALUE rb_name = NOKOGIRI_STR_NEW2(c_property->name);\n    VALUE rb_value = Qnil;\n    xmlChar *c_value = xmlNodeGetContent((xmlNode *)c_property);\n\n    if (c_value) {\n      rb_value = NOKOGIRI_STR_NEW2(c_value);\n      xmlFree(c_value);\n    }\n\n    rb_hash_aset(rb_attributes, rb_name, rb_value);\n\n    c_property = c_property->next;\n  }\n\n  return rb_attributes;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -13,6 +13,10 @@\n   }\n \n   c_node = xmlTextReaderExpand(c_reader);\n+  if (c_node == NULL) {\n+    return Qnil;\n+  }\n+\n   c_property = c_node->properties;\n   while (c_property != NULL) {\n     VALUE rb_name = NOKOGIRI_STR_NEW2(c_property->name);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "  if (c_node == NULL) {",
                "    return Qnil;",
                "  }",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2020-15191",
        "func_name": "tensorflow/TFE_HandleToDLPack",
        "description": "In Tensorflow before versions 2.2.1 and 2.3.1, if a user passes an invalid argument to `dlpack.to_dlpack` the expected validations will cause variables to bind to `nullptr` while setting a `status` variable to the error condition. However, this `status` argument is not properly checked. Hence, code following these methods will bind references to null pointers. This is undefined behavior and reported as an error if compiling with `-fsanitize=null`. The issue is patched in commit 22e07fb204386768e5bcbea563641ea11f96ceb8 and is released in TensorFlow versions 2.2.1, or 2.3.1.",
        "git_url": "https://github.com/tensorflow/tensorflow/commit/22e07fb204386768e5bcbea563641ea11f96ceb8",
        "commit_title": "Fix multiple vulnerabilities in `tf.experimental.dlpack.to_dlpack`.",
        "commit_text": " We have a use after free caused by memory coruption, a segmentation fault caused by memory corruption, several memory leaks and an undefined behavior when taking the reference of a nullptr.  PiperOrigin-RevId: 332568894",
        "func_before": "void* TFE_HandleToDLPack(TFE_TensorHandle* h, TF_Status* status) {\n  const Tensor* tensor = GetTensorFromHandle(h, status);\n  TF_DataType data_type = static_cast<TF_DataType>(tensor->dtype());\n  TensorReference tensor_ref(*tensor);  // This will call buf_->Ref()\n\n  auto* tf_dlm_tensor_ctx = new TfDlManagedTensorCtx(tensor_ref);\n  tf_dlm_tensor_ctx->reference = tensor_ref;\n\n  DLManagedTensor* dlm_tensor = &tf_dlm_tensor_ctx->tensor;\n  dlm_tensor->manager_ctx = tf_dlm_tensor_ctx;\n  dlm_tensor->deleter = &DLManagedTensorDeleter;\n  dlm_tensor->dl_tensor.ctx = GetDlContext(h, status);\n  int ndim = tensor->dims();\n  dlm_tensor->dl_tensor.ndim = ndim;\n  dlm_tensor->dl_tensor.data = TFE_TensorHandleDevicePointer(h, status);\n  dlm_tensor->dl_tensor.dtype = GetDlDataType(data_type, status);\n\n  std::vector<int64_t>* shape_arr = &tf_dlm_tensor_ctx->shape;\n  std::vector<int64_t>* stride_arr = &tf_dlm_tensor_ctx->strides;\n  shape_arr->resize(ndim);\n  stride_arr->resize(ndim, 1);\n  for (int i = 0; i < ndim; i++) {\n    (*shape_arr)[i] = tensor->dim_size(i);\n  }\n  for (int i = ndim - 2; i >= 0; --i) {\n    (*stride_arr)[i] = (*shape_arr)[i + 1] * (*stride_arr)[i + 1];\n  }\n\n  dlm_tensor->dl_tensor.shape = &(*shape_arr)[0];\n  // There are two ways to represent compact row-major data\n  // 1) nullptr indicates tensor is compact and row-majored.\n  // 2) fill in the strides array as the real case for compact row-major data.\n  // Here we choose option 2, since some frameworks didn't handle the strides\n  // argument properly.\n  dlm_tensor->dl_tensor.strides = &(*stride_arr)[0];\n  dlm_tensor->dl_tensor.byte_offset =\n      0;  // TF doesn't handle the strides and byte_offsets here\n  return static_cast<void*>(dlm_tensor);\n}",
        "func": "void* TFE_HandleToDLPack(TFE_TensorHandle* h, TF_Status* status) {\n  auto tf_dlm_context = GetDlContext(h, status);\n  if (!status->status.ok()) {\n    return nullptr;\n  }\n\n  auto* tf_dlm_data = TFE_TensorHandleDevicePointer(h, status);\n  if (!status->status.ok()) {\n    return nullptr;\n  }\n\n  const Tensor* tensor = GetTensorFromHandle(h, status);\n  TF_DataType data_type = static_cast<TF_DataType>(tensor->dtype());\n\n  auto tf_dlm_type = GetDlDataType(data_type, status);\n  if (!status->status.ok()) {\n    return nullptr;\n  }\n\n  TensorReference tensor_ref(*tensor);  // This will call buf_->Ref()\n  auto* tf_dlm_tensor_ctx = new TfDlManagedTensorCtx(tensor_ref);\n  tf_dlm_tensor_ctx->reference = tensor_ref;\n\n  DLManagedTensor* dlm_tensor = &tf_dlm_tensor_ctx->tensor;\n  dlm_tensor->manager_ctx = tf_dlm_tensor_ctx;\n  dlm_tensor->deleter = &DLManagedTensorDeleter;\n  dlm_tensor->dl_tensor.ctx = tf_dlm_context;\n  int ndim = tensor->dims();\n  dlm_tensor->dl_tensor.ndim = ndim;\n  dlm_tensor->dl_tensor.data = tf_dlm_data;\n  dlm_tensor->dl_tensor.dtype = tf_dlm_type;\n\n  std::vector<int64_t>* shape_arr = &tf_dlm_tensor_ctx->shape;\n  std::vector<int64_t>* stride_arr = &tf_dlm_tensor_ctx->strides;\n  shape_arr->resize(ndim);\n  stride_arr->resize(ndim, 1);\n  for (int i = 0; i < ndim; i++) {\n    (*shape_arr)[i] = tensor->dim_size(i);\n  }\n  for (int i = ndim - 2; i >= 0; --i) {\n    (*stride_arr)[i] = (*shape_arr)[i + 1] * (*stride_arr)[i + 1];\n  }\n\n  dlm_tensor->dl_tensor.shape = shape_arr->data();\n  // There are two ways to represent compact row-major data\n  // 1) nullptr indicates tensor is compact and row-majored.\n  // 2) fill in the strides array as the real case for compact row-major data.\n  // Here we choose option 2, since some frameworks didn't handle the strides\n  // argument properly.\n  dlm_tensor->dl_tensor.strides = stride_arr->data();\n\n  dlm_tensor->dl_tensor.byte_offset =\n      0;  // TF doesn't handle the strides and byte_offsets here\n  return static_cast<void*>(dlm_tensor);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,19 +1,34 @@\n void* TFE_HandleToDLPack(TFE_TensorHandle* h, TF_Status* status) {\n+  auto tf_dlm_context = GetDlContext(h, status);\n+  if (!status->status.ok()) {\n+    return nullptr;\n+  }\n+\n+  auto* tf_dlm_data = TFE_TensorHandleDevicePointer(h, status);\n+  if (!status->status.ok()) {\n+    return nullptr;\n+  }\n+\n   const Tensor* tensor = GetTensorFromHandle(h, status);\n   TF_DataType data_type = static_cast<TF_DataType>(tensor->dtype());\n+\n+  auto tf_dlm_type = GetDlDataType(data_type, status);\n+  if (!status->status.ok()) {\n+    return nullptr;\n+  }\n+\n   TensorReference tensor_ref(*tensor);  // This will call buf_->Ref()\n-\n   auto* tf_dlm_tensor_ctx = new TfDlManagedTensorCtx(tensor_ref);\n   tf_dlm_tensor_ctx->reference = tensor_ref;\n \n   DLManagedTensor* dlm_tensor = &tf_dlm_tensor_ctx->tensor;\n   dlm_tensor->manager_ctx = tf_dlm_tensor_ctx;\n   dlm_tensor->deleter = &DLManagedTensorDeleter;\n-  dlm_tensor->dl_tensor.ctx = GetDlContext(h, status);\n+  dlm_tensor->dl_tensor.ctx = tf_dlm_context;\n   int ndim = tensor->dims();\n   dlm_tensor->dl_tensor.ndim = ndim;\n-  dlm_tensor->dl_tensor.data = TFE_TensorHandleDevicePointer(h, status);\n-  dlm_tensor->dl_tensor.dtype = GetDlDataType(data_type, status);\n+  dlm_tensor->dl_tensor.data = tf_dlm_data;\n+  dlm_tensor->dl_tensor.dtype = tf_dlm_type;\n \n   std::vector<int64_t>* shape_arr = &tf_dlm_tensor_ctx->shape;\n   std::vector<int64_t>* stride_arr = &tf_dlm_tensor_ctx->strides;\n@@ -26,13 +41,14 @@\n     (*stride_arr)[i] = (*shape_arr)[i + 1] * (*stride_arr)[i + 1];\n   }\n \n-  dlm_tensor->dl_tensor.shape = &(*shape_arr)[0];\n+  dlm_tensor->dl_tensor.shape = shape_arr->data();\n   // There are two ways to represent compact row-major data\n   // 1) nullptr indicates tensor is compact and row-majored.\n   // 2) fill in the strides array as the real case for compact row-major data.\n   // Here we choose option 2, since some frameworks didn't handle the strides\n   // argument properly.\n-  dlm_tensor->dl_tensor.strides = &(*stride_arr)[0];\n+  dlm_tensor->dl_tensor.strides = stride_arr->data();\n+\n   dlm_tensor->dl_tensor.byte_offset =\n       0;  // TF doesn't handle the strides and byte_offsets here\n   return static_cast<void*>(dlm_tensor);",
        "diff_line_info": {
            "deleted_lines": [
                "",
                "  dlm_tensor->dl_tensor.ctx = GetDlContext(h, status);",
                "  dlm_tensor->dl_tensor.data = TFE_TensorHandleDevicePointer(h, status);",
                "  dlm_tensor->dl_tensor.dtype = GetDlDataType(data_type, status);",
                "  dlm_tensor->dl_tensor.shape = &(*shape_arr)[0];",
                "  dlm_tensor->dl_tensor.strides = &(*stride_arr)[0];"
            ],
            "added_lines": [
                "  auto tf_dlm_context = GetDlContext(h, status);",
                "  if (!status->status.ok()) {",
                "    return nullptr;",
                "  }",
                "",
                "  auto* tf_dlm_data = TFE_TensorHandleDevicePointer(h, status);",
                "  if (!status->status.ok()) {",
                "    return nullptr;",
                "  }",
                "",
                "",
                "  auto tf_dlm_type = GetDlDataType(data_type, status);",
                "  if (!status->status.ok()) {",
                "    return nullptr;",
                "  }",
                "",
                "  dlm_tensor->dl_tensor.ctx = tf_dlm_context;",
                "  dlm_tensor->dl_tensor.data = tf_dlm_data;",
                "  dlm_tensor->dl_tensor.dtype = tf_dlm_type;",
                "  dlm_tensor->dl_tensor.shape = shape_arr->data();",
                "  dlm_tensor->dl_tensor.strides = stride_arr->data();",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-1999-0199",
        "func_name": "bminor/glibc/expand_dynamic_string_token",
        "description": "manual/search.texi in the GNU C Library (aka glibc) before 2.2 lacks a statement about the unspecified tdelete return value upon deletion of a tree's root, which might allow attackers to access a dangling pointer in an application whose developer was unaware of a documentation update from 1999.",
        "git_url": "https://github.com/bminor/glibc/commit/2864e767053317538feafa815046fff89e5a16be",
        "commit_title": "Update.",
        "commit_text": " 1999-11-09  Ulrich Drepper  <drepper@cygnus.com>  \t* elf/dl-load.c (_dl_dst_count): Allow $ORIGIN to point to \tdirectory with the reference since this is as secure as using the \tobject with the dependency. \t(_dl_dst_substitute): Likewise.  \t* elf/dl-load.c (_dl_dst_count): Change strings in first two \tstrncmp calls to allow reuse. \t(_dl_dst_substitute): Likewise.  1999-11-01  Arnold D. Robbins  <arnold@skeeve.com>  \t* posix/regex.c (init_syntax_once): move below definition of \tISALNUM etc., then use ISALNUM to init the table, so that \tthe word ops will work if i18n'ed. \t(SYNTAX): And subscript with 0xFF for 8bit character sets.  1999-11-09  Andreas Jaeger  <aj@suse.de>  \t* sysdeps/unix/getlogin_r.c (getlogin_r): Sync with getlogin \timplementation for ttyname_r call; fix inverted condition; return \tut_user.  Closes PR libc/1438.  1999-11-09  Ulrich Drepper  <drepper@cygnus.com>  \t* timezone/checktab.awk: Update from tzcode1999h. \t* timezone/africa: Update from tzdata1999i. \t* timezone/asia: Likewise. \t* timezone/australasia: Likewise. \t* timezone/backward: Likewise. \t* timezone/europe: Likewise. \t* timezone/northamerica: Likewise. \t* timezone/southamerica: Likewise. \t* timezone/iso3166.tab: Likewise. \t* timezone/zone.tab: Likewise.  \t* sysdeps/unix/sysv/linux/bits/resource.h: Define values also as \tmacros.  Patch by brg@csua.berkeley.edu [PR libc/1439].  1999-11-09  Andreas Jaeger  <aj@suse.de>  \t* posix/Makefile (tests): Added tst-getlogin.  \t* posix/tst-getlogin.c: New file, contains simple tests for \tgetlogin and getlogin_r.  1999-11-09  Andreas Schwab  <schwab@suse.de>  \t* misc/syslog.c: For LOG_PERROR only append a newline if \tnecessary.",
        "func_before": "static char *\nexpand_dynamic_string_token (struct link_map *l, const char *s)\n{\n  /* We make two runs over the string.  First we determine how large the\n     resulting string is and then we copy it over.  Since this is now\n     frequently executed operation we are looking here not for performance\n     but rather for code size.  */\n  size_t cnt;\n  size_t total;\n  char *result;\n\n  /* Determine the nubmer of DST elements.  */\n  cnt = DL_DST_COUNT (s, 1);\n\n  /* If we do not have to replace anything simply copy the string.  */\n  if (cnt == 0)\n    return local_strdup (s);\n\n  /* Determine the length of the substituted string.  */\n  total = DL_DST_REQUIRED (l, s, strlen (s), cnt);\n\n  /* Allocate the necessary memory.  */\n  result = (char *) malloc (total + 1);\n  if (result == NULL)\n    return NULL;\n\n  return DL_DST_SUBSTITUTE (l, s, result, 1);\n}",
        "func": "static char *\nexpand_dynamic_string_token (struct link_map *l, const char *s)\n{\n  /* We make two runs over the string.  First we determine how large the\n     resulting string is and then we copy it over.  Since this is now\n     frequently executed operation we are looking here not for performance\n     but rather for code size.  */\n  size_t cnt;\n  size_t total;\n  char *result;\n\n  /* Determine the number of DST elements.  */\n  cnt = DL_DST_COUNT (s, 1);\n\n  /* If we do not have to replace anything simply copy the string.  */\n  if (cnt == 0)\n    return local_strdup (s);\n\n  /* Determine the length of the substituted string.  */\n  total = DL_DST_REQUIRED (l, s, strlen (s), cnt);\n\n  /* Allocate the necessary memory.  */\n  result = (char *) malloc (total + 1);\n  if (result == NULL)\n    return NULL;\n\n  return DL_DST_SUBSTITUTE (l, s, result, 1);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -9,7 +9,7 @@\n   size_t total;\n   char *result;\n \n-  /* Determine the nubmer of DST elements.  */\n+  /* Determine the number of DST elements.  */\n   cnt = DL_DST_COUNT (s, 1);\n \n   /* If we do not have to replace anything simply copy the string.  */",
        "diff_line_info": {
            "deleted_lines": [
                "  /* Determine the nubmer of DST elements.  */"
            ],
            "added_lines": [
                "  /* Determine the number of DST elements.  */"
            ]
        }
    },
    {
        "cve_id": "CVE-1999-0199",
        "func_name": "bminor/glibc/_dl_dst_substitute",
        "description": "manual/search.texi in the GNU C Library (aka glibc) before 2.2 lacks a statement about the unspecified tdelete return value upon deletion of a tree's root, which might allow attackers to access a dangling pointer in an application whose developer was unaware of a documentation update from 1999.",
        "git_url": "https://github.com/bminor/glibc/commit/2864e767053317538feafa815046fff89e5a16be",
        "commit_title": "Update.",
        "commit_text": " 1999-11-09  Ulrich Drepper  <drepper@cygnus.com>  \t* elf/dl-load.c (_dl_dst_count): Allow $ORIGIN to point to \tdirectory with the reference since this is as secure as using the \tobject with the dependency. \t(_dl_dst_substitute): Likewise.  \t* elf/dl-load.c (_dl_dst_count): Change strings in first two \tstrncmp calls to allow reuse. \t(_dl_dst_substitute): Likewise.  1999-11-01  Arnold D. Robbins  <arnold@skeeve.com>  \t* posix/regex.c (init_syntax_once): move below definition of \tISALNUM etc., then use ISALNUM to init the table, so that \tthe word ops will work if i18n'ed. \t(SYNTAX): And subscript with 0xFF for 8bit character sets.  1999-11-09  Andreas Jaeger  <aj@suse.de>  \t* sysdeps/unix/getlogin_r.c (getlogin_r): Sync with getlogin \timplementation for ttyname_r call; fix inverted condition; return \tut_user.  Closes PR libc/1438.  1999-11-09  Ulrich Drepper  <drepper@cygnus.com>  \t* timezone/checktab.awk: Update from tzcode1999h. \t* timezone/africa: Update from tzdata1999i. \t* timezone/asia: Likewise. \t* timezone/australasia: Likewise. \t* timezone/backward: Likewise. \t* timezone/europe: Likewise. \t* timezone/northamerica: Likewise. \t* timezone/southamerica: Likewise. \t* timezone/iso3166.tab: Likewise. \t* timezone/zone.tab: Likewise.  \t* sysdeps/unix/sysv/linux/bits/resource.h: Define values also as \tmacros.  Patch by brg@csua.berkeley.edu [PR libc/1439].  1999-11-09  Andreas Jaeger  <aj@suse.de>  \t* posix/Makefile (tests): Added tst-getlogin.  \t* posix/tst-getlogin.c: New file, contains simple tests for \tgetlogin and getlogin_r.  1999-11-09  Andreas Schwab  <schwab@suse.de>  \t* misc/syslog.c: For LOG_PERROR only append a newline if \tnecessary.",
        "func_before": "char *\n_dl_dst_substitute (struct link_map *l, const char *name, char *result,\n\t\t    int is_path)\n{\n  char *last_elem, *wp;\n\n  /* Now fill the result path.  While copying over the string we keep\n     track of the start of the last path element.  When we come accross\n     a DST we copy over the value or (if the value is not available)\n     leave the entire path element out.  */\n  last_elem = wp = result;\n\n  do\n    {\n      if (*name == '$')\n\t{\n\t  const char *repl;\n\t  size_t len;\n\n\t  if ((((strncmp (&name[1], \"ORIGIN\", 6) == 0 && (len = 7) != 0)\n\t\t|| (strncmp (&name[1], \"PLATFORM\", 8) == 0 && (len = 9) != 0))\n\t       && (name[len] == '\\0' || name[len] == '/'\n\t\t   || (is_path && name[len] == ':')))\n\t      || (name[1] == '{'\n\t\t  && ((strncmp (&name[2], \"ORIGIN}\", 7) == 0 && (len = 9) != 0)\n\t\t      || (strncmp (&name[2], \"PLATFORM}\", 9) == 0\n\t\t\t  && (len = 11) != 0))))\n\t    {\n\t      repl = ((len == 7 || name[2] == 'O')\n\t\t      ? (__libc_enable_secure ? NULL : l->l_origin)\n\t\t      : _dl_platform);\n\n\t      if (repl != NULL && repl != (const char *) -1)\n\t\t{\n\t\t  wp = __stpcpy (wp, repl);\n\t\t  name += len;\n\t\t}\n\t      else\n\t\t{\n\t\t  /* We cannot use this path element, the value of the\n\t\t     replacement is unknown.  */\n\t\t  wp = last_elem;\n\t\t  name += len;\n\t\t  while (*name != '\\0' && (!is_path || *name != ':'))\n\t\t    ++name;\n\t\t}\n\t    }\n\t  else\n\t    /* No DST we recognize.  */\n\t    *wp++ = *name++;\n\t}\n      else if (is_path && *name == ':')\n\t{\n\t  *wp++ = *name++;\n\t  last_elem = wp;\n\t}\n      else\n\t*wp++ = *name++;\n    }\n  while (*name != '\\0');\n\n  *wp = '\\0';\n\n  return result;\n}",
        "func": "char *\n_dl_dst_substitute (struct link_map *l, const char *name, char *result,\n\t\t    int is_path)\n{\n  const char *const start = name;\n  char *last_elem, *wp;\n\n  /* Now fill the result path.  While copying over the string we keep\n     track of the start of the last path element.  When we come accross\n     a DST we copy over the value or (if the value is not available)\n     leave the entire path element out.  */\n  last_elem = wp = result;\n\n  do\n    {\n      if (*name == '$')\n\t{\n\t  const char *repl;\n\t  size_t len;\n\n      /* Note that it is no bug that the strings in the first two `strncmp'\n\t calls are longer than the sequence which is actually tested.  */\n\t  if ((((strncmp (&name[1], \"ORIGIN}\", 6) == 0 && (len = 7) != 0)\n\t\t|| (strncmp (&name[1], \"PLATFORM}\", 8) == 0 && (len = 9) != 0))\n\t       && (name[len] == '\\0' || name[len] == '/'\n\t\t   || (is_path && name[len] == ':')))\n\t      || (name[1] == '{'\n\t\t  && ((strncmp (&name[2], \"ORIGIN}\", 7) == 0 && (len = 9) != 0)\n\t\t      || (strncmp (&name[2], \"PLATFORM}\", 9) == 0\n\t\t\t  && (len = 11) != 0))))\n\t    {\n\t      repl = ((len == 7 || name[2] == 'O')\n\t\t      ? (__libc_enable_secure\n\t\t\t && ((name[len] != '\\0'\n\t\t\t      && (!is_path || name[len] != ':'))\n\t\t\t     || (name != start\n\t\t\t\t && (!is_path || name[-1] != ':')))\n\t\t\t ? NULL : l->l_origin)\n\t\t      : _dl_platform);\n\n\t      if (repl != NULL && repl != (const char *) -1)\n\t\t{\n\t\t  wp = __stpcpy (wp, repl);\n\t\t  name += len;\n\t\t}\n\t      else\n\t\t{\n\t\t  /* We cannot use this path element, the value of the\n\t\t     replacement is unknown.  */\n\t\t  wp = last_elem;\n\t\t  name += len;\n\t\t  while (*name != '\\0' && (!is_path || *name != ':'))\n\t\t    ++name;\n\t\t}\n\t    }\n\t  else\n\t    /* No DST we recognize.  */\n\t    *wp++ = *name++;\n\t}\n      else if (is_path && *name == ':')\n\t{\n\t  *wp++ = *name++;\n\t  last_elem = wp;\n\t}\n      else\n\t*wp++ = *name++;\n    }\n  while (*name != '\\0');\n\n  *wp = '\\0';\n\n  return result;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,6 +2,7 @@\n _dl_dst_substitute (struct link_map *l, const char *name, char *result,\n \t\t    int is_path)\n {\n+  const char *const start = name;\n   char *last_elem, *wp;\n \n   /* Now fill the result path.  While copying over the string we keep\n@@ -17,8 +18,10 @@\n \t  const char *repl;\n \t  size_t len;\n \n-\t  if ((((strncmp (&name[1], \"ORIGIN\", 6) == 0 && (len = 7) != 0)\n-\t\t|| (strncmp (&name[1], \"PLATFORM\", 8) == 0 && (len = 9) != 0))\n+      /* Note that it is no bug that the strings in the first two `strncmp'\n+\t calls are longer than the sequence which is actually tested.  */\n+\t  if ((((strncmp (&name[1], \"ORIGIN}\", 6) == 0 && (len = 7) != 0)\n+\t\t|| (strncmp (&name[1], \"PLATFORM}\", 8) == 0 && (len = 9) != 0))\n \t       && (name[len] == '\\0' || name[len] == '/'\n \t\t   || (is_path && name[len] == ':')))\n \t      || (name[1] == '{'\n@@ -27,7 +30,12 @@\n \t\t\t  && (len = 11) != 0))))\n \t    {\n \t      repl = ((len == 7 || name[2] == 'O')\n-\t\t      ? (__libc_enable_secure ? NULL : l->l_origin)\n+\t\t      ? (__libc_enable_secure\n+\t\t\t && ((name[len] != '\\0'\n+\t\t\t      && (!is_path || name[len] != ':'))\n+\t\t\t     || (name != start\n+\t\t\t\t && (!is_path || name[-1] != ':')))\n+\t\t\t ? NULL : l->l_origin)\n \t\t      : _dl_platform);\n \n \t      if (repl != NULL && repl != (const char *) -1)",
        "diff_line_info": {
            "deleted_lines": [
                "\t  if ((((strncmp (&name[1], \"ORIGIN\", 6) == 0 && (len = 7) != 0)",
                "\t\t|| (strncmp (&name[1], \"PLATFORM\", 8) == 0 && (len = 9) != 0))",
                "\t\t      ? (__libc_enable_secure ? NULL : l->l_origin)"
            ],
            "added_lines": [
                "  const char *const start = name;",
                "      /* Note that it is no bug that the strings in the first two `strncmp'",
                "\t calls are longer than the sequence which is actually tested.  */",
                "\t  if ((((strncmp (&name[1], \"ORIGIN}\", 6) == 0 && (len = 7) != 0)",
                "\t\t|| (strncmp (&name[1], \"PLATFORM}\", 8) == 0 && (len = 9) != 0))",
                "\t\t      ? (__libc_enable_secure",
                "\t\t\t && ((name[len] != '\\0'",
                "\t\t\t      && (!is_path || name[len] != ':'))",
                "\t\t\t     || (name != start",
                "\t\t\t\t && (!is_path || name[-1] != ':')))",
                "\t\t\t ? NULL : l->l_origin)"
            ]
        }
    },
    {
        "cve_id": "CVE-1999-0199",
        "func_name": "bminor/glibc/_dl_dst_count",
        "description": "manual/search.texi in the GNU C Library (aka glibc) before 2.2 lacks a statement about the unspecified tdelete return value upon deletion of a tree's root, which might allow attackers to access a dangling pointer in an application whose developer was unaware of a documentation update from 1999.",
        "git_url": "https://github.com/bminor/glibc/commit/2864e767053317538feafa815046fff89e5a16be",
        "commit_title": "Update.",
        "commit_text": " 1999-11-09  Ulrich Drepper  <drepper@cygnus.com>  \t* elf/dl-load.c (_dl_dst_count): Allow $ORIGIN to point to \tdirectory with the reference since this is as secure as using the \tobject with the dependency. \t(_dl_dst_substitute): Likewise.  \t* elf/dl-load.c (_dl_dst_count): Change strings in first two \tstrncmp calls to allow reuse. \t(_dl_dst_substitute): Likewise.  1999-11-01  Arnold D. Robbins  <arnold@skeeve.com>  \t* posix/regex.c (init_syntax_once): move below definition of \tISALNUM etc., then use ISALNUM to init the table, so that \tthe word ops will work if i18n'ed. \t(SYNTAX): And subscript with 0xFF for 8bit character sets.  1999-11-09  Andreas Jaeger  <aj@suse.de>  \t* sysdeps/unix/getlogin_r.c (getlogin_r): Sync with getlogin \timplementation for ttyname_r call; fix inverted condition; return \tut_user.  Closes PR libc/1438.  1999-11-09  Ulrich Drepper  <drepper@cygnus.com>  \t* timezone/checktab.awk: Update from tzcode1999h. \t* timezone/africa: Update from tzdata1999i. \t* timezone/asia: Likewise. \t* timezone/australasia: Likewise. \t* timezone/backward: Likewise. \t* timezone/europe: Likewise. \t* timezone/northamerica: Likewise. \t* timezone/southamerica: Likewise. \t* timezone/iso3166.tab: Likewise. \t* timezone/zone.tab: Likewise.  \t* sysdeps/unix/sysv/linux/bits/resource.h: Define values also as \tmacros.  Patch by brg@csua.berkeley.edu [PR libc/1439].  1999-11-09  Andreas Jaeger  <aj@suse.de>  \t* posix/Makefile (tests): Added tst-getlogin.  \t* posix/tst-getlogin.c: New file, contains simple tests for \tgetlogin and getlogin_r.  1999-11-09  Andreas Schwab  <schwab@suse.de>  \t* misc/syslog.c: For LOG_PERROR only append a newline if \tnecessary.",
        "func_before": "size_t\n_dl_dst_count (const char *name, int is_path)\n{\n  size_t cnt = 0;\n\n  do\n    {\n      size_t len = 1;\n\n      /* $ORIGIN is not expanded for SUID/GUID programs.  */\n      if ((((!__libc_enable_secure\n\t     && strncmp (&name[1], \"ORIGIN\", 6) == 0 && (len = 7) != 0)\n\t    || (strncmp (&name[1], \"PLATFORM\", 8) == 0 && (len = 9) != 0))\n\t   && (name[len] == '\\0' || name[len] == '/'\n\t       || (is_path && name[len] == ':')))\n\t  || (name[1] == '{'\n\t      && ((!__libc_enable_secure\n\t\t   && strncmp (&name[2], \"ORIGIN}\", 7) == 0 && (len = 9) != 0)\n\t\t  || (strncmp (&name[2], \"PLATFORM}\", 9) == 0\n\t\t      && (len = 11) != 0))))\n\t++cnt;\n\n      name = strchr (name + len, '$');\n    }\n  while (name != NULL);\n\n  return cnt;\n}",
        "func": "size_t\n_dl_dst_count (const char *name, int is_path)\n{\n  const char *const start = name;\n  size_t cnt = 0;\n\n  do\n    {\n      size_t len = 1;\n\n      /* $ORIGIN is not expanded for SUID/GUID programs.\n\n\t Note that it is no bug that the strings in the first two `strncmp'\n\t calls are longer than the sequence which is actually tested.  */\n      if ((((strncmp (&name[1], \"ORIGIN}\", 6) == 0\n\t     && (!__libc_enable_secure\n\t\t || ((name[7] == '\\0' || (is_path && name[7] == ':'))\n\t\t     && (name == start || (is_path && name[-1] == ':'))))\n\t     && (len = 7) != 0)\n\t    || (strncmp (&name[1], \"PLATFORM}\", 8) == 0 && (len = 9) != 0))\n\t   && (name[len] == '\\0' || name[len] == '/'\n\t       || (is_path && name[len] == ':')))\n\t  || (name[1] == '{'\n\t      && ((strncmp (&name[2], \"ORIGIN}\", 7) == 0\n\t\t   && (!__libc_enable_secure\n\t\t       || ((name[9] == '\\0' || (is_path && name[9] == ':'))\n\t\t\t   && (name == start || (is_path && name[-1] == ':'))))\n\t\t   && (len = 9) != 0)\n\t\t  || (strncmp (&name[2], \"PLATFORM}\", 9) == 0\n\t\t      && (len = 11) != 0))))\n\t++cnt;\n\n      name = strchr (name + len, '$');\n    }\n  while (name != NULL);\n\n  return cnt;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,21 +1,31 @@\n size_t\n _dl_dst_count (const char *name, int is_path)\n {\n+  const char *const start = name;\n   size_t cnt = 0;\n \n   do\n     {\n       size_t len = 1;\n \n-      /* $ORIGIN is not expanded for SUID/GUID programs.  */\n-      if ((((!__libc_enable_secure\n-\t     && strncmp (&name[1], \"ORIGIN\", 6) == 0 && (len = 7) != 0)\n-\t    || (strncmp (&name[1], \"PLATFORM\", 8) == 0 && (len = 9) != 0))\n+      /* $ORIGIN is not expanded for SUID/GUID programs.\n+\n+\t Note that it is no bug that the strings in the first two `strncmp'\n+\t calls are longer than the sequence which is actually tested.  */\n+      if ((((strncmp (&name[1], \"ORIGIN}\", 6) == 0\n+\t     && (!__libc_enable_secure\n+\t\t || ((name[7] == '\\0' || (is_path && name[7] == ':'))\n+\t\t     && (name == start || (is_path && name[-1] == ':'))))\n+\t     && (len = 7) != 0)\n+\t    || (strncmp (&name[1], \"PLATFORM}\", 8) == 0 && (len = 9) != 0))\n \t   && (name[len] == '\\0' || name[len] == '/'\n \t       || (is_path && name[len] == ':')))\n \t  || (name[1] == '{'\n-\t      && ((!__libc_enable_secure\n-\t\t   && strncmp (&name[2], \"ORIGIN}\", 7) == 0 && (len = 9) != 0)\n+\t      && ((strncmp (&name[2], \"ORIGIN}\", 7) == 0\n+\t\t   && (!__libc_enable_secure\n+\t\t       || ((name[9] == '\\0' || (is_path && name[9] == ':'))\n+\t\t\t   && (name == start || (is_path && name[-1] == ':'))))\n+\t\t   && (len = 9) != 0)\n \t\t  || (strncmp (&name[2], \"PLATFORM}\", 9) == 0\n \t\t      && (len = 11) != 0))))\n \t++cnt;",
        "diff_line_info": {
            "deleted_lines": [
                "      /* $ORIGIN is not expanded for SUID/GUID programs.  */",
                "      if ((((!__libc_enable_secure",
                "\t     && strncmp (&name[1], \"ORIGIN\", 6) == 0 && (len = 7) != 0)",
                "\t    || (strncmp (&name[1], \"PLATFORM\", 8) == 0 && (len = 9) != 0))",
                "\t      && ((!__libc_enable_secure",
                "\t\t   && strncmp (&name[2], \"ORIGIN}\", 7) == 0 && (len = 9) != 0)"
            ],
            "added_lines": [
                "  const char *const start = name;",
                "      /* $ORIGIN is not expanded for SUID/GUID programs.",
                "",
                "\t Note that it is no bug that the strings in the first two `strncmp'",
                "\t calls are longer than the sequence which is actually tested.  */",
                "      if ((((strncmp (&name[1], \"ORIGIN}\", 6) == 0",
                "\t     && (!__libc_enable_secure",
                "\t\t || ((name[7] == '\\0' || (is_path && name[7] == ':'))",
                "\t\t     && (name == start || (is_path && name[-1] == ':'))))",
                "\t     && (len = 7) != 0)",
                "\t    || (strncmp (&name[1], \"PLATFORM}\", 8) == 0 && (len = 9) != 0))",
                "\t      && ((strncmp (&name[2], \"ORIGIN}\", 7) == 0",
                "\t\t   && (!__libc_enable_secure",
                "\t\t       || ((name[9] == '\\0' || (is_path && name[9] == ':'))",
                "\t\t\t   && (name == start || (is_path && name[-1] == ':'))))",
                "\t\t   && (len = 9) != 0)"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-15523",
        "func_name": "LINBIT/csync2/conn_activate_ssl",
        "description": "An issue was discovered in LINBIT csync2 through 2.0. It does not correctly check for the return value GNUTLS_E_WARNING_ALERT_RECEIVED of the gnutls_handshake() function. It neglects to call this function again, as required by the design of the API.",
        "git_url": "https://github.com/LINBIT/csync2/commit/92742544a56bcbcd9ec99ca15f898b31797e39e2",
        "commit_title": "repeat gnutls_handshake() call in case of warnings",
        "commit_text": " that's what the semantics of this call require",
        "func_before": "int conn_activate_ssl(int server_role)\n{\n\tgnutls_alert_description_t alrt;\n\tchar *ssl_keyfile;\n\tchar *ssl_certfile;\n\tint err;\n\n\tif (csync_conn_usessl)\n\t\treturn 0;\n\n\tASPRINTF(&ssl_keyfile, \"%s/csync2_ssl_key.pem\", systemdir);\n\tASPRINTF(&ssl_certfile, \"%s/csync2_ssl_cert.pem\", systemdir);\n\n\tgnutls_global_init();\n\tgnutls_global_set_log_function(ssl_log);\n\tgnutls_global_set_log_level(10);\n\n\tgnutls_certificate_allocate_credentials(&conn_x509_cred);\n\n\terr = gnutls_certificate_set_x509_key_file(conn_x509_cred, ssl_certfile, ssl_keyfile, GNUTLS_X509_FMT_PEM);\n\tif(err != GNUTLS_E_SUCCESS) {\n\t\tgnutls_certificate_free_credentials(conn_x509_cred);\n\t\tgnutls_global_deinit();\n\n\t\tcsync_fatal(\n\t\t\t\"SSL: failed to use key file %s and/or certificate file %s: %s (%s)\\n\",\n\t\t\tssl_keyfile,\n\t\t\tssl_certfile,\n\t\t\tgnutls_strerror(err),\n\t\t\tgnutls_strerror_name(err)\n\t\t);\n\t}\n\n\tif(server_role) {\n\t\tgnutls_certificate_free_cas(conn_x509_cred);\n\n\t\tif(gnutls_certificate_set_x509_trust_file(conn_x509_cred, ssl_certfile, GNUTLS_X509_FMT_PEM) < 1) {\n\t\t\tgnutls_certificate_free_credentials(conn_x509_cred);\n\t\t\tgnutls_global_deinit();\n\n\t\t\tcsync_fatal(\n\t\t\t\t\"SSL: failed to use certificate file %s as CA.\\n\",\n\t\t\t\tssl_certfile\n\t\t\t);\n\t\t}\n\t} else\n\t\tgnutls_certificate_free_ca_names(conn_x509_cred);\n\n\tgnutls_init(&conn_tls_session, (server_role ? GNUTLS_SERVER : GNUTLS_CLIENT));\n\tgnutls_priority_set_direct(conn_tls_session, \"PERFORMANCE\", NULL);\n\tgnutls_credentials_set(conn_tls_session, GNUTLS_CRD_CERTIFICATE, conn_x509_cred);\n\n\tif(server_role) {\n\t\tgnutls_certificate_send_x509_rdn_sequence(conn_tls_session, 0);\n\t\tgnutls_certificate_server_set_request(conn_tls_session, GNUTLS_CERT_REQUIRE);\n\t}\n\n\tgnutls_transport_set_ptr2(\n\t\tconn_tls_session,\n\t\t(gnutls_transport_ptr_t)(long)conn_fd_in,\n\t\t(gnutls_transport_ptr_t)(long)conn_fd_out\n\t);\n\n\terr = gnutls_handshake(conn_tls_session);\n\tswitch(err) {\n\tcase GNUTLS_E_SUCCESS:\n\t\tbreak;\n\n\tcase GNUTLS_E_WARNING_ALERT_RECEIVED:\n\t\talrt = gnutls_alert_get(conn_tls_session);\n\t\tfprintf(\n\t\t\tcsync_debug_out,\n\t\t\t\"SSL: warning alert received from peer: %d (%s).\\n\",\n\t\t\talrt, gnutls_alert_get_name(alrt)\n\t\t);\n\t\tbreak;\n\n\tcase GNUTLS_E_FATAL_ALERT_RECEIVED:\n\t\talrt = gnutls_alert_get(conn_tls_session);\n\t\tfprintf(\n\t\t\tcsync_debug_out,\n\t\t\t\"SSL: fatal alert received from peer: %d (%s).\\n\",\n\t\t\talrt, gnutls_alert_get_name(alrt)\n\t\t);\n\n\tdefault:\n\t\tgnutls_bye(conn_tls_session, GNUTLS_SHUT_RDWR);\n\t\tgnutls_deinit(conn_tls_session);\n\t\tgnutls_certificate_free_credentials(conn_x509_cred);\n\t\tgnutls_global_deinit();\n\n\t\tcsync_fatal(\n\t\t\t\"SSL: handshake failed: %s (%s)\\n\",\n\t\t\tgnutls_strerror(err),\n\t\t\tgnutls_strerror_name(err)\n\t\t);\n\t}\n\n\tcsync_conn_usessl = 1;\n\n\treturn 0;\n}",
        "func": "int conn_activate_ssl(int server_role)\n{\n\tgnutls_alert_description_t alrt;\n\tchar *ssl_keyfile;\n\tchar *ssl_certfile;\n\tint err;\n\tint handshake_repeat = 0;\n\n\tif (csync_conn_usessl)\n\t\treturn 0;\n\n\tASPRINTF(&ssl_keyfile, \"%s/csync2_ssl_key.pem\", systemdir);\n\tASPRINTF(&ssl_certfile, \"%s/csync2_ssl_cert.pem\", systemdir);\n\n\tgnutls_global_init();\n\tgnutls_global_set_log_function(ssl_log);\n\tgnutls_global_set_log_level(10);\n\n\tgnutls_certificate_allocate_credentials(&conn_x509_cred);\n\n\terr = gnutls_certificate_set_x509_key_file(conn_x509_cred, ssl_certfile, ssl_keyfile, GNUTLS_X509_FMT_PEM);\n\tif(err != GNUTLS_E_SUCCESS) {\n\t\tgnutls_certificate_free_credentials(conn_x509_cred);\n\t\tgnutls_global_deinit();\n\n\t\tcsync_fatal(\n\t\t\t\"SSL: failed to use key file %s and/or certificate file %s: %s (%s)\\n\",\n\t\t\tssl_keyfile,\n\t\t\tssl_certfile,\n\t\t\tgnutls_strerror(err),\n\t\t\tgnutls_strerror_name(err)\n\t\t);\n\t}\n\n\tif(server_role) {\n\t\tgnutls_certificate_free_cas(conn_x509_cred);\n\n\t\tif(gnutls_certificate_set_x509_trust_file(conn_x509_cred, ssl_certfile, GNUTLS_X509_FMT_PEM) < 1) {\n\t\t\tgnutls_certificate_free_credentials(conn_x509_cred);\n\t\t\tgnutls_global_deinit();\n\n\t\t\tcsync_fatal(\n\t\t\t\t\"SSL: failed to use certificate file %s as CA.\\n\",\n\t\t\t\tssl_certfile\n\t\t\t);\n\t\t}\n\t} else\n\t\tgnutls_certificate_free_ca_names(conn_x509_cred);\n\n\tgnutls_init(&conn_tls_session, (server_role ? GNUTLS_SERVER : GNUTLS_CLIENT));\n\tgnutls_priority_set_direct(conn_tls_session, \"PERFORMANCE\", NULL);\n\tgnutls_credentials_set(conn_tls_session, GNUTLS_CRD_CERTIFICATE, conn_x509_cred);\n\n\tif(server_role) {\n\t\tgnutls_certificate_send_x509_rdn_sequence(conn_tls_session, 0);\n\t\tgnutls_certificate_server_set_request(conn_tls_session, GNUTLS_CERT_REQUIRE);\n\t}\n\n\tgnutls_transport_set_ptr2(\n\t\tconn_tls_session,\n\t\t(gnutls_transport_ptr_t)(long)conn_fd_in,\n\t\t(gnutls_transport_ptr_t)(long)conn_fd_out\n\t);\n\n\n\tdo {\n\t\thandshake_repeat = 0;\n\t\terr = gnutls_handshake(conn_tls_session);\n\t\tswitch(err) {\n\t\tcase GNUTLS_E_SUCCESS:\n\t\t\tbreak;\n\n\t\tcase GNUTLS_E_WARNING_ALERT_RECEIVED:\n\t\t\talrt = gnutls_alert_get(conn_tls_session);\n\t\t\tfprintf(\n\t\t\t\tcsync_debug_out,\n\t\t\t\t\"SSL: warning alert received from peer: %d (%s).\\n\",\n\t\t\t\talrt, gnutls_alert_get_name(alrt)\n\t\t\t);\n\t\t\thandshake_repeat = 1;\n\t\t\tbreak;\n\n\t\tcase GNUTLS_E_FATAL_ALERT_RECEIVED:\n\t\t\talrt = gnutls_alert_get(conn_tls_session);\n\t\t\tfprintf(\n\t\t\t\tcsync_debug_out,\n\t\t\t\t\"SSL: fatal alert received from peer: %d (%s).\\n\",\n\t\t\t\talrt, gnutls_alert_get_name(alrt)\n\t\t\t);\n\t\t\t// fall-through!\n\n\t\tdefault:\n\t\t\tgnutls_bye(conn_tls_session, GNUTLS_SHUT_RDWR);\n\t\t\tgnutls_deinit(conn_tls_session);\n\t\t\tgnutls_certificate_free_credentials(conn_x509_cred);\n\t\t\tgnutls_global_deinit();\n\n\t\t\tcsync_fatal(\n\t\t\t\t\"SSL: handshake failed: %s (%s)\\n\",\n\t\t\t\tgnutls_strerror(err),\n\t\t\t\tgnutls_strerror_name(err)\n\t\t\t);\n\t\t}\n\t} while (handshake_repeat);\n\n\tcsync_conn_usessl = 1;\n\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,6 +4,7 @@\n \tchar *ssl_keyfile;\n \tchar *ssl_certfile;\n \tint err;\n+\tint handshake_repeat = 0;\n \n \tif (csync_conn_usessl)\n \t\treturn 0;\n@@ -61,40 +62,46 @@\n \t\t(gnutls_transport_ptr_t)(long)conn_fd_out\n \t);\n \n-\terr = gnutls_handshake(conn_tls_session);\n-\tswitch(err) {\n-\tcase GNUTLS_E_SUCCESS:\n-\t\tbreak;\n \n-\tcase GNUTLS_E_WARNING_ALERT_RECEIVED:\n-\t\talrt = gnutls_alert_get(conn_tls_session);\n-\t\tfprintf(\n-\t\t\tcsync_debug_out,\n-\t\t\t\"SSL: warning alert received from peer: %d (%s).\\n\",\n-\t\t\talrt, gnutls_alert_get_name(alrt)\n-\t\t);\n-\t\tbreak;\n+\tdo {\n+\t\thandshake_repeat = 0;\n+\t\terr = gnutls_handshake(conn_tls_session);\n+\t\tswitch(err) {\n+\t\tcase GNUTLS_E_SUCCESS:\n+\t\t\tbreak;\n \n-\tcase GNUTLS_E_FATAL_ALERT_RECEIVED:\n-\t\talrt = gnutls_alert_get(conn_tls_session);\n-\t\tfprintf(\n-\t\t\tcsync_debug_out,\n-\t\t\t\"SSL: fatal alert received from peer: %d (%s).\\n\",\n-\t\t\talrt, gnutls_alert_get_name(alrt)\n-\t\t);\n+\t\tcase GNUTLS_E_WARNING_ALERT_RECEIVED:\n+\t\t\talrt = gnutls_alert_get(conn_tls_session);\n+\t\t\tfprintf(\n+\t\t\t\tcsync_debug_out,\n+\t\t\t\t\"SSL: warning alert received from peer: %d (%s).\\n\",\n+\t\t\t\talrt, gnutls_alert_get_name(alrt)\n+\t\t\t);\n+\t\t\thandshake_repeat = 1;\n+\t\t\tbreak;\n \n-\tdefault:\n-\t\tgnutls_bye(conn_tls_session, GNUTLS_SHUT_RDWR);\n-\t\tgnutls_deinit(conn_tls_session);\n-\t\tgnutls_certificate_free_credentials(conn_x509_cred);\n-\t\tgnutls_global_deinit();\n+\t\tcase GNUTLS_E_FATAL_ALERT_RECEIVED:\n+\t\t\talrt = gnutls_alert_get(conn_tls_session);\n+\t\t\tfprintf(\n+\t\t\t\tcsync_debug_out,\n+\t\t\t\t\"SSL: fatal alert received from peer: %d (%s).\\n\",\n+\t\t\t\talrt, gnutls_alert_get_name(alrt)\n+\t\t\t);\n+\t\t\t// fall-through!\n \n-\t\tcsync_fatal(\n-\t\t\t\"SSL: handshake failed: %s (%s)\\n\",\n-\t\t\tgnutls_strerror(err),\n-\t\t\tgnutls_strerror_name(err)\n-\t\t);\n-\t}\n+\t\tdefault:\n+\t\t\tgnutls_bye(conn_tls_session, GNUTLS_SHUT_RDWR);\n+\t\t\tgnutls_deinit(conn_tls_session);\n+\t\t\tgnutls_certificate_free_credentials(conn_x509_cred);\n+\t\t\tgnutls_global_deinit();\n+\n+\t\t\tcsync_fatal(\n+\t\t\t\t\"SSL: handshake failed: %s (%s)\\n\",\n+\t\t\t\tgnutls_strerror(err),\n+\t\t\t\tgnutls_strerror_name(err)\n+\t\t\t);\n+\t\t}\n+\t} while (handshake_repeat);\n \n \tcsync_conn_usessl = 1;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\terr = gnutls_handshake(conn_tls_session);",
                "\tswitch(err) {",
                "\tcase GNUTLS_E_SUCCESS:",
                "\t\tbreak;",
                "\tcase GNUTLS_E_WARNING_ALERT_RECEIVED:",
                "\t\talrt = gnutls_alert_get(conn_tls_session);",
                "\t\tfprintf(",
                "\t\t\tcsync_debug_out,",
                "\t\t\t\"SSL: warning alert received from peer: %d (%s).\\n\",",
                "\t\t\talrt, gnutls_alert_get_name(alrt)",
                "\t\t);",
                "\t\tbreak;",
                "\tcase GNUTLS_E_FATAL_ALERT_RECEIVED:",
                "\t\talrt = gnutls_alert_get(conn_tls_session);",
                "\t\tfprintf(",
                "\t\t\tcsync_debug_out,",
                "\t\t\t\"SSL: fatal alert received from peer: %d (%s).\\n\",",
                "\t\t\talrt, gnutls_alert_get_name(alrt)",
                "\t\t);",
                "\tdefault:",
                "\t\tgnutls_bye(conn_tls_session, GNUTLS_SHUT_RDWR);",
                "\t\tgnutls_deinit(conn_tls_session);",
                "\t\tgnutls_certificate_free_credentials(conn_x509_cred);",
                "\t\tgnutls_global_deinit();",
                "\t\tcsync_fatal(",
                "\t\t\t\"SSL: handshake failed: %s (%s)\\n\",",
                "\t\t\tgnutls_strerror(err),",
                "\t\t\tgnutls_strerror_name(err)",
                "\t\t);",
                "\t}"
            ],
            "added_lines": [
                "\tint handshake_repeat = 0;",
                "\tdo {",
                "\t\thandshake_repeat = 0;",
                "\t\terr = gnutls_handshake(conn_tls_session);",
                "\t\tswitch(err) {",
                "\t\tcase GNUTLS_E_SUCCESS:",
                "\t\t\tbreak;",
                "\t\tcase GNUTLS_E_WARNING_ALERT_RECEIVED:",
                "\t\t\talrt = gnutls_alert_get(conn_tls_session);",
                "\t\t\tfprintf(",
                "\t\t\t\tcsync_debug_out,",
                "\t\t\t\t\"SSL: warning alert received from peer: %d (%s).\\n\",",
                "\t\t\t\talrt, gnutls_alert_get_name(alrt)",
                "\t\t\t);",
                "\t\t\thandshake_repeat = 1;",
                "\t\t\tbreak;",
                "\t\tcase GNUTLS_E_FATAL_ALERT_RECEIVED:",
                "\t\t\talrt = gnutls_alert_get(conn_tls_session);",
                "\t\t\tfprintf(",
                "\t\t\t\tcsync_debug_out,",
                "\t\t\t\t\"SSL: fatal alert received from peer: %d (%s).\\n\",",
                "\t\t\t\talrt, gnutls_alert_get_name(alrt)",
                "\t\t\t);",
                "\t\t\t// fall-through!",
                "\t\tdefault:",
                "\t\t\tgnutls_bye(conn_tls_session, GNUTLS_SHUT_RDWR);",
                "\t\t\tgnutls_deinit(conn_tls_session);",
                "\t\t\tgnutls_certificate_free_credentials(conn_x509_cred);",
                "\t\t\tgnutls_global_deinit();",
                "",
                "\t\t\tcsync_fatal(",
                "\t\t\t\t\"SSL: handshake failed: %s (%s)\\n\",",
                "\t\t\t\tgnutls_strerror(err),",
                "\t\t\t\tgnutls_strerror_name(err)",
                "\t\t\t);",
                "\t\t}",
                "\t} while (handshake_repeat);"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-3108",
        "func_name": "torvalds/linux/kfd_parse_subtype_iolink",
        "description": "An issue was discovered in the Linux kernel through 5.16-rc6. kfd_parse_subtype_iolink in drivers/gpu/drm/amd/amdkfd/kfd_crat.c lacks check of the return value of kmemdup().",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=v5.19-rc2&h=abfaf0eee97925905e742aa3b0b72e04a918fa9e",
        "commit_title": "As the possible failure of the allocation, kmemdup() may return NULL",
        "commit_text": "pointer. Therefore, it should be better to check the 'props2' in order to prevent the dereference of NULL pointer.  ",
        "func_before": "static int kfd_parse_subtype_iolink(struct crat_subtype_iolink *iolink,\n\t\t\t\t\tstruct list_head *device_list)\n{\n\tstruct kfd_iolink_properties *props = NULL, *props2;\n\tstruct kfd_topology_device *dev, *to_dev;\n\tuint32_t id_from;\n\tuint32_t id_to;\n\n\tid_from = iolink->proximity_domain_from;\n\tid_to = iolink->proximity_domain_to;\n\n\tpr_debug(\"Found IO link entry in CRAT table with id_from=%d, id_to %d\\n\",\n\t\t\tid_from, id_to);\n\tlist_for_each_entry(dev, device_list, list) {\n\t\tif (id_from == dev->proximity_domain) {\n\t\t\tprops = kfd_alloc_struct(props);\n\t\t\tif (!props)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tprops->node_from = id_from;\n\t\t\tprops->node_to = id_to;\n\t\t\tprops->ver_maj = iolink->version_major;\n\t\t\tprops->ver_min = iolink->version_minor;\n\t\t\tprops->iolink_type = iolink->io_interface_type;\n\n\t\t\tif (props->iolink_type == CRAT_IOLINK_TYPE_PCIEXPRESS)\n\t\t\t\tprops->weight = 20;\n\t\t\telse if (props->iolink_type == CRAT_IOLINK_TYPE_XGMI)\n\t\t\t\tprops->weight = 15 * iolink->num_hops_xgmi;\n\t\t\telse\n\t\t\t\tprops->weight = node_distance(id_from, id_to);\n\n\t\t\tprops->min_latency = iolink->minimum_latency;\n\t\t\tprops->max_latency = iolink->maximum_latency;\n\t\t\tprops->min_bandwidth = iolink->minimum_bandwidth_mbs;\n\t\t\tprops->max_bandwidth = iolink->maximum_bandwidth_mbs;\n\t\t\tprops->rec_transfer_size =\n\t\t\t\t\tiolink->recommended_transfer_size;\n\n\t\t\tdev->io_link_count++;\n\t\t\tdev->node_props.io_links_count++;\n\t\t\tlist_add_tail(&props->list, &dev->io_link_props);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* CPU topology is created before GPUs are detected, so CPU->GPU\n\t * links are not built at that time. If a PCIe type is discovered, it\n\t * means a GPU is detected and we are adding GPU->CPU to the topology.\n\t * At this time, also add the corresponded CPU->GPU link if GPU\n\t * is large bar.\n\t * For xGMI, we only added the link with one direction in the crat\n\t * table, add corresponded reversed direction link now.\n\t */\n\tif (props && (iolink->flags & CRAT_IOLINK_FLAGS_BI_DIRECTIONAL)) {\n\t\tto_dev = kfd_topology_device_by_proximity_domain(id_to);\n\t\tif (!to_dev)\n\t\t\treturn -ENODEV;\n\t\t/* same everything but the other direction */\n\t\tprops2 = kmemdup(props, sizeof(*props2), GFP_KERNEL);\n\t\tprops2->node_from = id_to;\n\t\tprops2->node_to = id_from;\n\t\tprops2->kobj = NULL;\n\t\tto_dev->io_link_count++;\n\t\tto_dev->node_props.io_links_count++;\n\t\tlist_add_tail(&props2->list, &to_dev->io_link_props);\n\t}\n\n\treturn 0;\n}",
        "func": "static int kfd_parse_subtype_iolink(struct crat_subtype_iolink *iolink,\n\t\t\t\t\tstruct list_head *device_list)\n{\n\tstruct kfd_iolink_properties *props = NULL, *props2;\n\tstruct kfd_topology_device *dev, *to_dev;\n\tuint32_t id_from;\n\tuint32_t id_to;\n\n\tid_from = iolink->proximity_domain_from;\n\tid_to = iolink->proximity_domain_to;\n\n\tpr_debug(\"Found IO link entry in CRAT table with id_from=%d, id_to %d\\n\",\n\t\t\tid_from, id_to);\n\tlist_for_each_entry(dev, device_list, list) {\n\t\tif (id_from == dev->proximity_domain) {\n\t\t\tprops = kfd_alloc_struct(props);\n\t\t\tif (!props)\n\t\t\t\treturn -ENOMEM;\n\n\t\t\tprops->node_from = id_from;\n\t\t\tprops->node_to = id_to;\n\t\t\tprops->ver_maj = iolink->version_major;\n\t\t\tprops->ver_min = iolink->version_minor;\n\t\t\tprops->iolink_type = iolink->io_interface_type;\n\n\t\t\tif (props->iolink_type == CRAT_IOLINK_TYPE_PCIEXPRESS)\n\t\t\t\tprops->weight = 20;\n\t\t\telse if (props->iolink_type == CRAT_IOLINK_TYPE_XGMI)\n\t\t\t\tprops->weight = 15 * iolink->num_hops_xgmi;\n\t\t\telse\n\t\t\t\tprops->weight = node_distance(id_from, id_to);\n\n\t\t\tprops->min_latency = iolink->minimum_latency;\n\t\t\tprops->max_latency = iolink->maximum_latency;\n\t\t\tprops->min_bandwidth = iolink->minimum_bandwidth_mbs;\n\t\t\tprops->max_bandwidth = iolink->maximum_bandwidth_mbs;\n\t\t\tprops->rec_transfer_size =\n\t\t\t\t\tiolink->recommended_transfer_size;\n\n\t\t\tdev->io_link_count++;\n\t\t\tdev->node_props.io_links_count++;\n\t\t\tlist_add_tail(&props->list, &dev->io_link_props);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* CPU topology is created before GPUs are detected, so CPU->GPU\n\t * links are not built at that time. If a PCIe type is discovered, it\n\t * means a GPU is detected and we are adding GPU->CPU to the topology.\n\t * At this time, also add the corresponded CPU->GPU link if GPU\n\t * is large bar.\n\t * For xGMI, we only added the link with one direction in the crat\n\t * table, add corresponded reversed direction link now.\n\t */\n\tif (props && (iolink->flags & CRAT_IOLINK_FLAGS_BI_DIRECTIONAL)) {\n\t\tto_dev = kfd_topology_device_by_proximity_domain(id_to);\n\t\tif (!to_dev)\n\t\t\treturn -ENODEV;\n\t\t/* same everything but the other direction */\n\t\tprops2 = kmemdup(props, sizeof(*props2), GFP_KERNEL);\n\t\tif (!props2)\n\t\t\treturn -ENOMEM;\n\n\t\tprops2->node_from = id_to;\n\t\tprops2->node_to = id_from;\n\t\tprops2->kobj = NULL;\n\t\tto_dev->io_link_count++;\n\t\tto_dev->node_props.io_links_count++;\n\t\tlist_add_tail(&props2->list, &to_dev->io_link_props);\n\t}\n\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -58,6 +58,9 @@\n \t\t\treturn -ENODEV;\n \t\t/* same everything but the other direction */\n \t\tprops2 = kmemdup(props, sizeof(*props2), GFP_KERNEL);\n+\t\tif (!props2)\n+\t\t\treturn -ENOMEM;\n+\n \t\tprops2->node_from = id_to;\n \t\tprops2->node_to = id_from;\n \t\tprops2->kobj = NULL;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\tif (!props2)",
                "\t\t\treturn -ENOMEM;",
                ""
            ]
        }
    }
]