[
    {
        "cve_id": "CVE-2019-12735",
        "func_name": "neovim/openscript",
        "description": "getchar.c in Vim before 8.1.1365 and Neovim before 0.3.6 allows remote attackers to execute arbitrary OS commands via the :source! command in a modeline, as demonstrated by execute in Vim, and assert_fails or nvim_input in Neovim.",
        "git_url": "https://github.com/neovim/neovim/commit/5e611f32841e746932fbcbea292ca502ed9e694b",
        "commit_title": "vim-patch:8.1.1365: source command doesn't check for the sandbox",
        "commit_text": " Problem:    Source command doesn't check for the sandbox. (Armin Razmjou) Solution:   Check for the sandbox when sourcing a file. https://github.com/vim/vim/commit/53575521406739cf20bbe4e384d88e7dca11f040",
        "func_before": "void \nopenscript (\n    char_u *name,\n    int directly                   /* when TRUE execute directly */\n)\n{\n  if (curscript + 1 == NSCRIPT) {\n    EMSG(_(e_nesting));\n    return;\n  }\n  if (ignore_script)\n    /* Not reading from script, also don't open one.  Warning message? */\n    return;\n\n  if (scriptin[curscript] != NULL)      /* already reading script */\n    ++curscript;\n  /* use NameBuff for expanded name */\n  expand_env(name, NameBuff, MAXPATHL);\n  int error;\n  if ((scriptin[curscript] = file_open_new(&error, (char *)NameBuff,\n                                           kFileReadOnly, 0)) == NULL) {\n    emsgf(_(e_notopen_2), name, os_strerror(error));\n    if (curscript) {\n      curscript--;\n    }\n    return;\n  }\n  save_typebuf();\n\n  /*\n   * Execute the commands from the file right now when using \":source!\"\n   * after \":global\" or \":argdo\" or in a loop.  Also when another command\n   * follows.  This means the display won't be updated.  Don't do this\n   * always, \"make test\" would fail.\n   */\n  if (directly) {\n    oparg_T oa;\n    int oldcurscript;\n    int save_State = State;\n    int save_restart_edit = restart_edit;\n    int save_insertmode = p_im;\n    int save_finish_op = finish_op;\n    int save_msg_scroll = msg_scroll;\n\n    State = NORMAL;\n    msg_scroll = FALSE;         /* no msg scrolling in Normal mode */\n    restart_edit = 0;           /* don't go to Insert mode */\n    p_im = FALSE;               /* don't use 'insertmode' */\n    clear_oparg(&oa);\n    finish_op = FALSE;\n\n    oldcurscript = curscript;\n    do {\n      update_topline_cursor();          /* update cursor position and topline */\n      normal_cmd(&oa, FALSE);           /* execute one command */\n      vpeekc();                         /* check for end of file */\n    } while (scriptin[oldcurscript] != NULL);\n\n    State = save_State;\n    msg_scroll = save_msg_scroll;\n    restart_edit = save_restart_edit;\n    p_im = save_insertmode;\n    finish_op = save_finish_op;\n  }\n}",
        "func": "void \nopenscript (\n    char_u *name,\n    int directly                   /* when TRUE execute directly */\n)\n{\n  if (curscript + 1 == NSCRIPT) {\n    EMSG(_(e_nesting));\n    return;\n  }\n\n  // Disallow sourcing a file in the sandbox, the commands would be executed\n  // later, possibly outside of the sandbox.\n  if (check_secure()) {\n    return;\n  }\n\n  if (ignore_script)\n    /* Not reading from script, also don't open one.  Warning message? */\n    return;\n\n  if (scriptin[curscript] != NULL)      /* already reading script */\n    ++curscript;\n  /* use NameBuff for expanded name */\n  expand_env(name, NameBuff, MAXPATHL);\n  int error;\n  if ((scriptin[curscript] = file_open_new(&error, (char *)NameBuff,\n                                           kFileReadOnly, 0)) == NULL) {\n    emsgf(_(e_notopen_2), name, os_strerror(error));\n    if (curscript) {\n      curscript--;\n    }\n    return;\n  }\n  save_typebuf();\n\n  /*\n   * Execute the commands from the file right now when using \":source!\"\n   * after \":global\" or \":argdo\" or in a loop.  Also when another command\n   * follows.  This means the display won't be updated.  Don't do this\n   * always, \"make test\" would fail.\n   */\n  if (directly) {\n    oparg_T oa;\n    int oldcurscript;\n    int save_State = State;\n    int save_restart_edit = restart_edit;\n    int save_insertmode = p_im;\n    int save_finish_op = finish_op;\n    int save_msg_scroll = msg_scroll;\n\n    State = NORMAL;\n    msg_scroll = FALSE;         /* no msg scrolling in Normal mode */\n    restart_edit = 0;           /* don't go to Insert mode */\n    p_im = FALSE;               /* don't use 'insertmode' */\n    clear_oparg(&oa);\n    finish_op = FALSE;\n\n    oldcurscript = curscript;\n    do {\n      update_topline_cursor();          /* update cursor position and topline */\n      normal_cmd(&oa, FALSE);           /* execute one command */\n      vpeekc();                         /* check for end of file */\n    } while (scriptin[oldcurscript] != NULL);\n\n    State = save_State;\n    msg_scroll = save_msg_scroll;\n    restart_edit = save_restart_edit;\n    p_im = save_insertmode;\n    finish_op = save_finish_op;\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -8,6 +8,13 @@\n     EMSG(_(e_nesting));\n     return;\n   }\n+\n+  // Disallow sourcing a file in the sandbox, the commands would be executed\n+  // later, possibly outside of the sandbox.\n+  if (check_secure()) {\n+    return;\n+  }\n+\n   if (ignore_script)\n     /* Not reading from script, also don't open one.  Warning message? */\n     return;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "  // Disallow sourcing a file in the sandbox, the commands would be executed",
                "  // later, possibly outside of the sandbox.",
                "  if (check_secure()) {",
                "    return;",
                "  }",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2019-12735",
        "func_name": "vim/openscript",
        "description": "getchar.c in Vim before 8.1.1365 and Neovim before 0.3.6 allows remote attackers to execute arbitrary OS commands via the :source! command in a modeline, as demonstrated by execute in Vim, and assert_fails or nvim_input in Neovim.",
        "git_url": "https://github.com/vim/vim/commit/53575521406739cf20bbe4e384d88e7dca11f040",
        "commit_title": "patch 8.1.1365: source command doesn't check for the sandbox",
        "commit_text": " Problem:    Source command doesn't check for the sandbox. (Armin Razmjou) Solution:   Check for the sandbox when sourcing a file.",
        "func_before": "void\nopenscript(\n    char_u\t*name,\n    int\t\tdirectly)\t/* when TRUE execute directly */\n{\n    if (curscript + 1 == NSCRIPT)\n    {\n\temsg(_(e_nesting));\n\treturn;\n    }\n#ifdef FEAT_EVAL\n    if (ignore_script)\n\t/* Not reading from script, also don't open one.  Warning message? */\n\treturn;\n#endif\n\n    if (scriptin[curscript] != NULL)\t/* already reading script */\n\t++curscript;\n\t\t\t\t/* use NameBuff for expanded name */\n    expand_env(name, NameBuff, MAXPATHL);\n    if ((scriptin[curscript] = mch_fopen((char *)NameBuff, READBIN)) == NULL)\n    {\n\tsemsg(_(e_notopen), name);\n\tif (curscript)\n\t    --curscript;\n\treturn;\n    }\n    if (save_typebuf() == FAIL)\n\treturn;\n\n    /*\n     * Execute the commands from the file right now when using \":source!\"\n     * after \":global\" or \":argdo\" or in a loop.  Also when another command\n     * follows.  This means the display won't be updated.  Don't do this\n     * always, \"make test\" would fail.\n     */\n    if (directly)\n    {\n\toparg_T\toa;\n\tint\toldcurscript;\n\tint\tsave_State = State;\n\tint\tsave_restart_edit = restart_edit;\n\tint\tsave_insertmode = p_im;\n\tint\tsave_finish_op = finish_op;\n\tint\tsave_msg_scroll = msg_scroll;\n\n\tState = NORMAL;\n\tmsg_scroll = FALSE;\t/* no msg scrolling in Normal mode */\n\trestart_edit = 0;\t/* don't go to Insert mode */\n\tp_im = FALSE;\t\t/* don't use 'insertmode' */\n\tclear_oparg(&oa);\n\tfinish_op = FALSE;\n\n\toldcurscript = curscript;\n\tdo\n\t{\n\t    update_topline_cursor();\t// update cursor position and topline\n\t    normal_cmd(&oa, FALSE);\t// execute one command\n\t    vpeekc();\t\t\t// check for end of file\n\t}\n\twhile (scriptin[oldcurscript] != NULL);\n\n\tState = save_State;\n\tmsg_scroll = save_msg_scroll;\n\trestart_edit = save_restart_edit;\n\tp_im = save_insertmode;\n\tfinish_op = save_finish_op;\n    }\n}",
        "func": "void\nopenscript(\n    char_u\t*name,\n    int\t\tdirectly)\t/* when TRUE execute directly */\n{\n    if (curscript + 1 == NSCRIPT)\n    {\n\temsg(_(e_nesting));\n\treturn;\n    }\n\n    // Disallow sourcing a file in the sandbox, the commands would be executed\n    // later, possibly outside of the sandbox.\n    if (check_secure())\n\treturn;\n\n#ifdef FEAT_EVAL\n    if (ignore_script)\n\t/* Not reading from script, also don't open one.  Warning message? */\n\treturn;\n#endif\n\n    if (scriptin[curscript] != NULL)\t/* already reading script */\n\t++curscript;\n\t\t\t\t/* use NameBuff for expanded name */\n    expand_env(name, NameBuff, MAXPATHL);\n    if ((scriptin[curscript] = mch_fopen((char *)NameBuff, READBIN)) == NULL)\n    {\n\tsemsg(_(e_notopen), name);\n\tif (curscript)\n\t    --curscript;\n\treturn;\n    }\n    if (save_typebuf() == FAIL)\n\treturn;\n\n    /*\n     * Execute the commands from the file right now when using \":source!\"\n     * after \":global\" or \":argdo\" or in a loop.  Also when another command\n     * follows.  This means the display won't be updated.  Don't do this\n     * always, \"make test\" would fail.\n     */\n    if (directly)\n    {\n\toparg_T\toa;\n\tint\toldcurscript;\n\tint\tsave_State = State;\n\tint\tsave_restart_edit = restart_edit;\n\tint\tsave_insertmode = p_im;\n\tint\tsave_finish_op = finish_op;\n\tint\tsave_msg_scroll = msg_scroll;\n\n\tState = NORMAL;\n\tmsg_scroll = FALSE;\t/* no msg scrolling in Normal mode */\n\trestart_edit = 0;\t/* don't go to Insert mode */\n\tp_im = FALSE;\t\t/* don't use 'insertmode' */\n\tclear_oparg(&oa);\n\tfinish_op = FALSE;\n\n\toldcurscript = curscript;\n\tdo\n\t{\n\t    update_topline_cursor();\t// update cursor position and topline\n\t    normal_cmd(&oa, FALSE);\t// execute one command\n\t    vpeekc();\t\t\t// check for end of file\n\t}\n\twhile (scriptin[oldcurscript] != NULL);\n\n\tState = save_State;\n\tmsg_scroll = save_msg_scroll;\n\trestart_edit = save_restart_edit;\n\tp_im = save_insertmode;\n\tfinish_op = save_finish_op;\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -8,6 +8,12 @@\n \temsg(_(e_nesting));\n \treturn;\n     }\n+\n+    // Disallow sourcing a file in the sandbox, the commands would be executed\n+    // later, possibly outside of the sandbox.\n+    if (check_secure())\n+\treturn;\n+\n #ifdef FEAT_EVAL\n     if (ignore_script)\n \t/* Not reading from script, also don't open one.  Warning message? */",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "    // Disallow sourcing a file in the sandbox, the commands would be executed",
                "    // later, possibly outside of the sandbox.",
                "    if (check_secure())",
                "\treturn;",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2019-13640",
        "func_name": "qbittorrent/qBittorrent/Application::runExternalProgram",
        "description": "In qBittorrent before 4.1.7, the function Application::runExternalProgram() located in app/application.cpp allows command injection via shell metacharacters in the torrent name parameter or current tracker parameter, as demonstrated by remote command execution via a crafted name within an RSS feed.",
        "git_url": "https://github.com/qbittorrent/qBittorrent/commit/a610c8567e55516231d199b551e0e7e2dca70cbf",
        "commit_title": "Prevent command injection via \"Run external program\" function",
        "commit_text": " Closes #10925.",
        "func_before": "void Application::runExternalProgram(const BitTorrent::TorrentHandle *torrent) const\n{\n    QString program = Preferences::instance()->getAutoRunProgram().trimmed();\n    program.replace(\"%N\", torrent->name());\n    program.replace(\"%L\", torrent->category());\n\n    QStringList tags = torrent->tags().toList();\n    std::sort(tags.begin(), tags.end(), Utils::String::naturalLessThan<Qt::CaseInsensitive>);\n    program.replace(\"%G\", tags.join(','));\n\n#if defined(Q_OS_WIN)\n    const auto chopPathSep = [](const QString &str) -> QString\n    {\n        if (str.endsWith('\\\\'))\n            return str.mid(0, (str.length() -1));\n        return str;\n    };\n    program.replace(\"%F\", chopPathSep(Utils::Fs::toNativePath(torrent->contentPath())));\n    program.replace(\"%R\", chopPathSep(Utils::Fs::toNativePath(torrent->rootPath())));\n    program.replace(\"%D\", chopPathSep(Utils::Fs::toNativePath(torrent->savePath())));\n#else\n    program.replace(\"%F\", Utils::Fs::toNativePath(torrent->contentPath()));\n    program.replace(\"%R\", Utils::Fs::toNativePath(torrent->rootPath()));\n    program.replace(\"%D\", Utils::Fs::toNativePath(torrent->savePath()));\n#endif\n    program.replace(\"%C\", QString::number(torrent->filesCount()));\n    program.replace(\"%Z\", QString::number(torrent->totalSize()));\n    program.replace(\"%T\", torrent->currentTracker());\n    program.replace(\"%I\", torrent->hash());\n\n    Logger *logger = Logger::instance();\n    logger->addMessage(tr(\"Torrent: %1, running external program, command: %2\").arg(torrent->name(), program));\n\n#if defined(Q_OS_WIN)\n    std::unique_ptr<wchar_t[]> programWchar(new wchar_t[program.length() + 1] {});\n    program.toWCharArray(programWchar.get());\n\n    // Need to split arguments manually because QProcess::startDetached(QString)\n    // will strip off empty parameters.\n    // E.g. `python.exe \"1\" \"\" \"3\"` will become `python.exe \"1\" \"3\"`\n    int argCount = 0;\n    LPWSTR *args = ::CommandLineToArgvW(programWchar.get(), &argCount);\n\n    QStringList argList;\n    for (int i = 1; i < argCount; ++i)\n        argList += QString::fromWCharArray(args[i]);\n\n    QProcess::startDetached(QString::fromWCharArray(args[0]), argList);\n\n    ::LocalFree(args);\n#else\n    QProcess::startDetached(QLatin1String(\"/bin/sh\"), {QLatin1String(\"-c\"), program});\n#endif\n}",
        "func": "void Application::runExternalProgram(const BitTorrent::TorrentHandle *torrent) const\n{\n    QString program = Preferences::instance()->getAutoRunProgram().trimmed();\n    program.replace(\"%N\", torrent->name());\n    program.replace(\"%L\", torrent->category());\n\n    QStringList tags = torrent->tags().toList();\n    std::sort(tags.begin(), tags.end(), Utils::String::naturalLessThan<Qt::CaseInsensitive>);\n    program.replace(\"%G\", tags.join(','));\n\n#if defined(Q_OS_WIN)\n    const auto chopPathSep = [](const QString &str) -> QString\n    {\n        if (str.endsWith('\\\\'))\n            return str.mid(0, (str.length() -1));\n        return str;\n    };\n    program.replace(\"%F\", chopPathSep(Utils::Fs::toNativePath(torrent->contentPath())));\n    program.replace(\"%R\", chopPathSep(Utils::Fs::toNativePath(torrent->rootPath())));\n    program.replace(\"%D\", chopPathSep(Utils::Fs::toNativePath(torrent->savePath())));\n#else\n    program.replace(\"%F\", Utils::Fs::toNativePath(torrent->contentPath()));\n    program.replace(\"%R\", Utils::Fs::toNativePath(torrent->rootPath()));\n    program.replace(\"%D\", Utils::Fs::toNativePath(torrent->savePath()));\n#endif\n    program.replace(\"%C\", QString::number(torrent->filesCount()));\n    program.replace(\"%Z\", QString::number(torrent->totalSize()));\n    program.replace(\"%T\", torrent->currentTracker());\n    program.replace(\"%I\", torrent->hash());\n\n    Logger *logger = Logger::instance();\n    logger->addMessage(tr(\"Torrent: %1, running external program, command: %2\").arg(torrent->name(), program));\n\n#if defined(Q_OS_WIN)\n    std::unique_ptr<wchar_t[]> programWchar(new wchar_t[program.length() + 1] {});\n    program.toWCharArray(programWchar.get());\n\n    // Need to split arguments manually because QProcess::startDetached(QString)\n    // will strip off empty parameters.\n    // E.g. `python.exe \"1\" \"\" \"3\"` will become `python.exe \"1\" \"3\"`\n    int argCount = 0;\n    LPWSTR *args = ::CommandLineToArgvW(programWchar.get(), &argCount);\n\n    QStringList argList;\n    for (int i = 1; i < argCount; ++i)\n        argList += QString::fromWCharArray(args[i]);\n\n    QProcess::startDetached(QString::fromWCharArray(args[0]), argList);\n\n    ::LocalFree(args);\n#else\n    // Cannot give users shell environment by default, as doing so could\n    // enable command injection via torrent name and other arguments\n    // (especially when some automated download mechanism has been setup).\n    // See: https://github.com/qbittorrent/qBittorrent/issues/10925\n    QProcess::startDetached(program);\n#endif\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -49,6 +49,10 @@\n \n     ::LocalFree(args);\n #else\n-    QProcess::startDetached(QLatin1String(\"/bin/sh\"), {QLatin1String(\"-c\"), program});\n+    // Cannot give users shell environment by default, as doing so could\n+    // enable command injection via torrent name and other arguments\n+    // (especially when some automated download mechanism has been setup).\n+    // See: https://github.com/qbittorrent/qBittorrent/issues/10925\n+    QProcess::startDetached(program);\n #endif\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    QProcess::startDetached(QLatin1String(\"/bin/sh\"), {QLatin1String(\"-c\"), program});"
            ],
            "added_lines": [
                "    // Cannot give users shell environment by default, as doing so could",
                "    // enable command injection via torrent name and other arguments",
                "    // (especially when some automated download mechanism has been setup).",
                "    // See: https://github.com/qbittorrent/qBittorrent/issues/10925",
                "    QProcess::startDetached(program);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-16718",
        "func_name": "radareorg/radare2/__filterShell",
        "description": "In radare2 before 3.9.0, a command injection vulnerability exists in bin_symbols() in libr/core/cbin.c. By using a crafted executable file, it's possible to execute arbitrary shell commands with the permissions of the victim. This vulnerability is due to an insufficient fix for CVE-2019-14745 and improper handling of symbol names embedded in executables.",
        "git_url": "https://github.com/radareorg/radare2/commit/5411543a310a470b1257fb93273cdd6e8dfcb3af",
        "commit_title": "More fixes for the CVE-2019-14745",
        "commit_text": "",
        "func_before": "static char *__filterShell(const char *arg) {\n\tr_return_val_if_fail (arg, NULL);\n\tchar *a = malloc (strlen (arg) + 1);\n\tif (!a) {\n\t\treturn NULL;\n\t}\n\tchar *b = a;\n\twhile (*arg) {\n\t\tswitch (*arg) {\n\t\tcase '@':\n\t\tcase '`':\n\t\tcase '|':\n\t\tcase ';':\n\t\tcase '\\n':\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t*b++ = *arg;\n\t\t\tbreak;\n\t\t}\n\t\targ++;\n\t}\n\t*b = 0;\n\treturn a;\n}",
        "func": "static char *__filterShell(const char *arg) {\n\tr_return_val_if_fail (arg, NULL);\n\tchar *a = malloc (strlen (arg) + 1);\n\tif (!a) {\n\t\treturn NULL;\n\t}\n\tchar *b = a;\n\twhile (*arg) {\n\t\tchar ch = *arg;\n\t\tswitch (ch) {\n\t\tcase '@':\n\t\tcase '`':\n\t\tcase '|':\n\t\tcase ';':\n\t\tcase '=':\n\t\tcase '\\n':\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t*b++ = ch;\n\t\t\tbreak;\n\t\t}\n\t\targ++;\n\t}\n\t*b = 0;\n\treturn a;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,15 +6,17 @@\n \t}\n \tchar *b = a;\n \twhile (*arg) {\n-\t\tswitch (*arg) {\n+\t\tchar ch = *arg;\n+\t\tswitch (ch) {\n \t\tcase '@':\n \t\tcase '`':\n \t\tcase '|':\n \t\tcase ';':\n+\t\tcase '=':\n \t\tcase '\\n':\n \t\t\tbreak;\n \t\tdefault:\n-\t\t\t*b++ = *arg;\n+\t\t\t*b++ = ch;\n \t\t\tbreak;\n \t\t}\n \t\targ++;",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tswitch (*arg) {",
                "\t\t\t*b++ = *arg;"
            ],
            "added_lines": [
                "\t\tchar ch = *arg;",
                "\t\tswitch (ch) {",
                "\t\tcase '=':",
                "\t\t\t*b++ = ch;"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-16718",
        "func_name": "radareorg/radare2/bin_symbols",
        "description": "In radare2 before 3.9.0, a command injection vulnerability exists in bin_symbols() in libr/core/cbin.c. By using a crafted executable file, it's possible to execute arbitrary shell commands with the permissions of the victim. This vulnerability is due to an insufficient fix for CVE-2019-14745 and improper handling of symbol names embedded in executables.",
        "git_url": "https://github.com/radareorg/radare2/commit/5411543a310a470b1257fb93273cdd6e8dfcb3af",
        "commit_title": "More fixes for the CVE-2019-14745",
        "commit_text": "",
        "func_before": "static int bin_symbols(RCore *r, int mode, ut64 laddr, int va, ut64 at, const char *name, bool exponly, const char *args) {\n\tRBinInfo *info = r_bin_get_info (r->bin);\n\tRList *entries = r_bin_get_entries (r->bin);\n\tRBinSymbol *symbol;\n\tRBinAddr *entry;\n\tRListIter *iter;\n\tbool firstexp = true;\n\tbool printHere = false;\n\tint i = 0, lastfs = 's';\n\tbool bin_demangle = r_config_get_i (r->config, \"bin.demangle\");\n\tif (!info) {\n\t\treturn 0;\n\t}\n\n\tif (args && *args == '.') {\n\t\tprintHere = true;\n\t}\n\n\tbool is_arm = info && info->arch && !strncmp (info->arch, \"arm\", 3);\n\tconst char *lang = bin_demangle ? r_config_get (r->config, \"bin.lang\") : NULL;\n\n\tRList *symbols = r_bin_get_symbols (r->bin);\n\tr_spaces_push (&r->anal->meta_spaces, \"bin\");\n\n\tif (IS_MODE_JSON (mode) && !printHere) {\n\t\tr_cons_printf (\"[\");\n\t} else if (IS_MODE_SET (mode)) {\n\t\tr_flag_space_set (r->flags, R_FLAGS_FS_SYMBOLS);\n\t} else if (!at && exponly) {\n\t\tif (IS_MODE_RAD (mode)) {\n\t\t\tr_cons_printf (\"fs exports\\n\");\n\t\t} else if (IS_MODE_NORMAL (mode)) {\n\t\t\tr_cons_printf (printHere ? \"\" : \"[Exports]\\n\");\n\t\t}\n\t} else if (!at && !exponly) {\n\t\tif (IS_MODE_RAD (mode)) {\n\t\t\tr_cons_printf (\"fs symbols\\n\");\n\t\t} else if (IS_MODE_NORMAL (mode)) {\n\t\t\tr_cons_printf (printHere ? \"\" : \"[Symbols]\\n\");\n\t\t}\n\t}\n\tif (IS_MODE_NORMAL (mode)) {\n\t\tr_cons_printf (\"Num Paddr      Vaddr      Bind     Type Size Name\\n\");\n\t}\n\n\n\tsize_t count = 0;\n\tr_list_foreach (symbols, iter, symbol) {\n\t\tif (!symbol->name) {\n\t\t\tcontinue;\n\t\t}\n\t\tchar *r_symbol_name = r_str_escape_utf8 (symbol->name, false, true);\n\t\tut64 addr = compute_addr (r->bin, symbol->paddr, symbol->vaddr, va);\n\t\tint len = symbol->size ? symbol->size : 32;\n\t\tSymName sn = {0};\n\n\t\tif (exponly && !isAnExport (symbol)) {\n\t\t\tfree (r_symbol_name);\n\t\t\tcontinue;\n\t\t}\n\t\tif (name && strcmp (r_symbol_name, name)) {\n\t\t\tfree (r_symbol_name);\n\t\t\tcontinue;\n\t\t}\n\t\tif (at && (!symbol->size || !is_in_range (at, addr, symbol->size))) {\n\t\t\tfree (r_symbol_name);\n\t\t\tcontinue;\n\t\t}\n\t\tif ((printHere && !is_in_range (r->offset, symbol->paddr, len))\n\t\t\t\t&& (printHere && !is_in_range (r->offset, addr, len))) {\n\t\t\tfree (r_symbol_name);\n\t\t\tcontinue;\n\t\t}\n\t\tcount ++;\n\t\tsnInit (r, &sn, symbol, lang);\n\n\t\tif (IS_MODE_SET (mode) && (is_section_symbol (symbol) || is_file_symbol (symbol))) {\n\t\t\t/*\n\t\t\t * Skip section symbols because they will have their own flag.\n\t\t\t * Skip also file symbols because not useful for now.\n\t\t\t */\n\t\t} else if (IS_MODE_SET (mode) && is_special_symbol (symbol)) {\n\t\t\tif (is_arm) {\n\t\t\t\thandle_arm_special_symbol (r, symbol, va);\n\t\t\t}\n\t\t} else if (IS_MODE_SET (mode)) {\n\t\t\t// TODO: provide separate API in RBinPlugin to let plugins handle anal hints/metadata\n\t\t\tif (is_arm) {\n\t\t\t\thandle_arm_symbol (r, symbol, info, va);\n\t\t\t}\n\t\t\tselect_flag_space (r, symbol);\n\t\t\t/* If that's a Classed symbol (method or so) */\n\t\t\tif (sn.classname) {\n\t\t\t\tRFlagItem *fi = r_flag_get (r->flags, sn.methflag);\n\t\t\t\tif (r->bin->prefix) {\n\t\t\t\t\tchar *prname = r_str_newf (\"%s.%s\", r->bin->prefix, sn.methflag);\n\t\t\t\t\tr_name_filter (sn.methflag, -1);\n\t\t\t\t\tfree (sn.methflag);\n\t\t\t\t\tsn.methflag = prname;\n\t\t\t\t}\n\t\t\t\tif (fi) {\n\t\t\t\t\tr_flag_item_set_realname (fi, sn.methname);\n\t\t\t\t\tif ((fi->offset - r->flags->base) == addr) {\n\t\t\t\t//\t\tchar *comment = fi->comment ? strdup (fi->comment) : NULL;\n\t\t\t\t\t\tr_flag_unset (r->flags, fi);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfi = r_flag_set (r->flags, sn.methflag, addr, symbol->size);\n\t\t\t\t\tchar *comment = fi->comment ? strdup (fi->comment) : NULL;\n\t\t\t\t\tif (comment) {\n\t\t\t\t\t\tr_flag_item_set_comment (fi, comment);\n\t\t\t\t\t\tR_FREE (comment);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst char *n = sn.demname ? sn.demname : sn.name;\n\t\t\t\tconst char *fn = sn.demflag ? sn.demflag : sn.nameflag;\n\t\t\t\tchar *fnp = (r->bin->prefix) ?\n\t\t\t\t\tr_str_newf (\"%s.%s\", r->bin->prefix, fn):\n\t\t\t\t\tstrdup (fn);\n\t\t\t\tRFlagItem *fi = r_flag_set (r->flags, fnp, addr, symbol->size);\n\t\t\t\tif (fi) {\n\t\t\t\t\tr_flag_item_set_realname (fi, n);\n\t\t\t\t\tfi->demangled = (bool)(size_t)sn.demname;\n\t\t\t\t} else {\n\t\t\t\t\tif (fn) {\n\t\t\t\t\t\teprintf (\"[Warning] Can't find flag (%s)\\n\", fn);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfree (fnp);\n\t\t\t}\n\t\t\tif (sn.demname) {\n\t\t\t\tr_meta_add (r->anal, R_META_TYPE_COMMENT,\n\t\t\t\t\taddr, symbol->size, sn.demname);\n\t\t\t}\n\t\t\tr_flag_space_pop (r->flags);\n\t\t} else if (IS_MODE_JSON (mode)) {\n\t\t\tchar *str = r_str_escape_utf8_for_json (r_symbol_name, -1);\n\t\t\t// str = r_str_replace (str, \"\\\"\", \"\\\\\\\"\", 1);\n\t\t\tr_cons_printf (\"%s{\\\"name\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"demname\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"flagname\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"ordinal\\\":%d,\"\n\t\t\t\t\"\\\"bind\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"size\\\":%d,\"\n\t\t\t\t\"\\\"type\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"vaddr\\\":%\"PFMT64d\",\"\n\t\t\t\t\"\\\"paddr\\\":%\"PFMT64d\"}\",\n\t\t\t\t((exponly && firstexp) || printHere) ? \"\" : (iter->p ? \",\" : \"\"),\n\t\t\t\tstr,\n\t\t\t\tsn.demname? sn.demname: \"\",\n\t\t\t\tsn.nameflag,\n\t\t\t\tsymbol->ordinal,\n\t\t\t\tsymbol->bind,\n\t\t\t\t(int)symbol->size,\n\t\t\t\tsymbol->type,\n\t\t\t\t(ut64)addr, (ut64)symbol->paddr);\n\t\t\tfree (str);\n\t\t} else if (IS_MODE_SIMPLE (mode)) {\n\t\t\tconst char *name = sn.demname? sn.demname: r_symbol_name;\n\t\t\tr_cons_printf (\"0x%08\"PFMT64x\" %d %s\\n\",\n\t\t\t\taddr, (int)symbol->size, name);\n\t\t} else if (IS_MODE_SIMPLEST (mode)) {\n\t\t\tconst char *name = sn.demname? sn.demname: r_symbol_name;\n\t\t\tr_cons_printf (\"%s\\n\", name);\n\t\t} else if (IS_MODE_RAD (mode)) {\n\t\t\t/* Skip special symbols because we do not flag them and\n\t\t\t * they shouldn't be printed in the rad format either */\n\t\t\tif (is_special_symbol (symbol)) {\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\tRBinFile *binfile;\n\t\t\tRBinPlugin *plugin;\n\t\t\tconst char *name = sn.demname? sn.demname: r_symbol_name;\n\t\t\tif (!name) {\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\tif (!strncmp (name, \"imp.\", 4)) {\n\t\t\t\tif (lastfs != 'i') {\n\t\t\t\t\tr_cons_printf (\"fs imports\\n\");\n\t\t\t\t}\n\t\t\t\tlastfs = 'i';\n\t\t\t} else {\n\t\t\t\tif (lastfs != 's') {\n\t\t\t\t\tconst char *fs = exponly? \"exports\": \"symbols\";\n\t\t\t\t\tr_cons_printf (\"fs %s\\n\", fs);\n\t\t\t\t}\n\t\t\t\tlastfs = 's';\n\t\t\t}\n\t\t\tif (r->bin->prefix || *name) { // we don't want unnamed symbol flags\n\t\t\t\tchar *flagname = construct_symbol_flagname (\"sym\", name, MAXFLAG_LEN_DEFAULT);\n\t\t\t\tif (!flagname) {\n\t\t\t\t\tgoto next;\n\t\t\t\t}\n\t\t\t\tr_cons_printf (\"\\\"f %s%s%s %u 0x%08\" PFMT64x \"\\\"\\n\",\n\t\t\t\t\tr->bin->prefix ? r->bin->prefix : \"\", r->bin->prefix ? \".\" : \"\",\n\t\t\t\t\tflagname, symbol->size, addr);\n\t\t\t\tfree (flagname);\n\t\t\t}\n\t\t\tbinfile = r_bin_cur (r->bin);\n\t\t\tplugin = r_bin_file_cur_plugin (binfile);\n\t\t\tif (plugin && plugin->name) {\n\t\t\t\tif (r_str_startswith (plugin->name, \"pe\")) {\n\t\t\t\t\tchar *module = strdup (r_symbol_name);\n\t\t\t\t\tchar *p = strstr (module, \".dll_\");\n\t\t\t\t\tif (p && strstr (module, \"imp.\")) {\n\t\t\t\t\t\tchar *symname = __filterShell (p + 5);\n\t\t\t\t\t\tchar *m = __filterShell (module);\n\t\t\t\t\t\t*p = 0;\n\t\t\t\t\t\tif (r->bin->prefix) {\n\t\t\t\t\t\t\tr_cons_printf (\"k bin/pe/%s/%d=%s.%s\\n\",\n\t\t\t\t\t\t\t\tmodule, symbol->ordinal, r->bin->prefix, symname);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tr_cons_printf (\"k bin/pe/%s/%d=%s\\n\",\n\t\t\t\t\t\t\t\tmodule, symbol->ordinal, symname);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfree (symname);\n\t\t\t\t\t\tfree (m);\n\t\t\t\t\t}\n\t\t\t\t\tfree (module);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tconst char *bind = symbol->bind? symbol->bind: \"NONE\";\n\t\t\tconst char *type = symbol->type? symbol->type: \"NONE\";\n\t\t\tconst char *name = r_str_get (sn.demname? sn.demname: r_symbol_name);\n\t\t\t// const char *fwd = r_str_get (symbol->forwarder);\n\t\t\tr_cons_printf (\"%03u\", symbol->ordinal);\n\t\t\tif (symbol->paddr == UT64_MAX) {\n\t\t\t\tr_cons_printf (\" ----------\");\n\t\t\t} else {\n\t\t\t\tr_cons_printf (\" 0x%08\"PFMT64x, symbol->paddr);\n\t\t\t}\n\t\t\tr_cons_printf (\" 0x%08\"PFMT64x\" %6s %6s %4d%s%s\\n\",\n\t\t\t               addr, bind, type, symbol->size, *name? \" \": \"\", name);\n\t\t}\nnext:\n\t\tsnFini (&sn);\n\t\ti++;\n\t\tfree (r_symbol_name);\n\t\tif (exponly && firstexp) {\n\t\t\tfirstexp = false;\n\t\t}\n\t\tif (printHere) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (count == 0 && IS_MODE_JSON (mode)) {\n\t\tr_cons_printf (\"{}\");\n\t}\n\n\n\t//handle thumb and arm for entry point since they are not present in symbols\n\tif (is_arm) {\n\t\tr_list_foreach (entries, iter, entry) {\n\t\t\tif (IS_MODE_SET (mode)) {\n\t\t\t\thandle_arm_entry (r, entry, info, va);\n\t\t\t}\n\t\t}\n\t}\n\tif (IS_MODE_JSON (mode) && !printHere) {\n\t\tr_cons_printf (\"]\");\n\t}\n\n\tr_spaces_pop (&r->anal->meta_spaces);\n\treturn true;\n}",
        "func": "static int bin_symbols(RCore *r, int mode, ut64 laddr, int va, ut64 at, const char *name, bool exponly, const char *args) {\n\tRBinInfo *info = r_bin_get_info (r->bin);\n\tRList *entries = r_bin_get_entries (r->bin);\n\tRBinSymbol *symbol;\n\tRBinAddr *entry;\n\tRListIter *iter;\n\tbool firstexp = true;\n\tbool printHere = false;\n\tint i = 0, lastfs = 's';\n\tbool bin_demangle = r_config_get_i (r->config, \"bin.demangle\");\n\tif (!info) {\n\t\treturn 0;\n\t}\n\n\tif (args && *args == '.') {\n\t\tprintHere = true;\n\t}\n\n\tbool is_arm = info && info->arch && !strncmp (info->arch, \"arm\", 3);\n\tconst char *lang = bin_demangle ? r_config_get (r->config, \"bin.lang\") : NULL;\n\n\tRList *symbols = r_bin_get_symbols (r->bin);\n\tr_spaces_push (&r->anal->meta_spaces, \"bin\");\n\n\tif (IS_MODE_JSON (mode) && !printHere) {\n\t\tr_cons_printf (\"[\");\n\t} else if (IS_MODE_SET (mode)) {\n\t\tr_flag_space_set (r->flags, R_FLAGS_FS_SYMBOLS);\n\t} else if (!at && exponly) {\n\t\tif (IS_MODE_RAD (mode)) {\n\t\t\tr_cons_printf (\"fs exports\\n\");\n\t\t} else if (IS_MODE_NORMAL (mode)) {\n\t\t\tr_cons_printf (printHere ? \"\" : \"[Exports]\\n\");\n\t\t}\n\t} else if (!at && !exponly) {\n\t\tif (IS_MODE_RAD (mode)) {\n\t\t\tr_cons_printf (\"fs symbols\\n\");\n\t\t} else if (IS_MODE_NORMAL (mode)) {\n\t\t\tr_cons_printf (printHere ? \"\" : \"[Symbols]\\n\");\n\t\t}\n\t}\n\tif (IS_MODE_NORMAL (mode)) {\n\t\tr_cons_printf (\"Num Paddr      Vaddr      Bind     Type Size Name\\n\");\n\t}\n\n\n\tsize_t count = 0;\n\tr_list_foreach (symbols, iter, symbol) {\n\t\tif (!symbol->name) {\n\t\t\tcontinue;\n\t\t}\n\t\tchar *r_symbol_name = r_str_escape_utf8 (symbol->name, false, true);\n\t\tut64 addr = compute_addr (r->bin, symbol->paddr, symbol->vaddr, va);\n\t\tint len = symbol->size ? symbol->size : 32;\n\t\tSymName sn = {0};\n\n\t\tif (exponly && !isAnExport (symbol)) {\n\t\t\tfree (r_symbol_name);\n\t\t\tcontinue;\n\t\t}\n\t\tif (name && strcmp (r_symbol_name, name)) {\n\t\t\tfree (r_symbol_name);\n\t\t\tcontinue;\n\t\t}\n\t\tif (at && (!symbol->size || !is_in_range (at, addr, symbol->size))) {\n\t\t\tfree (r_symbol_name);\n\t\t\tcontinue;\n\t\t}\n\t\tif ((printHere && !is_in_range (r->offset, symbol->paddr, len))\n\t\t\t\t&& (printHere && !is_in_range (r->offset, addr, len))) {\n\t\t\tfree (r_symbol_name);\n\t\t\tcontinue;\n\t\t}\n\t\tcount ++;\n\t\tsnInit (r, &sn, symbol, lang);\n\n\t\tif (IS_MODE_SET (mode) && (is_section_symbol (symbol) || is_file_symbol (symbol))) {\n\t\t\t/*\n\t\t\t * Skip section symbols because they will have their own flag.\n\t\t\t * Skip also file symbols because not useful for now.\n\t\t\t */\n\t\t} else if (IS_MODE_SET (mode) && is_special_symbol (symbol)) {\n\t\t\tif (is_arm) {\n\t\t\t\thandle_arm_special_symbol (r, symbol, va);\n\t\t\t}\n\t\t} else if (IS_MODE_SET (mode)) {\n\t\t\t// TODO: provide separate API in RBinPlugin to let plugins handle anal hints/metadata\n\t\t\tif (is_arm) {\n\t\t\t\thandle_arm_symbol (r, symbol, info, va);\n\t\t\t}\n\t\t\tselect_flag_space (r, symbol);\n\t\t\t/* If that's a Classed symbol (method or so) */\n\t\t\tif (sn.classname) {\n\t\t\t\tRFlagItem *fi = r_flag_get (r->flags, sn.methflag);\n\t\t\t\tif (r->bin->prefix) {\n\t\t\t\t\tchar *prname = r_str_newf (\"%s.%s\", r->bin->prefix, sn.methflag);\n\t\t\t\t\tr_name_filter (sn.methflag, -1);\n\t\t\t\t\tfree (sn.methflag);\n\t\t\t\t\tsn.methflag = prname;\n\t\t\t\t}\n\t\t\t\tif (fi) {\n\t\t\t\t\tr_flag_item_set_realname (fi, sn.methname);\n\t\t\t\t\tif ((fi->offset - r->flags->base) == addr) {\n\t\t\t\t//\t\tchar *comment = fi->comment ? strdup (fi->comment) : NULL;\n\t\t\t\t\t\tr_flag_unset (r->flags, fi);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfi = r_flag_set (r->flags, sn.methflag, addr, symbol->size);\n\t\t\t\t\tchar *comment = fi->comment ? strdup (fi->comment) : NULL;\n\t\t\t\t\tif (comment) {\n\t\t\t\t\t\tr_flag_item_set_comment (fi, comment);\n\t\t\t\t\t\tR_FREE (comment);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst char *n = sn.demname ? sn.demname : sn.name;\n\t\t\t\tconst char *fn = sn.demflag ? sn.demflag : sn.nameflag;\n\t\t\t\tchar *fnp = (r->bin->prefix) ?\n\t\t\t\t\tr_str_newf (\"%s.%s\", r->bin->prefix, fn):\n\t\t\t\t\tstrdup (fn);\n\t\t\t\tRFlagItem *fi = r_flag_set (r->flags, fnp, addr, symbol->size);\n\t\t\t\tif (fi) {\n\t\t\t\t\tr_flag_item_set_realname (fi, n);\n\t\t\t\t\tfi->demangled = (bool)(size_t)sn.demname;\n\t\t\t\t} else {\n\t\t\t\t\tif (fn) {\n\t\t\t\t\t\teprintf (\"[Warning] Can't find flag (%s)\\n\", fn);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfree (fnp);\n\t\t\t}\n\t\t\tif (sn.demname) {\n\t\t\t\tr_meta_add (r->anal, R_META_TYPE_COMMENT,\n\t\t\t\t\taddr, symbol->size, sn.demname);\n\t\t\t}\n\t\t\tr_flag_space_pop (r->flags);\n\t\t} else if (IS_MODE_JSON (mode)) {\n\t\t\tchar *str = r_str_escape_utf8_for_json (r_symbol_name, -1);\n\t\t\t// str = r_str_replace (str, \"\\\"\", \"\\\\\\\"\", 1);\n\t\t\tr_cons_printf (\"%s{\\\"name\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"demname\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"flagname\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"ordinal\\\":%d,\"\n\t\t\t\t\"\\\"bind\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"size\\\":%d,\"\n\t\t\t\t\"\\\"type\\\":\\\"%s\\\",\"\n\t\t\t\t\"\\\"vaddr\\\":%\"PFMT64d\",\"\n\t\t\t\t\"\\\"paddr\\\":%\"PFMT64d\"}\",\n\t\t\t\t((exponly && firstexp) || printHere) ? \"\" : (iter->p ? \",\" : \"\"),\n\t\t\t\tstr,\n\t\t\t\tsn.demname? sn.demname: \"\",\n\t\t\t\tsn.nameflag,\n\t\t\t\tsymbol->ordinal,\n\t\t\t\tsymbol->bind,\n\t\t\t\t(int)symbol->size,\n\t\t\t\tsymbol->type,\n\t\t\t\t(ut64)addr, (ut64)symbol->paddr);\n\t\t\tfree (str);\n\t\t} else if (IS_MODE_SIMPLE (mode)) {\n\t\t\tconst char *name = sn.demname? sn.demname: r_symbol_name;\n\t\t\tr_cons_printf (\"0x%08\"PFMT64x\" %d %s\\n\",\n\t\t\t\taddr, (int)symbol->size, name);\n\t\t} else if (IS_MODE_SIMPLEST (mode)) {\n\t\t\tconst char *name = sn.demname? sn.demname: r_symbol_name;\n\t\t\tr_cons_printf (\"%s\\n\", name);\n\t\t} else if (IS_MODE_RAD (mode)) {\n\t\t\t/* Skip special symbols because we do not flag them and\n\t\t\t * they shouldn't be printed in the rad format either */\n\t\t\tif (is_special_symbol (symbol)) {\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\tRBinFile *binfile;\n\t\t\tRBinPlugin *plugin;\n\t\t\tconst char *name = sn.demname? sn.demname: r_symbol_name;\n\t\t\tif (!name) {\n\t\t\t\tgoto next;\n\t\t\t}\n\t\t\tif (!strncmp (name, \"imp.\", 4)) {\n\t\t\t\tif (lastfs != 'i') {\n\t\t\t\t\tr_cons_printf (\"fs imports\\n\");\n\t\t\t\t}\n\t\t\t\tlastfs = 'i';\n\t\t\t} else {\n\t\t\t\tif (lastfs != 's') {\n\t\t\t\t\tconst char *fs = exponly? \"exports\": \"symbols\";\n\t\t\t\t\tr_cons_printf (\"fs %s\\n\", fs);\n\t\t\t\t}\n\t\t\t\tlastfs = 's';\n\t\t\t}\n\t\t\tif (r->bin->prefix || *name) { // we don't want unnamed symbol flags\n\t\t\t\tchar *flagname = construct_symbol_flagname (\"sym\", name, MAXFLAG_LEN_DEFAULT);\n\t\t\t\tif (!flagname) {\n\t\t\t\t\tgoto next;\n\t\t\t\t}\n\t\t\t\tr_cons_printf (\"\\\"f %s%s%s %u 0x%08\" PFMT64x \"\\\"\\n\",\n\t\t\t\t\tr->bin->prefix ? r->bin->prefix : \"\", r->bin->prefix ? \".\" : \"\",\n\t\t\t\t\tflagname, symbol->size, addr);\n\t\t\t\tfree (flagname);\n\t\t\t}\n\t\t\tbinfile = r_bin_cur (r->bin);\n\t\t\tplugin = r_bin_file_cur_plugin (binfile);\n\t\t\tif (plugin && plugin->name) {\n\t\t\t\tif (r_str_startswith (plugin->name, \"pe\")) {\n\t\t\t\t\tchar *module = strdup (r_symbol_name);\n\t\t\t\t\tchar *p = strstr (module, \".dll_\");\n\t\t\t\t\tif (p && strstr (module, \"imp.\")) {\n\t\t\t\t\t\tchar *symname = __filterShell (p + 5);\n\t\t\t\t\t\tchar *m = __filterShell (module);\n\t\t\t\t\t\t*p = 0;\n\t\t\t\t\t\tif (r->bin->prefix) {\n\t\t\t\t\t\t\tr_cons_printf (\"\\\"k bin/pe/%s/%d=%s.%s\\\"\\n\",\n\t\t\t\t\t\t\t\tmodule, symbol->ordinal, r->bin->prefix, symname);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tr_cons_printf (\"\\\"k bin/pe/%s/%d=%s\\\"\\n\",\n\t\t\t\t\t\t\t\tmodule, symbol->ordinal, symname);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfree (symname);\n\t\t\t\t\t\tfree (m);\n\t\t\t\t\t}\n\t\t\t\t\tfree (module);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tconst char *bind = symbol->bind? symbol->bind: \"NONE\";\n\t\t\tconst char *type = symbol->type? symbol->type: \"NONE\";\n\t\t\tconst char *name = r_str_get (sn.demname? sn.demname: r_symbol_name);\n\t\t\t// const char *fwd = r_str_get (symbol->forwarder);\n\t\t\tr_cons_printf (\"%03u\", symbol->ordinal);\n\t\t\tif (symbol->paddr == UT64_MAX) {\n\t\t\t\tr_cons_printf (\" ----------\");\n\t\t\t} else {\n\t\t\t\tr_cons_printf (\" 0x%08\"PFMT64x, symbol->paddr);\n\t\t\t}\n\t\t\tr_cons_printf (\" 0x%08\"PFMT64x\" %6s %6s %4d%s%s\\n\",\n\t\t\t               addr, bind, type, symbol->size, *name? \" \": \"\", name);\n\t\t}\nnext:\n\t\tsnFini (&sn);\n\t\ti++;\n\t\tfree (r_symbol_name);\n\t\tif (exponly && firstexp) {\n\t\t\tfirstexp = false;\n\t\t}\n\t\tif (printHere) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (count == 0 && IS_MODE_JSON (mode)) {\n\t\tr_cons_printf (\"{}\");\n\t}\n\n\n\t//handle thumb and arm for entry point since they are not present in symbols\n\tif (is_arm) {\n\t\tr_list_foreach (entries, iter, entry) {\n\t\t\tif (IS_MODE_SET (mode)) {\n\t\t\t\thandle_arm_entry (r, entry, info, va);\n\t\t\t}\n\t\t}\n\t}\n\tif (IS_MODE_JSON (mode) && !printHere) {\n\t\tr_cons_printf (\"]\");\n\t}\n\n\tr_spaces_pop (&r->anal->meta_spaces);\n\treturn true;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -208,10 +208,10 @@\n \t\t\t\t\t\tchar *m = __filterShell (module);\n \t\t\t\t\t\t*p = 0;\n \t\t\t\t\t\tif (r->bin->prefix) {\n-\t\t\t\t\t\t\tr_cons_printf (\"k bin/pe/%s/%d=%s.%s\\n\",\n+\t\t\t\t\t\t\tr_cons_printf (\"\\\"k bin/pe/%s/%d=%s.%s\\\"\\n\",\n \t\t\t\t\t\t\t\tmodule, symbol->ordinal, r->bin->prefix, symname);\n \t\t\t\t\t\t} else {\n-\t\t\t\t\t\t\tr_cons_printf (\"k bin/pe/%s/%d=%s\\n\",\n+\t\t\t\t\t\t\tr_cons_printf (\"\\\"k bin/pe/%s/%d=%s\\\"\\n\",\n \t\t\t\t\t\t\t\tmodule, symbol->ordinal, symname);\n \t\t\t\t\t\t}\n \t\t\t\t\t\tfree (symname);",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\t\t\t\t\tr_cons_printf (\"k bin/pe/%s/%d=%s.%s\\n\",",
                "\t\t\t\t\t\t\tr_cons_printf (\"k bin/pe/%s/%d=%s\\n\","
            ],
            "added_lines": [
                "\t\t\t\t\t\t\tr_cons_printf (\"\\\"k bin/pe/%s/%d=%s.%s\\\"\\n\",",
                "\t\t\t\t\t\t\tr_cons_printf (\"\\\"k bin/pe/%s/%d=%s\\\"\\n\","
            ]
        }
    },
    {
        "cve_id": "CVE-2019-16718",
        "func_name": "radareorg/radare2/__filterQuotedShell",
        "description": "In radare2 before 3.9.0, a command injection vulnerability exists in bin_symbols() in libr/core/cbin.c. By using a crafted executable file, it's possible to execute arbitrary shell commands with the permissions of the victim. This vulnerability is due to an insufficient fix for CVE-2019-14745 and improper handling of symbol names embedded in executables.",
        "git_url": "https://github.com/radareorg/radare2/commit/5411543a310a470b1257fb93273cdd6e8dfcb3af",
        "commit_title": "More fixes for the CVE-2019-14745",
        "commit_text": "",
        "func_before": "static char *__filterQuotedShell(const char *arg) {\n\tr_return_val_if_fail (arg, NULL);\n\tchar *a = malloc (strlen (arg) + 1);\n\tif (!a) {\n\t\treturn NULL;\n\t}\n\tchar *b = a;\n\twhile (*arg) {\n\t\tswitch (*arg) {\n\t\tcase ' ':\n\t\tcase '=':\n\t\tcase '\\r':\n\t\tcase '\\n':\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t*b++ = *arg;\n\t\t\tbreak;\n\t\t}\n\t\targ++;\n\t}\n\t*b = 0;\n\treturn a;\n}",
        "func": "static char *__filterQuotedShell(const char *arg) {\n\tr_return_val_if_fail (arg, NULL);\n\tchar *a = malloc (strlen (arg) + 1);\n\tif (!a) {\n\t\treturn NULL;\n\t}\n\tchar *b = a;\n\twhile (*arg) {\n\t\tswitch (*arg) {\n\t\tcase ' ':\n\t\tcase '=':\n\t\tcase '\"':\n\t\tcase '\\\\':\n\t\tcase '\\r':\n\t\tcase '\\n':\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t*b++ = *arg;\n\t\t\tbreak;\n\t\t}\n\t\targ++;\n\t}\n\t*b = 0;\n\treturn a;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -9,6 +9,8 @@\n \t\tswitch (*arg) {\n \t\tcase ' ':\n \t\tcase '=':\n+\t\tcase '\"':\n+\t\tcase '\\\\':\n \t\tcase '\\r':\n \t\tcase '\\n':\n \t\t\tbreak;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\tcase '\"':",
                "\t\tcase '\\\\':"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-18424",
        "func_name": "xen-project/xen/iommu_setup",
        "description": "An issue was discovered in Xen through 4.12.x allowing attackers to gain host OS privileges via DMA in a situation where an untrusted domain has access to a physical device. This occurs because passed through PCI devices may corrupt host memory after deassignment. When a PCI device is assigned to an untrusted domain, it is possible for that domain to program the device to DMA to an arbitrary address. The IOMMU is used to protect the host from malicious DMA by making sure that the device addresses can only target memory assigned to the guest. However, when the guest domain is torn down, or the device is deassigned, the device is assigned back to dom0, thus allowing any in-flight DMA to potentially target critical host data. An untrusted domain with access to a physical device can DMA into host memory, leading to privilege escalation. Only systems where guests are given direct access to physical devices capable of DMA (PCI pass-through) are vulnerable. Systems which do not use PCI pass-through are not vulnerable.",
        "git_url": "https://github.com/xen-project/xen/commit/319f9a0ba94c7db505cd5dd9cb0b037ab1aa8e12",
        "commit_title": "passthrough: quarantine PCI devices",
        "commit_text": " When a PCI device is assigned to an untrusted domain, it is possible for that domain to program the device to DMA to an arbitrary address. The IOMMU is used to protect the host from malicious DMA by making sure that the device addresses can only target memory assigned to the guest. However, when the guest domain is torn down the device is assigned back to dom0, thus allowing any in-flight DMA to potentially target critical host data.  This patch introduces a 'quarantine' for PCI devices using dom_io. When the toolstack makes a device assignable (by binding it to pciback), it will now also assign it to DOMID_IO and the device will only be assigned back to dom0 when the device is made unassignable again. Whilst device is assignable it will only ever transfer between dom_io and guest domains. dom_io is actually only used as a sentinel domain for quarantining purposes; it is not configured with any IOMMU mappings. Assignment to dom_io simply means that the device's initiator (requestor) identifier is not present in the IOMMU's device table and thus any DMA transactions issued will be terminated with a fault condition.  In addition, a fix to assignment handling is made for VT-d.  Failure during the assignment step should not lead to a device still being associated with its prior owner. Hand the device to DomIO temporarily, until the assignment step has completed successfully.  Remove the PI hooks from the source domain then earlier as well.  Failure of the recovery reassign_device_ownership() may not go silent: There e.g. may still be left over RMRR mappings in the domain assignment to which has failed, and hence we can't allow that domain to continue executing.  NOTE: This patch also includes one printk() cleanup; the       \"XEN_DOMCTL_assign_device: \" tag is dropped in iommu_do_pci_domctl(),       since similar printk()-s elsewhere also don't log such a tag.  This is XSA-302. ",
        "func_before": "int __init iommu_setup(void)\n{\n    int rc = -ENODEV;\n    bool_t force_intremap = force_iommu && iommu_intremap;\n\n    if ( iommu_hwdom_strict )\n        iommu_hwdom_passthrough = false;\n\n    if ( iommu_enable )\n    {\n        rc = iommu_hardware_setup();\n        iommu_enabled = (rc == 0);\n    }\n    if ( !iommu_enabled )\n        iommu_intremap = 0;\n\n    if ( (force_iommu && !iommu_enabled) ||\n         (force_intremap && !iommu_intremap) )\n        panic(\"Couldn't enable %s and iommu=required/force\\n\",\n              !iommu_enabled ? \"IOMMU\" : \"Interrupt Remapping\");\n\n    if ( !iommu_intremap )\n        iommu_intpost = 0;\n\n    printk(\"I/O virtualisation %sabled\\n\", iommu_enabled ? \"en\" : \"dis\");\n    if ( !iommu_enabled )\n    {\n        iommu_snoop = 0;\n        iommu_hwdom_passthrough = false;\n        iommu_hwdom_strict = false;\n    }\n    else\n    {\n        printk(\" - Dom0 mode: %s\\n\",\n               iommu_hwdom_passthrough ? \"Passthrough\" :\n               iommu_hwdom_strict ? \"Strict\" : \"Relaxed\");\n        printk(\"Interrupt remapping %sabled\\n\", iommu_intremap ? \"en\" : \"dis\");\n        tasklet_init(&iommu_pt_cleanup_tasklet, iommu_free_pagetables, 0);\n    }\n\n    return rc;\n}",
        "func": "int __init iommu_setup(void)\n{\n    int rc = -ENODEV;\n    bool_t force_intremap = force_iommu && iommu_intremap;\n\n    if ( iommu_hwdom_strict )\n        iommu_hwdom_passthrough = false;\n\n    if ( iommu_enable )\n    {\n        rc = iommu_hardware_setup();\n        iommu_enabled = (rc == 0);\n    }\n    if ( !iommu_enabled )\n        iommu_intremap = 0;\n\n    if ( (force_iommu && !iommu_enabled) ||\n         (force_intremap && !iommu_intremap) )\n        panic(\"Couldn't enable %s and iommu=required/force\\n\",\n              !iommu_enabled ? \"IOMMU\" : \"Interrupt Remapping\");\n\n    if ( !iommu_intremap )\n        iommu_intpost = 0;\n\n    printk(\"I/O virtualisation %sabled\\n\", iommu_enabled ? \"en\" : \"dis\");\n    if ( !iommu_enabled )\n    {\n        iommu_snoop = 0;\n        iommu_hwdom_passthrough = false;\n        iommu_hwdom_strict = false;\n    }\n    else\n    {\n        dom_io->options |= XEN_DOMCTL_CDF_iommu;\n        if ( iommu_domain_init(dom_io, 0) )\n            panic(\"Could not set up quarantine\\n\");\n\n        printk(\" - Dom0 mode: %s\\n\",\n               iommu_hwdom_passthrough ? \"Passthrough\" :\n               iommu_hwdom_strict ? \"Strict\" : \"Relaxed\");\n        printk(\"Interrupt remapping %sabled\\n\", iommu_intremap ? \"en\" : \"dis\");\n        tasklet_init(&iommu_pt_cleanup_tasklet, iommu_free_pagetables, 0);\n    }\n\n    return rc;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -31,6 +31,10 @@\n     }\n     else\n     {\n+        dom_io->options |= XEN_DOMCTL_CDF_iommu;\n+        if ( iommu_domain_init(dom_io, 0) )\n+            panic(\"Could not set up quarantine\\n\");\n+\n         printk(\" - Dom0 mode: %s\\n\",\n                iommu_hwdom_passthrough ? \"Passthrough\" :\n                iommu_hwdom_strict ? \"Strict\" : \"Relaxed\");",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "        dom_io->options |= XEN_DOMCTL_CDF_iommu;",
                "        if ( iommu_domain_init(dom_io, 0) )",
                "            panic(\"Could not set up quarantine\\n\");",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2019-18424",
        "func_name": "xen-project/xen/iommu_domain_init",
        "description": "An issue was discovered in Xen through 4.12.x allowing attackers to gain host OS privileges via DMA in a situation where an untrusted domain has access to a physical device. This occurs because passed through PCI devices may corrupt host memory after deassignment. When a PCI device is assigned to an untrusted domain, it is possible for that domain to program the device to DMA to an arbitrary address. The IOMMU is used to protect the host from malicious DMA by making sure that the device addresses can only target memory assigned to the guest. However, when the guest domain is torn down, or the device is deassigned, the device is assigned back to dom0, thus allowing any in-flight DMA to potentially target critical host data. An untrusted domain with access to a physical device can DMA into host memory, leading to privilege escalation. Only systems where guests are given direct access to physical devices capable of DMA (PCI pass-through) are vulnerable. Systems which do not use PCI pass-through are not vulnerable.",
        "git_url": "https://github.com/xen-project/xen/commit/319f9a0ba94c7db505cd5dd9cb0b037ab1aa8e12",
        "commit_title": "passthrough: quarantine PCI devices",
        "commit_text": " When a PCI device is assigned to an untrusted domain, it is possible for that domain to program the device to DMA to an arbitrary address. The IOMMU is used to protect the host from malicious DMA by making sure that the device addresses can only target memory assigned to the guest. However, when the guest domain is torn down the device is assigned back to dom0, thus allowing any in-flight DMA to potentially target critical host data.  This patch introduces a 'quarantine' for PCI devices using dom_io. When the toolstack makes a device assignable (by binding it to pciback), it will now also assign it to DOMID_IO and the device will only be assigned back to dom0 when the device is made unassignable again. Whilst device is assignable it will only ever transfer between dom_io and guest domains. dom_io is actually only used as a sentinel domain for quarantining purposes; it is not configured with any IOMMU mappings. Assignment to dom_io simply means that the device's initiator (requestor) identifier is not present in the IOMMU's device table and thus any DMA transactions issued will be terminated with a fault condition.  In addition, a fix to assignment handling is made for VT-d.  Failure during the assignment step should not lead to a device still being associated with its prior owner. Hand the device to DomIO temporarily, until the assignment step has completed successfully.  Remove the PI hooks from the source domain then earlier as well.  Failure of the recovery reassign_device_ownership() may not go silent: There e.g. may still be left over RMRR mappings in the domain assignment to which has failed, and hence we can't allow that domain to continue executing.  NOTE: This patch also includes one printk() cleanup; the       \"XEN_DOMCTL_assign_device: \" tag is dropped in iommu_do_pci_domctl(),       since similar printk()-s elsewhere also don't log such a tag.  This is XSA-302. ",
        "func_before": "int iommu_domain_init(struct domain *d, unsigned int opts)\n{\n    struct domain_iommu *hd = dom_iommu(d);\n    int ret = 0;\n\n    if ( !is_iommu_enabled(d) )\n        return 0;\n\n#ifdef CONFIG_NUMA\n    hd->node = NUMA_NO_NODE;\n#endif\n\n    ret = arch_iommu_domain_init(d);\n    if ( ret )\n        return ret;\n\n    hd->platform_ops = iommu_get_ops();\n    ret = hd->platform_ops->init(d);\n    if ( ret )\n        return ret;\n\n    if ( is_hardware_domain(d) )\n        check_hwdom_reqs(d); /* may modify iommu_hwdom_strict */\n\n    /*\n     * Use shared page tables for HAP and IOMMU if the global option\n     * is enabled (from which we can infer the h/w is capable) and\n     * the domain options do not disallow it. HAP must, of course, also\n     * be enabled.\n     */\n    hd->hap_pt_share = hap_enabled(d) && iommu_hap_pt_share &&\n        !(opts & XEN_DOMCTL_IOMMU_no_sharept);\n\n    /*\n     * NB: 'relaxed' h/w domains don't need the IOMMU mappings to be kept\n     *     in-sync with their assigned pages because all host RAM will be\n     *     mapped during hwdom_init().\n     */\n    if ( !is_hardware_domain(d) || iommu_hwdom_strict )\n        hd->need_sync = !iommu_use_hap_pt(d);\n\n    ASSERT(!(hd->need_sync && hd->hap_pt_share));\n\n    return 0;\n}",
        "func": "int iommu_domain_init(struct domain *d, unsigned int opts)\n{\n    struct domain_iommu *hd = dom_iommu(d);\n    int ret = 0;\n\n    if ( !is_iommu_enabled(d) )\n        return 0;\n\n#ifdef CONFIG_NUMA\n    hd->node = NUMA_NO_NODE;\n#endif\n\n    ret = arch_iommu_domain_init(d);\n    if ( ret )\n        return ret;\n\n    hd->platform_ops = iommu_get_ops();\n    ret = hd->platform_ops->init(d);\n    if ( ret || is_system_domain(d) )\n        return ret;\n\n    if ( is_hardware_domain(d) )\n        check_hwdom_reqs(d); /* may modify iommu_hwdom_strict */\n\n    /*\n     * Use shared page tables for HAP and IOMMU if the global option\n     * is enabled (from which we can infer the h/w is capable) and\n     * the domain options do not disallow it. HAP must, of course, also\n     * be enabled.\n     */\n    hd->hap_pt_share = hap_enabled(d) && iommu_hap_pt_share &&\n        !(opts & XEN_DOMCTL_IOMMU_no_sharept);\n\n    /*\n     * NB: 'relaxed' h/w domains don't need the IOMMU mappings to be kept\n     *     in-sync with their assigned pages because all host RAM will be\n     *     mapped during hwdom_init().\n     */\n    if ( !is_hardware_domain(d) || iommu_hwdom_strict )\n        hd->need_sync = !iommu_use_hap_pt(d);\n\n    ASSERT(!(hd->need_sync && hd->hap_pt_share));\n\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -16,7 +16,7 @@\n \n     hd->platform_ops = iommu_get_ops();\n     ret = hd->platform_ops->init(d);\n-    if ( ret )\n+    if ( ret || is_system_domain(d) )\n         return ret;\n \n     if ( is_hardware_domain(d) )",
        "diff_line_info": {
            "deleted_lines": [
                "    if ( ret )"
            ],
            "added_lines": [
                "    if ( ret || is_system_domain(d) )"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-18424",
        "func_name": "xen-project/xen/setup_system_domains",
        "description": "An issue was discovered in Xen through 4.12.x allowing attackers to gain host OS privileges via DMA in a situation where an untrusted domain has access to a physical device. This occurs because passed through PCI devices may corrupt host memory after deassignment. When a PCI device is assigned to an untrusted domain, it is possible for that domain to program the device to DMA to an arbitrary address. The IOMMU is used to protect the host from malicious DMA by making sure that the device addresses can only target memory assigned to the guest. However, when the guest domain is torn down, or the device is deassigned, the device is assigned back to dom0, thus allowing any in-flight DMA to potentially target critical host data. An untrusted domain with access to a physical device can DMA into host memory, leading to privilege escalation. Only systems where guests are given direct access to physical devices capable of DMA (PCI pass-through) are vulnerable. Systems which do not use PCI pass-through are not vulnerable.",
        "git_url": "https://github.com/xen-project/xen/commit/319f9a0ba94c7db505cd5dd9cb0b037ab1aa8e12",
        "commit_title": "passthrough: quarantine PCI devices",
        "commit_text": " When a PCI device is assigned to an untrusted domain, it is possible for that domain to program the device to DMA to an arbitrary address. The IOMMU is used to protect the host from malicious DMA by making sure that the device addresses can only target memory assigned to the guest. However, when the guest domain is torn down the device is assigned back to dom0, thus allowing any in-flight DMA to potentially target critical host data.  This patch introduces a 'quarantine' for PCI devices using dom_io. When the toolstack makes a device assignable (by binding it to pciback), it will now also assign it to DOMID_IO and the device will only be assigned back to dom0 when the device is made unassignable again. Whilst device is assignable it will only ever transfer between dom_io and guest domains. dom_io is actually only used as a sentinel domain for quarantining purposes; it is not configured with any IOMMU mappings. Assignment to dom_io simply means that the device's initiator (requestor) identifier is not present in the IOMMU's device table and thus any DMA transactions issued will be terminated with a fault condition.  In addition, a fix to assignment handling is made for VT-d.  Failure during the assignment step should not lead to a device still being associated with its prior owner. Hand the device to DomIO temporarily, until the assignment step has completed successfully.  Remove the PI hooks from the source domain then earlier as well.  Failure of the recovery reassign_device_ownership() may not go silent: There e.g. may still be left over RMRR mappings in the domain assignment to which has failed, and hence we can't allow that domain to continue executing.  NOTE: This patch also includes one printk() cleanup; the       \"XEN_DOMCTL_assign_device: \" tag is dropped in iommu_do_pci_domctl(),       since similar printk()-s elsewhere also don't log such a tag.  This is XSA-302. ",
        "func_before": "void __init setup_system_domains(void)\n{\n    /*\n     * Initialise our DOMID_XEN domain.\n     * Any Xen-heap pages that we will allow to be mapped will have\n     * their domain field set to dom_xen.\n     * Hidden PCI devices will also be associated with this domain\n     * (but be [partly] controlled by Dom0 nevertheless).\n     */\n    dom_xen = domain_create(DOMID_XEN, NULL, false);\n    if ( IS_ERR(dom_xen) )\n        panic(\"Failed to create d[XEN]: %ld\\n\", PTR_ERR(dom_xen));\n\n    /*\n     * Initialise our DOMID_IO domain.\n     * This domain owns I/O pages that are within the range of the page_info\n     * array. Mappings occur at the priv of the caller.\n     */\n    dom_io = domain_create(DOMID_IO, NULL, false);\n    if ( IS_ERR(dom_io) )\n        panic(\"Failed to create d[IO]: %ld\\n\", PTR_ERR(dom_io));\n\n#ifdef CONFIG_MEM_SHARING\n    /*\n     * Initialise our COW domain.\n     * This domain owns sharable pages.\n     */\n    dom_cow = domain_create(DOMID_COW, NULL, false);\n    if ( IS_ERR(dom_cow) )\n        panic(\"Failed to create d[COW]: %ld\\n\", PTR_ERR(dom_cow));\n#endif\n}",
        "func": "void __init setup_system_domains(void)\n{\n    /*\n     * Initialise our DOMID_XEN domain.\n     * Any Xen-heap pages that we will allow to be mapped will have\n     * their domain field set to dom_xen.\n     * Hidden PCI devices will also be associated with this domain\n     * (but be [partly] controlled by Dom0 nevertheless).\n     */\n    dom_xen = domain_create(DOMID_XEN, NULL, false);\n    if ( IS_ERR(dom_xen) )\n        panic(\"Failed to create d[XEN]: %ld\\n\", PTR_ERR(dom_xen));\n\n    /*\n     * Initialise our DOMID_IO domain.\n     * This domain owns I/O pages that are within the range of the page_info\n     * array. Mappings occur at the priv of the caller.\n     * Quarantined PCI devices will be associated with this domain.\n     */\n    dom_io = domain_create(DOMID_IO, NULL, false);\n    if ( IS_ERR(dom_io) )\n        panic(\"Failed to create d[IO]: %ld\\n\", PTR_ERR(dom_io));\n\n#ifdef CONFIG_MEM_SHARING\n    /*\n     * Initialise our COW domain.\n     * This domain owns sharable pages.\n     */\n    dom_cow = domain_create(DOMID_COW, NULL, false);\n    if ( IS_ERR(dom_cow) )\n        panic(\"Failed to create d[COW]: %ld\\n\", PTR_ERR(dom_cow));\n#endif\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -15,6 +15,7 @@\n      * Initialise our DOMID_IO domain.\n      * This domain owns I/O pages that are within the range of the page_info\n      * array. Mappings occur at the priv of the caller.\n+     * Quarantined PCI devices will be associated with this domain.\n      */\n     dom_io = domain_create(DOMID_IO, NULL, false);\n     if ( IS_ERR(dom_io) )",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "     * Quarantined PCI devices will be associated with this domain."
            ]
        }
    },
    {
        "cve_id": "CVE-2019-18424",
        "func_name": "xen-project/xen/amd_iommu_setup_domain_device",
        "description": "An issue was discovered in Xen through 4.12.x allowing attackers to gain host OS privileges via DMA in a situation where an untrusted domain has access to a physical device. This occurs because passed through PCI devices may corrupt host memory after deassignment. When a PCI device is assigned to an untrusted domain, it is possible for that domain to program the device to DMA to an arbitrary address. The IOMMU is used to protect the host from malicious DMA by making sure that the device addresses can only target memory assigned to the guest. However, when the guest domain is torn down, or the device is deassigned, the device is assigned back to dom0, thus allowing any in-flight DMA to potentially target critical host data. An untrusted domain with access to a physical device can DMA into host memory, leading to privilege escalation. Only systems where guests are given direct access to physical devices capable of DMA (PCI pass-through) are vulnerable. Systems which do not use PCI pass-through are not vulnerable.",
        "git_url": "https://github.com/xen-project/xen/commit/319f9a0ba94c7db505cd5dd9cb0b037ab1aa8e12",
        "commit_title": "passthrough: quarantine PCI devices",
        "commit_text": " When a PCI device is assigned to an untrusted domain, it is possible for that domain to program the device to DMA to an arbitrary address. The IOMMU is used to protect the host from malicious DMA by making sure that the device addresses can only target memory assigned to the guest. However, when the guest domain is torn down the device is assigned back to dom0, thus allowing any in-flight DMA to potentially target critical host data.  This patch introduces a 'quarantine' for PCI devices using dom_io. When the toolstack makes a device assignable (by binding it to pciback), it will now also assign it to DOMID_IO and the device will only be assigned back to dom0 when the device is made unassignable again. Whilst device is assignable it will only ever transfer between dom_io and guest domains. dom_io is actually only used as a sentinel domain for quarantining purposes; it is not configured with any IOMMU mappings. Assignment to dom_io simply means that the device's initiator (requestor) identifier is not present in the IOMMU's device table and thus any DMA transactions issued will be terminated with a fault condition.  In addition, a fix to assignment handling is made for VT-d.  Failure during the assignment step should not lead to a device still being associated with its prior owner. Hand the device to DomIO temporarily, until the assignment step has completed successfully.  Remove the PI hooks from the source domain then earlier as well.  Failure of the recovery reassign_device_ownership() may not go silent: There e.g. may still be left over RMRR mappings in the domain assignment to which has failed, and hence we can't allow that domain to continue executing.  NOTE: This patch also includes one printk() cleanup; the       \"XEN_DOMCTL_assign_device: \" tag is dropped in iommu_do_pci_domctl(),       since similar printk()-s elsewhere also don't log such a tag.  This is XSA-302. ",
        "func_before": "static void amd_iommu_setup_domain_device(\n    struct domain *domain, struct amd_iommu *iommu,\n    uint8_t devfn, struct pci_dev *pdev)\n{\n    struct amd_iommu_dte *table, *dte;\n    unsigned long flags;\n    int req_id, valid = 1;\n    u8 bus = pdev->bus;\n    const struct domain_iommu *hd = dom_iommu(domain);\n\n    BUG_ON( !hd->arch.root_table || !hd->arch.paging_mode ||\n            !iommu->dev_table.buffer );\n\n    if ( iommu_hwdom_passthrough && is_hardware_domain(domain) )\n        valid = 0;\n\n    /* get device-table entry */\n    req_id = get_dma_requestor_id(iommu->seg, PCI_BDF2(bus, devfn));\n    table = iommu->dev_table.buffer;\n    dte = &table[req_id];\n\n    spin_lock_irqsave(&iommu->lock, flags);\n\n    if ( !dte->v || !dte->tv )\n    {\n        /* bind DTE to domain page-tables */\n        amd_iommu_set_root_page_table(\n            dte, page_to_maddr(hd->arch.root_table), domain->domain_id,\n            hd->arch.paging_mode, valid);\n\n        if ( pci_ats_device(iommu->seg, bus, pdev->devfn) &&\n             iommu_has_cap(iommu, PCI_CAP_IOTLB_SHIFT) )\n            dte->i = ats_enabled;\n\n        amd_iommu_flush_device(iommu, req_id);\n\n        AMD_IOMMU_DEBUG(\"Setup I/O page table: device id = %#x, type = %#x, \"\n                        \"root table = %#\"PRIx64\", \"\n                        \"domain = %d, paging mode = %d\\n\",\n                        req_id, pdev->type,\n                        page_to_maddr(hd->arch.root_table),\n                        domain->domain_id, hd->arch.paging_mode);\n    }\n\n    spin_unlock_irqrestore(&iommu->lock, flags);\n\n    ASSERT(pcidevs_locked());\n\n    if ( pci_ats_device(iommu->seg, bus, pdev->devfn) &&\n         !pci_ats_enabled(iommu->seg, bus, pdev->devfn) )\n    {\n        if ( devfn == pdev->devfn )\n            enable_ats_device(pdev, &iommu->ats_devices);\n\n        amd_iommu_flush_iotlb(devfn, pdev, INV_IOMMU_ALL_PAGES_ADDRESS, 0);\n    }\n}",
        "func": "static void amd_iommu_setup_domain_device(\n    struct domain *domain, struct amd_iommu *iommu,\n    uint8_t devfn, struct pci_dev *pdev)\n{\n    struct amd_iommu_dte *table, *dte;\n    unsigned long flags;\n    int req_id, valid = 1;\n    u8 bus = pdev->bus;\n    const struct domain_iommu *hd = dom_iommu(domain);\n\n    /* dom_io is used as a sentinel for quarantined devices */\n    if ( domain == dom_io )\n        return;\n\n    BUG_ON( !hd->arch.root_table || !hd->arch.paging_mode ||\n            !iommu->dev_table.buffer );\n\n    if ( iommu_hwdom_passthrough && is_hardware_domain(domain) )\n        valid = 0;\n\n    /* get device-table entry */\n    req_id = get_dma_requestor_id(iommu->seg, PCI_BDF2(bus, devfn));\n    table = iommu->dev_table.buffer;\n    dte = &table[req_id];\n\n    spin_lock_irqsave(&iommu->lock, flags);\n\n    if ( !dte->v || !dte->tv )\n    {\n        /* bind DTE to domain page-tables */\n        amd_iommu_set_root_page_table(\n            dte, page_to_maddr(hd->arch.root_table), domain->domain_id,\n            hd->arch.paging_mode, valid);\n\n        if ( pci_ats_device(iommu->seg, bus, pdev->devfn) &&\n             iommu_has_cap(iommu, PCI_CAP_IOTLB_SHIFT) )\n            dte->i = ats_enabled;\n\n        amd_iommu_flush_device(iommu, req_id);\n\n        AMD_IOMMU_DEBUG(\"Setup I/O page table: device id = %#x, type = %#x, \"\n                        \"root table = %#\"PRIx64\", \"\n                        \"domain = %d, paging mode = %d\\n\",\n                        req_id, pdev->type,\n                        page_to_maddr(hd->arch.root_table),\n                        domain->domain_id, hd->arch.paging_mode);\n    }\n\n    spin_unlock_irqrestore(&iommu->lock, flags);\n\n    ASSERT(pcidevs_locked());\n\n    if ( pci_ats_device(iommu->seg, bus, pdev->devfn) &&\n         !pci_ats_enabled(iommu->seg, bus, pdev->devfn) )\n    {\n        if ( devfn == pdev->devfn )\n            enable_ats_device(pdev, &iommu->ats_devices);\n\n        amd_iommu_flush_iotlb(devfn, pdev, INV_IOMMU_ALL_PAGES_ADDRESS, 0);\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -7,6 +7,10 @@\n     int req_id, valid = 1;\n     u8 bus = pdev->bus;\n     const struct domain_iommu *hd = dom_iommu(domain);\n+\n+    /* dom_io is used as a sentinel for quarantined devices */\n+    if ( domain == dom_io )\n+        return;\n \n     BUG_ON( !hd->arch.root_table || !hd->arch.paging_mode ||\n             !iommu->dev_table.buffer );",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "    /* dom_io is used as a sentinel for quarantined devices */",
                "    if ( domain == dom_io )",
                "        return;"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-18424",
        "func_name": "xen-project/xen/amd_iommu_disable_domain_device",
        "description": "An issue was discovered in Xen through 4.12.x allowing attackers to gain host OS privileges via DMA in a situation where an untrusted domain has access to a physical device. This occurs because passed through PCI devices may corrupt host memory after deassignment. When a PCI device is assigned to an untrusted domain, it is possible for that domain to program the device to DMA to an arbitrary address. The IOMMU is used to protect the host from malicious DMA by making sure that the device addresses can only target memory assigned to the guest. However, when the guest domain is torn down, or the device is deassigned, the device is assigned back to dom0, thus allowing any in-flight DMA to potentially target critical host data. An untrusted domain with access to a physical device can DMA into host memory, leading to privilege escalation. Only systems where guests are given direct access to physical devices capable of DMA (PCI pass-through) are vulnerable. Systems which do not use PCI pass-through are not vulnerable.",
        "git_url": "https://github.com/xen-project/xen/commit/319f9a0ba94c7db505cd5dd9cb0b037ab1aa8e12",
        "commit_title": "passthrough: quarantine PCI devices",
        "commit_text": " When a PCI device is assigned to an untrusted domain, it is possible for that domain to program the device to DMA to an arbitrary address. The IOMMU is used to protect the host from malicious DMA by making sure that the device addresses can only target memory assigned to the guest. However, when the guest domain is torn down the device is assigned back to dom0, thus allowing any in-flight DMA to potentially target critical host data.  This patch introduces a 'quarantine' for PCI devices using dom_io. When the toolstack makes a device assignable (by binding it to pciback), it will now also assign it to DOMID_IO and the device will only be assigned back to dom0 when the device is made unassignable again. Whilst device is assignable it will only ever transfer between dom_io and guest domains. dom_io is actually only used as a sentinel domain for quarantining purposes; it is not configured with any IOMMU mappings. Assignment to dom_io simply means that the device's initiator (requestor) identifier is not present in the IOMMU's device table and thus any DMA transactions issued will be terminated with a fault condition.  In addition, a fix to assignment handling is made for VT-d.  Failure during the assignment step should not lead to a device still being associated with its prior owner. Hand the device to DomIO temporarily, until the assignment step has completed successfully.  Remove the PI hooks from the source domain then earlier as well.  Failure of the recovery reassign_device_ownership() may not go silent: There e.g. may still be left over RMRR mappings in the domain assignment to which has failed, and hence we can't allow that domain to continue executing.  NOTE: This patch also includes one printk() cleanup; the       \"XEN_DOMCTL_assign_device: \" tag is dropped in iommu_do_pci_domctl(),       since similar printk()-s elsewhere also don't log such a tag.  This is XSA-302. ",
        "func_before": "static void amd_iommu_disable_domain_device(const struct domain *domain,\n                                            struct amd_iommu *iommu,\n                                            uint8_t devfn, struct pci_dev *pdev)\n{\n    struct amd_iommu_dte *table, *dte;\n    unsigned long flags;\n    int req_id;\n    u8 bus = pdev->bus;\n\n    BUG_ON ( iommu->dev_table.buffer == NULL );\n    req_id = get_dma_requestor_id(iommu->seg, PCI_BDF2(bus, devfn));\n    table = iommu->dev_table.buffer;\n    dte = &table[req_id];\n\n    spin_lock_irqsave(&iommu->lock, flags);\n    if ( dte->tv || dte->v )\n    {\n        /* See the comment in amd_iommu_setup_device_table(). */\n        dte->int_ctl = IOMMU_DEV_TABLE_INT_CONTROL_ABORTED;\n        smp_wmb();\n        dte->iv = true;\n        dte->tv = false;\n        dte->gv = false;\n        dte->i = false;\n        dte->ex = false;\n        dte->sa = false;\n        dte->se = false;\n        dte->sd = false;\n        dte->sys_mgt = IOMMU_DEV_TABLE_SYS_MGT_DMA_ABORTED;\n        dte->ioctl = IOMMU_DEV_TABLE_IO_CONTROL_ABORTED;\n        smp_wmb();\n        dte->v = true;\n\n        amd_iommu_flush_device(iommu, req_id);\n\n        AMD_IOMMU_DEBUG(\"Disable: device id = %#x, \"\n                        \"domain = %d, paging mode = %d\\n\",\n                        req_id,  domain->domain_id,\n                        dom_iommu(domain)->arch.paging_mode);\n    }\n    spin_unlock_irqrestore(&iommu->lock, flags);\n\n    ASSERT(pcidevs_locked());\n\n    if ( devfn == pdev->devfn &&\n         pci_ats_device(iommu->seg, bus, devfn) &&\n         pci_ats_enabled(iommu->seg, bus, devfn) )\n        disable_ats_device(pdev);\n}",
        "func": "static void amd_iommu_disable_domain_device(const struct domain *domain,\n                                            struct amd_iommu *iommu,\n                                            uint8_t devfn, struct pci_dev *pdev)\n{\n    struct amd_iommu_dte *table, *dte;\n    unsigned long flags;\n    int req_id;\n    u8 bus = pdev->bus;\n\n    /* dom_io is used as a sentinel for quarantined devices */\n    if ( domain == dom_io )\n        return;\n\n    BUG_ON ( iommu->dev_table.buffer == NULL );\n    req_id = get_dma_requestor_id(iommu->seg, PCI_BDF2(bus, devfn));\n    table = iommu->dev_table.buffer;\n    dte = &table[req_id];\n\n    spin_lock_irqsave(&iommu->lock, flags);\n    if ( dte->tv || dte->v )\n    {\n        /* See the comment in amd_iommu_setup_device_table(). */\n        dte->int_ctl = IOMMU_DEV_TABLE_INT_CONTROL_ABORTED;\n        smp_wmb();\n        dte->iv = true;\n        dte->tv = false;\n        dte->gv = false;\n        dte->i = false;\n        dte->ex = false;\n        dte->sa = false;\n        dte->se = false;\n        dte->sd = false;\n        dte->sys_mgt = IOMMU_DEV_TABLE_SYS_MGT_DMA_ABORTED;\n        dte->ioctl = IOMMU_DEV_TABLE_IO_CONTROL_ABORTED;\n        smp_wmb();\n        dte->v = true;\n\n        amd_iommu_flush_device(iommu, req_id);\n\n        AMD_IOMMU_DEBUG(\"Disable: device id = %#x, \"\n                        \"domain = %d, paging mode = %d\\n\",\n                        req_id,  domain->domain_id,\n                        dom_iommu(domain)->arch.paging_mode);\n    }\n    spin_unlock_irqrestore(&iommu->lock, flags);\n\n    ASSERT(pcidevs_locked());\n\n    if ( devfn == pdev->devfn &&\n         pci_ats_device(iommu->seg, bus, devfn) &&\n         pci_ats_enabled(iommu->seg, bus, devfn) )\n        disable_ats_device(pdev);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,6 +6,10 @@\n     unsigned long flags;\n     int req_id;\n     u8 bus = pdev->bus;\n+\n+    /* dom_io is used as a sentinel for quarantined devices */\n+    if ( domain == dom_io )\n+        return;\n \n     BUG_ON ( iommu->dev_table.buffer == NULL );\n     req_id = get_dma_requestor_id(iommu->seg, PCI_BDF2(bus, devfn));",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "    /* dom_io is used as a sentinel for quarantined devices */",
                "    if ( domain == dom_io )",
                "        return;"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-18424",
        "func_name": "xen-project/xen/amd_iommu_assign_device",
        "description": "An issue was discovered in Xen through 4.12.x allowing attackers to gain host OS privileges via DMA in a situation where an untrusted domain has access to a physical device. This occurs because passed through PCI devices may corrupt host memory after deassignment. When a PCI device is assigned to an untrusted domain, it is possible for that domain to program the device to DMA to an arbitrary address. The IOMMU is used to protect the host from malicious DMA by making sure that the device addresses can only target memory assigned to the guest. However, when the guest domain is torn down, or the device is deassigned, the device is assigned back to dom0, thus allowing any in-flight DMA to potentially target critical host data. An untrusted domain with access to a physical device can DMA into host memory, leading to privilege escalation. Only systems where guests are given direct access to physical devices capable of DMA (PCI pass-through) are vulnerable. Systems which do not use PCI pass-through are not vulnerable.",
        "git_url": "https://github.com/xen-project/xen/commit/319f9a0ba94c7db505cd5dd9cb0b037ab1aa8e12",
        "commit_title": "passthrough: quarantine PCI devices",
        "commit_text": " When a PCI device is assigned to an untrusted domain, it is possible for that domain to program the device to DMA to an arbitrary address. The IOMMU is used to protect the host from malicious DMA by making sure that the device addresses can only target memory assigned to the guest. However, when the guest domain is torn down the device is assigned back to dom0, thus allowing any in-flight DMA to potentially target critical host data.  This patch introduces a 'quarantine' for PCI devices using dom_io. When the toolstack makes a device assignable (by binding it to pciback), it will now also assign it to DOMID_IO and the device will only be assigned back to dom0 when the device is made unassignable again. Whilst device is assignable it will only ever transfer between dom_io and guest domains. dom_io is actually only used as a sentinel domain for quarantining purposes; it is not configured with any IOMMU mappings. Assignment to dom_io simply means that the device's initiator (requestor) identifier is not present in the IOMMU's device table and thus any DMA transactions issued will be terminated with a fault condition.  In addition, a fix to assignment handling is made for VT-d.  Failure during the assignment step should not lead to a device still being associated with its prior owner. Hand the device to DomIO temporarily, until the assignment step has completed successfully.  Remove the PI hooks from the source domain then earlier as well.  Failure of the recovery reassign_device_ownership() may not go silent: There e.g. may still be left over RMRR mappings in the domain assignment to which has failed, and hence we can't allow that domain to continue executing.  NOTE: This patch also includes one printk() cleanup; the       \"XEN_DOMCTL_assign_device: \" tag is dropped in iommu_do_pci_domctl(),       since similar printk()-s elsewhere also don't log such a tag.  This is XSA-302. ",
        "func_before": "static int amd_iommu_assign_device(struct domain *d, u8 devfn,\n                                   struct pci_dev *pdev,\n                                   u32 flag)\n{\n    struct ivrs_mappings *ivrs_mappings = get_ivrs_mappings(pdev->seg);\n    int bdf = PCI_BDF2(pdev->bus, devfn);\n    int req_id = get_dma_requestor_id(pdev->seg, bdf);\n\n    if ( ivrs_mappings[req_id].unity_map_enable )\n    {\n        amd_iommu_reserve_domain_unity_map(\n            d,\n            ivrs_mappings[req_id].addr_range_start,\n            ivrs_mappings[req_id].addr_range_length,\n            ivrs_mappings[req_id].write_permission,\n            ivrs_mappings[req_id].read_permission);\n    }\n\n    return reassign_device(hardware_domain, d, devfn, pdev);\n}",
        "func": "static int amd_iommu_assign_device(struct domain *d, u8 devfn,\n                                   struct pci_dev *pdev,\n                                   u32 flag)\n{\n    struct ivrs_mappings *ivrs_mappings = get_ivrs_mappings(pdev->seg);\n    int bdf = PCI_BDF2(pdev->bus, devfn);\n    int req_id = get_dma_requestor_id(pdev->seg, bdf);\n\n    if ( ivrs_mappings[req_id].unity_map_enable )\n    {\n        amd_iommu_reserve_domain_unity_map(\n            d,\n            ivrs_mappings[req_id].addr_range_start,\n            ivrs_mappings[req_id].addr_range_length,\n            ivrs_mappings[req_id].write_permission,\n            ivrs_mappings[req_id].read_permission);\n    }\n\n    return reassign_device(pdev->domain, d, devfn, pdev);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -16,5 +16,5 @@\n             ivrs_mappings[req_id].read_permission);\n     }\n \n-    return reassign_device(hardware_domain, d, devfn, pdev);\n+    return reassign_device(pdev->domain, d, devfn, pdev);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    return reassign_device(hardware_domain, d, devfn, pdev);"
            ],
            "added_lines": [
                "    return reassign_device(pdev->domain, d, devfn, pdev);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-18424",
        "func_name": "xen-project/xen/libxl__device_pci_assignable_remove",
        "description": "An issue was discovered in Xen through 4.12.x allowing attackers to gain host OS privileges via DMA in a situation where an untrusted domain has access to a physical device. This occurs because passed through PCI devices may corrupt host memory after deassignment. When a PCI device is assigned to an untrusted domain, it is possible for that domain to program the device to DMA to an arbitrary address. The IOMMU is used to protect the host from malicious DMA by making sure that the device addresses can only target memory assigned to the guest. However, when the guest domain is torn down, or the device is deassigned, the device is assigned back to dom0, thus allowing any in-flight DMA to potentially target critical host data. An untrusted domain with access to a physical device can DMA into host memory, leading to privilege escalation. Only systems where guests are given direct access to physical devices capable of DMA (PCI pass-through) are vulnerable. Systems which do not use PCI pass-through are not vulnerable.",
        "git_url": "https://github.com/xen-project/xen/commit/319f9a0ba94c7db505cd5dd9cb0b037ab1aa8e12",
        "commit_title": "passthrough: quarantine PCI devices",
        "commit_text": " When a PCI device is assigned to an untrusted domain, it is possible for that domain to program the device to DMA to an arbitrary address. The IOMMU is used to protect the host from malicious DMA by making sure that the device addresses can only target memory assigned to the guest. However, when the guest domain is torn down the device is assigned back to dom0, thus allowing any in-flight DMA to potentially target critical host data.  This patch introduces a 'quarantine' for PCI devices using dom_io. When the toolstack makes a device assignable (by binding it to pciback), it will now also assign it to DOMID_IO and the device will only be assigned back to dom0 when the device is made unassignable again. Whilst device is assignable it will only ever transfer between dom_io and guest domains. dom_io is actually only used as a sentinel domain for quarantining purposes; it is not configured with any IOMMU mappings. Assignment to dom_io simply means that the device's initiator (requestor) identifier is not present in the IOMMU's device table and thus any DMA transactions issued will be terminated with a fault condition.  In addition, a fix to assignment handling is made for VT-d.  Failure during the assignment step should not lead to a device still being associated with its prior owner. Hand the device to DomIO temporarily, until the assignment step has completed successfully.  Remove the PI hooks from the source domain then earlier as well.  Failure of the recovery reassign_device_ownership() may not go silent: There e.g. may still be left over RMRR mappings in the domain assignment to which has failed, and hence we can't allow that domain to continue executing.  NOTE: This patch also includes one printk() cleanup; the       \"XEN_DOMCTL_assign_device: \" tag is dropped in iommu_do_pci_domctl(),       since similar printk()-s elsewhere also don't log such a tag.  This is XSA-302. ",
        "func_before": "static int libxl__device_pci_assignable_remove(libxl__gc *gc,\n                                               libxl_device_pci *pcidev,\n                                               int rebind)\n{\n    int rc;\n    char *driver_path;\n\n    /* Unbind from pciback */\n    if ( (rc=pciback_dev_is_assigned(gc, pcidev)) < 0 ) {\n        return ERROR_FAIL;\n    } else if ( rc ) {\n        pciback_dev_unassign(gc, pcidev);\n    } else {\n        LOG(WARN, \"Not bound to pciback\");\n    }\n\n    /* Rebind if necessary */\n    driver_path = pci_assignable_driver_path_read(gc, pcidev);\n\n    if ( driver_path ) {\n        if ( rebind ) {\n            LOG(INFO, \"Rebinding to driver at %s\", driver_path);\n\n            if ( sysfs_write_bdf(gc,\n                                 GCSPRINTF(\"%s/bind\", driver_path),\n                                 pcidev) < 0 ) {\n                LOGE(ERROR, \"Couldn't bind device to %s\", driver_path);\n                return -1;\n            }\n\n            pci_assignable_driver_path_remove(gc, pcidev);\n        }\n    } else {\n        if ( rebind ) {\n            LOG(WARN,\n                \"Couldn't find path for original driver; not rebinding\");\n        }\n    }\n\n    return 0;\n}",
        "func": "static int libxl__device_pci_assignable_remove(libxl__gc *gc,\n                                               libxl_device_pci *pcidev,\n                                               int rebind)\n{\n    libxl_ctx *ctx = libxl__gc_owner(gc);\n    int rc;\n    char *driver_path;\n\n    /* De-quarantine */\n    rc = xc_deassign_device(ctx->xch, DOMID_IO, pcidev_encode_bdf(pcidev));\n    if ( rc < 0 ) {\n        LOG(ERROR, \"failed to de-quarantine \"PCI_BDF, pcidev->domain, pcidev->bus,\n            pcidev->dev, pcidev->func);\n        return ERROR_FAIL;\n    }\n\n    /* Unbind from pciback */\n    if ( (rc=pciback_dev_is_assigned(gc, pcidev)) < 0 ) {\n        return ERROR_FAIL;\n    } else if ( rc ) {\n        pciback_dev_unassign(gc, pcidev);\n    } else {\n        LOG(WARN, \"Not bound to pciback\");\n    }\n\n    /* Rebind if necessary */\n    driver_path = pci_assignable_driver_path_read(gc, pcidev);\n\n    if ( driver_path ) {\n        if ( rebind ) {\n            LOG(INFO, \"Rebinding to driver at %s\", driver_path);\n\n            if ( sysfs_write_bdf(gc,\n                                 GCSPRINTF(\"%s/bind\", driver_path),\n                                 pcidev) < 0 ) {\n                LOGE(ERROR, \"Couldn't bind device to %s\", driver_path);\n                return -1;\n            }\n\n            pci_assignable_driver_path_remove(gc, pcidev);\n        }\n    } else {\n        if ( rebind ) {\n            LOG(WARN,\n                \"Couldn't find path for original driver; not rebinding\");\n        }\n    }\n\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,8 +2,17 @@\n                                                libxl_device_pci *pcidev,\n                                                int rebind)\n {\n+    libxl_ctx *ctx = libxl__gc_owner(gc);\n     int rc;\n     char *driver_path;\n+\n+    /* De-quarantine */\n+    rc = xc_deassign_device(ctx->xch, DOMID_IO, pcidev_encode_bdf(pcidev));\n+    if ( rc < 0 ) {\n+        LOG(ERROR, \"failed to de-quarantine \"PCI_BDF, pcidev->domain, pcidev->bus,\n+            pcidev->dev, pcidev->func);\n+        return ERROR_FAIL;\n+    }\n \n     /* Unbind from pciback */\n     if ( (rc=pciback_dev_is_assigned(gc, pcidev)) < 0 ) {",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    libxl_ctx *ctx = libxl__gc_owner(gc);",
                "",
                "    /* De-quarantine */",
                "    rc = xc_deassign_device(ctx->xch, DOMID_IO, pcidev_encode_bdf(pcidev));",
                "    if ( rc < 0 ) {",
                "        LOG(ERROR, \"failed to de-quarantine \"PCI_BDF, pcidev->domain, pcidev->bus,",
                "            pcidev->dev, pcidev->func);",
                "        return ERROR_FAIL;",
                "    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-18424",
        "func_name": "xen-project/xen/libxl__device_pci_assignable_add",
        "description": "An issue was discovered in Xen through 4.12.x allowing attackers to gain host OS privileges via DMA in a situation where an untrusted domain has access to a physical device. This occurs because passed through PCI devices may corrupt host memory after deassignment. When a PCI device is assigned to an untrusted domain, it is possible for that domain to program the device to DMA to an arbitrary address. The IOMMU is used to protect the host from malicious DMA by making sure that the device addresses can only target memory assigned to the guest. However, when the guest domain is torn down, or the device is deassigned, the device is assigned back to dom0, thus allowing any in-flight DMA to potentially target critical host data. An untrusted domain with access to a physical device can DMA into host memory, leading to privilege escalation. Only systems where guests are given direct access to physical devices capable of DMA (PCI pass-through) are vulnerable. Systems which do not use PCI pass-through are not vulnerable.",
        "git_url": "https://github.com/xen-project/xen/commit/319f9a0ba94c7db505cd5dd9cb0b037ab1aa8e12",
        "commit_title": "passthrough: quarantine PCI devices",
        "commit_text": " When a PCI device is assigned to an untrusted domain, it is possible for that domain to program the device to DMA to an arbitrary address. The IOMMU is used to protect the host from malicious DMA by making sure that the device addresses can only target memory assigned to the guest. However, when the guest domain is torn down the device is assigned back to dom0, thus allowing any in-flight DMA to potentially target critical host data.  This patch introduces a 'quarantine' for PCI devices using dom_io. When the toolstack makes a device assignable (by binding it to pciback), it will now also assign it to DOMID_IO and the device will only be assigned back to dom0 when the device is made unassignable again. Whilst device is assignable it will only ever transfer between dom_io and guest domains. dom_io is actually only used as a sentinel domain for quarantining purposes; it is not configured with any IOMMU mappings. Assignment to dom_io simply means that the device's initiator (requestor) identifier is not present in the IOMMU's device table and thus any DMA transactions issued will be terminated with a fault condition.  In addition, a fix to assignment handling is made for VT-d.  Failure during the assignment step should not lead to a device still being associated with its prior owner. Hand the device to DomIO temporarily, until the assignment step has completed successfully.  Remove the PI hooks from the source domain then earlier as well.  Failure of the recovery reassign_device_ownership() may not go silent: There e.g. may still be left over RMRR mappings in the domain assignment to which has failed, and hence we can't allow that domain to continue executing.  NOTE: This patch also includes one printk() cleanup; the       \"XEN_DOMCTL_assign_device: \" tag is dropped in iommu_do_pci_domctl(),       since similar printk()-s elsewhere also don't log such a tag.  This is XSA-302. ",
        "func_before": "static int libxl__device_pci_assignable_add(libxl__gc *gc,\n                                            libxl_device_pci *pcidev,\n                                            int rebind)\n{\n    unsigned dom, bus, dev, func;\n    char *spath, *driver_path = NULL;\n    int rc;\n    struct stat st;\n\n    /* Local copy for convenience */\n    dom = pcidev->domain;\n    bus = pcidev->bus;\n    dev = pcidev->dev;\n    func = pcidev->func;\n\n    /* See if the device exists */\n    spath = GCSPRINTF(SYSFS_PCI_DEV\"/\"PCI_BDF, dom, bus, dev, func);\n    if ( lstat(spath, &st) ) {\n        LOGE(ERROR, \"Couldn't lstat %s\", spath);\n        return ERROR_FAIL;\n    }",
        "func": "static int libxl__device_pci_assignable_add(libxl__gc *gc,\n                                            libxl_device_pci *pcidev,\n                                            int rebind)\n{\n    libxl_ctx *ctx = libxl__gc_owner(gc);\n    unsigned dom, bus, dev, func;\n    char *spath, *driver_path = NULL;\n    int rc;\n    struct stat st;\n\n    /* Local copy for convenience */\n    dom = pcidev->domain;\n    bus = pcidev->bus;\n    dev = pcidev->dev;\n    func = pcidev->func;\n\n    /* See if the device exists */\n    spath = GCSPRINTF(SYSFS_PCI_DEV\"/\"PCI_BDF, dom, bus, dev, func);\n    if ( lstat(spath, &st) ) {\n        LOGE(ERROR, \"Couldn't lstat %s\", spath);\n        return ERROR_FAIL;\n    }",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,6 +2,7 @@\n                                             libxl_device_pci *pcidev,\n                                             int rebind)\n {\n+    libxl_ctx *ctx = libxl__gc_owner(gc);\n     unsigned dom, bus, dev, func;\n     char *spath, *driver_path = NULL;\n     int rc;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    libxl_ctx *ctx = libxl__gc_owner(gc);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-18424",
        "func_name": "xen-project/xen/iommu_do_dt_domctl",
        "description": "An issue was discovered in Xen through 4.12.x allowing attackers to gain host OS privileges via DMA in a situation where an untrusted domain has access to a physical device. This occurs because passed through PCI devices may corrupt host memory after deassignment. When a PCI device is assigned to an untrusted domain, it is possible for that domain to program the device to DMA to an arbitrary address. The IOMMU is used to protect the host from malicious DMA by making sure that the device addresses can only target memory assigned to the guest. However, when the guest domain is torn down, or the device is deassigned, the device is assigned back to dom0, thus allowing any in-flight DMA to potentially target critical host data. An untrusted domain with access to a physical device can DMA into host memory, leading to privilege escalation. Only systems where guests are given direct access to physical devices capable of DMA (PCI pass-through) are vulnerable. Systems which do not use PCI pass-through are not vulnerable.",
        "git_url": "https://github.com/xen-project/xen/commit/319f9a0ba94c7db505cd5dd9cb0b037ab1aa8e12",
        "commit_title": "passthrough: quarantine PCI devices",
        "commit_text": " When a PCI device is assigned to an untrusted domain, it is possible for that domain to program the device to DMA to an arbitrary address. The IOMMU is used to protect the host from malicious DMA by making sure that the device addresses can only target memory assigned to the guest. However, when the guest domain is torn down the device is assigned back to dom0, thus allowing any in-flight DMA to potentially target critical host data.  This patch introduces a 'quarantine' for PCI devices using dom_io. When the toolstack makes a device assignable (by binding it to pciback), it will now also assign it to DOMID_IO and the device will only be assigned back to dom0 when the device is made unassignable again. Whilst device is assignable it will only ever transfer between dom_io and guest domains. dom_io is actually only used as a sentinel domain for quarantining purposes; it is not configured with any IOMMU mappings. Assignment to dom_io simply means that the device's initiator (requestor) identifier is not present in the IOMMU's device table and thus any DMA transactions issued will be terminated with a fault condition.  In addition, a fix to assignment handling is made for VT-d.  Failure during the assignment step should not lead to a device still being associated with its prior owner. Hand the device to DomIO temporarily, until the assignment step has completed successfully.  Remove the PI hooks from the source domain then earlier as well.  Failure of the recovery reassign_device_ownership() may not go silent: There e.g. may still be left over RMRR mappings in the domain assignment to which has failed, and hence we can't allow that domain to continue executing.  NOTE: This patch also includes one printk() cleanup; the       \"XEN_DOMCTL_assign_device: \" tag is dropped in iommu_do_pci_domctl(),       since similar printk()-s elsewhere also don't log such a tag.  This is XSA-302. ",
        "func_before": "int iommu_do_dt_domctl(struct xen_domctl *domctl, struct domain *d,\n                       XEN_GUEST_HANDLE_PARAM(xen_domctl_t) u_domctl)\n{\n    int ret;\n    struct dt_device_node *dev;\n\n    switch ( domctl->cmd )\n    {\n    case XEN_DOMCTL_assign_device:\n        ASSERT(d);\n        /* fall through */\n    case XEN_DOMCTL_test_assign_device:\n        ret = -ENODEV;\n        if ( domctl->u.assign_device.dev != XEN_DOMCTL_DEV_DT )\n            break;\n\n        ret = -EINVAL;\n        if ( (d && d->is_dying) || domctl->u.assign_device.flags )\n            break;\n\n        ret = dt_find_node_by_gpath(domctl->u.assign_device.u.dt.path,\n                                    domctl->u.assign_device.u.dt.size,\n                                    &dev);\n        if ( ret )\n            break;\n\n        ret = xsm_assign_dtdevice(XSM_HOOK, d, dt_node_full_name(dev));\n        if ( ret )\n            break;\n\n        if ( domctl->cmd == XEN_DOMCTL_test_assign_device )\n        {\n            if ( iommu_dt_device_is_assigned(dev) )\n            {\n                printk(XENLOG_G_ERR \"%s already assigned.\\n\",\n                       dt_node_full_name(dev));\n                ret = -EINVAL;\n            }\n            break;\n        }\n\n        ret = iommu_add_dt_device(dev);\n        /*\n         * Ignore \"-EEXIST\" error code as it would mean that the device is\n         * already added to the IOMMU (positive result). Such happens after\n         * re-creating guest domain.\n         */\n        if ( ret < 0 && ret != -EEXIST )\n        {\n            printk(XENLOG_G_ERR \"Failed to add %s to the IOMMU\\n\",\n                   dt_node_full_name(dev));\n            break;\n        }\n\n        ret = iommu_assign_dt_device(d, dev);\n\n        if ( ret )\n            printk(XENLOG_G_ERR \"XEN_DOMCTL_assign_dt_device: assign \\\"%s\\\"\"\n                   \" to dom%u failed (%d)\\n\",\n                   dt_node_full_name(dev), d->domain_id, ret);\n        break;\n\n    case XEN_DOMCTL_deassign_device:\n        ret = -ENODEV;\n        if ( domctl->u.assign_device.dev != XEN_DOMCTL_DEV_DT )\n            break;\n\n        ret = -EINVAL;\n        if ( domctl->u.assign_device.flags )\n            break;\n\n        ret = dt_find_node_by_gpath(domctl->u.assign_device.u.dt.path,\n                                    domctl->u.assign_device.u.dt.size,\n                                    &dev);\n        if ( ret )\n            break;\n\n        ret = xsm_deassign_dtdevice(XSM_HOOK, d, dt_node_full_name(dev));\n\n        ret = iommu_deassign_dt_device(d, dev);\n\n        if ( ret )\n            printk(XENLOG_G_ERR \"XEN_DOMCTL_assign_dt_device: assign \\\"%s\\\"\"\n                   \" to dom%u failed (%d)\\n\",\n                   dt_node_full_name(dev), d->domain_id, ret);\n        break;\n\n    default:\n        ret = -ENOSYS;\n        break;\n    }\n\n    return ret;\n}",
        "func": "int iommu_do_dt_domctl(struct xen_domctl *domctl, struct domain *d,\n                       XEN_GUEST_HANDLE_PARAM(xen_domctl_t) u_domctl)\n{\n    int ret;\n    struct dt_device_node *dev;\n\n    switch ( domctl->cmd )\n    {\n    case XEN_DOMCTL_assign_device:\n        ASSERT(d);\n        /* fall through */\n    case XEN_DOMCTL_test_assign_device:\n        ret = -ENODEV;\n        if ( domctl->u.assign_device.dev != XEN_DOMCTL_DEV_DT )\n            break;\n\n        ret = -EINVAL;\n        if ( (d && d->is_dying) || domctl->u.assign_device.flags )\n            break;\n\n        ret = dt_find_node_by_gpath(domctl->u.assign_device.u.dt.path,\n                                    domctl->u.assign_device.u.dt.size,\n                                    &dev);\n        if ( ret )\n            break;\n\n        ret = xsm_assign_dtdevice(XSM_HOOK, d, dt_node_full_name(dev));\n        if ( ret )\n            break;\n\n        if ( domctl->cmd == XEN_DOMCTL_test_assign_device )\n        {\n            if ( iommu_dt_device_is_assigned(dev) )\n            {\n                printk(XENLOG_G_ERR \"%s already assigned.\\n\",\n                       dt_node_full_name(dev));\n                ret = -EINVAL;\n            }\n            break;\n        }\n\n        if ( d == dom_io )\n            return -EINVAL;\n\n        ret = iommu_add_dt_device(dev);\n        /*\n         * Ignore \"-EEXIST\" error code as it would mean that the device is\n         * already added to the IOMMU (positive result). Such happens after\n         * re-creating guest domain.\n         */\n        if ( ret < 0 && ret != -EEXIST )\n        {\n            printk(XENLOG_G_ERR \"Failed to add %s to the IOMMU\\n\",\n                   dt_node_full_name(dev));\n            break;\n        }\n\n        ret = iommu_assign_dt_device(d, dev);\n\n        if ( ret )\n            printk(XENLOG_G_ERR \"XEN_DOMCTL_assign_dt_device: assign \\\"%s\\\"\"\n                   \" to dom%u failed (%d)\\n\",\n                   dt_node_full_name(dev), d->domain_id, ret);\n        break;\n\n    case XEN_DOMCTL_deassign_device:\n        ret = -ENODEV;\n        if ( domctl->u.assign_device.dev != XEN_DOMCTL_DEV_DT )\n            break;\n\n        ret = -EINVAL;\n        if ( domctl->u.assign_device.flags )\n            break;\n\n        ret = dt_find_node_by_gpath(domctl->u.assign_device.u.dt.path,\n                                    domctl->u.assign_device.u.dt.size,\n                                    &dev);\n        if ( ret )\n            break;\n\n        ret = xsm_deassign_dtdevice(XSM_HOOK, d, dt_node_full_name(dev));\n\n        if ( d == dom_io )\n            return -EINVAL;\n\n        ret = iommu_deassign_dt_device(d, dev);\n\n        if ( ret )\n            printk(XENLOG_G_ERR \"XEN_DOMCTL_assign_dt_device: assign \\\"%s\\\"\"\n                   \" to dom%u failed (%d)\\n\",\n                   dt_node_full_name(dev), d->domain_id, ret);\n        break;\n\n    default:\n        ret = -ENOSYS;\n        break;\n    }\n\n    return ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -39,6 +39,9 @@\n             break;\n         }\n \n+        if ( d == dom_io )\n+            return -EINVAL;\n+\n         ret = iommu_add_dt_device(dev);\n         /*\n          * Ignore \"-EEXIST\" error code as it would mean that the device is\n@@ -77,6 +80,9 @@\n \n         ret = xsm_deassign_dtdevice(XSM_HOOK, d, dt_node_full_name(dev));\n \n+        if ( d == dom_io )\n+            return -EINVAL;\n+\n         ret = iommu_deassign_dt_device(d, dev);\n \n         if ( ret )",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "        if ( d == dom_io )",
                "            return -EINVAL;",
                "",
                "        if ( d == dom_io )",
                "            return -EINVAL;",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2019-18424",
        "func_name": "xen-project/xen/do_domctl",
        "description": "An issue was discovered in Xen through 4.12.x allowing attackers to gain host OS privileges via DMA in a situation where an untrusted domain has access to a physical device. This occurs because passed through PCI devices may corrupt host memory after deassignment. When a PCI device is assigned to an untrusted domain, it is possible for that domain to program the device to DMA to an arbitrary address. The IOMMU is used to protect the host from malicious DMA by making sure that the device addresses can only target memory assigned to the guest. However, when the guest domain is torn down, or the device is deassigned, the device is assigned back to dom0, thus allowing any in-flight DMA to potentially target critical host data. An untrusted domain with access to a physical device can DMA into host memory, leading to privilege escalation. Only systems where guests are given direct access to physical devices capable of DMA (PCI pass-through) are vulnerable. Systems which do not use PCI pass-through are not vulnerable.",
        "git_url": "https://github.com/xen-project/xen/commit/319f9a0ba94c7db505cd5dd9cb0b037ab1aa8e12",
        "commit_title": "passthrough: quarantine PCI devices",
        "commit_text": " When a PCI device is assigned to an untrusted domain, it is possible for that domain to program the device to DMA to an arbitrary address. The IOMMU is used to protect the host from malicious DMA by making sure that the device addresses can only target memory assigned to the guest. However, when the guest domain is torn down the device is assigned back to dom0, thus allowing any in-flight DMA to potentially target critical host data.  This patch introduces a 'quarantine' for PCI devices using dom_io. When the toolstack makes a device assignable (by binding it to pciback), it will now also assign it to DOMID_IO and the device will only be assigned back to dom0 when the device is made unassignable again. Whilst device is assignable it will only ever transfer between dom_io and guest domains. dom_io is actually only used as a sentinel domain for quarantining purposes; it is not configured with any IOMMU mappings. Assignment to dom_io simply means that the device's initiator (requestor) identifier is not present in the IOMMU's device table and thus any DMA transactions issued will be terminated with a fault condition.  In addition, a fix to assignment handling is made for VT-d.  Failure during the assignment step should not lead to a device still being associated with its prior owner. Hand the device to DomIO temporarily, until the assignment step has completed successfully.  Remove the PI hooks from the source domain then earlier as well.  Failure of the recovery reassign_device_ownership() may not go silent: There e.g. may still be left over RMRR mappings in the domain assignment to which has failed, and hence we can't allow that domain to continue executing.  NOTE: This patch also includes one printk() cleanup; the       \"XEN_DOMCTL_assign_device: \" tag is dropped in iommu_do_pci_domctl(),       since similar printk()-s elsewhere also don't log such a tag.  This is XSA-302. ",
        "func_before": "long do_domctl(XEN_GUEST_HANDLE_PARAM(xen_domctl_t) u_domctl)\n{\n    long ret = 0;\n    bool_t copyback = 0;\n    struct xen_domctl curop, *op = &curop;\n    struct domain *d;\n\n    if ( copy_from_guest(op, u_domctl, 1) )\n        return -EFAULT;\n\n    if ( op->interface_version != XEN_DOMCTL_INTERFACE_VERSION )\n        return -EACCES;\n\n    switch ( op->cmd )\n    {\n    case XEN_DOMCTL_test_assign_device:\n    case XEN_DOMCTL_vm_event_op:\n        if ( op->domain == DOMID_INVALID )\n        {\n    case XEN_DOMCTL_createdomain:\n    case XEN_DOMCTL_gdbsx_guestmemio:\n            d = NULL;\n            break;\n        }\n        /* fall through */\n    default:\n        d = rcu_lock_domain_by_id(op->domain);\n        if ( !d && op->cmd != XEN_DOMCTL_getdomaininfo )\n            return -ESRCH;\n    }\n\n    ret = xsm_domctl(XSM_OTHER, d, op->cmd);\n    if ( ret )\n        goto domctl_out_unlock_domonly;\n\n    if ( !domctl_lock_acquire() )\n    {\n        if ( d )\n            rcu_unlock_domain(d);\n        return hypercall_create_continuation(\n            __HYPERVISOR_domctl, \"h\", u_domctl);\n    }\n\n    switch ( op->cmd )\n    {\n\n    case XEN_DOMCTL_setvcpucontext:\n    {\n        vcpu_guest_context_u c = { .nat = NULL };\n        unsigned int vcpu = op->u.vcpucontext.vcpu;\n        struct vcpu *v;\n\n        ret = -EINVAL;\n        if ( (d == current->domain) || /* no domain_pause() */\n             (vcpu >= d->max_vcpus) || ((v = d->vcpu[vcpu]) == NULL) )\n            break;\n\n        if ( guest_handle_is_null(op->u.vcpucontext.ctxt) )\n        {\n            ret = vcpu_reset(v);\n            if ( ret == -ERESTART )\n                ret = hypercall_create_continuation(\n                          __HYPERVISOR_domctl, \"h\", u_domctl);\n            break;\n        }\n\n#ifdef CONFIG_COMPAT\n        BUILD_BUG_ON(sizeof(struct vcpu_guest_context)\n                     < sizeof(struct compat_vcpu_guest_context));\n#endif\n        ret = -ENOMEM;\n        if ( (c.nat = alloc_vcpu_guest_context()) == NULL )\n            break;\n\n#ifdef CONFIG_COMPAT\n        if ( !is_pv_32bit_domain(d) )\n            ret = copy_from_guest(c.nat, op->u.vcpucontext.ctxt, 1);\n        else\n            ret = copy_from_guest(c.cmp,\n                                  guest_handle_cast(op->u.vcpucontext.ctxt,\n                                                    void), 1);\n#else\n        ret = copy_from_guest(c.nat, op->u.vcpucontext.ctxt, 1);\n#endif\n        ret = ret ? -EFAULT : 0;\n\n        if ( ret == 0 )\n        {\n            domain_pause(d);\n            ret = arch_set_info_guest(v, c);\n            domain_unpause(d);\n\n            if ( ret == -ERESTART )\n                ret = hypercall_create_continuation(\n                          __HYPERVISOR_domctl, \"h\", u_domctl);\n        }\n\n        free_vcpu_guest_context(c.nat);\n        break;\n    }\n\n    case XEN_DOMCTL_pausedomain:\n        ret = -EINVAL;\n        if ( d != current->domain )\n            ret = domain_pause_by_systemcontroller(d);\n        break;\n\n    case XEN_DOMCTL_unpausedomain:\n        ret = domain_unpause_by_systemcontroller(d);\n        break;\n\n    case XEN_DOMCTL_resumedomain:\n        if ( d == current->domain ) /* no domain_pause() */\n            ret = -EINVAL;\n        else\n            domain_resume(d);\n        break;\n\n    case XEN_DOMCTL_createdomain:\n    {\n        domid_t        dom;\n        static domid_t rover = 0;\n\n        dom = op->domain;\n        if ( (dom > 0) && (dom < DOMID_FIRST_RESERVED) )\n        {\n            ret = -EINVAL;\n            if ( !is_free_domid(dom) )\n                break;\n        }\n        else\n        {\n            for ( dom = rover + 1; dom != rover; dom++ )\n            {\n                if ( dom == DOMID_FIRST_RESERVED )\n                    dom = 1;\n                if ( is_free_domid(dom) )\n                    break;\n            }\n\n            ret = -ENOMEM;\n            if ( dom == rover )\n                break;\n\n            rover = dom;\n        }\n\n        d = domain_create(dom, &op->u.createdomain, false);\n        if ( IS_ERR(d) )\n        {\n            ret = PTR_ERR(d);\n            d = NULL;\n            break;\n        }\n\n        ret = 0;\n        op->domain = d->domain_id;\n        copyback = 1;\n        d = NULL;\n        break;\n    }\n\n    case XEN_DOMCTL_max_vcpus:\n    {\n        unsigned int i, max = op->u.max_vcpus.max;\n\n        ret = -EINVAL;\n        if ( (d == current->domain) || /* no domain_pause() */\n             (max != d->max_vcpus) )   /* max_vcpus set up in createdomain */\n            break;\n\n        /* Needed, for example, to ensure writable p.t. state is synced. */\n        domain_pause(d);\n\n        ret = -ENOMEM;\n\n        for ( i = 0; i < max; i++ )\n        {\n            if ( d->vcpu[i] != NULL )\n                continue;\n\n            if ( vcpu_create(d, i) == NULL )\n                goto maxvcpu_out;\n        }\n\n        domain_update_node_affinity(d);\n        ret = 0;\n\n    maxvcpu_out:\n        domain_unpause(d);\n        break;\n    }\n\n    case XEN_DOMCTL_soft_reset:\n        if ( d == current->domain ) /* no domain_pause() */\n        {\n            ret = -EINVAL;\n            break;\n        }\n        ret = domain_soft_reset(d);\n        break;\n\n    case XEN_DOMCTL_destroydomain:\n        domctl_lock_release();\n        domain_lock(d);\n        ret = domain_kill(d);\n        domain_unlock(d);\n        if ( ret == -ERESTART )\n            ret = hypercall_create_continuation(\n                __HYPERVISOR_domctl, \"h\", u_domctl);\n        goto domctl_out_unlock_domonly;\n\n    case XEN_DOMCTL_setnodeaffinity:\n    {\n        nodemask_t new_affinity;\n\n        ret = xenctl_bitmap_to_nodemask(&new_affinity,\n                                        &op->u.nodeaffinity.nodemap);\n        if ( !ret )\n            ret = domain_set_node_affinity(d, &new_affinity);\n        break;\n    }\n\n    case XEN_DOMCTL_getnodeaffinity:\n        ret = nodemask_to_xenctl_bitmap(&op->u.nodeaffinity.nodemap,\n                                        &d->node_affinity);\n        break;\n\n    case XEN_DOMCTL_setvcpuaffinity:\n    case XEN_DOMCTL_getvcpuaffinity:\n    {\n        struct vcpu *v;\n        const struct sched_unit *unit;\n        struct xen_domctl_vcpuaffinity *vcpuaff = &op->u.vcpuaffinity;\n\n        ret = -EINVAL;\n        if ( vcpuaff->vcpu >= d->max_vcpus )\n            break;\n\n        ret = -ESRCH;\n        if ( (v = d->vcpu[vcpuaff->vcpu]) == NULL )\n            break;\n\n        unit = v->sched_unit;\n        ret = -EINVAL;\n        if ( vcpuaffinity_params_invalid(vcpuaff) )\n            break;\n\n        if ( op->cmd == XEN_DOMCTL_setvcpuaffinity )\n        {\n            cpumask_var_t new_affinity, old_affinity;\n            cpumask_t *online = cpupool_domain_master_cpumask(v->domain);\n\n            /*\n             * We want to be able to restore hard affinity if we are trying\n             * setting both and changing soft affinity (which happens later,\n             * when hard affinity has been succesfully chaged already) fails.\n             */\n            if ( !alloc_cpumask_var(&old_affinity) )\n            {\n                ret = -ENOMEM;\n                break;\n            }\n            cpumask_copy(old_affinity, unit->cpu_hard_affinity);\n\n            if ( !alloc_cpumask_var(&new_affinity) )\n            {\n                free_cpumask_var(old_affinity);\n                ret = -ENOMEM;\n                break;\n            }\n\n            /* Undo a stuck SCHED_pin_override? */\n            if ( vcpuaff->flags & XEN_VCPUAFFINITY_FORCE )\n                vcpu_temporary_affinity(v, NR_CPUS, VCPU_AFFINITY_OVERRIDE);\n\n            ret = 0;\n\n            /*\n             * We both set a new affinity and report back to the caller what\n             * the scheduler will be effectively using.\n             */\n            if ( vcpuaff->flags & XEN_VCPUAFFINITY_HARD )\n            {\n                ret = xenctl_bitmap_to_bitmap(cpumask_bits(new_affinity),\n                                              &vcpuaff->cpumap_hard,\n                                              nr_cpu_ids);\n                if ( !ret )\n                    ret = vcpu_set_hard_affinity(v, new_affinity);\n                if ( ret )\n                    goto setvcpuaffinity_out;\n\n                /*\n                 * For hard affinity, what we return is the intersection of\n                 * cpupool's online mask and the new hard affinity.\n                 */\n                cpumask_and(new_affinity, online, unit->cpu_hard_affinity);\n                ret = cpumask_to_xenctl_bitmap(&vcpuaff->cpumap_hard,\n                                               new_affinity);\n            }\n            if ( vcpuaff->flags & XEN_VCPUAFFINITY_SOFT )\n            {\n                ret = xenctl_bitmap_to_bitmap(cpumask_bits(new_affinity),\n                                              &vcpuaff->cpumap_soft,\n                                              nr_cpu_ids);\n                if ( !ret)\n                    ret = vcpu_set_soft_affinity(v, new_affinity);\n                if ( ret )\n                {\n                    /*\n                     * Since we're returning error, the caller expects nothing\n                     * happened, so we rollback the changes to hard affinity\n                     * (if any).\n                     */\n                    if ( vcpuaff->flags & XEN_VCPUAFFINITY_HARD )\n                        vcpu_set_hard_affinity(v, old_affinity);\n                    goto setvcpuaffinity_out;\n                }\n\n                /*\n                 * For soft affinity, we return the intersection between the\n                 * new soft affinity, the cpupool's online map and the (new)\n                 * hard affinity.\n                 */\n                cpumask_and(new_affinity, new_affinity, online);\n                cpumask_and(new_affinity, new_affinity,\n                            unit->cpu_hard_affinity);\n                ret = cpumask_to_xenctl_bitmap(&vcpuaff->cpumap_soft,\n                                               new_affinity);\n            }\n\n setvcpuaffinity_out:\n            free_cpumask_var(new_affinity);\n            free_cpumask_var(old_affinity);\n        }\n        else\n        {\n            if ( vcpuaff->flags & XEN_VCPUAFFINITY_HARD )\n                ret = cpumask_to_xenctl_bitmap(&vcpuaff->cpumap_hard,\n                                               unit->cpu_hard_affinity);\n            if ( vcpuaff->flags & XEN_VCPUAFFINITY_SOFT )\n                ret = cpumask_to_xenctl_bitmap(&vcpuaff->cpumap_soft,\n                                               unit->cpu_soft_affinity);\n        }\n        break;\n    }\n\n    case XEN_DOMCTL_scheduler_op:\n        ret = sched_adjust(d, &op->u.scheduler_op);\n        copyback = 1;\n        break;\n\n    case XEN_DOMCTL_getdomaininfo:\n    {\n        domid_t dom = DOMID_INVALID;\n\n        if ( !d )\n        {\n            ret = -EINVAL;\n            if ( op->domain >= DOMID_FIRST_RESERVED )\n                break;\n\n            rcu_read_lock(&domlist_read_lock);\n\n            dom = op->domain;\n            for_each_domain ( d )\n                if ( d->domain_id >= dom )\n                    break;\n        }\n\n        ret = -ESRCH;\n        if ( d == NULL )\n            goto getdomaininfo_out;\n\n        ret = xsm_getdomaininfo(XSM_HOOK, d);\n        if ( ret )\n            goto getdomaininfo_out;\n\n        getdomaininfo(d, &op->u.getdomaininfo);\n\n        op->domain = op->u.getdomaininfo.domain;\n        copyback = 1;\n\n    getdomaininfo_out:\n        /* When d was non-NULL upon entry, no cleanup is needed. */\n        if ( dom == DOMID_INVALID )\n            break;\n\n        rcu_read_unlock(&domlist_read_lock);\n        d = NULL;\n        break;\n    }\n\n    case XEN_DOMCTL_getvcpucontext:\n    {\n        vcpu_guest_context_u c = { .nat = NULL };\n        struct vcpu         *v;\n\n        ret = -EINVAL;\n        if ( op->u.vcpucontext.vcpu >= d->max_vcpus ||\n             (v = d->vcpu[op->u.vcpucontext.vcpu]) == NULL ||\n             v == current ) /* no vcpu_pause() */\n            goto getvcpucontext_out;\n\n        ret = -ENODATA;\n        if ( !v->is_initialised )\n            goto getvcpucontext_out;\n\n#ifdef CONFIG_COMPAT\n        BUILD_BUG_ON(sizeof(struct vcpu_guest_context)\n                     < sizeof(struct compat_vcpu_guest_context));\n#endif\n        ret = -ENOMEM;\n        if ( (c.nat = xzalloc(struct vcpu_guest_context)) == NULL )\n            goto getvcpucontext_out;\n\n        vcpu_pause(v);\n\n        arch_get_info_guest(v, c);\n        ret = 0;\n\n        vcpu_unpause(v);\n\n#ifdef CONFIG_COMPAT\n        if ( !is_pv_32bit_domain(d) )\n            ret = copy_to_guest(op->u.vcpucontext.ctxt, c.nat, 1);\n        else\n            ret = copy_to_guest(guest_handle_cast(op->u.vcpucontext.ctxt,\n                                                  void), c.cmp, 1);\n#else\n        ret = copy_to_guest(op->u.vcpucontext.ctxt, c.nat, 1);\n#endif\n\n        if ( ret )\n            ret = -EFAULT;\n        copyback = 1;\n\n    getvcpucontext_out:\n        xfree(c.nat);\n        break;\n    }\n\n    case XEN_DOMCTL_getvcpuinfo:\n    {\n        struct vcpu   *v;\n        struct vcpu_runstate_info runstate;\n\n        ret = -EINVAL;\n        if ( op->u.getvcpuinfo.vcpu >= d->max_vcpus )\n            break;\n\n        ret = -ESRCH;\n        if ( (v = d->vcpu[op->u.getvcpuinfo.vcpu]) == NULL )\n            break;\n\n        vcpu_runstate_get(v, &runstate);\n\n        op->u.getvcpuinfo.online   = !(v->pause_flags & VPF_down);\n        op->u.getvcpuinfo.blocked  = !!(v->pause_flags & VPF_blocked);\n        op->u.getvcpuinfo.running  = v->is_running;\n        op->u.getvcpuinfo.cpu_time = runstate.time[RUNSTATE_running];\n        op->u.getvcpuinfo.cpu      = v->processor;\n        ret = 0;\n        copyback = 1;\n        break;\n    }\n\n    case XEN_DOMCTL_max_mem:\n    {\n        uint64_t new_max = op->u.max_mem.max_memkb >> (PAGE_SHIFT - 10);\n\n        spin_lock(&d->page_alloc_lock);\n        /*\n         * NB. We removed a check that new_max >= current tot_pages; this means\n         * that the domain will now be allowed to \"ratchet\" down to new_max. In\n         * the meantime, while tot > max, all new allocations are disallowed.\n         */\n        d->max_pages = min(new_max, (uint64_t)(typeof(d->max_pages))-1);\n        spin_unlock(&d->page_alloc_lock);\n        break;\n    }\n\n    case XEN_DOMCTL_setdomainhandle:\n        memcpy(d->handle, op->u.setdomainhandle.handle,\n               sizeof(xen_domain_handle_t));\n        break;\n\n    case XEN_DOMCTL_setdebugging:\n        if ( unlikely(d == current->domain) ) /* no domain_pause() */\n            ret = -EINVAL;\n        else\n        {\n            domain_pause(d);\n            d->debugger_attached = !!op->u.setdebugging.enable;\n            domain_unpause(d); /* causes guest to latch new status */\n        }\n        break;\n\n    case XEN_DOMCTL_irq_permission:\n    {\n        unsigned int pirq = op->u.irq_permission.pirq, irq;\n        int allow = op->u.irq_permission.allow_access;\n\n        if ( pirq >= current->domain->nr_pirqs )\n        {\n            ret = -EINVAL;\n            break;\n        }\n        irq = pirq_access_permitted(current->domain, pirq);\n        if ( !irq || xsm_irq_permission(XSM_HOOK, d, irq, allow) )\n            ret = -EPERM;\n        else if ( allow )\n            ret = irq_permit_access(d, irq);\n        else\n            ret = irq_deny_access(d, irq);\n        break;\n    }\n\n    case XEN_DOMCTL_iomem_permission:\n    {\n        unsigned long mfn = op->u.iomem_permission.first_mfn;\n        unsigned long nr_mfns = op->u.iomem_permission.nr_mfns;\n        int allow = op->u.iomem_permission.allow_access;\n\n        ret = -EINVAL;\n        if ( (mfn + nr_mfns - 1) < mfn ) /* wrap? */\n            break;\n\n        if ( !iomem_access_permitted(current->domain,\n                                     mfn, mfn + nr_mfns - 1) ||\n             xsm_iomem_permission(XSM_HOOK, d, mfn, mfn + nr_mfns - 1, allow) )\n            ret = -EPERM;\n        else if ( allow )\n            ret = iomem_permit_access(d, mfn, mfn + nr_mfns - 1);\n        else\n            ret = iomem_deny_access(d, mfn, mfn + nr_mfns - 1);\n        if ( !ret )\n            memory_type_changed(d);\n        break;\n    }\n\n    case XEN_DOMCTL_memory_mapping:\n    {\n        unsigned long gfn = op->u.memory_mapping.first_gfn;\n        unsigned long mfn = op->u.memory_mapping.first_mfn;\n        unsigned long nr_mfns = op->u.memory_mapping.nr_mfns;\n        unsigned long mfn_end = mfn + nr_mfns - 1;\n        int add = op->u.memory_mapping.add_mapping;\n\n        ret = -EINVAL;\n        if ( mfn_end < mfn || /* wrap? */\n             ((mfn | mfn_end) >> (paddr_bits - PAGE_SHIFT)) ||\n             (gfn + nr_mfns - 1) < gfn ) /* wrap? */\n            break;\n\n#ifndef CONFIG_X86 /* XXX ARM!? */\n        ret = -E2BIG;\n        /* Must break hypercall up as this could take a while. */\n        if ( nr_mfns > 64 )\n            break;\n#endif\n\n        ret = -EPERM;\n        if ( !iomem_access_permitted(current->domain, mfn, mfn_end) ||\n             !iomem_access_permitted(d, mfn, mfn_end) )\n            break;\n\n        ret = xsm_iomem_mapping(XSM_HOOK, d, mfn, mfn_end, add);\n        if ( ret )\n            break;\n\n        if ( add )\n        {\n            printk(XENLOG_G_DEBUG\n                   \"memory_map:add: dom%d gfn=%lx mfn=%lx nr=%lx\\n\",\n                   d->domain_id, gfn, mfn, nr_mfns);\n\n            ret = map_mmio_regions(d, _gfn(gfn), nr_mfns, _mfn(mfn));\n            if ( ret < 0 )\n                printk(XENLOG_G_WARNING\n                       \"memory_map:fail: dom%d gfn=%lx mfn=%lx nr=%lx ret:%ld\\n\",\n                       d->domain_id, gfn, mfn, nr_mfns, ret);\n        }\n        else\n        {\n            printk(XENLOG_G_DEBUG\n                   \"memory_map:remove: dom%d gfn=%lx mfn=%lx nr=%lx\\n\",\n                   d->domain_id, gfn, mfn, nr_mfns);\n\n            ret = unmap_mmio_regions(d, _gfn(gfn), nr_mfns, _mfn(mfn));\n            if ( ret < 0 && is_hardware_domain(current->domain) )\n                printk(XENLOG_ERR\n                       \"memory_map: error %ld removing dom%d access to [%lx,%lx]\\n\",\n                       ret, d->domain_id, mfn, mfn_end);\n        }\n        /* Do this unconditionally to cover errors on above failure paths. */\n        memory_type_changed(d);\n        break;\n    }\n\n    case XEN_DOMCTL_settimeoffset:\n        domain_set_time_offset(d, op->u.settimeoffset.time_offset_seconds);\n        break;\n\n    case XEN_DOMCTL_set_target:\n    {\n        struct domain *e;\n\n        ret = -ESRCH;\n        e = get_domain_by_id(op->u.set_target.target);\n        if ( e == NULL )\n            break;\n\n        ret = -EINVAL;\n        if ( (d == e) || (d->target != NULL) )\n        {\n            put_domain(e);\n            break;\n        }\n\n        ret = -EOPNOTSUPP;\n        if ( is_hvm_domain(e) )\n            ret = xsm_set_target(XSM_HOOK, d, e);\n        if ( ret )\n        {\n            put_domain(e);\n            break;\n        }\n\n        /* Hold reference on @e until we destroy @d. */\n        d->target = e;\n        break;\n    }\n\n    case XEN_DOMCTL_subscribe:\n        d->suspend_evtchn = op->u.subscribe.port;\n        break;\n\n    case XEN_DOMCTL_vm_event_op:\n        ret = vm_event_domctl(d, &op->u.vm_event_op);\n        if ( ret == 0 )\n            copyback = true;\n        break;\n\n#ifdef CONFIG_MEM_ACCESS\n    case XEN_DOMCTL_set_access_required:\n        if ( unlikely(current->domain == d) ) /* no domain_pause() */\n            ret = -EPERM;\n        else\n        {\n            domain_pause(d);\n            arch_p2m_set_access_required(d,\n                op->u.access_required.access_required);\n            domain_unpause(d);\n        }\n        break;\n#endif\n\n    case XEN_DOMCTL_set_virq_handler:\n        ret = set_global_virq_handler(d, op->u.set_virq_handler.virq);\n        break;\n\n    case XEN_DOMCTL_setvnumainfo:\n    {\n        struct vnuma_info *vnuma;\n\n        vnuma = vnuma_init(&op->u.vnuma, d);\n        if ( IS_ERR(vnuma) )\n        {\n            ret = PTR_ERR(vnuma);\n            break;\n        }\n\n        /* overwrite vnuma topology for domain. */\n        write_lock(&d->vnuma_rwlock);\n        vnuma_destroy(d->vnuma);\n        d->vnuma = vnuma;\n        write_unlock(&d->vnuma_rwlock);\n\n        break;\n    }\n\n    case XEN_DOMCTL_monitor_op:\n        ret = monitor_domctl(d, &op->u.monitor_op);\n        if ( !ret )\n            copyback = 1;\n        break;\n\n    default:\n        ret = arch_do_domctl(op, d, u_domctl);\n        break;\n    }\n\n    domctl_lock_release();\n\n domctl_out_unlock_domonly:\n    if ( d )\n        rcu_unlock_domain(d);\n\n    if ( copyback && __copy_to_guest(u_domctl, op, 1) )\n        ret = -EFAULT;\n\n    return ret;\n}",
        "func": "long do_domctl(XEN_GUEST_HANDLE_PARAM(xen_domctl_t) u_domctl)\n{\n    long ret = 0;\n    bool_t copyback = 0;\n    struct xen_domctl curop, *op = &curop;\n    struct domain *d;\n\n    if ( copy_from_guest(op, u_domctl, 1) )\n        return -EFAULT;\n\n    if ( op->interface_version != XEN_DOMCTL_INTERFACE_VERSION )\n        return -EACCES;\n\n    switch ( op->cmd )\n    {\n    case XEN_DOMCTL_assign_device:\n    case XEN_DOMCTL_deassign_device:\n        if ( op->domain == DOMID_IO )\n        {\n            d = dom_io;\n            break;\n        }\n        else if ( op->domain == DOMID_INVALID )\n            return -ESRCH;\n        /* fall through */\n    case XEN_DOMCTL_test_assign_device:\n    case XEN_DOMCTL_vm_event_op:\n        if ( op->domain == DOMID_INVALID )\n        {\n    case XEN_DOMCTL_createdomain:\n    case XEN_DOMCTL_gdbsx_guestmemio:\n            d = NULL;\n            break;\n        }\n        /* fall through */\n    default:\n        d = rcu_lock_domain_by_id(op->domain);\n        if ( !d && op->cmd != XEN_DOMCTL_getdomaininfo )\n            return -ESRCH;\n    }\n\n    ret = xsm_domctl(XSM_OTHER, d, op->cmd);\n    if ( ret )\n        goto domctl_out_unlock_domonly;\n\n    if ( !domctl_lock_acquire() )\n    {\n        if ( d && d != dom_io )\n            rcu_unlock_domain(d);\n        return hypercall_create_continuation(\n            __HYPERVISOR_domctl, \"h\", u_domctl);\n    }\n\n    switch ( op->cmd )\n    {\n\n    case XEN_DOMCTL_setvcpucontext:\n    {\n        vcpu_guest_context_u c = { .nat = NULL };\n        unsigned int vcpu = op->u.vcpucontext.vcpu;\n        struct vcpu *v;\n\n        ret = -EINVAL;\n        if ( (d == current->domain) || /* no domain_pause() */\n             (vcpu >= d->max_vcpus) || ((v = d->vcpu[vcpu]) == NULL) )\n            break;\n\n        if ( guest_handle_is_null(op->u.vcpucontext.ctxt) )\n        {\n            ret = vcpu_reset(v);\n            if ( ret == -ERESTART )\n                ret = hypercall_create_continuation(\n                          __HYPERVISOR_domctl, \"h\", u_domctl);\n            break;\n        }\n\n#ifdef CONFIG_COMPAT\n        BUILD_BUG_ON(sizeof(struct vcpu_guest_context)\n                     < sizeof(struct compat_vcpu_guest_context));\n#endif\n        ret = -ENOMEM;\n        if ( (c.nat = alloc_vcpu_guest_context()) == NULL )\n            break;\n\n#ifdef CONFIG_COMPAT\n        if ( !is_pv_32bit_domain(d) )\n            ret = copy_from_guest(c.nat, op->u.vcpucontext.ctxt, 1);\n        else\n            ret = copy_from_guest(c.cmp,\n                                  guest_handle_cast(op->u.vcpucontext.ctxt,\n                                                    void), 1);\n#else\n        ret = copy_from_guest(c.nat, op->u.vcpucontext.ctxt, 1);\n#endif\n        ret = ret ? -EFAULT : 0;\n\n        if ( ret == 0 )\n        {\n            domain_pause(d);\n            ret = arch_set_info_guest(v, c);\n            domain_unpause(d);\n\n            if ( ret == -ERESTART )\n                ret = hypercall_create_continuation(\n                          __HYPERVISOR_domctl, \"h\", u_domctl);\n        }\n\n        free_vcpu_guest_context(c.nat);\n        break;\n    }\n\n    case XEN_DOMCTL_pausedomain:\n        ret = -EINVAL;\n        if ( d != current->domain )\n            ret = domain_pause_by_systemcontroller(d);\n        break;\n\n    case XEN_DOMCTL_unpausedomain:\n        ret = domain_unpause_by_systemcontroller(d);\n        break;\n\n    case XEN_DOMCTL_resumedomain:\n        if ( d == current->domain ) /* no domain_pause() */\n            ret = -EINVAL;\n        else\n            domain_resume(d);\n        break;\n\n    case XEN_DOMCTL_createdomain:\n    {\n        domid_t        dom;\n        static domid_t rover = 0;\n\n        dom = op->domain;\n        if ( (dom > 0) && (dom < DOMID_FIRST_RESERVED) )\n        {\n            ret = -EINVAL;\n            if ( !is_free_domid(dom) )\n                break;\n        }\n        else\n        {\n            for ( dom = rover + 1; dom != rover; dom++ )\n            {\n                if ( dom == DOMID_FIRST_RESERVED )\n                    dom = 1;\n                if ( is_free_domid(dom) )\n                    break;\n            }\n\n            ret = -ENOMEM;\n            if ( dom == rover )\n                break;\n\n            rover = dom;\n        }\n\n        d = domain_create(dom, &op->u.createdomain, false);\n        if ( IS_ERR(d) )\n        {\n            ret = PTR_ERR(d);\n            d = NULL;\n            break;\n        }\n\n        ret = 0;\n        op->domain = d->domain_id;\n        copyback = 1;\n        d = NULL;\n        break;\n    }\n\n    case XEN_DOMCTL_max_vcpus:\n    {\n        unsigned int i, max = op->u.max_vcpus.max;\n\n        ret = -EINVAL;\n        if ( (d == current->domain) || /* no domain_pause() */\n             (max != d->max_vcpus) )   /* max_vcpus set up in createdomain */\n            break;\n\n        /* Needed, for example, to ensure writable p.t. state is synced. */\n        domain_pause(d);\n\n        ret = -ENOMEM;\n\n        for ( i = 0; i < max; i++ )\n        {\n            if ( d->vcpu[i] != NULL )\n                continue;\n\n            if ( vcpu_create(d, i) == NULL )\n                goto maxvcpu_out;\n        }\n\n        domain_update_node_affinity(d);\n        ret = 0;\n\n    maxvcpu_out:\n        domain_unpause(d);\n        break;\n    }\n\n    case XEN_DOMCTL_soft_reset:\n        if ( d == current->domain ) /* no domain_pause() */\n        {\n            ret = -EINVAL;\n            break;\n        }\n        ret = domain_soft_reset(d);\n        break;\n\n    case XEN_DOMCTL_destroydomain:\n        domctl_lock_release();\n        domain_lock(d);\n        ret = domain_kill(d);\n        domain_unlock(d);\n        if ( ret == -ERESTART )\n            ret = hypercall_create_continuation(\n                __HYPERVISOR_domctl, \"h\", u_domctl);\n        goto domctl_out_unlock_domonly;\n\n    case XEN_DOMCTL_setnodeaffinity:\n    {\n        nodemask_t new_affinity;\n\n        ret = xenctl_bitmap_to_nodemask(&new_affinity,\n                                        &op->u.nodeaffinity.nodemap);\n        if ( !ret )\n            ret = domain_set_node_affinity(d, &new_affinity);\n        break;\n    }\n\n    case XEN_DOMCTL_getnodeaffinity:\n        ret = nodemask_to_xenctl_bitmap(&op->u.nodeaffinity.nodemap,\n                                        &d->node_affinity);\n        break;\n\n    case XEN_DOMCTL_setvcpuaffinity:\n    case XEN_DOMCTL_getvcpuaffinity:\n    {\n        struct vcpu *v;\n        const struct sched_unit *unit;\n        struct xen_domctl_vcpuaffinity *vcpuaff = &op->u.vcpuaffinity;\n\n        ret = -EINVAL;\n        if ( vcpuaff->vcpu >= d->max_vcpus )\n            break;\n\n        ret = -ESRCH;\n        if ( (v = d->vcpu[vcpuaff->vcpu]) == NULL )\n            break;\n\n        unit = v->sched_unit;\n        ret = -EINVAL;\n        if ( vcpuaffinity_params_invalid(vcpuaff) )\n            break;\n\n        if ( op->cmd == XEN_DOMCTL_setvcpuaffinity )\n        {\n            cpumask_var_t new_affinity, old_affinity;\n            cpumask_t *online = cpupool_domain_master_cpumask(v->domain);\n\n            /*\n             * We want to be able to restore hard affinity if we are trying\n             * setting both and changing soft affinity (which happens later,\n             * when hard affinity has been succesfully chaged already) fails.\n             */\n            if ( !alloc_cpumask_var(&old_affinity) )\n            {\n                ret = -ENOMEM;\n                break;\n            }\n            cpumask_copy(old_affinity, unit->cpu_hard_affinity);\n\n            if ( !alloc_cpumask_var(&new_affinity) )\n            {\n                free_cpumask_var(old_affinity);\n                ret = -ENOMEM;\n                break;\n            }\n\n            /* Undo a stuck SCHED_pin_override? */\n            if ( vcpuaff->flags & XEN_VCPUAFFINITY_FORCE )\n                vcpu_temporary_affinity(v, NR_CPUS, VCPU_AFFINITY_OVERRIDE);\n\n            ret = 0;\n\n            /*\n             * We both set a new affinity and report back to the caller what\n             * the scheduler will be effectively using.\n             */\n            if ( vcpuaff->flags & XEN_VCPUAFFINITY_HARD )\n            {\n                ret = xenctl_bitmap_to_bitmap(cpumask_bits(new_affinity),\n                                              &vcpuaff->cpumap_hard,\n                                              nr_cpu_ids);\n                if ( !ret )\n                    ret = vcpu_set_hard_affinity(v, new_affinity);\n                if ( ret )\n                    goto setvcpuaffinity_out;\n\n                /*\n                 * For hard affinity, what we return is the intersection of\n                 * cpupool's online mask and the new hard affinity.\n                 */\n                cpumask_and(new_affinity, online, unit->cpu_hard_affinity);\n                ret = cpumask_to_xenctl_bitmap(&vcpuaff->cpumap_hard,\n                                               new_affinity);\n            }\n            if ( vcpuaff->flags & XEN_VCPUAFFINITY_SOFT )\n            {\n                ret = xenctl_bitmap_to_bitmap(cpumask_bits(new_affinity),\n                                              &vcpuaff->cpumap_soft,\n                                              nr_cpu_ids);\n                if ( !ret)\n                    ret = vcpu_set_soft_affinity(v, new_affinity);\n                if ( ret )\n                {\n                    /*\n                     * Since we're returning error, the caller expects nothing\n                     * happened, so we rollback the changes to hard affinity\n                     * (if any).\n                     */\n                    if ( vcpuaff->flags & XEN_VCPUAFFINITY_HARD )\n                        vcpu_set_hard_affinity(v, old_affinity);\n                    goto setvcpuaffinity_out;\n                }\n\n                /*\n                 * For soft affinity, we return the intersection between the\n                 * new soft affinity, the cpupool's online map and the (new)\n                 * hard affinity.\n                 */\n                cpumask_and(new_affinity, new_affinity, online);\n                cpumask_and(new_affinity, new_affinity,\n                            unit->cpu_hard_affinity);\n                ret = cpumask_to_xenctl_bitmap(&vcpuaff->cpumap_soft,\n                                               new_affinity);\n            }\n\n setvcpuaffinity_out:\n            free_cpumask_var(new_affinity);\n            free_cpumask_var(old_affinity);\n        }\n        else\n        {\n            if ( vcpuaff->flags & XEN_VCPUAFFINITY_HARD )\n                ret = cpumask_to_xenctl_bitmap(&vcpuaff->cpumap_hard,\n                                               unit->cpu_hard_affinity);\n            if ( vcpuaff->flags & XEN_VCPUAFFINITY_SOFT )\n                ret = cpumask_to_xenctl_bitmap(&vcpuaff->cpumap_soft,\n                                               unit->cpu_soft_affinity);\n        }\n        break;\n    }\n\n    case XEN_DOMCTL_scheduler_op:\n        ret = sched_adjust(d, &op->u.scheduler_op);\n        copyback = 1;\n        break;\n\n    case XEN_DOMCTL_getdomaininfo:\n    {\n        domid_t dom = DOMID_INVALID;\n\n        if ( !d )\n        {\n            ret = -EINVAL;\n            if ( op->domain >= DOMID_FIRST_RESERVED )\n                break;\n\n            rcu_read_lock(&domlist_read_lock);\n\n            dom = op->domain;\n            for_each_domain ( d )\n                if ( d->domain_id >= dom )\n                    break;\n        }\n\n        ret = -ESRCH;\n        if ( d == NULL )\n            goto getdomaininfo_out;\n\n        ret = xsm_getdomaininfo(XSM_HOOK, d);\n        if ( ret )\n            goto getdomaininfo_out;\n\n        getdomaininfo(d, &op->u.getdomaininfo);\n\n        op->domain = op->u.getdomaininfo.domain;\n        copyback = 1;\n\n    getdomaininfo_out:\n        /* When d was non-NULL upon entry, no cleanup is needed. */\n        if ( dom == DOMID_INVALID )\n            break;\n\n        rcu_read_unlock(&domlist_read_lock);\n        d = NULL;\n        break;\n    }\n\n    case XEN_DOMCTL_getvcpucontext:\n    {\n        vcpu_guest_context_u c = { .nat = NULL };\n        struct vcpu         *v;\n\n        ret = -EINVAL;\n        if ( op->u.vcpucontext.vcpu >= d->max_vcpus ||\n             (v = d->vcpu[op->u.vcpucontext.vcpu]) == NULL ||\n             v == current ) /* no vcpu_pause() */\n            goto getvcpucontext_out;\n\n        ret = -ENODATA;\n        if ( !v->is_initialised )\n            goto getvcpucontext_out;\n\n#ifdef CONFIG_COMPAT\n        BUILD_BUG_ON(sizeof(struct vcpu_guest_context)\n                     < sizeof(struct compat_vcpu_guest_context));\n#endif\n        ret = -ENOMEM;\n        if ( (c.nat = xzalloc(struct vcpu_guest_context)) == NULL )\n            goto getvcpucontext_out;\n\n        vcpu_pause(v);\n\n        arch_get_info_guest(v, c);\n        ret = 0;\n\n        vcpu_unpause(v);\n\n#ifdef CONFIG_COMPAT\n        if ( !is_pv_32bit_domain(d) )\n            ret = copy_to_guest(op->u.vcpucontext.ctxt, c.nat, 1);\n        else\n            ret = copy_to_guest(guest_handle_cast(op->u.vcpucontext.ctxt,\n                                                  void), c.cmp, 1);\n#else\n        ret = copy_to_guest(op->u.vcpucontext.ctxt, c.nat, 1);\n#endif\n\n        if ( ret )\n            ret = -EFAULT;\n        copyback = 1;\n\n    getvcpucontext_out:\n        xfree(c.nat);\n        break;\n    }\n\n    case XEN_DOMCTL_getvcpuinfo:\n    {\n        struct vcpu   *v;\n        struct vcpu_runstate_info runstate;\n\n        ret = -EINVAL;\n        if ( op->u.getvcpuinfo.vcpu >= d->max_vcpus )\n            break;\n\n        ret = -ESRCH;\n        if ( (v = d->vcpu[op->u.getvcpuinfo.vcpu]) == NULL )\n            break;\n\n        vcpu_runstate_get(v, &runstate);\n\n        op->u.getvcpuinfo.online   = !(v->pause_flags & VPF_down);\n        op->u.getvcpuinfo.blocked  = !!(v->pause_flags & VPF_blocked);\n        op->u.getvcpuinfo.running  = v->is_running;\n        op->u.getvcpuinfo.cpu_time = runstate.time[RUNSTATE_running];\n        op->u.getvcpuinfo.cpu      = v->processor;\n        ret = 0;\n        copyback = 1;\n        break;\n    }\n\n    case XEN_DOMCTL_max_mem:\n    {\n        uint64_t new_max = op->u.max_mem.max_memkb >> (PAGE_SHIFT - 10);\n\n        spin_lock(&d->page_alloc_lock);\n        /*\n         * NB. We removed a check that new_max >= current tot_pages; this means\n         * that the domain will now be allowed to \"ratchet\" down to new_max. In\n         * the meantime, while tot > max, all new allocations are disallowed.\n         */\n        d->max_pages = min(new_max, (uint64_t)(typeof(d->max_pages))-1);\n        spin_unlock(&d->page_alloc_lock);\n        break;\n    }\n\n    case XEN_DOMCTL_setdomainhandle:\n        memcpy(d->handle, op->u.setdomainhandle.handle,\n               sizeof(xen_domain_handle_t));\n        break;\n\n    case XEN_DOMCTL_setdebugging:\n        if ( unlikely(d == current->domain) ) /* no domain_pause() */\n            ret = -EINVAL;\n        else\n        {\n            domain_pause(d);\n            d->debugger_attached = !!op->u.setdebugging.enable;\n            domain_unpause(d); /* causes guest to latch new status */\n        }\n        break;\n\n    case XEN_DOMCTL_irq_permission:\n    {\n        unsigned int pirq = op->u.irq_permission.pirq, irq;\n        int allow = op->u.irq_permission.allow_access;\n\n        if ( pirq >= current->domain->nr_pirqs )\n        {\n            ret = -EINVAL;\n            break;\n        }\n        irq = pirq_access_permitted(current->domain, pirq);\n        if ( !irq || xsm_irq_permission(XSM_HOOK, d, irq, allow) )\n            ret = -EPERM;\n        else if ( allow )\n            ret = irq_permit_access(d, irq);\n        else\n            ret = irq_deny_access(d, irq);\n        break;\n    }\n\n    case XEN_DOMCTL_iomem_permission:\n    {\n        unsigned long mfn = op->u.iomem_permission.first_mfn;\n        unsigned long nr_mfns = op->u.iomem_permission.nr_mfns;\n        int allow = op->u.iomem_permission.allow_access;\n\n        ret = -EINVAL;\n        if ( (mfn + nr_mfns - 1) < mfn ) /* wrap? */\n            break;\n\n        if ( !iomem_access_permitted(current->domain,\n                                     mfn, mfn + nr_mfns - 1) ||\n             xsm_iomem_permission(XSM_HOOK, d, mfn, mfn + nr_mfns - 1, allow) )\n            ret = -EPERM;\n        else if ( allow )\n            ret = iomem_permit_access(d, mfn, mfn + nr_mfns - 1);\n        else\n            ret = iomem_deny_access(d, mfn, mfn + nr_mfns - 1);\n        if ( !ret )\n            memory_type_changed(d);\n        break;\n    }\n\n    case XEN_DOMCTL_memory_mapping:\n    {\n        unsigned long gfn = op->u.memory_mapping.first_gfn;\n        unsigned long mfn = op->u.memory_mapping.first_mfn;\n        unsigned long nr_mfns = op->u.memory_mapping.nr_mfns;\n        unsigned long mfn_end = mfn + nr_mfns - 1;\n        int add = op->u.memory_mapping.add_mapping;\n\n        ret = -EINVAL;\n        if ( mfn_end < mfn || /* wrap? */\n             ((mfn | mfn_end) >> (paddr_bits - PAGE_SHIFT)) ||\n             (gfn + nr_mfns - 1) < gfn ) /* wrap? */\n            break;\n\n#ifndef CONFIG_X86 /* XXX ARM!? */\n        ret = -E2BIG;\n        /* Must break hypercall up as this could take a while. */\n        if ( nr_mfns > 64 )\n            break;\n#endif\n\n        ret = -EPERM;\n        if ( !iomem_access_permitted(current->domain, mfn, mfn_end) ||\n             !iomem_access_permitted(d, mfn, mfn_end) )\n            break;\n\n        ret = xsm_iomem_mapping(XSM_HOOK, d, mfn, mfn_end, add);\n        if ( ret )\n            break;\n\n        if ( add )\n        {\n            printk(XENLOG_G_DEBUG\n                   \"memory_map:add: dom%d gfn=%lx mfn=%lx nr=%lx\\n\",\n                   d->domain_id, gfn, mfn, nr_mfns);\n\n            ret = map_mmio_regions(d, _gfn(gfn), nr_mfns, _mfn(mfn));\n            if ( ret < 0 )\n                printk(XENLOG_G_WARNING\n                       \"memory_map:fail: dom%d gfn=%lx mfn=%lx nr=%lx ret:%ld\\n\",\n                       d->domain_id, gfn, mfn, nr_mfns, ret);\n        }\n        else\n        {\n            printk(XENLOG_G_DEBUG\n                   \"memory_map:remove: dom%d gfn=%lx mfn=%lx nr=%lx\\n\",\n                   d->domain_id, gfn, mfn, nr_mfns);\n\n            ret = unmap_mmio_regions(d, _gfn(gfn), nr_mfns, _mfn(mfn));\n            if ( ret < 0 && is_hardware_domain(current->domain) )\n                printk(XENLOG_ERR\n                       \"memory_map: error %ld removing dom%d access to [%lx,%lx]\\n\",\n                       ret, d->domain_id, mfn, mfn_end);\n        }\n        /* Do this unconditionally to cover errors on above failure paths. */\n        memory_type_changed(d);\n        break;\n    }\n\n    case XEN_DOMCTL_settimeoffset:\n        domain_set_time_offset(d, op->u.settimeoffset.time_offset_seconds);\n        break;\n\n    case XEN_DOMCTL_set_target:\n    {\n        struct domain *e;\n\n        ret = -ESRCH;\n        e = get_domain_by_id(op->u.set_target.target);\n        if ( e == NULL )\n            break;\n\n        ret = -EINVAL;\n        if ( (d == e) || (d->target != NULL) )\n        {\n            put_domain(e);\n            break;\n        }\n\n        ret = -EOPNOTSUPP;\n        if ( is_hvm_domain(e) )\n            ret = xsm_set_target(XSM_HOOK, d, e);\n        if ( ret )\n        {\n            put_domain(e);\n            break;\n        }\n\n        /* Hold reference on @e until we destroy @d. */\n        d->target = e;\n        break;\n    }\n\n    case XEN_DOMCTL_subscribe:\n        d->suspend_evtchn = op->u.subscribe.port;\n        break;\n\n    case XEN_DOMCTL_vm_event_op:\n        ret = vm_event_domctl(d, &op->u.vm_event_op);\n        if ( ret == 0 )\n            copyback = true;\n        break;\n\n#ifdef CONFIG_MEM_ACCESS\n    case XEN_DOMCTL_set_access_required:\n        if ( unlikely(current->domain == d) ) /* no domain_pause() */\n            ret = -EPERM;\n        else\n        {\n            domain_pause(d);\n            arch_p2m_set_access_required(d,\n                op->u.access_required.access_required);\n            domain_unpause(d);\n        }\n        break;\n#endif\n\n    case XEN_DOMCTL_set_virq_handler:\n        ret = set_global_virq_handler(d, op->u.set_virq_handler.virq);\n        break;\n\n    case XEN_DOMCTL_setvnumainfo:\n    {\n        struct vnuma_info *vnuma;\n\n        vnuma = vnuma_init(&op->u.vnuma, d);\n        if ( IS_ERR(vnuma) )\n        {\n            ret = PTR_ERR(vnuma);\n            break;\n        }\n\n        /* overwrite vnuma topology for domain. */\n        write_lock(&d->vnuma_rwlock);\n        vnuma_destroy(d->vnuma);\n        d->vnuma = vnuma;\n        write_unlock(&d->vnuma_rwlock);\n\n        break;\n    }\n\n    case XEN_DOMCTL_monitor_op:\n        ret = monitor_domctl(d, &op->u.monitor_op);\n        if ( !ret )\n            copyback = 1;\n        break;\n\n    default:\n        ret = arch_do_domctl(op, d, u_domctl);\n        break;\n    }\n\n    domctl_lock_release();\n\n domctl_out_unlock_domonly:\n    if ( d && d != dom_io )\n        rcu_unlock_domain(d);\n\n    if ( copyback && __copy_to_guest(u_domctl, op, 1) )\n        ret = -EFAULT;\n\n    return ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -13,6 +13,16 @@\n \n     switch ( op->cmd )\n     {\n+    case XEN_DOMCTL_assign_device:\n+    case XEN_DOMCTL_deassign_device:\n+        if ( op->domain == DOMID_IO )\n+        {\n+            d = dom_io;\n+            break;\n+        }\n+        else if ( op->domain == DOMID_INVALID )\n+            return -ESRCH;\n+        /* fall through */\n     case XEN_DOMCTL_test_assign_device:\n     case XEN_DOMCTL_vm_event_op:\n         if ( op->domain == DOMID_INVALID )\n@@ -35,7 +45,7 @@\n \n     if ( !domctl_lock_acquire() )\n     {\n-        if ( d )\n+        if ( d && d != dom_io )\n             rcu_unlock_domain(d);\n         return hypercall_create_continuation(\n             __HYPERVISOR_domctl, \"h\", u_domctl);\n@@ -694,7 +704,7 @@\n     domctl_lock_release();\n \n  domctl_out_unlock_domonly:\n-    if ( d )\n+    if ( d && d != dom_io )\n         rcu_unlock_domain(d);\n \n     if ( copyback && __copy_to_guest(u_domctl, op, 1) )",
        "diff_line_info": {
            "deleted_lines": [
                "        if ( d )",
                "    if ( d )"
            ],
            "added_lines": [
                "    case XEN_DOMCTL_assign_device:",
                "    case XEN_DOMCTL_deassign_device:",
                "        if ( op->domain == DOMID_IO )",
                "        {",
                "            d = dom_io;",
                "            break;",
                "        }",
                "        else if ( op->domain == DOMID_INVALID )",
                "            return -ESRCH;",
                "        /* fall through */",
                "        if ( d && d != dom_io )",
                "    if ( d && d != dom_io )"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-18424",
        "func_name": "xen-project/xen/deassign_device",
        "description": "An issue was discovered in Xen through 4.12.x allowing attackers to gain host OS privileges via DMA in a situation where an untrusted domain has access to a physical device. This occurs because passed through PCI devices may corrupt host memory after deassignment. When a PCI device is assigned to an untrusted domain, it is possible for that domain to program the device to DMA to an arbitrary address. The IOMMU is used to protect the host from malicious DMA by making sure that the device addresses can only target memory assigned to the guest. However, when the guest domain is torn down, or the device is deassigned, the device is assigned back to dom0, thus allowing any in-flight DMA to potentially target critical host data. An untrusted domain with access to a physical device can DMA into host memory, leading to privilege escalation. Only systems where guests are given direct access to physical devices capable of DMA (PCI pass-through) are vulnerable. Systems which do not use PCI pass-through are not vulnerable.",
        "git_url": "https://github.com/xen-project/xen/commit/319f9a0ba94c7db505cd5dd9cb0b037ab1aa8e12",
        "commit_title": "passthrough: quarantine PCI devices",
        "commit_text": " When a PCI device is assigned to an untrusted domain, it is possible for that domain to program the device to DMA to an arbitrary address. The IOMMU is used to protect the host from malicious DMA by making sure that the device addresses can only target memory assigned to the guest. However, when the guest domain is torn down the device is assigned back to dom0, thus allowing any in-flight DMA to potentially target critical host data.  This patch introduces a 'quarantine' for PCI devices using dom_io. When the toolstack makes a device assignable (by binding it to pciback), it will now also assign it to DOMID_IO and the device will only be assigned back to dom0 when the device is made unassignable again. Whilst device is assignable it will only ever transfer between dom_io and guest domains. dom_io is actually only used as a sentinel domain for quarantining purposes; it is not configured with any IOMMU mappings. Assignment to dom_io simply means that the device's initiator (requestor) identifier is not present in the IOMMU's device table and thus any DMA transactions issued will be terminated with a fault condition.  In addition, a fix to assignment handling is made for VT-d.  Failure during the assignment step should not lead to a device still being associated with its prior owner. Hand the device to DomIO temporarily, until the assignment step has completed successfully.  Remove the PI hooks from the source domain then earlier as well.  Failure of the recovery reassign_device_ownership() may not go silent: There e.g. may still be left over RMRR mappings in the domain assignment to which has failed, and hence we can't allow that domain to continue executing.  NOTE: This patch also includes one printk() cleanup; the       \"XEN_DOMCTL_assign_device: \" tag is dropped in iommu_do_pci_domctl(),       since similar printk()-s elsewhere also don't log such a tag.  This is XSA-302. ",
        "func_before": "static int deassign_device(struct domain *d, uint16_t seg, uint8_t bus,\n                           uint8_t devfn)\n{\n    const struct domain_iommu *hd = dom_iommu(d);\n    struct pci_dev *pdev;\n    int ret = 0;\n\n    if ( !is_iommu_enabled(d) )\n        return -EINVAL;\n\n    ASSERT(pcidevs_locked());\n    pdev = pci_get_pdev_by_domain(d, seg, bus, devfn);\n    if ( !pdev )\n        return -ENODEV;\n\n    while ( pdev->phantom_stride )\n    {\n        devfn += pdev->phantom_stride;\n        if ( PCI_SLOT(devfn) != PCI_SLOT(pdev->devfn) )\n            break;\n        ret = hd->platform_ops->reassign_device(d, hardware_domain, devfn,\n                                                pci_to_dev(pdev));\n        if ( !ret )\n            continue;\n\n        printk(XENLOG_G_ERR \"%pd: deassign %04x:%02x:%02x.%u failed (%d)\\n\",\n               d, seg, bus, PCI_SLOT(devfn), PCI_FUNC(devfn), ret);\n        return ret;\n    }\n\n    devfn = pdev->devfn;\n    ret = hd->platform_ops->reassign_device(d, hardware_domain, devfn,\n                                            pci_to_dev(pdev));\n    if ( ret )\n    {\n        dprintk(XENLOG_G_ERR,\n                \"%pd: deassign device (%04x:%02x:%02x.%u) failed\\n\",\n                d, seg, bus, PCI_SLOT(devfn), PCI_FUNC(devfn));\n        return ret;\n    }\n\n    pdev->fault.count = 0;\n\n    return ret;\n}",
        "func": "static int deassign_device(struct domain *d, uint16_t seg, uint8_t bus,\n                           uint8_t devfn)\n{\n    const struct domain_iommu *hd = dom_iommu(d);\n    struct pci_dev *pdev;\n    struct domain *target;\n    int ret = 0;\n\n    if ( !is_iommu_enabled(d) )\n        return -EINVAL;\n\n    ASSERT(pcidevs_locked());\n    pdev = pci_get_pdev_by_domain(d, seg, bus, devfn);\n    if ( !pdev )\n        return -ENODEV;\n\n    /* De-assignment from dom_io should de-quarantine the device */\n    target = (pdev->quarantine && pdev->domain != dom_io) ?\n        dom_io : hardware_domain;\n\n    while ( pdev->phantom_stride )\n    {\n        devfn += pdev->phantom_stride;\n        if ( PCI_SLOT(devfn) != PCI_SLOT(pdev->devfn) )\n            break;\n        ret = hd->platform_ops->reassign_device(d, target, devfn,\n                                                pci_to_dev(pdev));\n        if ( !ret )\n            continue;\n\n        printk(XENLOG_G_ERR \"%pd: deassign %04x:%02x:%02x.%u failed (%d)\\n\",\n               d, seg, bus, PCI_SLOT(devfn), PCI_FUNC(devfn), ret);\n        return ret;\n    }\n\n    devfn = pdev->devfn;\n    ret = hd->platform_ops->reassign_device(d, target, devfn,\n                                            pci_to_dev(pdev));\n    if ( ret )\n    {\n        dprintk(XENLOG_G_ERR,\n                \"%pd: deassign device (%04x:%02x:%02x.%u) failed\\n\",\n                d, seg, bus, PCI_SLOT(devfn), PCI_FUNC(devfn));\n        return ret;\n    }\n\n    if ( pdev->domain == hardware_domain  )\n        pdev->quarantine = false;\n\n    pdev->fault.count = 0;\n\n    return ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,6 +3,7 @@\n {\n     const struct domain_iommu *hd = dom_iommu(d);\n     struct pci_dev *pdev;\n+    struct domain *target;\n     int ret = 0;\n \n     if ( !is_iommu_enabled(d) )\n@@ -13,12 +14,16 @@\n     if ( !pdev )\n         return -ENODEV;\n \n+    /* De-assignment from dom_io should de-quarantine the device */\n+    target = (pdev->quarantine && pdev->domain != dom_io) ?\n+        dom_io : hardware_domain;\n+\n     while ( pdev->phantom_stride )\n     {\n         devfn += pdev->phantom_stride;\n         if ( PCI_SLOT(devfn) != PCI_SLOT(pdev->devfn) )\n             break;\n-        ret = hd->platform_ops->reassign_device(d, hardware_domain, devfn,\n+        ret = hd->platform_ops->reassign_device(d, target, devfn,\n                                                 pci_to_dev(pdev));\n         if ( !ret )\n             continue;\n@@ -29,7 +34,7 @@\n     }\n \n     devfn = pdev->devfn;\n-    ret = hd->platform_ops->reassign_device(d, hardware_domain, devfn,\n+    ret = hd->platform_ops->reassign_device(d, target, devfn,\n                                             pci_to_dev(pdev));\n     if ( ret )\n     {\n@@ -39,6 +44,9 @@\n         return ret;\n     }\n \n+    if ( pdev->domain == hardware_domain  )\n+        pdev->quarantine = false;\n+\n     pdev->fault.count = 0;\n \n     return ret;",
        "diff_line_info": {
            "deleted_lines": [
                "        ret = hd->platform_ops->reassign_device(d, hardware_domain, devfn,",
                "    ret = hd->platform_ops->reassign_device(d, hardware_domain, devfn,"
            ],
            "added_lines": [
                "    struct domain *target;",
                "    /* De-assignment from dom_io should de-quarantine the device */",
                "    target = (pdev->quarantine && pdev->domain != dom_io) ?",
                "        dom_io : hardware_domain;",
                "",
                "        ret = hd->platform_ops->reassign_device(d, target, devfn,",
                "    ret = hd->platform_ops->reassign_device(d, target, devfn,",
                "    if ( pdev->domain == hardware_domain  )",
                "        pdev->quarantine = false;",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2019-18424",
        "func_name": "xen-project/xen/assign_device",
        "description": "An issue was discovered in Xen through 4.12.x allowing attackers to gain host OS privileges via DMA in a situation where an untrusted domain has access to a physical device. This occurs because passed through PCI devices may corrupt host memory after deassignment. When a PCI device is assigned to an untrusted domain, it is possible for that domain to program the device to DMA to an arbitrary address. The IOMMU is used to protect the host from malicious DMA by making sure that the device addresses can only target memory assigned to the guest. However, when the guest domain is torn down, or the device is deassigned, the device is assigned back to dom0, thus allowing any in-flight DMA to potentially target critical host data. An untrusted domain with access to a physical device can DMA into host memory, leading to privilege escalation. Only systems where guests are given direct access to physical devices capable of DMA (PCI pass-through) are vulnerable. Systems which do not use PCI pass-through are not vulnerable.",
        "git_url": "https://github.com/xen-project/xen/commit/319f9a0ba94c7db505cd5dd9cb0b037ab1aa8e12",
        "commit_title": "passthrough: quarantine PCI devices",
        "commit_text": " When a PCI device is assigned to an untrusted domain, it is possible for that domain to program the device to DMA to an arbitrary address. The IOMMU is used to protect the host from malicious DMA by making sure that the device addresses can only target memory assigned to the guest. However, when the guest domain is torn down the device is assigned back to dom0, thus allowing any in-flight DMA to potentially target critical host data.  This patch introduces a 'quarantine' for PCI devices using dom_io. When the toolstack makes a device assignable (by binding it to pciback), it will now also assign it to DOMID_IO and the device will only be assigned back to dom0 when the device is made unassignable again. Whilst device is assignable it will only ever transfer between dom_io and guest domains. dom_io is actually only used as a sentinel domain for quarantining purposes; it is not configured with any IOMMU mappings. Assignment to dom_io simply means that the device's initiator (requestor) identifier is not present in the IOMMU's device table and thus any DMA transactions issued will be terminated with a fault condition.  In addition, a fix to assignment handling is made for VT-d.  Failure during the assignment step should not lead to a device still being associated with its prior owner. Hand the device to DomIO temporarily, until the assignment step has completed successfully.  Remove the PI hooks from the source domain then earlier as well.  Failure of the recovery reassign_device_ownership() may not go silent: There e.g. may still be left over RMRR mappings in the domain assignment to which has failed, and hence we can't allow that domain to continue executing.  NOTE: This patch also includes one printk() cleanup; the       \"XEN_DOMCTL_assign_device: \" tag is dropped in iommu_do_pci_domctl(),       since similar printk()-s elsewhere also don't log such a tag.  This is XSA-302. ",
        "func_before": "static int assign_device(struct domain *d, u16 seg, u8 bus, u8 devfn, u32 flag)\n{\n    const struct domain_iommu *hd = dom_iommu(d);\n    struct pci_dev *pdev;\n    int rc = 0;\n\n    if ( !is_iommu_enabled(d) )\n        return 0;\n\n    /* Prevent device assign if mem paging or mem sharing have been \n     * enabled for this domain */\n    if ( unlikely((is_hvm_domain(d) &&\n                   d->arch.hvm.mem_sharing_enabled) ||\n                  vm_event_check_ring(d->vm_event_paging) ||\n                  p2m_get_hostp2m(d)->global_logdirty) )\n        return -EXDEV;\n\n    if ( !pcidevs_trylock() )\n        return -ERESTART;\n\n    pdev = pci_get_pdev_by_domain(hardware_domain, seg, bus, devfn);\n    if ( !pdev )\n    {\n        rc = pci_get_pdev(seg, bus, devfn) ? -EBUSY : -ENODEV;\n        goto done;\n    }\n\n    if ( pdev->msix )\n    {\n        rc = pci_reset_msix_state(pdev);\n        if ( rc )\n            goto done;\n        msixtbl_init(d);\n    }\n\n    pdev->fault.count = 0;\n\n    if ( (rc = hd->platform_ops->assign_device(d, devfn, pci_to_dev(pdev), flag)) )\n        goto done;\n\n    for ( ; pdev->phantom_stride; rc = 0 )\n    {\n        devfn += pdev->phantom_stride;\n        if ( PCI_SLOT(devfn) != PCI_SLOT(pdev->devfn) )\n            break;\n        rc = hd->platform_ops->assign_device(d, devfn, pci_to_dev(pdev), flag);\n        if ( rc )\n            printk(XENLOG_G_WARNING \"d%d: assign %04x:%02x:%02x.%u failed (%d)\\n\",\n                   d->domain_id, seg, bus, PCI_SLOT(devfn), PCI_FUNC(devfn),\n                   rc);\n    }\n\n done:\n    pcidevs_unlock();\n\n    return rc;\n}",
        "func": "static int assign_device(struct domain *d, u16 seg, u8 bus, u8 devfn, u32 flag)\n{\n    const struct domain_iommu *hd = dom_iommu(d);\n    struct pci_dev *pdev;\n    int rc = 0;\n\n    if ( !is_iommu_enabled(d) )\n        return 0;\n\n    /* Prevent device assign if mem paging or mem sharing have been \n     * enabled for this domain */\n    if ( d != dom_io &&\n         unlikely((is_hvm_domain(d) &&\n                   d->arch.hvm.mem_sharing_enabled) ||\n                  vm_event_check_ring(d->vm_event_paging) ||\n                  p2m_get_hostp2m(d)->global_logdirty) )\n        return -EXDEV;\n\n    if ( !pcidevs_trylock() )\n        return -ERESTART;\n\n    pdev = pci_get_pdev(seg, bus, devfn);\n\n    rc = -ENODEV;\n    if ( !pdev )\n        goto done;\n\n    rc = 0;\n    if ( d == pdev->domain )\n        goto done;\n\n    rc = -EBUSY;\n    if ( pdev->domain != hardware_domain &&\n         pdev->domain != dom_io )\n        goto done;\n\n    if ( pdev->msix )\n    {\n        rc = pci_reset_msix_state(pdev);\n        if ( rc )\n            goto done;\n        msixtbl_init(d);\n    }\n\n    pdev->fault.count = 0;\n\n    if ( (rc = hd->platform_ops->assign_device(d, devfn, pci_to_dev(pdev), flag)) )\n        goto done;\n\n    for ( ; pdev->phantom_stride; rc = 0 )\n    {\n        devfn += pdev->phantom_stride;\n        if ( PCI_SLOT(devfn) != PCI_SLOT(pdev->devfn) )\n            break;\n        rc = hd->platform_ops->assign_device(d, devfn, pci_to_dev(pdev), flag);\n        if ( rc )\n            printk(XENLOG_G_WARNING \"d%d: assign %04x:%02x:%02x.%u failed (%d)\\n\",\n                   d->domain_id, seg, bus, PCI_SLOT(devfn), PCI_FUNC(devfn),\n                   rc);\n    }\n\n done:\n    /* The device is assigned to dom_io so mark it as quarantined */\n    if ( !rc && d == dom_io )\n        pdev->quarantine = true;\n\n    pcidevs_unlock();\n\n    return rc;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -9,7 +9,8 @@\n \n     /* Prevent device assign if mem paging or mem sharing have been \n      * enabled for this domain */\n-    if ( unlikely((is_hvm_domain(d) &&\n+    if ( d != dom_io &&\n+         unlikely((is_hvm_domain(d) &&\n                    d->arch.hvm.mem_sharing_enabled) ||\n                   vm_event_check_ring(d->vm_event_paging) ||\n                   p2m_get_hostp2m(d)->global_logdirty) )\n@@ -18,12 +19,20 @@\n     if ( !pcidevs_trylock() )\n         return -ERESTART;\n \n-    pdev = pci_get_pdev_by_domain(hardware_domain, seg, bus, devfn);\n+    pdev = pci_get_pdev(seg, bus, devfn);\n+\n+    rc = -ENODEV;\n     if ( !pdev )\n-    {\n-        rc = pci_get_pdev(seg, bus, devfn) ? -EBUSY : -ENODEV;\n         goto done;\n-    }\n+\n+    rc = 0;\n+    if ( d == pdev->domain )\n+        goto done;\n+\n+    rc = -EBUSY;\n+    if ( pdev->domain != hardware_domain &&\n+         pdev->domain != dom_io )\n+        goto done;\n \n     if ( pdev->msix )\n     {\n@@ -51,6 +60,10 @@\n     }\n \n  done:\n+    /* The device is assigned to dom_io so mark it as quarantined */\n+    if ( !rc && d == dom_io )\n+        pdev->quarantine = true;\n+\n     pcidevs_unlock();\n \n     return rc;",
        "diff_line_info": {
            "deleted_lines": [
                "    if ( unlikely((is_hvm_domain(d) &&",
                "    pdev = pci_get_pdev_by_domain(hardware_domain, seg, bus, devfn);",
                "    {",
                "        rc = pci_get_pdev(seg, bus, devfn) ? -EBUSY : -ENODEV;",
                "    }"
            ],
            "added_lines": [
                "    if ( d != dom_io &&",
                "         unlikely((is_hvm_domain(d) &&",
                "    pdev = pci_get_pdev(seg, bus, devfn);",
                "",
                "    rc = -ENODEV;",
                "",
                "    rc = 0;",
                "    if ( d == pdev->domain )",
                "        goto done;",
                "",
                "    rc = -EBUSY;",
                "    if ( pdev->domain != hardware_domain &&",
                "         pdev->domain != dom_io )",
                "        goto done;",
                "    /* The device is assigned to dom_io so mark it as quarantined */",
                "    if ( !rc && d == dom_io )",
                "        pdev->quarantine = true;",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2019-18424",
        "func_name": "xen-project/xen/device_assigned",
        "description": "An issue was discovered in Xen through 4.12.x allowing attackers to gain host OS privileges via DMA in a situation where an untrusted domain has access to a physical device. This occurs because passed through PCI devices may corrupt host memory after deassignment. When a PCI device is assigned to an untrusted domain, it is possible for that domain to program the device to DMA to an arbitrary address. The IOMMU is used to protect the host from malicious DMA by making sure that the device addresses can only target memory assigned to the guest. However, when the guest domain is torn down, or the device is deassigned, the device is assigned back to dom0, thus allowing any in-flight DMA to potentially target critical host data. An untrusted domain with access to a physical device can DMA into host memory, leading to privilege escalation. Only systems where guests are given direct access to physical devices capable of DMA (PCI pass-through) are vulnerable. Systems which do not use PCI pass-through are not vulnerable.",
        "git_url": "https://github.com/xen-project/xen/commit/319f9a0ba94c7db505cd5dd9cb0b037ab1aa8e12",
        "commit_title": "passthrough: quarantine PCI devices",
        "commit_text": " When a PCI device is assigned to an untrusted domain, it is possible for that domain to program the device to DMA to an arbitrary address. The IOMMU is used to protect the host from malicious DMA by making sure that the device addresses can only target memory assigned to the guest. However, when the guest domain is torn down the device is assigned back to dom0, thus allowing any in-flight DMA to potentially target critical host data.  This patch introduces a 'quarantine' for PCI devices using dom_io. When the toolstack makes a device assignable (by binding it to pciback), it will now also assign it to DOMID_IO and the device will only be assigned back to dom0 when the device is made unassignable again. Whilst device is assignable it will only ever transfer between dom_io and guest domains. dom_io is actually only used as a sentinel domain for quarantining purposes; it is not configured with any IOMMU mappings. Assignment to dom_io simply means that the device's initiator (requestor) identifier is not present in the IOMMU's device table and thus any DMA transactions issued will be terminated with a fault condition.  In addition, a fix to assignment handling is made for VT-d.  Failure during the assignment step should not lead to a device still being associated with its prior owner. Hand the device to DomIO temporarily, until the assignment step has completed successfully.  Remove the PI hooks from the source domain then earlier as well.  Failure of the recovery reassign_device_ownership() may not go silent: There e.g. may still be left over RMRR mappings in the domain assignment to which has failed, and hence we can't allow that domain to continue executing.  NOTE: This patch also includes one printk() cleanup; the       \"XEN_DOMCTL_assign_device: \" tag is dropped in iommu_do_pci_domctl(),       since similar printk()-s elsewhere also don't log such a tag.  This is XSA-302. ",
        "func_before": "static int device_assigned(u16 seg, u8 bus, u8 devfn)\n{\n    struct pci_dev *pdev;\n\n    pcidevs_lock();\n    pdev = pci_get_pdev_by_domain(hardware_domain, seg, bus, devfn);\n    pcidevs_unlock();\n\n    return pdev ? 0 : -EBUSY;\n}",
        "func": "static int device_assigned(u16 seg, u8 bus, u8 devfn)\n{\n    struct pci_dev *pdev;\n    int rc = 0;\n\n    pcidevs_lock();\n\n    pdev = pci_get_pdev(seg, bus, devfn);\n\n    if ( !pdev )\n        rc = -ENODEV;\n    /*\n     * If the device exists and it is not owned by either the hardware\n     * domain or dom_io then it must be assigned to a guest, or be\n     * hidden (owned by dom_xen).\n     */\n    else if ( pdev->domain != hardware_domain &&\n              pdev->domain != dom_io )\n        rc = -EBUSY;\n\n    pcidevs_unlock();\n\n    return rc;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,10 +1,24 @@\n static int device_assigned(u16 seg, u8 bus, u8 devfn)\n {\n     struct pci_dev *pdev;\n+    int rc = 0;\n \n     pcidevs_lock();\n-    pdev = pci_get_pdev_by_domain(hardware_domain, seg, bus, devfn);\n+\n+    pdev = pci_get_pdev(seg, bus, devfn);\n+\n+    if ( !pdev )\n+        rc = -ENODEV;\n+    /*\n+     * If the device exists and it is not owned by either the hardware\n+     * domain or dom_io then it must be assigned to a guest, or be\n+     * hidden (owned by dom_xen).\n+     */\n+    else if ( pdev->domain != hardware_domain &&\n+              pdev->domain != dom_io )\n+        rc = -EBUSY;\n+\n     pcidevs_unlock();\n \n-    return pdev ? 0 : -EBUSY;\n+    return rc;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    pdev = pci_get_pdev_by_domain(hardware_domain, seg, bus, devfn);",
                "    return pdev ? 0 : -EBUSY;"
            ],
            "added_lines": [
                "    int rc = 0;",
                "",
                "    pdev = pci_get_pdev(seg, bus, devfn);",
                "",
                "    if ( !pdev )",
                "        rc = -ENODEV;",
                "    /*",
                "     * If the device exists and it is not owned by either the hardware",
                "     * domain or dom_io then it must be assigned to a guest, or be",
                "     * hidden (owned by dom_xen).",
                "     */",
                "    else if ( pdev->domain != hardware_domain &&",
                "              pdev->domain != dom_io )",
                "        rc = -EBUSY;",
                "",
                "    return rc;"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-18424",
        "func_name": "xen-project/xen/iommu_do_pci_domctl",
        "description": "An issue was discovered in Xen through 4.12.x allowing attackers to gain host OS privileges via DMA in a situation where an untrusted domain has access to a physical device. This occurs because passed through PCI devices may corrupt host memory after deassignment. When a PCI device is assigned to an untrusted domain, it is possible for that domain to program the device to DMA to an arbitrary address. The IOMMU is used to protect the host from malicious DMA by making sure that the device addresses can only target memory assigned to the guest. However, when the guest domain is torn down, or the device is deassigned, the device is assigned back to dom0, thus allowing any in-flight DMA to potentially target critical host data. An untrusted domain with access to a physical device can DMA into host memory, leading to privilege escalation. Only systems where guests are given direct access to physical devices capable of DMA (PCI pass-through) are vulnerable. Systems which do not use PCI pass-through are not vulnerable.",
        "git_url": "https://github.com/xen-project/xen/commit/319f9a0ba94c7db505cd5dd9cb0b037ab1aa8e12",
        "commit_title": "passthrough: quarantine PCI devices",
        "commit_text": " When a PCI device is assigned to an untrusted domain, it is possible for that domain to program the device to DMA to an arbitrary address. The IOMMU is used to protect the host from malicious DMA by making sure that the device addresses can only target memory assigned to the guest. However, when the guest domain is torn down the device is assigned back to dom0, thus allowing any in-flight DMA to potentially target critical host data.  This patch introduces a 'quarantine' for PCI devices using dom_io. When the toolstack makes a device assignable (by binding it to pciback), it will now also assign it to DOMID_IO and the device will only be assigned back to dom0 when the device is made unassignable again. Whilst device is assignable it will only ever transfer between dom_io and guest domains. dom_io is actually only used as a sentinel domain for quarantining purposes; it is not configured with any IOMMU mappings. Assignment to dom_io simply means that the device's initiator (requestor) identifier is not present in the IOMMU's device table and thus any DMA transactions issued will be terminated with a fault condition.  In addition, a fix to assignment handling is made for VT-d.  Failure during the assignment step should not lead to a device still being associated with its prior owner. Hand the device to DomIO temporarily, until the assignment step has completed successfully.  Remove the PI hooks from the source domain then earlier as well.  Failure of the recovery reassign_device_ownership() may not go silent: There e.g. may still be left over RMRR mappings in the domain assignment to which has failed, and hence we can't allow that domain to continue executing.  NOTE: This patch also includes one printk() cleanup; the       \"XEN_DOMCTL_assign_device: \" tag is dropped in iommu_do_pci_domctl(),       since similar printk()-s elsewhere also don't log such a tag.  This is XSA-302. ",
        "func_before": "int iommu_do_pci_domctl(\n    struct xen_domctl *domctl, struct domain *d,\n    XEN_GUEST_HANDLE_PARAM(xen_domctl_t) u_domctl)\n{\n    u16 seg;\n    u8 bus, devfn;\n    int ret = 0;\n    uint32_t machine_sbdf;\n\n    switch ( domctl->cmd )\n    {\n        unsigned int flags;\n\n    case XEN_DOMCTL_get_device_group:\n    {\n        u32 max_sdevs;\n        XEN_GUEST_HANDLE_64(uint32) sdevs;\n\n        ret = xsm_get_device_group(XSM_HOOK, domctl->u.get_device_group.machine_sbdf);\n        if ( ret )\n            break;\n\n        seg = domctl->u.get_device_group.machine_sbdf >> 16;\n        bus = PCI_BUS(domctl->u.get_device_group.machine_sbdf);\n        devfn = PCI_DEVFN2(domctl->u.get_device_group.machine_sbdf);\n        max_sdevs = domctl->u.get_device_group.max_sdevs;\n        sdevs = domctl->u.get_device_group.sdev_array;\n\n        ret = iommu_get_device_group(d, seg, bus, devfn, sdevs, max_sdevs);\n        if ( ret < 0 )\n        {\n            dprintk(XENLOG_ERR, \"iommu_get_device_group() failed!\\n\");\n            ret = -EFAULT;\n            domctl->u.get_device_group.num_sdevs = 0;\n        }\n        else\n        {\n            domctl->u.get_device_group.num_sdevs = ret;\n            ret = 0;\n        }\n        if ( __copy_field_to_guest(u_domctl, domctl, u.get_device_group) )\n            ret = -EFAULT;\n    }\n    break;\n\n    case XEN_DOMCTL_assign_device:\n        ASSERT(d);\n        /* fall through */\n    case XEN_DOMCTL_test_assign_device:\n        /* Don't support self-assignment of devices. */\n        if ( d == current->domain )\n        {\n            ret = -EINVAL;\n            break;\n        }\n\n        ret = -ENODEV;\n        if ( domctl->u.assign_device.dev != XEN_DOMCTL_DEV_PCI )\n            break;\n\n        ret = -EINVAL;\n        flags = domctl->u.assign_device.flags;\n        if ( domctl->cmd == XEN_DOMCTL_assign_device\n             ? d->is_dying || (flags & ~XEN_DOMCTL_DEV_RDM_RELAXED)\n             : flags )\n            break;\n\n        machine_sbdf = domctl->u.assign_device.u.pci.machine_sbdf;\n\n        ret = xsm_assign_device(XSM_HOOK, d, machine_sbdf);\n        if ( ret )\n            break;\n\n        seg = machine_sbdf >> 16;\n        bus = PCI_BUS(machine_sbdf);\n        devfn = PCI_DEVFN2(machine_sbdf);\n\n        ret = device_assigned(seg, bus, devfn);\n        if ( domctl->cmd == XEN_DOMCTL_test_assign_device )\n        {\n            if ( ret )\n            {\n                printk(XENLOG_G_INFO\n                       \"%04x:%02x:%02x.%u already assigned, or non-existent\\n\",\n                       seg, bus, PCI_SLOT(devfn), PCI_FUNC(devfn));\n                ret = -EINVAL;\n            }\n            break;\n        }\n        if ( !ret )\n            ret = assign_device(d, seg, bus, devfn, flags);\n        if ( ret == -ERESTART )\n            ret = hypercall_create_continuation(__HYPERVISOR_domctl,\n                                                \"h\", u_domctl);\n        else if ( ret )\n            printk(XENLOG_G_ERR \"XEN_DOMCTL_assign_device: \"\n                   \"assign %04x:%02x:%02x.%u to dom%d failed (%d)\\n\",\n                   seg, bus, PCI_SLOT(devfn), PCI_FUNC(devfn),\n                   d->domain_id, ret);\n\n        break;\n\n    case XEN_DOMCTL_deassign_device:\n        /* Don't support self-deassignment of devices. */\n        if ( d == current->domain )\n        {\n            ret = -EINVAL;\n            break;\n        }\n\n        ret = -ENODEV;\n        if ( domctl->u.assign_device.dev != XEN_DOMCTL_DEV_PCI )\n            break;\n\n        ret = -EINVAL;\n        if ( domctl->u.assign_device.flags )\n            break;\n\n        machine_sbdf = domctl->u.assign_device.u.pci.machine_sbdf;\n\n        ret = xsm_deassign_device(XSM_HOOK, d, machine_sbdf);\n        if ( ret )\n            break;\n\n        seg = machine_sbdf >> 16;\n        bus = PCI_BUS(machine_sbdf);\n        devfn = PCI_DEVFN2(machine_sbdf);\n\n        pcidevs_lock();\n        ret = deassign_device(d, seg, bus, devfn);\n        pcidevs_unlock();\n        if ( ret )\n            printk(XENLOG_G_ERR\n                   \"deassign %04x:%02x:%02x.%u from dom%d failed (%d)\\n\",\n                   seg, bus, PCI_SLOT(devfn), PCI_FUNC(devfn),\n                   d->domain_id, ret);\n\n        break;\n\n    default:\n        ret = -ENOSYS;\n        break;\n    }\n\n    return ret;\n}",
        "func": "int iommu_do_pci_domctl(\n    struct xen_domctl *domctl, struct domain *d,\n    XEN_GUEST_HANDLE_PARAM(xen_domctl_t) u_domctl)\n{\n    u16 seg;\n    u8 bus, devfn;\n    int ret = 0;\n    uint32_t machine_sbdf;\n\n    switch ( domctl->cmd )\n    {\n        unsigned int flags;\n\n    case XEN_DOMCTL_get_device_group:\n    {\n        u32 max_sdevs;\n        XEN_GUEST_HANDLE_64(uint32) sdevs;\n\n        ret = xsm_get_device_group(XSM_HOOK, domctl->u.get_device_group.machine_sbdf);\n        if ( ret )\n            break;\n\n        seg = domctl->u.get_device_group.machine_sbdf >> 16;\n        bus = PCI_BUS(domctl->u.get_device_group.machine_sbdf);\n        devfn = PCI_DEVFN2(domctl->u.get_device_group.machine_sbdf);\n        max_sdevs = domctl->u.get_device_group.max_sdevs;\n        sdevs = domctl->u.get_device_group.sdev_array;\n\n        ret = iommu_get_device_group(d, seg, bus, devfn, sdevs, max_sdevs);\n        if ( ret < 0 )\n        {\n            dprintk(XENLOG_ERR, \"iommu_get_device_group() failed!\\n\");\n            ret = -EFAULT;\n            domctl->u.get_device_group.num_sdevs = 0;\n        }\n        else\n        {\n            domctl->u.get_device_group.num_sdevs = ret;\n            ret = 0;\n        }\n        if ( __copy_field_to_guest(u_domctl, domctl, u.get_device_group) )\n            ret = -EFAULT;\n    }\n    break;\n\n    case XEN_DOMCTL_assign_device:\n        ASSERT(d);\n        /* fall through */\n    case XEN_DOMCTL_test_assign_device:\n        /* Don't support self-assignment of devices. */\n        if ( d == current->domain )\n        {\n            ret = -EINVAL;\n            break;\n        }\n\n        ret = -ENODEV;\n        if ( domctl->u.assign_device.dev != XEN_DOMCTL_DEV_PCI )\n            break;\n\n        ret = -EINVAL;\n        flags = domctl->u.assign_device.flags;\n        if ( domctl->cmd == XEN_DOMCTL_assign_device\n             ? d->is_dying || (flags & ~XEN_DOMCTL_DEV_RDM_RELAXED)\n             : flags )\n            break;\n\n        machine_sbdf = domctl->u.assign_device.u.pci.machine_sbdf;\n\n        ret = xsm_assign_device(XSM_HOOK, d, machine_sbdf);\n        if ( ret )\n            break;\n\n        seg = machine_sbdf >> 16;\n        bus = PCI_BUS(machine_sbdf);\n        devfn = PCI_DEVFN2(machine_sbdf);\n\n        ret = device_assigned(seg, bus, devfn);\n        if ( domctl->cmd == XEN_DOMCTL_test_assign_device )\n        {\n            if ( ret )\n            {\n                printk(XENLOG_G_INFO\n                       \"%04x:%02x:%02x.%u already assigned, or non-existent\\n\",\n                       seg, bus, PCI_SLOT(devfn), PCI_FUNC(devfn));\n                ret = -EINVAL;\n            }\n            break;\n        }\n        if ( !ret )\n            ret = assign_device(d, seg, bus, devfn, flags);\n        if ( ret == -ERESTART )\n            ret = hypercall_create_continuation(__HYPERVISOR_domctl,\n                                                \"h\", u_domctl);\n        else if ( ret )\n            printk(XENLOG_G_ERR\n                   \"assign %04x:%02x:%02x.%u to dom%d failed (%d)\\n\",\n                   seg, bus, PCI_SLOT(devfn), PCI_FUNC(devfn),\n                   d->domain_id, ret);\n\n        break;\n\n    case XEN_DOMCTL_deassign_device:\n        /* Don't support self-deassignment of devices. */\n        if ( d == current->domain )\n        {\n            ret = -EINVAL;\n            break;\n        }\n\n        ret = -ENODEV;\n        if ( domctl->u.assign_device.dev != XEN_DOMCTL_DEV_PCI )\n            break;\n\n        ret = -EINVAL;\n        if ( domctl->u.assign_device.flags )\n            break;\n\n        machine_sbdf = domctl->u.assign_device.u.pci.machine_sbdf;\n\n        ret = xsm_deassign_device(XSM_HOOK, d, machine_sbdf);\n        if ( ret )\n            break;\n\n        seg = machine_sbdf >> 16;\n        bus = PCI_BUS(machine_sbdf);\n        devfn = PCI_DEVFN2(machine_sbdf);\n\n        pcidevs_lock();\n        ret = deassign_device(d, seg, bus, devfn);\n        pcidevs_unlock();\n        if ( ret )\n            printk(XENLOG_G_ERR\n                   \"deassign %04x:%02x:%02x.%u from dom%d failed (%d)\\n\",\n                   seg, bus, PCI_SLOT(devfn), PCI_FUNC(devfn),\n                   d->domain_id, ret);\n\n        break;\n\n    default:\n        ret = -ENOSYS;\n        break;\n    }\n\n    return ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -93,7 +93,7 @@\n             ret = hypercall_create_continuation(__HYPERVISOR_domctl,\n                                                 \"h\", u_domctl);\n         else if ( ret )\n-            printk(XENLOG_G_ERR \"XEN_DOMCTL_assign_device: \"\n+            printk(XENLOG_G_ERR\n                    \"assign %04x:%02x:%02x.%u to dom%d failed (%d)\\n\",\n                    seg, bus, PCI_SLOT(devfn), PCI_FUNC(devfn),\n                    d->domain_id, ret);",
        "diff_line_info": {
            "deleted_lines": [
                "            printk(XENLOG_G_ERR \"XEN_DOMCTL_assign_device: \""
            ],
            "added_lines": [
                "            printk(XENLOG_G_ERR"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-18424",
        "func_name": "xen-project/xen/iommu_setup",
        "description": "An issue was discovered in Xen through 4.12.x allowing attackers to gain host OS privileges via DMA in a situation where an untrusted domain has access to a physical device. This occurs because passed through PCI devices may corrupt host memory after deassignment. When a PCI device is assigned to an untrusted domain, it is possible for that domain to program the device to DMA to an arbitrary address. The IOMMU is used to protect the host from malicious DMA by making sure that the device addresses can only target memory assigned to the guest. However, when the guest domain is torn down, or the device is deassigned, the device is assigned back to dom0, thus allowing any in-flight DMA to potentially target critical host data. An untrusted domain with access to a physical device can DMA into host memory, leading to privilege escalation. Only systems where guests are given direct access to physical devices capable of DMA (PCI pass-through) are vulnerable. Systems which do not use PCI pass-through are not vulnerable.",
        "git_url": "https://github.com/xen-project/xen/commit/319f9a0ba94c7db505cd5dd9cb0b037ab1aa8e12",
        "commit_title": "passthrough: quarantine PCI devices",
        "commit_text": " When a PCI device is assigned to an untrusted domain, it is possible for that domain to program the device to DMA to an arbitrary address. The IOMMU is used to protect the host from malicious DMA by making sure that the device addresses can only target memory assigned to the guest. However, when the guest domain is torn down the device is assigned back to dom0, thus allowing any in-flight DMA to potentially target critical host data.  This patch introduces a 'quarantine' for PCI devices using dom_io. When the toolstack makes a device assignable (by binding it to pciback), it will now also assign it to DOMID_IO and the device will only be assigned back to dom0 when the device is made unassignable again. Whilst device is assignable it will only ever transfer between dom_io and guest domains. dom_io is actually only used as a sentinel domain for quarantining purposes; it is not configured with any IOMMU mappings. Assignment to dom_io simply means that the device's initiator (requestor) identifier is not present in the IOMMU's device table and thus any DMA transactions issued will be terminated with a fault condition.  In addition, a fix to assignment handling is made for VT-d.  Failure during the assignment step should not lead to a device still being associated with its prior owner. Hand the device to DomIO temporarily, until the assignment step has completed successfully.  Remove the PI hooks from the source domain then earlier as well.  Failure of the recovery reassign_device_ownership() may not go silent: There e.g. may still be left over RMRR mappings in the domain assignment to which has failed, and hence we can't allow that domain to continue executing.  NOTE: This patch also includes one printk() cleanup; the       \"XEN_DOMCTL_assign_device: \" tag is dropped in iommu_do_pci_domctl(),       since similar printk()-s elsewhere also don't log such a tag.  This is XSA-302. ",
        "func_before": "int __init iommu_setup(void)\n{\n    int rc = -ENODEV;\n    bool_t force_intremap = force_iommu && iommu_intremap;\n\n    if ( iommu_hwdom_strict )\n        iommu_hwdom_passthrough = false;\n\n    if ( iommu_enable )\n    {\n        rc = iommu_hardware_setup();\n        iommu_enabled = (rc == 0);\n    }\n    if ( !iommu_enabled )\n        iommu_intremap = 0;\n\n    if ( (force_iommu && !iommu_enabled) ||\n         (force_intremap && !iommu_intremap) )\n        panic(\"Couldn't enable %s and iommu=required/force\\n\",\n              !iommu_enabled ? \"IOMMU\" : \"Interrupt Remapping\");\n\n    if ( !iommu_intremap )\n        iommu_intpost = 0;\n\n    printk(\"I/O virtualisation %sabled\\n\", iommu_enabled ? \"en\" : \"dis\");\n    if ( !iommu_enabled )\n    {\n        iommu_snoop = 0;\n        iommu_hwdom_passthrough = false;\n        iommu_hwdom_strict = false;\n    }\n    else\n    {\n        printk(\" - Dom0 mode: %s\\n\",\n               iommu_hwdom_passthrough ? \"Passthrough\" :\n               iommu_hwdom_strict ? \"Strict\" : \"Relaxed\");\n        printk(\"Interrupt remapping %sabled\\n\", iommu_intremap ? \"en\" : \"dis\");\n        tasklet_init(&iommu_pt_cleanup_tasklet, iommu_free_pagetables, 0);\n    }\n\n    return rc;\n}",
        "func": "int __init iommu_setup(void)\n{\n    int rc = -ENODEV;\n    bool_t force_intremap = force_iommu && iommu_intremap;\n\n    if ( iommu_hwdom_strict )\n        iommu_hwdom_passthrough = false;\n\n    if ( iommu_enable )\n    {\n        rc = iommu_hardware_setup();\n        iommu_enabled = (rc == 0);\n    }\n    if ( !iommu_enabled )\n        iommu_intremap = 0;\n\n    if ( (force_iommu && !iommu_enabled) ||\n         (force_intremap && !iommu_intremap) )\n        panic(\"Couldn't enable %s and iommu=required/force\\n\",\n              !iommu_enabled ? \"IOMMU\" : \"Interrupt Remapping\");\n\n    if ( !iommu_intremap )\n        iommu_intpost = 0;\n\n    printk(\"I/O virtualisation %sabled\\n\", iommu_enabled ? \"en\" : \"dis\");\n    if ( !iommu_enabled )\n    {\n        iommu_snoop = 0;\n        iommu_hwdom_passthrough = false;\n        iommu_hwdom_strict = false;\n    }\n    else\n    {\n        dom_io->options |= XEN_DOMCTL_CDF_iommu;\n        if ( iommu_domain_init(dom_io, 0) )\n            panic(\"Could not set up quarantine\\n\");\n\n        printk(\" - Dom0 mode: %s\\n\",\n               iommu_hwdom_passthrough ? \"Passthrough\" :\n               iommu_hwdom_strict ? \"Strict\" : \"Relaxed\");\n        printk(\"Interrupt remapping %sabled\\n\", iommu_intremap ? \"en\" : \"dis\");\n        tasklet_init(&iommu_pt_cleanup_tasklet, iommu_free_pagetables, 0);\n    }\n\n    return rc;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -31,6 +31,10 @@\n     }\n     else\n     {\n+        dom_io->options |= XEN_DOMCTL_CDF_iommu;\n+        if ( iommu_domain_init(dom_io, 0) )\n+            panic(\"Could not set up quarantine\\n\");\n+\n         printk(\" - Dom0 mode: %s\\n\",\n                iommu_hwdom_passthrough ? \"Passthrough\" :\n                iommu_hwdom_strict ? \"Strict\" : \"Relaxed\");",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "        dom_io->options |= XEN_DOMCTL_CDF_iommu;",
                "        if ( iommu_domain_init(dom_io, 0) )",
                "            panic(\"Could not set up quarantine\\n\");",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2019-18424",
        "func_name": "xen-project/xen/iommu_domain_init",
        "description": "An issue was discovered in Xen through 4.12.x allowing attackers to gain host OS privileges via DMA in a situation where an untrusted domain has access to a physical device. This occurs because passed through PCI devices may corrupt host memory after deassignment. When a PCI device is assigned to an untrusted domain, it is possible for that domain to program the device to DMA to an arbitrary address. The IOMMU is used to protect the host from malicious DMA by making sure that the device addresses can only target memory assigned to the guest. However, when the guest domain is torn down, or the device is deassigned, the device is assigned back to dom0, thus allowing any in-flight DMA to potentially target critical host data. An untrusted domain with access to a physical device can DMA into host memory, leading to privilege escalation. Only systems where guests are given direct access to physical devices capable of DMA (PCI pass-through) are vulnerable. Systems which do not use PCI pass-through are not vulnerable.",
        "git_url": "https://github.com/xen-project/xen/commit/319f9a0ba94c7db505cd5dd9cb0b037ab1aa8e12",
        "commit_title": "passthrough: quarantine PCI devices",
        "commit_text": " When a PCI device is assigned to an untrusted domain, it is possible for that domain to program the device to DMA to an arbitrary address. The IOMMU is used to protect the host from malicious DMA by making sure that the device addresses can only target memory assigned to the guest. However, when the guest domain is torn down the device is assigned back to dom0, thus allowing any in-flight DMA to potentially target critical host data.  This patch introduces a 'quarantine' for PCI devices using dom_io. When the toolstack makes a device assignable (by binding it to pciback), it will now also assign it to DOMID_IO and the device will only be assigned back to dom0 when the device is made unassignable again. Whilst device is assignable it will only ever transfer between dom_io and guest domains. dom_io is actually only used as a sentinel domain for quarantining purposes; it is not configured with any IOMMU mappings. Assignment to dom_io simply means that the device's initiator (requestor) identifier is not present in the IOMMU's device table and thus any DMA transactions issued will be terminated with a fault condition.  In addition, a fix to assignment handling is made for VT-d.  Failure during the assignment step should not lead to a device still being associated with its prior owner. Hand the device to DomIO temporarily, until the assignment step has completed successfully.  Remove the PI hooks from the source domain then earlier as well.  Failure of the recovery reassign_device_ownership() may not go silent: There e.g. may still be left over RMRR mappings in the domain assignment to which has failed, and hence we can't allow that domain to continue executing.  NOTE: This patch also includes one printk() cleanup; the       \"XEN_DOMCTL_assign_device: \" tag is dropped in iommu_do_pci_domctl(),       since similar printk()-s elsewhere also don't log such a tag.  This is XSA-302. ",
        "func_before": "int iommu_domain_init(struct domain *d, unsigned int opts)\n{\n    struct domain_iommu *hd = dom_iommu(d);\n    int ret = 0;\n\n    if ( !is_iommu_enabled(d) )\n        return 0;\n\n#ifdef CONFIG_NUMA\n    hd->node = NUMA_NO_NODE;\n#endif\n\n    ret = arch_iommu_domain_init(d);\n    if ( ret )\n        return ret;\n\n    hd->platform_ops = iommu_get_ops();\n    ret = hd->platform_ops->init(d);\n    if ( ret )\n        return ret;\n\n    if ( is_hardware_domain(d) )\n        check_hwdom_reqs(d); /* may modify iommu_hwdom_strict */\n\n    /*\n     * Use shared page tables for HAP and IOMMU if the global option\n     * is enabled (from which we can infer the h/w is capable) and\n     * the domain options do not disallow it. HAP must, of course, also\n     * be enabled.\n     */\n    hd->hap_pt_share = hap_enabled(d) && iommu_hap_pt_share &&\n        !(opts & XEN_DOMCTL_IOMMU_no_sharept);\n\n    /*\n     * NB: 'relaxed' h/w domains don't need the IOMMU mappings to be kept\n     *     in-sync with their assigned pages because all host RAM will be\n     *     mapped during hwdom_init().\n     */\n    if ( !is_hardware_domain(d) || iommu_hwdom_strict )\n        hd->need_sync = !iommu_use_hap_pt(d);\n\n    ASSERT(!(hd->need_sync && hd->hap_pt_share));\n\n    return 0;\n}",
        "func": "int iommu_domain_init(struct domain *d, unsigned int opts)\n{\n    struct domain_iommu *hd = dom_iommu(d);\n    int ret = 0;\n\n    if ( !is_iommu_enabled(d) )\n        return 0;\n\n#ifdef CONFIG_NUMA\n    hd->node = NUMA_NO_NODE;\n#endif\n\n    ret = arch_iommu_domain_init(d);\n    if ( ret )\n        return ret;\n\n    hd->platform_ops = iommu_get_ops();\n    ret = hd->platform_ops->init(d);\n    if ( ret || is_system_domain(d) )\n        return ret;\n\n    if ( is_hardware_domain(d) )\n        check_hwdom_reqs(d); /* may modify iommu_hwdom_strict */\n\n    /*\n     * Use shared page tables for HAP and IOMMU if the global option\n     * is enabled (from which we can infer the h/w is capable) and\n     * the domain options do not disallow it. HAP must, of course, also\n     * be enabled.\n     */\n    hd->hap_pt_share = hap_enabled(d) && iommu_hap_pt_share &&\n        !(opts & XEN_DOMCTL_IOMMU_no_sharept);\n\n    /*\n     * NB: 'relaxed' h/w domains don't need the IOMMU mappings to be kept\n     *     in-sync with their assigned pages because all host RAM will be\n     *     mapped during hwdom_init().\n     */\n    if ( !is_hardware_domain(d) || iommu_hwdom_strict )\n        hd->need_sync = !iommu_use_hap_pt(d);\n\n    ASSERT(!(hd->need_sync && hd->hap_pt_share));\n\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -16,7 +16,7 @@\n \n     hd->platform_ops = iommu_get_ops();\n     ret = hd->platform_ops->init(d);\n-    if ( ret )\n+    if ( ret || is_system_domain(d) )\n         return ret;\n \n     if ( is_hardware_domain(d) )",
        "diff_line_info": {
            "deleted_lines": [
                "    if ( ret )"
            ],
            "added_lines": [
                "    if ( ret || is_system_domain(d) )"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-41751",
        "func_name": "Matthias-Wandel/jhead/RegenerateThumbnail",
        "description": "Jhead 3.06.0.1 allows attackers to execute arbitrary OS commands by placing them in a JPEG filename and then using the regeneration -rgt50 option.",
        "git_url": "https://github.com/Matthias-Wandel/jhead/commit/3fe905cf674f8dbac8a89e58cee1b4850abf9530",
        "commit_title": "Check for dangerous filenames in RegenerateThumbnail",
        "commit_text": "",
        "func_before": "static int RegenerateThumbnail(const char * FileName)\n{\n    char ThumbnailGenCommand[PATH_MAX*2+50];\n    if (ImageInfo.ThumbnailOffset == 0 || ImageInfo.ThumbnailAtEnd == FALSE){\n        // There is no thumbnail, or the thumbnail is not at the end.\n        return FALSE;\n    }\n\n    snprintf(ThumbnailGenCommand, sizeof(ThumbnailGenCommand),\n        \"mogrify -thumbnail %dx%d -quality 80 \\\"%s\\\"\",\n        RegenThumbnail, RegenThumbnail, FileName);\n\n    if (system(ThumbnailGenCommand) == 0){\n        // Put the thumbnail back in the header\n        return ReplaceThumbnail(FileName);\n    }else{\n        ErrFatal(\"Unable to run 'mogrify' command\");\n        return FALSE;\n    }\n}",
        "func": "static int RegenerateThumbnail(const char * FileName)\n{\n    char ThumbnailGenCommand[PATH_MAX*2+50];\n    if (ImageInfo.ThumbnailOffset == 0 || ImageInfo.ThumbnailAtEnd == FALSE){\n        // There is no thumbnail, or the thumbnail is not at the end.\n        return FALSE;\n    }\n\n    // Disallow characters in the filename that could be used to execute arbitrary\n    // shell commands with system() below.\n    if(strpbrk(FileName, \"\\\";'&|`\")) {\n        ErrNonfatal(\"Filename has invalid characters.\", 0, 0);\n        return FALSE;\n    }\n\n    snprintf(ThumbnailGenCommand, sizeof(ThumbnailGenCommand),\n        \"mogrify -thumbnail %dx%d -quality 80 \\\"%s\\\"\",\n        RegenThumbnail, RegenThumbnail, FileName);\n\n    if (system(ThumbnailGenCommand) == 0){\n        // Put the thumbnail back in the header\n        return ReplaceThumbnail(FileName);\n    }else{\n        ErrFatal(\"Unable to run 'mogrify' command\");\n        return FALSE;\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,6 +3,13 @@\n     char ThumbnailGenCommand[PATH_MAX*2+50];\n     if (ImageInfo.ThumbnailOffset == 0 || ImageInfo.ThumbnailAtEnd == FALSE){\n         // There is no thumbnail, or the thumbnail is not at the end.\n+        return FALSE;\n+    }\n+\n+    // Disallow characters in the filename that could be used to execute arbitrary\n+    // shell commands with system() below.\n+    if(strpbrk(FileName, \"\\\";'&|`\")) {\n+        ErrNonfatal(\"Filename has invalid characters.\", 0, 0);\n         return FALSE;\n     }\n ",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "        return FALSE;",
                "    }",
                "",
                "    // Disallow characters in the filename that could be used to execute arbitrary",
                "    // shell commands with system() below.",
                "    if(strpbrk(FileName, \"\\\";'&|`\")) {",
                "        ErrNonfatal(\"Filename has invalid characters.\", 0, 0);"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-41751",
        "func_name": "Matthias-Wandel/jhead/RegenerateThumbnail",
        "description": "Jhead 3.06.0.1 allows attackers to execute arbitrary OS commands by placing them in a JPEG filename and then using the regeneration -rgt50 option.",
        "git_url": "https://github.com/Matthias-Wandel/jhead/commit/6985da52c9ad4f5f6c247269cb5508fae34a971c",
        "commit_title": "Replace sprintf with snprintf in RegenerateThumbnail",
        "commit_text": "",
        "func_before": "static int RegenerateThumbnail(const char * FileName)\n{\n    char ThumbnailGenCommand[PATH_MAX*2+50];\n    if (ImageInfo.ThumbnailOffset == 0 || ImageInfo.ThumbnailAtEnd == FALSE){\n        // There is no thumbnail, or the thumbnail is not at the end.\n        return FALSE;\n    }\n\n    sprintf(ThumbnailGenCommand, \"mogrify -thumbnail %dx%d -quality 80 \\\"%s\\\"\",\n        RegenThumbnail, RegenThumbnail, FileName);\n\n    if (system(ThumbnailGenCommand) == 0){\n        // Put the thumbnail back in the header\n        return ReplaceThumbnail(FileName);\n    }else{\n        ErrFatal(\"Unable to run 'mogrify' command\");\n        return FALSE;\n    }\n}",
        "func": "static int RegenerateThumbnail(const char * FileName)\n{\n    char ThumbnailGenCommand[PATH_MAX*2+50];\n    if (ImageInfo.ThumbnailOffset == 0 || ImageInfo.ThumbnailAtEnd == FALSE){\n        // There is no thumbnail, or the thumbnail is not at the end.\n        return FALSE;\n    }\n\n    snprintf(ThumbnailGenCommand, sizeof(ThumbnailGenCommand),\n        \"mogrify -thumbnail %dx%d -quality 80 \\\"%s\\\"\",\n        RegenThumbnail, RegenThumbnail, FileName);\n\n    if (system(ThumbnailGenCommand) == 0){\n        // Put the thumbnail back in the header\n        return ReplaceThumbnail(FileName);\n    }else{\n        ErrFatal(\"Unable to run 'mogrify' command\");\n        return FALSE;\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,7 +6,8 @@\n         return FALSE;\n     }\n \n-    sprintf(ThumbnailGenCommand, \"mogrify -thumbnail %dx%d -quality 80 \\\"%s\\\"\",\n+    snprintf(ThumbnailGenCommand, sizeof(ThumbnailGenCommand),\n+        \"mogrify -thumbnail %dx%d -quality 80 \\\"%s\\\"\",\n         RegenThumbnail, RegenThumbnail, FileName);\n \n     if (system(ThumbnailGenCommand) == 0){",
        "diff_line_info": {
            "deleted_lines": [
                "    sprintf(ThumbnailGenCommand, \"mogrify -thumbnail %dx%d -quality 80 \\\"%s\\\"\","
            ],
            "added_lines": [
                "    snprintf(ThumbnailGenCommand, sizeof(ThumbnailGenCommand),",
                "        \"mogrify -thumbnail %dx%d -quality 80 \\\"%s\\\"\","
            ]
        }
    },
    {
        "cve_id": "CVE-2017-15924",
        "func_name": "shadowsocks/shadowsocks-libev/construct_command_line",
        "description": "In manager.c in ss-manager in shadowsocks-libev 3.1.0, improper parsing allows command injection via shell metacharacters in a JSON configuration request received via 127.0.0.1 UDP traffic, related to the add_server, build_config, and construct_command_line functions.",
        "git_url": "https://github.com/shadowsocks/shadowsocks-libev/commit/c67d275803dc6ea22c558d06b1f7ba9f94cd8de3",
        "commit_title": "Fix #1734",
        "commit_text": "",
        "func_before": "static char *\nconstruct_command_line(struct manager_ctx *manager, struct server *server)\n{\n    static char cmd[BUF_SIZE];\n    char *method = manager->method;\n    int i;\n\n    build_config(working_dir, server);\n\n    if (server->method) method = server->method;\n    memset(cmd, 0, BUF_SIZE);\n    snprintf(cmd, BUF_SIZE,\n             \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\",\n             executable, method, manager->manager_address,\n             working_dir, server->port, working_dir, server->port);\n\n    if (manager->acl != NULL) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" --acl %s\", manager->acl);\n    }\n    if (manager->timeout != NULL) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" -t %s\", manager->timeout);\n    }\n#ifdef HAVE_SETRLIMIT\n    if (manager->nofile) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" -n %d\", manager->nofile);\n    }\n#endif\n    if (manager->user != NULL) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" -a %s\", manager->user);\n    }\n    if (manager->verbose) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" -v\");\n    }\n    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" -U\");\n    }\n    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" -u\");\n    }\n    if (server->fast_open[0] == 0 && manager->fast_open) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" --fast-open\");\n    }\n    if (manager->ipv6first) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" -6\");\n    }\n    if (manager->mtu) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" --mtu %d\", manager->mtu);\n    }\n    if (server->plugin == NULL && manager->plugin) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" --plugin \\\"%s\\\"\", manager->plugin);\n    }\n    if (server->plugin_opts == NULL && manager->plugin_opts) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" --plugin-opts \\\"%s\\\"\", manager->plugin_opts);\n    }\n    for (i = 0; i < manager->nameserver_num; i++) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" -d %s\", manager->nameservers[i]);\n    }\n    for (i = 0; i < manager->host_num; i++) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" -s %s\", manager->hosts[i]);\n    }\n    // Always enable reuse port\n    {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" --reuse-port\");\n    }\n\n    if (verbose) {\n        LOGI(\"cmd: %s\", cmd);\n    }\n\n    return cmd;\n}",
        "func": "static char *\nconstruct_command_line(struct manager_ctx *manager, struct server *server)\n{\n    static char cmd[BUF_SIZE];\n    int i;\n    int port;\n\n    port = atoi(server->port);\n\n    build_config(working_dir, manager, server);\n\n    memset(cmd, 0, BUF_SIZE);\n    snprintf(cmd, BUF_SIZE,\n             \"%s --manager-address %s -f %s/.shadowsocks_%d.pid -c %s/.shadowsocks_%d.conf\",\n             executable, manager->manager_address, working_dir, port, working_dir, port);\n\n    if (manager->acl != NULL) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" --acl %s\", manager->acl);\n    }\n    if (manager->timeout != NULL) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" -t %s\", manager->timeout);\n    }\n#ifdef HAVE_SETRLIMIT\n    if (manager->nofile) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" -n %d\", manager->nofile);\n    }\n#endif\n    if (manager->user != NULL) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" -a %s\", manager->user);\n    }\n    if (manager->verbose) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" -v\");\n    }\n    if (server->mode == NULL && manager->mode == UDP_ONLY) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" -U\");\n    }\n    if (server->mode == NULL && manager->mode == TCP_AND_UDP) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" -u\");\n    }\n    if (server->fast_open[0] == 0 && manager->fast_open) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" --fast-open\");\n    }\n    if (manager->ipv6first) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" -6\");\n    }\n    if (manager->mtu) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" --mtu %d\", manager->mtu);\n    }\n    if (server->plugin == NULL && manager->plugin) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" --plugin \\\"%s\\\"\", manager->plugin);\n    }\n    if (server->plugin_opts == NULL && manager->plugin_opts) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" --plugin-opts \\\"%s\\\"\", manager->plugin_opts);\n    }\n    for (i = 0; i < manager->nameserver_num; i++) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" -d %s\", manager->nameservers[i]);\n    }\n    for (i = 0; i < manager->host_num; i++) {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" -s %s\", manager->hosts[i]);\n    }\n    // Always enable reuse port\n    {\n        int len = strlen(cmd);\n        snprintf(cmd + len, BUF_SIZE - len, \" --reuse-port\");\n    }\n\n    if (verbose) {\n        LOGI(\"cmd: %s\", cmd);\n    }\n\n    return cmd;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,17 +2,17 @@\n construct_command_line(struct manager_ctx *manager, struct server *server)\n {\n     static char cmd[BUF_SIZE];\n-    char *method = manager->method;\n     int i;\n+    int port;\n \n-    build_config(working_dir, server);\n+    port = atoi(server->port);\n \n-    if (server->method) method = server->method;\n+    build_config(working_dir, manager, server);\n+\n     memset(cmd, 0, BUF_SIZE);\n     snprintf(cmd, BUF_SIZE,\n-             \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\",\n-             executable, method, manager->manager_address,\n-             working_dir, server->port, working_dir, server->port);\n+             \"%s --manager-address %s -f %s/.shadowsocks_%d.pid -c %s/.shadowsocks_%d.conf\",\n+             executable, manager->manager_address, working_dir, port, working_dir, port);\n \n     if (manager->acl != NULL) {\n         int len = strlen(cmd);",
        "diff_line_info": {
            "deleted_lines": [
                "    char *method = manager->method;",
                "    build_config(working_dir, server);",
                "    if (server->method) method = server->method;",
                "             \"%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf\",",
                "             executable, method, manager->manager_address,",
                "             working_dir, server->port, working_dir, server->port);"
            ],
            "added_lines": [
                "    int port;",
                "    port = atoi(server->port);",
                "    build_config(working_dir, manager, server);",
                "",
                "             \"%s --manager-address %s -f %s/.shadowsocks_%d.pid -c %s/.shadowsocks_%d.conf\",",
                "             executable, manager->manager_address, working_dir, port, working_dir, port);"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-15924",
        "func_name": "shadowsocks/shadowsocks-libev/build_config",
        "description": "In manager.c in ss-manager in shadowsocks-libev 3.1.0, improper parsing allows command injection via shell metacharacters in a JSON configuration request received via 127.0.0.1 UDP traffic, related to the add_server, build_config, and construct_command_line functions.",
        "git_url": "https://github.com/shadowsocks/shadowsocks-libev/commit/c67d275803dc6ea22c558d06b1f7ba9f94cd8de3",
        "commit_title": "Fix #1734",
        "commit_text": "",
        "func_before": "static void\nbuild_config(char *prefix, struct server *server)\n{\n    char *path    = NULL;\n    int path_size = strlen(prefix) + strlen(server->port) + 20;\n\n    path = ss_malloc(path_size);\n    snprintf(path, path_size, \"%s/.shadowsocks_%s.conf\", prefix, server->port);\n    FILE *f = fopen(path, \"w+\");\n    if (f == NULL) {\n        if (verbose) {\n            LOGE(\"unable to open config file\");\n        }\n        ss_free(path);\n        return;\n    }\n    fprintf(f, \"{\\n\");\n    fprintf(f, \"\\\"server_port\\\":%d,\\n\", atoi(server->port));\n    fprintf(f, \"\\\"password\\\":\\\"%s\\\"\", server->password);\n    if (server->fast_open[0]) fprintf(f, \",\\n\\\"fast_open\\\": %s\", server->fast_open);\n    if (server->mode)   fprintf(f, \",\\n\\\"mode\\\":\\\"%s\\\"\", server->mode);\n    if (server->method) fprintf(f, \",\\n\\\"method\\\":\\\"%s\\\"\", server->method);\n    if (server->plugin) fprintf(f, \",\\n\\\"plugin\\\":\\\"%s\\\"\", server->plugin);\n    if (server->plugin_opts) fprintf(f, \",\\n\\\"plugin_opts\\\":\\\"%s\\\"\", server->plugin_opts);\n    fprintf(f, \"\\n}\\n\");\n    fclose(f);\n    ss_free(path);\n}",
        "func": "static void\nbuild_config(char *prefix, struct manager_ctx *manager, struct server *server)\n{\n    char *path    = NULL;\n    int path_size = strlen(prefix) + strlen(server->port) + 20;\n\n    path = ss_malloc(path_size);\n    snprintf(path, path_size, \"%s/.shadowsocks_%s.conf\", prefix, server->port);\n    FILE *f = fopen(path, \"w+\");\n    if (f == NULL) {\n        if (verbose) {\n            LOGE(\"unable to open config file\");\n        }\n        ss_free(path);\n        return;\n    }\n    fprintf(f, \"{\\n\");\n    fprintf(f, \"\\\"server_port\\\":%d,\\n\", atoi(server->port));\n    fprintf(f, \"\\\"password\\\":\\\"%s\\\"\", server->password);\n    if (server->method)\n        fprintf(f, \",\\n\\\"method\\\":\\\"%s\\\"\", server->method);\n    else if (manager->method)\n        fprintf(f, \",\\n\\\"method\\\":\\\"%s\\\"\", manager->method);\n    if (server->fast_open[0])\n        fprintf(f, \",\\n\\\"fast_open\\\": %s\", server->fast_open);\n    if (server->mode)\n        fprintf(f, \",\\n\\\"mode\\\":\\\"%s\\\"\", server->mode);\n    if (server->plugin)\n        fprintf(f, \",\\n\\\"plugin\\\":\\\"%s\\\"\", server->plugin);\n    if (server->plugin_opts)\n        fprintf(f, \",\\n\\\"plugin_opts\\\":\\\"%s\\\"\", server->plugin_opts);\n    fprintf(f, \"\\n}\\n\");\n    fclose(f);\n    ss_free(path);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,5 @@\n static void\n-build_config(char *prefix, struct server *server)\n+build_config(char *prefix, struct manager_ctx *manager, struct server *server)\n {\n     char *path    = NULL;\n     int path_size = strlen(prefix) + strlen(server->port) + 20;\n@@ -17,11 +17,18 @@\n     fprintf(f, \"{\\n\");\n     fprintf(f, \"\\\"server_port\\\":%d,\\n\", atoi(server->port));\n     fprintf(f, \"\\\"password\\\":\\\"%s\\\"\", server->password);\n-    if (server->fast_open[0]) fprintf(f, \",\\n\\\"fast_open\\\": %s\", server->fast_open);\n-    if (server->mode)   fprintf(f, \",\\n\\\"mode\\\":\\\"%s\\\"\", server->mode);\n-    if (server->method) fprintf(f, \",\\n\\\"method\\\":\\\"%s\\\"\", server->method);\n-    if (server->plugin) fprintf(f, \",\\n\\\"plugin\\\":\\\"%s\\\"\", server->plugin);\n-    if (server->plugin_opts) fprintf(f, \",\\n\\\"plugin_opts\\\":\\\"%s\\\"\", server->plugin_opts);\n+    if (server->method)\n+        fprintf(f, \",\\n\\\"method\\\":\\\"%s\\\"\", server->method);\n+    else if (manager->method)\n+        fprintf(f, \",\\n\\\"method\\\":\\\"%s\\\"\", manager->method);\n+    if (server->fast_open[0])\n+        fprintf(f, \",\\n\\\"fast_open\\\": %s\", server->fast_open);\n+    if (server->mode)\n+        fprintf(f, \",\\n\\\"mode\\\":\\\"%s\\\"\", server->mode);\n+    if (server->plugin)\n+        fprintf(f, \",\\n\\\"plugin\\\":\\\"%s\\\"\", server->plugin);\n+    if (server->plugin_opts)\n+        fprintf(f, \",\\n\\\"plugin_opts\\\":\\\"%s\\\"\", server->plugin_opts);\n     fprintf(f, \"\\n}\\n\");\n     fclose(f);\n     ss_free(path);",
        "diff_line_info": {
            "deleted_lines": [
                "build_config(char *prefix, struct server *server)",
                "    if (server->fast_open[0]) fprintf(f, \",\\n\\\"fast_open\\\": %s\", server->fast_open);",
                "    if (server->mode)   fprintf(f, \",\\n\\\"mode\\\":\\\"%s\\\"\", server->mode);",
                "    if (server->method) fprintf(f, \",\\n\\\"method\\\":\\\"%s\\\"\", server->method);",
                "    if (server->plugin) fprintf(f, \",\\n\\\"plugin\\\":\\\"%s\\\"\", server->plugin);",
                "    if (server->plugin_opts) fprintf(f, \",\\n\\\"plugin_opts\\\":\\\"%s\\\"\", server->plugin_opts);"
            ],
            "added_lines": [
                "build_config(char *prefix, struct manager_ctx *manager, struct server *server)",
                "    if (server->method)",
                "        fprintf(f, \",\\n\\\"method\\\":\\\"%s\\\"\", server->method);",
                "    else if (manager->method)",
                "        fprintf(f, \",\\n\\\"method\\\":\\\"%s\\\"\", manager->method);",
                "    if (server->fast_open[0])",
                "        fprintf(f, \",\\n\\\"fast_open\\\": %s\", server->fast_open);",
                "    if (server->mode)",
                "        fprintf(f, \",\\n\\\"mode\\\":\\\"%s\\\"\", server->mode);",
                "    if (server->plugin)",
                "        fprintf(f, \",\\n\\\"plugin\\\":\\\"%s\\\"\", server->plugin);",
                "    if (server->plugin_opts)",
                "        fprintf(f, \",\\n\\\"plugin_opts\\\":\\\"%s\\\"\", server->plugin_opts);"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-14500",
        "func_name": "akrennmair/newsbeuter/queueloader::get_filename",
        "description": "Improper Neutralization of Special Elements used in an OS Command in the podcast playback function of Podbeuter in Newsbeuter 0.3 through 2.9 allows remote attackers to perform user-assisted code execution by crafting an RSS item with a media enclosure (i.e., a podcast file) that includes shell metacharacters in its filename, related to pb_controller.cpp and queueloader.cpp, a different vulnerability than CVE-2017-12904.",
        "git_url": "https://github.com/akrennmair/newsbeuter/commit/26f5a4350f3ab5507bb8727051c87bb04660f333",
        "commit_title": "Work around shell code in podcast names (#598)",
        "commit_text": "",
        "func_before": "std::string queueloader::get_filename(const std::string& str) {\n\tstd::string fn = ctrl->get_dlpath();\n\n\tif (fn[fn.length()-1] != NEWSBEUTER_PATH_SEP[0])\n\t\tfn.append(NEWSBEUTER_PATH_SEP);\n\tchar buf[1024];\n\tsnprintf(buf, sizeof(buf), \"%s\", str.c_str());\n\tchar * base = basename(buf);\n\tif (!base || strlen(base) == 0) {\n\t\tchar lbuf[128];\n\t\ttime_t t = time(NULL);\n\t\tstrftime(lbuf, sizeof(lbuf), \"%Y-%b-%d-%H%M%S.unknown\", localtime(&t));\n\t\tfn.append(lbuf);\n\t} else {\n\t\tfn.append(base);\n\t}\n\treturn fn;\n}",
        "func": "std::string queueloader::get_filename(const std::string& str) {\n\tstd::string fn = ctrl->get_dlpath();\n\n\tif (fn[fn.length()-1] != NEWSBEUTER_PATH_SEP[0])\n\t\tfn.append(NEWSBEUTER_PATH_SEP);\n\tchar buf[1024];\n\tsnprintf(buf, sizeof(buf), \"%s\", str.c_str());\n\tchar * base = basename(buf);\n\tif (!base || strlen(base) == 0) {\n\t\tchar lbuf[128];\n\t\ttime_t t = time(NULL);\n\t\tstrftime(lbuf, sizeof(lbuf), \"%Y-%b-%d-%H%M%S.unknown\", localtime(&t));\n\t\tfn.append(lbuf);\n\t} else {\n\t\tfn.append(utils::replace_all(base, \"'\", \"%27\"));\n\t}\n\treturn fn;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -12,7 +12,7 @@\n \t\tstrftime(lbuf, sizeof(lbuf), \"%Y-%b-%d-%H%M%S.unknown\", localtime(&t));\n \t\tfn.append(lbuf);\n \t} else {\n-\t\tfn.append(base);\n+\t\tfn.append(utils::replace_all(base, \"'\", \"%27\"));\n \t}\n \treturn fn;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tfn.append(base);"
            ],
            "added_lines": [
                "\t\tfn.append(utils::replace_all(base, \"'\", \"%27\"));"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-14500",
        "func_name": "akrennmair/newsbeuter/pb_controller::play_file",
        "description": "Improper Neutralization of Special Elements used in an OS Command in the podcast playback function of Podbeuter in Newsbeuter 0.3 through 2.9 allows remote attackers to perform user-assisted code execution by crafting an RSS item with a media enclosure (i.e., a podcast file) that includes shell metacharacters in its filename, related to pb_controller.cpp and queueloader.cpp, a different vulnerability than CVE-2017-12904.",
        "git_url": "https://github.com/akrennmair/newsbeuter/commit/26f5a4350f3ab5507bb8727051c87bb04660f333",
        "commit_title": "Work around shell code in podcast names (#598)",
        "commit_text": "",
        "func_before": "void pb_controller::play_file(const std::string& file) {\n\tstd::string cmdline;\n\tstd::string player = cfg->get_configvalue(\"player\");\n\tif (player == \"\")\n\t\treturn;\n\tcmdline.append(player);\n\tcmdline.append(\" \\\"\");\n\tcmdline.append(utils::replace_all(file,\"\\\"\", \"\\\\\\\"\"));\n\tcmdline.append(\"\\\"\");\n\tstfl::reset();\n\tLOG(LOG_DEBUG, \"pb_controller::play_file: running `%s'\", cmdline.c_str());\n\t::system(cmdline.c_str());\n}",
        "func": "void pb_controller::play_file(const std::string& file) {\n\tstd::string cmdline;\n\tstd::string player = cfg->get_configvalue(\"player\");\n\tif (player == \"\")\n\t\treturn;\n\tcmdline.append(player);\n\tcmdline.append(\" \\'\");\n\tcmdline.append(utils::replace_all(file,\"'\", \"%27\"));\n\tcmdline.append(\"\\'\");\n\tstfl::reset();\n\tLOG(LOG_DEBUG, \"pb_controller::play_file: running `%s'\", cmdline.c_str());\n\t::system(cmdline.c_str());\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,9 +4,9 @@\n \tif (player == \"\")\n \t\treturn;\n \tcmdline.append(player);\n-\tcmdline.append(\" \\\"\");\n-\tcmdline.append(utils::replace_all(file,\"\\\"\", \"\\\\\\\"\"));\n-\tcmdline.append(\"\\\"\");\n+\tcmdline.append(\" \\'\");\n+\tcmdline.append(utils::replace_all(file,\"'\", \"%27\"));\n+\tcmdline.append(\"\\'\");\n \tstfl::reset();\n \tLOG(LOG_DEBUG, \"pb_controller::play_file: running `%s'\", cmdline.c_str());\n \t::system(cmdline.c_str());",
        "diff_line_info": {
            "deleted_lines": [
                "\tcmdline.append(\" \\\"\");",
                "\tcmdline.append(utils::replace_all(file,\"\\\"\", \"\\\\\\\"\"));",
                "\tcmdline.append(\"\\\"\");"
            ],
            "added_lines": [
                "\tcmdline.append(\" \\'\");",
                "\tcmdline.append(utils::replace_all(file,\"'\", \"%27\"));",
                "\tcmdline.append(\"\\'\");"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-5736",
        "func_name": "opencontainers/runc/nsexec",
        "description": "runc through 1.0-rc6, as used in Docker before 18.09.2 and other products, allows attackers to overwrite the host runc binary (and consequently obtain host root access) by leveraging the ability to execute a command as root within one of these types of containers: (1) a new container with an attacker-controlled image, or (2) an existing container, to which the attacker previously had write access, that can be attached with docker exec. This occurs because of file-descriptor mishandling, related to /proc/self/exe.",
        "git_url": "https://github.com/opencontainers/runc/commit/0a8e4117e7f715d5fbeef398405813ce8e88558b",
        "commit_title": "nsenter: clone /proc/self/exe to avoid exposing host binary to container",
        "commit_text": " There are quite a few circumstances where /proc/self/exe pointing to a pretty important container binary is a _bad_ thing, so to avoid this we have to make a copy (preferably doing self-clean-up and not being writeable).  We require memfd_create(2) -- though there is an O_TMPFILE fallback -- but we can always extend this to use a scratch MNT_DETACH overlayfs or tmpfs. The main downside to this approach is no page-cache sharing for the runc binary (which overlayfs would give us) but this is far less complicated.  This is only done during nsenter so that it happens transparently to the Go code, and any libcontainer users benefit from it. This also makes ExtraFiles and --preserve-fds handling trivial (because we don't need to worry about it).  Co-developed-by: Christian Brauner <christian.brauner@ubuntu.com>",
        "func_before": "void nsexec(void)\n{\n\tint pipenum;\n\tjmp_buf env;\n\tint sync_child_pipe[2], sync_grandchild_pipe[2];\n\tstruct nlconfig_t config = { 0 };\n\n\t/*\n\t * If we don't have an init pipe, just return to the go routine.\n\t * We'll only get an init pipe for start or exec.\n\t */\n\tpipenum = initpipe();\n\tif (pipenum == -1)\n\t\treturn;\n\n\t/* Parse all of the netlink configuration. */\n\tnl_parse(pipenum, &config);\n\n\t/* Set oom_score_adj. This has to be done before !dumpable because\n\t * /proc/self/oom_score_adj is not writeable unless you're an privileged\n\t * user (if !dumpable is set). All children inherit their parent's\n\t * oom_score_adj value on fork(2) so this will always be propagated\n\t * properly.\n\t */\n\tupdate_oom_score_adj(config.oom_score_adj, config.oom_score_adj_len);\n\n\t/*\n\t * Make the process non-dumpable, to avoid various race conditions that\n\t * could cause processes in namespaces we're joining to access host\n\t * resources (or potentially execute code).\n\t *\n\t * However, if the number of namespaces we are joining is 0, we are not\n\t * going to be switching to a different security context. Thus setting\n\t * ourselves to be non-dumpable only breaks things (like rootless\n\t * containers), which is the recommendation from the kernel folks.\n\t */\n\tif (config.namespaces) {\n\t\tif (prctl(PR_SET_DUMPABLE, 0, 0, 0, 0) < 0)\n\t\t\tbail(\"failed to set process as non-dumpable\");\n\t}\n\n\t/* Pipe so we can tell the child when we've finished setting up. */\n\tif (socketpair(AF_LOCAL, SOCK_STREAM, 0, sync_child_pipe) < 0)\n\t\tbail(\"failed to setup sync pipe between parent and child\");\n\n\t/*\n\t * We need a new socketpair to sync with grandchild so we don't have\n\t * race condition with child.\n\t */\n\tif (socketpair(AF_LOCAL, SOCK_STREAM, 0, sync_grandchild_pipe) < 0)\n\t\tbail(\"failed to setup sync pipe between parent and grandchild\");\n\n\t/* TODO: Currently we aren't dealing with child deaths properly. */\n\n\t/*\n\t * Okay, so this is quite annoying.\n\t *\n\t * In order for this unsharing code to be more extensible we need to split\n\t * up unshare(CLONE_NEWUSER) and clone() in various ways. The ideal case\n\t * would be if we did clone(CLONE_NEWUSER) and the other namespaces\n\t * separately, but because of SELinux issues we cannot really do that. But\n\t * we cannot just dump the namespace flags into clone(...) because several\n\t * usecases (such as rootless containers) require more granularity around\n\t * the namespace setup. In addition, some older kernels had issues where\n\t * CLONE_NEWUSER wasn't handled before other namespaces (but we cannot\n\t * handle this while also dealing with SELinux so we choose SELinux support\n\t * over broken kernel support).\n\t *\n\t * However, if we unshare(2) the user namespace *before* we clone(2), then\n\t * all hell breaks loose.\n\t *\n\t * The parent no longer has permissions to do many things (unshare(2) drops\n\t * all capabilities in your old namespace), and the container cannot be set\n\t * up to have more than one {uid,gid} mapping. This is obviously less than\n\t * ideal. In order to fix this, we have to first clone(2) and then unshare.\n\t *\n\t * Unfortunately, it's not as simple as that. We have to fork to enter the\n\t * PID namespace (the PID namespace only applies to children). Since we'll\n\t * have to double-fork, this clone_parent() call won't be able to get the\n\t * PID of the _actual_ init process (without doing more synchronisation than\n\t * I can deal with at the moment). So we'll just get the parent to send it\n\t * for us, the only job of this process is to update\n\t * /proc/pid/{setgroups,uid_map,gid_map}.\n\t *\n\t * And as a result of the above, we also need to setns(2) in the first child\n\t * because if we join a PID namespace in the topmost parent then our child\n\t * will be in that namespace (and it will not be able to give us a PID value\n\t * that makes sense without resorting to sending things with cmsg).\n\t *\n\t * This also deals with an older issue caused by dumping cloneflags into\n\t * clone(2): On old kernels, CLONE_PARENT didn't work with CLONE_NEWPID, so\n\t * we have to unshare(2) before clone(2) in order to do this. This was fixed\n\t * in upstream commit 1f7f4dde5c945f41a7abc2285be43d918029ecc5, and was\n\t * introduced by 40a0d32d1eaffe6aac7324ca92604b6b3977eb0e. As far as we're\n\t * aware, the last mainline kernel which had this bug was Linux 3.12.\n\t * However, we cannot comment on which kernels the broken patch was\n\t * backported to.\n\t *\n\t * -- Aleksa \"what has my life come to?\" Sarai\n\t */\n\n\tswitch (setjmp(env)) {\n\t\t/*\n\t\t * Stage 0: We're in the parent. Our job is just to create a new child\n\t\t *          (stage 1: JUMP_CHILD) process and write its uid_map and\n\t\t *          gid_map. That process will go on to create a new process, then\n\t\t *          it will send us its PID which we will send to the bootstrap\n\t\t *          process.\n\t\t */\n\tcase JUMP_PARENT:{\n\t\t\tint len;\n\t\t\tpid_t child, first_child = -1;\n\t\t\tbool ready = false;\n\n\t\t\t/* For debugging. */\n\t\t\tprctl(PR_SET_NAME, (unsigned long)\"runc:[0:PARENT]\", 0, 0, 0);\n\n\t\t\t/* Start the process of getting a container. */\n\t\t\tchild = clone_parent(&env, JUMP_CHILD);\n\t\t\tif (child < 0)\n\t\t\t\tbail(\"unable to fork: child_func\");\n\n\t\t\t/*\n\t\t\t * State machine for synchronisation with the children.\n\t\t\t *\n\t\t\t * Father only return when both child and grandchild are\n\t\t\t * ready, so we can receive all possible error codes\n\t\t\t * generated by children.\n\t\t\t */\n\t\t\twhile (!ready) {\n\t\t\t\tenum sync_t s;\n\t\t\t\tint ret;\n\n\t\t\t\tsyncfd = sync_child_pipe[1];\n\t\t\t\tclose(sync_child_pipe[0]);\n\n\t\t\t\tif (read(syncfd, &s, sizeof(s)) != sizeof(s))\n\t\t\t\t\tbail(\"failed to sync with child: next state\");\n\n\t\t\t\tswitch (s) {\n\t\t\t\tcase SYNC_ERR:\n\t\t\t\t\t/* We have to mirror the error code of the child. */\n\t\t\t\t\tif (read(syncfd, &ret, sizeof(ret)) != sizeof(ret))\n\t\t\t\t\t\tbail(\"failed to sync with child: read(error code)\");\n\n\t\t\t\t\texit(ret);\n\t\t\t\tcase SYNC_USERMAP_PLS:\n\t\t\t\t\t/*\n\t\t\t\t\t * Enable setgroups(2) if we've been asked to. But we also\n\t\t\t\t\t * have to explicitly disable setgroups(2) if we're\n\t\t\t\t\t * creating a rootless container for single-entry mapping.\n\t\t\t\t\t * i.e. config.is_setgroup == false.\n\t\t\t\t\t * (this is required since Linux 3.19).\n\t\t\t\t\t *\n\t\t\t\t\t * For rootless multi-entry mapping, config.is_setgroup shall be true and\n\t\t\t\t\t * newuidmap/newgidmap shall be used.\n\t\t\t\t\t */\n\n\t\t\t\t\tif (config.is_rootless_euid && !config.is_setgroup)\n\t\t\t\t\t\tupdate_setgroups(child, SETGROUPS_DENY);\n\n\t\t\t\t\t/* Set up mappings. */\n\t\t\t\t\tupdate_uidmap(config.uidmappath, child, config.uidmap, config.uidmap_len);\n\t\t\t\t\tupdate_gidmap(config.gidmappath, child, config.gidmap, config.gidmap_len);\n\n\t\t\t\t\ts = SYNC_USERMAP_ACK;\n\t\t\t\t\tif (write(syncfd, &s, sizeof(s)) != sizeof(s)) {\n\t\t\t\t\t\tkill(child, SIGKILL);\n\t\t\t\t\t\tbail(\"failed to sync with child: write(SYNC_USERMAP_ACK)\");\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase SYNC_RECVPID_PLS:{\n\t\t\t\t\t\tfirst_child = child;\n\n\t\t\t\t\t\t/* Get the init_func pid. */\n\t\t\t\t\t\tif (read(syncfd, &child, sizeof(child)) != sizeof(child)) {\n\t\t\t\t\t\t\tkill(first_child, SIGKILL);\n\t\t\t\t\t\t\tbail(\"failed to sync with child: read(childpid)\");\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/* Send ACK. */\n\t\t\t\t\t\ts = SYNC_RECVPID_ACK;\n\t\t\t\t\t\tif (write(syncfd, &s, sizeof(s)) != sizeof(s)) {\n\t\t\t\t\t\t\tkill(first_child, SIGKILL);\n\t\t\t\t\t\t\tkill(child, SIGKILL);\n\t\t\t\t\t\t\tbail(\"failed to sync with child: write(SYNC_RECVPID_ACK)\");\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/* Send the init_func pid back to our parent.\n\t\t\t\t\t\t *\n\t\t\t\t\t\t * Send the init_func pid and the pid of the first child back to our parent.\n\t\t\t\t\t\t * We need to send both back because we can't reap the first child we created (CLONE_PARENT).\n\t\t\t\t\t\t * It becomes the responsibility of our parent to reap the first child.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tlen = dprintf(pipenum, \"{\\\"pid\\\": %d, \\\"pid_first\\\": %d}\\n\", child, first_child);\n\t\t\t\t\t\tif (len < 0) {\n\t\t\t\t\t\t\tkill(child, SIGKILL);\n\t\t\t\t\t\t\tbail(\"unable to generate JSON for child pid\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase SYNC_CHILD_READY:\n\t\t\t\t\tready = true;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbail(\"unexpected sync value: %u\", s);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Now sync with grandchild. */\n\n\t\t\tready = false;\n\t\t\twhile (!ready) {\n\t\t\t\tenum sync_t s;\n\t\t\t\tint ret;\n\n\t\t\t\tsyncfd = sync_grandchild_pipe[1];\n\t\t\t\tclose(sync_grandchild_pipe[0]);\n\n\t\t\t\ts = SYNC_GRANDCHILD;\n\t\t\t\tif (write(syncfd, &s, sizeof(s)) != sizeof(s)) {\n\t\t\t\t\tkill(child, SIGKILL);\n\t\t\t\t\tbail(\"failed to sync with child: write(SYNC_GRANDCHILD)\");\n\t\t\t\t}\n\n\t\t\t\tif (read(syncfd, &s, sizeof(s)) != sizeof(s))\n\t\t\t\t\tbail(\"failed to sync with child: next state\");\n\n\t\t\t\tswitch (s) {\n\t\t\t\tcase SYNC_ERR:\n\t\t\t\t\t/* We have to mirror the error code of the child. */\n\t\t\t\t\tif (read(syncfd, &ret, sizeof(ret)) != sizeof(ret))\n\t\t\t\t\t\tbail(\"failed to sync with child: read(error code)\");\n\n\t\t\t\t\texit(ret);\n\t\t\t\tcase SYNC_CHILD_READY:\n\t\t\t\t\tready = true;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbail(\"unexpected sync value: %u\", s);\n\t\t\t\t}\n\t\t\t}\n\t\t\texit(0);\n\t\t}\n\n\t\t/*\n\t\t * Stage 1: We're in the first child process. Our job is to join any\n\t\t *          provided namespaces in the netlink payload and unshare all\n\t\t *          of the requested namespaces. If we've been asked to\n\t\t *          CLONE_NEWUSER, we will ask our parent (stage 0) to set up\n\t\t *          our user mappings for us. Then, we create a new child\n\t\t *          (stage 2: JUMP_INIT) for PID namespace. We then send the\n\t\t *          child's PID to our parent (stage 0).\n\t\t */\n\tcase JUMP_CHILD:{\n\t\t\tpid_t child;\n\t\t\tenum sync_t s;\n\n\t\t\t/* We're in a child and thus need to tell the parent if we die. */\n\t\t\tsyncfd = sync_child_pipe[0];\n\t\t\tclose(sync_child_pipe[1]);\n\n\t\t\t/* For debugging. */\n\t\t\tprctl(PR_SET_NAME, (unsigned long)\"runc:[1:CHILD]\", 0, 0, 0);\n\n\t\t\t/*\n\t\t\t * We need to setns first. We cannot do this earlier (in stage 0)\n\t\t\t * because of the fact that we forked to get here (the PID of\n\t\t\t * [stage 2: JUMP_INIT]) would be meaningless). We could send it\n\t\t\t * using cmsg(3) but that's just annoying.\n\t\t\t */\n\t\t\tif (config.namespaces)\n\t\t\t\tjoin_namespaces(config.namespaces);\n\n\t\t\t/*\n\t\t\t * Deal with user namespaces first. They are quite special, as they\n\t\t\t * affect our ability to unshare other namespaces and are used as\n\t\t\t * context for privilege checks.\n\t\t\t *\n\t\t\t * We don't unshare all namespaces in one go. The reason for this\n\t\t\t * is that, while the kernel documentation may claim otherwise,\n\t\t\t * there are certain cases where unsharing all namespaces at once\n\t\t\t * will result in namespace objects being owned incorrectly.\n\t\t\t * Ideally we should just fix these kernel bugs, but it's better to\n\t\t\t * be safe than sorry, and fix them separately.\n\t\t\t *\n\t\t\t * A specific case of this is that the SELinux label of the\n\t\t\t * internal kern-mount that mqueue uses will be incorrect if the\n\t\t\t * UTS namespace is cloned before the USER namespace is mapped.\n\t\t\t * I've also heard of similar problems with the network namespace\n\t\t\t * in some scenarios. This also mirrors how LXC deals with this\n\t\t\t * problem.\n\t\t\t */\n\t\t\tif (config.cloneflags & CLONE_NEWUSER) {\n\t\t\t\tif (unshare(CLONE_NEWUSER) < 0)\n\t\t\t\t\tbail(\"failed to unshare user namespace\");\n\t\t\t\tconfig.cloneflags &= ~CLONE_NEWUSER;\n\n\t\t\t\t/*\n\t\t\t\t * We don't have the privileges to do any mapping here (see the\n\t\t\t\t * clone_parent rant). So signal our parent to hook us up.\n\t\t\t\t */\n\n\t\t\t\t/* Switching is only necessary if we joined namespaces. */\n\t\t\t\tif (config.namespaces) {\n\t\t\t\t\tif (prctl(PR_SET_DUMPABLE, 1, 0, 0, 0) < 0)\n\t\t\t\t\t\tbail(\"failed to set process as dumpable\");\n\t\t\t\t}\n\t\t\t\ts = SYNC_USERMAP_PLS;\n\t\t\t\tif (write(syncfd, &s, sizeof(s)) != sizeof(s))\n\t\t\t\t\tbail(\"failed to sync with parent: write(SYNC_USERMAP_PLS)\");\n\n\t\t\t\t/* ... wait for mapping ... */\n\n\t\t\t\tif (read(syncfd, &s, sizeof(s)) != sizeof(s))\n\t\t\t\t\tbail(\"failed to sync with parent: read(SYNC_USERMAP_ACK)\");\n\t\t\t\tif (s != SYNC_USERMAP_ACK)\n\t\t\t\t\tbail(\"failed to sync with parent: SYNC_USERMAP_ACK: got %u\", s);\n\t\t\t\t/* Switching is only necessary if we joined namespaces. */\n\t\t\t\tif (config.namespaces) {\n\t\t\t\t\tif (prctl(PR_SET_DUMPABLE, 0, 0, 0, 0) < 0)\n\t\t\t\t\t\tbail(\"failed to set process as dumpable\");\n\t\t\t\t}\n\n\t\t\t\t/* Become root in the namespace proper. */\n\t\t\t\tif (setresuid(0, 0, 0) < 0)\n\t\t\t\t\tbail(\"failed to become root in user namespace\");\n\t\t\t}\n\t\t\t/*\n\t\t\t * Unshare all of the namespaces. Now, it should be noted that this\n\t\t\t * ordering might break in the future (especially with rootless\n\t\t\t * containers). But for now, it's not possible to split this into\n\t\t\t * CLONE_NEWUSER + [the rest] because of some RHEL SELinux issues.\n\t\t\t *\n\t\t\t * Note that we don't merge this with clone() because there were\n\t\t\t * some old kernel versions where clone(CLONE_PARENT | CLONE_NEWPID)\n\t\t\t * was broken, so we'll just do it the long way anyway.\n\t\t\t */\n\t\t\tif (unshare(config.cloneflags & ~CLONE_NEWCGROUP) < 0)\n\t\t\t\tbail(\"failed to unshare namespaces\");\n\n\t\t\t/*\n\t\t\t * TODO: What about non-namespace clone flags that we're dropping here?\n\t\t\t *\n\t\t\t * We fork again because of PID namespace, setns(2) or unshare(2) don't\n\t\t\t * change the PID namespace of the calling process, because doing so\n\t\t\t * would change the caller's idea of its own PID (as reported by getpid()),\n\t\t\t * which would break many applications and libraries, so we must fork\n\t\t\t * to actually enter the new PID namespace.\n\t\t\t */\n\t\t\tchild = clone_parent(&env, JUMP_INIT);\n\t\t\tif (child < 0)\n\t\t\t\tbail(\"unable to fork: init_func\");\n\n\t\t\t/* Send the child to our parent, which knows what it's doing. */\n\t\t\ts = SYNC_RECVPID_PLS;\n\t\t\tif (write(syncfd, &s, sizeof(s)) != sizeof(s)) {\n\t\t\t\tkill(child, SIGKILL);\n\t\t\t\tbail(\"failed to sync with parent: write(SYNC_RECVPID_PLS)\");\n\t\t\t}\n\t\t\tif (write(syncfd, &child, sizeof(child)) != sizeof(child)) {\n\t\t\t\tkill(child, SIGKILL);\n\t\t\t\tbail(\"failed to sync with parent: write(childpid)\");\n\t\t\t}\n\n\t\t\t/* ... wait for parent to get the pid ... */\n\n\t\t\tif (read(syncfd, &s, sizeof(s)) != sizeof(s)) {\n\t\t\t\tkill(child, SIGKILL);\n\t\t\t\tbail(\"failed to sync with parent: read(SYNC_RECVPID_ACK)\");\n\t\t\t}\n\t\t\tif (s != SYNC_RECVPID_ACK) {\n\t\t\t\tkill(child, SIGKILL);\n\t\t\t\tbail(\"failed to sync with parent: SYNC_RECVPID_ACK: got %u\", s);\n\t\t\t}\n\n\t\t\ts = SYNC_CHILD_READY;\n\t\t\tif (write(syncfd, &s, sizeof(s)) != sizeof(s)) {\n\t\t\t\tkill(child, SIGKILL);\n\t\t\t\tbail(\"failed to sync with parent: write(SYNC_CHILD_READY)\");\n\t\t\t}\n\n\t\t\t/* Our work is done. [Stage 2: JUMP_INIT] is doing the rest of the work. */\n\t\t\texit(0);\n\t\t}\n\n\t\t/*\n\t\t * Stage 2: We're the final child process, and the only process that will\n\t\t *          actually return to the Go runtime. Our job is to just do the\n\t\t *          final cleanup steps and then return to the Go runtime to allow\n\t\t *          init_linux.go to run.\n\t\t */\n\tcase JUMP_INIT:{\n\t\t\t/*\n\t\t\t * We're inside the child now, having jumped from the\n\t\t\t * start_child() code after forking in the parent.\n\t\t\t */\n\t\t\tenum sync_t s;\n\n\t\t\t/* We're in a child and thus need to tell the parent if we die. */\n\t\t\tsyncfd = sync_grandchild_pipe[0];\n\t\t\tclose(sync_grandchild_pipe[1]);\n\t\t\tclose(sync_child_pipe[0]);\n\t\t\tclose(sync_child_pipe[1]);\n\n\t\t\t/* For debugging. */\n\t\t\tprctl(PR_SET_NAME, (unsigned long)\"runc:[2:INIT]\", 0, 0, 0);\n\n\t\t\tif (read(syncfd, &s, sizeof(s)) != sizeof(s))\n\t\t\t\tbail(\"failed to sync with parent: read(SYNC_GRANDCHILD)\");\n\t\t\tif (s != SYNC_GRANDCHILD)\n\t\t\t\tbail(\"failed to sync with parent: SYNC_GRANDCHILD: got %u\", s);\n\n\t\t\tif (setsid() < 0)\n\t\t\t\tbail(\"setsid failed\");\n\n\t\t\tif (setuid(0) < 0)\n\t\t\t\tbail(\"setuid failed\");\n\n\t\t\tif (setgid(0) < 0)\n\t\t\t\tbail(\"setgid failed\");\n\n\t\t\tif (!config.is_rootless_euid && config.is_setgroup) {\n\t\t\t\tif (setgroups(0, NULL) < 0)\n\t\t\t\t\tbail(\"setgroups failed\");\n\t\t\t}\n\n\t\t\t/* ... wait until our topmost parent has finished cgroup setup in p.manager.Apply() ... */\n\t\t\tif (config.cloneflags & CLONE_NEWCGROUP) {\n\t\t\t\tuint8_t value;\n\t\t\t\tif (read(pipenum, &value, sizeof(value)) != sizeof(value))\n\t\t\t\t\tbail(\"read synchronisation value failed\");\n\t\t\t\tif (value == CREATECGROUPNS) {\n\t\t\t\t\tif (unshare(CLONE_NEWCGROUP) < 0)\n\t\t\t\t\t\tbail(\"failed to unshare cgroup namespace\");\n\t\t\t\t} else\n\t\t\t\t\tbail(\"received unknown synchronisation value\");\n\t\t\t}\n\n\t\t\ts = SYNC_CHILD_READY;\n\t\t\tif (write(syncfd, &s, sizeof(s)) != sizeof(s))\n\t\t\t\tbail(\"failed to sync with patent: write(SYNC_CHILD_READY)\");\n\n\t\t\t/* Close sync pipes. */\n\t\t\tclose(sync_grandchild_pipe[0]);\n\n\t\t\t/* Free netlink data. */\n\t\t\tnl_free(&config);\n\n\t\t\t/* Finish executing, let the Go runtime take over. */\n\t\t\treturn;\n\t\t}\n\tdefault:\n\t\tbail(\"unexpected jump value\");\n\t}\n\n\t/* Should never be reached. */\n\tbail(\"should never be reached\");\n}",
        "func": "void nsexec(void)\n{\n\tint pipenum;\n\tjmp_buf env;\n\tint sync_child_pipe[2], sync_grandchild_pipe[2];\n\tstruct nlconfig_t config = { 0 };\n\n\t/*\n\t * If we don't have an init pipe, just return to the go routine.\n\t * We'll only get an init pipe for start or exec.\n\t */\n\tpipenum = initpipe();\n\tif (pipenum == -1)\n\t\treturn;\n\n\t/*\n\t * We need to re-exec if we are not in a cloned binary. This is necessary\n\t * to ensure that containers won't be able to access the host binary\n\t * through /proc/self/exe. See CVE-2019-5736.\n\t */\n\tif (ensure_cloned_binary() < 0)\n\t\tbail(\"could not ensure we are a cloned binary\");\n\n\t/* Parse all of the netlink configuration. */\n\tnl_parse(pipenum, &config);\n\n\t/* Set oom_score_adj. This has to be done before !dumpable because\n\t * /proc/self/oom_score_adj is not writeable unless you're an privileged\n\t * user (if !dumpable is set). All children inherit their parent's\n\t * oom_score_adj value on fork(2) so this will always be propagated\n\t * properly.\n\t */\n\tupdate_oom_score_adj(config.oom_score_adj, config.oom_score_adj_len);\n\n\t/*\n\t * Make the process non-dumpable, to avoid various race conditions that\n\t * could cause processes in namespaces we're joining to access host\n\t * resources (or potentially execute code).\n\t *\n\t * However, if the number of namespaces we are joining is 0, we are not\n\t * going to be switching to a different security context. Thus setting\n\t * ourselves to be non-dumpable only breaks things (like rootless\n\t * containers), which is the recommendation from the kernel folks.\n\t */\n\tif (config.namespaces) {\n\t\tif (prctl(PR_SET_DUMPABLE, 0, 0, 0, 0) < 0)\n\t\t\tbail(\"failed to set process as non-dumpable\");\n\t}\n\n\t/* Pipe so we can tell the child when we've finished setting up. */\n\tif (socketpair(AF_LOCAL, SOCK_STREAM, 0, sync_child_pipe) < 0)\n\t\tbail(\"failed to setup sync pipe between parent and child\");\n\n\t/*\n\t * We need a new socketpair to sync with grandchild so we don't have\n\t * race condition with child.\n\t */\n\tif (socketpair(AF_LOCAL, SOCK_STREAM, 0, sync_grandchild_pipe) < 0)\n\t\tbail(\"failed to setup sync pipe between parent and grandchild\");\n\n\t/* TODO: Currently we aren't dealing with child deaths properly. */\n\n\t/*\n\t * Okay, so this is quite annoying.\n\t *\n\t * In order for this unsharing code to be more extensible we need to split\n\t * up unshare(CLONE_NEWUSER) and clone() in various ways. The ideal case\n\t * would be if we did clone(CLONE_NEWUSER) and the other namespaces\n\t * separately, but because of SELinux issues we cannot really do that. But\n\t * we cannot just dump the namespace flags into clone(...) because several\n\t * usecases (such as rootless containers) require more granularity around\n\t * the namespace setup. In addition, some older kernels had issues where\n\t * CLONE_NEWUSER wasn't handled before other namespaces (but we cannot\n\t * handle this while also dealing with SELinux so we choose SELinux support\n\t * over broken kernel support).\n\t *\n\t * However, if we unshare(2) the user namespace *before* we clone(2), then\n\t * all hell breaks loose.\n\t *\n\t * The parent no longer has permissions to do many things (unshare(2) drops\n\t * all capabilities in your old namespace), and the container cannot be set\n\t * up to have more than one {uid,gid} mapping. This is obviously less than\n\t * ideal. In order to fix this, we have to first clone(2) and then unshare.\n\t *\n\t * Unfortunately, it's not as simple as that. We have to fork to enter the\n\t * PID namespace (the PID namespace only applies to children). Since we'll\n\t * have to double-fork, this clone_parent() call won't be able to get the\n\t * PID of the _actual_ init process (without doing more synchronisation than\n\t * I can deal with at the moment). So we'll just get the parent to send it\n\t * for us, the only job of this process is to update\n\t * /proc/pid/{setgroups,uid_map,gid_map}.\n\t *\n\t * And as a result of the above, we also need to setns(2) in the first child\n\t * because if we join a PID namespace in the topmost parent then our child\n\t * will be in that namespace (and it will not be able to give us a PID value\n\t * that makes sense without resorting to sending things with cmsg).\n\t *\n\t * This also deals with an older issue caused by dumping cloneflags into\n\t * clone(2): On old kernels, CLONE_PARENT didn't work with CLONE_NEWPID, so\n\t * we have to unshare(2) before clone(2) in order to do this. This was fixed\n\t * in upstream commit 1f7f4dde5c945f41a7abc2285be43d918029ecc5, and was\n\t * introduced by 40a0d32d1eaffe6aac7324ca92604b6b3977eb0e. As far as we're\n\t * aware, the last mainline kernel which had this bug was Linux 3.12.\n\t * However, we cannot comment on which kernels the broken patch was\n\t * backported to.\n\t *\n\t * -- Aleksa \"what has my life come to?\" Sarai\n\t */\n\n\tswitch (setjmp(env)) {\n\t\t/*\n\t\t * Stage 0: We're in the parent. Our job is just to create a new child\n\t\t *          (stage 1: JUMP_CHILD) process and write its uid_map and\n\t\t *          gid_map. That process will go on to create a new process, then\n\t\t *          it will send us its PID which we will send to the bootstrap\n\t\t *          process.\n\t\t */\n\tcase JUMP_PARENT:{\n\t\t\tint len;\n\t\t\tpid_t child, first_child = -1;\n\t\t\tbool ready = false;\n\n\t\t\t/* For debugging. */\n\t\t\tprctl(PR_SET_NAME, (unsigned long)\"runc:[0:PARENT]\", 0, 0, 0);\n\n\t\t\t/* Start the process of getting a container. */\n\t\t\tchild = clone_parent(&env, JUMP_CHILD);\n\t\t\tif (child < 0)\n\t\t\t\tbail(\"unable to fork: child_func\");\n\n\t\t\t/*\n\t\t\t * State machine for synchronisation with the children.\n\t\t\t *\n\t\t\t * Father only return when both child and grandchild are\n\t\t\t * ready, so we can receive all possible error codes\n\t\t\t * generated by children.\n\t\t\t */\n\t\t\twhile (!ready) {\n\t\t\t\tenum sync_t s;\n\t\t\t\tint ret;\n\n\t\t\t\tsyncfd = sync_child_pipe[1];\n\t\t\t\tclose(sync_child_pipe[0]);\n\n\t\t\t\tif (read(syncfd, &s, sizeof(s)) != sizeof(s))\n\t\t\t\t\tbail(\"failed to sync with child: next state\");\n\n\t\t\t\tswitch (s) {\n\t\t\t\tcase SYNC_ERR:\n\t\t\t\t\t/* We have to mirror the error code of the child. */\n\t\t\t\t\tif (read(syncfd, &ret, sizeof(ret)) != sizeof(ret))\n\t\t\t\t\t\tbail(\"failed to sync with child: read(error code)\");\n\n\t\t\t\t\texit(ret);\n\t\t\t\tcase SYNC_USERMAP_PLS:\n\t\t\t\t\t/*\n\t\t\t\t\t * Enable setgroups(2) if we've been asked to. But we also\n\t\t\t\t\t * have to explicitly disable setgroups(2) if we're\n\t\t\t\t\t * creating a rootless container for single-entry mapping.\n\t\t\t\t\t * i.e. config.is_setgroup == false.\n\t\t\t\t\t * (this is required since Linux 3.19).\n\t\t\t\t\t *\n\t\t\t\t\t * For rootless multi-entry mapping, config.is_setgroup shall be true and\n\t\t\t\t\t * newuidmap/newgidmap shall be used.\n\t\t\t\t\t */\n\n\t\t\t\t\tif (config.is_rootless_euid && !config.is_setgroup)\n\t\t\t\t\t\tupdate_setgroups(child, SETGROUPS_DENY);\n\n\t\t\t\t\t/* Set up mappings. */\n\t\t\t\t\tupdate_uidmap(config.uidmappath, child, config.uidmap, config.uidmap_len);\n\t\t\t\t\tupdate_gidmap(config.gidmappath, child, config.gidmap, config.gidmap_len);\n\n\t\t\t\t\ts = SYNC_USERMAP_ACK;\n\t\t\t\t\tif (write(syncfd, &s, sizeof(s)) != sizeof(s)) {\n\t\t\t\t\t\tkill(child, SIGKILL);\n\t\t\t\t\t\tbail(\"failed to sync with child: write(SYNC_USERMAP_ACK)\");\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase SYNC_RECVPID_PLS:{\n\t\t\t\t\t\tfirst_child = child;\n\n\t\t\t\t\t\t/* Get the init_func pid. */\n\t\t\t\t\t\tif (read(syncfd, &child, sizeof(child)) != sizeof(child)) {\n\t\t\t\t\t\t\tkill(first_child, SIGKILL);\n\t\t\t\t\t\t\tbail(\"failed to sync with child: read(childpid)\");\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/* Send ACK. */\n\t\t\t\t\t\ts = SYNC_RECVPID_ACK;\n\t\t\t\t\t\tif (write(syncfd, &s, sizeof(s)) != sizeof(s)) {\n\t\t\t\t\t\t\tkill(first_child, SIGKILL);\n\t\t\t\t\t\t\tkill(child, SIGKILL);\n\t\t\t\t\t\t\tbail(\"failed to sync with child: write(SYNC_RECVPID_ACK)\");\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t/* Send the init_func pid back to our parent.\n\t\t\t\t\t\t *\n\t\t\t\t\t\t * Send the init_func pid and the pid of the first child back to our parent.\n\t\t\t\t\t\t * We need to send both back because we can't reap the first child we created (CLONE_PARENT).\n\t\t\t\t\t\t * It becomes the responsibility of our parent to reap the first child.\n\t\t\t\t\t\t */\n\t\t\t\t\t\tlen = dprintf(pipenum, \"{\\\"pid\\\": %d, \\\"pid_first\\\": %d}\\n\", child, first_child);\n\t\t\t\t\t\tif (len < 0) {\n\t\t\t\t\t\t\tkill(child, SIGKILL);\n\t\t\t\t\t\t\tbail(\"unable to generate JSON for child pid\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase SYNC_CHILD_READY:\n\t\t\t\t\tready = true;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbail(\"unexpected sync value: %u\", s);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* Now sync with grandchild. */\n\n\t\t\tready = false;\n\t\t\twhile (!ready) {\n\t\t\t\tenum sync_t s;\n\t\t\t\tint ret;\n\n\t\t\t\tsyncfd = sync_grandchild_pipe[1];\n\t\t\t\tclose(sync_grandchild_pipe[0]);\n\n\t\t\t\ts = SYNC_GRANDCHILD;\n\t\t\t\tif (write(syncfd, &s, sizeof(s)) != sizeof(s)) {\n\t\t\t\t\tkill(child, SIGKILL);\n\t\t\t\t\tbail(\"failed to sync with child: write(SYNC_GRANDCHILD)\");\n\t\t\t\t}\n\n\t\t\t\tif (read(syncfd, &s, sizeof(s)) != sizeof(s))\n\t\t\t\t\tbail(\"failed to sync with child: next state\");\n\n\t\t\t\tswitch (s) {\n\t\t\t\tcase SYNC_ERR:\n\t\t\t\t\t/* We have to mirror the error code of the child. */\n\t\t\t\t\tif (read(syncfd, &ret, sizeof(ret)) != sizeof(ret))\n\t\t\t\t\t\tbail(\"failed to sync with child: read(error code)\");\n\n\t\t\t\t\texit(ret);\n\t\t\t\tcase SYNC_CHILD_READY:\n\t\t\t\t\tready = true;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbail(\"unexpected sync value: %u\", s);\n\t\t\t\t}\n\t\t\t}\n\t\t\texit(0);\n\t\t}\n\n\t\t/*\n\t\t * Stage 1: We're in the first child process. Our job is to join any\n\t\t *          provided namespaces in the netlink payload and unshare all\n\t\t *          of the requested namespaces. If we've been asked to\n\t\t *          CLONE_NEWUSER, we will ask our parent (stage 0) to set up\n\t\t *          our user mappings for us. Then, we create a new child\n\t\t *          (stage 2: JUMP_INIT) for PID namespace. We then send the\n\t\t *          child's PID to our parent (stage 0).\n\t\t */\n\tcase JUMP_CHILD:{\n\t\t\tpid_t child;\n\t\t\tenum sync_t s;\n\n\t\t\t/* We're in a child and thus need to tell the parent if we die. */\n\t\t\tsyncfd = sync_child_pipe[0];\n\t\t\tclose(sync_child_pipe[1]);\n\n\t\t\t/* For debugging. */\n\t\t\tprctl(PR_SET_NAME, (unsigned long)\"runc:[1:CHILD]\", 0, 0, 0);\n\n\t\t\t/*\n\t\t\t * We need to setns first. We cannot do this earlier (in stage 0)\n\t\t\t * because of the fact that we forked to get here (the PID of\n\t\t\t * [stage 2: JUMP_INIT]) would be meaningless). We could send it\n\t\t\t * using cmsg(3) but that's just annoying.\n\t\t\t */\n\t\t\tif (config.namespaces)\n\t\t\t\tjoin_namespaces(config.namespaces);\n\n\t\t\t/*\n\t\t\t * Deal with user namespaces first. They are quite special, as they\n\t\t\t * affect our ability to unshare other namespaces and are used as\n\t\t\t * context for privilege checks.\n\t\t\t *\n\t\t\t * We don't unshare all namespaces in one go. The reason for this\n\t\t\t * is that, while the kernel documentation may claim otherwise,\n\t\t\t * there are certain cases where unsharing all namespaces at once\n\t\t\t * will result in namespace objects being owned incorrectly.\n\t\t\t * Ideally we should just fix these kernel bugs, but it's better to\n\t\t\t * be safe than sorry, and fix them separately.\n\t\t\t *\n\t\t\t * A specific case of this is that the SELinux label of the\n\t\t\t * internal kern-mount that mqueue uses will be incorrect if the\n\t\t\t * UTS namespace is cloned before the USER namespace is mapped.\n\t\t\t * I've also heard of similar problems with the network namespace\n\t\t\t * in some scenarios. This also mirrors how LXC deals with this\n\t\t\t * problem.\n\t\t\t */\n\t\t\tif (config.cloneflags & CLONE_NEWUSER) {\n\t\t\t\tif (unshare(CLONE_NEWUSER) < 0)\n\t\t\t\t\tbail(\"failed to unshare user namespace\");\n\t\t\t\tconfig.cloneflags &= ~CLONE_NEWUSER;\n\n\t\t\t\t/*\n\t\t\t\t * We don't have the privileges to do any mapping here (see the\n\t\t\t\t * clone_parent rant). So signal our parent to hook us up.\n\t\t\t\t */\n\n\t\t\t\t/* Switching is only necessary if we joined namespaces. */\n\t\t\t\tif (config.namespaces) {\n\t\t\t\t\tif (prctl(PR_SET_DUMPABLE, 1, 0, 0, 0) < 0)\n\t\t\t\t\t\tbail(\"failed to set process as dumpable\");\n\t\t\t\t}\n\t\t\t\ts = SYNC_USERMAP_PLS;\n\t\t\t\tif (write(syncfd, &s, sizeof(s)) != sizeof(s))\n\t\t\t\t\tbail(\"failed to sync with parent: write(SYNC_USERMAP_PLS)\");\n\n\t\t\t\t/* ... wait for mapping ... */\n\n\t\t\t\tif (read(syncfd, &s, sizeof(s)) != sizeof(s))\n\t\t\t\t\tbail(\"failed to sync with parent: read(SYNC_USERMAP_ACK)\");\n\t\t\t\tif (s != SYNC_USERMAP_ACK)\n\t\t\t\t\tbail(\"failed to sync with parent: SYNC_USERMAP_ACK: got %u\", s);\n\t\t\t\t/* Switching is only necessary if we joined namespaces. */\n\t\t\t\tif (config.namespaces) {\n\t\t\t\t\tif (prctl(PR_SET_DUMPABLE, 0, 0, 0, 0) < 0)\n\t\t\t\t\t\tbail(\"failed to set process as dumpable\");\n\t\t\t\t}\n\n\t\t\t\t/* Become root in the namespace proper. */\n\t\t\t\tif (setresuid(0, 0, 0) < 0)\n\t\t\t\t\tbail(\"failed to become root in user namespace\");\n\t\t\t}\n\t\t\t/*\n\t\t\t * Unshare all of the namespaces. Now, it should be noted that this\n\t\t\t * ordering might break in the future (especially with rootless\n\t\t\t * containers). But for now, it's not possible to split this into\n\t\t\t * CLONE_NEWUSER + [the rest] because of some RHEL SELinux issues.\n\t\t\t *\n\t\t\t * Note that we don't merge this with clone() because there were\n\t\t\t * some old kernel versions where clone(CLONE_PARENT | CLONE_NEWPID)\n\t\t\t * was broken, so we'll just do it the long way anyway.\n\t\t\t */\n\t\t\tif (unshare(config.cloneflags & ~CLONE_NEWCGROUP) < 0)\n\t\t\t\tbail(\"failed to unshare namespaces\");\n\n\t\t\t/*\n\t\t\t * TODO: What about non-namespace clone flags that we're dropping here?\n\t\t\t *\n\t\t\t * We fork again because of PID namespace, setns(2) or unshare(2) don't\n\t\t\t * change the PID namespace of the calling process, because doing so\n\t\t\t * would change the caller's idea of its own PID (as reported by getpid()),\n\t\t\t * which would break many applications and libraries, so we must fork\n\t\t\t * to actually enter the new PID namespace.\n\t\t\t */\n\t\t\tchild = clone_parent(&env, JUMP_INIT);\n\t\t\tif (child < 0)\n\t\t\t\tbail(\"unable to fork: init_func\");\n\n\t\t\t/* Send the child to our parent, which knows what it's doing. */\n\t\t\ts = SYNC_RECVPID_PLS;\n\t\t\tif (write(syncfd, &s, sizeof(s)) != sizeof(s)) {\n\t\t\t\tkill(child, SIGKILL);\n\t\t\t\tbail(\"failed to sync with parent: write(SYNC_RECVPID_PLS)\");\n\t\t\t}\n\t\t\tif (write(syncfd, &child, sizeof(child)) != sizeof(child)) {\n\t\t\t\tkill(child, SIGKILL);\n\t\t\t\tbail(\"failed to sync with parent: write(childpid)\");\n\t\t\t}\n\n\t\t\t/* ... wait for parent to get the pid ... */\n\n\t\t\tif (read(syncfd, &s, sizeof(s)) != sizeof(s)) {\n\t\t\t\tkill(child, SIGKILL);\n\t\t\t\tbail(\"failed to sync with parent: read(SYNC_RECVPID_ACK)\");\n\t\t\t}\n\t\t\tif (s != SYNC_RECVPID_ACK) {\n\t\t\t\tkill(child, SIGKILL);\n\t\t\t\tbail(\"failed to sync with parent: SYNC_RECVPID_ACK: got %u\", s);\n\t\t\t}\n\n\t\t\ts = SYNC_CHILD_READY;\n\t\t\tif (write(syncfd, &s, sizeof(s)) != sizeof(s)) {\n\t\t\t\tkill(child, SIGKILL);\n\t\t\t\tbail(\"failed to sync with parent: write(SYNC_CHILD_READY)\");\n\t\t\t}\n\n\t\t\t/* Our work is done. [Stage 2: JUMP_INIT] is doing the rest of the work. */\n\t\t\texit(0);\n\t\t}\n\n\t\t/*\n\t\t * Stage 2: We're the final child process, and the only process that will\n\t\t *          actually return to the Go runtime. Our job is to just do the\n\t\t *          final cleanup steps and then return to the Go runtime to allow\n\t\t *          init_linux.go to run.\n\t\t */\n\tcase JUMP_INIT:{\n\t\t\t/*\n\t\t\t * We're inside the child now, having jumped from the\n\t\t\t * start_child() code after forking in the parent.\n\t\t\t */\n\t\t\tenum sync_t s;\n\n\t\t\t/* We're in a child and thus need to tell the parent if we die. */\n\t\t\tsyncfd = sync_grandchild_pipe[0];\n\t\t\tclose(sync_grandchild_pipe[1]);\n\t\t\tclose(sync_child_pipe[0]);\n\t\t\tclose(sync_child_pipe[1]);\n\n\t\t\t/* For debugging. */\n\t\t\tprctl(PR_SET_NAME, (unsigned long)\"runc:[2:INIT]\", 0, 0, 0);\n\n\t\t\tif (read(syncfd, &s, sizeof(s)) != sizeof(s))\n\t\t\t\tbail(\"failed to sync with parent: read(SYNC_GRANDCHILD)\");\n\t\t\tif (s != SYNC_GRANDCHILD)\n\t\t\t\tbail(\"failed to sync with parent: SYNC_GRANDCHILD: got %u\", s);\n\n\t\t\tif (setsid() < 0)\n\t\t\t\tbail(\"setsid failed\");\n\n\t\t\tif (setuid(0) < 0)\n\t\t\t\tbail(\"setuid failed\");\n\n\t\t\tif (setgid(0) < 0)\n\t\t\t\tbail(\"setgid failed\");\n\n\t\t\tif (!config.is_rootless_euid && config.is_setgroup) {\n\t\t\t\tif (setgroups(0, NULL) < 0)\n\t\t\t\t\tbail(\"setgroups failed\");\n\t\t\t}\n\n\t\t\t/* ... wait until our topmost parent has finished cgroup setup in p.manager.Apply() ... */\n\t\t\tif (config.cloneflags & CLONE_NEWCGROUP) {\n\t\t\t\tuint8_t value;\n\t\t\t\tif (read(pipenum, &value, sizeof(value)) != sizeof(value))\n\t\t\t\t\tbail(\"read synchronisation value failed\");\n\t\t\t\tif (value == CREATECGROUPNS) {\n\t\t\t\t\tif (unshare(CLONE_NEWCGROUP) < 0)\n\t\t\t\t\t\tbail(\"failed to unshare cgroup namespace\");\n\t\t\t\t} else\n\t\t\t\t\tbail(\"received unknown synchronisation value\");\n\t\t\t}\n\n\t\t\ts = SYNC_CHILD_READY;\n\t\t\tif (write(syncfd, &s, sizeof(s)) != sizeof(s))\n\t\t\t\tbail(\"failed to sync with patent: write(SYNC_CHILD_READY)\");\n\n\t\t\t/* Close sync pipes. */\n\t\t\tclose(sync_grandchild_pipe[0]);\n\n\t\t\t/* Free netlink data. */\n\t\t\tnl_free(&config);\n\n\t\t\t/* Finish executing, let the Go runtime take over. */\n\t\t\treturn;\n\t\t}\n\tdefault:\n\t\tbail(\"unexpected jump value\");\n\t}\n\n\t/* Should never be reached. */\n\tbail(\"should never be reached\");\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -12,6 +12,14 @@\n \tpipenum = initpipe();\n \tif (pipenum == -1)\n \t\treturn;\n+\n+\t/*\n+\t * We need to re-exec if we are not in a cloned binary. This is necessary\n+\t * to ensure that containers won't be able to access the host binary\n+\t * through /proc/self/exe. See CVE-2019-5736.\n+\t */\n+\tif (ensure_cloned_binary() < 0)\n+\t\tbail(\"could not ensure we are a cloned binary\");\n \n \t/* Parse all of the netlink configuration. */\n \tnl_parse(pipenum, &config);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "\t/*",
                "\t * We need to re-exec if we are not in a cloned binary. This is necessary",
                "\t * to ensure that containers won't be able to access the host binary",
                "\t * through /proc/self/exe. See CVE-2019-5736.",
                "\t */",
                "\tif (ensure_cloned_binary() < 0)",
                "\t\tbail(\"could not ensure we are a cloned binary\");"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-1000203",
        "func_name": "root-project/root/RootdExpandPathName",
        "description": "ROOT version 6.9.03 and below is vulnerable to an authenticated shell metacharacter injection in the rootd daemon resulting in remote code execution",
        "git_url": "https://github.com/root-project/root/commit/88ccff152604e0f1012653a596d802ff7ede3145",
        "commit_title": "rootd: do not use popen() to expand path names (#513)",
        "commit_text": " Addressed security threat reported by S. Luders.\r Using the same technology used in TSystem::ExpandFileName (with clang-format processing).",
        "func_before": "char *RootdExpandPathName(const char *name)\n{\n   const char *patbuf = name;\n\n   // skip leading blanks\n   while (*patbuf == ' ')\n      patbuf++;\n\n   // any shell meta characters?\n   for (const char *p = patbuf; *p; p++)\n      if (strchr(shellMeta, *p))\n         goto needshell;\n\n   return strdup(name);\n\nneedshell:\n   // escape shell quote characters\n   char escPatbuf[kMAXPATHLEN];\n   EscChar(patbuf, escPatbuf, sizeof(escPatbuf), shellStuff, shellEscape);\n\n   char cmd[kMAXPATHLEN];\n#ifdef __hpux\n   strlcpy(cmd, \"/bin/echo \", sizeof(cmd));\n#else\n   strlcpy(cmd, \"echo \", sizeof(cmd));\n#endif\n\n   // emulate csh -> popen executes sh\n   if (escPatbuf[0] == '~') {\n      const char *hd;\n      if (escPatbuf[1] != '\\0' && escPatbuf[1] != '/') {\n         // extract user name\n         char uname[70], *p, *q;\n         for (p = &escPatbuf[1], q = uname; *p && *p !='/';)\n            *q++ = *p++;\n         *q = '\\0';\n         hd = HomeDirectory(uname);\n         if (hd == 0)\n            strcat(cmd, escPatbuf);\n         else {\n            strcat(cmd, hd);\n            strcat(cmd, p);\n         }\n\n      } else {\n         hd = HomeDirectory(0);\n         if (hd == 0) {\n            Error(ErrSys, kErrFatal, \"RootdExpandPathName: no home directory\");\n            return 0;\n         }\n         strcat(cmd, hd);\n         strcat(cmd, &escPatbuf[1]);\n      }\n   } else\n      strcat(cmd, escPatbuf);\n\n   FILE *pf;\n   if ((pf = ::popen(&cmd[0], \"r\")) == 0) {\n      Error(ErrSys, kErrFatal, \"RootdExpandPathName: error in popen(%s)\", cmd);\n      return 0;\n   }\n\n   // read first argument\n   char expPatbuf[kMAXPATHLEN];\n   int  ch, i, cnt = 0;\nagain:\n   for (i = 0, ch = fgetc(pf); ch != EOF && ch != ' ' && ch != '\\n'; i++, ch = fgetc(pf)) {\n      expPatbuf[i] = ch;\n      cnt++;\n   }\n   // this will be true if forked process was not yet ready to be read\n   if (cnt == 0 && ch == EOF) goto again;\n   expPatbuf[cnt] = '\\0';\n\n   // skip rest of pipe\n   while (ch != EOF) {\n      ch = fgetc(pf);\n      if (ch == ' ' || ch == '\\t') {\n         ::pclose(pf);\n         Error(ErrFatal, kErrFatal, \"RootdExpandPathName: expression ambigous\");\n         return 0;\n      }\n   }\n\n   ::pclose(pf);\n\n   return strdup(expPatbuf);\n}",
        "func": "char *RootdExpandPathName(const char *name)\n{\n   const char *patbuf = name;\n\n   // skip leading blanks\n   while (*patbuf == ' ') patbuf++;\n\n   // any shell meta characters?\n   bool needesc = false;\n   for (const char *p = patbuf; *p; p++)\n      if (strchr(shellMeta, *p)) {\n         needesc = true;\n         break;\n      }\n\n   // Escape meta characters, if required\n   if (needesc) {\n      const int kBufSize = kMAXPATHLEN;\n      char xname[kBufSize];\n      if (RootdExpandFileName(name, xname, kBufSize)) {\n         Error(ErrFatal, kErrFatal, \"RootdExpandPathName: problem escaping meta characters\");\n         return 0;\n      } else {\n         return strdup(xname);\n      }\n   }\n   return strdup(name);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,86 +3,26 @@\n    const char *patbuf = name;\n \n    // skip leading blanks\n-   while (*patbuf == ' ')\n-      patbuf++;\n+   while (*patbuf == ' ') patbuf++;\n \n    // any shell meta characters?\n+   bool needesc = false;\n    for (const char *p = patbuf; *p; p++)\n-      if (strchr(shellMeta, *p))\n-         goto needshell;\n+      if (strchr(shellMeta, *p)) {\n+         needesc = true;\n+         break;\n+      }\n \n-   return strdup(name);\n-\n-needshell:\n-   // escape shell quote characters\n-   char escPatbuf[kMAXPATHLEN];\n-   EscChar(patbuf, escPatbuf, sizeof(escPatbuf), shellStuff, shellEscape);\n-\n-   char cmd[kMAXPATHLEN];\n-#ifdef __hpux\n-   strlcpy(cmd, \"/bin/echo \", sizeof(cmd));\n-#else\n-   strlcpy(cmd, \"echo \", sizeof(cmd));\n-#endif\n-\n-   // emulate csh -> popen executes sh\n-   if (escPatbuf[0] == '~') {\n-      const char *hd;\n-      if (escPatbuf[1] != '\\0' && escPatbuf[1] != '/') {\n-         // extract user name\n-         char uname[70], *p, *q;\n-         for (p = &escPatbuf[1], q = uname; *p && *p !='/';)\n-            *q++ = *p++;\n-         *q = '\\0';\n-         hd = HomeDirectory(uname);\n-         if (hd == 0)\n-            strcat(cmd, escPatbuf);\n-         else {\n-            strcat(cmd, hd);\n-            strcat(cmd, p);\n-         }\n-\n+   // Escape meta characters, if required\n+   if (needesc) {\n+      const int kBufSize = kMAXPATHLEN;\n+      char xname[kBufSize];\n+      if (RootdExpandFileName(name, xname, kBufSize)) {\n+         Error(ErrFatal, kErrFatal, \"RootdExpandPathName: problem escaping meta characters\");\n+         return 0;\n       } else {\n-         hd = HomeDirectory(0);\n-         if (hd == 0) {\n-            Error(ErrSys, kErrFatal, \"RootdExpandPathName: no home directory\");\n-            return 0;\n-         }\n-         strcat(cmd, hd);\n-         strcat(cmd, &escPatbuf[1]);\n-      }\n-   } else\n-      strcat(cmd, escPatbuf);\n-\n-   FILE *pf;\n-   if ((pf = ::popen(&cmd[0], \"r\")) == 0) {\n-      Error(ErrSys, kErrFatal, \"RootdExpandPathName: error in popen(%s)\", cmd);\n-      return 0;\n-   }\n-\n-   // read first argument\n-   char expPatbuf[kMAXPATHLEN];\n-   int  ch, i, cnt = 0;\n-again:\n-   for (i = 0, ch = fgetc(pf); ch != EOF && ch != ' ' && ch != '\\n'; i++, ch = fgetc(pf)) {\n-      expPatbuf[i] = ch;\n-      cnt++;\n-   }\n-   // this will be true if forked process was not yet ready to be read\n-   if (cnt == 0 && ch == EOF) goto again;\n-   expPatbuf[cnt] = '\\0';\n-\n-   // skip rest of pipe\n-   while (ch != EOF) {\n-      ch = fgetc(pf);\n-      if (ch == ' ' || ch == '\\t') {\n-         ::pclose(pf);\n-         Error(ErrFatal, kErrFatal, \"RootdExpandPathName: expression ambigous\");\n-         return 0;\n+         return strdup(xname);\n       }\n    }\n-\n-   ::pclose(pf);\n-\n-   return strdup(expPatbuf);\n+   return strdup(name);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "   while (*patbuf == ' ')",
                "      patbuf++;",
                "      if (strchr(shellMeta, *p))",
                "         goto needshell;",
                "   return strdup(name);",
                "",
                "needshell:",
                "   // escape shell quote characters",
                "   char escPatbuf[kMAXPATHLEN];",
                "   EscChar(patbuf, escPatbuf, sizeof(escPatbuf), shellStuff, shellEscape);",
                "",
                "   char cmd[kMAXPATHLEN];",
                "#ifdef __hpux",
                "   strlcpy(cmd, \"/bin/echo \", sizeof(cmd));",
                "#else",
                "   strlcpy(cmd, \"echo \", sizeof(cmd));",
                "#endif",
                "",
                "   // emulate csh -> popen executes sh",
                "   if (escPatbuf[0] == '~') {",
                "      const char *hd;",
                "      if (escPatbuf[1] != '\\0' && escPatbuf[1] != '/') {",
                "         // extract user name",
                "         char uname[70], *p, *q;",
                "         for (p = &escPatbuf[1], q = uname; *p && *p !='/';)",
                "            *q++ = *p++;",
                "         *q = '\\0';",
                "         hd = HomeDirectory(uname);",
                "         if (hd == 0)",
                "            strcat(cmd, escPatbuf);",
                "         else {",
                "            strcat(cmd, hd);",
                "            strcat(cmd, p);",
                "         }",
                "",
                "         hd = HomeDirectory(0);",
                "         if (hd == 0) {",
                "            Error(ErrSys, kErrFatal, \"RootdExpandPathName: no home directory\");",
                "            return 0;",
                "         }",
                "         strcat(cmd, hd);",
                "         strcat(cmd, &escPatbuf[1]);",
                "      }",
                "   } else",
                "      strcat(cmd, escPatbuf);",
                "",
                "   FILE *pf;",
                "   if ((pf = ::popen(&cmd[0], \"r\")) == 0) {",
                "      Error(ErrSys, kErrFatal, \"RootdExpandPathName: error in popen(%s)\", cmd);",
                "      return 0;",
                "   }",
                "",
                "   // read first argument",
                "   char expPatbuf[kMAXPATHLEN];",
                "   int  ch, i, cnt = 0;",
                "again:",
                "   for (i = 0, ch = fgetc(pf); ch != EOF && ch != ' ' && ch != '\\n'; i++, ch = fgetc(pf)) {",
                "      expPatbuf[i] = ch;",
                "      cnt++;",
                "   }",
                "   // this will be true if forked process was not yet ready to be read",
                "   if (cnt == 0 && ch == EOF) goto again;",
                "   expPatbuf[cnt] = '\\0';",
                "",
                "   // skip rest of pipe",
                "   while (ch != EOF) {",
                "      ch = fgetc(pf);",
                "      if (ch == ' ' || ch == '\\t') {",
                "         ::pclose(pf);",
                "         Error(ErrFatal, kErrFatal, \"RootdExpandPathName: expression ambigous\");",
                "         return 0;",
                "",
                "   ::pclose(pf);",
                "",
                "   return strdup(expPatbuf);"
            ],
            "added_lines": [
                "   while (*patbuf == ' ') patbuf++;",
                "   bool needesc = false;",
                "      if (strchr(shellMeta, *p)) {",
                "         needesc = true;",
                "         break;",
                "      }",
                "   // Escape meta characters, if required",
                "   if (needesc) {",
                "      const int kBufSize = kMAXPATHLEN;",
                "      char xname[kBufSize];",
                "      if (RootdExpandFileName(name, xname, kBufSize)) {",
                "         Error(ErrFatal, kErrFatal, \"RootdExpandPathName: problem escaping meta characters\");",
                "         return 0;",
                "         return strdup(xname);",
                "   return strdup(name);"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-1000215",
        "func_name": "xrootd/DefaultEnv::Initialize",
        "description": "ROOT xrootd version 4.6.0 and below is vulnerable to an unauthenticated shell command injection resulting in remote code execution",
        "git_url": "https://github.com/xrootd/xrootd/commit/befa2e627a5a33a38c92db3e57c07d8246a24acf",
        "commit_title": "secgsi: do not build/package libXrdSecgsiGMAPLDAP-4.so",
        "commit_text": " The way the LDAP query is implemented may represent a security threat. Any related building and packaging reference is removed. The code is left in place (for the time being) to remind its functionality in the case a sanitized version is required.",
        "func_before": "void DefaultEnv::Initialize()\n  {\n    sLog           = new Log();\n    SetUpLog();\n\n    sEnv           = new DefaultEnv();\n    sForkHandler   = new ForkHandler();\n    sFileTimer     = new FileTimer();\n    sPlugInManager = new PlugInManager();\n\n    sPlugInManager->ProcessEnvironmentSettings();\n    sForkHandler->RegisterFileTimer( sFileTimer );\n\n    //--------------------------------------------------------------------------\n    // MacOSX library loading is completely moronic. We cannot dlopen a library\n    // from a thread other than a main thread, so we-pre dlopen all the\n    // libraries that we may potentially want.\n    //--------------------------------------------------------------------------\n#ifdef __APPLE__\n    char *errBuff = new char[1024];\n\n    const char *libs[] =\n    {\n      \"libXrdSeckrb5.so\",\n      \"libXrdSecgsi.so\",\n      \"libXrdSecgsiAuthzVO.so\",\n      \"libXrdSecgsiGMAPDN.so\",\n      \"libXrdSecgsiGMAPLDAP.so\",\n      \"libXrdSecpwd.so\",\n      \"libXrdSecsss.so\",\n      \"libXrdSecunix.so\",\n      0\n    };\n\n    for( int i = 0; libs[i]; ++i )\n    {\n      sLog->Debug( UtilityMsg, \"Attempting to pre-load: %s\", libs[i] );\n      bool ok = XrdOucPreload( libs[i], errBuff, 1024 );\n      if( !ok )\n        sLog->Error( UtilityMsg, \"Unable to pre-load %s: %s\", libs[i], errBuff );\n    }\n    delete [] errBuff;\n#endif\n  }",
        "func": "void DefaultEnv::Initialize()\n  {\n    sLog           = new Log();\n    SetUpLog();\n\n    sEnv           = new DefaultEnv();\n    sForkHandler   = new ForkHandler();\n    sFileTimer     = new FileTimer();\n    sPlugInManager = new PlugInManager();\n\n    sPlugInManager->ProcessEnvironmentSettings();\n    sForkHandler->RegisterFileTimer( sFileTimer );\n\n    //--------------------------------------------------------------------------\n    // MacOSX library loading is completely moronic. We cannot dlopen a library\n    // from a thread other than a main thread, so we-pre dlopen all the\n    // libraries that we may potentially want.\n    //--------------------------------------------------------------------------\n#ifdef __APPLE__\n    char *errBuff = new char[1024];\n\n    const char *libs[] =\n    {\n      \"libXrdSeckrb5.so\",\n      \"libXrdSecgsi.so\",\n      \"libXrdSecgsiAuthzVO.so\",\n      \"libXrdSecgsiGMAPDN.so\",\n      \"libXrdSecpwd.so\",\n      \"libXrdSecsss.so\",\n      \"libXrdSecunix.so\",\n      0\n    };\n\n    for( int i = 0; libs[i]; ++i )\n    {\n      sLog->Debug( UtilityMsg, \"Attempting to pre-load: %s\", libs[i] );\n      bool ok = XrdOucPreload( libs[i], errBuff, 1024 );\n      if( !ok )\n        sLog->Error( UtilityMsg, \"Unable to pre-load %s: %s\", libs[i], errBuff );\n    }\n    delete [] errBuff;\n#endif\n  }",
        "diff_func": "--- func_before\n+++ func_after\n@@ -25,7 +25,6 @@\n       \"libXrdSecgsi.so\",\n       \"libXrdSecgsiAuthzVO.so\",\n       \"libXrdSecgsiGMAPDN.so\",\n-      \"libXrdSecgsiGMAPLDAP.so\",\n       \"libXrdSecpwd.so\",\n       \"libXrdSecsss.so\",\n       \"libXrdSecunix.so\",",
        "diff_line_info": {
            "deleted_lines": [
                "      \"libXrdSecgsiGMAPLDAP.so\","
            ],
            "added_lines": []
        }
    },
    {
        "cve_id": "CVE-2017-15108",
        "func_name": "spice/linux/vd_agent/vdagent_file_xfers_data",
        "description": "spice-vdagent up to and including 0.17.0 does not properly escape save directory before passing to shell, allowing local attacker with access to the session the agent runs in to inject arbitrary commands to be executed.",
        "git_url": "https://cgit.freedesktop.org/spice/linux/vd_agent/commit/?id=8ba174816d245757e743e636df357910e1d5eb61",
        "commit_title": "Thanks to a report from Seth Arnold <seth.arnold@canonial.com>:",
        "commit_text": "- vdagent_file_xfers_data() does not escape xfers->save_dir before giving   it to the shell - vdagent_file_xfers_data() does not check snprintf() return code; a   too-long xfers->save_dir could cause the & or ' or any number of other   characters to go missing.  To fix these issues, we use g_spawn_async(). This avoids the need to quote the filename and also avoids the snprintf issue.  In the case that the spawn fails, we also print a warning to the syslog now.  ",
        "func_before": "void vdagent_file_xfers_data(struct vdagent_file_xfers *xfers,\n    VDAgentFileXferDataMessage *msg)\n{\n    AgentFileXferTask *task;\n    int len, status = -1;\n\n    g_return_if_fail(xfers != NULL);\n\n    task = vdagent_file_xfers_get_task(xfers, msg->id);\n    if (!task)\n        return;\n\n    len = write(task->file_fd, msg->data, msg->size);\n    if (len == msg->size) {\n        task->read_bytes += msg->size;\n        if (task->read_bytes >= task->file_size) {\n            if (task->read_bytes == task->file_size) {\n                if (xfers->debug)\n                    syslog(LOG_DEBUG, \"file-xfer: task %u %s has completed\",\n                           task->id, task->file_name);\n                close(task->file_fd);\n                task->file_fd = -1;\n                if (xfers->open_save_dir &&\n                        task->file_xfer_nr == task->file_xfer_total &&\n                        g_hash_table_size(xfers->xfers) == 1) {\n                    char buf[PATH_MAX];\n                    snprintf(buf, PATH_MAX, \"xdg-open '%s'&\", xfers->save_dir);\n                    status = system(buf);\n                }\n                status = VD_AGENT_FILE_XFER_STATUS_SUCCESS;\n            } else {\n                syslog(LOG_ERR, \"file-xfer: error received too much data\");\n                status = VD_AGENT_FILE_XFER_STATUS_ERROR;\n            }\n        }\n    } else {\n        syslog(LOG_ERR, \"file-xfer: error writing %s: %s\", task->file_name,\n               strerror(errno));\n        status = VD_AGENT_FILE_XFER_STATUS_ERROR;\n    }\n\n    if (status != -1) {\n        udscs_write(xfers->vdagentd, VDAGENTD_FILE_XFER_STATUS,\n                    msg->id, status, NULL, 0);\n        g_hash_table_remove(xfers->xfers, GUINT_TO_POINTER(msg->id));\n    }\n}",
        "func": "void vdagent_file_xfers_data(struct vdagent_file_xfers *xfers,\n    VDAgentFileXferDataMessage *msg)\n{\n    AgentFileXferTask *task;\n    int len, status = -1;\n\n    g_return_if_fail(xfers != NULL);\n\n    task = vdagent_file_xfers_get_task(xfers, msg->id);\n    if (!task)\n        return;\n\n    len = write(task->file_fd, msg->data, msg->size);\n    if (len == msg->size) {\n        task->read_bytes += msg->size;\n        if (task->read_bytes >= task->file_size) {\n            if (task->read_bytes == task->file_size) {\n                if (xfers->debug)\n                    syslog(LOG_DEBUG, \"file-xfer: task %u %s has completed\",\n                           task->id, task->file_name);\n                close(task->file_fd);\n                task->file_fd = -1;\n                if (xfers->open_save_dir &&\n                        task->file_xfer_nr == task->file_xfer_total &&\n                        g_hash_table_size(xfers->xfers) == 1) {\n                    GError *error = NULL;\n                    gchar *argv[] = { \"xdg-open\", xfers->save_dir, NULL };\n                    if (!g_spawn_async(NULL, argv, NULL,\n                                           G_SPAWN_SEARCH_PATH,\n                                           NULL, NULL, NULL, &error)) {\n                        syslog(LOG_WARNING,\n                               \"file-xfer: failed to open save directory: %s\",\n                               error->message);\n                        g_error_free(error);\n                    }\n                }\n                status = VD_AGENT_FILE_XFER_STATUS_SUCCESS;\n            } else {\n                syslog(LOG_ERR, \"file-xfer: error received too much data\");\n                status = VD_AGENT_FILE_XFER_STATUS_ERROR;\n            }\n        }\n    } else {\n        syslog(LOG_ERR, \"file-xfer: error writing %s: %s\", task->file_name,\n               strerror(errno));\n        status = VD_AGENT_FILE_XFER_STATUS_ERROR;\n    }\n\n    if (status != -1) {\n        udscs_write(xfers->vdagentd, VDAGENTD_FILE_XFER_STATUS,\n                    msg->id, status, NULL, 0);\n        g_hash_table_remove(xfers->xfers, GUINT_TO_POINTER(msg->id));\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -23,9 +23,16 @@\n                 if (xfers->open_save_dir &&\n                         task->file_xfer_nr == task->file_xfer_total &&\n                         g_hash_table_size(xfers->xfers) == 1) {\n-                    char buf[PATH_MAX];\n-                    snprintf(buf, PATH_MAX, \"xdg-open '%s'&\", xfers->save_dir);\n-                    status = system(buf);\n+                    GError *error = NULL;\n+                    gchar *argv[] = { \"xdg-open\", xfers->save_dir, NULL };\n+                    if (!g_spawn_async(NULL, argv, NULL,\n+                                           G_SPAWN_SEARCH_PATH,\n+                                           NULL, NULL, NULL, &error)) {\n+                        syslog(LOG_WARNING,\n+                               \"file-xfer: failed to open save directory: %s\",\n+                               error->message);\n+                        g_error_free(error);\n+                    }\n                 }\n                 status = VD_AGENT_FILE_XFER_STATUS_SUCCESS;\n             } else {",
        "diff_line_info": {
            "deleted_lines": [
                "                    char buf[PATH_MAX];",
                "                    snprintf(buf, PATH_MAX, \"xdg-open '%s'&\", xfers->save_dir);",
                "                    status = system(buf);"
            ],
            "added_lines": [
                "                    GError *error = NULL;",
                "                    gchar *argv[] = { \"xdg-open\", xfers->save_dir, NULL };",
                "                    if (!g_spawn_async(NULL, argv, NULL,",
                "                                           G_SPAWN_SEARCH_PATH,",
                "                                           NULL, NULL, NULL, &error)) {",
                "                        syslog(LOG_WARNING,",
                "                               \"file-xfer: failed to open save directory: %s\",",
                "                               error->message);",
                "                        g_error_free(error);",
                "                    }"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-48337",
        "func_name": "emacs/process_file_name",
        "description": "GNU Emacs through 28.2 allows attackers to execute commands via shell metacharacters in the name of a source-code file, because lib-src/etags.c uses the system C library function in its implementation of the etags program. For example, a victim may use the \"etags -u *\" command (suggested in the etags documentation) in a situation where the current working directory has contents that depend on untrusted input.",
        "git_url": "https://git.savannah.gnu.org/cgit/emacs.git/commit/?id=01a4035c869b91c153af9a9132c87adb7669ea1c",
        "commit_title": "* lib-src/etags.c: (escape_shell_arg_string): New function.",
        "commit_text": "(process_file_name): Use it to quote file names passed to the shell.  (Bug#59817) ",
        "func_before": "static void\nprocess_file_name (char *file, language *lang)\n{\n  FILE *inf;\n  fdesc *fdp;\n  compressor *compr;\n  char *compressed_name, *uncompressed_name;\n  char *ext, *real_name UNINIT, *tmp_name UNINIT;\n  int retval;\n\n  canonicalize_filename (file);\n  if (streq (file, tagfile) && !streq (tagfile, \"-\"))\n    {\n      error (\"skipping inclusion of %s in self.\", file);\n      return;\n    }\n  compr = get_compressor_from_suffix (file, &ext);\n  if (compr)\n    {\n      compressed_name = file;\n      uncompressed_name = savenstr (file, ext - file);\n    }\n  else\n    {\n      compressed_name = NULL;\n      uncompressed_name = file;\n    }\n\n  /* If the canonicalized uncompressed name\n     has already been dealt with, skip it silently. */\n  for (fdp = fdhead; fdp != NULL; fdp = fdp->next)\n    {\n      assert (fdp->infname != NULL);\n      if (streq (uncompressed_name, fdp->infname))\n\tgoto cleanup;\n    }\n\n  inf = fopen (file, \"r\" FOPEN_BINARY);\n  if (inf)\n    real_name = file;\n  else\n    {\n      int file_errno = errno;\n      if (compressed_name)\n\t{\n\t  /* Try with the given suffix.  */\n\t  inf = fopen (uncompressed_name, \"r\" FOPEN_BINARY);\n\t  if (inf)\n\t    real_name = uncompressed_name;\n\t}\n      else\n\t{\n\t  /* Try all possible suffixes.  */\n\t  for (compr = compressors; compr->suffix != NULL; compr++)\n\t    {\n\t      compressed_name = concat (file, \".\", compr->suffix);\n\t      inf = fopen (compressed_name, \"r\" FOPEN_BINARY);\n\t      if (inf)\n\t\t{\n\t\t  real_name = compressed_name;\n\t\t  break;\n\t\t}\n\t      if (MSDOS)\n\t\t{\n\t\t  char *suf = compressed_name + strlen (file);\n\t\t  size_t suflen = strlen (compr->suffix) + 1;\n\t\t  for ( ; suf[1]; suf++, suflen--)\n\t\t    {\n\t\t      memmove (suf, suf + 1, suflen);\n\t\t      inf = fopen (compressed_name, \"r\" FOPEN_BINARY);\n\t\t      if (inf)\n\t\t\t{\n\t\t\t  real_name = compressed_name;\n\t\t\t  break;\n\t\t\t}\n\t\t    }\n\t\t  if (inf)\n\t\t    break;\n\t\t}\n\t      free (compressed_name);\n\t      compressed_name = NULL;\n\t    }\n\t}\n      if (! inf)\n\t{\n\t  errno = file_errno;\n\t  perror (file);\n\t  goto cleanup;\n\t}\n    }\n\n  if (real_name == compressed_name)\n    {\n      fclose (inf);\n      tmp_name = etags_mktmp ();\n      if (!tmp_name)\n\tinf = NULL;\n      else\n\t{\n#if MSDOS || defined (DOS_NT)\n\t  char *cmd1 = concat (compr->command, \" \\\"\", real_name);\n\t  char *cmd = concat (cmd1, \"\\\" > \", tmp_name);\n#else\n\t  char *cmd1 = concat (compr->command, \" '\", real_name);\n\t  char *cmd = concat (cmd1, \"' > \", tmp_name);\n#endif\n\t  free (cmd1);\n\t  inf = (system (cmd) == -1\n\t\t ? NULL\n\t\t : fopen (tmp_name, \"r\" FOPEN_BINARY));\n\t  free (cmd);\n\t}\n\n      if (!inf)\n\t{\n\t  perror (real_name);\n\t  goto cleanup;\n\t}\n    }\n\n  process_file (inf, uncompressed_name, lang);\n\n  retval = fclose (inf);\n  if (real_name == compressed_name)\n    {\n      remove (tmp_name);\n      free (tmp_name);\n    }\n  if (retval < 0)\n    pfatal (file);\n\n cleanup:\n  if (compressed_name != file)\n    free (compressed_name);\n  if (uncompressed_name != file)\n    free (uncompressed_name);\n  last_node = NULL;\n  curfdp = NULL;\n  return;\n}",
        "func": "static void\nprocess_file_name (char *file, language *lang)\n{\n  FILE *inf;\n  fdesc *fdp;\n  compressor *compr;\n  char *compressed_name, *uncompressed_name;\n  char *ext, *real_name UNINIT, *tmp_name UNINIT;\n  int retval;\n\n  canonicalize_filename (file);\n  if (streq (file, tagfile) && !streq (tagfile, \"-\"))\n    {\n      error (\"skipping inclusion of %s in self.\", file);\n      return;\n    }\n  compr = get_compressor_from_suffix (file, &ext);\n  if (compr)\n    {\n      compressed_name = file;\n      uncompressed_name = savenstr (file, ext - file);\n    }\n  else\n    {\n      compressed_name = NULL;\n      uncompressed_name = file;\n    }\n\n  /* If the canonicalized uncompressed name\n     has already been dealt with, skip it silently. */\n  for (fdp = fdhead; fdp != NULL; fdp = fdp->next)\n    {\n      assert (fdp->infname != NULL);\n      if (streq (uncompressed_name, fdp->infname))\n\tgoto cleanup;\n    }\n\n  inf = fopen (file, \"r\" FOPEN_BINARY);\n  if (inf)\n    real_name = file;\n  else\n    {\n      int file_errno = errno;\n      if (compressed_name)\n\t{\n\t  /* Try with the given suffix.  */\n\t  inf = fopen (uncompressed_name, \"r\" FOPEN_BINARY);\n\t  if (inf)\n\t    real_name = uncompressed_name;\n\t}\n      else\n\t{\n\t  /* Try all possible suffixes.  */\n\t  for (compr = compressors; compr->suffix != NULL; compr++)\n\t    {\n\t      compressed_name = concat (file, \".\", compr->suffix);\n\t      inf = fopen (compressed_name, \"r\" FOPEN_BINARY);\n\t      if (inf)\n\t\t{\n\t\t  real_name = compressed_name;\n\t\t  break;\n\t\t}\n\t      if (MSDOS)\n\t\t{\n\t\t  char *suf = compressed_name + strlen (file);\n\t\t  size_t suflen = strlen (compr->suffix) + 1;\n\t\t  for ( ; suf[1]; suf++, suflen--)\n\t\t    {\n\t\t      memmove (suf, suf + 1, suflen);\n\t\t      inf = fopen (compressed_name, \"r\" FOPEN_BINARY);\n\t\t      if (inf)\n\t\t\t{\n\t\t\t  real_name = compressed_name;\n\t\t\t  break;\n\t\t\t}\n\t\t    }\n\t\t  if (inf)\n\t\t    break;\n\t\t}\n\t      free (compressed_name);\n\t      compressed_name = NULL;\n\t    }\n\t}\n      if (! inf)\n\t{\n\t  errno = file_errno;\n\t  perror (file);\n\t  goto cleanup;\n\t}\n    }\n\n  if (real_name == compressed_name)\n    {\n      fclose (inf);\n      tmp_name = etags_mktmp ();\n      if (!tmp_name)\n\tinf = NULL;\n      else\n\t{\n#if MSDOS || defined (DOS_NT)\n          int buf_len = strlen (compr->command) + strlen (\" \\\"\\\" > \\\"\\\"\") + strlen (real_name) + strlen (tmp_name) + 1;\n          char *cmd = xmalloc (buf_len);\n          snprintf (cmd, buf_len, \"%s \\\"%s\\\" > \\\"%s\\\"\", compr->command, real_name, tmp_name);\n#else\n          char *new_real_name = escape_shell_arg_string (real_name);\n          char *new_tmp_name = escape_shell_arg_string (tmp_name);\n          int buf_len = strlen (compr->command) + strlen (\"  > \") + strlen (new_real_name) + strlen (new_tmp_name) + 1;\n          char *cmd = xmalloc (buf_len);\n          snprintf (cmd, buf_len, \"%s %s > %s\", compr->command, new_real_name, new_tmp_name);\n#endif\n\t  inf = (system (cmd) == -1\n\t\t ? NULL\n\t\t : fopen (tmp_name, \"r\" FOPEN_BINARY));\n\t  free (cmd);\n\t}\n\n      if (!inf)\n\t{\n\t  perror (real_name);\n\t  goto cleanup;\n\t}\n    }\n\n  process_file (inf, uncompressed_name, lang);\n\n  retval = fclose (inf);\n  if (real_name == compressed_name)\n    {\n      remove (tmp_name);\n      free (tmp_name);\n    }\n  if (retval < 0)\n    pfatal (file);\n\n cleanup:\n  if (compressed_name != file)\n    free (compressed_name);\n  if (uncompressed_name != file)\n    free (uncompressed_name);\n  last_node = NULL;\n  curfdp = NULL;\n  return;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -98,13 +98,16 @@\n       else\n \t{\n #if MSDOS || defined (DOS_NT)\n-\t  char *cmd1 = concat (compr->command, \" \\\"\", real_name);\n-\t  char *cmd = concat (cmd1, \"\\\" > \", tmp_name);\n+          int buf_len = strlen (compr->command) + strlen (\" \\\"\\\" > \\\"\\\"\") + strlen (real_name) + strlen (tmp_name) + 1;\n+          char *cmd = xmalloc (buf_len);\n+          snprintf (cmd, buf_len, \"%s \\\"%s\\\" > \\\"%s\\\"\", compr->command, real_name, tmp_name);\n #else\n-\t  char *cmd1 = concat (compr->command, \" '\", real_name);\n-\t  char *cmd = concat (cmd1, \"' > \", tmp_name);\n+          char *new_real_name = escape_shell_arg_string (real_name);\n+          char *new_tmp_name = escape_shell_arg_string (tmp_name);\n+          int buf_len = strlen (compr->command) + strlen (\"  > \") + strlen (new_real_name) + strlen (new_tmp_name) + 1;\n+          char *cmd = xmalloc (buf_len);\n+          snprintf (cmd, buf_len, \"%s %s > %s\", compr->command, new_real_name, new_tmp_name);\n #endif\n-\t  free (cmd1);\n \t  inf = (system (cmd) == -1\n \t\t ? NULL\n \t\t : fopen (tmp_name, \"r\" FOPEN_BINARY));",
        "diff_line_info": {
            "deleted_lines": [
                "\t  char *cmd1 = concat (compr->command, \" \\\"\", real_name);",
                "\t  char *cmd = concat (cmd1, \"\\\" > \", tmp_name);",
                "\t  char *cmd1 = concat (compr->command, \" '\", real_name);",
                "\t  char *cmd = concat (cmd1, \"' > \", tmp_name);",
                "\t  free (cmd1);"
            ],
            "added_lines": [
                "          int buf_len = strlen (compr->command) + strlen (\" \\\"\\\" > \\\"\\\"\") + strlen (real_name) + strlen (tmp_name) + 1;",
                "          char *cmd = xmalloc (buf_len);",
                "          snprintf (cmd, buf_len, \"%s \\\"%s\\\" > \\\"%s\\\"\", compr->command, real_name, tmp_name);",
                "          char *new_real_name = escape_shell_arg_string (real_name);",
                "          char *new_tmp_name = escape_shell_arg_string (tmp_name);",
                "          int buf_len = strlen (compr->command) + strlen (\"  > \") + strlen (new_real_name) + strlen (new_tmp_name) + 1;",
                "          char *cmd = xmalloc (buf_len);",
                "          snprintf (cmd, buf_len, \"%s %s > %s\", compr->command, new_real_name, new_tmp_name);"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-1000118",
        "func_name": "electron/IsBlacklistedArg",
        "description": "Github Electron version Electron 1.8.2-beta.4 and earlier contains a Command Injection vulnerability in Protocol Handler that can result in command execute. This attack appear to be exploitable via the victim opening an electron protocol handler in their browser. This vulnerability appears to have been fixed in Electron 1.8.2-beta.5. This issue is due to an incomplete fix for CVE-2018-1000006, specifically the black list used was not case insensitive allowing an attacker to potentially bypass it.",
        "git_url": "https://github.com/electron/electron/commit/ce361a12e355f9e1e99c989f1ea056c9e502dbe7",
        "commit_title": "Use case-insensitive switch comparisons",
        "commit_text": "",
        "func_before": "bool IsBlacklistedArg(const base::CommandLine::CharType* arg) {\n#if defined(OS_WIN)\n  const auto converted = base::WideToUTF8(arg);\n  const char* a = converted.c_str();\n#else\n  const char* a = arg;\n#endif\n\n  static const char* prefixes[] = {\"--\", \"-\", \"/\"};\n\n  int prefix_length = 0;\n  for (auto& prefix : prefixes) {\n    if (base::StartsWith(a, prefix, base::CompareCase::SENSITIVE)) {\n      prefix_length = strlen(prefix);\n      break;\n    }\n  }\n\n  if (prefix_length > 0) {\n    a += prefix_length;\n    std::string switch_name(a, strcspn(a, \"=\"));\n    auto* iter = std::lower_bound(std::begin(kBlacklist), std::end(kBlacklist),\n                                  switch_name);\n    if (iter != std::end(kBlacklist) && switch_name == *iter) {\n      return true;\n    }\n  }\n\n  return false;\n}",
        "func": "bool IsBlacklistedArg(const base::CommandLine::CharType* arg) {\n#if defined(OS_WIN)\n  const auto converted = base::WideToUTF8(arg);\n  const char* a = converted.c_str();\n#else\n  const char* a = arg;\n#endif\n\n  static const char* prefixes[] = {\"--\", \"-\", \"/\"};\n\n  int prefix_length = 0;\n  for (auto& prefix : prefixes) {\n    if (base::StartsWith(a, prefix, base::CompareCase::SENSITIVE)) {\n      prefix_length = strlen(prefix);\n      break;\n    }\n  }\n\n  if (prefix_length > 0) {\n    a += prefix_length;\n    std::string switch_name =\n        base::ToLowerASCII(base::StringPiece(a, strcspn(a, \"=\")));\n    auto* iter = std::lower_bound(std::begin(kBlacklist), std::end(kBlacklist),\n                                  switch_name);\n    if (iter != std::end(kBlacklist) && switch_name == *iter) {\n      return true;\n    }\n  }\n\n  return false;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -18,7 +18,8 @@\n \n   if (prefix_length > 0) {\n     a += prefix_length;\n-    std::string switch_name(a, strcspn(a, \"=\"));\n+    std::string switch_name =\n+        base::ToLowerASCII(base::StringPiece(a, strcspn(a, \"=\")));\n     auto* iter = std::lower_bound(std::begin(kBlacklist), std::end(kBlacklist),\n                                   switch_name);\n     if (iter != std::end(kBlacklist) && switch_name == *iter) {",
        "diff_line_info": {
            "deleted_lines": [
                "    std::string switch_name(a, strcspn(a, \"=\"));"
            ],
            "added_lines": [
                "    std::string switch_name =",
                "        base::ToLowerASCII(base::StringPiece(a, strcspn(a, \"=\")));"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-14354",
        "func_name": "neomutt/imap_subscribe",
        "description": "An issue was discovered in Mutt before 1.10.1 and NeoMutt before 2018-07-16. They allow remote IMAP servers to execute arbitrary commands via backquote characters, related to the mailboxes command associated with a manual subscription or unsubscription.",
        "git_url": "https://github.com/neomutt/neomutt/commit/95e80bf9ff10f68cb6443f760b85df4117cb15eb",
        "commit_title": "Quote path in imap_subscribe",
        "commit_text": "",
        "func_before": "int imap_subscribe(char *path, bool subscribe)\n{\n  struct ImapData *idata = NULL;\n  char buf[LONG_STRING];\n  char mbox[LONG_STRING];\n  char errstr[STRING];\n  struct Buffer err, token;\n  struct ImapMbox mx;\n\n  if (!mx_is_imap(path) || imap_parse_path(path, &mx) || !mx.mbox)\n  {\n    mutt_error(_(\"Bad mailbox name\"));\n    return -1;\n  }\n  idata = imap_conn_find(&(mx.account), 0);\n  if (!idata)\n    goto fail;\n\n  imap_fix_path(idata, mx.mbox, buf, sizeof(buf));\n  if (!*buf)\n    mutt_str_strfcpy(buf, \"INBOX\", sizeof(buf));\n\n  if (ImapCheckSubscribed)\n  {\n    mutt_buffer_init(&token);\n    mutt_buffer_init(&err);\n    err.data = errstr;\n    err.dsize = sizeof(errstr);\n    snprintf(mbox, sizeof(mbox), \"%smailboxes \\\"%s\\\"\", subscribe ? \"\" : \"un\", path);\n    if (mutt_parse_rc_line(mbox, &token, &err))\n      mutt_debug(1, \"Error adding subscribed mailbox: %s\\n\", errstr);\n    FREE(&token.data);\n  }\n\n  if (subscribe)\n    mutt_message(_(\"Subscribing to %s...\"), buf);\n  else\n    mutt_message(_(\"Unsubscribing from %s...\"), buf);\n  imap_munge_mbox_name(idata, mbox, sizeof(mbox), buf);\n\n  snprintf(buf, sizeof(buf), \"%sSUBSCRIBE %s\", subscribe ? \"\" : \"UN\", mbox);\n\n  if (imap_exec(idata, buf, 0) < 0)\n    goto fail;\n\n  imap_unmunge_mbox_name(idata, mx.mbox);\n  if (subscribe)\n    mutt_message(_(\"Subscribed to %s\"), mx.mbox);\n  else\n    mutt_message(_(\"Unsubscribed from %s\"), mx.mbox);\n  FREE(&mx.mbox);\n  return 0;\n\nfail:\n  FREE(&mx.mbox);\n  return -1;\n}",
        "func": "int imap_subscribe(char *path, bool subscribe)\n{\n  struct ImapData *idata = NULL;\n  char buf[LONG_STRING];\n  char mbox[LONG_STRING];\n  char errstr[STRING];\n  struct Buffer err, token;\n  struct ImapMbox mx;\n  size_t len = 0;\n\n  if (!mx_is_imap(path) || imap_parse_path(path, &mx) || !mx.mbox)\n  {\n    mutt_error(_(\"Bad mailbox name\"));\n    return -1;\n  }\n  idata = imap_conn_find(&(mx.account), 0);\n  if (!idata)\n    goto fail;\n\n  imap_fix_path(idata, mx.mbox, buf, sizeof(buf));\n  if (!*buf)\n    mutt_str_strfcpy(buf, \"INBOX\", sizeof(buf));\n\n  if (ImapCheckSubscribed)\n  {\n    mutt_buffer_init(&token);\n    mutt_buffer_init(&err);\n    err.data = errstr;\n    err.dsize = sizeof(errstr);\n\tlen = snprintf(mbox, sizeof(mbox), \"%smailboxes \", subscribe ? \"\" : \"un\");\n\timap_quote_string(mbox + len, sizeof(mbox) - len, path, true);\n    if (mutt_parse_rc_line(mbox, &token, &err))\n      mutt_debug(1, \"Error adding subscribed mailbox: %s\\n\", errstr);\n    FREE(&token.data);\n  }\n\n  if (subscribe)\n    mutt_message(_(\"Subscribing to %s...\"), buf);\n  else\n    mutt_message(_(\"Unsubscribing from %s...\"), buf);\n  imap_munge_mbox_name(idata, mbox, sizeof(mbox), buf);\n\n  snprintf(buf, sizeof(buf), \"%sSUBSCRIBE %s\", subscribe ? \"\" : \"UN\", mbox);\n\n  if (imap_exec(idata, buf, 0) < 0)\n    goto fail;\n\n  imap_unmunge_mbox_name(idata, mx.mbox);\n  if (subscribe)\n    mutt_message(_(\"Subscribed to %s\"), mx.mbox);\n  else\n    mutt_message(_(\"Unsubscribed from %s\"), mx.mbox);\n  FREE(&mx.mbox);\n  return 0;\n\nfail:\n  FREE(&mx.mbox);\n  return -1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,6 +6,7 @@\n   char errstr[STRING];\n   struct Buffer err, token;\n   struct ImapMbox mx;\n+  size_t len = 0;\n \n   if (!mx_is_imap(path) || imap_parse_path(path, &mx) || !mx.mbox)\n   {\n@@ -26,7 +27,8 @@\n     mutt_buffer_init(&err);\n     err.data = errstr;\n     err.dsize = sizeof(errstr);\n-    snprintf(mbox, sizeof(mbox), \"%smailboxes \\\"%s\\\"\", subscribe ? \"\" : \"un\", path);\n+\tlen = snprintf(mbox, sizeof(mbox), \"%smailboxes \", subscribe ? \"\" : \"un\");\n+\timap_quote_string(mbox + len, sizeof(mbox) - len, path, true);\n     if (mutt_parse_rc_line(mbox, &token, &err))\n       mutt_debug(1, \"Error adding subscribed mailbox: %s\\n\", errstr);\n     FREE(&token.data);",
        "diff_line_info": {
            "deleted_lines": [
                "    snprintf(mbox, sizeof(mbox), \"%smailboxes \\\"%s\\\"\", subscribe ? \"\" : \"un\", path);"
            ],
            "added_lines": [
                "  size_t len = 0;",
                "\tlen = snprintf(mbox, sizeof(mbox), \"%smailboxes \", subscribe ? \"\" : \"un\");",
                "\timap_quote_string(mbox + len, sizeof(mbox) - len, path, true);"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-14357",
        "func_name": "neomutt/imap_auth_login",
        "description": "An issue was discovered in Mutt before 1.10.1 and NeoMutt before 2018-07-16. They allow remote IMAP servers to execute arbitrary commands via backquote characters, related to the mailboxes command associated with an automatic subscription.",
        "git_url": "https://github.com/neomutt/neomutt/commit/e52393740334443ae0206cab2d7caef381646725",
        "commit_title": "quote imap strings more carefully",
        "commit_text": " Co-authored-by: JerikoOne <jeriko.one@gmx.us>",
        "func_before": "enum ImapAuthRes imap_auth_login(struct ImapData *idata, const char *method)\n{\n  char q_user[SHORT_STRING], q_pass[SHORT_STRING];\n  char buf[STRING];\n  int rc;\n\n  if (mutt_bit_isset(idata->capabilities, LOGINDISABLED))\n  {\n    mutt_message(_(\"LOGIN disabled on this server.\"));\n    return IMAP_AUTH_UNAVAIL;\n  }\n\n  if (mutt_account_getuser(&idata->conn->account) < 0)\n    return IMAP_AUTH_FAILURE;\n  if (mutt_account_getpass(&idata->conn->account) < 0)\n    return IMAP_AUTH_FAILURE;\n\n  mutt_message(_(\"Logging in...\"));\n\n  imap_quote_string(q_user, sizeof(q_user), idata->conn->account.user);\n  imap_quote_string(q_pass, sizeof(q_pass), idata->conn->account.pass);\n\n  /* don't print the password unless we're at the ungodly debugging level\n   * of 5 or higher */\n\n  if (DebugLevel < IMAP_LOG_PASS)\n    mutt_debug(2, \"Sending LOGIN command for %s...\\n\", idata->conn->account.user);\n\n  snprintf(buf, sizeof(buf), \"LOGIN %s %s\", q_user, q_pass);\n  rc = imap_exec(idata, buf, IMAP_CMD_FAIL_OK | IMAP_CMD_PASS);\n\n  if (!rc)\n  {\n    mutt_clear_error(); /* clear \"Logging in...\".  fixes #3524 */\n    return IMAP_AUTH_SUCCESS;\n  }\n\n  mutt_error(_(\"Login failed.\"));\n  return IMAP_AUTH_FAILURE;\n}",
        "func": "enum ImapAuthRes imap_auth_login(struct ImapData *idata, const char *method)\n{\n  char q_user[SHORT_STRING], q_pass[SHORT_STRING];\n  char buf[STRING];\n  int rc;\n\n  if (mutt_bit_isset(idata->capabilities, LOGINDISABLED))\n  {\n    mutt_message(_(\"LOGIN disabled on this server.\"));\n    return IMAP_AUTH_UNAVAIL;\n  }\n\n  if (mutt_account_getuser(&idata->conn->account) < 0)\n    return IMAP_AUTH_FAILURE;\n  if (mutt_account_getpass(&idata->conn->account) < 0)\n    return IMAP_AUTH_FAILURE;\n\n  mutt_message(_(\"Logging in...\"));\n\n  imap_quote_string(q_user, sizeof(q_user), idata->conn->account.user, false);\n  imap_quote_string(q_pass, sizeof(q_pass), idata->conn->account.pass, false);\n\n  /* don't print the password unless we're at the ungodly debugging level\n   * of 5 or higher */\n\n  if (DebugLevel < IMAP_LOG_PASS)\n    mutt_debug(2, \"Sending LOGIN command for %s...\\n\", idata->conn->account.user);\n\n  snprintf(buf, sizeof(buf), \"LOGIN %s %s\", q_user, q_pass);\n  rc = imap_exec(idata, buf, IMAP_CMD_FAIL_OK | IMAP_CMD_PASS);\n\n  if (!rc)\n  {\n    mutt_clear_error(); /* clear \"Logging in...\".  fixes #3524 */\n    return IMAP_AUTH_SUCCESS;\n  }\n\n  mutt_error(_(\"Login failed.\"));\n  return IMAP_AUTH_FAILURE;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -17,8 +17,8 @@\n \n   mutt_message(_(\"Logging in...\"));\n \n-  imap_quote_string(q_user, sizeof(q_user), idata->conn->account.user);\n-  imap_quote_string(q_pass, sizeof(q_pass), idata->conn->account.pass);\n+  imap_quote_string(q_user, sizeof(q_user), idata->conn->account.user, false);\n+  imap_quote_string(q_pass, sizeof(q_pass), idata->conn->account.pass, false);\n \n   /* don't print the password unless we're at the ungodly debugging level\n    * of 5 or higher */",
        "diff_line_info": {
            "deleted_lines": [
                "  imap_quote_string(q_user, sizeof(q_user), idata->conn->account.user);",
                "  imap_quote_string(q_pass, sizeof(q_pass), idata->conn->account.pass);"
            ],
            "added_lines": [
                "  imap_quote_string(q_user, sizeof(q_user), idata->conn->account.user, false);",
                "  imap_quote_string(q_pass, sizeof(q_pass), idata->conn->account.pass, false);"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-14357",
        "func_name": "neomutt/compile_search",
        "description": "An issue was discovered in Mutt before 1.10.1 and NeoMutt before 2018-07-16. They allow remote IMAP servers to execute arbitrary commands via backquote characters, related to the mailboxes command associated with an automatic subscription.",
        "git_url": "https://github.com/neomutt/neomutt/commit/e52393740334443ae0206cab2d7caef381646725",
        "commit_title": "quote imap strings more carefully",
        "commit_text": " Co-authored-by: JerikoOne <jeriko.one@gmx.us>",
        "func_before": "static int compile_search(struct Context *ctx, const struct Pattern *pat, struct Buffer *buf)\n{\n  if (do_search(pat, 0) == 0)\n    return 0;\n\n  if (pat->not)\n    mutt_buffer_addstr(buf, \"NOT \");\n\n  if (pat->child)\n  {\n    int clauses;\n\n    clauses = do_search(pat->child, 1);\n    if (clauses > 0)\n    {\n      const struct Pattern *clause = pat->child;\n\n      mutt_buffer_addch(buf, '(');\n\n      while (clauses)\n      {\n        if (do_search(clause, 0))\n        {\n          if (pat->op == MUTT_OR && clauses > 1)\n            mutt_buffer_addstr(buf, \"OR \");\n          clauses--;\n\n          if (compile_search(ctx, clause, buf) < 0)\n            return -1;\n\n          if (clauses)\n            mutt_buffer_addch(buf, ' ');\n        }\n        clause = clause->next;\n      }\n\n      mutt_buffer_addch(buf, ')');\n    }\n  }\n  else\n  {\n    char term[STRING];\n    char *delim = NULL;\n\n    switch (pat->op)\n    {\n      case MUTT_HEADER:\n        mutt_buffer_addstr(buf, \"HEADER \");\n\n        /* extract header name */\n        delim = strchr(pat->p.str, ':');\n        if (!delim)\n        {\n          mutt_error(_(\"Header search without header name: %s\"), pat->p.str);\n          return -1;\n        }\n        *delim = '\\0';\n        imap_quote_string(term, sizeof(term), pat->p.str);\n        mutt_buffer_addstr(buf, term);\n        mutt_buffer_addch(buf, ' ');\n\n        /* and field */\n        *delim = ':';\n        delim++;\n        SKIPWS(delim);\n        imap_quote_string(term, sizeof(term), delim);\n        mutt_buffer_addstr(buf, term);\n        break;\n      case MUTT_BODY:\n        mutt_buffer_addstr(buf, \"BODY \");\n        imap_quote_string(term, sizeof(term), pat->p.str);\n        mutt_buffer_addstr(buf, term);\n        break;\n      case MUTT_WHOLE_MSG:\n        mutt_buffer_addstr(buf, \"TEXT \");\n        imap_quote_string(term, sizeof(term), pat->p.str);\n        mutt_buffer_addstr(buf, term);\n        break;\n      case MUTT_SERVERSEARCH:\n      {\n        struct ImapData *idata = ctx->data;\n        if (!mutt_bit_isset(idata->capabilities, X_GM_EXT1))\n        {\n          mutt_error(_(\"Server-side custom search not supported: %s\"), pat->p.str);\n          return -1;\n        }\n      }\n        mutt_buffer_addstr(buf, \"X-GM-RAW \");\n        imap_quote_string(term, sizeof(term), pat->p.str);\n        mutt_buffer_addstr(buf, term);\n        break;\n    }\n  }\n\n  return 0;\n}",
        "func": "static int compile_search(struct Context *ctx, const struct Pattern *pat, struct Buffer *buf)\n{\n  if (do_search(pat, 0) == 0)\n    return 0;\n\n  if (pat->not)\n    mutt_buffer_addstr(buf, \"NOT \");\n\n  if (pat->child)\n  {\n    int clauses;\n\n    clauses = do_search(pat->child, 1);\n    if (clauses > 0)\n    {\n      const struct Pattern *clause = pat->child;\n\n      mutt_buffer_addch(buf, '(');\n\n      while (clauses)\n      {\n        if (do_search(clause, 0))\n        {\n          if (pat->op == MUTT_OR && clauses > 1)\n            mutt_buffer_addstr(buf, \"OR \");\n          clauses--;\n\n          if (compile_search(ctx, clause, buf) < 0)\n            return -1;\n\n          if (clauses)\n            mutt_buffer_addch(buf, ' ');\n        }\n        clause = clause->next;\n      }\n\n      mutt_buffer_addch(buf, ')');\n    }\n  }\n  else\n  {\n    char term[STRING];\n    char *delim = NULL;\n\n    switch (pat->op)\n    {\n      case MUTT_HEADER:\n        mutt_buffer_addstr(buf, \"HEADER \");\n\n        /* extract header name */\n        delim = strchr(pat->p.str, ':');\n        if (!delim)\n        {\n          mutt_error(_(\"Header search without header name: %s\"), pat->p.str);\n          return -1;\n        }\n        *delim = '\\0';\n        imap_quote_string(term, sizeof(term), pat->p.str, false);\n        mutt_buffer_addstr(buf, term);\n        mutt_buffer_addch(buf, ' ');\n\n        /* and field */\n        *delim = ':';\n        delim++;\n        SKIPWS(delim);\n        imap_quote_string(term, sizeof(term), delim, false);\n        mutt_buffer_addstr(buf, term);\n        break;\n      case MUTT_BODY:\n        mutt_buffer_addstr(buf, \"BODY \");\n        imap_quote_string(term, sizeof(term), pat->p.str, false);\n        mutt_buffer_addstr(buf, term);\n        break;\n      case MUTT_WHOLE_MSG:\n        mutt_buffer_addstr(buf, \"TEXT \");\n        imap_quote_string(term, sizeof(term), pat->p.str, false);\n        mutt_buffer_addstr(buf, term);\n        break;\n      case MUTT_SERVERSEARCH:\n      {\n        struct ImapData *idata = ctx->data;\n        if (!mutt_bit_isset(idata->capabilities, X_GM_EXT1))\n        {\n          mutt_error(_(\"Server-side custom search not supported: %s\"), pat->p.str);\n          return -1;\n        }\n      }\n        mutt_buffer_addstr(buf, \"X-GM-RAW \");\n        imap_quote_string(term, sizeof(term), pat->p.str, false);\n        mutt_buffer_addstr(buf, term);\n        break;\n    }\n  }\n\n  return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -55,7 +55,7 @@\n           return -1;\n         }\n         *delim = '\\0';\n-        imap_quote_string(term, sizeof(term), pat->p.str);\n+        imap_quote_string(term, sizeof(term), pat->p.str, false);\n         mutt_buffer_addstr(buf, term);\n         mutt_buffer_addch(buf, ' ');\n \n@@ -63,17 +63,17 @@\n         *delim = ':';\n         delim++;\n         SKIPWS(delim);\n-        imap_quote_string(term, sizeof(term), delim);\n+        imap_quote_string(term, sizeof(term), delim, false);\n         mutt_buffer_addstr(buf, term);\n         break;\n       case MUTT_BODY:\n         mutt_buffer_addstr(buf, \"BODY \");\n-        imap_quote_string(term, sizeof(term), pat->p.str);\n+        imap_quote_string(term, sizeof(term), pat->p.str, false);\n         mutt_buffer_addstr(buf, term);\n         break;\n       case MUTT_WHOLE_MSG:\n         mutt_buffer_addstr(buf, \"TEXT \");\n-        imap_quote_string(term, sizeof(term), pat->p.str);\n+        imap_quote_string(term, sizeof(term), pat->p.str, false);\n         mutt_buffer_addstr(buf, term);\n         break;\n       case MUTT_SERVERSEARCH:\n@@ -86,7 +86,7 @@\n         }\n       }\n         mutt_buffer_addstr(buf, \"X-GM-RAW \");\n-        imap_quote_string(term, sizeof(term), pat->p.str);\n+        imap_quote_string(term, sizeof(term), pat->p.str, false);\n         mutt_buffer_addstr(buf, term);\n         break;\n     }",
        "diff_line_info": {
            "deleted_lines": [
                "        imap_quote_string(term, sizeof(term), pat->p.str);",
                "        imap_quote_string(term, sizeof(term), delim);",
                "        imap_quote_string(term, sizeof(term), pat->p.str);",
                "        imap_quote_string(term, sizeof(term), pat->p.str);",
                "        imap_quote_string(term, sizeof(term), pat->p.str);"
            ],
            "added_lines": [
                "        imap_quote_string(term, sizeof(term), pat->p.str, false);",
                "        imap_quote_string(term, sizeof(term), delim, false);",
                "        imap_quote_string(term, sizeof(term), pat->p.str, false);",
                "        imap_quote_string(term, sizeof(term), pat->p.str, false);",
                "        imap_quote_string(term, sizeof(term), pat->p.str, false);"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-14357",
        "func_name": "neomutt/cmd_parse_lsub",
        "description": "An issue was discovered in Mutt before 1.10.1 and NeoMutt before 2018-07-16. They allow remote IMAP servers to execute arbitrary commands via backquote characters, related to the mailboxes command associated with an automatic subscription.",
        "git_url": "https://github.com/neomutt/neomutt/commit/e52393740334443ae0206cab2d7caef381646725",
        "commit_title": "quote imap strings more carefully",
        "commit_text": " Co-authored-by: JerikoOne <jeriko.one@gmx.us>",
        "func_before": "static void cmd_parse_lsub(struct ImapData *idata, char *s)\n{\n  char buf[STRING];\n  char errstr[STRING];\n  struct Buffer err, token;\n  struct Url url;\n  struct ImapList list;\n\n  if (idata->cmddata && idata->cmdtype == IMAP_CT_LIST)\n  {\n    /* caller will handle response itself */\n    cmd_parse_list(idata, s);\n    return;\n  }\n\n  if (!ImapCheckSubscribed)\n    return;\n\n  idata->cmdtype = IMAP_CT_LIST;\n  idata->cmddata = &list;\n  cmd_parse_list(idata, s);\n  idata->cmddata = NULL;\n  /* noselect is for a gmail quirk (#3445) */\n  if (!list.name || list.noselect)\n    return;\n\n  mutt_debug(3, \"Subscribing to %s\\n\", list.name);\n\n  mutt_str_strfcpy(buf, \"mailboxes \\\"\", sizeof(buf));\n  mutt_account_tourl(&idata->conn->account, &url);\n  /* escape \\ and \" */\n  imap_quote_string(errstr, sizeof(errstr), list.name);\n  url.path = errstr + 1;\n  url.path[strlen(url.path) - 1] = '\\0';\n  if (mutt_str_strcmp(url.user, ImapUser) == 0)\n    url.user = NULL;\n  url_tostring(&url, buf + 11, sizeof(buf) - 11, 0);\n  mutt_str_strcat(buf, sizeof(buf), \"\\\"\");\n  mutt_buffer_init(&token);\n  mutt_buffer_init(&err);\n  err.data = errstr;\n  err.dsize = sizeof(errstr);\n  if (mutt_parse_rc_line(buf, &token, &err))\n    mutt_debug(1, \"Error adding subscribed mailbox: %s\\n\", errstr);\n  FREE(&token.data);\n}",
        "func": "static void cmd_parse_lsub(struct ImapData *idata, char *s)\n{\n  char buf[STRING];\n  char errstr[STRING];\n  struct Buffer err, token;\n  struct Url url;\n  struct ImapList list;\n\n  if (idata->cmddata && idata->cmdtype == IMAP_CT_LIST)\n  {\n    /* caller will handle response itself */\n    cmd_parse_list(idata, s);\n    return;\n  }\n\n  if (!ImapCheckSubscribed)\n    return;\n\n  idata->cmdtype = IMAP_CT_LIST;\n  idata->cmddata = &list;\n  cmd_parse_list(idata, s);\n  idata->cmddata = NULL;\n  /* noselect is for a gmail quirk (#3445) */\n  if (!list.name || list.noselect)\n    return;\n\n  mutt_debug(3, \"Subscribing to %s\\n\", list.name);\n\n  mutt_str_strfcpy(buf, \"mailboxes \\\"\", sizeof(buf));\n  mutt_account_tourl(&idata->conn->account, &url);\n  /* escape \\ and \" */\n  imap_quote_string(errstr, sizeof(errstr), list.name, true);\n  url.path = errstr + 1;\n  url.path[strlen(url.path) - 1] = '\\0';\n  if (mutt_str_strcmp(url.user, ImapUser) == 0)\n    url.user = NULL;\n  url_tostring(&url, buf + 11, sizeof(buf) - 11, 0);\n  mutt_str_strcat(buf, sizeof(buf), \"\\\"\");\n  mutt_buffer_init(&token);\n  mutt_buffer_init(&err);\n  err.data = errstr;\n  err.dsize = sizeof(errstr);\n  if (mutt_parse_rc_line(buf, &token, &err))\n    mutt_debug(1, \"Error adding subscribed mailbox: %s\\n\", errstr);\n  FREE(&token.data);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -29,7 +29,7 @@\n   mutt_str_strfcpy(buf, \"mailboxes \\\"\", sizeof(buf));\n   mutt_account_tourl(&idata->conn->account, &url);\n   /* escape \\ and \" */\n-  imap_quote_string(errstr, sizeof(errstr), list.name);\n+  imap_quote_string(errstr, sizeof(errstr), list.name, true);\n   url.path = errstr + 1;\n   url.path[strlen(url.path) - 1] = '\\0';\n   if (mutt_str_strcmp(url.user, ImapUser) == 0)",
        "diff_line_info": {
            "deleted_lines": [
                "  imap_quote_string(errstr, sizeof(errstr), list.name);"
            ],
            "added_lines": [
                "  imap_quote_string(errstr, sizeof(errstr), list.name, true);"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-14357",
        "func_name": "neomutt/imap_quote_string",
        "description": "An issue was discovered in Mutt before 1.10.1 and NeoMutt before 2018-07-16. They allow remote IMAP servers to execute arbitrary commands via backquote characters, related to the mailboxes command associated with an automatic subscription.",
        "git_url": "https://github.com/neomutt/neomutt/commit/e52393740334443ae0206cab2d7caef381646725",
        "commit_title": "quote imap strings more carefully",
        "commit_text": " Co-authored-by: JerikoOne <jeriko.one@gmx.us>",
        "func_before": "void imap_quote_string(char *dest, size_t dlen, const char *src)\n{\n  static const char quote[] = \"\\\"\\\\\";\n  char *pt = dest;\n  const char *s = src;\n\n  *pt++ = '\"';\n  /* save room for trailing quote-char */\n  dlen -= 2;\n\n  for (; *s && dlen; s++)\n  {\n    if (strchr(quote, *s))\n    {\n      dlen -= 2;\n      if (dlen == 0)\n        break;\n      *pt++ = '\\\\';\n      *pt++ = *s;\n    }\n    else\n    {\n      *pt++ = *s;\n      dlen--;\n    }\n  }\n  *pt++ = '\"';\n  *pt = '\\0';\n}",
        "func": "void imap_quote_string(char *dest, size_t dlen, const char *src, bool quote_backtick)\n{\n  const char *quote = \"`\\\"\\\\\";\n  if (!quote_backtick)\n    quote++;\n\n  char *pt = dest;\n  const char *s = src;\n\n  *pt++ = '\"';\n  /* save room for trailing quote-char */\n  dlen -= 2;\n\n  for (; *s && dlen; s++)\n  {\n    if (strchr(quote, *s))\n    {\n      dlen -= 2;\n      if (dlen == 0)\n        break;\n      *pt++ = '\\\\';\n      *pt++ = *s;\n    }\n    else\n    {\n      *pt++ = *s;\n      dlen--;\n    }\n  }\n  *pt++ = '\"';\n  *pt = '\\0';\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,9 @@\n-void imap_quote_string(char *dest, size_t dlen, const char *src)\n+void imap_quote_string(char *dest, size_t dlen, const char *src, bool quote_backtick)\n {\n-  static const char quote[] = \"\\\"\\\\\";\n+  const char *quote = \"`\\\"\\\\\";\n+  if (!quote_backtick)\n+    quote++;\n+\n   char *pt = dest;\n   const char *s = src;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "void imap_quote_string(char *dest, size_t dlen, const char *src)",
                "  static const char quote[] = \"\\\"\\\\\";"
            ],
            "added_lines": [
                "void imap_quote_string(char *dest, size_t dlen, const char *src, bool quote_backtick)",
                "  const char *quote = \"`\\\"\\\\\";",
                "  if (!quote_backtick)",
                "    quote++;",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2018-14357",
        "func_name": "neomutt/imap_munge_mbox_name",
        "description": "An issue was discovered in Mutt before 1.10.1 and NeoMutt before 2018-07-16. They allow remote IMAP servers to execute arbitrary commands via backquote characters, related to the mailboxes command associated with an automatic subscription.",
        "git_url": "https://github.com/neomutt/neomutt/commit/e52393740334443ae0206cab2d7caef381646725",
        "commit_title": "quote imap strings more carefully",
        "commit_text": " Co-authored-by: JerikoOne <jeriko.one@gmx.us>",
        "func_before": "void imap_munge_mbox_name(struct ImapData *idata, char *dest, size_t dlen, const char *src)\n{\n  char *buf = mutt_str_strdup(src);\n  imap_utf_encode(idata, &buf);\n\n  imap_quote_string(dest, dlen, buf);\n\n  FREE(&buf);\n}",
        "func": "void imap_munge_mbox_name(struct ImapData *idata, char *dest, size_t dlen, const char *src)\n{\n  char *buf = mutt_str_strdup(src);\n  imap_utf_encode(idata, &buf);\n\n  imap_quote_string(dest, dlen, buf, false);\n\n  FREE(&buf);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,7 +3,7 @@\n   char *buf = mutt_str_strdup(src);\n   imap_utf_encode(idata, &buf);\n \n-  imap_quote_string(dest, dlen, buf);\n+  imap_quote_string(dest, dlen, buf, false);\n \n   FREE(&buf);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "  imap_quote_string(dest, dlen, buf);"
            ],
            "added_lines": [
                "  imap_quote_string(dest, dlen, buf, false);"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-10900",
        "func_name": "GNOME/NetworkManager-vpnc/validate_one_property",
        "description": "Network Manager VPNC plugin (aka networkmanager-vpnc) before version 1.2.6 is vulnerable to a privilege escalation attack. A new line character can be used to inject a Password helper parameter into the configuration data passed to VPNC, allowing an attacker to execute arbitrary commands as root.",
        "git_url": "https://github.com/GNOME/NetworkManager-vpnc/commit/07ac18a32b4e361a27ef48ac757d36cbb46e8e12",
        "commit_title": "service: disallow newlinies in configuration values (CVE-2018-10900)",
        "commit_text": " The vpnc configuration format doesn't allow those. vpnc(8):    The values start exactly one space after the keywords, and run to the end   of line. This lets you put any kind of weird character (except CR, LF and   NUL) in your strings  We have no choice but to reject them. If we didn't it would allow the user to inject arbitrary configuration directives with potential security implications.  https://pulsesecurity.co.nz/advisories/NM-VPNC-Privesc  Reported by: Denis Andzakovic",
        "func_before": "static void\nvalidate_one_property (const char *key, const char *value, gpointer user_data)\n{\n\tValidateInfo *info = (ValidateInfo *) user_data;\n\tValidProperty *prop = NULL;\n\tlong int tmp;\n\tint i;\n\n\tif (*(info->error))\n\t\treturn;\n\n\tinfo->have_items = TRUE;\n\n\t/* 'name' is the setting name; always allowed but unused */\n\tif (!strcmp (key, NM_SETTING_NAME))\n\t\treturn;\n\n\tfor (i = 0; info->table[i].name; i++) {\n\t\tprop = &info->table[i];\n\t\tif (g_strcmp0 (prop->name, key) == 0)\n\t\t\tbreak;\n\t}\n\n\t/* Did not find the property from valid_properties or the type did not match */\n\tif (!prop || !prop->name) {\n\t\tg_set_error (info->error,\n\t\t             NM_VPN_PLUGIN_ERROR,\n\t\t             NM_VPN_PLUGIN_ERROR_BAD_ARGUMENTS,\n\t\t             _(\"property %s invalid or not supported\"),\n\t\t             key);\n\t\treturn;\n\t}\n\n\t/* Validate the property */\n\tswitch (prop->type) {\n\tcase ITEM_TYPE_IGNORED:\n\t\tbreak; /* technically valid, but unused */\n\tcase ITEM_TYPE_STRING:\n\tcase ITEM_TYPE_SECRET:\n\t\tbreak; /* valid */\n\tcase ITEM_TYPE_PATH:\n\t\tif (   !value\n\t\t    || !strlen (value)\n\t\t    || !g_path_is_absolute (value)\n\t\t    || !g_file_test (value, G_FILE_TEST_EXISTS)) {\n\t\t\tg_set_error (info->error,\n\t\t\t             NM_VPN_PLUGIN_ERROR,\n\t\t\t             NM_VPN_PLUGIN_ERROR_BAD_ARGUMENTS,\n\t\t\t             _(\"property %s file path %s is not absolute or does not exist\"),\n\t\t\t             key, value);\n\t\t}\n\t\tbreak;\n\tcase ITEM_TYPE_INT:\n\t\terrno = 0;\n\t\ttmp = strtol (value, NULL, 10);\n\t\tif (errno == 0 && tmp >= prop->int_min && tmp <= prop->int_max)\n\t\t\tbreak; /* valid */\n\n\t\tg_set_error (info->error,\n\t\t             NM_VPN_PLUGIN_ERROR,\n\t\t             NM_VPN_PLUGIN_ERROR_BAD_ARGUMENTS,\n\t\t             _(\"invalid integer property %s or out of range [%d -> %d]\"),\n\t\t             key, prop->int_min, prop->int_max);\n\t\tbreak;\n\tcase ITEM_TYPE_BOOLEAN:\n\t\tif (!strcmp (value, \"yes\") || !strcmp (value, \"no\"))\n\t\t\tbreak; /* valid */\n\n\t\tg_set_error (info->error,\n\t\t             NM_VPN_PLUGIN_ERROR,\n\t\t             NM_VPN_PLUGIN_ERROR_BAD_ARGUMENTS,\n\t\t             _(\"invalid boolean property %s (not yes or no)\"),\n\t\t             key);\n\t\tbreak;\n\tdefault:\n\t\tg_set_error (info->error,\n\t\t             NM_VPN_PLUGIN_ERROR,\n\t\t             NM_VPN_PLUGIN_ERROR_BAD_ARGUMENTS,\n\t\t             _(\"unhandled property %s type %d\"),\n\t\t             key, prop->type);\n\t\tbreak;\n\t}\n}",
        "func": "static void\nvalidate_one_property (const char *key, const char *value, gpointer user_data)\n{\n\tValidateInfo *info = (ValidateInfo *) user_data;\n\tValidProperty *prop = NULL;\n\tlong int tmp;\n\tint i;\n\n\tif (*(info->error))\n\t\treturn;\n\n\tinfo->have_items = TRUE;\n\n\t/* 'name' is the setting name; always allowed but unused */\n\tif (!strcmp (key, NM_SETTING_NAME))\n\t\treturn;\n\n\tfor (i = 0; info->table[i].name; i++) {\n\t\tprop = &info->table[i];\n\t\tif (g_strcmp0 (prop->name, key) == 0)\n\t\t\tbreak;\n\t}\n\n\t/* Did not find the property from valid_properties or the type did not match */\n\tif (!prop || !prop->name) {\n\t\tg_set_error (info->error,\n\t\t             NM_VPN_PLUGIN_ERROR,\n\t\t             NM_VPN_PLUGIN_ERROR_BAD_ARGUMENTS,\n\t\t             _(\"property %s invalid or not supported\"),\n\t\t             key);\n\t\treturn;\n\t}\n\n\t/* Validate the property */\n\tswitch (prop->type) {\n\tcase ITEM_TYPE_IGNORED:\n\t\tbreak; /* technically valid, but unused */\n\tcase ITEM_TYPE_STRING:\n\tcase ITEM_TYPE_SECRET:\n\t\tif (strchr (value, '\\n') || strchr (value, '\\r')) {\n\t\t\tg_set_error (info->error,\n\t\t\t             NM_VPN_PLUGIN_ERROR,\n\t\t\t             NM_VPN_PLUGIN_ERROR_BAD_ARGUMENTS,\n\t\t\t             _(\"property %s contains a newline character\"),\n\t\t\t             key);\n\t\t}\n\t\tbreak;\n\tcase ITEM_TYPE_PATH:\n\t\tif (   !value\n\t\t    || !strlen (value)\n\t\t    || !g_path_is_absolute (value)\n\t\t    || !g_file_test (value, G_FILE_TEST_EXISTS)) {\n\t\t\tg_set_error (info->error,\n\t\t\t             NM_VPN_PLUGIN_ERROR,\n\t\t\t             NM_VPN_PLUGIN_ERROR_BAD_ARGUMENTS,\n\t\t\t             _(\"property %s file path %s is not absolute or does not exist\"),\n\t\t\t             key, value);\n\t\t}\n\t\tbreak;\n\tcase ITEM_TYPE_INT:\n\t\terrno = 0;\n\t\ttmp = strtol (value, NULL, 10);\n\t\tif (errno == 0 && tmp >= prop->int_min && tmp <= prop->int_max)\n\t\t\tbreak; /* valid */\n\n\t\tg_set_error (info->error,\n\t\t             NM_VPN_PLUGIN_ERROR,\n\t\t             NM_VPN_PLUGIN_ERROR_BAD_ARGUMENTS,\n\t\t             _(\"invalid integer property %s or out of range [%d -> %d]\"),\n\t\t             key, prop->int_min, prop->int_max);\n\t\tbreak;\n\tcase ITEM_TYPE_BOOLEAN:\n\t\tif (!strcmp (value, \"yes\") || !strcmp (value, \"no\"))\n\t\t\tbreak; /* valid */\n\n\t\tg_set_error (info->error,\n\t\t             NM_VPN_PLUGIN_ERROR,\n\t\t             NM_VPN_PLUGIN_ERROR_BAD_ARGUMENTS,\n\t\t             _(\"invalid boolean property %s (not yes or no)\"),\n\t\t             key);\n\t\tbreak;\n\tdefault:\n\t\tg_set_error (info->error,\n\t\t             NM_VPN_PLUGIN_ERROR,\n\t\t             NM_VPN_PLUGIN_ERROR_BAD_ARGUMENTS,\n\t\t             _(\"unhandled property %s type %d\"),\n\t\t             key, prop->type);\n\t\tbreak;\n\t}\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -37,7 +37,14 @@\n \t\tbreak; /* technically valid, but unused */\n \tcase ITEM_TYPE_STRING:\n \tcase ITEM_TYPE_SECRET:\n-\t\tbreak; /* valid */\n+\t\tif (strchr (value, '\\n') || strchr (value, '\\r')) {\n+\t\t\tg_set_error (info->error,\n+\t\t\t             NM_VPN_PLUGIN_ERROR,\n+\t\t\t             NM_VPN_PLUGIN_ERROR_BAD_ARGUMENTS,\n+\t\t\t             _(\"property %s contains a newline character\"),\n+\t\t\t             key);\n+\t\t}\n+\t\tbreak;\n \tcase ITEM_TYPE_PATH:\n \t\tif (   !value\n \t\t    || !strlen (value)",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tbreak; /* valid */"
            ],
            "added_lines": [
                "\t\tif (strchr (value, '\\n') || strchr (value, '\\r')) {",
                "\t\t\tg_set_error (info->error,",
                "\t\t\t             NM_VPN_PLUGIN_ERROR,",
                "\t\t\t             NM_VPN_PLUGIN_ERROR_BAD_ARGUMENTS,",
                "\t\t\t             _(\"property %s contains a newline character\"),",
                "\t\t\t             key);",
                "\t\t}",
                "\t\tbreak;"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-1350",
        "func_name": "lwindolf/liferea/update_job_run",
        "description": "A vulnerability was found in liferea. It has been rated as critical. Affected by this issue is the function update_job_run of the file src/update.c of the component Feed Enrichment. The manipulation of the argument source with the input |date &gt;/tmp/bad-item-link.txt leads to os command injection. The attack may be launched remotely. The exploit has been disclosed to the public and may be used. The name of the patch is 8d8b5b963fa64c7a2122d1bbfbb0bed46e813e59. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-222848.",
        "git_url": "https://github.com/lwindolf/liferea/commit/8d8b5b963fa64c7a2122d1bbfbb0bed46e813e59",
        "commit_title": "Fix RCE vulnerability on feed enrichment",
        "commit_text": " Currently there are a few places in the code that do not check URLs for the presence of a command prefix, allowing malicious websites to run any command in the local system.  Trying to run feed enrichment (i.e. after option \"Extract full content from HTML5 and Google AMP\" is enabled) in a subscription that produces this item:      <item>       <title>Check /tmp/bad-item-link.txt</title>       <link>|date &gt;/tmp/bad-item-link.txt</link>     </item>  will cause Liferea to call update_request_new on URL \"|date >/tmp/bad-item-link.txt\" and then blindly run the command. A similar effect happens when running the feed enrichment in a item that links to a document like this:      <!DOCTYPE html>     <html>      <head>       <title>AMP URL RCE PoC</title>       <link rel=\"amphtml\" href=\"|date &gt; /tmp/bad-amp-url.txt\">      </head>      <body>          Check the results in /tmp/bad-amp-url.txt      </body>     </html>  once Liferea tries to load the AMP URL.  There are other calls to update_request_* functions where URLs are validated correctly (e.g. in feed icons and comments) and do not trigger this vulnerability. Since the subscription update is the exception where feed commands are supported (and welcome!) I chose to lock this feature behind a non-persistent flag and only enable it when required. This is safer than adding the flag in updateOptions, which is usually reused in subordinate requests.  This failure exists since commits b8288389820a3f510ef4b21684b22439c41d95a5 and b67dbba73443ab7b36fcd3c78aa803e974c0f23e from Setember 2017.",
        "func_before": "static void\nupdate_job_run (updateJobPtr job)\n{\n\t/* Here we decide on the source type and the proper execution\n\t   methods which then do anything they want with the job and\n\t   pass the processed job to update_process_finished_job()\n\t   for result dequeuing */\n\n\t/* everything starting with '|' is a local command */\n\tif (*(job->request->source) == '|') {\n\t\tdebug1 (DEBUG_UPDATE, \"Recognized local command: %s\", job->request->source);\n\t\tupdate_exec_cmd (job);\n\t\treturn;\n\t}\n\n\t/* if it has a protocol \"://\" prefix, but not \"file://\" it is an URI */\n\tif (strstr (job->request->source, \"://\") && strncmp (job->request->source, \"file://\", 7)) {\n\t\tnetwork_process_request (job);\n\t\treturn;\n\t}\n\n\t/* otherwise it must be a local file... */\n\t{\n\t\tdebug1 (DEBUG_UPDATE, \"Recognized file URI: %s\", job->request->source);\n\t\tupdate_load_file (job);\n\t\treturn;\n\t}\n}",
        "func": "static void\nupdate_job_run (updateJobPtr job)\n{\n\t/* Here we decide on the source type and the proper execution\n\t   methods which then do anything they want with the job and\n\t   pass the processed job to update_process_finished_job()\n\t   for result dequeuing */\n\n\t/* everything starting with '|' is a local command */\n\tif (*(job->request->source) == '|') {\n\t\tif (job->request->allowCommands) {\n\t\t\tdebug1 (DEBUG_UPDATE, \"Recognized local command: %s\", job->request->source);\n\t\t\tupdate_exec_cmd (job);\n\t\t} else {\n\t\t\tdebug1 (DEBUG_UPDATE, \"Refusing to run local command from unexpected source: %s\", job->request->source);\n\t\t\tjob->result->httpstatus = 403;  /* Forbidden. */\n\t\t\tupdate_process_finished_job (job);\n\t\t}\n\t\treturn;\n\t}\n\n\t/* if it has a protocol \"://\" prefix, but not \"file://\" it is an URI */\n\tif (strstr (job->request->source, \"://\") && strncmp (job->request->source, \"file://\", 7)) {\n\t\tnetwork_process_request (job);\n\t\treturn;\n\t}\n\n\t/* otherwise it must be a local file... */\n\t{\n\t\tdebug1 (DEBUG_UPDATE, \"Recognized file URI: %s\", job->request->source);\n\t\tupdate_load_file (job);\n\t\treturn;\n\t}\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -8,8 +8,14 @@\n \n \t/* everything starting with '|' is a local command */\n \tif (*(job->request->source) == '|') {\n-\t\tdebug1 (DEBUG_UPDATE, \"Recognized local command: %s\", job->request->source);\n-\t\tupdate_exec_cmd (job);\n+\t\tif (job->request->allowCommands) {\n+\t\t\tdebug1 (DEBUG_UPDATE, \"Recognized local command: %s\", job->request->source);\n+\t\t\tupdate_exec_cmd (job);\n+\t\t} else {\n+\t\t\tdebug1 (DEBUG_UPDATE, \"Refusing to run local command from unexpected source: %s\", job->request->source);\n+\t\t\tjob->result->httpstatus = 403;  /* Forbidden. */\n+\t\t\tupdate_process_finished_job (job);\n+\t\t}\n \t\treturn;\n \t}\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tdebug1 (DEBUG_UPDATE, \"Recognized local command: %s\", job->request->source);",
                "\t\tupdate_exec_cmd (job);"
            ],
            "added_lines": [
                "\t\tif (job->request->allowCommands) {",
                "\t\t\tdebug1 (DEBUG_UPDATE, \"Recognized local command: %s\", job->request->source);",
                "\t\t\tupdate_exec_cmd (job);",
                "\t\t} else {",
                "\t\t\tdebug1 (DEBUG_UPDATE, \"Refusing to run local command from unexpected source: %s\", job->request->source);",
                "\t\t\tjob->result->httpstatus = 403;  /* Forbidden. */",
                "\t\t\tupdate_process_finished_job (job);",
                "\t\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-1350",
        "func_name": "lwindolf/liferea/subscription_update",
        "description": "A vulnerability was found in liferea. It has been rated as critical. Affected by this issue is the function update_job_run of the file src/update.c of the component Feed Enrichment. The manipulation of the argument source with the input |date &gt;/tmp/bad-item-link.txt leads to os command injection. The attack may be launched remotely. The exploit has been disclosed to the public and may be used. The name of the patch is 8d8b5b963fa64c7a2122d1bbfbb0bed46e813e59. It is recommended to apply a patch to fix this issue. The identifier of this vulnerability is VDB-222848.",
        "git_url": "https://github.com/lwindolf/liferea/commit/8d8b5b963fa64c7a2122d1bbfbb0bed46e813e59",
        "commit_title": "Fix RCE vulnerability on feed enrichment",
        "commit_text": " Currently there are a few places in the code that do not check URLs for the presence of a command prefix, allowing malicious websites to run any command in the local system.  Trying to run feed enrichment (i.e. after option \"Extract full content from HTML5 and Google AMP\" is enabled) in a subscription that produces this item:      <item>       <title>Check /tmp/bad-item-link.txt</title>       <link>|date &gt;/tmp/bad-item-link.txt</link>     </item>  will cause Liferea to call update_request_new on URL \"|date >/tmp/bad-item-link.txt\" and then blindly run the command. A similar effect happens when running the feed enrichment in a item that links to a document like this:      <!DOCTYPE html>     <html>      <head>       <title>AMP URL RCE PoC</title>       <link rel=\"amphtml\" href=\"|date &gt; /tmp/bad-amp-url.txt\">      </head>      <body>          Check the results in /tmp/bad-amp-url.txt      </body>     </html>  once Liferea tries to load the AMP URL.  There are other calls to update_request_* functions where URLs are validated correctly (e.g. in feed icons and comments) and do not trigger this vulnerability. Since the subscription update is the exception where feed commands are supported (and welcome!) I chose to lock this feature behind a non-persistent flag and only enable it when required. This is safer than adding the flag in updateOptions, which is usually reused in subordinate requests.  This failure exists since commits b8288389820a3f510ef4b21684b22439c41d95a5 and b67dbba73443ab7b36fcd3c78aa803e974c0f23e from Setember 2017.",
        "func_before": "void\nsubscription_update (subscriptionPtr subscription, guint flags)\n{\n\tUpdateRequest\t*request;\n\tguint64\t\tnow;\n\tguint\t\tcount, maxcount;\n\n\tif (!subscription)\n\t\treturn;\n\n\tif (subscription->updateJob)\n\t\treturn;\n\n\tdebug1 (DEBUG_UPDATE, \"Scheduling %s to be updated\", node_get_title (subscription->node));\n\n\tif (subscription_can_be_updated (subscription)) {\n\t\tnow = g_get_real_time();\n\t\tsubscription_reset_update_counter (subscription, &now);\n\n\t\trequest = update_request_new (\n\t\t\tsubscription_get_source (subscription),\n\t\t\tsubscription->updateState,\n\t\t\tsubscription->updateOptions\n\t\t);\n\n\t\tif (subscription_get_filter (subscription))\n\t\t\trequest->filtercmd = g_strdup (subscription_get_filter (subscription));\n\n\t\tif (SUBSCRIPTION_TYPE (subscription)->prepare_update_request (subscription, request))\n\t\t\tsubscription->updateJob = update_execute_request (subscription, request, subscription_process_update_result, subscription, flags);\n\t\telse\n\t\t\tg_object_unref (request);\n\n\t\tupdate_jobs_get_count (&count, &maxcount);\n\t\tif (count > 1)\n\t\t\tliferea_shell_set_status_bar (_(\"Updating (%d / %d) ...\"), maxcount - count, maxcount);\n\t\telse\n\t\t\tliferea_shell_set_status_bar (_(\"Updating '%s'...\"), node_get_title (subscription->node));\n\t}\n}",
        "func": "void\nsubscription_update (subscriptionPtr subscription, guint flags)\n{\n\tUpdateRequest\t*request;\n\tguint64\t\tnow;\n\tguint\t\tcount, maxcount;\n\n\tif (!subscription)\n\t\treturn;\n\n\tif (subscription->updateJob)\n\t\treturn;\n\n\tdebug1 (DEBUG_UPDATE, \"Scheduling %s to be updated\", node_get_title (subscription->node));\n\n\tif (subscription_can_be_updated (subscription)) {\n\t\tnow = g_get_real_time();\n\t\tsubscription_reset_update_counter (subscription, &now);\n\n\t\trequest = update_request_new (\n\t\t\tsubscription_get_source (subscription),\n\t\t\tsubscription->updateState,\n\t\t\tsubscription->updateOptions\n\t\t);\n\t\tupdate_request_allow_commands (request, TRUE);\n\n\t\tif (subscription_get_filter (subscription))\n\t\t\trequest->filtercmd = g_strdup (subscription_get_filter (subscription));\n\n\t\tif (SUBSCRIPTION_TYPE (subscription)->prepare_update_request (subscription, request))\n\t\t\tsubscription->updateJob = update_execute_request (subscription, request, subscription_process_update_result, subscription, flags);\n\t\telse\n\t\t\tg_object_unref (request);\n\n\t\tupdate_jobs_get_count (&count, &maxcount);\n\t\tif (count > 1)\n\t\t\tliferea_shell_set_status_bar (_(\"Updating (%d / %d) ...\"), maxcount - count, maxcount);\n\t\telse\n\t\t\tliferea_shell_set_status_bar (_(\"Updating '%s'...\"), node_get_title (subscription->node));\n\t}\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -22,6 +22,7 @@\n \t\t\tsubscription->updateState,\n \t\t\tsubscription->updateOptions\n \t\t);\n+\t\tupdate_request_allow_commands (request, TRUE);\n \n \t\tif (subscription_get_filter (subscription))\n \t\t\trequest->filtercmd = g_strdup (subscription_get_filter (subscription));",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\tupdate_request_allow_commands (request, TRUE);"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-24805",
        "func_name": "OpenPrinting/cups-filters/sigterm_handler",
        "description": "cups-filters contains backends, filters, and other software required to get the cups printing service working on operating systems other than macos. If you use the Backend Error Handler (beh) to create an accessible network printer, this security vulnerability can cause remote code execution. `beh.c` contains the line `retval = system(cmdline) >> 8;` which calls the `system` command with the operand `cmdline`. `cmdline` contains multiple user controlled, unsanitized values. As a result an attacker with network access to the hosted print server can exploit this vulnerability to inject system commands which are executed in the context of the running server. This issue has been addressed in commit `8f2740357` and is expected to be bundled in the next release. Users are advised to upgrade when possible and to restrict access to network printers in the meantime.",
        "git_url": "https://github.com/OpenPrinting/cups-filters/commit/8f274035756c04efeb77eb654e9d4c4447287d65",
        "commit_title": "Merge pull request from GHSA-gpxc-v2m8-fr3x",
        "commit_text": " * beh backend: Use execv() instead of system() - CVE-2023-24805  With execv() command line arguments are passed as separate strings and not the full command line in a single string. This prevents arbitrary command execution by escaping the quoting of the arguments in a job with forged job title.  * beh backend: Extra checks against odd/forged input - CVE-2023-24805  - Do not allow '/' in the scheme of the URI (= backend executable   name), to assure that only backends inside /usr/lib/cups/backend/   are used.  - Pre-define scheme buffer to empty string, to be defined for case of   uri being NULL.  - URI must have ':', to split off scheme, otherwise error.  - Check return value of snprintf() to create call path for backend, to   error out on truncation of a too long scheme or on complete failure   due to a completely odd scheme.  * beh backend: Further improvements - CVE-2023-24805  - Use strncat() instead of strncpy() for getting scheme from URI, the latter   does not require setting terminating zero byte in case of truncation.  - Also exclude \".\" or \"..\" as scheme, as directories are not valid CUPS   backends.  - Do not use fprintf() in sigterm_handler(), to not interfere with a   fprintf() which could be running in the main process when   sigterm_handler() is triggered.  - Use \"static volatile int\" for global variable job_canceled.",
        "func_before": "static void\nsigterm_handler(int sig)\t\t// I - Signal number (unused)\n{\n  (void)sig;\n\n  fprintf(stderr,\n\t  \"DEBUG: beh: Job canceled.\\n\");\n\n  if (job_canceled)\n    _exit(CUPS_BACKEND_OK);\n  else\n    job_canceled = 1;\n}",
        "func": "static void\nsigterm_handler(int sig)\t\t// I - Signal number (unused)\n{\n  (void)sig;\n\n  const char * const msg = \"DEBUG: beh: Job canceled.\\n\";\n  // The if() is to eliminate the return value and silence the warning\n  // about an unused return value.\n  if (write(2, msg, strlen(msg)));\n\n  if (job_canceled)\n    _exit(CUPS_BACKEND_OK);\n  else\n    job_canceled = 1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,8 +3,10 @@\n {\n   (void)sig;\n \n-  fprintf(stderr,\n-\t  \"DEBUG: beh: Job canceled.\\n\");\n+  const char * const msg = \"DEBUG: beh: Job canceled.\\n\";\n+  // The if() is to eliminate the return value and silence the warning\n+  // about an unused return value.\n+  if (write(2, msg, strlen(msg)));\n \n   if (job_canceled)\n     _exit(CUPS_BACKEND_OK);",
        "diff_line_info": {
            "deleted_lines": [
                "  fprintf(stderr,",
                "\t  \"DEBUG: beh: Job canceled.\\n\");"
            ],
            "added_lines": [
                "  const char * const msg = \"DEBUG: beh: Job canceled.\\n\";",
                "  // The if() is to eliminate the return value and silence the warning",
                "  // about an unused return value.",
                "  if (write(2, msg, strlen(msg)));"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-24805",
        "func_name": "OpenPrinting/cups-filters/call_backend",
        "description": "cups-filters contains backends, filters, and other software required to get the cups printing service working on operating systems other than macos. If you use the Backend Error Handler (beh) to create an accessible network printer, this security vulnerability can cause remote code execution. `beh.c` contains the line `retval = system(cmdline) >> 8;` which calls the `system` command with the operand `cmdline`. `cmdline` contains multiple user controlled, unsanitized values. As a result an attacker with network access to the hosted print server can exploit this vulnerability to inject system commands which are executed in the context of the running server. This issue has been addressed in commit `8f2740357` and is expected to be bundled in the next release. Users are advised to upgrade when possible and to restrict access to network printers in the meantime.",
        "git_url": "https://github.com/OpenPrinting/cups-filters/commit/8f274035756c04efeb77eb654e9d4c4447287d65",
        "commit_title": "Merge pull request from GHSA-gpxc-v2m8-fr3x",
        "commit_text": " * beh backend: Use execv() instead of system() - CVE-2023-24805  With execv() command line arguments are passed as separate strings and not the full command line in a single string. This prevents arbitrary command execution by escaping the quoting of the arguments in a job with forged job title.  * beh backend: Extra checks against odd/forged input - CVE-2023-24805  - Do not allow '/' in the scheme of the URI (= backend executable   name), to assure that only backends inside /usr/lib/cups/backend/   are used.  - Pre-define scheme buffer to empty string, to be defined for case of   uri being NULL.  - URI must have ':', to split off scheme, otherwise error.  - Check return value of snprintf() to create call path for backend, to   error out on truncation of a too long scheme or on complete failure   due to a completely odd scheme.  * beh backend: Further improvements - CVE-2023-24805  - Use strncat() instead of strncpy() for getting scheme from URI, the latter   does not require setting terminating zero byte in case of truncation.  - Also exclude \".\" or \"..\" as scheme, as directories are not valid CUPS   backends.  - Do not use fprintf() in sigterm_handler(), to not interfere with a   fprintf() which could be running in the main process when   sigterm_handler() is triggered.  - Use \"static volatile int\" for global variable job_canceled.",
        "func_before": "static int\ncall_backend(char *uri,                 // I - URI of final destination\n\t     int  argc,                 // I - Number of command line\n\t                                //     arguments\n\t     char **argv,\t\t// I - Command-line arguments\n\t     char *filename)            // I - File name of input data\n{\n  const char\t*cups_serverbin;\t// Location of programs\n  char\t\tscheme[1024],           // Scheme from URI\n                *ptr,\t\t\t// Pointer into scheme\n\t\tcmdline[65536];\t\t// Backend command line\n  int           retval;\n\n  //\n  // Build the backend command line...\n  //\n\n  strncpy(scheme, uri, sizeof(scheme) - 1);\n  if (strlen(uri) > 1023)\n    scheme[1023] = '\\0';\n  if ((ptr = strchr(scheme, ':')) != NULL)\n    *ptr = '\\0';\n\n  if ((cups_serverbin = getenv(\"CUPS_SERVERBIN\")) == NULL)\n    cups_serverbin = CUPS_SERVERBIN;\n\n  if (!strncasecmp(uri, \"file:\", 5) || uri[0] == '/')\n  {\n    fprintf(stderr,\n\t    \"ERROR: beh: Direct output into a file not supported.\\n\");\n    exit (CUPS_BACKEND_FAILED);\n  }\n  else\n    snprintf(cmdline, sizeof(cmdline),\n\t     \"%s/backend/%s '%s' '%s' '%s' '%s' '%s' %s\",\n\t     cups_serverbin, scheme, argv[1], argv[2], argv[3],\n\t     // Apply number of copies only if beh was called with a\n\t     // file name and not with the print data in stdin, as\n\t     // backends should handle copies only if they are called\n\t     // with a file name\n\t     (argc == 6 ? \"1\" : argv[4]),\n\t     argv[5], filename);\n\n  //\n  // Overwrite the device URI and run the actual backend...\n  //\n\n  setenv(\"DEVICE_URI\", uri, 1);\n\n  fprintf(stderr,\n\t  \"DEBUG: beh: Executing backend command line \\\"%s\\\"...\\n\",\n\t  cmdline);\n  fprintf(stderr,\n\t  \"DEBUG: beh: Using device URI: %s\\n\",\n\t  uri);\n\n  retval = system(cmdline) >> 8;\n\n  if (retval == -1)\n    fprintf(stderr, \"ERROR: Unable to execute backend command line: %s\\n\",\n\t    strerror(errno));\n\n  return (retval);\n}",
        "func": "static int\ncall_backend(char *uri,                 // I - URI of final destination\n\t     int  argc,                 // I - Number of command line\n\t                                //     arguments\n\t     char **argv,\t\t// I - Command-line arguments\n\t     char *filename)            // I - File name of input data\n{\n  const char\t*cups_serverbin;\t// Location of programs\n  char          *backend_argv[8];       // Arguments for called CUPS backend\n  char\t\tscheme[1024],           // Scheme from URI\n                *ptr,\t\t\t// Pointer into scheme\n\t\tbackend_path[2048];\t// Backend path\n  int           pid,\n                wait_pid,\n                wait_status,\n                retval = 0;\n  int           bytes;\n\n\n  //\n  // Build the backend command line...\n  //\n\n  scheme[0] = '\\0';\n  strncat(scheme, uri, sizeof(scheme) - 1);\n  if ((ptr = strchr(scheme, ':')) != NULL)\n    *ptr = '\\0';\n  else\n  {\n    fprintf(stderr,\n\t    \"ERROR: beh: Invalid URI, no colon (':') to mark end of scheme part.\\n\");\n    exit (CUPS_BACKEND_FAILED);\n  }\n  if (strchr(scheme, '/'))\n  {\n    fprintf(stderr,\n\t    \"ERROR: beh: Invalid URI, scheme contains a slash ('/').\\n\");\n    exit (CUPS_BACKEND_FAILED);\n  }\n  if (!strcmp(scheme, \".\") || !strcmp(scheme, \"..\"))\n  {\n    fprintf(stderr,\n\t    \"ERROR: beh: Invalid URI, scheme (\\\"%s\\\") is a directory.\\n\",\n\t    scheme);\n    exit (CUPS_BACKEND_FAILED);\n  }\n  if ((cups_serverbin = getenv(\"CUPS_SERVERBIN\")) == NULL)\n    cups_serverbin = CUPS_SERVERBIN;\n\n  if (!strncasecmp(uri, \"file:\", 5) || uri[0] == '/')\n  {\n    fprintf(stderr,\n\t    \"ERROR: beh: Direct output into a file not supported.\\n\");\n    exit (CUPS_BACKEND_FAILED);\n  }\n\n  backend_argv[0] = uri;\n  backend_argv[1] = argv[1];\n  backend_argv[2] = argv[2];\n  backend_argv[3] = argv[3];\n  backend_argv[4] = (argc == 6 ? \"1\" : argv[4]);\n  backend_argv[5] = argv[5];\n  backend_argv[6] = filename;\n  backend_argv[7] = NULL;\n\n  bytes = snprintf(backend_path, sizeof(backend_path),\n\t\t   \"%s/backend/%s\", cups_serverbin, scheme);\n  if (bytes < 0 || bytes >= sizeof(backend_path))\n  {\n    fprintf(stderr,\n\t    \"ERROR: beh: Invalid scheme (\\\"%s\\\"), could not determing backend path.\\n\",\n\t    scheme);\n    exit (CUPS_BACKEND_FAILED);\n  }\n\n  //\n  // Overwrite the device URI and run the actual backend...\n  //\n\n  setenv(\"DEVICE_URI\", uri, 1);\n\n  fprintf(stderr,\n\t  \"DEBUG: beh: Executing backend command line \\\"%s '%s' '%s' '%s' '%s' '%s'%s%s\\\"...\\n\",\n\t  backend_path, backend_argv[1], backend_argv[2], backend_argv[3],\n\t  backend_argv[4], backend_argv[5],\n\t  (backend_argv[6] && backend_argv[6][0] ? \" \" : \"\"),\n\t  (backend_argv[6] && backend_argv[6][0] ? backend_argv[6] : \"\"));\n  fprintf(stderr,\n\t  \"DEBUG: beh: Using device URI: %s\\n\",\n\t  uri);\n\n  if ((pid = fork()) == 0)\n  {\n    retval = execv(backend_path, backend_argv);\n\n    if (retval == -1)\n      fprintf(stderr, \"ERROR: Unable to execute backend: %s\\n\",\n\t      strerror(errno));\n    exit (CUPS_BACKEND_FAILED);\n  }\n  else if (pid < 0)\n  {\n    fprintf(stderr, \"ERROR: Unable to fork for backend\\n\");\n    return (CUPS_BACKEND_FAILED);\n  }\n\n  while ((wait_pid = wait(&wait_status)) < 0 && errno == EINTR);\n\n  if (wait_pid >= 0 && wait_status)\n  {\n    if (WIFEXITED(wait_status))\n      retval = WEXITSTATUS(wait_status);\n    else if (WTERMSIG(wait_status) != SIGTERM)\n      retval = WTERMSIG(wait_status);\n    else\n      retval = 0;\n  }\n\n  return (retval);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,21 +6,44 @@\n \t     char *filename)            // I - File name of input data\n {\n   const char\t*cups_serverbin;\t// Location of programs\n+  char          *backend_argv[8];       // Arguments for called CUPS backend\n   char\t\tscheme[1024],           // Scheme from URI\n                 *ptr,\t\t\t// Pointer into scheme\n-\t\tcmdline[65536];\t\t// Backend command line\n-  int           retval;\n+\t\tbackend_path[2048];\t// Backend path\n+  int           pid,\n+                wait_pid,\n+                wait_status,\n+                retval = 0;\n+  int           bytes;\n+\n \n   //\n   // Build the backend command line...\n   //\n \n-  strncpy(scheme, uri, sizeof(scheme) - 1);\n-  if (strlen(uri) > 1023)\n-    scheme[1023] = '\\0';\n+  scheme[0] = '\\0';\n+  strncat(scheme, uri, sizeof(scheme) - 1);\n   if ((ptr = strchr(scheme, ':')) != NULL)\n     *ptr = '\\0';\n-\n+  else\n+  {\n+    fprintf(stderr,\n+\t    \"ERROR: beh: Invalid URI, no colon (':') to mark end of scheme part.\\n\");\n+    exit (CUPS_BACKEND_FAILED);\n+  }\n+  if (strchr(scheme, '/'))\n+  {\n+    fprintf(stderr,\n+\t    \"ERROR: beh: Invalid URI, scheme contains a slash ('/').\\n\");\n+    exit (CUPS_BACKEND_FAILED);\n+  }\n+  if (!strcmp(scheme, \".\") || !strcmp(scheme, \"..\"))\n+  {\n+    fprintf(stderr,\n+\t    \"ERROR: beh: Invalid URI, scheme (\\\"%s\\\") is a directory.\\n\",\n+\t    scheme);\n+    exit (CUPS_BACKEND_FAILED);\n+  }\n   if ((cups_serverbin = getenv(\"CUPS_SERVERBIN\")) == NULL)\n     cups_serverbin = CUPS_SERVERBIN;\n \n@@ -30,16 +53,25 @@\n \t    \"ERROR: beh: Direct output into a file not supported.\\n\");\n     exit (CUPS_BACKEND_FAILED);\n   }\n-  else\n-    snprintf(cmdline, sizeof(cmdline),\n-\t     \"%s/backend/%s '%s' '%s' '%s' '%s' '%s' %s\",\n-\t     cups_serverbin, scheme, argv[1], argv[2], argv[3],\n-\t     // Apply number of copies only if beh was called with a\n-\t     // file name and not with the print data in stdin, as\n-\t     // backends should handle copies only if they are called\n-\t     // with a file name\n-\t     (argc == 6 ? \"1\" : argv[4]),\n-\t     argv[5], filename);\n+\n+  backend_argv[0] = uri;\n+  backend_argv[1] = argv[1];\n+  backend_argv[2] = argv[2];\n+  backend_argv[3] = argv[3];\n+  backend_argv[4] = (argc == 6 ? \"1\" : argv[4]);\n+  backend_argv[5] = argv[5];\n+  backend_argv[6] = filename;\n+  backend_argv[7] = NULL;\n+\n+  bytes = snprintf(backend_path, sizeof(backend_path),\n+\t\t   \"%s/backend/%s\", cups_serverbin, scheme);\n+  if (bytes < 0 || bytes >= sizeof(backend_path))\n+  {\n+    fprintf(stderr,\n+\t    \"ERROR: beh: Invalid scheme (\\\"%s\\\"), could not determing backend path.\\n\",\n+\t    scheme);\n+    exit (CUPS_BACKEND_FAILED);\n+  }\n \n   //\n   // Overwrite the device URI and run the actual backend...\n@@ -48,17 +80,41 @@\n   setenv(\"DEVICE_URI\", uri, 1);\n \n   fprintf(stderr,\n-\t  \"DEBUG: beh: Executing backend command line \\\"%s\\\"...\\n\",\n-\t  cmdline);\n+\t  \"DEBUG: beh: Executing backend command line \\\"%s '%s' '%s' '%s' '%s' '%s'%s%s\\\"...\\n\",\n+\t  backend_path, backend_argv[1], backend_argv[2], backend_argv[3],\n+\t  backend_argv[4], backend_argv[5],\n+\t  (backend_argv[6] && backend_argv[6][0] ? \" \" : \"\"),\n+\t  (backend_argv[6] && backend_argv[6][0] ? backend_argv[6] : \"\"));\n   fprintf(stderr,\n \t  \"DEBUG: beh: Using device URI: %s\\n\",\n \t  uri);\n \n-  retval = system(cmdline) >> 8;\n+  if ((pid = fork()) == 0)\n+  {\n+    retval = execv(backend_path, backend_argv);\n \n-  if (retval == -1)\n-    fprintf(stderr, \"ERROR: Unable to execute backend command line: %s\\n\",\n-\t    strerror(errno));\n+    if (retval == -1)\n+      fprintf(stderr, \"ERROR: Unable to execute backend: %s\\n\",\n+\t      strerror(errno));\n+    exit (CUPS_BACKEND_FAILED);\n+  }\n+  else if (pid < 0)\n+  {\n+    fprintf(stderr, \"ERROR: Unable to fork for backend\\n\");\n+    return (CUPS_BACKEND_FAILED);\n+  }\n+\n+  while ((wait_pid = wait(&wait_status)) < 0 && errno == EINTR);\n+\n+  if (wait_pid >= 0 && wait_status)\n+  {\n+    if (WIFEXITED(wait_status))\n+      retval = WEXITSTATUS(wait_status);\n+    else if (WTERMSIG(wait_status) != SIGTERM)\n+      retval = WTERMSIG(wait_status);\n+    else\n+      retval = 0;\n+  }\n \n   return (retval);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tcmdline[65536];\t\t// Backend command line",
                "  int           retval;",
                "  strncpy(scheme, uri, sizeof(scheme) - 1);",
                "  if (strlen(uri) > 1023)",
                "    scheme[1023] = '\\0';",
                "",
                "  else",
                "    snprintf(cmdline, sizeof(cmdline),",
                "\t     \"%s/backend/%s '%s' '%s' '%s' '%s' '%s' %s\",",
                "\t     cups_serverbin, scheme, argv[1], argv[2], argv[3],",
                "\t     // Apply number of copies only if beh was called with a",
                "\t     // file name and not with the print data in stdin, as",
                "\t     // backends should handle copies only if they are called",
                "\t     // with a file name",
                "\t     (argc == 6 ? \"1\" : argv[4]),",
                "\t     argv[5], filename);",
                "\t  \"DEBUG: beh: Executing backend command line \\\"%s\\\"...\\n\",",
                "\t  cmdline);",
                "  retval = system(cmdline) >> 8;",
                "  if (retval == -1)",
                "    fprintf(stderr, \"ERROR: Unable to execute backend command line: %s\\n\",",
                "\t    strerror(errno));"
            ],
            "added_lines": [
                "  char          *backend_argv[8];       // Arguments for called CUPS backend",
                "\t\tbackend_path[2048];\t// Backend path",
                "  int           pid,",
                "                wait_pid,",
                "                wait_status,",
                "                retval = 0;",
                "  int           bytes;",
                "",
                "  scheme[0] = '\\0';",
                "  strncat(scheme, uri, sizeof(scheme) - 1);",
                "  else",
                "  {",
                "    fprintf(stderr,",
                "\t    \"ERROR: beh: Invalid URI, no colon (':') to mark end of scheme part.\\n\");",
                "    exit (CUPS_BACKEND_FAILED);",
                "  }",
                "  if (strchr(scheme, '/'))",
                "  {",
                "    fprintf(stderr,",
                "\t    \"ERROR: beh: Invalid URI, scheme contains a slash ('/').\\n\");",
                "    exit (CUPS_BACKEND_FAILED);",
                "  }",
                "  if (!strcmp(scheme, \".\") || !strcmp(scheme, \"..\"))",
                "  {",
                "    fprintf(stderr,",
                "\t    \"ERROR: beh: Invalid URI, scheme (\\\"%s\\\") is a directory.\\n\",",
                "\t    scheme);",
                "    exit (CUPS_BACKEND_FAILED);",
                "  }",
                "",
                "  backend_argv[0] = uri;",
                "  backend_argv[1] = argv[1];",
                "  backend_argv[2] = argv[2];",
                "  backend_argv[3] = argv[3];",
                "  backend_argv[4] = (argc == 6 ? \"1\" : argv[4]);",
                "  backend_argv[5] = argv[5];",
                "  backend_argv[6] = filename;",
                "  backend_argv[7] = NULL;",
                "",
                "  bytes = snprintf(backend_path, sizeof(backend_path),",
                "\t\t   \"%s/backend/%s\", cups_serverbin, scheme);",
                "  if (bytes < 0 || bytes >= sizeof(backend_path))",
                "  {",
                "    fprintf(stderr,",
                "\t    \"ERROR: beh: Invalid scheme (\\\"%s\\\"), could not determing backend path.\\n\",",
                "\t    scheme);",
                "    exit (CUPS_BACKEND_FAILED);",
                "  }",
                "\t  \"DEBUG: beh: Executing backend command line \\\"%s '%s' '%s' '%s' '%s' '%s'%s%s\\\"...\\n\",",
                "\t  backend_path, backend_argv[1], backend_argv[2], backend_argv[3],",
                "\t  backend_argv[4], backend_argv[5],",
                "\t  (backend_argv[6] && backend_argv[6][0] ? \" \" : \"\"),",
                "\t  (backend_argv[6] && backend_argv[6][0] ? backend_argv[6] : \"\"));",
                "  if ((pid = fork()) == 0)",
                "  {",
                "    retval = execv(backend_path, backend_argv);",
                "    if (retval == -1)",
                "      fprintf(stderr, \"ERROR: Unable to execute backend: %s\\n\",",
                "\t      strerror(errno));",
                "    exit (CUPS_BACKEND_FAILED);",
                "  }",
                "  else if (pid < 0)",
                "  {",
                "    fprintf(stderr, \"ERROR: Unable to fork for backend\\n\");",
                "    return (CUPS_BACKEND_FAILED);",
                "  }",
                "",
                "  while ((wait_pid = wait(&wait_status)) < 0 && errno == EINTR);",
                "",
                "  if (wait_pid >= 0 && wait_status)",
                "  {",
                "    if (WIFEXITED(wait_status))",
                "      retval = WEXITSTATUS(wait_status);",
                "    else if (WTERMSIG(wait_status) != SIGTERM)",
                "      retval = WTERMSIG(wait_status);",
                "    else",
                "      retval = 0;",
                "  }"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-34152",
        "func_name": "ImageMagick/OpenBlob",
        "description": "A vulnerability was found in ImageMagick. This security flaw cause a remote code execution vulnerability in OpenBlob with --enable-pipes configured.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/99b72d81a3370a966a52ec2fa88dacda3f5b028e",
        "commit_title": "Reverted the patch of https://github.com/ImageMagick/ImageMagick/issues/6339.",
        "commit_text": "",
        "func_before": "MagickExport MagickBooleanType OpenBlob(const ImageInfo *image_info,\n  Image *image,const BlobMode mode,ExceptionInfo *exception)\n{\n  BlobInfo\n    *magick_restrict blob_info;\n\n  char\n    extension[MagickPathExtent],\n    filename[MagickPathExtent];\n\n  const char\n    *type;\n\n  MagickBooleanType\n    status;\n\n  PolicyRights\n    rights;\n\n  assert(image_info != (ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (IsEventLogging() != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  blob_info=image->blob;\n  if (image_info->blob != (void *) NULL)\n    {\n      if (image_info->stream != (StreamHandler) NULL)\n        blob_info->stream=(StreamHandler) image_info->stream;\n      AttachBlob(blob_info,image_info->blob,image_info->length);\n      return(MagickTrue);\n    }\n  if ((image_info->custom_stream != (CustomStreamInfo *) NULL) &&\n      (*image->filename == '\\0'))\n    {\n      blob_info->type=CustomStream;\n      blob_info->custom_stream=image_info->custom_stream;\n      return(MagickTrue);\n    }\n  (void) DetachBlob(blob_info);\n  blob_info->mode=mode;\n  switch (mode)\n  {\n    default: type=\"r\"; break;\n    case ReadBlobMode: type=\"r\"; break;\n    case ReadBinaryBlobMode: type=\"rb\"; break;\n    case WriteBlobMode: type=\"w\"; break;\n    case WriteBinaryBlobMode: type=\"w+b\"; break;\n    case AppendBlobMode: type=\"a\"; break;\n    case AppendBinaryBlobMode: type=\"a+b\"; break;\n  }\n  if (*type != 'r')\n    blob_info->synchronize=image_info->synchronize;\n  if (image_info->stream != (StreamHandler) NULL)\n    {\n      blob_info->stream=image_info->stream;\n      if (*type == 'w')\n        {\n          blob_info->type=FifoStream;\n          return(MagickTrue);\n        }\n    }\n  /*\n    Open image file.\n  */\n  *filename='\\0';\n  (void) CopyMagickString(filename,image->filename,MagickPathExtent);\n  rights=ReadPolicyRights;\n  if (*type == 'w')\n    rights=WritePolicyRights;\n  if (IsRightsAuthorized(PathPolicyDomain,rights,filename) == MagickFalse)\n    {\n      errno=EPERM;\n      (void) ThrowMagickException(exception,GetMagickModule(),PolicyError,\n        \"NotAuthorized\",\"`%s'\",filename);\n      return(MagickFalse);\n    }\n  if ((LocaleCompare(filename,\"-\") == 0) ||\n      ((*filename == '\\0') && (image_info->file == (FILE *) NULL)))\n    {\n      blob_info->file_info.file=(*type == 'r') ? stdin : stdout;\n#if defined(MAGICKCORE_WINDOWS_SUPPORT) || defined(__OS2__)\n      if (strchr(type,'b') != (char *) NULL)\n        (void) setmode(fileno(blob_info->file_info.file),_O_BINARY);\n#endif\n      blob_info->type=StandardStream;\n      blob_info->exempt=MagickTrue;\n      return(SetStreamBuffering(image_info,blob_info));\n    }\n  if ((LocaleNCompare(filename,\"fd:\",3) == 0) &&\n      (IsGeometry(filename+3) != MagickFalse))\n    {\n      char\n        fileMode[2];\n\n      *fileMode=(*type);\n      fileMode[1]='\\0';\n      blob_info->file_info.file=fdopen(StringToLong(filename+3),fileMode);\n      if (blob_info->file_info.file == (FILE *) NULL)\n        {\n          ThrowFileException(exception,BlobError,\"UnableToOpenBlob\",filename);\n          return(MagickFalse);\n        }\n#if defined(MAGICKCORE_WINDOWS_SUPPORT) || defined(__OS2__)\n      if (strchr(type,'b') != (char *) NULL)\n        (void) setmode(fileno(blob_info->file_info.file),_O_BINARY);\n#endif\n      blob_info->type=FileStream;\n      blob_info->exempt=MagickTrue;\n      return(SetStreamBuffering(image_info,blob_info));\n    }\n#if defined(MAGICKCORE_HAVE_POPEN) && defined(MAGICKCORE_PIPES_SUPPORT)\n  if ((*filename == '|') && (strchr(filename,'`') == (char *) NULL) &&\n      (strchr(filename,'\"') == (char *) NULL))\n    {\n      char\n        fileMode[MagickPathExtent],\n        *sanitize_command;\n\n      /*\n        Pipe image to or from a system command.\n      */\n#if defined(SIGPIPE)\n      if (*type == 'w')\n        (void) signal(SIGPIPE,SIG_IGN);\n#endif\n      *fileMode=(*type);\n      fileMode[1]='\\0';\n      sanitize_command=SanitizeString(filename+1);\n      blob_info->file_info.file=(FILE *) popen_utf8(sanitize_command,fileMode);\n      sanitize_command=DestroyString(sanitize_command);\n      if (blob_info->file_info.file == (FILE *) NULL)\n        {\n          ThrowFileException(exception,BlobError,\"UnableToOpenBlob\",filename);\n          return(MagickFalse);\n        }\n      blob_info->type=PipeStream;\n      blob_info->exempt=MagickTrue;\n      return(SetStreamBuffering(image_info,blob_info));\n    }\n#endif\n  status=GetPathAttributes(filename,&blob_info->properties);\n#if defined(S_ISFIFO)\n  if ((status != MagickFalse) && S_ISFIFO(blob_info->properties.st_mode))\n    {\n      blob_info->file_info.file=(FILE *) fopen_utf8(filename,type);\n      if (blob_info->file_info.file == (FILE *) NULL)\n        {\n          ThrowFileException(exception,BlobError,\"UnableToOpenBlob\",filename);\n          return(MagickFalse);\n        }\n      blob_info->type=FileStream;\n      blob_info->exempt=MagickTrue;\n      return(SetStreamBuffering(image_info,blob_info));\n    }\n#endif\n  GetPathComponent(image->filename,ExtensionPath,extension);\n  if (*type == 'w')\n    {\n      (void) CopyMagickString(filename,image->filename,MagickPathExtent);\n      if ((image_info->adjoin == MagickFalse) ||\n          (strchr(filename,'%') != (char *) NULL))\n        {\n          /*\n            Form filename for multi-part images.\n          */\n          (void) InterpretImageFilename(image_info,image,image->filename,(int)\n            image->scene,filename,exception);\n          if ((LocaleCompare(filename,image->filename) == 0) &&\n              ((GetPreviousImageInList(image) != (Image *) NULL) ||\n               (GetNextImageInList(image) != (Image *) NULL)))\n            {\n              char\n                path[MagickPathExtent];\n\n              GetPathComponent(image->filename,RootPath,path);\n              if (*extension == '\\0')\n                (void) FormatLocaleString(filename,MagickPathExtent,\"%s-%.20g\",\n                  path,(double) image->scene);\n              else\n                (void) FormatLocaleString(filename,MagickPathExtent,\n                  \"%s-%.20g.%s\",path,(double) image->scene,extension);\n            }\n          (void) CopyMagickString(image->filename,filename,MagickPathExtent);\n        }\n    }\n  if (image_info->file != (FILE *) NULL)\n    {\n      blob_info->file_info.file=image_info->file;\n      blob_info->type=FileStream;\n      blob_info->exempt=MagickTrue;\n    }\n  else\n    if (*type == 'r')\n      {\n        blob_info->file_info.file=(FILE *) fopen_utf8(filename,type);\n        if (blob_info->file_info.file != (FILE *) NULL)\n          {\n            size_t\n              count;\n\n            unsigned char\n              magick[3];\n\n            blob_info->type=FileStream;\n            (void) SetStreamBuffering(image_info,blob_info);\n            (void) memset(magick,0,sizeof(magick));\n            count=fread(magick,1,sizeof(magick),blob_info->file_info.file);\n            (void) fseek(blob_info->file_info.file,-((off_t) count),SEEK_CUR);\n#if defined(MAGICKCORE_POSIX_SUPPORT)\n            (void) fflush(blob_info->file_info.file);\n#endif\n            (void) LogMagickEvent(BlobEvent,GetMagickModule(),\n               \"  read %.20g magic header bytes\",(double) count);\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n            if (((int) magick[0] == 0x1F) && ((int) magick[1] == 0x8B) &&\n                ((int) magick[2] == 0x08))\n              {\n                gzFile\n                  gzfile = gzopen_utf8(filename,\"rb\");\n\n                if (gzfile != (gzFile) NULL)\n                  {\n                    if (blob_info->file_info.file != (FILE *) NULL)\n                      (void) fclose(blob_info->file_info.file);\n                    blob_info->file_info.file=(FILE *) NULL;\n                    blob_info->file_info.gzfile=gzfile;\n                    blob_info->type=ZipStream;\n                  }\n              }\n#endif\n#if defined(MAGICKCORE_BZLIB_DELEGATE)\n            if (strncmp((char *) magick,\"BZh\",3) == 0)\n              {\n                BZFILE\n                  *bzfile = BZ2_bzopen(filename,\"r\");\n\n                if (bzfile != (BZFILE *) NULL)\n                  {\n                    if (blob_info->file_info.file != (FILE *) NULL)\n                      (void) fclose(blob_info->file_info.file);\n                    blob_info->file_info.file=(FILE *) NULL;\n                    blob_info->file_info.bzfile=bzfile;\n                    blob_info->type=BZipStream;\n                  }\n              }\n#endif\n            if (blob_info->type == FileStream)\n              {\n                const MagickInfo\n                  *magick_info;\n\n                ExceptionInfo\n                  *sans_exception;\n\n                size_t\n                  length;\n\n                sans_exception=AcquireExceptionInfo();\n                magick_info=GetMagickInfo(image_info->magick,sans_exception);\n                sans_exception=DestroyExceptionInfo(sans_exception);\n                length=(size_t) blob_info->properties.st_size;\n                if ((magick_info != (const MagickInfo *) NULL) &&\n                    (GetMagickBlobSupport(magick_info) != MagickFalse) &&\n                    (length > MagickMaxBufferExtent) &&\n                    (AcquireMagickResource(MapResource,length) != MagickFalse))\n                  {\n                    void\n                      *blob;\n\n                    blob=MapBlob(fileno(blob_info->file_info.file),ReadMode,0,\n                      length);\n                    if (blob == (void *) NULL)\n                      RelinquishMagickResource(MapResource,length);\n                    else\n                      {\n                        /*\n                          Format supports blobs-- use memory-mapped I/O.\n                        */\n                        if (image_info->file != (FILE *) NULL)\n                          blob_info->exempt=MagickFalse;\n                        else\n                          {\n                            (void) fclose(blob_info->file_info.file);\n                            blob_info->file_info.file=(FILE *) NULL;\n                          }\n                        AttachBlob(blob_info,blob,length);\n                        blob_info->mapped=MagickTrue;\n                      }\n                  }\n              }\n          }\n      }\n    else\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n      if ((LocaleCompare(extension,\"gz\") == 0) ||\n          (LocaleCompare(extension,\"wmz\") == 0) ||\n          (LocaleCompare(extension,\"svgz\") == 0))\n        {\n          blob_info->file_info.gzfile=gzopen_utf8(filename,\"wb\");\n          if (blob_info->file_info.gzfile != (gzFile) NULL)\n            blob_info->type=ZipStream;\n        }\n      else\n#endif\n#if defined(MAGICKCORE_BZLIB_DELEGATE)\n        if (LocaleCompare(extension,\"bz2\") == 0)\n          {\n            blob_info->file_info.bzfile=BZ2_bzopen(filename,\"w\");\n            if (blob_info->file_info.bzfile != (BZFILE *) NULL)\n              blob_info->type=BZipStream;\n          }\n        else\n#endif\n          {\n            blob_info->file_info.file=(FILE *) fopen_utf8(filename,type);\n            if (blob_info->file_info.file != (FILE *) NULL)\n              {\n                blob_info->type=FileStream;\n                (void) SetStreamBuffering(image_info,blob_info);\n              }\n          }\n  blob_info->status=MagickFalse;\n  blob_info->error_number=0;\n  if (blob_info->type != UndefinedStream)\n    blob_info->size=GetBlobSize(image);\n  else\n    {\n      ThrowFileException(exception,BlobError,\"UnableToOpenBlob\",filename);\n      return(MagickFalse);\n    }\n  return(MagickTrue);\n}",
        "func": "MagickExport MagickBooleanType OpenBlob(const ImageInfo *image_info,\n  Image *image,const BlobMode mode,ExceptionInfo *exception)\n{\n  BlobInfo\n    *magick_restrict blob_info;\n\n  char\n    extension[MagickPathExtent],\n    filename[MagickPathExtent];\n\n  const char\n    *type;\n\n  MagickBooleanType\n    status;\n\n  PolicyRights\n    rights;\n\n  assert(image_info != (ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (IsEventLogging() != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  blob_info=image->blob;\n  if (image_info->blob != (void *) NULL)\n    {\n      if (image_info->stream != (StreamHandler) NULL)\n        blob_info->stream=(StreamHandler) image_info->stream;\n      AttachBlob(blob_info,image_info->blob,image_info->length);\n      return(MagickTrue);\n    }\n  if ((image_info->custom_stream != (CustomStreamInfo *) NULL) &&\n      (*image->filename == '\\0'))\n    {\n      blob_info->type=CustomStream;\n      blob_info->custom_stream=image_info->custom_stream;\n      return(MagickTrue);\n    }\n  (void) DetachBlob(blob_info);\n  blob_info->mode=mode;\n  switch (mode)\n  {\n    default: type=\"r\"; break;\n    case ReadBlobMode: type=\"r\"; break;\n    case ReadBinaryBlobMode: type=\"rb\"; break;\n    case WriteBlobMode: type=\"w\"; break;\n    case WriteBinaryBlobMode: type=\"w+b\"; break;\n    case AppendBlobMode: type=\"a\"; break;\n    case AppendBinaryBlobMode: type=\"a+b\"; break;\n  }\n  if (*type != 'r')\n    blob_info->synchronize=image_info->synchronize;\n  if (image_info->stream != (StreamHandler) NULL)\n    {\n      blob_info->stream=image_info->stream;\n      if (*type == 'w')\n        {\n          blob_info->type=FifoStream;\n          return(MagickTrue);\n        }\n    }\n  /*\n    Open image file.\n  */\n  *filename='\\0';\n  (void) CopyMagickString(filename,image->filename,MagickPathExtent);\n  rights=ReadPolicyRights;\n  if (*type == 'w')\n    rights=WritePolicyRights;\n  if (IsRightsAuthorized(PathPolicyDomain,rights,filename) == MagickFalse)\n    {\n      errno=EPERM;\n      (void) ThrowMagickException(exception,GetMagickModule(),PolicyError,\n        \"NotAuthorized\",\"`%s'\",filename);\n      return(MagickFalse);\n    }\n  if ((LocaleCompare(filename,\"-\") == 0) ||\n      ((*filename == '\\0') && (image_info->file == (FILE *) NULL)))\n    {\n      blob_info->file_info.file=(*type == 'r') ? stdin : stdout;\n#if defined(MAGICKCORE_WINDOWS_SUPPORT) || defined(__OS2__)\n      if (strchr(type,'b') != (char *) NULL)\n        (void) setmode(fileno(blob_info->file_info.file),_O_BINARY);\n#endif\n      blob_info->type=StandardStream;\n      blob_info->exempt=MagickTrue;\n      return(SetStreamBuffering(image_info,blob_info));\n    }\n  if ((LocaleNCompare(filename,\"fd:\",3) == 0) &&\n      (IsGeometry(filename+3) != MagickFalse))\n    {\n      char\n        fileMode[2];\n\n      *fileMode=(*type);\n      fileMode[1]='\\0';\n      blob_info->file_info.file=fdopen(StringToLong(filename+3),fileMode);\n      if (blob_info->file_info.file == (FILE *) NULL)\n        {\n          ThrowFileException(exception,BlobError,\"UnableToOpenBlob\",filename);\n          return(MagickFalse);\n        }\n#if defined(MAGICKCORE_WINDOWS_SUPPORT) || defined(__OS2__)\n      if (strchr(type,'b') != (char *) NULL)\n        (void) setmode(fileno(blob_info->file_info.file),_O_BINARY);\n#endif\n      blob_info->type=FileStream;\n      blob_info->exempt=MagickTrue;\n      return(SetStreamBuffering(image_info,blob_info));\n    }\n#if defined(MAGICKCORE_HAVE_POPEN) && defined(MAGICKCORE_PIPES_SUPPORT)\n  if (*filename == '|')\n    {\n      char\n        fileMode[MagickPathExtent],\n        *sanitize_command;\n\n      /*\n        Pipe image to or from a system command.\n      */\n#if defined(SIGPIPE)\n      if (*type == 'w')\n        (void) signal(SIGPIPE,SIG_IGN);\n#endif\n      *fileMode=(*type);\n      fileMode[1]='\\0';\n      sanitize_command=SanitizeString(filename+1);\n      blob_info->file_info.file=(FILE *) popen_utf8(sanitize_command,fileMode);\n      sanitize_command=DestroyString(sanitize_command);\n      if (blob_info->file_info.file == (FILE *) NULL)\n        {\n          ThrowFileException(exception,BlobError,\"UnableToOpenBlob\",filename);\n          return(MagickFalse);\n        }\n      blob_info->type=PipeStream;\n      blob_info->exempt=MagickTrue;\n      return(SetStreamBuffering(image_info,blob_info));\n    }\n#endif\n  status=GetPathAttributes(filename,&blob_info->properties);\n#if defined(S_ISFIFO)\n  if ((status != MagickFalse) && S_ISFIFO(blob_info->properties.st_mode))\n    {\n      blob_info->file_info.file=(FILE *) fopen_utf8(filename,type);\n      if (blob_info->file_info.file == (FILE *) NULL)\n        {\n          ThrowFileException(exception,BlobError,\"UnableToOpenBlob\",filename);\n          return(MagickFalse);\n        }\n      blob_info->type=FileStream;\n      blob_info->exempt=MagickTrue;\n      return(SetStreamBuffering(image_info,blob_info));\n    }\n#endif\n  GetPathComponent(image->filename,ExtensionPath,extension);\n  if (*type == 'w')\n    {\n      (void) CopyMagickString(filename,image->filename,MagickPathExtent);\n      if ((image_info->adjoin == MagickFalse) ||\n          (strchr(filename,'%') != (char *) NULL))\n        {\n          /*\n            Form filename for multi-part images.\n          */\n          (void) InterpretImageFilename(image_info,image,image->filename,(int)\n            image->scene,filename,exception);\n          if ((LocaleCompare(filename,image->filename) == 0) &&\n              ((GetPreviousImageInList(image) != (Image *) NULL) ||\n               (GetNextImageInList(image) != (Image *) NULL)))\n            {\n              char\n                path[MagickPathExtent];\n\n              GetPathComponent(image->filename,RootPath,path);\n              if (*extension == '\\0')\n                (void) FormatLocaleString(filename,MagickPathExtent,\"%s-%.20g\",\n                  path,(double) image->scene);\n              else\n                (void) FormatLocaleString(filename,MagickPathExtent,\n                  \"%s-%.20g.%s\",path,(double) image->scene,extension);\n            }\n          (void) CopyMagickString(image->filename,filename,MagickPathExtent);\n        }\n    }\n  if (image_info->file != (FILE *) NULL)\n    {\n      blob_info->file_info.file=image_info->file;\n      blob_info->type=FileStream;\n      blob_info->exempt=MagickTrue;\n    }\n  else\n    if (*type == 'r')\n      {\n        blob_info->file_info.file=(FILE *) fopen_utf8(filename,type);\n        if (blob_info->file_info.file != (FILE *) NULL)\n          {\n            size_t\n              count;\n\n            unsigned char\n              magick[3];\n\n            blob_info->type=FileStream;\n            (void) SetStreamBuffering(image_info,blob_info);\n            (void) memset(magick,0,sizeof(magick));\n            count=fread(magick,1,sizeof(magick),blob_info->file_info.file);\n            (void) fseek(blob_info->file_info.file,-((off_t) count),SEEK_CUR);\n#if defined(MAGICKCORE_POSIX_SUPPORT)\n            (void) fflush(blob_info->file_info.file);\n#endif\n            (void) LogMagickEvent(BlobEvent,GetMagickModule(),\n               \"  read %.20g magic header bytes\",(double) count);\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n            if (((int) magick[0] == 0x1F) && ((int) magick[1] == 0x8B) &&\n                ((int) magick[2] == 0x08))\n              {\n                gzFile\n                  gzfile = gzopen_utf8(filename,\"rb\");\n\n                if (gzfile != (gzFile) NULL)\n                  {\n                    if (blob_info->file_info.file != (FILE *) NULL)\n                      (void) fclose(blob_info->file_info.file);\n                    blob_info->file_info.file=(FILE *) NULL;\n                    blob_info->file_info.gzfile=gzfile;\n                    blob_info->type=ZipStream;\n                  }\n              }\n#endif\n#if defined(MAGICKCORE_BZLIB_DELEGATE)\n            if (strncmp((char *) magick,\"BZh\",3) == 0)\n              {\n                BZFILE\n                  *bzfile = BZ2_bzopen(filename,\"r\");\n\n                if (bzfile != (BZFILE *) NULL)\n                  {\n                    if (blob_info->file_info.file != (FILE *) NULL)\n                      (void) fclose(blob_info->file_info.file);\n                    blob_info->file_info.file=(FILE *) NULL;\n                    blob_info->file_info.bzfile=bzfile;\n                    blob_info->type=BZipStream;\n                  }\n              }\n#endif\n            if (blob_info->type == FileStream)\n              {\n                const MagickInfo\n                  *magick_info;\n\n                ExceptionInfo\n                  *sans_exception;\n\n                size_t\n                  length;\n\n                sans_exception=AcquireExceptionInfo();\n                magick_info=GetMagickInfo(image_info->magick,sans_exception);\n                sans_exception=DestroyExceptionInfo(sans_exception);\n                length=(size_t) blob_info->properties.st_size;\n                if ((magick_info != (const MagickInfo *) NULL) &&\n                    (GetMagickBlobSupport(magick_info) != MagickFalse) &&\n                    (length > MagickMaxBufferExtent) &&\n                    (AcquireMagickResource(MapResource,length) != MagickFalse))\n                  {\n                    void\n                      *blob;\n\n                    blob=MapBlob(fileno(blob_info->file_info.file),ReadMode,0,\n                      length);\n                    if (blob == (void *) NULL)\n                      RelinquishMagickResource(MapResource,length);\n                    else\n                      {\n                        /*\n                          Format supports blobs-- use memory-mapped I/O.\n                        */\n                        if (image_info->file != (FILE *) NULL)\n                          blob_info->exempt=MagickFalse;\n                        else\n                          {\n                            (void) fclose(blob_info->file_info.file);\n                            blob_info->file_info.file=(FILE *) NULL;\n                          }\n                        AttachBlob(blob_info,blob,length);\n                        blob_info->mapped=MagickTrue;\n                      }\n                  }\n              }\n          }\n      }\n    else\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n      if ((LocaleCompare(extension,\"gz\") == 0) ||\n          (LocaleCompare(extension,\"wmz\") == 0) ||\n          (LocaleCompare(extension,\"svgz\") == 0))\n        {\n          blob_info->file_info.gzfile=gzopen_utf8(filename,\"wb\");\n          if (blob_info->file_info.gzfile != (gzFile) NULL)\n            blob_info->type=ZipStream;\n        }\n      else\n#endif\n#if defined(MAGICKCORE_BZLIB_DELEGATE)\n        if (LocaleCompare(extension,\"bz2\") == 0)\n          {\n            blob_info->file_info.bzfile=BZ2_bzopen(filename,\"w\");\n            if (blob_info->file_info.bzfile != (BZFILE *) NULL)\n              blob_info->type=BZipStream;\n          }\n        else\n#endif\n          {\n            blob_info->file_info.file=(FILE *) fopen_utf8(filename,type);\n            if (blob_info->file_info.file != (FILE *) NULL)\n              {\n                blob_info->type=FileStream;\n                (void) SetStreamBuffering(image_info,blob_info);\n              }\n          }\n  blob_info->status=MagickFalse;\n  blob_info->error_number=0;\n  if (blob_info->type != UndefinedStream)\n    blob_info->size=GetBlobSize(image);\n  else\n    {\n      ThrowFileException(exception,BlobError,\"UnableToOpenBlob\",filename);\n      return(MagickFalse);\n    }\n  return(MagickTrue);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -112,8 +112,7 @@\n       return(SetStreamBuffering(image_info,blob_info));\n     }\n #if defined(MAGICKCORE_HAVE_POPEN) && defined(MAGICKCORE_PIPES_SUPPORT)\n-  if ((*filename == '|') && (strchr(filename,'`') == (char *) NULL) &&\n-      (strchr(filename,'\"') == (char *) NULL))\n+  if (*filename == '|')\n     {\n       char\n         fileMode[MagickPathExtent],",
        "diff_line_info": {
            "deleted_lines": [
                "  if ((*filename == '|') && (strchr(filename,'`') == (char *) NULL) &&",
                "      (strchr(filename,'\"') == (char *) NULL))"
            ],
            "added_lines": [
                "  if (*filename == '|')"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-34152",
        "func_name": "ImageMagick/OpenBlob",
        "description": "A vulnerability was found in ImageMagick. This security flaw cause a remote code execution vulnerability in OpenBlob with --enable-pipes configured.",
        "git_url": "https://github.com/ImageMagick/ImageMagick/commit/17c4859bf4b1551185ab0b296e61b60b13969917",
        "commit_title": "possible RCE vulnerability (https://github.com/ImageMagick/ImageMagick/issues/6339)",
        "commit_text": "",
        "func_before": "MagickExport MagickBooleanType OpenBlob(const ImageInfo *image_info,\n  Image *image,const BlobMode mode,ExceptionInfo *exception)\n{\n  BlobInfo\n    *magick_restrict blob_info;\n\n  char\n    extension[MagickPathExtent],\n    filename[MagickPathExtent];\n\n  const char\n    *type;\n\n  MagickBooleanType\n    status;\n\n  PolicyRights\n    rights;\n\n  assert(image_info != (ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (IsEventLogging() != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  blob_info=image->blob;\n  if (image_info->blob != (void *) NULL)\n    {\n      if (image_info->stream != (StreamHandler) NULL)\n        blob_info->stream=(StreamHandler) image_info->stream;\n      AttachBlob(blob_info,image_info->blob,image_info->length);\n      return(MagickTrue);\n    }\n  if ((image_info->custom_stream != (CustomStreamInfo *) NULL) &&\n      (*image->filename == '\\0'))\n    {\n      blob_info->type=CustomStream;\n      blob_info->custom_stream=image_info->custom_stream;\n      return(MagickTrue);\n    }\n  (void) DetachBlob(blob_info);\n  blob_info->mode=mode;\n  switch (mode)\n  {\n    default: type=\"r\"; break;\n    case ReadBlobMode: type=\"r\"; break;\n    case ReadBinaryBlobMode: type=\"rb\"; break;\n    case WriteBlobMode: type=\"w\"; break;\n    case WriteBinaryBlobMode: type=\"w+b\"; break;\n    case AppendBlobMode: type=\"a\"; break;\n    case AppendBinaryBlobMode: type=\"a+b\"; break;\n  }\n  if (*type != 'r')\n    blob_info->synchronize=image_info->synchronize;\n  if (image_info->stream != (StreamHandler) NULL)\n    {\n      blob_info->stream=image_info->stream;\n      if (*type == 'w')\n        {\n          blob_info->type=FifoStream;\n          return(MagickTrue);\n        }\n    }\n  /*\n    Open image file.\n  */\n  *filename='\\0';\n  (void) CopyMagickString(filename,image->filename,MagickPathExtent);\n  rights=ReadPolicyRights;\n  if (*type == 'w')\n    rights=WritePolicyRights;\n  if (IsRightsAuthorized(PathPolicyDomain,rights,filename) == MagickFalse)\n    {\n      errno=EPERM;\n      (void) ThrowMagickException(exception,GetMagickModule(),PolicyError,\n        \"NotAuthorized\",\"`%s'\",filename);\n      return(MagickFalse);\n    }\n  if ((LocaleCompare(filename,\"-\") == 0) ||\n      ((*filename == '\\0') && (image_info->file == (FILE *) NULL)))\n    {\n      blob_info->file_info.file=(*type == 'r') ? stdin : stdout;\n#if defined(MAGICKCORE_WINDOWS_SUPPORT) || defined(__OS2__)\n      if (strchr(type,'b') != (char *) NULL)\n        (void) setmode(fileno(blob_info->file_info.file),_O_BINARY);\n#endif\n      blob_info->type=StandardStream;\n      blob_info->exempt=MagickTrue;\n      return(SetStreamBuffering(image_info,blob_info));\n    }\n  if ((LocaleNCompare(filename,\"fd:\",3) == 0) &&\n      (IsGeometry(filename+3) != MagickFalse))\n    {\n      char\n        fileMode[2];\n\n      *fileMode=(*type);\n      fileMode[1]='\\0';\n      blob_info->file_info.file=fdopen(StringToLong(filename+3),fileMode);\n      if (blob_info->file_info.file == (FILE *) NULL)\n        {\n          ThrowFileException(exception,BlobError,\"UnableToOpenBlob\",filename);\n          return(MagickFalse);\n        }\n#if defined(MAGICKCORE_WINDOWS_SUPPORT) || defined(__OS2__)\n      if (strchr(type,'b') != (char *) NULL)\n        (void) setmode(fileno(blob_info->file_info.file),_O_BINARY);\n#endif\n      blob_info->type=FileStream;\n      blob_info->exempt=MagickTrue;\n      return(SetStreamBuffering(image_info,blob_info));\n    }\n#if defined(MAGICKCORE_HAVE_POPEN) && defined(MAGICKCORE_PIPES_SUPPORT)\n  if (*filename == '|')\n    {\n      char\n        fileMode[MagickPathExtent],\n        *sanitize_command;\n\n      /*\n        Pipe image to or from a system command.\n      */\n#if defined(SIGPIPE)\n      if (*type == 'w')\n        (void) signal(SIGPIPE,SIG_IGN);\n#endif\n      *fileMode=(*type);\n      fileMode[1]='\\0';\n      sanitize_command=SanitizeString(filename+1);\n      blob_info->file_info.file=(FILE *) popen_utf8(sanitize_command,fileMode);\n      sanitize_command=DestroyString(sanitize_command);\n      if (blob_info->file_info.file == (FILE *) NULL)\n        {\n          ThrowFileException(exception,BlobError,\"UnableToOpenBlob\",filename);\n          return(MagickFalse);\n        }\n      blob_info->type=PipeStream;\n      blob_info->exempt=MagickTrue;\n      return(SetStreamBuffering(image_info,blob_info));\n    }\n#endif\n  status=GetPathAttributes(filename,&blob_info->properties);\n#if defined(S_ISFIFO)\n  if ((status != MagickFalse) && S_ISFIFO(blob_info->properties.st_mode))\n    {\n      blob_info->file_info.file=(FILE *) fopen_utf8(filename,type);\n      if (blob_info->file_info.file == (FILE *) NULL)\n        {\n          ThrowFileException(exception,BlobError,\"UnableToOpenBlob\",filename);\n          return(MagickFalse);\n        }\n      blob_info->type=FileStream;\n      blob_info->exempt=MagickTrue;\n      return(SetStreamBuffering(image_info,blob_info));\n    }\n#endif\n  GetPathComponent(image->filename,ExtensionPath,extension);\n  if (*type == 'w')\n    {\n      (void) CopyMagickString(filename,image->filename,MagickPathExtent);\n      if ((image_info->adjoin == MagickFalse) ||\n          (strchr(filename,'%') != (char *) NULL))\n        {\n          /*\n            Form filename for multi-part images.\n          */\n          (void) InterpretImageFilename(image_info,image,image->filename,(int)\n            image->scene,filename,exception);\n          if ((LocaleCompare(filename,image->filename) == 0) &&\n              ((GetPreviousImageInList(image) != (Image *) NULL) ||\n               (GetNextImageInList(image) != (Image *) NULL)))\n            {\n              char\n                path[MagickPathExtent];\n\n              GetPathComponent(image->filename,RootPath,path);\n              if (*extension == '\\0')\n                (void) FormatLocaleString(filename,MagickPathExtent,\"%s-%.20g\",\n                  path,(double) image->scene);\n              else\n                (void) FormatLocaleString(filename,MagickPathExtent,\n                  \"%s-%.20g.%s\",path,(double) image->scene,extension);\n            }\n          (void) CopyMagickString(image->filename,filename,MagickPathExtent);\n        }\n    }\n  if (image_info->file != (FILE *) NULL)\n    {\n      blob_info->file_info.file=image_info->file;\n      blob_info->type=FileStream;\n      blob_info->exempt=MagickTrue;\n    }\n  else\n    if (*type == 'r')\n      {\n        blob_info->file_info.file=(FILE *) fopen_utf8(filename,type);\n        if (blob_info->file_info.file != (FILE *) NULL)\n          {\n            size_t\n              count;\n\n            unsigned char\n              magick[3];\n\n            blob_info->type=FileStream;\n            (void) SetStreamBuffering(image_info,blob_info);\n            (void) memset(magick,0,sizeof(magick));\n            count=fread(magick,1,sizeof(magick),blob_info->file_info.file);\n            (void) fseek(blob_info->file_info.file,-((off_t) count),SEEK_CUR);\n#if defined(MAGICKCORE_POSIX_SUPPORT)\n            (void) fflush(blob_info->file_info.file);\n#endif\n            (void) LogMagickEvent(BlobEvent,GetMagickModule(),\n               \"  read %.20g magic header bytes\",(double) count);\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n            if (((int) magick[0] == 0x1F) && ((int) magick[1] == 0x8B) &&\n                ((int) magick[2] == 0x08))\n              {\n                gzFile\n                  gzfile = gzopen_utf8(filename,\"rb\");\n\n                if (gzfile != (gzFile) NULL)\n                  {\n                    if (blob_info->file_info.file != (FILE *) NULL)\n                      (void) fclose(blob_info->file_info.file);\n                    blob_info->file_info.file=(FILE *) NULL;\n                    blob_info->file_info.gzfile=gzfile;\n                    blob_info->type=ZipStream;\n                  }\n              }\n#endif\n#if defined(MAGICKCORE_BZLIB_DELEGATE)\n            if (strncmp((char *) magick,\"BZh\",3) == 0)\n              {\n                BZFILE\n                  *bzfile = BZ2_bzopen(filename,\"r\");\n\n                if (bzfile != (BZFILE *) NULL)\n                  {\n                    if (blob_info->file_info.file != (FILE *) NULL)\n                      (void) fclose(blob_info->file_info.file);\n                    blob_info->file_info.file=(FILE *) NULL;\n                    blob_info->file_info.bzfile=bzfile;\n                    blob_info->type=BZipStream;\n                  }\n              }\n#endif\n            if (blob_info->type == FileStream)\n              {\n                const MagickInfo\n                  *magick_info;\n\n                ExceptionInfo\n                  *sans_exception;\n\n                size_t\n                  length;\n\n                sans_exception=AcquireExceptionInfo();\n                magick_info=GetMagickInfo(image_info->magick,sans_exception);\n                sans_exception=DestroyExceptionInfo(sans_exception);\n                length=(size_t) blob_info->properties.st_size;\n                if ((magick_info != (const MagickInfo *) NULL) &&\n                    (GetMagickBlobSupport(magick_info) != MagickFalse) &&\n                    (length > MagickMaxBufferExtent) &&\n                    (AcquireMagickResource(MapResource,length) != MagickFalse))\n                  {\n                    void\n                      *blob;\n\n                    blob=MapBlob(fileno(blob_info->file_info.file),ReadMode,0,\n                      length);\n                    if (blob == (void *) NULL)\n                      RelinquishMagickResource(MapResource,length);\n                    else\n                      {\n                        /*\n                          Format supports blobs-- use memory-mapped I/O.\n                        */\n                        if (image_info->file != (FILE *) NULL)\n                          blob_info->exempt=MagickFalse;\n                        else\n                          {\n                            (void) fclose(blob_info->file_info.file);\n                            blob_info->file_info.file=(FILE *) NULL;\n                          }\n                        AttachBlob(blob_info,blob,length);\n                        blob_info->mapped=MagickTrue;\n                      }\n                  }\n              }\n          }\n      }\n    else\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n      if ((LocaleCompare(extension,\"gz\") == 0) ||\n          (LocaleCompare(extension,\"wmz\") == 0) ||\n          (LocaleCompare(extension,\"svgz\") == 0))\n        {\n          blob_info->file_info.gzfile=gzopen_utf8(filename,\"wb\");\n          if (blob_info->file_info.gzfile != (gzFile) NULL)\n            blob_info->type=ZipStream;\n        }\n      else\n#endif\n#if defined(MAGICKCORE_BZLIB_DELEGATE)\n        if (LocaleCompare(extension,\"bz2\") == 0)\n          {\n            blob_info->file_info.bzfile=BZ2_bzopen(filename,\"w\");\n            if (blob_info->file_info.bzfile != (BZFILE *) NULL)\n              blob_info->type=BZipStream;\n          }\n        else\n#endif\n          {\n            blob_info->file_info.file=(FILE *) fopen_utf8(filename,type);\n            if (blob_info->file_info.file != (FILE *) NULL)\n              {\n                blob_info->type=FileStream;\n                (void) SetStreamBuffering(image_info,blob_info);\n              }\n          }\n  blob_info->status=MagickFalse;\n  blob_info->error_number=0;\n  if (blob_info->type != UndefinedStream)\n    blob_info->size=GetBlobSize(image);\n  else\n    {\n      ThrowFileException(exception,BlobError,\"UnableToOpenBlob\",filename);\n      return(MagickFalse);\n    }\n  return(MagickTrue);\n}",
        "func": "MagickExport MagickBooleanType OpenBlob(const ImageInfo *image_info,\n  Image *image,const BlobMode mode,ExceptionInfo *exception)\n{\n  BlobInfo\n    *magick_restrict blob_info;\n\n  char\n    extension[MagickPathExtent],\n    filename[MagickPathExtent];\n\n  const char\n    *type;\n\n  MagickBooleanType\n    status;\n\n  PolicyRights\n    rights;\n\n  assert(image_info != (ImageInfo *) NULL);\n  assert(image_info->signature == MagickCoreSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (IsEventLogging() != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      image_info->filename);\n  blob_info=image->blob;\n  if (image_info->blob != (void *) NULL)\n    {\n      if (image_info->stream != (StreamHandler) NULL)\n        blob_info->stream=(StreamHandler) image_info->stream;\n      AttachBlob(blob_info,image_info->blob,image_info->length);\n      return(MagickTrue);\n    }\n  if ((image_info->custom_stream != (CustomStreamInfo *) NULL) &&\n      (*image->filename == '\\0'))\n    {\n      blob_info->type=CustomStream;\n      blob_info->custom_stream=image_info->custom_stream;\n      return(MagickTrue);\n    }\n  (void) DetachBlob(blob_info);\n  blob_info->mode=mode;\n  switch (mode)\n  {\n    default: type=\"r\"; break;\n    case ReadBlobMode: type=\"r\"; break;\n    case ReadBinaryBlobMode: type=\"rb\"; break;\n    case WriteBlobMode: type=\"w\"; break;\n    case WriteBinaryBlobMode: type=\"w+b\"; break;\n    case AppendBlobMode: type=\"a\"; break;\n    case AppendBinaryBlobMode: type=\"a+b\"; break;\n  }\n  if (*type != 'r')\n    blob_info->synchronize=image_info->synchronize;\n  if (image_info->stream != (StreamHandler) NULL)\n    {\n      blob_info->stream=image_info->stream;\n      if (*type == 'w')\n        {\n          blob_info->type=FifoStream;\n          return(MagickTrue);\n        }\n    }\n  /*\n    Open image file.\n  */\n  *filename='\\0';\n  (void) CopyMagickString(filename,image->filename,MagickPathExtent);\n  rights=ReadPolicyRights;\n  if (*type == 'w')\n    rights=WritePolicyRights;\n  if (IsRightsAuthorized(PathPolicyDomain,rights,filename) == MagickFalse)\n    {\n      errno=EPERM;\n      (void) ThrowMagickException(exception,GetMagickModule(),PolicyError,\n        \"NotAuthorized\",\"`%s'\",filename);\n      return(MagickFalse);\n    }\n  if ((LocaleCompare(filename,\"-\") == 0) ||\n      ((*filename == '\\0') && (image_info->file == (FILE *) NULL)))\n    {\n      blob_info->file_info.file=(*type == 'r') ? stdin : stdout;\n#if defined(MAGICKCORE_WINDOWS_SUPPORT) || defined(__OS2__)\n      if (strchr(type,'b') != (char *) NULL)\n        (void) setmode(fileno(blob_info->file_info.file),_O_BINARY);\n#endif\n      blob_info->type=StandardStream;\n      blob_info->exempt=MagickTrue;\n      return(SetStreamBuffering(image_info,blob_info));\n    }\n  if ((LocaleNCompare(filename,\"fd:\",3) == 0) &&\n      (IsGeometry(filename+3) != MagickFalse))\n    {\n      char\n        fileMode[2];\n\n      *fileMode=(*type);\n      fileMode[1]='\\0';\n      blob_info->file_info.file=fdopen(StringToLong(filename+3),fileMode);\n      if (blob_info->file_info.file == (FILE *) NULL)\n        {\n          ThrowFileException(exception,BlobError,\"UnableToOpenBlob\",filename);\n          return(MagickFalse);\n        }\n#if defined(MAGICKCORE_WINDOWS_SUPPORT) || defined(__OS2__)\n      if (strchr(type,'b') != (char *) NULL)\n        (void) setmode(fileno(blob_info->file_info.file),_O_BINARY);\n#endif\n      blob_info->type=FileStream;\n      blob_info->exempt=MagickTrue;\n      return(SetStreamBuffering(image_info,blob_info));\n    }\n#if defined(MAGICKCORE_HAVE_POPEN) && defined(MAGICKCORE_PIPES_SUPPORT)\n  if ((*filename == '|') && (strchr(filename,'`') == (char *) NULL) &&\n      (strchr(filename,'\"') == (char *) NULL))\n    {\n      char\n        fileMode[MagickPathExtent],\n        *sanitize_command;\n\n      /*\n        Pipe image to or from a system command.\n      */\n#if defined(SIGPIPE)\n      if (*type == 'w')\n        (void) signal(SIGPIPE,SIG_IGN);\n#endif\n      *fileMode=(*type);\n      fileMode[1]='\\0';\n      sanitize_command=SanitizeString(filename+1);\n      blob_info->file_info.file=(FILE *) popen_utf8(sanitize_command,fileMode);\n      sanitize_command=DestroyString(sanitize_command);\n      if (blob_info->file_info.file == (FILE *) NULL)\n        {\n          ThrowFileException(exception,BlobError,\"UnableToOpenBlob\",filename);\n          return(MagickFalse);\n        }\n      blob_info->type=PipeStream;\n      blob_info->exempt=MagickTrue;\n      return(SetStreamBuffering(image_info,blob_info));\n    }\n#endif\n  status=GetPathAttributes(filename,&blob_info->properties);\n#if defined(S_ISFIFO)\n  if ((status != MagickFalse) && S_ISFIFO(blob_info->properties.st_mode))\n    {\n      blob_info->file_info.file=(FILE *) fopen_utf8(filename,type);\n      if (blob_info->file_info.file == (FILE *) NULL)\n        {\n          ThrowFileException(exception,BlobError,\"UnableToOpenBlob\",filename);\n          return(MagickFalse);\n        }\n      blob_info->type=FileStream;\n      blob_info->exempt=MagickTrue;\n      return(SetStreamBuffering(image_info,blob_info));\n    }\n#endif\n  GetPathComponent(image->filename,ExtensionPath,extension);\n  if (*type == 'w')\n    {\n      (void) CopyMagickString(filename,image->filename,MagickPathExtent);\n      if ((image_info->adjoin == MagickFalse) ||\n          (strchr(filename,'%') != (char *) NULL))\n        {\n          /*\n            Form filename for multi-part images.\n          */\n          (void) InterpretImageFilename(image_info,image,image->filename,(int)\n            image->scene,filename,exception);\n          if ((LocaleCompare(filename,image->filename) == 0) &&\n              ((GetPreviousImageInList(image) != (Image *) NULL) ||\n               (GetNextImageInList(image) != (Image *) NULL)))\n            {\n              char\n                path[MagickPathExtent];\n\n              GetPathComponent(image->filename,RootPath,path);\n              if (*extension == '\\0')\n                (void) FormatLocaleString(filename,MagickPathExtent,\"%s-%.20g\",\n                  path,(double) image->scene);\n              else\n                (void) FormatLocaleString(filename,MagickPathExtent,\n                  \"%s-%.20g.%s\",path,(double) image->scene,extension);\n            }\n          (void) CopyMagickString(image->filename,filename,MagickPathExtent);\n        }\n    }\n  if (image_info->file != (FILE *) NULL)\n    {\n      blob_info->file_info.file=image_info->file;\n      blob_info->type=FileStream;\n      blob_info->exempt=MagickTrue;\n    }\n  else\n    if (*type == 'r')\n      {\n        blob_info->file_info.file=(FILE *) fopen_utf8(filename,type);\n        if (blob_info->file_info.file != (FILE *) NULL)\n          {\n            size_t\n              count;\n\n            unsigned char\n              magick[3];\n\n            blob_info->type=FileStream;\n            (void) SetStreamBuffering(image_info,blob_info);\n            (void) memset(magick,0,sizeof(magick));\n            count=fread(magick,1,sizeof(magick),blob_info->file_info.file);\n            (void) fseek(blob_info->file_info.file,-((off_t) count),SEEK_CUR);\n#if defined(MAGICKCORE_POSIX_SUPPORT)\n            (void) fflush(blob_info->file_info.file);\n#endif\n            (void) LogMagickEvent(BlobEvent,GetMagickModule(),\n               \"  read %.20g magic header bytes\",(double) count);\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n            if (((int) magick[0] == 0x1F) && ((int) magick[1] == 0x8B) &&\n                ((int) magick[2] == 0x08))\n              {\n                gzFile\n                  gzfile = gzopen_utf8(filename,\"rb\");\n\n                if (gzfile != (gzFile) NULL)\n                  {\n                    if (blob_info->file_info.file != (FILE *) NULL)\n                      (void) fclose(blob_info->file_info.file);\n                    blob_info->file_info.file=(FILE *) NULL;\n                    blob_info->file_info.gzfile=gzfile;\n                    blob_info->type=ZipStream;\n                  }\n              }\n#endif\n#if defined(MAGICKCORE_BZLIB_DELEGATE)\n            if (strncmp((char *) magick,\"BZh\",3) == 0)\n              {\n                BZFILE\n                  *bzfile = BZ2_bzopen(filename,\"r\");\n\n                if (bzfile != (BZFILE *) NULL)\n                  {\n                    if (blob_info->file_info.file != (FILE *) NULL)\n                      (void) fclose(blob_info->file_info.file);\n                    blob_info->file_info.file=(FILE *) NULL;\n                    blob_info->file_info.bzfile=bzfile;\n                    blob_info->type=BZipStream;\n                  }\n              }\n#endif\n            if (blob_info->type == FileStream)\n              {\n                const MagickInfo\n                  *magick_info;\n\n                ExceptionInfo\n                  *sans_exception;\n\n                size_t\n                  length;\n\n                sans_exception=AcquireExceptionInfo();\n                magick_info=GetMagickInfo(image_info->magick,sans_exception);\n                sans_exception=DestroyExceptionInfo(sans_exception);\n                length=(size_t) blob_info->properties.st_size;\n                if ((magick_info != (const MagickInfo *) NULL) &&\n                    (GetMagickBlobSupport(magick_info) != MagickFalse) &&\n                    (length > MagickMaxBufferExtent) &&\n                    (AcquireMagickResource(MapResource,length) != MagickFalse))\n                  {\n                    void\n                      *blob;\n\n                    blob=MapBlob(fileno(blob_info->file_info.file),ReadMode,0,\n                      length);\n                    if (blob == (void *) NULL)\n                      RelinquishMagickResource(MapResource,length);\n                    else\n                      {\n                        /*\n                          Format supports blobs-- use memory-mapped I/O.\n                        */\n                        if (image_info->file != (FILE *) NULL)\n                          blob_info->exempt=MagickFalse;\n                        else\n                          {\n                            (void) fclose(blob_info->file_info.file);\n                            blob_info->file_info.file=(FILE *) NULL;\n                          }\n                        AttachBlob(blob_info,blob,length);\n                        blob_info->mapped=MagickTrue;\n                      }\n                  }\n              }\n          }\n      }\n    else\n#if defined(MAGICKCORE_ZLIB_DELEGATE)\n      if ((LocaleCompare(extension,\"gz\") == 0) ||\n          (LocaleCompare(extension,\"wmz\") == 0) ||\n          (LocaleCompare(extension,\"svgz\") == 0))\n        {\n          blob_info->file_info.gzfile=gzopen_utf8(filename,\"wb\");\n          if (blob_info->file_info.gzfile != (gzFile) NULL)\n            blob_info->type=ZipStream;\n        }\n      else\n#endif\n#if defined(MAGICKCORE_BZLIB_DELEGATE)\n        if (LocaleCompare(extension,\"bz2\") == 0)\n          {\n            blob_info->file_info.bzfile=BZ2_bzopen(filename,\"w\");\n            if (blob_info->file_info.bzfile != (BZFILE *) NULL)\n              blob_info->type=BZipStream;\n          }\n        else\n#endif\n          {\n            blob_info->file_info.file=(FILE *) fopen_utf8(filename,type);\n            if (blob_info->file_info.file != (FILE *) NULL)\n              {\n                blob_info->type=FileStream;\n                (void) SetStreamBuffering(image_info,blob_info);\n              }\n          }\n  blob_info->status=MagickFalse;\n  blob_info->error_number=0;\n  if (blob_info->type != UndefinedStream)\n    blob_info->size=GetBlobSize(image);\n  else\n    {\n      ThrowFileException(exception,BlobError,\"UnableToOpenBlob\",filename);\n      return(MagickFalse);\n    }\n  return(MagickTrue);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -112,7 +112,8 @@\n       return(SetStreamBuffering(image_info,blob_info));\n     }\n #if defined(MAGICKCORE_HAVE_POPEN) && defined(MAGICKCORE_PIPES_SUPPORT)\n-  if (*filename == '|')\n+  if ((*filename == '|') && (strchr(filename,'`') == (char *) NULL) &&\n+      (strchr(filename,'\"') == (char *) NULL))\n     {\n       char\n         fileMode[MagickPathExtent],",
        "diff_line_info": {
            "deleted_lines": [
                "  if (*filename == '|')"
            ],
            "added_lines": [
                "  if ((*filename == '|') && (strchr(filename,'`') == (char *) NULL) &&",
                "      (strchr(filename,'\"') == (char *) NULL))"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-7247",
        "func_name": "openbsd/src/smtp_mailaddr",
        "description": "smtp_mailaddr in smtp_session.c in OpenSMTPD 6.6, as used in OpenBSD 6.6 and other products, allows remote attackers to execute arbitrary commands as root via a crafted SMTP session, as demonstrated by shell metacharacters in a MAIL FROM field. This affects the \"uncommented\" default configuration. The issue exists because of an incorrect return value upon failure of input validation.",
        "git_url": "https://github.com/openbsd/src/commit/9dcfda045474d8903224d175907bfc29761dcb45",
        "commit_title": "Fix a security vulnerability discovered by Qualys which can lead to a",
        "commit_text": "privileges escalation on mbox deliveries and unprivileged code execution on lmtp deliveries, due to a logic issue causing a sanity check to be missed.  ok eric@, millert@",
        "func_before": "static int\nsmtp_mailaddr(struct mailaddr *maddr, char *line, int mailfrom, char **args,\n    const char *domain)\n{\n\tchar   *p, *e;\n\n\tif (line == NULL)\n\t\treturn (0);\n\n\tif (*line != '<')\n\t\treturn (0);\n\n\te = strchr(line, '>');\n\tif (e == NULL)\n\t\treturn (0);\n\t*e++ = '\\0';\n\twhile (*e == ' ')\n\t\te++;\n\t*args = e;\n\n\tif (!text_to_mailaddr(maddr, line + 1))\n\t\treturn (0);\n\n\tp = strchr(maddr->user, ':');\n\tif (p != NULL) {\n\t\tp++;\n\t\tmemmove(maddr->user, p, strlen(p) + 1);\n\t}\n\n\tif (!valid_localpart(maddr->user) ||\n\t    !valid_domainpart(maddr->domain)) {\n\t\t/* accept empty return-path in MAIL FROM, required for bounces */\n\t\tif (mailfrom && maddr->user[0] == '\\0' && maddr->domain[0] == '\\0')\n\t\t\treturn (1);\n\n\t\t/* no user-part, reject */\n\t\tif (maddr->user[0] == '\\0')\n\t\t\treturn (0);\n\n\t\t/* no domain, local user */\n\t\tif (maddr->domain[0] == '\\0') {\n\t\t\t(void)strlcpy(maddr->domain, domain,\n\t\t\t    sizeof(maddr->domain));\n\t\t\treturn (1);\n\t\t}\n\t\treturn (0);\n\t}\n\n\treturn (1);\n}",
        "func": "static int\nsmtp_mailaddr(struct mailaddr *maddr, char *line, int mailfrom, char **args,\n    const char *domain)\n{\n\tchar   *p, *e;\n\n\tif (line == NULL)\n\t\treturn (0);\n\n\tif (*line != '<')\n\t\treturn (0);\n\n\te = strchr(line, '>');\n\tif (e == NULL)\n\t\treturn (0);\n\t*e++ = '\\0';\n\twhile (*e == ' ')\n\t\te++;\n\t*args = e;\n\n\tif (!text_to_mailaddr(maddr, line + 1))\n\t\treturn (0);\n\n\tp = strchr(maddr->user, ':');\n\tif (p != NULL) {\n\t\tp++;\n\t\tmemmove(maddr->user, p, strlen(p) + 1);\n\t}\n\n\t/* accept empty return-path in MAIL FROM, required for bounces */\n\tif (mailfrom && maddr->user[0] == '\\0' && maddr->domain[0] == '\\0')\n\t\treturn (1);\n\n\t/* no or invalid user-part, reject */\n\tif (maddr->user[0] == '\\0' || !valid_localpart(maddr->user))\n\t\treturn (0);\n\n\t/* no domain part, local user */\n\tif (maddr->domain[0] == '\\0') {\n\t\t(void)strlcpy(maddr->domain, domain,\n\t\t\tsizeof(maddr->domain));\n\t}\n\n\tif (!valid_domainpart(maddr->domain))\n\t\treturn (0);\n\n\treturn (1);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -27,24 +27,22 @@\n \t\tmemmove(maddr->user, p, strlen(p) + 1);\n \t}\n \n-\tif (!valid_localpart(maddr->user) ||\n-\t    !valid_domainpart(maddr->domain)) {\n-\t\t/* accept empty return-path in MAIL FROM, required for bounces */\n-\t\tif (mailfrom && maddr->user[0] == '\\0' && maddr->domain[0] == '\\0')\n-\t\t\treturn (1);\n+\t/* accept empty return-path in MAIL FROM, required for bounces */\n+\tif (mailfrom && maddr->user[0] == '\\0' && maddr->domain[0] == '\\0')\n+\t\treturn (1);\n \n-\t\t/* no user-part, reject */\n-\t\tif (maddr->user[0] == '\\0')\n-\t\t\treturn (0);\n+\t/* no or invalid user-part, reject */\n+\tif (maddr->user[0] == '\\0' || !valid_localpart(maddr->user))\n+\t\treturn (0);\n \n-\t\t/* no domain, local user */\n-\t\tif (maddr->domain[0] == '\\0') {\n-\t\t\t(void)strlcpy(maddr->domain, domain,\n-\t\t\t    sizeof(maddr->domain));\n-\t\t\treturn (1);\n-\t\t}\n+\t/* no domain part, local user */\n+\tif (maddr->domain[0] == '\\0') {\n+\t\t(void)strlcpy(maddr->domain, domain,\n+\t\t\tsizeof(maddr->domain));\n+\t}\n+\n+\tif (!valid_domainpart(maddr->domain))\n \t\treturn (0);\n-\t}\n \n \treturn (1);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (!valid_localpart(maddr->user) ||",
                "\t    !valid_domainpart(maddr->domain)) {",
                "\t\t/* accept empty return-path in MAIL FROM, required for bounces */",
                "\t\tif (mailfrom && maddr->user[0] == '\\0' && maddr->domain[0] == '\\0')",
                "\t\t\treturn (1);",
                "\t\t/* no user-part, reject */",
                "\t\tif (maddr->user[0] == '\\0')",
                "\t\t\treturn (0);",
                "\t\t/* no domain, local user */",
                "\t\tif (maddr->domain[0] == '\\0') {",
                "\t\t\t(void)strlcpy(maddr->domain, domain,",
                "\t\t\t    sizeof(maddr->domain));",
                "\t\t\treturn (1);",
                "\t\t}",
                "\t}"
            ],
            "added_lines": [
                "\t/* accept empty return-path in MAIL FROM, required for bounces */",
                "\tif (mailfrom && maddr->user[0] == '\\0' && maddr->domain[0] == '\\0')",
                "\t\treturn (1);",
                "\t/* no or invalid user-part, reject */",
                "\tif (maddr->user[0] == '\\0' || !valid_localpart(maddr->user))",
                "\t\treturn (0);",
                "\t/* no domain part, local user */",
                "\tif (maddr->domain[0] == '\\0') {",
                "\t\t(void)strlcpy(maddr->domain, domain,",
                "\t\t\tsizeof(maddr->domain));",
                "\t}",
                "",
                "\tif (!valid_domainpart(maddr->domain))"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-45939",
        "func_name": "emacs/readline",
        "description": "GNU Emacs through 28.2 allows attackers to execute commands via shell metacharacters in the name of a source-code file, because lib-src/etags.c uses the system C library function in its implementation of the ctags program. For example, a victim may use the \"ctags *\" command (suggested in the ctags documentation) in a situation where the current working directory has contents that depend on untrusted input.",
        "git_url": "https://git.savannah.gnu.org/cgit/emacs.git/commit/?id=d48bb4874bc6cd3e69c7a15fc3c91cc141025c51",
        "commit_title": "* lib-src/etags.c:",
        "commit_text": " (clean_matched_file_tag): New function (do_move_file): New function (readline_internal): Add `leave_cr` parameter, if true, include the \\r character  * test/manual/etags/CTAGS.good_crlf: New file * test/manual/etags/CTAGS.good_update: New file * test/manual/etags/crlf: New file * test/manual/etags/Makefile: Add `ctags -u` test cases ",
        "func_before": "static void\nreadline (linebuffer *lbp, FILE *stream)\n{\n  linecharno = charno;\t\t/* update global char number of line start */\n  ptrdiff_t result = readline_internal (lbp, stream, infilename);\n  lineno += 1;\t\t\t/* increment global line number */\n  charno += result;\t\t/* increment global char number */\n\n  /* Honor #line directives. */\n  if (!no_line_directive)\n    {\n      static bool discard_until_line_directive;\n\n      /* Check whether this is a #line directive. */\n      if (result > 12 && strneq (lbp->buffer, \"#line \", 6))\n\t{\n\t  intmax_t lno;\n\t  int start = 0;\n\n\t  if (sscanf (lbp->buffer, \"#line %\"SCNdMAX\" \\\"%n\", &lno, &start) >= 1\n\t      && start > 0)\t/* double quote character found */\n\t    {\n\t      char *endp = lbp->buffer + start;\n\n\t      while ((endp = strchr (endp, '\"')) != NULL\n\t\t     && endp[-1] == '\\\\')\n\t\tendp++;\n\t      if (endp != NULL)\n\t\t/* Ok, this is a real #line directive.  Let's deal with it. */\n\t\t{\n\t\t  char *taggedabsname;\t/* absolute name of original file */\n\t\t  char *taggedfname;\t/* name of original file as given */\n\t\t  char *name;\t\t/* temp var */\n\n\t\t  discard_until_line_directive = false; /* found it */\n\t\t  name = lbp->buffer + start;\n\t\t  *endp = '\\0';\n\t\t  canonicalize_filename (name);\n\t\t  taggedabsname = absolute_filename (name, tagfiledir);\n\t\t  if (filename_is_absolute (name)\n\t\t      || filename_is_absolute (curfdp->infname))\n\t\t    taggedfname = savestr (taggedabsname);\n\t\t  else\n\t\t    taggedfname = relative_filename (taggedabsname,tagfiledir);\n\n\t\t  if (streq (curfdp->taggedfname, taggedfname))\n\t\t    /* The #line directive is only a line number change.  We\n\t\t       deal with this afterwards. */\n\t\t    free (taggedfname);\n\t\t  else\n\t\t    /* The tags following this #line directive should be\n\t\t       attributed to taggedfname.  In order to do this, set\n\t\t       curfdp accordingly. */\n\t\t    {\n\t\t      fdesc *fdp; /* file description pointer */\n\n\t\t      /* Go look for a file description already set up for the\n\t\t\t file indicated in the #line directive.  If there is\n\t\t\t one, use it from now until the next #line\n\t\t\t directive. */\n\t\t      for (fdp = fdhead; fdp != NULL; fdp = fdp->next)\n\t\t\tif (streq (fdp->infname, curfdp->infname)\n\t\t\t    && streq (fdp->taggedfname, taggedfname))\n\t\t\t  /* If we remove the second test above (after the &&)\n\t\t\t     then all entries pertaining to the same file are\n\t\t\t     coalesced in the tags file.  If we use it, then\n\t\t\t     entries pertaining to the same file but generated\n\t\t\t     from different files (via #line directives) will\n\t\t\t     go into separate sections in the tags file.  These\n\t\t\t     alternatives look equivalent.  The first one\n\t\t\t     destroys some apparently useless information. */\n\t\t\t  {\n\t\t\t    curfdp = fdp;\n\t\t\t    free (taggedfname);\n\t\t\t    break;\n\t\t\t  }\n\t\t      /* Else, if we already tagged the real file, skip all\n\t\t\t input lines until the next #line directive. */\n\t\t      if (fdp == NULL) /* not found */\n\t\t\tfor (fdp = fdhead; fdp != NULL; fdp = fdp->next)\n\t\t\t  if (streq (fdp->infabsname, taggedabsname))\n\t\t\t    {\n\t\t\t      discard_until_line_directive = true;\n\t\t\t      free (taggedfname);\n\t\t\t      break;\n\t\t\t    }\n\t\t      /* Else create a new file description and use that from\n\t\t\t now on, until the next #line directive. */\n\t\t      if (fdp == NULL) /* not found */\n\t\t\t{\n\t\t\t  fdp = fdhead;\n\t\t\t  fdhead = xnew (1, fdesc);\n\t\t\t  *fdhead = *curfdp; /* copy curr. file description */\n\t\t\t  fdhead->next = fdp;\n\t\t\t  fdhead->infname = savestr (curfdp->infname);\n\t\t\t  fdhead->infabsname = savestr (curfdp->infabsname);\n\t\t\t  fdhead->infabsdir = savestr (curfdp->infabsdir);\n\t\t\t  fdhead->taggedfname = taggedfname;\n\t\t\t  fdhead->usecharno = false;\n\t\t\t  fdhead->prop = NULL;\n\t\t\t  fdhead->written = false;\n\t\t\t  curfdp = fdhead;\n\t\t\t}\n\t\t    }\n\t\t  free (taggedabsname);\n\t\t  lineno = lno - 1;\n\t\t  readline (lbp, stream);\n\t\t  return;\n\t\t} /* if a real #line directive */\n\t    } /* if #line is followed by a number */\n\t} /* if line begins with \"#line \" */\n\n      /* If we are here, no #line directive was found. */\n      if (discard_until_line_directive)\n\t{\n\t  if (result > 0)\n\t    {\n\t      /* Do a tail recursion on ourselves, thus discarding the contents\n\t\t of the line buffer. */\n\t      readline (lbp, stream);\n\t      return;\n\t    }\n\t  /* End of file. */\n\t  discard_until_line_directive = false;\n\t  return;\n\t}\n    } /* if #line directives should be considered */\n\n  {\n    ptrdiff_t match;\n    regexp *rp;\n    char *name;\n\n    /* Match against relevant regexps. */\n    if (lbp->len > 0)\n      for (rp = p_head; rp != NULL; rp = rp->p_next)\n\t{\n\t  /* Only use generic regexps or those for the current language.\n\t     Also do not use multiline regexps, which is the job of\n\t     regex_tag_multiline. */\n\t  if ((rp->lang != NULL && rp->lang != fdhead->lang)\n\t      || rp->multi_line)\n\t    continue;\n\n\t  match = re_match (rp->pat, lbp->buffer, lbp->len, 0, &rp->regs);\n\t  switch (match)\n\t    {\n\t    case -2:\n\t      /* Some error. */\n\t      if (!rp->error_signaled)\n\t\t{\n\t\t  error (\"regexp stack overflow while matching \\\"%s\\\"\",\n\t\t\t rp->pattern);\n\t\t  rp->error_signaled = true;\n\t\t}\n\t      break;\n\t    case -1:\n\t      /* No match. */\n\t      break;\n\t    case 0:\n\t      /* Empty string matched. */\n\t      if (!rp->error_signaled)\n\t\t{\n\t\t  error (\"regexp matches the empty string: \\\"%s\\\"\", rp->pattern);\n\t\t  rp->error_signaled = true;\n\t\t}\n\t      break;\n\t    default:\n\t      /* Match occurred.  Construct a tag. */\n\t      name = rp->name;\n\t      if (name[0] == '\\0')\n\t\tname = NULL;\n\t      else /* make a named tag */\n\t\tname = substitute (lbp->buffer, rp->name, &rp->regs);\n\n\t      /* Force explicit tag name, if a name is there. */\n\t      pfnote (name, true, lbp->buffer, match, lineno, linecharno);\n\n\t      if (debug)\n\t\tfprintf (stderr, \"%s on %s:%\"PRIdMAX\": %s\\n\",\n\t\t\t name ? name : \"(unnamed)\", curfdp->taggedfname,\n\t\t\t lineno, lbp->buffer);\n\t      break;\n\t    }\n\t}\n  }\n}",
        "func": "static void\nreadline (linebuffer *lbp, FILE *stream)\n{\n  linecharno = charno;\t\t/* update global char number of line start */\n  ptrdiff_t result = readline_internal (lbp, stream, infilename, false);\n  lineno += 1;\t\t\t/* increment global line number */\n  charno += result;\t\t/* increment global char number */\n\n  /* Honor #line directives. */\n  if (!no_line_directive)\n    {\n      static bool discard_until_line_directive;\n\n      /* Check whether this is a #line directive. */\n      if (result > 12 && strneq (lbp->buffer, \"#line \", 6))\n\t{\n\t  intmax_t lno;\n\t  int start = 0;\n\n\t  if (sscanf (lbp->buffer, \"#line %\"SCNdMAX\" \\\"%n\", &lno, &start) >= 1\n\t      && start > 0)\t/* double quote character found */\n\t    {\n\t      char *endp = lbp->buffer + start;\n\n\t      while ((endp = strchr (endp, '\"')) != NULL\n\t\t     && endp[-1] == '\\\\')\n\t\tendp++;\n\t      if (endp != NULL)\n\t\t/* Ok, this is a real #line directive.  Let's deal with it. */\n\t\t{\n\t\t  char *taggedabsname;\t/* absolute name of original file */\n\t\t  char *taggedfname;\t/* name of original file as given */\n\t\t  char *name;\t\t/* temp var */\n\n\t\t  discard_until_line_directive = false; /* found it */\n\t\t  name = lbp->buffer + start;\n\t\t  *endp = '\\0';\n\t\t  canonicalize_filename (name);\n\t\t  taggedabsname = absolute_filename (name, tagfiledir);\n\t\t  if (filename_is_absolute (name)\n\t\t      || filename_is_absolute (curfdp->infname))\n\t\t    taggedfname = savestr (taggedabsname);\n\t\t  else\n\t\t    taggedfname = relative_filename (taggedabsname,tagfiledir);\n\n\t\t  if (streq (curfdp->taggedfname, taggedfname))\n\t\t    /* The #line directive is only a line number change.  We\n\t\t       deal with this afterwards. */\n\t\t    free (taggedfname);\n\t\t  else\n\t\t    /* The tags following this #line directive should be\n\t\t       attributed to taggedfname.  In order to do this, set\n\t\t       curfdp accordingly. */\n\t\t    {\n\t\t      fdesc *fdp; /* file description pointer */\n\n\t\t      /* Go look for a file description already set up for the\n\t\t\t file indicated in the #line directive.  If there is\n\t\t\t one, use it from now until the next #line\n\t\t\t directive. */\n\t\t      for (fdp = fdhead; fdp != NULL; fdp = fdp->next)\n\t\t\tif (streq (fdp->infname, curfdp->infname)\n\t\t\t    && streq (fdp->taggedfname, taggedfname))\n\t\t\t  /* If we remove the second test above (after the &&)\n\t\t\t     then all entries pertaining to the same file are\n\t\t\t     coalesced in the tags file.  If we use it, then\n\t\t\t     entries pertaining to the same file but generated\n\t\t\t     from different files (via #line directives) will\n\t\t\t     go into separate sections in the tags file.  These\n\t\t\t     alternatives look equivalent.  The first one\n\t\t\t     destroys some apparently useless information. */\n\t\t\t  {\n\t\t\t    curfdp = fdp;\n\t\t\t    free (taggedfname);\n\t\t\t    break;\n\t\t\t  }\n\t\t      /* Else, if we already tagged the real file, skip all\n\t\t\t input lines until the next #line directive. */\n\t\t      if (fdp == NULL) /* not found */\n\t\t\tfor (fdp = fdhead; fdp != NULL; fdp = fdp->next)\n\t\t\t  if (streq (fdp->infabsname, taggedabsname))\n\t\t\t    {\n\t\t\t      discard_until_line_directive = true;\n\t\t\t      free (taggedfname);\n\t\t\t      break;\n\t\t\t    }\n\t\t      /* Else create a new file description and use that from\n\t\t\t now on, until the next #line directive. */\n\t\t      if (fdp == NULL) /* not found */\n\t\t\t{\n\t\t\t  fdp = fdhead;\n\t\t\t  fdhead = xnew (1, fdesc);\n\t\t\t  *fdhead = *curfdp; /* copy curr. file description */\n\t\t\t  fdhead->next = fdp;\n\t\t\t  fdhead->infname = savestr (curfdp->infname);\n\t\t\t  fdhead->infabsname = savestr (curfdp->infabsname);\n\t\t\t  fdhead->infabsdir = savestr (curfdp->infabsdir);\n\t\t\t  fdhead->taggedfname = taggedfname;\n\t\t\t  fdhead->usecharno = false;\n\t\t\t  fdhead->prop = NULL;\n\t\t\t  fdhead->written = false;\n\t\t\t  curfdp = fdhead;\n\t\t\t}\n\t\t    }\n\t\t  free (taggedabsname);\n\t\t  lineno = lno - 1;\n\t\t  readline (lbp, stream);\n\t\t  return;\n\t\t} /* if a real #line directive */\n\t    } /* if #line is followed by a number */\n\t} /* if line begins with \"#line \" */\n\n      /* If we are here, no #line directive was found. */\n      if (discard_until_line_directive)\n\t{\n\t  if (result > 0)\n\t    {\n\t      /* Do a tail recursion on ourselves, thus discarding the contents\n\t\t of the line buffer. */\n\t      readline (lbp, stream);\n\t      return;\n\t    }\n\t  /* End of file. */\n\t  discard_until_line_directive = false;\n\t  return;\n\t}\n    } /* if #line directives should be considered */\n\n  {\n    ptrdiff_t match;\n    regexp *rp;\n    char *name;\n\n    /* Match against relevant regexps. */\n    if (lbp->len > 0)\n      for (rp = p_head; rp != NULL; rp = rp->p_next)\n\t{\n\t  /* Only use generic regexps or those for the current language.\n\t     Also do not use multiline regexps, which is the job of\n\t     regex_tag_multiline. */\n\t  if ((rp->lang != NULL && rp->lang != fdhead->lang)\n\t      || rp->multi_line)\n\t    continue;\n\n\t  match = re_match (rp->pat, lbp->buffer, lbp->len, 0, &rp->regs);\n\t  switch (match)\n\t    {\n\t    case -2:\n\t      /* Some error. */\n\t      if (!rp->error_signaled)\n\t\t{\n\t\t  error (\"regexp stack overflow while matching \\\"%s\\\"\",\n\t\t\t rp->pattern);\n\t\t  rp->error_signaled = true;\n\t\t}\n\t      break;\n\t    case -1:\n\t      /* No match. */\n\t      break;\n\t    case 0:\n\t      /* Empty string matched. */\n\t      if (!rp->error_signaled)\n\t\t{\n\t\t  error (\"regexp matches the empty string: \\\"%s\\\"\", rp->pattern);\n\t\t  rp->error_signaled = true;\n\t\t}\n\t      break;\n\t    default:\n\t      /* Match occurred.  Construct a tag. */\n\t      name = rp->name;\n\t      if (name[0] == '\\0')\n\t\tname = NULL;\n\t      else /* make a named tag */\n\t\tname = substitute (lbp->buffer, rp->name, &rp->regs);\n\n\t      /* Force explicit tag name, if a name is there. */\n\t      pfnote (name, true, lbp->buffer, match, lineno, linecharno);\n\n\t      if (debug)\n\t\tfprintf (stderr, \"%s on %s:%\"PRIdMAX\": %s\\n\",\n\t\t\t name ? name : \"(unnamed)\", curfdp->taggedfname,\n\t\t\t lineno, lbp->buffer);\n\t      break;\n\t    }\n\t}\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,7 +2,7 @@\n readline (linebuffer *lbp, FILE *stream)\n {\n   linecharno = charno;\t\t/* update global char number of line start */\n-  ptrdiff_t result = readline_internal (lbp, stream, infilename);\n+  ptrdiff_t result = readline_internal (lbp, stream, infilename, false);\n   lineno += 1;\t\t\t/* increment global line number */\n   charno += result;\t\t/* increment global char number */\n ",
        "diff_line_info": {
            "deleted_lines": [
                "  ptrdiff_t result = readline_internal (lbp, stream, infilename);"
            ],
            "added_lines": [
                "  ptrdiff_t result = readline_internal (lbp, stream, infilename, false);"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-45939",
        "func_name": "emacs/analyze_regex",
        "description": "GNU Emacs through 28.2 allows attackers to execute commands via shell metacharacters in the name of a source-code file, because lib-src/etags.c uses the system C library function in its implementation of the ctags program. For example, a victim may use the \"ctags *\" command (suggested in the ctags documentation) in a situation where the current working directory has contents that depend on untrusted input.",
        "git_url": "https://git.savannah.gnu.org/cgit/emacs.git/commit/?id=d48bb4874bc6cd3e69c7a15fc3c91cc141025c51",
        "commit_title": "* lib-src/etags.c:",
        "commit_text": " (clean_matched_file_tag): New function (do_move_file): New function (readline_internal): Add `leave_cr` parameter, if true, include the \\r character  * test/manual/etags/CTAGS.good_crlf: New file * test/manual/etags/CTAGS.good_update: New file * test/manual/etags/crlf: New file * test/manual/etags/Makefile: Add `ctags -u` test cases ",
        "func_before": "static void\nanalyze_regex (char *regex_arg)\n{\n  if (regex_arg == NULL)\n    {\n      free_regexps ();\t\t/* --no-regex: remove existing regexps */\n      return;\n    }\n\n  /* A real --regexp option or a line in a regexp file. */\n  switch (regex_arg[0])\n    {\n      /* Comments in regexp file or null arg to --regex. */\n    case '\\0':\n    case ' ':\n    case '\\t':\n      break;\n\n      /* Read a regex file.  This is recursive and may result in a\n\t loop, which will stop when the file descriptors are exhausted. */\n    case '@':\n      {\n\tFILE *regexfp;\n\tlinebuffer regexbuf;\n\tchar *regexfile = regex_arg + 1;\n\n\t/* regexfile is a file containing regexps, one per line. */\n\tregexfp = fopen (regexfile, \"r\" FOPEN_BINARY);\n\tif (regexfp == NULL)\n\t  pfatal (regexfile);\n\tlinebuffer_init (&regexbuf);\n\twhile (readline_internal (&regexbuf, regexfp, regexfile) > 0)\n\t  analyze_regex (regexbuf.buffer);\n\tfree (regexbuf.buffer);\n\tif (fclose (regexfp) != 0)\n\t  pfatal (regexfile);\n      }\n      break;\n\n      /* Regexp to be used for a specific language only. */\n    case '{':\n      {\n\tlanguage *lang;\n\tchar *lang_name = regex_arg + 1;\n\tchar *cp;\n\n\tfor (cp = lang_name; *cp != '}'; cp++)\n\t  if (*cp == '\\0')\n\t    {\n\t      error (\"unterminated language name in regex: %s\", regex_arg);\n\t      return;\n\t    }\n\t*cp++ = '\\0';\n\tlang = get_language_from_langname (lang_name);\n\tif (lang == NULL)\n\t  return;\n\tadd_regex (cp, lang);\n      }\n      break;\n\n      /* Regexp to be used for any language. */\n    default:\n      add_regex (regex_arg, NULL);\n      break;\n    }\n}",
        "func": "static void\nanalyze_regex (char *regex_arg)\n{\n  if (regex_arg == NULL)\n    {\n      free_regexps ();\t\t/* --no-regex: remove existing regexps */\n      return;\n    }\n\n  /* A real --regexp option or a line in a regexp file. */\n  switch (regex_arg[0])\n    {\n      /* Comments in regexp file or null arg to --regex. */\n    case '\\0':\n    case ' ':\n    case '\\t':\n      break;\n\n      /* Read a regex file.  This is recursive and may result in a\n\t loop, which will stop when the file descriptors are exhausted. */\n    case '@':\n      {\n\tFILE *regexfp;\n\tlinebuffer regexbuf;\n\tchar *regexfile = regex_arg + 1;\n\n\t/* regexfile is a file containing regexps, one per line. */\n\tregexfp = fopen (regexfile, \"r\" FOPEN_BINARY);\n\tif (regexfp == NULL)\n\t  pfatal (regexfile);\n\tlinebuffer_init (&regexbuf);\n\twhile (readline_internal (&regexbuf, regexfp, regexfile, false) > 0)\n\t  analyze_regex (regexbuf.buffer);\n\tfree (regexbuf.buffer);\n\tif (fclose (regexfp) != 0)\n\t  pfatal (regexfile);\n      }\n      break;\n\n      /* Regexp to be used for a specific language only. */\n    case '{':\n      {\n\tlanguage *lang;\n\tchar *lang_name = regex_arg + 1;\n\tchar *cp;\n\n\tfor (cp = lang_name; *cp != '}'; cp++)\n\t  if (*cp == '\\0')\n\t    {\n\t      error (\"unterminated language name in regex: %s\", regex_arg);\n\t      return;\n\t    }\n\t*cp++ = '\\0';\n\tlang = get_language_from_langname (lang_name);\n\tif (lang == NULL)\n\t  return;\n\tadd_regex (cp, lang);\n      }\n      break;\n\n      /* Regexp to be used for any language. */\n    default:\n      add_regex (regex_arg, NULL);\n      break;\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -29,7 +29,7 @@\n \tif (regexfp == NULL)\n \t  pfatal (regexfile);\n \tlinebuffer_init (&regexbuf);\n-\twhile (readline_internal (&regexbuf, regexfp, regexfile) > 0)\n+\twhile (readline_internal (&regexbuf, regexfp, regexfile, false) > 0)\n \t  analyze_regex (regexbuf.buffer);\n \tfree (regexbuf.buffer);\n \tif (fclose (regexfp) != 0)",
        "diff_line_info": {
            "deleted_lines": [
                "\twhile (readline_internal (&regexbuf, regexfp, regexfile) > 0)"
            ],
            "added_lines": [
                "\twhile (readline_internal (&regexbuf, regexfp, regexfile, false) > 0)"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-45939",
        "func_name": "emacs/readline_internal",
        "description": "GNU Emacs through 28.2 allows attackers to execute commands via shell metacharacters in the name of a source-code file, because lib-src/etags.c uses the system C library function in its implementation of the ctags program. For example, a victim may use the \"ctags *\" command (suggested in the ctags documentation) in a situation where the current working directory has contents that depend on untrusted input.",
        "git_url": "https://git.savannah.gnu.org/cgit/emacs.git/commit/?id=d48bb4874bc6cd3e69c7a15fc3c91cc141025c51",
        "commit_title": "* lib-src/etags.c:",
        "commit_text": " (clean_matched_file_tag): New function (do_move_file): New function (readline_internal): Add `leave_cr` parameter, if true, include the \\r character  * test/manual/etags/CTAGS.good_crlf: New file * test/manual/etags/CTAGS.good_update: New file * test/manual/etags/crlf: New file * test/manual/etags/Makefile: Add `ctags -u` test cases ",
        "func_before": "static ptrdiff_t\nreadline_internal (linebuffer *lbp, FILE *stream, char const *filename)\n{\n  char *buffer = lbp->buffer;\n  char *p = lbp->buffer;\n  char *pend;\n  int chars_deleted;\n\n  pend = p + lbp->size;\t\t/* Separate to avoid 386/IX compiler bug.  */\n\n  for (;;)\n    {\n      register int c = getc (stream);\n      if (p == pend)\n\t{\n\t  /* We're at the end of linebuffer: expand it. */\n\t  xrnew (buffer, lbp->size, 2);\n\t  p = buffer + lbp->size;\n\t  lbp->size *= 2;\n\t  pend = buffer + lbp->size;\n\t  lbp->buffer = buffer;\n\t}\n      if (c == EOF)\n\t{\n\t  if (ferror (stream))\n\t    perror (filename);\n\t  *p = '\\0';\n\t  chars_deleted = 0;\n\t  break;\n\t}\n      if (c == '\\n')\n\t{\n\t  if (p > buffer && p[-1] == '\\r')\n\t    {\n\t      p -= 1;\n\t      chars_deleted = 2;\n\t    }\n\t  else\n\t    {\n\t      chars_deleted = 1;\n\t    }\n\t  *p = '\\0';\n\t  break;\n\t}\n      *p++ = c;\n    }\n  lbp->len = p - buffer;\n\n  if (need_filebuf\t\t/* we need filebuf for multi-line regexps */\n      && chars_deleted > 0)\t/* not at EOF */\n    {\n      while (filebuf.size <= filebuf.len + lbp->len + 1) /* +1 for \\n */\n\t{\n\t  /* Expand filebuf. */\n\t  xrnew (filebuf.buffer, filebuf.size, 2);\n\t  filebuf.size *= 2;\n\t}\n      strcpy (mempcpy (filebuf.buffer + filebuf.len, lbp->buffer, lbp->len),\n\t      \"\\n\");\n      filebuf.len += lbp->len + 1;\n    }\n\n  return lbp->len + chars_deleted;\n}",
        "func": "static ptrdiff_t\nreadline_internal (linebuffer *lbp, FILE *stream, char const *filename, const bool leave_cr)\n{\n  char *buffer = lbp->buffer;\n  char *p = lbp->buffer;\n  char *pend;\n  int chars_deleted;\n\n  pend = p + lbp->size;\t\t/* Separate to avoid 386/IX compiler bug.  */\n\n  for (;;)\n    {\n      register int c = getc (stream);\n      if (p == pend)\n\t{\n\t  /* We're at the end of linebuffer: expand it. */\n\t  xrnew (buffer, lbp->size, 2);\n\t  p = buffer + lbp->size;\n\t  lbp->size *= 2;\n\t  pend = buffer + lbp->size;\n\t  lbp->buffer = buffer;\n\t}\n      if (c == EOF)\n\t{\n\t  if (ferror (stream))\n\t    perror (filename);\n\t  *p = '\\0';\n\t  chars_deleted = 0;\n\t  break;\n\t}\n      if (c == '\\n')\n        {\n          if (!leave_cr && p > buffer && p[-1] == '\\r')\n            {\n              p -= 1;\n              chars_deleted = 2;\n            }\n          else\n            {\n              chars_deleted = 1;\n            }\n          *p = '\\0';\n          break;\n        }\n      *p++ = c;\n    }\n  lbp->len = p - buffer;\n\n  if (need_filebuf\t\t/* we need filebuf for multi-line regexps */\n      && chars_deleted > 0)\t/* not at EOF */\n    {\n      while (filebuf.size <= filebuf.len + lbp->len + 1) /* +1 for \\n */\n\t{\n\t  /* Expand filebuf. */\n\t  xrnew (filebuf.buffer, filebuf.size, 2);\n\t  filebuf.size *= 2;\n\t}\n      strcpy (mempcpy (filebuf.buffer + filebuf.len, lbp->buffer, lbp->len),\n\t      \"\\n\");\n      filebuf.len += lbp->len + 1;\n    }\n\n  return lbp->len + chars_deleted;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,5 @@\n static ptrdiff_t\n-readline_internal (linebuffer *lbp, FILE *stream, char const *filename)\n+readline_internal (linebuffer *lbp, FILE *stream, char const *filename, const bool leave_cr)\n {\n   char *buffer = lbp->buffer;\n   char *p = lbp->buffer;\n@@ -29,19 +29,19 @@\n \t  break;\n \t}\n       if (c == '\\n')\n-\t{\n-\t  if (p > buffer && p[-1] == '\\r')\n-\t    {\n-\t      p -= 1;\n-\t      chars_deleted = 2;\n-\t    }\n-\t  else\n-\t    {\n-\t      chars_deleted = 1;\n-\t    }\n-\t  *p = '\\0';\n-\t  break;\n-\t}\n+        {\n+          if (!leave_cr && p > buffer && p[-1] == '\\r')\n+            {\n+              p -= 1;\n+              chars_deleted = 2;\n+            }\n+          else\n+            {\n+              chars_deleted = 1;\n+            }\n+          *p = '\\0';\n+          break;\n+        }\n       *p++ = c;\n     }\n   lbp->len = p - buffer;",
        "diff_line_info": {
            "deleted_lines": [
                "readline_internal (linebuffer *lbp, FILE *stream, char const *filename)",
                "\t{",
                "\t  if (p > buffer && p[-1] == '\\r')",
                "\t    {",
                "\t      p -= 1;",
                "\t      chars_deleted = 2;",
                "\t    }",
                "\t  else",
                "\t    {",
                "\t      chars_deleted = 1;",
                "\t    }",
                "\t  *p = '\\0';",
                "\t  break;",
                "\t}"
            ],
            "added_lines": [
                "readline_internal (linebuffer *lbp, FILE *stream, char const *filename, const bool leave_cr)",
                "        {",
                "          if (!leave_cr && p > buffer && p[-1] == '\\r')",
                "            {",
                "              p -= 1;",
                "              chars_deleted = 2;",
                "            }",
                "          else",
                "            {",
                "              chars_deleted = 1;",
                "            }",
                "          *p = '\\0';",
                "          break;",
                "        }"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-45939",
        "func_name": "emacs/main",
        "description": "GNU Emacs through 28.2 allows attackers to execute commands via shell metacharacters in the name of a source-code file, because lib-src/etags.c uses the system C library function in its implementation of the ctags program. For example, a victim may use the \"ctags *\" command (suggested in the ctags documentation) in a situation where the current working directory has contents that depend on untrusted input.",
        "git_url": "https://git.savannah.gnu.org/cgit/emacs.git/commit/?id=d48bb4874bc6cd3e69c7a15fc3c91cc141025c51",
        "commit_title": "* lib-src/etags.c:",
        "commit_text": " (clean_matched_file_tag): New function (do_move_file): New function (readline_internal): Add `leave_cr` parameter, if true, include the \\r character  * test/manual/etags/CTAGS.good_crlf: New file * test/manual/etags/CTAGS.good_update: New file * test/manual/etags/crlf: New file * test/manual/etags/Makefile: Add `ctags -u` test cases ",
        "func_before": "int\nmain (int argc, char **argv)\n{\n  int i;\n  int nincluded_files;\n  char **included_files;\n  argument *argbuffer;\n  int current_arg, file_count;\n  linebuffer filename_lb;\n  bool help_asked = false;\n  ptrdiff_t len;\n  char *optstring;\n  int opt;\n\n  progname = argv[0];\n  nincluded_files = 0;\n  included_files = xnew (argc, char *);\n  current_arg = 0;\n  file_count = 0;\n\n  /* Allocate enough no matter what happens.  Overkill, but each one\n     is small. */\n  argbuffer = xnew (argc, argument);\n\n  /*\n   * Always find typedefs and structure tags.\n   * Also default to find macro constants, enum constants, struct\n   * members and global variables.  Do it for both etags and ctags.\n   */\n  typedefs = typedefs_or_cplusplus = constantypedefs = true;\n  globals = members = true;\n\n  /* When the optstring begins with a '-' getopt_long does not rearrange the\n     non-options arguments to be at the end, but leaves them alone. */\n  optstring = concat (\"-ac:Cf:Il:o:Qr:RSVhH\",\n\t\t      (CTAGS) ? \"BxdtTuvw\" : \"Di:\",\n\t\t      \"\");\n\n  while ((opt = getopt_long (argc, argv, optstring, longopts, NULL)) != EOF)\n    switch (opt)\n      {\n      case 0:\n\t/* If getopt returns 0, then it has already processed a\n\t   long-named option.  We should do nothing.  */\n\tbreak;\n\n      case 1:\n\t/* This means that a file name has been seen.  Record it. */\n\targbuffer[current_arg].arg_type = at_filename;\n\targbuffer[current_arg].what     = optarg;\n\tlen = strlen (optarg);\n\tif (whatlen_max < len)\n\t  whatlen_max = len;\n\t++current_arg;\n\t++file_count;\n\tbreak;\n\n      case STDIN:\n\t/* Parse standard input.  Idea by Vivek <vivek@etla.org>. */\n\targbuffer[current_arg].arg_type = at_stdin;\n\targbuffer[current_arg].what     = optarg;\n\tlen = strlen (optarg);\n\tif (whatlen_max < len)\n\t  whatlen_max = len;\n\t++current_arg;\n\t++file_count;\n\tif (parsing_stdin)\n\t  fatal (\"cannot parse standard input more than once\");\n\tparsing_stdin = true;\n\tbreak;\n\n\t/* Common options. */\n      case 'a': append_to_tagfile = true;\tbreak;\n      case 'C': cplusplus = true;\t\tbreak;\n      case 'f':\t\t/* for compatibility with old makefiles */\n      case 'o':\n\tif (tagfile)\n\t  {\n\t    error (\"-o option may only be given once.\");\n\t    suggest_asking_for_help ();\n\t  }\n\ttagfile = optarg;\n\tbreak;\n      case 'I':\n      case 'S':\t\t/* for backward compatibility */\n\tignoreindent = true;\n\tbreak;\n      case 'l':\n\t{\n\t  language *lang = get_language_from_langname (optarg);\n\t  if (lang != NULL)\n\t    {\n\t      argbuffer[current_arg].lang = lang;\n\t      argbuffer[current_arg].arg_type = at_language;\n\t      ++current_arg;\n\t    }\n\t}\n\tbreak;\n      case 'c':\n\t/* Backward compatibility: support obsolete --ignore-case-regexp. */\n\toptarg = concat (optarg, \"i\", \"\"); /* memory leak here */\n\tFALLTHROUGH;\n      case 'r':\n\targbuffer[current_arg].arg_type = at_regexp;\n\targbuffer[current_arg].what = optarg;\n\tlen = strlen (optarg);\n\tif (whatlen_max < len)\n\t  whatlen_max = len;\n\t++current_arg;\n\tbreak;\n      case 'R':\n\targbuffer[current_arg].arg_type = at_regexp;\n\targbuffer[current_arg].what = NULL;\n\t++current_arg;\n\tbreak;\n      case 'V':\n\tprint_version ();\n\tbreak;\n      case 'h':\n      case 'H':\n\thelp_asked = true;\n\tbreak;\n      case 'Q':\n\tclass_qualify = 1;\n\tbreak;\n\n\t/* Etags options */\n      case 'D': constantypedefs = false;\t\t\tbreak;\n      case 'i': included_files[nincluded_files++] = optarg;\tbreak;\n\n\t/* Ctags options. */\n      case 'B': searchar = '?';\t\t\t\t\tbreak;\n      case 'd': constantypedefs = true;\t\t\t\tbreak;\n      case 't': typedefs = true;\t\t\t\tbreak;\n      case 'T': typedefs = typedefs_or_cplusplus = true;\tbreak;\n      case 'u': update = true;\t\t\t\t\tbreak;\n      case 'v': vgrind_style = true;\t\t\t\tFALLTHROUGH;\n      case 'x': cxref_style = true;\t\t\t\tbreak;\n      case 'w': no_warnings = true;\t\t\t\tbreak;\n      default:\n\tsuggest_asking_for_help ();\n      }\n\n  /* No more options.  Store the rest of arguments. */\n  for (; optind < argc; optind++)\n    {\n      argbuffer[current_arg].arg_type = at_filename;\n      argbuffer[current_arg].what = argv[optind];\n      len = strlen (argv[optind]);\n      if (whatlen_max < len)\n\twhatlen_max = len;\n      ++current_arg;\n      ++file_count;\n    }\n\n  argbuffer[current_arg].arg_type = at_end;\n\n  if (help_asked)\n    print_help (argbuffer);\n\n  if (nincluded_files == 0 && file_count == 0)\n    {\n      error (\"no input files specified.\");\n      suggest_asking_for_help ();\n    }\n\n  if (tagfile == NULL)\n    tagfile = savestr (CTAGS ? \"tags\" : \"TAGS\");\n  cwd = etags_getcwd ();\t/* the current working directory */\n  if (cwd[strlen (cwd) - 1] != '/')\n    {\n      char *oldcwd = cwd;\n      cwd = concat (oldcwd, \"/\", \"\");\n      free (oldcwd);\n    }\n\n  /* Compute base directory for relative file names. */\n  if (streq (tagfile, \"-\")\n      || strneq (tagfile, \"/dev/\", 5))\n    tagfiledir = cwd;\t\t /* relative file names are relative to cwd */\n  else\n    {\n      canonicalize_filename (tagfile);\n      tagfiledir = absolute_dirname (tagfile, cwd);\n    }\n\n  linebuffer_init (&lb);\n  linebuffer_init (&filename_lb);\n  linebuffer_init (&filebuf);\n  linebuffer_init (&token_name);\n\n  if (!CTAGS)\n    {\n      if (streq (tagfile, \"-\"))\n\t{\n\t  tagf = stdout;\n\t  set_binary_mode (STDOUT_FILENO, O_BINARY);\n\t}\n      else\n\ttagf = fopen (tagfile, append_to_tagfile ? \"ab\" : \"wb\");\n      if (tagf == NULL)\n\tpfatal (tagfile);\n    }\n\n  /*\n   * Loop through files finding functions.\n   */\n  for (i = 0; i < current_arg; i++)\n    {\n      static language *lang;\t/* non-NULL if language is forced */\n      char *this_file;\n\n      switch (argbuffer[i].arg_type)\n\t{\n\tcase at_language:\n\t  lang = argbuffer[i].lang;\n\t  break;\n\tcase at_regexp:\n\t  analyze_regex (argbuffer[i].what);\n\t  break;\n\tcase at_filename:\n\t      this_file = argbuffer[i].what;\n\t      /* Input file named \"-\" means read file names from stdin\n\t\t (one per line) and use them. */\n\t      if (streq (this_file, \"-\"))\n\t\t{\n\t\t  if (parsing_stdin)\n\t\t    fatal (\"cannot parse standard input \"\n\t\t\t   \"AND read file names from it\");\n\t\t  while (readline_internal (&filename_lb, stdin, \"-\") > 0)\n\t\t    process_file_name (filename_lb.buffer, lang);\n\t\t}\n\t      else\n\t\tprocess_file_name (this_file, lang);\n\t  break;\n        case at_stdin:\n          this_file = argbuffer[i].what;\n          process_file (stdin, this_file, lang);\n          break;\n\tdefault:\n\t  error (\"internal error: arg_type\");\n\t}\n    }\n\n  free_regexps ();\n  free (lb.buffer);\n  free (filebuf.buffer);\n  free (token_name.buffer);\n\n  if (!CTAGS || cxref_style)\n    {\n      /* Write the remaining tags to tagf (ETAGS) or stdout (CXREF). */\n      put_entries (nodehead);\n      free_tree (nodehead);\n      nodehead = NULL;\n      if (!CTAGS)\n\t{\n\t  fdesc *fdp;\n\n\t  /* Output file entries that have no tags. */\n\t  for (fdp = fdhead; fdp != NULL; fdp = fdp->next)\n\t    if (!fdp->written)\n\t      fprintf (tagf, \"\\f\\n%s,0\\n\", fdp->taggedfname);\n\n\t  while (nincluded_files-- > 0)\n\t    fprintf (tagf, \"\\f\\n%s,include\\n\", *included_files++);\n\n\t  if (fclose (tagf) == EOF)\n\t    pfatal (tagfile);\n\t}\n\n      return EXIT_SUCCESS;\n    }\n\n  /* From here on, we are in (CTAGS && !cxref_style) */\n  if (update)\n    {\n      char *cmd =\n\txmalloc (strlen (tagfile) + whatlen_max +\n\t\t sizeof \"mv..OTAGS;grep -Fv '\\t\\t' OTAGS >;rm OTAGS\");\n      for (i = 0; i < current_arg; ++i)\n\t{\n\t  switch (argbuffer[i].arg_type)\n\t    {\n\t    case at_filename:\n\t    case at_stdin:\n\t      break;\n\t    default:\n\t      continue;\t\t/* the for loop */\n\t    }\n\t  char *z = stpcpy (cmd, \"mv \");\n\t  z = stpcpy (z, tagfile);\n\t  z = stpcpy (z, \" OTAGS;grep -Fv '\\t\");\n\t  z = stpcpy (z, argbuffer[i].what);\n\t  z = stpcpy (z, \"\\t' OTAGS >\");\n\t  z = stpcpy (z, tagfile);\n\t  strcpy (z, \";rm OTAGS\");\n\t  if (system (cmd) != EXIT_SUCCESS)\n\t    fatal (\"failed to execute shell command\");\n\t}\n      free (cmd);\n      append_to_tagfile = true;\n    }\n\n  tagf = fopen (tagfile, append_to_tagfile ? \"ab\" : \"wb\");\n  if (tagf == NULL)\n    pfatal (tagfile);\n  put_entries (nodehead);\t/* write all the tags (CTAGS) */\n  free_tree (nodehead);\n  nodehead = NULL;\n  if (fclose (tagf) == EOF)\n    pfatal (tagfile);\n\n  if (CTAGS)\n    if (append_to_tagfile || update)\n      {\n\t/* Maybe these should be used:\n\t   setenv (\"LC_COLLATE\", \"C\", 1);\n\t   setenv (\"LC_ALL\", \"C\", 1); */\n\tchar *cmd = xmalloc (8 * strlen (tagfile) + sizeof \"sort -u -o '' ''\");\n#if defined WINDOWSNT || defined MSDOS\n\t/* Quote \"like this\".  No need to escape the quotes in the file name,\n\t   since it is not allowed in file names on these systems.  */\n\tchar *z = stpcpy (cmd, \"sort -u -o \\\"\");\n\tz = stpcpy (z, tagfile);\n\tz = stpcpy (z, \"\\\" \\\"\");\n\tz = stpcpy (z, tagfile);\n\tstpcpy (z, \"\\\"\");\n#else\n\t/* Quote 'like this', and escape the apostrophe in the file name.  */\n\tchar *z = stpcpy (cmd, \"sort -u -o '\");\n\tchar *escaped_tagfile = z;\n\tfor (; *tagfile; *z++ = *tagfile++)\n\t  if (*tagfile == '\\'')\n\t    z = stpcpy (z, \"'\\\\'\");\n\tptrdiff_t escaped_tagfile_len = z - escaped_tagfile;\n\tz = stpcpy (z, \"' '\");\n\tz = mempcpy (z, escaped_tagfile, escaped_tagfile_len);\n\tstrcpy (z, \"'\");\n#endif\n\treturn system (cmd);\n      }\n  return EXIT_SUCCESS;\n}",
        "func": "int\nmain (int argc, char **argv)\n{\n  int i;\n  int nincluded_files;\n  char **included_files;\n  argument *argbuffer;\n  int current_arg, file_count;\n  linebuffer filename_lb;\n  bool help_asked = false;\n  ptrdiff_t len;\n  char *optstring;\n  int opt;\n\n  progname = argv[0];\n  nincluded_files = 0;\n  included_files = xnew (argc, char *);\n  current_arg = 0;\n  file_count = 0;\n\n  /* Allocate enough no matter what happens.  Overkill, but each one\n     is small. */\n  argbuffer = xnew (argc, argument);\n\n  /*\n   * Always find typedefs and structure tags.\n   * Also default to find macro constants, enum constants, struct\n   * members and global variables.  Do it for both etags and ctags.\n   */\n  typedefs = typedefs_or_cplusplus = constantypedefs = true;\n  globals = members = true;\n\n  /* When the optstring begins with a '-' getopt_long does not rearrange the\n     non-options arguments to be at the end, but leaves them alone. */\n  optstring = concat (\"-ac:Cf:Il:o:Qr:RSVhH\",\n\t\t      (CTAGS) ? \"BxdtTuvw\" : \"Di:\",\n\t\t      \"\");\n\n  while ((opt = getopt_long (argc, argv, optstring, longopts, NULL)) != EOF)\n    switch (opt)\n      {\n      case 0:\n\t/* If getopt returns 0, then it has already processed a\n\t   long-named option.  We should do nothing.  */\n\tbreak;\n\n      case 1:\n\t/* This means that a file name has been seen.  Record it. */\n\targbuffer[current_arg].arg_type = at_filename;\n\targbuffer[current_arg].what     = optarg;\n\tlen = strlen (optarg);\n\tif (whatlen_max < len)\n\t  whatlen_max = len;\n\t++current_arg;\n\t++file_count;\n\tbreak;\n\n      case STDIN:\n\t/* Parse standard input.  Idea by Vivek <vivek@etla.org>. */\n\targbuffer[current_arg].arg_type = at_stdin;\n\targbuffer[current_arg].what     = optarg;\n\tlen = strlen (optarg);\n\tif (whatlen_max < len)\n\t  whatlen_max = len;\n\t++current_arg;\n\t++file_count;\n\tif (parsing_stdin)\n\t  fatal (\"cannot parse standard input more than once\");\n\tparsing_stdin = true;\n\tbreak;\n\n\t/* Common options. */\n      case 'a': append_to_tagfile = true;\tbreak;\n      case 'C': cplusplus = true;\t\tbreak;\n      case 'f':\t\t/* for compatibility with old makefiles */\n      case 'o':\n\tif (tagfile)\n\t  {\n\t    error (\"-o option may only be given once.\");\n\t    suggest_asking_for_help ();\n\t  }\n\ttagfile = optarg;\n\tbreak;\n      case 'I':\n      case 'S':\t\t/* for backward compatibility */\n\tignoreindent = true;\n\tbreak;\n      case 'l':\n\t{\n\t  language *lang = get_language_from_langname (optarg);\n\t  if (lang != NULL)\n\t    {\n\t      argbuffer[current_arg].lang = lang;\n\t      argbuffer[current_arg].arg_type = at_language;\n\t      ++current_arg;\n\t    }\n\t}\n\tbreak;\n      case 'c':\n\t/* Backward compatibility: support obsolete --ignore-case-regexp. */\n\toptarg = concat (optarg, \"i\", \"\"); /* memory leak here */\n\tFALLTHROUGH;\n      case 'r':\n\targbuffer[current_arg].arg_type = at_regexp;\n\targbuffer[current_arg].what = optarg;\n\tlen = strlen (optarg);\n\tif (whatlen_max < len)\n\t  whatlen_max = len;\n\t++current_arg;\n\tbreak;\n      case 'R':\n\targbuffer[current_arg].arg_type = at_regexp;\n\targbuffer[current_arg].what = NULL;\n\t++current_arg;\n\tbreak;\n      case 'V':\n\tprint_version ();\n\tbreak;\n      case 'h':\n      case 'H':\n\thelp_asked = true;\n\tbreak;\n      case 'Q':\n\tclass_qualify = 1;\n\tbreak;\n\n\t/* Etags options */\n      case 'D': constantypedefs = false;\t\t\tbreak;\n      case 'i': included_files[nincluded_files++] = optarg;\tbreak;\n\n\t/* Ctags options. */\n      case 'B': searchar = '?';\t\t\t\t\tbreak;\n      case 'd': constantypedefs = true;\t\t\t\tbreak;\n      case 't': typedefs = true;\t\t\t\tbreak;\n      case 'T': typedefs = typedefs_or_cplusplus = true;\tbreak;\n      case 'u': update = true;\t\t\t\t\tbreak;\n      case 'v': vgrind_style = true;\t\t\t\tFALLTHROUGH;\n      case 'x': cxref_style = true;\t\t\t\tbreak;\n      case 'w': no_warnings = true;\t\t\t\tbreak;\n      default:\n\tsuggest_asking_for_help ();\n      }\n\n  /* No more options.  Store the rest of arguments. */\n  for (; optind < argc; optind++)\n    {\n      argbuffer[current_arg].arg_type = at_filename;\n      argbuffer[current_arg].what = argv[optind];\n      len = strlen (argv[optind]);\n      if (whatlen_max < len)\n\twhatlen_max = len;\n      ++current_arg;\n      ++file_count;\n    }\n\n  argbuffer[current_arg].arg_type = at_end;\n\n  if (help_asked)\n    print_help (argbuffer);\n\n  if (nincluded_files == 0 && file_count == 0)\n    {\n      error (\"no input files specified.\");\n      suggest_asking_for_help ();\n    }\n\n  if (tagfile == NULL)\n    tagfile = savestr (CTAGS ? \"tags\" : \"TAGS\");\n  cwd = etags_getcwd ();\t/* the current working directory */\n  if (cwd[strlen (cwd) - 1] != '/')\n    {\n      char *oldcwd = cwd;\n      cwd = concat (oldcwd, \"/\", \"\");\n      free (oldcwd);\n    }\n\n  /* Compute base directory for relative file names. */\n  if (streq (tagfile, \"-\")\n      || strneq (tagfile, \"/dev/\", 5))\n    tagfiledir = cwd;\t\t /* relative file names are relative to cwd */\n  else\n    {\n      canonicalize_filename (tagfile);\n      tagfiledir = absolute_dirname (tagfile, cwd);\n    }\n\n  linebuffer_init (&lb);\n  linebuffer_init (&filename_lb);\n  linebuffer_init (&filebuf);\n  linebuffer_init (&token_name);\n\n  if (!CTAGS)\n    {\n      if (streq (tagfile, \"-\"))\n\t{\n\t  tagf = stdout;\n\t  set_binary_mode (STDOUT_FILENO, O_BINARY);\n\t}\n      else\n\ttagf = fopen (tagfile, append_to_tagfile ? \"ab\" : \"wb\");\n      if (tagf == NULL)\n\tpfatal (tagfile);\n    }\n\n  /*\n   * Loop through files finding functions.\n   */\n  for (i = 0; i < current_arg; i++)\n    {\n      static language *lang;\t/* non-NULL if language is forced */\n      char *this_file;\n\n      switch (argbuffer[i].arg_type)\n\t{\n\tcase at_language:\n\t  lang = argbuffer[i].lang;\n\t  break;\n\tcase at_regexp:\n\t  analyze_regex (argbuffer[i].what);\n\t  break;\n\tcase at_filename:\n\t      this_file = argbuffer[i].what;\n\t      /* Input file named \"-\" means read file names from stdin\n\t\t (one per line) and use them. */\n\t      if (streq (this_file, \"-\"))\n\t\t{\n\t\t  if (parsing_stdin)\n\t\t    fatal (\"cannot parse standard input \"\n\t\t\t   \"AND read file names from it\");\n\t\t  while (readline_internal (&filename_lb, stdin, \"-\", false) > 0)\n\t\t    process_file_name (filename_lb.buffer, lang);\n\t\t}\n\t      else\n\t\tprocess_file_name (this_file, lang);\n\t  break;\n        case at_stdin:\n          this_file = argbuffer[i].what;\n          process_file (stdin, this_file, lang);\n          break;\n\tdefault:\n\t  error (\"internal error: arg_type\");\n\t}\n    }\n\n  free_regexps ();\n  free (lb.buffer);\n  free (filebuf.buffer);\n  free (token_name.buffer);\n\n  if (!CTAGS || cxref_style)\n    {\n      /* Write the remaining tags to tagf (ETAGS) or stdout (CXREF). */\n      put_entries (nodehead);\n      free_tree (nodehead);\n      nodehead = NULL;\n      if (!CTAGS)\n\t{\n\t  fdesc *fdp;\n\n\t  /* Output file entries that have no tags. */\n\t  for (fdp = fdhead; fdp != NULL; fdp = fdp->next)\n\t    if (!fdp->written)\n\t      fprintf (tagf, \"\\f\\n%s,0\\n\", fdp->taggedfname);\n\n\t  while (nincluded_files-- > 0)\n\t    fprintf (tagf, \"\\f\\n%s,include\\n\", *included_files++);\n\n\t  if (fclose (tagf) == EOF)\n\t    pfatal (tagfile);\n\t}\n\n      return EXIT_SUCCESS;\n    }\n\n  /* From here on, we are in (CTAGS && !cxref_style) */\n  if (update)\n    {\n      for (i = 0; i < current_arg; ++i)\n\t{\n\t  switch (argbuffer[i].arg_type)\n\t    {\n\t    case at_filename:\n\t    case at_stdin:\n\t      break;\n\t    default:\n\t      continue;\t\t/* the for loop */\n\t    }\n          clean_matched_file_tag (tagfile, argbuffer[i].what);\n\t}\n      append_to_tagfile = true;\n    }\n\n  tagf = fopen (tagfile, append_to_tagfile ? \"ab\" : \"wb\");\n  if (tagf == NULL)\n    pfatal (tagfile);\n  put_entries (nodehead);\t/* write all the tags (CTAGS) */\n  free_tree (nodehead);\n  nodehead = NULL;\n  if (fclose (tagf) == EOF)\n    pfatal (tagfile);\n\n  if (CTAGS)\n    if (append_to_tagfile || update)\n      {\n\t/* Maybe these should be used:\n\t   setenv (\"LC_COLLATE\", \"C\", 1);\n\t   setenv (\"LC_ALL\", \"C\", 1); */\n\tchar *cmd = xmalloc (8 * strlen (tagfile) + sizeof \"sort -u -o '' ''\");\n#if defined WINDOWSNT || defined MSDOS\n\t/* Quote \"like this\".  No need to escape the quotes in the file name,\n\t   since it is not allowed in file names on these systems.  */\n\tchar *z = stpcpy (cmd, \"sort -u -o \\\"\");\n\tz = stpcpy (z, tagfile);\n\tz = stpcpy (z, \"\\\" \\\"\");\n\tz = stpcpy (z, tagfile);\n\tstpcpy (z, \"\\\"\");\n#else\n\t/* Quote 'like this', and escape the apostrophe in the file name.  */\n\tchar *z = stpcpy (cmd, \"sort -u -o '\");\n\tchar *escaped_tagfile = z;\n\tfor (; *tagfile; *z++ = *tagfile++)\n\t  if (*tagfile == '\\'')\n\t    z = stpcpy (z, \"'\\\\'\");\n\tptrdiff_t escaped_tagfile_len = z - escaped_tagfile;\n\tz = stpcpy (z, \"' '\");\n\tz = mempcpy (z, escaped_tagfile, escaped_tagfile_len);\n\tstrcpy (z, \"'\");\n#endif\n\treturn system (cmd);\n      }\n  return EXIT_SUCCESS;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -227,7 +227,7 @@\n \t\t  if (parsing_stdin)\n \t\t    fatal (\"cannot parse standard input \"\n \t\t\t   \"AND read file names from it\");\n-\t\t  while (readline_internal (&filename_lb, stdin, \"-\") > 0)\n+\t\t  while (readline_internal (&filename_lb, stdin, \"-\", false) > 0)\n \t\t    process_file_name (filename_lb.buffer, lang);\n \t\t}\n \t      else\n@@ -275,9 +275,6 @@\n   /* From here on, we are in (CTAGS && !cxref_style) */\n   if (update)\n     {\n-      char *cmd =\n-\txmalloc (strlen (tagfile) + whatlen_max +\n-\t\t sizeof \"mv..OTAGS;grep -Fv '\\t\\t' OTAGS >;rm OTAGS\");\n       for (i = 0; i < current_arg; ++i)\n \t{\n \t  switch (argbuffer[i].arg_type)\n@@ -288,17 +285,8 @@\n \t    default:\n \t      continue;\t\t/* the for loop */\n \t    }\n-\t  char *z = stpcpy (cmd, \"mv \");\n-\t  z = stpcpy (z, tagfile);\n-\t  z = stpcpy (z, \" OTAGS;grep -Fv '\\t\");\n-\t  z = stpcpy (z, argbuffer[i].what);\n-\t  z = stpcpy (z, \"\\t' OTAGS >\");\n-\t  z = stpcpy (z, tagfile);\n-\t  strcpy (z, \";rm OTAGS\");\n-\t  if (system (cmd) != EXIT_SUCCESS)\n-\t    fatal (\"failed to execute shell command\");\n-\t}\n-      free (cmd);\n+          clean_matched_file_tag (tagfile, argbuffer[i].what);\n+\t}\n       append_to_tagfile = true;\n     }\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t  while (readline_internal (&filename_lb, stdin, \"-\") > 0)",
                "      char *cmd =",
                "\txmalloc (strlen (tagfile) + whatlen_max +",
                "\t\t sizeof \"mv..OTAGS;grep -Fv '\\t\\t' OTAGS >;rm OTAGS\");",
                "\t  char *z = stpcpy (cmd, \"mv \");",
                "\t  z = stpcpy (z, tagfile);",
                "\t  z = stpcpy (z, \" OTAGS;grep -Fv '\\t\");",
                "\t  z = stpcpy (z, argbuffer[i].what);",
                "\t  z = stpcpy (z, \"\\t' OTAGS >\");",
                "\t  z = stpcpy (z, tagfile);",
                "\t  strcpy (z, \";rm OTAGS\");",
                "\t  if (system (cmd) != EXIT_SUCCESS)",
                "\t    fatal (\"failed to execute shell command\");",
                "\t}",
                "      free (cmd);"
            ],
            "added_lines": [
                "\t\t  while (readline_internal (&filename_lb, stdin, \"-\", false) > 0)",
                "          clean_matched_file_tag (tagfile, argbuffer[i].what);",
                "\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-45939",
        "func_name": "emacs/find_entries",
        "description": "GNU Emacs through 28.2 allows attackers to execute commands via shell metacharacters in the name of a source-code file, because lib-src/etags.c uses the system C library function in its implementation of the ctags program. For example, a victim may use the \"ctags *\" command (suggested in the ctags documentation) in a situation where the current working directory has contents that depend on untrusted input.",
        "git_url": "https://git.savannah.gnu.org/cgit/emacs.git/commit/?id=d48bb4874bc6cd3e69c7a15fc3c91cc141025c51",
        "commit_title": "* lib-src/etags.c:",
        "commit_text": " (clean_matched_file_tag): New function (do_move_file): New function (readline_internal): Add `leave_cr` parameter, if true, include the \\r character  * test/manual/etags/CTAGS.good_crlf: New file * test/manual/etags/CTAGS.good_update: New file * test/manual/etags/crlf: New file * test/manual/etags/Makefile: Add `ctags -u` test cases ",
        "func_before": "static void\nfind_entries (FILE *inf)\n{\n  char *cp;\n  language *lang = curfdp->lang;\n  Lang_function *parser = NULL;\n\n  /* If user specified a language, use it. */\n  if (lang != NULL && lang->function != NULL)\n    {\n      parser = lang->function;\n    }\n\n  /* Else try to guess the language given the file name. */\n  if (parser == NULL)\n    {\n      lang = get_language_from_filename (curfdp->infname, true);\n\n      /* Disambiguate file names between Objc and Mercury. */\n      if (lang != NULL && strcmp (lang->name, \"objc\") == 0)\n\ttest_objc_is_mercury (curfdp->infname, &lang);\n\n      if (lang != NULL && lang->function != NULL)\n\t{\n\t  curfdp->lang = lang;\n\t  parser = lang->function;\n\t}\n    }\n\n  /* Else look for sharp-bang as the first two characters. */\n  if (parser == NULL\n      && readline_internal (&lb, inf, infilename) > 0\n      && lb.len >= 2\n      && lb.buffer[0] == '#'\n      && lb.buffer[1] == '!')\n    {\n      char *lp;\n\n      /* Set lp to point at the first char after the last slash in the\n         line or, if no slashes, at the first nonblank.  Then set cp to\n\t the first successive blank and terminate the string. */\n      lp = strrchr (lb.buffer+2, '/');\n      if (lp != NULL)\n\tlp += 1;\n      else\n\tlp = skip_spaces (lb.buffer + 2);\n      cp = skip_non_spaces (lp);\n      /* If the \"interpreter\" turns out to be \"env\", the real interpreter is\n\t the next word.  */\n      if (cp > lp && strneq (lp, \"env\", cp - lp))\n\t{\n\t  lp = skip_spaces (cp);\n\t  cp = skip_non_spaces (lp);\n\t}\n      *cp = '\\0';\n\n      if (*lp)\n\t{\n\t  lang = get_language_from_interpreter (lp);\n\t  if (lang != NULL && lang->function != NULL)\n\t    {\n\t      curfdp->lang = lang;\n\t      parser = lang->function;\n\t    }\n\t}\n    }\n\n  reset_input (inf);\n\n  /* Else try to guess the language given the case insensitive file name. */\n  if (parser == NULL)\n    {\n      lang = get_language_from_filename (curfdp->infname, false);\n      if (lang != NULL && lang->function != NULL)\n\t{\n\t  curfdp->lang = lang;\n\t  parser = lang->function;\n\t}\n    }\n\n  /* Else try Fortran or C. */\n  if (parser == NULL)\n    {\n      node *old_last_node = last_node;\n\n      curfdp->lang = get_language_from_langname (\"fortran\");\n      find_entries (inf);\n\n      if (old_last_node == last_node)\n\t/* No Fortran entries found.  Try C. */\n\t{\n\t  reset_input (inf);\n\t  curfdp->lang = get_language_from_langname (cplusplus ? \"c++\" : \"c\");\n\t  find_entries (inf);\n\t}\n      return;\n    }\n\n  if (!no_line_directive\n      && curfdp->lang != NULL && curfdp->lang->metasource)\n    /* It may be that this is a bingo.y file, and we already parsed a bingo.c\n       file, or anyway we parsed a file that is automatically generated from\n       this one.  If this is the case, the bingo.c file contained #line\n       directives that generated tags pointing to this file.  Let's delete\n       them all before parsing this file, which is the real source. */\n    {\n      fdesc **fdpp = &fdhead;\n      while (*fdpp != NULL)\n\tif (*fdpp != curfdp\n\t    && streq ((*fdpp)->taggedfname, curfdp->taggedfname))\n\t  /* We found one of those!  We must delete both the file description\n\t     and all tags referring to it. */\n\t  {\n\t    fdesc *badfdp = *fdpp;\n\n\t    /* Delete the tags referring to badfdp->taggedfname\n\t       that were obtained from badfdp->infname. */\n\t    invalidate_nodes (badfdp, &nodehead);\n\n\t    *fdpp = badfdp->next; /* remove the bad description from the list */\n\t    free_fdesc (badfdp);\n\t  }\n\telse\n\t  fdpp = &(*fdpp)->next; /* advance the list pointer */\n    }\n\n  assert (parser != NULL);\n\n  /* Generic initializations before reading from file. */\n  linebuffer_setlen (&filebuf, 0); /* reset the file buffer */\n\n  /* Generic initializations before parsing file with readline. */\n  lineno = 0;\t\t       /* reset global line number */\n  charno = 0;\t\t       /* reset global char number */\n  linecharno = 0;\t       /* reset global char number of line start */\n\n  parser (inf);\n\n  regex_tag_multiline ();\n}",
        "func": "static void\nfind_entries (FILE *inf)\n{\n  char *cp;\n  language *lang = curfdp->lang;\n  Lang_function *parser = NULL;\n\n  /* If user specified a language, use it. */\n  if (lang != NULL && lang->function != NULL)\n    {\n      parser = lang->function;\n    }\n\n  /* Else try to guess the language given the file name. */\n  if (parser == NULL)\n    {\n      lang = get_language_from_filename (curfdp->infname, true);\n\n      /* Disambiguate file names between Objc and Mercury. */\n      if (lang != NULL && strcmp (lang->name, \"objc\") == 0)\n\ttest_objc_is_mercury (curfdp->infname, &lang);\n\n      if (lang != NULL && lang->function != NULL)\n\t{\n\t  curfdp->lang = lang;\n\t  parser = lang->function;\n\t}\n    }\n\n  /* Else look for sharp-bang as the first two characters. */\n  if (parser == NULL\n      && readline_internal (&lb, inf, infilename, false) > 0\n      && lb.len >= 2\n      && lb.buffer[0] == '#'\n      && lb.buffer[1] == '!')\n    {\n      char *lp;\n\n      /* Set lp to point at the first char after the last slash in the\n         line or, if no slashes, at the first nonblank.  Then set cp to\n\t the first successive blank and terminate the string. */\n      lp = strrchr (lb.buffer+2, '/');\n      if (lp != NULL)\n\tlp += 1;\n      else\n\tlp = skip_spaces (lb.buffer + 2);\n      cp = skip_non_spaces (lp);\n      /* If the \"interpreter\" turns out to be \"env\", the real interpreter is\n\t the next word.  */\n      if (cp > lp && strneq (lp, \"env\", cp - lp))\n\t{\n\t  lp = skip_spaces (cp);\n\t  cp = skip_non_spaces (lp);\n\t}\n      *cp = '\\0';\n\n      if (*lp)\n\t{\n\t  lang = get_language_from_interpreter (lp);\n\t  if (lang != NULL && lang->function != NULL)\n\t    {\n\t      curfdp->lang = lang;\n\t      parser = lang->function;\n\t    }\n\t}\n    }\n\n  reset_input (inf);\n\n  /* Else try to guess the language given the case insensitive file name. */\n  if (parser == NULL)\n    {\n      lang = get_language_from_filename (curfdp->infname, false);\n      if (lang != NULL && lang->function != NULL)\n\t{\n\t  curfdp->lang = lang;\n\t  parser = lang->function;\n\t}\n    }\n\n  /* Else try Fortran or C. */\n  if (parser == NULL)\n    {\n      node *old_last_node = last_node;\n\n      curfdp->lang = get_language_from_langname (\"fortran\");\n      find_entries (inf);\n\n      if (old_last_node == last_node)\n\t/* No Fortran entries found.  Try C. */\n\t{\n\t  reset_input (inf);\n\t  curfdp->lang = get_language_from_langname (cplusplus ? \"c++\" : \"c\");\n\t  find_entries (inf);\n\t}\n      return;\n    }\n\n  if (!no_line_directive\n      && curfdp->lang != NULL && curfdp->lang->metasource)\n    /* It may be that this is a bingo.y file, and we already parsed a bingo.c\n       file, or anyway we parsed a file that is automatically generated from\n       this one.  If this is the case, the bingo.c file contained #line\n       directives that generated tags pointing to this file.  Let's delete\n       them all before parsing this file, which is the real source. */\n    {\n      fdesc **fdpp = &fdhead;\n      while (*fdpp != NULL)\n\tif (*fdpp != curfdp\n\t    && streq ((*fdpp)->taggedfname, curfdp->taggedfname))\n\t  /* We found one of those!  We must delete both the file description\n\t     and all tags referring to it. */\n\t  {\n\t    fdesc *badfdp = *fdpp;\n\n\t    /* Delete the tags referring to badfdp->taggedfname\n\t       that were obtained from badfdp->infname. */\n\t    invalidate_nodes (badfdp, &nodehead);\n\n\t    *fdpp = badfdp->next; /* remove the bad description from the list */\n\t    free_fdesc (badfdp);\n\t  }\n\telse\n\t  fdpp = &(*fdpp)->next; /* advance the list pointer */\n    }\n\n  assert (parser != NULL);\n\n  /* Generic initializations before reading from file. */\n  linebuffer_setlen (&filebuf, 0); /* reset the file buffer */\n\n  /* Generic initializations before parsing file with readline. */\n  lineno = 0;\t\t       /* reset global line number */\n  charno = 0;\t\t       /* reset global char number */\n  linecharno = 0;\t       /* reset global char number of line start */\n\n  parser (inf);\n\n  regex_tag_multiline ();\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -29,7 +29,7 @@\n \n   /* Else look for sharp-bang as the first two characters. */\n   if (parser == NULL\n-      && readline_internal (&lb, inf, infilename) > 0\n+      && readline_internal (&lb, inf, infilename, false) > 0\n       && lb.len >= 2\n       && lb.buffer[0] == '#'\n       && lb.buffer[1] == '!')",
        "diff_line_info": {
            "deleted_lines": [
                "      && readline_internal (&lb, inf, infilename) > 0"
            ],
            "added_lines": [
                "      && readline_internal (&lb, inf, infilename, false) > 0"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-20807",
        "func_name": "vim/check_restricted",
        "description": "In Vim before 8.1.0881, users can circumvent the rvim restricted mode and execute arbitrary OS commands via scripting interfaces (e.g., Python, Ruby, or Lua).",
        "git_url": "https://github.com/vim/vim/commit/8c62a08faf89663e5633dc5036cd8695c80f1075",
        "commit_title": "patch 8.1.0881: can execute shell commands in rvim through interfaces",
        "commit_text": " Problem:    Can execute shell commands in rvim through interfaces. Solution:   Disable using interfaces in restricted mode. Allow for writing             file with writefile(), histadd() and a few others.",
        "func_before": "int\ncheck_restricted(void)\n{\n    if (restricted)\n    {\n\temsg(_(\"E145: Shell commands not allowed in rvim\"));\n\treturn TRUE;\n    }\n    return FALSE;\n}",
        "func": "int\ncheck_restricted(void)\n{\n    if (restricted)\n    {\n\temsg(_(\"E145: Shell commands and some functionality not allowed in rvim\"));\n\treturn TRUE;\n    }\n    return FALSE;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,7 +3,7 @@\n {\n     if (restricted)\n     {\n-\temsg(_(\"E145: Shell commands not allowed in rvim\"));\n+\temsg(_(\"E145: Shell commands and some functionality not allowed in rvim\"));\n \treturn TRUE;\n     }\n     return FALSE;",
        "diff_line_info": {
            "deleted_lines": [
                "\temsg(_(\"E145: Shell commands not allowed in rvim\"));"
            ],
            "added_lines": [
                "\temsg(_(\"E145: Shell commands and some functionality not allowed in rvim\"));"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-20807",
        "func_name": "vim/f_mzeval",
        "description": "In Vim before 8.1.0881, users can circumvent the rvim restricted mode and execute arbitrary OS commands via scripting interfaces (e.g., Python, Ruby, or Lua).",
        "git_url": "https://github.com/vim/vim/commit/8c62a08faf89663e5633dc5036cd8695c80f1075",
        "commit_title": "patch 8.1.0881: can execute shell commands in rvim through interfaces",
        "commit_text": " Problem:    Can execute shell commands in rvim through interfaces. Solution:   Disable using interfaces in restricted mode. Allow for writing             file with writefile(), histadd() and a few others.",
        "func_before": "static void\nf_mzeval(typval_T *argvars, typval_T *rettv)\n{\n    char_u\t*str;\n    char_u\tbuf[NUMBUFLEN];\n\n    str = tv_get_string_buf(&argvars[0], buf);\n    do_mzeval(str, rettv);\n}",
        "func": "static void\nf_mzeval(typval_T *argvars, typval_T *rettv)\n{\n    char_u\t*str;\n    char_u\tbuf[NUMBUFLEN];\n\n    if (check_restricted() || check_secure())\n\treturn;\n    str = tv_get_string_buf(&argvars[0], buf);\n    do_mzeval(str, rettv);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,6 +4,8 @@\n     char_u\t*str;\n     char_u\tbuf[NUMBUFLEN];\n \n+    if (check_restricted() || check_secure())\n+\treturn;\n     str = tv_get_string_buf(&argvars[0], buf);\n     do_mzeval(str, rettv);\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    if (check_restricted() || check_secure())",
                "\treturn;"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-20807",
        "func_name": "vim/f_pyeval",
        "description": "In Vim before 8.1.0881, users can circumvent the rvim restricted mode and execute arbitrary OS commands via scripting interfaces (e.g., Python, Ruby, or Lua).",
        "git_url": "https://github.com/vim/vim/commit/8c62a08faf89663e5633dc5036cd8695c80f1075",
        "commit_title": "patch 8.1.0881: can execute shell commands in rvim through interfaces",
        "commit_text": " Problem:    Can execute shell commands in rvim through interfaces. Solution:   Disable using interfaces in restricted mode. Allow for writing             file with writefile(), histadd() and a few others.",
        "func_before": "static void\nf_pyeval(typval_T *argvars, typval_T *rettv)\n{\n    char_u\t*str;\n    char_u\tbuf[NUMBUFLEN];\n\n    if (p_pyx == 0)\n\tp_pyx = 2;\n\n    str = tv_get_string_buf(&argvars[0], buf);\n    do_pyeval(str, rettv);\n}",
        "func": "static void\nf_pyeval(typval_T *argvars, typval_T *rettv)\n{\n    char_u\t*str;\n    char_u\tbuf[NUMBUFLEN];\n\n    if (check_restricted() || check_secure())\n\treturn;\n\n    if (p_pyx == 0)\n\tp_pyx = 2;\n\n    str = tv_get_string_buf(&argvars[0], buf);\n    do_pyeval(str, rettv);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,6 +3,9 @@\n {\n     char_u\t*str;\n     char_u\tbuf[NUMBUFLEN];\n+\n+    if (check_restricted() || check_secure())\n+\treturn;\n \n     if (p_pyx == 0)\n \tp_pyx = 2;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "    if (check_restricted() || check_secure())",
                "\treturn;"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-20807",
        "func_name": "vim/f_luaeval",
        "description": "In Vim before 8.1.0881, users can circumvent the rvim restricted mode and execute arbitrary OS commands via scripting interfaces (e.g., Python, Ruby, or Lua).",
        "git_url": "https://github.com/vim/vim/commit/8c62a08faf89663e5633dc5036cd8695c80f1075",
        "commit_title": "patch 8.1.0881: can execute shell commands in rvim through interfaces",
        "commit_text": " Problem:    Can execute shell commands in rvim through interfaces. Solution:   Disable using interfaces in restricted mode. Allow for writing             file with writefile(), histadd() and a few others.",
        "func_before": "static void\nf_luaeval(typval_T *argvars, typval_T *rettv)\n{\n    char_u\t*str;\n    char_u\tbuf[NUMBUFLEN];\n\n    str = tv_get_string_buf(&argvars[0], buf);\n    do_luaeval(str, argvars + 1, rettv);\n}",
        "func": "static void\nf_luaeval(typval_T *argvars, typval_T *rettv)\n{\n    char_u\t*str;\n    char_u\tbuf[NUMBUFLEN];\n\n    if (check_restricted() || check_secure())\n\treturn;\n\n    str = tv_get_string_buf(&argvars[0], buf);\n    do_luaeval(str, argvars + 1, rettv);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,6 +4,9 @@\n     char_u\t*str;\n     char_u\tbuf[NUMBUFLEN];\n \n+    if (check_restricted() || check_secure())\n+\treturn;\n+\n     str = tv_get_string_buf(&argvars[0], buf);\n     do_luaeval(str, argvars + 1, rettv);\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    if (check_restricted() || check_secure())",
                "\treturn;",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2019-20807",
        "func_name": "vim/f_py3eval",
        "description": "In Vim before 8.1.0881, users can circumvent the rvim restricted mode and execute arbitrary OS commands via scripting interfaces (e.g., Python, Ruby, or Lua).",
        "git_url": "https://github.com/vim/vim/commit/8c62a08faf89663e5633dc5036cd8695c80f1075",
        "commit_title": "patch 8.1.0881: can execute shell commands in rvim through interfaces",
        "commit_text": " Problem:    Can execute shell commands in rvim through interfaces. Solution:   Disable using interfaces in restricted mode. Allow for writing             file with writefile(), histadd() and a few others.",
        "func_before": "static void\nf_py3eval(typval_T *argvars, typval_T *rettv)\n{\n    char_u\t*str;\n    char_u\tbuf[NUMBUFLEN];\n\n    if (p_pyx == 0)\n\tp_pyx = 3;\n\n    str = tv_get_string_buf(&argvars[0], buf);\n    do_py3eval(str, rettv);\n}",
        "func": "static void\nf_py3eval(typval_T *argvars, typval_T *rettv)\n{\n    char_u\t*str;\n    char_u\tbuf[NUMBUFLEN];\n\n    if (check_restricted() || check_secure())\n\treturn;\n\n    if (p_pyx == 0)\n\tp_pyx = 3;\n\n    str = tv_get_string_buf(&argvars[0], buf);\n    do_py3eval(str, rettv);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,6 +3,9 @@\n {\n     char_u\t*str;\n     char_u\tbuf[NUMBUFLEN];\n+\n+    if (check_restricted() || check_secure())\n+\treturn;\n \n     if (p_pyx == 0)\n \tp_pyx = 3;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "    if (check_restricted() || check_secure())",
                "\treturn;"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-20807",
        "func_name": "vim/f_pyxeval",
        "description": "In Vim before 8.1.0881, users can circumvent the rvim restricted mode and execute arbitrary OS commands via scripting interfaces (e.g., Python, Ruby, or Lua).",
        "git_url": "https://github.com/vim/vim/commit/8c62a08faf89663e5633dc5036cd8695c80f1075",
        "commit_title": "patch 8.1.0881: can execute shell commands in rvim through interfaces",
        "commit_text": " Problem:    Can execute shell commands in rvim through interfaces. Solution:   Disable using interfaces in restricted mode. Allow for writing             file with writefile(), histadd() and a few others.",
        "func_before": "static void\nf_pyxeval(typval_T *argvars, typval_T *rettv)\n{\n# if defined(FEAT_PYTHON) && defined(FEAT_PYTHON3)\n    init_pyxversion();\n    if (p_pyx == 2)\n\tf_pyeval(argvars, rettv);\n    else\n\tf_py3eval(argvars, rettv);\n# elif defined(FEAT_PYTHON)\n    f_pyeval(argvars, rettv);\n# elif defined(FEAT_PYTHON3)\n    f_py3eval(argvars, rettv);\n# endif\n}",
        "func": "static void\nf_pyxeval(typval_T *argvars, typval_T *rettv)\n{\n    if (check_restricted() || check_secure())\n\treturn;\n\n# if defined(FEAT_PYTHON) && defined(FEAT_PYTHON3)\n    init_pyxversion();\n    if (p_pyx == 2)\n\tf_pyeval(argvars, rettv);\n    else\n\tf_py3eval(argvars, rettv);\n# elif defined(FEAT_PYTHON)\n    f_pyeval(argvars, rettv);\n# elif defined(FEAT_PYTHON3)\n    f_py3eval(argvars, rettv);\n# endif\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,9 @@\n static void\n f_pyxeval(typval_T *argvars, typval_T *rettv)\n {\n+    if (check_restricted() || check_secure())\n+\treturn;\n+\n # if defined(FEAT_PYTHON) && defined(FEAT_PYTHON3)\n     init_pyxversion();\n     if (p_pyx == 2)",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    if (check_restricted() || check_secure())",
                "\treturn;",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2019-20807",
        "func_name": "vim/f_setbufvar",
        "description": "In Vim before 8.1.0881, users can circumvent the rvim restricted mode and execute arbitrary OS commands via scripting interfaces (e.g., Python, Ruby, or Lua).",
        "git_url": "https://github.com/vim/vim/commit/8c62a08faf89663e5633dc5036cd8695c80f1075",
        "commit_title": "patch 8.1.0881: can execute shell commands in rvim through interfaces",
        "commit_text": " Problem:    Can execute shell commands in rvim through interfaces. Solution:   Disable using interfaces in restricted mode. Allow for writing             file with writefile(), histadd() and a few others.",
        "func_before": "static void\nf_setbufvar(typval_T *argvars, typval_T *rettv UNUSED)\n{\n    buf_T\t*buf;\n    char_u\t*varname, *bufvarname;\n    typval_T\t*varp;\n    char_u\tnbuf[NUMBUFLEN];\n\n    if (check_restricted() || check_secure())\n\treturn;\n    (void)tv_get_number(&argvars[0]);\t    /* issue errmsg if type error */\n    varname = tv_get_string_chk(&argvars[1]);\n    buf = tv_get_buf(&argvars[0], FALSE);\n    varp = &argvars[2];\n\n    if (buf != NULL && varname != NULL && varp != NULL)\n    {\n\tif (*varname == '&')\n\t{\n\t    long\tnumval;\n\t    char_u\t*strval;\n\t    int\t\terror = FALSE;\n\t    aco_save_T\taco;\n\n\t    /* set curbuf to be our buf, temporarily */\n\t    aucmd_prepbuf(&aco, buf);\n\n\t    ++varname;\n\t    numval = (long)tv_get_number_chk(varp, &error);\n\t    strval = tv_get_string_buf_chk(varp, nbuf);\n\t    if (!error && strval != NULL)\n\t\tset_option_value(varname, numval, strval, OPT_LOCAL);\n\n\t    /* reset notion of buffer */\n\t    aucmd_restbuf(&aco);\n\t}\n\telse\n\t{\n\t    buf_T *save_curbuf = curbuf;\n\n\t    bufvarname = alloc((unsigned)STRLEN(varname) + 3);\n\t    if (bufvarname != NULL)\n\t    {\n\t\tcurbuf = buf;\n\t\tSTRCPY(bufvarname, \"b:\");\n\t\tSTRCPY(bufvarname + 2, varname);\n\t\tset_var(bufvarname, varp, TRUE);\n\t\tvim_free(bufvarname);\n\t\tcurbuf = save_curbuf;\n\t    }\n\t}\n    }\n}",
        "func": "static void\nf_setbufvar(typval_T *argvars, typval_T *rettv UNUSED)\n{\n    buf_T\t*buf;\n    char_u\t*varname, *bufvarname;\n    typval_T\t*varp;\n    char_u\tnbuf[NUMBUFLEN];\n\n    if (check_secure())\n\treturn;\n    (void)tv_get_number(&argvars[0]);\t    /* issue errmsg if type error */\n    varname = tv_get_string_chk(&argvars[1]);\n    buf = tv_get_buf(&argvars[0], FALSE);\n    varp = &argvars[2];\n\n    if (buf != NULL && varname != NULL && varp != NULL)\n    {\n\tif (*varname == '&')\n\t{\n\t    long\tnumval;\n\t    char_u\t*strval;\n\t    int\t\terror = FALSE;\n\t    aco_save_T\taco;\n\n\t    /* set curbuf to be our buf, temporarily */\n\t    aucmd_prepbuf(&aco, buf);\n\n\t    ++varname;\n\t    numval = (long)tv_get_number_chk(varp, &error);\n\t    strval = tv_get_string_buf_chk(varp, nbuf);\n\t    if (!error && strval != NULL)\n\t\tset_option_value(varname, numval, strval, OPT_LOCAL);\n\n\t    /* reset notion of buffer */\n\t    aucmd_restbuf(&aco);\n\t}\n\telse\n\t{\n\t    buf_T *save_curbuf = curbuf;\n\n\t    bufvarname = alloc((unsigned)STRLEN(varname) + 3);\n\t    if (bufvarname != NULL)\n\t    {\n\t\tcurbuf = buf;\n\t\tSTRCPY(bufvarname, \"b:\");\n\t\tSTRCPY(bufvarname + 2, varname);\n\t\tset_var(bufvarname, varp, TRUE);\n\t\tvim_free(bufvarname);\n\t\tcurbuf = save_curbuf;\n\t    }\n\t}\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,7 +6,7 @@\n     typval_T\t*varp;\n     char_u\tnbuf[NUMBUFLEN];\n \n-    if (check_restricted() || check_secure())\n+    if (check_secure())\n \treturn;\n     (void)tv_get_number(&argvars[0]);\t    /* issue errmsg if type error */\n     varname = tv_get_string_chk(&argvars[1]);",
        "diff_line_info": {
            "deleted_lines": [
                "    if (check_restricted() || check_secure())"
            ],
            "added_lines": [
                "    if (check_secure())"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-20807",
        "func_name": "vim/f_histadd",
        "description": "In Vim before 8.1.0881, users can circumvent the rvim restricted mode and execute arbitrary OS commands via scripting interfaces (e.g., Python, Ruby, or Lua).",
        "git_url": "https://github.com/vim/vim/commit/8c62a08faf89663e5633dc5036cd8695c80f1075",
        "commit_title": "patch 8.1.0881: can execute shell commands in rvim through interfaces",
        "commit_text": " Problem:    Can execute shell commands in rvim through interfaces. Solution:   Disable using interfaces in restricted mode. Allow for writing             file with writefile(), histadd() and a few others.",
        "func_before": "static void\nf_histadd(typval_T *argvars UNUSED, typval_T *rettv)\n{\n#ifdef FEAT_CMDHIST\n    int\t\thistype;\n    char_u\t*str;\n    char_u\tbuf[NUMBUFLEN];\n#endif\n\n    rettv->vval.v_number = FALSE;\n    if (check_restricted() || check_secure())\n\treturn;\n#ifdef FEAT_CMDHIST\n    str = tv_get_string_chk(&argvars[0]);\t/* NULL on type error */\n    histype = str != NULL ? get_histtype(str) : -1;\n    if (histype >= 0)\n    {\n\tstr = tv_get_string_buf(&argvars[1], buf);\n\tif (*str != NUL)\n\t{\n\t    init_history();\n\t    add_to_history(histype, str, FALSE, NUL);\n\t    rettv->vval.v_number = TRUE;\n\t    return;\n\t}\n    }\n#endif\n}",
        "func": "static void\nf_histadd(typval_T *argvars UNUSED, typval_T *rettv)\n{\n#ifdef FEAT_CMDHIST\n    int\t\thistype;\n    char_u\t*str;\n    char_u\tbuf[NUMBUFLEN];\n#endif\n\n    rettv->vval.v_number = FALSE;\n    if (check_secure())\n\treturn;\n#ifdef FEAT_CMDHIST\n    str = tv_get_string_chk(&argvars[0]);\t/* NULL on type error */\n    histype = str != NULL ? get_histtype(str) : -1;\n    if (histype >= 0)\n    {\n\tstr = tv_get_string_buf(&argvars[1], buf);\n\tif (*str != NUL)\n\t{\n\t    init_history();\n\t    add_to_history(histype, str, FALSE, NUL);\n\t    rettv->vval.v_number = TRUE;\n\t    return;\n\t}\n    }\n#endif\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -8,7 +8,7 @@\n #endif\n \n     rettv->vval.v_number = FALSE;\n-    if (check_restricted() || check_secure())\n+    if (check_secure())\n \treturn;\n #ifdef FEAT_CMDHIST\n     str = tv_get_string_chk(&argvars[0]);\t/* NULL on type error */",
        "diff_line_info": {
            "deleted_lines": [
                "    if (check_restricted() || check_secure())"
            ],
            "added_lines": [
                "    if (check_secure())"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-20807",
        "func_name": "vim/f_settabvar",
        "description": "In Vim before 8.1.0881, users can circumvent the rvim restricted mode and execute arbitrary OS commands via scripting interfaces (e.g., Python, Ruby, or Lua).",
        "git_url": "https://github.com/vim/vim/commit/8c62a08faf89663e5633dc5036cd8695c80f1075",
        "commit_title": "patch 8.1.0881: can execute shell commands in rvim through interfaces",
        "commit_text": " Problem:    Can execute shell commands in rvim through interfaces. Solution:   Disable using interfaces in restricted mode. Allow for writing             file with writefile(), histadd() and a few others.",
        "func_before": "static void\nf_settabvar(typval_T *argvars, typval_T *rettv)\n{\n    tabpage_T\t*save_curtab;\n    tabpage_T\t*tp;\n    char_u\t*varname, *tabvarname;\n    typval_T\t*varp;\n\n    rettv->vval.v_number = 0;\n\n    if (check_restricted() || check_secure())\n\treturn;\n\n    tp = find_tabpage((int)tv_get_number_chk(&argvars[0], NULL));\n    varname = tv_get_string_chk(&argvars[1]);\n    varp = &argvars[2];\n\n    if (varname != NULL && varp != NULL && tp != NULL)\n    {\n\tsave_curtab = curtab;\n\tgoto_tabpage_tp(tp, FALSE, FALSE);\n\n\ttabvarname = alloc((unsigned)STRLEN(varname) + 3);\n\tif (tabvarname != NULL)\n\t{\n\t    STRCPY(tabvarname, \"t:\");\n\t    STRCPY(tabvarname + 2, varname);\n\t    set_var(tabvarname, varp, TRUE);\n\t    vim_free(tabvarname);\n\t}\n\n\t/* Restore current tabpage */\n\tif (valid_tabpage(save_curtab))\n\t    goto_tabpage_tp(save_curtab, FALSE, FALSE);\n    }\n}",
        "func": "static void\nf_settabvar(typval_T *argvars, typval_T *rettv)\n{\n    tabpage_T\t*save_curtab;\n    tabpage_T\t*tp;\n    char_u\t*varname, *tabvarname;\n    typval_T\t*varp;\n\n    rettv->vval.v_number = 0;\n\n    if (check_secure())\n\treturn;\n\n    tp = find_tabpage((int)tv_get_number_chk(&argvars[0], NULL));\n    varname = tv_get_string_chk(&argvars[1]);\n    varp = &argvars[2];\n\n    if (varname != NULL && varp != NULL && tp != NULL)\n    {\n\tsave_curtab = curtab;\n\tgoto_tabpage_tp(tp, FALSE, FALSE);\n\n\ttabvarname = alloc((unsigned)STRLEN(varname) + 3);\n\tif (tabvarname != NULL)\n\t{\n\t    STRCPY(tabvarname, \"t:\");\n\t    STRCPY(tabvarname + 2, varname);\n\t    set_var(tabvarname, varp, TRUE);\n\t    vim_free(tabvarname);\n\t}\n\n\t/* Restore current tabpage */\n\tif (valid_tabpage(save_curtab))\n\t    goto_tabpage_tp(save_curtab, FALSE, FALSE);\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -8,7 +8,7 @@\n \n     rettv->vval.v_number = 0;\n \n-    if (check_restricted() || check_secure())\n+    if (check_secure())\n \treturn;\n \n     tp = find_tabpage((int)tv_get_number_chk(&argvars[0], NULL));",
        "diff_line_info": {
            "deleted_lines": [
                "    if (check_restricted() || check_secure())"
            ],
            "added_lines": [
                "    if (check_secure())"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-20807",
        "func_name": "vim/f_writefile",
        "description": "In Vim before 8.1.0881, users can circumvent the rvim restricted mode and execute arbitrary OS commands via scripting interfaces (e.g., Python, Ruby, or Lua).",
        "git_url": "https://github.com/vim/vim/commit/8c62a08faf89663e5633dc5036cd8695c80f1075",
        "commit_title": "patch 8.1.0881: can execute shell commands in rvim through interfaces",
        "commit_text": " Problem:    Can execute shell commands in rvim through interfaces. Solution:   Disable using interfaces in restricted mode. Allow for writing             file with writefile(), histadd() and a few others.",
        "func_before": "static void\nf_writefile(typval_T *argvars, typval_T *rettv)\n{\n    int\t\tbinary = FALSE;\n    int\t\tappend = FALSE;\n#ifdef HAVE_FSYNC\n    int\t\tdo_fsync = p_fs;\n#endif\n    char_u\t*fname;\n    FILE\t*fd;\n    int\t\tret = 0;\n    listitem_T\t*li;\n    list_T\t*list = NULL;\n    blob_T\t*blob = NULL;\n\n    rettv->vval.v_number = -1;\n    if (check_restricted() || check_secure())\n\treturn;\n\n    if (argvars[0].v_type == VAR_LIST)\n    {\n\tlist = argvars[0].vval.v_list;\n\tif (list == NULL)\n\t    return;\n\tfor (li = list->lv_first; li != NULL; li = li->li_next)\n\t    if (tv_get_string_chk(&li->li_tv) == NULL)\n\t\treturn;\n    }\n    else if (argvars[0].v_type == VAR_BLOB)\n    {\n\tblob = argvars[0].vval.v_blob;\n\tif (blob == NULL)\n\t    return;\n    }\n    else\n    {\n\tsemsg(_(e_invarg2), \"writefile()\");\n\treturn;\n    }\n\n    if (argvars[2].v_type != VAR_UNKNOWN)\n    {\n\tchar_u *arg2 = tv_get_string_chk(&argvars[2]);\n\n\tif (arg2 == NULL)\n\t    return;\n\tif (vim_strchr(arg2, 'b') != NULL)\n\t    binary = TRUE;\n\tif (vim_strchr(arg2, 'a') != NULL)\n\t    append = TRUE;\n#ifdef HAVE_FSYNC\n\tif (vim_strchr(arg2, 's') != NULL)\n\t    do_fsync = TRUE;\n\telse if (vim_strchr(arg2, 'S') != NULL)\n\t    do_fsync = FALSE;\n#endif\n    }\n\n    fname = tv_get_string_chk(&argvars[1]);\n    if (fname == NULL)\n\treturn;\n\n    /* Always open the file in binary mode, library functions have a mind of\n     * their own about CR-LF conversion. */\n    if (*fname == NUL || (fd = mch_fopen((char *)fname,\n\t\t\t\t      append ? APPENDBIN : WRITEBIN)) == NULL)\n    {\n\tsemsg(_(e_notcreate), *fname == NUL ? (char_u *)_(\"<empty>\") : fname);\n\tret = -1;\n    }\n    else if (blob)\n    {\n\tif (write_blob(fd, blob) == FAIL)\n\t    ret = -1;\n#ifdef HAVE_FSYNC\n\telse if (do_fsync)\n\t    // Ignore the error, the user wouldn't know what to do about it.\n\t    // May happen for a device.\n\t    vim_ignored = fsync(fileno(fd));\n#endif\n\tfclose(fd);\n    }\n    else\n    {\n\tif (write_list(fd, list, binary) == FAIL)\n\t    ret = -1;\n#ifdef HAVE_FSYNC\n\telse if (do_fsync)\n\t    /* Ignore the error, the user wouldn't know what to do about it.\n\t     * May happen for a device. */\n\t    vim_ignored = fsync(fileno(fd));\n#endif\n\tfclose(fd);\n    }\n\n    rettv->vval.v_number = ret;\n}",
        "func": "static void\nf_writefile(typval_T *argvars, typval_T *rettv)\n{\n    int\t\tbinary = FALSE;\n    int\t\tappend = FALSE;\n#ifdef HAVE_FSYNC\n    int\t\tdo_fsync = p_fs;\n#endif\n    char_u\t*fname;\n    FILE\t*fd;\n    int\t\tret = 0;\n    listitem_T\t*li;\n    list_T\t*list = NULL;\n    blob_T\t*blob = NULL;\n\n    rettv->vval.v_number = -1;\n    if (check_secure())\n\treturn;\n\n    if (argvars[0].v_type == VAR_LIST)\n    {\n\tlist = argvars[0].vval.v_list;\n\tif (list == NULL)\n\t    return;\n\tfor (li = list->lv_first; li != NULL; li = li->li_next)\n\t    if (tv_get_string_chk(&li->li_tv) == NULL)\n\t\treturn;\n    }\n    else if (argvars[0].v_type == VAR_BLOB)\n    {\n\tblob = argvars[0].vval.v_blob;\n\tif (blob == NULL)\n\t    return;\n    }\n    else\n    {\n\tsemsg(_(e_invarg2), \"writefile()\");\n\treturn;\n    }\n\n    if (argvars[2].v_type != VAR_UNKNOWN)\n    {\n\tchar_u *arg2 = tv_get_string_chk(&argvars[2]);\n\n\tif (arg2 == NULL)\n\t    return;\n\tif (vim_strchr(arg2, 'b') != NULL)\n\t    binary = TRUE;\n\tif (vim_strchr(arg2, 'a') != NULL)\n\t    append = TRUE;\n#ifdef HAVE_FSYNC\n\tif (vim_strchr(arg2, 's') != NULL)\n\t    do_fsync = TRUE;\n\telse if (vim_strchr(arg2, 'S') != NULL)\n\t    do_fsync = FALSE;\n#endif\n    }\n\n    fname = tv_get_string_chk(&argvars[1]);\n    if (fname == NULL)\n\treturn;\n\n    /* Always open the file in binary mode, library functions have a mind of\n     * their own about CR-LF conversion. */\n    if (*fname == NUL || (fd = mch_fopen((char *)fname,\n\t\t\t\t      append ? APPENDBIN : WRITEBIN)) == NULL)\n    {\n\tsemsg(_(e_notcreate), *fname == NUL ? (char_u *)_(\"<empty>\") : fname);\n\tret = -1;\n    }\n    else if (blob)\n    {\n\tif (write_blob(fd, blob) == FAIL)\n\t    ret = -1;\n#ifdef HAVE_FSYNC\n\telse if (do_fsync)\n\t    // Ignore the error, the user wouldn't know what to do about it.\n\t    // May happen for a device.\n\t    vim_ignored = fsync(fileno(fd));\n#endif\n\tfclose(fd);\n    }\n    else\n    {\n\tif (write_list(fd, list, binary) == FAIL)\n\t    ret = -1;\n#ifdef HAVE_FSYNC\n\telse if (do_fsync)\n\t    /* Ignore the error, the user wouldn't know what to do about it.\n\t     * May happen for a device. */\n\t    vim_ignored = fsync(fileno(fd));\n#endif\n\tfclose(fd);\n    }\n\n    rettv->vval.v_number = ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -14,7 +14,7 @@\n     blob_T\t*blob = NULL;\n \n     rettv->vval.v_number = -1;\n-    if (check_restricted() || check_secure())\n+    if (check_secure())\n \treturn;\n \n     if (argvars[0].v_type == VAR_LIST)",
        "diff_line_info": {
            "deleted_lines": [
                "    if (check_restricted() || check_secure())"
            ],
            "added_lines": [
                "    if (check_secure())"
            ]
        }
    }
]