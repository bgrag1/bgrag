[
    {
        "cve_id": "CVE-2019-12209",
        "func_name": "Yubico/pam-u2f/pam_sm_authenticate",
        "description": "Yubico pam-u2f 1.0.7 attempts parsing of the configured authfile (default $HOME/.config/Yubico/u2f_keys) as root (unless openasuser was enabled), and does not properly verify that the path lacks symlinks pointing to other files on the system owned by root. If the debug option is enabled in the PAM configuration, part of the file contents of a symlink target will be logged, possibly revealing sensitive information.",
        "git_url": "https://github.com/Yubico/pam-u2f/commit/7db3386fcdb454e33a3ea30dcfb8e8960d4c3aa3",
        "commit_title": "Drop privileges by default when opening user-related files",
        "commit_text": " The module is typically executed as root and would sometimes open files or follow symlinks that could be controlled from the outside.  Drop privileges to the target user before opening any files.  Fixes CVE-2019-12209.  Thanks to Matthias Gerstner of the SUSE Security Team for reporting the issue.",
        "func_before": "int pam_sm_authenticate(pam_handle_t *pamh, int flags, int argc,\n                        const char **argv) {\n\n  struct passwd *pw = NULL, pw_s;\n  const char *user = NULL;\n\n  cfg_t cfg_st;\n  cfg_t *cfg = &cfg_st;\n  char buffer[BUFSIZE];\n  char *buf = NULL;\n  char *authfile_dir;\n  size_t authfile_dir_len;\n  int pgu_ret, gpn_ret;\n  int retval = PAM_IGNORE;\n  device_t *devices = NULL;\n  unsigned n_devices = 0;\n  int openasuser;\n  int should_free_origin = 0;\n  int should_free_appid = 0;\n  int should_free_auth_file = 0;\n  int should_free_authpending_file = 0;\n\n  parse_cfg(flags, argc, argv, cfg);\n\n  if (!cfg->origin) {\n    strcpy(buffer, DEFAULT_ORIGIN_PREFIX);\n\n    if (gethostname(buffer + strlen(DEFAULT_ORIGIN_PREFIX),\n                    BUFSIZE - strlen(DEFAULT_ORIGIN_PREFIX)) == -1) {\n      DBG(\"Unable to get host name\");\n      goto done;\n    }\n    DBG(\"Origin not specified, using \\\"%s\\\"\", buffer);\n    cfg->origin = strdup(buffer);\n    if (!cfg->origin) {\n      DBG(\"Unable to allocate memory\");\n      goto done;\n    } else {\n      should_free_origin = 1;\n    }\n  }\n\n  if (!cfg->appid) {\n    DBG(\"Appid not specified, using the same value of origin (%s)\",\n         cfg->origin);\n    cfg->appid = strdup(cfg->origin);\n    if (!cfg->appid) {\n      DBG(\"Unable to allocate memory\")\n      goto done;\n    } else {\n      should_free_appid = 1;\n    }\n  }\n\n  if (cfg->max_devs == 0) {\n    DBG(\"Maximum devices number not set. Using default (%d)\", MAX_DEVS);\n    cfg->max_devs = MAX_DEVS;\n  }\n\n  devices = malloc(sizeof(device_t) * cfg->max_devs);\n  if (!devices) {\n    DBG(\"Unable to allocate memory\");\n    retval = PAM_IGNORE;\n    goto done;\n  }\n\n  pgu_ret = pam_get_user(pamh, &user, NULL);\n  if (pgu_ret != PAM_SUCCESS || user == NULL) {\n    DBG(\"Unable to access user %s\", user);\n    retval = PAM_CONV_ERR;\n    goto done;\n  }\n\n  DBG(\"Requesting authentication for user %s\", user);\n\n  gpn_ret = getpwnam_r(user, &pw_s, buffer, sizeof(buffer), &pw);\n  if (gpn_ret != 0 || pw == NULL || pw->pw_dir == NULL ||\n      pw->pw_dir[0] != '/') {\n    DBG(\"Unable to retrieve credentials for user %s, (%s)\", user,\n         strerror(errno));\n    retval = PAM_USER_UNKNOWN;\n    goto done;\n  }\n\n  DBG(\"Found user %s\", user);\n  DBG(\"Home directory for %s is %s\", user, pw->pw_dir);\n\n  if (!cfg->auth_file) {\n    buf = NULL;\n    authfile_dir = secure_getenv(DEFAULT_AUTHFILE_DIR_VAR);\n    if (!authfile_dir) {\n      DBG(\"Variable %s is not set. Using default value ($HOME/.config/)\",\n           DEFAULT_AUTHFILE_DIR_VAR);\n      authfile_dir_len =\n        strlen(pw->pw_dir) + strlen(\"/.config\") + strlen(DEFAULT_AUTHFILE) + 1;\n      buf = malloc(sizeof(char) * (authfile_dir_len));\n\n      if (!buf) {\n        DBG(\"Unable to allocate memory\");\n        retval = PAM_IGNORE;\n        goto done;\n      }\n\n      snprintf(buf, authfile_dir_len,\n               \"%s/.config%s\", pw->pw_dir, DEFAULT_AUTHFILE);\n    } else {\n      DBG(\"Variable %s set to %s\", DEFAULT_AUTHFILE_DIR_VAR, authfile_dir);\n      authfile_dir_len = strlen(authfile_dir) + strlen(DEFAULT_AUTHFILE) + 1;\n      buf = malloc(sizeof(char) * (authfile_dir_len));\n\n      if (!buf) {\n        DBG(\"Unable to allocate memory\");\n        retval = PAM_IGNORE;\n        goto done;\n      }\n\n      snprintf(buf, authfile_dir_len,\n               \"%s%s\", authfile_dir, DEFAULT_AUTHFILE);\n    }\n\n    DBG(\"Using default authentication file %s\", buf);\n\n    cfg->auth_file = buf; /* cfg takes ownership */\n    should_free_auth_file = 1;\n    buf = NULL;\n  } else {\n    DBG(\"Using authentication file %s\", cfg->auth_file);\n  }\n\n  openasuser = geteuid() == 0 && cfg->openasuser;\n  if (openasuser) {\n    if (seteuid(pw_s.pw_uid)) {\n      DBG(\"Unable to switch user to uid %i\", pw_s.pw_uid);\n      retval = PAM_IGNORE;\n      goto done;\n    }\n    DBG(\"Switched to uid %i\", pw_s.pw_uid);\n  }\n  retval = get_devices_from_authfile(cfg->auth_file, user, cfg->max_devs,\n                                     cfg->debug, cfg->debug_file,\n                                     devices, &n_devices);\n  if (openasuser) {\n    if (seteuid(0)) {\n      DBG(\"Unable to switch back to uid 0\");\n      retval = PAM_IGNORE;\n      goto done;\n    }\n    DBG(\"Switched back to uid 0\");\n  }\n\n  if (retval != 1) {\n    // for nouserok; make sure errors in get_devices_from_authfile don't\n    // result in valid devices\n    n_devices = 0;\n  }\n\n  if (n_devices == 0) {\n    if (cfg->nouserok) {\n      DBG(\"Found no devices but nouserok specified. Skipping authentication\");\n      retval = PAM_SUCCESS;\n      goto done;\n    } else if (retval != 1) {\n      DBG(\"Unable to get devices from file %s\", cfg->auth_file);\n      retval = PAM_AUTHINFO_UNAVAIL;\n      goto done;\n    } else {\n      DBG(\"Found no devices. Aborting.\");\n      retval = PAM_AUTHINFO_UNAVAIL;\n      goto done;\n    }\n  }\n\n  // Determine the full path for authpending_file in order to emit touch request notifications\n  if (!cfg->authpending_file) {\n    int actual_size = snprintf(buffer, BUFSIZE, DEFAULT_AUTHPENDING_FILE_PATH, getuid());\n    if (actual_size >= 0 && actual_size < BUFSIZE) {\n      cfg->authpending_file = strdup(buffer);\n    }\n    if (!cfg->authpending_file) {\n      DBG(\"Unable to allocate memory for the authpending_file, touch request notifications will not be emitted\");\n    } else {\n      should_free_authpending_file = 1;\n    }\n  } else {\n    if (strlen(cfg->authpending_file) == 0) {\n      DBG(\"authpending_file is set to an empty value, touch request notifications will be disabled\");\n      cfg->authpending_file = NULL;\n    }\n  }\n\n  int authpending_file_descriptor = -1;\n  if (cfg->authpending_file) {\n    DBG(\"Using file '%s' for emitting touch request notifications\", cfg->authpending_file);\n\n    // Open (or create) the authpending_file to indicate that we start waiting for a touch\n    authpending_file_descriptor =\n      open(cfg->authpending_file, O_RDONLY | O_CREAT | O_CLOEXEC | O_NOFOLLOW | O_NOCTTY, 0664);\n    if (authpending_file_descriptor < 0) {\n      DBG(\"Unable to emit 'authentication started' notification by opening the file '%s', (%s)\",\n          cfg->authpending_file, strerror(errno));\n    }\n  }\n\n  if (cfg->manual == 0) {\n    if (cfg->interactive) {\n      converse(pamh, PAM_PROMPT_ECHO_ON,\n               cfg->prompt != NULL ? cfg->prompt : DEFAULT_PROMPT);\n    }\n\n    retval = do_authentication(cfg, devices, n_devices, pamh);\n  } else {\n    retval = do_manual_authentication(cfg, devices, n_devices, pamh);\n  }\n\n  // Close the authpending_file to indicate that we stop waiting for a touch\n  if (authpending_file_descriptor >= 0) {\n    if (close(authpending_file_descriptor) < 0) {\n      DBG(\"Unable to emit 'authentication stopped' notification by closing the file '%s', (%s)\",\n          cfg->authpending_file, strerror(errno));\n    }\n  }\n\n  if (retval != 1) {\n    DBG(\"do_authentication returned %d\", retval);\n    retval = PAM_AUTH_ERR;\n    goto done;\n  }\n\n  retval = PAM_SUCCESS;\n\ndone:\n  free_devices(devices, n_devices);\n\n  if (buf) {\n    free(buf);\n    buf = NULL;\n  }\n\n  if (should_free_origin) {\n    free((char *) cfg->origin);\n    cfg->origin = NULL;\n  }\n\n  if (should_free_appid) {\n    free((char *) cfg->appid);\n    cfg->appid = NULL;\n  }\n\n  if (should_free_auth_file) {\n    free((char *) cfg->auth_file);\n    cfg->auth_file = NULL;\n  }\n\n  if (should_free_authpending_file) {\n    free((char *) cfg->authpending_file);\n    cfg->authpending_file = NULL;\n  }\n\n  if (cfg->alwaysok && retval != PAM_SUCCESS) {\n    DBG(\"alwaysok needed (otherwise return with %d)\", retval);\n    retval = PAM_SUCCESS;\n  }\n  DBG(\"done. [%s]\", pam_strerror(pamh, retval));\n\n  if (cfg->is_custom_debug_file) {\n    fclose(cfg->debug_file);\n  }\n\n  return retval;\n}",
        "func": "int pam_sm_authenticate(pam_handle_t *pamh, int flags, int argc,\n                        const char **argv) {\n\n  struct passwd *pw = NULL, pw_s;\n  const char *user = NULL;\n\n  cfg_t cfg_st;\n  cfg_t *cfg = &cfg_st;\n  char buffer[BUFSIZE];\n  char *buf = NULL;\n  char *authfile_dir;\n  size_t authfile_dir_len;\n  int pgu_ret, gpn_ret;\n  int retval = PAM_IGNORE;\n  device_t *devices = NULL;\n  unsigned n_devices = 0;\n  int openasuser = 0;\n  int should_free_origin = 0;\n  int should_free_appid = 0;\n  int should_free_auth_file = 0;\n  int should_free_authpending_file = 0;\n  PAM_MODUTIL_DEF_PRIVS(privs);\n\n  parse_cfg(flags, argc, argv, cfg);\n\n  if (!cfg->origin) {\n    strcpy(buffer, DEFAULT_ORIGIN_PREFIX);\n\n    if (gethostname(buffer + strlen(DEFAULT_ORIGIN_PREFIX),\n                    BUFSIZE - strlen(DEFAULT_ORIGIN_PREFIX)) == -1) {\n      DBG(\"Unable to get host name\");\n      goto done;\n    }\n    DBG(\"Origin not specified, using \\\"%s\\\"\", buffer);\n    cfg->origin = strdup(buffer);\n    if (!cfg->origin) {\n      DBG(\"Unable to allocate memory\");\n      goto done;\n    } else {\n      should_free_origin = 1;\n    }\n  }\n\n  if (!cfg->appid) {\n    DBG(\"Appid not specified, using the same value of origin (%s)\",\n         cfg->origin);\n    cfg->appid = strdup(cfg->origin);\n    if (!cfg->appid) {\n      DBG(\"Unable to allocate memory\")\n      goto done;\n    } else {\n      should_free_appid = 1;\n    }\n  }\n\n  if (cfg->max_devs == 0) {\n    DBG(\"Maximum devices number not set. Using default (%d)\", MAX_DEVS);\n    cfg->max_devs = MAX_DEVS;\n  }\n\n  devices = malloc(sizeof(device_t) * cfg->max_devs);\n  if (!devices) {\n    DBG(\"Unable to allocate memory\");\n    retval = PAM_IGNORE;\n    goto done;\n  }\n\n  pgu_ret = pam_get_user(pamh, &user, NULL);\n  if (pgu_ret != PAM_SUCCESS || user == NULL) {\n    DBG(\"Unable to access user %s\", user);\n    retval = PAM_CONV_ERR;\n    goto done;\n  }\n\n  DBG(\"Requesting authentication for user %s\", user);\n\n  gpn_ret = getpwnam_r(user, &pw_s, buffer, sizeof(buffer), &pw);\n  if (gpn_ret != 0 || pw == NULL || pw->pw_dir == NULL ||\n      pw->pw_dir[0] != '/') {\n    DBG(\"Unable to retrieve credentials for user %s, (%s)\", user,\n         strerror(errno));\n    retval = PAM_USER_UNKNOWN;\n    goto done;\n  }\n\n  DBG(\"Found user %s\", user);\n  DBG(\"Home directory for %s is %s\", user, pw->pw_dir);\n\n  if (!cfg->auth_file) {\n    buf = NULL;\n    authfile_dir = secure_getenv(DEFAULT_AUTHFILE_DIR_VAR);\n    if (!authfile_dir) {\n      DBG(\"Variable %s is not set. Using default value ($HOME/.config/)\",\n           DEFAULT_AUTHFILE_DIR_VAR);\n      authfile_dir_len =\n        strlen(pw->pw_dir) + strlen(\"/.config\") + strlen(DEFAULT_AUTHFILE) + 1;\n      buf = malloc(sizeof(char) * (authfile_dir_len));\n\n      if (!buf) {\n        DBG(\"Unable to allocate memory\");\n        retval = PAM_IGNORE;\n        goto done;\n      }\n\n      /* Opening a file in a users $HOME, need to drop privs for security */\n      openasuser = geteuid() == 0 ? 1 : 0;\n\n      snprintf(buf, authfile_dir_len,\n               \"%s/.config%s\", pw->pw_dir, DEFAULT_AUTHFILE);\n    } else {\n      DBG(\"Variable %s set to %s\", DEFAULT_AUTHFILE_DIR_VAR, authfile_dir);\n      authfile_dir_len = strlen(authfile_dir) + strlen(DEFAULT_AUTHFILE) + 1;\n      buf = malloc(sizeof(char) * (authfile_dir_len));\n\n      if (!buf) {\n        DBG(\"Unable to allocate memory\");\n        retval = PAM_IGNORE;\n        goto done;\n      }\n\n      snprintf(buf, authfile_dir_len,\n               \"%s%s\", authfile_dir, DEFAULT_AUTHFILE);\n\n      if (!openasuser) {\n\tDBG(\"WARNING: not dropping privileges when reading %s, please \"\n\t    \"consider setting openasuser=1 in the module configuration\", buf);\n      }\n    }\n\n    DBG(\"Using authentication file %s\", buf);\n\n    cfg->auth_file = buf; /* cfg takes ownership */\n    should_free_auth_file = 1;\n    buf = NULL;\n  } else {\n    DBG(\"Using authentication file %s\", cfg->auth_file);\n  }\n\n  if (!openasuser) {\n    openasuser = geteuid() == 0 && cfg->openasuser;\n  }\n  if (openasuser) {\n    DBG(\"Dropping privileges\");\n    if (pam_modutil_drop_priv(pamh, &privs, pw)) {\n      DBG(\"Unable to switch user to uid %i\", pw->pw_uid);\n      retval = PAM_IGNORE;\n      goto done;\n    }\n    DBG(\"Switched to uid %i\", pw->pw_uid);\n  }\n  retval = get_devices_from_authfile(cfg->auth_file, user, cfg->max_devs,\n                                     cfg->debug, cfg->debug_file,\n                                     devices, &n_devices);\n  if (openasuser) {\n    if (pam_modutil_regain_priv(pamh, &privs)) {\n      DBG(\"could not restore privileges\");\n      retval = PAM_IGNORE;\n      goto done;\n    }\n    DBG(\"Restored privileges\");\n  }\n\n  if (retval != 1) {\n    // for nouserok; make sure errors in get_devices_from_authfile don't\n    // result in valid devices\n    n_devices = 0;\n  }\n\n  if (n_devices == 0) {\n    if (cfg->nouserok) {\n      DBG(\"Found no devices but nouserok specified. Skipping authentication\");\n      retval = PAM_SUCCESS;\n      goto done;\n    } else if (retval != 1) {\n      DBG(\"Unable to get devices from file %s\", cfg->auth_file);\n      retval = PAM_AUTHINFO_UNAVAIL;\n      goto done;\n    } else {\n      DBG(\"Found no devices. Aborting.\");\n      retval = PAM_AUTHINFO_UNAVAIL;\n      goto done;\n    }\n  }\n\n  // Determine the full path for authpending_file in order to emit touch request notifications\n  if (!cfg->authpending_file) {\n    int actual_size = snprintf(buffer, BUFSIZE, DEFAULT_AUTHPENDING_FILE_PATH, getuid());\n    if (actual_size >= 0 && actual_size < BUFSIZE) {\n      cfg->authpending_file = strdup(buffer);\n    }\n    if (!cfg->authpending_file) {\n      DBG(\"Unable to allocate memory for the authpending_file, touch request notifications will not be emitted\");\n    } else {\n      should_free_authpending_file = 1;\n    }\n  } else {\n    if (strlen(cfg->authpending_file) == 0) {\n      DBG(\"authpending_file is set to an empty value, touch request notifications will be disabled\");\n      cfg->authpending_file = NULL;\n    }\n  }\n\n  int authpending_file_descriptor = -1;\n  if (cfg->authpending_file) {\n    DBG(\"Using file '%s' for emitting touch request notifications\", cfg->authpending_file);\n\n    // Open (or create) the authpending_file to indicate that we start waiting for a touch\n    authpending_file_descriptor =\n      open(cfg->authpending_file, O_RDONLY | O_CREAT | O_CLOEXEC | O_NOFOLLOW | O_NOCTTY, 0664);\n    if (authpending_file_descriptor < 0) {\n      DBG(\"Unable to emit 'authentication started' notification by opening the file '%s', (%s)\",\n          cfg->authpending_file, strerror(errno));\n    }\n  }\n\n  if (cfg->manual == 0) {\n    if (cfg->interactive) {\n      converse(pamh, PAM_PROMPT_ECHO_ON,\n               cfg->prompt != NULL ? cfg->prompt : DEFAULT_PROMPT);\n    }\n\n    retval = do_authentication(cfg, devices, n_devices, pamh);\n  } else {\n    retval = do_manual_authentication(cfg, devices, n_devices, pamh);\n  }\n\n  // Close the authpending_file to indicate that we stop waiting for a touch\n  if (authpending_file_descriptor >= 0) {\n    if (close(authpending_file_descriptor) < 0) {\n      DBG(\"Unable to emit 'authentication stopped' notification by closing the file '%s', (%s)\",\n          cfg->authpending_file, strerror(errno));\n    }\n  }\n\n  if (retval != 1) {\n    DBG(\"do_authentication returned %d\", retval);\n    retval = PAM_AUTH_ERR;\n    goto done;\n  }\n\n  retval = PAM_SUCCESS;\n\ndone:\n  free_devices(devices, n_devices);\n\n  if (buf) {\n    free(buf);\n    buf = NULL;\n  }\n\n  if (should_free_origin) {\n    free((char *) cfg->origin);\n    cfg->origin = NULL;\n  }\n\n  if (should_free_appid) {\n    free((char *) cfg->appid);\n    cfg->appid = NULL;\n  }\n\n  if (should_free_auth_file) {\n    free((char *) cfg->auth_file);\n    cfg->auth_file = NULL;\n  }\n\n  if (should_free_authpending_file) {\n    free((char *) cfg->authpending_file);\n    cfg->authpending_file = NULL;\n  }\n\n  if (cfg->alwaysok && retval != PAM_SUCCESS) {\n    DBG(\"alwaysok needed (otherwise return with %d)\", retval);\n    retval = PAM_SUCCESS;\n  }\n  DBG(\"done. [%s]\", pam_strerror(pamh, retval));\n\n  if (cfg->is_custom_debug_file) {\n    fclose(cfg->debug_file);\n  }\n\n  return retval;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -14,11 +14,12 @@\n   int retval = PAM_IGNORE;\n   device_t *devices = NULL;\n   unsigned n_devices = 0;\n-  int openasuser;\n+  int openasuser = 0;\n   int should_free_origin = 0;\n   int should_free_appid = 0;\n   int should_free_auth_file = 0;\n   int should_free_authpending_file = 0;\n+  PAM_MODUTIL_DEF_PRIVS(privs);\n \n   parse_cfg(flags, argc, argv, cfg);\n \n@@ -101,6 +102,9 @@\n         goto done;\n       }\n \n+      /* Opening a file in a users $HOME, need to drop privs for security */\n+      openasuser = geteuid() == 0 ? 1 : 0;\n+\n       snprintf(buf, authfile_dir_len,\n                \"%s/.config%s\", pw->pw_dir, DEFAULT_AUTHFILE);\n     } else {\n@@ -116,9 +120,14 @@\n \n       snprintf(buf, authfile_dir_len,\n                \"%s%s\", authfile_dir, DEFAULT_AUTHFILE);\n-    }\n-\n-    DBG(\"Using default authentication file %s\", buf);\n+\n+      if (!openasuser) {\n+\tDBG(\"WARNING: not dropping privileges when reading %s, please \"\n+\t    \"consider setting openasuser=1 in the module configuration\", buf);\n+      }\n+    }\n+\n+    DBG(\"Using authentication file %s\", buf);\n \n     cfg->auth_file = buf; /* cfg takes ownership */\n     should_free_auth_file = 1;\n@@ -127,25 +136,28 @@\n     DBG(\"Using authentication file %s\", cfg->auth_file);\n   }\n \n-  openasuser = geteuid() == 0 && cfg->openasuser;\n+  if (!openasuser) {\n+    openasuser = geteuid() == 0 && cfg->openasuser;\n+  }\n   if (openasuser) {\n-    if (seteuid(pw_s.pw_uid)) {\n-      DBG(\"Unable to switch user to uid %i\", pw_s.pw_uid);\n+    DBG(\"Dropping privileges\");\n+    if (pam_modutil_drop_priv(pamh, &privs, pw)) {\n+      DBG(\"Unable to switch user to uid %i\", pw->pw_uid);\n       retval = PAM_IGNORE;\n       goto done;\n     }\n-    DBG(\"Switched to uid %i\", pw_s.pw_uid);\n+    DBG(\"Switched to uid %i\", pw->pw_uid);\n   }\n   retval = get_devices_from_authfile(cfg->auth_file, user, cfg->max_devs,\n                                      cfg->debug, cfg->debug_file,\n                                      devices, &n_devices);\n   if (openasuser) {\n-    if (seteuid(0)) {\n-      DBG(\"Unable to switch back to uid 0\");\n+    if (pam_modutil_regain_priv(pamh, &privs)) {\n+      DBG(\"could not restore privileges\");\n       retval = PAM_IGNORE;\n       goto done;\n     }\n-    DBG(\"Switched back to uid 0\");\n+    DBG(\"Restored privileges\");\n   }\n \n   if (retval != 1) {",
        "diff_line_info": {
            "deleted_lines": [
                "  int openasuser;",
                "    }",
                "",
                "    DBG(\"Using default authentication file %s\", buf);",
                "  openasuser = geteuid() == 0 && cfg->openasuser;",
                "    if (seteuid(pw_s.pw_uid)) {",
                "      DBG(\"Unable to switch user to uid %i\", pw_s.pw_uid);",
                "    DBG(\"Switched to uid %i\", pw_s.pw_uid);",
                "    if (seteuid(0)) {",
                "      DBG(\"Unable to switch back to uid 0\");",
                "    DBG(\"Switched back to uid 0\");"
            ],
            "added_lines": [
                "  int openasuser = 0;",
                "  PAM_MODUTIL_DEF_PRIVS(privs);",
                "      /* Opening a file in a users $HOME, need to drop privs for security */",
                "      openasuser = geteuid() == 0 ? 1 : 0;",
                "",
                "",
                "      if (!openasuser) {",
                "\tDBG(\"WARNING: not dropping privileges when reading %s, please \"",
                "\t    \"consider setting openasuser=1 in the module configuration\", buf);",
                "      }",
                "    }",
                "",
                "    DBG(\"Using authentication file %s\", buf);",
                "  if (!openasuser) {",
                "    openasuser = geteuid() == 0 && cfg->openasuser;",
                "  }",
                "    DBG(\"Dropping privileges\");",
                "    if (pam_modutil_drop_priv(pamh, &privs, pw)) {",
                "      DBG(\"Unable to switch user to uid %i\", pw->pw_uid);",
                "    DBG(\"Switched to uid %i\", pw->pw_uid);",
                "    if (pam_modutil_regain_priv(pamh, &privs)) {",
                "      DBG(\"could not restore privileges\");",
                "    DBG(\"Restored privileges\");"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-13226",
        "func_name": "linuxdeepin/deepin-clone/main",
        "description": "deepin-clone before 1.1.3 uses a predictable path /tmp/.deepin-clone/mount/<block-dev-basename> in the Helper::temporaryMountDevice() function to temporarily mount a file system as root. An unprivileged user can prepare a symlink at this location to have the file system mounted in an arbitrary location. By winning a race condition, the attacker can also enter the mount point, thereby preventing a subsequent unmount of the file system.",
        "git_url": "https://github.com/linuxdeepin/deepin-clone/commit/e079f3e2712b4f8c28e3e63e71ba1a1f90fce1ab",
        "commit_title": "fix: Do not use the \"/tmp\" directory",
        "commit_text": " https://github.com/linuxdeepin/deepin-clone/issues/16 https://bugzilla.opensuse.org/show_bug.cgi?id=1130388",
        "func_before": "int main(int argc, char *argv[])\n{\n    QCoreApplication *a;\n\n    if (isTUIMode(argc, argv)) {\n        Global::isTUIMode = true;\n\n        a = new QCoreApplication(argc, argv);\n    }\n#ifdef ENABLE_GUI\n    else {\n        ConsoleAppender *consoleAppender = new ConsoleAppender;\n        consoleAppender->setFormat(logFormat);\n\n        RollingFileAppender *rollingFileAppender = new RollingFileAppender(\"/tmp/.deepin-clone.log\");\n        rollingFileAppender->setFormat(logFormat);\n        rollingFileAppender->setLogFilesLimit(5);\n        rollingFileAppender->setDatePattern(RollingFileAppender::DailyRollover);\n\n        logger->registerAppender(consoleAppender);\n        logger->registerAppender(rollingFileAppender);\n\n        if (qEnvironmentVariableIsSet(\"PKEXEC_UID\")) {\n            const quint32 pkexec_uid = qgetenv(\"PKEXEC_UID\").toUInt();\n            const QDir user_home(getpwuid(pkexec_uid)->pw_dir);\n\n            QFile pam_file(user_home.absoluteFilePath(\".pam_environment\"));\n\n            if (pam_file.open(QIODevice::ReadOnly)) {\n                while (!pam_file.atEnd()) {\n                    const QByteArray &line = pam_file.readLine().simplified();\n\n                    if (line.startsWith(\"QT_SCALE_FACTOR\")) {\n                        const QByteArrayList &list = line.split('=');\n\n                        if (list.count() == 2) {\n                            qputenv(\"QT_SCALE_FACTOR\", list.last());\n                            break;\n                        }\n                    }\n                }\n\n                pam_file.close();\n            }\n        }\n\n        DApplication::loadDXcbPlugin();\n        DApplication *app = new DApplication(argc, argv);\n\n        app->setAttribute(Qt::AA_UseHighDpiPixmaps);\n\n        if (!qApp->setSingleInstance(\"_deepin_clone_\")) {\n            qCritical() << \"As well as the process is running\";\n\n            return -1;\n        }\n\n        if (!app->loadTranslator()) {\n            dError(\"Load translator failed\");\n        }\n\n        app->setApplicationDisplayName(QObject::tr(\"Deepin Clone\"));\n        app->setApplicationDescription(QObject::tr(\"Deepin Clone is a backup and restore tool in deepin. \"\n                                                   \"It supports disk or partition clone, backup and restore, and other functions.\"));\n        app->setApplicationAcknowledgementPage(\"https://www.deepin.org/acknowledgments/deepin-clone/\");\n        app->setTheme(\"light\");\n        a = app;\n    }\n#endif\n\n    a->setApplicationName(\"deepin-clone\");\n#ifdef ENABLE_GUI\n    a->setApplicationVersion(DApplication::buildVersion(\"1.0.0.1\"));\n#else\n    a->setApplicationVersion(\"1.0.0.1\");\n#endif\n    a->setOrganizationName(\"deepin\");\n\n    CommandLineParser parser;\n\n    QFile arguments_file(\"/lib/live/mount/medium/.tmp/deepin-clone.arguments\");\n    QStringList arguments;\n\n    bool load_arg_from_file = arguments_file.exists() && !Global::isTUIMode && !a->arguments().contains(\"--tui\");\n\n    if (load_arg_from_file) {\n        arguments.append(a->arguments().first());\n\n        if (!arguments_file.open(QIODevice::ReadOnly)) {\n            qCritical() << \"Open \\\"/lib/live/mount/medium/.tmp/deepin-clone.arguments\\\" failed, error:\" << arguments_file.errorString();\n        } else {\n            while (!arguments_file.atEnd()) {\n                const QString &arg = QString::fromUtf8(arguments_file.readLine().trimmed());\n\n                if (!arg.isEmpty())\n                    arguments.append(arg);\n            }\n\n            arguments_file.close();\n            arguments_file.remove();\n        }\n\n        qDebug() << arguments;\n    } else {\n        arguments = a->arguments();\n    }\n\n    parser.process(arguments);\n\n    ConsoleAppender *consoleAppender = new ConsoleAppender;\n    consoleAppender->setFormat(logFormat);\n\n    RollingFileAppender *rollingFileAppender = new RollingFileAppender(parser.logFile());\n    rollingFileAppender->setFormat(logFormat);\n    rollingFileAppender->setLogFilesLimit(5);\n    rollingFileAppender->setDatePattern(RollingFileAppender::DailyRollover);\n\n    logger->registerCategoryAppender(\"deepin.ghost\", consoleAppender);\n    logger->registerCategoryAppender(\"deepin.ghost\", rollingFileAppender);\n\n    parser.parse();\n\n    if (load_arg_from_file) {\n        dCDebug(\"Load arguments from \\\"%s\\\"\", qPrintable(arguments_file.fileName()));\n    }\n\n    dCInfo(\"Application command line: %s\", qPrintable(arguments.join(' ')));\n\n    if (Global::debugLevel == 0) {\n        QLoggingCategory::setFilterRules(\"deepin.ghost.debug=false\");\n    }\n\n    if (Global::isTUIMode) {\n        if (!parser.target().isEmpty()) {\n            CloneJob *job = new CloneJob;\n\n            QObject::connect(job, &QThread::finished, a, &QCoreApplication::quit);\n\n            job->start(parser.source(), parser.target());\n        }\n    }\n#ifdef ENABLE_GUI\n    else {\n        if (!parser.isSetOverride())\n            Global::isOverride = true;\n\n        if (!parser.isSetDebug())\n            Global::debugLevel = 2;\n\n        MainWindow *window = new MainWindow;\n\n        window->setFixedSize(860, 660);\n        window->setStyleSheet(DThemeManager::instance()->getQssForWidget(\"main\", window));\n        window->setWindowIcon(QIcon::fromTheme(\"deepin-clone\"));\n        window->setWindowFlags(Qt::WindowCloseButtonHint | Qt::WindowMinimizeButtonHint | Qt::WindowSystemMenuHint);\n        window->titlebar()->setIcon(window->windowIcon());\n        window->titlebar()->setTitle(QString());\n#if DTK_VERSION > DTK_VERSION_CHECK(2, 0, 6, 0)\n        window->titlebar()->setBackgroundTransparent(true);\n#endif\n        window->show();\n\n        qApp->setProductIcon(window->windowIcon());\n\n        if (!parser.source().isEmpty()) {\n            window->startWithFile(parser.source(), parser.target());\n        }\n\n        QObject::connect(a, &QCoreApplication::aboutToQuit, window, &MainWindow::deleteLater);\n        QDesktopServices::setUrlHandler(\"https\", window, \"openUrl\");\n    }\n#endif\n\n    int exitCode = Global::isTUIMode ? a->exec() : qApp->exec();\n    QString log_backup_file = parser.logBackupFile();\n\n    if (log_backup_file.startsWith(\"serial://\")) {\n        log_backup_file = Helper::parseSerialUrl(log_backup_file);\n    }\n\n    if (log_backup_file.isEmpty()) {\n        return exitCode;\n    }\n\n    if (!QFile::copy(parser.logFile(), log_backup_file)) {\n        dCWarning(\"failed to copy log file to \\\"%s\\\"\", qPrintable(log_backup_file));\n    }\n\n    return exitCode;\n}",
        "func": "int main(int argc, char *argv[])\n{\n    QCoreApplication *a;\n\n    if (isTUIMode(argc, argv)) {\n        Global::isTUIMode = true;\n\n        a = new QCoreApplication(argc, argv);\n    }\n#ifdef ENABLE_GUI\n    else {\n        ConsoleAppender *consoleAppender = new ConsoleAppender;\n        consoleAppender->setFormat(logFormat);\n\n        const QString log_file(\"/var/log/deepin-clone.log\");\n\n        RollingFileAppender *rollingFileAppender = new RollingFileAppender(log_file);\n        rollingFileAppender->setFormat(logFormat);\n        rollingFileAppender->setLogFilesLimit(5);\n        rollingFileAppender->setDatePattern(RollingFileAppender::DailyRollover);\n\n        logger->registerAppender(rollingFileAppender);\n        logger->registerAppender(consoleAppender);\n\n        if (qEnvironmentVariableIsSet(\"PKEXEC_UID\")) {\n            const quint32 pkexec_uid = qgetenv(\"PKEXEC_UID\").toUInt();\n\n            DApplication::customQtThemeConfigPathByUserHome(getpwuid(pkexec_uid)->pw_dir);\n        }\n\n        DApplication::loadDXcbPlugin();\n        DApplication *app = new DApplication(argc, argv);\n\n        app->setAttribute(Qt::AA_UseHighDpiPixmaps);\n\n        if (!qApp->setSingleInstance(\"_deepin_clone_\")) {\n            qCritical() << \"As well as the process is running\";\n\n            return -1;\n        }\n\n        if (!app->loadTranslator()) {\n            dError(\"Load translator failed\");\n        }\n\n        app->setApplicationDisplayName(QObject::tr(\"Deepin Clone\"));\n        app->setApplicationDescription(QObject::tr(\"Deepin Clone is a backup and restore tool in deepin. \"\n                                                   \"It supports disk or partition clone, backup and restore, and other functions.\"));\n        app->setApplicationAcknowledgementPage(\"https://www.deepin.org/acknowledgments/deepin-clone/\");\n        app->setTheme(\"light\");\n        a = app;\n    }\n#endif\n\n    a->setApplicationName(\"deepin-clone\");\n#ifdef ENABLE_GUI\n    a->setApplicationVersion(DApplication::buildVersion(\"1.0.0.1\"));\n#else\n    a->setApplicationVersion(\"1.0.0.1\");\n#endif\n    a->setOrganizationName(\"deepin\");\n\n    CommandLineParser parser;\n\n    QFile arguments_file(\"/lib/live/mount/medium/.tmp/deepin-clone.arguments\");\n    QStringList arguments;\n\n    bool load_arg_from_file = arguments_file.exists() && !Global::isTUIMode && !a->arguments().contains(\"--tui\");\n\n    if (load_arg_from_file) {\n        arguments.append(a->arguments().first());\n\n        if (!arguments_file.open(QIODevice::ReadOnly)) {\n            qCritical() << \"Open \\\"/lib/live/mount/medium/.tmp/deepin-clone.arguments\\\" failed, error:\" << arguments_file.errorString();\n        } else {\n            while (!arguments_file.atEnd()) {\n                const QString &arg = QString::fromUtf8(arguments_file.readLine().trimmed());\n\n                if (!arg.isEmpty())\n                    arguments.append(arg);\n            }\n\n            arguments_file.close();\n            arguments_file.remove();\n        }\n\n        qDebug() << arguments;\n    } else {\n        arguments = a->arguments();\n    }\n\n    parser.process(arguments);\n\n    ConsoleAppender *consoleAppender = new ConsoleAppender;\n    consoleAppender->setFormat(logFormat);\n\n    RollingFileAppender *rollingFileAppender = new RollingFileAppender(parser.logFile());\n    rollingFileAppender->setFormat(logFormat);\n    rollingFileAppender->setLogFilesLimit(5);\n    rollingFileAppender->setDatePattern(RollingFileAppender::DailyRollover);\n\n    logger->registerCategoryAppender(\"deepin.ghost\", consoleAppender);\n    logger->registerCategoryAppender(\"deepin.ghost\", rollingFileAppender);\n\n    parser.parse();\n\n    if (load_arg_from_file) {\n        dCDebug(\"Load arguments from \\\"%s\\\"\", qPrintable(arguments_file.fileName()));\n    }\n\n    dCInfo(\"Application command line: %s\", qPrintable(arguments.join(' ')));\n\n    if (Global::debugLevel == 0) {\n        QLoggingCategory::setFilterRules(\"deepin.ghost.debug=false\");\n    }\n\n    if (Global::isTUIMode) {\n        if (!parser.target().isEmpty()) {\n            CloneJob *job = new CloneJob;\n\n            QObject::connect(job, &QThread::finished, a, &QCoreApplication::quit);\n\n            job->start(parser.source(), parser.target());\n        }\n    }\n#ifdef ENABLE_GUI\n    else {\n        if (!parser.isSetOverride())\n            Global::isOverride = true;\n\n        if (!parser.isSetDebug())\n            Global::debugLevel = 2;\n\n        MainWindow *window = new MainWindow;\n\n        window->setFixedSize(860, 660);\n        window->setStyleSheet(DThemeManager::instance()->getQssForWidget(\"main\", window));\n        window->setWindowIcon(QIcon::fromTheme(\"deepin-clone\"));\n        window->setWindowFlags(Qt::WindowCloseButtonHint | Qt::WindowMinimizeButtonHint | Qt::WindowSystemMenuHint);\n        window->titlebar()->setIcon(window->windowIcon());\n        window->titlebar()->setTitle(QString());\n#if DTK_VERSION > DTK_VERSION_CHECK(2, 0, 6, 0)\n        window->titlebar()->setBackgroundTransparent(true);\n#endif\n        window->show();\n\n        qApp->setProductIcon(window->windowIcon());\n\n        if (!parser.source().isEmpty()) {\n            window->startWithFile(parser.source(), parser.target());\n        }\n\n        QObject::connect(a, &QCoreApplication::aboutToQuit, window, &MainWindow::deleteLater);\n        QDesktopServices::setUrlHandler(\"https\", window, \"openUrl\");\n    }\n#endif\n\n    int exitCode = Global::isTUIMode ? a->exec() : qApp->exec();\n    QString log_backup_file = parser.logBackupFile();\n\n    if (log_backup_file.startsWith(\"serial://\")) {\n        log_backup_file = Helper::parseSerialUrl(log_backup_file);\n    }\n\n    if (log_backup_file.isEmpty()) {\n        return exitCode;\n    }\n\n    if (!QFile::copy(parser.logFile(), log_backup_file)) {\n        dCWarning(\"failed to copy log file to \\\"%s\\\"\", qPrintable(log_backup_file));\n    }\n\n    return exitCode;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -12,36 +12,20 @@\n         ConsoleAppender *consoleAppender = new ConsoleAppender;\n         consoleAppender->setFormat(logFormat);\n \n-        RollingFileAppender *rollingFileAppender = new RollingFileAppender(\"/tmp/.deepin-clone.log\");\n+        const QString log_file(\"/var/log/deepin-clone.log\");\n+\n+        RollingFileAppender *rollingFileAppender = new RollingFileAppender(log_file);\n         rollingFileAppender->setFormat(logFormat);\n         rollingFileAppender->setLogFilesLimit(5);\n         rollingFileAppender->setDatePattern(RollingFileAppender::DailyRollover);\n \n+        logger->registerAppender(rollingFileAppender);\n         logger->registerAppender(consoleAppender);\n-        logger->registerAppender(rollingFileAppender);\n \n         if (qEnvironmentVariableIsSet(\"PKEXEC_UID\")) {\n             const quint32 pkexec_uid = qgetenv(\"PKEXEC_UID\").toUInt();\n-            const QDir user_home(getpwuid(pkexec_uid)->pw_dir);\n \n-            QFile pam_file(user_home.absoluteFilePath(\".pam_environment\"));\n-\n-            if (pam_file.open(QIODevice::ReadOnly)) {\n-                while (!pam_file.atEnd()) {\n-                    const QByteArray &line = pam_file.readLine().simplified();\n-\n-                    if (line.startsWith(\"QT_SCALE_FACTOR\")) {\n-                        const QByteArrayList &list = line.split('=');\n-\n-                        if (list.count() == 2) {\n-                            qputenv(\"QT_SCALE_FACTOR\", list.last());\n-                            break;\n-                        }\n-                    }\n-                }\n-\n-                pam_file.close();\n-            }\n+            DApplication::customQtThemeConfigPathByUserHome(getpwuid(pkexec_uid)->pw_dir);\n         }\n \n         DApplication::loadDXcbPlugin();",
        "diff_line_info": {
            "deleted_lines": [
                "        RollingFileAppender *rollingFileAppender = new RollingFileAppender(\"/tmp/.deepin-clone.log\");",
                "        logger->registerAppender(rollingFileAppender);",
                "            const QDir user_home(getpwuid(pkexec_uid)->pw_dir);",
                "            QFile pam_file(user_home.absoluteFilePath(\".pam_environment\"));",
                "",
                "            if (pam_file.open(QIODevice::ReadOnly)) {",
                "                while (!pam_file.atEnd()) {",
                "                    const QByteArray &line = pam_file.readLine().simplified();",
                "",
                "                    if (line.startsWith(\"QT_SCALE_FACTOR\")) {",
                "                        const QByteArrayList &list = line.split('=');",
                "",
                "                        if (list.count() == 2) {",
                "                            qputenv(\"QT_SCALE_FACTOR\", list.last());",
                "                            break;",
                "                        }",
                "                    }",
                "                }",
                "",
                "                pam_file.close();",
                "            }"
            ],
            "added_lines": [
                "        const QString log_file(\"/var/log/deepin-clone.log\");",
                "",
                "        RollingFileAppender *rollingFileAppender = new RollingFileAppender(log_file);",
                "        logger->registerAppender(rollingFileAppender);",
                "            DApplication::customQtThemeConfigPathByUserHome(getpwuid(pkexec_uid)->pw_dir);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-13226",
        "func_name": "linuxdeepin/deepin-clone/DDeviceDiskInfoPrivate::openDataStream",
        "description": "deepin-clone before 1.1.3 uses a predictable path /tmp/.deepin-clone/mount/<block-dev-basename> in the Helper::temporaryMountDevice() function to temporarily mount a file system as root. An unprivileged user can prepare a symlink at this location to have the file system mounted in an arbitrary location. By winning a race condition, the attacker can also enter the mount point, thereby preventing a subsequent unmount of the file system.",
        "git_url": "https://github.com/linuxdeepin/deepin-clone/commit/e079f3e2712b4f8c28e3e63e71ba1a1f90fce1ab",
        "commit_title": "fix: Do not use the \"/tmp\" directory",
        "commit_text": " https://github.com/linuxdeepin/deepin-clone/issues/16 https://bugzilla.opensuse.org/show_bug.cgi?id=1130388",
        "func_before": "bool DDeviceDiskInfoPrivate::openDataStream(int index)\n{\n    if (process) {\n        process->deleteLater();\n    }\n\n    process = new QProcess();\n\n    QObject::connect(process, static_cast<void (QProcess::*)(int, QProcess::ExitStatus)>(&QProcess::finished),\n                     process, [this] (int code, QProcess::ExitStatus status) {\n        if (isClosing())\n            return;\n\n        if (status == QProcess::CrashExit) {\n            setErrorString(QObject::tr(\"process \\\"%1 %2\\\" crashed\").arg(process->program()).arg(process->arguments().join(\" \")));\n        } else if (code != 0) {\n            setErrorString(QObject::tr(\"Failed to perform process \\\"%1 %2\\\", error: %3\").arg(process->program()).arg(process->arguments().join(\" \")).arg(QString::fromUtf8(process->readAllStandardError())));\n        }\n    });\n\n    switch (currentScope) {\n    case DDiskInfo::Headgear: {\n        if (type != DDiskInfo::Disk) {\n            setErrorString(QObject::tr(\"\\\"%1\\\" is not a disk device\").arg(filePath()));\n\n            return false;\n        }\n\n        if (currentMode == DDiskInfo::Read) {\n            process->start(QStringLiteral(\"dd if=%1 bs=512 count=2048 status=none\").arg(filePath()), QIODevice::ReadOnly);\n        } else {\n            process->start(QStringLiteral(\"dd of=%1 bs=512 status=none conv=fsync\").arg(filePath()));\n        }\n\n        break;\n    }\n    case DDiskInfo::PartitionTable: {\n        if (type != DDiskInfo::Disk) {\n            setErrorString(QObject::tr(\"\\\"%1\\\" is not a disk device\").arg(filePath()));\n\n            return false;\n        }\n\n        if (currentMode == DDiskInfo::Read)\n            process->start(QStringLiteral(\"sfdisk -d %1\").arg(filePath()), QIODevice::ReadOnly);\n        else\n            process->start(QStringLiteral(\"sfdisk %1 --no-reread\").arg(filePath()));\n\n        break;\n    }\n    case DDiskInfo::Partition: {\n        const DPartInfo &part = (index == 0 && currentMode == DDiskInfo::Write) ? DDevicePartInfo(filePath()) : q->getPartByNumber(index);\n\n        if (!part) {\n            dCDebug(\"Part is null(index: %d)\", index);\n\n            return false;\n        }\n\n        dCDebug(\"Try open device: %s, mode: %s\", qPrintable(part.filePath()), currentMode == DDiskInfo::Read ? \"Read\" : \"Write\");\n\n        if (Helper::isMounted(part.filePath())) {\n            if (Helper::umountDevice(part.filePath())) {\n                part.d->mountPoint.clear();\n            } else {\n                setErrorString(QObject::tr(\"\\\"%1\\\" is busy\").arg(part.filePath()));\n\n                return false;\n            }\n        }\n\n        if (currentMode == DDiskInfo::Read) {\n            const QString &executer = Helper::getPartcloneExecuter(part);\n            process->start(QStringLiteral(\"%1 -s %2 -o - -c -z %3 -L /tmp/partclone.log\").arg(executer).arg(part.filePath()).arg(Global::bufferSize), QIODevice::ReadOnly);\n        } else {\n            process->start(QStringLiteral(\"partclone.restore -s - -o %2 -z %3 -L /tmp/partclone.log\").arg(part.filePath()).arg(Global::bufferSize));\n        }\n\n        break;\n    }\n    case DDiskInfo::JsonInfo: {\n        process->deleteLater();\n        process = 0;\n        buffer.setData(q->toJson());\n        break;\n    }\n    default:\n        return false;\n    }\n\n    if (process) {\n        if (!process->waitForStarted()) {\n            setErrorString(QObject::tr(\"Failed to start \\\"%1 %2\\\", error: %3\").arg(process->program()).arg(process->arguments().join(\" \")).arg(process->errorString()));\n\n            return false;\n        }\n\n        dCDebug(\"The \\\"%s %s\\\" command start finished\", qPrintable(process->program()), qPrintable(process->arguments().join(\" \")));\n    }\n\n    bool ok = process ? process->isOpen() : buffer.open(QIODevice::ReadOnly);\n\n    if (!ok) {\n        setErrorString(QObject::tr(\"Failed to open process, error: %1\").arg(process ? process->errorString(): buffer.errorString()));\n    }\n\n    return ok;\n}",
        "func": "bool DDeviceDiskInfoPrivate::openDataStream(int index)\n{\n    if (process) {\n        process->deleteLater();\n    }\n\n    process = new QProcess();\n\n    QObject::connect(process, static_cast<void (QProcess::*)(int, QProcess::ExitStatus)>(&QProcess::finished),\n                     process, [this] (int code, QProcess::ExitStatus status) {\n        if (isClosing())\n            return;\n\n        if (status == QProcess::CrashExit) {\n            setErrorString(QObject::tr(\"process \\\"%1 %2\\\" crashed\").arg(process->program()).arg(process->arguments().join(\" \")));\n        } else if (code != 0) {\n            setErrorString(QObject::tr(\"Failed to perform process \\\"%1 %2\\\", error: %3\").arg(process->program()).arg(process->arguments().join(\" \")).arg(QString::fromUtf8(process->readAllStandardError())));\n        }\n    });\n\n    switch (currentScope) {\n    case DDiskInfo::Headgear: {\n        if (type != DDiskInfo::Disk) {\n            setErrorString(QObject::tr(\"\\\"%1\\\" is not a disk device\").arg(filePath()));\n\n            return false;\n        }\n\n        if (currentMode == DDiskInfo::Read) {\n            process->start(QStringLiteral(\"dd if=%1 bs=512 count=2048 status=none\").arg(filePath()), QIODevice::ReadOnly);\n        } else {\n            process->start(QStringLiteral(\"dd of=%1 bs=512 status=none conv=fsync\").arg(filePath()));\n        }\n\n        break;\n    }\n    case DDiskInfo::PartitionTable: {\n        if (type != DDiskInfo::Disk) {\n            setErrorString(QObject::tr(\"\\\"%1\\\" is not a disk device\").arg(filePath()));\n\n            return false;\n        }\n\n        if (currentMode == DDiskInfo::Read)\n            process->start(QStringLiteral(\"sfdisk -d %1\").arg(filePath()), QIODevice::ReadOnly);\n        else\n            process->start(QStringLiteral(\"sfdisk %1 --no-reread\").arg(filePath()));\n\n        break;\n    }\n    case DDiskInfo::Partition: {\n        const DPartInfo &part = (index == 0 && currentMode == DDiskInfo::Write) ? DDevicePartInfo(filePath()) : q->getPartByNumber(index);\n\n        if (!part) {\n            dCDebug(\"Part is null(index: %d)\", index);\n\n            return false;\n        }\n\n        dCDebug(\"Try open device: %s, mode: %s\", qPrintable(part.filePath()), currentMode == DDiskInfo::Read ? \"Read\" : \"Write\");\n\n        if (Helper::isMounted(part.filePath())) {\n            if (Helper::umountDevice(part.filePath())) {\n                part.d->mountPoint.clear();\n            } else {\n                setErrorString(QObject::tr(\"\\\"%1\\\" is busy\").arg(part.filePath()));\n\n                return false;\n            }\n        }\n\n        if (currentMode == DDiskInfo::Read) {\n            const QString &executer = Helper::getPartcloneExecuter(part);\n            process->start(QStringLiteral(\"%1 -s %2 -o - -c -z %3 -L /var/log/partclone.log\").arg(executer).arg(part.filePath()).arg(Global::bufferSize), QIODevice::ReadOnly);\n        } else {\n            process->start(QStringLiteral(\"partclone.restore -s - -o %2 -z %3 -L /var/log/partclone.log\").arg(part.filePath()).arg(Global::bufferSize));\n        }\n\n        break;\n    }\n    case DDiskInfo::JsonInfo: {\n        process->deleteLater();\n        process = 0;\n        buffer.setData(q->toJson());\n        break;\n    }\n    default:\n        return false;\n    }\n\n    if (process) {\n        if (!process->waitForStarted()) {\n            setErrorString(QObject::tr(\"Failed to start \\\"%1 %2\\\", error: %3\").arg(process->program()).arg(process->arguments().join(\" \")).arg(process->errorString()));\n\n            return false;\n        }\n\n        dCDebug(\"The \\\"%s %s\\\" command start finished\", qPrintable(process->program()), qPrintable(process->arguments().join(\" \")));\n    }\n\n    bool ok = process ? process->isOpen() : buffer.open(QIODevice::ReadOnly);\n\n    if (!ok) {\n        setErrorString(QObject::tr(\"Failed to open process, error: %1\").arg(process ? process->errorString(): buffer.errorString()));\n    }\n\n    return ok;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -71,9 +71,9 @@\n \n         if (currentMode == DDiskInfo::Read) {\n             const QString &executer = Helper::getPartcloneExecuter(part);\n-            process->start(QStringLiteral(\"%1 -s %2 -o - -c -z %3 -L /tmp/partclone.log\").arg(executer).arg(part.filePath()).arg(Global::bufferSize), QIODevice::ReadOnly);\n+            process->start(QStringLiteral(\"%1 -s %2 -o - -c -z %3 -L /var/log/partclone.log\").arg(executer).arg(part.filePath()).arg(Global::bufferSize), QIODevice::ReadOnly);\n         } else {\n-            process->start(QStringLiteral(\"partclone.restore -s - -o %2 -z %3 -L /tmp/partclone.log\").arg(part.filePath()).arg(Global::bufferSize));\n+            process->start(QStringLiteral(\"partclone.restore -s - -o %2 -z %3 -L /var/log/partclone.log\").arg(part.filePath()).arg(Global::bufferSize));\n         }\n \n         break;",
        "diff_line_info": {
            "deleted_lines": [
                "            process->start(QStringLiteral(\"%1 -s %2 -o - -c -z %3 -L /tmp/partclone.log\").arg(executer).arg(part.filePath()).arg(Global::bufferSize), QIODevice::ReadOnly);",
                "            process->start(QStringLiteral(\"partclone.restore -s - -o %2 -z %3 -L /tmp/partclone.log\").arg(part.filePath()).arg(Global::bufferSize));"
            ],
            "added_lines": [
                "            process->start(QStringLiteral(\"%1 -s %2 -o - -c -z %3 -L /var/log/partclone.log\").arg(executer).arg(part.filePath()).arg(Global::bufferSize), QIODevice::ReadOnly);",
                "            process->start(QStringLiteral(\"partclone.restore -s - -o %2 -z %3 -L /var/log/partclone.log\").arg(part.filePath()).arg(Global::bufferSize));"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-13226",
        "func_name": "linuxdeepin/deepin-clone/Helper::temporaryMountDevice",
        "description": "deepin-clone before 1.1.3 uses a predictable path /tmp/.deepin-clone/mount/<block-dev-basename> in the Helper::temporaryMountDevice() function to temporarily mount a file system as root. An unprivileged user can prepare a symlink at this location to have the file system mounted in an arbitrary location. By winning a race condition, the attacker can also enter the mount point, thereby preventing a subsequent unmount of the file system.",
        "git_url": "https://github.com/linuxdeepin/deepin-clone/commit/e079f3e2712b4f8c28e3e63e71ba1a1f90fce1ab",
        "commit_title": "fix: Do not use the \"/tmp\" directory",
        "commit_text": " https://github.com/linuxdeepin/deepin-clone/issues/16 https://bugzilla.opensuse.org/show_bug.cgi?id=1130388",
        "func_before": "QString Helper::temporaryMountDevice(const QString &device, const QString &name, bool readonly)\n{\n    QString mount_point = mountPoint(device);\n\n    if (!mount_point.isEmpty())\n        return mount_point;\n\n    mount_point = \"%1/.%2/mount/%3\";\n    const QStringList &tmp_paths = QStandardPaths::standardLocations(QStandardPaths::TempLocation);\n\n    mount_point = mount_point.arg(tmp_paths.isEmpty() ? \"/tmp\" : tmp_paths.first()).arg(qApp->applicationName()).arg(name);\n\n    if (!QDir::current().mkpath(mount_point)) {\n        dCError(\"mkpath \\\"%s\\\" failed\", qPrintable(mount_point));\n\n        return QString();\n    }\n\n    if (!mountDevice(device, mount_point, readonly)) {\n        dCError(\"Mount the device \\\"%s\\\" to \\\"%s\\\" failed\", qPrintable(device), qPrintable(mount_point));\n\n        return QString();\n    }\n\n    return mount_point;\n}",
        "func": "QString Helper::temporaryMountDevice(const QString &device, const QString &name, bool readonly)\n{\n    QString mount_point = mountPoint(device);\n\n    if (!mount_point.isEmpty())\n        return mount_point;\n\n    mount_point = \"%1/.%2/mount/%3\";\n    const QStringList &tmp_paths = QStandardPaths::standardLocations(QStandardPaths::RuntimeLocation);\n\n    mount_point = mount_point.arg(tmp_paths.isEmpty() ? \"/run/user/0\" : tmp_paths.first()).arg(qApp->applicationName()).arg(name);\n\n    if (!QDir::current().mkpath(mount_point)) {\n        dCError(\"mkpath \\\"%s\\\" failed\", qPrintable(mount_point));\n\n        return QString();\n    }\n\n    if (!mountDevice(device, mount_point, readonly)) {\n        dCError(\"Mount the device \\\"%s\\\" to \\\"%s\\\" failed\", qPrintable(device), qPrintable(mount_point));\n\n        return QString();\n    }\n\n    return mount_point;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,9 +6,9 @@\n         return mount_point;\n \n     mount_point = \"%1/.%2/mount/%3\";\n-    const QStringList &tmp_paths = QStandardPaths::standardLocations(QStandardPaths::TempLocation);\n+    const QStringList &tmp_paths = QStandardPaths::standardLocations(QStandardPaths::RuntimeLocation);\n \n-    mount_point = mount_point.arg(tmp_paths.isEmpty() ? \"/tmp\" : tmp_paths.first()).arg(qApp->applicationName()).arg(name);\n+    mount_point = mount_point.arg(tmp_paths.isEmpty() ? \"/run/user/0\" : tmp_paths.first()).arg(qApp->applicationName()).arg(name);\n \n     if (!QDir::current().mkpath(mount_point)) {\n         dCError(\"mkpath \\\"%s\\\" failed\", qPrintable(mount_point));",
        "diff_line_info": {
            "deleted_lines": [
                "    const QStringList &tmp_paths = QStandardPaths::standardLocations(QStandardPaths::TempLocation);",
                "    mount_point = mount_point.arg(tmp_paths.isEmpty() ? \"/tmp\" : tmp_paths.first()).arg(qApp->applicationName()).arg(name);"
            ],
            "added_lines": [
                "    const QStringList &tmp_paths = QStandardPaths::standardLocations(QStandardPaths::RuntimeLocation);",
                "    mount_point = mount_point.arg(tmp_paths.isEmpty() ? \"/run/user/0\" : tmp_paths.first()).arg(qApp->applicationName()).arg(name);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-13226",
        "func_name": "linuxdeepin/deepin-clone/Helper::processExec",
        "description": "deepin-clone before 1.1.3 uses a predictable path /tmp/.deepin-clone/mount/<block-dev-basename> in the Helper::temporaryMountDevice() function to temporarily mount a file system as root. An unprivileged user can prepare a symlink at this location to have the file system mounted in an arbitrary location. By winning a race condition, the attacker can also enter the mount point, thereby preventing a subsequent unmount of the file system.",
        "git_url": "https://github.com/linuxdeepin/deepin-clone/commit/e079f3e2712b4f8c28e3e63e71ba1a1f90fce1ab",
        "commit_title": "fix: Do not use the \"/tmp\" directory",
        "commit_text": " https://github.com/linuxdeepin/deepin-clone/issues/16 https://bugzilla.opensuse.org/show_bug.cgi?id=1130388",
        "func_before": "int Helper::processExec(QProcess *process, const QString &command, int timeout, QIODevice::OpenMode mode)\n{\n    m_processStandardOutput.clear();\n    m_processStandardError.clear();\n\n    QEventLoop loop;\n    QTimer timer;\n\n    timer.setSingleShot(true);\n    timer.setInterval(timeout);\n\n    timer.connect(&timer, &QTimer::timeout, &loop, &QEventLoop::quit);\n    loop.connect(process, static_cast<void(QProcess::*)(int)>(&QProcess::finished), &loop, &QEventLoop::exit);\n\n    // \n    process->connect(process, &QProcess::readyReadStandardError, process, [process] {\n        m_processStandardError.append(process->readAllStandardError());\n    });\n    process->connect(process, &QProcess::readyReadStandardOutput, process, [process] {\n        m_processStandardOutput.append(process->readAllStandardOutput());\n    });\n\n    if (timeout > 0) {\n        timer.start();\n    } else {\n        QTimer::singleShot(10000, process, [process] {\n            dCWarning(\"\\\"%s %s\\\" running for more than 10 seconds, state=%d, pid_file_exist=%d\",\n                      qPrintable(process->program()), qPrintable(process->arguments().join(\" \")),\n                      (int)process->state(), (int)QFile::exists(QString(\"/proc/%1\").arg(process->pid())));\n        });\n    }\n\n    if (Global::debugLevel > 1)\n        dCDebug(\"Exec: \\\"%s\\\", timeout: %d\", qPrintable(command), timeout);\n\n    process->start(command, mode);\n    process->waitForStarted();\n\n    if (process->error() != QProcess::UnknownError) {\n        dCError(process->errorString());\n\n        return -1;\n    }\n\n    if (process->state() == QProcess::Running) {\n        loop.exec();\n    }\n\n    if (process->state() != QProcess::NotRunning) {\n        dCDebug(\"The \\\"%s\\\" timeout, timeout: %d\", qPrintable(command), timeout);\n\n        if (QFile::exists(QString(\"/proc/%1\").arg(process->pid()))) {\n            process->terminate();\n            process->waitForFinished();\n        } else {\n            dCDebug(\"The \\\"%s\\\" is quit, but the QProcess object state is not NotRunning\");\n        }\n    }\n\n    m_processStandardOutput.append(process->readAllStandardOutput());\n    m_processStandardError.append(process->readAllStandardError());\n\n    if (Global::debugLevel > 1) {\n        dCDebug(\"Done: \\\"%s\\\", exit code: %d\", qPrintable(command), process->exitCode());\n\n        if (process->exitCode() != 0) {\n            dCError(\"error: \\\"%s\\\"\\nstdout: \\\"%s\\\"\", qPrintable(m_processStandardError), qPrintable(m_processStandardOutput));\n        }\n    }\n\n    return process->exitCode();\n}",
        "func": "int Helper::processExec(QProcess *process, const QString &command, int timeout, QIODevice::OpenMode mode)\n{\n    m_processStandardOutput.clear();\n    m_processStandardError.clear();\n\n    QEventLoop loop;\n    QTimer timer;\n\n    timer.setSingleShot(true);\n    timer.setInterval(timeout);\n\n    timer.connect(&timer, &QTimer::timeout, &loop, &QEventLoop::quit);\n    loop.connect(process, static_cast<void(QProcess::*)(int)>(&QProcess::finished), &loop, &QEventLoop::exit);\n\n    // \n    process->connect(process, &QProcess::readyReadStandardError, process, [process] {\n        m_processStandardError.append(process->readAllStandardError());\n    });\n    process->connect(process, &QProcess::readyReadStandardOutput, process, [process] {\n        m_processStandardOutput.append(process->readAllStandardOutput());\n    });\n\n    if (timeout > 0) {\n        timer.start();\n    } else {\n        QTimer::singleShot(10000, process, [process] {\n            dCWarning(\"\\\"%s %s\\\" running for more than 10 seconds, state=%d, pid_file_exist=%d\",\n                      qPrintable(process->program()), qPrintable(process->arguments().join(\" \")),\n                      (int)process->state(), (int)QFile::exists(QString(\"/proc/%1\").arg(process->pid())));\n        });\n    }\n\n    if (Global::debugLevel > 1)\n        dCDebug(\"Exec: \\\"%s\\\", timeout: %d\", qPrintable(command), timeout);\n\n    process->start(command, mode);\n    process->waitForStarted();\n\n    if (process->error() != QProcess::UnknownError) {\n        dCError(process->errorString());\n\n        return -1;\n    }\n\n    if (process->state() == QProcess::Running) {\n        loop.exec();\n    }\n\n    if (process->state() != QProcess::NotRunning) {\n        dCDebug(\"The \\\"%s\\\" timeout, timeout: %d\", qPrintable(command), timeout);\n\n        // QT Bug() QProcess::state \n        // ,\n        if (QFile::exists(QString(\"/proc/%1\").arg(process->pid()))) {\n            process->terminate();\n            process->waitForFinished();\n        } else {\n            dCDebug(\"The \\\"%s\\\" is quit, but the QProcess object state is not NotRunning\");\n        }\n    }\n\n    m_processStandardOutput.append(process->readAllStandardOutput());\n    m_processStandardError.append(process->readAllStandardError());\n\n    if (Global::debugLevel > 1) {\n        dCDebug(\"Done: \\\"%s\\\", exit code: %d\", qPrintable(command), process->exitCode());\n\n        if (process->exitCode() != 0) {\n            dCError(\"error: \\\"%s\\\"\\nstdout: \\\"%s\\\"\", qPrintable(m_processStandardError), qPrintable(m_processStandardOutput));\n        }\n    }\n\n    return process->exitCode();\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -49,6 +49,8 @@\n     if (process->state() != QProcess::NotRunning) {\n         dCDebug(\"The \\\"%s\\\" timeout, timeout: %d\", qPrintable(command), timeout);\n \n+        // QT Bug() QProcess::state \n+        // ,\n         if (QFile::exists(QString(\"/proc/%1\").arg(process->pid()))) {\n             process->terminate();\n             process->waitForFinished();",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "        // QT Bug() QProcess::state ",
                "        // ,"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-13226",
        "func_name": "linuxdeepin/deepin-clone/Helper::getPartitionSizeInfo",
        "description": "deepin-clone before 1.1.3 uses a predictable path /tmp/.deepin-clone/mount/<block-dev-basename> in the Helper::temporaryMountDevice() function to temporarily mount a file system as root. An unprivileged user can prepare a symlink at this location to have the file system mounted in an arbitrary location. By winning a race condition, the attacker can also enter the mount point, thereby preventing a subsequent unmount of the file system.",
        "git_url": "https://github.com/linuxdeepin/deepin-clone/commit/e079f3e2712b4f8c28e3e63e71ba1a1f90fce1ab",
        "commit_title": "fix: Do not use the \"/tmp\" directory",
        "commit_text": " https://github.com/linuxdeepin/deepin-clone/issues/16 https://bugzilla.opensuse.org/show_bug.cgi?id=1130388",
        "func_before": "bool Helper::getPartitionSizeInfo(const QString &partDevice, qint64 *used, qint64 *free, int *blockSize)\n{\n    QProcess process;\n    QStringList env_list = QProcess::systemEnvironment();\n\n    env_list.append(\"LANG=C\");\n    process.setEnvironment(env_list);\n\n    if (Helper::isMounted(partDevice)) {\n        process.start(QString(\"df -B1 -P %1\").arg(partDevice));\n        process.waitForFinished();\n\n        if (process.exitCode() != 0) {\n            dCError(\"Call df failed: %s\", qPrintable(process.readAllStandardError()));\n\n            return false;\n        }\n\n        QByteArray output = process.readAll();\n        const QByteArrayList &lines = output.trimmed().split('\\n');\n\n        if (lines.count() != 2)\n            return false;\n\n        output = lines.last().simplified();\n\n        const QByteArrayList &values = output.split(' ');\n\n        if (values.count() != 6)\n            return false;\n\n        bool ok = false;\n\n        if (used)\n            *used = values.at(2).toLongLong(&ok);\n\n        if (!ok)\n            return false;\n\n        if (free)\n            *free = values.at(3).toLongLong(&ok);\n\n        if (!ok)\n            return false;\n\n        return true;\n    } else {\n        process.start(QString(\"%1 -s %2 -c -q -C -L /tmp/partclone.log\").arg(getPartcloneExecuter(DDevicePartInfo(partDevice))).arg(partDevice));\n        process.setStandardOutputFile(\"/dev/null\");\n        process.setReadChannel(QProcess::StandardError);\n        process.waitForStarted();\n\n        qint64 used_block = -1;\n        qint64 free_block = -1;\n\n        while (process.waitForReadyRead(5000)) {\n            const QByteArray &data = process.readAll();\n\n            for (QByteArray line : data.split('\\n')) {\n                line = line.simplified();\n\n                if (QString::fromLatin1(line).contains(QRegularExpression(\"\\\\berror\\\\b\"))) {\n                    dCError(\"Call \\\"%s %s\\\" failed: \\\"%s\\\"\", qPrintable(process.program()), qPrintable(process.arguments().join(' ')), line.constData());\n                }\n\n                if (line.startsWith(\"Space in use:\")) {\n                    bool ok = false;\n                    const QByteArray &value = line.split(' ').value(6, \"-1\");\n\n                    used_block = value.toLongLong(&ok);\n\n                    if (!ok) {\n                        dCError(\"String to LongLong failed, String: %s\", value.constData());\n\n                        return false;\n                    }\n                } else if (line.startsWith(\"Free Space:\")) {\n                    bool ok = false;\n                    const QByteArray &value = line.split(' ').value(5, \"-1\");\n\n                    free_block = value.toLongLong(&ok);\n\n                    if (!ok) {\n                        dCError(\"String to LongLong failed, String: %s\", value.constData());\n\n                        return false;\n                    }\n                } else if (line.startsWith(\"Block size:\")) {\n                    bool ok = false;\n                    const QByteArray &value = line.split(' ').value(2, \"-1\");\n\n                    int block_size = value.toInt(&ok);\n\n                    if (!ok) {\n                        dCError(\"String to Int failed, String: %s\", value.constData());\n\n                        return false;\n                    }\n\n                    if (used_block < 0 || free_block < 0 || block_size < 0)\n                        return false;\n\n                    if (used)\n                        *used = used_block * block_size;\n\n                    if (free)\n                        *free = free_block * block_size;\n\n                    if (blockSize)\n                        *blockSize = block_size;\n\n                    process.terminate();\n                    process.waitForFinished();\n\n                    return true;\n                }\n            }\n        }\n    }\n\n    return false;\n}",
        "func": "bool Helper::getPartitionSizeInfo(const QString &partDevice, qint64 *used, qint64 *free, int *blockSize)\n{\n    QProcess process;\n    QStringList env_list = QProcess::systemEnvironment();\n\n    env_list.append(\"LANG=C\");\n    process.setEnvironment(env_list);\n\n    if (Helper::isMounted(partDevice)) {\n        process.start(QString(\"df -B1 -P %1\").arg(partDevice));\n        process.waitForFinished();\n\n        if (process.exitCode() != 0) {\n            dCError(\"Call df failed: %s\", qPrintable(process.readAllStandardError()));\n\n            return false;\n        }\n\n        QByteArray output = process.readAll();\n        const QByteArrayList &lines = output.trimmed().split('\\n');\n\n        if (lines.count() != 2)\n            return false;\n\n        output = lines.last().simplified();\n\n        const QByteArrayList &values = output.split(' ');\n\n        if (values.count() != 6)\n            return false;\n\n        bool ok = false;\n\n        if (used)\n            *used = values.at(2).toLongLong(&ok);\n\n        if (!ok)\n            return false;\n\n        if (free)\n            *free = values.at(3).toLongLong(&ok);\n\n        if (!ok)\n            return false;\n\n        return true;\n    } else {\n        process.start(QString(\"%1 -s %2 -c -q -C -L /var/log/partclone.log\").arg(getPartcloneExecuter(DDevicePartInfo(partDevice))).arg(partDevice));\n        process.setStandardOutputFile(\"/dev/null\");\n        process.setReadChannel(QProcess::StandardError);\n        process.waitForStarted();\n\n        qint64 used_block = -1;\n        qint64 free_block = -1;\n\n        while (process.waitForReadyRead(5000)) {\n            const QByteArray &data = process.readAll();\n\n            for (QByteArray line : data.split('\\n')) {\n                line = line.simplified();\n\n                if (QString::fromLatin1(line).contains(QRegularExpression(\"\\\\berror\\\\b\"))) {\n                    dCError(\"Call \\\"%s %s\\\" failed: \\\"%s\\\"\", qPrintable(process.program()), qPrintable(process.arguments().join(' ')), line.constData());\n                }\n\n                if (line.startsWith(\"Space in use:\")) {\n                    bool ok = false;\n                    const QByteArray &value = line.split(' ').value(6, \"-1\");\n\n                    used_block = value.toLongLong(&ok);\n\n                    if (!ok) {\n                        dCError(\"String to LongLong failed, String: %s\", value.constData());\n\n                        return false;\n                    }\n                } else if (line.startsWith(\"Free Space:\")) {\n                    bool ok = false;\n                    const QByteArray &value = line.split(' ').value(5, \"-1\");\n\n                    free_block = value.toLongLong(&ok);\n\n                    if (!ok) {\n                        dCError(\"String to LongLong failed, String: %s\", value.constData());\n\n                        return false;\n                    }\n                } else if (line.startsWith(\"Block size:\")) {\n                    bool ok = false;\n                    const QByteArray &value = line.split(' ').value(2, \"-1\");\n\n                    int block_size = value.toInt(&ok);\n\n                    if (!ok) {\n                        dCError(\"String to Int failed, String: %s\", value.constData());\n\n                        return false;\n                    }\n\n                    if (used_block < 0 || free_block < 0 || block_size < 0)\n                        return false;\n\n                    if (used)\n                        *used = used_block * block_size;\n\n                    if (free)\n                        *free = free_block * block_size;\n\n                    if (blockSize)\n                        *blockSize = block_size;\n\n                    process.terminate();\n                    process.waitForFinished();\n\n                    return true;\n                }\n            }\n        }\n    }\n\n    return false;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -45,7 +45,7 @@\n \n         return true;\n     } else {\n-        process.start(QString(\"%1 -s %2 -c -q -C -L /tmp/partclone.log\").arg(getPartcloneExecuter(DDevicePartInfo(partDevice))).arg(partDevice));\n+        process.start(QString(\"%1 -s %2 -c -q -C -L /var/log/partclone.log\").arg(getPartcloneExecuter(DDevicePartInfo(partDevice))).arg(partDevice));\n         process.setStandardOutputFile(\"/dev/null\");\n         process.setReadChannel(QProcess::StandardError);\n         process.waitForStarted();",
        "diff_line_info": {
            "deleted_lines": [
                "        process.start(QString(\"%1 -s %2 -c -q -C -L /tmp/partclone.log\").arg(getPartcloneExecuter(DDevicePartInfo(partDevice))).arg(partDevice));"
            ],
            "added_lines": [
                "        process.start(QString(\"%1 -s %2 -c -q -C -L /var/log/partclone.log\").arg(getPartcloneExecuter(DDevicePartInfo(partDevice))).arg(partDevice));"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-13226",
        "func_name": "linuxdeepin/deepin-clone/BootDoctor::fix",
        "description": "deepin-clone before 1.1.3 uses a predictable path /tmp/.deepin-clone/mount/<block-dev-basename> in the Helper::temporaryMountDevice() function to temporarily mount a file system as root. An unprivileged user can prepare a symlink at this location to have the file system mounted in an arbitrary location. By winning a race condition, the attacker can also enter the mount point, thereby preventing a subsequent unmount of the file system.",
        "git_url": "https://github.com/linuxdeepin/deepin-clone/commit/e079f3e2712b4f8c28e3e63e71ba1a1f90fce1ab",
        "commit_title": "fix: Do not use the \"/tmp\" directory",
        "commit_text": " https://github.com/linuxdeepin/deepin-clone/issues/16 https://bugzilla.opensuse.org/show_bug.cgi?id=1130388",
        "func_before": "bool BootDoctor::fix(const QString &partDevice)\n{\n    m_lastErrorString.clear();\n\n    DDevicePartInfo part_info(partDevice);\n    const QString part_old_uuid = part_info.uuid();\n\n    if (Helper::processExec(\"lsblk -s -d -n -o UUID\") == 0) {\n        if (Helper::lastProcessStandardOutput().contains(part_old_uuid.toLatin1())) {\n            // reset uuid\n            if (Helper::resetPartUUID(part_info)) {\n                QThread::sleep(1);\n                part_info.refresh();\n\n                qDebug() << part_old_uuid << part_info.uuid();\n            } else {\n                dCWarning(\"Failed to reset uuid\");\n            }\n        }\n    }\n\n    bool device_is_mounted = Helper::isMounted(partDevice);\n    const QString &mount_root = Helper::temporaryMountDevice(partDevice, QFileInfo(partDevice).fileName());\n\n    if (mount_root.isEmpty()) {\n        m_lastErrorString = QObject::tr(\"Failed to mount partition \\\"%1\\\"\").arg(partDevice);\n        goto failed;\n    }\n\n    {\n        const QStringList &tmp_paths = QStandardPaths::standardLocations(QStandardPaths::TempLocation);\n        const QString tmp_dir = (tmp_paths.isEmpty() ? \"/tmp\" : tmp_paths.first()) + \"/.deepin-clone\";\n\n        if (!QDir::current().mkpath(tmp_dir)) {\n            dCError(\"mkpath \\\"%s\\\" failed\", qPrintable(tmp_dir));\n            goto failed;\n        }\n\n        const QString &repo_path = tmp_dir + \"/repo.iso\";\n\n        if (!QFile::exists(repo_path)\n                && !QFile::copy(QString(\":/repo_%1.iso\").arg(HOST_ARCH), repo_path)) {\n            dCError(\"copy file failed, new name: %s\", qPrintable(repo_path));\n            goto failed;\n        }\n\n        bool ok = false;\n\n        const QString &repo_mount_point = mount_root + \"/deepin-clone\";\n        QFile file_boot_fix(mount_root + \"/boot_fix.sh\");\n\n        do {\n            if (!QDir(mount_root).exists(\"deepin-clone\") && !QDir(mount_root).mkdir(\"deepin-clone\")) {\n                dCError(\"Create \\\"deepin-clone\\\" dir failed(\\\"%s\\\")\", qPrintable(mount_root));\n                break;\n            }\n\n            if (!Helper::mountDevice(repo_path, repo_mount_point, true)) {\n                m_lastErrorString = QObject::tr(\"Failed to mount partition \\\"%1\\\"\").arg(repo_path);\n                break;\n            }\n\n            if (file_boot_fix.exists()) {\n                file_boot_fix.remove();\n            }\n\n            if (!QFile::copy(QString(\":/scripts/boot_fix_%1.sh\").arg(\n                     #if defined(HOST_ARCH_x86_64) || defined(HOST_ARCH_i386) || defined(HOST_ARCH_i686)\n                                 \"x86\"\n                     #elif defined(HOST_ARCH_mips64) || defined(HOST_ARCH_mips32)\n                                 \"mips\"\n                     #elif defined(HOST_ARCH_sw_64)\n                                 \"sw_64\"\n                     #elif defined(HOST_ARCH_aarch64)\n                                 \"aarch64\"\n                     #else\n                     #pragma message \"Machine: \" HOST_ARCH\n                                \"unknow\"\n                     #endif\n                                 ), file_boot_fix.fileName())) {\n                dCError(\"copy file failed, new name: %s\", qPrintable(file_boot_fix.fileName()));\n                break;\n            }\n\n            if (!file_boot_fix.setPermissions(file_boot_fix.permissions() | QFile::ExeUser)) {\n                dCError(\"Set \\\"%s\\\" permissions failed\", qPrintable(file_boot_fix.fileName()));\n                break;\n            }\n\n            if (Helper::processExec(QString(\"mount --bind -v --bind /dev %1/dev\").arg(mount_root)) != 0) {\n                dCError(\"Failed to bind /dev\");\n                break;\n            }\n\n            if (Helper::processExec(QString(\"mount --bind -v --bind /dev/pts %1/dev/pts\").arg(mount_root)) != 0) {\n                dCError(\"Failed to bind /dev/pts\");\n                break;\n            }\n\n            if (Helper::processExec(QString(\"mount --bind -v --bind /proc %1/proc\").arg(mount_root)) != 0) {\n                dCError(\"Failed to bind /proc\");\n                break;\n            }\n\n            if (Helper::processExec(QString(\"mount --bind -v --bind /sys %1/sys\").arg(mount_root)) != 0) {\n                dCError(\"Failed to bind /sys\");\n                break;\n            }\n\n            ok = true;\n        } while (0);\n\n        QProcess process;\n\n        if (ok) {\n            const QString &parent_device = Helper::parentDevice(partDevice);\n\n            bool is_efi = false;\n\n            if (!parent_device.isEmpty()) {\n                DDeviceDiskInfo info(parent_device);\n\n                dCDebug(\"Disk partition table type: %d\", info.ptType());\n\n                if (info.ptType() == DDeviceDiskInfo::GPT) {\n                    for (const DPartInfo &part : info.childrenPartList()) {\n                        if (part.guidType() == DPartInfo::EFI_SP_None) {\n                            const QString &efi_path = mount_root + \"/boot/efi\";\n\n                            QDir::current().mkpath(efi_path);\n\n                            if (Helper::processExec(QString(\"mount %1 %2\").arg(part.filePath()).arg(efi_path)) != 0) {\n                                dCError(\"Failed to mount EFI partition\");\n                                m_lastErrorString = QObject::tr(\"Failed to mount partition \\\"%1\\\"\").arg(part.filePath());\n                                ok = false;\n                                break;\n                            }\n\n                            is_efi = true;\n\n                            break;\n                        }\n                    }\n\n                    if (!is_efi && m_lastErrorString.isEmpty()) {\n                        m_lastErrorString = QObject::tr(\"EFI partition not found\");\n                        ok = false;\n                    }\n                } else if (info.ptType() == DDeviceDiskInfo::Unknow) {\n                    m_lastErrorString = QObject::tr(\"Unknown partition style\");\n                    ok = false;\n                }\n            }\n\n            if (ok) {\n                process.setProcessChannelMode(QProcess::MergedChannels);\n                process.start(QString(\"chroot %1 ./boot_fix.sh %2 %3 /deepin-clone\")\n                              .arg(mount_root)\n                              .arg(parent_device)\n                              .arg(is_efi ? \"true\" : \"false\"));\n\n                while (process.waitForReadyRead()) {\n                    const QByteArray &data = process.readAll().simplified().constData();\n\n                    dCDebug(data.constData());\n                }\n\n                process.waitForFinished(-1);\n\n                switch (process.exitCode()) {\n                case 1:\n                    m_lastErrorString = QObject::tr(\"Boot for install system failed\");\n                    break;\n                case 2:\n                    m_lastErrorString = QObject::tr(\"Boot for update system failed\");\n                    break;\n                default:\n                    break;\n                }\n            }\n        }\n\n        // clear\n        Helper::processExec(\"umount \" + repo_mount_point);\n        QDir(mount_root).rmdir(\"deepin-clone\");\n        file_boot_fix.remove();\n        Helper::processExec(\"umount \" + mount_root + \"/dev/pts\");\n        Helper::processExec(\"umount \" + mount_root + \"/dev\");\n        Helper::processExec(\"umount \" + mount_root + \"/proc\");\n        Helper::processExec(\"umount \" + mount_root + \"/sys\");\n        Helper::processExec(\"umount \" + mount_root + \"/boot/efi\");\n\n        if (ok && process.exitCode() == 0) {\n            if (part_old_uuid != part_info.uuid()) {\n                dCDebug(\"Reset the uuid from \\\"%s\\\" to \\\"%s\\\"\", qPrintable(part_old_uuid), qPrintable(part_info.uuid()));\n\n                // update /etc/fstab\n                QFile file(mount_root + \"/etc/fstab\");\n\n                if (file.exists() && file.open(QIODevice::ReadWrite)) {\n                    QByteArray data = file.readAll();\n\n                    if (file.seek(0)) {\n                        file.write(data.replace(part_old_uuid.toLatin1(), part_info.uuid().toLatin1()));\n                    }\n\n                    file.close();\n                } else {\n                    dCWarning(\"Failed to update /etc/fstab, error: %s\", qPrintable(file.errorString()));\n                }\n\n                file.setFileName(mount_root + \"/etc/crypttab\");\n\n                if (file.exists() && file.open(QIODevice::ReadWrite)) {\n                    QByteArray data = file.readAll();\n\n                    if (file.seek(0)) {\n                        file.write(data.replace(part_old_uuid.toLatin1(), part_info.uuid().toLatin1()));\n                    }\n\n                    file.close();\n                } else {\n                    dCWarning(\"Failed to update /etc/crypttab, error: %s\", qPrintable(file.errorString()));\n                }\n            }\n\n            if (!device_is_mounted)\n                Helper::umountDevice(partDevice);\n\n            return true;\n        }\n    }\n\nfailed:\n    if (!device_is_mounted)\n        Helper::umountDevice(partDevice);\n\n    if (m_lastErrorString.isEmpty())\n        m_lastErrorString = QObject::tr(\"Boot for repair system failed\");\n\n    dCDebug(\"Restore partition uuid\");\n\n    if (!Helper::resetPartUUID(part_info, part_old_uuid.toLatin1())) {\n        dCWarning(\"Failed to restore partition uuid, part: %s, uuid: %s\", qPrintable(partDevice), qPrintable(part_old_uuid));\n    }\n\n    return false;\n}",
        "func": "bool BootDoctor::fix(const QString &partDevice)\n{\n    m_lastErrorString.clear();\n\n    DDevicePartInfo part_info(partDevice);\n    const QString part_old_uuid = part_info.uuid();\n\n    if (Helper::processExec(\"lsblk -s -d -n -o UUID\") == 0) {\n        if (Helper::lastProcessStandardOutput().contains(part_old_uuid.toLatin1())) {\n            // reset uuid\n            if (Helper::resetPartUUID(part_info)) {\n                QThread::sleep(1);\n                part_info.refresh();\n\n                qDebug() << part_old_uuid << part_info.uuid();\n            } else {\n                dCWarning(\"Failed to reset uuid\");\n            }\n        }\n    }\n\n    bool device_is_mounted = Helper::isMounted(partDevice);\n    const QString &mount_root = Helper::temporaryMountDevice(partDevice, QFileInfo(partDevice).fileName());\n\n    if (mount_root.isEmpty()) {\n        m_lastErrorString = QObject::tr(\"Failed to mount partition \\\"%1\\\"\").arg(partDevice);\n        goto failed;\n    }\n\n    {\n        const QString tmp_dir = \"/var/cache/deepin-clone\";\n\n        if (!QDir::current().mkpath(tmp_dir)) {\n            dCError(\"mkpath \\\"%s\\\" failed\", qPrintable(tmp_dir));\n            goto failed;\n        }\n\n        const QString &repo_path = tmp_dir + \"/repo.iso\";\n\n        if (!QFile::exists(repo_path)\n                && !QFile::copy(QString(\":/repo_%1.iso\").arg(HOST_ARCH), repo_path)) {\n            dCError(\"copy file failed, new name: %s\", qPrintable(repo_path));\n            goto failed;\n        }\n\n        bool ok = false;\n\n        const QString &repo_mount_point = mount_root + \"/deepin-clone\";\n        QFile file_boot_fix(mount_root + \"/boot_fix.sh\");\n\n        do {\n            if (!QDir(mount_root).exists(\"deepin-clone\") && !QDir(mount_root).mkdir(\"deepin-clone\")) {\n                dCError(\"Create \\\"deepin-clone\\\" dir failed(\\\"%s\\\")\", qPrintable(mount_root));\n                break;\n            }\n\n            if (!Helper::mountDevice(repo_path, repo_mount_point, true)) {\n                m_lastErrorString = QObject::tr(\"Failed to mount partition \\\"%1\\\"\").arg(repo_path);\n                break;\n            }\n\n            if (file_boot_fix.exists()) {\n                file_boot_fix.remove();\n            }\n\n            if (!QFile::copy(QString(\":/scripts/boot_fix_%1.sh\").arg(\n                     #if defined(HOST_ARCH_x86_64) || defined(HOST_ARCH_i386) || defined(HOST_ARCH_i686)\n                                 \"x86\"\n                     #elif defined(HOST_ARCH_mips64) || defined(HOST_ARCH_mips32)\n                                 \"mips\"\n                     #elif defined(HOST_ARCH_sw_64)\n                                 \"sw_64\"\n                     #elif defined(HOST_ARCH_aarch64)\n                                 \"aarch64\"\n                     #else\n                     #pragma message \"Machine: \" HOST_ARCH\n                                \"unknow\"\n                     #endif\n                                 ), file_boot_fix.fileName())) {\n                dCError(\"copy file failed, new name: %s\", qPrintable(file_boot_fix.fileName()));\n                break;\n            }\n\n            if (!file_boot_fix.setPermissions(file_boot_fix.permissions() | QFile::ExeUser)) {\n                dCError(\"Set \\\"%s\\\" permissions failed\", qPrintable(file_boot_fix.fileName()));\n                break;\n            }\n\n            if (Helper::processExec(QString(\"mount --bind -v --bind /dev %1/dev\").arg(mount_root)) != 0) {\n                dCError(\"Failed to bind /dev\");\n                break;\n            }\n\n            if (Helper::processExec(QString(\"mount --bind -v --bind /dev/pts %1/dev/pts\").arg(mount_root)) != 0) {\n                dCError(\"Failed to bind /dev/pts\");\n                break;\n            }\n\n            if (Helper::processExec(QString(\"mount --bind -v --bind /proc %1/proc\").arg(mount_root)) != 0) {\n                dCError(\"Failed to bind /proc\");\n                break;\n            }\n\n            if (Helper::processExec(QString(\"mount --bind -v --bind /sys %1/sys\").arg(mount_root)) != 0) {\n                dCError(\"Failed to bind /sys\");\n                break;\n            }\n\n            ok = true;\n        } while (0);\n\n        QProcess process;\n\n        if (ok) {\n            const QString &parent_device = Helper::parentDevice(partDevice);\n\n            bool is_efi = false;\n\n            if (!parent_device.isEmpty()) {\n                DDeviceDiskInfo info(parent_device);\n\n                dCDebug(\"Disk partition table type: %d\", info.ptType());\n\n                if (info.ptType() == DDeviceDiskInfo::GPT) {\n                    for (const DPartInfo &part : info.childrenPartList()) {\n                        if (part.guidType() == DPartInfo::EFI_SP_None) {\n                            const QString &efi_path = mount_root + \"/boot/efi\";\n\n                            QDir::current().mkpath(efi_path);\n\n                            if (Helper::processExec(QString(\"mount %1 %2\").arg(part.filePath()).arg(efi_path)) != 0) {\n                                dCError(\"Failed to mount EFI partition\");\n                                m_lastErrorString = QObject::tr(\"Failed to mount partition \\\"%1\\\"\").arg(part.filePath());\n                                ok = false;\n                                break;\n                            }\n\n                            is_efi = true;\n\n                            break;\n                        }\n                    }\n\n                    if (!is_efi && m_lastErrorString.isEmpty()) {\n                        m_lastErrorString = QObject::tr(\"EFI partition not found\");\n                        ok = false;\n                    }\n                } else if (info.ptType() == DDeviceDiskInfo::Unknow) {\n                    m_lastErrorString = QObject::tr(\"Unknown partition style\");\n                    ok = false;\n                }\n            }\n\n            if (ok) {\n                process.setProcessChannelMode(QProcess::MergedChannels);\n                process.start(QString(\"chroot %1 ./boot_fix.sh %2 %3 /deepin-clone\")\n                              .arg(mount_root)\n                              .arg(parent_device)\n                              .arg(is_efi ? \"true\" : \"false\"));\n\n                while (process.waitForReadyRead()) {\n                    const QByteArray &data = process.readAll().simplified().constData();\n\n                    dCDebug(data.constData());\n                }\n\n                process.waitForFinished(-1);\n\n                switch (process.exitCode()) {\n                case 1:\n                    m_lastErrorString = QObject::tr(\"Boot for install system failed\");\n                    break;\n                case 2:\n                    m_lastErrorString = QObject::tr(\"Boot for update system failed\");\n                    break;\n                default:\n                    break;\n                }\n            }\n        }\n\n        // clear\n        Helper::processExec(\"umount \" + repo_mount_point);\n        QDir(mount_root).rmdir(\"deepin-clone\");\n        file_boot_fix.remove();\n        Helper::processExec(\"umount \" + mount_root + \"/dev/pts\");\n        Helper::processExec(\"umount \" + mount_root + \"/dev\");\n        Helper::processExec(\"umount \" + mount_root + \"/proc\");\n        Helper::processExec(\"umount \" + mount_root + \"/sys\");\n        Helper::processExec(\"umount \" + mount_root + \"/boot/efi\");\n\n        if (ok && process.exitCode() == 0) {\n            if (part_old_uuid != part_info.uuid()) {\n                dCDebug(\"Reset the uuid from \\\"%s\\\" to \\\"%s\\\"\", qPrintable(part_old_uuid), qPrintable(part_info.uuid()));\n\n                // update /etc/fstab\n                QFile file(mount_root + \"/etc/fstab\");\n\n                if (file.exists() && file.open(QIODevice::ReadWrite)) {\n                    QByteArray data = file.readAll();\n\n                    if (file.seek(0)) {\n                        file.write(data.replace(part_old_uuid.toLatin1(), part_info.uuid().toLatin1()));\n                    }\n\n                    file.close();\n                } else {\n                    dCWarning(\"Failed to update /etc/fstab, error: %s\", qPrintable(file.errorString()));\n                }\n\n                file.setFileName(mount_root + \"/etc/crypttab\");\n\n                if (file.exists() && file.open(QIODevice::ReadWrite)) {\n                    QByteArray data = file.readAll();\n\n                    if (file.seek(0)) {\n                        file.write(data.replace(part_old_uuid.toLatin1(), part_info.uuid().toLatin1()));\n                    }\n\n                    file.close();\n                } else {\n                    dCWarning(\"Failed to update /etc/crypttab, error: %s\", qPrintable(file.errorString()));\n                }\n            }\n\n            if (!device_is_mounted)\n                Helper::umountDevice(partDevice);\n\n            return true;\n        }\n    }\n\nfailed:\n    if (!device_is_mounted)\n        Helper::umountDevice(partDevice);\n\n    if (m_lastErrorString.isEmpty())\n        m_lastErrorString = QObject::tr(\"Boot for repair system failed\");\n\n    dCDebug(\"Restore partition uuid\");\n\n    if (!Helper::resetPartUUID(part_info, part_old_uuid.toLatin1())) {\n        dCWarning(\"Failed to restore partition uuid, part: %s, uuid: %s\", qPrintable(partDevice), qPrintable(part_old_uuid));\n    }\n\n    return false;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -28,8 +28,7 @@\n     }\n \n     {\n-        const QStringList &tmp_paths = QStandardPaths::standardLocations(QStandardPaths::TempLocation);\n-        const QString tmp_dir = (tmp_paths.isEmpty() ? \"/tmp\" : tmp_paths.first()) + \"/.deepin-clone\";\n+        const QString tmp_dir = \"/var/cache/deepin-clone\";\n \n         if (!QDir::current().mkpath(tmp_dir)) {\n             dCError(\"mkpath \\\"%s\\\" failed\", qPrintable(tmp_dir));",
        "diff_line_info": {
            "deleted_lines": [
                "        const QStringList &tmp_paths = QStandardPaths::standardLocations(QStandardPaths::TempLocation);",
                "        const QString tmp_dir = (tmp_paths.isEmpty() ? \"/tmp\" : tmp_paths.first()) + \"/.deepin-clone\";"
            ],
            "added_lines": [
                "        const QString tmp_dir = \"/var/cache/deepin-clone\";"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-23520",
        "func_name": "juce-framework/JUCE/TemporaryFile::deleteTemporaryFile",
        "description": "The package juce-framework/juce before 6.1.5 are vulnerable to Arbitrary File Write via Archive Extraction (Zip Slip) via the ZipFile::uncompressEntry function in juce_ZipFile.cpp. This vulnerability is triggered when the archive is extracted upon calling uncompressTo() on a ZipFile object.",
        "git_url": "https://github.com/juce-framework/JUCE/commit/2e874e80cba0152201aff6a4d0dc407997d10a7f",
        "commit_title": "ZipFile:  Add path checks to uncompressEntry()",
        "commit_text": "",
        "func_before": "bool TemporaryFile::deleteTemporaryFile() const\n{\n    // Have a few attempts at deleting the file before giving up..\n    for (int i = 5; --i >= 0;)\n    {\n        if (temporaryFile.deleteFile())\n            return true;\n\n        Thread::sleep (50);\n    }\n\n    return false;\n}",
        "func": "bool TemporaryFile::deleteTemporaryFile() const\n{\n    // Have a few attempts at deleting the file before giving up..\n    for (int i = 5; --i >= 0;)\n    {\n        if (temporaryFile.isDirectory() ? temporaryFile.deleteRecursively() : temporaryFile.deleteFile())\n            return true;\n\n        Thread::sleep (50);\n    }\n\n    return false;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,7 +3,7 @@\n     // Have a few attempts at deleting the file before giving up..\n     for (int i = 5; --i >= 0;)\n     {\n-        if (temporaryFile.deleteFile())\n+        if (temporaryFile.isDirectory() ? temporaryFile.deleteRecursively() : temporaryFile.deleteFile())\n             return true;\n \n         Thread::sleep (50);",
        "diff_line_info": {
            "deleted_lines": [
                "        if (temporaryFile.deleteFile())"
            ],
            "added_lines": [
                "        if (temporaryFile.isDirectory() ? temporaryFile.deleteRecursively() : temporaryFile.deleteFile())"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-23520",
        "func_name": "juce-framework/JUCE/runTest",
        "description": "The package juce-framework/juce before 6.1.5 are vulnerable to Arbitrary File Write via Archive Extraction (Zip Slip) via the ZipFile::uncompressEntry function in juce_ZipFile.cpp. This vulnerability is triggered when the archive is extracted upon calling uncompressTo() on a ZipFile object.",
        "git_url": "https://github.com/juce-framework/JUCE/commit/2e874e80cba0152201aff6a4d0dc407997d10a7f",
        "commit_title": "ZipFile:  Add path checks to uncompressEntry()",
        "commit_text": "",
        "func_before": "void runTest() override\n    {\n        beginTest (\"ZIP\");\n\n        ZipFile::Builder builder;\n        StringArray entryNames { \"first\", \"second\", \"third\" };\n        HashMap<String, MemoryBlock> blocks;\n\n        for (auto& entryName : entryNames)\n        {\n            auto& block = blocks.getReference (entryName);\n            MemoryOutputStream mo (block, false);\n            mo << entryName;\n            mo.flush();\n            builder.addEntry (new MemoryInputStream (block, false), 9, entryName, Time::getCurrentTime());\n        }\n\n        MemoryBlock data;\n        MemoryOutputStream mo (data, false);\n        builder.writeToStream (mo, nullptr);\n        MemoryInputStream mi (data, false);\n\n        ZipFile zip (mi);\n\n        expectEquals (zip.getNumEntries(), entryNames.size());\n\n        for (auto& entryName : entryNames)\n        {\n            auto* entry = zip.getEntry (entryName);\n            std::unique_ptr<InputStream> input (zip.createStreamForEntry (*entry));\n            expectEquals (input->readEntireStreamAsString(), entryName);\n        }\n    }",
        "func": "void runTest() override\n    {\n        beginTest (\"ZIP\");\n\n        StringArray entryNames { \"first\", \"second\", \"third\" };\n        auto data = createZipMemoryBlock (entryNames);\n        MemoryInputStream mi (data, false);\n        ZipFile zip (mi);\n\n        expectEquals (zip.getNumEntries(), entryNames.size());\n\n        for (auto& entryName : entryNames)\n        {\n            auto* entry = zip.getEntry (entryName);\n            std::unique_ptr<InputStream> input (zip.createStreamForEntry (*entry));\n            expectEquals (input->readEntireStreamAsString(), entryName);\n        }\n\n        beginTest (\"ZipSlip\");\n        runZipSlipTest();\n    }",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,24 +2,9 @@\n     {\n         beginTest (\"ZIP\");\n \n-        ZipFile::Builder builder;\n         StringArray entryNames { \"first\", \"second\", \"third\" };\n-        HashMap<String, MemoryBlock> blocks;\n-\n-        for (auto& entryName : entryNames)\n-        {\n-            auto& block = blocks.getReference (entryName);\n-            MemoryOutputStream mo (block, false);\n-            mo << entryName;\n-            mo.flush();\n-            builder.addEntry (new MemoryInputStream (block, false), 9, entryName, Time::getCurrentTime());\n-        }\n-\n-        MemoryBlock data;\n-        MemoryOutputStream mo (data, false);\n-        builder.writeToStream (mo, nullptr);\n+        auto data = createZipMemoryBlock (entryNames);\n         MemoryInputStream mi (data, false);\n-\n         ZipFile zip (mi);\n \n         expectEquals (zip.getNumEntries(), entryNames.size());\n@@ -30,4 +15,7 @@\n             std::unique_ptr<InputStream> input (zip.createStreamForEntry (*entry));\n             expectEquals (input->readEntireStreamAsString(), entryName);\n         }\n+\n+        beginTest (\"ZipSlip\");\n+        runZipSlipTest();\n     }",
        "diff_line_info": {
            "deleted_lines": [
                "        ZipFile::Builder builder;",
                "        HashMap<String, MemoryBlock> blocks;",
                "",
                "        for (auto& entryName : entryNames)",
                "        {",
                "            auto& block = blocks.getReference (entryName);",
                "            MemoryOutputStream mo (block, false);",
                "            mo << entryName;",
                "            mo.flush();",
                "            builder.addEntry (new MemoryInputStream (block, false), 9, entryName, Time::getCurrentTime());",
                "        }",
                "",
                "        MemoryBlock data;",
                "        MemoryOutputStream mo (data, false);",
                "        builder.writeToStream (mo, nullptr);",
                ""
            ],
            "added_lines": [
                "        auto data = createZipMemoryBlock (entryNames);",
                "",
                "        beginTest (\"ZipSlip\");",
                "        runZipSlipTest();"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-23177",
        "func_name": "libarchive/archive_write_disk_set_acls",
        "description": "An improper link resolution flaw while extracting an archive can lead to changing the access control list (ACL) of the target of the link. An attacker may provide a malicious archive to a victim user, who would trigger this flaw when trying to extract the archive. A local attacker may use this flaw to change the ACL of a file on the system and gain more privileges.",
        "git_url": "https://github.com/libarchive/libarchive/commit/fba4f123cc456d2b2538f811bb831483bf336bad",
        "commit_title": "Fix handling of symbolic link ACLs",
        "commit_text": " On Linux ACLs on symbolic links are not supported. We must avoid calling acl_set_file() on symbolic links as their targets are modified instead.  While here, do not try to set default ACLs on non-directories.  Fixes #1565",
        "func_before": "int\narchive_write_disk_set_acls(struct archive *a, int fd, const char *name,\n    struct archive_acl *abstract_acl, __LA_MODE_T mode)\n{\n\tint\t\tret = ARCHIVE_OK;\n\n\t(void)mode;\t/* UNUSED */\n\n\tif ((archive_acl_types(abstract_acl)\n\t    & ARCHIVE_ENTRY_ACL_TYPE_POSIX1E) != 0) {\n\t\tif ((archive_acl_types(abstract_acl)\n\t\t    & ARCHIVE_ENTRY_ACL_TYPE_ACCESS) != 0) {\n\t\t\tret = set_acl(a, fd, name, abstract_acl,\n\t\t\t    ARCHIVE_ENTRY_ACL_TYPE_ACCESS, \"access\");\n\t\t\tif (ret != ARCHIVE_OK)\n\t\t\t\treturn (ret);\n\t\t}\n\t\tif ((archive_acl_types(abstract_acl)\n\t\t    & ARCHIVE_ENTRY_ACL_TYPE_DEFAULT) != 0)\n\t\t\tret = set_acl(a, fd, name, abstract_acl,\n\t\t\t    ARCHIVE_ENTRY_ACL_TYPE_DEFAULT, \"default\");\n\n\t\t/* Simultaneous POSIX.1e and NFSv4 is not supported */\n\t\treturn (ret);\n\t}\n#if ARCHIVE_ACL_FREEBSD_NFS4\n\telse if ((archive_acl_types(abstract_acl) &\n\t    ARCHIVE_ENTRY_ACL_TYPE_NFS4) != 0) {\n\t\tret = set_acl(a, fd, name, abstract_acl,\n\t\t    ARCHIVE_ENTRY_ACL_TYPE_NFS4, \"nfs4\");\n\t}\n#endif\n\treturn (ret);\n}",
        "func": "int\narchive_write_disk_set_acls(struct archive *a, int fd, const char *name,\n    struct archive_acl *abstract_acl, __LA_MODE_T mode)\n{\n\tint\t\tret = ARCHIVE_OK;\n\n\t(void)mode;\t/* UNUSED */\n\n\tif ((archive_acl_types(abstract_acl)\n\t    & ARCHIVE_ENTRY_ACL_TYPE_POSIX1E) != 0) {\n\t\tif ((archive_acl_types(abstract_acl)\n\t\t    & ARCHIVE_ENTRY_ACL_TYPE_ACCESS) != 0) {\n\t\t\tret = set_acl(a, fd, name, abstract_acl, mode,\n\t\t\t    ARCHIVE_ENTRY_ACL_TYPE_ACCESS, \"access\");\n\t\t\tif (ret != ARCHIVE_OK)\n\t\t\t\treturn (ret);\n\t\t}\n\t\tif ((archive_acl_types(abstract_acl)\n\t\t    & ARCHIVE_ENTRY_ACL_TYPE_DEFAULT) != 0)\n\t\t\tret = set_acl(a, fd, name, abstract_acl, mode,\n\t\t\t    ARCHIVE_ENTRY_ACL_TYPE_DEFAULT, \"default\");\n\n\t\t/* Simultaneous POSIX.1e and NFSv4 is not supported */\n\t\treturn (ret);\n\t}\n#if ARCHIVE_ACL_FREEBSD_NFS4\n\telse if ((archive_acl_types(abstract_acl) &\n\t    ARCHIVE_ENTRY_ACL_TYPE_NFS4) != 0) {\n\t\tret = set_acl(a, fd, name, abstract_acl, mode,\n\t\t    ARCHIVE_ENTRY_ACL_TYPE_NFS4, \"nfs4\");\n\t}\n#endif\n\treturn (ret);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -10,14 +10,14 @@\n \t    & ARCHIVE_ENTRY_ACL_TYPE_POSIX1E) != 0) {\n \t\tif ((archive_acl_types(abstract_acl)\n \t\t    & ARCHIVE_ENTRY_ACL_TYPE_ACCESS) != 0) {\n-\t\t\tret = set_acl(a, fd, name, abstract_acl,\n+\t\t\tret = set_acl(a, fd, name, abstract_acl, mode,\n \t\t\t    ARCHIVE_ENTRY_ACL_TYPE_ACCESS, \"access\");\n \t\t\tif (ret != ARCHIVE_OK)\n \t\t\t\treturn (ret);\n \t\t}\n \t\tif ((archive_acl_types(abstract_acl)\n \t\t    & ARCHIVE_ENTRY_ACL_TYPE_DEFAULT) != 0)\n-\t\t\tret = set_acl(a, fd, name, abstract_acl,\n+\t\t\tret = set_acl(a, fd, name, abstract_acl, mode,\n \t\t\t    ARCHIVE_ENTRY_ACL_TYPE_DEFAULT, \"default\");\n \n \t\t/* Simultaneous POSIX.1e and NFSv4 is not supported */\n@@ -26,7 +26,7 @@\n #if ARCHIVE_ACL_FREEBSD_NFS4\n \telse if ((archive_acl_types(abstract_acl) &\n \t    ARCHIVE_ENTRY_ACL_TYPE_NFS4) != 0) {\n-\t\tret = set_acl(a, fd, name, abstract_acl,\n+\t\tret = set_acl(a, fd, name, abstract_acl, mode,\n \t\t    ARCHIVE_ENTRY_ACL_TYPE_NFS4, \"nfs4\");\n \t}\n #endif",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\tret = set_acl(a, fd, name, abstract_acl,",
                "\t\t\tret = set_acl(a, fd, name, abstract_acl,",
                "\t\tret = set_acl(a, fd, name, abstract_acl,"
            ],
            "added_lines": [
                "\t\t\tret = set_acl(a, fd, name, abstract_acl, mode,",
                "\t\t\tret = set_acl(a, fd, name, abstract_acl, mode,",
                "\t\tret = set_acl(a, fd, name, abstract_acl, mode,"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-23177",
        "func_name": "libarchive/set_acl",
        "description": "An improper link resolution flaw while extracting an archive can lead to changing the access control list (ACL) of the target of the link. An attacker may provide a malicious archive to a victim user, who would trigger this flaw when trying to extract the archive. A local attacker may use this flaw to change the ACL of a file on the system and gain more privileges.",
        "git_url": "https://github.com/libarchive/libarchive/commit/fba4f123cc456d2b2538f811bb831483bf336bad",
        "commit_title": "Fix handling of symbolic link ACLs",
        "commit_text": " On Linux ACLs on symbolic links are not supported. We must avoid calling acl_set_file() on symbolic links as their targets are modified instead.  While here, do not try to set default ACLs on non-directories.  Fixes #1565",
        "func_before": "static int\nset_acl(struct archive *a, int fd, const char *name,\n    struct archive_acl *abstract_acl,\n    int ae_requested_type, const char *tname)\n{\n\tint\t\t acl_type = 0;\n\tacl_t\t\t acl;\n\tacl_entry_t\t acl_entry;\n\tacl_permset_t\t acl_permset;\n#if ARCHIVE_ACL_FREEBSD_NFS4\n\tacl_flagset_t\t acl_flagset;\n\tint\t\t r;\n#endif\n\tint\t\t ret;\n\tint\t\t ae_type, ae_permset, ae_tag, ae_id;\n\tint\t\t perm_map_size;\n\tconst acl_perm_map_t\t*perm_map;\n\tuid_t\t\t ae_uid;\n\tgid_t\t\t ae_gid;\n\tconst char\t*ae_name;\n\tint\t\t entries;\n\tint\t\t i;\n\n\tret = ARCHIVE_OK;\n\tentries = archive_acl_reset(abstract_acl, ae_requested_type);\n\tif (entries == 0)\n\t\treturn (ARCHIVE_OK);\n\n\n\tswitch (ae_requested_type) {\n\tcase ARCHIVE_ENTRY_ACL_TYPE_ACCESS:\n\t\tacl_type = ACL_TYPE_ACCESS;\n\t\tbreak;\n\tcase ARCHIVE_ENTRY_ACL_TYPE_DEFAULT:\n\t\tacl_type = ACL_TYPE_DEFAULT;\n\t\tbreak;\n#if ARCHIVE_ACL_FREEBSD_NFS4\n\tcase ARCHIVE_ENTRY_ACL_TYPE_NFS4:\n\t\tacl_type = ACL_TYPE_NFS4;\n\t\tbreak;\n#endif\n\tdefault:\n\t\terrno = ENOENT;\n\t\tarchive_set_error(a, errno, \"Unsupported ACL type\");\n\t\treturn (ARCHIVE_FAILED);\n\t}\n\n\tacl = acl_init(entries);\n\tif (acl == (acl_t)NULL) {\n\t\tarchive_set_error(a, errno,\n\t\t    \"Failed to initialize ACL working storage\");\n\t\treturn (ARCHIVE_FAILED);\n\t}\n\n\twhile (archive_acl_next(a, abstract_acl, ae_requested_type, &ae_type,\n\t\t   &ae_permset, &ae_tag, &ae_id, &ae_name) == ARCHIVE_OK) {\n\t\tif (acl_create_entry(&acl, &acl_entry) != 0) {\n\t\t\tarchive_set_error(a, errno,\n\t\t\t    \"Failed to create a new ACL entry\");\n\t\t\tret = ARCHIVE_FAILED;\n\t\t\tgoto exit_free;\n\t\t}\n\t\tswitch (ae_tag) {\n\t\tcase ARCHIVE_ENTRY_ACL_USER:\n\t\t\tae_uid = archive_write_disk_uid(a, ae_name, ae_id);\n\t\t\tacl_set_tag_type(acl_entry, ACL_USER);\n\t\t\tacl_set_qualifier(acl_entry, &ae_uid);\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_GROUP:\n\t\t\tae_gid = archive_write_disk_gid(a, ae_name, ae_id);\n\t\t\tacl_set_tag_type(acl_entry, ACL_GROUP);\n\t\t\tacl_set_qualifier(acl_entry, &ae_gid);\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_USER_OBJ:\n\t\t\tacl_set_tag_type(acl_entry, ACL_USER_OBJ);\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_GROUP_OBJ:\n\t\t\tacl_set_tag_type(acl_entry, ACL_GROUP_OBJ);\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_MASK:\n\t\t\tacl_set_tag_type(acl_entry, ACL_MASK);\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_OTHER:\n\t\t\tacl_set_tag_type(acl_entry, ACL_OTHER);\n\t\t\tbreak;\n#if ARCHIVE_ACL_FREEBSD_NFS4\n\t\tcase ARCHIVE_ENTRY_ACL_EVERYONE:\n\t\t\tacl_set_tag_type(acl_entry, ACL_EVERYONE);\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_MISC,\n\t\t\t    \"Unsupported ACL tag\");\n\t\t\tret = ARCHIVE_FAILED;\n\t\t\tgoto exit_free;\n\t\t}\n\n#if ARCHIVE_ACL_FREEBSD_NFS4\n\t\tr = 0;\n\t\tswitch (ae_type) {\n\t\tcase ARCHIVE_ENTRY_ACL_TYPE_ALLOW:\n\t\t\tr = acl_set_entry_type_np(acl_entry,\n\t\t\t    ACL_ENTRY_TYPE_ALLOW);\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_TYPE_DENY:\n\t\t\tr = acl_set_entry_type_np(acl_entry,\n\t\t\t    ACL_ENTRY_TYPE_DENY);\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_TYPE_AUDIT:\n\t\t\tr = acl_set_entry_type_np(acl_entry,\n\t\t\t    ACL_ENTRY_TYPE_AUDIT);\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_TYPE_ALARM:\n\t\t\tr = acl_set_entry_type_np(acl_entry,\n\t\t\t    ACL_ENTRY_TYPE_ALARM);\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_TYPE_ACCESS:\n\t\tcase ARCHIVE_ENTRY_ACL_TYPE_DEFAULT:\n\t\t\t// These don't translate directly into the system ACL.\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_MISC,\n\t\t\t    \"Unsupported ACL entry type\");\n\t\t\tret = ARCHIVE_FAILED;\n\t\t\tgoto exit_free;\n\t\t}\n\n\t\tif (r != 0) {\n\t\t\tarchive_set_error(a, errno,\n\t\t\t    \"Failed to set ACL entry type\");\n\t\t\tret = ARCHIVE_FAILED;\n\t\t\tgoto exit_free;\n\t\t}\n#endif\n\n\t\tif (acl_get_permset(acl_entry, &acl_permset) != 0) {\n\t\t\tarchive_set_error(a, errno,\n\t\t\t    \"Failed to get ACL permission set\");\n\t\t\tret = ARCHIVE_FAILED;\n\t\t\tgoto exit_free;\n\t\t}\n\t\tif (acl_clear_perms(acl_permset) != 0) {\n\t\t\tarchive_set_error(a, errno,\n\t\t\t    \"Failed to clear ACL permissions\");\n\t\t\tret = ARCHIVE_FAILED;\n\t\t\tgoto exit_free;\n\t\t}\n#if ARCHIVE_ACL_FREEBSD_NFS4\n\t\tif (ae_requested_type == ARCHIVE_ENTRY_ACL_TYPE_NFS4) {\n\t\t\tperm_map_size = acl_nfs4_perm_map_size;\n\t\t\tperm_map = acl_nfs4_perm_map;\n\t\t} else {\n#endif\n\t\t\tperm_map_size = acl_posix_perm_map_size;\n\t\t\tperm_map = acl_posix_perm_map;\n#if ARCHIVE_ACL_FREEBSD_NFS4\n\t\t}\n#endif\n\n\t\tfor (i = 0; i < perm_map_size; ++i) {\n\t\t\tif (ae_permset & perm_map[i].a_perm) {\n\t\t\t\tif (acl_add_perm(acl_permset,\n\t\t\t\t    perm_map[i].p_perm) != 0) {\n\t\t\t\t\tarchive_set_error(a, errno,\n\t\t\t\t\t    \"Failed to add ACL permission\");\n\t\t\t\t\tret = ARCHIVE_FAILED;\n\t\t\t\t\tgoto exit_free;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n#if ARCHIVE_ACL_FREEBSD_NFS4\n\t\tif (ae_requested_type == ARCHIVE_ENTRY_ACL_TYPE_NFS4) {\n\t\t\t/*\n\t\t\t * acl_get_flagset_np() fails with non-NFSv4 ACLs\n\t\t\t */\n\t\t\tif (acl_get_flagset_np(acl_entry, &acl_flagset) != 0) {\n\t\t\t\tarchive_set_error(a, errno,\n\t\t\t\t    \"Failed to get flagset from an NFSv4 \"\n\t\t\t\t    \"ACL entry\");\n\t\t\t\tret = ARCHIVE_FAILED;\n\t\t\t\tgoto exit_free;\n\t\t\t}\n\t\t\tif (acl_clear_flags_np(acl_flagset) != 0) {\n\t\t\t\tarchive_set_error(a, errno,\n\t\t\t\t    \"Failed to clear flags from an NFSv4 \"\n\t\t\t\t    \"ACL flagset\");\n\t\t\t\tret = ARCHIVE_FAILED;\n\t\t\t\tgoto exit_free;\n\t\t\t}\n\t\t\tfor (i = 0; i < acl_nfs4_flag_map_size; ++i) {\n\t\t\t\tif (ae_permset & acl_nfs4_flag_map[i].a_perm) {\n\t\t\t\t\tif (acl_add_flag_np(acl_flagset,\n\t\t\t\t\t    acl_nfs4_flag_map[i].p_perm) != 0) {\n\t\t\t\t\t\tarchive_set_error(a, errno,\n\t\t\t\t\t\t    \"Failed to add flag to \"\n\t\t\t\t\t\t    \"NFSv4 ACL flagset\");\n\t\t\t\t\t\tret = ARCHIVE_FAILED;\n\t\t\t\t\t\tgoto exit_free;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n#endif\n\t}\n\n\t/* Try restoring the ACL through 'fd' if we can. */\n\tif (fd >= 0) {\n\t\tif (acl_set_fd_np(fd, acl, acl_type) == 0)\n\t\t\tret = ARCHIVE_OK;\n\t\telse {\n\t\t\tif (errno == EOPNOTSUPP) {\n\t\t\t\t/* Filesystem doesn't support ACLs */\n\t\t\t\tret = ARCHIVE_OK;\n\t\t\t} else {\n\t\t\t\tarchive_set_error(a, errno,\n\t\t\t\t    \"Failed to set acl on fd: %s\", tname);\n\t\t\t\tret = ARCHIVE_WARN;\n\t\t\t}\n\t\t}\n\t}\n#if HAVE_ACL_SET_LINK_NP\n\telse if (acl_set_link_np(name, acl_type, acl) != 0)\n#else\n\t/* FreeBSD older than 8.0 */\n\telse if (acl_set_file(name, acl_type, acl) != 0)\n#endif\n\t{\n\t\tif (errno == EOPNOTSUPP) {\n\t\t\t/* Filesystem doesn't support ACLs */\n\t\t\tret = ARCHIVE_OK;\n\t\t} else {\n\t\t\tarchive_set_error(a, errno, \"Failed to set acl: %s\",\n\t\t\t    tname);\n\t\t\tret = ARCHIVE_WARN;\n\t\t}\n\t}\nexit_free:\n\tacl_free(acl);\n\treturn (ret);\n}",
        "func": "static int\nset_acl(struct archive *a, int fd, const char *name,\n    struct archive_acl *abstract_acl, __LA_MODE_T mode,\n    int ae_requested_type, const char *tname)\n{\n\tint\t\t acl_type = 0;\n\tacl_t\t\t acl;\n\tacl_entry_t\t acl_entry;\n\tacl_permset_t\t acl_permset;\n#if ARCHIVE_ACL_FREEBSD_NFS4\n\tacl_flagset_t\t acl_flagset;\n\tint\t\t r;\n#endif\n\tint\t\t ret;\n\tint\t\t ae_type, ae_permset, ae_tag, ae_id;\n\tint\t\t perm_map_size;\n\tconst acl_perm_map_t\t*perm_map;\n\tuid_t\t\t ae_uid;\n\tgid_t\t\t ae_gid;\n\tconst char\t*ae_name;\n\tint\t\t entries;\n\tint\t\t i;\n\n\tret = ARCHIVE_OK;\n\tentries = archive_acl_reset(abstract_acl, ae_requested_type);\n\tif (entries == 0)\n\t\treturn (ARCHIVE_OK);\n\n\n\tswitch (ae_requested_type) {\n\tcase ARCHIVE_ENTRY_ACL_TYPE_ACCESS:\n\t\tacl_type = ACL_TYPE_ACCESS;\n\t\tbreak;\n\tcase ARCHIVE_ENTRY_ACL_TYPE_DEFAULT:\n\t\tacl_type = ACL_TYPE_DEFAULT;\n\t\tbreak;\n#if ARCHIVE_ACL_FREEBSD_NFS4\n\tcase ARCHIVE_ENTRY_ACL_TYPE_NFS4:\n\t\tacl_type = ACL_TYPE_NFS4;\n\t\tbreak;\n#endif\n\tdefault:\n\t\terrno = ENOENT;\n\t\tarchive_set_error(a, errno, \"Unsupported ACL type\");\n\t\treturn (ARCHIVE_FAILED);\n\t}\n\n\tif (acl_type == ACL_TYPE_DEFAULT && !S_ISDIR(mode)) {\n\t\terrno = EINVAL;\n\t\tarchive_set_error(a, errno,\n\t\t    \"Cannot set default ACL on non-directory\");\n\t\treturn (ARCHIVE_WARN);\n\t}\n\n\tacl = acl_init(entries);\n\tif (acl == (acl_t)NULL) {\n\t\tarchive_set_error(a, errno,\n\t\t    \"Failed to initialize ACL working storage\");\n\t\treturn (ARCHIVE_FAILED);\n\t}\n\n\twhile (archive_acl_next(a, abstract_acl, ae_requested_type, &ae_type,\n\t\t   &ae_permset, &ae_tag, &ae_id, &ae_name) == ARCHIVE_OK) {\n\t\tif (acl_create_entry(&acl, &acl_entry) != 0) {\n\t\t\tarchive_set_error(a, errno,\n\t\t\t    \"Failed to create a new ACL entry\");\n\t\t\tret = ARCHIVE_FAILED;\n\t\t\tgoto exit_free;\n\t\t}\n\t\tswitch (ae_tag) {\n\t\tcase ARCHIVE_ENTRY_ACL_USER:\n\t\t\tae_uid = archive_write_disk_uid(a, ae_name, ae_id);\n\t\t\tacl_set_tag_type(acl_entry, ACL_USER);\n\t\t\tacl_set_qualifier(acl_entry, &ae_uid);\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_GROUP:\n\t\t\tae_gid = archive_write_disk_gid(a, ae_name, ae_id);\n\t\t\tacl_set_tag_type(acl_entry, ACL_GROUP);\n\t\t\tacl_set_qualifier(acl_entry, &ae_gid);\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_USER_OBJ:\n\t\t\tacl_set_tag_type(acl_entry, ACL_USER_OBJ);\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_GROUP_OBJ:\n\t\t\tacl_set_tag_type(acl_entry, ACL_GROUP_OBJ);\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_MASK:\n\t\t\tacl_set_tag_type(acl_entry, ACL_MASK);\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_OTHER:\n\t\t\tacl_set_tag_type(acl_entry, ACL_OTHER);\n\t\t\tbreak;\n#if ARCHIVE_ACL_FREEBSD_NFS4\n\t\tcase ARCHIVE_ENTRY_ACL_EVERYONE:\n\t\t\tacl_set_tag_type(acl_entry, ACL_EVERYONE);\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_MISC,\n\t\t\t    \"Unsupported ACL tag\");\n\t\t\tret = ARCHIVE_FAILED;\n\t\t\tgoto exit_free;\n\t\t}\n\n#if ARCHIVE_ACL_FREEBSD_NFS4\n\t\tr = 0;\n\t\tswitch (ae_type) {\n\t\tcase ARCHIVE_ENTRY_ACL_TYPE_ALLOW:\n\t\t\tr = acl_set_entry_type_np(acl_entry,\n\t\t\t    ACL_ENTRY_TYPE_ALLOW);\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_TYPE_DENY:\n\t\t\tr = acl_set_entry_type_np(acl_entry,\n\t\t\t    ACL_ENTRY_TYPE_DENY);\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_TYPE_AUDIT:\n\t\t\tr = acl_set_entry_type_np(acl_entry,\n\t\t\t    ACL_ENTRY_TYPE_AUDIT);\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_TYPE_ALARM:\n\t\t\tr = acl_set_entry_type_np(acl_entry,\n\t\t\t    ACL_ENTRY_TYPE_ALARM);\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_TYPE_ACCESS:\n\t\tcase ARCHIVE_ENTRY_ACL_TYPE_DEFAULT:\n\t\t\t// These don't translate directly into the system ACL.\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_MISC,\n\t\t\t    \"Unsupported ACL entry type\");\n\t\t\tret = ARCHIVE_FAILED;\n\t\t\tgoto exit_free;\n\t\t}\n\n\t\tif (r != 0) {\n\t\t\tarchive_set_error(a, errno,\n\t\t\t    \"Failed to set ACL entry type\");\n\t\t\tret = ARCHIVE_FAILED;\n\t\t\tgoto exit_free;\n\t\t}\n#endif\n\n\t\tif (acl_get_permset(acl_entry, &acl_permset) != 0) {\n\t\t\tarchive_set_error(a, errno,\n\t\t\t    \"Failed to get ACL permission set\");\n\t\t\tret = ARCHIVE_FAILED;\n\t\t\tgoto exit_free;\n\t\t}\n\t\tif (acl_clear_perms(acl_permset) != 0) {\n\t\t\tarchive_set_error(a, errno,\n\t\t\t    \"Failed to clear ACL permissions\");\n\t\t\tret = ARCHIVE_FAILED;\n\t\t\tgoto exit_free;\n\t\t}\n#if ARCHIVE_ACL_FREEBSD_NFS4\n\t\tif (ae_requested_type == ARCHIVE_ENTRY_ACL_TYPE_NFS4) {\n\t\t\tperm_map_size = acl_nfs4_perm_map_size;\n\t\t\tperm_map = acl_nfs4_perm_map;\n\t\t} else {\n#endif\n\t\t\tperm_map_size = acl_posix_perm_map_size;\n\t\t\tperm_map = acl_posix_perm_map;\n#if ARCHIVE_ACL_FREEBSD_NFS4\n\t\t}\n#endif\n\n\t\tfor (i = 0; i < perm_map_size; ++i) {\n\t\t\tif (ae_permset & perm_map[i].a_perm) {\n\t\t\t\tif (acl_add_perm(acl_permset,\n\t\t\t\t    perm_map[i].p_perm) != 0) {\n\t\t\t\t\tarchive_set_error(a, errno,\n\t\t\t\t\t    \"Failed to add ACL permission\");\n\t\t\t\t\tret = ARCHIVE_FAILED;\n\t\t\t\t\tgoto exit_free;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n#if ARCHIVE_ACL_FREEBSD_NFS4\n\t\tif (ae_requested_type == ARCHIVE_ENTRY_ACL_TYPE_NFS4) {\n\t\t\t/*\n\t\t\t * acl_get_flagset_np() fails with non-NFSv4 ACLs\n\t\t\t */\n\t\t\tif (acl_get_flagset_np(acl_entry, &acl_flagset) != 0) {\n\t\t\t\tarchive_set_error(a, errno,\n\t\t\t\t    \"Failed to get flagset from an NFSv4 \"\n\t\t\t\t    \"ACL entry\");\n\t\t\t\tret = ARCHIVE_FAILED;\n\t\t\t\tgoto exit_free;\n\t\t\t}\n\t\t\tif (acl_clear_flags_np(acl_flagset) != 0) {\n\t\t\t\tarchive_set_error(a, errno,\n\t\t\t\t    \"Failed to clear flags from an NFSv4 \"\n\t\t\t\t    \"ACL flagset\");\n\t\t\t\tret = ARCHIVE_FAILED;\n\t\t\t\tgoto exit_free;\n\t\t\t}\n\t\t\tfor (i = 0; i < acl_nfs4_flag_map_size; ++i) {\n\t\t\t\tif (ae_permset & acl_nfs4_flag_map[i].a_perm) {\n\t\t\t\t\tif (acl_add_flag_np(acl_flagset,\n\t\t\t\t\t    acl_nfs4_flag_map[i].p_perm) != 0) {\n\t\t\t\t\t\tarchive_set_error(a, errno,\n\t\t\t\t\t\t    \"Failed to add flag to \"\n\t\t\t\t\t\t    \"NFSv4 ACL flagset\");\n\t\t\t\t\t\tret = ARCHIVE_FAILED;\n\t\t\t\t\t\tgoto exit_free;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n#endif\n\t}\n\n\t/* Try restoring the ACL through 'fd' if we can. */\n\tif (fd >= 0) {\n\t\tif (acl_set_fd_np(fd, acl, acl_type) == 0)\n\t\t\tret = ARCHIVE_OK;\n\t\telse {\n\t\t\tif (errno == EOPNOTSUPP) {\n\t\t\t\t/* Filesystem doesn't support ACLs */\n\t\t\t\tret = ARCHIVE_OK;\n\t\t\t} else {\n\t\t\t\tarchive_set_error(a, errno,\n\t\t\t\t    \"Failed to set acl on fd: %s\", tname);\n\t\t\t\tret = ARCHIVE_WARN;\n\t\t\t}\n\t\t}\n\t}\n#if HAVE_ACL_SET_LINK_NP\n\telse if (acl_set_link_np(name, acl_type, acl) != 0)\n#else\n\t/* FreeBSD older than 8.0 */\n\telse if (S_ISLNK(mode)) {\n\t    /* acl_set_file() follows symbolic links, skip */\n\t    ret = ARCHIVE_OK;\n\t} else if (acl_set_file(name, acl_type, acl) != 0)\n#endif\n\t{\n\t\tif (errno == EOPNOTSUPP) {\n\t\t\t/* Filesystem doesn't support ACLs */\n\t\t\tret = ARCHIVE_OK;\n\t\t} else {\n\t\t\tarchive_set_error(a, errno, \"Failed to set acl: %s\",\n\t\t\t    tname);\n\t\t\tret = ARCHIVE_WARN;\n\t\t}\n\t}\nexit_free:\n\tacl_free(acl);\n\treturn (ret);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,6 @@\n static int\n set_acl(struct archive *a, int fd, const char *name,\n-    struct archive_acl *abstract_acl,\n+    struct archive_acl *abstract_acl, __LA_MODE_T mode,\n     int ae_requested_type, const char *tname)\n {\n \tint\t\t acl_type = 0;\n@@ -43,6 +43,13 @@\n \t\terrno = ENOENT;\n \t\tarchive_set_error(a, errno, \"Unsupported ACL type\");\n \t\treturn (ARCHIVE_FAILED);\n+\t}\n+\n+\tif (acl_type == ACL_TYPE_DEFAULT && !S_ISDIR(mode)) {\n+\t\terrno = EINVAL;\n+\t\tarchive_set_error(a, errno,\n+\t\t    \"Cannot set default ACL on non-directory\");\n+\t\treturn (ARCHIVE_WARN);\n \t}\n \n \tacl = acl_init(entries);\n@@ -223,7 +230,10 @@\n \telse if (acl_set_link_np(name, acl_type, acl) != 0)\n #else\n \t/* FreeBSD older than 8.0 */\n-\telse if (acl_set_file(name, acl_type, acl) != 0)\n+\telse if (S_ISLNK(mode)) {\n+\t    /* acl_set_file() follows symbolic links, skip */\n+\t    ret = ARCHIVE_OK;\n+\t} else if (acl_set_file(name, acl_type, acl) != 0)\n #endif\n \t{\n \t\tif (errno == EOPNOTSUPP) {",
        "diff_line_info": {
            "deleted_lines": [
                "    struct archive_acl *abstract_acl,",
                "\telse if (acl_set_file(name, acl_type, acl) != 0)"
            ],
            "added_lines": [
                "    struct archive_acl *abstract_acl, __LA_MODE_T mode,",
                "\t}",
                "",
                "\tif (acl_type == ACL_TYPE_DEFAULT && !S_ISDIR(mode)) {",
                "\t\terrno = EINVAL;",
                "\t\tarchive_set_error(a, errno,",
                "\t\t    \"Cannot set default ACL on non-directory\");",
                "\t\treturn (ARCHIVE_WARN);",
                "\telse if (S_ISLNK(mode)) {",
                "\t    /* acl_set_file() follows symbolic links, skip */",
                "\t    ret = ARCHIVE_OK;",
                "\t} else if (acl_set_file(name, acl_type, acl) != 0)"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-23177",
        "func_name": "libarchive/set_acl",
        "description": "An improper link resolution flaw while extracting an archive can lead to changing the access control list (ACL) of the target of the link. An attacker may provide a malicious archive to a victim user, who would trigger this flaw when trying to extract the archive. A local attacker may use this flaw to change the ACL of a file on the system and gain more privileges.",
        "git_url": "https://github.com/libarchive/libarchive/commit/fba4f123cc456d2b2538f811bb831483bf336bad",
        "commit_title": "Fix handling of symbolic link ACLs",
        "commit_text": " On Linux ACLs on symbolic links are not supported. We must avoid calling acl_set_file() on symbolic links as their targets are modified instead.  While here, do not try to set default ACLs on non-directories.  Fixes #1565",
        "func_before": "static int\nset_acl(struct archive *a, int fd, const char *name,\n    struct archive_acl *abstract_acl,\n    int ae_requested_type, const char *tname)\n{\n\taclent_t\t *aclent;\n#if ARCHIVE_ACL_SUNOS_NFS4\n\tace_t\t\t *ace;\n#endif\n\tint\t\t cmd, e, r;\n\tvoid\t\t *aclp;\n\tint\t\t ret;\n\tint\t\t ae_type, ae_permset, ae_tag, ae_id;\n\tint\t\t perm_map_size;\n\tconst acl_perm_map_t\t*perm_map;\n\tuid_t\t\t ae_uid;\n\tgid_t\t\t ae_gid;\n\tconst char\t*ae_name;\n\tint\t\t entries;\n\tint\t\t i;\n\n\tret = ARCHIVE_OK;\n\tentries = archive_acl_reset(abstract_acl, ae_requested_type);\n\tif (entries == 0)\n\t\treturn (ARCHIVE_OK);\n\n\n\tswitch (ae_requested_type) {\n\tcase ARCHIVE_ENTRY_ACL_TYPE_POSIX1E:\n\t\tcmd = SETACL;\n\t\taclp = malloc(entries * sizeof(aclent_t));\n\t\tbreak;\n#if ARCHIVE_ACL_SUNOS_NFS4\n\tcase ARCHIVE_ENTRY_ACL_TYPE_NFS4:\n\t\tcmd = ACE_SETACL;\n\t\taclp = malloc(entries * sizeof(ace_t));\n\n\t\tbreak;\n#endif\n\tdefault:\n\t\terrno = ENOENT;\n\t\tarchive_set_error(a, errno, \"Unsupported ACL type\");\n\t\treturn (ARCHIVE_FAILED);\n\t}\n\n\tif (aclp == NULL) {\n\t\tarchive_set_error(a, errno,\n\t\t    \"Can't allocate memory for acl buffer\");\n\t\treturn (ARCHIVE_FAILED);\n\t}\n\n\te = 0;\n\n\twhile (archive_acl_next(a, abstract_acl, ae_requested_type, &ae_type,\n\t\t   &ae_permset, &ae_tag, &ae_id, &ae_name) == ARCHIVE_OK) {\n\t\taclent = NULL;\n#if ARCHIVE_ACL_SUNOS_NFS4\n\t\tace = NULL;\n#endif\n\t\tif (cmd == SETACL) {\n\t\t\taclent = &((aclent_t *)aclp)[e];\n\t\t\taclent->a_id = -1;\n\t\t\taclent->a_type = 0;\n\t\t\taclent->a_perm = 0;\n\t\t}\n#if ARCHIVE_ACL_SUNOS_NFS4\n\t\telse {\t/* cmd == ACE_SETACL */\n\t\t\tace = &((ace_t *)aclp)[e];\n\t\t\tace->a_who = -1;\n\t\t\tace->a_access_mask = 0;\n\t\t\tace->a_flags = 0;\n\t\t}\n#endif\t/* ARCHIVE_ACL_SUNOS_NFS4 */\n\n\t\tswitch (ae_tag) {\n\t\tcase ARCHIVE_ENTRY_ACL_USER:\n\t\t\tae_uid = archive_write_disk_uid(a, ae_name, ae_id);\n\t\t\tif (aclent != NULL) {\n\t\t\t\taclent->a_id = ae_uid;\n\t\t\t\taclent->a_type |= USER;\n\t\t\t}\n#if ARCHIVE_ACL_SUNOS_NFS4\n\t\t\telse {\n\t\t\t\tace->a_who = ae_uid;\n\t\t\t}\n#endif\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_GROUP:\n\t\t\tae_gid = archive_write_disk_gid(a, ae_name, ae_id);\n\t\t\tif (aclent != NULL) {\n\t\t\t\taclent->a_id = ae_gid;\n\t\t\t\taclent->a_type |= GROUP;\n\t\t\t}\n#if ARCHIVE_ACL_SUNOS_NFS4\n\t\t\telse {\n\t\t\t\tace->a_who = ae_gid;\n\t\t\t\tace->a_flags |= ACE_IDENTIFIER_GROUP;\n\t\t\t}\n#endif\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_USER_OBJ:\n\t\t\tif (aclent != NULL)\n\t\t\t\taclent->a_type |= USER_OBJ;\n#if ARCHIVE_ACL_SUNOS_NFS4\n\t\t\telse {\n\t\t\t\tace->a_flags |= ACE_OWNER;\n\t\t\t}\n#endif\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_GROUP_OBJ:\n\t\t\tif (aclent != NULL)\n\t\t\t\taclent->a_type |= GROUP_OBJ;\n#if ARCHIVE_ACL_SUNOS_NFS4\n\t\t\telse {\n\t\t\t\tace->a_flags |= ACE_GROUP;\n\t\t\t\tace->a_flags |= ACE_IDENTIFIER_GROUP;\n\t\t\t}\n#endif\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_MASK:\n\t\t\tif (aclent != NULL)\n\t\t\t\taclent->a_type |= CLASS_OBJ;\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_OTHER:\n\t\t\tif (aclent != NULL)\n\t\t\t\taclent->a_type |= OTHER_OBJ;\n\t\t\tbreak;\n#if ARCHIVE_ACL_SUNOS_NFS4\n\t\tcase ARCHIVE_ENTRY_ACL_EVERYONE:\n\t\t\tif (ace != NULL)\n\t\t\t\tace->a_flags |= ACE_EVERYONE;\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_MISC,\n\t\t\t    \"Unsupported ACL tag\");\n\t\t\tret = ARCHIVE_FAILED;\n\t\t\tgoto exit_free;\n\t\t}\n\n\t\tr = 0;\n\t\tswitch (ae_type) {\n#if ARCHIVE_ACL_SUNOS_NFS4\n\t\tcase ARCHIVE_ENTRY_ACL_TYPE_ALLOW:\n\t\t\tif (ace != NULL)\n\t\t\t\tace->a_type = ACE_ACCESS_ALLOWED_ACE_TYPE;\n\t\t\telse\n\t\t\t\tr = -1;\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_TYPE_DENY:\n\t\t\tif (ace != NULL)\n\t\t\t\tace->a_type = ACE_ACCESS_DENIED_ACE_TYPE;\n\t\t\telse\n\t\t\t\tr = -1;\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_TYPE_AUDIT:\n\t\t\tif (ace != NULL)\n\t\t\t\tace->a_type = ACE_SYSTEM_AUDIT_ACE_TYPE;\n\t\t\telse\n\t\t\t\tr = -1;\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_TYPE_ALARM:\n\t\t\tif (ace != NULL)\n\t\t\t\tace->a_type = ACE_SYSTEM_ALARM_ACE_TYPE;\n\t\t\telse\n\t\t\t\tr = -1;\n\t\t\tbreak;\n#endif\n\t\tcase ARCHIVE_ENTRY_ACL_TYPE_ACCESS:\n\t\t\tif (aclent == NULL)\n\t\t\t\tr = -1;\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_TYPE_DEFAULT:\n\t\t\tif (aclent != NULL)\n\t\t\t\taclent->a_type |= ACL_DEFAULT;\n\t\t\telse\n\t\t\t\tr = -1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_MISC,\n\t\t\t    \"Unsupported ACL entry type\");\n\t\t\tret = ARCHIVE_FAILED;\n\t\t\tgoto exit_free;\n\t\t}\n\n\t\tif (r != 0) {\n\t\t\terrno = EINVAL;\n\t\t\tarchive_set_error(a, errno,\n\t\t\t    \"Failed to set ACL entry type\");\n\t\t\tret = ARCHIVE_FAILED;\n\t\t\tgoto exit_free;\n\t\t}\n\n#if ARCHIVE_ACL_SUNOS_NFS4\n\t\tif (ae_requested_type == ARCHIVE_ENTRY_ACL_TYPE_NFS4) {\n\t\t\tperm_map_size = acl_nfs4_perm_map_size;\n\t\t\tperm_map = acl_nfs4_perm_map;\n\t\t} else {\n#endif\n\t\t\tperm_map_size = acl_posix_perm_map_size;\n\t\t\tperm_map = acl_posix_perm_map;\n#if ARCHIVE_ACL_SUNOS_NFS4\n\t\t}\n#endif\n\t\tfor (i = 0; i < perm_map_size; ++i) {\n\t\t\tif (ae_permset & perm_map[i].a_perm) {\n#if ARCHIVE_ACL_SUNOS_NFS4\n\t\t\t\tif (ae_requested_type ==\n\t\t\t\t    ARCHIVE_ENTRY_ACL_TYPE_NFS4)\n\t\t\t\t\tace->a_access_mask |=\n\t\t\t\t\t    perm_map[i].p_perm;\n\t\t\t\telse\n#endif\n\t\t\t\t\taclent->a_perm |= perm_map[i].p_perm;\n\t\t\t}\n\t\t}\n\n#if ARCHIVE_ACL_SUNOS_NFS4\n\t\tif (ae_requested_type == ARCHIVE_ENTRY_ACL_TYPE_NFS4) {\n\t\t\tfor (i = 0; i < acl_nfs4_flag_map_size; ++i) {\n\t\t\t\tif (ae_permset & acl_nfs4_flag_map[i].a_perm) {\n\t\t\t\t\tace->a_flags |=\n\t\t\t\t\t    acl_nfs4_flag_map[i].p_perm;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n#endif\n\te++;\n\t}\n\n\t/* Try restoring the ACL through 'fd' if we can. */\n\tif (fd >= 0) {\n\t\tif (facl(fd, cmd, entries, aclp) == 0)\n\t\t\tret = ARCHIVE_OK;\n\t\telse {\n\t\t\tif (errno == EOPNOTSUPP) {\n\t\t\t\t/* Filesystem doesn't support ACLs */\n\t\t\t\tret = ARCHIVE_OK;\n\t\t\t} else {\n\t\t\t\tarchive_set_error(a, errno,\n\t\t\t\t    \"Failed to set acl on fd: %s\", tname);\n\t\t\t\tret = ARCHIVE_WARN;\n\t\t\t}\n\t\t}\n\t} else if (acl(name, cmd, entries, aclp) != 0) {\n\t\tif (errno == EOPNOTSUPP) {\n\t\t\t/* Filesystem doesn't support ACLs */\n\t\t\tret = ARCHIVE_OK;\n\t\t} else {\n\t\t\tarchive_set_error(a, errno, \"Failed to set acl: %s\",\n\t\t\t    tname);\n\t\t\tret = ARCHIVE_WARN;\n\t\t}\n\t}\nexit_free:\n\tfree(aclp);\n\treturn (ret);\n}",
        "func": "static int\nset_acl(struct archive *a, int fd, const char *name,\n    struct archive_acl *abstract_acl, __LA_MODE_T mode,\n    int ae_requested_type, const char *tname)\n{\n\taclent_t\t *aclent;\n#if ARCHIVE_ACL_SUNOS_NFS4\n\tace_t\t\t *ace;\n#endif\n\tint\t\t cmd, e, r;\n\tvoid\t\t *aclp;\n\tint\t\t ret;\n\tint\t\t ae_type, ae_permset, ae_tag, ae_id;\n\tint\t\t perm_map_size;\n\tconst acl_perm_map_t\t*perm_map;\n\tuid_t\t\t ae_uid;\n\tgid_t\t\t ae_gid;\n\tconst char\t*ae_name;\n\tint\t\t entries;\n\tint\t\t i;\n\n\tret = ARCHIVE_OK;\n\tentries = archive_acl_reset(abstract_acl, ae_requested_type);\n\tif (entries == 0)\n\t\treturn (ARCHIVE_OK);\n\n\tswitch (ae_requested_type) {\n\tcase ARCHIVE_ENTRY_ACL_TYPE_POSIX1E:\n\t\tcmd = SETACL;\n\t\taclp = malloc(entries * sizeof(aclent_t));\n\t\tbreak;\n#if ARCHIVE_ACL_SUNOS_NFS4\n\tcase ARCHIVE_ENTRY_ACL_TYPE_NFS4:\n\t\tcmd = ACE_SETACL;\n\t\taclp = malloc(entries * sizeof(ace_t));\n\n\t\tbreak;\n#endif\n\tdefault:\n\t\terrno = ENOENT;\n\t\tarchive_set_error(a, errno, \"Unsupported ACL type\");\n\t\treturn (ARCHIVE_FAILED);\n\t}\n\n\tif (aclp == NULL) {\n\t\tarchive_set_error(a, errno,\n\t\t    \"Can't allocate memory for acl buffer\");\n\t\treturn (ARCHIVE_FAILED);\n\t}\n\n        if (S_ISLNK(mode)) {\n                /* Skip ACLs on symbolic links */\n\t\tret = ARCHIVE_OK;\n\t\tgoto exit_free;\n        }\n\n\te = 0;\n\n\twhile (archive_acl_next(a, abstract_acl, ae_requested_type, &ae_type,\n\t\t   &ae_permset, &ae_tag, &ae_id, &ae_name) == ARCHIVE_OK) {\n\t\taclent = NULL;\n#if ARCHIVE_ACL_SUNOS_NFS4\n\t\tace = NULL;\n#endif\n\t\tif (cmd == SETACL) {\n\t\t\taclent = &((aclent_t *)aclp)[e];\n\t\t\taclent->a_id = -1;\n\t\t\taclent->a_type = 0;\n\t\t\taclent->a_perm = 0;\n\t\t}\n#if ARCHIVE_ACL_SUNOS_NFS4\n\t\telse {\t/* cmd == ACE_SETACL */\n\t\t\tace = &((ace_t *)aclp)[e];\n\t\t\tace->a_who = -1;\n\t\t\tace->a_access_mask = 0;\n\t\t\tace->a_flags = 0;\n\t\t}\n#endif\t/* ARCHIVE_ACL_SUNOS_NFS4 */\n\n\t\tswitch (ae_tag) {\n\t\tcase ARCHIVE_ENTRY_ACL_USER:\n\t\t\tae_uid = archive_write_disk_uid(a, ae_name, ae_id);\n\t\t\tif (aclent != NULL) {\n\t\t\t\taclent->a_id = ae_uid;\n\t\t\t\taclent->a_type |= USER;\n\t\t\t}\n#if ARCHIVE_ACL_SUNOS_NFS4\n\t\t\telse {\n\t\t\t\tace->a_who = ae_uid;\n\t\t\t}\n#endif\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_GROUP:\n\t\t\tae_gid = archive_write_disk_gid(a, ae_name, ae_id);\n\t\t\tif (aclent != NULL) {\n\t\t\t\taclent->a_id = ae_gid;\n\t\t\t\taclent->a_type |= GROUP;\n\t\t\t}\n#if ARCHIVE_ACL_SUNOS_NFS4\n\t\t\telse {\n\t\t\t\tace->a_who = ae_gid;\n\t\t\t\tace->a_flags |= ACE_IDENTIFIER_GROUP;\n\t\t\t}\n#endif\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_USER_OBJ:\n\t\t\tif (aclent != NULL)\n\t\t\t\taclent->a_type |= USER_OBJ;\n#if ARCHIVE_ACL_SUNOS_NFS4\n\t\t\telse {\n\t\t\t\tace->a_flags |= ACE_OWNER;\n\t\t\t}\n#endif\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_GROUP_OBJ:\n\t\t\tif (aclent != NULL)\n\t\t\t\taclent->a_type |= GROUP_OBJ;\n#if ARCHIVE_ACL_SUNOS_NFS4\n\t\t\telse {\n\t\t\t\tace->a_flags |= ACE_GROUP;\n\t\t\t\tace->a_flags |= ACE_IDENTIFIER_GROUP;\n\t\t\t}\n#endif\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_MASK:\n\t\t\tif (aclent != NULL)\n\t\t\t\taclent->a_type |= CLASS_OBJ;\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_OTHER:\n\t\t\tif (aclent != NULL)\n\t\t\t\taclent->a_type |= OTHER_OBJ;\n\t\t\tbreak;\n#if ARCHIVE_ACL_SUNOS_NFS4\n\t\tcase ARCHIVE_ENTRY_ACL_EVERYONE:\n\t\t\tif (ace != NULL)\n\t\t\t\tace->a_flags |= ACE_EVERYONE;\n\t\t\tbreak;\n#endif\n\t\tdefault:\n\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_MISC,\n\t\t\t    \"Unsupported ACL tag\");\n\t\t\tret = ARCHIVE_FAILED;\n\t\t\tgoto exit_free;\n\t\t}\n\n\t\tr = 0;\n\t\tswitch (ae_type) {\n#if ARCHIVE_ACL_SUNOS_NFS4\n\t\tcase ARCHIVE_ENTRY_ACL_TYPE_ALLOW:\n\t\t\tif (ace != NULL)\n\t\t\t\tace->a_type = ACE_ACCESS_ALLOWED_ACE_TYPE;\n\t\t\telse\n\t\t\t\tr = -1;\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_TYPE_DENY:\n\t\t\tif (ace != NULL)\n\t\t\t\tace->a_type = ACE_ACCESS_DENIED_ACE_TYPE;\n\t\t\telse\n\t\t\t\tr = -1;\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_TYPE_AUDIT:\n\t\t\tif (ace != NULL)\n\t\t\t\tace->a_type = ACE_SYSTEM_AUDIT_ACE_TYPE;\n\t\t\telse\n\t\t\t\tr = -1;\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_TYPE_ALARM:\n\t\t\tif (ace != NULL)\n\t\t\t\tace->a_type = ACE_SYSTEM_ALARM_ACE_TYPE;\n\t\t\telse\n\t\t\t\tr = -1;\n\t\t\tbreak;\n#endif\n\t\tcase ARCHIVE_ENTRY_ACL_TYPE_ACCESS:\n\t\t\tif (aclent == NULL)\n\t\t\t\tr = -1;\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_TYPE_DEFAULT:\n\t\t\tif (aclent != NULL)\n\t\t\t\taclent->a_type |= ACL_DEFAULT;\n\t\t\telse\n\t\t\t\tr = -1;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_MISC,\n\t\t\t    \"Unsupported ACL entry type\");\n\t\t\tret = ARCHIVE_FAILED;\n\t\t\tgoto exit_free;\n\t\t}\n\n\t\tif (r != 0) {\n\t\t\terrno = EINVAL;\n\t\t\tarchive_set_error(a, errno,\n\t\t\t    \"Failed to set ACL entry type\");\n\t\t\tret = ARCHIVE_FAILED;\n\t\t\tgoto exit_free;\n\t\t}\n\n#if ARCHIVE_ACL_SUNOS_NFS4\n\t\tif (ae_requested_type == ARCHIVE_ENTRY_ACL_TYPE_NFS4) {\n\t\t\tperm_map_size = acl_nfs4_perm_map_size;\n\t\t\tperm_map = acl_nfs4_perm_map;\n\t\t} else {\n#endif\n\t\t\tperm_map_size = acl_posix_perm_map_size;\n\t\t\tperm_map = acl_posix_perm_map;\n#if ARCHIVE_ACL_SUNOS_NFS4\n\t\t}\n#endif\n\t\tfor (i = 0; i < perm_map_size; ++i) {\n\t\t\tif (ae_permset & perm_map[i].a_perm) {\n#if ARCHIVE_ACL_SUNOS_NFS4\n\t\t\t\tif (ae_requested_type ==\n\t\t\t\t    ARCHIVE_ENTRY_ACL_TYPE_NFS4)\n\t\t\t\t\tace->a_access_mask |=\n\t\t\t\t\t    perm_map[i].p_perm;\n\t\t\t\telse\n#endif\n\t\t\t\t\taclent->a_perm |= perm_map[i].p_perm;\n\t\t\t}\n\t\t}\n\n#if ARCHIVE_ACL_SUNOS_NFS4\n\t\tif (ae_requested_type == ARCHIVE_ENTRY_ACL_TYPE_NFS4) {\n\t\t\tfor (i = 0; i < acl_nfs4_flag_map_size; ++i) {\n\t\t\t\tif (ae_permset & acl_nfs4_flag_map[i].a_perm) {\n\t\t\t\t\tace->a_flags |=\n\t\t\t\t\t    acl_nfs4_flag_map[i].p_perm;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n#endif\n\te++;\n\t}\n\n\t/* Try restoring the ACL through 'fd' if we can. */\n\tif (fd >= 0) {\n\t\tif (facl(fd, cmd, entries, aclp) == 0)\n\t\t\tret = ARCHIVE_OK;\n\t\telse {\n\t\t\tif (errno == EOPNOTSUPP) {\n\t\t\t\t/* Filesystem doesn't support ACLs */\n\t\t\t\tret = ARCHIVE_OK;\n\t\t\t} else {\n\t\t\t\tarchive_set_error(a, errno,\n\t\t\t\t    \"Failed to set acl on fd: %s\", tname);\n\t\t\t\tret = ARCHIVE_WARN;\n\t\t\t}\n\t\t}\n\t} else if (acl(name, cmd, entries, aclp) != 0) {\n\t\tif (errno == EOPNOTSUPP) {\n\t\t\t/* Filesystem doesn't support ACLs */\n\t\t\tret = ARCHIVE_OK;\n\t\t} else {\n\t\t\tarchive_set_error(a, errno, \"Failed to set acl: %s\",\n\t\t\t    tname);\n\t\t\tret = ARCHIVE_WARN;\n\t\t}\n\t}\nexit_free:\n\tfree(aclp);\n\treturn (ret);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,6 @@\n static int\n set_acl(struct archive *a, int fd, const char *name,\n-    struct archive_acl *abstract_acl,\n+    struct archive_acl *abstract_acl, __LA_MODE_T mode,\n     int ae_requested_type, const char *tname)\n {\n \taclent_t\t *aclent;\n@@ -24,7 +24,6 @@\n \tif (entries == 0)\n \t\treturn (ARCHIVE_OK);\n \n-\n \tswitch (ae_requested_type) {\n \tcase ARCHIVE_ENTRY_ACL_TYPE_POSIX1E:\n \t\tcmd = SETACL;\n@@ -48,6 +47,12 @@\n \t\t    \"Can't allocate memory for acl buffer\");\n \t\treturn (ARCHIVE_FAILED);\n \t}\n+\n+        if (S_ISLNK(mode)) {\n+                /* Skip ACLs on symbolic links */\n+\t\tret = ARCHIVE_OK;\n+\t\tgoto exit_free;\n+        }\n \n \te = 0;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "    struct archive_acl *abstract_acl,",
                ""
            ],
            "added_lines": [
                "    struct archive_acl *abstract_acl, __LA_MODE_T mode,",
                "",
                "        if (S_ISLNK(mode)) {",
                "                /* Skip ACLs on symbolic links */",
                "\t\tret = ARCHIVE_OK;",
                "\t\tgoto exit_free;",
                "        }"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-23177",
        "func_name": "libarchive/archive_write_disk_set_acls",
        "description": "An improper link resolution flaw while extracting an archive can lead to changing the access control list (ACL) of the target of the link. An attacker may provide a malicious archive to a victim user, who would trigger this flaw when trying to extract the archive. A local attacker may use this flaw to change the ACL of a file on the system and gain more privileges.",
        "git_url": "https://github.com/libarchive/libarchive/commit/fba4f123cc456d2b2538f811bb831483bf336bad",
        "commit_title": "Fix handling of symbolic link ACLs",
        "commit_text": " On Linux ACLs on symbolic links are not supported. We must avoid calling acl_set_file() on symbolic links as their targets are modified instead.  While here, do not try to set default ACLs on non-directories.  Fixes #1565",
        "func_before": "int\narchive_write_disk_set_acls(struct archive *a, int fd, const char *name,\n    struct archive_acl *abstract_acl, __LA_MODE_T mode)\n{\n\tint\t\tret = ARCHIVE_OK;\n\n\t(void)mode;\t/* UNUSED */\n\n\tif ((archive_acl_types(abstract_acl)\n\t    & ARCHIVE_ENTRY_ACL_TYPE_POSIX1E) != 0) {\n\t\t/* Solaris writes POSIX.1e access and default ACLs together */\n\t\tret = set_acl(a, fd, name, abstract_acl,\n\t\t    ARCHIVE_ENTRY_ACL_TYPE_POSIX1E, \"posix1e\");\n\n\t\t/* Simultaneous POSIX.1e and NFSv4 is not supported */\n\t\treturn (ret);\n\t}\n#if ARCHIVE_ACL_SUNOS_NFS4\n\telse if ((archive_acl_types(abstract_acl) &\n\t    ARCHIVE_ENTRY_ACL_TYPE_NFS4) != 0) {\n\t\tret = set_acl(a, fd, name, abstract_acl,\n\t\t    ARCHIVE_ENTRY_ACL_TYPE_NFS4, \"nfs4\");\n\t}\n#endif\n\treturn (ret);\n}",
        "func": "int\narchive_write_disk_set_acls(struct archive *a, int fd, const char *name,\n    struct archive_acl *abstract_acl, __LA_MODE_T mode)\n{\n\tint\t\tret = ARCHIVE_OK;\n\n\t(void)mode;\t/* UNUSED */\n\n\tif ((archive_acl_types(abstract_acl)\n\t    & ARCHIVE_ENTRY_ACL_TYPE_POSIX1E) != 0) {\n\t\t/* Solaris writes POSIX.1e access and default ACLs together */\n\t\tret = set_acl(a, fd, name, abstract_acl, mode,\n\t\t    ARCHIVE_ENTRY_ACL_TYPE_POSIX1E, \"posix1e\");\n\n\t\t/* Simultaneous POSIX.1e and NFSv4 is not supported */\n\t\treturn (ret);\n\t}\n#if ARCHIVE_ACL_SUNOS_NFS4\n\telse if ((archive_acl_types(abstract_acl) &\n\t    ARCHIVE_ENTRY_ACL_TYPE_NFS4) != 0) {\n\t\tret = set_acl(a, fd, name, abstract_acl, mode,\n\t\t    ARCHIVE_ENTRY_ACL_TYPE_NFS4, \"nfs4\");\n\t}\n#endif\n\treturn (ret);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -9,7 +9,7 @@\n \tif ((archive_acl_types(abstract_acl)\n \t    & ARCHIVE_ENTRY_ACL_TYPE_POSIX1E) != 0) {\n \t\t/* Solaris writes POSIX.1e access and default ACLs together */\n-\t\tret = set_acl(a, fd, name, abstract_acl,\n+\t\tret = set_acl(a, fd, name, abstract_acl, mode,\n \t\t    ARCHIVE_ENTRY_ACL_TYPE_POSIX1E, \"posix1e\");\n \n \t\t/* Simultaneous POSIX.1e and NFSv4 is not supported */\n@@ -18,7 +18,7 @@\n #if ARCHIVE_ACL_SUNOS_NFS4\n \telse if ((archive_acl_types(abstract_acl) &\n \t    ARCHIVE_ENTRY_ACL_TYPE_NFS4) != 0) {\n-\t\tret = set_acl(a, fd, name, abstract_acl,\n+\t\tret = set_acl(a, fd, name, abstract_acl, mode,\n \t\t    ARCHIVE_ENTRY_ACL_TYPE_NFS4, \"nfs4\");\n \t}\n #endif",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tret = set_acl(a, fd, name, abstract_acl,",
                "\t\tret = set_acl(a, fd, name, abstract_acl,"
            ],
            "added_lines": [
                "\t\tret = set_acl(a, fd, name, abstract_acl, mode,",
                "\t\tret = set_acl(a, fd, name, abstract_acl, mode,"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-23177",
        "func_name": "libarchive/set_acl",
        "description": "An improper link resolution flaw while extracting an archive can lead to changing the access control list (ACL) of the target of the link. An attacker may provide a malicious archive to a victim user, who would trigger this flaw when trying to extract the archive. A local attacker may use this flaw to change the ACL of a file on the system and gain more privileges.",
        "git_url": "https://github.com/libarchive/libarchive/commit/fba4f123cc456d2b2538f811bb831483bf336bad",
        "commit_title": "Fix handling of symbolic link ACLs",
        "commit_text": " On Linux ACLs on symbolic links are not supported. We must avoid calling acl_set_file() on symbolic links as their targets are modified instead.  While here, do not try to set default ACLs on non-directories.  Fixes #1565",
        "func_before": "static int\nset_acl(struct archive *a, int fd, const char *name,\n    struct archive_acl *abstract_acl,\n    int ae_requested_type, const char *tname)\n{\n\tint\t\t acl_type = 0;\n\tint\t\t ae_type, ae_permset, ae_tag, ae_id;\n\tuid_t\t\t ae_uid;\n\tgid_t\t\t ae_gid;\n\tconst char\t*ae_name;\n\tint\t\t entries;\n\tint\t\t i;\n\tint\t\t ret;\n\tacl_t\t\t acl = NULL;\n\tacl_entry_t\t acl_entry;\n\tacl_permset_t\t acl_permset;\n\n\tret = ARCHIVE_OK;\n\tentries = archive_acl_reset(abstract_acl, ae_requested_type);\n\tif (entries == 0)\n\t\treturn (ARCHIVE_OK);\n\n\tswitch (ae_requested_type) {\n\tcase ARCHIVE_ENTRY_ACL_TYPE_ACCESS:\n\t\tacl_type = ACL_TYPE_ACCESS;\n\t\tbreak;\n\tcase ARCHIVE_ENTRY_ACL_TYPE_DEFAULT:\n\t\tacl_type = ACL_TYPE_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\terrno = ENOENT;\n\t\tarchive_set_error(a, errno, \"Unsupported ACL type\");\n\t\treturn (ARCHIVE_FAILED);\n\t}\n\n\tacl = acl_init(entries);\n\tif (acl == (acl_t)NULL) {\n\t\tarchive_set_error(a, errno,\n\t\t    \"Failed to initialize ACL working storage\");\n\t\treturn (ARCHIVE_FAILED);\n\t}\n\n\twhile (archive_acl_next(a, abstract_acl, ae_requested_type, &ae_type,\n\t\t   &ae_permset, &ae_tag, &ae_id, &ae_name) == ARCHIVE_OK) {\n\n\t\tif (acl_create_entry(&acl, &acl_entry) != 0) {\n\t\t\tarchive_set_error(a, errno,\n\t\t\t    \"Failed to create a new ACL entry\");\n\t\t\tret = ARCHIVE_FAILED;\n\t\t\tgoto exit_free;\n\t\t}\n\n\t\tswitch (ae_tag) {\n\t\tcase ARCHIVE_ENTRY_ACL_USER:\n\t\t\tae_uid = archive_write_disk_uid(a, ae_name, ae_id);\n\t\t\tacl_set_tag_type(acl_entry, ACL_USER);\n\t\t\tacl_set_qualifier(acl_entry, &ae_uid);\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_GROUP:\n\t\t\tae_gid = archive_write_disk_gid(a, ae_name, ae_id);\n\t\t\tacl_set_tag_type(acl_entry, ACL_GROUP);\n\t\t\tacl_set_qualifier(acl_entry, &ae_gid);\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_USER_OBJ:\n\t\t\tacl_set_tag_type(acl_entry, ACL_USER_OBJ);\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_GROUP_OBJ:\n\t\t\tacl_set_tag_type(acl_entry, ACL_GROUP_OBJ);\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_MASK:\n\t\t\tacl_set_tag_type(acl_entry, ACL_MASK);\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_OTHER:\n\t\t\tacl_set_tag_type(acl_entry, ACL_OTHER);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_MISC,\n\t\t\t    \"Unsupported ACL tag\");\n\t\t\tret = ARCHIVE_FAILED;\n\t\t\tgoto exit_free;\n\t\t}\n\n\t\tif (acl_get_permset(acl_entry, &acl_permset) != 0) {\n\t\t\tarchive_set_error(a, errno,\n\t\t\t    \"Failed to get ACL permission set\");\n\t\t\tret = ARCHIVE_FAILED;\n\t\t\tgoto exit_free;\n\t\t}\n\t\tif (acl_clear_perms(acl_permset) != 0) {\n\t\t\tarchive_set_error(a, errno,\n\t\t\t    \"Failed to clear ACL permissions\");\n\t\t\tret = ARCHIVE_FAILED;\n\t\t\tgoto exit_free;\n\t\t}\n\n\t\tfor (i = 0; i < acl_posix_perm_map_size; ++i) {\n\t\t\tif (ae_permset & acl_posix_perm_map[i].a_perm) {\n\t\t\t\tif (acl_add_perm(acl_permset,\n\t\t\t\t    acl_posix_perm_map[i].p_perm) != 0) {\n\t\t\t\t\tarchive_set_error(a, errno,\n\t\t\t\t\t    \"Failed to add ACL permission\");\n\t\t\t\t\tret = ARCHIVE_FAILED;\n\t\t\t\t\tgoto exit_free;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\tif (fd >= 0 && ae_requested_type == ARCHIVE_ENTRY_ACL_TYPE_ACCESS) {\n\t\tif (acl_set_fd(fd, acl) == 0)\n\t\t\tret = ARCHIVE_OK;\n\t\telse {\n\t\t\tif (errno == EOPNOTSUPP) {\n\t\t\t\t/* Filesystem doesn't support ACLs */\n\t\t\t\tret = ARCHIVE_OK;\n\t\t\t} else {\n\t\t\t\tarchive_set_error(a, errno,\n\t\t\t\t    \"Failed to set acl on fd: %s\", tname);\n\t\t\t\tret = ARCHIVE_WARN;\n\t\t\t}\n\t\t}\n\t} else if (acl_set_file(name, acl_type, acl) != 0) {\n\t\tif (errno == EOPNOTSUPP) {\n\t\t\t/* Filesystem doesn't support ACLs */\n\t\t\tret = ARCHIVE_OK;\n\t\t} else {\n\t\t\tarchive_set_error(a, errno, \"Failed to set acl: %s\",\n\t\t\t    tname);\n\t\t\tret = ARCHIVE_WARN;\n\t\t}\n\t}\nexit_free:\n\tacl_free(acl);\n\treturn (ret);\n}",
        "func": "static int\nset_acl(struct archive *a, int fd, const char *name,\n    struct archive_acl *abstract_acl, __LA_MODE_T mode,\n    int ae_requested_type, const char *tname)\n{\n\tint\t\t acl_type = 0;\n\tint\t\t ae_type, ae_permset, ae_tag, ae_id;\n\tuid_t\t\t ae_uid;\n\tgid_t\t\t ae_gid;\n\tconst char\t*ae_name;\n\tint\t\t entries;\n\tint\t\t i;\n\tint\t\t ret;\n\tacl_t\t\t acl = NULL;\n\tacl_entry_t\t acl_entry;\n\tacl_permset_t\t acl_permset;\n\n\tret = ARCHIVE_OK;\n\tentries = archive_acl_reset(abstract_acl, ae_requested_type);\n\tif (entries == 0)\n\t\treturn (ARCHIVE_OK);\n\n\tswitch (ae_requested_type) {\n\tcase ARCHIVE_ENTRY_ACL_TYPE_ACCESS:\n\t\tacl_type = ACL_TYPE_ACCESS;\n\t\tbreak;\n\tcase ARCHIVE_ENTRY_ACL_TYPE_DEFAULT:\n\t\tacl_type = ACL_TYPE_DEFAULT;\n\t\tbreak;\n\tdefault:\n\t\terrno = ENOENT;\n\t\tarchive_set_error(a, errno, \"Unsupported ACL type\");\n\t\treturn (ARCHIVE_FAILED);\n\t}\n\n\tif (S_ISLNK(mode)) {\n\t\t/* Linux does not support ACLs on symbolic links */\n\t\treturn (ARCHIVE_OK);\n\t}\n\n\tif (acl_type == ACL_TYPE_DEFAULT && !S_ISDIR(mode)) {\n\t\terrno = EINVAL;\n\t\tarchive_set_error(a, errno,\n\t\t    \"Cannot set default ACL on non-directory\");\n\t\treturn (ARCHIVE_WARN);\n\t}\n\n\tacl = acl_init(entries);\n\tif (acl == (acl_t)NULL) {\n\t\tarchive_set_error(a, errno,\n\t\t    \"Failed to initialize ACL working storage\");\n\t\treturn (ARCHIVE_FAILED);\n\t}\n\n\twhile (archive_acl_next(a, abstract_acl, ae_requested_type, &ae_type,\n\t\t   &ae_permset, &ae_tag, &ae_id, &ae_name) == ARCHIVE_OK) {\n\n\t\tif (acl_create_entry(&acl, &acl_entry) != 0) {\n\t\t\tarchive_set_error(a, errno,\n\t\t\t    \"Failed to create a new ACL entry\");\n\t\t\tret = ARCHIVE_FAILED;\n\t\t\tgoto exit_free;\n\t\t}\n\n\t\tswitch (ae_tag) {\n\t\tcase ARCHIVE_ENTRY_ACL_USER:\n\t\t\tae_uid = archive_write_disk_uid(a, ae_name, ae_id);\n\t\t\tacl_set_tag_type(acl_entry, ACL_USER);\n\t\t\tacl_set_qualifier(acl_entry, &ae_uid);\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_GROUP:\n\t\t\tae_gid = archive_write_disk_gid(a, ae_name, ae_id);\n\t\t\tacl_set_tag_type(acl_entry, ACL_GROUP);\n\t\t\tacl_set_qualifier(acl_entry, &ae_gid);\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_USER_OBJ:\n\t\t\tacl_set_tag_type(acl_entry, ACL_USER_OBJ);\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_GROUP_OBJ:\n\t\t\tacl_set_tag_type(acl_entry, ACL_GROUP_OBJ);\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_MASK:\n\t\t\tacl_set_tag_type(acl_entry, ACL_MASK);\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_OTHER:\n\t\t\tacl_set_tag_type(acl_entry, ACL_OTHER);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_MISC,\n\t\t\t    \"Unsupported ACL tag\");\n\t\t\tret = ARCHIVE_FAILED;\n\t\t\tgoto exit_free;\n\t\t}\n\n\t\tif (acl_get_permset(acl_entry, &acl_permset) != 0) {\n\t\t\tarchive_set_error(a, errno,\n\t\t\t    \"Failed to get ACL permission set\");\n\t\t\tret = ARCHIVE_FAILED;\n\t\t\tgoto exit_free;\n\t\t}\n\t\tif (acl_clear_perms(acl_permset) != 0) {\n\t\t\tarchive_set_error(a, errno,\n\t\t\t    \"Failed to clear ACL permissions\");\n\t\t\tret = ARCHIVE_FAILED;\n\t\t\tgoto exit_free;\n\t\t}\n\n\t\tfor (i = 0; i < acl_posix_perm_map_size; ++i) {\n\t\t\tif (ae_permset & acl_posix_perm_map[i].a_perm) {\n\t\t\t\tif (acl_add_perm(acl_permset,\n\t\t\t\t    acl_posix_perm_map[i].p_perm) != 0) {\n\t\t\t\t\tarchive_set_error(a, errno,\n\t\t\t\t\t    \"Failed to add ACL permission\");\n\t\t\t\t\tret = ARCHIVE_FAILED;\n\t\t\t\t\tgoto exit_free;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\tif (fd >= 0 && ae_requested_type == ARCHIVE_ENTRY_ACL_TYPE_ACCESS) {\n\t\tif (acl_set_fd(fd, acl) == 0)\n\t\t\tret = ARCHIVE_OK;\n\t\telse {\n\t\t\tif (errno == EOPNOTSUPP) {\n\t\t\t\t/* Filesystem doesn't support ACLs */\n\t\t\t\tret = ARCHIVE_OK;\n\t\t\t} else {\n\t\t\t\tarchive_set_error(a, errno,\n\t\t\t\t    \"Failed to set acl on fd: %s\", tname);\n\t\t\t\tret = ARCHIVE_WARN;\n\t\t\t}\n\t\t}\n\t} else if (acl_set_file(name, acl_type, acl) != 0) {\n\t\tif (errno == EOPNOTSUPP) {\n\t\t\t/* Filesystem doesn't support ACLs */\n\t\t\tret = ARCHIVE_OK;\n\t\t} else {\n\t\t\tarchive_set_error(a, errno, \"Failed to set acl: %s\",\n\t\t\t    tname);\n\t\t\tret = ARCHIVE_WARN;\n\t\t}\n\t}\nexit_free:\n\tacl_free(acl);\n\treturn (ret);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,6 @@\n static int\n set_acl(struct archive *a, int fd, const char *name,\n-    struct archive_acl *abstract_acl,\n+    struct archive_acl *abstract_acl, __LA_MODE_T mode,\n     int ae_requested_type, const char *tname)\n {\n \tint\t\t acl_type = 0;\n@@ -31,6 +31,18 @@\n \t\terrno = ENOENT;\n \t\tarchive_set_error(a, errno, \"Unsupported ACL type\");\n \t\treturn (ARCHIVE_FAILED);\n+\t}\n+\n+\tif (S_ISLNK(mode)) {\n+\t\t/* Linux does not support ACLs on symbolic links */\n+\t\treturn (ARCHIVE_OK);\n+\t}\n+\n+\tif (acl_type == ACL_TYPE_DEFAULT && !S_ISDIR(mode)) {\n+\t\terrno = EINVAL;\n+\t\tarchive_set_error(a, errno,\n+\t\t    \"Cannot set default ACL on non-directory\");\n+\t\treturn (ARCHIVE_WARN);\n \t}\n \n \tacl = acl_init(entries);",
        "diff_line_info": {
            "deleted_lines": [
                "    struct archive_acl *abstract_acl,"
            ],
            "added_lines": [
                "    struct archive_acl *abstract_acl, __LA_MODE_T mode,",
                "\t}",
                "",
                "\tif (S_ISLNK(mode)) {",
                "\t\t/* Linux does not support ACLs on symbolic links */",
                "\t\treturn (ARCHIVE_OK);",
                "\t}",
                "",
                "\tif (acl_type == ACL_TYPE_DEFAULT && !S_ISDIR(mode)) {",
                "\t\terrno = EINVAL;",
                "\t\tarchive_set_error(a, errno,",
                "\t\t    \"Cannot set default ACL on non-directory\");",
                "\t\treturn (ARCHIVE_WARN);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-23177",
        "func_name": "libarchive/archive_write_disk_set_acls",
        "description": "An improper link resolution flaw while extracting an archive can lead to changing the access control list (ACL) of the target of the link. An attacker may provide a malicious archive to a victim user, who would trigger this flaw when trying to extract the archive. A local attacker may use this flaw to change the ACL of a file on the system and gain more privileges.",
        "git_url": "https://github.com/libarchive/libarchive/commit/fba4f123cc456d2b2538f811bb831483bf336bad",
        "commit_title": "Fix handling of symbolic link ACLs",
        "commit_text": " On Linux ACLs on symbolic links are not supported. We must avoid calling acl_set_file() on symbolic links as their targets are modified instead.  While here, do not try to set default ACLs on non-directories.  Fixes #1565",
        "func_before": "int\narchive_write_disk_set_acls(struct archive *a, int fd, const char *name,\n    struct archive_acl *abstract_acl, __LA_MODE_T mode)\n{\n\tint\t\tret = ARCHIVE_OK;\n\n#if !ARCHIVE_ACL_LIBRICHACL\n\t(void)mode;\t/* UNUSED */\n#endif\n\n#if ARCHIVE_ACL_LIBRICHACL\n\tif ((archive_acl_types(abstract_acl)\n\t    & ARCHIVE_ENTRY_ACL_TYPE_NFS4) != 0) {\n\t\tret = set_richacl(a, fd, name, abstract_acl, mode,\n\t\t    ARCHIVE_ENTRY_ACL_TYPE_NFS4, \"nfs4\");\n\t}\n#if ARCHIVE_ACL_LIBACL\n\telse\n#endif\n#endif\t/* ARCHIVE_ACL_LIBRICHACL */\n#if ARCHIVE_ACL_LIBACL\n\tif ((archive_acl_types(abstract_acl)\n\t    & ARCHIVE_ENTRY_ACL_TYPE_POSIX1E) != 0) {\n\t\tif ((archive_acl_types(abstract_acl)\n\t\t    & ARCHIVE_ENTRY_ACL_TYPE_ACCESS) != 0) {\n\t\t\tret = set_acl(a, fd, name, abstract_acl,\n\t\t\t    ARCHIVE_ENTRY_ACL_TYPE_ACCESS, \"access\");\n\t\t\tif (ret != ARCHIVE_OK)\n\t\t\t\treturn (ret);\n\t\t}\n\t\tif ((archive_acl_types(abstract_acl)\n\t\t    & ARCHIVE_ENTRY_ACL_TYPE_DEFAULT) != 0)\n\t\t\tret = set_acl(a, fd, name, abstract_acl,\n\t\t\t    ARCHIVE_ENTRY_ACL_TYPE_DEFAULT, \"default\");\n\t}\n#endif\t/* ARCHIVE_ACL_LIBACL */\n\treturn (ret);\n}",
        "func": "int\narchive_write_disk_set_acls(struct archive *a, int fd, const char *name,\n    struct archive_acl *abstract_acl, __LA_MODE_T mode)\n{\n\tint\t\tret = ARCHIVE_OK;\n\n#if !ARCHIVE_ACL_LIBRICHACL\n\t(void)mode;\t/* UNUSED */\n#endif\n\n#if ARCHIVE_ACL_LIBRICHACL\n\tif ((archive_acl_types(abstract_acl)\n\t    & ARCHIVE_ENTRY_ACL_TYPE_NFS4) != 0) {\n\t\tret = set_richacl(a, fd, name, abstract_acl, mode,\n\t\t    ARCHIVE_ENTRY_ACL_TYPE_NFS4, \"nfs4\");\n\t}\n#if ARCHIVE_ACL_LIBACL\n\telse\n#endif\n#endif\t/* ARCHIVE_ACL_LIBRICHACL */\n#if ARCHIVE_ACL_LIBACL\n\tif ((archive_acl_types(abstract_acl)\n\t    & ARCHIVE_ENTRY_ACL_TYPE_POSIX1E) != 0) {\n\t\tif ((archive_acl_types(abstract_acl)\n\t\t    & ARCHIVE_ENTRY_ACL_TYPE_ACCESS) != 0) {\n\t\t\tret = set_acl(a, fd, name, abstract_acl, mode,\n\t\t\t    ARCHIVE_ENTRY_ACL_TYPE_ACCESS, \"access\");\n\t\t\tif (ret != ARCHIVE_OK)\n\t\t\t\treturn (ret);\n\t\t}\n\t\tif ((archive_acl_types(abstract_acl)\n\t\t    & ARCHIVE_ENTRY_ACL_TYPE_DEFAULT) != 0)\n\t\t\tret = set_acl(a, fd, name, abstract_acl, mode,\n\t\t\t    ARCHIVE_ENTRY_ACL_TYPE_DEFAULT, \"default\");\n\t}\n#endif\t/* ARCHIVE_ACL_LIBACL */\n\treturn (ret);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -23,14 +23,14 @@\n \t    & ARCHIVE_ENTRY_ACL_TYPE_POSIX1E) != 0) {\n \t\tif ((archive_acl_types(abstract_acl)\n \t\t    & ARCHIVE_ENTRY_ACL_TYPE_ACCESS) != 0) {\n-\t\t\tret = set_acl(a, fd, name, abstract_acl,\n+\t\t\tret = set_acl(a, fd, name, abstract_acl, mode,\n \t\t\t    ARCHIVE_ENTRY_ACL_TYPE_ACCESS, \"access\");\n \t\t\tif (ret != ARCHIVE_OK)\n \t\t\t\treturn (ret);\n \t\t}\n \t\tif ((archive_acl_types(abstract_acl)\n \t\t    & ARCHIVE_ENTRY_ACL_TYPE_DEFAULT) != 0)\n-\t\t\tret = set_acl(a, fd, name, abstract_acl,\n+\t\t\tret = set_acl(a, fd, name, abstract_acl, mode,\n \t\t\t    ARCHIVE_ENTRY_ACL_TYPE_DEFAULT, \"default\");\n \t}\n #endif\t/* ARCHIVE_ACL_LIBACL */",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\tret = set_acl(a, fd, name, abstract_acl,",
                "\t\t\tret = set_acl(a, fd, name, abstract_acl,"
            ],
            "added_lines": [
                "\t\t\tret = set_acl(a, fd, name, abstract_acl, mode,",
                "\t\t\tret = set_acl(a, fd, name, abstract_acl, mode,"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-23177",
        "func_name": "libarchive/set_richacl",
        "description": "An improper link resolution flaw while extracting an archive can lead to changing the access control list (ACL) of the target of the link. An attacker may provide a malicious archive to a victim user, who would trigger this flaw when trying to extract the archive. A local attacker may use this flaw to change the ACL of a file on the system and gain more privileges.",
        "git_url": "https://github.com/libarchive/libarchive/commit/fba4f123cc456d2b2538f811bb831483bf336bad",
        "commit_title": "Fix handling of symbolic link ACLs",
        "commit_text": " On Linux ACLs on symbolic links are not supported. We must avoid calling acl_set_file() on symbolic links as their targets are modified instead.  While here, do not try to set default ACLs on non-directories.  Fixes #1565",
        "func_before": "static int\nset_richacl(struct archive *a, int fd, const char *name,\n    struct archive_acl *abstract_acl, __LA_MODE_T mode,\n    int ae_requested_type, const char *tname)\n{\n\tint\t\t ae_type, ae_permset, ae_tag, ae_id;\n\tuid_t\t\t ae_uid;\n\tgid_t\t\t ae_gid;\n\tconst char\t*ae_name;\n\tint\t\t entries;\n\tint\t\t i;\n\tint\t\t ret;\n\tint\t\t e = 0;\n\tstruct richacl  *richacl = NULL;\n\tstruct richace  *richace;\n\n\tret = ARCHIVE_OK;\n\tentries = archive_acl_reset(abstract_acl, ae_requested_type);\n\tif (entries == 0)\n\t\treturn (ARCHIVE_OK);\n\n\tif (ae_requested_type != ARCHIVE_ENTRY_ACL_TYPE_NFS4) {\n\t\terrno = ENOENT;\n\t\tarchive_set_error(a, errno, \"Unsupported ACL type\");\n\t\treturn (ARCHIVE_FAILED);\n\t}\n\n\trichacl = richacl_alloc(entries);\n\tif (richacl == NULL) {\n\t\tarchive_set_error(a, errno,\n\t\t\t\"Failed to initialize RichACL working storage\");\n\t\treturn (ARCHIVE_FAILED);\n\t}\n\n\te = 0;\n\n\twhile (archive_acl_next(a, abstract_acl, ae_requested_type, &ae_type,\n\t\t   &ae_permset, &ae_tag, &ae_id, &ae_name) == ARCHIVE_OK) {\n\t\trichace = &(richacl->a_entries[e]);\n\n\t\trichace->e_flags = 0;\n\t\trichace->e_mask = 0;\n\n\t\tswitch (ae_tag) {\n\t\tcase ARCHIVE_ENTRY_ACL_USER:\n\t\t\tae_uid = archive_write_disk_uid(a, ae_name, ae_id);\n\t\t\trichace->e_id = ae_uid;\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_GROUP:\n\t\t\tae_gid = archive_write_disk_gid(a, ae_name, ae_id);\n\t\t\trichace->e_id = ae_gid;\n\t\t\trichace->e_flags |= RICHACE_IDENTIFIER_GROUP;\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_USER_OBJ:\n\t\t\trichace->e_flags |= RICHACE_SPECIAL_WHO;\n\t\t\trichace->e_id = RICHACE_OWNER_SPECIAL_ID;\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_GROUP_OBJ:\n\t\t\trichace->e_flags |= RICHACE_SPECIAL_WHO;\n\t\t\trichace->e_id = RICHACE_GROUP_SPECIAL_ID;\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_EVERYONE:\n\t\t\trichace->e_flags |= RICHACE_SPECIAL_WHO;\n\t\t\trichace->e_id = RICHACE_EVERYONE_SPECIAL_ID;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_MISC,\n\t\t\t    \"Unsupported ACL tag\");\n\t\t\tret = ARCHIVE_FAILED;\n\t\t\tgoto exit_free;\n\t\t}\n\n\t\tswitch (ae_type) {\n\t\t\tcase ARCHIVE_ENTRY_ACL_TYPE_ALLOW:\n\t\t\t\trichace->e_type =\n\t\t\t\t    RICHACE_ACCESS_ALLOWED_ACE_TYPE;\n\t\t\t\tbreak;\n\t\t\tcase ARCHIVE_ENTRY_ACL_TYPE_DENY:\n\t\t\t\trichace->e_type =\n\t\t\t\t    RICHACE_ACCESS_DENIED_ACE_TYPE;\n\t\t\t\tbreak;\n\t\t\tcase ARCHIVE_ENTRY_ACL_TYPE_AUDIT:\n\t\t\tcase ARCHIVE_ENTRY_ACL_TYPE_ALARM:\n\t\t\t\tbreak;\n\t\tdefault:\n\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_MISC,\n\t\t\t    \"Unsupported ACL entry type\");\n\t\t\tret = ARCHIVE_FAILED;\n\t\t\tgoto exit_free;\n\t\t}\n\n\t\tfor (i = 0; i < acl_nfs4_perm_map_size; ++i) {\n\t\t\tif (ae_permset & acl_nfs4_perm_map[i].a_perm)\n\t\t\t\trichace->e_mask |= acl_nfs4_perm_map[i].p_perm;\n\t\t}\n\n\t\tfor (i = 0; i < acl_nfs4_flag_map_size; ++i) {\n\t\t\tif (ae_permset &\n\t\t\t    acl_nfs4_flag_map[i].a_perm)\n\t\t\t\trichace->e_flags |= acl_nfs4_flag_map[i].p_perm;\n\t\t}\n\te++;\n\t}\n\n\t/* Fill RichACL masks */\n\t_richacl_mode_to_masks(richacl, mode);\n\n\tif (fd >= 0) {\n\t\tif (richacl_set_fd(fd, richacl) == 0)\n\t\t\tret = ARCHIVE_OK;\n\t\telse {\n\t\t\tif (errno == EOPNOTSUPP) {\n\t\t\t\t/* Filesystem doesn't support ACLs */\n\t\t\t\tret = ARCHIVE_OK;\n\t\t\t} else {\n\t\t\t\tarchive_set_error(a, errno,\n\t\t\t\t    \"Failed to set richacl on fd: %s\", tname);\n\t\t\t\tret = ARCHIVE_WARN;\n\t\t\t}\n\t\t}\n\t} else if (richacl_set_file(name, richacl) != 0) {\n\t\tif (errno == EOPNOTSUPP) {\n\t\t\t/* Filesystem doesn't support ACLs */\n\t\t\tret = ARCHIVE_OK;\n\t\t} else {\n\t\t\tarchive_set_error(a, errno, \"Failed to set richacl: %s\",\n\t\t\t    tname);\n\t\t\tret = ARCHIVE_WARN;\n\t\t}\n\t}\nexit_free:\n\trichacl_free(richacl);\n\treturn (ret);\n}",
        "func": "static int\nset_richacl(struct archive *a, int fd, const char *name,\n    struct archive_acl *abstract_acl, __LA_MODE_T mode,\n    int ae_requested_type, const char *tname)\n{\n\tint\t\t ae_type, ae_permset, ae_tag, ae_id;\n\tuid_t\t\t ae_uid;\n\tgid_t\t\t ae_gid;\n\tconst char\t*ae_name;\n\tint\t\t entries;\n\tint\t\t i;\n\tint\t\t ret;\n\tint\t\t e = 0;\n\tstruct richacl  *richacl = NULL;\n\tstruct richace  *richace;\n\n\tret = ARCHIVE_OK;\n\tentries = archive_acl_reset(abstract_acl, ae_requested_type);\n\tif (entries == 0)\n\t\treturn (ARCHIVE_OK);\n\n\tif (ae_requested_type != ARCHIVE_ENTRY_ACL_TYPE_NFS4) {\n\t\terrno = ENOENT;\n\t\tarchive_set_error(a, errno, \"Unsupported ACL type\");\n\t\treturn (ARCHIVE_FAILED);\n\t}\n\n\tif (S_ISLNK(mode)) {\n\t\t/* Linux does not support RichACLs on symbolic links */\n\t\treturn (ARCHIVE_OK);\n\t}\n\n\trichacl = richacl_alloc(entries);\n\tif (richacl == NULL) {\n\t\tarchive_set_error(a, errno,\n\t\t\t\"Failed to initialize RichACL working storage\");\n\t\treturn (ARCHIVE_FAILED);\n\t}\n\n\te = 0;\n\n\twhile (archive_acl_next(a, abstract_acl, ae_requested_type, &ae_type,\n\t\t   &ae_permset, &ae_tag, &ae_id, &ae_name) == ARCHIVE_OK) {\n\t\trichace = &(richacl->a_entries[e]);\n\n\t\trichace->e_flags = 0;\n\t\trichace->e_mask = 0;\n\n\t\tswitch (ae_tag) {\n\t\tcase ARCHIVE_ENTRY_ACL_USER:\n\t\t\tae_uid = archive_write_disk_uid(a, ae_name, ae_id);\n\t\t\trichace->e_id = ae_uid;\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_GROUP:\n\t\t\tae_gid = archive_write_disk_gid(a, ae_name, ae_id);\n\t\t\trichace->e_id = ae_gid;\n\t\t\trichace->e_flags |= RICHACE_IDENTIFIER_GROUP;\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_USER_OBJ:\n\t\t\trichace->e_flags |= RICHACE_SPECIAL_WHO;\n\t\t\trichace->e_id = RICHACE_OWNER_SPECIAL_ID;\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_GROUP_OBJ:\n\t\t\trichace->e_flags |= RICHACE_SPECIAL_WHO;\n\t\t\trichace->e_id = RICHACE_GROUP_SPECIAL_ID;\n\t\t\tbreak;\n\t\tcase ARCHIVE_ENTRY_ACL_EVERYONE:\n\t\t\trichace->e_flags |= RICHACE_SPECIAL_WHO;\n\t\t\trichace->e_id = RICHACE_EVERYONE_SPECIAL_ID;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_MISC,\n\t\t\t    \"Unsupported ACL tag\");\n\t\t\tret = ARCHIVE_FAILED;\n\t\t\tgoto exit_free;\n\t\t}\n\n\t\tswitch (ae_type) {\n\t\t\tcase ARCHIVE_ENTRY_ACL_TYPE_ALLOW:\n\t\t\t\trichace->e_type =\n\t\t\t\t    RICHACE_ACCESS_ALLOWED_ACE_TYPE;\n\t\t\t\tbreak;\n\t\t\tcase ARCHIVE_ENTRY_ACL_TYPE_DENY:\n\t\t\t\trichace->e_type =\n\t\t\t\t    RICHACE_ACCESS_DENIED_ACE_TYPE;\n\t\t\t\tbreak;\n\t\t\tcase ARCHIVE_ENTRY_ACL_TYPE_AUDIT:\n\t\t\tcase ARCHIVE_ENTRY_ACL_TYPE_ALARM:\n\t\t\t\tbreak;\n\t\tdefault:\n\t\t\tarchive_set_error(a, ARCHIVE_ERRNO_MISC,\n\t\t\t    \"Unsupported ACL entry type\");\n\t\t\tret = ARCHIVE_FAILED;\n\t\t\tgoto exit_free;\n\t\t}\n\n\t\tfor (i = 0; i < acl_nfs4_perm_map_size; ++i) {\n\t\t\tif (ae_permset & acl_nfs4_perm_map[i].a_perm)\n\t\t\t\trichace->e_mask |= acl_nfs4_perm_map[i].p_perm;\n\t\t}\n\n\t\tfor (i = 0; i < acl_nfs4_flag_map_size; ++i) {\n\t\t\tif (ae_permset &\n\t\t\t    acl_nfs4_flag_map[i].a_perm)\n\t\t\t\trichace->e_flags |= acl_nfs4_flag_map[i].p_perm;\n\t\t}\n\te++;\n\t}\n\n\t/* Fill RichACL masks */\n\t_richacl_mode_to_masks(richacl, mode);\n\n\tif (fd >= 0) {\n\t\tif (richacl_set_fd(fd, richacl) == 0)\n\t\t\tret = ARCHIVE_OK;\n\t\telse {\n\t\t\tif (errno == EOPNOTSUPP) {\n\t\t\t\t/* Filesystem doesn't support ACLs */\n\t\t\t\tret = ARCHIVE_OK;\n\t\t\t} else {\n\t\t\t\tarchive_set_error(a, errno,\n\t\t\t\t    \"Failed to set richacl on fd: %s\", tname);\n\t\t\t\tret = ARCHIVE_WARN;\n\t\t\t}\n\t\t}\n\t} else if (richacl_set_file(name, richacl) != 0) {\n\t\tif (errno == EOPNOTSUPP) {\n\t\t\t/* Filesystem doesn't support ACLs */\n\t\t\tret = ARCHIVE_OK;\n\t\t} else {\n\t\t\tarchive_set_error(a, errno, \"Failed to set richacl: %s\",\n\t\t\t    tname);\n\t\t\tret = ARCHIVE_WARN;\n\t\t}\n\t}\nexit_free:\n\trichacl_free(richacl);\n\treturn (ret);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -23,6 +23,11 @@\n \t\terrno = ENOENT;\n \t\tarchive_set_error(a, errno, \"Unsupported ACL type\");\n \t\treturn (ARCHIVE_FAILED);\n+\t}\n+\n+\tif (S_ISLNK(mode)) {\n+\t\t/* Linux does not support RichACLs on symbolic links */\n+\t\treturn (ARCHIVE_OK);\n \t}\n \n \trichacl = richacl_alloc(entries);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t}",
                "",
                "\tif (S_ISLNK(mode)) {",
                "\t\t/* Linux does not support RichACLs on symbolic links */",
                "\t\treturn (ARCHIVE_OK);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-31566",
        "func_name": "libarchive/new_fixup",
        "description": "An improper link resolution flaw can occur while extracting an archive leading to changing modes, times, access control lists, and flags of a file outside of the archive. An attacker may provide a malicious archive to a victim user, who would trigger this flaw when trying to extract the archive. A local attacker may use this flaw to gain more privileges in a system.",
        "git_url": "https://github.com/libarchive/libarchive/commit/b41daecb5ccb4c8e3b2c53fd6147109fc12c3043",
        "commit_title": "Do not follow symlinks when processing the fixup list",
        "commit_text": " Use lchmod() instead of chmod() and tell the remaining functions that the real file to be modified is a symbolic link.  Fixes #1566",
        "func_before": "static struct fixup_entry *\nnew_fixup(struct archive_write_disk *a, const char *pathname)\n{\n\tstruct fixup_entry *fe;\n\n\tfe = (struct fixup_entry *)calloc(1, sizeof(struct fixup_entry));\n\tif (fe == NULL) {\n\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t    \"Can't allocate memory for a fixup\");\n\t\treturn (NULL);\n\t}\n\tfe->next = a->fixup_list;\n\ta->fixup_list = fe;\n\tfe->fixup = 0;\n\tfe->name = strdup(pathname);\n\treturn (fe);\n}",
        "func": "static struct fixup_entry *\nnew_fixup(struct archive_write_disk *a, const char *pathname)\n{\n\tstruct fixup_entry *fe;\n\n\tfe = (struct fixup_entry *)calloc(1, sizeof(struct fixup_entry));\n\tif (fe == NULL) {\n\t\tarchive_set_error(&a->archive, ENOMEM,\n\t\t    \"Can't allocate memory for a fixup\");\n\t\treturn (NULL);\n\t}\n\tfe->next = a->fixup_list;\n\ta->fixup_list = fe;\n\tfe->fixup = 0;\n\tfe->mode = 0;\n\tfe->name = strdup(pathname);\n\treturn (fe);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -12,6 +12,7 @@\n \tfe->next = a->fixup_list;\n \ta->fixup_list = fe;\n \tfe->fixup = 0;\n+\tfe->mode = 0;\n \tfe->name = strdup(pathname);\n \treturn (fe);\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tfe->mode = 0;"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-31566",
        "func_name": "libarchive/_archive_write_disk_close",
        "description": "An improper link resolution flaw can occur while extracting an archive leading to changing modes, times, access control lists, and flags of a file outside of the archive. An attacker may provide a malicious archive to a victim user, who would trigger this flaw when trying to extract the archive. A local attacker may use this flaw to gain more privileges in a system.",
        "git_url": "https://github.com/libarchive/libarchive/commit/b41daecb5ccb4c8e3b2c53fd6147109fc12c3043",
        "commit_title": "Do not follow symlinks when processing the fixup list",
        "commit_text": " Use lchmod() instead of chmod() and tell the remaining functions that the real file to be modified is a symbolic link.  Fixes #1566",
        "func_before": "static int\n_archive_write_disk_close(struct archive *_a)\n{\n\tstruct archive_write_disk *a = (struct archive_write_disk *)_a;\n\tstruct fixup_entry *next, *p;\n\tint fd, ret;\n\n\tarchive_check_magic(&a->archive, ARCHIVE_WRITE_DISK_MAGIC,\n\t    ARCHIVE_STATE_HEADER | ARCHIVE_STATE_DATA,\n\t    \"archive_write_disk_close\");\n\tret = _archive_write_disk_finish_entry(&a->archive);\n\n\t/* Sort dir list so directories are fixed up in depth-first order. */\n\tp = sort_dir_list(a->fixup_list);\n\n\twhile (p != NULL) {\n\t\tfd = -1;\n\t\ta->pst = NULL; /* Mark stat cache as out-of-date. */\n\t\tif (p->fixup &\n\t\t    (TODO_TIMES | TODO_MODE_BASE | TODO_ACLS | TODO_FFLAGS)) {\n\t\t\tfd = open(p->name,\n\t\t\t    O_WRONLY | O_BINARY | O_NOFOLLOW | O_CLOEXEC);\n\t\t}\n\t\tif (p->fixup & TODO_TIMES) {\n\t\t\tset_times(a, fd, p->mode, p->name,\n\t\t\t    p->atime, p->atime_nanos,\n\t\t\t    p->birthtime, p->birthtime_nanos,\n\t\t\t    p->mtime, p->mtime_nanos,\n\t\t\t    p->ctime, p->ctime_nanos);\n\t\t}\n\t\tif (p->fixup & TODO_MODE_BASE) {\n#ifdef HAVE_FCHMOD\n\t\t\tif (fd >= 0)\n\t\t\t\tfchmod(fd, p->mode);\n\t\t\telse\n#endif\n\t\t\tchmod(p->name, p->mode);\n\t\t}\n\t\tif (p->fixup & TODO_ACLS)\n\t\t\tarchive_write_disk_set_acls(&a->archive, fd,\n\t\t\t    p->name, &p->acl, p->mode);\n\t\tif (p->fixup & TODO_FFLAGS)\n\t\t\tset_fflags_platform(a, fd, p->name,\n\t\t\t    p->mode, p->fflags_set, 0);\n\t\tif (p->fixup & TODO_MAC_METADATA)\n\t\t\tset_mac_metadata(a, p->name, p->mac_metadata,\n\t\t\t\t\t p->mac_metadata_size);\n\t\tnext = p->next;\n\t\tarchive_acl_clear(&p->acl);\n\t\tfree(p->mac_metadata);\n\t\tfree(p->name);\n\t\tif (fd >= 0)\n\t\t\tclose(fd);\n\t\tfree(p);\n\t\tp = next;\n\t}\n\ta->fixup_list = NULL;\n\treturn (ret);\n}",
        "func": "static int\n_archive_write_disk_close(struct archive *_a)\n{\n\tstruct archive_write_disk *a = (struct archive_write_disk *)_a;\n\tstruct fixup_entry *next, *p;\n\tstruct stat st;\n\tint fd, ret;\n\n\tarchive_check_magic(&a->archive, ARCHIVE_WRITE_DISK_MAGIC,\n\t    ARCHIVE_STATE_HEADER | ARCHIVE_STATE_DATA,\n\t    \"archive_write_disk_close\");\n\tret = _archive_write_disk_finish_entry(&a->archive);\n\n\t/* Sort dir list so directories are fixed up in depth-first order. */\n\tp = sort_dir_list(a->fixup_list);\n\n\twhile (p != NULL) {\n\t\tfd = -1;\n\t\ta->pst = NULL; /* Mark stat cache as out-of-date. */\n\t\tif (p->fixup &\n\t\t    (TODO_TIMES | TODO_MODE_BASE | TODO_ACLS | TODO_FFLAGS)) {\n\t\t\tfd = open(p->name,\n\t\t\t    O_WRONLY | O_BINARY | O_NOFOLLOW | O_CLOEXEC);\n\t\t\tif (fd == -1) {\n\t\t\t\t/* If we cannot lstat, skip entry */\n\t\t\t\tif (lstat(p->name, &st) != 0)\n\t\t\t\t\tgoto skip_fixup_entry;\n\t\t\t\t/*\n\t\t\t\t * If we deal with a symbolic link, mark\n\t\t\t\t * it in the fixup mode to ensure no\n\t\t\t\t * modifications are made to its target.\n\t\t\t\t */\n\t\t\t\tif (S_ISLNK(st.st_mode)) {\n\t\t\t\t\tp->mode &= ~S_IFMT;\n\t\t\t\t\tp->mode |= S_IFLNK;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (p->fixup & TODO_TIMES) {\n\t\t\tset_times(a, fd, p->mode, p->name,\n\t\t\t    p->atime, p->atime_nanos,\n\t\t\t    p->birthtime, p->birthtime_nanos,\n\t\t\t    p->mtime, p->mtime_nanos,\n\t\t\t    p->ctime, p->ctime_nanos);\n\t\t}\n\t\tif (p->fixup & TODO_MODE_BASE) {\n#ifdef HAVE_FCHMOD\n\t\t\tif (fd >= 0)\n\t\t\t\tfchmod(fd, p->mode);\n\t\t\telse\n#endif\n#ifdef HAVE_LCHMOD\n\t\t\tlchmod(p->name, p->mode);\n#else\n\t\t\tif (!S_ISLNK(p->mode))\n\t\t\t\tchmod(p->name, p->mode);\n#endif\n\t\t}\n\t\tif (p->fixup & TODO_ACLS)\n\t\t\tarchive_write_disk_set_acls(&a->archive, fd,\n\t\t\t    p->name, &p->acl, p->mode);\n\t\tif (p->fixup & TODO_FFLAGS)\n\t\t\tset_fflags_platform(a, fd, p->name,\n\t\t\t    p->mode, p->fflags_set, 0);\n\t\tif (p->fixup & TODO_MAC_METADATA)\n\t\t\tset_mac_metadata(a, p->name, p->mac_metadata,\n\t\t\t\t\t p->mac_metadata_size);\nskip_fixup_entry:\n\t\tnext = p->next;\n\t\tarchive_acl_clear(&p->acl);\n\t\tfree(p->mac_metadata);\n\t\tfree(p->name);\n\t\tif (fd >= 0)\n\t\t\tclose(fd);\n\t\tfree(p);\n\t\tp = next;\n\t}\n\ta->fixup_list = NULL;\n\treturn (ret);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,6 +3,7 @@\n {\n \tstruct archive_write_disk *a = (struct archive_write_disk *)_a;\n \tstruct fixup_entry *next, *p;\n+\tstruct stat st;\n \tint fd, ret;\n \n \tarchive_check_magic(&a->archive, ARCHIVE_WRITE_DISK_MAGIC,\n@@ -20,6 +21,20 @@\n \t\t    (TODO_TIMES | TODO_MODE_BASE | TODO_ACLS | TODO_FFLAGS)) {\n \t\t\tfd = open(p->name,\n \t\t\t    O_WRONLY | O_BINARY | O_NOFOLLOW | O_CLOEXEC);\n+\t\t\tif (fd == -1) {\n+\t\t\t\t/* If we cannot lstat, skip entry */\n+\t\t\t\tif (lstat(p->name, &st) != 0)\n+\t\t\t\t\tgoto skip_fixup_entry;\n+\t\t\t\t/*\n+\t\t\t\t * If we deal with a symbolic link, mark\n+\t\t\t\t * it in the fixup mode to ensure no\n+\t\t\t\t * modifications are made to its target.\n+\t\t\t\t */\n+\t\t\t\tif (S_ISLNK(st.st_mode)) {\n+\t\t\t\t\tp->mode &= ~S_IFMT;\n+\t\t\t\t\tp->mode |= S_IFLNK;\n+\t\t\t\t}\n+\t\t\t}\n \t\t}\n \t\tif (p->fixup & TODO_TIMES) {\n \t\t\tset_times(a, fd, p->mode, p->name,\n@@ -34,7 +49,12 @@\n \t\t\t\tfchmod(fd, p->mode);\n \t\t\telse\n #endif\n-\t\t\tchmod(p->name, p->mode);\n+#ifdef HAVE_LCHMOD\n+\t\t\tlchmod(p->name, p->mode);\n+#else\n+\t\t\tif (!S_ISLNK(p->mode))\n+\t\t\t\tchmod(p->name, p->mode);\n+#endif\n \t\t}\n \t\tif (p->fixup & TODO_ACLS)\n \t\t\tarchive_write_disk_set_acls(&a->archive, fd,\n@@ -45,6 +65,7 @@\n \t\tif (p->fixup & TODO_MAC_METADATA)\n \t\t\tset_mac_metadata(a, p->name, p->mac_metadata,\n \t\t\t\t\t p->mac_metadata_size);\n+skip_fixup_entry:\n \t\tnext = p->next;\n \t\tarchive_acl_clear(&p->acl);\n \t\tfree(p->mac_metadata);",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\tchmod(p->name, p->mode);"
            ],
            "added_lines": [
                "\tstruct stat st;",
                "\t\t\tif (fd == -1) {",
                "\t\t\t\t/* If we cannot lstat, skip entry */",
                "\t\t\t\tif (lstat(p->name, &st) != 0)",
                "\t\t\t\t\tgoto skip_fixup_entry;",
                "\t\t\t\t/*",
                "\t\t\t\t * If we deal with a symbolic link, mark",
                "\t\t\t\t * it in the fixup mode to ensure no",
                "\t\t\t\t * modifications are made to its target.",
                "\t\t\t\t */",
                "\t\t\t\tif (S_ISLNK(st.st_mode)) {",
                "\t\t\t\t\tp->mode &= ~S_IFMT;",
                "\t\t\t\t\tp->mode |= S_IFLNK;",
                "\t\t\t\t}",
                "\t\t\t}",
                "#ifdef HAVE_LCHMOD",
                "\t\t\tlchmod(p->name, p->mode);",
                "#else",
                "\t\t\tif (!S_ISLNK(p->mode))",
                "\t\t\t\tchmod(p->name, p->mode);",
                "#endif",
                "skip_fixup_entry:"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-35938",
        "func_name": "rpm-software-management/rpm/rpmPackageFilesInstall",
        "description": "A symbolic link issue was found in rpm. It occurs when rpm sets the desired permissions and credentials after installing a file. A local unprivileged user could use this flaw to exchange the original file with a symbolic link to a security-critical file and escalate their privileges on the system. The highest threat from this vulnerability is to data confidentiality and integrity as well as system availability.",
        "git_url": "https://github.com/rpm-software-management/rpm/commit/25a435e90844ea98fe5eb7bef22c1aecf3a9c033",
        "commit_title": "Set file metadata via fd-based ops for everything but symlinks",
        "commit_text": " Regular file ops are fd-based already, for the rest we need to open them manually. Files with temporary suffix must never be followed, for directories (and pre-existing FA_TOUCHed files) use the rpm symlink \"root or target owner allowed\" rule wrt following.  This mostly fixes CVE-2021-35938, but as we're not yet using dirfd-based operatiosn for everything there are corner cases left undone. And then there's the plugin API which needs updating for all this.",
        "func_before": "int rpmPackageFilesInstall(rpmts ts, rpmte te, rpmfiles files,\n              rpmpsm psm, char ** failedFile)\n{\n    FD_t payload = rpmtePayload(te);\n    rpmfi fi = NULL;\n    rpmfs fs = rpmteGetFileStates(te);\n    rpmPlugins plugins = rpmtsPlugins(ts);\n    int rc = 0;\n    int fx = -1;\n    int fc = rpmfilesFC(files);\n    int nodigest = (rpmtsFlags(ts) & RPMTRANS_FLAG_NOFILEDIGEST) ? 1 : 0;\n    int nofcaps = (rpmtsFlags(ts) & RPMTRANS_FLAG_NOCAPS) ? 1 : 0;\n    int firstlinkfile = -1;\n    char *tid = NULL;\n    struct filedata_s *fdata = xcalloc(fc, sizeof(*fdata));\n    struct filedata_s *firstlink = NULL;\n    struct diriter_s di = { -1 };\n\n    /* transaction id used for temporary path suffix while installing */\n    rasprintf(&tid, \";%08x\", (unsigned)rpmtsGetTid(ts));\n\n    /* Collect state data for the whole operation */\n    fi = rpmfilesIter(files, RPMFI_ITER_FWD);\n    while (!rc && (fx = rpmfiNext(fi)) >= 0) {\n\tstruct filedata_s *fp = &fdata[fx];\n\tif (rpmfiFFlags(fi) & RPMFILE_GHOST)\n            fp->action = FA_SKIP;\n\telse\n\t    fp->action = rpmfsGetAction(fs, fx);\n\tfp->skip = XFA_SKIPPING(fp->action);\n\tif (XFA_CREATING(fp->action) && !S_ISDIR(rpmfiFMode(fi)))\n\t    fp->suffix = tid;\n\tfp->fpath = fsmFsPath(fi, fp->suffix);\n\n\t/* Remap file perms, owner, and group. */\n\trc = rpmfiStat(fi, 1, &fp->sb);\n\n\t/* Hardlinks are tricky and handled elsewhere for install */\n\tfp->setmeta = (fp->skip == 0) &&\n\t\t      (fp->sb.st_nlink == 1 || fp->action == FA_TOUCH);\n\n\tsetFileState(fs, fx);\n\tfsmDebug(fp->fpath, fp->action, &fp->sb);\n\n\tfp->stage = FILE_PRE;\n    }\n    fi = rpmfiFree(fi);\n\n    if (rc)\n\tgoto exit;\n\n    fi = fsmIter(payload, files,\n\t\t payload ? RPMFI_ITER_READ_ARCHIVE : RPMFI_ITER_FWD, &di);\n\n    if (fi == NULL) {\n        rc = RPMERR_BAD_MAGIC;\n        goto exit;\n    }\n\n    /* Process the payload */\n    while (!rc && (fx = rpmfiNext(fi)) >= 0) {\n\tstruct filedata_s *fp = &fdata[fx];\n\n\t/*\n\t * Tricksy case: this file is a being skipped, but it's part of\n\t * a hardlinked set and has the actual content linked with it.\n\t * Write the content to the first non-skipped file of the set\n\t * instead.\n\t */\n\tif (fp->skip && firstlink && rpmfiArchiveHasContent(fi))\n\t    fp = firstlink;\n\n        if (!fp->skip) {\n\t    int fd = -1;\n\t    /* Directories replacing something need early backup */\n\t    if (!fp->suffix && fp != firstlink) {\n\t\trc = fsmBackup(di.dirfd, fi, fp->action);\n\t    }\n\n\t    if (!rc) {\n\t\trc = ensureDir(plugins, rpmfiDN(fi), 0,\n\t\t\t\t(fp->action == FA_CREATE), 0, &di.dirfd);\n\t    }\n\n\t    /* Run fsm file pre hook for all plugins */\n\t    rc = rpmpluginsCallFsmFilePre(plugins, fi, fp->fpath,\n\t\t\t\t\t  fp->sb.st_mode, fp->action);\n\t    if (rc)\n\t\tgoto setmeta; /* for error notification */\n\n\t    /* Assume file does't exist when tmp suffix is in use */\n\t    if (!fp->suffix) {\n\t\tif (fp->action == FA_TOUCH) {\n\t\t    struct stat sb;\n\t\t    rc = fsmStat(di.dirfd, fp->fpath, 1, &sb);\n\t\t} else {\n\t\t    rc = fsmVerify(di.dirfd, fp->fpath, fi);\n\t\t}\n\t    } else {\n\t\trc = RPMERR_ENOENT;\n\t    }\n\n\t    /* See if the file was removed while our attention was elsewhere */\n\t    if (rc == RPMERR_ENOENT && fp->action == FA_TOUCH) {\n\t\trpmlog(RPMLOG_DEBUG, \"file %s vanished unexpectedly\\n\",\n\t\t\tfp->fpath);\n\t\tfp->action = FA_CREATE;\n\t\tfsmDebug(fp->fpath, fp->action, &fp->sb);\n\t    }\n\n\t    /* When touching we don't need any of this... */\n\t    if (fp->action == FA_TOUCH)\n\t\tgoto setmeta;\n\n            if (S_ISREG(fp->sb.st_mode)) {\n\t\tif (rc == RPMERR_ENOENT) {\n\t\t    rc = fsmMkfile(di.dirfd, fi, fp, files, psm, nodigest,\n\t\t\t\t   &firstlink, &firstlinkfile, &fd);\n\t\t}\n            } else if (S_ISDIR(fp->sb.st_mode)) {\n                if (rc == RPMERR_ENOENT) {\n                    mode_t mode = fp->sb.st_mode;\n                    mode &= ~07777;\n                    mode |=  00700;\n                    rc = fsmMkdir(di.dirfd, fp->fpath, mode);\n                }\n            } else if (S_ISLNK(fp->sb.st_mode)) {\n\t\tif (rc == RPMERR_ENOENT) {\n\t\t    rc = fsmSymlink(rpmfiFLink(fi), di.dirfd, fp->fpath);\n\t\t}\n            } else if (S_ISFIFO(fp->sb.st_mode)) {\n                /* This mimics cpio S_ISSOCK() behavior but probably isn't right */\n                if (rc == RPMERR_ENOENT) {\n                    rc = fsmMkfifo(di.dirfd, fp->fpath, 0000);\n                }\n            } else if (S_ISCHR(fp->sb.st_mode) ||\n                       S_ISBLK(fp->sb.st_mode) ||\n                       S_ISSOCK(fp->sb.st_mode))\n            {\n                if (rc == RPMERR_ENOENT) {\n                    rc = fsmMknod(di.dirfd, fp->fpath, fp->sb.st_mode, fp->sb.st_rdev);\n                }\n            } else {\n                /* XXX Special case /dev/log, which shouldn't be packaged anyways */\n                if (!IS_DEV_LOG(fp->fpath))\n                    rc = RPMERR_UNKNOWN_FILETYPE;\n            }\n\nsetmeta:\n\t    if (!rc && fp->setmeta) {\n\t\trc = fsmSetmeta(fd, di.dirfd, fp->fpath,\n\t\t\t\tfi, plugins, fp->action,\n\t\t\t\t&fp->sb, nofcaps);\n\t    }\n\n\t    if (fd != firstlinkfile)\n\t\tfsmClose(&fd);\n\t}\n\n\t/* Notify on success. */\n\tif (rc)\n\t    *failedFile = xstrdup(fp->fpath);\n\telse\n\t    rpmpsmNotify(psm, RPMCALLBACK_INST_PROGRESS, rpmfiArchiveTell(fi));\n\tfp->stage = FILE_UNPACK;\n    }\n    fi = fsmIterFini(fi, &di);\n\n    if (!rc && fx < 0 && fx != RPMERR_ITER_END)\n\trc = fx;\n\n    /* If all went well, commit files to final destination */\n    fi = fsmIter(NULL, files, RPMFI_ITER_FWD, &di);\n    while (!rc && (fx = rpmfiNext(fi)) >= 0) {\n\tstruct filedata_s *fp = &fdata[fx];\n\n\tif (!fp->skip) {\n\t    if (!rc)\n\t\trc = ensureDir(NULL, rpmfiDN(fi), 0, 0, 0, &di.dirfd);\n\n\t    /* Backup file if needed. Directories are handled earlier */\n\t    if (!rc && fp->suffix)\n\t\trc = fsmBackup(di.dirfd, fi, fp->action);\n\n\t    if (!rc)\n\t\trc = fsmCommit(di.dirfd, &fp->fpath, fi, fp->action, fp->suffix);\n\n\t    if (!rc)\n\t\tfp->stage = FILE_COMMIT;\n\t    else\n\t\t*failedFile = xstrdup(fp->fpath);\n\n\t    /* Run fsm file post hook for all plugins for all processed files */\n\t    rpmpluginsCallFsmFilePost(plugins, fi, fp->fpath,\n\t\t\t\t      fp->sb.st_mode, fp->action, rc);\n\t}\n    }\n    fi = fsmIterFini(fi, &di);\n\n    /* On failure, walk backwards and erase non-committed files */\n    if (rc) {\n\tfi = fsmIter(NULL, files, RPMFI_ITER_BACK, &di);\n\twhile ((fx = rpmfiNext(fi)) >= 0) {\n\t    struct filedata_s *fp = &fdata[fx];\n\n\t    /* If the directory doesn't exist there's nothing to clean up */\n\t    if (ensureDir(NULL, rpmfiDN(fi), 0, 0, 1, &di.dirfd))\n\t\tcontinue;\n\n\t    if (fp->stage > FILE_NONE && !fp->skip) {\n\t\t(void) fsmRemove(di.dirfd, fp->fpath, fp->sb.st_mode);\n\t    }\n\t}\n    }\n\n    rpmswAdd(rpmtsOp(ts, RPMTS_OP_UNCOMPRESS), fdOp(payload, FDSTAT_READ));\n    rpmswAdd(rpmtsOp(ts, RPMTS_OP_DIGEST), fdOp(payload, FDSTAT_DIGEST));\n\nexit:\n    fi = fsmIterFini(fi, &di);\n    Fclose(payload);\n    free(tid);\n    for (int i = 0; i < fc; i++)\n\tfree(fdata[i].fpath);\n    free(fdata);\n\n    return rc;\n}",
        "func": "int rpmPackageFilesInstall(rpmts ts, rpmte te, rpmfiles files,\n              rpmpsm psm, char ** failedFile)\n{\n    FD_t payload = rpmtePayload(te);\n    rpmfi fi = NULL;\n    rpmfs fs = rpmteGetFileStates(te);\n    rpmPlugins plugins = rpmtsPlugins(ts);\n    int rc = 0;\n    int fx = -1;\n    int fc = rpmfilesFC(files);\n    int nodigest = (rpmtsFlags(ts) & RPMTRANS_FLAG_NOFILEDIGEST) ? 1 : 0;\n    int nofcaps = (rpmtsFlags(ts) & RPMTRANS_FLAG_NOCAPS) ? 1 : 0;\n    int firstlinkfile = -1;\n    char *tid = NULL;\n    struct filedata_s *fdata = xcalloc(fc, sizeof(*fdata));\n    struct filedata_s *firstlink = NULL;\n    struct diriter_s di = { -1 };\n\n    /* transaction id used for temporary path suffix while installing */\n    rasprintf(&tid, \";%08x\", (unsigned)rpmtsGetTid(ts));\n\n    /* Collect state data for the whole operation */\n    fi = rpmfilesIter(files, RPMFI_ITER_FWD);\n    while (!rc && (fx = rpmfiNext(fi)) >= 0) {\n\tstruct filedata_s *fp = &fdata[fx];\n\tif (rpmfiFFlags(fi) & RPMFILE_GHOST)\n            fp->action = FA_SKIP;\n\telse\n\t    fp->action = rpmfsGetAction(fs, fx);\n\tfp->skip = XFA_SKIPPING(fp->action);\n\tif (XFA_CREATING(fp->action) && !S_ISDIR(rpmfiFMode(fi)))\n\t    fp->suffix = tid;\n\tfp->fpath = fsmFsPath(fi, fp->suffix);\n\n\t/* Remap file perms, owner, and group. */\n\trc = rpmfiStat(fi, 1, &fp->sb);\n\n\t/* Hardlinks are tricky and handled elsewhere for install */\n\tfp->setmeta = (fp->skip == 0) &&\n\t\t      (fp->sb.st_nlink == 1 || fp->action == FA_TOUCH);\n\n\tsetFileState(fs, fx);\n\tfsmDebug(fp->fpath, fp->action, &fp->sb);\n\n\tfp->stage = FILE_PRE;\n    }\n    fi = rpmfiFree(fi);\n\n    if (rc)\n\tgoto exit;\n\n    fi = fsmIter(payload, files,\n\t\t payload ? RPMFI_ITER_READ_ARCHIVE : RPMFI_ITER_FWD, &di);\n\n    if (fi == NULL) {\n        rc = RPMERR_BAD_MAGIC;\n        goto exit;\n    }\n\n    /* Process the payload */\n    while (!rc && (fx = rpmfiNext(fi)) >= 0) {\n\tstruct filedata_s *fp = &fdata[fx];\n\n\t/*\n\t * Tricksy case: this file is a being skipped, but it's part of\n\t * a hardlinked set and has the actual content linked with it.\n\t * Write the content to the first non-skipped file of the set\n\t * instead.\n\t */\n\tif (fp->skip && firstlink && rpmfiArchiveHasContent(fi))\n\t    fp = firstlink;\n\n        if (!fp->skip) {\n\t    int fd = -1;\n\t    /* Directories replacing something need early backup */\n\t    if (!fp->suffix && fp != firstlink) {\n\t\trc = fsmBackup(di.dirfd, fi, fp->action);\n\t    }\n\n\t    if (!rc) {\n\t\trc = ensureDir(plugins, rpmfiDN(fi), 0,\n\t\t\t\t(fp->action == FA_CREATE), 0, &di.dirfd);\n\t    }\n\n\t    /* Run fsm file pre hook for all plugins */\n\t    rc = rpmpluginsCallFsmFilePre(plugins, fi, fp->fpath,\n\t\t\t\t\t  fp->sb.st_mode, fp->action);\n\t    if (rc)\n\t\tgoto setmeta; /* for error notification */\n\n\t    /* Assume file does't exist when tmp suffix is in use */\n\t    if (!fp->suffix) {\n\t\tif (fp->action == FA_TOUCH) {\n\t\t    struct stat sb;\n\t\t    rc = fsmStat(di.dirfd, fp->fpath, 1, &sb);\n\t\t} else {\n\t\t    rc = fsmVerify(di.dirfd, fp->fpath, fi);\n\t\t}\n\t    } else {\n\t\trc = RPMERR_ENOENT;\n\t    }\n\n\t    /* See if the file was removed while our attention was elsewhere */\n\t    if (rc == RPMERR_ENOENT && fp->action == FA_TOUCH) {\n\t\trpmlog(RPMLOG_DEBUG, \"file %s vanished unexpectedly\\n\",\n\t\t\tfp->fpath);\n\t\tfp->action = FA_CREATE;\n\t\tfsmDebug(fp->fpath, fp->action, &fp->sb);\n\t    }\n\n\t    /* When touching we don't need any of this... */\n\t    if (fp->action == FA_TOUCH)\n\t\tgoto setmeta;\n\n            if (S_ISREG(fp->sb.st_mode)) {\n\t\tif (rc == RPMERR_ENOENT) {\n\t\t    rc = fsmMkfile(di.dirfd, fi, fp, files, psm, nodigest,\n\t\t\t\t   &firstlink, &firstlinkfile, &fd);\n\t\t}\n            } else if (S_ISDIR(fp->sb.st_mode)) {\n                if (rc == RPMERR_ENOENT) {\n                    mode_t mode = fp->sb.st_mode;\n                    mode &= ~07777;\n                    mode |=  00700;\n                    rc = fsmMkdir(di.dirfd, fp->fpath, mode);\n                }\n            } else if (S_ISLNK(fp->sb.st_mode)) {\n\t\tif (rc == RPMERR_ENOENT) {\n\t\t    rc = fsmSymlink(rpmfiFLink(fi), di.dirfd, fp->fpath);\n\t\t}\n            } else if (S_ISFIFO(fp->sb.st_mode)) {\n                /* This mimics cpio S_ISSOCK() behavior but probably isn't right */\n                if (rc == RPMERR_ENOENT) {\n                    rc = fsmMkfifo(di.dirfd, fp->fpath, 0000);\n                }\n            } else if (S_ISCHR(fp->sb.st_mode) ||\n                       S_ISBLK(fp->sb.st_mode) ||\n                       S_ISSOCK(fp->sb.st_mode))\n            {\n                if (rc == RPMERR_ENOENT) {\n                    rc = fsmMknod(di.dirfd, fp->fpath, fp->sb.st_mode, fp->sb.st_rdev);\n                }\n            } else {\n                /* XXX Special case /dev/log, which shouldn't be packaged anyways */\n                if (!IS_DEV_LOG(fp->fpath))\n                    rc = RPMERR_UNKNOWN_FILETYPE;\n            }\n\n\t    if (!rc && fd == -1 && !S_ISLNK(fp->sb.st_mode)) {\n\t\t/* Only follow safe symlinks, and never on temporary files */\n\t\tfd = fsmOpenat(di.dirfd, fp->fpath,\n\t\t\t\tfp->suffix ? AT_SYMLINK_NOFOLLOW : 0);\n\t\tif (fd < 0)\n\t\t    rc = RPMERR_OPEN_FAILED;\n\t    }\n\nsetmeta:\n\t    if (!rc && fp->setmeta) {\n\t\trc = fsmSetmeta(fd, di.dirfd, fp->fpath,\n\t\t\t\tfi, plugins, fp->action,\n\t\t\t\t&fp->sb, nofcaps);\n\t    }\n\n\t    if (fd != firstlinkfile)\n\t\tfsmClose(&fd);\n\t}\n\n\t/* Notify on success. */\n\tif (rc)\n\t    *failedFile = xstrdup(fp->fpath);\n\telse\n\t    rpmpsmNotify(psm, RPMCALLBACK_INST_PROGRESS, rpmfiArchiveTell(fi));\n\tfp->stage = FILE_UNPACK;\n    }\n    fi = fsmIterFini(fi, &di);\n\n    if (!rc && fx < 0 && fx != RPMERR_ITER_END)\n\trc = fx;\n\n    /* If all went well, commit files to final destination */\n    fi = fsmIter(NULL, files, RPMFI_ITER_FWD, &di);\n    while (!rc && (fx = rpmfiNext(fi)) >= 0) {\n\tstruct filedata_s *fp = &fdata[fx];\n\n\tif (!fp->skip) {\n\t    if (!rc)\n\t\trc = ensureDir(NULL, rpmfiDN(fi), 0, 0, 0, &di.dirfd);\n\n\t    /* Backup file if needed. Directories are handled earlier */\n\t    if (!rc && fp->suffix)\n\t\trc = fsmBackup(di.dirfd, fi, fp->action);\n\n\t    if (!rc)\n\t\trc = fsmCommit(di.dirfd, &fp->fpath, fi, fp->action, fp->suffix);\n\n\t    if (!rc)\n\t\tfp->stage = FILE_COMMIT;\n\t    else\n\t\t*failedFile = xstrdup(fp->fpath);\n\n\t    /* Run fsm file post hook for all plugins for all processed files */\n\t    rpmpluginsCallFsmFilePost(plugins, fi, fp->fpath,\n\t\t\t\t      fp->sb.st_mode, fp->action, rc);\n\t}\n    }\n    fi = fsmIterFini(fi, &di);\n\n    /* On failure, walk backwards and erase non-committed files */\n    if (rc) {\n\tfi = fsmIter(NULL, files, RPMFI_ITER_BACK, &di);\n\twhile ((fx = rpmfiNext(fi)) >= 0) {\n\t    struct filedata_s *fp = &fdata[fx];\n\n\t    /* If the directory doesn't exist there's nothing to clean up */\n\t    if (ensureDir(NULL, rpmfiDN(fi), 0, 0, 1, &di.dirfd))\n\t\tcontinue;\n\n\t    if (fp->stage > FILE_NONE && !fp->skip) {\n\t\t(void) fsmRemove(di.dirfd, fp->fpath, fp->sb.st_mode);\n\t    }\n\t}\n    }\n\n    rpmswAdd(rpmtsOp(ts, RPMTS_OP_UNCOMPRESS), fdOp(payload, FDSTAT_READ));\n    rpmswAdd(rpmtsOp(ts, RPMTS_OP_DIGEST), fdOp(payload, FDSTAT_DIGEST));\n\nexit:\n    fi = fsmIterFini(fi, &di);\n    Fclose(payload);\n    free(tid);\n    for (int i = 0; i < fc; i++)\n\tfree(fdata[i].fpath);\n    free(fdata);\n\n    return rc;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -146,6 +146,14 @@\n                     rc = RPMERR_UNKNOWN_FILETYPE;\n             }\n \n+\t    if (!rc && fd == -1 && !S_ISLNK(fp->sb.st_mode)) {\n+\t\t/* Only follow safe symlinks, and never on temporary files */\n+\t\tfd = fsmOpenat(di.dirfd, fp->fpath,\n+\t\t\t\tfp->suffix ? AT_SYMLINK_NOFOLLOW : 0);\n+\t\tif (fd < 0)\n+\t\t    rc = RPMERR_OPEN_FAILED;\n+\t    }\n+\n setmeta:\n \t    if (!rc && fp->setmeta) {\n \t\trc = fsmSetmeta(fd, di.dirfd, fp->fpath,",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t    if (!rc && fd == -1 && !S_ISLNK(fp->sb.st_mode)) {",
                "\t\t/* Only follow safe symlinks, and never on temporary files */",
                "\t\tfd = fsmOpenat(di.dirfd, fp->fpath,",
                "\t\t\t\tfp->suffix ? AT_SYMLINK_NOFOLLOW : 0);",
                "\t\tif (fd < 0)",
                "\t\t    rc = RPMERR_OPEN_FAILED;",
                "\t    }",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2021-35939",
        "func_name": "rpm-software-management/rpm/rpmPackageFilesInstall",
        "description": "It was found that the fix for CVE-2017-7500 and CVE-2017-7501 was incomplete: the check was only implemented for the parent directory of the file to be created. A local unprivileged user who owns another ancestor directory could potentially use this flaw to gain root privileges. The highest threat from this vulnerability is to data confidentiality and integrity as well as system availability.",
        "git_url": "https://github.com/rpm-software-management/rpm/commit/96ec957e281220f8e137a2d5eb23b83a6377d556",
        "commit_title": "Validate intermediate symlinks during installation, CVE-2021-35939",
        "commit_text": " Whenever directory changes during unpacking, walk the entire tree from starting from / and validate any symlinks crossed, fail the install on invalid links.  This is the first of step of many towards securing our file operations against local tamperers and besides plugging that one CVE, paves the way for the next step by adding the necessary directory fd tracking. This also bumps the rpm OS requirements to a whole new level by requiring the *at() family of calls from POSIX-1.2008.  This necessarily does a whole lot of huffing and puffing we previously did not do. It should be possible to cache secure (ie root-owned) directory structures to avoid validating everything a million times but for now, just keeping things simple.",
        "func_before": "int rpmPackageFilesInstall(rpmts ts, rpmte te, rpmfiles files,\n              rpmpsm psm, char ** failedFile)\n{\n    FD_t payload = rpmtePayload(te);\n    rpmfi fi = NULL;\n    rpmfs fs = rpmteGetFileStates(te);\n    rpmPlugins plugins = rpmtsPlugins(ts);\n    int rc = 0;\n    int fx = -1;\n    int fc = rpmfilesFC(files);\n    int nodigest = (rpmtsFlags(ts) & RPMTRANS_FLAG_NOFILEDIGEST) ? 1 : 0;\n    int nofcaps = (rpmtsFlags(ts) & RPMTRANS_FLAG_NOCAPS) ? 1 : 0;\n    FD_t firstlinkfile = NULL;\n    char *tid = NULL;\n    struct filedata_s *fdata = xcalloc(fc, sizeof(*fdata));\n    struct filedata_s *firstlink = NULL;\n\n    /* transaction id used for temporary path suffix while installing */\n    rasprintf(&tid, \";%08x\", (unsigned)rpmtsGetTid(ts));\n\n    /* Collect state data for the whole operation */\n    fi = rpmfilesIter(files, RPMFI_ITER_FWD);\n    while (!rc && (fx = rpmfiNext(fi)) >= 0) {\n\tstruct filedata_s *fp = &fdata[fx];\n\tif (rpmfiFFlags(fi) & RPMFILE_GHOST)\n            fp->action = FA_SKIP;\n\telse\n\t    fp->action = rpmfsGetAction(fs, fx);\n\tfp->skip = XFA_SKIPPING(fp->action);\n\tfp->setmeta = 1;\n\tif (XFA_CREATING(fp->action) && !S_ISDIR(rpmfiFMode(fi)))\n\t    fp->suffix = tid;\n\tfp->fpath = fsmFsPath(fi, fp->suffix);\n\n\t/* Remap file perms, owner, and group. */\n\trc = rpmfiStat(fi, 1, &fp->sb);\n\n\tsetFileState(fs, fx);\n\tfsmDebug(fp->fpath, fp->action, &fp->sb);\n\n\t/* Run fsm file pre hook for all plugins */\n\trc = rpmpluginsCallFsmFilePre(plugins, fi, fp->fpath,\n\t\t\t\t      fp->sb.st_mode, fp->action);\n\tfp->stage = FILE_PRE;\n    }\n    fi = rpmfiFree(fi);\n\n    if (rc)\n\tgoto exit;\n\n    if (rpmteType(te) == TR_ADDED)\n\tfi = rpmfiNewArchiveReader(payload, files, RPMFI_ITER_READ_ARCHIVE);\n    else\n\tfi = rpmfilesIter(files, RPMFI_ITER_FWD);\n    if (fi == NULL) {\n        rc = RPMERR_BAD_MAGIC;\n        goto exit;\n    }\n\n    /* Detect and create directories not explicitly in package. */\n    if (!rc)\n\trc = fsmMkdirs(files, fs, plugins);\n\n    /* Process the payload */\n    while (!rc && (fx = rpmfiNext(fi)) >= 0) {\n\tstruct filedata_s *fp = &fdata[fx];\n\n        if (!fp->skip) {\n\t    /* Directories replacing something need early backup */\n\t    if (!fp->suffix) {\n\t\trc = fsmBackup(fi, fp->action);\n\t    }\n\t    /* Assume file does't exist when tmp suffix is in use */\n\t    if (!fp->suffix) {\n\t\tif (fp->action == FA_TOUCH) {\n\t\t    struct stat sb;\n\t\t    rc = fsmStat(fp->fpath, 1, &sb);\n\t\t} else {\n\t\t    rc = fsmVerify(fp->fpath, fi);\n\t\t}\n\t    } else {\n\t\trc = RPMERR_ENOENT;\n\t    }\n\n\t    /* See if the file was removed while our attention was elsewhere */\n\t    if (rc == RPMERR_ENOENT && fp->action == FA_TOUCH) {\n\t\trpmlog(RPMLOG_DEBUG, \"file %s vanished unexpectedly\\n\",\n\t\t\tfp->fpath);\n\t\tfp->action = FA_CREATE;\n\t\tfsmDebug(fp->fpath, fp->action, &fp->sb);\n\t    }\n\n\t    /* When touching we don't need any of this... */\n\t    if (fp->action == FA_TOUCH)\n\t\tcontinue;\n\n            if (S_ISREG(fp->sb.st_mode)) {\n\t\tif (rc == RPMERR_ENOENT) {\n\t\t    rc = fsmMkfile(fi, fp, files, psm, nodigest,\n\t\t\t\t   &firstlink, &firstlinkfile);\n\t\t}\n            } else if (S_ISDIR(fp->sb.st_mode)) {\n                if (rc == RPMERR_ENOENT) {\n                    mode_t mode = fp->sb.st_mode;\n                    mode &= ~07777;\n                    mode |=  00700;\n                    rc = fsmMkdir(fp->fpath, mode);\n                }\n            } else if (S_ISLNK(fp->sb.st_mode)) {\n\t\tif (rc == RPMERR_ENOENT) {\n\t\t    rc = fsmSymlink(rpmfiFLink(fi), fp->fpath);\n\t\t}\n            } else if (S_ISFIFO(fp->sb.st_mode)) {\n                /* This mimics cpio S_ISSOCK() behavior but probably isn't right */\n                if (rc == RPMERR_ENOENT) {\n                    rc = fsmMkfifo(fp->fpath, 0000);\n                }\n            } else if (S_ISCHR(fp->sb.st_mode) ||\n                       S_ISBLK(fp->sb.st_mode) ||\n                       S_ISSOCK(fp->sb.st_mode))\n            {\n                if (rc == RPMERR_ENOENT) {\n                    rc = fsmMknod(fp->fpath, fp->sb.st_mode, fp->sb.st_rdev);\n                }\n            } else {\n                /* XXX Special case /dev/log, which shouldn't be packaged anyways */\n                if (!IS_DEV_LOG(fp->fpath))\n                    rc = RPMERR_UNKNOWN_FILETYPE;\n            }\n\t} else if (firstlink && rpmfiArchiveHasContent(fi)) {\n\t    /*\n\t     * Tricksy case: this file is a being skipped, but it's part of\n\t     * a hardlinked set and has the actual content linked with it.\n\t     * Write the content to the first non-skipped file of the set\n\t     * instead.\n\t     */\n\t    rc = fsmMkfile(fi, firstlink, files, psm, nodigest,\n\t\t\t   &firstlink, &firstlinkfile);\n\t}\n\n\t/* Notify on success. */\n\tif (rc)\n\t    *failedFile = xstrdup(fp->fpath);\n\telse\n\t    rpmpsmNotify(psm, RPMCALLBACK_INST_PROGRESS, rpmfiArchiveTell(fi));\n\tfp->stage = FILE_UNPACK;\n    }\n    fi = rpmfiFree(fi);\n\n    if (!rc && fx < 0 && fx != RPMERR_ITER_END)\n\trc = fx;\n\n    /* Set permissions, timestamps etc for non-hardlink entries */\n    fi = rpmfilesIter(files, RPMFI_ITER_FWD);\n    while (!rc && (fx = rpmfiNext(fi)) >= 0) {\n\tstruct filedata_s *fp = &fdata[fx];\n\tif (!fp->skip && fp->setmeta) {\n\t    rc = fsmSetmeta(fp->fpath, fi, plugins, fp->action,\n\t\t\t    &fp->sb, nofcaps);\n\t}\n\tif (rc)\n\t    *failedFile = xstrdup(fp->fpath);\n\tfp->stage = FILE_PREP;\n    }\n    fi = rpmfiFree(fi);\n\n    /* If all went well, commit files to final destination */\n    fi = rpmfilesIter(files, RPMFI_ITER_FWD);\n    while (!rc && (fx = rpmfiNext(fi)) >= 0) {\n\tstruct filedata_s *fp = &fdata[fx];\n\n\tif (!fp->skip) {\n\t    /* Backup file if needed. Directories are handled earlier */\n\t    if (!rc && fp->suffix)\n\t\trc = fsmBackup(fi, fp->action);\n\n\t    if (!rc)\n\t\trc = fsmCommit(&fp->fpath, fi, fp->action, fp->suffix);\n\n\t    if (!rc)\n\t\tfp->stage = FILE_COMMIT;\n\t    else\n\t\t*failedFile = xstrdup(fp->fpath);\n\t}\n    }\n    fi = rpmfiFree(fi);\n\n    /* Walk backwards in case we need to erase */\n    fi = rpmfilesIter(files, RPMFI_ITER_BACK);\n    while ((fx = rpmfiNext(fi)) >= 0) {\n\tstruct filedata_s *fp = &fdata[fx];\n\t/* Run fsm file post hook for all plugins for all processed files */\n\tif (fp->stage) {\n\t    rpmpluginsCallFsmFilePost(plugins, fi, fp->fpath,\n\t\t\t\t      fp->sb.st_mode, fp->action, rc);\n\t}\n\n\t/* On failure, erase non-committed files */\n\tif (rc && fp->stage > FILE_NONE && !fp->skip) {\n\t    (void) fsmRemove(fp->fpath, fp->sb.st_mode);\n\t}\n    }\n\n    rpmswAdd(rpmtsOp(ts, RPMTS_OP_UNCOMPRESS), fdOp(payload, FDSTAT_READ));\n    rpmswAdd(rpmtsOp(ts, RPMTS_OP_DIGEST), fdOp(payload, FDSTAT_DIGEST));\n\nexit:\n    fi = rpmfiFree(fi);\n    Fclose(payload);\n    free(tid);\n    for (int i = 0; i < fc; i++)\n\tfree(fdata[i].fpath);\n    free(fdata);\n\n    return rc;\n}",
        "func": "int rpmPackageFilesInstall(rpmts ts, rpmte te, rpmfiles files,\n              rpmpsm psm, char ** failedFile)\n{\n    FD_t payload = rpmtePayload(te);\n    rpmfi fi = NULL;\n    rpmfs fs = rpmteGetFileStates(te);\n    rpmPlugins plugins = rpmtsPlugins(ts);\n    int rc = 0;\n    int fx = -1;\n    int fc = rpmfilesFC(files);\n    int nodigest = (rpmtsFlags(ts) & RPMTRANS_FLAG_NOFILEDIGEST) ? 1 : 0;\n    int nofcaps = (rpmtsFlags(ts) & RPMTRANS_FLAG_NOCAPS) ? 1 : 0;\n    FD_t firstlinkfile = NULL;\n    char *tid = NULL;\n    struct filedata_s *fdata = xcalloc(fc, sizeof(*fdata));\n    struct filedata_s *firstlink = NULL;\n    struct diriter_s di = { -1 };\n\n    /* transaction id used for temporary path suffix while installing */\n    rasprintf(&tid, \";%08x\", (unsigned)rpmtsGetTid(ts));\n\n    /* Collect state data for the whole operation */\n    fi = rpmfilesIter(files, RPMFI_ITER_FWD);\n    while (!rc && (fx = rpmfiNext(fi)) >= 0) {\n\tstruct filedata_s *fp = &fdata[fx];\n\tif (rpmfiFFlags(fi) & RPMFILE_GHOST)\n            fp->action = FA_SKIP;\n\telse\n\t    fp->action = rpmfsGetAction(fs, fx);\n\tfp->skip = XFA_SKIPPING(fp->action);\n\tfp->setmeta = 1;\n\tif (XFA_CREATING(fp->action) && !S_ISDIR(rpmfiFMode(fi)))\n\t    fp->suffix = tid;\n\tfp->fpath = fsmFsPath(fi, fp->suffix);\n\n\t/* Remap file perms, owner, and group. */\n\trc = rpmfiStat(fi, 1, &fp->sb);\n\n\tsetFileState(fs, fx);\n\tfsmDebug(fp->fpath, fp->action, &fp->sb);\n\n\t/* Run fsm file pre hook for all plugins */\n\trc = rpmpluginsCallFsmFilePre(plugins, fi, fp->fpath,\n\t\t\t\t      fp->sb.st_mode, fp->action);\n\tfp->stage = FILE_PRE;\n    }\n    fi = rpmfiFree(fi);\n\n    if (rc)\n\tgoto exit;\n\n    if (rpmteType(te) == TR_ADDED)\n\tfi = rpmfiNewArchiveReader(payload, files, RPMFI_ITER_READ_ARCHIVE);\n    else\n\tfi = rpmfilesIter(files, RPMFI_ITER_FWD);\n    if (fi == NULL) {\n        rc = RPMERR_BAD_MAGIC;\n        goto exit;\n    }\n    rpmfiSetOnChdir(fi, onChdir, &di);\n\n    /* Detect and create directories not explicitly in package. */\n    if (!rc)\n\trc = fsmMkdirs(files, fs, plugins);\n\n    /* Process the payload */\n    while (!rc && (fx = rpmfiNext(fi)) >= 0) {\n\tstruct filedata_s *fp = &fdata[fx];\n\n        if (!fp->skip) {\n\t    /* Directories replacing something need early backup */\n\t    if (!fp->suffix) {\n\t\trc = fsmBackup(fi, fp->action);\n\t    }\n\n\t    if (di.dirfd == -1) {\n\t\tdi.dirfd = ensureDir(plugins, rpmfiDN(fi), 0,\n\t\t\t\t    (fp->action == FA_CREATE));\n\t\tif (di.dirfd == -1) {\n\t\t    rc = RPMERR_OPEN_FAILED;\n\t\t    break;\n\t\t}\n\t    }\n\n\t    /* Assume file does't exist when tmp suffix is in use */\n\t    if (!fp->suffix) {\n\t\tif (fp->action == FA_TOUCH) {\n\t\t    struct stat sb;\n\t\t    rc = fsmStat(fp->fpath, 1, &sb);\n\t\t} else {\n\t\t    rc = fsmVerify(fp->fpath, fi);\n\t\t}\n\t    } else {\n\t\trc = RPMERR_ENOENT;\n\t    }\n\n\t    /* See if the file was removed while our attention was elsewhere */\n\t    if (rc == RPMERR_ENOENT && fp->action == FA_TOUCH) {\n\t\trpmlog(RPMLOG_DEBUG, \"file %s vanished unexpectedly\\n\",\n\t\t\tfp->fpath);\n\t\tfp->action = FA_CREATE;\n\t\tfsmDebug(fp->fpath, fp->action, &fp->sb);\n\t    }\n\n\t    /* When touching we don't need any of this... */\n\t    if (fp->action == FA_TOUCH)\n\t\tcontinue;\n\n            if (S_ISREG(fp->sb.st_mode)) {\n\t\tif (rc == RPMERR_ENOENT) {\n\t\t    rc = fsmMkfile(fi, fp, files, psm, nodigest,\n\t\t\t\t   &firstlink, &firstlinkfile);\n\t\t}\n            } else if (S_ISDIR(fp->sb.st_mode)) {\n                if (rc == RPMERR_ENOENT) {\n                    mode_t mode = fp->sb.st_mode;\n                    mode &= ~07777;\n                    mode |=  00700;\n                    rc = fsmMkdir(di.dirfd, fp->fpath, mode);\n                }\n            } else if (S_ISLNK(fp->sb.st_mode)) {\n\t\tif (rc == RPMERR_ENOENT) {\n\t\t    rc = fsmSymlink(rpmfiFLink(fi), fp->fpath);\n\t\t}\n            } else if (S_ISFIFO(fp->sb.st_mode)) {\n                /* This mimics cpio S_ISSOCK() behavior but probably isn't right */\n                if (rc == RPMERR_ENOENT) {\n                    rc = fsmMkfifo(fp->fpath, 0000);\n                }\n            } else if (S_ISCHR(fp->sb.st_mode) ||\n                       S_ISBLK(fp->sb.st_mode) ||\n                       S_ISSOCK(fp->sb.st_mode))\n            {\n                if (rc == RPMERR_ENOENT) {\n                    rc = fsmMknod(fp->fpath, fp->sb.st_mode, fp->sb.st_rdev);\n                }\n            } else {\n                /* XXX Special case /dev/log, which shouldn't be packaged anyways */\n                if (!IS_DEV_LOG(fp->fpath))\n                    rc = RPMERR_UNKNOWN_FILETYPE;\n            }\n\t} else if (firstlink && rpmfiArchiveHasContent(fi)) {\n\t    /*\n\t     * Tricksy case: this file is a being skipped, but it's part of\n\t     * a hardlinked set and has the actual content linked with it.\n\t     * Write the content to the first non-skipped file of the set\n\t     * instead.\n\t     */\n\t    rc = fsmMkfile(fi, firstlink, files, psm, nodigest,\n\t\t\t   &firstlink, &firstlinkfile);\n\t}\n\n\t/* Notify on success. */\n\tif (rc)\n\t    *failedFile = xstrdup(fp->fpath);\n\telse\n\t    rpmpsmNotify(psm, RPMCALLBACK_INST_PROGRESS, rpmfiArchiveTell(fi));\n\tfp->stage = FILE_UNPACK;\n    }\n    fi = rpmfiFree(fi);\n    close(di.dirfd);\n    di.dirfd = -1;\n\n    if (!rc && fx < 0 && fx != RPMERR_ITER_END)\n\trc = fx;\n\n    /* Set permissions, timestamps etc for non-hardlink entries */\n    fi = rpmfilesIter(files, RPMFI_ITER_FWD);\n    while (!rc && (fx = rpmfiNext(fi)) >= 0) {\n\tstruct filedata_s *fp = &fdata[fx];\n\tif (!fp->skip && fp->setmeta) {\n\t    rc = fsmSetmeta(fp->fpath, fi, plugins, fp->action,\n\t\t\t    &fp->sb, nofcaps);\n\t}\n\tif (rc)\n\t    *failedFile = xstrdup(fp->fpath);\n\tfp->stage = FILE_PREP;\n    }\n    fi = rpmfiFree(fi);\n\n    /* If all went well, commit files to final destination */\n    fi = rpmfilesIter(files, RPMFI_ITER_FWD);\n    while (!rc && (fx = rpmfiNext(fi)) >= 0) {\n\tstruct filedata_s *fp = &fdata[fx];\n\n\tif (!fp->skip) {\n\t    /* Backup file if needed. Directories are handled earlier */\n\t    if (!rc && fp->suffix)\n\t\trc = fsmBackup(fi, fp->action);\n\n\t    if (!rc)\n\t\trc = fsmCommit(&fp->fpath, fi, fp->action, fp->suffix);\n\n\t    if (!rc)\n\t\tfp->stage = FILE_COMMIT;\n\t    else\n\t\t*failedFile = xstrdup(fp->fpath);\n\t}\n    }\n    fi = rpmfiFree(fi);\n\n    /* Walk backwards in case we need to erase */\n    fi = rpmfilesIter(files, RPMFI_ITER_BACK);\n    while ((fx = rpmfiNext(fi)) >= 0) {\n\tstruct filedata_s *fp = &fdata[fx];\n\t/* Run fsm file post hook for all plugins for all processed files */\n\tif (fp->stage) {\n\t    rpmpluginsCallFsmFilePost(plugins, fi, fp->fpath,\n\t\t\t\t      fp->sb.st_mode, fp->action, rc);\n\t}\n\n\t/* On failure, erase non-committed files */\n\tif (rc && fp->stage > FILE_NONE && !fp->skip) {\n\t    (void) fsmRemove(fp->fpath, fp->sb.st_mode);\n\t}\n    }\n\n    rpmswAdd(rpmtsOp(ts, RPMTS_OP_UNCOMPRESS), fdOp(payload, FDSTAT_READ));\n    rpmswAdd(rpmtsOp(ts, RPMTS_OP_DIGEST), fdOp(payload, FDSTAT_DIGEST));\n\nexit:\n    fi = rpmfiFree(fi);\n    Fclose(payload);\n    free(tid);\n    for (int i = 0; i < fc; i++)\n\tfree(fdata[i].fpath);\n    free(fdata);\n\n    return rc;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -14,6 +14,7 @@\n     char *tid = NULL;\n     struct filedata_s *fdata = xcalloc(fc, sizeof(*fdata));\n     struct filedata_s *firstlink = NULL;\n+    struct diriter_s di = { -1 };\n \n     /* transaction id used for temporary path suffix while installing */\n     rasprintf(&tid, \";%08x\", (unsigned)rpmtsGetTid(ts));\n@@ -56,6 +57,7 @@\n         rc = RPMERR_BAD_MAGIC;\n         goto exit;\n     }\n+    rpmfiSetOnChdir(fi, onChdir, &di);\n \n     /* Detect and create directories not explicitly in package. */\n     if (!rc)\n@@ -70,6 +72,16 @@\n \t    if (!fp->suffix) {\n \t\trc = fsmBackup(fi, fp->action);\n \t    }\n+\n+\t    if (di.dirfd == -1) {\n+\t\tdi.dirfd = ensureDir(plugins, rpmfiDN(fi), 0,\n+\t\t\t\t    (fp->action == FA_CREATE));\n+\t\tif (di.dirfd == -1) {\n+\t\t    rc = RPMERR_OPEN_FAILED;\n+\t\t    break;\n+\t\t}\n+\t    }\n+\n \t    /* Assume file does't exist when tmp suffix is in use */\n \t    if (!fp->suffix) {\n \t\tif (fp->action == FA_TOUCH) {\n@@ -104,7 +116,7 @@\n                     mode_t mode = fp->sb.st_mode;\n                     mode &= ~07777;\n                     mode |=  00700;\n-                    rc = fsmMkdir(fp->fpath, mode);\n+                    rc = fsmMkdir(di.dirfd, fp->fpath, mode);\n                 }\n             } else if (S_ISLNK(fp->sb.st_mode)) {\n \t\tif (rc == RPMERR_ENOENT) {\n@@ -146,6 +158,8 @@\n \tfp->stage = FILE_UNPACK;\n     }\n     fi = rpmfiFree(fi);\n+    close(di.dirfd);\n+    di.dirfd = -1;\n \n     if (!rc && fx < 0 && fx != RPMERR_ITER_END)\n \trc = fx;",
        "diff_line_info": {
            "deleted_lines": [
                "                    rc = fsmMkdir(fp->fpath, mode);"
            ],
            "added_lines": [
                "    struct diriter_s di = { -1 };",
                "    rpmfiSetOnChdir(fi, onChdir, &di);",
                "",
                "\t    if (di.dirfd == -1) {",
                "\t\tdi.dirfd = ensureDir(plugins, rpmfiDN(fi), 0,",
                "\t\t\t\t    (fp->action == FA_CREATE));",
                "\t\tif (di.dirfd == -1) {",
                "\t\t    rc = RPMERR_OPEN_FAILED;",
                "\t\t    break;",
                "\t\t}",
                "\t    }",
                "",
                "                    rc = fsmMkdir(di.dirfd, fp->fpath, mode);",
                "    close(di.dirfd);",
                "    di.dirfd = -1;"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-35939",
        "func_name": "rpm-software-management/rpm/fsmMkdirs",
        "description": "It was found that the fix for CVE-2017-7500 and CVE-2017-7501 was incomplete: the check was only implemented for the parent directory of the file to be created. A local unprivileged user who owns another ancestor directory could potentially use this flaw to gain root privileges. The highest threat from this vulnerability is to data confidentiality and integrity as well as system availability.",
        "git_url": "https://github.com/rpm-software-management/rpm/commit/96ec957e281220f8e137a2d5eb23b83a6377d556",
        "commit_title": "Validate intermediate symlinks during installation, CVE-2021-35939",
        "commit_text": " Whenever directory changes during unpacking, walk the entire tree from starting from / and validate any symlinks crossed, fail the install on invalid links.  This is the first of step of many towards securing our file operations against local tamperers and besides plugging that one CVE, paves the way for the next step by adding the necessary directory fd tracking. This also bumps the rpm OS requirements to a whole new level by requiring the *at() family of calls from POSIX-1.2008.  This necessarily does a whole lot of huffing and puffing we previously did not do. It should be possible to cache secure (ie root-owned) directory structures to avoid validating everything a million times but for now, just keeping things simple.",
        "func_before": "static int fsmMkdirs(rpmfiles files, rpmfs fs, rpmPlugins plugins)\n{\n    DNLI_t dnli = dnlInitIterator(files, fs, 0);\n    struct stat sb;\n    const char *dpath;\n    int rc = 0;\n    int i;\n    size_t ldnlen = 0;\n    const char * ldn = NULL;\n\n    while ((dpath = dnlNextIterator(dnli)) != NULL) {\n\tsize_t dnlen = strlen(dpath);\n\tchar * te, dn[dnlen+1];\n\n\tif (dnlen <= 1)\n\t    continue;\n\n\tif (dnlen == ldnlen && rstreq(dpath, ldn))\n\t    continue;\n\n\t/* Copy as we need to modify the string */\n\t(void) stpcpy(dn, dpath);\n\n\t/* Assume '/' directory exists, \"mkdir -p\" for others if non-existent */\n\tfor (i = 1, te = dn + 1; *te != '\\0'; te++, i++) {\n\t    if (*te != '/')\n\t\tcontinue;\n\n\t    /* Already validated? */\n\t    if (i < ldnlen &&\n\t\t(ldn[i] == '/' || ldn[i] == '\\0') && rstreqn(dn, ldn, i))\n\t\tcontinue;\n\n\t    /* Validate next component of path. */\n\t    *te = '\\0';\n\t    rc = fsmStat(dn, 1, &sb); /* lstat */\n\t    *te = '/';\n\n\t    /* Directory already exists? */\n\t    if (rc == 0 && S_ISDIR(sb.st_mode)) {\n\t\tcontinue;\n\t    } else if (rc == RPMERR_ENOENT) {\n\t\t*te = '\\0';\n\t\tmode_t mode = S_IFDIR | (_dirPerms & 07777);\n\t\trpmFsmOp op = (FA_CREATE|FAF_UNOWNED);\n\n\t\t/* Run fsm file pre hook for all plugins */\n\t\trc = rpmpluginsCallFsmFilePre(plugins, NULL, dn, mode, op);\n\n\t\tif (!rc)\n\t\t    rc = fsmMkdir(dn, mode);\n\n\t\tif (!rc) {\n\t\t    rc = rpmpluginsCallFsmFilePrepare(plugins, NULL, dn, dn,\n\t\t\t\t\t\t      mode, op);\n\t\t}\n\n\t\t/* Run fsm file post hook for all plugins */\n\t\trpmpluginsCallFsmFilePost(plugins, NULL, dn, mode, op, rc);\n\n\t\tif (!rc) {\n\t\t    rpmlog(RPMLOG_DEBUG,\n\t\t\t    \"%s directory created with perms %04o\\n\",\n\t\t\t    dn, (unsigned)(mode & 07777));\n\t\t}\n\t\t*te = '/';\n\t    }\n\t    if (rc)\n\t\tbreak;\n\t}\n\tif (rc) break;\n\n\t/* Save last validated path. */\n\tldn = dpath;\n\tldnlen = dnlen;\n    }\n    dnlFreeIterator(dnli);\n\n    return rc;\n}",
        "func": "static int fsmMkdirs(rpmfiles files, rpmfs fs, rpmPlugins plugins)\n{\n    DNLI_t dnli = dnlInitIterator(files, fs, 0);\n    struct stat sb;\n    const char *dpath;\n    int rc = 0;\n    int i;\n    size_t ldnlen = 0;\n    const char * ldn = NULL;\n\n    while ((dpath = dnlNextIterator(dnli)) != NULL) {\n\tsize_t dnlen = strlen(dpath);\n\tchar * te, dn[dnlen+1];\n\n\tif (dnlen <= 1)\n\t    continue;\n\n\tif (dnlen == ldnlen && rstreq(dpath, ldn))\n\t    continue;\n\n\t/* Copy as we need to modify the string */\n\t(void) stpcpy(dn, dpath);\n\n\t/* Assume '/' directory exists, \"mkdir -p\" for others if non-existent */\n\tfor (i = 1, te = dn + 1; *te != '\\0'; te++, i++) {\n\t    if (*te != '/')\n\t\tcontinue;\n\n\t    /* Already validated? */\n\t    if (i < ldnlen &&\n\t\t(ldn[i] == '/' || ldn[i] == '\\0') && rstreqn(dn, ldn, i))\n\t\tcontinue;\n\n\t    /* Validate next component of path. */\n\t    *te = '\\0';\n\t    rc = fsmStat(dn, 1, &sb); /* lstat */\n\t    *te = '/';\n\n\t    /* Directory already exists? */\n\t    if (rc == 0 && S_ISDIR(sb.st_mode)) {\n\t\tcontinue;\n\t    } else if (rc == RPMERR_ENOENT) {\n\t\t*te = '\\0';\n\t\tmode_t mode = S_IFDIR | (_dirPerms & 07777);\n\t\trpmFsmOp op = (FA_CREATE|FAF_UNOWNED);\n\n\t\t/* Run fsm file pre hook for all plugins */\n\t\trc = rpmpluginsCallFsmFilePre(plugins, NULL, dn, mode, op);\n\n\t\tif (!rc)\n\t\t    rc = fsmMkdir(-1, dn, mode);\n\n\t\tif (!rc) {\n\t\t    rc = rpmpluginsCallFsmFilePrepare(plugins, NULL, dn, dn,\n\t\t\t\t\t\t      mode, op);\n\t\t}\n\n\t\t/* Run fsm file post hook for all plugins */\n\t\trpmpluginsCallFsmFilePost(plugins, NULL, dn, mode, op, rc);\n\n\t\tif (!rc) {\n\t\t    rpmlog(RPMLOG_DEBUG,\n\t\t\t    \"%s directory created with perms %04o\\n\",\n\t\t\t    dn, (unsigned)(mode & 07777));\n\t\t}\n\t\t*te = '/';\n\t    }\n\t    if (rc)\n\t\tbreak;\n\t}\n\tif (rc) break;\n\n\t/* Save last validated path. */\n\tldn = dpath;\n\tldnlen = dnlen;\n    }\n    dnlFreeIterator(dnli);\n\n    return rc;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -48,7 +48,7 @@\n \t\trc = rpmpluginsCallFsmFilePre(plugins, NULL, dn, mode, op);\n \n \t\tif (!rc)\n-\t\t    rc = fsmMkdir(dn, mode);\n+\t\t    rc = fsmMkdir(-1, dn, mode);\n \n \t\tif (!rc) {\n \t\t    rc = rpmpluginsCallFsmFilePrepare(plugins, NULL, dn, dn,",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t    rc = fsmMkdir(dn, mode);"
            ],
            "added_lines": [
                "\t\t    rc = fsmMkdir(-1, dn, mode);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-35939",
        "func_name": "rpm-software-management/rpm/fsmMkdir",
        "description": "It was found that the fix for CVE-2017-7500 and CVE-2017-7501 was incomplete: the check was only implemented for the parent directory of the file to be created. A local unprivileged user who owns another ancestor directory could potentially use this flaw to gain root privileges. The highest threat from this vulnerability is to data confidentiality and integrity as well as system availability.",
        "git_url": "https://github.com/rpm-software-management/rpm/commit/96ec957e281220f8e137a2d5eb23b83a6377d556",
        "commit_title": "Validate intermediate symlinks during installation, CVE-2021-35939",
        "commit_text": " Whenever directory changes during unpacking, walk the entire tree from starting from / and validate any symlinks crossed, fail the install on invalid links.  This is the first of step of many towards securing our file operations against local tamperers and besides plugging that one CVE, paves the way for the next step by adding the necessary directory fd tracking. This also bumps the rpm OS requirements to a whole new level by requiring the *at() family of calls from POSIX-1.2008.  This necessarily does a whole lot of huffing and puffing we previously did not do. It should be possible to cache secure (ie root-owned) directory structures to avoid validating everything a million times but for now, just keeping things simple.",
        "func_before": "static int fsmMkdir(const char *path, mode_t mode)\n{\n    int rc = mkdir(path, (mode & 07777));\n    if (_fsm_debug)\n\trpmlog(RPMLOG_DEBUG, \" %8s (%s, 0%04o) %s\\n\", __func__,\n\t       path, (unsigned)(mode & 07777),\n\t       (rc < 0 ? strerror(errno) : \"\"));\n    if (rc < 0)\trc = RPMERR_MKDIR_FAILED;\n    return rc;\n}",
        "func": "static int fsmMkdir(int dirfd, const char *path, mode_t mode)\n{\n    int rc = mkdirat(dirfd, path, (mode & 07777));\n    if (_fsm_debug)\n\trpmlog(RPMLOG_DEBUG, \" %8s (%d %s, 0%04o) %s\\n\", __func__,\n\t       dirfd, path, (unsigned)(mode & 07777),\n\t       (rc < 0 ? strerror(errno) : \"\"));\n    if (rc < 0)\trc = RPMERR_MKDIR_FAILED;\n    return rc;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,9 +1,9 @@\n-static int fsmMkdir(const char *path, mode_t mode)\n+static int fsmMkdir(int dirfd, const char *path, mode_t mode)\n {\n-    int rc = mkdir(path, (mode & 07777));\n+    int rc = mkdirat(dirfd, path, (mode & 07777));\n     if (_fsm_debug)\n-\trpmlog(RPMLOG_DEBUG, \" %8s (%s, 0%04o) %s\\n\", __func__,\n-\t       path, (unsigned)(mode & 07777),\n+\trpmlog(RPMLOG_DEBUG, \" %8s (%d %s, 0%04o) %s\\n\", __func__,\n+\t       dirfd, path, (unsigned)(mode & 07777),\n \t       (rc < 0 ? strerror(errno) : \"\"));\n     if (rc < 0)\trc = RPMERR_MKDIR_FAILED;\n     return rc;",
        "diff_line_info": {
            "deleted_lines": [
                "static int fsmMkdir(const char *path, mode_t mode)",
                "    int rc = mkdir(path, (mode & 07777));",
                "\trpmlog(RPMLOG_DEBUG, \" %8s (%s, 0%04o) %s\\n\", __func__,",
                "\t       path, (unsigned)(mode & 07777),"
            ],
            "added_lines": [
                "static int fsmMkdir(int dirfd, const char *path, mode_t mode)",
                "    int rc = mkdirat(dirfd, path, (mode & 07777));",
                "\trpmlog(RPMLOG_DEBUG, \" %8s (%d %s, 0%04o) %s\\n\", __func__,",
                "\t       dirfd, path, (unsigned)(mode & 07777),"
            ]
        }
    },
    {
        "cve_id": "CVE-2011-4028",
        "func_name": "xorg/xserver/LockServer",
        "description": "The LockServer function in os/utils.c in X.Org xserver before 1.11.2 allows local users to determine the existence of arbitrary files via a symlink attack on a temporary lock file, which is handled differently if the file exists.",
        "git_url": "http://cgit.freedesktop.org/xorg/xserver/commit/?id=6ba44b91e37622ef8c146d8f2ac92d708a18ed34",
        "commit_title": "use O_NOFOLLOW to open the existing lock file, so symbolic links",
        "commit_text": "aren't followed, thus avoid revealing if it point to an existing file.  ",
        "func_before": "void\nLockServer(void)\n{\n  char tmp[PATH_MAX], pid_str[12];\n  int lfd, i, haslock, l_pid, t;\n  char *tmppath = NULL;\n  int len;\n  char port[20];\n\n  if (nolock) return;\n  /*\n   * Path names\n   */\n  tmppath = LOCK_DIR;\n\n  sprintf(port, \"%d\", atoi(display));\n  len = strlen(LOCK_PREFIX) > strlen(LOCK_TMP_PREFIX) ? strlen(LOCK_PREFIX) :\n\t\t\t\t\t\tstrlen(LOCK_TMP_PREFIX);\n  len += strlen(tmppath) + strlen(port) + strlen(LOCK_SUFFIX) + 1;\n  if (len > sizeof(LockFile))\n    FatalError(\"Display name `%s' is too long\\n\", port);\n  (void)sprintf(tmp, \"%s\" LOCK_TMP_PREFIX \"%s\" LOCK_SUFFIX, tmppath, port);\n  (void)sprintf(LockFile, \"%s\" LOCK_PREFIX \"%s\" LOCK_SUFFIX, tmppath, port);\n\n  /*\n   * Create a temporary file containing our PID.  Attempt three times\n   * to create the file.\n   */\n  StillLocking = TRUE;\n  i = 0;\n  do {\n    i++;\n    lfd = open(tmp, O_CREAT | O_EXCL | O_WRONLY, 0644);\n    if (lfd < 0)\n       sleep(2);\n    else\n       break;\n  } while (i < 3);\n  if (lfd < 0) {\n    unlink(tmp);\n    i = 0;\n    do {\n      i++;\n      lfd = open(tmp, O_CREAT | O_EXCL | O_WRONLY, 0644);\n      if (lfd < 0)\n         sleep(2);\n      else\n         break;\n    } while (i < 3);\n  }\n  if (lfd < 0)\n    FatalError(\"Could not create lock file in %s\\n\", tmp);\n  (void) sprintf(pid_str, \"%10ld\\n\", (long)getpid());\n  (void) write(lfd, pid_str, 11);\n  (void) chmod(tmp, 0444);\n  (void) close(lfd);\n\n  /*\n   * OK.  Now the tmp file exists.  Try three times to move it in place\n   * for the lock.\n   */\n  i = 0;\n  haslock = 0;\n  while ((!haslock) && (i++ < 3)) {\n    haslock = (link(tmp,LockFile) == 0);\n    if (haslock) {\n      /*\n       * We're done.\n       */\n      break;\n    }\n    else {\n      /*\n       * Read the pid from the existing file\n       */\n      lfd = open(LockFile, O_RDONLY);\n      if (lfd < 0) {\n        unlink(tmp);\n        FatalError(\"Can't read lock file %s\\n\", LockFile);\n      }\n      pid_str[0] = '\\0';\n      if (read(lfd, pid_str, 11) != 11) {\n        /*\n         * Bogus lock file.\n         */\n        unlink(LockFile);\n        close(lfd);\n        continue;\n      }\n      pid_str[11] = '\\0';\n      sscanf(pid_str, \"%d\", &l_pid);\n      close(lfd);\n\n      /*\n       * Now try to kill the PID to see if it exists.\n       */\n      errno = 0;\n      t = kill(l_pid, 0);\n      if ((t< 0) && (errno == ESRCH)) {\n        /*\n         * Stale lock file.\n         */\n        unlink(LockFile);\n        continue;\n      }\n      else if (((t < 0) && (errno == EPERM)) || (t == 0)) {\n        /*\n         * Process is still active.\n         */\n        unlink(tmp);\n\tFatalError(\"Server is already active for display %s\\n%s %s\\n%s\\n\",\n\t\t   port, \"\\tIf this server is no longer running, remove\",\n\t\t   LockFile, \"\\tand start again.\");\n      }\n    }\n  }\n  unlink(tmp);\n  if (!haslock)\n    FatalError(\"Could not create server lock file: %s\\n\", LockFile);\n  StillLocking = FALSE;\n}",
        "func": "void\nLockServer(void)\n{\n  char tmp[PATH_MAX], pid_str[12];\n  int lfd, i, haslock, l_pid, t;\n  char *tmppath = NULL;\n  int len;\n  char port[20];\n\n  if (nolock) return;\n  /*\n   * Path names\n   */\n  tmppath = LOCK_DIR;\n\n  sprintf(port, \"%d\", atoi(display));\n  len = strlen(LOCK_PREFIX) > strlen(LOCK_TMP_PREFIX) ? strlen(LOCK_PREFIX) :\n\t\t\t\t\t\tstrlen(LOCK_TMP_PREFIX);\n  len += strlen(tmppath) + strlen(port) + strlen(LOCK_SUFFIX) + 1;\n  if (len > sizeof(LockFile))\n    FatalError(\"Display name `%s' is too long\\n\", port);\n  (void)sprintf(tmp, \"%s\" LOCK_TMP_PREFIX \"%s\" LOCK_SUFFIX, tmppath, port);\n  (void)sprintf(LockFile, \"%s\" LOCK_PREFIX \"%s\" LOCK_SUFFIX, tmppath, port);\n\n  /*\n   * Create a temporary file containing our PID.  Attempt three times\n   * to create the file.\n   */\n  StillLocking = TRUE;\n  i = 0;\n  do {\n    i++;\n    lfd = open(tmp, O_CREAT | O_EXCL | O_WRONLY, 0644);\n    if (lfd < 0)\n       sleep(2);\n    else\n       break;\n  } while (i < 3);\n  if (lfd < 0) {\n    unlink(tmp);\n    i = 0;\n    do {\n      i++;\n      lfd = open(tmp, O_CREAT | O_EXCL | O_WRONLY, 0644);\n      if (lfd < 0)\n         sleep(2);\n      else\n         break;\n    } while (i < 3);\n  }\n  if (lfd < 0)\n    FatalError(\"Could not create lock file in %s\\n\", tmp);\n  (void) sprintf(pid_str, \"%10ld\\n\", (long)getpid());\n  (void) write(lfd, pid_str, 11);\n  (void) chmod(tmp, 0444);\n  (void) close(lfd);\n\n  /*\n   * OK.  Now the tmp file exists.  Try three times to move it in place\n   * for the lock.\n   */\n  i = 0;\n  haslock = 0;\n  while ((!haslock) && (i++ < 3)) {\n    haslock = (link(tmp,LockFile) == 0);\n    if (haslock) {\n      /*\n       * We're done.\n       */\n      break;\n    }\n    else {\n      /*\n       * Read the pid from the existing file\n       */\n      lfd = open(LockFile, O_RDONLY|O_NOFOLLOW);\n      if (lfd < 0) {\n        unlink(tmp);\n        FatalError(\"Can't read lock file %s\\n\", LockFile);\n      }\n      pid_str[0] = '\\0';\n      if (read(lfd, pid_str, 11) != 11) {\n        /*\n         * Bogus lock file.\n         */\n        unlink(LockFile);\n        close(lfd);\n        continue;\n      }\n      pid_str[11] = '\\0';\n      sscanf(pid_str, \"%d\", &l_pid);\n      close(lfd);\n\n      /*\n       * Now try to kill the PID to see if it exists.\n       */\n      errno = 0;\n      t = kill(l_pid, 0);\n      if ((t< 0) && (errno == ESRCH)) {\n        /*\n         * Stale lock file.\n         */\n        unlink(LockFile);\n        continue;\n      }\n      else if (((t < 0) && (errno == EPERM)) || (t == 0)) {\n        /*\n         * Process is still active.\n         */\n        unlink(tmp);\n\tFatalError(\"Server is already active for display %s\\n%s %s\\n%s\\n\",\n\t\t   port, \"\\tIf this server is no longer running, remove\",\n\t\t   LockFile, \"\\tand start again.\");\n      }\n    }\n  }\n  unlink(tmp);\n  if (!haslock)\n    FatalError(\"Could not create server lock file: %s\\n\", LockFile);\n  StillLocking = FALSE;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -73,7 +73,7 @@\n       /*\n        * Read the pid from the existing file\n        */\n-      lfd = open(LockFile, O_RDONLY);\n+      lfd = open(LockFile, O_RDONLY|O_NOFOLLOW);\n       if (lfd < 0) {\n         unlink(tmp);\n         FatalError(\"Can't read lock file %s\\n\", LockFile);",
        "diff_line_info": {
            "deleted_lines": [
                "      lfd = open(LockFile, O_RDONLY);"
            ],
            "added_lines": [
                "      lfd = open(LockFile, O_RDONLY|O_NOFOLLOW);"
            ]
        }
    },
    {
        "cve_id": "CVE-2013-4136",
        "func_name": "phusion/passenger/initialize",
        "description": "ext/common/ServerInstanceDir.h in Phusion Passenger gem before 4.0.6 for Ruby allows local users to gain privileges or possibly change the ownership of arbitrary directories via a symlink attack on a directory with a predictable name in /tmp/.",
        "git_url": "https://github.com/phusion/passenger/commit/5483b3292cc2af1c83033eaaadec20dba4dcfd9b",
        "commit_title": "If the server instance directory already exists, it is now removed first in order get correct directory permissions.",
        "commit_text": "If the directory still exists after removal, Phusion Passenger aborts to avoid writing to a directory with unexpected permissions. Fixes issue #910.",
        "func_before": "void initialize(const string &path, bool owner) {\n\t\tTRACE_POINT();\n\t\tthis->path  = path;\n\t\tthis->owner = owner;\n\t\t\n\t\t/* Create the server instance directory. We only need to write to this\n\t\t * directory for these reasons:\n\t\t * 1. Initial population of structure files (structure_version.txt, instance.pid).\n\t\t * 2. Creating/removing a generation directory.\n\t\t * 3. Removing the entire server instance directory (after all\n\t\t *    generations are removed).\n\t\t *\n\t\t * 1 and 2 are done by the helper server during initialization and before lowering\n\t\t * privilege. 3 is done during helper server shutdown by a cleanup process that's\n\t\t * running as the same user the helper server was running as before privilege\n\t\t * lowering.\n\t\t * Therefore, we make the directory only writable by the user the helper server\n\t\t * was running as before privilege is lowered. Everybody else has read and execute\n\t\t * rights though, because we want admin tools to be able to list the available\n\t\t * generations no matter what user they're running as.\n\t\t */\n\t\tmakeDirTree(path, \"u=rwx,g=rx,o=rx\");\n\t}",
        "func": "void initialize(const string &path, bool owner) {\n\t\tTRACE_POINT();\n\t\tthis->path  = path;\n\t\tthis->owner = owner;\n\t\t\n\t\t/* Create the server instance directory. We only need to write to this\n\t\t * directory for these reasons:\n\t\t * 1. Initial population of structure files (structure_version.txt, instance.pid).\n\t\t * 2. Creating/removing a generation directory.\n\t\t * 3. Removing the entire server instance directory (after all\n\t\t *    generations are removed).\n\t\t *\n\t\t * 1 and 2 are done by the helper server during initialization and before lowering\n\t\t * privilege. 3 is done during helper server shutdown by a cleanup process that's\n\t\t * running as the same user the helper server was running as before privilege\n\t\t * lowering.\n\t\t * Therefore, we make the directory only writable by the user the helper server\n\t\t * was running as before privilege is lowered. Everybody else has read and execute\n\t\t * rights though, because we want admin tools to be able to list the available\n\t\t * generations no matter what user they're running as.\n\t\t */\n\t\tif (owner) {\n\t\t\tswitch (getFileType(path)) {\n\t\t\tcase FT_NONEXISTANT:\n\t\t\t\tcreateDirectory(path);\n\t\t\t\tbreak;\n\t\t\tcase FT_DIRECTORY:\n\t\t\t\tremoveDirTree(path);\n\t\t\t\tcreateDirectory(path);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow RuntimeException(\"'\" + path + \"' already exists, and is not a directory\");\n\t\t\t}\n\t\t} else if (getFileType(path) != FT_DIRECTORY) {\n\t\t\tthrow RuntimeException(\"Server instance directory '\" + path +\n\t\t\t\t\"' does not exist\");\n\t\t}\n\t}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -19,5 +19,20 @@\n \t\t * rights though, because we want admin tools to be able to list the available\n \t\t * generations no matter what user they're running as.\n \t\t */\n-\t\tmakeDirTree(path, \"u=rwx,g=rx,o=rx\");\n+\t\tif (owner) {\n+\t\t\tswitch (getFileType(path)) {\n+\t\t\tcase FT_NONEXISTANT:\n+\t\t\t\tcreateDirectory(path);\n+\t\t\t\tbreak;\n+\t\t\tcase FT_DIRECTORY:\n+\t\t\t\tremoveDirTree(path);\n+\t\t\t\tcreateDirectory(path);\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\tthrow RuntimeException(\"'\" + path + \"' already exists, and is not a directory\");\n+\t\t\t}\n+\t\t} else if (getFileType(path) != FT_DIRECTORY) {\n+\t\t\tthrow RuntimeException(\"Server instance directory '\" + path +\n+\t\t\t\t\"' does not exist\");\n+\t\t}\n \t}",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tmakeDirTree(path, \"u=rwx,g=rx,o=rx\");"
            ],
            "added_lines": [
                "\t\tif (owner) {",
                "\t\t\tswitch (getFileType(path)) {",
                "\t\t\tcase FT_NONEXISTANT:",
                "\t\t\t\tcreateDirectory(path);",
                "\t\t\t\tbreak;",
                "\t\t\tcase FT_DIRECTORY:",
                "\t\t\t\tremoveDirTree(path);",
                "\t\t\t\tcreateDirectory(path);",
                "\t\t\t\tbreak;",
                "\t\t\tdefault:",
                "\t\t\t\tthrow RuntimeException(\"'\" + path + \"' already exists, and is not a directory\");",
                "\t\t\t}",
                "\t\t} else if (getFileType(path) != FT_DIRECTORY) {",
                "\t\t\tthrow RuntimeException(\"Server instance directory '\" + path +",
                "\t\t\t\t\"' does not exist\");",
                "\t\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2012-0871",
        "func_name": "systemd/session_link_x11_socket",
        "description": "The session_link_x11_socket function in login/logind-session.c in systemd-logind in systemd, possibly 37 and earlier, allows local users to create or overwrite arbitrary files via a symlink attack on the X11 user directory in /run/user/.",
        "git_url": "http://cgit.freedesktop.org/systemd/systemd/commit/?id=fc3c1c6e091ea16ad5600b145201ec535bbb5d7c",
        "commit_title": "",
        "commit_text": "",
        "func_before": "static int session_link_x11_socket(Session *s) {\n        char *t, *f, *c;\n        size_t k;\n\n        assert(s);\n        assert(s->user);\n        assert(s->user->runtime_path);\n\n        if (s->user->display)\n                return 0;\n\n        if (!s->display || !display_is_local(s->display))\n                return 0;\n\n        k = strspn(s->display+1, \"0123456789\");\n        f = new(char, sizeof(\"/tmp/.X11-unix/X\") + k);\n        if (!f) {\n                log_error(\"Out of memory\");\n                return -ENOMEM;\n        }\n\n        c = stpcpy(f, \"/tmp/.X11-unix/X\");\n        memcpy(c, s->display+1, k);\n        c[k] = 0;\n\n        if (access(f, F_OK) < 0) {\n                log_warning(\"Session %s has display %s with nonexisting socket %s.\", s->id, s->display, f);\n                free(f);\n                return -ENOENT;\n        }\n\n        t = strappend(s->user->runtime_path, \"/X11/display\");\n        if (!t) {\n                log_error(\"Out of memory\");\n                free(f);\n                return -ENOMEM;\n        }\n\n        mkdir_parents(t, 0755);\n\n        if (link(f, t) < 0) {\n                if (errno == EEXIST) {\n                        unlink(t);\n\n                        if (link(f, t) >= 0)\n                                goto done;\n                }\n\n                if (symlink(f, t) < 0) {\n\n                        if (errno == EEXIST) {\n                                unlink(t);\n\n                                if (symlink(f, t) >= 0)\n                                        goto done;\n                        }\n\n                        log_error(\"Failed to link %s to %s: %m\", f, t);\n                        free(f);\n                        free(t);\n                        return -errno;\n                }\n        }\n\ndone:\n        log_info(\"Linked %s to %s.\", f, t);\n        free(f);\n        free(t);\n\n        s->user->display = s;\n\n        return 0;\n}",
        "func": "static int session_link_x11_socket(Session *s) {\n        char *t, *f, *c;\n        size_t k;\n\n        assert(s);\n        assert(s->user);\n        assert(s->user->runtime_path);\n\n        if (s->user->display)\n                return 0;\n\n        if (!s->display || !display_is_local(s->display))\n                return 0;\n\n        k = strspn(s->display+1, \"0123456789\");\n        f = new(char, sizeof(\"/tmp/.X11-unix/X\") + k);\n        if (!f) {\n                log_error(\"Out of memory\");\n                return -ENOMEM;\n        }\n\n        c = stpcpy(f, \"/tmp/.X11-unix/X\");\n        memcpy(c, s->display+1, k);\n        c[k] = 0;\n\n        if (access(f, F_OK) < 0) {\n                log_warning(\"Session %s has display %s with nonexisting socket %s.\", s->id, s->display, f);\n                free(f);\n                return -ENOENT;\n        }\n\n        t = strappend(s->user->runtime_path, \"/X11-display\");\n        if (!t) {\n                log_error(\"Out of memory\");\n                free(f);\n                return -ENOMEM;\n        }\n\n        if (link(f, t) < 0) {\n                if (errno == EEXIST) {\n                        unlink(t);\n\n                        if (link(f, t) >= 0)\n                                goto done;\n                }\n\n                if (symlink(f, t) < 0) {\n\n                        if (errno == EEXIST) {\n                                unlink(t);\n\n                                if (symlink(f, t) >= 0)\n                                        goto done;\n                        }\n\n                        log_error(\"Failed to link %s to %s: %m\", f, t);\n                        free(f);\n                        free(t);\n                        return -errno;\n                }\n        }\n\ndone:\n        log_info(\"Linked %s to %s.\", f, t);\n        free(f);\n        free(t);\n\n        s->user->display = s;\n\n        return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -29,14 +29,12 @@\n                 return -ENOENT;\n         }\n \n-        t = strappend(s->user->runtime_path, \"/X11/display\");\n+        t = strappend(s->user->runtime_path, \"/X11-display\");\n         if (!t) {\n                 log_error(\"Out of memory\");\n                 free(f);\n                 return -ENOMEM;\n         }\n-\n-        mkdir_parents(t, 0755);\n \n         if (link(f, t) < 0) {\n                 if (errno == EEXIST) {",
        "diff_line_info": {
            "deleted_lines": [
                "        t = strappend(s->user->runtime_path, \"/X11/display\");",
                "",
                "        mkdir_parents(t, 0755);"
            ],
            "added_lines": [
                "        t = strappend(s->user->runtime_path, \"/X11-display\");"
            ]
        }
    },
    {
        "cve_id": "CVE-2012-0871",
        "func_name": "systemd/session_unlink_x11_socket",
        "description": "The session_link_x11_socket function in login/logind-session.c in systemd-logind in systemd, possibly 37 and earlier, allows local users to create or overwrite arbitrary files via a symlink attack on the X11 user directory in /run/user/.",
        "git_url": "http://cgit.freedesktop.org/systemd/systemd/commit/?id=fc3c1c6e091ea16ad5600b145201ec535bbb5d7c",
        "commit_title": "",
        "commit_text": "",
        "func_before": "static int session_unlink_x11_socket(Session *s) {\n        char *t;\n        int r;\n\n        assert(s);\n        assert(s->user);\n\n        if (s->user->display != s)\n                return 0;\n\n        s->user->display = NULL;\n\n        t = strappend(s->user->runtime_path, \"/X11/display\");\n        if (!t) {\n                log_error(\"Out of memory\");\n                return -ENOMEM;\n        }\n\n        r = unlink(t);\n        free(t);\n\n        return r < 0 ? -errno : 0;\n}",
        "func": "static int session_unlink_x11_socket(Session *s) {\n        char *t;\n        int r;\n\n        assert(s);\n        assert(s->user);\n\n        if (s->user->display != s)\n                return 0;\n\n        s->user->display = NULL;\n\n        t = strappend(s->user->runtime_path, \"/X11-display\");\n        if (!t) {\n                log_error(\"Out of memory\");\n                return -ENOMEM;\n        }\n\n        r = unlink(t);\n        free(t);\n\n        return r < 0 ? -errno : 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -10,7 +10,7 @@\n \n         s->user->display = NULL;\n \n-        t = strappend(s->user->runtime_path, \"/X11/display\");\n+        t = strappend(s->user->runtime_path, \"/X11-display\");\n         if (!t) {\n                 log_error(\"Out of memory\");\n                 return -ENOMEM;",
        "diff_line_info": {
            "deleted_lines": [
                "        t = strappend(s->user->runtime_path, \"/X11/display\");"
            ],
            "added_lines": [
                "        t = strappend(s->user->runtime_path, \"/X11-display\");"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-15861",
        "func_name": "net-snmp/add_mibfile",
        "description": "Net-SNMP through 5.7.3 allows Escalation of Privileges because of UNIX symbolic link (symlink) following.",
        "git_url": "https://github.com/net-snmp/net-snmp/commit/4fd9a450444a434a993bc72f7c3486ccce41f602",
        "commit_title": "CHANGES: snmpd: Stop reading and writing the mib_indexes/* files",
        "commit_text": " Caching directory contents is something the operating system should do and is not something Net-SNMP should do. Instead of storing a copy of the directory contents in ${tmp_dir}/mib_indexes/${n}, always scan a MIB directory.",
        "func_before": "int\nadd_mibfile(const char* tmpstr, const char* d_name, FILE *ip )\n{\n    FILE           *fp;\n    char            token[MAXTOKEN], token2[MAXTOKEN];\n\n    /*\n     * which module is this \n     */\n    if ((fp = fopen(tmpstr, \"r\")) == NULL) {\n        snmp_log_perror(tmpstr);\n        return 1;\n    }\n    DEBUGMSGTL((\"parse-mibs\", \"Checking file: %s...\\n\",\n                tmpstr));\n    mibLine = 1;\n    File = tmpstr;\n    if (get_token(fp, token, MAXTOKEN) != LABEL) {\n\t    fclose(fp);\n\t    return 1;\n    }\n    /*\n     * simple test for this being a MIB \n     */\n    if (get_token(fp, token2, MAXTOKEN) == DEFINITIONS) {\n        new_module(token, tmpstr);\n        if (ip)\n            fprintf(ip, \"%s %s\\n\", token, d_name);\n        fclose(fp);\n        return 0;\n    } else {\n        fclose(fp);\n        return 1;\n    }\n}",
        "func": "int\nadd_mibfile(const char* tmpstr, const char* d_name)\n{\n    FILE           *fp;\n    char            token[MAXTOKEN], token2[MAXTOKEN];\n\n    /*\n     * which module is this \n     */\n    if ((fp = fopen(tmpstr, \"r\")) == NULL) {\n        snmp_log_perror(tmpstr);\n        return 1;\n    }\n    DEBUGMSGTL((\"parse-mibs\", \"Checking file: %s...\\n\",\n                tmpstr));\n    mibLine = 1;\n    File = tmpstr;\n    if (get_token(fp, token, MAXTOKEN) != LABEL) {\n\t    fclose(fp);\n\t    return 1;\n    }\n    /*\n     * simple test for this being a MIB \n     */\n    if (get_token(fp, token2, MAXTOKEN) == DEFINITIONS) {\n        new_module(token, tmpstr);\n        fclose(fp);\n        return 0;\n    } else {\n        fclose(fp);\n        return 1;\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,5 @@\n int\n-add_mibfile(const char* tmpstr, const char* d_name, FILE *ip )\n+add_mibfile(const char* tmpstr, const char* d_name)\n {\n     FILE           *fp;\n     char            token[MAXTOKEN], token2[MAXTOKEN];\n@@ -24,8 +24,6 @@\n      */\n     if (get_token(fp, token2, MAXTOKEN) == DEFINITIONS) {\n         new_module(token, tmpstr);\n-        if (ip)\n-            fprintf(ip, \"%s %s\\n\", token, d_name);\n         fclose(fp);\n         return 0;\n     } else {",
        "diff_line_info": {
            "deleted_lines": [
                "add_mibfile(const char* tmpstr, const char* d_name, FILE *ip )",
                "        if (ip)",
                "            fprintf(ip, \"%s %s\\n\", token, d_name);"
            ],
            "added_lines": [
                "add_mibfile(const char* tmpstr, const char* d_name)"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-15861",
        "func_name": "net-snmp/add_mibdir",
        "description": "Net-SNMP through 5.7.3 allows Escalation of Privileges because of UNIX symbolic link (symlink) following.",
        "git_url": "https://github.com/net-snmp/net-snmp/commit/4fd9a450444a434a993bc72f7c3486ccce41f602",
        "commit_title": "CHANGES: snmpd: Stop reading and writing the mib_indexes/* files",
        "commit_text": " Caching directory contents is something the operating system should do and is not something Net-SNMP should do. Instead of storing a copy of the directory contents in ${tmp_dir}/mib_indexes/${n}, always scan a MIB directory.",
        "func_before": "int\nadd_mibdir(const char *dirname)\n{\n    FILE           *ip;\n    const char     *oldFile = File;\n    char          **filenames;\n    int             count = 0;\n    int             filename_count, i;\n#if !(defined(WIN32) || defined(cygwin))\n    char           *token;\n    char space;\n    char newline;\n    struct stat     dir_stat, idx_stat;\n    char            tmpstr[300];\n    char            tmpstr1[300];\n#endif\n\n    DEBUGMSGTL((\"parse-mibs\", \"Scanning directory %s\\n\", dirname));\n#if !(defined(WIN32) || defined(cygwin))\n    token = netsnmp_mibindex_lookup( dirname );\n    if (token && stat(token, &idx_stat) == 0 && stat(dirname, &dir_stat) == 0) {\n        if (dir_stat.st_mtime < idx_stat.st_mtime) {\n            DEBUGMSGTL((\"parse-mibs\", \"The index is good\\n\"));\n            if ((ip = fopen(token, \"r\")) != NULL) {\n                fgets(tmpstr, sizeof(tmpstr), ip); /* Skip dir line */\n                while (fscanf(ip, \"%127s%c%299[^\\n]%c\", token, &space, tmpstr,\n\t\t    &newline) == 4) {\n\n\t\t    /*\n\t\t     * If an overflow of the token or tmpstr buffers has been\n\t\t     * found log a message and break out of the while loop,\n\t\t     * thus the rest of the file tokens will be ignored.\n\t\t     */\n\t\t    if (space != ' ' || newline != '\\n') {\n\t\t\tsnmp_log(LOG_ERR,\n\t\t\t    \"add_mibdir: strings scanned in from %s/%s \" \\\n\t\t\t    \"are too large.  count = %d\\n \", dirname,\n\t\t\t    \".index\", count);\n\t\t\t    break;\n\t\t    }\n\t\t   \n\t\t    snprintf(tmpstr1, sizeof(tmpstr1), \"%s/%s\", dirname, tmpstr);\n                    tmpstr1[ sizeof(tmpstr1)-1 ] = 0;\n                    new_module(token, tmpstr1);\n                    count++;\n                }\n                fclose(ip);\n                return count;\n            } else\n                DEBUGMSGTL((\"parse-mibs\", \"Can't read index\\n\"));\n        } else\n            DEBUGMSGTL((\"parse-mibs\", \"Index outdated\\n\"));\n    } else\n        DEBUGMSGTL((\"parse-mibs\", \"No index\\n\"));\n#endif\n\n    filename_count = scan_directory(&filenames, dirname);\n\n    if (filename_count >= 0) {\n        ip = netsnmp_mibindex_new(dirname);\n        for (i = 0; i < filename_count; i++) {\n            if (add_mibfile(filenames[i], strrchr(filenames[i], '/'), ip) == 0)\n                count++;\n\t    free(filenames[i]);\n        }\n        File = oldFile;\n        if (ip)\n            fclose(ip);\n        free(filenames);\n        return (count);\n    }\n    else\n        DEBUGMSGTL((\"parse-mibs\",\"cannot open MIB directory %s\\n\", dirname));\n\n    return (-1);\n}",
        "func": "int\nadd_mibdir(const char *dirname)\n{\n    const char     *oldFile = File;\n    char          **filenames;\n    int             count = 0;\n    int             filename_count, i;\n\n    DEBUGMSGTL((\"parse-mibs\", \"Scanning directory %s\\n\", dirname));\n\n    filename_count = scan_directory(&filenames, dirname);\n\n    if (filename_count >= 0) {\n        for (i = 0; i < filename_count; i++) {\n            if (add_mibfile(filenames[i], strrchr(filenames[i], '/')) == 0)\n                count++;\n\t    free(filenames[i]);\n        }\n        File = oldFile;\n        free(filenames);\n        return (count);\n    }\n    else\n        DEBUGMSGTL((\"parse-mibs\",\"cannot open MIB directory %s\\n\", dirname));\n\n    return (-1);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,71 +1,22 @@\n int\n add_mibdir(const char *dirname)\n {\n-    FILE           *ip;\n     const char     *oldFile = File;\n     char          **filenames;\n     int             count = 0;\n     int             filename_count, i;\n-#if !(defined(WIN32) || defined(cygwin))\n-    char           *token;\n-    char space;\n-    char newline;\n-    struct stat     dir_stat, idx_stat;\n-    char            tmpstr[300];\n-    char            tmpstr1[300];\n-#endif\n \n     DEBUGMSGTL((\"parse-mibs\", \"Scanning directory %s\\n\", dirname));\n-#if !(defined(WIN32) || defined(cygwin))\n-    token = netsnmp_mibindex_lookup( dirname );\n-    if (token && stat(token, &idx_stat) == 0 && stat(dirname, &dir_stat) == 0) {\n-        if (dir_stat.st_mtime < idx_stat.st_mtime) {\n-            DEBUGMSGTL((\"parse-mibs\", \"The index is good\\n\"));\n-            if ((ip = fopen(token, \"r\")) != NULL) {\n-                fgets(tmpstr, sizeof(tmpstr), ip); /* Skip dir line */\n-                while (fscanf(ip, \"%127s%c%299[^\\n]%c\", token, &space, tmpstr,\n-\t\t    &newline) == 4) {\n-\n-\t\t    /*\n-\t\t     * If an overflow of the token or tmpstr buffers has been\n-\t\t     * found log a message and break out of the while loop,\n-\t\t     * thus the rest of the file tokens will be ignored.\n-\t\t     */\n-\t\t    if (space != ' ' || newline != '\\n') {\n-\t\t\tsnmp_log(LOG_ERR,\n-\t\t\t    \"add_mibdir: strings scanned in from %s/%s \" \\\n-\t\t\t    \"are too large.  count = %d\\n \", dirname,\n-\t\t\t    \".index\", count);\n-\t\t\t    break;\n-\t\t    }\n-\t\t   \n-\t\t    snprintf(tmpstr1, sizeof(tmpstr1), \"%s/%s\", dirname, tmpstr);\n-                    tmpstr1[ sizeof(tmpstr1)-1 ] = 0;\n-                    new_module(token, tmpstr1);\n-                    count++;\n-                }\n-                fclose(ip);\n-                return count;\n-            } else\n-                DEBUGMSGTL((\"parse-mibs\", \"Can't read index\\n\"));\n-        } else\n-            DEBUGMSGTL((\"parse-mibs\", \"Index outdated\\n\"));\n-    } else\n-        DEBUGMSGTL((\"parse-mibs\", \"No index\\n\"));\n-#endif\n \n     filename_count = scan_directory(&filenames, dirname);\n \n     if (filename_count >= 0) {\n-        ip = netsnmp_mibindex_new(dirname);\n         for (i = 0; i < filename_count; i++) {\n-            if (add_mibfile(filenames[i], strrchr(filenames[i], '/'), ip) == 0)\n+            if (add_mibfile(filenames[i], strrchr(filenames[i], '/')) == 0)\n                 count++;\n \t    free(filenames[i]);\n         }\n         File = oldFile;\n-        if (ip)\n-            fclose(ip);\n         free(filenames);\n         return (count);\n     }",
        "diff_line_info": {
            "deleted_lines": [
                "    FILE           *ip;",
                "#if !(defined(WIN32) || defined(cygwin))",
                "    char           *token;",
                "    char space;",
                "    char newline;",
                "    struct stat     dir_stat, idx_stat;",
                "    char            tmpstr[300];",
                "    char            tmpstr1[300];",
                "#endif",
                "#if !(defined(WIN32) || defined(cygwin))",
                "    token = netsnmp_mibindex_lookup( dirname );",
                "    if (token && stat(token, &idx_stat) == 0 && stat(dirname, &dir_stat) == 0) {",
                "        if (dir_stat.st_mtime < idx_stat.st_mtime) {",
                "            DEBUGMSGTL((\"parse-mibs\", \"The index is good\\n\"));",
                "            if ((ip = fopen(token, \"r\")) != NULL) {",
                "                fgets(tmpstr, sizeof(tmpstr), ip); /* Skip dir line */",
                "                while (fscanf(ip, \"%127s%c%299[^\\n]%c\", token, &space, tmpstr,",
                "\t\t    &newline) == 4) {",
                "",
                "\t\t    /*",
                "\t\t     * If an overflow of the token or tmpstr buffers has been",
                "\t\t     * found log a message and break out of the while loop,",
                "\t\t     * thus the rest of the file tokens will be ignored.",
                "\t\t     */",
                "\t\t    if (space != ' ' || newline != '\\n') {",
                "\t\t\tsnmp_log(LOG_ERR,",
                "\t\t\t    \"add_mibdir: strings scanned in from %s/%s \" \\",
                "\t\t\t    \"are too large.  count = %d\\n \", dirname,",
                "\t\t\t    \".index\", count);",
                "\t\t\t    break;",
                "\t\t    }",
                "\t\t   ",
                "\t\t    snprintf(tmpstr1, sizeof(tmpstr1), \"%s/%s\", dirname, tmpstr);",
                "                    tmpstr1[ sizeof(tmpstr1)-1 ] = 0;",
                "                    new_module(token, tmpstr1);",
                "                    count++;",
                "                }",
                "                fclose(ip);",
                "                return count;",
                "            } else",
                "                DEBUGMSGTL((\"parse-mibs\", \"Can't read index\\n\"));",
                "        } else",
                "            DEBUGMSGTL((\"parse-mibs\", \"Index outdated\\n\"));",
                "    } else",
                "        DEBUGMSGTL((\"parse-mibs\", \"No index\\n\"));",
                "#endif",
                "        ip = netsnmp_mibindex_new(dirname);",
                "            if (add_mibfile(filenames[i], strrchr(filenames[i], '/'), ip) == 0)",
                "        if (ip)",
                "            fclose(ip);"
            ],
            "added_lines": [
                "            if (add_mibfile(filenames[i], strrchr(filenames[i], '/')) == 0)"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-15861",
        "func_name": "net-snmp/shutdown_mib",
        "description": "Net-SNMP through 5.7.3 allows Escalation of Privileges because of UNIX symbolic link (symlink) following.",
        "git_url": "https://github.com/net-snmp/net-snmp/commit/4fd9a450444a434a993bc72f7c3486ccce41f602",
        "commit_title": "CHANGES: snmpd: Stop reading and writing the mib_indexes/* files",
        "commit_text": " Caching directory contents is something the operating system should do and is not something Net-SNMP should do. Instead of storing a copy of the directory contents in ${tmp_dir}/mib_indexes/${n}, always scan a MIB directory.",
        "func_before": "void\nshutdown_mib(void)\n{\n    unload_all_mibs();\n    if (tree_top) {\n        if (tree_top->label)\n            SNMP_FREE(tree_top->label);\n        SNMP_FREE(tree_top);\n    }\n    tree_head = NULL;\n    Mib = NULL;\n    if (_mibindexes) {\n        int i;\n        for (i = 0; i < _mibindex; ++i)\n            SNMP_FREE(_mibindexes[i]);\n        free(_mibindexes);\n        _mibindex = 0;\n        _mibindex_max = 0;\n        _mibindexes = NULL;\n    }\n    if (Prefix != NULL && Prefix != &Standard_Prefix[0])\n        SNMP_FREE(Prefix);\n    if (Prefix)\n        Prefix = NULL;\n    SNMP_FREE(confmibs);\n    SNMP_FREE(confmibdir);\n}",
        "func": "void\nshutdown_mib(void)\n{\n    unload_all_mibs();\n    if (tree_top) {\n        if (tree_top->label)\n            SNMP_FREE(tree_top->label);\n        SNMP_FREE(tree_top);\n    }\n    tree_head = NULL;\n    Mib = NULL;\n    if (Prefix != NULL && Prefix != &Standard_Prefix[0])\n        SNMP_FREE(Prefix);\n    if (Prefix)\n        Prefix = NULL;\n    SNMP_FREE(confmibs);\n    SNMP_FREE(confmibdir);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -9,15 +9,6 @@\n     }\n     tree_head = NULL;\n     Mib = NULL;\n-    if (_mibindexes) {\n-        int i;\n-        for (i = 0; i < _mibindex; ++i)\n-            SNMP_FREE(_mibindexes[i]);\n-        free(_mibindexes);\n-        _mibindex = 0;\n-        _mibindex_max = 0;\n-        _mibindexes = NULL;\n-    }\n     if (Prefix != NULL && Prefix != &Standard_Prefix[0])\n         SNMP_FREE(Prefix);\n     if (Prefix)",
        "diff_line_info": {
            "deleted_lines": [
                "    if (_mibindexes) {",
                "        int i;",
                "        for (i = 0; i < _mibindex; ++i)",
                "            SNMP_FREE(_mibindexes[i]);",
                "        free(_mibindexes);",
                "        _mibindex = 0;",
                "        _mibindex_max = 0;",
                "        _mibindexes = NULL;",
                "    }"
            ],
            "added_lines": []
        }
    },
    {
        "cve_id": "CVE-2020-15861",
        "func_name": "net-snmp/netsnmp_init_mib",
        "description": "Net-SNMP through 5.7.3 allows Escalation of Privileges because of UNIX symbolic link (symlink) following.",
        "git_url": "https://github.com/net-snmp/net-snmp/commit/4fd9a450444a434a993bc72f7c3486ccce41f602",
        "commit_title": "CHANGES: snmpd: Stop reading and writing the mib_indexes/* files",
        "commit_text": " Caching directory contents is something the operating system should do and is not something Net-SNMP should do. Instead of storing a copy of the directory contents in ${tmp_dir}/mib_indexes/${n}, always scan a MIB directory.",
        "func_before": "void\nnetsnmp_init_mib(void)\n{\n    const char     *prefix;\n    char           *env_var, *entry;\n    PrefixListPtr   pp = &mib_prefixes[0];\n    char           *st = NULL;\n\n    if (Mib)\n        return;\n    netsnmp_init_mib_internals();\n\n    /*\n     * Initialise the MIB directory/ies \n     */\n    netsnmp_fixup_mib_directory();\n    env_var = strdup(netsnmp_get_mib_directory());\n    if (!env_var)\n        return;\n    netsnmp_mibindex_load();\n\n    DEBUGMSGTL((\"init_mib\",\n                \"Seen MIBDIRS: Looking in '%s' for mib dirs ...\\n\",\n                env_var));\n\n    entry = strtok_r(env_var, ENV_SEPARATOR, &st);\n    while (entry) {\n        add_mibdir(entry);\n        entry = strtok_r(NULL, ENV_SEPARATOR, &st);\n    }\n    SNMP_FREE(env_var);\n\n    env_var = netsnmp_getenv(\"MIBFILES\");\n    if (env_var != NULL) {\n        if (*env_var == '+')\n            entry = strtok_r(env_var+1, ENV_SEPARATOR, &st);\n        else\n            entry = strtok_r(env_var, ENV_SEPARATOR, &st);\n        while (entry) {\n            add_mibfile(entry, NULL, NULL);\n            entry = strtok_r(NULL, ENV_SEPARATOR, &st);\n        }\n    }\n\n    netsnmp_init_mib_internals();\n\n    /*\n     * Read in any modules or mibs requested \n     */\n\n    env_var = netsnmp_getenv(\"MIBS\");\n    if (env_var == NULL) {\n        if (confmibs != NULL)\n            env_var = strdup(confmibs);\n        else\n            env_var = strdup(NETSNMP_DEFAULT_MIBS);\n    } else {\n        env_var = strdup(env_var);\n    }\n    if (env_var && ((*env_var == '+') || (*env_var == '-'))) {\n        entry =\n            (char *) malloc(strlen(NETSNMP_DEFAULT_MIBS) + strlen(env_var) + 2);\n        if (!entry) {\n            DEBUGMSGTL((\"init_mib\", \"env mibs malloc failed\"));\n            SNMP_FREE(env_var);\n            return;\n        } else {\n            if (*env_var == '+')\n                sprintf(entry, \"%s%c%s\", NETSNMP_DEFAULT_MIBS, ENV_SEPARATOR_CHAR,\n                        env_var+1);\n            else\n                sprintf(entry, \"%s%c%s\", env_var+1, ENV_SEPARATOR_CHAR,\n                        NETSNMP_DEFAULT_MIBS );\n        }\n        SNMP_FREE(env_var);\n        env_var = entry;\n    }\n\n    DEBUGMSGTL((\"init_mib\",\n                \"Seen MIBS: Looking in '%s' for mib files ...\\n\",\n                env_var));\n    entry = strtok_r(env_var, ENV_SEPARATOR, &st);\n    while (entry) {\n        if (strcasecmp(entry, DEBUG_ALWAYS_TOKEN) == 0) {\n            read_all_mibs();\n        } else if (strstr(entry, \"/\") != NULL) {\n            read_mib(entry);\n        } else {\n            netsnmp_read_module(entry);\n        }\n        entry = strtok_r(NULL, ENV_SEPARATOR, &st);\n    }\n    adopt_orphans();\n    SNMP_FREE(env_var);\n\n    env_var = netsnmp_getenv(\"MIBFILES\");\n    if (env_var != NULL) {\n        if ((*env_var == '+') || (*env_var == '-')) {\n#ifdef NETSNMP_DEFAULT_MIBFILES\n            entry =\n                (char *) malloc(strlen(NETSNMP_DEFAULT_MIBFILES) +\n                                strlen(env_var) + 2);\n            if (!entry) {\n                DEBUGMSGTL((\"init_mib\", \"env mibfiles malloc failed\"));\n            } else {\n                if (*env_var++ == '+')\n                    sprintf(entry, \"%s%c%s\", NETSNMP_DEFAULT_MIBFILES, ENV_SEPARATOR_CHAR,\n                            env_var );\n                else\n                    sprintf(entry, \"%s%c%s\", env_var, ENV_SEPARATOR_CHAR,\n                            NETSNMP_DEFAULT_MIBFILES );\n            }\n            SNMP_FREE(env_var);\n            env_var = entry;\n#else\n            env_var = strdup(env_var + 1);\n#endif\n        } else {\n            env_var = strdup(env_var);\n        }\n    } else {\n#ifdef NETSNMP_DEFAULT_MIBFILES\n        env_var = strdup(NETSNMP_DEFAULT_MIBFILES);\n#endif\n    }\n\n    if (env_var != NULL) {\n        DEBUGMSGTL((\"init_mib\",\n                    \"Seen MIBFILES: Looking in '%s' for mib files ...\\n\",\n                    env_var));\n        entry = strtok_r(env_var, ENV_SEPARATOR, &st);\n        while (entry) {\n            read_mib(entry);\n            entry = strtok_r(NULL, ENV_SEPARATOR, &st);\n        }\n        SNMP_FREE(env_var);\n    }\n\n    prefix = netsnmp_getenv(\"PREFIX\");\n\n    if (!prefix)\n        prefix = Standard_Prefix;\n\n    Prefix = (char *) malloc(strlen(prefix) + 2);\n    if (!Prefix)\n        DEBUGMSGTL((\"init_mib\", \"Prefix malloc failed\"));\n    else\n        strcpy(Prefix, prefix);\n\n    DEBUGMSGTL((\"init_mib\",\n                \"Seen PREFIX: Looking in '%s' for prefix ...\\n\", Prefix));\n\n    /*\n     * remove trailing dot \n     */\n    if (Prefix) {\n        env_var = &Prefix[strlen(Prefix) - 1];\n        if (*env_var == '.')\n            *env_var = '\\0';\n    }\n\n    pp->str = Prefix;           /* fixup first mib_prefix entry */\n    /*\n     * now that the list of prefixes is built, save each string length. \n     */\n    while (pp->str) {\n        pp->len = strlen(pp->str);\n        pp++;\n    }\n\n    Mib = tree_head;            /* Backwards compatibility */\n    tree_top = (struct tree *) calloc(1, sizeof(struct tree));\n    /*\n     * XX error check ? \n     */\n    if (tree_top) {\n        tree_top->label = strdup(\"(top)\");\n        tree_top->child_list = tree_head;\n    }\n}",
        "func": "void\nnetsnmp_init_mib(void)\n{\n    const char     *prefix;\n    char           *env_var, *entry;\n    PrefixListPtr   pp = &mib_prefixes[0];\n    char           *st = NULL;\n\n    if (Mib)\n        return;\n    netsnmp_init_mib_internals();\n\n    /*\n     * Initialise the MIB directory/ies \n     */\n    netsnmp_fixup_mib_directory();\n    env_var = strdup(netsnmp_get_mib_directory());\n    if (!env_var)\n        return;\n\n    DEBUGMSGTL((\"init_mib\",\n                \"Seen MIBDIRS: Looking in '%s' for mib dirs ...\\n\",\n                env_var));\n\n    entry = strtok_r(env_var, ENV_SEPARATOR, &st);\n    while (entry) {\n        add_mibdir(entry);\n        entry = strtok_r(NULL, ENV_SEPARATOR, &st);\n    }\n    SNMP_FREE(env_var);\n\n    env_var = netsnmp_getenv(\"MIBFILES\");\n    if (env_var != NULL) {\n        if (*env_var == '+')\n            entry = strtok_r(env_var+1, ENV_SEPARATOR, &st);\n        else\n            entry = strtok_r(env_var, ENV_SEPARATOR, &st);\n        while (entry) {\n            add_mibfile(entry, NULL);\n            entry = strtok_r(NULL, ENV_SEPARATOR, &st);\n        }\n    }\n\n    netsnmp_init_mib_internals();\n\n    /*\n     * Read in any modules or mibs requested \n     */\n\n    env_var = netsnmp_getenv(\"MIBS\");\n    if (env_var == NULL) {\n        if (confmibs != NULL)\n            env_var = strdup(confmibs);\n        else\n            env_var = strdup(NETSNMP_DEFAULT_MIBS);\n    } else {\n        env_var = strdup(env_var);\n    }\n    if (env_var && ((*env_var == '+') || (*env_var == '-'))) {\n        entry =\n            (char *) malloc(strlen(NETSNMP_DEFAULT_MIBS) + strlen(env_var) + 2);\n        if (!entry) {\n            DEBUGMSGTL((\"init_mib\", \"env mibs malloc failed\"));\n            SNMP_FREE(env_var);\n            return;\n        } else {\n            if (*env_var == '+')\n                sprintf(entry, \"%s%c%s\", NETSNMP_DEFAULT_MIBS, ENV_SEPARATOR_CHAR,\n                        env_var+1);\n            else\n                sprintf(entry, \"%s%c%s\", env_var+1, ENV_SEPARATOR_CHAR,\n                        NETSNMP_DEFAULT_MIBS );\n        }\n        SNMP_FREE(env_var);\n        env_var = entry;\n    }\n\n    DEBUGMSGTL((\"init_mib\",\n                \"Seen MIBS: Looking in '%s' for mib files ...\\n\",\n                env_var));\n    entry = strtok_r(env_var, ENV_SEPARATOR, &st);\n    while (entry) {\n        if (strcasecmp(entry, DEBUG_ALWAYS_TOKEN) == 0) {\n            read_all_mibs();\n        } else if (strstr(entry, \"/\") != NULL) {\n            read_mib(entry);\n        } else {\n            netsnmp_read_module(entry);\n        }\n        entry = strtok_r(NULL, ENV_SEPARATOR, &st);\n    }\n    adopt_orphans();\n    SNMP_FREE(env_var);\n\n    env_var = netsnmp_getenv(\"MIBFILES\");\n    if (env_var != NULL) {\n        if ((*env_var == '+') || (*env_var == '-')) {\n#ifdef NETSNMP_DEFAULT_MIBFILES\n            entry =\n                (char *) malloc(strlen(NETSNMP_DEFAULT_MIBFILES) +\n                                strlen(env_var) + 2);\n            if (!entry) {\n                DEBUGMSGTL((\"init_mib\", \"env mibfiles malloc failed\"));\n            } else {\n                if (*env_var++ == '+')\n                    sprintf(entry, \"%s%c%s\", NETSNMP_DEFAULT_MIBFILES, ENV_SEPARATOR_CHAR,\n                            env_var );\n                else\n                    sprintf(entry, \"%s%c%s\", env_var, ENV_SEPARATOR_CHAR,\n                            NETSNMP_DEFAULT_MIBFILES );\n            }\n            SNMP_FREE(env_var);\n            env_var = entry;\n#else\n            env_var = strdup(env_var + 1);\n#endif\n        } else {\n            env_var = strdup(env_var);\n        }\n    } else {\n#ifdef NETSNMP_DEFAULT_MIBFILES\n        env_var = strdup(NETSNMP_DEFAULT_MIBFILES);\n#endif\n    }\n\n    if (env_var != NULL) {\n        DEBUGMSGTL((\"init_mib\",\n                    \"Seen MIBFILES: Looking in '%s' for mib files ...\\n\",\n                    env_var));\n        entry = strtok_r(env_var, ENV_SEPARATOR, &st);\n        while (entry) {\n            read_mib(entry);\n            entry = strtok_r(NULL, ENV_SEPARATOR, &st);\n        }\n        SNMP_FREE(env_var);\n    }\n\n    prefix = netsnmp_getenv(\"PREFIX\");\n\n    if (!prefix)\n        prefix = Standard_Prefix;\n\n    Prefix = (char *) malloc(strlen(prefix) + 2);\n    if (!Prefix)\n        DEBUGMSGTL((\"init_mib\", \"Prefix malloc failed\"));\n    else\n        strcpy(Prefix, prefix);\n\n    DEBUGMSGTL((\"init_mib\",\n                \"Seen PREFIX: Looking in '%s' for prefix ...\\n\", Prefix));\n\n    /*\n     * remove trailing dot \n     */\n    if (Prefix) {\n        env_var = &Prefix[strlen(Prefix) - 1];\n        if (*env_var == '.')\n            *env_var = '\\0';\n    }\n\n    pp->str = Prefix;           /* fixup first mib_prefix entry */\n    /*\n     * now that the list of prefixes is built, save each string length. \n     */\n    while (pp->str) {\n        pp->len = strlen(pp->str);\n        pp++;\n    }\n\n    Mib = tree_head;            /* Backwards compatibility */\n    tree_top = (struct tree *) calloc(1, sizeof(struct tree));\n    /*\n     * XX error check ? \n     */\n    if (tree_top) {\n        tree_top->label = strdup(\"(top)\");\n        tree_top->child_list = tree_head;\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -17,7 +17,6 @@\n     env_var = strdup(netsnmp_get_mib_directory());\n     if (!env_var)\n         return;\n-    netsnmp_mibindex_load();\n \n     DEBUGMSGTL((\"init_mib\",\n                 \"Seen MIBDIRS: Looking in '%s' for mib dirs ...\\n\",\n@@ -37,7 +36,7 @@\n         else\n             entry = strtok_r(env_var, ENV_SEPARATOR, &st);\n         while (entry) {\n-            add_mibfile(entry, NULL, NULL);\n+            add_mibfile(entry, NULL);\n             entry = strtok_r(NULL, ENV_SEPARATOR, &st);\n         }\n     }",
        "diff_line_info": {
            "deleted_lines": [
                "    netsnmp_mibindex_load();",
                "            add_mibfile(entry, NULL, NULL);"
            ],
            "added_lines": [
                "            add_mibfile(entry, NULL);"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-24654",
        "func_name": "KDE/ark/LibarchivePlugin::extractionFlags",
        "description": "In KDE Ark before 20.08.1, a crafted TAR archive with symlinks can install files outside the extraction directory, as demonstrated by a write operation to a user's home directory.",
        "git_url": "https://github.com/KDE/ark/commit/8bf8c5ef07b0ac5e914d752681e470dea403a5bd",
        "commit_title": "Pass the ARCHIVE_EXTRACT_SECURE_SYMLINKS flag to libarchive",
        "commit_text": " There are archive types which allow to first create a symlink and then later on dereference it. If the symlink points outside of the archive, this results in writing outside of the destination directory.  With the ARCHIVE_EXTRACT_SECURE_SYMLINKS option set, libarchive avoids this situation by verifying that none of the target path components are symlinks before writing.  Remove the commented out code in the method, which would actually misbehave if enabled again. ",
        "func_before": "int LibarchivePlugin::extractionFlags() const\n{\n    int result = ARCHIVE_EXTRACT_TIME;\n    result |= ARCHIVE_EXTRACT_SECURE_NODOTDOT;\n\n    // TODO: Don't use arksettings here\n    /*if ( ArkSettings::preservePerms() )\n    {\n        result &= ARCHIVE_EXTRACT_PERM;\n    }\n\n    if ( !ArkSettings::extractOverwrite() )\n    {\n        result &= ARCHIVE_EXTRACT_NO_OVERWRITE;\n    }*/\n\n    return result;\n}",
        "func": "int LibarchivePlugin::extractionFlags() const\n{\n    return ARCHIVE_EXTRACT_TIME\n           | ARCHIVE_EXTRACT_SECURE_NODOTDOT\n           | ARCHIVE_EXTRACT_SECURE_SYMLINKS;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,18 +1,6 @@\n int LibarchivePlugin::extractionFlags() const\n {\n-    int result = ARCHIVE_EXTRACT_TIME;\n-    result |= ARCHIVE_EXTRACT_SECURE_NODOTDOT;\n-\n-    // TODO: Don't use arksettings here\n-    /*if ( ArkSettings::preservePerms() )\n-    {\n-        result &= ARCHIVE_EXTRACT_PERM;\n-    }\n-\n-    if ( !ArkSettings::extractOverwrite() )\n-    {\n-        result &= ARCHIVE_EXTRACT_NO_OVERWRITE;\n-    }*/\n-\n-    return result;\n+    return ARCHIVE_EXTRACT_TIME\n+           | ARCHIVE_EXTRACT_SECURE_NODOTDOT\n+           | ARCHIVE_EXTRACT_SECURE_SYMLINKS;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    int result = ARCHIVE_EXTRACT_TIME;",
                "    result |= ARCHIVE_EXTRACT_SECURE_NODOTDOT;",
                "",
                "    // TODO: Don't use arksettings here",
                "    /*if ( ArkSettings::preservePerms() )",
                "    {",
                "        result &= ARCHIVE_EXTRACT_PERM;",
                "    }",
                "",
                "    if ( !ArkSettings::extractOverwrite() )",
                "    {",
                "        result &= ARCHIVE_EXTRACT_NO_OVERWRITE;",
                "    }*/",
                "",
                "    return result;"
            ],
            "added_lines": [
                "    return ARCHIVE_EXTRACT_TIME",
                "           | ARCHIVE_EXTRACT_SECURE_NODOTDOT",
                "           | ARCHIVE_EXTRACT_SECURE_SYMLINKS;"
            ]
        }
    },
    {
        "cve_id": "CVE-2014-5045",
        "func_name": "torvalds/linux/mountpoint_last",
        "description": "The mountpoint_last function in fs/namei.c in the Linux kernel before 3.15.8 does not properly maintain a certain reference count during attempts to use the umount system call in conjunction with a symlink, which allows local users to cause a denial of service (memory consumption or use-after-free) or possibly have unspecified other impact via the umount program.",
        "git_url": "https://github.com/torvalds/linux/commit/295dc39d941dc2ae53d5c170365af4c9d5c16212",
        "commit_title": "fs: umount on symlink leaks mnt count",
        "commit_text": " Currently umount on symlink blocks following umount:  /vz is separate mount  # ls /vz/ -al | grep test drwxr-xr-x.  2 root root       4096 Jul 19 01:14 testdir lrwxrwxrwx.  1 root root         11 Jul 19 01:16 testlink -> /vz/testdir # umount -l /vz/testlink umount: /vz/testlink: not mounted (expected)  # lsof /vz # umount /vz umount: /vz: device is busy. (unexpected)  In this case mountpoint_last() gets an extra refcount on path->mnt  Cc: stable@vger.kernel.org",
        "func_before": "static int\nmountpoint_last(struct nameidata *nd, struct path *path)\n{\n\tint error = 0;\n\tstruct dentry *dentry;\n\tstruct dentry *dir = nd->path.dentry;\n\n\t/* If we're in rcuwalk, drop out of it to handle last component */\n\tif (nd->flags & LOOKUP_RCU) {\n\t\tif (unlazy_walk(nd, NULL)) {\n\t\t\terror = -ECHILD;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tnd->flags &= ~LOOKUP_PARENT;\n\n\tif (unlikely(nd->last_type != LAST_NORM)) {\n\t\terror = handle_dots(nd, nd->last_type);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tdentry = dget(nd->path.dentry);\n\t\tgoto done;\n\t}\n\n\tmutex_lock(&dir->d_inode->i_mutex);\n\tdentry = d_lookup(dir, &nd->last);\n\tif (!dentry) {\n\t\t/*\n\t\t * No cached dentry. Mounted dentries are pinned in the cache,\n\t\t * so that means that this dentry is probably a symlink or the\n\t\t * path doesn't actually point to a mounted dentry.\n\t\t */\n\t\tdentry = d_alloc(dir, &nd->last);\n\t\tif (!dentry) {\n\t\t\terror = -ENOMEM;\n\t\t\tmutex_unlock(&dir->d_inode->i_mutex);\n\t\t\tgoto out;\n\t\t}\n\t\tdentry = lookup_real(dir->d_inode, dentry, nd->flags);\n\t\terror = PTR_ERR(dentry);\n\t\tif (IS_ERR(dentry)) {\n\t\t\tmutex_unlock(&dir->d_inode->i_mutex);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tmutex_unlock(&dir->d_inode->i_mutex);\n\ndone:\n\tif (!dentry->d_inode || d_is_negative(dentry)) {\n\t\terror = -ENOENT;\n\t\tdput(dentry);\n\t\tgoto out;\n\t}\n\tpath->dentry = dentry;\n\tpath->mnt = mntget(nd->path.mnt);\n\tif (should_follow_link(dentry, nd->flags & LOOKUP_FOLLOW))\n\t\treturn 1;\n\tfollow_mount(path);\n\terror = 0;\nout:\n\tterminate_walk(nd);\n\treturn error;\n}",
        "func": "static int\nmountpoint_last(struct nameidata *nd, struct path *path)\n{\n\tint error = 0;\n\tstruct dentry *dentry;\n\tstruct dentry *dir = nd->path.dentry;\n\n\t/* If we're in rcuwalk, drop out of it to handle last component */\n\tif (nd->flags & LOOKUP_RCU) {\n\t\tif (unlazy_walk(nd, NULL)) {\n\t\t\terror = -ECHILD;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tnd->flags &= ~LOOKUP_PARENT;\n\n\tif (unlikely(nd->last_type != LAST_NORM)) {\n\t\terror = handle_dots(nd, nd->last_type);\n\t\tif (error)\n\t\t\tgoto out;\n\t\tdentry = dget(nd->path.dentry);\n\t\tgoto done;\n\t}\n\n\tmutex_lock(&dir->d_inode->i_mutex);\n\tdentry = d_lookup(dir, &nd->last);\n\tif (!dentry) {\n\t\t/*\n\t\t * No cached dentry. Mounted dentries are pinned in the cache,\n\t\t * so that means that this dentry is probably a symlink or the\n\t\t * path doesn't actually point to a mounted dentry.\n\t\t */\n\t\tdentry = d_alloc(dir, &nd->last);\n\t\tif (!dentry) {\n\t\t\terror = -ENOMEM;\n\t\t\tmutex_unlock(&dir->d_inode->i_mutex);\n\t\t\tgoto out;\n\t\t}\n\t\tdentry = lookup_real(dir->d_inode, dentry, nd->flags);\n\t\terror = PTR_ERR(dentry);\n\t\tif (IS_ERR(dentry)) {\n\t\t\tmutex_unlock(&dir->d_inode->i_mutex);\n\t\t\tgoto out;\n\t\t}\n\t}\n\tmutex_unlock(&dir->d_inode->i_mutex);\n\ndone:\n\tif (!dentry->d_inode || d_is_negative(dentry)) {\n\t\terror = -ENOENT;\n\t\tdput(dentry);\n\t\tgoto out;\n\t}\n\tpath->dentry = dentry;\n\tpath->mnt = nd->path.mnt;\n\tif (should_follow_link(dentry, nd->flags & LOOKUP_FOLLOW))\n\t\treturn 1;\n\tmntget(path->mnt);\n\tfollow_mount(path);\n\terror = 0;\nout:\n\tterminate_walk(nd);\n\treturn error;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -53,9 +53,10 @@\n \t\tgoto out;\n \t}\n \tpath->dentry = dentry;\n-\tpath->mnt = mntget(nd->path.mnt);\n+\tpath->mnt = nd->path.mnt;\n \tif (should_follow_link(dentry, nd->flags & LOOKUP_FOLLOW))\n \t\treturn 1;\n+\tmntget(path->mnt);\n \tfollow_mount(path);\n \terror = 0;\n out:",
        "diff_line_info": {
            "deleted_lines": [
                "\tpath->mnt = mntget(nd->path.mnt);"
            ],
            "added_lines": [
                "\tpath->mnt = nd->path.mnt;",
                "\tmntget(path->mnt);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-11502",
        "func_name": "snapcore/snapd/setup_private_mount",
        "description": "snap-confine in snapd before 2.38 incorrectly set the ownership of a snap application to the uid and gid of the first calling user. Consequently, that user had unintended access to a private /tmp directory.",
        "git_url": "https://github.com/snapcore/snapd/commit/bdbfeebef03245176ae0dc323392bb0522a339b1",
        "commit_title": "cmd/snap-confine: chown private /tmp parent to root.root",
        "commit_text": " When snap-confine creates a private /tmp directory for a given snap it first creates a temporary directory in /tmp/ named after the snap, along with a random name. Inside that directory it creates a /tmp directory with permissions appropriate for a future /tmp, namely 1777.  Up until recently the that directory was owned by the user who first invoked snap-confine. Since the directory is reused by all the users on the system this logic makes no sense.  This patch changes the related logic so that the private /tmp directory is owned by root, just like the real one. ",
        "func_before": "static void setup_private_mount(const char *snap_name)\n{\n\tuid_t uid = getuid();\n\tgid_t gid = getgid();\n\tchar tmpdir[MAX_BUF] = { 0 };\n\n\t// Create a 0700 base directory, this is the base dir that is\n\t// protected from other users.\n\t//\n\t// Under that basedir, we put a 1777 /tmp dir that is then bind\n\t// mounted for the applications to use\n\tsc_must_snprintf(tmpdir, sizeof(tmpdir), \"/tmp/snap.%s_XXXXXX\", snap_name);\n\tif (mkdtemp(tmpdir) == NULL) {\n\t\tdie(\"cannot create temporary directory essential for private /tmp\");\n\t}\n\t// now we create a 1777 /tmp inside our private dir\n\tmode_t old_mask = umask(0);\n\tchar *d = sc_strdup(tmpdir);\n\tsc_must_snprintf(tmpdir, sizeof(tmpdir), \"%s/tmp\", d);\n\tfree(d);\n\n\tif (mkdir(tmpdir, 01777) != 0) {\n\t\tdie(\"cannot create temporary directory for private /tmp\");\n\t}\n\tumask(old_mask);\n\n\t// chdir to '/' since the mount won't apply to the current directory\n\tchar *pwd = get_current_dir_name();\n\tif (pwd == NULL)\n\t\tdie(\"cannot get current working directory\");\n\tif (chdir(\"/\") != 0)\n\t\tdie(\"cannot change directory to '/'\");\n\n\t// MS_BIND is there from linux 2.4\n\tsc_do_mount(tmpdir, \"/tmp\", NULL, MS_BIND, NULL);\n\t// MS_PRIVATE needs linux > 2.6.11\n\tsc_do_mount(\"none\", \"/tmp\", NULL, MS_PRIVATE, NULL);\n\t// do the chown after the bind mount to avoid potential shenanigans\n\tif (chown(\"/tmp/\", uid, gid) < 0) {\n\t\tdie(\"cannot change ownership of /tmp\");\n\t}\n\t// chdir to original directory\n\tif (chdir(pwd) != 0)\n\t\tdie(\"cannot change current working directory to the original directory\");\n\tfree(pwd);\n}",
        "func": "static void setup_private_mount(const char *snap_name)\n{\n\tchar tmpdir[MAX_BUF] = { 0 };\n\n\t// Create a 0700 base directory, this is the base dir that is\n\t// protected from other users.\n\t//\n\t// Under that basedir, we put a 1777 /tmp dir that is then bind\n\t// mounted for the applications to use\n\tsc_must_snprintf(tmpdir, sizeof(tmpdir), \"/tmp/snap.%s_XXXXXX\", snap_name);\n\tif (mkdtemp(tmpdir) == NULL) {\n\t\tdie(\"cannot create temporary directory essential for private /tmp\");\n\t}\n\t// now we create a 1777 /tmp inside our private dir\n\tmode_t old_mask = umask(0);\n\tchar *d = sc_strdup(tmpdir);\n\tsc_must_snprintf(tmpdir, sizeof(tmpdir), \"%s/tmp\", d);\n\tfree(d);\n\n\tif (mkdir(tmpdir, 01777) != 0) {\n\t\tdie(\"cannot create temporary directory for private /tmp\");\n\t}\n\tumask(old_mask);\n\n\t// chdir to '/' since the mount won't apply to the current directory\n\tchar *pwd = get_current_dir_name();\n\tif (pwd == NULL)\n\t\tdie(\"cannot get current working directory\");\n\tif (chdir(\"/\") != 0)\n\t\tdie(\"cannot change directory to '/'\");\n\n\t// MS_BIND is there from linux 2.4\n\tsc_do_mount(tmpdir, \"/tmp\", NULL, MS_BIND, NULL);\n\t// MS_PRIVATE needs linux > 2.6.11\n\tsc_do_mount(\"none\", \"/tmp\", NULL, MS_PRIVATE, NULL);\n\t// do the chown after the bind mount to avoid potential shenanigans\n\tif (chown(\"/tmp/\", 0, 0) < 0) {\n\t\tdie(\"cannot change ownership of /tmp\");\n\t}\n\t// chdir to original directory\n\tif (chdir(pwd) != 0)\n\t\tdie(\"cannot change current working directory to the original directory\");\n\tfree(pwd);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,7 +1,5 @@\n static void setup_private_mount(const char *snap_name)\n {\n-\tuid_t uid = getuid();\n-\tgid_t gid = getgid();\n \tchar tmpdir[MAX_BUF] = { 0 };\n \n \t// Create a 0700 base directory, this is the base dir that is\n@@ -36,7 +34,7 @@\n \t// MS_PRIVATE needs linux > 2.6.11\n \tsc_do_mount(\"none\", \"/tmp\", NULL, MS_PRIVATE, NULL);\n \t// do the chown after the bind mount to avoid potential shenanigans\n-\tif (chown(\"/tmp/\", uid, gid) < 0) {\n+\tif (chown(\"/tmp/\", 0, 0) < 0) {\n \t\tdie(\"cannot change ownership of /tmp\");\n \t}\n \t// chdir to original directory",
        "diff_line_info": {
            "deleted_lines": [
                "\tuid_t uid = getuid();",
                "\tgid_t gid = getgid();",
                "\tif (chown(\"/tmp/\", uid, gid) < 0) {"
            ],
            "added_lines": [
                "\tif (chown(\"/tmp/\", 0, 0) < 0) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-1331",
        "func_name": "lxc/lxclock_name",
        "description": "lxclock.c in LXC 1.1.2 and earlier allows local users to create arbitrary files via a symlink attack on /run/lock/lxc/*.",
        "git_url": "https://github.com/lxc/lxc/commit/72cf81f6a3404e35028567db2c99a90406e9c6e6",
        "commit_title": "CVE-2015-1331: lxclock: use /run/lxc/lock rather than /run/lock/lxc",
        "commit_text": " This prevents an unprivileged user to use LXC to create arbitrary file on the filesystem. ",
        "func_before": "static char *lxclock_name(const char *p, const char *n)\n{\n\tint ret;\n\tint len;\n\tchar *dest;\n\tchar *rundir;\n\n\t/* lockfile will be:\n\t * \"/run\" + \"/lock/lxc/$lxcpath/$lxcname + '\\0' if root\n\t * or\n\t * $XDG_RUNTIME_DIR + \"/lock/lxc/$lxcpath/$lxcname + '\\0' if non-root\n\t */\n\n\t/* length of \"/lock/lxc/\" + $lxcpath + \"/\" + \".\" + $lxcname + '\\0' */\n\tlen = strlen(\"/lock/lxc/\") + strlen(n) + strlen(p) + 3;\n\trundir = get_rundir();\n\tif (!rundir)\n\t\treturn NULL;\n\tlen += strlen(rundir);\n\n\tif ((dest = malloc(len)) == NULL) {\n\t\tfree(rundir);\n\t\treturn NULL;\n\t}\n\n\tret = snprintf(dest, len, \"%s/lock/lxc/%s\", rundir, p);\n\tif (ret < 0 || ret >= len) {\n\t\tfree(dest);\n\t\tfree(rundir);\n\t\treturn NULL;\n\t}\n\tret = mkdir_p(dest, 0755);\n\tif (ret < 0) {\n\t\t/* fall back to \"/tmp/\" + $(id -u) + \"/lxc\" + $lxcpath + \"/\" + \".\" + $lxcname + '\\0'\n\t\t * * maximum length of $(id -u) is 10 calculated by (log (2 ** (sizeof(uid_t) * 8) - 1) / log 10 + 1)\n\t\t * * lxcpath always starts with '/'\n\t\t */\n\t\tint l2 = 22 + strlen(n) + strlen(p);\n\t\tif (l2 > len) {\n\t\t\tchar *d;\n\t\t\td = realloc(dest, l2);\n\t\t\tif (!d) {\n\t\t\t\tfree(dest);\n\t\t\t\tfree(rundir);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tlen = l2;\n\t\t\tdest = d;\n\t\t}\n\t\tret = snprintf(dest, len, \"/tmp/%d/lxc%s\", geteuid(), p);\n\t\tif (ret < 0 || ret >= len) {\n\t\t\tfree(dest);\n\t\t\tfree(rundir);\n\t\t\treturn NULL;\n\t\t}\n\t\tret = mkdir_p(dest, 0755);\n\t\tif (ret < 0) {\n\t\t\tfree(dest);\n\t\t\tfree(rundir);\n\t\t\treturn NULL;\n\t\t}\n\t\tret = snprintf(dest, len, \"/tmp/%d/lxc%s/.%s\", geteuid(), p, n);\n\t} else\n\t\tret = snprintf(dest, len, \"%s/lock/lxc/%s/.%s\", rundir, p, n);\n\n\tfree(rundir);\n\n\tif (ret < 0 || ret >= len) {\n\t\tfree(dest);\n\t\treturn NULL;\n\t}\n\treturn dest;\n}",
        "func": "static char *lxclock_name(const char *p, const char *n)\n{\n\tint ret;\n\tint len;\n\tchar *dest;\n\tchar *rundir;\n\n\t/* lockfile will be:\n\t * \"/run\" + \"/lxc/lock/$lxcpath/$lxcname + '\\0' if root\n\t * or\n\t * $XDG_RUNTIME_DIR + \"/lxc/lock/$lxcpath/$lxcname + '\\0' if non-root\n\t */\n\n\t/* length of \"/lxc/lock/\" + $lxcpath + \"/\" + \".\" + $lxcname + '\\0' */\n\tlen = strlen(\"/lxc/lock/\") + strlen(n) + strlen(p) + 3;\n\trundir = get_rundir();\n\tif (!rundir)\n\t\treturn NULL;\n\tlen += strlen(rundir);\n\n\tif ((dest = malloc(len)) == NULL) {\n\t\tfree(rundir);\n\t\treturn NULL;\n\t}\n\n\tret = snprintf(dest, len, \"%s/lxc/lock/%s\", rundir, p);\n\tif (ret < 0 || ret >= len) {\n\t\tfree(dest);\n\t\tfree(rundir);\n\t\treturn NULL;\n\t}\n\tret = mkdir_p(dest, 0755);\n\tif (ret < 0) {\n\t\tfree(dest);\n\t\tfree(rundir);\n\t\treturn NULL;\n\t}\n\n\tret = snprintf(dest, len, \"%s/lxc/lock/%s/.%s\", rundir, p, n);\n\tfree(rundir);\n\tif (ret < 0 || ret >= len) {\n\t\tfree(dest);\n\t\treturn NULL;\n\t}\n\treturn dest;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,13 +6,13 @@\n \tchar *rundir;\n \n \t/* lockfile will be:\n-\t * \"/run\" + \"/lock/lxc/$lxcpath/$lxcname + '\\0' if root\n+\t * \"/run\" + \"/lxc/lock/$lxcpath/$lxcname + '\\0' if root\n \t * or\n-\t * $XDG_RUNTIME_DIR + \"/lock/lxc/$lxcpath/$lxcname + '\\0' if non-root\n+\t * $XDG_RUNTIME_DIR + \"/lxc/lock/$lxcpath/$lxcname + '\\0' if non-root\n \t */\n \n-\t/* length of \"/lock/lxc/\" + $lxcpath + \"/\" + \".\" + $lxcname + '\\0' */\n-\tlen = strlen(\"/lock/lxc/\") + strlen(n) + strlen(p) + 3;\n+\t/* length of \"/lxc/lock/\" + $lxcpath + \"/\" + \".\" + $lxcname + '\\0' */\n+\tlen = strlen(\"/lxc/lock/\") + strlen(n) + strlen(p) + 3;\n \trundir = get_rundir();\n \tif (!rundir)\n \t\treturn NULL;\n@@ -23,7 +23,7 @@\n \t\treturn NULL;\n \t}\n \n-\tret = snprintf(dest, len, \"%s/lock/lxc/%s\", rundir, p);\n+\tret = snprintf(dest, len, \"%s/lxc/lock/%s\", rundir, p);\n \tif (ret < 0 || ret >= len) {\n \t\tfree(dest);\n \t\tfree(rundir);\n@@ -31,40 +31,13 @@\n \t}\n \tret = mkdir_p(dest, 0755);\n \tif (ret < 0) {\n-\t\t/* fall back to \"/tmp/\" + $(id -u) + \"/lxc\" + $lxcpath + \"/\" + \".\" + $lxcname + '\\0'\n-\t\t * * maximum length of $(id -u) is 10 calculated by (log (2 ** (sizeof(uid_t) * 8) - 1) / log 10 + 1)\n-\t\t * * lxcpath always starts with '/'\n-\t\t */\n-\t\tint l2 = 22 + strlen(n) + strlen(p);\n-\t\tif (l2 > len) {\n-\t\t\tchar *d;\n-\t\t\td = realloc(dest, l2);\n-\t\t\tif (!d) {\n-\t\t\t\tfree(dest);\n-\t\t\t\tfree(rundir);\n-\t\t\t\treturn NULL;\n-\t\t\t}\n-\t\t\tlen = l2;\n-\t\t\tdest = d;\n-\t\t}\n-\t\tret = snprintf(dest, len, \"/tmp/%d/lxc%s\", geteuid(), p);\n-\t\tif (ret < 0 || ret >= len) {\n-\t\t\tfree(dest);\n-\t\t\tfree(rundir);\n-\t\t\treturn NULL;\n-\t\t}\n-\t\tret = mkdir_p(dest, 0755);\n-\t\tif (ret < 0) {\n-\t\t\tfree(dest);\n-\t\t\tfree(rundir);\n-\t\t\treturn NULL;\n-\t\t}\n-\t\tret = snprintf(dest, len, \"/tmp/%d/lxc%s/.%s\", geteuid(), p, n);\n-\t} else\n-\t\tret = snprintf(dest, len, \"%s/lock/lxc/%s/.%s\", rundir, p, n);\n+\t\tfree(dest);\n+\t\tfree(rundir);\n+\t\treturn NULL;\n+\t}\n \n+\tret = snprintf(dest, len, \"%s/lxc/lock/%s/.%s\", rundir, p, n);\n \tfree(rundir);\n-\n \tif (ret < 0 || ret >= len) {\n \t\tfree(dest);\n \t\treturn NULL;",
        "diff_line_info": {
            "deleted_lines": [
                "\t * \"/run\" + \"/lock/lxc/$lxcpath/$lxcname + '\\0' if root",
                "\t * $XDG_RUNTIME_DIR + \"/lock/lxc/$lxcpath/$lxcname + '\\0' if non-root",
                "\t/* length of \"/lock/lxc/\" + $lxcpath + \"/\" + \".\" + $lxcname + '\\0' */",
                "\tlen = strlen(\"/lock/lxc/\") + strlen(n) + strlen(p) + 3;",
                "\tret = snprintf(dest, len, \"%s/lock/lxc/%s\", rundir, p);",
                "\t\t/* fall back to \"/tmp/\" + $(id -u) + \"/lxc\" + $lxcpath + \"/\" + \".\" + $lxcname + '\\0'",
                "\t\t * * maximum length of $(id -u) is 10 calculated by (log (2 ** (sizeof(uid_t) * 8) - 1) / log 10 + 1)",
                "\t\t * * lxcpath always starts with '/'",
                "\t\t */",
                "\t\tint l2 = 22 + strlen(n) + strlen(p);",
                "\t\tif (l2 > len) {",
                "\t\t\tchar *d;",
                "\t\t\td = realloc(dest, l2);",
                "\t\t\tif (!d) {",
                "\t\t\t\tfree(dest);",
                "\t\t\t\tfree(rundir);",
                "\t\t\t\treturn NULL;",
                "\t\t\t}",
                "\t\t\tlen = l2;",
                "\t\t\tdest = d;",
                "\t\t}",
                "\t\tret = snprintf(dest, len, \"/tmp/%d/lxc%s\", geteuid(), p);",
                "\t\tif (ret < 0 || ret >= len) {",
                "\t\t\tfree(dest);",
                "\t\t\tfree(rundir);",
                "\t\t\treturn NULL;",
                "\t\t}",
                "\t\tret = mkdir_p(dest, 0755);",
                "\t\tif (ret < 0) {",
                "\t\t\tfree(dest);",
                "\t\t\tfree(rundir);",
                "\t\t\treturn NULL;",
                "\t\t}",
                "\t\tret = snprintf(dest, len, \"/tmp/%d/lxc%s/.%s\", geteuid(), p, n);",
                "\t} else",
                "\t\tret = snprintf(dest, len, \"%s/lock/lxc/%s/.%s\", rundir, p, n);",
                ""
            ],
            "added_lines": [
                "\t * \"/run\" + \"/lxc/lock/$lxcpath/$lxcname + '\\0' if root",
                "\t * $XDG_RUNTIME_DIR + \"/lxc/lock/$lxcpath/$lxcname + '\\0' if non-root",
                "\t/* length of \"/lxc/lock/\" + $lxcpath + \"/\" + \".\" + $lxcname + '\\0' */",
                "\tlen = strlen(\"/lxc/lock/\") + strlen(n) + strlen(p) + 3;",
                "\tret = snprintf(dest, len, \"%s/lxc/lock/%s\", rundir, p);",
                "\t\tfree(dest);",
                "\t\tfree(rundir);",
                "\t\treturn NULL;",
                "\t}",
                "\tret = snprintf(dest, len, \"%s/lxc/lock/%s/.%s\", rundir, p, n);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-41072",
        "func_name": "plougher/squashfs-tools/squashfs_opendir",
        "description": "squashfs_opendir in unsquash-2.c in Squashfs-Tools 4.5 allows Directory Traversal, a different vulnerability than CVE-2021-40153. A squashfs filesystem that has been crafted to include a symbolic link and then contents under the same filename in a filesystem can cause unsquashfs to first create the symbolic link pointing outside the expected directory, and then the subsequent write operation will cause the unsquashfs process to write through the symbolic link elsewhere in the filesystem.",
        "git_url": "https://github.com/plougher/squashfs-tools/commit/e0485802ec72996c20026da320650d8362f555bd",
        "commit_title": "Unsquashfs: additional write outside destination directory exploit fix",
        "commit_text": " An issue on github (https://github.com/plougher/squashfs-tools/issues/72) showed how some specially crafted Squashfs filesystems containing invalid file names (with '/' and '..') can cause Unsquashfs to write files outside of the destination directory.  Since then it has been shown that specially crafted Squashfs filesystems that contain a symbolic link pointing outside of the destination directory, coupled with an identically named file within the same directory, can cause Unsquashfs to write files outside of the destination directory.  Specifically the symbolic link produces a pathname pointing outside of the destination directory, which is then followed when writing the duplicate identically named file within the directory.  This commit fixes this exploit by explictly checking for duplicate filenames within a directory.  As directories in v2.1, v3.x, and v4.0 filesystems are sorted, this is achieved by checking for consecutively identical filenames.  Additionally directories are checked to ensure they are sorted, to avoid attempts to evade the duplicate check.  Version 1.x and 2.0 filesystems (where the directories were unsorted) are sorted and then the above duplicate filename check is applied. ",
        "func_before": "static struct dir *squashfs_opendir(unsigned int block_start, unsigned int offset,\n\tstruct inode **i)\n{\n\tstruct squashfs_dir_header dirh;\n\tchar buffer[sizeof(struct squashfs_dir_entry) + SQUASHFS_NAME_LEN + 1]\n\t\t__attribute__((aligned));\n\tstruct squashfs_dir_entry *dire = (struct squashfs_dir_entry *) buffer;\n\tlong long start;\n\tint bytes = 0, dir_count, size, res;\n\tstruct dir_ent *ent, *cur_ent = NULL;\n\tstruct dir *dir;\n\n\tTRACE(\"squashfs_opendir: inode start block %d, offset %d\\n\",\n\t\tblock_start, offset);\n\n\t*i = read_inode(block_start, offset);\n\n\tdir = malloc(sizeof(struct dir));\n\tif(dir == NULL)\n\t\tMEM_ERROR();\n\n\tdir->dir_count = 0;\n\tdir->cur_entry = NULL;\n\tdir->mode = (*i)->mode;\n\tdir->uid = (*i)->uid;\n\tdir->guid = (*i)->gid;\n\tdir->mtime = (*i)->time;\n\tdir->xattr = (*i)->xattr;\n\tdir->dirs = NULL;\n\n\tif ((*i)->data == 3)\n\t\t/*\n\t\t * if the directory is empty, skip the unnecessary\n\t\t * lookup_entry, this fixes the corner case with\n\t\t * completely empty filesystems where lookup_entry correctly\n\t\t * returning -1 is incorrectly treated as an error\n\t\t */\n\t\treturn dir;\n\n\tstart = sBlk.s.directory_table_start + (*i)->start;\n\toffset = (*i)->offset;\n\tsize = (*i)->data + bytes - 3;\n\n\twhile(bytes < size) {\t\t\t\n\t\tres = read_directory_data(&dirh, &start, &offset, sizeof(dirh));\n\t\tif(res == FALSE)\n\t\t\tgoto corrupted;\n\n\t\tSQUASHFS_INSWAP_DIR_HEADER(&dirh);\n\t\n\t\tdir_count = dirh.count + 1;\n\t\tTRACE(\"squashfs_opendir: Read directory header @ byte position \"\n\t\t\t\"%d, %d directory entries\\n\", bytes, dir_count);\n\t\tbytes += sizeof(dirh);\n\n\t\t/* dir_count should never be larger than SQUASHFS_DIR_COUNT */\n\t\tif(dir_count > SQUASHFS_DIR_COUNT) {\n\t\t\tERROR(\"File system corrupted: too many entries in directory\\n\");\n\t\t\tgoto corrupted;\n\t\t}\n\n\t\twhile(dir_count--) {\n\t\t\tres = read_directory_data(dire, &start, &offset, sizeof(*dire));\n\t\t\tif(res == FALSE)\n\t\t\t\tgoto corrupted;\n\n\t\t\tSQUASHFS_INSWAP_DIR_ENTRY(dire);\n\n\t\t\tbytes += sizeof(*dire);\n\n\t\t\t/* size should never be SQUASHFS_NAME_LEN or larger */\n\t\t\tif(dire->size >= SQUASHFS_NAME_LEN) {\n\t\t\t\tERROR(\"File system corrupted: filename too long\\n\");\n\t\t\t\tgoto corrupted;\n\t\t\t}\n\n\t\t\tres = read_directory_data(dire->name, &start, &offset,\n\t\t\t\t\t\t\t\tdire->size + 1);\n\t\t\tif(res == FALSE)\n\t\t\t\tgoto corrupted;\n\n\t\t\tdire->name[dire->size + 1] = '\\0';\n\n\t\t\t/* check name for invalid characters (i.e /, ., ..) */\n\t\t\tif(check_name(dire->name, dire->size + 1) == FALSE) {\n\t\t\t\tERROR(\"File system corrupted: invalid characters in name\\n\");\n\t\t\t\tgoto corrupted;\n\t\t\t}\n\n\t\t\tTRACE(\"squashfs_opendir: directory entry %s, inode \"\n\t\t\t\t\"%d:%d, type %d\\n\", dire->name,\n\t\t\t\tdirh.start_block, dire->offset, dire->type);\n\n\t\t\tent = malloc(sizeof(struct dir_ent));\n\t\t\tif(ent == NULL)\n\t\t\t\tMEM_ERROR();\n\n\t\t\tent->name = strdup(dire->name);\n\t\t\tent->start_block = dirh.start_block;\n\t\t\tent->offset = dire->offset;\n\t\t\tent->type = dire->type;\n\t\t\tent->next = NULL;\n\t\t\tif(cur_ent == NULL)\n\t\t\t\tdir->dirs = ent;\n\t\t\telse\n\t\t\t\tcur_ent->next = ent;\n\t\t\tcur_ent = ent;\n\t\t\tdir->dir_count ++;\n\t\t\tbytes += dire->size + 1;\n\t\t}\n\t}\n\n\treturn dir;\n\ncorrupted:\n\tsquashfs_closedir(dir);\n\treturn NULL;\n}",
        "func": "static struct dir *squashfs_opendir(unsigned int block_start, unsigned int offset,\n\tstruct inode **i)\n{\n\tstruct squashfs_dir_header dirh;\n\tchar buffer[sizeof(struct squashfs_dir_entry) + SQUASHFS_NAME_LEN + 1]\n\t\t__attribute__((aligned));\n\tstruct squashfs_dir_entry *dire = (struct squashfs_dir_entry *) buffer;\n\tlong long start;\n\tint bytes = 0, dir_count, size, res;\n\tstruct dir_ent *ent, *cur_ent = NULL;\n\tstruct dir *dir;\n\n\tTRACE(\"squashfs_opendir: inode start block %d, offset %d\\n\",\n\t\tblock_start, offset);\n\n\t*i = read_inode(block_start, offset);\n\n\tdir = malloc(sizeof(struct dir));\n\tif(dir == NULL)\n\t\tMEM_ERROR();\n\n\tdir->dir_count = 0;\n\tdir->cur_entry = NULL;\n\tdir->mode = (*i)->mode;\n\tdir->uid = (*i)->uid;\n\tdir->guid = (*i)->gid;\n\tdir->mtime = (*i)->time;\n\tdir->xattr = (*i)->xattr;\n\tdir->dirs = NULL;\n\n\tif ((*i)->data == 3)\n\t\t/*\n\t\t * if the directory is empty, skip the unnecessary\n\t\t * lookup_entry, this fixes the corner case with\n\t\t * completely empty filesystems where lookup_entry correctly\n\t\t * returning -1 is incorrectly treated as an error\n\t\t */\n\t\treturn dir;\n\n\tstart = sBlk.s.directory_table_start + (*i)->start;\n\toffset = (*i)->offset;\n\tsize = (*i)->data + bytes - 3;\n\n\twhile(bytes < size) {\t\t\t\n\t\tres = read_directory_data(&dirh, &start, &offset, sizeof(dirh));\n\t\tif(res == FALSE)\n\t\t\tgoto corrupted;\n\n\t\tSQUASHFS_INSWAP_DIR_HEADER(&dirh);\n\t\n\t\tdir_count = dirh.count + 1;\n\t\tTRACE(\"squashfs_opendir: Read directory header @ byte position \"\n\t\t\t\"%d, %d directory entries\\n\", bytes, dir_count);\n\t\tbytes += sizeof(dirh);\n\n\t\t/* dir_count should never be larger than SQUASHFS_DIR_COUNT */\n\t\tif(dir_count > SQUASHFS_DIR_COUNT) {\n\t\t\tERROR(\"File system corrupted: too many entries in directory\\n\");\n\t\t\tgoto corrupted;\n\t\t}\n\n\t\twhile(dir_count--) {\n\t\t\tres = read_directory_data(dire, &start, &offset, sizeof(*dire));\n\t\t\tif(res == FALSE)\n\t\t\t\tgoto corrupted;\n\n\t\t\tSQUASHFS_INSWAP_DIR_ENTRY(dire);\n\n\t\t\tbytes += sizeof(*dire);\n\n\t\t\t/* size should never be SQUASHFS_NAME_LEN or larger */\n\t\t\tif(dire->size >= SQUASHFS_NAME_LEN) {\n\t\t\t\tERROR(\"File system corrupted: filename too long\\n\");\n\t\t\t\tgoto corrupted;\n\t\t\t}\n\n\t\t\tres = read_directory_data(dire->name, &start, &offset,\n\t\t\t\t\t\t\t\tdire->size + 1);\n\t\t\tif(res == FALSE)\n\t\t\t\tgoto corrupted;\n\n\t\t\tdire->name[dire->size + 1] = '\\0';\n\n\t\t\t/* check name for invalid characters (i.e /, ., ..) */\n\t\t\tif(check_name(dire->name, dire->size + 1) == FALSE) {\n\t\t\t\tERROR(\"File system corrupted: invalid characters in name\\n\");\n\t\t\t\tgoto corrupted;\n\t\t\t}\n\n\t\t\tTRACE(\"squashfs_opendir: directory entry %s, inode \"\n\t\t\t\t\"%d:%d, type %d\\n\", dire->name,\n\t\t\t\tdirh.start_block, dire->offset, dire->type);\n\n\t\t\tent = malloc(sizeof(struct dir_ent));\n\t\t\tif(ent == NULL)\n\t\t\t\tMEM_ERROR();\n\n\t\t\tent->name = strdup(dire->name);\n\t\t\tent->start_block = dirh.start_block;\n\t\t\tent->offset = dire->offset;\n\t\t\tent->type = dire->type;\n\t\t\tent->next = NULL;\n\t\t\tif(cur_ent == NULL)\n\t\t\t\tdir->dirs = ent;\n\t\t\telse\n\t\t\t\tcur_ent->next = ent;\n\t\t\tcur_ent = ent;\n\t\t\tdir->dir_count ++;\n\t\t\tbytes += dire->size + 1;\n\t\t}\n\t}\n\n\t/* check directory for duplicate names and sorting */\n\tif(check_directory(dir) == FALSE) {\n\t\tERROR(\"File system corrupted: directory has duplicate names or is unsorted\\n\");\n\t\tgoto corrupted;\n\t}\n\n\treturn dir;\n\ncorrupted:\n\tsquashfs_closedir(dir);\n\treturn NULL;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -110,6 +110,12 @@\n \t\t}\n \t}\n \n+\t/* check directory for duplicate names and sorting */\n+\tif(check_directory(dir) == FALSE) {\n+\t\tERROR(\"File system corrupted: directory has duplicate names or is unsorted\\n\");\n+\t\tgoto corrupted;\n+\t}\n+\n \treturn dir;\n \n corrupted:",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t/* check directory for duplicate names and sorting */",
                "\tif(check_directory(dir) == FALSE) {",
                "\t\tERROR(\"File system corrupted: directory has duplicate names or is unsorted\\n\");",
                "\t\tgoto corrupted;",
                "\t}",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2021-41072",
        "func_name": "plougher/squashfs-tools/squashfs_opendir",
        "description": "squashfs_opendir in unsquash-2.c in Squashfs-Tools 4.5 allows Directory Traversal, a different vulnerability than CVE-2021-40153. A squashfs filesystem that has been crafted to include a symbolic link and then contents under the same filename in a filesystem can cause unsquashfs to first create the symbolic link pointing outside the expected directory, and then the subsequent write operation will cause the unsquashfs process to write through the symbolic link elsewhere in the filesystem.",
        "git_url": "https://github.com/plougher/squashfs-tools/commit/e0485802ec72996c20026da320650d8362f555bd",
        "commit_title": "Unsquashfs: additional write outside destination directory exploit fix",
        "commit_text": " An issue on github (https://github.com/plougher/squashfs-tools/issues/72) showed how some specially crafted Squashfs filesystems containing invalid file names (with '/' and '..') can cause Unsquashfs to write files outside of the destination directory.  Since then it has been shown that specially crafted Squashfs filesystems that contain a symbolic link pointing outside of the destination directory, coupled with an identically named file within the same directory, can cause Unsquashfs to write files outside of the destination directory.  Specifically the symbolic link produces a pathname pointing outside of the destination directory, which is then followed when writing the duplicate identically named file within the directory.  This commit fixes this exploit by explictly checking for duplicate filenames within a directory.  As directories in v2.1, v3.x, and v4.0 filesystems are sorted, this is achieved by checking for consecutively identical filenames.  Additionally directories are checked to ensure they are sorted, to avoid attempts to evade the duplicate check.  Version 1.x and 2.0 filesystems (where the directories were unsorted) are sorted and then the above duplicate filename check is applied. ",
        "func_before": "static struct dir *squashfs_opendir(unsigned int block_start, unsigned int offset,\n\tstruct inode **i)\n{\n\tsquashfs_dir_header_2 dirh;\n\tchar buffer[sizeof(squashfs_dir_entry_2) + SQUASHFS_NAME_LEN + 1]\n\t\t__attribute__((aligned));\n\tsquashfs_dir_entry_2 *dire = (squashfs_dir_entry_2 *) buffer;\n\tlong long start;\n\tint bytes = 0;\n\tint dir_count, size, res;\n\tstruct dir_ent *ent, *cur_ent = NULL;\n\tstruct dir *dir;\n\n\tTRACE(\"squashfs_opendir: inode start block %d, offset %d\\n\",\n\t\tblock_start, offset);\n\n\t*i = read_inode(block_start, offset);\n\n\tdir = malloc(sizeof(struct dir));\n\tif(dir == NULL)\n\t\tMEM_ERROR();\n\n\tdir->dir_count = 0;\n\tdir->cur_entry = NULL;\n\tdir->mode = (*i)->mode;\n\tdir->uid = (*i)->uid;\n\tdir->guid = (*i)->gid;\n\tdir->mtime = (*i)->time;\n\tdir->xattr = (*i)->xattr;\n\tdir->dirs = NULL;\n\n\tif ((*i)->data == 0)\n\t\t/*\n\t\t * if the directory is empty, skip the unnecessary\n\t\t * lookup_entry, this fixes the corner case with\n\t\t * completely empty filesystems where lookup_entry correctly\n\t\t * returning -1 is incorrectly treated as an error\n\t\t */\n\t\treturn dir;\n\n\tstart = sBlk.s.directory_table_start + (*i)->start;\n\toffset = (*i)->offset;\n\tsize = (*i)->data + bytes;\n\n\twhile(bytes < size) {\n\t\tif(swap) {\n\t\t\tsquashfs_dir_header_2 sdirh;\n\t\t\tres = read_directory_data(&sdirh, &start, &offset, sizeof(sdirh));\n\t\t\tif(res)\n\t\t\t\tSQUASHFS_SWAP_DIR_HEADER_2(&dirh, &sdirh);\n\t\t} else\n\t\t\tres = read_directory_data(&dirh, &start, &offset, sizeof(dirh));\n\n\t\tif(res == FALSE)\n\t\t\tgoto corrupted;\n\n\t\tdir_count = dirh.count + 1;\n\t\tTRACE(\"squashfs_opendir: Read directory header @ byte position \"\n\t\t\t\"%d, %d directory entries\\n\", bytes, dir_count);\n\t\tbytes += sizeof(dirh);\n\n\t\t/* dir_count should never be larger than SQUASHFS_DIR_COUNT */\n\t\tif(dir_count > SQUASHFS_DIR_COUNT) {\n\t\t\tERROR(\"File system corrupted: too many entries in directory\\n\");\n\t\t\tgoto corrupted;\n\t\t}\n\n\t\twhile(dir_count--) {\n\t\t\tif(swap) {\n\t\t\t\tsquashfs_dir_entry_2 sdire;\n\t\t\t\tres = read_directory_data(&sdire, &start,\n\t\t\t\t\t&offset, sizeof(sdire));\n\t\t\t\tif(res)\n\t\t\t\t\tSQUASHFS_SWAP_DIR_ENTRY_2(dire, &sdire);\n\t\t\t} else\n\t\t\t\tres = read_directory_data(dire, &start,\n\t\t\t\t\t&offset, sizeof(*dire));\n\n\t\t\tif(res == FALSE)\n\t\t\t\tgoto corrupted;\n\n\t\t\tbytes += sizeof(*dire);\n\n\t\t\t/* size should never be SQUASHFS_NAME_LEN or larger */\n\t\t\tif(dire->size >= SQUASHFS_NAME_LEN) {\n\t\t\t\tERROR(\"File system corrupted: filename too long\\n\");\n\t\t\t\tgoto corrupted;\n\t\t\t}\n\n\t\t\tres = read_directory_data(dire->name, &start, &offset,\n\t\t\t\t\t\t\t\tdire->size + 1);\n\n\t\t\tif(res == FALSE)\n\t\t\t\tgoto corrupted;\n\n\t\t\tdire->name[dire->size + 1] = '\\0';\n\n\t\t\t/* check name for invalid characters (i.e /, ., ..) */\n\t\t\tif(check_name(dire->name, dire->size + 1) == FALSE) {\n\t\t\t\tERROR(\"File system corrupted: invalid characters in name\\n\");\n\t\t\t\tgoto corrupted;\n\t\t\t}\n\n\t\t\tTRACE(\"squashfs_opendir: directory entry %s, inode \"\n\t\t\t\t\"%d:%d, type %d\\n\", dire->name,\n\t\t\t\tdirh.start_block, dire->offset, dire->type);\n\n\t\t\tent = malloc(sizeof(struct dir_ent));\n\t\t\tif(ent == NULL)\n\t\t\t\tMEM_ERROR();\n\n\t\t\tent->name = strdup(dire->name);\n\t\t\tent->start_block = dirh.start_block;\n\t\t\tent->offset = dire->offset;\n\t\t\tent->type = dire->type;\n\t\t\tent->next = NULL;\n\t\t\tif(cur_ent == NULL)\n\t\t\t\tdir->dirs = ent;\n\t\t\telse\n\t\t\t\tcur_ent->next = ent;\n\t\t\tcur_ent = ent;\n\t\t\tdir->dir_count ++;\n\t\t\tbytes += dire->size + 1;\n\t\t}\n\t}\n\n\treturn dir;\n\ncorrupted:\n\tsquashfs_closedir(dir);\n\treturn NULL;\n}",
        "func": "static struct dir *squashfs_opendir(unsigned int block_start, unsigned int offset,\n\tstruct inode **i)\n{\n\tsquashfs_dir_header_2 dirh;\n\tchar buffer[sizeof(squashfs_dir_entry_2) + SQUASHFS_NAME_LEN + 1]\n\t\t__attribute__((aligned));\n\tsquashfs_dir_entry_2 *dire = (squashfs_dir_entry_2 *) buffer;\n\tlong long start;\n\tint bytes = 0;\n\tint dir_count, size, res;\n\tstruct dir_ent *ent, *cur_ent = NULL;\n\tstruct dir *dir;\n\n\tTRACE(\"squashfs_opendir: inode start block %d, offset %d\\n\",\n\t\tblock_start, offset);\n\n\t*i = read_inode(block_start, offset);\n\n\tdir = malloc(sizeof(struct dir));\n\tif(dir == NULL)\n\t\tMEM_ERROR();\n\n\tdir->dir_count = 0;\n\tdir->cur_entry = NULL;\n\tdir->mode = (*i)->mode;\n\tdir->uid = (*i)->uid;\n\tdir->guid = (*i)->gid;\n\tdir->mtime = (*i)->time;\n\tdir->xattr = (*i)->xattr;\n\tdir->dirs = NULL;\n\n\tif ((*i)->data == 0)\n\t\t/*\n\t\t * if the directory is empty, skip the unnecessary\n\t\t * lookup_entry, this fixes the corner case with\n\t\t * completely empty filesystems where lookup_entry correctly\n\t\t * returning -1 is incorrectly treated as an error\n\t\t */\n\t\treturn dir;\n\n\tstart = sBlk.s.directory_table_start + (*i)->start;\n\toffset = (*i)->offset;\n\tsize = (*i)->data + bytes;\n\n\twhile(bytes < size) {\n\t\tif(swap) {\n\t\t\tsquashfs_dir_header_2 sdirh;\n\t\t\tres = read_directory_data(&sdirh, &start, &offset, sizeof(sdirh));\n\t\t\tif(res)\n\t\t\t\tSQUASHFS_SWAP_DIR_HEADER_2(&dirh, &sdirh);\n\t\t} else\n\t\t\tres = read_directory_data(&dirh, &start, &offset, sizeof(dirh));\n\n\t\tif(res == FALSE)\n\t\t\tgoto corrupted;\n\n\t\tdir_count = dirh.count + 1;\n\t\tTRACE(\"squashfs_opendir: Read directory header @ byte position \"\n\t\t\t\"%d, %d directory entries\\n\", bytes, dir_count);\n\t\tbytes += sizeof(dirh);\n\n\t\t/* dir_count should never be larger than SQUASHFS_DIR_COUNT */\n\t\tif(dir_count > SQUASHFS_DIR_COUNT) {\n\t\t\tERROR(\"File system corrupted: too many entries in directory\\n\");\n\t\t\tgoto corrupted;\n\t\t}\n\n\t\twhile(dir_count--) {\n\t\t\tif(swap) {\n\t\t\t\tsquashfs_dir_entry_2 sdire;\n\t\t\t\tres = read_directory_data(&sdire, &start,\n\t\t\t\t\t&offset, sizeof(sdire));\n\t\t\t\tif(res)\n\t\t\t\t\tSQUASHFS_SWAP_DIR_ENTRY_2(dire, &sdire);\n\t\t\t} else\n\t\t\t\tres = read_directory_data(dire, &start,\n\t\t\t\t\t&offset, sizeof(*dire));\n\n\t\t\tif(res == FALSE)\n\t\t\t\tgoto corrupted;\n\n\t\t\tbytes += sizeof(*dire);\n\n\t\t\t/* size should never be SQUASHFS_NAME_LEN or larger */\n\t\t\tif(dire->size >= SQUASHFS_NAME_LEN) {\n\t\t\t\tERROR(\"File system corrupted: filename too long\\n\");\n\t\t\t\tgoto corrupted;\n\t\t\t}\n\n\t\t\tres = read_directory_data(dire->name, &start, &offset,\n\t\t\t\t\t\t\t\tdire->size + 1);\n\n\t\t\tif(res == FALSE)\n\t\t\t\tgoto corrupted;\n\n\t\t\tdire->name[dire->size + 1] = '\\0';\n\n\t\t\t/* check name for invalid characters (i.e /, ., ..) */\n\t\t\tif(check_name(dire->name, dire->size + 1) == FALSE) {\n\t\t\t\tERROR(\"File system corrupted: invalid characters in name\\n\");\n\t\t\t\tgoto corrupted;\n\t\t\t}\n\n\t\t\tTRACE(\"squashfs_opendir: directory entry %s, inode \"\n\t\t\t\t\"%d:%d, type %d\\n\", dire->name,\n\t\t\t\tdirh.start_block, dire->offset, dire->type);\n\n\t\t\tent = malloc(sizeof(struct dir_ent));\n\t\t\tif(ent == NULL)\n\t\t\t\tMEM_ERROR();\n\n\t\t\tent->name = strdup(dire->name);\n\t\t\tent->start_block = dirh.start_block;\n\t\t\tent->offset = dire->offset;\n\t\t\tent->type = dire->type;\n\t\t\tent->next = NULL;\n\t\t\tif(cur_ent == NULL)\n\t\t\t\tdir->dirs = ent;\n\t\t\telse\n\t\t\t\tcur_ent->next = ent;\n\t\t\tcur_ent = ent;\n\t\t\tdir->dir_count ++;\n\t\t\tbytes += dire->size + 1;\n\t\t}\n\t}\n\n\tif(needs_sorting)\n\t\tsort_directory(dir);\n\n\t/* check directory for duplicate names and sorting */\n\tif(check_directory(dir) == FALSE) {\n\t\tif(needs_sorting)\n\t\t\tERROR(\"File system corrupted: directory has duplicate names\\n\");\n\t\telse\n\t\t\tERROR(\"File system corrupted: directory has duplicate names or is unsorted\\n\");\n\t\tgoto corrupted;\n\t}\n\treturn dir;\n\ncorrupted:\n\tsquashfs_closedir(dir);\n\treturn NULL;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -124,6 +124,17 @@\n \t\t}\n \t}\n \n+\tif(needs_sorting)\n+\t\tsort_directory(dir);\n+\n+\t/* check directory for duplicate names and sorting */\n+\tif(check_directory(dir) == FALSE) {\n+\t\tif(needs_sorting)\n+\t\t\tERROR(\"File system corrupted: directory has duplicate names\\n\");\n+\t\telse\n+\t\t\tERROR(\"File system corrupted: directory has duplicate names or is unsorted\\n\");\n+\t\tgoto corrupted;\n+\t}\n \treturn dir;\n \n corrupted:",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tif(needs_sorting)",
                "\t\tsort_directory(dir);",
                "",
                "\t/* check directory for duplicate names and sorting */",
                "\tif(check_directory(dir) == FALSE) {",
                "\t\tif(needs_sorting)",
                "\t\t\tERROR(\"File system corrupted: directory has duplicate names\\n\");",
                "\t\telse",
                "\t\t\tERROR(\"File system corrupted: directory has duplicate names or is unsorted\\n\");",
                "\t\tgoto corrupted;",
                "\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-41072",
        "func_name": "plougher/squashfs-tools/read_super_2",
        "description": "squashfs_opendir in unsquash-2.c in Squashfs-Tools 4.5 allows Directory Traversal, a different vulnerability than CVE-2021-40153. A squashfs filesystem that has been crafted to include a symbolic link and then contents under the same filename in a filesystem can cause unsquashfs to first create the symbolic link pointing outside the expected directory, and then the subsequent write operation will cause the unsquashfs process to write through the symbolic link elsewhere in the filesystem.",
        "git_url": "https://github.com/plougher/squashfs-tools/commit/e0485802ec72996c20026da320650d8362f555bd",
        "commit_title": "Unsquashfs: additional write outside destination directory exploit fix",
        "commit_text": " An issue on github (https://github.com/plougher/squashfs-tools/issues/72) showed how some specially crafted Squashfs filesystems containing invalid file names (with '/' and '..') can cause Unsquashfs to write files outside of the destination directory.  Since then it has been shown that specially crafted Squashfs filesystems that contain a symbolic link pointing outside of the destination directory, coupled with an identically named file within the same directory, can cause Unsquashfs to write files outside of the destination directory.  Specifically the symbolic link produces a pathname pointing outside of the destination directory, which is then followed when writing the duplicate identically named file within the directory.  This commit fixes this exploit by explictly checking for duplicate filenames within a directory.  As directories in v2.1, v3.x, and v4.0 filesystems are sorted, this is achieved by checking for consecutively identical filenames.  Additionally directories are checked to ensure they are sorted, to avoid attempts to evade the duplicate check.  Version 1.x and 2.0 filesystems (where the directories were unsorted) are sorted and then the above duplicate filename check is applied. ",
        "func_before": "int read_super_2(squashfs_operations **s_ops, void *s)\n{\n\t squashfs_super_block_3 *sBlk_3 = s;\n\n\tif(sBlk_3->s_magic != SQUASHFS_MAGIC || sBlk_3->s_major != 2 ||\n\t\t\t\t\t\t\tsBlk_3->s_minor > 1)\n\t\treturn -1;\n\n\tsBlk.s.s_magic = sBlk_3->s_magic;\n\tsBlk.s.inodes = sBlk_3->inodes;\n\tsBlk.s.mkfs_time = sBlk_3->mkfs_time;\n\tsBlk.s.block_size = sBlk_3->block_size;\n\tsBlk.s.fragments = sBlk_3->fragments;\n\tsBlk.s.block_log = sBlk_3->block_log;\n\tsBlk.s.flags = sBlk_3->flags;\n\tsBlk.s.s_major = sBlk_3->s_major;\n\tsBlk.s.s_minor = sBlk_3->s_minor;\n\tsBlk.s.root_inode = sBlk_3->root_inode;\n\tsBlk.s.bytes_used = sBlk_3->bytes_used_2;\n\tsBlk.s.inode_table_start = sBlk_3->inode_table_start;\n\tsBlk.s.directory_table_start = sBlk_3->directory_table_start_2;\n\tsBlk.s.fragment_table_start = sBlk_3->fragment_table_start_2;\n\tsBlk.s.inode_table_start = sBlk_3->inode_table_start_2;\n\tsBlk.no_uids = sBlk_3->no_uids;\n\tsBlk.no_guids = sBlk_3->no_guids;\n\tsBlk.uid_start = sBlk_3->uid_start_2;\n\tsBlk.guid_start = sBlk_3->guid_start_2;\n\tsBlk.s.xattr_id_table_start = SQUASHFS_INVALID_BLK;\n\n\t*s_ops = &ops;\n\n\t/*\n\t * 2.x filesystems use gzip compression.\n\t */\n\tcomp = lookup_compressor(\"gzip\");\n\treturn TRUE;\n}",
        "func": "int read_super_2(squashfs_operations **s_ops, void *s)\n{\n\t squashfs_super_block_3 *sBlk_3 = s;\n\n\tif(sBlk_3->s_magic != SQUASHFS_MAGIC || sBlk_3->s_major != 2 ||\n\t\t\t\t\t\t\tsBlk_3->s_minor > 1)\n\t\treturn -1;\n\n\tsBlk.s.s_magic = sBlk_3->s_magic;\n\tsBlk.s.inodes = sBlk_3->inodes;\n\tsBlk.s.mkfs_time = sBlk_3->mkfs_time;\n\tsBlk.s.block_size = sBlk_3->block_size;\n\tsBlk.s.fragments = sBlk_3->fragments;\n\tsBlk.s.block_log = sBlk_3->block_log;\n\tsBlk.s.flags = sBlk_3->flags;\n\tsBlk.s.s_major = sBlk_3->s_major;\n\tsBlk.s.s_minor = sBlk_3->s_minor;\n\tsBlk.s.root_inode = sBlk_3->root_inode;\n\tsBlk.s.bytes_used = sBlk_3->bytes_used_2;\n\tsBlk.s.inode_table_start = sBlk_3->inode_table_start;\n\tsBlk.s.directory_table_start = sBlk_3->directory_table_start_2;\n\tsBlk.s.fragment_table_start = sBlk_3->fragment_table_start_2;\n\tsBlk.s.inode_table_start = sBlk_3->inode_table_start_2;\n\tsBlk.no_uids = sBlk_3->no_uids;\n\tsBlk.no_guids = sBlk_3->no_guids;\n\tsBlk.uid_start = sBlk_3->uid_start_2;\n\tsBlk.guid_start = sBlk_3->guid_start_2;\n\tsBlk.s.xattr_id_table_start = SQUASHFS_INVALID_BLK;\n\n\t*s_ops = &ops;\n\n\t/*\n\t * 2.x filesystems use gzip compression.\n\t */\n\tcomp = lookup_compressor(\"gzip\");\n\n\tif(sBlk_3->s_minor == 0)\n\t\tneeds_sorting = TRUE;\n\n\treturn TRUE;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -33,5 +33,9 @@\n \t * 2.x filesystems use gzip compression.\n \t */\n \tcomp = lookup_compressor(\"gzip\");\n+\n+\tif(sBlk_3->s_minor == 0)\n+\t\tneeds_sorting = TRUE;\n+\n \treturn TRUE;\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "\tif(sBlk_3->s_minor == 0)",
                "\t\tneeds_sorting = TRUE;",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2021-41072",
        "func_name": "plougher/squashfs-tools/squashfs_opendir",
        "description": "squashfs_opendir in unsquash-2.c in Squashfs-Tools 4.5 allows Directory Traversal, a different vulnerability than CVE-2021-40153. A squashfs filesystem that has been crafted to include a symbolic link and then contents under the same filename in a filesystem can cause unsquashfs to first create the symbolic link pointing outside the expected directory, and then the subsequent write operation will cause the unsquashfs process to write through the symbolic link elsewhere in the filesystem.",
        "git_url": "https://github.com/plougher/squashfs-tools/commit/e0485802ec72996c20026da320650d8362f555bd",
        "commit_title": "Unsquashfs: additional write outside destination directory exploit fix",
        "commit_text": " An issue on github (https://github.com/plougher/squashfs-tools/issues/72) showed how some specially crafted Squashfs filesystems containing invalid file names (with '/' and '..') can cause Unsquashfs to write files outside of the destination directory.  Since then it has been shown that specially crafted Squashfs filesystems that contain a symbolic link pointing outside of the destination directory, coupled with an identically named file within the same directory, can cause Unsquashfs to write files outside of the destination directory.  Specifically the symbolic link produces a pathname pointing outside of the destination directory, which is then followed when writing the duplicate identically named file within the directory.  This commit fixes this exploit by explictly checking for duplicate filenames within a directory.  As directories in v2.1, v3.x, and v4.0 filesystems are sorted, this is achieved by checking for consecutively identical filenames.  Additionally directories are checked to ensure they are sorted, to avoid attempts to evade the duplicate check.  Version 1.x and 2.0 filesystems (where the directories were unsorted) are sorted and then the above duplicate filename check is applied. ",
        "func_before": "static struct dir *squashfs_opendir(unsigned int block_start, unsigned int offset,\n\tstruct inode **i)\n{\n\tsquashfs_dir_header_3 dirh;\n\tchar buffer[sizeof(squashfs_dir_entry_3) + SQUASHFS_NAME_LEN + 1]\n\t\t__attribute__((aligned));\n\tsquashfs_dir_entry_3 *dire = (squashfs_dir_entry_3 *) buffer;\n\tlong long start;\n\tint bytes = 0;\n\tint dir_count, size, res;\n\tstruct dir_ent *ent, *cur_ent = NULL;\n\tstruct dir *dir;\n\n\tTRACE(\"squashfs_opendir: inode start block %d, offset %d\\n\",\n\t\tblock_start, offset);\n\n\t*i = read_inode(block_start, offset);\n\n\tdir = malloc(sizeof(struct dir));\n\tif(dir == NULL)\n\t\tMEM_ERROR();\n\n\tdir->dir_count = 0;\n\tdir->cur_entry = NULL;\n\tdir->mode = (*i)->mode;\n\tdir->uid = (*i)->uid;\n\tdir->guid = (*i)->gid;\n\tdir->mtime = (*i)->time;\n\tdir->xattr = (*i)->xattr;\n\tdir->dirs = NULL;\n\n\tif ((*i)->data == 3)\n\t\t/*\n\t\t * if the directory is empty, skip the unnecessary\n\t\t * lookup_entry, this fixes the corner case with\n\t\t * completely empty filesystems where lookup_entry correctly\n\t\t * returning -1 is incorrectly treated as an error\n\t\t */\n\t\treturn dir;\n\n\tstart = sBlk.s.directory_table_start + (*i)->start;\n\toffset = (*i)->offset;\n\tsize = (*i)->data + bytes - 3;\n\n\twhile(bytes < size) {\t\t\t\n\t\tif(swap) {\n\t\t\tsquashfs_dir_header_3 sdirh;\n\t\t\tres = read_directory_data(&sdirh, &start, &offset, sizeof(sdirh));\n\t\t\tif(res)\n\t\t\t\tSQUASHFS_SWAP_DIR_HEADER_3(&dirh, &sdirh);\n\t\t} else\n\t\t\tres = read_directory_data(&dirh, &start, &offset, sizeof(dirh));\n\t\n\t\tif(res == FALSE)\n\t\t\tgoto corrupted;\n\n\t\tdir_count = dirh.count + 1;\n\t\tTRACE(\"squashfs_opendir: Read directory header @ byte position \"\n\t\t\t\"%d, %d directory entries\\n\", bytes, dir_count);\n\t\tbytes += sizeof(dirh);\n\n\t\t/* dir_count should never be larger than SQUASHFS_DIR_COUNT */\n\t\tif(dir_count > SQUASHFS_DIR_COUNT) {\n\t\t\tERROR(\"File system corrupted: too many entries in directory\\n\");\n\t\t\tgoto corrupted;\n\t\t}\n\n\t\twhile(dir_count--) {\n\t\t\tif(swap) {\n\t\t\t\tsquashfs_dir_entry_3 sdire;\n\t\t\t\tres = read_directory_data(&sdire, &start,\n\t\t\t\t\t&offset, sizeof(sdire));\n\t\t\t\tif(res)\n\t\t\t\t\tSQUASHFS_SWAP_DIR_ENTRY_3(dire, &sdire);\n\t\t\t} else\n\t\t\t\tres = read_directory_data(dire, &start,\n\t\t\t\t\t&offset, sizeof(*dire));\n\n\t\t\tif(res == FALSE)\n\t\t\t\tgoto corrupted;\n\n\t\t\tbytes += sizeof(*dire);\n\n\t\t\t/* size should never be SQUASHFS_NAME_LEN or larger */\n\t\t\tif(dire->size >= SQUASHFS_NAME_LEN) {\n\t\t\t\tERROR(\"File system corrupted: filename too long\\n\");\n\t\t\t\tgoto corrupted;\n\t\t\t}\n\n\t\t\tres = read_directory_data(dire->name, &start, &offset,\n\t\t\t\t\t\t\t\tdire->size + 1);\n\n\t\t\tif(res == FALSE)\n\t\t\t\tgoto corrupted;\n\n\t\t\tdire->name[dire->size + 1] = '\\0';\n\n\t\t\t/* check name for invalid characters (i.e /, ., ..) */\n\t\t\tif(check_name(dire->name, dire->size + 1) == FALSE) {\n\t\t\t\tERROR(\"File system corrupted: invalid characters in name\\n\");\n\t\t\t\tgoto corrupted;\n\t\t\t}\n\n\t\t\tTRACE(\"squashfs_opendir: directory entry %s, inode \"\n\t\t\t\t\"%d:%d, type %d\\n\", dire->name,\n\t\t\t\tdirh.start_block, dire->offset, dire->type);\n\n\t\t\tent = malloc(sizeof(struct dir_ent));\n\t\t\tif(ent == NULL)\n\t\t\t\tMEM_ERROR();\n\n\t\t\tent->name = strdup(dire->name);\n\t\t\tent->start_block = dirh.start_block;\n\t\t\tent->offset = dire->offset;\n\t\t\tent->type = dire->type;\n\t\t\tent->next = NULL;\n\t\t\tif(cur_ent == NULL)\n\t\t\t\tdir->dirs = ent;\n\t\t\telse\n\t\t\t\tcur_ent->next = ent;\n\t\t\tcur_ent = ent;\n\t\t\tdir->dir_count ++;\n\t\t\tbytes += dire->size + 1;\n\t\t}\n\t}\n\n\treturn dir;\n\ncorrupted:\n\tsquashfs_closedir(dir);\n\treturn NULL;\n}",
        "func": "static struct dir *squashfs_opendir(unsigned int block_start, unsigned int offset,\n\tstruct inode **i)\n{\n\tsquashfs_dir_header_3 dirh;\n\tchar buffer[sizeof(squashfs_dir_entry_3) + SQUASHFS_NAME_LEN + 1]\n\t\t__attribute__((aligned));\n\tsquashfs_dir_entry_3 *dire = (squashfs_dir_entry_3 *) buffer;\n\tlong long start;\n\tint bytes = 0;\n\tint dir_count, size, res;\n\tstruct dir_ent *ent, *cur_ent = NULL;\n\tstruct dir *dir;\n\n\tTRACE(\"squashfs_opendir: inode start block %d, offset %d\\n\",\n\t\tblock_start, offset);\n\n\t*i = read_inode(block_start, offset);\n\n\tdir = malloc(sizeof(struct dir));\n\tif(dir == NULL)\n\t\tMEM_ERROR();\n\n\tdir->dir_count = 0;\n\tdir->cur_entry = NULL;\n\tdir->mode = (*i)->mode;\n\tdir->uid = (*i)->uid;\n\tdir->guid = (*i)->gid;\n\tdir->mtime = (*i)->time;\n\tdir->xattr = (*i)->xattr;\n\tdir->dirs = NULL;\n\n\tif ((*i)->data == 3)\n\t\t/*\n\t\t * if the directory is empty, skip the unnecessary\n\t\t * lookup_entry, this fixes the corner case with\n\t\t * completely empty filesystems where lookup_entry correctly\n\t\t * returning -1 is incorrectly treated as an error\n\t\t */\n\t\treturn dir;\n\n\tstart = sBlk.s.directory_table_start + (*i)->start;\n\toffset = (*i)->offset;\n\tsize = (*i)->data + bytes - 3;\n\n\twhile(bytes < size) {\t\t\t\n\t\tif(swap) {\n\t\t\tsquashfs_dir_header_3 sdirh;\n\t\t\tres = read_directory_data(&sdirh, &start, &offset, sizeof(sdirh));\n\t\t\tif(res)\n\t\t\t\tSQUASHFS_SWAP_DIR_HEADER_3(&dirh, &sdirh);\n\t\t} else\n\t\t\tres = read_directory_data(&dirh, &start, &offset, sizeof(dirh));\n\t\n\t\tif(res == FALSE)\n\t\t\tgoto corrupted;\n\n\t\tdir_count = dirh.count + 1;\n\t\tTRACE(\"squashfs_opendir: Read directory header @ byte position \"\n\t\t\t\"%d, %d directory entries\\n\", bytes, dir_count);\n\t\tbytes += sizeof(dirh);\n\n\t\t/* dir_count should never be larger than SQUASHFS_DIR_COUNT */\n\t\tif(dir_count > SQUASHFS_DIR_COUNT) {\n\t\t\tERROR(\"File system corrupted: too many entries in directory\\n\");\n\t\t\tgoto corrupted;\n\t\t}\n\n\t\twhile(dir_count--) {\n\t\t\tif(swap) {\n\t\t\t\tsquashfs_dir_entry_3 sdire;\n\t\t\t\tres = read_directory_data(&sdire, &start,\n\t\t\t\t\t&offset, sizeof(sdire));\n\t\t\t\tif(res)\n\t\t\t\t\tSQUASHFS_SWAP_DIR_ENTRY_3(dire, &sdire);\n\t\t\t} else\n\t\t\t\tres = read_directory_data(dire, &start,\n\t\t\t\t\t&offset, sizeof(*dire));\n\n\t\t\tif(res == FALSE)\n\t\t\t\tgoto corrupted;\n\n\t\t\tbytes += sizeof(*dire);\n\n\t\t\t/* size should never be SQUASHFS_NAME_LEN or larger */\n\t\t\tif(dire->size >= SQUASHFS_NAME_LEN) {\n\t\t\t\tERROR(\"File system corrupted: filename too long\\n\");\n\t\t\t\tgoto corrupted;\n\t\t\t}\n\n\t\t\tres = read_directory_data(dire->name, &start, &offset,\n\t\t\t\t\t\t\t\tdire->size + 1);\n\n\t\t\tif(res == FALSE)\n\t\t\t\tgoto corrupted;\n\n\t\t\tdire->name[dire->size + 1] = '\\0';\n\n\t\t\t/* check name for invalid characters (i.e /, ., ..) */\n\t\t\tif(check_name(dire->name, dire->size + 1) == FALSE) {\n\t\t\t\tERROR(\"File system corrupted: invalid characters in name\\n\");\n\t\t\t\tgoto corrupted;\n\t\t\t}\n\n\t\t\tTRACE(\"squashfs_opendir: directory entry %s, inode \"\n\t\t\t\t\"%d:%d, type %d\\n\", dire->name,\n\t\t\t\tdirh.start_block, dire->offset, dire->type);\n\n\t\t\tent = malloc(sizeof(struct dir_ent));\n\t\t\tif(ent == NULL)\n\t\t\t\tMEM_ERROR();\n\n\t\t\tent->name = strdup(dire->name);\n\t\t\tent->start_block = dirh.start_block;\n\t\t\tent->offset = dire->offset;\n\t\t\tent->type = dire->type;\n\t\t\tent->next = NULL;\n\t\t\tif(cur_ent == NULL)\n\t\t\t\tdir->dirs = ent;\n\t\t\telse\n\t\t\t\tcur_ent->next = ent;\n\t\t\tcur_ent = ent;\n\t\t\tdir->dir_count ++;\n\t\t\tbytes += dire->size + 1;\n\t\t}\n\t}\n\n\t/* check directory for duplicate names and sorting */\n\tif(check_directory(dir) == FALSE) {\n\t\tERROR(\"File system corrupted: directory has duplicate names or is unsorted\\n\");\n\t\tgoto corrupted;\n\t}\n\n\treturn dir;\n\ncorrupted:\n\tsquashfs_closedir(dir);\n\treturn NULL;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -124,6 +124,12 @@\n \t\t}\n \t}\n \n+\t/* check directory for duplicate names and sorting */\n+\tif(check_directory(dir) == FALSE) {\n+\t\tERROR(\"File system corrupted: directory has duplicate names or is unsorted\\n\");\n+\t\tgoto corrupted;\n+\t}\n+\n \treturn dir;\n \n corrupted:",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t/* check directory for duplicate names and sorting */",
                "\tif(check_directory(dir) == FALSE) {",
                "\t\tERROR(\"File system corrupted: directory has duplicate names or is unsorted\\n\");",
                "\t\tgoto corrupted;",
                "\t}",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2021-41072",
        "func_name": "plougher/squashfs-tools/squashfs_opendir",
        "description": "squashfs_opendir in unsquash-2.c in Squashfs-Tools 4.5 allows Directory Traversal, a different vulnerability than CVE-2021-40153. A squashfs filesystem that has been crafted to include a symbolic link and then contents under the same filename in a filesystem can cause unsquashfs to first create the symbolic link pointing outside the expected directory, and then the subsequent write operation will cause the unsquashfs process to write through the symbolic link elsewhere in the filesystem.",
        "git_url": "https://github.com/plougher/squashfs-tools/commit/e0485802ec72996c20026da320650d8362f555bd",
        "commit_title": "Unsquashfs: additional write outside destination directory exploit fix",
        "commit_text": " An issue on github (https://github.com/plougher/squashfs-tools/issues/72) showed how some specially crafted Squashfs filesystems containing invalid file names (with '/' and '..') can cause Unsquashfs to write files outside of the destination directory.  Since then it has been shown that specially crafted Squashfs filesystems that contain a symbolic link pointing outside of the destination directory, coupled with an identically named file within the same directory, can cause Unsquashfs to write files outside of the destination directory.  Specifically the symbolic link produces a pathname pointing outside of the destination directory, which is then followed when writing the duplicate identically named file within the directory.  This commit fixes this exploit by explictly checking for duplicate filenames within a directory.  As directories in v2.1, v3.x, and v4.0 filesystems are sorted, this is achieved by checking for consecutively identical filenames.  Additionally directories are checked to ensure they are sorted, to avoid attempts to evade the duplicate check.  Version 1.x and 2.0 filesystems (where the directories were unsorted) are sorted and then the above duplicate filename check is applied. ",
        "func_before": "static struct dir *squashfs_opendir(unsigned int block_start, unsigned int offset,\n\tstruct inode **i)\n{\n\tsquashfs_dir_header_2 dirh;\n\tchar buffer[sizeof(squashfs_dir_entry_2) + SQUASHFS_NAME_LEN + 1]\n\t\t__attribute__((aligned));\n\tsquashfs_dir_entry_2 *dire = (squashfs_dir_entry_2 *) buffer;\n\tlong long start;\n\tint bytes = 0;\n\tint dir_count, size, res;\n\tstruct dir_ent *ent, *cur_ent = NULL;\n\tstruct dir *dir;\n\n\tTRACE(\"squashfs_opendir: inode start block %d, offset %d\\n\",\n\t\tblock_start, offset);\n\n\t*i = read_inode(block_start, offset);\n\n\tdir = malloc(sizeof(struct dir));\n\tif(dir == NULL)\n\t\tMEM_ERROR();\n\n\tdir->dir_count = 0;\n\tdir->cur_entry = NULL;\n\tdir->mode = (*i)->mode;\n\tdir->uid = (*i)->uid;\n\tdir->guid = (*i)->gid;\n\tdir->mtime = (*i)->time;\n\tdir->xattr = (*i)->xattr;\n\tdir->dirs = NULL;\n\n\tif ((*i)->data == 0)\n\t\t/*\n\t\t * if the directory is empty, skip the unnecessary\n\t\t * lookup_entry, this fixes the corner case with\n\t\t * completely empty filesystems where lookup_entry correctly\n\t\t * returning -1 is incorrectly treated as an error\n\t\t */\n\t\treturn dir;\n\t\t\n\tstart = sBlk.s.directory_table_start + (*i)->start;\n\toffset = (*i)->offset;\n\tsize = (*i)->data + bytes;\n\n\twhile(bytes < size) {\t\t\t\n\t\tif(swap) {\n\t\t\tsquashfs_dir_header_2 sdirh;\n\t\t\tres = read_directory_data(&sdirh, &start, &offset, sizeof(sdirh));\n\t\t\tif(res)\n\t\t\t\tSQUASHFS_SWAP_DIR_HEADER_2(&dirh, &sdirh);\n\t\t} else\n\t\t\tres = read_directory_data(&dirh, &start, &offset, sizeof(dirh));\n\n\t\tif(res == FALSE)\n\t\t\tgoto corrupted;\n\t\n\t\tdir_count = dirh.count + 1;\n\t\tTRACE(\"squashfs_opendir: Read directory header @ byte position \"\n\t\t\t\"%d, %d directory entries\\n\", bytes, dir_count);\n\t\tbytes += sizeof(dirh);\n\n\t\t/* dir_count should never be larger than SQUASHFS_DIR_COUNT */\n\t\tif(dir_count > SQUASHFS_DIR_COUNT) {\n\t\t\tERROR(\"File system corrupted: too many entries in directory\\n\");\n\t\t\tgoto corrupted;\n\t\t}\n\n\t\twhile(dir_count--) {\n\t\t\tif(swap) {\n\t\t\t\tsquashfs_dir_entry_2 sdire;\n\t\t\t\tres = read_directory_data(&sdire, &start,\n\t\t\t\t\t&offset, sizeof(sdire));\n\t\t\t\tif(res)\n\t\t\t\t\tSQUASHFS_SWAP_DIR_ENTRY_2(dire, &sdire);\n\t\t\t} else\n\t\t\t\tres = read_directory_data(dire, &start,\n\t\t\t\t\t&offset, sizeof(*dire));\n\n\t\t\tif(res == FALSE)\n\t\t\t\tgoto corrupted;\n\n\t\t\tbytes += sizeof(*dire);\n\n\t\t\t/* size should never be SQUASHFS_NAME_LEN or larger */\n\t\t\tif(dire->size >= SQUASHFS_NAME_LEN) {\n\t\t\t\tERROR(\"File system corrupted: filename too long\\n\");\n\t\t\t\tgoto corrupted;\n\t\t\t}\n\n\t\t\tres = read_directory_data(dire->name, &start, &offset,\n\t\t\t\t\t\t\t\tdire->size + 1);\n\n\t\t\tif(res == FALSE)\n\t\t\t\tgoto corrupted;\n\n\t\t\tdire->name[dire->size + 1] = '\\0';\n\n\t\t\t/* check name for invalid characters (i.e /, ., ..) */\n\t\t\tif(check_name(dire->name, dire->size + 1) == FALSE) {\n\t\t\t\tERROR(\"File system corrupted: invalid characters in name\\n\");\n\t\t\t\tgoto corrupted;\n\t\t\t}\n\n\t\t\tTRACE(\"squashfs_opendir: directory entry %s, inode \"\n\t\t\t\t\"%d:%d, type %d\\n\", dire->name,\n\t\t\t\tdirh.start_block, dire->offset, dire->type);\n\n\t\t\tent = malloc(sizeof(struct dir_ent));\n\t\t\tif(ent == NULL)\n\t\t\t\tMEM_ERROR();\n\n\t\t\tent->name = strdup(dire->name);\n\t\t\tent->start_block = dirh.start_block;\n\t\t\tent->offset = dire->offset;\n\t\t\tent->type = dire->type;\n\t\t\tent->next = NULL;\n\t\t\tif(cur_ent == NULL)\n\t\t\t\tdir->dirs = ent;\n\t\t\telse\n\t\t\t\tcur_ent->next = ent;\n\t\t\tcur_ent = ent;\n\t\t\tdir->dir_count ++;\n\t\t\tbytes += dire->size + 1;\n\t\t}\n\t}\n\n\treturn dir;\n\ncorrupted:\n\tsquashfs_closedir(dir);\n\treturn NULL;\n}",
        "func": "static struct dir *squashfs_opendir(unsigned int block_start, unsigned int offset,\n\tstruct inode **i)\n{\n\tsquashfs_dir_header_2 dirh;\n\tchar buffer[sizeof(squashfs_dir_entry_2) + SQUASHFS_NAME_LEN + 1]\n\t\t__attribute__((aligned));\n\tsquashfs_dir_entry_2 *dire = (squashfs_dir_entry_2 *) buffer;\n\tlong long start;\n\tint bytes = 0;\n\tint dir_count, size, res;\n\tstruct dir_ent *ent, *cur_ent = NULL;\n\tstruct dir *dir;\n\n\tTRACE(\"squashfs_opendir: inode start block %d, offset %d\\n\",\n\t\tblock_start, offset);\n\n\t*i = read_inode(block_start, offset);\n\n\tdir = malloc(sizeof(struct dir));\n\tif(dir == NULL)\n\t\tMEM_ERROR();\n\n\tdir->dir_count = 0;\n\tdir->cur_entry = NULL;\n\tdir->mode = (*i)->mode;\n\tdir->uid = (*i)->uid;\n\tdir->guid = (*i)->gid;\n\tdir->mtime = (*i)->time;\n\tdir->xattr = (*i)->xattr;\n\tdir->dirs = NULL;\n\n\tif ((*i)->data == 0)\n\t\t/*\n\t\t * if the directory is empty, skip the unnecessary\n\t\t * lookup_entry, this fixes the corner case with\n\t\t * completely empty filesystems where lookup_entry correctly\n\t\t * returning -1 is incorrectly treated as an error\n\t\t */\n\t\treturn dir;\n\t\t\n\tstart = sBlk.s.directory_table_start + (*i)->start;\n\toffset = (*i)->offset;\n\tsize = (*i)->data + bytes;\n\n\twhile(bytes < size) {\t\t\t\n\t\tif(swap) {\n\t\t\tsquashfs_dir_header_2 sdirh;\n\t\t\tres = read_directory_data(&sdirh, &start, &offset, sizeof(sdirh));\n\t\t\tif(res)\n\t\t\t\tSQUASHFS_SWAP_DIR_HEADER_2(&dirh, &sdirh);\n\t\t} else\n\t\t\tres = read_directory_data(&dirh, &start, &offset, sizeof(dirh));\n\n\t\tif(res == FALSE)\n\t\t\tgoto corrupted;\n\t\n\t\tdir_count = dirh.count + 1;\n\t\tTRACE(\"squashfs_opendir: Read directory header @ byte position \"\n\t\t\t\"%d, %d directory entries\\n\", bytes, dir_count);\n\t\tbytes += sizeof(dirh);\n\n\t\t/* dir_count should never be larger than SQUASHFS_DIR_COUNT */\n\t\tif(dir_count > SQUASHFS_DIR_COUNT) {\n\t\t\tERROR(\"File system corrupted: too many entries in directory\\n\");\n\t\t\tgoto corrupted;\n\t\t}\n\n\t\twhile(dir_count--) {\n\t\t\tif(swap) {\n\t\t\t\tsquashfs_dir_entry_2 sdire;\n\t\t\t\tres = read_directory_data(&sdire, &start,\n\t\t\t\t\t&offset, sizeof(sdire));\n\t\t\t\tif(res)\n\t\t\t\t\tSQUASHFS_SWAP_DIR_ENTRY_2(dire, &sdire);\n\t\t\t} else\n\t\t\t\tres = read_directory_data(dire, &start,\n\t\t\t\t\t&offset, sizeof(*dire));\n\n\t\t\tif(res == FALSE)\n\t\t\t\tgoto corrupted;\n\n\t\t\tbytes += sizeof(*dire);\n\n\t\t\t/* size should never be SQUASHFS_NAME_LEN or larger */\n\t\t\tif(dire->size >= SQUASHFS_NAME_LEN) {\n\t\t\t\tERROR(\"File system corrupted: filename too long\\n\");\n\t\t\t\tgoto corrupted;\n\t\t\t}\n\n\t\t\tres = read_directory_data(dire->name, &start, &offset,\n\t\t\t\t\t\t\t\tdire->size + 1);\n\n\t\t\tif(res == FALSE)\n\t\t\t\tgoto corrupted;\n\n\t\t\tdire->name[dire->size + 1] = '\\0';\n\n\t\t\t/* check name for invalid characters (i.e /, ., ..) */\n\t\t\tif(check_name(dire->name, dire->size + 1) == FALSE) {\n\t\t\t\tERROR(\"File system corrupted: invalid characters in name\\n\");\n\t\t\t\tgoto corrupted;\n\t\t\t}\n\n\t\t\tTRACE(\"squashfs_opendir: directory entry %s, inode \"\n\t\t\t\t\"%d:%d, type %d\\n\", dire->name,\n\t\t\t\tdirh.start_block, dire->offset, dire->type);\n\n\t\t\tent = malloc(sizeof(struct dir_ent));\n\t\t\tif(ent == NULL)\n\t\t\t\tMEM_ERROR();\n\n\t\t\tent->name = strdup(dire->name);\n\t\t\tent->start_block = dirh.start_block;\n\t\t\tent->offset = dire->offset;\n\t\t\tent->type = dire->type;\n\t\t\tent->next = NULL;\n\t\t\tif(cur_ent == NULL)\n\t\t\t\tdir->dirs = ent;\n\t\t\telse\n\t\t\t\tcur_ent->next = ent;\n\t\t\tcur_ent = ent;\n\t\t\tdir->dir_count ++;\n\t\t\tbytes += dire->size + 1;\n\t\t}\n\t}\n\n\t/* check directory for duplicate names.  Need to sort directory first */\n\tsort_directory(dir);\n\tif(check_directory(dir) == FALSE) {\n\t\tERROR(\"File system corrupted: directory has duplicate names\\n\");\n\t\tgoto corrupted;\n\t}\n\treturn dir;\n\ncorrupted:\n\tsquashfs_closedir(dir);\n\treturn NULL;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -124,6 +124,12 @@\n \t\t}\n \t}\n \n+\t/* check directory for duplicate names.  Need to sort directory first */\n+\tsort_directory(dir);\n+\tif(check_directory(dir) == FALSE) {\n+\t\tERROR(\"File system corrupted: directory has duplicate names\\n\");\n+\t\tgoto corrupted;\n+\t}\n \treturn dir;\n \n corrupted:",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t/* check directory for duplicate names.  Need to sort directory first */",
                "\tsort_directory(dir);",
                "\tif(check_directory(dir) == FALSE) {",
                "\t\tERROR(\"File system corrupted: directory has duplicate names\\n\");",
                "\t\tgoto corrupted;",
                "\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-7501",
        "func_name": "rpm-software-management/rpm/rpmPackageFilesInstall",
        "description": "It was found that versions of rpm before 4.13.0.2 use temporary files with predictable names when installing an RPM. An attacker with ability to write in a directory where files will be installed could create symbolic links to an arbitrary location and modify content, and possibly permissions to arbitrary files, which could be used for denial of service or possibly privilege escalation.",
        "git_url": "https://github.com/rpm-software-management/rpm/commit/404ef011c300207cdb1e531670384564aae04bdc",
        "commit_title": "Don't follow symlinks on file creation (CVE-2017-7501)",
        "commit_text": " Open newly created files with O_EXCL to prevent symlink tricks. When reopening hardlinks for writing the actual content, use append mode instead. This is compatible with the write-only permissions but is not destructive in case we got redirected to somebody elses file, verify the target before actually writing anything.  As these are files with the temporary suffix, errors mean a local user with sufficient privileges to break the installation of the package anyway is trying to goof us on purpose, don't bother trying to mend it (we couldn't fix the hardlink case anyhow) but just bail out.  Based on a patch by Florian Festi.",
        "func_before": "int rpmPackageFilesInstall(rpmts ts, rpmte te, rpmfiles files,\n              rpmpsm psm, char ** failedFile)\n{\n    FD_t payload = rpmtePayload(te);\n    rpmfi fi = rpmfiNewArchiveReader(payload, files, RPMFI_ITER_READ_ARCHIVE);\n    rpmfs fs = rpmteGetFileStates(te);\n    rpmPlugins plugins = rpmtsPlugins(ts);\n    struct stat sb;\n    int saveerrno = errno;\n    int rc = 0;\n    int nodigest = (rpmtsFlags(ts) & RPMTRANS_FLAG_NOFILEDIGEST) ? 1 : 0;\n    int nofcaps = (rpmtsFlags(ts) & RPMTRANS_FLAG_NOCAPS) ? 1 : 0;\n    int firsthardlink = -1;\n    int skip;\n    rpmFileAction action;\n    char *tid = NULL;\n    const char *suffix;\n    char *fpath = NULL;\n\n    if (fi == NULL) {\n\trc = RPMERR_BAD_MAGIC;\n\tgoto exit;\n    }\n\n    /* transaction id used for temporary path suffix while installing */\n    rasprintf(&tid, \";%08x\", (unsigned)rpmtsGetTid(ts));\n\n    /* Detect and create directories not explicitly in package. */\n    rc = fsmMkdirs(files, fs, plugins);\n\n    while (!rc) {\n\t/* Read next payload header. */\n\trc = rpmfiNext(fi);\n\n\tif (rc < 0) {\n\t    if (rc == RPMERR_ITER_END)\n\t\trc = 0;\n\t    break;\n\t}\n\n\taction = rpmfsGetAction(fs, rpmfiFX(fi));\n\tskip = XFA_SKIPPING(action);\n\tsuffix = S_ISDIR(rpmfiFMode(fi)) ? NULL : tid;\n\tif (action != FA_TOUCH) {\n\t    fpath = fsmFsPath(fi, suffix);\n\t} else {\n\t    fpath = fsmFsPath(fi, \"\");\n\t}\n\n\t/* Remap file perms, owner, and group. */\n\trc = rpmfiStat(fi, 1, &sb);\n\n\tfsmDebug(fpath, action, &sb);\n\n        /* Exit on error. */\n        if (rc)\n            break;\n\n\t/* Run fsm file pre hook for all plugins */\n\trc = rpmpluginsCallFsmFilePre(plugins, fi, fpath,\n\t\t\t\t      sb.st_mode, action);\n\tif (rc) {\n\t    skip = 1;\n\t} else {\n\t    setFileState(fs, rpmfiFX(fi));\n\t}\n\n        if (!skip) {\n\t    int setmeta = 1;\n\n\t    /* Directories replacing something need early backup */\n\t    if (!suffix) {\n\t\trc = fsmBackup(fi, action);\n\t    }\n\t    /* Assume file does't exist when tmp suffix is in use */\n\t    if (!suffix) {\n\t\trc = fsmVerify(fpath, fi);\n\t    } else {\n\t\trc = (action == FA_TOUCH) ? 0 : RPMERR_ENOENT;\n\t    }\n\n            if (S_ISREG(sb.st_mode)) {\n\t\tif (rc == RPMERR_ENOENT) {\n\t\t    rc = fsmMkfile(fi, fpath, files, psm, nodigest,\n\t\t\t\t   &setmeta, &firsthardlink);\n\t\t}\n            } else if (S_ISDIR(sb.st_mode)) {\n                if (rc == RPMERR_ENOENT) {\n                    mode_t mode = sb.st_mode;\n                    mode &= ~07777;\n                    mode |=  00700;\n                    rc = fsmMkdir(fpath, mode);\n                }\n            } else if (S_ISLNK(sb.st_mode)) {\n\t\tif (rc == RPMERR_ENOENT) {\n\t\t    rc = fsmSymlink(rpmfiFLink(fi), fpath);\n\t\t}\n            } else if (S_ISFIFO(sb.st_mode)) {\n                /* This mimics cpio S_ISSOCK() behavior but probably isn't right */\n                if (rc == RPMERR_ENOENT) {\n                    rc = fsmMkfifo(fpath, 0000);\n                }\n            } else if (S_ISCHR(sb.st_mode) ||\n                       S_ISBLK(sb.st_mode) ||\n                       S_ISSOCK(sb.st_mode))\n            {\n                if (rc == RPMERR_ENOENT) {\n                    rc = fsmMknod(fpath, sb.st_mode, sb.st_rdev);\n                }\n            } else {\n                /* XXX Special case /dev/log, which shouldn't be packaged anyways */\n                if (!IS_DEV_LOG(fpath))\n                    rc = RPMERR_UNKNOWN_FILETYPE;\n            }\n\t    /* Set permissions, timestamps etc for non-hardlink entries */\n\t    if (!rc && setmeta) {\n\t\trc = fsmSetmeta(fpath, fi, plugins, action, &sb, nofcaps);\n\t    }\n        } else if (firsthardlink >= 0 && rpmfiArchiveHasContent(fi)) {\n\t    /* we skip the hard linked file containing the content */\n\t    /* write the content to the first used instead */\n\t    char *fn = rpmfilesFN(files, firsthardlink);\n\t    rc = expandRegular(fi, fn, psm, nodigest, 0);\n\t    firsthardlink = -1;\n\t    free(fn);\n\t}\n\n        if (rc) {\n            if (!skip) {\n                /* XXX only erase if temp fn w suffix is in use */\n                if (suffix && (action != FA_TOUCH)) {\n\t\t    (void) fsmRemove(fpath, sb.st_mode);\n                }\n                errno = saveerrno;\n            }\n        } else {\n\t    /* Notify on success. */\n\t    rpmpsmNotify(psm, RPMCALLBACK_INST_PROGRESS, rpmfiArchiveTell(fi));\n\n\t    if (!skip) {\n\t\t/* Backup file if needed. Directories are handled earlier */\n\t\tif (suffix)\n\t\t    rc = fsmBackup(fi, action);\n\n\t\tif (!rc)\n\t\t    rc = fsmCommit(&fpath, fi, action, suffix);\n\t    }\n\t}\n\n\tif (rc)\n\t    *failedFile = xstrdup(fpath);\n\n\t/* Run fsm file post hook for all plugins */\n\trpmpluginsCallFsmFilePost(plugins, fi, fpath,\n\t\t\t\t  sb.st_mode, action, rc);\n\tfpath = _free(fpath);\n    }\n\n    rpmswAdd(rpmtsOp(ts, RPMTS_OP_UNCOMPRESS), fdOp(payload, FDSTAT_READ));\n    rpmswAdd(rpmtsOp(ts, RPMTS_OP_DIGEST), fdOp(payload, FDSTAT_DIGEST));\n\nexit:\n\n    /* No need to bother with close errors on read */\n    rpmfiArchiveClose(fi);\n    rpmfiFree(fi);\n    Fclose(payload);\n    free(tid);\n    free(fpath);\n\n    return rc;\n}",
        "func": "int rpmPackageFilesInstall(rpmts ts, rpmte te, rpmfiles files,\n              rpmpsm psm, char ** failedFile)\n{\n    FD_t payload = rpmtePayload(te);\n    rpmfi fi = rpmfiNewArchiveReader(payload, files, RPMFI_ITER_READ_ARCHIVE);\n    rpmfs fs = rpmteGetFileStates(te);\n    rpmPlugins plugins = rpmtsPlugins(ts);\n    struct stat sb;\n    int saveerrno = errno;\n    int rc = 0;\n    int nodigest = (rpmtsFlags(ts) & RPMTRANS_FLAG_NOFILEDIGEST) ? 1 : 0;\n    int nofcaps = (rpmtsFlags(ts) & RPMTRANS_FLAG_NOCAPS) ? 1 : 0;\n    int firsthardlink = -1;\n    int skip;\n    rpmFileAction action;\n    char *tid = NULL;\n    const char *suffix;\n    char *fpath = NULL;\n\n    if (fi == NULL) {\n\trc = RPMERR_BAD_MAGIC;\n\tgoto exit;\n    }\n\n    /* transaction id used for temporary path suffix while installing */\n    rasprintf(&tid, \";%08x\", (unsigned)rpmtsGetTid(ts));\n\n    /* Detect and create directories not explicitly in package. */\n    rc = fsmMkdirs(files, fs, plugins);\n\n    while (!rc) {\n\t/* Read next payload header. */\n\trc = rpmfiNext(fi);\n\n\tif (rc < 0) {\n\t    if (rc == RPMERR_ITER_END)\n\t\trc = 0;\n\t    break;\n\t}\n\n\taction = rpmfsGetAction(fs, rpmfiFX(fi));\n\tskip = XFA_SKIPPING(action);\n\tsuffix = S_ISDIR(rpmfiFMode(fi)) ? NULL : tid;\n\tif (action != FA_TOUCH) {\n\t    fpath = fsmFsPath(fi, suffix);\n\t} else {\n\t    fpath = fsmFsPath(fi, \"\");\n\t}\n\n\t/* Remap file perms, owner, and group. */\n\trc = rpmfiStat(fi, 1, &sb);\n\n\tfsmDebug(fpath, action, &sb);\n\n        /* Exit on error. */\n        if (rc)\n            break;\n\n\t/* Run fsm file pre hook for all plugins */\n\trc = rpmpluginsCallFsmFilePre(plugins, fi, fpath,\n\t\t\t\t      sb.st_mode, action);\n\tif (rc) {\n\t    skip = 1;\n\t} else {\n\t    setFileState(fs, rpmfiFX(fi));\n\t}\n\n        if (!skip) {\n\t    int setmeta = 1;\n\n\t    /* Directories replacing something need early backup */\n\t    if (!suffix) {\n\t\trc = fsmBackup(fi, action);\n\t    }\n\t    /* Assume file does't exist when tmp suffix is in use */\n\t    if (!suffix) {\n\t\trc = fsmVerify(fpath, fi);\n\t    } else {\n\t\trc = (action == FA_TOUCH) ? 0 : RPMERR_ENOENT;\n\t    }\n\n            if (S_ISREG(sb.st_mode)) {\n\t\tif (rc == RPMERR_ENOENT) {\n\t\t    rc = fsmMkfile(fi, fpath, files, psm, nodigest,\n\t\t\t\t   &setmeta, &firsthardlink);\n\t\t}\n            } else if (S_ISDIR(sb.st_mode)) {\n                if (rc == RPMERR_ENOENT) {\n                    mode_t mode = sb.st_mode;\n                    mode &= ~07777;\n                    mode |=  00700;\n                    rc = fsmMkdir(fpath, mode);\n                }\n            } else if (S_ISLNK(sb.st_mode)) {\n\t\tif (rc == RPMERR_ENOENT) {\n\t\t    rc = fsmSymlink(rpmfiFLink(fi), fpath);\n\t\t}\n            } else if (S_ISFIFO(sb.st_mode)) {\n                /* This mimics cpio S_ISSOCK() behavior but probably isn't right */\n                if (rc == RPMERR_ENOENT) {\n                    rc = fsmMkfifo(fpath, 0000);\n                }\n            } else if (S_ISCHR(sb.st_mode) ||\n                       S_ISBLK(sb.st_mode) ||\n                       S_ISSOCK(sb.st_mode))\n            {\n                if (rc == RPMERR_ENOENT) {\n                    rc = fsmMknod(fpath, sb.st_mode, sb.st_rdev);\n                }\n            } else {\n                /* XXX Special case /dev/log, which shouldn't be packaged anyways */\n                if (!IS_DEV_LOG(fpath))\n                    rc = RPMERR_UNKNOWN_FILETYPE;\n            }\n\t    /* Set permissions, timestamps etc for non-hardlink entries */\n\t    if (!rc && setmeta) {\n\t\trc = fsmSetmeta(fpath, fi, plugins, action, &sb, nofcaps);\n\t    }\n        } else if (firsthardlink >= 0 && rpmfiArchiveHasContent(fi)) {\n\t    /* we skip the hard linked file containing the content */\n\t    /* write the content to the first used instead */\n\t    char *fn = rpmfilesFN(files, firsthardlink);\n\t    rc = expandRegular(fi, fn, psm, 0, nodigest, 0);\n\t    firsthardlink = -1;\n\t    free(fn);\n\t}\n\n        if (rc) {\n            if (!skip) {\n                /* XXX only erase if temp fn w suffix is in use */\n                if (suffix && (action != FA_TOUCH)) {\n\t\t    (void) fsmRemove(fpath, sb.st_mode);\n                }\n                errno = saveerrno;\n            }\n        } else {\n\t    /* Notify on success. */\n\t    rpmpsmNotify(psm, RPMCALLBACK_INST_PROGRESS, rpmfiArchiveTell(fi));\n\n\t    if (!skip) {\n\t\t/* Backup file if needed. Directories are handled earlier */\n\t\tif (suffix)\n\t\t    rc = fsmBackup(fi, action);\n\n\t\tif (!rc)\n\t\t    rc = fsmCommit(&fpath, fi, action, suffix);\n\t    }\n\t}\n\n\tif (rc)\n\t    *failedFile = xstrdup(fpath);\n\n\t/* Run fsm file post hook for all plugins */\n\trpmpluginsCallFsmFilePost(plugins, fi, fpath,\n\t\t\t\t  sb.st_mode, action, rc);\n\tfpath = _free(fpath);\n    }\n\n    rpmswAdd(rpmtsOp(ts, RPMTS_OP_UNCOMPRESS), fdOp(payload, FDSTAT_READ));\n    rpmswAdd(rpmtsOp(ts, RPMTS_OP_DIGEST), fdOp(payload, FDSTAT_DIGEST));\n\nexit:\n\n    /* No need to bother with close errors on read */\n    rpmfiArchiveClose(fi);\n    rpmfiFree(fi);\n    Fclose(payload);\n    free(tid);\n    free(fpath);\n\n    return rc;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -120,7 +120,7 @@\n \t    /* we skip the hard linked file containing the content */\n \t    /* write the content to the first used instead */\n \t    char *fn = rpmfilesFN(files, firsthardlink);\n-\t    rc = expandRegular(fi, fn, psm, nodigest, 0);\n+\t    rc = expandRegular(fi, fn, psm, 0, nodigest, 0);\n \t    firsthardlink = -1;\n \t    free(fn);\n \t}",
        "diff_line_info": {
            "deleted_lines": [
                "\t    rc = expandRegular(fi, fn, psm, nodigest, 0);"
            ],
            "added_lines": [
                "\t    rc = expandRegular(fi, fn, psm, 0, nodigest, 0);"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-7501",
        "func_name": "rpm-software-management/rpm/expandRegular",
        "description": "It was found that versions of rpm before 4.13.0.2 use temporary files with predictable names when installing an RPM. An attacker with ability to write in a directory where files will be installed could create symbolic links to an arbitrary location and modify content, and possibly permissions to arbitrary files, which could be used for denial of service or possibly privilege escalation.",
        "git_url": "https://github.com/rpm-software-management/rpm/commit/404ef011c300207cdb1e531670384564aae04bdc",
        "commit_title": "Don't follow symlinks on file creation (CVE-2017-7501)",
        "commit_text": " Open newly created files with O_EXCL to prevent symlink tricks. When reopening hardlinks for writing the actual content, use append mode instead. This is compatible with the write-only permissions but is not destructive in case we got redirected to somebody elses file, verify the target before actually writing anything.  As these are files with the temporary suffix, errors mean a local user with sufficient privileges to break the installation of the package anyway is trying to goof us on purpose, don't bother trying to mend it (we couldn't fix the hardlink case anyhow) but just bail out.  Based on a patch by Florian Festi.",
        "func_before": "static int expandRegular(rpmfi fi, const char *dest, rpmpsm psm, int nodigest, int nocontent)\n{\n    FD_t wfd = NULL;\n    int rc = 0;\n\n    /* Create the file with 0200 permissions (write by owner). */\n    {\n\tmode_t old_umask = umask(0577);\n\twfd = Fopen(dest, \"w.ufdio\");\n\tumask(old_umask);\n    }\n    if (Ferror(wfd)) {\n\trc = RPMERR_OPEN_FAILED;\n\tgoto exit;\n    }\n\n    if (!nocontent)\n\trc = rpmfiArchiveReadToFilePsm(fi, wfd, nodigest, psm);\nexit:\n    if (wfd) {\n\tint myerrno = errno;\n\tFclose(wfd);\n\terrno = myerrno;\n    }\n    return rc;\n}",
        "func": "static int expandRegular(rpmfi fi, const char *dest, rpmpsm psm, int exclusive, int nodigest, int nocontent)\n{\n    FD_t wfd = NULL;\n    int rc = 0;\n\n    /* Create the file with 0200 permissions (write by owner). */\n    {\n\tmode_t old_umask = umask(0577);\n\twfd = Fopen(dest, exclusive ? \"wx.ufdio\" : \"a.ufdio\");\n\tumask(old_umask);\n\n\t/* If reopening, make sure the file is what we expect */\n\tif (!exclusive && wfd != NULL && !linkSane(wfd, dest)) {\n\t    rc = RPMERR_OPEN_FAILED;\n\t    goto exit;\n\t}\n    }\n    if (Ferror(wfd)) {\n\trc = RPMERR_OPEN_FAILED;\n\tgoto exit;\n    }\n\n    if (!nocontent)\n\trc = rpmfiArchiveReadToFilePsm(fi, wfd, nodigest, psm);\nexit:\n    if (wfd) {\n\tint myerrno = errno;\n\tFclose(wfd);\n\terrno = myerrno;\n    }\n    return rc;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,4 @@\n-static int expandRegular(rpmfi fi, const char *dest, rpmpsm psm, int nodigest, int nocontent)\n+static int expandRegular(rpmfi fi, const char *dest, rpmpsm psm, int exclusive, int nodigest, int nocontent)\n {\n     FD_t wfd = NULL;\n     int rc = 0;\n@@ -6,8 +6,14 @@\n     /* Create the file with 0200 permissions (write by owner). */\n     {\n \tmode_t old_umask = umask(0577);\n-\twfd = Fopen(dest, \"w.ufdio\");\n+\twfd = Fopen(dest, exclusive ? \"wx.ufdio\" : \"a.ufdio\");\n \tumask(old_umask);\n+\n+\t/* If reopening, make sure the file is what we expect */\n+\tif (!exclusive && wfd != NULL && !linkSane(wfd, dest)) {\n+\t    rc = RPMERR_OPEN_FAILED;\n+\t    goto exit;\n+\t}\n     }\n     if (Ferror(wfd)) {\n \trc = RPMERR_OPEN_FAILED;",
        "diff_line_info": {
            "deleted_lines": [
                "static int expandRegular(rpmfi fi, const char *dest, rpmpsm psm, int nodigest, int nocontent)",
                "\twfd = Fopen(dest, \"w.ufdio\");"
            ],
            "added_lines": [
                "static int expandRegular(rpmfi fi, const char *dest, rpmpsm psm, int exclusive, int nodigest, int nocontent)",
                "\twfd = Fopen(dest, exclusive ? \"wx.ufdio\" : \"a.ufdio\");",
                "",
                "\t/* If reopening, make sure the file is what we expect */",
                "\tif (!exclusive && wfd != NULL && !linkSane(wfd, dest)) {",
                "\t    rc = RPMERR_OPEN_FAILED;",
                "\t    goto exit;",
                "\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-7501",
        "func_name": "rpm-software-management/rpm/fsmMkfile",
        "description": "It was found that versions of rpm before 4.13.0.2 use temporary files with predictable names when installing an RPM. An attacker with ability to write in a directory where files will be installed could create symbolic links to an arbitrary location and modify content, and possibly permissions to arbitrary files, which could be used for denial of service or possibly privilege escalation.",
        "git_url": "https://github.com/rpm-software-management/rpm/commit/404ef011c300207cdb1e531670384564aae04bdc",
        "commit_title": "Don't follow symlinks on file creation (CVE-2017-7501)",
        "commit_text": " Open newly created files with O_EXCL to prevent symlink tricks. When reopening hardlinks for writing the actual content, use append mode instead. This is compatible with the write-only permissions but is not destructive in case we got redirected to somebody elses file, verify the target before actually writing anything.  As these are files with the temporary suffix, errors mean a local user with sufficient privileges to break the installation of the package anyway is trying to goof us on purpose, don't bother trying to mend it (we couldn't fix the hardlink case anyhow) but just bail out.  Based on a patch by Florian Festi.",
        "func_before": "static int fsmMkfile(rpmfi fi, const char *dest, rpmfiles files,\n\t\t     rpmpsm psm, int nodigest, int *setmeta,\n\t\t     int * firsthardlink)\n{\n    int rc = 0;\n    int numHardlinks = rpmfiFNlink(fi);\n\n    if (numHardlinks > 1) {\n\t/* Create first hardlinked file empty */\n\tif (*firsthardlink < 0) {\n\t    *firsthardlink = rpmfiFX(fi);\n\t    rc = expandRegular(fi, dest, psm, nodigest, 1);\n\t} else {\n\t    /* Create hard links for others */\n\t    char *fn = rpmfilesFN(files, *firsthardlink);\n\t    rc = link(fn, dest);\n\t    if (rc < 0) {\n\t\trc = RPMERR_LINK_FAILED;\n\t    }\n\t    free(fn);\n\t}\n    }\n    /* Write normal files or fill the last hardlinked (already\n       existing) file with content */\n    if (numHardlinks<=1) {\n\tif (!rc)\n\t    rc = expandRegular(fi, dest, psm, nodigest, 0);\n    } else if (rpmfiArchiveHasContent(fi)) {\n\tif (!rc)\n\t    rc = expandRegular(fi, dest, psm, nodigest, 0);\n\t*firsthardlink = -1;\n    } else {\n\t*setmeta = 0;\n    }\n\n    return rc;\n}",
        "func": "static int fsmMkfile(rpmfi fi, const char *dest, rpmfiles files,\n\t\t     rpmpsm psm, int nodigest, int *setmeta,\n\t\t     int * firsthardlink)\n{\n    int rc = 0;\n    int numHardlinks = rpmfiFNlink(fi);\n\n    if (numHardlinks > 1) {\n\t/* Create first hardlinked file empty */\n\tif (*firsthardlink < 0) {\n\t    *firsthardlink = rpmfiFX(fi);\n\t    rc = expandRegular(fi, dest, psm, 1, nodigest, 1);\n\t} else {\n\t    /* Create hard links for others */\n\t    char *fn = rpmfilesFN(files, *firsthardlink);\n\t    rc = link(fn, dest);\n\t    if (rc < 0) {\n\t\trc = RPMERR_LINK_FAILED;\n\t    }\n\t    free(fn);\n\t}\n    }\n    /* Write normal files or fill the last hardlinked (already\n       existing) file with content */\n    if (numHardlinks<=1) {\n\tif (!rc)\n\t    rc = expandRegular(fi, dest, psm, 1, nodigest, 0);\n    } else if (rpmfiArchiveHasContent(fi)) {\n\tif (!rc)\n\t    rc = expandRegular(fi, dest, psm, 0, nodigest, 0);\n\t*firsthardlink = -1;\n    } else {\n\t*setmeta = 0;\n    }\n\n    return rc;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -9,7 +9,7 @@\n \t/* Create first hardlinked file empty */\n \tif (*firsthardlink < 0) {\n \t    *firsthardlink = rpmfiFX(fi);\n-\t    rc = expandRegular(fi, dest, psm, nodigest, 1);\n+\t    rc = expandRegular(fi, dest, psm, 1, nodigest, 1);\n \t} else {\n \t    /* Create hard links for others */\n \t    char *fn = rpmfilesFN(files, *firsthardlink);\n@@ -24,10 +24,10 @@\n        existing) file with content */\n     if (numHardlinks<=1) {\n \tif (!rc)\n-\t    rc = expandRegular(fi, dest, psm, nodigest, 0);\n+\t    rc = expandRegular(fi, dest, psm, 1, nodigest, 0);\n     } else if (rpmfiArchiveHasContent(fi)) {\n \tif (!rc)\n-\t    rc = expandRegular(fi, dest, psm, nodigest, 0);\n+\t    rc = expandRegular(fi, dest, psm, 0, nodigest, 0);\n \t*firsthardlink = -1;\n     } else {\n \t*setmeta = 0;",
        "diff_line_info": {
            "deleted_lines": [
                "\t    rc = expandRegular(fi, dest, psm, nodigest, 1);",
                "\t    rc = expandRegular(fi, dest, psm, nodigest, 0);",
                "\t    rc = expandRegular(fi, dest, psm, nodigest, 0);"
            ],
            "added_lines": [
                "\t    rc = expandRegular(fi, dest, psm, 1, nodigest, 1);",
                "\t    rc = expandRegular(fi, dest, psm, 1, nodigest, 0);",
                "\t    rc = expandRegular(fi, dest, psm, 0, nodigest, 0);"
            ]
        }
    },
    {
        "cve_id": "CVE-2014-4978",
        "func_name": "rawstudio/rs_filter_graph",
        "description": "The rs_filter_graph function in librawstudio/rs-filter.c in rawstudio might allow local users to truncate arbitrary files via a symlink attack on (1) /tmp/rs-filter-graph.png or (2) /tmp/rs-filter-graph.",
        "git_url": "https://github.com/rawstudio/rawstudio/commit/9c2cd3c93c05d009a91d84eedbb85873b0cb505d",
        "commit_title": "Fixes insecure use of temporary file (CVE-2014-4978).",
        "commit_text": "",
        "func_before": "void\nrs_filter_graph(RSFilter *filter)\n{\n\tg_return_if_fail(RS_IS_FILTER(filter));\n\tGString *str = g_string_new(\"digraph G {\\n\");\n\n\trs_filter_graph_helper(str, filter);\n\n\tg_string_append_printf(str, \"}\\n\");\n\tg_file_set_contents(\"/tmp/rs-filter-graph\", str->str, str->len, NULL);\n\n\tif (0 != system(\"dot -Tpng >/tmp/rs-filter-graph.png </tmp/rs-filter-graph\"))\n\t\tg_warning(\"Calling dot failed\");\n\tif (0 != system(\"gnome-open /tmp/rs-filter-graph.png\"))\n\t\tg_warning(\"Calling gnome-open failed.\");\n\n\tg_string_free(str, TRUE);\n}",
        "func": "void\nrs_filter_graph(RSFilter *filter)\n{\n\tg_return_if_fail(RS_IS_FILTER(filter));\n\tgchar *dot_filename;\n\tgchar *png_filename;\n\tgchar *command_line;\n\tGString *str = g_string_new(\"digraph G {\\n\");\n\n\trs_filter_graph_helper(str, filter);\n\n\tg_string_append_printf(str, \"}\\n\");\n\n\t/* Here we would like to use g_mkdtemp(), but due to a bug in upstream, that's impossible */\n\tdot_filename = g_strdup_printf(\"/tmp/rs-filter-graph.%u\", g_random_int());\n\tpng_filename = g_strdup_printf(\"%s.%u.png\", dot_filename, g_random_int());\n\n\tg_file_set_contents(dot_filename, str->str, str->len, NULL);\n\n\tcommand_line = g_strdup_printf(\"dot -Tpng >%s <%s\", png_filename, dot_filename);\n\tif (0 != system(command_line))\n\t\tg_warning(\"Calling dot failed\");\n\tg_free(command_line);\n\n\tcommand_line = g_strdup_printf(\"gnome-open %s\", png_filename);\n\tif (0 != system(command_line))\n\t\tg_warning(\"Calling gnome-open failed.\");\n\tg_free(command_line);\n\n\tg_free(dot_filename);\n\tg_free(png_filename);\n\tg_string_free(str, TRUE);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,17 +2,32 @@\n rs_filter_graph(RSFilter *filter)\n {\n \tg_return_if_fail(RS_IS_FILTER(filter));\n+\tgchar *dot_filename;\n+\tgchar *png_filename;\n+\tgchar *command_line;\n \tGString *str = g_string_new(\"digraph G {\\n\");\n \n \trs_filter_graph_helper(str, filter);\n \n \tg_string_append_printf(str, \"}\\n\");\n-\tg_file_set_contents(\"/tmp/rs-filter-graph\", str->str, str->len, NULL);\n \n-\tif (0 != system(\"dot -Tpng >/tmp/rs-filter-graph.png </tmp/rs-filter-graph\"))\n+\t/* Here we would like to use g_mkdtemp(), but due to a bug in upstream, that's impossible */\n+\tdot_filename = g_strdup_printf(\"/tmp/rs-filter-graph.%u\", g_random_int());\n+\tpng_filename = g_strdup_printf(\"%s.%u.png\", dot_filename, g_random_int());\n+\n+\tg_file_set_contents(dot_filename, str->str, str->len, NULL);\n+\n+\tcommand_line = g_strdup_printf(\"dot -Tpng >%s <%s\", png_filename, dot_filename);\n+\tif (0 != system(command_line))\n \t\tg_warning(\"Calling dot failed\");\n-\tif (0 != system(\"gnome-open /tmp/rs-filter-graph.png\"))\n+\tg_free(command_line);\n+\n+\tcommand_line = g_strdup_printf(\"gnome-open %s\", png_filename);\n+\tif (0 != system(command_line))\n \t\tg_warning(\"Calling gnome-open failed.\");\n+\tg_free(command_line);\n \n+\tg_free(dot_filename);\n+\tg_free(png_filename);\n \tg_string_free(str, TRUE);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tg_file_set_contents(\"/tmp/rs-filter-graph\", str->str, str->len, NULL);",
                "\tif (0 != system(\"dot -Tpng >/tmp/rs-filter-graph.png </tmp/rs-filter-graph\"))",
                "\tif (0 != system(\"gnome-open /tmp/rs-filter-graph.png\"))"
            ],
            "added_lines": [
                "\tgchar *dot_filename;",
                "\tgchar *png_filename;",
                "\tgchar *command_line;",
                "\t/* Here we would like to use g_mkdtemp(), but due to a bug in upstream, that's impossible */",
                "\tdot_filename = g_strdup_printf(\"/tmp/rs-filter-graph.%u\", g_random_int());",
                "\tpng_filename = g_strdup_printf(\"%s.%u.png\", dot_filename, g_random_int());",
                "",
                "\tg_file_set_contents(dot_filename, str->str, str->len, NULL);",
                "",
                "\tcommand_line = g_strdup_printf(\"dot -Tpng >%s <%s\", png_filename, dot_filename);",
                "\tif (0 != system(command_line))",
                "\tg_free(command_line);",
                "",
                "\tcommand_line = g_strdup_printf(\"gnome-open %s\", png_filename);",
                "\tif (0 != system(command_line))",
                "\tg_free(command_line);",
                "\tg_free(dot_filename);",
                "\tg_free(png_filename);"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-6198",
        "func_name": "tats/w3m/w3m_exit",
        "description": "w3m through 0.5.3 does not properly handle temporary files when the ~/.w3m directory is unwritable, which allows a local attacker to craft a symlink attack to overwrite arbitrary files.",
        "git_url": "https://github.com/tats/w3m/commit/18dcbadf2771cdb0c18509b14e4e73505b242753",
        "commit_title": "Make temporary directory safely when ~/.w3m is unwritable",
        "commit_text": "",
        "func_before": "void\nw3m_exit(int i)\n{\n#ifdef USE_MIGEMO\n    init_migemo();\t\t/* close pipe to migemo */\n#endif\n    stopDownload();\n    deleteFiles();\n#ifdef USE_SSL\n    free_ssl_ctx();\n#endif\n    disconnectFTP();\n#ifdef USE_NNTP\n    disconnectNews();\n#endif\n#ifdef __MINGW32_VERSION\n    WSACleanup();\n#endif\n    exit(i);\n}",
        "func": "void\nw3m_exit(int i)\n{\n#ifdef USE_MIGEMO\n    init_migemo();\t\t/* close pipe to migemo */\n#endif\n    stopDownload();\n    deleteFiles();\n#ifdef USE_SSL\n    free_ssl_ctx();\n#endif\n    disconnectFTP();\n#ifdef USE_NNTP\n    disconnectNews();\n#endif\n#ifdef __MINGW32_VERSION\n    WSACleanup();\n#endif\n#ifdef HAVE_MKDTEMP\n    if (no_rc_dir && tmp_dir != rc_dir)\n\tif (rmdir(tmp_dir) != 0) {\n\t    fprintf(stderr, \"Can't remove temporary directory (%s)!\\n\", tmp_dir);\n\t    exit(1);\n\t}\n#endif\n    exit(i);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -16,5 +16,12 @@\n #ifdef __MINGW32_VERSION\n     WSACleanup();\n #endif\n+#ifdef HAVE_MKDTEMP\n+    if (no_rc_dir && tmp_dir != rc_dir)\n+\tif (rmdir(tmp_dir) != 0) {\n+\t    fprintf(stderr, \"Can't remove temporary directory (%s)!\\n\", tmp_dir);\n+\t    exit(1);\n+\t}\n+#endif\n     exit(i);\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "#ifdef HAVE_MKDTEMP",
                "    if (no_rc_dir && tmp_dir != rc_dir)",
                "\tif (rmdir(tmp_dir) != 0) {",
                "\t    fprintf(stderr, \"Can't remove temporary directory (%s)!\\n\", tmp_dir);",
                "\t    exit(1);",
                "\t}",
                "#endif"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-6198",
        "func_name": "tats/w3m/init_rc",
        "description": "w3m through 0.5.3 does not properly handle temporary files when the ~/.w3m directory is unwritable, which allows a local attacker to craft a symlink attack to overwrite arbitrary files.",
        "git_url": "https://github.com/tats/w3m/commit/18dcbadf2771cdb0c18509b14e4e73505b242753",
        "commit_title": "Make temporary directory safely when ~/.w3m is unwritable",
        "commit_text": "",
        "func_before": "void\ninit_rc(void)\n{\n    int i;\n    struct stat st;\n    FILE *f;\n\n    if (rc_dir != NULL)\n\tgoto open_rc;\n\n    rc_dir = expandPath(RC_DIR);\n    i = strlen(rc_dir);\n    if (i > 1 && rc_dir[i - 1] == '/')\n\trc_dir[i - 1] = '\\0';\n\n#ifdef USE_M17N\n    display_charset_str = wc_get_ces_list();\n    document_charset_str = display_charset_str;\n    system_charset_str = display_charset_str;\n#endif\n\n    if (stat(rc_dir, &st) < 0) {\n\tif (errno == ENOENT) {\t/* no directory */\n\t    if (do_mkdir(rc_dir, 0700) < 0) {\n\t\t/* fprintf(stderr, \"Can't create config directory (%s)!\\n\", rc_dir); */\n\t\tgoto rc_dir_err;\n\t    }\n\t    else {\n\t\tstat(rc_dir, &st);\n\t    }\n\t}\n\telse {\n\t    /* fprintf(stderr, \"Can't open config directory (%s)!\\n\", rc_dir); */\n\t    goto rc_dir_err;\n\t}\n    }\n    if (!S_ISDIR(st.st_mode)) {\n\t/* not a directory */\n\t/* fprintf(stderr, \"%s is not a directory!\\n\", rc_dir); */\n\tgoto rc_dir_err;\n    }\n    if (!(st.st_mode & S_IWUSR)) {\n\t/* fprintf(stderr, \"%s is not writable!\\n\", rc_dir); */\n\tgoto rc_dir_err;\n    }\n    no_rc_dir = FALSE;\n    tmp_dir = rc_dir;\n\n    if (config_file == NULL)\n\tconfig_file = rcFile(CONFIG_FILE);\n\n    create_option_search_table();\n\n  open_rc:\n    /* open config file */\n    if ((f = fopen(etcFile(W3MCONFIG), \"rt\")) != NULL) {\n\tinterpret_rc(f);\n\tfclose(f);\n    }\n    if ((f = fopen(confFile(CONFIG_FILE), \"rt\")) != NULL) {\n\tinterpret_rc(f);\n\tfclose(f);\n    }\n    if (config_file && (f = fopen(config_file, \"rt\")) != NULL) {\n\tinterpret_rc(f);\n\tfclose(f);\n    }\n    return;\n\n  rc_dir_err:\n    no_rc_dir = TRUE;\n    if (((tmp_dir = getenv(\"TMPDIR\")) == NULL || *tmp_dir == '\\0') &&\n\t((tmp_dir = getenv(\"TMP\")) == NULL || *tmp_dir == '\\0') &&\n\t((tmp_dir = getenv(\"TEMP\")) == NULL || *tmp_dir == '\\0'))\n\ttmp_dir = \"/tmp\";\n    create_option_search_table();\n    goto open_rc;\n}",
        "func": "void\ninit_rc(void)\n{\n    int i;\n    struct stat st;\n    FILE *f;\n\n    if (rc_dir != NULL)\n\tgoto open_rc;\n\n    rc_dir = expandPath(RC_DIR);\n    i = strlen(rc_dir);\n    if (i > 1 && rc_dir[i - 1] == '/')\n\trc_dir[i - 1] = '\\0';\n\n#ifdef USE_M17N\n    display_charset_str = wc_get_ces_list();\n    document_charset_str = display_charset_str;\n    system_charset_str = display_charset_str;\n#endif\n\n    if (stat(rc_dir, &st) < 0) {\n\tif (errno == ENOENT) {\t/* no directory */\n\t    if (do_mkdir(rc_dir, 0700) < 0) {\n\t\t/* fprintf(stderr, \"Can't create config directory (%s)!\\n\", rc_dir); */\n\t\tgoto rc_dir_err;\n\t    }\n\t    else {\n\t\tstat(rc_dir, &st);\n\t    }\n\t}\n\telse {\n\t    /* fprintf(stderr, \"Can't open config directory (%s)!\\n\", rc_dir); */\n\t    goto rc_dir_err;\n\t}\n    }\n    if (!S_ISDIR(st.st_mode)) {\n\t/* not a directory */\n\t/* fprintf(stderr, \"%s is not a directory!\\n\", rc_dir); */\n\tgoto rc_dir_err;\n    }\n    if (!(st.st_mode & S_IWUSR)) {\n\t/* fprintf(stderr, \"%s is not writable!\\n\", rc_dir); */\n\tgoto rc_dir_err;\n    }\n    no_rc_dir = FALSE;\n    tmp_dir = rc_dir;\n\n    if (config_file == NULL)\n\tconfig_file = rcFile(CONFIG_FILE);\n\n    create_option_search_table();\n\n  open_rc:\n    /* open config file */\n    if ((f = fopen(etcFile(W3MCONFIG), \"rt\")) != NULL) {\n\tinterpret_rc(f);\n\tfclose(f);\n    }\n    if ((f = fopen(confFile(CONFIG_FILE), \"rt\")) != NULL) {\n\tinterpret_rc(f);\n\tfclose(f);\n    }\n    if (config_file && (f = fopen(config_file, \"rt\")) != NULL) {\n\tinterpret_rc(f);\n\tfclose(f);\n    }\n    return;\n\n  rc_dir_err:\n    no_rc_dir = TRUE;\n    if (((tmp_dir = getenv(\"TMPDIR\")) == NULL || *tmp_dir == '\\0') &&\n\t((tmp_dir = getenv(\"TMP\")) == NULL || *tmp_dir == '\\0') &&\n\t((tmp_dir = getenv(\"TEMP\")) == NULL || *tmp_dir == '\\0'))\n\ttmp_dir = \"/tmp\";\n#ifdef HAVE_MKDTEMP\n    tmp_dir = mkdtemp(Strnew_m_charp(tmp_dir, \"/w3m-XXXXXX\", NULL)->ptr);\n    if (tmp_dir == NULL)\n\ttmp_dir = rc_dir;\n#endif\n    create_option_search_table();\n    goto open_rc;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -73,6 +73,11 @@\n \t((tmp_dir = getenv(\"TMP\")) == NULL || *tmp_dir == '\\0') &&\n \t((tmp_dir = getenv(\"TEMP\")) == NULL || *tmp_dir == '\\0'))\n \ttmp_dir = \"/tmp\";\n+#ifdef HAVE_MKDTEMP\n+    tmp_dir = mkdtemp(Strnew_m_charp(tmp_dir, \"/w3m-XXXXXX\", NULL)->ptr);\n+    if (tmp_dir == NULL)\n+\ttmp_dir = rc_dir;\n+#endif\n     create_option_search_table();\n     goto open_rc;\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "#ifdef HAVE_MKDTEMP",
                "    tmp_dir = mkdtemp(Strnew_m_charp(tmp_dir, \"/w3m-XXXXXX\", NULL)->ptr);",
                "    if (tmp_dir == NULL)",
                "\ttmp_dir = rc_dir;",
                "#endif"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-18078",
        "func_name": "systemd/path_set_acls",
        "description": "systemd-tmpfiles in systemd before 237 attempts to support ownership/permission changes on hardlinked files even if the fs.protected_hardlinks sysctl is turned off, which allows local users to bypass intended access restrictions via vectors involving a hard link to a file for which the user lacks write access, as demonstrated by changing the ownership of the /etc/passwd file.",
        "git_url": "https://github.com/systemd/systemd/commit/5579f85663d10269e7ac7464be6548c99cea4ada",
        "commit_title": "tmpfiles: refuse to chown()/chmod() files which are hardlinked, unless protected_hardlinks sysctl is on",
        "commit_text": " Let's add some extra safety. ",
        "func_before": "static int path_set_acls(Item *item, const char *path) {\n        int r = 0;\n#if HAVE_ACL\n        char fn[STRLEN(\"/proc/self/fd/\") + DECIMAL_STR_MAX(int)];\n        _cleanup_close_ int fd = -1;\n        struct stat st;\n\n        assert(item);\n        assert(path);\n\n        fd = open(path, O_NOFOLLOW|O_CLOEXEC|O_PATH);\n        if (fd < 0)\n                return log_error_errno(errno, \"Adjusting ACL of %s failed: %m\", path);\n\n        if (fstatat(fd, \"\", &st, AT_EMPTY_PATH) < 0)\n                return log_error_errno(errno, \"Failed to fstat() file %s: %m\", path);\n\n        if (S_ISLNK(st.st_mode)) {\n                log_debug(\"Skipping ACL fix for symlink %s.\", path);\n                return 0;\n        }\n\n        xsprintf(fn, \"/proc/self/fd/%i\", fd);\n\n        if (item->acl_access)\n                r = path_set_acl(fn, path, ACL_TYPE_ACCESS, item->acl_access, item->force);\n\n        if (r == 0 && item->acl_default)\n                r = path_set_acl(fn, path, ACL_TYPE_DEFAULT, item->acl_default, item->force);\n\n        if (r > 0)\n                return -r; /* already warned */\n        else if (r == -EOPNOTSUPP) {\n                log_debug_errno(r, \"ACLs not supported by file system at %s\", path);\n                return 0;\n        } else if (r < 0)\n                log_error_errno(r, \"ACL operation on \\\"%s\\\" failed: %m\", path);\n#endif\n        return r;\n}",
        "func": "static int path_set_acls(Item *item, const char *path) {\n        int r = 0;\n#if HAVE_ACL\n        char fn[STRLEN(\"/proc/self/fd/\") + DECIMAL_STR_MAX(int)];\n        _cleanup_close_ int fd = -1;\n        struct stat st;\n\n        assert(item);\n        assert(path);\n\n        fd = open(path, O_NOFOLLOW|O_CLOEXEC|O_PATH);\n        if (fd < 0)\n                return log_error_errno(errno, \"Adjusting ACL of %s failed: %m\", path);\n\n        if (fstatat(fd, \"\", &st, AT_EMPTY_PATH) < 0)\n                return log_error_errno(errno, \"Failed to fstat() file %s: %m\", path);\n\n        if (hardlink_vulnerable(&st)) {\n                log_error(\"Refusing to set ACLs on hardlinked file %s while the fs.protected_hardlinks sysctl is turned off.\", path);\n                return -EPERM;\n        }\n\n        if (S_ISLNK(st.st_mode)) {\n                log_debug(\"Skipping ACL fix for symlink %s.\", path);\n                return 0;\n        }\n\n        xsprintf(fn, \"/proc/self/fd/%i\", fd);\n\n        if (item->acl_access)\n                r = path_set_acl(fn, path, ACL_TYPE_ACCESS, item->acl_access, item->force);\n\n        if (r == 0 && item->acl_default)\n                r = path_set_acl(fn, path, ACL_TYPE_DEFAULT, item->acl_default, item->force);\n\n        if (r > 0)\n                return -r; /* already warned */\n        else if (r == -EOPNOTSUPP) {\n                log_debug_errno(r, \"ACLs not supported by file system at %s\", path);\n                return 0;\n        } else if (r < 0)\n                log_error_errno(r, \"ACL operation on \\\"%s\\\" failed: %m\", path);\n#endif\n        return r;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -14,6 +14,11 @@\n \n         if (fstatat(fd, \"\", &st, AT_EMPTY_PATH) < 0)\n                 return log_error_errno(errno, \"Failed to fstat() file %s: %m\", path);\n+\n+        if (hardlink_vulnerable(&st)) {\n+                log_error(\"Refusing to set ACLs on hardlinked file %s while the fs.protected_hardlinks sysctl is turned off.\", path);\n+                return -EPERM;\n+        }\n \n         if (S_ISLNK(st.st_mode)) {\n                 log_debug(\"Skipping ACL fix for symlink %s.\", path);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "        if (hardlink_vulnerable(&st)) {",
                "                log_error(\"Refusing to set ACLs on hardlinked file %s while the fs.protected_hardlinks sysctl is turned off.\", path);",
                "                return -EPERM;",
                "        }"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-18078",
        "func_name": "systemd/path_set_perms",
        "description": "systemd-tmpfiles in systemd before 237 attempts to support ownership/permission changes on hardlinked files even if the fs.protected_hardlinks sysctl is turned off, which allows local users to bypass intended access restrictions via vectors involving a hard link to a file for which the user lacks write access, as demonstrated by changing the ownership of the /etc/passwd file.",
        "git_url": "https://github.com/systemd/systemd/commit/5579f85663d10269e7ac7464be6548c99cea4ada",
        "commit_title": "tmpfiles: refuse to chown()/chmod() files which are hardlinked, unless protected_hardlinks sysctl is on",
        "commit_text": " Let's add some extra safety. ",
        "func_before": "static int path_set_perms(Item *i, const char *path) {\n        char fn[STRLEN(\"/proc/self/fd/\") + DECIMAL_STR_MAX(int)];\n        _cleanup_close_ int fd = -1;\n        struct stat st;\n\n        assert(i);\n        assert(path);\n\n        if (!i->mode_set && !i->uid_set && !i->gid_set)\n                goto shortcut;\n\n        /* We open the file with O_PATH here, to make the operation\n         * somewhat atomic. Also there's unfortunately no fchmodat()\n         * with AT_SYMLINK_NOFOLLOW, hence we emulate it here via\n         * O_PATH. */\n\n        fd = open(path, O_NOFOLLOW|O_CLOEXEC|O_PATH);\n        if (fd < 0) {\n                int level = LOG_ERR, r = -errno;\n\n                /* Option \"e\" operates only on existing objects. Do not\n                 * print errors about non-existent files or directories */\n                if (i->type == EMPTY_DIRECTORY && errno == ENOENT) {\n                        level = LOG_DEBUG;\n                        r = 0;\n                }\n\n                log_full_errno(level, errno, \"Adjusting owner and mode for %s failed: %m\", path);\n                return r;\n        }\n\n        if (fstatat(fd, \"\", &st, AT_EMPTY_PATH) < 0)\n                return log_error_errno(errno, \"Failed to fstat() file %s: %m\", path);\n\n        xsprintf(fn, \"/proc/self/fd/%i\", fd);\n\n        if (i->mode_set) {\n                if (S_ISLNK(st.st_mode))\n                        log_debug(\"Skipping mode fix for symlink %s.\", path);\n                else {\n                        mode_t m = i->mode;\n\n                        if (i->mask_perms) {\n                                if (!(st.st_mode & 0111))\n                                        m &= ~0111;\n                                if (!(st.st_mode & 0222))\n                                        m &= ~0222;\n                                if (!(st.st_mode & 0444))\n                                        m &= ~0444;\n                                if (!S_ISDIR(st.st_mode))\n                                        m &= ~07000; /* remove sticky/sgid/suid bit, unless directory */\n                        }\n\n                        if (m == (st.st_mode & 07777))\n                                log_debug(\"\\\"%s\\\" has correct mode %o already.\", path, st.st_mode);\n                        else {\n                                log_debug(\"Changing \\\"%s\\\" to mode %o.\", path, m);\n\n                                if (chmod(fn, m) < 0)\n                                        return log_error_errno(errno, \"chmod() of %s via %s failed: %m\", path, fn);\n                        }\n                }\n        }\n\n        if ((i->uid_set && i->uid != st.st_uid) ||\n            (i->gid_set && i->gid != st.st_gid)) {\n                log_debug(\"Changing \\\"%s\\\" to owner \"UID_FMT\":\"GID_FMT,\n                          path,\n                          i->uid_set ? i->uid : UID_INVALID,\n                          i->gid_set ? i->gid : GID_INVALID);\n\n                if (chown(fn,\n                          i->uid_set ? i->uid : UID_INVALID,\n                          i->gid_set ? i->gid : GID_INVALID) < 0)\n                        return log_error_errno(errno, \"chown() of %s via %s failed: %m\", path, fn);\n        }\n\n        fd = safe_close(fd);\n\nshortcut:\n        return label_fix(path, false, false);\n}",
        "func": "static int path_set_perms(Item *i, const char *path) {\n        char fn[STRLEN(\"/proc/self/fd/\") + DECIMAL_STR_MAX(int)];\n        _cleanup_close_ int fd = -1;\n        struct stat st;\n\n        assert(i);\n        assert(path);\n\n        if (!i->mode_set && !i->uid_set && !i->gid_set)\n                goto shortcut;\n\n        /* We open the file with O_PATH here, to make the operation\n         * somewhat atomic. Also there's unfortunately no fchmodat()\n         * with AT_SYMLINK_NOFOLLOW, hence we emulate it here via\n         * O_PATH. */\n\n        fd = open(path, O_NOFOLLOW|O_CLOEXEC|O_PATH);\n        if (fd < 0) {\n                int level = LOG_ERR, r = -errno;\n\n                /* Option \"e\" operates only on existing objects. Do not\n                 * print errors about non-existent files or directories */\n                if (i->type == EMPTY_DIRECTORY && errno == ENOENT) {\n                        level = LOG_DEBUG;\n                        r = 0;\n                }\n\n                log_full_errno(level, errno, \"Adjusting owner and mode for %s failed: %m\", path);\n                return r;\n        }\n\n        if (fstatat(fd, \"\", &st, AT_EMPTY_PATH) < 0)\n                return log_error_errno(errno, \"Failed to fstat() file %s: %m\", path);\n\n        if (hardlink_vulnerable(&st)) {\n                log_error(\"Refusing to set permissions on hardlinked file %s while the fs.protected_hardlinks sysctl is turned off.\", path);\n                return -EPERM;\n        }\n\n        xsprintf(fn, \"/proc/self/fd/%i\", fd);\n\n        if (i->mode_set) {\n                if (S_ISLNK(st.st_mode))\n                        log_debug(\"Skipping mode fix for symlink %s.\", path);\n                else {\n                        mode_t m = i->mode;\n\n                        if (i->mask_perms) {\n                                if (!(st.st_mode & 0111))\n                                        m &= ~0111;\n                                if (!(st.st_mode & 0222))\n                                        m &= ~0222;\n                                if (!(st.st_mode & 0444))\n                                        m &= ~0444;\n                                if (!S_ISDIR(st.st_mode))\n                                        m &= ~07000; /* remove sticky/sgid/suid bit, unless directory */\n                        }\n\n                        if (m == (st.st_mode & 07777))\n                                log_debug(\"\\\"%s\\\" has correct mode %o already.\", path, st.st_mode);\n                        else {\n                                log_debug(\"Changing \\\"%s\\\" to mode %o.\", path, m);\n\n                                if (chmod(fn, m) < 0)\n                                        return log_error_errno(errno, \"chmod() of %s via %s failed: %m\", path, fn);\n                        }\n                }\n        }\n\n        if ((i->uid_set && i->uid != st.st_uid) ||\n            (i->gid_set && i->gid != st.st_gid)) {\n                log_debug(\"Changing \\\"%s\\\" to owner \"UID_FMT\":\"GID_FMT,\n                          path,\n                          i->uid_set ? i->uid : UID_INVALID,\n                          i->gid_set ? i->gid : GID_INVALID);\n\n                if (chown(fn,\n                          i->uid_set ? i->uid : UID_INVALID,\n                          i->gid_set ? i->gid : GID_INVALID) < 0)\n                        return log_error_errno(errno, \"chown() of %s via %s failed: %m\", path, fn);\n        }\n\n        fd = safe_close(fd);\n\nshortcut:\n        return label_fix(path, false, false);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -31,6 +31,11 @@\n \n         if (fstatat(fd, \"\", &st, AT_EMPTY_PATH) < 0)\n                 return log_error_errno(errno, \"Failed to fstat() file %s: %m\", path);\n+\n+        if (hardlink_vulnerable(&st)) {\n+                log_error(\"Refusing to set permissions on hardlinked file %s while the fs.protected_hardlinks sysctl is turned off.\", path);\n+                return -EPERM;\n+        }\n \n         xsprintf(fn, \"/proc/self/fd/%i\", fd);\n ",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "        if (hardlink_vulnerable(&st)) {",
                "                log_error(\"Refusing to set permissions on hardlinked file %s while the fs.protected_hardlinks sysctl is turned off.\", path);",
                "                return -EPERM;",
                "        }"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-5273",
        "func_name": "abrt/main",
        "description": "The abrt-action-install-debuginfo-to-abrt-cache help program in Automatic Bug Reporting Tool (ABRT) before 2.7.1 allows local users to write to arbitrary files via a symlink attack on unpacked.cpio in a pre-created directory with a predictable name in /var/tmp.",
        "git_url": "https://github.com/abrt/abrt/commit/50ee8130fb4cd4ef1af7682a2c85dd99cb99424e",
        "commit_title": "a-a-i-d-to-abrt-cache: make own random temporary directory",
        "commit_text": " The set-user-ID wrapper must use own new temporary directory in order to avoid security issues with unpacking specially crafted debuginfo packages that might be used to create files or symlinks anywhere on the file system as the abrt user.  Withot the forking code the temporary directory would remain on the filesystem in the case where all debuginfo data are already available. This is caused by the fact that the underlying libreport functionality accepts path to a desired temporary directory and creates it only if necessary. Otherwise, the directory is not touched at all.  This commit addresses CVE-2015-5273 ",
        "func_before": "int main(int argc, char **argv)\n{\n    /* I18n */\n    setlocale(LC_ALL, \"\");\n#if ENABLE_NLS\n    bindtextdomain(PACKAGE, LOCALEDIR);\n    textdomain(PACKAGE);\n#endif\n\n    abrt_init(argv);\n\n    /* Can't keep these strings/structs static: _() doesn't support that */\n    const char *program_usage_string = _(\n        \"& [-y] [-i BUILD_IDS_FILE|-i -] [-e PATH[:PATH]...]\\n\"\n        \"\\t[-r REPO]\\n\"\n        \"\\n\"\n        \"Installs debuginfo packages for all build-ids listed in BUILD_IDS_FILE to\\n\"\n        \"ABRT system cache.\"\n    );\n\n    enum {\n        OPT_v = 1 << 0,\n        OPT_y = 1 << 1,\n        OPT_i = 1 << 2,\n        OPT_e = 1 << 3,\n        OPT_r = 1 << 4,\n        OPT_s = 1 << 5,\n    };\n\n    const char *build_ids = \"build_ids\";\n    const char *exact = NULL;\n    const char *repo = NULL;\n    const char *size_mb = NULL;\n\n    struct options program_options[] = {\n        OPT__VERBOSE(&g_verbose),\n        OPT_BOOL  ('y', \"yes\",         NULL,                   _(\"Noninteractive, assume 'Yes' to all questions\")),\n        OPT_STRING('i', \"ids\",   &build_ids, \"BUILD_IDS_FILE\", _(\"- means STDIN, default: build_ids\")),\n        OPT_STRING('e', \"exact\",     &exact, \"EXACT\",          _(\"Download only specified files\")),\n        OPT_STRING('r', \"repo\",       &repo, \"REPO\",           _(\"Pattern to use when searching for repos, default: *debug*\")),\n        OPT_STRING('s', \"size_mb\", &size_mb, \"SIZE_MB\",        _(\"Ignored option\")),\n        OPT_END()\n    };\n    const unsigned opts = parse_opts(argc, argv, program_options, program_usage_string);\n\n    const gid_t egid = getegid();\n    const gid_t rgid = getgid();\n    const uid_t euid = geteuid();\n    const gid_t ruid = getuid();\n\n    /* We need to open the build ids file under the caller's UID/GID to avoid\n     * information disclosures when reading files with changed UID.\n     * Unfortunately, we cannot replace STDIN with the new fd because ABRT uses\n     * STDIN to communicate with the caller. So, the following code opens a\n     * dummy file descriptor to the build ids file and passes the new fd's proc\n     * path to the wrapped program in the ids argument.\n     * The new fd remains opened, the OS will close it for us. */\n    char *build_ids_self_fd = NULL;\n    if (strcmp(\"-\", build_ids) != 0)\n    {\n        if (setregid(egid, rgid) < 0)\n            perror_msg_and_die(\"setregid(egid, rgid)\");\n\n        if (setreuid(euid, ruid) < 0)\n            perror_msg_and_die(\"setreuid(euid, ruid)\");\n\n        const int build_ids_fd = open(build_ids, O_RDONLY);\n\n        if (setregid(rgid, egid) < 0)\n            perror_msg_and_die(\"setregid(rgid, egid)\");\n\n        if (setreuid(ruid, euid) < 0 )\n            perror_msg_and_die(\"setreuid(ruid, euid)\");\n\n        if (build_ids_fd < 0)\n            perror_msg_and_die(\"Failed to open file '%s'\", build_ids);\n\n        /* We are not going to free this memory. There is no place to do so. */\n        build_ids_self_fd = xasprintf(\"/proc/self/fd/%d\", build_ids_fd);\n    }\n\n    /* name, -v, --ids, -, -y, -e, EXACT, -r, REPO, --, NULL */\n    const char *args[11];\n    {\n        const char *verbs[] = { \"\", \"-v\", \"-vv\", \"-vvv\" };\n        unsigned i = 0;\n        args[i++] = EXECUTABLE;\n        args[i++] = \"--ids\";\n        args[i++] = (build_ids_self_fd != NULL) ? build_ids_self_fd : \"-\";\n        if (g_verbose > 0)\n            args[i++] = verbs[g_verbose <= 3 ? g_verbose : 3];\n        if ((opts & OPT_y))\n            args[i++] = \"-y\";\n        if ((opts & OPT_e))\n        {\n            args[i++] = \"--exact\";\n            args[i++] = exact;\n        }\n        if ((opts & OPT_r))\n        {\n            args[i++] = \"--repo\";\n            args[i++] = repo;\n        }\n        args[i++] = \"--\";\n        args[i] = NULL;\n    }\n\n    /* Switch real user/group to effective ones.\n     * Otherwise yum library gets confused - gets EPERM (why??).\n     */\n    /* do setregid only if we have to, to not upset selinux needlessly */\n    if (egid != rgid)\n        IGNORE_RESULT(setregid(egid, egid));\n    if (euid != ruid)\n    {\n        IGNORE_RESULT(setreuid(euid, euid));\n        /* We are suid'ed! */\n        /* Prevent malicious user from messing up with suid'ed process: */\n#if 1\n// We forgot to sanitize PYTHONPATH. And who knows what else we forgot\n// (especially considering *future* new variables of this kind).\n// We switched to clearing entire environment instead:\n\n        // However since we communicate through environment variables\n        // we have to keep a whitelist of variables to keep.\n        static const char *whitelist[] = {\n            \"REPORT_CLIENT_SLAVE\", //  Check if the app is being run as a slave\n            \"LANG\",\n        };\n        const size_t wlsize = sizeof(whitelist)/sizeof(char*);\n        char *setlist[sizeof(whitelist)/sizeof(char*)] = { 0 };\n        char *p = NULL;\n        for (size_t i = 0; i < wlsize; i++)\n            if ((p = getenv(whitelist[i])) != NULL)\n                setlist[i] = xstrdup(p);\n\n        // Now we can clear the environment\n        clearenv();\n\n        // And once again set whitelisted variables\n        for (size_t i = 0; i < wlsize; i++)\n            if (setlist[i] != NULL)\n            {\n                xsetenv(whitelist[i], setlist[i]);\n                free(setlist[i]);\n            }\n#else\n        /* Clear dangerous stuff from env */\n        static const char forbid[] =\n            \"LD_LIBRARY_PATH\" \"\\0\"\n            \"LD_PRELOAD\" \"\\0\"\n            \"LD_TRACE_LOADED_OBJECTS\" \"\\0\"\n            \"LD_BIND_NOW\" \"\\0\"\n            \"LD_AOUT_LIBRARY_PATH\" \"\\0\"\n            \"LD_AOUT_PRELOAD\" \"\\0\"\n            \"LD_NOWARN\" \"\\0\"\n            \"LD_KEEPDIR\" \"\\0\"\n        ;\n        const char *p = forbid;\n        do {\n            unsetenv(p);\n            p += strlen(p) + 1;\n        } while (*p);\n#endif\n        /* Set safe PATH */\n        // Adding configure --bindir and --sbindir to the PATH so that\n        // abrt-action-install-debuginfo doesn't fail when spawning\n        // abrt-action-trim-files\n        char path_env[] = \"PATH=/usr/sbin:/sbin:/usr/bin:/bin:\"BIN_DIR\":\"SBIN_DIR;\n        if (euid != 0)\n            strcpy(path_env, \"PATH=/usr/bin:/bin:\"BIN_DIR);\n        putenv(path_env);\n\n        /* Use safe umask */\n        umask(0022);\n    }\n\n    execvp(EXECUTABLE, (char **)args);\n    error_msg_and_die(\"Can't execute %s\", EXECUTABLE);\n}",
        "func": "int main(int argc, char **argv)\n{\n    /* I18n */\n    setlocale(LC_ALL, \"\");\n#if ENABLE_NLS\n    bindtextdomain(PACKAGE, LOCALEDIR);\n    textdomain(PACKAGE);\n#endif\n\n    abrt_init(argv);\n\n    /* Can't keep these strings/structs static: _() doesn't support that */\n    const char *program_usage_string = _(\n        \"& [-y] [-i BUILD_IDS_FILE|-i -] [-e PATH[:PATH]...]\\n\"\n        \"\\t[-r REPO]\\n\"\n        \"\\n\"\n        \"Installs debuginfo packages for all build-ids listed in BUILD_IDS_FILE to\\n\"\n        \"ABRT system cache.\"\n    );\n\n    enum {\n        OPT_v = 1 << 0,\n        OPT_y = 1 << 1,\n        OPT_i = 1 << 2,\n        OPT_e = 1 << 3,\n        OPT_r = 1 << 4,\n        OPT_s = 1 << 5,\n    };\n\n    const char *build_ids = \"build_ids\";\n    const char *exact = NULL;\n    const char *repo = NULL;\n    const char *size_mb = NULL;\n\n    struct options program_options[] = {\n        OPT__VERBOSE(&g_verbose),\n        OPT_BOOL  ('y', \"yes\",         NULL,                   _(\"Noninteractive, assume 'Yes' to all questions\")),\n        OPT_STRING('i', \"ids\",   &build_ids, \"BUILD_IDS_FILE\", _(\"- means STDIN, default: build_ids\")),\n        OPT_STRING('e', \"exact\",     &exact, \"EXACT\",          _(\"Download only specified files\")),\n        OPT_STRING('r', \"repo\",       &repo, \"REPO\",           _(\"Pattern to use when searching for repos, default: *debug*\")),\n        OPT_STRING('s', \"size_mb\", &size_mb, \"SIZE_MB\",        _(\"Ignored option\")),\n        OPT_END()\n    };\n    const unsigned opts = parse_opts(argc, argv, program_options, program_usage_string);\n\n    const gid_t egid = getegid();\n    const gid_t rgid = getgid();\n    const uid_t euid = geteuid();\n    const gid_t ruid = getuid();\n\n    /* We need to open the build ids file under the caller's UID/GID to avoid\n     * information disclosures when reading files with changed UID.\n     * Unfortunately, we cannot replace STDIN with the new fd because ABRT uses\n     * STDIN to communicate with the caller. So, the following code opens a\n     * dummy file descriptor to the build ids file and passes the new fd's proc\n     * path to the wrapped program in the ids argument.\n     * The new fd remains opened, the OS will close it for us. */\n    char *build_ids_self_fd = NULL;\n    if (strcmp(\"-\", build_ids) != 0)\n    {\n        if (setregid(egid, rgid) < 0)\n            perror_msg_and_die(\"setregid(egid, rgid)\");\n\n        if (setreuid(euid, ruid) < 0)\n            perror_msg_and_die(\"setreuid(euid, ruid)\");\n\n        const int build_ids_fd = open(build_ids, O_RDONLY);\n\n        if (setregid(rgid, egid) < 0)\n            perror_msg_and_die(\"setregid(rgid, egid)\");\n\n        if (setreuid(ruid, euid) < 0 )\n            perror_msg_and_die(\"setreuid(ruid, euid)\");\n\n        if (build_ids_fd < 0)\n            perror_msg_and_die(\"Failed to open file '%s'\", build_ids);\n\n        /* We are not going to free this memory. There is no place to do so. */\n        build_ids_self_fd = xasprintf(\"/proc/self/fd/%d\", build_ids_fd);\n    }\n\n    char tmp_directory[] = LARGE_DATA_TMP_DIR\"/abrt-tmp-debuginfo.XXXXXX\";\n    if (mkdtemp(tmp_directory) == NULL)\n        perror_msg_and_die(\"Failed to create working directory\");\n\n    log_info(\"Created working directory: %s\", tmp_directory);\n\n    /* name, -v, --ids, -, -y, -e, EXACT, -r, REPO, -t, PATH, --, NULL */\n    const char *args[13];\n    {\n        const char *verbs[] = { \"\", \"-v\", \"-vv\", \"-vvv\" };\n        unsigned i = 0;\n        args[i++] = EXECUTABLE;\n        args[i++] = \"--ids\";\n        args[i++] = (build_ids_self_fd != NULL) ? build_ids_self_fd : \"-\";\n        if (g_verbose > 0)\n            args[i++] = verbs[g_verbose <= 3 ? g_verbose : 3];\n        if ((opts & OPT_y))\n            args[i++] = \"-y\";\n        if ((opts & OPT_e))\n        {\n            args[i++] = \"--exact\";\n            args[i++] = exact;\n        }\n        if ((opts & OPT_r))\n        {\n            args[i++] = \"--repo\";\n            args[i++] = repo;\n        }\n        args[i++] = \"--tmpdir\";\n        args[i++] = tmp_directory;\n        args[i++] = \"--\";\n        args[i] = NULL;\n    }\n\n    /* Switch real user/group to effective ones.\n     * Otherwise yum library gets confused - gets EPERM (why??).\n     */\n    /* do setregid only if we have to, to not upset selinux needlessly */\n    if (egid != rgid)\n        IGNORE_RESULT(setregid(egid, egid));\n    if (euid != ruid)\n    {\n        IGNORE_RESULT(setreuid(euid, euid));\n        /* We are suid'ed! */\n        /* Prevent malicious user from messing up with suid'ed process: */\n#if 1\n// We forgot to sanitize PYTHONPATH. And who knows what else we forgot\n// (especially considering *future* new variables of this kind).\n// We switched to clearing entire environment instead:\n\n        // However since we communicate through environment variables\n        // we have to keep a whitelist of variables to keep.\n        static const char *whitelist[] = {\n            \"REPORT_CLIENT_SLAVE\", //  Check if the app is being run as a slave\n            \"LANG\",\n        };\n        const size_t wlsize = sizeof(whitelist)/sizeof(char*);\n        char *setlist[sizeof(whitelist)/sizeof(char*)] = { 0 };\n        char *p = NULL;\n        for (size_t i = 0; i < wlsize; i++)\n            if ((p = getenv(whitelist[i])) != NULL)\n                setlist[i] = xstrdup(p);\n\n        // Now we can clear the environment\n        clearenv();\n\n        // And once again set whitelisted variables\n        for (size_t i = 0; i < wlsize; i++)\n            if (setlist[i] != NULL)\n            {\n                xsetenv(whitelist[i], setlist[i]);\n                free(setlist[i]);\n            }\n#else\n        /* Clear dangerous stuff from env */\n        static const char forbid[] =\n            \"LD_LIBRARY_PATH\" \"\\0\"\n            \"LD_PRELOAD\" \"\\0\"\n            \"LD_TRACE_LOADED_OBJECTS\" \"\\0\"\n            \"LD_BIND_NOW\" \"\\0\"\n            \"LD_AOUT_LIBRARY_PATH\" \"\\0\"\n            \"LD_AOUT_PRELOAD\" \"\\0\"\n            \"LD_NOWARN\" \"\\0\"\n            \"LD_KEEPDIR\" \"\\0\"\n        ;\n        const char *p = forbid;\n        do {\n            unsetenv(p);\n            p += strlen(p) + 1;\n        } while (*p);\n#endif\n        /* Set safe PATH */\n        // Adding configure --bindir and --sbindir to the PATH so that\n        // abrt-action-install-debuginfo doesn't fail when spawning\n        // abrt-action-trim-files\n        char path_env[] = \"PATH=/usr/sbin:/sbin:/usr/bin:/bin:\"BIN_DIR\":\"SBIN_DIR;\n        if (euid != 0)\n            strcpy(path_env, \"PATH=/usr/bin:/bin:\"BIN_DIR);\n        putenv(path_env);\n\n        /* Use safe umask */\n        umask(0022);\n    }\n\n    pid_t pid = fork();\n    if (pid < 0)\n        perror_msg_and_die(\"fork\");\n\n    if (pid == 0)\n    {\n        execvp(EXECUTABLE, (char **)args);\n        error_msg_and_die(\"Can't execute %s\", EXECUTABLE);\n    }\n\n    int status;\n    if (safe_waitpid(pid, &status, 0) < 0)\n        perror_msg_and_die(\"waitpid\");\n\n    if (rmdir(tmp_directory) >= 0)\n        log_info(\"Removed working directory: %s\", tmp_directory);\n    else if (errno != ENOENT)\n        perror_msg(\"Failed to remove working directory\");\n\n    /* Normal execution should exit here. */\n    if (WIFEXITED(status))\n        return WEXITSTATUS(status);\n\n    if (WIFSIGNALED(status))\n        error_msg_and_die(\"Child terminated with signal %d\", WTERMSIG(status));\n\n    error_msg_and_die(\"Child exit failed\");\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -79,8 +79,14 @@\n         build_ids_self_fd = xasprintf(\"/proc/self/fd/%d\", build_ids_fd);\n     }\n \n-    /* name, -v, --ids, -, -y, -e, EXACT, -r, REPO, --, NULL */\n-    const char *args[11];\n+    char tmp_directory[] = LARGE_DATA_TMP_DIR\"/abrt-tmp-debuginfo.XXXXXX\";\n+    if (mkdtemp(tmp_directory) == NULL)\n+        perror_msg_and_die(\"Failed to create working directory\");\n+\n+    log_info(\"Created working directory: %s\", tmp_directory);\n+\n+    /* name, -v, --ids, -, -y, -e, EXACT, -r, REPO, -t, PATH, --, NULL */\n+    const char *args[13];\n     {\n         const char *verbs[] = { \"\", \"-v\", \"-vv\", \"-vvv\" };\n         unsigned i = 0;\n@@ -101,6 +107,8 @@\n             args[i++] = \"--repo\";\n             args[i++] = repo;\n         }\n+        args[i++] = \"--tmpdir\";\n+        args[i++] = tmp_directory;\n         args[i++] = \"--\";\n         args[i] = NULL;\n     }\n@@ -175,6 +183,31 @@\n         umask(0022);\n     }\n \n-    execvp(EXECUTABLE, (char **)args);\n-    error_msg_and_die(\"Can't execute %s\", EXECUTABLE);\n+    pid_t pid = fork();\n+    if (pid < 0)\n+        perror_msg_and_die(\"fork\");\n+\n+    if (pid == 0)\n+    {\n+        execvp(EXECUTABLE, (char **)args);\n+        error_msg_and_die(\"Can't execute %s\", EXECUTABLE);\n+    }\n+\n+    int status;\n+    if (safe_waitpid(pid, &status, 0) < 0)\n+        perror_msg_and_die(\"waitpid\");\n+\n+    if (rmdir(tmp_directory) >= 0)\n+        log_info(\"Removed working directory: %s\", tmp_directory);\n+    else if (errno != ENOENT)\n+        perror_msg(\"Failed to remove working directory\");\n+\n+    /* Normal execution should exit here. */\n+    if (WIFEXITED(status))\n+        return WEXITSTATUS(status);\n+\n+    if (WIFSIGNALED(status))\n+        error_msg_and_die(\"Child terminated with signal %d\", WTERMSIG(status));\n+\n+    error_msg_and_die(\"Child exit failed\");\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    /* name, -v, --ids, -, -y, -e, EXACT, -r, REPO, --, NULL */",
                "    const char *args[11];",
                "    execvp(EXECUTABLE, (char **)args);",
                "    error_msg_and_die(\"Can't execute %s\", EXECUTABLE);"
            ],
            "added_lines": [
                "    char tmp_directory[] = LARGE_DATA_TMP_DIR\"/abrt-tmp-debuginfo.XXXXXX\";",
                "    if (mkdtemp(tmp_directory) == NULL)",
                "        perror_msg_and_die(\"Failed to create working directory\");",
                "",
                "    log_info(\"Created working directory: %s\", tmp_directory);",
                "",
                "    /* name, -v, --ids, -, -y, -e, EXACT, -r, REPO, -t, PATH, --, NULL */",
                "    const char *args[13];",
                "        args[i++] = \"--tmpdir\";",
                "        args[i++] = tmp_directory;",
                "    pid_t pid = fork();",
                "    if (pid < 0)",
                "        perror_msg_and_die(\"fork\");",
                "",
                "    if (pid == 0)",
                "    {",
                "        execvp(EXECUTABLE, (char **)args);",
                "        error_msg_and_die(\"Can't execute %s\", EXECUTABLE);",
                "    }",
                "",
                "    int status;",
                "    if (safe_waitpid(pid, &status, 0) < 0)",
                "        perror_msg_and_die(\"waitpid\");",
                "",
                "    if (rmdir(tmp_directory) >= 0)",
                "        log_info(\"Removed working directory: %s\", tmp_directory);",
                "    else if (errno != ENOENT)",
                "        perror_msg(\"Failed to remove working directory\");",
                "",
                "    /* Normal execution should exit here. */",
                "    if (WIFEXITED(status))",
                "        return WEXITSTATUS(status);",
                "",
                "    if (WIFSIGNALED(status))",
                "        error_msg_and_die(\"Child terminated with signal %d\", WTERMSIG(status));",
                "",
                "    error_msg_and_die(\"Child exit failed\");"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-5287",
        "func_name": "abrt/main",
        "description": "The abrt-hook-ccpp help program in Automatic Bug Reporting Tool (ABRT) before 2.7.1 allows local users with certain permissions to gain privileges via a symlink attack on a file with a predictable name, as demonstrated by /var/tmp/abrt/abrt-hax-coredump or /var/spool/abrt/abrt-hax-coredump.",
        "git_url": "https://github.com/abrt/abrt/commit/3c1b60cfa62d39e5fff5a53a5bc53dae189e740e",
        "commit_title": "ccpp: save abrt core files only to new files",
        "commit_text": " Prior this commit abrt-hook-ccpp saved a core file generated by a process running a program whose name starts with \"abrt\" in DUMP_LOCATION/$(basename program)-coredump. If the file was a symlink, the hook followed and wrote core file to the symlink's target.  Addresses CVE-2015-5287 ",
        "func_before": "int main(int argc, char** argv)\n{\n    /* Kernel starts us with all fd's closed.\n     * But it's dangerous:\n     * fprintf(stderr) can dump messages into random fds, etc.\n     * Ensure that if any of fd 0,1,2 is closed, we open it to /dev/null.\n     */\n    int fd = xopen(\"/dev/null\", O_RDWR);\n    while (fd < 2)\n        fd = xdup(fd);\n    if (fd > 2)\n        close(fd);\n\n    int err = 1;\n    logmode = LOGMODE_JOURNAL;\n\n    /* Parse abrt.conf */\n    load_abrt_conf();\n    /* ... and plugins/CCpp.conf */\n    bool setting_MakeCompatCore;\n    bool setting_SaveBinaryImage;\n    bool setting_SaveFullCore;\n    bool setting_CreateCoreBacktrace;\n    bool setting_SaveContainerizedPackageData;\n    bool setting_StandaloneHook;\n    {\n        map_string_t *settings = new_map_string();\n        load_abrt_plugin_conf_file(\"CCpp.conf\", settings);\n        const char *value;\n        value = get_map_string_item_or_NULL(settings, \"MakeCompatCore\");\n        setting_MakeCompatCore = value && string_to_bool(value);\n        value = get_map_string_item_or_NULL(settings, \"SaveBinaryImage\");\n        setting_SaveBinaryImage = value && string_to_bool(value);\n        value = get_map_string_item_or_NULL(settings, \"SaveFullCore\");\n        setting_SaveFullCore = value ? string_to_bool(value) : true;\n        value = get_map_string_item_or_NULL(settings, \"CreateCoreBacktrace\");\n        setting_CreateCoreBacktrace = value ? string_to_bool(value) : true;\n\n        value = get_map_string_item_or_NULL(settings, \"SaveContainerizedPackageData\");\n        setting_SaveContainerizedPackageData = value && string_to_bool(value);\n\n        /* Do not call abrt-action-save-package-data with process's root, if ExploreChroots is disabled. */\n        if (!g_settings_explorechroots)\n        {\n            if (setting_SaveContainerizedPackageData)\n                log_warning(\"Ignoring SaveContainerizedPackageData because ExploreChroots is disabled\");\n            setting_SaveContainerizedPackageData = false;\n        }\n\n        value = get_map_string_item_or_NULL(settings, \"StandaloneHook\");\n        setting_StandaloneHook = value && string_to_bool(value);\n        value = get_map_string_item_or_NULL(settings, \"VerboseLog\");\n        if (value)\n            g_verbose = xatoi_positive(value);\n        free_map_string(settings);\n    }\n\n    if (argc == 2 && strcmp(argv[1], \"--config-test\"))\n        return test_configuration(setting_SaveFullCore, setting_CreateCoreBacktrace);\n\n    if (argc < 8)\n    {\n        /* percent specifier:         %s   %c              %p  %u  %g  %t   %e          %P         %i*/\n        /* argv:                  [0] [1]  [2]             [3] [4] [5] [6]  [7]         [8]        [9]*/\n        error_msg_and_die(\"Usage: %s SIGNO CORE_SIZE_LIMIT PID UID GID TIME BINARY_NAME GLOBAL_PID [TID]\", argv[0]);\n    }\n\n    /* Not needed on 2.6.30.\n     * At least 2.6.18 has a bug where\n     * argv[1] = \"SIGNO CORE_SIZE_LIMIT PID ...\"\n     * argv[2] = \"CORE_SIZE_LIMIT PID ...\"\n     * and so on. Fixing it:\n     */\n    if (strchr(argv[1], ' '))\n    {\n        int i;\n        for (i = 1; argv[i]; i++)\n        {\n            strchrnul(argv[i], ' ')[0] = '\\0';\n        }\n    }\n\n    errno = 0;\n    const char* signal_str = argv[1];\n    int signal_no = xatoi_positive(signal_str);\n    off_t ulimit_c = strtoull(argv[2], NULL, 10);\n    if (ulimit_c < 0) /* unlimited? */\n    {\n        /* set to max possible >0 value */\n        ulimit_c = ~((off_t)1 << (sizeof(off_t)*8-1));\n    }\n    const char *pid_str = argv[3];\n    pid_t local_pid = xatoi_positive(argv[3]);\n    uid_t uid = xatoi_positive(argv[4]);\n    if (errno || local_pid <= 0)\n    {\n        perror_msg_and_die(\"PID '%s' or limit '%s' is bogus\", argv[3], argv[2]);\n    }\n\n    {\n        char *s = xmalloc_fopen_fgetline_fclose(VAR_RUN\"/abrt/saved_core_pattern\");\n        /* If we have a saved pattern and it's not a \"|PROG ARGS\" thing... */\n        if (s && s[0] != '|')\n            core_basename = s;\n        else\n            free(s);\n    }\n    const char *global_pid_str = argv[8];\n    pid_t pid = xatoi_positive(argv[8]);\n\n    pid_t tid = -1;\n    const char *tid_str = argv[9];\n    if (tid_str)\n    {\n        tid = xatoi_positive(tid_str);\n    }\n\n    char path[PATH_MAX];\n\n    char *executable = get_executable(pid);\n    if (executable && strstr(executable, \"/abrt-hook-ccpp\"))\n    {\n        error_msg_and_die(\"PID %lu is '%s', not dumping it to avoid recursion\",\n                        (long)pid, executable);\n    }\n\n    user_pwd = get_cwd(pid); /* may be NULL on error */\n    log_notice(\"user_pwd:'%s'\", user_pwd);\n\n    sprintf(path, \"/proc/%lu/status\", (long)pid);\n    char *proc_pid_status = xmalloc_xopen_read_close(path, /*maxsz:*/ NULL);\n\n    uid_t fsuid = uid;\n    uid_t tmp_fsuid = get_fsuid(proc_pid_status);\n    if (tmp_fsuid < 0)\n        perror_msg_and_die(\"Can't parse 'Uid: line' in /proc/%lu/status\", (long)pid);\n\n    const int fsgid = get_fsgid(proc_pid_status);\n    if (fsgid < 0)\n        error_msg_and_die(\"Can't parse 'Gid: line' in /proc/%lu/status\", (long)pid);\n\n    int suid_policy = dump_suid_policy();\n    if (tmp_fsuid != uid)\n    {\n        /* use root for suided apps unless it's explicitly set to UNSAFE */\n        fsuid = 0;\n        if (suid_policy == DUMP_SUID_UNSAFE)\n            fsuid = tmp_fsuid;\n        else\n        {\n            g_user_core_flags = O_EXCL;\n            g_need_nonrelative = 1;\n        }\n    }\n\n    /* Open a fd to compat coredump, if requested and is possible */\n    int user_core_fd = -1;\n    if (setting_MakeCompatCore && ulimit_c != 0)\n        /* note: checks \"user_pwd == NULL\" inside; updates core_basename */\n        user_core_fd = open_user_core(uid, fsuid, fsgid, pid, &argv[1]);\n\n    if (executable == NULL)\n    {\n        /* readlink on /proc/$PID/exe failed, don't create abrt dump dir */\n        error_msg(\"Can't read /proc/%lu/exe link\", (long)pid);\n        return create_user_core(user_core_fd, pid, ulimit_c);\n    }\n\n    const char *signame = NULL;\n    if (!signal_is_fatal(signal_no, &signame))\n        return create_user_core(user_core_fd, pid, ulimit_c); // not a signal we care about\n\n    const int abrtd_running = daemon_is_ok();\n    if (!setting_StandaloneHook && !abrtd_running)\n    {\n        /* not an error, exit with exit code 0 */\n        log(\"abrtd is not running. If it crashed, \"\n            \"/proc/sys/kernel/core_pattern contains a stale value, \"\n            \"consider resetting it to 'core'\"\n        );\n        return create_user_core(user_core_fd, pid, ulimit_c);\n    }\n\n    if (setting_StandaloneHook)\n        ensure_writable_dir(g_settings_dump_location, DEFAULT_DUMP_LOCATION_MODE, \"abrt\");\n\n    if (g_settings_nMaxCrashReportsSize > 0)\n    {\n        /* If free space is less than 1/4 of MaxCrashReportsSize... */\n        if (low_free_space(g_settings_nMaxCrashReportsSize, g_settings_dump_location))\n            return create_user_core(user_core_fd, pid, ulimit_c);\n    }\n\n    /* Check /var/tmp/abrt/last-ccpp marker, do not dump repeated crashes\n     * if they happen too often. Else, write new marker value.\n     */\n    snprintf(path, sizeof(path), \"%s/last-ccpp\", g_settings_dump_location);\n    if (check_recent_crash_file(path, executable))\n    {\n        /* It is a repeating crash */\n        return create_user_core(user_core_fd, pid, ulimit_c);\n    }\n\n    const char *last_slash = strrchr(executable, '/');\n    if (last_slash && strncmp(++last_slash, \"abrt\", 4) == 0)\n    {\n        if (g_settings_debug_level == 0)\n        {\n            log_warning(\"Ignoring crash of %s (SIG%s).\",\n                        executable, signame ? signame : signal_str);\n            goto cleanup_and_exit;\n        }\n\n        /* If abrtd/abrt-foo crashes, we don't want to create a _directory_,\n         * since that can make new copy of abrtd to process it,\n         * and maybe crash again...\n         * Unlike dirs, mere files are ignored by abrtd.\n         */\n        if (snprintf(path, sizeof(path), \"%s/%s-coredump\", g_settings_dump_location, last_slash) >= sizeof(path))\n            error_msg_and_die(\"Error saving '%s': truncated long file path\", path);\n\n        int abrt_core_fd = xopen3(path, O_WRONLY | O_CREAT | O_TRUNC, 0600);\n        off_t core_size = copyfd_eof(STDIN_FILENO, abrt_core_fd, COPYFD_SPARSE);\n        if (core_size < 0 || fsync(abrt_core_fd) != 0)\n        {\n            unlink(path);\n            /* copyfd_eof logs the error including errno string,\n             * but it does not log file name */\n            error_msg_and_die(\"Error saving '%s'\", path);\n        }\n        log_notice(\"Saved core dump of pid %lu (%s) to %s (%llu bytes)\", (long)pid, executable, path, (long long)core_size);\n        err = 0;\n        goto cleanup_and_exit;\n    }\n\n    unsigned path_len = snprintf(path, sizeof(path), \"%s/ccpp-%s-%lu.new\",\n            g_settings_dump_location, iso_date_string(NULL), (long)pid);\n    if (path_len >= (sizeof(path) - sizeof(\"/\"FILENAME_COREDUMP)))\n    {\n        return create_user_core(user_core_fd, pid, ulimit_c);\n    }\n\n    /* If you don't want to have fs owner as root then:\n     *\n     * - use fsuid instead of uid for fs owner, so we don't expose any\n     *   sensitive information of suided app in /var/(tmp|spool)/abrt\n     *\n     * - use dd_create_skeleton() and dd_reset_ownership(), when you finish\n     *   creating the new dump directory, to prevent the real owner to write to\n     *   the directory until the hook is done (avoid race conditions and defend\n     *   hard and symbolic link attacs)\n     */\n    dd = dd_create(path, /*fs owner*/0, DEFAULT_DUMP_DIR_MODE);\n    if (dd)\n    {\n        char source_filename[sizeof(\"/proc/%lu/somewhat_long_name\") + sizeof(long)*3];\n        int source_base_ofs = sprintf(source_filename, \"/proc/%lu/root\", (long)pid);\n        source_base_ofs -= strlen(\"root\");\n\n        /* What's wrong on using /proc/[pid]/root every time ?*/\n        /* It creates os_info_in_root_dir for all crashes. */\n        char *rootdir = process_has_own_root(pid) ? get_rootdir(pid) : NULL;\n\n        /* Reading data from an arbitrary root directory is not secure. */\n        if (g_settings_explorechroots)\n        {\n            /* Yes, test 'rootdir' but use 'source_filename' because 'rootdir' can\n             * be '/' for a process with own namespace. 'source_filename' is /proc/[pid]/root. */\n            dd_create_basic_files(dd, fsuid, (rootdir != NULL) ? source_filename : NULL);\n        }\n        else\n        {\n            dd_create_basic_files(dd, fsuid, NULL);\n        }\n\n        char *dest_filename = concat_path_file(dd->dd_dirname, \"also_somewhat_longish_name\");\n        char *dest_base = strrchr(dest_filename, '/') + 1;\n\n        // Disabled for now: /proc/PID/smaps tends to be BIG,\n        // and not much more informative than /proc/PID/maps:\n        // dd_copy_file(dd, FILENAME_SMAPS, source_filename);\n\n        strcpy(source_filename + source_base_ofs, \"maps\");\n        dd_copy_file(dd, FILENAME_MAPS, source_filename);\n\n        strcpy(source_filename + source_base_ofs, \"limits\");\n        dd_copy_file(dd, FILENAME_LIMITS, source_filename);\n\n        strcpy(source_filename + source_base_ofs, \"cgroup\");\n        dd_copy_file(dd, FILENAME_CGROUP, source_filename);\n\n        strcpy(source_filename + source_base_ofs, \"mountinfo\");\n        dd_copy_file(dd, FILENAME_MOUNTINFO, source_filename);\n\n        strcpy(dest_base, FILENAME_OPEN_FDS);\n        strcpy(source_filename + source_base_ofs, \"fd\");\n        dump_fd_info_ext(dest_filename, source_filename, dd->dd_uid, dd->dd_gid);\n\n        strcpy(dest_base, FILENAME_NAMESPACES);\n        dump_namespace_diff_ext(dest_filename, 1, pid, dd->dd_uid, dd->dd_gid);\n\n        free(dest_filename);\n\n        char *tmp = NULL;\n        get_env_variable(pid, \"container\", &tmp);\n        if (tmp != NULL)\n        {\n            dd_save_text(dd, FILENAME_CONTAINER, tmp);\n            free(tmp);\n            tmp = NULL;\n        }\n\n        get_env_variable(pid, \"container_uuid\", &tmp);\n        if (tmp != NULL)\n        {\n            dd_save_text(dd, FILENAME_CONTAINER_UUID, tmp);\n            free(tmp);\n        }\n\n        /* There's no need to compare mount namespaces and search for '/' in\n         * mountifo.  Comparison of inodes of '/proc/[pid]/root' and '/' works\n         * fine. If those inodes do not equal each other, we have to verify\n         * that '/proc/[pid]/root' is not a symlink to a chroot.\n         */\n        const int containerized = (rootdir != NULL && strcmp(rootdir, \"/\") == 0);\n        if (containerized)\n        {\n            log_debug(\"Process %d is considered to be containerized\", pid);\n            pid_t container_pid;\n            if (get_pid_of_container(pid, &container_pid) == 0)\n            {\n                char *container_cmdline = get_cmdline(container_pid);\n                dd_save_text(dd, FILENAME_CONTAINER_CMDLINE, container_cmdline);\n                free(container_cmdline);\n            }\n        }\n\n        dd_save_text(dd, FILENAME_ANALYZER, \"abrt-ccpp\");\n        dd_save_text(dd, FILENAME_TYPE, \"CCpp\");\n        dd_save_text(dd, FILENAME_EXECUTABLE, executable);\n        dd_save_text(dd, FILENAME_PID, pid_str);\n        dd_save_text(dd, FILENAME_GLOBAL_PID, global_pid_str);\n        dd_save_text(dd, FILENAME_PROC_PID_STATUS, proc_pid_status);\n        if (user_pwd)\n            dd_save_text(dd, FILENAME_PWD, user_pwd);\n        if (tid_str)\n            dd_save_text(dd, FILENAME_TID, tid_str);\n\n        if (rootdir)\n        {\n            if (strcmp(rootdir, \"/\") != 0)\n                dd_save_text(dd, FILENAME_ROOTDIR, rootdir);\n        }\n        free(rootdir);\n\n        char *reason = xasprintf(\"%s killed by SIG%s\",\n                                 last_slash, signame ? signame : signal_str);\n        dd_save_text(dd, FILENAME_REASON, reason);\n        free(reason);\n\n        char *cmdline = get_cmdline(pid);\n        dd_save_text(dd, FILENAME_CMDLINE, cmdline ? : \"\");\n        free(cmdline);\n\n        char *environ = get_environ(pid);\n        dd_save_text(dd, FILENAME_ENVIRON, environ ? : \"\");\n        free(environ);\n\n        char *fips_enabled = xmalloc_fopen_fgetline_fclose(\"/proc/sys/crypto/fips_enabled\");\n        if (fips_enabled)\n        {\n            if (strcmp(fips_enabled, \"0\") != 0)\n                dd_save_text(dd, \"fips_enabled\", fips_enabled);\n            free(fips_enabled);\n        }\n\n        dd_save_text(dd, FILENAME_ABRT_VERSION, VERSION);\n\n        /* In case of errors, treat the process as if it has locked memory */\n        long unsigned lck_bytes = ULONG_MAX;\n        const char *vmlck = strstr(proc_pid_status, \"VmLck:\");\n        if (vmlck == NULL)\n            error_msg(\"/proc/%s/status does not contain 'VmLck:' line\", pid_str);\n        else if (1 != sscanf(vmlck + 6, \"%lu kB\\n\", &lck_bytes))\n            error_msg(\"Failed to parse 'VmLck:' line in /proc/%s/status\", pid_str);\n\n        if (lck_bytes)\n        {\n            log_notice(\"Process %s of user %lu has locked memory\",\n                        pid_str, (long unsigned)uid);\n\n            dd_mark_as_notreportable(dd, \"The process had locked memory \"\n                    \"which usually indicates efforts to protect sensitive \"\n                    \"data (passwords) from being written to disk.\\n\"\n                    \"In order to avoid sensitive information leakages, \"\n                    \"ABRT will not allow you to report this problem to \"\n                    \"bug tracking tools\");\n        }\n\n        if (setting_SaveBinaryImage)\n        {\n            if (save_crashing_binary(pid, dd))\n            {\n                error_msg(\"Error saving '%s'\", path);\n\n                goto cleanup_and_exit;\n            }\n        }\n\n        off_t core_size = 0;\n        if (setting_SaveFullCore)\n        {\n            strcpy(path + path_len, \"/\"FILENAME_COREDUMP);\n            int abrt_core_fd = create_or_die(path, user_core_fd);\n\n            /* We write both coredumps at once.\n             * We can't write user coredump first, since it might be truncated\n             * and thus can't be copied and used as abrt coredump;\n             * and if we write abrt coredump first and then copy it as user one,\n             * then we have a race when process exits but coredump does not exist yet:\n             * $ echo -e '#include<signal.h>\\nmain(){raise(SIGSEGV);}' | gcc -o test -x c -\n             * $ rm -f core*; ulimit -c unlimited; ./test; ls -l core*\n             * 21631 Segmentation fault (core dumped) ./test\n             * ls: cannot access core*: No such file or directory <=== BAD\n             */\n            core_size = copyfd_sparse(STDIN_FILENO, abrt_core_fd, user_core_fd, ulimit_c);\n            close_user_core(user_core_fd, core_size);\n            if (fsync(abrt_core_fd) != 0 || close(abrt_core_fd) != 0 || core_size < 0)\n            {\n                unlink(path);\n\n                /* copyfd_sparse logs the error including errno string,\n                 * but it does not log file name */\n                error_msg(\"Error writing '%s'\", path);\n\n                goto cleanup_and_exit;\n            }\n        }\n        else\n        {\n            /* User core is created even if WriteFullCore is off. */\n            create_user_core(user_core_fd, pid, ulimit_c);\n        }\n\n        /* User core is either written or closed */\n        user_core_fd = -1;\n\n        /*\n         * ! No other errors should cause removal of the user core !\n         */\n\n/* Because of #1211835 and #1126850 */\n#if 0\n        /* Save JVM crash log if it exists. (JVM's coredump per se\n         * is nearly useless for JVM developers)\n         */\n        {\n            char *java_log = xasprintf(\"/tmp/jvm-%lu/hs_error.log\", (long)pid);\n            int src_fd = open(java_log, O_RDONLY);\n            free(java_log);\n\n            /* If we couldn't open the error log in /tmp directory we can try to\n             * read the log from the current directory. It may produce AVC, it\n             * may produce some error log but all these are expected.\n             */\n            if (src_fd < 0)\n            {\n                java_log = xasprintf(\"%s/hs_err_pid%lu.log\", user_pwd, (long)pid);\n                src_fd = open(java_log, O_RDONLY);\n                free(java_log);\n            }\n\n            if (src_fd >= 0)\n            {\n                strcpy(path + path_len, \"/hs_err.log\");\n                int dst_fd = create_or_die(path, user_core_fd);\n                off_t sz = copyfd_eof(src_fd, dst_fd, COPYFD_SPARSE);\n                if (close(dst_fd) != 0 || sz < 0)\n                {\n                    error_msg(\"Error saving '%s'\", path);\n\n                    goto cleanup_and_exit;\n                }\n                close(src_fd);\n            }\n        }\n#endif\n\n        /* Perform crash-time unwind of the guilty thread. */\n        if (tid > 0 && setting_CreateCoreBacktrace)\n            create_core_backtrace(tid, executable, signal_no, dd);\n\n        /* We close dumpdir before we start catering for crash storm case.\n         * Otherwise, delete_dump_dir's from other concurrent\n         * CCpp's won't be able to delete our dump (their delete_dump_dir\n         * will wait for us), and we won't be able to delete their dumps.\n         * Classic deadlock.\n         */\n        dd_close(dd);\n        dd = NULL;\n\n        path[path_len] = '\\0'; /* path now contains only directory name */\n\n        if (abrtd_running && setting_SaveContainerizedPackageData && containerized)\n        {   /* Do we really need to run rpm from core_pattern hook? */\n            sprintf(source_filename, \"/proc/%lu/root\", (long)pid);\n\n            const char *cmd_args[6];\n            cmd_args[0] = BIN_DIR\"/abrt-action-save-package-data\";\n            cmd_args[1] = \"-d\";\n            cmd_args[2] = path;\n            cmd_args[3] = \"-r\";\n            cmd_args[4] = source_filename;\n            cmd_args[5] = NULL;\n\n            pid_t pid = fork_execv_on_steroids(0, (char **)cmd_args, NULL, NULL, path, 0);\n            int stat;\n            safe_waitpid(pid, &stat, 0);\n        }\n\n        char *newpath = xstrndup(path, path_len - (sizeof(\".new\")-1));\n        if (rename(path, newpath) == 0)\n            strcpy(path, newpath);\n        free(newpath);\n\n        if (core_size > 0)\n            log_notice(\"Saved core dump of pid %lu (%s) to %s (%llu bytes)\",\n                       (long)pid, executable, path, (long long)core_size);\n\n        if (abrtd_running)\n            notify_new_path(path);\n\n        /* rhbz#539551: \"abrt going crazy when crashing process is respawned\" */\n        if (g_settings_nMaxCrashReportsSize > 0)\n        {\n            /* x1.25 and round up to 64m: go a bit up, so that usual in-daemon trimming\n             * kicks in first, and we don't \"fight\" with it:\n             */\n            unsigned maxsize = g_settings_nMaxCrashReportsSize + g_settings_nMaxCrashReportsSize / 4;\n            maxsize |= 63;\n            trim_problem_dirs(g_settings_dump_location, maxsize * (double)(1024*1024), path);\n        }\n\n        err = 0;\n    }\n    else\n    {\n        /* We didn't create abrt dump, but may need to create compat coredump */\n        return create_user_core(user_core_fd, pid, ulimit_c);\n    }\n\ncleanup_and_exit:\n    if (dd)\n        dd_delete(dd);\n\n    if (user_core_fd >= 0)\n        unlinkat(dirfd(proc_cwd), core_basename, /*only files*/0);\n\n    if (proc_cwd != NULL)\n        closedir(proc_cwd);\n\n    return err;\n}",
        "func": "int main(int argc, char** argv)\n{\n    /* Kernel starts us with all fd's closed.\n     * But it's dangerous:\n     * fprintf(stderr) can dump messages into random fds, etc.\n     * Ensure that if any of fd 0,1,2 is closed, we open it to /dev/null.\n     */\n    int fd = xopen(\"/dev/null\", O_RDWR);\n    while (fd < 2)\n        fd = xdup(fd);\n    if (fd > 2)\n        close(fd);\n\n    int err = 1;\n    logmode = LOGMODE_JOURNAL;\n\n    /* Parse abrt.conf */\n    load_abrt_conf();\n    /* ... and plugins/CCpp.conf */\n    bool setting_MakeCompatCore;\n    bool setting_SaveBinaryImage;\n    bool setting_SaveFullCore;\n    bool setting_CreateCoreBacktrace;\n    bool setting_SaveContainerizedPackageData;\n    bool setting_StandaloneHook;\n    {\n        map_string_t *settings = new_map_string();\n        load_abrt_plugin_conf_file(\"CCpp.conf\", settings);\n        const char *value;\n        value = get_map_string_item_or_NULL(settings, \"MakeCompatCore\");\n        setting_MakeCompatCore = value && string_to_bool(value);\n        value = get_map_string_item_or_NULL(settings, \"SaveBinaryImage\");\n        setting_SaveBinaryImage = value && string_to_bool(value);\n        value = get_map_string_item_or_NULL(settings, \"SaveFullCore\");\n        setting_SaveFullCore = value ? string_to_bool(value) : true;\n        value = get_map_string_item_or_NULL(settings, \"CreateCoreBacktrace\");\n        setting_CreateCoreBacktrace = value ? string_to_bool(value) : true;\n\n        value = get_map_string_item_or_NULL(settings, \"SaveContainerizedPackageData\");\n        setting_SaveContainerizedPackageData = value && string_to_bool(value);\n\n        /* Do not call abrt-action-save-package-data with process's root, if ExploreChroots is disabled. */\n        if (!g_settings_explorechroots)\n        {\n            if (setting_SaveContainerizedPackageData)\n                log_warning(\"Ignoring SaveContainerizedPackageData because ExploreChroots is disabled\");\n            setting_SaveContainerizedPackageData = false;\n        }\n\n        value = get_map_string_item_or_NULL(settings, \"StandaloneHook\");\n        setting_StandaloneHook = value && string_to_bool(value);\n        value = get_map_string_item_or_NULL(settings, \"VerboseLog\");\n        if (value)\n            g_verbose = xatoi_positive(value);\n        free_map_string(settings);\n    }\n\n    if (argc == 2 && strcmp(argv[1], \"--config-test\"))\n        return test_configuration(setting_SaveFullCore, setting_CreateCoreBacktrace);\n\n    if (argc < 8)\n    {\n        /* percent specifier:         %s   %c              %p  %u  %g  %t   %e          %P         %i*/\n        /* argv:                  [0] [1]  [2]             [3] [4] [5] [6]  [7]         [8]        [9]*/\n        error_msg_and_die(\"Usage: %s SIGNO CORE_SIZE_LIMIT PID UID GID TIME BINARY_NAME GLOBAL_PID [TID]\", argv[0]);\n    }\n\n    /* Not needed on 2.6.30.\n     * At least 2.6.18 has a bug where\n     * argv[1] = \"SIGNO CORE_SIZE_LIMIT PID ...\"\n     * argv[2] = \"CORE_SIZE_LIMIT PID ...\"\n     * and so on. Fixing it:\n     */\n    if (strchr(argv[1], ' '))\n    {\n        int i;\n        for (i = 1; argv[i]; i++)\n        {\n            strchrnul(argv[i], ' ')[0] = '\\0';\n        }\n    }\n\n    errno = 0;\n    const char* signal_str = argv[1];\n    int signal_no = xatoi_positive(signal_str);\n    off_t ulimit_c = strtoull(argv[2], NULL, 10);\n    if (ulimit_c < 0) /* unlimited? */\n    {\n        /* set to max possible >0 value */\n        ulimit_c = ~((off_t)1 << (sizeof(off_t)*8-1));\n    }\n    const char *pid_str = argv[3];\n    pid_t local_pid = xatoi_positive(argv[3]);\n    uid_t uid = xatoi_positive(argv[4]);\n    if (errno || local_pid <= 0)\n    {\n        perror_msg_and_die(\"PID '%s' or limit '%s' is bogus\", argv[3], argv[2]);\n    }\n\n    {\n        char *s = xmalloc_fopen_fgetline_fclose(VAR_RUN\"/abrt/saved_core_pattern\");\n        /* If we have a saved pattern and it's not a \"|PROG ARGS\" thing... */\n        if (s && s[0] != '|')\n            core_basename = s;\n        else\n            free(s);\n    }\n    const char *global_pid_str = argv[8];\n    pid_t pid = xatoi_positive(argv[8]);\n\n    pid_t tid = -1;\n    const char *tid_str = argv[9];\n    if (tid_str)\n    {\n        tid = xatoi_positive(tid_str);\n    }\n\n    char path[PATH_MAX];\n\n    char *executable = get_executable(pid);\n    if (executable && strstr(executable, \"/abrt-hook-ccpp\"))\n    {\n        error_msg_and_die(\"PID %lu is '%s', not dumping it to avoid recursion\",\n                        (long)pid, executable);\n    }\n\n    user_pwd = get_cwd(pid); /* may be NULL on error */\n    log_notice(\"user_pwd:'%s'\", user_pwd);\n\n    sprintf(path, \"/proc/%lu/status\", (long)pid);\n    char *proc_pid_status = xmalloc_xopen_read_close(path, /*maxsz:*/ NULL);\n\n    uid_t fsuid = uid;\n    uid_t tmp_fsuid = get_fsuid(proc_pid_status);\n    if (tmp_fsuid < 0)\n        perror_msg_and_die(\"Can't parse 'Uid: line' in /proc/%lu/status\", (long)pid);\n\n    const int fsgid = get_fsgid(proc_pid_status);\n    if (fsgid < 0)\n        error_msg_and_die(\"Can't parse 'Gid: line' in /proc/%lu/status\", (long)pid);\n\n    int suid_policy = dump_suid_policy();\n    if (tmp_fsuid != uid)\n    {\n        /* use root for suided apps unless it's explicitly set to UNSAFE */\n        fsuid = 0;\n        if (suid_policy == DUMP_SUID_UNSAFE)\n            fsuid = tmp_fsuid;\n        else\n        {\n            g_user_core_flags = O_EXCL;\n            g_need_nonrelative = 1;\n        }\n    }\n\n    /* Open a fd to compat coredump, if requested and is possible */\n    int user_core_fd = -1;\n    if (setting_MakeCompatCore && ulimit_c != 0)\n        /* note: checks \"user_pwd == NULL\" inside; updates core_basename */\n        user_core_fd = open_user_core(uid, fsuid, fsgid, pid, &argv[1]);\n\n    if (executable == NULL)\n    {\n        /* readlink on /proc/$PID/exe failed, don't create abrt dump dir */\n        error_msg(\"Can't read /proc/%lu/exe link\", (long)pid);\n        return create_user_core(user_core_fd, pid, ulimit_c);\n    }\n\n    const char *signame = NULL;\n    if (!signal_is_fatal(signal_no, &signame))\n        return create_user_core(user_core_fd, pid, ulimit_c); // not a signal we care about\n\n    const int abrtd_running = daemon_is_ok();\n    if (!setting_StandaloneHook && !abrtd_running)\n    {\n        /* not an error, exit with exit code 0 */\n        log(\"abrtd is not running. If it crashed, \"\n            \"/proc/sys/kernel/core_pattern contains a stale value, \"\n            \"consider resetting it to 'core'\"\n        );\n        return create_user_core(user_core_fd, pid, ulimit_c);\n    }\n\n    if (setting_StandaloneHook)\n        ensure_writable_dir(g_settings_dump_location, DEFAULT_DUMP_LOCATION_MODE, \"abrt\");\n\n    if (g_settings_nMaxCrashReportsSize > 0)\n    {\n        /* If free space is less than 1/4 of MaxCrashReportsSize... */\n        if (low_free_space(g_settings_nMaxCrashReportsSize, g_settings_dump_location))\n            return create_user_core(user_core_fd, pid, ulimit_c);\n    }\n\n    /* Check /var/tmp/abrt/last-ccpp marker, do not dump repeated crashes\n     * if they happen too often. Else, write new marker value.\n     */\n    snprintf(path, sizeof(path), \"%s/last-ccpp\", g_settings_dump_location);\n    if (check_recent_crash_file(path, executable))\n    {\n        /* It is a repeating crash */\n        return create_user_core(user_core_fd, pid, ulimit_c);\n    }\n\n    const char *last_slash = strrchr(executable, '/');\n    if (last_slash && strncmp(++last_slash, \"abrt\", 4) == 0)\n    {\n        if (g_settings_debug_level == 0)\n        {\n            log_warning(\"Ignoring crash of %s (SIG%s).\",\n                        executable, signame ? signame : signal_str);\n            goto cleanup_and_exit;\n        }\n\n        /* If abrtd/abrt-foo crashes, we don't want to create a _directory_,\n         * since that can make new copy of abrtd to process it,\n         * and maybe crash again...\n         * Unlike dirs, mere files are ignored by abrtd.\n         */\n        if (snprintf(path, sizeof(path), \"%s/%s-coredump\", g_settings_dump_location, last_slash) >= sizeof(path))\n            error_msg_and_die(\"Error saving '%s': truncated long file path\", path);\n\n        unlink(path);\n        int abrt_core_fd = xopen3(path, O_WRONLY | O_CREAT | O_EXCL, 0600);\n        off_t core_size = copyfd_eof(STDIN_FILENO, abrt_core_fd, COPYFD_SPARSE);\n        if (core_size < 0 || fsync(abrt_core_fd) != 0)\n        {\n            unlink(path);\n            /* copyfd_eof logs the error including errno string,\n             * but it does not log file name */\n            error_msg_and_die(\"Error saving '%s'\", path);\n        }\n        log_notice(\"Saved core dump of pid %lu (%s) to %s (%llu bytes)\", (long)pid, executable, path, (long long)core_size);\n        err = 0;\n        goto cleanup_and_exit;\n    }\n\n    unsigned path_len = snprintf(path, sizeof(path), \"%s/ccpp-%s-%lu.new\",\n            g_settings_dump_location, iso_date_string(NULL), (long)pid);\n    if (path_len >= (sizeof(path) - sizeof(\"/\"FILENAME_COREDUMP)))\n    {\n        return create_user_core(user_core_fd, pid, ulimit_c);\n    }\n\n    /* If you don't want to have fs owner as root then:\n     *\n     * - use fsuid instead of uid for fs owner, so we don't expose any\n     *   sensitive information of suided app in /var/(tmp|spool)/abrt\n     *\n     * - use dd_create_skeleton() and dd_reset_ownership(), when you finish\n     *   creating the new dump directory, to prevent the real owner to write to\n     *   the directory until the hook is done (avoid race conditions and defend\n     *   hard and symbolic link attacs)\n     */\n    dd = dd_create(path, /*fs owner*/0, DEFAULT_DUMP_DIR_MODE);\n    if (dd)\n    {\n        char source_filename[sizeof(\"/proc/%lu/somewhat_long_name\") + sizeof(long)*3];\n        int source_base_ofs = sprintf(source_filename, \"/proc/%lu/root\", (long)pid);\n        source_base_ofs -= strlen(\"root\");\n\n        /* What's wrong on using /proc/[pid]/root every time ?*/\n        /* It creates os_info_in_root_dir for all crashes. */\n        char *rootdir = process_has_own_root(pid) ? get_rootdir(pid) : NULL;\n\n        /* Reading data from an arbitrary root directory is not secure. */\n        if (g_settings_explorechroots)\n        {\n            /* Yes, test 'rootdir' but use 'source_filename' because 'rootdir' can\n             * be '/' for a process with own namespace. 'source_filename' is /proc/[pid]/root. */\n            dd_create_basic_files(dd, fsuid, (rootdir != NULL) ? source_filename : NULL);\n        }\n        else\n        {\n            dd_create_basic_files(dd, fsuid, NULL);\n        }\n\n        char *dest_filename = concat_path_file(dd->dd_dirname, \"also_somewhat_longish_name\");\n        char *dest_base = strrchr(dest_filename, '/') + 1;\n\n        // Disabled for now: /proc/PID/smaps tends to be BIG,\n        // and not much more informative than /proc/PID/maps:\n        // dd_copy_file(dd, FILENAME_SMAPS, source_filename);\n\n        strcpy(source_filename + source_base_ofs, \"maps\");\n        dd_copy_file(dd, FILENAME_MAPS, source_filename);\n\n        strcpy(source_filename + source_base_ofs, \"limits\");\n        dd_copy_file(dd, FILENAME_LIMITS, source_filename);\n\n        strcpy(source_filename + source_base_ofs, \"cgroup\");\n        dd_copy_file(dd, FILENAME_CGROUP, source_filename);\n\n        strcpy(source_filename + source_base_ofs, \"mountinfo\");\n        dd_copy_file(dd, FILENAME_MOUNTINFO, source_filename);\n\n        strcpy(dest_base, FILENAME_OPEN_FDS);\n        strcpy(source_filename + source_base_ofs, \"fd\");\n        dump_fd_info_ext(dest_filename, source_filename, dd->dd_uid, dd->dd_gid);\n\n        strcpy(dest_base, FILENAME_NAMESPACES);\n        dump_namespace_diff_ext(dest_filename, 1, pid, dd->dd_uid, dd->dd_gid);\n\n        free(dest_filename);\n\n        char *tmp = NULL;\n        get_env_variable(pid, \"container\", &tmp);\n        if (tmp != NULL)\n        {\n            dd_save_text(dd, FILENAME_CONTAINER, tmp);\n            free(tmp);\n            tmp = NULL;\n        }\n\n        get_env_variable(pid, \"container_uuid\", &tmp);\n        if (tmp != NULL)\n        {\n            dd_save_text(dd, FILENAME_CONTAINER_UUID, tmp);\n            free(tmp);\n        }\n\n        /* There's no need to compare mount namespaces and search for '/' in\n         * mountifo.  Comparison of inodes of '/proc/[pid]/root' and '/' works\n         * fine. If those inodes do not equal each other, we have to verify\n         * that '/proc/[pid]/root' is not a symlink to a chroot.\n         */\n        const int containerized = (rootdir != NULL && strcmp(rootdir, \"/\") == 0);\n        if (containerized)\n        {\n            log_debug(\"Process %d is considered to be containerized\", pid);\n            pid_t container_pid;\n            if (get_pid_of_container(pid, &container_pid) == 0)\n            {\n                char *container_cmdline = get_cmdline(container_pid);\n                dd_save_text(dd, FILENAME_CONTAINER_CMDLINE, container_cmdline);\n                free(container_cmdline);\n            }\n        }\n\n        dd_save_text(dd, FILENAME_ANALYZER, \"abrt-ccpp\");\n        dd_save_text(dd, FILENAME_TYPE, \"CCpp\");\n        dd_save_text(dd, FILENAME_EXECUTABLE, executable);\n        dd_save_text(dd, FILENAME_PID, pid_str);\n        dd_save_text(dd, FILENAME_GLOBAL_PID, global_pid_str);\n        dd_save_text(dd, FILENAME_PROC_PID_STATUS, proc_pid_status);\n        if (user_pwd)\n            dd_save_text(dd, FILENAME_PWD, user_pwd);\n        if (tid_str)\n            dd_save_text(dd, FILENAME_TID, tid_str);\n\n        if (rootdir)\n        {\n            if (strcmp(rootdir, \"/\") != 0)\n                dd_save_text(dd, FILENAME_ROOTDIR, rootdir);\n        }\n        free(rootdir);\n\n        char *reason = xasprintf(\"%s killed by SIG%s\",\n                                 last_slash, signame ? signame : signal_str);\n        dd_save_text(dd, FILENAME_REASON, reason);\n        free(reason);\n\n        char *cmdline = get_cmdline(pid);\n        dd_save_text(dd, FILENAME_CMDLINE, cmdline ? : \"\");\n        free(cmdline);\n\n        char *environ = get_environ(pid);\n        dd_save_text(dd, FILENAME_ENVIRON, environ ? : \"\");\n        free(environ);\n\n        char *fips_enabled = xmalloc_fopen_fgetline_fclose(\"/proc/sys/crypto/fips_enabled\");\n        if (fips_enabled)\n        {\n            if (strcmp(fips_enabled, \"0\") != 0)\n                dd_save_text(dd, \"fips_enabled\", fips_enabled);\n            free(fips_enabled);\n        }\n\n        dd_save_text(dd, FILENAME_ABRT_VERSION, VERSION);\n\n        /* In case of errors, treat the process as if it has locked memory */\n        long unsigned lck_bytes = ULONG_MAX;\n        const char *vmlck = strstr(proc_pid_status, \"VmLck:\");\n        if (vmlck == NULL)\n            error_msg(\"/proc/%s/status does not contain 'VmLck:' line\", pid_str);\n        else if (1 != sscanf(vmlck + 6, \"%lu kB\\n\", &lck_bytes))\n            error_msg(\"Failed to parse 'VmLck:' line in /proc/%s/status\", pid_str);\n\n        if (lck_bytes)\n        {\n            log_notice(\"Process %s of user %lu has locked memory\",\n                        pid_str, (long unsigned)uid);\n\n            dd_mark_as_notreportable(dd, \"The process had locked memory \"\n                    \"which usually indicates efforts to protect sensitive \"\n                    \"data (passwords) from being written to disk.\\n\"\n                    \"In order to avoid sensitive information leakages, \"\n                    \"ABRT will not allow you to report this problem to \"\n                    \"bug tracking tools\");\n        }\n\n        if (setting_SaveBinaryImage)\n        {\n            if (save_crashing_binary(pid, dd))\n            {\n                error_msg(\"Error saving '%s'\", path);\n\n                goto cleanup_and_exit;\n            }\n        }\n\n        off_t core_size = 0;\n        if (setting_SaveFullCore)\n        {\n            strcpy(path + path_len, \"/\"FILENAME_COREDUMP);\n            int abrt_core_fd = create_or_die(path, user_core_fd);\n\n            /* We write both coredumps at once.\n             * We can't write user coredump first, since it might be truncated\n             * and thus can't be copied and used as abrt coredump;\n             * and if we write abrt coredump first and then copy it as user one,\n             * then we have a race when process exits but coredump does not exist yet:\n             * $ echo -e '#include<signal.h>\\nmain(){raise(SIGSEGV);}' | gcc -o test -x c -\n             * $ rm -f core*; ulimit -c unlimited; ./test; ls -l core*\n             * 21631 Segmentation fault (core dumped) ./test\n             * ls: cannot access core*: No such file or directory <=== BAD\n             */\n            core_size = copyfd_sparse(STDIN_FILENO, abrt_core_fd, user_core_fd, ulimit_c);\n            close_user_core(user_core_fd, core_size);\n            if (fsync(abrt_core_fd) != 0 || close(abrt_core_fd) != 0 || core_size < 0)\n            {\n                unlink(path);\n\n                /* copyfd_sparse logs the error including errno string,\n                 * but it does not log file name */\n                error_msg(\"Error writing '%s'\", path);\n\n                goto cleanup_and_exit;\n            }\n        }\n        else\n        {\n            /* User core is created even if WriteFullCore is off. */\n            create_user_core(user_core_fd, pid, ulimit_c);\n        }\n\n        /* User core is either written or closed */\n        user_core_fd = -1;\n\n        /*\n         * ! No other errors should cause removal of the user core !\n         */\n\n/* Because of #1211835 and #1126850 */\n#if 0\n        /* Save JVM crash log if it exists. (JVM's coredump per se\n         * is nearly useless for JVM developers)\n         */\n        {\n            char *java_log = xasprintf(\"/tmp/jvm-%lu/hs_error.log\", (long)pid);\n            int src_fd = open(java_log, O_RDONLY);\n            free(java_log);\n\n            /* If we couldn't open the error log in /tmp directory we can try to\n             * read the log from the current directory. It may produce AVC, it\n             * may produce some error log but all these are expected.\n             */\n            if (src_fd < 0)\n            {\n                java_log = xasprintf(\"%s/hs_err_pid%lu.log\", user_pwd, (long)pid);\n                src_fd = open(java_log, O_RDONLY);\n                free(java_log);\n            }\n\n            if (src_fd >= 0)\n            {\n                strcpy(path + path_len, \"/hs_err.log\");\n                int dst_fd = create_or_die(path, user_core_fd);\n                off_t sz = copyfd_eof(src_fd, dst_fd, COPYFD_SPARSE);\n                if (close(dst_fd) != 0 || sz < 0)\n                {\n                    error_msg(\"Error saving '%s'\", path);\n\n                    goto cleanup_and_exit;\n                }\n                close(src_fd);\n            }\n        }\n#endif\n\n        /* Perform crash-time unwind of the guilty thread. */\n        if (tid > 0 && setting_CreateCoreBacktrace)\n            create_core_backtrace(tid, executable, signal_no, dd);\n\n        /* We close dumpdir before we start catering for crash storm case.\n         * Otherwise, delete_dump_dir's from other concurrent\n         * CCpp's won't be able to delete our dump (their delete_dump_dir\n         * will wait for us), and we won't be able to delete their dumps.\n         * Classic deadlock.\n         */\n        dd_close(dd);\n        dd = NULL;\n\n        path[path_len] = '\\0'; /* path now contains only directory name */\n\n        if (abrtd_running && setting_SaveContainerizedPackageData && containerized)\n        {   /* Do we really need to run rpm from core_pattern hook? */\n            sprintf(source_filename, \"/proc/%lu/root\", (long)pid);\n\n            const char *cmd_args[6];\n            cmd_args[0] = BIN_DIR\"/abrt-action-save-package-data\";\n            cmd_args[1] = \"-d\";\n            cmd_args[2] = path;\n            cmd_args[3] = \"-r\";\n            cmd_args[4] = source_filename;\n            cmd_args[5] = NULL;\n\n            pid_t pid = fork_execv_on_steroids(0, (char **)cmd_args, NULL, NULL, path, 0);\n            int stat;\n            safe_waitpid(pid, &stat, 0);\n        }\n\n        char *newpath = xstrndup(path, path_len - (sizeof(\".new\")-1));\n        if (rename(path, newpath) == 0)\n            strcpy(path, newpath);\n        free(newpath);\n\n        if (core_size > 0)\n            log_notice(\"Saved core dump of pid %lu (%s) to %s (%llu bytes)\",\n                       (long)pid, executable, path, (long long)core_size);\n\n        if (abrtd_running)\n            notify_new_path(path);\n\n        /* rhbz#539551: \"abrt going crazy when crashing process is respawned\" */\n        if (g_settings_nMaxCrashReportsSize > 0)\n        {\n            /* x1.25 and round up to 64m: go a bit up, so that usual in-daemon trimming\n             * kicks in first, and we don't \"fight\" with it:\n             */\n            unsigned maxsize = g_settings_nMaxCrashReportsSize + g_settings_nMaxCrashReportsSize / 4;\n            maxsize |= 63;\n            trim_problem_dirs(g_settings_dump_location, maxsize * (double)(1024*1024), path);\n        }\n\n        err = 0;\n    }\n    else\n    {\n        /* We didn't create abrt dump, but may need to create compat coredump */\n        return create_user_core(user_core_fd, pid, ulimit_c);\n    }\n\ncleanup_and_exit:\n    if (dd)\n        dd_delete(dd);\n\n    if (user_core_fd >= 0)\n        unlinkat(dirfd(proc_cwd), core_basename, /*only files*/0);\n\n    if (proc_cwd != NULL)\n        closedir(proc_cwd);\n\n    return err;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -219,7 +219,8 @@\n         if (snprintf(path, sizeof(path), \"%s/%s-coredump\", g_settings_dump_location, last_slash) >= sizeof(path))\n             error_msg_and_die(\"Error saving '%s': truncated long file path\", path);\n \n-        int abrt_core_fd = xopen3(path, O_WRONLY | O_CREAT | O_TRUNC, 0600);\n+        unlink(path);\n+        int abrt_core_fd = xopen3(path, O_WRONLY | O_CREAT | O_EXCL, 0600);\n         off_t core_size = copyfd_eof(STDIN_FILENO, abrt_core_fd, COPYFD_SPARSE);\n         if (core_size < 0 || fsync(abrt_core_fd) != 0)\n         {",
        "diff_line_info": {
            "deleted_lines": [
                "        int abrt_core_fd = xopen3(path, O_WRONLY | O_CREAT | O_TRUNC, 0600);"
            ],
            "added_lines": [
                "        unlink(path);",
                "        int abrt_core_fd = xopen3(path, O_WRONLY | O_CREAT | O_EXCL, 0600);"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-7418",
        "func_name": "proftpd/get_default_root",
        "description": "ProFTPD before 1.3.5e and 1.3.6 before 1.3.6rc5 controls whether the home directory of a user could contain a symbolic link through the AllowChrootSymlinks configuration option, but checks only the last path component when enforcing AllowChrootSymlinks. Attackers with local access could bypass the AllowChrootSymlinks control by replacing a path component (other than the last one) with a symbolic link. The threat model includes an attacker who is not granted full filesystem access by a hosting provider, but can reconfigure the home directory of an FTP user.",
        "git_url": "https://github.com/proftpd/proftpd/commit/349addc3be4fcdad9bd4ec01ad1ccd916c898ed8",
        "commit_title": "Walk the entire DefaultRoot path, checking for symlinks of any component,",
        "commit_text": "when AllowChrootSymlinks is disabled.",
        "func_before": "static int get_default_root(pool *p, int allow_symlinks, const char **root) {\n  config_rec *c = NULL;\n  const char *dir = NULL;\n  int res;\n\n  c = find_config(main_server->conf, CONF_PARAM, \"DefaultRoot\", FALSE);\n  while (c != NULL) {\n    pr_signals_handle();\n\n    /* Check the groups acl */\n    if (c->argc < 2) {\n      dir = c->argv[0];\n      break;\n    }\n\n    res = pr_expr_eval_group_and(((char **) c->argv)+1);\n    if (res) {\n      dir = c->argv[0];\n      break;\n    }\n\n    c = find_config_next(c, c->next, CONF_PARAM, \"DefaultRoot\", FALSE);\n  }\n\n  if (dir != NULL) {\n    const char *new_dir;\n\n    /* Check for any expandable variables. */\n    new_dir = path_subst_uservar(p, &dir);\n    if (new_dir != NULL) {\n      dir = new_dir;\n    }\n\n    if (strncmp(dir, \"/\", 2) == 0) {\n      dir = NULL;\n\n    } else {\n      char *realdir;\n      int xerrno = 0;\n\n      if (allow_symlinks == FALSE) {\n        char *path, target_path[PR_TUNABLE_PATH_MAX + 1];\n        struct stat st;\n        size_t pathlen;\n\n        /* First, deal with any possible interpolation.  dir_realpath() will\n         * do this for us, but dir_realpath() ALSO automatically follows\n         * symlinks, which is what we do NOT want to do here.\n         */\n\n        path = pstrdup(p, dir);\n        if (*path != '/') {\n          if (*path == '~') {\n            if (pr_fs_interpolate(dir, target_path,\n                sizeof(target_path)-1) < 0) {\n              return -1;\n            }\n\n            path = target_path;\n          }\n        }\n\n        /* Note: lstat(2) is sensitive to the presence of a trailing slash on\n         * the path, particularly in the case of a symlink to a directory.\n         * Thus to get the correct test, we need to remove any trailing slash\n         * that might be present.  Subtle.\n         */\n        pathlen = strlen(path);\n        if (pathlen > 1 &&\n            path[pathlen-1] == '/') {\n          path[pathlen-1] = '\\0';\n        }\n\n        pr_fs_clear_cache2(path);\n        res = pr_fsio_lstat(path, &st);\n        if (res < 0) {\n          xerrno = errno;\n\n          pr_log_pri(PR_LOG_WARNING, \"error: unable to check %s: %s\", path,\n            strerror(xerrno));\n\n          errno = xerrno;\n          return -1;\n        }\n\n        if (S_ISLNK(st.st_mode)) {\n          pr_log_pri(PR_LOG_WARNING,\n            \"error: DefaultRoot %s is a symlink (denied by AllowChrootSymlinks \"\n            \"config)\", path);\n          errno = EPERM;\n          return -1;\n        }\n      }\n\n      /* We need to be the final user here so that if the user has their home\n       * directory with a mode the user proftpd is running (i.e. the User\n       * directive) as can not traverse down, we can still have the default\n       * root.\n       */\n\n      pr_fs_clear_cache2(dir);\n\n      PRIVS_USER\n      realdir = dir_realpath(p, dir);\n      xerrno = errno;\n      PRIVS_RELINQUISH\n\n      if (realdir) {\n        dir = realdir;\n\n      } else {\n        /* Try to provide a more informative message. */\n        char interp_dir[PR_TUNABLE_PATH_MAX + 1];\n\n        memset(interp_dir, '\\0', sizeof(interp_dir));\n        (void) pr_fs_interpolate(dir, interp_dir, sizeof(interp_dir)-1); \n\n        pr_log_pri(PR_LOG_NOTICE,\n          \"notice: unable to use DefaultRoot '%s' [resolved to '%s']: %s\",\n          dir, interp_dir, strerror(xerrno));\n\n        errno = xerrno;\n      }\n    }\n  }\n\n  *root = dir;\n  return 0;\n}",
        "func": "static int get_default_root(pool *p, int allow_symlinks, const char **root) {\n  config_rec *c = NULL;\n  const char *dir = NULL;\n  int res;\n\n  c = find_config(main_server->conf, CONF_PARAM, \"DefaultRoot\", FALSE);\n  while (c != NULL) {\n    pr_signals_handle();\n\n    /* Check the groups acl */\n    if (c->argc < 2) {\n      dir = c->argv[0];\n      break;\n    }\n\n    res = pr_expr_eval_group_and(((char **) c->argv)+1);\n    if (res) {\n      dir = c->argv[0];\n      break;\n    }\n\n    c = find_config_next(c, c->next, CONF_PARAM, \"DefaultRoot\", FALSE);\n  }\n\n  if (dir != NULL) {\n    const char *new_dir;\n\n    /* Check for any expandable variables. */\n    new_dir = path_subst_uservar(p, &dir);\n    if (new_dir != NULL) {\n      dir = new_dir;\n    }\n\n    if (strncmp(dir, \"/\", 2) == 0) {\n      dir = NULL;\n\n    } else {\n      char *realdir;\n      int xerrno = 0;\n\n      if (allow_symlinks == FALSE) {\n        char *path, target_path[PR_TUNABLE_PATH_MAX + 1];\n        size_t pathlen;\n\n        /* First, deal with any possible interpolation.  dir_realpath() will\n         * do this for us, but dir_realpath() ALSO automatically follows\n         * symlinks, which is what we do NOT want to do here.\n         */\n\n        path = pstrdup(p, dir);\n        if (*path != '/') {\n          if (*path == '~') {\n            if (pr_fs_interpolate(dir, target_path,\n                sizeof(target_path)-1) < 0) {\n              return -1;\n            }\n\n            path = target_path;\n          }\n        }\n\n        /* Note: lstat(2) is sensitive to the presence of a trailing slash on\n         * the path, particularly in the case of a symlink to a directory.\n         * Thus to get the correct test, we need to remove any trailing slash\n         * that might be present.  Subtle.\n         */\n        pathlen = strlen(path);\n        if (pathlen > 1 &&\n            path[pathlen-1] == '/') {\n          path[pathlen-1] = '\\0';\n        }\n\n        res = is_symlink_path(p, path, pathlen);\n        if (res < 0) {\n          if (errno == EPERM) {\n            pr_log_pri(PR_LOG_WARNING, \"error: DefaultRoot %s is a symlink \"\n              \"(denied by AllowChrootSymlinks config)\", path);\n          }\n\n          errno = EPERM;\n          return -1;\n        }\n      }\n\n      /* We need to be the final user here so that if the user has their home\n       * directory with a mode the user proftpd is running (i.e. the User\n       * directive) as can not traverse down, we can still have the default\n       * root.\n       */\n\n      pr_fs_clear_cache2(dir);\n\n      PRIVS_USER\n      realdir = dir_realpath(p, dir);\n      xerrno = errno;\n      PRIVS_RELINQUISH\n\n      if (realdir) {\n        dir = realdir;\n\n      } else {\n        /* Try to provide a more informative message. */\n        char interp_dir[PR_TUNABLE_PATH_MAX + 1];\n\n        memset(interp_dir, '\\0', sizeof(interp_dir));\n        (void) pr_fs_interpolate(dir, interp_dir, sizeof(interp_dir)-1); \n\n        pr_log_pri(PR_LOG_NOTICE,\n          \"notice: unable to use DefaultRoot '%s' [resolved to '%s']: %s\",\n          dir, interp_dir, strerror(xerrno));\n\n        errno = xerrno;\n      }\n    }\n  }\n\n  *root = dir;\n  return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -40,7 +40,6 @@\n \n       if (allow_symlinks == FALSE) {\n         char *path, target_path[PR_TUNABLE_PATH_MAX + 1];\n-        struct stat st;\n         size_t pathlen;\n \n         /* First, deal with any possible interpolation.  dir_realpath() will\n@@ -71,22 +70,13 @@\n           path[pathlen-1] = '\\0';\n         }\n \n-        pr_fs_clear_cache2(path);\n-        res = pr_fsio_lstat(path, &st);\n+        res = is_symlink_path(p, path, pathlen);\n         if (res < 0) {\n-          xerrno = errno;\n+          if (errno == EPERM) {\n+            pr_log_pri(PR_LOG_WARNING, \"error: DefaultRoot %s is a symlink \"\n+              \"(denied by AllowChrootSymlinks config)\", path);\n+          }\n \n-          pr_log_pri(PR_LOG_WARNING, \"error: unable to check %s: %s\", path,\n-            strerror(xerrno));\n-\n-          errno = xerrno;\n-          return -1;\n-        }\n-\n-        if (S_ISLNK(st.st_mode)) {\n-          pr_log_pri(PR_LOG_WARNING,\n-            \"error: DefaultRoot %s is a symlink (denied by AllowChrootSymlinks \"\n-            \"config)\", path);\n           errno = EPERM;\n           return -1;\n         }",
        "diff_line_info": {
            "deleted_lines": [
                "        struct stat st;",
                "        pr_fs_clear_cache2(path);",
                "        res = pr_fsio_lstat(path, &st);",
                "          xerrno = errno;",
                "          pr_log_pri(PR_LOG_WARNING, \"error: unable to check %s: %s\", path,",
                "            strerror(xerrno));",
                "",
                "          errno = xerrno;",
                "          return -1;",
                "        }",
                "",
                "        if (S_ISLNK(st.st_mode)) {",
                "          pr_log_pri(PR_LOG_WARNING,",
                "            \"error: DefaultRoot %s is a symlink (denied by AllowChrootSymlinks \"",
                "            \"config)\", path);"
            ],
            "added_lines": [
                "        res = is_symlink_path(p, path, pathlen);",
                "          if (errno == EPERM) {",
                "            pr_log_pri(PR_LOG_WARNING, \"error: DefaultRoot %s is a symlink \"",
                "              \"(denied by AllowChrootSymlinks config)\", path);",
                "          }"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-7418",
        "func_name": "proftpd/get_default_root",
        "description": "ProFTPD before 1.3.5e and 1.3.6 before 1.3.6rc5 controls whether the home directory of a user could contain a symbolic link through the AllowChrootSymlinks configuration option, but checks only the last path component when enforcing AllowChrootSymlinks. Attackers with local access could bypass the AllowChrootSymlinks control by replacing a path component (other than the last one) with a symbolic link. The threat model includes an attacker who is not granted full filesystem access by a hosting provider, but can reconfigure the home directory of an FTP user.",
        "git_url": "https://github.com/proftpd/proftpd/commit/ecff21e0d0e84f35c299ef91d7fda088e516d4ed",
        "commit_title": "Backporting recursive handling of DefaultRoot path, when AllowChrootSymlinks",
        "commit_text": "is off, to 1.3.5 branch.",
        "func_before": "static int get_default_root(pool *p, int allow_symlinks, char **root) {\n  config_rec *c = NULL;\n  char *dir = NULL;\n  int res;\n\n  c = find_config(main_server->conf, CONF_PARAM, \"DefaultRoot\", FALSE);\n  while (c) {\n    pr_signals_handle();\n\n    /* Check the groups acl */\n    if (c->argc < 2) {\n      dir = c->argv[0];\n      break;\n    }\n\n    res = pr_expr_eval_group_and(((char **) c->argv)+1);\n    if (res) {\n      dir = c->argv[0];\n      break;\n    }\n\n    c = find_config_next(c, c->next, CONF_PARAM, \"DefaultRoot\", FALSE);\n  }\n\n  if (dir) {\n    char *new_dir;\n\n    /* Check for any expandable variables. */\n    new_dir = path_subst_uservar(p, &dir);\n    if (new_dir != NULL) {\n      dir = new_dir;\n    }\n\n    if (strncmp(dir, \"/\", 2) == 0) {\n      dir = NULL;\n\n    } else {\n      char *realdir;\n      int xerrno = 0;\n\n      if (allow_symlinks == FALSE) {\n        char *path, target_path[PR_TUNABLE_PATH_MAX + 1];\n        struct stat st;\n        size_t pathlen;\n\n        /* First, deal with any possible interpolation.  dir_realpath() will\n         * do this for us, but dir_realpath() ALSO automatically follows\n         * symlinks, which is what we do NOT want to do here.\n         */\n\n        path = dir;\n        if (*path != '/') {\n          if (*path == '~') {\n            if (pr_fs_interpolate(dir, target_path,\n                sizeof(target_path)-1) < 0) {\n              return -1;\n            }\n\n            path = target_path;\n          }\n        }\n\n        /* Note: lstat(2) is sensitive to the presence of a trailing slash on\n         * the path, particularly in the case of a symlink to a directory.\n         * Thus to get the correct test, we need to remove any trailing slash\n         * that might be present.  Subtle.\n         */\n        pathlen = strlen(path);\n        if (pathlen > 1 &&\n            path[pathlen-1] == '/') {\n          path[pathlen-1] = '\\0';\n        }\n\n        pr_fs_clear_cache();\n        res = pr_fsio_lstat(path, &st);\n        if (res < 0) {\n          xerrno = errno;\n\n          pr_log_pri(PR_LOG_WARNING, \"error: unable to check %s: %s\", path,\n            strerror(xerrno));\n\n          errno = xerrno;\n          return -1;\n        }\n\n        if (S_ISLNK(st.st_mode)) {\n          pr_log_pri(PR_LOG_WARNING,\n            \"error: DefaultRoot %s is a symlink (denied by AllowChrootSymlinks \"\n            \"config)\", path);\n          errno = EPERM;\n          return -1;\n        }\n      }\n\n      /* We need to be the final user here so that if the user has their home\n       * directory with a mode the user proftpd is running (i.e. the User\n       * directive) as can not traverse down, we can still have the default\n       * root.\n       */\n\n      PRIVS_USER\n      realdir = dir_realpath(p, dir);\n      xerrno = errno;\n      PRIVS_RELINQUISH\n\n      if (realdir) {\n        dir = realdir;\n\n      } else {\n        /* Try to provide a more informative message. */\n        char interp_dir[PR_TUNABLE_PATH_MAX + 1];\n\n        memset(interp_dir, '\\0', sizeof(interp_dir));\n        (void) pr_fs_interpolate(dir, interp_dir, sizeof(interp_dir)-1); \n\n        pr_log_pri(PR_LOG_NOTICE,\n          \"notice: unable to use DefaultRoot '%s' [resolved to '%s']: %s\",\n          dir, interp_dir, strerror(xerrno));\n\n        errno = xerrno;\n      }\n    }\n  }\n\n  *root = dir;\n  return 0;\n}",
        "func": "static int get_default_root(pool *p, int allow_symlinks, char **root) {\n  config_rec *c = NULL;\n  char *dir = NULL;\n  int res;\n\n  c = find_config(main_server->conf, CONF_PARAM, \"DefaultRoot\", FALSE);\n  while (c) {\n    pr_signals_handle();\n\n    /* Check the groups acl */\n    if (c->argc < 2) {\n      dir = c->argv[0];\n      break;\n    }\n\n    res = pr_expr_eval_group_and(((char **) c->argv)+1);\n    if (res) {\n      dir = c->argv[0];\n      break;\n    }\n\n    c = find_config_next(c, c->next, CONF_PARAM, \"DefaultRoot\", FALSE);\n  }\n\n  if (dir) {\n    char *new_dir;\n\n    /* Check for any expandable variables. */\n    new_dir = path_subst_uservar(p, &dir);\n    if (new_dir != NULL) {\n      dir = new_dir;\n    }\n\n    if (strncmp(dir, \"/\", 2) == 0) {\n      dir = NULL;\n\n    } else {\n      char *realdir;\n      int xerrno = 0;\n\n      if (allow_symlinks == FALSE) {\n        char *path, target_path[PR_TUNABLE_PATH_MAX + 1];\n        size_t pathlen;\n\n        /* First, deal with any possible interpolation.  dir_realpath() will\n         * do this for us, but dir_realpath() ALSO automatically follows\n         * symlinks, which is what we do NOT want to do here.\n         */\n\n        path = dir;\n        if (*path != '/') {\n          if (*path == '~') {\n            if (pr_fs_interpolate(dir, target_path,\n                sizeof(target_path)-1) < 0) {\n              return -1;\n            }\n\n            path = target_path;\n          }\n        }\n\n        /* Note: lstat(2) is sensitive to the presence of a trailing slash on\n         * the path, particularly in the case of a symlink to a directory.\n         * Thus to get the correct test, we need to remove any trailing slash\n         * that might be present.  Subtle.\n         */\n        pathlen = strlen(path);\n        if (pathlen > 1 &&\n            path[pathlen-1] == '/') {\n          path[pathlen-1] = '\\0';\n        }\n\n        res = is_symlink_path(p, path, pathlen);\n        if (res < 0) {\n          if (errno == EPERM) {\n            pr_log_pri(PR_LOG_WARNING, \"error: DefaultRoot %s is a symlink \"\n              \"(denied by AllowChrootSymlinks config)\", path);\n          }\n\n          errno = EPERM;\n          return -1;\n        }\n      }\n\n      /* We need to be the final user here so that if the user has their home\n       * directory with a mode the user proftpd is running (i.e. the User\n       * directive) as can not traverse down, we can still have the default\n       * root.\n       */\n\n      PRIVS_USER\n      realdir = dir_realpath(p, dir);\n      xerrno = errno;\n      PRIVS_RELINQUISH\n\n      if (realdir) {\n        dir = realdir;\n\n      } else {\n        /* Try to provide a more informative message. */\n        char interp_dir[PR_TUNABLE_PATH_MAX + 1];\n\n        memset(interp_dir, '\\0', sizeof(interp_dir));\n        (void) pr_fs_interpolate(dir, interp_dir, sizeof(interp_dir)-1); \n\n        pr_log_pri(PR_LOG_NOTICE,\n          \"notice: unable to use DefaultRoot '%s' [resolved to '%s']: %s\",\n          dir, interp_dir, strerror(xerrno));\n\n        errno = xerrno;\n      }\n    }\n  }\n\n  *root = dir;\n  return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -40,7 +40,6 @@\n \n       if (allow_symlinks == FALSE) {\n         char *path, target_path[PR_TUNABLE_PATH_MAX + 1];\n-        struct stat st;\n         size_t pathlen;\n \n         /* First, deal with any possible interpolation.  dir_realpath() will\n@@ -71,22 +70,13 @@\n           path[pathlen-1] = '\\0';\n         }\n \n-        pr_fs_clear_cache();\n-        res = pr_fsio_lstat(path, &st);\n+        res = is_symlink_path(p, path, pathlen);\n         if (res < 0) {\n-          xerrno = errno;\n+          if (errno == EPERM) {\n+            pr_log_pri(PR_LOG_WARNING, \"error: DefaultRoot %s is a symlink \"\n+              \"(denied by AllowChrootSymlinks config)\", path);\n+          }\n \n-          pr_log_pri(PR_LOG_WARNING, \"error: unable to check %s: %s\", path,\n-            strerror(xerrno));\n-\n-          errno = xerrno;\n-          return -1;\n-        }\n-\n-        if (S_ISLNK(st.st_mode)) {\n-          pr_log_pri(PR_LOG_WARNING,\n-            \"error: DefaultRoot %s is a symlink (denied by AllowChrootSymlinks \"\n-            \"config)\", path);\n           errno = EPERM;\n           return -1;\n         }",
        "diff_line_info": {
            "deleted_lines": [
                "        struct stat st;",
                "        pr_fs_clear_cache();",
                "        res = pr_fsio_lstat(path, &st);",
                "          xerrno = errno;",
                "          pr_log_pri(PR_LOG_WARNING, \"error: unable to check %s: %s\", path,",
                "            strerror(xerrno));",
                "",
                "          errno = xerrno;",
                "          return -1;",
                "        }",
                "",
                "        if (S_ISLNK(st.st_mode)) {",
                "          pr_log_pri(PR_LOG_WARNING,",
                "            \"error: DefaultRoot %s is a symlink (denied by AllowChrootSymlinks \"",
                "            \"config)\", path);"
            ],
            "added_lines": [
                "        res = is_symlink_path(p, path, pathlen);",
                "          if (errno == EPERM) {",
                "            pr_log_pri(PR_LOG_WARNING, \"error: DefaultRoot %s is a symlink \"",
                "              \"(denied by AllowChrootSymlinks config)\", path);",
                "          }"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-7500",
        "func_name": "rpm-software-management/rpm/fsmVerify",
        "description": "It was found that rpm did not properly handle RPM installations when a destination path was a symbolic link to a directory, possibly changing ownership and permissions of an arbitrary directory, and RPM files being placed in an arbitrary destination. An attacker, with write access to a directory in which a subdirectory will be installed, could redirect that directory to an arbitrary location and gain root privilege.",
        "git_url": "https://github.com/rpm-software-management/rpm/commit/f2d3be2a8741234faaa96f5fd05fdfdc75779a79",
        "commit_title": "Restrict following symlinks to directories by ownership (CVE-2017-7500)",
        "commit_text": " Only follow directory symlinks owned by target directory owner or root. This prevents privilege escalation from user-writable directories via directory symlinks to privileged directories on package upgrade, while still allowing admin to arrange disk usage with symlinks.  The rationale is that if you can create symlinks owned by user X you *are* user X (or root), and if you also own directory Y you can do whatever with it already, including change permissions. So when you create a symlink to that directory, the link ownership acts as a simple stamp of authority that you indeed want rpm to treat this symlink as it were the directory that you own. Such a permission can only be given by you or root, which is just the way we want it. Plus it's almost ridiculously simple as far as rules go, compared to trying to calculate something from the source vs destination directory permissions etc.  In the normal case, the user arranging diskspace with symlinks is indeed root so nothing changes, the only real change here is to links created by non-privileged users which should be few and far between in practise. Unfortunately our test-suite runs as a regular user via fakechroot and thus the testcase for this fails under the new rules. Adjust the testcase to get the ownership straight and add a second case for the illegal behavior, basically the same as the old one but with different expectations.",
        "func_before": "static int fsmVerify(const char *path, rpmfi fi)\n{\n    int rc;\n    int saveerrno = errno;\n    struct stat dsb;\n    mode_t mode = rpmfiFMode(fi);\n\n    rc = fsmStat(path, 1, &dsb);\n    if (rc)\n\treturn rc;\n\n    if (S_ISREG(mode)) {\n\t/* HP-UX (and other os'es) don't permit unlink on busy files. */\n\tchar *rmpath = rstrscat(NULL, path, \"-RPMDELETE\", NULL);\n\trc = fsmRename(path, rmpath);\n\t/* XXX shouldn't we take unlink return code here? */\n\tif (!rc)\n\t    (void) fsmUnlink(rmpath);\n\telse\n\t    rc = RPMERR_UNLINK_FAILED;\n\tfree(rmpath);\n        return (rc ? rc : RPMERR_ENOENT);\t/* XXX HACK */\n    } else if (S_ISDIR(mode)) {\n        if (S_ISDIR(dsb.st_mode)) return 0;\n        if (S_ISLNK(dsb.st_mode)) {\n            rc = fsmStat(path, 0, &dsb);\n            if (rc == RPMERR_ENOENT) rc = 0;\n            if (rc) return rc;\n            errno = saveerrno;\n            if (S_ISDIR(dsb.st_mode)) return 0;\n        }\n    } else if (S_ISLNK(mode)) {\n        if (S_ISLNK(dsb.st_mode)) {\n            char buf[8 * BUFSIZ];\n            size_t len;\n            rc = fsmReadLink(path, buf, 8 * BUFSIZ, &len);\n            errno = saveerrno;\n            if (rc) return rc;\n            if (rstreq(rpmfiFLink(fi), buf)) return 0;\n        }\n    } else if (S_ISFIFO(mode)) {\n        if (S_ISFIFO(dsb.st_mode)) return 0;\n    } else if (S_ISCHR(mode) || S_ISBLK(mode)) {\n        if ((S_ISCHR(dsb.st_mode) || S_ISBLK(dsb.st_mode)) &&\n            (dsb.st_rdev == rpmfiFRdev(fi))) return 0;\n    } else if (S_ISSOCK(mode)) {\n        if (S_ISSOCK(dsb.st_mode)) return 0;\n    }\n    /* XXX shouldn't do this with commit/undo. */\n    rc = fsmUnlink(path);\n    if (rc == 0)\trc = RPMERR_ENOENT;\n    return (rc ? rc : RPMERR_ENOENT);\t/* XXX HACK */\n}",
        "func": "static int fsmVerify(const char *path, rpmfi fi, const struct stat *fsb)\n{\n    int rc;\n    int saveerrno = errno;\n    struct stat dsb;\n    mode_t mode = rpmfiFMode(fi);\n\n    rc = fsmStat(path, 1, &dsb);\n    if (rc)\n\treturn rc;\n\n    if (S_ISREG(mode)) {\n\t/* HP-UX (and other os'es) don't permit unlink on busy files. */\n\tchar *rmpath = rstrscat(NULL, path, \"-RPMDELETE\", NULL);\n\trc = fsmRename(path, rmpath);\n\t/* XXX shouldn't we take unlink return code here? */\n\tif (!rc)\n\t    (void) fsmUnlink(rmpath);\n\telse\n\t    rc = RPMERR_UNLINK_FAILED;\n\tfree(rmpath);\n        return (rc ? rc : RPMERR_ENOENT);\t/* XXX HACK */\n    } else if (S_ISDIR(mode)) {\n        if (S_ISDIR(dsb.st_mode)) return 0;\n        if (S_ISLNK(dsb.st_mode)) {\n\t    uid_t luid = dsb.st_uid;\n            rc = fsmStat(path, 0, &dsb);\n            if (rc == RPMERR_ENOENT) rc = 0;\n            if (rc) return rc;\n            errno = saveerrno;\n\t    /* Only permit directory symlinks by target owner and root */\n            if (S_ISDIR(dsb.st_mode) && (luid == 0 || luid == fsb->st_uid))\n\t\t    return 0;\n        }\n    } else if (S_ISLNK(mode)) {\n        if (S_ISLNK(dsb.st_mode)) {\n            char buf[8 * BUFSIZ];\n            size_t len;\n            rc = fsmReadLink(path, buf, 8 * BUFSIZ, &len);\n            errno = saveerrno;\n            if (rc) return rc;\n            if (rstreq(rpmfiFLink(fi), buf)) return 0;\n        }\n    } else if (S_ISFIFO(mode)) {\n        if (S_ISFIFO(dsb.st_mode)) return 0;\n    } else if (S_ISCHR(mode) || S_ISBLK(mode)) {\n        if ((S_ISCHR(dsb.st_mode) || S_ISBLK(dsb.st_mode)) &&\n            (dsb.st_rdev == rpmfiFRdev(fi))) return 0;\n    } else if (S_ISSOCK(mode)) {\n        if (S_ISSOCK(dsb.st_mode)) return 0;\n    }\n    /* XXX shouldn't do this with commit/undo. */\n    rc = fsmUnlink(path);\n    if (rc == 0)\trc = RPMERR_ENOENT;\n    return (rc ? rc : RPMERR_ENOENT);\t/* XXX HACK */\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,4 @@\n-static int fsmVerify(const char *path, rpmfi fi)\n+static int fsmVerify(const char *path, rpmfi fi, const struct stat *fsb)\n {\n     int rc;\n     int saveerrno = errno;\n@@ -23,11 +23,14 @@\n     } else if (S_ISDIR(mode)) {\n         if (S_ISDIR(dsb.st_mode)) return 0;\n         if (S_ISLNK(dsb.st_mode)) {\n+\t    uid_t luid = dsb.st_uid;\n             rc = fsmStat(path, 0, &dsb);\n             if (rc == RPMERR_ENOENT) rc = 0;\n             if (rc) return rc;\n             errno = saveerrno;\n-            if (S_ISDIR(dsb.st_mode)) return 0;\n+\t    /* Only permit directory symlinks by target owner and root */\n+            if (S_ISDIR(dsb.st_mode) && (luid == 0 || luid == fsb->st_uid))\n+\t\t    return 0;\n         }\n     } else if (S_ISLNK(mode)) {\n         if (S_ISLNK(dsb.st_mode)) {",
        "diff_line_info": {
            "deleted_lines": [
                "static int fsmVerify(const char *path, rpmfi fi)",
                "            if (S_ISDIR(dsb.st_mode)) return 0;"
            ],
            "added_lines": [
                "static int fsmVerify(const char *path, rpmfi fi, const struct stat *fsb)",
                "\t    uid_t luid = dsb.st_uid;",
                "\t    /* Only permit directory symlinks by target owner and root */",
                "            if (S_ISDIR(dsb.st_mode) && (luid == 0 || luid == fsb->st_uid))",
                "\t\t    return 0;"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-7500",
        "func_name": "rpm-software-management/rpm/rpmPackageFilesInstall",
        "description": "It was found that rpm did not properly handle RPM installations when a destination path was a symbolic link to a directory, possibly changing ownership and permissions of an arbitrary directory, and RPM files being placed in an arbitrary destination. An attacker, with write access to a directory in which a subdirectory will be installed, could redirect that directory to an arbitrary location and gain root privilege.",
        "git_url": "https://github.com/rpm-software-management/rpm/commit/f2d3be2a8741234faaa96f5fd05fdfdc75779a79",
        "commit_title": "Restrict following symlinks to directories by ownership (CVE-2017-7500)",
        "commit_text": " Only follow directory symlinks owned by target directory owner or root. This prevents privilege escalation from user-writable directories via directory symlinks to privileged directories on package upgrade, while still allowing admin to arrange disk usage with symlinks.  The rationale is that if you can create symlinks owned by user X you *are* user X (or root), and if you also own directory Y you can do whatever with it already, including change permissions. So when you create a symlink to that directory, the link ownership acts as a simple stamp of authority that you indeed want rpm to treat this symlink as it were the directory that you own. Such a permission can only be given by you or root, which is just the way we want it. Plus it's almost ridiculously simple as far as rules go, compared to trying to calculate something from the source vs destination directory permissions etc.  In the normal case, the user arranging diskspace with symlinks is indeed root so nothing changes, the only real change here is to links created by non-privileged users which should be few and far between in practise. Unfortunately our test-suite runs as a regular user via fakechroot and thus the testcase for this fails under the new rules. Adjust the testcase to get the ownership straight and add a second case for the illegal behavior, basically the same as the old one but with different expectations.",
        "func_before": "int rpmPackageFilesInstall(rpmts ts, rpmte te, rpmfiles files,\n              rpmpsm psm, char ** failedFile)\n{\n    FD_t payload = rpmtePayload(te);\n    rpmfi fi = rpmfiNewArchiveReader(payload, files, RPMFI_ITER_READ_ARCHIVE);\n    rpmfs fs = rpmteGetFileStates(te);\n    rpmPlugins plugins = rpmtsPlugins(ts);\n    struct stat sb;\n    int saveerrno = errno;\n    int rc = 0;\n    int nodigest = (rpmtsFlags(ts) & RPMTRANS_FLAG_NOFILEDIGEST) ? 1 : 0;\n    int nofcaps = (rpmtsFlags(ts) & RPMTRANS_FLAG_NOCAPS) ? 1 : 0;\n    int firsthardlink = -1;\n    int skip;\n    rpmFileAction action;\n    char *tid = NULL;\n    const char *suffix;\n    char *fpath = NULL;\n\n    if (fi == NULL) {\n\trc = RPMERR_BAD_MAGIC;\n\tgoto exit;\n    }\n\n    /* transaction id used for temporary path suffix while installing */\n    rasprintf(&tid, \";%08x\", (unsigned)rpmtsGetTid(ts));\n\n    /* Detect and create directories not explicitly in package. */\n    rc = fsmMkdirs(files, fs, plugins);\n\n    while (!rc) {\n\t/* Read next payload header. */\n\trc = rpmfiNext(fi);\n\n\tif (rc < 0) {\n\t    if (rc == RPMERR_ITER_END)\n\t\trc = 0;\n\t    break;\n\t}\n\n\taction = rpmfsGetAction(fs, rpmfiFX(fi));\n\tskip = XFA_SKIPPING(action);\n\tsuffix = S_ISDIR(rpmfiFMode(fi)) ? NULL : tid;\n\tif (action != FA_TOUCH) {\n\t    fpath = fsmFsPath(fi, suffix);\n\t} else {\n\t    fpath = fsmFsPath(fi, \"\");\n\t}\n\n\t/* Remap file perms, owner, and group. */\n\trc = rpmfiStat(fi, 1, &sb);\n\n\tfsmDebug(fpath, action, &sb);\n\n        /* Exit on error. */\n        if (rc)\n            break;\n\n\t/* Run fsm file pre hook for all plugins */\n\trc = rpmpluginsCallFsmFilePre(plugins, fi, fpath,\n\t\t\t\t      sb.st_mode, action);\n\tif (rc) {\n\t    skip = 1;\n\t} else {\n\t    setFileState(fs, rpmfiFX(fi));\n\t}\n\n        if (!skip) {\n\t    int setmeta = 1;\n\n\t    /* Directories replacing something need early backup */\n\t    if (!suffix) {\n\t\trc = fsmBackup(fi, action);\n\t    }\n\t    /* Assume file does't exist when tmp suffix is in use */\n\t    if (!suffix) {\n\t\trc = fsmVerify(fpath, fi);\n\t    } else {\n\t\trc = (action == FA_TOUCH) ? 0 : RPMERR_ENOENT;\n\t    }\n\n            if (S_ISREG(sb.st_mode)) {\n\t\tif (rc == RPMERR_ENOENT) {\n\t\t    rc = fsmMkfile(fi, fpath, files, psm, nodigest,\n\t\t\t\t   &setmeta, &firsthardlink);\n\t\t}\n            } else if (S_ISDIR(sb.st_mode)) {\n                if (rc == RPMERR_ENOENT) {\n                    mode_t mode = sb.st_mode;\n                    mode &= ~07777;\n                    mode |=  00700;\n                    rc = fsmMkdir(fpath, mode);\n                }\n            } else if (S_ISLNK(sb.st_mode)) {\n\t\tif (rc == RPMERR_ENOENT) {\n\t\t    rc = fsmSymlink(rpmfiFLink(fi), fpath);\n\t\t}\n            } else if (S_ISFIFO(sb.st_mode)) {\n                /* This mimics cpio S_ISSOCK() behavior but probably isn't right */\n                if (rc == RPMERR_ENOENT) {\n                    rc = fsmMkfifo(fpath, 0000);\n                }\n            } else if (S_ISCHR(sb.st_mode) ||\n                       S_ISBLK(sb.st_mode) ||\n                       S_ISSOCK(sb.st_mode))\n            {\n                if (rc == RPMERR_ENOENT) {\n                    rc = fsmMknod(fpath, sb.st_mode, sb.st_rdev);\n                }\n            } else {\n                /* XXX Special case /dev/log, which shouldn't be packaged anyways */\n                if (!IS_DEV_LOG(fpath))\n                    rc = RPMERR_UNKNOWN_FILETYPE;\n            }\n\t    /* Set permissions, timestamps etc for non-hardlink entries */\n\t    if (!rc && setmeta) {\n\t\trc = fsmSetmeta(fpath, fi, plugins, action, &sb, nofcaps);\n\t    }\n        } else if (firsthardlink >= 0 && rpmfiArchiveHasContent(fi)) {\n\t    /* we skip the hard linked file containing the content */\n\t    /* write the content to the first used instead */\n\t    char *fn = rpmfilesFN(files, firsthardlink);\n\t    rc = expandRegular(fi, fn, psm, 0, nodigest, 0);\n\t    firsthardlink = -1;\n\t    free(fn);\n\t}\n\n        if (rc) {\n            if (!skip) {\n                /* XXX only erase if temp fn w suffix is in use */\n                if (suffix && (action != FA_TOUCH)) {\n\t\t    (void) fsmRemove(fpath, sb.st_mode);\n                }\n                errno = saveerrno;\n            }\n        } else {\n\t    /* Notify on success. */\n\t    rpmpsmNotify(psm, RPMCALLBACK_INST_PROGRESS, rpmfiArchiveTell(fi));\n\n\t    if (!skip) {\n\t\t/* Backup file if needed. Directories are handled earlier */\n\t\tif (suffix)\n\t\t    rc = fsmBackup(fi, action);\n\n\t\tif (!rc)\n\t\t    rc = fsmCommit(&fpath, fi, action, suffix);\n\t    }\n\t}\n\n\tif (rc)\n\t    *failedFile = xstrdup(fpath);\n\n\t/* Run fsm file post hook for all plugins */\n\trpmpluginsCallFsmFilePost(plugins, fi, fpath,\n\t\t\t\t  sb.st_mode, action, rc);\n\tfpath = _free(fpath);\n    }\n\n    rpmswAdd(rpmtsOp(ts, RPMTS_OP_UNCOMPRESS), fdOp(payload, FDSTAT_READ));\n    rpmswAdd(rpmtsOp(ts, RPMTS_OP_DIGEST), fdOp(payload, FDSTAT_DIGEST));\n\nexit:\n\n    /* No need to bother with close errors on read */\n    rpmfiArchiveClose(fi);\n    rpmfiFree(fi);\n    Fclose(payload);\n    free(tid);\n    free(fpath);\n\n    return rc;\n}",
        "func": "int rpmPackageFilesInstall(rpmts ts, rpmte te, rpmfiles files,\n              rpmpsm psm, char ** failedFile)\n{\n    FD_t payload = rpmtePayload(te);\n    rpmfi fi = rpmfiNewArchiveReader(payload, files, RPMFI_ITER_READ_ARCHIVE);\n    rpmfs fs = rpmteGetFileStates(te);\n    rpmPlugins plugins = rpmtsPlugins(ts);\n    struct stat sb;\n    int saveerrno = errno;\n    int rc = 0;\n    int nodigest = (rpmtsFlags(ts) & RPMTRANS_FLAG_NOFILEDIGEST) ? 1 : 0;\n    int nofcaps = (rpmtsFlags(ts) & RPMTRANS_FLAG_NOCAPS) ? 1 : 0;\n    int firsthardlink = -1;\n    int skip;\n    rpmFileAction action;\n    char *tid = NULL;\n    const char *suffix;\n    char *fpath = NULL;\n\n    if (fi == NULL) {\n\trc = RPMERR_BAD_MAGIC;\n\tgoto exit;\n    }\n\n    /* transaction id used for temporary path suffix while installing */\n    rasprintf(&tid, \";%08x\", (unsigned)rpmtsGetTid(ts));\n\n    /* Detect and create directories not explicitly in package. */\n    rc = fsmMkdirs(files, fs, plugins);\n\n    while (!rc) {\n\t/* Read next payload header. */\n\trc = rpmfiNext(fi);\n\n\tif (rc < 0) {\n\t    if (rc == RPMERR_ITER_END)\n\t\trc = 0;\n\t    break;\n\t}\n\n\taction = rpmfsGetAction(fs, rpmfiFX(fi));\n\tskip = XFA_SKIPPING(action);\n\tsuffix = S_ISDIR(rpmfiFMode(fi)) ? NULL : tid;\n\tif (action != FA_TOUCH) {\n\t    fpath = fsmFsPath(fi, suffix);\n\t} else {\n\t    fpath = fsmFsPath(fi, \"\");\n\t}\n\n\t/* Remap file perms, owner, and group. */\n\trc = rpmfiStat(fi, 1, &sb);\n\n\tfsmDebug(fpath, action, &sb);\n\n        /* Exit on error. */\n        if (rc)\n            break;\n\n\t/* Run fsm file pre hook for all plugins */\n\trc = rpmpluginsCallFsmFilePre(plugins, fi, fpath,\n\t\t\t\t      sb.st_mode, action);\n\tif (rc) {\n\t    skip = 1;\n\t} else {\n\t    setFileState(fs, rpmfiFX(fi));\n\t}\n\n        if (!skip) {\n\t    int setmeta = 1;\n\n\t    /* Directories replacing something need early backup */\n\t    if (!suffix) {\n\t\trc = fsmBackup(fi, action);\n\t    }\n\t    /* Assume file does't exist when tmp suffix is in use */\n\t    if (!suffix) {\n\t\trc = fsmVerify(fpath, fi, &sb);\n\t    } else {\n\t\trc = (action == FA_TOUCH) ? 0 : RPMERR_ENOENT;\n\t    }\n\n            if (S_ISREG(sb.st_mode)) {\n\t\tif (rc == RPMERR_ENOENT) {\n\t\t    rc = fsmMkfile(fi, fpath, files, psm, nodigest,\n\t\t\t\t   &setmeta, &firsthardlink);\n\t\t}\n            } else if (S_ISDIR(sb.st_mode)) {\n                if (rc == RPMERR_ENOENT) {\n                    mode_t mode = sb.st_mode;\n                    mode &= ~07777;\n                    mode |=  00700;\n                    rc = fsmMkdir(fpath, mode);\n                }\n            } else if (S_ISLNK(sb.st_mode)) {\n\t\tif (rc == RPMERR_ENOENT) {\n\t\t    rc = fsmSymlink(rpmfiFLink(fi), fpath);\n\t\t}\n            } else if (S_ISFIFO(sb.st_mode)) {\n                /* This mimics cpio S_ISSOCK() behavior but probably isn't right */\n                if (rc == RPMERR_ENOENT) {\n                    rc = fsmMkfifo(fpath, 0000);\n                }\n            } else if (S_ISCHR(sb.st_mode) ||\n                       S_ISBLK(sb.st_mode) ||\n                       S_ISSOCK(sb.st_mode))\n            {\n                if (rc == RPMERR_ENOENT) {\n                    rc = fsmMknod(fpath, sb.st_mode, sb.st_rdev);\n                }\n            } else {\n                /* XXX Special case /dev/log, which shouldn't be packaged anyways */\n                if (!IS_DEV_LOG(fpath))\n                    rc = RPMERR_UNKNOWN_FILETYPE;\n            }\n\t    /* Set permissions, timestamps etc for non-hardlink entries */\n\t    if (!rc && setmeta) {\n\t\trc = fsmSetmeta(fpath, fi, plugins, action, &sb, nofcaps);\n\t    }\n        } else if (firsthardlink >= 0 && rpmfiArchiveHasContent(fi)) {\n\t    /* we skip the hard linked file containing the content */\n\t    /* write the content to the first used instead */\n\t    char *fn = rpmfilesFN(files, firsthardlink);\n\t    rc = expandRegular(fi, fn, psm, 0, nodigest, 0);\n\t    firsthardlink = -1;\n\t    free(fn);\n\t}\n\n        if (rc) {\n            if (!skip) {\n                /* XXX only erase if temp fn w suffix is in use */\n                if (suffix && (action != FA_TOUCH)) {\n\t\t    (void) fsmRemove(fpath, sb.st_mode);\n                }\n                errno = saveerrno;\n            }\n        } else {\n\t    /* Notify on success. */\n\t    rpmpsmNotify(psm, RPMCALLBACK_INST_PROGRESS, rpmfiArchiveTell(fi));\n\n\t    if (!skip) {\n\t\t/* Backup file if needed. Directories are handled earlier */\n\t\tif (suffix)\n\t\t    rc = fsmBackup(fi, action);\n\n\t\tif (!rc)\n\t\t    rc = fsmCommit(&fpath, fi, action, suffix);\n\t    }\n\t}\n\n\tif (rc)\n\t    *failedFile = xstrdup(fpath);\n\n\t/* Run fsm file post hook for all plugins */\n\trpmpluginsCallFsmFilePost(plugins, fi, fpath,\n\t\t\t\t  sb.st_mode, action, rc);\n\tfpath = _free(fpath);\n    }\n\n    rpmswAdd(rpmtsOp(ts, RPMTS_OP_UNCOMPRESS), fdOp(payload, FDSTAT_READ));\n    rpmswAdd(rpmtsOp(ts, RPMTS_OP_DIGEST), fdOp(payload, FDSTAT_DIGEST));\n\nexit:\n\n    /* No need to bother with close errors on read */\n    rpmfiArchiveClose(fi);\n    rpmfiFree(fi);\n    Fclose(payload);\n    free(tid);\n    free(fpath);\n\n    return rc;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -74,7 +74,7 @@\n \t    }\n \t    /* Assume file does't exist when tmp suffix is in use */\n \t    if (!suffix) {\n-\t\trc = fsmVerify(fpath, fi);\n+\t\trc = fsmVerify(fpath, fi, &sb);\n \t    } else {\n \t\trc = (action == FA_TOUCH) ? 0 : RPMERR_ENOENT;\n \t    }",
        "diff_line_info": {
            "deleted_lines": [
                "\t\trc = fsmVerify(fpath, fi);"
            ],
            "added_lines": [
                "\t\trc = fsmVerify(fpath, fi, &sb);"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-7500",
        "func_name": "rpm-software-management/rpm/rpmfilesVerify",
        "description": "It was found that rpm did not properly handle RPM installations when a destination path was a symbolic link to a directory, possibly changing ownership and permissions of an arbitrary directory, and RPM files being placed in an arbitrary destination. An attacker, with write access to a directory in which a subdirectory will be installed, could redirect that directory to an arbitrary location and gain root privilege.",
        "git_url": "https://github.com/rpm-software-management/rpm/commit/c815822c8bdb138066ff58c624ae83e3a12ebfa9",
        "commit_title": "Make verification match the new restricted directory symlink behavior",
        "commit_text": " Only follow directory symlinks owned by target directory owner or root during verification to match the behavior of fsmVerify() in the new CVE-2017-7500 world order.  The code is klunkier than it should and the logic should use common code with fsmVerify() instead of duplicating it here, but that needs more changes than is comfortable to backport so starting with this.  Also worth noting that the previous \"follow the link\" logic from commit 3ccd774255b8215733e0bdfdf5a683da9dd10923 was not quite right, it'd fail with RPMVERIFY_LSTATFAIL on a broken symlink when it should've ran verification on the symlink itself. This behavior is fixed here too.  Finally, once again fakechroot gets in the way and forces the related verify testcase to be changed to be able to create a valid link. Reuse the replacement testcase for the purpose and add another case for verifying an invalid link.",
        "func_before": "rpmVerifyAttrs rpmfilesVerify(rpmfiles fi, int ix, rpmVerifyAttrs omitMask)\n{\n    rpm_mode_t fmode = rpmfilesFMode(fi, ix);\n    rpmfileAttrs fileAttrs = rpmfilesFFlags(fi, ix);\n    rpmVerifyAttrs flags = rpmfilesVFlags(fi, ix);\n    const char * fn = rpmfilesFN(fi, ix);\n    struct stat sb;\n    rpmVerifyAttrs vfy = RPMVERIFY_NONE;\n\n    /*\n     * Check to see if the file was installed - if not pretend all is OK.\n     */\n    switch (rpmfilesFState(fi, ix)) {\n    case RPMFILE_STATE_NETSHARED:\n    case RPMFILE_STATE_NOTINSTALLED:\n\tgoto exit;\n\tbreak;\n    case RPMFILE_STATE_REPLACED:\n\t/* For replaced files we can only verify if it exists at all */\n\tflags = RPMVERIFY_LSTATFAIL;\n\tbreak;\n    case RPMFILE_STATE_WRONGCOLOR:\n\t/*\n\t * Files with wrong color are supposed to share some attributes\n\t * with the actually installed file - verify what we can.\n\t */\n\tflags &= ~(RPMVERIFY_FILEDIGEST | RPMVERIFY_FILESIZE |\n\t\t   RPMVERIFY_MTIME | RPMVERIFY_RDEV);\n\tbreak;\n    case RPMFILE_STATE_NORMAL:\n    /* File from a non-installed package, try to verify nevertheless */\n    case RPMFILE_STATE_MISSING:\n\tbreak;\n    }\n\n    if (fn == NULL || lstat(fn, &sb) != 0) {\n\tvfy |= RPMVERIFY_LSTATFAIL;\n\tgoto exit;\n    }\n\n    /* If we expected a directory but got a symlink to one, follow the link */\n    if (S_ISDIR(fmode) && S_ISLNK(sb.st_mode) && stat(fn, &sb) != 0) {\n\tvfy |= RPMVERIFY_LSTATFAIL;\n\tgoto exit;\n    }\n\n    /* Links have no mode, other types have no linkto */\n    if (S_ISLNK(sb.st_mode))\n\tflags &= ~(RPMVERIFY_MODE);\n    else\n\tflags &= ~(RPMVERIFY_LINKTO);\n\n    /* Not all attributes of non-regular files can be verified */\n    if (!S_ISREG(sb.st_mode))\n\tflags &= ~(RPMVERIFY_FILEDIGEST | RPMVERIFY_FILESIZE |\n\t\t   RPMVERIFY_MTIME | RPMVERIFY_CAPS);\n\n    /* Content checks of %ghost files are meaningless. */\n    if (fileAttrs & RPMFILE_GHOST)\n\tflags &= ~(RPMVERIFY_FILEDIGEST | RPMVERIFY_FILESIZE |\n\t\t   RPMVERIFY_MTIME | RPMVERIFY_LINKTO);\n\n    /* Don't verify any features in omitMask. */\n    flags &= ~(omitMask | RPMVERIFY_FAILURES);\n\n\n    if (flags & RPMVERIFY_FILEDIGEST) {\n\tconst unsigned char *digest; \n\tint algo;\n\tsize_t diglen;\n\n\t/* XXX If --nomd5, then prelinked library sizes are not corrected. */\n\tif ((digest = rpmfilesFDigest(fi, ix, &algo, &diglen))) {\n\t    unsigned char fdigest[diglen];\n\t    rpm_loff_t fsize;\n\n\t    if (rpmDoDigest(algo, fn, 0, fdigest, &fsize)) {\n\t\tvfy |= (RPMVERIFY_READFAIL|RPMVERIFY_FILEDIGEST);\n\t    } else {\n\t\tsb.st_size = fsize;\n\t\tif (memcmp(fdigest, digest, diglen))\n\t\t    vfy |= RPMVERIFY_FILEDIGEST;\n\t    }\n\t} else {\n\t    vfy |= RPMVERIFY_FILEDIGEST;\n\t} \n    } \n\n    if (flags & RPMVERIFY_LINKTO) {\n\tchar linkto[1024+1];\n\tint size = 0;\n\n\tif ((size = readlink(fn, linkto, sizeof(linkto)-1)) == -1)\n\t    vfy |= (RPMVERIFY_READLINKFAIL|RPMVERIFY_LINKTO);\n\telse {\n\t    const char * flink = rpmfilesFLink(fi, ix);\n\t    linkto[size] = '\\0';\n\t    if (flink == NULL || !rstreq(linkto, flink))\n\t\tvfy |= RPMVERIFY_LINKTO;\n\t}\n    } \n\n    if (flags & RPMVERIFY_FILESIZE) {\n\tif (sb.st_size != rpmfilesFSize(fi, ix))\n\t    vfy |= RPMVERIFY_FILESIZE;\n    } \n\n    if (flags & RPMVERIFY_MODE) {\n\trpm_mode_t metamode = fmode;\n\trpm_mode_t filemode;\n\n\t/*\n\t * Platforms (like AIX) where sizeof(rpm_mode_t) != sizeof(mode_t)\n\t * need the (rpm_mode_t) cast here. \n\t */\n\tfilemode = (rpm_mode_t)sb.st_mode;\n\n\t/*\n\t * Comparing the type of %ghost files is meaningless, but perms are OK.\n\t */\n\tif (fileAttrs & RPMFILE_GHOST) {\n\t    metamode &= ~0xf000;\n\t    filemode &= ~0xf000;\n\t}\n\n\tif (metamode != filemode)\n\t    vfy |= RPMVERIFY_MODE;\n\n#if WITH_ACL\n\t/*\n\t * For now, any non-default acl's on a file is a difference as rpm\n\t * cannot have set them.\n\t */\n\tacl_t facl = acl_get_file(fn, ACL_TYPE_ACCESS);\n\tif (facl) {\n\t    if (acl_equiv_mode(facl, NULL) == 1) {\n\t\tvfy |= RPMVERIFY_MODE;\n\t    }\n\t    acl_free(facl);\n\t}\n#endif \n    }\n\n    if (flags & RPMVERIFY_RDEV) {\n\tif (S_ISCHR(fmode) != S_ISCHR(sb.st_mode)\n\t || S_ISBLK(fmode) != S_ISBLK(sb.st_mode))\n\t{\n\t    vfy |= RPMVERIFY_RDEV;\n\t} else if (S_ISDEV(fmode) && S_ISDEV(sb.st_mode)) {\n\t    rpm_rdev_t st_rdev = (sb.st_rdev & 0xffff);\n\t    rpm_rdev_t frdev = (rpmfilesFRdev(fi, ix) & 0xffff);\n\t    if (st_rdev != frdev)\n\t\tvfy |= RPMVERIFY_RDEV;\n\t} \n    }\n\n#if WITH_CAP\n    if (flags & RPMVERIFY_CAPS) {\n\t/*\n \t * Empty capability set (\"=\") is not exactly the same as no\n \t * capabilities at all but suffices for now... \n \t */\n\tcap_t cap, fcap;\n\tcap = cap_from_text(rpmfilesFCaps(fi, ix));\n\tif (!cap) {\n\t    cap = cap_from_text(\"=\");\n\t}\n\tfcap = cap_get_file(fn);\n\tif (!fcap) {\n\t    fcap = cap_from_text(\"=\");\n\t}\n\t\n\tif (cap_compare(cap, fcap) != 0)\n\t    vfy |= RPMVERIFY_CAPS;\n\n\tcap_free(fcap);\n\tcap_free(cap);\n    }\n#endif\n\n    if ((flags & RPMVERIFY_MTIME) && (sb.st_mtime != rpmfilesFMtime(fi, ix))) {\n\tvfy |= RPMVERIFY_MTIME;\n    }\n\n    if (flags & RPMVERIFY_USER) {\n\tconst char * name = rpmugUname(sb.st_uid);\n\tconst char * fuser = rpmfilesFUser(fi, ix);\n\tuid_t uid;\n\tint namematch = 0;\n\tint idmatch = 0;\n\n\tif (name && fuser)\n\t   namematch =  rstreq(name, fuser);\n\tif (fuser && rpmugUid(fuser, &uid) == 0)\n\t    idmatch = (uid == sb.st_uid);\n\n\tif (namematch != idmatch) {\n\t    rpmlog(RPMLOG_WARNING,\n\t\t    _(\"Duplicate username or UID for user %s\\n\"), fuser);\n\t}\n\n\tif (!(namematch || idmatch))\n\t    vfy |= RPMVERIFY_USER;\n    }\n\n    if (flags & RPMVERIFY_GROUP) {\n\tconst char * name = rpmugGname(sb.st_gid);\n\tconst char * fgroup = rpmfilesFGroup(fi, ix);\n\tgid_t gid;\n\tint namematch = 0;\n\tint idmatch = 0;\n\n\tif (name && fgroup)\n\t    namematch = rstreq(name, fgroup);\n\tif (fgroup && rpmugGid(fgroup, &gid) == 0)\n\t    idmatch = (gid == sb.st_gid);\n\n\tif (namematch != idmatch) {\n\t    rpmlog(RPMLOG_WARNING,\n\t\t    _(\"Duplicate groupname or GID for group %s\\n\"), fgroup);\n\t}\n\n\tif (!(namematch || idmatch))\n\t    vfy |= RPMVERIFY_GROUP;\n    }\n\nexit:\n    return vfy;\n}",
        "func": "rpmVerifyAttrs rpmfilesVerify(rpmfiles fi, int ix, rpmVerifyAttrs omitMask)\n{\n    rpm_mode_t fmode = rpmfilesFMode(fi, ix);\n    rpmfileAttrs fileAttrs = rpmfilesFFlags(fi, ix);\n    rpmVerifyAttrs flags = rpmfilesVFlags(fi, ix);\n    const char * fn = rpmfilesFN(fi, ix);\n    struct stat sb;\n    rpmVerifyAttrs vfy = RPMVERIFY_NONE;\n\n    /*\n     * Check to see if the file was installed - if not pretend all is OK.\n     */\n    switch (rpmfilesFState(fi, ix)) {\n    case RPMFILE_STATE_NETSHARED:\n    case RPMFILE_STATE_NOTINSTALLED:\n\tgoto exit;\n\tbreak;\n    case RPMFILE_STATE_REPLACED:\n\t/* For replaced files we can only verify if it exists at all */\n\tflags = RPMVERIFY_LSTATFAIL;\n\tbreak;\n    case RPMFILE_STATE_WRONGCOLOR:\n\t/*\n\t * Files with wrong color are supposed to share some attributes\n\t * with the actually installed file - verify what we can.\n\t */\n\tflags &= ~(RPMVERIFY_FILEDIGEST | RPMVERIFY_FILESIZE |\n\t\t   RPMVERIFY_MTIME | RPMVERIFY_RDEV);\n\tbreak;\n    case RPMFILE_STATE_NORMAL:\n    /* File from a non-installed package, try to verify nevertheless */\n    case RPMFILE_STATE_MISSING:\n\tbreak;\n    }\n\n    if (fn == NULL || lstat(fn, &sb) != 0) {\n\tvfy |= RPMVERIFY_LSTATFAIL;\n\tgoto exit;\n    }\n\n    /* If we expected a directory but got a symlink to one, follow the link */\n    if (S_ISDIR(fmode) && S_ISLNK(sb.st_mode)) {\n\tstruct stat dsb;\n\t/* ...if it actually points to a directory  */\n\tif (stat(fn, &dsb) == 0 && S_ISDIR(dsb.st_mode)) {\n\t    uid_t fuid;\n\t    /* ...and is by a legit user, to match fsmVerify() behavior */\n\t    if (sb.st_uid == 0 ||\n\t\t\t(rpmugUid(rpmfilesFUser(fi, ix), &fuid) == 0 &&\n\t\t\t sb.st_uid == fuid)) {\n\t\tsb = dsb; /* struct assignment */\n\t    }\n\t}\n    }\n\n    /* Links have no mode, other types have no linkto */\n    if (S_ISLNK(sb.st_mode))\n\tflags &= ~(RPMVERIFY_MODE);\n    else\n\tflags &= ~(RPMVERIFY_LINKTO);\n\n    /* Not all attributes of non-regular files can be verified */\n    if (!S_ISREG(sb.st_mode))\n\tflags &= ~(RPMVERIFY_FILEDIGEST | RPMVERIFY_FILESIZE |\n\t\t   RPMVERIFY_MTIME | RPMVERIFY_CAPS);\n\n    /* Content checks of %ghost files are meaningless. */\n    if (fileAttrs & RPMFILE_GHOST)\n\tflags &= ~(RPMVERIFY_FILEDIGEST | RPMVERIFY_FILESIZE |\n\t\t   RPMVERIFY_MTIME | RPMVERIFY_LINKTO);\n\n    /* Don't verify any features in omitMask. */\n    flags &= ~(omitMask | RPMVERIFY_FAILURES);\n\n\n    if (flags & RPMVERIFY_FILEDIGEST) {\n\tconst unsigned char *digest; \n\tint algo;\n\tsize_t diglen;\n\n\t/* XXX If --nomd5, then prelinked library sizes are not corrected. */\n\tif ((digest = rpmfilesFDigest(fi, ix, &algo, &diglen))) {\n\t    unsigned char fdigest[diglen];\n\t    rpm_loff_t fsize;\n\n\t    if (rpmDoDigest(algo, fn, 0, fdigest, &fsize)) {\n\t\tvfy |= (RPMVERIFY_READFAIL|RPMVERIFY_FILEDIGEST);\n\t    } else {\n\t\tsb.st_size = fsize;\n\t\tif (memcmp(fdigest, digest, diglen))\n\t\t    vfy |= RPMVERIFY_FILEDIGEST;\n\t    }\n\t} else {\n\t    vfy |= RPMVERIFY_FILEDIGEST;\n\t} \n    } \n\n    if (flags & RPMVERIFY_LINKTO) {\n\tchar linkto[1024+1];\n\tint size = 0;\n\n\tif ((size = readlink(fn, linkto, sizeof(linkto)-1)) == -1)\n\t    vfy |= (RPMVERIFY_READLINKFAIL|RPMVERIFY_LINKTO);\n\telse {\n\t    const char * flink = rpmfilesFLink(fi, ix);\n\t    linkto[size] = '\\0';\n\t    if (flink == NULL || !rstreq(linkto, flink))\n\t\tvfy |= RPMVERIFY_LINKTO;\n\t}\n    } \n\n    if (flags & RPMVERIFY_FILESIZE) {\n\tif (sb.st_size != rpmfilesFSize(fi, ix))\n\t    vfy |= RPMVERIFY_FILESIZE;\n    } \n\n    if (flags & RPMVERIFY_MODE) {\n\trpm_mode_t metamode = fmode;\n\trpm_mode_t filemode;\n\n\t/*\n\t * Platforms (like AIX) where sizeof(rpm_mode_t) != sizeof(mode_t)\n\t * need the (rpm_mode_t) cast here. \n\t */\n\tfilemode = (rpm_mode_t)sb.st_mode;\n\n\t/*\n\t * Comparing the type of %ghost files is meaningless, but perms are OK.\n\t */\n\tif (fileAttrs & RPMFILE_GHOST) {\n\t    metamode &= ~0xf000;\n\t    filemode &= ~0xf000;\n\t}\n\n\tif (metamode != filemode)\n\t    vfy |= RPMVERIFY_MODE;\n\n#if WITH_ACL\n\t/*\n\t * For now, any non-default acl's on a file is a difference as rpm\n\t * cannot have set them.\n\t */\n\tacl_t facl = acl_get_file(fn, ACL_TYPE_ACCESS);\n\tif (facl) {\n\t    if (acl_equiv_mode(facl, NULL) == 1) {\n\t\tvfy |= RPMVERIFY_MODE;\n\t    }\n\t    acl_free(facl);\n\t}\n#endif \n    }\n\n    if (flags & RPMVERIFY_RDEV) {\n\tif (S_ISCHR(fmode) != S_ISCHR(sb.st_mode)\n\t || S_ISBLK(fmode) != S_ISBLK(sb.st_mode))\n\t{\n\t    vfy |= RPMVERIFY_RDEV;\n\t} else if (S_ISDEV(fmode) && S_ISDEV(sb.st_mode)) {\n\t    rpm_rdev_t st_rdev = (sb.st_rdev & 0xffff);\n\t    rpm_rdev_t frdev = (rpmfilesFRdev(fi, ix) & 0xffff);\n\t    if (st_rdev != frdev)\n\t\tvfy |= RPMVERIFY_RDEV;\n\t} \n    }\n\n#if WITH_CAP\n    if (flags & RPMVERIFY_CAPS) {\n\t/*\n \t * Empty capability set (\"=\") is not exactly the same as no\n \t * capabilities at all but suffices for now... \n \t */\n\tcap_t cap, fcap;\n\tcap = cap_from_text(rpmfilesFCaps(fi, ix));\n\tif (!cap) {\n\t    cap = cap_from_text(\"=\");\n\t}\n\tfcap = cap_get_file(fn);\n\tif (!fcap) {\n\t    fcap = cap_from_text(\"=\");\n\t}\n\t\n\tif (cap_compare(cap, fcap) != 0)\n\t    vfy |= RPMVERIFY_CAPS;\n\n\tcap_free(fcap);\n\tcap_free(cap);\n    }\n#endif\n\n    if ((flags & RPMVERIFY_MTIME) && (sb.st_mtime != rpmfilesFMtime(fi, ix))) {\n\tvfy |= RPMVERIFY_MTIME;\n    }\n\n    if (flags & RPMVERIFY_USER) {\n\tconst char * name = rpmugUname(sb.st_uid);\n\tconst char * fuser = rpmfilesFUser(fi, ix);\n\tuid_t uid;\n\tint namematch = 0;\n\tint idmatch = 0;\n\n\tif (name && fuser)\n\t   namematch =  rstreq(name, fuser);\n\tif (fuser && rpmugUid(fuser, &uid) == 0)\n\t    idmatch = (uid == sb.st_uid);\n\n\tif (namematch != idmatch) {\n\t    rpmlog(RPMLOG_WARNING,\n\t\t    _(\"Duplicate username or UID for user %s\\n\"), fuser);\n\t}\n\n\tif (!(namematch || idmatch))\n\t    vfy |= RPMVERIFY_USER;\n    }\n\n    if (flags & RPMVERIFY_GROUP) {\n\tconst char * name = rpmugGname(sb.st_gid);\n\tconst char * fgroup = rpmfilesFGroup(fi, ix);\n\tgid_t gid;\n\tint namematch = 0;\n\tint idmatch = 0;\n\n\tif (name && fgroup)\n\t    namematch = rstreq(name, fgroup);\n\tif (fgroup && rpmugGid(fgroup, &gid) == 0)\n\t    idmatch = (gid == sb.st_gid);\n\n\tif (namematch != idmatch) {\n\t    rpmlog(RPMLOG_WARNING,\n\t\t    _(\"Duplicate groupname or GID for group %s\\n\"), fgroup);\n\t}\n\n\tif (!(namematch || idmatch))\n\t    vfy |= RPMVERIFY_GROUP;\n    }\n\nexit:\n    return vfy;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -39,9 +39,18 @@\n     }\n \n     /* If we expected a directory but got a symlink to one, follow the link */\n-    if (S_ISDIR(fmode) && S_ISLNK(sb.st_mode) && stat(fn, &sb) != 0) {\n-\tvfy |= RPMVERIFY_LSTATFAIL;\n-\tgoto exit;\n+    if (S_ISDIR(fmode) && S_ISLNK(sb.st_mode)) {\n+\tstruct stat dsb;\n+\t/* ...if it actually points to a directory  */\n+\tif (stat(fn, &dsb) == 0 && S_ISDIR(dsb.st_mode)) {\n+\t    uid_t fuid;\n+\t    /* ...and is by a legit user, to match fsmVerify() behavior */\n+\t    if (sb.st_uid == 0 ||\n+\t\t\t(rpmugUid(rpmfilesFUser(fi, ix), &fuid) == 0 &&\n+\t\t\t sb.st_uid == fuid)) {\n+\t\tsb = dsb; /* struct assignment */\n+\t    }\n+\t}\n     }\n \n     /* Links have no mode, other types have no linkto */",
        "diff_line_info": {
            "deleted_lines": [
                "    if (S_ISDIR(fmode) && S_ISLNK(sb.st_mode) && stat(fn, &sb) != 0) {",
                "\tvfy |= RPMVERIFY_LSTATFAIL;",
                "\tgoto exit;"
            ],
            "added_lines": [
                "    if (S_ISDIR(fmode) && S_ISLNK(sb.st_mode)) {",
                "\tstruct stat dsb;",
                "\t/* ...if it actually points to a directory  */",
                "\tif (stat(fn, &dsb) == 0 && S_ISDIR(dsb.st_mode)) {",
                "\t    uid_t fuid;",
                "\t    /* ...and is by a legit user, to match fsmVerify() behavior */",
                "\t    if (sb.st_uid == 0 ||",
                "\t\t\t(rpmugUid(rpmfilesFUser(fi, ix), &fuid) == 0 &&",
                "\t\t\t sb.st_uid == fuid)) {",
                "\t\tsb = dsb; /* struct assignment */",
                "\t    }",
                "\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-19044",
        "func_name": "acassen/keepalived/vrrp_print_json",
        "description": "keepalived 2.0.8 didn't check for pathnames with symlinks when writing data to a temporary file upon a call to PrintData or PrintStats. This allowed local users to overwrite arbitrary files if fs.protected_symlinks is set to 0, as demonstrated by a symlink from /tmp/keepalived.data or /tmp/keepalived.stats to /etc/passwd.",
        "git_url": "https://github.com/acassen/keepalived/commit/04f2d32871bb3b11d7dc024039952f2fe2750306",
        "commit_title": "When opening files for write, ensure they aren't symbolic links",
        "commit_text": " Issue #1048 identified that if, for example, a non privileged user created a symbolic link from /etc/keepalvied.data to /etc/passwd, writing to /etc/keepalived.data (which could be invoked via DBus) would cause /etc/passwd to be overwritten.  This commit stops keepalived writing to pathnames where the ultimate component is a symbolic link, by setting O_NOFOLLOW whenever opening a file for writing.  This might break some setups, where, for example, /etc/keepalived.data was a symbolic link to /home/fred/keepalived.data. If this was the case, instead create a symbolic link from /home/fred/keepalived.data to /tmp/keepalived.data, so that the file is still accessible via /home/fred/keepalived.data.  There doesn't appear to be a way around this backward incompatibility, since even checking if the pathname is a symbolic link prior to opening for writing would create a race condition. ",
        "func_before": "void\nvrrp_print_json(void)\n{\n\tFILE *file;\n\telement e;\n\tstruct json_object *array;\n\n\tif (LIST_ISEMPTY(vrrp_data->vrrp))\n\t\treturn;\n\n\tfile = fopen (\"/tmp/keepalived.json\",\"w\");\n\tif (!file) {\n\t\tlog_message(LOG_INFO, \"Can't open /tmp/keepalived.json (%d: %s)\",\n\t\t\terrno, strerror(errno));\n\t\treturn;\n\t}\n\n\tarray = json_object_new_array();\n\n\tfor (e = LIST_HEAD(vrrp_data->vrrp); e; ELEMENT_NEXT(e)) {\n\t\tstruct json_object *instance_json, *json_stats, *json_data,\n\t\t\t*vips, *evips, *track_ifp, *track_script;\n#ifdef _HAVE_FIB_ROUTING_\n\t\tstruct json_object *vroutes, *vrules;\n#endif\n\t\telement f;\n\n\t\tvrrp_t *vrrp = ELEMENT_DATA(e);\n\t\tinstance_json = json_object_new_object();\n\t\tjson_stats = json_object_new_object();\n\t\tjson_data = json_object_new_object();\n\t\tvips = json_object_new_array();\n\t\tevips = json_object_new_array();\n\t\ttrack_ifp = json_object_new_array();\n\t\ttrack_script = json_object_new_array();\n#ifdef _HAVE_FIB_ROUTING_\n\t\tvroutes = json_object_new_array();\n\t\tvrules = json_object_new_array();\n#endif\n\n\t\t// Dump data to json\n\t\tjson_object_object_add(json_data, \"iname\",\n\t\t\tjson_object_new_string(vrrp->iname));\n\t\tjson_object_object_add(json_data, \"dont_track_primary\",\n\t\t\tjson_object_new_int(vrrp->dont_track_primary));\n\t\tjson_object_object_add(json_data, \"skip_check_adv_addr\",\n\t\t\tjson_object_new_int(vrrp->skip_check_adv_addr));\n\t\tjson_object_object_add(json_data, \"strict_mode\",\n\t\t\tjson_object_new_int((int)vrrp->strict_mode));\n#ifdef _HAVE_VRRP_VMAC_\n\t\tjson_object_object_add(json_data, \"vmac_ifname\",\n\t\t\tjson_object_new_string(vrrp->vmac_ifname));\n#endif\n\t\t// Tracked interfaces are stored in a list\n\t\tif (!LIST_ISEMPTY(vrrp->track_ifp)) {\n\t\t\tfor (f = LIST_HEAD(vrrp->track_ifp); f; ELEMENT_NEXT(f)) {\n\t\t\t\tinterface_t *ifp = ELEMENT_DATA(f);\n\t\t\t\tjson_object_array_add(track_ifp,\n\t\t\t\t\tjson_object_new_string(ifp->ifname));\n\t\t\t}\n\t\t}\n\t\tjson_object_object_add(json_data, \"track_ifp\", track_ifp);\n\n\t\t// Tracked scripts also\n\t\tif (!LIST_ISEMPTY(vrrp->track_script)) {\n\t\t\tfor (f = LIST_HEAD(vrrp->track_script); f; ELEMENT_NEXT(f)) {\n\t\t\t\ttracked_sc_t *tsc = ELEMENT_DATA(f);\n\t\t\t\tvrrp_script_t *vscript = tsc->scr;\n\t\t\t\tjson_object_array_add(track_script,\n\t\t\t\t\tjson_object_new_string(cmd_str(&vscript->script)));\n\t\t\t}\n\t\t}\n\t\tjson_object_object_add(json_data, \"track_script\", track_script);\n\n\t\tjson_object_object_add(json_data, \"ifp_ifname\",\n\t\t\tjson_object_new_string(vrrp->ifp->ifname));\n\t\tjson_object_object_add(json_data, \"master_priority\",\n\t\t\tjson_object_new_int(vrrp->master_priority));\n\t\tjson_object_object_add(json_data, \"last_transition\",\n\t\t\tjson_object_new_double(timeval_to_double(&vrrp->last_transition)));\n\t\tjson_object_object_add(json_data, \"garp_delay\",\n\t\t\tjson_object_new_double(vrrp->garp_delay / TIMER_HZ_FLOAT));\n\t\tjson_object_object_add(json_data, \"garp_refresh\",\n\t\t\tjson_object_new_int((int)vrrp->garp_refresh.tv_sec));\n\t\tjson_object_object_add(json_data, \"garp_rep\",\n\t\t\tjson_object_new_int((int)vrrp->garp_rep));\n\t\tjson_object_object_add(json_data, \"garp_refresh_rep\",\n\t\t\tjson_object_new_int((int)vrrp->garp_refresh_rep));\n\t\tjson_object_object_add(json_data, \"garp_lower_prio_delay\",\n\t\t\tjson_object_new_int((int)(vrrp->garp_lower_prio_delay / TIMER_HZ)));\n\t\tjson_object_object_add(json_data, \"garp_lower_prio_rep\",\n\t\t\tjson_object_new_int((int)vrrp->garp_lower_prio_rep));\n\t\tjson_object_object_add(json_data, \"lower_prio_no_advert\",\n\t\t\tjson_object_new_int((int)vrrp->lower_prio_no_advert));\n\t\tjson_object_object_add(json_data, \"higher_prio_send_advert\",\n\t\t\tjson_object_new_int((int)vrrp->higher_prio_send_advert));\n\t\tjson_object_object_add(json_data, \"vrid\",\n\t\t\tjson_object_new_int(vrrp->vrid));\n\t\tjson_object_object_add(json_data, \"base_priority\",\n\t\t\tjson_object_new_int(vrrp->base_priority));\n\t\tjson_object_object_add(json_data, \"effective_priority\",\n\t\t\tjson_object_new_int(vrrp->effective_priority));\n\t\tjson_object_object_add(json_data, \"vipset\",\n\t\t\tjson_object_new_boolean(vrrp->vipset));\n\n\t\t//Virtual IPs are stored in a list\n\t\tif (!LIST_ISEMPTY(vrrp->vip)) {\n\t\t\tfor (f = LIST_HEAD(vrrp->vip); f; ELEMENT_NEXT(f)) {\n\t\t\t\tip_address_t *vip = ELEMENT_DATA(f);\n\t\t\t\tchar ipaddr[INET6_ADDRSTRLEN];\n\t\t\t\tinet_ntop(vrrp->family, &(vip->u.sin.sin_addr.s_addr),\n\t\t\t\t\tipaddr, INET6_ADDRSTRLEN);\n\t\t\t\tjson_object_array_add(vips,\n\t\t\t\t\tjson_object_new_string(ipaddr));\n\t\t\t}\n\t\t}\n\t\tjson_object_object_add(json_data, \"vips\", vips);\n\n\t\t//External VIPs are also stored in a list\n\t\tif (!LIST_ISEMPTY(vrrp->evip)) {\n\t\t\tfor (f = LIST_HEAD(vrrp->evip); f; ELEMENT_NEXT(f)) {\n\t\t\t\tip_address_t *evip = ELEMENT_DATA(f);\n\t\t\t\tchar ipaddr[INET6_ADDRSTRLEN];\n\t\t\t\tinet_ntop(vrrp->family, &(evip->u.sin.sin_addr.s_addr),\n\t\t\t\t\tipaddr, INET6_ADDRSTRLEN);\n\t\t\t\tjson_object_array_add(evips,\n\t\t\t\t\tjson_object_new_string(ipaddr));\n\t\t\t}\n\t\t}\n\t\tjson_object_object_add(json_data, \"evips\", evips);\n\n\t\tjson_object_object_add(json_data, \"promote_secondaries\",\n\t\t\tjson_object_new_boolean(vrrp->promote_secondaries));\n\n#ifdef _HAVE_FIB_ROUTING_\n\t\t// Dump vroutes\n\t\tif (!LIST_ISEMPTY(vrrp->vroutes)) {\n\t\t\tfor (f = LIST_HEAD(vrrp->vroutes); f; ELEMENT_NEXT(f)) {\n\t\t\t\tip_route_t *route = ELEMENT_DATA(f);\n\t\t\t\tchar *buf = MALLOC(ROUTE_BUF_SIZE);\n\t\t\t\tformat_iproute(route, buf, ROUTE_BUF_SIZE);\n\t\t\t\tjson_object_array_add(vroutes,\n\t\t\t\t\tjson_object_new_string(buf));\n\t\t\t}\n\t\t}\n\t\tjson_object_object_add(json_data, \"vroutes\", vroutes);\n\n\t\t// Dump vrules\n\t\tif (!LIST_ISEMPTY(vrrp->vrules)) {\n\t\t\tfor (f = LIST_HEAD(vrrp->vrules); f; ELEMENT_NEXT(f)) {\n\t\t\t\tip_rule_t *rule = ELEMENT_DATA(f);\n\t\t\t\tchar *buf = MALLOC(RULE_BUF_SIZE);\n\t\t\t\tformat_iprule(rule, buf, RULE_BUF_SIZE);\n\t\t\t\tjson_object_array_add(vrules,\n\t\t\t\t\tjson_object_new_string(buf));\n\t\t\t}\n\t\t}\n\t\tjson_object_object_add(json_data, \"vrules\", vrules);\n#endif\n\n\t\tjson_object_object_add(json_data, \"adver_int\",\n\t\t\tjson_object_new_double(vrrp->adver_int / TIMER_HZ_FLOAT));\n\t\tjson_object_object_add(json_data, \"master_adver_int\",\n\t\t\tjson_object_new_double(vrrp->master_adver_int / TIMER_HZ_FLOAT));\n\t\tjson_object_object_add(json_data, \"accept\",\n\t\t\tjson_object_new_int((int)vrrp->accept));\n\t\tjson_object_object_add(json_data, \"nopreempt\",\n\t\t\tjson_object_new_boolean(vrrp->nopreempt));\n\t\tjson_object_object_add(json_data, \"preempt_delay\",\n\t\t\tjson_object_new_int((int)(vrrp->preempt_delay / TIMER_HZ)));\n\t\tjson_object_object_add(json_data, \"state\",\n\t\t\tjson_object_new_int(vrrp->state));\n\t\tjson_object_object_add(json_data, \"wantstate\",\n\t\t\tjson_object_new_int(vrrp->wantstate));\n\t\tjson_object_object_add(json_data, \"version\",\n\t\t\tjson_object_new_int(vrrp->version));\n\t\tif (vrrp->script_backup)\n\t\t\tjson_object_object_add(json_data, \"script_backup\",\n\t\t\t\tjson_object_new_string(cmd_str(vrrp->script_backup)));\n\t\tif (vrrp->script_master)\n\t\t\tjson_object_object_add(json_data, \"script_master\",\n\t\t\t\tjson_object_new_string(cmd_str(vrrp->script_master)));\n\t\tif (vrrp->script_fault)\n\t\t\tjson_object_object_add(json_data, \"script_fault\",\n\t\t\t\tjson_object_new_string(cmd_str(vrrp->script_fault)));\n\t\tif (vrrp->script_stop)\n\t\t\tjson_object_object_add(json_data, \"script_stop\",\n\t\t\t\tjson_object_new_string(cmd_str(vrrp->script_stop)));\n\t\tif (vrrp->script)\n\t\t\tjson_object_object_add(json_data, \"script\",\n\t\t\t\tjson_object_new_string(cmd_str(vrrp->script)));\n\t\tif (vrrp->script_master_rx_lower_pri)\n\t\t\tjson_object_object_add(json_data, \"script_master_rx_lower_pri\",\n\t\t\t\tjson_object_new_string(cmd_str(vrrp->script_master_rx_lower_pri)));\n\t\tjson_object_object_add(json_data, \"smtp_alert\",\n\t\t\tjson_object_new_boolean(vrrp->smtp_alert));\n#ifdef _WITH_VRRP_AUTH_\n\t\tif (vrrp->auth_type) {\n\t\t\tjson_object_object_add(json_data, \"auth_type\",\n\t\t\t\tjson_object_new_int(vrrp->auth_type));\n\n\t\t\tif (vrrp->auth_type != VRRP_AUTH_AH) {\n\t\t\t\tchar auth_data[sizeof(vrrp->auth_data) + 1];\n\t\t\t\tmemcpy(auth_data, vrrp->auth_data, sizeof(vrrp->auth_data));\n\t\t\t\tauth_data[sizeof(vrrp->auth_data)] = '\\0';\n\t\t\t\tjson_object_object_add(json_data, \"auth_data\",\n\t\t\t\t\tjson_object_new_string(auth_data));\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tjson_object_object_add(json_data, \"auth_type\",\n\t\t\t\tjson_object_new_int(0));\n#endif\n\n\t\t// Dump stats to json\n\t\tjson_object_object_add(json_stats, \"advert_rcvd\",\n\t\t\tjson_object_new_int64((int64_t)vrrp->stats->advert_rcvd));\n\t\tjson_object_object_add(json_stats, \"advert_sent\",\n\t\t\tjson_object_new_int64(vrrp->stats->advert_sent));\n\t\tjson_object_object_add(json_stats, \"become_master\",\n\t\t\tjson_object_new_int64(vrrp->stats->become_master));\n\t\tjson_object_object_add(json_stats, \"release_master\",\n\t\t\tjson_object_new_int64(vrrp->stats->release_master));\n\t\tjson_object_object_add(json_stats, \"packet_len_err\",\n\t\t\tjson_object_new_int64((int64_t)vrrp->stats->packet_len_err));\n\t\tjson_object_object_add(json_stats, \"advert_interval_err\",\n\t\t\tjson_object_new_int64((int64_t)vrrp->stats->advert_interval_err));\n\t\tjson_object_object_add(json_stats, \"ip_ttl_err\",\n\t\t\tjson_object_new_int64((int64_t)vrrp->stats->ip_ttl_err));\n\t\tjson_object_object_add(json_stats, \"invalid_type_rcvd\",\n\t\t\tjson_object_new_int64((int64_t)vrrp->stats->invalid_type_rcvd));\n\t\tjson_object_object_add(json_stats, \"addr_list_err\",\n\t\t\tjson_object_new_int64((int64_t)vrrp->stats->addr_list_err));\n\t\tjson_object_object_add(json_stats, \"invalid_authtype\",\n\t\t\tjson_object_new_int64(vrrp->stats->invalid_authtype));\n#ifdef _WITH_VRRP_AUTH_\n\t\tjson_object_object_add(json_stats, \"authtype_mismatch\",\n\t\t\tjson_object_new_int64(vrrp->stats->authtype_mismatch));\n\t\tjson_object_object_add(json_stats, \"auth_failure\",\n\t\t\tjson_object_new_int64(vrrp->stats->auth_failure));\n#endif\n\t\tjson_object_object_add(json_stats, \"pri_zero_rcvd\",\n\t\t\tjson_object_new_int64((int64_t)vrrp->stats->pri_zero_rcvd));\n\t\tjson_object_object_add(json_stats, \"pri_zero_sent\",\n\t\t\tjson_object_new_int64((int64_t)vrrp->stats->pri_zero_sent));\n\n\t\t// Add both json_data and json_stats to main instance_json\n\t\tjson_object_object_add(instance_json, \"data\", json_data);\n\t\tjson_object_object_add(instance_json, \"stats\", json_stats);\n\n\t\t// Add instance_json to main array\n\t\tjson_object_array_add(array, instance_json);\n\n\t}\n\tfprintf(file, \"%s\", json_object_to_json_string(array));\n\tfclose(file);\n}",
        "func": "void\nvrrp_print_json(void)\n{\n\tFILE *file;\n\telement e;\n\tstruct json_object *array;\n\n\tif (LIST_ISEMPTY(vrrp_data->vrrp))\n\t\treturn;\n\n\tfile = fopen_safe(\"/tmp/keepalived.json\", \"w\");\n\tif (!file) {\n\t\tlog_message(LOG_INFO, \"Can't open /tmp/keepalived.json (%d: %s)\",\n\t\t\terrno, strerror(errno));\n\t\treturn;\n\t}\n\n\tarray = json_object_new_array();\n\n\tfor (e = LIST_HEAD(vrrp_data->vrrp); e; ELEMENT_NEXT(e)) {\n\t\tstruct json_object *instance_json, *json_stats, *json_data,\n\t\t\t*vips, *evips, *track_ifp, *track_script;\n#ifdef _HAVE_FIB_ROUTING_\n\t\tstruct json_object *vroutes, *vrules;\n#endif\n\t\telement f;\n\n\t\tvrrp_t *vrrp = ELEMENT_DATA(e);\n\t\tinstance_json = json_object_new_object();\n\t\tjson_stats = json_object_new_object();\n\t\tjson_data = json_object_new_object();\n\t\tvips = json_object_new_array();\n\t\tevips = json_object_new_array();\n\t\ttrack_ifp = json_object_new_array();\n\t\ttrack_script = json_object_new_array();\n#ifdef _HAVE_FIB_ROUTING_\n\t\tvroutes = json_object_new_array();\n\t\tvrules = json_object_new_array();\n#endif\n\n\t\t// Dump data to json\n\t\tjson_object_object_add(json_data, \"iname\",\n\t\t\tjson_object_new_string(vrrp->iname));\n\t\tjson_object_object_add(json_data, \"dont_track_primary\",\n\t\t\tjson_object_new_int(vrrp->dont_track_primary));\n\t\tjson_object_object_add(json_data, \"skip_check_adv_addr\",\n\t\t\tjson_object_new_int(vrrp->skip_check_adv_addr));\n\t\tjson_object_object_add(json_data, \"strict_mode\",\n\t\t\tjson_object_new_int((int)vrrp->strict_mode));\n#ifdef _HAVE_VRRP_VMAC_\n\t\tjson_object_object_add(json_data, \"vmac_ifname\",\n\t\t\tjson_object_new_string(vrrp->vmac_ifname));\n#endif\n\t\t// Tracked interfaces are stored in a list\n\t\tif (!LIST_ISEMPTY(vrrp->track_ifp)) {\n\t\t\tfor (f = LIST_HEAD(vrrp->track_ifp); f; ELEMENT_NEXT(f)) {\n\t\t\t\tinterface_t *ifp = ELEMENT_DATA(f);\n\t\t\t\tjson_object_array_add(track_ifp,\n\t\t\t\t\tjson_object_new_string(ifp->ifname));\n\t\t\t}\n\t\t}\n\t\tjson_object_object_add(json_data, \"track_ifp\", track_ifp);\n\n\t\t// Tracked scripts also\n\t\tif (!LIST_ISEMPTY(vrrp->track_script)) {\n\t\t\tfor (f = LIST_HEAD(vrrp->track_script); f; ELEMENT_NEXT(f)) {\n\t\t\t\ttracked_sc_t *tsc = ELEMENT_DATA(f);\n\t\t\t\tvrrp_script_t *vscript = tsc->scr;\n\t\t\t\tjson_object_array_add(track_script,\n\t\t\t\t\tjson_object_new_string(cmd_str(&vscript->script)));\n\t\t\t}\n\t\t}\n\t\tjson_object_object_add(json_data, \"track_script\", track_script);\n\n\t\tjson_object_object_add(json_data, \"ifp_ifname\",\n\t\t\tjson_object_new_string(vrrp->ifp->ifname));\n\t\tjson_object_object_add(json_data, \"master_priority\",\n\t\t\tjson_object_new_int(vrrp->master_priority));\n\t\tjson_object_object_add(json_data, \"last_transition\",\n\t\t\tjson_object_new_double(timeval_to_double(&vrrp->last_transition)));\n\t\tjson_object_object_add(json_data, \"garp_delay\",\n\t\t\tjson_object_new_double(vrrp->garp_delay / TIMER_HZ_FLOAT));\n\t\tjson_object_object_add(json_data, \"garp_refresh\",\n\t\t\tjson_object_new_int((int)vrrp->garp_refresh.tv_sec));\n\t\tjson_object_object_add(json_data, \"garp_rep\",\n\t\t\tjson_object_new_int((int)vrrp->garp_rep));\n\t\tjson_object_object_add(json_data, \"garp_refresh_rep\",\n\t\t\tjson_object_new_int((int)vrrp->garp_refresh_rep));\n\t\tjson_object_object_add(json_data, \"garp_lower_prio_delay\",\n\t\t\tjson_object_new_int((int)(vrrp->garp_lower_prio_delay / TIMER_HZ)));\n\t\tjson_object_object_add(json_data, \"garp_lower_prio_rep\",\n\t\t\tjson_object_new_int((int)vrrp->garp_lower_prio_rep));\n\t\tjson_object_object_add(json_data, \"lower_prio_no_advert\",\n\t\t\tjson_object_new_int((int)vrrp->lower_prio_no_advert));\n\t\tjson_object_object_add(json_data, \"higher_prio_send_advert\",\n\t\t\tjson_object_new_int((int)vrrp->higher_prio_send_advert));\n\t\tjson_object_object_add(json_data, \"vrid\",\n\t\t\tjson_object_new_int(vrrp->vrid));\n\t\tjson_object_object_add(json_data, \"base_priority\",\n\t\t\tjson_object_new_int(vrrp->base_priority));\n\t\tjson_object_object_add(json_data, \"effective_priority\",\n\t\t\tjson_object_new_int(vrrp->effective_priority));\n\t\tjson_object_object_add(json_data, \"vipset\",\n\t\t\tjson_object_new_boolean(vrrp->vipset));\n\n\t\t//Virtual IPs are stored in a list\n\t\tif (!LIST_ISEMPTY(vrrp->vip)) {\n\t\t\tfor (f = LIST_HEAD(vrrp->vip); f; ELEMENT_NEXT(f)) {\n\t\t\t\tip_address_t *vip = ELEMENT_DATA(f);\n\t\t\t\tchar ipaddr[INET6_ADDRSTRLEN];\n\t\t\t\tinet_ntop(vrrp->family, &(vip->u.sin.sin_addr.s_addr),\n\t\t\t\t\tipaddr, INET6_ADDRSTRLEN);\n\t\t\t\tjson_object_array_add(vips,\n\t\t\t\t\tjson_object_new_string(ipaddr));\n\t\t\t}\n\t\t}\n\t\tjson_object_object_add(json_data, \"vips\", vips);\n\n\t\t//External VIPs are also stored in a list\n\t\tif (!LIST_ISEMPTY(vrrp->evip)) {\n\t\t\tfor (f = LIST_HEAD(vrrp->evip); f; ELEMENT_NEXT(f)) {\n\t\t\t\tip_address_t *evip = ELEMENT_DATA(f);\n\t\t\t\tchar ipaddr[INET6_ADDRSTRLEN];\n\t\t\t\tinet_ntop(vrrp->family, &(evip->u.sin.sin_addr.s_addr),\n\t\t\t\t\tipaddr, INET6_ADDRSTRLEN);\n\t\t\t\tjson_object_array_add(evips,\n\t\t\t\t\tjson_object_new_string(ipaddr));\n\t\t\t}\n\t\t}\n\t\tjson_object_object_add(json_data, \"evips\", evips);\n\n\t\tjson_object_object_add(json_data, \"promote_secondaries\",\n\t\t\tjson_object_new_boolean(vrrp->promote_secondaries));\n\n#ifdef _HAVE_FIB_ROUTING_\n\t\t// Dump vroutes\n\t\tif (!LIST_ISEMPTY(vrrp->vroutes)) {\n\t\t\tfor (f = LIST_HEAD(vrrp->vroutes); f; ELEMENT_NEXT(f)) {\n\t\t\t\tip_route_t *route = ELEMENT_DATA(f);\n\t\t\t\tchar *buf = MALLOC(ROUTE_BUF_SIZE);\n\t\t\t\tformat_iproute(route, buf, ROUTE_BUF_SIZE);\n\t\t\t\tjson_object_array_add(vroutes,\n\t\t\t\t\tjson_object_new_string(buf));\n\t\t\t}\n\t\t}\n\t\tjson_object_object_add(json_data, \"vroutes\", vroutes);\n\n\t\t// Dump vrules\n\t\tif (!LIST_ISEMPTY(vrrp->vrules)) {\n\t\t\tfor (f = LIST_HEAD(vrrp->vrules); f; ELEMENT_NEXT(f)) {\n\t\t\t\tip_rule_t *rule = ELEMENT_DATA(f);\n\t\t\t\tchar *buf = MALLOC(RULE_BUF_SIZE);\n\t\t\t\tformat_iprule(rule, buf, RULE_BUF_SIZE);\n\t\t\t\tjson_object_array_add(vrules,\n\t\t\t\t\tjson_object_new_string(buf));\n\t\t\t}\n\t\t}\n\t\tjson_object_object_add(json_data, \"vrules\", vrules);\n#endif\n\n\t\tjson_object_object_add(json_data, \"adver_int\",\n\t\t\tjson_object_new_double(vrrp->adver_int / TIMER_HZ_FLOAT));\n\t\tjson_object_object_add(json_data, \"master_adver_int\",\n\t\t\tjson_object_new_double(vrrp->master_adver_int / TIMER_HZ_FLOAT));\n\t\tjson_object_object_add(json_data, \"accept\",\n\t\t\tjson_object_new_int((int)vrrp->accept));\n\t\tjson_object_object_add(json_data, \"nopreempt\",\n\t\t\tjson_object_new_boolean(vrrp->nopreempt));\n\t\tjson_object_object_add(json_data, \"preempt_delay\",\n\t\t\tjson_object_new_int((int)(vrrp->preempt_delay / TIMER_HZ)));\n\t\tjson_object_object_add(json_data, \"state\",\n\t\t\tjson_object_new_int(vrrp->state));\n\t\tjson_object_object_add(json_data, \"wantstate\",\n\t\t\tjson_object_new_int(vrrp->wantstate));\n\t\tjson_object_object_add(json_data, \"version\",\n\t\t\tjson_object_new_int(vrrp->version));\n\t\tif (vrrp->script_backup)\n\t\t\tjson_object_object_add(json_data, \"script_backup\",\n\t\t\t\tjson_object_new_string(cmd_str(vrrp->script_backup)));\n\t\tif (vrrp->script_master)\n\t\t\tjson_object_object_add(json_data, \"script_master\",\n\t\t\t\tjson_object_new_string(cmd_str(vrrp->script_master)));\n\t\tif (vrrp->script_fault)\n\t\t\tjson_object_object_add(json_data, \"script_fault\",\n\t\t\t\tjson_object_new_string(cmd_str(vrrp->script_fault)));\n\t\tif (vrrp->script_stop)\n\t\t\tjson_object_object_add(json_data, \"script_stop\",\n\t\t\t\tjson_object_new_string(cmd_str(vrrp->script_stop)));\n\t\tif (vrrp->script)\n\t\t\tjson_object_object_add(json_data, \"script\",\n\t\t\t\tjson_object_new_string(cmd_str(vrrp->script)));\n\t\tif (vrrp->script_master_rx_lower_pri)\n\t\t\tjson_object_object_add(json_data, \"script_master_rx_lower_pri\",\n\t\t\t\tjson_object_new_string(cmd_str(vrrp->script_master_rx_lower_pri)));\n\t\tjson_object_object_add(json_data, \"smtp_alert\",\n\t\t\tjson_object_new_boolean(vrrp->smtp_alert));\n#ifdef _WITH_VRRP_AUTH_\n\t\tif (vrrp->auth_type) {\n\t\t\tjson_object_object_add(json_data, \"auth_type\",\n\t\t\t\tjson_object_new_int(vrrp->auth_type));\n\n\t\t\tif (vrrp->auth_type != VRRP_AUTH_AH) {\n\t\t\t\tchar auth_data[sizeof(vrrp->auth_data) + 1];\n\t\t\t\tmemcpy(auth_data, vrrp->auth_data, sizeof(vrrp->auth_data));\n\t\t\t\tauth_data[sizeof(vrrp->auth_data)] = '\\0';\n\t\t\t\tjson_object_object_add(json_data, \"auth_data\",\n\t\t\t\t\tjson_object_new_string(auth_data));\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tjson_object_object_add(json_data, \"auth_type\",\n\t\t\t\tjson_object_new_int(0));\n#endif\n\n\t\t// Dump stats to json\n\t\tjson_object_object_add(json_stats, \"advert_rcvd\",\n\t\t\tjson_object_new_int64((int64_t)vrrp->stats->advert_rcvd));\n\t\tjson_object_object_add(json_stats, \"advert_sent\",\n\t\t\tjson_object_new_int64(vrrp->stats->advert_sent));\n\t\tjson_object_object_add(json_stats, \"become_master\",\n\t\t\tjson_object_new_int64(vrrp->stats->become_master));\n\t\tjson_object_object_add(json_stats, \"release_master\",\n\t\t\tjson_object_new_int64(vrrp->stats->release_master));\n\t\tjson_object_object_add(json_stats, \"packet_len_err\",\n\t\t\tjson_object_new_int64((int64_t)vrrp->stats->packet_len_err));\n\t\tjson_object_object_add(json_stats, \"advert_interval_err\",\n\t\t\tjson_object_new_int64((int64_t)vrrp->stats->advert_interval_err));\n\t\tjson_object_object_add(json_stats, \"ip_ttl_err\",\n\t\t\tjson_object_new_int64((int64_t)vrrp->stats->ip_ttl_err));\n\t\tjson_object_object_add(json_stats, \"invalid_type_rcvd\",\n\t\t\tjson_object_new_int64((int64_t)vrrp->stats->invalid_type_rcvd));\n\t\tjson_object_object_add(json_stats, \"addr_list_err\",\n\t\t\tjson_object_new_int64((int64_t)vrrp->stats->addr_list_err));\n\t\tjson_object_object_add(json_stats, \"invalid_authtype\",\n\t\t\tjson_object_new_int64(vrrp->stats->invalid_authtype));\n#ifdef _WITH_VRRP_AUTH_\n\t\tjson_object_object_add(json_stats, \"authtype_mismatch\",\n\t\t\tjson_object_new_int64(vrrp->stats->authtype_mismatch));\n\t\tjson_object_object_add(json_stats, \"auth_failure\",\n\t\t\tjson_object_new_int64(vrrp->stats->auth_failure));\n#endif\n\t\tjson_object_object_add(json_stats, \"pri_zero_rcvd\",\n\t\t\tjson_object_new_int64((int64_t)vrrp->stats->pri_zero_rcvd));\n\t\tjson_object_object_add(json_stats, \"pri_zero_sent\",\n\t\t\tjson_object_new_int64((int64_t)vrrp->stats->pri_zero_sent));\n\n\t\t// Add both json_data and json_stats to main instance_json\n\t\tjson_object_object_add(instance_json, \"data\", json_data);\n\t\tjson_object_object_add(instance_json, \"stats\", json_stats);\n\n\t\t// Add instance_json to main array\n\t\tjson_object_array_add(array, instance_json);\n\n\t}\n\tfprintf(file, \"%s\", json_object_to_json_string(array));\n\tfclose(file);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -8,7 +8,7 @@\n \tif (LIST_ISEMPTY(vrrp_data->vrrp))\n \t\treturn;\n \n-\tfile = fopen (\"/tmp/keepalived.json\",\"w\");\n+\tfile = fopen_safe(\"/tmp/keepalived.json\", \"w\");\n \tif (!file) {\n \t\tlog_message(LOG_INFO, \"Can't open /tmp/keepalived.json (%d: %s)\",\n \t\t\terrno, strerror(errno));",
        "diff_line_info": {
            "deleted_lines": [
                "\tfile = fopen (\"/tmp/keepalived.json\",\"w\");"
            ],
            "added_lines": [
                "\tfile = fopen_safe(\"/tmp/keepalived.json\", \"w\");"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-19044",
        "func_name": "acassen/keepalived/vrrp_print_data",
        "description": "keepalived 2.0.8 didn't check for pathnames with symlinks when writing data to a temporary file upon a call to PrintData or PrintStats. This allowed local users to overwrite arbitrary files if fs.protected_symlinks is set to 0, as demonstrated by a symlink from /tmp/keepalived.data or /tmp/keepalived.stats to /etc/passwd.",
        "git_url": "https://github.com/acassen/keepalived/commit/04f2d32871bb3b11d7dc024039952f2fe2750306",
        "commit_title": "When opening files for write, ensure they aren't symbolic links",
        "commit_text": " Issue #1048 identified that if, for example, a non privileged user created a symbolic link from /etc/keepalvied.data to /etc/passwd, writing to /etc/keepalived.data (which could be invoked via DBus) would cause /etc/passwd to be overwritten.  This commit stops keepalived writing to pathnames where the ultimate component is a symbolic link, by setting O_NOFOLLOW whenever opening a file for writing.  This might break some setups, where, for example, /etc/keepalived.data was a symbolic link to /home/fred/keepalived.data. If this was the case, instead create a symbolic link from /home/fred/keepalived.data to /tmp/keepalived.data, so that the file is still accessible via /home/fred/keepalived.data.  There doesn't appear to be a way around this backward incompatibility, since even checking if the pathname is a symbolic link prior to opening for writing would create a race condition. ",
        "func_before": "void\nvrrp_print_data(void)\n{\n\tFILE *file = fopen (dump_file, \"w\");\n\n\tif (!file) {\n\t\tlog_message(LOG_INFO, \"Can't open %s (%d: %s)\",\n\t\t\tdump_file, errno, strerror(errno));\n\t\treturn;\n\t}\n\n\tdump_data_vrrp(file);\n\n\tfclose(file);\n}",
        "func": "void\nvrrp_print_data(void)\n{\n\tFILE *file = fopen_safe(dump_file, \"w\");\n\n\tif (!file) {\n\t\tlog_message(LOG_INFO, \"Can't open %s (%d: %s)\",\n\t\t\tdump_file, errno, strerror(errno));\n\t\treturn;\n\t}\n\n\tdump_data_vrrp(file);\n\n\tfclose(file);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,7 +1,7 @@\n void\n vrrp_print_data(void)\n {\n-\tFILE *file = fopen (dump_file, \"w\");\n+\tFILE *file = fopen_safe(dump_file, \"w\");\n \n \tif (!file) {\n \t\tlog_message(LOG_INFO, \"Can't open %s (%d: %s)\",",
        "diff_line_info": {
            "deleted_lines": [
                "\tFILE *file = fopen (dump_file, \"w\");"
            ],
            "added_lines": [
                "\tFILE *file = fopen_safe(dump_file, \"w\");"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-19044",
        "func_name": "acassen/keepalived/vrrp_print_stats",
        "description": "keepalived 2.0.8 didn't check for pathnames with symlinks when writing data to a temporary file upon a call to PrintData or PrintStats. This allowed local users to overwrite arbitrary files if fs.protected_symlinks is set to 0, as demonstrated by a symlink from /tmp/keepalived.data or /tmp/keepalived.stats to /etc/passwd.",
        "git_url": "https://github.com/acassen/keepalived/commit/04f2d32871bb3b11d7dc024039952f2fe2750306",
        "commit_title": "When opening files for write, ensure they aren't symbolic links",
        "commit_text": " Issue #1048 identified that if, for example, a non privileged user created a symbolic link from /etc/keepalvied.data to /etc/passwd, writing to /etc/keepalived.data (which could be invoked via DBus) would cause /etc/passwd to be overwritten.  This commit stops keepalived writing to pathnames where the ultimate component is a symbolic link, by setting O_NOFOLLOW whenever opening a file for writing.  This might break some setups, where, for example, /etc/keepalived.data was a symbolic link to /home/fred/keepalived.data. If this was the case, instead create a symbolic link from /home/fred/keepalived.data to /tmp/keepalived.data, so that the file is still accessible via /home/fred/keepalived.data.  There doesn't appear to be a way around this backward incompatibility, since even checking if the pathname is a symbolic link prior to opening for writing would create a race condition. ",
        "func_before": "void\nvrrp_print_stats(void)\n{\n\tFILE *file;\n\tfile = fopen (stats_file, \"w\");\n\n\tif (!file) {\n\t\tlog_message(LOG_INFO, \"Can't open %s (%d: %s)\",\n\t\t\tstats_file, errno, strerror(errno));\n\t\treturn;\n\t}\n\n\tlist l = vrrp_data->vrrp;\n\telement e;\n\tvrrp_t *vrrp;\n\n\tfor (e = LIST_HEAD(l); e; ELEMENT_NEXT(e)) {\n\t\tvrrp = ELEMENT_DATA(e);\n\t\tfprintf(file, \"VRRP Instance: %s\\n\", vrrp->iname);\n\t\tfprintf(file, \"  Advertisements:\\n\");\n\t\tfprintf(file, \"    Received: %\" PRIu64 \"\\n\", vrrp->stats->advert_rcvd);\n\t\tfprintf(file, \"    Sent: %d\\n\", vrrp->stats->advert_sent);\n\t\tfprintf(file, \"  Became master: %d\\n\", vrrp->stats->become_master);\n\t\tfprintf(file, \"  Released master: %d\\n\",\n\t\t\tvrrp->stats->release_master);\n\t\tfprintf(file, \"  Packet Errors:\\n\");\n\t\tfprintf(file, \"    Length: %\" PRIu64 \"\\n\", vrrp->stats->packet_len_err);\n\t\tfprintf(file, \"    TTL: %\" PRIu64 \"\\n\", vrrp->stats->ip_ttl_err);\n\t\tfprintf(file, \"    Invalid Type: %\" PRIu64 \"\\n\",\n\t\t\tvrrp->stats->invalid_type_rcvd);\n\t\tfprintf(file, \"    Advertisement Interval: %\" PRIu64 \"\\n\",\n\t\t\tvrrp->stats->advert_interval_err);\n\t\tfprintf(file, \"    Address List: %\" PRIu64 \"\\n\",\n\t\t\tvrrp->stats->addr_list_err);\n\t\tfprintf(file, \"  Authentication Errors:\\n\");\n\t\tfprintf(file, \"    Invalid Type: %d\\n\",\n\t\t\tvrrp->stats->invalid_authtype);\n#ifdef _WITH_VRRP_AUTH_\n\t\tfprintf(file, \"    Type Mismatch: %d\\n\",\n\t\t\tvrrp->stats->authtype_mismatch);\n\t\tfprintf(file, \"    Failure: %d\\n\",\n\t\t\tvrrp->stats->auth_failure);\n#endif\n\t\tfprintf(file, \"  Priority Zero:\\n\");\n\t\tfprintf(file, \"    Received: %\" PRIu64 \"\\n\", vrrp->stats->pri_zero_rcvd);\n\t\tfprintf(file, \"    Sent: %\" PRIu64 \"\\n\", vrrp->stats->pri_zero_sent);\n\t}\n\tfclose(file);\n}",
        "func": "void\nvrrp_print_stats(void)\n{\n\tFILE *file = fopen_safe(stats_file, \"w\");\n\telement e;\n\tvrrp_t *vrrp;\n\n\tif (!file) {\n\t\tlog_message(LOG_INFO, \"Can't open %s (%d: %s)\",\n\t\t\tstats_file, errno, strerror(errno));\n\t\treturn;\n\t}\n\n\n\tLIST_FOREACH(vrrp_data->vrrp, vrrp, e) {\n\t\tfprintf(file, \"VRRP Instance: %s\\n\", vrrp->iname);\n\t\tfprintf(file, \"  Advertisements:\\n\");\n\t\tfprintf(file, \"    Received: %\" PRIu64 \"\\n\", vrrp->stats->advert_rcvd);\n\t\tfprintf(file, \"    Sent: %d\\n\", vrrp->stats->advert_sent);\n\t\tfprintf(file, \"  Became master: %d\\n\", vrrp->stats->become_master);\n\t\tfprintf(file, \"  Released master: %d\\n\", vrrp->stats->release_master);\n\t\tfprintf(file, \"  Packet Errors:\\n\");\n\t\tfprintf(file, \"    Length: %\" PRIu64 \"\\n\", vrrp->stats->packet_len_err);\n\t\tfprintf(file, \"    TTL: %\" PRIu64 \"\\n\", vrrp->stats->ip_ttl_err);\n\t\tfprintf(file, \"    Invalid Type: %\" PRIu64 \"\\n\",\n\t\t\tvrrp->stats->invalid_type_rcvd);\n\t\tfprintf(file, \"    Advertisement Interval: %\" PRIu64 \"\\n\",\n\t\t\tvrrp->stats->advert_interval_err);\n\t\tfprintf(file, \"    Address List: %\" PRIu64 \"\\n\",\n\t\t\tvrrp->stats->addr_list_err);\n\t\tfprintf(file, \"  Authentication Errors:\\n\");\n\t\tfprintf(file, \"    Invalid Type: %d\\n\",\n\t\t\tvrrp->stats->invalid_authtype);\n#ifdef _WITH_VRRP_AUTH_\n\t\tfprintf(file, \"    Type Mismatch: %d\\n\",\n\t\t\tvrrp->stats->authtype_mismatch);\n\t\tfprintf(file, \"    Failure: %d\\n\",\n\t\t\tvrrp->stats->auth_failure);\n#endif\n\t\tfprintf(file, \"  Priority Zero:\\n\");\n\t\tfprintf(file, \"    Received: %\" PRIu64 \"\\n\", vrrp->stats->pri_zero_rcvd);\n\t\tfprintf(file, \"    Sent: %\" PRIu64 \"\\n\", vrrp->stats->pri_zero_sent);\n\t}\n\tfclose(file);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,8 +1,9 @@\n void\n vrrp_print_stats(void)\n {\n-\tFILE *file;\n-\tfile = fopen (stats_file, \"w\");\n+\tFILE *file = fopen_safe(stats_file, \"w\");\n+\telement e;\n+\tvrrp_t *vrrp;\n \n \tif (!file) {\n \t\tlog_message(LOG_INFO, \"Can't open %s (%d: %s)\",\n@@ -10,19 +11,14 @@\n \t\treturn;\n \t}\n \n-\tlist l = vrrp_data->vrrp;\n-\telement e;\n-\tvrrp_t *vrrp;\n \n-\tfor (e = LIST_HEAD(l); e; ELEMENT_NEXT(e)) {\n-\t\tvrrp = ELEMENT_DATA(e);\n+\tLIST_FOREACH(vrrp_data->vrrp, vrrp, e) {\n \t\tfprintf(file, \"VRRP Instance: %s\\n\", vrrp->iname);\n \t\tfprintf(file, \"  Advertisements:\\n\");\n \t\tfprintf(file, \"    Received: %\" PRIu64 \"\\n\", vrrp->stats->advert_rcvd);\n \t\tfprintf(file, \"    Sent: %d\\n\", vrrp->stats->advert_sent);\n \t\tfprintf(file, \"  Became master: %d\\n\", vrrp->stats->become_master);\n-\t\tfprintf(file, \"  Released master: %d\\n\",\n-\t\t\tvrrp->stats->release_master);\n+\t\tfprintf(file, \"  Released master: %d\\n\", vrrp->stats->release_master);\n \t\tfprintf(file, \"  Packet Errors:\\n\");\n \t\tfprintf(file, \"    Length: %\" PRIu64 \"\\n\", vrrp->stats->packet_len_err);\n \t\tfprintf(file, \"    TTL: %\" PRIu64 \"\\n\", vrrp->stats->ip_ttl_err);",
        "diff_line_info": {
            "deleted_lines": [
                "\tFILE *file;",
                "\tfile = fopen (stats_file, \"w\");",
                "\tlist l = vrrp_data->vrrp;",
                "\telement e;",
                "\tvrrp_t *vrrp;",
                "\tfor (e = LIST_HEAD(l); e; ELEMENT_NEXT(e)) {",
                "\t\tvrrp = ELEMENT_DATA(e);",
                "\t\tfprintf(file, \"  Released master: %d\\n\",",
                "\t\t\tvrrp->stats->release_master);"
            ],
            "added_lines": [
                "\tFILE *file = fopen_safe(stats_file, \"w\");",
                "\telement e;",
                "\tvrrp_t *vrrp;",
                "\tLIST_FOREACH(vrrp_data->vrrp, vrrp, e) {",
                "\t\tfprintf(file, \"  Released master: %d\\n\", vrrp->stats->release_master);"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-19044",
        "func_name": "acassen/keepalived/vrrp_tfile_end_handler",
        "description": "keepalived 2.0.8 didn't check for pathnames with symlinks when writing data to a temporary file upon a call to PrintData or PrintStats. This allowed local users to overwrite arbitrary files if fs.protected_symlinks is set to 0, as demonstrated by a symlink from /tmp/keepalived.data or /tmp/keepalived.stats to /etc/passwd.",
        "git_url": "https://github.com/acassen/keepalived/commit/04f2d32871bb3b11d7dc024039952f2fe2750306",
        "commit_title": "When opening files for write, ensure they aren't symbolic links",
        "commit_text": " Issue #1048 identified that if, for example, a non privileged user created a symbolic link from /etc/keepalvied.data to /etc/passwd, writing to /etc/keepalived.data (which could be invoked via DBus) would cause /etc/passwd to be overwritten.  This commit stops keepalived writing to pathnames where the ultimate component is a symbolic link, by setting O_NOFOLLOW whenever opening a file for writing.  This might break some setups, where, for example, /etc/keepalived.data was a symbolic link to /home/fred/keepalived.data. If this was the case, instead create a symbolic link from /home/fred/keepalived.data to /tmp/keepalived.data, so that the file is still accessible via /home/fred/keepalived.data.  There doesn't appear to be a way around this backward incompatibility, since even checking if the pathname is a symbolic link prior to opening for writing would create a race condition. ",
        "func_before": "static void\nvrrp_tfile_end_handler(void)\n{\n\tvrrp_tracked_file_t *tfile = LIST_TAIL_DATA(vrrp_data->vrrp_track_files);\n\tstruct stat statb;\n\tFILE *tf;\n\tint ret;\n\n\tif (!tfile->file_path) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"No file set for track_file %s - removing\", tfile->fname);\n\t\tfree_list_element(vrrp_data->vrrp_track_files, vrrp_data->vrrp_track_files->tail);\n\t\treturn;\n\t}\n\n\tif (track_file_init == TRACK_FILE_NO_INIT)\n\t\treturn;\n\n\tret = stat(tfile->file_path, &statb);\n\tif (!ret) {\n\t\tif (track_file_init == TRACK_FILE_CREATE) {\n\t\t\t/* The file exists */\n\t\t\treturn;\n\t\t}\n\t\tif ((statb.st_mode & S_IFMT) != S_IFREG) {\n\t\t\t/* It is not a regular file */\n\t\t\treport_config_error(CONFIG_GENERAL_ERROR, \"Cannot initialise track file %s - it is not a regular file\", tfile->fname);\n\t\t\treturn;\n\t\t}\n\n\t\t/* Don't overwrite a file on reload */\n\t\tif (reload)\n\t\t\treturn;\n\t}\n\n\tif (!__test_bit(CONFIG_TEST_BIT, &debug)) {\n\t\t/* Write the value to the file */\n\t\tif ((tf = fopen(tfile->file_path, \"w\"))) {\n\t\t\tfprintf(tf, \"%d\\n\", track_file_init_value);\n\t\t\tfclose(tf);\n\t\t}\n\t\telse\n\t\t\treport_config_error(CONFIG_GENERAL_ERROR, \"Unable to initialise track file %s\", tfile->fname);\n\t}\n}",
        "func": "static void\nvrrp_tfile_end_handler(void)\n{\n\tvrrp_tracked_file_t *tfile = LIST_TAIL_DATA(vrrp_data->vrrp_track_files);\n\tstruct stat statb;\n\tFILE *tf;\n\tint ret;\n\n\tif (!tfile->file_path) {\n\t\treport_config_error(CONFIG_GENERAL_ERROR, \"No file set for track_file %s - removing\", tfile->fname);\n\t\tfree_list_element(vrrp_data->vrrp_track_files, vrrp_data->vrrp_track_files->tail);\n\t\treturn;\n\t}\n\n\tif (track_file_init == TRACK_FILE_NO_INIT)\n\t\treturn;\n\n\tret = stat(tfile->file_path, &statb);\n\tif (!ret) {\n\t\tif (track_file_init == TRACK_FILE_CREATE) {\n\t\t\t/* The file exists */\n\t\t\treturn;\n\t\t}\n\t\tif ((statb.st_mode & S_IFMT) != S_IFREG) {\n\t\t\t/* It is not a regular file */\n\t\t\treport_config_error(CONFIG_GENERAL_ERROR, \"Cannot initialise track file %s - it is not a regular file\", tfile->fname);\n\t\t\treturn;\n\t\t}\n\n\t\t/* Don't overwrite a file on reload */\n\t\tif (reload)\n\t\t\treturn;\n\t}\n\n\tif (!__test_bit(CONFIG_TEST_BIT, &debug)) {\n\t\t/* Write the value to the file */\n\t\tif ((tf = fopen_safe(tfile->file_path, \"w\"))) {\n\t\t\tfprintf(tf, \"%d\\n\", track_file_init_value);\n\t\t\tfclose(tf);\n\t\t}\n\t\telse\n\t\t\treport_config_error(CONFIG_GENERAL_ERROR, \"Unable to initialise track file %s\", tfile->fname);\n\t}\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -34,7 +34,7 @@\n \n \tif (!__test_bit(CONFIG_TEST_BIT, &debug)) {\n \t\t/* Write the value to the file */\n-\t\tif ((tf = fopen(tfile->file_path, \"w\"))) {\n+\t\tif ((tf = fopen_safe(tfile->file_path, \"w\"))) {\n \t\t\tfprintf(tf, \"%d\\n\", track_file_init_value);\n \t\t\tfclose(tf);\n \t\t}",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tif ((tf = fopen(tfile->file_path, \"w\"))) {"
            ],
            "added_lines": [
                "\t\tif ((tf = fopen_safe(tfile->file_path, \"w\"))) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-19044",
        "func_name": "acassen/keepalived/smtp_log_to_file",
        "description": "keepalived 2.0.8 didn't check for pathnames with symlinks when writing data to a temporary file upon a call to PrintData or PrintStats. This allowed local users to overwrite arbitrary files if fs.protected_symlinks is set to 0, as demonstrated by a symlink from /tmp/keepalived.data or /tmp/keepalived.stats to /etc/passwd.",
        "git_url": "https://github.com/acassen/keepalived/commit/04f2d32871bb3b11d7dc024039952f2fe2750306",
        "commit_title": "When opening files for write, ensure they aren't symbolic links",
        "commit_text": " Issue #1048 identified that if, for example, a non privileged user created a symbolic link from /etc/keepalvied.data to /etc/passwd, writing to /etc/keepalived.data (which could be invoked via DBus) would cause /etc/passwd to be overwritten.  This commit stops keepalived writing to pathnames where the ultimate component is a symbolic link, by setting O_NOFOLLOW whenever opening a file for writing.  This might break some setups, where, for example, /etc/keepalived.data was a symbolic link to /home/fred/keepalived.data. If this was the case, instead create a symbolic link from /home/fred/keepalived.data to /tmp/keepalived.data, so that the file is still accessible via /home/fred/keepalived.data.  There doesn't appear to be a way around this backward incompatibility, since even checking if the pathname is a symbolic link prior to opening for writing would create a race condition. ",
        "func_before": "static void\nsmtp_log_to_file(smtp_t *smtp)\n{\n\tFILE *fp = fopen(\"/tmp/smtp-alert.log\", \"a\");\n\ttime_t now;\n\tstruct tm tm;\n\tchar time_buf[25];\n\tint time_buf_len;\n\n\ttime(&now);\n\tlocaltime_r(&now, &tm);\n\ttime_buf_len = strftime(time_buf, sizeof time_buf, \"%a %b %e %X %Y\", &tm);\n\n\tfprintf(fp, \"%s: %s -> %s\\n\"\n\t\t    \"%*sSubject: %s\\n\"\n\t\t    \"%*sBody:    %s\\n\\n\",\n\t\t    time_buf, global_data->email_from, smtp->email_to,\n\t\t    time_buf_len - 7, \"\", smtp->subject,\n\t\t    time_buf_len - 7, \"\", smtp->body);\n\n\tfclose(fp);\n\n\tfree_smtp_all(smtp);\n}",
        "func": "static void\nsmtp_log_to_file(smtp_t *smtp)\n{\n\tFILE *fp = fopen_safe(\"/tmp/smtp-alert.log\", \"a\");\n\ttime_t now;\n\tstruct tm tm;\n\tchar time_buf[25];\n\tint time_buf_len;\n\n\ttime(&now);\n\tlocaltime_r(&now, &tm);\n\ttime_buf_len = strftime(time_buf, sizeof time_buf, \"%a %b %e %X %Y\", &tm);\n\n\tfprintf(fp, \"%s: %s -> %s\\n\"\n\t\t    \"%*sSubject: %s\\n\"\n\t\t    \"%*sBody:    %s\\n\\n\",\n\t\t    time_buf, global_data->email_from, smtp->email_to,\n\t\t    time_buf_len - 7, \"\", smtp->subject,\n\t\t    time_buf_len - 7, \"\", smtp->body);\n\n\tfclose(fp);\n\n\tfree_smtp_all(smtp);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,7 +1,7 @@\n static void\n smtp_log_to_file(smtp_t *smtp)\n {\n-\tFILE *fp = fopen(\"/tmp/smtp-alert.log\", \"a\");\n+\tFILE *fp = fopen_safe(\"/tmp/smtp-alert.log\", \"a\");\n \ttime_t now;\n \tstruct tm tm;\n \tchar time_buf[25];",
        "diff_line_info": {
            "deleted_lines": [
                "\tFILE *fp = fopen(\"/tmp/smtp-alert.log\", \"a\");"
            ],
            "added_lines": [
                "\tFILE *fp = fopen_safe(\"/tmp/smtp-alert.log\", \"a\");"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-19044",
        "func_name": "acassen/keepalived/dump_threads",
        "description": "keepalived 2.0.8 didn't check for pathnames with symlinks when writing data to a temporary file upon a call to PrintData or PrintStats. This allowed local users to overwrite arbitrary files if fs.protected_symlinks is set to 0, as demonstrated by a symlink from /tmp/keepalived.data or /tmp/keepalived.stats to /etc/passwd.",
        "git_url": "https://github.com/acassen/keepalived/commit/04f2d32871bb3b11d7dc024039952f2fe2750306",
        "commit_title": "When opening files for write, ensure they aren't symbolic links",
        "commit_text": " Issue #1048 identified that if, for example, a non privileged user created a symbolic link from /etc/keepalvied.data to /etc/passwd, writing to /etc/keepalived.data (which could be invoked via DBus) would cause /etc/passwd to be overwritten.  This commit stops keepalived writing to pathnames where the ultimate component is a symbolic link, by setting O_NOFOLLOW whenever opening a file for writing.  This might break some setups, where, for example, /etc/keepalived.data was a symbolic link to /home/fred/keepalived.data. If this was the case, instead create a symbolic link from /home/fred/keepalived.data to /tmp/keepalived.data, so that the file is still accessible via /home/fred/keepalived.data.  There doesn't appear to be a way around this backward incompatibility, since even checking if the pathname is a symbolic link prior to opening for writing would create a race condition. ",
        "func_before": "void\ndump_threads(void)\n{\n\tFILE *fp;\n\tchar time_buf[26];\n\telement e;\n\tvrrp_t *vrrp;\n\tchar *file_name;\n\n\tfile_name = make_file_name(\"/tmp/thread_dump.dat\",\n\t\t\t\t\t\"vrrp\",\n#if HAVE_DECL_CLONE_NEWNET\n\t\t\t\t\tglobal_data->network_namespace,\n#else\n\t\t\t\t\tNULL,\n#endif\n\t\t\t\t\tglobal_data->instance_name);\n\tfp = fopen(file_name, \"a\");\n\tFREE(file_name);\n\n\tset_time_now();\n\tctime_r(&time_now.tv_sec, time_buf);\n\n\tfprintf(fp, \"\\n%.19s.%6.6ld: Thread dump\\n\", time_buf, time_now.tv_usec);\n\n\tdump_thread_data(master, fp);\n\n\tfprintf(fp, \"alloc = %lu\\n\", master->alloc);\n\n\tfprintf(fp, \"\\n\");\n\tLIST_FOREACH(vrrp_data->vrrp, vrrp, e) {\n\t\tctime_r(&vrrp->sands.tv_sec, time_buf);\n\t\tfprintf(fp, \"VRRP instance %s, sands %.19s.%6.6lu, status %s\\n\", vrrp->iname, time_buf, vrrp->sands.tv_usec,\n\t\t\t\tvrrp->state == VRRP_STATE_INIT ? \"INIT\" :\n\t\t\t\tvrrp->state == VRRP_STATE_BACK ? \"BACKUP\" :\n\t\t\t\tvrrp->state == VRRP_STATE_MAST ? \"MASTER\" :\n\t\t\t\tvrrp->state == VRRP_STATE_FAULT ? \"FAULT\" :\n\t\t\t\tvrrp->state == VRRP_STATE_STOP ? \"STOP\" :\n\t\t\t\tvrrp->state == VRRP_DISPATCHER ? \"DISPATCHER\" : \"unknown\");\n\t}\n\tfclose(fp);\n}",
        "func": "void\ndump_threads(void)\n{\n\tFILE *fp;\n\tchar time_buf[26];\n\telement e;\n\tvrrp_t *vrrp;\n\tchar *file_name;\n\n\tfile_name = make_file_name(\"/tmp/thread_dump.dat\",\n\t\t\t\t\t\"vrrp\",\n#if HAVE_DECL_CLONE_NEWNET\n\t\t\t\t\tglobal_data->network_namespace,\n#else\n\t\t\t\t\tNULL,\n#endif\n\t\t\t\t\tglobal_data->instance_name);\n\tfp = fopen_safe(file_name, \"a\");\n\tFREE(file_name);\n\n\tset_time_now();\n\tctime_r(&time_now.tv_sec, time_buf);\n\n\tfprintf(fp, \"\\n%.19s.%6.6ld: Thread dump\\n\", time_buf, time_now.tv_usec);\n\n\tdump_thread_data(master, fp);\n\n\tfprintf(fp, \"alloc = %lu\\n\", master->alloc);\n\n\tfprintf(fp, \"\\n\");\n\tLIST_FOREACH(vrrp_data->vrrp, vrrp, e) {\n\t\tctime_r(&vrrp->sands.tv_sec, time_buf);\n\t\tfprintf(fp, \"VRRP instance %s, sands %.19s.%6.6lu, status %s\\n\", vrrp->iname, time_buf, vrrp->sands.tv_usec,\n\t\t\t\tvrrp->state == VRRP_STATE_INIT ? \"INIT\" :\n\t\t\t\tvrrp->state == VRRP_STATE_BACK ? \"BACKUP\" :\n\t\t\t\tvrrp->state == VRRP_STATE_MAST ? \"MASTER\" :\n\t\t\t\tvrrp->state == VRRP_STATE_FAULT ? \"FAULT\" :\n\t\t\t\tvrrp->state == VRRP_STATE_STOP ? \"STOP\" :\n\t\t\t\tvrrp->state == VRRP_DISPATCHER ? \"DISPATCHER\" : \"unknown\");\n\t}\n\tfclose(fp);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -15,7 +15,7 @@\n \t\t\t\t\tNULL,\n #endif\n \t\t\t\t\tglobal_data->instance_name);\n-\tfp = fopen(file_name, \"a\");\n+\tfp = fopen_safe(file_name, \"a\");\n \tFREE(file_name);\n \n \tset_time_now();",
        "diff_line_info": {
            "deleted_lines": [
                "\tfp = fopen(file_name, \"a\");"
            ],
            "added_lines": [
                "\tfp = fopen_safe(file_name, \"a\");"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-19044",
        "func_name": "acassen/keepalived/pidfile_write",
        "description": "keepalived 2.0.8 didn't check for pathnames with symlinks when writing data to a temporary file upon a call to PrintData or PrintStats. This allowed local users to overwrite arbitrary files if fs.protected_symlinks is set to 0, as demonstrated by a symlink from /tmp/keepalived.data or /tmp/keepalived.stats to /etc/passwd.",
        "git_url": "https://github.com/acassen/keepalived/commit/04f2d32871bb3b11d7dc024039952f2fe2750306",
        "commit_title": "When opening files for write, ensure they aren't symbolic links",
        "commit_text": " Issue #1048 identified that if, for example, a non privileged user created a symbolic link from /etc/keepalvied.data to /etc/passwd, writing to /etc/keepalived.data (which could be invoked via DBus) would cause /etc/passwd to be overwritten.  This commit stops keepalived writing to pathnames where the ultimate component is a symbolic link, by setting O_NOFOLLOW whenever opening a file for writing.  This might break some setups, where, for example, /etc/keepalived.data was a symbolic link to /home/fred/keepalived.data. If this was the case, instead create a symbolic link from /home/fred/keepalived.data to /tmp/keepalived.data, so that the file is still accessible via /home/fred/keepalived.data.  There doesn't appear to be a way around this backward incompatibility, since even checking if the pathname is a symbolic link prior to opening for writing would create a race condition. ",
        "func_before": "int\npidfile_write(const char *pid_file, int pid)\n{\n\tFILE *pidfile = NULL;\n\tint pidfd = creat(pid_file, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n\n\tif (pidfd != -1) pidfile = fdopen(pidfd, \"w\");\n\n\tif (!pidfile) {\n\t\tlog_message(LOG_INFO, \"pidfile_write : Cannot open %s pidfile\",\n\t\t       pid_file);\n\t\treturn 0;\n\t}\n\tfprintf(pidfile, \"%d\\n\", pid);\n\tfclose(pidfile);\n\treturn 1;\n}",
        "func": "int\npidfile_write(const char *pid_file, int pid)\n{\n\tFILE *pidfile = NULL;\n\tint pidfd = open(pid_file, O_NOFOLLOW | O_CREAT | O_WRONLY | O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n\n\tif (pidfd != -1) pidfile = fdopen(pidfd, \"w\");\n\n\tif (!pidfile) {\n\t\tlog_message(LOG_INFO, \"pidfile_write : Cannot open %s pidfile\",\n\t\t       pid_file);\n\t\treturn 0;\n\t}\n\tfprintf(pidfile, \"%d\\n\", pid);\n\tfclose(pidfile);\n\treturn 1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,7 +2,7 @@\n pidfile_write(const char *pid_file, int pid)\n {\n \tFILE *pidfile = NULL;\n-\tint pidfd = creat(pid_file, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n+\tint pidfd = open(pid_file, O_NOFOLLOW | O_CREAT | O_WRONLY | O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n \n \tif (pidfd != -1) pidfile = fdopen(pidfd, \"w\");\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\tint pidfd = creat(pid_file, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);"
            ],
            "added_lines": [
                "\tint pidfd = open(pid_file, O_NOFOLLOW | O_CREAT | O_WRONLY | O_TRUNC, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-19044",
        "func_name": "acassen/keepalived/read_file",
        "description": "keepalived 2.0.8 didn't check for pathnames with symlinks when writing data to a temporary file upon a call to PrintData or PrintStats. This allowed local users to overwrite arbitrary files if fs.protected_symlinks is set to 0, as demonstrated by a symlink from /tmp/keepalived.data or /tmp/keepalived.stats to /etc/passwd.",
        "git_url": "https://github.com/acassen/keepalived/commit/04f2d32871bb3b11d7dc024039952f2fe2750306",
        "commit_title": "When opening files for write, ensure they aren't symbolic links",
        "commit_text": " Issue #1048 identified that if, for example, a non privileged user created a symbolic link from /etc/keepalvied.data to /etc/passwd, writing to /etc/keepalived.data (which could be invoked via DBus) would cause /etc/passwd to be overwritten.  This commit stops keepalived writing to pathnames where the ultimate component is a symbolic link, by setting O_NOFOLLOW whenever opening a file for writing.  This might break some setups, where, for example, /etc/keepalived.data was a symbolic link to /home/fred/keepalived.data. If this was the case, instead create a symbolic link from /home/fred/keepalived.data to /tmp/keepalived.data, so that the file is still accessible via /home/fred/keepalived.data.  There doesn't appear to be a way around this backward incompatibility, since even checking if the pathname is a symbolic link prior to opening for writing would create a race condition. ",
        "func_before": "static gchar*\nread_file(gchar* filepath)\n{\n\tFILE * f;\n\tsize_t length;\n\tgchar *ret = NULL;\n\n\tf = fopen(filepath, \"rb\");\n\tif (f) {\n\t\tfseek(f, 0, SEEK_END);\n\t\tlength = (size_t)ftell(f);\n\t\tfseek(f, 0, SEEK_SET);\n\n\t\t/* We can't use MALLOC since it isn't thread safe */\n\t\tret = MALLOC(length + 1);\n\t\tif (ret) {\n\t\t\tif (fread(ret, length, 1, f) != 1) {\n\t\t\t\tlog_message(LOG_INFO, \"Failed to read all of %s\", filepath);\n\t\t\t}\n\t\t\tret[length] = '\\0';\n\t\t}\n\t\telse\n\t\t\tlog_message(LOG_INFO, \"Unable to read Dbus file %s\", filepath);\n\n\t\tfclose(f);\n\t}\n\treturn ret;\n}",
        "func": "static gchar*\nread_file(gchar* filepath)\n{\n\tFILE * f;\n\tsize_t length;\n\tgchar *ret = NULL;\n\n\tf = fopen(filepath, \"r\");\n\tif (f) {\n\t\tfseek(f, 0, SEEK_END);\n\t\tlength = (size_t)ftell(f);\n\t\tfseek(f, 0, SEEK_SET);\n\n\t\t/* We can't use MALLOC since it isn't thread safe */\n\t\tret = MALLOC(length + 1);\n\t\tif (ret) {\n\t\t\tif (fread(ret, length, 1, f) != 1) {\n\t\t\t\tlog_message(LOG_INFO, \"Failed to read all of %s\", filepath);\n\t\t\t}\n\t\t\tret[length] = '\\0';\n\t\t}\n\t\telse\n\t\t\tlog_message(LOG_INFO, \"Unable to read Dbus file %s\", filepath);\n\n\t\tfclose(f);\n\t}\n\treturn ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,7 +5,7 @@\n \tsize_t length;\n \tgchar *ret = NULL;\n \n-\tf = fopen(filepath, \"rb\");\n+\tf = fopen(filepath, \"r\");\n \tif (f) {\n \t\tfseek(f, 0, SEEK_END);\n \t\tlength = (size_t)ftell(f);",
        "diff_line_info": {
            "deleted_lines": [
                "\tf = fopen(filepath, \"rb\");"
            ],
            "added_lines": [
                "\tf = fopen(filepath, \"r\");"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-19044",
        "func_name": "acassen/keepalived/fifo_open",
        "description": "keepalived 2.0.8 didn't check for pathnames with symlinks when writing data to a temporary file upon a call to PrintData or PrintStats. This allowed local users to overwrite arbitrary files if fs.protected_symlinks is set to 0, as demonstrated by a symlink from /tmp/keepalived.data or /tmp/keepalived.stats to /etc/passwd.",
        "git_url": "https://github.com/acassen/keepalived/commit/04f2d32871bb3b11d7dc024039952f2fe2750306",
        "commit_title": "When opening files for write, ensure they aren't symbolic links",
        "commit_text": " Issue #1048 identified that if, for example, a non privileged user created a symbolic link from /etc/keepalvied.data to /etc/passwd, writing to /etc/keepalived.data (which could be invoked via DBus) would cause /etc/passwd to be overwritten.  This commit stops keepalived writing to pathnames where the ultimate component is a symbolic link, by setting O_NOFOLLOW whenever opening a file for writing.  This might break some setups, where, for example, /etc/keepalived.data was a symbolic link to /home/fred/keepalived.data. If this was the case, instead create a symbolic link from /home/fred/keepalived.data to /tmp/keepalived.data, so that the file is still accessible via /home/fred/keepalived.data.  There doesn't appear to be a way around this backward incompatibility, since even checking if the pathname is a symbolic link prior to opening for writing would create a race condition. ",
        "func_before": "static void\nfifo_open(notify_fifo_t* fifo, int (*script_exit)(thread_t *), const char *type)\n{\n\tint ret;\n\tint sav_errno;\n\n\tif (fifo->name) {\n\t\tsav_errno = 0;\n\n\t\tif (!(ret = mkfifo(fifo->name, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)))\n\t\t\tfifo->created_fifo = true;\n\t\telse {\n\t\t\tsav_errno = errno;\n\n\t\t\tif (sav_errno != EEXIST)\n\t\t\t\tlog_message(LOG_INFO, \"Unable to create %snotify fifo %s\", type, fifo->name);\n\t\t}\n\n\t\tif (!sav_errno || sav_errno == EEXIST) {\n\t\t\t/* Run the notify script if there is one */\n\t\t\tif (fifo->script)\n\t\t\t\tnotify_fifo_exec(master, script_exit, fifo, fifo->script);\n\n\t\t\t/* Now open the fifo */\n\t\t\tif ((fifo->fd = open(fifo->name, O_RDWR | O_CLOEXEC | O_NONBLOCK)) == -1) {\n\t\t\t\tlog_message(LOG_INFO, \"Unable to open %snotify fifo %s - errno %d\", type, fifo->name, errno);\n\t\t\t\tif (fifo->created_fifo) {\n\t\t\t\t\tunlink(fifo->name);\n\t\t\t\t\tfifo->created_fifo = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (fifo->fd == -1) {\n\t\t\tFREE(fifo->name);\n\t\t\tfifo->name = NULL;\n\t\t}\n\t}\n}",
        "func": "static void\nfifo_open(notify_fifo_t* fifo, int (*script_exit)(thread_t *), const char *type)\n{\n\tint ret;\n\tint sav_errno;\n\n\tif (fifo->name) {\n\t\tsav_errno = 0;\n\n\t\tif (!(ret = mkfifo(fifo->name, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)))\n\t\t\tfifo->created_fifo = true;\n\t\telse {\n\t\t\tsav_errno = errno;\n\n\t\t\tif (sav_errno != EEXIST)\n\t\t\t\tlog_message(LOG_INFO, \"Unable to create %snotify fifo %s\", type, fifo->name);\n\t\t}\n\n\t\tif (!sav_errno || sav_errno == EEXIST) {\n\t\t\t/* Run the notify script if there is one */\n\t\t\tif (fifo->script)\n\t\t\t\tnotify_fifo_exec(master, script_exit, fifo, fifo->script);\n\n\t\t\t/* Now open the fifo */\n\t\t\tif ((fifo->fd = open(fifo->name, O_RDWR | O_CLOEXEC | O_NONBLOCK | O_NOFOLLOW)) == -1) {\n\t\t\t\tlog_message(LOG_INFO, \"Unable to open %snotify fifo %s - errno %d\", type, fifo->name, errno);\n\t\t\t\tif (fifo->created_fifo) {\n\t\t\t\t\tunlink(fifo->name);\n\t\t\t\t\tfifo->created_fifo = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (fifo->fd == -1) {\n\t\t\tFREE(fifo->name);\n\t\t\tfifo->name = NULL;\n\t\t}\n\t}\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -22,7 +22,7 @@\n \t\t\t\tnotify_fifo_exec(master, script_exit, fifo, fifo->script);\n \n \t\t\t/* Now open the fifo */\n-\t\t\tif ((fifo->fd = open(fifo->name, O_RDWR | O_CLOEXEC | O_NONBLOCK)) == -1) {\n+\t\t\tif ((fifo->fd = open(fifo->name, O_RDWR | O_CLOEXEC | O_NONBLOCK | O_NOFOLLOW)) == -1) {\n \t\t\t\tlog_message(LOG_INFO, \"Unable to open %snotify fifo %s - errno %d\", type, fifo->name, errno);\n \t\t\t\tif (fifo->created_fifo) {\n \t\t\t\t\tunlink(fifo->name);",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\tif ((fifo->fd = open(fifo->name, O_RDWR | O_CLOEXEC | O_NONBLOCK)) == -1) {"
            ],
            "added_lines": [
                "\t\t\tif ((fifo->fd = open(fifo->name, O_RDWR | O_CLOEXEC | O_NONBLOCK | O_NOFOLLOW)) == -1) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-19044",
        "func_name": "acassen/keepalived/open_log_file",
        "description": "keepalived 2.0.8 didn't check for pathnames with symlinks when writing data to a temporary file upon a call to PrintData or PrintStats. This allowed local users to overwrite arbitrary files if fs.protected_symlinks is set to 0, as demonstrated by a symlink from /tmp/keepalived.data or /tmp/keepalived.stats to /etc/passwd.",
        "git_url": "https://github.com/acassen/keepalived/commit/04f2d32871bb3b11d7dc024039952f2fe2750306",
        "commit_title": "When opening files for write, ensure they aren't symbolic links",
        "commit_text": " Issue #1048 identified that if, for example, a non privileged user created a symbolic link from /etc/keepalvied.data to /etc/passwd, writing to /etc/keepalived.data (which could be invoked via DBus) would cause /etc/passwd to be overwritten.  This commit stops keepalived writing to pathnames where the ultimate component is a symbolic link, by setting O_NOFOLLOW whenever opening a file for writing.  This might break some setups, where, for example, /etc/keepalived.data was a symbolic link to /home/fred/keepalived.data. If this was the case, instead create a symbolic link from /home/fred/keepalived.data to /tmp/keepalived.data, so that the file is still accessible via /home/fred/keepalived.data.  There doesn't appear to be a way around this backward incompatibility, since even checking if the pathname is a symbolic link prior to opening for writing would create a race condition. ",
        "func_before": "void\nopen_log_file(const char *name, const char *prog, const char *namespace, const char *instance)\n{\n\tchar *file_name;\n\n\tif (log_file) {\n\t\tfclose(log_file);\n\t\tlog_file = NULL;\n\t}\n\n\tif (!name)\n\t\treturn;\n\n\tfile_name = make_file_name(name, prog, namespace, instance);\n\n\tlog_file = fopen(file_name, \"a\");\n\tif (log_file) {\n\t\tint n = fileno(log_file);\n\t\tfcntl(n, F_SETFD, FD_CLOEXEC | fcntl(n, F_GETFD));\n\t\tfcntl(n, F_SETFL, O_NONBLOCK | fcntl(n, F_GETFL));\n\t}\n\n\tFREE(file_name);\n}",
        "func": "void\nopen_log_file(const char *name, const char *prog, const char *namespace, const char *instance)\n{\n\tchar *file_name;\n\n\tif (log_file) {\n\t\tfclose(log_file);\n\t\tlog_file = NULL;\n\t}\n\n\tif (!name)\n\t\treturn;\n\n\tfile_name = make_file_name(name, prog, namespace, instance);\n\n\tlog_file = fopen_safe(file_name, \"a\");\n\tif (log_file) {\n\t\tint n = fileno(log_file);\n\t\tfcntl(n, F_SETFD, FD_CLOEXEC | fcntl(n, F_GETFD));\n\t\tfcntl(n, F_SETFL, O_NONBLOCK | fcntl(n, F_GETFL));\n\t}\n\n\tFREE(file_name);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -13,7 +13,7 @@\n \n \tfile_name = make_file_name(name, prog, namespace, instance);\n \n-\tlog_file = fopen(file_name, \"a\");\n+\tlog_file = fopen_safe(file_name, \"a\");\n \tif (log_file) {\n \t\tint n = fileno(log_file);\n \t\tfcntl(n, F_SETFD, FD_CLOEXEC | fcntl(n, F_GETFD));",
        "diff_line_info": {
            "deleted_lines": [
                "\tlog_file = fopen(file_name, \"a\");"
            ],
            "added_lines": [
                "\tlog_file = fopen_safe(file_name, \"a\");"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-19044",
        "func_name": "acassen/keepalived/write_stacktrace",
        "description": "keepalived 2.0.8 didn't check for pathnames with symlinks when writing data to a temporary file upon a call to PrintData or PrintStats. This allowed local users to overwrite arbitrary files if fs.protected_symlinks is set to 0, as demonstrated by a symlink from /tmp/keepalived.data or /tmp/keepalived.stats to /etc/passwd.",
        "git_url": "https://github.com/acassen/keepalived/commit/04f2d32871bb3b11d7dc024039952f2fe2750306",
        "commit_title": "When opening files for write, ensure they aren't symbolic links",
        "commit_text": " Issue #1048 identified that if, for example, a non privileged user created a symbolic link from /etc/keepalvied.data to /etc/passwd, writing to /etc/keepalived.data (which could be invoked via DBus) would cause /etc/passwd to be overwritten.  This commit stops keepalived writing to pathnames where the ultimate component is a symbolic link, by setting O_NOFOLLOW whenever opening a file for writing.  This might break some setups, where, for example, /etc/keepalived.data was a symbolic link to /home/fred/keepalived.data. If this was the case, instead create a symbolic link from /home/fred/keepalived.data to /tmp/keepalived.data, so that the file is still accessible via /home/fred/keepalived.data.  There doesn't appear to be a way around this backward incompatibility, since even checking if the pathname is a symbolic link prior to opening for writing would create a race condition. ",
        "func_before": "void\nwrite_stacktrace(const char *file_name, const char *str)\n{\n\tint fd;\n\tvoid *buffer[100];\n\tint nptrs;\n\tint i;\n\tchar **strs;\n\n\tnptrs = backtrace(buffer, 100);\n\tif (file_name) {\n\t\tfd = open(file_name, O_WRONLY | O_APPEND | O_CREAT, 0644);\n\t\tif (str)\n\t\t\tdprintf(fd, \"%s\\n\", str);\n\t\tbacktrace_symbols_fd(buffer, nptrs, fd);\n\t\tif (write(fd, \"\\n\", 1) != 1) {\n\t\t\t/* We don't care, but this stops a warning on Ubuntu */\n\t\t}\n\t\tclose(fd);\n\t} else {\n\t\tif (str)\n\t\t\tlog_message(LOG_INFO, \"%s\", str);\n\t\tstrs = backtrace_symbols(buffer, nptrs);\n\t\tif (strs == NULL) {\n\t\t\tlog_message(LOG_INFO, \"Unable to get stack backtrace\");\n\t\t\treturn;\n\t\t}\n\n\t\t/* We don't need the call to this function, or the first two entries on the stack */\n\t\tfor (i = 1; i < nptrs - 2; i++)\n\t\t\tlog_message(LOG_INFO, \"  %s\", strs[i]);\n\t\tfree(strs);\n\t}\n}",
        "func": "void\nwrite_stacktrace(const char *file_name, const char *str)\n{\n\tint fd;\n\tvoid *buffer[100];\n\tint nptrs;\n\tint i;\n\tchar **strs;\n\n\tnptrs = backtrace(buffer, 100);\n\tif (file_name) {\n\t\tfd = open(file_name, O_WRONLY | O_APPEND | O_CREAT | O_NOFOLLOW, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH);\n\t\tif (str)\n\t\t\tdprintf(fd, \"%s\\n\", str);\n\t\tbacktrace_symbols_fd(buffer, nptrs, fd);\n\t\tif (write(fd, \"\\n\", 1) != 1) {\n\t\t\t/* We don't care, but this stops a warning on Ubuntu */\n\t\t}\n\t\tclose(fd);\n\t} else {\n\t\tif (str)\n\t\t\tlog_message(LOG_INFO, \"%s\", str);\n\t\tstrs = backtrace_symbols(buffer, nptrs);\n\t\tif (strs == NULL) {\n\t\t\tlog_message(LOG_INFO, \"Unable to get stack backtrace\");\n\t\t\treturn;\n\t\t}\n\n\t\t/* We don't need the call to this function, or the first two entries on the stack */\n\t\tfor (i = 1; i < nptrs - 2; i++)\n\t\t\tlog_message(LOG_INFO, \"  %s\", strs[i]);\n\t\tfree(strs);\n\t}\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -9,7 +9,7 @@\n \n \tnptrs = backtrace(buffer, 100);\n \tif (file_name) {\n-\t\tfd = open(file_name, O_WRONLY | O_APPEND | O_CREAT, 0644);\n+\t\tfd = open(file_name, O_WRONLY | O_APPEND | O_CREAT | O_NOFOLLOW, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH);\n \t\tif (str)\n \t\t\tdprintf(fd, \"%s\\n\", str);\n \t\tbacktrace_symbols_fd(buffer, nptrs, fd);",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tfd = open(file_name, O_WRONLY | O_APPEND | O_CREAT, 0644);"
            ],
            "added_lines": [
                "\t\tfd = open(file_name, O_WRONLY | O_APPEND | O_CREAT | O_NOFOLLOW, S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH);"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-19044",
        "func_name": "acassen/keepalived/mem_log_init",
        "description": "keepalived 2.0.8 didn't check for pathnames with symlinks when writing data to a temporary file upon a call to PrintData or PrintStats. This allowed local users to overwrite arbitrary files if fs.protected_symlinks is set to 0, as demonstrated by a symlink from /tmp/keepalived.data or /tmp/keepalived.stats to /etc/passwd.",
        "git_url": "https://github.com/acassen/keepalived/commit/04f2d32871bb3b11d7dc024039952f2fe2750306",
        "commit_title": "When opening files for write, ensure they aren't symbolic links",
        "commit_text": " Issue #1048 identified that if, for example, a non privileged user created a symbolic link from /etc/keepalvied.data to /etc/passwd, writing to /etc/keepalived.data (which could be invoked via DBus) would cause /etc/passwd to be overwritten.  This commit stops keepalived writing to pathnames where the ultimate component is a symbolic link, by setting O_NOFOLLOW whenever opening a file for writing.  This might break some setups, where, for example, /etc/keepalived.data was a symbolic link to /home/fred/keepalived.data. If this was the case, instead create a symbolic link from /home/fred/keepalived.data to /tmp/keepalived.data, so that the file is still accessible via /home/fred/keepalived.data.  There doesn't appear to be a way around this backward incompatibility, since even checking if the pathname is a symbolic link prior to opening for writing would create a race condition. ",
        "func_before": "void\nmem_log_init(const char* prog_name, const char *banner)\n{\n\tsize_t log_name_len;\n\tchar *log_name;\n\n\tif (__test_bit(LOG_CONSOLE_BIT, &debug)) {\n\t\tlog_op = stderr;\n\t\treturn;\n\t}\n\n\tif (log_op)\n\t\tfclose(log_op);\n\n\tlog_name_len = 5 + strlen(prog_name) + 5 + 7 + 4 + 1;\t/* \"/tmp/\" + prog_name + \"_mem.\" + PID + \".log\" + '\\0\" */\n\tlog_name = malloc(log_name_len);\n\tif (!log_name) {\n\t\tlog_message(LOG_INFO, \"Unable to malloc log file name\");\n\t\tlog_op = stderr;\n\t\treturn;\n\t}\n\n\tsnprintf(log_name, log_name_len, \"/tmp/%s_mem.%d.log\", prog_name, getpid());\n\tlog_op = fopen(log_name, \"a\");\n\tif (log_op == NULL) {\n\t\tlog_message(LOG_INFO, \"Unable to open %s for appending\", log_name);\n\t\tlog_op = stderr;\n\t}\n\telse {\n\t\tint fd = fileno(log_op);\n\n\t\t/* We don't want any children to inherit the log file */\n\t\tfcntl(fd, F_SETFD, fcntl(fd, F_GETFD) | FD_CLOEXEC);\n\n\t\t/* Make the log output line buffered. This was to ensure that\n\t\t * children didn't inherit the buffer, but the CLOEXEC above\n\t\t * should resolve that. */\n\t\tsetlinebuf(log_op);\n\n\t\tfprintf(log_op, \"\\n\");\n\t}\n\n\tfree(log_name);\n\n\tterminate_banner = banner;\n}",
        "func": "void\nmem_log_init(const char* prog_name, const char *banner)\n{\n\tsize_t log_name_len;\n\tchar *log_name;\n\n\tif (__test_bit(LOG_CONSOLE_BIT, &debug)) {\n\t\tlog_op = stderr;\n\t\treturn;\n\t}\n\n\tif (log_op)\n\t\tfclose(log_op);\n\n\tlog_name_len = 5 + strlen(prog_name) + 5 + 7 + 4 + 1;\t/* \"/tmp/\" + prog_name + \"_mem.\" + PID + \".log\" + '\\0\" */\n\tlog_name = malloc(log_name_len);\n\tif (!log_name) {\n\t\tlog_message(LOG_INFO, \"Unable to malloc log file name\");\n\t\tlog_op = stderr;\n\t\treturn;\n\t}\n\n\tsnprintf(log_name, log_name_len, \"/tmp/%s_mem.%d.log\", prog_name, getpid());\n\tlog_op = fopen_safe(log_name, \"a\");\n\tif (log_op == NULL) {\n\t\tlog_message(LOG_INFO, \"Unable to open %s for appending\", log_name);\n\t\tlog_op = stderr;\n\t}\n\telse {\n\t\tint fd = fileno(log_op);\n\n\t\t/* We don't want any children to inherit the log file */\n\t\tfcntl(fd, F_SETFD, fcntl(fd, F_GETFD) | FD_CLOEXEC);\n\n\t\t/* Make the log output line buffered. This was to ensure that\n\t\t * children didn't inherit the buffer, but the CLOEXEC above\n\t\t * should resolve that. */\n\t\tsetlinebuf(log_op);\n\n\t\tfprintf(log_op, \"\\n\");\n\t}\n\n\tfree(log_name);\n\n\tterminate_banner = banner;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -21,7 +21,7 @@\n \t}\n \n \tsnprintf(log_name, log_name_len, \"/tmp/%s_mem.%d.log\", prog_name, getpid());\n-\tlog_op = fopen(log_name, \"a\");\n+\tlog_op = fopen_safe(log_name, \"a\");\n \tif (log_op == NULL) {\n \t\tlog_message(LOG_INFO, \"Unable to open %s for appending\", log_name);\n \t\tlog_op = stderr;",
        "diff_line_info": {
            "deleted_lines": [
                "\tlog_op = fopen(log_name, \"a\");"
            ],
            "added_lines": [
                "\tlog_op = fopen_safe(log_name, \"a\");"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-19044",
        "func_name": "acassen/keepalived/parse_cmdline",
        "description": "keepalived 2.0.8 didn't check for pathnames with symlinks when writing data to a temporary file upon a call to PrintData or PrintStats. This allowed local users to overwrite arbitrary files if fs.protected_symlinks is set to 0, as demonstrated by a symlink from /tmp/keepalived.data or /tmp/keepalived.stats to /etc/passwd.",
        "git_url": "https://github.com/acassen/keepalived/commit/04f2d32871bb3b11d7dc024039952f2fe2750306",
        "commit_title": "When opening files for write, ensure they aren't symbolic links",
        "commit_text": " Issue #1048 identified that if, for example, a non privileged user created a symbolic link from /etc/keepalvied.data to /etc/passwd, writing to /etc/keepalived.data (which could be invoked via DBus) would cause /etc/passwd to be overwritten.  This commit stops keepalived writing to pathnames where the ultimate component is a symbolic link, by setting O_NOFOLLOW whenever opening a file for writing.  This might break some setups, where, for example, /etc/keepalived.data was a symbolic link to /home/fred/keepalived.data. If this was the case, instead create a symbolic link from /home/fred/keepalived.data to /tmp/keepalived.data, so that the file is still accessible via /home/fred/keepalived.data.  There doesn't appear to be a way around this backward incompatibility, since even checking if the pathname is a symbolic link prior to opening for writing would create a race condition. ",
        "func_before": "static bool\nparse_cmdline(int argc, char **argv)\n{\n\tint c;\n\tbool reopen_log = false;\n\tint signum;\n\tstruct utsname uname_buf;\n\tint longindex;\n\tint curind;\n\tbool bad_option = false;\n\tunsigned facility;\n\tmode_t new_umask_val;\n\n\tstruct option long_options[] = {\n\t\t{\"use-file\",\t\trequired_argument,\tNULL, 'f'},\n#if defined _WITH_VRRP_ && defined _WITH_LVS_\n\t\t{\"vrrp\",\t\tno_argument,\t\tNULL, 'P'},\n\t\t{\"check\",\t\tno_argument,\t\tNULL, 'C'},\n#endif\n#ifdef _WITH_BFD_\n\t\t{\"no_bfd\",\t\tno_argument,\t\tNULL, 'B'},\n#endif\n\t\t{\"all\",\t\t\tno_argument,\t\tNULL,  3 },\n\t\t{\"log-console\",\t\tno_argument,\t\tNULL, 'l'},\n\t\t{\"log-detail\",\t\tno_argument,\t\tNULL, 'D'},\n\t\t{\"log-facility\",\trequired_argument,\tNULL, 'S'},\n\t\t{\"log-file\",\t\toptional_argument,\tNULL, 'g'},\n\t\t{\"flush-log-file\",\tno_argument,\t\tNULL,  2 },\n\t\t{\"no-syslog\",\t\tno_argument,\t\tNULL, 'G'},\n\t\t{\"umask\",\t\trequired_argument,\tNULL, 'u'},\n#ifdef _WITH_VRRP_\n\t\t{\"release-vips\",\tno_argument,\t\tNULL, 'X'},\n\t\t{\"dont-release-vrrp\",\tno_argument,\t\tNULL, 'V'},\n#endif\n#ifdef _WITH_LVS_\n\t\t{\"dont-release-ipvs\",\tno_argument,\t\tNULL, 'I'},\n#endif\n\t\t{\"dont-respawn\",\tno_argument,\t\tNULL, 'R'},\n\t\t{\"dont-fork\",\t\tno_argument,\t\tNULL, 'n'},\n\t\t{\"dump-conf\",\t\tno_argument,\t\tNULL, 'd'},\n\t\t{\"pid\",\t\t\trequired_argument,\tNULL, 'p'},\n#ifdef _WITH_VRRP_\n\t\t{\"vrrp_pid\",\t\trequired_argument,\tNULL, 'r'},\n#endif\n#ifdef _WITH_LVS_\n\t\t{\"checkers_pid\",\trequired_argument,\tNULL, 'c'},\n\t\t{\"address-monitoring\",\tno_argument,\t\tNULL, 'a'},\n#endif\n#ifdef _WITH_BFD_\n\t\t{\"bfd_pid\",\t\trequired_argument,\tNULL, 'b'},\n#endif\n#ifdef _WITH_SNMP_\n\t\t{\"snmp\",\t\tno_argument,\t\tNULL, 'x'},\n\t\t{\"snmp-agent-socket\",\trequired_argument,\tNULL, 'A'},\n#endif\n\t\t{\"core-dump\",\t\tno_argument,\t\tNULL, 'm'},\n\t\t{\"core-dump-pattern\",\toptional_argument,\tNULL, 'M'},\n#ifdef _MEM_CHECK_LOG_\n\t\t{\"mem-check-log\",\tno_argument,\t\tNULL, 'L'},\n#endif\n#if HAVE_DECL_CLONE_NEWNET\n\t\t{\"namespace\",\t\trequired_argument,\tNULL, 's'},\n#endif\n\t\t{\"config-id\",\t\trequired_argument,\tNULL, 'i'},\n\t\t{\"signum\",\t\trequired_argument,\tNULL,  4 },\n\t\t{\"config-test\",\t\toptional_argument,\tNULL, 't'},\n#ifdef _WITH_PERF_\n\t\t{\"perf\",\t\toptional_argument,\tNULL,  5 },\n#endif\n#ifdef WITH_DEBUG_OPTIONS\n\t\t{\"debug\",\t\toptional_argument,\tNULL,  6 },\n#endif\n\t\t{\"version\",\t\tno_argument,\t\tNULL, 'v'},\n\t\t{\"help\",\t\tno_argument,\t\tNULL, 'h'},\n\n\t\t{NULL,\t\t\t0,\t\t\tNULL,  0 }\n\t};\n\n\t/* Unfortunately, if a short option is used, getopt_long() doesn't change the value\n\t * of longindex, so we need to ensure that before calling getopt_long(), longindex\n\t * is set to a known invalid value */\n\tcurind = optind;\n\twhile (longindex = -1, (c = getopt_long(argc, argv, \":vhlndu:DRS:f:p:i:mM::g::Gt::\"\n#if defined _WITH_VRRP_ && defined _WITH_LVS_\n\t\t\t\t\t    \"PC\"\n#endif\n#ifdef _WITH_VRRP_\n\t\t\t\t\t    \"r:VX\"\n#endif\n#ifdef _WITH_LVS_\n\t\t\t\t\t    \"ac:I\"\n#endif\n#ifdef _WITH_BFD_\n\t\t\t\t\t    \"Bb:\"\n#endif\n#ifdef _WITH_SNMP_\n\t\t\t\t\t    \"xA:\"\n#endif\n#ifdef _MEM_CHECK_LOG_\n\t\t\t\t\t    \"L\"\n#endif\n#if HAVE_DECL_CLONE_NEWNET\n\t\t\t\t\t    \"s:\"\n#endif\n\t\t\t\t, long_options, &longindex)) != -1) {\n\n\t\t/* Check for an empty option argument. For example --use-file= returns\n\t\t * a 0 length option, which we don't want */\n\t\tif (longindex >= 0 && long_options[longindex].has_arg == required_argument && optarg && !optarg[0]) {\n\t\t\tc = ':';\n\t\t\toptarg = NULL;\n\t\t}\n\n\t\tswitch (c) {\n\t\tcase 'v':\n\t\t\tfprintf(stderr, \"%s\", version_string);\n#ifdef GIT_COMMIT\n\t\t\tfprintf(stderr, \", git commit %s\", GIT_COMMIT);\n#endif\n\t\t\tfprintf(stderr, \"\\n\\n%s\\n\\n\", COPYRIGHT_STRING);\n\t\t\tfprintf(stderr, \"Built with kernel headers for Linux %d.%d.%d\\n\",\n\t\t\t\t\t\t(LINUX_VERSION_CODE >> 16) & 0xff,\n\t\t\t\t\t\t(LINUX_VERSION_CODE >>  8) & 0xff,\n\t\t\t\t\t\t(LINUX_VERSION_CODE      ) & 0xff);\n\t\t\tuname(&uname_buf);\n\t\t\tfprintf(stderr, \"Running on %s %s %s\\n\\n\", uname_buf.sysname, uname_buf.release, uname_buf.version);\n\t\t\tfprintf(stderr, \"configure options: %s\\n\\n\", KEEPALIVED_CONFIGURE_OPTIONS);\n\t\t\tfprintf(stderr, \"Config options: %s\\n\\n\", CONFIGURATION_OPTIONS);\n\t\t\tfprintf(stderr, \"System options: %s\\n\", SYSTEM_OPTIONS);\n\t\t\texit(0);\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tusage(argv[0]);\n\t\t\texit(0);\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\t__set_bit(LOG_CONSOLE_BIT, &debug);\n\t\t\treopen_log = true;\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\t__set_bit(DONT_FORK_BIT, &debug);\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\t__set_bit(DUMP_CONF_BIT, &debug);\n\t\t\tbreak;\n#ifdef _WITH_VRRP_\n\t\tcase 'V':\n\t\t\t__set_bit(DONT_RELEASE_VRRP_BIT, &debug);\n\t\t\tbreak;\n#endif\n#ifdef _WITH_LVS_\n\t\tcase 'I':\n\t\t\t__set_bit(DONT_RELEASE_IPVS_BIT, &debug);\n\t\t\tbreak;\n#endif\n\t\tcase 'D':\n\t\t\tif (__test_bit(LOG_DETAIL_BIT, &debug))\n\t\t\t\t__set_bit(LOG_EXTRA_DETAIL_BIT, &debug);\n\t\t\telse\n\t\t\t\t__set_bit(LOG_DETAIL_BIT, &debug);\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\t__set_bit(DONT_RESPAWN_BIT, &debug);\n\t\t\tbreak;\n#ifdef _WITH_VRRP_\n\t\tcase 'X':\n\t\t\t__set_bit(RELEASE_VIPS_BIT, &debug);\n\t\t\tbreak;\n#endif\n\t\tcase 'S':\n\t\t\tif (!read_unsigned(optarg, &facility, 0, LOG_FACILITY_MAX, false))\n\t\t\t\tfprintf(stderr, \"Invalid log facility '%s'\\n\", optarg);\n\t\t\telse {\n\t\t\t\tlog_facility = LOG_FACILITY[facility].facility;\n\t\t\t\treopen_log = true;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'g':\n\t\t\tif (optarg && optarg[0])\n\t\t\t\tlog_file_name = optarg;\n\t\t\telse\n\t\t\t\tlog_file_name = \"/tmp/keepalived.log\";\n\t\t\topen_log_file(log_file_name, NULL, NULL, NULL);\n\t\t\tbreak;\n\t\tcase 'G':\n\t\t\t__set_bit(NO_SYSLOG_BIT, &debug);\n\t\t\treopen_log = true;\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\tnew_umask_val = set_umask(optarg);\n\t\t\tif (umask_cmdline)\n\t\t\t\tumask_val = new_umask_val;\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\t__set_bit(CONFIG_TEST_BIT, &debug);\n\t\t\t__set_bit(DONT_RESPAWN_BIT, &debug);\n\t\t\t__set_bit(DONT_FORK_BIT, &debug);\n\t\t\t__set_bit(NO_SYSLOG_BIT, &debug);\n\t\t\tif (optarg && optarg[0]) {\n\t\t\t\tint fd = open(optarg, O_WRONLY | O_APPEND | O_CREAT, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n\t\t\t\tif (fd == -1) {\n\t\t\t\t\tfprintf(stderr, \"Unable to open config-test log file %s\\n\", optarg);\n\t\t\t\t\texit(EXIT_FAILURE);\n\t\t\t\t}\n\t\t\t\tdup2(fd, STDERR_FILENO);\n\t\t\t\tclose(fd);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tconf_file = optarg;\n\t\t\tbreak;\n\t\tcase 2:\t\t/* --flush-log-file */\n\t\t\tset_flush_log_file();\n\t\t\tbreak;\n#if defined _WITH_VRRP_ && defined _WITH_LVS_\n\t\tcase 'P':\n\t\t\t__clear_bit(DAEMON_CHECKERS, &daemon_mode);\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\t__clear_bit(DAEMON_VRRP, &daemon_mode);\n\t\t\tbreak;\n#endif\n#ifdef _WITH_BFD_\n\t\tcase 'B':\n\t\t\t__clear_bit(DAEMON_BFD, &daemon_mode);\n\t\t\tbreak;\n#endif\n\t\tcase 'p':\n\t\t\tmain_pidfile = optarg;\n\t\t\tbreak;\n#ifdef _WITH_LVS_\n\t\tcase 'c':\n\t\t\tcheckers_pidfile = optarg;\n\t\t\tbreak;\n\t\tcase 'a':\n\t\t\t__set_bit(LOG_ADDRESS_CHANGES, &debug);\n\t\t\tbreak;\n#endif\n#ifdef _WITH_VRRP_\n\t\tcase 'r':\n\t\t\tvrrp_pidfile = optarg;\n\t\t\tbreak;\n#endif\n#ifdef _WITH_BFD_\n\t\tcase 'b':\n\t\t\tbfd_pidfile = optarg;\n\t\t\tbreak;\n#endif\n#ifdef _WITH_SNMP_\n\t\tcase 'x':\n\t\t\tsnmp = 1;\n\t\t\tbreak;\n\t\tcase 'A':\n\t\t\tsnmp_socket = optarg;\n\t\t\tbreak;\n#endif\n\t\tcase 'M':\n\t\t\tset_core_dump_pattern = true;\n\t\t\tif (optarg && optarg[0])\n\t\t\t\tcore_dump_pattern = optarg;\n\t\t\t/* ... falls through ... */\n\t\tcase 'm':\n\t\t\tcreate_core_dump = true;\n\t\t\tbreak;\n#ifdef _MEM_CHECK_LOG_\n\t\tcase 'L':\n\t\t\t__set_bit(MEM_CHECK_LOG_BIT, &debug);\n\t\t\tbreak;\n#endif\n#if HAVE_DECL_CLONE_NEWNET\n\t\tcase 's':\n\t\t\toverride_namespace = MALLOC(strlen(optarg) + 1);\n\t\t\tstrcpy(override_namespace, optarg);\n\t\t\tbreak;\n#endif\n\t\tcase 'i':\n\t\t\tFREE_PTR(config_id);\n\t\t\tconfig_id = MALLOC(strlen(optarg) + 1);\n\t\t\tstrcpy(config_id, optarg);\n\t\t\tbreak;\n\t\tcase 4:\t\t\t/* --signum */\n\t\t\tsignum = get_signum(optarg);\n\t\t\tif (signum == -1) {\n\t\t\t\tfprintf(stderr, \"Unknown sigfunc %s\\n\", optarg);\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tprintf(\"%d\\n\", signum);\n\t\t\texit(0);\n\t\t\tbreak;\n\t\tcase 3:\t\t\t/* --all */\n\t\t\t__set_bit(RUN_ALL_CHILDREN, &daemon_mode);\n#ifdef _WITH_VRRP_\n\t\t\t__set_bit(DAEMON_VRRP, &daemon_mode);\n#endif\n#ifdef _WITH_LVS_\n\t\t\t__set_bit(DAEMON_CHECKERS, &daemon_mode);\n#endif\n#ifdef _WITH_BFD_\n\t\t\t__set_bit(DAEMON_BFD, &daemon_mode);\n#endif\n\t\t\tbreak;\n#ifdef _WITH_PERF_\n\t\tcase 5:\n\t\t\tif (optarg && optarg[0]) {\n\t\t\t\tif (!strcmp(optarg, \"run\"))\n\t\t\t\t\tperf_run = PERF_RUN;\n\t\t\t\telse if (!strcmp(optarg, \"all\"))\n\t\t\t\t\tperf_run = PERF_ALL;\n\t\t\t\telse if (!strcmp(optarg, \"end\"))\n\t\t\t\t\tperf_run = PERF_END;\n\t\t\t\telse\n\t\t\t\t\tlog_message(LOG_INFO, \"Unknown perf start point %s\", optarg);\n\t\t\t}\n\t\t\telse\n\t\t\t\tperf_run = PERF_RUN;\n\n\t\t\tbreak;\n#endif\n#ifdef WITH_DEBUG_OPTIONS\n\t\tcase 6:\n\t\t\tset_debug_options(optarg && optarg[0] ? optarg : NULL);\n\t\t\tbreak;\n#endif\n\t\tcase '?':\n\t\t\tif (optopt && argv[curind][1] != '-')\n\t\t\t\tfprintf(stderr, \"Unknown option -%c\\n\", optopt);\n\t\t\telse\n\t\t\t\tfprintf(stderr, \"Unknown option %s\\n\", argv[curind]);\n\t\t\tbad_option = true;\n\t\t\tbreak;\n\t\tcase ':':\n\t\t\tif (optopt && argv[curind][1] != '-')\n\t\t\t\tfprintf(stderr, \"Missing parameter for option -%c\\n\", optopt);\n\t\t\telse\n\t\t\t\tfprintf(stderr, \"Missing parameter for option --%s\\n\", long_options[longindex].name);\n\t\t\tbad_option = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\texit(1);\n\t\t\tbreak;\n\t\t}\n\t\tcurind = optind;\n\t}\n\n\tif (optind < argc) {\n\t\tprintf(\"Unexpected argument(s): \");\n\t\twhile (optind < argc)\n\t\t\tprintf(\"%s \", argv[optind++]);\n\t\tprintf(\"\\n\");\n\t}\n\n\tif (bad_option)\n\t\texit(1);\n\n\treturn reopen_log;\n}",
        "func": "static bool\nparse_cmdline(int argc, char **argv)\n{\n\tint c;\n\tbool reopen_log = false;\n\tint signum;\n\tstruct utsname uname_buf;\n\tint longindex;\n\tint curind;\n\tbool bad_option = false;\n\tunsigned facility;\n\tmode_t new_umask_val;\n\n\tstruct option long_options[] = {\n\t\t{\"use-file\",\t\trequired_argument,\tNULL, 'f'},\n#if defined _WITH_VRRP_ && defined _WITH_LVS_\n\t\t{\"vrrp\",\t\tno_argument,\t\tNULL, 'P'},\n\t\t{\"check\",\t\tno_argument,\t\tNULL, 'C'},\n#endif\n#ifdef _WITH_BFD_\n\t\t{\"no_bfd\",\t\tno_argument,\t\tNULL, 'B'},\n#endif\n\t\t{\"all\",\t\t\tno_argument,\t\tNULL,  3 },\n\t\t{\"log-console\",\t\tno_argument,\t\tNULL, 'l'},\n\t\t{\"log-detail\",\t\tno_argument,\t\tNULL, 'D'},\n\t\t{\"log-facility\",\trequired_argument,\tNULL, 'S'},\n\t\t{\"log-file\",\t\toptional_argument,\tNULL, 'g'},\n\t\t{\"flush-log-file\",\tno_argument,\t\tNULL,  2 },\n\t\t{\"no-syslog\",\t\tno_argument,\t\tNULL, 'G'},\n\t\t{\"umask\",\t\trequired_argument,\tNULL, 'u'},\n#ifdef _WITH_VRRP_\n\t\t{\"release-vips\",\tno_argument,\t\tNULL, 'X'},\n\t\t{\"dont-release-vrrp\",\tno_argument,\t\tNULL, 'V'},\n#endif\n#ifdef _WITH_LVS_\n\t\t{\"dont-release-ipvs\",\tno_argument,\t\tNULL, 'I'},\n#endif\n\t\t{\"dont-respawn\",\tno_argument,\t\tNULL, 'R'},\n\t\t{\"dont-fork\",\t\tno_argument,\t\tNULL, 'n'},\n\t\t{\"dump-conf\",\t\tno_argument,\t\tNULL, 'd'},\n\t\t{\"pid\",\t\t\trequired_argument,\tNULL, 'p'},\n#ifdef _WITH_VRRP_\n\t\t{\"vrrp_pid\",\t\trequired_argument,\tNULL, 'r'},\n#endif\n#ifdef _WITH_LVS_\n\t\t{\"checkers_pid\",\trequired_argument,\tNULL, 'c'},\n\t\t{\"address-monitoring\",\tno_argument,\t\tNULL, 'a'},\n#endif\n#ifdef _WITH_BFD_\n\t\t{\"bfd_pid\",\t\trequired_argument,\tNULL, 'b'},\n#endif\n#ifdef _WITH_SNMP_\n\t\t{\"snmp\",\t\tno_argument,\t\tNULL, 'x'},\n\t\t{\"snmp-agent-socket\",\trequired_argument,\tNULL, 'A'},\n#endif\n\t\t{\"core-dump\",\t\tno_argument,\t\tNULL, 'm'},\n\t\t{\"core-dump-pattern\",\toptional_argument,\tNULL, 'M'},\n#ifdef _MEM_CHECK_LOG_\n\t\t{\"mem-check-log\",\tno_argument,\t\tNULL, 'L'},\n#endif\n#if HAVE_DECL_CLONE_NEWNET\n\t\t{\"namespace\",\t\trequired_argument,\tNULL, 's'},\n#endif\n\t\t{\"config-id\",\t\trequired_argument,\tNULL, 'i'},\n\t\t{\"signum\",\t\trequired_argument,\tNULL,  4 },\n\t\t{\"config-test\",\t\toptional_argument,\tNULL, 't'},\n#ifdef _WITH_PERF_\n\t\t{\"perf\",\t\toptional_argument,\tNULL,  5 },\n#endif\n#ifdef WITH_DEBUG_OPTIONS\n\t\t{\"debug\",\t\toptional_argument,\tNULL,  6 },\n#endif\n\t\t{\"version\",\t\tno_argument,\t\tNULL, 'v'},\n\t\t{\"help\",\t\tno_argument,\t\tNULL, 'h'},\n\n\t\t{NULL,\t\t\t0,\t\t\tNULL,  0 }\n\t};\n\n\t/* Unfortunately, if a short option is used, getopt_long() doesn't change the value\n\t * of longindex, so we need to ensure that before calling getopt_long(), longindex\n\t * is set to a known invalid value */\n\tcurind = optind;\n\twhile (longindex = -1, (c = getopt_long(argc, argv, \":vhlndu:DRS:f:p:i:mM::g::Gt::\"\n#if defined _WITH_VRRP_ && defined _WITH_LVS_\n\t\t\t\t\t    \"PC\"\n#endif\n#ifdef _WITH_VRRP_\n\t\t\t\t\t    \"r:VX\"\n#endif\n#ifdef _WITH_LVS_\n\t\t\t\t\t    \"ac:I\"\n#endif\n#ifdef _WITH_BFD_\n\t\t\t\t\t    \"Bb:\"\n#endif\n#ifdef _WITH_SNMP_\n\t\t\t\t\t    \"xA:\"\n#endif\n#ifdef _MEM_CHECK_LOG_\n\t\t\t\t\t    \"L\"\n#endif\n#if HAVE_DECL_CLONE_NEWNET\n\t\t\t\t\t    \"s:\"\n#endif\n\t\t\t\t, long_options, &longindex)) != -1) {\n\n\t\t/* Check for an empty option argument. For example --use-file= returns\n\t\t * a 0 length option, which we don't want */\n\t\tif (longindex >= 0 && long_options[longindex].has_arg == required_argument && optarg && !optarg[0]) {\n\t\t\tc = ':';\n\t\t\toptarg = NULL;\n\t\t}\n\n\t\tswitch (c) {\n\t\tcase 'v':\n\t\t\tfprintf(stderr, \"%s\", version_string);\n#ifdef GIT_COMMIT\n\t\t\tfprintf(stderr, \", git commit %s\", GIT_COMMIT);\n#endif\n\t\t\tfprintf(stderr, \"\\n\\n%s\\n\\n\", COPYRIGHT_STRING);\n\t\t\tfprintf(stderr, \"Built with kernel headers for Linux %d.%d.%d\\n\",\n\t\t\t\t\t\t(LINUX_VERSION_CODE >> 16) & 0xff,\n\t\t\t\t\t\t(LINUX_VERSION_CODE >>  8) & 0xff,\n\t\t\t\t\t\t(LINUX_VERSION_CODE      ) & 0xff);\n\t\t\tuname(&uname_buf);\n\t\t\tfprintf(stderr, \"Running on %s %s %s\\n\\n\", uname_buf.sysname, uname_buf.release, uname_buf.version);\n\t\t\tfprintf(stderr, \"configure options: %s\\n\\n\", KEEPALIVED_CONFIGURE_OPTIONS);\n\t\t\tfprintf(stderr, \"Config options: %s\\n\\n\", CONFIGURATION_OPTIONS);\n\t\t\tfprintf(stderr, \"System options: %s\\n\", SYSTEM_OPTIONS);\n\t\t\texit(0);\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\tusage(argv[0]);\n\t\t\texit(0);\n\t\t\tbreak;\n\t\tcase 'l':\n\t\t\t__set_bit(LOG_CONSOLE_BIT, &debug);\n\t\t\treopen_log = true;\n\t\t\tbreak;\n\t\tcase 'n':\n\t\t\t__set_bit(DONT_FORK_BIT, &debug);\n\t\t\tbreak;\n\t\tcase 'd':\n\t\t\t__set_bit(DUMP_CONF_BIT, &debug);\n\t\t\tbreak;\n#ifdef _WITH_VRRP_\n\t\tcase 'V':\n\t\t\t__set_bit(DONT_RELEASE_VRRP_BIT, &debug);\n\t\t\tbreak;\n#endif\n#ifdef _WITH_LVS_\n\t\tcase 'I':\n\t\t\t__set_bit(DONT_RELEASE_IPVS_BIT, &debug);\n\t\t\tbreak;\n#endif\n\t\tcase 'D':\n\t\t\tif (__test_bit(LOG_DETAIL_BIT, &debug))\n\t\t\t\t__set_bit(LOG_EXTRA_DETAIL_BIT, &debug);\n\t\t\telse\n\t\t\t\t__set_bit(LOG_DETAIL_BIT, &debug);\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\t__set_bit(DONT_RESPAWN_BIT, &debug);\n\t\t\tbreak;\n#ifdef _WITH_VRRP_\n\t\tcase 'X':\n\t\t\t__set_bit(RELEASE_VIPS_BIT, &debug);\n\t\t\tbreak;\n#endif\n\t\tcase 'S':\n\t\t\tif (!read_unsigned(optarg, &facility, 0, LOG_FACILITY_MAX, false))\n\t\t\t\tfprintf(stderr, \"Invalid log facility '%s'\\n\", optarg);\n\t\t\telse {\n\t\t\t\tlog_facility = LOG_FACILITY[facility].facility;\n\t\t\t\treopen_log = true;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'g':\n\t\t\tif (optarg && optarg[0])\n\t\t\t\tlog_file_name = optarg;\n\t\t\telse\n\t\t\t\tlog_file_name = \"/tmp/keepalived.log\";\n\t\t\topen_log_file(log_file_name, NULL, NULL, NULL);\n\t\t\tbreak;\n\t\tcase 'G':\n\t\t\t__set_bit(NO_SYSLOG_BIT, &debug);\n\t\t\treopen_log = true;\n\t\t\tbreak;\n\t\tcase 'u':\n\t\t\tnew_umask_val = set_umask(optarg);\n\t\t\tif (umask_cmdline)\n\t\t\t\tumask_val = new_umask_val;\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\t__set_bit(CONFIG_TEST_BIT, &debug);\n\t\t\t__set_bit(DONT_RESPAWN_BIT, &debug);\n\t\t\t__set_bit(DONT_FORK_BIT, &debug);\n\t\t\t__set_bit(NO_SYSLOG_BIT, &debug);\n\t\t\tif (optarg && optarg[0]) {\n\t\t\t\tint fd = open(optarg, O_WRONLY | O_APPEND | O_CREAT | O_NOFOLLOW, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n\t\t\t\tif (fd == -1) {\n\t\t\t\t\tfprintf(stderr, \"Unable to open config-test log file %s\\n\", optarg);\n\t\t\t\t\texit(EXIT_FAILURE);\n\t\t\t\t}\n\t\t\t\tdup2(fd, STDERR_FILENO);\n\t\t\t\tclose(fd);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tconf_file = optarg;\n\t\t\tbreak;\n\t\tcase 2:\t\t/* --flush-log-file */\n\t\t\tset_flush_log_file();\n\t\t\tbreak;\n#if defined _WITH_VRRP_ && defined _WITH_LVS_\n\t\tcase 'P':\n\t\t\t__clear_bit(DAEMON_CHECKERS, &daemon_mode);\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\t__clear_bit(DAEMON_VRRP, &daemon_mode);\n\t\t\tbreak;\n#endif\n#ifdef _WITH_BFD_\n\t\tcase 'B':\n\t\t\t__clear_bit(DAEMON_BFD, &daemon_mode);\n\t\t\tbreak;\n#endif\n\t\tcase 'p':\n\t\t\tmain_pidfile = optarg;\n\t\t\tbreak;\n#ifdef _WITH_LVS_\n\t\tcase 'c':\n\t\t\tcheckers_pidfile = optarg;\n\t\t\tbreak;\n\t\tcase 'a':\n\t\t\t__set_bit(LOG_ADDRESS_CHANGES, &debug);\n\t\t\tbreak;\n#endif\n#ifdef _WITH_VRRP_\n\t\tcase 'r':\n\t\t\tvrrp_pidfile = optarg;\n\t\t\tbreak;\n#endif\n#ifdef _WITH_BFD_\n\t\tcase 'b':\n\t\t\tbfd_pidfile = optarg;\n\t\t\tbreak;\n#endif\n#ifdef _WITH_SNMP_\n\t\tcase 'x':\n\t\t\tsnmp = 1;\n\t\t\tbreak;\n\t\tcase 'A':\n\t\t\tsnmp_socket = optarg;\n\t\t\tbreak;\n#endif\n\t\tcase 'M':\n\t\t\tset_core_dump_pattern = true;\n\t\t\tif (optarg && optarg[0])\n\t\t\t\tcore_dump_pattern = optarg;\n\t\t\t/* ... falls through ... */\n\t\tcase 'm':\n\t\t\tcreate_core_dump = true;\n\t\t\tbreak;\n#ifdef _MEM_CHECK_LOG_\n\t\tcase 'L':\n\t\t\t__set_bit(MEM_CHECK_LOG_BIT, &debug);\n\t\t\tbreak;\n#endif\n#if HAVE_DECL_CLONE_NEWNET\n\t\tcase 's':\n\t\t\toverride_namespace = MALLOC(strlen(optarg) + 1);\n\t\t\tstrcpy(override_namespace, optarg);\n\t\t\tbreak;\n#endif\n\t\tcase 'i':\n\t\t\tFREE_PTR(config_id);\n\t\t\tconfig_id = MALLOC(strlen(optarg) + 1);\n\t\t\tstrcpy(config_id, optarg);\n\t\t\tbreak;\n\t\tcase 4:\t\t\t/* --signum */\n\t\t\tsignum = get_signum(optarg);\n\t\t\tif (signum == -1) {\n\t\t\t\tfprintf(stderr, \"Unknown sigfunc %s\\n\", optarg);\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tprintf(\"%d\\n\", signum);\n\t\t\texit(0);\n\t\t\tbreak;\n\t\tcase 3:\t\t\t/* --all */\n\t\t\t__set_bit(RUN_ALL_CHILDREN, &daemon_mode);\n#ifdef _WITH_VRRP_\n\t\t\t__set_bit(DAEMON_VRRP, &daemon_mode);\n#endif\n#ifdef _WITH_LVS_\n\t\t\t__set_bit(DAEMON_CHECKERS, &daemon_mode);\n#endif\n#ifdef _WITH_BFD_\n\t\t\t__set_bit(DAEMON_BFD, &daemon_mode);\n#endif\n\t\t\tbreak;\n#ifdef _WITH_PERF_\n\t\tcase 5:\n\t\t\tif (optarg && optarg[0]) {\n\t\t\t\tif (!strcmp(optarg, \"run\"))\n\t\t\t\t\tperf_run = PERF_RUN;\n\t\t\t\telse if (!strcmp(optarg, \"all\"))\n\t\t\t\t\tperf_run = PERF_ALL;\n\t\t\t\telse if (!strcmp(optarg, \"end\"))\n\t\t\t\t\tperf_run = PERF_END;\n\t\t\t\telse\n\t\t\t\t\tlog_message(LOG_INFO, \"Unknown perf start point %s\", optarg);\n\t\t\t}\n\t\t\telse\n\t\t\t\tperf_run = PERF_RUN;\n\n\t\t\tbreak;\n#endif\n#ifdef WITH_DEBUG_OPTIONS\n\t\tcase 6:\n\t\t\tset_debug_options(optarg && optarg[0] ? optarg : NULL);\n\t\t\tbreak;\n#endif\n\t\tcase '?':\n\t\t\tif (optopt && argv[curind][1] != '-')\n\t\t\t\tfprintf(stderr, \"Unknown option -%c\\n\", optopt);\n\t\t\telse\n\t\t\t\tfprintf(stderr, \"Unknown option %s\\n\", argv[curind]);\n\t\t\tbad_option = true;\n\t\t\tbreak;\n\t\tcase ':':\n\t\t\tif (optopt && argv[curind][1] != '-')\n\t\t\t\tfprintf(stderr, \"Missing parameter for option -%c\\n\", optopt);\n\t\t\telse\n\t\t\t\tfprintf(stderr, \"Missing parameter for option --%s\\n\", long_options[longindex].name);\n\t\t\tbad_option = true;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\texit(1);\n\t\t\tbreak;\n\t\t}\n\t\tcurind = optind;\n\t}\n\n\tif (optind < argc) {\n\t\tprintf(\"Unexpected argument(s): \");\n\t\twhile (optind < argc)\n\t\t\tprintf(\"%s \", argv[optind++]);\n\t\tprintf(\"\\n\");\n\t}\n\n\tif (bad_option)\n\t\texit(1);\n\n\treturn reopen_log;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -197,7 +197,7 @@\n \t\t\t__set_bit(DONT_FORK_BIT, &debug);\n \t\t\t__set_bit(NO_SYSLOG_BIT, &debug);\n \t\t\tif (optarg && optarg[0]) {\n-\t\t\t\tint fd = open(optarg, O_WRONLY | O_APPEND | O_CREAT, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n+\t\t\t\tint fd = open(optarg, O_WRONLY | O_APPEND | O_CREAT | O_NOFOLLOW, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);\n \t\t\t\tif (fd == -1) {\n \t\t\t\t\tfprintf(stderr, \"Unable to open config-test log file %s\\n\", optarg);\n \t\t\t\t\texit(EXIT_FAILURE);",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\t\tint fd = open(optarg, O_WRONLY | O_APPEND | O_CREAT, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);"
            ],
            "added_lines": [
                "\t\t\t\tint fd = open(optarg, O_WRONLY | O_APPEND | O_CREAT | O_NOFOLLOW, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-19044",
        "func_name": "acassen/keepalived/dump_keywords",
        "description": "keepalived 2.0.8 didn't check for pathnames with symlinks when writing data to a temporary file upon a call to PrintData or PrintStats. This allowed local users to overwrite arbitrary files if fs.protected_symlinks is set to 0, as demonstrated by a symlink from /tmp/keepalived.data or /tmp/keepalived.stats to /etc/passwd.",
        "git_url": "https://github.com/acassen/keepalived/commit/04f2d32871bb3b11d7dc024039952f2fe2750306",
        "commit_title": "When opening files for write, ensure they aren't symbolic links",
        "commit_text": " Issue #1048 identified that if, for example, a non privileged user created a symbolic link from /etc/keepalvied.data to /etc/passwd, writing to /etc/keepalived.data (which could be invoked via DBus) would cause /etc/passwd to be overwritten.  This commit stops keepalived writing to pathnames where the ultimate component is a symbolic link, by setting O_NOFOLLOW whenever opening a file for writing.  This might break some setups, where, for example, /etc/keepalived.data was a symbolic link to /home/fred/keepalived.data. If this was the case, instead create a symbolic link from /home/fred/keepalived.data to /tmp/keepalived.data, so that the file is still accessible via /home/fred/keepalived.data.  There doesn't appear to be a way around this backward incompatibility, since even checking if the pathname is a symbolic link prior to opening for writing would create a race condition. ",
        "func_before": "static void\ndump_keywords(vector_t *keydump, int level, FILE *fp)\n{\n\tunsigned int i;\n\tkeyword_t *keyword_vec;\n\tchar file_name[21];\n\n\tif (!level) {\n\t\tsnprintf(file_name, sizeof(file_name), \"/tmp/keywords.%d\", getpid());\n\t\tfp = fopen(file_name, \"w\");\n\t\tif (!fp)\n\t\t\treturn;\n\t}\n\n\tfor (i = 0; i < vector_size(keydump); i++) {\n\t\tkeyword_vec = vector_slot(keydump, i);\n\t\tfprintf(fp, \"%*sKeyword : %s (%s)\\n\", level * 2, \"\", keyword_vec->string, keyword_vec->active ? \"active\": \"disabled\");\n\t\tif (keyword_vec->sub)\n\t\t\tdump_keywords(keyword_vec->sub, level + 1, fp);\n\t}\n\n\tif (!level)\n\t\tfclose(fp);\n}",
        "func": "static void\ndump_keywords(vector_t *keydump, int level, FILE *fp)\n{\n\tunsigned int i;\n\tkeyword_t *keyword_vec;\n\tchar file_name[22];\n\n\tif (!level) {\n\t\tsnprintf(file_name, sizeof(file_name), \"/tmp/keywords.%d\", getpid());\n\t\tfp = fopen_safe(file_name, \"w\");\n\t\tif (!fp)\n\t\t\treturn;\n\t}\n\n\tfor (i = 0; i < vector_size(keydump); i++) {\n\t\tkeyword_vec = vector_slot(keydump, i);\n\t\tfprintf(fp, \"%*sKeyword : %s (%s)\\n\", level * 2, \"\", keyword_vec->string, keyword_vec->active ? \"active\": \"disabled\");\n\t\tif (keyword_vec->sub)\n\t\t\tdump_keywords(keyword_vec->sub, level + 1, fp);\n\t}\n\n\tif (!level)\n\t\tfclose(fp);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,11 +3,11 @@\n {\n \tunsigned int i;\n \tkeyword_t *keyword_vec;\n-\tchar file_name[21];\n+\tchar file_name[22];\n \n \tif (!level) {\n \t\tsnprintf(file_name, sizeof(file_name), \"/tmp/keywords.%d\", getpid());\n-\t\tfp = fopen(file_name, \"w\");\n+\t\tfp = fopen_safe(file_name, \"w\");\n \t\tif (!fp)\n \t\t\treturn;\n \t}",
        "diff_line_info": {
            "deleted_lines": [
                "\tchar file_name[21];",
                "\t\tfp = fopen(file_name, \"w\");"
            ],
            "added_lines": [
                "\tchar file_name[22];",
                "\t\tfp = fopen_safe(file_name, \"w\");"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-1335",
        "func_name": "lxc/cgroupfs_mount_cgroup",
        "description": "lxc-start in lxc before 1.0.8 and 1.1.x before 1.1.4 allows local container administrators to escape AppArmor confinement via a symlink attack on a (1) mount target or (2) bind mount source.",
        "git_url": "https://github.com/lxc/lxc/commit/592fd47a6245508b79fe6ac819fe6d3b2c1289be",
        "commit_title": "CVE-2015-1335: Protect container mounts against symlinks",
        "commit_text": " When a container starts up, lxc sets up the container's inital fstree by doing a bunch of mounting, guided by the container configuration file.  The container config is owned by the admin or user on the host, so we do not try to guard against bad entries.  However, since the mount target is in the container, it's possible that the container admin could divert the mount with symbolic links.  This could bypass proper container startup (i.e. confinement of a root-owned container by the restrictive apparmor policy, by diverting the required write to /proc/self/attr/current), or bypass the (path-based) apparmor policy by diverting, say, /proc to /mnt in the container.  To prevent this,  1. do not allow mounts to paths containing symbolic links  2. do not allow bind mounts from relative paths containing symbolic links.  Details:  Define safe_mount which ensures that the container has not inserted any symbolic links into any mount targets for mounts to be done during container setup.  The host's mount path may contain symbolic links.  As it is under the control of the administrator, that's ok.  So safe_mount begins the check for symbolic links after the rootfs->mount, by opening that directory.  It opens each directory along the path using openat() relative to the parent directory using O_NOFOLLOW.  When the target is reached, it mounts onto /proc/self/fd/<targetfd>.  Use safe_mount() in mount_entry(), when mounting container proc, and when needed.  In particular, safe_mount() need not be used in any case where:  1. the mount is done in the container's namespace 2. the mount is for the container's rootfs 3. the mount is relative to a tmpfs or proc/sysfs which we have    just safe_mount()ed ourselves  Since we were using proc/net as a temporary placeholder for /proc/sys/net during container startup, and proc/net is a symbolic link, use proc/tty instead.  Update the lxc.container.conf manpage with details about the new restrictions.  Finally, add a testcase to test some symbolic link possibilities. ",
        "func_before": "static bool cgroupfs_mount_cgroup(void *hdata, const char *root, int type)\n{\n\tsize_t bufsz = strlen(root) + sizeof(\"/sys/fs/cgroup\");\n\tchar *path = NULL;\n\tchar **parts = NULL;\n\tchar *dirname = NULL;\n\tchar *abs_path = NULL;\n\tchar *abs_path2 = NULL;\n\tstruct cgfs_data *cgfs_d;\n\tstruct cgroup_process_info *info, *base_info;\n\tint r, saved_errno = 0;\n\n\tcgfs_d = hdata;\n\tif (!cgfs_d)\n\t\treturn false;\n\tbase_info = cgfs_d->info;\n\n\t/* If we get passed the _NOSPEC types, we default to _MIXED, since we don't\n\t * have access to the lxc_conf object at this point. It really should be up\n\t * to the caller to fix this, but this doesn't really hurt.\n\t */\n\tif (type == LXC_AUTO_CGROUP_FULL_NOSPEC)\n\t\ttype = LXC_AUTO_CGROUP_FULL_MIXED;\n\telse if (type == LXC_AUTO_CGROUP_NOSPEC)\n\t\ttype = LXC_AUTO_CGROUP_MIXED;\n\n\tif (type < LXC_AUTO_CGROUP_RO || type > LXC_AUTO_CGROUP_FULL_MIXED) {\n\t\tERROR(\"could not mount cgroups into container: invalid type specified internally\");\n\t\terrno = EINVAL;\n\t\treturn false;\n\t}\n\n\tpath = calloc(1, bufsz);\n\tif (!path)\n\t\treturn false;\n\tsnprintf(path, bufsz, \"%s/sys/fs/cgroup\", root);\n\tr = mount(\"cgroup_root\", path, \"tmpfs\", MS_NOSUID|MS_NODEV|MS_NOEXEC|MS_RELATIME, \"size=10240k,mode=755\");\n\tif (r < 0) {\n\t\tSYSERROR(\"could not mount tmpfs to /sys/fs/cgroup in the container\");\n\t\treturn false;\n\t}\n\n\t/* now mount all the hierarchies we care about */\n\tfor (info = base_info; info; info = info->next) {\n\t\tsize_t subsystem_count, i;\n\t\tstruct cgroup_mount_point *mp = info->designated_mount_point;\n\t\tif (!mp)\n\t\t\tmp = lxc_cgroup_find_mount_point(info->hierarchy, info->cgroup_path, true);\n\t\tif (!mp) {\n\t\t\tSYSERROR(\"could not find original mount point for cgroup hierarchy while trying to mount cgroup filesystem\");\n\t\t\tgoto out_error;\n\t\t}\n\n\t\tsubsystem_count = lxc_array_len((void **)info->hierarchy->subsystems);\n\t\tparts = calloc(subsystem_count + 1, sizeof(char *));\n\t\tif (!parts)\n\t\t\tgoto out_error;\n\n\t\tfor (i = 0; i < subsystem_count; i++) {\n\t\t\tif (!strncmp(info->hierarchy->subsystems[i], \"name=\", 5))\n\t\t\t\tparts[i] = info->hierarchy->subsystems[i] + 5;\n\t\t\telse\n\t\t\t\tparts[i] = info->hierarchy->subsystems[i];\n\t\t}\n\t\tdirname = lxc_string_join(\",\", (const char **)parts, false);\n\t\tif (!dirname)\n\t\t\tgoto out_error;\n\n\t\t/* create subsystem directory */\n\t\tabs_path = lxc_append_paths(path, dirname);\n\t\tif (!abs_path)\n\t\t\tgoto out_error;\n\t\tr = mkdir_p(abs_path, 0755);\n\t\tif (r < 0 && errno != EEXIST) {\n\t\t\tSYSERROR(\"could not create cgroup subsystem directory /sys/fs/cgroup/%s\", dirname);\n\t\t\tgoto out_error;\n\t\t}\n\n\t\tabs_path2 = lxc_append_paths(abs_path, info->cgroup_path);\n\t\tif (!abs_path2)\n\t\t\tgoto out_error;\n\n\t\tif (type == LXC_AUTO_CGROUP_FULL_RO || type == LXC_AUTO_CGROUP_FULL_RW || type == LXC_AUTO_CGROUP_FULL_MIXED) {\n\t\t\t/* bind-mount the cgroup entire filesystem there */\n\t\t\tif (strcmp(mp->mount_prefix, \"/\") != 0) {\n\t\t\t\t/* FIXME: maybe we should just try to remount the entire hierarchy\n\t\t\t\t *        with a regular mount command? may that works? */\n\t\t\t\tERROR(\"could not automatically mount cgroup-full to /sys/fs/cgroup/%s: host has no mount point for this cgroup filesystem that has access to the root cgroup\", dirname);\n\t\t\t\tgoto out_error;\n\t\t\t}\n\t\t\tr = mount(mp->mount_point, abs_path, \"none\", MS_BIND, 0);\n\t\t\tif (r < 0) {\n\t\t\t\tSYSERROR(\"error bind-mounting %s to %s\", mp->mount_point, abs_path);\n\t\t\t\tgoto out_error;\n\t\t\t}\n\t\t\t/* main cgroup path should be read-only */\n\t\t\tif (type == LXC_AUTO_CGROUP_FULL_RO || type == LXC_AUTO_CGROUP_FULL_MIXED) {\n\t\t\t\tr = mount(NULL, abs_path, NULL, MS_REMOUNT|MS_BIND|MS_RDONLY, NULL);\n\t\t\t\tif (r < 0) {\n\t\t\t\t\tSYSERROR(\"error re-mounting %s readonly\", abs_path);\n\t\t\t\t\tgoto out_error;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* own cgroup should be read-write */\n\t\t\tif (type == LXC_AUTO_CGROUP_FULL_MIXED) {\n\t\t\t\tr = mount(abs_path2, abs_path2, NULL, MS_BIND, NULL);\n\t\t\t\tif (r < 0) {\n\t\t\t\t\tSYSERROR(\"error bind-mounting %s onto itself\", abs_path2);\n\t\t\t\t\tgoto out_error;\n\t\t\t\t}\n\t\t\t\tr = mount(NULL, abs_path2, NULL, MS_REMOUNT|MS_BIND, NULL);\n\t\t\t\tif (r < 0) {\n\t\t\t\t\tSYSERROR(\"error re-mounting %s readwrite\", abs_path2);\n\t\t\t\t\tgoto out_error;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t/* create path for container's cgroup */\n\t\t\tr = mkdir_p(abs_path2, 0755);\n\t\t\tif (r < 0 && errno != EEXIST) {\n\t\t\t\tSYSERROR(\"could not create cgroup directory /sys/fs/cgroup/%s%s\", dirname, info->cgroup_path);\n\t\t\t\tgoto out_error;\n\t\t\t}\n\n\t\t\t/* for read-only and mixed cases, we have to bind-mount the tmpfs directory\n\t\t\t * that points to the hierarchy itself (i.e. /sys/fs/cgroup/cpu etc.) onto\n\t\t\t * itself and then bind-mount it read-only, since we keep the tmpfs itself\n\t\t\t * read-write (see comment below)\n\t\t\t */\n\t\t\tif (type == LXC_AUTO_CGROUP_MIXED || type == LXC_AUTO_CGROUP_RO) {\n\t\t\t\tr = mount(abs_path, abs_path, NULL, MS_BIND, NULL);\n\t\t\t\tif (r < 0) {\n\t\t\t\t\tSYSERROR(\"error bind-mounting %s onto itself\", abs_path);\n\t\t\t\t\tgoto out_error;\n\t\t\t\t}\n\t\t\t\tr = mount(NULL, abs_path, NULL, MS_REMOUNT|MS_BIND|MS_RDONLY, NULL);\n\t\t\t\tif (r < 0) {\n\t\t\t\t\tSYSERROR(\"error re-mounting %s readonly\", abs_path);\n\t\t\t\t\tgoto out_error;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfree(abs_path);\n\t\t\tabs_path = NULL;\n\n\t\t\t/* bind-mount container's cgroup to that directory */\n\t\t\tabs_path = cgroup_to_absolute_path(mp, info->cgroup_path, NULL);\n\t\t\tif (!abs_path)\n\t\t\t\tgoto out_error;\n\t\t\tr = mount(abs_path, abs_path2, \"none\", MS_BIND, 0);\n\t\t\tif (r < 0) {\n\t\t\t\tSYSERROR(\"error bind-mounting %s to %s\", abs_path, abs_path2);\n\t\t\t\tgoto out_error;\n\t\t\t}\n\t\t\tif (type == LXC_AUTO_CGROUP_RO) {\n\t\t\t\tr = mount(NULL, abs_path2, NULL, MS_REMOUNT|MS_BIND|MS_RDONLY, NULL);\n\t\t\t\tif (r < 0) {\n\t\t\t\t\tSYSERROR(\"error re-mounting %s readonly\", abs_path2);\n\t\t\t\t\tgoto out_error;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfree(abs_path);\n\t\tfree(abs_path2);\n\t\tabs_path = NULL;\n\t\tabs_path2 = NULL;\n\n\t\t/* add symlinks for every single subsystem */\n\t\tif (subsystem_count > 1) {\n\t\t\tfor (i = 0; i < subsystem_count; i++) {\n\t\t\t\tabs_path = lxc_append_paths(path, parts[i]);\n\t\t\t\tif (!abs_path)\n\t\t\t\t\tgoto out_error;\n\t\t\t\tr = symlink(dirname, abs_path);\n\t\t\t\tif (r < 0)\n\t\t\t\t\tWARN(\"could not create symlink %s -> %s in /sys/fs/cgroup of container\", parts[i], dirname);\n\t\t\t\tfree(abs_path);\n\t\t\t\tabs_path = NULL;\n\t\t\t}\n\t\t}\n\t\tfree(dirname);\n\t\tfree(parts);\n\t\tdirname = NULL;\n\t\tparts = NULL;\n\t}\n\n\t/* We used to remount the entire tmpfs readonly if any :ro or\n\t * :mixed mode was specified. However, Ubuntu's mountall has the\n\t * unfortunate behavior to block bootup if /sys/fs/cgroup is\n\t * mounted read-only and cannot be remounted read-write.\n\t * (mountall reads /lib/init/fstab and tries to (re-)mount all of\n\t * these if they are not already mounted with the right options;\n\t * it contains an entry for /sys/fs/cgroup. In case it can't do\n\t * that, it prompts for the user to either manually fix it or\n\t * boot anyway. But without user input, booting of the container\n\t * hangs.)\n\t *\n\t * Instead of remounting the entire tmpfs readonly, we only\n\t * remount the paths readonly that are part of the cgroup\n\t * hierarchy.\n\t */\n\n\tfree(path);\n\n\treturn true;\n\nout_error:\n\tsaved_errno = errno;\n\tfree(path);\n\tfree(dirname);\n\tfree(parts);\n\tfree(abs_path);\n\tfree(abs_path2);\n\terrno = saved_errno;\n\treturn false;\n}",
        "func": "static bool cgroupfs_mount_cgroup(void *hdata, const char *root, int type)\n{\n\tsize_t bufsz = strlen(root) + sizeof(\"/sys/fs/cgroup\");\n\tchar *path = NULL;\n\tchar **parts = NULL;\n\tchar *dirname = NULL;\n\tchar *abs_path = NULL;\n\tchar *abs_path2 = NULL;\n\tstruct cgfs_data *cgfs_d;\n\tstruct cgroup_process_info *info, *base_info;\n\tint r, saved_errno = 0;\n\n\tcgfs_d = hdata;\n\tif (!cgfs_d)\n\t\treturn false;\n\tbase_info = cgfs_d->info;\n\n\t/* If we get passed the _NOSPEC types, we default to _MIXED, since we don't\n\t * have access to the lxc_conf object at this point. It really should be up\n\t * to the caller to fix this, but this doesn't really hurt.\n\t */\n\tif (type == LXC_AUTO_CGROUP_FULL_NOSPEC)\n\t\ttype = LXC_AUTO_CGROUP_FULL_MIXED;\n\telse if (type == LXC_AUTO_CGROUP_NOSPEC)\n\t\ttype = LXC_AUTO_CGROUP_MIXED;\n\n\tif (type < LXC_AUTO_CGROUP_RO || type > LXC_AUTO_CGROUP_FULL_MIXED) {\n\t\tERROR(\"could not mount cgroups into container: invalid type specified internally\");\n\t\terrno = EINVAL;\n\t\treturn false;\n\t}\n\n\tpath = calloc(1, bufsz);\n\tif (!path)\n\t\treturn false;\n\tsnprintf(path, bufsz, \"%s/sys/fs/cgroup\", root);\n\tr = safe_mount(\"cgroup_root\", path, \"tmpfs\",\n\t\t\tMS_NOSUID|MS_NODEV|MS_NOEXEC|MS_RELATIME,\n\t\t\t\"size=10240k,mode=755\",\n\t\t\troot);\n\tif (r < 0) {\n\t\tSYSERROR(\"could not mount tmpfs to /sys/fs/cgroup in the container\");\n\t\treturn false;\n\t}\n\n\t/* now mount all the hierarchies we care about */\n\tfor (info = base_info; info; info = info->next) {\n\t\tsize_t subsystem_count, i;\n\t\tstruct cgroup_mount_point *mp = info->designated_mount_point;\n\t\tif (!mp)\n\t\t\tmp = lxc_cgroup_find_mount_point(info->hierarchy, info->cgroup_path, true);\n\t\tif (!mp) {\n\t\t\tSYSERROR(\"could not find original mount point for cgroup hierarchy while trying to mount cgroup filesystem\");\n\t\t\tgoto out_error;\n\t\t}\n\n\t\tsubsystem_count = lxc_array_len((void **)info->hierarchy->subsystems);\n\t\tparts = calloc(subsystem_count + 1, sizeof(char *));\n\t\tif (!parts)\n\t\t\tgoto out_error;\n\n\t\tfor (i = 0; i < subsystem_count; i++) {\n\t\t\tif (!strncmp(info->hierarchy->subsystems[i], \"name=\", 5))\n\t\t\t\tparts[i] = info->hierarchy->subsystems[i] + 5;\n\t\t\telse\n\t\t\t\tparts[i] = info->hierarchy->subsystems[i];\n\t\t}\n\t\tdirname = lxc_string_join(\",\", (const char **)parts, false);\n\t\tif (!dirname)\n\t\t\tgoto out_error;\n\n\t\t/* create subsystem directory */\n\t\tabs_path = lxc_append_paths(path, dirname);\n\t\tif (!abs_path)\n\t\t\tgoto out_error;\n\t\tr = mkdir_p(abs_path, 0755);\n\t\tif (r < 0 && errno != EEXIST) {\n\t\t\tSYSERROR(\"could not create cgroup subsystem directory /sys/fs/cgroup/%s\", dirname);\n\t\t\tgoto out_error;\n\t\t}\n\n\t\tabs_path2 = lxc_append_paths(abs_path, info->cgroup_path);\n\t\tif (!abs_path2)\n\t\t\tgoto out_error;\n\n\t\tif (type == LXC_AUTO_CGROUP_FULL_RO || type == LXC_AUTO_CGROUP_FULL_RW || type == LXC_AUTO_CGROUP_FULL_MIXED) {\n\t\t\t/* bind-mount the cgroup entire filesystem there */\n\t\t\tif (strcmp(mp->mount_prefix, \"/\") != 0) {\n\t\t\t\t/* FIXME: maybe we should just try to remount the entire hierarchy\n\t\t\t\t *        with a regular mount command? may that works? */\n\t\t\t\tERROR(\"could not automatically mount cgroup-full to /sys/fs/cgroup/%s: host has no mount point for this cgroup filesystem that has access to the root cgroup\", dirname);\n\t\t\t\tgoto out_error;\n\t\t\t}\n\t\t\tr = mount(mp->mount_point, abs_path, \"none\", MS_BIND, 0);\n\t\t\tif (r < 0) {\n\t\t\t\tSYSERROR(\"error bind-mounting %s to %s\", mp->mount_point, abs_path);\n\t\t\t\tgoto out_error;\n\t\t\t}\n\t\t\t/* main cgroup path should be read-only */\n\t\t\tif (type == LXC_AUTO_CGROUP_FULL_RO || type == LXC_AUTO_CGROUP_FULL_MIXED) {\n\t\t\t\tr = mount(NULL, abs_path, NULL, MS_REMOUNT|MS_BIND|MS_RDONLY, NULL);\n\t\t\t\tif (r < 0) {\n\t\t\t\t\tSYSERROR(\"error re-mounting %s readonly\", abs_path);\n\t\t\t\t\tgoto out_error;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/* own cgroup should be read-write */\n\t\t\tif (type == LXC_AUTO_CGROUP_FULL_MIXED) {\n\t\t\t\tr = mount(abs_path2, abs_path2, NULL, MS_BIND, NULL);\n\t\t\t\tif (r < 0) {\n\t\t\t\t\tSYSERROR(\"error bind-mounting %s onto itself\", abs_path2);\n\t\t\t\t\tgoto out_error;\n\t\t\t\t}\n\t\t\t\tr = mount(NULL, abs_path2, NULL, MS_REMOUNT|MS_BIND, NULL);\n\t\t\t\tif (r < 0) {\n\t\t\t\t\tSYSERROR(\"error re-mounting %s readwrite\", abs_path2);\n\t\t\t\t\tgoto out_error;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\t/* create path for container's cgroup */\n\t\t\tr = mkdir_p(abs_path2, 0755);\n\t\t\tif (r < 0 && errno != EEXIST) {\n\t\t\t\tSYSERROR(\"could not create cgroup directory /sys/fs/cgroup/%s%s\", dirname, info->cgroup_path);\n\t\t\t\tgoto out_error;\n\t\t\t}\n\n\t\t\t/* for read-only and mixed cases, we have to bind-mount the tmpfs directory\n\t\t\t * that points to the hierarchy itself (i.e. /sys/fs/cgroup/cpu etc.) onto\n\t\t\t * itself and then bind-mount it read-only, since we keep the tmpfs itself\n\t\t\t * read-write (see comment below)\n\t\t\t */\n\t\t\tif (type == LXC_AUTO_CGROUP_MIXED || type == LXC_AUTO_CGROUP_RO) {\n\t\t\t\tr = mount(abs_path, abs_path, NULL, MS_BIND, NULL);\n\t\t\t\tif (r < 0) {\n\t\t\t\t\tSYSERROR(\"error bind-mounting %s onto itself\", abs_path);\n\t\t\t\t\tgoto out_error;\n\t\t\t\t}\n\t\t\t\tr = mount(NULL, abs_path, NULL, MS_REMOUNT|MS_BIND|MS_RDONLY, NULL);\n\t\t\t\tif (r < 0) {\n\t\t\t\t\tSYSERROR(\"error re-mounting %s readonly\", abs_path);\n\t\t\t\t\tgoto out_error;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfree(abs_path);\n\t\t\tabs_path = NULL;\n\n\t\t\t/* bind-mount container's cgroup to that directory */\n\t\t\tabs_path = cgroup_to_absolute_path(mp, info->cgroup_path, NULL);\n\t\t\tif (!abs_path)\n\t\t\t\tgoto out_error;\n\t\t\tr = mount(abs_path, abs_path2, \"none\", MS_BIND, 0);\n\t\t\tif (r < 0) {\n\t\t\t\tSYSERROR(\"error bind-mounting %s to %s\", abs_path, abs_path2);\n\t\t\t\tgoto out_error;\n\t\t\t}\n\t\t\tif (type == LXC_AUTO_CGROUP_RO) {\n\t\t\t\tr = mount(NULL, abs_path2, NULL, MS_REMOUNT|MS_BIND|MS_RDONLY, NULL);\n\t\t\t\tif (r < 0) {\n\t\t\t\t\tSYSERROR(\"error re-mounting %s readonly\", abs_path2);\n\t\t\t\t\tgoto out_error;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfree(abs_path);\n\t\tfree(abs_path2);\n\t\tabs_path = NULL;\n\t\tabs_path2 = NULL;\n\n\t\t/* add symlinks for every single subsystem */\n\t\tif (subsystem_count > 1) {\n\t\t\tfor (i = 0; i < subsystem_count; i++) {\n\t\t\t\tabs_path = lxc_append_paths(path, parts[i]);\n\t\t\t\tif (!abs_path)\n\t\t\t\t\tgoto out_error;\n\t\t\t\tr = symlink(dirname, abs_path);\n\t\t\t\tif (r < 0)\n\t\t\t\t\tWARN(\"could not create symlink %s -> %s in /sys/fs/cgroup of container\", parts[i], dirname);\n\t\t\t\tfree(abs_path);\n\t\t\t\tabs_path = NULL;\n\t\t\t}\n\t\t}\n\t\tfree(dirname);\n\t\tfree(parts);\n\t\tdirname = NULL;\n\t\tparts = NULL;\n\t}\n\n\t/* We used to remount the entire tmpfs readonly if any :ro or\n\t * :mixed mode was specified. However, Ubuntu's mountall has the\n\t * unfortunate behavior to block bootup if /sys/fs/cgroup is\n\t * mounted read-only and cannot be remounted read-write.\n\t * (mountall reads /lib/init/fstab and tries to (re-)mount all of\n\t * these if they are not already mounted with the right options;\n\t * it contains an entry for /sys/fs/cgroup. In case it can't do\n\t * that, it prompts for the user to either manually fix it or\n\t * boot anyway. But without user input, booting of the container\n\t * hangs.)\n\t *\n\t * Instead of remounting the entire tmpfs readonly, we only\n\t * remount the paths readonly that are part of the cgroup\n\t * hierarchy.\n\t */\n\n\tfree(path);\n\n\treturn true;\n\nout_error:\n\tsaved_errno = errno;\n\tfree(path);\n\tfree(dirname);\n\tfree(parts);\n\tfree(abs_path);\n\tfree(abs_path2);\n\terrno = saved_errno;\n\treturn false;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -34,7 +34,10 @@\n \tif (!path)\n \t\treturn false;\n \tsnprintf(path, bufsz, \"%s/sys/fs/cgroup\", root);\n-\tr = mount(\"cgroup_root\", path, \"tmpfs\", MS_NOSUID|MS_NODEV|MS_NOEXEC|MS_RELATIME, \"size=10240k,mode=755\");\n+\tr = safe_mount(\"cgroup_root\", path, \"tmpfs\",\n+\t\t\tMS_NOSUID|MS_NODEV|MS_NOEXEC|MS_RELATIME,\n+\t\t\t\"size=10240k,mode=755\",\n+\t\t\troot);\n \tif (r < 0) {\n \t\tSYSERROR(\"could not mount tmpfs to /sys/fs/cgroup in the container\");\n \t\treturn false;",
        "diff_line_info": {
            "deleted_lines": [
                "\tr = mount(\"cgroup_root\", path, \"tmpfs\", MS_NOSUID|MS_NODEV|MS_NOEXEC|MS_RELATIME, \"size=10240k,mode=755\");"
            ],
            "added_lines": [
                "\tr = safe_mount(\"cgroup_root\", path, \"tmpfs\",",
                "\t\t\tMS_NOSUID|MS_NODEV|MS_NOEXEC|MS_RELATIME,",
                "\t\t\t\"size=10240k,mode=755\",",
                "\t\t\troot);"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-1335",
        "func_name": "lxc/mount_proc_if_needed",
        "description": "lxc-start in lxc before 1.0.8 and 1.1.x before 1.1.4 allows local container administrators to escape AppArmor confinement via a symlink attack on a (1) mount target or (2) bind mount source.",
        "git_url": "https://github.com/lxc/lxc/commit/592fd47a6245508b79fe6ac819fe6d3b2c1289be",
        "commit_title": "CVE-2015-1335: Protect container mounts against symlinks",
        "commit_text": " When a container starts up, lxc sets up the container's inital fstree by doing a bunch of mounting, guided by the container configuration file.  The container config is owned by the admin or user on the host, so we do not try to guard against bad entries.  However, since the mount target is in the container, it's possible that the container admin could divert the mount with symbolic links.  This could bypass proper container startup (i.e. confinement of a root-owned container by the restrictive apparmor policy, by diverting the required write to /proc/self/attr/current), or bypass the (path-based) apparmor policy by diverting, say, /proc to /mnt in the container.  To prevent this,  1. do not allow mounts to paths containing symbolic links  2. do not allow bind mounts from relative paths containing symbolic links.  Details:  Define safe_mount which ensures that the container has not inserted any symbolic links into any mount targets for mounts to be done during container setup.  The host's mount path may contain symbolic links.  As it is under the control of the administrator, that's ok.  So safe_mount begins the check for symbolic links after the rootfs->mount, by opening that directory.  It opens each directory along the path using openat() relative to the parent directory using O_NOFOLLOW.  When the target is reached, it mounts onto /proc/self/fd/<targetfd>.  Use safe_mount() in mount_entry(), when mounting container proc, and when needed.  In particular, safe_mount() need not be used in any case where:  1. the mount is done in the container's namespace 2. the mount is for the container's rootfs 3. the mount is relative to a tmpfs or proc/sysfs which we have    just safe_mount()ed ourselves  Since we were using proc/net as a temporary placeholder for /proc/sys/net during container startup, and proc/net is a symbolic link, use proc/tty instead.  Update the lxc.container.conf manpage with details about the new restrictions.  Finally, add a testcase to test some symbolic link possibilities. ",
        "func_before": "int mount_proc_if_needed(const char *rootfs)\n{\n\tchar path[MAXPATHLEN];\n\tchar link[20];\n\tint linklen, ret;\n\tint mypid;\n\n\tret = snprintf(path, MAXPATHLEN, \"%s/proc/self\", rootfs);\n\tif (ret < 0 || ret >= MAXPATHLEN) {\n\t\tSYSERROR(\"proc path name too long\");\n\t\treturn -1;\n\t}\n\tmemset(link, 0, 20);\n\tlinklen = readlink(path, link, 20);\n\tmypid = (int)getpid();\n\tINFO(\"I am %d, /proc/self points to '%s'\", mypid, link);\n\tret = snprintf(path, MAXPATHLEN, \"%s/proc\", rootfs);\n\tif (ret < 0 || ret >= MAXPATHLEN) {\n\t\tSYSERROR(\"proc path name too long\");\n\t\treturn -1;\n\t}\n\tif (linklen < 0) /* /proc not mounted */\n\t\tgoto domount;\n\tif (atoi(link) != mypid) {\n\t\t/* wrong /procs mounted */\n\t\tumount2(path, MNT_DETACH); /* ignore failure */\n\t\tgoto domount;\n\t}\n\t/* the right proc is already mounted */\n\treturn 0;\n\ndomount:\n\tif (mount(\"proc\", path, \"proc\", 0, NULL))\n\t\treturn -1;\n\tINFO(\"Mounted /proc in container for security transition\");\n\treturn 1;\n}",
        "func": "int mount_proc_if_needed(const char *rootfs)\n{\n\tchar path[MAXPATHLEN];\n\tchar link[20];\n\tint linklen, ret;\n\tint mypid;\n\n\tret = snprintf(path, MAXPATHLEN, \"%s/proc/self\", rootfs);\n\tif (ret < 0 || ret >= MAXPATHLEN) {\n\t\tSYSERROR(\"proc path name too long\");\n\t\treturn -1;\n\t}\n\tmemset(link, 0, 20);\n\tlinklen = readlink(path, link, 20);\n\tmypid = (int)getpid();\n\tINFO(\"I am %d, /proc/self points to '%s'\", mypid, link);\n\tret = snprintf(path, MAXPATHLEN, \"%s/proc\", rootfs);\n\tif (ret < 0 || ret >= MAXPATHLEN) {\n\t\tSYSERROR(\"proc path name too long\");\n\t\treturn -1;\n\t}\n\tif (linklen < 0) /* /proc not mounted */\n\t\tgoto domount;\n\tif (atoi(link) != mypid) {\n\t\t/* wrong /procs mounted */\n\t\tumount2(path, MNT_DETACH); /* ignore failure */\n\t\tgoto domount;\n\t}\n\t/* the right proc is already mounted */\n\treturn 0;\n\ndomount:\n\tif (safe_mount(\"proc\", path, \"proc\", 0, NULL, rootfs) < 0)\n\t\treturn -1;\n\tINFO(\"Mounted /proc in container for security transition\");\n\treturn 1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -30,7 +30,7 @@\n \treturn 0;\n \n domount:\n-\tif (mount(\"proc\", path, \"proc\", 0, NULL))\n+\tif (safe_mount(\"proc\", path, \"proc\", 0, NULL, rootfs) < 0)\n \t\treturn -1;\n \tINFO(\"Mounted /proc in container for security transition\");\n \treturn 1;",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (mount(\"proc\", path, \"proc\", 0, NULL))"
            ],
            "added_lines": [
                "\tif (safe_mount(\"proc\", path, \"proc\", 0, NULL, rootfs) < 0)"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-1335",
        "func_name": "lxc/cgm_bind_dir",
        "description": "lxc-start in lxc before 1.0.8 and 1.1.x before 1.1.4 allows local container administrators to escape AppArmor confinement via a symlink attack on a (1) mount target or (2) bind mount source.",
        "git_url": "https://github.com/lxc/lxc/commit/592fd47a6245508b79fe6ac819fe6d3b2c1289be",
        "commit_title": "CVE-2015-1335: Protect container mounts against symlinks",
        "commit_text": " When a container starts up, lxc sets up the container's inital fstree by doing a bunch of mounting, guided by the container configuration file.  The container config is owned by the admin or user on the host, so we do not try to guard against bad entries.  However, since the mount target is in the container, it's possible that the container admin could divert the mount with symbolic links.  This could bypass proper container startup (i.e. confinement of a root-owned container by the restrictive apparmor policy, by diverting the required write to /proc/self/attr/current), or bypass the (path-based) apparmor policy by diverting, say, /proc to /mnt in the container.  To prevent this,  1. do not allow mounts to paths containing symbolic links  2. do not allow bind mounts from relative paths containing symbolic links.  Details:  Define safe_mount which ensures that the container has not inserted any symbolic links into any mount targets for mounts to be done during container setup.  The host's mount path may contain symbolic links.  As it is under the control of the administrator, that's ok.  So safe_mount begins the check for symbolic links after the rootfs->mount, by opening that directory.  It opens each directory along the path using openat() relative to the parent directory using O_NOFOLLOW.  When the target is reached, it mounts onto /proc/self/fd/<targetfd>.  Use safe_mount() in mount_entry(), when mounting container proc, and when needed.  In particular, safe_mount() need not be used in any case where:  1. the mount is done in the container's namespace 2. the mount is for the container's rootfs 3. the mount is relative to a tmpfs or proc/sysfs which we have    just safe_mount()ed ourselves  Since we were using proc/net as a temporary placeholder for /proc/sys/net during container startup, and proc/net is a symbolic link, use proc/tty instead.  Update the lxc.container.conf manpage with details about the new restrictions.  Finally, add a testcase to test some symbolic link possibilities. ",
        "func_before": "static bool cgm_bind_dir(const char *root, const char *dirname)\n{\n\tnih_local char *cgpath = NULL;\n\n\t/* /sys should have been mounted by now */\n\tcgpath = NIH_MUST( nih_strdup(NULL, root) );\n\tNIH_MUST( nih_strcat(&cgpath, NULL, \"/sys/fs/cgroup\") );\n\n\tif (!dir_exists(cgpath)) {\n\t\tERROR(\"%s does not exist\", cgpath);\n\t\treturn false;\n\t}\n\n\t/* mount a tmpfs there so we can create subdirs */\n\tif (mount(\"cgroup\", cgpath, \"tmpfs\", 0, \"size=10000,mode=755\")) {\n\t\tSYSERROR(\"Failed to mount tmpfs at %s\", cgpath);\n\t\treturn false;\n\t}\n\tNIH_MUST( nih_strcat(&cgpath, NULL, \"/cgmanager\") );\n\n\tif (mkdir(cgpath, 0755) < 0) {\n\t\tSYSERROR(\"Failed to create %s\", cgpath);\n\t\treturn false;\n\t}\n\n\tif (mount(dirname, cgpath, \"none\", MS_BIND, 0)) {\n\t\tSYSERROR(\"Failed to bind mount %s to %s\", dirname, cgpath);\n\t\treturn false;\n\t}\n\n\treturn true;\n}",
        "func": "static bool cgm_bind_dir(const char *root, const char *dirname)\n{\n\tnih_local char *cgpath = NULL;\n\n\t/* /sys should have been mounted by now */\n\tcgpath = NIH_MUST( nih_strdup(NULL, root) );\n\tNIH_MUST( nih_strcat(&cgpath, NULL, \"/sys/fs/cgroup\") );\n\n\tif (!dir_exists(cgpath)) {\n\t\tERROR(\"%s does not exist\", cgpath);\n\t\treturn false;\n\t}\n\n\t/* mount a tmpfs there so we can create subdirs */\n\tif (safe_mount(\"cgroup\", cgpath, \"tmpfs\", 0, \"size=10000,mode=755\", root)) {\n\t\tSYSERROR(\"Failed to mount tmpfs at %s\", cgpath);\n\t\treturn false;\n\t}\n\tNIH_MUST( nih_strcat(&cgpath, NULL, \"/cgmanager\") );\n\n\tif (mkdir(cgpath, 0755) < 0) {\n\t\tSYSERROR(\"Failed to create %s\", cgpath);\n\t\treturn false;\n\t}\n\n\tif (safe_mount(dirname, cgpath, \"none\", MS_BIND, 0, root)) {\n\t\tSYSERROR(\"Failed to bind mount %s to %s\", dirname, cgpath);\n\t\treturn false;\n\t}\n\n\treturn true;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -12,7 +12,7 @@\n \t}\n \n \t/* mount a tmpfs there so we can create subdirs */\n-\tif (mount(\"cgroup\", cgpath, \"tmpfs\", 0, \"size=10000,mode=755\")) {\n+\tif (safe_mount(\"cgroup\", cgpath, \"tmpfs\", 0, \"size=10000,mode=755\", root)) {\n \t\tSYSERROR(\"Failed to mount tmpfs at %s\", cgpath);\n \t\treturn false;\n \t}\n@@ -23,7 +23,7 @@\n \t\treturn false;\n \t}\n \n-\tif (mount(dirname, cgpath, \"none\", MS_BIND, 0)) {\n+\tif (safe_mount(dirname, cgpath, \"none\", MS_BIND, 0, root)) {\n \t\tSYSERROR(\"Failed to bind mount %s to %s\", dirname, cgpath);\n \t\treturn false;\n \t}",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (mount(\"cgroup\", cgpath, \"tmpfs\", 0, \"size=10000,mode=755\")) {",
                "\tif (mount(dirname, cgpath, \"none\", MS_BIND, 0)) {"
            ],
            "added_lines": [
                "\tif (safe_mount(\"cgroup\", cgpath, \"tmpfs\", 0, \"size=10000,mode=755\", root)) {",
                "\tif (safe_mount(dirname, cgpath, \"none\", MS_BIND, 0, root)) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-1335",
        "func_name": "lxc/fill_autodev",
        "description": "lxc-start in lxc before 1.0.8 and 1.1.x before 1.1.4 allows local container administrators to escape AppArmor confinement via a symlink attack on a (1) mount target or (2) bind mount source.",
        "git_url": "https://github.com/lxc/lxc/commit/592fd47a6245508b79fe6ac819fe6d3b2c1289be",
        "commit_title": "CVE-2015-1335: Protect container mounts against symlinks",
        "commit_text": " When a container starts up, lxc sets up the container's inital fstree by doing a bunch of mounting, guided by the container configuration file.  The container config is owned by the admin or user on the host, so we do not try to guard against bad entries.  However, since the mount target is in the container, it's possible that the container admin could divert the mount with symbolic links.  This could bypass proper container startup (i.e. confinement of a root-owned container by the restrictive apparmor policy, by diverting the required write to /proc/self/attr/current), or bypass the (path-based) apparmor policy by diverting, say, /proc to /mnt in the container.  To prevent this,  1. do not allow mounts to paths containing symbolic links  2. do not allow bind mounts from relative paths containing symbolic links.  Details:  Define safe_mount which ensures that the container has not inserted any symbolic links into any mount targets for mounts to be done during container setup.  The host's mount path may contain symbolic links.  As it is under the control of the administrator, that's ok.  So safe_mount begins the check for symbolic links after the rootfs->mount, by opening that directory.  It opens each directory along the path using openat() relative to the parent directory using O_NOFOLLOW.  When the target is reached, it mounts onto /proc/self/fd/<targetfd>.  Use safe_mount() in mount_entry(), when mounting container proc, and when needed.  In particular, safe_mount() need not be used in any case where:  1. the mount is done in the container's namespace 2. the mount is for the container's rootfs 3. the mount is relative to a tmpfs or proc/sysfs which we have    just safe_mount()ed ourselves  Since we were using proc/net as a temporary placeholder for /proc/sys/net during container startup, and proc/net is a symbolic link, use proc/tty instead.  Update the lxc.container.conf manpage with details about the new restrictions.  Finally, add a testcase to test some symbolic link possibilities. ",
        "func_before": "static int fill_autodev(const struct lxc_rootfs *rootfs)\n{\n\tint ret;\n\tchar path[MAXPATHLEN];\n\tint i;\n\tmode_t cmask;\n\n\tINFO(\"Creating initial consoles under container /dev\");\n\n\tret = snprintf(path, MAXPATHLEN, \"%s/dev\", rootfs->path ? rootfs->mount : \"\");\n\tif (ret < 0 || ret >= MAXPATHLEN) {\n\t\tERROR(\"Error calculating container /dev location\");\n\t\treturn -1;\n\t}\n\n\tif (!dir_exists(path))  // ignore, just don't try to fill in\n\t\treturn 0;\n\n\tINFO(\"Populating container /dev\");\n\tcmask = umask(S_IXUSR | S_IXGRP | S_IXOTH);\n\tfor (i = 0; i < sizeof(lxc_devs) / sizeof(lxc_devs[0]); i++) {\n\t\tconst struct lxc_devs *d = &lxc_devs[i];\n\t\tret = snprintf(path, MAXPATHLEN, \"%s/dev/%s\", rootfs->path ? rootfs->mount : \"\", d->name);\n\t\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\t\treturn -1;\n\t\tret = mknod(path, d->mode, makedev(d->maj, d->min));\n\t\tif (ret && errno != EEXIST) {\n\t\t\tchar hostpath[MAXPATHLEN];\n\t\t\tFILE *pathfile;\n\n\t\t\t// Unprivileged containers cannot create devices, so\n\t\t\t// bind mount the device from the host\n\t\t\tret = snprintf(hostpath, MAXPATHLEN, \"/dev/%s\", d->name);\n\t\t\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\t\t\treturn -1;\n\t\t\tpathfile = fopen(path, \"wb\");\n\t\t\tif (!pathfile) {\n\t\t\t\tSYSERROR(\"Failed to create device mount target '%s'\", path);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfclose(pathfile);\n\t\t\tif (mount(hostpath, path, 0, MS_BIND, NULL) != 0) {\n\t\t\t\tSYSERROR(\"Failed bind mounting device %s from host into container\",\n\t\t\t\t\td->name);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\tumask(cmask);\n\n\tINFO(\"Populated container /dev\");\n\treturn 0;\n}",
        "func": "static int fill_autodev(const struct lxc_rootfs *rootfs)\n{\n\tint ret;\n\tchar path[MAXPATHLEN];\n\tint i;\n\tmode_t cmask;\n\n\tINFO(\"Creating initial consoles under container /dev\");\n\n\tret = snprintf(path, MAXPATHLEN, \"%s/dev\", rootfs->path ? rootfs->mount : \"\");\n\tif (ret < 0 || ret >= MAXPATHLEN) {\n\t\tERROR(\"Error calculating container /dev location\");\n\t\treturn -1;\n\t}\n\n\tif (!dir_exists(path))  // ignore, just don't try to fill in\n\t\treturn 0;\n\n\tINFO(\"Populating container /dev\");\n\tcmask = umask(S_IXUSR | S_IXGRP | S_IXOTH);\n\tfor (i = 0; i < sizeof(lxc_devs) / sizeof(lxc_devs[0]); i++) {\n\t\tconst struct lxc_devs *d = &lxc_devs[i];\n\t\tret = snprintf(path, MAXPATHLEN, \"%s/dev/%s\", rootfs->path ? rootfs->mount : \"\", d->name);\n\t\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\t\treturn -1;\n\t\tret = mknod(path, d->mode, makedev(d->maj, d->min));\n\t\tif (ret && errno != EEXIST) {\n\t\t\tchar hostpath[MAXPATHLEN];\n\t\t\tFILE *pathfile;\n\n\t\t\t// Unprivileged containers cannot create devices, so\n\t\t\t// bind mount the device from the host\n\t\t\tret = snprintf(hostpath, MAXPATHLEN, \"/dev/%s\", d->name);\n\t\t\tif (ret < 0 || ret >= MAXPATHLEN)\n\t\t\t\treturn -1;\n\t\t\tpathfile = fopen(path, \"wb\");\n\t\t\tif (!pathfile) {\n\t\t\t\tSYSERROR(\"Failed to create device mount target '%s'\", path);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfclose(pathfile);\n\t\t\tif (safe_mount(hostpath, path, 0, MS_BIND, NULL,\n\t\t\t\t\t\trootfs->path ? rootfs->mount : NULL) != 0) {\n\t\t\t\tSYSERROR(\"Failed bind mounting device %s from host into container\",\n\t\t\t\t\td->name);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\tumask(cmask);\n\n\tINFO(\"Populated container /dev\");\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -39,7 +39,8 @@\n \t\t\t\treturn -1;\n \t\t\t}\n \t\t\tfclose(pathfile);\n-\t\t\tif (mount(hostpath, path, 0, MS_BIND, NULL) != 0) {\n+\t\t\tif (safe_mount(hostpath, path, 0, MS_BIND, NULL,\n+\t\t\t\t\t\trootfs->path ? rootfs->mount : NULL) != 0) {\n \t\t\t\tSYSERROR(\"Failed bind mounting device %s from host into container\",\n \t\t\t\t\td->name);\n \t\t\t\treturn -1;",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\tif (mount(hostpath, path, 0, MS_BIND, NULL) != 0) {"
            ],
            "added_lines": [
                "\t\t\tif (safe_mount(hostpath, path, 0, MS_BIND, NULL,",
                "\t\t\t\t\t\trootfs->path ? rootfs->mount : NULL) != 0) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-1335",
        "func_name": "lxc/mount_autodev",
        "description": "lxc-start in lxc before 1.0.8 and 1.1.x before 1.1.4 allows local container administrators to escape AppArmor confinement via a symlink attack on a (1) mount target or (2) bind mount source.",
        "git_url": "https://github.com/lxc/lxc/commit/592fd47a6245508b79fe6ac819fe6d3b2c1289be",
        "commit_title": "CVE-2015-1335: Protect container mounts against symlinks",
        "commit_text": " When a container starts up, lxc sets up the container's inital fstree by doing a bunch of mounting, guided by the container configuration file.  The container config is owned by the admin or user on the host, so we do not try to guard against bad entries.  However, since the mount target is in the container, it's possible that the container admin could divert the mount with symbolic links.  This could bypass proper container startup (i.e. confinement of a root-owned container by the restrictive apparmor policy, by diverting the required write to /proc/self/attr/current), or bypass the (path-based) apparmor policy by diverting, say, /proc to /mnt in the container.  To prevent this,  1. do not allow mounts to paths containing symbolic links  2. do not allow bind mounts from relative paths containing symbolic links.  Details:  Define safe_mount which ensures that the container has not inserted any symbolic links into any mount targets for mounts to be done during container setup.  The host's mount path may contain symbolic links.  As it is under the control of the administrator, that's ok.  So safe_mount begins the check for symbolic links after the rootfs->mount, by opening that directory.  It opens each directory along the path using openat() relative to the parent directory using O_NOFOLLOW.  When the target is reached, it mounts onto /proc/self/fd/<targetfd>.  Use safe_mount() in mount_entry(), when mounting container proc, and when needed.  In particular, safe_mount() need not be used in any case where:  1. the mount is done in the container's namespace 2. the mount is for the container's rootfs 3. the mount is relative to a tmpfs or proc/sysfs which we have    just safe_mount()ed ourselves  Since we were using proc/net as a temporary placeholder for /proc/sys/net during container startup, and proc/net is a symbolic link, use proc/tty instead.  Update the lxc.container.conf manpage with details about the new restrictions.  Finally, add a testcase to test some symbolic link possibilities. ",
        "func_before": "static int mount_autodev(const char *name, const struct lxc_rootfs *rootfs, const char *lxcpath)\n{\n\tint ret;\n\tsize_t clen;\n\tchar *path;\n\n\tINFO(\"Mounting container /dev\");\n\n\t/* $(rootfs->mount) + \"/dev/pts\" + '\\0' */\n\tclen = (rootfs->path ? strlen(rootfs->mount) : 0) + 9;\n\tpath = alloca(clen);\n\n\tret = snprintf(path, clen, \"%s/dev\", rootfs->path ? rootfs->mount : \"\");\n\tif (ret < 0 || ret >= clen)\n\t\treturn -1;\n\n\tif (!dir_exists(path)) {\n\t\tWARN(\"No /dev in container.\");\n\t\tWARN(\"Proceeding without autodev setup\");\n\t\treturn 0;\n\t}\n\n\tif (mount(\"none\", path, \"tmpfs\", 0, \"size=100000,mode=755\")) {\n\t\tSYSERROR(\"Failed mounting tmpfs onto %s\\n\", path);\n\t\treturn false;\n\t}\n\n\tINFO(\"Mounted tmpfs onto %s\",  path);\n\n\tret = snprintf(path, clen, \"%s/dev/pts\", rootfs->path ? rootfs->mount : \"\");\n\tif (ret < 0 || ret >= clen)\n\t\treturn -1;\n\n\t/*\n\t * If we are running on a devtmpfs mapping, dev/pts may already exist.\n\t * If not, then create it and exit if that fails...\n\t */\n\tif (!dir_exists(path)) {\n\t\tret = mkdir(path, S_IRWXU | S_IRGRP | S_IXGRP | S_IROTH | S_IXOTH);\n\t\tif (ret) {\n\t\t\tSYSERROR(\"Failed to create /dev/pts in container\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tINFO(\"Mounted container /dev\");\n\treturn 0;\n}",
        "func": "static int mount_autodev(const char *name, const struct lxc_rootfs *rootfs, const char *lxcpath)\n{\n\tint ret;\n\tsize_t clen;\n\tchar *path;\n\n\tINFO(\"Mounting container /dev\");\n\n\t/* $(rootfs->mount) + \"/dev/pts\" + '\\0' */\n\tclen = (rootfs->path ? strlen(rootfs->mount) : 0) + 9;\n\tpath = alloca(clen);\n\n\tret = snprintf(path, clen, \"%s/dev\", rootfs->path ? rootfs->mount : \"\");\n\tif (ret < 0 || ret >= clen)\n\t\treturn -1;\n\n\tif (!dir_exists(path)) {\n\t\tWARN(\"No /dev in container.\");\n\t\tWARN(\"Proceeding without autodev setup\");\n\t\treturn 0;\n\t}\n\n\tif (safe_mount(\"none\", path, \"tmpfs\", 0, \"size=100000,mode=755\",\n\t\t\t\trootfs->path ? rootfs->mount : NULL)) {\n\t\tSYSERROR(\"Failed mounting tmpfs onto %s\\n\", path);\n\t\treturn false;\n\t}\n\n\tINFO(\"Mounted tmpfs onto %s\",  path);\n\n\tret = snprintf(path, clen, \"%s/dev/pts\", rootfs->path ? rootfs->mount : \"\");\n\tif (ret < 0 || ret >= clen)\n\t\treturn -1;\n\n\t/*\n\t * If we are running on a devtmpfs mapping, dev/pts may already exist.\n\t * If not, then create it and exit if that fails...\n\t */\n\tif (!dir_exists(path)) {\n\t\tret = mkdir(path, S_IRWXU | S_IRGRP | S_IXGRP | S_IROTH | S_IXOTH);\n\t\tif (ret) {\n\t\t\tSYSERROR(\"Failed to create /dev/pts in container\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tINFO(\"Mounted container /dev\");\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -20,7 +20,8 @@\n \t\treturn 0;\n \t}\n \n-\tif (mount(\"none\", path, \"tmpfs\", 0, \"size=100000,mode=755\")) {\n+\tif (safe_mount(\"none\", path, \"tmpfs\", 0, \"size=100000,mode=755\",\n+\t\t\t\trootfs->path ? rootfs->mount : NULL)) {\n \t\tSYSERROR(\"Failed mounting tmpfs onto %s\\n\", path);\n \t\treturn false;\n \t}",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (mount(\"none\", path, \"tmpfs\", 0, \"size=100000,mode=755\")) {"
            ],
            "added_lines": [
                "\tif (safe_mount(\"none\", path, \"tmpfs\", 0, \"size=100000,mode=755\",",
                "\t\t\t\trootfs->path ? rootfs->mount : NULL)) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-1335",
        "func_name": "lxc/lxc_mount_auto_mounts",
        "description": "lxc-start in lxc before 1.0.8 and 1.1.x before 1.1.4 allows local container administrators to escape AppArmor confinement via a symlink attack on a (1) mount target or (2) bind mount source.",
        "git_url": "https://github.com/lxc/lxc/commit/592fd47a6245508b79fe6ac819fe6d3b2c1289be",
        "commit_title": "CVE-2015-1335: Protect container mounts against symlinks",
        "commit_text": " When a container starts up, lxc sets up the container's inital fstree by doing a bunch of mounting, guided by the container configuration file.  The container config is owned by the admin or user on the host, so we do not try to guard against bad entries.  However, since the mount target is in the container, it's possible that the container admin could divert the mount with symbolic links.  This could bypass proper container startup (i.e. confinement of a root-owned container by the restrictive apparmor policy, by diverting the required write to /proc/self/attr/current), or bypass the (path-based) apparmor policy by diverting, say, /proc to /mnt in the container.  To prevent this,  1. do not allow mounts to paths containing symbolic links  2. do not allow bind mounts from relative paths containing symbolic links.  Details:  Define safe_mount which ensures that the container has not inserted any symbolic links into any mount targets for mounts to be done during container setup.  The host's mount path may contain symbolic links.  As it is under the control of the administrator, that's ok.  So safe_mount begins the check for symbolic links after the rootfs->mount, by opening that directory.  It opens each directory along the path using openat() relative to the parent directory using O_NOFOLLOW.  When the target is reached, it mounts onto /proc/self/fd/<targetfd>.  Use safe_mount() in mount_entry(), when mounting container proc, and when needed.  In particular, safe_mount() need not be used in any case where:  1. the mount is done in the container's namespace 2. the mount is for the container's rootfs 3. the mount is relative to a tmpfs or proc/sysfs which we have    just safe_mount()ed ourselves  Since we were using proc/net as a temporary placeholder for /proc/sys/net during container startup, and proc/net is a symbolic link, use proc/tty instead.  Update the lxc.container.conf manpage with details about the new restrictions.  Finally, add a testcase to test some symbolic link possibilities. ",
        "func_before": "static int lxc_mount_auto_mounts(struct lxc_conf *conf, int flags, struct lxc_handler *handler)\n{\n\tint r;\n\tsize_t i;\n\tstatic struct {\n\t\tint match_mask;\n\t\tint match_flag;\n\t\tconst char *source;\n\t\tconst char *destination;\n\t\tconst char *fstype;\n\t\tunsigned long flags;\n\t\tconst char *options;\n\t} default_mounts[] = {\n\t\t/* Read-only bind-mounting... In older kernels, doing that required\n\t\t * to do one MS_BIND mount and then MS_REMOUNT|MS_RDONLY the same\n\t\t * one. According to mount(2) manpage, MS_BIND honors MS_RDONLY from\n\t\t * kernel 2.6.26 onwards. However, this apparently does not work on\n\t\t * kernel 3.8. Unfortunately, on that very same kernel, doing the\n\t\t * same trick as above doesn't seem to work either, there one needs\n\t\t * to ALSO specify MS_BIND for the remount, otherwise the entire\n\t\t * fs is remounted read-only or the mount fails because it's busy...\n\t\t * MS_REMOUNT|MS_BIND|MS_RDONLY seems to work for kernels as low as\n\t\t * 2.6.32...\n\t\t */\n\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \"proc\",                                              \"%r/proc\",                      \"proc\",     MS_NODEV|MS_NOEXEC|MS_NOSUID,   NULL },\n\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \"%r/proc/sys/net\",                                   \"%r/proc/net\",                  NULL,       MS_BIND,                        NULL },\n\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \"%r/proc/sys\",                                       \"%r/proc/sys\",                  NULL,       MS_BIND,                        NULL },\n\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, NULL,                                                \"%r/proc/sys\",                  NULL,       MS_REMOUNT|MS_BIND|MS_RDONLY,   NULL },\n\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \"%r/proc/net\",                                       \"%r/proc/sys/net\",              NULL,       MS_MOVE,                        NULL },\n\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \"%r/proc/sysrq-trigger\",                             \"%r/proc/sysrq-trigger\",        NULL,       MS_BIND,                        NULL },\n\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, NULL,                                                \"%r/proc/sysrq-trigger\",        NULL,       MS_REMOUNT|MS_BIND|MS_RDONLY,   NULL },\n\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_RW,    \"proc\",                                              \"%r/proc\",                      \"proc\",     MS_NODEV|MS_NOEXEC|MS_NOSUID,   NULL },\n\t\t{ LXC_AUTO_SYS_MASK,  LXC_AUTO_SYS_RW,     \"sysfs\",                                             \"%r/sys\",                       \"sysfs\",    0,                              NULL },\n\t\t{ LXC_AUTO_SYS_MASK,  LXC_AUTO_SYS_RO,     \"sysfs\",                                             \"%r/sys\",                       \"sysfs\",    MS_RDONLY,                      NULL },\n\t\t{ LXC_AUTO_SYS_MASK,  LXC_AUTO_SYS_MIXED,  \"sysfs\",                                             \"%r/sys\",                       \"sysfs\",    MS_NODEV|MS_NOEXEC|MS_NOSUID,   NULL },\n\t\t{ LXC_AUTO_SYS_MASK,  LXC_AUTO_SYS_MIXED,  \"%r/sys\",                                            \"%r/sys\",                       NULL,       MS_BIND,                        NULL },\n\t\t{ LXC_AUTO_SYS_MASK,  LXC_AUTO_SYS_MIXED,  NULL,                                                \"%r/sys\",                       NULL,       MS_REMOUNT|MS_BIND|MS_RDONLY,   NULL },\n\t\t{ LXC_AUTO_SYS_MASK,  LXC_AUTO_SYS_MIXED,  \"sysfs\",                                             \"%r/sys/devices/virtual/net\",   \"sysfs\",    0,                              NULL },\n\t\t{ LXC_AUTO_SYS_MASK,  LXC_AUTO_SYS_MIXED,  \"%r/sys/devices/virtual/net/devices/virtual/net\",    \"%r/sys/devices/virtual/net\",   NULL,       MS_BIND,                        NULL },\n\t\t{ LXC_AUTO_SYS_MASK,  LXC_AUTO_SYS_MIXED,  NULL,                                                \"%r/sys/devices/virtual/net\",   NULL,       MS_REMOUNT|MS_BIND|MS_NOSUID|MS_NODEV|MS_NOEXEC,   NULL },\n\t\t{ 0,                  0,                   NULL,                                                NULL,                           NULL,       0,                              NULL }\n\t};\n\n\tfor (i = 0; default_mounts[i].match_mask; i++) {\n\t\tif ((flags & default_mounts[i].match_mask) == default_mounts[i].match_flag) {\n\t\t\tchar *source = NULL;\n\t\t\tchar *destination = NULL;\n\t\t\tint saved_errno;\n\t\t\tunsigned long mflags;\n\n\t\t\tif (default_mounts[i].source) {\n\t\t\t\t/* will act like strdup if %r is not present */\n\t\t\t\tsource = lxc_string_replace(\"%r\", conf->rootfs.path ? conf->rootfs.mount : \"\", default_mounts[i].source);\n\t\t\t\tif (!source) {\n\t\t\t\t\tSYSERROR(\"memory allocation error\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (default_mounts[i].destination) {\n\t\t\t\t/* will act like strdup if %r is not present */\n\t\t\t\tdestination = lxc_string_replace(\"%r\", conf->rootfs.path ? conf->rootfs.mount : \"\", default_mounts[i].destination);\n\t\t\t\tif (!destination) {\n\t\t\t\t\tsaved_errno = errno;\n\t\t\t\t\tSYSERROR(\"memory allocation error\");\n\t\t\t\t\tfree(source);\n\t\t\t\t\terrno = saved_errno;\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmflags = add_required_remount_flags(source, destination,\n\t\t\t\t\tdefault_mounts[i].flags);\n\t\t\tr = mount(source, destination, default_mounts[i].fstype, mflags, default_mounts[i].options);\n\t\t\tsaved_errno = errno;\n\t\t\tif (r < 0 && errno == ENOENT) {\n\t\t\t\tINFO(\"Mount source or target for %s on %s doesn't exist. Skipping.\", source, destination);\n\t\t\t\tr = 0;\n\t\t\t}\n\t\t\telse if (r < 0)\n\t\t\t\tSYSERROR(\"error mounting %s on %s flags %lu\", source, destination, mflags);\n\n\t\t\tfree(source);\n\t\t\tfree(destination);\n\t\t\tif (r < 0) {\n\t\t\t\terrno = saved_errno;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (flags & LXC_AUTO_CGROUP_MASK) {\n\t\tint cg_flags;\n\n\t\tcg_flags = flags & LXC_AUTO_CGROUP_MASK;\n\t\t/* If the type of cgroup mount was not specified, it depends on the\n\t\t * container's capabilities as to what makes sense: if we have\n\t\t * CAP_SYS_ADMIN, the read-only part can be remounted read-write\n\t\t * anyway, so we may as well default to read-write; then the admin\n\t\t * will not be given a false sense of security. (And if they really\n\t\t * want mixed r/o r/w, then they can explicitly specify :mixed.)\n\t\t * OTOH, if the container lacks CAP_SYS_ADMIN, do only default to\n\t\t * :mixed, because then the container can't remount it read-write. */\n\t\tif (cg_flags == LXC_AUTO_CGROUP_NOSPEC || cg_flags == LXC_AUTO_CGROUP_FULL_NOSPEC) {\n\t\t\tint has_sys_admin = 0;\n\t\t\tif (!lxc_list_empty(&conf->keepcaps)) {\n\t\t\t\thas_sys_admin = in_caplist(CAP_SYS_ADMIN, &conf->keepcaps);\n\t\t\t} else {\n\t\t\t\thas_sys_admin = !in_caplist(CAP_SYS_ADMIN, &conf->caps);\n\t\t\t}\n\t\t\tif (cg_flags == LXC_AUTO_CGROUP_NOSPEC) {\n\t\t\t\tcg_flags = has_sys_admin ? LXC_AUTO_CGROUP_RW : LXC_AUTO_CGROUP_MIXED;\n\t\t\t} else {\n\t\t\t\tcg_flags = has_sys_admin ? LXC_AUTO_CGROUP_FULL_RW : LXC_AUTO_CGROUP_FULL_MIXED;\n\t\t\t}\n\t\t}\n\n\t\tif (!cgroup_mount(conf->rootfs.path ? conf->rootfs.mount : \"\", handler, cg_flags)) {\n\t\t\tSYSERROR(\"error mounting /sys/fs/cgroup\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}",
        "func": "static int lxc_mount_auto_mounts(struct lxc_conf *conf, int flags, struct lxc_handler *handler)\n{\n\tint r;\n\tsize_t i;\n\tstatic struct {\n\t\tint match_mask;\n\t\tint match_flag;\n\t\tconst char *source;\n\t\tconst char *destination;\n\t\tconst char *fstype;\n\t\tunsigned long flags;\n\t\tconst char *options;\n\t} default_mounts[] = {\n\t\t/* Read-only bind-mounting... In older kernels, doing that required\n\t\t * to do one MS_BIND mount and then MS_REMOUNT|MS_RDONLY the same\n\t\t * one. According to mount(2) manpage, MS_BIND honors MS_RDONLY from\n\t\t * kernel 2.6.26 onwards. However, this apparently does not work on\n\t\t * kernel 3.8. Unfortunately, on that very same kernel, doing the\n\t\t * same trick as above doesn't seem to work either, there one needs\n\t\t * to ALSO specify MS_BIND for the remount, otherwise the entire\n\t\t * fs is remounted read-only or the mount fails because it's busy...\n\t\t * MS_REMOUNT|MS_BIND|MS_RDONLY seems to work for kernels as low as\n\t\t * 2.6.32...\n\t\t */\n\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \"proc\",                                              \"%r/proc\",                      \"proc\",     MS_NODEV|MS_NOEXEC|MS_NOSUID,   NULL },\n\t\t/* proc/tty is used as a temporary placeholder for proc/sys/net which we'll move back in a few steps */\n\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \"%r/proc/sys/net\",                                   \"%r/proc/tty\",                  NULL,       MS_BIND,                        NULL },\n\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \"%r/proc/sys\",                                       \"%r/proc/sys\",                  NULL,       MS_BIND,                        NULL },\n\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, NULL,                                                \"%r/proc/sys\",                  NULL,       MS_REMOUNT|MS_BIND|MS_RDONLY,   NULL },\n\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \"%r/proc/tty\",                                       \"%r/proc/sys/net\",              NULL,       MS_MOVE,                        NULL },\n\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \"%r/proc/sysrq-trigger\",                             \"%r/proc/sysrq-trigger\",        NULL,       MS_BIND,                        NULL },\n\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, NULL,                                                \"%r/proc/sysrq-trigger\",        NULL,       MS_REMOUNT|MS_BIND|MS_RDONLY,   NULL },\n\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_RW,    \"proc\",                                              \"%r/proc\",                      \"proc\",     MS_NODEV|MS_NOEXEC|MS_NOSUID,   NULL },\n\t\t{ LXC_AUTO_SYS_MASK,  LXC_AUTO_SYS_RW,     \"sysfs\",                                             \"%r/sys\",                       \"sysfs\",    0,                              NULL },\n\t\t{ LXC_AUTO_SYS_MASK,  LXC_AUTO_SYS_RO,     \"sysfs\",                                             \"%r/sys\",                       \"sysfs\",    MS_RDONLY,                      NULL },\n\t\t{ LXC_AUTO_SYS_MASK,  LXC_AUTO_SYS_MIXED,  \"sysfs\",                                             \"%r/sys\",                       \"sysfs\",    MS_NODEV|MS_NOEXEC|MS_NOSUID,   NULL },\n\t\t{ LXC_AUTO_SYS_MASK,  LXC_AUTO_SYS_MIXED,  \"%r/sys\",                                            \"%r/sys\",                       NULL,       MS_BIND,                        NULL },\n\t\t{ LXC_AUTO_SYS_MASK,  LXC_AUTO_SYS_MIXED,  NULL,                                                \"%r/sys\",                       NULL,       MS_REMOUNT|MS_BIND|MS_RDONLY,   NULL },\n\t\t{ LXC_AUTO_SYS_MASK,  LXC_AUTO_SYS_MIXED,  \"sysfs\",                                             \"%r/sys/devices/virtual/net\",   \"sysfs\",    0,                              NULL },\n\t\t{ LXC_AUTO_SYS_MASK,  LXC_AUTO_SYS_MIXED,  \"%r/sys/devices/virtual/net/devices/virtual/net\",    \"%r/sys/devices/virtual/net\",   NULL,       MS_BIND,                        NULL },\n\t\t{ LXC_AUTO_SYS_MASK,  LXC_AUTO_SYS_MIXED,  NULL,                                                \"%r/sys/devices/virtual/net\",   NULL,       MS_REMOUNT|MS_BIND|MS_NOSUID|MS_NODEV|MS_NOEXEC,   NULL },\n\t\t{ 0,                  0,                   NULL,                                                NULL,                           NULL,       0,                              NULL }\n\t};\n\n\tfor (i = 0; default_mounts[i].match_mask; i++) {\n\t\tif ((flags & default_mounts[i].match_mask) == default_mounts[i].match_flag) {\n\t\t\tchar *source = NULL;\n\t\t\tchar *destination = NULL;\n\t\t\tint saved_errno;\n\t\t\tunsigned long mflags;\n\n\t\t\tif (default_mounts[i].source) {\n\t\t\t\t/* will act like strdup if %r is not present */\n\t\t\t\tsource = lxc_string_replace(\"%r\", conf->rootfs.path ? conf->rootfs.mount : \"\", default_mounts[i].source);\n\t\t\t\tif (!source) {\n\t\t\t\t\tSYSERROR(\"memory allocation error\");\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (default_mounts[i].destination) {\n\t\t\t\t/* will act like strdup if %r is not present */\n\t\t\t\tdestination = lxc_string_replace(\"%r\", conf->rootfs.path ? conf->rootfs.mount : \"\", default_mounts[i].destination);\n\t\t\t\tif (!destination) {\n\t\t\t\t\tsaved_errno = errno;\n\t\t\t\t\tSYSERROR(\"memory allocation error\");\n\t\t\t\t\tfree(source);\n\t\t\t\t\terrno = saved_errno;\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmflags = add_required_remount_flags(source, destination,\n\t\t\t\t\tdefault_mounts[i].flags);\n\t\t\tr = safe_mount(source, destination, default_mounts[i].fstype, mflags, default_mounts[i].options, conf->rootfs.path ? conf->rootfs.mount : NULL);\n\t\t\tsaved_errno = errno;\n\t\t\tif (r < 0 && errno == ENOENT) {\n\t\t\t\tINFO(\"Mount source or target for %s on %s doesn't exist. Skipping.\", source, destination);\n\t\t\t\tr = 0;\n\t\t\t}\n\t\t\telse if (r < 0)\n\t\t\t\tSYSERROR(\"error mounting %s on %s flags %lu\", source, destination, mflags);\n\n\t\t\tfree(source);\n\t\t\tfree(destination);\n\t\t\tif (r < 0) {\n\t\t\t\terrno = saved_errno;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (flags & LXC_AUTO_CGROUP_MASK) {\n\t\tint cg_flags;\n\n\t\tcg_flags = flags & LXC_AUTO_CGROUP_MASK;\n\t\t/* If the type of cgroup mount was not specified, it depends on the\n\t\t * container's capabilities as to what makes sense: if we have\n\t\t * CAP_SYS_ADMIN, the read-only part can be remounted read-write\n\t\t * anyway, so we may as well default to read-write; then the admin\n\t\t * will not be given a false sense of security. (And if they really\n\t\t * want mixed r/o r/w, then they can explicitly specify :mixed.)\n\t\t * OTOH, if the container lacks CAP_SYS_ADMIN, do only default to\n\t\t * :mixed, because then the container can't remount it read-write. */\n\t\tif (cg_flags == LXC_AUTO_CGROUP_NOSPEC || cg_flags == LXC_AUTO_CGROUP_FULL_NOSPEC) {\n\t\t\tint has_sys_admin = 0;\n\t\t\tif (!lxc_list_empty(&conf->keepcaps)) {\n\t\t\t\thas_sys_admin = in_caplist(CAP_SYS_ADMIN, &conf->keepcaps);\n\t\t\t} else {\n\t\t\t\thas_sys_admin = !in_caplist(CAP_SYS_ADMIN, &conf->caps);\n\t\t\t}\n\t\t\tif (cg_flags == LXC_AUTO_CGROUP_NOSPEC) {\n\t\t\t\tcg_flags = has_sys_admin ? LXC_AUTO_CGROUP_RW : LXC_AUTO_CGROUP_MIXED;\n\t\t\t} else {\n\t\t\t\tcg_flags = has_sys_admin ? LXC_AUTO_CGROUP_FULL_RW : LXC_AUTO_CGROUP_FULL_MIXED;\n\t\t\t}\n\t\t}\n\n\t\tif (!cgroup_mount(conf->rootfs.path ? conf->rootfs.mount : \"\", handler, cg_flags)) {\n\t\t\tSYSERROR(\"error mounting /sys/fs/cgroup\");\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -23,10 +23,11 @@\n \t\t * 2.6.32...\n \t\t */\n \t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \"proc\",                                              \"%r/proc\",                      \"proc\",     MS_NODEV|MS_NOEXEC|MS_NOSUID,   NULL },\n-\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \"%r/proc/sys/net\",                                   \"%r/proc/net\",                  NULL,       MS_BIND,                        NULL },\n+\t\t/* proc/tty is used as a temporary placeholder for proc/sys/net which we'll move back in a few steps */\n+\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \"%r/proc/sys/net\",                                   \"%r/proc/tty\",                  NULL,       MS_BIND,                        NULL },\n \t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \"%r/proc/sys\",                                       \"%r/proc/sys\",                  NULL,       MS_BIND,                        NULL },\n \t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, NULL,                                                \"%r/proc/sys\",                  NULL,       MS_REMOUNT|MS_BIND|MS_RDONLY,   NULL },\n-\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \"%r/proc/net\",                                       \"%r/proc/sys/net\",              NULL,       MS_MOVE,                        NULL },\n+\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \"%r/proc/tty\",                                       \"%r/proc/sys/net\",              NULL,       MS_MOVE,                        NULL },\n \t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \"%r/proc/sysrq-trigger\",                             \"%r/proc/sysrq-trigger\",        NULL,       MS_BIND,                        NULL },\n \t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, NULL,                                                \"%r/proc/sysrq-trigger\",        NULL,       MS_REMOUNT|MS_BIND|MS_RDONLY,   NULL },\n \t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_RW,    \"proc\",                                              \"%r/proc\",                      \"proc\",     MS_NODEV|MS_NOEXEC|MS_NOSUID,   NULL },\n@@ -69,7 +70,7 @@\n \t\t\t}\n \t\t\tmflags = add_required_remount_flags(source, destination,\n \t\t\t\t\tdefault_mounts[i].flags);\n-\t\t\tr = mount(source, destination, default_mounts[i].fstype, mflags, default_mounts[i].options);\n+\t\t\tr = safe_mount(source, destination, default_mounts[i].fstype, mflags, default_mounts[i].options, conf->rootfs.path ? conf->rootfs.mount : NULL);\n \t\t\tsaved_errno = errno;\n \t\t\tif (r < 0 && errno == ENOENT) {\n \t\t\t\tINFO(\"Mount source or target for %s on %s doesn't exist. Skipping.\", source, destination);",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \"%r/proc/sys/net\",                                   \"%r/proc/net\",                  NULL,       MS_BIND,                        NULL },",
                "\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \"%r/proc/net\",                                       \"%r/proc/sys/net\",              NULL,       MS_MOVE,                        NULL },",
                "\t\t\tr = mount(source, destination, default_mounts[i].fstype, mflags, default_mounts[i].options);"
            ],
            "added_lines": [
                "\t\t/* proc/tty is used as a temporary placeholder for proc/sys/net which we'll move back in a few steps */",
                "\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \"%r/proc/sys/net\",                                   \"%r/proc/tty\",                  NULL,       MS_BIND,                        NULL },",
                "\t\t{ LXC_AUTO_PROC_MASK, LXC_AUTO_PROC_MIXED, \"%r/proc/tty\",                                       \"%r/proc/sys/net\",              NULL,       MS_MOVE,                        NULL },",
                "\t\t\tr = safe_mount(source, destination, default_mounts[i].fstype, mflags, default_mounts[i].options, conf->rootfs.path ? conf->rootfs.mount : NULL);"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-1335",
        "func_name": "lxc/mount_entry",
        "description": "lxc-start in lxc before 1.0.8 and 1.1.x before 1.1.4 allows local container administrators to escape AppArmor confinement via a symlink attack on a (1) mount target or (2) bind mount source.",
        "git_url": "https://github.com/lxc/lxc/commit/592fd47a6245508b79fe6ac819fe6d3b2c1289be",
        "commit_title": "CVE-2015-1335: Protect container mounts against symlinks",
        "commit_text": " When a container starts up, lxc sets up the container's inital fstree by doing a bunch of mounting, guided by the container configuration file.  The container config is owned by the admin or user on the host, so we do not try to guard against bad entries.  However, since the mount target is in the container, it's possible that the container admin could divert the mount with symbolic links.  This could bypass proper container startup (i.e. confinement of a root-owned container by the restrictive apparmor policy, by diverting the required write to /proc/self/attr/current), or bypass the (path-based) apparmor policy by diverting, say, /proc to /mnt in the container.  To prevent this,  1. do not allow mounts to paths containing symbolic links  2. do not allow bind mounts from relative paths containing symbolic links.  Details:  Define safe_mount which ensures that the container has not inserted any symbolic links into any mount targets for mounts to be done during container setup.  The host's mount path may contain symbolic links.  As it is under the control of the administrator, that's ok.  So safe_mount begins the check for symbolic links after the rootfs->mount, by opening that directory.  It opens each directory along the path using openat() relative to the parent directory using O_NOFOLLOW.  When the target is reached, it mounts onto /proc/self/fd/<targetfd>.  Use safe_mount() in mount_entry(), when mounting container proc, and when needed.  In particular, safe_mount() need not be used in any case where:  1. the mount is done in the container's namespace 2. the mount is for the container's rootfs 3. the mount is relative to a tmpfs or proc/sysfs which we have    just safe_mount()ed ourselves  Since we were using proc/net as a temporary placeholder for /proc/sys/net during container startup, and proc/net is a symbolic link, use proc/tty instead.  Update the lxc.container.conf manpage with details about the new restrictions.  Finally, add a testcase to test some symbolic link possibilities. ",
        "func_before": "static int mount_entry(const char *fsname, const char *target,\n\t\t       const char *fstype, unsigned long mountflags,\n\t\t       const char *data, int optional)\n{\n#ifdef HAVE_STATVFS\n\tstruct statvfs sb;\n#endif\n\n\tif (mount(fsname, target, fstype, mountflags & ~MS_REMOUNT, data)) {\n\t\tif (optional) {\n\t\t\tINFO(\"failed to mount '%s' on '%s' (optional): %s\", fsname,\n\t\t\t     target, strerror(errno));\n\t\t\treturn 0;\n\t\t}\n\t\telse {\n\t\t\tSYSERROR(\"failed to mount '%s' on '%s'\", fsname, target);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif ((mountflags & MS_REMOUNT) || (mountflags & MS_BIND)) {\n\t\tDEBUG(\"remounting %s on %s to respect bind or remount options\",\n\t\t      fsname ? fsname : \"(none)\", target ? target : \"(none)\");\n\t\tunsigned long rqd_flags = 0;\n\t\tif (mountflags & MS_RDONLY)\n\t\t\trqd_flags |= MS_RDONLY;\n#ifdef HAVE_STATVFS\n\t\tif (statvfs(fsname, &sb) == 0) {\n\t\t\tunsigned long required_flags = rqd_flags;\n\t\t\tif (sb.f_flag & MS_NOSUID)\n\t\t\t\trequired_flags |= MS_NOSUID;\n\t\t\tif (sb.f_flag & MS_NODEV)\n\t\t\t\trequired_flags |= MS_NODEV;\n\t\t\tif (sb.f_flag & MS_RDONLY)\n\t\t\t\trequired_flags |= MS_RDONLY;\n\t\t\tif (sb.f_flag & MS_NOEXEC)\n\t\t\t\trequired_flags |= MS_NOEXEC;\n\t\t\tDEBUG(\"(at remount) flags for %s was %lu, required extra flags are %lu\", fsname, sb.f_flag, required_flags);\n\t\t\t/*\n\t\t\t * If this was a bind mount request, and required_flags\n\t\t\t * does not have any flags which are not already in\n\t\t\t * mountflags, then skip the remount\n\t\t\t */\n\t\t\tif (!(mountflags & MS_REMOUNT)) {\n\t\t\t\tif (!(required_flags & ~mountflags) && rqd_flags == 0) {\n\t\t\t\t\tDEBUG(\"mountflags already was %lu, skipping remount\",\n\t\t\t\t\t\tmountflags);\n\t\t\t\t\tgoto skipremount;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmountflags |= required_flags;\n\t\t}\n#endif\n\n\t\tif (mount(fsname, target, fstype,\n\t\t\t  mountflags | MS_REMOUNT, data)) {\n\t\t\tif (optional) {\n\t\t\t\tINFO(\"failed to mount '%s' on '%s' (optional): %s\",\n\t\t\t\t\t fsname, target, strerror(errno));\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSYSERROR(\"failed to mount '%s' on '%s'\",\n\t\t\t\t\t fsname, target);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n#ifdef HAVE_STATVFS\nskipremount:\n#endif\n\tDEBUG(\"mounted '%s' on '%s', type '%s'\", fsname, target, fstype);\n\n\treturn 0;\n}",
        "func": "static int mount_entry(const char *fsname, const char *target,\n\t\t       const char *fstype, unsigned long mountflags,\n\t\t       const char *data, int optional, const char *rootfs)\n{\n#ifdef HAVE_STATVFS\n\tstruct statvfs sb;\n#endif\n\n\tif (safe_mount(fsname, target, fstype, mountflags & ~MS_REMOUNT, data, rootfs)) {\n\t\tif (optional) {\n\t\t\tINFO(\"failed to mount '%s' on '%s' (optional): %s\", fsname,\n\t\t\t     target, strerror(errno));\n\t\t\treturn 0;\n\t\t}\n\t\telse {\n\t\t\tSYSERROR(\"failed to mount '%s' on '%s'\", fsname, target);\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tif ((mountflags & MS_REMOUNT) || (mountflags & MS_BIND)) {\n\t\tDEBUG(\"remounting %s on %s to respect bind or remount options\",\n\t\t      fsname ? fsname : \"(none)\", target ? target : \"(none)\");\n\t\tunsigned long rqd_flags = 0;\n\t\tif (mountflags & MS_RDONLY)\n\t\t\trqd_flags |= MS_RDONLY;\n#ifdef HAVE_STATVFS\n\t\tif (statvfs(fsname, &sb) == 0) {\n\t\t\tunsigned long required_flags = rqd_flags;\n\t\t\tif (sb.f_flag & MS_NOSUID)\n\t\t\t\trequired_flags |= MS_NOSUID;\n\t\t\tif (sb.f_flag & MS_NODEV)\n\t\t\t\trequired_flags |= MS_NODEV;\n\t\t\tif (sb.f_flag & MS_RDONLY)\n\t\t\t\trequired_flags |= MS_RDONLY;\n\t\t\tif (sb.f_flag & MS_NOEXEC)\n\t\t\t\trequired_flags |= MS_NOEXEC;\n\t\t\tDEBUG(\"(at remount) flags for %s was %lu, required extra flags are %lu\", fsname, sb.f_flag, required_flags);\n\t\t\t/*\n\t\t\t * If this was a bind mount request, and required_flags\n\t\t\t * does not have any flags which are not already in\n\t\t\t * mountflags, then skip the remount\n\t\t\t */\n\t\t\tif (!(mountflags & MS_REMOUNT)) {\n\t\t\t\tif (!(required_flags & ~mountflags) && rqd_flags == 0) {\n\t\t\t\t\tDEBUG(\"mountflags already was %lu, skipping remount\",\n\t\t\t\t\t\tmountflags);\n\t\t\t\t\tgoto skipremount;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmountflags |= required_flags;\n\t\t}\n#endif\n\n\t\tif (mount(fsname, target, fstype,\n\t\t\t  mountflags | MS_REMOUNT, data) < 0) {\n\t\t\tif (optional) {\n\t\t\t\tINFO(\"failed to mount '%s' on '%s' (optional): %s\",\n\t\t\t\t\t fsname, target, strerror(errno));\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSYSERROR(\"failed to mount '%s' on '%s'\",\n\t\t\t\t\t fsname, target);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n#ifdef HAVE_STATVFS\nskipremount:\n#endif\n\tDEBUG(\"mounted '%s' on '%s', type '%s'\", fsname, target, fstype);\n\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,12 +1,12 @@\n static int mount_entry(const char *fsname, const char *target,\n \t\t       const char *fstype, unsigned long mountflags,\n-\t\t       const char *data, int optional)\n+\t\t       const char *data, int optional, const char *rootfs)\n {\n #ifdef HAVE_STATVFS\n \tstruct statvfs sb;\n #endif\n \n-\tif (mount(fsname, target, fstype, mountflags & ~MS_REMOUNT, data)) {\n+\tif (safe_mount(fsname, target, fstype, mountflags & ~MS_REMOUNT, data, rootfs)) {\n \t\tif (optional) {\n \t\t\tINFO(\"failed to mount '%s' on '%s' (optional): %s\", fsname,\n \t\t\t     target, strerror(errno));\n@@ -53,7 +53,7 @@\n #endif\n \n \t\tif (mount(fsname, target, fstype,\n-\t\t\t  mountflags | MS_REMOUNT, data)) {\n+\t\t\t  mountflags | MS_REMOUNT, data) < 0) {\n \t\t\tif (optional) {\n \t\t\t\tINFO(\"failed to mount '%s' on '%s' (optional): %s\",\n \t\t\t\t\t fsname, target, strerror(errno));",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t       const char *data, int optional)",
                "\tif (mount(fsname, target, fstype, mountflags & ~MS_REMOUNT, data)) {",
                "\t\t\t  mountflags | MS_REMOUNT, data)) {"
            ],
            "added_lines": [
                "\t\t       const char *data, int optional, const char *rootfs)",
                "\tif (safe_mount(fsname, target, fstype, mountflags & ~MS_REMOUNT, data, rootfs)) {",
                "\t\t\t  mountflags | MS_REMOUNT, data) < 0) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-1335",
        "func_name": "lxc/setup_ttydir_console",
        "description": "lxc-start in lxc before 1.0.8 and 1.1.x before 1.1.4 allows local container administrators to escape AppArmor confinement via a symlink attack on a (1) mount target or (2) bind mount source.",
        "git_url": "https://github.com/lxc/lxc/commit/592fd47a6245508b79fe6ac819fe6d3b2c1289be",
        "commit_title": "CVE-2015-1335: Protect container mounts against symlinks",
        "commit_text": " When a container starts up, lxc sets up the container's inital fstree by doing a bunch of mounting, guided by the container configuration file.  The container config is owned by the admin or user on the host, so we do not try to guard against bad entries.  However, since the mount target is in the container, it's possible that the container admin could divert the mount with symbolic links.  This could bypass proper container startup (i.e. confinement of a root-owned container by the restrictive apparmor policy, by diverting the required write to /proc/self/attr/current), or bypass the (path-based) apparmor policy by diverting, say, /proc to /mnt in the container.  To prevent this,  1. do not allow mounts to paths containing symbolic links  2. do not allow bind mounts from relative paths containing symbolic links.  Details:  Define safe_mount which ensures that the container has not inserted any symbolic links into any mount targets for mounts to be done during container setup.  The host's mount path may contain symbolic links.  As it is under the control of the administrator, that's ok.  So safe_mount begins the check for symbolic links after the rootfs->mount, by opening that directory.  It opens each directory along the path using openat() relative to the parent directory using O_NOFOLLOW.  When the target is reached, it mounts onto /proc/self/fd/<targetfd>.  Use safe_mount() in mount_entry(), when mounting container proc, and when needed.  In particular, safe_mount() need not be used in any case where:  1. the mount is done in the container's namespace 2. the mount is for the container's rootfs 3. the mount is relative to a tmpfs or proc/sysfs which we have    just safe_mount()ed ourselves  Since we were using proc/net as a temporary placeholder for /proc/sys/net during container startup, and proc/net is a symbolic link, use proc/tty instead.  Update the lxc.container.conf manpage with details about the new restrictions.  Finally, add a testcase to test some symbolic link possibilities. ",
        "func_before": "static int setup_ttydir_console(const struct lxc_rootfs *rootfs,\n\t\t\t const struct lxc_console *console,\n\t\t\t char *ttydir)\n{\n\tchar path[MAXPATHLEN], lxcpath[MAXPATHLEN];\n\tint ret;\n\n\t/* create rootfs/dev/<ttydir> directory */\n\tret = snprintf(path, sizeof(path), \"%s/dev/%s\", rootfs->mount,\n\t\t       ttydir);\n\tif (ret >= sizeof(path))\n\t\treturn -1;\n\tret = mkdir(path, 0755);\n\tif (ret && errno != EEXIST) {\n\t\tSYSERROR(\"failed with errno %d to create %s\", errno, path);\n\t\treturn -1;\n\t}\n\tINFO(\"created %s\", path);\n\n\tret = snprintf(lxcpath, sizeof(lxcpath), \"%s/dev/%s/console\",\n\t\t       rootfs->mount, ttydir);\n\tif (ret >= sizeof(lxcpath)) {\n\t\tERROR(\"console path too long\");\n\t\treturn -1;\n\t}\n\n\tsnprintf(path, sizeof(path), \"%s/dev/console\", rootfs->mount);\n\tret = unlink(path);\n\tif (ret && errno != ENOENT) {\n\t\tSYSERROR(\"error unlinking %s\", path);\n\t\treturn -1;\n\t}\n\n\tret = creat(lxcpath, 0660);\n\tif (ret==-1 && errno != EEXIST) {\n\t\tSYSERROR(\"error %d creating %s\", errno, lxcpath);\n\t\treturn -1;\n\t}\n\tif (ret >= 0)\n\t\tclose(ret);\n\n\tif (console->master < 0) {\n\t\tINFO(\"no console\");\n\t\treturn 0;\n\t}\n\n\tif (mount(console->name, lxcpath, \"none\", MS_BIND, 0)) {\n\t\tERROR(\"failed to mount '%s' on '%s'\", console->name, lxcpath);\n\t\treturn -1;\n\t}\n\n\t/* create symlink from rootfs/dev/console to 'lxc/console' */\n\tret = snprintf(lxcpath, sizeof(lxcpath), \"%s/console\", ttydir);\n\tif (ret >= sizeof(lxcpath)) {\n\t\tERROR(\"lxc/console path too long\");\n\t\treturn -1;\n\t}\n\tret = symlink(lxcpath, path);\n\tif (ret) {\n\t\tSYSERROR(\"failed to create symlink for console\");\n\t\treturn -1;\n\t}\n\n\tINFO(\"console has been setup on %s\", lxcpath);\n\n\treturn 0;\n}",
        "func": "static int setup_ttydir_console(const struct lxc_rootfs *rootfs,\n\t\t\t const struct lxc_console *console,\n\t\t\t char *ttydir)\n{\n\tchar path[MAXPATHLEN], lxcpath[MAXPATHLEN];\n\tint ret;\n\n\t/* create rootfs/dev/<ttydir> directory */\n\tret = snprintf(path, sizeof(path), \"%s/dev/%s\", rootfs->mount,\n\t\t       ttydir);\n\tif (ret >= sizeof(path))\n\t\treturn -1;\n\tret = mkdir(path, 0755);\n\tif (ret && errno != EEXIST) {\n\t\tSYSERROR(\"failed with errno %d to create %s\", errno, path);\n\t\treturn -1;\n\t}\n\tINFO(\"created %s\", path);\n\n\tret = snprintf(lxcpath, sizeof(lxcpath), \"%s/dev/%s/console\",\n\t\t       rootfs->mount, ttydir);\n\tif (ret >= sizeof(lxcpath)) {\n\t\tERROR(\"console path too long\");\n\t\treturn -1;\n\t}\n\n\tsnprintf(path, sizeof(path), \"%s/dev/console\", rootfs->mount);\n\tret = unlink(path);\n\tif (ret && errno != ENOENT) {\n\t\tSYSERROR(\"error unlinking %s\", path);\n\t\treturn -1;\n\t}\n\n\tret = creat(lxcpath, 0660);\n\tif (ret==-1 && errno != EEXIST) {\n\t\tSYSERROR(\"error %d creating %s\", errno, lxcpath);\n\t\treturn -1;\n\t}\n\tif (ret >= 0)\n\t\tclose(ret);\n\n\tif (console->master < 0) {\n\t\tINFO(\"no console\");\n\t\treturn 0;\n\t}\n\n\tif (safe_mount(console->name, lxcpath, \"none\", MS_BIND, 0, rootfs->mount)) {\n\t\tERROR(\"failed to mount '%s' on '%s'\", console->name, lxcpath);\n\t\treturn -1;\n\t}\n\n\t/* create symlink from rootfs/dev/console to 'lxc/console' */\n\tret = snprintf(lxcpath, sizeof(lxcpath), \"%s/console\", ttydir);\n\tif (ret >= sizeof(lxcpath)) {\n\t\tERROR(\"lxc/console path too long\");\n\t\treturn -1;\n\t}\n\tret = symlink(lxcpath, path);\n\tif (ret) {\n\t\tSYSERROR(\"failed to create symlink for console\");\n\t\treturn -1;\n\t}\n\n\tINFO(\"console has been setup on %s\", lxcpath);\n\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -44,7 +44,7 @@\n \t\treturn 0;\n \t}\n \n-\tif (mount(console->name, lxcpath, \"none\", MS_BIND, 0)) {\n+\tif (safe_mount(console->name, lxcpath, \"none\", MS_BIND, 0, rootfs->mount)) {\n \t\tERROR(\"failed to mount '%s' on '%s'\", console->name, lxcpath);\n \t\treturn -1;\n \t}",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (mount(console->name, lxcpath, \"none\", MS_BIND, 0)) {"
            ],
            "added_lines": [
                "\tif (safe_mount(console->name, lxcpath, \"none\", MS_BIND, 0, rootfs->mount)) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-1335",
        "func_name": "lxc/mount_entry_on_systemfs",
        "description": "lxc-start in lxc before 1.0.8 and 1.1.x before 1.1.4 allows local container administrators to escape AppArmor confinement via a symlink attack on a (1) mount target or (2) bind mount source.",
        "git_url": "https://github.com/lxc/lxc/commit/592fd47a6245508b79fe6ac819fe6d3b2c1289be",
        "commit_title": "CVE-2015-1335: Protect container mounts against symlinks",
        "commit_text": " When a container starts up, lxc sets up the container's inital fstree by doing a bunch of mounting, guided by the container configuration file.  The container config is owned by the admin or user on the host, so we do not try to guard against bad entries.  However, since the mount target is in the container, it's possible that the container admin could divert the mount with symbolic links.  This could bypass proper container startup (i.e. confinement of a root-owned container by the restrictive apparmor policy, by diverting the required write to /proc/self/attr/current), or bypass the (path-based) apparmor policy by diverting, say, /proc to /mnt in the container.  To prevent this,  1. do not allow mounts to paths containing symbolic links  2. do not allow bind mounts from relative paths containing symbolic links.  Details:  Define safe_mount which ensures that the container has not inserted any symbolic links into any mount targets for mounts to be done during container setup.  The host's mount path may contain symbolic links.  As it is under the control of the administrator, that's ok.  So safe_mount begins the check for symbolic links after the rootfs->mount, by opening that directory.  It opens each directory along the path using openat() relative to the parent directory using O_NOFOLLOW.  When the target is reached, it mounts onto /proc/self/fd/<targetfd>.  Use safe_mount() in mount_entry(), when mounting container proc, and when needed.  In particular, safe_mount() need not be used in any case where:  1. the mount is done in the container's namespace 2. the mount is for the container's rootfs 3. the mount is relative to a tmpfs or proc/sysfs which we have    just safe_mount()ed ourselves  Since we were using proc/net as a temporary placeholder for /proc/sys/net during container startup, and proc/net is a symbolic link, use proc/tty instead.  Update the lxc.container.conf manpage with details about the new restrictions.  Finally, add a testcase to test some symbolic link possibilities. ",
        "func_before": "static inline int mount_entry_on_systemfs(struct mntent *mntent)\n{\n  return mount_entry_on_generic(mntent, mntent->mnt_dir);\n}",
        "func": "static inline int mount_entry_on_systemfs(struct mntent *mntent)\n{\n  return mount_entry_on_generic(mntent, mntent->mnt_dir, NULL);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,4 @@\n static inline int mount_entry_on_systemfs(struct mntent *mntent)\n {\n-  return mount_entry_on_generic(mntent, mntent->mnt_dir);\n+  return mount_entry_on_generic(mntent, mntent->mnt_dir, NULL);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "  return mount_entry_on_generic(mntent, mntent->mnt_dir);"
            ],
            "added_lines": [
                "  return mount_entry_on_generic(mntent, mntent->mnt_dir, NULL);"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-1335",
        "func_name": "lxc/mount_entry_on_relative_rootfs",
        "description": "lxc-start in lxc before 1.0.8 and 1.1.x before 1.1.4 allows local container administrators to escape AppArmor confinement via a symlink attack on a (1) mount target or (2) bind mount source.",
        "git_url": "https://github.com/lxc/lxc/commit/592fd47a6245508b79fe6ac819fe6d3b2c1289be",
        "commit_title": "CVE-2015-1335: Protect container mounts against symlinks",
        "commit_text": " When a container starts up, lxc sets up the container's inital fstree by doing a bunch of mounting, guided by the container configuration file.  The container config is owned by the admin or user on the host, so we do not try to guard against bad entries.  However, since the mount target is in the container, it's possible that the container admin could divert the mount with symbolic links.  This could bypass proper container startup (i.e. confinement of a root-owned container by the restrictive apparmor policy, by diverting the required write to /proc/self/attr/current), or bypass the (path-based) apparmor policy by diverting, say, /proc to /mnt in the container.  To prevent this,  1. do not allow mounts to paths containing symbolic links  2. do not allow bind mounts from relative paths containing symbolic links.  Details:  Define safe_mount which ensures that the container has not inserted any symbolic links into any mount targets for mounts to be done during container setup.  The host's mount path may contain symbolic links.  As it is under the control of the administrator, that's ok.  So safe_mount begins the check for symbolic links after the rootfs->mount, by opening that directory.  It opens each directory along the path using openat() relative to the parent directory using O_NOFOLLOW.  When the target is reached, it mounts onto /proc/self/fd/<targetfd>.  Use safe_mount() in mount_entry(), when mounting container proc, and when needed.  In particular, safe_mount() need not be used in any case where:  1. the mount is done in the container's namespace 2. the mount is for the container's rootfs 3. the mount is relative to a tmpfs or proc/sysfs which we have    just safe_mount()ed ourselves  Since we were using proc/net as a temporary placeholder for /proc/sys/net during container startup, and proc/net is a symbolic link, use proc/tty instead.  Update the lxc.container.conf manpage with details about the new restrictions.  Finally, add a testcase to test some symbolic link possibilities. ",
        "func_before": "static int mount_entry_on_relative_rootfs(struct mntent *mntent,\n\t\t\t\t\t  const char *rootfs)\n{\n\tchar path[MAXPATHLEN];\n\tint ret;\n\n\t/* relative to root mount point */\n\tret = snprintf(path, sizeof(path), \"%s/%s\", rootfs, mntent->mnt_dir);\n\tif (ret >= sizeof(path)) {\n\t\tERROR(\"path name too long\");\n\t\treturn -1;\n\t}\n\n\treturn mount_entry_on_generic(mntent, path);\n}",
        "func": "static int mount_entry_on_relative_rootfs(struct mntent *mntent,\n\t\t\t\t\t  const char *rootfs)\n{\n\tchar path[MAXPATHLEN];\n\tint ret;\n\n\t/* relative to root mount point */\n\tret = snprintf(path, sizeof(path), \"%s/%s\", rootfs, mntent->mnt_dir);\n\tif (ret >= sizeof(path)) {\n\t\tERROR(\"path name too long\");\n\t\treturn -1;\n\t}\n\n\treturn mount_entry_on_generic(mntent, path, rootfs);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -11,5 +11,5 @@\n \t\treturn -1;\n \t}\n \n-\treturn mount_entry_on_generic(mntent, path);\n+\treturn mount_entry_on_generic(mntent, path, rootfs);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\treturn mount_entry_on_generic(mntent, path);"
            ],
            "added_lines": [
                "\treturn mount_entry_on_generic(mntent, path, rootfs);"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-1335",
        "func_name": "lxc/lxc_execute_bind_init",
        "description": "lxc-start in lxc before 1.0.8 and 1.1.x before 1.1.4 allows local container administrators to escape AppArmor confinement via a symlink attack on a (1) mount target or (2) bind mount source.",
        "git_url": "https://github.com/lxc/lxc/commit/592fd47a6245508b79fe6ac819fe6d3b2c1289be",
        "commit_title": "CVE-2015-1335: Protect container mounts against symlinks",
        "commit_text": " When a container starts up, lxc sets up the container's inital fstree by doing a bunch of mounting, guided by the container configuration file.  The container config is owned by the admin or user on the host, so we do not try to guard against bad entries.  However, since the mount target is in the container, it's possible that the container admin could divert the mount with symbolic links.  This could bypass proper container startup (i.e. confinement of a root-owned container by the restrictive apparmor policy, by diverting the required write to /proc/self/attr/current), or bypass the (path-based) apparmor policy by diverting, say, /proc to /mnt in the container.  To prevent this,  1. do not allow mounts to paths containing symbolic links  2. do not allow bind mounts from relative paths containing symbolic links.  Details:  Define safe_mount which ensures that the container has not inserted any symbolic links into any mount targets for mounts to be done during container setup.  The host's mount path may contain symbolic links.  As it is under the control of the administrator, that's ok.  So safe_mount begins the check for symbolic links after the rootfs->mount, by opening that directory.  It opens each directory along the path using openat() relative to the parent directory using O_NOFOLLOW.  When the target is reached, it mounts onto /proc/self/fd/<targetfd>.  Use safe_mount() in mount_entry(), when mounting container proc, and when needed.  In particular, safe_mount() need not be used in any case where:  1. the mount is done in the container's namespace 2. the mount is for the container's rootfs 3. the mount is relative to a tmpfs or proc/sysfs which we have    just safe_mount()ed ourselves  Since we were using proc/net as a temporary placeholder for /proc/sys/net during container startup, and proc/net is a symbolic link, use proc/tty instead.  Update the lxc.container.conf manpage with details about the new restrictions.  Finally, add a testcase to test some symbolic link possibilities. ",
        "func_before": "void lxc_execute_bind_init(struct lxc_conf *conf)\n{\n\tint ret;\n\tchar path[PATH_MAX], destpath[PATH_MAX], *p;\n\n\t/* If init exists in the container, don't bind mount a static one */\n\tp = choose_init(conf->rootfs.mount);\n\tif (p) {\n\t\tfree(p);\n\t\treturn;\n\t}\n\n\tret = snprintf(path, PATH_MAX, SBINDIR \"/init.lxc.static\");\n\tif (ret < 0 || ret >= PATH_MAX) {\n\t\tWARN(\"Path name too long searching for lxc.init.static\");\n\t\treturn;\n\t}\n\n\tif (!file_exists(path)) {\n\t\tINFO(\"%s does not exist on host\", path);\n\t\treturn;\n\t}\n\n\tret = snprintf(destpath, PATH_MAX, \"%s%s\", conf->rootfs.mount, \"/init.lxc.static\");\n\tif (ret < 0 || ret >= PATH_MAX) {\n\t\tWARN(\"Path name too long for container's lxc.init.static\");\n\t\treturn;\n\t}\n\n\tif (!file_exists(destpath)) {\n\t\tFILE * pathfile = fopen(destpath, \"wb\");\n\t\tif (!pathfile) {\n\t\t\tSYSERROR(\"Failed to create mount target '%s'\", destpath);\n\t\t\treturn;\n\t\t}\n\t\tfclose(pathfile);\n\t}\n\n\tret = mount(path, destpath, \"none\", MS_BIND, NULL);\n\tif (ret < 0)\n\t\tSYSERROR(\"Failed to bind lxc.init.static into container\");\n\tINFO(\"lxc.init.static bound into container at %s\", path);\n}",
        "func": "void lxc_execute_bind_init(struct lxc_conf *conf)\n{\n\tint ret;\n\tchar path[PATH_MAX], destpath[PATH_MAX], *p;\n\n\t/* If init exists in the container, don't bind mount a static one */\n\tp = choose_init(conf->rootfs.mount);\n\tif (p) {\n\t\tfree(p);\n\t\treturn;\n\t}\n\n\tret = snprintf(path, PATH_MAX, SBINDIR \"/init.lxc.static\");\n\tif (ret < 0 || ret >= PATH_MAX) {\n\t\tWARN(\"Path name too long searching for lxc.init.static\");\n\t\treturn;\n\t}\n\n\tif (!file_exists(path)) {\n\t\tINFO(\"%s does not exist on host\", path);\n\t\treturn;\n\t}\n\n\tret = snprintf(destpath, PATH_MAX, \"%s%s\", conf->rootfs.mount, \"/init.lxc.static\");\n\tif (ret < 0 || ret >= PATH_MAX) {\n\t\tWARN(\"Path name too long for container's lxc.init.static\");\n\t\treturn;\n\t}\n\n\tif (!file_exists(destpath)) {\n\t\tFILE * pathfile = fopen(destpath, \"wb\");\n\t\tif (!pathfile) {\n\t\t\tSYSERROR(\"Failed to create mount target '%s'\", destpath);\n\t\t\treturn;\n\t\t}\n\t\tfclose(pathfile);\n\t}\n\n\tret = safe_mount(path, destpath, \"none\", MS_BIND, NULL, conf->rootfs.mount);\n\tif (ret < 0)\n\t\tSYSERROR(\"Failed to bind lxc.init.static into container\");\n\tINFO(\"lxc.init.static bound into container at %s\", path);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -36,7 +36,7 @@\n \t\tfclose(pathfile);\n \t}\n \n-\tret = mount(path, destpath, \"none\", MS_BIND, NULL);\n+\tret = safe_mount(path, destpath, \"none\", MS_BIND, NULL, conf->rootfs.mount);\n \tif (ret < 0)\n \t\tSYSERROR(\"Failed to bind lxc.init.static into container\");\n \tINFO(\"lxc.init.static bound into container at %s\", path);",
        "diff_line_info": {
            "deleted_lines": [
                "\tret = mount(path, destpath, \"none\", MS_BIND, NULL);"
            ],
            "added_lines": [
                "\tret = safe_mount(path, destpath, \"none\", MS_BIND, NULL, conf->rootfs.mount);"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-1335",
        "func_name": "lxc/setup_dev_console",
        "description": "lxc-start in lxc before 1.0.8 and 1.1.x before 1.1.4 allows local container administrators to escape AppArmor confinement via a symlink attack on a (1) mount target or (2) bind mount source.",
        "git_url": "https://github.com/lxc/lxc/commit/592fd47a6245508b79fe6ac819fe6d3b2c1289be",
        "commit_title": "CVE-2015-1335: Protect container mounts against symlinks",
        "commit_text": " When a container starts up, lxc sets up the container's inital fstree by doing a bunch of mounting, guided by the container configuration file.  The container config is owned by the admin or user on the host, so we do not try to guard against bad entries.  However, since the mount target is in the container, it's possible that the container admin could divert the mount with symbolic links.  This could bypass proper container startup (i.e. confinement of a root-owned container by the restrictive apparmor policy, by diverting the required write to /proc/self/attr/current), or bypass the (path-based) apparmor policy by diverting, say, /proc to /mnt in the container.  To prevent this,  1. do not allow mounts to paths containing symbolic links  2. do not allow bind mounts from relative paths containing symbolic links.  Details:  Define safe_mount which ensures that the container has not inserted any symbolic links into any mount targets for mounts to be done during container setup.  The host's mount path may contain symbolic links.  As it is under the control of the administrator, that's ok.  So safe_mount begins the check for symbolic links after the rootfs->mount, by opening that directory.  It opens each directory along the path using openat() relative to the parent directory using O_NOFOLLOW.  When the target is reached, it mounts onto /proc/self/fd/<targetfd>.  Use safe_mount() in mount_entry(), when mounting container proc, and when needed.  In particular, safe_mount() need not be used in any case where:  1. the mount is done in the container's namespace 2. the mount is for the container's rootfs 3. the mount is relative to a tmpfs or proc/sysfs which we have    just safe_mount()ed ourselves  Since we were using proc/net as a temporary placeholder for /proc/sys/net during container startup, and proc/net is a symbolic link, use proc/tty instead.  Update the lxc.container.conf manpage with details about the new restrictions.  Finally, add a testcase to test some symbolic link possibilities. ",
        "func_before": "static int setup_dev_console(const struct lxc_rootfs *rootfs,\n\t\t\t const struct lxc_console *console)\n{\n\tchar path[MAXPATHLEN];\n\tstruct stat s;\n\tint ret;\n\n\tret = snprintf(path, sizeof(path), \"%s/dev/console\", rootfs->mount);\n\tif (ret >= sizeof(path)) {\n\t\tERROR(\"console path too long\");\n\t\treturn -1;\n\t}\n\n\tif (access(path, F_OK)) {\n\t\tWARN(\"rootfs specified but no console found at '%s'\", path);\n\t\treturn 0;\n\t}\n\n\tif (console->master < 0) {\n\t\tINFO(\"no console\");\n\t\treturn 0;\n\t}\n\n\tif (stat(path, &s)) {\n\t\tSYSERROR(\"failed to stat '%s'\", path);\n\t\treturn -1;\n\t}\n\n\tif (chmod(console->name, s.st_mode)) {\n\t\tSYSERROR(\"failed to set mode '0%o' to '%s'\",\n\t\t\t s.st_mode, console->name);\n\t\treturn -1;\n\t}\n\n\tif (mount(console->name, path, \"none\", MS_BIND, 0)) {\n\t\tERROR(\"failed to mount '%s' on '%s'\", console->name, path);\n\t\treturn -1;\n\t}\n\n\tINFO(\"console has been setup\");\n\treturn 0;\n}",
        "func": "static int setup_dev_console(const struct lxc_rootfs *rootfs,\n\t\t\t const struct lxc_console *console)\n{\n\tchar path[MAXPATHLEN];\n\tstruct stat s;\n\tint ret;\n\n\tret = snprintf(path, sizeof(path), \"%s/dev/console\", rootfs->mount);\n\tif (ret >= sizeof(path)) {\n\t\tERROR(\"console path too long\");\n\t\treturn -1;\n\t}\n\n\tif (access(path, F_OK)) {\n\t\tWARN(\"rootfs specified but no console found at '%s'\", path);\n\t\treturn 0;\n\t}\n\n\tif (console->master < 0) {\n\t\tINFO(\"no console\");\n\t\treturn 0;\n\t}\n\n\tif (stat(path, &s)) {\n\t\tSYSERROR(\"failed to stat '%s'\", path);\n\t\treturn -1;\n\t}\n\n\tif (chmod(console->name, s.st_mode)) {\n\t\tSYSERROR(\"failed to set mode '0%o' to '%s'\",\n\t\t\t s.st_mode, console->name);\n\t\treturn -1;\n\t}\n\n\tif (safe_mount(console->name, path, \"none\", MS_BIND, 0, rootfs->mount)) {\n\t\tERROR(\"failed to mount '%s' on '%s'\", console->name, path);\n\t\treturn -1;\n\t}\n\n\tINFO(\"console has been setup\");\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -32,7 +32,7 @@\n \t\treturn -1;\n \t}\n \n-\tif (mount(console->name, path, \"none\", MS_BIND, 0)) {\n+\tif (safe_mount(console->name, path, \"none\", MS_BIND, 0, rootfs->mount)) {\n \t\tERROR(\"failed to mount '%s' on '%s'\", console->name, path);\n \t\treturn -1;\n \t}",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (mount(console->name, path, \"none\", MS_BIND, 0)) {"
            ],
            "added_lines": [
                "\tif (safe_mount(console->name, path, \"none\", MS_BIND, 0, rootfs->mount)) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-1335",
        "func_name": "lxc/mount_entry_on_absolute_rootfs",
        "description": "lxc-start in lxc before 1.0.8 and 1.1.x before 1.1.4 allows local container administrators to escape AppArmor confinement via a symlink attack on a (1) mount target or (2) bind mount source.",
        "git_url": "https://github.com/lxc/lxc/commit/592fd47a6245508b79fe6ac819fe6d3b2c1289be",
        "commit_title": "CVE-2015-1335: Protect container mounts against symlinks",
        "commit_text": " When a container starts up, lxc sets up the container's inital fstree by doing a bunch of mounting, guided by the container configuration file.  The container config is owned by the admin or user on the host, so we do not try to guard against bad entries.  However, since the mount target is in the container, it's possible that the container admin could divert the mount with symbolic links.  This could bypass proper container startup (i.e. confinement of a root-owned container by the restrictive apparmor policy, by diverting the required write to /proc/self/attr/current), or bypass the (path-based) apparmor policy by diverting, say, /proc to /mnt in the container.  To prevent this,  1. do not allow mounts to paths containing symbolic links  2. do not allow bind mounts from relative paths containing symbolic links.  Details:  Define safe_mount which ensures that the container has not inserted any symbolic links into any mount targets for mounts to be done during container setup.  The host's mount path may contain symbolic links.  As it is under the control of the administrator, that's ok.  So safe_mount begins the check for symbolic links after the rootfs->mount, by opening that directory.  It opens each directory along the path using openat() relative to the parent directory using O_NOFOLLOW.  When the target is reached, it mounts onto /proc/self/fd/<targetfd>.  Use safe_mount() in mount_entry(), when mounting container proc, and when needed.  In particular, safe_mount() need not be used in any case where:  1. the mount is done in the container's namespace 2. the mount is for the container's rootfs 3. the mount is relative to a tmpfs or proc/sysfs which we have    just safe_mount()ed ourselves  Since we were using proc/net as a temporary placeholder for /proc/sys/net during container startup, and proc/net is a symbolic link, use proc/tty instead.  Update the lxc.container.conf manpage with details about the new restrictions.  Finally, add a testcase to test some symbolic link possibilities. ",
        "func_before": "static int mount_entry_on_absolute_rootfs(struct mntent *mntent,\n\t\t\t\t\t  const struct lxc_rootfs *rootfs,\n\t\t\t\t\t  const char *lxc_name)\n{\n\tchar *aux;\n\tchar path[MAXPATHLEN];\n\tint r, ret = 0, offset;\n\tconst char *lxcpath;\n\n\tlxcpath = lxc_global_config_value(\"lxc.lxcpath\");\n\tif (!lxcpath) {\n\t\tERROR(\"Out of memory\");\n\t\treturn -1;\n\t}\n\n\t/* if rootfs->path is a blockdev path, allow container fstab to\n\t * use $lxcpath/CN/rootfs as the target prefix */\n\tr = snprintf(path, MAXPATHLEN, \"%s/%s/rootfs\", lxcpath, lxc_name);\n\tif (r < 0 || r >= MAXPATHLEN)\n\t\tgoto skipvarlib;\n\n\taux = strstr(mntent->mnt_dir, path);\n\tif (aux) {\n\t\toffset = strlen(path);\n\t\tgoto skipabs;\n\t}\n\nskipvarlib:\n\taux = strstr(mntent->mnt_dir, rootfs->path);\n\tif (!aux) {\n\t\tWARN(\"ignoring mount point '%s'\", mntent->mnt_dir);\n\t\treturn ret;\n\t}\n\toffset = strlen(rootfs->path);\n\nskipabs:\n\n\tr = snprintf(path, MAXPATHLEN, \"%s/%s\", rootfs->mount,\n\t\t aux + offset);\n\tif (r < 0 || r >= MAXPATHLEN) {\n\t\tWARN(\"pathnme too long for '%s'\", mntent->mnt_dir);\n\t\treturn -1;\n\t}\n\n\treturn mount_entry_on_generic(mntent, path);\n}",
        "func": "static int mount_entry_on_absolute_rootfs(struct mntent *mntent,\n\t\t\t\t\t  const struct lxc_rootfs *rootfs,\n\t\t\t\t\t  const char *lxc_name)\n{\n\tchar *aux;\n\tchar path[MAXPATHLEN];\n\tint r, ret = 0, offset;\n\tconst char *lxcpath;\n\n\tlxcpath = lxc_global_config_value(\"lxc.lxcpath\");\n\tif (!lxcpath) {\n\t\tERROR(\"Out of memory\");\n\t\treturn -1;\n\t}\n\n\t/* if rootfs->path is a blockdev path, allow container fstab to\n\t * use $lxcpath/CN/rootfs as the target prefix */\n\tr = snprintf(path, MAXPATHLEN, \"%s/%s/rootfs\", lxcpath, lxc_name);\n\tif (r < 0 || r >= MAXPATHLEN)\n\t\tgoto skipvarlib;\n\n\taux = strstr(mntent->mnt_dir, path);\n\tif (aux) {\n\t\toffset = strlen(path);\n\t\tgoto skipabs;\n\t}\n\nskipvarlib:\n\taux = strstr(mntent->mnt_dir, rootfs->path);\n\tif (!aux) {\n\t\tWARN(\"ignoring mount point '%s'\", mntent->mnt_dir);\n\t\treturn ret;\n\t}\n\toffset = strlen(rootfs->path);\n\nskipabs:\n\n\tr = snprintf(path, MAXPATHLEN, \"%s/%s\", rootfs->mount,\n\t\t aux + offset);\n\tif (r < 0 || r >= MAXPATHLEN) {\n\t\tWARN(\"pathnme too long for '%s'\", mntent->mnt_dir);\n\t\treturn -1;\n\t}\n\n\treturn mount_entry_on_generic(mntent, path, rootfs->mount);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -42,5 +42,5 @@\n \t\treturn -1;\n \t}\n \n-\treturn mount_entry_on_generic(mntent, path);\n+\treturn mount_entry_on_generic(mntent, path, rootfs->mount);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\treturn mount_entry_on_generic(mntent, path);"
            ],
            "added_lines": [
                "\treturn mount_entry_on_generic(mntent, path, rootfs->mount);"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-1335",
        "func_name": "lxc/mount_entry_on_generic",
        "description": "lxc-start in lxc before 1.0.8 and 1.1.x before 1.1.4 allows local container administrators to escape AppArmor confinement via a symlink attack on a (1) mount target or (2) bind mount source.",
        "git_url": "https://github.com/lxc/lxc/commit/592fd47a6245508b79fe6ac819fe6d3b2c1289be",
        "commit_title": "CVE-2015-1335: Protect container mounts against symlinks",
        "commit_text": " When a container starts up, lxc sets up the container's inital fstree by doing a bunch of mounting, guided by the container configuration file.  The container config is owned by the admin or user on the host, so we do not try to guard against bad entries.  However, since the mount target is in the container, it's possible that the container admin could divert the mount with symbolic links.  This could bypass proper container startup (i.e. confinement of a root-owned container by the restrictive apparmor policy, by diverting the required write to /proc/self/attr/current), or bypass the (path-based) apparmor policy by diverting, say, /proc to /mnt in the container.  To prevent this,  1. do not allow mounts to paths containing symbolic links  2. do not allow bind mounts from relative paths containing symbolic links.  Details:  Define safe_mount which ensures that the container has not inserted any symbolic links into any mount targets for mounts to be done during container setup.  The host's mount path may contain symbolic links.  As it is under the control of the administrator, that's ok.  So safe_mount begins the check for symbolic links after the rootfs->mount, by opening that directory.  It opens each directory along the path using openat() relative to the parent directory using O_NOFOLLOW.  When the target is reached, it mounts onto /proc/self/fd/<targetfd>.  Use safe_mount() in mount_entry(), when mounting container proc, and when needed.  In particular, safe_mount() need not be used in any case where:  1. the mount is done in the container's namespace 2. the mount is for the container's rootfs 3. the mount is relative to a tmpfs or proc/sysfs which we have    just safe_mount()ed ourselves  Since we were using proc/net as a temporary placeholder for /proc/sys/net during container startup, and proc/net is a symbolic link, use proc/tty instead.  Update the lxc.container.conf manpage with details about the new restrictions.  Finally, add a testcase to test some symbolic link possibilities. ",
        "func_before": "static inline int mount_entry_on_generic(struct mntent *mntent,\n                 const char* path)\n{\n\tunsigned long mntflags;\n\tchar *mntdata;\n\tint ret;\n\tbool optional = hasmntopt(mntent, \"optional\") != NULL;\n\n\tret = mount_entry_create_dir_file(mntent, path);\n\n\tif (ret < 0)\n\t\treturn optional ? 0 : -1;\n\n\tcull_mntent_opt(mntent);\n\n\tif (parse_mntopts(mntent->mnt_opts, &mntflags, &mntdata) < 0) {\n\t\tfree(mntdata);\n\t\treturn -1;\n\t}\n\n\tret = mount_entry(mntent->mnt_fsname, path, mntent->mnt_type,\n\t\t\t  mntflags, mntdata, optional);\n\n\tfree(mntdata);\n\n\treturn ret;\n}",
        "func": "static inline int mount_entry_on_generic(struct mntent *mntent,\n                 const char* path, const char *rootfs)\n{\n\tunsigned long mntflags;\n\tchar *mntdata;\n\tint ret;\n\tbool optional = hasmntopt(mntent, \"optional\") != NULL;\n\n\tret = mount_entry_create_dir_file(mntent, path);\n\n\tif (ret < 0)\n\t\treturn optional ? 0 : -1;\n\n\tcull_mntent_opt(mntent);\n\n\tif (parse_mntopts(mntent->mnt_opts, &mntflags, &mntdata) < 0) {\n\t\tfree(mntdata);\n\t\treturn -1;\n\t}\n\n\tret = mount_entry(mntent->mnt_fsname, path, mntent->mnt_type,\n\t\t\t  mntflags, mntdata, optional, rootfs);\n\n\tfree(mntdata);\n\n\treturn ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,5 @@\n static inline int mount_entry_on_generic(struct mntent *mntent,\n-                 const char* path)\n+                 const char* path, const char *rootfs)\n {\n \tunsigned long mntflags;\n \tchar *mntdata;\n@@ -19,7 +19,7 @@\n \t}\n \n \tret = mount_entry(mntent->mnt_fsname, path, mntent->mnt_type,\n-\t\t\t  mntflags, mntdata, optional);\n+\t\t\t  mntflags, mntdata, optional, rootfs);\n \n \tfree(mntdata);\n ",
        "diff_line_info": {
            "deleted_lines": [
                "                 const char* path)",
                "\t\t\t  mntflags, mntdata, optional);"
            ],
            "added_lines": [
                "                 const char* path, const char *rootfs)",
                "\t\t\t  mntflags, mntdata, optional, rootfs);"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-52138",
        "func_name": "mate-desktop/engrampa/fr_command_cpio_get_capabilities",
        "description": "Engrampa is an archive manager for the MATE environment. Engrampa is found to be vulnerable to a Path Traversal vulnerability that can be leveraged to achieve full Remote Command Execution (RCE) on the target. While handling CPIO archives, the Engrampa Archive manager follows symlink, cpio by default will follow stored symlinks while extracting and the Archiver will not check the symlink location, which leads to arbitrary file writes to unintended locations. When the victim extracts the archive, the attacker can craft a malicious cpio or ISO archive to achieve RCE on the target system. This vulnerability was fixed in commit 63d5dfa.\n",
        "git_url": "https://github.com/mate-desktop/engrampa/commit/63d5dfa9005c6b16d0f0ccd888cc859fca78f970",
        "commit_title": "Use unar instead of cpio for CPIO archives",
        "commit_text": "",
        "func_before": "static FrCommandCaps\nfr_command_cpio_get_capabilities (FrCommand  *comm,\n\t\t\t          const char *mime_type,\n\t\t\t\t  gboolean    check_command)\n{\n\tFrCommandCaps capabilities;\n\n\tcapabilities = FR_COMMAND_CAN_ARCHIVE_MANY_FILES;\n\tif (is_program_available (CPIO_PATH, check_command))\n\t\tcapabilities |= FR_COMMAND_CAN_READ;\n\n\treturn capabilities;\n}",
        "func": "static FrCommandCaps\nfr_command_cpio_get_capabilities (FrCommand  *comm,\n\t\t\t          const char *mime_type,\n\t\t\t\t  gboolean    check_command)\n{\n\tFrCommandCaps capabilities;\n\n\tcapabilities = FR_COMMAND_CAN_ARCHIVE_MANY_FILES;\n/*\tif (is_program_available (CPIO_PATH, check_command))\n\t\tcapabilities |= FR_COMMAND_CAN_READ;*/\n\n\treturn capabilities;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,8 +6,8 @@\n \tFrCommandCaps capabilities;\n \n \tcapabilities = FR_COMMAND_CAN_ARCHIVE_MANY_FILES;\n-\tif (is_program_available (CPIO_PATH, check_command))\n-\t\tcapabilities |= FR_COMMAND_CAN_READ;\n+/*\tif (is_program_available (CPIO_PATH, check_command))\n+\t\tcapabilities |= FR_COMMAND_CAN_READ;*/\n \n \treturn capabilities;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (is_program_available (CPIO_PATH, check_command))",
                "\t\tcapabilities |= FR_COMMAND_CAN_READ;"
            ],
            "added_lines": [
                "/*\tif (is_program_available (CPIO_PATH, check_command))",
                "\t\tcapabilities |= FR_COMMAND_CAN_READ;*/"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-1869",
        "func_name": "abrt/run_post_create",
        "description": "The default event handling scripts in Automatic Bug Reporting Tool (ABRT) allow local users to gain privileges as demonstrated by a symlink attack on a var_log_messages file.",
        "git_url": "https://github.com/abrt/abrt/commit/3287aa12eb205cff95cdd00d6d6c5c9a4f8f0eca",
        "commit_title": "daemon: allow only root user to trigger the post-create",
        "commit_text": " There is no reason to allow non-root users to trigger this functionality. Regular users can create abrt problems only through abrtd or abrt-dbus and both triggers the post-create.  Other hooks run under root user (CCpp, Koops, VMCore, Xorg).  Related: #1212861 ",
        "func_before": "static int run_post_create(const char *dirname)\n{\n    /* If doesn't start with \"g_settings_dump_location/\"... */\n    if (!dir_is_in_dump_location(dirname))\n    {\n        /* Then refuse to operate on it (someone is attacking us??) */\n        error_msg(\"Bad problem directory name '%s', should start with: '%s'\", dirname, g_settings_dump_location);\n        return 400; /* Bad Request */\n    }\n    if (!dir_has_correct_permissions(dirname))\n    {\n        error_msg(\"Problem directory '%s' isn't owned by root:abrt or others are not restricted from access\", dirname);\n        return 400; /*  */\n    }\n    if (g_settings_privatereports)\n    {\n        struct dump_dir *dd = dd_opendir(dirname, DD_OPEN_READONLY);\n        const bool complete = dd && problem_dump_dir_is_complete(dd);\n        dd_close(dd);\n        if (complete)\n        {\n            error_msg(\"Problem directory '%s' has already been processed\", dirname);\n            return 403;\n        }\n    }\n    else if (!dump_dir_accessible_by_uid(dirname, client_uid))\n    {\n        if (errno == ENOTDIR)\n        {\n            error_msg(\"Path '%s' isn't problem directory\", dirname);\n            return 404; /* Not Found */\n        }\n        error_msg(\"Problem directory '%s' can't be accessed by user with uid %ld\", dirname, (long)client_uid);\n        return 403; /* Forbidden */\n    }\n\n    int child_stdout_fd;\n    int child_pid = spawn_event_handler_child(dirname, \"post-create\", &child_stdout_fd);\n\n    char *dup_of_dir = NULL;\n    struct strbuf *cmd_output = strbuf_new();\n\n    bool child_is_post_create = 1; /* else it is a notify child */\n\n read_child_output:\n    //log(\"Reading from event fd %d\", child_stdout_fd);\n\n    /* Read streamed data and split lines */\n    for (;;)\n    {\n        char buf[250]; /* usually we get one line, no need to have big buf */\n        errno = 0;\n        int r = safe_read(child_stdout_fd, buf, sizeof(buf) - 1);\n        if (r <= 0)\n            break;\n        buf[r] = '\\0';\n\n        /* split lines in the current buffer */\n        char *raw = buf;\n        char *newline;\n        while ((newline = strchr(raw, '\\n')) != NULL)\n        {\n            *newline = '\\0';\n            strbuf_append_str(cmd_output, raw);\n            char *msg = cmd_output->buf;\n\n            /* Hmm, DUP_OF_DIR: ends up in syslog. move log() into 'else'? */\n            log(\"%s\", msg);\n\n            if (child_is_post_create\n             && prefixcmp(msg, \"DUP_OF_DIR: \") == 0\n            ) {\n                free(dup_of_dir);\n                dup_of_dir = xstrdup(msg + strlen(\"DUP_OF_DIR: \"));\n            }\n\n            strbuf_clear(cmd_output);\n            /* jump to next line */\n            raw = newline + 1;\n        }\n\n        /* beginning of next line. the line continues by next read */\n        strbuf_append_str(cmd_output, raw);\n    }\n\n    /* EOF/error */\n\n    /* Wait for child to actually exit, collect status */\n    int status = 0;\n    if (safe_waitpid(child_pid, &status, 0) <= 0)\n    /* should not happen */\n        perror_msg(\"waitpid(%d)\", child_pid);\n\n    /* If it was a \"notify[-dup]\" event, then we're done */\n    if (!child_is_post_create)\n        goto ret;\n\n    /* exit 0 means \"this is a good, non-dup dir\" */\n    /* exit with 1 + \"DUP_OF_DIR: dir\" string => dup */\n    if (status != 0)\n    {\n        if (WIFSIGNALED(status))\n        {\n            log(\"'post-create' on '%s' killed by signal %d\",\n                            dirname, WTERMSIG(status));\n            goto delete_bad_dir;\n        }\n        /* else: it is WIFEXITED(status) */\n        if (!dup_of_dir)\n        {\n            log(\"'post-create' on '%s' exited with %d\",\n                            dirname, WEXITSTATUS(status));\n            goto delete_bad_dir;\n        }\n    }\n\n    const char *work_dir = (dup_of_dir ? dup_of_dir : dirname);\n\n    /* Load problem_data (from the *first dir* if this one is a dup) */\n    struct dump_dir *dd = dd_opendir(work_dir, /*flags:*/ 0);\n    if (!dd)\n        /* dd_opendir already emitted error msg */\n        goto delete_bad_dir;\n\n    /* Update count */\n    char *count_str = dd_load_text_ext(dd, FILENAME_COUNT, DD_FAIL_QUIETLY_ENOENT);\n    unsigned long count = strtoul(count_str, NULL, 10);\n\n    /* Don't increase crash count if we are working with newly uploaded\n     * directory (remote crash) which already has its crash count set.\n     */\n    if ((status != 0 && dup_of_dir) || count == 0)\n    {\n        count++;\n        char new_count_str[sizeof(long)*3 + 2];\n        sprintf(new_count_str, \"%lu\", count);\n        dd_save_text(dd, FILENAME_COUNT, new_count_str);\n\n        /* This condition can be simplified to either\n         * (status * != 0 && * dup_of_dir) or (count == 1). But the\n         * chosen form is much more reliable and safe. We must not call\n         * dd_opendir() to locked dd otherwise we go into a deadlock.\n         */\n        if (strcmp(dd->dd_dirname, dirname) != 0)\n        {\n            /* Update the last occurrence file by the time file of the new problem */\n            struct dump_dir *new_dd = dd_opendir(dirname, DD_OPEN_READONLY);\n            char *last_ocr = NULL;\n            if (new_dd)\n            {\n                /* TIME must exists in a valid dump directory but we don't want to die\n                 * due to broken duplicated dump directory */\n                last_ocr = dd_load_text_ext(new_dd, FILENAME_TIME,\n                            DD_LOAD_TEXT_RETURN_NULL_ON_FAILURE | DD_FAIL_QUIETLY_ENOENT);\n                dd_close(new_dd);\n            }\n            else\n            {   /* dd_opendir() already produced a message with good information about failure */\n                error_msg(\"Can't read the last occurrence file from the new dump directory.\");\n            }\n\n            if (!last_ocr)\n            {   /* the new dump directory may lie in the dump location for some time */\n                log(\"Using current time for the last occurrence file which may be incorrect.\");\n                time_t t = time(NULL);\n                last_ocr = xasprintf(\"%lu\", (long)t);\n            }\n\n            dd_save_text(dd, FILENAME_LAST_OCCURRENCE, last_ocr);\n\n            free(last_ocr);\n        }\n    }\n\n    /* Reset mode/uig/gid to correct values for all files created by event run */\n    dd_sanitize_mode_and_owner(dd);\n\n    dd_close(dd);\n\n    if (!dup_of_dir)\n        log_notice(\"New problem directory %s, processing\", work_dir);\n    else\n    {\n        log_warning(\"Deleting problem directory %s (dup of %s)\",\n                    strrchr(dirname, '/') + 1,\n                    strrchr(dup_of_dir, '/') + 1);\n        delete_dump_dir(dirname);\n    }\n\n    /* Run \"notify[-dup]\" event */\n    int fd;\n    child_pid = spawn_event_handler_child(\n                work_dir,\n                (dup_of_dir ? \"notify-dup\" : \"notify\"),\n                &fd\n    );\n    //log(\"Started notify, fd %d -> %d\", fd, child_stdout_fd);\n    xmove_fd(fd, child_stdout_fd);\n    child_is_post_create = 0;\n    strbuf_clear(cmd_output);\n    free(dup_of_dir);\n    dup_of_dir = NULL;\n    goto read_child_output;\n\n delete_bad_dir:\n    log_warning(\"Deleting problem directory '%s'\", dirname);\n    delete_dump_dir(dirname);\n\n ret:\n    strbuf_free(cmd_output);\n    free(dup_of_dir);\n    close(child_stdout_fd);\n    return 0;\n}",
        "func": "static int run_post_create(const char *dirname)\n{\n    /* If doesn't start with \"g_settings_dump_location/\"... */\n    if (!dir_is_in_dump_location(dirname))\n    {\n        /* Then refuse to operate on it (someone is attacking us??) */\n        error_msg(\"Bad problem directory name '%s', should start with: '%s'\", dirname, g_settings_dump_location);\n        return 400; /* Bad Request */\n    }\n    if (!dir_has_correct_permissions(dirname))\n    {\n        error_msg(\"Problem directory '%s' isn't owned by root:abrt or others are not restricted from access\", dirname);\n        return 400; /*  */\n    }\n    if (g_settings_privatereports)\n    {\n        struct dump_dir *dd = dd_opendir(dirname, DD_OPEN_READONLY);\n        const bool complete = dd && problem_dump_dir_is_complete(dd);\n        dd_close(dd);\n        if (complete)\n        {\n            error_msg(\"Problem directory '%s' has already been processed\", dirname);\n            return 403;\n        }\n    }\n\n    int child_stdout_fd;\n    int child_pid = spawn_event_handler_child(dirname, \"post-create\", &child_stdout_fd);\n\n    char *dup_of_dir = NULL;\n    struct strbuf *cmd_output = strbuf_new();\n\n    bool child_is_post_create = 1; /* else it is a notify child */\n\n read_child_output:\n    //log(\"Reading from event fd %d\", child_stdout_fd);\n\n    /* Read streamed data and split lines */\n    for (;;)\n    {\n        char buf[250]; /* usually we get one line, no need to have big buf */\n        errno = 0;\n        int r = safe_read(child_stdout_fd, buf, sizeof(buf) - 1);\n        if (r <= 0)\n            break;\n        buf[r] = '\\0';\n\n        /* split lines in the current buffer */\n        char *raw = buf;\n        char *newline;\n        while ((newline = strchr(raw, '\\n')) != NULL)\n        {\n            *newline = '\\0';\n            strbuf_append_str(cmd_output, raw);\n            char *msg = cmd_output->buf;\n\n            /* Hmm, DUP_OF_DIR: ends up in syslog. move log() into 'else'? */\n            log(\"%s\", msg);\n\n            if (child_is_post_create\n             && prefixcmp(msg, \"DUP_OF_DIR: \") == 0\n            ) {\n                free(dup_of_dir);\n                dup_of_dir = xstrdup(msg + strlen(\"DUP_OF_DIR: \"));\n            }\n\n            strbuf_clear(cmd_output);\n            /* jump to next line */\n            raw = newline + 1;\n        }\n\n        /* beginning of next line. the line continues by next read */\n        strbuf_append_str(cmd_output, raw);\n    }\n\n    /* EOF/error */\n\n    /* Wait for child to actually exit, collect status */\n    int status = 0;\n    if (safe_waitpid(child_pid, &status, 0) <= 0)\n    /* should not happen */\n        perror_msg(\"waitpid(%d)\", child_pid);\n\n    /* If it was a \"notify[-dup]\" event, then we're done */\n    if (!child_is_post_create)\n        goto ret;\n\n    /* exit 0 means \"this is a good, non-dup dir\" */\n    /* exit with 1 + \"DUP_OF_DIR: dir\" string => dup */\n    if (status != 0)\n    {\n        if (WIFSIGNALED(status))\n        {\n            log(\"'post-create' on '%s' killed by signal %d\",\n                            dirname, WTERMSIG(status));\n            goto delete_bad_dir;\n        }\n        /* else: it is WIFEXITED(status) */\n        if (!dup_of_dir)\n        {\n            log(\"'post-create' on '%s' exited with %d\",\n                            dirname, WEXITSTATUS(status));\n            goto delete_bad_dir;\n        }\n    }\n\n    const char *work_dir = (dup_of_dir ? dup_of_dir : dirname);\n\n    /* Load problem_data (from the *first dir* if this one is a dup) */\n    struct dump_dir *dd = dd_opendir(work_dir, /*flags:*/ 0);\n    if (!dd)\n        /* dd_opendir already emitted error msg */\n        goto delete_bad_dir;\n\n    /* Update count */\n    char *count_str = dd_load_text_ext(dd, FILENAME_COUNT, DD_FAIL_QUIETLY_ENOENT);\n    unsigned long count = strtoul(count_str, NULL, 10);\n\n    /* Don't increase crash count if we are working with newly uploaded\n     * directory (remote crash) which already has its crash count set.\n     */\n    if ((status != 0 && dup_of_dir) || count == 0)\n    {\n        count++;\n        char new_count_str[sizeof(long)*3 + 2];\n        sprintf(new_count_str, \"%lu\", count);\n        dd_save_text(dd, FILENAME_COUNT, new_count_str);\n\n        /* This condition can be simplified to either\n         * (status * != 0 && * dup_of_dir) or (count == 1). But the\n         * chosen form is much more reliable and safe. We must not call\n         * dd_opendir() to locked dd otherwise we go into a deadlock.\n         */\n        if (strcmp(dd->dd_dirname, dirname) != 0)\n        {\n            /* Update the last occurrence file by the time file of the new problem */\n            struct dump_dir *new_dd = dd_opendir(dirname, DD_OPEN_READONLY);\n            char *last_ocr = NULL;\n            if (new_dd)\n            {\n                /* TIME must exists in a valid dump directory but we don't want to die\n                 * due to broken duplicated dump directory */\n                last_ocr = dd_load_text_ext(new_dd, FILENAME_TIME,\n                            DD_LOAD_TEXT_RETURN_NULL_ON_FAILURE | DD_FAIL_QUIETLY_ENOENT);\n                dd_close(new_dd);\n            }\n            else\n            {   /* dd_opendir() already produced a message with good information about failure */\n                error_msg(\"Can't read the last occurrence file from the new dump directory.\");\n            }\n\n            if (!last_ocr)\n            {   /* the new dump directory may lie in the dump location for some time */\n                log(\"Using current time for the last occurrence file which may be incorrect.\");\n                time_t t = time(NULL);\n                last_ocr = xasprintf(\"%lu\", (long)t);\n            }\n\n            dd_save_text(dd, FILENAME_LAST_OCCURRENCE, last_ocr);\n\n            free(last_ocr);\n        }\n    }\n\n    /* Reset mode/uig/gid to correct values for all files created by event run */\n    dd_sanitize_mode_and_owner(dd);\n\n    dd_close(dd);\n\n    if (!dup_of_dir)\n        log_notice(\"New problem directory %s, processing\", work_dir);\n    else\n    {\n        log_warning(\"Deleting problem directory %s (dup of %s)\",\n                    strrchr(dirname, '/') + 1,\n                    strrchr(dup_of_dir, '/') + 1);\n        delete_dump_dir(dirname);\n    }\n\n    /* Run \"notify[-dup]\" event */\n    int fd;\n    child_pid = spawn_event_handler_child(\n                work_dir,\n                (dup_of_dir ? \"notify-dup\" : \"notify\"),\n                &fd\n    );\n    //log(\"Started notify, fd %d -> %d\", fd, child_stdout_fd);\n    xmove_fd(fd, child_stdout_fd);\n    child_is_post_create = 0;\n    strbuf_clear(cmd_output);\n    free(dup_of_dir);\n    dup_of_dir = NULL;\n    goto read_child_output;\n\n delete_bad_dir:\n    log_warning(\"Deleting problem directory '%s'\", dirname);\n    delete_dump_dir(dirname);\n\n ret:\n    strbuf_free(cmd_output);\n    free(dup_of_dir);\n    close(child_stdout_fd);\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -22,16 +22,6 @@\n             error_msg(\"Problem directory '%s' has already been processed\", dirname);\n             return 403;\n         }\n-    }\n-    else if (!dump_dir_accessible_by_uid(dirname, client_uid))\n-    {\n-        if (errno == ENOTDIR)\n-        {\n-            error_msg(\"Path '%s' isn't problem directory\", dirname);\n-            return 404; /* Not Found */\n-        }\n-        error_msg(\"Problem directory '%s' can't be accessed by user with uid %ld\", dirname, (long)client_uid);\n-        return 403; /* Forbidden */\n     }\n \n     int child_stdout_fd;",
        "diff_line_info": {
            "deleted_lines": [
                "    }",
                "    else if (!dump_dir_accessible_by_uid(dirname, client_uid))",
                "    {",
                "        if (errno == ENOTDIR)",
                "        {",
                "            error_msg(\"Path '%s' isn't problem directory\", dirname);",
                "            return 404; /* Not Found */",
                "        }",
                "        error_msg(\"Problem directory '%s' can't be accessed by user with uid %ld\", dirname, (long)client_uid);",
                "        return 403; /* Forbidden */"
            ],
            "added_lines": []
        }
    },
    {
        "cve_id": "CVE-2015-1869",
        "func_name": "abrt/perform_http_xact",
        "description": "The default event handling scripts in Automatic Bug Reporting Tool (ABRT) allow local users to gain privileges as demonstrated by a symlink attack on a var_log_messages file.",
        "git_url": "https://github.com/abrt/abrt/commit/3287aa12eb205cff95cdd00d6d6c5c9a4f8f0eca",
        "commit_title": "daemon: allow only root user to trigger the post-create",
        "commit_text": " There is no reason to allow non-root users to trigger this functionality. Regular users can create abrt problems only through abrtd or abrt-dbus and both triggers the post-create.  Other hooks run under root user (CCpp, Koops, VMCore, Xorg).  Related: #1212861 ",
        "func_before": "static int perform_http_xact(void)\n{\n    /* use free instead of g_free so that we can use xstr* functions from\n     * libreport/lib/xfuncs.c\n     */\n    GHashTable *problem_info = g_hash_table_new_full(g_str_hash, g_str_equal,\n                                     free, free);\n    /* Read header */\n    char *body_start = NULL;\n    char *messagebuf_data = NULL;\n    unsigned messagebuf_len = 0;\n    /* Loop until EOF/error/timeout/end_of_header */\n    while (1)\n    {\n        messagebuf_data = xrealloc(messagebuf_data, messagebuf_len + INPUT_BUFFER_SIZE);\n        char *p = messagebuf_data + messagebuf_len;\n        int rd = read(STDIN_FILENO, p, INPUT_BUFFER_SIZE);\n        if (rd < 0)\n        {\n            if (errno == EINTR) /* SIGALRM? */\n                error_msg_and_die(\"Timed out\");\n            perror_msg_and_die(\"read\");\n        }\n        if (rd == 0)\n            break;\n\n        log_debug(\"Received %u bytes of data\", rd);\n        messagebuf_len += rd;\n        total_bytes_read += rd;\n        if (total_bytes_read > MAX_MESSAGE_SIZE)\n            error_msg_and_die(\"Message is too long, aborting\");\n\n        /* Check whether we see end of header */\n        /* Note: we support both [\\r]\\n\\r\\n and \\n\\n */\n        char *past_end = messagebuf_data + messagebuf_len;\n        if (p > messagebuf_data+1)\n            p -= 2; /* start search from two last bytes in last read - they might be '\\n\\r' */\n        while (p < past_end)\n        {\n            p = memchr(p, '\\n', past_end - p);\n            if (!p)\n                break;\n            p++;\n            if (p >= past_end)\n                break;\n            if (*p == '\\n'\n             || (*p == '\\r' && p+1 < past_end && p[1] == '\\n')\n            ) {\n                body_start = p + 1 + (*p == '\\r');\n                *p = '\\0';\n                goto found_end_of_header;\n            }\n        }\n    } /* while (read) */\n found_end_of_header: ;\n    log_debug(\"Request: %s\", messagebuf_data);\n\n    /* Sanitize and analyze header.\n     * Header now is in messagebuf_data, NUL terminated string,\n     * with last empty line deleted (by placement of NUL).\n     * \\r\\n are not (yet) converted to \\n, multi-line headers also\n     * not converted.\n     */\n    /* First line must be \"op<space>[http://host]/path<space>HTTP/n.n\".\n     * <space> is exactly one space char.\n     */\n    if (prefixcmp(messagebuf_data, \"DELETE \") == 0)\n    {\n        messagebuf_data += strlen(\"DELETE \");\n        char *space = strchr(messagebuf_data, ' ');\n        if (!space || prefixcmp(space+1, \"HTTP/\") != 0)\n            return 400; /* Bad Request */\n        *space = '\\0';\n        //decode_url(messagebuf_data); %20 => ' '\n        alarm(0);\n        return delete_path(messagebuf_data);\n    }\n\n    /* We erroneously used \"PUT /\" to create new problems.\n     * POST is the correct request in this case:\n     * \"PUT /\" implies creation or replace of resource named \"/\"!\n     * Delete PUT in 2014.\n     */\n    if (prefixcmp(messagebuf_data, \"PUT \") != 0\n     && prefixcmp(messagebuf_data, \"POST \") != 0\n    ) {\n        return 400; /* Bad Request */\n    }\n\n    enum {\n        CREATION_NOTIFICATION,\n        CREATION_REQUEST,\n    };\n    int url_type;\n    char *url = skip_non_whitespace(messagebuf_data) + 1; /* skip \"POST \" */\n    if (prefixcmp(url, \"/creation_notification \") == 0)\n        url_type = CREATION_NOTIFICATION;\n    else if (prefixcmp(url, \"/ \") == 0)\n        url_type = CREATION_REQUEST;\n    else\n        return 400; /* Bad Request */\n\n    /* Read body */\n    if (!body_start)\n    {\n        log_warning(\"Premature EOF detected, exiting\");\n        return 400; /* Bad Request */\n    }\n\n    messagebuf_len -= (body_start - messagebuf_data);\n    memmove(messagebuf_data, body_start, messagebuf_len);\n    log_debug(\"Body so far: %u bytes, '%s'\", messagebuf_len, messagebuf_data);\n\n    /* Loop until EOF/error/timeout */\n    while (1)\n    {\n        if (url_type == CREATION_REQUEST)\n        {\n            while (1)\n            {\n                unsigned len = strnlen(messagebuf_data, messagebuf_len);\n                if (len >= messagebuf_len)\n                    break;\n                /* messagebuf has at least one NUL - process the line */\n                process_message(problem_info, messagebuf_data);\n                messagebuf_len -= (len + 1);\n                memmove(messagebuf_data, messagebuf_data + len + 1, messagebuf_len);\n            }\n        }\n\n        messagebuf_data = xrealloc(messagebuf_data, messagebuf_len + INPUT_BUFFER_SIZE + 1);\n        int rd = read(STDIN_FILENO, messagebuf_data + messagebuf_len, INPUT_BUFFER_SIZE);\n        if (rd < 0)\n        {\n            if (errno == EINTR) /* SIGALRM? */\n                error_msg_and_die(\"Timed out\");\n            perror_msg_and_die(\"read\");\n        }\n        if (rd == 0)\n            break;\n\n        log_debug(\"Received %u bytes of data\", rd);\n        messagebuf_len += rd;\n        total_bytes_read += rd;\n        if (total_bytes_read > MAX_MESSAGE_SIZE)\n            error_msg_and_die(\"Message is too long, aborting\");\n    }\n\n    /* Body received, EOF was seen. Don't let alarm to interrupt after this. */\n    alarm(0);\n\n    if (url_type == CREATION_NOTIFICATION)\n    {\n        messagebuf_data[messagebuf_len] = '\\0';\n        return run_post_create(messagebuf_data);\n    }\n\n    /* Save problem dir */\n    int ret = 0;\n    unsigned pid = convert_pid(problem_info);\n    die_if_data_is_missing(problem_info);\n\n    char *executable = g_hash_table_lookup(problem_info, FILENAME_EXECUTABLE);\n    if (executable)\n    {\n        char *last_file = concat_path_file(g_settings_dump_location, \"last-via-server\");\n        int repeating_crash = check_recent_crash_file(last_file, executable);\n        free(last_file);\n        if (repeating_crash) /* Only pretend that we saved it */\n            goto out; /* ret is 0: \"success\" */\n    }\n\n#if 0\n//TODO:\n    /* At least it should generate local problem identifier UUID */\n    problem_data_add_basics(problem_info);\n//...the problem being that problem_info here is not a problem_data_t!\n#endif\n\n    create_problem_dir(problem_info, pid);\n    /* does not return */\n\n out:\n    g_hash_table_destroy(problem_info);\n    return ret; /* Used as HTTP response code */\n}",
        "func": "static int perform_http_xact(void)\n{\n    /* use free instead of g_free so that we can use xstr* functions from\n     * libreport/lib/xfuncs.c\n     */\n    GHashTable *problem_info = g_hash_table_new_full(g_str_hash, g_str_equal,\n                                     free, free);\n    /* Read header */\n    char *body_start = NULL;\n    char *messagebuf_data = NULL;\n    unsigned messagebuf_len = 0;\n    /* Loop until EOF/error/timeout/end_of_header */\n    while (1)\n    {\n        messagebuf_data = xrealloc(messagebuf_data, messagebuf_len + INPUT_BUFFER_SIZE);\n        char *p = messagebuf_data + messagebuf_len;\n        int rd = read(STDIN_FILENO, p, INPUT_BUFFER_SIZE);\n        if (rd < 0)\n        {\n            if (errno == EINTR) /* SIGALRM? */\n                error_msg_and_die(\"Timed out\");\n            perror_msg_and_die(\"read\");\n        }\n        if (rd == 0)\n            break;\n\n        log_debug(\"Received %u bytes of data\", rd);\n        messagebuf_len += rd;\n        total_bytes_read += rd;\n        if (total_bytes_read > MAX_MESSAGE_SIZE)\n            error_msg_and_die(\"Message is too long, aborting\");\n\n        /* Check whether we see end of header */\n        /* Note: we support both [\\r]\\n\\r\\n and \\n\\n */\n        char *past_end = messagebuf_data + messagebuf_len;\n        if (p > messagebuf_data+1)\n            p -= 2; /* start search from two last bytes in last read - they might be '\\n\\r' */\n        while (p < past_end)\n        {\n            p = memchr(p, '\\n', past_end - p);\n            if (!p)\n                break;\n            p++;\n            if (p >= past_end)\n                break;\n            if (*p == '\\n'\n             || (*p == '\\r' && p+1 < past_end && p[1] == '\\n')\n            ) {\n                body_start = p + 1 + (*p == '\\r');\n                *p = '\\0';\n                goto found_end_of_header;\n            }\n        }\n    } /* while (read) */\n found_end_of_header: ;\n    log_debug(\"Request: %s\", messagebuf_data);\n\n    /* Sanitize and analyze header.\n     * Header now is in messagebuf_data, NUL terminated string,\n     * with last empty line deleted (by placement of NUL).\n     * \\r\\n are not (yet) converted to \\n, multi-line headers also\n     * not converted.\n     */\n    /* First line must be \"op<space>[http://host]/path<space>HTTP/n.n\".\n     * <space> is exactly one space char.\n     */\n    if (prefixcmp(messagebuf_data, \"DELETE \") == 0)\n    {\n        messagebuf_data += strlen(\"DELETE \");\n        char *space = strchr(messagebuf_data, ' ');\n        if (!space || prefixcmp(space+1, \"HTTP/\") != 0)\n            return 400; /* Bad Request */\n        *space = '\\0';\n        //decode_url(messagebuf_data); %20 => ' '\n        alarm(0);\n        return delete_path(messagebuf_data);\n    }\n\n    /* We erroneously used \"PUT /\" to create new problems.\n     * POST is the correct request in this case:\n     * \"PUT /\" implies creation or replace of resource named \"/\"!\n     * Delete PUT in 2014.\n     */\n    if (prefixcmp(messagebuf_data, \"PUT \") != 0\n     && prefixcmp(messagebuf_data, \"POST \") != 0\n    ) {\n        return 400; /* Bad Request */\n    }\n\n    enum {\n        CREATION_NOTIFICATION,\n        CREATION_REQUEST,\n    };\n    int url_type;\n    char *url = skip_non_whitespace(messagebuf_data) + 1; /* skip \"POST \" */\n    if (prefixcmp(url, \"/creation_notification \") == 0)\n        url_type = CREATION_NOTIFICATION;\n    else if (prefixcmp(url, \"/ \") == 0)\n        url_type = CREATION_REQUEST;\n    else\n        return 400; /* Bad Request */\n\n    /* Read body */\n    if (!body_start)\n    {\n        log_warning(\"Premature EOF detected, exiting\");\n        return 400; /* Bad Request */\n    }\n\n    messagebuf_len -= (body_start - messagebuf_data);\n    memmove(messagebuf_data, body_start, messagebuf_len);\n    log_debug(\"Body so far: %u bytes, '%s'\", messagebuf_len, messagebuf_data);\n\n    /* Loop until EOF/error/timeout */\n    while (1)\n    {\n        if (url_type == CREATION_REQUEST)\n        {\n            while (1)\n            {\n                unsigned len = strnlen(messagebuf_data, messagebuf_len);\n                if (len >= messagebuf_len)\n                    break;\n                /* messagebuf has at least one NUL - process the line */\n                process_message(problem_info, messagebuf_data);\n                messagebuf_len -= (len + 1);\n                memmove(messagebuf_data, messagebuf_data + len + 1, messagebuf_len);\n            }\n        }\n\n        messagebuf_data = xrealloc(messagebuf_data, messagebuf_len + INPUT_BUFFER_SIZE + 1);\n        int rd = read(STDIN_FILENO, messagebuf_data + messagebuf_len, INPUT_BUFFER_SIZE);\n        if (rd < 0)\n        {\n            if (errno == EINTR) /* SIGALRM? */\n                error_msg_and_die(\"Timed out\");\n            perror_msg_and_die(\"read\");\n        }\n        if (rd == 0)\n            break;\n\n        log_debug(\"Received %u bytes of data\", rd);\n        messagebuf_len += rd;\n        total_bytes_read += rd;\n        if (total_bytes_read > MAX_MESSAGE_SIZE)\n            error_msg_and_die(\"Message is too long, aborting\");\n    }\n\n    /* Body received, EOF was seen. Don't let alarm to interrupt after this. */\n    alarm(0);\n\n    int ret = 0;\n    if (url_type == CREATION_NOTIFICATION)\n    {\n        if (client_uid != 0)\n        {\n            error_msg(\"UID=%ld is not authorized to trigger post-create processing\", (long)client_uid);\n            ret = 403; /* Forbidden */\n            goto out;\n        }\n\n        messagebuf_data[messagebuf_len] = '\\0';\n        return run_post_create(messagebuf_data);\n    }\n\n    /* Save problem dir */\n    unsigned pid = convert_pid(problem_info);\n    die_if_data_is_missing(problem_info);\n\n    char *executable = g_hash_table_lookup(problem_info, FILENAME_EXECUTABLE);\n    if (executable)\n    {\n        char *last_file = concat_path_file(g_settings_dump_location, \"last-via-server\");\n        int repeating_crash = check_recent_crash_file(last_file, executable);\n        free(last_file);\n        if (repeating_crash) /* Only pretend that we saved it */\n            goto out; /* ret is 0: \"success\" */\n    }\n\n#if 0\n//TODO:\n    /* At least it should generate local problem identifier UUID */\n    problem_data_add_basics(problem_info);\n//...the problem being that problem_info here is not a problem_data_t!\n#endif\n\n    create_problem_dir(problem_info, pid);\n    /* does not return */\n\n out:\n    g_hash_table_destroy(problem_info);\n    return ret; /* Used as HTTP response code */\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -149,14 +149,21 @@\n     /* Body received, EOF was seen. Don't let alarm to interrupt after this. */\n     alarm(0);\n \n+    int ret = 0;\n     if (url_type == CREATION_NOTIFICATION)\n     {\n+        if (client_uid != 0)\n+        {\n+            error_msg(\"UID=%ld is not authorized to trigger post-create processing\", (long)client_uid);\n+            ret = 403; /* Forbidden */\n+            goto out;\n+        }\n+\n         messagebuf_data[messagebuf_len] = '\\0';\n         return run_post_create(messagebuf_data);\n     }\n \n     /* Save problem dir */\n-    int ret = 0;\n     unsigned pid = convert_pid(problem_info);\n     die_if_data_is_missing(problem_info);\n ",
        "diff_line_info": {
            "deleted_lines": [
                "    int ret = 0;"
            ],
            "added_lines": [
                "    int ret = 0;",
                "        if (client_uid != 0)",
                "        {",
                "            error_msg(\"UID=%ld is not authorized to trigger post-create processing\", (long)client_uid);",
                "            ret = 403; /* Forbidden */",
                "            goto out;",
                "        }",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2015-1869",
        "func_name": "abrt/key_value_ok",
        "description": "The default event handling scripts in Automatic Bug Reporting Tool (ABRT) allow local users to gain privileges as demonstrated by a symlink attack on a var_log_messages file.",
        "git_url": "https://github.com/abrt/abrt/commit/7417505e1d93cc95ec648b74e3c801bc67aacb9f",
        "commit_title": "daemon, dbus: allow only root to create CCpp, Koops, vmcore and xorg",
        "commit_text": " Florian Weimer <fweimer@redhat.com>:     This prevents users from feeding things that are not actually     coredumps and excerpts from /proc to these analyzers.      For example, it should not be possible to trigger a rule with     EVENT=post-create analyzer=CCpp using NewProblem  Related: #1212861 ",
        "func_before": "static gboolean key_value_ok(gchar *key, gchar *value)\n{\n    char *i;\n\n    /* check key, it has to be valid filename and will end up in the\n     * bugzilla */\n    for (i = key; *i != 0; i++)\n    {\n        if (!isalpha(*i) && (*i != '-') && (*i != '_') && (*i != ' '))\n            return FALSE;\n    }\n\n    /* check value of 'basename', it has to be valid non-hidden directory\n     * name */\n    if (strcmp(key, \"basename\") == 0\n     || strcmp(key, FILENAME_TYPE) == 0\n    )\n    {\n        if (!str_is_correct_filename(value))\n        {\n            error_msg(\"Value of '%s' ('%s') is not a valid directory name\",\n                      key, value);\n            return FALSE;\n        }\n    }\n\n    return TRUE;\n}",
        "func": "static gboolean key_value_ok(gchar *key, gchar *value)\n{\n    char *i;\n\n    /* check key, it has to be valid filename and will end up in the\n     * bugzilla */\n    for (i = key; *i != 0; i++)\n    {\n        if (!isalpha(*i) && (*i != '-') && (*i != '_') && (*i != ' '))\n            return FALSE;\n    }\n\n    /* check value of 'basename', it has to be valid non-hidden directory\n     * name */\n    if (strcmp(key, \"basename\") == 0\n     || strcmp(key, FILENAME_TYPE) == 0\n    )\n    {\n        if (!str_is_correct_filename(value))\n        {\n            error_msg(\"Value of '%s' ('%s') is not a valid directory name\",\n                      key, value);\n            return FALSE;\n        }\n    }\n\n    return allowed_new_user_problem_entry(client_uid, key, value);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -24,5 +24,5 @@\n         }\n     }\n \n-    return TRUE;\n+    return allowed_new_user_problem_entry(client_uid, key, value);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    return TRUE;"
            ],
            "added_lines": [
                "    return allowed_new_user_problem_entry(client_uid, key, value);"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-1869",
        "func_name": "abrt/handle_new_problem",
        "description": "The default event handling scripts in Automatic Bug Reporting Tool (ABRT) allow local users to gain privileges as demonstrated by a symlink attack on a var_log_messages file.",
        "git_url": "https://github.com/abrt/abrt/commit/7417505e1d93cc95ec648b74e3c801bc67aacb9f",
        "commit_title": "daemon, dbus: allow only root to create CCpp, Koops, vmcore and xorg",
        "commit_text": " Florian Weimer <fweimer@redhat.com>:     This prevents users from feeding things that are not actually     coredumps and excerpts from /proc to these analyzers.      For example, it should not be possible to trigger a rule with     EVENT=post-create analyzer=CCpp using NewProblem  Related: #1212861 ",
        "func_before": "static char *handle_new_problem(GVariant *problem_info, uid_t caller_uid, char **error)\n{\n    problem_data_t *pd = problem_data_new();\n\n    GVariantIter *iter;\n    g_variant_get(problem_info, \"a{ss}\", &iter);\n    gchar *key, *value;\n    while (g_variant_iter_loop(iter, \"{ss}\", &key, &value))\n    {\n        problem_data_add_text_editable(pd, key, value);\n    }\n\n    if (caller_uid != 0 || problem_data_get_content_or_NULL(pd, FILENAME_UID) == NULL)\n    {   /* set uid field to caller's uid if caller is not root or root doesn't pass own uid */\n        log_info(\"Adding UID %d to problem data\", caller_uid);\n        char buf[sizeof(uid_t) * 3 + 2];\n        snprintf(buf, sizeof(buf), \"%d\", caller_uid);\n        problem_data_add_text_noteditable(pd, FILENAME_UID, buf);\n    }\n\n    /* At least it should generate local problem identifier UUID */\n    problem_data_add_basics(pd);\n\n    char *problem_id = problem_data_save(pd);\n    if (problem_id)\n        notify_new_path(problem_id);\n    else if (error)\n        *error = xasprintf(\"Cannot create a new problem\");\n\n    problem_data_free(pd);\n    return problem_id;\n}",
        "func": "static char *handle_new_problem(GVariant *problem_info, uid_t caller_uid, char **error)\n{\n    char *problem_id = NULL;\n    problem_data_t *pd = problem_data_new();\n\n    GVariantIter *iter;\n    g_variant_get(problem_info, \"a{ss}\", &iter);\n    gchar *key, *value;\n    while (g_variant_iter_loop(iter, \"{ss}\", &key, &value))\n    {\n        if (allowed_new_user_problem_entry(caller_uid, key, value) == false)\n        {\n            *error = xasprintf(\"You are not allowed to create element '%s' containing '%s'\", key, value);\n            goto finito;\n        }\n\n        problem_data_add_text_editable(pd, key, value);\n    }\n\n    if (caller_uid != 0 || problem_data_get_content_or_NULL(pd, FILENAME_UID) == NULL)\n    {   /* set uid field to caller's uid if caller is not root or root doesn't pass own uid */\n        log_info(\"Adding UID %d to problem data\", caller_uid);\n        char buf[sizeof(uid_t) * 3 + 2];\n        snprintf(buf, sizeof(buf), \"%d\", caller_uid);\n        problem_data_add_text_noteditable(pd, FILENAME_UID, buf);\n    }\n\n    /* At least it should generate local problem identifier UUID */\n    problem_data_add_basics(pd);\n\n    problem_id = problem_data_save(pd);\n    if (problem_id)\n        notify_new_path(problem_id);\n    else if (error)\n        *error = xasprintf(\"Cannot create a new problem\");\n\nfinito:\n    problem_data_free(pd);\n    return problem_id;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,6 @@\n static char *handle_new_problem(GVariant *problem_info, uid_t caller_uid, char **error)\n {\n+    char *problem_id = NULL;\n     problem_data_t *pd = problem_data_new();\n \n     GVariantIter *iter;\n@@ -7,6 +8,12 @@\n     gchar *key, *value;\n     while (g_variant_iter_loop(iter, \"{ss}\", &key, &value))\n     {\n+        if (allowed_new_user_problem_entry(caller_uid, key, value) == false)\n+        {\n+            *error = xasprintf(\"You are not allowed to create element '%s' containing '%s'\", key, value);\n+            goto finito;\n+        }\n+\n         problem_data_add_text_editable(pd, key, value);\n     }\n \n@@ -21,12 +28,13 @@\n     /* At least it should generate local problem identifier UUID */\n     problem_data_add_basics(pd);\n \n-    char *problem_id = problem_data_save(pd);\n+    problem_id = problem_data_save(pd);\n     if (problem_id)\n         notify_new_path(problem_id);\n     else if (error)\n         *error = xasprintf(\"Cannot create a new problem\");\n \n+finito:\n     problem_data_free(pd);\n     return problem_id;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    char *problem_id = problem_data_save(pd);"
            ],
            "added_lines": [
                "    char *problem_id = NULL;",
                "        if (allowed_new_user_problem_entry(caller_uid, key, value) == false)",
                "        {",
                "            *error = xasprintf(\"You are not allowed to create element '%s' containing '%s'\", key, value);",
                "            goto finito;",
                "        }",
                "",
                "    problem_id = problem_data_save(pd);",
                "finito:"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-21269",
        "func_name": "OpenRC/openrc/do_check",
        "description": "checkpath in OpenRC through 0.42.1 might allow local users to take ownership of arbitrary files because a non-terminal path component can be a symlink.",
        "git_url": "https://github.com/OpenRC/openrc/commit/b6fef599bf8493480664b766040fa9b0d4b1e335",
        "commit_title": "checkpath: fix CVE-2018-21269",
        "commit_text": " This walks the directory path to the file we are going to manipulate to make sure that when we create the file and change the ownership and permissions we are working on the same file. Also, all non-terminal symbolic links must be owned by root. This will keep a non-root user from making a symbolic link as described in the bug. If root creates the symbolic link, it is assumed to be trusted.  On non-linux platforms, we no longer follow non-terminal symbolic links by default. If you need to do that, add the -s option on the checkpath command line, but keep in mind that this is not secure.  This fixes #201.",
        "func_before": "static int do_check(char *path, uid_t uid, gid_t gid, mode_t mode,\n\tinode_t type, bool trunc, bool chowner, bool selinux_on)\n{\n\tstruct stat st;\n\tint fd;\n\tint flags;\n\tint r;\n\tint readfd;\n\tint readflags;\n\tint u;\n\n\tmemset(&st, 0, sizeof(st));\n\tflags = O_CREAT|O_NDELAY|O_WRONLY|O_NOCTTY;\n\treadflags = O_NDELAY|O_NOCTTY|O_RDONLY;\n#ifdef O_CLOEXEC\n\tflags |= O_CLOEXEC;\n\treadflags |= O_CLOEXEC;\n#endif\n#ifdef O_NOFOLLOW\n\tflags |= O_NOFOLLOW;\n\treadflags |= O_NOFOLLOW;\n#endif\n\tif (trunc)\n\t\tflags |= O_TRUNC;\n\treadfd = open(path, readflags);\n\tif (readfd == -1 || (type == inode_file && trunc)) {\n\t\tif (type == inode_file) {\n\t\t\teinfo(\"%s: creating file\", path);\n\t\t\tif (!mode) /* 664 */\n\t\t\t\tmode = S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH;\n\t\t\tu = umask(0);\n\t\t\tfd = open(path, flags, mode);\n\t\t\tumask(u);\n\t\t\tif (fd == -1) {\n\t\t\t\teerror(\"%s: open: %s\", applet, strerror(errno));\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (readfd != -1 && trunc)\n\t\t\t\tclose(readfd);\n\t\t\treadfd = fd;\n\t\t} else if (type == inode_dir) {\n\t\t\teinfo(\"%s: creating directory\", path);\n\t\t\tif (!mode) /* 775 */\n\t\t\t\tmode = S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH;\n\t\t\tu = umask(0);\n\t\t\t/* We do not recursively create parents */\n\t\t\tr = mkdir(path, mode);\n\t\t\tumask(u);\n\t\t\tif (r == -1 && errno != EEXIST) {\n\t\t\t\teerror(\"%s: mkdir: %s\", applet,\n\t\t\t\t    strerror (errno));\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treadfd = open(path, readflags);\n\t\t\tif (readfd == -1) {\n\t\t\t\teerror(\"%s: unable to open directory: %s\", applet,\n\t\t\t\t\t\tstrerror(errno));\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else if (type == inode_fifo) {\n\t\t\teinfo(\"%s: creating fifo\", path);\n\t\t\tif (!mode) /* 600 */\n\t\t\t\tmode = S_IRUSR | S_IWUSR;\n\t\t\tu = umask(0);\n\t\t\tr = mkfifo(path, mode);\n\t\t\tumask(u);\n\t\t\tif (r == -1 && errno != EEXIST) {\n\t\t\t\teerror(\"%s: mkfifo: %s\", applet,\n\t\t\t\t    strerror (errno));\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treadfd = open(path, readflags);\n\t\t\tif (readfd == -1) {\n\t\t\t\teerror(\"%s: unable to open fifo: %s\", applet,\n\t\t\t\t\t\tstrerror(errno));\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\tif (fstat(readfd, &st) != -1) {\n\t\tif (type != inode_dir && S_ISDIR(st.st_mode)) {\n\t\t\teerror(\"%s: is a directory\", path);\n\t\t\tclose(readfd);\n\t\t\treturn 1;\n\t\t}\n\t\tif (type != inode_file && S_ISREG(st.st_mode)) {\n\t\t\teerror(\"%s: is a file\", path);\n\t\t\tclose(readfd);\n\t\t\treturn 1;\n\t\t}\n\t\tif (type != inode_fifo && S_ISFIFO(st.st_mode)) {\n\t\t\teerror(\"%s: is a fifo\", path);\n\t\t\tclose(readfd);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (mode && (st.st_mode & 0777) != mode) {\n\t\t\tif ((type != inode_dir) && (st.st_nlink > 1)) {\n\t\t\t\teerror(\"%s: chmod: %s %s\", applet, \"Too many hard links to\", path);\n\t\t\t\tclose(readfd);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (S_ISLNK(st.st_mode)) {\n\t\t\t\teerror(\"%s: chmod: %s %s\", applet, path, \" is a symbolic link\");\n\t\t\t\tclose(readfd);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\teinfo(\"%s: correcting mode\", path);\n\t\t\tif (fchmod(readfd, mode)) {\n\t\t\t\teerror(\"%s: chmod: %s\", applet, strerror(errno));\n\t\t\t\tclose(readfd);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tif (chowner && (st.st_uid != uid || st.st_gid != gid)) {\n\t\t\tif ((type != inode_dir) && (st.st_nlink > 1)) {\n\t\t\t\teerror(\"%s: chown: %s %s\", applet, \"Too many hard links to\", path);\n\t\t\t\tclose(readfd);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (S_ISLNK(st.st_mode)) {\n\t\t\t\teerror(\"%s: chown: %s %s\", applet, path, \" is a symbolic link\");\n\t\t\t\tclose(readfd);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\teinfo(\"%s: correcting owner\", path);\n\t\t\tif (fchown(readfd, uid, gid)) {\n\t\t\t\teerror(\"%s: chown: %s\", applet, strerror(errno));\n\t\t\t\tclose(readfd);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tif (selinux_on)\n\t\t\tselinux_util_label(path);\n\t} else {\n\t\teerror(\"fstat: %s: %s\", path, strerror(errno));\n\t\tclose(readfd);\n\t\treturn -1;\n\t}\n\tclose(readfd);\n\n\treturn 0;\n}",
        "func": "static int do_check(char *path, uid_t uid, gid_t gid, mode_t mode,\n\tinode_t type, bool trunc, bool chowner, bool symlinks, bool selinux_on)\n{\n\tstruct stat st;\n\tchar *name = NULL;\n\tint dirfd;\n\tint fd;\n\tint flags;\n\tint r;\n\tint readfd;\n\tint readflags;\n\tint u;\n\n\tmemset(&st, 0, sizeof(st));\n\tflags = O_CREAT|O_NDELAY|O_WRONLY|O_NOCTTY;\n\treadflags = O_NDELAY|O_NOCTTY|O_RDONLY;\n#ifdef O_CLOEXEC\n\tflags |= O_CLOEXEC;\n\treadflags |= O_CLOEXEC;\n#endif\n#ifdef O_NOFOLLOW\n\tflags |= O_NOFOLLOW;\n\treadflags |= O_NOFOLLOW;\n#endif\n\tif (trunc)\n\t\tflags |= O_TRUNC;\n\txasprintf(&name, \"%s\", basename_c(path));\n\tdirfd = get_dirfd(path, symlinks);\n\treadfd = openat(dirfd, name, readflags);\n\tif (readfd == -1 || (type == inode_file && trunc)) {\n\t\tif (type == inode_file) {\n\t\t\teinfo(\"%s: creating file\", path);\n\t\t\tif (!mode) /* 664 */\n\t\t\t\tmode = S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH;\n\t\t\tu = umask(0);\n\t\t\tfd = openat(dirfd, name, flags, mode);\n\t\t\tumask(u);\n\t\t\tif (fd == -1) {\n\t\t\t\teerror(\"%s: open: %s\", applet, strerror(errno));\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (readfd != -1 && trunc)\n\t\t\t\tclose(readfd);\n\t\t\treadfd = fd;\n\t\t} else if (type == inode_dir) {\n\t\t\teinfo(\"%s: creating directory\", path);\n\t\t\tif (!mode) /* 775 */\n\t\t\t\tmode = S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH;\n\t\t\tu = umask(0);\n\t\t\t/* We do not recursively create parents */\n\t\t\tr = mkdir(path, mode);\n\t\t\tumask(u);\n\t\t\tif (r == -1 && errno != EEXIST) {\n\t\t\t\teerror(\"%s: mkdir: %s\", applet,\n\t\t\t\t    strerror (errno));\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treadfd = openat(dirfd, name, readflags);\n\t\t\tif (readfd == -1) {\n\t\t\t\teerror(\"%s: unable to open directory: %s\", applet,\n\t\t\t\t\t\tstrerror(errno));\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t} else if (type == inode_fifo) {\n\t\t\teinfo(\"%s: creating fifo\", path);\n\t\t\tif (!mode) /* 600 */\n\t\t\t\tmode = S_IRUSR | S_IWUSR;\n\t\t\tu = umask(0);\n\t\t\tr = mkfifo(path, mode);\n\t\t\tumask(u);\n\t\t\tif (r == -1 && errno != EEXIST) {\n\t\t\t\teerror(\"%s: mkfifo: %s\", applet,\n\t\t\t\t    strerror (errno));\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treadfd = openat(dirfd, name, readflags);\n\t\t\tif (readfd == -1) {\n\t\t\t\teerror(\"%s: unable to open fifo: %s\", applet,\n\t\t\t\t\t\tstrerror(errno));\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\tif (fstat(readfd, &st) != -1) {\n\t\tif (type != inode_dir && S_ISDIR(st.st_mode)) {\n\t\t\teerror(\"%s: is a directory\", path);\n\t\t\tclose(readfd);\n\t\t\treturn 1;\n\t\t}\n\t\tif (type != inode_file && S_ISREG(st.st_mode)) {\n\t\t\teerror(\"%s: is a file\", path);\n\t\t\tclose(readfd);\n\t\t\treturn 1;\n\t\t}\n\t\tif (type != inode_fifo && S_ISFIFO(st.st_mode)) {\n\t\t\teerror(\"%s: is a fifo\", path);\n\t\t\tclose(readfd);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (mode && (st.st_mode & 0777) != mode) {\n\t\t\tif ((type != inode_dir) && (st.st_nlink > 1)) {\n\t\t\t\teerror(\"%s: chmod: %s %s\", applet, \"Too many hard links to\", path);\n\t\t\t\tclose(readfd);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (S_ISLNK(st.st_mode)) {\n\t\t\t\teerror(\"%s: chmod: %s %s\", applet, path, \" is a symbolic link\");\n\t\t\t\tclose(readfd);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\teinfo(\"%s: correcting mode\", path);\n\t\t\tif (fchmod(readfd, mode)) {\n\t\t\t\teerror(\"%s: chmod: %s\", applet, strerror(errno));\n\t\t\t\tclose(readfd);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tif (chowner && (st.st_uid != uid || st.st_gid != gid)) {\n\t\t\tif ((type != inode_dir) && (st.st_nlink > 1)) {\n\t\t\t\teerror(\"%s: chown: %s %s\", applet, \"Too many hard links to\", path);\n\t\t\t\tclose(readfd);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tif (S_ISLNK(st.st_mode)) {\n\t\t\t\teerror(\"%s: chown: %s %s\", applet, path, \" is a symbolic link\");\n\t\t\t\tclose(readfd);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\teinfo(\"%s: correcting owner\", path);\n\t\t\tif (fchown(readfd, uid, gid)) {\n\t\t\t\teerror(\"%s: chown: %s\", applet, strerror(errno));\n\t\t\t\tclose(readfd);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\tif (selinux_on)\n\t\t\tselinux_util_label(path);\n\t} else {\n\t\teerror(\"fstat: %s: %s\", path, strerror(errno));\n\t\tclose(readfd);\n\t\treturn -1;\n\t}\n\tclose(readfd);\n\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,7 +1,9 @@\n static int do_check(char *path, uid_t uid, gid_t gid, mode_t mode,\n-\tinode_t type, bool trunc, bool chowner, bool selinux_on)\n+\tinode_t type, bool trunc, bool chowner, bool symlinks, bool selinux_on)\n {\n \tstruct stat st;\n+\tchar *name = NULL;\n+\tint dirfd;\n \tint fd;\n \tint flags;\n \tint r;\n@@ -22,14 +24,16 @@\n #endif\n \tif (trunc)\n \t\tflags |= O_TRUNC;\n-\treadfd = open(path, readflags);\n+\txasprintf(&name, \"%s\", basename_c(path));\n+\tdirfd = get_dirfd(path, symlinks);\n+\treadfd = openat(dirfd, name, readflags);\n \tif (readfd == -1 || (type == inode_file && trunc)) {\n \t\tif (type == inode_file) {\n \t\t\teinfo(\"%s: creating file\", path);\n \t\t\tif (!mode) /* 664 */\n \t\t\t\tmode = S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH;\n \t\t\tu = umask(0);\n-\t\t\tfd = open(path, flags, mode);\n+\t\t\tfd = openat(dirfd, name, flags, mode);\n \t\t\tumask(u);\n \t\t\tif (fd == -1) {\n \t\t\t\teerror(\"%s: open: %s\", applet, strerror(errno));\n@@ -51,7 +55,7 @@\n \t\t\t\t    strerror (errno));\n \t\t\t\treturn -1;\n \t\t\t}\n-\t\t\treadfd = open(path, readflags);\n+\t\t\treadfd = openat(dirfd, name, readflags);\n \t\t\tif (readfd == -1) {\n \t\t\t\teerror(\"%s: unable to open directory: %s\", applet,\n \t\t\t\t\t\tstrerror(errno));\n@@ -69,7 +73,7 @@\n \t\t\t\t    strerror (errno));\n \t\t\t\treturn -1;\n \t\t\t}\n-\t\t\treadfd = open(path, readflags);\n+\t\t\treadfd = openat(dirfd, name, readflags);\n \t\t\tif (readfd == -1) {\n \t\t\t\teerror(\"%s: unable to open fifo: %s\", applet,\n \t\t\t\t\t\tstrerror(errno));",
        "diff_line_info": {
            "deleted_lines": [
                "\tinode_t type, bool trunc, bool chowner, bool selinux_on)",
                "\treadfd = open(path, readflags);",
                "\t\t\tfd = open(path, flags, mode);",
                "\t\t\treadfd = open(path, readflags);",
                "\t\t\treadfd = open(path, readflags);"
            ],
            "added_lines": [
                "\tinode_t type, bool trunc, bool chowner, bool symlinks, bool selinux_on)",
                "\tchar *name = NULL;",
                "\tint dirfd;",
                "\txasprintf(&name, \"%s\", basename_c(path));",
                "\tdirfd = get_dirfd(path, symlinks);",
                "\treadfd = openat(dirfd, name, readflags);",
                "\t\t\tfd = openat(dirfd, name, flags, mode);",
                "\t\t\treadfd = openat(dirfd, name, readflags);",
                "\t\t\treadfd = openat(dirfd, name, readflags);"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-21269",
        "func_name": "OpenRC/openrc/main",
        "description": "checkpath in OpenRC through 0.42.1 might allow local users to take ownership of arbitrary files because a non-terminal path component can be a symlink.",
        "git_url": "https://github.com/OpenRC/openrc/commit/b6fef599bf8493480664b766040fa9b0d4b1e335",
        "commit_title": "checkpath: fix CVE-2018-21269",
        "commit_text": " This walks the directory path to the file we are going to manipulate to make sure that when we create the file and change the ownership and permissions we are working on the same file. Also, all non-terminal symbolic links must be owned by root. This will keep a non-root user from making a symbolic link as described in the bug. If root creates the symbolic link, it is assumed to be trusted.  On non-linux platforms, we no longer follow non-terminal symbolic links by default. If you need to do that, add the -s option on the checkpath command line, but keep in mind that this is not secure.  This fixes #201.",
        "func_before": "int main(int argc, char **argv)\n{\n\tint opt;\n\tuid_t uid = geteuid();\n\tgid_t gid = getgid();\n\tmode_t mode = 0;\n\tstruct passwd *pw = NULL;\n\tstruct group *gr = NULL;\n\tinode_t type = inode_unknown;\n\tint retval = EXIT_SUCCESS;\n\tbool trunc = false;\n\tbool chowner = false;\n\tbool writable = false;\n\tbool selinux_on = false;\n\n\tapplet = basename_c(argv[0]);\n\twhile ((opt = getopt_long(argc, argv, getoptstring,\n\t\t    longopts, (int *) 0)) != -1)\n\t{\n\t\tswitch (opt) {\n\t\tcase 'D':\n\t\t\ttrunc = true;\n\t\t\t/* falls through */\n\t\tcase 'd':\n\t\t\ttype = inode_dir;\n\t\t\tbreak;\n\t\tcase 'F':\n\t\t\ttrunc = true;\n\t\t\t/* falls through */\n\t\tcase 'f':\n\t\t\ttype = inode_file;\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\ttype = inode_fifo;\n\t\t\tbreak;\n\t\tcase 'm':\n\t\t\tif (parse_mode(&mode, optarg) != 0)\n\t\t\t\teerrorx(\"%s: invalid mode `%s'\",\n\t\t\t\t    applet, optarg);\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\tchowner = true;\n\t\t\tif (parse_owner(&pw, &gr, optarg) != 0)\n\t\t\t\teerrorx(\"%s: owner `%s' not found\",\n\t\t\t\t    applet, optarg);\n\t\t\tbreak;\n\t\tcase 'W':\n\t\t\twritable = true;\n\t\t\tbreak;\n\n\t\tcase_RC_COMMON_GETOPT\n\t\t}\n\t}\n\n\tif (optind >= argc)\n\t\tusage(EXIT_FAILURE);\n\n\tif (writable && type != inode_unknown)\n\t\teerrorx(\"%s: -W cannot be specified along with -d, -f or -p\", applet);\n\n\tif (pw) {\n\t\tuid = pw->pw_uid;\n\t\tgid = pw->pw_gid;\n\t}\n\tif (gr)\n\t\tgid = gr->gr_gid;\n\n\tif (selinux_util_open() == 1)\n\t\tselinux_on = true;\n\n\twhile (optind < argc) {\n\t\tif (writable)\n\t\t\texit(!is_writable(argv[optind]));\n\t\tif (do_check(argv[optind], uid, gid, mode, type, trunc, chowner, selinux_on))\n\t\t\tretval = EXIT_FAILURE;\n\t\toptind++;\n\t}\n\n\tif (selinux_on)\n\t\tselinux_util_close();\n\n\treturn retval;\n}",
        "func": "int main(int argc, char **argv)\n{\n\tint opt;\n\tuid_t uid = geteuid();\n\tgid_t gid = getgid();\n\tmode_t mode = 0;\n\tstruct passwd *pw = NULL;\n\tstruct group *gr = NULL;\n\tinode_t type = inode_unknown;\n\tint retval = EXIT_SUCCESS;\n\tbool trunc = false;\n\tbool chowner = false;\n\tbool symlinks = false;\n\tbool writable = false;\n\tbool selinux_on = false;\n\n\tapplet = basename_c(argv[0]);\n\twhile ((opt = getopt_long(argc, argv, getoptstring,\n\t\t    longopts, (int *) 0)) != -1)\n\t{\n\t\tswitch (opt) {\n\t\tcase 'D':\n\t\t\ttrunc = true;\n\t\t\t/* falls through */\n\t\tcase 'd':\n\t\t\ttype = inode_dir;\n\t\t\tbreak;\n\t\tcase 'F':\n\t\t\ttrunc = true;\n\t\t\t/* falls through */\n\t\tcase 'f':\n\t\t\ttype = inode_file;\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\ttype = inode_fifo;\n\t\t\tbreak;\n\t\tcase 'm':\n\t\t\tif (parse_mode(&mode, optarg) != 0)\n\t\t\t\teerrorx(\"%s: invalid mode `%s'\",\n\t\t\t\t    applet, optarg);\n\t\t\tbreak;\n\t\tcase 'o':\n\t\t\tchowner = true;\n\t\t\tif (parse_owner(&pw, &gr, optarg) != 0)\n\t\t\t\teerrorx(\"%s: owner `%s' not found\",\n\t\t\t\t    applet, optarg);\n\t\t\tbreak;\n\t\tcase 's':\n#ifndef O_PATH\n\t\t\tsymlinks = true;\n#endif\n\t\t\tbreak;\n\t\tcase 'W':\n\t\t\twritable = true;\n\t\t\tbreak;\n\n\t\tcase_RC_COMMON_GETOPT\n\t\t}\n\t}\n\n\tif (optind >= argc)\n\t\tusage(EXIT_FAILURE);\n\n\tif (writable && type != inode_unknown)\n\t\teerrorx(\"%s: -W cannot be specified along with -d, -f or -p\", applet);\n\n\tif (pw) {\n\t\tuid = pw->pw_uid;\n\t\tgid = pw->pw_gid;\n\t}\n\tif (gr)\n\t\tgid = gr->gr_gid;\n\n\tif (selinux_util_open() == 1)\n\t\tselinux_on = true;\n\n\twhile (optind < argc) {\n\t\tif (writable)\n\t\t\texit(!is_writable(argv[optind]));\n\t\tif (do_check(argv[optind], uid, gid, mode, type, trunc, chowner,\n\t\t\t\t\tsymlinks, selinux_on))\n\t\t\tretval = EXIT_FAILURE;\n\t\toptind++;\n\t}\n\n\tif (selinux_on)\n\t\tselinux_util_close();\n\n\treturn retval;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -10,6 +10,7 @@\n \tint retval = EXIT_SUCCESS;\n \tbool trunc = false;\n \tbool chowner = false;\n+\tbool symlinks = false;\n \tbool writable = false;\n \tbool selinux_on = false;\n \n@@ -44,6 +45,11 @@\n \t\t\t\teerrorx(\"%s: owner `%s' not found\",\n \t\t\t\t    applet, optarg);\n \t\t\tbreak;\n+\t\tcase 's':\n+#ifndef O_PATH\n+\t\t\tsymlinks = true;\n+#endif\n+\t\t\tbreak;\n \t\tcase 'W':\n \t\t\twritable = true;\n \t\t\tbreak;\n@@ -71,7 +77,8 @@\n \twhile (optind < argc) {\n \t\tif (writable)\n \t\t\texit(!is_writable(argv[optind]));\n-\t\tif (do_check(argv[optind], uid, gid, mode, type, trunc, chowner, selinux_on))\n+\t\tif (do_check(argv[optind], uid, gid, mode, type, trunc, chowner,\n+\t\t\t\t\tsymlinks, selinux_on))\n \t\t\tretval = EXIT_FAILURE;\n \t\toptind++;\n \t}",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tif (do_check(argv[optind], uid, gid, mode, type, trunc, chowner, selinux_on))"
            ],
            "added_lines": [
                "\tbool symlinks = false;",
                "\t\tcase 's':",
                "#ifndef O_PATH",
                "\t\t\tsymlinks = true;",
                "#endif",
                "\t\t\tbreak;",
                "\t\tif (do_check(argv[optind], uid, gid, mode, type, trunc, chowner,",
                "\t\t\t\t\tsymlinks, selinux_on))"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-36241",
        "func_name": "GNOME/gnome-autoar/autoar_extractor_do_sanitize_pathname",
        "description": "autoar-extractor.c in GNOME gnome-autoar through 0.2.4, as used by GNOME Shell, Nautilus, and other software, allows Directory Traversal during extraction because it lacks a check of whether a file's parent is a symlink to a directory outside of the intended extraction location.",
        "git_url": "https://github.com/GNOME/gnome-autoar/commit/adb067e645732fdbe7103516e506d09eb6a54429",
        "commit_title": "AutoarExtractor: Do not extract files outside the destination dir",
        "commit_text": " Currently, a malicious archive can cause that the files are extracted outside of the destination dir. This can happen if the archive contains a file whose parent is a symbolic link, which points outside of the destination dir. This is potentially a security threat similar to CVE-2020-11736. Let's skip such problematic files when extracting. ",
        "func_before": "static GFile*\nautoar_extractor_do_sanitize_pathname (AutoarExtractor *self,\n                                       const char      *pathname_bytes)\n{\n  GFile *extracted_filename;\n  gboolean valid_filename;\n  g_autofree char *sanitized_pathname;\n  g_autofree char *utf8_pathname;\n\n  utf8_pathname = autoar_common_get_utf8_pathname (pathname_bytes);\n  extracted_filename = g_file_get_child (self->destination_dir,\n                                         utf8_pathname ?  utf8_pathname : pathname_bytes);\n\n  valid_filename =\n    g_file_equal (extracted_filename, self->destination_dir) ||\n    g_file_has_prefix (extracted_filename, self->destination_dir);\n\n  if (!valid_filename) {\n    g_autofree char *basename;\n\n    basename = g_file_get_basename (extracted_filename);\n\n    g_object_unref (extracted_filename);\n\n    extracted_filename = g_file_get_child (self->destination_dir,\n                                           basename);\n  }\n\n  if (self->prefix != NULL && self->new_prefix != NULL) {\n    g_autofree char *relative_path;\n    /* Replace the old prefix with the new one */\n    relative_path = g_file_get_relative_path (self->prefix,\n                                              extracted_filename);\n\n    relative_path = relative_path != NULL ? relative_path : g_strdup (\"\");\n\n    g_object_unref (extracted_filename);\n\n    extracted_filename = g_file_get_child (self->new_prefix,\n                                           relative_path);\n  }\n\n  sanitized_pathname = g_file_get_path (extracted_filename);\n\n  g_debug (\"autoar_extractor_do_sanitize_pathname: %s\", sanitized_pathname);\n\n  return extracted_filename;\n}",
        "func": "static GFile*\nautoar_extractor_do_sanitize_pathname (AutoarExtractor *self,\n                                       const char      *pathname_bytes)\n{\n  GFile *extracted_filename;\n  gboolean valid_filename;\n  g_autofree char *sanitized_pathname = NULL;\n  g_autofree char *utf8_pathname;\n\n  utf8_pathname = autoar_common_get_utf8_pathname (pathname_bytes);\n  extracted_filename = g_file_get_child (self->destination_dir,\n                                         utf8_pathname ?  utf8_pathname : pathname_bytes);\n\n  valid_filename = is_valid_filename (extracted_filename, self->destination_dir);\n  if (!valid_filename) {\n    g_warning (\"autoar_extractor_do_sanitize_pathname: %s is outside of the destination dir\",\n                g_file_peek_path (extracted_filename));\n\n    g_object_unref (extracted_filename);\n\n    return NULL;\n  }\n\n  if (self->prefix != NULL && self->new_prefix != NULL) {\n    g_autofree char *relative_path;\n    /* Replace the old prefix with the new one */\n    relative_path = g_file_get_relative_path (self->prefix,\n                                              extracted_filename);\n\n    relative_path = relative_path != NULL ? relative_path : g_strdup (\"\");\n\n    g_object_unref (extracted_filename);\n\n    extracted_filename = g_file_get_child (self->new_prefix,\n                                           relative_path);\n  }\n\n  sanitized_pathname = g_file_get_path (extracted_filename);\n\n  g_debug (\"autoar_extractor_do_sanitize_pathname: %s\", sanitized_pathname);\n\n  return extracted_filename;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,26 +4,21 @@\n {\n   GFile *extracted_filename;\n   gboolean valid_filename;\n-  g_autofree char *sanitized_pathname;\n+  g_autofree char *sanitized_pathname = NULL;\n   g_autofree char *utf8_pathname;\n \n   utf8_pathname = autoar_common_get_utf8_pathname (pathname_bytes);\n   extracted_filename = g_file_get_child (self->destination_dir,\n                                          utf8_pathname ?  utf8_pathname : pathname_bytes);\n \n-  valid_filename =\n-    g_file_equal (extracted_filename, self->destination_dir) ||\n-    g_file_has_prefix (extracted_filename, self->destination_dir);\n-\n+  valid_filename = is_valid_filename (extracted_filename, self->destination_dir);\n   if (!valid_filename) {\n-    g_autofree char *basename;\n-\n-    basename = g_file_get_basename (extracted_filename);\n+    g_warning (\"autoar_extractor_do_sanitize_pathname: %s is outside of the destination dir\",\n+                g_file_peek_path (extracted_filename));\n \n     g_object_unref (extracted_filename);\n \n-    extracted_filename = g_file_get_child (self->destination_dir,\n-                                           basename);\n+    return NULL;\n   }\n \n   if (self->prefix != NULL && self->new_prefix != NULL) {",
        "diff_line_info": {
            "deleted_lines": [
                "  g_autofree char *sanitized_pathname;",
                "  valid_filename =",
                "    g_file_equal (extracted_filename, self->destination_dir) ||",
                "    g_file_has_prefix (extracted_filename, self->destination_dir);",
                "",
                "    g_autofree char *basename;",
                "",
                "    basename = g_file_get_basename (extracted_filename);",
                "    extracted_filename = g_file_get_child (self->destination_dir,",
                "                                           basename);"
            ],
            "added_lines": [
                "  g_autofree char *sanitized_pathname = NULL;",
                "  valid_filename = is_valid_filename (extracted_filename, self->destination_dir);",
                "    g_warning (\"autoar_extractor_do_sanitize_pathname: %s is outside of the destination dir\",",
                "                g_file_peek_path (extracted_filename));",
                "    return NULL;"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-36241",
        "func_name": "GNOME/gnome-autoar/autoar_extractor_step_extract",
        "description": "autoar-extractor.c in GNOME gnome-autoar through 0.2.4, as used by GNOME Shell, Nautilus, and other software, allows Directory Traversal during extraction because it lacks a check of whether a file's parent is a symlink to a directory outside of the intended extraction location.",
        "git_url": "https://github.com/GNOME/gnome-autoar/commit/adb067e645732fdbe7103516e506d09eb6a54429",
        "commit_title": "AutoarExtractor: Do not extract files outside the destination dir",
        "commit_text": " Currently, a malicious archive can cause that the files are extracted outside of the destination dir. This can happen if the archive contains a file whose parent is a symbolic link, which points outside of the destination dir. This is potentially a security threat similar to CVE-2020-11736. Let's skip such problematic files when extracting. ",
        "func_before": "static void\nautoar_extractor_step_extract (AutoarExtractor *self) {\n  /* Step 3: Extract files\n   * We have to re-open the archive to extract files\n   */\n\n  struct archive *a;\n  struct archive_entry *entry;\n\n  int r;\n\n  g_debug (\"autoar_extractor_step_extract: called\");\n\n  r = libarchive_create_read_object (self->use_raw_format, self, &a);\n  if (r != ARCHIVE_OK) {\n    if (self->error == NULL) {\n      self->error =\n        autoar_common_g_error_new_a (a, self->source_basename);\n    }\n    archive_read_free (a);\n    return;\n  }\n\n  while ((r = archive_read_next_header (a, &entry)) == ARCHIVE_OK) {\n    const char *pathname;\n    const char *hardlink;\n    g_autoptr (GFile) extracted_filename = NULL;\n    g_autoptr (GFile) hardlink_filename = NULL;\n    AutoarConflictAction action;\n    gboolean file_conflict;\n\n    if (g_cancellable_is_cancelled (self->cancellable)) {\n      archive_read_free (a);\n      return;\n    }\n\n    pathname = archive_entry_pathname (entry);\n    hardlink = archive_entry_hardlink (entry);\n\n    extracted_filename =\n      autoar_extractor_do_sanitize_pathname (self, pathname);\n\n    if (hardlink != NULL) {\n      hardlink_filename =\n        autoar_extractor_do_sanitize_pathname (self, hardlink);\n    }\n\n    /* Attempt to solve any name conflict before doing any operations */\n    file_conflict = autoar_extractor_check_file_conflict (extracted_filename,\n                                                          archive_entry_filetype (entry));\n    while (file_conflict) {\n      GFile *new_extracted_filename = NULL;\n\n      action = autoar_extractor_signal_conflict (self,\n                                                 extracted_filename,\n                                                 &new_extracted_filename);\n\n      switch (action) {\n        case AUTOAR_CONFLICT_OVERWRITE:\n          break;\n        case AUTOAR_CONFLICT_CHANGE_DESTINATION:\n          g_assert_nonnull (new_extracted_filename);\n          g_clear_object (&extracted_filename);\n          extracted_filename = new_extracted_filename;\n          break;\n        case AUTOAR_CONFLICT_SKIP:\n          archive_read_data_skip (a);\n          break;\n        default:\n          g_assert_not_reached ();\n          break;\n      }\n\n      if (action != AUTOAR_CONFLICT_CHANGE_DESTINATION) {\n        break;\n      }\n\n      file_conflict = autoar_extractor_check_file_conflict (extracted_filename,\n                                                            archive_entry_filetype (entry));\n    }\n\n    if (file_conflict && action == AUTOAR_CONFLICT_SKIP) {\n      continue;\n    }\n\n    autoar_extractor_do_write_entry (self, a, entry,\n                                     extracted_filename, hardlink_filename);\n\n    if (self->error != NULL) {\n      archive_read_free (a);\n      return;\n    }\n\n    self->completed_files++;\n    autoar_extractor_signal_progress (self);\n  }\n\n  if (r != ARCHIVE_EOF) {\n    if (self->error == NULL) {\n      self->error =\n        autoar_common_g_error_new_a (a, self->source_basename);\n    }\n    archive_read_free (a);\n    return;\n  }\n\n  archive_read_free (a);\n}",
        "func": "static void\nautoar_extractor_step_extract (AutoarExtractor *self) {\n  /* Step 3: Extract files\n   * We have to re-open the archive to extract files\n   */\n\n  struct archive *a;\n  struct archive_entry *entry;\n\n  int r;\n\n  g_debug (\"autoar_extractor_step_extract: called\");\n\n  r = libarchive_create_read_object (self->use_raw_format, self, &a);\n  if (r != ARCHIVE_OK) {\n    if (self->error == NULL) {\n      self->error =\n        autoar_common_g_error_new_a (a, self->source_basename);\n    }\n    archive_read_free (a);\n    return;\n  }\n\n  while ((r = archive_read_next_header (a, &entry)) == ARCHIVE_OK) {\n    const char *pathname;\n    const char *hardlink;\n    g_autoptr (GFile) extracted_filename = NULL;\n    g_autoptr (GFile) hardlink_filename = NULL;\n    AutoarConflictAction action;\n    gboolean file_conflict;\n\n    if (g_cancellable_is_cancelled (self->cancellable)) {\n      archive_read_free (a);\n      return;\n    }\n\n    pathname = archive_entry_pathname (entry);\n    hardlink = archive_entry_hardlink (entry);\n\n    extracted_filename =\n      autoar_extractor_do_sanitize_pathname (self, pathname);\n    if (extracted_filename == NULL) {\n      archive_read_data_skip (a);\n      continue;\n    }\n\n    if (hardlink != NULL) {\n      hardlink_filename =\n        autoar_extractor_do_sanitize_pathname (self, hardlink);\n        if (hardlink_filename == NULL) {\n          archive_read_data_skip (a);\n          continue;\n        }\n    }\n\n    /* Attempt to solve any name conflict before doing any operations */\n    file_conflict = autoar_extractor_check_file_conflict (extracted_filename,\n                                                          archive_entry_filetype (entry));\n    while (file_conflict) {\n      GFile *new_extracted_filename = NULL;\n\n      action = autoar_extractor_signal_conflict (self,\n                                                 extracted_filename,\n                                                 &new_extracted_filename);\n\n      switch (action) {\n        case AUTOAR_CONFLICT_OVERWRITE:\n          break;\n        case AUTOAR_CONFLICT_CHANGE_DESTINATION:\n          g_assert_nonnull (new_extracted_filename);\n          g_clear_object (&extracted_filename);\n          extracted_filename = new_extracted_filename;\n          break;\n        case AUTOAR_CONFLICT_SKIP:\n          archive_read_data_skip (a);\n          break;\n        default:\n          g_assert_not_reached ();\n          break;\n      }\n\n      if (action != AUTOAR_CONFLICT_CHANGE_DESTINATION) {\n        break;\n      }\n\n      file_conflict = autoar_extractor_check_file_conflict (extracted_filename,\n                                                            archive_entry_filetype (entry));\n    }\n\n    if (file_conflict && action == AUTOAR_CONFLICT_SKIP) {\n      continue;\n    }\n\n    autoar_extractor_do_write_entry (self, a, entry,\n                                     extracted_filename, hardlink_filename);\n\n    if (self->error != NULL) {\n      archive_read_free (a);\n      return;\n    }\n\n    self->completed_files++;\n    autoar_extractor_signal_progress (self);\n  }\n\n  if (r != ARCHIVE_EOF) {\n    if (self->error == NULL) {\n      self->error =\n        autoar_common_g_error_new_a (a, self->source_basename);\n    }\n    archive_read_free (a);\n    return;\n  }\n\n  archive_read_free (a);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -39,10 +39,18 @@\n \n     extracted_filename =\n       autoar_extractor_do_sanitize_pathname (self, pathname);\n+    if (extracted_filename == NULL) {\n+      archive_read_data_skip (a);\n+      continue;\n+    }\n \n     if (hardlink != NULL) {\n       hardlink_filename =\n         autoar_extractor_do_sanitize_pathname (self, hardlink);\n+        if (hardlink_filename == NULL) {\n+          archive_read_data_skip (a);\n+          continue;\n+        }\n     }\n \n     /* Attempt to solve any name conflict before doing any operations */",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    if (extracted_filename == NULL) {",
                "      archive_read_data_skip (a);",
                "      continue;",
                "    }",
                "        if (hardlink_filename == NULL) {",
                "          archive_read_data_skip (a);",
                "          continue;",
                "        }"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-27229",
        "func_name": "mumble-voip/mumble/ConnectDialog::on_qaUrl_triggered",
        "description": "Mumble before 1.3.4 allows remote code execution if a victim navigates to a crafted URL on a server list and clicks on the Open Webpage text.",
        "git_url": "https://github.com/mumble-voip/mumble/commit/e59ee87abe249f345908c7d568f6879d16bfd648",
        "commit_title": "FIX(client): Only allow \"http\"/\"https\" for URLs in ConnectDialog",
        "commit_text": " Our public server list registration script doesn't have an URL scheme whitelist for the website field.  Turns out a malicious server can register itself with a dangerous URL in an attempt to attack a user's machine.  User interaction is required, as the URL has to be opened by right-clicking on the server entry and clicking on \"Open Webpage\".  This commit introduces a client-side whitelist, which only allows \"http\" and \"https\" schemes. We will also implement it in our public list.  In future we should probably add a warning QMessageBox informing the user that there's no guarantee the URL is safe (regardless of the scheme).  Thanks a lot to https://positive.security for reporting the RCE vulnerability to us privately.",
        "func_before": "void ConnectDialog::on_qaUrl_triggered() {\n\tServerItem *si = static_cast<ServerItem *>(qtwServers->currentItem());\n\tif (! si || si->qsUrl.isEmpty())\n\t\treturn;\n\n\tQDesktopServices::openUrl(QUrl(si->qsUrl));\n}",
        "func": "void ConnectDialog::on_qaUrl_triggered() {\n\tauto *si = static_cast< const ServerItem * >(qtwServers->currentItem());\n\tif (!si || si->qsUrl.isEmpty()) {\n\t\treturn;\n\t}\n\n\tconst QStringList allowedSchemes = { QLatin1String(\"http\"), QLatin1String(\"https\") };\n\n\tconst auto url = QUrl(si->qsUrl);\n\tif (allowedSchemes.contains(url.scheme())) {\n\t\tQDesktopServices::openUrl(url);\n\t} else {\n\t\t// Inform user that the requested URL has been blocked\n\t\tQMessageBox msgBox;\n\t\tmsgBox.setText(QObject::tr(\"<b>Blocked URL scheme \\\"%1\\\"</b>\").arg(url.scheme()));\n\t\tmsgBox.setInformativeText(QObject::tr(\"The URL uses a scheme that has been blocked for security reasons.\"));\n\t\tmsgBox.setDetailedText(QObject::tr(\"Blocked URL: \\\"%1\\\"\").arg(url.toString()));\n\t\tmsgBox.setIcon(QMessageBox::Warning);\n\t\tmsgBox.exec();\n\t}\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,7 +1,21 @@\n void ConnectDialog::on_qaUrl_triggered() {\n-\tServerItem *si = static_cast<ServerItem *>(qtwServers->currentItem());\n-\tif (! si || si->qsUrl.isEmpty())\n+\tauto *si = static_cast< const ServerItem * >(qtwServers->currentItem());\n+\tif (!si || si->qsUrl.isEmpty()) {\n \t\treturn;\n+\t}\n \n-\tQDesktopServices::openUrl(QUrl(si->qsUrl));\n+\tconst QStringList allowedSchemes = { QLatin1String(\"http\"), QLatin1String(\"https\") };\n+\n+\tconst auto url = QUrl(si->qsUrl);\n+\tif (allowedSchemes.contains(url.scheme())) {\n+\t\tQDesktopServices::openUrl(url);\n+\t} else {\n+\t\t// Inform user that the requested URL has been blocked\n+\t\tQMessageBox msgBox;\n+\t\tmsgBox.setText(QObject::tr(\"<b>Blocked URL scheme \\\"%1\\\"</b>\").arg(url.scheme()));\n+\t\tmsgBox.setInformativeText(QObject::tr(\"The URL uses a scheme that has been blocked for security reasons.\"));\n+\t\tmsgBox.setDetailedText(QObject::tr(\"Blocked URL: \\\"%1\\\"\").arg(url.toString()));\n+\t\tmsgBox.setIcon(QMessageBox::Warning);\n+\t\tmsgBox.exec();\n+\t}\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tServerItem *si = static_cast<ServerItem *>(qtwServers->currentItem());",
                "\tif (! si || si->qsUrl.isEmpty())",
                "\tQDesktopServices::openUrl(QUrl(si->qsUrl));"
            ],
            "added_lines": [
                "\tauto *si = static_cast< const ServerItem * >(qtwServers->currentItem());",
                "\tif (!si || si->qsUrl.isEmpty()) {",
                "\t}",
                "\tconst QStringList allowedSchemes = { QLatin1String(\"http\"), QLatin1String(\"https\") };",
                "",
                "\tconst auto url = QUrl(si->qsUrl);",
                "\tif (allowedSchemes.contains(url.scheme())) {",
                "\t\tQDesktopServices::openUrl(url);",
                "\t} else {",
                "\t\t// Inform user that the requested URL has been blocked",
                "\t\tQMessageBox msgBox;",
                "\t\tmsgBox.setText(QObject::tr(\"<b>Blocked URL scheme \\\"%1\\\"</b>\").arg(url.scheme()));",
                "\t\tmsgBox.setInformativeText(QObject::tr(\"The URL uses a scheme that has been blocked for security reasons.\"));",
                "\t\tmsgBox.setDetailedText(QObject::tr(\"Blocked URL: \\\"%1\\\"\").arg(url.toString()));",
                "\t\tmsgBox.setIcon(QMessageBox::Warning);",
                "\t\tmsgBox.exec();",
                "\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-21300",
        "func_name": "git/threaded_has_dirs_only_path",
        "description": "Git is an open-source distributed revision control system. In affected versions of Git a specially crafted repository that contains symbolic links as well as files using a clean/smudge filter such as Git LFS, may cause just-checked out script to be executed while cloning onto a case-insensitive file system such as NTFS, HFS+ or APFS (i.e. the default file systems on Windows and macOS). Note that clean/smudge filters have to be configured for that. Git for Windows configures Git LFS by default, and is therefore vulnerable. The problem has been patched in the versions published on Tuesday, March 9th, 2021. As a workaound, if symbolic link support is disabled in Git (e.g. via `git config --global core.symlinks false`), the described attack won't work. Likewise, if no clean/smudge filters such as Git LFS are configured globally (i.e. _before_ cloning), the attack is foiled. As always, it is best to avoid cloning repositories from untrusted sources. The earliest impacted version is 2.14.2. The fix versions are: 2.30.1, 2.29.3, 2.28.1, 2.27.1, 2.26.3, 2.25.5, 2.24.4, 2.23.4, 2.22.5, 2.21.4, 2.20.5, 2.19.6, 2.18.5, 2.17.62.17.6.",
        "git_url": "https://github.com/git/git/commit/684dd4c2b414bcf648505e74498a608f28de4592",
        "commit_title": "checkout: fix bug that makes checkout follow symlinks in leading path",
        "commit_text": " Before checking out a file, we have to confirm that all of its leading components are real existing directories. And to reduce the number of lstat() calls in this process, we cache the last leading path known to contain only directories. However, when a path collision occurs (e.g. when checking out case-sensitive files in case-insensitive file systems), a cached path might have its file type changed on disk, leaving the cache on an invalid state. Normally, this doesn't bring any bad consequences as we usually check out files in index order, and therefore, by the time the cached path becomes outdated, we no longer need it anyway (because all files in that directory would have already been written).  But, there are some users of the checkout machinery that do not always follow the index order. In particular: checkout-index writes the paths in the same order that they appear on the CLI (or stdin); and the delayed checkout feature -- used when a long-running filter process replies with \"status=delayed\" -- postpones the checkout of some entries, thus modifying the checkout order.  When we have to check out an out-of-order entry and the lstat() cache is invalid (due to a previous path collision), checkout_entry() may end up using the invalid data and thrusting that the leading components are real directories when, in reality, they are not. In the best case scenario, where the directory was replaced by a regular file, the user will get an error: \"fatal: unable to create file 'foo/bar': Not a directory\". But if the directory was replaced by a symlink, checkout could actually end up following the symlink and writing the file at a wrong place, even outside the repository. Since delayed checkout is affected by this bug, it could be used by an attacker to write arbitrary files during the clone of a maliciously crafted repository.  Some candidate solutions considered were to disable the lstat() cache during unordered checkouts or sort the entries before passing them to the checkout machinery. But both ideas include some performance penalty and they don't future-proof the code against new unordered use cases.  Instead, we now manually reset the lstat cache whenever we successfully remove a directory. Note: We are not even checking whether the directory was the same as the lstat cache points to because we might face a scenario where the paths refer to the same location but differ due to case folding, precomposed UTF-8 issues, or the presence of `..` components in the path. Two regression tests, with case-collisions and utf8-collisions, are also added for both checkout-index and delayed checkout.  Note: to make the previously mentioned clone attack unfeasible, it would be sufficient to reset the lstat cache only after the remove_subtree() call inside checkout_entry(). This is the place where we would remove a directory whose path collides with the path of another entry that we are currently trying to check out (possibly a symlink). However, in the interest of a thorough fix that does not leave Git open to similar-but-not-identical attack vectors, we decided to intercept all `rmdir()` calls in one fell swoop.  This addresses CVE-2021-21300.  Co-authored-by: Johannes Schindelin <johannes.schindelin@gmx.de>",
        "func_before": "static int threaded_has_dirs_only_path(struct cache_def *cache, const char *name, int len, int prefix_len)\n{\n\treturn lstat_cache(cache, name, len,\n\t\t\t   FL_DIR|FL_FULLPATH, prefix_len) &\n\t\tFL_DIR;\n}",
        "func": "static int threaded_has_dirs_only_path(struct cache_def *cache, const char *name, int len, int prefix_len)\n{\n\t/*\n\t * Note: this function is used by the checkout machinery, which also\n\t * takes care to properly reset the cache when it performs an operation\n\t * that would leave the cache outdated. If this function starts caching\n\t * anything else besides FL_DIR, remember to also invalidate the cache\n\t * when creating or deleting paths that might be in the cache.\n\t */\n\treturn lstat_cache(cache, name, len,\n\t\t\t   FL_DIR|FL_FULLPATH, prefix_len) &\n\t\tFL_DIR;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,12 @@\n static int threaded_has_dirs_only_path(struct cache_def *cache, const char *name, int len, int prefix_len)\n {\n+\t/*\n+\t * Note: this function is used by the checkout machinery, which also\n+\t * takes care to properly reset the cache when it performs an operation\n+\t * that would leave the cache outdated. If this function starts caching\n+\t * anything else besides FL_DIR, remember to also invalidate the cache\n+\t * when creating or deleting paths that might be in the cache.\n+\t */\n \treturn lstat_cache(cache, name, len,\n \t\t\t   FL_DIR|FL_FULLPATH, prefix_len) &\n \t\tFL_DIR;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t/*",
                "\t * Note: this function is used by the checkout machinery, which also",
                "\t * takes care to properly reset the cache when it performs an operation",
                "\t * that would leave the cache outdated. If this function starts caching",
                "\t * anything else besides FL_DIR, remember to also invalidate the cache",
                "\t * when creating or deleting paths that might be in the cache.",
                "\t */"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-21300",
        "func_name": "git/mingw_rmdir",
        "description": "Git is an open-source distributed revision control system. In affected versions of Git a specially crafted repository that contains symbolic links as well as files using a clean/smudge filter such as Git LFS, may cause just-checked out script to be executed while cloning onto a case-insensitive file system such as NTFS, HFS+ or APFS (i.e. the default file systems on Windows and macOS). Note that clean/smudge filters have to be configured for that. Git for Windows configures Git LFS by default, and is therefore vulnerable. The problem has been patched in the versions published on Tuesday, March 9th, 2021. As a workaound, if symbolic link support is disabled in Git (e.g. via `git config --global core.symlinks false`), the described attack won't work. Likewise, if no clean/smudge filters such as Git LFS are configured globally (i.e. _before_ cloning), the attack is foiled. As always, it is best to avoid cloning repositories from untrusted sources. The earliest impacted version is 2.14.2. The fix versions are: 2.30.1, 2.29.3, 2.28.1, 2.27.1, 2.26.3, 2.25.5, 2.24.4, 2.23.4, 2.22.5, 2.21.4, 2.20.5, 2.19.6, 2.18.5, 2.17.62.17.6.",
        "git_url": "https://github.com/git/git/commit/684dd4c2b414bcf648505e74498a608f28de4592",
        "commit_title": "checkout: fix bug that makes checkout follow symlinks in leading path",
        "commit_text": " Before checking out a file, we have to confirm that all of its leading components are real existing directories. And to reduce the number of lstat() calls in this process, we cache the last leading path known to contain only directories. However, when a path collision occurs (e.g. when checking out case-sensitive files in case-insensitive file systems), a cached path might have its file type changed on disk, leaving the cache on an invalid state. Normally, this doesn't bring any bad consequences as we usually check out files in index order, and therefore, by the time the cached path becomes outdated, we no longer need it anyway (because all files in that directory would have already been written).  But, there are some users of the checkout machinery that do not always follow the index order. In particular: checkout-index writes the paths in the same order that they appear on the CLI (or stdin); and the delayed checkout feature -- used when a long-running filter process replies with \"status=delayed\" -- postpones the checkout of some entries, thus modifying the checkout order.  When we have to check out an out-of-order entry and the lstat() cache is invalid (due to a previous path collision), checkout_entry() may end up using the invalid data and thrusting that the leading components are real directories when, in reality, they are not. In the best case scenario, where the directory was replaced by a regular file, the user will get an error: \"fatal: unable to create file 'foo/bar': Not a directory\". But if the directory was replaced by a symlink, checkout could actually end up following the symlink and writing the file at a wrong place, even outside the repository. Since delayed checkout is affected by this bug, it could be used by an attacker to write arbitrary files during the clone of a maliciously crafted repository.  Some candidate solutions considered were to disable the lstat() cache during unordered checkouts or sort the entries before passing them to the checkout machinery. But both ideas include some performance penalty and they don't future-proof the code against new unordered use cases.  Instead, we now manually reset the lstat cache whenever we successfully remove a directory. Note: We are not even checking whether the directory was the same as the lstat cache points to because we might face a scenario where the paths refer to the same location but differ due to case folding, precomposed UTF-8 issues, or the presence of `..` components in the path. Two regression tests, with case-collisions and utf8-collisions, are also added for both checkout-index and delayed checkout.  Note: to make the previously mentioned clone attack unfeasible, it would be sufficient to reset the lstat cache only after the remove_subtree() call inside checkout_entry(). This is the place where we would remove a directory whose path collides with the path of another entry that we are currently trying to check out (possibly a symlink). However, in the interest of a thorough fix that does not leave Git open to similar-but-not-identical attack vectors, we decided to intercept all `rmdir()` calls in one fell swoop.  This addresses CVE-2021-21300.  Co-authored-by: Johannes Schindelin <johannes.schindelin@gmx.de>",
        "func_before": "int mingw_rmdir(const char *pathname)\n{\n\tint ret, tries = 0;\n\twchar_t wpathname[MAX_PATH];\n\tif (xutftowcs_path(wpathname, pathname) < 0)\n\t\treturn -1;\n\n\twhile ((ret = _wrmdir(wpathname)) == -1 && tries < ARRAY_SIZE(delay)) {\n\t\tif (!is_file_in_use_error(GetLastError()))\n\t\t\terrno = err_win_to_posix(GetLastError());\n\t\tif (errno != EACCES)\n\t\t\tbreak;\n\t\tif (!is_dir_empty(wpathname)) {\n\t\t\terrno = ENOTEMPTY;\n\t\t\tbreak;\n\t\t}\n\t\t/*\n\t\t * We assume that some other process had the source or\n\t\t * destination file open at the wrong moment and retry.\n\t\t * In order to give the other process a higher chance to\n\t\t * complete its operation, we give up our time slice now.\n\t\t * If we have to retry again, we do sleep a bit.\n\t\t */\n\t\tSleep(delay[tries]);\n\t\ttries++;\n\t}\n\twhile (ret == -1 && errno == EACCES && is_file_in_use_error(GetLastError()) &&\n\t       ask_yes_no_if_possible(\"Deletion of directory '%s' failed. \"\n\t\t\t\"Should I try again?\", pathname))\n\t       ret = _wrmdir(wpathname);\n\treturn ret;\n}",
        "func": "int mingw_rmdir(const char *pathname)\n{\n\tint ret, tries = 0;\n\twchar_t wpathname[MAX_PATH];\n\tif (xutftowcs_path(wpathname, pathname) < 0)\n\t\treturn -1;\n\n\twhile ((ret = _wrmdir(wpathname)) == -1 && tries < ARRAY_SIZE(delay)) {\n\t\tif (!is_file_in_use_error(GetLastError()))\n\t\t\terrno = err_win_to_posix(GetLastError());\n\t\tif (errno != EACCES)\n\t\t\tbreak;\n\t\tif (!is_dir_empty(wpathname)) {\n\t\t\terrno = ENOTEMPTY;\n\t\t\tbreak;\n\t\t}\n\t\t/*\n\t\t * We assume that some other process had the source or\n\t\t * destination file open at the wrong moment and retry.\n\t\t * In order to give the other process a higher chance to\n\t\t * complete its operation, we give up our time slice now.\n\t\t * If we have to retry again, we do sleep a bit.\n\t\t */\n\t\tSleep(delay[tries]);\n\t\ttries++;\n\t}\n\twhile (ret == -1 && errno == EACCES && is_file_in_use_error(GetLastError()) &&\n\t       ask_yes_no_if_possible(\"Deletion of directory '%s' failed. \"\n\t\t\t\"Should I try again?\", pathname))\n\t       ret = _wrmdir(wpathname);\n\tif (!ret)\n\t\tinvalidate_lstat_cache();\n\treturn ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -28,5 +28,7 @@\n \t       ask_yes_no_if_possible(\"Deletion of directory '%s' failed. \"\n \t\t\t\"Should I try again?\", pathname))\n \t       ret = _wrmdir(wpathname);\n+\tif (!ret)\n+\t\tinvalidate_lstat_cache();\n \treturn ret;\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tif (!ret)",
                "\t\tinvalidate_lstat_cache();"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-28153",
        "func_name": "GNOME/glib/handle_overwrite_open",
        "description": "An issue was discovered in GNOME GLib before 2.66.8. When g_file_replace() is used with G_FILE_CREATE_REPLACE_DESTINATION to replace a path that is a dangling symlink, it incorrectly also creates the target of the symlink as an empty file, which could conceivably have security relevance if the symlink is attacker-controlled. (If the path is a symlink to a file that already exists, then the contents of that file correctly remain unchanged.)",
        "git_url": "https://github.com/GNOME/glib/commit/87e19535fe2a33b880883128370fe49aa9f906b1",
        "commit_title": "glocalfileoutputstream: Fix CREATE_REPLACE_DESTINATION with symlinks",
        "commit_text": " The `G_FILE_CREATE_REPLACE_DESTINATION` flag is equivalent to unlinking the destination file and re-creating it from scratch. That did previously work, but in the process the code would call `open(O_CREAT)` on the file. If the file was a dangling symlink, this would create the destination file (empty). Thats not an intended side-effect, and has security implications if the symlink is controlled by a lower-privileged process.  Fix that by not opening the destination file if its a symlink, and adjusting the rest of the code to cope with  - the fact that `fd == -1` is not an error iff `is_symlink` is true,  - and that `original_stat` will contain the `lstat()` results for the    symlink now, rather than the `stat()` results for its target (again,    iff `is_symlink` is true).  This means that the target of the dangling symlink is no longer created, which was the bug. The symlink itself continues to be replaced (as before) with the new file  this is the intended behaviour of `g_file_replace()`.  The behaviour for non-symlink cases, or cases where the symlink was not dangling, should be unchanged.  Includes a unit test.  ",
        "func_before": "static int\nhandle_overwrite_open (const char    *filename,\n\t\t       gboolean       readable,\n\t\t       const char    *etag,\n\t\t       gboolean       create_backup,\n\t\t       char         **temp_filename,\n\t\t       GFileCreateFlags flags,\n                       GFileInfo       *reference_info,\n\t\t       GCancellable  *cancellable,\n\t\t       GError       **error)\n{\n  int fd = -1;\n  GLocalFileStat original_stat;\n  char *current_etag;\n  gboolean is_symlink;\n  int open_flags;\n  int res;\n  int mode;\n  int errsv;\n  gboolean replace_destination_set = (flags & G_FILE_CREATE_REPLACE_DESTINATION);\n\n  mode = mode_from_flags_or_info (flags, reference_info);\n\n  /* We only need read access to the original file if we are creating a backup.\n   * We also add O_CREAT to avoid a race if the file was just removed */\n  if (create_backup || readable)\n    open_flags = O_RDWR | O_CREAT | O_BINARY;\n  else\n    open_flags = O_WRONLY | O_CREAT | O_BINARY;\n  \n  /* Some systems have O_NOFOLLOW, which lets us avoid some races\n   * when finding out if the file we opened was a symlink */\n#ifdef O_NOFOLLOW\n  is_symlink = FALSE;\n  fd = g_open (filename, open_flags | O_NOFOLLOW, mode);\n  errsv = errno;\n#if defined(__FreeBSD__) || defined(__FreeBSD_kernel__) || defined(__DragonFly__)\n  if (fd == -1 && errsv == EMLINK)\n#elif defined(__NetBSD__)\n  if (fd == -1 && errsv == EFTYPE)\n#else\n  if (fd == -1 && errsv == ELOOP)\n#endif\n    {\n      /* Could be a symlink, or it could be a regular ELOOP error,\n       * but then the next open will fail too. */\n      is_symlink = TRUE;\n      fd = g_open (filename, open_flags, mode);\n    }\n#else\n  fd = g_open (filename, open_flags, mode);\n  errsv = errno;\n  /* This is racy, but we do it as soon as possible to minimize the race */\n  is_symlink = g_file_test (filename, G_FILE_TEST_IS_SYMLINK);\n#endif\n\n  if (fd == -1)\n    {\n      char *display_name = g_filename_display_name (filename);\n      g_set_error (error, G_IO_ERROR,\n\t\t   g_io_error_from_errno (errsv),\n\t\t   _(\"Error opening file %s: %s\"),\n\t\t   display_name, g_strerror (errsv));\n      g_free (display_name);\n      return -1;\n    }\n\n  res = g_local_file_fstat (fd,\n                            G_LOCAL_FILE_STAT_FIELD_TYPE |\n                            G_LOCAL_FILE_STAT_FIELD_MODE |\n                            G_LOCAL_FILE_STAT_FIELD_UID |\n                            G_LOCAL_FILE_STAT_FIELD_GID |\n                            G_LOCAL_FILE_STAT_FIELD_MTIME |\n                            G_LOCAL_FILE_STAT_FIELD_NLINK,\n                            G_LOCAL_FILE_STAT_FIELD_ALL, &original_stat);\n  errsv = errno;\n\n  if (res != 0)\n    {\n      char *display_name = g_filename_display_name (filename);\n      g_set_error (error, G_IO_ERROR,\n\t\t   g_io_error_from_errno (errsv),\n\t\t   _(\"Error when getting information for file %s: %s\"),\n\t\t   display_name, g_strerror (errsv));\n      g_free (display_name);\n      goto err_out;\n    }\n  \n  /* not a regular file */\n  if (!S_ISREG (_g_stat_mode (&original_stat)))\n    {\n      if (S_ISDIR (_g_stat_mode (&original_stat)))\n\tg_set_error_literal (error,\n                             G_IO_ERROR,\n                             G_IO_ERROR_IS_DIRECTORY,\n                             _(\"Target file is a directory\"));\n      else\n\tg_set_error_literal (error,\n                             G_IO_ERROR,\n                             G_IO_ERROR_NOT_REGULAR_FILE,\n                             _(\"Target file is not a regular file\"));\n      goto err_out;\n    }\n  \n  if (etag != NULL)\n    {\n      current_etag = _g_local_file_info_create_etag (&original_stat);\n      if (strcmp (etag, current_etag) != 0)\n\t{\n\t  g_set_error_literal (error,\n                               G_IO_ERROR,\n                               G_IO_ERROR_WRONG_ETAG,\n                               _(\"The file was externally modified\"));\n\t  g_free (current_etag);\n\t  goto err_out;\n\t}\n      g_free (current_etag);\n    }\n\n  /* We use two backup strategies.\n   * The first one (which is faster) consist in saving to a\n   * tmp file then rename the original file to the backup and the\n   * tmp file to the original name. This is fast but doesn't work\n   * when the file is a link (hard or symbolic) or when we can't\n   * write to the current dir or can't set the permissions on the\n   * new file. \n   * The second strategy consist simply in copying the old file\n   * to a backup file and rewrite the contents of the file.\n   */\n  \n  if (replace_destination_set ||\n      (!(_g_stat_nlink (&original_stat) > 1) && !is_symlink))\n    {\n      char *dirname, *tmp_filename;\n      int tmpfd;\n      \n      dirname = g_path_get_dirname (filename);\n      tmp_filename = g_build_filename (dirname, \".goutputstream-XXXXXX\", NULL);\n      g_free (dirname);\n\n      tmpfd = g_mkstemp_full (tmp_filename, (readable ? O_RDWR : O_WRONLY) | O_BINARY, mode);\n      if (tmpfd == -1)\n\t{\n\t  g_free (tmp_filename);\n\t  goto fallback_strategy;\n\t}\n      \n      /* try to keep permissions (unless replacing) */\n\n      if (!replace_destination_set &&\n\t   (\n#ifdef HAVE_FCHOWN\n\t    fchown (tmpfd, _g_stat_uid (&original_stat), _g_stat_gid (&original_stat)) == -1 ||\n#endif\n#ifdef HAVE_FCHMOD\n\t    fchmod (tmpfd, _g_stat_mode (&original_stat) & ~S_IFMT) == -1 ||\n#endif\n\t    0\n\t    )\n\t  )\n\t{\n          GLocalFileStat tmp_statbuf;\n          int tres;\n\n          tres = g_local_file_fstat (tmpfd,\n                                     G_LOCAL_FILE_STAT_FIELD_TYPE |\n                                     G_LOCAL_FILE_STAT_FIELD_MODE |\n                                     G_LOCAL_FILE_STAT_FIELD_UID |\n                                     G_LOCAL_FILE_STAT_FIELD_GID,\n                                     G_LOCAL_FILE_STAT_FIELD_ALL, &tmp_statbuf);\n\n\t  /* Check that we really needed to change something */\n\t  if (tres != 0 ||\n\t      _g_stat_uid (&original_stat) != _g_stat_uid (&tmp_statbuf) ||\n\t      _g_stat_gid (&original_stat) != _g_stat_gid (&tmp_statbuf) ||\n\t      _g_stat_mode (&original_stat) != _g_stat_mode (&tmp_statbuf))\n\t    {\n\t      g_close (tmpfd, NULL);\n\t      g_unlink (tmp_filename);\n\t      g_free (tmp_filename);\n\t      goto fallback_strategy;\n\t    }\n\t}\n\n      g_close (fd, NULL);\n      *temp_filename = tmp_filename;\n      return tmpfd;\n    }\n\n fallback_strategy:\n\n  if (create_backup)\n    {\n#if defined(HAVE_FCHOWN) && defined(HAVE_FCHMOD)\n      GLocalFileStat tmp_statbuf;\n#endif\n      char *backup_filename;\n      int bfd;\n      \n      backup_filename = create_backup_filename (filename);\n\n      if (g_unlink (backup_filename) == -1 && errno != ENOENT)\n\t{\n\t  g_set_error_literal (error,\n                               G_IO_ERROR,\n                               G_IO_ERROR_CANT_CREATE_BACKUP,\n                               _(\"Backup file creation failed\"));\n\t  g_free (backup_filename);\n\t  goto err_out;\n\t}\n\n      bfd = g_open (backup_filename,\n\t\t    O_WRONLY | O_CREAT | O_EXCL | O_BINARY,\n\t\t    _g_stat_mode (&original_stat) & 0777);\n\n      if (bfd == -1)\n\t{\n\t  g_set_error_literal (error,\n                               G_IO_ERROR,\n                               G_IO_ERROR_CANT_CREATE_BACKUP,\n                               _(\"Backup file creation failed\"));\n\t  g_free (backup_filename);\n\t  goto err_out;\n\t}\n\n      /* If needed, Try to set the group of the backup same as the\n       * original file. If this fails, set the protection\n       * bits for the group same as the protection bits for\n       * others. */\n#if defined(HAVE_FCHOWN) && defined(HAVE_FCHMOD)\n      if (g_local_file_fstat (bfd, G_LOCAL_FILE_STAT_FIELD_GID, G_LOCAL_FILE_STAT_FIELD_ALL, &tmp_statbuf) != 0)\n\t{\n\t  g_set_error_literal (error,\n                               G_IO_ERROR,\n                               G_IO_ERROR_CANT_CREATE_BACKUP,\n                               _(\"Backup file creation failed\"));\n\t  g_unlink (backup_filename);\n\t  g_close (bfd, NULL);\n\t  g_free (backup_filename);\n\t  goto err_out;\n\t}\n      \n      if ((_g_stat_gid (&original_stat) != _g_stat_gid (&tmp_statbuf))  &&\n\t  fchown (bfd, (uid_t) -1, _g_stat_gid (&original_stat)) != 0)\n\t{\n\t  if (fchmod (bfd,\n\t\t      (_g_stat_mode (&original_stat) & 0707) |\n\t\t      ((_g_stat_mode (&original_stat) & 07) << 3)) != 0)\n\t    {\n\t      g_set_error_literal (error,\n                                   G_IO_ERROR,\n                                   G_IO_ERROR_CANT_CREATE_BACKUP,\n                                   _(\"Backup file creation failed\"));\n\t      g_unlink (backup_filename);\n\t      g_close (bfd, NULL);\n\t      g_free (backup_filename);\n\t      goto err_out;\n\t    }\n\t}\n#endif\n\n      if (!copy_file_data (fd, bfd, NULL))\n\t{\n\t  g_set_error_literal (error,\n                               G_IO_ERROR,\n                               G_IO_ERROR_CANT_CREATE_BACKUP,\n                               _(\"Backup file creation failed\"));\n\t  g_unlink (backup_filename);\n          g_close (bfd, NULL);\n\t  g_free (backup_filename);\n\t  \n\t  goto err_out;\n\t}\n      \n      g_close (bfd, NULL);\n      g_free (backup_filename);\n\n      /* Seek back to the start of the file after the backup copy */\n      if (lseek (fd, 0, SEEK_SET) == -1)\n\t{\n          int errsv = errno;\n\n\t  g_set_error (error, G_IO_ERROR,\n\t\t       g_io_error_from_errno (errsv),\n\t\t       _(\"Error seeking in file: %s\"),\n\t\t       g_strerror (errsv));\n\t  goto err_out;\n\t}\n    }\n\n  if (replace_destination_set)\n    {\n      g_close (fd, NULL);\n      \n      if (g_unlink (filename) != 0)\n\t{\n\t  int errsv = errno;\n\t  \n\t  g_set_error (error, G_IO_ERROR,\n\t\t       g_io_error_from_errno (errsv),\n\t\t       _(\"Error removing old file: %s\"),\n\t\t       g_strerror (errsv));\n\t  goto err_out2;\n\t}\n\n      if (readable)\n\topen_flags = O_RDWR | O_CREAT | O_BINARY;\n      else\n\topen_flags = O_WRONLY | O_CREAT | O_BINARY;\n      fd = g_open (filename, open_flags, mode);\n      if (fd == -1)\n\t{\n\t  int errsv = errno;\n\t  char *display_name = g_filename_display_name (filename);\n\t  g_set_error (error, G_IO_ERROR,\n\t\t       g_io_error_from_errno (errsv),\n\t\t       _(\"Error opening file %s: %s\"),\n\t\t       display_name, g_strerror (errsv));\n\t  g_free (display_name);\n\t  goto err_out2;\n\t}\n    }\n  else\n    {\n      /* Truncate the file at the start */\n#ifdef G_OS_WIN32\n      if (g_win32_ftruncate (fd, 0) == -1)\n#else\n\tif (ftruncate (fd, 0) == -1)\n#endif\n\t  {\n\t    int errsv = errno;\n\t    \n\t    g_set_error (error, G_IO_ERROR,\n\t\t\t g_io_error_from_errno (errsv),\n\t\t\t _(\"Error truncating file: %s\"),\n\t\t\t g_strerror (errsv));\n\t    goto err_out;\n\t  }\n    }\n    \n  return fd;\n\n err_out:\n  g_close (fd, NULL);\n err_out2:\n  return -1;\n}",
        "func": "static int\nhandle_overwrite_open (const char    *filename,\n\t\t       gboolean       readable,\n\t\t       const char    *etag,\n\t\t       gboolean       create_backup,\n\t\t       char         **temp_filename,\n\t\t       GFileCreateFlags flags,\n                       GFileInfo       *reference_info,\n\t\t       GCancellable  *cancellable,\n\t\t       GError       **error)\n{\n  int fd = -1;\n  GLocalFileStat original_stat;\n  char *current_etag;\n  gboolean is_symlink;\n  int open_flags;\n  int res;\n  int mode;\n  int errsv;\n  gboolean replace_destination_set = (flags & G_FILE_CREATE_REPLACE_DESTINATION);\n\n  mode = mode_from_flags_or_info (flags, reference_info);\n\n  /* We only need read access to the original file if we are creating a backup.\n   * We also add O_CREAT to avoid a race if the file was just removed */\n  if (create_backup || readable)\n    open_flags = O_RDWR | O_CREAT | O_BINARY;\n  else\n    open_flags = O_WRONLY | O_CREAT | O_BINARY;\n  \n  /* Some systems have O_NOFOLLOW, which lets us avoid some races\n   * when finding out if the file we opened was a symlink */\n#ifdef O_NOFOLLOW\n  is_symlink = FALSE;\n  fd = g_open (filename, open_flags | O_NOFOLLOW, mode);\n  errsv = errno;\n#if defined(__FreeBSD__) || defined(__FreeBSD_kernel__) || defined(__DragonFly__)\n  if (fd == -1 && errsv == EMLINK)\n#elif defined(__NetBSD__)\n  if (fd == -1 && errsv == EFTYPE)\n#else\n  if (fd == -1 && errsv == ELOOP)\n#endif\n    {\n      /* Could be a symlink, or it could be a regular ELOOP error,\n       * but then the next open will fail too. */\n      is_symlink = TRUE;\n      if (!replace_destination_set)\n        fd = g_open (filename, open_flags, mode);\n    }\n#else  /* if !O_NOFOLLOW */\n  /* This is racy, but we do it as soon as possible to minimize the race */\n  is_symlink = g_file_test (filename, G_FILE_TEST_IS_SYMLINK);\n\n  if (!is_symlink || !replace_destination_set)\n    {\n      fd = g_open (filename, open_flags, mode);\n      errsv = errno;\n    }\n#endif\n\n  if (fd == -1 &&\n      (!is_symlink || !replace_destination_set))\n    {\n      char *display_name = g_filename_display_name (filename);\n      g_set_error (error, G_IO_ERROR,\n\t\t   g_io_error_from_errno (errsv),\n\t\t   _(\"Error opening file %s: %s\"),\n\t\t   display_name, g_strerror (errsv));\n      g_free (display_name);\n      return -1;\n    }\n\n  if (!is_symlink)\n    {\n      res = g_local_file_fstat (fd,\n                                G_LOCAL_FILE_STAT_FIELD_TYPE |\n                                G_LOCAL_FILE_STAT_FIELD_MODE |\n                                G_LOCAL_FILE_STAT_FIELD_UID |\n                                G_LOCAL_FILE_STAT_FIELD_GID |\n                                G_LOCAL_FILE_STAT_FIELD_MTIME |\n                                G_LOCAL_FILE_STAT_FIELD_NLINK,\n                                G_LOCAL_FILE_STAT_FIELD_ALL, &original_stat);\n      errsv = errno;\n    }\n  else\n    {\n      res = g_local_file_lstat (filename,\n                                G_LOCAL_FILE_STAT_FIELD_TYPE |\n                                G_LOCAL_FILE_STAT_FIELD_MODE |\n                                G_LOCAL_FILE_STAT_FIELD_UID |\n                                G_LOCAL_FILE_STAT_FIELD_GID |\n                                G_LOCAL_FILE_STAT_FIELD_MTIME |\n                                G_LOCAL_FILE_STAT_FIELD_NLINK,\n                                G_LOCAL_FILE_STAT_FIELD_ALL, &original_stat);\n      errsv = errno;\n    }\n\n  if (res != 0)\n    {\n      char *display_name = g_filename_display_name (filename);\n      g_set_error (error, G_IO_ERROR,\n\t\t   g_io_error_from_errno (errsv),\n\t\t   _(\"Error when getting information for file %s: %s\"),\n\t\t   display_name, g_strerror (errsv));\n      g_free (display_name);\n      goto err_out;\n    }\n  \n  /* not a regular file */\n  if (!S_ISREG (_g_stat_mode (&original_stat)))\n    {\n      if (S_ISDIR (_g_stat_mode (&original_stat)))\n        {\n          g_set_error_literal (error,\n                               G_IO_ERROR,\n                               G_IO_ERROR_IS_DIRECTORY,\n                               _(\"Target file is a directory\"));\n          goto err_out;\n        }\n      else if (!is_symlink ||\n#ifdef S_ISLNK\n               !S_ISLNK (_g_stat_mode (&original_stat))\n#else\n               FALSE\n#endif\n               )\n        {\n          g_set_error_literal (error,\n                             G_IO_ERROR,\n                             G_IO_ERROR_NOT_REGULAR_FILE,\n                             _(\"Target file is not a regular file\"));\n          goto err_out;\n        }\n    }\n  \n  if (etag != NULL)\n    {\n      current_etag = _g_local_file_info_create_etag (&original_stat);\n      if (strcmp (etag, current_etag) != 0)\n\t{\n\t  g_set_error_literal (error,\n                               G_IO_ERROR,\n                               G_IO_ERROR_WRONG_ETAG,\n                               _(\"The file was externally modified\"));\n\t  g_free (current_etag);\n\t  goto err_out;\n\t}\n      g_free (current_etag);\n    }\n\n  /* We use two backup strategies.\n   * The first one (which is faster) consist in saving to a\n   * tmp file then rename the original file to the backup and the\n   * tmp file to the original name. This is fast but doesn't work\n   * when the file is a link (hard or symbolic) or when we can't\n   * write to the current dir or can't set the permissions on the\n   * new file. \n   * The second strategy consist simply in copying the old file\n   * to a backup file and rewrite the contents of the file.\n   */\n  \n  if (replace_destination_set ||\n      (!(_g_stat_nlink (&original_stat) > 1) && !is_symlink))\n    {\n      char *dirname, *tmp_filename;\n      int tmpfd;\n      \n      dirname = g_path_get_dirname (filename);\n      tmp_filename = g_build_filename (dirname, \".goutputstream-XXXXXX\", NULL);\n      g_free (dirname);\n\n      tmpfd = g_mkstemp_full (tmp_filename, (readable ? O_RDWR : O_WRONLY) | O_BINARY, mode);\n      if (tmpfd == -1)\n\t{\n\t  g_free (tmp_filename);\n\t  goto fallback_strategy;\n\t}\n      \n      /* try to keep permissions (unless replacing) */\n\n      if (!replace_destination_set &&\n\t   (\n#ifdef HAVE_FCHOWN\n\t    fchown (tmpfd, _g_stat_uid (&original_stat), _g_stat_gid (&original_stat)) == -1 ||\n#endif\n#ifdef HAVE_FCHMOD\n\t    fchmod (tmpfd, _g_stat_mode (&original_stat) & ~S_IFMT) == -1 ||\n#endif\n\t    0\n\t    )\n\t  )\n\t{\n          GLocalFileStat tmp_statbuf;\n          int tres;\n\n          tres = g_local_file_fstat (tmpfd,\n                                     G_LOCAL_FILE_STAT_FIELD_TYPE |\n                                     G_LOCAL_FILE_STAT_FIELD_MODE |\n                                     G_LOCAL_FILE_STAT_FIELD_UID |\n                                     G_LOCAL_FILE_STAT_FIELD_GID,\n                                     G_LOCAL_FILE_STAT_FIELD_ALL, &tmp_statbuf);\n\n\t  /* Check that we really needed to change something */\n\t  if (tres != 0 ||\n\t      _g_stat_uid (&original_stat) != _g_stat_uid (&tmp_statbuf) ||\n\t      _g_stat_gid (&original_stat) != _g_stat_gid (&tmp_statbuf) ||\n\t      _g_stat_mode (&original_stat) != _g_stat_mode (&tmp_statbuf))\n\t    {\n\t      g_close (tmpfd, NULL);\n\t      g_unlink (tmp_filename);\n\t      g_free (tmp_filename);\n\t      goto fallback_strategy;\n\t    }\n\t}\n\n      if (fd >= 0)\n        g_close (fd, NULL);\n      *temp_filename = tmp_filename;\n      return tmpfd;\n    }\n\n fallback_strategy:\n\n  if (create_backup)\n    {\n#if defined(HAVE_FCHOWN) && defined(HAVE_FCHMOD)\n      GLocalFileStat tmp_statbuf;\n#endif\n      char *backup_filename;\n      int bfd;\n      \n      backup_filename = create_backup_filename (filename);\n\n      if (g_unlink (backup_filename) == -1 && errno != ENOENT)\n\t{\n\t  g_set_error_literal (error,\n                               G_IO_ERROR,\n                               G_IO_ERROR_CANT_CREATE_BACKUP,\n                               _(\"Backup file creation failed\"));\n\t  g_free (backup_filename);\n\t  goto err_out;\n\t}\n\n      bfd = g_open (backup_filename,\n\t\t    O_WRONLY | O_CREAT | O_EXCL | O_BINARY,\n\t\t    _g_stat_mode (&original_stat) & 0777);\n\n      if (bfd == -1)\n\t{\n\t  g_set_error_literal (error,\n                               G_IO_ERROR,\n                               G_IO_ERROR_CANT_CREATE_BACKUP,\n                               _(\"Backup file creation failed\"));\n\t  g_free (backup_filename);\n\t  goto err_out;\n\t}\n\n      /* If needed, Try to set the group of the backup same as the\n       * original file. If this fails, set the protection\n       * bits for the group same as the protection bits for\n       * others. */\n#if defined(HAVE_FCHOWN) && defined(HAVE_FCHMOD)\n      if (g_local_file_fstat (bfd, G_LOCAL_FILE_STAT_FIELD_GID, G_LOCAL_FILE_STAT_FIELD_ALL, &tmp_statbuf) != 0)\n\t{\n\t  g_set_error_literal (error,\n                               G_IO_ERROR,\n                               G_IO_ERROR_CANT_CREATE_BACKUP,\n                               _(\"Backup file creation failed\"));\n\t  g_unlink (backup_filename);\n\t  g_close (bfd, NULL);\n\t  g_free (backup_filename);\n\t  goto err_out;\n\t}\n      \n      if ((_g_stat_gid (&original_stat) != _g_stat_gid (&tmp_statbuf))  &&\n\t  fchown (bfd, (uid_t) -1, _g_stat_gid (&original_stat)) != 0)\n\t{\n\t  if (fchmod (bfd,\n\t\t      (_g_stat_mode (&original_stat) & 0707) |\n\t\t      ((_g_stat_mode (&original_stat) & 07) << 3)) != 0)\n\t    {\n\t      g_set_error_literal (error,\n                                   G_IO_ERROR,\n                                   G_IO_ERROR_CANT_CREATE_BACKUP,\n                                   _(\"Backup file creation failed\"));\n\t      g_unlink (backup_filename);\n\t      g_close (bfd, NULL);\n\t      g_free (backup_filename);\n\t      goto err_out;\n\t    }\n\t}\n#endif\n\n      if (!copy_file_data (fd, bfd, NULL))\n\t{\n\t  g_set_error_literal (error,\n                               G_IO_ERROR,\n                               G_IO_ERROR_CANT_CREATE_BACKUP,\n                               _(\"Backup file creation failed\"));\n\t  g_unlink (backup_filename);\n          g_close (bfd, NULL);\n\t  g_free (backup_filename);\n\t  \n\t  goto err_out;\n\t}\n      \n      g_close (bfd, NULL);\n      g_free (backup_filename);\n\n      /* Seek back to the start of the file after the backup copy */\n      if (lseek (fd, 0, SEEK_SET) == -1)\n\t{\n          int errsv = errno;\n\n\t  g_set_error (error, G_IO_ERROR,\n\t\t       g_io_error_from_errno (errsv),\n\t\t       _(\"Error seeking in file: %s\"),\n\t\t       g_strerror (errsv));\n\t  goto err_out;\n\t}\n    }\n\n  if (replace_destination_set)\n    {\n      g_close (fd, NULL);\n      \n      if (g_unlink (filename) != 0)\n\t{\n\t  int errsv = errno;\n\t  \n\t  g_set_error (error, G_IO_ERROR,\n\t\t       g_io_error_from_errno (errsv),\n\t\t       _(\"Error removing old file: %s\"),\n\t\t       g_strerror (errsv));\n\t  goto err_out2;\n\t}\n\n      if (readable)\n\topen_flags = O_RDWR | O_CREAT | O_BINARY;\n      else\n\topen_flags = O_WRONLY | O_CREAT | O_BINARY;\n      fd = g_open (filename, open_flags, mode);\n      if (fd == -1)\n\t{\n\t  int errsv = errno;\n\t  char *display_name = g_filename_display_name (filename);\n\t  g_set_error (error, G_IO_ERROR,\n\t\t       g_io_error_from_errno (errsv),\n\t\t       _(\"Error opening file %s: %s\"),\n\t\t       display_name, g_strerror (errsv));\n\t  g_free (display_name);\n\t  goto err_out2;\n\t}\n    }\n  else\n    {\n      /* Truncate the file at the start */\n#ifdef G_OS_WIN32\n      if (g_win32_ftruncate (fd, 0) == -1)\n#else\n\tif (ftruncate (fd, 0) == -1)\n#endif\n\t  {\n\t    int errsv = errno;\n\t    \n\t    g_set_error (error, G_IO_ERROR,\n\t\t\t g_io_error_from_errno (errsv),\n\t\t\t _(\"Error truncating file: %s\"),\n\t\t\t g_strerror (errsv));\n\t    goto err_out;\n\t  }\n    }\n    \n  return fd;\n\n err_out:\n  g_close (fd, NULL);\n err_out2:\n  return -1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -45,16 +45,22 @@\n       /* Could be a symlink, or it could be a regular ELOOP error,\n        * but then the next open will fail too. */\n       is_symlink = TRUE;\n-      fd = g_open (filename, open_flags, mode);\n-    }\n-#else\n-  fd = g_open (filename, open_flags, mode);\n-  errsv = errno;\n+      if (!replace_destination_set)\n+        fd = g_open (filename, open_flags, mode);\n+    }\n+#else  /* if !O_NOFOLLOW */\n   /* This is racy, but we do it as soon as possible to minimize the race */\n   is_symlink = g_file_test (filename, G_FILE_TEST_IS_SYMLINK);\n-#endif\n-\n-  if (fd == -1)\n+\n+  if (!is_symlink || !replace_destination_set)\n+    {\n+      fd = g_open (filename, open_flags, mode);\n+      errsv = errno;\n+    }\n+#endif\n+\n+  if (fd == -1 &&\n+      (!is_symlink || !replace_destination_set))\n     {\n       char *display_name = g_filename_display_name (filename);\n       g_set_error (error, G_IO_ERROR,\n@@ -65,15 +71,30 @@\n       return -1;\n     }\n \n-  res = g_local_file_fstat (fd,\n-                            G_LOCAL_FILE_STAT_FIELD_TYPE |\n-                            G_LOCAL_FILE_STAT_FIELD_MODE |\n-                            G_LOCAL_FILE_STAT_FIELD_UID |\n-                            G_LOCAL_FILE_STAT_FIELD_GID |\n-                            G_LOCAL_FILE_STAT_FIELD_MTIME |\n-                            G_LOCAL_FILE_STAT_FIELD_NLINK,\n-                            G_LOCAL_FILE_STAT_FIELD_ALL, &original_stat);\n-  errsv = errno;\n+  if (!is_symlink)\n+    {\n+      res = g_local_file_fstat (fd,\n+                                G_LOCAL_FILE_STAT_FIELD_TYPE |\n+                                G_LOCAL_FILE_STAT_FIELD_MODE |\n+                                G_LOCAL_FILE_STAT_FIELD_UID |\n+                                G_LOCAL_FILE_STAT_FIELD_GID |\n+                                G_LOCAL_FILE_STAT_FIELD_MTIME |\n+                                G_LOCAL_FILE_STAT_FIELD_NLINK,\n+                                G_LOCAL_FILE_STAT_FIELD_ALL, &original_stat);\n+      errsv = errno;\n+    }\n+  else\n+    {\n+      res = g_local_file_lstat (filename,\n+                                G_LOCAL_FILE_STAT_FIELD_TYPE |\n+                                G_LOCAL_FILE_STAT_FIELD_MODE |\n+                                G_LOCAL_FILE_STAT_FIELD_UID |\n+                                G_LOCAL_FILE_STAT_FIELD_GID |\n+                                G_LOCAL_FILE_STAT_FIELD_MTIME |\n+                                G_LOCAL_FILE_STAT_FIELD_NLINK,\n+                                G_LOCAL_FILE_STAT_FIELD_ALL, &original_stat);\n+      errsv = errno;\n+    }\n \n   if (res != 0)\n     {\n@@ -90,16 +111,27 @@\n   if (!S_ISREG (_g_stat_mode (&original_stat)))\n     {\n       if (S_ISDIR (_g_stat_mode (&original_stat)))\n-\tg_set_error_literal (error,\n-                             G_IO_ERROR,\n-                             G_IO_ERROR_IS_DIRECTORY,\n-                             _(\"Target file is a directory\"));\n-      else\n-\tg_set_error_literal (error,\n+        {\n+          g_set_error_literal (error,\n+                               G_IO_ERROR,\n+                               G_IO_ERROR_IS_DIRECTORY,\n+                               _(\"Target file is a directory\"));\n+          goto err_out;\n+        }\n+      else if (!is_symlink ||\n+#ifdef S_ISLNK\n+               !S_ISLNK (_g_stat_mode (&original_stat))\n+#else\n+               FALSE\n+#endif\n+               )\n+        {\n+          g_set_error_literal (error,\n                              G_IO_ERROR,\n                              G_IO_ERROR_NOT_REGULAR_FILE,\n                              _(\"Target file is not a regular file\"));\n-      goto err_out;\n+          goto err_out;\n+        }\n     }\n   \n   if (etag != NULL)\n@@ -182,7 +214,8 @@\n \t    }\n \t}\n \n-      g_close (fd, NULL);\n+      if (fd >= 0)\n+        g_close (fd, NULL);\n       *temp_filename = tmp_filename;\n       return tmpfd;\n     }",
        "diff_line_info": {
            "deleted_lines": [
                "      fd = g_open (filename, open_flags, mode);",
                "    }",
                "#else",
                "  fd = g_open (filename, open_flags, mode);",
                "  errsv = errno;",
                "#endif",
                "",
                "  if (fd == -1)",
                "  res = g_local_file_fstat (fd,",
                "                            G_LOCAL_FILE_STAT_FIELD_TYPE |",
                "                            G_LOCAL_FILE_STAT_FIELD_MODE |",
                "                            G_LOCAL_FILE_STAT_FIELD_UID |",
                "                            G_LOCAL_FILE_STAT_FIELD_GID |",
                "                            G_LOCAL_FILE_STAT_FIELD_MTIME |",
                "                            G_LOCAL_FILE_STAT_FIELD_NLINK,",
                "                            G_LOCAL_FILE_STAT_FIELD_ALL, &original_stat);",
                "  errsv = errno;",
                "\tg_set_error_literal (error,",
                "                             G_IO_ERROR,",
                "                             G_IO_ERROR_IS_DIRECTORY,",
                "                             _(\"Target file is a directory\"));",
                "      else",
                "\tg_set_error_literal (error,",
                "      goto err_out;",
                "      g_close (fd, NULL);"
            ],
            "added_lines": [
                "      if (!replace_destination_set)",
                "        fd = g_open (filename, open_flags, mode);",
                "    }",
                "#else  /* if !O_NOFOLLOW */",
                "",
                "  if (!is_symlink || !replace_destination_set)",
                "    {",
                "      fd = g_open (filename, open_flags, mode);",
                "      errsv = errno;",
                "    }",
                "#endif",
                "",
                "  if (fd == -1 &&",
                "      (!is_symlink || !replace_destination_set))",
                "  if (!is_symlink)",
                "    {",
                "      res = g_local_file_fstat (fd,",
                "                                G_LOCAL_FILE_STAT_FIELD_TYPE |",
                "                                G_LOCAL_FILE_STAT_FIELD_MODE |",
                "                                G_LOCAL_FILE_STAT_FIELD_UID |",
                "                                G_LOCAL_FILE_STAT_FIELD_GID |",
                "                                G_LOCAL_FILE_STAT_FIELD_MTIME |",
                "                                G_LOCAL_FILE_STAT_FIELD_NLINK,",
                "                                G_LOCAL_FILE_STAT_FIELD_ALL, &original_stat);",
                "      errsv = errno;",
                "    }",
                "  else",
                "    {",
                "      res = g_local_file_lstat (filename,",
                "                                G_LOCAL_FILE_STAT_FIELD_TYPE |",
                "                                G_LOCAL_FILE_STAT_FIELD_MODE |",
                "                                G_LOCAL_FILE_STAT_FIELD_UID |",
                "                                G_LOCAL_FILE_STAT_FIELD_GID |",
                "                                G_LOCAL_FILE_STAT_FIELD_MTIME |",
                "                                G_LOCAL_FILE_STAT_FIELD_NLINK,",
                "                                G_LOCAL_FILE_STAT_FIELD_ALL, &original_stat);",
                "      errsv = errno;",
                "    }",
                "        {",
                "          g_set_error_literal (error,",
                "                               G_IO_ERROR,",
                "                               G_IO_ERROR_IS_DIRECTORY,",
                "                               _(\"Target file is a directory\"));",
                "          goto err_out;",
                "        }",
                "      else if (!is_symlink ||",
                "#ifdef S_ISLNK",
                "               !S_ISLNK (_g_stat_mode (&original_stat))",
                "#else",
                "               FALSE",
                "#endif",
                "               )",
                "        {",
                "          g_set_error_literal (error,",
                "          goto err_out;",
                "        }",
                "      if (fd >= 0)",
                "        g_close (fd, NULL);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-28650",
        "func_name": "GNOME/gnome-autoar/autoar_extractor_check_file_conflict",
        "description": "autoar-extractor.c in GNOME gnome-autoar before 0.3.1, as used by GNOME Shell, Nautilus, and other software, allows Directory Traversal during extraction because it lacks a check of whether a file's parent is a symlink in certain complex situations. NOTE: this issue exists because of an incomplete fix for CVE-2020-36241.",
        "git_url": "https://github.com/GNOME/gnome-autoar/commit/8109c368c6cfdb593faaf698c2bf5da32bb1ace4",
        "commit_title": "extractor: Do not allow symlink in parents",
        "commit_text": " Currently, it is still possible that some files are extracted outside of the destination dir in case of malicious archives. The checks from commit adb067e6 can be still bypassed in certain cases. See GNOME/file-roller#108 for more details. After some investigation, I am convinced that it would be best to\tsimply disallow symlinks in parents. For example, `tar` fails to extract such files with the `ENOTDIR` error. Let's do the same here. ",
        "func_before": "static gboolean\nautoar_extractor_check_file_conflict (GFile  *file,\n                                      mode_t  extracted_filetype)\n{\n  GFileType file_type;\n\n  file_type = g_file_query_file_type (file,\n                                      G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                                      NULL);\n  /* If there is no file with the given name, there will be no conflict */\n  if (file_type == G_FILE_TYPE_UNKNOWN) {\n    return FALSE;\n  }\n\n  /* It is not problem if the directory already exists */\n  if (file_type == G_FILE_TYPE_DIRECTORY &&\n      extracted_filetype == AE_IFDIR) {\n    return FALSE;\n  }\n\n  return TRUE;\n}",
        "func": "static GFile *\nautoar_extractor_check_file_conflict (AutoarExtractor *self,\n                                      GFile  *file,\n                                      mode_t  extracted_filetype)\n{\n  GFileType file_type;\n  g_autoptr (GFile) parent = NULL;\n\n  file_type = g_file_query_file_type (file,\n                                      G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                                      NULL);\n\n  /* It is a conflict if the file already exists with an exception for already\n   * existing directories.\n   */\n  if (file_type != G_FILE_TYPE_UNKNOWN &&\n      (file_type != G_FILE_TYPE_DIRECTORY ||\n       extracted_filetype != AE_IFDIR)) {\n    return g_object_ref (file);\n  }\n\n  if ((self->new_prefix && g_file_equal (self->new_prefix, file)) ||\n      (!self->new_prefix && g_file_equal (self->destination_dir, file))) {\n    return NULL;\n  }\n\n  /* Check also parents for conflict to be sure it is directory. */\n  parent = g_file_get_parent (file);\n  return autoar_extractor_check_file_conflict (self, parent, AE_IFDIR);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,22 +1,30 @@\n-static gboolean\n-autoar_extractor_check_file_conflict (GFile  *file,\n+static GFile *\n+autoar_extractor_check_file_conflict (AutoarExtractor *self,\n+                                      GFile  *file,\n                                       mode_t  extracted_filetype)\n {\n   GFileType file_type;\n+  g_autoptr (GFile) parent = NULL;\n \n   file_type = g_file_query_file_type (file,\n                                       G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                                       NULL);\n-  /* If there is no file with the given name, there will be no conflict */\n-  if (file_type == G_FILE_TYPE_UNKNOWN) {\n-    return FALSE;\n+\n+  /* It is a conflict if the file already exists with an exception for already\n+   * existing directories.\n+   */\n+  if (file_type != G_FILE_TYPE_UNKNOWN &&\n+      (file_type != G_FILE_TYPE_DIRECTORY ||\n+       extracted_filetype != AE_IFDIR)) {\n+    return g_object_ref (file);\n   }\n \n-  /* It is not problem if the directory already exists */\n-  if (file_type == G_FILE_TYPE_DIRECTORY &&\n-      extracted_filetype == AE_IFDIR) {\n-    return FALSE;\n+  if ((self->new_prefix && g_file_equal (self->new_prefix, file)) ||\n+      (!self->new_prefix && g_file_equal (self->destination_dir, file))) {\n+    return NULL;\n   }\n \n-  return TRUE;\n+  /* Check also parents for conflict to be sure it is directory. */\n+  parent = g_file_get_parent (file);\n+  return autoar_extractor_check_file_conflict (self, parent, AE_IFDIR);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "static gboolean",
                "autoar_extractor_check_file_conflict (GFile  *file,",
                "  /* If there is no file with the given name, there will be no conflict */",
                "  if (file_type == G_FILE_TYPE_UNKNOWN) {",
                "    return FALSE;",
                "  /* It is not problem if the directory already exists */",
                "  if (file_type == G_FILE_TYPE_DIRECTORY &&",
                "      extracted_filetype == AE_IFDIR) {",
                "    return FALSE;",
                "  return TRUE;"
            ],
            "added_lines": [
                "static GFile *",
                "autoar_extractor_check_file_conflict (AutoarExtractor *self,",
                "                                      GFile  *file,",
                "  g_autoptr (GFile) parent = NULL;",
                "",
                "  /* It is a conflict if the file already exists with an exception for already",
                "   * existing directories.",
                "   */",
                "  if (file_type != G_FILE_TYPE_UNKNOWN &&",
                "      (file_type != G_FILE_TYPE_DIRECTORY ||",
                "       extracted_filetype != AE_IFDIR)) {",
                "    return g_object_ref (file);",
                "  if ((self->new_prefix && g_file_equal (self->new_prefix, file)) ||",
                "      (!self->new_prefix && g_file_equal (self->destination_dir, file))) {",
                "    return NULL;",
                "  /* Check also parents for conflict to be sure it is directory. */",
                "  parent = g_file_get_parent (file);",
                "  return autoar_extractor_check_file_conflict (self, parent, AE_IFDIR);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-28650",
        "func_name": "GNOME/gnome-autoar/autoar_extractor_step_extract",
        "description": "autoar-extractor.c in GNOME gnome-autoar before 0.3.1, as used by GNOME Shell, Nautilus, and other software, allows Directory Traversal during extraction because it lacks a check of whether a file's parent is a symlink in certain complex situations. NOTE: this issue exists because of an incomplete fix for CVE-2020-36241.",
        "git_url": "https://github.com/GNOME/gnome-autoar/commit/8109c368c6cfdb593faaf698c2bf5da32bb1ace4",
        "commit_title": "extractor: Do not allow symlink in parents",
        "commit_text": " Currently, it is still possible that some files are extracted outside of the destination dir in case of malicious archives. The checks from commit adb067e6 can be still bypassed in certain cases. See GNOME/file-roller#108 for more details. After some investigation, I am convinced that it would be best to\tsimply disallow symlinks in parents. For example, `tar` fails to extract such files with the `ENOTDIR` error. Let's do the same here. ",
        "func_before": "static void\nautoar_extractor_step_extract (AutoarExtractor *self) {\n  /* Step 3: Extract files\n   * We have to re-open the archive to extract files\n   */\n\n  struct archive *a;\n  struct archive_entry *entry;\n\n  int r;\n\n  g_debug (\"autoar_extractor_step_extract: called\");\n\n  r = libarchive_create_read_object (self->use_raw_format, self, &a);\n  if (r != ARCHIVE_OK) {\n    if (self->error == NULL) {\n      self->error =\n        autoar_common_g_error_new_a (a, self->source_basename);\n    }\n    archive_read_free (a);\n    return;\n  }\n\n  while ((r = archive_read_next_header (a, &entry)) == ARCHIVE_OK) {\n    const char *pathname;\n    const char *hardlink;\n    g_autoptr (GFile) extracted_filename = NULL;\n    g_autoptr (GFile) hardlink_filename = NULL;\n    AutoarConflictAction action;\n    gboolean file_conflict;\n\n    if (g_cancellable_is_cancelled (self->cancellable)) {\n      archive_read_free (a);\n      return;\n    }\n\n    pathname = archive_entry_pathname (entry);\n    hardlink = archive_entry_hardlink (entry);\n\n    extracted_filename =\n      autoar_extractor_do_sanitize_pathname (self, pathname);\n\n    if (hardlink != NULL) {\n      hardlink_filename =\n        autoar_extractor_do_sanitize_pathname (self, hardlink);\n    }\n\n    /* Attempt to solve any name conflict before doing any operations */\n    file_conflict = autoar_extractor_check_file_conflict (extracted_filename,\n                                                          archive_entry_filetype (entry));\n    while (file_conflict) {\n      GFile *new_extracted_filename = NULL;\n\n      action = autoar_extractor_signal_conflict (self,\n                                                 extracted_filename,\n                                                 &new_extracted_filename);\n\n      switch (action) {\n        case AUTOAR_CONFLICT_OVERWRITE:\n          /* It is expected that this will fail for non-empty directories to\n           * prevent data loss.\n           */\n          g_file_delete (extracted_filename, self->cancellable, &self->error);\n          if (self->error != NULL) {\n            archive_read_free (a);\n            return;\n          }\n          break;\n        case AUTOAR_CONFLICT_CHANGE_DESTINATION:\n          /* FIXME: If the destination is changed for directory, it should be\n           * changed also for its children...\n           */\n          g_assert_nonnull (new_extracted_filename);\n          g_clear_object (&extracted_filename);\n          extracted_filename = new_extracted_filename;\n          break;\n        case AUTOAR_CONFLICT_SKIP:\n          archive_read_data_skip (a);\n          break;\n        default:\n          g_assert_not_reached ();\n          break;\n      }\n\n      if (action != AUTOAR_CONFLICT_CHANGE_DESTINATION) {\n        break;\n      }\n\n      file_conflict = autoar_extractor_check_file_conflict (extracted_filename,\n                                                            archive_entry_filetype (entry));\n    }\n\n    if (file_conflict && action == AUTOAR_CONFLICT_SKIP) {\n      self->total_files -= 1;\n      self->total_size -= archive_entry_size (entry);\n      continue;\n    }\n\n    autoar_extractor_do_write_entry (self, a, entry,\n                                     extracted_filename, hardlink_filename);\n\n    if (self->error != NULL) {\n      archive_read_free (a);\n      return;\n    }\n\n    self->completed_files++;\n    autoar_extractor_signal_progress (self);\n  }\n\n  if (r != ARCHIVE_EOF) {\n    if (self->error == NULL) {\n      self->error =\n        autoar_common_g_error_new_a (a, self->source_basename);\n    }\n    archive_read_free (a);\n    return;\n  }\n\n  archive_read_free (a);\n}",
        "func": "static void\nautoar_extractor_step_extract (AutoarExtractor *self) {\n  /* Step 3: Extract files\n   * We have to re-open the archive to extract files\n   */\n\n  struct archive *a;\n  struct archive_entry *entry;\n\n  int r;\n\n  g_debug (\"autoar_extractor_step_extract: called\");\n\n  r = libarchive_create_read_object (self->use_raw_format, self, &a);\n  if (r != ARCHIVE_OK) {\n    if (self->error == NULL) {\n      self->error =\n        autoar_common_g_error_new_a (a, self->source_basename);\n    }\n    archive_read_free (a);\n    return;\n  }\n\n  while ((r = archive_read_next_header (a, &entry)) == ARCHIVE_OK) {\n    const char *pathname;\n    const char *hardlink;\n    g_autoptr (GFile) extracted_filename = NULL;\n    g_autoptr (GFile) hardlink_filename = NULL;\n    AutoarConflictAction action;\n    g_autoptr (GFile) file_conflict = NULL;\n\n    if (g_cancellable_is_cancelled (self->cancellable)) {\n      archive_read_free (a);\n      return;\n    }\n\n    pathname = archive_entry_pathname (entry);\n    hardlink = archive_entry_hardlink (entry);\n\n    extracted_filename =\n      autoar_extractor_do_sanitize_pathname (self, pathname);\n\n    if (hardlink != NULL) {\n      hardlink_filename =\n        autoar_extractor_do_sanitize_pathname (self, hardlink);\n    }\n\n    /* Attempt to solve any name conflict before doing any operations */\n    file_conflict = autoar_extractor_check_file_conflict (self,\n                                                          extracted_filename,\n                                                          archive_entry_filetype (entry));\n    while (file_conflict) {\n      GFile *new_extracted_filename = NULL;\n\n      /* Do not try to solve any conflicts in parents for now. Especially\n       * symlinks in parents are dangerous as it can easily happen that files\n       * are written outside of the destination. The tar cmd fails to extract\n       * such archives with ENOTDIR. Let's do the same here. This is most\n       * probably malicious, or corrupted archive if the conflict was caused\n       * only by files from the archive...\n       */\n      if (!g_file_equal (file_conflict, extracted_filename)) {\n        self->error = g_error_new (G_IO_ERROR,\n                                   G_IO_ERROR_NOT_DIRECTORY,\n                                   \"The file is not a directory\");\n        archive_read_free (a);\n        return;\n      }\n\n      action = autoar_extractor_signal_conflict (self,\n                                                 extracted_filename,\n                                                 &new_extracted_filename);\n\n      switch (action) {\n        case AUTOAR_CONFLICT_OVERWRITE:\n          /* It is expected that this will fail for non-empty directories to\n           * prevent data loss.\n           */\n          g_file_delete (extracted_filename, self->cancellable, &self->error);\n          if (self->error != NULL) {\n            archive_read_free (a);\n            return;\n          }\n          break;\n        case AUTOAR_CONFLICT_CHANGE_DESTINATION:\n          /* FIXME: If the destination is changed for directory, it should be\n           * changed also for its children...\n           */\n          g_assert_nonnull (new_extracted_filename);\n          g_clear_object (&extracted_filename);\n          extracted_filename = new_extracted_filename;\n          break;\n        case AUTOAR_CONFLICT_SKIP:\n          archive_read_data_skip (a);\n          break;\n        default:\n          g_assert_not_reached ();\n          break;\n      }\n\n      if (action != AUTOAR_CONFLICT_CHANGE_DESTINATION) {\n        break;\n      }\n\n      g_clear_object (&file_conflict);\n      file_conflict = autoar_extractor_check_file_conflict (self,\n                                                            extracted_filename,\n                                                            archive_entry_filetype (entry));\n    }\n\n    if (file_conflict && action == AUTOAR_CONFLICT_SKIP) {\n      self->total_files -= 1;\n      self->total_size -= archive_entry_size (entry);\n      continue;\n    }\n\n    autoar_extractor_do_write_entry (self, a, entry,\n                                     extracted_filename, hardlink_filename);\n\n    if (self->error != NULL) {\n      archive_read_free (a);\n      return;\n    }\n\n    self->completed_files++;\n    autoar_extractor_signal_progress (self);\n  }\n\n  if (r != ARCHIVE_EOF) {\n    if (self->error == NULL) {\n      self->error =\n        autoar_common_g_error_new_a (a, self->source_basename);\n    }\n    archive_read_free (a);\n    return;\n  }\n\n  archive_read_free (a);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -27,7 +27,7 @@\n     g_autoptr (GFile) extracted_filename = NULL;\n     g_autoptr (GFile) hardlink_filename = NULL;\n     AutoarConflictAction action;\n-    gboolean file_conflict;\n+    g_autoptr (GFile) file_conflict = NULL;\n \n     if (g_cancellable_is_cancelled (self->cancellable)) {\n       archive_read_free (a);\n@@ -46,10 +46,26 @@\n     }\n \n     /* Attempt to solve any name conflict before doing any operations */\n-    file_conflict = autoar_extractor_check_file_conflict (extracted_filename,\n+    file_conflict = autoar_extractor_check_file_conflict (self,\n+                                                          extracted_filename,\n                                                           archive_entry_filetype (entry));\n     while (file_conflict) {\n       GFile *new_extracted_filename = NULL;\n+\n+      /* Do not try to solve any conflicts in parents for now. Especially\n+       * symlinks in parents are dangerous as it can easily happen that files\n+       * are written outside of the destination. The tar cmd fails to extract\n+       * such archives with ENOTDIR. Let's do the same here. This is most\n+       * probably malicious, or corrupted archive if the conflict was caused\n+       * only by files from the archive...\n+       */\n+      if (!g_file_equal (file_conflict, extracted_filename)) {\n+        self->error = g_error_new (G_IO_ERROR,\n+                                   G_IO_ERROR_NOT_DIRECTORY,\n+                                   \"The file is not a directory\");\n+        archive_read_free (a);\n+        return;\n+      }\n \n       action = autoar_extractor_signal_conflict (self,\n                                                  extracted_filename,\n@@ -86,7 +102,9 @@\n         break;\n       }\n \n-      file_conflict = autoar_extractor_check_file_conflict (extracted_filename,\n+      g_clear_object (&file_conflict);\n+      file_conflict = autoar_extractor_check_file_conflict (self,\n+                                                            extracted_filename,\n                                                             archive_entry_filetype (entry));\n     }\n ",
        "diff_line_info": {
            "deleted_lines": [
                "    gboolean file_conflict;",
                "    file_conflict = autoar_extractor_check_file_conflict (extracted_filename,",
                "      file_conflict = autoar_extractor_check_file_conflict (extracted_filename,"
            ],
            "added_lines": [
                "    g_autoptr (GFile) file_conflict = NULL;",
                "    file_conflict = autoar_extractor_check_file_conflict (self,",
                "                                                          extracted_filename,",
                "",
                "      /* Do not try to solve any conflicts in parents for now. Especially",
                "       * symlinks in parents are dangerous as it can easily happen that files",
                "       * are written outside of the destination. The tar cmd fails to extract",
                "       * such archives with ENOTDIR. Let's do the same here. This is most",
                "       * probably malicious, or corrupted archive if the conflict was caused",
                "       * only by files from the archive...",
                "       */",
                "      if (!g_file_equal (file_conflict, extracted_filename)) {",
                "        self->error = g_error_new (G_IO_ERROR,",
                "                                   G_IO_ERROR_NOT_DIRECTORY,",
                "                                   \"The file is not a directory\");",
                "        archive_read_free (a);",
                "        return;",
                "      }",
                "      g_clear_object (&file_conflict);",
                "      file_conflict = autoar_extractor_check_file_conflict (self,",
                "                                                            extracted_filename,"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-36314",
        "func_name": "GNOME/file-roller/extract_archive_thread",
        "description": "fr-archive-libarchive.c in GNOME file-roller through 3.38.0, as used by GNOME Shell and other software, allows Directory Traversal during extraction because it lacks a check of whether a file's parent is a symlink in certain complex situations. NOTE: this issue exists because of an incomplete fix for CVE-2020-11736.",
        "git_url": "https://github.com/GNOME/file-roller/commit/e970f4966bf388f6e7c277357c8b186c645683ae",
        "commit_title": "libarchive: Skip files with symlinks in parents",
        "commit_text": " Currently, it is still possible that some files are extracted outside of the destination dir in case of malicious archives. The checks from commit 21dfcdbf can be still bypassed in certain cases. See GNOME/file-roller#108 for more details. After some investigation, I am convinced that it would be best to simply disallow symlinks in parents. For example, `tar` fails to extract such files with the `ENOTDIR` error. Let's do the same here. ",
        "func_before": "static void\nextract_archive_thread (GSimpleAsyncResult *result,\n\t\t\tGObject            *object,\n\t\t\tGCancellable       *cancellable)\n{\n\tExtractData          *extract_data;\n\tLoadData             *load_data;\n\tGHashTable           *checked_folders;\n\tGHashTable           *created_files;\n\tGHashTable           *folders_created_during_extraction;\n\tGHashTable           *external_links;\n\tstruct archive       *a;\n\tstruct archive_entry *entry;\n\tint                   r;\n\n\textract_data = g_simple_async_result_get_op_res_gpointer (result);\n\tload_data = LOAD_DATA (extract_data);\n\n\tr = create_read_object (load_data, &a);\n\tif (r != ARCHIVE_OK) {\n\t\tarchive_read_free(a);\n\t\treturn;\n\t}\n\n\tchecked_folders = g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, NULL);\n\tcreated_files = g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, g_object_unref);\n\tfolders_created_during_extraction = g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, NULL);\n\texternal_links = g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, NULL);\n\tfr_archive_progress_set_total_files (load_data->archive, extract_data->n_files_to_extract);\n\n\twhile ((r = archive_read_next_header (a, &entry)) == ARCHIVE_OK) {\n\t\tconst char    *pathname;\n\t\tchar          *fullpath;\n\t\tconst char    *relative_path;\n\t\tGFile         *file;\n\t\tGFile         *parent;\n\t\tGOutputStream *ostream;\n\t\tconst void    *buffer;\n\t\tsize_t         buffer_size;\n\t\tint64_t        target_offset, actual_offset;\n\t\tGError        *local_error = NULL;\n\t\t__LA_MODE_T    filetype;\n\n\t\tif (g_cancellable_is_cancelled (cancellable))\n\t\t\tbreak;\n\n\t\tpathname = archive_entry_pathname (entry);\n\t\tif (! extract_data_get_extraction_requested (extract_data, pathname)) {\n\t\t\tarchive_read_data_skip (a);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfullpath = (*pathname == '/') ? g_strdup (pathname) : g_strconcat (\"/\", pathname, NULL);\n\t\trelative_path = _g_path_get_relative_basename_safe (fullpath, extract_data->base_dir, extract_data->junk_paths);\n\t\tif (relative_path == NULL) {\n\t\t\tfr_archive_progress_inc_completed_files (load_data->archive, 1);\n\t\t\tfr_archive_progress_inc_completed_bytes (load_data->archive, archive_entry_size_is_set (entry) ? archive_entry_size (entry) : 0);\n\t\t\tarchive_read_data_skip (a);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (_g_path_is_external_to_destination (relative_path, extract_data->destination, external_links)) {\n\t\t\tfr_archive_progress_inc_completed_files (load_data->archive, 1);\n\t\t\tfr_archive_progress_inc_completed_bytes (load_data->archive, archive_entry_size_is_set (entry) ? archive_entry_size (entry) : 0);\n\t\t\tarchive_read_data_skip (a);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfile = g_file_get_child (extract_data->destination, relative_path);\n\n\t\t/* honor the skip_older and overwrite options */\n\n\t\tif ((g_hash_table_lookup (folders_created_during_extraction, file) == NULL)\n\t\t    && (extract_data->skip_older || ! extract_data->overwrite))\n\t\t{\n\t\t\tGFileInfo *info;\n\n\t\t\tinfo = g_file_query_info (file,\n\t\t\t\t\t\t  G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME \",\" G_FILE_ATTRIBUTE_TIME_MODIFIED,\n\t\t\t\t\t\t  G_FILE_QUERY_INFO_NONE,\n\t\t\t\t\t\t  cancellable,\n\t\t\t\t\t\t  &local_error);\n\t\t\tif (info != NULL) {\n\t\t\t\tgboolean skip = FALSE;\n\n\t\t\t\tif (! extract_data->overwrite) {\n\t\t\t\t\tskip = TRUE;\n\t\t\t\t}\n\t\t\t\telse if (extract_data->skip_older) {\n\t\t\t\t\tGTimeVal modification_time;\n\n\t\t\t\t\tg_file_info_get_modification_time (info, &modification_time);\n\t\t\t\t\tif (archive_entry_mtime (entry) < modification_time.tv_sec)\n\t\t\t\t\t\tskip = TRUE;\n\t\t\t\t}\n\n\t\t\t\tg_object_unref (info);\n\n\t\t\t\tif (skip) {\n\t\t\t\t\tg_object_unref (file);\n\n\t\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\t\tfr_archive_progress_inc_completed_bytes (load_data->archive, archive_entry_size_is_set (entry) ? archive_entry_size (entry) : 0);\n\n\t\t\t\t\tif ((extract_data->file_list != NULL) && (--extract_data->n_files_to_extract == 0)) {\n\t\t\t\t\t\tr = ARCHIVE_EOF;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (! g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND)) {\n\t\t\t\t\tload_data->error = local_error;\n\t\t\t\t\tg_object_unref (info);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tg_clear_error (&local_error);\n\t\t\t}\n\t\t}\n\n\t\tfr_archive_progress_inc_completed_files (load_data->archive, 1);\n\n\t\t/* create the file parents */\n\n\t\tparent = g_file_get_parent (file);\n\n\t\tif ((parent != NULL)\n\t\t    && (g_hash_table_lookup (checked_folders, parent) == NULL)\n\t\t    && ! g_file_query_exists (parent, cancellable))\n\t\t{\n\t\t\tif (! _g_file_make_directory_with_parents (parent,\n\t\t\t\t\t\t\t\t   folders_created_during_extraction,\n\t\t\t\t\t\t\t\t   cancellable,\n\t\t\t\t\t\t\t\t   &local_error))\n\t\t\t{\n\t\t\t\tif (! g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_EXISTS))\n\t\t\t\t\tload_data->error = local_error;\n\t\t\t\telse\n\t\t\t\t\tg_clear_error (&local_error);\n\t\t\t}\n\n\t\t\tif (load_data->error == NULL) {\n\t\t\t\tGFile *grandparent;\n\n\t\t\t\tgrandparent = g_object_ref (parent);\n\t\t\t\twhile (grandparent != NULL) {\n\t\t\t\t\tif (g_hash_table_lookup (checked_folders, grandparent) == NULL)\n\t\t\t\t\t\tg_hash_table_insert (checked_folders, grandparent, GINT_TO_POINTER (1));\n\t\t\t\t\tgrandparent = g_file_get_parent (grandparent);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tg_object_unref (parent);\n\n\t\t/* create the file */\n\n\t\tfiletype = archive_entry_filetype (entry);\n\n\t\tif (load_data->error == NULL) {\n\t\t\tconst char  *linkname;\n\n\t\t\tlinkname = archive_entry_hardlink (entry);\n\t\t\tif (linkname != NULL) {\n\t\t\t\tchar        *link_fullpath;\n\t\t\t\tconst char  *relative_path;\n\t\t\t\tGFile       *link_file;\n\t\t\t\tchar        *oldname;\n\t\t\t\tchar        *newname;\n\t\t\t\tint          r;\n\n\t\t\t\tlink_fullpath = (*linkname == '/') ? g_strdup (linkname) : g_strconcat (\"/\", linkname, NULL);\n\t\t\t\trelative_path = _g_path_get_relative_basename_safe (link_fullpath, extract_data->base_dir, extract_data->junk_paths);\n\t\t\t\tif (relative_path == NULL) {\n\t\t\t\t\tg_free (link_fullpath);\n\t\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tlink_file = g_file_get_child (extract_data->destination, relative_path);\n\t\t\t\toldname = g_file_get_path (link_file);\n\t\t\t\tnewname = g_file_get_path (file);\n\n\t\t\t\tif ((oldname != NULL) && (newname != NULL))\n\t\t\t\t\tr = link (oldname, newname);\n\t\t\t\telse\n\t\t\t\t\tr = -1;\n\n\t\t\t\tif (r == 0) {\n\t\t\t\t\t__LA_INT64_T filesize;\n\n\t\t\t\t\tif (archive_entry_size_is_set (entry))\n\t\t\t\t\t\tfilesize = archive_entry_size (entry);\n\t\t\t\t\telse\n\t\t\t\t\t\tfilesize = -1;\n\n\t\t\t\t\tif (filesize > 0)\n\t\t\t\t\t\tfiletype = AE_IFREG; /* treat as a regular file to save the data */\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tchar *uri;\n\t\t\t\t\tchar *msg;\n\n\t\t\t\t\turi = g_file_get_uri (file);\n\t\t\t\t\tmsg = g_strdup_printf (\"Could not create the hard link %s\", uri);\n\t\t\t\t\tload_data->error = g_error_new_literal (G_IO_ERROR, G_IO_ERROR_FAILED, msg);\n\n\t\t\t\t\tg_free (msg);\n\t\t\t\t\tg_free (uri);\n\t\t\t\t}\n\n\t\t\t\tg_free (newname);\n\t\t\t\tg_free (oldname);\n\t\t\t\tg_object_unref (link_file);\n\t\t\t\tg_free (link_fullpath);\n\t\t\t}\n\t\t}\n\n\t\tif (load_data->error == NULL) {\n\t\t\tswitch (filetype) {\n\t\t\tcase AE_IFDIR:\n\t\t\t\tif (! g_file_make_directory (file, cancellable, &local_error)) {\n\t\t\t\t\tif (! g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_EXISTS))\n\t\t\t\t\t\tload_data->error = g_error_copy (local_error);\n\t\t\t\t\tg_clear_error (&local_error);\n\t\t\t\t}\n\t\t\t\tif (load_data->error == NULL)\n\t\t\t\t\tg_hash_table_insert (created_files, g_object_ref (file), _g_file_info_create_from_entry (entry, extract_data));\n\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\tbreak;\n\n\t\t\tcase AE_IFREG:\n\t\t\t\tostream = (GOutputStream *) g_file_replace (file, NULL, FALSE, G_FILE_CREATE_REPLACE_DESTINATION, cancellable, &load_data->error);\n\t\t\t\tif (ostream == NULL)\n\t\t\t\t\tbreak;\n\n\t\t\t\tactual_offset = 0;\n\t\t\t\twhile ((r = archive_read_data_block (a, &buffer, &buffer_size, &target_offset)) == ARCHIVE_OK) {\n\t\t\t\t\tgsize bytes_written;\n\n\t\t\t\t\tif (target_offset > actual_offset) {\n\t\t\t\t\t\tif (! _g_output_stream_add_padding (extract_data, ostream, target_offset, actual_offset, cancellable, &load_data->error))\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tfr_archive_progress_inc_completed_bytes (load_data->archive, target_offset - actual_offset);\n\t\t\t\t\t\tactual_offset = target_offset;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (! g_output_stream_write_all (ostream, buffer, buffer_size, &bytes_written, cancellable, &load_data->error))\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tactual_offset += bytes_written;\n\t\t\t\t\tfr_archive_progress_inc_completed_bytes (load_data->archive, bytes_written);\n\t\t\t\t}\n\n\t\t\t\tif ((r == ARCHIVE_EOF) && (target_offset > actual_offset))\n\t\t\t\t\t_g_output_stream_add_padding (extract_data, ostream, target_offset, actual_offset, cancellable, &load_data->error);\n\n\t\t\t\t_g_object_unref (ostream);\n\n\t\t\t\tif (r != ARCHIVE_EOF)\n\t\t\t\t\tload_data->error = _g_error_new_from_archive_error (archive_error_string (a));\n\t\t\t\telse\n\t\t\t\t\tg_hash_table_insert (created_files, g_object_ref (file), _g_file_info_create_from_entry (entry, extract_data));\n\t\t\t\tbreak;\n\n\t\t\tcase AE_IFLNK:\n\t\t\t\tif (! g_file_make_symbolic_link (file, archive_entry_symlink (entry), cancellable, &local_error)) {\n\t\t\t\t\tif (g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_EXISTS)) {\n\t\t\t\t\t\tg_clear_error (&local_error);\n\t\t\t\t\t\tif (g_file_delete (file, cancellable, &local_error)) {\n\t\t\t\t\t\t\tg_clear_error (&local_error);\n\t\t\t\t\t\t\tif (! g_file_make_symbolic_link (file, archive_entry_symlink (entry), cancellable, &local_error))\n\t\t\t\t\t\t\t\tload_data->error = g_error_copy (local_error);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tload_data->error = g_error_copy (local_error);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tload_data->error = g_error_copy (local_error);\n\t\t\t\t\tg_clear_error (&local_error);\n\t\t\t\t}\n\t\t\t\tif ((load_data->error == NULL) && _symlink_is_external_to_destination (file, archive_entry_symlink (entry), extract_data->destination, external_links))\n\t\t\t\t\tg_hash_table_insert (external_links, g_object_ref (file), GINT_TO_POINTER (1));\n\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tg_object_unref (file);\n\t\tg_free (fullpath);\n\n\t\tif (load_data->error != NULL)\n\t\t\tbreak;\n\n\t\tif ((extract_data->file_list != NULL) && (--extract_data->n_files_to_extract == 0)) {\n\t\t\tr = ARCHIVE_EOF;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (load_data->error == NULL)\n\t\trestore_original_file_attributes (created_files, cancellable);\n\n\tif ((load_data->error == NULL) && (r != ARCHIVE_EOF))\n\t\tload_data->error = _g_error_new_from_archive_error (archive_error_string (a));\n\tif (load_data->error == NULL)\n\t\tg_cancellable_set_error_if_cancelled (cancellable, &load_data->error);\n\tif (load_data->error != NULL)\n\t\tg_simple_async_result_set_from_error (result, load_data->error);\n\n\tg_hash_table_unref (folders_created_during_extraction);\n\tg_hash_table_unref (created_files);\n\tg_hash_table_unref (checked_folders);\n\tg_hash_table_unref (external_links);\n\tarchive_read_free (a);\n\textract_data_free (extract_data);\n}",
        "func": "static void\nextract_archive_thread (GSimpleAsyncResult *result,\n\t\t\tGObject            *object,\n\t\t\tGCancellable       *cancellable)\n{\n\tExtractData          *extract_data;\n\tLoadData             *load_data;\n\tGHashTable           *checked_folders;\n\tGHashTable           *created_files;\n\tGHashTable           *folders_created_during_extraction;\n\tGHashTable           *symlinks;\n\tstruct archive       *a;\n\tstruct archive_entry *entry;\n\tint                   r;\n\n\textract_data = g_simple_async_result_get_op_res_gpointer (result);\n\tload_data = LOAD_DATA (extract_data);\n\n\tr = create_read_object (load_data, &a);\n\tif (r != ARCHIVE_OK) {\n\t\tarchive_read_free(a);\n\t\treturn;\n\t}\n\n\tchecked_folders = g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, NULL);\n\tcreated_files = g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, g_object_unref);\n\tfolders_created_during_extraction = g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, NULL);\n\tsymlinks = g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, NULL);\n\tfr_archive_progress_set_total_files (load_data->archive, extract_data->n_files_to_extract);\n\n\twhile ((r = archive_read_next_header (a, &entry)) == ARCHIVE_OK) {\n\t\tconst char    *pathname;\n\t\tchar          *fullpath;\n\t\tconst char    *relative_path;\n\t\tGFile         *file;\n\t\tGFile         *parent;\n\t\tGOutputStream *ostream;\n\t\tconst void    *buffer;\n\t\tsize_t         buffer_size;\n\t\tint64_t        target_offset, actual_offset;\n\t\tGError        *local_error = NULL;\n\t\t__LA_MODE_T    filetype;\n\n\t\tif (g_cancellable_is_cancelled (cancellable))\n\t\t\tbreak;\n\n\t\tpathname = archive_entry_pathname (entry);\n\t\tif (! extract_data_get_extraction_requested (extract_data, pathname)) {\n\t\t\tarchive_read_data_skip (a);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfullpath = (*pathname == '/') ? g_strdup (pathname) : g_strconcat (\"/\", pathname, NULL);\n\t\trelative_path = _g_path_get_relative_basename_safe (fullpath, extract_data->base_dir, extract_data->junk_paths);\n\t\tif (relative_path == NULL) {\n\t\t\tfr_archive_progress_inc_completed_files (load_data->archive, 1);\n\t\t\tfr_archive_progress_inc_completed_bytes (load_data->archive, archive_entry_size_is_set (entry) ? archive_entry_size (entry) : 0);\n\t\t\tarchive_read_data_skip (a);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Symlinks in parents are dangerous as it can easily happen\n\t\t * that files are written outside of the destination. The tar\n\t\t * cmd fails to extract such archives with ENOTDIR. Let's skip\n\t\t * those files here for sure. This is most probably malicious,\n\t\t * or corrupted archive.\n\t\t */\n\t\tif (_g_file_contains_symlinks_in_path (relative_path, extract_data->destination, symlinks)) {\n\t\t\tg_warning (\"Skipping '%s' file as it has symlink in parents.\", relative_path);\n\t\t\tfr_archive_progress_inc_completed_files (load_data->archive, 1);\n\t\t\tfr_archive_progress_inc_completed_bytes (load_data->archive, archive_entry_size_is_set (entry) ? archive_entry_size (entry) : 0);\n\t\t\tarchive_read_data_skip (a);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfile = g_file_get_child (extract_data->destination, relative_path);\n\n\t\t/* honor the skip_older and overwrite options */\n\n\t\tif ((g_hash_table_lookup (folders_created_during_extraction, file) == NULL)\n\t\t    && (extract_data->skip_older || ! extract_data->overwrite))\n\t\t{\n\t\t\tGFileInfo *info;\n\n\t\t\tinfo = g_file_query_info (file,\n\t\t\t\t\t\t  G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME \",\" G_FILE_ATTRIBUTE_TIME_MODIFIED,\n\t\t\t\t\t\t  G_FILE_QUERY_INFO_NONE,\n\t\t\t\t\t\t  cancellable,\n\t\t\t\t\t\t  &local_error);\n\t\t\tif (info != NULL) {\n\t\t\t\tgboolean skip = FALSE;\n\n\t\t\t\tif (! extract_data->overwrite) {\n\t\t\t\t\tskip = TRUE;\n\t\t\t\t}\n\t\t\t\telse if (extract_data->skip_older) {\n\t\t\t\t\tGTimeVal modification_time;\n\n\t\t\t\t\tg_file_info_get_modification_time (info, &modification_time);\n\t\t\t\t\tif (archive_entry_mtime (entry) < modification_time.tv_sec)\n\t\t\t\t\t\tskip = TRUE;\n\t\t\t\t}\n\n\t\t\t\tg_object_unref (info);\n\n\t\t\t\tif (skip) {\n\t\t\t\t\tg_object_unref (file);\n\n\t\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\t\tfr_archive_progress_inc_completed_bytes (load_data->archive, archive_entry_size_is_set (entry) ? archive_entry_size (entry) : 0);\n\n\t\t\t\t\tif ((extract_data->file_list != NULL) && (--extract_data->n_files_to_extract == 0)) {\n\t\t\t\t\t\tr = ARCHIVE_EOF;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (! g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND)) {\n\t\t\t\t\tload_data->error = local_error;\n\t\t\t\t\tg_object_unref (info);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tg_clear_error (&local_error);\n\t\t\t}\n\t\t}\n\n\t\tfr_archive_progress_inc_completed_files (load_data->archive, 1);\n\n\t\t/* create the file parents */\n\n\t\tparent = g_file_get_parent (file);\n\n\t\tif ((parent != NULL)\n\t\t    && (g_hash_table_lookup (checked_folders, parent) == NULL)\n\t\t    && ! g_file_query_exists (parent, cancellable))\n\t\t{\n\t\t\tif (! _g_file_make_directory_with_parents (parent,\n\t\t\t\t\t\t\t\t   folders_created_during_extraction,\n\t\t\t\t\t\t\t\t   cancellable,\n\t\t\t\t\t\t\t\t   &local_error))\n\t\t\t{\n\t\t\t\tif (! g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_EXISTS))\n\t\t\t\t\tload_data->error = local_error;\n\t\t\t\telse\n\t\t\t\t\tg_clear_error (&local_error);\n\t\t\t}\n\n\t\t\tif (load_data->error == NULL) {\n\t\t\t\tGFile *grandparent;\n\n\t\t\t\tgrandparent = g_object_ref (parent);\n\t\t\t\twhile (grandparent != NULL) {\n\t\t\t\t\tif (g_hash_table_lookup (checked_folders, grandparent) == NULL)\n\t\t\t\t\t\tg_hash_table_insert (checked_folders, grandparent, GINT_TO_POINTER (1));\n\t\t\t\t\tgrandparent = g_file_get_parent (grandparent);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tg_object_unref (parent);\n\n\t\t/* create the file */\n\n\t\tfiletype = archive_entry_filetype (entry);\n\n\t\tif (load_data->error == NULL) {\n\t\t\tconst char  *linkname;\n\n\t\t\tlinkname = archive_entry_hardlink (entry);\n\t\t\tif (linkname != NULL) {\n\t\t\t\tchar        *link_fullpath;\n\t\t\t\tconst char  *relative_path;\n\t\t\t\tGFile       *link_file;\n\t\t\t\tchar        *oldname;\n\t\t\t\tchar        *newname;\n\t\t\t\tint          r;\n\n\t\t\t\tlink_fullpath = (*linkname == '/') ? g_strdup (linkname) : g_strconcat (\"/\", linkname, NULL);\n\t\t\t\trelative_path = _g_path_get_relative_basename_safe (link_fullpath, extract_data->base_dir, extract_data->junk_paths);\n\t\t\t\tif (relative_path == NULL) {\n\t\t\t\t\tg_free (link_fullpath);\n\t\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tlink_file = g_file_get_child (extract_data->destination, relative_path);\n\t\t\t\toldname = g_file_get_path (link_file);\n\t\t\t\tnewname = g_file_get_path (file);\n\n\t\t\t\tif ((oldname != NULL) && (newname != NULL))\n\t\t\t\t\tr = link (oldname, newname);\n\t\t\t\telse\n\t\t\t\t\tr = -1;\n\n\t\t\t\tif (r == 0) {\n\t\t\t\t\t__LA_INT64_T filesize;\n\n\t\t\t\t\tif (archive_entry_size_is_set (entry))\n\t\t\t\t\t\tfilesize = archive_entry_size (entry);\n\t\t\t\t\telse\n\t\t\t\t\t\tfilesize = -1;\n\n\t\t\t\t\tif (filesize > 0)\n\t\t\t\t\t\tfiletype = AE_IFREG; /* treat as a regular file to save the data */\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tchar *uri;\n\t\t\t\t\tchar *msg;\n\n\t\t\t\t\turi = g_file_get_uri (file);\n\t\t\t\t\tmsg = g_strdup_printf (\"Could not create the hard link %s\", uri);\n\t\t\t\t\tload_data->error = g_error_new_literal (G_IO_ERROR, G_IO_ERROR_FAILED, msg);\n\n\t\t\t\t\tg_free (msg);\n\t\t\t\t\tg_free (uri);\n\t\t\t\t}\n\n\t\t\t\tg_free (newname);\n\t\t\t\tg_free (oldname);\n\t\t\t\tg_object_unref (link_file);\n\t\t\t\tg_free (link_fullpath);\n\t\t\t}\n\t\t}\n\n\t\tif (load_data->error == NULL) {\n\t\t\tswitch (filetype) {\n\t\t\tcase AE_IFDIR:\n\t\t\t\tif (! g_file_make_directory (file, cancellable, &local_error)) {\n\t\t\t\t\tif (! g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_EXISTS))\n\t\t\t\t\t\tload_data->error = g_error_copy (local_error);\n\t\t\t\t\tg_clear_error (&local_error);\n\t\t\t\t}\n\t\t\t\tif (load_data->error == NULL)\n\t\t\t\t\tg_hash_table_insert (created_files, g_object_ref (file), _g_file_info_create_from_entry (entry, extract_data));\n\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\tbreak;\n\n\t\t\tcase AE_IFREG:\n\t\t\t\tostream = (GOutputStream *) g_file_replace (file, NULL, FALSE, G_FILE_CREATE_REPLACE_DESTINATION, cancellable, &load_data->error);\n\t\t\t\tif (ostream == NULL)\n\t\t\t\t\tbreak;\n\n\t\t\t\tactual_offset = 0;\n\t\t\t\twhile ((r = archive_read_data_block (a, &buffer, &buffer_size, &target_offset)) == ARCHIVE_OK) {\n\t\t\t\t\tgsize bytes_written;\n\n\t\t\t\t\tif (target_offset > actual_offset) {\n\t\t\t\t\t\tif (! _g_output_stream_add_padding (extract_data, ostream, target_offset, actual_offset, cancellable, &load_data->error))\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tfr_archive_progress_inc_completed_bytes (load_data->archive, target_offset - actual_offset);\n\t\t\t\t\t\tactual_offset = target_offset;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (! g_output_stream_write_all (ostream, buffer, buffer_size, &bytes_written, cancellable, &load_data->error))\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tactual_offset += bytes_written;\n\t\t\t\t\tfr_archive_progress_inc_completed_bytes (load_data->archive, bytes_written);\n\t\t\t\t}\n\n\t\t\t\tif ((r == ARCHIVE_EOF) && (target_offset > actual_offset))\n\t\t\t\t\t_g_output_stream_add_padding (extract_data, ostream, target_offset, actual_offset, cancellable, &load_data->error);\n\n\t\t\t\t_g_object_unref (ostream);\n\n\t\t\t\tif (r != ARCHIVE_EOF)\n\t\t\t\t\tload_data->error = _g_error_new_from_archive_error (archive_error_string (a));\n\t\t\t\telse\n\t\t\t\t\tg_hash_table_insert (created_files, g_object_ref (file), _g_file_info_create_from_entry (entry, extract_data));\n\t\t\t\tbreak;\n\n\t\t\tcase AE_IFLNK:\n\t\t\t\tif (! g_file_make_symbolic_link (file, archive_entry_symlink (entry), cancellable, &local_error)) {\n\t\t\t\t\tif (g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_EXISTS)) {\n\t\t\t\t\t\tg_clear_error (&local_error);\n\t\t\t\t\t\tif (g_file_delete (file, cancellable, &local_error)) {\n\t\t\t\t\t\t\tg_clear_error (&local_error);\n\t\t\t\t\t\t\tif (! g_file_make_symbolic_link (file, archive_entry_symlink (entry), cancellable, &local_error))\n\t\t\t\t\t\t\t\tload_data->error = g_error_copy (local_error);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tload_data->error = g_error_copy (local_error);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tload_data->error = g_error_copy (local_error);\n\t\t\t\t\tg_clear_error (&local_error);\n\t\t\t\t}\n\t\t\t\tif (load_data->error == NULL)\n\t\t\t\t\tg_hash_table_add (symlinks, g_object_ref (file));\n\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tg_object_unref (file);\n\t\tg_free (fullpath);\n\n\t\tif (load_data->error != NULL)\n\t\t\tbreak;\n\n\t\tif ((extract_data->file_list != NULL) && (--extract_data->n_files_to_extract == 0)) {\n\t\t\tr = ARCHIVE_EOF;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (load_data->error == NULL)\n\t\trestore_original_file_attributes (created_files, cancellable);\n\n\tif ((load_data->error == NULL) && (r != ARCHIVE_EOF))\n\t\tload_data->error = _g_error_new_from_archive_error (archive_error_string (a));\n\tif (load_data->error == NULL)\n\t\tg_cancellable_set_error_if_cancelled (cancellable, &load_data->error);\n\tif (load_data->error != NULL)\n\t\tg_simple_async_result_set_from_error (result, load_data->error);\n\n\tg_hash_table_unref (folders_created_during_extraction);\n\tg_hash_table_unref (created_files);\n\tg_hash_table_unref (checked_folders);\n\tg_hash_table_unref (symlinks);\n\tarchive_read_free (a);\n\textract_data_free (extract_data);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -8,7 +8,7 @@\n \tGHashTable           *checked_folders;\n \tGHashTable           *created_files;\n \tGHashTable           *folders_created_during_extraction;\n-\tGHashTable           *external_links;\n+\tGHashTable           *symlinks;\n \tstruct archive       *a;\n \tstruct archive_entry *entry;\n \tint                   r;\n@@ -25,7 +25,7 @@\n \tchecked_folders = g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, NULL);\n \tcreated_files = g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, g_object_unref);\n \tfolders_created_during_extraction = g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, NULL);\n-\texternal_links = g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, NULL);\n+\tsymlinks = g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, NULL);\n \tfr_archive_progress_set_total_files (load_data->archive, extract_data->n_files_to_extract);\n \n \twhile ((r = archive_read_next_header (a, &entry)) == ARCHIVE_OK) {\n@@ -59,7 +59,14 @@\n \t\t\tcontinue;\n \t\t}\n \n-\t\tif (_g_path_is_external_to_destination (relative_path, extract_data->destination, external_links)) {\n+\t\t/* Symlinks in parents are dangerous as it can easily happen\n+\t\t * that files are written outside of the destination. The tar\n+\t\t * cmd fails to extract such archives with ENOTDIR. Let's skip\n+\t\t * those files here for sure. This is most probably malicious,\n+\t\t * or corrupted archive.\n+\t\t */\n+\t\tif (_g_file_contains_symlinks_in_path (relative_path, extract_data->destination, symlinks)) {\n+\t\t\tg_warning (\"Skipping '%s' file as it has symlink in parents.\", relative_path);\n \t\t\tfr_archive_progress_inc_completed_files (load_data->archive, 1);\n \t\t\tfr_archive_progress_inc_completed_bytes (load_data->archive, archive_entry_size_is_set (entry) ? archive_entry_size (entry) : 0);\n \t\t\tarchive_read_data_skip (a);\n@@ -280,8 +287,8 @@\n \t\t\t\t\t\tload_data->error = g_error_copy (local_error);\n \t\t\t\t\tg_clear_error (&local_error);\n \t\t\t\t}\n-\t\t\t\tif ((load_data->error == NULL) && _symlink_is_external_to_destination (file, archive_entry_symlink (entry), extract_data->destination, external_links))\n-\t\t\t\t\tg_hash_table_insert (external_links, g_object_ref (file), GINT_TO_POINTER (1));\n+\t\t\t\tif (load_data->error == NULL)\n+\t\t\t\t\tg_hash_table_add (symlinks, g_object_ref (file));\n \t\t\t\tarchive_read_data_skip (a);\n \t\t\t\tbreak;\n \n@@ -316,7 +323,7 @@\n \tg_hash_table_unref (folders_created_during_extraction);\n \tg_hash_table_unref (created_files);\n \tg_hash_table_unref (checked_folders);\n-\tg_hash_table_unref (external_links);\n+\tg_hash_table_unref (symlinks);\n \tarchive_read_free (a);\n \textract_data_free (extract_data);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tGHashTable           *external_links;",
                "\texternal_links = g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, NULL);",
                "\t\tif (_g_path_is_external_to_destination (relative_path, extract_data->destination, external_links)) {",
                "\t\t\t\tif ((load_data->error == NULL) && _symlink_is_external_to_destination (file, archive_entry_symlink (entry), extract_data->destination, external_links))",
                "\t\t\t\t\tg_hash_table_insert (external_links, g_object_ref (file), GINT_TO_POINTER (1));",
                "\tg_hash_table_unref (external_links);"
            ],
            "added_lines": [
                "\tGHashTable           *symlinks;",
                "\tsymlinks = g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, NULL);",
                "\t\t/* Symlinks in parents are dangerous as it can easily happen",
                "\t\t * that files are written outside of the destination. The tar",
                "\t\t * cmd fails to extract such archives with ENOTDIR. Let's skip",
                "\t\t * those files here for sure. This is most probably malicious,",
                "\t\t * or corrupted archive.",
                "\t\t */",
                "\t\tif (_g_file_contains_symlinks_in_path (relative_path, extract_data->destination, symlinks)) {",
                "\t\t\tg_warning (\"Skipping '%s' file as it has symlink in parents.\", relative_path);",
                "\t\t\t\tif (load_data->error == NULL)",
                "\t\t\t\t\tg_hash_table_add (symlinks, g_object_ref (file));",
                "\tg_hash_table_unref (symlinks);"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-11736",
        "func_name": "GNOME/file-roller/extract_archive_thread",
        "description": "fr-archive-libarchive.c in GNOME file-roller through 3.36.1 allows Directory Traversal during extraction because it lacks a check of whether a file's parent is a symlink to a directory outside of the intended extraction location.",
        "git_url": "https://github.com/GNOME/file-roller/commit/21dfcdbfe258984db89fb65243a1a888924e45a0",
        "commit_title": "libarchive: do not follow external links when extracting files",
        "commit_text": " Do not extract a file if its parent is a symbolic link to a directory external to the destination.",
        "func_before": "static void\nextract_archive_thread (GSimpleAsyncResult *result,\n\t\t\tGObject            *object,\n\t\t\tGCancellable       *cancellable)\n{\n\tExtractData          *extract_data;\n\tLoadData             *load_data;\n\tGHashTable           *checked_folders;\n\tGHashTable           *created_files;\n\tGHashTable           *folders_created_during_extraction;\n\tstruct archive       *a;\n\tstruct archive_entry *entry;\n\tint                   r;\n\n\textract_data = g_simple_async_result_get_op_res_gpointer (result);\n\tload_data = LOAD_DATA (extract_data);\n\n\tr = create_read_object (load_data, &a);\n\tif (r != ARCHIVE_OK) {\n\t\tarchive_read_free(a);\n\t\treturn;\n\t}\n\n\tchecked_folders = g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, NULL);\n\tcreated_files = g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, g_object_unref);\n\tfolders_created_during_extraction = g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, NULL);\n\tfr_archive_progress_set_total_files (load_data->archive, extract_data->n_files_to_extract);\n\n\twhile ((r = archive_read_next_header (a, &entry)) == ARCHIVE_OK) {\n\t\tconst char    *pathname;\n\t\tchar          *fullpath;\n\t\tconst char    *relative_path;\n\t\tGFile         *file;\n\t\tGFile         *parent;\n\t\tGOutputStream *ostream;\n\t\tconst void    *buffer;\n\t\tsize_t         buffer_size;\n\t\tint64_t        target_offset, actual_offset;\n\t\tGError        *local_error = NULL;\n\t\t__LA_MODE_T    filetype;\n\n\t\tif (g_cancellable_is_cancelled (cancellable))\n\t\t\tbreak;\n\n\t\tpathname = archive_entry_pathname (entry);\n\t\tif (! extract_data_get_extraction_requested (extract_data, pathname)) {\n\t\t\tarchive_read_data_skip (a);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfullpath = (*pathname == '/') ? g_strdup (pathname) : g_strconcat (\"/\", pathname, NULL);\n\t\trelative_path = _g_path_get_relative_basename_safe (fullpath, extract_data->base_dir, extract_data->junk_paths);\n\t\tif (relative_path == NULL) {\n\t\t\tarchive_read_data_skip (a);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfile = g_file_get_child (extract_data->destination, relative_path);\n\n\t\t/* honor the skip_older and overwrite options */\n\n\t\tif ((g_hash_table_lookup (folders_created_during_extraction, file) == NULL)\n\t\t    && (extract_data->skip_older || ! extract_data->overwrite))\n\t\t{\n\t\t\tGFileInfo *info;\n\n\t\t\tinfo = g_file_query_info (file,\n\t\t\t\t\t\t  G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME \",\" G_FILE_ATTRIBUTE_TIME_MODIFIED,\n\t\t\t\t\t\t  G_FILE_QUERY_INFO_NONE,\n\t\t\t\t\t\t  cancellable,\n\t\t\t\t\t\t  &local_error);\n\t\t\tif (info != NULL) {\n\t\t\t\tgboolean skip = FALSE;\n\n\t\t\t\tif (! extract_data->overwrite) {\n\t\t\t\t\tskip = TRUE;\n\t\t\t\t}\n\t\t\t\telse if (extract_data->skip_older) {\n\t\t\t\t\tGTimeVal modification_time;\n\n\t\t\t\t\tg_file_info_get_modification_time (info, &modification_time);\n\t\t\t\t\tif (archive_entry_mtime (entry) < modification_time.tv_sec)\n\t\t\t\t\t\tskip = TRUE;\n\t\t\t\t}\n\n\t\t\t\tg_object_unref (info);\n\n\t\t\t\tif (skip) {\n\t\t\t\t\tg_object_unref (file);\n\n\t\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\t\tfr_archive_progress_inc_completed_bytes (load_data->archive, archive_entry_size_is_set (entry) ? archive_entry_size (entry) : 0);\n\n\t\t\t\t\tif ((extract_data->file_list != NULL) && (--extract_data->n_files_to_extract == 0)) {\n\t\t\t\t\t\tr = ARCHIVE_EOF;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (! g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND)) {\n\t\t\t\t\tload_data->error = local_error;\n\t\t\t\t\tg_object_unref (info);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tg_clear_error (&local_error);\n\t\t\t}\n\t\t}\n\n\t\tfr_archive_progress_inc_completed_files (load_data->archive, 1);\n\n\t\t/* create the file parents */\n\n\t\tparent = g_file_get_parent (file);\n\n\t\tif ((parent != NULL)\n\t\t    && (g_hash_table_lookup (checked_folders, parent) == NULL)\n\t\t    && ! g_file_query_exists (parent, cancellable))\n\t\t{\n\t\t\tif (! _g_file_make_directory_with_parents (parent,\n\t\t\t\t\t\t\t\t   folders_created_during_extraction,\n\t\t\t\t\t\t\t\t   cancellable,\n\t\t\t\t\t\t\t\t   &local_error))\n\t\t\t{\n\t\t\t\tif (! g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_EXISTS))\n\t\t\t\t\tload_data->error = local_error;\n\t\t\t\telse\n\t\t\t\t\tg_clear_error (&local_error);\n\t\t\t}\n\n\t\t\tif (load_data->error == NULL) {\n\t\t\t\tGFile *grandparent;\n\n\t\t\t\tgrandparent = g_object_ref (parent);\n\t\t\t\twhile (grandparent != NULL) {\n\t\t\t\t\tif (g_hash_table_lookup (checked_folders, grandparent) == NULL)\n\t\t\t\t\t\tg_hash_table_insert (checked_folders, grandparent, GINT_TO_POINTER (1));\n\t\t\t\t\tgrandparent = g_file_get_parent (grandparent);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tg_object_unref (parent);\n\n\t\t/* create the file */\n\n\t\tfiletype = archive_entry_filetype (entry);\n\n\t\tif (load_data->error == NULL) {\n\t\t\tconst char  *linkname;\n\n\t\t\tlinkname = archive_entry_hardlink (entry);\n\t\t\tif (linkname != NULL) {\n\t\t\t\tchar        *link_fullpath;\n\t\t\t\tconst char  *relative_path;\n\t\t\t\tGFile       *link_file;\n\t\t\t\tchar        *oldname;\n\t\t\t\tchar        *newname;\n\t\t\t\tint          r;\n\n\t\t\t\tlink_fullpath = (*linkname == '/') ? g_strdup (linkname) : g_strconcat (\"/\", linkname, NULL);\n\t\t\t\trelative_path = _g_path_get_relative_basename_safe (link_fullpath, extract_data->base_dir, extract_data->junk_paths);\n\t\t\t\tif (relative_path == NULL) {\n\t\t\t\t\tg_free (link_fullpath);\n\t\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tlink_file = g_file_get_child (extract_data->destination, relative_path);\n\t\t\t\toldname = g_file_get_path (link_file);\n\t\t\t\tnewname = g_file_get_path (file);\n\n\t\t\t\tif ((oldname != NULL) && (newname != NULL))\n\t\t\t\t\tr = link (oldname, newname);\n\t\t\t\telse\n\t\t\t\t\tr = -1;\n\n\t\t\t\tif (r == 0) {\n\t\t\t\t\t__LA_INT64_T filesize;\n\n\t\t\t\t\tif (archive_entry_size_is_set (entry))\n\t\t\t\t\t\tfilesize = archive_entry_size (entry);\n\t\t\t\t\telse\n\t\t\t\t\t\tfilesize = -1;\n\n\t\t\t\t\tif (filesize > 0)\n\t\t\t\t\t\tfiletype = AE_IFREG; /* treat as a regular file to save the data */\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tchar *uri;\n\t\t\t\t\tchar *msg;\n\n\t\t\t\t\turi = g_file_get_uri (file);\n\t\t\t\t\tmsg = g_strdup_printf (\"Could not create the hard link %s\", uri);\n\t\t\t\t\tload_data->error = g_error_new_literal (G_IO_ERROR, G_IO_ERROR_FAILED, msg);\n\n\t\t\t\t\tg_free (msg);\n\t\t\t\t\tg_free (uri);\n\t\t\t\t}\n\n\t\t\t\tg_free (newname);\n\t\t\t\tg_free (oldname);\n\t\t\t\tg_object_unref (link_file);\n\t\t\t\tg_free (link_fullpath);\n\t\t\t}\n\t\t}\n\n\t\tif (load_data->error == NULL) {\n\t\t\tswitch (filetype) {\n\t\t\tcase AE_IFDIR:\n\t\t\t\tif (! g_file_make_directory (file, cancellable, &local_error)) {\n\t\t\t\t\tif (! g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_EXISTS))\n\t\t\t\t\t\tload_data->error = g_error_copy (local_error);\n\t\t\t\t\tg_clear_error (&local_error);\n\t\t\t\t}\n\t\t\t\tif (load_data->error == NULL)\n\t\t\t\t\tg_hash_table_insert (created_files, g_object_ref (file), _g_file_info_create_from_entry (entry, extract_data));\n\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\tbreak;\n\n\t\t\tcase AE_IFREG:\n\t\t\t\tostream = (GOutputStream *) g_file_replace (file, NULL, FALSE, G_FILE_CREATE_REPLACE_DESTINATION, cancellable, &load_data->error);\n\t\t\t\tif (ostream == NULL)\n\t\t\t\t\tbreak;\n\n\t\t\t\tactual_offset = 0;\n\t\t\t\twhile ((r = archive_read_data_block (a, &buffer, &buffer_size, &target_offset)) == ARCHIVE_OK) {\n\t\t\t\t\tgsize bytes_written;\n\n\t\t\t\t\tif (target_offset > actual_offset) {\n\t\t\t\t\t\tif (! _g_output_stream_add_padding (extract_data, ostream, target_offset, actual_offset, cancellable, &load_data->error))\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tfr_archive_progress_inc_completed_bytes (load_data->archive, target_offset - actual_offset);\n\t\t\t\t\t\tactual_offset = target_offset;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (! g_output_stream_write_all (ostream, buffer, buffer_size, &bytes_written, cancellable, &load_data->error))\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tactual_offset += bytes_written;\n\t\t\t\t\tfr_archive_progress_inc_completed_bytes (load_data->archive, bytes_written);\n\t\t\t\t}\n\n\t\t\t\tif ((r == ARCHIVE_EOF) && (target_offset > actual_offset))\n\t\t\t\t\t_g_output_stream_add_padding (extract_data, ostream, target_offset, actual_offset, cancellable, &load_data->error);\n\n\t\t\t\t_g_object_unref (ostream);\n\n\t\t\t\tif (r != ARCHIVE_EOF)\n\t\t\t\t\tload_data->error = _g_error_new_from_archive_error (archive_error_string (a));\n\t\t\t\telse\n\t\t\t\t\tg_hash_table_insert (created_files, g_object_ref (file), _g_file_info_create_from_entry (entry, extract_data));\n\t\t\t\tbreak;\n\n\t\t\tcase AE_IFLNK:\n\t\t\t\tif (! g_file_make_symbolic_link (file, archive_entry_symlink (entry), cancellable, &local_error)) {\n\t\t\t\t\tif (! g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_EXISTS))\n\t\t\t\t\t\tload_data->error = g_error_copy (local_error);\n\t\t\t\t\tg_clear_error (&local_error);\n\t\t\t\t}\n\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tg_object_unref (file);\n\t\tg_free (fullpath);\n\n\t\tif (load_data->error != NULL)\n\t\t\tbreak;\n\n\t\tif ((extract_data->file_list != NULL) && (--extract_data->n_files_to_extract == 0)) {\n\t\t\tr = ARCHIVE_EOF;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (load_data->error == NULL)\n\t\trestore_original_file_attributes (created_files, cancellable);\n\n\tif ((load_data->error == NULL) && (r != ARCHIVE_EOF))\n\t\tload_data->error = _g_error_new_from_archive_error (archive_error_string (a));\n\tif (load_data->error == NULL)\n\t\tg_cancellable_set_error_if_cancelled (cancellable, &load_data->error);\n\tif (load_data->error != NULL)\n\t\tg_simple_async_result_set_from_error (result, load_data->error);\n\n\tg_hash_table_unref (folders_created_during_extraction);\n\tg_hash_table_unref (created_files);\n\tg_hash_table_unref (checked_folders);\n\tarchive_read_free (a);\n\textract_data_free (extract_data);\n}",
        "func": "static void\nextract_archive_thread (GSimpleAsyncResult *result,\n\t\t\tGObject            *object,\n\t\t\tGCancellable       *cancellable)\n{\n\tExtractData          *extract_data;\n\tLoadData             *load_data;\n\tGHashTable           *checked_folders;\n\tGHashTable           *created_files;\n\tGHashTable           *folders_created_during_extraction;\n\tGHashTable           *external_links;\n\tstruct archive       *a;\n\tstruct archive_entry *entry;\n\tint                   r;\n\n\textract_data = g_simple_async_result_get_op_res_gpointer (result);\n\tload_data = LOAD_DATA (extract_data);\n\n\tr = create_read_object (load_data, &a);\n\tif (r != ARCHIVE_OK) {\n\t\tarchive_read_free(a);\n\t\treturn;\n\t}\n\n\tchecked_folders = g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, NULL);\n\tcreated_files = g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, g_object_unref);\n\tfolders_created_during_extraction = g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, NULL);\n\texternal_links = g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, NULL);\n\tfr_archive_progress_set_total_files (load_data->archive, extract_data->n_files_to_extract);\n\n\twhile ((r = archive_read_next_header (a, &entry)) == ARCHIVE_OK) {\n\t\tconst char    *pathname;\n\t\tchar          *fullpath;\n\t\tconst char    *relative_path;\n\t\tGFile         *file;\n\t\tGFile         *parent;\n\t\tGOutputStream *ostream;\n\t\tconst void    *buffer;\n\t\tsize_t         buffer_size;\n\t\tint64_t        target_offset, actual_offset;\n\t\tGError        *local_error = NULL;\n\t\t__LA_MODE_T    filetype;\n\n\t\tif (g_cancellable_is_cancelled (cancellable))\n\t\t\tbreak;\n\n\t\tpathname = archive_entry_pathname (entry);\n\t\tif (! extract_data_get_extraction_requested (extract_data, pathname)) {\n\t\t\tarchive_read_data_skip (a);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfullpath = (*pathname == '/') ? g_strdup (pathname) : g_strconcat (\"/\", pathname, NULL);\n\t\trelative_path = _g_path_get_relative_basename_safe (fullpath, extract_data->base_dir, extract_data->junk_paths);\n\t\tif (relative_path == NULL) {\n\t\t\tfr_archive_progress_inc_completed_files (load_data->archive, 1);\n\t\t\tfr_archive_progress_inc_completed_bytes (load_data->archive, archive_entry_size_is_set (entry) ? archive_entry_size (entry) : 0);\n\t\t\tarchive_read_data_skip (a);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (_g_path_is_external_to_destination (relative_path, extract_data->destination, external_links)) {\n\t\t\tfr_archive_progress_inc_completed_files (load_data->archive, 1);\n\t\t\tfr_archive_progress_inc_completed_bytes (load_data->archive, archive_entry_size_is_set (entry) ? archive_entry_size (entry) : 0);\n\t\t\tarchive_read_data_skip (a);\n\t\t\tcontinue;\n\t\t}\n\n\t\tfile = g_file_get_child (extract_data->destination, relative_path);\n\n\t\t/* honor the skip_older and overwrite options */\n\n\t\tif ((g_hash_table_lookup (folders_created_during_extraction, file) == NULL)\n\t\t    && (extract_data->skip_older || ! extract_data->overwrite))\n\t\t{\n\t\t\tGFileInfo *info;\n\n\t\t\tinfo = g_file_query_info (file,\n\t\t\t\t\t\t  G_FILE_ATTRIBUTE_STANDARD_DISPLAY_NAME \",\" G_FILE_ATTRIBUTE_TIME_MODIFIED,\n\t\t\t\t\t\t  G_FILE_QUERY_INFO_NONE,\n\t\t\t\t\t\t  cancellable,\n\t\t\t\t\t\t  &local_error);\n\t\t\tif (info != NULL) {\n\t\t\t\tgboolean skip = FALSE;\n\n\t\t\t\tif (! extract_data->overwrite) {\n\t\t\t\t\tskip = TRUE;\n\t\t\t\t}\n\t\t\t\telse if (extract_data->skip_older) {\n\t\t\t\t\tGTimeVal modification_time;\n\n\t\t\t\t\tg_file_info_get_modification_time (info, &modification_time);\n\t\t\t\t\tif (archive_entry_mtime (entry) < modification_time.tv_sec)\n\t\t\t\t\t\tskip = TRUE;\n\t\t\t\t}\n\n\t\t\t\tg_object_unref (info);\n\n\t\t\t\tif (skip) {\n\t\t\t\t\tg_object_unref (file);\n\n\t\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\t\tfr_archive_progress_inc_completed_bytes (load_data->archive, archive_entry_size_is_set (entry) ? archive_entry_size (entry) : 0);\n\n\t\t\t\t\tif ((extract_data->file_list != NULL) && (--extract_data->n_files_to_extract == 0)) {\n\t\t\t\t\t\tr = ARCHIVE_EOF;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (! g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_NOT_FOUND)) {\n\t\t\t\t\tload_data->error = local_error;\n\t\t\t\t\tg_object_unref (info);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tg_clear_error (&local_error);\n\t\t\t}\n\t\t}\n\n\t\tfr_archive_progress_inc_completed_files (load_data->archive, 1);\n\n\t\t/* create the file parents */\n\n\t\tparent = g_file_get_parent (file);\n\n\t\tif ((parent != NULL)\n\t\t    && (g_hash_table_lookup (checked_folders, parent) == NULL)\n\t\t    && ! g_file_query_exists (parent, cancellable))\n\t\t{\n\t\t\tif (! _g_file_make_directory_with_parents (parent,\n\t\t\t\t\t\t\t\t   folders_created_during_extraction,\n\t\t\t\t\t\t\t\t   cancellable,\n\t\t\t\t\t\t\t\t   &local_error))\n\t\t\t{\n\t\t\t\tif (! g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_EXISTS))\n\t\t\t\t\tload_data->error = local_error;\n\t\t\t\telse\n\t\t\t\t\tg_clear_error (&local_error);\n\t\t\t}\n\n\t\t\tif (load_data->error == NULL) {\n\t\t\t\tGFile *grandparent;\n\n\t\t\t\tgrandparent = g_object_ref (parent);\n\t\t\t\twhile (grandparent != NULL) {\n\t\t\t\t\tif (g_hash_table_lookup (checked_folders, grandparent) == NULL)\n\t\t\t\t\t\tg_hash_table_insert (checked_folders, grandparent, GINT_TO_POINTER (1));\n\t\t\t\t\tgrandparent = g_file_get_parent (grandparent);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tg_object_unref (parent);\n\n\t\t/* create the file */\n\n\t\tfiletype = archive_entry_filetype (entry);\n\n\t\tif (load_data->error == NULL) {\n\t\t\tconst char  *linkname;\n\n\t\t\tlinkname = archive_entry_hardlink (entry);\n\t\t\tif (linkname != NULL) {\n\t\t\t\tchar        *link_fullpath;\n\t\t\t\tconst char  *relative_path;\n\t\t\t\tGFile       *link_file;\n\t\t\t\tchar        *oldname;\n\t\t\t\tchar        *newname;\n\t\t\t\tint          r;\n\n\t\t\t\tlink_fullpath = (*linkname == '/') ? g_strdup (linkname) : g_strconcat (\"/\", linkname, NULL);\n\t\t\t\trelative_path = _g_path_get_relative_basename_safe (link_fullpath, extract_data->base_dir, extract_data->junk_paths);\n\t\t\t\tif (relative_path == NULL) {\n\t\t\t\t\tg_free (link_fullpath);\n\t\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tlink_file = g_file_get_child (extract_data->destination, relative_path);\n\t\t\t\toldname = g_file_get_path (link_file);\n\t\t\t\tnewname = g_file_get_path (file);\n\n\t\t\t\tif ((oldname != NULL) && (newname != NULL))\n\t\t\t\t\tr = link (oldname, newname);\n\t\t\t\telse\n\t\t\t\t\tr = -1;\n\n\t\t\t\tif (r == 0) {\n\t\t\t\t\t__LA_INT64_T filesize;\n\n\t\t\t\t\tif (archive_entry_size_is_set (entry))\n\t\t\t\t\t\tfilesize = archive_entry_size (entry);\n\t\t\t\t\telse\n\t\t\t\t\t\tfilesize = -1;\n\n\t\t\t\t\tif (filesize > 0)\n\t\t\t\t\t\tfiletype = AE_IFREG; /* treat as a regular file to save the data */\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tchar *uri;\n\t\t\t\t\tchar *msg;\n\n\t\t\t\t\turi = g_file_get_uri (file);\n\t\t\t\t\tmsg = g_strdup_printf (\"Could not create the hard link %s\", uri);\n\t\t\t\t\tload_data->error = g_error_new_literal (G_IO_ERROR, G_IO_ERROR_FAILED, msg);\n\n\t\t\t\t\tg_free (msg);\n\t\t\t\t\tg_free (uri);\n\t\t\t\t}\n\n\t\t\t\tg_free (newname);\n\t\t\t\tg_free (oldname);\n\t\t\t\tg_object_unref (link_file);\n\t\t\t\tg_free (link_fullpath);\n\t\t\t}\n\t\t}\n\n\t\tif (load_data->error == NULL) {\n\t\t\tswitch (filetype) {\n\t\t\tcase AE_IFDIR:\n\t\t\t\tif (! g_file_make_directory (file, cancellable, &local_error)) {\n\t\t\t\t\tif (! g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_EXISTS))\n\t\t\t\t\t\tload_data->error = g_error_copy (local_error);\n\t\t\t\t\tg_clear_error (&local_error);\n\t\t\t\t}\n\t\t\t\tif (load_data->error == NULL)\n\t\t\t\t\tg_hash_table_insert (created_files, g_object_ref (file), _g_file_info_create_from_entry (entry, extract_data));\n\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\tbreak;\n\n\t\t\tcase AE_IFREG:\n\t\t\t\tostream = (GOutputStream *) g_file_replace (file, NULL, FALSE, G_FILE_CREATE_REPLACE_DESTINATION, cancellable, &load_data->error);\n\t\t\t\tif (ostream == NULL)\n\t\t\t\t\tbreak;\n\n\t\t\t\tactual_offset = 0;\n\t\t\t\twhile ((r = archive_read_data_block (a, &buffer, &buffer_size, &target_offset)) == ARCHIVE_OK) {\n\t\t\t\t\tgsize bytes_written;\n\n\t\t\t\t\tif (target_offset > actual_offset) {\n\t\t\t\t\t\tif (! _g_output_stream_add_padding (extract_data, ostream, target_offset, actual_offset, cancellable, &load_data->error))\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tfr_archive_progress_inc_completed_bytes (load_data->archive, target_offset - actual_offset);\n\t\t\t\t\t\tactual_offset = target_offset;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (! g_output_stream_write_all (ostream, buffer, buffer_size, &bytes_written, cancellable, &load_data->error))\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tactual_offset += bytes_written;\n\t\t\t\t\tfr_archive_progress_inc_completed_bytes (load_data->archive, bytes_written);\n\t\t\t\t}\n\n\t\t\t\tif ((r == ARCHIVE_EOF) && (target_offset > actual_offset))\n\t\t\t\t\t_g_output_stream_add_padding (extract_data, ostream, target_offset, actual_offset, cancellable, &load_data->error);\n\n\t\t\t\t_g_object_unref (ostream);\n\n\t\t\t\tif (r != ARCHIVE_EOF)\n\t\t\t\t\tload_data->error = _g_error_new_from_archive_error (archive_error_string (a));\n\t\t\t\telse\n\t\t\t\t\tg_hash_table_insert (created_files, g_object_ref (file), _g_file_info_create_from_entry (entry, extract_data));\n\t\t\t\tbreak;\n\n\t\t\tcase AE_IFLNK:\n\t\t\t\tif (! g_file_make_symbolic_link (file, archive_entry_symlink (entry), cancellable, &local_error)) {\n\t\t\t\t\tif (! g_error_matches (local_error, G_IO_ERROR, G_IO_ERROR_EXISTS))\n\t\t\t\t\t\tload_data->error = g_error_copy (local_error);\n\t\t\t\t\tg_clear_error (&local_error);\n\t\t\t\t}\n\t\t\t\telse if (_symlink_is_external_to_destination (file, archive_entry_symlink (entry), extract_data->destination, external_links))\n\t\t\t\t\tg_hash_table_insert (external_links, g_object_ref (file), GINT_TO_POINTER (1));\n\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tarchive_read_data_skip (a);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tg_object_unref (file);\n\t\tg_free (fullpath);\n\n\t\tif (load_data->error != NULL)\n\t\t\tbreak;\n\n\t\tif ((extract_data->file_list != NULL) && (--extract_data->n_files_to_extract == 0)) {\n\t\t\tr = ARCHIVE_EOF;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (load_data->error == NULL)\n\t\trestore_original_file_attributes (created_files, cancellable);\n\n\tif ((load_data->error == NULL) && (r != ARCHIVE_EOF))\n\t\tload_data->error = _g_error_new_from_archive_error (archive_error_string (a));\n\tif (load_data->error == NULL)\n\t\tg_cancellable_set_error_if_cancelled (cancellable, &load_data->error);\n\tif (load_data->error != NULL)\n\t\tg_simple_async_result_set_from_error (result, load_data->error);\n\n\tg_hash_table_unref (folders_created_during_extraction);\n\tg_hash_table_unref (created_files);\n\tg_hash_table_unref (checked_folders);\n\tg_hash_table_unref (external_links);\n\tarchive_read_free (a);\n\textract_data_free (extract_data);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -8,6 +8,7 @@\n \tGHashTable           *checked_folders;\n \tGHashTable           *created_files;\n \tGHashTable           *folders_created_during_extraction;\n+\tGHashTable           *external_links;\n \tstruct archive       *a;\n \tstruct archive_entry *entry;\n \tint                   r;\n@@ -24,6 +25,7 @@\n \tchecked_folders = g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, NULL);\n \tcreated_files = g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, g_object_unref);\n \tfolders_created_during_extraction = g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, NULL);\n+\texternal_links = g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, NULL);\n \tfr_archive_progress_set_total_files (load_data->archive, extract_data->n_files_to_extract);\n \n \twhile ((r = archive_read_next_header (a, &entry)) == ARCHIVE_OK) {\n@@ -51,6 +53,15 @@\n \t\tfullpath = (*pathname == '/') ? g_strdup (pathname) : g_strconcat (\"/\", pathname, NULL);\n \t\trelative_path = _g_path_get_relative_basename_safe (fullpath, extract_data->base_dir, extract_data->junk_paths);\n \t\tif (relative_path == NULL) {\n+\t\t\tfr_archive_progress_inc_completed_files (load_data->archive, 1);\n+\t\t\tfr_archive_progress_inc_completed_bytes (load_data->archive, archive_entry_size_is_set (entry) ? archive_entry_size (entry) : 0);\n+\t\t\tarchive_read_data_skip (a);\n+\t\t\tcontinue;\n+\t\t}\n+\n+\t\tif (_g_path_is_external_to_destination (relative_path, extract_data->destination, external_links)) {\n+\t\t\tfr_archive_progress_inc_completed_files (load_data->archive, 1);\n+\t\t\tfr_archive_progress_inc_completed_bytes (load_data->archive, archive_entry_size_is_set (entry) ? archive_entry_size (entry) : 0);\n \t\t\tarchive_read_data_skip (a);\n \t\t\tcontinue;\n \t\t}\n@@ -259,6 +270,8 @@\n \t\t\t\t\t\tload_data->error = g_error_copy (local_error);\n \t\t\t\t\tg_clear_error (&local_error);\n \t\t\t\t}\n+\t\t\t\telse if (_symlink_is_external_to_destination (file, archive_entry_symlink (entry), extract_data->destination, external_links))\n+\t\t\t\t\tg_hash_table_insert (external_links, g_object_ref (file), GINT_TO_POINTER (1));\n \t\t\t\tarchive_read_data_skip (a);\n \t\t\t\tbreak;\n \n@@ -293,6 +306,7 @@\n \tg_hash_table_unref (folders_created_during_extraction);\n \tg_hash_table_unref (created_files);\n \tg_hash_table_unref (checked_folders);\n+\tg_hash_table_unref (external_links);\n \tarchive_read_free (a);\n \textract_data_free (extract_data);\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tGHashTable           *external_links;",
                "\texternal_links = g_hash_table_new_full (g_file_hash, (GEqualFunc) g_file_equal, g_object_unref, NULL);",
                "\t\t\tfr_archive_progress_inc_completed_files (load_data->archive, 1);",
                "\t\t\tfr_archive_progress_inc_completed_bytes (load_data->archive, archive_entry_size_is_set (entry) ? archive_entry_size (entry) : 0);",
                "\t\t\tarchive_read_data_skip (a);",
                "\t\t\tcontinue;",
                "\t\t}",
                "",
                "\t\tif (_g_path_is_external_to_destination (relative_path, extract_data->destination, external_links)) {",
                "\t\t\tfr_archive_progress_inc_completed_files (load_data->archive, 1);",
                "\t\t\tfr_archive_progress_inc_completed_bytes (load_data->archive, archive_entry_size_is_set (entry) ? archive_entry_size (entry) : 0);",
                "\t\t\t\telse if (_symlink_is_external_to_destination (file, archive_entry_symlink (entry), extract_data->destination, external_links))",
                "\t\t\t\t\tg_hash_table_insert (external_links, g_object_ref (file), GINT_TO_POINTER (1));",
                "\tg_hash_table_unref (external_links);"
            ]
        }
    }
]