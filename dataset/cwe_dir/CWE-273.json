[
    {
        "cve_id": "CVE-2022-0358",
        "func_name": "qemu-project/qemu/main",
        "description": "A flaw was found in the QEMU virtio-fs shared file system daemon (virtiofsd) implementation. This flaw is strictly related to CVE-2018-13405. A local guest user can create files in the directories shared by virtio-fs with unintended group ownership in a scenario where a directory is SGID to a certain group and is writable by a user who is not a member of the group. This could allow a malicious unprivileged user inside the guest to gain access to resources accessible to the root group, potentially escalating their privileges within the guest. A malicious local user in the host might also leverage this unexpected executable file created by the guest to escalate their privileges on the host system.",
        "git_url": "https://gitlab.com/qemu-project/qemu/-/commit/449e8171f96a6a944d1f3b7d3627ae059eae21ca",
        "commit_title": "virtiofsd: Drop membership of all supplementary groups (CVE-2022-0358)",
        "commit_text": " At the start, drop membership of all supplementary groups. This is not required.  If we have membership of \"root\" supplementary group and when we switch uid/gid using setresuid/setsgid, we still retain membership of existing supplemntary groups. And that can allow some operations which are not normally allowed.  For example, if root in guest creates a dir as follows.  $ mkdir -m 03777 test_dir  This sets SGID on dir as well as allows unprivileged users to write into this dir.  And now as unprivileged user open file as follows.  $ su test $ fd = open(\"test_dir/priviledge_id\", O_RDWR|O_CREAT|O_EXCL, 02755);  This will create SGID set executable in test_dir/.  And that's a problem because now an unpriviliged user can execute it, get egid=0 and get access to resources owned by \"root\" group. This is privilege escalation.  Suggested-by: Miklos Szeredi <mszeredi@redhat.com> Message-Id: <YfBGoriS38eBQrAb@redhat.com>   dgilbert: Fixed missing {}'s style nit ",
        "func_before": "int main(int argc, char *argv[])\n{\n    struct fuse_args args = FUSE_ARGS_INIT(argc, argv);\n    struct fuse_session *se;\n    struct fuse_cmdline_opts opts;\n    struct lo_data lo = {\n        .sandbox = SANDBOX_NAMESPACE,\n        .debug = 0,\n        .writeback = 0,\n        .posix_lock = 0,\n        .allow_direct_io = 0,\n        .proc_self_fd = -1,\n        .user_killpriv_v2 = -1,\n        .user_posix_acl = -1,\n    };\n    struct lo_map_elem *root_elem;\n    struct lo_map_elem *reserve_elem;\n    int ret = -1;\n\n    /* Initialize time conversion information for localtime_r(). */\n    tzset();\n\n    /* Don't mask creation mode, kernel already did that */\n    umask(0);\n\n    qemu_init_exec_dir(argv[0]);\n\n    pthread_mutex_init(&lo.mutex, NULL);\n    lo.inodes = g_hash_table_new(lo_key_hash, lo_key_equal);\n    lo.root.fd = -1;\n    lo.root.fuse_ino = FUSE_ROOT_ID;\n    lo.cache = CACHE_AUTO;\n\n    /*\n     * Set up the ino map like this:\n     * [0] Reserved (will not be used)\n     * [1] Root inode\n     */\n    lo_map_init(&lo.ino_map);\n    reserve_elem = lo_map_reserve(&lo.ino_map, 0);\n    if (!reserve_elem) {\n        fuse_log(FUSE_LOG_ERR, \"failed to alloc reserve_elem.\\n\");\n        goto err_out1;\n    }\n    reserve_elem->in_use = false;\n    root_elem = lo_map_reserve(&lo.ino_map, lo.root.fuse_ino);\n    if (!root_elem) {\n        fuse_log(FUSE_LOG_ERR, \"failed to alloc root_elem.\\n\");\n        goto err_out1;\n    }\n    root_elem->inode = &lo.root;\n\n    lo_map_init(&lo.dirp_map);\n    lo_map_init(&lo.fd_map);\n\n    if (fuse_parse_cmdline(&args, &opts) != 0) {\n        goto err_out1;\n    }\n    fuse_set_log_func(log_func);\n    use_syslog = opts.syslog;\n    if (use_syslog) {\n        openlog(\"virtiofsd\", LOG_PID, LOG_DAEMON);\n    }\n\n    if (opts.show_help) {\n        printf(\"usage: %s [options]\\n\\n\", argv[0]);\n        fuse_cmdline_help();\n        printf(\"    -o source=PATH             shared directory tree\\n\");\n        fuse_lowlevel_help();\n        ret = 0;\n        goto err_out1;\n    } else if (opts.show_version) {\n        qemu_version();\n        fuse_lowlevel_version();\n        ret = 0;\n        goto err_out1;\n    } else if (opts.print_capabilities) {\n        print_capabilities();\n        ret = 0;\n        goto err_out1;\n    }\n\n    if (fuse_opt_parse(&args, &lo, lo_opts, NULL) == -1) {\n        goto err_out1;\n    }\n\n    if (opts.log_level != 0) {\n        current_log_level = opts.log_level;\n    } else {\n        /* default log level is INFO */\n        current_log_level = FUSE_LOG_INFO;\n    }\n    lo.debug = opts.debug;\n    if (lo.debug) {\n        current_log_level = FUSE_LOG_DEBUG;\n    }\n    if (lo.source) {\n        struct stat stat;\n        int res;\n\n        res = lstat(lo.source, &stat);\n        if (res == -1) {\n            fuse_log(FUSE_LOG_ERR, \"failed to stat source (\\\"%s\\\"): %m\\n\",\n                     lo.source);\n            exit(1);\n        }\n        if (!S_ISDIR(stat.st_mode)) {\n            fuse_log(FUSE_LOG_ERR, \"source is not a directory\\n\");\n            exit(1);\n        }\n    } else {\n        lo.source = strdup(\"/\");\n        if (!lo.source) {\n            fuse_log(FUSE_LOG_ERR, \"failed to strdup source\\n\");\n            goto err_out1;\n        }\n    }\n\n    if (lo.xattrmap) {\n        lo.xattr = 1;\n        parse_xattrmap(&lo);\n    }\n\n    if (!lo.timeout_set) {\n        switch (lo.cache) {\n        case CACHE_NONE:\n            lo.timeout = 0.0;\n            break;\n\n        case CACHE_AUTO:\n            lo.timeout = 1.0;\n            break;\n\n        case CACHE_ALWAYS:\n            lo.timeout = 86400.0;\n            break;\n        }\n    } else if (lo.timeout < 0) {\n        fuse_log(FUSE_LOG_ERR, \"timeout is negative (%lf)\\n\", lo.timeout);\n        exit(1);\n    }\n\n    if (lo.user_posix_acl == 1 && !lo.xattr) {\n        fuse_log(FUSE_LOG_ERR, \"Can't enable posix ACLs. xattrs are disabled.\"\n                 \"\\n\");\n        exit(1);\n    }\n\n    lo.use_statx = true;\n\n    se = fuse_session_new(&args, &lo_oper, sizeof(lo_oper), &lo);\n    if (se == NULL) {\n        goto err_out1;\n    }\n\n    if (fuse_set_signal_handlers(se) != 0) {\n        goto err_out2;\n    }\n\n    if (fuse_session_mount(se) != 0) {\n        goto err_out3;\n    }\n\n    fuse_daemonize(opts.foreground);\n\n    setup_nofile_rlimit(opts.rlimit_nofile);\n\n    /* Must be before sandbox since it wants /proc */\n    setup_capng();\n\n    setup_sandbox(&lo, se, opts.syslog);\n\n    setup_root(&lo, &lo.root);\n    /* Block until ctrl+c or fusermount -u */\n    ret = virtio_loop(se);\n\n    fuse_session_unmount(se);\n    cleanup_capng();\nerr_out3:\n    fuse_remove_signal_handlers(se);\nerr_out2:\n    fuse_session_destroy(se);\nerr_out1:\n    fuse_opt_free_args(&args);\n\n    fuse_lo_data_cleanup(&lo);\n\n    return ret ? 1 : 0;\n}",
        "func": "int main(int argc, char *argv[])\n{\n    struct fuse_args args = FUSE_ARGS_INIT(argc, argv);\n    struct fuse_session *se;\n    struct fuse_cmdline_opts opts;\n    struct lo_data lo = {\n        .sandbox = SANDBOX_NAMESPACE,\n        .debug = 0,\n        .writeback = 0,\n        .posix_lock = 0,\n        .allow_direct_io = 0,\n        .proc_self_fd = -1,\n        .user_killpriv_v2 = -1,\n        .user_posix_acl = -1,\n    };\n    struct lo_map_elem *root_elem;\n    struct lo_map_elem *reserve_elem;\n    int ret = -1;\n\n    /* Initialize time conversion information for localtime_r(). */\n    tzset();\n\n    /* Don't mask creation mode, kernel already did that */\n    umask(0);\n\n    qemu_init_exec_dir(argv[0]);\n\n    drop_supplementary_groups();\n\n    pthread_mutex_init(&lo.mutex, NULL);\n    lo.inodes = g_hash_table_new(lo_key_hash, lo_key_equal);\n    lo.root.fd = -1;\n    lo.root.fuse_ino = FUSE_ROOT_ID;\n    lo.cache = CACHE_AUTO;\n\n    /*\n     * Set up the ino map like this:\n     * [0] Reserved (will not be used)\n     * [1] Root inode\n     */\n    lo_map_init(&lo.ino_map);\n    reserve_elem = lo_map_reserve(&lo.ino_map, 0);\n    if (!reserve_elem) {\n        fuse_log(FUSE_LOG_ERR, \"failed to alloc reserve_elem.\\n\");\n        goto err_out1;\n    }\n    reserve_elem->in_use = false;\n    root_elem = lo_map_reserve(&lo.ino_map, lo.root.fuse_ino);\n    if (!root_elem) {\n        fuse_log(FUSE_LOG_ERR, \"failed to alloc root_elem.\\n\");\n        goto err_out1;\n    }\n    root_elem->inode = &lo.root;\n\n    lo_map_init(&lo.dirp_map);\n    lo_map_init(&lo.fd_map);\n\n    if (fuse_parse_cmdline(&args, &opts) != 0) {\n        goto err_out1;\n    }\n    fuse_set_log_func(log_func);\n    use_syslog = opts.syslog;\n    if (use_syslog) {\n        openlog(\"virtiofsd\", LOG_PID, LOG_DAEMON);\n    }\n\n    if (opts.show_help) {\n        printf(\"usage: %s [options]\\n\\n\", argv[0]);\n        fuse_cmdline_help();\n        printf(\"    -o source=PATH             shared directory tree\\n\");\n        fuse_lowlevel_help();\n        ret = 0;\n        goto err_out1;\n    } else if (opts.show_version) {\n        qemu_version();\n        fuse_lowlevel_version();\n        ret = 0;\n        goto err_out1;\n    } else if (opts.print_capabilities) {\n        print_capabilities();\n        ret = 0;\n        goto err_out1;\n    }\n\n    if (fuse_opt_parse(&args, &lo, lo_opts, NULL) == -1) {\n        goto err_out1;\n    }\n\n    if (opts.log_level != 0) {\n        current_log_level = opts.log_level;\n    } else {\n        /* default log level is INFO */\n        current_log_level = FUSE_LOG_INFO;\n    }\n    lo.debug = opts.debug;\n    if (lo.debug) {\n        current_log_level = FUSE_LOG_DEBUG;\n    }\n    if (lo.source) {\n        struct stat stat;\n        int res;\n\n        res = lstat(lo.source, &stat);\n        if (res == -1) {\n            fuse_log(FUSE_LOG_ERR, \"failed to stat source (\\\"%s\\\"): %m\\n\",\n                     lo.source);\n            exit(1);\n        }\n        if (!S_ISDIR(stat.st_mode)) {\n            fuse_log(FUSE_LOG_ERR, \"source is not a directory\\n\");\n            exit(1);\n        }\n    } else {\n        lo.source = strdup(\"/\");\n        if (!lo.source) {\n            fuse_log(FUSE_LOG_ERR, \"failed to strdup source\\n\");\n            goto err_out1;\n        }\n    }\n\n    if (lo.xattrmap) {\n        lo.xattr = 1;\n        parse_xattrmap(&lo);\n    }\n\n    if (!lo.timeout_set) {\n        switch (lo.cache) {\n        case CACHE_NONE:\n            lo.timeout = 0.0;\n            break;\n\n        case CACHE_AUTO:\n            lo.timeout = 1.0;\n            break;\n\n        case CACHE_ALWAYS:\n            lo.timeout = 86400.0;\n            break;\n        }\n    } else if (lo.timeout < 0) {\n        fuse_log(FUSE_LOG_ERR, \"timeout is negative (%lf)\\n\", lo.timeout);\n        exit(1);\n    }\n\n    if (lo.user_posix_acl == 1 && !lo.xattr) {\n        fuse_log(FUSE_LOG_ERR, \"Can't enable posix ACLs. xattrs are disabled.\"\n                 \"\\n\");\n        exit(1);\n    }\n\n    lo.use_statx = true;\n\n    se = fuse_session_new(&args, &lo_oper, sizeof(lo_oper), &lo);\n    if (se == NULL) {\n        goto err_out1;\n    }\n\n    if (fuse_set_signal_handlers(se) != 0) {\n        goto err_out2;\n    }\n\n    if (fuse_session_mount(se) != 0) {\n        goto err_out3;\n    }\n\n    fuse_daemonize(opts.foreground);\n\n    setup_nofile_rlimit(opts.rlimit_nofile);\n\n    /* Must be before sandbox since it wants /proc */\n    setup_capng();\n\n    setup_sandbox(&lo, se, opts.syslog);\n\n    setup_root(&lo, &lo.root);\n    /* Block until ctrl+c or fusermount -u */\n    ret = virtio_loop(se);\n\n    fuse_session_unmount(se);\n    cleanup_capng();\nerr_out3:\n    fuse_remove_signal_handlers(se);\nerr_out2:\n    fuse_session_destroy(se);\nerr_out1:\n    fuse_opt_free_args(&args);\n\n    fuse_lo_data_cleanup(&lo);\n\n    return ret ? 1 : 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -24,6 +24,8 @@\n     umask(0);\n \n     qemu_init_exec_dir(argv[0]);\n+\n+    drop_supplementary_groups();\n \n     pthread_mutex_init(&lo.mutex, NULL);\n     lo.inodes = g_hash_table_new(lo_key_hash, lo_key_equal);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "    drop_supplementary_groups();"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-0278",
        "func_name": "libuv/uv__process_child_init",
        "description": "libuv before 0.10.34 does not properly drop group privileges, which allows context-dependent attackers to gain privileges via unspecified vectors.",
        "git_url": "https://github.com/libuv/libuv/commit/66ab38918c911bcff025562cf06237d7fedaba0c",
        "commit_title": "unix: call setgoups before calling setuid/setgid",
        "commit_text": " Partial fix for #1093",
        "func_before": "static void uv__process_child_init(const uv_process_options_t* options,\n                                   int stdio_count,\n                                   int (*pipes)[2],\n                                   int error_fd) {\n  int close_fd;\n  int use_fd;\n  int fd;\n\n  if (options->flags & UV_PROCESS_DETACHED)\n    setsid();\n\n  for (fd = 0; fd < stdio_count; fd++) {\n    close_fd = pipes[fd][0];\n    use_fd = pipes[fd][1];\n\n    if (use_fd < 0) {\n      if (fd >= 3)\n        continue;\n      else {\n        /* redirect stdin, stdout and stderr to /dev/null even if UV_IGNORE is\n         * set\n         */\n        use_fd = open(\"/dev/null\", fd == 0 ? O_RDONLY : O_RDWR);\n        close_fd = use_fd;\n\n        if (use_fd == -1) {\n        uv__write_int(error_fd, -errno);\n          perror(\"failed to open stdio\");\n          _exit(127);\n        }\n      }\n    }\n\n    if (fd == use_fd)\n      uv__cloexec(use_fd, 0);\n    else\n      dup2(use_fd, fd);\n\n    if (fd <= 2)\n      uv__nonblock(fd, 0);\n\n    if (close_fd != -1)\n      uv__close(close_fd);\n  }\n\n  for (fd = 0; fd < stdio_count; fd++) {\n    use_fd = pipes[fd][1];\n\n    if (use_fd >= 0 && fd != use_fd)\n      close(use_fd);\n  }\n\n  if (options->cwd != NULL && chdir(options->cwd)) {\n    uv__write_int(error_fd, -errno);\n    perror(\"chdir()\");\n    _exit(127);\n  }\n\n  if ((options->flags & UV_PROCESS_SETGID) && setgid(options->gid)) {\n    uv__write_int(error_fd, -errno);\n    perror(\"setgid()\");\n    _exit(127);\n  }\n\n  if ((options->flags & UV_PROCESS_SETUID) && setuid(options->uid)) {\n    uv__write_int(error_fd, -errno);\n    perror(\"setuid()\");\n    _exit(127);\n  }\n\n  if (options->env != NULL) {\n    environ = options->env;\n  }\n\n  execvp(options->file, options->args);\n  uv__write_int(error_fd, -errno);\n  perror(\"execvp()\");\n  _exit(127);\n}",
        "func": "static void uv__process_child_init(const uv_process_options_t* options,\n                                   int stdio_count,\n                                   int (*pipes)[2],\n                                   int error_fd) {\n  int close_fd;\n  int use_fd;\n  int fd;\n\n  if (options->flags & UV_PROCESS_DETACHED)\n    setsid();\n\n  for (fd = 0; fd < stdio_count; fd++) {\n    close_fd = pipes[fd][0];\n    use_fd = pipes[fd][1];\n\n    if (use_fd < 0) {\n      if (fd >= 3)\n        continue;\n      else {\n        /* redirect stdin, stdout and stderr to /dev/null even if UV_IGNORE is\n         * set\n         */\n        use_fd = open(\"/dev/null\", fd == 0 ? O_RDONLY : O_RDWR);\n        close_fd = use_fd;\n\n        if (use_fd == -1) {\n        uv__write_int(error_fd, -errno);\n          perror(\"failed to open stdio\");\n          _exit(127);\n        }\n      }\n    }\n\n    if (fd == use_fd)\n      uv__cloexec(use_fd, 0);\n    else\n      dup2(use_fd, fd);\n\n    if (fd <= 2)\n      uv__nonblock(fd, 0);\n\n    if (close_fd != -1)\n      uv__close(close_fd);\n  }\n\n  for (fd = 0; fd < stdio_count; fd++) {\n    use_fd = pipes[fd][1];\n\n    if (use_fd >= 0 && fd != use_fd)\n      close(use_fd);\n  }\n\n  if (options->cwd != NULL && chdir(options->cwd)) {\n    uv__write_int(error_fd, -errno);\n    perror(\"chdir()\");\n    _exit(127);\n  }\n\n  if (options->flags & (UV_PROCESS_SETUID | UV_PROCESS_SETGID)) {\n    /* When dropping privileges from root, the `setgroups` call will\n     * remove any extraneous groups. If we don't call this, then\n     * even though our uid has dropped, we may still have groups\n     * that enable us to do super-user things. This will fail if we\n     * aren't root, so don't bother checking the return value, this\n     * is just done as an optimistic privilege dropping function.\n     */\n    SAVE_ERRNO(setgroups(0, NULL));\n  }\n\n  if ((options->flags & UV_PROCESS_SETGID) && setgid(options->gid)) {\n    uv__write_int(error_fd, -errno);\n    perror(\"setgid()\");\n    _exit(127);\n  }\n\n  if ((options->flags & UV_PROCESS_SETUID) && setuid(options->uid)) {\n    uv__write_int(error_fd, -errno);\n    perror(\"setuid()\");\n    _exit(127);\n  }\n\n  if (options->env != NULL) {\n    environ = options->env;\n  }\n\n  execvp(options->file, options->args);\n  uv__write_int(error_fd, -errno);\n  perror(\"execvp()\");\n  _exit(127);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -56,6 +56,17 @@\n     _exit(127);\n   }\n \n+  if (options->flags & (UV_PROCESS_SETUID | UV_PROCESS_SETGID)) {\n+    /* When dropping privileges from root, the `setgroups` call will\n+     * remove any extraneous groups. If we don't call this, then\n+     * even though our uid has dropped, we may still have groups\n+     * that enable us to do super-user things. This will fail if we\n+     * aren't root, so don't bother checking the return value, this\n+     * is just done as an optimistic privilege dropping function.\n+     */\n+    SAVE_ERRNO(setgroups(0, NULL));\n+  }\n+\n   if ((options->flags & UV_PROCESS_SETGID) && setgid(options->gid)) {\n     uv__write_int(error_fd, -errno);\n     perror(\"setgid()\");",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "  if (options->flags & (UV_PROCESS_SETUID | UV_PROCESS_SETGID)) {",
                "    /* When dropping privileges from root, the `setgroups` call will",
                "     * remove any extraneous groups. If we don't call this, then",
                "     * even though our uid has dropped, we may still have groups",
                "     * that enable us to do super-user things. This will fail if we",
                "     * aren't root, so don't bother checking the return value, this",
                "     * is just done as an optimistic privilege dropping function.",
                "     */",
                "    SAVE_ERRNO(setgroups(0, NULL));",
                "  }",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2021-3982",
        "func_name": "GNOME/mutter/meta_backend_native_post_init",
        "description": "Linux distributions using CAP_SYS_NICE for gnome-shell may be exposed to a privilege escalation issue. An attacker, with low privilege permissions, may take advantage of the way CAP_SYS_NICE is currently implemented and eventually load code to increase its process scheduler priority leading to possible DoS of other services running in the same machine.",
        "git_url": "https://github.com/GNOME/mutter/commit/820aa18126674dcee73f47afb23ed89b57251e2d",
        "commit_title": "backends/native: Use rtkit to get realtime priority",
        "commit_text": " Instead of using sched_setscheduler directly (and relying that we somehow got CAP_SYS_NICE), use rtkit to do this for us.  Part-of: <https://gitlab.gnome.org/GNOME/mutter/-/merge_requests/2060>",
        "func_before": "static void\nmeta_backend_native_post_init (MetaBackend *backend)\n{\n  MetaSettings *settings = meta_backend_get_settings (backend);\n\n  META_BACKEND_CLASS (meta_backend_native_parent_class)->post_init (backend);\n\n  if (meta_settings_is_experimental_feature_enabled (settings,\n                                                     META_EXPERIMENTAL_FEATURE_RT_SCHEDULER))\n    {\n      int retval;\n      struct sched_param sp = {\n        .sched_priority = sched_get_priority_min (SCHED_RR)\n      };\n\n      retval = sched_setscheduler (0, SCHED_RR | SCHED_RESET_ON_FORK, &sp);\n\n      if (retval != 0)\n        g_warning (\"Failed to set RT scheduler: %m\");\n    }\n\n#ifdef HAVE_REMOTE_DESKTOP\n  maybe_disable_screen_cast_dma_bufs (META_BACKEND_NATIVE (backend));\n#endif\n\n  update_viewports (backend);\n}",
        "func": "static void\nmeta_backend_native_post_init (MetaBackend *backend)\n{\n  MetaSettings *settings = meta_backend_get_settings (backend);\n\n  META_BACKEND_CLASS (meta_backend_native_parent_class)->post_init (backend);\n\n  if (meta_settings_is_experimental_feature_enabled (settings,\n                                                     META_EXPERIMENTAL_FEATURE_RT_SCHEDULER))\n    {\n      g_autoptr (MetaDbusRealtimeKit1) rtkit_proxy = NULL;\n      g_autoptr (GError) error = NULL;\n\n      rtkit_proxy =\n        meta_dbus_realtime_kit1_proxy_new_for_bus_sync (G_BUS_TYPE_SYSTEM,\n                                                        G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES |\n                                                        G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS |\n                                                        G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START,\n                                                        \"org.freedesktop.RealtimeKit1\",\n                                                        \"/org/freedesktop/RealtimeKit1\",\n                                                        NULL,\n                                                        &error);\n\n      if (rtkit_proxy)\n        {\n          uint32_t priority;\n\n          priority = sched_get_priority_min (SCHED_RR);\n          meta_dbus_realtime_kit1_call_make_thread_realtime_sync (rtkit_proxy,\n                                                                  gettid (),\n                                                                  priority,\n                                                                  NULL,\n                                                                  &error);\n        }\n\n      if (error)\n        {\n          g_dbus_error_strip_remote_error (error);\n          g_message (\"Failed to set RT scheduler: %s\", error->message);\n        }\n    }\n\n#ifdef HAVE_REMOTE_DESKTOP\n  maybe_disable_screen_cast_dma_bufs (META_BACKEND_NATIVE (backend));\n#endif\n\n  update_viewports (backend);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -8,15 +8,36 @@\n   if (meta_settings_is_experimental_feature_enabled (settings,\n                                                      META_EXPERIMENTAL_FEATURE_RT_SCHEDULER))\n     {\n-      int retval;\n-      struct sched_param sp = {\n-        .sched_priority = sched_get_priority_min (SCHED_RR)\n-      };\n+      g_autoptr (MetaDbusRealtimeKit1) rtkit_proxy = NULL;\n+      g_autoptr (GError) error = NULL;\n \n-      retval = sched_setscheduler (0, SCHED_RR | SCHED_RESET_ON_FORK, &sp);\n+      rtkit_proxy =\n+        meta_dbus_realtime_kit1_proxy_new_for_bus_sync (G_BUS_TYPE_SYSTEM,\n+                                                        G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES |\n+                                                        G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS |\n+                                                        G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START,\n+                                                        \"org.freedesktop.RealtimeKit1\",\n+                                                        \"/org/freedesktop/RealtimeKit1\",\n+                                                        NULL,\n+                                                        &error);\n \n-      if (retval != 0)\n-        g_warning (\"Failed to set RT scheduler: %m\");\n+      if (rtkit_proxy)\n+        {\n+          uint32_t priority;\n+\n+          priority = sched_get_priority_min (SCHED_RR);\n+          meta_dbus_realtime_kit1_call_make_thread_realtime_sync (rtkit_proxy,\n+                                                                  gettid (),\n+                                                                  priority,\n+                                                                  NULL,\n+                                                                  &error);\n+        }\n+\n+      if (error)\n+        {\n+          g_dbus_error_strip_remote_error (error);\n+          g_message (\"Failed to set RT scheduler: %s\", error->message);\n+        }\n     }\n \n #ifdef HAVE_REMOTE_DESKTOP",
        "diff_line_info": {
            "deleted_lines": [
                "      int retval;",
                "      struct sched_param sp = {",
                "        .sched_priority = sched_get_priority_min (SCHED_RR)",
                "      };",
                "      retval = sched_setscheduler (0, SCHED_RR | SCHED_RESET_ON_FORK, &sp);",
                "      if (retval != 0)",
                "        g_warning (\"Failed to set RT scheduler: %m\");"
            ],
            "added_lines": [
                "      g_autoptr (MetaDbusRealtimeKit1) rtkit_proxy = NULL;",
                "      g_autoptr (GError) error = NULL;",
                "      rtkit_proxy =",
                "        meta_dbus_realtime_kit1_proxy_new_for_bus_sync (G_BUS_TYPE_SYSTEM,",
                "                                                        G_DBUS_PROXY_FLAGS_DO_NOT_LOAD_PROPERTIES |",
                "                                                        G_DBUS_PROXY_FLAGS_DO_NOT_CONNECT_SIGNALS |",
                "                                                        G_DBUS_PROXY_FLAGS_DO_NOT_AUTO_START,",
                "                                                        \"org.freedesktop.RealtimeKit1\",",
                "                                                        \"/org/freedesktop/RealtimeKit1\",",
                "                                                        NULL,",
                "                                                        &error);",
                "      if (rtkit_proxy)",
                "        {",
                "          uint32_t priority;",
                "",
                "          priority = sched_get_priority_min (SCHED_RR);",
                "          meta_dbus_realtime_kit1_call_make_thread_realtime_sync (rtkit_proxy,",
                "                                                                  gettid (),",
                "                                                                  priority,",
                "                                                                  NULL,",
                "                                                                  &error);",
                "        }",
                "",
                "      if (error)",
                "        {",
                "          g_dbus_error_strip_remote_error (error);",
                "          g_message (\"Failed to set RT scheduler: %s\", error->message);",
                "        }"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-18276",
        "func_name": "bminor/bash/disable_priv_mode",
        "description": "An issue was discovered in disable_priv_mode in shell.c in GNU Bash through 5.0 patch 11. By default, if Bash is run with its effective UID not equal to its real UID, it will drop privileges by setting its effective UID to its real UID. However, it does so incorrectly. On Linux and other systems that support \"saved UID\" functionality, the saved UID is not dropped. An attacker with command execution in the shell can use \"enable -f\" for runtime loading of a new builtin, which can be a shared object that calls setuid() and therefore regains privileges. However, binaries running with an effective UID of 0 are unaffected.",
        "git_url": "https://github.com/bminor/bash/commit/951bdaad7a18cc0dc1036bba86b18b90874d39ff",
        "commit_title": "commit bash-20190628 snapshot",
        "commit_text": "",
        "func_before": "void\ndisable_priv_mode ()\n{\n  int e;\n\n  if (setuid (current_user.uid) < 0)\n    {\n      e = errno;\n      sys_error (_(\"cannot set uid to %d: effective uid %d\"), current_user.uid, current_user.euid);\n#if defined (EXIT_ON_SETUID_FAILURE)\n      if (e == EAGAIN)\n\texit (e);\n#endif\n    }\n  if (setgid (current_user.gid) < 0)\n    sys_error (_(\"cannot set gid to %d: effective gid %d\"), current_user.gid, current_user.egid);\n\n  current_user.euid = current_user.uid;\n  current_user.egid = current_user.gid;\n}",
        "func": "void\ndisable_priv_mode ()\n{\n  int e;\n\n#if HAVE_DECL_SETRESUID\n  if (setresuid (current_user.uid, current_user.uid, current_user.uid) < 0)\n#else\n  if (setuid (current_user.uid) < 0)\n#endif\n    {\n      e = errno;\n      sys_error (_(\"cannot set uid to %d: effective uid %d\"), current_user.uid, current_user.euid);\n#if defined (EXIT_ON_SETUID_FAILURE)\n      if (e == EAGAIN)\n\texit (e);\n#endif\n    }\n#if HAVE_DECL_SETRESGID\n  if (setresgid (current_user.gid, current_user.gid, current_user.gid) < 0)\n#else\n  if (setgid (current_user.gid) < 0)\n#endif\n    sys_error (_(\"cannot set gid to %d: effective gid %d\"), current_user.gid, current_user.egid);\n\n  current_user.euid = current_user.uid;\n  current_user.egid = current_user.gid;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,7 +3,11 @@\n {\n   int e;\n \n+#if HAVE_DECL_SETRESUID\n+  if (setresuid (current_user.uid, current_user.uid, current_user.uid) < 0)\n+#else\n   if (setuid (current_user.uid) < 0)\n+#endif\n     {\n       e = errno;\n       sys_error (_(\"cannot set uid to %d: effective uid %d\"), current_user.uid, current_user.euid);\n@@ -12,7 +16,11 @@\n \texit (e);\n #endif\n     }\n+#if HAVE_DECL_SETRESGID\n+  if (setresgid (current_user.gid, current_user.gid, current_user.gid) < 0)\n+#else\n   if (setgid (current_user.gid) < 0)\n+#endif\n     sys_error (_(\"cannot set gid to %d: effective gid %d\"), current_user.gid, current_user.egid);\n \n   current_user.euid = current_user.uid;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "#if HAVE_DECL_SETRESUID",
                "  if (setresuid (current_user.uid, current_user.uid, current_user.uid) < 0)",
                "#else",
                "#endif",
                "#if HAVE_DECL_SETRESGID",
                "  if (setresgid (current_user.gid, current_user.gid, current_user.gid) < 0)",
                "#else",
                "#endif"
            ]
        }
    }
]