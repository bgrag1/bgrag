[
    {
        "cve_id": "CVE-2023-1390",
        "func_name": "torvalds/linux/tipc_link_xmit",
        "description": "A remote denial of service vulnerability was found in the Linux kernelâ€™s TIPC kernel module. The while loop in tipc_link_xmit() hits an unknown state while attempting to parse SKBs, which are not in the queue. Sending two small UDP packets to a system with a UDP bearer results in the CPU utilization for the system to instantly spike to 100%, causing a denial of service condition.",
        "git_url": "https://github.com/torvalds/linux/commit/b77413446408fdd256599daf00d5be72b5f3e7c6",
        "commit_title": "tipc: fix NULL deref in tipc_link_xmit()",
        "commit_text": " The buffer list can have zero skb as following path: tipc_named_node_up()->tipc_node_xmit()->tipc_link_xmit(), so we need to check the list before casting an &sk_buff.  Fault report:  [] tipc: Bulk publication failure  [] general protection fault, probably for non-canonical [#1] PREEMPT [...]  [] KASAN: null-ptr-deref in range [0x00000000000000c8-0x00000000000000cf]  [] CPU: 0 PID: 0 Comm: swapper/0 Kdump: loaded Not tainted 5.10.0-rc4+ #2  [] Hardware name: Bochs ..., BIOS Bochs 01/01/2011  [] RIP: 0010:tipc_link_xmit+0xc1/0x2180  [] Code: 24 b8 00 00 00 00 4d 39 ec 4c 0f 44 e8 e8 d7 0a 10 f9 48 [...]  [] RSP: 0018:ffffc90000006ea0 EFLAGS: 00010202  [] RAX: dffffc0000000000 RBX: ffff8880224da000 RCX: 1ffff11003d3cc0d  [] RDX: 0000000000000019 RSI: ffffffff886007b9 RDI: 00000000000000c8  [] RBP: ffffc90000007018 R08: 0000000000000001 R09: fffff52000000ded  [] R10: 0000000000000003 R11: fffff52000000dec R12: ffffc90000007148  [] R13: 0000000000000000 R14: 0000000000000000 R15: ffffc90000007018  [] FS:  0000000000000000(0000) GS:ffff888037400000(0000) knlGS:000[...]  [] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033  [] CR2: 00007fffd2db5000 CR3: 000000002b08f000 CR4: 00000000000006f0  Link: https://lore.kernel.org/r/20210108071337.3598-1-hoang.h.le@dektech.com.au",
        "func_before": "int tipc_link_xmit(struct tipc_link *l, struct sk_buff_head *list,\n\t\t   struct sk_buff_head *xmitq)\n{\n\tstruct tipc_msg *hdr = buf_msg(skb_peek(list));\n\tstruct sk_buff_head *backlogq = &l->backlogq;\n\tstruct sk_buff_head *transmq = &l->transmq;\n\tstruct sk_buff *skb, *_skb;\n\tu16 bc_ack = l->bc_rcvlink->rcv_nxt - 1;\n\tu16 ack = l->rcv_nxt - 1;\n\tu16 seqno = l->snd_nxt;\n\tint pkt_cnt = skb_queue_len(list);\n\tint imp = msg_importance(hdr);\n\tunsigned int mss = tipc_link_mss(l);\n\tunsigned int cwin = l->window;\n\tunsigned int mtu = l->mtu;\n\tbool new_bundle;\n\tint rc = 0;\n\n\tif (unlikely(msg_size(hdr) > mtu)) {\n\t\tpr_warn(\"Too large msg, purging xmit list %d %d %d %d %d!\\n\",\n\t\t\tskb_queue_len(list), msg_user(hdr),\n\t\t\tmsg_type(hdr), msg_size(hdr), mtu);\n\t\t__skb_queue_purge(list);\n\t\treturn -EMSGSIZE;\n\t}\n\n\t/* Allow oversubscription of one data msg per source at congestion */\n\tif (unlikely(l->backlog[imp].len >= l->backlog[imp].limit)) {\n\t\tif (imp == TIPC_SYSTEM_IMPORTANCE) {\n\t\t\tpr_warn(\"%s<%s>, link overflow\", link_rst_msg, l->name);\n\t\t\treturn -ENOBUFS;\n\t\t}\n\t\trc = link_schedule_user(l, hdr);\n\t}\n\n\tif (pkt_cnt > 1) {\n\t\tl->stats.sent_fragmented++;\n\t\tl->stats.sent_fragments += pkt_cnt;\n\t}\n\n\t/* Prepare each packet for sending, and add to relevant queue: */\n\twhile ((skb = __skb_dequeue(list))) {\n\t\tif (likely(skb_queue_len(transmq) < cwin)) {\n\t\t\thdr = buf_msg(skb);\n\t\t\tmsg_set_seqno(hdr, seqno);\n\t\t\tmsg_set_ack(hdr, ack);\n\t\t\tmsg_set_bcast_ack(hdr, bc_ack);\n\t\t\t_skb = skb_clone(skb, GFP_ATOMIC);\n\t\t\tif (!_skb) {\n\t\t\t\tkfree_skb(skb);\n\t\t\t\t__skb_queue_purge(list);\n\t\t\t\treturn -ENOBUFS;\n\t\t\t}\n\t\t\t__skb_queue_tail(transmq, skb);\n\t\t\ttipc_link_set_skb_retransmit_time(skb, l);\n\t\t\t__skb_queue_tail(xmitq, _skb);\n\t\t\tTIPC_SKB_CB(skb)->ackers = l->ackers;\n\t\t\tl->rcv_unacked = 0;\n\t\t\tl->stats.sent_pkts++;\n\t\t\tseqno++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (tipc_msg_try_bundle(l->backlog[imp].target_bskb, &skb,\n\t\t\t\t\tmss, l->addr, &new_bundle)) {\n\t\t\tif (skb) {\n\t\t\t\t/* Keep a ref. to the skb for next try */\n\t\t\t\tl->backlog[imp].target_bskb = skb;\n\t\t\t\tl->backlog[imp].len++;\n\t\t\t\t__skb_queue_tail(backlogq, skb);\n\t\t\t} else {\n\t\t\t\tif (new_bundle) {\n\t\t\t\t\tl->stats.sent_bundles++;\n\t\t\t\t\tl->stats.sent_bundled++;\n\t\t\t\t}\n\t\t\t\tl->stats.sent_bundled++;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tl->backlog[imp].target_bskb = NULL;\n\t\tl->backlog[imp].len += (1 + skb_queue_len(list));\n\t\t__skb_queue_tail(backlogq, skb);\n\t\tskb_queue_splice_tail_init(list, backlogq);\n\t}\n\tl->snd_nxt = seqno;\n\treturn rc;\n}",
        "func": "int tipc_link_xmit(struct tipc_link *l, struct sk_buff_head *list,\n\t\t   struct sk_buff_head *xmitq)\n{\n\tstruct sk_buff_head *backlogq = &l->backlogq;\n\tstruct sk_buff_head *transmq = &l->transmq;\n\tstruct sk_buff *skb, *_skb;\n\tu16 bc_ack = l->bc_rcvlink->rcv_nxt - 1;\n\tu16 ack = l->rcv_nxt - 1;\n\tu16 seqno = l->snd_nxt;\n\tint pkt_cnt = skb_queue_len(list);\n\tunsigned int mss = tipc_link_mss(l);\n\tunsigned int cwin = l->window;\n\tunsigned int mtu = l->mtu;\n\tstruct tipc_msg *hdr;\n\tbool new_bundle;\n\tint rc = 0;\n\tint imp;\n\n\tif (pkt_cnt <= 0)\n\t\treturn 0;\n\n\thdr = buf_msg(skb_peek(list));\n\tif (unlikely(msg_size(hdr) > mtu)) {\n\t\tpr_warn(\"Too large msg, purging xmit list %d %d %d %d %d!\\n\",\n\t\t\tskb_queue_len(list), msg_user(hdr),\n\t\t\tmsg_type(hdr), msg_size(hdr), mtu);\n\t\t__skb_queue_purge(list);\n\t\treturn -EMSGSIZE;\n\t}\n\n\timp = msg_importance(hdr);\n\t/* Allow oversubscription of one data msg per source at congestion */\n\tif (unlikely(l->backlog[imp].len >= l->backlog[imp].limit)) {\n\t\tif (imp == TIPC_SYSTEM_IMPORTANCE) {\n\t\t\tpr_warn(\"%s<%s>, link overflow\", link_rst_msg, l->name);\n\t\t\treturn -ENOBUFS;\n\t\t}\n\t\trc = link_schedule_user(l, hdr);\n\t}\n\n\tif (pkt_cnt > 1) {\n\t\tl->stats.sent_fragmented++;\n\t\tl->stats.sent_fragments += pkt_cnt;\n\t}\n\n\t/* Prepare each packet for sending, and add to relevant queue: */\n\twhile ((skb = __skb_dequeue(list))) {\n\t\tif (likely(skb_queue_len(transmq) < cwin)) {\n\t\t\thdr = buf_msg(skb);\n\t\t\tmsg_set_seqno(hdr, seqno);\n\t\t\tmsg_set_ack(hdr, ack);\n\t\t\tmsg_set_bcast_ack(hdr, bc_ack);\n\t\t\t_skb = skb_clone(skb, GFP_ATOMIC);\n\t\t\tif (!_skb) {\n\t\t\t\tkfree_skb(skb);\n\t\t\t\t__skb_queue_purge(list);\n\t\t\t\treturn -ENOBUFS;\n\t\t\t}\n\t\t\t__skb_queue_tail(transmq, skb);\n\t\t\ttipc_link_set_skb_retransmit_time(skb, l);\n\t\t\t__skb_queue_tail(xmitq, _skb);\n\t\t\tTIPC_SKB_CB(skb)->ackers = l->ackers;\n\t\t\tl->rcv_unacked = 0;\n\t\t\tl->stats.sent_pkts++;\n\t\t\tseqno++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (tipc_msg_try_bundle(l->backlog[imp].target_bskb, &skb,\n\t\t\t\t\tmss, l->addr, &new_bundle)) {\n\t\t\tif (skb) {\n\t\t\t\t/* Keep a ref. to the skb for next try */\n\t\t\t\tl->backlog[imp].target_bskb = skb;\n\t\t\t\tl->backlog[imp].len++;\n\t\t\t\t__skb_queue_tail(backlogq, skb);\n\t\t\t} else {\n\t\t\t\tif (new_bundle) {\n\t\t\t\t\tl->stats.sent_bundles++;\n\t\t\t\t\tl->stats.sent_bundled++;\n\t\t\t\t}\n\t\t\t\tl->stats.sent_bundled++;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tl->backlog[imp].target_bskb = NULL;\n\t\tl->backlog[imp].len += (1 + skb_queue_len(list));\n\t\t__skb_queue_tail(backlogq, skb);\n\t\tskb_queue_splice_tail_init(list, backlogq);\n\t}\n\tl->snd_nxt = seqno;\n\treturn rc;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,7 +1,6 @@\n int tipc_link_xmit(struct tipc_link *l, struct sk_buff_head *list,\n \t\t   struct sk_buff_head *xmitq)\n {\n-\tstruct tipc_msg *hdr = buf_msg(skb_peek(list));\n \tstruct sk_buff_head *backlogq = &l->backlogq;\n \tstruct sk_buff_head *transmq = &l->transmq;\n \tstruct sk_buff *skb, *_skb;\n@@ -9,13 +8,18 @@\n \tu16 ack = l->rcv_nxt - 1;\n \tu16 seqno = l->snd_nxt;\n \tint pkt_cnt = skb_queue_len(list);\n-\tint imp = msg_importance(hdr);\n \tunsigned int mss = tipc_link_mss(l);\n \tunsigned int cwin = l->window;\n \tunsigned int mtu = l->mtu;\n+\tstruct tipc_msg *hdr;\n \tbool new_bundle;\n \tint rc = 0;\n+\tint imp;\n \n+\tif (pkt_cnt <= 0)\n+\t\treturn 0;\n+\n+\thdr = buf_msg(skb_peek(list));\n \tif (unlikely(msg_size(hdr) > mtu)) {\n \t\tpr_warn(\"Too large msg, purging xmit list %d %d %d %d %d!\\n\",\n \t\t\tskb_queue_len(list), msg_user(hdr),\n@@ -24,6 +28,7 @@\n \t\treturn -EMSGSIZE;\n \t}\n \n+\timp = msg_importance(hdr);\n \t/* Allow oversubscription of one data msg per source at congestion */\n \tif (unlikely(l->backlog[imp].len >= l->backlog[imp].limit)) {\n \t\tif (imp == TIPC_SYSTEM_IMPORTANCE) {",
        "diff_line_info": {
            "deleted_lines": [
                "\tstruct tipc_msg *hdr = buf_msg(skb_peek(list));",
                "\tint imp = msg_importance(hdr);"
            ],
            "added_lines": [
                "\tstruct tipc_msg *hdr;",
                "\tint imp;",
                "\tif (pkt_cnt <= 0)",
                "\t\treturn 0;",
                "",
                "\thdr = buf_msg(skb_peek(list));",
                "\timp = msg_importance(hdr);"
            ]
        }
    }
]