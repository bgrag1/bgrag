[
    {
        "cve_id": "CVE-2022-39264",
        "func_name": "Nheko-Reborn/nheko/handle_olm_message",
        "description": "nheko is a desktop client for the Matrix communication application. All versions below 0.10.2 are vulnerable homeservers inserting malicious secrets, which could lead to man-in-the-middle attacks. Users can upgrade to version 0.10.2 to protect against this issue. As a workaround, one may apply the patch manually, avoid doing verifications of one's own devices, and/or avoid pressing the request button in the settings menu.",
        "git_url": "https://github.com/Nheko-Reborn/nheko/commit/67bee15a389f9b8a9f6c3a340558d1e2319e7199",
        "commit_title": "Prevent the homeserver from inserting malicious secrets",
        "commit_text": " Correctly verify that the reply to a secrets request is actually coming from a verified device. While we did verify that it was us who replied, we didn't properly cancel storing the secret if the sending device was one of ours but was maliciously inserted by the homeserver and unverified. We only send secret requests to verified devices in the first place, so only the homeserver could abuse this issue.  Additionally we protected against malicious secret poisoning by verifying that the secret is actually the reply to a request. This means the server only has 2 places where it can poison the secrets:  - After a verification when we automatically request the secrets - When the user manually hits the request button  It also needs to prevent other secret answers to reach the client first since we ignore all replies after that one.  The impact of this might be quite severe. It could allow the server to replace the cross-signing keys silently and while we might not trust that key, we possibly could trust it in the future if we rely on the stored secret. Similarly this could potentially be abused to make the client trust a malicious online key backup.  If your deployment is not patched yet and you don't control your homeserver, you can protect against this by simply not doing any verifications of your own devices and not pressing the request button in the settings menu.",
        "func_before": "void\nhandle_olm_message(const OlmMessage &msg, const UserKeyCache &otherUserDeviceKeys)\n{\n    nhlog::crypto()->info(\"sender    : {}\", msg.sender);\n    nhlog::crypto()->info(\"sender_key: {}\", msg.sender_key);\n\n    if (msg.sender_key == olm::client()->identity_keys().ed25519) {\n        nhlog::crypto()->warn(\"Ignoring olm message from ourselves!\");\n        return;\n    }\n\n    const auto my_key = olm::client()->identity_keys().curve25519;\n\n    bool failed_decryption = false;\n\n    for (const auto &cipher : msg.ciphertext) {\n        // We skip messages not meant for the current device.\n        if (cipher.first != my_key) {\n            nhlog::crypto()->debug(\n              \"Skipping message for {} since we are {}.\", cipher.first, my_key);\n            continue;\n        }\n\n        const auto type = cipher.second.type;\n        nhlog::crypto()->info(\"type: {}\", type == 0 ? \"OLM_PRE_KEY\" : \"OLM_MESSAGE\");\n\n        auto payload = try_olm_decryption(msg.sender_key, cipher.second);\n\n        if (payload.is_null()) {\n            // Check for PRE_KEY message\n            if (cipher.second.type == 0) {\n                payload = handle_pre_key_olm_message(msg.sender, msg.sender_key, cipher.second);\n            } else {\n                nhlog::crypto()->error(\"Undecryptable olm message!\");\n                failed_decryption = true;\n                continue;\n            }\n        }\n\n        if (!payload.is_null()) {\n            mtx::events::collections::DeviceEvents device_event;\n\n            // Other properties are included in order to prevent an attacker from\n            // publishing someone else's curve25519 keys as their own and subsequently\n            // claiming to have sent messages which they didn't. sender must correspond\n            // to the user who sent the event, recipient to the local user, and\n            // recipient_keys to the local ed25519 key.\n            std::string receiver_ed25519 = payload[\"recipient_keys\"][\"ed25519\"].get<std::string>();\n            if (receiver_ed25519.empty() ||\n                receiver_ed25519 != olm::client()->identity_keys().ed25519) {\n                nhlog::crypto()->warn(\"Decrypted event doesn't include our ed25519: {}\",\n                                      payload.dump());\n                return;\n            }\n            std::string receiver = payload[\"recipient\"].get<std::string>();\n            if (receiver.empty() || receiver != http::client()->user_id().to_string()) {\n                nhlog::crypto()->warn(\"Decrypted event doesn't include our user_id: {}\",\n                                      payload.dump());\n                return;\n            }\n\n            // Clients must confirm that the sender_key and the ed25519 field value\n            // under the keys property match the keys returned by /keys/query for the\n            // given user, and must also verify the signature of the payload. Without\n            // this check, a client cannot be sure that the sender device owns the\n            // private part of the ed25519 key it claims to have in the Olm payload.\n            // This is crucial when the ed25519 key corresponds to a verified device.\n            std::string sender_ed25519 = payload[\"keys\"][\"ed25519\"].get<std::string>();\n            if (sender_ed25519.empty()) {\n                nhlog::crypto()->warn(\"Decrypted event doesn't include sender ed25519: {}\",\n                                      payload.dump());\n                return;\n            }\n\n            bool from_their_device = false;\n            for (const auto &[device_id, key] : otherUserDeviceKeys.device_keys) {\n                auto c_key = key.keys.find(\"curve25519:\" + device_id);\n                auto e_key = key.keys.find(\"ed25519:\" + device_id);\n\n                if (c_key == key.keys.end() || e_key == key.keys.end()) {\n                    nhlog::crypto()->warn(\"Skipping device {} as we have no keys for it.\",\n                                          device_id);\n                } else if (c_key->second == msg.sender_key && e_key->second == sender_ed25519) {\n                    from_their_device = true;\n                    break;\n                }\n            }\n            if (!from_their_device) {\n                nhlog::crypto()->warn(\"Decrypted event isn't sent from a device \"\n                                      \"listed by that user! {}\",\n                                      payload.dump());\n                return;\n            }\n\n            {\n                std::string msg_type       = payload[\"type\"].get<std::string>();\n                nlohmann::json event_array = nlohmann::json::array();\n                event_array.push_back(payload);\n\n                std::vector<mtx::events::collections::DeviceEvents> temp_events;\n                mtx::responses::utils::parse_device_events(event_array, temp_events);\n                if (temp_events.empty()) {\n                    nhlog::crypto()->warn(\"Decrypted unknown event: {}\", payload.dump());\n                    return;\n                }\n                device_event = temp_events.at(0);\n            }\n\n            using namespace mtx::events;\n            if (auto e1 = std::get_if<DeviceEvent<msg::KeyVerificationAccept>>(&device_event)) {\n                ChatPage::instance()->receivedDeviceVerificationAccept(e1->content);\n            } else if (auto e2 =\n                         std::get_if<DeviceEvent<msg::KeyVerificationRequest>>(&device_event)) {\n                ChatPage::instance()->receivedDeviceVerificationRequest(e2->content, e2->sender);\n            } else if (auto e3 =\n                         std::get_if<DeviceEvent<msg::KeyVerificationCancel>>(&device_event)) {\n                ChatPage::instance()->receivedDeviceVerificationCancel(e3->content);\n            } else if (auto e4 = std::get_if<DeviceEvent<msg::KeyVerificationKey>>(&device_event)) {\n                ChatPage::instance()->receivedDeviceVerificationKey(e4->content);\n            } else if (auto e5 = std::get_if<DeviceEvent<msg::KeyVerificationMac>>(&device_event)) {\n                ChatPage::instance()->receivedDeviceVerificationMac(e5->content);\n            } else if (auto e6 =\n                         std::get_if<DeviceEvent<msg::KeyVerificationStart>>(&device_event)) {\n                ChatPage::instance()->receivedDeviceVerificationStart(e6->content, e6->sender);\n            } else if (auto e7 =\n                         std::get_if<DeviceEvent<msg::KeyVerificationReady>>(&device_event)) {\n                ChatPage::instance()->receivedDeviceVerificationReady(e7->content);\n            } else if (auto e8 =\n                         std::get_if<DeviceEvent<msg::KeyVerificationDone>>(&device_event)) {\n                ChatPage::instance()->receivedDeviceVerificationDone(e8->content);\n            } else if (auto roomKey = std::get_if<DeviceEvent<msg::RoomKey>>(&device_event)) {\n                create_inbound_megolm_session(*roomKey, msg.sender_key, sender_ed25519);\n            } else if (auto forwardedRoomKey =\n                         std::get_if<DeviceEvent<msg::ForwardedRoomKey>>(&device_event)) {\n                forwardedRoomKey->content.forwarding_curve25519_key_chain.push_back(msg.sender_key);\n                import_inbound_megolm_session(*forwardedRoomKey);\n            } else if (auto e = std::get_if<DeviceEvent<msg::SecretSend>>(&device_event)) {\n                auto local_user = http::client()->user_id();\n\n                if (msg.sender != local_user.to_string())\n                    return;\n\n                auto secret_name = request_id_to_secret_name.find(e->content.request_id);\n\n                if (secret_name != request_id_to_secret_name.end()) {\n                    nhlog::crypto()->info(\"Received secret: {}\", secret_name->second);\n\n                    mtx::events::msg::SecretRequest secretRequest{};\n                    secretRequest.action = mtx::events::msg::RequestAction::Cancellation;\n                    secretRequest.requesting_device_id = http::client()->device_id();\n                    secretRequest.request_id           = e->content.request_id;\n\n                    auto verificationStatus = cache::verificationStatus(local_user.to_string());\n\n                    if (!verificationStatus)\n                        return;\n\n                    auto deviceKeys = cache::userKeys(local_user.to_string());\n                    std::string sender_device_id;\n                    if (deviceKeys) {\n                        for (auto &[dev, key] : deviceKeys->device_keys) {\n                            if (key.keys[\"curve25519:\" + dev] == msg.sender_key) {\n                                sender_device_id = dev;\n                                break;\n                            }\n                        }\n                    }\n\n                    std::map<mtx::identifiers::User,\n                             std::map<std::string, mtx::events::msg::SecretRequest>>\n                      body;\n\n                    for (const auto &dev : verificationStatus->verified_devices) {\n                        if (dev != secretRequest.requesting_device_id && dev != sender_device_id)\n                            body[local_user][dev] = secretRequest;\n                    }\n\n                    http::client()->send_to_device<mtx::events::msg::SecretRequest>(\n                      http::client()->generate_txn_id(),\n                      body,\n                      [name = secret_name->second](mtx::http::RequestErr err) {\n                          if (err) {\n                              nhlog::net()->error(\"Failed to send request cancellation \"\n                                                  \"for secrect \"\n                                                  \"'{}'\",\n                                                  name);\n                          }\n                      });\n\n                    nhlog::crypto()->info(\"Storing secret {}\", secret_name->second);\n                    cache::client()->storeSecret(secret_name->second, e->content.secret);\n\n                    request_id_to_secret_name.erase(secret_name);\n                }\n\n            } else if (auto sec_req = std::get_if<DeviceEvent<msg::SecretRequest>>(&device_event)) {\n                handle_secret_request(sec_req, msg.sender);\n            }\n\n            return;\n        } else {\n            failed_decryption = true;\n        }\n    }\n\n    if (failed_decryption) {\n        try {\n            std::map<std::string, std::vector<std::string>> targets;\n            for (const auto &[device_id, key] : otherUserDeviceKeys.device_keys) {\n                if (key.keys.at(\"curve25519:\" + device_id) == msg.sender_key)\n                    targets[msg.sender].push_back(device_id);\n            }\n\n            send_encrypted_to_device_messages(\n              targets, mtx::events::DeviceEvent<mtx::events::msg::Dummy>{}, true);\n            nhlog::crypto()->info(\n              \"Recovering from broken olm channel with {}:{}\", msg.sender, msg.sender_key);\n        } catch (std::exception &e) {\n            nhlog::crypto()->error(\"Failed to recover from broken olm sessions: {}\", e.what());\n        }\n    }\n}",
        "func": "void\nhandle_olm_message(const OlmMessage &msg, const UserKeyCache &otherUserDeviceKeys)\n{\n    nhlog::crypto()->info(\"sender    : {}\", msg.sender);\n    nhlog::crypto()->info(\"sender_key: {}\", msg.sender_key);\n\n    if (msg.sender_key == olm::client()->identity_keys().ed25519) {\n        nhlog::crypto()->warn(\"Ignoring olm message from ourselves!\");\n        return;\n    }\n\n    const auto my_key = olm::client()->identity_keys().curve25519;\n\n    bool failed_decryption = false;\n\n    for (const auto &cipher : msg.ciphertext) {\n        // We skip messages not meant for the current device.\n        if (cipher.first != my_key) {\n            nhlog::crypto()->debug(\n              \"Skipping message for {} since we are {}.\", cipher.first, my_key);\n            continue;\n        }\n\n        const auto type = cipher.second.type;\n        nhlog::crypto()->info(\"type: {}\", type == 0 ? \"OLM_PRE_KEY\" : \"OLM_MESSAGE\");\n\n        auto payload = try_olm_decryption(msg.sender_key, cipher.second);\n\n        if (payload.is_null()) {\n            // Check for PRE_KEY message\n            if (cipher.second.type == 0) {\n                payload = handle_pre_key_olm_message(msg.sender, msg.sender_key, cipher.second);\n            } else {\n                nhlog::crypto()->error(\"Undecryptable olm message!\");\n                failed_decryption = true;\n                continue;\n            }\n        }\n\n        if (!payload.is_null()) {\n            mtx::events::collections::DeviceEvents device_event;\n\n            // Other properties are included in order to prevent an attacker from\n            // publishing someone else's curve25519 keys as their own and subsequently\n            // claiming to have sent messages which they didn't. sender must correspond\n            // to the user who sent the event, recipient to the local user, and\n            // recipient_keys to the local ed25519 key.\n            std::string receiver_ed25519 = payload[\"recipient_keys\"][\"ed25519\"].get<std::string>();\n            if (receiver_ed25519.empty() ||\n                receiver_ed25519 != olm::client()->identity_keys().ed25519) {\n                nhlog::crypto()->warn(\"Decrypted event doesn't include our ed25519: {}\",\n                                      payload.dump());\n                return;\n            }\n            std::string receiver = payload[\"recipient\"].get<std::string>();\n            if (receiver.empty() || receiver != http::client()->user_id().to_string()) {\n                nhlog::crypto()->warn(\"Decrypted event doesn't include our user_id: {}\",\n                                      payload.dump());\n                return;\n            }\n\n            // Clients must confirm that the sender_key and the ed25519 field value\n            // under the keys property match the keys returned by /keys/query for the\n            // given user, and must also verify the signature of the payload. Without\n            // this check, a client cannot be sure that the sender device owns the\n            // private part of the ed25519 key it claims to have in the Olm payload.\n            // This is crucial when the ed25519 key corresponds to a verified device.\n            std::string sender_ed25519 = payload[\"keys\"][\"ed25519\"].get<std::string>();\n            if (sender_ed25519.empty()) {\n                nhlog::crypto()->warn(\"Decrypted event doesn't include sender ed25519: {}\",\n                                      payload.dump());\n                return;\n            }\n\n            bool from_their_device = false;\n            for (const auto &[device_id, key] : otherUserDeviceKeys.device_keys) {\n                auto c_key = key.keys.find(\"curve25519:\" + device_id);\n                auto e_key = key.keys.find(\"ed25519:\" + device_id);\n\n                if (c_key == key.keys.end() || e_key == key.keys.end()) {\n                    nhlog::crypto()->warn(\"Skipping device {} as we have no keys for it.\",\n                                          device_id);\n                } else if (c_key->second == msg.sender_key && e_key->second == sender_ed25519) {\n                    from_their_device = true;\n                    break;\n                }\n            }\n            if (!from_their_device) {\n                nhlog::crypto()->warn(\"Decrypted event isn't sent from a device \"\n                                      \"listed by that user! {}\",\n                                      payload.dump());\n                return;\n            }\n\n            {\n                std::string msg_type       = payload[\"type\"].get<std::string>();\n                nlohmann::json event_array = nlohmann::json::array();\n                event_array.push_back(payload);\n\n                std::vector<mtx::events::collections::DeviceEvents> temp_events;\n                mtx::responses::utils::parse_device_events(event_array, temp_events);\n                if (temp_events.empty()) {\n                    nhlog::crypto()->warn(\"Decrypted unknown event: {}\", payload.dump());\n                    return;\n                }\n                device_event = temp_events.at(0);\n            }\n\n            using namespace mtx::events;\n            if (auto e1 = std::get_if<DeviceEvent<msg::KeyVerificationAccept>>(&device_event)) {\n                ChatPage::instance()->receivedDeviceVerificationAccept(e1->content);\n            } else if (auto e2 =\n                         std::get_if<DeviceEvent<msg::KeyVerificationRequest>>(&device_event)) {\n                ChatPage::instance()->receivedDeviceVerificationRequest(e2->content, e2->sender);\n            } else if (auto e3 =\n                         std::get_if<DeviceEvent<msg::KeyVerificationCancel>>(&device_event)) {\n                ChatPage::instance()->receivedDeviceVerificationCancel(e3->content);\n            } else if (auto e4 = std::get_if<DeviceEvent<msg::KeyVerificationKey>>(&device_event)) {\n                ChatPage::instance()->receivedDeviceVerificationKey(e4->content);\n            } else if (auto e5 = std::get_if<DeviceEvent<msg::KeyVerificationMac>>(&device_event)) {\n                ChatPage::instance()->receivedDeviceVerificationMac(e5->content);\n            } else if (auto e6 =\n                         std::get_if<DeviceEvent<msg::KeyVerificationStart>>(&device_event)) {\n                ChatPage::instance()->receivedDeviceVerificationStart(e6->content, e6->sender);\n            } else if (auto e7 =\n                         std::get_if<DeviceEvent<msg::KeyVerificationReady>>(&device_event)) {\n                ChatPage::instance()->receivedDeviceVerificationReady(e7->content);\n            } else if (auto e8 =\n                         std::get_if<DeviceEvent<msg::KeyVerificationDone>>(&device_event)) {\n                ChatPage::instance()->receivedDeviceVerificationDone(e8->content);\n            } else if (auto roomKey = std::get_if<DeviceEvent<msg::RoomKey>>(&device_event)) {\n                create_inbound_megolm_session(*roomKey, msg.sender_key, sender_ed25519);\n            } else if (auto forwardedRoomKey =\n                         std::get_if<DeviceEvent<msg::ForwardedRoomKey>>(&device_event)) {\n                forwardedRoomKey->content.forwarding_curve25519_key_chain.push_back(msg.sender_key);\n                import_inbound_megolm_session(*forwardedRoomKey);\n            } else if (auto e = std::get_if<DeviceEvent<msg::SecretSend>>(&device_event)) {\n                auto local_user = http::client()->user_id();\n\n                if (msg.sender != local_user.to_string())\n                    return;\n\n                auto secret_name_it = request_id_to_secret_name.find(e->content.request_id);\n\n                if (secret_name_it != request_id_to_secret_name.end()) {\n                    auto secret_name = secret_name_it->second;\n                    request_id_to_secret_name.erase(secret_name_it);\n\n                    nhlog::crypto()->info(\"Received secret: {}\", secret_name);\n\n                    mtx::events::msg::SecretRequest secretRequest{};\n                    secretRequest.action = mtx::events::msg::RequestAction::Cancellation;\n                    secretRequest.requesting_device_id = http::client()->device_id();\n                    secretRequest.request_id           = e->content.request_id;\n\n                    auto verificationStatus = cache::verificationStatus(local_user.to_string());\n\n                    if (!verificationStatus)\n                        return;\n\n                    auto deviceKeys = cache::userKeys(local_user.to_string());\n                    if (!deviceKeys)\n                        return;\n\n                    std::string sender_device_id;\n                    for (auto &[dev, key] : deviceKeys->device_keys) {\n                        if (key.keys[\"curve25519:\" + dev] == msg.sender_key) {\n                            sender_device_id = dev;\n                            break;\n                        }\n                    }\n                    if (!verificationStatus->verified_devices.count(sender_device_id) ||\n                        !verificationStatus->verified_device_keys.count(msg.sender_key) ||\n                        verificationStatus->verified_device_keys.at(msg.sender_key) !=\n                          crypto::Trust::Verified) {\n                        nhlog::net()->critical(\n                          \"Received secret from unverified device {}! Ignoring!\", sender_device_id);\n                        return;\n                    }\n\n                    std::map<mtx::identifiers::User,\n                             std::map<std::string, mtx::events::msg::SecretRequest>>\n                      body;\n\n                    for (const auto &dev : verificationStatus->verified_devices) {\n                        if (dev != secretRequest.requesting_device_id && dev != sender_device_id)\n                            body[local_user][dev] = secretRequest;\n                    }\n\n                    http::client()->send_to_device<mtx::events::msg::SecretRequest>(\n                      http::client()->generate_txn_id(),\n                      body,\n                      [secret_name](mtx::http::RequestErr err) {\n                          if (err) {\n                              nhlog::net()->error(\"Failed to send request cancellation \"\n                                                  \"for secrect \"\n                                                  \"'{}'\",\n                                                  secret_name);\n                          }\n                      });\n\n                    nhlog::crypto()->info(\"Storing secret {}\", secret_name);\n                    cache::client()->storeSecret(secret_name, e->content.secret);\n                }\n\n            } else if (auto sec_req = std::get_if<DeviceEvent<msg::SecretRequest>>(&device_event)) {\n                handle_secret_request(sec_req, msg.sender);\n            }\n\n            return;\n        } else {\n            failed_decryption = true;\n        }\n    }\n\n    if (failed_decryption) {\n        try {\n            std::map<std::string, std::vector<std::string>> targets;\n            for (const auto &[device_id, key] : otherUserDeviceKeys.device_keys) {\n                if (key.keys.at(\"curve25519:\" + device_id) == msg.sender_key)\n                    targets[msg.sender].push_back(device_id);\n            }\n\n            send_encrypted_to_device_messages(\n              targets, mtx::events::DeviceEvent<mtx::events::msg::Dummy>{}, true);\n            nhlog::crypto()->info(\n              \"Recovering from broken olm channel with {}:{}\", msg.sender, msg.sender_key);\n        } catch (std::exception &e) {\n            nhlog::crypto()->error(\"Failed to recover from broken olm sessions: {}\", e.what());\n        }\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -140,10 +140,13 @@\n                 if (msg.sender != local_user.to_string())\n                     return;\n \n-                auto secret_name = request_id_to_secret_name.find(e->content.request_id);\n-\n-                if (secret_name != request_id_to_secret_name.end()) {\n-                    nhlog::crypto()->info(\"Received secret: {}\", secret_name->second);\n+                auto secret_name_it = request_id_to_secret_name.find(e->content.request_id);\n+\n+                if (secret_name_it != request_id_to_secret_name.end()) {\n+                    auto secret_name = secret_name_it->second;\n+                    request_id_to_secret_name.erase(secret_name_it);\n+\n+                    nhlog::crypto()->info(\"Received secret: {}\", secret_name);\n \n                     mtx::events::msg::SecretRequest secretRequest{};\n                     secretRequest.action = mtx::events::msg::RequestAction::Cancellation;\n@@ -156,14 +159,23 @@\n                         return;\n \n                     auto deviceKeys = cache::userKeys(local_user.to_string());\n+                    if (!deviceKeys)\n+                        return;\n+\n                     std::string sender_device_id;\n-                    if (deviceKeys) {\n-                        for (auto &[dev, key] : deviceKeys->device_keys) {\n-                            if (key.keys[\"curve25519:\" + dev] == msg.sender_key) {\n-                                sender_device_id = dev;\n-                                break;\n-                            }\n+                    for (auto &[dev, key] : deviceKeys->device_keys) {\n+                        if (key.keys[\"curve25519:\" + dev] == msg.sender_key) {\n+                            sender_device_id = dev;\n+                            break;\n                         }\n+                    }\n+                    if (!verificationStatus->verified_devices.count(sender_device_id) ||\n+                        !verificationStatus->verified_device_keys.count(msg.sender_key) ||\n+                        verificationStatus->verified_device_keys.at(msg.sender_key) !=\n+                          crypto::Trust::Verified) {\n+                        nhlog::net()->critical(\n+                          \"Received secret from unverified device {}! Ignoring!\", sender_device_id);\n+                        return;\n                     }\n \n                     std::map<mtx::identifiers::User,\n@@ -178,19 +190,17 @@\n                     http::client()->send_to_device<mtx::events::msg::SecretRequest>(\n                       http::client()->generate_txn_id(),\n                       body,\n-                      [name = secret_name->second](mtx::http::RequestErr err) {\n+                      [secret_name](mtx::http::RequestErr err) {\n                           if (err) {\n                               nhlog::net()->error(\"Failed to send request cancellation \"\n                                                   \"for secrect \"\n                                                   \"'{}'\",\n-                                                  name);\n+                                                  secret_name);\n                           }\n                       });\n \n-                    nhlog::crypto()->info(\"Storing secret {}\", secret_name->second);\n-                    cache::client()->storeSecret(secret_name->second, e->content.secret);\n-\n-                    request_id_to_secret_name.erase(secret_name);\n+                    nhlog::crypto()->info(\"Storing secret {}\", secret_name);\n+                    cache::client()->storeSecret(secret_name, e->content.secret);\n                 }\n \n             } else if (auto sec_req = std::get_if<DeviceEvent<msg::SecretRequest>>(&device_event)) {",
        "diff_line_info": {
            "deleted_lines": [
                "                auto secret_name = request_id_to_secret_name.find(e->content.request_id);",
                "",
                "                if (secret_name != request_id_to_secret_name.end()) {",
                "                    nhlog::crypto()->info(\"Received secret: {}\", secret_name->second);",
                "                    if (deviceKeys) {",
                "                        for (auto &[dev, key] : deviceKeys->device_keys) {",
                "                            if (key.keys[\"curve25519:\" + dev] == msg.sender_key) {",
                "                                sender_device_id = dev;",
                "                                break;",
                "                            }",
                "                      [name = secret_name->second](mtx::http::RequestErr err) {",
                "                                                  name);",
                "                    nhlog::crypto()->info(\"Storing secret {}\", secret_name->second);",
                "                    cache::client()->storeSecret(secret_name->second, e->content.secret);",
                "",
                "                    request_id_to_secret_name.erase(secret_name);"
            ],
            "added_lines": [
                "                auto secret_name_it = request_id_to_secret_name.find(e->content.request_id);",
                "",
                "                if (secret_name_it != request_id_to_secret_name.end()) {",
                "                    auto secret_name = secret_name_it->second;",
                "                    request_id_to_secret_name.erase(secret_name_it);",
                "",
                "                    nhlog::crypto()->info(\"Received secret: {}\", secret_name);",
                "                    if (!deviceKeys)",
                "                        return;",
                "",
                "                    for (auto &[dev, key] : deviceKeys->device_keys) {",
                "                        if (key.keys[\"curve25519:\" + dev] == msg.sender_key) {",
                "                            sender_device_id = dev;",
                "                            break;",
                "                    }",
                "                    if (!verificationStatus->verified_devices.count(sender_device_id) ||",
                "                        !verificationStatus->verified_device_keys.count(msg.sender_key) ||",
                "                        verificationStatus->verified_device_keys.at(msg.sender_key) !=",
                "                          crypto::Trust::Verified) {",
                "                        nhlog::net()->critical(",
                "                          \"Received secret from unverified device {}! Ignoring!\", sender_device_id);",
                "                        return;",
                "                      [secret_name](mtx::http::RequestErr err) {",
                "                                                  secret_name);",
                "                    nhlog::crypto()->info(\"Storing secret {}\", secret_name);",
                "                    cache::client()->storeSecret(secret_name, e->content.secret);"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-3724",
        "func_name": "wolfSSL/wolfssl/DoTls13ServerHello",
        "description": "If a TLS 1.3 client gets neither a PSK (pre shared key) extension nor a KSE (key share extension) when connecting to a malicious server, a default predictable buffer gets used for the IKM (Input Keying Material) value when generating the session master secret. Using a potentially known IKM value when generating the session master secret key compromises the key generated, allowing an eavesdropper to reconstruct it and potentially allowing access to or meddling with message contents in the session. This issue does not affect client validation of connected servers, nor expose private key information, but could result in an insecure TLS 1.3 session when not controlling both sides of the connection. wolfSSL recommends that TLS 1.3 client side users update the version of wolfSSL used.Â \n\n\n",
        "git_url": "https://github.com/wolfSSL/wolfssl/commit/00f1eddee429ff51390b20caadd2eb6afe51e1aa",
        "commit_title": "add tls extension sanity check",
        "commit_text": "",
        "func_before": "int DoTls13ServerHello(WOLFSSL* ssl, const byte* input, word32* inOutIdx,\n                       word32 helloSz, byte* extMsgType)\n{\n    int ret;\n    byte suite[2];\n    byte tls12minor;\n#ifdef WOLFSSL_ASYNC_CRYPT\n    Dsh13Args* args = NULL;\n    WOLFSSL_ASSERT_SIZEOF_GE(ssl->async->args, *args);\n#else\n    Dsh13Args  args[1];\n#endif\n\n    WOLFSSL_START(WC_FUNC_SERVER_HELLO_DO);\n    WOLFSSL_ENTER(\"DoTls13ServerHello\");\n\n    tls12minor = TLSv1_2_MINOR;\n\n#ifdef WOLFSSL_DTLS13\n    if (ssl->options.dtls)\n        tls12minor = DTLSv1_2_MINOR;\n#endif /*  WOLFSSL_DTLS13 */\n\n\n    if (ssl == NULL || ssl->arrays == NULL)\n        return BAD_FUNC_ARG;\n\n#ifdef WOLFSSL_ASYNC_CRYPT\n    if (ssl->async == NULL) {\n        ssl->async = (struct WOLFSSL_ASYNC*)\n                XMALLOC(sizeof(struct WOLFSSL_ASYNC), ssl->heap,\n                        DYNAMIC_TYPE_ASYNC);\n        if (ssl->async == NULL)\n            return MEMORY_E;\n        ssl->async->freeArgs = NULL;\n    }\n    args = (Dsh13Args*)ssl->async->args;\n\n    ret = wolfSSL_AsyncPop(ssl, &ssl->options.asyncState);\n    if (ret != WC_NOT_PENDING_E) {\n        /* Check for error */\n        if (ret < 0) {\n            if (ret == WC_PENDING_E) {\n                /* Mark message as not received so it can process again */\n                ssl->msgsReceived.got_server_hello = 0;\n            }\n            return ret;\n        }\n    }\n    else\n#endif\n    {\n        /* Reset state */\n        ssl->options.asyncState = TLS_ASYNC_BEGIN;\n        XMEMSET(args, 0, sizeof(Dsh13Args));\n    }\n\n    switch (ssl->options.asyncState) {\n    case TLS_ASYNC_BEGIN:\n    {\n    byte b;\n#ifdef WOLFSSL_CALLBACKS\n    if (ssl->hsInfoOn) AddPacketName(ssl, \"ServerHello\");\n    if (ssl->toInfoOn) AddLateName(\"ServerHello\", &ssl->timeoutInfo);\n#endif\n\n    /* Protocol version length check. */\n    if (helloSz < OPAQUE16_LEN)\n        return BUFFER_ERROR;\n\n    args->idx = *inOutIdx;\n    args->begin = args->idx;\n\n    /* Protocol version */\n    XMEMCPY(&args->pv, input + args->idx, OPAQUE16_LEN);\n    args->idx += OPAQUE16_LEN;\n\n#ifdef WOLFSSL_DTLS\n    if (ssl->options.dtls &&\n        (args->pv.major != DTLS_MAJOR || args->pv.minor == DTLS_BOGUS_MINOR))\n        return VERSION_ERROR;\n#endif /* WOLFSSL_DTLS */\n\n#ifndef WOLFSSL_NO_TLS12\n    {\n        byte wantDowngrade;\n\n        wantDowngrade = args->pv.major == ssl->version.major &&\n            args->pv.minor < TLSv1_2_MINOR;\n\n#ifdef WOLFSSL_DTLS13\n        if (ssl->options.dtls)\n            wantDowngrade = args->pv.major == ssl->version.major &&\n                args->pv.minor > DTLSv1_2_MINOR;\n#endif /* WOLFSSL_DTLS13 */\n\n        if (wantDowngrade && ssl->options.downgrade) {\n            /* Force client hello version 1.2 to work for static RSA. */\n            ssl->chVersion.minor = TLSv1_2_MINOR;\n            ssl->version.minor = TLSv1_2_MINOR;\n\n#ifdef WOLFSSL_DTLS13\n            if (ssl->options.dtls) {\n                ssl->chVersion.minor = DTLSv1_2_MINOR;\n                ssl->version.minor = DTLSv1_2_MINOR;\n                ret = Dtls13DoDowngrade(ssl);\n                if (ret != 0)\n                    return ret;\n            }\n#endif /* WOLFSSL_DTLS13 */\n\n            return DoServerHello(ssl, input, inOutIdx, helloSz);\n        }\n    }\n#endif\n\n    if (args->pv.major != ssl->version.major ||\n        args->pv.minor != tls12minor) {\n        SendAlert(ssl, alert_fatal, wolfssl_alert_protocol_version);\n        WOLFSSL_ERROR_VERBOSE(VERSION_ERROR);\n        return VERSION_ERROR;\n    }\n\n    /* Random and session id length check */\n    if ((args->idx - args->begin) + RAN_LEN + ENUM_LEN > helloSz)\n        return BUFFER_ERROR;\n\n    /* Check if hello retry request */\n    if (XMEMCMP(input + args->idx, helloRetryRequestRandom, RAN_LEN) == 0) {\n        WOLFSSL_MSG(\"HelloRetryRequest format\");\n        *extMsgType = hello_retry_request;\n\n        /* A HelloRetryRequest comes in as an ServerHello for MiddleBox compat.\n         * Found message to be a HelloRetryRequest.\n         * Don't allow more than one HelloRetryRequest or ServerHello.\n         */\n        if (ssl->msgsReceived.got_hello_retry_request) {\n            WOLFSSL_ERROR_VERBOSE(DUPLICATE_MSG_E);\n            return DUPLICATE_MSG_E;\n        }\n    }\n    args->extMsgType = *extMsgType;\n\n    /* Server random - keep for debugging. */\n    XMEMCPY(ssl->arrays->serverRandom, input + args->idx, RAN_LEN);\n#if defined(HAVE_ECH)\n    args->serverRandomOffset = args->idx;\n#endif\n    args->idx += RAN_LEN;\n\n    /* Session id */\n    args->sessIdSz = input[args->idx++];\n    if ((args->idx - args->begin) + args->sessIdSz > helloSz)\n        return BUFFER_ERROR;\n    args->sessId = input + args->idx;\n    args->idx += args->sessIdSz;\n\n    ssl->options.haveSessionId = 1;\n\n    /* Ciphersuite and compression check */\n    if ((args->idx - args->begin) + OPAQUE16_LEN + OPAQUE8_LEN > helloSz)\n        return BUFFER_ERROR;\n\n    /* Set the cipher suite from the message. */\n    ssl->options.cipherSuite0 = input[args->idx++];\n    ssl->options.cipherSuite  = input[args->idx++];\n#ifdef WOLFSSL_DEBUG_TLS\n    WOLFSSL_MSG(\"Chosen cipher suite:\");\n    WOLFSSL_MSG(GetCipherNameInternal(ssl->options.cipherSuite0,\n                                      ssl->options.cipherSuite));\n#endif\n\n    /* Compression */\n    b = input[args->idx++];\n    if (b != 0) {\n        WOLFSSL_MSG(\"Must be no compression types in list\");\n        WOLFSSL_ERROR_VERBOSE(INVALID_PARAMETER);\n        return INVALID_PARAMETER;\n    }\n\n    if ((args->idx - args->begin) + OPAQUE16_LEN > helloSz) {\n        if (!ssl->options.downgrade)\n            return BUFFER_ERROR;\n#ifndef WOLFSSL_NO_TLS12\n        /* Force client hello version 1.2 to work for static RSA. */\n        ssl->chVersion.minor = TLSv1_2_MINOR;\n        ssl->version.minor = TLSv1_2_MINOR;\n\n#ifdef WOLFSSL_DTLS13\n        if (ssl->options.dtls) {\n            ssl->chVersion.minor = DTLSv1_2_MINOR;\n            ssl->version.minor = DTLSv1_2_MINOR;\n            ret = Dtls13DoDowngrade(ssl);\n            if (ret != 0)\n                return ret;\n        }\n#endif /* WOLFSSL_DTLS13 */\n\n#endif\n        ssl->options.haveEMS = 0;\n        if (args->pv.minor < ssl->options.minDowngrade) {\n            SendAlert(ssl, alert_fatal, wolfssl_alert_protocol_version);\n            return VERSION_ERROR;\n        }\n#ifndef WOLFSSL_NO_TLS12\n        return DoServerHello(ssl, input, inOutIdx, helloSz);\n#else\n        SendAlert(ssl, alert_fatal, wolfssl_alert_protocol_version);\n        return VERSION_ERROR;\n#endif\n    }\n\n    if ((args->idx - args->begin) < helloSz) {\n        int foundVersion;\n\n        /* Get extension length and length check. */\n        if ((args->idx - args->begin) + OPAQUE16_LEN > helloSz)\n            return BUFFER_ERROR;\n        ato16(&input[args->idx], &args->totalExtSz);\n        args->idx += OPAQUE16_LEN;\n        if ((args->idx - args->begin) + args->totalExtSz > helloSz)\n            return BUFFER_ERROR;\n\n        /* Need to negotiate version first. */\n        if ((ret = TLSX_ParseVersion(ssl, input + args->idx,\n            args->totalExtSz, *extMsgType, &foundVersion))) {\n            return ret;\n        }\n        if (!foundVersion) {\n            if (!ssl->options.downgrade) {\n                WOLFSSL_MSG(\"Server trying to downgrade to version less than \"\n                            \"TLS v1.3\");\n                SendAlert(ssl, alert_fatal, wolfssl_alert_protocol_version);\n                WOLFSSL_ERROR_VERBOSE(VERSION_ERROR);\n                return VERSION_ERROR;\n            }\n#if defined(OPENSSL_EXTRA) || defined(HAVE_WEBSERVER) || \\\n    defined(WOLFSSL_WPAS_SMALL)\n            /* Check if client has disabled TLS 1.2 */\n            if (args->pv.minor == TLSv1_2_MINOR &&\n                (ssl->options.mask & SSL_OP_NO_TLSv1_2) == SSL_OP_NO_TLSv1_2) {\n                WOLFSSL_MSG(\"\\tOption set to not allow TLSv1.2\");\n                WOLFSSL_ERROR_VERBOSE(VERSION_ERROR);\n                return VERSION_ERROR;\n            }\n#endif\n\n            if (!ssl->options.dtls &&\n                args->pv.minor < ssl->options.minDowngrade) {\n                SendAlert(ssl, alert_fatal, wolfssl_alert_protocol_version);\n                WOLFSSL_ERROR_VERBOSE(VERSION_ERROR);\n                return VERSION_ERROR;\n            }\n\n            if (ssl->options.dtls &&\n                args->pv.minor > ssl->options.minDowngrade) {\n                SendAlert(ssl, alert_fatal, wolfssl_alert_protocol_version);\n                WOLFSSL_ERROR_VERBOSE(VERSION_ERROR);\n                return VERSION_ERROR;\n            }\n\n            ssl->version.minor = args->pv.minor;\n\n#ifdef WOLFSSL_DTLS13\n            if (ssl->options.dtls) {\n                ret = Dtls13DoDowngrade(ssl);\n                if (ret != 0)\n                    return ret;\n            }\n#endif /* WOLFSSL_DTLS13 */\n        }\n    }\n\n#ifdef WOLFSSL_DTLS13\n    /* we are sure that version is >= v1.3 now, we can get rid of buffered\n     * ClientHello that was buffered to re-compute the hash in case of\n     * downgrade */\n    if (ssl->options.dtls && ssl->dtls13ClientHello != NULL) {\n        XFREE(ssl->dtls13ClientHello, ssl->heap, DYNAMIC_TYPE_DTLS_MSG);\n        ssl->dtls13ClientHello = NULL;\n        ssl->dtls13ClientHelloSz = 0;\n    }\n#endif /* WOLFSSL_DTLS13 */\n\n    /* Advance state and proceed */\n    ssl->options.asyncState = TLS_ASYNC_BUILD;\n    } /* case TLS_ASYNC_BEGIN */\n    FALL_THROUGH;\n\n    case TLS_ASYNC_BUILD:\n    case TLS_ASYNC_DO:\n    {\n    /* restore message type */\n    *extMsgType = args->extMsgType;\n\n    if (args->totalExtSz > 0) {\n        /* Parse and handle extensions. */\n        ret = TLSX_Parse(ssl, input + args->idx, args->totalExtSz,\n            *extMsgType, NULL);\n        if (ret != 0) {\n        #ifdef WOLFSSL_ASYNC_CRYPT\n            /* Handle async operation */\n            if (ret == WC_PENDING_E) {\n                /* Mark message as not received so it can process again */\n                ssl->msgsReceived.got_server_hello = 0;\n            }\n        #endif\n            return ret;\n        }\n\n        if (*extMsgType == hello_retry_request) {\n            /* Update counts to reflect change of message type. */\n            ssl->msgsReceived.got_hello_retry_request = 1;\n            ssl->msgsReceived.got_server_hello = 0;\n        }\n\n        args->idx += args->totalExtSz;\n    }\n\n#ifdef WOLFSSL_DTLS_CID\n    if (ssl->options.useDtlsCID && *extMsgType == server_hello)\n        DtlsCIDOnExtensionsParsed(ssl);\n#endif /* WOLFSSL_DTLS_CID */\n\n    *inOutIdx = args->idx;\n\n    ssl->options.serverState = SERVER_HELLO_COMPLETE;\n\n#ifdef HAVE_SECRET_CALLBACK\n    if (ssl->sessionSecretCb != NULL\n#ifdef HAVE_SESSION_TICKET\n            && ssl->session->ticketLen > 0\n#endif\n            ) {\n        int secretSz = SECRET_LEN;\n        ret = ssl->sessionSecretCb(ssl, ssl->session->masterSecret,\n                                   &secretSz, ssl->sessionSecretCtx);\n        if (ret != 0 || secretSz != SECRET_LEN) {\n            WOLFSSL_ERROR_VERBOSE(SESSION_SECRET_CB_E);\n            return SESSION_SECRET_CB_E;\n        }\n    }\n#endif /* HAVE_SECRET_CALLBACK */\n\n    /* Version only negotiated in extensions for TLS v1.3.\n     * Only now do we know how to deal with session id.\n     */\n    if (!IsAtLeastTLSv1_3(ssl->version)) {\n#ifndef WOLFSSL_NO_TLS12\n        ssl->arrays->sessionIDSz = args->sessIdSz;\n\n        if (ssl->arrays->sessionIDSz > ID_LEN) {\n            WOLFSSL_MSG(\"Invalid session ID size\");\n            ssl->arrays->sessionIDSz = 0;\n            return BUFFER_ERROR;\n        }\n        else if (ssl->arrays->sessionIDSz) {\n            XMEMCPY(ssl->arrays->sessionID, args->sessId,\n                ssl->arrays->sessionIDSz);\n            ssl->options.haveSessionId = 1;\n        }\n\n        /* Force client hello version 1.2 to work for static RSA. */\n        ssl->chVersion.minor = TLSv1_2_MINOR;\n        /* Complete TLS v1.2 processing of ServerHello. */\n        ret = CompleteServerHello(ssl);\n#else\n        WOLFSSL_MSG(\"Client using higher version, fatal error\");\n        WOLFSSL_ERROR_VERBOSE(VERSION_ERROR);\n        ret = VERSION_ERROR;\n#endif\n\n        WOLFSSL_LEAVE(\"DoTls13ServerHello\", ret);\n\n        return ret;\n    }\n\n    /* Advance state and proceed */\n    ssl->options.asyncState = TLS_ASYNC_FINALIZE;\n    } /* case TLS_ASYNC_BUILD || TLS_ASYNC_DO */\n    FALL_THROUGH;\n\n    case TLS_ASYNC_FINALIZE:\n    {\n#ifdef WOLFSSL_TLS13_MIDDLEBOX_COMPAT\n    if (ssl->options.tls13MiddleBoxCompat) {\n        if (args->sessIdSz == 0) {\n            WOLFSSL_MSG(\"args->sessIdSz == 0\");\n            WOLFSSL_ERROR_VERBOSE(INVALID_PARAMETER);\n            return INVALID_PARAMETER;\n        }\n        if (ssl->session->sessionIDSz != 0) {\n            if (ssl->session->sessionIDSz != args->sessIdSz ||\n                XMEMCMP(ssl->session->sessionID, args->sessId,\n                    args->sessIdSz) != 0) {\n                WOLFSSL_MSG(\"session id doesn't match\");\n                WOLFSSL_ERROR_VERBOSE(INVALID_PARAMETER);\n                return INVALID_PARAMETER;\n            }\n        }\n        else if (XMEMCMP(ssl->arrays->clientRandom, args->sessId,\n                args->sessIdSz) != 0) {\n            WOLFSSL_MSG(\"session id doesn't match client random\");\n            WOLFSSL_ERROR_VERBOSE(INVALID_PARAMETER);\n            return INVALID_PARAMETER;\n        }\n    }\n    else\n#endif /* WOLFSSL_TLS13_MIDDLEBOX_COMPAT */\n#ifdef WOLFSSL_QUIC\n    if (WOLFSSL_IS_QUIC(ssl)) {\n        if (args->sessIdSz != 0) {\n            WOLFSSL_MSG(\"args->sessIdSz != 0\");\n            WOLFSSL_ERROR_VERBOSE(INVALID_PARAMETER);\n            return INVALID_PARAMETER;\n        }\n    }\n    else\n#endif /* WOLFSSL_QUIC */\n    if (args->sessIdSz != ssl->session->sessionIDSz || (args->sessIdSz > 0 &&\n        XMEMCMP(ssl->session->sessionID, args->sessId, args->sessIdSz) != 0))\n    {\n        WOLFSSL_MSG(\"Server sent different session id\");\n        WOLFSSL_ERROR_VERBOSE(INVALID_PARAMETER);\n        return INVALID_PARAMETER;\n    }\n\n    ret = SetCipherSpecs(ssl);\n    if (ret != 0)\n        return ret;\n\n#if defined(HAVE_ECH)\n    /* check for acceptConfirmation and HashInput with 8 0 bytes */\n    if (ssl->options.useEch == 1) {\n        ret = EchCheckAcceptance(ssl, input, args->serverRandomOffset, helloSz);\n        if (ret != 0)\n            return ret;\n    }\n#endif\n\n#ifdef HAVE_NULL_CIPHER\n    if (ssl->options.cipherSuite0 == ECC_BYTE &&\n                              (ssl->options.cipherSuite == TLS_SHA256_SHA256 ||\n                               ssl->options.cipherSuite == TLS_SHA384_SHA384)) {\n        ;\n    }\n    else\n#endif\n    /* Check that the negotiated ciphersuite matches protocol version. */\n    if (ssl->options.cipherSuite0 != TLS13_BYTE) {\n        WOLFSSL_MSG(\"Server sent non-TLS13 cipher suite in TLS 1.3 packet\");\n        WOLFSSL_ERROR_VERBOSE(INVALID_PARAMETER);\n        return INVALID_PARAMETER;\n    }\n\n    suite[0] = ssl->options.cipherSuite0;\n    suite[1] = ssl->options.cipherSuite;\n    if (!FindSuiteSSL(ssl, suite)) {\n        WOLFSSL_MSG(\"Cipher suite not supported on client\");\n        WOLFSSL_ERROR_VERBOSE(MATCH_SUITE_ERROR);\n        return MATCH_SUITE_ERROR;\n    }\n\n    if (*extMsgType == server_hello) {\n#if defined(HAVE_SESSION_TICKET) || !defined(NO_PSK)\n        PreSharedKey* psk = NULL;\n        TLSX* ext = TLSX_Find(ssl->extensions, TLSX_PRE_SHARED_KEY);\n        if (ext != NULL)\n            psk = (PreSharedKey*)ext->data;\n        while (psk != NULL && !psk->chosen)\n            psk = psk->next;\n        if (psk == NULL) {\n            ssl->options.resuming = 0;\n            ssl->arrays->psk_keySz = 0;\n            XMEMSET(ssl->arrays->psk_key, 0, MAX_PSK_KEY_LEN);\n        }\n        else {\n            if ((ret = SetupPskKey(ssl, psk, 0)) != 0)\n                return ret;\n            ssl->options.pskNegotiated = 1;\n        }\n#endif\n\n        ssl->keys.encryptionOn = 1;\n        ssl->options.serverState = SERVER_HELLO_COMPLETE;\n    }\n    else {\n        ssl->options.tls1_3 = 1;\n        ssl->options.serverState = SERVER_HELLO_RETRY_REQUEST_COMPLETE;\n\n        ret = RestartHandshakeHash(ssl);\n    }\n\n    break;\n    } /* case TLS_ASYNC_FINALIZE */\n    default:\n        ret = INPUT_CASE_ERROR;\n    } /* switch (ssl->options.asyncState) */\n\n#ifdef WOLFSSL_ASYNC_CRYPT\n    if (ret == 0)\n        FreeAsyncCtx(ssl, 0);\n#endif\n\n    WOLFSSL_LEAVE(\"DoTls13ServerHello\", ret);\n    WOLFSSL_END(WC_FUNC_SERVER_HELLO_DO);\n\n    return ret;\n}",
        "func": "int DoTls13ServerHello(WOLFSSL* ssl, const byte* input, word32* inOutIdx,\n                       word32 helloSz, byte* extMsgType)\n{\n    int ret;\n    byte suite[2];\n    byte tls12minor;\n#ifdef WOLFSSL_ASYNC_CRYPT\n    Dsh13Args* args = NULL;\n    WOLFSSL_ASSERT_SIZEOF_GE(ssl->async->args, *args);\n#else\n    Dsh13Args  args[1];\n#endif\n\n    WOLFSSL_START(WC_FUNC_SERVER_HELLO_DO);\n    WOLFSSL_ENTER(\"DoTls13ServerHello\");\n\n    tls12minor = TLSv1_2_MINOR;\n\n#ifdef WOLFSSL_DTLS13\n    if (ssl->options.dtls)\n        tls12minor = DTLSv1_2_MINOR;\n#endif /*  WOLFSSL_DTLS13 */\n\n\n    if (ssl == NULL || ssl->arrays == NULL)\n        return BAD_FUNC_ARG;\n\n#ifdef WOLFSSL_ASYNC_CRYPT\n    if (ssl->async == NULL) {\n        ssl->async = (struct WOLFSSL_ASYNC*)\n                XMALLOC(sizeof(struct WOLFSSL_ASYNC), ssl->heap,\n                        DYNAMIC_TYPE_ASYNC);\n        if (ssl->async == NULL)\n            return MEMORY_E;\n        ssl->async->freeArgs = NULL;\n    }\n    args = (Dsh13Args*)ssl->async->args;\n\n    ret = wolfSSL_AsyncPop(ssl, &ssl->options.asyncState);\n    if (ret != WC_NOT_PENDING_E) {\n        /* Check for error */\n        if (ret < 0) {\n            if (ret == WC_PENDING_E) {\n                /* Mark message as not received so it can process again */\n                ssl->msgsReceived.got_server_hello = 0;\n            }\n            return ret;\n        }\n    }\n    else\n#endif\n    {\n        /* Reset state */\n        ssl->options.asyncState = TLS_ASYNC_BEGIN;\n        XMEMSET(args, 0, sizeof(Dsh13Args));\n    }\n\n    switch (ssl->options.asyncState) {\n    case TLS_ASYNC_BEGIN:\n    {\n    byte b;\n#ifdef WOLFSSL_CALLBACKS\n    if (ssl->hsInfoOn) AddPacketName(ssl, \"ServerHello\");\n    if (ssl->toInfoOn) AddLateName(\"ServerHello\", &ssl->timeoutInfo);\n#endif\n\n    /* Protocol version length check. */\n    if (helloSz < OPAQUE16_LEN)\n        return BUFFER_ERROR;\n\n    args->idx = *inOutIdx;\n    args->begin = args->idx;\n\n    /* Protocol version */\n    XMEMCPY(&args->pv, input + args->idx, OPAQUE16_LEN);\n    args->idx += OPAQUE16_LEN;\n\n#ifdef WOLFSSL_DTLS\n    if (ssl->options.dtls &&\n        (args->pv.major != DTLS_MAJOR || args->pv.minor == DTLS_BOGUS_MINOR))\n        return VERSION_ERROR;\n#endif /* WOLFSSL_DTLS */\n\n#ifndef WOLFSSL_NO_TLS12\n    {\n        byte wantDowngrade;\n\n        wantDowngrade = args->pv.major == ssl->version.major &&\n            args->pv.minor < TLSv1_2_MINOR;\n\n#ifdef WOLFSSL_DTLS13\n        if (ssl->options.dtls)\n            wantDowngrade = args->pv.major == ssl->version.major &&\n                args->pv.minor > DTLSv1_2_MINOR;\n#endif /* WOLFSSL_DTLS13 */\n\n        if (wantDowngrade && ssl->options.downgrade) {\n            /* Force client hello version 1.2 to work for static RSA. */\n            ssl->chVersion.minor = TLSv1_2_MINOR;\n            ssl->version.minor = TLSv1_2_MINOR;\n\n#ifdef WOLFSSL_DTLS13\n            if (ssl->options.dtls) {\n                ssl->chVersion.minor = DTLSv1_2_MINOR;\n                ssl->version.minor = DTLSv1_2_MINOR;\n                ret = Dtls13DoDowngrade(ssl);\n                if (ret != 0)\n                    return ret;\n            }\n#endif /* WOLFSSL_DTLS13 */\n\n            return DoServerHello(ssl, input, inOutIdx, helloSz);\n        }\n    }\n#endif\n\n    if (args->pv.major != ssl->version.major ||\n        args->pv.minor != tls12minor) {\n        SendAlert(ssl, alert_fatal, wolfssl_alert_protocol_version);\n        WOLFSSL_ERROR_VERBOSE(VERSION_ERROR);\n        return VERSION_ERROR;\n    }\n\n    /* Random and session id length check */\n    if ((args->idx - args->begin) + RAN_LEN + ENUM_LEN > helloSz)\n        return BUFFER_ERROR;\n\n    /* Check if hello retry request */\n    if (XMEMCMP(input + args->idx, helloRetryRequestRandom, RAN_LEN) == 0) {\n        WOLFSSL_MSG(\"HelloRetryRequest format\");\n        *extMsgType = hello_retry_request;\n\n        /* A HelloRetryRequest comes in as an ServerHello for MiddleBox compat.\n         * Found message to be a HelloRetryRequest.\n         * Don't allow more than one HelloRetryRequest or ServerHello.\n         */\n        if (ssl->msgsReceived.got_hello_retry_request) {\n            WOLFSSL_ERROR_VERBOSE(DUPLICATE_MSG_E);\n            return DUPLICATE_MSG_E;\n        }\n    }\n    args->extMsgType = *extMsgType;\n\n    /* Server random - keep for debugging. */\n    XMEMCPY(ssl->arrays->serverRandom, input + args->idx, RAN_LEN);\n#if defined(HAVE_ECH)\n    args->serverRandomOffset = args->idx;\n#endif\n    args->idx += RAN_LEN;\n\n    /* Session id */\n    args->sessIdSz = input[args->idx++];\n    if ((args->idx - args->begin) + args->sessIdSz > helloSz)\n        return BUFFER_ERROR;\n    args->sessId = input + args->idx;\n    args->idx += args->sessIdSz;\n\n    ssl->options.haveSessionId = 1;\n\n    /* Ciphersuite and compression check */\n    if ((args->idx - args->begin) + OPAQUE16_LEN + OPAQUE8_LEN > helloSz)\n        return BUFFER_ERROR;\n\n    /* Set the cipher suite from the message. */\n    ssl->options.cipherSuite0 = input[args->idx++];\n    ssl->options.cipherSuite  = input[args->idx++];\n#ifdef WOLFSSL_DEBUG_TLS\n    WOLFSSL_MSG(\"Chosen cipher suite:\");\n    WOLFSSL_MSG(GetCipherNameInternal(ssl->options.cipherSuite0,\n                                      ssl->options.cipherSuite));\n#endif\n\n    /* Compression */\n    b = input[args->idx++];\n    if (b != 0) {\n        WOLFSSL_MSG(\"Must be no compression types in list\");\n        WOLFSSL_ERROR_VERBOSE(INVALID_PARAMETER);\n        return INVALID_PARAMETER;\n    }\n\n    if ((args->idx - args->begin) + OPAQUE16_LEN > helloSz) {\n        if (!ssl->options.downgrade)\n            return BUFFER_ERROR;\n#ifndef WOLFSSL_NO_TLS12\n        /* Force client hello version 1.2 to work for static RSA. */\n        ssl->chVersion.minor = TLSv1_2_MINOR;\n        ssl->version.minor = TLSv1_2_MINOR;\n\n#ifdef WOLFSSL_DTLS13\n        if (ssl->options.dtls) {\n            ssl->chVersion.minor = DTLSv1_2_MINOR;\n            ssl->version.minor = DTLSv1_2_MINOR;\n            ret = Dtls13DoDowngrade(ssl);\n            if (ret != 0)\n                return ret;\n        }\n#endif /* WOLFSSL_DTLS13 */\n\n#endif\n        ssl->options.haveEMS = 0;\n        if (args->pv.minor < ssl->options.minDowngrade) {\n            SendAlert(ssl, alert_fatal, wolfssl_alert_protocol_version);\n            return VERSION_ERROR;\n        }\n#ifndef WOLFSSL_NO_TLS12\n        return DoServerHello(ssl, input, inOutIdx, helloSz);\n#else\n        SendAlert(ssl, alert_fatal, wolfssl_alert_protocol_version);\n        return VERSION_ERROR;\n#endif\n    }\n\n    if ((args->idx - args->begin) < helloSz) {\n        int foundVersion;\n\n        /* Get extension length and length check. */\n        if ((args->idx - args->begin) + OPAQUE16_LEN > helloSz)\n            return BUFFER_ERROR;\n        ato16(&input[args->idx], &args->totalExtSz);\n        args->idx += OPAQUE16_LEN;\n        if ((args->idx - args->begin) + args->totalExtSz > helloSz)\n            return BUFFER_ERROR;\n\n        /* Need to negotiate version first. */\n        if ((ret = TLSX_ParseVersion(ssl, input + args->idx,\n            args->totalExtSz, *extMsgType, &foundVersion))) {\n            return ret;\n        }\n        if (!foundVersion) {\n            if (!ssl->options.downgrade) {\n                WOLFSSL_MSG(\"Server trying to downgrade to version less than \"\n                            \"TLS v1.3\");\n                SendAlert(ssl, alert_fatal, wolfssl_alert_protocol_version);\n                WOLFSSL_ERROR_VERBOSE(VERSION_ERROR);\n                return VERSION_ERROR;\n            }\n#if defined(OPENSSL_EXTRA) || defined(HAVE_WEBSERVER) || \\\n    defined(WOLFSSL_WPAS_SMALL)\n            /* Check if client has disabled TLS 1.2 */\n            if (args->pv.minor == TLSv1_2_MINOR &&\n                (ssl->options.mask & SSL_OP_NO_TLSv1_2) == SSL_OP_NO_TLSv1_2) {\n                WOLFSSL_MSG(\"\\tOption set to not allow TLSv1.2\");\n                WOLFSSL_ERROR_VERBOSE(VERSION_ERROR);\n                return VERSION_ERROR;\n            }\n#endif\n\n            if (!ssl->options.dtls &&\n                args->pv.minor < ssl->options.minDowngrade) {\n                SendAlert(ssl, alert_fatal, wolfssl_alert_protocol_version);\n                WOLFSSL_ERROR_VERBOSE(VERSION_ERROR);\n                return VERSION_ERROR;\n            }\n\n            if (ssl->options.dtls &&\n                args->pv.minor > ssl->options.minDowngrade) {\n                SendAlert(ssl, alert_fatal, wolfssl_alert_protocol_version);\n                WOLFSSL_ERROR_VERBOSE(VERSION_ERROR);\n                return VERSION_ERROR;\n            }\n\n            ssl->version.minor = args->pv.minor;\n\n#ifdef WOLFSSL_DTLS13\n            if (ssl->options.dtls) {\n                ret = Dtls13DoDowngrade(ssl);\n                if (ret != 0)\n                    return ret;\n            }\n#endif /* WOLFSSL_DTLS13 */\n        }\n    }\n\n#ifdef WOLFSSL_DTLS13\n    /* we are sure that version is >= v1.3 now, we can get rid of buffered\n     * ClientHello that was buffered to re-compute the hash in case of\n     * downgrade */\n    if (ssl->options.dtls && ssl->dtls13ClientHello != NULL) {\n        XFREE(ssl->dtls13ClientHello, ssl->heap, DYNAMIC_TYPE_DTLS_MSG);\n        ssl->dtls13ClientHello = NULL;\n        ssl->dtls13ClientHelloSz = 0;\n    }\n#endif /* WOLFSSL_DTLS13 */\n\n    /* Advance state and proceed */\n    ssl->options.asyncState = TLS_ASYNC_BUILD;\n    } /* case TLS_ASYNC_BEGIN */\n    FALL_THROUGH;\n\n    case TLS_ASYNC_BUILD:\n    case TLS_ASYNC_DO:\n    {\n    /* restore message type */\n    *extMsgType = args->extMsgType;\n\n    if (args->totalExtSz > 0) {\n        /* Parse and handle extensions. */\n        ret = TLSX_Parse(ssl, input + args->idx, args->totalExtSz,\n            *extMsgType, NULL);\n        if (ret != 0) {\n        #ifdef WOLFSSL_ASYNC_CRYPT\n            /* Handle async operation */\n            if (ret == WC_PENDING_E) {\n                /* Mark message as not received so it can process again */\n                ssl->msgsReceived.got_server_hello = 0;\n            }\n        #endif\n            return ret;\n        }\n\n        if (*extMsgType == hello_retry_request) {\n            /* Update counts to reflect change of message type. */\n            ssl->msgsReceived.got_hello_retry_request = 1;\n            ssl->msgsReceived.got_server_hello = 0;\n        }\n\n        args->idx += args->totalExtSz;\n    }\n\n#ifdef WOLFSSL_DTLS_CID\n    if (ssl->options.useDtlsCID && *extMsgType == server_hello)\n        DtlsCIDOnExtensionsParsed(ssl);\n#endif /* WOLFSSL_DTLS_CID */\n\n    *inOutIdx = args->idx;\n\n    ssl->options.serverState = SERVER_HELLO_COMPLETE;\n\n#ifdef HAVE_SECRET_CALLBACK\n    if (ssl->sessionSecretCb != NULL\n#ifdef HAVE_SESSION_TICKET\n            && ssl->session->ticketLen > 0\n#endif\n            ) {\n        int secretSz = SECRET_LEN;\n        ret = ssl->sessionSecretCb(ssl, ssl->session->masterSecret,\n                                   &secretSz, ssl->sessionSecretCtx);\n        if (ret != 0 || secretSz != SECRET_LEN) {\n            WOLFSSL_ERROR_VERBOSE(SESSION_SECRET_CB_E);\n            return SESSION_SECRET_CB_E;\n        }\n    }\n#endif /* HAVE_SECRET_CALLBACK */\n\n    /* Version only negotiated in extensions for TLS v1.3.\n     * Only now do we know how to deal with session id.\n     */\n    if (!IsAtLeastTLSv1_3(ssl->version)) {\n#ifndef WOLFSSL_NO_TLS12\n        ssl->arrays->sessionIDSz = args->sessIdSz;\n\n        if (ssl->arrays->sessionIDSz > ID_LEN) {\n            WOLFSSL_MSG(\"Invalid session ID size\");\n            ssl->arrays->sessionIDSz = 0;\n            return BUFFER_ERROR;\n        }\n        else if (ssl->arrays->sessionIDSz) {\n            XMEMCPY(ssl->arrays->sessionID, args->sessId,\n                ssl->arrays->sessionIDSz);\n            ssl->options.haveSessionId = 1;\n        }\n\n        /* Force client hello version 1.2 to work for static RSA. */\n        ssl->chVersion.minor = TLSv1_2_MINOR;\n        /* Complete TLS v1.2 processing of ServerHello. */\n        ret = CompleteServerHello(ssl);\n#else\n        WOLFSSL_MSG(\"Client using higher version, fatal error\");\n        WOLFSSL_ERROR_VERBOSE(VERSION_ERROR);\n        ret = VERSION_ERROR;\n#endif\n\n        WOLFSSL_LEAVE(\"DoTls13ServerHello\", ret);\n\n        return ret;\n    }\n\n    /* Advance state and proceed */\n    ssl->options.asyncState = TLS_ASYNC_FINALIZE;\n    } /* case TLS_ASYNC_BUILD || TLS_ASYNC_DO */\n    FALL_THROUGH;\n\n    case TLS_ASYNC_FINALIZE:\n    {\n#ifdef WOLFSSL_TLS13_MIDDLEBOX_COMPAT\n    if (ssl->options.tls13MiddleBoxCompat) {\n        if (args->sessIdSz == 0) {\n            WOLFSSL_MSG(\"args->sessIdSz == 0\");\n            WOLFSSL_ERROR_VERBOSE(INVALID_PARAMETER);\n            return INVALID_PARAMETER;\n        }\n        if (ssl->session->sessionIDSz != 0) {\n            if (ssl->session->sessionIDSz != args->sessIdSz ||\n                XMEMCMP(ssl->session->sessionID, args->sessId,\n                    args->sessIdSz) != 0) {\n                WOLFSSL_MSG(\"session id doesn't match\");\n                WOLFSSL_ERROR_VERBOSE(INVALID_PARAMETER);\n                return INVALID_PARAMETER;\n            }\n        }\n        else if (XMEMCMP(ssl->arrays->clientRandom, args->sessId,\n                args->sessIdSz) != 0) {\n            WOLFSSL_MSG(\"session id doesn't match client random\");\n            WOLFSSL_ERROR_VERBOSE(INVALID_PARAMETER);\n            return INVALID_PARAMETER;\n        }\n    }\n    else\n#endif /* WOLFSSL_TLS13_MIDDLEBOX_COMPAT */\n#ifdef WOLFSSL_QUIC\n    if (WOLFSSL_IS_QUIC(ssl)) {\n        if (args->sessIdSz != 0) {\n            WOLFSSL_MSG(\"args->sessIdSz != 0\");\n            WOLFSSL_ERROR_VERBOSE(INVALID_PARAMETER);\n            return INVALID_PARAMETER;\n        }\n    }\n    else\n#endif /* WOLFSSL_QUIC */\n    if (args->sessIdSz != ssl->session->sessionIDSz || (args->sessIdSz > 0 &&\n        XMEMCMP(ssl->session->sessionID, args->sessId, args->sessIdSz) != 0))\n    {\n        WOLFSSL_MSG(\"Server sent different session id\");\n        WOLFSSL_ERROR_VERBOSE(INVALID_PARAMETER);\n        return INVALID_PARAMETER;\n    }\n\n    ret = SetCipherSpecs(ssl);\n    if (ret != 0)\n        return ret;\n\n#if defined(HAVE_ECH)\n    /* check for acceptConfirmation and HashInput with 8 0 bytes */\n    if (ssl->options.useEch == 1) {\n        ret = EchCheckAcceptance(ssl, input, args->serverRandomOffset, helloSz);\n        if (ret != 0)\n            return ret;\n    }\n#endif\n\n#ifdef HAVE_NULL_CIPHER\n    if (ssl->options.cipherSuite0 == ECC_BYTE &&\n                              (ssl->options.cipherSuite == TLS_SHA256_SHA256 ||\n                               ssl->options.cipherSuite == TLS_SHA384_SHA384)) {\n        ;\n    }\n    else\n#endif\n    /* Check that the negotiated ciphersuite matches protocol version. */\n    if (ssl->options.cipherSuite0 != TLS13_BYTE) {\n        WOLFSSL_MSG(\"Server sent non-TLS13 cipher suite in TLS 1.3 packet\");\n        WOLFSSL_ERROR_VERBOSE(INVALID_PARAMETER);\n        return INVALID_PARAMETER;\n    }\n\n    suite[0] = ssl->options.cipherSuite0;\n    suite[1] = ssl->options.cipherSuite;\n    if (!FindSuiteSSL(ssl, suite)) {\n        WOLFSSL_MSG(\"Cipher suite not supported on client\");\n        WOLFSSL_ERROR_VERBOSE(MATCH_SUITE_ERROR);\n        return MATCH_SUITE_ERROR;\n    }\n\n    if (*extMsgType == server_hello) {\n#if defined(HAVE_SESSION_TICKET) || !defined(NO_PSK)\n        PreSharedKey* psk = NULL;\n        TLSX* ext = TLSX_Find(ssl->extensions, TLSX_PRE_SHARED_KEY);\n        if (ext != NULL)\n            psk = (PreSharedKey*)ext->data;\n        while (psk != NULL && !psk->chosen)\n            psk = psk->next;\n        if (psk == NULL) {\n            ssl->options.resuming = 0;\n            ssl->arrays->psk_keySz = 0;\n            XMEMSET(ssl->arrays->psk_key, 0, MAX_PSK_KEY_LEN);\n        }\n        else {\n            if ((ret = SetupPskKey(ssl, psk, 0)) != 0)\n                return ret;\n            ssl->options.pskNegotiated = 1;\n        }\n#endif\n\n        /* sanity check on PSK / KSE */\n        if (\n    #if defined(HAVE_SESSION_TICKET) || !defined(NO_PSK)\n            ssl->options.pskNegotiated == 0 &&\n    #endif\n            ssl->session->namedGroup == 0) {\n            return EXT_MISSING;\n        }\n\n        ssl->keys.encryptionOn = 1;\n        ssl->options.serverState = SERVER_HELLO_COMPLETE;\n\n    }\n    else {\n        ssl->options.tls1_3 = 1;\n        ssl->options.serverState = SERVER_HELLO_RETRY_REQUEST_COMPLETE;\n\n        ret = RestartHandshakeHash(ssl);\n    }\n\n    break;\n    } /* case TLS_ASYNC_FINALIZE */\n    default:\n        ret = INPUT_CASE_ERROR;\n    } /* switch (ssl->options.asyncState) */\n\n#ifdef WOLFSSL_ASYNC_CRYPT\n    if (ret == 0)\n        FreeAsyncCtx(ssl, 0);\n#endif\n\n    WOLFSSL_LEAVE(\"DoTls13ServerHello\", ret);\n    WOLFSSL_END(WC_FUNC_SERVER_HELLO_DO);\n\n    return ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -481,8 +481,18 @@\n         }\n #endif\n \n+        /* sanity check on PSK / KSE */\n+        if (\n+    #if defined(HAVE_SESSION_TICKET) || !defined(NO_PSK)\n+            ssl->options.pskNegotiated == 0 &&\n+    #endif\n+            ssl->session->namedGroup == 0) {\n+            return EXT_MISSING;\n+        }\n+\n         ssl->keys.encryptionOn = 1;\n         ssl->options.serverState = SERVER_HELLO_COMPLETE;\n+\n     }\n     else {\n         ssl->options.tls1_3 = 1;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "        /* sanity check on PSK / KSE */",
                "        if (",
                "    #if defined(HAVE_SESSION_TICKET) || !defined(NO_PSK)",
                "            ssl->options.pskNegotiated == 0 &&",
                "    #endif",
                "            ssl->session->namedGroup == 0) {",
                "            return EXT_MISSING;",
                "        }",
                "",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2023-3724",
        "func_name": "wolfSSL/wolfssl/TLSX_KeyShare_Parse",
        "description": "If a TLS 1.3 client gets neither a PSK (pre shared key) extension nor a KSE (key share extension) when connecting to a malicious server, a default predictable buffer gets used for the IKM (Input Keying Material) value when generating the session master secret. Using a potentially known IKM value when generating the session master secret key compromises the key generated, allowing an eavesdropper to reconstruct it and potentially allowing access to or meddling with message contents in the session. This issue does not affect client validation of connected servers, nor expose private key information, but could result in an insecure TLS 1.3 session when not controlling both sides of the connection. wolfSSL recommends that TLS 1.3 client side users update the version of wolfSSL used.Â \n\n\n",
        "git_url": "https://github.com/wolfSSL/wolfssl/commit/00f1eddee429ff51390b20caadd2eb6afe51e1aa",
        "commit_title": "add tls extension sanity check",
        "commit_text": "",
        "func_before": "int TLSX_KeyShare_Parse(WOLFSSL* ssl, const byte* input, word16 length,\n                               byte msgType)\n{\n    int ret;\n    KeyShareEntry *keyShareEntry = NULL;\n    word16 group;\n\n    if (msgType == client_hello) {\n        ret = TLSX_KeyShare_Parse_ClientHello(ssl, input, length,\n                                              &ssl->extensions);\n    }\n    else if (msgType == server_hello) {\n        int len;\n\n        if (length < OPAQUE16_LEN)\n            return BUFFER_ERROR;\n\n        /* The data is the named group the server wants to use. */\n        ato16(input, &group);\n\n        /* Check the selected group was supported by ClientHello extensions. */\n        if (!TLSX_SupportedGroups_Find(ssl, group, ssl->extensions)) {\n            WOLFSSL_ERROR_VERBOSE(BAD_KEY_SHARE_DATA);\n            return BAD_KEY_SHARE_DATA;\n        }\n\n        /* Check if the group was sent. */\n        if (!TLSX_KeyShare_Find(ssl, group)) {\n            WOLFSSL_ERROR_VERBOSE(BAD_KEY_SHARE_DATA);\n            return BAD_KEY_SHARE_DATA;\n        }\n\n        /* ServerHello contains one key share entry. */\n        len = TLSX_KeyShareEntry_Parse(ssl, input, length, &keyShareEntry,\n                &ssl->extensions);\n        if (len != (int)length)\n            return BUFFER_ERROR;\n\n        /* Not in list sent if there isn't a private key. */\n        if (keyShareEntry == NULL || (keyShareEntry->key == NULL\n        #if !defined(NO_DH) || defined(HAVE_PQC)\n            && keyShareEntry->privKey == NULL\n        #endif\n        )) {\n            WOLFSSL_ERROR_VERBOSE(BAD_KEY_SHARE_DATA);\n            return BAD_KEY_SHARE_DATA;\n        }\n\n        /* Process the entry to calculate the secret. */\n        ret = TLSX_KeyShare_Process(ssl, keyShareEntry);\n        if (ret == 0)\n            ssl->session->namedGroup = ssl->namedGroup = group;\n    }\n    else if (msgType == hello_retry_request) {\n        if (length != OPAQUE16_LEN)\n            return BUFFER_ERROR;\n\n        /* The data is the named group the server wants to use. */\n        ato16(input, &group);\n\n    #ifdef WOLFSSL_ASYNC_CRYPT\n        /* only perform find and clear TLSX if not returning from async */\n        if (ssl->error != WC_PENDING_E)\n    #endif\n        {\n            /* Check the selected group was supported by ClientHello extensions. */\n            if (!TLSX_SupportedGroups_Find(ssl, group, ssl->extensions)) {\n                WOLFSSL_ERROR_VERBOSE(BAD_KEY_SHARE_DATA);\n                return BAD_KEY_SHARE_DATA;\n            }\n\n            /* Check if the group was sent. */\n            if (TLSX_KeyShare_Find(ssl, group)) {\n                WOLFSSL_ERROR_VERBOSE(BAD_KEY_SHARE_DATA);\n                return BAD_KEY_SHARE_DATA;\n            }\n\n            /* Clear out unusable key shares. */\n            ret = TLSX_KeyShare_Empty(ssl);\n            if (ret != 0)\n                return ret;\n        }\n\n#ifdef HAVE_PQC\n        /* For post-quantum groups, do this in TLSX_PopulateExtensions(). */\n        if (!WOLFSSL_NAMED_GROUP_IS_PQC(group))\n#endif\n            ret = TLSX_KeyShare_Use(ssl, group, 0, NULL, NULL, &ssl->extensions);\n    }\n    else {\n        /* Not a message type that is allowed to have this extension. */\n        WOLFSSL_ERROR_VERBOSE(SANITY_MSG_E);\n        return SANITY_MSG_E;\n    }\n\n    return ret;\n}",
        "func": "int TLSX_KeyShare_Parse(WOLFSSL* ssl, const byte* input, word16 length,\n                               byte msgType)\n{\n    int ret;\n    KeyShareEntry *keyShareEntry = NULL;\n    word16 group;\n\n    if (msgType == client_hello) {\n        ret = TLSX_KeyShare_Parse_ClientHello(ssl, input, length,\n                                              &ssl->extensions);\n    }\n    else if (msgType == server_hello) {\n        int len;\n\n        if (length < OPAQUE16_LEN)\n            return BUFFER_ERROR;\n\n        /* The data is the named group the server wants to use. */\n        ato16(input, &group);\n\n        /* Check the selected group was supported by ClientHello extensions. */\n        if (!TLSX_SupportedGroups_Find(ssl, group, ssl->extensions)) {\n            WOLFSSL_ERROR_VERBOSE(BAD_KEY_SHARE_DATA);\n            return BAD_KEY_SHARE_DATA;\n        }\n\n        /* Check if the group was sent. */\n        if (!TLSX_KeyShare_Find(ssl, group)) {\n            WOLFSSL_ERROR_VERBOSE(BAD_KEY_SHARE_DATA);\n            return BAD_KEY_SHARE_DATA;\n        }\n\n        /* ServerHello contains one key share entry. */\n        len = TLSX_KeyShareEntry_Parse(ssl, input, length, &keyShareEntry,\n                &ssl->extensions);\n        if (len != (int)length)\n            return BUFFER_ERROR;\n\n        /* Not in list sent if there isn't a private key. */\n        if (keyShareEntry == NULL || (keyShareEntry->key == NULL\n        #if !defined(NO_DH) || defined(HAVE_PQC)\n            && keyShareEntry->privKey == NULL\n        #endif\n        )) {\n            WOLFSSL_ERROR_VERBOSE(BAD_KEY_SHARE_DATA);\n            return BAD_KEY_SHARE_DATA;\n        }\n\n        /* Process the entry to calculate the secret. */\n        ret = TLSX_KeyShare_Process(ssl, keyShareEntry);\n        if (ret == 0)\n            ssl->session->namedGroup = ssl->namedGroup = group;\n    }\n    else if (msgType == hello_retry_request) {\n        if (length != OPAQUE16_LEN)\n            return BUFFER_ERROR;\n\n        /* The data is the named group the server wants to use. */\n        ato16(input, &group);\n\n    #ifdef WOLFSSL_ASYNC_CRYPT\n        /* only perform find and clear TLSX if not returning from async */\n        if (ssl->error != WC_PENDING_E)\n    #endif\n        {\n            /* Check the selected group was supported by ClientHello extensions. */\n            if (!TLSX_SupportedGroups_Find(ssl, group, ssl->extensions)) {\n                WOLFSSL_ERROR_VERBOSE(BAD_KEY_SHARE_DATA);\n                return BAD_KEY_SHARE_DATA;\n            }\n\n            /* Check if the group was sent. */\n            if (TLSX_KeyShare_Find(ssl, group)) {\n                WOLFSSL_ERROR_VERBOSE(BAD_KEY_SHARE_DATA);\n                return BAD_KEY_SHARE_DATA;\n            }\n\n            /* Clear out unusable key shares. */\n            ret = TLSX_KeyShare_Empty(ssl);\n            if (ret != 0)\n                return ret;\n        }\n\n#ifdef HAVE_PQC\n        /* For post-quantum groups, do this in TLSX_PopulateExtensions(). */\n        if (!WOLFSSL_NAMED_GROUP_IS_PQC(group))\n#endif\n            ret = TLSX_KeyShare_Use(ssl, group, 0, NULL, NULL, &ssl->extensions);\n\n        if (ret == 0)\n            ssl->session->namedGroup = ssl->namedGroup = group;\n    }\n    else {\n        /* Not a message type that is allowed to have this extension. */\n        WOLFSSL_ERROR_VERBOSE(SANITY_MSG_E);\n        return SANITY_MSG_E;\n    }\n\n    return ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -86,6 +86,9 @@\n         if (!WOLFSSL_NAMED_GROUP_IS_PQC(group))\n #endif\n             ret = TLSX_KeyShare_Use(ssl, group, 0, NULL, NULL, &ssl->extensions);\n+\n+        if (ret == 0)\n+            ssl->session->namedGroup = ssl->namedGroup = group;\n     }\n     else {\n         /* Not a message type that is allowed to have this extension. */",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "        if (ret == 0)",
                "            ssl->session->namedGroup = ssl->namedGroup = group;"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-36425",
        "func_name": "Mbed-TLS/mbedtls/mbedtls_x509_crt_is_revoked",
        "description": "An issue was discovered in Arm Mbed TLS before 2.24.0. It incorrectly uses a revocationDate check when deciding whether to honor certificate revocation via a CRL. In some situations, an attacker can exploit this by changing the local clock.",
        "git_url": "https://github.com/Mbed-TLS/mbedtls/commit/a4e86141f1451e8097f85a823a4426e1c1cfdf7c",
        "commit_title": "Always revoke certificate on CRL",
        "commit_text": " RFC5280 does not state that the `revocationDate` should be checked.  In addition, when no time source is available (i.e., when MBEDTLS_HAVE_TIME_DATE is not defined), `mbedtls_x509_time_is_past` always returns 0. This results in the CRL not being checked at all.  https://tools.ietf.org/html/rfc5280",
        "func_before": "int mbedtls_x509_crt_is_revoked( const mbedtls_x509_crt *crt, const mbedtls_x509_crl *crl )\n{\n    const mbedtls_x509_crl_entry *cur = &crl->entry;\n\n    while( cur != NULL && cur->serial.len != 0 )\n    {\n        if( crt->serial.len == cur->serial.len &&\n            memcmp( crt->serial.p, cur->serial.p, crt->serial.len ) == 0 )\n        {\n            if( mbedtls_x509_time_is_past( &cur->revocation_date ) )\n                return( 1 );\n        }\n\n        cur = cur->next;\n    }\n\n    return( 0 );\n}",
        "func": "int mbedtls_x509_crt_is_revoked( const mbedtls_x509_crt *crt, const mbedtls_x509_crl *crl )\n{\n    const mbedtls_x509_crl_entry *cur = &crl->entry;\n\n    while( cur != NULL && cur->serial.len != 0 )\n    {\n        if( crt->serial.len == cur->serial.len &&\n            memcmp( crt->serial.p, cur->serial.p, crt->serial.len ) == 0 )\n        {\n            return( 1 );\n        }\n\n        cur = cur->next;\n    }\n\n    return( 0 );\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -7,8 +7,7 @@\n         if( crt->serial.len == cur->serial.len &&\n             memcmp( crt->serial.p, cur->serial.p, crt->serial.len ) == 0 )\n         {\n-            if( mbedtls_x509_time_is_past( &cur->revocation_date ) )\n-                return( 1 );\n+            return( 1 );\n         }\n \n         cur = cur->next;",
        "diff_line_info": {
            "deleted_lines": [
                "            if( mbedtls_x509_time_is_past( &cur->revocation_date ) )",
                "                return( 1 );"
            ],
            "added_lines": [
                "            return( 1 );"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-32728",
        "func_name": "nextcloud/desktop/ClientSideEncryption::decryptPrivateKey",
        "description": "The Nextcloud Desktop Client is a tool to synchronize files from Nextcloud Server with a computer. Clients using the Nextcloud end-to-end encryption feature download the public and private key via an API endpoint. In versions prior to 3.3.0, the Nextcloud Desktop client fails to check if a private key belongs to previously downloaded public certificate. If the Nextcloud instance serves a malicious public key, the data would be encrypted for this key and thus could be accessible to a malicious actor. This issue is fixed in Nextcloud Desktop Client version 3.3.0. There are no known workarounds aside from upgrading.",
        "git_url": "https://github.com/nextcloud/desktop/commit/7fb09a81632de6066e55def20308d6e61cadbc48",
        "commit_title": "check e2ee public key against private one",
        "commit_text": " should ensure we have matching private/public keys ",
        "func_before": "void ClientSideEncryption::decryptPrivateKey(const AccountPtr &account, const QByteArray &key) {\n    QString msg = tr(\"Please enter your end to end encryption passphrase:<br>\"\n                     \"<br>\"\n                     \"User: %2<br>\"\n                     \"Account: %3<br>\")\n                      .arg(Utility::escape(account->credentials()->user()),\n                           Utility::escape(account->displayName()));\n\n    QInputDialog dialog;\n    dialog.setWindowTitle(tr(\"Enter E2E passphrase\"));\n    dialog.setLabelText(msg);\n    dialog.setTextEchoMode(QLineEdit::Normal);\n\n    QString prev;\n\n    while(true) {\n        if (!prev.isEmpty()) {\n            dialog.setTextValue(prev);\n        }\n        bool ok = dialog.exec();\n        if (ok) {\n            qCInfo(lcCse()) << \"Got mnemonic:\" << dialog.textValue();\n            prev = dialog.textValue();\n\n            _mnemonic = prev;\n            QString mnemonic = prev.split(\" \").join(QString()).toLower();\n            qCInfo(lcCse()) << \"mnemonic:\" << mnemonic;\n\n            // split off salt\n            const auto salt = EncryptionHelper::extractPrivateKeySalt(key);\n\n            auto pass = EncryptionHelper::generatePassword(mnemonic, salt);\n            qCInfo(lcCse()) << \"Generated key:\" << pass;\n\n            QByteArray privateKey = EncryptionHelper::decryptPrivateKey(pass, key);\n            //_privateKey = QSslKey(privateKey, QSsl::Rsa, QSsl::Pem, QSsl::PrivateKey);\n            _privateKey = privateKey;\n\n            qCInfo(lcCse()) << \"Private key: \" << _privateKey;\n\n            if (!_privateKey.isNull()) {\n                writePrivateKey(account);\n                writeCertificate(account);\n                writeMnemonic(account);\n                break;\n            }\n        } else {\n            _mnemonic = QString();\n            _privateKey = QByteArray();\n            qCInfo(lcCse()) << \"Cancelled\";\n            break;\n        }\n    }\n\n    emit initializationFinished();\n}",
        "func": "void ClientSideEncryption::decryptPrivateKey(const AccountPtr &account, const QByteArray &key) {\n    QString msg = tr(\"Please enter your end to end encryption passphrase:<br>\"\n                     \"<br>\"\n                     \"User: %2<br>\"\n                     \"Account: %3<br>\")\n                      .arg(Utility::escape(account->credentials()->user()),\n                           Utility::escape(account->displayName()));\n\n    QInputDialog dialog;\n    dialog.setWindowTitle(tr(\"Enter E2E passphrase\"));\n    dialog.setLabelText(msg);\n    dialog.setTextEchoMode(QLineEdit::Normal);\n\n    QString prev;\n\n    while(true) {\n        if (!prev.isEmpty()) {\n            dialog.setTextValue(prev);\n        }\n        bool ok = dialog.exec();\n        if (ok) {\n            qCInfo(lcCse()) << \"Got mnemonic:\" << dialog.textValue();\n            prev = dialog.textValue();\n\n            _mnemonic = prev;\n            QString mnemonic = prev.split(\" \").join(QString()).toLower();\n            qCInfo(lcCse()) << \"mnemonic:\" << mnemonic;\n\n            // split off salt\n            const auto salt = EncryptionHelper::extractPrivateKeySalt(key);\n\n            auto pass = EncryptionHelper::generatePassword(mnemonic, salt);\n            qCInfo(lcCse()) << \"Generated key:\" << pass;\n\n            QByteArray privateKey = EncryptionHelper::decryptPrivateKey(pass, key);\n            //_privateKey = QSslKey(privateKey, QSsl::Rsa, QSsl::Pem, QSsl::PrivateKey);\n            _privateKey = privateKey;\n\n            qCInfo(lcCse()) << \"Private key: \" << _privateKey;\n\n            if (!_privateKey.isNull() && checkPublicKeyValidity(account)) {\n                writePrivateKey(account);\n                writeCertificate(account);\n                writeMnemonic(account);\n                break;\n            }\n        } else {\n            _mnemonic = QString();\n            _privateKey = QByteArray();\n            qCInfo(lcCse()) << \"Cancelled\";\n            break;\n        }\n    }\n\n    emit initializationFinished();\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -38,7 +38,7 @@\n \n             qCInfo(lcCse()) << \"Private key: \" << _privateKey;\n \n-            if (!_privateKey.isNull()) {\n+            if (!_privateKey.isNull() && checkPublicKeyValidity(account)) {\n                 writePrivateKey(account);\n                 writeCertificate(account);\n                 writeMnemonic(account);",
        "diff_line_info": {
            "deleted_lines": [
                "            if (!_privateKey.isNull()) {"
            ],
            "added_lines": [
                "            if (!_privateKey.isNull() && checkPublicKeyValidity(account)) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-39358",
        "func_name": "GNOME/libgfbgraph/gfbgraph_photo_download_default_size",
        "description": "In GNOME libgfbgraph through 0.2.4, gfbgraph-photo.c does not enable TLS certificate verification on the SoupSessionSync objects it creates, leaving users vulnerable to network MITM attacks. NOTE: this is similar to CVE-2016-20011.",
        "git_url": "https://github.com/GNOME/libgfbgraph/commit/0ddb634dde56dbd7c589ce1fb7c8871fd183e1e9",
        "commit_title": "Fix CVE-2021-39358 by forcing TLS certificate validation",
        "commit_text": " This is similar to the fix performed in other packages. See https://gitlab.gnome.org/Teams/Releng/security/-/issues/57 for more details.  Tested on Linux From Scratch 11.0 and on Debian 11.  Fixes #17",
        "func_before": "GInputStream *\ngfbgraph_photo_download_default_size (GFBGraphPhoto       *photo,\n                                      GFBGraphAuthorizer  *authorizer,\n                                      GError             **error)\n{\n  GInputStream *stream = NULL;\n  SoupSession *session;\n  SoupRequester *requester;\n  SoupRequest *request;\n  SoupMessage *message;\n  GFBGraphPhotoPrivate *priv;\n\n  g_return_val_if_fail (GFBGRAPH_IS_PHOTO (photo), NULL);\n  g_return_val_if_fail (GFBGRAPH_IS_AUTHORIZER (authorizer), NULL);\n\n  priv = GFBGRAPH_PHOTO_GET_PRIVATE (photo);\n\n  session = soup_session_sync_new ();\n  requester = soup_requester_new ();\n  soup_session_add_feature (session, SOUP_SESSION_FEATURE (requester));\n\n  request = soup_requester_request (requester, priv->source, error);\n  if (request != NULL) {\n    message = soup_request_http_get_message (SOUP_REQUEST_HTTP (request));\n\n    stream = soup_request_send (request, NULL, error);\n    if (stream != NULL) {\n      g_object_weak_ref (G_OBJECT (stream),\n                         (GWeakNotify)g_object_unref,\n                         session);\n    }\n\n    g_clear_object (&message);\n    g_clear_object (&request);\n  }\n\n  g_clear_object (&requester);\n\n  return stream;\n}",
        "func": "GInputStream *\ngfbgraph_photo_download_default_size (GFBGraphPhoto       *photo,\n                                      GFBGraphAuthorizer  *authorizer,\n                                      GError             **error)\n{\n  GInputStream *stream = NULL;\n  SoupSession *session;\n  SoupRequester *requester;\n  SoupRequest *request;\n  SoupMessage *message;\n  GFBGraphPhotoPrivate *priv;\n\n  g_return_val_if_fail (GFBGRAPH_IS_PHOTO (photo), NULL);\n  g_return_val_if_fail (GFBGRAPH_IS_AUTHORIZER (authorizer), NULL);\n\n  priv = GFBGRAPH_PHOTO_GET_PRIVATE (photo);\n\n  session = soup_session_sync_new ();\n  requester = soup_requester_new ();\n  g_object_set (G_OBJECT (session), \"ssl-use-system-ca-file\", TRUE, NULL);\n  soup_session_add_feature (session, SOUP_SESSION_FEATURE (requester));\n\n  request = soup_requester_request (requester, priv->source, error);\n  if (request != NULL) {\n    message = soup_request_http_get_message (SOUP_REQUEST_HTTP (request));\n\n    stream = soup_request_send (request, NULL, error);\n    if (stream != NULL) {\n      g_object_weak_ref (G_OBJECT (stream),\n                         (GWeakNotify)g_object_unref,\n                         session);\n    }\n\n    g_clear_object (&message);\n    g_clear_object (&request);\n  }\n\n  g_clear_object (&requester);\n\n  return stream;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -17,6 +17,7 @@\n \n   session = soup_session_sync_new ();\n   requester = soup_requester_new ();\n+  g_object_set (G_OBJECT (session), \"ssl-use-system-ca-file\", TRUE, NULL);\n   soup_session_add_feature (session, SOUP_SESSION_FEATURE (requester));\n \n   request = soup_requester_request (requester, priv->source, error);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "  g_object_set (G_OBJECT (session), \"ssl-use-system-ca-file\", TRUE, NULL);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-39359",
        "func_name": "GNOME/libgda/gda_web_provider_open_connection",
        "description": "In GNOME libgda through 6.0.0, gda-web-provider.c does not enable TLS certificate verification on the SoupSessionSync objects it creates, leaving users vulnerable to network MITM attacks. NOTE: this is similar to CVE-2016-20011.",
        "git_url": "https://github.com/GNOME/libgda/commit/bebdffb4de586fb43fd07ac549121f4b22f6812d",
        "commit_title": "Fix CVE-2021-39359 by forcing TLS certificate validation",
        "commit_text": " This was done by adding \"ssl-use-system-ca-file\", TRUE to the options for each soup_session_new_with_options() call that was made.  Tested on Linux From Scratch 11.0 and Debian 11.  Fixes #249",
        "func_before": "static gboolean\ngda_web_provider_open_connection (GdaServerProvider *provider, GdaConnection *cnc,\n\t\t\t\t  GdaQuarkList *params, GdaQuarkList *auth)\n{\n\tg_return_val_if_fail (GDA_IS_WEB_PROVIDER (provider), FALSE);\n\tg_return_val_if_fail (GDA_IS_CONNECTION (cnc), FALSE);\n\n\t/* Check for connection parameters */\n\tconst gchar *db_name, *host, *path, *port, *serversecret, *pass = NULL, *use_ssl;\n\n\tif (auth)\n\t\tpass = gda_quark_list_find (auth, \"PASSWORD\");\n\tif (!pass) {\n\t\tgda_connection_add_event_string (cnc, _(\"The connection string must contain the %s value\"), \"PASSWORD\");\n                return FALSE;\n\t}\n\thost = gda_quark_list_find (params, \"HOST\");\n\tif (!host) {\n\t\tgda_connection_add_event_string (cnc,\n\t\t\t\t\t\t _(\"The connection string must contain the %s value\"), \"HOST\");\n\t\treturn FALSE;\n\t}\n\tserversecret = gda_quark_list_find (params, \"SECRET\");\n\tif (!serversecret) {\n\t\tgda_connection_add_event_string (cnc,\n\t\t\t\t\t\t _(\"The connection string must contain the %s value\"), \"SECRET\");\n\t\treturn FALSE;\n\t}\n\tpath = gda_quark_list_find (params, \"PATH\");\n\tport = gda_quark_list_find (params, \"PORT\");\n\tdb_name = gda_quark_list_find (params, \"DB_NAME\");\n\tif (!db_name) {\n\t\tgda_connection_add_event_string (cnc,\n\t\t\t\t\t\t _(\"The connection string must contain the %s value\"), \"DB_NAME\");\n\t\treturn FALSE;\n\t}\n\tuse_ssl = gda_quark_list_find (params, \"USE_SSL\");\n\tif (use_ssl && (*use_ssl != 'T') && (*use_ssl != 't'))\n\t\tuse_ssl = NULL;\n\t\n\t/* open Libsoup session */\n\tWebConnectionData *cdata;\n\tGString *server_url;\n\n\tcdata = g_new0 (WebConnectionData, 1);\n\tg_rec_mutex_init (& (cdata->mutex));\n\tcdata->server_id = NULL;\n\tcdata->forced_closing = FALSE;\n\tcdata->worker_session = soup_session_new ();\n\tcdata->front_session = soup_session_new_with_options (\"max-conns-per-host\", 1, NULL);\n\tif (use_ssl) {\n\t\tserver_url = g_string_new (\"https://\");\n\t\tg_print (\"USING SSL\\n\");\n\t}\n\telse\n\t\tserver_url = g_string_new (\"http://\");\n\tg_string_append (server_url, host);\n\tif (port)\n\t\tg_string_append_printf (server_url, \":%s\", port);\n\tif (path)\n\t\tg_string_append_printf (server_url, \"/%s\", path);\n\tcdata->front_url = g_strdup_printf (\"%s/gda-front.php\", server_url->str);\n\tcdata->worker_url = g_strdup_printf (\"%s/gda-worker.php\", server_url->str);\n\tcdata->server_base_url = g_string_free (server_url, FALSE);\n\tif (serversecret)\n\t\tcdata->key = g_strdup (serversecret);\n\tgda_connection_internal_set_provider_data (cnc, (GdaServerProviderConnectionData*) cdata, (GDestroyNotify) _gda_web_free_cnc_data);\n\n\t/*\n\t * perform setup\n\t */\n\tif (! do_server_setup (cnc, cdata))\n\t\treturn FALSE;\n\n\t/*\n\t * send HELLO\n\t */\n\txmlDocPtr doc;\n\tgchar status;\n#define HELLO_MSG \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" standalone=\\\"no\\\"?>\\n\" \\\n\t\t\"<request>\\n\"\t\t\t\t\t\t\\\n\t\t\"  <cmd>HELLO</cmd>\\n\"\t\t\t\t\t\\\n\t\t\"</request>\"\n\tdoc = _gda_web_send_message_to_frontend (cnc, cdata, MESSAGE_HELLO, HELLO_MSG, NULL, &status);\n\tif (!doc) {\n\t\tgda_connection_internal_set_provider_data (cnc, NULL, NULL);\n\t\t_gda_web_do_server_cleanup (cnc, cdata);\n\t\treturn FALSE;\n\t}\n\tif (status != 'O') {\n\t\t_gda_web_set_connection_error_from_xmldoc (cnc, doc, NULL);\n\t\txmlFreeDoc (doc);\n\t\tgda_connection_internal_set_provider_data (cnc, NULL, NULL);\n\t\t_gda_web_do_server_cleanup (cnc, cdata);\n\t\treturn FALSE;\n\t}\n\txmlFreeDoc (doc);\n\n\t/*\n\t * send CONNECT\n\t */\n\tgchar *tmp, *token;\n#define CONNECT_MSG \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" standalone=\\\"no\\\"?>\" \\\n\t\t\"<request>\\n\"\t\t\t\t\t\t\\\n\t\t\"  <token>%s</token>\\n\"\t\t\t\t\t\\\n\t\t\"  <cmd>CONNECT</cmd>\\n\"\t\t\t\t\\\n\t\t\"</request>\"\n\tif (cdata->key)\n\t\tg_free (cdata->key);\n\tcdata->key = g_strdup_printf (\"%s/AND/%s\", db_name, pass);\n\t\n\ttoken = _gda_web_compute_token (cdata);\n\ttmp = g_strdup_printf (CONNECT_MSG, token);\n\tg_free (token);\n\n\tcdata->server_secret = g_strdup (serversecret);\n\tdoc = _gda_web_send_message_to_frontend (cnc, cdata, MESSAGE_CONNECT, tmp, serversecret, &status);\n\tg_free (tmp);\n\tif (!doc) {\n\t\tgda_connection_internal_set_provider_data (cnc, NULL, NULL);\n\t\t_gda_web_do_server_cleanup (cnc, cdata);\n\t\treturn FALSE;\n\t}\n\tif (status != 'O') {\n\t\t_gda_web_set_connection_error_from_xmldoc (cnc, doc, NULL);\n\t\txmlFreeDoc (doc);\n\t\tgda_connection_internal_set_provider_data (cnc, NULL, NULL);\n\t\t_gda_web_do_server_cleanup (cnc, cdata);\n\t\treturn FALSE;\n\t}\n\txmlFreeDoc (doc);\n\n\t/*\n\t * change key: cdata->key = MD5(cdata->key)\n\t */\n\tgchar *md5str;\n\tmd5str = g_compute_checksum_for_data (G_CHECKSUM_MD5, (const guchar*) cdata->key, strlen (cdata->key));\n\tg_free (cdata->key);\n\tcdata->key = md5str;\n\n\treturn TRUE;\n}",
        "func": "static gboolean\ngda_web_provider_open_connection (GdaServerProvider *provider, GdaConnection *cnc,\n\t\t\t\t  GdaQuarkList *params, GdaQuarkList *auth)\n{\n\tg_return_val_if_fail (GDA_IS_WEB_PROVIDER (provider), FALSE);\n\tg_return_val_if_fail (GDA_IS_CONNECTION (cnc), FALSE);\n\n\t/* Check for connection parameters */\n\tconst gchar *db_name, *host, *path, *port, *serversecret, *pass = NULL, *use_ssl;\n\n\tif (auth)\n\t\tpass = gda_quark_list_find (auth, \"PASSWORD\");\n\tif (!pass) {\n\t\tgda_connection_add_event_string (cnc, _(\"The connection string must contain the %s value\"), \"PASSWORD\");\n                return FALSE;\n\t}\n\thost = gda_quark_list_find (params, \"HOST\");\n\tif (!host) {\n\t\tgda_connection_add_event_string (cnc,\n\t\t\t\t\t\t _(\"The connection string must contain the %s value\"), \"HOST\");\n\t\treturn FALSE;\n\t}\n\tserversecret = gda_quark_list_find (params, \"SECRET\");\n\tif (!serversecret) {\n\t\tgda_connection_add_event_string (cnc,\n\t\t\t\t\t\t _(\"The connection string must contain the %s value\"), \"SECRET\");\n\t\treturn FALSE;\n\t}\n\tpath = gda_quark_list_find (params, \"PATH\");\n\tport = gda_quark_list_find (params, \"PORT\");\n\tdb_name = gda_quark_list_find (params, \"DB_NAME\");\n\tif (!db_name) {\n\t\tgda_connection_add_event_string (cnc,\n\t\t\t\t\t\t _(\"The connection string must contain the %s value\"), \"DB_NAME\");\n\t\treturn FALSE;\n\t}\n\tuse_ssl = gda_quark_list_find (params, \"USE_SSL\");\n\tif (use_ssl && (*use_ssl != 'T') && (*use_ssl != 't'))\n\t\tuse_ssl = NULL;\n\t\n\t/* open Libsoup session */\n\tWebConnectionData *cdata;\n\tGString *server_url;\n\n\tcdata = g_new0 (WebConnectionData, 1);\n\tg_rec_mutex_init (& (cdata->mutex));\n\tcdata->server_id = NULL;\n\tcdata->forced_closing = FALSE;\n\tcdata->worker_session = soup_session_new_with_options (\"ssl-use-system-ca-file\", TRUE, NULL);\n\tcdata->front_session = soup_session_new_with_options (\"max-conns-per-host\", 1, \"ssl-use-system-ca-file\", TRUE, NULL);\n\tif (use_ssl) {\n\t\tserver_url = g_string_new (\"https://\");\n\t\tg_print (\"USING SSL\\n\");\n\t}\n\telse\n\t\tserver_url = g_string_new (\"http://\");\n\tg_string_append (server_url, host);\n\tif (port)\n\t\tg_string_append_printf (server_url, \":%s\", port);\n\tif (path)\n\t\tg_string_append_printf (server_url, \"/%s\", path);\n\tcdata->front_url = g_strdup_printf (\"%s/gda-front.php\", server_url->str);\n\tcdata->worker_url = g_strdup_printf (\"%s/gda-worker.php\", server_url->str);\n\tcdata->server_base_url = g_string_free (server_url, FALSE);\n\tif (serversecret)\n\t\tcdata->key = g_strdup (serversecret);\n\tgda_connection_internal_set_provider_data (cnc, (GdaServerProviderConnectionData*) cdata, (GDestroyNotify) _gda_web_free_cnc_data);\n\n\t/*\n\t * perform setup\n\t */\n\tif (! do_server_setup (cnc, cdata))\n\t\treturn FALSE;\n\n\t/*\n\t * send HELLO\n\t */\n\txmlDocPtr doc;\n\tgchar status;\n#define HELLO_MSG \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" standalone=\\\"no\\\"?>\\n\" \\\n\t\t\"<request>\\n\"\t\t\t\t\t\t\\\n\t\t\"  <cmd>HELLO</cmd>\\n\"\t\t\t\t\t\\\n\t\t\"</request>\"\n\tdoc = _gda_web_send_message_to_frontend (cnc, cdata, MESSAGE_HELLO, HELLO_MSG, NULL, &status);\n\tif (!doc) {\n\t\tgda_connection_internal_set_provider_data (cnc, NULL, NULL);\n\t\t_gda_web_do_server_cleanup (cnc, cdata);\n\t\treturn FALSE;\n\t}\n\tif (status != 'O') {\n\t\t_gda_web_set_connection_error_from_xmldoc (cnc, doc, NULL);\n\t\txmlFreeDoc (doc);\n\t\tgda_connection_internal_set_provider_data (cnc, NULL, NULL);\n\t\t_gda_web_do_server_cleanup (cnc, cdata);\n\t\treturn FALSE;\n\t}\n\txmlFreeDoc (doc);\n\n\t/*\n\t * send CONNECT\n\t */\n\tgchar *tmp, *token;\n#define CONNECT_MSG \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" standalone=\\\"no\\\"?>\" \\\n\t\t\"<request>\\n\"\t\t\t\t\t\t\\\n\t\t\"  <token>%s</token>\\n\"\t\t\t\t\t\\\n\t\t\"  <cmd>CONNECT</cmd>\\n\"\t\t\t\t\\\n\t\t\"</request>\"\n\tif (cdata->key)\n\t\tg_free (cdata->key);\n\tcdata->key = g_strdup_printf (\"%s/AND/%s\", db_name, pass);\n\t\n\ttoken = _gda_web_compute_token (cdata);\n\ttmp = g_strdup_printf (CONNECT_MSG, token);\n\tg_free (token);\n\n\tcdata->server_secret = g_strdup (serversecret);\n\tdoc = _gda_web_send_message_to_frontend (cnc, cdata, MESSAGE_CONNECT, tmp, serversecret, &status);\n\tg_free (tmp);\n\tif (!doc) {\n\t\tgda_connection_internal_set_provider_data (cnc, NULL, NULL);\n\t\t_gda_web_do_server_cleanup (cnc, cdata);\n\t\treturn FALSE;\n\t}\n\tif (status != 'O') {\n\t\t_gda_web_set_connection_error_from_xmldoc (cnc, doc, NULL);\n\t\txmlFreeDoc (doc);\n\t\tgda_connection_internal_set_provider_data (cnc, NULL, NULL);\n\t\t_gda_web_do_server_cleanup (cnc, cdata);\n\t\treturn FALSE;\n\t}\n\txmlFreeDoc (doc);\n\n\t/*\n\t * change key: cdata->key = MD5(cdata->key)\n\t */\n\tgchar *md5str;\n\tmd5str = g_compute_checksum_for_data (G_CHECKSUM_MD5, (const guchar*) cdata->key, strlen (cdata->key));\n\tg_free (cdata->key);\n\tcdata->key = md5str;\n\n\treturn TRUE;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -46,8 +46,8 @@\n \tg_rec_mutex_init (& (cdata->mutex));\n \tcdata->server_id = NULL;\n \tcdata->forced_closing = FALSE;\n-\tcdata->worker_session = soup_session_new ();\n-\tcdata->front_session = soup_session_new_with_options (\"max-conns-per-host\", 1, NULL);\n+\tcdata->worker_session = soup_session_new_with_options (\"ssl-use-system-ca-file\", TRUE, NULL);\n+\tcdata->front_session = soup_session_new_with_options (\"max-conns-per-host\", 1, \"ssl-use-system-ca-file\", TRUE, NULL);\n \tif (use_ssl) {\n \t\tserver_url = g_string_new (\"https://\");\n \t\tg_print (\"USING SSL\\n\");",
        "diff_line_info": {
            "deleted_lines": [
                "\tcdata->worker_session = soup_session_new ();",
                "\tcdata->front_session = soup_session_new_with_options (\"max-conns-per-host\", 1, NULL);"
            ],
            "added_lines": [
                "\tcdata->worker_session = soup_session_new_with_options (\"ssl-use-system-ca-file\", TRUE, NULL);",
                "\tcdata->front_session = soup_session_new_with_options (\"max-conns-per-host\", 1, \"ssl-use-system-ca-file\", TRUE, NULL);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-39365",
        "func_name": "GNOME/grilo/grl_net_wc_init",
        "description": "In GNOME grilo though 0.3.13, grl-net-wc.c does not enable TLS certificate verification on the SoupSessionAsync objects it creates, leaving users vulnerable to network MITM attacks. NOTE: this is similar to CVE-2016-20011.",
        "git_url": "https://github.com/GNOME/grilo/commit/cd2472e506dafb1bb8ae510e34ad4797f63e263e",
        "commit_title": "net: Fix TLS cert validation not being done for any network call",
        "commit_text": " The default SoupSessionAsync behaviour does not perform any TLS certificate validation, unless the ssl-use-system-ca-file property is set to true.  See https://blogs.gnome.org/mcatanzaro/2021/05/25/reminder-soupsessionsync-and-soupsessionasync-default-to-no-tls-certificate-verification/  This mitigates CVE-2016-20011.  Closes: #146",
        "func_before": "static void\ngrl_net_wc_init (GrlNetWc *wc)\n{\n  GRL_LOG_DOMAIN_INIT (wc_log_domain, \"wc\");\n\n  wc->priv = grl_net_wc_get_instance_private (wc);\n\n  wc->priv->session = soup_session_async_new ();\n  wc->priv->pending = g_queue_new ();\n\n  set_thread_context (wc);\n  init_mock_requester (wc);\n  init_requester (wc);\n}",
        "func": "static void\ngrl_net_wc_init (GrlNetWc *wc)\n{\n  GRL_LOG_DOMAIN_INIT (wc_log_domain, \"wc\");\n\n  wc->priv = grl_net_wc_get_instance_private (wc);\n\n  wc->priv->session = soup_session_async_new ();\n  g_object_set (G_OBJECT (wc->priv->session), \"ssl-use-system-ca-file\", TRUE, NULL);\n  wc->priv->pending = g_queue_new ();\n\n  set_thread_context (wc);\n  init_mock_requester (wc);\n  init_requester (wc);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,6 +6,7 @@\n   wc->priv = grl_net_wc_get_instance_private (wc);\n \n   wc->priv->session = soup_session_async_new ();\n+  g_object_set (G_OBJECT (wc->priv->session), \"ssl-use-system-ca-file\", TRUE, NULL);\n   wc->priv->pending = g_queue_new ();\n \n   set_thread_context (wc);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "  g_object_set (G_OBJECT (wc->priv->session), \"ssl-use-system-ca-file\", TRUE, NULL);"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-36477",
        "func_name": "Mbed-TLS/mbedtls/x509_crt_verify_name",
        "description": "An issue was discovered in Mbed TLS before 2.24.0. The verification of X.509 certificates when matching the expected common name (the cn argument of mbedtls_x509_crt_verify) with the actual certificate name is mishandled: when the subjecAltName extension is present, the expected name is compared to any name in that extension regardless of its type. This means that an attacker could impersonate a 4-byte or 16-byte domain by getting a certificate for the corresponding IPv4 or IPv6 address (this would require the attacker to control that IP address, though).",
        "git_url": "https://github.com/Mbed-TLS/mbedtls/commit/f3e4bd8632b71dc491e52e6df87dc3e409d2b869",
        "commit_title": "Fix comparison between different name types",
        "commit_text": "",
        "func_before": "static void x509_crt_verify_name( const mbedtls_x509_crt *crt,\n                                  const char *cn,\n                                  uint32_t *flags )\n{\n    const mbedtls_x509_name *name;\n    const mbedtls_x509_sequence *cur;\n    size_t cn_len = strlen( cn );\n\n    if( crt->ext_types & MBEDTLS_X509_EXT_SUBJECT_ALT_NAME )\n    {\n        for( cur = &crt->subject_alt_names; cur != NULL; cur = cur->next )\n        {\n            if( x509_crt_check_cn( &cur->buf, cn, cn_len ) == 0 )\n                break;\n        }\n\n        if( cur == NULL )\n            *flags |= MBEDTLS_X509_BADCERT_CN_MISMATCH;\n    }\n    else\n    {\n        for( name = &crt->subject; name != NULL; name = name->next )\n        {\n            if( MBEDTLS_OID_CMP( MBEDTLS_OID_AT_CN, &name->oid ) == 0 &&\n                x509_crt_check_cn( &name->val, cn, cn_len ) == 0 )\n            {\n                break;\n            }\n        }\n\n        if( name == NULL )\n            *flags |= MBEDTLS_X509_BADCERT_CN_MISMATCH;\n    }\n}",
        "func": "static void x509_crt_verify_name( const mbedtls_x509_crt *crt,\n                                  const char *cn,\n                                  uint32_t *flags )\n{\n    const mbedtls_x509_name *name;\n    const mbedtls_x509_sequence *cur;\n    size_t cn_len = strlen( cn );\n\n    if( crt->ext_types & MBEDTLS_X509_EXT_SUBJECT_ALT_NAME )\n    {\n        for( cur = &crt->subject_alt_names; cur != NULL; cur = cur->next )\n        {\n            if( x509_crt_check_san( &cur->buf, cn, cn_len ) == 0 )\n                break;\n        }\n\n        if( cur == NULL )\n            *flags |= MBEDTLS_X509_BADCERT_CN_MISMATCH;\n    }\n    else\n    {\n        for( name = &crt->subject; name != NULL; name = name->next )\n        {\n            if( MBEDTLS_OID_CMP( MBEDTLS_OID_AT_CN, &name->oid ) == 0 &&\n                x509_crt_check_cn( &name->val, cn, cn_len ) == 0 )\n            {\n                break;\n            }\n        }\n\n        if( name == NULL )\n            *flags |= MBEDTLS_X509_BADCERT_CN_MISMATCH;\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -10,7 +10,7 @@\n     {\n         for( cur = &crt->subject_alt_names; cur != NULL; cur = cur->next )\n         {\n-            if( x509_crt_check_cn( &cur->buf, cn, cn_len ) == 0 )\n+            if( x509_crt_check_san( &cur->buf, cn, cn_len ) == 0 )\n                 break;\n         }\n ",
        "diff_line_info": {
            "deleted_lines": [
                "            if( x509_crt_check_cn( &cur->buf, cn, cn_len ) == 0 )"
            ],
            "added_lines": [
                "            if( x509_crt_check_san( &cur->buf, cn, cn_len ) == 0 )"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-21654",
        "func_name": "envoyproxy/envoy/DefaultCertValidator::updateDigestForSessionId",
        "description": "Envoy is an open source edge and service proxy, designed for cloud-native applications. Envoy's tls allows re-use when some cert validation settings have changed from their default configuration. The only workaround for this issue is to ensure that default tls settings are used. Users are advised to upgrade.",
        "git_url": "https://github.com/envoyproxy/envoy/commit/e9f936d85dc1edc34fabd0a1725ec180f2316353",
        "commit_title": "CVE-2022-21654",
        "commit_text": " tls allows re-use when some cert validation settings have changed ",
        "func_before": "void DefaultCertValidator::updateDigestForSessionId(bssl::ScopedEVP_MD_CTX& md,\n                                                    uint8_t hash_buffer[EVP_MAX_MD_SIZE],\n                                                    unsigned hash_length) {\n  int rc;\n\n  // Hash all the settings that affect whether the server will allow/accept\n  // the client connection. This ensures that the client is always validated against\n  // the correct settings, even if session resumption across different listeners\n  // is enabled.\n  if (ca_cert_ != nullptr) {\n    rc = X509_digest(ca_cert_.get(), EVP_sha256(), hash_buffer, &hash_length);\n    RELEASE_ASSERT(rc == 1, Utility::getLastCryptoError().value_or(\"\"));\n    RELEASE_ASSERT(hash_length == SHA256_DIGEST_LENGTH,\n                   fmt::format(\"invalid SHA256 hash length {}\", hash_length));\n\n    rc = EVP_DigestUpdate(md.get(), hash_buffer, hash_length);\n    RELEASE_ASSERT(rc == 1, Utility::getLastCryptoError().value_or(\"\"));\n  }\n\n  for (const auto& hash : verify_certificate_hash_list_) {\n    rc = EVP_DigestUpdate(md.get(), hash.data(),\n                          hash.size() *\n                              sizeof(std::remove_reference<decltype(hash)>::type::value_type));\n    RELEASE_ASSERT(rc == 1, Utility::getLastCryptoError().value_or(\"\"));\n  }\n\n  for (const auto& hash : verify_certificate_spki_list_) {\n    rc = EVP_DigestUpdate(md.get(), hash.data(),\n                          hash.size() *\n                              sizeof(std::remove_reference<decltype(hash)>::type::value_type));\n    RELEASE_ASSERT(rc == 1, Utility::getLastCryptoError().value_or(\"\"));\n  }\n}",
        "func": "void DefaultCertValidator::updateDigestForSessionId(bssl::ScopedEVP_MD_CTX& md,\n                                                    uint8_t hash_buffer[EVP_MAX_MD_SIZE],\n                                                    unsigned hash_length) {\n  int rc;\n\n  // Hash all the settings that affect whether the server will allow/accept\n  // the client connection. This ensures that the client is always validated against\n  // the correct settings, even if session resumption across different listeners\n  // is enabled.\n  if (ca_cert_ != nullptr) {\n    rc = X509_digest(ca_cert_.get(), EVP_sha256(), hash_buffer, &hash_length);\n    RELEASE_ASSERT(rc == 1, Utility::getLastCryptoError().value_or(\"\"));\n    RELEASE_ASSERT(hash_length == SHA256_DIGEST_LENGTH,\n                   fmt::format(\"invalid SHA256 hash length {}\", hash_length));\n\n    rc = EVP_DigestUpdate(md.get(), hash_buffer, hash_length);\n    RELEASE_ASSERT(rc == 1, Utility::getLastCryptoError().value_or(\"\"));\n  }\n\n  for (const auto& hash : verify_certificate_hash_list_) {\n    rc = EVP_DigestUpdate(md.get(), hash.data(),\n                          hash.size() *\n                              sizeof(std::remove_reference<decltype(hash)>::type::value_type));\n    RELEASE_ASSERT(rc == 1, Utility::getLastCryptoError().value_or(\"\"));\n  }\n\n  for (const auto& hash : verify_certificate_spki_list_) {\n    rc = EVP_DigestUpdate(md.get(), hash.data(),\n                          hash.size() *\n                              sizeof(std::remove_reference<decltype(hash)>::type::value_type));\n    RELEASE_ASSERT(rc == 1, Utility::getLastCryptoError().value_or(\"\"));\n  }\n\n  rc = EVP_DigestUpdate(md.get(), &verify_trusted_ca_, sizeof(verify_trusted_ca_));\n  RELEASE_ASSERT(rc == 1, Utility::getLastCryptoError().value_or(\"\"));\n\n  if (config_ != nullptr) {\n    for (const auto& matcher : config_->subjectAltNameMatchers()) {\n      size_t hash = MessageUtil::hash(matcher);\n      rc = EVP_DigestUpdate(md.get(), &hash, sizeof(hash));\n      RELEASE_ASSERT(rc == 1, Utility::getLastCryptoError().value_or(\"\"));\n    }\n\n    const std::string& crl = config_->certificateRevocationList();\n    if (!crl.empty()) {\n      rc = EVP_DigestUpdate(md.get(), crl.data(), crl.length());\n      RELEASE_ASSERT(rc == 1, Utility::getLastCryptoError().value_or(\"\"));\n    }\n\n    bool allow_expired = config_->allowExpiredCertificate();\n    rc = EVP_DigestUpdate(md.get(), &allow_expired, sizeof(allow_expired));\n    RELEASE_ASSERT(rc == 1, Utility::getLastCryptoError().value_or(\"\"));\n\n    auto trust_chain_verification = config_->trustChainVerification();\n    rc = EVP_DigestUpdate(md.get(), &trust_chain_verification, sizeof(trust_chain_verification));\n    RELEASE_ASSERT(rc == 1, Utility::getLastCryptoError().value_or(\"\"));\n\n    auto only_leaf_crl = config_->onlyVerifyLeafCertificateCrl();\n    rc = EVP_DigestUpdate(md.get(), &only_leaf_crl, sizeof(only_leaf_crl));\n    RELEASE_ASSERT(rc == 1, Utility::getLastCryptoError().value_or(\"\"));\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -30,4 +30,33 @@\n                               sizeof(std::remove_reference<decltype(hash)>::type::value_type));\n     RELEASE_ASSERT(rc == 1, Utility::getLastCryptoError().value_or(\"\"));\n   }\n+\n+  rc = EVP_DigestUpdate(md.get(), &verify_trusted_ca_, sizeof(verify_trusted_ca_));\n+  RELEASE_ASSERT(rc == 1, Utility::getLastCryptoError().value_or(\"\"));\n+\n+  if (config_ != nullptr) {\n+    for (const auto& matcher : config_->subjectAltNameMatchers()) {\n+      size_t hash = MessageUtil::hash(matcher);\n+      rc = EVP_DigestUpdate(md.get(), &hash, sizeof(hash));\n+      RELEASE_ASSERT(rc == 1, Utility::getLastCryptoError().value_or(\"\"));\n+    }\n+\n+    const std::string& crl = config_->certificateRevocationList();\n+    if (!crl.empty()) {\n+      rc = EVP_DigestUpdate(md.get(), crl.data(), crl.length());\n+      RELEASE_ASSERT(rc == 1, Utility::getLastCryptoError().value_or(\"\"));\n+    }\n+\n+    bool allow_expired = config_->allowExpiredCertificate();\n+    rc = EVP_DigestUpdate(md.get(), &allow_expired, sizeof(allow_expired));\n+    RELEASE_ASSERT(rc == 1, Utility::getLastCryptoError().value_or(\"\"));\n+\n+    auto trust_chain_verification = config_->trustChainVerification();\n+    rc = EVP_DigestUpdate(md.get(), &trust_chain_verification, sizeof(trust_chain_verification));\n+    RELEASE_ASSERT(rc == 1, Utility::getLastCryptoError().value_or(\"\"));\n+\n+    auto only_leaf_crl = config_->onlyVerifyLeafCertificateCrl();\n+    rc = EVP_DigestUpdate(md.get(), &only_leaf_crl, sizeof(only_leaf_crl));\n+    RELEASE_ASSERT(rc == 1, Utility::getLastCryptoError().value_or(\"\"));\n+  }\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "  rc = EVP_DigestUpdate(md.get(), &verify_trusted_ca_, sizeof(verify_trusted_ca_));",
                "  RELEASE_ASSERT(rc == 1, Utility::getLastCryptoError().value_or(\"\"));",
                "",
                "  if (config_ != nullptr) {",
                "    for (const auto& matcher : config_->subjectAltNameMatchers()) {",
                "      size_t hash = MessageUtil::hash(matcher);",
                "      rc = EVP_DigestUpdate(md.get(), &hash, sizeof(hash));",
                "      RELEASE_ASSERT(rc == 1, Utility::getLastCryptoError().value_or(\"\"));",
                "    }",
                "",
                "    const std::string& crl = config_->certificateRevocationList();",
                "    if (!crl.empty()) {",
                "      rc = EVP_DigestUpdate(md.get(), crl.data(), crl.length());",
                "      RELEASE_ASSERT(rc == 1, Utility::getLastCryptoError().value_or(\"\"));",
                "    }",
                "",
                "    bool allow_expired = config_->allowExpiredCertificate();",
                "    rc = EVP_DigestUpdate(md.get(), &allow_expired, sizeof(allow_expired));",
                "    RELEASE_ASSERT(rc == 1, Utility::getLastCryptoError().value_or(\"\"));",
                "",
                "    auto trust_chain_verification = config_->trustChainVerification();",
                "    rc = EVP_DigestUpdate(md.get(), &trust_chain_verification, sizeof(trust_chain_verification));",
                "    RELEASE_ASSERT(rc == 1, Utility::getLastCryptoError().value_or(\"\"));",
                "",
                "    auto only_leaf_crl = config_->onlyVerifyLeafCertificateCrl();",
                "    rc = EVP_DigestUpdate(md.get(), &only_leaf_crl, sizeof(only_leaf_crl));",
                "    RELEASE_ASSERT(rc == 1, Utility::getLastCryptoError().value_or(\"\"));",
                "  }"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-25638",
        "func_name": "wolfSSL/wolfssl/DoTls13CertificateVerify",
        "description": "In wolfSSL before 5.2.0, certificate validation may be bypassed during attempted authentication by a TLS 1.3 client to a TLS 1.3 server. This occurs when the sig_algo field differs between the certificate_verify message and the certificate message.",
        "git_url": "https://github.com/wolfSSL/wolfssl/commit/08047b2d959ee5e21a4a2c672308f45fec61f059",
        "commit_title": "Add checking to make sure key is present in all cases. Explicitly set `validSigAlgo` to zero with comment to clarify the default assumption.",
        "commit_text": "",
        "func_before": "static int DoTls13CertificateVerify(WOLFSSL* ssl, byte* input,\n                                    word32* inOutIdx, word32 totalSz)\n{\n    int         ret = 0;\n    buffer*     sig = &ssl->buffers.sig;\n#ifdef WOLFSSL_ASYNC_CRYPT\n    Dcv13Args* args = (Dcv13Args*)ssl->async.args;\n    typedef char args_test[sizeof(ssl->async.args) >= sizeof(*args) ? 1 : -1];\n    (void)sizeof(args_test);\n#else\n    Dcv13Args  args[1];\n#endif\n\n    WOLFSSL_START(WC_FUNC_CERTIFICATE_VERIFY_DO);\n    WOLFSSL_ENTER(\"DoTls13CertificateVerify\");\n\n#ifdef WOLFSSL_ASYNC_CRYPT\n    ret = wolfSSL_AsyncPop(ssl, &ssl->options.asyncState);\n    if (ret != WC_NOT_PENDING_E) {\n        /* Check for error */\n        if (ret < 0)\n            goto exit_dcv;\n    }\n    else\n#endif\n    {\n        /* Reset state */\n        ret = 0;\n        ssl->options.asyncState = TLS_ASYNC_BEGIN;\n        XMEMSET(args, 0, sizeof(Dcv13Args));\n        args->hashAlgo = sha_mac;\n        args->sigAlgo = anonymous_sa_algo;\n        args->idx = *inOutIdx;\n        args->begin = *inOutIdx;\n    #ifdef WOLFSSL_ASYNC_CRYPT\n        ssl->async.freeArgs = FreeDcv13Args;\n    #endif\n    }\n\n    switch(ssl->options.asyncState)\n    {\n        case TLS_ASYNC_BEGIN:\n        {\n        #ifdef WOLFSSL_CALLBACKS\n            if (ssl->hsInfoOn) AddPacketName(ssl, \"CertificateVerify\");\n            if (ssl->toInfoOn) AddLateName(\"CertificateVerify\",\n                                           &ssl->timeoutInfo);\n        #endif\n\n            /* Advance state and proceed */\n            ssl->options.asyncState = TLS_ASYNC_BUILD;\n        } /* case TLS_ASYNC_BEGIN */\n        FALL_THROUGH;\n\n        case TLS_ASYNC_BUILD:\n        {\n            int validSigAlgo = 0;\n\n            /* Signature algorithm. */\n            if ((args->idx - args->begin) + ENUM_LEN + ENUM_LEN > totalSz) {\n                ERROR_OUT(BUFFER_ERROR, exit_dcv);\n            }\n            ret = DecodeTls13SigAlg(input + args->idx, &args->hashAlgo,\n                                                                &args->sigAlgo);\n            if (ret < 0)\n                goto exit_dcv;\n            args->idx += OPAQUE16_LEN;\n\n            /* Signature length. */\n            if ((args->idx - args->begin) + OPAQUE16_LEN > totalSz) {\n                ERROR_OUT(BUFFER_ERROR, exit_dcv);\n            }\n            ato16(input + args->idx, &args->sz);\n            args->idx += OPAQUE16_LEN;\n\n            /* Signature data. */\n            if ((args->idx - args->begin) + args->sz > totalSz ||\n                                                       args->sz > ENCRYPT_LEN) {\n                ERROR_OUT(BUFFER_ERROR, exit_dcv);\n            }\n\n            /* Check for public key of required type. */\n        #ifdef HAVE_ED25519\n            if (args->sigAlgo == ed25519_sa_algo) {\n                WOLFSSL_MSG(\"Peer sent ED25519 sig\");\n                validSigAlgo = ssl->peerEd25519KeyPresent;\n            }\n        #endif\n        #ifdef HAVE_ED448\n            if (args->sigAlgo == ed448_sa_algo) {\n                WOLFSSL_MSG(\"Peer sent ED448 sig\");\n                validSigAlgo = ssl->peerEd448KeyPresent;\n            }\n        #endif\n        #ifdef HAVE_ECC\n            if (args->sigAlgo == ecc_dsa_sa_algo) {\n                WOLFSSL_MSG(\"Peer sent ECC sig\");\n                validSigAlgo = ssl->peerEccDsaKeyPresent;\n            }\n        #endif\n        #ifdef HAVE_PQC\n            if (args->sigAlgo == falcon_level1_sa_algo) {\n                WOLFSSL_MSG(\"Peer sent Falcon Level 1 sig\");\n                validSigAlgo = ssl->peerFalconKeyPresent;\n            }\n            if (args->sigAlgo == falcon_level5_sa_algo) {\n                WOLFSSL_MSG(\"Peer sent Falcon Level 5 sig\");\n                validSigAlgo = ssl->peerFalconKeyPresent;\n            }\n        #endif\n\n        #ifndef NO_RSA\n            if (args->sigAlgo == rsa_sa_algo) {\n                WOLFSSL_MSG(\"Peer sent PKCS#1.5 algo - not valid TLS 1.3\");\n                ERROR_OUT(INVALID_PARAMETER, exit_dcv);\n            }\n            if (args->sigAlgo == rsa_pss_sa_algo) {\n                WOLFSSL_MSG(\"Peer sent RSA sig\");\n                validSigAlgo = (ssl->peerRsaKey != NULL) &&\n                                                         ssl->peerRsaKeyPresent;\n            }\n        #endif\n            if (!validSigAlgo) {\n                WOLFSSL_MSG(\"Sig algo doesn't correspond to certficate\");\n                ret = SIG_VERIFY_E;\n                goto exit_dcv;\n            }\n\n            sig->buffer = (byte*)XMALLOC(args->sz, ssl->heap,\n                                         DYNAMIC_TYPE_SIGNATURE);\n            if (sig->buffer == NULL) {\n                ERROR_OUT(MEMORY_E, exit_dcv);\n            }\n            sig->length = args->sz;\n            XMEMCPY(sig->buffer, input + args->idx, args->sz);\n\n        #ifdef HAVE_ECC\n            if (ssl->peerEccDsaKeyPresent) {\n                WOLFSSL_MSG(\"Doing ECC peer cert verify\");\n\n                args->sigData = (byte*)XMALLOC(MAX_SIG_DATA_SZ, ssl->heap,\n                                                        DYNAMIC_TYPE_SIGNATURE);\n                if (args->sigData == NULL) {\n                    ERROR_OUT(MEMORY_E, exit_dcv);\n                }\n\n                ret = CreateSigData(ssl, args->sigData, &args->sigDataSz, 1);\n                if (ret != 0)\n                    goto exit_dcv;\n                ret = CreateECCEncodedSig(args->sigData,\n                    args->sigDataSz, args->hashAlgo);\n                if (ret < 0)\n                    goto exit_dcv;\n                args->sigDataSz = (word16)ret;\n                ret = 0;\n            }\n        #endif\n        #ifdef HAVE_ED25519\n            if (ssl->peerEd25519KeyPresent) {\n                WOLFSSL_MSG(\"Doing ED25519 peer cert verify\");\n\n                args->sigData = (byte*)XMALLOC(MAX_SIG_DATA_SZ, ssl->heap,\n                                                        DYNAMIC_TYPE_SIGNATURE);\n                if (args->sigData == NULL) {\n                    ERROR_OUT(MEMORY_E, exit_dcv);\n                }\n\n                CreateSigData(ssl, args->sigData, &args->sigDataSz, 1);\n                ret = 0;\n            }\n        #endif\n        #ifdef HAVE_ED448\n            if (ssl->peerEd448KeyPresent) {\n                WOLFSSL_MSG(\"Doing ED448 peer cert verify\");\n\n                args->sigData = (byte*)XMALLOC(MAX_SIG_DATA_SZ, ssl->heap,\n                                                        DYNAMIC_TYPE_SIGNATURE);\n                if (args->sigData == NULL) {\n                    ERROR_OUT(MEMORY_E, exit_dcv);\n                }\n\n                CreateSigData(ssl, args->sigData, &args->sigDataSz, 1);\n                ret = 0;\n            }\n       #endif\n       #ifdef HAVE_PQC\n            if (ssl->peerFalconKeyPresent) {\n                WOLFSSL_MSG(\"Doing Falcon peer cert verify\");\n\n                args->sigData = (byte*)XMALLOC(MAX_SIG_DATA_SZ, ssl->heap,\n                                                        DYNAMIC_TYPE_SIGNATURE);\n                if (args->sigData == NULL) {\n                    ERROR_OUT(MEMORY_E, exit_dcv);\n                }\n\n                CreateSigData(ssl, args->sigData, &args->sigDataSz, 1);\n                ret = 0;\n            }\n       #endif\n\n            /* Advance state and proceed */\n            ssl->options.asyncState = TLS_ASYNC_DO;\n        } /* case TLS_ASYNC_BUILD */\n        FALL_THROUGH;\n\n        case TLS_ASYNC_DO:\n        {\n        #ifndef NO_RSA\n            if (ssl->peerRsaKey != NULL && ssl->peerRsaKeyPresent != 0) {\n                ret = RsaVerify(ssl, sig->buffer, (word32)sig->length, &args->output,\n                    args->sigAlgo, args->hashAlgo, ssl->peerRsaKey,\n                #ifdef HAVE_PK_CALLBACKS\n                    &ssl->buffers.peerRsaKey\n                #else\n                    NULL\n                #endif\n                );\n                if (ret >= 0) {\n                    args->sendSz = ret;\n                    ret = 0;\n                }\n            }\n        #endif /* !NO_RSA */\n        #ifdef HAVE_ECC\n            if (ssl->peerEccDsaKeyPresent) {\n                ret = EccVerify(ssl, input + args->idx, args->sz,\n                    args->sigData, args->sigDataSz,\n                    ssl->peerEccDsaKey,\n                #ifdef HAVE_PK_CALLBACKS\n                    &ssl->buffers.peerEccDsaKey\n                #else\n                    NULL\n                #endif\n                );\n\n                if (ret >= 0) {\n                    FreeKey(ssl, DYNAMIC_TYPE_ECC, (void**)&ssl->peerEccDsaKey);\n                    ssl->peerEccDsaKeyPresent = 0;\n                }\n            }\n        #endif /* HAVE_ECC */\n        #ifdef HAVE_ED25519\n            if (ssl->peerEd25519KeyPresent) {\n                ret = Ed25519Verify(ssl, input + args->idx, args->sz,\n                    args->sigData, args->sigDataSz,\n                    ssl->peerEd25519Key,\n                #ifdef HAVE_PK_CALLBACKS\n                    &ssl->buffers.peerEd25519Key\n                #else\n                    NULL\n                #endif\n                );\n\n                if (ret >= 0) {\n                    FreeKey(ssl, DYNAMIC_TYPE_ED25519,\n                                                  (void**)&ssl->peerEd25519Key);\n                    ssl->peerEd25519KeyPresent = 0;\n                }\n            }\n        #endif\n        #ifdef HAVE_ED448\n            if (ssl->peerEd448KeyPresent) {\n                ret = Ed448Verify(ssl, input + args->idx, args->sz,\n                    args->sigData, args->sigDataSz,\n                    ssl->peerEd448Key,\n                #ifdef HAVE_PK_CALLBACKS\n                    &ssl->buffers.peerEd448Key\n                #else\n                    NULL\n                #endif\n                );\n\n                if (ret >= 0) {\n                    FreeKey(ssl, DYNAMIC_TYPE_ED448,\n                                                    (void**)&ssl->peerEd448Key);\n                    ssl->peerEd448KeyPresent = 0;\n                }\n            }\n        #endif\n        #ifdef HAVE_PQC\n            if (ssl->peerFalconKeyPresent) {\n                int res = 0;\n                WOLFSSL_MSG(\"Doing Falcon peer cert verify\");\n                ret = wc_falcon_verify_msg(input + args->idx, args->sz,\n                                    args->sigData, args->sigDataSz,\n                                    &res, ssl->peerFalconKey);\n\n                if ((ret >= 0) && (res == 1)) {\n                    FreeKey(ssl, DYNAMIC_TYPE_FALCON,\n                                                   (void**)&ssl->peerFalconKey);\n                    ssl->peerFalconKeyPresent = 0;\n                }\n            }\n        #endif\n\n            /* Check for error */\n            if (ret != 0) {\n                goto exit_dcv;\n            }\n\n            /* Advance state and proceed */\n            ssl->options.asyncState = TLS_ASYNC_VERIFY;\n        } /* case TLS_ASYNC_DO */\n        FALL_THROUGH;\n\n        case TLS_ASYNC_VERIFY:\n        {\n        #if !defined(NO_RSA) && defined(WC_RSA_PSS)\n            if (ssl->peerRsaKey != NULL && ssl->peerRsaKeyPresent != 0) {\n                ret = CheckRSASignature(ssl, args->sigAlgo, args->hashAlgo,\n                                        args->output, args->sendSz);\n                if (ret != 0)\n                    goto exit_dcv;\n\n                FreeKey(ssl, DYNAMIC_TYPE_RSA, (void**)&ssl->peerRsaKey);\n                ssl->peerRsaKeyPresent = 0;\n            }\n        #endif /* !NO_RSA && WC_RSA_PSS */\n\n            /* Advance state and proceed */\n            ssl->options.asyncState = TLS_ASYNC_FINALIZE;\n        } /* case TLS_ASYNC_VERIFY */\n        FALL_THROUGH;\n\n        case TLS_ASYNC_FINALIZE:\n        {\n            ssl->options.havePeerVerify = 1;\n\n            /* Set final index */\n            args->idx += args->sz;\n            *inOutIdx = args->idx;\n\n            /* Encryption is always on: add padding */\n            *inOutIdx += ssl->keys.padSz;\n\n            /* Advance state and proceed */\n            ssl->options.asyncState = TLS_ASYNC_END;\n\n        #if !defined(NO_WOLFSSL_CLIENT)\n            if (ssl->options.side == WOLFSSL_CLIENT_END)\n                ssl->options.serverState = SERVER_CERT_VERIFY_COMPLETE;\n        #endif\n        } /* case TLS_ASYNC_FINALIZE */\n        FALL_THROUGH;\n\n        case TLS_ASYNC_END:\n        {\n            break;\n        }\n\n        default:\n            ret = INPUT_CASE_ERROR;\n    } /* switch(ssl->options.asyncState) */\n\nexit_dcv:\n\n    WOLFSSL_LEAVE(\"DoTls13CertificateVerify\", ret);\n    WOLFSSL_END(WC_FUNC_CERTIFICATE_VERIFY_DO);\n\n#ifdef WOLFSSL_ASYNC_CRYPT\n    /* Handle async operation */\n    if (ret == WC_PENDING_E) {\n        /* Mark message as not received so it can process again */\n        ssl->msgsReceived.got_certificate_verify = 0;\n\n        return ret;\n    }\n    else\n#endif /* WOLFSSL_ASYNC_CRYPT */\n    if (ret != 0 && ret != INVALID_PARAMETER)\n        SendAlert(ssl, alert_fatal, decrypt_error);\n\n    /* Final cleanup */\n    FreeDcv13Args(ssl, args);\n    FreeKeyExchange(ssl);\n\n    return ret;\n}",
        "func": "static int DoTls13CertificateVerify(WOLFSSL* ssl, byte* input,\n                                    word32* inOutIdx, word32 totalSz)\n{\n    int         ret = 0;\n    buffer*     sig = &ssl->buffers.sig;\n#ifdef WOLFSSL_ASYNC_CRYPT\n    Dcv13Args* args = (Dcv13Args*)ssl->async.args;\n    typedef char args_test[sizeof(ssl->async.args) >= sizeof(*args) ? 1 : -1];\n    (void)sizeof(args_test);\n#else\n    Dcv13Args  args[1];\n#endif\n\n    WOLFSSL_START(WC_FUNC_CERTIFICATE_VERIFY_DO);\n    WOLFSSL_ENTER(\"DoTls13CertificateVerify\");\n\n#ifdef WOLFSSL_ASYNC_CRYPT\n    ret = wolfSSL_AsyncPop(ssl, &ssl->options.asyncState);\n    if (ret != WC_NOT_PENDING_E) {\n        /* Check for error */\n        if (ret < 0)\n            goto exit_dcv;\n    }\n    else\n#endif\n    {\n        /* Reset state */\n        ret = 0;\n        ssl->options.asyncState = TLS_ASYNC_BEGIN;\n        XMEMSET(args, 0, sizeof(Dcv13Args));\n        args->hashAlgo = sha_mac;\n        args->sigAlgo = anonymous_sa_algo;\n        args->idx = *inOutIdx;\n        args->begin = *inOutIdx;\n    #ifdef WOLFSSL_ASYNC_CRYPT\n        ssl->async.freeArgs = FreeDcv13Args;\n    #endif\n    }\n\n    switch(ssl->options.asyncState)\n    {\n        case TLS_ASYNC_BEGIN:\n        {\n        #ifdef WOLFSSL_CALLBACKS\n            if (ssl->hsInfoOn) AddPacketName(ssl, \"CertificateVerify\");\n            if (ssl->toInfoOn) AddLateName(\"CertificateVerify\",\n                                           &ssl->timeoutInfo);\n        #endif\n\n            /* Advance state and proceed */\n            ssl->options.asyncState = TLS_ASYNC_BUILD;\n        } /* case TLS_ASYNC_BEGIN */\n        FALL_THROUGH;\n\n        case TLS_ASYNC_BUILD:\n        {\n            int validSigAlgo;\n\n            /* Signature algorithm. */\n            if ((args->idx - args->begin) + ENUM_LEN + ENUM_LEN > totalSz) {\n                ERROR_OUT(BUFFER_ERROR, exit_dcv);\n            }\n            ret = DecodeTls13SigAlg(input + args->idx, &args->hashAlgo,\n                                                                &args->sigAlgo);\n            if (ret < 0)\n                goto exit_dcv;\n            args->idx += OPAQUE16_LEN;\n\n            /* Signature length. */\n            if ((args->idx - args->begin) + OPAQUE16_LEN > totalSz) {\n                ERROR_OUT(BUFFER_ERROR, exit_dcv);\n            }\n            ato16(input + args->idx, &args->sz);\n            args->idx += OPAQUE16_LEN;\n\n            /* Signature data. */\n            if ((args->idx - args->begin) + args->sz > totalSz ||\n                                                       args->sz > ENCRYPT_LEN) {\n                ERROR_OUT(BUFFER_ERROR, exit_dcv);\n            }\n\n            /* Check for public key of required type. */\n            /* Assume invalid unless signature algo matches the key provided */\n            validSigAlgo = 0;\n        #ifdef HAVE_ED25519\n            if (args->sigAlgo == ed25519_sa_algo) {\n                WOLFSSL_MSG(\"Peer sent ED25519 sig\");\n                validSigAlgo = (ssl->peerEd25519Key != NULL) &&\n                                                     ssl->peerEd25519KeyPresent;\n            }\n        #endif\n        #ifdef HAVE_ED448\n            if (args->sigAlgo == ed448_sa_algo) {\n                WOLFSSL_MSG(\"Peer sent ED448 sig\");\n                validSigAlgo = (ssl->peerEd448Key != NULL) &&\n                                                       ssl->peerEd448KeyPresent;\n            }\n        #endif\n        #ifdef HAVE_ECC\n            if (args->sigAlgo == ecc_dsa_sa_algo) {\n                WOLFSSL_MSG(\"Peer sent ECC sig\");\n                validSigAlgo = (ssl->peerEccDsaKey != NULL) &&\n                                                      ssl->peerEccDsaKeyPresent;\n            }\n        #endif\n        #ifdef HAVE_PQC\n            if (args->sigAlgo == falcon_level1_sa_algo) {\n                WOLFSSL_MSG(\"Peer sent Falcon Level 1 sig\");\n                validSigAlgo = (ssl->peerFalconKey != NULL) &&\n                                                      ssl->peerFalconKeyPresent;\n            }\n            if (args->sigAlgo == falcon_level5_sa_algo) {\n                WOLFSSL_MSG(\"Peer sent Falcon Level 5 sig\");\n                validSigAlgo = (ssl->peerFalconKey != NULL) &&\n                                                      ssl->peerFalconKeyPresent;\n            }\n        #endif\n        #ifndef NO_RSA\n            if (args->sigAlgo == rsa_sa_algo) {\n                WOLFSSL_MSG(\"Peer sent PKCS#1.5 algo - not valid TLS 1.3\");\n                ERROR_OUT(INVALID_PARAMETER, exit_dcv);\n            }\n            if (args->sigAlgo == rsa_pss_sa_algo) {\n                WOLFSSL_MSG(\"Peer sent RSA sig\");\n                validSigAlgo = (ssl->peerRsaKey != NULL) &&\n                                                         ssl->peerRsaKeyPresent;\n            }\n        #endif\n            if (!validSigAlgo) {\n                WOLFSSL_MSG(\"Sig algo doesn't correspond to certficate\");\n                ERROR_OUT(SIG_VERIFY_E, exit_dcv);\n            }\n\n            sig->buffer = (byte*)XMALLOC(args->sz, ssl->heap,\n                                         DYNAMIC_TYPE_SIGNATURE);\n            if (sig->buffer == NULL) {\n                ERROR_OUT(MEMORY_E, exit_dcv);\n            }\n            sig->length = args->sz;\n            XMEMCPY(sig->buffer, input + args->idx, args->sz);\n\n        #ifdef HAVE_ECC\n            if (ssl->peerEccDsaKeyPresent) {\n                WOLFSSL_MSG(\"Doing ECC peer cert verify\");\n\n                args->sigData = (byte*)XMALLOC(MAX_SIG_DATA_SZ, ssl->heap,\n                                                        DYNAMIC_TYPE_SIGNATURE);\n                if (args->sigData == NULL) {\n                    ERROR_OUT(MEMORY_E, exit_dcv);\n                }\n\n                ret = CreateSigData(ssl, args->sigData, &args->sigDataSz, 1);\n                if (ret != 0)\n                    goto exit_dcv;\n                ret = CreateECCEncodedSig(args->sigData,\n                    args->sigDataSz, args->hashAlgo);\n                if (ret < 0)\n                    goto exit_dcv;\n                args->sigDataSz = (word16)ret;\n                ret = 0;\n            }\n        #endif\n        #ifdef HAVE_ED25519\n            if (ssl->peerEd25519KeyPresent) {\n                WOLFSSL_MSG(\"Doing ED25519 peer cert verify\");\n\n                args->sigData = (byte*)XMALLOC(MAX_SIG_DATA_SZ, ssl->heap,\n                                                        DYNAMIC_TYPE_SIGNATURE);\n                if (args->sigData == NULL) {\n                    ERROR_OUT(MEMORY_E, exit_dcv);\n                }\n\n                CreateSigData(ssl, args->sigData, &args->sigDataSz, 1);\n                ret = 0;\n            }\n        #endif\n        #ifdef HAVE_ED448\n            if (ssl->peerEd448KeyPresent) {\n                WOLFSSL_MSG(\"Doing ED448 peer cert verify\");\n\n                args->sigData = (byte*)XMALLOC(MAX_SIG_DATA_SZ, ssl->heap,\n                                                        DYNAMIC_TYPE_SIGNATURE);\n                if (args->sigData == NULL) {\n                    ERROR_OUT(MEMORY_E, exit_dcv);\n                }\n\n                CreateSigData(ssl, args->sigData, &args->sigDataSz, 1);\n                ret = 0;\n            }\n       #endif\n       #ifdef HAVE_PQC\n            if (ssl->peerFalconKeyPresent) {\n                WOLFSSL_MSG(\"Doing Falcon peer cert verify\");\n\n                args->sigData = (byte*)XMALLOC(MAX_SIG_DATA_SZ, ssl->heap,\n                                                        DYNAMIC_TYPE_SIGNATURE);\n                if (args->sigData == NULL) {\n                    ERROR_OUT(MEMORY_E, exit_dcv);\n                }\n\n                CreateSigData(ssl, args->sigData, &args->sigDataSz, 1);\n                ret = 0;\n            }\n       #endif\n\n            /* Advance state and proceed */\n            ssl->options.asyncState = TLS_ASYNC_DO;\n        } /* case TLS_ASYNC_BUILD */\n        FALL_THROUGH;\n\n        case TLS_ASYNC_DO:\n        {\n        #ifndef NO_RSA\n            if (ssl->peerRsaKey != NULL && ssl->peerRsaKeyPresent != 0) {\n                ret = RsaVerify(ssl, sig->buffer, (word32)sig->length, &args->output,\n                    args->sigAlgo, args->hashAlgo, ssl->peerRsaKey,\n                #ifdef HAVE_PK_CALLBACKS\n                    &ssl->buffers.peerRsaKey\n                #else\n                    NULL\n                #endif\n                );\n                if (ret >= 0) {\n                    args->sendSz = ret;\n                    ret = 0;\n                }\n            }\n        #endif /* !NO_RSA */\n        #ifdef HAVE_ECC\n            if (ssl->peerEccDsaKeyPresent) {\n                ret = EccVerify(ssl, input + args->idx, args->sz,\n                    args->sigData, args->sigDataSz,\n                    ssl->peerEccDsaKey,\n                #ifdef HAVE_PK_CALLBACKS\n                    &ssl->buffers.peerEccDsaKey\n                #else\n                    NULL\n                #endif\n                );\n\n                if (ret >= 0) {\n                    FreeKey(ssl, DYNAMIC_TYPE_ECC, (void**)&ssl->peerEccDsaKey);\n                    ssl->peerEccDsaKeyPresent = 0;\n                }\n            }\n        #endif /* HAVE_ECC */\n        #ifdef HAVE_ED25519\n            if (ssl->peerEd25519KeyPresent) {\n                ret = Ed25519Verify(ssl, input + args->idx, args->sz,\n                    args->sigData, args->sigDataSz,\n                    ssl->peerEd25519Key,\n                #ifdef HAVE_PK_CALLBACKS\n                    &ssl->buffers.peerEd25519Key\n                #else\n                    NULL\n                #endif\n                );\n\n                if (ret >= 0) {\n                    FreeKey(ssl, DYNAMIC_TYPE_ED25519,\n                                                  (void**)&ssl->peerEd25519Key);\n                    ssl->peerEd25519KeyPresent = 0;\n                }\n            }\n        #endif\n        #ifdef HAVE_ED448\n            if (ssl->peerEd448KeyPresent) {\n                ret = Ed448Verify(ssl, input + args->idx, args->sz,\n                    args->sigData, args->sigDataSz,\n                    ssl->peerEd448Key,\n                #ifdef HAVE_PK_CALLBACKS\n                    &ssl->buffers.peerEd448Key\n                #else\n                    NULL\n                #endif\n                );\n\n                if (ret >= 0) {\n                    FreeKey(ssl, DYNAMIC_TYPE_ED448,\n                                                    (void**)&ssl->peerEd448Key);\n                    ssl->peerEd448KeyPresent = 0;\n                }\n            }\n        #endif\n        #ifdef HAVE_PQC\n            if (ssl->peerFalconKeyPresent) {\n                int res = 0;\n                WOLFSSL_MSG(\"Doing Falcon peer cert verify\");\n                ret = wc_falcon_verify_msg(input + args->idx, args->sz,\n                                    args->sigData, args->sigDataSz,\n                                    &res, ssl->peerFalconKey);\n\n                if ((ret >= 0) && (res == 1)) {\n                    FreeKey(ssl, DYNAMIC_TYPE_FALCON,\n                                                   (void**)&ssl->peerFalconKey);\n                    ssl->peerFalconKeyPresent = 0;\n                }\n            }\n        #endif\n\n            /* Check for error */\n            if (ret != 0) {\n                goto exit_dcv;\n            }\n\n            /* Advance state and proceed */\n            ssl->options.asyncState = TLS_ASYNC_VERIFY;\n        } /* case TLS_ASYNC_DO */\n        FALL_THROUGH;\n\n        case TLS_ASYNC_VERIFY:\n        {\n        #if !defined(NO_RSA) && defined(WC_RSA_PSS)\n            if (ssl->peerRsaKey != NULL && ssl->peerRsaKeyPresent != 0) {\n                ret = CheckRSASignature(ssl, args->sigAlgo, args->hashAlgo,\n                                        args->output, args->sendSz);\n                if (ret != 0)\n                    goto exit_dcv;\n\n                FreeKey(ssl, DYNAMIC_TYPE_RSA, (void**)&ssl->peerRsaKey);\n                ssl->peerRsaKeyPresent = 0;\n            }\n        #endif /* !NO_RSA && WC_RSA_PSS */\n\n            /* Advance state and proceed */\n            ssl->options.asyncState = TLS_ASYNC_FINALIZE;\n        } /* case TLS_ASYNC_VERIFY */\n        FALL_THROUGH;\n\n        case TLS_ASYNC_FINALIZE:\n        {\n            ssl->options.havePeerVerify = 1;\n\n            /* Set final index */\n            args->idx += args->sz;\n            *inOutIdx = args->idx;\n\n            /* Encryption is always on: add padding */\n            *inOutIdx += ssl->keys.padSz;\n\n            /* Advance state and proceed */\n            ssl->options.asyncState = TLS_ASYNC_END;\n\n        #if !defined(NO_WOLFSSL_CLIENT)\n            if (ssl->options.side == WOLFSSL_CLIENT_END)\n                ssl->options.serverState = SERVER_CERT_VERIFY_COMPLETE;\n        #endif\n        } /* case TLS_ASYNC_FINALIZE */\n        FALL_THROUGH;\n\n        case TLS_ASYNC_END:\n        {\n            break;\n        }\n\n        default:\n            ret = INPUT_CASE_ERROR;\n    } /* switch(ssl->options.asyncState) */\n\nexit_dcv:\n\n    WOLFSSL_LEAVE(\"DoTls13CertificateVerify\", ret);\n    WOLFSSL_END(WC_FUNC_CERTIFICATE_VERIFY_DO);\n\n#ifdef WOLFSSL_ASYNC_CRYPT\n    /* Handle async operation */\n    if (ret == WC_PENDING_E) {\n        /* Mark message as not received so it can process again */\n        ssl->msgsReceived.got_certificate_verify = 0;\n\n        return ret;\n    }\n    else\n#endif /* WOLFSSL_ASYNC_CRYPT */\n    if (ret != 0 && ret != INVALID_PARAMETER)\n        SendAlert(ssl, alert_fatal, decrypt_error);\n\n    /* Final cleanup */\n    FreeDcv13Args(ssl, args);\n    FreeKeyExchange(ssl);\n\n    return ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -54,7 +54,7 @@\n \n         case TLS_ASYNC_BUILD:\n         {\n-            int validSigAlgo = 0;\n+            int validSigAlgo;\n \n             /* Signature algorithm. */\n             if ((args->idx - args->begin) + ENUM_LEN + ENUM_LEN > totalSz) {\n@@ -80,35 +80,41 @@\n             }\n \n             /* Check for public key of required type. */\n+            /* Assume invalid unless signature algo matches the key provided */\n+            validSigAlgo = 0;\n         #ifdef HAVE_ED25519\n             if (args->sigAlgo == ed25519_sa_algo) {\n                 WOLFSSL_MSG(\"Peer sent ED25519 sig\");\n-                validSigAlgo = ssl->peerEd25519KeyPresent;\n+                validSigAlgo = (ssl->peerEd25519Key != NULL) &&\n+                                                     ssl->peerEd25519KeyPresent;\n             }\n         #endif\n         #ifdef HAVE_ED448\n             if (args->sigAlgo == ed448_sa_algo) {\n                 WOLFSSL_MSG(\"Peer sent ED448 sig\");\n-                validSigAlgo = ssl->peerEd448KeyPresent;\n+                validSigAlgo = (ssl->peerEd448Key != NULL) &&\n+                                                       ssl->peerEd448KeyPresent;\n             }\n         #endif\n         #ifdef HAVE_ECC\n             if (args->sigAlgo == ecc_dsa_sa_algo) {\n                 WOLFSSL_MSG(\"Peer sent ECC sig\");\n-                validSigAlgo = ssl->peerEccDsaKeyPresent;\n+                validSigAlgo = (ssl->peerEccDsaKey != NULL) &&\n+                                                      ssl->peerEccDsaKeyPresent;\n             }\n         #endif\n         #ifdef HAVE_PQC\n             if (args->sigAlgo == falcon_level1_sa_algo) {\n                 WOLFSSL_MSG(\"Peer sent Falcon Level 1 sig\");\n-                validSigAlgo = ssl->peerFalconKeyPresent;\n+                validSigAlgo = (ssl->peerFalconKey != NULL) &&\n+                                                      ssl->peerFalconKeyPresent;\n             }\n             if (args->sigAlgo == falcon_level5_sa_algo) {\n                 WOLFSSL_MSG(\"Peer sent Falcon Level 5 sig\");\n-                validSigAlgo = ssl->peerFalconKeyPresent;\n-            }\n-        #endif\n-\n+                validSigAlgo = (ssl->peerFalconKey != NULL) &&\n+                                                      ssl->peerFalconKeyPresent;\n+            }\n+        #endif\n         #ifndef NO_RSA\n             if (args->sigAlgo == rsa_sa_algo) {\n                 WOLFSSL_MSG(\"Peer sent PKCS#1.5 algo - not valid TLS 1.3\");\n@@ -122,8 +128,7 @@\n         #endif\n             if (!validSigAlgo) {\n                 WOLFSSL_MSG(\"Sig algo doesn't correspond to certficate\");\n-                ret = SIG_VERIFY_E;\n-                goto exit_dcv;\n+                ERROR_OUT(SIG_VERIFY_E, exit_dcv);\n             }\n \n             sig->buffer = (byte*)XMALLOC(args->sz, ssl->heap,",
        "diff_line_info": {
            "deleted_lines": [
                "            int validSigAlgo = 0;",
                "                validSigAlgo = ssl->peerEd25519KeyPresent;",
                "                validSigAlgo = ssl->peerEd448KeyPresent;",
                "                validSigAlgo = ssl->peerEccDsaKeyPresent;",
                "                validSigAlgo = ssl->peerFalconKeyPresent;",
                "                validSigAlgo = ssl->peerFalconKeyPresent;",
                "            }",
                "        #endif",
                "",
                "                ret = SIG_VERIFY_E;",
                "                goto exit_dcv;"
            ],
            "added_lines": [
                "            int validSigAlgo;",
                "            /* Assume invalid unless signature algo matches the key provided */",
                "            validSigAlgo = 0;",
                "                validSigAlgo = (ssl->peerEd25519Key != NULL) &&",
                "                                                     ssl->peerEd25519KeyPresent;",
                "                validSigAlgo = (ssl->peerEd448Key != NULL) &&",
                "                                                       ssl->peerEd448KeyPresent;",
                "                validSigAlgo = (ssl->peerEccDsaKey != NULL) &&",
                "                                                      ssl->peerEccDsaKeyPresent;",
                "                validSigAlgo = (ssl->peerFalconKey != NULL) &&",
                "                                                      ssl->peerFalconKeyPresent;",
                "                validSigAlgo = (ssl->peerFalconKey != NULL) &&",
                "                                                      ssl->peerFalconKeyPresent;",
                "            }",
                "        #endif",
                "                ERROR_OUT(SIG_VERIFY_E, exit_dcv);"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-25638",
        "func_name": "wolfSSL/wolfssl/DoTls13CertificateVerify",
        "description": "In wolfSSL before 5.2.0, certificate validation may be bypassed during attempted authentication by a TLS 1.3 client to a TLS 1.3 server. This occurs when the sig_algo field differs between the certificate_verify message and the certificate message.",
        "git_url": "https://github.com/wolfSSL/wolfssl/commit/e13861bcde8015bb99ddb034224afb66e2fb89b8",
        "commit_title": "Fix for mutual authentication to prevent mismatch of certificate and sig algo. Work from Sean P. ZD 13571",
        "commit_text": "",
        "func_before": "static int DoTls13CertificateVerify(WOLFSSL* ssl, byte* input,\n                                    word32* inOutIdx, word32 totalSz)\n{\n    int         ret = 0;\n    buffer*     sig = &ssl->buffers.sig;\n#ifdef WOLFSSL_ASYNC_CRYPT\n    Dcv13Args* args = (Dcv13Args*)ssl->async.args;\n    typedef char args_test[sizeof(ssl->async.args) >= sizeof(*args) ? 1 : -1];\n    (void)sizeof(args_test);\n#else\n    Dcv13Args  args[1];\n#endif\n\n    WOLFSSL_START(WC_FUNC_CERTIFICATE_VERIFY_DO);\n    WOLFSSL_ENTER(\"DoTls13CertificateVerify\");\n\n#ifdef WOLFSSL_ASYNC_CRYPT\n    ret = wolfSSL_AsyncPop(ssl, &ssl->options.asyncState);\n    if (ret != WC_NOT_PENDING_E) {\n        /* Check for error */\n        if (ret < 0)\n            goto exit_dcv;\n    }\n    else\n#endif\n    {\n        /* Reset state */\n        ret = 0;\n        ssl->options.asyncState = TLS_ASYNC_BEGIN;\n        XMEMSET(args, 0, sizeof(Dcv13Args));\n        args->hashAlgo = sha_mac;\n        args->sigAlgo = anonymous_sa_algo;\n        args->idx = *inOutIdx;\n        args->begin = *inOutIdx;\n    #ifdef WOLFSSL_ASYNC_CRYPT\n        ssl->async.freeArgs = FreeDcv13Args;\n    #endif\n    }\n\n    switch(ssl->options.asyncState)\n    {\n        case TLS_ASYNC_BEGIN:\n        {\n        #ifdef WOLFSSL_CALLBACKS\n            if (ssl->hsInfoOn) AddPacketName(ssl, \"CertificateVerify\");\n            if (ssl->toInfoOn) AddLateName(\"CertificateVerify\",\n                                           &ssl->timeoutInfo);\n        #endif\n\n            /* Advance state and proceed */\n            ssl->options.asyncState = TLS_ASYNC_BUILD;\n        } /* case TLS_ASYNC_BEGIN */\n        FALL_THROUGH;\n\n        case TLS_ASYNC_BUILD:\n        {\n            /* Signature algorithm. */\n            if ((args->idx - args->begin) + ENUM_LEN + ENUM_LEN > totalSz) {\n                ERROR_OUT(BUFFER_ERROR, exit_dcv);\n            }\n            ret = DecodeTls13SigAlg(input + args->idx, &args->hashAlgo,\n                                                                &args->sigAlgo);\n            if (ret < 0)\n                goto exit_dcv;\n            args->idx += OPAQUE16_LEN;\n\n            /* Signature length. */\n            if ((args->idx - args->begin) + OPAQUE16_LEN > totalSz) {\n                ERROR_OUT(BUFFER_ERROR, exit_dcv);\n            }\n            ato16(input + args->idx, &args->sz);\n            args->idx += OPAQUE16_LEN;\n\n            /* Signature data. */\n            if ((args->idx - args->begin) + args->sz > totalSz ||\n                                                       args->sz > ENCRYPT_LEN) {\n                ERROR_OUT(BUFFER_ERROR, exit_dcv);\n            }\n\n            /* Check for public key of required type. */\n        #ifdef HAVE_ED25519\n            if (args->sigAlgo == ed25519_sa_algo &&\n                                                  !ssl->peerEd25519KeyPresent) {\n                WOLFSSL_MSG(\"Peer sent ED25519 sig but not ED25519 cert\");\n                ret = SIG_VERIFY_E;\n                goto exit_dcv;\n            }\n        #endif\n        #ifdef HAVE_ED448\n            if (args->sigAlgo == ed448_sa_algo && !ssl->peerEd448KeyPresent) {\n                WOLFSSL_MSG(\"Peer sent ED448 sig but not ED448 cert\");\n                ret = SIG_VERIFY_E;\n                goto exit_dcv;\n            }\n        #endif\n        #ifdef HAVE_ECC\n            if (args->sigAlgo == ecc_dsa_sa_algo &&\n                                                   !ssl->peerEccDsaKeyPresent) {\n                WOLFSSL_MSG(\"Peer sent ECC sig but not ECC cert\");\n                ret = SIG_VERIFY_E;\n                goto exit_dcv;\n            }\n        #endif\n        #ifdef HAVE_PQC\n            if (args->sigAlgo == falcon_level1_sa_algo && !ssl->peerFalconKeyPresent) {\n                WOLFSSL_MSG(\"Peer sent Falcon Level 1 sig but different cert\");\n                ret = SIG_VERIFY_E;\n                goto exit_dcv;\n            }\n            if (args->sigAlgo == falcon_level5_sa_algo && !ssl->peerFalconKeyPresent) {\n                WOLFSSL_MSG(\"Peer sent Falcon Level 5 sig but different cert\");\n                ret = SIG_VERIFY_E;\n                goto exit_dcv;\n            }\n        #endif\n\n        #ifndef NO_RSA\n            if (args->sigAlgo == rsa_sa_algo) {\n                WOLFSSL_MSG(\"Peer sent PKCS#1.5 algo but not in certificate\");\n                ERROR_OUT(INVALID_PARAMETER, exit_dcv);\n            }\n            if (args->sigAlgo == rsa_pss_sa_algo &&\n                         (ssl->peerRsaKey == NULL || !ssl->peerRsaKeyPresent)) {\n                WOLFSSL_MSG(\"Peer sent RSA sig but not RSA cert\");\n                ret = SIG_VERIFY_E;\n                goto exit_dcv;\n            }\n        #endif\n\n            sig->buffer = (byte*)XMALLOC(args->sz, ssl->heap,\n                                         DYNAMIC_TYPE_SIGNATURE);\n            if (sig->buffer == NULL) {\n                ERROR_OUT(MEMORY_E, exit_dcv);\n            }\n            sig->length = args->sz;\n            XMEMCPY(sig->buffer, input + args->idx, args->sz);\n\n        #ifdef HAVE_ECC\n            if (ssl->peerEccDsaKeyPresent) {\n                WOLFSSL_MSG(\"Doing ECC peer cert verify\");\n\n                args->sigData = (byte*)XMALLOC(MAX_SIG_DATA_SZ, ssl->heap,\n                                                        DYNAMIC_TYPE_SIGNATURE);\n                if (args->sigData == NULL) {\n                    ERROR_OUT(MEMORY_E, exit_dcv);\n                }\n\n                ret = CreateSigData(ssl, args->sigData, &args->sigDataSz, 1);\n                if (ret != 0)\n                    goto exit_dcv;\n                ret = CreateECCEncodedSig(args->sigData,\n                    args->sigDataSz, args->hashAlgo);\n                if (ret < 0)\n                    goto exit_dcv;\n                args->sigDataSz = (word16)ret;\n                ret = 0;\n            }\n        #endif\n        #ifdef HAVE_ED25519\n            if (ssl->peerEd25519KeyPresent) {\n                WOLFSSL_MSG(\"Doing ED25519 peer cert verify\");\n\n                args->sigData = (byte*)XMALLOC(MAX_SIG_DATA_SZ, ssl->heap,\n                                                        DYNAMIC_TYPE_SIGNATURE);\n                if (args->sigData == NULL) {\n                    ERROR_OUT(MEMORY_E, exit_dcv);\n                }\n\n                CreateSigData(ssl, args->sigData, &args->sigDataSz, 1);\n                ret = 0;\n            }\n        #endif\n        #ifdef HAVE_ED448\n            if (ssl->peerEd448KeyPresent) {\n                WOLFSSL_MSG(\"Doing ED448 peer cert verify\");\n\n                args->sigData = (byte*)XMALLOC(MAX_SIG_DATA_SZ, ssl->heap,\n                                                        DYNAMIC_TYPE_SIGNATURE);\n                if (args->sigData == NULL) {\n                    ERROR_OUT(MEMORY_E, exit_dcv);\n                }\n\n                CreateSigData(ssl, args->sigData, &args->sigDataSz, 1);\n                ret = 0;\n            }\n       #endif\n       #ifdef HAVE_PQC\n            if (ssl->peerFalconKeyPresent) {\n                WOLFSSL_MSG(\"Doing Falcon peer cert verify\");\n\n                args->sigData = (byte*)XMALLOC(MAX_SIG_DATA_SZ, ssl->heap,\n                                                        DYNAMIC_TYPE_SIGNATURE);\n                if (args->sigData == NULL) {\n                    ERROR_OUT(MEMORY_E, exit_dcv);\n                }\n\n                CreateSigData(ssl, args->sigData, &args->sigDataSz, 1);\n                ret = 0;\n            }\n       #endif\n\n            /* Advance state and proceed */\n            ssl->options.asyncState = TLS_ASYNC_DO;\n        } /* case TLS_ASYNC_BUILD */\n        FALL_THROUGH;\n\n        case TLS_ASYNC_DO:\n        {\n        #ifndef NO_RSA\n            if (ssl->peerRsaKey != NULL && ssl->peerRsaKeyPresent != 0) {\n                ret = RsaVerify(ssl, sig->buffer, (word32)sig->length, &args->output,\n                    args->sigAlgo, args->hashAlgo, ssl->peerRsaKey,\n                #ifdef HAVE_PK_CALLBACKS\n                    &ssl->buffers.peerRsaKey\n                #else\n                    NULL\n                #endif\n                );\n                if (ret >= 0) {\n                    args->sendSz = ret;\n                    ret = 0;\n                }\n            }\n        #endif /* !NO_RSA */\n        #ifdef HAVE_ECC\n            if (ssl->peerEccDsaKeyPresent) {\n                ret = EccVerify(ssl, input + args->idx, args->sz,\n                    args->sigData, args->sigDataSz,\n                    ssl->peerEccDsaKey,\n                #ifdef HAVE_PK_CALLBACKS\n                    &ssl->buffers.peerEccDsaKey\n                #else\n                    NULL\n                #endif\n                );\n\n                if (ret >= 0) {\n                    FreeKey(ssl, DYNAMIC_TYPE_ECC, (void**)&ssl->peerEccDsaKey);\n                    ssl->peerEccDsaKeyPresent = 0;\n                }\n            }\n        #endif /* HAVE_ECC */\n        #ifdef HAVE_ED25519\n            if (ssl->peerEd25519KeyPresent) {\n                ret = Ed25519Verify(ssl, input + args->idx, args->sz,\n                    args->sigData, args->sigDataSz,\n                    ssl->peerEd25519Key,\n                #ifdef HAVE_PK_CALLBACKS\n                    &ssl->buffers.peerEd25519Key\n                #else\n                    NULL\n                #endif\n                );\n\n                if (ret >= 0) {\n                    FreeKey(ssl, DYNAMIC_TYPE_ED25519,\n                                                  (void**)&ssl->peerEd25519Key);\n                    ssl->peerEd25519KeyPresent = 0;\n                }\n            }\n        #endif\n        #ifdef HAVE_ED448\n            if (ssl->peerEd448KeyPresent) {\n                ret = Ed448Verify(ssl, input + args->idx, args->sz,\n                    args->sigData, args->sigDataSz,\n                    ssl->peerEd448Key,\n                #ifdef HAVE_PK_CALLBACKS\n                    &ssl->buffers.peerEd448Key\n                #else\n                    NULL\n                #endif\n                );\n\n                if (ret >= 0) {\n                    FreeKey(ssl, DYNAMIC_TYPE_ED448,\n                                                    (void**)&ssl->peerEd448Key);\n                    ssl->peerEd448KeyPresent = 0;\n                }\n            }\n        #endif\n        #ifdef HAVE_PQC\n            if (ssl->peerFalconKeyPresent) {\n                int res = 0;\n                WOLFSSL_MSG(\"Doing Falcon peer cert verify\");\n                ret = wc_falcon_verify_msg(input + args->idx, args->sz,\n                                    args->sigData, args->sigDataSz,\n                                    &res, ssl->peerFalconKey);\n\n                if ((ret >= 0) && (res == 1)) {\n                    FreeKey(ssl, DYNAMIC_TYPE_FALCON,\n                                                   (void**)&ssl->peerFalconKey);\n                    ssl->peerFalconKeyPresent = 0;\n                }\n            }\n        #endif\n\n            /* Check for error */\n            if (ret != 0) {\n                goto exit_dcv;\n            }\n\n            /* Advance state and proceed */\n            ssl->options.asyncState = TLS_ASYNC_VERIFY;\n        } /* case TLS_ASYNC_DO */\n        FALL_THROUGH;\n\n        case TLS_ASYNC_VERIFY:\n        {\n        #if !defined(NO_RSA) && defined(WC_RSA_PSS)\n            if (ssl->peerRsaKey != NULL && ssl->peerRsaKeyPresent != 0) {\n                ret = CheckRSASignature(ssl, args->sigAlgo, args->hashAlgo,\n                                        args->output, args->sendSz);\n                if (ret != 0)\n                    goto exit_dcv;\n\n                FreeKey(ssl, DYNAMIC_TYPE_RSA, (void**)&ssl->peerRsaKey);\n                ssl->peerRsaKeyPresent = 0;\n            }\n        #endif /* !NO_RSA && WC_RSA_PSS */\n\n            /* Advance state and proceed */\n            ssl->options.asyncState = TLS_ASYNC_FINALIZE;\n        } /* case TLS_ASYNC_VERIFY */\n        FALL_THROUGH;\n\n        case TLS_ASYNC_FINALIZE:\n        {\n            ssl->options.havePeerVerify = 1;\n\n            /* Set final index */\n            args->idx += args->sz;\n            *inOutIdx = args->idx;\n\n            /* Encryption is always on: add padding */\n            *inOutIdx += ssl->keys.padSz;\n\n            /* Advance state and proceed */\n            ssl->options.asyncState = TLS_ASYNC_END;\n\n        #if !defined(NO_WOLFSSL_CLIENT)\n            if (ssl->options.side == WOLFSSL_CLIENT_END)\n                ssl->options.serverState = SERVER_CERT_VERIFY_COMPLETE;\n        #endif\n        } /* case TLS_ASYNC_FINALIZE */\n        FALL_THROUGH;\n\n        case TLS_ASYNC_END:\n        {\n            break;\n        }\n\n        default:\n            ret = INPUT_CASE_ERROR;\n    } /* switch(ssl->options.asyncState) */\n\nexit_dcv:\n\n    WOLFSSL_LEAVE(\"DoTls13CertificateVerify\", ret);\n    WOLFSSL_END(WC_FUNC_CERTIFICATE_VERIFY_DO);\n\n#ifdef WOLFSSL_ASYNC_CRYPT\n    /* Handle async operation */\n    if (ret == WC_PENDING_E) {\n        /* Mark message as not received so it can process again */\n        ssl->msgsReceived.got_certificate_verify = 0;\n\n        return ret;\n    }\n    else\n#endif /* WOLFSSL_ASYNC_CRYPT */\n    if (ret != 0 && ret != INVALID_PARAMETER)\n        SendAlert(ssl, alert_fatal, decrypt_error);\n\n    /* Final cleanup */\n    FreeDcv13Args(ssl, args);\n    FreeKeyExchange(ssl);\n\n    return ret;\n}",
        "func": "static int DoTls13CertificateVerify(WOLFSSL* ssl, byte* input,\n                                    word32* inOutIdx, word32 totalSz)\n{\n    int         ret = 0;\n    buffer*     sig = &ssl->buffers.sig;\n#ifdef WOLFSSL_ASYNC_CRYPT\n    Dcv13Args* args = (Dcv13Args*)ssl->async.args;\n    typedef char args_test[sizeof(ssl->async.args) >= sizeof(*args) ? 1 : -1];\n    (void)sizeof(args_test);\n#else\n    Dcv13Args  args[1];\n#endif\n\n    WOLFSSL_START(WC_FUNC_CERTIFICATE_VERIFY_DO);\n    WOLFSSL_ENTER(\"DoTls13CertificateVerify\");\n\n#ifdef WOLFSSL_ASYNC_CRYPT\n    ret = wolfSSL_AsyncPop(ssl, &ssl->options.asyncState);\n    if (ret != WC_NOT_PENDING_E) {\n        /* Check for error */\n        if (ret < 0)\n            goto exit_dcv;\n    }\n    else\n#endif\n    {\n        /* Reset state */\n        ret = 0;\n        ssl->options.asyncState = TLS_ASYNC_BEGIN;\n        XMEMSET(args, 0, sizeof(Dcv13Args));\n        args->hashAlgo = sha_mac;\n        args->sigAlgo = anonymous_sa_algo;\n        args->idx = *inOutIdx;\n        args->begin = *inOutIdx;\n    #ifdef WOLFSSL_ASYNC_CRYPT\n        ssl->async.freeArgs = FreeDcv13Args;\n    #endif\n    }\n\n    switch(ssl->options.asyncState)\n    {\n        case TLS_ASYNC_BEGIN:\n        {\n        #ifdef WOLFSSL_CALLBACKS\n            if (ssl->hsInfoOn) AddPacketName(ssl, \"CertificateVerify\");\n            if (ssl->toInfoOn) AddLateName(\"CertificateVerify\",\n                                           &ssl->timeoutInfo);\n        #endif\n\n            /* Advance state and proceed */\n            ssl->options.asyncState = TLS_ASYNC_BUILD;\n        } /* case TLS_ASYNC_BEGIN */\n        FALL_THROUGH;\n\n        case TLS_ASYNC_BUILD:\n        {\n            int validSigAlgo = 0;\n\n            /* Signature algorithm. */\n            if ((args->idx - args->begin) + ENUM_LEN + ENUM_LEN > totalSz) {\n                ERROR_OUT(BUFFER_ERROR, exit_dcv);\n            }\n            ret = DecodeTls13SigAlg(input + args->idx, &args->hashAlgo,\n                                                                &args->sigAlgo);\n            if (ret < 0)\n                goto exit_dcv;\n            args->idx += OPAQUE16_LEN;\n\n            /* Signature length. */\n            if ((args->idx - args->begin) + OPAQUE16_LEN > totalSz) {\n                ERROR_OUT(BUFFER_ERROR, exit_dcv);\n            }\n            ato16(input + args->idx, &args->sz);\n            args->idx += OPAQUE16_LEN;\n\n            /* Signature data. */\n            if ((args->idx - args->begin) + args->sz > totalSz ||\n                                                       args->sz > ENCRYPT_LEN) {\n                ERROR_OUT(BUFFER_ERROR, exit_dcv);\n            }\n\n            /* Check for public key of required type. */\n        #ifdef HAVE_ED25519\n            if (args->sigAlgo == ed25519_sa_algo) {\n                WOLFSSL_MSG(\"Peer sent ED25519 sig\");\n                validSigAlgo = ssl->peerEd25519KeyPresent;\n            }\n        #endif\n        #ifdef HAVE_ED448\n            if (args->sigAlgo == ed448_sa_algo) {\n                WOLFSSL_MSG(\"Peer sent ED448 sig\");\n                validSigAlgo = ssl->peerEd448KeyPresent;\n            }\n        #endif\n        #ifdef HAVE_ECC\n            if (args->sigAlgo == ecc_dsa_sa_algo) {\n                WOLFSSL_MSG(\"Peer sent ECC sig\");\n                validSigAlgo = ssl->peerEccDsaKeyPresent;\n            }\n        #endif\n        #ifdef HAVE_PQC\n            if (args->sigAlgo == falcon_level1_sa_algo) {\n                WOLFSSL_MSG(\"Peer sent Falcon Level 1 sig\");\n                validSigAlgo = ssl->peerFalconKeyPresent;\n            }\n            if (args->sigAlgo == falcon_level5_sa_algo) {\n                WOLFSSL_MSG(\"Peer sent Falcon Level 5 sig\");\n                validSigAlgo = ssl->peerFalconKeyPresent;\n            }\n        #endif\n\n        #ifndef NO_RSA\n            if (args->sigAlgo == rsa_sa_algo) {\n                WOLFSSL_MSG(\"Peer sent PKCS#1.5 algo - not valid TLS 1.3\");\n                ERROR_OUT(INVALID_PARAMETER, exit_dcv);\n            }\n            if (args->sigAlgo == rsa_pss_sa_algo) {\n                WOLFSSL_MSG(\"Peer sent RSA sig\");\n                validSigAlgo = (ssl->peerRsaKey != NULL) &&\n                                                         ssl->peerRsaKeyPresent;\n            }\n        #endif\n            if (!validSigAlgo) {\n                WOLFSSL_MSG(\"Sig algo doesn't correspond to certficate\");\n                ret = SIG_VERIFY_E;\n                goto exit_dcv;\n            }\n\n            sig->buffer = (byte*)XMALLOC(args->sz, ssl->heap,\n                                         DYNAMIC_TYPE_SIGNATURE);\n            if (sig->buffer == NULL) {\n                ERROR_OUT(MEMORY_E, exit_dcv);\n            }\n            sig->length = args->sz;\n            XMEMCPY(sig->buffer, input + args->idx, args->sz);\n\n        #ifdef HAVE_ECC\n            if (ssl->peerEccDsaKeyPresent) {\n                WOLFSSL_MSG(\"Doing ECC peer cert verify\");\n\n                args->sigData = (byte*)XMALLOC(MAX_SIG_DATA_SZ, ssl->heap,\n                                                        DYNAMIC_TYPE_SIGNATURE);\n                if (args->sigData == NULL) {\n                    ERROR_OUT(MEMORY_E, exit_dcv);\n                }\n\n                ret = CreateSigData(ssl, args->sigData, &args->sigDataSz, 1);\n                if (ret != 0)\n                    goto exit_dcv;\n                ret = CreateECCEncodedSig(args->sigData,\n                    args->sigDataSz, args->hashAlgo);\n                if (ret < 0)\n                    goto exit_dcv;\n                args->sigDataSz = (word16)ret;\n                ret = 0;\n            }\n        #endif\n        #ifdef HAVE_ED25519\n            if (ssl->peerEd25519KeyPresent) {\n                WOLFSSL_MSG(\"Doing ED25519 peer cert verify\");\n\n                args->sigData = (byte*)XMALLOC(MAX_SIG_DATA_SZ, ssl->heap,\n                                                        DYNAMIC_TYPE_SIGNATURE);\n                if (args->sigData == NULL) {\n                    ERROR_OUT(MEMORY_E, exit_dcv);\n                }\n\n                CreateSigData(ssl, args->sigData, &args->sigDataSz, 1);\n                ret = 0;\n            }\n        #endif\n        #ifdef HAVE_ED448\n            if (ssl->peerEd448KeyPresent) {\n                WOLFSSL_MSG(\"Doing ED448 peer cert verify\");\n\n                args->sigData = (byte*)XMALLOC(MAX_SIG_DATA_SZ, ssl->heap,\n                                                        DYNAMIC_TYPE_SIGNATURE);\n                if (args->sigData == NULL) {\n                    ERROR_OUT(MEMORY_E, exit_dcv);\n                }\n\n                CreateSigData(ssl, args->sigData, &args->sigDataSz, 1);\n                ret = 0;\n            }\n       #endif\n       #ifdef HAVE_PQC\n            if (ssl->peerFalconKeyPresent) {\n                WOLFSSL_MSG(\"Doing Falcon peer cert verify\");\n\n                args->sigData = (byte*)XMALLOC(MAX_SIG_DATA_SZ, ssl->heap,\n                                                        DYNAMIC_TYPE_SIGNATURE);\n                if (args->sigData == NULL) {\n                    ERROR_OUT(MEMORY_E, exit_dcv);\n                }\n\n                CreateSigData(ssl, args->sigData, &args->sigDataSz, 1);\n                ret = 0;\n            }\n       #endif\n\n            /* Advance state and proceed */\n            ssl->options.asyncState = TLS_ASYNC_DO;\n        } /* case TLS_ASYNC_BUILD */\n        FALL_THROUGH;\n\n        case TLS_ASYNC_DO:\n        {\n        #ifndef NO_RSA\n            if (ssl->peerRsaKey != NULL && ssl->peerRsaKeyPresent != 0) {\n                ret = RsaVerify(ssl, sig->buffer, (word32)sig->length, &args->output,\n                    args->sigAlgo, args->hashAlgo, ssl->peerRsaKey,\n                #ifdef HAVE_PK_CALLBACKS\n                    &ssl->buffers.peerRsaKey\n                #else\n                    NULL\n                #endif\n                );\n                if (ret >= 0) {\n                    args->sendSz = ret;\n                    ret = 0;\n                }\n            }\n        #endif /* !NO_RSA */\n        #ifdef HAVE_ECC\n            if (ssl->peerEccDsaKeyPresent) {\n                ret = EccVerify(ssl, input + args->idx, args->sz,\n                    args->sigData, args->sigDataSz,\n                    ssl->peerEccDsaKey,\n                #ifdef HAVE_PK_CALLBACKS\n                    &ssl->buffers.peerEccDsaKey\n                #else\n                    NULL\n                #endif\n                );\n\n                if (ret >= 0) {\n                    FreeKey(ssl, DYNAMIC_TYPE_ECC, (void**)&ssl->peerEccDsaKey);\n                    ssl->peerEccDsaKeyPresent = 0;\n                }\n            }\n        #endif /* HAVE_ECC */\n        #ifdef HAVE_ED25519\n            if (ssl->peerEd25519KeyPresent) {\n                ret = Ed25519Verify(ssl, input + args->idx, args->sz,\n                    args->sigData, args->sigDataSz,\n                    ssl->peerEd25519Key,\n                #ifdef HAVE_PK_CALLBACKS\n                    &ssl->buffers.peerEd25519Key\n                #else\n                    NULL\n                #endif\n                );\n\n                if (ret >= 0) {\n                    FreeKey(ssl, DYNAMIC_TYPE_ED25519,\n                                                  (void**)&ssl->peerEd25519Key);\n                    ssl->peerEd25519KeyPresent = 0;\n                }\n            }\n        #endif\n        #ifdef HAVE_ED448\n            if (ssl->peerEd448KeyPresent) {\n                ret = Ed448Verify(ssl, input + args->idx, args->sz,\n                    args->sigData, args->sigDataSz,\n                    ssl->peerEd448Key,\n                #ifdef HAVE_PK_CALLBACKS\n                    &ssl->buffers.peerEd448Key\n                #else\n                    NULL\n                #endif\n                );\n\n                if (ret >= 0) {\n                    FreeKey(ssl, DYNAMIC_TYPE_ED448,\n                                                    (void**)&ssl->peerEd448Key);\n                    ssl->peerEd448KeyPresent = 0;\n                }\n            }\n        #endif\n        #ifdef HAVE_PQC\n            if (ssl->peerFalconKeyPresent) {\n                int res = 0;\n                WOLFSSL_MSG(\"Doing Falcon peer cert verify\");\n                ret = wc_falcon_verify_msg(input + args->idx, args->sz,\n                                    args->sigData, args->sigDataSz,\n                                    &res, ssl->peerFalconKey);\n\n                if ((ret >= 0) && (res == 1)) {\n                    FreeKey(ssl, DYNAMIC_TYPE_FALCON,\n                                                   (void**)&ssl->peerFalconKey);\n                    ssl->peerFalconKeyPresent = 0;\n                }\n            }\n        #endif\n\n            /* Check for error */\n            if (ret != 0) {\n                goto exit_dcv;\n            }\n\n            /* Advance state and proceed */\n            ssl->options.asyncState = TLS_ASYNC_VERIFY;\n        } /* case TLS_ASYNC_DO */\n        FALL_THROUGH;\n\n        case TLS_ASYNC_VERIFY:\n        {\n        #if !defined(NO_RSA) && defined(WC_RSA_PSS)\n            if (ssl->peerRsaKey != NULL && ssl->peerRsaKeyPresent != 0) {\n                ret = CheckRSASignature(ssl, args->sigAlgo, args->hashAlgo,\n                                        args->output, args->sendSz);\n                if (ret != 0)\n                    goto exit_dcv;\n\n                FreeKey(ssl, DYNAMIC_TYPE_RSA, (void**)&ssl->peerRsaKey);\n                ssl->peerRsaKeyPresent = 0;\n            }\n        #endif /* !NO_RSA && WC_RSA_PSS */\n\n            /* Advance state and proceed */\n            ssl->options.asyncState = TLS_ASYNC_FINALIZE;\n        } /* case TLS_ASYNC_VERIFY */\n        FALL_THROUGH;\n\n        case TLS_ASYNC_FINALIZE:\n        {\n            ssl->options.havePeerVerify = 1;\n\n            /* Set final index */\n            args->idx += args->sz;\n            *inOutIdx = args->idx;\n\n            /* Encryption is always on: add padding */\n            *inOutIdx += ssl->keys.padSz;\n\n            /* Advance state and proceed */\n            ssl->options.asyncState = TLS_ASYNC_END;\n\n        #if !defined(NO_WOLFSSL_CLIENT)\n            if (ssl->options.side == WOLFSSL_CLIENT_END)\n                ssl->options.serverState = SERVER_CERT_VERIFY_COMPLETE;\n        #endif\n        } /* case TLS_ASYNC_FINALIZE */\n        FALL_THROUGH;\n\n        case TLS_ASYNC_END:\n        {\n            break;\n        }\n\n        default:\n            ret = INPUT_CASE_ERROR;\n    } /* switch(ssl->options.asyncState) */\n\nexit_dcv:\n\n    WOLFSSL_LEAVE(\"DoTls13CertificateVerify\", ret);\n    WOLFSSL_END(WC_FUNC_CERTIFICATE_VERIFY_DO);\n\n#ifdef WOLFSSL_ASYNC_CRYPT\n    /* Handle async operation */\n    if (ret == WC_PENDING_E) {\n        /* Mark message as not received so it can process again */\n        ssl->msgsReceived.got_certificate_verify = 0;\n\n        return ret;\n    }\n    else\n#endif /* WOLFSSL_ASYNC_CRYPT */\n    if (ret != 0 && ret != INVALID_PARAMETER)\n        SendAlert(ssl, alert_fatal, decrypt_error);\n\n    /* Final cleanup */\n    FreeDcv13Args(ssl, args);\n    FreeKeyExchange(ssl);\n\n    return ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -54,6 +54,8 @@\n \n         case TLS_ASYNC_BUILD:\n         {\n+            int validSigAlgo = 0;\n+\n             /* Signature algorithm. */\n             if ((args->idx - args->begin) + ENUM_LEN + ENUM_LEN > totalSz) {\n                 ERROR_OUT(BUFFER_ERROR, exit_dcv);\n@@ -79,53 +81,50 @@\n \n             /* Check for public key of required type. */\n         #ifdef HAVE_ED25519\n-            if (args->sigAlgo == ed25519_sa_algo &&\n-                                                  !ssl->peerEd25519KeyPresent) {\n-                WOLFSSL_MSG(\"Peer sent ED25519 sig but not ED25519 cert\");\n+            if (args->sigAlgo == ed25519_sa_algo) {\n+                WOLFSSL_MSG(\"Peer sent ED25519 sig\");\n+                validSigAlgo = ssl->peerEd25519KeyPresent;\n+            }\n+        #endif\n+        #ifdef HAVE_ED448\n+            if (args->sigAlgo == ed448_sa_algo) {\n+                WOLFSSL_MSG(\"Peer sent ED448 sig\");\n+                validSigAlgo = ssl->peerEd448KeyPresent;\n+            }\n+        #endif\n+        #ifdef HAVE_ECC\n+            if (args->sigAlgo == ecc_dsa_sa_algo) {\n+                WOLFSSL_MSG(\"Peer sent ECC sig\");\n+                validSigAlgo = ssl->peerEccDsaKeyPresent;\n+            }\n+        #endif\n+        #ifdef HAVE_PQC\n+            if (args->sigAlgo == falcon_level1_sa_algo) {\n+                WOLFSSL_MSG(\"Peer sent Falcon Level 1 sig\");\n+                validSigAlgo = ssl->peerFalconKeyPresent;\n+            }\n+            if (args->sigAlgo == falcon_level5_sa_algo) {\n+                WOLFSSL_MSG(\"Peer sent Falcon Level 5 sig\");\n+                validSigAlgo = ssl->peerFalconKeyPresent;\n+            }\n+        #endif\n+\n+        #ifndef NO_RSA\n+            if (args->sigAlgo == rsa_sa_algo) {\n+                WOLFSSL_MSG(\"Peer sent PKCS#1.5 algo - not valid TLS 1.3\");\n+                ERROR_OUT(INVALID_PARAMETER, exit_dcv);\n+            }\n+            if (args->sigAlgo == rsa_pss_sa_algo) {\n+                WOLFSSL_MSG(\"Peer sent RSA sig\");\n+                validSigAlgo = (ssl->peerRsaKey != NULL) &&\n+                                                         ssl->peerRsaKeyPresent;\n+            }\n+        #endif\n+            if (!validSigAlgo) {\n+                WOLFSSL_MSG(\"Sig algo doesn't correspond to certficate\");\n                 ret = SIG_VERIFY_E;\n                 goto exit_dcv;\n             }\n-        #endif\n-        #ifdef HAVE_ED448\n-            if (args->sigAlgo == ed448_sa_algo && !ssl->peerEd448KeyPresent) {\n-                WOLFSSL_MSG(\"Peer sent ED448 sig but not ED448 cert\");\n-                ret = SIG_VERIFY_E;\n-                goto exit_dcv;\n-            }\n-        #endif\n-        #ifdef HAVE_ECC\n-            if (args->sigAlgo == ecc_dsa_sa_algo &&\n-                                                   !ssl->peerEccDsaKeyPresent) {\n-                WOLFSSL_MSG(\"Peer sent ECC sig but not ECC cert\");\n-                ret = SIG_VERIFY_E;\n-                goto exit_dcv;\n-            }\n-        #endif\n-        #ifdef HAVE_PQC\n-            if (args->sigAlgo == falcon_level1_sa_algo && !ssl->peerFalconKeyPresent) {\n-                WOLFSSL_MSG(\"Peer sent Falcon Level 1 sig but different cert\");\n-                ret = SIG_VERIFY_E;\n-                goto exit_dcv;\n-            }\n-            if (args->sigAlgo == falcon_level5_sa_algo && !ssl->peerFalconKeyPresent) {\n-                WOLFSSL_MSG(\"Peer sent Falcon Level 5 sig but different cert\");\n-                ret = SIG_VERIFY_E;\n-                goto exit_dcv;\n-            }\n-        #endif\n-\n-        #ifndef NO_RSA\n-            if (args->sigAlgo == rsa_sa_algo) {\n-                WOLFSSL_MSG(\"Peer sent PKCS#1.5 algo but not in certificate\");\n-                ERROR_OUT(INVALID_PARAMETER, exit_dcv);\n-            }\n-            if (args->sigAlgo == rsa_pss_sa_algo &&\n-                         (ssl->peerRsaKey == NULL || !ssl->peerRsaKeyPresent)) {\n-                WOLFSSL_MSG(\"Peer sent RSA sig but not RSA cert\");\n-                ret = SIG_VERIFY_E;\n-                goto exit_dcv;\n-            }\n-        #endif\n \n             sig->buffer = (byte*)XMALLOC(args->sz, ssl->heap,\n                                          DYNAMIC_TYPE_SIGNATURE);",
        "diff_line_info": {
            "deleted_lines": [
                "            if (args->sigAlgo == ed25519_sa_algo &&",
                "                                                  !ssl->peerEd25519KeyPresent) {",
                "                WOLFSSL_MSG(\"Peer sent ED25519 sig but not ED25519 cert\");",
                "        #endif",
                "        #ifdef HAVE_ED448",
                "            if (args->sigAlgo == ed448_sa_algo && !ssl->peerEd448KeyPresent) {",
                "                WOLFSSL_MSG(\"Peer sent ED448 sig but not ED448 cert\");",
                "                ret = SIG_VERIFY_E;",
                "                goto exit_dcv;",
                "            }",
                "        #endif",
                "        #ifdef HAVE_ECC",
                "            if (args->sigAlgo == ecc_dsa_sa_algo &&",
                "                                                   !ssl->peerEccDsaKeyPresent) {",
                "                WOLFSSL_MSG(\"Peer sent ECC sig but not ECC cert\");",
                "                ret = SIG_VERIFY_E;",
                "                goto exit_dcv;",
                "            }",
                "        #endif",
                "        #ifdef HAVE_PQC",
                "            if (args->sigAlgo == falcon_level1_sa_algo && !ssl->peerFalconKeyPresent) {",
                "                WOLFSSL_MSG(\"Peer sent Falcon Level 1 sig but different cert\");",
                "                ret = SIG_VERIFY_E;",
                "                goto exit_dcv;",
                "            }",
                "            if (args->sigAlgo == falcon_level5_sa_algo && !ssl->peerFalconKeyPresent) {",
                "                WOLFSSL_MSG(\"Peer sent Falcon Level 5 sig but different cert\");",
                "                ret = SIG_VERIFY_E;",
                "                goto exit_dcv;",
                "            }",
                "        #endif",
                "",
                "        #ifndef NO_RSA",
                "            if (args->sigAlgo == rsa_sa_algo) {",
                "                WOLFSSL_MSG(\"Peer sent PKCS#1.5 algo but not in certificate\");",
                "                ERROR_OUT(INVALID_PARAMETER, exit_dcv);",
                "            }",
                "            if (args->sigAlgo == rsa_pss_sa_algo &&",
                "                         (ssl->peerRsaKey == NULL || !ssl->peerRsaKeyPresent)) {",
                "                WOLFSSL_MSG(\"Peer sent RSA sig but not RSA cert\");",
                "                ret = SIG_VERIFY_E;",
                "                goto exit_dcv;",
                "            }",
                "        #endif"
            ],
            "added_lines": [
                "            int validSigAlgo = 0;",
                "",
                "            if (args->sigAlgo == ed25519_sa_algo) {",
                "                WOLFSSL_MSG(\"Peer sent ED25519 sig\");",
                "                validSigAlgo = ssl->peerEd25519KeyPresent;",
                "            }",
                "        #endif",
                "        #ifdef HAVE_ED448",
                "            if (args->sigAlgo == ed448_sa_algo) {",
                "                WOLFSSL_MSG(\"Peer sent ED448 sig\");",
                "                validSigAlgo = ssl->peerEd448KeyPresent;",
                "            }",
                "        #endif",
                "        #ifdef HAVE_ECC",
                "            if (args->sigAlgo == ecc_dsa_sa_algo) {",
                "                WOLFSSL_MSG(\"Peer sent ECC sig\");",
                "                validSigAlgo = ssl->peerEccDsaKeyPresent;",
                "            }",
                "        #endif",
                "        #ifdef HAVE_PQC",
                "            if (args->sigAlgo == falcon_level1_sa_algo) {",
                "                WOLFSSL_MSG(\"Peer sent Falcon Level 1 sig\");",
                "                validSigAlgo = ssl->peerFalconKeyPresent;",
                "            }",
                "            if (args->sigAlgo == falcon_level5_sa_algo) {",
                "                WOLFSSL_MSG(\"Peer sent Falcon Level 5 sig\");",
                "                validSigAlgo = ssl->peerFalconKeyPresent;",
                "            }",
                "        #endif",
                "",
                "        #ifndef NO_RSA",
                "            if (args->sigAlgo == rsa_sa_algo) {",
                "                WOLFSSL_MSG(\"Peer sent PKCS#1.5 algo - not valid TLS 1.3\");",
                "                ERROR_OUT(INVALID_PARAMETER, exit_dcv);",
                "            }",
                "            if (args->sigAlgo == rsa_pss_sa_algo) {",
                "                WOLFSSL_MSG(\"Peer sent RSA sig\");",
                "                validSigAlgo = (ssl->peerRsaKey != NULL) &&",
                "                                                         ssl->peerRsaKeyPresent;",
                "            }",
                "        #endif",
                "            if (!validSigAlgo) {",
                "                WOLFSSL_MSG(\"Sig algo doesn't correspond to certficate\");"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-25640",
        "func_name": "wolfSSL/wolfssl/DoTls13Finished",
        "description": "In wolfSSL before 5.2.0, a TLS 1.3 server cannot properly enforce a requirement for mutual authentication. A client can simply omit the certificate_verify message from the handshake, and never present a certificate.",
        "git_url": "https://github.com/wolfSSL/wolfssl/commit/3cdb1c639da94a9dc8c75590d0ec475e7f27c226",
        "commit_title": "Improve the client certificate checking logic. Make sure calling `wolfSSL_CTX_mutual_auth` is also checked.",
        "commit_text": "",
        "func_before": "int DoTls13Finished(WOLFSSL* ssl, const byte* input, word32* inOutIdx,\n                           word32 size, word32 totalSz, int sniff)\n{\n    int    ret;\n    word32 finishedSz = 0;\n    byte*  secret;\n    byte   mac[WC_MAX_DIGEST_SIZE];\n\n    WOLFSSL_START(WC_FUNC_FINISHED_DO);\n    WOLFSSL_ENTER(\"DoTls13Finished\");\n\n    /* check against totalSz */\n    if (*inOutIdx + size + ssl->keys.padSz > totalSz)\n        return BUFFER_E;\n\n    if (ssl->options.handShakeDone) {\n        ret = DeriveFinishedSecret(ssl, ssl->clientSecret,\n                                   ssl->keys.client_write_MAC_secret);\n        if (ret != 0)\n            return ret;\n\n        secret = ssl->keys.client_write_MAC_secret;\n    }\n    else if (ssl->options.side == WOLFSSL_CLIENT_END) {\n        /* All the handshake messages have been received to calculate\n         * client and server finished keys.\n         */\n        ret = DeriveFinishedSecret(ssl, ssl->clientSecret,\n                                   ssl->keys.client_write_MAC_secret);\n        if (ret != 0)\n            return ret;\n\n        ret = DeriveFinishedSecret(ssl, ssl->serverSecret,\n                                   ssl->keys.server_write_MAC_secret);\n        if (ret != 0)\n            return ret;\n\n        secret = ssl->keys.server_write_MAC_secret;\n    }\n    else {\n        secret = ssl->keys.client_write_MAC_secret;\n    }\n\n    if (sniff == NO_SNIFF) {\n        ret = BuildTls13HandshakeHmac(ssl, secret, mac, &finishedSz);\n    #if defined(OPENSSL_ALL) || defined(WOLFSSL_HAPROXY) || defined(WOLFSSL_WPAS)\n        if (ssl->options.side == WOLFSSL_CLIENT_END) {\n            XMEMCPY(ssl->serverFinished, mac, finishedSz);\n            ssl->serverFinished_len = finishedSz;\n        }\n        else {\n            XMEMCPY(ssl->clientFinished, mac, finishedSz);\n            ssl->clientFinished_len = finishedSz;\n        }\n    #endif\n        if (ret != 0)\n            return ret;\n        if (size != finishedSz)\n            return BUFFER_ERROR;\n    }\n\n#ifdef WOLFSSL_CALLBACKS\n    if (ssl->hsInfoOn) AddPacketName(ssl, \"Finished\");\n    if (ssl->toInfoOn) AddLateName(\"Finished\", &ssl->timeoutInfo);\n#endif\n\n    if (sniff == NO_SNIFF) {\n        /* Actually check verify data. */\n        if (XMEMCMP(input + *inOutIdx, mac, size) != 0){\n            WOLFSSL_MSG(\"Verify finished error on hashes\");\n            SendAlert(ssl, alert_fatal, decrypt_error);\n            return VERIFY_FINISHED_ERROR;\n        }\n    }\n\n    /* Force input exhaustion at ProcessReply by consuming padSz. */\n    *inOutIdx += size + ssl->keys.padSz;\n\n    if (ssl->options.side == WOLFSSL_SERVER_END &&\n                                                  !ssl->options.handShakeDone) {\n#ifdef WOLFSSL_EARLY_DATA\n        if (ssl->earlyData != no_early_data) {\n            if ((ret = DeriveTls13Keys(ssl, no_key, DECRYPT_SIDE_ONLY, 1)) != 0)\n                return ret;\n        }\n#endif\n        /* Setup keys for application data messages from client. */\n        if ((ret = SetKeysSide(ssl, DECRYPT_SIDE_ONLY)) != 0)\n            return ret;\n    }\n\n#ifndef NO_WOLFSSL_CLIENT\n    if (ssl->options.side == WOLFSSL_CLIENT_END)\n        ssl->options.serverState = SERVER_FINISHED_COMPLETE;\n#endif\n#ifndef NO_WOLFSSL_SERVER\n    if (ssl->options.side == WOLFSSL_SERVER_END) {\n        ssl->options.clientState = CLIENT_FINISHED_COMPLETE;\n        ssl->options.handShakeState = HANDSHAKE_DONE;\n        ssl->options.handShakeDone  = 1;\n    }\n#endif\n\n    WOLFSSL_LEAVE(\"DoTls13Finished\", 0);\n    WOLFSSL_END(WC_FUNC_FINISHED_DO);\n\n    return 0;\n}",
        "func": "int DoTls13Finished(WOLFSSL* ssl, const byte* input, word32* inOutIdx,\n                           word32 size, word32 totalSz, int sniff)\n{\n    int    ret;\n    word32 finishedSz = 0;\n    byte*  secret;\n    byte   mac[WC_MAX_DIGEST_SIZE];\n\n    WOLFSSL_START(WC_FUNC_FINISHED_DO);\n    WOLFSSL_ENTER(\"DoTls13Finished\");\n\n#if !defined(NO_CERTS) && !defined(WOLFSSL_NO_CLIENT_AUTH)\n    /* verify the client sent certificate if required */\n    if (ssl->options.side == WOLFSSL_SERVER_END &&\n            (ssl->options.mutualAuth || ssl->options.failNoCert)) {\n        if (!ssl->options.havePeerVerify && !ssl->options.resuming) {\n            ret = NO_PEER_CERT;\n            DoCertFatalAlert(ssl, ret);\n            return ret;\n        }\n    }\n#endif\n\n    /* check against totalSz */\n    if (*inOutIdx + size + ssl->keys.padSz > totalSz)\n        return BUFFER_E;\n\n    if (ssl->options.handShakeDone) {\n        ret = DeriveFinishedSecret(ssl, ssl->clientSecret,\n                                   ssl->keys.client_write_MAC_secret);\n        if (ret != 0)\n            return ret;\n\n        secret = ssl->keys.client_write_MAC_secret;\n    }\n    else if (ssl->options.side == WOLFSSL_CLIENT_END) {\n        /* All the handshake messages have been received to calculate\n         * client and server finished keys.\n         */\n        ret = DeriveFinishedSecret(ssl, ssl->clientSecret,\n                                   ssl->keys.client_write_MAC_secret);\n        if (ret != 0)\n            return ret;\n\n        ret = DeriveFinishedSecret(ssl, ssl->serverSecret,\n                                   ssl->keys.server_write_MAC_secret);\n        if (ret != 0)\n            return ret;\n\n        secret = ssl->keys.server_write_MAC_secret;\n    }\n    else {\n        secret = ssl->keys.client_write_MAC_secret;\n    }\n\n    if (sniff == NO_SNIFF) {\n        ret = BuildTls13HandshakeHmac(ssl, secret, mac, &finishedSz);\n    #if defined(OPENSSL_ALL) || defined(WOLFSSL_HAPROXY) || defined(WOLFSSL_WPAS)\n        if (ssl->options.side == WOLFSSL_CLIENT_END) {\n            XMEMCPY(ssl->serverFinished, mac, finishedSz);\n            ssl->serverFinished_len = finishedSz;\n        }\n        else {\n            XMEMCPY(ssl->clientFinished, mac, finishedSz);\n            ssl->clientFinished_len = finishedSz;\n        }\n    #endif\n        if (ret != 0)\n            return ret;\n        if (size != finishedSz)\n            return BUFFER_ERROR;\n    }\n\n#ifdef WOLFSSL_CALLBACKS\n    if (ssl->hsInfoOn) AddPacketName(ssl, \"Finished\");\n    if (ssl->toInfoOn) AddLateName(\"Finished\", &ssl->timeoutInfo);\n#endif\n\n    if (sniff == NO_SNIFF) {\n        /* Actually check verify data. */\n        if (XMEMCMP(input + *inOutIdx, mac, size) != 0){\n            WOLFSSL_MSG(\"Verify finished error on hashes\");\n            SendAlert(ssl, alert_fatal, decrypt_error);\n            return VERIFY_FINISHED_ERROR;\n        }\n    }\n\n    /* Force input exhaustion at ProcessReply by consuming padSz. */\n    *inOutIdx += size + ssl->keys.padSz;\n\n    if (ssl->options.side == WOLFSSL_SERVER_END &&\n                                                  !ssl->options.handShakeDone) {\n#ifdef WOLFSSL_EARLY_DATA\n        if (ssl->earlyData != no_early_data) {\n            if ((ret = DeriveTls13Keys(ssl, no_key, DECRYPT_SIDE_ONLY, 1)) != 0)\n                return ret;\n        }\n#endif\n        /* Setup keys for application data messages from client. */\n        if ((ret = SetKeysSide(ssl, DECRYPT_SIDE_ONLY)) != 0)\n            return ret;\n    }\n\n#ifndef NO_WOLFSSL_CLIENT\n    if (ssl->options.side == WOLFSSL_CLIENT_END)\n        ssl->options.serverState = SERVER_FINISHED_COMPLETE;\n#endif\n#ifndef NO_WOLFSSL_SERVER\n    if (ssl->options.side == WOLFSSL_SERVER_END) {\n        ssl->options.clientState = CLIENT_FINISHED_COMPLETE;\n        ssl->options.handShakeState = HANDSHAKE_DONE;\n        ssl->options.handShakeDone  = 1;\n    }\n#endif\n\n    WOLFSSL_LEAVE(\"DoTls13Finished\", 0);\n    WOLFSSL_END(WC_FUNC_FINISHED_DO);\n\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -8,6 +8,18 @@\n \n     WOLFSSL_START(WC_FUNC_FINISHED_DO);\n     WOLFSSL_ENTER(\"DoTls13Finished\");\n+\n+#if !defined(NO_CERTS) && !defined(WOLFSSL_NO_CLIENT_AUTH)\n+    /* verify the client sent certificate if required */\n+    if (ssl->options.side == WOLFSSL_SERVER_END &&\n+            (ssl->options.mutualAuth || ssl->options.failNoCert)) {\n+        if (!ssl->options.havePeerVerify && !ssl->options.resuming) {\n+            ret = NO_PEER_CERT;\n+            DoCertFatalAlert(ssl, ret);\n+            return ret;\n+        }\n+    }\n+#endif\n \n     /* check against totalSz */\n     if (*inOutIdx + size + ssl->keys.padSz > totalSz)",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "#if !defined(NO_CERTS) && !defined(WOLFSSL_NO_CLIENT_AUTH)",
                "    /* verify the client sent certificate if required */",
                "    if (ssl->options.side == WOLFSSL_SERVER_END &&",
                "            (ssl->options.mutualAuth || ssl->options.failNoCert)) {",
                "        if (!ssl->options.havePeerVerify && !ssl->options.resuming) {",
                "            ret = NO_PEER_CERT;",
                "            DoCertFatalAlert(ssl, ret);",
                "            return ret;",
                "        }",
                "    }",
                "#endif"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-25640",
        "func_name": "wolfSSL/wolfssl/DoCertFatalAlert",
        "description": "In wolfSSL before 5.2.0, a TLS 1.3 server cannot properly enforce a requirement for mutual authentication. A client can simply omit the certificate_verify message from the handshake, and never present a certificate.",
        "git_url": "https://github.com/wolfSSL/wolfssl/commit/3cdb1c639da94a9dc8c75590d0ec475e7f27c226",
        "commit_title": "Improve the client certificate checking logic. Make sure calling `wolfSSL_CTX_mutual_auth` is also checked.",
        "commit_text": "",
        "func_before": "static void DoCertFatalAlert(WOLFSSL* ssl, int ret)\n{\n    int alertWhy;\n    if (ssl == NULL || ret == 0) {\n        return;\n    }\n    WOLFSSL_ERROR(ret);\n\n    /* Determine alert reason */\n    alertWhy = bad_certificate;\n    if (ret == ASN_AFTER_DATE_E || ret == ASN_BEFORE_DATE_E) {\n        alertWhy = certificate_expired;\n    } else if (ret == ASN_NO_SIGNER_E) {\n        alertWhy = unknown_ca;\n    }\n#if (defined(OPENSSL_ALL) || defined(WOLFSSL_APACHE_HTTPD))\n    else if (ret == CRL_CERT_REVOKED) {\n        alertWhy = certificate_revoked;\n    }\n#endif\n    else if (ret == NO_PEER_CERT) {\n#ifdef WOLFSSL_TLS13\n        if (ssl->options.tls1_3) {\n            alertWhy = certificate_required;\n        }\n        else\n#endif\n        {\n            alertWhy = handshake_failure;\n        }\n    }\n\n    /* send fatal alert and mark connection closed */\n    SendAlert(ssl, alert_fatal, alertWhy); /* try to send */\n    ssl->options.isClosed = 1;\n}",
        "func": "void DoCertFatalAlert(WOLFSSL* ssl, int ret)\n{\n    int alertWhy;\n    if (ssl == NULL || ret == 0) {\n        return;\n    }\n    WOLFSSL_ERROR(ret);\n\n    /* Determine alert reason */\n    alertWhy = bad_certificate;\n    if (ret == ASN_AFTER_DATE_E || ret == ASN_BEFORE_DATE_E) {\n        alertWhy = certificate_expired;\n    } else if (ret == ASN_NO_SIGNER_E) {\n        alertWhy = unknown_ca;\n    }\n#if (defined(OPENSSL_ALL) || defined(WOLFSSL_APACHE_HTTPD))\n    else if (ret == CRL_CERT_REVOKED) {\n        alertWhy = certificate_revoked;\n    }\n#endif\n    else if (ret == NO_PEER_CERT) {\n#ifdef WOLFSSL_TLS13\n        if (ssl->options.tls1_3) {\n            alertWhy = certificate_required;\n        }\n        else\n#endif\n        {\n            alertWhy = handshake_failure;\n        }\n    }\n\n    /* send fatal alert and mark connection closed */\n    SendAlert(ssl, alert_fatal, alertWhy); /* try to send */\n    ssl->options.isClosed = 1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,4 @@\n-static void DoCertFatalAlert(WOLFSSL* ssl, int ret)\n+void DoCertFatalAlert(WOLFSSL* ssl, int ret)\n {\n     int alertWhy;\n     if (ssl == NULL || ret == 0) {",
        "diff_line_info": {
            "deleted_lines": [
                "static void DoCertFatalAlert(WOLFSSL* ssl, int ret)"
            ],
            "added_lines": [
                "void DoCertFatalAlert(WOLFSSL* ssl, int ret)"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-25640",
        "func_name": "wolfSSL/wolfssl/DoTls13Finished",
        "description": "In wolfSSL before 5.2.0, a TLS 1.3 server cannot properly enforce a requirement for mutual authentication. A client can simply omit the certificate_verify message from the handshake, and never present a certificate.",
        "git_url": "https://github.com/wolfSSL/wolfssl/commit/b60d2dccce9110fd2b985d99063e524e39bdf6f7",
        "commit_title": "Include the `havePeerCert` argument in the check.",
        "commit_text": "",
        "func_before": "int DoTls13Finished(WOLFSSL* ssl, const byte* input, word32* inOutIdx,\n                           word32 size, word32 totalSz, int sniff)\n{\n    int    ret;\n    word32 finishedSz = 0;\n    byte*  secret;\n    byte   mac[WC_MAX_DIGEST_SIZE];\n\n    WOLFSSL_START(WC_FUNC_FINISHED_DO);\n    WOLFSSL_ENTER(\"DoTls13Finished\");\n\n#if !defined(NO_CERTS) && !defined(WOLFSSL_NO_CLIENT_AUTH)\n    /* verify the client sent certificate if required */\n    if (ssl->options.side == WOLFSSL_SERVER_END &&\n            (ssl->options.mutualAuth || ssl->options.failNoCert)) {\n        if (!ssl->options.havePeerVerify && !ssl->options.resuming) {\n            ret = NO_PEER_CERT;\n            DoCertFatalAlert(ssl, ret);\n            return ret;\n        }\n    }\n#endif\n\n    /* check against totalSz */\n    if (*inOutIdx + size + ssl->keys.padSz > totalSz)\n        return BUFFER_E;\n\n    if (ssl->options.handShakeDone) {\n        ret = DeriveFinishedSecret(ssl, ssl->clientSecret,\n                                   ssl->keys.client_write_MAC_secret);\n        if (ret != 0)\n            return ret;\n\n        secret = ssl->keys.client_write_MAC_secret;\n    }\n    else if (ssl->options.side == WOLFSSL_CLIENT_END) {\n        /* All the handshake messages have been received to calculate\n         * client and server finished keys.\n         */\n        ret = DeriveFinishedSecret(ssl, ssl->clientSecret,\n                                   ssl->keys.client_write_MAC_secret);\n        if (ret != 0)\n            return ret;\n\n        ret = DeriveFinishedSecret(ssl, ssl->serverSecret,\n                                   ssl->keys.server_write_MAC_secret);\n        if (ret != 0)\n            return ret;\n\n        secret = ssl->keys.server_write_MAC_secret;\n    }\n    else {\n        secret = ssl->keys.client_write_MAC_secret;\n    }\n\n    if (sniff == NO_SNIFF) {\n        ret = BuildTls13HandshakeHmac(ssl, secret, mac, &finishedSz);\n    #if defined(OPENSSL_ALL) || defined(WOLFSSL_HAPROXY) || defined(WOLFSSL_WPAS)\n        if (ssl->options.side == WOLFSSL_CLIENT_END) {\n            XMEMCPY(ssl->serverFinished, mac, finishedSz);\n            ssl->serverFinished_len = finishedSz;\n        }\n        else {\n            XMEMCPY(ssl->clientFinished, mac, finishedSz);\n            ssl->clientFinished_len = finishedSz;\n        }\n    #endif\n        if (ret != 0)\n            return ret;\n        if (size != finishedSz)\n            return BUFFER_ERROR;\n    }\n\n#ifdef WOLFSSL_CALLBACKS\n    if (ssl->hsInfoOn) AddPacketName(ssl, \"Finished\");\n    if (ssl->toInfoOn) AddLateName(\"Finished\", &ssl->timeoutInfo);\n#endif\n\n    if (sniff == NO_SNIFF) {\n        /* Actually check verify data. */\n        if (XMEMCMP(input + *inOutIdx, mac, size) != 0){\n            WOLFSSL_MSG(\"Verify finished error on hashes\");\n            SendAlert(ssl, alert_fatal, decrypt_error);\n            return VERIFY_FINISHED_ERROR;\n        }\n    }\n\n    /* Force input exhaustion at ProcessReply by consuming padSz. */\n    *inOutIdx += size + ssl->keys.padSz;\n\n    if (ssl->options.side == WOLFSSL_SERVER_END &&\n                                                  !ssl->options.handShakeDone) {\n#ifdef WOLFSSL_EARLY_DATA\n        if (ssl->earlyData != no_early_data) {\n            if ((ret = DeriveTls13Keys(ssl, no_key, DECRYPT_SIDE_ONLY, 1)) != 0)\n                return ret;\n        }\n#endif\n        /* Setup keys for application data messages from client. */\n        if ((ret = SetKeysSide(ssl, DECRYPT_SIDE_ONLY)) != 0)\n            return ret;\n    }\n\n#ifndef NO_WOLFSSL_CLIENT\n    if (ssl->options.side == WOLFSSL_CLIENT_END)\n        ssl->options.serverState = SERVER_FINISHED_COMPLETE;\n#endif\n#ifndef NO_WOLFSSL_SERVER\n    if (ssl->options.side == WOLFSSL_SERVER_END) {\n        ssl->options.clientState = CLIENT_FINISHED_COMPLETE;\n        ssl->options.handShakeState = HANDSHAKE_DONE;\n        ssl->options.handShakeDone  = 1;\n    }\n#endif\n\n    WOLFSSL_LEAVE(\"DoTls13Finished\", 0);\n    WOLFSSL_END(WC_FUNC_FINISHED_DO);\n\n    return 0;\n}",
        "func": "int DoTls13Finished(WOLFSSL* ssl, const byte* input, word32* inOutIdx,\n                           word32 size, word32 totalSz, int sniff)\n{\n    int    ret;\n    word32 finishedSz = 0;\n    byte*  secret;\n    byte   mac[WC_MAX_DIGEST_SIZE];\n\n    WOLFSSL_START(WC_FUNC_FINISHED_DO);\n    WOLFSSL_ENTER(\"DoTls13Finished\");\n\n#if !defined(NO_CERTS) && !defined(WOLFSSL_NO_CLIENT_AUTH)\n    /* verify the client sent certificate if required */\n    if (ssl->options.side == WOLFSSL_SERVER_END && !ssl->options.resuming &&\n            (ssl->options.mutualAuth || ssl->options.failNoCert)) {\n        if (!ssl->options.havePeerCert || !ssl->options.havePeerVerify) {\n            ret = NO_PEER_CERT; /* NO_PEER_VERIFY */\n            WOLFSSL_MSG(\"TLS v1.3 client did not present peer cert\");\n            DoCertFatalAlert(ssl, ret);\n            return ret;\n        }\n    }\n#endif\n\n    /* check against totalSz */\n    if (*inOutIdx + size + ssl->keys.padSz > totalSz)\n        return BUFFER_E;\n\n    if (ssl->options.handShakeDone) {\n        ret = DeriveFinishedSecret(ssl, ssl->clientSecret,\n                                   ssl->keys.client_write_MAC_secret);\n        if (ret != 0)\n            return ret;\n\n        secret = ssl->keys.client_write_MAC_secret;\n    }\n    else if (ssl->options.side == WOLFSSL_CLIENT_END) {\n        /* All the handshake messages have been received to calculate\n         * client and server finished keys.\n         */\n        ret = DeriveFinishedSecret(ssl, ssl->clientSecret,\n                                   ssl->keys.client_write_MAC_secret);\n        if (ret != 0)\n            return ret;\n\n        ret = DeriveFinishedSecret(ssl, ssl->serverSecret,\n                                   ssl->keys.server_write_MAC_secret);\n        if (ret != 0)\n            return ret;\n\n        secret = ssl->keys.server_write_MAC_secret;\n    }\n    else {\n        secret = ssl->keys.client_write_MAC_secret;\n    }\n\n    if (sniff == NO_SNIFF) {\n        ret = BuildTls13HandshakeHmac(ssl, secret, mac, &finishedSz);\n    #if defined(OPENSSL_ALL) || defined(WOLFSSL_HAPROXY) || defined(WOLFSSL_WPAS)\n        if (ssl->options.side == WOLFSSL_CLIENT_END) {\n            XMEMCPY(ssl->serverFinished, mac, finishedSz);\n            ssl->serverFinished_len = finishedSz;\n        }\n        else {\n            XMEMCPY(ssl->clientFinished, mac, finishedSz);\n            ssl->clientFinished_len = finishedSz;\n        }\n    #endif\n        if (ret != 0)\n            return ret;\n        if (size != finishedSz)\n            return BUFFER_ERROR;\n    }\n\n#ifdef WOLFSSL_CALLBACKS\n    if (ssl->hsInfoOn) AddPacketName(ssl, \"Finished\");\n    if (ssl->toInfoOn) AddLateName(\"Finished\", &ssl->timeoutInfo);\n#endif\n\n    if (sniff == NO_SNIFF) {\n        /* Actually check verify data. */\n        if (XMEMCMP(input + *inOutIdx, mac, size) != 0){\n            WOLFSSL_MSG(\"Verify finished error on hashes\");\n            SendAlert(ssl, alert_fatal, decrypt_error);\n            return VERIFY_FINISHED_ERROR;\n        }\n    }\n\n    /* Force input exhaustion at ProcessReply by consuming padSz. */\n    *inOutIdx += size + ssl->keys.padSz;\n\n    if (ssl->options.side == WOLFSSL_SERVER_END &&\n                                                  !ssl->options.handShakeDone) {\n#ifdef WOLFSSL_EARLY_DATA\n        if (ssl->earlyData != no_early_data) {\n            if ((ret = DeriveTls13Keys(ssl, no_key, DECRYPT_SIDE_ONLY, 1)) != 0)\n                return ret;\n        }\n#endif\n        /* Setup keys for application data messages from client. */\n        if ((ret = SetKeysSide(ssl, DECRYPT_SIDE_ONLY)) != 0)\n            return ret;\n    }\n\n#ifndef NO_WOLFSSL_CLIENT\n    if (ssl->options.side == WOLFSSL_CLIENT_END)\n        ssl->options.serverState = SERVER_FINISHED_COMPLETE;\n#endif\n#ifndef NO_WOLFSSL_SERVER\n    if (ssl->options.side == WOLFSSL_SERVER_END) {\n        ssl->options.clientState = CLIENT_FINISHED_COMPLETE;\n        ssl->options.handShakeState = HANDSHAKE_DONE;\n        ssl->options.handShakeDone  = 1;\n    }\n#endif\n\n    WOLFSSL_LEAVE(\"DoTls13Finished\", 0);\n    WOLFSSL_END(WC_FUNC_FINISHED_DO);\n\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -11,10 +11,11 @@\n \n #if !defined(NO_CERTS) && !defined(WOLFSSL_NO_CLIENT_AUTH)\n     /* verify the client sent certificate if required */\n-    if (ssl->options.side == WOLFSSL_SERVER_END &&\n+    if (ssl->options.side == WOLFSSL_SERVER_END && !ssl->options.resuming &&\n             (ssl->options.mutualAuth || ssl->options.failNoCert)) {\n-        if (!ssl->options.havePeerVerify && !ssl->options.resuming) {\n-            ret = NO_PEER_CERT;\n+        if (!ssl->options.havePeerCert || !ssl->options.havePeerVerify) {\n+            ret = NO_PEER_CERT; /* NO_PEER_VERIFY */\n+            WOLFSSL_MSG(\"TLS v1.3 client did not present peer cert\");\n             DoCertFatalAlert(ssl, ret);\n             return ret;\n         }",
        "diff_line_info": {
            "deleted_lines": [
                "    if (ssl->options.side == WOLFSSL_SERVER_END &&",
                "        if (!ssl->options.havePeerVerify && !ssl->options.resuming) {",
                "            ret = NO_PEER_CERT;"
            ],
            "added_lines": [
                "    if (ssl->options.side == WOLFSSL_SERVER_END && !ssl->options.resuming &&",
                "        if (!ssl->options.havePeerCert || !ssl->options.havePeerVerify) {",
                "            ret = NO_PEER_CERT; /* NO_PEER_VERIFY */",
                "            WOLFSSL_MSG(\"TLS v1.3 client did not present peer cert\");"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-28352",
        "func_name": "weechat/network_init_gnutls",
        "description": "WeeChat (aka Wee Enhanced Environment for Chat) 3.2 to 3.4 before 3.4.1 does not properly verify the TLS certificate of the server, after certain GnuTLS options are changed, which allows man-in-the-middle attackers to spoof a TLS chat server via an arbitrary certificate. NOTE: this only affects situations where weechat.network.gnutls_ca_system or weechat.network.gnutls_ca_user is changed without a WeeChat restart.",
        "git_url": "https://github.com/weechat/weechat/commit/600413909804edfd32c53ea3d47db5b6d2871a89",
        "commit_title": "core: set again TLS verification functions after GnuTLS options are changed (closes #1763)",
        "commit_text": " When changing the options weechat.network.gnutls_ca_system or weechat.network.gnutls_ca_user, the GnuTLS credentials are freed then allocated again, but the verification function used to check the certificate on connection is not set again.  As a consequence, any TLS connection is made without checking the certificate.  This regression was introduced in version 3.2, when the options were changed to automatically load system certificates without having to give the path, and to let user give an extra custom path with certificates.",
        "func_before": "void\nnetwork_init_gnutls ()\n{\n    if (!weechat_no_gnutls)\n    {\n        gnutls_global_init ();\n        gnutls_certificate_allocate_credentials (&gnutls_xcred);\n        network_load_ca_files (0);\n#if LIBGNUTLS_VERSION_NUMBER >= 0x02090a /* 2.9.10 */\n        gnutls_certificate_set_verify_function (gnutls_xcred,\n                                                &hook_connect_gnutls_verify_certificates);\n#endif /* LIBGNUTLS_VERSION_NUMBER >= 0x02090a */\n#if LIBGNUTLS_VERSION_NUMBER >= 0x020b00 /* 2.11.0 */\n        gnutls_certificate_set_retrieve_function (gnutls_xcred,\n                                                  &hook_connect_gnutls_set_certificates);\n#else\n        gnutls_certificate_client_set_retrieve_function (gnutls_xcred,\n                                                         &hook_connect_gnutls_set_certificates);\n#endif /* LIBGNUTLS_VERSION_NUMBER >= 0x020b00 */\n    }\n\n    network_init_gnutls_ok = 1;\n}",
        "func": "void\nnetwork_init_gnutls ()\n{\n    if (!weechat_no_gnutls)\n    {\n        gnutls_global_init ();\n        network_allocate_credentials ();\n        network_load_ca_files (0);\n    }\n\n    network_init_gnutls_ok = 1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,19 +4,8 @@\n     if (!weechat_no_gnutls)\n     {\n         gnutls_global_init ();\n-        gnutls_certificate_allocate_credentials (&gnutls_xcred);\n+        network_allocate_credentials ();\n         network_load_ca_files (0);\n-#if LIBGNUTLS_VERSION_NUMBER >= 0x02090a /* 2.9.10 */\n-        gnutls_certificate_set_verify_function (gnutls_xcred,\n-                                                &hook_connect_gnutls_verify_certificates);\n-#endif /* LIBGNUTLS_VERSION_NUMBER >= 0x02090a */\n-#if LIBGNUTLS_VERSION_NUMBER >= 0x020b00 /* 2.11.0 */\n-        gnutls_certificate_set_retrieve_function (gnutls_xcred,\n-                                                  &hook_connect_gnutls_set_certificates);\n-#else\n-        gnutls_certificate_client_set_retrieve_function (gnutls_xcred,\n-                                                         &hook_connect_gnutls_set_certificates);\n-#endif /* LIBGNUTLS_VERSION_NUMBER >= 0x020b00 */\n     }\n \n     network_init_gnutls_ok = 1;",
        "diff_line_info": {
            "deleted_lines": [
                "        gnutls_certificate_allocate_credentials (&gnutls_xcred);",
                "#if LIBGNUTLS_VERSION_NUMBER >= 0x02090a /* 2.9.10 */",
                "        gnutls_certificate_set_verify_function (gnutls_xcred,",
                "                                                &hook_connect_gnutls_verify_certificates);",
                "#endif /* LIBGNUTLS_VERSION_NUMBER >= 0x02090a */",
                "#if LIBGNUTLS_VERSION_NUMBER >= 0x020b00 /* 2.11.0 */",
                "        gnutls_certificate_set_retrieve_function (gnutls_xcred,",
                "                                                  &hook_connect_gnutls_set_certificates);",
                "#else",
                "        gnutls_certificate_client_set_retrieve_function (gnutls_xcred,",
                "                                                         &hook_connect_gnutls_set_certificates);",
                "#endif /* LIBGNUTLS_VERSION_NUMBER >= 0x020b00 */"
            ],
            "added_lines": [
                "        network_allocate_credentials ();"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-28352",
        "func_name": "weechat/network_reload_ca_files",
        "description": "WeeChat (aka Wee Enhanced Environment for Chat) 3.2 to 3.4 before 3.4.1 does not properly verify the TLS certificate of the server, after certain GnuTLS options are changed, which allows man-in-the-middle attackers to spoof a TLS chat server via an arbitrary certificate. NOTE: this only affects situations where weechat.network.gnutls_ca_system or weechat.network.gnutls_ca_user is changed without a WeeChat restart.",
        "git_url": "https://github.com/weechat/weechat/commit/600413909804edfd32c53ea3d47db5b6d2871a89",
        "commit_title": "core: set again TLS verification functions after GnuTLS options are changed (closes #1763)",
        "commit_text": " When changing the options weechat.network.gnutls_ca_system or weechat.network.gnutls_ca_user, the GnuTLS credentials are freed then allocated again, but the verification function used to check the certificate on connection is not set again.  As a consequence, any TLS connection is made without checking the certificate.  This regression was introduced in version 3.2, when the options were changed to automatically load system certificates without having to give the path, and to let user give an extra custom path with certificates.",
        "func_before": "void\nnetwork_reload_ca_files (int force_display)\n{\n    if (weechat_no_gnutls)\n        return;\n\n    gnutls_certificate_free_credentials (gnutls_xcred);\n    if (force_display || (weechat_debug_core >= 1))\n    {\n        gui_chat_printf (NULL,\n                         NG_(\"%d certificate purged\",\n                             \"%d certificates purged\",\n                             network_num_certs),\n                         network_num_certs);\n    }\n\n    gnutls_certificate_allocate_credentials (&gnutls_xcred);\n\n    network_load_ca_files (force_display);\n}",
        "func": "void\nnetwork_reload_ca_files (int force_display)\n{\n    if (weechat_no_gnutls)\n        return;\n\n    gnutls_certificate_free_credentials (gnutls_xcred);\n    if (force_display || (weechat_debug_core >= 1))\n    {\n        gui_chat_printf (NULL,\n                         NG_(\"%d certificate purged\",\n                             \"%d certificates purged\",\n                             network_num_certs),\n                         network_num_certs);\n    }\n    network_allocate_credentials ();\n    network_load_ca_files (force_display);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -13,8 +13,6 @@\n                              network_num_certs),\n                          network_num_certs);\n     }\n-\n-    gnutls_certificate_allocate_credentials (&gnutls_xcred);\n-\n+    network_allocate_credentials ();\n     network_load_ca_files (force_display);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "",
                "    gnutls_certificate_allocate_credentials (&gnutls_xcred);",
                ""
            ],
            "added_lines": [
                "    network_allocate_credentials ();"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-1343",
        "func_name": "openssl/ocsp_verify_signer",
        "description": "The function `OCSP_basic_verify` verifies the signer certificate on an OCSP response. In the case where the (non-default) flag OCSP_NOCHECKS is used then the response will be positive (meaning a successful verification) even in the case where the response signing certificate fails to verify. It is anticipated that most users of `OCSP_basic_verify` will not use the OCSP_NOCHECKS flag. In this case the `OCSP_basic_verify` function will return a negative value (indicating a fatal error) in the case of a certificate verification failure. The normal expected return value in this case would be 0. This issue also impacts the command line OpenSSL \"ocsp\" application. When verifying an ocsp response with the \"-no_cert_checks\" option the command line application will report that the verification is successful even though it has in fact failed. In this case the incorrect successful response will also be accompanied by error messages showing the failure and contradicting the apparently successful result. Fixed in OpenSSL 3.0.3 (Affected 3.0.0,3.0.1,3.0.2).",
        "git_url": "https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=2eda98790c5c2741d76d23cc1e74b0dc4f4b391a",
        "commit_title": "",
        "commit_text": "Fix OCSP_basic_verify signer certificate validation  The function `OCSP_basic_verify` validates the signer certificate on an OCSP response. The internal function, ocsp_verify_signer, is responsible for this and is expected to return a 0 value in the event of a failure to verify. Unfortunately, due to a bug, it actually returns with a postive success response in this case. In the normal course of events OCSP_basic_verify will then continue and will fail anyway in the ocsp_check_issuer function because the supplied \"chain\" value will be empty in the case that ocsp_verify_signer failed to verify the chain. This will cause OCSP_basic_verify to return with a negative result (fatal error). Normally in the event of a failure to verify it should return with 0.  However, in the case of the OCSP_NOCHECKS flag being used, OCSP_basic_verify will return with a positvie result. This could lead to callers trusting an OCSP Basic response when it should not be.  CVE-2022-1343  Fixes #18053  ",
        "func_before": "static int ocsp_verify_signer(X509 *signer, int response,\n                              X509_STORE *st, unsigned long flags,\n                              STACK_OF(X509) *untrusted, STACK_OF(X509) **chain)\n{\n    X509_STORE_CTX *ctx = X509_STORE_CTX_new();\n    X509_VERIFY_PARAM *vp;\n    int ret = -1;\n\n    if (ctx == NULL) {\n        ERR_raise(ERR_LIB_OCSP, ERR_R_MALLOC_FAILURE);\n        goto end;\n    }\n    if (!X509_STORE_CTX_init(ctx, st, signer, untrusted)) {\n        ERR_raise(ERR_LIB_OCSP, ERR_R_X509_LIB);\n        goto end;\n    }\n    if ((vp = X509_STORE_CTX_get0_param(ctx)) == NULL)\n        goto end;\n    if ((flags & OCSP_PARTIAL_CHAIN) != 0)\n        X509_VERIFY_PARAM_set_flags(vp, X509_V_FLAG_PARTIAL_CHAIN);\n    if (response\n            && X509_get_ext_by_NID(signer, NID_id_pkix_OCSP_noCheck, -1) >= 0)\n        /*\n         * Locally disable revocation status checking for OCSP responder cert.\n         * Done here for CRLs; should be done also for OCSP-based checks.\n         */\n        X509_VERIFY_PARAM_clear_flags(vp, X509_V_FLAG_CRL_CHECK);\n    X509_STORE_CTX_set_purpose(ctx, X509_PURPOSE_OCSP_HELPER);\n    X509_STORE_CTX_set_trust(ctx, X509_TRUST_OCSP_REQUEST);\n\n    ret = X509_verify_cert(ctx);\n    if (ret <= 0) {\n        ret = X509_STORE_CTX_get_error(ctx);\n        ERR_raise_data(ERR_LIB_OCSP, OCSP_R_CERTIFICATE_VERIFY_ERROR,\n                       \"Verify error: %s\", X509_verify_cert_error_string(ret));\n        goto end;\n    }\n    if (chain != NULL)\n        *chain = X509_STORE_CTX_get1_chain(ctx);\n\n end:\n    X509_STORE_CTX_free(ctx);\n    return ret;\n}",
        "func": "static int ocsp_verify_signer(X509 *signer, int response,\n                              X509_STORE *st, unsigned long flags,\n                              STACK_OF(X509) *untrusted, STACK_OF(X509) **chain)\n{\n    X509_STORE_CTX *ctx = X509_STORE_CTX_new();\n    X509_VERIFY_PARAM *vp;\n    int ret = -1;\n\n    if (ctx == NULL) {\n        ERR_raise(ERR_LIB_OCSP, ERR_R_MALLOC_FAILURE);\n        goto end;\n    }\n    if (!X509_STORE_CTX_init(ctx, st, signer, untrusted)) {\n        ERR_raise(ERR_LIB_OCSP, ERR_R_X509_LIB);\n        goto end;\n    }\n    if ((vp = X509_STORE_CTX_get0_param(ctx)) == NULL)\n        goto end;\n    if ((flags & OCSP_PARTIAL_CHAIN) != 0)\n        X509_VERIFY_PARAM_set_flags(vp, X509_V_FLAG_PARTIAL_CHAIN);\n    if (response\n            && X509_get_ext_by_NID(signer, NID_id_pkix_OCSP_noCheck, -1) >= 0)\n        /*\n         * Locally disable revocation status checking for OCSP responder cert.\n         * Done here for CRLs; should be done also for OCSP-based checks.\n         */\n        X509_VERIFY_PARAM_clear_flags(vp, X509_V_FLAG_CRL_CHECK);\n    X509_STORE_CTX_set_purpose(ctx, X509_PURPOSE_OCSP_HELPER);\n    X509_STORE_CTX_set_trust(ctx, X509_TRUST_OCSP_REQUEST);\n\n    ret = X509_verify_cert(ctx);\n    if (ret <= 0) {\n        int err = X509_STORE_CTX_get_error(ctx);\n\n        ERR_raise_data(ERR_LIB_OCSP, OCSP_R_CERTIFICATE_VERIFY_ERROR,\n                       \"Verify error: %s\", X509_verify_cert_error_string(err));\n        goto end;\n    }\n    if (chain != NULL)\n        *chain = X509_STORE_CTX_get1_chain(ctx);\n\n end:\n    X509_STORE_CTX_free(ctx);\n    return ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -30,9 +30,10 @@\n \n     ret = X509_verify_cert(ctx);\n     if (ret <= 0) {\n-        ret = X509_STORE_CTX_get_error(ctx);\n+        int err = X509_STORE_CTX_get_error(ctx);\n+\n         ERR_raise_data(ERR_LIB_OCSP, OCSP_R_CERTIFICATE_VERIFY_ERROR,\n-                       \"Verify error: %s\", X509_verify_cert_error_string(ret));\n+                       \"Verify error: %s\", X509_verify_cert_error_string(err));\n         goto end;\n     }\n     if (chain != NULL)",
        "diff_line_info": {
            "deleted_lines": [
                "        ret = X509_STORE_CTX_get_error(ctx);",
                "                       \"Verify error: %s\", X509_verify_cert_error_string(ret));"
            ],
            "added_lines": [
                "        int err = X509_STORE_CTX_get_error(ctx);",
                "",
                "                       \"Verify error: %s\", X509_verify_cert_error_string(err));"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-7041",
        "func_name": "adrienverge/openfortivpn/ssl_verify_cert",
        "description": "An issue was discovered in openfortivpn 1.11.0 when used with OpenSSL 1.0.2 or later. tunnel.c mishandles certificate validation because an X509_check_host negative error code is interpreted as a successful return value.",
        "git_url": "https://github.com/adrienverge/openfortivpn/commit/60660e00b80bad0fadcf39aee86f6f8756c94f91",
        "commit_title": "correctly check return value of X509_check_host",
        "commit_text": " CVE-2020-7041 incorrect use of X509_check_host (regarding return value) is fixed with this commit.  The flaw came in with #242 and prevented proper host name verification when openssl >= 1.0.2 was in use since openfortivpn 1.7.0.",
        "func_before": "static int ssl_verify_cert(struct tunnel *tunnel)\n{\n\tint ret = -1;\n\tint cert_valid = 0;\n\tunsigned char digest[SHA256LEN];\n\tunsigned int len;\n\tstruct x509_digest *elem;\n\tchar digest_str[SHA256STRLEN], *subject, *issuer;\n\tchar *line;\n\tint i;\n\tX509_NAME *subj;\n\tchar common_name[FIELD_SIZE + 1];\n\n\tSSL_set_verify(tunnel->ssl_handle, SSL_VERIFY_PEER, NULL);\n\n\tX509 *cert = SSL_get_peer_certificate(tunnel->ssl_handle);\n\tif (cert == NULL) {\n\t\tlog_error(\"Unable to get gateway certificate.\\n\");\n\t\treturn 1;\n\t}\n\n\tsubj = X509_get_subject_name(cert);\n\n#ifdef HAVE_X509_CHECK_HOST\n\t// Use OpenSSL native host validation if v >= 1.0.2.\n\tif (X509_check_host(cert, common_name, FIELD_SIZE, 0, NULL))\n\t\tcert_valid = 1;\n#else\n\t// Use explicit Common Name check if native validation not available.\n\t// Note: this will ignore Subject Alternative Name fields.\n\tif (subj\n\t    && X509_NAME_get_text_by_NID(subj, NID_commonName, common_name,\n\t                                 FIELD_SIZE) > 0\n\t    && strncasecmp(common_name, tunnel->config->gateway_host,\n\t                   FIELD_SIZE) == 0)\n\t\tcert_valid = 1;\n#endif\n\n\t// Try to validate certificate using local PKI\n\tif (cert_valid\n\t    && SSL_get_verify_result(tunnel->ssl_handle) == X509_V_OK) {\n\t\tlog_debug(\"Gateway certificate validation succeeded.\\n\");\n\t\tret = 0;\n\t\tgoto free_cert;\n\t}\n\tlog_debug(\"Gateway certificate validation failed.\\n\");\n\n\t// If validation failed, check if cert is in the white list\n\tif (X509_digest(cert, EVP_sha256(), digest, &len) <= 0\n\t    || len != SHA256LEN) {\n\t\tlog_error(\"Could not compute certificate sha256 digest.\\n\");\n\t\tgoto free_cert;\n\t}\n\t// Encode digest in base16\n\tfor (i = 0; i < SHA256LEN; i++)\n\t\tsprintf(&digest_str[2 * i], \"%02x\", digest[i]);\n\tdigest_str[SHA256STRLEN - 1] = '\\0';\n\t// Is it in whitelist?\n\tfor (elem = tunnel->config->cert_whitelist; elem != NULL;\n\t     elem = elem->next)\n\t\tif (memcmp(digest_str, elem->data, SHA256STRLEN - 1) == 0)\n\t\t\tbreak;\n\tif (elem != NULL) { // break before end of loop\n\t\tlog_debug(\"Gateway certificate digest found in white list.\\n\");\n\t\tret = 0;\n\t\tgoto free_cert;\n\t}\n\n\tsubject = X509_NAME_oneline(subj, NULL, 0);\n\tissuer = X509_NAME_oneline(X509_get_issuer_name(cert), NULL, 0);\n\n\tlog_error(\"Gateway certificate validation failed, and the certificate digest in not in the local whitelist. If you trust it, rerun with:\\n\");\n\tlog_error(\"    --trusted-cert %s\\n\", digest_str);\n\tlog_error(\"or add this line to your config file:\\n\");\n\tlog_error(\"    trusted-cert = %s\\n\", digest_str);\n\tlog_error(\"Gateway certificate:\\n\");\n\tlog_error(\"    subject:\\n\");\n\tfor (line = strtok(subject, \"/\"); line != NULL;\n\t     line = strtok(NULL, \"/\"))\n\t\tlog_error(\"        %s\\n\", line);\n\tlog_error(\"    issuer:\\n\");\n\tfor (line = strtok(issuer, \"/\"); line != NULL;\n\t     line = strtok(NULL, \"/\"))\n\t\tlog_error(\"        %s\\n\", line);\n\tlog_error(\"    sha256 digest:\\n\");\n\tlog_error(\"        %s\\n\", digest_str);\n\nfree_cert:\n\tX509_free(cert);\n\treturn ret;\n}",
        "func": "static int ssl_verify_cert(struct tunnel *tunnel)\n{\n\tint ret = -1;\n\tint cert_valid = 0;\n\tunsigned char digest[SHA256LEN];\n\tunsigned int len;\n\tstruct x509_digest *elem;\n\tchar digest_str[SHA256STRLEN], *subject, *issuer;\n\tchar *line;\n\tint i;\n\tX509_NAME *subj;\n\tchar common_name[FIELD_SIZE + 1];\n\n\tSSL_set_verify(tunnel->ssl_handle, SSL_VERIFY_PEER, NULL);\n\n\tX509 *cert = SSL_get_peer_certificate(tunnel->ssl_handle);\n\tif (cert == NULL) {\n\t\tlog_error(\"Unable to get gateway certificate.\\n\");\n\t\treturn 1;\n\t}\n\n\tsubj = X509_get_subject_name(cert);\n\n#ifdef HAVE_X509_CHECK_HOST\n\t// Use OpenSSL native host validation if v >= 1.0.2.\n\t// correctly check return value of X509_check_host\n\tif (X509_check_host(cert, common_name, FIELD_SIZE, 0, NULL) == 1)\n\t\tcert_valid = 1;\n#else\n\t// Use explicit Common Name check if native validation not available.\n\t// Note: this will ignore Subject Alternative Name fields.\n\tif (subj\n\t    && X509_NAME_get_text_by_NID(subj, NID_commonName, common_name,\n\t                                 FIELD_SIZE) > 0\n\t    && strncasecmp(common_name, tunnel->config->gateway_host,\n\t                   FIELD_SIZE) == 0)\n\t\tcert_valid = 1;\n#endif\n\n\t// Try to validate certificate using local PKI\n\tif (cert_valid\n\t    && SSL_get_verify_result(tunnel->ssl_handle) == X509_V_OK) {\n\t\tlog_debug(\"Gateway certificate validation succeeded.\\n\");\n\t\tret = 0;\n\t\tgoto free_cert;\n\t}\n\tlog_debug(\"Gateway certificate validation failed.\\n\");\n\n\t// If validation failed, check if cert is in the white list\n\tif (X509_digest(cert, EVP_sha256(), digest, &len) <= 0\n\t    || len != SHA256LEN) {\n\t\tlog_error(\"Could not compute certificate sha256 digest.\\n\");\n\t\tgoto free_cert;\n\t}\n\t// Encode digest in base16\n\tfor (i = 0; i < SHA256LEN; i++)\n\t\tsprintf(&digest_str[2 * i], \"%02x\", digest[i]);\n\tdigest_str[SHA256STRLEN - 1] = '\\0';\n\t// Is it in whitelist?\n\tfor (elem = tunnel->config->cert_whitelist; elem != NULL;\n\t     elem = elem->next)\n\t\tif (memcmp(digest_str, elem->data, SHA256STRLEN - 1) == 0)\n\t\t\tbreak;\n\tif (elem != NULL) { // break before end of loop\n\t\tlog_debug(\"Gateway certificate digest found in white list.\\n\");\n\t\tret = 0;\n\t\tgoto free_cert;\n\t}\n\n\tsubject = X509_NAME_oneline(subj, NULL, 0);\n\tissuer = X509_NAME_oneline(X509_get_issuer_name(cert), NULL, 0);\n\n\tlog_error(\"Gateway certificate validation failed, and the certificate digest in not in the local whitelist. If you trust it, rerun with:\\n\");\n\tlog_error(\"    --trusted-cert %s\\n\", digest_str);\n\tlog_error(\"or add this line to your config file:\\n\");\n\tlog_error(\"    trusted-cert = %s\\n\", digest_str);\n\tlog_error(\"Gateway certificate:\\n\");\n\tlog_error(\"    subject:\\n\");\n\tfor (line = strtok(subject, \"/\"); line != NULL;\n\t     line = strtok(NULL, \"/\"))\n\t\tlog_error(\"        %s\\n\", line);\n\tlog_error(\"    issuer:\\n\");\n\tfor (line = strtok(issuer, \"/\"); line != NULL;\n\t     line = strtok(NULL, \"/\"))\n\t\tlog_error(\"        %s\\n\", line);\n\tlog_error(\"    sha256 digest:\\n\");\n\tlog_error(\"        %s\\n\", digest_str);\n\nfree_cert:\n\tX509_free(cert);\n\treturn ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -23,7 +23,8 @@\n \n #ifdef HAVE_X509_CHECK_HOST\n \t// Use OpenSSL native host validation if v >= 1.0.2.\n-\tif (X509_check_host(cert, common_name, FIELD_SIZE, 0, NULL))\n+\t// correctly check return value of X509_check_host\n+\tif (X509_check_host(cert, common_name, FIELD_SIZE, 0, NULL) == 1)\n \t\tcert_valid = 1;\n #else\n \t// Use explicit Common Name check if native validation not available.",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (X509_check_host(cert, common_name, FIELD_SIZE, 0, NULL))"
            ],
            "added_lines": [
                "\t// correctly check return value of X509_check_host",
                "\tif (X509_check_host(cert, common_name, FIELD_SIZE, 0, NULL) == 1)"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-7042",
        "func_name": "adrienverge/openfortivpn/ssl_verify_cert",
        "description": "An issue was discovered in openfortivpn 1.11.0 when used with OpenSSL 1.0.2 or later. tunnel.c mishandles certificate validation because the hostname check operates on uninitialized memory. The outcome is that a valid certificate is never accepted (only a malformed certificate may be accepted).",
        "git_url": "https://github.com/adrienverge/openfortivpn/commit/9eee997d599a89492281fc7ffdd79d88cd61afc3",
        "commit_title": "supply proper input buffer to X509_check_host",
        "commit_text": " CVE-2020-7042 use of uninitialized memory in X509_check_host is fixed with this commit  the uninitialized buffer common_name was passed as argument to X509_check_host which prevented proper host name validation when openssl >= 1.0.2 was in use. This came in with #282 which went into openfortivpn 1.7.1. Unfortunately, this problem has stayed unnoticed because the return value was not properly checked either (which is a separate issue, with CVE-2020-7041, and which has been fixed by the previous commit)",
        "func_before": "static int ssl_verify_cert(struct tunnel *tunnel)\n{\n\tint ret = -1;\n\tint cert_valid = 0;\n\tunsigned char digest[SHA256LEN];\n\tunsigned int len;\n\tstruct x509_digest *elem;\n\tchar digest_str[SHA256STRLEN], *subject, *issuer;\n\tchar *line;\n\tint i;\n\tX509_NAME *subj;\n\tchar common_name[FIELD_SIZE + 1];\n\n\tSSL_set_verify(tunnel->ssl_handle, SSL_VERIFY_PEER, NULL);\n\n\tX509 *cert = SSL_get_peer_certificate(tunnel->ssl_handle);\n\tif (cert == NULL) {\n\t\tlog_error(\"Unable to get gateway certificate.\\n\");\n\t\treturn 1;\n\t}\n\n\tsubj = X509_get_subject_name(cert);\n\n#ifdef HAVE_X509_CHECK_HOST\n\t// Use OpenSSL native host validation if v >= 1.0.2.\n\t// correctly check return value of X509_check_host\n\tif (X509_check_host(cert, common_name, FIELD_SIZE, 0, NULL) == 1)\n\t\tcert_valid = 1;\n#else\n\t// Use explicit Common Name check if native validation not available.\n\t// Note: this will ignore Subject Alternative Name fields.\n\tif (subj\n\t    && X509_NAME_get_text_by_NID(subj, NID_commonName, common_name,\n\t                                 FIELD_SIZE) > 0\n\t    && strncasecmp(common_name, tunnel->config->gateway_host,\n\t                   FIELD_SIZE) == 0)\n\t\tcert_valid = 1;\n#endif\n\n\t// Try to validate certificate using local PKI\n\tif (cert_valid\n\t    && SSL_get_verify_result(tunnel->ssl_handle) == X509_V_OK) {\n\t\tlog_debug(\"Gateway certificate validation succeeded.\\n\");\n\t\tret = 0;\n\t\tgoto free_cert;\n\t}\n\tlog_debug(\"Gateway certificate validation failed.\\n\");\n\n\t// If validation failed, check if cert is in the white list\n\tif (X509_digest(cert, EVP_sha256(), digest, &len) <= 0\n\t    || len != SHA256LEN) {\n\t\tlog_error(\"Could not compute certificate sha256 digest.\\n\");\n\t\tgoto free_cert;\n\t}\n\t// Encode digest in base16\n\tfor (i = 0; i < SHA256LEN; i++)\n\t\tsprintf(&digest_str[2 * i], \"%02x\", digest[i]);\n\tdigest_str[SHA256STRLEN - 1] = '\\0';\n\t// Is it in whitelist?\n\tfor (elem = tunnel->config->cert_whitelist; elem != NULL;\n\t     elem = elem->next)\n\t\tif (memcmp(digest_str, elem->data, SHA256STRLEN - 1) == 0)\n\t\t\tbreak;\n\tif (elem != NULL) { // break before end of loop\n\t\tlog_debug(\"Gateway certificate digest found in white list.\\n\");\n\t\tret = 0;\n\t\tgoto free_cert;\n\t}\n\n\tsubject = X509_NAME_oneline(subj, NULL, 0);\n\tissuer = X509_NAME_oneline(X509_get_issuer_name(cert), NULL, 0);\n\n\tlog_error(\"Gateway certificate validation failed, and the certificate digest in not in the local whitelist. If you trust it, rerun with:\\n\");\n\tlog_error(\"    --trusted-cert %s\\n\", digest_str);\n\tlog_error(\"or add this line to your config file:\\n\");\n\tlog_error(\"    trusted-cert = %s\\n\", digest_str);\n\tlog_error(\"Gateway certificate:\\n\");\n\tlog_error(\"    subject:\\n\");\n\tfor (line = strtok(subject, \"/\"); line != NULL;\n\t     line = strtok(NULL, \"/\"))\n\t\tlog_error(\"        %s\\n\", line);\n\tlog_error(\"    issuer:\\n\");\n\tfor (line = strtok(issuer, \"/\"); line != NULL;\n\t     line = strtok(NULL, \"/\"))\n\t\tlog_error(\"        %s\\n\", line);\n\tlog_error(\"    sha256 digest:\\n\");\n\tlog_error(\"        %s\\n\", digest_str);\n\nfree_cert:\n\tX509_free(cert);\n\treturn ret;\n}",
        "func": "static int ssl_verify_cert(struct tunnel *tunnel)\n{\n\tint ret = -1;\n\tint cert_valid = 0;\n\tunsigned char digest[SHA256LEN];\n\tunsigned int len;\n\tstruct x509_digest *elem;\n\tchar digest_str[SHA256STRLEN], *subject, *issuer;\n\tchar *line;\n\tint i;\n\tX509_NAME *subj;\n\n\tSSL_set_verify(tunnel->ssl_handle, SSL_VERIFY_PEER, NULL);\n\n\tX509 *cert = SSL_get_peer_certificate(tunnel->ssl_handle);\n\tif (cert == NULL) {\n\t\tlog_error(\"Unable to get gateway certificate.\\n\");\n\t\treturn 1;\n\t}\n\n\tsubj = X509_get_subject_name(cert);\n\n#ifdef HAVE_X509_CHECK_HOST\n\t// Use OpenSSL native host validation if v >= 1.0.2.\n\t// compare against gateway_host and correctly check return value\n\t// to fix piror Incorrect use of X509_check_host\n\tif (X509_check_host(cert, tunnel->config->gateway_host,\n\t                    0, 0, NULL) == 1)\n\t\tcert_valid = 1;\n#else\n\tchar common_name[FIELD_SIZE + 1];\n\t// Use explicit Common Name check if native validation not available.\n\t// Note: this will ignore Subject Alternative Name fields.\n\tif (subj\n\t    && X509_NAME_get_text_by_NID(subj, NID_commonName, common_name,\n\t                                 FIELD_SIZE) > 0\n\t    && strncasecmp(common_name, tunnel->config->gateway_host,\n\t                   FIELD_SIZE) == 0)\n\t\tcert_valid = 1;\n#endif\n\n\t// Try to validate certificate using local PKI\n\tif (cert_valid\n\t    && SSL_get_verify_result(tunnel->ssl_handle) == X509_V_OK) {\n\t\tlog_debug(\"Gateway certificate validation succeeded.\\n\");\n\t\tret = 0;\n\t\tgoto free_cert;\n\t}\n\tlog_debug(\"Gateway certificate validation failed.\\n\");\n\n\t// If validation failed, check if cert is in the white list\n\tif (X509_digest(cert, EVP_sha256(), digest, &len) <= 0\n\t    || len != SHA256LEN) {\n\t\tlog_error(\"Could not compute certificate sha256 digest.\\n\");\n\t\tgoto free_cert;\n\t}\n\t// Encode digest in base16\n\tfor (i = 0; i < SHA256LEN; i++)\n\t\tsprintf(&digest_str[2 * i], \"%02x\", digest[i]);\n\tdigest_str[SHA256STRLEN - 1] = '\\0';\n\t// Is it in whitelist?\n\tfor (elem = tunnel->config->cert_whitelist; elem != NULL;\n\t     elem = elem->next)\n\t\tif (memcmp(digest_str, elem->data, SHA256STRLEN - 1) == 0)\n\t\t\tbreak;\n\tif (elem != NULL) { // break before end of loop\n\t\tlog_debug(\"Gateway certificate digest found in white list.\\n\");\n\t\tret = 0;\n\t\tgoto free_cert;\n\t}\n\n\tsubject = X509_NAME_oneline(subj, NULL, 0);\n\tissuer = X509_NAME_oneline(X509_get_issuer_name(cert), NULL, 0);\n\n\tlog_error(\"Gateway certificate validation failed, and the certificate digest in not in the local whitelist. If you trust it, rerun with:\\n\");\n\tlog_error(\"    --trusted-cert %s\\n\", digest_str);\n\tlog_error(\"or add this line to your config file:\\n\");\n\tlog_error(\"    trusted-cert = %s\\n\", digest_str);\n\tlog_error(\"Gateway certificate:\\n\");\n\tlog_error(\"    subject:\\n\");\n\tfor (line = strtok(subject, \"/\"); line != NULL;\n\t     line = strtok(NULL, \"/\"))\n\t\tlog_error(\"        %s\\n\", line);\n\tlog_error(\"    issuer:\\n\");\n\tfor (line = strtok(issuer, \"/\"); line != NULL;\n\t     line = strtok(NULL, \"/\"))\n\t\tlog_error(\"        %s\\n\", line);\n\tlog_error(\"    sha256 digest:\\n\");\n\tlog_error(\"        %s\\n\", digest_str);\n\nfree_cert:\n\tX509_free(cert);\n\treturn ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -9,7 +9,6 @@\n \tchar *line;\n \tint i;\n \tX509_NAME *subj;\n-\tchar common_name[FIELD_SIZE + 1];\n \n \tSSL_set_verify(tunnel->ssl_handle, SSL_VERIFY_PEER, NULL);\n \n@@ -23,10 +22,13 @@\n \n #ifdef HAVE_X509_CHECK_HOST\n \t// Use OpenSSL native host validation if v >= 1.0.2.\n-\t// correctly check return value of X509_check_host\n-\tif (X509_check_host(cert, common_name, FIELD_SIZE, 0, NULL) == 1)\n+\t// compare against gateway_host and correctly check return value\n+\t// to fix piror Incorrect use of X509_check_host\n+\tif (X509_check_host(cert, tunnel->config->gateway_host,\n+\t                    0, 0, NULL) == 1)\n \t\tcert_valid = 1;\n #else\n+\tchar common_name[FIELD_SIZE + 1];\n \t// Use explicit Common Name check if native validation not available.\n \t// Note: this will ignore Subject Alternative Name fields.\n \tif (subj",
        "diff_line_info": {
            "deleted_lines": [
                "\tchar common_name[FIELD_SIZE + 1];",
                "\t// correctly check return value of X509_check_host",
                "\tif (X509_check_host(cert, common_name, FIELD_SIZE, 0, NULL) == 1)"
            ],
            "added_lines": [
                "\t// compare against gateway_host and correctly check return value",
                "\t// to fix piror Incorrect use of X509_check_host",
                "\tif (X509_check_host(cert, tunnel->config->gateway_host,",
                "\t                    0, 0, NULL) == 1)",
                "\tchar common_name[FIELD_SIZE + 1];"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-7043",
        "func_name": "adrienverge/openfortivpn/ssl_verify_cert",
        "description": "An issue was discovered in openfortivpn 1.11.0 when used with OpenSSL before 1.0.2. tunnel.c mishandles certificate validation because hostname comparisons do not consider '\\0' characters, as demonstrated by a good.example.com\\x00evil.example.com attack.",
        "git_url": "https://github.com/adrienverge/openfortivpn/commit/6328a070ddaab16faaf008cb9a8a62439c30f2a8",
        "commit_title": "fix TLS Certificate CommonName NULL Byte Vulnerability",
        "commit_text": " CVE-2020-7043 TLS Certificate CommonName NULL Byte Vulnerability is fixed with this commit  with #8 hostname validation for the certificate was introduced but unfortunately strncasecmp() was used to compare the byte array against the expected hostname. This does not correctly treat a CN which contains a NULL byte. In order to fix this vulnerability the reference implementation from iSECPartners has been included into the code.",
        "func_before": "static int ssl_verify_cert(struct tunnel *tunnel)\n{\n\tint ret = -1;\n\tint cert_valid = 0;\n\tunsigned char digest[SHA256LEN];\n\tunsigned int len;\n\tstruct x509_digest *elem;\n\tchar digest_str[SHA256STRLEN], *subject, *issuer;\n\tchar *line;\n\tint i;\n\tX509_NAME *subj;\n\n\tSSL_set_verify(tunnel->ssl_handle, SSL_VERIFY_PEER, NULL);\n\n\tX509 *cert = SSL_get_peer_certificate(tunnel->ssl_handle);\n\tif (cert == NULL) {\n\t\tlog_error(\"Unable to get gateway certificate.\\n\");\n\t\treturn 1;\n\t}\n\n\tsubj = X509_get_subject_name(cert);\n\n#ifdef HAVE_X509_CHECK_HOST\n\t// Use OpenSSL native host validation if v >= 1.0.2.\n\t// compare against gateway_host and correctly check return value\n\t// to fix piror Incorrect use of X509_check_host\n\tif (X509_check_host(cert, tunnel->config->gateway_host,\n\t                    0, 0, NULL) == 1)\n\t\tcert_valid = 1;\n#else\n\tchar common_name[FIELD_SIZE + 1];\n\t// Use explicit Common Name check if native validation not available.\n\t// Note: this will ignore Subject Alternative Name fields.\n\tif (subj\n\t    && X509_NAME_get_text_by_NID(subj, NID_commonName, common_name,\n\t                                 FIELD_SIZE) > 0\n\t    && strncasecmp(common_name, tunnel->config->gateway_host,\n\t                   FIELD_SIZE) == 0)\n\t\tcert_valid = 1;\n#endif\n\n\t// Try to validate certificate using local PKI\n\tif (cert_valid\n\t    && SSL_get_verify_result(tunnel->ssl_handle) == X509_V_OK) {\n\t\tlog_debug(\"Gateway certificate validation succeeded.\\n\");\n\t\tret = 0;\n\t\tgoto free_cert;\n\t}\n\tlog_debug(\"Gateway certificate validation failed.\\n\");\n\n\t// If validation failed, check if cert is in the white list\n\tif (X509_digest(cert, EVP_sha256(), digest, &len) <= 0\n\t    || len != SHA256LEN) {\n\t\tlog_error(\"Could not compute certificate sha256 digest.\\n\");\n\t\tgoto free_cert;\n\t}\n\t// Encode digest in base16\n\tfor (i = 0; i < SHA256LEN; i++)\n\t\tsprintf(&digest_str[2 * i], \"%02x\", digest[i]);\n\tdigest_str[SHA256STRLEN - 1] = '\\0';\n\t// Is it in whitelist?\n\tfor (elem = tunnel->config->cert_whitelist; elem != NULL;\n\t     elem = elem->next)\n\t\tif (memcmp(digest_str, elem->data, SHA256STRLEN - 1) == 0)\n\t\t\tbreak;\n\tif (elem != NULL) { // break before end of loop\n\t\tlog_debug(\"Gateway certificate digest found in white list.\\n\");\n\t\tret = 0;\n\t\tgoto free_cert;\n\t}\n\n\tsubject = X509_NAME_oneline(subj, NULL, 0);\n\tissuer = X509_NAME_oneline(X509_get_issuer_name(cert), NULL, 0);\n\n\tlog_error(\"Gateway certificate validation failed, and the certificate digest in not in the local whitelist. If you trust it, rerun with:\\n\");\n\tlog_error(\"    --trusted-cert %s\\n\", digest_str);\n\tlog_error(\"or add this line to your config file:\\n\");\n\tlog_error(\"    trusted-cert = %s\\n\", digest_str);\n\tlog_error(\"Gateway certificate:\\n\");\n\tlog_error(\"    subject:\\n\");\n\tfor (line = strtok(subject, \"/\"); line != NULL;\n\t     line = strtok(NULL, \"/\"))\n\t\tlog_error(\"        %s\\n\", line);\n\tlog_error(\"    issuer:\\n\");\n\tfor (line = strtok(issuer, \"/\"); line != NULL;\n\t     line = strtok(NULL, \"/\"))\n\t\tlog_error(\"        %s\\n\", line);\n\tlog_error(\"    sha256 digest:\\n\");\n\tlog_error(\"        %s\\n\", digest_str);\n\nfree_cert:\n\tX509_free(cert);\n\treturn ret;\n}",
        "func": "static int ssl_verify_cert(struct tunnel *tunnel)\n{\n\tint ret = -1;\n\tint cert_valid = 0;\n\tunsigned char digest[SHA256LEN];\n\tunsigned int len;\n\tstruct x509_digest *elem;\n\tchar digest_str[SHA256STRLEN], *subject, *issuer;\n\tchar *line;\n\tint i;\n\tX509_NAME *subj;\n\n\tSSL_set_verify(tunnel->ssl_handle, SSL_VERIFY_PEER, NULL);\n\n\tX509 *cert = SSL_get_peer_certificate(tunnel->ssl_handle);\n\tif (cert == NULL) {\n\t\tlog_error(\"Unable to get gateway certificate.\\n\");\n\t\treturn 1;\n\t}\n\n\tsubj = X509_get_subject_name(cert);\n\n#ifdef HAVE_X509_CHECK_HOST\n\t// Use OpenSSL native host validation if v >= 1.0.2.\n\t// compare against gateway_host and correctly check return value\n\t// to fix piror Incorrect use of X509_check_host\n\tif (X509_check_host(cert, tunnel->config->gateway_host,\n\t                    0, 0, NULL) == 1)\n\t\tcert_valid = 1;\n#else\n\t// Use validate_hostname form iSECPartners if native validation not available\n\t// in order to avoid TLS Certificate CommonName NULL Byte Vulnerability\n\tif (validate_hostname(tunnel->config->gateway_host, cert) == MatchFound)\n \t\tcert_valid = 1;\n#endif\n\n\t// Try to validate certificate using local PKI\n\tif (cert_valid\n\t    && SSL_get_verify_result(tunnel->ssl_handle) == X509_V_OK) {\n\t\tlog_debug(\"Gateway certificate validation succeeded.\\n\");\n\t\tret = 0;\n\t\tgoto free_cert;\n\t}\n\tlog_debug(\"Gateway certificate validation failed.\\n\");\n\n\t// If validation failed, check if cert is in the white list\n\tif (X509_digest(cert, EVP_sha256(), digest, &len) <= 0\n\t    || len != SHA256LEN) {\n\t\tlog_error(\"Could not compute certificate sha256 digest.\\n\");\n\t\tgoto free_cert;\n\t}\n\t// Encode digest in base16\n\tfor (i = 0; i < SHA256LEN; i++)\n\t\tsprintf(&digest_str[2 * i], \"%02x\", digest[i]);\n\tdigest_str[SHA256STRLEN - 1] = '\\0';\n\t// Is it in whitelist?\n\tfor (elem = tunnel->config->cert_whitelist; elem != NULL;\n\t     elem = elem->next)\n\t\tif (memcmp(digest_str, elem->data, SHA256STRLEN - 1) == 0)\n\t\t\tbreak;\n\tif (elem != NULL) { // break before end of loop\n\t\tlog_debug(\"Gateway certificate digest found in white list.\\n\");\n\t\tret = 0;\n\t\tgoto free_cert;\n\t}\n\n\tsubject = X509_NAME_oneline(subj, NULL, 0);\n\tissuer = X509_NAME_oneline(X509_get_issuer_name(cert), NULL, 0);\n\n\tlog_error(\"Gateway certificate validation failed, and the certificate digest in not in the local whitelist. If you trust it, rerun with:\\n\");\n\tlog_error(\"    --trusted-cert %s\\n\", digest_str);\n\tlog_error(\"or add this line to your config file:\\n\");\n\tlog_error(\"    trusted-cert = %s\\n\", digest_str);\n\tlog_error(\"Gateway certificate:\\n\");\n\tlog_error(\"    subject:\\n\");\n\tfor (line = strtok(subject, \"/\"); line != NULL;\n\t     line = strtok(NULL, \"/\"))\n\t\tlog_error(\"        %s\\n\", line);\n\tlog_error(\"    issuer:\\n\");\n\tfor (line = strtok(issuer, \"/\"); line != NULL;\n\t     line = strtok(NULL, \"/\"))\n\t\tlog_error(\"        %s\\n\", line);\n\tlog_error(\"    sha256 digest:\\n\");\n\tlog_error(\"        %s\\n\", digest_str);\n\nfree_cert:\n\tX509_free(cert);\n\treturn ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -28,15 +28,10 @@\n \t                    0, 0, NULL) == 1)\n \t\tcert_valid = 1;\n #else\n-\tchar common_name[FIELD_SIZE + 1];\n-\t// Use explicit Common Name check if native validation not available.\n-\t// Note: this will ignore Subject Alternative Name fields.\n-\tif (subj\n-\t    && X509_NAME_get_text_by_NID(subj, NID_commonName, common_name,\n-\t                                 FIELD_SIZE) > 0\n-\t    && strncasecmp(common_name, tunnel->config->gateway_host,\n-\t                   FIELD_SIZE) == 0)\n-\t\tcert_valid = 1;\n+\t// Use validate_hostname form iSECPartners if native validation not available\n+\t// in order to avoid TLS Certificate CommonName NULL Byte Vulnerability\n+\tif (validate_hostname(tunnel->config->gateway_host, cert) == MatchFound)\n+ \t\tcert_valid = 1;\n #endif\n \n \t// Try to validate certificate using local PKI",
        "diff_line_info": {
            "deleted_lines": [
                "\tchar common_name[FIELD_SIZE + 1];",
                "\t// Use explicit Common Name check if native validation not available.",
                "\t// Note: this will ignore Subject Alternative Name fields.",
                "\tif (subj",
                "\t    && X509_NAME_get_text_by_NID(subj, NID_commonName, common_name,",
                "\t                                 FIELD_SIZE) > 0",
                "\t    && strncasecmp(common_name, tunnel->config->gateway_host,",
                "\t                   FIELD_SIZE) == 0)",
                "\t\tcert_valid = 1;"
            ],
            "added_lines": [
                "\t// Use validate_hostname form iSECPartners if native validation not available",
                "\t// in order to avoid TLS Certificate CommonName NULL Byte Vulnerability",
                "\tif (validate_hostname(tunnel->config->gateway_host, cert) == MatchFound)",
                " \t\tcert_valid = 1;"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-9432",
        "func_name": "zhaozg/lua-openssl/luaopen_x509",
        "description": "openssl_x509_check_host in lua-openssl 0.7.7-1 mishandles X.509 certificate validation because it uses lua_pushboolean for certain non-boolean return values.",
        "git_url": "https://github.com/zhaozg/lua-openssl/commit/a6dc186dd4b6b9e329a93cca3e7e3cfccfdf3cca",
        "commit_title": "fix security: GSL-2020-026",
        "commit_text": "",
        "func_before": "int luaopen_x509(lua_State *L)\n{\n  auxiliar_newclass(L, \"openssl.x509\", x509_funcs);\n\n  lua_newtable(L);\n  luaL_setfuncs(L, R, 0);\n\n  openssl_register_xname(L);\n  lua_setfield(L, -2, \"name\");\n  openssl_register_xattribute(L);\n  lua_setfield(L, -2, \"attribute\");\n  openssl_register_xextension(L);\n  lua_setfield(L, -2, \"extension\");\n  openssl_register_xstore(L);\n  lua_setfield(L, -2, \"store\");\n  openssl_register_xalgor(L);\n  lua_setfield(L, -2, \"algor\");\n\n  luaopen_x509_req(L);\n  lua_setfield(L, -2, \"req\");\n  luaopen_x509_crl(L);\n  lua_setfield(L, -2, \"crl\");\n\n  lua_pushliteral(L, \"version\");    /** version */\n  lua_pushliteral(L, MYVERSION);\n  lua_settable(L, -3);\n\n  return 1;\n}",
        "func": "int luaopen_x509(lua_State *L)\n{\n  auxiliar_newclass(L, \"openssl.x509\", x509_funcs);\n\n  lua_newtable(L);\n  luaL_setfuncs(L, R, 0);\n\n  openssl_register_xname(L);\n  lua_setfield(L, -2, \"name\");\n  openssl_register_xattribute(L);\n  lua_setfield(L, -2, \"attribute\");\n  openssl_register_xextension(L);\n  lua_setfield(L, -2, \"extension\");\n  openssl_register_xstore(L);\n  lua_setfield(L, -2, \"store\");\n  openssl_register_xalgor(L);\n  lua_setfield(L, -2, \"algor\");\n\n  luaopen_x509_req(L);\n  lua_setfield(L, -2, \"req\");\n  luaopen_x509_crl(L);\n  lua_setfield(L, -2, \"crl\");\n\n  lua_pushliteral(L, \"version\");    /** version */\n  lua_pushliteral(L, MYVERSION);\n  lua_settable(L, -3);\n\n#if OPENSSL_VERSION_NUMBER > 0x10002000L\n  lua_pushliteral(L, \"check_flag\");\n  lua_newtable(L);\n  auxiliar_enumerate(L, -1, check_flags_const);\n  lua_settable(L, -3);\n#endif\n\n  return 1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -25,5 +25,12 @@\n   lua_pushliteral(L, MYVERSION);\n   lua_settable(L, -3);\n \n+#if OPENSSL_VERSION_NUMBER > 0x10002000L\n+  lua_pushliteral(L, \"check_flag\");\n+  lua_newtable(L);\n+  auxiliar_enumerate(L, -1, check_flags_const);\n+  lua_settable(L, -3);\n+#endif\n+\n   return 1;\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "#if OPENSSL_VERSION_NUMBER > 0x10002000L",
                "  lua_pushliteral(L, \"check_flag\");",
                "  lua_newtable(L);",
                "  auxiliar_enumerate(L, -1, check_flags_const);",
                "  lua_settable(L, -3);",
                "#endif",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2020-1887",
        "func_name": "osquery/Client::encryptConnection",
        "description": "Incorrect validation of the TLS SNI hostname in osquery versions after 2.9.0 and before 4.2.0 could allow an attacker to MITM osquery traffic in the absence of a configured root chain of trust.",
        "git_url": "https://github.com/osquery/osquery/commit/3ae9a09e14193a9c0a81c38dd3fef4c2fe38966e",
        "commit_title": "http_client: Add missing certificate hostname verification",
        "commit_text": " Before this commit it was possible to have osquery accept a valid certificate with a wrong hostname. The commit fixes this adding the hostname verification.  Moreover:  - Regenerate test CA, server certificates and keys, so that   the CA key is available, to be able to sign other test certs. - Add a regression test for the hostname verification bug.  Co-Authored-By: Alessandro Gario <alessandro.gario@gmail.com>",
        "func_before": "void Client::encryptConnection() {\n  boost::asio::ssl::context ctx{boost::asio::ssl::context::sslv23};\n\n  if (client_options_.always_verify_peer_) {\n    ctx.set_verify_mode(boost::asio::ssl::verify_peer);\n  } else {\n    ctx.set_verify_mode(boost::asio::ssl::verify_none);\n  }\n\n  if (client_options_.server_certificate_) {\n    ctx.set_verify_mode(boost::asio::ssl::verify_peer);\n    ctx.load_verify_file(*client_options_.server_certificate_);\n  }\n\n  if (client_options_.verify_path_) {\n    ctx.set_verify_mode(boost::asio::ssl::verify_peer);\n    ctx.add_verify_path(*client_options_.verify_path_);\n  }\n\n  if (client_options_.ciphers_) {\n    ::SSL_CTX_set_cipher_list(ctx.native_handle(),\n                              client_options_.ciphers_->c_str());\n  }\n\n  if (client_options_.ssl_options_) {\n    ctx.set_options(client_options_.ssl_options_);\n  }\n\n  if (client_options_.client_certificate_file_) {\n    ctx.use_certificate_file(*client_options_.client_certificate_file_,\n                             boost::asio::ssl::context::pem);\n  }\n\n  if (client_options_.client_private_key_file_) {\n    ctx.use_private_key_file(*client_options_.client_private_key_file_,\n                             boost::asio::ssl::context::pem);\n  }\n\n  ssl_sock_ = std::make_shared<ssl_stream>(sock_, ctx);\n  ::SSL_set_tlsext_host_name(ssl_sock_->native_handle(),\n                             client_options_.remote_hostname_->c_str());\n\n  callNetworkOperation([&]() {\n    ssl_sock_->async_handshake(\n        boost::asio::ssl::stream_base::client,\n        std::bind(&Client::handshakeHandler, this, std::placeholders::_1));\n  });\n\n  if (ec_) {\n    throw std::system_error(ec_);\n  }\n}",
        "func": "void Client::encryptConnection() {\n  boost::asio::ssl::context ctx{boost::asio::ssl::context::sslv23};\n  const auto remote_hostname = *client_options_.remote_hostname_;\n\n  bool verify_hostname = false;\n\n  if (client_options_.always_verify_peer_) {\n    ctx.set_verify_mode(boost::asio::ssl::verify_peer);\n    verify_hostname = true;\n  } else {\n    ctx.set_verify_mode(boost::asio::ssl::verify_none);\n  }\n\n  if (client_options_.server_certificate_) {\n    ctx.set_verify_mode(boost::asio::ssl::verify_peer);\n    ctx.load_verify_file(*client_options_.server_certificate_);\n    verify_hostname = true;\n  }\n\n  if (client_options_.verify_path_) {\n    ctx.set_verify_mode(boost::asio::ssl::verify_peer);\n    ctx.add_verify_path(*client_options_.verify_path_);\n    verify_hostname = true;\n  }\n\n  if (client_options_.ciphers_) {\n    ::SSL_CTX_set_cipher_list(ctx.native_handle(),\n                              client_options_.ciphers_->c_str());\n  }\n\n  if (client_options_.ssl_options_) {\n    ctx.set_options(client_options_.ssl_options_);\n  }\n\n  if (client_options_.client_certificate_file_) {\n    ctx.use_certificate_file(*client_options_.client_certificate_file_,\n                             boost::asio::ssl::context::pem);\n  }\n\n  if (client_options_.client_private_key_file_) {\n    ctx.use_private_key_file(*client_options_.client_private_key_file_,\n                             boost::asio::ssl::context::pem);\n  }\n\n  ssl_sock_ = std::make_shared<ssl_stream>(sock_, ctx);\n  ::SSL_set_tlsext_host_name(ssl_sock_->native_handle(),\n                             remote_hostname.c_str());\n\n  if (verify_hostname) {\n    ssl_sock_->set_verify_callback(\n        boost::asio::ssl::rfc2818_verification(remote_hostname));\n  }\n\n  callNetworkOperation([&]() {\n    ssl_sock_->async_handshake(\n        boost::asio::ssl::stream_base::client,\n        std::bind(&Client::handshakeHandler, this, std::placeholders::_1));\n  });\n\n  if (ec_) {\n    throw std::system_error(ec_);\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,8 +1,12 @@\n void Client::encryptConnection() {\n   boost::asio::ssl::context ctx{boost::asio::ssl::context::sslv23};\n+  const auto remote_hostname = *client_options_.remote_hostname_;\n+\n+  bool verify_hostname = false;\n \n   if (client_options_.always_verify_peer_) {\n     ctx.set_verify_mode(boost::asio::ssl::verify_peer);\n+    verify_hostname = true;\n   } else {\n     ctx.set_verify_mode(boost::asio::ssl::verify_none);\n   }\n@@ -10,11 +14,13 @@\n   if (client_options_.server_certificate_) {\n     ctx.set_verify_mode(boost::asio::ssl::verify_peer);\n     ctx.load_verify_file(*client_options_.server_certificate_);\n+    verify_hostname = true;\n   }\n \n   if (client_options_.verify_path_) {\n     ctx.set_verify_mode(boost::asio::ssl::verify_peer);\n     ctx.add_verify_path(*client_options_.verify_path_);\n+    verify_hostname = true;\n   }\n \n   if (client_options_.ciphers_) {\n@@ -38,7 +44,12 @@\n \n   ssl_sock_ = std::make_shared<ssl_stream>(sock_, ctx);\n   ::SSL_set_tlsext_host_name(ssl_sock_->native_handle(),\n-                             client_options_.remote_hostname_->c_str());\n+                             remote_hostname.c_str());\n+\n+  if (verify_hostname) {\n+    ssl_sock_->set_verify_callback(\n+        boost::asio::ssl::rfc2818_verification(remote_hostname));\n+  }\n \n   callNetworkOperation([&]() {\n     ssl_sock_->async_handshake(",
        "diff_line_info": {
            "deleted_lines": [
                "                             client_options_.remote_hostname_->c_str());"
            ],
            "added_lines": [
                "  const auto remote_hostname = *client_options_.remote_hostname_;",
                "",
                "  bool verify_hostname = false;",
                "    verify_hostname = true;",
                "    verify_hostname = true;",
                "    verify_hostname = true;",
                "                             remote_hostname.c_str());",
                "",
                "  if (verify_hostname) {",
                "    ssl_sock_->set_verify_callback(",
                "        boost::asio::ssl::rfc2818_verification(remote_hostname));",
                "  }"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-1887",
        "func_name": "osquery/Client::encryptConnection",
        "description": "Incorrect validation of the TLS SNI hostname in osquery versions after 2.9.0 and before 4.2.0 could allow an attacker to MITM osquery traffic in the absence of a configured root chain of trust.",
        "git_url": "https://github.com/osquery/osquery/commit/4b561c773922562edb79bb55bc47dcf6d6d746fa",
        "commit_title": "Always enable hostname verification",
        "commit_text": "",
        "func_before": "void Client::encryptConnection() {\n  boost::asio::ssl::context ctx{boost::asio::ssl::context::sslv23};\n  const auto remote_hostname = *client_options_.remote_hostname_;\n\n  bool verify_hostname = false;\n\n  if (client_options_.always_verify_peer_) {\n    ctx.set_verify_mode(boost::asio::ssl::verify_peer);\n    verify_hostname = true;\n  } else {\n    ctx.set_verify_mode(boost::asio::ssl::verify_none);\n  }\n\n  if (client_options_.server_certificate_) {\n    ctx.set_verify_mode(boost::asio::ssl::verify_peer);\n    ctx.load_verify_file(*client_options_.server_certificate_);\n    verify_hostname = true;\n  }\n\n  if (client_options_.verify_path_) {\n    ctx.set_verify_mode(boost::asio::ssl::verify_peer);\n    ctx.add_verify_path(*client_options_.verify_path_);\n    verify_hostname = true;\n  }\n\n  if (client_options_.ciphers_) {\n    ::SSL_CTX_set_cipher_list(ctx.native_handle(),\n                              client_options_.ciphers_->c_str());\n  }\n\n  if (client_options_.ssl_options_) {\n    ctx.set_options(client_options_.ssl_options_);\n  }\n\n  if (client_options_.client_certificate_file_) {\n    ctx.use_certificate_file(*client_options_.client_certificate_file_,\n                             boost::asio::ssl::context::pem);\n  }\n\n  if (client_options_.client_private_key_file_) {\n    ctx.use_private_key_file(*client_options_.client_private_key_file_,\n                             boost::asio::ssl::context::pem);\n  }\n\n  ssl_sock_ = std::make_shared<ssl_stream>(sock_, ctx);\n  ::SSL_set_tlsext_host_name(ssl_sock_->native_handle(),\n                             remote_hostname.c_str());\n\n  if (verify_hostname) {\n    ssl_sock_->set_verify_callback(\n        boost::asio::ssl::rfc2818_verification(remote_hostname));\n  }\n\n  callNetworkOperation([&]() {\n    ssl_sock_->async_handshake(\n        boost::asio::ssl::stream_base::client,\n        std::bind(&Client::handshakeHandler, this, std::placeholders::_1));\n  });\n\n  if (ec_) {\n    throw std::system_error(ec_);\n  }\n}",
        "func": "void Client::encryptConnection() {\n  boost::asio::ssl::context ctx{boost::asio::ssl::context::sslv23};\n\n  if (client_options_.always_verify_peer_) {\n    ctx.set_verify_mode(boost::asio::ssl::verify_peer);\n  } else {\n    ctx.set_verify_mode(boost::asio::ssl::verify_none);\n  }\n\n  if (client_options_.server_certificate_) {\n    ctx.set_verify_mode(boost::asio::ssl::verify_peer);\n    ctx.load_verify_file(*client_options_.server_certificate_);\n  }\n\n  if (client_options_.verify_path_) {\n    ctx.set_verify_mode(boost::asio::ssl::verify_peer);\n    ctx.add_verify_path(*client_options_.verify_path_);\n  }\n\n  if (client_options_.ciphers_) {\n    ::SSL_CTX_set_cipher_list(ctx.native_handle(),\n                              client_options_.ciphers_->c_str());\n  }\n\n  if (client_options_.ssl_options_) {\n    ctx.set_options(client_options_.ssl_options_);\n  }\n\n  if (client_options_.client_certificate_file_) {\n    ctx.use_certificate_file(*client_options_.client_certificate_file_,\n                             boost::asio::ssl::context::pem);\n  }\n\n  if (client_options_.client_private_key_file_) {\n    ctx.use_private_key_file(*client_options_.client_private_key_file_,\n                             boost::asio::ssl::context::pem);\n  }\n\n  ssl_sock_ = std::make_shared<ssl_stream>(sock_, ctx);\n  ::SSL_set_tlsext_host_name(ssl_sock_->native_handle(),\n                             client_options_.remote_hostname_->c_str());\n\n  ssl_sock_->set_verify_callback(boost::asio::ssl::rfc2818_verification(\n      *client_options_.remote_hostname_));\n\n  callNetworkOperation([&]() {\n    ssl_sock_->async_handshake(\n        boost::asio::ssl::stream_base::client,\n        std::bind(&Client::handshakeHandler, this, std::placeholders::_1));\n  });\n\n  if (ec_) {\n    throw std::system_error(ec_);\n  }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,12 +1,8 @@\n void Client::encryptConnection() {\n   boost::asio::ssl::context ctx{boost::asio::ssl::context::sslv23};\n-  const auto remote_hostname = *client_options_.remote_hostname_;\n-\n-  bool verify_hostname = false;\n \n   if (client_options_.always_verify_peer_) {\n     ctx.set_verify_mode(boost::asio::ssl::verify_peer);\n-    verify_hostname = true;\n   } else {\n     ctx.set_verify_mode(boost::asio::ssl::verify_none);\n   }\n@@ -14,13 +10,11 @@\n   if (client_options_.server_certificate_) {\n     ctx.set_verify_mode(boost::asio::ssl::verify_peer);\n     ctx.load_verify_file(*client_options_.server_certificate_);\n-    verify_hostname = true;\n   }\n \n   if (client_options_.verify_path_) {\n     ctx.set_verify_mode(boost::asio::ssl::verify_peer);\n     ctx.add_verify_path(*client_options_.verify_path_);\n-    verify_hostname = true;\n   }\n \n   if (client_options_.ciphers_) {\n@@ -44,12 +38,10 @@\n \n   ssl_sock_ = std::make_shared<ssl_stream>(sock_, ctx);\n   ::SSL_set_tlsext_host_name(ssl_sock_->native_handle(),\n-                             remote_hostname.c_str());\n+                             client_options_.remote_hostname_->c_str());\n \n-  if (verify_hostname) {\n-    ssl_sock_->set_verify_callback(\n-        boost::asio::ssl::rfc2818_verification(remote_hostname));\n-  }\n+  ssl_sock_->set_verify_callback(boost::asio::ssl::rfc2818_verification(\n+      *client_options_.remote_hostname_));\n \n   callNetworkOperation([&]() {\n     ssl_sock_->async_handshake(",
        "diff_line_info": {
            "deleted_lines": [
                "  const auto remote_hostname = *client_options_.remote_hostname_;",
                "",
                "  bool verify_hostname = false;",
                "    verify_hostname = true;",
                "    verify_hostname = true;",
                "    verify_hostname = true;",
                "                             remote_hostname.c_str());",
                "  if (verify_hostname) {",
                "    ssl_sock_->set_verify_callback(",
                "        boost::asio::ssl::rfc2818_verification(remote_hostname));",
                "  }"
            ],
            "added_lines": [
                "                             client_options_.remote_hostname_->c_str());",
                "  ssl_sock_->set_verify_callback(boost::asio::ssl::rfc2818_verification(",
                "      *client_options_.remote_hostname_));"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-7562",
        "func_name": "krb5/crypto_retrieve_X509_sans",
        "description": "An authentication bypass flaw was found in the way krb5's certauth interface before 1.16.1 handled the validation of client certificates. A remote attacker able to communicate with the KDC could potentially use this flaw to impersonate arbitrary principals under rare and erroneous circumstances.",
        "git_url": "https://github.com/krb5/krb5/commit/50fe4074f188c2d4da0c421e96553acea8378db2",
        "commit_title": "Fix certauth built-in module returns",
        "commit_text": " The PKINIT certauth eku module should never authoritatively authorize a certificate, because an extended key usage does not establish a relationship between the certificate and any specific user; it only establishes that the certificate was created for PKINIT client authentication.  Therefore, pkinit_eku_authorize() should return KRB5_PLUGIN_NO_HANDLE on success, not 0.  The certauth san module should pass if it does not find any SANs of the types it can match against; the presence of other types of SANs should not cause it to explicitly deny a certificate.  Check for an empty result from crypto_retrieve_cert_sans() in verify_client_san(), instead of returning ENOENT from crypto_retrieve_cert_sans() when there are no SANs at all.  ticket: 8561",
        "func_before": "static krb5_error_code\ncrypto_retrieve_X509_sans(krb5_context context,\n                          pkinit_plg_crypto_context plgctx,\n                          pkinit_req_crypto_context reqctx,\n                          X509 *cert,\n                          krb5_principal **princs_ret,\n                          krb5_principal **upn_ret,\n                          unsigned char ***dns_ret)\n{\n    krb5_error_code retval = EINVAL;\n    char buf[DN_BUF_LEN];\n    int p = 0, u = 0, d = 0, ret = 0, l;\n    krb5_principal *princs = NULL;\n    krb5_principal *upns = NULL;\n    unsigned char **dnss = NULL;\n    unsigned int i, num_found = 0, num_sans = 0;\n    X509_EXTENSION *ext = NULL;\n    GENERAL_NAMES *ialt = NULL;\n    GENERAL_NAME *gen = NULL;\n\n    if (princs_ret != NULL)\n        *princs_ret = NULL;\n    if (upn_ret != NULL)\n        *upn_ret = NULL;\n    if (dns_ret != NULL)\n        *dns_ret = NULL;\n\n    if (princs_ret == NULL && upn_ret == NULL && dns_ret == NULL) {\n        pkiDebug(\"%s: nowhere to return any values!\\n\", __FUNCTION__);\n        return retval;\n    }\n\n    if (cert == NULL) {\n        pkiDebug(\"%s: no certificate!\\n\", __FUNCTION__);\n        return retval;\n    }\n\n    X509_NAME_oneline(X509_get_subject_name(cert),\n                      buf, sizeof(buf));\n    pkiDebug(\"%s: looking for SANs in cert = %s\\n\", __FUNCTION__, buf);\n\n    l = X509_get_ext_by_NID(cert, NID_subject_alt_name, -1);\n    if (l < 0)\n        return 0;\n\n    if (!(ext = X509_get_ext(cert, l)) || !(ialt = X509V3_EXT_d2i(ext))) {\n        pkiDebug(\"%s: found no subject alt name extensions\\n\", __FUNCTION__);\n        retval = ENOENT;\n        goto cleanup;\n    }\n    num_sans = sk_GENERAL_NAME_num(ialt);\n\n    pkiDebug(\"%s: found %d subject alt name extension(s)\\n\", __FUNCTION__,\n             num_sans);\n\n    /* OK, we're likely returning something. Allocate return values */\n    if (princs_ret != NULL) {\n        princs = calloc(num_sans + 1, sizeof(krb5_principal));\n        if (princs == NULL) {\n            retval = ENOMEM;\n            goto cleanup;\n        }\n    }\n    if (upn_ret != NULL) {\n        upns = calloc(num_sans + 1, sizeof(krb5_principal));\n        if (upns == NULL) {\n            retval = ENOMEM;\n            goto cleanup;\n        }\n    }\n    if (dns_ret != NULL) {\n        dnss = calloc(num_sans + 1, sizeof(*dnss));\n        if (dnss == NULL) {\n            retval = ENOMEM;\n            goto cleanup;\n        }\n    }\n\n    for (i = 0; i < num_sans; i++) {\n        krb5_data name = { 0, 0, NULL };\n\n        gen = sk_GENERAL_NAME_value(ialt, i);\n        switch (gen->type) {\n        case GEN_OTHERNAME:\n            name.length = gen->d.otherName->value->value.sequence->length;\n            name.data = (char *)gen->d.otherName->value->value.sequence->data;\n            if (princs != NULL &&\n                OBJ_cmp(plgctx->id_pkinit_san,\n                        gen->d.otherName->type_id) == 0) {\n#ifdef DEBUG_ASN1\n                print_buffer_bin((unsigned char *)name.data, name.length,\n                                 \"/tmp/pkinit_san\");\n#endif\n                ret = k5int_decode_krb5_principal_name(&name, &princs[p]);\n                if (ret) {\n                    pkiDebug(\"%s: failed decoding pkinit san value\\n\",\n                             __FUNCTION__);\n                } else {\n                    p++;\n                    num_found++;\n                }\n            } else if (upns != NULL &&\n                       OBJ_cmp(plgctx->id_ms_san_upn,\n                               gen->d.otherName->type_id) == 0) {\n                /* Prevent abuse of embedded null characters. */\n                if (memchr(name.data, '\\0', name.length))\n                    break;\n                ret = krb5_parse_name_flags(context, name.data,\n                                            KRB5_PRINCIPAL_PARSE_ENTERPRISE,\n                                            &upns[u]);\n                if (ret) {\n                    pkiDebug(\"%s: failed parsing ms-upn san value\\n\",\n                             __FUNCTION__);\n                } else {\n                    u++;\n                    num_found++;\n                }\n            } else {\n                pkiDebug(\"%s: unrecognized othername oid in SAN\\n\",\n                         __FUNCTION__);\n                continue;\n            }\n\n            break;\n        case GEN_DNS:\n            if (dnss != NULL) {\n                /* Prevent abuse of embedded null characters. */\n                if (memchr(gen->d.dNSName->data, '\\0', gen->d.dNSName->length))\n                    break;\n                pkiDebug(\"%s: found dns name = %s\\n\", __FUNCTION__,\n                         gen->d.dNSName->data);\n                dnss[d] = (unsigned char *)\n                    strdup((char *)gen->d.dNSName->data);\n                if (dnss[d] == NULL) {\n                    pkiDebug(\"%s: failed to duplicate dns name\\n\",\n                             __FUNCTION__);\n                } else {\n                    d++;\n                    num_found++;\n                }\n            }\n            break;\n        default:\n            pkiDebug(\"%s: SAN type = %d expecting %d\\n\", __FUNCTION__,\n                     gen->type, GEN_OTHERNAME);\n        }\n    }\n    sk_GENERAL_NAME_pop_free(ialt, GENERAL_NAME_free);\n\n    retval = 0;\n    if (princs)\n        *princs_ret = princs;\n    if (upns)\n        *upn_ret = upns;\n    if (dnss)\n        *dns_ret = dnss;\n\ncleanup:\n    if (retval) {\n        if (princs != NULL) {\n            for (i = 0; princs[i] != NULL; i++)\n                krb5_free_principal(context, princs[i]);\n            free(princs);\n        }\n        if (upns != NULL) {\n            for (i = 0; upns[i] != NULL; i++)\n                krb5_free_principal(context, upns[i]);\n            free(upns);\n        }\n        if (dnss != NULL) {\n            for (i = 0; dnss[i] != NULL; i++)\n                free(dnss[i]);\n            free(dnss);\n        }\n    }\n    return retval;\n}",
        "func": "static krb5_error_code\ncrypto_retrieve_X509_sans(krb5_context context,\n                          pkinit_plg_crypto_context plgctx,\n                          pkinit_req_crypto_context reqctx,\n                          X509 *cert,\n                          krb5_principal **princs_ret,\n                          krb5_principal **upn_ret,\n                          unsigned char ***dns_ret)\n{\n    krb5_error_code retval = EINVAL;\n    char buf[DN_BUF_LEN];\n    int p = 0, u = 0, d = 0, ret = 0, l;\n    krb5_principal *princs = NULL;\n    krb5_principal *upns = NULL;\n    unsigned char **dnss = NULL;\n    unsigned int i, num_found = 0, num_sans = 0;\n    X509_EXTENSION *ext = NULL;\n    GENERAL_NAMES *ialt = NULL;\n    GENERAL_NAME *gen = NULL;\n\n    if (princs_ret != NULL)\n        *princs_ret = NULL;\n    if (upn_ret != NULL)\n        *upn_ret = NULL;\n    if (dns_ret != NULL)\n        *dns_ret = NULL;\n\n    if (princs_ret == NULL && upn_ret == NULL && dns_ret == NULL) {\n        pkiDebug(\"%s: nowhere to return any values!\\n\", __FUNCTION__);\n        return retval;\n    }\n\n    if (cert == NULL) {\n        pkiDebug(\"%s: no certificate!\\n\", __FUNCTION__);\n        return retval;\n    }\n\n    X509_NAME_oneline(X509_get_subject_name(cert),\n                      buf, sizeof(buf));\n    pkiDebug(\"%s: looking for SANs in cert = %s\\n\", __FUNCTION__, buf);\n\n    l = X509_get_ext_by_NID(cert, NID_subject_alt_name, -1);\n    if (l < 0)\n        return 0;\n\n    if (!(ext = X509_get_ext(cert, l)) || !(ialt = X509V3_EXT_d2i(ext))) {\n        pkiDebug(\"%s: found no subject alt name extensions\\n\", __FUNCTION__);\n        goto cleanup;\n    }\n    num_sans = sk_GENERAL_NAME_num(ialt);\n\n    pkiDebug(\"%s: found %d subject alt name extension(s)\\n\", __FUNCTION__,\n             num_sans);\n\n    /* OK, we're likely returning something. Allocate return values */\n    if (princs_ret != NULL) {\n        princs = calloc(num_sans + 1, sizeof(krb5_principal));\n        if (princs == NULL) {\n            retval = ENOMEM;\n            goto cleanup;\n        }\n    }\n    if (upn_ret != NULL) {\n        upns = calloc(num_sans + 1, sizeof(krb5_principal));\n        if (upns == NULL) {\n            retval = ENOMEM;\n            goto cleanup;\n        }\n    }\n    if (dns_ret != NULL) {\n        dnss = calloc(num_sans + 1, sizeof(*dnss));\n        if (dnss == NULL) {\n            retval = ENOMEM;\n            goto cleanup;\n        }\n    }\n\n    for (i = 0; i < num_sans; i++) {\n        krb5_data name = { 0, 0, NULL };\n\n        gen = sk_GENERAL_NAME_value(ialt, i);\n        switch (gen->type) {\n        case GEN_OTHERNAME:\n            name.length = gen->d.otherName->value->value.sequence->length;\n            name.data = (char *)gen->d.otherName->value->value.sequence->data;\n            if (princs != NULL &&\n                OBJ_cmp(plgctx->id_pkinit_san,\n                        gen->d.otherName->type_id) == 0) {\n#ifdef DEBUG_ASN1\n                print_buffer_bin((unsigned char *)name.data, name.length,\n                                 \"/tmp/pkinit_san\");\n#endif\n                ret = k5int_decode_krb5_principal_name(&name, &princs[p]);\n                if (ret) {\n                    pkiDebug(\"%s: failed decoding pkinit san value\\n\",\n                             __FUNCTION__);\n                } else {\n                    p++;\n                    num_found++;\n                }\n            } else if (upns != NULL &&\n                       OBJ_cmp(plgctx->id_ms_san_upn,\n                               gen->d.otherName->type_id) == 0) {\n                /* Prevent abuse of embedded null characters. */\n                if (memchr(name.data, '\\0', name.length))\n                    break;\n                ret = krb5_parse_name_flags(context, name.data,\n                                            KRB5_PRINCIPAL_PARSE_ENTERPRISE,\n                                            &upns[u]);\n                if (ret) {\n                    pkiDebug(\"%s: failed parsing ms-upn san value\\n\",\n                             __FUNCTION__);\n                } else {\n                    u++;\n                    num_found++;\n                }\n            } else {\n                pkiDebug(\"%s: unrecognized othername oid in SAN\\n\",\n                         __FUNCTION__);\n                continue;\n            }\n\n            break;\n        case GEN_DNS:\n            if (dnss != NULL) {\n                /* Prevent abuse of embedded null characters. */\n                if (memchr(gen->d.dNSName->data, '\\0', gen->d.dNSName->length))\n                    break;\n                pkiDebug(\"%s: found dns name = %s\\n\", __FUNCTION__,\n                         gen->d.dNSName->data);\n                dnss[d] = (unsigned char *)\n                    strdup((char *)gen->d.dNSName->data);\n                if (dnss[d] == NULL) {\n                    pkiDebug(\"%s: failed to duplicate dns name\\n\",\n                             __FUNCTION__);\n                } else {\n                    d++;\n                    num_found++;\n                }\n            }\n            break;\n        default:\n            pkiDebug(\"%s: SAN type = %d expecting %d\\n\", __FUNCTION__,\n                     gen->type, GEN_OTHERNAME);\n        }\n    }\n    sk_GENERAL_NAME_pop_free(ialt, GENERAL_NAME_free);\n\n    retval = 0;\n    if (princs != NULL && *princs != NULL) {\n        *princs_ret = princs;\n        princs = NULL;\n    }\n    if (upns != NULL && *upns != NULL) {\n        *upn_ret = upns;\n        upns = NULL;\n    }\n    if (dnss != NULL && *dnss != NULL) {\n        *dns_ret = dnss;\n        dnss = NULL;\n    }\n\ncleanup:\n    for (i = 0; princs != NULL && princs[i] != NULL; i++)\n        krb5_free_principal(context, princs[i]);\n    free(princs);\n    for (i = 0; upns != NULL && upns[i] != NULL; i++)\n        krb5_free_principal(context, upns[i]);\n    free(upns);\n    for (i = 0; dnss != NULL && dnss[i] != NULL; i++)\n        free(dnss[i]);\n    free(dnss);\n    return retval;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -45,7 +45,6 @@\n \n     if (!(ext = X509_get_ext(cert, l)) || !(ialt = X509V3_EXT_d2i(ext))) {\n         pkiDebug(\"%s: found no subject alt name extensions\\n\", __FUNCTION__);\n-        retval = ENOENT;\n         goto cleanup;\n     }\n     num_sans = sk_GENERAL_NAME_num(ialt);\n@@ -148,30 +147,28 @@\n     sk_GENERAL_NAME_pop_free(ialt, GENERAL_NAME_free);\n \n     retval = 0;\n-    if (princs)\n+    if (princs != NULL && *princs != NULL) {\n         *princs_ret = princs;\n-    if (upns)\n+        princs = NULL;\n+    }\n+    if (upns != NULL && *upns != NULL) {\n         *upn_ret = upns;\n-    if (dnss)\n+        upns = NULL;\n+    }\n+    if (dnss != NULL && *dnss != NULL) {\n         *dns_ret = dnss;\n+        dnss = NULL;\n+    }\n \n cleanup:\n-    if (retval) {\n-        if (princs != NULL) {\n-            for (i = 0; princs[i] != NULL; i++)\n-                krb5_free_principal(context, princs[i]);\n-            free(princs);\n-        }\n-        if (upns != NULL) {\n-            for (i = 0; upns[i] != NULL; i++)\n-                krb5_free_principal(context, upns[i]);\n-            free(upns);\n-        }\n-        if (dnss != NULL) {\n-            for (i = 0; dnss[i] != NULL; i++)\n-                free(dnss[i]);\n-            free(dnss);\n-        }\n-    }\n+    for (i = 0; princs != NULL && princs[i] != NULL; i++)\n+        krb5_free_principal(context, princs[i]);\n+    free(princs);\n+    for (i = 0; upns != NULL && upns[i] != NULL; i++)\n+        krb5_free_principal(context, upns[i]);\n+    free(upns);\n+    for (i = 0; dnss != NULL && dnss[i] != NULL; i++)\n+        free(dnss[i]);\n+    free(dnss);\n     return retval;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "        retval = ENOENT;",
                "    if (princs)",
                "    if (upns)",
                "    if (dnss)",
                "    if (retval) {",
                "        if (princs != NULL) {",
                "            for (i = 0; princs[i] != NULL; i++)",
                "                krb5_free_principal(context, princs[i]);",
                "            free(princs);",
                "        }",
                "        if (upns != NULL) {",
                "            for (i = 0; upns[i] != NULL; i++)",
                "                krb5_free_principal(context, upns[i]);",
                "            free(upns);",
                "        }",
                "        if (dnss != NULL) {",
                "            for (i = 0; dnss[i] != NULL; i++)",
                "                free(dnss[i]);",
                "            free(dnss);",
                "        }",
                "    }"
            ],
            "added_lines": [
                "    if (princs != NULL && *princs != NULL) {",
                "        princs = NULL;",
                "    }",
                "    if (upns != NULL && *upns != NULL) {",
                "        upns = NULL;",
                "    }",
                "    if (dnss != NULL && *dnss != NULL) {",
                "        dnss = NULL;",
                "    }",
                "    for (i = 0; princs != NULL && princs[i] != NULL; i++)",
                "        krb5_free_principal(context, princs[i]);",
                "    free(princs);",
                "    for (i = 0; upns != NULL && upns[i] != NULL; i++)",
                "        krb5_free_principal(context, upns[i]);",
                "    free(upns);",
                "    for (i = 0; dnss != NULL && dnss[i] != NULL; i++)",
                "        free(dnss[i]);",
                "    free(dnss);"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-7562",
        "func_name": "krb5/verify_client_san",
        "description": "An authentication bypass flaw was found in the way krb5's certauth interface before 1.16.1 handled the validation of client certificates. A remote attacker able to communicate with the KDC could potentially use this flaw to impersonate arbitrary principals under rare and erroneous circumstances.",
        "git_url": "https://github.com/krb5/krb5/commit/50fe4074f188c2d4da0c421e96553acea8378db2",
        "commit_title": "Fix certauth built-in module returns",
        "commit_text": " The PKINIT certauth eku module should never authoritatively authorize a certificate, because an extended key usage does not establish a relationship between the certificate and any specific user; it only establishes that the certificate was created for PKINIT client authentication.  Therefore, pkinit_eku_authorize() should return KRB5_PLUGIN_NO_HANDLE on success, not 0.  The certauth san module should pass if it does not find any SANs of the types it can match against; the presence of other types of SANs should not cause it to explicitly deny a certificate.  Check for an empty result from crypto_retrieve_cert_sans() in verify_client_san(), instead of returning ENOENT from crypto_retrieve_cert_sans() when there are no SANs at all.  ticket: 8561",
        "func_before": "static krb5_error_code\nverify_client_san(krb5_context context,\n                  pkinit_kdc_context plgctx,\n                  pkinit_kdc_req_context reqctx,\n                  krb5_kdcpreauth_callbacks cb,\n                  krb5_kdcpreauth_rock rock,\n                  krb5_const_principal client,\n                  int *valid_san)\n{\n    krb5_error_code retval;\n    krb5_principal *princs = NULL;\n    krb5_principal *upns = NULL;\n    int i;\n#ifdef DEBUG_SAN_INFO\n    char *client_string = NULL, *san_string;\n#endif\n\n    *valid_san = 0;\n    retval = crypto_retrieve_cert_sans(context, plgctx->cryptoctx,\n                                       reqctx->cryptoctx, plgctx->idctx,\n                                       &princs,\n                                       plgctx->opts->allow_upn ? &upns : NULL,\n                                       NULL);\n    if (retval == ENOENT) {\n        TRACE_PKINIT_SERVER_NO_SAN(context);\n        goto out;\n    } else if (retval) {\n        pkiDebug(\"%s: error from retrieve_certificate_sans()\\n\", __FUNCTION__);\n        retval = KRB5KDC_ERR_CLIENT_NAME_MISMATCH;\n        goto out;\n    }\n    /* XXX Verify this is consistent with client side XXX */\n#if 0\n    retval = call_san_checking_plugins(context, plgctx, reqctx, princs,\n                                       upns, NULL, &plugin_decision, &ignore);\n    pkiDebug(\"%s: call_san_checking_plugins() returned retval %d\\n\",\n             __FUNCTION__);\n    if (retval) {\n        retval = KRB5KDC_ERR_CLIENT_NAME_MISMATCH;\n        goto cleanup;\n    }\n    pkiDebug(\"%s: call_san_checking_plugins() returned decision %d\\n\",\n             __FUNCTION__, plugin_decision);\n    if (plugin_decision != NO_DECISION) {\n        retval = plugin_decision;\n        goto out;\n    }\n#endif\n\n#ifdef DEBUG_SAN_INFO\n    krb5_unparse_name(context, client, &client_string);\n#endif\n    pkiDebug(\"%s: Checking pkinit sans\\n\", __FUNCTION__);\n    for (i = 0; princs != NULL && princs[i] != NULL; i++) {\n#ifdef DEBUG_SAN_INFO\n        krb5_unparse_name(context, princs[i], &san_string);\n        pkiDebug(\"%s: Comparing client '%s' to pkinit san value '%s'\\n\",\n                 __FUNCTION__, client_string, san_string);\n        krb5_free_unparsed_name(context, san_string);\n#endif\n        if (cb->match_client(context, rock, princs[i])) {\n            TRACE_PKINIT_SERVER_MATCHING_SAN_FOUND(context);\n            *valid_san = 1;\n            retval = 0;\n            goto out;\n        }\n    }\n    pkiDebug(\"%s: no pkinit san match found\\n\", __FUNCTION__);\n    /*\n     * XXX if cert has names but none match, should we\n     * be returning KRB5KDC_ERR_CLIENT_NAME_MISMATCH here?\n     */\n\n    if (upns == NULL) {\n        pkiDebug(\"%s: no upn sans (or we wouldn't accept them anyway)\\n\",\n                 __FUNCTION__);\n        retval = KRB5KDC_ERR_CLIENT_NAME_MISMATCH;\n        goto out;\n    }\n\n    pkiDebug(\"%s: Checking upn sans\\n\", __FUNCTION__);\n    for (i = 0; upns[i] != NULL; i++) {\n#ifdef DEBUG_SAN_INFO\n        krb5_unparse_name(context, upns[i], &san_string);\n        pkiDebug(\"%s: Comparing client '%s' to upn san value '%s'\\n\",\n                 __FUNCTION__, client_string, san_string);\n        krb5_free_unparsed_name(context, san_string);\n#endif\n        if (cb->match_client(context, rock, upns[i])) {\n            TRACE_PKINIT_SERVER_MATCHING_UPN_FOUND(context);\n            *valid_san = 1;\n            retval = 0;\n            goto out;\n        }\n    }\n    pkiDebug(\"%s: no upn san match found\\n\", __FUNCTION__);\n\n    /* We found no match */\n    if (princs != NULL || upns != NULL) {\n        *valid_san = 0;\n        /* XXX ??? If there was one or more name in the cert, but\n         * none matched the client name, then return mismatch? */\n        retval = KRB5KDC_ERR_CLIENT_NAME_MISMATCH;\n    }\n    retval = 0;\n\nout:\n    if (princs != NULL) {\n        for (i = 0; princs[i] != NULL; i++)\n            krb5_free_principal(context, princs[i]);\n        free(princs);\n    }\n    if (upns != NULL) {\n        for (i = 0; upns[i] != NULL; i++)\n            krb5_free_principal(context, upns[i]);\n        free(upns);\n    }\n#ifdef DEBUG_SAN_INFO\n    if (client_string != NULL)\n        krb5_free_unparsed_name(context, client_string);\n#endif\n    pkiDebug(\"%s: returning retval %d, valid_san %d\\n\",\n             __FUNCTION__, retval, *valid_san);\n    return retval;\n}",
        "func": "static krb5_error_code\nverify_client_san(krb5_context context,\n                  pkinit_kdc_context plgctx,\n                  pkinit_kdc_req_context reqctx,\n                  krb5_kdcpreauth_callbacks cb,\n                  krb5_kdcpreauth_rock rock,\n                  krb5_const_principal client,\n                  int *valid_san)\n{\n    krb5_error_code retval;\n    krb5_principal *princs = NULL;\n    krb5_principal *upns = NULL;\n    int i;\n#ifdef DEBUG_SAN_INFO\n    char *client_string = NULL, *san_string;\n#endif\n\n    *valid_san = 0;\n    retval = crypto_retrieve_cert_sans(context, plgctx->cryptoctx,\n                                       reqctx->cryptoctx, plgctx->idctx,\n                                       &princs,\n                                       plgctx->opts->allow_upn ? &upns : NULL,\n                                       NULL);\n    if (retval) {\n        pkiDebug(\"%s: error from retrieve_certificate_sans()\\n\", __FUNCTION__);\n        retval = KRB5KDC_ERR_CLIENT_NAME_MISMATCH;\n        goto out;\n    }\n\n    if (princs == NULL && upns == NULL) {\n        TRACE_PKINIT_SERVER_NO_SAN(context);\n        retval = ENOENT;\n        goto out;\n    }\n\n    /* XXX Verify this is consistent with client side XXX */\n#if 0\n    retval = call_san_checking_plugins(context, plgctx, reqctx, princs,\n                                       upns, NULL, &plugin_decision, &ignore);\n    pkiDebug(\"%s: call_san_checking_plugins() returned retval %d\\n\",\n             __FUNCTION__);\n    if (retval) {\n        retval = KRB5KDC_ERR_CLIENT_NAME_MISMATCH;\n        goto cleanup;\n    }\n    pkiDebug(\"%s: call_san_checking_plugins() returned decision %d\\n\",\n             __FUNCTION__, plugin_decision);\n    if (plugin_decision != NO_DECISION) {\n        retval = plugin_decision;\n        goto out;\n    }\n#endif\n\n#ifdef DEBUG_SAN_INFO\n    krb5_unparse_name(context, client, &client_string);\n#endif\n    pkiDebug(\"%s: Checking pkinit sans\\n\", __FUNCTION__);\n    for (i = 0; princs != NULL && princs[i] != NULL; i++) {\n#ifdef DEBUG_SAN_INFO\n        krb5_unparse_name(context, princs[i], &san_string);\n        pkiDebug(\"%s: Comparing client '%s' to pkinit san value '%s'\\n\",\n                 __FUNCTION__, client_string, san_string);\n        krb5_free_unparsed_name(context, san_string);\n#endif\n        if (cb->match_client(context, rock, princs[i])) {\n            TRACE_PKINIT_SERVER_MATCHING_SAN_FOUND(context);\n            *valid_san = 1;\n            retval = 0;\n            goto out;\n        }\n    }\n    pkiDebug(\"%s: no pkinit san match found\\n\", __FUNCTION__);\n    /*\n     * XXX if cert has names but none match, should we\n     * be returning KRB5KDC_ERR_CLIENT_NAME_MISMATCH here?\n     */\n\n    if (upns == NULL) {\n        pkiDebug(\"%s: no upn sans (or we wouldn't accept them anyway)\\n\",\n                 __FUNCTION__);\n        retval = KRB5KDC_ERR_CLIENT_NAME_MISMATCH;\n        goto out;\n    }\n\n    pkiDebug(\"%s: Checking upn sans\\n\", __FUNCTION__);\n    for (i = 0; upns[i] != NULL; i++) {\n#ifdef DEBUG_SAN_INFO\n        krb5_unparse_name(context, upns[i], &san_string);\n        pkiDebug(\"%s: Comparing client '%s' to upn san value '%s'\\n\",\n                 __FUNCTION__, client_string, san_string);\n        krb5_free_unparsed_name(context, san_string);\n#endif\n        if (cb->match_client(context, rock, upns[i])) {\n            TRACE_PKINIT_SERVER_MATCHING_UPN_FOUND(context);\n            *valid_san = 1;\n            retval = 0;\n            goto out;\n        }\n    }\n    pkiDebug(\"%s: no upn san match found\\n\", __FUNCTION__);\n\n    /* We found no match */\n    if (princs != NULL || upns != NULL) {\n        *valid_san = 0;\n        /* XXX ??? If there was one or more name in the cert, but\n         * none matched the client name, then return mismatch? */\n        retval = KRB5KDC_ERR_CLIENT_NAME_MISMATCH;\n    }\n    retval = 0;\n\nout:\n    if (princs != NULL) {\n        for (i = 0; princs[i] != NULL; i++)\n            krb5_free_principal(context, princs[i]);\n        free(princs);\n    }\n    if (upns != NULL) {\n        for (i = 0; upns[i] != NULL; i++)\n            krb5_free_principal(context, upns[i]);\n        free(upns);\n    }\n#ifdef DEBUG_SAN_INFO\n    if (client_string != NULL)\n        krb5_free_unparsed_name(context, client_string);\n#endif\n    pkiDebug(\"%s: returning retval %d, valid_san %d\\n\",\n             __FUNCTION__, retval, *valid_san);\n    return retval;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -21,14 +21,18 @@\n                                        &princs,\n                                        plgctx->opts->allow_upn ? &upns : NULL,\n                                        NULL);\n-    if (retval == ENOENT) {\n-        TRACE_PKINIT_SERVER_NO_SAN(context);\n-        goto out;\n-    } else if (retval) {\n+    if (retval) {\n         pkiDebug(\"%s: error from retrieve_certificate_sans()\\n\", __FUNCTION__);\n         retval = KRB5KDC_ERR_CLIENT_NAME_MISMATCH;\n         goto out;\n     }\n+\n+    if (princs == NULL && upns == NULL) {\n+        TRACE_PKINIT_SERVER_NO_SAN(context);\n+        retval = ENOENT;\n+        goto out;\n+    }\n+\n     /* XXX Verify this is consistent with client side XXX */\n #if 0\n     retval = call_san_checking_plugins(context, plgctx, reqctx, princs,",
        "diff_line_info": {
            "deleted_lines": [
                "    if (retval == ENOENT) {",
                "        TRACE_PKINIT_SERVER_NO_SAN(context);",
                "        goto out;",
                "    } else if (retval) {"
            ],
            "added_lines": [
                "    if (retval) {",
                "",
                "    if (princs == NULL && upns == NULL) {",
                "        TRACE_PKINIT_SERVER_NO_SAN(context);",
                "        retval = ENOENT;",
                "        goto out;",
                "    }",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2017-7562",
        "func_name": "krb5/pkinit_eku_authorize",
        "description": "An authentication bypass flaw was found in the way krb5's certauth interface before 1.16.1 handled the validation of client certificates. A remote attacker able to communicate with the KDC could potentially use this flaw to impersonate arbitrary principals under rare and erroneous circumstances.",
        "git_url": "https://github.com/krb5/krb5/commit/50fe4074f188c2d4da0c421e96553acea8378db2",
        "commit_title": "Fix certauth built-in module returns",
        "commit_text": " The PKINIT certauth eku module should never authoritatively authorize a certificate, because an extended key usage does not establish a relationship between the certificate and any specific user; it only establishes that the certificate was created for PKINIT client authentication.  Therefore, pkinit_eku_authorize() should return KRB5_PLUGIN_NO_HANDLE on success, not 0.  The certauth san module should pass if it does not find any SANs of the types it can match against; the presence of other types of SANs should not cause it to explicitly deny a certificate.  Check for an empty result from crypto_retrieve_cert_sans() in verify_client_san(), instead of returning ENOENT from crypto_retrieve_cert_sans() when there are no SANs at all.  ticket: 8561",
        "func_before": "static krb5_error_code\npkinit_eku_authorize(krb5_context context, krb5_certauth_moddata moddata,\n                     const uint8_t *cert, size_t cert_len,\n                     krb5_const_principal princ, const void *opts,\n                     const struct _krb5_db_entry_new *db_entry,\n                     char ***authinds_out)\n{\n    krb5_error_code ret;\n    int valid_eku;\n    const struct certauth_req_opts *req_opts = opts;\n\n    *authinds_out = NULL;\n\n    /* Verify the client EKU. */\n    ret = verify_client_eku(context, req_opts->plgctx, req_opts->reqctx,\n                            &valid_eku);\n    if (ret)\n        return ret;\n\n    if (!valid_eku) {\n        TRACE_PKINIT_SERVER_EKU_REJECT(context);\n        return KRB5KDC_ERR_INCONSISTENT_KEY_PURPOSE;\n    }\n\n    return 0;\n}",
        "func": "static krb5_error_code\npkinit_eku_authorize(krb5_context context, krb5_certauth_moddata moddata,\n                     const uint8_t *cert, size_t cert_len,\n                     krb5_const_principal princ, const void *opts,\n                     const struct _krb5_db_entry_new *db_entry,\n                     char ***authinds_out)\n{\n    krb5_error_code ret;\n    int valid_eku;\n    const struct certauth_req_opts *req_opts = opts;\n\n    *authinds_out = NULL;\n\n    /* Verify the client EKU. */\n    ret = verify_client_eku(context, req_opts->plgctx, req_opts->reqctx,\n                            &valid_eku);\n    if (ret)\n        return ret;\n\n    if (!valid_eku) {\n        TRACE_PKINIT_SERVER_EKU_REJECT(context);\n        return KRB5KDC_ERR_INCONSISTENT_KEY_PURPOSE;\n    }\n\n    return KRB5_PLUGIN_NO_HANDLE;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -22,5 +22,5 @@\n         return KRB5KDC_ERR_INCONSISTENT_KEY_PURPOSE;\n     }\n \n-    return 0;\n+    return KRB5_PLUGIN_NO_HANDLE;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    return 0;"
            ],
            "added_lines": [
                "    return KRB5_PLUGIN_NO_HANDLE;"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-46724",
        "func_name": "squid-cache/squid/matchDomainName",
        "description": " Squid is a caching proxy for the Web. Due to an Improper Validation of Specified Index bug, Squid versions 3.3.0.1 through 5.9 and 6.0 prior to 6.4 compiled using `--with-openssl` are vulnerable to a Denial of Service attack against SSL Certificate validation. This problem allows a remote server to perform Denial of Service against Squid Proxy by initiating a TLS Handshake with a specially crafted SSL Certificate in a server certificate chain. This attack is limited to HTTPS and SSL-Bump. This bug is fixed in Squid version 6.4. In addition, patches addressing this problem for the stable releases can be found in Squid's patch archives. Those who you use a prepackaged version of Squid should refer to the package vendor for availability information on updated packages.",
        "git_url": "https://github.com/squid-cache/squid/commit/b70f864940225dfe69f9f653f948e787f99c3810",
        "commit_title": "Fix validation of certificates with CN=* (#1523)",
        "commit_text": " The bug was discovered and detailed by Joshua Rogers at https://megamansec.github.io/Squid-Security-Audit/ where it was filed as \"Buffer UnderRead in SSL CN Parsing\".",
        "func_before": "int\nmatchDomainName(const char *h, const char *d, MatchDomainNameFlags flags)\n{\n    int dl;\n    int hl;\n\n    const bool hostIncludesSubdomains = (*h == '.');\n    while ('.' == *h)\n        ++h;\n\n    hl = strlen(h);\n\n    if (hl == 0)\n        return -1;\n\n    dl = strlen(d);\n\n    /*\n     * Start at the ends of the two strings and work towards the\n     * beginning.\n     */\n    while (xtolower(h[--hl]) == xtolower(d[--dl])) {\n        if (hl == 0 && dl == 0) {\n            /*\n             * We made it all the way to the beginning of both\n             * strings without finding any difference.\n             */\n            return 0;\n        }\n\n        if (0 == hl) {\n            /*\n             * The host string is shorter than the domain string.\n             * There is only one case when this can be a match.\n             * If the domain is just one character longer, and if\n             * that character is a leading '.' then we call it a\n             * match.\n             */\n\n            if (1 == dl && '.' == d[0])\n                return 0;\n            else\n                return -1;\n        }\n\n        if (0 == dl) {\n            /*\n             * The domain string is shorter than the host string.\n             * This is a match only if the first domain character\n             * is a leading '.'.\n             */\n\n            if ('.' == d[0]) {\n                if (flags & mdnRejectSubsubDomains) {\n                    // Check for sub-sub domain and reject\n                    while(--hl >= 0 && h[hl] != '.');\n                    if (hl < 0) {\n                        // No sub-sub domain found, but reject if there is a\n                        // leading dot in given host string (which is removed\n                        // before the check is started).\n                        return hostIncludesSubdomains ? 1 : 0;\n                    } else\n                        return 1; // sub-sub domain, reject\n                } else\n                    return 0;\n            } else\n                return 1;\n        }\n    }\n\n    /*\n     * We found different characters in the same position (from the end).\n     */\n\n    // If the h has a form of \"*.foo.com\" and d has a form of \"x.foo.com\"\n    // then the h[hl] points to '*', h[hl+1] to '.' and d[dl] to 'x'\n    // The following checks are safe, the \"h[hl + 1]\" in the worst case is '\\0'.\n    if ((flags & mdnHonorWildcards) && h[hl] == '*' && h[hl + 1] == '.')\n        return 0;\n\n    /*\n     * If one of those character is '.' then its special.  In order\n     * for splay tree sorting to work properly, \"x-foo.com\" must\n     * be greater than \".foo.com\" even though '-' is less than '.'.\n     */\n    if ('.' == d[dl])\n        return 1;\n\n    if ('.' == h[hl])\n        return -1;\n\n    return (xtolower(h[hl]) - xtolower(d[dl]));\n}",
        "func": "int\nmatchDomainName(const char *h, const char *d, MatchDomainNameFlags flags)\n{\n    int dl;\n    int hl;\n\n    const bool hostIncludesSubdomains = (*h == '.');\n    while ('.' == *h)\n        ++h;\n\n    hl = strlen(h);\n\n    if (hl == 0)\n        return -1;\n\n    dl = strlen(d);\n    if (dl == 0)\n        return 1;\n\n    /*\n     * Start at the ends of the two strings and work towards the\n     * beginning.\n     */\n    while (xtolower(h[--hl]) == xtolower(d[--dl])) {\n        if (hl == 0 && dl == 0) {\n            /*\n             * We made it all the way to the beginning of both\n             * strings without finding any difference.\n             */\n            return 0;\n        }\n\n        if (0 == hl) {\n            /*\n             * The host string is shorter than the domain string.\n             * There is only one case when this can be a match.\n             * If the domain is just one character longer, and if\n             * that character is a leading '.' then we call it a\n             * match.\n             */\n\n            if (1 == dl && '.' == d[0])\n                return 0;\n            else\n                return -1;\n        }\n\n        if (0 == dl) {\n            /*\n             * The domain string is shorter than the host string.\n             * This is a match only if the first domain character\n             * is a leading '.'.\n             */\n\n            if ('.' == d[0]) {\n                if (flags & mdnRejectSubsubDomains) {\n                    // Check for sub-sub domain and reject\n                    while(--hl >= 0 && h[hl] != '.');\n                    if (hl < 0) {\n                        // No sub-sub domain found, but reject if there is a\n                        // leading dot in given host string (which is removed\n                        // before the check is started).\n                        return hostIncludesSubdomains ? 1 : 0;\n                    } else\n                        return 1; // sub-sub domain, reject\n                } else\n                    return 0;\n            } else\n                return 1;\n        }\n    }\n\n    /*\n     * We found different characters in the same position (from the end).\n     */\n\n    // If the h has a form of \"*.foo.com\" and d has a form of \"x.foo.com\"\n    // then the h[hl] points to '*', h[hl+1] to '.' and d[dl] to 'x'\n    // The following checks are safe, the \"h[hl + 1]\" in the worst case is '\\0'.\n    if ((flags & mdnHonorWildcards) && h[hl] == '*' && h[hl + 1] == '.')\n        return 0;\n\n    /*\n     * If one of those character is '.' then its special.  In order\n     * for splay tree sorting to work properly, \"x-foo.com\" must\n     * be greater than \".foo.com\" even though '-' is less than '.'.\n     */\n    if ('.' == d[dl])\n        return 1;\n\n    if ('.' == h[hl])\n        return -1;\n\n    return (xtolower(h[hl]) - xtolower(d[dl]));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -14,6 +14,8 @@\n         return -1;\n \n     dl = strlen(d);\n+    if (dl == 0)\n+        return 1;\n \n     /*\n      * Start at the ends of the two strings and work towards the",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    if (dl == 0)",
                "        return 1;"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-46724",
        "func_name": "squid-cache/squid/urlInitialize",
        "description": " Squid is a caching proxy for the Web. Due to an Improper Validation of Specified Index bug, Squid versions 3.3.0.1 through 5.9 and 6.0 prior to 6.4 compiled using `--with-openssl` are vulnerable to a Denial of Service attack against SSL Certificate validation. This problem allows a remote server to perform Denial of Service against Squid Proxy by initiating a TLS Handshake with a specially crafted SSL Certificate in a server certificate chain. This attack is limited to HTTPS and SSL-Bump. This bug is fixed in Squid version 6.4. In addition, patches addressing this problem for the stable releases can be found in Squid's patch archives. Those who you use a prepackaged version of Squid should refer to the package vendor for availability information on updated packages.",
        "git_url": "https://github.com/squid-cache/squid/commit/b70f864940225dfe69f9f653f948e787f99c3810",
        "commit_title": "Fix validation of certificates with CN=* (#1523)",
        "commit_text": " The bug was discovered and detailed by Joshua Rogers at https://megamansec.github.io/Squid-Security-Audit/ where it was filed as \"Buffer UnderRead in SSL CN Parsing\".",
        "func_before": "void\nurlInitialize(void)\n{\n    debugs(23, 5, \"urlInitialize: Initializing...\");\n    /* this ensures that the number of protocol strings is the same as\n     * the enum slots allocated because the last enum is always 'MAX'.\n     */\n    assert(strcmp(AnyP::ProtocolType_str[AnyP::PROTO_MAX], \"MAX\") == 0);\n    /*\n     * These test that our matchDomainName() function works the\n     * way we expect it to.\n     */\n    assert(0 == matchDomainName(\"foo.com\", \"foo.com\"));\n    assert(0 == matchDomainName(\".foo.com\", \"foo.com\"));\n    assert(0 == matchDomainName(\"foo.com\", \".foo.com\"));\n    assert(0 == matchDomainName(\".foo.com\", \".foo.com\"));\n    assert(0 == matchDomainName(\"x.foo.com\", \".foo.com\"));\n    assert(0 == matchDomainName(\"y.x.foo.com\", \".foo.com\"));\n    assert(0 != matchDomainName(\"x.foo.com\", \"foo.com\"));\n    assert(0 != matchDomainName(\"foo.com\", \"x.foo.com\"));\n    assert(0 != matchDomainName(\"bar.com\", \"foo.com\"));\n    assert(0 != matchDomainName(\".bar.com\", \"foo.com\"));\n    assert(0 != matchDomainName(\".bar.com\", \".foo.com\"));\n    assert(0 != matchDomainName(\"bar.com\", \".foo.com\"));\n    assert(0 < matchDomainName(\"zzz.com\", \"foo.com\"));\n    assert(0 > matchDomainName(\"aaa.com\", \"foo.com\"));\n    assert(0 == matchDomainName(\"FOO.com\", \"foo.COM\"));\n    assert(0 < matchDomainName(\"bfoo.com\", \"afoo.com\"));\n    assert(0 > matchDomainName(\"afoo.com\", \"bfoo.com\"));\n    assert(0 < matchDomainName(\"x-foo.com\", \".foo.com\"));\n\n    assert(0 == matchDomainName(\".foo.com\", \".foo.com\", mdnRejectSubsubDomains));\n    assert(0 == matchDomainName(\"x.foo.com\", \".foo.com\", mdnRejectSubsubDomains));\n    assert(0 != matchDomainName(\"y.x.foo.com\", \".foo.com\", mdnRejectSubsubDomains));\n    assert(0 != matchDomainName(\".x.foo.com\", \".foo.com\", mdnRejectSubsubDomains));\n\n    assert(0 == matchDomainName(\"*.foo.com\", \"x.foo.com\", mdnHonorWildcards));\n    assert(0 == matchDomainName(\"*.foo.com\", \".x.foo.com\", mdnHonorWildcards));\n    assert(0 == matchDomainName(\"*.foo.com\", \".foo.com\", mdnHonorWildcards));\n    assert(0 != matchDomainName(\"*.foo.com\", \"foo.com\", mdnHonorWildcards));\n\n    /* more cases? */\n}",
        "func": "void\nurlInitialize(void)\n{\n    debugs(23, 5, \"urlInitialize: Initializing...\");\n    /* this ensures that the number of protocol strings is the same as\n     * the enum slots allocated because the last enum is always 'MAX'.\n     */\n    assert(strcmp(AnyP::ProtocolType_str[AnyP::PROTO_MAX], \"MAX\") == 0);\n    /*\n     * These test that our matchDomainName() function works the\n     * way we expect it to.\n     */\n    assert(0 == matchDomainName(\"foo.com\", \"foo.com\"));\n    assert(0 == matchDomainName(\".foo.com\", \"foo.com\"));\n    assert(0 == matchDomainName(\"foo.com\", \".foo.com\"));\n    assert(0 == matchDomainName(\".foo.com\", \".foo.com\"));\n    assert(0 == matchDomainName(\"x.foo.com\", \".foo.com\"));\n    assert(0 == matchDomainName(\"y.x.foo.com\", \".foo.com\"));\n    assert(0 != matchDomainName(\"x.foo.com\", \"foo.com\"));\n    assert(0 != matchDomainName(\"foo.com\", \"x.foo.com\"));\n    assert(0 != matchDomainName(\"bar.com\", \"foo.com\"));\n    assert(0 != matchDomainName(\".bar.com\", \"foo.com\"));\n    assert(0 != matchDomainName(\".bar.com\", \".foo.com\"));\n    assert(0 != matchDomainName(\"bar.com\", \".foo.com\"));\n    assert(0 < matchDomainName(\"zzz.com\", \"foo.com\"));\n    assert(0 > matchDomainName(\"aaa.com\", \"foo.com\"));\n    assert(0 == matchDomainName(\"FOO.com\", \"foo.COM\"));\n    assert(0 < matchDomainName(\"bfoo.com\", \"afoo.com\"));\n    assert(0 > matchDomainName(\"afoo.com\", \"bfoo.com\"));\n    assert(0 < matchDomainName(\"x-foo.com\", \".foo.com\"));\n\n    assert(0 == matchDomainName(\".foo.com\", \".foo.com\", mdnRejectSubsubDomains));\n    assert(0 == matchDomainName(\"x.foo.com\", \".foo.com\", mdnRejectSubsubDomains));\n    assert(0 != matchDomainName(\"y.x.foo.com\", \".foo.com\", mdnRejectSubsubDomains));\n    assert(0 != matchDomainName(\".x.foo.com\", \".foo.com\", mdnRejectSubsubDomains));\n\n    assert(0 == matchDomainName(\"*.foo.com\", \"x.foo.com\", mdnHonorWildcards));\n    assert(0 == matchDomainName(\"*.foo.com\", \".x.foo.com\", mdnHonorWildcards));\n    assert(0 == matchDomainName(\"*.foo.com\", \".foo.com\", mdnHonorWildcards));\n    assert(0 != matchDomainName(\"*.foo.com\", \"foo.com\", mdnHonorWildcards));\n\n    assert(0 != matchDomainName(\"foo.com\", \"\"));\n    assert(0 != matchDomainName(\"foo.com\", \"\", mdnHonorWildcards));\n    assert(0 != matchDomainName(\"foo.com\", \"\", mdnRejectSubsubDomains));\n\n    /* more cases? */\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -39,5 +39,9 @@\n     assert(0 == matchDomainName(\"*.foo.com\", \".foo.com\", mdnHonorWildcards));\n     assert(0 != matchDomainName(\"*.foo.com\", \"foo.com\", mdnHonorWildcards));\n \n+    assert(0 != matchDomainName(\"foo.com\", \"\"));\n+    assert(0 != matchDomainName(\"foo.com\", \"\", mdnHonorWildcards));\n+    assert(0 != matchDomainName(\"foo.com\", \"\", mdnRejectSubsubDomains));\n+\n     /* more cases? */\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    assert(0 != matchDomainName(\"foo.com\", \"\"));",
                "    assert(0 != matchDomainName(\"foo.com\", \"\", mdnHonorWildcards));",
                "    assert(0 != matchDomainName(\"foo.com\", \"\", mdnRejectSubsubDomains));",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2021-22895",
        "func_name": "nextcloud/desktop/WebEnginePage::certificateError",
        "description": "Nextcloud Desktop Client before 3.3.1 is vulnerable to improper certificate validation due to lack of SSL certificate verification when using the \"Register with a Provider\" flow.",
        "git_url": "https://github.com/nextcloud/desktop/commit/142180c0e297ef500daf8328e7ea3020e33a3639",
        "commit_title": "Validate the providers ssl certificate",
        "commit_text": "",
        "func_before": "bool WebEnginePage::certificateError(const QWebEngineCertificateError &certificateError) {\n    if (certificateError.error() == QWebEngineCertificateError::CertificateAuthorityInvalid &&\n        certificateError.url().host() == _rootUrl.host()) {\n        return true;\n    }\n\n    /**\n     * TODO properly improve this.\n     * The certificate should be displayed.\n     *\n     * Or rather we should do a request with the QNAM and see if it works (then it is in the store).\n     * This is just a quick fix for now.\n     */\n    QMessageBox messageBox;\n    messageBox.setText(tr(\"Invalid certificate detected\"));\n    messageBox.setInformativeText(tr(\"The host \\\"%1\\\" provided an invalid certificate. Continue?\").arg(certificateError.url().host()));\n    messageBox.setIcon(QMessageBox::Warning);\n    messageBox.setStandardButtons(QMessageBox::Yes|QMessageBox::No);\n    messageBox.setDefaultButton(QMessageBox::No);\n\n    int ret = messageBox.exec();\n\n    return ret == QMessageBox::Yes;\n}",
        "func": "bool WebEnginePage::certificateError(const QWebEngineCertificateError &certificateError)\n{\n    /**\n     * TODO properly improve this.\n     * The certificate should be displayed.\n     *\n     * Or rather we should do a request with the QNAM and see if it works (then it is in the store).\n     * This is just a quick fix for now.\n     */\n    QMessageBox messageBox;\n    messageBox.setText(tr(\"Invalid certificate detected\"));\n    messageBox.setInformativeText(tr(\"The host \\\"%1\\\" provided an invalid certificate. Continue?\").arg(certificateError.url().host()));\n    messageBox.setIcon(QMessageBox::Warning);\n    messageBox.setStandardButtons(QMessageBox::Yes|QMessageBox::No);\n    messageBox.setDefaultButton(QMessageBox::No);\n\n    int ret = messageBox.exec();\n\n    return ret == QMessageBox::Yes;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,9 +1,5 @@\n-bool WebEnginePage::certificateError(const QWebEngineCertificateError &certificateError) {\n-    if (certificateError.error() == QWebEngineCertificateError::CertificateAuthorityInvalid &&\n-        certificateError.url().host() == _rootUrl.host()) {\n-        return true;\n-    }\n-\n+bool WebEnginePage::certificateError(const QWebEngineCertificateError &certificateError)\n+{\n     /**\n      * TODO properly improve this.\n      * The certificate should be displayed.",
        "diff_line_info": {
            "deleted_lines": [
                "bool WebEnginePage::certificateError(const QWebEngineCertificateError &certificateError) {",
                "    if (certificateError.error() == QWebEngineCertificateError::CertificateAuthorityInvalid &&",
                "        certificateError.url().host() == _rootUrl.host()) {",
                "        return true;",
                "    }",
                ""
            ],
            "added_lines": [
                "bool WebEnginePage::certificateError(const QWebEngineCertificateError &certificateError)",
                "{"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-22895",
        "func_name": "nextcloud/desktop/WebEnginePage::setUrl",
        "description": "Nextcloud Desktop Client before 3.3.1 is vulnerable to improper certificate validation due to lack of SSL certificate verification when using the \"Register with a Provider\" flow.",
        "git_url": "https://github.com/nextcloud/desktop/commit/142180c0e297ef500daf8328e7ea3020e33a3639",
        "commit_title": "Validate the providers ssl certificate",
        "commit_text": "",
        "func_before": "void WebEnginePage::setUrl(const QUrl &url) {\n    QWebEnginePage::setUrl(url);\n    _rootUrl = url;\n}",
        "func": "void WebEnginePage::setUrl(const QUrl &url) {\n    QWebEnginePage::setUrl(url);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,3 @@\n void WebEnginePage::setUrl(const QUrl &url) {\n     QWebEnginePage::setUrl(url);\n-    _rootUrl = url;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    _rootUrl = url;"
            ],
            "added_lines": []
        }
    },
    {
        "cve_id": "CVE-2023-0464",
        "func_name": "openssl/tree_init",
        "description": "A security vulnerability has been identified in all supported versions\n\nof OpenSSL related to the verification of X.509 certificate chains\nthat include policy constraints.  Attackers may be able to exploit this\nvulnerability by creating a malicious certificate chain that triggers\nexponential use of computational resources, leading to a denial-of-service\n(DoS) attack on affected systems.\n\nPolicy processing is disabled by default but can be enabled by passing\nthe `-policy' argument to the command line utilities or by calling the\n`X509_VERIFY_PARAM_set1_policies()' function.",
        "git_url": "https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=879f7080d7e141f415c79eaa3a8ac4a3dad0348b",
        "commit_title": "",
        "commit_text": "x509: excessive resource use verifying policy constraints  A security vulnerability has been identified in all supported versions of OpenSSL related to the verification of X.509 certificate chains that include policy constraints.  Attackers may be able to exploit this vulnerability by creating a malicious certificate chain that triggers exponential use of computational resources, leading to a denial-of-service (DoS) attack on affected systems.  Fixes CVE-2023-0464  (Merged from https://github.com/openssl/openssl/pull/20569) ",
        "func_before": "static int tree_init(X509_POLICY_TREE **ptree, STACK_OF(X509) *certs,\n                     unsigned int flags)\n{\n    X509_POLICY_TREE *tree;\n    X509_POLICY_LEVEL *level;\n    const X509_POLICY_CACHE *cache;\n    X509_POLICY_DATA *data = NULL;\n    int ret = X509_PCY_TREE_VALID;\n    int n = sk_X509_num(certs) - 1; /* RFC5280 paths omit the TA */\n    int explicit_policy = (flags & X509_V_FLAG_EXPLICIT_POLICY) ? 0 : n+1;\n    int any_skip = (flags & X509_V_FLAG_INHIBIT_ANY) ? 0 : n+1;\n    int map_skip = (flags & X509_V_FLAG_INHIBIT_MAP) ? 0 : n+1;\n    int i;\n\n    *ptree = NULL;\n\n    /* Can't do anything with just a trust anchor */\n    if (n == 0)\n        return X509_PCY_TREE_EMPTY;\n\n    /*\n     * First setup the policy cache in all n non-TA certificates, this will be\n     * used in X509_verify_cert() which will invoke the verify callback for all\n     * certificates with invalid policy extensions.\n     */\n    for (i = n - 1; i >= 0; i--) {\n        X509 *x = sk_X509_value(certs, i);\n\n        /* Call for side-effect of computing hash and caching extensions */\n        X509_check_purpose(x, -1, 0);\n\n        /* If cache is NULL, likely ENOMEM: return immediately */\n        if (policy_cache_set(x) == NULL)\n            return X509_PCY_TREE_INTERNAL;\n    }\n\n    /*\n     * At this point check for invalid policies and required explicit policy.\n     * Note that the explicit_policy counter is a count-down to zero, with the\n     * requirement kicking in if and once it does that.  The counter is\n     * decremented for every non-self-issued certificate in the path, but may\n     * be further reduced by policy constraints in a non-leaf certificate.\n     *\n     * The ultimate policy set is the intersection of all the policies along\n     * the path, if we hit a certificate with an empty policy set, and explicit\n     * policy is required we're done.\n     */\n    for (i = n - 1;\n         i >= 0 && (explicit_policy > 0 || (ret & X509_PCY_TREE_EMPTY) == 0);\n         i--) {\n        X509 *x = sk_X509_value(certs, i);\n        uint32_t ex_flags = X509_get_extension_flags(x);\n\n        /* All the policies are already cached, we can return early */\n        if (ex_flags & EXFLAG_INVALID_POLICY)\n            return X509_PCY_TREE_INVALID;\n\n        /* Access the cache which we now know exists */\n        cache = policy_cache_set(x);\n\n        if ((ret & X509_PCY_TREE_VALID) && cache->data == NULL)\n            ret = X509_PCY_TREE_EMPTY;\n        if (explicit_policy > 0) {\n            if (!(ex_flags & EXFLAG_SI))\n                explicit_policy--;\n            if ((cache->explicit_skip >= 0)\n                && (cache->explicit_skip < explicit_policy))\n                explicit_policy = cache->explicit_skip;\n        }\n    }\n\n    if (explicit_policy == 0)\n        ret |= X509_PCY_TREE_EXPLICIT;\n    if ((ret & X509_PCY_TREE_VALID) == 0)\n        return ret;\n\n    /* If we get this far initialize the tree */\n    if ((tree = OPENSSL_zalloc(sizeof(*tree))) == NULL) {\n        X509V3err(X509V3_F_TREE_INIT, ERR_R_MALLOC_FAILURE);\n        return X509_PCY_TREE_INTERNAL;\n    }\n\n    /*\n     * http://tools.ietf.org/html/rfc5280#section-6.1.2, figure 3.\n     *\n     * The top level is implicitly for the trust anchor with valid expected\n     * policies of anyPolicy.  (RFC 5280 has the TA at depth 0 and the leaf at\n     * depth n, we have the leaf at depth 0 and the TA at depth n).\n     */\n    if ((tree->levels = OPENSSL_zalloc(sizeof(*tree->levels)*(n+1))) == NULL) {\n        OPENSSL_free(tree);\n        X509V3err(X509V3_F_TREE_INIT, ERR_R_MALLOC_FAILURE);\n        return X509_PCY_TREE_INTERNAL;\n    }\n    tree->nlevel = n+1;\n    level = tree->levels;\n    if ((data = policy_data_new(NULL, OBJ_nid2obj(NID_any_policy), 0)) == NULL)\n        goto bad_tree;\n    if (level_add_node(level, data, NULL, tree) == NULL) {\n        policy_data_free(data);\n        goto bad_tree;\n    }\n\n    /*\n     * In this pass initialize all the tree levels and whether anyPolicy and\n     * policy mapping are inhibited at each level.\n     */\n    for (i = n - 1; i >= 0; i--) {\n        X509 *x = sk_X509_value(certs, i);\n        uint32_t ex_flags = X509_get_extension_flags(x);\n\n        /* Access the cache which we now know exists */\n        cache = policy_cache_set(x);\n\n        X509_up_ref(x);\n        (++level)->cert = x;\n\n        if (!cache->anyPolicy)\n            level->flags |= X509_V_FLAG_INHIBIT_ANY;\n\n        /* Determine inhibit any and inhibit map flags */\n        if (any_skip == 0) {\n            /*\n             * Any matching allowed only if certificate is self issued and not\n             * the last in the chain.\n             */\n            if (!(ex_flags & EXFLAG_SI) || (i == 0))\n                level->flags |= X509_V_FLAG_INHIBIT_ANY;\n        } else {\n            if (!(ex_flags & EXFLAG_SI))\n                any_skip--;\n            if ((cache->any_skip >= 0) && (cache->any_skip < any_skip))\n                any_skip = cache->any_skip;\n        }\n\n        if (map_skip == 0)\n            level->flags |= X509_V_FLAG_INHIBIT_MAP;\n        else {\n            if (!(ex_flags & EXFLAG_SI))\n                map_skip--;\n            if ((cache->map_skip >= 0) && (cache->map_skip < map_skip))\n                map_skip = cache->map_skip;\n        }\n    }\n\n    *ptree = tree;\n    return ret;\n\n bad_tree:\n    X509_policy_tree_free(tree);\n    return X509_PCY_TREE_INTERNAL;\n}",
        "func": "static int tree_init(X509_POLICY_TREE **ptree, STACK_OF(X509) *certs,\n                     unsigned int flags)\n{\n    X509_POLICY_TREE *tree;\n    X509_POLICY_LEVEL *level;\n    const X509_POLICY_CACHE *cache;\n    X509_POLICY_DATA *data = NULL;\n    int ret = X509_PCY_TREE_VALID;\n    int n = sk_X509_num(certs) - 1; /* RFC5280 paths omit the TA */\n    int explicit_policy = (flags & X509_V_FLAG_EXPLICIT_POLICY) ? 0 : n+1;\n    int any_skip = (flags & X509_V_FLAG_INHIBIT_ANY) ? 0 : n+1;\n    int map_skip = (flags & X509_V_FLAG_INHIBIT_MAP) ? 0 : n+1;\n    int i;\n\n    *ptree = NULL;\n\n    /* Can't do anything with just a trust anchor */\n    if (n == 0)\n        return X509_PCY_TREE_EMPTY;\n\n    /*\n     * First setup the policy cache in all n non-TA certificates, this will be\n     * used in X509_verify_cert() which will invoke the verify callback for all\n     * certificates with invalid policy extensions.\n     */\n    for (i = n - 1; i >= 0; i--) {\n        X509 *x = sk_X509_value(certs, i);\n\n        /* Call for side-effect of computing hash and caching extensions */\n        X509_check_purpose(x, -1, 0);\n\n        /* If cache is NULL, likely ENOMEM: return immediately */\n        if (policy_cache_set(x) == NULL)\n            return X509_PCY_TREE_INTERNAL;\n    }\n\n    /*\n     * At this point check for invalid policies and required explicit policy.\n     * Note that the explicit_policy counter is a count-down to zero, with the\n     * requirement kicking in if and once it does that.  The counter is\n     * decremented for every non-self-issued certificate in the path, but may\n     * be further reduced by policy constraints in a non-leaf certificate.\n     *\n     * The ultimate policy set is the intersection of all the policies along\n     * the path, if we hit a certificate with an empty policy set, and explicit\n     * policy is required we're done.\n     */\n    for (i = n - 1;\n         i >= 0 && (explicit_policy > 0 || (ret & X509_PCY_TREE_EMPTY) == 0);\n         i--) {\n        X509 *x = sk_X509_value(certs, i);\n        uint32_t ex_flags = X509_get_extension_flags(x);\n\n        /* All the policies are already cached, we can return early */\n        if (ex_flags & EXFLAG_INVALID_POLICY)\n            return X509_PCY_TREE_INVALID;\n\n        /* Access the cache which we now know exists */\n        cache = policy_cache_set(x);\n\n        if ((ret & X509_PCY_TREE_VALID) && cache->data == NULL)\n            ret = X509_PCY_TREE_EMPTY;\n        if (explicit_policy > 0) {\n            if (!(ex_flags & EXFLAG_SI))\n                explicit_policy--;\n            if ((cache->explicit_skip >= 0)\n                && (cache->explicit_skip < explicit_policy))\n                explicit_policy = cache->explicit_skip;\n        }\n    }\n\n    if (explicit_policy == 0)\n        ret |= X509_PCY_TREE_EXPLICIT;\n    if ((ret & X509_PCY_TREE_VALID) == 0)\n        return ret;\n\n    /* If we get this far initialize the tree */\n    if ((tree = OPENSSL_zalloc(sizeof(*tree))) == NULL) {\n        X509V3err(X509V3_F_TREE_INIT, ERR_R_MALLOC_FAILURE);\n        return X509_PCY_TREE_INTERNAL;\n    }\n\n    /* Limit the growth of the tree to mitigate CVE-2023-0464 */\n    tree->node_maximum = OPENSSL_POLICY_TREE_NODES_MAX;\n\n    /*\n     * http://tools.ietf.org/html/rfc5280#section-6.1.2, figure 3.\n     *\n     * The top level is implicitly for the trust anchor with valid expected\n     * policies of anyPolicy.  (RFC 5280 has the TA at depth 0 and the leaf at\n     * depth n, we have the leaf at depth 0 and the TA at depth n).\n     */\n    if ((tree->levels = OPENSSL_zalloc(sizeof(*tree->levels)*(n+1))) == NULL) {\n        OPENSSL_free(tree);\n        X509V3err(X509V3_F_TREE_INIT, ERR_R_MALLOC_FAILURE);\n        return X509_PCY_TREE_INTERNAL;\n    }\n    tree->nlevel = n+1;\n    level = tree->levels;\n    if ((data = policy_data_new(NULL, OBJ_nid2obj(NID_any_policy), 0)) == NULL)\n        goto bad_tree;\n    if (level_add_node(level, data, NULL, tree, 1) == NULL) {\n        policy_data_free(data);\n        goto bad_tree;\n    }\n\n    /*\n     * In this pass initialize all the tree levels and whether anyPolicy and\n     * policy mapping are inhibited at each level.\n     */\n    for (i = n - 1; i >= 0; i--) {\n        X509 *x = sk_X509_value(certs, i);\n        uint32_t ex_flags = X509_get_extension_flags(x);\n\n        /* Access the cache which we now know exists */\n        cache = policy_cache_set(x);\n\n        X509_up_ref(x);\n        (++level)->cert = x;\n\n        if (!cache->anyPolicy)\n            level->flags |= X509_V_FLAG_INHIBIT_ANY;\n\n        /* Determine inhibit any and inhibit map flags */\n        if (any_skip == 0) {\n            /*\n             * Any matching allowed only if certificate is self issued and not\n             * the last in the chain.\n             */\n            if (!(ex_flags & EXFLAG_SI) || (i == 0))\n                level->flags |= X509_V_FLAG_INHIBIT_ANY;\n        } else {\n            if (!(ex_flags & EXFLAG_SI))\n                any_skip--;\n            if ((cache->any_skip >= 0) && (cache->any_skip < any_skip))\n                any_skip = cache->any_skip;\n        }\n\n        if (map_skip == 0)\n            level->flags |= X509_V_FLAG_INHIBIT_MAP;\n        else {\n            if (!(ex_flags & EXFLAG_SI))\n                map_skip--;\n            if ((cache->map_skip >= 0) && (cache->map_skip < map_skip))\n                map_skip = cache->map_skip;\n        }\n    }\n\n    *ptree = tree;\n    return ret;\n\n bad_tree:\n    X509_policy_tree_free(tree);\n    return X509_PCY_TREE_INTERNAL;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -80,6 +80,9 @@\n         return X509_PCY_TREE_INTERNAL;\n     }\n \n+    /* Limit the growth of the tree to mitigate CVE-2023-0464 */\n+    tree->node_maximum = OPENSSL_POLICY_TREE_NODES_MAX;\n+\n     /*\n      * http://tools.ietf.org/html/rfc5280#section-6.1.2, figure 3.\n      *\n@@ -96,7 +99,7 @@\n     level = tree->levels;\n     if ((data = policy_data_new(NULL, OBJ_nid2obj(NID_any_policy), 0)) == NULL)\n         goto bad_tree;\n-    if (level_add_node(level, data, NULL, tree) == NULL) {\n+    if (level_add_node(level, data, NULL, tree, 1) == NULL) {\n         policy_data_free(data);\n         goto bad_tree;\n     }",
        "diff_line_info": {
            "deleted_lines": [
                "    if (level_add_node(level, data, NULL, tree) == NULL) {"
            ],
            "added_lines": [
                "    /* Limit the growth of the tree to mitigate CVE-2023-0464 */",
                "    tree->node_maximum = OPENSSL_POLICY_TREE_NODES_MAX;",
                "",
                "    if (level_add_node(level, data, NULL, tree, 1) == NULL) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-0464",
        "func_name": "openssl/tree_evaluate",
        "description": "A security vulnerability has been identified in all supported versions\n\nof OpenSSL related to the verification of X.509 certificate chains\nthat include policy constraints.  Attackers may be able to exploit this\nvulnerability by creating a malicious certificate chain that triggers\nexponential use of computational resources, leading to a denial-of-service\n(DoS) attack on affected systems.\n\nPolicy processing is disabled by default but can be enabled by passing\nthe `-policy' argument to the command line utilities or by calling the\n`X509_VERIFY_PARAM_set1_policies()' function.",
        "git_url": "https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=879f7080d7e141f415c79eaa3a8ac4a3dad0348b",
        "commit_title": "",
        "commit_text": "x509: excessive resource use verifying policy constraints  A security vulnerability has been identified in all supported versions of OpenSSL related to the verification of X.509 certificate chains that include policy constraints.  Attackers may be able to exploit this vulnerability by creating a malicious certificate chain that triggers exponential use of computational resources, leading to a denial-of-service (DoS) attack on affected systems.  Fixes CVE-2023-0464  (Merged from https://github.com/openssl/openssl/pull/20569) ",
        "func_before": "static int tree_evaluate(X509_POLICY_TREE *tree)\n{\n    int ret, i;\n    X509_POLICY_LEVEL *curr = tree->levels + 1;\n    const X509_POLICY_CACHE *cache;\n\n    for (i = 1; i < tree->nlevel; i++, curr++) {\n        cache = policy_cache_set(curr->cert);\n        if (!tree_link_nodes(curr, cache))\n            return X509_PCY_TREE_INTERNAL;\n\n        if (!(curr->flags & X509_V_FLAG_INHIBIT_ANY)\n            && !tree_link_any(curr, cache, tree))\n            return X509_PCY_TREE_INTERNAL;\n#ifdef OPENSSL_POLICY_DEBUG\n        tree_print(\"before tree_prune()\", tree, curr);\n#endif\n        ret = tree_prune(tree, curr);\n        if (ret != X509_PCY_TREE_VALID)\n            return ret;\n    }\n    return X509_PCY_TREE_VALID;\n}",
        "func": "static int tree_evaluate(X509_POLICY_TREE *tree)\n{\n    int ret, i;\n    X509_POLICY_LEVEL *curr = tree->levels + 1;\n    const X509_POLICY_CACHE *cache;\n\n    for (i = 1; i < tree->nlevel; i++, curr++) {\n        cache = policy_cache_set(curr->cert);\n        if (!tree_link_nodes(curr, cache, tree))\n            return X509_PCY_TREE_INTERNAL;\n\n        if (!(curr->flags & X509_V_FLAG_INHIBIT_ANY)\n            && !tree_link_any(curr, cache, tree))\n            return X509_PCY_TREE_INTERNAL;\n#ifdef OPENSSL_POLICY_DEBUG\n        tree_print(\"before tree_prune()\", tree, curr);\n#endif\n        ret = tree_prune(tree, curr);\n        if (ret != X509_PCY_TREE_VALID)\n            return ret;\n    }\n    return X509_PCY_TREE_VALID;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,7 +6,7 @@\n \n     for (i = 1; i < tree->nlevel; i++, curr++) {\n         cache = policy_cache_set(curr->cert);\n-        if (!tree_link_nodes(curr, cache))\n+        if (!tree_link_nodes(curr, cache, tree))\n             return X509_PCY_TREE_INTERNAL;\n \n         if (!(curr->flags & X509_V_FLAG_INHIBIT_ANY)",
        "diff_line_info": {
            "deleted_lines": [
                "        if (!tree_link_nodes(curr, cache))"
            ],
            "added_lines": [
                "        if (!tree_link_nodes(curr, cache, tree))"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-0464",
        "func_name": "openssl/tree_link_matching_nodes",
        "description": "A security vulnerability has been identified in all supported versions\n\nof OpenSSL related to the verification of X.509 certificate chains\nthat include policy constraints.  Attackers may be able to exploit this\nvulnerability by creating a malicious certificate chain that triggers\nexponential use of computational resources, leading to a denial-of-service\n(DoS) attack on affected systems.\n\nPolicy processing is disabled by default but can be enabled by passing\nthe `-policy' argument to the command line utilities or by calling the\n`X509_VERIFY_PARAM_set1_policies()' function.",
        "git_url": "https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=879f7080d7e141f415c79eaa3a8ac4a3dad0348b",
        "commit_title": "",
        "commit_text": "x509: excessive resource use verifying policy constraints  A security vulnerability has been identified in all supported versions of OpenSSL related to the verification of X.509 certificate chains that include policy constraints.  Attackers may be able to exploit this vulnerability by creating a malicious certificate chain that triggers exponential use of computational resources, leading to a denial-of-service (DoS) attack on affected systems.  Fixes CVE-2023-0464  (Merged from https://github.com/openssl/openssl/pull/20569) ",
        "func_before": "static int tree_link_matching_nodes(X509_POLICY_LEVEL *curr,\n                                    X509_POLICY_DATA *data)\n{\n    X509_POLICY_LEVEL *last = curr - 1;\n    int i, matched = 0;\n\n    /* Iterate through all in nodes linking matches */\n    for (i = 0; i < sk_X509_POLICY_NODE_num(last->nodes); i++) {\n        X509_POLICY_NODE *node = sk_X509_POLICY_NODE_value(last->nodes, i);\n\n        if (policy_node_match(last, node, data->valid_policy)) {\n            if (level_add_node(curr, data, node, NULL) == NULL)\n                return 0;\n            matched = 1;\n        }\n    }\n    if (!matched && last->anyPolicy) {\n        if (level_add_node(curr, data, last->anyPolicy, NULL) == NULL)\n            return 0;\n    }\n    return 1;\n}",
        "func": "static int tree_link_matching_nodes(X509_POLICY_LEVEL *curr,\n                                    X509_POLICY_DATA *data,\n                                    X509_POLICY_TREE *tree)\n{\n    X509_POLICY_LEVEL *last = curr - 1;\n    int i, matched = 0;\n\n    /* Iterate through all in nodes linking matches */\n    for (i = 0; i < sk_X509_POLICY_NODE_num(last->nodes); i++) {\n        X509_POLICY_NODE *node = sk_X509_POLICY_NODE_value(last->nodes, i);\n\n        if (policy_node_match(last, node, data->valid_policy)) {\n            if (level_add_node(curr, data, node, tree, 0) == NULL)\n                return 0;\n            matched = 1;\n        }\n    }\n    if (!matched && last->anyPolicy) {\n        if (level_add_node(curr, data, last->anyPolicy, tree, 0) == NULL)\n            return 0;\n    }\n    return 1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,6 @@\n static int tree_link_matching_nodes(X509_POLICY_LEVEL *curr,\n-                                    X509_POLICY_DATA *data)\n+                                    X509_POLICY_DATA *data,\n+                                    X509_POLICY_TREE *tree)\n {\n     X509_POLICY_LEVEL *last = curr - 1;\n     int i, matched = 0;\n@@ -9,13 +10,13 @@\n         X509_POLICY_NODE *node = sk_X509_POLICY_NODE_value(last->nodes, i);\n \n         if (policy_node_match(last, node, data->valid_policy)) {\n-            if (level_add_node(curr, data, node, NULL) == NULL)\n+            if (level_add_node(curr, data, node, tree, 0) == NULL)\n                 return 0;\n             matched = 1;\n         }\n     }\n     if (!matched && last->anyPolicy) {\n-        if (level_add_node(curr, data, last->anyPolicy, NULL) == NULL)\n+        if (level_add_node(curr, data, last->anyPolicy, tree, 0) == NULL)\n             return 0;\n     }\n     return 1;",
        "diff_line_info": {
            "deleted_lines": [
                "                                    X509_POLICY_DATA *data)",
                "            if (level_add_node(curr, data, node, NULL) == NULL)",
                "        if (level_add_node(curr, data, last->anyPolicy, NULL) == NULL)"
            ],
            "added_lines": [
                "                                    X509_POLICY_DATA *data,",
                "                                    X509_POLICY_TREE *tree)",
                "            if (level_add_node(curr, data, node, tree, 0) == NULL)",
                "        if (level_add_node(curr, data, last->anyPolicy, tree, 0) == NULL)"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-0464",
        "func_name": "openssl/tree_link_any",
        "description": "A security vulnerability has been identified in all supported versions\n\nof OpenSSL related to the verification of X.509 certificate chains\nthat include policy constraints.  Attackers may be able to exploit this\nvulnerability by creating a malicious certificate chain that triggers\nexponential use of computational resources, leading to a denial-of-service\n(DoS) attack on affected systems.\n\nPolicy processing is disabled by default but can be enabled by passing\nthe `-policy' argument to the command line utilities or by calling the\n`X509_VERIFY_PARAM_set1_policies()' function.",
        "git_url": "https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=879f7080d7e141f415c79eaa3a8ac4a3dad0348b",
        "commit_title": "",
        "commit_text": "x509: excessive resource use verifying policy constraints  A security vulnerability has been identified in all supported versions of OpenSSL related to the verification of X.509 certificate chains that include policy constraints.  Attackers may be able to exploit this vulnerability by creating a malicious certificate chain that triggers exponential use of computational resources, leading to a denial-of-service (DoS) attack on affected systems.  Fixes CVE-2023-0464  (Merged from https://github.com/openssl/openssl/pull/20569) ",
        "func_before": "static int tree_link_any(X509_POLICY_LEVEL *curr,\n                         const X509_POLICY_CACHE *cache,\n                         X509_POLICY_TREE *tree)\n{\n    int i;\n    X509_POLICY_NODE *node;\n    X509_POLICY_LEVEL *last = curr - 1;\n\n    for (i = 0; i < sk_X509_POLICY_NODE_num(last->nodes); i++) {\n        node = sk_X509_POLICY_NODE_value(last->nodes, i);\n\n        if (!tree_link_unmatched(curr, cache, node, tree))\n            return 0;\n    }\n    /* Finally add link to anyPolicy */\n    if (last->anyPolicy &&\n        level_add_node(curr, cache->anyPolicy, last->anyPolicy, NULL) == NULL)\n        return 0;\n    return 1;\n}",
        "func": "static int tree_link_any(X509_POLICY_LEVEL *curr,\n                         const X509_POLICY_CACHE *cache,\n                         X509_POLICY_TREE *tree)\n{\n    int i;\n    X509_POLICY_NODE *node;\n    X509_POLICY_LEVEL *last = curr - 1;\n\n    for (i = 0; i < sk_X509_POLICY_NODE_num(last->nodes); i++) {\n        node = sk_X509_POLICY_NODE_value(last->nodes, i);\n\n        if (!tree_link_unmatched(curr, cache, node, tree))\n            return 0;\n    }\n    /* Finally add link to anyPolicy */\n    if (last->anyPolicy &&\n        level_add_node(curr, cache->anyPolicy, last->anyPolicy, tree, 0) == NULL)\n        return 0;\n    return 1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -14,7 +14,7 @@\n     }\n     /* Finally add link to anyPolicy */\n     if (last->anyPolicy &&\n-        level_add_node(curr, cache->anyPolicy, last->anyPolicy, NULL) == NULL)\n+        level_add_node(curr, cache->anyPolicy, last->anyPolicy, tree, 0) == NULL)\n         return 0;\n     return 1;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "        level_add_node(curr, cache->anyPolicy, last->anyPolicy, NULL) == NULL)"
            ],
            "added_lines": [
                "        level_add_node(curr, cache->anyPolicy, last->anyPolicy, tree, 0) == NULL)"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-0464",
        "func_name": "openssl/tree_link_nodes",
        "description": "A security vulnerability has been identified in all supported versions\n\nof OpenSSL related to the verification of X.509 certificate chains\nthat include policy constraints.  Attackers may be able to exploit this\nvulnerability by creating a malicious certificate chain that triggers\nexponential use of computational resources, leading to a denial-of-service\n(DoS) attack on affected systems.\n\nPolicy processing is disabled by default but can be enabled by passing\nthe `-policy' argument to the command line utilities or by calling the\n`X509_VERIFY_PARAM_set1_policies()' function.",
        "git_url": "https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=879f7080d7e141f415c79eaa3a8ac4a3dad0348b",
        "commit_title": "",
        "commit_text": "x509: excessive resource use verifying policy constraints  A security vulnerability has been identified in all supported versions of OpenSSL related to the verification of X.509 certificate chains that include policy constraints.  Attackers may be able to exploit this vulnerability by creating a malicious certificate chain that triggers exponential use of computational resources, leading to a denial-of-service (DoS) attack on affected systems.  Fixes CVE-2023-0464  (Merged from https://github.com/openssl/openssl/pull/20569) ",
        "func_before": "static int tree_link_nodes(X509_POLICY_LEVEL *curr,\n                           const X509_POLICY_CACHE *cache)\n{\n    int i;\n\n    for (i = 0; i < sk_X509_POLICY_DATA_num(cache->data); i++) {\n        X509_POLICY_DATA *data = sk_X509_POLICY_DATA_value(cache->data, i);\n\n        /* Look for matching nodes in previous level */\n        if (!tree_link_matching_nodes(curr, data))\n            return 0;\n    }\n    return 1;\n}",
        "func": "static int tree_link_nodes(X509_POLICY_LEVEL *curr,\n                           const X509_POLICY_CACHE *cache,\n                           X509_POLICY_TREE *tree)\n{\n    int i;\n\n    for (i = 0; i < sk_X509_POLICY_DATA_num(cache->data); i++) {\n        X509_POLICY_DATA *data = sk_X509_POLICY_DATA_value(cache->data, i);\n\n        /* Look for matching nodes in previous level */\n        if (!tree_link_matching_nodes(curr, data, tree))\n            return 0;\n    }\n    return 1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,6 @@\n static int tree_link_nodes(X509_POLICY_LEVEL *curr,\n-                           const X509_POLICY_CACHE *cache)\n+                           const X509_POLICY_CACHE *cache,\n+                           X509_POLICY_TREE *tree)\n {\n     int i;\n \n@@ -7,7 +8,7 @@\n         X509_POLICY_DATA *data = sk_X509_POLICY_DATA_value(cache->data, i);\n \n         /* Look for matching nodes in previous level */\n-        if (!tree_link_matching_nodes(curr, data))\n+        if (!tree_link_matching_nodes(curr, data, tree))\n             return 0;\n     }\n     return 1;",
        "diff_line_info": {
            "deleted_lines": [
                "                           const X509_POLICY_CACHE *cache)",
                "        if (!tree_link_matching_nodes(curr, data))"
            ],
            "added_lines": [
                "                           const X509_POLICY_CACHE *cache,",
                "                           X509_POLICY_TREE *tree)",
                "        if (!tree_link_matching_nodes(curr, data, tree))"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-0464",
        "func_name": "openssl/tree_add_unmatched",
        "description": "A security vulnerability has been identified in all supported versions\n\nof OpenSSL related to the verification of X.509 certificate chains\nthat include policy constraints.  Attackers may be able to exploit this\nvulnerability by creating a malicious certificate chain that triggers\nexponential use of computational resources, leading to a denial-of-service\n(DoS) attack on affected systems.\n\nPolicy processing is disabled by default but can be enabled by passing\nthe `-policy' argument to the command line utilities or by calling the\n`X509_VERIFY_PARAM_set1_policies()' function.",
        "git_url": "https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=879f7080d7e141f415c79eaa3a8ac4a3dad0348b",
        "commit_title": "",
        "commit_text": "x509: excessive resource use verifying policy constraints  A security vulnerability has been identified in all supported versions of OpenSSL related to the verification of X.509 certificate chains that include policy constraints.  Attackers may be able to exploit this vulnerability by creating a malicious certificate chain that triggers exponential use of computational resources, leading to a denial-of-service (DoS) attack on affected systems.  Fixes CVE-2023-0464  (Merged from https://github.com/openssl/openssl/pull/20569) ",
        "func_before": "static int tree_add_unmatched(X509_POLICY_LEVEL *curr,\n                              const X509_POLICY_CACHE *cache,\n                              const ASN1_OBJECT *id,\n                              X509_POLICY_NODE *node, X509_POLICY_TREE *tree)\n{\n    X509_POLICY_DATA *data;\n\n    if (id == NULL)\n        id = node->data->valid_policy;\n    /*\n     * Create a new node with qualifiers from anyPolicy and id from unmatched\n     * node.\n     */\n    if ((data = policy_data_new(NULL, id, node_critical(node))) == NULL)\n        return 0;\n\n    /* Curr may not have anyPolicy */\n    data->qualifier_set = cache->anyPolicy->qualifier_set;\n    data->flags |= POLICY_DATA_FLAG_SHARED_QUALIFIERS;\n    if (level_add_node(curr, data, node, tree) == NULL) {\n        policy_data_free(data);\n        return 0;\n    }\n    return 1;\n}",
        "func": "static int tree_add_unmatched(X509_POLICY_LEVEL *curr,\n                              const X509_POLICY_CACHE *cache,\n                              const ASN1_OBJECT *id,\n                              X509_POLICY_NODE *node, X509_POLICY_TREE *tree)\n{\n    X509_POLICY_DATA *data;\n\n    if (id == NULL)\n        id = node->data->valid_policy;\n    /*\n     * Create a new node with qualifiers from anyPolicy and id from unmatched\n     * node.\n     */\n    if ((data = policy_data_new(NULL, id, node_critical(node))) == NULL)\n        return 0;\n\n    /* Curr may not have anyPolicy */\n    data->qualifier_set = cache->anyPolicy->qualifier_set;\n    data->flags |= POLICY_DATA_FLAG_SHARED_QUALIFIERS;\n    if (level_add_node(curr, data, node, tree, 1) == NULL) {\n        policy_data_free(data);\n        return 0;\n    }\n    return 1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -17,7 +17,7 @@\n     /* Curr may not have anyPolicy */\n     data->qualifier_set = cache->anyPolicy->qualifier_set;\n     data->flags |= POLICY_DATA_FLAG_SHARED_QUALIFIERS;\n-    if (level_add_node(curr, data, node, tree) == NULL) {\n+    if (level_add_node(curr, data, node, tree, 1) == NULL) {\n         policy_data_free(data);\n         return 0;\n     }",
        "diff_line_info": {
            "deleted_lines": [
                "    if (level_add_node(curr, data, node, tree) == NULL) {"
            ],
            "added_lines": [
                "    if (level_add_node(curr, data, node, tree, 1) == NULL) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-0464",
        "func_name": "openssl/tree_calculate_user_set",
        "description": "A security vulnerability has been identified in all supported versions\n\nof OpenSSL related to the verification of X.509 certificate chains\nthat include policy constraints.  Attackers may be able to exploit this\nvulnerability by creating a malicious certificate chain that triggers\nexponential use of computational resources, leading to a denial-of-service\n(DoS) attack on affected systems.\n\nPolicy processing is disabled by default but can be enabled by passing\nthe `-policy' argument to the command line utilities or by calling the\n`X509_VERIFY_PARAM_set1_policies()' function.",
        "git_url": "https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=879f7080d7e141f415c79eaa3a8ac4a3dad0348b",
        "commit_title": "",
        "commit_text": "x509: excessive resource use verifying policy constraints  A security vulnerability has been identified in all supported versions of OpenSSL related to the verification of X.509 certificate chains that include policy constraints.  Attackers may be able to exploit this vulnerability by creating a malicious certificate chain that triggers exponential use of computational resources, leading to a denial-of-service (DoS) attack on affected systems.  Fixes CVE-2023-0464  (Merged from https://github.com/openssl/openssl/pull/20569) ",
        "func_before": "static int tree_calculate_user_set(X509_POLICY_TREE *tree,\n                                   STACK_OF(ASN1_OBJECT) *policy_oids,\n                                   STACK_OF(X509_POLICY_NODE) *auth_nodes)\n{\n    int i;\n    X509_POLICY_NODE *node;\n    ASN1_OBJECT *oid;\n    X509_POLICY_NODE *anyPolicy;\n    X509_POLICY_DATA *extra;\n\n    /*\n     * Check if anyPolicy present in authority constrained policy set: this\n     * will happen if it is a leaf node.\n     */\n    if (sk_ASN1_OBJECT_num(policy_oids) <= 0)\n        return 1;\n\n    anyPolicy = tree->levels[tree->nlevel - 1].anyPolicy;\n\n    for (i = 0; i < sk_ASN1_OBJECT_num(policy_oids); i++) {\n        oid = sk_ASN1_OBJECT_value(policy_oids, i);\n        if (OBJ_obj2nid(oid) == NID_any_policy) {\n            tree->flags |= POLICY_FLAG_ANY_POLICY;\n            return 1;\n        }\n    }\n\n    for (i = 0; i < sk_ASN1_OBJECT_num(policy_oids); i++) {\n        oid = sk_ASN1_OBJECT_value(policy_oids, i);\n        node = tree_find_sk(auth_nodes, oid);\n        if (!node) {\n            if (!anyPolicy)\n                continue;\n            /*\n             * Create a new node with policy ID from user set and qualifiers\n             * from anyPolicy.\n             */\n            extra = policy_data_new(NULL, oid, node_critical(anyPolicy));\n            if (extra == NULL)\n                return 0;\n            extra->qualifier_set = anyPolicy->data->qualifier_set;\n            extra->flags = POLICY_DATA_FLAG_SHARED_QUALIFIERS\n                | POLICY_DATA_FLAG_EXTRA_NODE;\n            node = level_add_node(NULL, extra, anyPolicy->parent, tree);\n        }\n        if (!tree->user_policies) {\n            tree->user_policies = sk_X509_POLICY_NODE_new_null();\n            if (!tree->user_policies)\n                return 1;\n        }\n        if (!sk_X509_POLICY_NODE_push(tree->user_policies, node))\n            return 0;\n    }\n    return 1;\n}",
        "func": "static int tree_calculate_user_set(X509_POLICY_TREE *tree,\n                                   STACK_OF(ASN1_OBJECT) *policy_oids,\n                                   STACK_OF(X509_POLICY_NODE) *auth_nodes)\n{\n    int i;\n    X509_POLICY_NODE *node;\n    ASN1_OBJECT *oid;\n    X509_POLICY_NODE *anyPolicy;\n    X509_POLICY_DATA *extra;\n\n    /*\n     * Check if anyPolicy present in authority constrained policy set: this\n     * will happen if it is a leaf node.\n     */\n    if (sk_ASN1_OBJECT_num(policy_oids) <= 0)\n        return 1;\n\n    anyPolicy = tree->levels[tree->nlevel - 1].anyPolicy;\n\n    for (i = 0; i < sk_ASN1_OBJECT_num(policy_oids); i++) {\n        oid = sk_ASN1_OBJECT_value(policy_oids, i);\n        if (OBJ_obj2nid(oid) == NID_any_policy) {\n            tree->flags |= POLICY_FLAG_ANY_POLICY;\n            return 1;\n        }\n    }\n\n    for (i = 0; i < sk_ASN1_OBJECT_num(policy_oids); i++) {\n        oid = sk_ASN1_OBJECT_value(policy_oids, i);\n        node = tree_find_sk(auth_nodes, oid);\n        if (!node) {\n            if (!anyPolicy)\n                continue;\n            /*\n             * Create a new node with policy ID from user set and qualifiers\n             * from anyPolicy.\n             */\n            extra = policy_data_new(NULL, oid, node_critical(anyPolicy));\n            if (extra == NULL)\n                return 0;\n            extra->qualifier_set = anyPolicy->data->qualifier_set;\n            extra->flags = POLICY_DATA_FLAG_SHARED_QUALIFIERS\n                | POLICY_DATA_FLAG_EXTRA_NODE;\n            node = level_add_node(NULL, extra, anyPolicy->parent, tree, 1);\n        }\n        if (!tree->user_policies) {\n            tree->user_policies = sk_X509_POLICY_NODE_new_null();\n            if (!tree->user_policies)\n                return 1;\n        }\n        if (!sk_X509_POLICY_NODE_push(tree->user_policies, node))\n            return 0;\n    }\n    return 1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -41,7 +41,7 @@\n             extra->qualifier_set = anyPolicy->data->qualifier_set;\n             extra->flags = POLICY_DATA_FLAG_SHARED_QUALIFIERS\n                 | POLICY_DATA_FLAG_EXTRA_NODE;\n-            node = level_add_node(NULL, extra, anyPolicy->parent, tree);\n+            node = level_add_node(NULL, extra, anyPolicy->parent, tree, 1);\n         }\n         if (!tree->user_policies) {\n             tree->user_policies = sk_X509_POLICY_NODE_new_null();",
        "diff_line_info": {
            "deleted_lines": [
                "            node = level_add_node(NULL, extra, anyPolicy->parent, tree);"
            ],
            "added_lines": [
                "            node = level_add_node(NULL, extra, anyPolicy->parent, tree, 1);"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-0464",
        "func_name": "openssl/level_add_node",
        "description": "A security vulnerability has been identified in all supported versions\n\nof OpenSSL related to the verification of X.509 certificate chains\nthat include policy constraints.  Attackers may be able to exploit this\nvulnerability by creating a malicious certificate chain that triggers\nexponential use of computational resources, leading to a denial-of-service\n(DoS) attack on affected systems.\n\nPolicy processing is disabled by default but can be enabled by passing\nthe `-policy' argument to the command line utilities or by calling the\n`X509_VERIFY_PARAM_set1_policies()' function.",
        "git_url": "https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=879f7080d7e141f415c79eaa3a8ac4a3dad0348b",
        "commit_title": "",
        "commit_text": "x509: excessive resource use verifying policy constraints  A security vulnerability has been identified in all supported versions of OpenSSL related to the verification of X.509 certificate chains that include policy constraints.  Attackers may be able to exploit this vulnerability by creating a malicious certificate chain that triggers exponential use of computational resources, leading to a denial-of-service (DoS) attack on affected systems.  Fixes CVE-2023-0464  (Merged from https://github.com/openssl/openssl/pull/20569) ",
        "func_before": "X509_POLICY_NODE *level_add_node(X509_POLICY_LEVEL *level,\n                                 X509_POLICY_DATA *data,\n                                 X509_POLICY_NODE *parent,\n                                 X509_POLICY_TREE *tree)\n{\n    X509_POLICY_NODE *node;\n\n    node = OPENSSL_zalloc(sizeof(*node));\n    if (node == NULL) {\n        X509V3err(X509V3_F_LEVEL_ADD_NODE, ERR_R_MALLOC_FAILURE);\n        return NULL;\n    }\n    node->data = data;\n    node->parent = parent;\n    if (level) {\n        if (OBJ_obj2nid(data->valid_policy) == NID_any_policy) {\n            if (level->anyPolicy)\n                goto node_error;\n            level->anyPolicy = node;\n        } else {\n\n            if (level->nodes == NULL)\n                level->nodes = policy_node_cmp_new();\n            if (level->nodes == NULL) {\n                X509V3err(X509V3_F_LEVEL_ADD_NODE, ERR_R_MALLOC_FAILURE);\n                goto node_error;\n            }\n            if (!sk_X509_POLICY_NODE_push(level->nodes, node)) {\n                X509V3err(X509V3_F_LEVEL_ADD_NODE, ERR_R_MALLOC_FAILURE);\n                goto node_error;\n            }\n        }\n    }\n\n    if (tree) {\n        if (tree->extra_data == NULL)\n            tree->extra_data = sk_X509_POLICY_DATA_new_null();\n        if (tree->extra_data == NULL){\n            X509V3err(X509V3_F_LEVEL_ADD_NODE, ERR_R_MALLOC_FAILURE);\n            goto node_error;\n        }\n        if (!sk_X509_POLICY_DATA_push(tree->extra_data, data)) {\n            X509V3err(X509V3_F_LEVEL_ADD_NODE, ERR_R_MALLOC_FAILURE);\n            goto node_error;\n        }\n    }\n\n    if (parent)\n        parent->nchild++;\n\n    return node;\n\n node_error:\n    policy_node_free(node);\n    return NULL;\n}",
        "func": "X509_POLICY_NODE *level_add_node(X509_POLICY_LEVEL *level,\n                                 X509_POLICY_DATA *data,\n                                 X509_POLICY_NODE *parent,\n                                 X509_POLICY_TREE *tree,\n                                 int extra_data)\n{\n    X509_POLICY_NODE *node;\n\n    /* Verify that the tree isn't too large.  This mitigates CVE-2023-0464 */\n    if (tree->node_maximum > 0 && tree->node_count >= tree->node_maximum)\n        return NULL;\n\n    node = OPENSSL_zalloc(sizeof(*node));\n    if (node == NULL) {\n        X509V3err(X509V3_F_LEVEL_ADD_NODE, ERR_R_MALLOC_FAILURE);\n        return NULL;\n    }\n    node->data = data;\n    node->parent = parent;\n    if (level != NULL) {\n        if (OBJ_obj2nid(data->valid_policy) == NID_any_policy) {\n            if (level->anyPolicy)\n                goto node_error;\n            level->anyPolicy = node;\n        } else {\n\n            if (level->nodes == NULL)\n                level->nodes = policy_node_cmp_new();\n            if (level->nodes == NULL) {\n                X509V3err(X509V3_F_LEVEL_ADD_NODE, ERR_R_MALLOC_FAILURE);\n                goto node_error;\n            }\n            if (!sk_X509_POLICY_NODE_push(level->nodes, node)) {\n                X509V3err(X509V3_F_LEVEL_ADD_NODE, ERR_R_MALLOC_FAILURE);\n                goto node_error;\n            }\n        }\n    }\n\n    if (extra_data) {\n        if (tree->extra_data == NULL)\n            tree->extra_data = sk_X509_POLICY_DATA_new_null();\n        if (tree->extra_data == NULL){\n            X509V3err(X509V3_F_LEVEL_ADD_NODE, ERR_R_MALLOC_FAILURE);\n            goto node_error;\n        }\n        if (!sk_X509_POLICY_DATA_push(tree->extra_data, data)) {\n            X509V3err(X509V3_F_LEVEL_ADD_NODE, ERR_R_MALLOC_FAILURE);\n            goto node_error;\n        }\n    }\n\n    tree->node_count++;\n    if (parent)\n        parent->nchild++;\n\n    return node;\n\n node_error:\n    policy_node_free(node);\n    return NULL;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,9 +1,14 @@\n X509_POLICY_NODE *level_add_node(X509_POLICY_LEVEL *level,\n                                  X509_POLICY_DATA *data,\n                                  X509_POLICY_NODE *parent,\n-                                 X509_POLICY_TREE *tree)\n+                                 X509_POLICY_TREE *tree,\n+                                 int extra_data)\n {\n     X509_POLICY_NODE *node;\n+\n+    /* Verify that the tree isn't too large.  This mitigates CVE-2023-0464 */\n+    if (tree->node_maximum > 0 && tree->node_count >= tree->node_maximum)\n+        return NULL;\n \n     node = OPENSSL_zalloc(sizeof(*node));\n     if (node == NULL) {\n@@ -12,7 +17,7 @@\n     }\n     node->data = data;\n     node->parent = parent;\n-    if (level) {\n+    if (level != NULL) {\n         if (OBJ_obj2nid(data->valid_policy) == NID_any_policy) {\n             if (level->anyPolicy)\n                 goto node_error;\n@@ -32,7 +37,7 @@\n         }\n     }\n \n-    if (tree) {\n+    if (extra_data) {\n         if (tree->extra_data == NULL)\n             tree->extra_data = sk_X509_POLICY_DATA_new_null();\n         if (tree->extra_data == NULL){\n@@ -45,6 +50,7 @@\n         }\n     }\n \n+    tree->node_count++;\n     if (parent)\n         parent->nchild++;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "                                 X509_POLICY_TREE *tree)",
                "    if (level) {",
                "    if (tree) {"
            ],
            "added_lines": [
                "                                 X509_POLICY_TREE *tree,",
                "                                 int extra_data)",
                "",
                "    /* Verify that the tree isn't too large.  This mitigates CVE-2023-0464 */",
                "    if (tree->node_maximum > 0 && tree->node_count >= tree->node_maximum)",
                "        return NULL;",
                "    if (level != NULL) {",
                "    if (extra_data) {",
                "    tree->node_count++;"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-0464",
        "func_name": "openssl/ossl_policy_level_add_node",
        "description": "A security vulnerability has been identified in all supported versions\n\nof OpenSSL related to the verification of X.509 certificate chains\nthat include policy constraints.  Attackers may be able to exploit this\nvulnerability by creating a malicious certificate chain that triggers\nexponential use of computational resources, leading to a denial-of-service\n(DoS) attack on affected systems.\n\nPolicy processing is disabled by default but can be enabled by passing\nthe `-policy' argument to the command line utilities or by calling the\n`X509_VERIFY_PARAM_set1_policies()' function.",
        "git_url": "https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=959c59c7a0164117e7f8366466a32bb1f8d77ff1",
        "commit_title": "",
        "commit_text": "x509: excessive resource use verifying policy constraints  A security vulnerability has been identified in all supported versions of OpenSSL related to the verification of X.509 certificate chains that include policy constraints.  Attackers may be able to exploit this vulnerability by creating a malicious certificate chain that triggers exponential use of computational resources, leading to a denial-of-service (DoS) attack on affected systems.  Fixes CVE-2023-0464  (Merged from https://github.com/openssl/openssl/pull/20568) ",
        "func_before": "X509_POLICY_NODE *ossl_policy_level_add_node(X509_POLICY_LEVEL *level,\n                                             X509_POLICY_DATA *data,\n                                             X509_POLICY_NODE *parent,\n                                             X509_POLICY_TREE *tree)\n{\n    X509_POLICY_NODE *node;\n\n    node = OPENSSL_zalloc(sizeof(*node));\n    if (node == NULL) {\n        ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);\n        return NULL;\n    }\n    node->data = data;\n    node->parent = parent;\n    if (level) {\n        if (OBJ_obj2nid(data->valid_policy) == NID_any_policy) {\n            if (level->anyPolicy)\n                goto node_error;\n            level->anyPolicy = node;\n        } else {\n\n            if (level->nodes == NULL)\n                level->nodes = ossl_policy_node_cmp_new();\n            if (level->nodes == NULL) {\n                ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);\n                goto node_error;\n            }\n            if (!sk_X509_POLICY_NODE_push(level->nodes, node)) {\n                ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);\n                goto node_error;\n            }\n        }\n    }\n\n    if (tree) {\n        if (tree->extra_data == NULL)\n            tree->extra_data = sk_X509_POLICY_DATA_new_null();\n        if (tree->extra_data == NULL){\n            ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);\n            goto node_error;\n        }\n        if (!sk_X509_POLICY_DATA_push(tree->extra_data, data)) {\n            ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);\n            goto node_error;\n        }\n    }\n\n    if (parent)\n        parent->nchild++;\n\n    return node;\n\n node_error:\n    ossl_policy_node_free(node);\n    return NULL;\n}",
        "func": "X509_POLICY_NODE *ossl_policy_level_add_node(X509_POLICY_LEVEL *level,\n                                             X509_POLICY_DATA *data,\n                                             X509_POLICY_NODE *parent,\n                                             X509_POLICY_TREE *tree,\n                                             int extra_data)\n{\n    X509_POLICY_NODE *node;\n\n    /* Verify that the tree isn't too large.  This mitigates CVE-2023-0464 */\n    if (tree->node_maximum > 0 && tree->node_count >= tree->node_maximum)\n        return NULL;\n\n    node = OPENSSL_zalloc(sizeof(*node));\n    if (node == NULL) {\n        ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);\n        return NULL;\n    }\n    node->data = data;\n    node->parent = parent;\n    if (level != NULL) {\n        if (OBJ_obj2nid(data->valid_policy) == NID_any_policy) {\n            if (level->anyPolicy)\n                goto node_error;\n            level->anyPolicy = node;\n        } else {\n\n            if (level->nodes == NULL)\n                level->nodes = ossl_policy_node_cmp_new();\n            if (level->nodes == NULL) {\n                ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);\n                goto node_error;\n            }\n            if (!sk_X509_POLICY_NODE_push(level->nodes, node)) {\n                ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);\n                goto node_error;\n            }\n        }\n    }\n\n    if (extra_data) {\n        if (tree->extra_data == NULL)\n            tree->extra_data = sk_X509_POLICY_DATA_new_null();\n        if (tree->extra_data == NULL){\n            ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);\n            goto node_error;\n        }\n        if (!sk_X509_POLICY_DATA_push(tree->extra_data, data)) {\n            ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);\n            goto node_error;\n        }\n    }\n\n    tree->node_count++;\n    if (parent)\n        parent->nchild++;\n\n    return node;\n\n node_error:\n    ossl_policy_node_free(node);\n    return NULL;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,9 +1,14 @@\n X509_POLICY_NODE *ossl_policy_level_add_node(X509_POLICY_LEVEL *level,\n                                              X509_POLICY_DATA *data,\n                                              X509_POLICY_NODE *parent,\n-                                             X509_POLICY_TREE *tree)\n+                                             X509_POLICY_TREE *tree,\n+                                             int extra_data)\n {\n     X509_POLICY_NODE *node;\n+\n+    /* Verify that the tree isn't too large.  This mitigates CVE-2023-0464 */\n+    if (tree->node_maximum > 0 && tree->node_count >= tree->node_maximum)\n+        return NULL;\n \n     node = OPENSSL_zalloc(sizeof(*node));\n     if (node == NULL) {\n@@ -12,7 +17,7 @@\n     }\n     node->data = data;\n     node->parent = parent;\n-    if (level) {\n+    if (level != NULL) {\n         if (OBJ_obj2nid(data->valid_policy) == NID_any_policy) {\n             if (level->anyPolicy)\n                 goto node_error;\n@@ -32,7 +37,7 @@\n         }\n     }\n \n-    if (tree) {\n+    if (extra_data) {\n         if (tree->extra_data == NULL)\n             tree->extra_data = sk_X509_POLICY_DATA_new_null();\n         if (tree->extra_data == NULL){\n@@ -45,6 +50,7 @@\n         }\n     }\n \n+    tree->node_count++;\n     if (parent)\n         parent->nchild++;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "                                             X509_POLICY_TREE *tree)",
                "    if (level) {",
                "    if (tree) {"
            ],
            "added_lines": [
                "                                             X509_POLICY_TREE *tree,",
                "                                             int extra_data)",
                "",
                "    /* Verify that the tree isn't too large.  This mitigates CVE-2023-0464 */",
                "    if (tree->node_maximum > 0 && tree->node_count >= tree->node_maximum)",
                "        return NULL;",
                "    if (level != NULL) {",
                "    if (extra_data) {",
                "    tree->node_count++;"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-0464",
        "func_name": "openssl/tree_init",
        "description": "A security vulnerability has been identified in all supported versions\n\nof OpenSSL related to the verification of X.509 certificate chains\nthat include policy constraints.  Attackers may be able to exploit this\nvulnerability by creating a malicious certificate chain that triggers\nexponential use of computational resources, leading to a denial-of-service\n(DoS) attack on affected systems.\n\nPolicy processing is disabled by default but can be enabled by passing\nthe `-policy' argument to the command line utilities or by calling the\n`X509_VERIFY_PARAM_set1_policies()' function.",
        "git_url": "https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=959c59c7a0164117e7f8366466a32bb1f8d77ff1",
        "commit_title": "",
        "commit_text": "x509: excessive resource use verifying policy constraints  A security vulnerability has been identified in all supported versions of OpenSSL related to the verification of X.509 certificate chains that include policy constraints.  Attackers may be able to exploit this vulnerability by creating a malicious certificate chain that triggers exponential use of computational resources, leading to a denial-of-service (DoS) attack on affected systems.  Fixes CVE-2023-0464  (Merged from https://github.com/openssl/openssl/pull/20568) ",
        "func_before": "static int tree_init(X509_POLICY_TREE **ptree, STACK_OF(X509) *certs,\n                     unsigned int flags)\n{\n    X509_POLICY_TREE *tree;\n    X509_POLICY_LEVEL *level;\n    const X509_POLICY_CACHE *cache;\n    X509_POLICY_DATA *data = NULL;\n    int ret = X509_PCY_TREE_VALID;\n    int n = sk_X509_num(certs) - 1; /* RFC5280 paths omit the TA */\n    int explicit_policy = (flags & X509_V_FLAG_EXPLICIT_POLICY) ? 0 : n+1;\n    int any_skip = (flags & X509_V_FLAG_INHIBIT_ANY) ? 0 : n+1;\n    int map_skip = (flags & X509_V_FLAG_INHIBIT_MAP) ? 0 : n+1;\n    int i;\n\n    *ptree = NULL;\n\n    /* Can't do anything with just a trust anchor */\n    if (n == 0)\n        return X509_PCY_TREE_EMPTY;\n\n    /*\n     * First setup the policy cache in all n non-TA certificates, this will be\n     * used in X509_verify_cert() which will invoke the verify callback for all\n     * certificates with invalid policy extensions.\n     */\n    for (i = n - 1; i >= 0; i--) {\n        X509 *x = sk_X509_value(certs, i);\n\n        /* Call for side-effect of computing hash and caching extensions */\n        X509_check_purpose(x, -1, 0);\n\n        /* If cache is NULL, likely ENOMEM: return immediately */\n        if (ossl_policy_cache_set(x) == NULL)\n            return X509_PCY_TREE_INTERNAL;\n    }\n\n    /*\n     * At this point check for invalid policies and required explicit policy.\n     * Note that the explicit_policy counter is a count-down to zero, with the\n     * requirement kicking in if and once it does that.  The counter is\n     * decremented for every non-self-issued certificate in the path, but may\n     * be further reduced by policy constraints in a non-leaf certificate.\n     *\n     * The ultimate policy set is the intersection of all the policies along\n     * the path, if we hit a certificate with an empty policy set, and explicit\n     * policy is required we're done.\n     */\n    for (i = n - 1;\n         i >= 0 && (explicit_policy > 0 || (ret & X509_PCY_TREE_EMPTY) == 0);\n         i--) {\n        X509 *x = sk_X509_value(certs, i);\n        uint32_t ex_flags = X509_get_extension_flags(x);\n\n        /* All the policies are already cached, we can return early */\n        if (ex_flags & EXFLAG_INVALID_POLICY)\n            return X509_PCY_TREE_INVALID;\n\n        /* Access the cache which we now know exists */\n        cache = ossl_policy_cache_set(x);\n\n        if ((ret & X509_PCY_TREE_VALID) && cache->data == NULL)\n            ret = X509_PCY_TREE_EMPTY;\n        if (explicit_policy > 0) {\n            if (!(ex_flags & EXFLAG_SI))\n                explicit_policy--;\n            if ((cache->explicit_skip >= 0)\n                && (cache->explicit_skip < explicit_policy))\n                explicit_policy = cache->explicit_skip;\n        }\n    }\n\n    if (explicit_policy == 0)\n        ret |= X509_PCY_TREE_EXPLICIT;\n    if ((ret & X509_PCY_TREE_VALID) == 0)\n        return ret;\n\n    /* If we get this far initialize the tree */\n    if ((tree = OPENSSL_zalloc(sizeof(*tree))) == NULL) {\n        ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);\n        return X509_PCY_TREE_INTERNAL;\n    }\n\n    /*\n     * http://tools.ietf.org/html/rfc5280#section-6.1.2, figure 3.\n     *\n     * The top level is implicitly for the trust anchor with valid expected\n     * policies of anyPolicy.  (RFC 5280 has the TA at depth 0 and the leaf at\n     * depth n, we have the leaf at depth 0 and the TA at depth n).\n     */\n    if ((tree->levels = OPENSSL_zalloc(sizeof(*tree->levels)*(n+1))) == NULL) {\n        OPENSSL_free(tree);\n        ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);\n        return X509_PCY_TREE_INTERNAL;\n    }\n    tree->nlevel = n+1;\n    level = tree->levels;\n    if ((data = ossl_policy_data_new(NULL,\n                                     OBJ_nid2obj(NID_any_policy), 0)) == NULL)\n        goto bad_tree;\n    if (ossl_policy_level_add_node(level, data, NULL, tree) == NULL) {\n        ossl_policy_data_free(data);\n        goto bad_tree;\n    }\n\n    /*\n     * In this pass initialize all the tree levels and whether anyPolicy and\n     * policy mapping are inhibited at each level.\n     */\n    for (i = n - 1; i >= 0; i--) {\n        X509 *x = sk_X509_value(certs, i);\n        uint32_t ex_flags = X509_get_extension_flags(x);\n\n        /* Access the cache which we now know exists */\n        cache = ossl_policy_cache_set(x);\n\n        X509_up_ref(x);\n        (++level)->cert = x;\n\n        if (!cache->anyPolicy)\n            level->flags |= X509_V_FLAG_INHIBIT_ANY;\n\n        /* Determine inhibit any and inhibit map flags */\n        if (any_skip == 0) {\n            /*\n             * Any matching allowed only if certificate is self issued and not\n             * the last in the chain.\n             */\n            if (!(ex_flags & EXFLAG_SI) || (i == 0))\n                level->flags |= X509_V_FLAG_INHIBIT_ANY;\n        } else {\n            if (!(ex_flags & EXFLAG_SI))\n                any_skip--;\n            if ((cache->any_skip >= 0) && (cache->any_skip < any_skip))\n                any_skip = cache->any_skip;\n        }\n\n        if (map_skip == 0)\n            level->flags |= X509_V_FLAG_INHIBIT_MAP;\n        else {\n            if (!(ex_flags & EXFLAG_SI))\n                map_skip--;\n            if ((cache->map_skip >= 0) && (cache->map_skip < map_skip))\n                map_skip = cache->map_skip;\n        }\n    }\n\n    *ptree = tree;\n    return ret;\n\n bad_tree:\n    X509_policy_tree_free(tree);\n    return X509_PCY_TREE_INTERNAL;\n}",
        "func": "static int tree_init(X509_POLICY_TREE **ptree, STACK_OF(X509) *certs,\n                     unsigned int flags)\n{\n    X509_POLICY_TREE *tree;\n    X509_POLICY_LEVEL *level;\n    const X509_POLICY_CACHE *cache;\n    X509_POLICY_DATA *data = NULL;\n    int ret = X509_PCY_TREE_VALID;\n    int n = sk_X509_num(certs) - 1; /* RFC5280 paths omit the TA */\n    int explicit_policy = (flags & X509_V_FLAG_EXPLICIT_POLICY) ? 0 : n+1;\n    int any_skip = (flags & X509_V_FLAG_INHIBIT_ANY) ? 0 : n+1;\n    int map_skip = (flags & X509_V_FLAG_INHIBIT_MAP) ? 0 : n+1;\n    int i;\n\n    *ptree = NULL;\n\n    /* Can't do anything with just a trust anchor */\n    if (n == 0)\n        return X509_PCY_TREE_EMPTY;\n\n    /*\n     * First setup the policy cache in all n non-TA certificates, this will be\n     * used in X509_verify_cert() which will invoke the verify callback for all\n     * certificates with invalid policy extensions.\n     */\n    for (i = n - 1; i >= 0; i--) {\n        X509 *x = sk_X509_value(certs, i);\n\n        /* Call for side-effect of computing hash and caching extensions */\n        X509_check_purpose(x, -1, 0);\n\n        /* If cache is NULL, likely ENOMEM: return immediately */\n        if (ossl_policy_cache_set(x) == NULL)\n            return X509_PCY_TREE_INTERNAL;\n    }\n\n    /*\n     * At this point check for invalid policies and required explicit policy.\n     * Note that the explicit_policy counter is a count-down to zero, with the\n     * requirement kicking in if and once it does that.  The counter is\n     * decremented for every non-self-issued certificate in the path, but may\n     * be further reduced by policy constraints in a non-leaf certificate.\n     *\n     * The ultimate policy set is the intersection of all the policies along\n     * the path, if we hit a certificate with an empty policy set, and explicit\n     * policy is required we're done.\n     */\n    for (i = n - 1;\n         i >= 0 && (explicit_policy > 0 || (ret & X509_PCY_TREE_EMPTY) == 0);\n         i--) {\n        X509 *x = sk_X509_value(certs, i);\n        uint32_t ex_flags = X509_get_extension_flags(x);\n\n        /* All the policies are already cached, we can return early */\n        if (ex_flags & EXFLAG_INVALID_POLICY)\n            return X509_PCY_TREE_INVALID;\n\n        /* Access the cache which we now know exists */\n        cache = ossl_policy_cache_set(x);\n\n        if ((ret & X509_PCY_TREE_VALID) && cache->data == NULL)\n            ret = X509_PCY_TREE_EMPTY;\n        if (explicit_policy > 0) {\n            if (!(ex_flags & EXFLAG_SI))\n                explicit_policy--;\n            if ((cache->explicit_skip >= 0)\n                && (cache->explicit_skip < explicit_policy))\n                explicit_policy = cache->explicit_skip;\n        }\n    }\n\n    if (explicit_policy == 0)\n        ret |= X509_PCY_TREE_EXPLICIT;\n    if ((ret & X509_PCY_TREE_VALID) == 0)\n        return ret;\n\n    /* If we get this far initialize the tree */\n    if ((tree = OPENSSL_zalloc(sizeof(*tree))) == NULL) {\n        ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);\n        return X509_PCY_TREE_INTERNAL;\n    }\n\n    /* Limit the growth of the tree to mitigate CVE-2023-0464 */\n    tree->node_maximum = OPENSSL_POLICY_TREE_NODES_MAX;\n\n    /*\n     * http://tools.ietf.org/html/rfc5280#section-6.1.2, figure 3.\n     *\n     * The top level is implicitly for the trust anchor with valid expected\n     * policies of anyPolicy.  (RFC 5280 has the TA at depth 0 and the leaf at\n     * depth n, we have the leaf at depth 0 and the TA at depth n).\n     */\n    if ((tree->levels = OPENSSL_zalloc(sizeof(*tree->levels)*(n+1))) == NULL) {\n        OPENSSL_free(tree);\n        ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);\n        return X509_PCY_TREE_INTERNAL;\n    }\n    tree->nlevel = n+1;\n    level = tree->levels;\n    if ((data = ossl_policy_data_new(NULL,\n                                     OBJ_nid2obj(NID_any_policy), 0)) == NULL)\n        goto bad_tree;\n    if (ossl_policy_level_add_node(level, data, NULL, tree, 1) == NULL) {\n        ossl_policy_data_free(data);\n        goto bad_tree;\n    }\n\n    /*\n     * In this pass initialize all the tree levels and whether anyPolicy and\n     * policy mapping are inhibited at each level.\n     */\n    for (i = n - 1; i >= 0; i--) {\n        X509 *x = sk_X509_value(certs, i);\n        uint32_t ex_flags = X509_get_extension_flags(x);\n\n        /* Access the cache which we now know exists */\n        cache = ossl_policy_cache_set(x);\n\n        X509_up_ref(x);\n        (++level)->cert = x;\n\n        if (!cache->anyPolicy)\n            level->flags |= X509_V_FLAG_INHIBIT_ANY;\n\n        /* Determine inhibit any and inhibit map flags */\n        if (any_skip == 0) {\n            /*\n             * Any matching allowed only if certificate is self issued and not\n             * the last in the chain.\n             */\n            if (!(ex_flags & EXFLAG_SI) || (i == 0))\n                level->flags |= X509_V_FLAG_INHIBIT_ANY;\n        } else {\n            if (!(ex_flags & EXFLAG_SI))\n                any_skip--;\n            if ((cache->any_skip >= 0) && (cache->any_skip < any_skip))\n                any_skip = cache->any_skip;\n        }\n\n        if (map_skip == 0)\n            level->flags |= X509_V_FLAG_INHIBIT_MAP;\n        else {\n            if (!(ex_flags & EXFLAG_SI))\n                map_skip--;\n            if ((cache->map_skip >= 0) && (cache->map_skip < map_skip))\n                map_skip = cache->map_skip;\n        }\n    }\n\n    *ptree = tree;\n    return ret;\n\n bad_tree:\n    X509_policy_tree_free(tree);\n    return X509_PCY_TREE_INTERNAL;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -80,6 +80,9 @@\n         return X509_PCY_TREE_INTERNAL;\n     }\n \n+    /* Limit the growth of the tree to mitigate CVE-2023-0464 */\n+    tree->node_maximum = OPENSSL_POLICY_TREE_NODES_MAX;\n+\n     /*\n      * http://tools.ietf.org/html/rfc5280#section-6.1.2, figure 3.\n      *\n@@ -97,7 +100,7 @@\n     if ((data = ossl_policy_data_new(NULL,\n                                      OBJ_nid2obj(NID_any_policy), 0)) == NULL)\n         goto bad_tree;\n-    if (ossl_policy_level_add_node(level, data, NULL, tree) == NULL) {\n+    if (ossl_policy_level_add_node(level, data, NULL, tree, 1) == NULL) {\n         ossl_policy_data_free(data);\n         goto bad_tree;\n     }",
        "diff_line_info": {
            "deleted_lines": [
                "    if (ossl_policy_level_add_node(level, data, NULL, tree) == NULL) {"
            ],
            "added_lines": [
                "    /* Limit the growth of the tree to mitigate CVE-2023-0464 */",
                "    tree->node_maximum = OPENSSL_POLICY_TREE_NODES_MAX;",
                "",
                "    if (ossl_policy_level_add_node(level, data, NULL, tree, 1) == NULL) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-0464",
        "func_name": "openssl/tree_evaluate",
        "description": "A security vulnerability has been identified in all supported versions\n\nof OpenSSL related to the verification of X.509 certificate chains\nthat include policy constraints.  Attackers may be able to exploit this\nvulnerability by creating a malicious certificate chain that triggers\nexponential use of computational resources, leading to a denial-of-service\n(DoS) attack on affected systems.\n\nPolicy processing is disabled by default but can be enabled by passing\nthe `-policy' argument to the command line utilities or by calling the\n`X509_VERIFY_PARAM_set1_policies()' function.",
        "git_url": "https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=959c59c7a0164117e7f8366466a32bb1f8d77ff1",
        "commit_title": "",
        "commit_text": "x509: excessive resource use verifying policy constraints  A security vulnerability has been identified in all supported versions of OpenSSL related to the verification of X.509 certificate chains that include policy constraints.  Attackers may be able to exploit this vulnerability by creating a malicious certificate chain that triggers exponential use of computational resources, leading to a denial-of-service (DoS) attack on affected systems.  Fixes CVE-2023-0464  (Merged from https://github.com/openssl/openssl/pull/20568) ",
        "func_before": "static int tree_evaluate(X509_POLICY_TREE *tree)\n{\n    int ret, i;\n    X509_POLICY_LEVEL *curr = tree->levels + 1;\n    const X509_POLICY_CACHE *cache;\n\n    for (i = 1; i < tree->nlevel; i++, curr++) {\n        cache = ossl_policy_cache_set(curr->cert);\n        if (!tree_link_nodes(curr, cache))\n            return X509_PCY_TREE_INTERNAL;\n\n        if (!(curr->flags & X509_V_FLAG_INHIBIT_ANY)\n            && !tree_link_any(curr, cache, tree))\n            return X509_PCY_TREE_INTERNAL;\n        TREE_PRINT(\"before tree_prune()\", tree, curr);\n        ret = tree_prune(tree, curr);\n        if (ret != X509_PCY_TREE_VALID)\n            return ret;\n    }\n    return X509_PCY_TREE_VALID;\n}",
        "func": "static int tree_evaluate(X509_POLICY_TREE *tree)\n{\n    int ret, i;\n    X509_POLICY_LEVEL *curr = tree->levels + 1;\n    const X509_POLICY_CACHE *cache;\n\n    for (i = 1; i < tree->nlevel; i++, curr++) {\n        cache = ossl_policy_cache_set(curr->cert);\n        if (!tree_link_nodes(curr, cache, tree))\n            return X509_PCY_TREE_INTERNAL;\n\n        if (!(curr->flags & X509_V_FLAG_INHIBIT_ANY)\n            && !tree_link_any(curr, cache, tree))\n            return X509_PCY_TREE_INTERNAL;\n        TREE_PRINT(\"before tree_prune()\", tree, curr);\n        ret = tree_prune(tree, curr);\n        if (ret != X509_PCY_TREE_VALID)\n            return ret;\n    }\n    return X509_PCY_TREE_VALID;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,7 +6,7 @@\n \n     for (i = 1; i < tree->nlevel; i++, curr++) {\n         cache = ossl_policy_cache_set(curr->cert);\n-        if (!tree_link_nodes(curr, cache))\n+        if (!tree_link_nodes(curr, cache, tree))\n             return X509_PCY_TREE_INTERNAL;\n \n         if (!(curr->flags & X509_V_FLAG_INHIBIT_ANY)",
        "diff_line_info": {
            "deleted_lines": [
                "        if (!tree_link_nodes(curr, cache))"
            ],
            "added_lines": [
                "        if (!tree_link_nodes(curr, cache, tree))"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-0464",
        "func_name": "openssl/tree_link_matching_nodes",
        "description": "A security vulnerability has been identified in all supported versions\n\nof OpenSSL related to the verification of X.509 certificate chains\nthat include policy constraints.  Attackers may be able to exploit this\nvulnerability by creating a malicious certificate chain that triggers\nexponential use of computational resources, leading to a denial-of-service\n(DoS) attack on affected systems.\n\nPolicy processing is disabled by default but can be enabled by passing\nthe `-policy' argument to the command line utilities or by calling the\n`X509_VERIFY_PARAM_set1_policies()' function.",
        "git_url": "https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=959c59c7a0164117e7f8366466a32bb1f8d77ff1",
        "commit_title": "",
        "commit_text": "x509: excessive resource use verifying policy constraints  A security vulnerability has been identified in all supported versions of OpenSSL related to the verification of X.509 certificate chains that include policy constraints.  Attackers may be able to exploit this vulnerability by creating a malicious certificate chain that triggers exponential use of computational resources, leading to a denial-of-service (DoS) attack on affected systems.  Fixes CVE-2023-0464  (Merged from https://github.com/openssl/openssl/pull/20568) ",
        "func_before": "static int tree_link_matching_nodes(X509_POLICY_LEVEL *curr,\n                                    X509_POLICY_DATA *data)\n{\n    X509_POLICY_LEVEL *last = curr - 1;\n    int i, matched = 0;\n\n    /* Iterate through all in nodes linking matches */\n    for (i = 0; i < sk_X509_POLICY_NODE_num(last->nodes); i++) {\n        X509_POLICY_NODE *node = sk_X509_POLICY_NODE_value(last->nodes, i);\n\n        if (ossl_policy_node_match(last, node, data->valid_policy)) {\n            if (ossl_policy_level_add_node(curr, data, node, NULL) == NULL)\n                return 0;\n            matched = 1;\n        }\n    }\n    if (!matched && last->anyPolicy) {\n        if (ossl_policy_level_add_node(curr, data, last->anyPolicy, NULL) == NULL)\n            return 0;\n    }\n    return 1;\n}",
        "func": "static int tree_link_matching_nodes(X509_POLICY_LEVEL *curr,\n                                    X509_POLICY_DATA *data,\n                                    X509_POLICY_TREE *tree)\n{\n    X509_POLICY_LEVEL *last = curr - 1;\n    int i, matched = 0;\n\n    /* Iterate through all in nodes linking matches */\n    for (i = 0; i < sk_X509_POLICY_NODE_num(last->nodes); i++) {\n        X509_POLICY_NODE *node = sk_X509_POLICY_NODE_value(last->nodes, i);\n\n        if (ossl_policy_node_match(last, node, data->valid_policy)) {\n            if (ossl_policy_level_add_node(curr, data, node, tree, 0) == NULL)\n                return 0;\n            matched = 1;\n        }\n    }\n    if (!matched && last->anyPolicy) {\n        if (ossl_policy_level_add_node(curr, data, last->anyPolicy, tree, 0) == NULL)\n            return 0;\n    }\n    return 1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,6 @@\n static int tree_link_matching_nodes(X509_POLICY_LEVEL *curr,\n-                                    X509_POLICY_DATA *data)\n+                                    X509_POLICY_DATA *data,\n+                                    X509_POLICY_TREE *tree)\n {\n     X509_POLICY_LEVEL *last = curr - 1;\n     int i, matched = 0;\n@@ -9,13 +10,13 @@\n         X509_POLICY_NODE *node = sk_X509_POLICY_NODE_value(last->nodes, i);\n \n         if (ossl_policy_node_match(last, node, data->valid_policy)) {\n-            if (ossl_policy_level_add_node(curr, data, node, NULL) == NULL)\n+            if (ossl_policy_level_add_node(curr, data, node, tree, 0) == NULL)\n                 return 0;\n             matched = 1;\n         }\n     }\n     if (!matched && last->anyPolicy) {\n-        if (ossl_policy_level_add_node(curr, data, last->anyPolicy, NULL) == NULL)\n+        if (ossl_policy_level_add_node(curr, data, last->anyPolicy, tree, 0) == NULL)\n             return 0;\n     }\n     return 1;",
        "diff_line_info": {
            "deleted_lines": [
                "                                    X509_POLICY_DATA *data)",
                "            if (ossl_policy_level_add_node(curr, data, node, NULL) == NULL)",
                "        if (ossl_policy_level_add_node(curr, data, last->anyPolicy, NULL) == NULL)"
            ],
            "added_lines": [
                "                                    X509_POLICY_DATA *data,",
                "                                    X509_POLICY_TREE *tree)",
                "            if (ossl_policy_level_add_node(curr, data, node, tree, 0) == NULL)",
                "        if (ossl_policy_level_add_node(curr, data, last->anyPolicy, tree, 0) == NULL)"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-0464",
        "func_name": "openssl/tree_link_any",
        "description": "A security vulnerability has been identified in all supported versions\n\nof OpenSSL related to the verification of X.509 certificate chains\nthat include policy constraints.  Attackers may be able to exploit this\nvulnerability by creating a malicious certificate chain that triggers\nexponential use of computational resources, leading to a denial-of-service\n(DoS) attack on affected systems.\n\nPolicy processing is disabled by default but can be enabled by passing\nthe `-policy' argument to the command line utilities or by calling the\n`X509_VERIFY_PARAM_set1_policies()' function.",
        "git_url": "https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=959c59c7a0164117e7f8366466a32bb1f8d77ff1",
        "commit_title": "",
        "commit_text": "x509: excessive resource use verifying policy constraints  A security vulnerability has been identified in all supported versions of OpenSSL related to the verification of X.509 certificate chains that include policy constraints.  Attackers may be able to exploit this vulnerability by creating a malicious certificate chain that triggers exponential use of computational resources, leading to a denial-of-service (DoS) attack on affected systems.  Fixes CVE-2023-0464  (Merged from https://github.com/openssl/openssl/pull/20568) ",
        "func_before": "static int tree_link_any(X509_POLICY_LEVEL *curr,\n                         const X509_POLICY_CACHE *cache,\n                         X509_POLICY_TREE *tree)\n{\n    int i;\n    X509_POLICY_NODE *node;\n    X509_POLICY_LEVEL *last = curr - 1;\n\n    for (i = 0; i < sk_X509_POLICY_NODE_num(last->nodes); i++) {\n        node = sk_X509_POLICY_NODE_value(last->nodes, i);\n\n        if (!tree_link_unmatched(curr, cache, node, tree))\n            return 0;\n    }\n    /* Finally add link to anyPolicy */\n    if (last->anyPolicy &&\n            ossl_policy_level_add_node(curr, cache->anyPolicy,\n                                       last->anyPolicy, NULL) == NULL)\n        return 0;\n    return 1;\n}",
        "func": "static int tree_link_any(X509_POLICY_LEVEL *curr,\n                         const X509_POLICY_CACHE *cache,\n                         X509_POLICY_TREE *tree)\n{\n    int i;\n    X509_POLICY_NODE *node;\n    X509_POLICY_LEVEL *last = curr - 1;\n\n    for (i = 0; i < sk_X509_POLICY_NODE_num(last->nodes); i++) {\n        node = sk_X509_POLICY_NODE_value(last->nodes, i);\n\n        if (!tree_link_unmatched(curr, cache, node, tree))\n            return 0;\n    }\n    /* Finally add link to anyPolicy */\n    if (last->anyPolicy &&\n            ossl_policy_level_add_node(curr, cache->anyPolicy,\n                                       last->anyPolicy, tree, 0) == NULL)\n        return 0;\n    return 1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -15,7 +15,7 @@\n     /* Finally add link to anyPolicy */\n     if (last->anyPolicy &&\n             ossl_policy_level_add_node(curr, cache->anyPolicy,\n-                                       last->anyPolicy, NULL) == NULL)\n+                                       last->anyPolicy, tree, 0) == NULL)\n         return 0;\n     return 1;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "                                       last->anyPolicy, NULL) == NULL)"
            ],
            "added_lines": [
                "                                       last->anyPolicy, tree, 0) == NULL)"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-0464",
        "func_name": "openssl/tree_link_nodes",
        "description": "A security vulnerability has been identified in all supported versions\n\nof OpenSSL related to the verification of X.509 certificate chains\nthat include policy constraints.  Attackers may be able to exploit this\nvulnerability by creating a malicious certificate chain that triggers\nexponential use of computational resources, leading to a denial-of-service\n(DoS) attack on affected systems.\n\nPolicy processing is disabled by default but can be enabled by passing\nthe `-policy' argument to the command line utilities or by calling the\n`X509_VERIFY_PARAM_set1_policies()' function.",
        "git_url": "https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=959c59c7a0164117e7f8366466a32bb1f8d77ff1",
        "commit_title": "",
        "commit_text": "x509: excessive resource use verifying policy constraints  A security vulnerability has been identified in all supported versions of OpenSSL related to the verification of X.509 certificate chains that include policy constraints.  Attackers may be able to exploit this vulnerability by creating a malicious certificate chain that triggers exponential use of computational resources, leading to a denial-of-service (DoS) attack on affected systems.  Fixes CVE-2023-0464  (Merged from https://github.com/openssl/openssl/pull/20568) ",
        "func_before": "static int tree_link_nodes(X509_POLICY_LEVEL *curr,\n                           const X509_POLICY_CACHE *cache)\n{\n    int i;\n\n    for (i = 0; i < sk_X509_POLICY_DATA_num(cache->data); i++) {\n        X509_POLICY_DATA *data = sk_X509_POLICY_DATA_value(cache->data, i);\n\n        /* Look for matching nodes in previous level */\n        if (!tree_link_matching_nodes(curr, data))\n            return 0;\n    }\n    return 1;\n}",
        "func": "static int tree_link_nodes(X509_POLICY_LEVEL *curr,\n                           const X509_POLICY_CACHE *cache,\n                           X509_POLICY_TREE *tree)\n{\n    int i;\n\n    for (i = 0; i < sk_X509_POLICY_DATA_num(cache->data); i++) {\n        X509_POLICY_DATA *data = sk_X509_POLICY_DATA_value(cache->data, i);\n\n        /* Look for matching nodes in previous level */\n        if (!tree_link_matching_nodes(curr, data, tree))\n            return 0;\n    }\n    return 1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,6 @@\n static int tree_link_nodes(X509_POLICY_LEVEL *curr,\n-                           const X509_POLICY_CACHE *cache)\n+                           const X509_POLICY_CACHE *cache,\n+                           X509_POLICY_TREE *tree)\n {\n     int i;\n \n@@ -7,7 +8,7 @@\n         X509_POLICY_DATA *data = sk_X509_POLICY_DATA_value(cache->data, i);\n \n         /* Look for matching nodes in previous level */\n-        if (!tree_link_matching_nodes(curr, data))\n+        if (!tree_link_matching_nodes(curr, data, tree))\n             return 0;\n     }\n     return 1;",
        "diff_line_info": {
            "deleted_lines": [
                "                           const X509_POLICY_CACHE *cache)",
                "        if (!tree_link_matching_nodes(curr, data))"
            ],
            "added_lines": [
                "                           const X509_POLICY_CACHE *cache,",
                "                           X509_POLICY_TREE *tree)",
                "        if (!tree_link_matching_nodes(curr, data, tree))"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-0464",
        "func_name": "openssl/tree_add_unmatched",
        "description": "A security vulnerability has been identified in all supported versions\n\nof OpenSSL related to the verification of X.509 certificate chains\nthat include policy constraints.  Attackers may be able to exploit this\nvulnerability by creating a malicious certificate chain that triggers\nexponential use of computational resources, leading to a denial-of-service\n(DoS) attack on affected systems.\n\nPolicy processing is disabled by default but can be enabled by passing\nthe `-policy' argument to the command line utilities or by calling the\n`X509_VERIFY_PARAM_set1_policies()' function.",
        "git_url": "https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=959c59c7a0164117e7f8366466a32bb1f8d77ff1",
        "commit_title": "",
        "commit_text": "x509: excessive resource use verifying policy constraints  A security vulnerability has been identified in all supported versions of OpenSSL related to the verification of X.509 certificate chains that include policy constraints.  Attackers may be able to exploit this vulnerability by creating a malicious certificate chain that triggers exponential use of computational resources, leading to a denial-of-service (DoS) attack on affected systems.  Fixes CVE-2023-0464  (Merged from https://github.com/openssl/openssl/pull/20568) ",
        "func_before": "static int tree_add_unmatched(X509_POLICY_LEVEL *curr,\n                              const X509_POLICY_CACHE *cache,\n                              const ASN1_OBJECT *id,\n                              X509_POLICY_NODE *node, X509_POLICY_TREE *tree)\n{\n    X509_POLICY_DATA *data;\n\n    if (id == NULL)\n        id = node->data->valid_policy;\n    /*\n     * Create a new node with qualifiers from anyPolicy and id from unmatched\n     * node.\n     */\n    if ((data = ossl_policy_data_new(NULL, id, node_critical(node))) == NULL)\n        return 0;\n\n    /* Curr may not have anyPolicy */\n    data->qualifier_set = cache->anyPolicy->qualifier_set;\n    data->flags |= POLICY_DATA_FLAG_SHARED_QUALIFIERS;\n    if (ossl_policy_level_add_node(curr, data, node, tree) == NULL) {\n        ossl_policy_data_free(data);\n        return 0;\n    }\n    return 1;\n}",
        "func": "static int tree_add_unmatched(X509_POLICY_LEVEL *curr,\n                              const X509_POLICY_CACHE *cache,\n                              const ASN1_OBJECT *id,\n                              X509_POLICY_NODE *node, X509_POLICY_TREE *tree)\n{\n    X509_POLICY_DATA *data;\n\n    if (id == NULL)\n        id = node->data->valid_policy;\n    /*\n     * Create a new node with qualifiers from anyPolicy and id from unmatched\n     * node.\n     */\n    if ((data = ossl_policy_data_new(NULL, id, node_critical(node))) == NULL)\n        return 0;\n\n    /* Curr may not have anyPolicy */\n    data->qualifier_set = cache->anyPolicy->qualifier_set;\n    data->flags |= POLICY_DATA_FLAG_SHARED_QUALIFIERS;\n    if (ossl_policy_level_add_node(curr, data, node, tree, 1) == NULL) {\n        ossl_policy_data_free(data);\n        return 0;\n    }\n    return 1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -17,7 +17,7 @@\n     /* Curr may not have anyPolicy */\n     data->qualifier_set = cache->anyPolicy->qualifier_set;\n     data->flags |= POLICY_DATA_FLAG_SHARED_QUALIFIERS;\n-    if (ossl_policy_level_add_node(curr, data, node, tree) == NULL) {\n+    if (ossl_policy_level_add_node(curr, data, node, tree, 1) == NULL) {\n         ossl_policy_data_free(data);\n         return 0;\n     }",
        "diff_line_info": {
            "deleted_lines": [
                "    if (ossl_policy_level_add_node(curr, data, node, tree) == NULL) {"
            ],
            "added_lines": [
                "    if (ossl_policy_level_add_node(curr, data, node, tree, 1) == NULL) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-0464",
        "func_name": "openssl/tree_calculate_user_set",
        "description": "A security vulnerability has been identified in all supported versions\n\nof OpenSSL related to the verification of X.509 certificate chains\nthat include policy constraints.  Attackers may be able to exploit this\nvulnerability by creating a malicious certificate chain that triggers\nexponential use of computational resources, leading to a denial-of-service\n(DoS) attack on affected systems.\n\nPolicy processing is disabled by default but can be enabled by passing\nthe `-policy' argument to the command line utilities or by calling the\n`X509_VERIFY_PARAM_set1_policies()' function.",
        "git_url": "https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=959c59c7a0164117e7f8366466a32bb1f8d77ff1",
        "commit_title": "",
        "commit_text": "x509: excessive resource use verifying policy constraints  A security vulnerability has been identified in all supported versions of OpenSSL related to the verification of X.509 certificate chains that include policy constraints.  Attackers may be able to exploit this vulnerability by creating a malicious certificate chain that triggers exponential use of computational resources, leading to a denial-of-service (DoS) attack on affected systems.  Fixes CVE-2023-0464  (Merged from https://github.com/openssl/openssl/pull/20568) ",
        "func_before": "static int tree_calculate_user_set(X509_POLICY_TREE *tree,\n                                   STACK_OF(ASN1_OBJECT) *policy_oids,\n                                   STACK_OF(X509_POLICY_NODE) *auth_nodes)\n{\n    int i;\n    X509_POLICY_NODE *node;\n    ASN1_OBJECT *oid;\n    X509_POLICY_NODE *anyPolicy;\n    X509_POLICY_DATA *extra;\n\n    /*\n     * Check if anyPolicy present in authority constrained policy set: this\n     * will happen if it is a leaf node.\n     */\n    if (sk_ASN1_OBJECT_num(policy_oids) <= 0)\n        return 1;\n\n    anyPolicy = tree->levels[tree->nlevel - 1].anyPolicy;\n\n    for (i = 0; i < sk_ASN1_OBJECT_num(policy_oids); i++) {\n        oid = sk_ASN1_OBJECT_value(policy_oids, i);\n        if (OBJ_obj2nid(oid) == NID_any_policy) {\n            tree->flags |= POLICY_FLAG_ANY_POLICY;\n            return 1;\n        }\n    }\n\n    for (i = 0; i < sk_ASN1_OBJECT_num(policy_oids); i++) {\n        oid = sk_ASN1_OBJECT_value(policy_oids, i);\n        node = ossl_policy_tree_find_sk(auth_nodes, oid);\n        if (!node) {\n            if (!anyPolicy)\n                continue;\n            /*\n             * Create a new node with policy ID from user set and qualifiers\n             * from anyPolicy.\n             */\n            extra = ossl_policy_data_new(NULL, oid, node_critical(anyPolicy));\n            if (extra == NULL)\n                return 0;\n            extra->qualifier_set = anyPolicy->data->qualifier_set;\n            extra->flags = POLICY_DATA_FLAG_SHARED_QUALIFIERS\n                | POLICY_DATA_FLAG_EXTRA_NODE;\n            node = ossl_policy_level_add_node(NULL, extra, anyPolicy->parent,\n                                              tree);\n        }\n        if (!tree->user_policies) {\n            tree->user_policies = sk_X509_POLICY_NODE_new_null();\n            if (!tree->user_policies)\n                return 1;\n        }\n        if (!sk_X509_POLICY_NODE_push(tree->user_policies, node))\n            return 0;\n    }\n    return 1;\n}",
        "func": "static int tree_calculate_user_set(X509_POLICY_TREE *tree,\n                                   STACK_OF(ASN1_OBJECT) *policy_oids,\n                                   STACK_OF(X509_POLICY_NODE) *auth_nodes)\n{\n    int i;\n    X509_POLICY_NODE *node;\n    ASN1_OBJECT *oid;\n    X509_POLICY_NODE *anyPolicy;\n    X509_POLICY_DATA *extra;\n\n    /*\n     * Check if anyPolicy present in authority constrained policy set: this\n     * will happen if it is a leaf node.\n     */\n    if (sk_ASN1_OBJECT_num(policy_oids) <= 0)\n        return 1;\n\n    anyPolicy = tree->levels[tree->nlevel - 1].anyPolicy;\n\n    for (i = 0; i < sk_ASN1_OBJECT_num(policy_oids); i++) {\n        oid = sk_ASN1_OBJECT_value(policy_oids, i);\n        if (OBJ_obj2nid(oid) == NID_any_policy) {\n            tree->flags |= POLICY_FLAG_ANY_POLICY;\n            return 1;\n        }\n    }\n\n    for (i = 0; i < sk_ASN1_OBJECT_num(policy_oids); i++) {\n        oid = sk_ASN1_OBJECT_value(policy_oids, i);\n        node = ossl_policy_tree_find_sk(auth_nodes, oid);\n        if (!node) {\n            if (!anyPolicy)\n                continue;\n            /*\n             * Create a new node with policy ID from user set and qualifiers\n             * from anyPolicy.\n             */\n            extra = ossl_policy_data_new(NULL, oid, node_critical(anyPolicy));\n            if (extra == NULL)\n                return 0;\n            extra->qualifier_set = anyPolicy->data->qualifier_set;\n            extra->flags = POLICY_DATA_FLAG_SHARED_QUALIFIERS\n                | POLICY_DATA_FLAG_EXTRA_NODE;\n            node = ossl_policy_level_add_node(NULL, extra, anyPolicy->parent,\n                                              tree, 1);\n        }\n        if (!tree->user_policies) {\n            tree->user_policies = sk_X509_POLICY_NODE_new_null();\n            if (!tree->user_policies)\n                return 1;\n        }\n        if (!sk_X509_POLICY_NODE_push(tree->user_policies, node))\n            return 0;\n    }\n    return 1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -42,7 +42,7 @@\n             extra->flags = POLICY_DATA_FLAG_SHARED_QUALIFIERS\n                 | POLICY_DATA_FLAG_EXTRA_NODE;\n             node = ossl_policy_level_add_node(NULL, extra, anyPolicy->parent,\n-                                              tree);\n+                                              tree, 1);\n         }\n         if (!tree->user_policies) {\n             tree->user_policies = sk_X509_POLICY_NODE_new_null();",
        "diff_line_info": {
            "deleted_lines": [
                "                                              tree);"
            ],
            "added_lines": [
                "                                              tree, 1);"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-0464",
        "func_name": "openssl/ossl_policy_level_add_node",
        "description": "A security vulnerability has been identified in all supported versions\n\nof OpenSSL related to the verification of X.509 certificate chains\nthat include policy constraints.  Attackers may be able to exploit this\nvulnerability by creating a malicious certificate chain that triggers\nexponential use of computational resources, leading to a denial-of-service\n(DoS) attack on affected systems.\n\nPolicy processing is disabled by default but can be enabled by passing\nthe `-policy' argument to the command line utilities or by calling the\n`X509_VERIFY_PARAM_set1_policies()' function.",
        "git_url": "https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=2017771e2db3e2b96f89bbe8766c3209f6a99545",
        "commit_title": "",
        "commit_text": "x509: excessive resource use verifying policy constraints  A security vulnerability has been identified in all supported versions of OpenSSL related to the verification of X.509 certificate chains that include policy constraints.  Attackers may be able to exploit this vulnerability by creating a malicious certificate chain that triggers exponential use of computational resources, leading to a denial-of-service (DoS) attack on affected systems.  Fixes CVE-2023-0464  (Merged from https://github.com/openssl/openssl/pull/20570) ",
        "func_before": "X509_POLICY_NODE *ossl_policy_level_add_node(X509_POLICY_LEVEL *level,\n                                             X509_POLICY_DATA *data,\n                                             X509_POLICY_NODE *parent,\n                                             X509_POLICY_TREE *tree)\n{\n    X509_POLICY_NODE *node;\n\n    node = OPENSSL_zalloc(sizeof(*node));\n    if (node == NULL) {\n        ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);\n        return NULL;\n    }\n    node->data = data;\n    node->parent = parent;\n    if (level) {\n        if (OBJ_obj2nid(data->valid_policy) == NID_any_policy) {\n            if (level->anyPolicy)\n                goto node_error;\n            level->anyPolicy = node;\n        } else {\n\n            if (level->nodes == NULL)\n                level->nodes = ossl_policy_node_cmp_new();\n            if (level->nodes == NULL) {\n                ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);\n                goto node_error;\n            }\n            if (!sk_X509_POLICY_NODE_push(level->nodes, node)) {\n                ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);\n                goto node_error;\n            }\n        }\n    }\n\n    if (tree) {\n        if (tree->extra_data == NULL)\n            tree->extra_data = sk_X509_POLICY_DATA_new_null();\n        if (tree->extra_data == NULL){\n            ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);\n            goto node_error;\n        }\n        if (!sk_X509_POLICY_DATA_push(tree->extra_data, data)) {\n            ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);\n            goto node_error;\n        }\n    }\n\n    if (parent)\n        parent->nchild++;\n\n    return node;\n\n node_error:\n    ossl_policy_node_free(node);\n    return NULL;\n}",
        "func": "X509_POLICY_NODE *ossl_policy_level_add_node(X509_POLICY_LEVEL *level,\n                                             X509_POLICY_DATA *data,\n                                             X509_POLICY_NODE *parent,\n                                             X509_POLICY_TREE *tree,\n                                             int extra_data)\n{\n    X509_POLICY_NODE *node;\n\n    /* Verify that the tree isn't too large.  This mitigates CVE-2023-0464 */\n    if (tree->node_maximum > 0 && tree->node_count >= tree->node_maximum)\n        return NULL;\n\n    node = OPENSSL_zalloc(sizeof(*node));\n    if (node == NULL) {\n        ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);\n        return NULL;\n    }\n    node->data = data;\n    node->parent = parent;\n    if (level != NULL) {\n        if (OBJ_obj2nid(data->valid_policy) == NID_any_policy) {\n            if (level->anyPolicy)\n                goto node_error;\n            level->anyPolicy = node;\n        } else {\n\n            if (level->nodes == NULL)\n                level->nodes = ossl_policy_node_cmp_new();\n            if (level->nodes == NULL) {\n                ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);\n                goto node_error;\n            }\n            if (!sk_X509_POLICY_NODE_push(level->nodes, node)) {\n                ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);\n                goto node_error;\n            }\n        }\n    }\n\n    if (extra_data) {\n        if (tree->extra_data == NULL)\n            tree->extra_data = sk_X509_POLICY_DATA_new_null();\n        if (tree->extra_data == NULL){\n            ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);\n            goto node_error;\n        }\n        if (!sk_X509_POLICY_DATA_push(tree->extra_data, data)) {\n            ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);\n            goto node_error;\n        }\n    }\n\n    tree->node_count++;\n    if (parent)\n        parent->nchild++;\n\n    return node;\n\n node_error:\n    ossl_policy_node_free(node);\n    return NULL;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,9 +1,14 @@\n X509_POLICY_NODE *ossl_policy_level_add_node(X509_POLICY_LEVEL *level,\n                                              X509_POLICY_DATA *data,\n                                              X509_POLICY_NODE *parent,\n-                                             X509_POLICY_TREE *tree)\n+                                             X509_POLICY_TREE *tree,\n+                                             int extra_data)\n {\n     X509_POLICY_NODE *node;\n+\n+    /* Verify that the tree isn't too large.  This mitigates CVE-2023-0464 */\n+    if (tree->node_maximum > 0 && tree->node_count >= tree->node_maximum)\n+        return NULL;\n \n     node = OPENSSL_zalloc(sizeof(*node));\n     if (node == NULL) {\n@@ -12,7 +17,7 @@\n     }\n     node->data = data;\n     node->parent = parent;\n-    if (level) {\n+    if (level != NULL) {\n         if (OBJ_obj2nid(data->valid_policy) == NID_any_policy) {\n             if (level->anyPolicy)\n                 goto node_error;\n@@ -32,7 +37,7 @@\n         }\n     }\n \n-    if (tree) {\n+    if (extra_data) {\n         if (tree->extra_data == NULL)\n             tree->extra_data = sk_X509_POLICY_DATA_new_null();\n         if (tree->extra_data == NULL){\n@@ -45,6 +50,7 @@\n         }\n     }\n \n+    tree->node_count++;\n     if (parent)\n         parent->nchild++;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "                                             X509_POLICY_TREE *tree)",
                "    if (level) {",
                "    if (tree) {"
            ],
            "added_lines": [
                "                                             X509_POLICY_TREE *tree,",
                "                                             int extra_data)",
                "",
                "    /* Verify that the tree isn't too large.  This mitigates CVE-2023-0464 */",
                "    if (tree->node_maximum > 0 && tree->node_count >= tree->node_maximum)",
                "        return NULL;",
                "    if (level != NULL) {",
                "    if (extra_data) {",
                "    tree->node_count++;"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-0464",
        "func_name": "openssl/tree_init",
        "description": "A security vulnerability has been identified in all supported versions\n\nof OpenSSL related to the verification of X.509 certificate chains\nthat include policy constraints.  Attackers may be able to exploit this\nvulnerability by creating a malicious certificate chain that triggers\nexponential use of computational resources, leading to a denial-of-service\n(DoS) attack on affected systems.\n\nPolicy processing is disabled by default but can be enabled by passing\nthe `-policy' argument to the command line utilities or by calling the\n`X509_VERIFY_PARAM_set1_policies()' function.",
        "git_url": "https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=2017771e2db3e2b96f89bbe8766c3209f6a99545",
        "commit_title": "",
        "commit_text": "x509: excessive resource use verifying policy constraints  A security vulnerability has been identified in all supported versions of OpenSSL related to the verification of X.509 certificate chains that include policy constraints.  Attackers may be able to exploit this vulnerability by creating a malicious certificate chain that triggers exponential use of computational resources, leading to a denial-of-service (DoS) attack on affected systems.  Fixes CVE-2023-0464  (Merged from https://github.com/openssl/openssl/pull/20570) ",
        "func_before": "static int tree_init(X509_POLICY_TREE **ptree, STACK_OF(X509) *certs,\n                     unsigned int flags)\n{\n    X509_POLICY_TREE *tree;\n    X509_POLICY_LEVEL *level;\n    const X509_POLICY_CACHE *cache;\n    X509_POLICY_DATA *data = NULL;\n    int ret = X509_PCY_TREE_VALID;\n    int n = sk_X509_num(certs) - 1; /* RFC5280 paths omit the TA */\n    int explicit_policy = (flags & X509_V_FLAG_EXPLICIT_POLICY) ? 0 : n+1;\n    int any_skip = (flags & X509_V_FLAG_INHIBIT_ANY) ? 0 : n+1;\n    int map_skip = (flags & X509_V_FLAG_INHIBIT_MAP) ? 0 : n+1;\n    int i;\n\n    *ptree = NULL;\n\n    /* Can't do anything with just a trust anchor */\n    if (n == 0)\n        return X509_PCY_TREE_EMPTY;\n\n    /*\n     * First setup the policy cache in all n non-TA certificates, this will be\n     * used in X509_verify_cert() which will invoke the verify callback for all\n     * certificates with invalid policy extensions.\n     */\n    for (i = n - 1; i >= 0; i--) {\n        X509 *x = sk_X509_value(certs, i);\n\n        /* Call for side-effect of computing hash and caching extensions */\n        X509_check_purpose(x, -1, 0);\n\n        /* If cache is NULL, likely ENOMEM: return immediately */\n        if (ossl_policy_cache_set(x) == NULL)\n            return X509_PCY_TREE_INTERNAL;\n    }\n\n    /*\n     * At this point check for invalid policies and required explicit policy.\n     * Note that the explicit_policy counter is a count-down to zero, with the\n     * requirement kicking in if and once it does that.  The counter is\n     * decremented for every non-self-issued certificate in the path, but may\n     * be further reduced by policy constraints in a non-leaf certificate.\n     *\n     * The ultimate policy set is the intersection of all the policies along\n     * the path, if we hit a certificate with an empty policy set, and explicit\n     * policy is required we're done.\n     */\n    for (i = n - 1;\n         i >= 0 && (explicit_policy > 0 || (ret & X509_PCY_TREE_EMPTY) == 0);\n         i--) {\n        X509 *x = sk_X509_value(certs, i);\n        uint32_t ex_flags = X509_get_extension_flags(x);\n\n        /* All the policies are already cached, we can return early */\n        if (ex_flags & EXFLAG_INVALID_POLICY)\n            return X509_PCY_TREE_INVALID;\n\n        /* Access the cache which we now know exists */\n        cache = ossl_policy_cache_set(x);\n\n        if ((ret & X509_PCY_TREE_VALID) && cache->data == NULL)\n            ret = X509_PCY_TREE_EMPTY;\n        if (explicit_policy > 0) {\n            if (!(ex_flags & EXFLAG_SI))\n                explicit_policy--;\n            if ((cache->explicit_skip >= 0)\n                && (cache->explicit_skip < explicit_policy))\n                explicit_policy = cache->explicit_skip;\n        }\n    }\n\n    if (explicit_policy == 0)\n        ret |= X509_PCY_TREE_EXPLICIT;\n    if ((ret & X509_PCY_TREE_VALID) == 0)\n        return ret;\n\n    /* If we get this far initialize the tree */\n    if ((tree = OPENSSL_zalloc(sizeof(*tree))) == NULL) {\n        ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);\n        return X509_PCY_TREE_INTERNAL;\n    }\n\n    /*\n     * http://tools.ietf.org/html/rfc5280#section-6.1.2, figure 3.\n     *\n     * The top level is implicitly for the trust anchor with valid expected\n     * policies of anyPolicy.  (RFC 5280 has the TA at depth 0 and the leaf at\n     * depth n, we have the leaf at depth 0 and the TA at depth n).\n     */\n    if ((tree->levels = OPENSSL_zalloc(sizeof(*tree->levels)*(n+1))) == NULL) {\n        OPENSSL_free(tree);\n        ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);\n        return X509_PCY_TREE_INTERNAL;\n    }\n    tree->nlevel = n+1;\n    level = tree->levels;\n    if ((data = ossl_policy_data_new(NULL,\n                                     OBJ_nid2obj(NID_any_policy), 0)) == NULL)\n        goto bad_tree;\n    if (ossl_policy_level_add_node(level, data, NULL, tree) == NULL) {\n        ossl_policy_data_free(data);\n        goto bad_tree;\n    }\n\n    /*\n     * In this pass initialize all the tree levels and whether anyPolicy and\n     * policy mapping are inhibited at each level.\n     */\n    for (i = n - 1; i >= 0; i--) {\n        X509 *x = sk_X509_value(certs, i);\n        uint32_t ex_flags = X509_get_extension_flags(x);\n\n        /* Access the cache which we now know exists */\n        cache = ossl_policy_cache_set(x);\n\n        X509_up_ref(x);\n        (++level)->cert = x;\n\n        if (!cache->anyPolicy)\n            level->flags |= X509_V_FLAG_INHIBIT_ANY;\n\n        /* Determine inhibit any and inhibit map flags */\n        if (any_skip == 0) {\n            /*\n             * Any matching allowed only if certificate is self issued and not\n             * the last in the chain.\n             */\n            if (!(ex_flags & EXFLAG_SI) || (i == 0))\n                level->flags |= X509_V_FLAG_INHIBIT_ANY;\n        } else {\n            if (!(ex_flags & EXFLAG_SI))\n                any_skip--;\n            if ((cache->any_skip >= 0) && (cache->any_skip < any_skip))\n                any_skip = cache->any_skip;\n        }\n\n        if (map_skip == 0)\n            level->flags |= X509_V_FLAG_INHIBIT_MAP;\n        else {\n            if (!(ex_flags & EXFLAG_SI))\n                map_skip--;\n            if ((cache->map_skip >= 0) && (cache->map_skip < map_skip))\n                map_skip = cache->map_skip;\n        }\n    }\n\n    *ptree = tree;\n    return ret;\n\n bad_tree:\n    X509_policy_tree_free(tree);\n    return X509_PCY_TREE_INTERNAL;\n}",
        "func": "static int tree_init(X509_POLICY_TREE **ptree, STACK_OF(X509) *certs,\n                     unsigned int flags)\n{\n    X509_POLICY_TREE *tree;\n    X509_POLICY_LEVEL *level;\n    const X509_POLICY_CACHE *cache;\n    X509_POLICY_DATA *data = NULL;\n    int ret = X509_PCY_TREE_VALID;\n    int n = sk_X509_num(certs) - 1; /* RFC5280 paths omit the TA */\n    int explicit_policy = (flags & X509_V_FLAG_EXPLICIT_POLICY) ? 0 : n+1;\n    int any_skip = (flags & X509_V_FLAG_INHIBIT_ANY) ? 0 : n+1;\n    int map_skip = (flags & X509_V_FLAG_INHIBIT_MAP) ? 0 : n+1;\n    int i;\n\n    *ptree = NULL;\n\n    /* Can't do anything with just a trust anchor */\n    if (n == 0)\n        return X509_PCY_TREE_EMPTY;\n\n    /*\n     * First setup the policy cache in all n non-TA certificates, this will be\n     * used in X509_verify_cert() which will invoke the verify callback for all\n     * certificates with invalid policy extensions.\n     */\n    for (i = n - 1; i >= 0; i--) {\n        X509 *x = sk_X509_value(certs, i);\n\n        /* Call for side-effect of computing hash and caching extensions */\n        X509_check_purpose(x, -1, 0);\n\n        /* If cache is NULL, likely ENOMEM: return immediately */\n        if (ossl_policy_cache_set(x) == NULL)\n            return X509_PCY_TREE_INTERNAL;\n    }\n\n    /*\n     * At this point check for invalid policies and required explicit policy.\n     * Note that the explicit_policy counter is a count-down to zero, with the\n     * requirement kicking in if and once it does that.  The counter is\n     * decremented for every non-self-issued certificate in the path, but may\n     * be further reduced by policy constraints in a non-leaf certificate.\n     *\n     * The ultimate policy set is the intersection of all the policies along\n     * the path, if we hit a certificate with an empty policy set, and explicit\n     * policy is required we're done.\n     */\n    for (i = n - 1;\n         i >= 0 && (explicit_policy > 0 || (ret & X509_PCY_TREE_EMPTY) == 0);\n         i--) {\n        X509 *x = sk_X509_value(certs, i);\n        uint32_t ex_flags = X509_get_extension_flags(x);\n\n        /* All the policies are already cached, we can return early */\n        if (ex_flags & EXFLAG_INVALID_POLICY)\n            return X509_PCY_TREE_INVALID;\n\n        /* Access the cache which we now know exists */\n        cache = ossl_policy_cache_set(x);\n\n        if ((ret & X509_PCY_TREE_VALID) && cache->data == NULL)\n            ret = X509_PCY_TREE_EMPTY;\n        if (explicit_policy > 0) {\n            if (!(ex_flags & EXFLAG_SI))\n                explicit_policy--;\n            if ((cache->explicit_skip >= 0)\n                && (cache->explicit_skip < explicit_policy))\n                explicit_policy = cache->explicit_skip;\n        }\n    }\n\n    if (explicit_policy == 0)\n        ret |= X509_PCY_TREE_EXPLICIT;\n    if ((ret & X509_PCY_TREE_VALID) == 0)\n        return ret;\n\n    /* If we get this far initialize the tree */\n    if ((tree = OPENSSL_zalloc(sizeof(*tree))) == NULL) {\n        ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);\n        return X509_PCY_TREE_INTERNAL;\n    }\n\n    /* Limit the growth of the tree to mitigate CVE-2023-0464 */\n    tree->node_maximum = OPENSSL_POLICY_TREE_NODES_MAX;\n\n    /*\n     * http://tools.ietf.org/html/rfc5280#section-6.1.2, figure 3.\n     *\n     * The top level is implicitly for the trust anchor with valid expected\n     * policies of anyPolicy.  (RFC 5280 has the TA at depth 0 and the leaf at\n     * depth n, we have the leaf at depth 0 and the TA at depth n).\n     */\n    if ((tree->levels = OPENSSL_zalloc(sizeof(*tree->levels)*(n+1))) == NULL) {\n        OPENSSL_free(tree);\n        ERR_raise(ERR_LIB_X509V3, ERR_R_MALLOC_FAILURE);\n        return X509_PCY_TREE_INTERNAL;\n    }\n    tree->nlevel = n+1;\n    level = tree->levels;\n    if ((data = ossl_policy_data_new(NULL,\n                                     OBJ_nid2obj(NID_any_policy), 0)) == NULL)\n        goto bad_tree;\n    if (ossl_policy_level_add_node(level, data, NULL, tree, 1) == NULL) {\n        ossl_policy_data_free(data);\n        goto bad_tree;\n    }\n\n    /*\n     * In this pass initialize all the tree levels and whether anyPolicy and\n     * policy mapping are inhibited at each level.\n     */\n    for (i = n - 1; i >= 0; i--) {\n        X509 *x = sk_X509_value(certs, i);\n        uint32_t ex_flags = X509_get_extension_flags(x);\n\n        /* Access the cache which we now know exists */\n        cache = ossl_policy_cache_set(x);\n\n        X509_up_ref(x);\n        (++level)->cert = x;\n\n        if (!cache->anyPolicy)\n            level->flags |= X509_V_FLAG_INHIBIT_ANY;\n\n        /* Determine inhibit any and inhibit map flags */\n        if (any_skip == 0) {\n            /*\n             * Any matching allowed only if certificate is self issued and not\n             * the last in the chain.\n             */\n            if (!(ex_flags & EXFLAG_SI) || (i == 0))\n                level->flags |= X509_V_FLAG_INHIBIT_ANY;\n        } else {\n            if (!(ex_flags & EXFLAG_SI))\n                any_skip--;\n            if ((cache->any_skip >= 0) && (cache->any_skip < any_skip))\n                any_skip = cache->any_skip;\n        }\n\n        if (map_skip == 0)\n            level->flags |= X509_V_FLAG_INHIBIT_MAP;\n        else {\n            if (!(ex_flags & EXFLAG_SI))\n                map_skip--;\n            if ((cache->map_skip >= 0) && (cache->map_skip < map_skip))\n                map_skip = cache->map_skip;\n        }\n    }\n\n    *ptree = tree;\n    return ret;\n\n bad_tree:\n    X509_policy_tree_free(tree);\n    return X509_PCY_TREE_INTERNAL;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -80,6 +80,9 @@\n         return X509_PCY_TREE_INTERNAL;\n     }\n \n+    /* Limit the growth of the tree to mitigate CVE-2023-0464 */\n+    tree->node_maximum = OPENSSL_POLICY_TREE_NODES_MAX;\n+\n     /*\n      * http://tools.ietf.org/html/rfc5280#section-6.1.2, figure 3.\n      *\n@@ -97,7 +100,7 @@\n     if ((data = ossl_policy_data_new(NULL,\n                                      OBJ_nid2obj(NID_any_policy), 0)) == NULL)\n         goto bad_tree;\n-    if (ossl_policy_level_add_node(level, data, NULL, tree) == NULL) {\n+    if (ossl_policy_level_add_node(level, data, NULL, tree, 1) == NULL) {\n         ossl_policy_data_free(data);\n         goto bad_tree;\n     }",
        "diff_line_info": {
            "deleted_lines": [
                "    if (ossl_policy_level_add_node(level, data, NULL, tree) == NULL) {"
            ],
            "added_lines": [
                "    /* Limit the growth of the tree to mitigate CVE-2023-0464 */",
                "    tree->node_maximum = OPENSSL_POLICY_TREE_NODES_MAX;",
                "",
                "    if (ossl_policy_level_add_node(level, data, NULL, tree, 1) == NULL) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-0464",
        "func_name": "openssl/tree_evaluate",
        "description": "A security vulnerability has been identified in all supported versions\n\nof OpenSSL related to the verification of X.509 certificate chains\nthat include policy constraints.  Attackers may be able to exploit this\nvulnerability by creating a malicious certificate chain that triggers\nexponential use of computational resources, leading to a denial-of-service\n(DoS) attack on affected systems.\n\nPolicy processing is disabled by default but can be enabled by passing\nthe `-policy' argument to the command line utilities or by calling the\n`X509_VERIFY_PARAM_set1_policies()' function.",
        "git_url": "https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=2017771e2db3e2b96f89bbe8766c3209f6a99545",
        "commit_title": "",
        "commit_text": "x509: excessive resource use verifying policy constraints  A security vulnerability has been identified in all supported versions of OpenSSL related to the verification of X.509 certificate chains that include policy constraints.  Attackers may be able to exploit this vulnerability by creating a malicious certificate chain that triggers exponential use of computational resources, leading to a denial-of-service (DoS) attack on affected systems.  Fixes CVE-2023-0464  (Merged from https://github.com/openssl/openssl/pull/20570) ",
        "func_before": "static int tree_evaluate(X509_POLICY_TREE *tree)\n{\n    int ret, i;\n    X509_POLICY_LEVEL *curr = tree->levels + 1;\n    const X509_POLICY_CACHE *cache;\n\n    for (i = 1; i < tree->nlevel; i++, curr++) {\n        cache = ossl_policy_cache_set(curr->cert);\n        if (!tree_link_nodes(curr, cache))\n            return X509_PCY_TREE_INTERNAL;\n\n        if (!(curr->flags & X509_V_FLAG_INHIBIT_ANY)\n            && !tree_link_any(curr, cache, tree))\n            return X509_PCY_TREE_INTERNAL;\n        TREE_PRINT(\"before tree_prune()\", tree, curr);\n        ret = tree_prune(tree, curr);\n        if (ret != X509_PCY_TREE_VALID)\n            return ret;\n    }\n    return X509_PCY_TREE_VALID;\n}",
        "func": "static int tree_evaluate(X509_POLICY_TREE *tree)\n{\n    int ret, i;\n    X509_POLICY_LEVEL *curr = tree->levels + 1;\n    const X509_POLICY_CACHE *cache;\n\n    for (i = 1; i < tree->nlevel; i++, curr++) {\n        cache = ossl_policy_cache_set(curr->cert);\n        if (!tree_link_nodes(curr, cache, tree))\n            return X509_PCY_TREE_INTERNAL;\n\n        if (!(curr->flags & X509_V_FLAG_INHIBIT_ANY)\n            && !tree_link_any(curr, cache, tree))\n            return X509_PCY_TREE_INTERNAL;\n        TREE_PRINT(\"before tree_prune()\", tree, curr);\n        ret = tree_prune(tree, curr);\n        if (ret != X509_PCY_TREE_VALID)\n            return ret;\n    }\n    return X509_PCY_TREE_VALID;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,7 +6,7 @@\n \n     for (i = 1; i < tree->nlevel; i++, curr++) {\n         cache = ossl_policy_cache_set(curr->cert);\n-        if (!tree_link_nodes(curr, cache))\n+        if (!tree_link_nodes(curr, cache, tree))\n             return X509_PCY_TREE_INTERNAL;\n \n         if (!(curr->flags & X509_V_FLAG_INHIBIT_ANY)",
        "diff_line_info": {
            "deleted_lines": [
                "        if (!tree_link_nodes(curr, cache))"
            ],
            "added_lines": [
                "        if (!tree_link_nodes(curr, cache, tree))"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-0464",
        "func_name": "openssl/tree_link_matching_nodes",
        "description": "A security vulnerability has been identified in all supported versions\n\nof OpenSSL related to the verification of X.509 certificate chains\nthat include policy constraints.  Attackers may be able to exploit this\nvulnerability by creating a malicious certificate chain that triggers\nexponential use of computational resources, leading to a denial-of-service\n(DoS) attack on affected systems.\n\nPolicy processing is disabled by default but can be enabled by passing\nthe `-policy' argument to the command line utilities or by calling the\n`X509_VERIFY_PARAM_set1_policies()' function.",
        "git_url": "https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=2017771e2db3e2b96f89bbe8766c3209f6a99545",
        "commit_title": "",
        "commit_text": "x509: excessive resource use verifying policy constraints  A security vulnerability has been identified in all supported versions of OpenSSL related to the verification of X.509 certificate chains that include policy constraints.  Attackers may be able to exploit this vulnerability by creating a malicious certificate chain that triggers exponential use of computational resources, leading to a denial-of-service (DoS) attack on affected systems.  Fixes CVE-2023-0464  (Merged from https://github.com/openssl/openssl/pull/20570) ",
        "func_before": "static int tree_link_matching_nodes(X509_POLICY_LEVEL *curr,\n                                    X509_POLICY_DATA *data)\n{\n    X509_POLICY_LEVEL *last = curr - 1;\n    int i, matched = 0;\n\n    /* Iterate through all in nodes linking matches */\n    for (i = 0; i < sk_X509_POLICY_NODE_num(last->nodes); i++) {\n        X509_POLICY_NODE *node = sk_X509_POLICY_NODE_value(last->nodes, i);\n\n        if (ossl_policy_node_match(last, node, data->valid_policy)) {\n            if (ossl_policy_level_add_node(curr, data, node, NULL) == NULL)\n                return 0;\n            matched = 1;\n        }\n    }\n    if (!matched && last->anyPolicy) {\n        if (ossl_policy_level_add_node(curr, data, last->anyPolicy, NULL) == NULL)\n            return 0;\n    }\n    return 1;\n}",
        "func": "static int tree_link_matching_nodes(X509_POLICY_LEVEL *curr,\n                                    X509_POLICY_DATA *data,\n                                    X509_POLICY_TREE *tree)\n{\n    X509_POLICY_LEVEL *last = curr - 1;\n    int i, matched = 0;\n\n    /* Iterate through all in nodes linking matches */\n    for (i = 0; i < sk_X509_POLICY_NODE_num(last->nodes); i++) {\n        X509_POLICY_NODE *node = sk_X509_POLICY_NODE_value(last->nodes, i);\n\n        if (ossl_policy_node_match(last, node, data->valid_policy)) {\n            if (ossl_policy_level_add_node(curr, data, node, tree, 0) == NULL)\n                return 0;\n            matched = 1;\n        }\n    }\n    if (!matched && last->anyPolicy) {\n        if (ossl_policy_level_add_node(curr, data, last->anyPolicy, tree, 0) == NULL)\n            return 0;\n    }\n    return 1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,6 @@\n static int tree_link_matching_nodes(X509_POLICY_LEVEL *curr,\n-                                    X509_POLICY_DATA *data)\n+                                    X509_POLICY_DATA *data,\n+                                    X509_POLICY_TREE *tree)\n {\n     X509_POLICY_LEVEL *last = curr - 1;\n     int i, matched = 0;\n@@ -9,13 +10,13 @@\n         X509_POLICY_NODE *node = sk_X509_POLICY_NODE_value(last->nodes, i);\n \n         if (ossl_policy_node_match(last, node, data->valid_policy)) {\n-            if (ossl_policy_level_add_node(curr, data, node, NULL) == NULL)\n+            if (ossl_policy_level_add_node(curr, data, node, tree, 0) == NULL)\n                 return 0;\n             matched = 1;\n         }\n     }\n     if (!matched && last->anyPolicy) {\n-        if (ossl_policy_level_add_node(curr, data, last->anyPolicy, NULL) == NULL)\n+        if (ossl_policy_level_add_node(curr, data, last->anyPolicy, tree, 0) == NULL)\n             return 0;\n     }\n     return 1;",
        "diff_line_info": {
            "deleted_lines": [
                "                                    X509_POLICY_DATA *data)",
                "            if (ossl_policy_level_add_node(curr, data, node, NULL) == NULL)",
                "        if (ossl_policy_level_add_node(curr, data, last->anyPolicy, NULL) == NULL)"
            ],
            "added_lines": [
                "                                    X509_POLICY_DATA *data,",
                "                                    X509_POLICY_TREE *tree)",
                "            if (ossl_policy_level_add_node(curr, data, node, tree, 0) == NULL)",
                "        if (ossl_policy_level_add_node(curr, data, last->anyPolicy, tree, 0) == NULL)"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-0464",
        "func_name": "openssl/tree_link_any",
        "description": "A security vulnerability has been identified in all supported versions\n\nof OpenSSL related to the verification of X.509 certificate chains\nthat include policy constraints.  Attackers may be able to exploit this\nvulnerability by creating a malicious certificate chain that triggers\nexponential use of computational resources, leading to a denial-of-service\n(DoS) attack on affected systems.\n\nPolicy processing is disabled by default but can be enabled by passing\nthe `-policy' argument to the command line utilities or by calling the\n`X509_VERIFY_PARAM_set1_policies()' function.",
        "git_url": "https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=2017771e2db3e2b96f89bbe8766c3209f6a99545",
        "commit_title": "",
        "commit_text": "x509: excessive resource use verifying policy constraints  A security vulnerability has been identified in all supported versions of OpenSSL related to the verification of X.509 certificate chains that include policy constraints.  Attackers may be able to exploit this vulnerability by creating a malicious certificate chain that triggers exponential use of computational resources, leading to a denial-of-service (DoS) attack on affected systems.  Fixes CVE-2023-0464  (Merged from https://github.com/openssl/openssl/pull/20570) ",
        "func_before": "static int tree_link_any(X509_POLICY_LEVEL *curr,\n                         const X509_POLICY_CACHE *cache,\n                         X509_POLICY_TREE *tree)\n{\n    int i;\n    X509_POLICY_NODE *node;\n    X509_POLICY_LEVEL *last = curr - 1;\n\n    for (i = 0; i < sk_X509_POLICY_NODE_num(last->nodes); i++) {\n        node = sk_X509_POLICY_NODE_value(last->nodes, i);\n\n        if (!tree_link_unmatched(curr, cache, node, tree))\n            return 0;\n    }\n    /* Finally add link to anyPolicy */\n    if (last->anyPolicy &&\n            ossl_policy_level_add_node(curr, cache->anyPolicy,\n                                       last->anyPolicy, NULL) == NULL)\n        return 0;\n    return 1;\n}",
        "func": "static int tree_link_any(X509_POLICY_LEVEL *curr,\n                         const X509_POLICY_CACHE *cache,\n                         X509_POLICY_TREE *tree)\n{\n    int i;\n    X509_POLICY_NODE *node;\n    X509_POLICY_LEVEL *last = curr - 1;\n\n    for (i = 0; i < sk_X509_POLICY_NODE_num(last->nodes); i++) {\n        node = sk_X509_POLICY_NODE_value(last->nodes, i);\n\n        if (!tree_link_unmatched(curr, cache, node, tree))\n            return 0;\n    }\n    /* Finally add link to anyPolicy */\n    if (last->anyPolicy &&\n            ossl_policy_level_add_node(curr, cache->anyPolicy,\n                                       last->anyPolicy, tree, 0) == NULL)\n        return 0;\n    return 1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -15,7 +15,7 @@\n     /* Finally add link to anyPolicy */\n     if (last->anyPolicy &&\n             ossl_policy_level_add_node(curr, cache->anyPolicy,\n-                                       last->anyPolicy, NULL) == NULL)\n+                                       last->anyPolicy, tree, 0) == NULL)\n         return 0;\n     return 1;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "                                       last->anyPolicy, NULL) == NULL)"
            ],
            "added_lines": [
                "                                       last->anyPolicy, tree, 0) == NULL)"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-0464",
        "func_name": "openssl/tree_link_nodes",
        "description": "A security vulnerability has been identified in all supported versions\n\nof OpenSSL related to the verification of X.509 certificate chains\nthat include policy constraints.  Attackers may be able to exploit this\nvulnerability by creating a malicious certificate chain that triggers\nexponential use of computational resources, leading to a denial-of-service\n(DoS) attack on affected systems.\n\nPolicy processing is disabled by default but can be enabled by passing\nthe `-policy' argument to the command line utilities or by calling the\n`X509_VERIFY_PARAM_set1_policies()' function.",
        "git_url": "https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=2017771e2db3e2b96f89bbe8766c3209f6a99545",
        "commit_title": "",
        "commit_text": "x509: excessive resource use verifying policy constraints  A security vulnerability has been identified in all supported versions of OpenSSL related to the verification of X.509 certificate chains that include policy constraints.  Attackers may be able to exploit this vulnerability by creating a malicious certificate chain that triggers exponential use of computational resources, leading to a denial-of-service (DoS) attack on affected systems.  Fixes CVE-2023-0464  (Merged from https://github.com/openssl/openssl/pull/20570) ",
        "func_before": "static int tree_link_nodes(X509_POLICY_LEVEL *curr,\n                           const X509_POLICY_CACHE *cache)\n{\n    int i;\n\n    for (i = 0; i < sk_X509_POLICY_DATA_num(cache->data); i++) {\n        X509_POLICY_DATA *data = sk_X509_POLICY_DATA_value(cache->data, i);\n\n        /* Look for matching nodes in previous level */\n        if (!tree_link_matching_nodes(curr, data))\n            return 0;\n    }\n    return 1;\n}",
        "func": "static int tree_link_nodes(X509_POLICY_LEVEL *curr,\n                           const X509_POLICY_CACHE *cache,\n                           X509_POLICY_TREE *tree)\n{\n    int i;\n\n    for (i = 0; i < sk_X509_POLICY_DATA_num(cache->data); i++) {\n        X509_POLICY_DATA *data = sk_X509_POLICY_DATA_value(cache->data, i);\n\n        /* Look for matching nodes in previous level */\n        if (!tree_link_matching_nodes(curr, data, tree))\n            return 0;\n    }\n    return 1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,6 @@\n static int tree_link_nodes(X509_POLICY_LEVEL *curr,\n-                           const X509_POLICY_CACHE *cache)\n+                           const X509_POLICY_CACHE *cache,\n+                           X509_POLICY_TREE *tree)\n {\n     int i;\n \n@@ -7,7 +8,7 @@\n         X509_POLICY_DATA *data = sk_X509_POLICY_DATA_value(cache->data, i);\n \n         /* Look for matching nodes in previous level */\n-        if (!tree_link_matching_nodes(curr, data))\n+        if (!tree_link_matching_nodes(curr, data, tree))\n             return 0;\n     }\n     return 1;",
        "diff_line_info": {
            "deleted_lines": [
                "                           const X509_POLICY_CACHE *cache)",
                "        if (!tree_link_matching_nodes(curr, data))"
            ],
            "added_lines": [
                "                           const X509_POLICY_CACHE *cache,",
                "                           X509_POLICY_TREE *tree)",
                "        if (!tree_link_matching_nodes(curr, data, tree))"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-0464",
        "func_name": "openssl/tree_add_unmatched",
        "description": "A security vulnerability has been identified in all supported versions\n\nof OpenSSL related to the verification of X.509 certificate chains\nthat include policy constraints.  Attackers may be able to exploit this\nvulnerability by creating a malicious certificate chain that triggers\nexponential use of computational resources, leading to a denial-of-service\n(DoS) attack on affected systems.\n\nPolicy processing is disabled by default but can be enabled by passing\nthe `-policy' argument to the command line utilities or by calling the\n`X509_VERIFY_PARAM_set1_policies()' function.",
        "git_url": "https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=2017771e2db3e2b96f89bbe8766c3209f6a99545",
        "commit_title": "",
        "commit_text": "x509: excessive resource use verifying policy constraints  A security vulnerability has been identified in all supported versions of OpenSSL related to the verification of X.509 certificate chains that include policy constraints.  Attackers may be able to exploit this vulnerability by creating a malicious certificate chain that triggers exponential use of computational resources, leading to a denial-of-service (DoS) attack on affected systems.  Fixes CVE-2023-0464  (Merged from https://github.com/openssl/openssl/pull/20570) ",
        "func_before": "static int tree_add_unmatched(X509_POLICY_LEVEL *curr,\n                              const X509_POLICY_CACHE *cache,\n                              const ASN1_OBJECT *id,\n                              X509_POLICY_NODE *node, X509_POLICY_TREE *tree)\n{\n    X509_POLICY_DATA *data;\n\n    if (id == NULL)\n        id = node->data->valid_policy;\n    /*\n     * Create a new node with qualifiers from anyPolicy and id from unmatched\n     * node.\n     */\n    if ((data = ossl_policy_data_new(NULL, id, node_critical(node))) == NULL)\n        return 0;\n\n    /* Curr may not have anyPolicy */\n    data->qualifier_set = cache->anyPolicy->qualifier_set;\n    data->flags |= POLICY_DATA_FLAG_SHARED_QUALIFIERS;\n    if (ossl_policy_level_add_node(curr, data, node, tree) == NULL) {\n        ossl_policy_data_free(data);\n        return 0;\n    }\n    return 1;\n}",
        "func": "static int tree_add_unmatched(X509_POLICY_LEVEL *curr,\n                              const X509_POLICY_CACHE *cache,\n                              const ASN1_OBJECT *id,\n                              X509_POLICY_NODE *node, X509_POLICY_TREE *tree)\n{\n    X509_POLICY_DATA *data;\n\n    if (id == NULL)\n        id = node->data->valid_policy;\n    /*\n     * Create a new node with qualifiers from anyPolicy and id from unmatched\n     * node.\n     */\n    if ((data = ossl_policy_data_new(NULL, id, node_critical(node))) == NULL)\n        return 0;\n\n    /* Curr may not have anyPolicy */\n    data->qualifier_set = cache->anyPolicy->qualifier_set;\n    data->flags |= POLICY_DATA_FLAG_SHARED_QUALIFIERS;\n    if (ossl_policy_level_add_node(curr, data, node, tree, 1) == NULL) {\n        ossl_policy_data_free(data);\n        return 0;\n    }\n    return 1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -17,7 +17,7 @@\n     /* Curr may not have anyPolicy */\n     data->qualifier_set = cache->anyPolicy->qualifier_set;\n     data->flags |= POLICY_DATA_FLAG_SHARED_QUALIFIERS;\n-    if (ossl_policy_level_add_node(curr, data, node, tree) == NULL) {\n+    if (ossl_policy_level_add_node(curr, data, node, tree, 1) == NULL) {\n         ossl_policy_data_free(data);\n         return 0;\n     }",
        "diff_line_info": {
            "deleted_lines": [
                "    if (ossl_policy_level_add_node(curr, data, node, tree) == NULL) {"
            ],
            "added_lines": [
                "    if (ossl_policy_level_add_node(curr, data, node, tree, 1) == NULL) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-0464",
        "func_name": "openssl/tree_calculate_user_set",
        "description": "A security vulnerability has been identified in all supported versions\n\nof OpenSSL related to the verification of X.509 certificate chains\nthat include policy constraints.  Attackers may be able to exploit this\nvulnerability by creating a malicious certificate chain that triggers\nexponential use of computational resources, leading to a denial-of-service\n(DoS) attack on affected systems.\n\nPolicy processing is disabled by default but can be enabled by passing\nthe `-policy' argument to the command line utilities or by calling the\n`X509_VERIFY_PARAM_set1_policies()' function.",
        "git_url": "https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=2017771e2db3e2b96f89bbe8766c3209f6a99545",
        "commit_title": "",
        "commit_text": "x509: excessive resource use verifying policy constraints  A security vulnerability has been identified in all supported versions of OpenSSL related to the verification of X.509 certificate chains that include policy constraints.  Attackers may be able to exploit this vulnerability by creating a malicious certificate chain that triggers exponential use of computational resources, leading to a denial-of-service (DoS) attack on affected systems.  Fixes CVE-2023-0464  (Merged from https://github.com/openssl/openssl/pull/20570) ",
        "func_before": "static int tree_calculate_user_set(X509_POLICY_TREE *tree,\n                                   STACK_OF(ASN1_OBJECT) *policy_oids,\n                                   STACK_OF(X509_POLICY_NODE) *auth_nodes)\n{\n    int i;\n    X509_POLICY_NODE *node;\n    ASN1_OBJECT *oid;\n    X509_POLICY_NODE *anyPolicy;\n    X509_POLICY_DATA *extra;\n\n    /*\n     * Check if anyPolicy present in authority constrained policy set: this\n     * will happen if it is a leaf node.\n     */\n    if (sk_ASN1_OBJECT_num(policy_oids) <= 0)\n        return 1;\n\n    anyPolicy = tree->levels[tree->nlevel - 1].anyPolicy;\n\n    for (i = 0; i < sk_ASN1_OBJECT_num(policy_oids); i++) {\n        oid = sk_ASN1_OBJECT_value(policy_oids, i);\n        if (OBJ_obj2nid(oid) == NID_any_policy) {\n            tree->flags |= POLICY_FLAG_ANY_POLICY;\n            return 1;\n        }\n    }\n\n    for (i = 0; i < sk_ASN1_OBJECT_num(policy_oids); i++) {\n        oid = sk_ASN1_OBJECT_value(policy_oids, i);\n        node = ossl_policy_tree_find_sk(auth_nodes, oid);\n        if (!node) {\n            if (!anyPolicy)\n                continue;\n            /*\n             * Create a new node with policy ID from user set and qualifiers\n             * from anyPolicy.\n             */\n            extra = ossl_policy_data_new(NULL, oid, node_critical(anyPolicy));\n            if (extra == NULL)\n                return 0;\n            extra->qualifier_set = anyPolicy->data->qualifier_set;\n            extra->flags = POLICY_DATA_FLAG_SHARED_QUALIFIERS\n                | POLICY_DATA_FLAG_EXTRA_NODE;\n            node = ossl_policy_level_add_node(NULL, extra, anyPolicy->parent,\n                                              tree);\n        }\n        if (!tree->user_policies) {\n            tree->user_policies = sk_X509_POLICY_NODE_new_null();\n            if (!tree->user_policies)\n                return 1;\n        }\n        if (!sk_X509_POLICY_NODE_push(tree->user_policies, node))\n            return 0;\n    }\n    return 1;\n}",
        "func": "static int tree_calculate_user_set(X509_POLICY_TREE *tree,\n                                   STACK_OF(ASN1_OBJECT) *policy_oids,\n                                   STACK_OF(X509_POLICY_NODE) *auth_nodes)\n{\n    int i;\n    X509_POLICY_NODE *node;\n    ASN1_OBJECT *oid;\n    X509_POLICY_NODE *anyPolicy;\n    X509_POLICY_DATA *extra;\n\n    /*\n     * Check if anyPolicy present in authority constrained policy set: this\n     * will happen if it is a leaf node.\n     */\n    if (sk_ASN1_OBJECT_num(policy_oids) <= 0)\n        return 1;\n\n    anyPolicy = tree->levels[tree->nlevel - 1].anyPolicy;\n\n    for (i = 0; i < sk_ASN1_OBJECT_num(policy_oids); i++) {\n        oid = sk_ASN1_OBJECT_value(policy_oids, i);\n        if (OBJ_obj2nid(oid) == NID_any_policy) {\n            tree->flags |= POLICY_FLAG_ANY_POLICY;\n            return 1;\n        }\n    }\n\n    for (i = 0; i < sk_ASN1_OBJECT_num(policy_oids); i++) {\n        oid = sk_ASN1_OBJECT_value(policy_oids, i);\n        node = ossl_policy_tree_find_sk(auth_nodes, oid);\n        if (!node) {\n            if (!anyPolicy)\n                continue;\n            /*\n             * Create a new node with policy ID from user set and qualifiers\n             * from anyPolicy.\n             */\n            extra = ossl_policy_data_new(NULL, oid, node_critical(anyPolicy));\n            if (extra == NULL)\n                return 0;\n            extra->qualifier_set = anyPolicy->data->qualifier_set;\n            extra->flags = POLICY_DATA_FLAG_SHARED_QUALIFIERS\n                | POLICY_DATA_FLAG_EXTRA_NODE;\n            node = ossl_policy_level_add_node(NULL, extra, anyPolicy->parent,\n                                              tree, 1);\n        }\n        if (!tree->user_policies) {\n            tree->user_policies = sk_X509_POLICY_NODE_new_null();\n            if (!tree->user_policies)\n                return 1;\n        }\n        if (!sk_X509_POLICY_NODE_push(tree->user_policies, node))\n            return 0;\n    }\n    return 1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -42,7 +42,7 @@\n             extra->flags = POLICY_DATA_FLAG_SHARED_QUALIFIERS\n                 | POLICY_DATA_FLAG_EXTRA_NODE;\n             node = ossl_policy_level_add_node(NULL, extra, anyPolicy->parent,\n-                                              tree);\n+                                              tree, 1);\n         }\n         if (!tree->user_policies) {\n             tree->user_policies = sk_X509_POLICY_NODE_new_null();",
        "diff_line_info": {
            "deleted_lines": [
                "                                              tree);"
            ],
            "added_lines": [
                "                                              tree, 1);"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-0465",
        "func_name": "openssl/check_policy",
        "description": "Applications that use a non-default option when verifying certificates may be\nvulnerable to an attack from a malicious CA to circumvent certain checks.\n\nInvalid certificate policies in leaf certificates are silently ignored by\nOpenSSL and other certificate policy checks are skipped for that certificate.\nA malicious CA could use this to deliberately assert invalid certificate policies\nin order to circumvent policy checking on the certificate altogether.\n\nPolicy processing is disabled by default but can be enabled by passing\nthe `-policy' argument to the command line utilities or by calling the\n`X509_VERIFY_PARAM_set1_policies()' function.",
        "git_url": "https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=facfb1ab745646e97a1920977ae4a9965ea61d5c",
        "commit_title": "",
        "commit_text": "Ensure that EXFLAG_INVALID_POLICY is checked even in leaf certs  Even though we check the leaf cert to confirm it is valid, we later ignored the invalid flag and did not notice that the leaf cert was bad.  (Merged from https://github.com/openssl/openssl/pull/20586) ",
        "func_before": "static int check_policy(X509_STORE_CTX *ctx)\n{\n    int ret;\n\n    if (ctx->parent)\n        return 1;\n    /*\n     * With DANE, the trust anchor might be a bare public key, not a\n     * certificate!  In that case our chain does not have the trust anchor\n     * certificate as a top-most element.  This comports well with RFC5280\n     * chain verification, since there too, the trust anchor is not part of the\n     * chain to be verified.  In particular, X509_policy_check() does not look\n     * at the TA cert, but assumes that it is present as the top-most chain\n     * element.  We therefore temporarily push a NULL cert onto the chain if it\n     * was verified via a bare public key, and pop it off right after the\n     * X509_policy_check() call.\n     */\n    if (ctx->bare_ta_signed && !sk_X509_push(ctx->chain, NULL))\n        goto memerr;\n    ret = X509_policy_check(&ctx->tree, &ctx->explicit_policy, ctx->chain,\n                            ctx->param->policies, ctx->param->flags);\n    if (ctx->bare_ta_signed)\n        (void)sk_X509_pop(ctx->chain);\n\n    if (ret == X509_PCY_TREE_INTERNAL)\n        goto memerr;\n    /* Invalid or inconsistent extensions */\n    if (ret == X509_PCY_TREE_INVALID) {\n        int i;\n\n        /* Locate certificates with bad extensions and notify callback. */\n        for (i = 1; i < sk_X509_num(ctx->chain); i++) {\n            X509 *x = sk_X509_value(ctx->chain, i);\n\n            CB_FAIL_IF((x->ex_flags & EXFLAG_INVALID_POLICY) != 0,\n                       ctx, x, i, X509_V_ERR_INVALID_POLICY_EXTENSION);\n        }\n        return 1;\n    }\n    if (ret == X509_PCY_TREE_FAILURE) {\n        ctx->current_cert = NULL;\n        ctx->error = X509_V_ERR_NO_EXPLICIT_POLICY;\n        return ctx->verify_cb(0, ctx);\n    }\n    if (ret != X509_PCY_TREE_VALID) {\n        ERR_raise(ERR_LIB_X509, ERR_R_INTERNAL_ERROR);\n        return 0;\n    }\n\n    if ((ctx->param->flags & X509_V_FLAG_NOTIFY_POLICY) != 0) {\n        ctx->current_cert = NULL;\n        /*\n         * Verification errors need to be \"sticky\", a callback may have allowed\n         * an SSL handshake to continue despite an error, and we must then\n         * remain in an error state.  Therefore, we MUST NOT clear earlier\n         * verification errors by setting the error to X509_V_OK.\n         */\n        if (!ctx->verify_cb(2, ctx))\n            return 0;\n    }\n\n    return 1;\n\n memerr:\n    ERR_raise(ERR_LIB_X509, ERR_R_MALLOC_FAILURE);\n    ctx->error = X509_V_ERR_OUT_OF_MEM;\n    return -1;\n}",
        "func": "static int check_policy(X509_STORE_CTX *ctx)\n{\n    int ret;\n\n    if (ctx->parent)\n        return 1;\n    /*\n     * With DANE, the trust anchor might be a bare public key, not a\n     * certificate!  In that case our chain does not have the trust anchor\n     * certificate as a top-most element.  This comports well with RFC5280\n     * chain verification, since there too, the trust anchor is not part of the\n     * chain to be verified.  In particular, X509_policy_check() does not look\n     * at the TA cert, but assumes that it is present as the top-most chain\n     * element.  We therefore temporarily push a NULL cert onto the chain if it\n     * was verified via a bare public key, and pop it off right after the\n     * X509_policy_check() call.\n     */\n    if (ctx->bare_ta_signed && !sk_X509_push(ctx->chain, NULL))\n        goto memerr;\n    ret = X509_policy_check(&ctx->tree, &ctx->explicit_policy, ctx->chain,\n                            ctx->param->policies, ctx->param->flags);\n    if (ctx->bare_ta_signed)\n        (void)sk_X509_pop(ctx->chain);\n\n    if (ret == X509_PCY_TREE_INTERNAL)\n        goto memerr;\n    /* Invalid or inconsistent extensions */\n    if (ret == X509_PCY_TREE_INVALID) {\n        int i, cbcalled = 0;\n\n        /* Locate certificates with bad extensions and notify callback. */\n        for (i = 0; i < sk_X509_num(ctx->chain); i++) {\n            X509 *x = sk_X509_value(ctx->chain, i);\n\n            if ((x->ex_flags & EXFLAG_INVALID_POLICY) != 0)\n                cbcalled = 1;\n            CB_FAIL_IF((x->ex_flags & EXFLAG_INVALID_POLICY) != 0,\n                       ctx, x, i, X509_V_ERR_INVALID_POLICY_EXTENSION);\n        }\n        if (!cbcalled) {\n            /* Should not be able to get here */\n            ERR_raise(ERR_LIB_X509, ERR_R_INTERNAL_ERROR);\n            return 0;\n        }\n        /* The callback ignored the error so we return success */\n        return 1;\n    }\n    if (ret == X509_PCY_TREE_FAILURE) {\n        ctx->current_cert = NULL;\n        ctx->error = X509_V_ERR_NO_EXPLICIT_POLICY;\n        return ctx->verify_cb(0, ctx);\n    }\n    if (ret != X509_PCY_TREE_VALID) {\n        ERR_raise(ERR_LIB_X509, ERR_R_INTERNAL_ERROR);\n        return 0;\n    }\n\n    if ((ctx->param->flags & X509_V_FLAG_NOTIFY_POLICY) != 0) {\n        ctx->current_cert = NULL;\n        /*\n         * Verification errors need to be \"sticky\", a callback may have allowed\n         * an SSL handshake to continue despite an error, and we must then\n         * remain in an error state.  Therefore, we MUST NOT clear earlier\n         * verification errors by setting the error to X509_V_OK.\n         */\n        if (!ctx->verify_cb(2, ctx))\n            return 0;\n    }\n\n    return 1;\n\n memerr:\n    ERR_raise(ERR_LIB_X509, ERR_R_MALLOC_FAILURE);\n    ctx->error = X509_V_ERR_OUT_OF_MEM;\n    return -1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -26,15 +26,23 @@\n         goto memerr;\n     /* Invalid or inconsistent extensions */\n     if (ret == X509_PCY_TREE_INVALID) {\n-        int i;\n+        int i, cbcalled = 0;\n \n         /* Locate certificates with bad extensions and notify callback. */\n-        for (i = 1; i < sk_X509_num(ctx->chain); i++) {\n+        for (i = 0; i < sk_X509_num(ctx->chain); i++) {\n             X509 *x = sk_X509_value(ctx->chain, i);\n \n+            if ((x->ex_flags & EXFLAG_INVALID_POLICY) != 0)\n+                cbcalled = 1;\n             CB_FAIL_IF((x->ex_flags & EXFLAG_INVALID_POLICY) != 0,\n                        ctx, x, i, X509_V_ERR_INVALID_POLICY_EXTENSION);\n         }\n+        if (!cbcalled) {\n+            /* Should not be able to get here */\n+            ERR_raise(ERR_LIB_X509, ERR_R_INTERNAL_ERROR);\n+            return 0;\n+        }\n+        /* The callback ignored the error so we return success */\n         return 1;\n     }\n     if (ret == X509_PCY_TREE_FAILURE) {",
        "diff_line_info": {
            "deleted_lines": [
                "        int i;",
                "        for (i = 1; i < sk_X509_num(ctx->chain); i++) {"
            ],
            "added_lines": [
                "        int i, cbcalled = 0;",
                "        for (i = 0; i < sk_X509_num(ctx->chain); i++) {",
                "            if ((x->ex_flags & EXFLAG_INVALID_POLICY) != 0)",
                "                cbcalled = 1;",
                "        if (!cbcalled) {",
                "            /* Should not be able to get here */",
                "            ERR_raise(ERR_LIB_X509, ERR_R_INTERNAL_ERROR);",
                "            return 0;",
                "        }",
                "        /* The callback ignored the error so we return success */"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-0465",
        "func_name": "openssl/check_policy",
        "description": "Applications that use a non-default option when verifying certificates may be\nvulnerable to an attack from a malicious CA to circumvent certain checks.\n\nInvalid certificate policies in leaf certificates are silently ignored by\nOpenSSL and other certificate policy checks are skipped for that certificate.\nA malicious CA could use this to deliberately assert invalid certificate policies\nin order to circumvent policy checking on the certificate altogether.\n\nPolicy processing is disabled by default but can be enabled by passing\nthe `-policy' argument to the command line utilities or by calling the\n`X509_VERIFY_PARAM_set1_policies()' function.",
        "git_url": "https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=1dd43e0709fece299b15208f36cc7c76209ba0bb",
        "commit_title": "",
        "commit_text": "Ensure that EXFLAG_INVALID_POLICY is checked even in leaf certs  Even though we check the leaf cert to confirm it is valid, we later ignored the invalid flag and did not notice that the leaf cert was bad.  (Merged from https://github.com/openssl/openssl/pull/20587) ",
        "func_before": "static int check_policy(X509_STORE_CTX *ctx)\n{\n    int ret;\n\n    if (ctx->parent)\n        return 1;\n    /*\n     * With DANE, the trust anchor might be a bare public key, not a\n     * certificate!  In that case our chain does not have the trust anchor\n     * certificate as a top-most element.  This comports well with RFC5280\n     * chain verification, since there too, the trust anchor is not part of the\n     * chain to be verified.  In particular, X509_policy_check() does not look\n     * at the TA cert, but assumes that it is present as the top-most chain\n     * element.  We therefore temporarily push a NULL cert onto the chain if it\n     * was verified via a bare public key, and pop it off right after the\n     * X509_policy_check() call.\n     */\n    if (ctx->bare_ta_signed && !sk_X509_push(ctx->chain, NULL))\n        goto memerr;\n    ret = X509_policy_check(&ctx->tree, &ctx->explicit_policy, ctx->chain,\n                            ctx->param->policies, ctx->param->flags);\n    if (ctx->bare_ta_signed)\n        (void)sk_X509_pop(ctx->chain);\n\n    if (ret == X509_PCY_TREE_INTERNAL)\n        goto memerr;\n    /* Invalid or inconsistent extensions */\n    if (ret == X509_PCY_TREE_INVALID) {\n        int i;\n\n        /* Locate certificates with bad extensions and notify callback. */\n        for (i = 1; i < sk_X509_num(ctx->chain); i++) {\n            X509 *x = sk_X509_value(ctx->chain, i);\n\n            CB_FAIL_IF((x->ex_flags & EXFLAG_INVALID_POLICY) != 0,\n                       ctx, x, i, X509_V_ERR_INVALID_POLICY_EXTENSION);\n        }\n        return 1;\n    }\n    if (ret == X509_PCY_TREE_FAILURE) {\n        ctx->current_cert = NULL;\n        ctx->error = X509_V_ERR_NO_EXPLICIT_POLICY;\n        return ctx->verify_cb(0, ctx);\n    }\n    if (ret != X509_PCY_TREE_VALID) {\n        ERR_raise(ERR_LIB_X509, ERR_R_INTERNAL_ERROR);\n        return 0;\n    }\n\n    if ((ctx->param->flags & X509_V_FLAG_NOTIFY_POLICY) != 0) {\n        ctx->current_cert = NULL;\n        /*\n         * Verification errors need to be \"sticky\", a callback may have allowed\n         * an SSL handshake to continue despite an error, and we must then\n         * remain in an error state.  Therefore, we MUST NOT clear earlier\n         * verification errors by setting the error to X509_V_OK.\n         */\n        if (!ctx->verify_cb(2, ctx))\n            return 0;\n    }\n\n    return 1;\n\n memerr:\n    ERR_raise(ERR_LIB_X509, ERR_R_MALLOC_FAILURE);\n    ctx->error = X509_V_ERR_OUT_OF_MEM;\n    return -1;\n}",
        "func": "static int check_policy(X509_STORE_CTX *ctx)\n{\n    int ret;\n\n    if (ctx->parent)\n        return 1;\n    /*\n     * With DANE, the trust anchor might be a bare public key, not a\n     * certificate!  In that case our chain does not have the trust anchor\n     * certificate as a top-most element.  This comports well with RFC5280\n     * chain verification, since there too, the trust anchor is not part of the\n     * chain to be verified.  In particular, X509_policy_check() does not look\n     * at the TA cert, but assumes that it is present as the top-most chain\n     * element.  We therefore temporarily push a NULL cert onto the chain if it\n     * was verified via a bare public key, and pop it off right after the\n     * X509_policy_check() call.\n     */\n    if (ctx->bare_ta_signed && !sk_X509_push(ctx->chain, NULL))\n        goto memerr;\n    ret = X509_policy_check(&ctx->tree, &ctx->explicit_policy, ctx->chain,\n                            ctx->param->policies, ctx->param->flags);\n    if (ctx->bare_ta_signed)\n        (void)sk_X509_pop(ctx->chain);\n\n    if (ret == X509_PCY_TREE_INTERNAL)\n        goto memerr;\n    /* Invalid or inconsistent extensions */\n    if (ret == X509_PCY_TREE_INVALID) {\n        int i, cbcalled = 0;\n\n        /* Locate certificates with bad extensions and notify callback. */\n        for (i = 0; i < sk_X509_num(ctx->chain); i++) {\n            X509 *x = sk_X509_value(ctx->chain, i);\n\n            if ((x->ex_flags & EXFLAG_INVALID_POLICY) != 0)\n                cbcalled = 1;\n            CB_FAIL_IF((x->ex_flags & EXFLAG_INVALID_POLICY) != 0,\n                       ctx, x, i, X509_V_ERR_INVALID_POLICY_EXTENSION);\n        }\n        if (!cbcalled) {\n            /* Should not be able to get here */\n            ERR_raise(ERR_LIB_X509, ERR_R_INTERNAL_ERROR);\n            return 0;\n        }\n        /* The callback ignored the error so we return success */\n        return 1;\n    }\n    if (ret == X509_PCY_TREE_FAILURE) {\n        ctx->current_cert = NULL;\n        ctx->error = X509_V_ERR_NO_EXPLICIT_POLICY;\n        return ctx->verify_cb(0, ctx);\n    }\n    if (ret != X509_PCY_TREE_VALID) {\n        ERR_raise(ERR_LIB_X509, ERR_R_INTERNAL_ERROR);\n        return 0;\n    }\n\n    if ((ctx->param->flags & X509_V_FLAG_NOTIFY_POLICY) != 0) {\n        ctx->current_cert = NULL;\n        /*\n         * Verification errors need to be \"sticky\", a callback may have allowed\n         * an SSL handshake to continue despite an error, and we must then\n         * remain in an error state.  Therefore, we MUST NOT clear earlier\n         * verification errors by setting the error to X509_V_OK.\n         */\n        if (!ctx->verify_cb(2, ctx))\n            return 0;\n    }\n\n    return 1;\n\n memerr:\n    ERR_raise(ERR_LIB_X509, ERR_R_MALLOC_FAILURE);\n    ctx->error = X509_V_ERR_OUT_OF_MEM;\n    return -1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -26,15 +26,23 @@\n         goto memerr;\n     /* Invalid or inconsistent extensions */\n     if (ret == X509_PCY_TREE_INVALID) {\n-        int i;\n+        int i, cbcalled = 0;\n \n         /* Locate certificates with bad extensions and notify callback. */\n-        for (i = 1; i < sk_X509_num(ctx->chain); i++) {\n+        for (i = 0; i < sk_X509_num(ctx->chain); i++) {\n             X509 *x = sk_X509_value(ctx->chain, i);\n \n+            if ((x->ex_flags & EXFLAG_INVALID_POLICY) != 0)\n+                cbcalled = 1;\n             CB_FAIL_IF((x->ex_flags & EXFLAG_INVALID_POLICY) != 0,\n                        ctx, x, i, X509_V_ERR_INVALID_POLICY_EXTENSION);\n         }\n+        if (!cbcalled) {\n+            /* Should not be able to get here */\n+            ERR_raise(ERR_LIB_X509, ERR_R_INTERNAL_ERROR);\n+            return 0;\n+        }\n+        /* The callback ignored the error so we return success */\n         return 1;\n     }\n     if (ret == X509_PCY_TREE_FAILURE) {",
        "diff_line_info": {
            "deleted_lines": [
                "        int i;",
                "        for (i = 1; i < sk_X509_num(ctx->chain); i++) {"
            ],
            "added_lines": [
                "        int i, cbcalled = 0;",
                "        for (i = 0; i < sk_X509_num(ctx->chain); i++) {",
                "            if ((x->ex_flags & EXFLAG_INVALID_POLICY) != 0)",
                "                cbcalled = 1;",
                "        if (!cbcalled) {",
                "            /* Should not be able to get here */",
                "            ERR_raise(ERR_LIB_X509, ERR_R_INTERNAL_ERROR);",
                "            return 0;",
                "        }",
                "        /* The callback ignored the error so we return success */"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-0465",
        "func_name": "openssl/check_policy",
        "description": "Applications that use a non-default option when verifying certificates may be\nvulnerable to an attack from a malicious CA to circumvent certain checks.\n\nInvalid certificate policies in leaf certificates are silently ignored by\nOpenSSL and other certificate policy checks are skipped for that certificate.\nA malicious CA could use this to deliberately assert invalid certificate policies\nin order to circumvent policy checking on the certificate altogether.\n\nPolicy processing is disabled by default but can be enabled by passing\nthe `-policy' argument to the command line utilities or by calling the\n`X509_VERIFY_PARAM_set1_policies()' function.",
        "git_url": "https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=b013765abfa80036dc779dd0e50602c57bb3bf95",
        "commit_title": "",
        "commit_text": "Ensure that EXFLAG_INVALID_POLICY is checked even in leaf certs  Even though we check the leaf cert to confirm it is valid, we later ignored the invalid flag and did not notice that the leaf cert was bad.  (Merged from https://github.com/openssl/openssl/pull/20588) ",
        "func_before": "static int check_policy(X509_STORE_CTX *ctx)\n{\n    int ret;\n\n    if (ctx->parent)\n        return 1;\n    /*\n     * With DANE, the trust anchor might be a bare public key, not a\n     * certificate!  In that case our chain does not have the trust anchor\n     * certificate as a top-most element.  This comports well with RFC5280\n     * chain verification, since there too, the trust anchor is not part of the\n     * chain to be verified.  In particular, X509_policy_check() does not look\n     * at the TA cert, but assumes that it is present as the top-most chain\n     * element.  We therefore temporarily push a NULL cert onto the chain if it\n     * was verified via a bare public key, and pop it off right after the\n     * X509_policy_check() call.\n     */\n    if (ctx->bare_ta_signed && !sk_X509_push(ctx->chain, NULL)) {\n        X509err(X509_F_CHECK_POLICY, ERR_R_MALLOC_FAILURE);\n        ctx->error = X509_V_ERR_OUT_OF_MEM;\n        return 0;\n    }\n    ret = X509_policy_check(&ctx->tree, &ctx->explicit_policy, ctx->chain,\n                            ctx->param->policies, ctx->param->flags);\n    if (ctx->bare_ta_signed)\n        sk_X509_pop(ctx->chain);\n\n    if (ret == X509_PCY_TREE_INTERNAL) {\n        X509err(X509_F_CHECK_POLICY, ERR_R_MALLOC_FAILURE);\n        ctx->error = X509_V_ERR_OUT_OF_MEM;\n        return 0;\n    }\n    /* Invalid or inconsistent extensions */\n    if (ret == X509_PCY_TREE_INVALID) {\n        int i;\n\n        /* Locate certificates with bad extensions and notify callback. */\n        for (i = 1; i < sk_X509_num(ctx->chain); i++) {\n            X509 *x = sk_X509_value(ctx->chain, i);\n\n            if (!(x->ex_flags & EXFLAG_INVALID_POLICY))\n                continue;\n            if (!verify_cb_cert(ctx, x, i,\n                                X509_V_ERR_INVALID_POLICY_EXTENSION))\n                return 0;\n        }\n        return 1;\n    }\n    if (ret == X509_PCY_TREE_FAILURE) {\n        ctx->current_cert = NULL;\n        ctx->error = X509_V_ERR_NO_EXPLICIT_POLICY;\n        return ctx->verify_cb(0, ctx);\n    }\n    if (ret != X509_PCY_TREE_VALID) {\n        X509err(X509_F_CHECK_POLICY, ERR_R_INTERNAL_ERROR);\n        return 0;\n    }\n\n    if (ctx->param->flags & X509_V_FLAG_NOTIFY_POLICY) {\n        ctx->current_cert = NULL;\n        /*\n         * Verification errors need to be \"sticky\", a callback may have allowed\n         * an SSL handshake to continue despite an error, and we must then\n         * remain in an error state.  Therefore, we MUST NOT clear earlier\n         * verification errors by setting the error to X509_V_OK.\n         */\n        if (!ctx->verify_cb(2, ctx))\n            return 0;\n    }\n\n    return 1;\n}",
        "func": "static int check_policy(X509_STORE_CTX *ctx)\n{\n    int ret;\n\n    if (ctx->parent)\n        return 1;\n    /*\n     * With DANE, the trust anchor might be a bare public key, not a\n     * certificate!  In that case our chain does not have the trust anchor\n     * certificate as a top-most element.  This comports well with RFC5280\n     * chain verification, since there too, the trust anchor is not part of the\n     * chain to be verified.  In particular, X509_policy_check() does not look\n     * at the TA cert, but assumes that it is present as the top-most chain\n     * element.  We therefore temporarily push a NULL cert onto the chain if it\n     * was verified via a bare public key, and pop it off right after the\n     * X509_policy_check() call.\n     */\n    if (ctx->bare_ta_signed && !sk_X509_push(ctx->chain, NULL)) {\n        X509err(X509_F_CHECK_POLICY, ERR_R_MALLOC_FAILURE);\n        ctx->error = X509_V_ERR_OUT_OF_MEM;\n        return 0;\n    }\n    ret = X509_policy_check(&ctx->tree, &ctx->explicit_policy, ctx->chain,\n                            ctx->param->policies, ctx->param->flags);\n    if (ctx->bare_ta_signed)\n        sk_X509_pop(ctx->chain);\n\n    if (ret == X509_PCY_TREE_INTERNAL) {\n        X509err(X509_F_CHECK_POLICY, ERR_R_MALLOC_FAILURE);\n        ctx->error = X509_V_ERR_OUT_OF_MEM;\n        return 0;\n    }\n    /* Invalid or inconsistent extensions */\n    if (ret == X509_PCY_TREE_INVALID) {\n        int i, cbcalled = 0;\n\n        /* Locate certificates with bad extensions and notify callback. */\n        for (i = 0; i < sk_X509_num(ctx->chain); i++) {\n            X509 *x = sk_X509_value(ctx->chain, i);\n\n            if (!(x->ex_flags & EXFLAG_INVALID_POLICY))\n                continue;\n            cbcalled = 1;\n            if (!verify_cb_cert(ctx, x, i,\n                                X509_V_ERR_INVALID_POLICY_EXTENSION))\n                return 0;\n        }\n        if (!cbcalled) {\n            /* Should not be able to get here */\n            X509err(X509_F_CHECK_POLICY, ERR_R_INTERNAL_ERROR);\n            return 0;\n        }\n        /* The callback ignored the error so we return success */\n        return 1;\n    }\n    if (ret == X509_PCY_TREE_FAILURE) {\n        ctx->current_cert = NULL;\n        ctx->error = X509_V_ERR_NO_EXPLICIT_POLICY;\n        return ctx->verify_cb(0, ctx);\n    }\n    if (ret != X509_PCY_TREE_VALID) {\n        X509err(X509_F_CHECK_POLICY, ERR_R_INTERNAL_ERROR);\n        return 0;\n    }\n\n    if (ctx->param->flags & X509_V_FLAG_NOTIFY_POLICY) {\n        ctx->current_cert = NULL;\n        /*\n         * Verification errors need to be \"sticky\", a callback may have allowed\n         * an SSL handshake to continue despite an error, and we must then\n         * remain in an error state.  Therefore, we MUST NOT clear earlier\n         * verification errors by setting the error to X509_V_OK.\n         */\n        if (!ctx->verify_cb(2, ctx))\n            return 0;\n    }\n\n    return 1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -32,18 +32,25 @@\n     }\n     /* Invalid or inconsistent extensions */\n     if (ret == X509_PCY_TREE_INVALID) {\n-        int i;\n+        int i, cbcalled = 0;\n \n         /* Locate certificates with bad extensions and notify callback. */\n-        for (i = 1; i < sk_X509_num(ctx->chain); i++) {\n+        for (i = 0; i < sk_X509_num(ctx->chain); i++) {\n             X509 *x = sk_X509_value(ctx->chain, i);\n \n             if (!(x->ex_flags & EXFLAG_INVALID_POLICY))\n                 continue;\n+            cbcalled = 1;\n             if (!verify_cb_cert(ctx, x, i,\n                                 X509_V_ERR_INVALID_POLICY_EXTENSION))\n                 return 0;\n         }\n+        if (!cbcalled) {\n+            /* Should not be able to get here */\n+            X509err(X509_F_CHECK_POLICY, ERR_R_INTERNAL_ERROR);\n+            return 0;\n+        }\n+        /* The callback ignored the error so we return success */\n         return 1;\n     }\n     if (ret == X509_PCY_TREE_FAILURE) {",
        "diff_line_info": {
            "deleted_lines": [
                "        int i;",
                "        for (i = 1; i < sk_X509_num(ctx->chain); i++) {"
            ],
            "added_lines": [
                "        int i, cbcalled = 0;",
                "        for (i = 0; i < sk_X509_num(ctx->chain); i++) {",
                "            cbcalled = 1;",
                "        if (!cbcalled) {",
                "            /* Should not be able to get here */",
                "            X509err(X509_F_CHECK_POLICY, ERR_R_INTERNAL_ERROR);",
                "            return 0;",
                "        }",
                "        /* The callback ignored the error so we return success */"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-48437",
        "func_name": "openbsd/src/x509_verify_ctx_add_chain",
        "description": "An issue was discovered in x509/x509_verify.c in LibreSSL before 3.6.1, and in OpenBSD before 7.2 errata 001. x509_verify_ctx_add_chain does not store errors that occur during leaf certificate verification, and therefore an incorrect error is returned. This behavior occurs when there is an installed verification callback that instructs the verifier to continue upon detecting an invalid certificate.",
        "git_url": "https://github.com/openbsd/src/commit/4f94258c65a918ee3d8670e93916d15bf879e6ec",
        "commit_title": "Store errors that result from leaf certificate verification.",
        "commit_text": " In the case that a verification callback is installed that tells the verifier to continue when a certificate is invalid (e.g. expired), any error resulting from the leaf certificate verification is not stored and made available post verification, resulting in an incorrect error being returned.  Also perform leaf certificate verification prior to adding the chain, which avoids a potential memory leak (as noted by tb@).  Issue reported by Ilya Shipitsin, who encountered haproxy regress failures.  ok tb@",
        "func_before": "static int\nx509_verify_ctx_add_chain(struct x509_verify_ctx *ctx,\n    struct x509_verify_chain *chain, char *name)\n{\n\tsize_t depth;\n\tX509 *last = x509_verify_chain_last(chain);\n\tX509 *leaf = x509_verify_chain_leaf(chain);\n\n\tdepth = sk_X509_num(chain->certs);\n\tif (depth > 0)\n\t\tdepth--;\n\n\tif (ctx->chains_count >= ctx->max_chains)\n\t\treturn x509_verify_cert_error(ctx, last, depth,\n\t\t    X509_V_ERR_CERT_CHAIN_TOO_LONG, 0);\n\n\t/* Clear a get issuer failure for a root certificate. */\n\tif (chain->cert_errors[depth] ==\n\t    X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY)\n\t\tchain->cert_errors[depth] = X509_V_OK;\n\n\tif (!x509_verify_ctx_validate_legacy_chain(ctx, chain, depth))\n\t\treturn 0;\n\n\t/*\n\t * In the non-legacy code, extensions and purpose are dealt\n\t * with as the chain is built.\n\t *\n\t * The non-legacy api returns multiple chains but does not do\n\t * any revocation checking (it must be done by the caller on\n\t * any chain they wish to use)\n\t */\n\n\tif ((ctx->chains[ctx->chains_count] = x509_verify_chain_dup(chain)) ==\n\t    NULL) {\n\t\treturn x509_verify_cert_error(ctx, last, depth,\n\t\t    X509_V_ERR_OUT_OF_MEM, 0);\n\t}\n\n\tif (!x509_verify_cert_valid(ctx, leaf, NULL))\n\t\treturn 0;\n\n\tif (!x509_verify_cert_hostname(ctx, leaf, name))\n\t\treturn 0;\n\n\tctx->chains_count++;\n\tctx->error = X509_V_OK;\n\tctx->error_depth = depth;\n\treturn 1;\n}",
        "func": "static int\nx509_verify_ctx_add_chain(struct x509_verify_ctx *ctx,\n    struct x509_verify_chain *chain, char *name)\n{\n\tsize_t depth;\n\tX509 *last = x509_verify_chain_last(chain);\n\tX509 *leaf = x509_verify_chain_leaf(chain);\n\n\tdepth = sk_X509_num(chain->certs);\n\tif (depth > 0)\n\t\tdepth--;\n\n\tif (ctx->chains_count >= ctx->max_chains)\n\t\treturn x509_verify_cert_error(ctx, last, depth,\n\t\t    X509_V_ERR_CERT_CHAIN_TOO_LONG, 0);\n\n\t/* Clear a get issuer failure for a root certificate. */\n\tif (chain->cert_errors[depth] ==\n\t    X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY)\n\t\tchain->cert_errors[depth] = X509_V_OK;\n\n\tif (!x509_verify_ctx_validate_legacy_chain(ctx, chain, depth))\n\t\treturn 0;\n\n\t/* Verify the leaf certificate and store any resulting error. */\n\tif (!x509_verify_cert_valid(ctx, leaf, NULL))\n\t\treturn 0;\n\tif (!x509_verify_cert_hostname(ctx, leaf, name))\n\t\treturn 0;\n\tif (ctx->error_depth == 0 &&\n\t    ctx->error != X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY)\n\t\tchain->cert_errors[0] = ctx->error;\n\n\t/*\n\t * In the non-legacy code, extensions and purpose are dealt\n\t * with as the chain is built.\n\t *\n\t * The non-legacy api returns multiple chains but does not do\n\t * any revocation checking (it must be done by the caller on\n\t * any chain they wish to use)\n\t */\n\n\tif ((ctx->chains[ctx->chains_count] = x509_verify_chain_dup(chain)) ==\n\t    NULL) {\n\t\treturn x509_verify_cert_error(ctx, last, depth,\n\t\t    X509_V_ERR_OUT_OF_MEM, 0);\n\t}\n\tctx->chains_count++;\n\n\tctx->error = X509_V_OK;\n\tctx->error_depth = depth;\n\n\treturn 1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -22,6 +22,15 @@\n \tif (!x509_verify_ctx_validate_legacy_chain(ctx, chain, depth))\n \t\treturn 0;\n \n+\t/* Verify the leaf certificate and store any resulting error. */\n+\tif (!x509_verify_cert_valid(ctx, leaf, NULL))\n+\t\treturn 0;\n+\tif (!x509_verify_cert_hostname(ctx, leaf, name))\n+\t\treturn 0;\n+\tif (ctx->error_depth == 0 &&\n+\t    ctx->error != X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY)\n+\t\tchain->cert_errors[0] = ctx->error;\n+\n \t/*\n \t * In the non-legacy code, extensions and purpose are dealt\n \t * with as the chain is built.\n@@ -36,15 +45,10 @@\n \t\treturn x509_verify_cert_error(ctx, last, depth,\n \t\t    X509_V_ERR_OUT_OF_MEM, 0);\n \t}\n+\tctx->chains_count++;\n \n-\tif (!x509_verify_cert_valid(ctx, leaf, NULL))\n-\t\treturn 0;\n-\n-\tif (!x509_verify_cert_hostname(ctx, leaf, name))\n-\t\treturn 0;\n-\n-\tctx->chains_count++;\n \tctx->error = X509_V_OK;\n \tctx->error_depth = depth;\n+\n \treturn 1;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (!x509_verify_cert_valid(ctx, leaf, NULL))",
                "\t\treturn 0;",
                "",
                "\tif (!x509_verify_cert_hostname(ctx, leaf, name))",
                "\t\treturn 0;",
                "",
                "\tctx->chains_count++;"
            ],
            "added_lines": [
                "\t/* Verify the leaf certificate and store any resulting error. */",
                "\tif (!x509_verify_cert_valid(ctx, leaf, NULL))",
                "\t\treturn 0;",
                "\tif (!x509_verify_cert_hostname(ctx, leaf, name))",
                "\t\treturn 0;",
                "\tif (ctx->error_depth == 0 &&",
                "\t    ctx->error != X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY)",
                "\t\tchain->cert_errors[0] = ctx->error;",
                "",
                "\tctx->chains_count++;",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2019-19270",
        "func_name": "proftpd/tls_verify_crl",
        "description": "An issue was discovered in tls_verify_crl in ProFTPD through 1.3.6b. Failure to check for the appropriate field of a CRL entry (checking twice for subject, rather than once for subject and once for issuer) prevents some valid CRLs from being taken into account, and can allow clients whose certificates have been revoked to proceed with a connection to the server.",
        "git_url": "https://github.com/proftpd/proftpd/commit/81cc5dce4fc0285629a1b08a07a109af10c208dd",
        "commit_title": "Issue #859, #861: Fix handling of CRL lookups by properly using issuer for",
        "commit_text": "lookups, and guarding against null pointers.",
        "func_before": "static int tls_verify_crl(int ok, X509_STORE_CTX *ctx) {\n  register int i = 0;\n  X509_NAME *subject = NULL, *issuer = NULL;\n  X509 *xs = NULL;\n  STACK_OF(X509_CRL) *crls = NULL;\n  X509_STORE_CTX *store_ctx = NULL;\n  int n, res;\n\n  /* Unless a revocation store for CRLs was created we cannot do any\n   * CRL-based verification, of course.\n   */\n  if (!tls_crl_store) {\n    return ok;\n  }\n\n  tls_log(\"%s\",\n    \"CRL store present, checking client certificate against configured CRLs\");\n\n  /* Determine certificate ingredients in advance. */\n  xs = X509_STORE_CTX_get_current_cert(ctx);\n\n  subject = X509_get_subject_name(xs);\n  pr_trace_msg(trace_channel, 15,\n    \"verifying cert: subject = '%s'\", tls_x509_name_oneline(subject));\n\n  issuer = X509_get_issuer_name(xs);\n  pr_trace_msg(trace_channel, 15,\n    \"verifying cert: issuer = '%s'\", tls_x509_name_oneline(issuer));\n\n  /* OpenSSL provides the general mechanism to deal with CRLs but does not\n   * use them automatically when verifying certificates, so we do it\n   * explicitly here. We will check the CRL for the currently checked\n   * certificate, if there is such a CRL in the store.\n   *\n   * We come through this procedure for each certificate in the certificate\n   * chain, starting with the root-CA's certificate. At each step we've to\n   * both verify the signature on the CRL (to make sure it's a valid CRL)\n   * and its revocation list (to make sure the current certificate isn't\n   * revoked).  But because to check the signature on the CRL we need the\n   * public key of the issuing CA certificate (which was already processed\n   * one round before), we've a little problem. But we can both solve it and\n   * at the same time optimize the processing by using the following\n   * verification scheme (idea and code snippets borrowed from the GLOBUS\n   * project):\n   *\n   * 1. We'll check the signature of a CRL in each step when we find a CRL\n   *    through the _subject_ name of the current certificate. This CRL\n   *    itself will be needed the first time in the next round, of course.\n   *    But we do the signature processing one round before this where the\n   *    public key of the CA is available.\n   *\n   * 2. We'll check the revocation list of a CRL in each step when\n   *    we find a CRL through the _issuer_ name of the current certificate.\n   *    This CRLs signature was then already verified one round before.\n   *\n   * This verification scheme allows a CA to revoke its own certificate as\n   * well, of course.\n   */\n\n  /* Try to retrieve a CRL corresponding to the _subject_ of\n   * the current certificate in order to verify its integrity.\n   */\n  store_ctx = X509_STORE_CTX_new();\n#if OPENSSL_VERSION_NUMBER > 0x000907000L\n  if (X509_STORE_CTX_init(store_ctx, tls_crl_store, NULL, NULL) <= 0) {\n    tls_log(\"error initializing CRL store context: %s\", tls_get_errors());\n    X509_STORE_CTX_free(store_ctx);\n    return ok;\n  }\n#else\n  X509_STORE_CTX_init(store_ctx, tls_crl_store, NULL, NULL);\n#endif\n\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L && \\\n    !defined(HAVE_LIBRESSL)\n  crls = X509_STORE_CTX_get1_crls(store_ctx, subject);\n#elif OPENSSL_VERSION_NUMBER >= 0x10000000L && \\\n      !defined(HAVE_LIBRESSL)\n  crls = X509_STORE_get1_crls(store_ctx, subject);\n#else\n  /* Your OpenSSL is before 1.0.0.  You really need to upgrade. */\n  crls = NULL;\n#endif /* OpenSSL-1.1.x and later */\n  if (crls != NULL) {\n    for (i = 0; i < sk_X509_CRL_num(crls); i++) {\n      X509_CRL *crl = NULL;\n      EVP_PKEY *pubkey;\n      char buf[512];\n      int len;\n      BIO *b = BIO_new(BIO_s_mem());\n\n      crl = sk_X509_CRL_value(crls, i);\n      BIO_printf(b, \"CA CRL: Issuer: \");\n      X509_NAME_print(b, issuer, 0);\n\n      BIO_printf(b, \", lastUpdate: \");\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n      ASN1_UTCTIME_print(b, X509_CRL_get_lastUpdate(crl));\n#else\n      ASN1_UTCTIME_print(b, crl->crl->lastUpdate);\n#endif /* OpenSSL-1.1.x and later */\n\n      BIO_printf(b, \", nextUpdate: \");\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n      ASN1_UTCTIME_print(b, X509_CRL_get_nextUpdate(crl));\n#else\n      ASN1_UTCTIME_print(b, crl->crl->nextUpdate);\n#endif /* OpenSSL-1.1.x and later */\n\n      len = BIO_read(b, buf, sizeof(buf) - 1);\n      if ((size_t) len >= sizeof(buf)) {\n        len = sizeof(buf)-1;\n      }\n      buf[len] = '\\0';\n\n      BIO_free(b);\n      tls_log(\"%s\", buf);\n\n      pubkey = X509_get_pubkey(xs);\n\n      /* Verify the signature on this CRL */\n      res = X509_CRL_verify(crl, pubkey);\n      if (pubkey) {\n        EVP_PKEY_free(pubkey);\n      }\n\n      if (res <= 0) {\n        tls_log(\"invalid signature on CRL: %s\", tls_get_errors());\n\n        X509_STORE_CTX_set_error(ctx, X509_V_ERR_CRL_SIGNATURE_FAILURE);\n        sk_X509_CRL_free(crls);\n        X509_STORE_CTX_cleanup(store_ctx);\n        X509_STORE_CTX_free(store_ctx);\n        return FALSE;\n      }\n\n      /* Check date of CRL to make sure it's not expired */\n      res = X509_cmp_current_time(X509_CRL_get_nextUpdate(crl));\n      if (res == 0) {\n        tls_log(\"CRL has invalid nextUpdate field: %s\", tls_get_errors());\n\n        X509_STORE_CTX_set_error(ctx,\n          X509_V_ERR_ERROR_IN_CRL_NEXT_UPDATE_FIELD);\n        sk_X509_CRL_free(crls);\n        X509_STORE_CTX_cleanup(store_ctx);\n        X509_STORE_CTX_free(store_ctx);\n        return FALSE;\n      }\n\n      if (res < 0) {\n        /* XXX This is a bit draconian, rejecting all certificates if the CRL\n         * has expired.  See also Bug#3216, about automatically reloading\n         * the CRL file when it has expired.\n         */\n        tls_log(\"%s\", \"CRL is expired, revoking all certificates until an \"\n          \"updated CRL is obtained\");\n\n        X509_STORE_CTX_set_error(ctx, X509_V_ERR_CRL_HAS_EXPIRED);\n        sk_X509_CRL_free(crls);\n        X509_STORE_CTX_cleanup(store_ctx);\n        X509_STORE_CTX_free(store_ctx);\n        return FALSE;\n      }\n    }\n\n    sk_X509_CRL_free(crls);\n    crls = NULL;\n  }\n\n  /* Try to retrieve a CRL corresponding to the _issuer_ of\n   * the current certificate in order to check for revocation.\n   */\n\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L && \\\n    !defined(HAVE_LIBRESSL)\n  crls = X509_STORE_CTX_get1_crls(store_ctx, subject);\n#elif OPENSSL_VERSION_NUMBER >= 0x10000000L && \\\n      !defined(HAVE_LIBRESSL)\n  crls = X509_STORE_get1_crls(store_ctx, subject);\n#else\n  /* Your OpenSSL is before 1.0.0.  You really need to upgrade. */\n  crls = NULL;\n#endif /* OpenSSL-1.1.x and later */\n  if (crls != NULL) {\n    for (i = 0; i < sk_X509_CRL_num(crls); i++) {\n      register int j;\n      X509_CRL *crl;\n\n      crl = sk_X509_CRL_value(crls, i);\n\n      /* Check if the current certificate is revoked by this CRL */\n      n = sk_X509_REVOKED_num(X509_CRL_get_REVOKED(crl));\n      for (j = 0; j < n; j++) {\n        X509_REVOKED *revoked;\n        ASN1_INTEGER *sn;\n\n        revoked = sk_X509_REVOKED_value(X509_CRL_get_REVOKED(crl), j);\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L && \\\n    !defined(HAVE_LIBRESSL)\n        sn = X509_REVOKED_get0_serialNumber(revoked);\n#else\n        sn = revoked->serialNumber;\n#endif /* OpenSSL-1.1.x and later */\n\n        if (ASN1_INTEGER_cmp(sn, X509_get_serialNumber(xs)) == 0) {\n          long serial = ASN1_INTEGER_get(sn);\n          char *cp = tls_x509_name_oneline(issuer);\n\n          tls_log(\"certificate with serial number %ld (0x%lX) revoked per CRL \"\n            \"from issuer '%s'\", serial, serial, cp ? cp : \"(ERROR)\");\n\n          X509_STORE_CTX_set_error(ctx, X509_V_ERR_CERT_REVOKED);\n          sk_X509_CRL_free(crls);\n          X509_STORE_CTX_cleanup(store_ctx);\n          X509_STORE_CTX_free(store_ctx);\n          return FALSE;\n        }\n      }\n    }\n\n    sk_X509_CRL_free(crls);\n  }\n\n  X509_STORE_CTX_cleanup(store_ctx);\n  X509_STORE_CTX_free(store_ctx);\n  return ok;\n}",
        "func": "static int tls_verify_crl(int ok, X509_STORE_CTX *ctx) {\n  register int i = 0;\n  X509_NAME *subject = NULL, *issuer = NULL;\n  X509 *xs = NULL;\n  STACK_OF(X509_CRL) *crls = NULL;\n  X509_STORE_CTX *store_ctx = NULL;\n  int n, res;\n\n  /* Unless a revocation store for CRLs was created we cannot do any\n   * CRL-based verification, of course.\n   */\n  if (!tls_crl_store) {\n    return ok;\n  }\n\n  tls_log(\"%s\",\n    \"CRL store present, checking client certificate against configured CRLs\");\n\n  /* Determine certificate ingredients in advance. */\n  xs = X509_STORE_CTX_get_current_cert(ctx);\n\n  subject = X509_get_subject_name(xs);\n  pr_trace_msg(trace_channel, 15,\n    \"verifying cert: subject = '%s'\", tls_x509_name_oneline(subject));\n\n  issuer = X509_get_issuer_name(xs);\n  pr_trace_msg(trace_channel, 15,\n    \"verifying cert: issuer = '%s'\", tls_x509_name_oneline(issuer));\n\n  /* OpenSSL provides the general mechanism to deal with CRLs but does not\n   * use them automatically when verifying certificates, so we do it\n   * explicitly here. We will check the CRL for the currently checked\n   * certificate, if there is such a CRL in the store.\n   *\n   * We come through this procedure for each certificate in the certificate\n   * chain, starting with the root-CA's certificate. At each step we've to\n   * both verify the signature on the CRL (to make sure it's a valid CRL)\n   * and its revocation list (to make sure the current certificate isn't\n   * revoked).  But because to check the signature on the CRL we need the\n   * public key of the issuing CA certificate (which was already processed\n   * one round before), we've a little problem. But we can both solve it and\n   * at the same time optimize the processing by using the following\n   * verification scheme (idea and code snippets borrowed from the GLOBUS\n   * project):\n   *\n   * 1. We'll check the signature of a CRL in each step when we find a CRL\n   *    through the _subject_ name of the current certificate. This CRL\n   *    itself will be needed the first time in the next round, of course.\n   *    But we do the signature processing one round before this where the\n   *    public key of the CA is available.\n   *\n   * 2. We'll check the revocation list of a CRL in each step when\n   *    we find a CRL through the _issuer_ name of the current certificate.\n   *    This CRLs signature was then already verified one round before.\n   *\n   * This verification scheme allows a CA to revoke its own certificate as\n   * well, of course.\n   */\n\n  /* Try to retrieve a CRL corresponding to the _subject_ of\n   * the current certificate in order to verify its integrity.\n   */\n  store_ctx = X509_STORE_CTX_new();\n#if OPENSSL_VERSION_NUMBER > 0x000907000L\n  if (X509_STORE_CTX_init(store_ctx, tls_crl_store, NULL, NULL) <= 0) {\n    tls_log(\"error initializing CRL store context: %s\", tls_get_errors());\n    X509_STORE_CTX_free(store_ctx);\n    return ok;\n  }\n#else\n  X509_STORE_CTX_init(store_ctx, tls_crl_store, NULL, NULL);\n#endif\n\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L && \\\n    !defined(HAVE_LIBRESSL)\n  crls = X509_STORE_CTX_get1_crls(store_ctx, subject);\n#elif OPENSSL_VERSION_NUMBER >= 0x10000000L && \\\n      !defined(HAVE_LIBRESSL)\n  crls = X509_STORE_get1_crls(store_ctx, subject);\n#else\n  /* Your OpenSSL is before 1.0.0.  You really need to upgrade. */\n  crls = NULL;\n#endif /* OpenSSL-1.1.x and later */\n  if (crls != NULL) {\n    for (i = 0; i < sk_X509_CRL_num(crls); i++) {\n      X509_CRL *crl = NULL;\n      EVP_PKEY *pubkey;\n      char buf[512];\n      int len;\n      BIO *b = BIO_new(BIO_s_mem());\n\n      crl = sk_X509_CRL_value(crls, i);\n      BIO_printf(b, \"CA CRL: Issuer: \");\n      X509_NAME_print(b, issuer, 0);\n\n      BIO_printf(b, \", lastUpdate: \");\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n      ASN1_UTCTIME_print(b, X509_CRL_get_lastUpdate(crl));\n#else\n      ASN1_UTCTIME_print(b, crl->crl->lastUpdate);\n#endif /* OpenSSL-1.1.x and later */\n\n      BIO_printf(b, \", nextUpdate: \");\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n      ASN1_UTCTIME_print(b, X509_CRL_get_nextUpdate(crl));\n#else\n      ASN1_UTCTIME_print(b, crl->crl->nextUpdate);\n#endif /* OpenSSL-1.1.x and later */\n\n      len = BIO_read(b, buf, sizeof(buf) - 1);\n      if ((size_t) len >= sizeof(buf)) {\n        len = sizeof(buf)-1;\n      }\n      buf[len] = '\\0';\n\n      BIO_free(b);\n      tls_log(\"%s\", buf);\n\n      pubkey = X509_get_pubkey(xs);\n\n      /* Verify the signature on this CRL */\n      res = X509_CRL_verify(crl, pubkey);\n      if (pubkey) {\n        EVP_PKEY_free(pubkey);\n      }\n\n      if (res <= 0) {\n        tls_log(\"invalid signature on CRL: %s\", tls_get_errors());\n\n        X509_STORE_CTX_set_error(ctx, X509_V_ERR_CRL_SIGNATURE_FAILURE);\n        sk_X509_CRL_free(crls);\n        X509_STORE_CTX_cleanup(store_ctx);\n        X509_STORE_CTX_free(store_ctx);\n        return FALSE;\n      }\n\n      /* Check date of CRL to make sure it's not expired */\n      res = X509_cmp_current_time(X509_CRL_get_nextUpdate(crl));\n      if (res == 0) {\n        tls_log(\"CRL has invalid nextUpdate field: %s\", tls_get_errors());\n\n        X509_STORE_CTX_set_error(ctx,\n          X509_V_ERR_ERROR_IN_CRL_NEXT_UPDATE_FIELD);\n        sk_X509_CRL_free(crls);\n        X509_STORE_CTX_cleanup(store_ctx);\n        X509_STORE_CTX_free(store_ctx);\n        return FALSE;\n      }\n\n      if (res < 0) {\n        /* XXX This is a bit draconian, rejecting all certificates if the CRL\n         * has expired.  See also Bug#3216, about automatically reloading\n         * the CRL file when it has expired.\n         */\n        tls_log(\"%s\", \"CRL is expired, revoking all certificates until an \"\n          \"updated CRL is obtained\");\n\n        X509_STORE_CTX_set_error(ctx, X509_V_ERR_CRL_HAS_EXPIRED);\n        sk_X509_CRL_free(crls);\n        X509_STORE_CTX_cleanup(store_ctx);\n        X509_STORE_CTX_free(store_ctx);\n        return FALSE;\n      }\n    }\n\n    sk_X509_CRL_free(crls);\n    crls = NULL;\n  }\n\n  /* Try to retrieve a CRL corresponding to the _issuer_ of\n   * the current certificate in order to check for revocation.\n   */\n\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L && \\\n    !defined(HAVE_LIBRESSL)\n  crls = X509_STORE_CTX_get1_crls(store_ctx, issuer);\n#elif OPENSSL_VERSION_NUMBER >= 0x10000000L && \\\n      !defined(HAVE_LIBRESSL)\n  crls = X509_STORE_get1_crls(store_ctx, issuer);\n#else\n  /* Your OpenSSL is before 1.0.0.  You really need to upgrade. */\n  crls = NULL;\n#endif /* OpenSSL-1.1.x and later */\n  if (crls != NULL) {\n    for (i = 0; i < sk_X509_CRL_num(crls); i++) {\n      register int j;\n      X509_CRL *crl;\n\n      crl = sk_X509_CRL_value(crls, i);\n\n      /* Check if the current certificate is revoked by this CRL */\n      n = sk_X509_REVOKED_num(X509_CRL_get_REVOKED(crl));\n      for (j = 0; j < n; j++) {\n        X509_REVOKED *revoked;\n        ASN1_INTEGER *sn;\n\n        revoked = sk_X509_REVOKED_value(X509_CRL_get_REVOKED(crl), j);\n        if (revoked == NULL) {\n          continue;\n        }\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L && \\\n    !defined(HAVE_LIBRESSL)\n        sn = X509_REVOKED_get0_serialNumber(revoked);\n#else\n        sn = revoked->serialNumber;\n#endif /* OpenSSL-1.1.x and later */\n\n        if (ASN1_INTEGER_cmp(sn, X509_get_serialNumber(xs)) == 0) {\n          long serial = ASN1_INTEGER_get(sn);\n          char *cp = tls_x509_name_oneline(issuer);\n\n          tls_log(\"certificate with serial number %ld (0x%lX) revoked per CRL \"\n            \"from issuer '%s'\", serial, serial, cp ? cp : \"(ERROR)\");\n\n          X509_STORE_CTX_set_error(ctx, X509_V_ERR_CERT_REVOKED);\n          sk_X509_CRL_free(crls);\n          X509_STORE_CTX_cleanup(store_ctx);\n          X509_STORE_CTX_free(store_ctx);\n          return FALSE;\n        }\n      }\n    }\n\n    sk_X509_CRL_free(crls);\n  }\n\n  X509_STORE_CTX_cleanup(store_ctx);\n  X509_STORE_CTX_free(store_ctx);\n  return ok;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -173,10 +173,10 @@\n \n #if OPENSSL_VERSION_NUMBER >= 0x10100000L && \\\n     !defined(HAVE_LIBRESSL)\n-  crls = X509_STORE_CTX_get1_crls(store_ctx, subject);\n+  crls = X509_STORE_CTX_get1_crls(store_ctx, issuer);\n #elif OPENSSL_VERSION_NUMBER >= 0x10000000L && \\\n       !defined(HAVE_LIBRESSL)\n-  crls = X509_STORE_get1_crls(store_ctx, subject);\n+  crls = X509_STORE_get1_crls(store_ctx, issuer);\n #else\n   /* Your OpenSSL is before 1.0.0.  You really need to upgrade. */\n   crls = NULL;\n@@ -195,6 +195,9 @@\n         ASN1_INTEGER *sn;\n \n         revoked = sk_X509_REVOKED_value(X509_CRL_get_REVOKED(crl), j);\n+        if (revoked == NULL) {\n+          continue;\n+        }\n #if OPENSSL_VERSION_NUMBER >= 0x10100000L && \\\n     !defined(HAVE_LIBRESSL)\n         sn = X509_REVOKED_get0_serialNumber(revoked);",
        "diff_line_info": {
            "deleted_lines": [
                "  crls = X509_STORE_CTX_get1_crls(store_ctx, subject);",
                "  crls = X509_STORE_get1_crls(store_ctx, subject);"
            ],
            "added_lines": [
                "  crls = X509_STORE_CTX_get1_crls(store_ctx, issuer);",
                "  crls = X509_STORE_get1_crls(store_ctx, issuer);",
                "        if (revoked == NULL) {",
                "          continue;",
                "        }"
            ]
        }
    },
    {
        "cve_id": "CVE-2015-3886",
        "func_name": "gobby/libinfinity/inf_gtk_certificate_manager_certificate_func",
        "description": "libinfinity before 0.6.6-1 does not validate expired SSL certificates, which allows remote attackers to have unspecified impact via unknown vectors.",
        "git_url": "https://github.com/gobby/libinfinity/commit/c97f870f5ae13112988d9f8ad464b4f679903706",
        "commit_title": "Fix expired certificate validation (gobby #61)",
        "commit_text": "",
        "func_before": "static void\ninf_gtk_certificate_manager_certificate_func(InfXmppConnection* connection,\n                                             gnutls_session_t session,\n                                             InfCertificateChain* chain,\n                                             gpointer user_data)\n{\n  InfGtkCertificateManager* manager;\n  InfGtkCertificateManagerPrivate* priv;\n\n  InfGtkCertificateDialogFlags flags;\n  gnutls_x509_crt_t presented_cert;\n  gnutls_x509_crt_t known_cert;\n  gchar* hostname;\n\n  gboolean match_hostname;\n  gboolean issuer_known;\n  gnutls_x509_crt_t root_cert;\n\n  int ret;\n  unsigned int verify;\n  GHashTable* table;\n  gboolean cert_equal;\n  time_t expiration_time;\n\n  InfGtkCertificateManagerQuery* query;\n  gchar* text;\n  GtkWidget* vbox;\n  GtkWidget* label;\n\n  GError* error;\n\n  manager = INF_GTK_CERTIFICATE_MANAGER(user_data);\n  priv = INF_GTK_CERTIFICATE_MANAGER_PRIVATE(manager);\n\n  g_object_get(G_OBJECT(connection), \"remote-hostname\", &hostname, NULL);\n  presented_cert = inf_certificate_chain_get_own_certificate(chain);\n\n  match_hostname = gnutls_x509_crt_check_hostname(presented_cert, hostname);\n\n  /* First, validate the certificate */\n  ret = gnutls_certificate_verify_peers2(session, &verify);\n  error = NULL;\n\n  if(ret != GNUTLS_E_SUCCESS)\n    inf_gnutls_set_error(&error, ret);\n\n  /* Remove the GNUTLS_CERT_ISSUER_NOT_KNOWN flag from the verification\n   * result, and if the certificate is still invalid, then set an error. */\n  if(error == NULL)\n  {\n    issuer_known = TRUE;\n    if(verify & GNUTLS_CERT_SIGNER_NOT_FOUND)\n    {\n      issuer_known = FALSE;\n\n      /* Re-validate the certificate for other failure reasons --\n       * unfortunately the gnutls_certificate_verify_peers2() call\n       * does not tell us whether the certificate is otherwise invalid\n       * if a signer is not found already. */\n      /* TODO: Here it would be good to use the verify flags from the\n       * certificate credentials, but GnuTLS does not have API to\n       * retrieve them. */\n      root_cert = inf_certificate_chain_get_root_certificate(chain);\n\n      ret = gnutls_x509_crt_list_verify(\n        inf_certificate_chain_get_raw(chain),\n        inf_certificate_chain_get_n_certificates(chain),\n        &root_cert,\n        1,\n        NULL,\n        0,\n        GNUTLS_VERIFY_ALLOW_X509_V1_CA_CRT,\n        &verify\n      );\n\n      if(ret != GNUTLS_E_SUCCESS)\n        inf_gnutls_set_error(&error, ret);\n      else if(verify & GNUTLS_CERT_INVALID)\n        inf_gnutls_certificate_verification_set_error(&error, verify);\n    }\n  }\n\n  /* Look up the host in our database of pinned certificates if we could not\n   * fully verify the certificate, i.e. if either the issuer is not known or\n   * the hostname of the connection does not match the certificate. */\n  table = NULL;\n  if(error == NULL)\n  {\n    known_cert = NULL;\n    if(!match_hostname || !issuer_known)\n    {\n      /* If we cannot load the known host file, then cancel the connection.\n       * Otherwise it might happen that someone shows us a certificate that we\n       * tell the user we don't know, if though actually for that host we expect\n       * a different certificate. */\n      table = inf_gtk_certificate_manager_ref_known_hosts(manager, &error);\n      if(table != NULL)\n        known_cert = g_hash_table_lookup(table, hostname);\n    }\n  }\n\n  /* Next, configure the flags for the dialog to be shown based on the\n   * verification result, and on whether the pinned certificate matches\n   * the one presented by the host or not. */\n  flags = 0;\n  if(error == NULL)\n  {\n    if(known_cert != NULL)\n    {\n      cert_equal = inf_gtk_certificate_manager_compare_fingerprint(\n        known_cert,\n        presented_cert,\n        &error\n      );\n\n      if(error == NULL && cert_equal == FALSE)\n      {\n        if(!match_hostname)\n          flags |= INF_GTK_CERTIFICATE_DIALOG_CERT_HOSTNAME_MISMATCH;\n        if(!issuer_known)\n          flags |= INF_GTK_CERTIFICATE_DIALOG_CERT_ISSUER_NOT_KNOWN;\n\n        flags |= INF_GTK_CERTIFICATE_DIALOG_CERT_UNEXPECTED;\n        expiration_time = gnutls_x509_crt_get_expiration_time(known_cert);\n        if(expiration_time != (time_t)(-1))\n        {\n          expiration_time -= INF_GTK_CERTIFICATE_MANAGER_EXPIRATION_TOLERANCE;\n          if(time(NULL) > expiration_time)\n          {\n            flags |= INF_GTK_CERTIFICATE_DIALOG_CERT_OLD_EXPIRED;\n          }\n        }\n      }\n    }\n    else\n    {\n      if(!match_hostname)\n        flags |= INF_GTK_CERTIFICATE_DIALOG_CERT_HOSTNAME_MISMATCH;\n      if(!issuer_known)\n        flags |= INF_GTK_CERTIFICATE_DIALOG_CERT_ISSUER_NOT_KNOWN;\n    }\n  }\n\n  /* Now proceed either by accepting the connection, rejecting it, or\n   * bothering the user with an annoying dialog. */\n  if(error == NULL)\n  {\n    if(flags == 0)\n    {\n      if(match_hostname && issuer_known)\n      {\n        /* Remove the pinned entry if we now have a valid certificate for\n         * this host. */\n        if(table != NULL && g_hash_table_remove(table, hostname) == TRUE)\n        {\n          inf_gtk_certificate_manager_write_known_hosts_with_warning(\n            manager,\n            table\n          );\n        }\n      }\n\n      inf_xmpp_connection_certificate_verify_continue(connection);\n    }\n    else\n    {\n      query = g_slice_new(InfGtkCertificateManagerQuery);\n      query->manager = manager;\n      query->known_hosts = table;\n      query->connection = connection;\n      query->dialog = inf_gtk_certificate_dialog_new(\n        priv->parent_window,\n        0,\n        flags,\n        hostname,\n        chain\n      );\n      query->certificate_chain = chain;\n\n      table = NULL;\n\n      g_object_ref(query->connection);\n      inf_certificate_chain_ref(chain);\n\n      g_signal_connect(\n        G_OBJECT(connection),\n        \"notify::status\",\n        G_CALLBACK(inf_gtk_certificate_manager_notify_status_cb),\n        query\n      );\n\n      g_signal_connect(\n        G_OBJECT(query->dialog),\n        \"response\",\n        G_CALLBACK(inf_gtk_certificate_manager_response_cb),\n        query\n      );\n\n      gtk_dialog_add_button(\n        GTK_DIALOG(query->dialog),\n        _(\"_Cancel connection\"),\n        GTK_RESPONSE_REJECT\n      );\n\n      gtk_dialog_add_button(\n        GTK_DIALOG(query->dialog),\n        _(\"C_ontinue connection\"),\n        GTK_RESPONSE_ACCEPT\n      );\n\n      text = g_strdup_printf(\n        _(\"Do you want to continue the connection to host \\\"%s\\\"? If you \"\n          \"choose to continue, this certificate will be trusted in the \"\n          \"future when connecting to this host.\"),\n        hostname\n      );\n\n      label = gtk_label_new(text);\n      gtk_label_set_line_wrap(GTK_LABEL(label), TRUE);\n      gtk_label_set_line_wrap_mode(GTK_LABEL(label), PANGO_WRAP_WORD_CHAR);\n      gtk_label_set_max_width_chars(GTK_LABEL(label), 60);\n      gtk_misc_set_alignment(GTK_MISC(label), 0.0, 0.0);\n      gtk_widget_show(label);\n      g_free(text);\n\n      vbox = gtk_dialog_get_content_area(GTK_DIALOG(query->dialog));\n      gtk_box_pack_start(GTK_BOX(vbox), label, FALSE, FALSE, 0);\n\n      priv->queries = g_slist_prepend(priv->queries, query);\n      gtk_window_present(GTK_WINDOW(query->dialog));\n    }\n  }\n  else\n  {\n    inf_xmpp_connection_certificate_verify_cancel(connection, error);\n    g_error_free(error);\n  }\n\n  if(table != NULL) g_hash_table_unref(table);\n  g_free(hostname);\n}",
        "func": "static void\ninf_gtk_certificate_manager_certificate_func(InfXmppConnection* connection,\n                                             gnutls_session_t session,\n                                             InfCertificateChain* chain,\n                                             gpointer user_data)\n{\n  InfGtkCertificateManager* manager;\n  InfGtkCertificateManagerPrivate* priv;\n\n  InfGtkCertificateDialogFlags flags;\n  gnutls_x509_crt_t presented_cert;\n  gnutls_x509_crt_t known_cert;\n  gchar* hostname;\n\n  gboolean match_hostname;\n  gboolean issuer_known;\n  gnutls_x509_crt_t root_cert;\n\n  int ret;\n  unsigned int verify;\n  GHashTable* table;\n  gboolean cert_equal;\n  time_t expiration_time;\n\n  InfGtkCertificateManagerQuery* query;\n  gchar* text;\n  GtkWidget* vbox;\n  GtkWidget* label;\n\n  GError* error;\n\n  manager = INF_GTK_CERTIFICATE_MANAGER(user_data);\n  priv = INF_GTK_CERTIFICATE_MANAGER_PRIVATE(manager);\n\n  g_object_get(G_OBJECT(connection), \"remote-hostname\", &hostname, NULL);\n  presented_cert = inf_certificate_chain_get_own_certificate(chain);\n\n  match_hostname = gnutls_x509_crt_check_hostname(presented_cert, hostname);\n\n  /* First, validate the certificate */\n  ret = gnutls_certificate_verify_peers2(session, &verify);\n  error = NULL;\n\n  if(ret != GNUTLS_E_SUCCESS)\n    inf_gnutls_set_error(&error, ret);\n\n  /* Remove the GNUTLS_CERT_ISSUER_NOT_KNOWN flag from the verification\n   * result, and if the certificate is still invalid, then set an error. */\n  if(error == NULL)\n  {\n    issuer_known = TRUE;\n    if(verify & GNUTLS_CERT_SIGNER_NOT_FOUND)\n    {\n      issuer_known = FALSE;\n\n      /* Re-validate the certificate for other failure reasons --\n       * unfortunately the gnutls_certificate_verify_peers2() call\n       * does not tell us whether the certificate is otherwise invalid\n       * if a signer is not found already. */\n      /* TODO: Here it would be good to use the verify flags from the\n       * certificate credentials, but GnuTLS does not have API to\n       * retrieve them. */\n      root_cert = inf_certificate_chain_get_root_certificate(chain);\n\n      ret = gnutls_x509_crt_list_verify(\n        inf_certificate_chain_get_raw(chain),\n        inf_certificate_chain_get_n_certificates(chain),\n        &root_cert,\n        1,\n        NULL,\n        0,\n        GNUTLS_VERIFY_ALLOW_X509_V1_CA_CRT,\n        &verify\n      );\n\n      if(ret != GNUTLS_E_SUCCESS)\n        inf_gnutls_set_error(&error, ret);\n    }\n\n    if(error == NULL)\n      if(verify & GNUTLS_CERT_INVALID)\n        inf_gnutls_certificate_verification_set_error(&error, verify);\n  }\n\n  /* Look up the host in our database of pinned certificates if we could not\n   * fully verify the certificate, i.e. if either the issuer is not known or\n   * the hostname of the connection does not match the certificate. */\n  table = NULL;\n  if(error == NULL)\n  {\n    known_cert = NULL;\n    if(!match_hostname || !issuer_known)\n    {\n      /* If we cannot load the known host file, then cancel the connection.\n       * Otherwise it might happen that someone shows us a certificate that we\n       * tell the user we don't know, if though actually for that host we expect\n       * a different certificate. */\n      table = inf_gtk_certificate_manager_ref_known_hosts(manager, &error);\n      if(table != NULL)\n        known_cert = g_hash_table_lookup(table, hostname);\n    }\n  }\n\n  /* Next, configure the flags for the dialog to be shown based on the\n   * verification result, and on whether the pinned certificate matches\n   * the one presented by the host or not. */\n  flags = 0;\n  if(error == NULL)\n  {\n    if(known_cert != NULL)\n    {\n      cert_equal = inf_gtk_certificate_manager_compare_fingerprint(\n        known_cert,\n        presented_cert,\n        &error\n      );\n\n      if(error == NULL && cert_equal == FALSE)\n      {\n        if(!match_hostname)\n          flags |= INF_GTK_CERTIFICATE_DIALOG_CERT_HOSTNAME_MISMATCH;\n        if(!issuer_known)\n          flags |= INF_GTK_CERTIFICATE_DIALOG_CERT_ISSUER_NOT_KNOWN;\n\n        flags |= INF_GTK_CERTIFICATE_DIALOG_CERT_UNEXPECTED;\n        expiration_time = gnutls_x509_crt_get_expiration_time(known_cert);\n        if(expiration_time != (time_t)(-1))\n        {\n          expiration_time -= INF_GTK_CERTIFICATE_MANAGER_EXPIRATION_TOLERANCE;\n          if(time(NULL) > expiration_time)\n          {\n            flags |= INF_GTK_CERTIFICATE_DIALOG_CERT_OLD_EXPIRED;\n          }\n        }\n      }\n    }\n    else\n    {\n      if(!match_hostname)\n        flags |= INF_GTK_CERTIFICATE_DIALOG_CERT_HOSTNAME_MISMATCH;\n      if(!issuer_known)\n        flags |= INF_GTK_CERTIFICATE_DIALOG_CERT_ISSUER_NOT_KNOWN;\n    }\n  }\n\n  /* Now proceed either by accepting the connection, rejecting it, or\n   * bothering the user with an annoying dialog. */\n  if(error == NULL)\n  {\n    if(flags == 0)\n    {\n      if(match_hostname && issuer_known)\n      {\n        /* Remove the pinned entry if we now have a valid certificate for\n         * this host. */\n        if(table != NULL && g_hash_table_remove(table, hostname) == TRUE)\n        {\n          inf_gtk_certificate_manager_write_known_hosts_with_warning(\n            manager,\n            table\n          );\n        }\n      }\n\n      inf_xmpp_connection_certificate_verify_continue(connection);\n    }\n    else\n    {\n      query = g_slice_new(InfGtkCertificateManagerQuery);\n      query->manager = manager;\n      query->known_hosts = table;\n      query->connection = connection;\n      query->dialog = inf_gtk_certificate_dialog_new(\n        priv->parent_window,\n        0,\n        flags,\n        hostname,\n        chain\n      );\n      query->certificate_chain = chain;\n\n      table = NULL;\n\n      g_object_ref(query->connection);\n      inf_certificate_chain_ref(chain);\n\n      g_signal_connect(\n        G_OBJECT(connection),\n        \"notify::status\",\n        G_CALLBACK(inf_gtk_certificate_manager_notify_status_cb),\n        query\n      );\n\n      g_signal_connect(\n        G_OBJECT(query->dialog),\n        \"response\",\n        G_CALLBACK(inf_gtk_certificate_manager_response_cb),\n        query\n      );\n\n      gtk_dialog_add_button(\n        GTK_DIALOG(query->dialog),\n        _(\"_Cancel connection\"),\n        GTK_RESPONSE_REJECT\n      );\n\n      gtk_dialog_add_button(\n        GTK_DIALOG(query->dialog),\n        _(\"C_ontinue connection\"),\n        GTK_RESPONSE_ACCEPT\n      );\n\n      text = g_strdup_printf(\n        _(\"Do you want to continue the connection to host \\\"%s\\\"? If you \"\n          \"choose to continue, this certificate will be trusted in the \"\n          \"future when connecting to this host.\"),\n        hostname\n      );\n\n      label = gtk_label_new(text);\n      gtk_label_set_line_wrap(GTK_LABEL(label), TRUE);\n      gtk_label_set_line_wrap_mode(GTK_LABEL(label), PANGO_WRAP_WORD_CHAR);\n      gtk_label_set_max_width_chars(GTK_LABEL(label), 60);\n      gtk_misc_set_alignment(GTK_MISC(label), 0.0, 0.0);\n      gtk_widget_show(label);\n      g_free(text);\n\n      vbox = gtk_dialog_get_content_area(GTK_DIALOG(query->dialog));\n      gtk_box_pack_start(GTK_BOX(vbox), label, FALSE, FALSE, 0);\n\n      priv->queries = g_slist_prepend(priv->queries, query);\n      gtk_window_present(GTK_WINDOW(query->dialog));\n    }\n  }\n  else\n  {\n    inf_xmpp_connection_certificate_verify_cancel(connection, error);\n    g_error_free(error);\n  }\n\n  if(table != NULL) g_hash_table_unref(table);\n  g_free(hostname);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -75,9 +75,11 @@\n \n       if(ret != GNUTLS_E_SUCCESS)\n         inf_gnutls_set_error(&error, ret);\n-      else if(verify & GNUTLS_CERT_INVALID)\n+    }\n+\n+    if(error == NULL)\n+      if(verify & GNUTLS_CERT_INVALID)\n         inf_gnutls_certificate_verification_set_error(&error, verify);\n-    }\n   }\n \n   /* Look up the host in our database of pinned certificates if we could not",
        "diff_line_info": {
            "deleted_lines": [
                "      else if(verify & GNUTLS_CERT_INVALID)",
                "    }"
            ],
            "added_lines": [
                "    }",
                "",
                "    if(error == NULL)",
                "      if(verify & GNUTLS_CERT_INVALID)"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-6594",
        "func_name": "heimdal/fix_transited_encoding",
        "description": "The transit path validation code in Heimdal before 7.3 might allow attackers to bypass the capath policy protection mechanism by leveraging failure to add the previous hop realm to the transit path of issued tickets.",
        "git_url": "https://github.com/heimdal/heimdal/commit/b1e699103f08d6a0ca46a122193c9da65f6cf837",
        "commit_title": "Fix transit path validation CVE-2017-6594",
        "commit_text": " Commit f469fc6 (2010-10-02) inadvertently caused the previous hop realm to not be added to the transit path of issued tickets.  This may, in some cases, enable bypass of capath policy in Heimdal versions 1.5 through 7.2.  Note, this may break sites that rely on the bug.  With the bug some incomplete [capaths] worked, that should not have.  These may now break authentication in some cross-realm configurations.",
        "func_before": "static krb5_error_code\nfix_transited_encoding(krb5_context context,\n\t\t       krb5_kdc_configuration *config,\n\t\t       krb5_boolean check_policy,\n\t\t       const TransitedEncoding *tr,\n\t\t       EncTicketPart *et,\n\t\t       const char *client_realm,\n\t\t       const char *server_realm,\n\t\t       const char *tgt_realm)\n{\n    krb5_error_code ret = 0;\n    char **realms, **tmp;\n    unsigned int num_realms;\n    size_t i;\n\n    switch (tr->tr_type) {\n    case DOMAIN_X500_COMPRESS:\n\tbreak;\n    case 0:\n\t/*\n\t * Allow empty content of type 0 because that is was Microsoft\n\t * generates in their TGT.\n\t */\n\tif (tr->contents.length == 0)\n\t    break;\n\tkdc_log(context, config, 0,\n\t\t\"Transited type 0 with non empty content\");\n\treturn KRB5KDC_ERR_TRTYPE_NOSUPP;\n    default:\n\tkdc_log(context, config, 0,\n\t\t\"Unknown transited type: %u\", tr->tr_type);\n\treturn KRB5KDC_ERR_TRTYPE_NOSUPP;\n    }\n\n    ret = krb5_domain_x500_decode(context,\n\t\t\t\t  tr->contents,\n\t\t\t\t  &realms,\n\t\t\t\t  &num_realms,\n\t\t\t\t  client_realm,\n\t\t\t\t  server_realm);\n    if(ret){\n\tkrb5_warn(context, ret,\n\t\t  \"Decoding transited encoding\");\n\treturn ret;\n    }\n    if(strcmp(client_realm, tgt_realm) && strcmp(server_realm, tgt_realm)) {\n\t/* not us, so add the previous realm to transited set */\n\tif (num_realms + 1 > UINT_MAX/sizeof(*realms)) {\n\t    ret = ERANGE;\n\t    goto free_realms;\n\t}\n\ttmp = realloc(realms, (num_realms + 1) * sizeof(*realms));\n\tif(tmp == NULL){\n\t    ret = ENOMEM;\n\t    goto free_realms;\n\t}\n\trealms = tmp;\n\trealms[num_realms] = strdup(tgt_realm);\n\tif(realms[num_realms] == NULL){\n\t    ret = ENOMEM;\n\t    goto free_realms;\n\t}\n\tnum_realms++;\n    }\n    if(num_realms == 0) {\n\tif(strcmp(client_realm, server_realm))\n\t    kdc_log(context, config, 0,\n\t\t    \"cross-realm %s -> %s\", client_realm, server_realm);\n    } else {\n\tsize_t l = 0;\n\tchar *rs;\n\tfor(i = 0; i < num_realms; i++)\n\t    l += strlen(realms[i]) + 2;\n\trs = malloc(l);\n\tif(rs != NULL) {\n\t    *rs = '\\0';\n\t    for(i = 0; i < num_realms; i++) {\n\t\tif(i > 0)\n\t\t    strlcat(rs, \", \", l);\n\t\tstrlcat(rs, realms[i], l);\n\t    }\n\t    kdc_log(context, config, 0,\n\t\t    \"cross-realm %s -> %s via [%s]\",\n\t\t    client_realm, server_realm, rs);\n\t    free(rs);\n\t}\n    }\n    if(check_policy) {\n\tret = krb5_check_transited(context, client_realm,\n\t\t\t\t   server_realm,\n\t\t\t\t   realms, num_realms, NULL);\n\tif(ret) {\n\t    krb5_warn(context, ret, \"cross-realm %s -> %s\",\n\t\t      client_realm, server_realm);\n\t    goto free_realms;\n\t}\n\tet->flags.transited_policy_checked = 1;\n    }\n    et->transited.tr_type = DOMAIN_X500_COMPRESS;\n    ret = krb5_domain_x500_encode(realms, num_realms, &et->transited.contents);\n    if(ret)\n\tkrb5_warn(context, ret, \"Encoding transited encoding\");\n  free_realms:\n    for(i = 0; i < num_realms; i++)\n\tfree(realms[i]);\n    free(realms);\n    return ret;\n}",
        "func": "static krb5_error_code\nfix_transited_encoding(krb5_context context,\n\t\t       krb5_kdc_configuration *config,\n\t\t       krb5_boolean check_policy,\n\t\t       const TransitedEncoding *tr,\n\t\t       EncTicketPart *et,\n\t\t       const char *client_realm,\n\t\t       const char *server_realm,\n\t\t       const char *tgt_realm)\n{\n    krb5_error_code ret = 0;\n    char **realms, **tmp;\n    unsigned int num_realms;\n    size_t i;\n\n    switch (tr->tr_type) {\n    case DOMAIN_X500_COMPRESS:\n\tbreak;\n    case 0:\n\t/*\n\t * Allow empty content of type 0 because that is was Microsoft\n\t * generates in their TGT.\n\t */\n\tif (tr->contents.length == 0)\n\t    break;\n\tkdc_log(context, config, 0,\n\t\t\"Transited type 0 with non empty content\");\n\treturn KRB5KDC_ERR_TRTYPE_NOSUPP;\n    default:\n\tkdc_log(context, config, 0,\n\t\t\"Unknown transited type: %u\", tr->tr_type);\n\treturn KRB5KDC_ERR_TRTYPE_NOSUPP;\n    }\n\n    ret = krb5_domain_x500_decode(context,\n\t\t\t\t  tr->contents,\n\t\t\t\t  &realms,\n\t\t\t\t  &num_realms,\n\t\t\t\t  client_realm,\n\t\t\t\t  server_realm);\n    if(ret){\n\tkrb5_warn(context, ret,\n\t\t  \"Decoding transited encoding\");\n\treturn ret;\n    }\n\n    /*\n     * If the realm of the presented tgt is neither the client nor the server\n     * realm, it is a transit realm and must be added to transited set.\n     */\n    if(strcmp(client_realm, tgt_realm) && strcmp(server_realm, tgt_realm)) {\n\tif (num_realms + 1 > UINT_MAX/sizeof(*realms)) {\n\t    ret = ERANGE;\n\t    goto free_realms;\n\t}\n\ttmp = realloc(realms, (num_realms + 1) * sizeof(*realms));\n\tif(tmp == NULL){\n\t    ret = ENOMEM;\n\t    goto free_realms;\n\t}\n\trealms = tmp;\n\trealms[num_realms] = strdup(tgt_realm);\n\tif(realms[num_realms] == NULL){\n\t    ret = ENOMEM;\n\t    goto free_realms;\n\t}\n\tnum_realms++;\n    }\n    if(num_realms == 0) {\n\tif(strcmp(client_realm, server_realm))\n\t    kdc_log(context, config, 0,\n\t\t    \"cross-realm %s -> %s\", client_realm, server_realm);\n    } else {\n\tsize_t l = 0;\n\tchar *rs;\n\tfor(i = 0; i < num_realms; i++)\n\t    l += strlen(realms[i]) + 2;\n\trs = malloc(l);\n\tif(rs != NULL) {\n\t    *rs = '\\0';\n\t    for(i = 0; i < num_realms; i++) {\n\t\tif(i > 0)\n\t\t    strlcat(rs, \", \", l);\n\t\tstrlcat(rs, realms[i], l);\n\t    }\n\t    kdc_log(context, config, 0,\n\t\t    \"cross-realm %s -> %s via [%s]\",\n\t\t    client_realm, server_realm, rs);\n\t    free(rs);\n\t}\n    }\n    if(check_policy) {\n\tret = krb5_check_transited(context, client_realm,\n\t\t\t\t   server_realm,\n\t\t\t\t   realms, num_realms, NULL);\n\tif(ret) {\n\t    krb5_warn(context, ret, \"cross-realm %s -> %s\",\n\t\t      client_realm, server_realm);\n\t    goto free_realms;\n\t}\n\tet->flags.transited_policy_checked = 1;\n    }\n    et->transited.tr_type = DOMAIN_X500_COMPRESS;\n    ret = krb5_domain_x500_encode(realms, num_realms, &et->transited.contents);\n    if(ret)\n\tkrb5_warn(context, ret, \"Encoding transited encoding\");\n  free_realms:\n    for(i = 0; i < num_realms; i++)\n\tfree(realms[i]);\n    free(realms);\n    return ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -43,8 +43,12 @@\n \t\t  \"Decoding transited encoding\");\n \treturn ret;\n     }\n+\n+    /*\n+     * If the realm of the presented tgt is neither the client nor the server\n+     * realm, it is a transit realm and must be added to transited set.\n+     */\n     if(strcmp(client_realm, tgt_realm) && strcmp(server_realm, tgt_realm)) {\n-\t/* not us, so add the previous realm to transited set */\n \tif (num_realms + 1 > UINT_MAX/sizeof(*realms)) {\n \t    ret = ERANGE;\n \t    goto free_realms;",
        "diff_line_info": {
            "deleted_lines": [
                "\t/* not us, so add the previous realm to transited set */"
            ],
            "added_lines": [
                "",
                "    /*",
                "     * If the realm of the presented tgt is neither the client nor the server",
                "     * realm, it is a transit realm and must be added to transited set.",
                "     */"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-6594",
        "func_name": "heimdal/tgs_make_reply",
        "description": "The transit path validation code in Heimdal before 7.3 might allow attackers to bypass the capath policy protection mechanism by leveraging failure to add the previous hop realm to the transit path of issued tickets.",
        "git_url": "https://github.com/heimdal/heimdal/commit/b1e699103f08d6a0ca46a122193c9da65f6cf837",
        "commit_title": "Fix transit path validation CVE-2017-6594",
        "commit_text": " Commit f469fc6 (2010-10-02) inadvertently caused the previous hop realm to not be added to the transit path of issued tickets.  This may, in some cases, enable bypass of capath policy in Heimdal versions 1.5 through 7.2.  Note, this may break sites that rely on the bug.  With the bug some incomplete [capaths] worked, that should not have.  These may now break authentication in some cross-realm configurations.",
        "func_before": "static krb5_error_code\ntgs_make_reply(krb5_context context,\n\t       krb5_kdc_configuration *config,\n\t       KDC_REQ_BODY *b,\n\t       krb5_const_principal tgt_name,\n\t       const EncTicketPart *tgt,\n\t       const krb5_keyblock *replykey,\n\t       int rk_is_subkey,\n\t       const EncryptionKey *serverkey,\n\t       const krb5_keyblock *sessionkey,\n\t       krb5_kvno kvno,\n\t       AuthorizationData *auth_data,\n\t       hdb_entry_ex *server,\n\t       krb5_principal server_principal,\n\t       const char *server_name,\n\t       hdb_entry_ex *client,\n\t       krb5_principal client_principal,\n\t       hdb_entry_ex *krbtgt,\n\t       krb5_enctype krbtgt_etype,\n\t       krb5_principals spp,\n\t       const krb5_data *rspac,\n\t       const METHOD_DATA *enc_pa_data,\n\t       const char **e_text,\n\t       krb5_data *reply)\n{\n    KDC_REP rep;\n    EncKDCRepPart ek;\n    EncTicketPart et;\n    KDCOptions f = b->kdc_options;\n    krb5_error_code ret;\n    int is_weak = 0;\n\n    memset(&rep, 0, sizeof(rep));\n    memset(&et, 0, sizeof(et));\n    memset(&ek, 0, sizeof(ek));\n\n    rep.pvno = 5;\n    rep.msg_type = krb_tgs_rep;\n\n    et.authtime = tgt->authtime;\n    _kdc_fix_time(&b->till);\n    et.endtime = min(tgt->endtime, *b->till);\n    ALLOC(et.starttime);\n    *et.starttime = kdc_time;\n\n    ret = check_tgs_flags(context, config, b, tgt, &et);\n    if(ret)\n\tgoto out;\n\n    /* We should check the transited encoding if:\n       1) the request doesn't ask not to be checked\n       2) globally enforcing a check\n       3) principal requires checking\n       4) we allow non-check per-principal, but principal isn't marked as allowing this\n       5) we don't globally allow this\n    */\n\n#define GLOBAL_FORCE_TRANSITED_CHECK\t\t\\\n    (config->trpolicy == TRPOLICY_ALWAYS_CHECK)\n#define GLOBAL_ALLOW_PER_PRINCIPAL\t\t\t\\\n    (config->trpolicy == TRPOLICY_ALLOW_PER_PRINCIPAL)\n#define GLOBAL_ALLOW_DISABLE_TRANSITED_CHECK\t\t\t\\\n    (config->trpolicy == TRPOLICY_ALWAYS_HONOUR_REQUEST)\n\n/* these will consult the database in future release */\n#define PRINCIPAL_FORCE_TRANSITED_CHECK(P)\t\t0\n#define PRINCIPAL_ALLOW_DISABLE_TRANSITED_CHECK(P)\t0\n\n    ret = fix_transited_encoding(context, config,\n\t\t\t\t !f.disable_transited_check ||\n\t\t\t\t GLOBAL_FORCE_TRANSITED_CHECK ||\n\t\t\t\t PRINCIPAL_FORCE_TRANSITED_CHECK(server) ||\n\t\t\t\t !((GLOBAL_ALLOW_PER_PRINCIPAL &&\n\t\t\t\t    PRINCIPAL_ALLOW_DISABLE_TRANSITED_CHECK(server)) ||\n\t\t\t\t   GLOBAL_ALLOW_DISABLE_TRANSITED_CHECK),\n\t\t\t\t &tgt->transited, &et,\n\t\t\t\t krb5_principal_get_realm(context, client_principal),\n\t\t\t\t krb5_principal_get_realm(context, server->entry.principal),\n\t\t\t\t krb5_principal_get_realm(context, krbtgt->entry.principal));\n    if(ret)\n\tgoto out;\n\n    copy_Realm(&server_principal->realm, &rep.ticket.realm);\n    _krb5_principal2principalname(&rep.ticket.sname, server_principal);\n    copy_Realm(&tgt_name->realm, &rep.crealm);\n/*\n    if (f.request_anonymous)\n\t_kdc_make_anonymous_principalname (&rep.cname);\n    else */\n\n    copy_PrincipalName(&tgt_name->name, &rep.cname);\n    rep.ticket.tkt_vno = 5;\n\n    ek.caddr = et.caddr;\n\n    {\n\ttime_t life;\n\tlife = et.endtime - *et.starttime;\n\tif(client && client->entry.max_life)\n\t    life = min(life, *client->entry.max_life);\n\tif(server->entry.max_life)\n\t    life = min(life, *server->entry.max_life);\n\tet.endtime = *et.starttime + life;\n    }\n    if(f.renewable_ok && tgt->flags.renewable &&\n       et.renew_till == NULL && et.endtime < *b->till &&\n       tgt->renew_till != NULL)\n    {\n\tet.flags.renewable = 1;\n\tALLOC(et.renew_till);\n\t*et.renew_till = *b->till;\n    }\n    if(et.renew_till){\n\ttime_t renew;\n\trenew = *et.renew_till - *et.starttime;\n\tif(client && client->entry.max_renew)\n\t    renew = min(renew, *client->entry.max_renew);\n\tif(server->entry.max_renew)\n\t    renew = min(renew, *server->entry.max_renew);\n\t*et.renew_till = *et.starttime + renew;\n    }\n\n    if(et.renew_till){\n\t*et.renew_till = min(*et.renew_till, *tgt->renew_till);\n\t*et.starttime = min(*et.starttime, *et.renew_till);\n\tet.endtime = min(et.endtime, *et.renew_till);\n    }\n\n    *et.starttime = min(*et.starttime, et.endtime);\n\n    if(*et.starttime == et.endtime){\n\tret = KRB5KDC_ERR_NEVER_VALID;\n\tgoto out;\n    }\n    if(et.renew_till && et.endtime == *et.renew_till){\n\tfree(et.renew_till);\n\tet.renew_till = NULL;\n\tet.flags.renewable = 0;\n    }\n\n    et.flags.pre_authent = tgt->flags.pre_authent;\n    et.flags.hw_authent  = tgt->flags.hw_authent;\n    et.flags.anonymous   = tgt->flags.anonymous;\n    et.flags.ok_as_delegate = server->entry.flags.ok_as_delegate;\n\n    if(rspac->length) {\n\t/*\n\t * No not need to filter out the any PAC from the\n\t * auth_data since it's signed by the KDC.\n\t */\n\tret = _kdc_tkt_add_if_relevant_ad(context, &et,\n\t\t\t\t\t  KRB5_AUTHDATA_WIN2K_PAC, rspac);\n\tif (ret)\n\t    goto out;\n    }\n\n    if (auth_data) {\n\tunsigned int i = 0;\n\n\t/* XXX check authdata */\n\n\tif (et.authorization_data == NULL) {\n\t    et.authorization_data = calloc(1, sizeof(*et.authorization_data));\n\t    if (et.authorization_data == NULL) {\n\t\tret = ENOMEM;\n\t\tkrb5_set_error_message(context, ret, \"malloc: out of memory\");\n\t\tgoto out;\n\t    }\n\t}\n\tfor(i = 0; i < auth_data->len ; i++) {\n\t    ret = add_AuthorizationData(et.authorization_data, &auth_data->val[i]);\n\t    if (ret) {\n\t\tkrb5_set_error_message(context, ret, \"malloc: out of memory\");\n\t\tgoto out;\n\t    }\n\t}\n\n\t/* Filter out type KRB5SignedPath */\n\tret = find_KRB5SignedPath(context, et.authorization_data, NULL);\n\tif (ret == 0) {\n\t    if (et.authorization_data->len == 1) {\n\t\tfree_AuthorizationData(et.authorization_data);\n\t\tfree(et.authorization_data);\n\t\tet.authorization_data = NULL;\n\t    } else {\n\t\tAuthorizationData *ad = et.authorization_data;\n\t\tfree_AuthorizationDataElement(&ad->val[ad->len - 1]);\n\t\tad->len--;\n\t    }\n\t}\n    }\n\n    ret = krb5_copy_keyblock_contents(context, sessionkey, &et.key);\n    if (ret)\n\tgoto out;\n    et.crealm = tgt_name->realm;\n    et.cname = tgt_name->name;\n\n    ek.key = et.key;\n    /* MIT must have at least one last_req */\n    ek.last_req.val = calloc(1, sizeof(*ek.last_req.val));\n    if (ek.last_req.val == NULL) {\n\tret = ENOMEM;\n\tgoto out;\n    }\n    ek.last_req.len = 1; /* set after alloc to avoid null deref on cleanup */\n    ek.nonce = b->nonce;\n    ek.flags = et.flags;\n    ek.authtime = et.authtime;\n    ek.starttime = et.starttime;\n    ek.endtime = et.endtime;\n    ek.renew_till = et.renew_till;\n    ek.srealm = rep.ticket.realm;\n    ek.sname = rep.ticket.sname;\n\n    _kdc_log_timestamp(context, config, \"TGS-REQ\", et.authtime, et.starttime,\n\t\t       et.endtime, et.renew_till);\n\n    /* Don't sign cross realm tickets, they can't be checked anyway */\n    {\n\tchar *r = get_krbtgt_realm(&ek.sname);\n\n\tif (r == NULL || strcmp(r, ek.srealm) == 0) {\n\t    ret = _kdc_add_KRB5SignedPath(context,\n\t\t\t\t\t  config,\n\t\t\t\t\t  krbtgt,\n\t\t\t\t\t  krbtgt_etype,\n\t\t\t\t\t  client_principal,\n\t\t\t\t\t  NULL,\n\t\t\t\t\t  spp,\n\t\t\t\t\t  &et);\n\t    if (ret)\n\t\tgoto out;\n\t}\n    }\n\n    if (enc_pa_data->len) {\n\trep.padata = calloc(1, sizeof(*rep.padata));\n\tif (rep.padata == NULL) {\n\t    ret = ENOMEM;\n\t    goto out;\n\t}\n\tret = copy_METHOD_DATA(enc_pa_data, rep.padata);\n\tif (ret)\n\t    goto out;\n    }\n\n    if (krb5_enctype_valid(context, serverkey->keytype) != 0\n\t&& _kdc_is_weak_exception(server->entry.principal, serverkey->keytype))\n    {\n\tkrb5_enctype_enable(context, serverkey->keytype);\n\tis_weak = 1;\n    }\n\n\n    /* It is somewhat unclear where the etype in the following\n       encryption should come from. What we have is a session\n       key in the passed tgt, and a list of preferred etypes\n       *for the new ticket*. Should we pick the best possible\n       etype, given the keytype in the tgt, or should we look\n       at the etype list here as well?  What if the tgt\n       session key is DES3 and we want a ticket with a (say)\n       CAST session key. Should the DES3 etype be added to the\n       etype list, even if we don't want a session key with\n       DES3? */\n    ret = _kdc_encode_reply(context, config, NULL, 0,\n\t\t\t    &rep, &et, &ek, serverkey->keytype,\n\t\t\t    kvno,\n\t\t\t    serverkey, 0, replykey, rk_is_subkey,\n\t\t\t    e_text, reply);\n    if (is_weak)\n\tkrb5_enctype_disable(context, serverkey->keytype);\n\nout:\n    free_TGS_REP(&rep);\n    free_TransitedEncoding(&et.transited);\n    if(et.starttime)\n\tfree(et.starttime);\n    if(et.renew_till)\n\tfree(et.renew_till);\n    if(et.authorization_data) {\n\tfree_AuthorizationData(et.authorization_data);\n\tfree(et.authorization_data);\n    }\n    free_LastReq(&ek.last_req);\n    memset(et.key.keyvalue.data, 0, et.key.keyvalue.length);\n    free_EncryptionKey(&et.key);\n    return ret;\n}",
        "func": "static krb5_error_code\ntgs_make_reply(krb5_context context,\n\t       krb5_kdc_configuration *config,\n\t       KDC_REQ_BODY *b,\n\t       krb5_const_principal tgt_name,\n\t       const EncTicketPart *tgt,\n\t       const krb5_keyblock *replykey,\n\t       int rk_is_subkey,\n\t       const EncryptionKey *serverkey,\n\t       const krb5_keyblock *sessionkey,\n\t       krb5_kvno kvno,\n\t       AuthorizationData *auth_data,\n\t       hdb_entry_ex *server,\n\t       krb5_principal server_principal,\n\t       const char *server_name,\n\t       hdb_entry_ex *client,\n\t       krb5_principal client_principal,\n               const char *tgt_realm,\n\t       hdb_entry_ex *krbtgt,\n\t       krb5_enctype krbtgt_etype,\n\t       krb5_principals spp,\n\t       const krb5_data *rspac,\n\t       const METHOD_DATA *enc_pa_data,\n\t       const char **e_text,\n\t       krb5_data *reply)\n{\n    KDC_REP rep;\n    EncKDCRepPart ek;\n    EncTicketPart et;\n    KDCOptions f = b->kdc_options;\n    krb5_error_code ret;\n    int is_weak = 0;\n\n    memset(&rep, 0, sizeof(rep));\n    memset(&et, 0, sizeof(et));\n    memset(&ek, 0, sizeof(ek));\n\n    rep.pvno = 5;\n    rep.msg_type = krb_tgs_rep;\n\n    et.authtime = tgt->authtime;\n    _kdc_fix_time(&b->till);\n    et.endtime = min(tgt->endtime, *b->till);\n    ALLOC(et.starttime);\n    *et.starttime = kdc_time;\n\n    ret = check_tgs_flags(context, config, b, tgt, &et);\n    if(ret)\n\tgoto out;\n\n    /* We should check the transited encoding if:\n       1) the request doesn't ask not to be checked\n       2) globally enforcing a check\n       3) principal requires checking\n       4) we allow non-check per-principal, but principal isn't marked as allowing this\n       5) we don't globally allow this\n    */\n\n#define GLOBAL_FORCE_TRANSITED_CHECK\t\t\\\n    (config->trpolicy == TRPOLICY_ALWAYS_CHECK)\n#define GLOBAL_ALLOW_PER_PRINCIPAL\t\t\t\\\n    (config->trpolicy == TRPOLICY_ALLOW_PER_PRINCIPAL)\n#define GLOBAL_ALLOW_DISABLE_TRANSITED_CHECK\t\t\t\\\n    (config->trpolicy == TRPOLICY_ALWAYS_HONOUR_REQUEST)\n\n/* these will consult the database in future release */\n#define PRINCIPAL_FORCE_TRANSITED_CHECK(P)\t\t0\n#define PRINCIPAL_ALLOW_DISABLE_TRANSITED_CHECK(P)\t0\n\n    ret = fix_transited_encoding(context, config,\n\t\t\t\t !f.disable_transited_check ||\n\t\t\t\t GLOBAL_FORCE_TRANSITED_CHECK ||\n\t\t\t\t PRINCIPAL_FORCE_TRANSITED_CHECK(server) ||\n\t\t\t\t !((GLOBAL_ALLOW_PER_PRINCIPAL &&\n\t\t\t\t    PRINCIPAL_ALLOW_DISABLE_TRANSITED_CHECK(server)) ||\n\t\t\t\t   GLOBAL_ALLOW_DISABLE_TRANSITED_CHECK),\n\t\t\t\t &tgt->transited, &et,\n\t\t\t\t krb5_principal_get_realm(context, client_principal),\n\t\t\t\t krb5_principal_get_realm(context, server->entry.principal),\n\t\t\t\t tgt_realm);\n    if(ret)\n\tgoto out;\n\n    copy_Realm(&server_principal->realm, &rep.ticket.realm);\n    _krb5_principal2principalname(&rep.ticket.sname, server_principal);\n    copy_Realm(&tgt_name->realm, &rep.crealm);\n/*\n    if (f.request_anonymous)\n\t_kdc_make_anonymous_principalname (&rep.cname);\n    else */\n\n    copy_PrincipalName(&tgt_name->name, &rep.cname);\n    rep.ticket.tkt_vno = 5;\n\n    ek.caddr = et.caddr;\n\n    {\n\ttime_t life;\n\tlife = et.endtime - *et.starttime;\n\tif(client && client->entry.max_life)\n\t    life = min(life, *client->entry.max_life);\n\tif(server->entry.max_life)\n\t    life = min(life, *server->entry.max_life);\n\tet.endtime = *et.starttime + life;\n    }\n    if(f.renewable_ok && tgt->flags.renewable &&\n       et.renew_till == NULL && et.endtime < *b->till &&\n       tgt->renew_till != NULL)\n    {\n\tet.flags.renewable = 1;\n\tALLOC(et.renew_till);\n\t*et.renew_till = *b->till;\n    }\n    if(et.renew_till){\n\ttime_t renew;\n\trenew = *et.renew_till - *et.starttime;\n\tif(client && client->entry.max_renew)\n\t    renew = min(renew, *client->entry.max_renew);\n\tif(server->entry.max_renew)\n\t    renew = min(renew, *server->entry.max_renew);\n\t*et.renew_till = *et.starttime + renew;\n    }\n\n    if(et.renew_till){\n\t*et.renew_till = min(*et.renew_till, *tgt->renew_till);\n\t*et.starttime = min(*et.starttime, *et.renew_till);\n\tet.endtime = min(et.endtime, *et.renew_till);\n    }\n\n    *et.starttime = min(*et.starttime, et.endtime);\n\n    if(*et.starttime == et.endtime){\n\tret = KRB5KDC_ERR_NEVER_VALID;\n\tgoto out;\n    }\n    if(et.renew_till && et.endtime == *et.renew_till){\n\tfree(et.renew_till);\n\tet.renew_till = NULL;\n\tet.flags.renewable = 0;\n    }\n\n    et.flags.pre_authent = tgt->flags.pre_authent;\n    et.flags.hw_authent  = tgt->flags.hw_authent;\n    et.flags.anonymous   = tgt->flags.anonymous;\n    et.flags.ok_as_delegate = server->entry.flags.ok_as_delegate;\n\n    if(rspac->length) {\n\t/*\n\t * No not need to filter out the any PAC from the\n\t * auth_data since it's signed by the KDC.\n\t */\n\tret = _kdc_tkt_add_if_relevant_ad(context, &et,\n\t\t\t\t\t  KRB5_AUTHDATA_WIN2K_PAC, rspac);\n\tif (ret)\n\t    goto out;\n    }\n\n    if (auth_data) {\n\tunsigned int i = 0;\n\n\t/* XXX check authdata */\n\n\tif (et.authorization_data == NULL) {\n\t    et.authorization_data = calloc(1, sizeof(*et.authorization_data));\n\t    if (et.authorization_data == NULL) {\n\t\tret = ENOMEM;\n\t\tkrb5_set_error_message(context, ret, \"malloc: out of memory\");\n\t\tgoto out;\n\t    }\n\t}\n\tfor(i = 0; i < auth_data->len ; i++) {\n\t    ret = add_AuthorizationData(et.authorization_data, &auth_data->val[i]);\n\t    if (ret) {\n\t\tkrb5_set_error_message(context, ret, \"malloc: out of memory\");\n\t\tgoto out;\n\t    }\n\t}\n\n\t/* Filter out type KRB5SignedPath */\n\tret = find_KRB5SignedPath(context, et.authorization_data, NULL);\n\tif (ret == 0) {\n\t    if (et.authorization_data->len == 1) {\n\t\tfree_AuthorizationData(et.authorization_data);\n\t\tfree(et.authorization_data);\n\t\tet.authorization_data = NULL;\n\t    } else {\n\t\tAuthorizationData *ad = et.authorization_data;\n\t\tfree_AuthorizationDataElement(&ad->val[ad->len - 1]);\n\t\tad->len--;\n\t    }\n\t}\n    }\n\n    ret = krb5_copy_keyblock_contents(context, sessionkey, &et.key);\n    if (ret)\n\tgoto out;\n    et.crealm = tgt_name->realm;\n    et.cname = tgt_name->name;\n\n    ek.key = et.key;\n    /* MIT must have at least one last_req */\n    ek.last_req.val = calloc(1, sizeof(*ek.last_req.val));\n    if (ek.last_req.val == NULL) {\n\tret = ENOMEM;\n\tgoto out;\n    }\n    ek.last_req.len = 1; /* set after alloc to avoid null deref on cleanup */\n    ek.nonce = b->nonce;\n    ek.flags = et.flags;\n    ek.authtime = et.authtime;\n    ek.starttime = et.starttime;\n    ek.endtime = et.endtime;\n    ek.renew_till = et.renew_till;\n    ek.srealm = rep.ticket.realm;\n    ek.sname = rep.ticket.sname;\n\n    _kdc_log_timestamp(context, config, \"TGS-REQ\", et.authtime, et.starttime,\n\t\t       et.endtime, et.renew_till);\n\n    /* Don't sign cross realm tickets, they can't be checked anyway */\n    {\n\tchar *r = get_krbtgt_realm(&ek.sname);\n\n\tif (r == NULL || strcmp(r, ek.srealm) == 0) {\n\t    ret = _kdc_add_KRB5SignedPath(context,\n\t\t\t\t\t  config,\n\t\t\t\t\t  krbtgt,\n\t\t\t\t\t  krbtgt_etype,\n\t\t\t\t\t  client_principal,\n\t\t\t\t\t  NULL,\n\t\t\t\t\t  spp,\n\t\t\t\t\t  &et);\n\t    if (ret)\n\t\tgoto out;\n\t}\n    }\n\n    if (enc_pa_data->len) {\n\trep.padata = calloc(1, sizeof(*rep.padata));\n\tif (rep.padata == NULL) {\n\t    ret = ENOMEM;\n\t    goto out;\n\t}\n\tret = copy_METHOD_DATA(enc_pa_data, rep.padata);\n\tif (ret)\n\t    goto out;\n    }\n\n    if (krb5_enctype_valid(context, serverkey->keytype) != 0\n\t&& _kdc_is_weak_exception(server->entry.principal, serverkey->keytype))\n    {\n\tkrb5_enctype_enable(context, serverkey->keytype);\n\tis_weak = 1;\n    }\n\n\n    /* It is somewhat unclear where the etype in the following\n       encryption should come from. What we have is a session\n       key in the passed tgt, and a list of preferred etypes\n       *for the new ticket*. Should we pick the best possible\n       etype, given the keytype in the tgt, or should we look\n       at the etype list here as well?  What if the tgt\n       session key is DES3 and we want a ticket with a (say)\n       CAST session key. Should the DES3 etype be added to the\n       etype list, even if we don't want a session key with\n       DES3? */\n    ret = _kdc_encode_reply(context, config, NULL, 0,\n\t\t\t    &rep, &et, &ek, serverkey->keytype,\n\t\t\t    kvno,\n\t\t\t    serverkey, 0, replykey, rk_is_subkey,\n\t\t\t    e_text, reply);\n    if (is_weak)\n\tkrb5_enctype_disable(context, serverkey->keytype);\n\nout:\n    free_TGS_REP(&rep);\n    free_TransitedEncoding(&et.transited);\n    if(et.starttime)\n\tfree(et.starttime);\n    if(et.renew_till)\n\tfree(et.renew_till);\n    if(et.authorization_data) {\n\tfree_AuthorizationData(et.authorization_data);\n\tfree(et.authorization_data);\n    }\n    free_LastReq(&ek.last_req);\n    memset(et.key.keyvalue.data, 0, et.key.keyvalue.length);\n    free_EncryptionKey(&et.key);\n    return ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -15,6 +15,7 @@\n \t       const char *server_name,\n \t       hdb_entry_ex *client,\n \t       krb5_principal client_principal,\n+               const char *tgt_realm,\n \t       hdb_entry_ex *krbtgt,\n \t       krb5_enctype krbtgt_etype,\n \t       krb5_principals spp,\n@@ -76,7 +77,7 @@\n \t\t\t\t &tgt->transited, &et,\n \t\t\t\t krb5_principal_get_realm(context, client_principal),\n \t\t\t\t krb5_principal_get_realm(context, server->entry.principal),\n-\t\t\t\t krb5_principal_get_realm(context, krbtgt->entry.principal));\n+\t\t\t\t tgt_realm);\n     if(ret)\n \tgoto out;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\t\t krb5_principal_get_realm(context, krbtgt->entry.principal));"
            ],
            "added_lines": [
                "               const char *tgt_realm,",
                "\t\t\t\t tgt_realm);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-44273",
        "func_name": "e2guardian/Socket::startSslClient",
        "description": "e2guardian v5.4.x <= v5.4.3r is affected by missing SSL certificate validation in the SSL MITM engine. In standalone mode (i.e., acting as a proxy or a transparent proxy), with SSL MITM enabled, e2guardian, if built with OpenSSL v1.1.x, did not validate hostnames in certificates of the web servers that it connected to, and thus was itself vulnerable to MITM attacks.",
        "git_url": "https://github.com/e2guardian/e2guardian/commit/eae46a7e2a57103aadca903c4a24cca94dc502a2",
        "commit_title": "Fix bug #707 cert hostnames not being checked",
        "commit_text": "- only happened when openssl v1.1 is used",
        "func_before": "int Socket::startSslClient(const std::string &certificate_path, String hostname)\n{\n    if (isssl) {\n        stopSsl();\n    }\n\n    ERR_clear_error();\n#if OPENSSL_VERSION_NUMBER < 0x10100000L\n    ctx = SSL_CTX_new(SSLv23_client_method());\n#else\n    ctx = SSL_CTX_new(TLS_client_method());\n#endif\n\n    if (ctx == NULL) {\n#ifdef NETDEBUG\n        std::cout << thread_id << \"Error ssl context is null (check that openssl has been inited)\" << std::endl;\n#endif\n        log_ssl_errors(\"Error ssl context is null for %s\", hostname.c_str());\n        return -1;\n    }\n\n    //set the timeout for the ssl session\n    if (SSL_CTX_set_timeout(ctx, 130l) < 1) {\n            SSL_CTX_free(ctx);\n            ctx = NULL;\n        return -1;\n    }\n\n    //load certs\n    ERR_clear_error();\n    if (certificate_path.length()) {\n        if (!SSL_CTX_load_verify_locations(ctx, NULL, certificate_path.c_str())) {\n#ifdef NETDEBUG\n            std::cout << thread_id << \"couldnt load certificates\" << std::endl;\n#endif\n            log_ssl_errors(\"couldnt load certificates from %s\", certificate_path.c_str());\n            //tidy up\n            SSL_CTX_free(ctx);\n            ctx = NULL;\n            return -2;\n        }\n    } else if (!SSL_CTX_set_default_verify_paths(ctx)) //use default if no certPpath given\n    {\n#ifdef NETDEBUG\n        std::cout << thread_id << \"couldnt load certificates\" << std::endl;\n#endif\n            log_ssl_errors(\"couldnt load default certificates for %s\", hostname.c_str());\n        //tidy up\n        SSL_CTX_free(ctx);\n        ctx = NULL;\n        return -2;\n    }\n\n    // add validation params\n    ERR_clear_error();\n    X509_VERIFY_PARAM *x509_param = X509_VERIFY_PARAM_new();\n    if (!x509_param) {\n        log_ssl_errors(\"couldnt add validation params for %s\", hostname.c_str());\n        //X509_VERIFY_PARAM_free(x509_param);\n            SSL_CTX_free(ctx);\n            ctx = NULL;\n        return -2;\n    }\n\n    ERR_clear_error();\n    if (!X509_VERIFY_PARAM_set_flags(x509_param, X509_V_FLAG_TRUSTED_FIRST)) {\n        log_ssl_errors(\"couldnt add validation params for %s\", hostname.c_str());\n        X509_VERIFY_PARAM_free(x509_param);\n            SSL_CTX_free(ctx);\n            ctx = NULL;\n        return -2;\n    }\n\n    ERR_clear_error();\n    if (!SSL_CTX_set1_param(ctx, x509_param)) {\n        log_ssl_errors(\"couldnt add validation params for %s\", hostname.c_str());\n        X509_VERIFY_PARAM_free(x509_param);\n            SSL_CTX_free(ctx);\n            ctx = NULL;\n        return -2;\n    }\n\n    X509_VERIFY_PARAM_free(x509_param);     // try not freeing this as SSL_CTX_free seems to be ring to free it\n\n    //hand socket over to ssl lib\n    ERR_clear_error();\n    ssl = SSL_new(ctx);\n    SSL_set_options(ssl, SSL_OP_ALL);\n    SSL_set_mode(ssl, SSL_MODE_AUTO_RETRY);\n    SSL_set_connect_state(ssl);\n\n    //fcntl(this->getFD() ,F_SETFL, O_NONBLOCK); // blocking mode used currently\n    SSL_set_fd(ssl, this->getFD());\n    SSL_set_tlsext_host_name(ssl, hostname.c_str());\n\n    //make io non blocking as select wont tell us if we can do a read without blocking\n    //BIO_set_nbio(SSL_get_rbio(ssl),1l);  // blocking mode used currently\n    //BIO_set_nbio(SSL_get_wbio(ssl),1l); // blocking mode used currently\n    ERR_clear_error();\n    int rc = SSL_connect(ssl);\n    if (rc < 0) {\n        log_ssl_errors(\"ssl_connect failed to %s\", hostname.c_str());\n#ifdef NETDEBUG\n        std::cout << thread_id << \"ssl_connect failed with error \" << SSL_get_error(ssl, rc) << std::endl;\n#endif\n        // tidy up\n        SSL_free(ssl);\n        ssl = NULL;\n        SSL_CTX_free(ctx);\n        ctx = NULL;\n        return -3;\n    }\n\n    //should be safer to do this last as nothing will ever try to use a ssl socket that isnt fully setup\n    isssl = true;\n    issslserver = false;\n    return 0;\n}",
        "func": "int Socket::startSslClient(const std::string &certificate_path, String hostname)\n{\n    if (isssl) {\n        stopSsl();\n    }\n\n    ERR_clear_error();\n#if OPENSSL_VERSION_NUMBER < 0x10100000L\n    ctx = SSL_CTX_new(SSLv23_client_method());\n#else\n    ctx = SSL_CTX_new(TLS_client_method());\n#endif\n\n    if (ctx == NULL) {\n#ifdef NETDEBUG\n        std::cout << thread_id << \"Error ssl context is null (check that openssl has been inited)\" << std::endl;\n#endif\n        log_ssl_errors(\"Error ssl context is null for %s\", hostname.c_str());\n        return -1;\n    }\n\n    //set the timeout for the ssl session\n    if (SSL_CTX_set_timeout(ctx, 130l) < 1) {\n            SSL_CTX_free(ctx);\n            ctx = NULL;\n        return -1;\n    }\n\n    //load certs\n    ERR_clear_error();\n    if (certificate_path.length()) {\n        if (!SSL_CTX_load_verify_locations(ctx, NULL, certificate_path.c_str())) {\n#ifdef NETDEBUG\n            std::cout << thread_id << \"couldnt load certificates\" << std::endl;\n#endif\n            log_ssl_errors(\"couldnt load certificates from %s\", certificate_path.c_str());\n            //tidy up\n            SSL_CTX_free(ctx);\n            ctx = NULL;\n            return -2;\n        }\n    } else if (!SSL_CTX_set_default_verify_paths(ctx)) //use default if no certPpath given\n    {\n#ifdef NETDEBUG\n        std::cout << thread_id << \"couldnt load certificates\" << std::endl;\n#endif\n            log_ssl_errors(\"couldnt load default certificates for %s\", hostname.c_str());\n        //tidy up\n        SSL_CTX_free(ctx);\n        ctx = NULL;\n        return -2;\n    }\n\n    // add validation params\n    ERR_clear_error();\n    X509_VERIFY_PARAM *x509_param = X509_VERIFY_PARAM_new();\n    if (!x509_param) {\n        log_ssl_errors(\"couldnt add validation params for %s\", hostname.c_str());\n        //X509_VERIFY_PARAM_free(x509_param);\n            SSL_CTX_free(ctx);\n            ctx = NULL;\n        return -2;\n    }\n\n    ERR_clear_error();\n    if (!X509_VERIFY_PARAM_set_flags(x509_param, X509_V_FLAG_TRUSTED_FIRST)) {\n        log_ssl_errors(\"couldnt add validation params for %s\", hostname.c_str());\n        X509_VERIFY_PARAM_free(x509_param);\n            SSL_CTX_free(ctx);\n            ctx = NULL;\n        return -2;\n    }\n\n    ERR_clear_error();\n    if (!SSL_CTX_set1_param(ctx, x509_param)) {\n        log_ssl_errors(\"couldnt add validation params for %s\", hostname.c_str());\n        X509_VERIFY_PARAM_free(x509_param);\n            SSL_CTX_free(ctx);\n            ctx = NULL;\n        return -2;\n    }\n\n    X509_VERIFY_PARAM_free(x509_param);     // try not freeing this as SSL_CTX_free seems to be ring to free it\n\n    //hand socket over to ssl lib\n    ERR_clear_error();\n    ssl = SSL_new(ctx);\n    SSL_set_options(ssl, SSL_OP_ALL);\n    SSL_set_mode(ssl, SSL_MODE_AUTO_RETRY);\n    SSL_set_connect_state(ssl);\n\n    //fcntl(this->getFD() ,F_SETFL, O_NONBLOCK); // blocking mode used currently\n    SSL_set_fd(ssl, this->getFD());\n    SSL_set_tlsext_host_name(ssl, hostname.c_str());\n#if OPENSSL_VERSION_NUMBER < 0x10100000L\n#else\n  X509_VERIFY_PARAM_set1_host(SSL_get0_param(ssl),hostname.c_str(),0);\n#endif\n\n    //make io non blocking as select wont tell us if we can do a read without blocking\n    //BIO_set_nbio(SSL_get_rbio(ssl),1l);  // blocking mode used currently\n    //BIO_set_nbio(SSL_get_wbio(ssl),1l); // blocking mode used currently\n    ERR_clear_error();\n    int rc = SSL_connect(ssl);\n    if (rc < 0) {\n        log_ssl_errors(\"ssl_connect failed to %s\", hostname.c_str());\n#ifdef NETDEBUG\n        std::cout << thread_id << \"ssl_connect failed with error \" << SSL_get_error(ssl, rc) << std::endl;\n#endif\n        // tidy up\n        SSL_free(ssl);\n        ssl = NULL;\n        SSL_CTX_free(ctx);\n        ctx = NULL;\n        return -3;\n    }\n\n    //should be safer to do this last as nothing will ever try to use a ssl socket that isnt fully setup\n    isssl = true;\n    issslserver = false;\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -92,6 +92,10 @@\n     //fcntl(this->getFD() ,F_SETFL, O_NONBLOCK); // blocking mode used currently\n     SSL_set_fd(ssl, this->getFD());\n     SSL_set_tlsext_host_name(ssl, hostname.c_str());\n+#if OPENSSL_VERSION_NUMBER < 0x10100000L\n+#else\n+  X509_VERIFY_PARAM_set1_host(SSL_get0_param(ssl),hostname.c_str(),0);\n+#endif\n \n     //make io non blocking as select wont tell us if we can do a read without blocking\n     //BIO_set_nbio(SSL_get_rbio(ssl),1l);  // blocking mode used currently",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "#if OPENSSL_VERSION_NUMBER < 0x10100000L",
                "#else",
                "  X509_VERIFY_PARAM_set1_host(SSL_get0_param(ssl),hostname.c_str(),0);",
                "#endif"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-39334",
        "func_name": "nextcloud/desktop/main",
        "description": "Nextcloud also ships a CLI utility called nextcloudcmd which is sometimes used for automated scripting and headless servers. Versions of nextcloudcmd prior to 3.6.1 would incorrectly trust invalid TLS certificates, which may enable a Man-in-the-middle attack that exposes sensitive data or credentials to a network attacker. This affects the CLI only. It does not affect the standard GUI desktop Nextcloud clients, and it does not affect the Nextcloud server.",
        "git_url": "https://github.com/nextcloud/desktop/commit/49305319496965ecf18963a81bf8a5a69df0d97e",
        "commit_title": "Command-line client. Do not trust SSL certificates by default, unlss '--trust' option is set.",
        "commit_text": "",
        "func_before": "int main(int argc, char **argv)\n{\n#ifdef Q_OS_WIN\n    SetDllDirectory(L\"\");\n#endif\n    QCoreApplication app(argc, argv);\n\n#ifdef Q_OS_WIN\n    // Ensure OpenSSL config file is only loaded from app directory\n    QString opensslConf = QCoreApplication::applicationDirPath() + QString(\"/openssl.cnf\");\n    qputenv(\"OPENSSL_CONF\", opensslConf.toLocal8Bit());\n#endif\n\n    CmdOptions options;\n    options.silent = false;\n    options.trustSSL = false;\n    options.useNetrc = false;\n    options.interactive = true;\n    options.ignoreHiddenFiles = false; // Default is to sync hidden files\n    options.restartTimes = 3;\n    options.uplimit = 0;\n    options.downlimit = 0;\n\n    parseOptions(app.arguments(), &options);\n\n    if (options.silent) {\n        qInstallMessageHandler(nullMessageHandler);\n    } else {\n        qSetMessagePattern(\"%{time MM-dd hh:mm:ss:zzz} [ %{type} %{category} ]%{if-debug}\\t[ %{function} ]%{endif}:\\t%{message}\");\n    }\n\n    AccountPtr account = Account::create();\n\n    if (!account) {\n        qFatal(\"Could not initialize account!\");\n        return EXIT_FAILURE;\n    }\n\n    if (options.target_url.contains(\"/webdav\", Qt::CaseInsensitive) || options.target_url.contains(\"/dav\", Qt::CaseInsensitive)) {\n        qWarning(\"Dav or webdav in server URL.\");\n        std::cerr << \"Error! Please specify only the base URL of your host with username and password. Example:\" << std::endl\n                  << \"http(s)://username:password@cloud.example.com\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    QUrl hostUrl = QUrl::fromUserInput((options.target_url.endsWith(QLatin1Char('/')) || options.target_url.endsWith(QLatin1Char('\\\\'))) ? options.target_url.chopped(1) : options.target_url);\n\n    // Order of retrieval attempt (later attempts override earlier ones):\n    // 1. From URL\n    // 2. From options\n    // 3. From netrc (if enabled)\n    // 4. From prompt (if interactive)\n\n    QString user = hostUrl.userName();\n    QString password = hostUrl.password();\n\n    if (!options.user.isEmpty()) {\n        user = options.user;\n    }\n\n    if (!options.password.isEmpty()) {\n        password = options.password;\n    }\n\n    if (options.useNetrc) {\n        NetrcParser parser;\n        if (parser.parse()) {\n            NetrcParser::LoginPair pair = parser.find(hostUrl.host());\n            user = pair.first;\n            password = pair.second;\n        }\n    }\n\n    if (options.interactive) {\n        if (user.isEmpty()) {\n            std::cout << \"Please enter username: \";\n            std::string s;\n            std::getline(std::cin, s);\n            user = QString::fromStdString(s);\n        }\n        if (password.isEmpty()) {\n            password = queryPassword(user);\n        }\n    }\n\n    // Find the folder and the original owncloud url\n\n    hostUrl.setScheme(hostUrl.scheme().replace(\"owncloud\", \"http\"));\n\n    QUrl credentialFreeUrl = hostUrl;\n    credentialFreeUrl.setUserName(QString());\n    credentialFreeUrl.setPassword(QString());\n\n    const QString folder = options.remotePath;\n\n    if (!options.proxy.isNull()) {\n        QString host;\n        int port = 0;\n        bool ok = false;\n\n        QStringList pList = options.proxy.split(':');\n        if (pList.count() == 3) {\n            // http: //192.168.178.23 : 8080\n            //  0            1            2\n            host = pList.at(1);\n            if (host.startsWith(\"//\"))\n                host.remove(0, 2);\n\n            port = pList.at(2).toInt(&ok);\n\n            QNetworkProxyFactory::setUseSystemConfiguration(false);\n            QNetworkProxy::setApplicationProxy(QNetworkProxy(QNetworkProxy::HttpProxy, host, port));\n        } else {\n            qFatal(\"Could not read httpproxy. The proxy should have the format \\\"http://hostname:port\\\".\");\n        }\n    }\n\n    auto *sslErrorHandler = new SimpleSslErrorHandler;\n\n#ifdef TOKEN_AUTH_ONLY\n    auto *cred = new TokenCredentials(user, password, \"\");\n    account->setCredentials(cred);\n#else\n    auto *cred = new HttpCredentialsText(user, password);\n    account->setCredentials(cred);\n    if (options.trustSSL) {\n        cred->setSSLTrusted(true);\n    }\n#endif\n\n    account->setUrl(hostUrl);\n    account->setSslErrorHandler(sslErrorHandler);\n\n    QEventLoop loop;\n    auto *job = new JsonApiJob(account, QLatin1String(\"ocs/v1.php/cloud/capabilities\"));\n    QObject::connect(job, &JsonApiJob::jsonReceived, [&](const QJsonDocument &json) {\n        auto caps = json.object().value(\"ocs\").toObject().value(\"data\").toObject().value(\"capabilities\").toObject();\n        qDebug() << \"Server capabilities\" << caps;\n        account->setCapabilities(caps.toVariantMap());\n        account->setServerVersion(caps[\"core\"].toObject()[\"status\"].toObject()[\"version\"].toString());\n        loop.quit();\n    });\n    job->start();\n    loop.exec();\n\n    if (job->reply()->error() != QNetworkReply::NoError){\n        std::cout<<\"Error connecting to server\\n\";\n        return EXIT_FAILURE;\n    }\n\n    job = new JsonApiJob(account, QLatin1String(\"ocs/v1.php/cloud/user\"));\n    QObject::connect(job, &JsonApiJob::jsonReceived, [&](const QJsonDocument &json) {\n        const QJsonObject data = json.object().value(\"ocs\").toObject().value(\"data\").toObject();\n        account->setDavUser(data.value(\"id\").toString());\n        account->setDavDisplayName(data.value(\"display-name\").toString());\n        loop.quit();\n    });\n    job->start();\n    loop.exec();\n\n    // much lower age than the default since this utility is usually made to be run right after a change in the tests\n    SyncEngine::minimumFileAgeForUpload = std::chrono::milliseconds(0);\n\n    int restartCount = 0;\nrestart_sync:\n\n    opts = &options;\n\n    QStringList selectiveSyncList;\n    if (!options.unsyncedfolders.isEmpty()) {\n        QFile f(options.unsyncedfolders);\n        if (!f.open(QFile::ReadOnly)) {\n            qCritical() << \"Could not open file containing the list of unsynced folders: \" << options.unsyncedfolders;\n        } else {\n            // filter out empty lines and comments\n            selectiveSyncList = QString::fromUtf8(f.readAll()).split('\\n').filter(QRegularExpression(\"\\\\S+\")).filter(QRegularExpression(\"^[^#]\"));\n\n            for (int i = 0; i < selectiveSyncList.count(); ++i) {\n                if (!selectiveSyncList.at(i).endsWith(QLatin1Char('/'))) {\n                    selectiveSyncList[i].append(QLatin1Char('/'));\n                }\n            }\n        }\n    }\n\n    Cmd cmd;\n    QString dbPath = options.source_dir + SyncJournalDb::makeDbName(options.source_dir, credentialFreeUrl, folder, user);\n    SyncJournalDb db(dbPath);\n\n    if (!selectiveSyncList.empty()) {\n        selectiveSyncFixup(&db, selectiveSyncList);\n    }\n\n    SyncOptions opt;\n    opt.fillFromEnvironmentVariables();\n    opt.verifyChunkSizes();\n    SyncEngine engine(account, options.source_dir, opt, folder, &db);\n    engine.setIgnoreHiddenFiles(options.ignoreHiddenFiles);\n    engine.setNetworkLimits(options.uplimit, options.downlimit);\n    QObject::connect(&engine, &SyncEngine::finished,\n        [&app](bool result) { app.exit(result ? EXIT_SUCCESS : EXIT_FAILURE); });\n    QObject::connect(&engine, &SyncEngine::transmissionProgress, &cmd, &Cmd::transmissionProgressSlot);\n    QObject::connect(&engine, &SyncEngine::syncError,\n        [](const QString &error) { qWarning() << \"Sync error:\" << error; });\n\n\n    // Exclude lists\n\n    bool hasUserExcludeFile = !options.exclude.isEmpty();\n    QString systemExcludeFile = ConfigFile::excludeFileFromSystem();\n\n    // Always try to load the user-provided exclude list if one is specified\n    if (hasUserExcludeFile) {\n        engine.excludedFiles().addExcludeFilePath(options.exclude);\n    }\n    // Load the system list if available, or if there's no user-provided list\n    if (!hasUserExcludeFile || QFile::exists(systemExcludeFile)) {\n        engine.excludedFiles().addExcludeFilePath(systemExcludeFile);\n    }\n\n    if (!engine.excludedFiles().reloadExcludeFiles()) {\n        qFatal(\"Cannot load system exclude list or list supplied via --exclude\");\n        return EXIT_FAILURE;\n    }\n\n\n    // Have to be done async, else, an error before exec() does not terminate the event loop.\n    QMetaObject::invokeMethod(&engine, \"startSync\", Qt::QueuedConnection);\n\n    int resultCode = app.exec();\n\n    if (engine.isAnotherSyncNeeded() != NoFollowUpSync) {\n        if (restartCount < options.restartTimes) {\n            restartCount++;\n            qDebug() << \"Restarting Sync, because another sync is needed\" << restartCount;\n            goto restart_sync;\n        }\n        qWarning() << \"Another sync is needed, but not done because restart count is exceeded\" << restartCount;\n    }\n\n    return resultCode;\n}",
        "func": "int main(int argc, char **argv)\n{\n#ifdef Q_OS_WIN\n    SetDllDirectory(L\"\");\n#endif\n    QCoreApplication app(argc, argv);\n\n#ifdef Q_OS_WIN\n    // Ensure OpenSSL config file is only loaded from app directory\n    QString opensslConf = QCoreApplication::applicationDirPath() + QString(\"/openssl.cnf\");\n    qputenv(\"OPENSSL_CONF\", opensslConf.toLocal8Bit());\n#endif\n\n    CmdOptions options;\n    options.silent = false;\n    options.trustSSL = false;\n    options.useNetrc = false;\n    options.interactive = true;\n    options.ignoreHiddenFiles = false; // Default is to sync hidden files\n    options.restartTimes = 3;\n    options.uplimit = 0;\n    options.downlimit = 0;\n\n    parseOptions(app.arguments(), &options);\n\n    if (options.silent) {\n        qInstallMessageHandler(nullMessageHandler);\n    } else {\n        qSetMessagePattern(\"%{time MM-dd hh:mm:ss:zzz} [ %{type} %{category} ]%{if-debug}\\t[ %{function} ]%{endif}:\\t%{message}\");\n    }\n\n    AccountPtr account = Account::create();\n\n    if (!account) {\n        qFatal(\"Could not initialize account!\");\n        return EXIT_FAILURE;\n    }\n\n    if (options.target_url.contains(\"/webdav\", Qt::CaseInsensitive) || options.target_url.contains(\"/dav\", Qt::CaseInsensitive)) {\n        qWarning(\"Dav or webdav in server URL.\");\n        std::cerr << \"Error! Please specify only the base URL of your host with username and password. Example:\" << std::endl\n                  << \"http(s)://username:password@cloud.example.com\" << std::endl;\n        return EXIT_FAILURE;\n    }\n\n    QUrl hostUrl = QUrl::fromUserInput((options.target_url.endsWith(QLatin1Char('/')) || options.target_url.endsWith(QLatin1Char('\\\\'))) ? options.target_url.chopped(1) : options.target_url);\n\n    // Order of retrieval attempt (later attempts override earlier ones):\n    // 1. From URL\n    // 2. From options\n    // 3. From netrc (if enabled)\n    // 4. From prompt (if interactive)\n\n    QString user = hostUrl.userName();\n    QString password = hostUrl.password();\n\n    if (!options.user.isEmpty()) {\n        user = options.user;\n    }\n\n    if (!options.password.isEmpty()) {\n        password = options.password;\n    }\n\n    if (options.useNetrc) {\n        NetrcParser parser;\n        if (parser.parse()) {\n            NetrcParser::LoginPair pair = parser.find(hostUrl.host());\n            user = pair.first;\n            password = pair.second;\n        }\n    }\n\n    if (options.interactive) {\n        if (user.isEmpty()) {\n            std::cout << \"Please enter username: \";\n            std::string s;\n            std::getline(std::cin, s);\n            user = QString::fromStdString(s);\n        }\n        if (password.isEmpty()) {\n            password = queryPassword(user);\n        }\n    }\n\n    // Find the folder and the original owncloud url\n\n    hostUrl.setScheme(hostUrl.scheme().replace(\"owncloud\", \"http\"));\n\n    QUrl credentialFreeUrl = hostUrl;\n    credentialFreeUrl.setUserName(QString());\n    credentialFreeUrl.setPassword(QString());\n\n    const QString folder = options.remotePath;\n\n    if (!options.proxy.isNull()) {\n        QString host;\n        int port = 0;\n        bool ok = false;\n\n        QStringList pList = options.proxy.split(':');\n        if (pList.count() == 3) {\n            // http: //192.168.178.23 : 8080\n            //  0            1            2\n            host = pList.at(1);\n            if (host.startsWith(\"//\"))\n                host.remove(0, 2);\n\n            port = pList.at(2).toInt(&ok);\n\n            QNetworkProxyFactory::setUseSystemConfiguration(false);\n            QNetworkProxy::setApplicationProxy(QNetworkProxy(QNetworkProxy::HttpProxy, host, port));\n        } else {\n            qFatal(\"Could not read httpproxy. The proxy should have the format \\\"http://hostname:port\\\".\");\n        }\n    }\n\n    auto *sslErrorHandler = new SimpleSslErrorHandler;\n\n#ifdef TOKEN_AUTH_ONLY\n    auto *cred = new TokenCredentials(user, password, \"\");\n    account->setCredentials(cred);\n#else\n    auto *cred = new HttpCredentialsText(user, password);\n    account->setCredentials(cred);\n    if (options.trustSSL) {\n        cred->setSSLTrusted(true);\n    }\n#endif\n\n    account->setUrl(hostUrl);\n    account->setSslErrorHandler(sslErrorHandler);\n    account->setTrustCertificates(options.trustSSL);\n\n    QEventLoop loop;\n    auto *job = new JsonApiJob(account, QLatin1String(\"ocs/v1.php/cloud/capabilities\"));\n    QObject::connect(job, &JsonApiJob::jsonReceived, [&](const QJsonDocument &json) {\n        auto caps = json.object().value(\"ocs\").toObject().value(\"data\").toObject().value(\"capabilities\").toObject();\n        qDebug() << \"Server capabilities\" << caps;\n        account->setCapabilities(caps.toVariantMap());\n        account->setServerVersion(caps[\"core\"].toObject()[\"status\"].toObject()[\"version\"].toString());\n        loop.quit();\n    });\n    job->start();\n    loop.exec();\n\n    if (job->reply()->error() != QNetworkReply::NoError){\n        std::cout<<\"Error connecting to server\\n\";\n        return EXIT_FAILURE;\n    }\n\n    job = new JsonApiJob(account, QLatin1String(\"ocs/v1.php/cloud/user\"));\n    QObject::connect(job, &JsonApiJob::jsonReceived, [&](const QJsonDocument &json) {\n        const QJsonObject data = json.object().value(\"ocs\").toObject().value(\"data\").toObject();\n        account->setDavUser(data.value(\"id\").toString());\n        account->setDavDisplayName(data.value(\"display-name\").toString());\n        loop.quit();\n    });\n    job->start();\n    loop.exec();\n\n    // much lower age than the default since this utility is usually made to be run right after a change in the tests\n    SyncEngine::minimumFileAgeForUpload = std::chrono::milliseconds(0);\n\n    int restartCount = 0;\nrestart_sync:\n\n    opts = &options;\n\n    QStringList selectiveSyncList;\n    if (!options.unsyncedfolders.isEmpty()) {\n        QFile f(options.unsyncedfolders);\n        if (!f.open(QFile::ReadOnly)) {\n            qCritical() << \"Could not open file containing the list of unsynced folders: \" << options.unsyncedfolders;\n        } else {\n            // filter out empty lines and comments\n            selectiveSyncList = QString::fromUtf8(f.readAll()).split('\\n').filter(QRegularExpression(\"\\\\S+\")).filter(QRegularExpression(\"^[^#]\"));\n\n            for (int i = 0; i < selectiveSyncList.count(); ++i) {\n                if (!selectiveSyncList.at(i).endsWith(QLatin1Char('/'))) {\n                    selectiveSyncList[i].append(QLatin1Char('/'));\n                }\n            }\n        }\n    }\n\n    Cmd cmd;\n    QString dbPath = options.source_dir + SyncJournalDb::makeDbName(options.source_dir, credentialFreeUrl, folder, user);\n    SyncJournalDb db(dbPath);\n\n    if (!selectiveSyncList.empty()) {\n        selectiveSyncFixup(&db, selectiveSyncList);\n    }\n\n    SyncOptions opt;\n    opt.fillFromEnvironmentVariables();\n    opt.verifyChunkSizes();\n    SyncEngine engine(account, options.source_dir, opt, folder, &db);\n    engine.setIgnoreHiddenFiles(options.ignoreHiddenFiles);\n    engine.setNetworkLimits(options.uplimit, options.downlimit);\n    QObject::connect(&engine, &SyncEngine::finished,\n        [&app](bool result) { app.exit(result ? EXIT_SUCCESS : EXIT_FAILURE); });\n    QObject::connect(&engine, &SyncEngine::transmissionProgress, &cmd, &Cmd::transmissionProgressSlot);\n    QObject::connect(&engine, &SyncEngine::syncError,\n        [](const QString &error) { qWarning() << \"Sync error:\" << error; });\n\n\n    // Exclude lists\n\n    bool hasUserExcludeFile = !options.exclude.isEmpty();\n    QString systemExcludeFile = ConfigFile::excludeFileFromSystem();\n\n    // Always try to load the user-provided exclude list if one is specified\n    if (hasUserExcludeFile) {\n        engine.excludedFiles().addExcludeFilePath(options.exclude);\n    }\n    // Load the system list if available, or if there's no user-provided list\n    if (!hasUserExcludeFile || QFile::exists(systemExcludeFile)) {\n        engine.excludedFiles().addExcludeFilePath(systemExcludeFile);\n    }\n\n    if (!engine.excludedFiles().reloadExcludeFiles()) {\n        qFatal(\"Cannot load system exclude list or list supplied via --exclude\");\n        return EXIT_FAILURE;\n    }\n\n\n    // Have to be done async, else, an error before exec() does not terminate the event loop.\n    QMetaObject::invokeMethod(&engine, \"startSync\", Qt::QueuedConnection);\n\n    int resultCode = app.exec();\n\n    if (engine.isAnotherSyncNeeded() != NoFollowUpSync) {\n        if (restartCount < options.restartTimes) {\n            restartCount++;\n            qDebug() << \"Restarting Sync, because another sync is needed\" << restartCount;\n            goto restart_sync;\n        }\n        qWarning() << \"Another sync is needed, but not done because restart count is exceeded\" << restartCount;\n    }\n\n    return resultCode;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -130,6 +130,7 @@\n \n     account->setUrl(hostUrl);\n     account->setSslErrorHandler(sslErrorHandler);\n+    account->setTrustCertificates(options.trustSSL);\n \n     QEventLoop loop;\n     auto *job = new JsonApiJob(account, QLatin1String(\"ocs/v1.php/cloud/capabilities\"));",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    account->setTrustCertificates(options.trustSSL);"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-39334",
        "func_name": "nextcloud/desktop/SimpleSslErrorHandler::handleErrors",
        "description": "Nextcloud also ships a CLI utility called nextcloudcmd which is sometimes used for automated scripting and headless servers. Versions of nextcloudcmd prior to 3.6.1 would incorrectly trust invalid TLS certificates, which may enable a Man-in-the-middle attack that exposes sensitive data or credentials to a network attacker. This affects the CLI only. It does not affect the standard GUI desktop Nextcloud clients, and it does not affect the Nextcloud server.",
        "git_url": "https://github.com/nextcloud/desktop/commit/49305319496965ecf18963a81bf8a5a69df0d97e",
        "commit_title": "Command-line client. Do not trust SSL certificates by default, unlss '--trust' option is set.",
        "commit_text": "",
        "func_before": "bool SimpleSslErrorHandler::handleErrors(QList<QSslError> errors, const QSslConfiguration &conf, QList<QSslCertificate> *certs, OCC::AccountPtr account)\n{\n    (void)account;\n    (void)conf;\n\n    if (!certs) {\n        qDebug() << \"Certs parameter required but is NULL!\";\n        return false;\n    }\n\n    for (const auto &error : qAsConst(errors)) {\n        certs->append(error.certificate());\n    }\n    return true;\n}",
        "func": "bool SimpleSslErrorHandler::handleErrors(QList<QSslError> errors, const QSslConfiguration &conf, QList<QSslCertificate> *certs, OCC::AccountPtr account)\n{\n    Q_UNUSED(conf);\n\n    if (!account || !certs) {\n        qDebug() << \"account and certs parameters are required!\";\n        return false;\n    }\n\n    if (account->trustCertificates()) {\n        for (const auto &error : qAsConst(errors)) {\n            certs->append(error.certificate());\n        }\n        return true;\n    }\n\n    for (const auto &error : qAsConst(errors)) {\n        if (!account->approvedCerts().contains(error.certificate())) {\n            certs->append(error.certificate());\n            return false;\n        }\n    }\n\n    return true;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,15 +1,25 @@\n bool SimpleSslErrorHandler::handleErrors(QList<QSslError> errors, const QSslConfiguration &conf, QList<QSslCertificate> *certs, OCC::AccountPtr account)\n {\n-    (void)account;\n-    (void)conf;\n+    Q_UNUSED(conf);\n \n-    if (!certs) {\n-        qDebug() << \"Certs parameter required but is NULL!\";\n+    if (!account || !certs) {\n+        qDebug() << \"account and certs parameters are required!\";\n         return false;\n     }\n \n+    if (account->trustCertificates()) {\n+        for (const auto &error : qAsConst(errors)) {\n+            certs->append(error.certificate());\n+        }\n+        return true;\n+    }\n+\n     for (const auto &error : qAsConst(errors)) {\n-        certs->append(error.certificate());\n+        if (!account->approvedCerts().contains(error.certificate())) {\n+            certs->append(error.certificate());\n+            return false;\n+        }\n     }\n+\n     return true;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    (void)account;",
                "    (void)conf;",
                "    if (!certs) {",
                "        qDebug() << \"Certs parameter required but is NULL!\";",
                "        certs->append(error.certificate());"
            ],
            "added_lines": [
                "    Q_UNUSED(conf);",
                "    if (!account || !certs) {",
                "        qDebug() << \"account and certs parameters are required!\";",
                "    if (account->trustCertificates()) {",
                "        for (const auto &error : qAsConst(errors)) {",
                "            certs->append(error.certificate());",
                "        }",
                "        return true;",
                "    }",
                "",
                "        if (!account->approvedCerts().contains(error.certificate())) {",
                "            certs->append(error.certificate());",
                "            return false;",
                "        }",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2022-39334",
        "func_name": "nextcloud/desktop/SimpleSslErrorHandler::handleErrors",
        "description": "Nextcloud also ships a CLI utility called nextcloudcmd which is sometimes used for automated scripting and headless servers. Versions of nextcloudcmd prior to 3.6.1 would incorrectly trust invalid TLS certificates, which may enable a Man-in-the-middle attack that exposes sensitive data or credentials to a network attacker. This affects the CLI only. It does not affect the standard GUI desktop Nextcloud clients, and it does not affect the Nextcloud server.",
        "git_url": "https://github.com/nextcloud/desktop/commit/564a3ad987a40135c9d6dedd5a1238caf0ce2d52",
        "commit_title": "Fix error in logic.",
        "commit_text": "",
        "func_before": "bool SimpleSslErrorHandler::handleErrors(QList<QSslError> errors, const QSslConfiguration &conf, QList<QSslCertificate> *certs, OCC::AccountPtr account)\n{\n    Q_UNUSED(conf);\n\n    if (!account || !certs) {\n        qDebug() << \"account and certs parameters are required!\";\n        return false;\n    }\n\n    if (account->trustCertificates()) {\n        for (const auto &error : qAsConst(errors)) {\n            certs->append(error.certificate());\n        }\n        return true;\n    }\n\n    for (const auto &error : qAsConst(errors)) {\n        if (!account->approvedCerts().contains(error.certificate())) {\n            certs->append(error.certificate());\n            return false;\n        }\n    }\n\n    return true;\n}",
        "func": "bool SimpleSslErrorHandler::handleErrors(QList<QSslError> errors, const QSslConfiguration &conf, QList<QSslCertificate> *certs, OCC::AccountPtr account)\n{\n    Q_UNUSED(conf);\n\n    if (!account || !certs) {\n        qDebug() << \"account and certs parameters are required!\";\n        return false;\n    }\n\n    if (account->trustCertificates()) {\n        for (const auto &error : qAsConst(errors)) {\n            certs->append(error.certificate());\n        }\n        return true;\n    }\n\n    bool allTrusted = true;\n\n    for (const auto &error : qAsConst(errors)) {\n        if (!account->approvedCerts().contains(error.certificate())) {\n            allTrusted = false;\n        }\n        certs->append(error.certificate());\n    }\n\n    return allTrusted;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -14,12 +14,14 @@\n         return true;\n     }\n \n+    bool allTrusted = true;\n+\n     for (const auto &error : qAsConst(errors)) {\n         if (!account->approvedCerts().contains(error.certificate())) {\n-            certs->append(error.certificate());\n-            return false;\n+            allTrusted = false;\n         }\n+        certs->append(error.certificate());\n     }\n \n-    return true;\n+    return allTrusted;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "            certs->append(error.certificate());",
                "            return false;",
                "    return true;"
            ],
            "added_lines": [
                "    bool allTrusted = true;",
                "",
                "            allTrusted = false;",
                "        certs->append(error.certificate());",
                "    return allTrusted;"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-24619",
        "func_name": "mltframework/shotcut/MainWindow::showUpgradePrompt",
        "description": "In mainwindow.cpp in Shotcut before 20.09.13, the upgrade check misuses TLS because of setPeerVerifyMode(QSslSocket::VerifyNone). A man-in-the-middle attacker could offer a spoofed download resource.",
        "git_url": "https://github.com/mltframework/shotcut/commit/f008adc039642307f6ee3378d378cdb842e52c1d",
        "commit_title": "fix upgrade check is not using TLS correctly",
        "commit_text": "",
        "func_before": "void MainWindow::showUpgradePrompt()\n{\n    if (Settings.checkUpgradeAutomatic()) {\n        showStatusMessage(\"Checking for upgrade...\");\n        QNetworkRequest request(QUrl(\"https://check.shotcut.org/version.json\"));\n        QSslConfiguration sslConfig = request.sslConfiguration();\n        sslConfig.setPeerVerifyMode(QSslSocket::VerifyNone);\n        request.setSslConfiguration(sslConfig);\n        m_network.get(request);\n    } else {\n        m_network.setStrictTransportSecurityEnabled(false);\n        QAction* action = new QAction(tr(\"Click here to check for a new version of Shotcut.\"), 0);\n        connect(action, SIGNAL(triggered(bool)), SLOT(on_actionUpgrade_triggered()));\n        showStatusMessage(action, 15 /* seconds */);\n    }\n}",
        "func": "void MainWindow::showUpgradePrompt()\n{\n    if (Settings.checkUpgradeAutomatic()) {\n        showStatusMessage(\"Checking for upgrade...\");\n        m_network.get(QNetworkRequest(QUrl(\"https://check.shotcut.org/version.json\")));\n    } else {\n        QAction* action = new QAction(tr(\"Click here to check for a new version of Shotcut.\"), 0);\n        connect(action, SIGNAL(triggered(bool)), SLOT(on_actionUpgrade_triggered()));\n        showStatusMessage(action, 15 /* seconds */);\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,13 +2,8 @@\n {\n     if (Settings.checkUpgradeAutomatic()) {\n         showStatusMessage(\"Checking for upgrade...\");\n-        QNetworkRequest request(QUrl(\"https://check.shotcut.org/version.json\"));\n-        QSslConfiguration sslConfig = request.sslConfiguration();\n-        sslConfig.setPeerVerifyMode(QSslSocket::VerifyNone);\n-        request.setSslConfiguration(sslConfig);\n-        m_network.get(request);\n+        m_network.get(QNetworkRequest(QUrl(\"https://check.shotcut.org/version.json\")));\n     } else {\n-        m_network.setStrictTransportSecurityEnabled(false);\n         QAction* action = new QAction(tr(\"Click here to check for a new version of Shotcut.\"), 0);\n         connect(action, SIGNAL(triggered(bool)), SLOT(on_actionUpgrade_triggered()));\n         showStatusMessage(action, 15 /* seconds */);",
        "diff_line_info": {
            "deleted_lines": [
                "        QNetworkRequest request(QUrl(\"https://check.shotcut.org/version.json\"));",
                "        QSslConfiguration sslConfig = request.sslConfiguration();",
                "        sslConfig.setPeerVerifyMode(QSslSocket::VerifyNone);",
                "        request.setSslConfiguration(sslConfig);",
                "        m_network.get(request);",
                "        m_network.setStrictTransportSecurityEnabled(false);"
            ],
            "added_lines": [
                "        m_network.get(QNetworkRequest(QUrl(\"https://check.shotcut.org/version.json\")));"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-24619",
        "func_name": "mltframework/shotcut/MainWindow::on_actionUpgrade_triggered",
        "description": "In mainwindow.cpp in Shotcut before 20.09.13, the upgrade check misuses TLS because of setPeerVerifyMode(QSslSocket::VerifyNone). A man-in-the-middle attacker could offer a spoofed download resource.",
        "git_url": "https://github.com/mltframework/shotcut/commit/f008adc039642307f6ee3378d378cdb842e52c1d",
        "commit_title": "fix upgrade check is not using TLS correctly",
        "commit_text": "",
        "func_before": "void MainWindow::on_actionUpgrade_triggered()\n{\n    if (Settings.askUpgradeAutmatic()) {\n        QMessageBox dialog(QMessageBox::Question,\n           qApp->applicationName(),\n           tr(\"Do you want to automatically check for updates in the future?\"),\n           QMessageBox::No |\n           QMessageBox::Yes,\n           this);\n        dialog.setWindowModality(QmlApplication::dialogModality());\n        dialog.setDefaultButton(QMessageBox::Yes);\n        dialog.setEscapeButton(QMessageBox::No);\n        dialog.setCheckBox(new QCheckBox(tr(\"Do not show this anymore.\", \"Automatic upgrade check dialog\")));\n        Settings.setCheckUpgradeAutomatic(dialog.exec() == QMessageBox::Yes);\n        if (dialog.checkBox()->isChecked())\n            Settings.setAskUpgradeAutomatic(false);\n    }\n    showStatusMessage(\"Checking for upgrade...\");\n    m_network.get(QNetworkRequest(QUrl(\"http://check.shotcut.org/version.json\")));\n}",
        "func": "void MainWindow::on_actionUpgrade_triggered()\n{\n    if (Settings.askUpgradeAutmatic()) {\n        QMessageBox dialog(QMessageBox::Question,\n           qApp->applicationName(),\n           tr(\"Do you want to automatically check for updates in the future?\"),\n           QMessageBox::No |\n           QMessageBox::Yes,\n           this);\n        dialog.setWindowModality(QmlApplication::dialogModality());\n        dialog.setDefaultButton(QMessageBox::Yes);\n        dialog.setEscapeButton(QMessageBox::No);\n        dialog.setCheckBox(new QCheckBox(tr(\"Do not show this anymore.\", \"Automatic upgrade check dialog\")));\n        Settings.setCheckUpgradeAutomatic(dialog.exec() == QMessageBox::Yes);\n        if (dialog.checkBox()->isChecked())\n            Settings.setAskUpgradeAutomatic(false);\n    }\n    showStatusMessage(\"Checking for upgrade...\");\n    m_network.get(QNetworkRequest(QUrl(\"https://check.shotcut.org/version.json\")));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -16,5 +16,5 @@\n             Settings.setAskUpgradeAutomatic(false);\n     }\n     showStatusMessage(\"Checking for upgrade...\");\n-    m_network.get(QNetworkRequest(QUrl(\"http://check.shotcut.org/version.json\")));\n+    m_network.get(QNetworkRequest(QUrl(\"https://check.shotcut.org/version.json\")));\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    m_network.get(QNetworkRequest(QUrl(\"http://check.shotcut.org/version.json\")));"
            ],
            "added_lines": [
                "    m_network.get(QNetworkRequest(QUrl(\"https://check.shotcut.org/version.json\")));"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-3336",
        "func_name": "wolfSSL/wolfssl/DoTls13CertificateVerify",
        "description": "DoTls13CertificateVerify in tls13.c in wolfSSL before 4.7.0 does not cease processing for certain anomalous peer behavior (sending an ED22519, ED448, ECC, or RSA signature without the corresponding certificate). The client side is affected because man-in-the-middle attackers can impersonate TLS 1.3 servers.",
        "git_url": "https://github.com/wolfSSL/wolfssl/commit/fad1e67677bf7797b6bd6e1f21a513c289d963a7",
        "commit_title": "TLS 1.3: ensure key for signature in CertificateVerify",
        "commit_text": "",
        "func_before": "static int DoTls13CertificateVerify(WOLFSSL* ssl, byte* input,\n                                    word32* inOutIdx, word32 totalSz)\n{\n    int         ret = 0;\n    buffer*     sig = &ssl->buffers.sig;\n#ifdef WOLFSSL_ASYNC_CRYPT\n    Dcv13Args* args = (Dcv13Args*)ssl->async.args;\n    typedef char args_test[sizeof(ssl->async.args) >= sizeof(*args) ? 1 : -1];\n    (void)sizeof(args_test);\n#else\n    Dcv13Args  args[1];\n#endif\n\n    WOLFSSL_START(WC_FUNC_CERTIFICATE_VERIFY_DO);\n    WOLFSSL_ENTER(\"DoTls13CertificateVerify\");\n\n#ifdef WOLFSSL_ASYNC_CRYPT\n    ret = wolfSSL_AsyncPop(ssl, &ssl->options.asyncState);\n    if (ret != WC_NOT_PENDING_E) {\n        /* Check for error */\n        if (ret < 0)\n            goto exit_dcv;\n    }\n    else\n#endif\n    {\n        /* Reset state */\n        ret = 0;\n        ssl->options.asyncState = TLS_ASYNC_BEGIN;\n        XMEMSET(args, 0, sizeof(Dcv13Args));\n        args->hashAlgo = sha_mac;\n        args->sigAlgo = anonymous_sa_algo;\n        args->idx = *inOutIdx;\n        args->begin = *inOutIdx;\n    #ifdef WOLFSSL_ASYNC_CRYPT\n        ssl->async.freeArgs = FreeDcv13Args;\n    #endif\n    }\n\n    switch(ssl->options.asyncState)\n    {\n        case TLS_ASYNC_BEGIN:\n        {\n        #ifdef WOLFSSL_CALLBACKS\n            if (ssl->hsInfoOn) AddPacketName(ssl, \"CertificateVerify\");\n            if (ssl->toInfoOn) AddLateName(\"CertificateVerify\",\n                                           &ssl->timeoutInfo);\n        #endif\n\n            /* Advance state and proceed */\n            ssl->options.asyncState = TLS_ASYNC_BUILD;\n        } /* case TLS_ASYNC_BEGIN */\n        FALL_THROUGH;\n\n        case TLS_ASYNC_BUILD:\n        {\n            /* Signature algorithm. */\n            if ((args->idx - args->begin) + ENUM_LEN + ENUM_LEN > totalSz) {\n                ERROR_OUT(BUFFER_ERROR, exit_dcv);\n            }\n            ret = DecodeTls13SigAlg(input + args->idx, &args->hashAlgo,\n                                                                &args->sigAlgo);\n            if (ret < 0)\n                goto exit_dcv;\n            args->idx += OPAQUE16_LEN;\n\n            /* Signature length. */\n            if ((args->idx - args->begin) + OPAQUE16_LEN > totalSz) {\n                ERROR_OUT(BUFFER_ERROR, exit_dcv);\n            }\n            ato16(input + args->idx, &args->sz);\n            args->idx += OPAQUE16_LEN;\n\n            /* Signature data. */\n            if ((args->idx - args->begin) + args->sz > totalSz ||\n                                                       args->sz > ENCRYPT_LEN) {\n                ERROR_OUT(BUFFER_ERROR, exit_dcv);\n            }\n\n            /* Check for public key of required type. */\n        #ifdef HAVE_ED25519\n            if (args->sigAlgo == ed25519_sa_algo &&\n                                                  !ssl->peerEd25519KeyPresent) {\n                WOLFSSL_MSG(\"Oops, peer sent ED25519 key but not in verify\");\n            }\n        #endif\n        #ifdef HAVE_ED448\n            if (args->sigAlgo == ed448_sa_algo && !ssl->peerEd448KeyPresent) {\n                WOLFSSL_MSG(\"Oops, peer sent ED448 key but not in verify\");\n            }\n        #endif\n        #ifdef HAVE_ECC\n            if (args->sigAlgo == ecc_dsa_sa_algo &&\n                                                   !ssl->peerEccDsaKeyPresent) {\n                WOLFSSL_MSG(\"Oops, peer sent ECC key but not in verify\");\n            }\n        #endif\n        #ifndef NO_RSA\n            if (args->sigAlgo == rsa_sa_algo) {\n                WOLFSSL_MSG(\"Oops, peer sent PKCS#1.5 signature\");\n                ERROR_OUT(INVALID_PARAMETER, exit_dcv);\n            }\n            if (args->sigAlgo == rsa_pss_sa_algo &&\n                         (ssl->peerRsaKey == NULL || !ssl->peerRsaKeyPresent)) {\n                WOLFSSL_MSG(\"Oops, peer sent RSA key but not in verify\");\n            }\n        #endif\n\n            sig->buffer = (byte*)XMALLOC(args->sz, ssl->heap,\n                                         DYNAMIC_TYPE_SIGNATURE);\n            if (sig->buffer == NULL) {\n                ERROR_OUT(MEMORY_E, exit_dcv);\n            }\n            sig->length = args->sz;\n            XMEMCPY(sig->buffer, input + args->idx, args->sz);\n\n        #ifdef HAVE_ECC\n            if (ssl->peerEccDsaKeyPresent) {\n                WOLFSSL_MSG(\"Doing ECC peer cert verify\");\n\n                args->sigData = (byte*)XMALLOC(MAX_SIG_DATA_SZ, ssl->heap,\n                                                        DYNAMIC_TYPE_SIGNATURE);\n                if (args->sigData == NULL) {\n                    ERROR_OUT(MEMORY_E, exit_dcv);\n                }\n\n                ret = CreateSigData(ssl, args->sigData, &args->sigDataSz, 1);\n                if (ret != 0)\n                    goto exit_dcv;\n                ret = CreateECCEncodedSig(args->sigData,\n                    args->sigDataSz, args->hashAlgo);\n                if (ret < 0)\n                    goto exit_dcv;\n                args->sigDataSz = (word16)ret;\n                ret = 0;\n            }\n        #endif\n        #ifdef HAVE_ED25519\n            if (ssl->peerEd25519KeyPresent) {\n                WOLFSSL_MSG(\"Doing ED25519 peer cert verify\");\n\n                args->sigData = (byte*)XMALLOC(MAX_SIG_DATA_SZ, ssl->heap,\n                                                        DYNAMIC_TYPE_SIGNATURE);\n                if (args->sigData == NULL) {\n                    ERROR_OUT(MEMORY_E, exit_dcv);\n                }\n\n                CreateSigData(ssl, args->sigData, &args->sigDataSz, 1);\n                ret = 0;\n            }\n        #endif\n        #ifdef HAVE_ED448\n            if (ssl->peerEd448KeyPresent) {\n                WOLFSSL_MSG(\"Doing ED448 peer cert verify\");\n\n                args->sigData = (byte*)XMALLOC(MAX_SIG_DATA_SZ, ssl->heap,\n                                                        DYNAMIC_TYPE_SIGNATURE);\n                if (args->sigData == NULL) {\n                    ERROR_OUT(MEMORY_E, exit_dcv);\n                }\n\n                CreateSigData(ssl, args->sigData, &args->sigDataSz, 1);\n                ret = 0;\n            }\n       #endif\n\n            /* Advance state and proceed */\n            ssl->options.asyncState = TLS_ASYNC_DO;\n        } /* case TLS_ASYNC_BUILD */\n        FALL_THROUGH;\n\n        case TLS_ASYNC_DO:\n        {\n        #ifndef NO_RSA\n            if (ssl->peerRsaKey != NULL && ssl->peerRsaKeyPresent != 0) {\n                WOLFSSL_MSG(\"Doing RSA peer cert verify\");\n\n                ret = RsaVerify(ssl, sig->buffer, (word32)sig->length, &args->output,\n                    args->sigAlgo, args->hashAlgo, ssl->peerRsaKey,\n                #ifdef HAVE_PK_CALLBACKS\n                    &ssl->buffers.peerRsaKey\n                #else\n                    NULL\n                #endif\n                );\n                if (ret >= 0) {\n                    args->sendSz = ret;\n                    ret = 0;\n                }\n            }\n        #endif /* !NO_RSA */\n        #ifdef HAVE_ECC\n            if (ssl->peerEccDsaKeyPresent) {\n                WOLFSSL_MSG(\"Doing ECC peer cert verify\");\n\n                ret = EccVerify(ssl, input + args->idx, args->sz,\n                    args->sigData, args->sigDataSz,\n                    ssl->peerEccDsaKey,\n                #ifdef HAVE_PK_CALLBACKS\n                    &ssl->buffers.peerEccDsaKey\n                #else\n                    NULL\n                #endif\n                );\n\n                if (ret >= 0) {\n                    FreeKey(ssl, DYNAMIC_TYPE_ECC, (void**)&ssl->peerEccDsaKey);\n                    ssl->peerEccDsaKeyPresent = 0;\n                }\n            }\n        #endif /* HAVE_ECC */\n        #ifdef HAVE_ED25519\n            if (ssl->peerEd25519KeyPresent) {\n                WOLFSSL_MSG(\"Doing ED25519 peer cert verify\");\n\n                ret = Ed25519Verify(ssl, input + args->idx, args->sz,\n                    args->sigData, args->sigDataSz,\n                    ssl->peerEd25519Key,\n                #ifdef HAVE_PK_CALLBACKS\n                    &ssl->buffers.peerEd25519Key\n                #else\n                    NULL\n                #endif\n                );\n\n                if (ret >= 0) {\n                    FreeKey(ssl, DYNAMIC_TYPE_ED25519,\n                                                  (void**)&ssl->peerEd25519Key);\n                    ssl->peerEd25519KeyPresent = 0;\n                }\n            }\n        #endif\n        #ifdef HAVE_ED448\n            if (ssl->peerEd448KeyPresent) {\n                WOLFSSL_MSG(\"Doing ED448 peer cert verify\");\n\n                ret = Ed448Verify(ssl, input + args->idx, args->sz,\n                    args->sigData, args->sigDataSz,\n                    ssl->peerEd448Key,\n                #ifdef HAVE_PK_CALLBACKS\n                    &ssl->buffers.peerEd448Key\n                #else\n                    NULL\n                #endif\n                );\n\n                if (ret >= 0) {\n                    FreeKey(ssl, DYNAMIC_TYPE_ED448,\n                                                    (void**)&ssl->peerEd448Key);\n                    ssl->peerEd448KeyPresent = 0;\n                }\n            }\n        #endif\n\n            /* Check for error */\n            if (ret != 0) {\n                goto exit_dcv;\n            }\n\n            /* Advance state and proceed */\n            ssl->options.asyncState = TLS_ASYNC_VERIFY;\n        } /* case TLS_ASYNC_DO */\n        FALL_THROUGH;\n\n        case TLS_ASYNC_VERIFY:\n        {\n        #if !defined(NO_RSA) && defined(WC_RSA_PSS)\n            if (ssl->peerRsaKey != NULL && ssl->peerRsaKeyPresent != 0) {\n                ret = CheckRSASignature(ssl, args->sigAlgo, args->hashAlgo,\n                                        args->output, args->sendSz);\n                if (ret != 0)\n                    goto exit_dcv;\n\n                FreeKey(ssl, DYNAMIC_TYPE_RSA, (void**)&ssl->peerRsaKey);\n                ssl->peerRsaKeyPresent = 0;\n            }\n        #endif /* !NO_RSA && WC_RSA_PSS */\n\n            /* Advance state and proceed */\n            ssl->options.asyncState = TLS_ASYNC_FINALIZE;\n        } /* case TLS_ASYNC_VERIFY */\n        FALL_THROUGH;\n\n        case TLS_ASYNC_FINALIZE:\n        {\n            ssl->options.havePeerVerify = 1;\n\n            /* Set final index */\n            args->idx += args->sz;\n            *inOutIdx = args->idx;\n\n            /* Encryption is always on: add padding */\n            *inOutIdx += ssl->keys.padSz;\n\n            /* Advance state and proceed */\n            ssl->options.asyncState = TLS_ASYNC_END;\n\n        #if !defined(NO_WOLFSSL_CLIENT)\n            if (ssl->options.side == WOLFSSL_CLIENT_END)\n                ssl->options.serverState = SERVER_CERT_VERIFY_COMPLETE;\n        #endif\n        } /* case TLS_ASYNC_FINALIZE */\n\n        case TLS_ASYNC_END:\n        {\n            break;\n        }\n        default:\n            ret = INPUT_CASE_ERROR;\n    } /* switch(ssl->options.asyncState) */\n\nexit_dcv:\n\n    WOLFSSL_LEAVE(\"DoTls13CertificateVerify\", ret);\n    WOLFSSL_END(WC_FUNC_CERTIFICATE_VERIFY_DO);\n\n#ifdef WOLFSSL_ASYNC_CRYPT\n    /* Handle async operation */\n    if (ret == WC_PENDING_E) {\n        /* Mark message as not received so it can process again */\n        ssl->msgsReceived.got_certificate_verify = 0;\n\n        return ret;\n    }\n    else\n#endif /* WOLFSSL_ASYNC_CRYPT */\n    if (ret != 0 && ret != INVALID_PARAMETER)\n        SendAlert(ssl, alert_fatal, decrypt_error);\n\n    /* Final cleanup */\n    FreeDcv13Args(ssl, args);\n    FreeKeyExchange(ssl);\n\n    return ret;\n}",
        "func": "static int DoTls13CertificateVerify(WOLFSSL* ssl, byte* input,\n                                    word32* inOutIdx, word32 totalSz)\n{\n    int         ret = 0;\n    buffer*     sig = &ssl->buffers.sig;\n#ifdef WOLFSSL_ASYNC_CRYPT\n    Dcv13Args* args = (Dcv13Args*)ssl->async.args;\n    typedef char args_test[sizeof(ssl->async.args) >= sizeof(*args) ? 1 : -1];\n    (void)sizeof(args_test);\n#else\n    Dcv13Args  args[1];\n#endif\n\n    WOLFSSL_START(WC_FUNC_CERTIFICATE_VERIFY_DO);\n    WOLFSSL_ENTER(\"DoTls13CertificateVerify\");\n\n#ifdef WOLFSSL_ASYNC_CRYPT\n    ret = wolfSSL_AsyncPop(ssl, &ssl->options.asyncState);\n    if (ret != WC_NOT_PENDING_E) {\n        /* Check for error */\n        if (ret < 0)\n            goto exit_dcv;\n    }\n    else\n#endif\n    {\n        /* Reset state */\n        ret = 0;\n        ssl->options.asyncState = TLS_ASYNC_BEGIN;\n        XMEMSET(args, 0, sizeof(Dcv13Args));\n        args->hashAlgo = sha_mac;\n        args->sigAlgo = anonymous_sa_algo;\n        args->idx = *inOutIdx;\n        args->begin = *inOutIdx;\n    #ifdef WOLFSSL_ASYNC_CRYPT\n        ssl->async.freeArgs = FreeDcv13Args;\n    #endif\n    }\n\n    switch(ssl->options.asyncState)\n    {\n        case TLS_ASYNC_BEGIN:\n        {\n        #ifdef WOLFSSL_CALLBACKS\n            if (ssl->hsInfoOn) AddPacketName(ssl, \"CertificateVerify\");\n            if (ssl->toInfoOn) AddLateName(\"CertificateVerify\",\n                                           &ssl->timeoutInfo);\n        #endif\n\n            /* Advance state and proceed */\n            ssl->options.asyncState = TLS_ASYNC_BUILD;\n        } /* case TLS_ASYNC_BEGIN */\n        FALL_THROUGH;\n\n        case TLS_ASYNC_BUILD:\n        {\n            /* Signature algorithm. */\n            if ((args->idx - args->begin) + ENUM_LEN + ENUM_LEN > totalSz) {\n                ERROR_OUT(BUFFER_ERROR, exit_dcv);\n            }\n            ret = DecodeTls13SigAlg(input + args->idx, &args->hashAlgo,\n                                                                &args->sigAlgo);\n            if (ret < 0)\n                goto exit_dcv;\n            args->idx += OPAQUE16_LEN;\n\n            /* Signature length. */\n            if ((args->idx - args->begin) + OPAQUE16_LEN > totalSz) {\n                ERROR_OUT(BUFFER_ERROR, exit_dcv);\n            }\n            ato16(input + args->idx, &args->sz);\n            args->idx += OPAQUE16_LEN;\n\n            /* Signature data. */\n            if ((args->idx - args->begin) + args->sz > totalSz ||\n                                                       args->sz > ENCRYPT_LEN) {\n                ERROR_OUT(BUFFER_ERROR, exit_dcv);\n            }\n\n            /* Check for public key of required type. */\n        #ifdef HAVE_ED25519\n            if (args->sigAlgo == ed25519_sa_algo &&\n                                                  !ssl->peerEd25519KeyPresent) {\n                WOLFSSL_MSG(\"Peer sent ED22519 sig but not ED22519 cert\");\n                ret = SIG_VERIFY_E;\n                goto exit_dcv;\n            }\n        #endif\n        #ifdef HAVE_ED448\n            if (args->sigAlgo == ed448_sa_algo && !ssl->peerEd448KeyPresent) {\n                WOLFSSL_MSG(\"Peer sent ED448 sig but not ED448 cert\");\n                ret = SIG_VERIFY_E;\n                goto exit_dcv;\n            }\n        #endif\n        #ifdef HAVE_ECC\n            if (args->sigAlgo == ecc_dsa_sa_algo &&\n                                                   !ssl->peerEccDsaKeyPresent) {\n                WOLFSSL_MSG(\"Peer sent ECC sig but not ECC cert\");\n                ret = SIG_VERIFY_E;\n                goto exit_dcv;\n            }\n        #endif\n        #ifndef NO_RSA\n            if (args->sigAlgo == rsa_sa_algo) {\n                WOLFSSL_MSG(\"Peer sent PKCS#1.5 algo but not in certificate\");\n                ERROR_OUT(INVALID_PARAMETER, exit_dcv);\n            }\n            if (args->sigAlgo == rsa_pss_sa_algo &&\n                         (ssl->peerRsaKey == NULL || !ssl->peerRsaKeyPresent)) {\n                WOLFSSL_MSG(\"Peer sent RSA sig but not RSA cert\");\n                ret = SIG_VERIFY_E;\n                goto exit_dcv;\n            }\n        #endif\n\n            sig->buffer = (byte*)XMALLOC(args->sz, ssl->heap,\n                                         DYNAMIC_TYPE_SIGNATURE);\n            if (sig->buffer == NULL) {\n                ERROR_OUT(MEMORY_E, exit_dcv);\n            }\n            sig->length = args->sz;\n            XMEMCPY(sig->buffer, input + args->idx, args->sz);\n\n        #ifdef HAVE_ECC\n            if (ssl->peerEccDsaKeyPresent) {\n                WOLFSSL_MSG(\"Doing ECC peer cert verify\");\n\n                args->sigData = (byte*)XMALLOC(MAX_SIG_DATA_SZ, ssl->heap,\n                                                        DYNAMIC_TYPE_SIGNATURE);\n                if (args->sigData == NULL) {\n                    ERROR_OUT(MEMORY_E, exit_dcv);\n                }\n\n                ret = CreateSigData(ssl, args->sigData, &args->sigDataSz, 1);\n                if (ret != 0)\n                    goto exit_dcv;\n                ret = CreateECCEncodedSig(args->sigData,\n                    args->sigDataSz, args->hashAlgo);\n                if (ret < 0)\n                    goto exit_dcv;\n                args->sigDataSz = (word16)ret;\n                ret = 0;\n            }\n        #endif\n        #ifdef HAVE_ED25519\n            if (ssl->peerEd25519KeyPresent) {\n                WOLFSSL_MSG(\"Doing ED25519 peer cert verify\");\n\n                args->sigData = (byte*)XMALLOC(MAX_SIG_DATA_SZ, ssl->heap,\n                                                        DYNAMIC_TYPE_SIGNATURE);\n                if (args->sigData == NULL) {\n                    ERROR_OUT(MEMORY_E, exit_dcv);\n                }\n\n                CreateSigData(ssl, args->sigData, &args->sigDataSz, 1);\n                ret = 0;\n            }\n        #endif\n        #ifdef HAVE_ED448\n            if (ssl->peerEd448KeyPresent) {\n                WOLFSSL_MSG(\"Doing ED448 peer cert verify\");\n\n                args->sigData = (byte*)XMALLOC(MAX_SIG_DATA_SZ, ssl->heap,\n                                                        DYNAMIC_TYPE_SIGNATURE);\n                if (args->sigData == NULL) {\n                    ERROR_OUT(MEMORY_E, exit_dcv);\n                }\n\n                CreateSigData(ssl, args->sigData, &args->sigDataSz, 1);\n                ret = 0;\n            }\n       #endif\n\n            /* Advance state and proceed */\n            ssl->options.asyncState = TLS_ASYNC_DO;\n        } /* case TLS_ASYNC_BUILD */\n        FALL_THROUGH;\n\n        case TLS_ASYNC_DO:\n        {\n        #ifndef NO_RSA\n            if (ssl->peerRsaKey != NULL && ssl->peerRsaKeyPresent != 0) {\n                WOLFSSL_MSG(\"Doing RSA peer cert verify\");\n\n                ret = RsaVerify(ssl, sig->buffer, (word32)sig->length, &args->output,\n                    args->sigAlgo, args->hashAlgo, ssl->peerRsaKey,\n                #ifdef HAVE_PK_CALLBACKS\n                    &ssl->buffers.peerRsaKey\n                #else\n                    NULL\n                #endif\n                );\n                if (ret >= 0) {\n                    args->sendSz = ret;\n                    ret = 0;\n                }\n            }\n        #endif /* !NO_RSA */\n        #ifdef HAVE_ECC\n            if (ssl->peerEccDsaKeyPresent) {\n                WOLFSSL_MSG(\"Doing ECC peer cert verify\");\n\n                ret = EccVerify(ssl, input + args->idx, args->sz,\n                    args->sigData, args->sigDataSz,\n                    ssl->peerEccDsaKey,\n                #ifdef HAVE_PK_CALLBACKS\n                    &ssl->buffers.peerEccDsaKey\n                #else\n                    NULL\n                #endif\n                );\n\n                if (ret >= 0) {\n                    FreeKey(ssl, DYNAMIC_TYPE_ECC, (void**)&ssl->peerEccDsaKey);\n                    ssl->peerEccDsaKeyPresent = 0;\n                }\n            }\n        #endif /* HAVE_ECC */\n        #ifdef HAVE_ED25519\n            if (ssl->peerEd25519KeyPresent) {\n                WOLFSSL_MSG(\"Doing ED25519 peer cert verify\");\n\n                ret = Ed25519Verify(ssl, input + args->idx, args->sz,\n                    args->sigData, args->sigDataSz,\n                    ssl->peerEd25519Key,\n                #ifdef HAVE_PK_CALLBACKS\n                    &ssl->buffers.peerEd25519Key\n                #else\n                    NULL\n                #endif\n                );\n\n                if (ret >= 0) {\n                    FreeKey(ssl, DYNAMIC_TYPE_ED25519,\n                                                  (void**)&ssl->peerEd25519Key);\n                    ssl->peerEd25519KeyPresent = 0;\n                }\n            }\n        #endif\n        #ifdef HAVE_ED448\n            if (ssl->peerEd448KeyPresent) {\n                WOLFSSL_MSG(\"Doing ED448 peer cert verify\");\n\n                ret = Ed448Verify(ssl, input + args->idx, args->sz,\n                    args->sigData, args->sigDataSz,\n                    ssl->peerEd448Key,\n                #ifdef HAVE_PK_CALLBACKS\n                    &ssl->buffers.peerEd448Key\n                #else\n                    NULL\n                #endif\n                );\n\n                if (ret >= 0) {\n                    FreeKey(ssl, DYNAMIC_TYPE_ED448,\n                                                    (void**)&ssl->peerEd448Key);\n                    ssl->peerEd448KeyPresent = 0;\n                }\n            }\n        #endif\n\n            /* Check for error */\n            if (ret != 0) {\n                goto exit_dcv;\n            }\n\n            /* Advance state and proceed */\n            ssl->options.asyncState = TLS_ASYNC_VERIFY;\n        } /* case TLS_ASYNC_DO */\n        FALL_THROUGH;\n\n        case TLS_ASYNC_VERIFY:\n        {\n        #if !defined(NO_RSA) && defined(WC_RSA_PSS)\n            if (ssl->peerRsaKey != NULL && ssl->peerRsaKeyPresent != 0) {\n                ret = CheckRSASignature(ssl, args->sigAlgo, args->hashAlgo,\n                                        args->output, args->sendSz);\n                if (ret != 0)\n                    goto exit_dcv;\n\n                FreeKey(ssl, DYNAMIC_TYPE_RSA, (void**)&ssl->peerRsaKey);\n                ssl->peerRsaKeyPresent = 0;\n            }\n        #endif /* !NO_RSA && WC_RSA_PSS */\n\n            /* Advance state and proceed */\n            ssl->options.asyncState = TLS_ASYNC_FINALIZE;\n        } /* case TLS_ASYNC_VERIFY */\n        FALL_THROUGH;\n\n        case TLS_ASYNC_FINALIZE:\n        {\n            ssl->options.havePeerVerify = 1;\n\n            /* Set final index */\n            args->idx += args->sz;\n            *inOutIdx = args->idx;\n\n            /* Encryption is always on: add padding */\n            *inOutIdx += ssl->keys.padSz;\n\n            /* Advance state and proceed */\n            ssl->options.asyncState = TLS_ASYNC_END;\n\n        #if !defined(NO_WOLFSSL_CLIENT)\n            if (ssl->options.side == WOLFSSL_CLIENT_END)\n                ssl->options.serverState = SERVER_CERT_VERIFY_COMPLETE;\n        #endif\n        } /* case TLS_ASYNC_FINALIZE */\n\n        case TLS_ASYNC_END:\n        {\n            break;\n        }\n        default:\n            ret = INPUT_CASE_ERROR;\n    } /* switch(ssl->options.asyncState) */\n\nexit_dcv:\n\n    WOLFSSL_LEAVE(\"DoTls13CertificateVerify\", ret);\n    WOLFSSL_END(WC_FUNC_CERTIFICATE_VERIFY_DO);\n\n#ifdef WOLFSSL_ASYNC_CRYPT\n    /* Handle async operation */\n    if (ret == WC_PENDING_E) {\n        /* Mark message as not received so it can process again */\n        ssl->msgsReceived.got_certificate_verify = 0;\n\n        return ret;\n    }\n    else\n#endif /* WOLFSSL_ASYNC_CRYPT */\n    if (ret != 0 && ret != INVALID_PARAMETER)\n        SendAlert(ssl, alert_fatal, decrypt_error);\n\n    /* Final cleanup */\n    FreeDcv13Args(ssl, args);\n    FreeKeyExchange(ssl);\n\n    return ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -81,28 +81,36 @@\n         #ifdef HAVE_ED25519\n             if (args->sigAlgo == ed25519_sa_algo &&\n                                                   !ssl->peerEd25519KeyPresent) {\n-                WOLFSSL_MSG(\"Oops, peer sent ED25519 key but not in verify\");\n+                WOLFSSL_MSG(\"Peer sent ED22519 sig but not ED22519 cert\");\n+                ret = SIG_VERIFY_E;\n+                goto exit_dcv;\n             }\n         #endif\n         #ifdef HAVE_ED448\n             if (args->sigAlgo == ed448_sa_algo && !ssl->peerEd448KeyPresent) {\n-                WOLFSSL_MSG(\"Oops, peer sent ED448 key but not in verify\");\n+                WOLFSSL_MSG(\"Peer sent ED448 sig but not ED448 cert\");\n+                ret = SIG_VERIFY_E;\n+                goto exit_dcv;\n             }\n         #endif\n         #ifdef HAVE_ECC\n             if (args->sigAlgo == ecc_dsa_sa_algo &&\n                                                    !ssl->peerEccDsaKeyPresent) {\n-                WOLFSSL_MSG(\"Oops, peer sent ECC key but not in verify\");\n+                WOLFSSL_MSG(\"Peer sent ECC sig but not ECC cert\");\n+                ret = SIG_VERIFY_E;\n+                goto exit_dcv;\n             }\n         #endif\n         #ifndef NO_RSA\n             if (args->sigAlgo == rsa_sa_algo) {\n-                WOLFSSL_MSG(\"Oops, peer sent PKCS#1.5 signature\");\n+                WOLFSSL_MSG(\"Peer sent PKCS#1.5 algo but not in certificate\");\n                 ERROR_OUT(INVALID_PARAMETER, exit_dcv);\n             }\n             if (args->sigAlgo == rsa_pss_sa_algo &&\n                          (ssl->peerRsaKey == NULL || !ssl->peerRsaKeyPresent)) {\n-                WOLFSSL_MSG(\"Oops, peer sent RSA key but not in verify\");\n+                WOLFSSL_MSG(\"Peer sent RSA sig but not RSA cert\");\n+                ret = SIG_VERIFY_E;\n+                goto exit_dcv;\n             }\n         #endif\n ",
        "diff_line_info": {
            "deleted_lines": [
                "                WOLFSSL_MSG(\"Oops, peer sent ED25519 key but not in verify\");",
                "                WOLFSSL_MSG(\"Oops, peer sent ED448 key but not in verify\");",
                "                WOLFSSL_MSG(\"Oops, peer sent ECC key but not in verify\");",
                "                WOLFSSL_MSG(\"Oops, peer sent PKCS#1.5 signature\");",
                "                WOLFSSL_MSG(\"Oops, peer sent RSA key but not in verify\");"
            ],
            "added_lines": [
                "                WOLFSSL_MSG(\"Peer sent ED22519 sig but not ED22519 cert\");",
                "                ret = SIG_VERIFY_E;",
                "                goto exit_dcv;",
                "                WOLFSSL_MSG(\"Peer sent ED448 sig but not ED448 cert\");",
                "                ret = SIG_VERIFY_E;",
                "                goto exit_dcv;",
                "                WOLFSSL_MSG(\"Peer sent ECC sig but not ECC cert\");",
                "                ret = SIG_VERIFY_E;",
                "                goto exit_dcv;",
                "                WOLFSSL_MSG(\"Peer sent PKCS#1.5 algo but not in certificate\");",
                "                WOLFSSL_MSG(\"Peer sent RSA sig but not RSA cert\");",
                "                ret = SIG_VERIFY_E;",
                "                goto exit_dcv;"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-26911",
        "func_name": "canarymail/mailcore2/IMAPSession::connect",
        "description": "core/imap/MCIMAPSession.cpp in Canary Mail before 3.22 has Missing SSL Certificate Validation for IMAP in STARTTLS mode.",
        "git_url": "https://github.com/canarymail/mailcore2/commit/45acb4efbcaa57a20ac5127dc976538671fce018",
        "commit_title": "[Core] Check Start/TLS cert",
        "commit_text": "",
        "func_before": "void IMAPSession::connect(ErrorCode * pError)\n{\n    int r;\n    \n    setup();\n\n    MCLog(\"connect %s\", MCUTF8DESC(this));\n\n    MCAssert(mState == STATE_DISCONNECTED);\n\n    if (mHostname == NULL) {\n        * pError = ErrorInvalidAccount;\n        goto close;\n    }\n    \n    switch (mConnectionType) {\n        case ConnectionTypeStartTLS:\n        MCLog(\"STARTTLS connect\");\n        r = mailimap_socket_connect_voip(mImap, MCUTF8(mHostname), mPort, isVoIPEnabled());\n        if (hasError(r)) {\n            * pError = ErrorConnection;\n            goto close;\n        }\n\n        r = mailimap_socket_starttls(mImap);\n        if (hasError(r)) {\n            MCLog(\"no TLS %i\", r);\n            * pError = ErrorTLSNotAvailable;\n            goto close;\n        }\n        break;\n\n        case ConnectionTypeTLS:\n        r = mailimap_ssl_connect_voip(mImap, MCUTF8(mHostname), mPort, isVoIPEnabled());\n        MCLog(\"ssl connect %s %u %u\", MCUTF8(mHostname), mPort, r);\n        if (hasError(r)) {\n            MCLog(\"connect error %i\", r);\n            * pError = ErrorConnection;\n            goto close;\n        }\n            \n        mIsCertificateValid = checkCertificate();\n        if (isCheckCertificateEnabled() && !mIsCertificateValid) {\n            * pError = ErrorCertificate;\n            goto close;\n        }\n\n        break;\n\n        default:\n        MCLog(\"socket connect %s %u\", MCUTF8(mHostname), mPort);\n        r = mailimap_socket_connect_voip(mImap, MCUTF8(mHostname), mPort, isVoIPEnabled());\n        MCLog(\"socket connect %i\", r);\n        if (hasError(r)) {\n            MCLog(\"connect error %i\", r);\n            * pError = ErrorConnection;\n            goto close;\n        }\n        break;\n    }\n    \n    mailstream_low * low;\n    String * identifierString;\n    char * identifier;\n    \n    low = mailstream_get_low(mImap->imap_stream);\n    identifierString = String::stringWithUTF8Format(\"%s@%s:%u\", MCUTF8(mUsername), MCUTF8(mHostname), mPort);\n    identifier = strdup(identifierString->UTF8Characters());\n    mailstream_low_set_identifier(low, identifier);\n    \n    if (mImap->imap_response != NULL) {\n        MC_SAFE_REPLACE_RETAIN(String, mWelcomeString, String::stringWithUTF8Characters(mImap->imap_response));\n        mYahooServer = (mWelcomeString->locationOfString(MCSTR(\"yahoo.com\")) != -1);\n#ifdef LIBETPAN_HAS_MAILIMAP_163_WORKAROUND\n        if (mWelcomeString->locationOfString(MCSTR(\"Coremail System IMap Server Ready\")) != -1)\n            mailimap_set_163_workaround_enabled(mImap, 1);\n#endif\n        if (mWelcomeString->locationOfString(MCSTR(\"Courier-IMAP\")) != -1) {\n            LOCK();\n            mIdleEnabled = true;\n            UNLOCK();\n            mNamespaceEnabled = true;\n        }\n        mRamblerRuServer = (mHostname->locationOfString(MCSTR(\".rambler.ru\")) != -1);\n        mHermesServer = (mWelcomeString->locationOfString(MCSTR(\"Hermes\")) != -1);\n        mQipServer = (mWelcomeString->locationOfString(MCSTR(\"QIP IMAP server\")) != -1);\n    }\n    \n    mState = STATE_CONNECTED;\n    \n    if (isAutomaticConfigurationEnabled()) {\n        if (mCurrentCapabilities != NULL) {\n            applyCapabilities(mCurrentCapabilities);\n        } else {\n            IndexSet *capabilities = capability(pError);\n            if (* pError != ErrorNone) {\n                MCLog(\"capabilities failed\");\n                goto close;\n            } else {\n                MC_SAFE_REPLACE_RETAIN(IndexSet, mCurrentCapabilities, capabilities);\n                applyCapabilities(mCurrentCapabilities);\n            }\n        }\n    }\n    \n    * pError = ErrorNone;\n    MCLog(\"connect ok\");\n    return;\n    \nclose:\n    unsetup();\n}",
        "func": "void IMAPSession::connect(ErrorCode * pError)\n{\n    int r;\n    \n    setup();\n\n    MCLog(\"connect %s\", MCUTF8DESC(this));\n\n    MCAssert(mState == STATE_DISCONNECTED);\n\n    if (mHostname == NULL) {\n        * pError = ErrorInvalidAccount;\n        goto close;\n    }\n    \n    switch (mConnectionType) {\n        case ConnectionTypeStartTLS:\n        MCLog(\"STARTTLS connect\");\n        r = mailimap_socket_connect_voip(mImap, MCUTF8(mHostname), mPort, isVoIPEnabled());\n        if (hasError(r)) {\n            * pError = ErrorConnection;\n            goto close;\n        }\n\n        r = mailimap_socket_starttls(mImap);\n        if (hasError(r)) {\n            MCLog(\"no TLS %i\", r);\n            * pError = ErrorTLSNotAvailable;\n            goto close;\n        }\n            \n        mIsCertificateValid = checkCertificate();\n        if (isCheckCertificateEnabled() && !mIsCertificateValid) {\n            * pError = ErrorCertificate;\n            goto close;\n        }\n            \n        break;\n\n        case ConnectionTypeTLS:\n        r = mailimap_ssl_connect_voip(mImap, MCUTF8(mHostname), mPort, isVoIPEnabled());\n        MCLog(\"ssl connect %s %u %u\", MCUTF8(mHostname), mPort, r);\n        if (hasError(r)) {\n            MCLog(\"connect error %i\", r);\n            * pError = ErrorConnection;\n            goto close;\n        }\n            \n        mIsCertificateValid = checkCertificate();\n        if (isCheckCertificateEnabled() && !mIsCertificateValid) {\n            * pError = ErrorCertificate;\n            goto close;\n        }\n\n        break;\n\n        default:\n        MCLog(\"socket connect %s %u\", MCUTF8(mHostname), mPort);\n        r = mailimap_socket_connect_voip(mImap, MCUTF8(mHostname), mPort, isVoIPEnabled());\n        MCLog(\"socket connect %i\", r);\n        if (hasError(r)) {\n            MCLog(\"connect error %i\", r);\n            * pError = ErrorConnection;\n            goto close;\n        }\n        break;\n    }\n    \n    mailstream_low * low;\n    String * identifierString;\n    char * identifier;\n    \n    low = mailstream_get_low(mImap->imap_stream);\n    identifierString = String::stringWithUTF8Format(\"%s@%s:%u\", MCUTF8(mUsername), MCUTF8(mHostname), mPort);\n    identifier = strdup(identifierString->UTF8Characters());\n    mailstream_low_set_identifier(low, identifier);\n    \n    if (mImap->imap_response != NULL) {\n        MC_SAFE_REPLACE_RETAIN(String, mWelcomeString, String::stringWithUTF8Characters(mImap->imap_response));\n        mYahooServer = (mWelcomeString->locationOfString(MCSTR(\"yahoo.com\")) != -1);\n#ifdef LIBETPAN_HAS_MAILIMAP_163_WORKAROUND\n        if (mWelcomeString->locationOfString(MCSTR(\"Coremail System IMap Server Ready\")) != -1)\n            mailimap_set_163_workaround_enabled(mImap, 1);\n#endif\n        if (mWelcomeString->locationOfString(MCSTR(\"Courier-IMAP\")) != -1) {\n            LOCK();\n            mIdleEnabled = true;\n            UNLOCK();\n            mNamespaceEnabled = true;\n        }\n        mRamblerRuServer = (mHostname->locationOfString(MCSTR(\".rambler.ru\")) != -1);\n        mHermesServer = (mWelcomeString->locationOfString(MCSTR(\"Hermes\")) != -1);\n        mQipServer = (mWelcomeString->locationOfString(MCSTR(\"QIP IMAP server\")) != -1);\n    }\n    \n    mState = STATE_CONNECTED;\n    \n    if (isAutomaticConfigurationEnabled()) {\n        if (mCurrentCapabilities != NULL) {\n            applyCapabilities(mCurrentCapabilities);\n        } else {\n            IndexSet *capabilities = capability(pError);\n            if (* pError != ErrorNone) {\n                MCLog(\"capabilities failed\");\n                goto close;\n            } else {\n                MC_SAFE_REPLACE_RETAIN(IndexSet, mCurrentCapabilities, capabilities);\n                applyCapabilities(mCurrentCapabilities);\n            }\n        }\n    }\n    \n    * pError = ErrorNone;\n    MCLog(\"connect ok\");\n    return;\n    \nclose:\n    unsetup();\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -28,6 +28,13 @@\n             * pError = ErrorTLSNotAvailable;\n             goto close;\n         }\n+            \n+        mIsCertificateValid = checkCertificate();\n+        if (isCheckCertificateEnabled() && !mIsCertificateValid) {\n+            * pError = ErrorCertificate;\n+            goto close;\n+        }\n+            \n         break;\n \n         case ConnectionTypeTLS:",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "            ",
                "        mIsCertificateValid = checkCertificate();",
                "        if (isCheckCertificateEnabled() && !mIsCertificateValid) {",
                "            * pError = ErrorCertificate;",
                "            goto close;",
                "        }",
                "            "
            ]
        }
    },
    {
        "cve_id": "CVE-2020-15260",
        "func_name": "pjsip/pjproject/dlg_create_request_throw",
        "description": "PJSIP is a free and open source multimedia communication library written in C language implementing standard based protocols such as SIP, SDP, RTP, STUN, TURN, and ICE. In version 2.10 and earlier, PJSIP transport can be reused if they have the same IP address + port + protocol. However, this is insufficient for secure transport since it lacks remote hostname authentication. Suppose we have created a TLS connection to `sip.foo.com`, which has an IP address `100.1.1.1`. If we want to create a TLS connection to another hostname, say `sip.bar.com`, which has the same IP address, then it will reuse that existing connection, even though `100.1.1.1` does not have certificate to authenticate as `sip.bar.com`. The vulnerability allows for an insecure interaction without user awareness. It affects users who need access to connections to different destinations that translate to the same address, and allows man-in-the-middle attack if attacker can route a connection to another destination such as in the case of DNS spoofing.",
        "git_url": "https://github.com/pjsip/pjproject/commit/67e46c1ac45ad784db5b9080f5ed8b133c122872",
        "commit_title": "Merge pull request from GHSA-8hcp-hm38-mfph",
        "commit_text": " * Check hostname during TLS transport selection  * revision based on feedback  * remove the code in create_request that has been moved",
        "func_before": "static pj_status_t dlg_create_request_throw( pjsip_dialog *dlg,\n\t\t\t\t\t     const pjsip_method *method,\n\t\t\t\t\t     int cseq,\n\t\t\t\t\t     pjsip_tx_data **p_tdata )\n{\n    pjsip_tx_data *tdata;\n    pjsip_contact_hdr *contact;\n    pjsip_route_hdr *route, *end_list;\n    pj_status_t status;\n\n    /* Contact Header field.\n     * Contact can only be present in requests that establish dialog (in the\n     * core SIP spec, only INVITE).\n     */\n    if (pjsip_method_creates_dialog(method))\n\tcontact = dlg->local.contact;\n    else\n\tcontact = NULL;\n\n    /*\n     * Create the request by cloning from the headers in the\n     * dialog.\n     */\n    status = pjsip_endpt_create_request_from_hdr(dlg->endpt,\n\t\t\t\t\t\t method,\n\t\t\t\t\t\t dlg->target,\n\t\t\t\t\t\t dlg->local.info,\n\t\t\t\t\t\t dlg->remote.info,\n\t\t\t\t\t\t contact,\n\t\t\t\t\t\t dlg->call_id,\n\t\t\t\t\t\t cseq,\n\t\t\t\t\t\t NULL,\n\t\t\t\t\t\t &tdata);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    /* Put this dialog in tdata's mod_data */\n    tdata->mod_data[dlg->ua->id] = dlg;\n\n    /* Just copy dialog route-set to Route header.\n     * The transaction will do the processing as specified in Section 12.2.1\n     * of RFC 3261 in function tsx_process_route() in sip_transaction.c.\n     */\n    route = dlg->route_set.next;\n    end_list = &dlg->route_set;\n    for (; route != end_list; route = route->next ) {\n\tpjsip_route_hdr *r;\n\tr = (pjsip_route_hdr*) pjsip_hdr_shallow_clone( tdata->pool, route );\n\tpjsip_routing_hdr_set_route(r);\n\tpjsip_msg_add_hdr(tdata->msg, (pjsip_hdr*)r);\n    }\n\n    /* Copy authorization headers, if request is not ACK or CANCEL. */\n    if (method->id != PJSIP_ACK_METHOD && method->id != PJSIP_CANCEL_METHOD) {\n\tstatus = pjsip_auth_clt_init_req( &dlg->auth_sess, tdata );\n\tif (status != PJ_SUCCESS)\n\t    return status;\n    }\n\n    /* Done. */\n    *p_tdata = tdata;\n\n    return PJ_SUCCESS;\n}",
        "func": "static pj_status_t dlg_create_request_throw( pjsip_dialog *dlg,\n\t\t\t\t\t     const pjsip_method *method,\n\t\t\t\t\t     int cseq,\n\t\t\t\t\t     pjsip_tx_data **p_tdata )\n{\n    pjsip_tx_data *tdata;\n    pjsip_contact_hdr *contact;\n    pjsip_route_hdr *route, *end_list;\n    pj_status_t status;\n\n    /* Contact Header field.\n     * Contact can only be present in requests that establish dialog (in the\n     * core SIP spec, only INVITE).\n     */\n    if (pjsip_method_creates_dialog(method))\n\tcontact = dlg->local.contact;\n    else\n\tcontact = NULL;\n\n    /*\n     * Create the request by cloning from the headers in the\n     * dialog.\n     */\n    status = pjsip_endpt_create_request_from_hdr(dlg->endpt,\n\t\t\t\t\t\t method,\n\t\t\t\t\t\t dlg->target,\n\t\t\t\t\t\t dlg->local.info,\n\t\t\t\t\t\t dlg->remote.info,\n\t\t\t\t\t\t contact,\n\t\t\t\t\t\t dlg->call_id,\n\t\t\t\t\t\t cseq,\n\t\t\t\t\t\t NULL,\n\t\t\t\t\t\t &tdata);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    /* Put this dialog in tdata's mod_data */\n    tdata->mod_data[dlg->ua->id] = dlg;\n\n    /* Just copy dialog route-set to Route header.\n     * The transaction will do the processing as specified in Section 12.2.1\n     * of RFC 3261 in function tsx_process_route() in sip_transaction.c.\n     */\n    route = dlg->route_set.next;\n    end_list = &dlg->route_set;\n    for (; route != end_list; route = route->next ) {\n\tpjsip_route_hdr *r;\n\tr = (pjsip_route_hdr*) pjsip_hdr_shallow_clone( tdata->pool, route );\n\tpjsip_routing_hdr_set_route(r);\n\tpjsip_msg_add_hdr(tdata->msg, (pjsip_hdr*)r);\n    }\n\n    /* Copy authorization headers, if request is not ACK or CANCEL. */\n    if (method->id != PJSIP_ACK_METHOD && method->id != PJSIP_CANCEL_METHOD) {\n\tstatus = pjsip_auth_clt_init_req( &dlg->auth_sess, tdata );\n\tif (status != PJ_SUCCESS)\n\t    return status;\n    }\n\n    /* Copy the initial destination host to tdata. This information can be\n     * used later by transport for transport selection.\n     */\n    if (dlg->initial_dest.slen)\n    \tpj_strdup(tdata->pool, &tdata->dest_info.name, &dlg->initial_dest);\n\n    /* Done. */\n    *p_tdata = tdata;\n\n    return PJ_SUCCESS;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -57,6 +57,12 @@\n \t    return status;\n     }\n \n+    /* Copy the initial destination host to tdata. This information can be\n+     * used later by transport for transport selection.\n+     */\n+    if (dlg->initial_dest.slen)\n+    \tpj_strdup(tdata->pool, &tdata->dest_info.name, &dlg->initial_dest);\n+\n     /* Done. */\n     *p_tdata = tdata;\n ",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    /* Copy the initial destination host to tdata. This information can be",
                "     * used later by transport for transport selection.",
                "     */",
                "    if (dlg->initial_dest.slen)",
                "    \tpj_strdup(tdata->pool, &tdata->dest_info.name, &dlg->initial_dest);",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2020-15260",
        "func_name": "pjsip/pjproject/create_uas_dialog",
        "description": "PJSIP is a free and open source multimedia communication library written in C language implementing standard based protocols such as SIP, SDP, RTP, STUN, TURN, and ICE. In version 2.10 and earlier, PJSIP transport can be reused if they have the same IP address + port + protocol. However, this is insufficient for secure transport since it lacks remote hostname authentication. Suppose we have created a TLS connection to `sip.foo.com`, which has an IP address `100.1.1.1`. If we want to create a TLS connection to another hostname, say `sip.bar.com`, which has the same IP address, then it will reuse that existing connection, even though `100.1.1.1` does not have certificate to authenticate as `sip.bar.com`. The vulnerability allows for an insecure interaction without user awareness. It affects users who need access to connections to different destinations that translate to the same address, and allows man-in-the-middle attack if attacker can route a connection to another destination such as in the case of DNS spoofing.",
        "git_url": "https://github.com/pjsip/pjproject/commit/67e46c1ac45ad784db5b9080f5ed8b133c122872",
        "commit_title": "Merge pull request from GHSA-8hcp-hm38-mfph",
        "commit_text": " * Check hostname during TLS transport selection  * revision based on feedback  * remove the code in create_request that has been moved",
        "func_before": "pj_status_t create_uas_dialog( pjsip_user_agent *ua,\n\t\t\t       pjsip_rx_data *rdata,\n\t\t\t       const pj_str_t *contact,\n\t\t\t       pj_bool_t inc_lock,\n\t\t\t       pjsip_dialog **p_dlg)\n{\n    pj_status_t status;\n    pjsip_hdr *pos = NULL;\n    pjsip_contact_hdr *contact_hdr;\n    pjsip_rr_hdr *rr;\n    pjsip_transaction *tsx = NULL;\n    pj_str_t tmp;\n    enum { TMP_LEN=PJSIP_MAX_URL_SIZE };\n    pj_ssize_t len;\n    pjsip_dialog *dlg;\n    pj_bool_t lock_incremented = PJ_FALSE;\n\n    /* Check arguments. */\n    PJ_ASSERT_RETURN(ua && rdata && p_dlg, PJ_EINVAL);\n\n    /* rdata must have request message. */\n    PJ_ASSERT_RETURN(rdata->msg_info.msg->type == PJSIP_REQUEST_MSG,\n\t\t     PJSIP_ENOTREQUESTMSG);\n\n    /* Request must not have To tag.\n     * This should have been checked in the user agent (or application?).\n     */\n    PJ_ASSERT_RETURN(rdata->msg_info.to->tag.slen == 0, PJ_EINVALIDOP);\n\n    /* The request must be a dialog establishing request. */\n    PJ_ASSERT_RETURN(\n\tpjsip_method_creates_dialog(&rdata->msg_info.msg->line.req.method),\n\tPJ_EINVALIDOP);\n\n    /* Create dialog instance. */\n    status = create_dialog(ua, NULL, &dlg);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    /* Temprary string for getting the string representation of\n     * both local and remote URI.\n     */\n    tmp.ptr = (char*) pj_pool_alloc(rdata->tp_info.pool, TMP_LEN);\n\n    /* Init local info from the To header. */\n    dlg->local.info = (pjsip_fromto_hdr*)\n    \t\t      pjsip_hdr_clone(dlg->pool, rdata->msg_info.to);\n    pjsip_fromto_hdr_set_from(dlg->local.info);\n\n    /* Generate local tag. */\n    pj_create_unique_string(dlg->pool, &dlg->local.info->tag);\n\n\n    /* Print the local info. */\n    len = pjsip_uri_print(PJSIP_URI_IN_FROMTO_HDR,\n\t\t\t  dlg->local.info->uri, tmp.ptr, TMP_LEN);\n    if (len < 1) {\n\tpj_ansi_strcpy(tmp.ptr, \"<-error: uri too long->\");\n\ttmp.slen = pj_ansi_strlen(tmp.ptr);\n    } else\n\ttmp.slen = len;\n\n    /* Save the local info. */\n    pj_strdup(dlg->pool, &dlg->local.info_str, &tmp);\n\n    /* Calculate hash value of local tag. */\n    dlg->local.tag_hval = pj_hash_calc_tolower(0, NULL, &dlg->local.info->tag);\n\n\n    /* Randomize local cseq */\n    dlg->local.first_cseq = pj_rand() & 0x7FFF;\n    dlg->local.cseq = dlg->local.first_cseq;\n\n    /* Init local contact. */\n    /* TODO:\n     *  Section 12.1.1, paragraph about using SIPS URI in Contact.\n     *  If the request that initiated the dialog contained a SIPS URI\n     *  in the Request-URI or in the top Record-Route header field value,\n     *  if there was any, or the Contact header field if there was no\n     *  Record-Route header field, the Contact header field in the response\n     *  MUST be a SIPS URI.\n     */\n    if (contact) {\n\tpj_str_t tmp2;\n\n\tpj_strdup_with_null(dlg->pool, &tmp2, contact);\n\tdlg->local.contact = (pjsip_contact_hdr*)\n\t\t\t     pjsip_parse_hdr(dlg->pool, &HCONTACT, tmp2.ptr,\n\t\t\t\t\t     tmp2.slen, NULL);\n\tif (!dlg->local.contact) {\n\t    status = PJSIP_EINVALIDURI;\n\t    goto on_error;\n\t}\n\n    } else {\n\tdlg->local.contact = pjsip_contact_hdr_create(dlg->pool);\n\tdlg->local.contact->uri = dlg->local.info->uri;\n    }\n\n    /* Init remote info from the From header. */\n    dlg->remote.info = (pjsip_fromto_hdr*)\n    \t\t       pjsip_hdr_clone(dlg->pool, rdata->msg_info.from);\n    pjsip_fromto_hdr_set_to(dlg->remote.info);\n\n    /* Print the remote info. */\n    len = pjsip_uri_print(PJSIP_URI_IN_FROMTO_HDR,\n\t\t\t  dlg->remote.info->uri, tmp.ptr, TMP_LEN);\n    if (len < 1) {\n\tpj_ansi_strcpy(tmp.ptr, \"<-error: uri too long->\");\n\ttmp.slen = pj_ansi_strlen(tmp.ptr);\n    } else\n\ttmp.slen = len;\n\n    /* Save the remote info. */\n    pj_strdup(dlg->pool, &dlg->remote.info_str, &tmp);\n\n\n    /* Init remote's contact from Contact header.\n     * Iterate the Contact URI until we find sip: or sips: scheme.\n     */\n    do {\n\tcontact_hdr = (pjsip_contact_hdr*)\n\t\t      pjsip_msg_find_hdr(rdata->msg_info.msg, PJSIP_H_CONTACT,\n\t\t\t\t         pos);\n\tif (contact_hdr) {\n\t    if (!contact_hdr->uri ||\n\t\t(!PJSIP_URI_SCHEME_IS_SIP(contact_hdr->uri) &&\n\t\t !PJSIP_URI_SCHEME_IS_SIPS(contact_hdr->uri)))\n\t    {\n\t\tpos = (pjsip_hdr*)contact_hdr->next;\n\t\tif (pos == &rdata->msg_info.msg->hdr)\n\t\t    contact_hdr = NULL;\n\t    } else {\n\t\tbreak;\n\t    }\n\t}\n    } while (contact_hdr);\n\n    if (!contact_hdr) {\n\tstatus = PJSIP_ERRNO_FROM_SIP_STATUS(PJSIP_SC_BAD_REQUEST);\n\tgoto on_error;\n    }\n\n    dlg->remote.contact = (pjsip_contact_hdr*)\n    \t\t\t  pjsip_hdr_clone(dlg->pool, (pjsip_hdr*)contact_hdr);\n\n    /* Init remote's CSeq from CSeq header */\n    dlg->remote.cseq = dlg->remote.first_cseq = rdata->msg_info.cseq->cseq;\n\n    /* Set initial target to remote's Contact. */\n    dlg->target = dlg->remote.contact->uri;\n\n    /* Initial role is UAS */\n    dlg->role = PJSIP_ROLE_UAS;\n\n    /* Secure?\n     *  RFC 3261 Section 12.1.1:\n     *  If the request arrived over TLS, and the Request-URI contained a\n     *  SIPS URI, the 'secure' flag is set to TRUE.\n     */\n    dlg->secure = PJSIP_TRANSPORT_IS_SECURE(rdata->tp_info.transport) &&\n\t\t  PJSIP_URI_SCHEME_IS_SIPS(rdata->msg_info.msg->line.req.uri);\n\n    /* Call-ID */\n    dlg->call_id = (pjsip_cid_hdr*)\n    \t\t   pjsip_hdr_clone(dlg->pool, rdata->msg_info.cid);\n\n    /* Route set.\n     *  RFC 3261 Section 12.1.1:\n     *  The route set MUST be set to the list of URIs in the Record-Route\n     *  header field from the request, taken in order and preserving all URI\n     *  parameters. If no Record-Route header field is present in the request,\n     * the route set MUST be set to the empty set.\n     */\n    pj_list_init(&dlg->route_set);\n    rr = rdata->msg_info.record_route;\n    while (rr != NULL) {\n\tpjsip_route_hdr *route;\n\n\t/* Clone the Record-Route, change the type to Route header. */\n\troute = (pjsip_route_hdr*) pjsip_hdr_clone(dlg->pool, rr);\n\tpjsip_routing_hdr_set_route(route);\n\n\t/* Add to route set. */\n\tpj_list_push_back(&dlg->route_set, route);\n\n\t/* Find next Record-Route header. */\n\trr = rr->next;\n\tif (rr == (void*)&rdata->msg_info.msg->hdr)\n\t    break;\n\trr = (pjsip_route_hdr*) pjsip_msg_find_hdr(rdata->msg_info.msg,\n\t\t\t\t\t\t   PJSIP_H_RECORD_ROUTE, rr);\n    }\n    dlg->route_set_frozen = PJ_TRUE;\n\n    /* Increment the dialog's lock since tsx may cause the dialog to be\n     * destroyed prematurely (such as in case of transport error).\n     */\n    if (inc_lock) {\n        pjsip_dlg_inc_lock(dlg);\n        lock_incremented = PJ_TRUE;\n    }\n\n    /* Create UAS transaction for this request. */\n    status = pjsip_tsx_create_uas(dlg->ua, rdata, &tsx);\n    if (status != PJ_SUCCESS)\n\tgoto on_error;\n\n    /* Associate this dialog to the transaction. */\n    tsx->mod_data[dlg->ua->id] = dlg;\n\n    /* Increment tsx counter */\n    ++dlg->tsx_count;\n\n    /* Calculate hash value of remote tag. */\n    dlg->remote.tag_hval = pj_hash_calc_tolower(0, NULL, &dlg->remote.info->tag);\n\n    /* Update remote capabilities info */\n    pjsip_dlg_update_remote_cap(dlg, rdata->msg_info.msg, PJ_TRUE);\n\n    /* Register this dialog to user agent. */\n    status = pjsip_ua_register_dlg( ua, dlg );\n    if (status != PJ_SUCCESS)\n\tgoto on_error;\n\n    /* Put this dialog in rdata's mod_data */\n    rdata->endpt_info.mod_data[ua->id] = dlg;\n\n    PJ_TODO(DIALOG_APP_TIMER);\n\n    /* Feed the first request to the transaction. */\n    pjsip_tsx_recv_msg(tsx, rdata);\n\n    /* Done. */\n    *p_dlg = dlg;\n    PJ_LOG(5,(dlg->obj_name, \"UAS dialog created\"));\n    return PJ_SUCCESS;\n\non_error:\n    if (tsx) {\n\tpjsip_tsx_terminate(tsx, 500);\n\tpj_assert(dlg->tsx_count>0);\n\t--dlg->tsx_count;\n    }\n\n    if (lock_incremented) {\n        pjsip_dlg_dec_lock(dlg);\n    } else {\n        destroy_dialog(dlg, PJ_FALSE);\n    }\n\n    return status;\n}",
        "func": "pj_status_t create_uas_dialog( pjsip_user_agent *ua,\n\t\t\t       pjsip_rx_data *rdata,\n\t\t\t       const pj_str_t *contact,\n\t\t\t       pj_bool_t inc_lock,\n\t\t\t       pjsip_dialog **p_dlg)\n{\n    pj_status_t status;\n    pjsip_hdr *pos = NULL;\n    pjsip_contact_hdr *contact_hdr;\n    pjsip_rr_hdr *rr;\n    pjsip_transaction *tsx = NULL;\n    pj_str_t tmp;\n    enum { TMP_LEN=PJSIP_MAX_URL_SIZE };\n    pj_ssize_t len;\n    pjsip_dialog *dlg;\n    pj_bool_t lock_incremented = PJ_FALSE;\n\n    /* Check arguments. */\n    PJ_ASSERT_RETURN(ua && rdata && p_dlg, PJ_EINVAL);\n\n    /* rdata must have request message. */\n    PJ_ASSERT_RETURN(rdata->msg_info.msg->type == PJSIP_REQUEST_MSG,\n\t\t     PJSIP_ENOTREQUESTMSG);\n\n    /* Request must not have To tag.\n     * This should have been checked in the user agent (or application?).\n     */\n    PJ_ASSERT_RETURN(rdata->msg_info.to->tag.slen == 0, PJ_EINVALIDOP);\n\n    /* The request must be a dialog establishing request. */\n    PJ_ASSERT_RETURN(\n\tpjsip_method_creates_dialog(&rdata->msg_info.msg->line.req.method),\n\tPJ_EINVALIDOP);\n\n    /* Create dialog instance. */\n    status = create_dialog(ua, NULL, &dlg);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    /* Temprary string for getting the string representation of\n     * both local and remote URI.\n     */\n    tmp.ptr = (char*) pj_pool_alloc(rdata->tp_info.pool, TMP_LEN);\n\n    /* Init local info from the To header. */\n    dlg->local.info = (pjsip_fromto_hdr*)\n    \t\t      pjsip_hdr_clone(dlg->pool, rdata->msg_info.to);\n    pjsip_fromto_hdr_set_from(dlg->local.info);\n\n    /* Generate local tag. */\n    pj_create_unique_string(dlg->pool, &dlg->local.info->tag);\n\n\n    /* Print the local info. */\n    len = pjsip_uri_print(PJSIP_URI_IN_FROMTO_HDR,\n\t\t\t  dlg->local.info->uri, tmp.ptr, TMP_LEN);\n    if (len < 1) {\n\tpj_ansi_strcpy(tmp.ptr, \"<-error: uri too long->\");\n\ttmp.slen = pj_ansi_strlen(tmp.ptr);\n    } else\n\ttmp.slen = len;\n\n    /* Save the local info. */\n    pj_strdup(dlg->pool, &dlg->local.info_str, &tmp);\n\n    /* Calculate hash value of local tag. */\n    dlg->local.tag_hval = pj_hash_calc_tolower(0, NULL, &dlg->local.info->tag);\n\n\n    /* Randomize local cseq */\n    dlg->local.first_cseq = pj_rand() & 0x7FFF;\n    dlg->local.cseq = dlg->local.first_cseq;\n\n    /* Init local contact. */\n    /* TODO:\n     *  Section 12.1.1, paragraph about using SIPS URI in Contact.\n     *  If the request that initiated the dialog contained a SIPS URI\n     *  in the Request-URI or in the top Record-Route header field value,\n     *  if there was any, or the Contact header field if there was no\n     *  Record-Route header field, the Contact header field in the response\n     *  MUST be a SIPS URI.\n     */\n    if (contact) {\n\tpj_str_t tmp2;\n\n\tpj_strdup_with_null(dlg->pool, &tmp2, contact);\n\tdlg->local.contact = (pjsip_contact_hdr*)\n\t\t\t     pjsip_parse_hdr(dlg->pool, &HCONTACT, tmp2.ptr,\n\t\t\t\t\t     tmp2.slen, NULL);\n\tif (!dlg->local.contact) {\n\t    status = PJSIP_EINVALIDURI;\n\t    goto on_error;\n\t}\n\n    } else {\n\tdlg->local.contact = pjsip_contact_hdr_create(dlg->pool);\n\tdlg->local.contact->uri = dlg->local.info->uri;\n    }\n\n    /* Init remote info from the From header. */\n    dlg->remote.info = (pjsip_fromto_hdr*)\n    \t\t       pjsip_hdr_clone(dlg->pool, rdata->msg_info.from);\n    pjsip_fromto_hdr_set_to(dlg->remote.info);\n\n    /* Print the remote info. */\n    len = pjsip_uri_print(PJSIP_URI_IN_FROMTO_HDR,\n\t\t\t  dlg->remote.info->uri, tmp.ptr, TMP_LEN);\n    if (len < 1) {\n\tpj_ansi_strcpy(tmp.ptr, \"<-error: uri too long->\");\n\ttmp.slen = pj_ansi_strlen(tmp.ptr);\n    } else\n\ttmp.slen = len;\n\n    /* Save the remote info. */\n    pj_strdup(dlg->pool, &dlg->remote.info_str, &tmp);\n    \n    /* Save initial destination host from transport's info */\n    pj_strdup(dlg->pool, &dlg->initial_dest,\n    \t      &rdata->tp_info.transport->remote_name.host);\n\n\n    /* Init remote's contact from Contact header.\n     * Iterate the Contact URI until we find sip: or sips: scheme.\n     */\n    do {\n\tcontact_hdr = (pjsip_contact_hdr*)\n\t\t      pjsip_msg_find_hdr(rdata->msg_info.msg, PJSIP_H_CONTACT,\n\t\t\t\t         pos);\n\tif (contact_hdr) {\n\t    if (!contact_hdr->uri ||\n\t\t(!PJSIP_URI_SCHEME_IS_SIP(contact_hdr->uri) &&\n\t\t !PJSIP_URI_SCHEME_IS_SIPS(contact_hdr->uri)))\n\t    {\n\t\tpos = (pjsip_hdr*)contact_hdr->next;\n\t\tif (pos == &rdata->msg_info.msg->hdr)\n\t\t    contact_hdr = NULL;\n\t    } else {\n\t\tbreak;\n\t    }\n\t}\n    } while (contact_hdr);\n\n    if (!contact_hdr) {\n\tstatus = PJSIP_ERRNO_FROM_SIP_STATUS(PJSIP_SC_BAD_REQUEST);\n\tgoto on_error;\n    }\n\n    dlg->remote.contact = (pjsip_contact_hdr*)\n    \t\t\t  pjsip_hdr_clone(dlg->pool, (pjsip_hdr*)contact_hdr);\n\n    /* Init remote's CSeq from CSeq header */\n    dlg->remote.cseq = dlg->remote.first_cseq = rdata->msg_info.cseq->cseq;\n\n    /* Set initial target to remote's Contact. */\n    dlg->target = dlg->remote.contact->uri;\n\n    /* Initial role is UAS */\n    dlg->role = PJSIP_ROLE_UAS;\n\n    /* Secure?\n     *  RFC 3261 Section 12.1.1:\n     *  If the request arrived over TLS, and the Request-URI contained a\n     *  SIPS URI, the 'secure' flag is set to TRUE.\n     */\n    dlg->secure = PJSIP_TRANSPORT_IS_SECURE(rdata->tp_info.transport) &&\n\t\t  PJSIP_URI_SCHEME_IS_SIPS(rdata->msg_info.msg->line.req.uri);\n\n    /* Call-ID */\n    dlg->call_id = (pjsip_cid_hdr*)\n    \t\t   pjsip_hdr_clone(dlg->pool, rdata->msg_info.cid);\n\n    /* Route set.\n     *  RFC 3261 Section 12.1.1:\n     *  The route set MUST be set to the list of URIs in the Record-Route\n     *  header field from the request, taken in order and preserving all URI\n     *  parameters. If no Record-Route header field is present in the request,\n     * the route set MUST be set to the empty set.\n     */\n    pj_list_init(&dlg->route_set);\n    rr = rdata->msg_info.record_route;\n    while (rr != NULL) {\n\tpjsip_route_hdr *route;\n\n\t/* Clone the Record-Route, change the type to Route header. */\n\troute = (pjsip_route_hdr*) pjsip_hdr_clone(dlg->pool, rr);\n\tpjsip_routing_hdr_set_route(route);\n\n\t/* Add to route set. */\n\tpj_list_push_back(&dlg->route_set, route);\n\n\t/* Find next Record-Route header. */\n\trr = rr->next;\n\tif (rr == (void*)&rdata->msg_info.msg->hdr)\n\t    break;\n\trr = (pjsip_route_hdr*) pjsip_msg_find_hdr(rdata->msg_info.msg,\n\t\t\t\t\t\t   PJSIP_H_RECORD_ROUTE, rr);\n    }\n    dlg->route_set_frozen = PJ_TRUE;\n\n    /* Increment the dialog's lock since tsx may cause the dialog to be\n     * destroyed prematurely (such as in case of transport error).\n     */\n    if (inc_lock) {\n        pjsip_dlg_inc_lock(dlg);\n        lock_incremented = PJ_TRUE;\n    }\n\n    /* Create UAS transaction for this request. */\n    status = pjsip_tsx_create_uas(dlg->ua, rdata, &tsx);\n    if (status != PJ_SUCCESS)\n\tgoto on_error;\n\n    /* Associate this dialog to the transaction. */\n    tsx->mod_data[dlg->ua->id] = dlg;\n\n    /* Increment tsx counter */\n    ++dlg->tsx_count;\n\n    /* Calculate hash value of remote tag. */\n    dlg->remote.tag_hval = pj_hash_calc_tolower(0, NULL, &dlg->remote.info->tag);\n\n    /* Update remote capabilities info */\n    pjsip_dlg_update_remote_cap(dlg, rdata->msg_info.msg, PJ_TRUE);\n\n    /* Register this dialog to user agent. */\n    status = pjsip_ua_register_dlg( ua, dlg );\n    if (status != PJ_SUCCESS)\n\tgoto on_error;\n\n    /* Put this dialog in rdata's mod_data */\n    rdata->endpt_info.mod_data[ua->id] = dlg;\n\n    PJ_TODO(DIALOG_APP_TIMER);\n\n    /* Feed the first request to the transaction. */\n    pjsip_tsx_recv_msg(tsx, rdata);\n\n    /* Done. */\n    *p_dlg = dlg;\n    PJ_LOG(5,(dlg->obj_name, \"UAS dialog created\"));\n    return PJ_SUCCESS;\n\non_error:\n    if (tsx) {\n\tpjsip_tsx_terminate(tsx, 500);\n\tpj_assert(dlg->tsx_count>0);\n\t--dlg->tsx_count;\n    }\n\n    if (lock_incremented) {\n        pjsip_dlg_dec_lock(dlg);\n    } else {\n        destroy_dialog(dlg, PJ_FALSE);\n    }\n\n    return status;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -113,6 +113,10 @@\n \n     /* Save the remote info. */\n     pj_strdup(dlg->pool, &dlg->remote.info_str, &tmp);\n+    \n+    /* Save initial destination host from transport's info */\n+    pj_strdup(dlg->pool, &dlg->initial_dest,\n+    \t      &rdata->tp_info.transport->remote_name.host);\n \n \n     /* Init remote's contact from Contact header.",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    ",
                "    /* Save initial destination host from transport's info */",
                "    pj_strdup(dlg->pool, &dlg->initial_dest,",
                "    \t      &rdata->tp_info.transport->remote_name.host);"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-15260",
        "func_name": "pjsip/pjproject/dlg_update_routeset",
        "description": "PJSIP is a free and open source multimedia communication library written in C language implementing standard based protocols such as SIP, SDP, RTP, STUN, TURN, and ICE. In version 2.10 and earlier, PJSIP transport can be reused if they have the same IP address + port + protocol. However, this is insufficient for secure transport since it lacks remote hostname authentication. Suppose we have created a TLS connection to `sip.foo.com`, which has an IP address `100.1.1.1`. If we want to create a TLS connection to another hostname, say `sip.bar.com`, which has the same IP address, then it will reuse that existing connection, even though `100.1.1.1` does not have certificate to authenticate as `sip.bar.com`. The vulnerability allows for an insecure interaction without user awareness. It affects users who need access to connections to different destinations that translate to the same address, and allows man-in-the-middle attack if attacker can route a connection to another destination such as in the case of DNS spoofing.",
        "git_url": "https://github.com/pjsip/pjproject/commit/67e46c1ac45ad784db5b9080f5ed8b133c122872",
        "commit_title": "Merge pull request from GHSA-8hcp-hm38-mfph",
        "commit_text": " * Check hostname during TLS transport selection  * revision based on feedback  * remove the code in create_request that has been moved",
        "func_before": "static void dlg_update_routeset(pjsip_dialog *dlg, const pjsip_rx_data *rdata)\n{\n    const pjsip_hdr *hdr, *end_hdr;\n    //pj_int32_t msg_cseq;\n    const pjsip_msg *msg;\n    const pjsip_method update = { PJSIP_OTHER_METHOD, {\"UPDATE\", 6}};\n\n    msg = rdata->msg_info.msg;\n    //msg_cseq = rdata->msg_info.cseq->cseq;\n\n    /* Ignore if route set has been frozen */\n    if (dlg->route_set_frozen)\n\treturn;\n\n    /* Ignore if the message is an UPDATE response (see ticket #1781) */\n    if (pjsip_method_cmp(&rdata->msg_info.cseq->method, &update) == 0)\n\treturn;\n\n    /* Only update route set if this message belongs to the same\n     * transaction as the initial transaction that establishes dialog.\n     */\n    if (dlg->role == PJSIP_ROLE_UAC) {\n\n\t/* Ignore subsequent request from remote */\n\tif (msg->type != PJSIP_RESPONSE_MSG)\n\t    return;\n\n\t/* Ignore subsequent responses with higher CSeq than initial CSeq.\n\t * Unfortunately this would be broken when the first request is\n\t * challenged!\n\t */\n\t//if (msg_cseq != dlg->local.first_cseq)\n\t//    return;\n\n    } else {\n\n\t/* For callee dialog, route set should have been set by initial\n\t * request and it will have been rejected by dlg->route_set_frozen\n\t * check above.\n\t */\n\tpj_assert(!\"Should not happen\");\n\n    }\n\n    /* Based on the checks above, we should only get response message here */\n    pj_assert(msg->type == PJSIP_RESPONSE_MSG);\n\n    /* Ignore if this is not 1xx or 2xx response */\n    if (msg->line.status.code >= 300)\n\treturn;\n\n    /* Reset route set */\n    pj_list_init(&dlg->route_set);\n\n    /* Update route set */\n    end_hdr = &msg->hdr;\n    for (hdr=msg->hdr.prev; hdr!=end_hdr; hdr=hdr->prev) {\n\tif (hdr->type == PJSIP_H_RECORD_ROUTE) {\n\t    pjsip_route_hdr *r;\n\t    r = (pjsip_route_hdr*) pjsip_hdr_clone(dlg->pool, hdr);\n\t    pjsip_routing_hdr_set_route(r);\n\t    pj_list_push_back(&dlg->route_set, r);\n\t}\n    }\n\n    PJ_LOG(5,(dlg->obj_name, \"Route-set updated\"));\n\n    /* Freeze the route set only when the route set comes in 2xx response.\n     * If it is in 1xx response, prepare to recompute the route set when\n     * the 2xx response comes in.\n     *\n     * There is a debate whether route set should be frozen when the dialog\n     * is established with reliable provisional response, but I think\n     * it is safer to not freeze the route set (thus recompute the route set\n     * upon receiving 2xx response). Also RFC 3261 says so in 13.2.2.4.\n     *\n     * The pjsip_method_creates_dialog() check protects from wrongly\n     * freezing the route set upon receiving 200/OK response for PRACK.\n     */\n    if (pjsip_method_creates_dialog(&rdata->msg_info.cseq->method) &&\n\tPJSIP_IS_STATUS_IN_CLASS(msg->line.status.code, 200))\n    {\n\tdlg->route_set_frozen = PJ_TRUE;\n\tPJ_LOG(5,(dlg->obj_name, \"Route-set frozen\"));\n    }\n}",
        "func": "static void dlg_update_routeset(pjsip_dialog *dlg, const pjsip_rx_data *rdata)\n{\n    const pjsip_hdr *hdr, *end_hdr;\n    //pj_int32_t msg_cseq;\n    const pjsip_msg *msg;\n    const pjsip_method update = { PJSIP_OTHER_METHOD, {\"UPDATE\", 6}};\n\n    msg = rdata->msg_info.msg;\n    //msg_cseq = rdata->msg_info.cseq->cseq;\n\n    /* Ignore if route set has been frozen */\n    if (dlg->route_set_frozen)\n\treturn;\n\n    /* Ignore if the message is an UPDATE response (see ticket #1781) */\n    if (pjsip_method_cmp(&rdata->msg_info.cseq->method, &update) == 0)\n\treturn;\n\n    /* Only update route set if this message belongs to the same\n     * transaction as the initial transaction that establishes dialog.\n     */\n    if (dlg->role == PJSIP_ROLE_UAC) {\n    \t/* Save initial destination host from transport's info. */\n    \tif (!dlg->initial_dest.slen) {\n    \t    pj_strdup(dlg->pool, &dlg->initial_dest,\n    \t      \t      &rdata->tp_info.transport->remote_name.host);\n    \t}\n\n\t/* Ignore subsequent request from remote */\n\tif (msg->type != PJSIP_RESPONSE_MSG)\n\t    return;\n\n\t/* Ignore subsequent responses with higher CSeq than initial CSeq.\n\t * Unfortunately this would be broken when the first request is\n\t * challenged!\n\t */\n\t//if (msg_cseq != dlg->local.first_cseq)\n\t//    return;\n\n    } else {\n\n\t/* For callee dialog, route set should have been set by initial\n\t * request and it will have been rejected by dlg->route_set_frozen\n\t * check above.\n\t */\n\tpj_assert(!\"Should not happen\");\n\n    }\n\n    /* Based on the checks above, we should only get response message here */\n    pj_assert(msg->type == PJSIP_RESPONSE_MSG);\n\n    /* Ignore if this is not 1xx or 2xx response */\n    if (msg->line.status.code >= 300)\n\treturn;\n\n    /* Reset route set */\n    pj_list_init(&dlg->route_set);\n\n    /* Update route set */\n    end_hdr = &msg->hdr;\n    for (hdr=msg->hdr.prev; hdr!=end_hdr; hdr=hdr->prev) {\n\tif (hdr->type == PJSIP_H_RECORD_ROUTE) {\n\t    pjsip_route_hdr *r;\n\t    r = (pjsip_route_hdr*) pjsip_hdr_clone(dlg->pool, hdr);\n\t    pjsip_routing_hdr_set_route(r);\n\t    pj_list_push_back(&dlg->route_set, r);\n\t}\n    }\n\n    PJ_LOG(5,(dlg->obj_name, \"Route-set updated\"));\n\n    /* Freeze the route set only when the route set comes in 2xx response.\n     * If it is in 1xx response, prepare to recompute the route set when\n     * the 2xx response comes in.\n     *\n     * There is a debate whether route set should be frozen when the dialog\n     * is established with reliable provisional response, but I think\n     * it is safer to not freeze the route set (thus recompute the route set\n     * upon receiving 2xx response). Also RFC 3261 says so in 13.2.2.4.\n     *\n     * The pjsip_method_creates_dialog() check protects from wrongly\n     * freezing the route set upon receiving 200/OK response for PRACK.\n     */\n    if (pjsip_method_creates_dialog(&rdata->msg_info.cseq->method) &&\n\tPJSIP_IS_STATUS_IN_CLASS(msg->line.status.code, 200))\n    {\n\tdlg->route_set_frozen = PJ_TRUE;\n\tPJ_LOG(5,(dlg->obj_name, \"Route-set frozen\"));\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -20,6 +20,11 @@\n      * transaction as the initial transaction that establishes dialog.\n      */\n     if (dlg->role == PJSIP_ROLE_UAC) {\n+    \t/* Save initial destination host from transport's info. */\n+    \tif (!dlg->initial_dest.slen) {\n+    \t    pj_strdup(dlg->pool, &dlg->initial_dest,\n+    \t      \t      &rdata->tp_info.transport->remote_name.host);\n+    \t}\n \n \t/* Ignore subsequent request from remote */\n \tif (msg->type != PJSIP_RESPONSE_MSG)",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "    \t/* Save initial destination host from transport's info. */",
                "    \tif (!dlg->initial_dest.slen) {",
                "    \t    pj_strdup(dlg->pool, &dlg->initial_dest,",
                "    \t      \t      &rdata->tp_info.transport->remote_name.host);",
                "    \t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-15260",
        "func_name": "pjsip/pjproject/pjsip_tpmgr_acquire_transport2",
        "description": "PJSIP is a free and open source multimedia communication library written in C language implementing standard based protocols such as SIP, SDP, RTP, STUN, TURN, and ICE. In version 2.10 and earlier, PJSIP transport can be reused if they have the same IP address + port + protocol. However, this is insufficient for secure transport since it lacks remote hostname authentication. Suppose we have created a TLS connection to `sip.foo.com`, which has an IP address `100.1.1.1`. If we want to create a TLS connection to another hostname, say `sip.bar.com`, which has the same IP address, then it will reuse that existing connection, even though `100.1.1.1` does not have certificate to authenticate as `sip.bar.com`. The vulnerability allows for an insecure interaction without user awareness. It affects users who need access to connections to different destinations that translate to the same address, and allows man-in-the-middle attack if attacker can route a connection to another destination such as in the case of DNS spoofing.",
        "git_url": "https://github.com/pjsip/pjproject/commit/67e46c1ac45ad784db5b9080f5ed8b133c122872",
        "commit_title": "Merge pull request from GHSA-8hcp-hm38-mfph",
        "commit_text": " * Check hostname during TLS transport selection  * revision based on feedback  * remove the code in create_request that has been moved",
        "func_before": "PJ_DEF(pj_status_t) pjsip_tpmgr_acquire_transport2(pjsip_tpmgr *mgr,\n\t\t\t\t\t\t   pjsip_transport_type_e type,\n\t\t\t\t\t\t   const pj_sockaddr_t *remote,\n\t\t\t\t\t\t   int addr_len,\n\t\t\t\t\t\t   const pjsip_tpselector *sel,\n\t\t\t\t\t\t   pjsip_tx_data *tdata,\n\t\t\t\t\t\t   pjsip_transport **tp)\n{\n    pjsip_tpfactory *factory;\n    pj_status_t status;\n\n    TRACE_((THIS_FILE,\"Acquiring transport type=%s, sel=%s remote=%s:%d\",\n\t\t       pjsip_transport_get_type_name(type),\n\t\t       print_tpsel_info(sel),\n\t\t       addr_string(remote),\n\t\t       pj_sockaddr_get_port(remote)));\n\n    pj_lock_acquire(mgr->lock);\n\n    /* If transport is specified, then just use it if it is suitable\n     * for the destination.\n     */\n    if (sel && sel->type == PJSIP_TPSELECTOR_TRANSPORT &&\n\tsel->u.transport) \n    {\n\tpjsip_transport *seltp = sel->u.transport;\n\n\t/* See if the transport is (not) suitable */\n\tif (seltp->key.type != type) {\n\t    pj_lock_release(mgr->lock);\n\t    TRACE_((THIS_FILE, \"Transport type in tpsel not matched\"));\n\t    return PJSIP_ETPNOTSUITABLE;\n\t}\n\n\t/* Make sure the transport is not being destroyed */\n\tif (seltp->is_destroying) {\n\t    pj_lock_release(mgr->lock);\n\t    TRACE_((THIS_FILE,\"Transport to be acquired is being destroyed\"));\n\t    return PJ_ENOTFOUND;\n\t}\n\n\t/* We could also verify that the destination address is reachable\n\t * from this transport (i.e. both are equal), but if application\n\t * has requested a specific transport to be used, assume that\n\t * it knows what to do.\n\t *\n\t * In other words, I don't think destination verification is a good\n\t * idea for now.\n\t */\n\n\t/* Transport looks to be suitable to use, so just use it. */\n\tpjsip_transport_add_ref(seltp);\n\tpj_lock_release(mgr->lock);\n\t*tp = seltp;\n\n\tTRACE_((THIS_FILE, \"Transport %s acquired\", seltp->obj_name));\n\treturn PJ_SUCCESS;\n\n    } else {\n\n\t/*\n\t * This is the \"normal\" flow, where application doesn't specify\n\t * specific transport to be used to send message to.\n\t * In this case, lookup the transport from the hash table.\n\t */\n\tpjsip_transport_key key;\n\tint key_len;\n\tpjsip_transport *tp_ref = NULL;\n\ttransport *tp_entry = NULL;\n\n\n\t/* If listener is specified, verify that the listener type matches\n\t * the destination type.\n\t */\n\tif (sel && sel->type == PJSIP_TPSELECTOR_LISTENER && sel->u.listener)\n\t{\n\t    if (sel->u.listener->type != type) {\n\t\tpj_lock_release(mgr->lock);\n\t\tTRACE_((THIS_FILE, \"Listener type in tpsel not matched\"));\n\t\treturn PJSIP_ETPNOTSUITABLE;\n\t    }\n\t}\n\n\tif (!sel || sel->disable_connection_reuse == PJ_FALSE) {\n\t    pj_bzero(&key, sizeof(key));\n\t    key_len = sizeof(key.type) + addr_len;\n\n\t    /* First try to get exact destination. */\n\t    key.type = type;\n\t    pj_memcpy(&key.rem_addr, remote, addr_len);\n\n\t    tp_entry = (transport *)pj_hash_get(mgr->table, &key, key_len,\n\t\t\t\t\t\tNULL);\n\t    if (tp_entry) {\n\t\ttransport *tp_iter = tp_entry;\n\t\tdo {\n\t\t    /* Don't use transport being shutdown/destroyed */\n\t\t    if (!tp_iter->tp->is_shutdown &&\n\t\t\t!tp_iter->tp->is_destroying)\n\t\t    {\n\t\t\tif (sel && sel->type == PJSIP_TPSELECTOR_LISTENER &&\n\t\t\t    sel->u.listener)\n\t\t\t{\n\t\t\t    /* Match listener if selector is set */\n\t\t\t    if (tp_iter->tp->factory == sel->u.listener) {\n\t\t\t\ttp_ref = tp_iter->tp;\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t} else {\n\t\t\t    tp_ref = tp_iter->tp;\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t    tp_iter = tp_iter->next;\n\t\t} while (tp_iter != tp_entry);\n\t    }\n\t}\n\n\tif (tp_ref == NULL &&\n\t    (!sel || sel->disable_connection_reuse == PJ_FALSE))\n\t{\n\t    unsigned flag = pjsip_transport_get_flag_from_type(type);\n\t    const pj_sockaddr *remote_addr = (const pj_sockaddr*)remote;\n\n\n\t    /* Ignore address for loop transports. */\n\t    if (type == PJSIP_TRANSPORT_LOOP ||\n\t\ttype == PJSIP_TRANSPORT_LOOP_DGRAM)\n\t    {\n\t\tpj_sockaddr *addr = &key.rem_addr;\n\n\t\tpj_bzero(addr, addr_len);\n\t\tkey_len = sizeof(key.type) + addr_len;\n\t\ttp_entry = (transport *) pj_hash_get(mgr->table, &key,\n\t\t\t\t\t\t     key_len, NULL);\n\t\tif (tp_entry) {\n\t\t    tp_ref = tp_entry->tp;\n\t\t}\n\t    }\n\t    /* For datagram transports, try lookup with zero address.\n\t     */\n\t    else if (flag & PJSIP_TRANSPORT_DATAGRAM)\n\t    {\n\t\tpj_sockaddr *addr = &key.rem_addr;\n\n\t\tpj_bzero(addr, addr_len);\n\t\taddr->addr.sa_family = remote_addr->addr.sa_family;\n\n\t\tkey_len = sizeof(key.type) + addr_len;\n\t\ttp_entry = (transport *) pj_hash_get(mgr->table, &key,\n\t\t\t\t\t\t     key_len, NULL);\n\t\tif (tp_entry) {\n\t\t    tp_ref = tp_entry->tp;\n\t\t}\n\t    }\n\t}\n\n\t/* If transport is found and listener is specified, verify listener */\n\telse if (sel && sel->type == PJSIP_TPSELECTOR_LISTENER &&\n\t\t sel->u.listener && tp_ref->factory != sel->u.listener)\n\t{\n\t    tp_ref = NULL;\n\t    /* This will cause a new transport to be created which will be a\n\t     * 'duplicate' of the existing transport (same type & remote addr,\n\t     * but different factory).\n\t     */\n\t    TRACE_((THIS_FILE, \"Transport found but from different listener\"));\n\t}\n\n\tif (tp_ref!=NULL && !tp_ref->is_shutdown && !tp_ref->is_destroying) {\n\t    /*\n\t     * Transport found!\n\t     */\n\t    pjsip_transport_add_ref(tp_ref);\n\t    pj_lock_release(mgr->lock);\n\t    *tp = tp_ref;\n\n\t    TRACE_((THIS_FILE, \"Transport %s acquired\", tp_ref->obj_name));\n\t    return PJ_SUCCESS;\n\t}\n\n\n\t/*\n\t * Either transport not found, or we don't want to use the existing\n\t * transport (such as in the case of different factory or\n\t * if connection reuse is disabled). So we need to create one,\n\t * find factory that can create such transport.\n\t *\n\t * If there's an existing transport, its place in the hash table\n\t * will be replaced by this new one. And eventually the existing\n\t * transport will still be freed (by application or #1774).\n\t */\n\tif (sel && sel->type == PJSIP_TPSELECTOR_LISTENER && sel->u.listener)\n\t{\n\t    /* Application has requested that a specific listener is to\n\t     * be used.\n\t     */\n\n\t    /* Verify that the listener type matches the destination type */\n\t    /* Already checked above. */\n\t    /*\n\t    if (sel->u.listener->type != type) {\n\t\tpj_lock_release(mgr->lock);\n\t\treturn PJSIP_ETPNOTSUITABLE;\n\t    }\n\t    */\n\n\t    /* We'll use this listener to create transport */\n\t    factory = sel->u.listener;\n\n\t    /* Verify if listener is still valid */\n\t    if (!pjsip_tpmgr_is_tpfactory_valid(mgr, factory)) {\n\t\tpj_lock_release(mgr->lock);\n\t\tPJ_LOG(3,(THIS_FILE, \"Specified factory for creating \"\n\t\t\t\t     \"transport is not found\"));\n\t\treturn PJ_ENOTFOUND;\n\t    }\n\n\t} else {\n\n\t    /* Find factory with type matches the destination type */\n\t    factory = mgr->factory_list.next;\n\t    while (factory != &mgr->factory_list) {\n\t\tif (factory->type == type)\n\t\t    break;\n\t\tfactory = factory->next;\n\t    }\n\n\t    if (factory == &mgr->factory_list) {\n\t\t/* No factory can create the transport! */\n\t\tpj_lock_release(mgr->lock);\n\t\tTRACE_((THIS_FILE, \"No suitable factory was found either\"));\n\t\treturn PJSIP_EUNSUPTRANSPORT;\n\t    }\n\t}\n    }\n\n    TRACE_((THIS_FILE, \"Creating new transport from factory\"));\n\n    /* Request factory to create transport. */\n    if (factory->create_transport2) {\n\tstatus = factory->create_transport2(factory, mgr, mgr->endpt,\n\t\t\t\t\t    (const pj_sockaddr*) remote,\n\t\t\t\t\t    addr_len, tdata, tp);\n    } else {\n\tstatus = factory->create_transport(factory, mgr, mgr->endpt,\n\t\t\t\t\t   (const pj_sockaddr*) remote,\n\t\t\t\t\t   addr_len, tp);\n    }\n    if (status == PJ_SUCCESS) {\n\tPJ_ASSERT_ON_FAIL(tp!=NULL,\n\t    {pj_lock_release(mgr->lock); return PJ_EBUG;});\n\tpjsip_transport_add_ref(*tp);\n\t(*tp)->factory = factory;\n    }",
        "func": "PJ_DEF(pj_status_t) pjsip_tpmgr_acquire_transport2(pjsip_tpmgr *mgr,\n\t\t\t\t\t\t   pjsip_transport_type_e type,\n\t\t\t\t\t\t   const pj_sockaddr_t *remote,\n\t\t\t\t\t\t   int addr_len,\n\t\t\t\t\t\t   const pjsip_tpselector *sel,\n\t\t\t\t\t\t   pjsip_tx_data *tdata,\n\t\t\t\t\t\t   pjsip_transport **tp)\n{\n    pjsip_tpfactory *factory;\n    pj_status_t status;\n\n    TRACE_((THIS_FILE,\"Acquiring transport type=%s, sel=%s remote=%s:%d\",\n\t\t       pjsip_transport_get_type_name(type),\n\t\t       print_tpsel_info(sel),\n\t\t       addr_string(remote),\n\t\t       pj_sockaddr_get_port(remote)));\n\n    pj_lock_acquire(mgr->lock);\n\n    /* If transport is specified, then just use it if it is suitable\n     * for the destination.\n     */\n    if (sel && sel->type == PJSIP_TPSELECTOR_TRANSPORT &&\n\tsel->u.transport) \n    {\n\tpjsip_transport *seltp = sel->u.transport;\n\n\t/* See if the transport is (not) suitable */\n\tif (seltp->key.type != type) {\n\t    pj_lock_release(mgr->lock);\n\t    TRACE_((THIS_FILE, \"Transport type in tpsel not matched\"));\n\t    return PJSIP_ETPNOTSUITABLE;\n\t}\n\n\t/* Make sure the transport is not being destroyed */\n\tif (seltp->is_destroying) {\n\t    pj_lock_release(mgr->lock);\n\t    TRACE_((THIS_FILE,\"Transport to be acquired is being destroyed\"));\n\t    return PJ_ENOTFOUND;\n\t}\n\n\t/* We could also verify that the destination address is reachable\n\t * from this transport (i.e. both are equal), but if application\n\t * has requested a specific transport to be used, assume that\n\t * it knows what to do.\n\t *\n\t * In other words, I don't think destination verification is a good\n\t * idea for now.\n\t */\n\n\t/* Transport looks to be suitable to use, so just use it. */\n\tpjsip_transport_add_ref(seltp);\n\tpj_lock_release(mgr->lock);\n\t*tp = seltp;\n\n\tTRACE_((THIS_FILE, \"Transport %s acquired\", seltp->obj_name));\n\treturn PJ_SUCCESS;\n\n    } else {\n\n\t/*\n\t * This is the \"normal\" flow, where application doesn't specify\n\t * specific transport to be used to send message to.\n\t * In this case, lookup the transport from the hash table.\n\t */\n\tpjsip_transport_key key;\n\tint key_len;\n\tpjsip_transport *tp_ref = NULL;\n\ttransport *tp_entry = NULL;\n\n\n\t/* If listener is specified, verify that the listener type matches\n\t * the destination type.\n\t */\n\tif (sel && sel->type == PJSIP_TPSELECTOR_LISTENER && sel->u.listener)\n\t{\n\t    if (sel->u.listener->type != type) {\n\t\tpj_lock_release(mgr->lock);\n\t\tTRACE_((THIS_FILE, \"Listener type in tpsel not matched\"));\n\t\treturn PJSIP_ETPNOTSUITABLE;\n\t    }\n\t}\n\n\tif (!sel || sel->disable_connection_reuse == PJ_FALSE) {\n\t    pj_bzero(&key, sizeof(key));\n\t    key_len = sizeof(key.type) + addr_len;\n\n\t    /* First try to get exact destination. */\n\t    key.type = type;\n\t    pj_memcpy(&key.rem_addr, remote, addr_len);\n\n\t    tp_entry = (transport *)pj_hash_get(mgr->table, &key, key_len,\n\t\t\t\t\t\tNULL);\n\t    if (tp_entry) {\n\t\ttransport *tp_iter = tp_entry;\n\t\tdo {\n\t\t    /* Don't use transport being shutdown/destroyed */\n\t\t    if (!tp_iter->tp->is_shutdown &&\n\t\t\t!tp_iter->tp->is_destroying)\n\t\t    {\n\t\t\tif ((type & PJSIP_TRANSPORT_SECURE) && tdata) {\n\t\t\t    /* For secure transport, make sure tdata's\n\t\t\t     * destination host matches the transport's\n\t\t\t     * remote host.\n\t\t\t     */\n\t\t\t    if (pj_stricmp(&tdata->dest_info.name,\n\t\t\t\t  \t   &tp_iter->tp->remote_name.host))\n\t\t\t    {\n\t\t\t    \ttp_iter = tp_iter->next;\n\t\t\t    \tcontinue;\n\t\t\t    }\n\t\t\t}\n\n\t\t\tif (sel && sel->type == PJSIP_TPSELECTOR_LISTENER &&\n\t\t\t    sel->u.listener)\n\t\t\t{\n\t\t\t    /* Match listener if selector is set */\n\t\t\t    if (tp_iter->tp->factory == sel->u.listener) {\n\t\t\t\ttp_ref = tp_iter->tp;\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t} else {\n\t\t\t    tp_ref = tp_iter->tp;\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t    tp_iter = tp_iter->next;\n\t\t} while (tp_iter != tp_entry);\n\t    }\n\t}\n\n\tif (tp_ref == NULL &&\n\t    (!sel || sel->disable_connection_reuse == PJ_FALSE))\n\t{\n\t    unsigned flag = pjsip_transport_get_flag_from_type(type);\n\t    const pj_sockaddr *remote_addr = (const pj_sockaddr*)remote;\n\n\n\t    /* Ignore address for loop transports. */\n\t    if (type == PJSIP_TRANSPORT_LOOP ||\n\t\ttype == PJSIP_TRANSPORT_LOOP_DGRAM)\n\t    {\n\t\tpj_sockaddr *addr = &key.rem_addr;\n\n\t\tpj_bzero(addr, addr_len);\n\t\tkey_len = sizeof(key.type) + addr_len;\n\t\ttp_entry = (transport *) pj_hash_get(mgr->table, &key,\n\t\t\t\t\t\t     key_len, NULL);\n\t\tif (tp_entry) {\n\t\t    tp_ref = tp_entry->tp;\n\t\t}\n\t    }\n\t    /* For datagram transports, try lookup with zero address.\n\t     */\n\t    else if (flag & PJSIP_TRANSPORT_DATAGRAM)\n\t    {\n\t\tpj_sockaddr *addr = &key.rem_addr;\n\n\t\tpj_bzero(addr, addr_len);\n\t\taddr->addr.sa_family = remote_addr->addr.sa_family;\n\n\t\tkey_len = sizeof(key.type) + addr_len;\n\t\ttp_entry = (transport *) pj_hash_get(mgr->table, &key,\n\t\t\t\t\t\t     key_len, NULL);\n\t\tif (tp_entry) {\n\t\t    tp_ref = tp_entry->tp;\n\t\t}\n\t    }\n\t}\n\n\t/* If transport is found and listener is specified, verify listener */\n\telse if (sel && sel->type == PJSIP_TPSELECTOR_LISTENER &&\n\t\t sel->u.listener && tp_ref->factory != sel->u.listener)\n\t{\n\t    tp_ref = NULL;\n\t    /* This will cause a new transport to be created which will be a\n\t     * 'duplicate' of the existing transport (same type & remote addr,\n\t     * but different factory).\n\t     */\n\t    TRACE_((THIS_FILE, \"Transport found but from different listener\"));\n\t}\n\n\tif (tp_ref!=NULL && !tp_ref->is_shutdown && !tp_ref->is_destroying) {\n\t    /*\n\t     * Transport found!\n\t     */\n\t    pjsip_transport_add_ref(tp_ref);\n\t    pj_lock_release(mgr->lock);\n\t    *tp = tp_ref;\n\n\t    TRACE_((THIS_FILE, \"Transport %s acquired\", tp_ref->obj_name));\n\t    return PJ_SUCCESS;\n\t}\n\n\n\t/*\n\t * Either transport not found, or we don't want to use the existing\n\t * transport (such as in the case of different factory or\n\t * if connection reuse is disabled). So we need to create one,\n\t * find factory that can create such transport.\n\t *\n\t * If there's an existing transport, its place in the hash table\n\t * will be replaced by this new one. And eventually the existing\n\t * transport will still be freed (by application or #1774).\n\t */\n\tif (sel && sel->type == PJSIP_TPSELECTOR_LISTENER && sel->u.listener)\n\t{\n\t    /* Application has requested that a specific listener is to\n\t     * be used.\n\t     */\n\n\t    /* Verify that the listener type matches the destination type */\n\t    /* Already checked above. */\n\t    /*\n\t    if (sel->u.listener->type != type) {\n\t\tpj_lock_release(mgr->lock);\n\t\treturn PJSIP_ETPNOTSUITABLE;\n\t    }\n\t    */\n\n\t    /* We'll use this listener to create transport */\n\t    factory = sel->u.listener;\n\n\t    /* Verify if listener is still valid */\n\t    if (!pjsip_tpmgr_is_tpfactory_valid(mgr, factory)) {\n\t\tpj_lock_release(mgr->lock);\n\t\tPJ_LOG(3,(THIS_FILE, \"Specified factory for creating \"\n\t\t\t\t     \"transport is not found\"));\n\t\treturn PJ_ENOTFOUND;\n\t    }\n\n\t} else {\n\n\t    /* Find factory with type matches the destination type */\n\t    factory = mgr->factory_list.next;\n\t    while (factory != &mgr->factory_list) {\n\t\tif (factory->type == type)\n\t\t    break;\n\t\tfactory = factory->next;\n\t    }\n\n\t    if (factory == &mgr->factory_list) {\n\t\t/* No factory can create the transport! */\n\t\tpj_lock_release(mgr->lock);\n\t\tTRACE_((THIS_FILE, \"No suitable factory was found either\"));\n\t\treturn PJSIP_EUNSUPTRANSPORT;\n\t    }\n\t}\n    }\n\n    TRACE_((THIS_FILE, \"Creating new transport from factory\"));\n\n    /* Request factory to create transport. */\n    if (factory->create_transport2) {\n\tstatus = factory->create_transport2(factory, mgr, mgr->endpt,\n\t\t\t\t\t    (const pj_sockaddr*) remote,\n\t\t\t\t\t    addr_len, tdata, tp);\n    } else {\n\tstatus = factory->create_transport(factory, mgr, mgr->endpt,\n\t\t\t\t\t   (const pj_sockaddr*) remote,\n\t\t\t\t\t   addr_len, tp);\n    }\n    if (status == PJ_SUCCESS) {\n\tPJ_ASSERT_ON_FAIL(tp!=NULL,\n\t    {pj_lock_release(mgr->lock); return PJ_EBUG;});\n\tpjsip_transport_add_ref(*tp);\n\t(*tp)->factory = factory;\n    }",
        "diff_func": "--- func_before\n+++ func_after\n@@ -98,6 +98,19 @@\n \t\t    if (!tp_iter->tp->is_shutdown &&\n \t\t\t!tp_iter->tp->is_destroying)\n \t\t    {\n+\t\t\tif ((type & PJSIP_TRANSPORT_SECURE) && tdata) {\n+\t\t\t    /* For secure transport, make sure tdata's\n+\t\t\t     * destination host matches the transport's\n+\t\t\t     * remote host.\n+\t\t\t     */\n+\t\t\t    if (pj_stricmp(&tdata->dest_info.name,\n+\t\t\t\t  \t   &tp_iter->tp->remote_name.host))\n+\t\t\t    {\n+\t\t\t    \ttp_iter = tp_iter->next;\n+\t\t\t    \tcontinue;\n+\t\t\t    }\n+\t\t\t}\n+\n \t\t\tif (sel && sel->type == PJSIP_TPSELECTOR_LISTENER &&\n \t\t\t    sel->u.listener)\n \t\t\t{",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\t\tif ((type & PJSIP_TRANSPORT_SECURE) && tdata) {",
                "\t\t\t    /* For secure transport, make sure tdata's",
                "\t\t\t     * destination host matches the transport's",
                "\t\t\t     * remote host.",
                "\t\t\t     */",
                "\t\t\t    if (pj_stricmp(&tdata->dest_info.name,",
                "\t\t\t\t  \t   &tp_iter->tp->remote_name.host))",
                "\t\t\t    {",
                "\t\t\t    \ttp_iter = tp_iter->next;",
                "\t\t\t    \tcontinue;",
                "\t\t\t    }",
                "\t\t\t}",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2020-15260",
        "func_name": "pjsip/pjproject/pjsip_endpt_send_response",
        "description": "PJSIP is a free and open source multimedia communication library written in C language implementing standard based protocols such as SIP, SDP, RTP, STUN, TURN, and ICE. In version 2.10 and earlier, PJSIP transport can be reused if they have the same IP address + port + protocol. However, this is insufficient for secure transport since it lacks remote hostname authentication. Suppose we have created a TLS connection to `sip.foo.com`, which has an IP address `100.1.1.1`. If we want to create a TLS connection to another hostname, say `sip.bar.com`, which has the same IP address, then it will reuse that existing connection, even though `100.1.1.1` does not have certificate to authenticate as `sip.bar.com`. The vulnerability allows for an insecure interaction without user awareness. It affects users who need access to connections to different destinations that translate to the same address, and allows man-in-the-middle attack if attacker can route a connection to another destination such as in the case of DNS spoofing.",
        "git_url": "https://github.com/pjsip/pjproject/commit/67e46c1ac45ad784db5b9080f5ed8b133c122872",
        "commit_title": "Merge pull request from GHSA-8hcp-hm38-mfph",
        "commit_text": " * Check hostname during TLS transport selection  * revision based on feedback  * remove the code in create_request that has been moved",
        "func_before": "PJ_DEF(pj_status_t) pjsip_endpt_send_response( pjsip_endpoint *endpt,\n\t\t\t\t\t       pjsip_response_addr *res_addr,\n\t\t\t\t\t       pjsip_tx_data *tdata,\n\t\t\t\t\t       void *token,\n\t\t\t\t\t       pjsip_send_callback cb)\n{\n    /* Determine which transports and addresses to send the response,\n     * based on Section 18.2.2 of RFC 3261.\n     */\n    pjsip_send_state *send_state;\n    pj_status_t status;\n\n    /* Create structure to keep the sending state. */\n    send_state = PJ_POOL_ZALLOC_T(tdata->pool, pjsip_send_state);\n    send_state->endpt = endpt;\n    send_state->tdata = tdata;\n    send_state->token = token;\n    send_state->app_cb = cb;\n\n    if (res_addr->transport != NULL) {\n\tsend_state->cur_transport = res_addr->transport;\n\tpjsip_transport_add_ref(send_state->cur_transport);\n\n\tstatus = pjsip_transport_send( send_state->cur_transport, tdata, \n\t\t\t\t       &res_addr->addr,\n\t\t\t\t       res_addr->addr_len,\n\t\t\t\t       send_state,\n\t\t\t\t       &send_response_transport_cb );\n\tif (status == PJ_SUCCESS) {\n\t    pj_ssize_t sent = tdata->buf.cur - tdata->buf.start;\n\t    send_response_transport_cb(send_state, tdata, sent);\n\t    return PJ_SUCCESS;\n\t} else if (status == PJ_EPENDING) {\n\t    /* Callback will be called later. */\n\t    return PJ_SUCCESS;\n\t} else {\n\t    pjsip_transport_dec_ref(send_state->cur_transport);\n\t    return status;\n\t}\n    } else {\n\t/* Copy the destination host name to TX data */\n\tpj_strdup(tdata->pool, &tdata->dest_info.name, \n\t\t  &res_addr->dst_host.addr.host);\n\n\tpjsip_endpt_resolve(endpt, tdata->pool, &res_addr->dst_host, \n\t\t\t    send_state, &send_response_resolver_cb);\n\treturn PJ_SUCCESS;\n    }\n}",
        "func": "PJ_DEF(pj_status_t) pjsip_endpt_send_response( pjsip_endpoint *endpt,\n\t\t\t\t\t       pjsip_response_addr *res_addr,\n\t\t\t\t\t       pjsip_tx_data *tdata,\n\t\t\t\t\t       void *token,\n\t\t\t\t\t       pjsip_send_callback cb)\n{\n    /* Determine which transports and addresses to send the response,\n     * based on Section 18.2.2 of RFC 3261.\n     */\n    pjsip_send_state *send_state;\n    pj_status_t status;\n\n    /* Create structure to keep the sending state. */\n    send_state = PJ_POOL_ZALLOC_T(tdata->pool, pjsip_send_state);\n    send_state->endpt = endpt;\n    send_state->tdata = tdata;\n    send_state->token = token;\n    send_state->app_cb = cb;\n\n    if (res_addr->transport != NULL) {\n\tsend_state->cur_transport = res_addr->transport;\n\tpjsip_transport_add_ref(send_state->cur_transport);\n\n\tstatus = pjsip_transport_send( send_state->cur_transport, tdata, \n\t\t\t\t       &res_addr->addr,\n\t\t\t\t       res_addr->addr_len,\n\t\t\t\t       send_state,\n\t\t\t\t       &send_response_transport_cb );\n\tif (status == PJ_SUCCESS) {\n\t    pj_ssize_t sent = tdata->buf.cur - tdata->buf.start;\n\t    send_response_transport_cb(send_state, tdata, sent);\n\t    return PJ_SUCCESS;\n\t} else if (status == PJ_EPENDING) {\n\t    /* Callback will be called later. */\n\t    return PJ_SUCCESS;\n\t} else {\n\t    pjsip_transport_dec_ref(send_state->cur_transport);\n\t    return status;\n\t}\n    } else {\n\t/* Copy the destination host name to TX data */\n\tif (!tdata->dest_info.name.slen) {\n\t    pj_strdup(tdata->pool, &tdata->dest_info.name, \n\t\t      &res_addr->dst_host.addr.host);\n\t}\n\n\tpjsip_endpt_resolve(endpt, tdata->pool, &res_addr->dst_host, \n\t\t\t    send_state, &send_response_resolver_cb);\n\treturn PJ_SUCCESS;\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -39,8 +39,10 @@\n \t}\n     } else {\n \t/* Copy the destination host name to TX data */\n-\tpj_strdup(tdata->pool, &tdata->dest_info.name, \n-\t\t  &res_addr->dst_host.addr.host);\n+\tif (!tdata->dest_info.name.slen) {\n+\t    pj_strdup(tdata->pool, &tdata->dest_info.name, \n+\t\t      &res_addr->dst_host.addr.host);\n+\t}\n \n \tpjsip_endpt_resolve(endpt, tdata->pool, &res_addr->dst_host, \n \t\t\t    send_state, &send_response_resolver_cb);",
        "diff_line_info": {
            "deleted_lines": [
                "\tpj_strdup(tdata->pool, &tdata->dest_info.name, ",
                "\t\t  &res_addr->dst_host.addr.host);"
            ],
            "added_lines": [
                "\tif (!tdata->dest_info.name.slen) {",
                "\t    pj_strdup(tdata->pool, &tdata->dest_info.name, ",
                "\t\t      &res_addr->dst_host.addr.host);",
                "\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-15260",
        "func_name": "pjsip/pjproject/pjsip_endpt_send_request_stateless",
        "description": "PJSIP is a free and open source multimedia communication library written in C language implementing standard based protocols such as SIP, SDP, RTP, STUN, TURN, and ICE. In version 2.10 and earlier, PJSIP transport can be reused if they have the same IP address + port + protocol. However, this is insufficient for secure transport since it lacks remote hostname authentication. Suppose we have created a TLS connection to `sip.foo.com`, which has an IP address `100.1.1.1`. If we want to create a TLS connection to another hostname, say `sip.bar.com`, which has the same IP address, then it will reuse that existing connection, even though `100.1.1.1` does not have certificate to authenticate as `sip.bar.com`. The vulnerability allows for an insecure interaction without user awareness. It affects users who need access to connections to different destinations that translate to the same address, and allows man-in-the-middle attack if attacker can route a connection to another destination such as in the case of DNS spoofing.",
        "git_url": "https://github.com/pjsip/pjproject/commit/67e46c1ac45ad784db5b9080f5ed8b133c122872",
        "commit_title": "Merge pull request from GHSA-8hcp-hm38-mfph",
        "commit_text": " * Check hostname during TLS transport selection  * revision based on feedback  * remove the code in create_request that has been moved",
        "func_before": "PJ_DEF(pj_status_t) pjsip_endpt_send_request_stateless(pjsip_endpoint *endpt, \n\t\t\t\t   pjsip_tx_data *tdata,\n\t\t\t\t   void *token,\n\t\t\t\t   pjsip_send_callback cb)\n{\n    pjsip_host_info dest_info;\n    pjsip_send_state *stateless_data;\n    pj_status_t status;\n\n    PJ_ASSERT_RETURN(endpt && tdata, PJ_EINVAL);\n\n    /* Get destination name to contact. */\n    status = pjsip_process_route_set(tdata, &dest_info);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    /* Keep stateless data. */\n    stateless_data = PJ_POOL_ZALLOC_T(tdata->pool, pjsip_send_state);\n    stateless_data->token = token;\n    stateless_data->endpt = endpt;\n    stateless_data->tdata = tdata;\n    stateless_data->app_cb = cb;\n\n    /* If destination info has not been initialized (this applies for most\n     * all requests except CANCEL), resolve destination host. The processing\n     * then resumed when the resolving callback is called. For CANCEL, the\n     * destination info must have been copied from the original INVITE so\n     * proceed to sending the request directly.\n     */\n    if (tdata->dest_info.addr.count == 0) {\n\t/* Copy the destination host name to TX data */\n\tpj_strdup(tdata->pool, &tdata->dest_info.name, &dest_info.addr.host);\n\n\tpjsip_endpt_resolve( endpt, tdata->pool, &dest_info, stateless_data,\n\t\t\t     &stateless_send_resolver_callback);\n    } else {\n\tPJ_LOG(5,(THIS_FILE, \"%s: skipping target resolution because \"\n\t                     \"address is already set\",\n\t\t\t     pjsip_tx_data_get_info(tdata)));\n\tstateless_send_resolver_callback(PJ_SUCCESS, stateless_data,\n\t\t\t\t\t &tdata->dest_info.addr);\n    }\n    return PJ_SUCCESS;\n}",
        "func": "PJ_DEF(pj_status_t) pjsip_endpt_send_request_stateless(pjsip_endpoint *endpt, \n\t\t\t\t   pjsip_tx_data *tdata,\n\t\t\t\t   void *token,\n\t\t\t\t   pjsip_send_callback cb)\n{\n    pjsip_host_info dest_info;\n    pjsip_send_state *stateless_data;\n    pj_status_t status;\n\n    PJ_ASSERT_RETURN(endpt && tdata, PJ_EINVAL);\n\n    /* Get destination name to contact. */\n    status = pjsip_process_route_set(tdata, &dest_info);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    /* Keep stateless data. */\n    stateless_data = PJ_POOL_ZALLOC_T(tdata->pool, pjsip_send_state);\n    stateless_data->token = token;\n    stateless_data->endpt = endpt;\n    stateless_data->tdata = tdata;\n    stateless_data->app_cb = cb;\n\n    /* If destination info has not been initialized (this applies for most\n     * all requests except CANCEL), resolve destination host. The processing\n     * then resumed when the resolving callback is called. For CANCEL, the\n     * destination info must have been copied from the original INVITE so\n     * proceed to sending the request directly.\n     */\n    if (tdata->dest_info.addr.count == 0) {\n\t/* Copy the destination host name to TX data */\n\tif (!tdata->dest_info.name.slen) {\n\t    pj_strdup(tdata->pool, &tdata->dest_info.name,\n\t    \t      &dest_info.addr.host);\n\t}\n\n\tpjsip_endpt_resolve( endpt, tdata->pool, &dest_info, stateless_data,\n\t\t\t     &stateless_send_resolver_callback);\n    } else {\n\tPJ_LOG(5,(THIS_FILE, \"%s: skipping target resolution because \"\n\t                     \"address is already set\",\n\t\t\t     pjsip_tx_data_get_info(tdata)));\n\tstateless_send_resolver_callback(PJ_SUCCESS, stateless_data,\n\t\t\t\t\t &tdata->dest_info.addr);\n    }\n    return PJ_SUCCESS;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -29,7 +29,10 @@\n      */\n     if (tdata->dest_info.addr.count == 0) {\n \t/* Copy the destination host name to TX data */\n-\tpj_strdup(tdata->pool, &tdata->dest_info.name, &dest_info.addr.host);\n+\tif (!tdata->dest_info.name.slen) {\n+\t    pj_strdup(tdata->pool, &tdata->dest_info.name,\n+\t    \t      &dest_info.addr.host);\n+\t}\n \n \tpjsip_endpt_resolve( endpt, tdata->pool, &dest_info, stateless_data,\n \t\t\t     &stateless_send_resolver_callback);",
        "diff_line_info": {
            "deleted_lines": [
                "\tpj_strdup(tdata->pool, &tdata->dest_info.name, &dest_info.addr.host);"
            ],
            "added_lines": [
                "\tif (!tdata->dest_info.name.slen) {",
                "\t    pj_strdup(tdata->pool, &tdata->dest_info.name,",
                "\t    \t      &dest_info.addr.host);",
                "\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-3450",
        "func_name": "openssl/check_chain_extensions",
        "description": "The X509_V_FLAG_X509_STRICT flag enables additional security checks of the certificates present in a certificate chain. It is not set by default. Starting from OpenSSL version 1.1.1h a check to disallow certificates in the chain that have explicitly encoded elliptic curve parameters was added as an additional strict check. An error in the implementation of this check meant that the result of a previous check to confirm that certificates in the chain are valid CA certificates was overwritten. This effectively bypasses the check that non-CA certificates must not be able to issue other certificates. If a \"purpose\" has been configured then there is a subsequent opportunity for checks that the certificate is a valid CA. All of the named \"purpose\" values implemented in libcrypto perform this check. Therefore, where a purpose is set the certificate chain will still be rejected even when the strict flag has been used. A purpose is set by default in libssl client and server certificate verification routines, but it can be overridden or removed by an application. In order to be affected, an application must explicitly set the X509_V_FLAG_X509_STRICT verification flag and either not set a purpose for the certificate verification or, in the case of TLS client or server applications, override the default purpose. OpenSSL versions 1.1.1h and newer are affected by this issue. Users of these versions should upgrade to OpenSSL 1.1.1k. OpenSSL 1.0.2 is not impacted by this issue. Fixed in OpenSSL 1.1.1k (Affected 1.1.1h-1.1.1j).",
        "git_url": "https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=2a40b7bc7b94dd7de897a74571e7024f0cf0d63b",
        "commit_title": "",
        "commit_text": "check_chain_extensions: Do not override error return value by check_curve  The X509_V_FLAG_X509_STRICT flag enables additional security checks of the certificates present in a certificate chain. It is not set by default.  Starting from OpenSSL version 1.1.1h a check to disallow certificates with explicitly encoded elliptic curve parameters in the chain was added to the strict checks.  An error in the implementation of this check meant that the result of a previous check to confirm that certificates in the chain are valid CA certificates was overwritten. This effectively bypasses the check that non-CA certificates must not be able to issue other certificates.  If a \"purpose\" has been configured then a subsequent check that the certificate is consistent with that purpose also checks that it is a valid CA. Therefore where a purpose is set the certificate chain will still be rejected even when the strict flag has been used. A purpose is set by default in libssl client and server certificate verification routines, but it can be overriden by an application.  Affected applications explicitly set the X509_V_FLAG_X509_STRICT verification flag and either do not set a purpose for the certificate verification or, in the case of TLS client or server applications, override the default purpose to make it not set.  CVE-2021-3450  ",
        "func_before": "static int check_chain_extensions(X509_STORE_CTX *ctx)\n{\n    int i, must_be_ca, plen = 0;\n    X509 *x;\n    int proxy_path_length = 0;\n    int purpose;\n    int allow_proxy_certs;\n    int num = sk_X509_num(ctx->chain);\n\n    /*-\n     *  must_be_ca can have 1 of 3 values:\n     * -1: we accept both CA and non-CA certificates, to allow direct\n     *     use of self-signed certificates (which are marked as CA).\n     * 0:  we only accept non-CA certificates.  This is currently not\n     *     used, but the possibility is present for future extensions.\n     * 1:  we only accept CA certificates.  This is currently used for\n     *     all certificates in the chain except the leaf certificate.\n     */\n    must_be_ca = -1;\n\n    /* CRL path validation */\n    if (ctx->parent) {\n        allow_proxy_certs = 0;\n        purpose = X509_PURPOSE_CRL_SIGN;\n    } else {\n        allow_proxy_certs =\n            ! !(ctx->param->flags & X509_V_FLAG_ALLOW_PROXY_CERTS);\n        purpose = ctx->param->purpose;\n    }\n\n    for (i = 0; i < num; i++) {\n        int ret;\n        x = sk_X509_value(ctx->chain, i);\n        if (!(ctx->param->flags & X509_V_FLAG_IGNORE_CRITICAL)\n            && (x->ex_flags & EXFLAG_CRITICAL)) {\n            if (!verify_cb_cert(ctx, x, i,\n                                X509_V_ERR_UNHANDLED_CRITICAL_EXTENSION))\n                return 0;\n        }\n        if (!allow_proxy_certs && (x->ex_flags & EXFLAG_PROXY)) {\n            if (!verify_cb_cert(ctx, x, i,\n                                X509_V_ERR_PROXY_CERTIFICATES_NOT_ALLOWED))\n                return 0;\n        }\n        ret = X509_check_ca(x);\n        switch (must_be_ca) {\n        case -1:\n            if ((ctx->param->flags & X509_V_FLAG_X509_STRICT)\n                && (ret != 1) && (ret != 0)) {\n                ret = 0;\n                ctx->error = X509_V_ERR_INVALID_CA;\n            } else\n                ret = 1;\n            break;\n        case 0:\n            if (ret != 0) {\n                ret = 0;\n                ctx->error = X509_V_ERR_INVALID_NON_CA;\n            } else\n                ret = 1;\n            break;\n        default:\n            /* X509_V_FLAG_X509_STRICT is implicit for intermediate CAs */\n            if ((ret == 0)\n                || ((i + 1 < num || ctx->param->flags & X509_V_FLAG_X509_STRICT)\n                    && (ret != 1))) {\n                ret = 0;\n                ctx->error = X509_V_ERR_INVALID_CA;\n            } else\n                ret = 1;\n            break;\n        }\n        if ((ctx->param->flags & X509_V_FLAG_X509_STRICT) && num > 1) {\n            /* Check for presence of explicit elliptic curve parameters */\n            ret = check_curve(x);\n            if (ret < 0)\n                ctx->error = X509_V_ERR_UNSPECIFIED;\n            else if (ret == 0)\n                ctx->error = X509_V_ERR_EC_KEY_EXPLICIT_PARAMS;\n        }\n        if ((x->ex_flags & EXFLAG_CA) == 0\n            && x->ex_pathlen != -1\n            && (ctx->param->flags & X509_V_FLAG_X509_STRICT)) {\n            ctx->error = X509_V_ERR_INVALID_EXTENSION;\n            ret = 0;\n        }\n        if (ret == 0 && !verify_cb_cert(ctx, x, i, X509_V_OK))\n            return 0;\n        /* check_purpose() makes the callback as needed */\n        if (purpose > 0 && !check_purpose(ctx, x, purpose, i, must_be_ca))\n            return 0;\n        /* Check pathlen */\n        if ((i > 1) && (x->ex_pathlen != -1)\n            && (plen > (x->ex_pathlen + proxy_path_length))) {\n            if (!verify_cb_cert(ctx, x, i, X509_V_ERR_PATH_LENGTH_EXCEEDED))\n                return 0;\n        }\n        /* Increment path length if not a self issued intermediate CA */\n        if (i > 0 && (x->ex_flags & EXFLAG_SI) == 0)\n            plen++;\n        /*\n         * If this certificate is a proxy certificate, the next certificate\n         * must be another proxy certificate or a EE certificate.  If not,\n         * the next certificate must be a CA certificate.\n         */\n        if (x->ex_flags & EXFLAG_PROXY) {\n            /*\n             * RFC3820, 4.1.3 (b)(1) stipulates that if pCPathLengthConstraint\n             * is less than max_path_length, the former should be copied to\n             * the latter, and 4.1.4 (a) stipulates that max_path_length\n             * should be verified to be larger than zero and decrement it.\n             *\n             * Because we're checking the certs in the reverse order, we start\n             * with verifying that proxy_path_length isn't larger than pcPLC,\n             * and copy the latter to the former if it is, and finally,\n             * increment proxy_path_length.\n             */\n            if (x->ex_pcpathlen != -1) {\n                if (proxy_path_length > x->ex_pcpathlen) {\n                    if (!verify_cb_cert(ctx, x, i,\n                                        X509_V_ERR_PROXY_PATH_LENGTH_EXCEEDED))\n                        return 0;\n                }\n                proxy_path_length = x->ex_pcpathlen;\n            }\n            proxy_path_length++;\n            must_be_ca = 0;\n        } else\n            must_be_ca = 1;\n    }\n    return 1;\n}",
        "func": "static int check_chain_extensions(X509_STORE_CTX *ctx)\n{\n    int i, must_be_ca, plen = 0;\n    X509 *x;\n    int proxy_path_length = 0;\n    int purpose;\n    int allow_proxy_certs;\n    int num = sk_X509_num(ctx->chain);\n\n    /*-\n     *  must_be_ca can have 1 of 3 values:\n     * -1: we accept both CA and non-CA certificates, to allow direct\n     *     use of self-signed certificates (which are marked as CA).\n     * 0:  we only accept non-CA certificates.  This is currently not\n     *     used, but the possibility is present for future extensions.\n     * 1:  we only accept CA certificates.  This is currently used for\n     *     all certificates in the chain except the leaf certificate.\n     */\n    must_be_ca = -1;\n\n    /* CRL path validation */\n    if (ctx->parent) {\n        allow_proxy_certs = 0;\n        purpose = X509_PURPOSE_CRL_SIGN;\n    } else {\n        allow_proxy_certs =\n            ! !(ctx->param->flags & X509_V_FLAG_ALLOW_PROXY_CERTS);\n        purpose = ctx->param->purpose;\n    }\n\n    for (i = 0; i < num; i++) {\n        int ret;\n        x = sk_X509_value(ctx->chain, i);\n        if (!(ctx->param->flags & X509_V_FLAG_IGNORE_CRITICAL)\n            && (x->ex_flags & EXFLAG_CRITICAL)) {\n            if (!verify_cb_cert(ctx, x, i,\n                                X509_V_ERR_UNHANDLED_CRITICAL_EXTENSION))\n                return 0;\n        }\n        if (!allow_proxy_certs && (x->ex_flags & EXFLAG_PROXY)) {\n            if (!verify_cb_cert(ctx, x, i,\n                                X509_V_ERR_PROXY_CERTIFICATES_NOT_ALLOWED))\n                return 0;\n        }\n        ret = X509_check_ca(x);\n        switch (must_be_ca) {\n        case -1:\n            if ((ctx->param->flags & X509_V_FLAG_X509_STRICT)\n                && (ret != 1) && (ret != 0)) {\n                ret = 0;\n                ctx->error = X509_V_ERR_INVALID_CA;\n            } else\n                ret = 1;\n            break;\n        case 0:\n            if (ret != 0) {\n                ret = 0;\n                ctx->error = X509_V_ERR_INVALID_NON_CA;\n            } else\n                ret = 1;\n            break;\n        default:\n            /* X509_V_FLAG_X509_STRICT is implicit for intermediate CAs */\n            if ((ret == 0)\n                || ((i + 1 < num || ctx->param->flags & X509_V_FLAG_X509_STRICT)\n                    && (ret != 1))) {\n                ret = 0;\n                ctx->error = X509_V_ERR_INVALID_CA;\n            } else\n                ret = 1;\n            break;\n        }\n        if (ret > 0\n            && (ctx->param->flags & X509_V_FLAG_X509_STRICT) && num > 1) {\n            /* Check for presence of explicit elliptic curve parameters */\n            ret = check_curve(x);\n            if (ret < 0) {\n                ctx->error = X509_V_ERR_UNSPECIFIED;\n                ret = 0;\n            } else if (ret == 0) {\n                ctx->error = X509_V_ERR_EC_KEY_EXPLICIT_PARAMS;\n            }\n        }\n        if (ret > 0\n            && (x->ex_flags & EXFLAG_CA) == 0\n            && x->ex_pathlen != -1\n            && (ctx->param->flags & X509_V_FLAG_X509_STRICT)) {\n            ctx->error = X509_V_ERR_INVALID_EXTENSION;\n            ret = 0;\n        }\n        if (ret == 0 && !verify_cb_cert(ctx, x, i, X509_V_OK))\n            return 0;\n        /* check_purpose() makes the callback as needed */\n        if (purpose > 0 && !check_purpose(ctx, x, purpose, i, must_be_ca))\n            return 0;\n        /* Check pathlen */\n        if ((i > 1) && (x->ex_pathlen != -1)\n            && (plen > (x->ex_pathlen + proxy_path_length))) {\n            if (!verify_cb_cert(ctx, x, i, X509_V_ERR_PATH_LENGTH_EXCEEDED))\n                return 0;\n        }\n        /* Increment path length if not a self issued intermediate CA */\n        if (i > 0 && (x->ex_flags & EXFLAG_SI) == 0)\n            plen++;\n        /*\n         * If this certificate is a proxy certificate, the next certificate\n         * must be another proxy certificate or a EE certificate.  If not,\n         * the next certificate must be a CA certificate.\n         */\n        if (x->ex_flags & EXFLAG_PROXY) {\n            /*\n             * RFC3820, 4.1.3 (b)(1) stipulates that if pCPathLengthConstraint\n             * is less than max_path_length, the former should be copied to\n             * the latter, and 4.1.4 (a) stipulates that max_path_length\n             * should be verified to be larger than zero and decrement it.\n             *\n             * Because we're checking the certs in the reverse order, we start\n             * with verifying that proxy_path_length isn't larger than pcPLC,\n             * and copy the latter to the former if it is, and finally,\n             * increment proxy_path_length.\n             */\n            if (x->ex_pcpathlen != -1) {\n                if (proxy_path_length > x->ex_pcpathlen) {\n                    if (!verify_cb_cert(ctx, x, i,\n                                        X509_V_ERR_PROXY_PATH_LENGTH_EXCEEDED))\n                        return 0;\n                }\n                proxy_path_length = x->ex_pcpathlen;\n            }\n            proxy_path_length++;\n            must_be_ca = 0;\n        } else\n            must_be_ca = 1;\n    }\n    return 1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -70,15 +70,19 @@\n                 ret = 1;\n             break;\n         }\n-        if ((ctx->param->flags & X509_V_FLAG_X509_STRICT) && num > 1) {\n+        if (ret > 0\n+            && (ctx->param->flags & X509_V_FLAG_X509_STRICT) && num > 1) {\n             /* Check for presence of explicit elliptic curve parameters */\n             ret = check_curve(x);\n-            if (ret < 0)\n+            if (ret < 0) {\n                 ctx->error = X509_V_ERR_UNSPECIFIED;\n-            else if (ret == 0)\n+                ret = 0;\n+            } else if (ret == 0) {\n                 ctx->error = X509_V_ERR_EC_KEY_EXPLICIT_PARAMS;\n+            }\n         }\n-        if ((x->ex_flags & EXFLAG_CA) == 0\n+        if (ret > 0\n+            && (x->ex_flags & EXFLAG_CA) == 0\n             && x->ex_pathlen != -1\n             && (ctx->param->flags & X509_V_FLAG_X509_STRICT)) {\n             ctx->error = X509_V_ERR_INVALID_EXTENSION;",
        "diff_line_info": {
            "deleted_lines": [
                "        if ((ctx->param->flags & X509_V_FLAG_X509_STRICT) && num > 1) {",
                "            if (ret < 0)",
                "            else if (ret == 0)",
                "        if ((x->ex_flags & EXFLAG_CA) == 0"
            ],
            "added_lines": [
                "        if (ret > 0",
                "            && (ctx->param->flags & X509_V_FLAG_X509_STRICT) && num > 1) {",
                "            if (ret < 0) {",
                "                ret = 0;",
                "            } else if (ret == 0) {",
                "            }",
                "        if (ret > 0",
                "            && (x->ex_flags & EXFLAG_CA) == 0"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-8970",
        "func_name": "libressl/openbsd/int_x509_param_set_hosts",
        "description": "The int_x509_param_set_hosts function in lib/libcrypto/x509/x509_vpm.c in LibreSSL 2.7.0 before 2.7.1 does not support a certain special case of a zero name length, which causes silent omission of hostname verification, and consequently allows man-in-the-middle attackers to spoof servers and obtain sensitive information via a crafted certificate. NOTE: the LibreSSL documentation indicates that this special case is supported, but the BoringSSL documentation does not.",
        "git_url": "https://github.com/libressl/openbsd/commit/0654414afcce51a16d35d05060190a3ec4618d42",
        "commit_title": "Call strlen() if name length provided is 0, like OpenSSL does.",
        "commit_text": "Issue notice by Christian Heimes <christian@python.org> ok deraadt@ jsing@",
        "func_before": "static int\nint_x509_param_set_hosts(X509_VERIFY_PARAM_ID *id, int mode,\n    const char *name, size_t namelen)\n{\n\tchar *copy;\n\n\t/*\n\t * Refuse names with embedded NUL bytes.\n\t * XXX: Do we need to push an error onto the error stack?\n\t */\n\tif (name && memchr(name, '\\0', namelen))\n\t\treturn 0;\n\n\tif (mode == SET_HOST && id->hosts) {\n\t\tstring_stack_free(id->hosts);\n\t\tid->hosts = NULL;\n\t}\n\tif (name == NULL || namelen == 0)\n\t\treturn 1;\n\tcopy = strndup(name, namelen);\n\tif (copy == NULL)\n\t\treturn 0;\n\n\tif (id->hosts == NULL &&\n\t    (id->hosts = sk_OPENSSL_STRING_new_null()) == NULL) {\n\t\tfree(copy);\n\t\treturn 0;\n\t}\n\n\tif (!sk_OPENSSL_STRING_push(id->hosts, copy)) {\n\t\tfree(copy);\n\t\tif (sk_OPENSSL_STRING_num(id->hosts) == 0) {\n\t\t\tsk_OPENSSL_STRING_free(id->hosts);\n\t\t\tid->hosts = NULL;\n\t\t}\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}",
        "func": "static int\nint_x509_param_set_hosts(X509_VERIFY_PARAM_ID *id, int mode,\n    const char *name, size_t namelen)\n{\n\tchar *copy;\n\n\tif (name != NULL && namelen == 0)\n\t\tnamelen = strlen(name);\n\t/*\n\t * Refuse names with embedded NUL bytes.\n\t * XXX: Do we need to push an error onto the error stack?\n\t */\n\tif (name && memchr(name, '\\0', namelen))\n\t\treturn 0;\n\n\tif (mode == SET_HOST && id->hosts) {\n\t\tstring_stack_free(id->hosts);\n\t\tid->hosts = NULL;\n\t}\n\tif (name == NULL || namelen == 0)\n\t\treturn 1;\n\tcopy = strndup(name, namelen);\n\tif (copy == NULL)\n\t\treturn 0;\n\n\tif (id->hosts == NULL &&\n\t    (id->hosts = sk_OPENSSL_STRING_new_null()) == NULL) {\n\t\tfree(copy);\n\t\treturn 0;\n\t}\n\n\tif (!sk_OPENSSL_STRING_push(id->hosts, copy)) {\n\t\tfree(copy);\n\t\tif (sk_OPENSSL_STRING_num(id->hosts) == 0) {\n\t\t\tsk_OPENSSL_STRING_free(id->hosts);\n\t\t\tid->hosts = NULL;\n\t\t}\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,6 +4,8 @@\n {\n \tchar *copy;\n \n+\tif (name != NULL && namelen == 0)\n+\t\tnamelen = strlen(name);\n \t/*\n \t * Refuse names with embedded NUL bytes.\n \t * XXX: Do we need to push an error onto the error stack?",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tif (name != NULL && namelen == 0)",
                "\t\tnamelen = strlen(name);"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-10059",
        "func_name": "zephyrproject-rtos/zephyr/start_coap_client",
        "description": "The UpdateHub module disables DTLS peer checking, which allows for a man in the middle attack. This is mitigated by firmware images requiring valid signatures. However, there is no benefit to using DTLS without the peer checking. See NCC-ZEP-018 This issue affects: zephyrproject-rtos zephyr version 2.1.0 and later versions.",
        "git_url": "https://github.com/zephyrproject-rtos/zephyr/commit/e79336c896ff4fe51217d9ffd82b22fca8459919",
        "commit_title": "updatehub: Require peer verification with DTLS",
        "commit_text": " DTLS without peer verification offers no security whatsoever (and is arguably worse than not using DTLS in the first place).  Change the verification option to require this peer verification.  To use this, it may be necessary to install and use a root certificate. ",
        "func_before": "static bool start_coap_client(void)\n{\n\tstruct addrinfo *addr;\n\tstruct addrinfo hints;\n\tint resolve_attempts = 10;\n\tint ret = -1;\n\n\tif (IS_ENABLED(CONFIG_NET_IPV6)) {\n\t\thints.ai_family = AF_INET6;\n\t\thints.ai_socktype = SOCK_STREAM;\n\t} else if (IS_ENABLED(CONFIG_NET_IPV4)) {\n\t\thints.ai_family = AF_INET;\n\t\thints.ai_socktype = SOCK_STREAM;\n\t}\n\n#if defined(CONFIG_UPDATEHUB_DTLS)\n\tint verify = TLS_PEER_VERIFY_NONE;\n\tsec_tag_t sec_list[] = { CA_CERTIFICATE_TAG };\n\tint protocol = IPPROTO_DTLS_1_2;\n\tchar port[] = \"5684\";\n#else\n\tint protocol = IPPROTO_UDP;\n\tchar port[] = \"5683\";\n#endif\n\n\twhile (resolve_attempts--) {\n\t\tret = getaddrinfo(UPDATEHUB_SERVER, port, &hints, &addr);\n\t\tif (ret == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tk_sleep(K_SECONDS(1));\n\t}\n\tif (ret < 0) {\n\t\tLOG_ERR(\"Could not resolve dns\");\n\t\treturn false;\n\t}\n\n\tctx.sock = socket(addr->ai_family, SOCK_DGRAM, protocol);\n\tif (ctx.sock < 0) {\n\t\tLOG_ERR(\"Failed to create UDP socket\");\n\t\treturn false;\n\t}\n\n#if defined(CONFIG_UPDATEHUB_DTLS)\n\tif (setsockopt(ctx.sock, SOL_TLS, TLS_SEC_TAG_LIST,\n\t\t       sec_list, sizeof(sec_list)) < 0) {\n\t\tLOG_ERR(\"Failed to set TLS_TAG option\");\n\t\treturn false;\n\t}\n\n\tif (setsockopt(ctx.sock, SOL_TLS, TLS_PEER_VERIFY, &verify, sizeof(int)) < 0) {\n\t\tLOG_ERR(\"Failed to set TLS_PEER_VERIFY option\");\n\t\treturn false;\n\t}\n#endif\n\n\tif (connect(ctx.sock, addr->ai_addr, addr->ai_addrlen) < 0) {\n\t\tLOG_ERR(\"Cannot connect to UDP remote\");\n\t\treturn false;\n\t}\n\n\tprepare_fds();\n\n\treturn true;\n}",
        "func": "static bool start_coap_client(void)\n{\n\tstruct addrinfo *addr;\n\tstruct addrinfo hints;\n\tint resolve_attempts = 10;\n\tint ret = -1;\n\n\tif (IS_ENABLED(CONFIG_NET_IPV6)) {\n\t\thints.ai_family = AF_INET6;\n\t\thints.ai_socktype = SOCK_STREAM;\n\t} else if (IS_ENABLED(CONFIG_NET_IPV4)) {\n\t\thints.ai_family = AF_INET;\n\t\thints.ai_socktype = SOCK_STREAM;\n\t}\n\n#if defined(CONFIG_UPDATEHUB_DTLS)\n\tint verify = TLS_PEER_VERIFY_REQUIRED;\n\tsec_tag_t sec_list[] = { CA_CERTIFICATE_TAG };\n\tint protocol = IPPROTO_DTLS_1_2;\n\tchar port[] = \"5684\";\n#else\n\tint protocol = IPPROTO_UDP;\n\tchar port[] = \"5683\";\n#endif\n\n\twhile (resolve_attempts--) {\n\t\tret = getaddrinfo(UPDATEHUB_SERVER, port, &hints, &addr);\n\t\tif (ret == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tk_sleep(K_SECONDS(1));\n\t}\n\tif (ret < 0) {\n\t\tLOG_ERR(\"Could not resolve dns\");\n\t\treturn false;\n\t}\n\n\tctx.sock = socket(addr->ai_family, SOCK_DGRAM, protocol);\n\tif (ctx.sock < 0) {\n\t\tLOG_ERR(\"Failed to create UDP socket\");\n\t\treturn false;\n\t}\n\n#if defined(CONFIG_UPDATEHUB_DTLS)\n\tif (setsockopt(ctx.sock, SOL_TLS, TLS_SEC_TAG_LIST,\n\t\t       sec_list, sizeof(sec_list)) < 0) {\n\t\tLOG_ERR(\"Failed to set TLS_TAG option\");\n\t\treturn false;\n\t}\n\n\tif (setsockopt(ctx.sock, SOL_TLS, TLS_PEER_VERIFY, &verify, sizeof(int)) < 0) {\n\t\tLOG_ERR(\"Failed to set TLS_PEER_VERIFY option\");\n\t\treturn false;\n\t}\n#endif\n\n\tif (connect(ctx.sock, addr->ai_addr, addr->ai_addrlen) < 0) {\n\t\tLOG_ERR(\"Cannot connect to UDP remote\");\n\t\treturn false;\n\t}\n\n\tprepare_fds();\n\n\treturn true;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -14,7 +14,7 @@\n \t}\n \n #if defined(CONFIG_UPDATEHUB_DTLS)\n-\tint verify = TLS_PEER_VERIFY_NONE;\n+\tint verify = TLS_PEER_VERIFY_REQUIRED;\n \tsec_tag_t sec_list[] = { CA_CERTIFICATE_TAG };\n \tint protocol = IPPROTO_DTLS_1_2;\n \tchar port[] = \"5684\";",
        "diff_line_info": {
            "deleted_lines": [
                "\tint verify = TLS_PEER_VERIFY_NONE;"
            ],
            "added_lines": [
                "\tint verify = TLS_PEER_VERIFY_REQUIRED;"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-13614",
        "func_name": "axel-download-accelerator/axel/ssl_connect",
        "description": "An issue was discovered in ssl.c in Axel before 2.17.8. The TLS implementation lacks hostname verification.",
        "git_url": "https://github.com/axel-download-accelerator/axel/commit/961cf5408baf17944edab2bf771afb90471c4262",
        "commit_title": "SSL: Add hostname verification",
        "commit_text": " Add iSEC Partners hostname validation strategy.  This should support OpenSSL 1.1.0 and 0.9.8. ",
        "func_before": "SSL *\nssl_connect(int fd, char *hostname)\n{\n\n\tSSL_CTX *ssl_ctx;\n\tSSL *ssl;\n\n\tssl_startup();\n\n\tssl_ctx = SSL_CTX_new(SSLv23_client_method());\n\tif (!conf->insecure) {\n\t\tSSL_CTX_set_default_verify_paths(ssl_ctx);\n\t\tSSL_CTX_set_verify(ssl_ctx, SSL_VERIFY_PEER, NULL);\n\t}\n\tSSL_CTX_set_mode(ssl_ctx, SSL_MODE_AUTO_RETRY);\n\n\tssl = SSL_new(ssl_ctx);\n\tSSL_set_fd(ssl, fd);\n\tSSL_set_tlsext_host_name(ssl, hostname);\n\n\tint err = SSL_connect(ssl);\n\tif (err <= 0) {\n\t\tfprintf(stderr, _(\"SSL error: %s\\n\"),\n\t\t\tERR_reason_error_string(ERR_get_error()));\n\t\treturn NULL;\n\t}\n\n\treturn ssl;\n}",
        "func": "SSL *\nssl_connect(int fd, char *hostname)\n{\n\tX509 *server_cert;\n\tSSL_CTX *ssl_ctx;\n\tSSL *ssl;\n\n\tssl_startup();\n\n\tssl_ctx = SSL_CTX_new(SSLv23_client_method());\n\tif (!conf->insecure) {\n\t\tSSL_CTX_set_default_verify_paths(ssl_ctx);\n\t\tSSL_CTX_set_verify(ssl_ctx, SSL_VERIFY_PEER, NULL);\n\t}\n\tSSL_CTX_set_mode(ssl_ctx, SSL_MODE_AUTO_RETRY);\n\n\tssl = SSL_new(ssl_ctx);\n\tSSL_set_fd(ssl, fd);\n\tSSL_set_tlsext_host_name(ssl, hostname);\n\n\tint err = SSL_connect(ssl);\n\tif (err <= 0) {\n\t\tfprintf(stderr, _(\"SSL error: %s\\n\"),\n\t\t\tERR_reason_error_string(ERR_get_error()));\n\t\tSSL_CTX_free(ssl_ctx);\n\t\treturn NULL;\n\t}\n\n\terr = SSL_get_verify_result(ssl);\n\tif (err != X509_V_OK) {\n\t\tfprintf(stderr, _(\"SSL error: Certificate error\"));\n\t\tSSL_CTX_free(ssl_ctx);\n\t\treturn NULL;\n\t}\n\n\tserver_cert =  SSL_get_peer_certificate(ssl);\n\tif (server_cert == NULL) {\n\t\tfprintf(stderr, _(\"SSL error: Certificate not found\"));\n\t\tSSL_CTX_free(ssl_ctx);\n\t\treturn NULL;\n\t}\n\n\tif (!ssl_validate_hostname(hostname, server_cert)) {\n\t\tfprintf(stderr, _(\"SSL error: Hostname verification failed\"));\n\t\tX509_free(server_cert);\n\t\tSSL_CTX_free(ssl_ctx);\n\t\treturn NULL;\n\t}\n\n\tX509_free(server_cert);\n\n\treturn ssl;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,7 +1,7 @@\n SSL *\n ssl_connect(int fd, char *hostname)\n {\n-\n+\tX509 *server_cert;\n \tSSL_CTX *ssl_ctx;\n \tSSL *ssl;\n \n@@ -22,8 +22,32 @@\n \tif (err <= 0) {\n \t\tfprintf(stderr, _(\"SSL error: %s\\n\"),\n \t\t\tERR_reason_error_string(ERR_get_error()));\n+\t\tSSL_CTX_free(ssl_ctx);\n \t\treturn NULL;\n \t}\n \n+\terr = SSL_get_verify_result(ssl);\n+\tif (err != X509_V_OK) {\n+\t\tfprintf(stderr, _(\"SSL error: Certificate error\"));\n+\t\tSSL_CTX_free(ssl_ctx);\n+\t\treturn NULL;\n+\t}\n+\n+\tserver_cert =  SSL_get_peer_certificate(ssl);\n+\tif (server_cert == NULL) {\n+\t\tfprintf(stderr, _(\"SSL error: Certificate not found\"));\n+\t\tSSL_CTX_free(ssl_ctx);\n+\t\treturn NULL;\n+\t}\n+\n+\tif (!ssl_validate_hostname(hostname, server_cert)) {\n+\t\tfprintf(stderr, _(\"SSL error: Hostname verification failed\"));\n+\t\tX509_free(server_cert);\n+\t\tSSL_CTX_free(ssl_ctx);\n+\t\treturn NULL;\n+\t}\n+\n+\tX509_free(server_cert);\n+\n \treturn ssl;\n }",
        "diff_line_info": {
            "deleted_lines": [
                ""
            ],
            "added_lines": [
                "\tX509 *server_cert;",
                "\t\tSSL_CTX_free(ssl_ctx);",
                "\terr = SSL_get_verify_result(ssl);",
                "\tif (err != X509_V_OK) {",
                "\t\tfprintf(stderr, _(\"SSL error: Certificate error\"));",
                "\t\tSSL_CTX_free(ssl_ctx);",
                "\t\treturn NULL;",
                "\t}",
                "",
                "\tserver_cert =  SSL_get_peer_certificate(ssl);",
                "\tif (server_cert == NULL) {",
                "\t\tfprintf(stderr, _(\"SSL error: Certificate not found\"));",
                "\t\tSSL_CTX_free(ssl_ctx);",
                "\t\treturn NULL;",
                "\t}",
                "",
                "\tif (!ssl_validate_hostname(hostname, server_cert)) {",
                "\t\tfprintf(stderr, _(\"SSL error: Hostname verification failed\"));",
                "\t\tX509_free(server_cert);",
                "\t\tSSL_CTX_free(ssl_ctx);",
                "\t\treturn NULL;",
                "\t}",
                "",
                "\tX509_free(server_cert);",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2020-13645",
        "func_name": "GNOME/glib-networking/verify_peer_certificate",
        "description": "In GNOME glib-networking through 2.64.2, the implementation of GTlsClientConnection skips hostname verification of the server's TLS certificate if the application fails to specify the expected server identity. This is in contrast to its intended documented behavior, to fail the certificate verification. Applications that fail to provide the server identity, including Balsa before 2.5.11 and 2.6.x before 2.6.1, accept a TLS certificate if the certificate is valid for any host.",
        "git_url": "https://github.com/GNOME/glib-networking/commit/dbc8d69f58b07f6ed091aa123e5d40a53573a5fc",
        "commit_title": "Return bad identity error if identity is unset",
        "commit_text": " When the server-identity property of GTlsClientConnection is unset, the documentation sasy we need to fail the certificate verification with G_TLS_CERTIFICATE_BAD_IDENTITY. This is important because otherwise, it's easy for applications to fail to specify server identity.  Unfortunately, we did not correctly implement the intended, documented behavior. When server identity is missing, we check the validity of the TLS certificate, but do not check if it corresponds to the expected server (since we have no expected server). Then we assume the identity is good, instead of returning bad identity, as documented. This means, for example, that evil.com can present a valid certificate issued to evil.com, and we would happily accept it for paypal.com.  Fixes #135",
        "func_before": "static GTlsCertificateFlags\nverify_peer_certificate (GTlsConnectionBase *tls,\n                         GTlsCertificate    *peer_certificate)\n{\n  GSocketConnectable *peer_identity;\n  GTlsDatabase *database;\n  GTlsCertificateFlags errors;\n  gboolean is_client;\n\n  is_client = G_IS_TLS_CLIENT_CONNECTION (tls);\n\n  if (!is_client)\n    peer_identity = NULL;\n  else if (!g_tls_connection_base_is_dtls (tls))\n    peer_identity = g_tls_client_connection_get_server_identity (G_TLS_CLIENT_CONNECTION (tls));\n  else\n    peer_identity = g_dtls_client_connection_get_server_identity (G_DTLS_CLIENT_CONNECTION (tls));\n\n  errors = 0;\n\n  database = g_tls_connection_get_database (G_TLS_CONNECTION (tls));\n  if (!database)\n    {\n      errors |= G_TLS_CERTIFICATE_UNKNOWN_CA;\n      errors |= g_tls_certificate_verify (peer_certificate, peer_identity, NULL);\n    }\n  else\n    {\n      GError *error = NULL;\n\n      errors |= g_tls_database_verify_chain (database, peer_certificate,\n                                             is_client ?\n                                             G_TLS_DATABASE_PURPOSE_AUTHENTICATE_SERVER :\n                                             G_TLS_DATABASE_PURPOSE_AUTHENTICATE_CLIENT,\n                                             peer_identity,\n                                             g_tls_connection_get_interaction (G_TLS_CONNECTION (tls)),\n                                             G_TLS_DATABASE_VERIFY_NONE,\n                                             NULL, &error);\n      if (error)\n        {\n          g_tls_log_debug (tls, \"failure verifying certificate chain: %s\", error->message);\n          g_assert (errors != 0);\n          g_clear_error (&error);\n        }\n    }\n\n  return errors;\n}",
        "func": "static GTlsCertificateFlags\nverify_peer_certificate (GTlsConnectionBase *tls,\n                         GTlsCertificate    *peer_certificate)\n{\n  GSocketConnectable *peer_identity = NULL;\n  GTlsDatabase *database;\n  GTlsCertificateFlags errors = 0;\n  gboolean is_client;\n\n  is_client = G_IS_TLS_CLIENT_CONNECTION (tls);\n\n  if (is_client)\n    {\n      if (!g_tls_connection_base_is_dtls (tls))\n        peer_identity = g_tls_client_connection_get_server_identity (G_TLS_CLIENT_CONNECTION (tls));\n      else\n        peer_identity = g_dtls_client_connection_get_server_identity (G_DTLS_CLIENT_CONNECTION (tls));\n\n      if (!peer_identity)\n        errors |= G_TLS_CERTIFICATE_BAD_IDENTITY;\n    }\n\n  database = g_tls_connection_get_database (G_TLS_CONNECTION (tls));\n  if (!database)\n    {\n      errors |= G_TLS_CERTIFICATE_UNKNOWN_CA;\n      errors |= g_tls_certificate_verify (peer_certificate, peer_identity, NULL);\n    }\n  else\n    {\n      GError *error = NULL;\n\n      errors |= g_tls_database_verify_chain (database, peer_certificate,\n                                             is_client ?\n                                             G_TLS_DATABASE_PURPOSE_AUTHENTICATE_SERVER :\n                                             G_TLS_DATABASE_PURPOSE_AUTHENTICATE_CLIENT,\n                                             peer_identity,\n                                             g_tls_connection_get_interaction (G_TLS_CONNECTION (tls)),\n                                             G_TLS_DATABASE_VERIFY_NONE,\n                                             NULL, &error);\n      if (error)\n        {\n          g_tls_log_debug (tls, \"failure verifying certificate chain: %s\", error->message);\n          g_assert (errors != 0);\n          g_clear_error (&error);\n        }\n    }\n\n  return errors;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,21 +2,23 @@\n verify_peer_certificate (GTlsConnectionBase *tls,\n                          GTlsCertificate    *peer_certificate)\n {\n-  GSocketConnectable *peer_identity;\n+  GSocketConnectable *peer_identity = NULL;\n   GTlsDatabase *database;\n-  GTlsCertificateFlags errors;\n+  GTlsCertificateFlags errors = 0;\n   gboolean is_client;\n \n   is_client = G_IS_TLS_CLIENT_CONNECTION (tls);\n \n-  if (!is_client)\n-    peer_identity = NULL;\n-  else if (!g_tls_connection_base_is_dtls (tls))\n-    peer_identity = g_tls_client_connection_get_server_identity (G_TLS_CLIENT_CONNECTION (tls));\n-  else\n-    peer_identity = g_dtls_client_connection_get_server_identity (G_DTLS_CLIENT_CONNECTION (tls));\n+  if (is_client)\n+    {\n+      if (!g_tls_connection_base_is_dtls (tls))\n+        peer_identity = g_tls_client_connection_get_server_identity (G_TLS_CLIENT_CONNECTION (tls));\n+      else\n+        peer_identity = g_dtls_client_connection_get_server_identity (G_DTLS_CLIENT_CONNECTION (tls));\n \n-  errors = 0;\n+      if (!peer_identity)\n+        errors |= G_TLS_CERTIFICATE_BAD_IDENTITY;\n+    }\n \n   database = g_tls_connection_get_database (G_TLS_CONNECTION (tls));\n   if (!database)",
        "diff_line_info": {
            "deleted_lines": [
                "  GSocketConnectable *peer_identity;",
                "  GTlsCertificateFlags errors;",
                "  if (!is_client)",
                "    peer_identity = NULL;",
                "  else if (!g_tls_connection_base_is_dtls (tls))",
                "    peer_identity = g_tls_client_connection_get_server_identity (G_TLS_CLIENT_CONNECTION (tls));",
                "  else",
                "    peer_identity = g_dtls_client_connection_get_server_identity (G_DTLS_CLIENT_CONNECTION (tls));",
                "  errors = 0;"
            ],
            "added_lines": [
                "  GSocketConnectable *peer_identity = NULL;",
                "  GTlsCertificateFlags errors = 0;",
                "  if (is_client)",
                "    {",
                "      if (!g_tls_connection_base_is_dtls (tls))",
                "        peer_identity = g_tls_client_connection_get_server_identity (G_TLS_CLIENT_CONNECTION (tls));",
                "      else",
                "        peer_identity = g_dtls_client_connection_get_server_identity (G_DTLS_CLIENT_CONNECTION (tls));",
                "      if (!peer_identity)",
                "        errors |= G_TLS_CERTIFICATE_BAD_IDENTITY;",
                "    }"
            ]
        }
    }
]