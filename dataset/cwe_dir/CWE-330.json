[
    {
        "cve_id": "CVE-2022-34295",
        "func_name": "fwdillema/totd/read_config",
        "description": "totd before 1.5.3 does not properly randomize mesg IDs.",
        "git_url": "https://github.com/fwdillema/totd/commit/afd8a10a6a21f82a70940d1b43cff48143250399",
        "commit_title": "Patch provided by Gabor Lencse for generating better randomized mesg IDs.",
        "commit_text": "",
        "func_before": "int read_config (char *config_file) {\n\tchar buf[512];\n\tchar *cp;\n\tFILE *config_fp;\n\tchar *args[MAXARGS];\n\tint argcnt, errcnt, linenum;\n\n\tif (T.debug > 0)\n\t\tsyslog (LOG_DEBUG, \"config file: %s\", config_file);\n\n\tconfig_fp = fopen (config_file, \"r\");\n\tif (!config_fp) {\n\t\tsyslog (LOG_ERR, \"can't open config file: %s\", config_file);\n\t\treturn -1;\n\t}\n\tlinenum = errcnt = 0;\n\twhile (fgets (buf, sizeof (buf), config_fp)) {\n\t\tlinenum++;\n\n\t\tcp = strchr (buf, '\\n');\n\t\tif (cp)\n\t\t\t*cp = '\\0';\n\t\tcp = strchr (buf, '\\n');\n\t\tif (cp)\n\t\t\t*cp = '\\0';\n\t\tcp = strchr (buf, '#'); /* strip comment */\n\t\tif (cp)\n\t\t\t*cp = '\\0';\n\t\tcp = strchr (buf, ';'); /* strip comment */\n\t\tif (cp)\n\t\t\t*cp = '\\0';\n\n\t\t/* parse config line in words */\n\t\targs[argcnt = 0] = strtok (buf, \" \\t\");\n\t\twhile (args[argcnt] && ++argcnt < MAXARGS)\n\t\t\targs[argcnt] = strtok (NULL, \" \\t\");\n\n\t\tif (!args[0]) /* empty line (or only comment) */\n\t\t\tcontinue;\n\n\t\tif (!strcasecmp (args[0], \"forwarder\")) {\n\t\t\tif (argcnt < 2 || argcnt > 4 ) {\n\t\t\t\tsyslog (LOG_ERR, \"line %d: invalid format: forwarder <IPaddr> [port <port>]\", linenum);\n\t\t\t\terrcnt++;\n\t\t\t} else {\n\t\t\t\tint port = PORT_TO, i;\n\n\t\t\t\ti = 2;\n\t\t\t\tif (argcnt > i) {\n\t\t\t\t\tif (!strcasecmp (args[i], \"port\")) {\n\t\t\t\t\t\tif (argcnt >= ++i) {\n\t\t\t\t\t\t\tport = atoi (args[i++]);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tsyslog (LOG_ERR, \"line %d: invalid format, missing <port> after port attribute\", linenum);\n\t\t\t\t\t\t\terrcnt++;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsyslog (LOG_ERR, \"line %d: invalid format, cannot parse unknown attribute: %s\", linenum, args[i]);\n\t\t\t\t\t\terrcnt++;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\t\n\t\t\t\t}\n\t\t\t\tif (fwd_add (args[1], port) == -1)\n\t\t\t\t\treturn -1; /* serious trouble */\n\t\t\t}\n\t\t} else if (!strcasecmp (args[0], \"prefix\")) {\n\t\t\tif (argcnt != 2) {\n\t\t\t\tsyslog (LOG_ERR, \"line %d: invalid format: prefix <IPv6prefix>\", linenum);\n\t\t\t\terrcnt++;\n\t\t\t} else {\n\t\t\t\tif (conv_trick_conf ((u_char *)args[1])) {\n\t\t\t\t\tsyslog (LOG_INFO, \"can not add prefix %d: %s\", T.prefixnum, args[1]);\n\t\t\t\t\terrcnt++;\n\t\t\t\t} else\n\t\t\t\t\tsyslog (LOG_INFO, \"prefix %d added: %s\", T.prefixnum, args[1]);\n\t\t\t}\n\t\t} else if (!strcasecmp (args[0], \"allow\")) {\n\t\t\tif (argcnt != 2) {\n\t\t\t\tsyslog (LOG_ERR, \"line %d: invalid format: allow <IP address>\", linenum);\n\t\t\t\terrcnt++;\n\t\t\t} else {\n#ifdef SWILL\n\t\t\t\tif (T.http_port) {\n\t\t\t\t\tswill_allow(args[1]);\n\t\t\t\t\tsyslog (LOG_INFO, \"allow http connects from %s\", args[1]);\n\t\t\t\t} else\n#endif\n\t\t\t\t\tsyslog (LOG_INFO, \"NOTE: http support not enabled!!!\");\n\t\t\t}\n\t\t} else if (!strcasecmp (args[0], \"retry\")) {\n\t\t\tif (argcnt != 2) {\n\t\t\t\tsyslog (LOG_ERR, \"line %d: invalid format: retry <seconds>\", linenum);\n\t\t\t\terrcnt++;\n\t\t\t} else {\n\t\t\t\tT.retry_interval = atoi(args[1]);\n\t\t\t}\n\t\t} else if (!strcasecmp (args[0], \"pidfile\")) {\n\t\t\tif (argcnt != 2) {\n\t\t\t\tsyslog (LOG_ERR, \"line %d: invalid format: pidfile <filename>\", linenum);\n\t\t\t\terrcnt++;\n\t\t\t} else {\n\t\t\t\tT.pidfile = strdup(args[1]);\n\t\t\t}\n\t\t} else if (!strcasecmp (args[0], \"interfaces\")) {\n\t\t\tint i;\n\n\t\t\tif (argcnt < 2) {\n\t\t\t\tsyslog (LOG_ERR, \"line %d: invalid format: interfaces <ifa> <ifb> ...\", linenum);\n\t\t\t\terrcnt++;\n\t\t\t}\n\n\t\t\tfor (i = 0; T.iflist[i] && i < MAXINTERFACES; i++);\n\n\t\t \tif (i + argcnt-1 > MAXINTERFACES) {\n\t\t\t\tsyslog (LOG_ERR, \"line %d: to many interfaces, more than %d\", linenum, MAXINTERFACES);\n\t\t\t\terrcnt++;\n\t\t\t} else {\n\t\t\t\tsyslog (LOG_DEBUG, \"line %d: %d interfaces listed, no wildcard socket\", linenum, argcnt-1);\n\n\t\t\t\tT.iflist[i + argcnt--] = NULL;\n\t\t\t\twhile (argcnt) {\n\t\t\t\t\tif (!strcmp(args[argcnt], \"*\")) {\n\t\t\t\t\t\t/* wildcard interface, ignore other ifn */\n\t\t\t\t\t\tT.iflist[0] = NULL;\n\t\t\t\t\t\tT.wildcard = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tT.iflist[i+argcnt-1] = strdup(args[argcnt]);\n\t\t\t\t\targcnt--;\n\t\t\t\t}\n\t\t\t\tif (T.iflist[0])\n\t\t\t\t\tT.wildcard = 0;\n\t\t\t}\n\t\t} else if (!strcasecmp (args[0], \"port\")) {\n\t\t\tif (argcnt != 2) {\n\t\t\t\tsyslog (LOG_ERR, \"line %d: invalid format: port <portnum>\", linenum);\n\t\t\t\terrcnt++;\n\t\t\t} else {\n\t\t\t\tT.port = atoi(args[1]);\n\t\t\t}\n\t\t}\n#ifdef SCOPED_REWRITE\n\t\telse if (!strcasecmp(args[0], \"scoped\")) {\n\t\t\tif (argcnt != 4) {\n\t\t\t\tsyslog (LOG_ERR, \"line %d: invalid format: scoped <from> <to> <plen>\", linenum);\n\t\t\t\terrcnt++;\n\t\t\t} else {\n\t\t\t\tif (conv_scoped_conf(args[1], args[2], atoi(args[3]))) {\n\t\t\t\t\tsyslog (LOG_INFO, \"can not add scoped %d: %s %s %s\",\n\t\t\t\t\t\tT.scoped_prefixes, args[1], args[2], args[3]);\n\t\t\t\t\terrcnt++;\n\t\t\t\t} else {\n\t\t\t\t\tsyslog(LOG_INFO, \"scoped %d added: %s %s %d\", \n\t\t\t\t\t\tT.scoped_prefixes, args[1], args[2], atoi(args[3]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n#endif\n#ifdef STF\n\t\telse if  (!strcasecmp(args[0], \"stf\")) {\n\t\t\tif (argcnt != 1) {\n\t\t\t\tsyslog (LOG_ERR, \"line %d: invalid format: stf\", linenum);\n\t\t\t\terrcnt++;\n\t\t\t} else {\n\t\t\t\tT.stf = 1;\n\t\t\t}\n\t\t}\n#endif\n\t\telse {\n\t\t\tsyslog (LOG_WARNING, \"line %d: unknown keyword in config file: %s\",\n\t\t\t\tlinenum, args[0]);\n\t\t\terrcnt++;\n\t\t}\n\t}\n\n\tfclose (config_fp);\n\n\tif (errcnt) {\n\t    syslog (LOG_ERR, \"errors found in config file. errcnt = %d\", errcnt);\n\t    return -1;\n\t}\n\telse\n\t    syslog (LOG_INFO, \"configuration file loaded.\");\n\n\treturn 0;\n}",
        "func": "int read_config (char *config_file) {\n\tchar buf[512];\n\tchar *cp;\n\tFILE *config_fp;\n\tchar *args[MAXARGS];\n\tint argcnt, errcnt, linenum;\n\n\tif (T.debug > 0)\n\t\tsyslog (LOG_DEBUG, \"config file: %s\", config_file);\n\n\tconfig_fp = fopen (config_file, \"r\");\n\tif (!config_fp) {\n\t\tsyslog (LOG_ERR, \"can't open config file: %s\", config_file);\n\t\treturn -1;\n\t}\n\tlinenum = errcnt = 0;\n\twhile (fgets (buf, sizeof (buf), config_fp)) {\n\t\tlinenum++;\n\n\t\tcp = strchr (buf, '\\n');\n\t\tif (cp)\n\t\t\t*cp = '\\0';\n\t\tcp = strchr (buf, '\\n');\n\t\tif (cp)\n\t\t\t*cp = '\\0';\n\t\tcp = strchr (buf, '#'); /* strip comment */\n\t\tif (cp)\n\t\t\t*cp = '\\0';\n\t\tcp = strchr (buf, ';'); /* strip comment */\n\t\tif (cp)\n\t\t\t*cp = '\\0';\n\n\t\t/* parse config line in words */\n\t\targs[argcnt = 0] = strtok (buf, \" \\t\");\n\t\twhile (args[argcnt] && ++argcnt < MAXARGS)\n\t\t\targs[argcnt] = strtok (NULL, \" \\t\");\n\n\t\tif (!args[0]) /* empty line (or only comment) */\n\t\t\tcontinue;\n\n\t\tif (!strcasecmp (args[0], \"forwarder\")) {\n\t\t\tif (argcnt < 2 || argcnt > 4 ) {\n\t\t\t\tsyslog (LOG_ERR, \"line %d: invalid format: forwarder <IPaddr> [port <port>]\", linenum);\n\t\t\t\terrcnt++;\n\t\t\t} else {\n\t\t\t\tint port = PORT_TO, i;\n\n\t\t\t\ti = 2;\n\t\t\t\tif (argcnt > i) {\n\t\t\t\t\tif (!strcasecmp (args[i], \"port\")) {\n\t\t\t\t\t\tif (argcnt >= ++i) {\n\t\t\t\t\t\t\tport = atoi (args[i++]);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tsyslog (LOG_ERR, \"line %d: invalid format, missing <port> after port attribute\", linenum);\n\t\t\t\t\t\t\terrcnt++;\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsyslog (LOG_ERR, \"line %d: invalid format, cannot parse unknown attribute: %s\", linenum, args[i]);\n\t\t\t\t\t\terrcnt++;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\t\n\t\t\t\t}\n\t\t\t\tif (fwd_add (args[1], port) == -1)\n\t\t\t\t\treturn -1; /* serious trouble */\n\t\t\t}\n\t\t} else if (!strcasecmp (args[0], \"prefix\")) {\n\t\t\tif (argcnt != 2) {\n\t\t\t\tsyslog (LOG_ERR, \"line %d: invalid format: prefix <IPv6prefix>\", linenum);\n\t\t\t\terrcnt++;\n\t\t\t} else {\n\t\t\t\tif (conv_trick_conf ((u_char *)args[1])) {\n\t\t\t\t\tsyslog (LOG_INFO, \"can not add prefix %d: %s\", T.prefixnum, args[1]);\n\t\t\t\t\terrcnt++;\n\t\t\t\t} else\n\t\t\t\t\tsyslog (LOG_INFO, \"prefix %d added: %s\", T.prefixnum, args[1]);\n\t\t\t}\n\t\t} else if (!strcasecmp (args[0], \"allow\")) {\n\t\t\tif (argcnt != 2) {\n\t\t\t\tsyslog (LOG_ERR, \"line %d: invalid format: allow <IP address>\", linenum);\n\t\t\t\terrcnt++;\n\t\t\t} else {\n#ifdef SWILL\n\t\t\t\tif (T.http_port) {\n\t\t\t\t\tswill_allow(args[1]);\n\t\t\t\t\tsyslog (LOG_INFO, \"allow http connects from %s\", args[1]);\n\t\t\t\t} else\n#endif\n\t\t\t\t\tsyslog (LOG_INFO, \"NOTE: http support not enabled!!!\");\n\t\t\t}\n\t\t} else if (!strcasecmp (args[0], \"retry\")) {\n\t\t\tif (argcnt != 2) {\n\t\t\t\tsyslog (LOG_ERR, \"line %d: invalid format: retry <seconds>\", linenum);\n\t\t\t\terrcnt++;\n\t\t\t} else {\n\t\t\t\tT.retry_interval = atoi(args[1]);\n\t\t\t}\n\t\t} else if (!strcasecmp (args[0], \"pidfile\")) {\n\t\t\tif (argcnt != 2) {\n\t\t\t\tsyslog (LOG_ERR, \"line %d: invalid format: pidfile <filename>\", linenum);\n\t\t\t\terrcnt++;\n\t\t\t} else {\n\t\t\t\tT.pidfile = strdup(args[1]);\n\t\t\t}\n\t\t} else if (!strcasecmp (args[0], \"interfaces\")) {\n\t\t\tint i;\n\n\t\t\tif (argcnt < 2) {\n\t\t\t\tsyslog (LOG_ERR, \"line %d: invalid format: interfaces <ifa> <ifb> ...\", linenum);\n\t\t\t\terrcnt++;\n\t\t\t}\n\n\t\t\tfor (i = 0; T.iflist[i] && i < MAXINTERFACES; i++) { \n                        };\n\n\t\t \tif (i + argcnt-1 > MAXINTERFACES) {\n\t\t\t\tsyslog (LOG_ERR, \"line %d: to many interfaces, more than %d\", linenum, MAXINTERFACES);\n\t\t\t\terrcnt++;\n\t\t\t} else {\n\t\t\t\tsyslog (LOG_DEBUG, \"line %d: %d interfaces listed, no wildcard socket\", linenum, argcnt-1);\n\n\t\t\t\tT.iflist[i + argcnt--] = NULL;\n\t\t\t\twhile (argcnt) {\n\t\t\t\t\tif (!strcmp(args[argcnt], \"*\")) {\n\t\t\t\t\t\t/* wildcard interface, ignore other ifn */\n\t\t\t\t\t\tT.iflist[0] = NULL;\n\t\t\t\t\t\tT.wildcard = 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tT.iflist[i+argcnt-1] = strdup(args[argcnt]);\n\t\t\t\t\targcnt--;\n\t\t\t\t}\n\t\t\t\tif (T.iflist[0])\n\t\t\t\t\tT.wildcard = 0;\n\t\t\t}\n\t\t} else if (!strcasecmp (args[0], \"port\")) {\n\t\t\tif (argcnt != 2) {\n\t\t\t\tsyslog (LOG_ERR, \"line %d: invalid format: port <portnum>\", linenum);\n\t\t\t\terrcnt++;\n\t\t\t} else {\n\t\t\t\tT.port = atoi(args[1]);\n\t\t\t}\n\t\t}\n#ifdef SCOPED_REWRITE\n\t\telse if (!strcasecmp(args[0], \"scoped\")) {\n\t\t\tif (argcnt != 4) {\n\t\t\t\tsyslog (LOG_ERR, \"line %d: invalid format: scoped <from> <to> <plen>\", linenum);\n\t\t\t\terrcnt++;\n\t\t\t} else {\n\t\t\t\tif (conv_scoped_conf(args[1], args[2], atoi(args[3]))) {\n\t\t\t\t\tsyslog (LOG_INFO, \"can not add scoped %d: %s %s %s\",\n\t\t\t\t\t\tT.scoped_prefixes, args[1], args[2], args[3]);\n\t\t\t\t\terrcnt++;\n\t\t\t\t} else {\n\t\t\t\t\tsyslog(LOG_INFO, \"scoped %d added: %s %s %d\", \n\t\t\t\t\t\tT.scoped_prefixes, args[1], args[2], atoi(args[3]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n#endif\n#ifdef STF\n\t\telse if  (!strcasecmp(args[0], \"stf\")) {\n\t\t\tif (argcnt != 1) {\n\t\t\t\tsyslog (LOG_ERR, \"line %d: invalid format: stf\", linenum);\n\t\t\t\terrcnt++;\n\t\t\t} else {\n\t\t\t\tT.stf = 1;\n\t\t\t}\n\t\t}\n#endif\n\t\telse {\n\t\t\tsyslog (LOG_WARNING, \"line %d: unknown keyword in config file: %s\",\n\t\t\t\tlinenum, args[0]);\n\t\t\terrcnt++;\n\t\t}\n\t}\n\n\tfclose (config_fp);\n\n\tif (errcnt) {\n\t    syslog (LOG_ERR, \"errors found in config file. errcnt = %d\", errcnt);\n\t    return -1;\n\t}\n\telse\n\t    syslog (LOG_INFO, \"configuration file loaded.\");\n\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -110,7 +110,8 @@\n \t\t\t\terrcnt++;\n \t\t\t}\n \n-\t\t\tfor (i = 0; T.iflist[i] && i < MAXINTERFACES; i++);\n+\t\t\tfor (i = 0; T.iflist[i] && i < MAXINTERFACES; i++) { \n+                        };\n \n \t\t \tif (i + argcnt-1 > MAXINTERFACES) {\n \t\t\t\tsyslog (LOG_ERR, \"line %d: to many interfaces, more than %d\", linenum, MAXINTERFACES);",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\tfor (i = 0; T.iflist[i] && i < MAXINTERFACES; i++);"
            ],
            "added_lines": [
                "\t\t\tfor (i = 0; T.iflist[i] && i < MAXINTERFACES; i++) { ",
                "                        };"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-34295",
        "func_name": "fwdillema/totd/mesg_id",
        "description": "totd before 1.5.3 does not properly randomize mesg IDs.",
        "git_url": "https://github.com/fwdillema/totd/commit/afd8a10a6a21f82a70940d1b43cff48143250399",
        "commit_title": "Patch provided by Gabor Lencse for generating better randomized mesg IDs.",
        "commit_text": "",
        "func_before": "uint16_t mesg_id (void) {\n\tstatic uint16_t id = 0;\n\n\tif (!id) {\n\t\tsrandom (time (NULL));\n\t\tid = random ();\n\t}\n\tid++;\n\n\tif (T.debug > 4)\n\t\tsyslog (LOG_DEBUG, \"mesg_id() = %d\", id);\n\treturn id;\n}",
        "func": "uint16_t mesg_id (void) {\n        static int range = 0; /* indicates that no permutation has been generated yet */\n        static int index;\n\n        if (!range) {\n                srandom(time(0)); \t/* initialize random number generator seed */\n                range = 1;\t\t/* choose the lower range first */\n                make_random_permutation(LOW_START);\n                index = 0;\t\t/* start from the first element */\n        }\n        if ( index == NUM_USE ) {\t/* if the pool is exhasuted */\n                if (range == 1) {\n                        range = 2;\t/* choose the higher range */\n                        make_random_permutation(HIGH_START);\n                }\n                else {\n                        range = 1;\t/* choose the lower range */\n                        make_random_permutation(LOW_START);\n                }\n                index = 0;\n        }\n\tif (T.debug > 4) { \n\t\tsyslog (LOG_DEBUG, \"mesg_id() = %d\", permutation[index]);\n        }\n        return permutation[index++];\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,13 +1,26 @@\n uint16_t mesg_id (void) {\n-\tstatic uint16_t id = 0;\n+        static int range = 0; /* indicates that no permutation has been generated yet */\n+        static int index;\n \n-\tif (!id) {\n-\t\tsrandom (time (NULL));\n-\t\tid = random ();\n-\t}\n-\tid++;\n-\n-\tif (T.debug > 4)\n-\t\tsyslog (LOG_DEBUG, \"mesg_id() = %d\", id);\n-\treturn id;\n+        if (!range) {\n+                srandom(time(0)); \t/* initialize random number generator seed */\n+                range = 1;\t\t/* choose the lower range first */\n+                make_random_permutation(LOW_START);\n+                index = 0;\t\t/* start from the first element */\n+        }\n+        if ( index == NUM_USE ) {\t/* if the pool is exhasuted */\n+                if (range == 1) {\n+                        range = 2;\t/* choose the higher range */\n+                        make_random_permutation(HIGH_START);\n+                }\n+                else {\n+                        range = 1;\t/* choose the lower range */\n+                        make_random_permutation(LOW_START);\n+                }\n+                index = 0;\n+        }\n+\tif (T.debug > 4) { \n+\t\tsyslog (LOG_DEBUG, \"mesg_id() = %d\", permutation[index]);\n+        }\n+        return permutation[index++];\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tstatic uint16_t id = 0;",
                "\tif (!id) {",
                "\t\tsrandom (time (NULL));",
                "\t\tid = random ();",
                "\t}",
                "\tid++;",
                "",
                "\tif (T.debug > 4)",
                "\t\tsyslog (LOG_DEBUG, \"mesg_id() = %d\", id);",
                "\treturn id;"
            ],
            "added_lines": [
                "        static int range = 0; /* indicates that no permutation has been generated yet */",
                "        static int index;",
                "        if (!range) {",
                "                srandom(time(0)); \t/* initialize random number generator seed */",
                "                range = 1;\t\t/* choose the lower range first */",
                "                make_random_permutation(LOW_START);",
                "                index = 0;\t\t/* start from the first element */",
                "        }",
                "        if ( index == NUM_USE ) {\t/* if the pool is exhasuted */",
                "                if (range == 1) {",
                "                        range = 2;\t/* choose the higher range */",
                "                        make_random_permutation(HIGH_START);",
                "                }",
                "                else {",
                "                        range = 1;\t/* choose the lower range */",
                "                        make_random_permutation(LOW_START);",
                "                }",
                "                index = 0;",
                "        }",
                "\tif (T.debug > 4) { ",
                "\t\tsyslog (LOG_DEBUG, \"mesg_id() = %d\", permutation[index]);",
                "        }",
                "        return permutation[index++];"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-34295",
        "func_name": "fwdillema/totd/mesg_make_query",
        "description": "totd before 1.5.3 does not properly randomize mesg IDs.",
        "git_url": "https://github.com/fwdillema/totd/commit/afd8a10a6a21f82a70940d1b43cff48143250399",
        "commit_title": "Patch provided by Gabor Lencse for generating better randomized mesg IDs.",
        "commit_text": "",
        "func_before": "int mesg_make_query (u_char *qname, uint16_t qtype, uint16_t qclass,\n\t\t     uint32_t id, int rd, u_char *buf, int buflen) {\n\tchar *fn = \"mesg_make_query()\";\n\tu_char *ucp;\n\tint i, written_len;\n\tMesg_Hdr *hdr;\n\n\tif (T.debug > 4)\n\t\tsyslog (LOG_DEBUG, \"%s: (qtype: %s, id: %d): start\", fn,\n\t\t\tstring_rtype (qtype), id);\n\n\thdr = (Mesg_Hdr *) buf;\n\n\t/* write header */\n\thdr->id = id;\n\thdr->opcode = OP_QUERY;\n\thdr->rcode = RC_OK;\n\thdr->rd = rd;\n\thdr->qr = hdr->aa = hdr->tc = hdr->ra = hdr->zero = 0;\n\thdr->qdcnt = ntohs (1);\n\thdr->ancnt = hdr->nscnt = hdr->arcnt = ntohs (0);\n\n\twritten_len = sizeof (Mesg_Hdr);\n\tucp = (u_char *) (hdr + 1);\n\n\t/* write qname */\n\tif (T.debug > 4)\n\t\tsyslog (LOG_DEBUG, \"%s: qname offset = %zd\", fn, ucp - buf);\n\n\ti = dname_copy (qname, ucp, buflen - written_len);\n\tif (i < 0)\n\t\treturn -1;\n\n\twritten_len += i;\n\tucp += i;\n\n\t/* write qtype / qclass */\n\tif (T.debug > 4)\n\t\tsyslog (LOG_DEBUG, \"%s: qtype/qclass offset = %zd\",\n\t\t\tfn, ucp - buf);\n\n\twritten_len += sizeof (uint16_t) * 2;\n\tif (written_len > buflen)\n\t\treturn -1;\n\n\tPUTSHORT (qtype, ucp);\n\tPUTSHORT (qclass, ucp);\n\n\treturn written_len;\n}",
        "func": "int mesg_make_query (u_char *qname, uint16_t qtype, uint16_t qclass,\n\t\t     uint32_t id, int rd, u_char *buf, int buflen) {\n\tchar *fn = \"mesg_make_query()\";\n\tu_char *ucp;\n\tint i, written_len;\n\tMesg_Hdr *hdr;\n\n\tif (T.debug > 4) { \n\t\tsyslog (LOG_DEBUG, \"%s: (qtype: %s, id: %d): start\", fn,\n\t\t\tstring_rtype (qtype), id);\n        }\n\thdr = (Mesg_Hdr *) buf;\n\n\t/* write header */\n\thdr->id = id;\n\thdr->opcode = OP_QUERY;\n\thdr->rcode = RC_OK;\n\thdr->rd = rd;\n\thdr->qr = hdr->aa = hdr->tc = hdr->ra = hdr->zero = 0;\n\thdr->qdcnt = ntohs (1);\n\thdr->ancnt = hdr->nscnt = hdr->arcnt = ntohs (0);\n\n\twritten_len = sizeof (Mesg_Hdr);\n\tucp = (u_char *) (hdr + 1);\n\n\t/* write qname */\n\tif (T.debug > 4)\n\t\tsyslog (LOG_DEBUG, \"%s: qname offset = %zd\", fn, ucp - buf);\n\n\ti = dname_copy (qname, ucp, buflen - written_len);\n\tif (i < 0)\n\t\treturn -1;\n\n\twritten_len += i;\n\tucp += i;\n\n\t/* write qtype / qclass */\n\tif (T.debug > 4)\n\t\tsyslog (LOG_DEBUG, \"%s: qtype/qclass offset = %zd\",\n\t\t\tfn, ucp - buf);\n\n\twritten_len += sizeof (uint16_t) * 2;\n\tif (written_len > buflen)\n\t\treturn -1;\n\n\tPUTSHORT (qtype, ucp);\n\tPUTSHORT (qclass, ucp);\n\n\treturn written_len;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,10 +5,10 @@\n \tint i, written_len;\n \tMesg_Hdr *hdr;\n \n-\tif (T.debug > 4)\n+\tif (T.debug > 4) { \n \t\tsyslog (LOG_DEBUG, \"%s: (qtype: %s, id: %d): start\", fn,\n \t\t\tstring_rtype (qtype), id);\n-\n+        }\n \thdr = (Mesg_Hdr *) buf;\n \n \t/* write header */",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (T.debug > 4)",
                ""
            ],
            "added_lines": [
                "\tif (T.debug > 4) { ",
                "        }"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-1549",
        "func_name": "openssl/RAND_DRBG_generate",
        "description": "OpenSSL 1.1.1 introduced a rewritten random number generator (RNG). This was intended to include protection in the event of a fork() system call in order to ensure that the parent and child processes did not share the same RNG state. However this protection was not being used in the default case. A partial mitigation for this issue is that the output from a high precision timer is mixed into the RNG state so the likelihood of a parent and child process sharing state is significantly reduced. If an application already calls OPENSSL_init_crypto() explicitly using OPENSSL_INIT_ATFORK then this problem does not occur at all. Fixed in OpenSSL 1.1.1d (Affected 1.1.1-1.1.1c).",
        "git_url": "https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=1b0fe00e2704b5e20334a16d3c9099d1ba2ef1be",
        "commit_title": "",
        "commit_text": "drbg: ensure fork-safety without using a pthread_atfork handler  When the new OpenSSL CSPRNG was introduced in version 1.1.1, it was announced in the release notes that it would be fork-safe, which the old CSPRNG hadn't been.  The fork-safety was implemented using a fork count, which was incremented by a pthread_atfork handler. Initially, this handler was enabled by default. Unfortunately, the default behaviour had to be changed for other reasons in commit b5319bdbd095, so the new OpenSSL CSPRNG failed to keep its promise.  This commit restores the fork-safety using a different approach. It replaces the fork count by a fork id, which coincides with the process id on UNIX-like operating systems and is zero on other operating systems. It is used to detect when an automatic reseed after a fork is necessary.  To prevent a future regression, it also adds a test to verify that the child reseeds after fork.  CVE-2019-1549  (Merged from https://github.com/openssl/openssl/pull/9802) ",
        "func_before": "int RAND_DRBG_generate(RAND_DRBG *drbg, unsigned char *out, size_t outlen,\n                       int prediction_resistance,\n                       const unsigned char *adin, size_t adinlen)\n{\n    int reseed_required = 0;\n\n    if (drbg->state != DRBG_READY) {\n        /* try to recover from previous errors */\n        rand_drbg_restart(drbg, NULL, 0, 0);\n\n        if (drbg->state == DRBG_ERROR) {\n            RANDerr(RAND_F_RAND_DRBG_GENERATE, RAND_R_IN_ERROR_STATE);\n            return 0;\n        }\n        if (drbg->state == DRBG_UNINITIALISED) {\n            RANDerr(RAND_F_RAND_DRBG_GENERATE, RAND_R_NOT_INSTANTIATED);\n            return 0;\n        }\n    }\n\n    if (outlen > drbg->max_request) {\n        RANDerr(RAND_F_RAND_DRBG_GENERATE, RAND_R_REQUEST_TOO_LARGE_FOR_DRBG);\n        return 0;\n    }\n    if (adinlen > drbg->max_adinlen) {\n        RANDerr(RAND_F_RAND_DRBG_GENERATE, RAND_R_ADDITIONAL_INPUT_TOO_LONG);\n        return 0;\n    }\n\n    if (drbg->fork_count != rand_fork_count) {\n        drbg->fork_count = rand_fork_count;\n        reseed_required = 1;\n    }\n\n    if (drbg->reseed_interval > 0) {\n        if (drbg->reseed_gen_counter >= drbg->reseed_interval)\n            reseed_required = 1;\n    }\n    if (drbg->reseed_time_interval > 0) {\n        time_t now = time(NULL);\n        if (now < drbg->reseed_time\n            || now - drbg->reseed_time >= drbg->reseed_time_interval)\n            reseed_required = 1;\n    }\n    if (drbg->parent != NULL) {\n        unsigned int reseed_counter = tsan_load(&drbg->reseed_prop_counter);\n        if (reseed_counter > 0\n                && tsan_load(&drbg->parent->reseed_prop_counter)\n                   != reseed_counter)\n            reseed_required = 1;\n    }\n\n    if (reseed_required || prediction_resistance) {\n        if (!RAND_DRBG_reseed(drbg, adin, adinlen, prediction_resistance)) {\n            RANDerr(RAND_F_RAND_DRBG_GENERATE, RAND_R_RESEED_ERROR);\n            return 0;\n        }\n        adin = NULL;\n        adinlen = 0;\n    }\n\n    if (!drbg->meth->generate(drbg, out, outlen, adin, adinlen)) {\n        drbg->state = DRBG_ERROR;\n        RANDerr(RAND_F_RAND_DRBG_GENERATE, RAND_R_GENERATE_ERROR);\n        return 0;\n    }\n\n    drbg->reseed_gen_counter++;\n\n    return 1;\n}",
        "func": "int RAND_DRBG_generate(RAND_DRBG *drbg, unsigned char *out, size_t outlen,\n                       int prediction_resistance,\n                       const unsigned char *adin, size_t adinlen)\n{\n    int fork_id;\n    int reseed_required = 0;\n\n    if (drbg->state != DRBG_READY) {\n        /* try to recover from previous errors */\n        rand_drbg_restart(drbg, NULL, 0, 0);\n\n        if (drbg->state == DRBG_ERROR) {\n            RANDerr(RAND_F_RAND_DRBG_GENERATE, RAND_R_IN_ERROR_STATE);\n            return 0;\n        }\n        if (drbg->state == DRBG_UNINITIALISED) {\n            RANDerr(RAND_F_RAND_DRBG_GENERATE, RAND_R_NOT_INSTANTIATED);\n            return 0;\n        }\n    }\n\n    if (outlen > drbg->max_request) {\n        RANDerr(RAND_F_RAND_DRBG_GENERATE, RAND_R_REQUEST_TOO_LARGE_FOR_DRBG);\n        return 0;\n    }\n    if (adinlen > drbg->max_adinlen) {\n        RANDerr(RAND_F_RAND_DRBG_GENERATE, RAND_R_ADDITIONAL_INPUT_TOO_LONG);\n        return 0;\n    }\n\n    fork_id = openssl_get_fork_id();\n\n    if (drbg->fork_id != fork_id) {\n        drbg->fork_id = fork_id;\n        reseed_required = 1;\n    }\n\n    if (drbg->reseed_interval > 0) {\n        if (drbg->reseed_gen_counter >= drbg->reseed_interval)\n            reseed_required = 1;\n    }\n    if (drbg->reseed_time_interval > 0) {\n        time_t now = time(NULL);\n        if (now < drbg->reseed_time\n            || now - drbg->reseed_time >= drbg->reseed_time_interval)\n            reseed_required = 1;\n    }\n    if (drbg->parent != NULL) {\n        unsigned int reseed_counter = tsan_load(&drbg->reseed_prop_counter);\n        if (reseed_counter > 0\n                && tsan_load(&drbg->parent->reseed_prop_counter)\n                   != reseed_counter)\n            reseed_required = 1;\n    }\n\n    if (reseed_required || prediction_resistance) {\n        if (!RAND_DRBG_reseed(drbg, adin, adinlen, prediction_resistance)) {\n            RANDerr(RAND_F_RAND_DRBG_GENERATE, RAND_R_RESEED_ERROR);\n            return 0;\n        }\n        adin = NULL;\n        adinlen = 0;\n    }\n\n    if (!drbg->meth->generate(drbg, out, outlen, adin, adinlen)) {\n        drbg->state = DRBG_ERROR;\n        RANDerr(RAND_F_RAND_DRBG_GENERATE, RAND_R_GENERATE_ERROR);\n        return 0;\n    }\n\n    drbg->reseed_gen_counter++;\n\n    return 1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -2,6 +2,7 @@\n                        int prediction_resistance,\n                        const unsigned char *adin, size_t adinlen)\n {\n+    int fork_id;\n     int reseed_required = 0;\n \n     if (drbg->state != DRBG_READY) {\n@@ -27,8 +28,10 @@\n         return 0;\n     }\n \n-    if (drbg->fork_count != rand_fork_count) {\n-        drbg->fork_count = rand_fork_count;\n+    fork_id = openssl_get_fork_id();\n+\n+    if (drbg->fork_id != fork_id) {\n+        drbg->fork_id = fork_id;\n         reseed_required = 1;\n     }\n ",
        "diff_line_info": {
            "deleted_lines": [
                "    if (drbg->fork_count != rand_fork_count) {",
                "        drbg->fork_count = rand_fork_count;"
            ],
            "added_lines": [
                "    int fork_id;",
                "    fork_id = openssl_get_fork_id();",
                "",
                "    if (drbg->fork_id != fork_id) {",
                "        drbg->fork_id = fork_id;"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-1549",
        "func_name": "openssl/rand_drbg_new",
        "description": "OpenSSL 1.1.1 introduced a rewritten random number generator (RNG). This was intended to include protection in the event of a fork() system call in order to ensure that the parent and child processes did not share the same RNG state. However this protection was not being used in the default case. A partial mitigation for this issue is that the output from a high precision timer is mixed into the RNG state so the likelihood of a parent and child process sharing state is significantly reduced. If an application already calls OPENSSL_init_crypto() explicitly using OPENSSL_INIT_ATFORK then this problem does not occur at all. Fixed in OpenSSL 1.1.1d (Affected 1.1.1-1.1.1c).",
        "git_url": "https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=1b0fe00e2704b5e20334a16d3c9099d1ba2ef1be",
        "commit_title": "",
        "commit_text": "drbg: ensure fork-safety without using a pthread_atfork handler  When the new OpenSSL CSPRNG was introduced in version 1.1.1, it was announced in the release notes that it would be fork-safe, which the old CSPRNG hadn't been.  The fork-safety was implemented using a fork count, which was incremented by a pthread_atfork handler. Initially, this handler was enabled by default. Unfortunately, the default behaviour had to be changed for other reasons in commit b5319bdbd095, so the new OpenSSL CSPRNG failed to keep its promise.  This commit restores the fork-safety using a different approach. It replaces the fork count by a fork id, which coincides with the process id on UNIX-like operating systems and is zero on other operating systems. It is used to detect when an automatic reseed after a fork is necessary.  To prevent a future regression, it also adds a test to verify that the child reseeds after fork.  CVE-2019-1549  (Merged from https://github.com/openssl/openssl/pull/9802) ",
        "func_before": "static RAND_DRBG *rand_drbg_new(int secure,\n                                int type,\n                                unsigned int flags,\n                                RAND_DRBG *parent)\n{\n    RAND_DRBG *drbg = secure ? OPENSSL_secure_zalloc(sizeof(*drbg))\n                             : OPENSSL_zalloc(sizeof(*drbg));\n\n    if (drbg == NULL) {\n        RANDerr(RAND_F_RAND_DRBG_NEW, ERR_R_MALLOC_FAILURE);\n        return NULL;\n    }\n\n    drbg->secure = secure && CRYPTO_secure_allocated(drbg);\n    drbg->fork_count = rand_fork_count;\n    drbg->parent = parent;\n\n    if (parent == NULL) {\n        drbg->get_entropy = rand_drbg_get_entropy;\n        drbg->cleanup_entropy = rand_drbg_cleanup_entropy;\n#ifndef RAND_DRBG_GET_RANDOM_NONCE\n        drbg->get_nonce = rand_drbg_get_nonce;\n        drbg->cleanup_nonce = rand_drbg_cleanup_nonce;\n#endif\n\n        drbg->reseed_interval = master_reseed_interval;\n        drbg->reseed_time_interval = master_reseed_time_interval;\n    } else {\n        drbg->get_entropy = rand_drbg_get_entropy;\n        drbg->cleanup_entropy = rand_drbg_cleanup_entropy;\n        /*\n         * Do not provide nonce callbacks, the child DRBGs will\n         * obtain their nonce using random bits from the parent.\n         */\n\n        drbg->reseed_interval = slave_reseed_interval;\n        drbg->reseed_time_interval = slave_reseed_time_interval;\n    }\n\n    if (RAND_DRBG_set(drbg, type, flags) == 0)\n        goto err;\n\n    if (parent != NULL) {\n        rand_drbg_lock(parent);\n        if (drbg->strength > parent->strength) {\n            /*\n             * We currently don't support the algorithm from NIST SP 800-90C\n             * 10.1.2 to use a weaker DRBG as source\n             */\n            rand_drbg_unlock(parent);\n            RANDerr(RAND_F_RAND_DRBG_NEW, RAND_R_PARENT_STRENGTH_TOO_WEAK);\n            goto err;\n        }\n        rand_drbg_unlock(parent);\n    }\n\n    return drbg;\n\n err:\n    RAND_DRBG_free(drbg);\n\n    return NULL;\n}",
        "func": "static RAND_DRBG *rand_drbg_new(int secure,\n                                int type,\n                                unsigned int flags,\n                                RAND_DRBG *parent)\n{\n    RAND_DRBG *drbg = secure ? OPENSSL_secure_zalloc(sizeof(*drbg))\n                             : OPENSSL_zalloc(sizeof(*drbg));\n\n    if (drbg == NULL) {\n        RANDerr(RAND_F_RAND_DRBG_NEW, ERR_R_MALLOC_FAILURE);\n        return NULL;\n    }\n\n    drbg->secure = secure && CRYPTO_secure_allocated(drbg);\n    drbg->fork_id = openssl_get_fork_id();\n    drbg->parent = parent;\n\n    if (parent == NULL) {\n        drbg->get_entropy = rand_drbg_get_entropy;\n        drbg->cleanup_entropy = rand_drbg_cleanup_entropy;\n#ifndef RAND_DRBG_GET_RANDOM_NONCE\n        drbg->get_nonce = rand_drbg_get_nonce;\n        drbg->cleanup_nonce = rand_drbg_cleanup_nonce;\n#endif\n\n        drbg->reseed_interval = master_reseed_interval;\n        drbg->reseed_time_interval = master_reseed_time_interval;\n    } else {\n        drbg->get_entropy = rand_drbg_get_entropy;\n        drbg->cleanup_entropy = rand_drbg_cleanup_entropy;\n        /*\n         * Do not provide nonce callbacks, the child DRBGs will\n         * obtain their nonce using random bits from the parent.\n         */\n\n        drbg->reseed_interval = slave_reseed_interval;\n        drbg->reseed_time_interval = slave_reseed_time_interval;\n    }\n\n    if (RAND_DRBG_set(drbg, type, flags) == 0)\n        goto err;\n\n    if (parent != NULL) {\n        rand_drbg_lock(parent);\n        if (drbg->strength > parent->strength) {\n            /*\n             * We currently don't support the algorithm from NIST SP 800-90C\n             * 10.1.2 to use a weaker DRBG as source\n             */\n            rand_drbg_unlock(parent);\n            RANDerr(RAND_F_RAND_DRBG_NEW, RAND_R_PARENT_STRENGTH_TOO_WEAK);\n            goto err;\n        }\n        rand_drbg_unlock(parent);\n    }\n\n    return drbg;\n\n err:\n    RAND_DRBG_free(drbg);\n\n    return NULL;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -12,7 +12,7 @@\n     }\n \n     drbg->secure = secure && CRYPTO_secure_allocated(drbg);\n-    drbg->fork_count = rand_fork_count;\n+    drbg->fork_id = openssl_get_fork_id();\n     drbg->parent = parent;\n \n     if (parent == NULL) {",
        "diff_line_info": {
            "deleted_lines": [
                "    drbg->fork_count = rand_fork_count;"
            ],
            "added_lines": [
                "    drbg->fork_id = openssl_get_fork_id();"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-1549",
        "func_name": "openssl/OPENSSL_fork_child",
        "description": "OpenSSL 1.1.1 introduced a rewritten random number generator (RNG). This was intended to include protection in the event of a fork() system call in order to ensure that the parent and child processes did not share the same RNG state. However this protection was not being used in the default case. A partial mitigation for this issue is that the output from a high precision timer is mixed into the RNG state so the likelihood of a parent and child process sharing state is significantly reduced. If an application already calls OPENSSL_init_crypto() explicitly using OPENSSL_INIT_ATFORK then this problem does not occur at all. Fixed in OpenSSL 1.1.1d (Affected 1.1.1-1.1.1c).",
        "git_url": "https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=1b0fe00e2704b5e20334a16d3c9099d1ba2ef1be",
        "commit_title": "",
        "commit_text": "drbg: ensure fork-safety without using a pthread_atfork handler  When the new OpenSSL CSPRNG was introduced in version 1.1.1, it was announced in the release notes that it would be fork-safe, which the old CSPRNG hadn't been.  The fork-safety was implemented using a fork count, which was incremented by a pthread_atfork handler. Initially, this handler was enabled by default. Unfortunately, the default behaviour had to be changed for other reasons in commit b5319bdbd095, so the new OpenSSL CSPRNG failed to keep its promise.  This commit restores the fork-safety using a different approach. It replaces the fork count by a fork id, which coincides with the process id on UNIX-like operating systems and is zero on other operating systems. It is used to detect when an automatic reseed after a fork is necessary.  To prevent a future regression, it also adds a test to verify that the child reseeds after fork.  CVE-2019-1549  (Merged from https://github.com/openssl/openssl/pull/9802) ",
        "func_before": "void OPENSSL_fork_child(void)\n{\n    rand_fork();\n}",
        "func": "void OPENSSL_fork_child(void)\n{\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,3 @@\n void OPENSSL_fork_child(void)\n {\n-    rand_fork();\n }",
        "diff_line_info": {
            "deleted_lines": [
                "    rand_fork();"
            ],
            "added_lines": []
        }
    },
    {
        "cve_id": "CVE-2022-1615",
        "func_name": "samba-team/samba/generate_secret_buffer",
        "description": "In Samba, GnuTLS gnutls_rnd() can fail and give predictable random values.",
        "git_url": "https://gitlab.com/samba-team/samba/-/commit/420c77baa5f67b3aef89a716156ef1151d61604b",
        "commit_title": "util/genrand: don't ignore errors in random number generation",
        "commit_text": " In this case it is probably better to crash out.  BUG: https://bugzilla.samba.org/show_bug.cgi?id=15103  ",
        "func_before": "_PUBLIC_ void generate_secret_buffer(uint8_t *out, int len)\n{\n\t/*\n\t * Random number generator for long term keys.\n\t *\n\t * The key generator, will re-seed after a fixed amount of bytes is\n\t * generated (typically less than the nonce), and will also re-seed\n\t * based on time, i.e., after few hours of operation without reaching\n\t * the limit for a re-seed. For its re-seed it mixes mixes data obtained\n\t * from the OS random device with the previous key.\n\t */\n\tgnutls_rnd(GNUTLS_RND_KEY, out, len);\n}",
        "func": "_PUBLIC_ void generate_secret_buffer(uint8_t *out, int len)\n{\n\t/*\n\t * Random number generator for long term keys.\n\t *\n\t * The key generator, will re-seed after a fixed amount of bytes is\n\t * generated (typically less than the nonce), and will also re-seed\n\t * based on time, i.e., after few hours of operation without reaching\n\t * the limit for a re-seed. For its re-seed it mixes mixes data obtained\n\t * from the OS random device with the previous key.\n\t */\n\tint ret = gnutls_rnd(GNUTLS_RND_KEY, out, len);\n\tif (ret != 0) {\n\t\tgenrand_panic(ret, __location__, __func__);\n\t}\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -9,5 +9,8 @@\n \t * the limit for a re-seed. For its re-seed it mixes mixes data obtained\n \t * from the OS random device with the previous key.\n \t */\n-\tgnutls_rnd(GNUTLS_RND_KEY, out, len);\n+\tint ret = gnutls_rnd(GNUTLS_RND_KEY, out, len);\n+\tif (ret != 0) {\n+\t\tgenrand_panic(ret, __location__, __func__);\n+\t}\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tgnutls_rnd(GNUTLS_RND_KEY, out, len);"
            ],
            "added_lines": [
                "\tint ret = gnutls_rnd(GNUTLS_RND_KEY, out, len);",
                "\tif (ret != 0) {",
                "\t\tgenrand_panic(ret, __location__, __func__);",
                "\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-1615",
        "func_name": "samba-team/samba/generate_random_buffer",
        "description": "In Samba, GnuTLS gnutls_rnd() can fail and give predictable random values.",
        "git_url": "https://gitlab.com/samba-team/samba/-/commit/420c77baa5f67b3aef89a716156ef1151d61604b",
        "commit_title": "util/genrand: don't ignore errors in random number generation",
        "commit_text": " In this case it is probably better to crash out.  BUG: https://bugzilla.samba.org/show_bug.cgi?id=15103  ",
        "func_before": "_PUBLIC_ void generate_random_buffer(uint8_t *out, int len)\n{\n\t/* Random number generator for temporary keys. */\n\tgnutls_rnd(GNUTLS_RND_RANDOM, out, len);\n}",
        "func": "_PUBLIC_ void generate_random_buffer(uint8_t *out, int len)\n{\n\t/* Random number generator for temporary keys. */\n\tint ret = gnutls_rnd(GNUTLS_RND_RANDOM, out, len);\n\tif (ret != 0) {\n\t\tgenrand_panic(ret, __location__, __func__);\n\t}\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,8 @@\n _PUBLIC_ void generate_random_buffer(uint8_t *out, int len)\n {\n \t/* Random number generator for temporary keys. */\n-\tgnutls_rnd(GNUTLS_RND_RANDOM, out, len);\n+\tint ret = gnutls_rnd(GNUTLS_RND_RANDOM, out, len);\n+\tif (ret != 0) {\n+\t\tgenrand_panic(ret, __location__, __func__);\n+\t}\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tgnutls_rnd(GNUTLS_RND_RANDOM, out, len);"
            ],
            "added_lines": [
                "\tint ret = gnutls_rnd(GNUTLS_RND_RANDOM, out, len);",
                "\tif (ret != 0) {",
                "\t\tgenrand_panic(ret, __location__, __func__);",
                "\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-1615",
        "func_name": "samba-team/samba/generate_nonce_buffer",
        "description": "In Samba, GnuTLS gnutls_rnd() can fail and give predictable random values.",
        "git_url": "https://gitlab.com/samba-team/samba/-/commit/420c77baa5f67b3aef89a716156ef1151d61604b",
        "commit_title": "util/genrand: don't ignore errors in random number generation",
        "commit_text": " In this case it is probably better to crash out.  BUG: https://bugzilla.samba.org/show_bug.cgi?id=15103  ",
        "func_before": "_PUBLIC_ void generate_nonce_buffer(uint8_t *out, int len)\n{\n\t/*\n\t * Random number generator for nonce and initialization vectors.\n\t *\n\t * The nonce generator will reseed after outputting a fixed amount of\n\t * bytes (typically few megabytes), or after few hours of operation\n\t * without reaching the limit has passed.\n\t */\n\tgnutls_rnd(GNUTLS_RND_NONCE, out, len);\n}",
        "func": "_PUBLIC_ void generate_nonce_buffer(uint8_t *out, int len)\n{\n\t/*\n\t * Random number generator for nonce and initialization vectors.\n\t *\n\t * The nonce generator will reseed after outputting a fixed amount of\n\t * bytes (typically few megabytes), or after few hours of operation\n\t * without reaching the limit has passed.\n\t */\n\tint ret = gnutls_rnd(GNUTLS_RND_NONCE, out, len);\n\tif (ret != 0) {\n\t\tgenrand_panic(ret, __location__, __func__);\n\t}\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -7,5 +7,8 @@\n \t * bytes (typically few megabytes), or after few hours of operation\n \t * without reaching the limit has passed.\n \t */\n-\tgnutls_rnd(GNUTLS_RND_NONCE, out, len);\n+\tint ret = gnutls_rnd(GNUTLS_RND_NONCE, out, len);\n+\tif (ret != 0) {\n+\t\tgenrand_panic(ret, __location__, __func__);\n+\t}\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tgnutls_rnd(GNUTLS_RND_NONCE, out, len);"
            ],
            "added_lines": [
                "\tint ret = gnutls_rnd(GNUTLS_RND_NONCE, out, len);",
                "\tif (ret != 0) {",
                "\t\tgenrand_panic(ret, __location__, __func__);",
                "\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-40299",
        "func_name": "Singular/sdb_edit",
        "description": "In Singular before 4.3.1, a predictable /tmp pathname is used (e.g., by sdb.cc), which allows local users to gain the privileges of other users via a procedure in a file under /tmp. NOTE: this CVE Record is about sdb.cc and similar files in the Singular interface that have predictable /tmp pathnames; this CVE Record is not about the lack of a safe temporary-file creation capability in the Singular language.",
        "git_url": "https://github.com/Singular/Singular/commit/5f28fbf066626fa9c4a8f0e6408c0bb362fb386c",
        "commit_title": "use mkstemp for sdb",
        "commit_text": "",
        "func_before": "void sdb_edit(procinfo *pi)\n{\n  char * filename = omStrDup(\"/tmp/sd000000\");\n  sprintf(filename+7,\"%d\",getpid());\n  FILE *fp=fopen(filename,\"w\");\n  if (fp==NULL)\n  {\n    Print(\"cannot open %s\\n\",filename);\n    omFree(filename);\n    return;\n  }\n  if (pi->language!= LANG_SINGULAR)\n  {\n    Print(\"cannot edit type %d\\n\",pi->language);\n    fclose(fp);\n    fp=NULL;\n  }\n  else\n  {\n    const char *editor=getenv(\"EDITOR\");\n    if (editor==NULL)\n      editor=getenv(\"VISUAL\");\n    if (editor==NULL)\n      editor=\"vi\";\n    editor=omStrDup(editor);\n\n    if (pi->data.s.body==NULL)\n    {\n      iiGetLibProcBuffer(pi);\n      if (pi->data.s.body==NULL)\n      {\n        PrintS(\"cannot get the procedure body\\n\");\n        fclose(fp);\n        si_unlink(filename);\n        omFree(filename);\n        return;\n      }\n    }\n\n    fwrite(pi->data.s.body,1,strlen(pi->data.s.body),fp);\n    fclose(fp);\n\n    int pid=fork();\n    if (pid!=0)\n    {\n      si_wait(&pid);\n    }\n    else if(pid==0)\n    {\n      if (strchr(editor,' ')==NULL)\n      {\n        execlp(editor,editor,filename,NULL);\n        Print(\"cannot exec %s\\n\",editor);\n      }\n      else\n      {\n        char *p=(char *)omAlloc(strlen(editor)+strlen(filename)+2);\n        sprintf(p,\"%s %s\",editor,filename);\n        system(p);\n      }\n      exit(0);\n    }\n    else\n    {\n      PrintS(\"cannot fork\\n\");\n    }\n\n    fp=fopen(filename,\"r\");\n    if (fp==NULL)\n    {\n      Print(\"cannot read from %s\\n\",filename);\n    }\n    else\n    {\n      fseek(fp,0L,SEEK_END);\n      long len=ftell(fp);\n      fseek(fp,0L,SEEK_SET);\n\n      omFree((ADDRESS)pi->data.s.body);\n      pi->data.s.body=(char *)omAlloc((int)len+1);\n      myfread( pi->data.s.body, len, 1, fp);\n      pi->data.s.body[len]='\\0';\n      fclose(fp);\n    }\n  }\n  si_unlink(filename);\n  omFree(filename);\n}",
        "func": "void sdb_edit(procinfo *pi)\n{\n  char * filename = omStrDup(\"/tmp/sdXXXXXX\");\n  int f=mkstemp(filename);\n  if (f==-1)\n  {\n    Print(\"cannot open %s\\n\",filename);\n    omFree(filename);\n    return;\n  }\n  if (pi->language!= LANG_SINGULAR)\n  {\n    Print(\"cannot edit type %d\\n\",pi->language);\n    close(f);\n    f=NULL;\n  }\n  else\n  {\n    const char *editor=getenv(\"EDITOR\");\n    if (editor==NULL)\n      editor=getenv(\"VISUAL\");\n    if (editor==NULL)\n      editor=\"vi\";\n    editor=omStrDup(editor);\n\n    if (pi->data.s.body==NULL)\n    {\n      iiGetLibProcBuffer(pi);\n      if (pi->data.s.body==NULL)\n      {\n        PrintS(\"cannot get the procedure body\\n\");\n        close(f);\n        si_unlink(filename);\n        omFree(filename);\n        return;\n      }\n    }\n\n    write(f,pi->data.s.body,strlen(pi->data.s.body));\n    close(f);\n\n    int pid=fork();\n    if (pid!=0)\n    {\n      si_wait(&pid);\n    }\n    else if(pid==0)\n    {\n      if (strchr(editor,' ')==NULL)\n      {\n        execlp(editor,editor,filename,NULL);\n        Print(\"cannot exec %s\\n\",editor);\n      }\n      else\n      {\n        char *p=(char *)omAlloc(strlen(editor)+strlen(filename)+2);\n        sprintf(p,\"%s %s\",editor,filename);\n        system(p);\n      }\n      exit(0);\n    }\n    else\n    {\n      PrintS(\"cannot fork\\n\");\n    }\n\n    FILE* fp=fopen(filename,\"r\");\n    if (fp==NULL)\n    {\n      Print(\"cannot read from %s\\n\",filename);\n    }\n    else\n    {\n      fseek(fp,0L,SEEK_END);\n      long len=ftell(fp);\n      fseek(fp,0L,SEEK_SET);\n\n      omFree((ADDRESS)pi->data.s.body);\n      pi->data.s.body=(char *)omAlloc((int)len+1);\n      myfread( pi->data.s.body, len, 1, fp);\n      pi->data.s.body[len]='\\0';\n      fclose(fp);\n    }\n  }\n  si_unlink(filename);\n  omFree(filename);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,9 +1,8 @@\n void sdb_edit(procinfo *pi)\n {\n-  char * filename = omStrDup(\"/tmp/sd000000\");\n-  sprintf(filename+7,\"%d\",getpid());\n-  FILE *fp=fopen(filename,\"w\");\n-  if (fp==NULL)\n+  char * filename = omStrDup(\"/tmp/sdXXXXXX\");\n+  int f=mkstemp(filename);\n+  if (f==-1)\n   {\n     Print(\"cannot open %s\\n\",filename);\n     omFree(filename);\n@@ -12,8 +11,8 @@\n   if (pi->language!= LANG_SINGULAR)\n   {\n     Print(\"cannot edit type %d\\n\",pi->language);\n-    fclose(fp);\n-    fp=NULL;\n+    close(f);\n+    f=NULL;\n   }\n   else\n   {\n@@ -30,15 +29,15 @@\n       if (pi->data.s.body==NULL)\n       {\n         PrintS(\"cannot get the procedure body\\n\");\n-        fclose(fp);\n+        close(f);\n         si_unlink(filename);\n         omFree(filename);\n         return;\n       }\n     }\n \n-    fwrite(pi->data.s.body,1,strlen(pi->data.s.body),fp);\n-    fclose(fp);\n+    write(f,pi->data.s.body,strlen(pi->data.s.body));\n+    close(f);\n \n     int pid=fork();\n     if (pid!=0)\n@@ -65,7 +64,7 @@\n       PrintS(\"cannot fork\\n\");\n     }\n \n-    fp=fopen(filename,\"r\");\n+    FILE* fp=fopen(filename,\"r\");\n     if (fp==NULL)\n     {\n       Print(\"cannot read from %s\\n\",filename);",
        "diff_line_info": {
            "deleted_lines": [
                "  char * filename = omStrDup(\"/tmp/sd000000\");",
                "  sprintf(filename+7,\"%d\",getpid());",
                "  FILE *fp=fopen(filename,\"w\");",
                "  if (fp==NULL)",
                "    fclose(fp);",
                "    fp=NULL;",
                "        fclose(fp);",
                "    fwrite(pi->data.s.body,1,strlen(pi->data.s.body),fp);",
                "    fclose(fp);",
                "    fp=fopen(filename,\"r\");"
            ],
            "added_lines": [
                "  char * filename = omStrDup(\"/tmp/sdXXXXXX\");",
                "  int f=mkstemp(filename);",
                "  if (f==-1)",
                "    close(f);",
                "    f=NULL;",
                "        close(f);",
                "    write(f,pi->data.s.body,strlen(pi->data.s.body));",
                "    close(f);",
                "    FILE* fp=fopen(filename,\"r\");"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-1543",
        "func_name": "openssl/chacha20_poly1305_ctrl",
        "description": "ChaCha20-Poly1305 is an AEAD cipher, and requires a unique nonce input for every encryption operation. RFC 7539 specifies that the nonce value (IV) should be 96 bits (12 bytes). OpenSSL allows a variable nonce length and front pads the nonce with 0 bytes if it is less than 12 bytes. However it also incorrectly allows a nonce to be set of up to 16 bytes. In this case only the last 12 bytes are significant and any additional leading bytes are ignored. It is a requirement of using this cipher that nonce values are unique. Messages encrypted using a reused nonce value are susceptible to serious confidentiality and integrity attacks. If an application changes the default nonce length to be longer than 12 bytes and then makes a change to the leading bytes of the nonce expecting the new value to be a new unique nonce then such an application could inadvertently encrypt messages with a reused nonce. Additionally the ignored bytes in a long nonce are not covered by the integrity guarantee of this cipher. Any application that relies on the integrity of these ignored leading bytes of a long nonce may be further affected. Any OpenSSL internal use of this cipher, including in SSL/TLS, is safe because no such use sets such a long nonce value. However user applications that use this cipher directly and set a non-default nonce length to be longer than 12 bytes may be vulnerable. OpenSSL versions 1.1.1 and 1.1.0 are affected by this issue. Due to the limited scope of affected deployments this has been assessed as low severity and therefore we are not creating new releases at this time. Fixed in OpenSSL 1.1.1c (Affected 1.1.1-1.1.1b). Fixed in OpenSSL 1.1.0k (Affected 1.1.0-1.1.0j).",
        "git_url": "https://git.openssl.org/gitweb/?p=openssl.git;a=commit;h=f426625b6ae9a7831010750490a5f0ad689c5ba3",
        "commit_title": "",
        "commit_text": "Prevent over long nonces in ChaCha20-Poly1305  ChaCha20-Poly1305 is an AEAD cipher, and requires a unique nonce input for every encryption operation. RFC 7539 specifies that the nonce value (IV) should be 96 bits (12 bytes). OpenSSL allows a variable nonce length and front pads the nonce with 0 bytes if it is less than 12 bytes. However it also incorrectly allows a nonce to be set of up to 16 bytes. In this case only the last 12 bytes are significant and any additional leading bytes are ignored.  It is a requirement of using this cipher that nonce values are unique. Messages encrypted using a reused nonce value are susceptible to serious confidentiality and integrity attacks. If an application changes the default nonce length to be longer than 12 bytes and then makes a change to the leading bytes of the nonce expecting the new value to be a new unique nonce then such an application could inadvertently encrypt messages with a reused nonce.  Additionally the ignored bytes in a long nonce are not covered by the integrity guarantee of this cipher. Any application that relies on the integrity of these ignored leading bytes of a long nonce may be further affected.  Any OpenSSL internal use of this cipher, including in SSL/TLS, is safe because no such use sets such a long nonce value. However user applications that use this cipher directly and set a non-default nonce length to be longer than 12 bytes may be vulnerable.  CVE-2019-1543  Fixes #8345  (Merged from https://github.com/openssl/openssl/pull/8406)  (cherry picked from commit 2a3d0ee9d59156c48973592331404471aca886d6) ",
        "func_before": "static int chacha20_poly1305_ctrl(EVP_CIPHER_CTX *ctx, int type, int arg,\n                                  void *ptr)\n{\n    EVP_CHACHA_AEAD_CTX *actx = aead_data(ctx);\n\n    switch(type) {\n    case EVP_CTRL_INIT:\n        if (actx == NULL)\n            actx = ctx->cipher_data\n                 = OPENSSL_zalloc(sizeof(*actx) + Poly1305_ctx_size());\n        if (actx == NULL) {\n            EVPerr(EVP_F_CHACHA20_POLY1305_CTRL, EVP_R_INITIALIZATION_ERROR);\n            return 0;\n        }\n        actx->len.aad = 0;\n        actx->len.text = 0;\n        actx->aad = 0;\n        actx->mac_inited = 0;\n        actx->tag_len = 0;\n        actx->nonce_len = 12;\n        actx->tls_payload_length = NO_TLS_PAYLOAD_LENGTH;\n        memset(actx->tls_aad, 0, POLY1305_BLOCK_SIZE);\n        return 1;\n\n    case EVP_CTRL_COPY:\n        if (actx) {\n            EVP_CIPHER_CTX *dst = (EVP_CIPHER_CTX *)ptr;\n\n            dst->cipher_data =\n                   OPENSSL_memdup(actx, sizeof(*actx) + Poly1305_ctx_size());\n            if (dst->cipher_data == NULL) {\n                EVPerr(EVP_F_CHACHA20_POLY1305_CTRL, EVP_R_COPY_ERROR);\n                return 0;\n            }\n        }\n        return 1;\n\n    case EVP_CTRL_AEAD_SET_IVLEN:\n        if (arg <= 0 || arg > CHACHA_CTR_SIZE)\n            return 0;\n        actx->nonce_len = arg;\n        return 1;\n\n    case EVP_CTRL_AEAD_SET_IV_FIXED:\n        if (arg != 12)\n            return 0;\n        actx->nonce[0] = actx->key.counter[1]\n                       = CHACHA_U8TOU32((unsigned char *)ptr);\n        actx->nonce[1] = actx->key.counter[2]\n                       = CHACHA_U8TOU32((unsigned char *)ptr+4);\n        actx->nonce[2] = actx->key.counter[3]\n                       = CHACHA_U8TOU32((unsigned char *)ptr+8);\n        return 1;\n\n    case EVP_CTRL_AEAD_SET_TAG:\n        if (arg <= 0 || arg > POLY1305_BLOCK_SIZE)\n            return 0;\n        if (ptr != NULL) {\n            memcpy(actx->tag, ptr, arg);\n            actx->tag_len = arg;\n        }\n        return 1;\n\n    case EVP_CTRL_AEAD_GET_TAG:\n        if (arg <= 0 || arg > POLY1305_BLOCK_SIZE || !ctx->encrypt)\n            return 0;\n        memcpy(ptr, actx->tag, arg);\n        return 1;\n\n    case EVP_CTRL_AEAD_TLS1_AAD:\n        if (arg != EVP_AEAD_TLS1_AAD_LEN)\n            return 0;\n        {\n            unsigned int len;\n            unsigned char *aad = ptr;\n\n            memcpy(actx->tls_aad, ptr, EVP_AEAD_TLS1_AAD_LEN);\n            len = aad[EVP_AEAD_TLS1_AAD_LEN - 2] << 8 |\n                  aad[EVP_AEAD_TLS1_AAD_LEN - 1];\n            aad = actx->tls_aad;\n            if (!ctx->encrypt) {\n                if (len < POLY1305_BLOCK_SIZE)\n                    return 0;\n                len -= POLY1305_BLOCK_SIZE;     /* discount attached tag */\n                aad[EVP_AEAD_TLS1_AAD_LEN - 2] = (unsigned char)(len >> 8);\n                aad[EVP_AEAD_TLS1_AAD_LEN - 1] = (unsigned char)len;\n            }\n            actx->tls_payload_length = len;\n\n            /*\n             * merge record sequence number as per RFC7905\n             */\n            actx->key.counter[1] = actx->nonce[0];\n            actx->key.counter[2] = actx->nonce[1] ^ CHACHA_U8TOU32(aad);\n            actx->key.counter[3] = actx->nonce[2] ^ CHACHA_U8TOU32(aad+4);\n            actx->mac_inited = 0;\n\n            return POLY1305_BLOCK_SIZE;         /* tag length */\n        }\n\n    case EVP_CTRL_AEAD_SET_MAC_KEY:\n        /* no-op */\n        return 1;\n\n    default:\n        return -1;\n    }\n}",
        "func": "static int chacha20_poly1305_ctrl(EVP_CIPHER_CTX *ctx, int type, int arg,\n                                  void *ptr)\n{\n    EVP_CHACHA_AEAD_CTX *actx = aead_data(ctx);\n\n    switch(type) {\n    case EVP_CTRL_INIT:\n        if (actx == NULL)\n            actx = ctx->cipher_data\n                 = OPENSSL_zalloc(sizeof(*actx) + Poly1305_ctx_size());\n        if (actx == NULL) {\n            EVPerr(EVP_F_CHACHA20_POLY1305_CTRL, EVP_R_INITIALIZATION_ERROR);\n            return 0;\n        }\n        actx->len.aad = 0;\n        actx->len.text = 0;\n        actx->aad = 0;\n        actx->mac_inited = 0;\n        actx->tag_len = 0;\n        actx->nonce_len = 12;\n        actx->tls_payload_length = NO_TLS_PAYLOAD_LENGTH;\n        memset(actx->tls_aad, 0, POLY1305_BLOCK_SIZE);\n        return 1;\n\n    case EVP_CTRL_COPY:\n        if (actx) {\n            EVP_CIPHER_CTX *dst = (EVP_CIPHER_CTX *)ptr;\n\n            dst->cipher_data =\n                   OPENSSL_memdup(actx, sizeof(*actx) + Poly1305_ctx_size());\n            if (dst->cipher_data == NULL) {\n                EVPerr(EVP_F_CHACHA20_POLY1305_CTRL, EVP_R_COPY_ERROR);\n                return 0;\n            }\n        }\n        return 1;\n\n    case EVP_CTRL_AEAD_SET_IVLEN:\n        if (arg <= 0 || arg > CHACHA20_POLY1305_MAX_IVLEN)\n            return 0;\n        actx->nonce_len = arg;\n        return 1;\n\n    case EVP_CTRL_AEAD_SET_IV_FIXED:\n        if (arg != 12)\n            return 0;\n        actx->nonce[0] = actx->key.counter[1]\n                       = CHACHA_U8TOU32((unsigned char *)ptr);\n        actx->nonce[1] = actx->key.counter[2]\n                       = CHACHA_U8TOU32((unsigned char *)ptr+4);\n        actx->nonce[2] = actx->key.counter[3]\n                       = CHACHA_U8TOU32((unsigned char *)ptr+8);\n        return 1;\n\n    case EVP_CTRL_AEAD_SET_TAG:\n        if (arg <= 0 || arg > POLY1305_BLOCK_SIZE)\n            return 0;\n        if (ptr != NULL) {\n            memcpy(actx->tag, ptr, arg);\n            actx->tag_len = arg;\n        }\n        return 1;\n\n    case EVP_CTRL_AEAD_GET_TAG:\n        if (arg <= 0 || arg > POLY1305_BLOCK_SIZE || !ctx->encrypt)\n            return 0;\n        memcpy(ptr, actx->tag, arg);\n        return 1;\n\n    case EVP_CTRL_AEAD_TLS1_AAD:\n        if (arg != EVP_AEAD_TLS1_AAD_LEN)\n            return 0;\n        {\n            unsigned int len;\n            unsigned char *aad = ptr;\n\n            memcpy(actx->tls_aad, ptr, EVP_AEAD_TLS1_AAD_LEN);\n            len = aad[EVP_AEAD_TLS1_AAD_LEN - 2] << 8 |\n                  aad[EVP_AEAD_TLS1_AAD_LEN - 1];\n            aad = actx->tls_aad;\n            if (!ctx->encrypt) {\n                if (len < POLY1305_BLOCK_SIZE)\n                    return 0;\n                len -= POLY1305_BLOCK_SIZE;     /* discount attached tag */\n                aad[EVP_AEAD_TLS1_AAD_LEN - 2] = (unsigned char)(len >> 8);\n                aad[EVP_AEAD_TLS1_AAD_LEN - 1] = (unsigned char)len;\n            }\n            actx->tls_payload_length = len;\n\n            /*\n             * merge record sequence number as per RFC7905\n             */\n            actx->key.counter[1] = actx->nonce[0];\n            actx->key.counter[2] = actx->nonce[1] ^ CHACHA_U8TOU32(aad);\n            actx->key.counter[3] = actx->nonce[2] ^ CHACHA_U8TOU32(aad+4);\n            actx->mac_inited = 0;\n\n            return POLY1305_BLOCK_SIZE;         /* tag length */\n        }\n\n    case EVP_CTRL_AEAD_SET_MAC_KEY:\n        /* no-op */\n        return 1;\n\n    default:\n        return -1;\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -36,7 +36,7 @@\n         return 1;\n \n     case EVP_CTRL_AEAD_SET_IVLEN:\n-        if (arg <= 0 || arg > CHACHA_CTR_SIZE)\n+        if (arg <= 0 || arg > CHACHA20_POLY1305_MAX_IVLEN)\n             return 0;\n         actx->nonce_len = arg;\n         return 1;",
        "diff_line_info": {
            "deleted_lines": [
                "        if (arg <= 0 || arg > CHACHA_CTR_SIZE)"
            ],
            "added_lines": [
                "        if (arg <= 0 || arg > CHACHA20_POLY1305_MAX_IVLEN)"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-23408",
        "func_name": "wolfSSL/wolfssl/BuildMessage",
        "description": "wolfSSL 5.x before 5.1.1 uses non-random IV values in certain situations. This affects connections (without AEAD) using AES-CBC or DES3 with TLS 1.1 or 1.2 or DTLS 1.1 or 1.2. This occurs because of misplaced memory initialization in BuildMessage in internal.c.",
        "git_url": "https://github.com/wolfSSL/wolfssl/commit/73b4cc9476f6355a91138f545f3fd007ce058255",
        "commit_title": "fix for location of xmemset",
        "commit_text": "",
        "func_before": "int BuildMessage(WOLFSSL* ssl, byte* output, int outSz, const byte* input,\n             int inSz, int type, int hashOutput, int sizeOnly, int asyncOkay,\n             int epochOrder)\n{\n#ifndef WOLFSSL_NO_TLS12\n    int ret;\n    BuildMsgArgs* args;\n    BuildMsgArgs  lcl_args;\n#ifdef WOLFSSL_ASYNC_CRYPT\n    args = &ssl->async.buildArgs;\n#endif\n#endif\n\n    WOLFSSL_ENTER(\"BuildMessage\");\n\n    if (ssl == NULL) {\n        return BAD_FUNC_ARG;\n    }\n\n    (void)epochOrder;\n\n#ifdef WOLFSSL_NO_TLS12\n    return BuildTls13Message(ssl, output, outSz, input, inSz, type,\n                                               hashOutput, sizeOnly, asyncOkay);\n#else\n#ifdef WOLFSSL_TLS13\n    if (ssl->options.tls1_3) {\n        return BuildTls13Message(ssl, output, outSz, input, inSz, type,\n                                 hashOutput, sizeOnly, asyncOkay);\n    }\n#endif\n\n#ifdef WOLFSSL_ASYNC_CRYPT\n    ret = WC_NOT_PENDING_E;\n    if (asyncOkay) {\n        ret = wolfSSL_AsyncPop(ssl, &ssl->options.buildMsgState);\n        if (ret != WC_NOT_PENDING_E) {\n            /* Check for error */\n            if (ret < 0)\n                goto exit_buildmsg;\n        }\n    }\n    else\n#endif\n    {\n        args = &lcl_args;\n    }\n\n    /* Reset state */\n#ifdef WOLFSSL_ASYNC_CRYPT\n    if (ret == WC_NOT_PENDING_E)\n#endif\n    {\n        ret = 0;\n        ssl->options.buildMsgState = BUILD_MSG_BEGIN;\n        XMEMSET(args, 0, sizeof(BuildMsgArgs));\n\n        args->sz = RECORD_HEADER_SZ + inSz;\n        args->idx  = RECORD_HEADER_SZ;\n        args->headerSz = RECORD_HEADER_SZ;\n    }\n\n    switch (ssl->options.buildMsgState) {\n        case BUILD_MSG_BEGIN:\n        {\n            /* catch mistaken sizeOnly parameter */\n            if (!sizeOnly && (output == NULL || input == NULL) ) {\n                ERROR_OUT(BAD_FUNC_ARG, exit_buildmsg);\n            }\n            if (sizeOnly && (output || input) ) {\n                WOLFSSL_MSG(\"BuildMessage w/sizeOnly doesn't need input/output\");\n                ERROR_OUT(BAD_FUNC_ARG, exit_buildmsg);\n            }\n        #if defined(WOLFSSL_DTLS) && defined(HAVE_SECURE_RENEGOTIATION)\n            if (ssl->options.dtls && DtlsSCRKeysSet(ssl)) {\n                /* For epochs >1 the current cipher parameters are located in\n                 * ssl->secure_renegotiation->tmp_keys. Previous cipher\n                 * parameters and for epoch 1 use ssl->keys */\n                switch (epochOrder) {\n                case PREV_ORDER:\n                    if (ssl->encrypt.src != KEYS) {\n                        ssl->secure_renegotiation->cache_status =\n                                SCR_CACHE_NULL;\n                        if ((ret = SetKeysSide(ssl, ENCRYPT_SIDE_ONLY)) != 0)\n                            ERROR_OUT(ret, exit_buildmsg);\n                    }\n                    break;\n                case CUR_ORDER:\n                    if (ssl->keys.dtls_epoch ==\n                            ssl->secure_renegotiation->tmp_keys.dtls_epoch) {\n                        if (ssl->encrypt.src != SCR) {\n                            ssl->secure_renegotiation->cache_status =\n                                    SCR_CACHE_NEEDED;\n                            if ((ret = SetKeysSide(ssl, ENCRYPT_SIDE_ONLY))\n                                    != 0)\n                                ERROR_OUT(ret, exit_buildmsg);\n                        }\n                    }\n                    else {\n                        if (ssl->encrypt.src != KEYS) {\n                            ssl->secure_renegotiation->cache_status =\n                                    SCR_CACHE_NULL;\n                            if ((ret = SetKeysSide(ssl, ENCRYPT_SIDE_ONLY))\n                                    != 0)\n                                ERROR_OUT(ret, exit_buildmsg);\n                        }\n                    }\n                    break;\n                default:\n                    WOLFSSL_MSG(\"BuildMessage only supports PREV_ORDER and \"\n                                \"CUR_ORDER\");\n                    ERROR_OUT(BAD_FUNC_ARG, exit_buildmsg);\n                }\n            }\n        #endif\n\n            ssl->options.buildMsgState = BUILD_MSG_SIZE;\n        }\n        FALL_THROUGH;\n        case BUILD_MSG_SIZE:\n        {\n            args->digestSz = ssl->specs.hash_size;\n        #ifdef HAVE_TRUNCATED_HMAC\n            if (ssl->truncated_hmac)\n                args->digestSz = min(TRUNCATED_HMAC_SZ, args->digestSz);\n        #endif\n            args->sz += args->digestSz;\n\n        #ifdef WOLFSSL_DTLS\n            if (ssl->options.dtls) {\n                args->sz       += DTLS_RECORD_EXTRA;\n                args->idx      += DTLS_RECORD_EXTRA;\n                args->headerSz += DTLS_RECORD_EXTRA;\n            }\n        #endif\n\n        #ifndef WOLFSSL_AEAD_ONLY\n            if (ssl->specs.cipher_type == block) {\n                word32 blockSz = ssl->specs.block_size;\n\n                if (blockSz == 0) {\n                    WOLFSSL_MSG(\"Invalid block size with block cipher type\");\n                    ERROR_OUT(BAD_STATE_E, exit_buildmsg);\n                }\n\n                if (ssl->options.tls1_1) {\n                    args->ivSz = blockSz;\n                    args->sz  += args->ivSz;\n\n                    if (args->ivSz > MAX_IV_SZ)\n                        ERROR_OUT(BUFFER_E, exit_buildmsg);\n                }\n                args->sz += 1;       /* pad byte */\n            #if defined(HAVE_ENCRYPT_THEN_MAC) && !defined(WOLFSSL_AEAD_ONLY)\n                if (ssl->options.startedETMWrite) {\n                    args->pad = (args->sz - args->headerSz -\n                                                      args->digestSz) % blockSz;\n                }\n                else\n            #endif\n                    args->pad = (args->sz - args->headerSz) % blockSz;\n                #ifdef OPENSSL_EXTRA\n                if(args->pad != 0)\n                #endif\n                    args->pad = blockSz - args->pad;\n                args->sz += args->pad;\n            }\n        #endif /* WOLFSSL_AEAD_ONLY */\n\n        #ifdef HAVE_AEAD\n            if (ssl->specs.cipher_type == aead) {\n                if (ssl->specs.bulk_cipher_algorithm != wolfssl_chacha)\n                    args->ivSz = AESGCM_EXP_IV_SZ;\n\n                args->sz += (args->ivSz + ssl->specs.aead_mac_size - args->digestSz);\n            }\n        #endif\n\n            /* done with size calculations */\n            if (sizeOnly)\n                goto exit_buildmsg;\n\n            if (args->sz > (word32)outSz) {\n                WOLFSSL_MSG(\"Oops, want to write past output buffer size\");\n                ERROR_OUT(BUFFER_E, exit_buildmsg);\n            }\n\n            if (args->ivSz > 0) {\n                args->iv = (byte*)XMALLOC(args->ivSz, ssl->heap, DYNAMIC_TYPE_SALT);\n                if (args->iv == NULL)\n                    ERROR_OUT(MEMORY_E, exit_buildmsg);\n\n                ret = wc_RNG_GenerateBlock(ssl->rng, args->iv, args->ivSz);\n                if (ret != 0)\n                    goto exit_buildmsg;\n\n                XMEMSET(args->iv, 0, args->ivSz);\n            }\n#if !defined(NO_PUBLIC_GCM_SET_IV) && \\\n    ((defined(HAVE_FIPS) || defined(HAVE_SELFTEST)) && \\\n    (!defined(HAVE_FIPS_VERSION) || (HAVE_FIPS_VERSION < 2)) && \\\n    defined(HAVE_AEAD))\n            if (ssl->specs.cipher_type == aead) {\n                if (ssl->specs.bulk_cipher_algorithm != wolfssl_chacha)\n                    XMEMCPY(args->iv, ssl->keys.aead_exp_IV, AESGCM_EXP_IV_SZ);\n            }\n#endif\n\n            args->size = (word16)(args->sz - args->headerSz);    /* include mac and digest */\n            AddRecordHeader(output, args->size, (byte)type, ssl, epochOrder);\n\n            /* write to output */\n            if (args->ivSz > 0) {\n                XMEMCPY(output + args->idx, args->iv,\n                                        min(args->ivSz, MAX_IV_SZ));\n                args->idx += args->ivSz;\n            }\n            XMEMCPY(output + args->idx, input, inSz);\n            args->idx += inSz;\n\n            ssl->options.buildMsgState = BUILD_MSG_HASH;\n        }\n        FALL_THROUGH;\n        case BUILD_MSG_HASH:\n        {\n            if (type == handshake && hashOutput) {\n                ret = HashOutput(ssl, output, args->headerSz + inSz, args->ivSz);\n                if (ret != 0)\n                    goto exit_buildmsg;\n            }\n        #ifndef WOLFSSL_AEAD_ONLY\n            if (ssl->specs.cipher_type == block) {\n                word32 tmpIdx;\n                word32 i;\n\n            #if defined(HAVE_ENCRYPT_THEN_MAC) && !defined(WOLFSSL_AEAD_ONLY)\n                if (ssl->options.startedETMWrite)\n                    tmpIdx = args->idx;\n                else\n            #endif\n                    tmpIdx = args->idx + args->digestSz;\n\n                for (i = 0; i <= args->pad; i++)\n                    output[tmpIdx++] = (byte)args->pad; /* pad byte gets pad value */\n            }\n        #endif\n\n            ssl->options.buildMsgState = BUILD_MSG_VERIFY_MAC;\n        }\n        FALL_THROUGH;\n        case BUILD_MSG_VERIFY_MAC:\n        {\n            /* User Record Layer Callback handling */\n    #ifdef ATOMIC_USER\n        #if defined(HAVE_ENCRYPT_THEN_MAC) && !defined(WOLFSSL_AEAD_ONLY)\n            if (ssl->options.startedETMWrite) {\n                if (ssl->ctx->EncryptMacCb) {\n                    ret = ssl->ctx->EncryptMacCb(ssl, output + args->idx +\n                                                 args->pad + 1, type, 0,\n                                                 output + args->headerSz,\n                                                 output + args->headerSz,\n                                                 args->size - args->digestSz,\n                                                 ssl->MacEncryptCtx);\n                    goto exit_buildmsg;\n                }\n            }\n            else\n        #endif\n            {\n                if (ssl->ctx->MacEncryptCb) {\n                    ret = ssl->ctx->MacEncryptCb(ssl, output + args->idx,\n                                    output + args->headerSz + args->ivSz, inSz,\n                                    type, 0, output + args->headerSz,\n                                    output + args->headerSz, args->size,\n                                    ssl->MacEncryptCtx);\n                    goto exit_buildmsg;\n                }\n            }\n    #endif\n\n        #ifndef WOLFSSL_AEAD_ONLY\n            if (ssl->specs.cipher_type != aead\n            #if defined(HAVE_ENCRYPT_THEN_MAC) && !defined(WOLFSSL_AEAD_ONLY)\n                                               && !ssl->options.startedETMWrite\n            #endif\n                ) {\n            #ifdef HAVE_TRUNCATED_HMAC\n                if (ssl->truncated_hmac &&\n                                        ssl->specs.hash_size > args->digestSz) {\n                #ifdef WOLFSSL_SMALL_STACK\n                    byte* hmac;\n                #else\n                    byte  hmac[WC_MAX_DIGEST_SIZE];\n                #endif\n\n                #ifdef WOLFSSL_SMALL_STACK\n                    hmac = (byte*)XMALLOC(WC_MAX_DIGEST_SIZE, ssl->heap,\n                                                           DYNAMIC_TYPE_DIGEST);\n                    if (hmac == NULL)\n                        ERROR_OUT(MEMORY_E, exit_buildmsg);\n                #endif\n\n                    ret = ssl->hmac(ssl, hmac,\n                                     output + args->headerSz + args->ivSz, inSz,\n                                     -1, type, 0, epochOrder);\n                    XMEMCPY(output + args->idx, hmac, args->digestSz);\n\n                #ifdef WOLFSSL_SMALL_STACK\n                    XFREE(hmac, ssl->heap, DYNAMIC_TYPE_DIGEST);\n                #endif\n                }\n                else\n            #endif\n                {\n                    ret = ssl->hmac(ssl, output + args->idx, output +\n                                args->headerSz + args->ivSz, inSz, -1, type, 0, epochOrder);\n                }\n            }\n        #endif /* WOLFSSL_AEAD_ONLY */\n            if (ret != 0)\n                goto exit_buildmsg;\n\n            ssl->options.buildMsgState = BUILD_MSG_ENCRYPT;\n        }\n        FALL_THROUGH;\n        case BUILD_MSG_ENCRYPT:\n        {\n    #if defined(HAVE_SECURE_RENEGOTIATION) && defined(WOLFSSL_DTLS)\n            /* If we want the PREV_ORDER then modify CUR_ORDER sequence number\n             * for all encryption algos that use it for encryption parameters */\n            word16 dtls_epoch = 0;\n            word16 dtls_sequence_number_hi = 0;\n            word32 dtls_sequence_number_lo = 0;\n            int swap_seq = ssl->options.dtls && epochOrder == PREV_ORDER &&\n                    DtlsUseSCRKeys(ssl);\n            if (swap_seq) {\n                dtls_epoch = ssl->keys.dtls_epoch;\n                dtls_sequence_number_hi = ssl->keys.dtls_sequence_number_hi;\n                dtls_sequence_number_lo = ssl->keys.dtls_sequence_number_lo;\n                ssl->keys.dtls_epoch--;\n                ssl->keys.dtls_sequence_number_hi =\n                        ssl->keys.dtls_prev_sequence_number_hi;\n                ssl->keys.dtls_sequence_number_lo =\n                        ssl->keys.dtls_prev_sequence_number_lo;\n            }\n    #endif\n    #if defined(HAVE_ENCRYPT_THEN_MAC) && !defined(WOLFSSL_AEAD_ONLY)\n            if (ssl->options.startedETMWrite) {\n                ret = Encrypt(ssl, output + args->headerSz,\n                                          output + args->headerSz,\n                                          (word16)(args->size - args->digestSz),\n                                          asyncOkay);\n            }\n            else\n    #endif\n            {\n                ret = Encrypt(ssl, output + args->headerSz,\n                                output + args->headerSz, args->size, asyncOkay);\n            }\n    #if defined(HAVE_SECURE_RENEGOTIATION) && defined(WOLFSSL_DTLS)\n            /* Restore sequence numbers */\n            if (swap_seq) {\n                ssl->keys.dtls_epoch = dtls_epoch;\n                ssl->keys.dtls_sequence_number_hi = dtls_sequence_number_hi;\n                ssl->keys.dtls_sequence_number_lo = dtls_sequence_number_lo;\n            }\n    #endif\n            if (ret != 0)\n                goto exit_buildmsg;\n            ssl->options.buildMsgState = BUILD_MSG_ENCRYPTED_VERIFY_MAC;\n        }\n        FALL_THROUGH;\n        case BUILD_MSG_ENCRYPTED_VERIFY_MAC:\n        {\n        #if defined(HAVE_ENCRYPT_THEN_MAC) && !defined(WOLFSSL_AEAD_ONLY)\n            if (ssl->options.startedETMWrite) {\n                WOLFSSL_MSG(\"Calculate MAC of Encrypted Data\");\n\n            #ifdef HAVE_TRUNCATED_HMAC\n                if (ssl->truncated_hmac &&\n                                        ssl->specs.hash_size > args->digestSz) {\n                #ifdef WOLFSSL_SMALL_STACK\n                    byte* hmac = NULL;\n                #else\n                    byte  hmac[WC_MAX_DIGEST_SIZE];\n                #endif\n\n                #ifdef WOLFSSL_SMALL_STACK\n                    hmac = (byte*)XMALLOC(WC_MAX_DIGEST_SIZE, ssl->heap,\n                                                           DYNAMIC_TYPE_DIGEST);\n                    if (hmac == NULL)\n                        ERROR_OUT(MEMORY_E, exit_buildmsg);\n                #endif\n\n                    ret = ssl->hmac(ssl, hmac, output + args->headerSz,\n                                    args->ivSz + inSz + args->pad + 1, -1, type,\n                                    0, epochOrder);\n                    XMEMCPY(output + args->idx + args->pad + 1, hmac,\n                                                                args->digestSz);\n\n                #ifdef WOLFSSL_SMALL_STACK\n                    XFREE(hmac, ssl->heap, DYNAMIC_TYPE_DIGEST);\n                #endif\n                }\n                else\n            #endif\n                {\n                    ret = ssl->hmac(ssl, output + args->idx + args->pad + 1,\n                                    output + args->headerSz,\n                                    args->ivSz + inSz + args->pad + 1, -1, type,\n                                    0, epochOrder);\n                }\n            }\n        #endif /* HAVE_ENCRYPT_THEN_MAC && !WOLFSSL_AEAD_ONLY */\n        }\n        FALL_THROUGH;\n        default:\n            break;\n    }\n\nexit_buildmsg:\n\n    WOLFSSL_LEAVE(\"BuildMessage\", ret);\n\n#ifdef WOLFSSL_ASYNC_CRYPT\n    if (ret == WC_PENDING_E) {\n        return ret;\n    }\n#endif\n\n    /* make sure build message state is reset */\n    ssl->options.buildMsgState = BUILD_MSG_BEGIN;\n\n    #ifdef WOLFSSL_DTLS\n        if (ret == 0 && ssl->options.dtls && !sizeOnly)\n            DtlsSEQIncrement(ssl, epochOrder);\n    #endif\n\n    /* return sz on success */\n    if (ret == 0)\n        ret = args->sz;\n\n    /* Final cleanup */\n    FreeBuildMsgArgs(ssl, args);\n\n    return ret;\n#endif /* !WOLFSSL_NO_TLS12 */\n}",
        "func": "int BuildMessage(WOLFSSL* ssl, byte* output, int outSz, const byte* input,\n             int inSz, int type, int hashOutput, int sizeOnly, int asyncOkay,\n             int epochOrder)\n{\n#ifndef WOLFSSL_NO_TLS12\n    int ret;\n    BuildMsgArgs* args;\n    BuildMsgArgs  lcl_args;\n#ifdef WOLFSSL_ASYNC_CRYPT\n    args = &ssl->async.buildArgs;\n#endif\n#endif\n\n    WOLFSSL_ENTER(\"BuildMessage\");\n\n    if (ssl == NULL) {\n        return BAD_FUNC_ARG;\n    }\n\n    (void)epochOrder;\n\n#ifdef WOLFSSL_NO_TLS12\n    return BuildTls13Message(ssl, output, outSz, input, inSz, type,\n                                               hashOutput, sizeOnly, asyncOkay);\n#else\n#ifdef WOLFSSL_TLS13\n    if (ssl->options.tls1_3) {\n        return BuildTls13Message(ssl, output, outSz, input, inSz, type,\n                                 hashOutput, sizeOnly, asyncOkay);\n    }\n#endif\n\n#ifdef WOLFSSL_ASYNC_CRYPT\n    ret = WC_NOT_PENDING_E;\n    if (asyncOkay) {\n        ret = wolfSSL_AsyncPop(ssl, &ssl->options.buildMsgState);\n        if (ret != WC_NOT_PENDING_E) {\n            /* Check for error */\n            if (ret < 0)\n                goto exit_buildmsg;\n        }\n    }\n    else\n#endif\n    {\n        args = &lcl_args;\n    }\n\n    /* Reset state */\n#ifdef WOLFSSL_ASYNC_CRYPT\n    if (ret == WC_NOT_PENDING_E)\n#endif\n    {\n        ret = 0;\n        ssl->options.buildMsgState = BUILD_MSG_BEGIN;\n        XMEMSET(args, 0, sizeof(BuildMsgArgs));\n\n        args->sz = RECORD_HEADER_SZ + inSz;\n        args->idx  = RECORD_HEADER_SZ;\n        args->headerSz = RECORD_HEADER_SZ;\n    }\n\n    switch (ssl->options.buildMsgState) {\n        case BUILD_MSG_BEGIN:\n        {\n            /* catch mistaken sizeOnly parameter */\n            if (!sizeOnly && (output == NULL || input == NULL) ) {\n                ERROR_OUT(BAD_FUNC_ARG, exit_buildmsg);\n            }\n            if (sizeOnly && (output || input) ) {\n                WOLFSSL_MSG(\"BuildMessage w/sizeOnly doesn't need input/output\");\n                ERROR_OUT(BAD_FUNC_ARG, exit_buildmsg);\n            }\n        #if defined(WOLFSSL_DTLS) && defined(HAVE_SECURE_RENEGOTIATION)\n            if (ssl->options.dtls && DtlsSCRKeysSet(ssl)) {\n                /* For epochs >1 the current cipher parameters are located in\n                 * ssl->secure_renegotiation->tmp_keys. Previous cipher\n                 * parameters and for epoch 1 use ssl->keys */\n                switch (epochOrder) {\n                case PREV_ORDER:\n                    if (ssl->encrypt.src != KEYS) {\n                        ssl->secure_renegotiation->cache_status =\n                                SCR_CACHE_NULL;\n                        if ((ret = SetKeysSide(ssl, ENCRYPT_SIDE_ONLY)) != 0)\n                            ERROR_OUT(ret, exit_buildmsg);\n                    }\n                    break;\n                case CUR_ORDER:\n                    if (ssl->keys.dtls_epoch ==\n                            ssl->secure_renegotiation->tmp_keys.dtls_epoch) {\n                        if (ssl->encrypt.src != SCR) {\n                            ssl->secure_renegotiation->cache_status =\n                                    SCR_CACHE_NEEDED;\n                            if ((ret = SetKeysSide(ssl, ENCRYPT_SIDE_ONLY))\n                                    != 0)\n                                ERROR_OUT(ret, exit_buildmsg);\n                        }\n                    }\n                    else {\n                        if (ssl->encrypt.src != KEYS) {\n                            ssl->secure_renegotiation->cache_status =\n                                    SCR_CACHE_NULL;\n                            if ((ret = SetKeysSide(ssl, ENCRYPT_SIDE_ONLY))\n                                    != 0)\n                                ERROR_OUT(ret, exit_buildmsg);\n                        }\n                    }\n                    break;\n                default:\n                    WOLFSSL_MSG(\"BuildMessage only supports PREV_ORDER and \"\n                                \"CUR_ORDER\");\n                    ERROR_OUT(BAD_FUNC_ARG, exit_buildmsg);\n                }\n            }\n        #endif\n\n            ssl->options.buildMsgState = BUILD_MSG_SIZE;\n        }\n        FALL_THROUGH;\n        case BUILD_MSG_SIZE:\n        {\n            args->digestSz = ssl->specs.hash_size;\n        #ifdef HAVE_TRUNCATED_HMAC\n            if (ssl->truncated_hmac)\n                args->digestSz = min(TRUNCATED_HMAC_SZ, args->digestSz);\n        #endif\n            args->sz += args->digestSz;\n\n        #ifdef WOLFSSL_DTLS\n            if (ssl->options.dtls) {\n                args->sz       += DTLS_RECORD_EXTRA;\n                args->idx      += DTLS_RECORD_EXTRA;\n                args->headerSz += DTLS_RECORD_EXTRA;\n            }\n        #endif\n\n        #ifndef WOLFSSL_AEAD_ONLY\n            if (ssl->specs.cipher_type == block) {\n                word32 blockSz = ssl->specs.block_size;\n\n                if (blockSz == 0) {\n                    WOLFSSL_MSG(\"Invalid block size with block cipher type\");\n                    ERROR_OUT(BAD_STATE_E, exit_buildmsg);\n                }\n\n                if (ssl->options.tls1_1) {\n                    args->ivSz = blockSz;\n                    args->sz  += args->ivSz;\n\n                    if (args->ivSz > MAX_IV_SZ)\n                        ERROR_OUT(BUFFER_E, exit_buildmsg);\n                }\n                args->sz += 1;       /* pad byte */\n            #if defined(HAVE_ENCRYPT_THEN_MAC) && !defined(WOLFSSL_AEAD_ONLY)\n                if (ssl->options.startedETMWrite) {\n                    args->pad = (args->sz - args->headerSz -\n                                                      args->digestSz) % blockSz;\n                }\n                else\n            #endif\n                    args->pad = (args->sz - args->headerSz) % blockSz;\n                #ifdef OPENSSL_EXTRA\n                if(args->pad != 0)\n                #endif\n                    args->pad = blockSz - args->pad;\n                args->sz += args->pad;\n            }\n        #endif /* WOLFSSL_AEAD_ONLY */\n\n        #ifdef HAVE_AEAD\n            if (ssl->specs.cipher_type == aead) {\n                if (ssl->specs.bulk_cipher_algorithm != wolfssl_chacha)\n                    args->ivSz = AESGCM_EXP_IV_SZ;\n\n                args->sz += (args->ivSz + ssl->specs.aead_mac_size - args->digestSz);\n            }\n        #endif\n\n            /* done with size calculations */\n            if (sizeOnly)\n                goto exit_buildmsg;\n\n            if (args->sz > (word32)outSz) {\n                WOLFSSL_MSG(\"Oops, want to write past output buffer size\");\n                ERROR_OUT(BUFFER_E, exit_buildmsg);\n            }\n\n            if (args->ivSz > 0) {\n                args->iv = (byte*)XMALLOC(args->ivSz, ssl->heap, DYNAMIC_TYPE_SALT);\n                if (args->iv == NULL)\n                    ERROR_OUT(MEMORY_E, exit_buildmsg);\n\n                ret = wc_RNG_GenerateBlock(ssl->rng, args->iv, args->ivSz);\n                if (ret != 0)\n                    goto exit_buildmsg;\n            }\n#if !defined(NO_PUBLIC_GCM_SET_IV) && \\\n    ((defined(HAVE_FIPS) || defined(HAVE_SELFTEST)) && \\\n    (!defined(HAVE_FIPS_VERSION) || (HAVE_FIPS_VERSION < 2)) && \\\n    defined(HAVE_AEAD))\n            if (ssl->specs.cipher_type == aead) {\n                if (ssl->specs.bulk_cipher_algorithm != wolfssl_chacha)\n                    XMEMCPY(args->iv, ssl->keys.aead_exp_IV, AESGCM_EXP_IV_SZ);\n            }\n#endif\n\n            args->size = (word16)(args->sz - args->headerSz);    /* include mac and digest */\n            AddRecordHeader(output, args->size, (byte)type, ssl, epochOrder);\n\n            /* write to output */\n            if (args->ivSz > 0) {\n                XMEMCPY(output + args->idx, args->iv,\n                                        min(args->ivSz, MAX_IV_SZ));\n                args->idx += args->ivSz;\n            }\n            XMEMCPY(output + args->idx, input, inSz);\n            args->idx += inSz;\n\n            ssl->options.buildMsgState = BUILD_MSG_HASH;\n        }\n        FALL_THROUGH;\n        case BUILD_MSG_HASH:\n        {\n            if (type == handshake && hashOutput) {\n                ret = HashOutput(ssl, output, args->headerSz + inSz, args->ivSz);\n                if (ret != 0)\n                    goto exit_buildmsg;\n            }\n        #ifndef WOLFSSL_AEAD_ONLY\n            if (ssl->specs.cipher_type == block) {\n                word32 tmpIdx;\n                word32 i;\n\n            #if defined(HAVE_ENCRYPT_THEN_MAC) && !defined(WOLFSSL_AEAD_ONLY)\n                if (ssl->options.startedETMWrite)\n                    tmpIdx = args->idx;\n                else\n            #endif\n                    tmpIdx = args->idx + args->digestSz;\n\n                for (i = 0; i <= args->pad; i++)\n                    output[tmpIdx++] = (byte)args->pad; /* pad byte gets pad value */\n            }\n        #endif\n\n            ssl->options.buildMsgState = BUILD_MSG_VERIFY_MAC;\n        }\n        FALL_THROUGH;\n        case BUILD_MSG_VERIFY_MAC:\n        {\n            /* User Record Layer Callback handling */\n    #ifdef ATOMIC_USER\n        #if defined(HAVE_ENCRYPT_THEN_MAC) && !defined(WOLFSSL_AEAD_ONLY)\n            if (ssl->options.startedETMWrite) {\n                if (ssl->ctx->EncryptMacCb) {\n                    ret = ssl->ctx->EncryptMacCb(ssl, output + args->idx +\n                                                 args->pad + 1, type, 0,\n                                                 output + args->headerSz,\n                                                 output + args->headerSz,\n                                                 args->size - args->digestSz,\n                                                 ssl->MacEncryptCtx);\n                    goto exit_buildmsg;\n                }\n            }\n            else\n        #endif\n            {\n                if (ssl->ctx->MacEncryptCb) {\n                    ret = ssl->ctx->MacEncryptCb(ssl, output + args->idx,\n                                    output + args->headerSz + args->ivSz, inSz,\n                                    type, 0, output + args->headerSz,\n                                    output + args->headerSz, args->size,\n                                    ssl->MacEncryptCtx);\n                    goto exit_buildmsg;\n                }\n            }\n    #endif\n\n        #ifndef WOLFSSL_AEAD_ONLY\n            if (ssl->specs.cipher_type != aead\n            #if defined(HAVE_ENCRYPT_THEN_MAC) && !defined(WOLFSSL_AEAD_ONLY)\n                                               && !ssl->options.startedETMWrite\n            #endif\n                ) {\n            #ifdef HAVE_TRUNCATED_HMAC\n                if (ssl->truncated_hmac &&\n                                        ssl->specs.hash_size > args->digestSz) {\n                #ifdef WOLFSSL_SMALL_STACK\n                    byte* hmac;\n                #else\n                    byte  hmac[WC_MAX_DIGEST_SIZE];\n                #endif\n\n                #ifdef WOLFSSL_SMALL_STACK\n                    hmac = (byte*)XMALLOC(WC_MAX_DIGEST_SIZE, ssl->heap,\n                                                           DYNAMIC_TYPE_DIGEST);\n                    if (hmac == NULL)\n                        ERROR_OUT(MEMORY_E, exit_buildmsg);\n                #endif\n\n                    ret = ssl->hmac(ssl, hmac,\n                                     output + args->headerSz + args->ivSz, inSz,\n                                     -1, type, 0, epochOrder);\n                    XMEMCPY(output + args->idx, hmac, args->digestSz);\n\n                #ifdef WOLFSSL_SMALL_STACK\n                    XFREE(hmac, ssl->heap, DYNAMIC_TYPE_DIGEST);\n                #endif\n                }\n                else\n            #endif\n                {\n                    ret = ssl->hmac(ssl, output + args->idx, output +\n                                args->headerSz + args->ivSz, inSz, -1, type, 0, epochOrder);\n                }\n            }\n        #endif /* WOLFSSL_AEAD_ONLY */\n            if (ret != 0)\n                goto exit_buildmsg;\n\n            ssl->options.buildMsgState = BUILD_MSG_ENCRYPT;\n        }\n        FALL_THROUGH;\n        case BUILD_MSG_ENCRYPT:\n        {\n    #if defined(HAVE_SECURE_RENEGOTIATION) && defined(WOLFSSL_DTLS)\n            /* If we want the PREV_ORDER then modify CUR_ORDER sequence number\n             * for all encryption algos that use it for encryption parameters */\n            word16 dtls_epoch = 0;\n            word16 dtls_sequence_number_hi = 0;\n            word32 dtls_sequence_number_lo = 0;\n            int swap_seq = ssl->options.dtls && epochOrder == PREV_ORDER &&\n                    DtlsUseSCRKeys(ssl);\n            if (swap_seq) {\n                dtls_epoch = ssl->keys.dtls_epoch;\n                dtls_sequence_number_hi = ssl->keys.dtls_sequence_number_hi;\n                dtls_sequence_number_lo = ssl->keys.dtls_sequence_number_lo;\n                ssl->keys.dtls_epoch--;\n                ssl->keys.dtls_sequence_number_hi =\n                        ssl->keys.dtls_prev_sequence_number_hi;\n                ssl->keys.dtls_sequence_number_lo =\n                        ssl->keys.dtls_prev_sequence_number_lo;\n            }\n    #endif\n    #if defined(HAVE_ENCRYPT_THEN_MAC) && !defined(WOLFSSL_AEAD_ONLY)\n            if (ssl->options.startedETMWrite) {\n                ret = Encrypt(ssl, output + args->headerSz,\n                                          output + args->headerSz,\n                                          (word16)(args->size - args->digestSz),\n                                          asyncOkay);\n            }\n            else\n    #endif\n            {\n                ret = Encrypt(ssl, output + args->headerSz,\n                                output + args->headerSz, args->size, asyncOkay);\n            }\n    #if defined(HAVE_SECURE_RENEGOTIATION) && defined(WOLFSSL_DTLS)\n            /* Restore sequence numbers */\n            if (swap_seq) {\n                ssl->keys.dtls_epoch = dtls_epoch;\n                ssl->keys.dtls_sequence_number_hi = dtls_sequence_number_hi;\n                ssl->keys.dtls_sequence_number_lo = dtls_sequence_number_lo;\n            }\n    #endif\n            if (ret != 0)\n                goto exit_buildmsg;\n            ssl->options.buildMsgState = BUILD_MSG_ENCRYPTED_VERIFY_MAC;\n        }\n        FALL_THROUGH;\n        case BUILD_MSG_ENCRYPTED_VERIFY_MAC:\n        {\n        #if defined(HAVE_ENCRYPT_THEN_MAC) && !defined(WOLFSSL_AEAD_ONLY)\n            if (ssl->options.startedETMWrite) {\n                WOLFSSL_MSG(\"Calculate MAC of Encrypted Data\");\n\n            #ifdef HAVE_TRUNCATED_HMAC\n                if (ssl->truncated_hmac &&\n                                        ssl->specs.hash_size > args->digestSz) {\n                #ifdef WOLFSSL_SMALL_STACK\n                    byte* hmac = NULL;\n                #else\n                    byte  hmac[WC_MAX_DIGEST_SIZE];\n                #endif\n\n                #ifdef WOLFSSL_SMALL_STACK\n                    hmac = (byte*)XMALLOC(WC_MAX_DIGEST_SIZE, ssl->heap,\n                                                           DYNAMIC_TYPE_DIGEST);\n                    if (hmac == NULL)\n                        ERROR_OUT(MEMORY_E, exit_buildmsg);\n                #endif\n\n                    ret = ssl->hmac(ssl, hmac, output + args->headerSz,\n                                    args->ivSz + inSz + args->pad + 1, -1, type,\n                                    0, epochOrder);\n                    XMEMCPY(output + args->idx + args->pad + 1, hmac,\n                                                                args->digestSz);\n\n                #ifdef WOLFSSL_SMALL_STACK\n                    XFREE(hmac, ssl->heap, DYNAMIC_TYPE_DIGEST);\n                #endif\n                }\n                else\n            #endif\n                {\n                    ret = ssl->hmac(ssl, output + args->idx + args->pad + 1,\n                                    output + args->headerSz,\n                                    args->ivSz + inSz + args->pad + 1, -1, type,\n                                    0, epochOrder);\n                }\n            }\n        #endif /* HAVE_ENCRYPT_THEN_MAC && !WOLFSSL_AEAD_ONLY */\n        }\n        FALL_THROUGH;\n        default:\n            break;\n    }\n\nexit_buildmsg:\n\n    WOLFSSL_LEAVE(\"BuildMessage\", ret);\n\n#ifdef WOLFSSL_ASYNC_CRYPT\n    if (ret == WC_PENDING_E) {\n        return ret;\n    }\n#endif\n\n    /* make sure build message state is reset */\n    ssl->options.buildMsgState = BUILD_MSG_BEGIN;\n\n    #ifdef WOLFSSL_DTLS\n        if (ret == 0 && ssl->options.dtls && !sizeOnly)\n            DtlsSEQIncrement(ssl, epochOrder);\n    #endif\n\n    /* return sz on success */\n    if (ret == 0)\n        ret = args->sz;\n\n    /* Final cleanup */\n    FreeBuildMsgArgs(ssl, args);\n\n    return ret;\n#endif /* !WOLFSSL_NO_TLS12 */\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -193,8 +193,6 @@\n                 ret = wc_RNG_GenerateBlock(ssl->rng, args->iv, args->ivSz);\n                 if (ret != 0)\n                     goto exit_buildmsg;\n-\n-                XMEMSET(args->iv, 0, args->ivSz);\n             }\n #if !defined(NO_PUBLIC_GCM_SET_IV) && \\\n     ((defined(HAVE_FIPS) || defined(HAVE_SELFTEST)) && \\",
        "diff_line_info": {
            "deleted_lines": [
                "",
                "                XMEMSET(args->iv, 0, args->ivSz);"
            ],
            "added_lines": []
        }
    },
    {
        "cve_id": "CVE-2019-18282",
        "func_name": "torvalds/linux/hhf_classify",
        "description": "The flow_dissector feature in the Linux kernel 4.3 through 5.x before 5.3.10 has a device tracking vulnerability, aka CID-55667441c84f. This occurs because the auto flowlabel of a UDP IPv6 packet relies on a 32-bit hashrnd value as a secret, and because jhash (instead of siphash) is used. The hashrnd value remains the same starting from boot time, and can be inferred by an attacker. This affects net/core/flow_dissector.c and related code.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?h=55667441c84fa5e0911a0aac44fb059c15ba6da2",
        "commit_title": "UDP IPv6 packets auto flowlabels are using a 32bit secret",
        "commit_text": "(static u32 hashrnd in net/core/flow_dissector.c) and apply jhash() over fields known by the receivers.  Attackers can easily infer the 32bit secret and use this information to identify a device and/or user, since this 32bit secret is only set at boot time.  Really, using jhash() to generate cookies sent on the wire is a serious security concern.  Trying to change the rol32(hash, 16) in ip6_make_flowlabel() would be a dead end. Trying to periodically change the secret (like in sch_sfq.c) could change paths taken in the network for long lived flows.  Let's switch to siphash, as we did in commit df453700e8d8 (\"inet: switch IP ID generator to siphash\")  Using a cryptographically strong pseudo random function will solve this privacy issue and more generally remove other weak points in the stack.  Packet schedulers using skb_get_hash_perturb() benefit from this change.  Cc: Tom Herbert <tom@herbertland.com> ",
        "func_before": "static enum wdrr_bucket_idx hhf_classify(struct sk_buff *skb, struct Qdisc *sch)\n{\n\tstruct hhf_sched_data *q = qdisc_priv(sch);\n\tu32 tmp_hash, hash;\n\tu32 xorsum, filter_pos[HHF_ARRAYS_CNT], flow_pos;\n\tstruct hh_flow_state *flow;\n\tu32 pkt_len, min_hhf_val;\n\tint i;\n\tu32 prev;\n\tu32 now = hhf_time_stamp();\n\n\t/* Reset the HHF counter arrays if this is the right time. */\n\tprev = q->hhf_arrays_reset_timestamp + q->hhf_reset_timeout;\n\tif (hhf_time_before(prev, now)) {\n\t\tfor (i = 0; i < HHF_ARRAYS_CNT; i++)\n\t\t\tbitmap_zero(q->hhf_valid_bits[i], HHF_ARRAYS_LEN);\n\t\tq->hhf_arrays_reset_timestamp = now;\n\t}\n\n\t/* Get hashed flow-id of the skb. */\n\thash = skb_get_hash_perturb(skb, q->perturbation);\n\n\t/* Check if this packet belongs to an already established HH flow. */\n\tflow_pos = hash & HHF_BIT_MASK;\n\tflow = seek_list(hash, &q->hh_flows[flow_pos], q);\n\tif (flow) { /* found its HH flow */\n\t\tflow->hit_timestamp = now;\n\t\treturn WDRR_BUCKET_FOR_HH;\n\t}\n\n\t/* Now pass the packet through the multi-stage filter. */\n\ttmp_hash = hash;\n\txorsum = 0;\n\tfor (i = 0; i < HHF_ARRAYS_CNT - 1; i++) {\n\t\t/* Split the skb_hash into three 10-bit chunks. */\n\t\tfilter_pos[i] = tmp_hash & HHF_BIT_MASK;\n\t\txorsum ^= filter_pos[i];\n\t\ttmp_hash >>= HHF_BIT_MASK_LEN;\n\t}\n\t/* The last chunk is computed as XOR sum of other chunks. */\n\tfilter_pos[HHF_ARRAYS_CNT - 1] = xorsum ^ tmp_hash;\n\n\tpkt_len = qdisc_pkt_len(skb);\n\tmin_hhf_val = ~0U;\n\tfor (i = 0; i < HHF_ARRAYS_CNT; i++) {\n\t\tu32 val;\n\n\t\tif (!test_bit(filter_pos[i], q->hhf_valid_bits[i])) {\n\t\t\tq->hhf_arrays[i][filter_pos[i]] = 0;\n\t\t\t__set_bit(filter_pos[i], q->hhf_valid_bits[i]);\n\t\t}\n\n\t\tval = q->hhf_arrays[i][filter_pos[i]] + pkt_len;\n\t\tif (min_hhf_val > val)\n\t\t\tmin_hhf_val = val;\n\t}\n\n\t/* Found a new HH iff all counter values > HH admit threshold. */\n\tif (min_hhf_val > q->hhf_admit_bytes) {\n\t\t/* Just captured a new heavy-hitter. */\n\t\tflow = alloc_new_hh(&q->hh_flows[flow_pos], q);\n\t\tif (!flow) /* memory alloc problem */\n\t\t\treturn WDRR_BUCKET_FOR_NON_HH;\n\t\tflow->hash_id = hash;\n\t\tflow->hit_timestamp = now;\n\t\tq->hh_flows_total_cnt++;\n\n\t\t/* By returning without updating counters in q->hhf_arrays,\n\t\t * we implicitly implement \"shielding\" (see Optimization O1).\n\t\t */\n\t\treturn WDRR_BUCKET_FOR_HH;\n\t}\n\n\t/* Conservative update of HHF arrays (see Optimization O2). */\n\tfor (i = 0; i < HHF_ARRAYS_CNT; i++) {\n\t\tif (q->hhf_arrays[i][filter_pos[i]] < min_hhf_val)\n\t\t\tq->hhf_arrays[i][filter_pos[i]] = min_hhf_val;\n\t}\n\treturn WDRR_BUCKET_FOR_NON_HH;\n}",
        "func": "static enum wdrr_bucket_idx hhf_classify(struct sk_buff *skb, struct Qdisc *sch)\n{\n\tstruct hhf_sched_data *q = qdisc_priv(sch);\n\tu32 tmp_hash, hash;\n\tu32 xorsum, filter_pos[HHF_ARRAYS_CNT], flow_pos;\n\tstruct hh_flow_state *flow;\n\tu32 pkt_len, min_hhf_val;\n\tint i;\n\tu32 prev;\n\tu32 now = hhf_time_stamp();\n\n\t/* Reset the HHF counter arrays if this is the right time. */\n\tprev = q->hhf_arrays_reset_timestamp + q->hhf_reset_timeout;\n\tif (hhf_time_before(prev, now)) {\n\t\tfor (i = 0; i < HHF_ARRAYS_CNT; i++)\n\t\t\tbitmap_zero(q->hhf_valid_bits[i], HHF_ARRAYS_LEN);\n\t\tq->hhf_arrays_reset_timestamp = now;\n\t}\n\n\t/* Get hashed flow-id of the skb. */\n\thash = skb_get_hash_perturb(skb, &q->perturbation);\n\n\t/* Check if this packet belongs to an already established HH flow. */\n\tflow_pos = hash & HHF_BIT_MASK;\n\tflow = seek_list(hash, &q->hh_flows[flow_pos], q);\n\tif (flow) { /* found its HH flow */\n\t\tflow->hit_timestamp = now;\n\t\treturn WDRR_BUCKET_FOR_HH;\n\t}\n\n\t/* Now pass the packet through the multi-stage filter. */\n\ttmp_hash = hash;\n\txorsum = 0;\n\tfor (i = 0; i < HHF_ARRAYS_CNT - 1; i++) {\n\t\t/* Split the skb_hash into three 10-bit chunks. */\n\t\tfilter_pos[i] = tmp_hash & HHF_BIT_MASK;\n\t\txorsum ^= filter_pos[i];\n\t\ttmp_hash >>= HHF_BIT_MASK_LEN;\n\t}\n\t/* The last chunk is computed as XOR sum of other chunks. */\n\tfilter_pos[HHF_ARRAYS_CNT - 1] = xorsum ^ tmp_hash;\n\n\tpkt_len = qdisc_pkt_len(skb);\n\tmin_hhf_val = ~0U;\n\tfor (i = 0; i < HHF_ARRAYS_CNT; i++) {\n\t\tu32 val;\n\n\t\tif (!test_bit(filter_pos[i], q->hhf_valid_bits[i])) {\n\t\t\tq->hhf_arrays[i][filter_pos[i]] = 0;\n\t\t\t__set_bit(filter_pos[i], q->hhf_valid_bits[i]);\n\t\t}\n\n\t\tval = q->hhf_arrays[i][filter_pos[i]] + pkt_len;\n\t\tif (min_hhf_val > val)\n\t\t\tmin_hhf_val = val;\n\t}\n\n\t/* Found a new HH iff all counter values > HH admit threshold. */\n\tif (min_hhf_val > q->hhf_admit_bytes) {\n\t\t/* Just captured a new heavy-hitter. */\n\t\tflow = alloc_new_hh(&q->hh_flows[flow_pos], q);\n\t\tif (!flow) /* memory alloc problem */\n\t\t\treturn WDRR_BUCKET_FOR_NON_HH;\n\t\tflow->hash_id = hash;\n\t\tflow->hit_timestamp = now;\n\t\tq->hh_flows_total_cnt++;\n\n\t\t/* By returning without updating counters in q->hhf_arrays,\n\t\t * we implicitly implement \"shielding\" (see Optimization O1).\n\t\t */\n\t\treturn WDRR_BUCKET_FOR_HH;\n\t}\n\n\t/* Conservative update of HHF arrays (see Optimization O2). */\n\tfor (i = 0; i < HHF_ARRAYS_CNT; i++) {\n\t\tif (q->hhf_arrays[i][filter_pos[i]] < min_hhf_val)\n\t\t\tq->hhf_arrays[i][filter_pos[i]] = min_hhf_val;\n\t}\n\treturn WDRR_BUCKET_FOR_NON_HH;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -18,7 +18,7 @@\n \t}\n \n \t/* Get hashed flow-id of the skb. */\n-\thash = skb_get_hash_perturb(skb, q->perturbation);\n+\thash = skb_get_hash_perturb(skb, &q->perturbation);\n \n \t/* Check if this packet belongs to an already established HH flow. */\n \tflow_pos = hash & HHF_BIT_MASK;",
        "diff_line_info": {
            "deleted_lines": [
                "\thash = skb_get_hash_perturb(skb, q->perturbation);"
            ],
            "added_lines": [
                "\thash = skb_get_hash_perturb(skb, &q->perturbation);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-18282",
        "func_name": "torvalds/linux/hhf_init",
        "description": "The flow_dissector feature in the Linux kernel 4.3 through 5.x before 5.3.10 has a device tracking vulnerability, aka CID-55667441c84f. This occurs because the auto flowlabel of a UDP IPv6 packet relies on a 32-bit hashrnd value as a secret, and because jhash (instead of siphash) is used. The hashrnd value remains the same starting from boot time, and can be inferred by an attacker. This affects net/core/flow_dissector.c and related code.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?h=55667441c84fa5e0911a0aac44fb059c15ba6da2",
        "commit_title": "UDP IPv6 packets auto flowlabels are using a 32bit secret",
        "commit_text": "(static u32 hashrnd in net/core/flow_dissector.c) and apply jhash() over fields known by the receivers.  Attackers can easily infer the 32bit secret and use this information to identify a device and/or user, since this 32bit secret is only set at boot time.  Really, using jhash() to generate cookies sent on the wire is a serious security concern.  Trying to change the rol32(hash, 16) in ip6_make_flowlabel() would be a dead end. Trying to periodically change the secret (like in sch_sfq.c) could change paths taken in the network for long lived flows.  Let's switch to siphash, as we did in commit df453700e8d8 (\"inet: switch IP ID generator to siphash\")  Using a cryptographically strong pseudo random function will solve this privacy issue and more generally remove other weak points in the stack.  Packet schedulers using skb_get_hash_perturb() benefit from this change.  Cc: Tom Herbert <tom@herbertland.com> ",
        "func_before": "static int hhf_init(struct Qdisc *sch, struct nlattr *opt,\n\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct hhf_sched_data *q = qdisc_priv(sch);\n\tint i;\n\n\tsch->limit = 1000;\n\tq->quantum = psched_mtu(qdisc_dev(sch));\n\tq->perturbation = prandom_u32();\n\tINIT_LIST_HEAD(&q->new_buckets);\n\tINIT_LIST_HEAD(&q->old_buckets);\n\n\t/* Configurable HHF parameters */\n\tq->hhf_reset_timeout = HZ / 25; /* 40  ms */\n\tq->hhf_admit_bytes = 131072;    /* 128 KB */\n\tq->hhf_evict_timeout = HZ;      /* 1  sec */\n\tq->hhf_non_hh_weight = 2;\n\n\tif (opt) {\n\t\tint err = hhf_change(sch, opt, extack);\n\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (!q->hh_flows) {\n\t\t/* Initialize heavy-hitter flow table. */\n\t\tq->hh_flows = kvcalloc(HH_FLOWS_CNT, sizeof(struct list_head),\n\t\t\t\t       GFP_KERNEL);\n\t\tif (!q->hh_flows)\n\t\t\treturn -ENOMEM;\n\t\tfor (i = 0; i < HH_FLOWS_CNT; i++)\n\t\t\tINIT_LIST_HEAD(&q->hh_flows[i]);\n\n\t\t/* Cap max active HHs at twice len of hh_flows table. */\n\t\tq->hh_flows_limit = 2 * HH_FLOWS_CNT;\n\t\tq->hh_flows_overlimit = 0;\n\t\tq->hh_flows_total_cnt = 0;\n\t\tq->hh_flows_current_cnt = 0;\n\n\t\t/* Initialize heavy-hitter filter arrays. */\n\t\tfor (i = 0; i < HHF_ARRAYS_CNT; i++) {\n\t\t\tq->hhf_arrays[i] = kvcalloc(HHF_ARRAYS_LEN,\n\t\t\t\t\t\t    sizeof(u32),\n\t\t\t\t\t\t    GFP_KERNEL);\n\t\t\tif (!q->hhf_arrays[i]) {\n\t\t\t\t/* Note: hhf_destroy() will be called\n\t\t\t\t * by our caller.\n\t\t\t\t */\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t}\n\t\tq->hhf_arrays_reset_timestamp = hhf_time_stamp();\n\n\t\t/* Initialize valid bits of heavy-hitter filter arrays. */\n\t\tfor (i = 0; i < HHF_ARRAYS_CNT; i++) {\n\t\t\tq->hhf_valid_bits[i] = kvzalloc(HHF_ARRAYS_LEN /\n\t\t\t\t\t\t\t  BITS_PER_BYTE, GFP_KERNEL);\n\t\t\tif (!q->hhf_valid_bits[i]) {\n\t\t\t\t/* Note: hhf_destroy() will be called\n\t\t\t\t * by our caller.\n\t\t\t\t */\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t}\n\n\t\t/* Initialize Weighted DRR buckets. */\n\t\tfor (i = 0; i < WDRR_BUCKET_CNT; i++) {\n\t\t\tstruct wdrr_bucket *bucket = q->buckets + i;\n\n\t\t\tINIT_LIST_HEAD(&bucket->bucketchain);\n\t\t}\n\t}\n\n\treturn 0;\n}",
        "func": "static int hhf_init(struct Qdisc *sch, struct nlattr *opt,\n\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct hhf_sched_data *q = qdisc_priv(sch);\n\tint i;\n\n\tsch->limit = 1000;\n\tq->quantum = psched_mtu(qdisc_dev(sch));\n\tget_random_bytes(&q->perturbation, sizeof(q->perturbation));\n\tINIT_LIST_HEAD(&q->new_buckets);\n\tINIT_LIST_HEAD(&q->old_buckets);\n\n\t/* Configurable HHF parameters */\n\tq->hhf_reset_timeout = HZ / 25; /* 40  ms */\n\tq->hhf_admit_bytes = 131072;    /* 128 KB */\n\tq->hhf_evict_timeout = HZ;      /* 1  sec */\n\tq->hhf_non_hh_weight = 2;\n\n\tif (opt) {\n\t\tint err = hhf_change(sch, opt, extack);\n\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (!q->hh_flows) {\n\t\t/* Initialize heavy-hitter flow table. */\n\t\tq->hh_flows = kvcalloc(HH_FLOWS_CNT, sizeof(struct list_head),\n\t\t\t\t       GFP_KERNEL);\n\t\tif (!q->hh_flows)\n\t\t\treturn -ENOMEM;\n\t\tfor (i = 0; i < HH_FLOWS_CNT; i++)\n\t\t\tINIT_LIST_HEAD(&q->hh_flows[i]);\n\n\t\t/* Cap max active HHs at twice len of hh_flows table. */\n\t\tq->hh_flows_limit = 2 * HH_FLOWS_CNT;\n\t\tq->hh_flows_overlimit = 0;\n\t\tq->hh_flows_total_cnt = 0;\n\t\tq->hh_flows_current_cnt = 0;\n\n\t\t/* Initialize heavy-hitter filter arrays. */\n\t\tfor (i = 0; i < HHF_ARRAYS_CNT; i++) {\n\t\t\tq->hhf_arrays[i] = kvcalloc(HHF_ARRAYS_LEN,\n\t\t\t\t\t\t    sizeof(u32),\n\t\t\t\t\t\t    GFP_KERNEL);\n\t\t\tif (!q->hhf_arrays[i]) {\n\t\t\t\t/* Note: hhf_destroy() will be called\n\t\t\t\t * by our caller.\n\t\t\t\t */\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t}\n\t\tq->hhf_arrays_reset_timestamp = hhf_time_stamp();\n\n\t\t/* Initialize valid bits of heavy-hitter filter arrays. */\n\t\tfor (i = 0; i < HHF_ARRAYS_CNT; i++) {\n\t\t\tq->hhf_valid_bits[i] = kvzalloc(HHF_ARRAYS_LEN /\n\t\t\t\t\t\t\t  BITS_PER_BYTE, GFP_KERNEL);\n\t\t\tif (!q->hhf_valid_bits[i]) {\n\t\t\t\t/* Note: hhf_destroy() will be called\n\t\t\t\t * by our caller.\n\t\t\t\t */\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t}\n\n\t\t/* Initialize Weighted DRR buckets. */\n\t\tfor (i = 0; i < WDRR_BUCKET_CNT; i++) {\n\t\t\tstruct wdrr_bucket *bucket = q->buckets + i;\n\n\t\t\tINIT_LIST_HEAD(&bucket->bucketchain);\n\t\t}\n\t}\n\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,7 +6,7 @@\n \n \tsch->limit = 1000;\n \tq->quantum = psched_mtu(qdisc_dev(sch));\n-\tq->perturbation = prandom_u32();\n+\tget_random_bytes(&q->perturbation, sizeof(q->perturbation));\n \tINIT_LIST_HEAD(&q->new_buckets);\n \tINIT_LIST_HEAD(&q->old_buckets);\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\tq->perturbation = prandom_u32();"
            ],
            "added_lines": [
                "\tget_random_bytes(&q->perturbation, sizeof(q->perturbation));"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-18282",
        "func_name": "torvalds/linux/__skb_get_hash",
        "description": "The flow_dissector feature in the Linux kernel 4.3 through 5.x before 5.3.10 has a device tracking vulnerability, aka CID-55667441c84f. This occurs because the auto flowlabel of a UDP IPv6 packet relies on a 32-bit hashrnd value as a secret, and because jhash (instead of siphash) is used. The hashrnd value remains the same starting from boot time, and can be inferred by an attacker. This affects net/core/flow_dissector.c and related code.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?h=55667441c84fa5e0911a0aac44fb059c15ba6da2",
        "commit_title": "UDP IPv6 packets auto flowlabels are using a 32bit secret",
        "commit_text": "(static u32 hashrnd in net/core/flow_dissector.c) and apply jhash() over fields known by the receivers.  Attackers can easily infer the 32bit secret and use this information to identify a device and/or user, since this 32bit secret is only set at boot time.  Really, using jhash() to generate cookies sent on the wire is a serious security concern.  Trying to change the rol32(hash, 16) in ip6_make_flowlabel() would be a dead end. Trying to periodically change the secret (like in sch_sfq.c) could change paths taken in the network for long lived flows.  Let's switch to siphash, as we did in commit df453700e8d8 (\"inet: switch IP ID generator to siphash\")  Using a cryptographically strong pseudo random function will solve this privacy issue and more generally remove other weak points in the stack.  Packet schedulers using skb_get_hash_perturb() benefit from this change.  Cc: Tom Herbert <tom@herbertland.com> ",
        "func_before": "void __skb_get_hash(struct sk_buff *skb)\n{\n\tstruct flow_keys keys;\n\tu32 hash;\n\n\t__flow_hash_secret_init();\n\n\thash = ___skb_get_hash(skb, &keys, hashrnd);\n\n\t__skb_set_sw_hash(skb, hash, flow_keys_have_l4(&keys));\n}",
        "func": "void __skb_get_hash(struct sk_buff *skb)\n{\n\tstruct flow_keys keys;\n\tu32 hash;\n\n\t__flow_hash_secret_init();\n\n\thash = ___skb_get_hash(skb, &keys, &hashrnd);\n\n\t__skb_set_sw_hash(skb, hash, flow_keys_have_l4(&keys));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,7 +5,7 @@\n \n \t__flow_hash_secret_init();\n \n-\thash = ___skb_get_hash(skb, &keys, hashrnd);\n+\thash = ___skb_get_hash(skb, &keys, &hashrnd);\n \n \t__skb_set_sw_hash(skb, hash, flow_keys_have_l4(&keys));\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\thash = ___skb_get_hash(skb, &keys, hashrnd);"
            ],
            "added_lines": [
                "\thash = ___skb_get_hash(skb, &keys, &hashrnd);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-18282",
        "func_name": "torvalds/linux/skb_get_hash_perturb",
        "description": "The flow_dissector feature in the Linux kernel 4.3 through 5.x before 5.3.10 has a device tracking vulnerability, aka CID-55667441c84f. This occurs because the auto flowlabel of a UDP IPv6 packet relies on a 32-bit hashrnd value as a secret, and because jhash (instead of siphash) is used. The hashrnd value remains the same starting from boot time, and can be inferred by an attacker. This affects net/core/flow_dissector.c and related code.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?h=55667441c84fa5e0911a0aac44fb059c15ba6da2",
        "commit_title": "UDP IPv6 packets auto flowlabels are using a 32bit secret",
        "commit_text": "(static u32 hashrnd in net/core/flow_dissector.c) and apply jhash() over fields known by the receivers.  Attackers can easily infer the 32bit secret and use this information to identify a device and/or user, since this 32bit secret is only set at boot time.  Really, using jhash() to generate cookies sent on the wire is a serious security concern.  Trying to change the rol32(hash, 16) in ip6_make_flowlabel() would be a dead end. Trying to periodically change the secret (like in sch_sfq.c) could change paths taken in the network for long lived flows.  Let's switch to siphash, as we did in commit df453700e8d8 (\"inet: switch IP ID generator to siphash\")  Using a cryptographically strong pseudo random function will solve this privacy issue and more generally remove other weak points in the stack.  Packet schedulers using skb_get_hash_perturb() benefit from this change.  Cc: Tom Herbert <tom@herbertland.com> ",
        "func_before": "__u32 skb_get_hash_perturb(const struct sk_buff *skb, u32 perturb)\n{\n\tstruct flow_keys keys;\n\n\treturn ___skb_get_hash(skb, &keys, perturb);\n}",
        "func": "__u32 skb_get_hash_perturb(const struct sk_buff *skb,\n\t\t\t   const siphash_key_t *perturb)\n{\n\tstruct flow_keys keys;\n\n\treturn ___skb_get_hash(skb, &keys, perturb);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,5 @@\n-__u32 skb_get_hash_perturb(const struct sk_buff *skb, u32 perturb)\n+__u32 skb_get_hash_perturb(const struct sk_buff *skb,\n+\t\t\t   const siphash_key_t *perturb)\n {\n \tstruct flow_keys keys;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "__u32 skb_get_hash_perturb(const struct sk_buff *skb, u32 perturb)"
            ],
            "added_lines": [
                "__u32 skb_get_hash_perturb(const struct sk_buff *skb,",
                "\t\t\t   const siphash_key_t *perturb)"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-18282",
        "func_name": "torvalds/linux/__flow_hash_from_keys",
        "description": "The flow_dissector feature in the Linux kernel 4.3 through 5.x before 5.3.10 has a device tracking vulnerability, aka CID-55667441c84f. This occurs because the auto flowlabel of a UDP IPv6 packet relies on a 32-bit hashrnd value as a secret, and because jhash (instead of siphash) is used. The hashrnd value remains the same starting from boot time, and can be inferred by an attacker. This affects net/core/flow_dissector.c and related code.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?h=55667441c84fa5e0911a0aac44fb059c15ba6da2",
        "commit_title": "UDP IPv6 packets auto flowlabels are using a 32bit secret",
        "commit_text": "(static u32 hashrnd in net/core/flow_dissector.c) and apply jhash() over fields known by the receivers.  Attackers can easily infer the 32bit secret and use this information to identify a device and/or user, since this 32bit secret is only set at boot time.  Really, using jhash() to generate cookies sent on the wire is a serious security concern.  Trying to change the rol32(hash, 16) in ip6_make_flowlabel() would be a dead end. Trying to periodically change the secret (like in sch_sfq.c) could change paths taken in the network for long lived flows.  Let's switch to siphash, as we did in commit df453700e8d8 (\"inet: switch IP ID generator to siphash\")  Using a cryptographically strong pseudo random function will solve this privacy issue and more generally remove other weak points in the stack.  Packet schedulers using skb_get_hash_perturb() benefit from this change.  Cc: Tom Herbert <tom@herbertland.com> ",
        "func_before": "static inline u32 __flow_hash_from_keys(struct flow_keys *keys, u32 keyval)\n{\n\tu32 hash;\n\n\t__flow_hash_consistentify(keys);\n\n\thash = __flow_hash_words(flow_keys_hash_start(keys),\n\t\t\t\t flow_keys_hash_length(keys), keyval);\n\tif (!hash)\n\t\thash = 1;\n\n\treturn hash;\n}",
        "func": "static inline u32 __flow_hash_from_keys(struct flow_keys *keys,\n\t\t\t\t\tconst siphash_key_t *keyval)\n{\n\tu32 hash;\n\n\t__flow_hash_consistentify(keys);\n\n\thash = siphash(flow_keys_hash_start(keys),\n\t\t       flow_keys_hash_length(keys), keyval);\n\tif (!hash)\n\t\thash = 1;\n\n\treturn hash;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,11 +1,12 @@\n-static inline u32 __flow_hash_from_keys(struct flow_keys *keys, u32 keyval)\n+static inline u32 __flow_hash_from_keys(struct flow_keys *keys,\n+\t\t\t\t\tconst siphash_key_t *keyval)\n {\n \tu32 hash;\n \n \t__flow_hash_consistentify(keys);\n \n-\thash = __flow_hash_words(flow_keys_hash_start(keys),\n-\t\t\t\t flow_keys_hash_length(keys), keyval);\n+\thash = siphash(flow_keys_hash_start(keys),\n+\t\t       flow_keys_hash_length(keys), keyval);\n \tif (!hash)\n \t\thash = 1;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "static inline u32 __flow_hash_from_keys(struct flow_keys *keys, u32 keyval)",
                "\thash = __flow_hash_words(flow_keys_hash_start(keys),",
                "\t\t\t\t flow_keys_hash_length(keys), keyval);"
            ],
            "added_lines": [
                "static inline u32 __flow_hash_from_keys(struct flow_keys *keys,",
                "\t\t\t\t\tconst siphash_key_t *keyval)",
                "\thash = siphash(flow_keys_hash_start(keys),",
                "\t\t       flow_keys_hash_length(keys), keyval);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-18282",
        "func_name": "torvalds/linux/flow_keys_hash_start",
        "description": "The flow_dissector feature in the Linux kernel 4.3 through 5.x before 5.3.10 has a device tracking vulnerability, aka CID-55667441c84f. This occurs because the auto flowlabel of a UDP IPv6 packet relies on a 32-bit hashrnd value as a secret, and because jhash (instead of siphash) is used. The hashrnd value remains the same starting from boot time, and can be inferred by an attacker. This affects net/core/flow_dissector.c and related code.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?h=55667441c84fa5e0911a0aac44fb059c15ba6da2",
        "commit_title": "UDP IPv6 packets auto flowlabels are using a 32bit secret",
        "commit_text": "(static u32 hashrnd in net/core/flow_dissector.c) and apply jhash() over fields known by the receivers.  Attackers can easily infer the 32bit secret and use this information to identify a device and/or user, since this 32bit secret is only set at boot time.  Really, using jhash() to generate cookies sent on the wire is a serious security concern.  Trying to change the rol32(hash, 16) in ip6_make_flowlabel() would be a dead end. Trying to periodically change the secret (like in sch_sfq.c) could change paths taken in the network for long lived flows.  Let's switch to siphash, as we did in commit df453700e8d8 (\"inet: switch IP ID generator to siphash\")  Using a cryptographically strong pseudo random function will solve this privacy issue and more generally remove other weak points in the stack.  Packet schedulers using skb_get_hash_perturb() benefit from this change.  Cc: Tom Herbert <tom@herbertland.com> ",
        "func_before": "static inline const u32 *flow_keys_hash_start(const struct flow_keys *flow)\n{\n\tconst void *p = flow;\n\n\tBUILD_BUG_ON(FLOW_KEYS_HASH_OFFSET % sizeof(u32));\n\treturn (const u32 *)(p + FLOW_KEYS_HASH_OFFSET);\n}",
        "func": "static const void *flow_keys_hash_start(const struct flow_keys *flow)\n{\n\tBUILD_BUG_ON(FLOW_KEYS_HASH_OFFSET % SIPHASH_ALIGNMENT);\n\treturn &flow->FLOW_KEYS_HASH_START_FIELD;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,7 +1,5 @@\n-static inline const u32 *flow_keys_hash_start(const struct flow_keys *flow)\n+static const void *flow_keys_hash_start(const struct flow_keys *flow)\n {\n-\tconst void *p = flow;\n-\n-\tBUILD_BUG_ON(FLOW_KEYS_HASH_OFFSET % sizeof(u32));\n-\treturn (const u32 *)(p + FLOW_KEYS_HASH_OFFSET);\n+\tBUILD_BUG_ON(FLOW_KEYS_HASH_OFFSET % SIPHASH_ALIGNMENT);\n+\treturn &flow->FLOW_KEYS_HASH_START_FIELD;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "static inline const u32 *flow_keys_hash_start(const struct flow_keys *flow)",
                "\tconst void *p = flow;",
                "",
                "\tBUILD_BUG_ON(FLOW_KEYS_HASH_OFFSET % sizeof(u32));",
                "\treturn (const u32 *)(p + FLOW_KEYS_HASH_OFFSET);"
            ],
            "added_lines": [
                "static const void *flow_keys_hash_start(const struct flow_keys *flow)",
                "\tBUILD_BUG_ON(FLOW_KEYS_HASH_OFFSET % SIPHASH_ALIGNMENT);",
                "\treturn &flow->FLOW_KEYS_HASH_START_FIELD;"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-18282",
        "func_name": "torvalds/linux/flow_hash_from_keys",
        "description": "The flow_dissector feature in the Linux kernel 4.3 through 5.x before 5.3.10 has a device tracking vulnerability, aka CID-55667441c84f. This occurs because the auto flowlabel of a UDP IPv6 packet relies on a 32-bit hashrnd value as a secret, and because jhash (instead of siphash) is used. The hashrnd value remains the same starting from boot time, and can be inferred by an attacker. This affects net/core/flow_dissector.c and related code.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?h=55667441c84fa5e0911a0aac44fb059c15ba6da2",
        "commit_title": "UDP IPv6 packets auto flowlabels are using a 32bit secret",
        "commit_text": "(static u32 hashrnd in net/core/flow_dissector.c) and apply jhash() over fields known by the receivers.  Attackers can easily infer the 32bit secret and use this information to identify a device and/or user, since this 32bit secret is only set at boot time.  Really, using jhash() to generate cookies sent on the wire is a serious security concern.  Trying to change the rol32(hash, 16) in ip6_make_flowlabel() would be a dead end. Trying to periodically change the secret (like in sch_sfq.c) could change paths taken in the network for long lived flows.  Let's switch to siphash, as we did in commit df453700e8d8 (\"inet: switch IP ID generator to siphash\")  Using a cryptographically strong pseudo random function will solve this privacy issue and more generally remove other weak points in the stack.  Packet schedulers using skb_get_hash_perturb() benefit from this change.  Cc: Tom Herbert <tom@herbertland.com> ",
        "func_before": "u32 flow_hash_from_keys(struct flow_keys *keys)\n{\n\t__flow_hash_secret_init();\n\treturn __flow_hash_from_keys(keys, hashrnd);\n}",
        "func": "u32 flow_hash_from_keys(struct flow_keys *keys)\n{\n\t__flow_hash_secret_init();\n\treturn __flow_hash_from_keys(keys, &hashrnd);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,5 @@\n u32 flow_hash_from_keys(struct flow_keys *keys)\n {\n \t__flow_hash_secret_init();\n-\treturn __flow_hash_from_keys(keys, hashrnd);\n+\treturn __flow_hash_from_keys(keys, &hashrnd);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\treturn __flow_hash_from_keys(keys, hashrnd);"
            ],
            "added_lines": [
                "\treturn __flow_hash_from_keys(keys, &hashrnd);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-18282",
        "func_name": "torvalds/linux/flow_keys_hash_length",
        "description": "The flow_dissector feature in the Linux kernel 4.3 through 5.x before 5.3.10 has a device tracking vulnerability, aka CID-55667441c84f. This occurs because the auto flowlabel of a UDP IPv6 packet relies on a 32-bit hashrnd value as a secret, and because jhash (instead of siphash) is used. The hashrnd value remains the same starting from boot time, and can be inferred by an attacker. This affects net/core/flow_dissector.c and related code.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?h=55667441c84fa5e0911a0aac44fb059c15ba6da2",
        "commit_title": "UDP IPv6 packets auto flowlabels are using a 32bit secret",
        "commit_text": "(static u32 hashrnd in net/core/flow_dissector.c) and apply jhash() over fields known by the receivers.  Attackers can easily infer the 32bit secret and use this information to identify a device and/or user, since this 32bit secret is only set at boot time.  Really, using jhash() to generate cookies sent on the wire is a serious security concern.  Trying to change the rol32(hash, 16) in ip6_make_flowlabel() would be a dead end. Trying to periodically change the secret (like in sch_sfq.c) could change paths taken in the network for long lived flows.  Let's switch to siphash, as we did in commit df453700e8d8 (\"inet: switch IP ID generator to siphash\")  Using a cryptographically strong pseudo random function will solve this privacy issue and more generally remove other weak points in the stack.  Packet schedulers using skb_get_hash_perturb() benefit from this change.  Cc: Tom Herbert <tom@herbertland.com> ",
        "func_before": "static inline size_t flow_keys_hash_length(const struct flow_keys *flow)\n{\n\tsize_t diff = FLOW_KEYS_HASH_OFFSET + sizeof(flow->addrs);\n\tBUILD_BUG_ON((sizeof(*flow) - FLOW_KEYS_HASH_OFFSET) % sizeof(u32));\n\tBUILD_BUG_ON(offsetof(typeof(*flow), addrs) !=\n\t\t     sizeof(*flow) - sizeof(flow->addrs));\n\n\tswitch (flow->control.addr_type) {\n\tcase FLOW_DISSECTOR_KEY_IPV4_ADDRS:\n\t\tdiff -= sizeof(flow->addrs.v4addrs);\n\t\tbreak;\n\tcase FLOW_DISSECTOR_KEY_IPV6_ADDRS:\n\t\tdiff -= sizeof(flow->addrs.v6addrs);\n\t\tbreak;\n\tcase FLOW_DISSECTOR_KEY_TIPC:\n\t\tdiff -= sizeof(flow->addrs.tipckey);\n\t\tbreak;\n\t}\n\treturn (sizeof(*flow) - diff) / sizeof(u32);\n}",
        "func": "static inline size_t flow_keys_hash_length(const struct flow_keys *flow)\n{\n\tsize_t diff = FLOW_KEYS_HASH_OFFSET + sizeof(flow->addrs);\n\tBUILD_BUG_ON(offsetof(typeof(*flow), addrs) !=\n\t\t     sizeof(*flow) - sizeof(flow->addrs));\n\n\tswitch (flow->control.addr_type) {\n\tcase FLOW_DISSECTOR_KEY_IPV4_ADDRS:\n\t\tdiff -= sizeof(flow->addrs.v4addrs);\n\t\tbreak;\n\tcase FLOW_DISSECTOR_KEY_IPV6_ADDRS:\n\t\tdiff -= sizeof(flow->addrs.v6addrs);\n\t\tbreak;\n\tcase FLOW_DISSECTOR_KEY_TIPC:\n\t\tdiff -= sizeof(flow->addrs.tipckey);\n\t\tbreak;\n\t}\n\treturn sizeof(*flow) - diff;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,7 +1,6 @@\n static inline size_t flow_keys_hash_length(const struct flow_keys *flow)\n {\n \tsize_t diff = FLOW_KEYS_HASH_OFFSET + sizeof(flow->addrs);\n-\tBUILD_BUG_ON((sizeof(*flow) - FLOW_KEYS_HASH_OFFSET) % sizeof(u32));\n \tBUILD_BUG_ON(offsetof(typeof(*flow), addrs) !=\n \t\t     sizeof(*flow) - sizeof(flow->addrs));\n \n@@ -16,5 +15,5 @@\n \t\tdiff -= sizeof(flow->addrs.tipckey);\n \t\tbreak;\n \t}\n-\treturn (sizeof(*flow) - diff) / sizeof(u32);\n+\treturn sizeof(*flow) - diff;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tBUILD_BUG_ON((sizeof(*flow) - FLOW_KEYS_HASH_OFFSET) % sizeof(u32));",
                "\treturn (sizeof(*flow) - diff) / sizeof(u32);"
            ],
            "added_lines": [
                "\treturn sizeof(*flow) - diff;"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-18282",
        "func_name": "torvalds/linux/___skb_get_hash",
        "description": "The flow_dissector feature in the Linux kernel 4.3 through 5.x before 5.3.10 has a device tracking vulnerability, aka CID-55667441c84f. This occurs because the auto flowlabel of a UDP IPv6 packet relies on a 32-bit hashrnd value as a secret, and because jhash (instead of siphash) is used. The hashrnd value remains the same starting from boot time, and can be inferred by an attacker. This affects net/core/flow_dissector.c and related code.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?h=55667441c84fa5e0911a0aac44fb059c15ba6da2",
        "commit_title": "UDP IPv6 packets auto flowlabels are using a 32bit secret",
        "commit_text": "(static u32 hashrnd in net/core/flow_dissector.c) and apply jhash() over fields known by the receivers.  Attackers can easily infer the 32bit secret and use this information to identify a device and/or user, since this 32bit secret is only set at boot time.  Really, using jhash() to generate cookies sent on the wire is a serious security concern.  Trying to change the rol32(hash, 16) in ip6_make_flowlabel() would be a dead end. Trying to periodically change the secret (like in sch_sfq.c) could change paths taken in the network for long lived flows.  Let's switch to siphash, as we did in commit df453700e8d8 (\"inet: switch IP ID generator to siphash\")  Using a cryptographically strong pseudo random function will solve this privacy issue and more generally remove other weak points in the stack.  Packet schedulers using skb_get_hash_perturb() benefit from this change.  Cc: Tom Herbert <tom@herbertland.com> ",
        "func_before": "static inline u32 ___skb_get_hash(const struct sk_buff *skb,\n\t\t\t\t  struct flow_keys *keys, u32 keyval)\n{\n\tskb_flow_dissect_flow_keys(skb, keys,\n\t\t\t\t   FLOW_DISSECTOR_F_STOP_AT_FLOW_LABEL);\n\n\treturn __flow_hash_from_keys(keys, keyval);\n}",
        "func": "static inline u32 ___skb_get_hash(const struct sk_buff *skb,\n\t\t\t\t  struct flow_keys *keys,\n\t\t\t\t  const siphash_key_t *keyval)\n{\n\tskb_flow_dissect_flow_keys(skb, keys,\n\t\t\t\t   FLOW_DISSECTOR_F_STOP_AT_FLOW_LABEL);\n\n\treturn __flow_hash_from_keys(keys, keyval);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,6 @@\n static inline u32 ___skb_get_hash(const struct sk_buff *skb,\n-\t\t\t\t  struct flow_keys *keys, u32 keyval)\n+\t\t\t\t  struct flow_keys *keys,\n+\t\t\t\t  const siphash_key_t *keyval)\n {\n \tskb_flow_dissect_flow_keys(skb, keys,\n \t\t\t\t   FLOW_DISSECTOR_F_STOP_AT_FLOW_LABEL);",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\t\t  struct flow_keys *keys, u32 keyval)"
            ],
            "added_lines": [
                "\t\t\t\t  struct flow_keys *keys,",
                "\t\t\t\t  const siphash_key_t *keyval)"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-18282",
        "func_name": "torvalds/linux/__skb_get_hash_symmetric",
        "description": "The flow_dissector feature in the Linux kernel 4.3 through 5.x before 5.3.10 has a device tracking vulnerability, aka CID-55667441c84f. This occurs because the auto flowlabel of a UDP IPv6 packet relies on a 32-bit hashrnd value as a secret, and because jhash (instead of siphash) is used. The hashrnd value remains the same starting from boot time, and can be inferred by an attacker. This affects net/core/flow_dissector.c and related code.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?h=55667441c84fa5e0911a0aac44fb059c15ba6da2",
        "commit_title": "UDP IPv6 packets auto flowlabels are using a 32bit secret",
        "commit_text": "(static u32 hashrnd in net/core/flow_dissector.c) and apply jhash() over fields known by the receivers.  Attackers can easily infer the 32bit secret and use this information to identify a device and/or user, since this 32bit secret is only set at boot time.  Really, using jhash() to generate cookies sent on the wire is a serious security concern.  Trying to change the rol32(hash, 16) in ip6_make_flowlabel() would be a dead end. Trying to periodically change the secret (like in sch_sfq.c) could change paths taken in the network for long lived flows.  Let's switch to siphash, as we did in commit df453700e8d8 (\"inet: switch IP ID generator to siphash\")  Using a cryptographically strong pseudo random function will solve this privacy issue and more generally remove other weak points in the stack.  Packet schedulers using skb_get_hash_perturb() benefit from this change.  Cc: Tom Herbert <tom@herbertland.com> ",
        "func_before": "u32 __skb_get_hash_symmetric(const struct sk_buff *skb)\n{\n\tstruct flow_keys keys;\n\n\t__flow_hash_secret_init();\n\n\tmemset(&keys, 0, sizeof(keys));\n\t__skb_flow_dissect(NULL, skb, &flow_keys_dissector_symmetric,\n\t\t\t   &keys, NULL, 0, 0, 0,\n\t\t\t   FLOW_DISSECTOR_F_STOP_AT_FLOW_LABEL);\n\n\treturn __flow_hash_from_keys(&keys, hashrnd);\n}",
        "func": "u32 __skb_get_hash_symmetric(const struct sk_buff *skb)\n{\n\tstruct flow_keys keys;\n\n\t__flow_hash_secret_init();\n\n\tmemset(&keys, 0, sizeof(keys));\n\t__skb_flow_dissect(NULL, skb, &flow_keys_dissector_symmetric,\n\t\t\t   &keys, NULL, 0, 0, 0,\n\t\t\t   FLOW_DISSECTOR_F_STOP_AT_FLOW_LABEL);\n\n\treturn __flow_hash_from_keys(&keys, &hashrnd);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -9,5 +9,5 @@\n \t\t\t   &keys, NULL, 0, 0, 0,\n \t\t\t   FLOW_DISSECTOR_F_STOP_AT_FLOW_LABEL);\n \n-\treturn __flow_hash_from_keys(&keys, hashrnd);\n+\treturn __flow_hash_from_keys(&keys, &hashrnd);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\treturn __flow_hash_from_keys(&keys, hashrnd);"
            ],
            "added_lines": [
                "\treturn __flow_hash_from_keys(&keys, &hashrnd);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-18282",
        "func_name": "torvalds/linux/sfb_enqueue",
        "description": "The flow_dissector feature in the Linux kernel 4.3 through 5.x before 5.3.10 has a device tracking vulnerability, aka CID-55667441c84f. This occurs because the auto flowlabel of a UDP IPv6 packet relies on a 32-bit hashrnd value as a secret, and because jhash (instead of siphash) is used. The hashrnd value remains the same starting from boot time, and can be inferred by an attacker. This affects net/core/flow_dissector.c and related code.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?h=55667441c84fa5e0911a0aac44fb059c15ba6da2",
        "commit_title": "UDP IPv6 packets auto flowlabels are using a 32bit secret",
        "commit_text": "(static u32 hashrnd in net/core/flow_dissector.c) and apply jhash() over fields known by the receivers.  Attackers can easily infer the 32bit secret and use this information to identify a device and/or user, since this 32bit secret is only set at boot time.  Really, using jhash() to generate cookies sent on the wire is a serious security concern.  Trying to change the rol32(hash, 16) in ip6_make_flowlabel() would be a dead end. Trying to periodically change the secret (like in sch_sfq.c) could change paths taken in the network for long lived flows.  Let's switch to siphash, as we did in commit df453700e8d8 (\"inet: switch IP ID generator to siphash\")  Using a cryptographically strong pseudo random function will solve this privacy issue and more generally remove other weak points in the stack.  Packet schedulers using skb_get_hash_perturb() benefit from this change.  Cc: Tom Herbert <tom@herbertland.com> ",
        "func_before": "static int sfb_enqueue(struct sk_buff *skb, struct Qdisc *sch,\n\t\t       struct sk_buff **to_free)\n{\n\n\tstruct sfb_sched_data *q = qdisc_priv(sch);\n\tstruct Qdisc *child = q->qdisc;\n\tstruct tcf_proto *fl;\n\tint i;\n\tu32 p_min = ~0;\n\tu32 minqlen = ~0;\n\tu32 r, sfbhash;\n\tu32 slot = q->slot;\n\tint ret = NET_XMIT_SUCCESS | __NET_XMIT_BYPASS;\n\n\tif (unlikely(sch->q.qlen >= q->limit)) {\n\t\tqdisc_qstats_overlimit(sch);\n\t\tq->stats.queuedrop++;\n\t\tgoto drop;\n\t}\n\n\tif (q->rehash_interval > 0) {\n\t\tunsigned long limit = q->rehash_time + q->rehash_interval;\n\n\t\tif (unlikely(time_after(jiffies, limit))) {\n\t\t\tsfb_swap_slot(q);\n\t\t\tq->rehash_time = jiffies;\n\t\t} else if (unlikely(!q->double_buffering && q->warmup_time > 0 &&\n\t\t\t\t    time_after(jiffies, limit - q->warmup_time))) {\n\t\t\tq->double_buffering = true;\n\t\t}\n\t}\n\n\tfl = rcu_dereference_bh(q->filter_list);\n\tif (fl) {\n\t\tu32 salt;\n\n\t\t/* If using external classifiers, get result and record it. */\n\t\tif (!sfb_classify(skb, fl, &ret, &salt))\n\t\t\tgoto other_drop;\n\t\tsfbhash = jhash_1word(salt, q->bins[slot].perturbation);\n\t} else {\n\t\tsfbhash = skb_get_hash_perturb(skb, q->bins[slot].perturbation);\n\t}\n\n\n\tif (!sfbhash)\n\t\tsfbhash = 1;\n\tsfb_skb_cb(skb)->hashes[slot] = sfbhash;\n\n\tfor (i = 0; i < SFB_LEVELS; i++) {\n\t\tu32 hash = sfbhash & SFB_BUCKET_MASK;\n\t\tstruct sfb_bucket *b = &q->bins[slot].bins[i][hash];\n\n\t\tsfbhash >>= SFB_BUCKET_SHIFT;\n\t\tif (b->qlen == 0)\n\t\t\tdecrement_prob(b, q);\n\t\telse if (b->qlen >= q->bin_size)\n\t\t\tincrement_prob(b, q);\n\t\tif (minqlen > b->qlen)\n\t\t\tminqlen = b->qlen;\n\t\tif (p_min > b->p_mark)\n\t\t\tp_min = b->p_mark;\n\t}\n\n\tslot ^= 1;\n\tsfb_skb_cb(skb)->hashes[slot] = 0;\n\n\tif (unlikely(minqlen >= q->max)) {\n\t\tqdisc_qstats_overlimit(sch);\n\t\tq->stats.bucketdrop++;\n\t\tgoto drop;\n\t}\n\n\tif (unlikely(p_min >= SFB_MAX_PROB)) {\n\t\t/* Inelastic flow */\n\t\tif (q->double_buffering) {\n\t\t\tsfbhash = skb_get_hash_perturb(skb,\n\t\t\t    q->bins[slot].perturbation);\n\t\t\tif (!sfbhash)\n\t\t\t\tsfbhash = 1;\n\t\t\tsfb_skb_cb(skb)->hashes[slot] = sfbhash;\n\n\t\t\tfor (i = 0; i < SFB_LEVELS; i++) {\n\t\t\t\tu32 hash = sfbhash & SFB_BUCKET_MASK;\n\t\t\t\tstruct sfb_bucket *b = &q->bins[slot].bins[i][hash];\n\n\t\t\t\tsfbhash >>= SFB_BUCKET_SHIFT;\n\t\t\t\tif (b->qlen == 0)\n\t\t\t\t\tdecrement_prob(b, q);\n\t\t\t\telse if (b->qlen >= q->bin_size)\n\t\t\t\t\tincrement_prob(b, q);\n\t\t\t}\n\t\t}\n\t\tif (sfb_rate_limit(skb, q)) {\n\t\t\tqdisc_qstats_overlimit(sch);\n\t\t\tq->stats.penaltydrop++;\n\t\t\tgoto drop;\n\t\t}\n\t\tgoto enqueue;\n\t}\n\n\tr = prandom_u32() & SFB_MAX_PROB;\n\n\tif (unlikely(r < p_min)) {\n\t\tif (unlikely(p_min > SFB_MAX_PROB / 2)) {\n\t\t\t/* If we're marking that many packets, then either\n\t\t\t * this flow is unresponsive, or we're badly congested.\n\t\t\t * In either case, we want to start dropping packets.\n\t\t\t */\n\t\t\tif (r < (p_min - SFB_MAX_PROB / 2) * 2) {\n\t\t\t\tq->stats.earlydrop++;\n\t\t\t\tgoto drop;\n\t\t\t}\n\t\t}\n\t\tif (INET_ECN_set_ce(skb)) {\n\t\t\tq->stats.marked++;\n\t\t} else {\n\t\t\tq->stats.earlydrop++;\n\t\t\tgoto drop;\n\t\t}\n\t}\n\nenqueue:\n\tret = qdisc_enqueue(skb, child, to_free);\n\tif (likely(ret == NET_XMIT_SUCCESS)) {\n\t\tqdisc_qstats_backlog_inc(sch, skb);\n\t\tsch->q.qlen++;\n\t\tincrement_qlen(skb, q);\n\t} else if (net_xmit_drop_count(ret)) {\n\t\tq->stats.childdrop++;\n\t\tqdisc_qstats_drop(sch);\n\t}\n\treturn ret;\n\ndrop:\n\tqdisc_drop(skb, sch, to_free);\n\treturn NET_XMIT_CN;\nother_drop:\n\tif (ret & __NET_XMIT_BYPASS)\n\t\tqdisc_qstats_drop(sch);\n\tkfree_skb(skb);\n\treturn ret;\n}",
        "func": "static int sfb_enqueue(struct sk_buff *skb, struct Qdisc *sch,\n\t\t       struct sk_buff **to_free)\n{\n\n\tstruct sfb_sched_data *q = qdisc_priv(sch);\n\tstruct Qdisc *child = q->qdisc;\n\tstruct tcf_proto *fl;\n\tint i;\n\tu32 p_min = ~0;\n\tu32 minqlen = ~0;\n\tu32 r, sfbhash;\n\tu32 slot = q->slot;\n\tint ret = NET_XMIT_SUCCESS | __NET_XMIT_BYPASS;\n\n\tif (unlikely(sch->q.qlen >= q->limit)) {\n\t\tqdisc_qstats_overlimit(sch);\n\t\tq->stats.queuedrop++;\n\t\tgoto drop;\n\t}\n\n\tif (q->rehash_interval > 0) {\n\t\tunsigned long limit = q->rehash_time + q->rehash_interval;\n\n\t\tif (unlikely(time_after(jiffies, limit))) {\n\t\t\tsfb_swap_slot(q);\n\t\t\tq->rehash_time = jiffies;\n\t\t} else if (unlikely(!q->double_buffering && q->warmup_time > 0 &&\n\t\t\t\t    time_after(jiffies, limit - q->warmup_time))) {\n\t\t\tq->double_buffering = true;\n\t\t}\n\t}\n\n\tfl = rcu_dereference_bh(q->filter_list);\n\tif (fl) {\n\t\tu32 salt;\n\n\t\t/* If using external classifiers, get result and record it. */\n\t\tif (!sfb_classify(skb, fl, &ret, &salt))\n\t\t\tgoto other_drop;\n\t\tsfbhash = siphash_1u32(salt, &q->bins[slot].perturbation);\n\t} else {\n\t\tsfbhash = skb_get_hash_perturb(skb, &q->bins[slot].perturbation);\n\t}\n\n\n\tif (!sfbhash)\n\t\tsfbhash = 1;\n\tsfb_skb_cb(skb)->hashes[slot] = sfbhash;\n\n\tfor (i = 0; i < SFB_LEVELS; i++) {\n\t\tu32 hash = sfbhash & SFB_BUCKET_MASK;\n\t\tstruct sfb_bucket *b = &q->bins[slot].bins[i][hash];\n\n\t\tsfbhash >>= SFB_BUCKET_SHIFT;\n\t\tif (b->qlen == 0)\n\t\t\tdecrement_prob(b, q);\n\t\telse if (b->qlen >= q->bin_size)\n\t\t\tincrement_prob(b, q);\n\t\tif (minqlen > b->qlen)\n\t\t\tminqlen = b->qlen;\n\t\tif (p_min > b->p_mark)\n\t\t\tp_min = b->p_mark;\n\t}\n\n\tslot ^= 1;\n\tsfb_skb_cb(skb)->hashes[slot] = 0;\n\n\tif (unlikely(minqlen >= q->max)) {\n\t\tqdisc_qstats_overlimit(sch);\n\t\tq->stats.bucketdrop++;\n\t\tgoto drop;\n\t}\n\n\tif (unlikely(p_min >= SFB_MAX_PROB)) {\n\t\t/* Inelastic flow */\n\t\tif (q->double_buffering) {\n\t\t\tsfbhash = skb_get_hash_perturb(skb,\n\t\t\t    &q->bins[slot].perturbation);\n\t\t\tif (!sfbhash)\n\t\t\t\tsfbhash = 1;\n\t\t\tsfb_skb_cb(skb)->hashes[slot] = sfbhash;\n\n\t\t\tfor (i = 0; i < SFB_LEVELS; i++) {\n\t\t\t\tu32 hash = sfbhash & SFB_BUCKET_MASK;\n\t\t\t\tstruct sfb_bucket *b = &q->bins[slot].bins[i][hash];\n\n\t\t\t\tsfbhash >>= SFB_BUCKET_SHIFT;\n\t\t\t\tif (b->qlen == 0)\n\t\t\t\t\tdecrement_prob(b, q);\n\t\t\t\telse if (b->qlen >= q->bin_size)\n\t\t\t\t\tincrement_prob(b, q);\n\t\t\t}\n\t\t}\n\t\tif (sfb_rate_limit(skb, q)) {\n\t\t\tqdisc_qstats_overlimit(sch);\n\t\t\tq->stats.penaltydrop++;\n\t\t\tgoto drop;\n\t\t}\n\t\tgoto enqueue;\n\t}\n\n\tr = prandom_u32() & SFB_MAX_PROB;\n\n\tif (unlikely(r < p_min)) {\n\t\tif (unlikely(p_min > SFB_MAX_PROB / 2)) {\n\t\t\t/* If we're marking that many packets, then either\n\t\t\t * this flow is unresponsive, or we're badly congested.\n\t\t\t * In either case, we want to start dropping packets.\n\t\t\t */\n\t\t\tif (r < (p_min - SFB_MAX_PROB / 2) * 2) {\n\t\t\t\tq->stats.earlydrop++;\n\t\t\t\tgoto drop;\n\t\t\t}\n\t\t}\n\t\tif (INET_ECN_set_ce(skb)) {\n\t\t\tq->stats.marked++;\n\t\t} else {\n\t\t\tq->stats.earlydrop++;\n\t\t\tgoto drop;\n\t\t}\n\t}\n\nenqueue:\n\tret = qdisc_enqueue(skb, child, to_free);\n\tif (likely(ret == NET_XMIT_SUCCESS)) {\n\t\tqdisc_qstats_backlog_inc(sch, skb);\n\t\tsch->q.qlen++;\n\t\tincrement_qlen(skb, q);\n\t} else if (net_xmit_drop_count(ret)) {\n\t\tq->stats.childdrop++;\n\t\tqdisc_qstats_drop(sch);\n\t}\n\treturn ret;\n\ndrop:\n\tqdisc_drop(skb, sch, to_free);\n\treturn NET_XMIT_CN;\nother_drop:\n\tif (ret & __NET_XMIT_BYPASS)\n\t\tqdisc_qstats_drop(sch);\n\tkfree_skb(skb);\n\treturn ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -37,9 +37,9 @@\n \t\t/* If using external classifiers, get result and record it. */\n \t\tif (!sfb_classify(skb, fl, &ret, &salt))\n \t\t\tgoto other_drop;\n-\t\tsfbhash = jhash_1word(salt, q->bins[slot].perturbation);\n+\t\tsfbhash = siphash_1u32(salt, &q->bins[slot].perturbation);\n \t} else {\n-\t\tsfbhash = skb_get_hash_perturb(skb, q->bins[slot].perturbation);\n+\t\tsfbhash = skb_get_hash_perturb(skb, &q->bins[slot].perturbation);\n \t}\n \n \n@@ -75,7 +75,7 @@\n \t\t/* Inelastic flow */\n \t\tif (q->double_buffering) {\n \t\t\tsfbhash = skb_get_hash_perturb(skb,\n-\t\t\t    q->bins[slot].perturbation);\n+\t\t\t    &q->bins[slot].perturbation);\n \t\t\tif (!sfbhash)\n \t\t\t\tsfbhash = 1;\n \t\t\tsfb_skb_cb(skb)->hashes[slot] = sfbhash;",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tsfbhash = jhash_1word(salt, q->bins[slot].perturbation);",
                "\t\tsfbhash = skb_get_hash_perturb(skb, q->bins[slot].perturbation);",
                "\t\t\t    q->bins[slot].perturbation);"
            ],
            "added_lines": [
                "\t\tsfbhash = siphash_1u32(salt, &q->bins[slot].perturbation);",
                "\t\tsfbhash = skb_get_hash_perturb(skb, &q->bins[slot].perturbation);",
                "\t\t\t    &q->bins[slot].perturbation);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-18282",
        "func_name": "torvalds/linux/sfb_init_perturbation",
        "description": "The flow_dissector feature in the Linux kernel 4.3 through 5.x before 5.3.10 has a device tracking vulnerability, aka CID-55667441c84f. This occurs because the auto flowlabel of a UDP IPv6 packet relies on a 32-bit hashrnd value as a secret, and because jhash (instead of siphash) is used. The hashrnd value remains the same starting from boot time, and can be inferred by an attacker. This affects net/core/flow_dissector.c and related code.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?h=55667441c84fa5e0911a0aac44fb059c15ba6da2",
        "commit_title": "UDP IPv6 packets auto flowlabels are using a 32bit secret",
        "commit_text": "(static u32 hashrnd in net/core/flow_dissector.c) and apply jhash() over fields known by the receivers.  Attackers can easily infer the 32bit secret and use this information to identify a device and/or user, since this 32bit secret is only set at boot time.  Really, using jhash() to generate cookies sent on the wire is a serious security concern.  Trying to change the rol32(hash, 16) in ip6_make_flowlabel() would be a dead end. Trying to periodically change the secret (like in sch_sfq.c) could change paths taken in the network for long lived flows.  Let's switch to siphash, as we did in commit df453700e8d8 (\"inet: switch IP ID generator to siphash\")  Using a cryptographically strong pseudo random function will solve this privacy issue and more generally remove other weak points in the stack.  Packet schedulers using skb_get_hash_perturb() benefit from this change.  Cc: Tom Herbert <tom@herbertland.com> ",
        "func_before": "static void sfb_init_perturbation(u32 slot, struct sfb_sched_data *q)\n{\n\tq->bins[slot].perturbation = prandom_u32();\n}",
        "func": "static void sfb_init_perturbation(u32 slot, struct sfb_sched_data *q)\n{\n\tget_random_bytes(&q->bins[slot].perturbation,\n\t\t\t sizeof(q->bins[slot].perturbation));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,4 +1,5 @@\n static void sfb_init_perturbation(u32 slot, struct sfb_sched_data *q)\n {\n-\tq->bins[slot].perturbation = prandom_u32();\n+\tget_random_bytes(&q->bins[slot].perturbation,\n+\t\t\t sizeof(q->bins[slot].perturbation));\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tq->bins[slot].perturbation = prandom_u32();"
            ],
            "added_lines": [
                "\tget_random_bytes(&q->bins[slot].perturbation,",
                "\t\t\t sizeof(q->bins[slot].perturbation));"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-18282",
        "func_name": "torvalds/linux/sfq_hash",
        "description": "The flow_dissector feature in the Linux kernel 4.3 through 5.x before 5.3.10 has a device tracking vulnerability, aka CID-55667441c84f. This occurs because the auto flowlabel of a UDP IPv6 packet relies on a 32-bit hashrnd value as a secret, and because jhash (instead of siphash) is used. The hashrnd value remains the same starting from boot time, and can be inferred by an attacker. This affects net/core/flow_dissector.c and related code.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?h=55667441c84fa5e0911a0aac44fb059c15ba6da2",
        "commit_title": "UDP IPv6 packets auto flowlabels are using a 32bit secret",
        "commit_text": "(static u32 hashrnd in net/core/flow_dissector.c) and apply jhash() over fields known by the receivers.  Attackers can easily infer the 32bit secret and use this information to identify a device and/or user, since this 32bit secret is only set at boot time.  Really, using jhash() to generate cookies sent on the wire is a serious security concern.  Trying to change the rol32(hash, 16) in ip6_make_flowlabel() would be a dead end. Trying to periodically change the secret (like in sch_sfq.c) could change paths taken in the network for long lived flows.  Let's switch to siphash, as we did in commit df453700e8d8 (\"inet: switch IP ID generator to siphash\")  Using a cryptographically strong pseudo random function will solve this privacy issue and more generally remove other weak points in the stack.  Packet schedulers using skb_get_hash_perturb() benefit from this change.  Cc: Tom Herbert <tom@herbertland.com> ",
        "func_before": "static unsigned int sfq_hash(const struct sfq_sched_data *q,\n\t\t\t     const struct sk_buff *skb)\n{\n\treturn skb_get_hash_perturb(skb, q->perturbation) & (q->divisor - 1);\n}",
        "func": "static unsigned int sfq_hash(const struct sfq_sched_data *q,\n\t\t\t     const struct sk_buff *skb)\n{\n\treturn skb_get_hash_perturb(skb, &q->perturbation) & (q->divisor - 1);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,5 +1,5 @@\n static unsigned int sfq_hash(const struct sfq_sched_data *q,\n \t\t\t     const struct sk_buff *skb)\n {\n-\treturn skb_get_hash_perturb(skb, q->perturbation) & (q->divisor - 1);\n+\treturn skb_get_hash_perturb(skb, &q->perturbation) & (q->divisor - 1);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\treturn skb_get_hash_perturb(skb, q->perturbation) & (q->divisor - 1);"
            ],
            "added_lines": [
                "\treturn skb_get_hash_perturb(skb, &q->perturbation) & (q->divisor - 1);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-18282",
        "func_name": "torvalds/linux/sfq_init",
        "description": "The flow_dissector feature in the Linux kernel 4.3 through 5.x before 5.3.10 has a device tracking vulnerability, aka CID-55667441c84f. This occurs because the auto flowlabel of a UDP IPv6 packet relies on a 32-bit hashrnd value as a secret, and because jhash (instead of siphash) is used. The hashrnd value remains the same starting from boot time, and can be inferred by an attacker. This affects net/core/flow_dissector.c and related code.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?h=55667441c84fa5e0911a0aac44fb059c15ba6da2",
        "commit_title": "UDP IPv6 packets auto flowlabels are using a 32bit secret",
        "commit_text": "(static u32 hashrnd in net/core/flow_dissector.c) and apply jhash() over fields known by the receivers.  Attackers can easily infer the 32bit secret and use this information to identify a device and/or user, since this 32bit secret is only set at boot time.  Really, using jhash() to generate cookies sent on the wire is a serious security concern.  Trying to change the rol32(hash, 16) in ip6_make_flowlabel() would be a dead end. Trying to periodically change the secret (like in sch_sfq.c) could change paths taken in the network for long lived flows.  Let's switch to siphash, as we did in commit df453700e8d8 (\"inet: switch IP ID generator to siphash\")  Using a cryptographically strong pseudo random function will solve this privacy issue and more generally remove other weak points in the stack.  Packet schedulers using skb_get_hash_perturb() benefit from this change.  Cc: Tom Herbert <tom@herbertland.com> ",
        "func_before": "static int sfq_init(struct Qdisc *sch, struct nlattr *opt,\n\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct sfq_sched_data *q = qdisc_priv(sch);\n\tint i;\n\tint err;\n\n\tq->sch = sch;\n\ttimer_setup(&q->perturb_timer, sfq_perturbation, TIMER_DEFERRABLE);\n\n\terr = tcf_block_get(&q->block, &q->filter_list, sch, extack);\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0; i < SFQ_MAX_DEPTH + 1; i++) {\n\t\tq->dep[i].next = i + SFQ_MAX_FLOWS;\n\t\tq->dep[i].prev = i + SFQ_MAX_FLOWS;\n\t}\n\n\tq->limit = SFQ_MAX_DEPTH;\n\tq->maxdepth = SFQ_MAX_DEPTH;\n\tq->cur_depth = 0;\n\tq->tail = NULL;\n\tq->divisor = SFQ_DEFAULT_HASH_DIVISOR;\n\tq->maxflows = SFQ_DEFAULT_FLOWS;\n\tq->quantum = psched_mtu(qdisc_dev(sch));\n\tq->scaled_quantum = SFQ_ALLOT_SIZE(q->quantum);\n\tq->perturb_period = 0;\n\tq->perturbation = prandom_u32();\n\n\tif (opt) {\n\t\tint err = sfq_change(sch, opt);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tq->ht = sfq_alloc(sizeof(q->ht[0]) * q->divisor);\n\tq->slots = sfq_alloc(sizeof(q->slots[0]) * q->maxflows);\n\tif (!q->ht || !q->slots) {\n\t\t/* Note: sfq_destroy() will be called by our caller */\n\t\treturn -ENOMEM;\n\t}\n\n\tfor (i = 0; i < q->divisor; i++)\n\t\tq->ht[i] = SFQ_EMPTY_SLOT;\n\n\tfor (i = 0; i < q->maxflows; i++) {\n\t\tslot_queue_init(&q->slots[i]);\n\t\tsfq_link(q, i);\n\t}\n\tif (q->limit >= 1)\n\t\tsch->flags |= TCQ_F_CAN_BYPASS;\n\telse\n\t\tsch->flags &= ~TCQ_F_CAN_BYPASS;\n\treturn 0;\n}",
        "func": "static int sfq_init(struct Qdisc *sch, struct nlattr *opt,\n\t\t    struct netlink_ext_ack *extack)\n{\n\tstruct sfq_sched_data *q = qdisc_priv(sch);\n\tint i;\n\tint err;\n\n\tq->sch = sch;\n\ttimer_setup(&q->perturb_timer, sfq_perturbation, TIMER_DEFERRABLE);\n\n\terr = tcf_block_get(&q->block, &q->filter_list, sch, extack);\n\tif (err)\n\t\treturn err;\n\n\tfor (i = 0; i < SFQ_MAX_DEPTH + 1; i++) {\n\t\tq->dep[i].next = i + SFQ_MAX_FLOWS;\n\t\tq->dep[i].prev = i + SFQ_MAX_FLOWS;\n\t}\n\n\tq->limit = SFQ_MAX_DEPTH;\n\tq->maxdepth = SFQ_MAX_DEPTH;\n\tq->cur_depth = 0;\n\tq->tail = NULL;\n\tq->divisor = SFQ_DEFAULT_HASH_DIVISOR;\n\tq->maxflows = SFQ_DEFAULT_FLOWS;\n\tq->quantum = psched_mtu(qdisc_dev(sch));\n\tq->scaled_quantum = SFQ_ALLOT_SIZE(q->quantum);\n\tq->perturb_period = 0;\n\tget_random_bytes(&q->perturbation, sizeof(q->perturbation));\n\n\tif (opt) {\n\t\tint err = sfq_change(sch, opt);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tq->ht = sfq_alloc(sizeof(q->ht[0]) * q->divisor);\n\tq->slots = sfq_alloc(sizeof(q->slots[0]) * q->maxflows);\n\tif (!q->ht || !q->slots) {\n\t\t/* Note: sfq_destroy() will be called by our caller */\n\t\treturn -ENOMEM;\n\t}\n\n\tfor (i = 0; i < q->divisor; i++)\n\t\tq->ht[i] = SFQ_EMPTY_SLOT;\n\n\tfor (i = 0; i < q->maxflows; i++) {\n\t\tslot_queue_init(&q->slots[i]);\n\t\tsfq_link(q, i);\n\t}\n\tif (q->limit >= 1)\n\t\tsch->flags |= TCQ_F_CAN_BYPASS;\n\telse\n\t\tsch->flags &= ~TCQ_F_CAN_BYPASS;\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -26,7 +26,7 @@\n \tq->quantum = psched_mtu(qdisc_dev(sch));\n \tq->scaled_quantum = SFQ_ALLOT_SIZE(q->quantum);\n \tq->perturb_period = 0;\n-\tq->perturbation = prandom_u32();\n+\tget_random_bytes(&q->perturbation, sizeof(q->perturbation));\n \n \tif (opt) {\n \t\tint err = sfq_change(sch, opt);",
        "diff_line_info": {
            "deleted_lines": [
                "\tq->perturbation = prandom_u32();"
            ],
            "added_lines": [
                "\tget_random_bytes(&q->perturbation, sizeof(q->perturbation));"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-18282",
        "func_name": "torvalds/linux/sfq_change",
        "description": "The flow_dissector feature in the Linux kernel 4.3 through 5.x before 5.3.10 has a device tracking vulnerability, aka CID-55667441c84f. This occurs because the auto flowlabel of a UDP IPv6 packet relies on a 32-bit hashrnd value as a secret, and because jhash (instead of siphash) is used. The hashrnd value remains the same starting from boot time, and can be inferred by an attacker. This affects net/core/flow_dissector.c and related code.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?h=55667441c84fa5e0911a0aac44fb059c15ba6da2",
        "commit_title": "UDP IPv6 packets auto flowlabels are using a 32bit secret",
        "commit_text": "(static u32 hashrnd in net/core/flow_dissector.c) and apply jhash() over fields known by the receivers.  Attackers can easily infer the 32bit secret and use this information to identify a device and/or user, since this 32bit secret is only set at boot time.  Really, using jhash() to generate cookies sent on the wire is a serious security concern.  Trying to change the rol32(hash, 16) in ip6_make_flowlabel() would be a dead end. Trying to periodically change the secret (like in sch_sfq.c) could change paths taken in the network for long lived flows.  Let's switch to siphash, as we did in commit df453700e8d8 (\"inet: switch IP ID generator to siphash\")  Using a cryptographically strong pseudo random function will solve this privacy issue and more generally remove other weak points in the stack.  Packet schedulers using skb_get_hash_perturb() benefit from this change.  Cc: Tom Herbert <tom@herbertland.com> ",
        "func_before": "static int sfq_change(struct Qdisc *sch, struct nlattr *opt)\n{\n\tstruct sfq_sched_data *q = qdisc_priv(sch);\n\tstruct tc_sfq_qopt *ctl = nla_data(opt);\n\tstruct tc_sfq_qopt_v1 *ctl_v1 = NULL;\n\tunsigned int qlen, dropped = 0;\n\tstruct red_parms *p = NULL;\n\tstruct sk_buff *to_free = NULL;\n\tstruct sk_buff *tail = NULL;\n\n\tif (opt->nla_len < nla_attr_size(sizeof(*ctl)))\n\t\treturn -EINVAL;\n\tif (opt->nla_len >= nla_attr_size(sizeof(*ctl_v1)))\n\t\tctl_v1 = nla_data(opt);\n\tif (ctl->divisor &&\n\t    (!is_power_of_2(ctl->divisor) || ctl->divisor > 65536))\n\t\treturn -EINVAL;\n\tif (ctl_v1 && !red_check_params(ctl_v1->qth_min, ctl_v1->qth_max,\n\t\t\t\t\tctl_v1->Wlog))\n\t\treturn -EINVAL;\n\tif (ctl_v1 && ctl_v1->qth_min) {\n\t\tp = kmalloc(sizeof(*p), GFP_KERNEL);\n\t\tif (!p)\n\t\t\treturn -ENOMEM;\n\t}\n\tsch_tree_lock(sch);\n\tif (ctl->quantum) {\n\t\tq->quantum = ctl->quantum;\n\t\tq->scaled_quantum = SFQ_ALLOT_SIZE(q->quantum);\n\t}\n\tq->perturb_period = ctl->perturb_period * HZ;\n\tif (ctl->flows)\n\t\tq->maxflows = min_t(u32, ctl->flows, SFQ_MAX_FLOWS);\n\tif (ctl->divisor) {\n\t\tq->divisor = ctl->divisor;\n\t\tq->maxflows = min_t(u32, q->maxflows, q->divisor);\n\t}\n\tif (ctl_v1) {\n\t\tif (ctl_v1->depth)\n\t\t\tq->maxdepth = min_t(u32, ctl_v1->depth, SFQ_MAX_DEPTH);\n\t\tif (p) {\n\t\t\tswap(q->red_parms, p);\n\t\t\tred_set_parms(q->red_parms,\n\t\t\t\t      ctl_v1->qth_min, ctl_v1->qth_max,\n\t\t\t\t      ctl_v1->Wlog,\n\t\t\t\t      ctl_v1->Plog, ctl_v1->Scell_log,\n\t\t\t\t      NULL,\n\t\t\t\t      ctl_v1->max_P);\n\t\t}\n\t\tq->flags = ctl_v1->flags;\n\t\tq->headdrop = ctl_v1->headdrop;\n\t}\n\tif (ctl->limit) {\n\t\tq->limit = min_t(u32, ctl->limit, q->maxdepth * q->maxflows);\n\t\tq->maxflows = min_t(u32, q->maxflows, q->limit);\n\t}\n\n\tqlen = sch->q.qlen;\n\twhile (sch->q.qlen > q->limit) {\n\t\tdropped += sfq_drop(sch, &to_free);\n\t\tif (!tail)\n\t\t\ttail = to_free;\n\t}\n\n\trtnl_kfree_skbs(to_free, tail);\n\tqdisc_tree_reduce_backlog(sch, qlen - sch->q.qlen, dropped);\n\n\tdel_timer(&q->perturb_timer);\n\tif (q->perturb_period) {\n\t\tmod_timer(&q->perturb_timer, jiffies + q->perturb_period);\n\t\tq->perturbation = prandom_u32();\n\t}\n\tsch_tree_unlock(sch);\n\tkfree(p);\n\treturn 0;\n}",
        "func": "static int sfq_change(struct Qdisc *sch, struct nlattr *opt)\n{\n\tstruct sfq_sched_data *q = qdisc_priv(sch);\n\tstruct tc_sfq_qopt *ctl = nla_data(opt);\n\tstruct tc_sfq_qopt_v1 *ctl_v1 = NULL;\n\tunsigned int qlen, dropped = 0;\n\tstruct red_parms *p = NULL;\n\tstruct sk_buff *to_free = NULL;\n\tstruct sk_buff *tail = NULL;\n\n\tif (opt->nla_len < nla_attr_size(sizeof(*ctl)))\n\t\treturn -EINVAL;\n\tif (opt->nla_len >= nla_attr_size(sizeof(*ctl_v1)))\n\t\tctl_v1 = nla_data(opt);\n\tif (ctl->divisor &&\n\t    (!is_power_of_2(ctl->divisor) || ctl->divisor > 65536))\n\t\treturn -EINVAL;\n\tif (ctl_v1 && !red_check_params(ctl_v1->qth_min, ctl_v1->qth_max,\n\t\t\t\t\tctl_v1->Wlog))\n\t\treturn -EINVAL;\n\tif (ctl_v1 && ctl_v1->qth_min) {\n\t\tp = kmalloc(sizeof(*p), GFP_KERNEL);\n\t\tif (!p)\n\t\t\treturn -ENOMEM;\n\t}\n\tsch_tree_lock(sch);\n\tif (ctl->quantum) {\n\t\tq->quantum = ctl->quantum;\n\t\tq->scaled_quantum = SFQ_ALLOT_SIZE(q->quantum);\n\t}\n\tq->perturb_period = ctl->perturb_period * HZ;\n\tif (ctl->flows)\n\t\tq->maxflows = min_t(u32, ctl->flows, SFQ_MAX_FLOWS);\n\tif (ctl->divisor) {\n\t\tq->divisor = ctl->divisor;\n\t\tq->maxflows = min_t(u32, q->maxflows, q->divisor);\n\t}\n\tif (ctl_v1) {\n\t\tif (ctl_v1->depth)\n\t\t\tq->maxdepth = min_t(u32, ctl_v1->depth, SFQ_MAX_DEPTH);\n\t\tif (p) {\n\t\t\tswap(q->red_parms, p);\n\t\t\tred_set_parms(q->red_parms,\n\t\t\t\t      ctl_v1->qth_min, ctl_v1->qth_max,\n\t\t\t\t      ctl_v1->Wlog,\n\t\t\t\t      ctl_v1->Plog, ctl_v1->Scell_log,\n\t\t\t\t      NULL,\n\t\t\t\t      ctl_v1->max_P);\n\t\t}\n\t\tq->flags = ctl_v1->flags;\n\t\tq->headdrop = ctl_v1->headdrop;\n\t}\n\tif (ctl->limit) {\n\t\tq->limit = min_t(u32, ctl->limit, q->maxdepth * q->maxflows);\n\t\tq->maxflows = min_t(u32, q->maxflows, q->limit);\n\t}\n\n\tqlen = sch->q.qlen;\n\twhile (sch->q.qlen > q->limit) {\n\t\tdropped += sfq_drop(sch, &to_free);\n\t\tif (!tail)\n\t\t\ttail = to_free;\n\t}\n\n\trtnl_kfree_skbs(to_free, tail);\n\tqdisc_tree_reduce_backlog(sch, qlen - sch->q.qlen, dropped);\n\n\tdel_timer(&q->perturb_timer);\n\tif (q->perturb_period) {\n\t\tmod_timer(&q->perturb_timer, jiffies + q->perturb_period);\n\t\tget_random_bytes(&q->perturbation, sizeof(q->perturbation));\n\t}\n\tsch_tree_unlock(sch);\n\tkfree(p);\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -68,7 +68,7 @@\n \tdel_timer(&q->perturb_timer);\n \tif (q->perturb_period) {\n \t\tmod_timer(&q->perturb_timer, jiffies + q->perturb_period);\n-\t\tq->perturbation = prandom_u32();\n+\t\tget_random_bytes(&q->perturbation, sizeof(q->perturbation));\n \t}\n \tsch_tree_unlock(sch);\n \tkfree(p);",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tq->perturbation = prandom_u32();"
            ],
            "added_lines": [
                "\t\tget_random_bytes(&q->perturbation, sizeof(q->perturbation));"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-18282",
        "func_name": "torvalds/linux/sfq_perturbation",
        "description": "The flow_dissector feature in the Linux kernel 4.3 through 5.x before 5.3.10 has a device tracking vulnerability, aka CID-55667441c84f. This occurs because the auto flowlabel of a UDP IPv6 packet relies on a 32-bit hashrnd value as a secret, and because jhash (instead of siphash) is used. The hashrnd value remains the same starting from boot time, and can be inferred by an attacker. This affects net/core/flow_dissector.c and related code.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?h=55667441c84fa5e0911a0aac44fb059c15ba6da2",
        "commit_title": "UDP IPv6 packets auto flowlabels are using a 32bit secret",
        "commit_text": "(static u32 hashrnd in net/core/flow_dissector.c) and apply jhash() over fields known by the receivers.  Attackers can easily infer the 32bit secret and use this information to identify a device and/or user, since this 32bit secret is only set at boot time.  Really, using jhash() to generate cookies sent on the wire is a serious security concern.  Trying to change the rol32(hash, 16) in ip6_make_flowlabel() would be a dead end. Trying to periodically change the secret (like in sch_sfq.c) could change paths taken in the network for long lived flows.  Let's switch to siphash, as we did in commit df453700e8d8 (\"inet: switch IP ID generator to siphash\")  Using a cryptographically strong pseudo random function will solve this privacy issue and more generally remove other weak points in the stack.  Packet schedulers using skb_get_hash_perturb() benefit from this change.  Cc: Tom Herbert <tom@herbertland.com> ",
        "func_before": "static void sfq_perturbation(struct timer_list *t)\n{\n\tstruct sfq_sched_data *q = from_timer(q, t, perturb_timer);\n\tstruct Qdisc *sch = q->sch;\n\tspinlock_t *root_lock = qdisc_lock(qdisc_root_sleeping(sch));\n\n\tspin_lock(root_lock);\n\tq->perturbation = prandom_u32();\n\tif (!q->filter_list && q->tail)\n\t\tsfq_rehash(sch);\n\tspin_unlock(root_lock);\n\n\tif (q->perturb_period)\n\t\tmod_timer(&q->perturb_timer, jiffies + q->perturb_period);\n}",
        "func": "static void sfq_perturbation(struct timer_list *t)\n{\n\tstruct sfq_sched_data *q = from_timer(q, t, perturb_timer);\n\tstruct Qdisc *sch = q->sch;\n\tspinlock_t *root_lock = qdisc_lock(qdisc_root_sleeping(sch));\n\tsiphash_key_t nkey;\n\n\tget_random_bytes(&nkey, sizeof(nkey));\n\tspin_lock(root_lock);\n\tq->perturbation = nkey;\n\tif (!q->filter_list && q->tail)\n\t\tsfq_rehash(sch);\n\tspin_unlock(root_lock);\n\n\tif (q->perturb_period)\n\t\tmod_timer(&q->perturb_timer, jiffies + q->perturb_period);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,9 +3,11 @@\n \tstruct sfq_sched_data *q = from_timer(q, t, perturb_timer);\n \tstruct Qdisc *sch = q->sch;\n \tspinlock_t *root_lock = qdisc_lock(qdisc_root_sleeping(sch));\n+\tsiphash_key_t nkey;\n \n+\tget_random_bytes(&nkey, sizeof(nkey));\n \tspin_lock(root_lock);\n-\tq->perturbation = prandom_u32();\n+\tq->perturbation = nkey;\n \tif (!q->filter_list && q->tail)\n \t\tsfq_rehash(sch);\n \tspin_unlock(root_lock);",
        "diff_line_info": {
            "deleted_lines": [
                "\tq->perturbation = prandom_u32();"
            ],
            "added_lines": [
                "\tsiphash_key_t nkey;",
                "\tget_random_bytes(&nkey, sizeof(nkey));",
                "\tq->perturbation = nkey;"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-18282",
        "func_name": "torvalds/linux/fq_flow_idx",
        "description": "The flow_dissector feature in the Linux kernel 4.3 through 5.x before 5.3.10 has a device tracking vulnerability, aka CID-55667441c84f. This occurs because the auto flowlabel of a UDP IPv6 packet relies on a 32-bit hashrnd value as a secret, and because jhash (instead of siphash) is used. The hashrnd value remains the same starting from boot time, and can be inferred by an attacker. This affects net/core/flow_dissector.c and related code.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?h=55667441c84fa5e0911a0aac44fb059c15ba6da2",
        "commit_title": "UDP IPv6 packets auto flowlabels are using a 32bit secret",
        "commit_text": "(static u32 hashrnd in net/core/flow_dissector.c) and apply jhash() over fields known by the receivers.  Attackers can easily infer the 32bit secret and use this information to identify a device and/or user, since this 32bit secret is only set at boot time.  Really, using jhash() to generate cookies sent on the wire is a serious security concern.  Trying to change the rol32(hash, 16) in ip6_make_flowlabel() would be a dead end. Trying to periodically change the secret (like in sch_sfq.c) could change paths taken in the network for long lived flows.  Let's switch to siphash, as we did in commit df453700e8d8 (\"inet: switch IP ID generator to siphash\")  Using a cryptographically strong pseudo random function will solve this privacy issue and more generally remove other weak points in the stack.  Packet schedulers using skb_get_hash_perturb() benefit from this change.  Cc: Tom Herbert <tom@herbertland.com> ",
        "func_before": "static u32 fq_flow_idx(struct fq *fq, struct sk_buff *skb)\n{\n\tu32 hash = skb_get_hash_perturb(skb, fq->perturbation);\n\n\treturn reciprocal_scale(hash, fq->flows_cnt);\n}",
        "func": "static u32 fq_flow_idx(struct fq *fq, struct sk_buff *skb)\n{\n\tu32 hash = skb_get_hash_perturb(skb, &fq->perturbation);\n\n\treturn reciprocal_scale(hash, fq->flows_cnt);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,6 @@\n static u32 fq_flow_idx(struct fq *fq, struct sk_buff *skb)\n {\n-\tu32 hash = skb_get_hash_perturb(skb, fq->perturbation);\n+\tu32 hash = skb_get_hash_perturb(skb, &fq->perturbation);\n \n \treturn reciprocal_scale(hash, fq->flows_cnt);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tu32 hash = skb_get_hash_perturb(skb, fq->perturbation);"
            ],
            "added_lines": [
                "\tu32 hash = skb_get_hash_perturb(skb, &fq->perturbation);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-18282",
        "func_name": "torvalds/linux/fq_init",
        "description": "The flow_dissector feature in the Linux kernel 4.3 through 5.x before 5.3.10 has a device tracking vulnerability, aka CID-55667441c84f. This occurs because the auto flowlabel of a UDP IPv6 packet relies on a 32-bit hashrnd value as a secret, and because jhash (instead of siphash) is used. The hashrnd value remains the same starting from boot time, and can be inferred by an attacker. This affects net/core/flow_dissector.c and related code.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?h=55667441c84fa5e0911a0aac44fb059c15ba6da2",
        "commit_title": "UDP IPv6 packets auto flowlabels are using a 32bit secret",
        "commit_text": "(static u32 hashrnd in net/core/flow_dissector.c) and apply jhash() over fields known by the receivers.  Attackers can easily infer the 32bit secret and use this information to identify a device and/or user, since this 32bit secret is only set at boot time.  Really, using jhash() to generate cookies sent on the wire is a serious security concern.  Trying to change the rol32(hash, 16) in ip6_make_flowlabel() would be a dead end. Trying to periodically change the secret (like in sch_sfq.c) could change paths taken in the network for long lived flows.  Let's switch to siphash, as we did in commit df453700e8d8 (\"inet: switch IP ID generator to siphash\")  Using a cryptographically strong pseudo random function will solve this privacy issue and more generally remove other weak points in the stack.  Packet schedulers using skb_get_hash_perturb() benefit from this change.  Cc: Tom Herbert <tom@herbertland.com> ",
        "func_before": "static int fq_init(struct fq *fq, int flows_cnt)\n{\n\tint i;\n\n\tmemset(fq, 0, sizeof(fq[0]));\n\tINIT_LIST_HEAD(&fq->backlogs);\n\tspin_lock_init(&fq->lock);\n\tfq->flows_cnt = max_t(u32, flows_cnt, 1);\n\tfq->perturbation = prandom_u32();\n\tfq->quantum = 300;\n\tfq->limit = 8192;\n\tfq->memory_limit = 16 << 20; /* 16 MBytes */\n\n\tfq->flows = kcalloc(fq->flows_cnt, sizeof(fq->flows[0]), GFP_KERNEL);\n\tif (!fq->flows)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < fq->flows_cnt; i++)\n\t\tfq_flow_init(&fq->flows[i]);\n\n\treturn 0;\n}",
        "func": "static int fq_init(struct fq *fq, int flows_cnt)\n{\n\tint i;\n\n\tmemset(fq, 0, sizeof(fq[0]));\n\tINIT_LIST_HEAD(&fq->backlogs);\n\tspin_lock_init(&fq->lock);\n\tfq->flows_cnt = max_t(u32, flows_cnt, 1);\n\tget_random_bytes(&fq->perturbation, sizeof(fq->perturbation));\n\tfq->quantum = 300;\n\tfq->limit = 8192;\n\tfq->memory_limit = 16 << 20; /* 16 MBytes */\n\n\tfq->flows = kcalloc(fq->flows_cnt, sizeof(fq->flows[0]), GFP_KERNEL);\n\tif (!fq->flows)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0; i < fq->flows_cnt; i++)\n\t\tfq_flow_init(&fq->flows[i]);\n\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,7 +6,7 @@\n \tINIT_LIST_HEAD(&fq->backlogs);\n \tspin_lock_init(&fq->lock);\n \tfq->flows_cnt = max_t(u32, flows_cnt, 1);\n-\tfq->perturbation = prandom_u32();\n+\tget_random_bytes(&fq->perturbation, sizeof(fq->perturbation));\n \tfq->quantum = 300;\n \tfq->limit = 8192;\n \tfq->memory_limit = 16 << 20; /* 16 MBytes */",
        "diff_line_info": {
            "deleted_lines": [
                "\tfq->perturbation = prandom_u32();"
            ],
            "added_lines": [
                "\tget_random_bytes(&fq->perturbation, sizeof(fq->perturbation));"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-27743",
        "func_name": "kravietz/pam_tacplus/pam_sm_open_session",
        "description": "libtac in pam_tacplus through 1.5.1 lacks a check for a failure of RAND_bytes()/RAND_pseudo_bytes(). This could lead to use of a non-random/predictable session_id.",
        "git_url": "https://github.com/kravietz/pam_tacplus/commit/c9bed7496e81e550ee22746f23bbb11be2e046ed",
        "commit_title": "magic.c: check for failure of RAND_[pseudo_]bytes",
        "commit_text": " When magic() is implemented via libcrypto's RAND_bytes or RAND_pseudo_bytes we should check for a failure and abort to ensure we don't use a predictable session_id.  This prevents (further) weakening* of the TACACS+ protocol \"encryption\" since session_id is an input to the algorithm.  *by modern standards TACACS+ is deemed \"obfuscated\" - RFC 8907.",
        "func_before": "PAM_EXTERN\nint pam_sm_open_session(pam_handle_t *pamh, int UNUSED(flags), int argc,\n                        const char **argv) {\n#if defined(HAVE_OPENSSL_RAND_H) && defined(HAVE_LIBCRYPTO)\n# if defined(HAVE_RAND_BYTES)\n\tRAND_bytes((unsigned char *) &task_id, sizeof(task_id));\n# else\n\tRAND_pseudo_bytes((unsigned char *) &task_id, sizeof(task_id));\n# endif\n#else\n\ttask_id=(short int) magic();\n#endif\n\n\treturn _pam_account(pamh, argc, argv, TAC_PLUS_ACCT_FLAG_START, NULL);\n}",
        "func": "PAM_EXTERN\nint pam_sm_open_session(pam_handle_t *pamh, int UNUSED(flags), int argc,\n                        const char **argv) {\n\n/* Task ID has no need to be cryptographically strong so we don't\n * check for failures of the RAND functions. If they fail then we are\n * as well sending the accounting request regardless of whether any value\n * was written to task_id.\n */\n#if defined(HAVE_OPENSSL_RAND_H) && defined(HAVE_LIBCRYPTO)\n# if defined(HAVE_RAND_BYTES)\n\tRAND_bytes((unsigned char *) &task_id, sizeof(task_id));\n# else\n\tRAND_pseudo_bytes((unsigned char *) &task_id, sizeof(task_id));\n# endif\n#else\n\ttask_id=(short int) magic();\n#endif\n\n\treturn _pam_account(pamh, argc, argv, TAC_PLUS_ACCT_FLAG_START, NULL);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,6 +1,12 @@\n PAM_EXTERN\n int pam_sm_open_session(pam_handle_t *pamh, int UNUSED(flags), int argc,\n                         const char **argv) {\n+\n+/* Task ID has no need to be cryptographically strong so we don't\n+ * check for failures of the RAND functions. If they fail then we are\n+ * as well sending the accounting request regardless of whether any value\n+ * was written to task_id.\n+ */\n #if defined(HAVE_OPENSSL_RAND_H) && defined(HAVE_LIBCRYPTO)\n # if defined(HAVE_RAND_BYTES)\n \tRAND_bytes((unsigned char *) &task_id, sizeof(task_id));",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "/* Task ID has no need to be cryptographically strong so we don't",
                " * check for failures of the RAND functions. If they fail then we are",
                " * as well sending the accounting request regardless of whether any value",
                " * was written to task_id.",
                " */"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-27743",
        "func_name": "kravietz/pam_tacplus/pam_sm_open_session",
        "description": "libtac in pam_tacplus through 1.5.1 lacks a check for a failure of RAND_bytes()/RAND_pseudo_bytes(). This could lead to use of a non-random/predictable session_id.",
        "git_url": "https://github.com/kravietz/pam_tacplus/commit/bceaab0cd51a09b88f40f19da799ac7390264bf8",
        "commit_title": "pam_tacplus.c: Fallback to using PID as task ID",
        "commit_text": " If there is a failure obtaining a random task ID for the session accounting request then fallback to using the PID, as this is unique for the lifetime of the PAM application and therefore session.",
        "func_before": "PAM_EXTERN\nint pam_sm_open_session(pam_handle_t *pamh, int UNUSED(flags), int argc,\n                        const char **argv) {\n\n/* Task ID has no need to be cryptographically strong so we don't\n * check for failures of the RAND functions. If they fail then we are\n * as well sending the accounting request regardless of whether any value\n * was written to task_id.\n */\n#if defined(HAVE_OPENSSL_RAND_H) && defined(HAVE_LIBCRYPTO)\n# if defined(HAVE_RAND_BYTES)\n\tRAND_bytes((unsigned char *) &task_id, sizeof(task_id));\n# else\n\tRAND_pseudo_bytes((unsigned char *) &task_id, sizeof(task_id));\n# endif\n#else\n\ttask_id=(short int) magic();\n#endif\n\n\treturn _pam_account(pamh, argc, argv, TAC_PLUS_ACCT_FLAG_START, NULL);\n}",
        "func": "PAM_EXTERN\nint pam_sm_open_session(pam_handle_t *pamh, int UNUSED(flags), int argc,\n                        const char **argv) {\n\n/* Task ID has no need to be cryptographically strong so we don't\n * check for failures of the RAND functions. If we fail to get an ID we\n * fallback to using our PID (in _pam_send_account).\n */\n#if defined(HAVE_OPENSSL_RAND_H) && defined(HAVE_LIBCRYPTO)\n# if defined(HAVE_RAND_BYTES)\n\tRAND_bytes((unsigned char *) &task_id, sizeof(task_id));\n# else\n\tRAND_pseudo_bytes((unsigned char *) &task_id, sizeof(task_id));\n# endif\n#else\n\ttask_id=(short int) magic();\n#endif\n\n\tif (task_id == 0)\n\t\tsyslog(LOG_INFO, \"%s: failed to generate random task ID, \"\n\t\t\t\t\"falling back to PID\", __FUNCTION__);\n\n\treturn _pam_account(pamh, argc, argv, TAC_PLUS_ACCT_FLAG_START, NULL);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,9 +3,8 @@\n                         const char **argv) {\n \n /* Task ID has no need to be cryptographically strong so we don't\n- * check for failures of the RAND functions. If they fail then we are\n- * as well sending the accounting request regardless of whether any value\n- * was written to task_id.\n+ * check for failures of the RAND functions. If we fail to get an ID we\n+ * fallback to using our PID (in _pam_send_account).\n  */\n #if defined(HAVE_OPENSSL_RAND_H) && defined(HAVE_LIBCRYPTO)\n # if defined(HAVE_RAND_BYTES)\n@@ -17,5 +16,9 @@\n \ttask_id=(short int) magic();\n #endif\n \n+\tif (task_id == 0)\n+\t\tsyslog(LOG_INFO, \"%s: failed to generate random task ID, \"\n+\t\t\t\t\"falling back to PID\", __FUNCTION__);\n+\n \treturn _pam_account(pamh, argc, argv, TAC_PLUS_ACCT_FLAG_START, NULL);\n }",
        "diff_line_info": {
            "deleted_lines": [
                " * check for failures of the RAND functions. If they fail then we are",
                " * as well sending the accounting request regardless of whether any value",
                " * was written to task_id."
            ],
            "added_lines": [
                " * check for failures of the RAND functions. If we fail to get an ID we",
                " * fallback to using our PID (in _pam_send_account).",
                "\tif (task_id == 0)",
                "\t\tsyslog(LOG_INFO, \"%s: failed to generate random task ID, \"",
                "\t\t\t\t\"falling back to PID\", __FUNCTION__);",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2020-27743",
        "func_name": "kravietz/pam_tacplus/_pam_send_account",
        "description": "libtac in pam_tacplus through 1.5.1 lacks a check for a failure of RAND_bytes()/RAND_pseudo_bytes(). This could lead to use of a non-random/predictable session_id.",
        "git_url": "https://github.com/kravietz/pam_tacplus/commit/bceaab0cd51a09b88f40f19da799ac7390264bf8",
        "commit_title": "pam_tacplus.c: Fallback to using PID as task ID",
        "commit_text": " If there is a failure obtaining a random task ID for the session accounting request then fallback to using the PID, as this is unique for the lifetime of the PAM application and therefore session.",
        "func_before": "int _pam_send_account(int tac_fd, int type, const char *user, char *tty,\n\t\tchar *r_addr, char *cmd) {\n\n\tchar buf[64];\n\tstruct tac_attrib *attr;\n\tint retval;\n\ttime_t t;\n\tstruct tm tm;\n\n\tattr = (struct tac_attrib *) xcalloc(1, sizeof(struct tac_attrib));\n\n\tt = time(NULL);\n\tgmtime_r(&t, &tm);\n\tstrftime(buf, sizeof(buf), \"%s\", &tm);\n\n\tif (type == TAC_PLUS_ACCT_FLAG_START) {\n\t\ttac_add_attrib(&attr, \"start_time\", buf);\n\t} else if (type == TAC_PLUS_ACCT_FLAG_STOP) {\n\t\ttac_add_attrib(&attr, \"stop_time\", buf);\n\t}\n\tsprintf(buf, \"%hu\", task_id);\n\ttac_add_attrib(&attr, \"task_id\", buf);\n\ttac_add_attrib(&attr, \"service\", tac_service);\n\tif (tac_protocol[0] != '\\0')\n\t\ttac_add_attrib(&attr, \"protocol\", tac_protocol);\n\tif (cmd != NULL) {\n\t\ttac_add_attrib(&attr, \"cmd\", cmd);\n\t}\n\n\tretval = tac_acct_send(tac_fd, type, user, tty, r_addr, attr);\n\n\t/* this is no longer needed */\n\ttac_free_attrib(&attr);\n\n\tif (retval < 0) {\n\t\t_pam_log(LOG_WARNING, \"%s: send %s accounting failed (task %hu)\",\n\t\t\t\t__FUNCTION__, tac_acct_flag2str(type), task_id);\n\t\tclose(tac_fd);\n\t\treturn -1;\n\t}\n\n\tstruct areply re;\n\tif (tac_acct_read(tac_fd, &re) != TAC_PLUS_ACCT_STATUS_SUCCESS) {\n\t\t_pam_log(LOG_WARNING, \"%s: accounting %s failed (task %hu)\",\n\t\t\t\t__FUNCTION__, tac_acct_flag2str(type), task_id);\n\n\t\tif (re.msg != NULL)\n\t\t\tfree(re.msg);\n\n\t\tclose(tac_fd);\n\t\treturn -1;\n\t}\n\n\tif (re.msg != NULL)\n\t\tfree(re.msg);\n\n\tclose(tac_fd);\n\treturn 0;\n}",
        "func": "int _pam_send_account(int tac_fd, int type, const char *user, char *tty,\n\t\tchar *r_addr, char *cmd) {\n\n\tchar buf[64];\n\tstruct tac_attrib *attr;\n\tint retval;\n\ttime_t t;\n\tstruct tm tm;\n\n\tattr = (struct tac_attrib *) xcalloc(1, sizeof(struct tac_attrib));\n\n\tt = time(NULL);\n\tgmtime_r(&t, &tm);\n\tstrftime(buf, sizeof(buf), \"%s\", &tm);\n\n\tif (type == TAC_PLUS_ACCT_FLAG_START) {\n\t\ttac_add_attrib(&attr, \"start_time\", buf);\n\t} else if (type == TAC_PLUS_ACCT_FLAG_STOP) {\n\t\ttac_add_attrib(&attr, \"stop_time\", buf);\n\t}\n\n\tif (task_id == 0)\n\t\tsnprintf(buf, sizeof(buf), \"%d\", getpid());\n\telse\n\t\tsnprintf(buf, sizeof(buf), \"%hu\", task_id);\n\ttac_add_attrib(&attr, \"task_id\", buf);\n\n\ttac_add_attrib(&attr, \"service\", tac_service);\n\tif (tac_protocol[0] != '\\0')\n\t\ttac_add_attrib(&attr, \"protocol\", tac_protocol);\n\tif (cmd != NULL) {\n\t\ttac_add_attrib(&attr, \"cmd\", cmd);\n\t}\n\n\tretval = tac_acct_send(tac_fd, type, user, tty, r_addr, attr);\n\n\t/* this is no longer needed */\n\ttac_free_attrib(&attr);\n\n\tif (retval < 0) {\n\t\t_pam_log(LOG_WARNING, \"%s: send %s accounting failed (task %hu)\",\n\t\t\t\t__FUNCTION__, tac_acct_flag2str(type), task_id);\n\t\tclose(tac_fd);\n\t\treturn -1;\n\t}\n\n\tstruct areply re;\n\tif (tac_acct_read(tac_fd, &re) != TAC_PLUS_ACCT_STATUS_SUCCESS) {\n\t\t_pam_log(LOG_WARNING, \"%s: accounting %s failed (task %hu)\",\n\t\t\t\t__FUNCTION__, tac_acct_flag2str(type), task_id);\n\n\t\tif (re.msg != NULL)\n\t\t\tfree(re.msg);\n\n\t\tclose(tac_fd);\n\t\treturn -1;\n\t}\n\n\tif (re.msg != NULL)\n\t\tfree(re.msg);\n\n\tclose(tac_fd);\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -18,8 +18,13 @@\n \t} else if (type == TAC_PLUS_ACCT_FLAG_STOP) {\n \t\ttac_add_attrib(&attr, \"stop_time\", buf);\n \t}\n-\tsprintf(buf, \"%hu\", task_id);\n+\n+\tif (task_id == 0)\n+\t\tsnprintf(buf, sizeof(buf), \"%d\", getpid());\n+\telse\n+\t\tsnprintf(buf, sizeof(buf), \"%hu\", task_id);\n \ttac_add_attrib(&attr, \"task_id\", buf);\n+\n \ttac_add_attrib(&attr, \"service\", tac_service);\n \tif (tac_protocol[0] != '\\0')\n \t\ttac_add_attrib(&attr, \"protocol\", tac_protocol);",
        "diff_line_info": {
            "deleted_lines": [
                "\tsprintf(buf, \"%hu\", task_id);"
            ],
            "added_lines": [
                "",
                "\tif (task_id == 0)",
                "\t\tsnprintf(buf, sizeof(buf), \"%d\", getpid());",
                "\telse",
                "\t\tsnprintf(buf, sizeof(buf), \"%hu\", task_id);",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2020-11501",
        "func_name": "gnutls/send_client_hello",
        "description": "GnuTLS 3.6.x before 3.6.13 uses incorrect cryptography for DTLS. The earliest affected version is 3.6.3 (2018-07-16) because of an error in a 2017-10-06 commit. The DTLS client always uses 32 '\\0' bytes instead of a random value, and thus contributes no randomness to a DTLS negotiation. This breaks the security guarantees of the DTLS protocol.",
        "git_url": "https://gitlab.com/gnutls/gnutls/-/commit/c01011c2d8533dbbbe754e49e256c109cb848d0d",
        "commit_title": "dtls client hello: fix zeroed random (fixes #960)",
        "commit_text": " This broke with bcf4de03 \"handshake: treat reply to HRR as a reply to hello verify request\", which failed to \"De Morgan\" properly.  ",
        "func_before": "static int send_client_hello(gnutls_session_t session, int again)\n{\n\tmbuffer_st *bufel = NULL;\n\tint type;\n\tint ret = 0;\n\tconst version_entry_st *hver, *min_ver, *max_ver;\n\tuint8_t tver[2];\n\tgnutls_buffer_st extdata;\n\tint rehandshake = 0;\n\tunsigned add_sr_scsv = 0;\n\tuint8_t session_id_len =\n\t    session->internals.resumed_security_parameters.session_id_size;\n\n\n\tif (again == 0) {\n\t\t/* note that rehandshake is different than resuming\n\t\t */\n\t\tif (session->internals.initial_negotiation_completed)\n\t\t\trehandshake = 1;\n\n\t\tret = _gnutls_buffer_init_handshake_mbuffer(&extdata);\n\t\tif (ret < 0)\n\t\t\treturn gnutls_assert_val(ret);\n\n\t\t/* if we are resuming a session then we set the\n\t\t * version number to the previously established.\n\t\t */\n\t\tif (session->internals.resumption_requested == 0 &&\n\t\t    session->internals.premaster_set == 0) {\n\t\t\tif (rehandshake)\t/* already negotiated version thus version_max == negotiated version */\n\t\t\t\thver = get_version(session);\n\t\t\telse\t/* new handshake. just get the max */\n\t\t\t\thver = _gnutls_legacy_version_max(session);\n\t\t} else {\n\t\t\t/* we are resuming a session */\n\t\t\thver =\n\t\t\t    session->internals.resumed_security_parameters.\n\t\t\t    pversion;\n\n\t\t\tif (hver && hver->tls13_sem)\n\t\t\t\thver = _gnutls_legacy_version_max(session);\n\t\t}\n\n\t\tif (hver == NULL) {\n\t\t\tgnutls_assert();\n\t\t\tif (session->internals.flags & INT_FLAG_NO_TLS13)\n\t\t\t\tret = GNUTLS_E_INSUFFICIENT_CREDENTIALS;\n\t\t\telse\n\t\t\t\tret = GNUTLS_E_NO_PRIORITIES_WERE_SET;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tif (unlikely(session->internals.default_hello_version[0] != 0)) {\n\t\t\ttver[0] = session->internals.default_hello_version[0];\n\t\t\ttver[1] = session->internals.default_hello_version[1];\n\t\t} else {\n\t\t\ttver[0] = hver->major;\n\t\t\ttver[1] = hver->minor;\n\t\t}\n\t\tret = _gnutls_buffer_append_data(&extdata, tver, 2);\n\t\tif (ret < 0) {\n\t\t\tgnutls_assert();\n\t\t\tgoto cleanup;\n\t\t}\n\t\t_gnutls_handshake_log(\"HSK[%p]: Adv. version: %u.%u\\n\", session,\n\t\t\t\t      (unsigned)tver[0], (unsigned)tver[1]);\n\n\t\tmin_ver = _gnutls_version_lowest(session);\n\t\tmax_ver = _gnutls_version_max(session);\n\t\tif (min_ver == NULL || max_ver == NULL) {\n\t\t\tgnutls_assert();\n\t\t\tret = GNUTLS_E_NO_PRIORITIES_WERE_SET;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* if we are replying to an HRR the version is already negotiated */\n\t\tif (!(session->internals.hsk_flags & HSK_HRR_RECEIVED) || !get_version(session)) {\n\t\t\t/* Set the version we advertized as maximum\n\t\t\t * (RSA uses it). */\n\t\t\tset_adv_version(session, hver->major, hver->minor);\n\t\t\tif (_gnutls_set_current_version(session, hver->id) < 0) {\n\t\t\t\tret = gnutls_assert_val(GNUTLS_E_UNSUPPORTED_VERSION_PACKET);\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t}\n\n\t\tif (session->internals.priorities->min_record_version != 0) {\n\t\t\t/* Advertize the lowest supported (SSL 3.0) record packet\n\t\t\t * version in record packets during the handshake.\n\t\t\t * That is to avoid confusing implementations\n\t\t\t * that do not support TLS 1.2 and don't know\n\t\t\t * how 3,3 version of record packets look like.\n\t\t\t */\n\t\t\tset_default_version(session, min_ver);\n\t\t} else {\n\t\t\tset_default_version(session, hver);\n\t\t}\n\n\t\t/* In order to know when this session was initiated.\n\t\t */\n\t\tsession->security_parameters.timestamp = gnutls_time(NULL);\n\n\t\t/* Generate random data\n\t\t */\n\t\tif (!(session->internals.hsk_flags & HSK_HRR_RECEIVED) &&\n\t\t    !(IS_DTLS(session) && session->internals.dtls.hsk_hello_verify_requests == 0)) {\n\t\t\tret = _gnutls_gen_client_random(session);\n\t\t\tif (ret < 0) {\n\t\t\t\tgnutls_assert();\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\n\t\t}\n\n\t\tret = _gnutls_buffer_append_data(&extdata,\n\t\t\t\t\t\t session->security_parameters.client_random,\n\t\t\t\t\t\t GNUTLS_RANDOM_SIZE);\n\t\tif (ret < 0) {\n\t\t\tgnutls_assert();\n\t\t\tgoto cleanup;\n\t\t}\n\n#ifdef TLS13_APPENDIX_D4\n\t\tif (max_ver->tls13_sem &&\n\t\t    session->security_parameters.session_id_size == 0) {\n\n\t\t\t/* Under TLS1.3 we generate a random session ID to make\n\t\t\t * the TLS1.3 session look like a resumed TLS1.2 session */\n\t\t\tret = _gnutls_generate_session_id(session->security_parameters.\n\t\t\t\t\t\t\t  session_id,\n\t\t\t\t\t\t\t  &session->security_parameters.\n\t\t\t\t\t\t\t  session_id_size);\n\t\t\tif (ret < 0) {\n\t\t\t\tgnutls_assert();\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t}\n#endif\n\n\t\t/* Copy the Session ID - if any\n\t\t */\n\t\tret = _gnutls_buffer_append_data_prefix(&extdata, 8,\n\t\t\t\t\t\t\tsession->internals.resumed_security_parameters.session_id,\n\t\t\t\t\t\t\tsession_id_len);\n\t\tif (ret < 0) {\n\t\t\tgnutls_assert();\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* Copy the DTLS cookie\n\t\t */\n\t\tif (IS_DTLS(session)) {\n\t\t\tret = _gnutls_buffer_append_data_prefix(&extdata, 8,\n\t\t\t\t\t\t\t\tsession->internals.dtls.dcookie.data,\n\t\t\t\t\t\t\t\tsession->internals.dtls.dcookie.size);\n\t\t\tif (ret < 0) {\n\t\t\t\tgnutls_assert();\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\t_gnutls_free_datum(&session->internals.dtls.dcookie);\n\t\t}\n\n\t\t/* Copy the ciphersuites.\n\t\t */\n#ifdef ENABLE_SSL3\n\t\t/* If using SSLv3 Send TLS_RENEGO_PROTECTION_REQUEST SCSV for MITM\n\t\t * prevention on initial negotiation (but not renegotiation; that's\n\t\t * handled with the RI extension below).\n\t\t */\n\t\tif (!session->internals.initial_negotiation_completed &&\n\t\t    session->security_parameters.entity == GNUTLS_CLIENT &&\n\t\t    (hver->id == GNUTLS_SSL3 &&\n\t\t     session->internals.priorities->no_extensions != 0)) {\n\t\t\tadd_sr_scsv = 1;\n\t\t}\n#endif\n\t\tret = _gnutls_get_client_ciphersuites(session, &extdata, min_ver, add_sr_scsv);\n\t\tif (ret < 0) {\n\t\t\tgnutls_assert();\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* Copy the compression methods.\n\t\t */\n\t\tret = append_null_comp(session, &extdata);\n\t\tif (ret < 0) {\n\t\t\tgnutls_assert();\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* Generate and copy TLS extensions.\n\t\t */\n\t\tif (session->internals.priorities->no_extensions == 0) {\n\t\t\tif (_gnutls_version_has_extensions(hver)) {\n\t\t\t\ttype = GNUTLS_EXT_ANY;\n\t\t\t} else {\n\t\t\t\ttype = GNUTLS_EXT_MANDATORY;\n\t\t\t}\n\n\t\t\tret =\n\t\t\t    _gnutls_gen_hello_extensions(session, &extdata,\n\t\t\t\t\t\t\t GNUTLS_EXT_FLAG_CLIENT_HELLO,\n\t\t\t\t\t\t\t type);\n\t\t\tif (ret < 0) {\n\t\t\t\tgnutls_assert();\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t}\n\n\t\tbufel = _gnutls_buffer_to_mbuffer(&extdata);\n\t}\n\n\tret = _gnutls_send_handshake(session, bufel,\n\t\t\t\t     GNUTLS_HANDSHAKE_CLIENT_HELLO);\n\n\treturn ret;\n\n cleanup:\n\t_gnutls_buffer_clear(&extdata);\n\treturn ret;\n}",
        "func": "static int send_client_hello(gnutls_session_t session, int again)\n{\n\tmbuffer_st *bufel = NULL;\n\tint type;\n\tint ret = 0;\n\tconst version_entry_st *hver, *min_ver, *max_ver;\n\tuint8_t tver[2];\n\tgnutls_buffer_st extdata;\n\tint rehandshake = 0;\n\tunsigned add_sr_scsv = 0;\n\tuint8_t session_id_len =\n\t    session->internals.resumed_security_parameters.session_id_size;\n\n\n\tif (again == 0) {\n\t\t/* note that rehandshake is different than resuming\n\t\t */\n\t\tif (session->internals.initial_negotiation_completed)\n\t\t\trehandshake = 1;\n\n\t\tret = _gnutls_buffer_init_handshake_mbuffer(&extdata);\n\t\tif (ret < 0)\n\t\t\treturn gnutls_assert_val(ret);\n\n\t\t/* if we are resuming a session then we set the\n\t\t * version number to the previously established.\n\t\t */\n\t\tif (session->internals.resumption_requested == 0 &&\n\t\t    session->internals.premaster_set == 0) {\n\t\t\tif (rehandshake)\t/* already negotiated version thus version_max == negotiated version */\n\t\t\t\thver = get_version(session);\n\t\t\telse\t/* new handshake. just get the max */\n\t\t\t\thver = _gnutls_legacy_version_max(session);\n\t\t} else {\n\t\t\t/* we are resuming a session */\n\t\t\thver =\n\t\t\t    session->internals.resumed_security_parameters.\n\t\t\t    pversion;\n\n\t\t\tif (hver && hver->tls13_sem)\n\t\t\t\thver = _gnutls_legacy_version_max(session);\n\t\t}\n\n\t\tif (hver == NULL) {\n\t\t\tgnutls_assert();\n\t\t\tif (session->internals.flags & INT_FLAG_NO_TLS13)\n\t\t\t\tret = GNUTLS_E_INSUFFICIENT_CREDENTIALS;\n\t\t\telse\n\t\t\t\tret = GNUTLS_E_NO_PRIORITIES_WERE_SET;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\tif (unlikely(session->internals.default_hello_version[0] != 0)) {\n\t\t\ttver[0] = session->internals.default_hello_version[0];\n\t\t\ttver[1] = session->internals.default_hello_version[1];\n\t\t} else {\n\t\t\ttver[0] = hver->major;\n\t\t\ttver[1] = hver->minor;\n\t\t}\n\t\tret = _gnutls_buffer_append_data(&extdata, tver, 2);\n\t\tif (ret < 0) {\n\t\t\tgnutls_assert();\n\t\t\tgoto cleanup;\n\t\t}\n\t\t_gnutls_handshake_log(\"HSK[%p]: Adv. version: %u.%u\\n\", session,\n\t\t\t\t      (unsigned)tver[0], (unsigned)tver[1]);\n\n\t\tmin_ver = _gnutls_version_lowest(session);\n\t\tmax_ver = _gnutls_version_max(session);\n\t\tif (min_ver == NULL || max_ver == NULL) {\n\t\t\tgnutls_assert();\n\t\t\tret = GNUTLS_E_NO_PRIORITIES_WERE_SET;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* if we are replying to an HRR the version is already negotiated */\n\t\tif (!(session->internals.hsk_flags & HSK_HRR_RECEIVED) || !get_version(session)) {\n\t\t\t/* Set the version we advertized as maximum\n\t\t\t * (RSA uses it). */\n\t\t\tset_adv_version(session, hver->major, hver->minor);\n\t\t\tif (_gnutls_set_current_version(session, hver->id) < 0) {\n\t\t\t\tret = gnutls_assert_val(GNUTLS_E_UNSUPPORTED_VERSION_PACKET);\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t}\n\n\t\tif (session->internals.priorities->min_record_version != 0) {\n\t\t\t/* Advertize the lowest supported (SSL 3.0) record packet\n\t\t\t * version in record packets during the handshake.\n\t\t\t * That is to avoid confusing implementations\n\t\t\t * that do not support TLS 1.2 and don't know\n\t\t\t * how 3,3 version of record packets look like.\n\t\t\t */\n\t\t\tset_default_version(session, min_ver);\n\t\t} else {\n\t\t\tset_default_version(session, hver);\n\t\t}\n\n\t\t/* In order to know when this session was initiated.\n\t\t */\n\t\tsession->security_parameters.timestamp = gnutls_time(NULL);\n\n\t\t/* Generate random data\n\t\t */\n\t\tif (!(session->internals.hsk_flags & HSK_HRR_RECEIVED) &&\n\t\t    !(IS_DTLS(session) && session->internals.dtls.hsk_hello_verify_requests != 0)) {\n\t\t\tret = _gnutls_gen_client_random(session);\n\t\t\tif (ret < 0) {\n\t\t\t\tgnutls_assert();\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\n\t\t}\n\n\t\tret = _gnutls_buffer_append_data(&extdata,\n\t\t\t\t\t\t session->security_parameters.client_random,\n\t\t\t\t\t\t GNUTLS_RANDOM_SIZE);\n\t\tif (ret < 0) {\n\t\t\tgnutls_assert();\n\t\t\tgoto cleanup;\n\t\t}\n\n#ifdef TLS13_APPENDIX_D4\n\t\tif (max_ver->tls13_sem &&\n\t\t    session->security_parameters.session_id_size == 0) {\n\n\t\t\t/* Under TLS1.3 we generate a random session ID to make\n\t\t\t * the TLS1.3 session look like a resumed TLS1.2 session */\n\t\t\tret = _gnutls_generate_session_id(session->security_parameters.\n\t\t\t\t\t\t\t  session_id,\n\t\t\t\t\t\t\t  &session->security_parameters.\n\t\t\t\t\t\t\t  session_id_size);\n\t\t\tif (ret < 0) {\n\t\t\t\tgnutls_assert();\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t}\n#endif\n\n\t\t/* Copy the Session ID - if any\n\t\t */\n\t\tret = _gnutls_buffer_append_data_prefix(&extdata, 8,\n\t\t\t\t\t\t\tsession->internals.resumed_security_parameters.session_id,\n\t\t\t\t\t\t\tsession_id_len);\n\t\tif (ret < 0) {\n\t\t\tgnutls_assert();\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* Copy the DTLS cookie\n\t\t */\n\t\tif (IS_DTLS(session)) {\n\t\t\tret = _gnutls_buffer_append_data_prefix(&extdata, 8,\n\t\t\t\t\t\t\t\tsession->internals.dtls.dcookie.data,\n\t\t\t\t\t\t\t\tsession->internals.dtls.dcookie.size);\n\t\t\tif (ret < 0) {\n\t\t\t\tgnutls_assert();\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\t_gnutls_free_datum(&session->internals.dtls.dcookie);\n\t\t}\n\n\t\t/* Copy the ciphersuites.\n\t\t */\n#ifdef ENABLE_SSL3\n\t\t/* If using SSLv3 Send TLS_RENEGO_PROTECTION_REQUEST SCSV for MITM\n\t\t * prevention on initial negotiation (but not renegotiation; that's\n\t\t * handled with the RI extension below).\n\t\t */\n\t\tif (!session->internals.initial_negotiation_completed &&\n\t\t    session->security_parameters.entity == GNUTLS_CLIENT &&\n\t\t    (hver->id == GNUTLS_SSL3 &&\n\t\t     session->internals.priorities->no_extensions != 0)) {\n\t\t\tadd_sr_scsv = 1;\n\t\t}\n#endif\n\t\tret = _gnutls_get_client_ciphersuites(session, &extdata, min_ver, add_sr_scsv);\n\t\tif (ret < 0) {\n\t\t\tgnutls_assert();\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* Copy the compression methods.\n\t\t */\n\t\tret = append_null_comp(session, &extdata);\n\t\tif (ret < 0) {\n\t\t\tgnutls_assert();\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* Generate and copy TLS extensions.\n\t\t */\n\t\tif (session->internals.priorities->no_extensions == 0) {\n\t\t\tif (_gnutls_version_has_extensions(hver)) {\n\t\t\t\ttype = GNUTLS_EXT_ANY;\n\t\t\t} else {\n\t\t\t\ttype = GNUTLS_EXT_MANDATORY;\n\t\t\t}\n\n\t\t\tret =\n\t\t\t    _gnutls_gen_hello_extensions(session, &extdata,\n\t\t\t\t\t\t\t GNUTLS_EXT_FLAG_CLIENT_HELLO,\n\t\t\t\t\t\t\t type);\n\t\t\tif (ret < 0) {\n\t\t\t\tgnutls_assert();\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t}\n\n\t\tbufel = _gnutls_buffer_to_mbuffer(&extdata);\n\t}\n\n\tret = _gnutls_send_handshake(session, bufel,\n\t\t\t\t     GNUTLS_HANDSHAKE_CLIENT_HELLO);\n\n\treturn ret;\n\n cleanup:\n\t_gnutls_buffer_clear(&extdata);\n\treturn ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -103,7 +103,7 @@\n \t\t/* Generate random data\n \t\t */\n \t\tif (!(session->internals.hsk_flags & HSK_HRR_RECEIVED) &&\n-\t\t    !(IS_DTLS(session) && session->internals.dtls.hsk_hello_verify_requests == 0)) {\n+\t\t    !(IS_DTLS(session) && session->internals.dtls.hsk_hello_verify_requests != 0)) {\n \t\t\tret = _gnutls_gen_client_random(session);\n \t\t\tif (ret < 0) {\n \t\t\t\tgnutls_assert();",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t    !(IS_DTLS(session) && session->internals.dtls.hsk_hello_verify_requests == 0)) {"
            ],
            "added_lines": [
                "\t\t    !(IS_DTLS(session) && session->internals.dtls.hsk_hello_verify_requests != 0)) {"
            ]
        }
    }
]