[
    {
        "cve_id": "CVE-2019-12589",
        "func_name": "netblue30/firejail/fslib_copy_libs",
        "description": "In Firejail before 0.9.60, seccomp filters are writable inside the jail, leading to a lack of intended seccomp restrictions for a process that is joined to the jail after a filter has been modified by an attacker.",
        "git_url": "https://github.com/netblue30/firejail/commit/eecf35c2f8249489a1d3e512bb07f0d427183134",
        "commit_title": "mount runtime seccomp files read-only (#2602)",
        "commit_text": " avoid creating locations in the file system that are both writable and\r executable (in this case for processes with euid of the user).\r \r for the same reason also remove user owned libfiles\r when it is not needed any more",
        "func_before": "void fslib_copy_libs(const char *full_path) {\n\tassert(full_path);\n\tif (arg_debug || arg_debug_private_lib)\n\t\tprintf(\"    fslib_copy_libs %s\\n\", full_path);\n\n\t// if library/executable does not exist or the user does not have read access to it\n\t// print a warning and exit the function.\n\tif (access(full_path, R_OK)) {\n\t\tif (arg_debug || arg_debug_private_lib)\n\t\t\tprintf(\"cannot find %s for private-lib, skipping...\\n\", full_path);\n\t\treturn;\n\t}\n\n\t// create an empty RUN_LIB_FILE and allow the user to write to it\n\tunlink(RUN_LIB_FILE);\t\t\t  // in case is there\n\tcreate_empty_file_as_root(RUN_LIB_FILE, 0644);\n\tif (chown(RUN_LIB_FILE, getuid(), getgid()))\n\t\terrExit(\"chown\");\n\n\t// run fldd to extract the list of files\n\tif (arg_debug || arg_debug_private_lib)\n\t\tprintf(\"    running fldd %s\\n\", full_path);\n\tsbox_run(SBOX_USER | SBOX_SECCOMP | SBOX_CAPS_NONE, 3, PATH_FLDD, full_path, RUN_LIB_FILE);\n\n\t// open the list of libraries and install them on by one\n\tFILE *fp = fopen(RUN_LIB_FILE, \"r\");\n\tif (!fp)\n\t\terrExit(\"fopen\");\n\n\tchar buf[MAXBUF];\n\twhile (fgets(buf, MAXBUF, fp)) {\n\t\t// remove \\n\n\t\tchar *ptr = strchr(buf, '\\n');\n\t\tif (ptr)\n\t\t\t*ptr = '\\0';\n\t\tfslib_duplicate(buf);\n\t}\n\tfclose(fp);\n}",
        "func": "void fslib_copy_libs(const char *full_path) {\n\tassert(full_path);\n\tif (arg_debug || arg_debug_private_lib)\n\t\tprintf(\"    fslib_copy_libs %s\\n\", full_path);\n\n\t// if library/executable does not exist or the user does not have read access to it\n\t// print a warning and exit the function.\n\tif (access(full_path, R_OK)) {\n\t\tif (arg_debug || arg_debug_private_lib)\n\t\t\tprintf(\"cannot find %s for private-lib, skipping...\\n\", full_path);\n\t\treturn;\n\t}\n\n\t// create an empty RUN_LIB_FILE and allow the user to write to it\n\tunlink(RUN_LIB_FILE);\t\t\t  // in case is there\n\tcreate_empty_file_as_root(RUN_LIB_FILE, 0644);\n\tif (chown(RUN_LIB_FILE, getuid(), getgid()))\n\t\terrExit(\"chown\");\n\n\t// run fldd to extract the list of files\n\tif (arg_debug || arg_debug_private_lib)\n\t\tprintf(\"    running fldd %s\\n\", full_path);\n\tsbox_run(SBOX_USER | SBOX_SECCOMP | SBOX_CAPS_NONE, 3, PATH_FLDD, full_path, RUN_LIB_FILE);\n\n\t// open the list of libraries and install them on by one\n\tFILE *fp = fopen(RUN_LIB_FILE, \"r\");\n\tif (!fp)\n\t\terrExit(\"fopen\");\n\n\tchar buf[MAXBUF];\n\twhile (fgets(buf, MAXBUF, fp)) {\n\t\t// remove \\n\n\t\tchar *ptr = strchr(buf, '\\n');\n\t\tif (ptr)\n\t\t\t*ptr = '\\0';\n\t\tfslib_duplicate(buf);\n\t}\n\tfclose(fp);\n\tunlink(RUN_LIB_FILE);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -36,4 +36,5 @@\n \t\tfslib_duplicate(buf);\n \t}\n \tfclose(fp);\n+\tunlink(RUN_LIB_FILE);\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tunlink(RUN_LIB_FILE);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-12589",
        "func_name": "netblue30/firejail/preproc_mount_mnt_dir",
        "description": "In Firejail before 0.9.60, seccomp filters are writable inside the jail, leading to a lack of intended seccomp restrictions for a process that is joined to the jail after a filter has been modified by an attacker.",
        "git_url": "https://github.com/netblue30/firejail/commit/eecf35c2f8249489a1d3e512bb07f0d427183134",
        "commit_title": "mount runtime seccomp files read-only (#2602)",
        "commit_text": " avoid creating locations in the file system that are both writable and\r executable (in this case for processes with euid of the user).\r \r for the same reason also remove user owned libfiles\r when it is not needed any more",
        "func_before": "void preproc_mount_mnt_dir(void) {\n\t// mount tmpfs on top of /run/firejail/mnt\n\tif (!tmpfs_mounted) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on %s directory\\n\", RUN_MNT_DIR);\n\t\tif (mount(\"tmpfs\", RUN_MNT_DIR, \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting /run/firejail/mnt\");\n\t\ttmpfs_mounted = 1;\n\t\tfs_logger2(\"tmpfs\", RUN_MNT_DIR);\n\n#ifdef HAVE_SECCOMP\n\t\tif (arg_seccomp_block_secondary)\n\t\t\tcopy_file(PATH_SECCOMP_BLOCK_SECONDARY, RUN_SECCOMP_BLOCK_SECONDARY, getuid(), getgid(), 0644); // root needed\n\t\telse {\n\t\t\t//copy default seccomp files\n\t\t\tcopy_file(PATH_SECCOMP_32, RUN_SECCOMP_32, getuid(), getgid(), 0644); // root needed\n\t\t}\n\t\tif (arg_allow_debuggers)\n\t\t\tcopy_file(PATH_SECCOMP_DEFAULT_DEBUG, RUN_SECCOMP_CFG, getuid(), getgid(), 0644); // root needed\n\t\telse\n\t\t\tcopy_file(PATH_SECCOMP_DEFAULT, RUN_SECCOMP_CFG, getuid(), getgid(), 0644); // root needed\n\n\t\tif (arg_memory_deny_write_execute)\n\t\t\tcopy_file(PATH_SECCOMP_MDWX, RUN_SECCOMP_MDWX, getuid(), getgid(), 0644); // root needed\n\t\t// as root, create empty RUN_SECCOMP_PROTOCOL and RUN_SECCOMP_POSTEXEC files\n\t\tcreate_empty_file_as_root(RUN_SECCOMP_PROTOCOL, 0644);\n\t\tif (set_perms(RUN_SECCOMP_PROTOCOL, getuid(), getgid(), 0644))\n\t\t\terrExit(\"set_perms\");\n\t\tcreate_empty_file_as_root(RUN_SECCOMP_POSTEXEC, 0644);\n\t\tif (set_perms(RUN_SECCOMP_POSTEXEC, getuid(), getgid(), 0644))\n\t\t\terrExit(\"set_perms\");\n#endif\n\t}\n}",
        "func": "void preproc_mount_mnt_dir(void) {\n\t// mount tmpfs on top of /run/firejail/mnt\n\tif (!tmpfs_mounted) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Mounting tmpfs on %s directory\\n\", RUN_MNT_DIR);\n\t\tif (mount(\"tmpfs\", RUN_MNT_DIR, \"tmpfs\", MS_NOSUID | MS_STRICTATIME,  \"mode=755,gid=0\") < 0)\n\t\t\terrExit(\"mounting /run/firejail/mnt\");\n\t\ttmpfs_mounted = 1;\n\t\tfs_logger2(\"tmpfs\", RUN_MNT_DIR);\n\n#ifdef HAVE_SECCOMP\n\t\tcreate_empty_dir_as_root(RUN_SECCOMP_DIR, 0755);\n\n\t\tif (arg_seccomp_block_secondary)\n\t\t\tcopy_file(PATH_SECCOMP_BLOCK_SECONDARY, RUN_SECCOMP_BLOCK_SECONDARY, getuid(), getgid(), 0644); // root needed\n\t\telse {\n\t\t\t//copy default seccomp files\n\t\t\tcopy_file(PATH_SECCOMP_32, RUN_SECCOMP_32, getuid(), getgid(), 0644); // root needed\n\t\t}\n\t\tif (arg_allow_debuggers)\n\t\t\tcopy_file(PATH_SECCOMP_DEFAULT_DEBUG, RUN_SECCOMP_CFG, getuid(), getgid(), 0644); // root needed\n\t\telse\n\t\t\tcopy_file(PATH_SECCOMP_DEFAULT, RUN_SECCOMP_CFG, getuid(), getgid(), 0644); // root needed\n\n\t\tif (arg_memory_deny_write_execute)\n\t\t\tcopy_file(PATH_SECCOMP_MDWX, RUN_SECCOMP_MDWX, getuid(), getgid(), 0644); // root needed\n\t\t// as root, create empty RUN_SECCOMP_PROTOCOL and RUN_SECCOMP_POSTEXEC files\n\t\tcreate_empty_file_as_root(RUN_SECCOMP_PROTOCOL, 0644);\n\t\tif (set_perms(RUN_SECCOMP_PROTOCOL, getuid(), getgid(), 0644))\n\t\t\terrExit(\"set_perms\");\n\t\tcreate_empty_file_as_root(RUN_SECCOMP_POSTEXEC, 0644);\n\t\tif (set_perms(RUN_SECCOMP_POSTEXEC, getuid(), getgid(), 0644))\n\t\t\terrExit(\"set_perms\");\n#endif\n\t}\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -9,6 +9,8 @@\n \t\tfs_logger2(\"tmpfs\", RUN_MNT_DIR);\n \n #ifdef HAVE_SECCOMP\n+\t\tcreate_empty_dir_as_root(RUN_SECCOMP_DIR, 0755);\n+\n \t\tif (arg_seccomp_block_secondary)\n \t\t\tcopy_file(PATH_SECCOMP_BLOCK_SECONDARY, RUN_SECCOMP_BLOCK_SECONDARY, getuid(), getgid(), 0644); // root needed\n \t\telse {",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\tcreate_empty_dir_as_root(RUN_SECCOMP_DIR, 0755);",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2019-12589",
        "func_name": "netblue30/firejail/sandbox",
        "description": "In Firejail before 0.9.60, seccomp filters are writable inside the jail, leading to a lack of intended seccomp restrictions for a process that is joined to the jail after a filter has been modified by an attacker.",
        "git_url": "https://github.com/netblue30/firejail/commit/eecf35c2f8249489a1d3e512bb07f0d427183134",
        "commit_title": "mount runtime seccomp files read-only (#2602)",
        "commit_text": " avoid creating locations in the file system that are both writable and\r executable (in this case for processes with euid of the user).\r \r for the same reason also remove user owned libfiles\r when it is not needed any more",
        "func_before": "int sandbox(void* sandbox_arg) {\n\t// Get rid of unused parameter warning\n\t(void)sandbox_arg;\n\n\tpid_t child_pid = getpid();\n\tif (arg_debug)\n\t\tprintf(\"Initializing child process\\n\");\n\n \t// close each end of the unused pipes\n \tclose(parent_to_child_fds[1]);\n \tclose(child_to_parent_fds[0]);\n\n \t// wait for parent to do base setup\n \twait_for_other(parent_to_child_fds[0]);\n\n\tif (arg_debug && child_pid == 1)\n\t\tprintf(\"PID namespace installed\\n\");\n\n\n\t//****************************\n\t// set hostname\n\t//****************************\n\tif (cfg.hostname) {\n\t\tif (sethostname(cfg.hostname, strlen(cfg.hostname)) < 0)\n\t\t\terrExit(\"sethostname\");\n\t}\n\n\t//****************************\n\t// mount namespace\n\t//****************************\n\t// mount events are not forwarded between the host the sandbox\n\tif (mount(NULL, \"/\", NULL, MS_SLAVE | MS_REC, NULL) < 0) {\n\t\tchk_chroot();\n\t}\n\t// ... and mount a tmpfs on top of /run/firejail/mnt directory\n\tpreproc_mount_mnt_dir();\n\t// bind-mount firejail binaries and helper programs\n\tif (mount(LIBDIR \"/firejail\", RUN_FIREJAIL_LIB_DIR, \"none\", MS_BIND, NULL) < 0)\n\t\terrExit(\"mounting \" RUN_FIREJAIL_LIB_DIR);\n\n\t//****************************\n\t// log sandbox data\n\t//****************************\n\tif (cfg.name)\n\t\tfs_logger2(\"sandbox name:\", cfg.name);\n\tfs_logger2int(\"sandbox pid:\", (int) sandbox_pid);\n\tif (cfg.chrootdir)\n\t\tfs_logger(\"sandbox filesystem: chroot\");\n\telse if (arg_overlay)\n\t\tfs_logger(\"sandbox filesystem: overlay\");\n\telse\n\t\tfs_logger(\"sandbox filesystem: local\");\n\tfs_logger(\"install mount namespace\");\n\n\t//****************************\n\t// netfilter\n\t//****************************\n\tif (arg_netfilter && any_bridge_configured()) { // assuming by default the client filter\n\t\tnetfilter(arg_netfilter_file);\n\t}\n\tif (arg_netfilter6 && any_bridge_configured()) { // assuming by default the client filter\n\t\tnetfilter6(arg_netfilter6_file);\n\t}\n\n\t//****************************\n\t// networking\n\t//****************************\n\tint gw_cfg_failed = 0; // default gw configuration flag\n\tif (arg_nonetwork) {\n\t\tnet_if_up(\"lo\");\n\t\tif (arg_debug)\n\t\t\tprintf(\"Network namespace enabled, only loopback interface available\\n\");\n\t}\n\telse if (arg_netns) {\n\t\tnetns(arg_netns);\n\t\tif (arg_debug)\n\t\t\tprintf(\"Network namespace '%s' activated\\n\", arg_netns);\n\t}\n\telse if (any_bridge_configured() || any_interface_configured()) {\n\t\t// configure lo and eth0...eth3\n\t\tnet_if_up(\"lo\");\n\n\t\tif (mac_not_zero(cfg.bridge0.macsandbox))\n\t\t\tnet_config_mac(cfg.bridge0.devsandbox, cfg.bridge0.macsandbox);\n\t\tsandbox_if_up(&cfg.bridge0);\n\n\t\tif (mac_not_zero(cfg.bridge1.macsandbox))\n\t\t\tnet_config_mac(cfg.bridge1.devsandbox, cfg.bridge1.macsandbox);\n\t\tsandbox_if_up(&cfg.bridge1);\n\n\t\tif (mac_not_zero(cfg.bridge2.macsandbox))\n\t\t\tnet_config_mac(cfg.bridge2.devsandbox, cfg.bridge2.macsandbox);\n\t\tsandbox_if_up(&cfg.bridge2);\n\n\t\tif (mac_not_zero(cfg.bridge3.macsandbox))\n\t\t\tnet_config_mac(cfg.bridge3.devsandbox, cfg.bridge3.macsandbox);\n\t\tsandbox_if_up(&cfg.bridge3);\n\n\n\t\t// moving an interface in a namespace using --interface will reset the interface configuration;\n\t\t// we need to put the configuration back\n\t\tif (cfg.interface0.configured && cfg.interface0.ip) {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Configuring %d.%d.%d.%d address on interface %s\\n\", PRINT_IP(cfg.interface0.ip), cfg.interface0.dev);\n\t\t\tnet_config_interface(cfg.interface0.dev, cfg.interface0.ip, cfg.interface0.mask, cfg.interface0.mtu);\n\t\t}\n\t\tif (cfg.interface1.configured && cfg.interface1.ip) {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Configuring %d.%d.%d.%d address on interface %s\\n\", PRINT_IP(cfg.interface1.ip), cfg.interface1.dev);\n\t\t\tnet_config_interface(cfg.interface1.dev, cfg.interface1.ip, cfg.interface1.mask, cfg.interface1.mtu);\n\t\t}\n\t\tif (cfg.interface2.configured && cfg.interface2.ip) {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Configuring %d.%d.%d.%d address on interface %s\\n\", PRINT_IP(cfg.interface2.ip), cfg.interface2.dev);\n\t\t\tnet_config_interface(cfg.interface2.dev, cfg.interface2.ip, cfg.interface2.mask, cfg.interface2.mtu);\n\t\t}\n\t\tif (cfg.interface3.configured && cfg.interface3.ip) {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Configuring %d.%d.%d.%d address on interface %s\\n\", PRINT_IP(cfg.interface3.ip), cfg.interface3.dev);\n\t\t\tnet_config_interface(cfg.interface3.dev, cfg.interface3.ip, cfg.interface3.mask, cfg.interface3.mtu);\n\t\t}\n\n\t\t// add a default route\n\t\tif (cfg.defaultgw) {\n\t\t\t// set the default route\n\t\t\tif (net_add_route(0, 0, cfg.defaultgw)) {\n\t\t\t\tfwarning(\"cannot configure default route\\n\");\n\t\t\t\tgw_cfg_failed = 1;\n\t\t\t}\n\t\t}\n\n\t\tif (arg_debug)\n\t\t\tprintf(\"Network namespace enabled\\n\");\n\t}\n\n\t// print network configuration\n\tif (!arg_quiet) {\n\t\tif (any_bridge_configured() || any_interface_configured() || cfg.defaultgw || cfg.dns1) {\n\t\t\tfmessage(\"\\n\");\n\t\t\tif (any_bridge_configured() || any_interface_configured()) {\n\t\t\t\tif (arg_scan)\n\t\t\t\t\tsbox_run(SBOX_ROOT | SBOX_CAPS_NETWORK | SBOX_SECCOMP, 3, PATH_FNET, \"printif\", \"scan\");\n\t\t\t\telse\n\t\t\t\t\tsbox_run(SBOX_ROOT | SBOX_CAPS_NETWORK | SBOX_SECCOMP, 2, PATH_FNET, \"printif\");\n\n\t\t\t}\n\t\t\tif (cfg.defaultgw != 0) {\n\t\t\t\tif (gw_cfg_failed)\n\t\t\t\t\tfmessage(\"Default gateway configuration failed\\n\");\n\t\t\t\telse\n\t\t\t\t\tfmessage(\"Default gateway %d.%d.%d.%d\\n\", PRINT_IP(cfg.defaultgw));\n\t\t\t}\n\t\t\tif (cfg.dns1 != NULL)\n\t\t\t\tfmessage(\"DNS server %s\\n\", cfg.dns1);\n\t\t\tif (cfg.dns2 != NULL)\n\t\t\t\tfmessage(\"DNS server %s\\n\", cfg.dns2);\n\t\t\tif (cfg.dns3 != NULL)\n\t\t\t\tfmessage(\"DNS server %s\\n\", cfg.dns3);\n\t\t\tif (cfg.dns4 != NULL)\n\t\t\t\tfmessage(\"DNS server %s\\n\", cfg.dns4);\n\t\t\tfmessage(\"\\n\");\n\t\t}\n\t}\n\n\t// load IBUS env variables\n\tif (arg_nonetwork || any_bridge_configured() || any_interface_configured()) {\n\t\t// do nothing - there are problems with ibus version 1.5.11\n\t}\n\telse {\n\t\tEUID_USER();\n\t\tenv_ibus_load();\n\t\tEUID_ROOT();\n\t}\n\n\t//****************************\n\t// fs pre-processing:\n\t//  - build seccomp filters\n\t//  - create an empty /etc/ld.so.preload\n\t//****************************\n#ifdef HAVE_SECCOMP\n\tif (cfg.protocol) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Build protocol filter: %s\\n\", cfg.protocol);\n\n\t\t// build the seccomp filter as a regular user\n\t\tint rv = sbox_run(SBOX_USER | SBOX_CAPS_NONE | SBOX_SECCOMP, 5,\n\t\t\tPATH_FSECCOMP, \"protocol\", \"build\", cfg.protocol, RUN_SECCOMP_PROTOCOL);\n\t\tif (rv)\n\t\t\texit(rv);\n\t}\n\tif (arg_seccomp && (cfg.seccomp_list || cfg.seccomp_list_drop || cfg.seccomp_list_keep))\n\t\targ_seccomp_postexec = 1;\n#endif\n\n\t// need ld.so.preload if tracing or seccomp with any non-default lists\n\tbool need_preload = arg_trace || arg_tracelog || arg_seccomp_postexec;\n\t// for --appimage, --chroot and --overlay* we force NO_NEW_PRIVS\n\t// and drop all capabilities\n\tif (getuid() != 0 && (arg_appimage || cfg.chrootdir || arg_overlay)) {\n\t\tenforce_filters();\n\t\tneed_preload = arg_trace || arg_tracelog;\n\t}\n\n\t// trace pre-install\n\tif (need_preload)\n\t\tfs_trace_preload();\n\n\t// store hosts file\n\tif (cfg.hosts_file)\n\t\tfs_store_hosts_file();\n\n\t//****************************\n\t// configure filesystem\n\t//****************************\n#ifdef HAVE_CHROOT\n\tif (cfg.chrootdir) {\n\t\tfs_chroot(cfg.chrootdir);\n\n\t\t//****************************\n\t\t// trace pre-install, this time inside chroot\n\t\t//****************************\n\t\tif (need_preload)\n\t\t\tfs_trace_preload();\n\t}\n\telse\n#endif\n#ifdef HAVE_OVERLAYFS\n\tif (arg_overlay)\n\t\tfs_overlayfs();\n\telse\n#endif\n\t\tfs_basic_fs();\n\n\t//****************************\n\t// private mode\n\t//****************************\n\tif (arg_private) {\n\t\tif (cfg.home_private) {\t// --private=\n\t\t\tif (cfg.chrootdir)\n\t\t\t\tfwarning(\"private=directory feature is disabled in chroot\\n\");\n\t\t\telse if (arg_overlay)\n\t\t\t\tfwarning(\"private=directory feature is disabled in overlay\\n\");\n\t\t\telse\n\t\t\t\tfs_private_homedir();\n\t\t}\n\t\telse if (cfg.home_private_keep) { // --private-home=\n\t\t\tif (cfg.chrootdir)\n\t\t\t\tfwarning(\"private-home= feature is disabled in chroot\\n\");\n\t\t\telse if (arg_overlay)\n\t\t\t\tfwarning(\"private-home= feature is disabled in overlay\\n\");\n\t\t\telse\n\t\t\t\tfs_private_home_list();\n\t\t}\n\t\telse // --private\n\t\t\tfs_private();\n\t}\n\n\tif (arg_private_dev)\n\t\tfs_private_dev();\n\n\tif (arg_private_etc) {\n\t\tif (cfg.chrootdir)\n\t\t\tfwarning(\"private-etc feature is disabled in chroot\\n\");\n\t\telse if (arg_overlay)\n\t\t\tfwarning(\"private-etc feature is disabled in overlay\\n\");\n\t\telse {\n\t\t\tfs_private_dir_list(\"/etc\", RUN_ETC_DIR, cfg.etc_private_keep);\n\t\t\t// create /etc/ld.so.preload file again\n\t\t\tif (need_preload)\n\t\t\t\tfs_trace_preload();\n\t\t}\n\t}\n\n\tif (arg_private_opt) {\n\t\tif (cfg.chrootdir)\n\t\t\tfwarning(\"private-opt feature is disabled in chroot\\n\");\n\t\telse if (arg_overlay)\n\t\t\tfwarning(\"private-opt feature is disabled in overlay\\n\");\n\t\telse {\n\t\t\tfs_private_dir_list(\"/opt\", RUN_OPT_DIR, cfg.opt_private_keep);\n\t\t}\n\t}\n\n\tif (arg_private_srv) {\n\t\tif (cfg.chrootdir)\n\t\t\tfwarning(\"private-srv feature is disabled in chroot\\n\");\n\t\telse if (arg_overlay)\n\t\t\tfwarning(\"private-srv feature is disabled in overlay\\n\");\n\t\telse {\n\t\t\tfs_private_dir_list(\"/srv\", RUN_SRV_DIR, cfg.srv_private_keep);\n\t\t}\n\t}\n\n\t// private-bin is disabled for appimages\n\tif (arg_private_bin && !arg_appimage) {\n\t\tif (cfg.chrootdir)\n\t\t\tfwarning(\"private-bin feature is disabled in chroot\\n\");\n\t\telse if (arg_overlay)\n\t\t\tfwarning(\"private-bin feature is disabled in overlay\\n\");\n\t\telse {\n\t\t\t// for --x11=xorg we need to add xauth command\n\t\t\tif (arg_x11_xorg) {\n\t\t\t\tEUID_USER();\n\t\t\t\tchar *tmp;\n\t\t\t\tif (asprintf(&tmp, \"%s,xauth\", cfg.bin_private_keep) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t\tcfg.bin_private_keep = tmp;\n\t\t\t\tEUID_ROOT();\n\t\t\t}\n\t\t\tfs_private_bin_list();\n\t\t}\n\t}\n\n\t// private-lib is disabled for appimages\n\tif (arg_private_lib && !arg_appimage) {\n\t\tif (cfg.chrootdir)\n\t\t\tfwarning(\"private-lib feature is disabled in chroot\\n\");\n\t\telse if (arg_overlay)\n\t\t\tfwarning(\"private-lib feature is disabled in overlay\\n\");\n\t\telse {\n\t\t\tfs_private_lib();\n\t\t}\n\t}\n\n\tif (arg_private_cache) {\n\t\tif (cfg.chrootdir)\n\t\t\tfwarning(\"private-cache feature is disabled in chroot\\n\");\n\t\telse if (arg_overlay)\n\t\t\tfwarning(\"private-cache feature is disabled in overlay\\n\");\n\t\telse\n\t\t\tfs_private_cache();\n\t}\n\n\tif (arg_private_tmp) {\n\t\t// private-tmp is implemented as a whitelist\n\t\tEUID_USER();\n\t\tfs_private_tmp();\n\t\tEUID_ROOT();\n\t}\n\n\t//****************************\n\t// Session D-BUS\n\t//****************************\n\tif (arg_nodbus)\n\t\tdbus_session_disable();\n\n\n\t//****************************\n\t// hosts and hostname\n\t//****************************\n\tif (cfg.hostname)\n\t\tfs_hostname(cfg.hostname);\n\n\tif (cfg.hosts_file)\n\t\tfs_mount_hosts_file();\n\n\t//****************************\n\t// /etc overrides from the network namespace\n\t//****************************\n\tif (arg_netns)\n\t\tnetns_mounts(arg_netns);\n\n\t//****************************\n\t// update /proc, /sys, /dev, /boot directory\n\t//****************************\n\tfs_proc_sys_dev_boot();\n\n\t//****************************\n\t// handle /mnt and /media\n\t//****************************\n\tif (checkcfg(CFG_DISABLE_MNT))\n\t\tfs_mnt(1);\n\telse if (arg_disable_mnt)\n\t\tfs_mnt(0);\n\n\t//****************************\n\t// apply the profile file\n\t//****************************\n\t// apply all whitelist commands ...\n\tfs_whitelist();\n\n\t// ... followed by blacklist commands\n\tfs_blacklist(); // mkdir and mkfile are processed all over again\n\n\t//****************************\n\t// nosound/no3d/notv/novideo and fix for pulseaudio 7.0\n\t//****************************\n\tif (arg_nosound) {\n\t\t// disable pulseaudio\n\t\tpulseaudio_disable();\n\n\t\t// disable /dev/snd\n\t\tfs_dev_disable_sound();\n\t}\n\telse if (!arg_noautopulse)\n\t\tpulseaudio_init();\n\n\tif (arg_no3d)\n\t\tfs_dev_disable_3d();\n\n\tif (arg_notv)\n\t\tfs_dev_disable_tv();\n\n\tif (arg_nodvd)\n\t\tfs_dev_disable_dvd();\n\n\tif (arg_nou2f)\n\t        fs_dev_disable_u2f();\n\n\tif (arg_novideo)\n\t\tfs_dev_disable_video();\n\n\t//****************************\n\t// install trace\n\t//****************************\n\tif (need_preload)\n\t\tfs_trace();\n\n\t//****************************\n\t// set dns\n\t//****************************\n\tfs_resolvconf();\n\n\t//****************************\n\t// fs post-processing\n\t//****************************\n\tfs_logger_print();\n\tfs_logger_change_owner();\n\n\t//****************************\n\t// set application environment\n\t//****************************\n\tEUID_USER();\n\tint cwd = 0;\n\tif (cfg.cwd) {\n\t\tif (chdir(cfg.cwd) == 0)\n\t\t\tcwd = 1;\n\t}\n\n\tif (!cwd) {\n\t\tif (chdir(\"/\") < 0)\n\t\t\terrExit(\"chdir\");\n\t\tif (cfg.homedir) {\n\t\t\tstruct stat s;\n\t\t\tif (stat(cfg.homedir, &s) == 0) {\n\t\t\t\t/* coverity[toctou] */\n\t\t\t\tif (chdir(cfg.homedir) < 0)\n\t\t\t\t\terrExit(\"chdir\");\n\t\t\t}\n\t\t}\n\t}\n\tif (arg_debug) {\n\t\tchar *cpath = get_current_dir_name();\n\t\tif (cpath) {\n\t\t\tprintf(\"Current directory: %s\\n\", cpath);\n\t\t\tfree(cpath);\n\t\t}\n\t}\n\n\tEUID_ROOT();\n\t// clean /tmp/.X11-unix sockets\n\tfs_x11();\n\tif (arg_x11_xorg)\n\t\tx11_xorg();\n\n\t// save original umask\n\tsave_umask();\n\n\t//****************************\n\t// set security filters\n\t//****************************\n\t// save state of nonewprivs\n\tsave_nonewprivs();\n\n\t// set capabilities\n\tset_caps();\n\n\t// save cpu affinity mask to CPU_CFG file\n\tsave_cpu();\n\n\t// save cgroup in CGROUP_CFG file\n\tsave_cgroup();\n\n\t// set seccomp\n#ifdef HAVE_SECCOMP\n\t// install protocol filter\n#ifdef SYS_socket\n\tif (cfg.protocol) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Install protocol filter: %s\\n\", cfg.protocol);\n\t\tseccomp_load(RUN_SECCOMP_PROTOCOL);\t// install filter\n\t\tprotocol_filter_save();\t// save filter in RUN_PROTOCOL_CFG\n\t}\n\telse {\n\t\tint rv = unlink(RUN_SECCOMP_PROTOCOL);\n\t\t(void) rv;\n\t}\n#endif\n\n\t// if a keep list is available, disregard the drop list\n\tif (arg_seccomp == 1) {\n\t\tif (cfg.seccomp_list_keep)\n\t\t\tseccomp_filter_keep();\n\t\telse\n\t\t\tseccomp_filter_drop();\n\n\t}\n\telse { // clean seccomp files under /run/firejail/mnt\n\t\tint rv = unlink(RUN_SECCOMP_CFG);\n\t\trv |= unlink(RUN_SECCOMP_32);\n\t\t(void) rv;\n\t}\n\n\tif (arg_memory_deny_write_execute) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Install memory write&execute filter\\n\");\n\t\tseccomp_load(RUN_SECCOMP_MDWX);\t// install filter\n\t}\n\telse {\n\t\tint rv = unlink(RUN_SECCOMP_MDWX);\n\t\t(void) rv;\n\t}\n#endif\n\n\t//****************************************\n\t// communicate progress of sandbox set up\n\t// to --join\n\t//****************************************\n\n\tFILE *rj = create_ready_for_join_file();\n\n\t//****************************************\n\t// create a new user namespace\n\t//     - too early to drop privileges\n\t//****************************************\n\tsave_nogroups();\n\tif (arg_noroot) {\n\t\tint rv = unshare(CLONE_NEWUSER);\n\t\tif (rv == -1) {\n\t\t\tfwarning(\"cannot create a new user namespace, going forward without it...\\n\");\n\t\t\targ_noroot = 0;\n\t\t}\n\t}\n\n\t// notify parent that new user namespace has been created so a proper\n \t// UID/GID map can be setup\n \tnotify_other(child_to_parent_fds[1]);\n \tclose(child_to_parent_fds[1]);\n\n \t// wait for parent to finish setting up a proper UID/GID map\n \twait_for_other(parent_to_child_fds[0]);\n \tclose(parent_to_child_fds[0]);\n\n\t// somehow, the new user namespace resets capabilities;\n\t// we need to do them again\n\tif (arg_noroot) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"noroot user namespace installed\\n\");\n\t\tset_caps();\n\t}\n\n\t//****************************************\n\t// Set NO_NEW_PRIVS if desired\n\t//****************************************\n\tif (arg_nonewprivs) {\n\t\tprctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);\n\n\t\tif (prctl(PR_GET_NO_NEW_PRIVS, 0, 0, 0, 0) != 1) {\n\t\t\tfwarning(\"cannot set NO_NEW_PRIVS, it requires a Linux kernel version 3.5 or newer.\\n\");\n\t\t\tif (force_nonewprivs) {\n\t\t\t\tfprintf(stderr, \"Error: NO_NEW_PRIVS required for this sandbox, exiting ...\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse if (arg_debug)\n\t\t\tprintf(\"NO_NEW_PRIVS set\\n\");\n\t}\n\n\t//****************************************\n\t// drop privileges\n\t//****************************************\n\tdrop_privs(arg_nogroups);\n\n\t// kill the sandbox in case the parent died\n\tprctl(PR_SET_PDEATHSIG, SIGKILL, 0, 0, 0);\n\n\t//****************************************\n\t// set cpu affinity\n\t//****************************************\n\n\tif (cfg.cpus)\n\t\tset_cpu_affinity();\n\n\t//****************************************\n\t// fork the application and monitor it\n\t//****************************************\n\tpid_t app_pid = fork();\n\tif (app_pid == -1)\n\t\terrExit(\"fork\");\n\n\tif (app_pid == 0) {\n#ifdef HAVE_APPARMOR\n\t\tif (checkcfg(CFG_APPARMOR) && arg_apparmor) {\n\t\t\terrno = 0;\n\t\t\tif (aa_change_onexec(\"firejail-default\")) {\n\t\t\t\tfwarning(\"Cannot confine the application using AppArmor.\\n\"\n\t\t\t\t\t\"Maybe firejail-default AppArmor profile is not loaded into the kernel.\\n\"\n\t\t\t\t\t\"As root, run \\\"aa-enforce firejail-default\\\" to load it.\\n\");\n\t\t\t}\n\t\t\telse if (arg_debug)\n\t\t\t\tprintf(\"AppArmor enabled\\n\");\n\t\t}\n#endif\n\t\t// set nice and rlimits\n\t\tif (arg_nice)\n\t\t\tset_nice(cfg.nice);\n\t\tset_rlimits();\n\n\t\tstart_application(0, rj);\n\t}\n\n\tfclose(rj);\n\n\tint status = monitor_application(app_pid);\t// monitor application\n\tflush_stdin();\n\n\tif (WIFEXITED(status)) {\n\t\t// if we had a proper exit, return that exit status\n\t\treturn WEXITSTATUS(status);\n\t} else {\n\t\t// something else went wrong!\n\t\treturn -1;\n\t}\n}",
        "func": "int sandbox(void* sandbox_arg) {\n\t// Get rid of unused parameter warning\n\t(void)sandbox_arg;\n\n\tpid_t child_pid = getpid();\n\tif (arg_debug)\n\t\tprintf(\"Initializing child process\\n\");\n\n \t// close each end of the unused pipes\n \tclose(parent_to_child_fds[1]);\n \tclose(child_to_parent_fds[0]);\n\n \t// wait for parent to do base setup\n \twait_for_other(parent_to_child_fds[0]);\n\n\tif (arg_debug && child_pid == 1)\n\t\tprintf(\"PID namespace installed\\n\");\n\n\n\t//****************************\n\t// set hostname\n\t//****************************\n\tif (cfg.hostname) {\n\t\tif (sethostname(cfg.hostname, strlen(cfg.hostname)) < 0)\n\t\t\terrExit(\"sethostname\");\n\t}\n\n\t//****************************\n\t// mount namespace\n\t//****************************\n\t// mount events are not forwarded between the host the sandbox\n\tif (mount(NULL, \"/\", NULL, MS_SLAVE | MS_REC, NULL) < 0) {\n\t\tchk_chroot();\n\t}\n\t// ... and mount a tmpfs on top of /run/firejail/mnt directory\n\tpreproc_mount_mnt_dir();\n\t// bind-mount firejail binaries and helper programs\n\tif (mount(LIBDIR \"/firejail\", RUN_FIREJAIL_LIB_DIR, \"none\", MS_BIND, NULL) < 0)\n\t\terrExit(\"mounting \" RUN_FIREJAIL_LIB_DIR);\n\n\t//****************************\n\t// log sandbox data\n\t//****************************\n\tif (cfg.name)\n\t\tfs_logger2(\"sandbox name:\", cfg.name);\n\tfs_logger2int(\"sandbox pid:\", (int) sandbox_pid);\n\tif (cfg.chrootdir)\n\t\tfs_logger(\"sandbox filesystem: chroot\");\n\telse if (arg_overlay)\n\t\tfs_logger(\"sandbox filesystem: overlay\");\n\telse\n\t\tfs_logger(\"sandbox filesystem: local\");\n\tfs_logger(\"install mount namespace\");\n\n\t//****************************\n\t// netfilter\n\t//****************************\n\tif (arg_netfilter && any_bridge_configured()) { // assuming by default the client filter\n\t\tnetfilter(arg_netfilter_file);\n\t}\n\tif (arg_netfilter6 && any_bridge_configured()) { // assuming by default the client filter\n\t\tnetfilter6(arg_netfilter6_file);\n\t}\n\n\t//****************************\n\t// networking\n\t//****************************\n\tint gw_cfg_failed = 0; // default gw configuration flag\n\tif (arg_nonetwork) {\n\t\tnet_if_up(\"lo\");\n\t\tif (arg_debug)\n\t\t\tprintf(\"Network namespace enabled, only loopback interface available\\n\");\n\t}\n\telse if (arg_netns) {\n\t\tnetns(arg_netns);\n\t\tif (arg_debug)\n\t\t\tprintf(\"Network namespace '%s' activated\\n\", arg_netns);\n\t}\n\telse if (any_bridge_configured() || any_interface_configured()) {\n\t\t// configure lo and eth0...eth3\n\t\tnet_if_up(\"lo\");\n\n\t\tif (mac_not_zero(cfg.bridge0.macsandbox))\n\t\t\tnet_config_mac(cfg.bridge0.devsandbox, cfg.bridge0.macsandbox);\n\t\tsandbox_if_up(&cfg.bridge0);\n\n\t\tif (mac_not_zero(cfg.bridge1.macsandbox))\n\t\t\tnet_config_mac(cfg.bridge1.devsandbox, cfg.bridge1.macsandbox);\n\t\tsandbox_if_up(&cfg.bridge1);\n\n\t\tif (mac_not_zero(cfg.bridge2.macsandbox))\n\t\t\tnet_config_mac(cfg.bridge2.devsandbox, cfg.bridge2.macsandbox);\n\t\tsandbox_if_up(&cfg.bridge2);\n\n\t\tif (mac_not_zero(cfg.bridge3.macsandbox))\n\t\t\tnet_config_mac(cfg.bridge3.devsandbox, cfg.bridge3.macsandbox);\n\t\tsandbox_if_up(&cfg.bridge3);\n\n\n\t\t// moving an interface in a namespace using --interface will reset the interface configuration;\n\t\t// we need to put the configuration back\n\t\tif (cfg.interface0.configured && cfg.interface0.ip) {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Configuring %d.%d.%d.%d address on interface %s\\n\", PRINT_IP(cfg.interface0.ip), cfg.interface0.dev);\n\t\t\tnet_config_interface(cfg.interface0.dev, cfg.interface0.ip, cfg.interface0.mask, cfg.interface0.mtu);\n\t\t}\n\t\tif (cfg.interface1.configured && cfg.interface1.ip) {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Configuring %d.%d.%d.%d address on interface %s\\n\", PRINT_IP(cfg.interface1.ip), cfg.interface1.dev);\n\t\t\tnet_config_interface(cfg.interface1.dev, cfg.interface1.ip, cfg.interface1.mask, cfg.interface1.mtu);\n\t\t}\n\t\tif (cfg.interface2.configured && cfg.interface2.ip) {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Configuring %d.%d.%d.%d address on interface %s\\n\", PRINT_IP(cfg.interface2.ip), cfg.interface2.dev);\n\t\t\tnet_config_interface(cfg.interface2.dev, cfg.interface2.ip, cfg.interface2.mask, cfg.interface2.mtu);\n\t\t}\n\t\tif (cfg.interface3.configured && cfg.interface3.ip) {\n\t\t\tif (arg_debug)\n\t\t\t\tprintf(\"Configuring %d.%d.%d.%d address on interface %s\\n\", PRINT_IP(cfg.interface3.ip), cfg.interface3.dev);\n\t\t\tnet_config_interface(cfg.interface3.dev, cfg.interface3.ip, cfg.interface3.mask, cfg.interface3.mtu);\n\t\t}\n\n\t\t// add a default route\n\t\tif (cfg.defaultgw) {\n\t\t\t// set the default route\n\t\t\tif (net_add_route(0, 0, cfg.defaultgw)) {\n\t\t\t\tfwarning(\"cannot configure default route\\n\");\n\t\t\t\tgw_cfg_failed = 1;\n\t\t\t}\n\t\t}\n\n\t\tif (arg_debug)\n\t\t\tprintf(\"Network namespace enabled\\n\");\n\t}\n\n\t// print network configuration\n\tif (!arg_quiet) {\n\t\tif (any_bridge_configured() || any_interface_configured() || cfg.defaultgw || cfg.dns1) {\n\t\t\tfmessage(\"\\n\");\n\t\t\tif (any_bridge_configured() || any_interface_configured()) {\n\t\t\t\tif (arg_scan)\n\t\t\t\t\tsbox_run(SBOX_ROOT | SBOX_CAPS_NETWORK | SBOX_SECCOMP, 3, PATH_FNET, \"printif\", \"scan\");\n\t\t\t\telse\n\t\t\t\t\tsbox_run(SBOX_ROOT | SBOX_CAPS_NETWORK | SBOX_SECCOMP, 2, PATH_FNET, \"printif\");\n\n\t\t\t}\n\t\t\tif (cfg.defaultgw != 0) {\n\t\t\t\tif (gw_cfg_failed)\n\t\t\t\t\tfmessage(\"Default gateway configuration failed\\n\");\n\t\t\t\telse\n\t\t\t\t\tfmessage(\"Default gateway %d.%d.%d.%d\\n\", PRINT_IP(cfg.defaultgw));\n\t\t\t}\n\t\t\tif (cfg.dns1 != NULL)\n\t\t\t\tfmessage(\"DNS server %s\\n\", cfg.dns1);\n\t\t\tif (cfg.dns2 != NULL)\n\t\t\t\tfmessage(\"DNS server %s\\n\", cfg.dns2);\n\t\t\tif (cfg.dns3 != NULL)\n\t\t\t\tfmessage(\"DNS server %s\\n\", cfg.dns3);\n\t\t\tif (cfg.dns4 != NULL)\n\t\t\t\tfmessage(\"DNS server %s\\n\", cfg.dns4);\n\t\t\tfmessage(\"\\n\");\n\t\t}\n\t}\n\n\t// load IBUS env variables\n\tif (arg_nonetwork || any_bridge_configured() || any_interface_configured()) {\n\t\t// do nothing - there are problems with ibus version 1.5.11\n\t}\n\telse {\n\t\tEUID_USER();\n\t\tenv_ibus_load();\n\t\tEUID_ROOT();\n\t}\n\n\t//****************************\n\t// fs pre-processing:\n\t//  - build seccomp filters\n\t//  - create an empty /etc/ld.so.preload\n\t//****************************\n#ifdef HAVE_SECCOMP\n\tif (cfg.protocol) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Build protocol filter: %s\\n\", cfg.protocol);\n\n\t\t// build the seccomp filter as a regular user\n\t\tint rv = sbox_run(SBOX_USER | SBOX_CAPS_NONE | SBOX_SECCOMP, 5,\n\t\t\tPATH_FSECCOMP, \"protocol\", \"build\", cfg.protocol, RUN_SECCOMP_PROTOCOL);\n\t\tif (rv)\n\t\t\texit(rv);\n\t}\n\tif (arg_seccomp && (cfg.seccomp_list || cfg.seccomp_list_drop || cfg.seccomp_list_keep))\n\t\targ_seccomp_postexec = 1;\n#endif\n\n\t// need ld.so.preload if tracing or seccomp with any non-default lists\n\tbool need_preload = arg_trace || arg_tracelog || arg_seccomp_postexec;\n\t// for --appimage, --chroot and --overlay* we force NO_NEW_PRIVS\n\t// and drop all capabilities\n\tif (getuid() != 0 && (arg_appimage || cfg.chrootdir || arg_overlay)) {\n\t\tenforce_filters();\n\t\tneed_preload = arg_trace || arg_tracelog;\n\t}\n\n\t// trace pre-install\n\tif (need_preload)\n\t\tfs_trace_preload();\n\n\t// store hosts file\n\tif (cfg.hosts_file)\n\t\tfs_store_hosts_file();\n\n\t//****************************\n\t// configure filesystem\n\t//****************************\n#ifdef HAVE_CHROOT\n\tif (cfg.chrootdir) {\n\t\tfs_chroot(cfg.chrootdir);\n\n\t\t//****************************\n\t\t// trace pre-install, this time inside chroot\n\t\t//****************************\n\t\tif (need_preload)\n\t\t\tfs_trace_preload();\n\t}\n\telse\n#endif\n#ifdef HAVE_OVERLAYFS\n\tif (arg_overlay)\n\t\tfs_overlayfs();\n\telse\n#endif\n\t\tfs_basic_fs();\n\n\t//****************************\n\t// private mode\n\t//****************************\n\tif (arg_private) {\n\t\tif (cfg.home_private) {\t// --private=\n\t\t\tif (cfg.chrootdir)\n\t\t\t\tfwarning(\"private=directory feature is disabled in chroot\\n\");\n\t\t\telse if (arg_overlay)\n\t\t\t\tfwarning(\"private=directory feature is disabled in overlay\\n\");\n\t\t\telse\n\t\t\t\tfs_private_homedir();\n\t\t}\n\t\telse if (cfg.home_private_keep) { // --private-home=\n\t\t\tif (cfg.chrootdir)\n\t\t\t\tfwarning(\"private-home= feature is disabled in chroot\\n\");\n\t\t\telse if (arg_overlay)\n\t\t\t\tfwarning(\"private-home= feature is disabled in overlay\\n\");\n\t\t\telse\n\t\t\t\tfs_private_home_list();\n\t\t}\n\t\telse // --private\n\t\t\tfs_private();\n\t}\n\n\tif (arg_private_dev)\n\t\tfs_private_dev();\n\n\tif (arg_private_etc) {\n\t\tif (cfg.chrootdir)\n\t\t\tfwarning(\"private-etc feature is disabled in chroot\\n\");\n\t\telse if (arg_overlay)\n\t\t\tfwarning(\"private-etc feature is disabled in overlay\\n\");\n\t\telse {\n\t\t\tfs_private_dir_list(\"/etc\", RUN_ETC_DIR, cfg.etc_private_keep);\n\t\t\t// create /etc/ld.so.preload file again\n\t\t\tif (need_preload)\n\t\t\t\tfs_trace_preload();\n\t\t}\n\t}\n\n\tif (arg_private_opt) {\n\t\tif (cfg.chrootdir)\n\t\t\tfwarning(\"private-opt feature is disabled in chroot\\n\");\n\t\telse if (arg_overlay)\n\t\t\tfwarning(\"private-opt feature is disabled in overlay\\n\");\n\t\telse {\n\t\t\tfs_private_dir_list(\"/opt\", RUN_OPT_DIR, cfg.opt_private_keep);\n\t\t}\n\t}\n\n\tif (arg_private_srv) {\n\t\tif (cfg.chrootdir)\n\t\t\tfwarning(\"private-srv feature is disabled in chroot\\n\");\n\t\telse if (arg_overlay)\n\t\t\tfwarning(\"private-srv feature is disabled in overlay\\n\");\n\t\telse {\n\t\t\tfs_private_dir_list(\"/srv\", RUN_SRV_DIR, cfg.srv_private_keep);\n\t\t}\n\t}\n\n\t// private-bin is disabled for appimages\n\tif (arg_private_bin && !arg_appimage) {\n\t\tif (cfg.chrootdir)\n\t\t\tfwarning(\"private-bin feature is disabled in chroot\\n\");\n\t\telse if (arg_overlay)\n\t\t\tfwarning(\"private-bin feature is disabled in overlay\\n\");\n\t\telse {\n\t\t\t// for --x11=xorg we need to add xauth command\n\t\t\tif (arg_x11_xorg) {\n\t\t\t\tEUID_USER();\n\t\t\t\tchar *tmp;\n\t\t\t\tif (asprintf(&tmp, \"%s,xauth\", cfg.bin_private_keep) == -1)\n\t\t\t\t\terrExit(\"asprintf\");\n\t\t\t\tcfg.bin_private_keep = tmp;\n\t\t\t\tEUID_ROOT();\n\t\t\t}\n\t\t\tfs_private_bin_list();\n\t\t}\n\t}\n\n\t// private-lib is disabled for appimages\n\tif (arg_private_lib && !arg_appimage) {\n\t\tif (cfg.chrootdir)\n\t\t\tfwarning(\"private-lib feature is disabled in chroot\\n\");\n\t\telse if (arg_overlay)\n\t\t\tfwarning(\"private-lib feature is disabled in overlay\\n\");\n\t\telse {\n\t\t\tfs_private_lib();\n\t\t}\n\t}\n\n\tif (arg_private_cache) {\n\t\tif (cfg.chrootdir)\n\t\t\tfwarning(\"private-cache feature is disabled in chroot\\n\");\n\t\telse if (arg_overlay)\n\t\t\tfwarning(\"private-cache feature is disabled in overlay\\n\");\n\t\telse\n\t\t\tfs_private_cache();\n\t}\n\n\tif (arg_private_tmp) {\n\t\t// private-tmp is implemented as a whitelist\n\t\tEUID_USER();\n\t\tfs_private_tmp();\n\t\tEUID_ROOT();\n\t}\n\n\t//****************************\n\t// Session D-BUS\n\t//****************************\n\tif (arg_nodbus)\n\t\tdbus_session_disable();\n\n\n\t//****************************\n\t// hosts and hostname\n\t//****************************\n\tif (cfg.hostname)\n\t\tfs_hostname(cfg.hostname);\n\n\tif (cfg.hosts_file)\n\t\tfs_mount_hosts_file();\n\n\t//****************************\n\t// /etc overrides from the network namespace\n\t//****************************\n\tif (arg_netns)\n\t\tnetns_mounts(arg_netns);\n\n\t//****************************\n\t// update /proc, /sys, /dev, /boot directory\n\t//****************************\n\tfs_proc_sys_dev_boot();\n\n\t//****************************\n\t// handle /mnt and /media\n\t//****************************\n\tif (checkcfg(CFG_DISABLE_MNT))\n\t\tfs_mnt(1);\n\telse if (arg_disable_mnt)\n\t\tfs_mnt(0);\n\n\t//****************************\n\t// apply the profile file\n\t//****************************\n\t// apply all whitelist commands ...\n\tfs_whitelist();\n\n\t// ... followed by blacklist commands\n\tfs_blacklist(); // mkdir and mkfile are processed all over again\n\n\t//****************************\n\t// nosound/no3d/notv/novideo and fix for pulseaudio 7.0\n\t//****************************\n\tif (arg_nosound) {\n\t\t// disable pulseaudio\n\t\tpulseaudio_disable();\n\n\t\t// disable /dev/snd\n\t\tfs_dev_disable_sound();\n\t}\n\telse if (!arg_noautopulse)\n\t\tpulseaudio_init();\n\n\tif (arg_no3d)\n\t\tfs_dev_disable_3d();\n\n\tif (arg_notv)\n\t\tfs_dev_disable_tv();\n\n\tif (arg_nodvd)\n\t\tfs_dev_disable_dvd();\n\n\tif (arg_nou2f)\n\t        fs_dev_disable_u2f();\n\n\tif (arg_novideo)\n\t\tfs_dev_disable_video();\n\n\t//****************************\n\t// install trace\n\t//****************************\n\tif (need_preload)\n\t\tfs_trace();\n\n\t//****************************\n\t// set dns\n\t//****************************\n\tfs_resolvconf();\n\n\t//****************************\n\t// fs post-processing\n\t//****************************\n\tfs_logger_print();\n\tfs_logger_change_owner();\n\n\t//****************************\n\t// set application environment\n\t//****************************\n\tEUID_USER();\n\tint cwd = 0;\n\tif (cfg.cwd) {\n\t\tif (chdir(cfg.cwd) == 0)\n\t\t\tcwd = 1;\n\t}\n\n\tif (!cwd) {\n\t\tif (chdir(\"/\") < 0)\n\t\t\terrExit(\"chdir\");\n\t\tif (cfg.homedir) {\n\t\t\tstruct stat s;\n\t\t\tif (stat(cfg.homedir, &s) == 0) {\n\t\t\t\t/* coverity[toctou] */\n\t\t\t\tif (chdir(cfg.homedir) < 0)\n\t\t\t\t\terrExit(\"chdir\");\n\t\t\t}\n\t\t}\n\t}\n\tif (arg_debug) {\n\t\tchar *cpath = get_current_dir_name();\n\t\tif (cpath) {\n\t\t\tprintf(\"Current directory: %s\\n\", cpath);\n\t\t\tfree(cpath);\n\t\t}\n\t}\n\n\tEUID_ROOT();\n\t// clean /tmp/.X11-unix sockets\n\tfs_x11();\n\tif (arg_x11_xorg)\n\t\tx11_xorg();\n\n\t// save original umask\n\tsave_umask();\n\n\t//****************************\n\t// set security filters\n\t//****************************\n\t// save state of nonewprivs\n\tsave_nonewprivs();\n\n\t// save cpu affinity mask to CPU_CFG file\n\tsave_cpu();\n\n\t// save cgroup in CGROUP_CFG file\n\tsave_cgroup();\n\n\t// set seccomp\n#ifdef HAVE_SECCOMP\n\t// install protocol filter\n#ifdef SYS_socket\n\tif (cfg.protocol) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Install protocol filter: %s\\n\", cfg.protocol);\n\t\tseccomp_load(RUN_SECCOMP_PROTOCOL);\t// install filter\n\t\tprotocol_filter_save();\t// save filter in RUN_PROTOCOL_CFG\n\t}\n\telse {\n\t\tint rv = unlink(RUN_SECCOMP_PROTOCOL);\n\t\t(void) rv;\n\t}\n#endif\n\n\t// if a keep list is available, disregard the drop list\n\tif (arg_seccomp == 1) {\n\t\tif (cfg.seccomp_list_keep)\n\t\t\tseccomp_filter_keep();\n\t\telse\n\t\t\tseccomp_filter_drop();\n\n\t}\n\telse { // clean seccomp files under /run/firejail/mnt\n\t\tint rv = unlink(RUN_SECCOMP_CFG);\n\t\trv |= unlink(RUN_SECCOMP_32);\n\t\t(void) rv;\n\t}\n\n\tif (arg_memory_deny_write_execute) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"Install memory write&execute filter\\n\");\n\t\tseccomp_load(RUN_SECCOMP_MDWX);\t// install filter\n\t}\n\telse {\n\t\tint rv = unlink(RUN_SECCOMP_MDWX);\n\t\t(void) rv;\n\t}\n\t// make seccomp filters read-only\n\tfs_rdonly(RUN_SECCOMP_DIR);\n#endif\n\n\t// set capabilities\n\tset_caps();\n\n\t//****************************************\n\t// communicate progress of sandbox set up\n\t// to --join\n\t//****************************************\n\n\tFILE *rj = create_ready_for_join_file();\n\n\t//****************************************\n\t// create a new user namespace\n\t//     - too early to drop privileges\n\t//****************************************\n\tsave_nogroups();\n\tif (arg_noroot) {\n\t\tint rv = unshare(CLONE_NEWUSER);\n\t\tif (rv == -1) {\n\t\t\tfwarning(\"cannot create a new user namespace, going forward without it...\\n\");\n\t\t\targ_noroot = 0;\n\t\t}\n\t}\n\n\t// notify parent that new user namespace has been created so a proper\n \t// UID/GID map can be setup\n \tnotify_other(child_to_parent_fds[1]);\n \tclose(child_to_parent_fds[1]);\n\n \t// wait for parent to finish setting up a proper UID/GID map\n \twait_for_other(parent_to_child_fds[0]);\n \tclose(parent_to_child_fds[0]);\n\n\t// somehow, the new user namespace resets capabilities;\n\t// we need to do them again\n\tif (arg_noroot) {\n\t\tif (arg_debug)\n\t\t\tprintf(\"noroot user namespace installed\\n\");\n\t\tset_caps();\n\t}\n\n\t//****************************************\n\t// Set NO_NEW_PRIVS if desired\n\t//****************************************\n\tif (arg_nonewprivs) {\n\t\tprctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0);\n\n\t\tif (prctl(PR_GET_NO_NEW_PRIVS, 0, 0, 0, 0) != 1) {\n\t\t\tfwarning(\"cannot set NO_NEW_PRIVS, it requires a Linux kernel version 3.5 or newer.\\n\");\n\t\t\tif (force_nonewprivs) {\n\t\t\t\tfprintf(stderr, \"Error: NO_NEW_PRIVS required for this sandbox, exiting ...\\n\");\n\t\t\t\texit(1);\n\t\t\t}\n\t\t}\n\t\telse if (arg_debug)\n\t\t\tprintf(\"NO_NEW_PRIVS set\\n\");\n\t}\n\n\t//****************************************\n\t// drop privileges\n\t//****************************************\n\tdrop_privs(arg_nogroups);\n\n\t// kill the sandbox in case the parent died\n\tprctl(PR_SET_PDEATHSIG, SIGKILL, 0, 0, 0);\n\n\t//****************************************\n\t// set cpu affinity\n\t//****************************************\n\n\tif (cfg.cpus)\n\t\tset_cpu_affinity();\n\n\t//****************************************\n\t// fork the application and monitor it\n\t//****************************************\n\tpid_t app_pid = fork();\n\tif (app_pid == -1)\n\t\terrExit(\"fork\");\n\n\tif (app_pid == 0) {\n#ifdef HAVE_APPARMOR\n\t\tif (checkcfg(CFG_APPARMOR) && arg_apparmor) {\n\t\t\terrno = 0;\n\t\t\tif (aa_change_onexec(\"firejail-default\")) {\n\t\t\t\tfwarning(\"Cannot confine the application using AppArmor.\\n\"\n\t\t\t\t\t\"Maybe firejail-default AppArmor profile is not loaded into the kernel.\\n\"\n\t\t\t\t\t\"As root, run \\\"aa-enforce firejail-default\\\" to load it.\\n\");\n\t\t\t}\n\t\t\telse if (arg_debug)\n\t\t\t\tprintf(\"AppArmor enabled\\n\");\n\t\t}\n#endif\n\t\t// set nice and rlimits\n\t\tif (arg_nice)\n\t\t\tset_nice(cfg.nice);\n\t\tset_rlimits();\n\n\t\tstart_application(0, rj);\n\t}\n\n\tfclose(rj);\n\n\tint status = monitor_application(app_pid);\t// monitor application\n\tflush_stdin();\n\n\tif (WIFEXITED(status)) {\n\t\t// if we had a proper exit, return that exit status\n\t\treturn WEXITSTATUS(status);\n\t} else {\n\t\t// something else went wrong!\n\t\treturn -1;\n\t}\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -472,9 +472,6 @@\n \t// save state of nonewprivs\n \tsave_nonewprivs();\n \n-\t// set capabilities\n-\tset_caps();\n-\n \t// save cpu affinity mask to CPU_CFG file\n \tsave_cpu();\n \n@@ -520,7 +517,12 @@\n \t\tint rv = unlink(RUN_SECCOMP_MDWX);\n \t\t(void) rv;\n \t}\n+\t// make seccomp filters read-only\n+\tfs_rdonly(RUN_SECCOMP_DIR);\n #endif\n+\n+\t// set capabilities\n+\tset_caps();\n \n \t//****************************************\n \t// communicate progress of sandbox set up",
        "diff_line_info": {
            "deleted_lines": [
                "\t// set capabilities",
                "\tset_caps();",
                ""
            ],
            "added_lines": [
                "\t// make seccomp filters read-only",
                "\tfs_rdonly(RUN_SECCOMP_DIR);",
                "",
                "\t// set capabilities",
                "\tset_caps();"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-13012",
        "func_name": "GNOME/glib/g_keyfile_settings_backend_keyfile_write",
        "description": "The keyfile settings backend in GNOME GLib (aka glib2.0) before 2.60.0 creates directories using g_file_make_directory_with_parents (kfsb->dir, NULL, NULL) and files using g_file_replace_contents (kfsb->file, contents, length, NULL, FALSE, G_FILE_CREATE_REPLACE_DESTINATION, NULL, NULL, NULL). Consequently, it does not properly restrict directory (and file) permissions. Instead, for directories, 0777 permissions are used; for files, default file permissions are used. This is similar to CVE-2019-12450.",
        "git_url": "https://github.com/GNOME/glib/commit/5e4da714f00f6bfb2ccd6d73d61329c6f3a08429",
        "commit_title": "keyfile settings: Use tighter permissions",
        "commit_text": " When creating directories, create them with 700 permissions, instead of 777.  Closes: #1658",
        "func_before": "static void\ng_keyfile_settings_backend_keyfile_write (GKeyfileSettingsBackend *kfsb)\n{\n  gchar *contents;\n  gsize length;\n\n  contents = g_key_file_to_data (kfsb->keyfile, &length, NULL);\n  g_file_replace_contents (kfsb->file, contents, length, NULL, FALSE,\n                           G_FILE_CREATE_REPLACE_DESTINATION,\n                           NULL, NULL, NULL);\n\n  compute_checksum (kfsb->digest, contents, length);\n  g_free (contents);\n}",
        "func": "static void\ng_keyfile_settings_backend_keyfile_write (GKeyfileSettingsBackend *kfsb)\n{\n  gchar *contents;\n  gsize length;\n\n  contents = g_key_file_to_data (kfsb->keyfile, &length, NULL);\n  g_file_replace_contents (kfsb->file, contents, length, NULL, FALSE,\n                           G_FILE_CREATE_REPLACE_DESTINATION |\n                           G_FILE_CREATE_PRIVATE,\n                           NULL, NULL, NULL);\n\n  compute_checksum (kfsb->digest, contents, length);\n  g_free (contents);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,7 +6,8 @@\n \n   contents = g_key_file_to_data (kfsb->keyfile, &length, NULL);\n   g_file_replace_contents (kfsb->file, contents, length, NULL, FALSE,\n-                           G_FILE_CREATE_REPLACE_DESTINATION,\n+                           G_FILE_CREATE_REPLACE_DESTINATION |\n+                           G_FILE_CREATE_PRIVATE,\n                            NULL, NULL, NULL);\n \n   compute_checksum (kfsb->digest, contents, length);",
        "diff_line_info": {
            "deleted_lines": [
                "                           G_FILE_CREATE_REPLACE_DESTINATION,"
            ],
            "added_lines": [
                "                           G_FILE_CREATE_REPLACE_DESTINATION |",
                "                           G_FILE_CREATE_PRIVATE,"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-13012",
        "func_name": "GNOME/glib/g_keyfile_settings_backend_constructed",
        "description": "The keyfile settings backend in GNOME GLib (aka glib2.0) before 2.60.0 creates directories using g_file_make_directory_with_parents (kfsb->dir, NULL, NULL) and files using g_file_replace_contents (kfsb->file, contents, length, NULL, FALSE, G_FILE_CREATE_REPLACE_DESTINATION, NULL, NULL, NULL). Consequently, it does not properly restrict directory (and file) permissions. Instead, for directories, 0777 permissions are used; for files, default file permissions are used. This is similar to CVE-2019-12450.",
        "git_url": "https://github.com/GNOME/glib/commit/5e4da714f00f6bfb2ccd6d73d61329c6f3a08429",
        "commit_title": "keyfile settings: Use tighter permissions",
        "commit_text": " When creating directories, create them with 700 permissions, instead of 777.  Closes: #1658",
        "func_before": "static void\ng_keyfile_settings_backend_constructed (GObject *object)\n{\n  GKeyfileSettingsBackend *kfsb = G_KEYFILE_SETTINGS_BACKEND (object);\n\n  if (kfsb->file == NULL)\n    {\n      char *filename = g_build_filename (g_get_user_config_dir (),\n                                         \"glib-2.0\", \"settings\", \"keyfile\",\n                                         NULL);\n      kfsb->file = g_file_new_for_path (filename);\n      g_free (filename);\n    }\n\n  if (kfsb->prefix == NULL)\n    {\n      kfsb->prefix = g_strdup (\"/\");\n      kfsb->prefix_len = 1;\n    }\n  \n  kfsb->keyfile = g_key_file_new ();\n  kfsb->permission = g_simple_permission_new (TRUE);\n\n  kfsb->dir = g_file_get_parent (kfsb->file);\n  g_file_make_directory_with_parents (kfsb->dir, NULL, NULL);\n\n  kfsb->file_monitor = g_file_monitor (kfsb->file, G_FILE_MONITOR_NONE, NULL, NULL);\n  kfsb->dir_monitor = g_file_monitor (kfsb->dir, G_FILE_MONITOR_NONE, NULL, NULL);\n\n  compute_checksum (kfsb->digest, NULL, 0);\n\n  g_signal_connect (kfsb->file_monitor, \"changed\",\n                    G_CALLBACK (file_changed), kfsb);\n  g_signal_connect (kfsb->dir_monitor, \"changed\",\n                    G_CALLBACK (dir_changed), kfsb);\n\n  g_keyfile_settings_backend_keyfile_writable (kfsb);\n  g_keyfile_settings_backend_keyfile_reload (kfsb);\n\n  load_system_settings (kfsb);\n}",
        "func": "static void\ng_keyfile_settings_backend_constructed (GObject *object)\n{\n  GKeyfileSettingsBackend *kfsb = G_KEYFILE_SETTINGS_BACKEND (object);\n\n  if (kfsb->file == NULL)\n    {\n      char *filename = g_build_filename (g_get_user_config_dir (),\n                                         \"glib-2.0\", \"settings\", \"keyfile\",\n                                         NULL);\n      kfsb->file = g_file_new_for_path (filename);\n      g_free (filename);\n    }\n\n  if (kfsb->prefix == NULL)\n    {\n      kfsb->prefix = g_strdup (\"/\");\n      kfsb->prefix_len = 1;\n    }\n  \n  kfsb->keyfile = g_key_file_new ();\n  kfsb->permission = g_simple_permission_new (TRUE);\n\n  kfsb->dir = g_file_get_parent (kfsb->file);\n  g_mkdir_with_parents (g_file_peek_path (kfsb->dir), 0700);\n\n  kfsb->file_monitor = g_file_monitor (kfsb->file, G_FILE_MONITOR_NONE, NULL, NULL);\n  kfsb->dir_monitor = g_file_monitor (kfsb->dir, G_FILE_MONITOR_NONE, NULL, NULL);\n\n  compute_checksum (kfsb->digest, NULL, 0);\n\n  g_signal_connect (kfsb->file_monitor, \"changed\",\n                    G_CALLBACK (file_changed), kfsb);\n  g_signal_connect (kfsb->dir_monitor, \"changed\",\n                    G_CALLBACK (dir_changed), kfsb);\n\n  g_keyfile_settings_backend_keyfile_writable (kfsb);\n  g_keyfile_settings_backend_keyfile_reload (kfsb);\n\n  load_system_settings (kfsb);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -22,7 +22,7 @@\n   kfsb->permission = g_simple_permission_new (TRUE);\n \n   kfsb->dir = g_file_get_parent (kfsb->file);\n-  g_file_make_directory_with_parents (kfsb->dir, NULL, NULL);\n+  g_mkdir_with_parents (g_file_peek_path (kfsb->dir), 0700);\n \n   kfsb->file_monitor = g_file_monitor (kfsb->file, G_FILE_MONITOR_NONE, NULL, NULL);\n   kfsb->dir_monitor = g_file_monitor (kfsb->dir, G_FILE_MONITOR_NONE, NULL, NULL);",
        "diff_line_info": {
            "deleted_lines": [
                "  g_file_make_directory_with_parents (kfsb->dir, NULL, NULL);"
            ],
            "added_lines": [
                "  g_mkdir_with_parents (g_file_peek_path (kfsb->dir), 0700);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-13012",
        "func_name": "GNOME/glib/g_keyfile_settings_backend_check_one",
        "description": "The keyfile settings backend in GNOME GLib (aka glib2.0) before 2.60.0 creates directories using g_file_make_directory_with_parents (kfsb->dir, NULL, NULL) and files using g_file_replace_contents (kfsb->file, contents, length, NULL, FALSE, G_FILE_CREATE_REPLACE_DESTINATION, NULL, NULL, NULL). Consequently, it does not properly restrict directory (and file) permissions. Instead, for directories, 0777 permissions are used; for files, default file permissions are used. This is similar to CVE-2019-12450.",
        "git_url": "https://github.com/GNOME/glib/commit/26c8b29ee12f20cf63866b87b9a3c41fab9153c5",
        "commit_title": "settings: Make the keyfile backend parameterless",
        "commit_text": " Make it possible to instantiate a keyfile settings backend without specifying parameters, by turning the arguments to the new() function into construct-only properties. If no filename is specified, default to $XDG_CONFIG_HOME/glib-2.0/settings/keyfile",
        "func_before": "static gboolean\ng_keyfile_settings_backend_check_one (gpointer key,\n                                      gpointer value,\n                                      gpointer user_data)\n{\n  WriteManyData *data = user_data;\n\n  return data->failed = !path_is_valid (data->kfsb, key);\n}",
        "func": "static gboolean\ng_keyfile_settings_backend_check_one (gpointer key,\n                                      gpointer value,\n                                      gpointer user_data)\n{\n  WriteManyData *data = user_data;\n\n  return data->failed = g_hash_table_contains (data->kfsb->system_locks, key) ||\n                        !path_is_valid (data->kfsb, key);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,5 +5,6 @@\n {\n   WriteManyData *data = user_data;\n \n-  return data->failed = !path_is_valid (data->kfsb, key);\n+  return data->failed = g_hash_table_contains (data->kfsb->system_locks, key) ||\n+                        !path_is_valid (data->kfsb, key);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "  return data->failed = !path_is_valid (data->kfsb, key);"
            ],
            "added_lines": [
                "  return data->failed = g_hash_table_contains (data->kfsb->system_locks, key) ||",
                "                        !path_is_valid (data->kfsb, key);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-13012",
        "func_name": "GNOME/glib/g_keyfile_settings_backend_new",
        "description": "The keyfile settings backend in GNOME GLib (aka glib2.0) before 2.60.0 creates directories using g_file_make_directory_with_parents (kfsb->dir, NULL, NULL) and files using g_file_replace_contents (kfsb->file, contents, length, NULL, FALSE, G_FILE_CREATE_REPLACE_DESTINATION, NULL, NULL, NULL). Consequently, it does not properly restrict directory (and file) permissions. Instead, for directories, 0777 permissions are used; for files, default file permissions are used. This is similar to CVE-2019-12450.",
        "git_url": "https://github.com/GNOME/glib/commit/26c8b29ee12f20cf63866b87b9a3c41fab9153c5",
        "commit_title": "settings: Make the keyfile backend parameterless",
        "commit_text": " Make it possible to instantiate a keyfile settings backend without specifying parameters, by turning the arguments to the new() function into construct-only properties. If no filename is specified, default to $XDG_CONFIG_HOME/glib-2.0/settings/keyfile",
        "func_before": "GSettingsBackend *\ng_keyfile_settings_backend_new (const gchar *filename,\n                                const gchar *root_path,\n                                const gchar *root_group)\n{\n  GKeyfileSettingsBackend *kfsb;\n\n  g_return_val_if_fail (filename != NULL, NULL);\n  g_return_val_if_fail (root_path != NULL, NULL);\n  g_return_val_if_fail (g_str_has_prefix (root_path, \"/\"), NULL);\n  g_return_val_if_fail (g_str_has_suffix (root_path, \"/\"), NULL);\n  g_return_val_if_fail (strstr (root_path, \"//\") == NULL, NULL);\n\n  kfsb = g_object_new (G_TYPE_KEYFILE_SETTINGS_BACKEND, NULL);\n  kfsb->keyfile = g_key_file_new ();\n  kfsb->permission = g_simple_permission_new (TRUE);\n\n  kfsb->file = g_file_new_for_path (filename);\n  kfsb->dir = g_file_get_parent (kfsb->file);\n  g_file_make_directory_with_parents (kfsb->dir, NULL, NULL);\n\n  kfsb->file_monitor = g_file_monitor (kfsb->file, 0, NULL, NULL);\n  kfsb->dir_monitor = g_file_monitor (kfsb->dir, 0, NULL, NULL);\n\n  kfsb->prefix_len = strlen (root_path);\n  kfsb->prefix = g_strdup (root_path);\n\n  if (root_group)\n    {\n      kfsb->root_group_len = strlen (root_group);\n      kfsb->root_group = g_strdup (root_group);\n    }\n\n  compute_checksum (kfsb->digest, NULL, 0);\n\n  g_signal_connect (kfsb->file_monitor, \"changed\",\n                    G_CALLBACK (file_changed), kfsb);\n  g_signal_connect (kfsb->dir_monitor, \"changed\",\n                    G_CALLBACK (dir_changed), kfsb);\n\n  g_keyfile_settings_backend_keyfile_writable (kfsb);\n  g_keyfile_settings_backend_keyfile_reload (kfsb);\n\n  return G_SETTINGS_BACKEND (kfsb);\n}",
        "func": "GSettingsBackend *\ng_keyfile_settings_backend_new (const gchar *filename,\n                                const gchar *root_path,\n                                const gchar *root_group)\n{\n  g_return_val_if_fail (filename != NULL, NULL);\n  g_return_val_if_fail (root_path != NULL, NULL);\n  g_return_val_if_fail (g_str_has_prefix (root_path, \"/\"), NULL);\n  g_return_val_if_fail (g_str_has_suffix (root_path, \"/\"), NULL);\n  g_return_val_if_fail (strstr (root_path, \"//\") == NULL, NULL);\n\n  return G_SETTINGS_BACKEND (g_object_new (G_TYPE_KEYFILE_SETTINGS_BACKEND,\n                                           \"filename\", filename,\n                                           \"root-path\", root_path,\n                                           \"root-group\", root_group,\n                                           NULL));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,43 +3,15 @@\n                                 const gchar *root_path,\n                                 const gchar *root_group)\n {\n-  GKeyfileSettingsBackend *kfsb;\n-\n   g_return_val_if_fail (filename != NULL, NULL);\n   g_return_val_if_fail (root_path != NULL, NULL);\n   g_return_val_if_fail (g_str_has_prefix (root_path, \"/\"), NULL);\n   g_return_val_if_fail (g_str_has_suffix (root_path, \"/\"), NULL);\n   g_return_val_if_fail (strstr (root_path, \"//\") == NULL, NULL);\n \n-  kfsb = g_object_new (G_TYPE_KEYFILE_SETTINGS_BACKEND, NULL);\n-  kfsb->keyfile = g_key_file_new ();\n-  kfsb->permission = g_simple_permission_new (TRUE);\n-\n-  kfsb->file = g_file_new_for_path (filename);\n-  kfsb->dir = g_file_get_parent (kfsb->file);\n-  g_file_make_directory_with_parents (kfsb->dir, NULL, NULL);\n-\n-  kfsb->file_monitor = g_file_monitor (kfsb->file, 0, NULL, NULL);\n-  kfsb->dir_monitor = g_file_monitor (kfsb->dir, 0, NULL, NULL);\n-\n-  kfsb->prefix_len = strlen (root_path);\n-  kfsb->prefix = g_strdup (root_path);\n-\n-  if (root_group)\n-    {\n-      kfsb->root_group_len = strlen (root_group);\n-      kfsb->root_group = g_strdup (root_group);\n-    }\n-\n-  compute_checksum (kfsb->digest, NULL, 0);\n-\n-  g_signal_connect (kfsb->file_monitor, \"changed\",\n-                    G_CALLBACK (file_changed), kfsb);\n-  g_signal_connect (kfsb->dir_monitor, \"changed\",\n-                    G_CALLBACK (dir_changed), kfsb);\n-\n-  g_keyfile_settings_backend_keyfile_writable (kfsb);\n-  g_keyfile_settings_backend_keyfile_reload (kfsb);\n-\n-  return G_SETTINGS_BACKEND (kfsb);\n+  return G_SETTINGS_BACKEND (g_object_new (G_TYPE_KEYFILE_SETTINGS_BACKEND,\n+                                           \"filename\", filename,\n+                                           \"root-path\", root_path,\n+                                           \"root-group\", root_group,\n+                                           NULL));\n }",
        "diff_line_info": {
            "deleted_lines": [
                "  GKeyfileSettingsBackend *kfsb;",
                "",
                "  kfsb = g_object_new (G_TYPE_KEYFILE_SETTINGS_BACKEND, NULL);",
                "  kfsb->keyfile = g_key_file_new ();",
                "  kfsb->permission = g_simple_permission_new (TRUE);",
                "",
                "  kfsb->file = g_file_new_for_path (filename);",
                "  kfsb->dir = g_file_get_parent (kfsb->file);",
                "  g_file_make_directory_with_parents (kfsb->dir, NULL, NULL);",
                "",
                "  kfsb->file_monitor = g_file_monitor (kfsb->file, 0, NULL, NULL);",
                "  kfsb->dir_monitor = g_file_monitor (kfsb->dir, 0, NULL, NULL);",
                "",
                "  kfsb->prefix_len = strlen (root_path);",
                "  kfsb->prefix = g_strdup (root_path);",
                "",
                "  if (root_group)",
                "    {",
                "      kfsb->root_group_len = strlen (root_group);",
                "      kfsb->root_group = g_strdup (root_group);",
                "    }",
                "",
                "  compute_checksum (kfsb->digest, NULL, 0);",
                "",
                "  g_signal_connect (kfsb->file_monitor, \"changed\",",
                "                    G_CALLBACK (file_changed), kfsb);",
                "  g_signal_connect (kfsb->dir_monitor, \"changed\",",
                "                    G_CALLBACK (dir_changed), kfsb);",
                "",
                "  g_keyfile_settings_backend_keyfile_writable (kfsb);",
                "  g_keyfile_settings_backend_keyfile_reload (kfsb);",
                "",
                "  return G_SETTINGS_BACKEND (kfsb);"
            ],
            "added_lines": [
                "  return G_SETTINGS_BACKEND (g_object_new (G_TYPE_KEYFILE_SETTINGS_BACKEND,",
                "                                           \"filename\", filename,",
                "                                           \"root-path\", root_path,",
                "                                           \"root-group\", root_group,",
                "                                           NULL));"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-13012",
        "func_name": "GNOME/glib/g_keyfile_settings_backend_class_init",
        "description": "The keyfile settings backend in GNOME GLib (aka glib2.0) before 2.60.0 creates directories using g_file_make_directory_with_parents (kfsb->dir, NULL, NULL) and files using g_file_replace_contents (kfsb->file, contents, length, NULL, FALSE, G_FILE_CREATE_REPLACE_DESTINATION, NULL, NULL, NULL). Consequently, it does not properly restrict directory (and file) permissions. Instead, for directories, 0777 permissions are used; for files, default file permissions are used. This is similar to CVE-2019-12450.",
        "git_url": "https://github.com/GNOME/glib/commit/26c8b29ee12f20cf63866b87b9a3c41fab9153c5",
        "commit_title": "settings: Make the keyfile backend parameterless",
        "commit_text": " Make it possible to instantiate a keyfile settings backend without specifying parameters, by turning the arguments to the new() function into construct-only properties. If no filename is specified, default to $XDG_CONFIG_HOME/glib-2.0/settings/keyfile",
        "func_before": "static void\ng_keyfile_settings_backend_class_init (GKeyfileSettingsBackendClass *class)\n{\n  GObjectClass *object_class = G_OBJECT_CLASS (class);\n\n  object_class->finalize = g_keyfile_settings_backend_finalize;\n\n  class->read = g_keyfile_settings_backend_read;\n  class->write = g_keyfile_settings_backend_write;\n  class->write_tree = g_keyfile_settings_backend_write_tree;\n  class->reset = g_keyfile_settings_backend_reset;\n  class->get_writable = g_keyfile_settings_backend_get_writable;\n  class->get_permission = g_keyfile_settings_backend_get_permission;\n  /* No need to implement subscribed/unsubscribe: the only point would be to\n   * stop monitoring the file when there's no GSettings anymore, which is no\n   * big win.\n   */\n}",
        "func": "static void\ng_keyfile_settings_backend_class_init (GKeyfileSettingsBackendClass *class)\n{\n  GObjectClass *object_class = G_OBJECT_CLASS (class);\n\n  object_class->finalize = g_keyfile_settings_backend_finalize;\n  object_class->constructed = g_keyfile_settings_backend_constructed;\n  object_class->get_property = g_keyfile_settings_backend_get_property;\n  object_class->set_property = g_keyfile_settings_backend_set_property;\n\n  class->read = g_keyfile_settings_backend_read;\n  class->write = g_keyfile_settings_backend_write;\n  class->write_tree = g_keyfile_settings_backend_write_tree;\n  class->reset = g_keyfile_settings_backend_reset;\n  class->get_writable = g_keyfile_settings_backend_get_writable;\n  class->get_permission = g_keyfile_settings_backend_get_permission;\n  /* No need to implement subscribed/unsubscribe: the only point would be to\n   * stop monitoring the file when there's no GSettings anymore, which is no\n   * big win.\n   */\n\n  /**\n   * GKeyfileSettingsBackend:filename:\n   *\n   * The location where the settings are stored on disk.\n   *\n   * Defaults to `$XDG_CONFIG_HOME/glib-2.0/settings/keyfile`.\n   */\n  g_object_class_install_property (object_class,\n                                   PROP_FILENAME,\n                                   g_param_spec_string (\"filename\",\n                                                        P_(\"Filename\"),\n                                                        P_(\"The filename\"),\n                                                        NULL,\n                                                        G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY |\n                                                        G_PARAM_STATIC_STRINGS));\n\n  /**\n   * GKeyfileSettingsBackend:root-path:\n   *\n   * All settings read to or written from the backend must fall under the\n   * path given in @root_path (which must start and end with a slash and\n   * not contain two consecutive slashes).  @root_path may be \"/\".\n   * \n   * Defaults to \"/\".\n   */\n  g_object_class_install_property (object_class,\n                                   PROP_ROOT_PATH,\n                                   g_param_spec_string (\"root-path\",\n                                                        P_(\"Root path\"),\n                                                        P_(\"The root path\"),\n                                                        NULL,\n                                                        G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY |\n                                                        G_PARAM_STATIC_STRINGS));\n\n  /**\n   * GKeyfileSettingsBackend:root-group:\n   *\n   * If @root_group is non-%NULL then it specifies the name of the keyfile\n   * group used for keys that are written directly below the root path.\n   *\n   * Defaults to NULL.\n   */\n  g_object_class_install_property (object_class,\n                                   PROP_ROOT_GROUP,\n                                   g_param_spec_string (\"root-group\",\n                                                        P_(\"Root group\"),\n                                                        P_(\"The root group\"),\n                                                        NULL,\n                                                        G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY |\n                                                        G_PARAM_STATIC_STRINGS));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,6 +4,9 @@\n   GObjectClass *object_class = G_OBJECT_CLASS (class);\n \n   object_class->finalize = g_keyfile_settings_backend_finalize;\n+  object_class->constructed = g_keyfile_settings_backend_constructed;\n+  object_class->get_property = g_keyfile_settings_backend_get_property;\n+  object_class->set_property = g_keyfile_settings_backend_set_property;\n \n   class->read = g_keyfile_settings_backend_read;\n   class->write = g_keyfile_settings_backend_write;\n@@ -15,4 +18,55 @@\n    * stop monitoring the file when there's no GSettings anymore, which is no\n    * big win.\n    */\n+\n+  /**\n+   * GKeyfileSettingsBackend:filename:\n+   *\n+   * The location where the settings are stored on disk.\n+   *\n+   * Defaults to `$XDG_CONFIG_HOME/glib-2.0/settings/keyfile`.\n+   */\n+  g_object_class_install_property (object_class,\n+                                   PROP_FILENAME,\n+                                   g_param_spec_string (\"filename\",\n+                                                        P_(\"Filename\"),\n+                                                        P_(\"The filename\"),\n+                                                        NULL,\n+                                                        G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY |\n+                                                        G_PARAM_STATIC_STRINGS));\n+\n+  /**\n+   * GKeyfileSettingsBackend:root-path:\n+   *\n+   * All settings read to or written from the backend must fall under the\n+   * path given in @root_path (which must start and end with a slash and\n+   * not contain two consecutive slashes).  @root_path may be \"/\".\n+   * \n+   * Defaults to \"/\".\n+   */\n+  g_object_class_install_property (object_class,\n+                                   PROP_ROOT_PATH,\n+                                   g_param_spec_string (\"root-path\",\n+                                                        P_(\"Root path\"),\n+                                                        P_(\"The root path\"),\n+                                                        NULL,\n+                                                        G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY |\n+                                                        G_PARAM_STATIC_STRINGS));\n+\n+  /**\n+   * GKeyfileSettingsBackend:root-group:\n+   *\n+   * If @root_group is non-%NULL then it specifies the name of the keyfile\n+   * group used for keys that are written directly below the root path.\n+   *\n+   * Defaults to NULL.\n+   */\n+  g_object_class_install_property (object_class,\n+                                   PROP_ROOT_GROUP,\n+                                   g_param_spec_string (\"root-group\",\n+                                                        P_(\"Root group\"),\n+                                                        P_(\"The root group\"),\n+                                                        NULL,\n+                                                        G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY |\n+                                                        G_PARAM_STATIC_STRINGS));\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "  object_class->constructed = g_keyfile_settings_backend_constructed;",
                "  object_class->get_property = g_keyfile_settings_backend_get_property;",
                "  object_class->set_property = g_keyfile_settings_backend_set_property;",
                "",
                "  /**",
                "   * GKeyfileSettingsBackend:filename:",
                "   *",
                "   * The location where the settings are stored on disk.",
                "   *",
                "   * Defaults to `$XDG_CONFIG_HOME/glib-2.0/settings/keyfile`.",
                "   */",
                "  g_object_class_install_property (object_class,",
                "                                   PROP_FILENAME,",
                "                                   g_param_spec_string (\"filename\",",
                "                                                        P_(\"Filename\"),",
                "                                                        P_(\"The filename\"),",
                "                                                        NULL,",
                "                                                        G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY |",
                "                                                        G_PARAM_STATIC_STRINGS));",
                "",
                "  /**",
                "   * GKeyfileSettingsBackend:root-path:",
                "   *",
                "   * All settings read to or written from the backend must fall under the",
                "   * path given in @root_path (which must start and end with a slash and",
                "   * not contain two consecutive slashes).  @root_path may be \"/\".",
                "   * ",
                "   * Defaults to \"/\".",
                "   */",
                "  g_object_class_install_property (object_class,",
                "                                   PROP_ROOT_PATH,",
                "                                   g_param_spec_string (\"root-path\",",
                "                                                        P_(\"Root path\"),",
                "                                                        P_(\"The root path\"),",
                "                                                        NULL,",
                "                                                        G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY |",
                "                                                        G_PARAM_STATIC_STRINGS));",
                "",
                "  /**",
                "   * GKeyfileSettingsBackend:root-group:",
                "   *",
                "   * If @root_group is non-%NULL then it specifies the name of the keyfile",
                "   * group used for keys that are written directly below the root path.",
                "   *",
                "   * Defaults to NULL.",
                "   */",
                "  g_object_class_install_property (object_class,",
                "                                   PROP_ROOT_GROUP,",
                "                                   g_param_spec_string (\"root-group\",",
                "                                                        P_(\"Root group\"),",
                "                                                        P_(\"The root group\"),",
                "                                                        NULL,",
                "                                                        G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY |",
                "                                                        G_PARAM_STATIC_STRINGS));"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-13012",
        "func_name": "GNOME/glib/g_keyfile_settings_backend_get_property",
        "description": "The keyfile settings backend in GNOME GLib (aka glib2.0) before 2.60.0 creates directories using g_file_make_directory_with_parents (kfsb->dir, NULL, NULL) and files using g_file_replace_contents (kfsb->file, contents, length, NULL, FALSE, G_FILE_CREATE_REPLACE_DESTINATION, NULL, NULL, NULL). Consequently, it does not properly restrict directory (and file) permissions. Instead, for directories, 0777 permissions are used; for files, default file permissions are used. This is similar to CVE-2019-12450.",
        "git_url": "https://github.com/GNOME/glib/commit/c63e3a4ada9852138042cb69441644bfe06ac430",
        "commit_title": "settings: Add support for defaults to keyfile backend",
        "commit_text": " Stacked databases and locks are dconf features that allow management software like Fleet Commander to set system-wide defaults and overrides centrally for applications.  This patch adds minimal support for the same to the keyfile backend. We look for a keyfile named 'defaults' and a lock-list named 'locks'.  Suitable files can be produced from a dconf database with dconf dump and dconf list-locks, respectively.  The default location for these files is /etc/glib-2.0/settings/. For test purposes, this can be overwritten with the GSETTINGS_DEFAULTS_DIR environment variable.  Writes always go to the per-user keyfile.",
        "func_before": "static void\ng_keyfile_settings_backend_get_property (GObject    *object,\n                                         guint       prop_id,\n                                         GValue     *value,\n                                         GParamSpec *pspec)\n{\n  GKeyfileSettingsBackend *kfsb = G_KEYFILE_SETTINGS_BACKEND (object);\n\n  switch (prop_id)\n    {\n    case PROP_FILENAME:\n      g_value_set_string (value, g_file_peek_path (kfsb->file));\n      break;\n\n    case PROP_ROOT_PATH:\n      g_value_set_string (value, kfsb->prefix);\n      break;\n\n    case PROP_ROOT_GROUP:\n      g_value_set_string (value, kfsb->root_group);\n      break;\n\n    default:\n      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);\n      break;\n    }\n}",
        "func": "static void\ng_keyfile_settings_backend_get_property (GObject    *object,\n                                         guint       prop_id,\n                                         GValue     *value,\n                                         GParamSpec *pspec)\n{\n  GKeyfileSettingsBackend *kfsb = G_KEYFILE_SETTINGS_BACKEND (object);\n\n  switch ((GKeyfileSettingsBackendProperty)prop_id)\n    {\n    case PROP_FILENAME:\n      g_value_set_string (value, g_file_peek_path (kfsb->file));\n      break;\n\n    case PROP_ROOT_PATH:\n      g_value_set_string (value, kfsb->prefix);\n      break;\n\n    case PROP_ROOT_GROUP:\n      g_value_set_string (value, kfsb->root_group);\n      break;\n\n    case PROP_DEFAULTS_DIR:\n      g_value_set_string (value, kfsb->defaults_dir);\n      break;\n\n    default:\n      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);\n      break;\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,7 +6,7 @@\n {\n   GKeyfileSettingsBackend *kfsb = G_KEYFILE_SETTINGS_BACKEND (object);\n \n-  switch (prop_id)\n+  switch ((GKeyfileSettingsBackendProperty)prop_id)\n     {\n     case PROP_FILENAME:\n       g_value_set_string (value, g_file_peek_path (kfsb->file));\n@@ -20,6 +20,10 @@\n       g_value_set_string (value, kfsb->root_group);\n       break;\n \n+    case PROP_DEFAULTS_DIR:\n+      g_value_set_string (value, kfsb->defaults_dir);\n+      break;\n+\n     default:\n       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);\n       break;",
        "diff_line_info": {
            "deleted_lines": [
                "  switch (prop_id)"
            ],
            "added_lines": [
                "  switch ((GKeyfileSettingsBackendProperty)prop_id)",
                "    case PROP_DEFAULTS_DIR:",
                "      g_value_set_string (value, kfsb->defaults_dir);",
                "      break;",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2019-13012",
        "func_name": "GNOME/glib/g_keyfile_settings_backend_finalize",
        "description": "The keyfile settings backend in GNOME GLib (aka glib2.0) before 2.60.0 creates directories using g_file_make_directory_with_parents (kfsb->dir, NULL, NULL) and files using g_file_replace_contents (kfsb->file, contents, length, NULL, FALSE, G_FILE_CREATE_REPLACE_DESTINATION, NULL, NULL, NULL). Consequently, it does not properly restrict directory (and file) permissions. Instead, for directories, 0777 permissions are used; for files, default file permissions are used. This is similar to CVE-2019-12450.",
        "git_url": "https://github.com/GNOME/glib/commit/c63e3a4ada9852138042cb69441644bfe06ac430",
        "commit_title": "settings: Add support for defaults to keyfile backend",
        "commit_text": " Stacked databases and locks are dconf features that allow management software like Fleet Commander to set system-wide defaults and overrides centrally for applications.  This patch adds minimal support for the same to the keyfile backend. We look for a keyfile named 'defaults' and a lock-list named 'locks'.  Suitable files can be produced from a dconf database with dconf dump and dconf list-locks, respectively.  The default location for these files is /etc/glib-2.0/settings/. For test purposes, this can be overwritten with the GSETTINGS_DEFAULTS_DIR environment variable.  Writes always go to the per-user keyfile.",
        "func_before": "static void\ng_keyfile_settings_backend_finalize (GObject *object)\n{\n  GKeyfileSettingsBackend *kfsb = G_KEYFILE_SETTINGS_BACKEND (object);\n\n  g_key_file_free (kfsb->keyfile);\n  g_object_unref (kfsb->permission);\n\n  g_file_monitor_cancel (kfsb->file_monitor);\n  g_object_unref (kfsb->file_monitor);\n  g_object_unref (kfsb->file);\n\n  g_file_monitor_cancel (kfsb->dir_monitor);\n  g_object_unref (kfsb->dir_monitor);\n  g_object_unref (kfsb->dir);\n\n  g_free (kfsb->root_group);\n  g_free (kfsb->prefix);\n\n  G_OBJECT_CLASS (g_keyfile_settings_backend_parent_class)\n    ->finalize (object);\n}",
        "func": "static void\ng_keyfile_settings_backend_finalize (GObject *object)\n{\n  GKeyfileSettingsBackend *kfsb = G_KEYFILE_SETTINGS_BACKEND (object);\n\n  g_key_file_free (kfsb->keyfile);\n  g_object_unref (kfsb->permission);\n  g_key_file_unref (kfsb->system_keyfile);\n  g_hash_table_unref (kfsb->system_locks);\n  g_free (kfsb->defaults_dir);\n\n  g_file_monitor_cancel (kfsb->file_monitor);\n  g_object_unref (kfsb->file_monitor);\n  g_object_unref (kfsb->file);\n\n  g_file_monitor_cancel (kfsb->dir_monitor);\n  g_object_unref (kfsb->dir_monitor);\n  g_object_unref (kfsb->dir);\n\n  g_free (kfsb->root_group);\n  g_free (kfsb->prefix);\n\n  G_OBJECT_CLASS (g_keyfile_settings_backend_parent_class)\n    ->finalize (object);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,6 +5,9 @@\n \n   g_key_file_free (kfsb->keyfile);\n   g_object_unref (kfsb->permission);\n+  g_key_file_unref (kfsb->system_keyfile);\n+  g_hash_table_unref (kfsb->system_locks);\n+  g_free (kfsb->defaults_dir);\n \n   g_file_monitor_cancel (kfsb->file_monitor);\n   g_object_unref (kfsb->file_monitor);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "  g_key_file_unref (kfsb->system_keyfile);",
                "  g_hash_table_unref (kfsb->system_locks);",
                "  g_free (kfsb->defaults_dir);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-13012",
        "func_name": "GNOME/glib/g_keyfile_settings_backend_get_writable",
        "description": "The keyfile settings backend in GNOME GLib (aka glib2.0) before 2.60.0 creates directories using g_file_make_directory_with_parents (kfsb->dir, NULL, NULL) and files using g_file_replace_contents (kfsb->file, contents, length, NULL, FALSE, G_FILE_CREATE_REPLACE_DESTINATION, NULL, NULL, NULL). Consequently, it does not properly restrict directory (and file) permissions. Instead, for directories, 0777 permissions are used; for files, default file permissions are used. This is similar to CVE-2019-12450.",
        "git_url": "https://github.com/GNOME/glib/commit/c63e3a4ada9852138042cb69441644bfe06ac430",
        "commit_title": "settings: Add support for defaults to keyfile backend",
        "commit_text": " Stacked databases and locks are dconf features that allow management software like Fleet Commander to set system-wide defaults and overrides centrally for applications.  This patch adds minimal support for the same to the keyfile backend. We look for a keyfile named 'defaults' and a lock-list named 'locks'.  Suitable files can be produced from a dconf database with dconf dump and dconf list-locks, respectively.  The default location for these files is /etc/glib-2.0/settings/. For test purposes, this can be overwritten with the GSETTINGS_DEFAULTS_DIR environment variable.  Writes always go to the per-user keyfile.",
        "func_before": "static gboolean\ng_keyfile_settings_backend_get_writable (GSettingsBackend *backend,\n                                         const gchar      *name)\n{\n  GKeyfileSettingsBackend *kfsb = G_KEYFILE_SETTINGS_BACKEND (backend);\n\n  return kfsb->writable && path_is_valid (kfsb, name);\n}",
        "func": "static gboolean\ng_keyfile_settings_backend_get_writable (GSettingsBackend *backend,\n                                         const gchar      *name)\n{\n  GKeyfileSettingsBackend *kfsb = G_KEYFILE_SETTINGS_BACKEND (backend);\n\n  return kfsb->writable &&\n         !g_hash_table_contains (kfsb->system_locks, name) &&\n         path_is_valid (kfsb, name);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,5 +4,7 @@\n {\n   GKeyfileSettingsBackend *kfsb = G_KEYFILE_SETTINGS_BACKEND (backend);\n \n-  return kfsb->writable && path_is_valid (kfsb, name);\n+  return kfsb->writable &&\n+         !g_hash_table_contains (kfsb->system_locks, name) &&\n+         path_is_valid (kfsb, name);\n }",
        "diff_line_info": {
            "deleted_lines": [
                "  return kfsb->writable && path_is_valid (kfsb, name);"
            ],
            "added_lines": [
                "  return kfsb->writable &&",
                "         !g_hash_table_contains (kfsb->system_locks, name) &&",
                "         path_is_valid (kfsb, name);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-13012",
        "func_name": "GNOME/glib/set_to_keyfile",
        "description": "The keyfile settings backend in GNOME GLib (aka glib2.0) before 2.60.0 creates directories using g_file_make_directory_with_parents (kfsb->dir, NULL, NULL) and files using g_file_replace_contents (kfsb->file, contents, length, NULL, FALSE, G_FILE_CREATE_REPLACE_DESTINATION, NULL, NULL, NULL). Consequently, it does not properly restrict directory (and file) permissions. Instead, for directories, 0777 permissions are used; for files, default file permissions are used. This is similar to CVE-2019-12450.",
        "git_url": "https://github.com/GNOME/glib/commit/c63e3a4ada9852138042cb69441644bfe06ac430",
        "commit_title": "settings: Add support for defaults to keyfile backend",
        "commit_text": " Stacked databases and locks are dconf features that allow management software like Fleet Commander to set system-wide defaults and overrides centrally for applications.  This patch adds minimal support for the same to the keyfile backend. We look for a keyfile named 'defaults' and a lock-list named 'locks'.  Suitable files can be produced from a dconf database with dconf dump and dconf list-locks, respectively.  The default location for these files is /etc/glib-2.0/settings/. For test purposes, this can be overwritten with the GSETTINGS_DEFAULTS_DIR environment variable.  Writes always go to the per-user keyfile.",
        "func_before": "static gboolean\nset_to_keyfile (GKeyfileSettingsBackend *kfsb,\n                const gchar             *key,\n                GVariant                *value)\n{\n  gchar *group, *name;\n\n  if (convert_path (kfsb, key, &group, &name))\n    {\n      if (value)\n        {\n          gchar *str = g_variant_print (value, FALSE);\n          g_key_file_set_value (kfsb->keyfile, group, name, str);\n          g_variant_unref (g_variant_ref_sink (value));\n          g_free (str);\n        }\n      else\n        {\n          if (*name == '\\0')\n            {\n              gchar **groups;\n              gint i;\n\n              groups = g_key_file_get_groups (kfsb->keyfile, NULL);\n\n              for (i = 0; groups[i]; i++)\n                if (group_name_matches (groups[i], group))\n                  g_key_file_remove_group (kfsb->keyfile, groups[i], NULL);\n\n              g_strfreev (groups);\n            }\n          else\n            g_key_file_remove_key (kfsb->keyfile, group, name, NULL);\n        }\n\n      g_free (group);\n      g_free (name);\n\n      return TRUE;\n    }\n\n  return FALSE;\n}",
        "func": "static gboolean\nset_to_keyfile (GKeyfileSettingsBackend *kfsb,\n                const gchar             *key,\n                GVariant                *value)\n{\n  gchar *group, *name;\n\n  if (g_hash_table_contains (kfsb->system_locks, key))\n    return FALSE;\n\n  if (convert_path (kfsb, key, &group, &name))\n    {\n      if (value)\n        {\n          gchar *str = g_variant_print (value, FALSE);\n          g_key_file_set_value (kfsb->keyfile, group, name, str);\n          g_variant_unref (g_variant_ref_sink (value));\n          g_free (str);\n        }\n      else\n        {\n          if (*name == '\\0')\n            {\n              gchar **groups;\n              gint i;\n\n              groups = g_key_file_get_groups (kfsb->keyfile, NULL);\n\n              for (i = 0; groups[i]; i++)\n                if (group_name_matches (groups[i], group))\n                  g_key_file_remove_group (kfsb->keyfile, groups[i], NULL);\n\n              g_strfreev (groups);\n            }\n          else\n            g_key_file_remove_key (kfsb->keyfile, group, name, NULL);\n        }\n\n      g_free (group);\n      g_free (name);\n\n      return TRUE;\n    }\n\n  return FALSE;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,6 +4,9 @@\n                 GVariant                *value)\n {\n   gchar *group, *name;\n+\n+  if (g_hash_table_contains (kfsb->system_locks, key))\n+    return FALSE;\n \n   if (convert_path (kfsb, key, &group, &name))\n     {",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "  if (g_hash_table_contains (kfsb->system_locks, key))",
                "    return FALSE;"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-13012",
        "func_name": "GNOME/glib/get_from_keyfile",
        "description": "The keyfile settings backend in GNOME GLib (aka glib2.0) before 2.60.0 creates directories using g_file_make_directory_with_parents (kfsb->dir, NULL, NULL) and files using g_file_replace_contents (kfsb->file, contents, length, NULL, FALSE, G_FILE_CREATE_REPLACE_DESTINATION, NULL, NULL, NULL). Consequently, it does not properly restrict directory (and file) permissions. Instead, for directories, 0777 permissions are used; for files, default file permissions are used. This is similar to CVE-2019-12450.",
        "git_url": "https://github.com/GNOME/glib/commit/c63e3a4ada9852138042cb69441644bfe06ac430",
        "commit_title": "settings: Add support for defaults to keyfile backend",
        "commit_text": " Stacked databases and locks are dconf features that allow management software like Fleet Commander to set system-wide defaults and overrides centrally for applications.  This patch adds minimal support for the same to the keyfile backend. We look for a keyfile named 'defaults' and a lock-list named 'locks'.  Suitable files can be produced from a dconf database with dconf dump and dconf list-locks, respectively.  The default location for these files is /etc/glib-2.0/settings/. For test purposes, this can be overwritten with the GSETTINGS_DEFAULTS_DIR environment variable.  Writes always go to the per-user keyfile.",
        "func_before": "static GVariant *\nget_from_keyfile (GKeyfileSettingsBackend *kfsb,\n                  const GVariantType      *type,\n                  const gchar             *key)\n{\n  GVariant *return_value = NULL;\n  gchar *group, *name;\n\n  if (convert_path (kfsb, key, &group, &name))\n    {\n      gchar *str;\n\n      g_assert (*name);\n\n      str = g_key_file_get_value (kfsb->keyfile, group, name, NULL);\n\n      if (str)\n        {\n          return_value = g_variant_parse (type, str, NULL, NULL, NULL);\n          g_free (str);\n        }\n\n      g_free (group);\n      g_free (name);\n    }\n\n  return return_value;\n}",
        "func": "static GVariant *\nget_from_keyfile (GKeyfileSettingsBackend *kfsb,\n                  const GVariantType      *type,\n                  const gchar             *key)\n{\n  GVariant *return_value = NULL;\n  gchar *group, *name;\n\n  if (convert_path (kfsb, key, &group, &name))\n    {\n      gchar *str;\n      gchar *sysstr;\n\n      g_assert (*name);\n\n      sysstr = g_key_file_get_value (kfsb->system_keyfile, group, name, NULL);\n      str = g_key_file_get_value (kfsb->keyfile, group, name, NULL);\n      if (sysstr &&\n          (g_hash_table_contains (kfsb->system_locks, key) ||\n           str == NULL))\n        {\n          g_free (str);\n          str = g_steal_pointer (&sysstr);\n        }\n\n      if (str)\n        {\n          return_value = g_variant_parse (type, str, NULL, NULL, NULL);\n          g_free (str);\n        }\n\n      g_free (sysstr);\n\n      g_free (group);\n      g_free (name);\n    }\n\n  return return_value;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -9,10 +9,19 @@\n   if (convert_path (kfsb, key, &group, &name))\n     {\n       gchar *str;\n+      gchar *sysstr;\n \n       g_assert (*name);\n \n+      sysstr = g_key_file_get_value (kfsb->system_keyfile, group, name, NULL);\n       str = g_key_file_get_value (kfsb->keyfile, group, name, NULL);\n+      if (sysstr &&\n+          (g_hash_table_contains (kfsb->system_locks, key) ||\n+           str == NULL))\n+        {\n+          g_free (str);\n+          str = g_steal_pointer (&sysstr);\n+        }\n \n       if (str)\n         {\n@@ -20,6 +29,8 @@\n           g_free (str);\n         }\n \n+      g_free (sysstr);\n+\n       g_free (group);\n       g_free (name);\n     }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "      gchar *sysstr;",
                "      sysstr = g_key_file_get_value (kfsb->system_keyfile, group, name, NULL);",
                "      if (sysstr &&",
                "          (g_hash_table_contains (kfsb->system_locks, key) ||",
                "           str == NULL))",
                "        {",
                "          g_free (str);",
                "          str = g_steal_pointer (&sysstr);",
                "        }",
                "      g_free (sysstr);",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2019-13012",
        "func_name": "GNOME/glib/g_keyfile_settings_backend_constructed",
        "description": "The keyfile settings backend in GNOME GLib (aka glib2.0) before 2.60.0 creates directories using g_file_make_directory_with_parents (kfsb->dir, NULL, NULL) and files using g_file_replace_contents (kfsb->file, contents, length, NULL, FALSE, G_FILE_CREATE_REPLACE_DESTINATION, NULL, NULL, NULL). Consequently, it does not properly restrict directory (and file) permissions. Instead, for directories, 0777 permissions are used; for files, default file permissions are used. This is similar to CVE-2019-12450.",
        "git_url": "https://github.com/GNOME/glib/commit/c63e3a4ada9852138042cb69441644bfe06ac430",
        "commit_title": "settings: Add support for defaults to keyfile backend",
        "commit_text": " Stacked databases and locks are dconf features that allow management software like Fleet Commander to set system-wide defaults and overrides centrally for applications.  This patch adds minimal support for the same to the keyfile backend. We look for a keyfile named 'defaults' and a lock-list named 'locks'.  Suitable files can be produced from a dconf database with dconf dump and dconf list-locks, respectively.  The default location for these files is /etc/glib-2.0/settings/. For test purposes, this can be overwritten with the GSETTINGS_DEFAULTS_DIR environment variable.  Writes always go to the per-user keyfile.",
        "func_before": "static void\ng_keyfile_settings_backend_constructed (GObject *object)\n{\n  GKeyfileSettingsBackend *kfsb = G_KEYFILE_SETTINGS_BACKEND (object);\n\n  if (kfsb->file == NULL)\n    {\n      char *filename = g_build_filename (g_get_user_config_dir (),\n                                         \"glib-2.0\", \"settings\", \"keyfile\",\n                                         NULL);\n      kfsb->file = g_file_new_for_path (filename);\n      g_free (filename);\n    }\n\n  if (kfsb->prefix == NULL)\n    {\n      kfsb->prefix = g_strdup (\"/\");\n      kfsb->prefix_len = 1;\n    }\n  \n  kfsb->keyfile = g_key_file_new ();\n  kfsb->permission = g_simple_permission_new (TRUE);\n\n  kfsb->dir = g_file_get_parent (kfsb->file);\n  g_file_make_directory_with_parents (kfsb->dir, NULL, NULL);\n\n  kfsb->file_monitor = g_file_monitor (kfsb->file, G_FILE_MONITOR_NONE, NULL, NULL);\n  kfsb->dir_monitor = g_file_monitor (kfsb->dir, G_FILE_MONITOR_NONE, NULL, NULL);\n\n  compute_checksum (kfsb->digest, NULL, 0);\n\n  g_signal_connect (kfsb->file_monitor, \"changed\",\n                    G_CALLBACK (file_changed), kfsb);\n  g_signal_connect (kfsb->dir_monitor, \"changed\",\n                    G_CALLBACK (dir_changed), kfsb);\n\n  g_keyfile_settings_backend_keyfile_writable (kfsb);\n  g_keyfile_settings_backend_keyfile_reload (kfsb);\n}",
        "func": "static void\ng_keyfile_settings_backend_constructed (GObject *object)\n{\n  GKeyfileSettingsBackend *kfsb = G_KEYFILE_SETTINGS_BACKEND (object);\n\n  if (kfsb->file == NULL)\n    {\n      char *filename = g_build_filename (g_get_user_config_dir (),\n                                         \"glib-2.0\", \"settings\", \"keyfile\",\n                                         NULL);\n      kfsb->file = g_file_new_for_path (filename);\n      g_free (filename);\n    }\n\n  if (kfsb->prefix == NULL)\n    {\n      kfsb->prefix = g_strdup (\"/\");\n      kfsb->prefix_len = 1;\n    }\n  \n  kfsb->keyfile = g_key_file_new ();\n  kfsb->permission = g_simple_permission_new (TRUE);\n\n  kfsb->dir = g_file_get_parent (kfsb->file);\n  g_file_make_directory_with_parents (kfsb->dir, NULL, NULL);\n\n  kfsb->file_monitor = g_file_monitor (kfsb->file, G_FILE_MONITOR_NONE, NULL, NULL);\n  kfsb->dir_monitor = g_file_monitor (kfsb->dir, G_FILE_MONITOR_NONE, NULL, NULL);\n\n  compute_checksum (kfsb->digest, NULL, 0);\n\n  g_signal_connect (kfsb->file_monitor, \"changed\",\n                    G_CALLBACK (file_changed), kfsb);\n  g_signal_connect (kfsb->dir_monitor, \"changed\",\n                    G_CALLBACK (dir_changed), kfsb);\n\n  g_keyfile_settings_backend_keyfile_writable (kfsb);\n  g_keyfile_settings_backend_keyfile_reload (kfsb);\n\n  load_system_settings (kfsb);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -36,4 +36,6 @@\n \n   g_keyfile_settings_backend_keyfile_writable (kfsb);\n   g_keyfile_settings_backend_keyfile_reload (kfsb);\n+\n+  load_system_settings (kfsb);\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "  load_system_settings (kfsb);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-13012",
        "func_name": "GNOME/glib/g_keyfile_settings_backend_class_init",
        "description": "The keyfile settings backend in GNOME GLib (aka glib2.0) before 2.60.0 creates directories using g_file_make_directory_with_parents (kfsb->dir, NULL, NULL) and files using g_file_replace_contents (kfsb->file, contents, length, NULL, FALSE, G_FILE_CREATE_REPLACE_DESTINATION, NULL, NULL, NULL). Consequently, it does not properly restrict directory (and file) permissions. Instead, for directories, 0777 permissions are used; for files, default file permissions are used. This is similar to CVE-2019-12450.",
        "git_url": "https://github.com/GNOME/glib/commit/c63e3a4ada9852138042cb69441644bfe06ac430",
        "commit_title": "settings: Add support for defaults to keyfile backend",
        "commit_text": " Stacked databases and locks are dconf features that allow management software like Fleet Commander to set system-wide defaults and overrides centrally for applications.  This patch adds minimal support for the same to the keyfile backend. We look for a keyfile named 'defaults' and a lock-list named 'locks'.  Suitable files can be produced from a dconf database with dconf dump and dconf list-locks, respectively.  The default location for these files is /etc/glib-2.0/settings/. For test purposes, this can be overwritten with the GSETTINGS_DEFAULTS_DIR environment variable.  Writes always go to the per-user keyfile.",
        "func_before": "static void\ng_keyfile_settings_backend_class_init (GKeyfileSettingsBackendClass *class)\n{\n  GObjectClass *object_class = G_OBJECT_CLASS (class);\n\n  object_class->finalize = g_keyfile_settings_backend_finalize;\n  object_class->constructed = g_keyfile_settings_backend_constructed;\n  object_class->get_property = g_keyfile_settings_backend_get_property;\n  object_class->set_property = g_keyfile_settings_backend_set_property;\n\n  class->read = g_keyfile_settings_backend_read;\n  class->write = g_keyfile_settings_backend_write;\n  class->write_tree = g_keyfile_settings_backend_write_tree;\n  class->reset = g_keyfile_settings_backend_reset;\n  class->get_writable = g_keyfile_settings_backend_get_writable;\n  class->get_permission = g_keyfile_settings_backend_get_permission;\n  /* No need to implement subscribed/unsubscribe: the only point would be to\n   * stop monitoring the file when there's no GSettings anymore, which is no\n   * big win.\n   */\n\n  /**\n   * GKeyfileSettingsBackend:filename:\n   *\n   * The location where the settings are stored on disk.\n   *\n   * Defaults to `$XDG_CONFIG_HOME/glib-2.0/settings/keyfile`.\n   */\n  g_object_class_install_property (object_class,\n                                   PROP_FILENAME,\n                                   g_param_spec_string (\"filename\",\n                                                        P_(\"Filename\"),\n                                                        P_(\"The filename\"),\n                                                        NULL,\n                                                        G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY |\n                                                        G_PARAM_STATIC_STRINGS));\n\n  /**\n   * GKeyfileSettingsBackend:root-path:\n   *\n   * All settings read to or written from the backend must fall under the\n   * path given in @root_path (which must start and end with a slash and\n   * not contain two consecutive slashes).  @root_path may be \"/\".\n   * \n   * Defaults to \"/\".\n   */\n  g_object_class_install_property (object_class,\n                                   PROP_ROOT_PATH,\n                                   g_param_spec_string (\"root-path\",\n                                                        P_(\"Root path\"),\n                                                        P_(\"The root path\"),\n                                                        NULL,\n                                                        G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY |\n                                                        G_PARAM_STATIC_STRINGS));\n\n  /**\n   * GKeyfileSettingsBackend:root-group:\n   *\n   * If @root_group is non-%NULL then it specifies the name of the keyfile\n   * group used for keys that are written directly below the root path.\n   *\n   * Defaults to NULL.\n   */\n  g_object_class_install_property (object_class,\n                                   PROP_ROOT_GROUP,\n                                   g_param_spec_string (\"root-group\",\n                                                        P_(\"Root group\"),\n                                                        P_(\"The root group\"),\n                                                        NULL,\n                                                        G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY |\n                                                        G_PARAM_STATIC_STRINGS));\n}",
        "func": "static void\ng_keyfile_settings_backend_class_init (GKeyfileSettingsBackendClass *class)\n{\n  GObjectClass *object_class = G_OBJECT_CLASS (class);\n\n  object_class->finalize = g_keyfile_settings_backend_finalize;\n  object_class->constructed = g_keyfile_settings_backend_constructed;\n  object_class->get_property = g_keyfile_settings_backend_get_property;\n  object_class->set_property = g_keyfile_settings_backend_set_property;\n\n  class->read = g_keyfile_settings_backend_read;\n  class->write = g_keyfile_settings_backend_write;\n  class->write_tree = g_keyfile_settings_backend_write_tree;\n  class->reset = g_keyfile_settings_backend_reset;\n  class->get_writable = g_keyfile_settings_backend_get_writable;\n  class->get_permission = g_keyfile_settings_backend_get_permission;\n  /* No need to implement subscribed/unsubscribe: the only point would be to\n   * stop monitoring the file when there's no GSettings anymore, which is no\n   * big win.\n   */\n\n  /**\n   * GKeyfileSettingsBackend:filename:\n   *\n   * The location where the settings are stored on disk.\n   *\n   * Defaults to `$XDG_CONFIG_HOME/glib-2.0/settings/keyfile`.\n   */\n  g_object_class_install_property (object_class,\n                                   PROP_FILENAME,\n                                   g_param_spec_string (\"filename\",\n                                                        P_(\"Filename\"),\n                                                        P_(\"The filename\"),\n                                                        NULL,\n                                                        G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY |\n                                                        G_PARAM_STATIC_STRINGS));\n\n  /**\n   * GKeyfileSettingsBackend:root-path:\n   *\n   * All settings read to or written from the backend must fall under the\n   * path given in @root_path (which must start and end with a slash and\n   * not contain two consecutive slashes).  @root_path may be \"/\".\n   * \n   * Defaults to \"/\".\n   */\n  g_object_class_install_property (object_class,\n                                   PROP_ROOT_PATH,\n                                   g_param_spec_string (\"root-path\",\n                                                        P_(\"Root path\"),\n                                                        P_(\"The root path\"),\n                                                        NULL,\n                                                        G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY |\n                                                        G_PARAM_STATIC_STRINGS));\n\n  /**\n   * GKeyfileSettingsBackend:root-group:\n   *\n   * If @root_group is non-%NULL then it specifies the name of the keyfile\n   * group used for keys that are written directly below the root path.\n   *\n   * Defaults to NULL.\n   */\n  g_object_class_install_property (object_class,\n                                   PROP_ROOT_GROUP,\n                                   g_param_spec_string (\"root-group\",\n                                                        P_(\"Root group\"),\n                                                        P_(\"The root group\"),\n                                                        NULL,\n                                                        G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY |\n                                                        G_PARAM_STATIC_STRINGS));\n\n  /**\n   * GKeyfileSettingsBackend:default-dir:\n   *\n   * The directory where the system defaults and locks are located.\n   *\n   * Defaults to `/etc/glib-2.0/settings`.\n   */\n  g_object_class_install_property (object_class,\n                                   PROP_DEFAULTS_DIR,\n                                   g_param_spec_string (\"defaults-dir\",\n                                                        P_(\"Default dir\"),\n                                                        P_(\"Defaults dir\"),\n                                                        NULL,\n                                                        G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY |\n                                                        G_PARAM_STATIC_STRINGS));\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -69,4 +69,20 @@\n                                                         NULL,\n                                                         G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY |\n                                                         G_PARAM_STATIC_STRINGS));\n+\n+  /**\n+   * GKeyfileSettingsBackend:default-dir:\n+   *\n+   * The directory where the system defaults and locks are located.\n+   *\n+   * Defaults to `/etc/glib-2.0/settings`.\n+   */\n+  g_object_class_install_property (object_class,\n+                                   PROP_DEFAULTS_DIR,\n+                                   g_param_spec_string (\"defaults-dir\",\n+                                                        P_(\"Default dir\"),\n+                                                        P_(\"Defaults dir\"),\n+                                                        NULL,\n+                                                        G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY |\n+                                                        G_PARAM_STATIC_STRINGS));\n }",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "  /**",
                "   * GKeyfileSettingsBackend:default-dir:",
                "   *",
                "   * The directory where the system defaults and locks are located.",
                "   *",
                "   * Defaults to `/etc/glib-2.0/settings`.",
                "   */",
                "  g_object_class_install_property (object_class,",
                "                                   PROP_DEFAULTS_DIR,",
                "                                   g_param_spec_string (\"defaults-dir\",",
                "                                                        P_(\"Default dir\"),",
                "                                                        P_(\"Defaults dir\"),",
                "                                                        NULL,",
                "                                                        G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY |",
                "                                                        G_PARAM_STATIC_STRINGS));"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-13012",
        "func_name": "GNOME/glib/g_keyfile_settings_backend_set_property",
        "description": "The keyfile settings backend in GNOME GLib (aka glib2.0) before 2.60.0 creates directories using g_file_make_directory_with_parents (kfsb->dir, NULL, NULL) and files using g_file_replace_contents (kfsb->file, contents, length, NULL, FALSE, G_FILE_CREATE_REPLACE_DESTINATION, NULL, NULL, NULL). Consequently, it does not properly restrict directory (and file) permissions. Instead, for directories, 0777 permissions are used; for files, default file permissions are used. This is similar to CVE-2019-12450.",
        "git_url": "https://github.com/GNOME/glib/commit/c63e3a4ada9852138042cb69441644bfe06ac430",
        "commit_title": "settings: Add support for defaults to keyfile backend",
        "commit_text": " Stacked databases and locks are dconf features that allow management software like Fleet Commander to set system-wide defaults and overrides centrally for applications.  This patch adds minimal support for the same to the keyfile backend. We look for a keyfile named 'defaults' and a lock-list named 'locks'.  Suitable files can be produced from a dconf database with dconf dump and dconf list-locks, respectively.  The default location for these files is /etc/glib-2.0/settings/. For test purposes, this can be overwritten with the GSETTINGS_DEFAULTS_DIR environment variable.  Writes always go to the per-user keyfile.",
        "func_before": "static void\ng_keyfile_settings_backend_set_property (GObject      *object,\n                                         guint         prop_id,\n                                         const GValue *value,\n                                         GParamSpec   *pspec)\n{\n  GKeyfileSettingsBackend *kfsb = G_KEYFILE_SETTINGS_BACKEND (object);\n\n  switch (prop_id)\n    {\n    case PROP_FILENAME:\n      /* Construct only. */\n      g_assert (kfsb->file == NULL);\n      kfsb->file = g_file_new_for_path (g_value_get_string (value));\n      break;\n\n    case PROP_ROOT_PATH:\n      /* Construct only. */\n      g_assert (kfsb->prefix == NULL);\n      kfsb->prefix = g_value_dup_string (value);\n      if (kfsb->prefix)\n        kfsb->prefix_len = strlen (kfsb->prefix);\n      break;\n\n    case PROP_ROOT_GROUP:\n      /* Construct only. */\n      g_assert (kfsb->root_group == NULL);\n      kfsb->root_group = g_value_dup_string (value);\n      if (kfsb->root_group)\n        kfsb->root_group_len = strlen (kfsb->root_group);\n      break;\n\n    default:\n      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);\n      break;\n    }\n}",
        "func": "static void\ng_keyfile_settings_backend_set_property (GObject      *object,\n                                         guint         prop_id,\n                                         const GValue *value,\n                                         GParamSpec   *pspec)\n{\n  GKeyfileSettingsBackend *kfsb = G_KEYFILE_SETTINGS_BACKEND (object);\n\n  switch ((GKeyfileSettingsBackendProperty)prop_id)\n    {\n    case PROP_FILENAME:\n      /* Construct only. */\n      g_assert (kfsb->file == NULL);\n      kfsb->file = g_file_new_for_path (g_value_get_string (value));\n      break;\n\n    case PROP_ROOT_PATH:\n      /* Construct only. */\n      g_assert (kfsb->prefix == NULL);\n      kfsb->prefix = g_value_dup_string (value);\n      if (kfsb->prefix)\n        kfsb->prefix_len = strlen (kfsb->prefix);\n      break;\n\n    case PROP_ROOT_GROUP:\n      /* Construct only. */\n      g_assert (kfsb->root_group == NULL);\n      kfsb->root_group = g_value_dup_string (value);\n      if (kfsb->root_group)\n        kfsb->root_group_len = strlen (kfsb->root_group);\n      break;\n\n    case PROP_DEFAULTS_DIR:\n      /* Construct only. */\n      g_assert (kfsb->defaults_dir == NULL);\n      kfsb->defaults_dir = g_value_dup_string (value);\n      break;\n\n    default:\n      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);\n      break;\n    }\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,7 +6,7 @@\n {\n   GKeyfileSettingsBackend *kfsb = G_KEYFILE_SETTINGS_BACKEND (object);\n \n-  switch (prop_id)\n+  switch ((GKeyfileSettingsBackendProperty)prop_id)\n     {\n     case PROP_FILENAME:\n       /* Construct only. */\n@@ -30,6 +30,12 @@\n         kfsb->root_group_len = strlen (kfsb->root_group);\n       break;\n \n+    case PROP_DEFAULTS_DIR:\n+      /* Construct only. */\n+      g_assert (kfsb->defaults_dir == NULL);\n+      kfsb->defaults_dir = g_value_dup_string (value);\n+      break;\n+\n     default:\n       G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);\n       break;",
        "diff_line_info": {
            "deleted_lines": [
                "  switch (prop_id)"
            ],
            "added_lines": [
                "  switch ((GKeyfileSettingsBackendProperty)prop_id)",
                "    case PROP_DEFAULTS_DIR:",
                "      /* Construct only. */",
                "      g_assert (kfsb->defaults_dir == NULL);",
                "      kfsb->defaults_dir = g_value_dup_string (value);",
                "      break;",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2017-15906",
        "func_name": "openbsd/src/process_open",
        "description": "The process_open function in sftp-server.c in OpenSSH before 7.6 does not properly prevent write operations in readonly mode, which allows attackers to create zero-length files.",
        "git_url": "https://github.com/openbsd/src/commit/a6981567e8e215acc1ef690c8dbb30f2d9b00a19",
        "commit_title": "disallow creation (of empty files) in read-only mode; reported by",
        "commit_text": "Michal Zalewski, feedback & ok deraadt@",
        "func_before": "static void\nprocess_open(u_int32_t id)\n{\n\tu_int32_t pflags;\n\tAttrib a;\n\tchar *name;\n\tint r, handle, fd, flags, mode, status = SSH2_FX_FAILURE;\n\n\tif ((r = sshbuf_get_cstring(iqueue, &name, NULL)) != 0 ||\n\t    (r = sshbuf_get_u32(iqueue, &pflags)) != 0 || /* portable flags */\n\t    (r = decode_attrib(iqueue, &a)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tdebug3(\"request %u: open flags %d\", id, pflags);\n\tflags = flags_from_portable(pflags);\n\tmode = (a.flags & SSH2_FILEXFER_ATTR_PERMISSIONS) ? a.perm : 0666;\n\tlogit(\"open \\\"%s\\\" flags %s mode 0%o\",\n\t    name, string_from_portable(pflags), mode);\n\tif (readonly &&\n\t    ((flags & O_ACCMODE) == O_WRONLY ||\n\t    (flags & O_ACCMODE) == O_RDWR)) {\n\t\tverbose(\"Refusing open request in read-only mode\");\n\t\tstatus = SSH2_FX_PERMISSION_DENIED;\n\t} else {\n\t\tfd = open(name, flags, mode);\n\t\tif (fd < 0) {\n\t\t\tstatus = errno_to_portable(errno);\n\t\t} else {\n\t\t\thandle = handle_new(HANDLE_FILE, name, fd, flags, NULL);\n\t\t\tif (handle < 0) {\n\t\t\t\tclose(fd);\n\t\t\t} else {\n\t\t\t\tsend_handle(id, handle);\n\t\t\t\tstatus = SSH2_FX_OK;\n\t\t\t}\n\t\t}\n\t}\n\tif (status != SSH2_FX_OK)\n\t\tsend_status(id, status);\n\tfree(name);\n}",
        "func": "static void\nprocess_open(u_int32_t id)\n{\n\tu_int32_t pflags;\n\tAttrib a;\n\tchar *name;\n\tint r, handle, fd, flags, mode, status = SSH2_FX_FAILURE;\n\n\tif ((r = sshbuf_get_cstring(iqueue, &name, NULL)) != 0 ||\n\t    (r = sshbuf_get_u32(iqueue, &pflags)) != 0 || /* portable flags */\n\t    (r = decode_attrib(iqueue, &a)) != 0)\n\t\tfatal(\"%s: buffer error: %s\", __func__, ssh_err(r));\n\n\tdebug3(\"request %u: open flags %d\", id, pflags);\n\tflags = flags_from_portable(pflags);\n\tmode = (a.flags & SSH2_FILEXFER_ATTR_PERMISSIONS) ? a.perm : 0666;\n\tlogit(\"open \\\"%s\\\" flags %s mode 0%o\",\n\t    name, string_from_portable(pflags), mode);\n\tif (readonly &&\n\t    ((flags & O_ACCMODE) != O_RDONLY ||\n\t    (flags & (O_CREAT|O_TRUNC)) != 0)) {\n\t\tverbose(\"Refusing open request in read-only mode\");\n\t\tstatus = SSH2_FX_PERMISSION_DENIED;\n\t} else {\n\t\tfd = open(name, flags, mode);\n\t\tif (fd < 0) {\n\t\t\tstatus = errno_to_portable(errno);\n\t\t} else {\n\t\t\thandle = handle_new(HANDLE_FILE, name, fd, flags, NULL);\n\t\t\tif (handle < 0) {\n\t\t\t\tclose(fd);\n\t\t\t} else {\n\t\t\t\tsend_handle(id, handle);\n\t\t\t\tstatus = SSH2_FX_OK;\n\t\t\t}\n\t\t}\n\t}\n\tif (status != SSH2_FX_OK)\n\t\tsend_status(id, status);\n\tfree(name);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -17,8 +17,8 @@\n \tlogit(\"open \\\"%s\\\" flags %s mode 0%o\",\n \t    name, string_from_portable(pflags), mode);\n \tif (readonly &&\n-\t    ((flags & O_ACCMODE) == O_WRONLY ||\n-\t    (flags & O_ACCMODE) == O_RDWR)) {\n+\t    ((flags & O_ACCMODE) != O_RDONLY ||\n+\t    (flags & (O_CREAT|O_TRUNC)) != 0)) {\n \t\tverbose(\"Refusing open request in read-only mode\");\n \t\tstatus = SSH2_FX_PERMISSION_DENIED;\n \t} else {",
        "diff_line_info": {
            "deleted_lines": [
                "\t    ((flags & O_ACCMODE) == O_WRONLY ||",
                "\t    (flags & O_ACCMODE) == O_RDWR)) {"
            ],
            "added_lines": [
                "\t    ((flags & O_ACCMODE) != O_RDONLY ||",
                "\t    (flags & (O_CREAT|O_TRUNC)) != 0)) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2020-24394",
        "func_name": "torvalds/linux/do_nfsd_create",
        "description": "In the Linux kernel before 5.7.8, fs/nfsd/vfs.c (in the NFS server) can set incorrect permissions on new filesystem objects when the filesystem lacks ACL support, aka CID-22cf8419f131. This occurs because the current umask is not considered.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=22cf8419f1319ff87ec759d0ebdff4cbafaee832",
        "commit_title": "The server is failing to apply the umask when creating new objects on",
        "commit_text": "filesystems without ACL support.  To reproduce this, you need to use NFSv4.2 and a client and server recent enough to support umask, and you need to export a filesystem that lacks ACL support (for example, ext4 with the \"noacl\" mount option).  Filesystems with ACL support are expected to take care of the umask themselves (usually by calling posix_acl_create).  For filesystems without ACL support, this is up to the caller of vfs_create(), vfs_mknod(), or vfs_mkdir().  Cc: stable@vger.kernel.org ",
        "func_before": "__be32\ndo_nfsd_create(struct svc_rqst *rqstp, struct svc_fh *fhp,\n\t\tchar *fname, int flen, struct iattr *iap,\n\t\tstruct svc_fh *resfhp, int createmode, u32 *verifier,\n\t        bool *truncp, bool *created)\n{\n\tstruct dentry\t*dentry, *dchild = NULL;\n\tstruct inode\t*dirp;\n\t__be32\t\terr;\n\tint\t\thost_err;\n\t__u32\t\tv_mtime=0, v_atime=0;\n\n\terr = nfserr_perm;\n\tif (!flen)\n\t\tgoto out;\n\terr = nfserr_exist;\n\tif (isdotent(fname, flen))\n\t\tgoto out;\n\tif (!(iap->ia_valid & ATTR_MODE))\n\t\tiap->ia_mode = 0;\n\terr = fh_verify(rqstp, fhp, S_IFDIR, NFSD_MAY_EXEC);\n\tif (err)\n\t\tgoto out;\n\n\tdentry = fhp->fh_dentry;\n\tdirp = d_inode(dentry);\n\n\thost_err = fh_want_write(fhp);\n\tif (host_err)\n\t\tgoto out_nfserr;\n\n\tfh_lock_nested(fhp, I_MUTEX_PARENT);\n\n\t/*\n\t * Compose the response file handle.\n\t */\n\tdchild = lookup_one_len(fname, dentry, flen);\n\thost_err = PTR_ERR(dchild);\n\tif (IS_ERR(dchild))\n\t\tgoto out_nfserr;\n\n\t/* If file doesn't exist, check for permissions to create one */\n\tif (d_really_is_negative(dchild)) {\n\t\terr = fh_verify(rqstp, fhp, S_IFDIR, NFSD_MAY_CREATE);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\terr = fh_compose(resfhp, fhp->fh_export, dchild, fhp);\n\tif (err)\n\t\tgoto out;\n\n\tif (nfsd_create_is_exclusive(createmode)) {\n\t\t/* solaris7 gets confused (bugid 4218508) if these have\n\t\t * the high bit set, so just clear the high bits. If this is\n\t\t * ever changed to use different attrs for storing the\n\t\t * verifier, then do_open_lookup() will also need to be fixed\n\t\t * accordingly.\n\t\t */\n\t\tv_mtime = verifier[0]&0x7fffffff;\n\t\tv_atime = verifier[1]&0x7fffffff;\n\t}\n\t\n\tif (d_really_is_positive(dchild)) {\n\t\terr = 0;\n\n\t\tswitch (createmode) {\n\t\tcase NFS3_CREATE_UNCHECKED:\n\t\t\tif (! d_is_reg(dchild))\n\t\t\t\tgoto out;\n\t\t\telse if (truncp) {\n\t\t\t\t/* in nfsv4, we need to treat this case a little\n\t\t\t\t * differently.  we don't want to truncate the\n\t\t\t\t * file now; this would be wrong if the OPEN\n\t\t\t\t * fails for some other reason.  furthermore,\n\t\t\t\t * if the size is nonzero, we should ignore it\n\t\t\t\t * according to spec!\n\t\t\t\t */\n\t\t\t\t*truncp = (iap->ia_valid & ATTR_SIZE) && !iap->ia_size;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tiap->ia_valid &= ATTR_SIZE;\n\t\t\t\tgoto set_attr;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase NFS3_CREATE_EXCLUSIVE:\n\t\t\tif (   d_inode(dchild)->i_mtime.tv_sec == v_mtime\n\t\t\t    && d_inode(dchild)->i_atime.tv_sec == v_atime\n\t\t\t    && d_inode(dchild)->i_size  == 0 ) {\n\t\t\t\tif (created)\n\t\t\t\t\t*created = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* fall through */\n\t\tcase NFS4_CREATE_EXCLUSIVE4_1:\n\t\t\tif (   d_inode(dchild)->i_mtime.tv_sec == v_mtime\n\t\t\t    && d_inode(dchild)->i_atime.tv_sec == v_atime\n\t\t\t    && d_inode(dchild)->i_size  == 0 ) {\n\t\t\t\tif (created)\n\t\t\t\t\t*created = true;\n\t\t\t\tgoto set_attr;\n\t\t\t}\n\t\t\t/* fall through */\n\t\tcase NFS3_CREATE_GUARDED:\n\t\t\terr = nfserr_exist;\n\t\t}\n\t\tfh_drop_write(fhp);\n\t\tgoto out;\n\t}\n\n\thost_err = vfs_create(dirp, dchild, iap->ia_mode, true);\n\tif (host_err < 0) {\n\t\tfh_drop_write(fhp);\n\t\tgoto out_nfserr;\n\t}\n\tif (created)\n\t\t*created = true;\n\n\tnfsd_check_ignore_resizing(iap);\n\n\tif (nfsd_create_is_exclusive(createmode)) {\n\t\t/* Cram the verifier into atime/mtime */\n\t\tiap->ia_valid = ATTR_MTIME|ATTR_ATIME\n\t\t\t| ATTR_MTIME_SET|ATTR_ATIME_SET;\n\t\t/* XXX someone who knows this better please fix it for nsec */ \n\t\tiap->ia_mtime.tv_sec = v_mtime;\n\t\tiap->ia_atime.tv_sec = v_atime;\n\t\tiap->ia_mtime.tv_nsec = 0;\n\t\tiap->ia_atime.tv_nsec = 0;\n\t}\n\n set_attr:\n\terr = nfsd_create_setattr(rqstp, resfhp, iap);\n\n\t/*\n\t * nfsd_create_setattr already committed the child\n\t * (and possibly also the parent).\n\t */\n\tif (!err)\n\t\terr = nfserrno(commit_metadata(fhp));\n\n\t/*\n\t * Update the filehandle to get the new inode info.\n\t */\n\tif (!err)\n\t\terr = fh_update(resfhp);\n\n out:\n\tfh_unlock(fhp);\n\tif (dchild && !IS_ERR(dchild))\n\t\tdput(dchild);\n\tfh_drop_write(fhp);\n \treturn err;\n \n out_nfserr:\n\terr = nfserrno(host_err);\n\tgoto out;\n}",
        "func": "__be32\ndo_nfsd_create(struct svc_rqst *rqstp, struct svc_fh *fhp,\n\t\tchar *fname, int flen, struct iattr *iap,\n\t\tstruct svc_fh *resfhp, int createmode, u32 *verifier,\n\t        bool *truncp, bool *created)\n{\n\tstruct dentry\t*dentry, *dchild = NULL;\n\tstruct inode\t*dirp;\n\t__be32\t\terr;\n\tint\t\thost_err;\n\t__u32\t\tv_mtime=0, v_atime=0;\n\n\terr = nfserr_perm;\n\tif (!flen)\n\t\tgoto out;\n\terr = nfserr_exist;\n\tif (isdotent(fname, flen))\n\t\tgoto out;\n\tif (!(iap->ia_valid & ATTR_MODE))\n\t\tiap->ia_mode = 0;\n\terr = fh_verify(rqstp, fhp, S_IFDIR, NFSD_MAY_EXEC);\n\tif (err)\n\t\tgoto out;\n\n\tdentry = fhp->fh_dentry;\n\tdirp = d_inode(dentry);\n\n\thost_err = fh_want_write(fhp);\n\tif (host_err)\n\t\tgoto out_nfserr;\n\n\tfh_lock_nested(fhp, I_MUTEX_PARENT);\n\n\t/*\n\t * Compose the response file handle.\n\t */\n\tdchild = lookup_one_len(fname, dentry, flen);\n\thost_err = PTR_ERR(dchild);\n\tif (IS_ERR(dchild))\n\t\tgoto out_nfserr;\n\n\t/* If file doesn't exist, check for permissions to create one */\n\tif (d_really_is_negative(dchild)) {\n\t\terr = fh_verify(rqstp, fhp, S_IFDIR, NFSD_MAY_CREATE);\n\t\tif (err)\n\t\t\tgoto out;\n\t}\n\n\terr = fh_compose(resfhp, fhp->fh_export, dchild, fhp);\n\tif (err)\n\t\tgoto out;\n\n\tif (nfsd_create_is_exclusive(createmode)) {\n\t\t/* solaris7 gets confused (bugid 4218508) if these have\n\t\t * the high bit set, so just clear the high bits. If this is\n\t\t * ever changed to use different attrs for storing the\n\t\t * verifier, then do_open_lookup() will also need to be fixed\n\t\t * accordingly.\n\t\t */\n\t\tv_mtime = verifier[0]&0x7fffffff;\n\t\tv_atime = verifier[1]&0x7fffffff;\n\t}\n\t\n\tif (d_really_is_positive(dchild)) {\n\t\terr = 0;\n\n\t\tswitch (createmode) {\n\t\tcase NFS3_CREATE_UNCHECKED:\n\t\t\tif (! d_is_reg(dchild))\n\t\t\t\tgoto out;\n\t\t\telse if (truncp) {\n\t\t\t\t/* in nfsv4, we need to treat this case a little\n\t\t\t\t * differently.  we don't want to truncate the\n\t\t\t\t * file now; this would be wrong if the OPEN\n\t\t\t\t * fails for some other reason.  furthermore,\n\t\t\t\t * if the size is nonzero, we should ignore it\n\t\t\t\t * according to spec!\n\t\t\t\t */\n\t\t\t\t*truncp = (iap->ia_valid & ATTR_SIZE) && !iap->ia_size;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tiap->ia_valid &= ATTR_SIZE;\n\t\t\t\tgoto set_attr;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase NFS3_CREATE_EXCLUSIVE:\n\t\t\tif (   d_inode(dchild)->i_mtime.tv_sec == v_mtime\n\t\t\t    && d_inode(dchild)->i_atime.tv_sec == v_atime\n\t\t\t    && d_inode(dchild)->i_size  == 0 ) {\n\t\t\t\tif (created)\n\t\t\t\t\t*created = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t/* fall through */\n\t\tcase NFS4_CREATE_EXCLUSIVE4_1:\n\t\t\tif (   d_inode(dchild)->i_mtime.tv_sec == v_mtime\n\t\t\t    && d_inode(dchild)->i_atime.tv_sec == v_atime\n\t\t\t    && d_inode(dchild)->i_size  == 0 ) {\n\t\t\t\tif (created)\n\t\t\t\t\t*created = true;\n\t\t\t\tgoto set_attr;\n\t\t\t}\n\t\t\t/* fall through */\n\t\tcase NFS3_CREATE_GUARDED:\n\t\t\terr = nfserr_exist;\n\t\t}\n\t\tfh_drop_write(fhp);\n\t\tgoto out;\n\t}\n\n\tif (!IS_POSIXACL(dirp))\n\t\tiap->ia_mode &= ~current_umask();\n\n\thost_err = vfs_create(dirp, dchild, iap->ia_mode, true);\n\tif (host_err < 0) {\n\t\tfh_drop_write(fhp);\n\t\tgoto out_nfserr;\n\t}\n\tif (created)\n\t\t*created = true;\n\n\tnfsd_check_ignore_resizing(iap);\n\n\tif (nfsd_create_is_exclusive(createmode)) {\n\t\t/* Cram the verifier into atime/mtime */\n\t\tiap->ia_valid = ATTR_MTIME|ATTR_ATIME\n\t\t\t| ATTR_MTIME_SET|ATTR_ATIME_SET;\n\t\t/* XXX someone who knows this better please fix it for nsec */ \n\t\tiap->ia_mtime.tv_sec = v_mtime;\n\t\tiap->ia_atime.tv_sec = v_atime;\n\t\tiap->ia_mtime.tv_nsec = 0;\n\t\tiap->ia_atime.tv_nsec = 0;\n\t}\n\n set_attr:\n\terr = nfsd_create_setattr(rqstp, resfhp, iap);\n\n\t/*\n\t * nfsd_create_setattr already committed the child\n\t * (and possibly also the parent).\n\t */\n\tif (!err)\n\t\terr = nfserrno(commit_metadata(fhp));\n\n\t/*\n\t * Update the filehandle to get the new inode info.\n\t */\n\tif (!err)\n\t\terr = fh_update(resfhp);\n\n out:\n\tfh_unlock(fhp);\n\tif (dchild && !IS_ERR(dchild))\n\t\tdput(dchild);\n\tfh_drop_write(fhp);\n \treturn err;\n \n out_nfserr:\n\terr = nfserrno(host_err);\n\tgoto out;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -108,6 +108,9 @@\n \t\tgoto out;\n \t}\n \n+\tif (!IS_POSIXACL(dirp))\n+\t\tiap->ia_mode &= ~current_umask();\n+\n \thost_err = vfs_create(dirp, dchild, iap->ia_mode, true);\n \tif (host_err < 0) {\n \t\tfh_drop_write(fhp);",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\tif (!IS_POSIXACL(dirp))",
                "\t\tiap->ia_mode &= ~current_umask();",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2020-24394",
        "func_name": "torvalds/linux/nfsd_create_locked",
        "description": "In the Linux kernel before 5.7.8, fs/nfsd/vfs.c (in the NFS server) can set incorrect permissions on new filesystem objects when the filesystem lacks ACL support, aka CID-22cf8419f131. This occurs because the current umask is not considered.",
        "git_url": "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?h=22cf8419f1319ff87ec759d0ebdff4cbafaee832",
        "commit_title": "The server is failing to apply the umask when creating new objects on",
        "commit_text": "filesystems without ACL support.  To reproduce this, you need to use NFSv4.2 and a client and server recent enough to support umask, and you need to export a filesystem that lacks ACL support (for example, ext4 with the \"noacl\" mount option).  Filesystems with ACL support are expected to take care of the umask themselves (usually by calling posix_acl_create).  For filesystems without ACL support, this is up to the caller of vfs_create(), vfs_mknod(), or vfs_mkdir().  Cc: stable@vger.kernel.org ",
        "func_before": "__be32\nnfsd_create_locked(struct svc_rqst *rqstp, struct svc_fh *fhp,\n\t\tchar *fname, int flen, struct iattr *iap,\n\t\tint type, dev_t rdev, struct svc_fh *resfhp)\n{\n\tstruct dentry\t*dentry, *dchild;\n\tstruct inode\t*dirp;\n\t__be32\t\terr;\n\t__be32\t\terr2;\n\tint\t\thost_err;\n\n\tdentry = fhp->fh_dentry;\n\tdirp = d_inode(dentry);\n\n\tdchild = dget(resfhp->fh_dentry);\n\tif (!fhp->fh_locked) {\n\t\tWARN_ONCE(1, \"nfsd_create: parent %pd2 not locked!\\n\",\n\t\t\t\tdentry);\n\t\terr = nfserr_io;\n\t\tgoto out;\n\t}\n\n\terr = nfsd_permission(rqstp, fhp->fh_export, dentry, NFSD_MAY_CREATE);\n\tif (err)\n\t\tgoto out;\n\n\tif (!(iap->ia_valid & ATTR_MODE))\n\t\tiap->ia_mode = 0;\n\tiap->ia_mode = (iap->ia_mode & S_IALLUGO) | type;\n\n\terr = 0;\n\thost_err = 0;\n\tswitch (type) {\n\tcase S_IFREG:\n\t\thost_err = vfs_create(dirp, dchild, iap->ia_mode, true);\n\t\tif (!host_err)\n\t\t\tnfsd_check_ignore_resizing(iap);\n\t\tbreak;\n\tcase S_IFDIR:\n\t\thost_err = vfs_mkdir(dirp, dchild, iap->ia_mode);\n\t\tif (!host_err && unlikely(d_unhashed(dchild))) {\n\t\t\tstruct dentry *d;\n\t\t\td = lookup_one_len(dchild->d_name.name,\n\t\t\t\t\t   dchild->d_parent,\n\t\t\t\t\t   dchild->d_name.len);\n\t\t\tif (IS_ERR(d)) {\n\t\t\t\thost_err = PTR_ERR(d);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (unlikely(d_is_negative(d))) {\n\t\t\t\tdput(d);\n\t\t\t\terr = nfserr_serverfault;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tdput(resfhp->fh_dentry);\n\t\t\tresfhp->fh_dentry = dget(d);\n\t\t\terr = fh_update(resfhp);\n\t\t\tdput(dchild);\n\t\t\tdchild = d;\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\tcase S_IFCHR:\n\tcase S_IFBLK:\n\tcase S_IFIFO:\n\tcase S_IFSOCK:\n\t\thost_err = vfs_mknod(dirp, dchild, iap->ia_mode, rdev);\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_WARNING \"nfsd: bad file type %o in nfsd_create\\n\",\n\t\t       type);\n\t\thost_err = -EINVAL;\n\t}\n\tif (host_err < 0)\n\t\tgoto out_nfserr;\n\n\terr = nfsd_create_setattr(rqstp, resfhp, iap);\n\n\t/*\n\t * nfsd_create_setattr already committed the child.  Transactional\n\t * filesystems had a chance to commit changes for both parent and\n\t * child simultaneously making the following commit_metadata a\n\t * noop.\n\t */\n\terr2 = nfserrno(commit_metadata(fhp));\n\tif (err2)\n\t\terr = err2;\n\t/*\n\t * Update the file handle to get the new inode info.\n\t */\n\tif (!err)\n\t\terr = fh_update(resfhp);\nout:\n\tdput(dchild);\n\treturn err;\n\nout_nfserr:\n\terr = nfserrno(host_err);\n\tgoto out;\n}",
        "func": "__be32\nnfsd_create_locked(struct svc_rqst *rqstp, struct svc_fh *fhp,\n\t\tchar *fname, int flen, struct iattr *iap,\n\t\tint type, dev_t rdev, struct svc_fh *resfhp)\n{\n\tstruct dentry\t*dentry, *dchild;\n\tstruct inode\t*dirp;\n\t__be32\t\terr;\n\t__be32\t\terr2;\n\tint\t\thost_err;\n\n\tdentry = fhp->fh_dentry;\n\tdirp = d_inode(dentry);\n\n\tdchild = dget(resfhp->fh_dentry);\n\tif (!fhp->fh_locked) {\n\t\tWARN_ONCE(1, \"nfsd_create: parent %pd2 not locked!\\n\",\n\t\t\t\tdentry);\n\t\terr = nfserr_io;\n\t\tgoto out;\n\t}\n\n\terr = nfsd_permission(rqstp, fhp->fh_export, dentry, NFSD_MAY_CREATE);\n\tif (err)\n\t\tgoto out;\n\n\tif (!(iap->ia_valid & ATTR_MODE))\n\t\tiap->ia_mode = 0;\n\tiap->ia_mode = (iap->ia_mode & S_IALLUGO) | type;\n\n\tif (!IS_POSIXACL(dirp))\n\t\tiap->ia_mode &= ~current_umask();\n\n\terr = 0;\n\thost_err = 0;\n\tswitch (type) {\n\tcase S_IFREG:\n\t\thost_err = vfs_create(dirp, dchild, iap->ia_mode, true);\n\t\tif (!host_err)\n\t\t\tnfsd_check_ignore_resizing(iap);\n\t\tbreak;\n\tcase S_IFDIR:\n\t\thost_err = vfs_mkdir(dirp, dchild, iap->ia_mode);\n\t\tif (!host_err && unlikely(d_unhashed(dchild))) {\n\t\t\tstruct dentry *d;\n\t\t\td = lookup_one_len(dchild->d_name.name,\n\t\t\t\t\t   dchild->d_parent,\n\t\t\t\t\t   dchild->d_name.len);\n\t\t\tif (IS_ERR(d)) {\n\t\t\t\thost_err = PTR_ERR(d);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (unlikely(d_is_negative(d))) {\n\t\t\t\tdput(d);\n\t\t\t\terr = nfserr_serverfault;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tdput(resfhp->fh_dentry);\n\t\t\tresfhp->fh_dentry = dget(d);\n\t\t\terr = fh_update(resfhp);\n\t\t\tdput(dchild);\n\t\t\tdchild = d;\n\t\t\tif (err)\n\t\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\tcase S_IFCHR:\n\tcase S_IFBLK:\n\tcase S_IFIFO:\n\tcase S_IFSOCK:\n\t\thost_err = vfs_mknod(dirp, dchild, iap->ia_mode, rdev);\n\t\tbreak;\n\tdefault:\n\t\tprintk(KERN_WARNING \"nfsd: bad file type %o in nfsd_create\\n\",\n\t\t       type);\n\t\thost_err = -EINVAL;\n\t}\n\tif (host_err < 0)\n\t\tgoto out_nfserr;\n\n\terr = nfsd_create_setattr(rqstp, resfhp, iap);\n\n\t/*\n\t * nfsd_create_setattr already committed the child.  Transactional\n\t * filesystems had a chance to commit changes for both parent and\n\t * child simultaneously making the following commit_metadata a\n\t * noop.\n\t */\n\terr2 = nfserrno(commit_metadata(fhp));\n\tif (err2)\n\t\terr = err2;\n\t/*\n\t * Update the file handle to get the new inode info.\n\t */\n\tif (!err)\n\t\terr = fh_update(resfhp);\nout:\n\tdput(dchild);\n\treturn err;\n\nout_nfserr:\n\terr = nfserrno(host_err);\n\tgoto out;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -27,6 +27,9 @@\n \tif (!(iap->ia_valid & ATTR_MODE))\n \t\tiap->ia_mode = 0;\n \tiap->ia_mode = (iap->ia_mode & S_IALLUGO) | type;\n+\n+\tif (!IS_POSIXACL(dirp))\n+\t\tiap->ia_mode &= ~current_umask();\n \n \terr = 0;\n \thost_err = 0;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "\tif (!IS_POSIXACL(dirp))",
                "\t\tiap->ia_mode &= ~current_umask();"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-48257",
        "func_name": "MisterTea/EternalTerminal/main",
        "description": "In Eternal Terminal 6.2.1, etserver and etclient have predictable logfile names in /tmp.",
        "git_url": "https://github.com/MisterTea/EternalTerminal/commit/4a8b02d5f1afb38b00c77ab1321d5f56720f4e30",
        "commit_title": "Unify logfile names and create with more secure open options and perms.",
        "commit_text": " Fixes #555 (Tribute to Colin McRae)",
        "func_before": "int main(int argc, char** argv) {\n  // Setup easylogging configurations\n  el::Configurations defaultConf = LogHandler::setupLogHandler(&argc, &argv);\n  LogHandler::setupStdoutLogger();\n\n  et::HandleTerminate();\n\n  // Override easylogging handler for sigint\n  ::signal(SIGINT, et::InterruptSignalHandler);\n\n  // Parse command line arguments\n  cxxopts::Options options(\"etterminal\", \"User terminal for Eternal Terminal.\");\n\n  try {\n    options.allow_unrecognised_options();\n\n    options.add_options()         //\n        (\"h,help\", \"Print help\")  //\n        (\"idpasskey\",\n         \"If set, uses IPC to send a client id/key to the server daemon. \"\n         \"Alternatively, pass in via stdin.\",\n         cxxopts::value<std::string>()->default_value(\"\"))  //\n        (\"idpasskeyfile\",\n         \"If set, uses IPC to send a client id/key to the server daemon from a \"\n         \"file. Alternatively, pass in via stdin.\",\n         cxxopts::value<std::string>()->default_value(\"\"))  //\n        (\"jump\",\n         \"If set, forward all packets between client and dst terminal\")  //\n        (\"dsthost\", \"Must be set if jump is set to true\",\n         cxxopts::value<std::string>()->default_value(\"\"))  //\n        (\"dstport\", \"Must be set if jump is set to true\",\n         cxxopts::value<int>()->default_value(\"2022\"))  //\n        // Not used by etterminal but easylogging uses this flag under the hood\n        (\"v,verbose\", \"Enable verbose logging\",\n         cxxopts::value<int>()->default_value(\"0\"))  //\n        (\"logtostdout\", \"Write log to stdout\")       //\n        (\"serverfifo\",\n         \"If set, connects to the etserver instance listening on the matching \"\n         \"fifo name\",                                       //\n         cxxopts::value<std::string>()->default_value(\"\"))  //\n        ;\n\n    auto result = options.parse(argc, argv);\n    if (result.count(\"help\")) {\n      CLOG(INFO, \"stdout\") << options.help({}) << endl;\n      exit(0);\n    }\n\n    el::Loggers::setVerboseLevel(result[\"verbose\"].as<int>());\n\n    if (result.count(\"logtostdout\")) {\n      defaultConf.setGlobally(el::ConfigurationType::ToStandardOutput, \"true\");\n    } else {\n      defaultConf.setGlobally(el::ConfigurationType::ToStandardOutput, \"false\");\n    }\n\n    // default max log file size is 20MB for etserver\n    string maxlogsize = \"20971520\";\n\n    GOOGLE_PROTOBUF_VERIFY_VERSION;\n    srand(1);\n\n    ServerFifoPath serverFifo;\n    if (!result[\"serverfifo\"].as<string>().empty()) {\n      serverFifo.setPathOverride(result[\"serverfifo\"].as<string>());\n    }\n\n    shared_ptr<SocketHandler> ipcSocketHandler(new PipeSocketHandler());\n    shared_ptr<PsuedoUserTerminal> term(new PsuedoUserTerminal());\n\n    string idpasskey;\n    if (result.count(\"idpasskey\") == 0 && result.count(\"idpasskeyfile\") == 0) {\n      // Try to read from stdin\n      struct timeval timeout;\n      timeout.tv_sec = 1;\n      timeout.tv_usec = 0;\n      fd_set readfds;\n      FD_ZERO(&readfds);\n\n      FD_SET(STDIN_FILENO, &readfds);\n\n      int selectResult = 0;\n      do {\n        // Repeatedly calls when interrupted, up to the timeout.\n        selectResult = select(1, &readfds, NULL, NULL, &timeout);\n      } while (selectResult < 0 && errno == EINTR);\n\n      FATAL_FAIL(selectResult);\n      if (selectResult == 0) {\n        CLOG(INFO, \"stdout\")\n            << \"Call etterminal with --idpasskey or --idpasskeyfile, or feed \"\n               \"this information on stdin\\n\";\n        exit(1);\n      }\n\n      string stdinData;\n      if (!getline(cin, stdinData)) {\n        CLOG(INFO, \"stdout\")\n            << \"Call etterminal with --idpasskey or --idpasskeyfile, or feed \"\n               \"this information on stdin\\n\";\n        exit(1);\n      }\n      auto tokens = split(stdinData, '_');\n      if (tokens.size() == 2) {\n        idpasskey = tokens[0];\n        if (idpasskey.substr(0, 3) == std::string(\"XXX\")) {\n          // New client connecting to new server, throw away passkey and\n          // regenerate\n          string passkey = genRandomAlphaNum(32);\n          string id = genRandomAlphaNum(16);\n          idpasskey = id + string(\"/\") + passkey;\n        }\n\n        FATAL_FAIL(setenv(\"TERM\", tokens[1].c_str(), 1));\n      } else {\n        STFATAL << \"Invalid number of tokens: \" << tokens.size();\n      }\n    } else {\n      string idpasskey = result[\"idpasskey\"].as<string>();\n      if (result.count(\"idpasskeyfile\")) {\n        // Check for passkey file\n        std::ifstream t(result[\"idpasskeyfile\"].as<string>().c_str());\n        std::stringstream buffer;\n        buffer << t.rdbuf();\n        idpasskey = buffer.str();\n        // Trim whitespace\n        idpasskey.erase(idpasskey.find_last_not_of(\" \\n\\r\\t\") + 1);\n      }\n    }\n\n    string id = split(idpasskey, '/')[0];\n    string username = string(ssh_get_local_username());\n    if (result.count(\"jump\")) {\n      // etserver with --jump cannot write to the default log file(root)\n      LogHandler::setupLogFile(\n          &defaultConf,\n          GetTempDirectory() + \"etjump-\" + username + \"-\" + id + \".log\",\n          maxlogsize);\n      // Reconfigure default logger to apply settings above\n      el::Loggers::reconfigureLogger(\"default\", defaultConf);\n      // set thread name\n      el::Helpers::setThreadName(\"jump-main\");\n      // Install log rotation callback\n      el::Helpers::installPreRollOutCallback(LogHandler::rolloutHandler);\n\n      CLOG(INFO, \"stdout\") << \"IDPASSKEY:\" << idpasskey << endl;\n      if (DaemonCreator::createSessionLeader() == -1) {\n        STFATAL << \"Error creating daemon: \" << strerror(GetErrno());\n      }\n      SocketEndpoint destinationEndpoint;\n      destinationEndpoint.set_name(result[\"dsthost\"].as<string>());\n      destinationEndpoint.set_port(result[\"dstport\"].as<int>());\n      shared_ptr<SocketHandler> jumpClientSocketHandler(new TcpSocketHandler());\n      UserJumphostHandler ujh(jumpClientSocketHandler, idpasskey,\n                              destinationEndpoint, ipcSocketHandler,\n                              serverFifo.getEndpointForConnect());\n      ujh.run();\n\n      // Uninstall log rotation callback\n      el::Helpers::uninstallPreRollOutCallback();\n      return 0;\n    }\n\n    // etserver with --idpasskey cannot write to the default log file(root)\n    LogHandler::setupLogFile(\n        &defaultConf,\n        GetTempDirectory() + \"etterminal-\" + username + \"-\" + id + \".log\",\n        maxlogsize);\n    // Reconfigure default logger to apply settings above\n    el::Loggers::reconfigureLogger(\"default\", defaultConf);\n    // set thread name\n    el::Helpers::setThreadName(\"terminal-main\");\n    // Install log rotation callback\n    el::Helpers::installPreRollOutCallback(LogHandler::rolloutHandler);\n\n    UserTerminalHandler uth(ipcSocketHandler, term, true,\n                            serverFifo.getEndpointForConnect(), idpasskey);\n    CLOG(INFO, \"stdout\") << \"IDPASSKEY:\" << idpasskey << endl;\n    if (DaemonCreator::createSessionLeader() == -1) {\n      STFATAL << \"Error creating daemon: \" << strerror(GetErrno());\n    }\n    uth.run();\n\n  } catch (cxxopts::OptionException& oe) {\n    CLOG(INFO, \"stdout\") << \"Exception: \" << oe.what() << \"\\n\" << endl;\n    CLOG(INFO, \"stdout\") << options.help({}) << endl;\n    exit(1);\n  }\n\n  // Uninstall log rotation callback\n  el::Helpers::uninstallPreRollOutCallback();\n  return 0;\n}",
        "func": "int main(int argc, char** argv) {\n  // Setup easylogging configurations\n  el::Configurations defaultConf = LogHandler::setupLogHandler(&argc, &argv);\n  LogHandler::setupStdoutLogger();\n\n  et::HandleTerminate();\n\n  // Override easylogging handler for sigint\n  ::signal(SIGINT, et::InterruptSignalHandler);\n\n  // Parse command line arguments\n  cxxopts::Options options(\"etterminal\", \"User terminal for Eternal Terminal.\");\n\n  try {\n    options.allow_unrecognised_options();\n\n    options.add_options()         //\n        (\"h,help\", \"Print help\")  //\n        (\"idpasskey\",\n         \"If set, uses IPC to send a client id/key to the server daemon. \"\n         \"Alternatively, pass in via stdin.\",\n         cxxopts::value<std::string>()->default_value(\"\"))  //\n        (\"idpasskeyfile\",\n         \"If set, uses IPC to send a client id/key to the server daemon from a \"\n         \"file. Alternatively, pass in via stdin.\",\n         cxxopts::value<std::string>()->default_value(\"\"))  //\n        (\"jump\",\n         \"If set, forward all packets between client and dst terminal\")  //\n        (\"dsthost\", \"Must be set if jump is set to true\",\n         cxxopts::value<std::string>()->default_value(\"\"))  //\n        (\"dstport\", \"Must be set if jump is set to true\",\n         cxxopts::value<int>()->default_value(\"2022\"))  //\n        // Not used by etterminal but easylogging uses this flag under the hood\n        (\"v,verbose\", \"Enable verbose logging\",\n         cxxopts::value<int>()->default_value(\"0\"))  //\n        (\"logtostdout\", \"Write log to stdout\")       //\n        (\"serverfifo\",\n         \"If set, connects to the etserver instance listening on the matching \"\n         \"fifo name\",                                       //\n         cxxopts::value<std::string>()->default_value(\"\"))  //\n        ;\n\n    auto result = options.parse(argc, argv);\n    if (result.count(\"help\")) {\n      CLOG(INFO, \"stdout\") << options.help({}) << endl;\n      exit(0);\n    }\n\n    el::Loggers::setVerboseLevel(result[\"verbose\"].as<int>());\n\n    GOOGLE_PROTOBUF_VERIFY_VERSION;\n    srand(1);\n\n    ServerFifoPath serverFifo;\n    if (!result[\"serverfifo\"].as<string>().empty()) {\n      serverFifo.setPathOverride(result[\"serverfifo\"].as<string>());\n    }\n\n    shared_ptr<SocketHandler> ipcSocketHandler(new PipeSocketHandler());\n    shared_ptr<PsuedoUserTerminal> term(new PsuedoUserTerminal());\n\n    string idpasskey;\n    if (result.count(\"idpasskey\") == 0 && result.count(\"idpasskeyfile\") == 0) {\n      // Try to read from stdin\n      struct timeval timeout;\n      timeout.tv_sec = 1;\n      timeout.tv_usec = 0;\n      fd_set readfds;\n      FD_ZERO(&readfds);\n\n      FD_SET(STDIN_FILENO, &readfds);\n\n      int selectResult = 0;\n      do {\n        // Repeatedly calls when interrupted, up to the timeout.\n        selectResult = select(1, &readfds, NULL, NULL, &timeout);\n      } while (selectResult < 0 && errno == EINTR);\n\n      FATAL_FAIL(selectResult);\n      if (selectResult == 0) {\n        CLOG(INFO, \"stdout\")\n            << \"Call etterminal with --idpasskey or --idpasskeyfile, or feed \"\n               \"this information on stdin\\n\";\n        exit(1);\n      }\n\n      string stdinData;\n      if (!getline(cin, stdinData)) {\n        CLOG(INFO, \"stdout\")\n            << \"Call etterminal with --idpasskey or --idpasskeyfile, or feed \"\n               \"this information on stdin\\n\";\n        exit(1);\n      }\n      auto tokens = split(stdinData, '_');\n      if (tokens.size() == 2) {\n        idpasskey = tokens[0];\n        if (idpasskey.substr(0, 3) == std::string(\"XXX\")) {\n          // New client connecting to new server, throw away passkey and\n          // regenerate\n          string passkey = genRandomAlphaNum(32);\n          string id = genRandomAlphaNum(16);\n          idpasskey = id + string(\"/\") + passkey;\n        }\n\n        FATAL_FAIL(setenv(\"TERM\", tokens[1].c_str(), 1));\n      } else {\n        STFATAL << \"Invalid number of tokens: \" << tokens.size();\n      }\n    } else {\n      string idpasskey = result[\"idpasskey\"].as<string>();\n      if (result.count(\"idpasskeyfile\")) {\n        // Check for passkey file\n        std::ifstream t(result[\"idpasskeyfile\"].as<string>().c_str());\n        std::stringstream buffer;\n        buffer << t.rdbuf();\n        idpasskey = buffer.str();\n        // Trim whitespace\n        idpasskey.erase(idpasskey.find_last_not_of(\" \\n\\r\\t\") + 1);\n      }\n    }\n\n    string id = split(idpasskey, '/')[0];\n    string username = string(ssh_get_local_username());\n    if (result.count(\"jump\")) {\n      // etserver with --jump cannot write to the default log file(root)\n      LogHandler::setupLogFiles(&defaultConf, GetTempDirectory(),\n                                (\"etjump-\" + username + \"-\" + id),\n                                result.count(\"logtostdout\"), false);\n      // Reconfigure default logger to apply settings above\n      el::Loggers::reconfigureLogger(\"default\", defaultConf);\n      // set thread name\n      el::Helpers::setThreadName(\"jump-main\");\n      // Install log rotation callback\n      el::Helpers::installPreRollOutCallback(LogHandler::rolloutHandler);\n\n      CLOG(INFO, \"stdout\") << \"IDPASSKEY:\" << idpasskey << endl;\n      if (DaemonCreator::createSessionLeader() == -1) {\n        STFATAL << \"Error creating daemon: \" << strerror(GetErrno());\n      }\n      SocketEndpoint destinationEndpoint;\n      destinationEndpoint.set_name(result[\"dsthost\"].as<string>());\n      destinationEndpoint.set_port(result[\"dstport\"].as<int>());\n      shared_ptr<SocketHandler> jumpClientSocketHandler(new TcpSocketHandler());\n      UserJumphostHandler ujh(jumpClientSocketHandler, idpasskey,\n                              destinationEndpoint, ipcSocketHandler,\n                              serverFifo.getEndpointForConnect());\n      ujh.run();\n\n      // Uninstall log rotation callback\n      el::Helpers::uninstallPreRollOutCallback();\n      return 0;\n    }\n\n    // etserver with --idpasskey cannot write to the default log file(root)\n    LogHandler::setupLogFiles(&defaultConf, GetTempDirectory(),\n                              (\"etterminal-\" + username + \"-\" + id),\n                              result.count(\"logtostdout\"), false);\n\n    // Reconfigure default logger to apply settings above\n    el::Loggers::reconfigureLogger(\"default\", defaultConf);\n    // set thread name\n    el::Helpers::setThreadName(\"terminal-main\");\n    // Install log rotation callback\n    el::Helpers::installPreRollOutCallback(LogHandler::rolloutHandler);\n\n    UserTerminalHandler uth(ipcSocketHandler, term, true,\n                            serverFifo.getEndpointForConnect(), idpasskey);\n    CLOG(INFO, \"stdout\") << \"IDPASSKEY:\" << idpasskey << endl;\n    if (DaemonCreator::createSessionLeader() == -1) {\n      STFATAL << \"Error creating daemon: \" << strerror(GetErrno());\n    }\n    uth.run();\n\n  } catch (cxxopts::OptionException& oe) {\n    CLOG(INFO, \"stdout\") << \"Exception: \" << oe.what() << \"\\n\" << endl;\n    CLOG(INFO, \"stdout\") << options.help({}) << endl;\n    exit(1);\n  }\n\n  // Uninstall log rotation callback\n  el::Helpers::uninstallPreRollOutCallback();\n  return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -47,15 +47,6 @@\n     }\n \n     el::Loggers::setVerboseLevel(result[\"verbose\"].as<int>());\n-\n-    if (result.count(\"logtostdout\")) {\n-      defaultConf.setGlobally(el::ConfigurationType::ToStandardOutput, \"true\");\n-    } else {\n-      defaultConf.setGlobally(el::ConfigurationType::ToStandardOutput, \"false\");\n-    }\n-\n-    // default max log file size is 20MB for etserver\n-    string maxlogsize = \"20971520\";\n \n     GOOGLE_PROTOBUF_VERIFY_VERSION;\n     srand(1);\n@@ -132,10 +123,9 @@\n     string username = string(ssh_get_local_username());\n     if (result.count(\"jump\")) {\n       // etserver with --jump cannot write to the default log file(root)\n-      LogHandler::setupLogFile(\n-          &defaultConf,\n-          GetTempDirectory() + \"etjump-\" + username + \"-\" + id + \".log\",\n-          maxlogsize);\n+      LogHandler::setupLogFiles(&defaultConf, GetTempDirectory(),\n+                                (\"etjump-\" + username + \"-\" + id),\n+                                result.count(\"logtostdout\"), false);\n       // Reconfigure default logger to apply settings above\n       el::Loggers::reconfigureLogger(\"default\", defaultConf);\n       // set thread name\n@@ -162,10 +152,10 @@\n     }\n \n     // etserver with --idpasskey cannot write to the default log file(root)\n-    LogHandler::setupLogFile(\n-        &defaultConf,\n-        GetTempDirectory() + \"etterminal-\" + username + \"-\" + id + \".log\",\n-        maxlogsize);\n+    LogHandler::setupLogFiles(&defaultConf, GetTempDirectory(),\n+                              (\"etterminal-\" + username + \"-\" + id),\n+                              result.count(\"logtostdout\"), false);\n+\n     // Reconfigure default logger to apply settings above\n     el::Loggers::reconfigureLogger(\"default\", defaultConf);\n     // set thread name",
        "diff_line_info": {
            "deleted_lines": [
                "",
                "    if (result.count(\"logtostdout\")) {",
                "      defaultConf.setGlobally(el::ConfigurationType::ToStandardOutput, \"true\");",
                "    } else {",
                "      defaultConf.setGlobally(el::ConfigurationType::ToStandardOutput, \"false\");",
                "    }",
                "",
                "    // default max log file size is 20MB for etserver",
                "    string maxlogsize = \"20971520\";",
                "      LogHandler::setupLogFile(",
                "          &defaultConf,",
                "          GetTempDirectory() + \"etjump-\" + username + \"-\" + id + \".log\",",
                "          maxlogsize);",
                "    LogHandler::setupLogFile(",
                "        &defaultConf,",
                "        GetTempDirectory() + \"etterminal-\" + username + \"-\" + id + \".log\",",
                "        maxlogsize);"
            ],
            "added_lines": [
                "      LogHandler::setupLogFiles(&defaultConf, GetTempDirectory(),",
                "                                (\"etjump-\" + username + \"-\" + id),",
                "                                result.count(\"logtostdout\"), false);",
                "    LogHandler::setupLogFiles(&defaultConf, GetTempDirectory(),",
                "                              (\"etterminal-\" + username + \"-\" + id),",
                "                              result.count(\"logtostdout\"), false);",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2022-48257",
        "func_name": "MisterTea/EternalTerminal/main",
        "description": "In Eternal Terminal 6.2.1, etserver and etclient have predictable logfile names in /tmp.",
        "git_url": "https://github.com/MisterTea/EternalTerminal/commit/4a8b02d5f1afb38b00c77ab1321d5f56720f4e30",
        "commit_title": "Unify logfile names and create with more secure open options and perms.",
        "commit_text": " Fixes #555 (Tribute to Colin McRae)",
        "func_before": "int main(int argc, char** argv) {\n  GOOGLE_PROTOBUF_VERIFY_VERSION;\n  srand(1);\n  // Parse command line arguments\n  cxxopts::Options options(\"htm\", \"Headless terminal multiplexer\");\n  options.allow_unrecognised_options();\n\n  options.add_options()       //\n      (\"help\", \"Print help\")  //\n      (\"x,kill-other-sessions\",\n       \"kill all old sessions belonging to the user\")  //\n      ;\n\n  auto result = options.parse(argc, argv);\n  if (result.count(\"help\")) {\n    CLOG(INFO, \"stdout\") << options.help({}) << endl;\n    exit(0);\n  }\n\n  setvbuf(stdin, NULL, _IONBF, 0);   // turn off buffering\n  setvbuf(stdout, NULL, _IONBF, 0);  // turn off buffering\n\n  // Turn on raw terminal mode\n  termios terminal_local;\n  tcgetattr(0, &terminal_local);\n  memcpy(&terminal_backup, &terminal_local, sizeof(struct termios));\n  cfmakeraw(&terminal_local);\n  tcsetattr(0, TCSANOW, &terminal_local);\n\n  // Catch sigterm and send exit control code\n  struct sigaction action;\n  memset(&action, 0, sizeof(struct sigaction));\n  action.sa_handler = term;\n  sigaction(SIGTERM, &action, NULL);\n\n  // Setup easylogging configurations\n  el::Configurations defaultConf = LogHandler::setupLogHandler(&argc, &argv);\n  defaultConf.setGlobally(el::ConfigurationType::ToStandardOutput, \"false\");\n  el::Loggers::setVerboseLevel(3);\n  // default max log file size is 20MB for etserver\n  string maxlogsize = \"20971520\";\n  LogHandler::setupLogFile(&defaultConf, GetTempDirectory() + \"htm.log\",\n                           maxlogsize);\n  // Redirect std streams to a file\n  LogHandler::stderrToFile(GetTempDirectory() + \"htm\");\n\n  // Reconfigure default logger to apply settings above\n  el::Loggers::reconfigureLogger(\"default\", defaultConf);\n\n  et::HandleTerminate();\n\n  // Override easylogging handler for sigint\n  ::signal(SIGINT, et::InterruptSignalHandler);\n\n  uid_t myuid = getuid();\n  if (result.count(\"x\")) {\n    LOG(INFO) << \"Killing previous htmd\";\n    // Kill previous htm daemon\n    string command =\n        string(\"pkill -x -U \") + to_string(myuid) + string(\" htmd\");\n    system(command.c_str());\n  }\n\n  // Check if daemon exists\n  string command = string(\"pgrep -x -U \") + to_string(myuid) + string(\" htmd\");\n  string pgrepOutput = SystemToStr(command.c_str());\n\n  if (pgrepOutput.length() == 0) {\n    // Fork to create the daemon\n    int result = DaemonCreator::create(false, \"\");\n    if (result == DaemonCreator::CHILD) {\n      // This means we are the daemon\n      exit(system(\"htmd\"));\n    }\n  }\n\n  // This means we are the client to the daemon\n  std::this_thread::sleep_for(std::chrono::microseconds(\n      10 * 1000));  // Sleep for 10ms to let the daemon come alive\n  shared_ptr<SocketHandler> socketHandler(new PipeSocketHandler());\n  SocketEndpoint pipeEndpoint;\n  pipeEndpoint.set_name(HtmServer::getPipeName());\n  HtmClient htmClient(socketHandler, pipeEndpoint);\n  htmClient.run();\n\n  char buf[] = {\n      0x1b, 0x5b, '$', '$', '$', 'q',\n  };\n  RawSocketUtils::writeAll(STDOUT_FILENO, buf, sizeof(buf));\n  fflush(stdout);\n  tcsetattr(0, TCSANOW, &terminal_backup);\n\n  return 0;\n}",
        "func": "int main(int argc, char** argv) {\n  GOOGLE_PROTOBUF_VERIFY_VERSION;\n  srand(1);\n  // Parse command line arguments\n  cxxopts::Options options(\"htm\", \"Headless terminal multiplexer\");\n  options.allow_unrecognised_options();\n\n  options.add_options()       //\n      (\"help\", \"Print help\")  //\n      (\"x,kill-other-sessions\",\n       \"kill all old sessions belonging to the user\")  //\n      ;\n\n  auto result = options.parse(argc, argv);\n  if (result.count(\"help\")) {\n    CLOG(INFO, \"stdout\") << options.help({}) << endl;\n    exit(0);\n  }\n\n  setvbuf(stdin, NULL, _IONBF, 0);   // turn off buffering\n  setvbuf(stdout, NULL, _IONBF, 0);  // turn off buffering\n\n  // Turn on raw terminal mode\n  termios terminal_local;\n  tcgetattr(0, &terminal_local);\n  memcpy(&terminal_backup, &terminal_local, sizeof(struct termios));\n  cfmakeraw(&terminal_local);\n  tcsetattr(0, TCSANOW, &terminal_local);\n\n  // Catch sigterm and send exit control code\n  struct sigaction action;\n  memset(&action, 0, sizeof(struct sigaction));\n  action.sa_handler = term;\n  sigaction(SIGTERM, &action, NULL);\n\n  // Setup easylogging configurations\n  el::Configurations defaultConf = LogHandler::setupLogHandler(&argc, &argv);\n  el::Loggers::setVerboseLevel(3);\n  LogHandler::setupLogFiles(&defaultConf, GetTempDirectory(), \"htm\", false,\n                            true);\n\n  // Reconfigure default logger to apply settings above\n  el::Loggers::reconfigureLogger(\"default\", defaultConf);\n\n  et::HandleTerminate();\n\n  // Override easylogging handler for sigint\n  ::signal(SIGINT, et::InterruptSignalHandler);\n\n  uid_t myuid = getuid();\n  if (result.count(\"x\")) {\n    LOG(INFO) << \"Killing previous htmd\";\n    // Kill previous htm daemon\n    string command =\n        string(\"pkill -x -U \") + to_string(myuid) + string(\" htmd\");\n    system(command.c_str());\n  }\n\n  // Check if daemon exists\n  string command = string(\"pgrep -x -U \") + to_string(myuid) + string(\" htmd\");\n  string pgrepOutput = SystemToStr(command.c_str());\n\n  if (pgrepOutput.length() == 0) {\n    // Fork to create the daemon\n    int result = DaemonCreator::create(false, \"\");\n    if (result == DaemonCreator::CHILD) {\n      // This means we are the daemon\n      exit(system(\"htmd\"));\n    }\n  }\n\n  // This means we are the client to the daemon\n  std::this_thread::sleep_for(std::chrono::microseconds(\n      10 * 1000));  // Sleep for 10ms to let the daemon come alive\n  shared_ptr<SocketHandler> socketHandler(new PipeSocketHandler());\n  SocketEndpoint pipeEndpoint;\n  pipeEndpoint.set_name(HtmServer::getPipeName());\n  HtmClient htmClient(socketHandler, pipeEndpoint);\n  htmClient.run();\n\n  char buf[] = {\n      0x1b, 0x5b, '$', '$', '$', 'q',\n  };\n  RawSocketUtils::writeAll(STDOUT_FILENO, buf, sizeof(buf));\n  fflush(stdout);\n  tcsetattr(0, TCSANOW, &terminal_backup);\n\n  return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -35,14 +35,9 @@\n \n   // Setup easylogging configurations\n   el::Configurations defaultConf = LogHandler::setupLogHandler(&argc, &argv);\n-  defaultConf.setGlobally(el::ConfigurationType::ToStandardOutput, \"false\");\n   el::Loggers::setVerboseLevel(3);\n-  // default max log file size is 20MB for etserver\n-  string maxlogsize = \"20971520\";\n-  LogHandler::setupLogFile(&defaultConf, GetTempDirectory() + \"htm.log\",\n-                           maxlogsize);\n-  // Redirect std streams to a file\n-  LogHandler::stderrToFile(GetTempDirectory() + \"htm\");\n+  LogHandler::setupLogFiles(&defaultConf, GetTempDirectory(), \"htm\", false,\n+                            true);\n \n   // Reconfigure default logger to apply settings above\n   el::Loggers::reconfigureLogger(\"default\", defaultConf);",
        "diff_line_info": {
            "deleted_lines": [
                "  defaultConf.setGlobally(el::ConfigurationType::ToStandardOutput, \"false\");",
                "  // default max log file size is 20MB for etserver",
                "  string maxlogsize = \"20971520\";",
                "  LogHandler::setupLogFile(&defaultConf, GetTempDirectory() + \"htm.log\",",
                "                           maxlogsize);",
                "  // Redirect std streams to a file",
                "  LogHandler::stderrToFile(GetTempDirectory() + \"htm\");"
            ],
            "added_lines": [
                "  LogHandler::setupLogFiles(&defaultConf, GetTempDirectory(), \"htm\", false,",
                "                            true);"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-48257",
        "func_name": "MisterTea/EternalTerminal/main",
        "description": "In Eternal Terminal 6.2.1, etserver and etclient have predictable logfile names in /tmp.",
        "git_url": "https://github.com/MisterTea/EternalTerminal/commit/4a8b02d5f1afb38b00c77ab1321d5f56720f4e30",
        "commit_title": "Unify logfile names and create with more secure open options and perms.",
        "commit_text": " Fixes #555 (Tribute to Colin McRae)",
        "func_before": "int main(int argc, char **argv) {\n  // Setup easylogging configurations\n  el::Configurations defaultConf = LogHandler::setupLogHandler(&argc, &argv);\n  LogHandler::setupStdoutLogger();\n\n  et::HandleTerminate();\n\n  // Override easylogging handler for sigint\n  ::signal(SIGINT, et::InterruptSignalHandler);\n\n  cxxopts::Options options(\"etserver\",\n                           \"Remote shell for the busy and impatient\");\n  try {\n    // Parse command line arguments\n    options.allow_unrecognised_options();\n\n    options.add_options()             //\n        (\"h,help\", \"Print help\")      //\n        (\"version\", \"Print version\")  //\n        (\"port\", \"Port to listen on\",\n         cxxopts::value<int>()->default_value(\"0\"))  //\n        (\"bindip\", \"IP to listen on\",\n         cxxopts::value<string>()->default_value(\"\"))  //\n        (\"daemon\", \"Daemonize the server\")             //\n        (\"cfgfile\", \"Location of the config file\",\n         cxxopts::value<std::string>()->default_value(\"\"))  //\n        (\"logtostdout\", \"log to stdout\")                    //\n        (\"pidfile\", \"Location of the pid file\",\n         cxxopts::value<std::string>()->default_value(\n             \"/var/run/etserver.pid\"))  //\n        (\"v,verbose\", \"Enable verbose logging\",\n         cxxopts::value<int>()->default_value(\"0\"), \"LEVEL\")  //\n        (\"serverfifo\",\n         \"If set, listens on the matching fifo name\",       //\n         cxxopts::value<std::string>()->default_value(\"\"))  //\n        (\"telemetry\",\n         \"Allow et to anonymously send errors to guide future improvements\",\n         cxxopts::value<bool>())  //\n        ;\n\n    auto result = options.parse(argc, argv);\n\n    if (result.count(\"help\")) {\n      CLOG(INFO, \"stdout\") << options.help({}) << endl;\n      exit(0);\n    }\n    if (result.count(\"version\")) {\n      CLOG(INFO, \"stdout\") << \"et version \" << ET_VERSION << endl;\n      exit(0);\n    }\n\n    el::Loggers::setVerboseLevel(result[\"verbose\"].as<int>());\n\n    if (result.count(\"daemon\")) {\n      if (DaemonCreator::create(true, result[\"pidfile\"].as<string>()) == -1) {\n        STFATAL << \"Error creating daemon: \" << strerror(GetErrno());\n      }\n    }\n\n    if (result.count(\"logtostdout\")) {\n      defaultConf.setGlobally(el::ConfigurationType::ToStandardOutput, \"true\");\n    } else {\n      defaultConf.setGlobally(el::ConfigurationType::ToStandardOutput, \"false\");\n      // Redirect std streams to a file\n      LogHandler::stderrToFile(GetTempDirectory() + \"etserver\");\n    }\n\n    ServerFifoPath serverFifo;\n\n    // default max log file size is 20MB for etserver\n    string maxlogsize = \"20971520\";\n\n    int port = 0;\n    string bindIp = \"\";\n    bool telemetry = false;\n    if (result.count(\"cfgfile\")) {\n      // Load the config file\n      CSimpleIniA ini(true, false, false);\n      string cfgfilename = result[\"cfgfile\"].as<string>();\n      SI_Error rc = ini.LoadFile(cfgfilename.c_str());\n      if (rc == 0) {\n        if (!result.count(\"port\")) {\n          const char *portString = ini.GetValue(\"Networking\", \"port\", NULL);\n          if (portString) {\n            port = stoi(portString);\n          }\n        }\n\n        if (!result.count(\"bindip\")) {\n          const char *bindIpPtr = ini.GetValue(\"Networking\", \"bind_ip\", NULL);\n          if (bindIpPtr) {\n            bindIp = string(bindIpPtr);\n          }\n        }\n\n        telemetry = ini.GetBoolValue(\"Debug\", \"telemetry\", false);\n        // read verbose level (prioritize command line option over cfgfile)\n        const char *vlevel = ini.GetValue(\"Debug\", \"verbose\", NULL);\n        if (result.count(\"verbose\")) {\n          el::Loggers::setVerboseLevel(result[\"verbose\"].as<int>());\n        } else if (vlevel) {\n          el::Loggers::setVerboseLevel(atoi(vlevel));\n        }\n\n        const char *fifoName = ini.GetValue(\"Debug\", \"serverfifo\", NULL);\n        if (fifoName) {\n          const string fifoNameStr(fifoName);\n          if (!fifoNameStr.empty()) {\n            serverFifo.setPathOverride(fifoNameStr);\n          }\n        }\n\n        // read silent setting\n        const char *silent = ini.GetValue(\"Debug\", \"silent\", NULL);\n        if (silent && atoi(silent) != 0) {\n          defaultConf.setGlobally(el::ConfigurationType::Enabled, \"false\");\n        }\n        // read log file size limit\n        const char *logsize = ini.GetValue(\"Debug\", \"logsize\", NULL);\n        if (logsize && atoi(logsize) != 0) {\n          // make sure maxlogsize is a string of int value\n          maxlogsize = string(logsize);\n        }\n\n      } else {\n        STFATAL << \"Invalid config file: \" << cfgfilename;\n      }\n    }\n\n    if (result.count(\"serverfifo\") &&\n        !result[\"serverfifo\"].as<string>().empty()) {\n      serverFifo.setPathOverride(result[\"serverfifo\"].as<string>());\n    }\n\n    if (result.count(\"port\")) {\n      port = result[\"port\"].as<int>();\n    }\n\n    if (result.count(\"bindip\")) {\n      bindIp = result[\"bindip\"].as<string>();\n    }\n\n    if (result.count(\"telemetry\")) {\n      telemetry = result[\"telemetry\"].as<bool>();\n    }\n\n    GOOGLE_PROTOBUF_VERIFY_VERSION;\n    srand(1);\n\n    if (port == 0) {\n      port = 2022;\n    }\n\n    // Set log file for etserver process here.\n    LogHandler::setupLogFile(&defaultConf,\n                             GetTempDirectory() + \"etserver-%datetime.log\",\n                             maxlogsize);\n    // Reconfigure default logger to apply settings above\n    el::Loggers::reconfigureLogger(\"default\", defaultConf);\n    // set thread name\n    el::Helpers::setThreadName(\"etserver-main\");\n    // Install log rotation callback\n    el::Helpers::installPreRollOutCallback(LogHandler::rolloutHandler);\n\n    TelemetryService::create(\n        telemetry, GetTempDirectory() + \"/.sentry-native-etserver\", \"Server\");\n\n    serverFifo.createDirectoriesIfRequired();\n\n    std::shared_ptr<SocketHandler> tcpSocketHandler(new TcpSocketHandler());\n    std::shared_ptr<PipeSocketHandler> pipeSocketHandler(\n        new PipeSocketHandler());\n\n    LOG(INFO) << \"In child, about to start server.\";\n\n    SocketEndpoint serverEndpoint;\n    serverEndpoint.set_port(port);\n    if (bindIp.length()) {\n      serverEndpoint.set_name(bindIp);\n    }\n    SocketEndpoint routerFifo;\n    routerFifo.set_name(serverFifo.getPathForCreation());\n    TerminalServer terminalServer(tcpSocketHandler, serverEndpoint,\n                                  pipeSocketHandler, routerFifo);\n    terminalServer.run();\n\n  } catch (cxxopts::OptionException &oe) {\n    CLOG(INFO, \"stdout\") << \"Exception: \" << oe.what() << \"\\n\" << endl;\n    CLOG(INFO, \"stdout\") << options.help({}) << endl;\n    exit(1);\n  }\n\n  // Uninstall log rotation callback\n  el::Helpers::uninstallPreRollOutCallback();\n}",
        "func": "int main(int argc, char **argv) {\n  // Setup easylogging configurations\n  el::Configurations defaultConf = LogHandler::setupLogHandler(&argc, &argv);\n  LogHandler::setupStdoutLogger();\n\n  et::HandleTerminate();\n\n  // Override easylogging handler for sigint\n  ::signal(SIGINT, et::InterruptSignalHandler);\n\n  cxxopts::Options options(\"etserver\",\n                           \"Remote shell for the busy and impatient\");\n  try {\n    // Parse command line arguments\n    options.allow_unrecognised_options();\n\n    options.add_options()             //\n        (\"h,help\", \"Print help\")      //\n        (\"version\", \"Print version\")  //\n        (\"port\", \"Port to listen on\",\n         cxxopts::value<int>()->default_value(\"0\"))  //\n        (\"bindip\", \"IP to listen on\",\n         cxxopts::value<string>()->default_value(\"\"))  //\n        (\"daemon\", \"Daemonize the server\")             //\n        (\"cfgfile\", \"Location of the config file\",\n         cxxopts::value<std::string>()->default_value(\"\"))  //\n        (\"logtostdout\", \"log to stdout\")                    //\n        (\"pidfile\", \"Location of the pid file\",\n         cxxopts::value<std::string>()->default_value(\n             \"/var/run/etserver.pid\"))  //\n        (\"v,verbose\", \"Enable verbose logging\",\n         cxxopts::value<int>()->default_value(\"0\"), \"LEVEL\")  //\n        (\"serverfifo\",\n         \"If set, listens on the matching fifo name\",       //\n         cxxopts::value<std::string>()->default_value(\"\"))  //\n        (\"telemetry\",\n         \"Allow et to anonymously send errors to guide future improvements\",\n         cxxopts::value<bool>())  //\n        ;\n\n    auto result = options.parse(argc, argv);\n\n    if (result.count(\"help\")) {\n      CLOG(INFO, \"stdout\") << options.help({}) << endl;\n      exit(0);\n    }\n    if (result.count(\"version\")) {\n      CLOG(INFO, \"stdout\") << \"et version \" << ET_VERSION << endl;\n      exit(0);\n    }\n\n    el::Loggers::setVerboseLevel(result[\"verbose\"].as<int>());\n\n    if (result.count(\"daemon\")) {\n      if (DaemonCreator::create(true, result[\"pidfile\"].as<string>()) == -1) {\n        STFATAL << \"Error creating daemon: \" << strerror(GetErrno());\n      }\n    }\n\n    ServerFifoPath serverFifo;\n\n    // default max log file size is 20MB for etserver\n    string maxlogsize = \"20971520\";\n\n    int port = 0;\n    string bindIp = \"\";\n    bool telemetry = false;\n    if (result.count(\"cfgfile\")) {\n      // Load the config file\n      CSimpleIniA ini(true, false, false);\n      string cfgfilename = result[\"cfgfile\"].as<string>();\n      SI_Error rc = ini.LoadFile(cfgfilename.c_str());\n      if (rc == 0) {\n        if (!result.count(\"port\")) {\n          const char *portString = ini.GetValue(\"Networking\", \"port\", NULL);\n          if (portString) {\n            port = stoi(portString);\n          }\n        }\n\n        if (!result.count(\"bindip\")) {\n          const char *bindIpPtr = ini.GetValue(\"Networking\", \"bind_ip\", NULL);\n          if (bindIpPtr) {\n            bindIp = string(bindIpPtr);\n          }\n        }\n\n        telemetry = ini.GetBoolValue(\"Debug\", \"telemetry\", false);\n        // read verbose level (prioritize command line option over cfgfile)\n        const char *vlevel = ini.GetValue(\"Debug\", \"verbose\", NULL);\n        if (result.count(\"verbose\")) {\n          el::Loggers::setVerboseLevel(result[\"verbose\"].as<int>());\n        } else if (vlevel) {\n          el::Loggers::setVerboseLevel(atoi(vlevel));\n        }\n\n        const char *fifoName = ini.GetValue(\"Debug\", \"serverfifo\", NULL);\n        if (fifoName) {\n          const string fifoNameStr(fifoName);\n          if (!fifoNameStr.empty()) {\n            serverFifo.setPathOverride(fifoNameStr);\n          }\n        }\n\n        // read silent setting\n        const char *silent = ini.GetValue(\"Debug\", \"silent\", NULL);\n        if (silent && atoi(silent) != 0) {\n          defaultConf.setGlobally(el::ConfigurationType::Enabled, \"false\");\n        }\n        // read log file size limit\n        const char *logsize = ini.GetValue(\"Debug\", \"logsize\", NULL);\n        if (logsize && atoi(logsize) != 0) {\n          // make sure maxlogsize is a string of int value\n          maxlogsize = string(logsize);\n        }\n\n      } else {\n        STFATAL << \"Invalid config file: \" << cfgfilename;\n      }\n    }\n\n    if (result.count(\"serverfifo\") &&\n        !result[\"serverfifo\"].as<string>().empty()) {\n      serverFifo.setPathOverride(result[\"serverfifo\"].as<string>());\n    }\n\n    if (result.count(\"port\")) {\n      port = result[\"port\"].as<int>();\n    }\n\n    if (result.count(\"bindip\")) {\n      bindIp = result[\"bindip\"].as<string>();\n    }\n\n    if (result.count(\"telemetry\")) {\n      telemetry = result[\"telemetry\"].as<bool>();\n    }\n\n    GOOGLE_PROTOBUF_VERIFY_VERSION;\n    srand(1);\n\n    if (port == 0) {\n      port = 2022;\n    }\n\n    // Set log file for etserver process here.\n    LogHandler::setupLogFiles(&defaultConf, GetTempDirectory(), \"etserver\",\n                              result.count(\"logtostdout\"),\n                              !result.count(\"logtostdout\"),\n                              true /* appendPid */, maxlogsize);\n    // Reconfigure default logger to apply settings above\n    el::Loggers::reconfigureLogger(\"default\", defaultConf);\n    // set thread name\n    el::Helpers::setThreadName(\"etserver-main\");\n    // Install log rotation callback\n    el::Helpers::installPreRollOutCallback(LogHandler::rolloutHandler);\n\n    TelemetryService::create(\n        telemetry, GetTempDirectory() + \"/.sentry-native-etserver\", \"Server\");\n\n    serverFifo.createDirectoriesIfRequired();\n\n    std::shared_ptr<SocketHandler> tcpSocketHandler(new TcpSocketHandler());\n    std::shared_ptr<PipeSocketHandler> pipeSocketHandler(\n        new PipeSocketHandler());\n\n    LOG(INFO) << \"In child, about to start server.\";\n\n    SocketEndpoint serverEndpoint;\n    serverEndpoint.set_port(port);\n    if (bindIp.length()) {\n      serverEndpoint.set_name(bindIp);\n    }\n    SocketEndpoint routerFifo;\n    routerFifo.set_name(serverFifo.getPathForCreation());\n    TerminalServer terminalServer(tcpSocketHandler, serverEndpoint,\n                                  pipeSocketHandler, routerFifo);\n    terminalServer.run();\n\n  } catch (cxxopts::OptionException &oe) {\n    CLOG(INFO, \"stdout\") << \"Exception: \" << oe.what() << \"\\n\" << endl;\n    CLOG(INFO, \"stdout\") << options.help({}) << endl;\n    exit(1);\n  }\n\n  // Uninstall log rotation callback\n  el::Helpers::uninstallPreRollOutCallback();\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -55,14 +55,6 @@\n       if (DaemonCreator::create(true, result[\"pidfile\"].as<string>()) == -1) {\n         STFATAL << \"Error creating daemon: \" << strerror(GetErrno());\n       }\n-    }\n-\n-    if (result.count(\"logtostdout\")) {\n-      defaultConf.setGlobally(el::ConfigurationType::ToStandardOutput, \"true\");\n-    } else {\n-      defaultConf.setGlobally(el::ConfigurationType::ToStandardOutput, \"false\");\n-      // Redirect std streams to a file\n-      LogHandler::stderrToFile(GetTempDirectory() + \"etserver\");\n     }\n \n     ServerFifoPath serverFifo;\n@@ -152,9 +144,10 @@\n     }\n \n     // Set log file for etserver process here.\n-    LogHandler::setupLogFile(&defaultConf,\n-                             GetTempDirectory() + \"etserver-%datetime.log\",\n-                             maxlogsize);\n+    LogHandler::setupLogFiles(&defaultConf, GetTempDirectory(), \"etserver\",\n+                              result.count(\"logtostdout\"),\n+                              !result.count(\"logtostdout\"),\n+                              true /* appendPid */, maxlogsize);\n     // Reconfigure default logger to apply settings above\n     el::Loggers::reconfigureLogger(\"default\", defaultConf);\n     // set thread name",
        "diff_line_info": {
            "deleted_lines": [
                "    }",
                "",
                "    if (result.count(\"logtostdout\")) {",
                "      defaultConf.setGlobally(el::ConfigurationType::ToStandardOutput, \"true\");",
                "    } else {",
                "      defaultConf.setGlobally(el::ConfigurationType::ToStandardOutput, \"false\");",
                "      // Redirect std streams to a file",
                "      LogHandler::stderrToFile(GetTempDirectory() + \"etserver\");",
                "    LogHandler::setupLogFile(&defaultConf,",
                "                             GetTempDirectory() + \"etserver-%datetime.log\",",
                "                             maxlogsize);"
            ],
            "added_lines": [
                "    LogHandler::setupLogFiles(&defaultConf, GetTempDirectory(), \"etserver\",",
                "                              result.count(\"logtostdout\"),",
                "                              !result.count(\"logtostdout\"),",
                "                              true /* appendPid */, maxlogsize);"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-48257",
        "func_name": "MisterTea/EternalTerminal/main",
        "description": "In Eternal Terminal 6.2.1, etserver and etclient have predictable logfile names in /tmp.",
        "git_url": "https://github.com/MisterTea/EternalTerminal/commit/4a8b02d5f1afb38b00c77ab1321d5f56720f4e30",
        "commit_title": "Unify logfile names and create with more secure open options and perms.",
        "commit_text": " Fixes #555 (Tribute to Colin McRae)",
        "func_before": "int main(int argc, char** argv) {\n  WinsockContext context;\n  string tmpDir = GetTempDirectory();\n\n  // Setup easylogging configurations\n  el::Configurations defaultConf = LogHandler::setupLogHandler(&argc, &argv);\n  LogHandler::setupStdoutLogger();\n\n  et::HandleTerminate();\n\n  // Override easylogging handler for sigint\n  ::signal(SIGINT, et::InterruptSignalHandler);\n\n  // Parse command line arguments\n  cxxopts::Options options(\"et\", \"Remote shell for the busy and impatient\");\n  try {\n    options.allow_unrecognised_options();\n    options.positional_help(\"\");\n    options.custom_help(\n        \"[OPTION...] [user@]host[:port]\\n\\n\"\n        \"  Note that 'host' can be a hostname or ipv4 address with or without \"\n        \"a port\\n  or an ipv6 address. If the ipv6 address is abbreviated with \"\n        \":: then it must\\n  be specfied without a port (use -p,--port).\");\n\n    options.add_options()             //\n        (\"h,help\", \"Print help\")      //\n        (\"version\", \"Print version\")  //\n        (\"u,username\", \"Username\")    //\n        (\"host\", \"Remote host name\",\n         cxxopts::value<std::string>())  //\n        (\"p,port\", \"Remote machine etserver port\",\n         cxxopts::value<int>()->default_value(\"2022\"))  //\n        (\"c,command\", \"Run command on connect\",\n         cxxopts::value<std::string>())  //\n        (\"terminal-path\",\n         \"Path to etterminal on server side. \"\n         \"Use if etterminal is not on the system path.\",\n         cxxopts::value<std::string>())  //\n        (\"t,tunnel\",\n         \"Tunnel: Array of source:destination ports or \"\n         \"srcStart-srcEnd:dstStart-dstEnd (inclusive) port ranges (e.g. \"\n         \"10080:80,10443:443, 10090-10092:8000-8002)\",\n         cxxopts::value<std::string>())  //\n        (\"r,reversetunnel\",\n         \"Reverse Tunnel: Array of source:destination ports or \"\n         \"srcStart-srcEnd:dstStart-dstEnd (inclusive) port ranges\",\n         cxxopts::value<std::string>())  //\n        (\"jumphost\", \"jumphost between localhost and destination\",\n         cxxopts::value<std::string>())  //\n        (\"jport\", \"Jumphost machine port\",\n         cxxopts::value<int>()->default_value(\"2022\"))  //\n        (\"x,kill-other-sessions\",\n         \"kill all old sessions belonging to the user\")  //\n        (\"macserver\",\n         \"Set when connecting to an macOS server.  Sets \"\n         \"--terminal-path=/usr/local/bin/etterminal\")  //\n        (\"v,verbose\", \"Enable verbose logging\",\n         cxxopts::value<int>()->default_value(\"0\"))  //\n        (\"k,keepalive\", \"Client keepalive duration in seconds\",\n         cxxopts::value<int>())                              //\n        (\"logtostdout\", \"Write log to stdout\")               //\n        (\"silent\", \"Disable logging\")                        //\n        (\"N,no-terminal\", \"Do not create a terminal\")        //\n        (\"f,forward-ssh-agent\", \"Forward ssh-agent socket\")  //\n        (\"ssh-socket\", \"The ssh-agent socket to forward\",\n         cxxopts::value<std::string>())  //\n        (\"telemetry\",\n         \"Allow et to anonymously send errors to guide future improvements\",\n         cxxopts::value<bool>()->default_value(\"true\"))  //\n        (\"serverfifo\",\n         \"If set, communicate to etserver on the matching fifo name\",\n         cxxopts::value<std::string>()->default_value(\"\"))  //\n        (\"ssh-option\", \"Options to pass down to `ssh -o`\",\n         cxxopts::value<std::vector<std::string>>());\n\n    options.parse_positional({\"host\"});\n    auto result = options.parse(argc, argv);\n\n    if (result.count(\"help\")) {\n      CLOG(INFO, \"stdout\") << options.help({}) << endl;\n      exit(0);\n    }\n\n    if (result.count(\"version\")) {\n      CLOG(INFO, \"stdout\") << \"et version \" << ET_VERSION << endl;\n      exit(0);\n    }\n\n    el::Loggers::setVerboseLevel(result[\"verbose\"].as<int>());\n\n    if (result.count(\"logtostdout\")) {\n      defaultConf.setGlobally(el::ConfigurationType::ToStandardOutput, \"true\");\n    } else {\n      defaultConf.setGlobally(el::ConfigurationType::ToStandardOutput, \"false\");\n      // Redirect std streams to a file\n      LogHandler::stderrToFile((tmpDir + \"/etclient\"));\n    }\n\n    // silent Flag, since etclient doesn't read /etc/et.cfg file\n    if (result.count(\"silent\")) {\n      defaultConf.setGlobally(el::ConfigurationType::Enabled, \"false\");\n    }\n\n    LogHandler::setupLogFile(\n        &defaultConf, (tmpDir + \"/etclient-%datetime{%Y-%M-%d_%H_%m_%s}.log\"));\n\n    el::Loggers::reconfigureLogger(\"default\", defaultConf);\n    // set thread name\n    el::Helpers::setThreadName(\"client-main\");\n\n    // Install log rotation callback\n    el::Helpers::installPreRollOutCallback(LogHandler::rolloutHandler);\n\n    GOOGLE_PROTOBUF_VERIFY_VERSION;\n    srand(1);\n\n    TelemetryService::create(result[\"telemetry\"].as<bool>(),\n                             tmpDir + \"/.sentry-native-et\", \"Client\");\n\n    string username = \"\";\n    if (result.count(\"username\")) {\n      username = result[\"username\"].as<string>();\n    }\n    int destinationPort = result[\"port\"].as<int>();\n    string destinationHost;\n\n    // Parse command-line argument\n    if (!result.count(\"host\")) {\n      CLOG(INFO, \"stdout\") << \"Missing host to connect to\" << endl;\n      CLOG(INFO, \"stdout\") << options.help({}) << endl;\n      exit(0);\n    }\n    string host_arg = result[\"host\"].as<std::string>();\n    if (host_arg.find('@') != string::npos) {\n      int i = host_arg.find('@');\n      username = host_arg.substr(0, i);\n      host_arg = host_arg.substr(i + 1);\n    }\n\n    if (host_arg.find(':') != string::npos) {\n      int colon_count = std::count(host_arg.begin(), host_arg.end(), ':');\n      if (colon_count == 1) {\n        // ipv4 or hostname with port specified\n        int port_colon_pos = host_arg.rfind(':');\n        destinationPort = stoi(host_arg.substr(port_colon_pos + 1));\n        host_arg = host_arg.substr(0, port_colon_pos);\n      } else {\n        // maybe ipv6 (colon_count >= 2)\n        if (host_arg.find(\"::\") != string::npos) {\n          // ipv6 with double colon zero abbreviation and no port\n          // leave host_arg as is\n        } else {\n          if (colon_count == 7) {\n            // ipv6, fully expanded, without port\n          } else if (colon_count == 8) {\n            // ipv6, fully expanded, with port\n            int port_colon_pos = host_arg.rfind(':');\n            destinationPort = stoi(host_arg.substr(port_colon_pos + 1));\n            host_arg = host_arg.substr(0, port_colon_pos);\n          } else {\n            CLOG(INFO, \"stdout\") << \"Invalid host positional arg: \"\n                                 << result[\"host\"].as<std::string>() << endl;\n            exit(1);\n          }\n        }\n      }\n    }\n    destinationHost = host_arg;\n    // host_alias is used for the initiating ssh call, if sshd runs on a port\n    // other than 22, either configure your .ssh/config with an alias with an\n    // overridden port or pass --ssh-option Port=<sshd_port>\n    string host_alias = destinationHost;\n\n    string jumphost =\n        result.count(\"jumphost\") ? result[\"jumphost\"].as<string>() : \"\";\n    int keepaliveDuration = result.count(\"keepalive\")\n                                ? result[\"keepalive\"].as<int>()\n                                : MAX_CLIENT_KEEP_ALIVE_DURATION;\n    if (keepaliveDuration < 1 ||\n        keepaliveDuration > MAX_CLIENT_KEEP_ALIVE_DURATION) {\n      CLOG(INFO, \"stdout\") << \"Keep-alive duration must between 1 and \"\n                           << MAX_CLIENT_KEEP_ALIVE_DURATION << \" seconds\"\n                           << endl;\n      CLOG(INFO, \"stdout\") << options.help({}) << endl;\n      exit(0);\n    }\n\n    Options sshConfigOptions = {\n        NULL,  // username\n        NULL,  // host\n        NULL,  // sshdir\n        NULL,  // knownhosts\n        NULL,  // ProxyCommand\n        NULL,  // ProxyJump\n        0,     // timeout\n        0,     // port\n        0,     // StrictHostKeyChecking\n        0,     // ssh2\n        0,     // ssh1\n        NULL,  // gss_server_identity\n        NULL,  // gss_client_identity\n        0,     // gss_delegate_creds\n        0,     // forward_agent\n        NULL   // identity_agent\n    };\n\n    char* home_dir = ssh_get_user_home_dir();\n    const char* host_from_command = destinationHost.c_str();\n    ssh_options_set(&sshConfigOptions, SSH_OPTIONS_HOST,\n                    destinationHost.c_str());\n    // First parse user-specific ssh config, then system-wide config.\n    parse_ssh_config_file(host_from_command, &sshConfigOptions,\n                          string(home_dir) + USER_SSH_CONFIG_PATH);\n    parse_ssh_config_file(host_from_command, &sshConfigOptions,\n                          SYSTEM_SSH_CONFIG_PATH);\n    LOG(INFO) << \"Parsed ssh config file, connecting to \"\n              << sshConfigOptions.host;\n    destinationHost = string(sshConfigOptions.host);\n\n    // Parse username: cmdline > sshconfig > localuser\n    if (username.empty()) {\n      if (sshConfigOptions.username) {\n        username = string(sshConfigOptions.username);\n      } else {\n        username = string(ssh_get_local_username());\n      }\n    }\n\n    // Parse jumphost: cmd > sshconfig\n    if (sshConfigOptions.ProxyJump && jumphost.length() == 0) {\n      string proxyjump = string(sshConfigOptions.ProxyJump);\n      size_t colonIndex = proxyjump.find(\":\");\n      if (colonIndex != string::npos) {\n        string userhostpair = proxyjump.substr(0, colonIndex);\n        size_t atIndex = userhostpair.find(\"@\");\n        if (atIndex != string::npos) {\n          jumphost = userhostpair.substr(atIndex + 1);\n        }\n      } else {\n        jumphost = proxyjump;\n      }\n      LOG(INFO) << \"ProxyJump found for dst in ssh config: \" << proxyjump;\n    }\n\n    bool is_jumphost = false;\n    SocketEndpoint socketEndpoint;\n    if (!jumphost.empty()) {\n      is_jumphost = true;\n      LOG(INFO) << \"Setting port to jumphost port\";\n      socketEndpoint.set_name(jumphost);\n      socketEndpoint.set_port(result[\"jport\"].as<int>());\n    } else {\n      socketEndpoint.set_name(destinationHost);\n      socketEndpoint.set_port(destinationPort);\n    }\n    shared_ptr<SocketHandler> clientSocket(new TcpSocketHandler());\n    shared_ptr<SocketHandler> clientPipeSocket(new PipeSocketHandler());\n\n    if (!ping(socketEndpoint, clientSocket)) {\n      CLOG(INFO, \"stdout\") << \"Could not reach the ET server: \"\n                           << socketEndpoint.name() << \":\"\n                           << socketEndpoint.port() << endl;\n      exit(1);\n    }\n\n    int jport = result[\"jport\"].as<int>();\n    string serverFifo = \"\";\n    if (result[\"serverfifo\"].as<string>() != \"\") {\n      serverFifo = result[\"serverfifo\"].as<string>();\n    }\n    std::vector<string> ssh_options;\n    if (result.count(\"ssh-option\")) {\n      ssh_options = result[\"ssh-option\"].as<std::vector<string>>();\n    }\n    string etterminal_path = \"\";\n    if (result.count(\"macserver\") > 0) {\n      etterminal_path = \"/usr/local/bin/etterminal\";\n    }\n    if (result.count(\"etterminal_path\")) {\n      etterminal_path = result[\"terminal-path\"].as<string>();\n    }\n    string idpasskeypair = SshSetupHandler::SetupSsh(\n        username, destinationHost, host_alias, destinationPort, jumphost, jport,\n        result.count(\"x\") > 0, result[\"verbose\"].as<int>(), etterminal_path,\n        serverFifo, ssh_options);\n\n    string id = \"\", passkey = \"\";\n    // Trim whitespace\n    idpasskeypair.erase(idpasskeypair.find_last_not_of(\" \\n\\r\\t\") + 1);\n    size_t slashIndex = idpasskeypair.find(\"/\");\n    if (slashIndex == string::npos) {\n      STFATAL << \"Invalid idPasskey id/key pair: \" << idpasskeypair;\n    } else {\n      id = idpasskeypair.substr(0, slashIndex);\n      passkey = idpasskeypair.substr(slashIndex + 1);\n    }\n    if (passkey.length() != 32) {\n      STFATAL << \"Invalid/missing passkey: \" << passkey << \" \"\n              << passkey.length();\n    }\n    shared_ptr<Console> console;\n    if (!result.count(\"N\")) {\n      console.reset(new PsuedoTerminalConsole());\n    }\n\n    bool forwardAgent = result.count(\"f\") > 0;\n    string sshSocket = \"\";\n#ifndef WIN32\n    if (sshConfigOptions.identity_agent) {\n      sshSocket = string(sshConfigOptions.identity_agent);\n    }\n    forwardAgent |= sshConfigOptions.forward_agent;\n#endif\n    if (result.count(\"ssh-socket\")) {\n      sshSocket = result[\"ssh-socket\"].as<string>();\n    }\n    TelemetryService::get()->logToDatadog(\"Session Started\", el::Level::Info,\n                                          __FILE__, __LINE__);\n    string tunnel_arg =\n        result.count(\"tunnel\") ? result[\"tunnel\"].as<string>() : \"\";\n    string r_tunnel_arg = result.count(\"reversetunnel\")\n                              ? result[\"reversetunnel\"].as<string>()\n                              : \"\";\n    TerminalClient terminalClient(clientSocket, clientPipeSocket,\n                                  socketEndpoint, id, passkey, console,\n                                  is_jumphost, tunnel_arg, r_tunnel_arg,\n                                  forwardAgent, sshSocket, keepaliveDuration);\n    terminalClient.run(result.count(\"command\") ? result[\"command\"].as<string>()\n                                               : \"\");\n  } catch (TunnelParseException& tpe) {\n    handleParseException(tpe, options);\n  } catch (cxxopts::OptionException& oe) {\n    handleParseException(oe, options);\n  }\n\n#ifdef WIN32\n  WSACleanup();\n#endif\n\n  TelemetryService::get()->shutdown();\n  TelemetryService::destroy();\n\n  // Uninstall log rotation callback\n  el::Helpers::uninstallPreRollOutCallback();\n\n  return 0;\n}",
        "func": "int main(int argc, char** argv) {\n  WinsockContext context;\n  string tmpDir = GetTempDirectory();\n\n  // Setup easylogging configurations\n  el::Configurations defaultConf = LogHandler::setupLogHandler(&argc, &argv);\n  LogHandler::setupStdoutLogger();\n\n  et::HandleTerminate();\n\n  // Override easylogging handler for sigint\n  ::signal(SIGINT, et::InterruptSignalHandler);\n\n  // Parse command line arguments\n  cxxopts::Options options(\"et\", \"Remote shell for the busy and impatient\");\n  try {\n    options.allow_unrecognised_options();\n    options.positional_help(\"\");\n    options.custom_help(\n        \"[OPTION...] [user@]host[:port]\\n\\n\"\n        \"  Note that 'host' can be a hostname or ipv4 address with or without \"\n        \"a port\\n  or an ipv6 address. If the ipv6 address is abbreviated with \"\n        \":: then it must\\n  be specfied without a port (use -p,--port).\");\n\n    options.add_options()             //\n        (\"h,help\", \"Print help\")      //\n        (\"version\", \"Print version\")  //\n        (\"u,username\", \"Username\")    //\n        (\"host\", \"Remote host name\",\n         cxxopts::value<std::string>())  //\n        (\"p,port\", \"Remote machine etserver port\",\n         cxxopts::value<int>()->default_value(\"2022\"))  //\n        (\"c,command\", \"Run command on connect\",\n         cxxopts::value<std::string>())  //\n        (\"terminal-path\",\n         \"Path to etterminal on server side. \"\n         \"Use if etterminal is not on the system path.\",\n         cxxopts::value<std::string>())  //\n        (\"t,tunnel\",\n         \"Tunnel: Array of source:destination ports or \"\n         \"srcStart-srcEnd:dstStart-dstEnd (inclusive) port ranges (e.g. \"\n         \"10080:80,10443:443, 10090-10092:8000-8002)\",\n         cxxopts::value<std::string>())  //\n        (\"r,reversetunnel\",\n         \"Reverse Tunnel: Array of source:destination ports or \"\n         \"srcStart-srcEnd:dstStart-dstEnd (inclusive) port ranges\",\n         cxxopts::value<std::string>())  //\n        (\"jumphost\", \"jumphost between localhost and destination\",\n         cxxopts::value<std::string>())  //\n        (\"jport\", \"Jumphost machine port\",\n         cxxopts::value<int>()->default_value(\"2022\"))  //\n        (\"x,kill-other-sessions\",\n         \"kill all old sessions belonging to the user\")  //\n        (\"macserver\",\n         \"Set when connecting to an macOS server.  Sets \"\n         \"--terminal-path=/usr/local/bin/etterminal\")  //\n        (\"v,verbose\", \"Enable verbose logging\",\n         cxxopts::value<int>()->default_value(\"0\"))  //\n        (\"k,keepalive\", \"Client keepalive duration in seconds\",\n         cxxopts::value<int>())                              //\n        (\"logtostdout\", \"Write log to stdout\")               //\n        (\"silent\", \"Disable logging\")                        //\n        (\"N,no-terminal\", \"Do not create a terminal\")        //\n        (\"f,forward-ssh-agent\", \"Forward ssh-agent socket\")  //\n        (\"ssh-socket\", \"The ssh-agent socket to forward\",\n         cxxopts::value<std::string>())  //\n        (\"telemetry\",\n         \"Allow et to anonymously send errors to guide future improvements\",\n         cxxopts::value<bool>()->default_value(\"true\"))  //\n        (\"serverfifo\",\n         \"If set, communicate to etserver on the matching fifo name\",\n         cxxopts::value<std::string>()->default_value(\"\"))  //\n        (\"ssh-option\", \"Options to pass down to `ssh -o`\",\n         cxxopts::value<std::vector<std::string>>());\n\n    options.parse_positional({\"host\"});\n    auto result = options.parse(argc, argv);\n\n    if (result.count(\"help\")) {\n      CLOG(INFO, \"stdout\") << options.help({}) << endl;\n      exit(0);\n    }\n\n    if (result.count(\"version\")) {\n      CLOG(INFO, \"stdout\") << \"et version \" << ET_VERSION << endl;\n      exit(0);\n    }\n\n    el::Loggers::setVerboseLevel(result[\"verbose\"].as<int>());\n\n    // silent Flag, since etclient doesn't read /etc/et.cfg file\n    if (result.count(\"silent\")) {\n      defaultConf.setGlobally(el::ConfigurationType::Enabled, \"false\");\n    }\n\n    LogHandler::setupLogFiles(&defaultConf, tmpDir, \"etclient\",\n                              result.count(\"logtostdout\"),\n                              !result.count(\"logtostdout\"));\n\n    el::Loggers::reconfigureLogger(\"default\", defaultConf);\n    // set thread name\n    el::Helpers::setThreadName(\"client-main\");\n\n    // Install log rotation callback\n    el::Helpers::installPreRollOutCallback(LogHandler::rolloutHandler);\n\n    GOOGLE_PROTOBUF_VERIFY_VERSION;\n    srand(1);\n\n    TelemetryService::create(result[\"telemetry\"].as<bool>(),\n                             tmpDir + \"/.sentry-native-et\", \"Client\");\n\n    string username = \"\";\n    if (result.count(\"username\")) {\n      username = result[\"username\"].as<string>();\n    }\n    int destinationPort = result[\"port\"].as<int>();\n    string destinationHost;\n\n    // Parse command-line argument\n    if (!result.count(\"host\")) {\n      CLOG(INFO, \"stdout\") << \"Missing host to connect to\" << endl;\n      CLOG(INFO, \"stdout\") << options.help({}) << endl;\n      exit(0);\n    }\n    string host_arg = result[\"host\"].as<std::string>();\n    if (host_arg.find('@') != string::npos) {\n      int i = host_arg.find('@');\n      username = host_arg.substr(0, i);\n      host_arg = host_arg.substr(i + 1);\n    }\n\n    if (host_arg.find(':') != string::npos) {\n      int colon_count = std::count(host_arg.begin(), host_arg.end(), ':');\n      if (colon_count == 1) {\n        // ipv4 or hostname with port specified\n        int port_colon_pos = host_arg.rfind(':');\n        destinationPort = stoi(host_arg.substr(port_colon_pos + 1));\n        host_arg = host_arg.substr(0, port_colon_pos);\n      } else {\n        // maybe ipv6 (colon_count >= 2)\n        if (host_arg.find(\"::\") != string::npos) {\n          // ipv6 with double colon zero abbreviation and no port\n          // leave host_arg as is\n        } else {\n          if (colon_count == 7) {\n            // ipv6, fully expanded, without port\n          } else if (colon_count == 8) {\n            // ipv6, fully expanded, with port\n            int port_colon_pos = host_arg.rfind(':');\n            destinationPort = stoi(host_arg.substr(port_colon_pos + 1));\n            host_arg = host_arg.substr(0, port_colon_pos);\n          } else {\n            CLOG(INFO, \"stdout\") << \"Invalid host positional arg: \"\n                                 << result[\"host\"].as<std::string>() << endl;\n            exit(1);\n          }\n        }\n      }\n    }\n    destinationHost = host_arg;\n    // host_alias is used for the initiating ssh call, if sshd runs on a port\n    // other than 22, either configure your .ssh/config with an alias with an\n    // overridden port or pass --ssh-option Port=<sshd_port>\n    string host_alias = destinationHost;\n\n    string jumphost =\n        result.count(\"jumphost\") ? result[\"jumphost\"].as<string>() : \"\";\n    int keepaliveDuration = result.count(\"keepalive\")\n                                ? result[\"keepalive\"].as<int>()\n                                : MAX_CLIENT_KEEP_ALIVE_DURATION;\n    if (keepaliveDuration < 1 ||\n        keepaliveDuration > MAX_CLIENT_KEEP_ALIVE_DURATION) {\n      CLOG(INFO, \"stdout\") << \"Keep-alive duration must between 1 and \"\n                           << MAX_CLIENT_KEEP_ALIVE_DURATION << \" seconds\"\n                           << endl;\n      CLOG(INFO, \"stdout\") << options.help({}) << endl;\n      exit(0);\n    }\n\n    Options sshConfigOptions = {\n        NULL,  // username\n        NULL,  // host\n        NULL,  // sshdir\n        NULL,  // knownhosts\n        NULL,  // ProxyCommand\n        NULL,  // ProxyJump\n        0,     // timeout\n        0,     // port\n        0,     // StrictHostKeyChecking\n        0,     // ssh2\n        0,     // ssh1\n        NULL,  // gss_server_identity\n        NULL,  // gss_client_identity\n        0,     // gss_delegate_creds\n        0,     // forward_agent\n        NULL   // identity_agent\n    };\n\n    char* home_dir = ssh_get_user_home_dir();\n    const char* host_from_command = destinationHost.c_str();\n    ssh_options_set(&sshConfigOptions, SSH_OPTIONS_HOST,\n                    destinationHost.c_str());\n    // First parse user-specific ssh config, then system-wide config.\n    parse_ssh_config_file(host_from_command, &sshConfigOptions,\n                          string(home_dir) + USER_SSH_CONFIG_PATH);\n    parse_ssh_config_file(host_from_command, &sshConfigOptions,\n                          SYSTEM_SSH_CONFIG_PATH);\n    LOG(INFO) << \"Parsed ssh config file, connecting to \"\n              << sshConfigOptions.host;\n    destinationHost = string(sshConfigOptions.host);\n\n    // Parse username: cmdline > sshconfig > localuser\n    if (username.empty()) {\n      if (sshConfigOptions.username) {\n        username = string(sshConfigOptions.username);\n      } else {\n        username = string(ssh_get_local_username());\n      }\n    }\n\n    // Parse jumphost: cmd > sshconfig\n    if (sshConfigOptions.ProxyJump && jumphost.length() == 0) {\n      string proxyjump = string(sshConfigOptions.ProxyJump);\n      size_t colonIndex = proxyjump.find(\":\");\n      if (colonIndex != string::npos) {\n        string userhostpair = proxyjump.substr(0, colonIndex);\n        size_t atIndex = userhostpair.find(\"@\");\n        if (atIndex != string::npos) {\n          jumphost = userhostpair.substr(atIndex + 1);\n        }\n      } else {\n        jumphost = proxyjump;\n      }\n      LOG(INFO) << \"ProxyJump found for dst in ssh config: \" << proxyjump;\n    }\n\n    bool is_jumphost = false;\n    SocketEndpoint socketEndpoint;\n    if (!jumphost.empty()) {\n      is_jumphost = true;\n      LOG(INFO) << \"Setting port to jumphost port\";\n      socketEndpoint.set_name(jumphost);\n      socketEndpoint.set_port(result[\"jport\"].as<int>());\n    } else {\n      socketEndpoint.set_name(destinationHost);\n      socketEndpoint.set_port(destinationPort);\n    }\n    shared_ptr<SocketHandler> clientSocket(new TcpSocketHandler());\n    shared_ptr<SocketHandler> clientPipeSocket(new PipeSocketHandler());\n\n    if (!ping(socketEndpoint, clientSocket)) {\n      CLOG(INFO, \"stdout\") << \"Could not reach the ET server: \"\n                           << socketEndpoint.name() << \":\"\n                           << socketEndpoint.port() << endl;\n      exit(1);\n    }\n\n    int jport = result[\"jport\"].as<int>();\n    string serverFifo = \"\";\n    if (result[\"serverfifo\"].as<string>() != \"\") {\n      serverFifo = result[\"serverfifo\"].as<string>();\n    }\n    std::vector<string> ssh_options;\n    if (result.count(\"ssh-option\")) {\n      ssh_options = result[\"ssh-option\"].as<std::vector<string>>();\n    }\n    string etterminal_path = \"\";\n    if (result.count(\"macserver\") > 0) {\n      etterminal_path = \"/usr/local/bin/etterminal\";\n    }\n    if (result.count(\"etterminal_path\")) {\n      etterminal_path = result[\"terminal-path\"].as<string>();\n    }\n    string idpasskeypair = SshSetupHandler::SetupSsh(\n        username, destinationHost, host_alias, destinationPort, jumphost, jport,\n        result.count(\"x\") > 0, result[\"verbose\"].as<int>(), etterminal_path,\n        serverFifo, ssh_options);\n\n    string id = \"\", passkey = \"\";\n    // Trim whitespace\n    idpasskeypair.erase(idpasskeypair.find_last_not_of(\" \\n\\r\\t\") + 1);\n    size_t slashIndex = idpasskeypair.find(\"/\");\n    if (slashIndex == string::npos) {\n      STFATAL << \"Invalid idPasskey id/key pair: \" << idpasskeypair;\n    } else {\n      id = idpasskeypair.substr(0, slashIndex);\n      passkey = idpasskeypair.substr(slashIndex + 1);\n    }\n    if (passkey.length() != 32) {\n      STFATAL << \"Invalid/missing passkey: \" << passkey << \" \"\n              << passkey.length();\n    }\n    shared_ptr<Console> console;\n    if (!result.count(\"N\")) {\n      console.reset(new PsuedoTerminalConsole());\n    }\n\n    bool forwardAgent = result.count(\"f\") > 0;\n    string sshSocket = \"\";\n#ifndef WIN32\n    if (sshConfigOptions.identity_agent) {\n      sshSocket = string(sshConfigOptions.identity_agent);\n    }\n    forwardAgent |= sshConfigOptions.forward_agent;\n#endif\n    if (result.count(\"ssh-socket\")) {\n      sshSocket = result[\"ssh-socket\"].as<string>();\n    }\n    TelemetryService::get()->logToDatadog(\"Session Started\", el::Level::Info,\n                                          __FILE__, __LINE__);\n    string tunnel_arg =\n        result.count(\"tunnel\") ? result[\"tunnel\"].as<string>() : \"\";\n    string r_tunnel_arg = result.count(\"reversetunnel\")\n                              ? result[\"reversetunnel\"].as<string>()\n                              : \"\";\n    TerminalClient terminalClient(clientSocket, clientPipeSocket,\n                                  socketEndpoint, id, passkey, console,\n                                  is_jumphost, tunnel_arg, r_tunnel_arg,\n                                  forwardAgent, sshSocket, keepaliveDuration);\n    terminalClient.run(result.count(\"command\") ? result[\"command\"].as<string>()\n                                               : \"\");\n  } catch (TunnelParseException& tpe) {\n    handleParseException(tpe, options);\n  } catch (cxxopts::OptionException& oe) {\n    handleParseException(oe, options);\n  }\n\n#ifdef WIN32\n  WSACleanup();\n#endif\n\n  TelemetryService::get()->shutdown();\n  TelemetryService::destroy();\n\n  // Uninstall log rotation callback\n  el::Helpers::uninstallPreRollOutCallback();\n\n  return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -88,21 +88,14 @@\n \n     el::Loggers::setVerboseLevel(result[\"verbose\"].as<int>());\n \n-    if (result.count(\"logtostdout\")) {\n-      defaultConf.setGlobally(el::ConfigurationType::ToStandardOutput, \"true\");\n-    } else {\n-      defaultConf.setGlobally(el::ConfigurationType::ToStandardOutput, \"false\");\n-      // Redirect std streams to a file\n-      LogHandler::stderrToFile((tmpDir + \"/etclient\"));\n-    }\n-\n     // silent Flag, since etclient doesn't read /etc/et.cfg file\n     if (result.count(\"silent\")) {\n       defaultConf.setGlobally(el::ConfigurationType::Enabled, \"false\");\n     }\n \n-    LogHandler::setupLogFile(\n-        &defaultConf, (tmpDir + \"/etclient-%datetime{%Y-%M-%d_%H_%m_%s}.log\"));\n+    LogHandler::setupLogFiles(&defaultConf, tmpDir, \"etclient\",\n+                              result.count(\"logtostdout\"),\n+                              !result.count(\"logtostdout\"));\n \n     el::Loggers::reconfigureLogger(\"default\", defaultConf);\n     // set thread name",
        "diff_line_info": {
            "deleted_lines": [
                "    if (result.count(\"logtostdout\")) {",
                "      defaultConf.setGlobally(el::ConfigurationType::ToStandardOutput, \"true\");",
                "    } else {",
                "      defaultConf.setGlobally(el::ConfigurationType::ToStandardOutput, \"false\");",
                "      // Redirect std streams to a file",
                "      LogHandler::stderrToFile((tmpDir + \"/etclient\"));",
                "    }",
                "",
                "    LogHandler::setupLogFile(",
                "        &defaultConf, (tmpDir + \"/etclient-%datetime{%Y-%M-%d_%H_%m_%s}.log\"));"
            ],
            "added_lines": [
                "    LogHandler::setupLogFiles(&defaultConf, tmpDir, \"etclient\",",
                "                              result.count(\"logtostdout\"),",
                "                              !result.count(\"logtostdout\"));"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-48257",
        "func_name": "MisterTea/EternalTerminal/main",
        "description": "In Eternal Terminal 6.2.1, etserver and etclient have predictable logfile names in /tmp.",
        "git_url": "https://github.com/MisterTea/EternalTerminal/commit/4a8b02d5f1afb38b00c77ab1321d5f56720f4e30",
        "commit_title": "Unify logfile names and create with more secure open options and perms.",
        "commit_text": " Fixes #555 (Tribute to Colin McRae)",
        "func_before": "int main(int argc, char **argv) {\n  // Version string need to be set before GFLAGS parse arguments\n  GOOGLE_PROTOBUF_VERIFY_VERSION;\n  srand(1);\n\n  // Setup easylogging configurations\n  el::Configurations defaultConf =\n      et::LogHandler::setupLogHandler(&argc, &argv);\n  defaultConf.setGlobally(el::ConfigurationType::ToStandardOutput, \"false\");\n  el::Loggers::setVerboseLevel(3);\n  // default max log file size is 20MB for etserver\n  string maxlogsize = \"20971520\";\n  LogHandler::setupLogFile(&defaultConf, GetTempDirectory() + \"htmd.log\",\n                           maxlogsize);\n  // Redirect std streams to a file\n  LogHandler::stderrToFile(GetTempDirectory() + \"htmd\");\n\n  // Reconfigure default logger to apply settings above\n  el::Loggers::reconfigureLogger(\"default\", defaultConf);\n\n  et::HandleTerminate();\n\n  // Override easylogging handler for sigint\n  ::signal(SIGINT, et::InterruptSignalHandler);\n\n  shared_ptr<SocketHandler> socketHandler(new PipeSocketHandler());\n  SocketEndpoint endpoint;\n  endpoint.set_name(HtmServer::getPipeName());\n  HtmServer htm(socketHandler, endpoint);\n  htm.run();\n  LOG(INFO) << \"Server is shutting down\";\n\n  return 0;\n}",
        "func": "int main(int argc, char **argv) {\n  // Version string need to be set before GFLAGS parse arguments\n  GOOGLE_PROTOBUF_VERIFY_VERSION;\n  srand(1);\n\n  // Setup easylogging configurations\n  el::Configurations defaultConf =\n      et::LogHandler::setupLogHandler(&argc, &argv);\n  el::Loggers::setVerboseLevel(3);\n  LogHandler::setupLogFiles(&defaultConf, GetTempDirectory(), \"htmd\", false,\n                            true);\n\n  // Reconfigure default logger to apply settings above\n  el::Loggers::reconfigureLogger(\"default\", defaultConf);\n\n  et::HandleTerminate();\n\n  // Override easylogging handler for sigint\n  ::signal(SIGINT, et::InterruptSignalHandler);\n\n  shared_ptr<SocketHandler> socketHandler(new PipeSocketHandler());\n  SocketEndpoint endpoint;\n  endpoint.set_name(HtmServer::getPipeName());\n  HtmServer htm(socketHandler, endpoint);\n  htm.run();\n  LOG(INFO) << \"Server is shutting down\";\n\n  return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,14 +6,9 @@\n   // Setup easylogging configurations\n   el::Configurations defaultConf =\n       et::LogHandler::setupLogHandler(&argc, &argv);\n-  defaultConf.setGlobally(el::ConfigurationType::ToStandardOutput, \"false\");\n   el::Loggers::setVerboseLevel(3);\n-  // default max log file size is 20MB for etserver\n-  string maxlogsize = \"20971520\";\n-  LogHandler::setupLogFile(&defaultConf, GetTempDirectory() + \"htmd.log\",\n-                           maxlogsize);\n-  // Redirect std streams to a file\n-  LogHandler::stderrToFile(GetTempDirectory() + \"htmd\");\n+  LogHandler::setupLogFiles(&defaultConf, GetTempDirectory(), \"htmd\", false,\n+                            true);\n \n   // Reconfigure default logger to apply settings above\n   el::Loggers::reconfigureLogger(\"default\", defaultConf);",
        "diff_line_info": {
            "deleted_lines": [
                "  defaultConf.setGlobally(el::ConfigurationType::ToStandardOutput, \"false\");",
                "  // default max log file size is 20MB for etserver",
                "  string maxlogsize = \"20971520\";",
                "  LogHandler::setupLogFile(&defaultConf, GetTempDirectory() + \"htmd.log\",",
                "                           maxlogsize);",
                "  // Redirect std streams to a file",
                "  LogHandler::stderrToFile(GetTempDirectory() + \"htmd\");"
            ],
            "added_lines": [
                "  LogHandler::setupLogFiles(&defaultConf, GetTempDirectory(), \"htmd\", false,",
                "                            true);"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-48257",
        "func_name": "MisterTea/EternalTerminal/main",
        "description": "In Eternal Terminal 6.2.1, etserver and etclient have predictable logfile names in /tmp.",
        "git_url": "https://github.com/MisterTea/EternalTerminal/commit/92c4c6ada445c1925a8b397f4171ca7735cbda16",
        "commit_title": "Logfile open mode and permission plus location configurability. (#556)",
        "commit_text": " * Unify logfile names and create with more secure open options and perms.\r \r Fixes #555 (Tribute to Colin McRae)\r \r * Logfile location configurability.\r \r Fixes #555",
        "func_before": "int main(int argc, char** argv) {\n  // Setup easylogging configurations\n  el::Configurations defaultConf = LogHandler::setupLogHandler(&argc, &argv);\n  LogHandler::setupStdoutLogger();\n\n  et::HandleTerminate();\n\n  // Override easylogging handler for sigint\n  ::signal(SIGINT, et::InterruptSignalHandler);\n\n  // Parse command line arguments\n  cxxopts::Options options(\"etterminal\", \"User terminal for Eternal Terminal.\");\n\n  try {\n    options.allow_unrecognised_options();\n\n    options.add_options()         //\n        (\"h,help\", \"Print help\")  //\n        (\"idpasskey\",\n         \"If set, uses IPC to send a client id/key to the server daemon. \"\n         \"Alternatively, pass in via stdin.\",\n         cxxopts::value<std::string>()->default_value(\"\"))  //\n        (\"idpasskeyfile\",\n         \"If set, uses IPC to send a client id/key to the server daemon from a \"\n         \"file. Alternatively, pass in via stdin.\",\n         cxxopts::value<std::string>()->default_value(\"\"))  //\n        (\"jump\",\n         \"If set, forward all packets between client and dst terminal\")  //\n        (\"dsthost\", \"Must be set if jump is set to true\",\n         cxxopts::value<std::string>()->default_value(\"\"))  //\n        (\"dstport\", \"Must be set if jump is set to true\",\n         cxxopts::value<int>()->default_value(\"2022\"))  //\n        // Not used by etterminal but easylogging uses this flag under the hood\n        (\"v,verbose\", \"Enable verbose logging\",\n         cxxopts::value<int>()->default_value(\"0\"))  //\n        (\"logtostdout\", \"Write log to stdout\")       //\n        (\"serverfifo\",\n         \"If set, connects to the etserver instance listening on the matching \"\n         \"fifo name\",                                       //\n         cxxopts::value<std::string>()->default_value(\"\"))  //\n        ;\n\n    auto result = options.parse(argc, argv);\n    if (result.count(\"help\")) {\n      CLOG(INFO, \"stdout\") << options.help({}) << endl;\n      exit(0);\n    }\n\n    el::Loggers::setVerboseLevel(result[\"verbose\"].as<int>());\n\n    if (result.count(\"logtostdout\")) {\n      defaultConf.setGlobally(el::ConfigurationType::ToStandardOutput, \"true\");\n    } else {\n      defaultConf.setGlobally(el::ConfigurationType::ToStandardOutput, \"false\");\n    }\n\n    // default max log file size is 20MB for etserver\n    string maxlogsize = \"20971520\";\n\n    GOOGLE_PROTOBUF_VERIFY_VERSION;\n    srand(1);\n\n    ServerFifoPath serverFifo;\n    if (!result[\"serverfifo\"].as<string>().empty()) {\n      serverFifo.setPathOverride(result[\"serverfifo\"].as<string>());\n    }\n\n    shared_ptr<SocketHandler> ipcSocketHandler(new PipeSocketHandler());\n    shared_ptr<PsuedoUserTerminal> term(new PsuedoUserTerminal());\n\n    string idpasskey;\n    if (result.count(\"idpasskey\") == 0 && result.count(\"idpasskeyfile\") == 0) {\n      // Try to read from stdin\n      struct timeval timeout;\n      timeout.tv_sec = 1;\n      timeout.tv_usec = 0;\n      fd_set readfds;\n      FD_ZERO(&readfds);\n\n      FD_SET(STDIN_FILENO, &readfds);\n\n      int selectResult = 0;\n      do {\n        // Repeatedly calls when interrupted, up to the timeout.\n        selectResult = select(1, &readfds, NULL, NULL, &timeout);\n      } while (selectResult < 0 && errno == EINTR);\n\n      FATAL_FAIL(selectResult);\n      if (selectResult == 0) {\n        CLOG(INFO, \"stdout\")\n            << \"Call etterminal with --idpasskey or --idpasskeyfile, or feed \"\n               \"this information on stdin\\n\";\n        exit(1);\n      }\n\n      string stdinData;\n      if (!getline(cin, stdinData)) {\n        CLOG(INFO, \"stdout\")\n            << \"Call etterminal with --idpasskey or --idpasskeyfile, or feed \"\n               \"this information on stdin\\n\";\n        exit(1);\n      }\n      auto tokens = split(stdinData, '_');\n      if (tokens.size() == 2) {\n        idpasskey = tokens[0];\n        if (idpasskey.substr(0, 3) == std::string(\"XXX\")) {\n          // New client connecting to new server, throw away passkey and\n          // regenerate\n          string passkey = genRandomAlphaNum(32);\n          string id = genRandomAlphaNum(16);\n          idpasskey = id + string(\"/\") + passkey;\n        }\n\n        FATAL_FAIL(setenv(\"TERM\", tokens[1].c_str(), 1));\n      } else {\n        STFATAL << \"Invalid number of tokens: \" << tokens.size();\n      }\n    } else {\n      string idpasskey = result[\"idpasskey\"].as<string>();\n      if (result.count(\"idpasskeyfile\")) {\n        // Check for passkey file\n        std::ifstream t(result[\"idpasskeyfile\"].as<string>().c_str());\n        std::stringstream buffer;\n        buffer << t.rdbuf();\n        idpasskey = buffer.str();\n        // Trim whitespace\n        idpasskey.erase(idpasskey.find_last_not_of(\" \\n\\r\\t\") + 1);\n      }\n    }\n\n    string id = split(idpasskey, '/')[0];\n    string username = string(ssh_get_local_username());\n    if (result.count(\"jump\")) {\n      // etserver with --jump cannot write to the default log file(root)\n      LogHandler::setupLogFile(\n          &defaultConf,\n          GetTempDirectory() + \"etjump-\" + username + \"-\" + id + \".log\",\n          maxlogsize);\n      // Reconfigure default logger to apply settings above\n      el::Loggers::reconfigureLogger(\"default\", defaultConf);\n      // set thread name\n      el::Helpers::setThreadName(\"jump-main\");\n      // Install log rotation callback\n      el::Helpers::installPreRollOutCallback(LogHandler::rolloutHandler);\n\n      CLOG(INFO, \"stdout\") << \"IDPASSKEY:\" << idpasskey << endl;\n      if (DaemonCreator::createSessionLeader() == -1) {\n        STFATAL << \"Error creating daemon: \" << strerror(GetErrno());\n      }\n      SocketEndpoint destinationEndpoint;\n      destinationEndpoint.set_name(result[\"dsthost\"].as<string>());\n      destinationEndpoint.set_port(result[\"dstport\"].as<int>());\n      shared_ptr<SocketHandler> jumpClientSocketHandler(new TcpSocketHandler());\n      UserJumphostHandler ujh(jumpClientSocketHandler, idpasskey,\n                              destinationEndpoint, ipcSocketHandler,\n                              serverFifo.getEndpointForConnect());\n      ujh.run();\n\n      // Uninstall log rotation callback\n      el::Helpers::uninstallPreRollOutCallback();\n      return 0;\n    }\n\n    // etserver with --idpasskey cannot write to the default log file(root)\n    LogHandler::setupLogFile(\n        &defaultConf,\n        GetTempDirectory() + \"etterminal-\" + username + \"-\" + id + \".log\",\n        maxlogsize);\n    // Reconfigure default logger to apply settings above\n    el::Loggers::reconfigureLogger(\"default\", defaultConf);\n    // set thread name\n    el::Helpers::setThreadName(\"terminal-main\");\n    // Install log rotation callback\n    el::Helpers::installPreRollOutCallback(LogHandler::rolloutHandler);\n\n    UserTerminalHandler uth(ipcSocketHandler, term, true,\n                            serverFifo.getEndpointForConnect(), idpasskey);\n    CLOG(INFO, \"stdout\") << \"IDPASSKEY:\" << idpasskey << endl;\n    if (DaemonCreator::createSessionLeader() == -1) {\n      STFATAL << \"Error creating daemon: \" << strerror(GetErrno());\n    }\n    uth.run();\n\n  } catch (cxxopts::OptionException& oe) {\n    CLOG(INFO, \"stdout\") << \"Exception: \" << oe.what() << \"\\n\" << endl;\n    CLOG(INFO, \"stdout\") << options.help({}) << endl;\n    exit(1);\n  }\n\n  // Uninstall log rotation callback\n  el::Helpers::uninstallPreRollOutCallback();\n  return 0;\n}",
        "func": "int main(int argc, char** argv) {\n  // Setup easylogging configurations\n  el::Configurations defaultConf = LogHandler::setupLogHandler(&argc, &argv);\n  LogHandler::setupStdoutLogger();\n\n  et::HandleTerminate();\n\n  // Override easylogging handler for sigint\n  ::signal(SIGINT, et::InterruptSignalHandler);\n\n  // Parse command line arguments\n  cxxopts::Options options(\"etterminal\", \"User terminal for Eternal Terminal.\");\n\n  try {\n    options.allow_unrecognised_options();\n\n    options.add_options()         //\n        (\"h,help\", \"Print help\")  //\n        (\"idpasskey\",\n         \"If set, uses IPC to send a client id/key to the server daemon. \"\n         \"Alternatively, pass in via stdin.\",\n         cxxopts::value<std::string>()->default_value(\"\"))  //\n        (\"idpasskeyfile\",\n         \"If set, uses IPC to send a client id/key to the server daemon from a \"\n         \"file. Alternatively, pass in via stdin.\",\n         cxxopts::value<std::string>()->default_value(\"\"))  //\n        (\"jump\",\n         \"If set, forward all packets between client and dst terminal\")  //\n        (\"dsthost\", \"Must be set if jump is set to true\",\n         cxxopts::value<std::string>()->default_value(\"\"))  //\n        (\"dstport\", \"Must be set if jump is set to true\",\n         cxxopts::value<int>()->default_value(\"2022\"))  //\n        // Not used by etterminal but easylogging uses this flag under the hood\n        (\"v,verbose\", \"Enable verbose logging\",\n         cxxopts::value<int>()->default_value(\"0\"))  //\n        (\"l,logdir\", \"Base directory for log files.\",\n         cxxopts::value<std::string>()->default_value(GetTempDirectory()))  //\n        (\"logtostdout\", \"Write log to stdout\")                              //\n        (\"serverfifo\",\n         \"If set, connects to the etserver instance listening on the matching \"\n         \"fifo name\",                                       //\n         cxxopts::value<std::string>()->default_value(\"\"))  //\n        ;\n\n    auto result = options.parse(argc, argv);\n    if (result.count(\"help\")) {\n      CLOG(INFO, \"stdout\") << options.help({}) << endl;\n      exit(0);\n    }\n\n    el::Loggers::setVerboseLevel(result[\"verbose\"].as<int>());\n\n    GOOGLE_PROTOBUF_VERIFY_VERSION;\n    srand(1);\n\n    ServerFifoPath serverFifo;\n    if (!result[\"serverfifo\"].as<string>().empty()) {\n      serverFifo.setPathOverride(result[\"serverfifo\"].as<string>());\n    }\n\n    shared_ptr<SocketHandler> ipcSocketHandler(new PipeSocketHandler());\n    shared_ptr<PsuedoUserTerminal> term(new PsuedoUserTerminal());\n\n    string idpasskey;\n    if (result.count(\"idpasskey\") == 0 && result.count(\"idpasskeyfile\") == 0) {\n      // Try to read from stdin\n      struct timeval timeout;\n      timeout.tv_sec = 1;\n      timeout.tv_usec = 0;\n      fd_set readfds;\n      FD_ZERO(&readfds);\n\n      FD_SET(STDIN_FILENO, &readfds);\n\n      int selectResult = 0;\n      do {\n        // Repeatedly calls when interrupted, up to the timeout.\n        selectResult = select(1, &readfds, NULL, NULL, &timeout);\n      } while (selectResult < 0 && errno == EINTR);\n\n      FATAL_FAIL(selectResult);\n      if (selectResult == 0) {\n        CLOG(INFO, \"stdout\")\n            << \"Call etterminal with --idpasskey or --idpasskeyfile, or feed \"\n               \"this information on stdin\\n\";\n        exit(1);\n      }\n\n      string stdinData;\n      if (!getline(cin, stdinData)) {\n        CLOG(INFO, \"stdout\")\n            << \"Call etterminal with --idpasskey or --idpasskeyfile, or feed \"\n               \"this information on stdin\\n\";\n        exit(1);\n      }\n      auto tokens = split(stdinData, '_');\n      if (tokens.size() == 2) {\n        idpasskey = tokens[0];\n        if (idpasskey.substr(0, 3) == std::string(\"XXX\")) {\n          // New client connecting to new server, throw away passkey and\n          // regenerate\n          string passkey = genRandomAlphaNum(32);\n          string id = genRandomAlphaNum(16);\n          idpasskey = id + string(\"/\") + passkey;\n        }\n\n        FATAL_FAIL(setenv(\"TERM\", tokens[1].c_str(), 1));\n      } else {\n        STFATAL << \"Invalid number of tokens: \" << tokens.size();\n      }\n    } else {\n      string idpasskey = result[\"idpasskey\"].as<string>();\n      if (result.count(\"idpasskeyfile\")) {\n        // Check for passkey file\n        std::ifstream t(result[\"idpasskeyfile\"].as<string>().c_str());\n        std::stringstream buffer;\n        buffer << t.rdbuf();\n        idpasskey = buffer.str();\n        // Trim whitespace\n        idpasskey.erase(idpasskey.find_last_not_of(\" \\n\\r\\t\") + 1);\n      }\n    }\n\n    string id = split(idpasskey, '/')[0];\n    string username = string(ssh_get_local_username());\n    if (result.count(\"jump\")) {\n      // etserver with --jump cannot write to the default log file(root)\n      LogHandler::setupLogFiles(&defaultConf, result[\"logdir\"].as<string>(),\n                                (\"etjump-\" + username + \"-\" + id),\n                                result.count(\"logtostdout\"), false);\n      // Reconfigure default logger to apply settings above\n      el::Loggers::reconfigureLogger(\"default\", defaultConf);\n      // set thread name\n      el::Helpers::setThreadName(\"jump-main\");\n      // Install log rotation callback\n      el::Helpers::installPreRollOutCallback(LogHandler::rolloutHandler);\n\n      CLOG(INFO, \"stdout\") << \"IDPASSKEY:\" << idpasskey << endl;\n      if (DaemonCreator::createSessionLeader() == -1) {\n        STFATAL << \"Error creating daemon: \" << strerror(GetErrno());\n      }\n      SocketEndpoint destinationEndpoint;\n      destinationEndpoint.set_name(result[\"dsthost\"].as<string>());\n      destinationEndpoint.set_port(result[\"dstport\"].as<int>());\n      shared_ptr<SocketHandler> jumpClientSocketHandler(new TcpSocketHandler());\n      UserJumphostHandler ujh(jumpClientSocketHandler, idpasskey,\n                              destinationEndpoint, ipcSocketHandler,\n                              serverFifo.getEndpointForConnect());\n      ujh.run();\n\n      // Uninstall log rotation callback\n      el::Helpers::uninstallPreRollOutCallback();\n      return 0;\n    }\n\n    // etserver with --idpasskey cannot write to the default log file(root)\n    LogHandler::setupLogFiles(&defaultConf, result[\"logdir\"].as<string>(),\n                              (\"etterminal-\" + username + \"-\" + id),\n                              result.count(\"logtostdout\"), false);\n\n    // Reconfigure default logger to apply settings above\n    el::Loggers::reconfigureLogger(\"default\", defaultConf);\n    // set thread name\n    el::Helpers::setThreadName(\"terminal-main\");\n    // Install log rotation callback\n    el::Helpers::installPreRollOutCallback(LogHandler::rolloutHandler);\n\n    UserTerminalHandler uth(ipcSocketHandler, term, true,\n                            serverFifo.getEndpointForConnect(), idpasskey);\n    CLOG(INFO, \"stdout\") << \"IDPASSKEY:\" << idpasskey << endl;\n    if (DaemonCreator::createSessionLeader() == -1) {\n      STFATAL << \"Error creating daemon: \" << strerror(GetErrno());\n    }\n    uth.run();\n\n  } catch (cxxopts::OptionException& oe) {\n    CLOG(INFO, \"stdout\") << \"Exception: \" << oe.what() << \"\\n\" << endl;\n    CLOG(INFO, \"stdout\") << options.help({}) << endl;\n    exit(1);\n  }\n\n  // Uninstall log rotation callback\n  el::Helpers::uninstallPreRollOutCallback();\n  return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -33,7 +33,9 @@\n         // Not used by etterminal but easylogging uses this flag under the hood\n         (\"v,verbose\", \"Enable verbose logging\",\n          cxxopts::value<int>()->default_value(\"0\"))  //\n-        (\"logtostdout\", \"Write log to stdout\")       //\n+        (\"l,logdir\", \"Base directory for log files.\",\n+         cxxopts::value<std::string>()->default_value(GetTempDirectory()))  //\n+        (\"logtostdout\", \"Write log to stdout\")                              //\n         (\"serverfifo\",\n          \"If set, connects to the etserver instance listening on the matching \"\n          \"fifo name\",                                       //\n@@ -47,15 +49,6 @@\n     }\n \n     el::Loggers::setVerboseLevel(result[\"verbose\"].as<int>());\n-\n-    if (result.count(\"logtostdout\")) {\n-      defaultConf.setGlobally(el::ConfigurationType::ToStandardOutput, \"true\");\n-    } else {\n-      defaultConf.setGlobally(el::ConfigurationType::ToStandardOutput, \"false\");\n-    }\n-\n-    // default max log file size is 20MB for etserver\n-    string maxlogsize = \"20971520\";\n \n     GOOGLE_PROTOBUF_VERIFY_VERSION;\n     srand(1);\n@@ -132,10 +125,9 @@\n     string username = string(ssh_get_local_username());\n     if (result.count(\"jump\")) {\n       // etserver with --jump cannot write to the default log file(root)\n-      LogHandler::setupLogFile(\n-          &defaultConf,\n-          GetTempDirectory() + \"etjump-\" + username + \"-\" + id + \".log\",\n-          maxlogsize);\n+      LogHandler::setupLogFiles(&defaultConf, result[\"logdir\"].as<string>(),\n+                                (\"etjump-\" + username + \"-\" + id),\n+                                result.count(\"logtostdout\"), false);\n       // Reconfigure default logger to apply settings above\n       el::Loggers::reconfigureLogger(\"default\", defaultConf);\n       // set thread name\n@@ -162,10 +154,10 @@\n     }\n \n     // etserver with --idpasskey cannot write to the default log file(root)\n-    LogHandler::setupLogFile(\n-        &defaultConf,\n-        GetTempDirectory() + \"etterminal-\" + username + \"-\" + id + \".log\",\n-        maxlogsize);\n+    LogHandler::setupLogFiles(&defaultConf, result[\"logdir\"].as<string>(),\n+                              (\"etterminal-\" + username + \"-\" + id),\n+                              result.count(\"logtostdout\"), false);\n+\n     // Reconfigure default logger to apply settings above\n     el::Loggers::reconfigureLogger(\"default\", defaultConf);\n     // set thread name",
        "diff_line_info": {
            "deleted_lines": [
                "        (\"logtostdout\", \"Write log to stdout\")       //",
                "",
                "    if (result.count(\"logtostdout\")) {",
                "      defaultConf.setGlobally(el::ConfigurationType::ToStandardOutput, \"true\");",
                "    } else {",
                "      defaultConf.setGlobally(el::ConfigurationType::ToStandardOutput, \"false\");",
                "    }",
                "",
                "    // default max log file size is 20MB for etserver",
                "    string maxlogsize = \"20971520\";",
                "      LogHandler::setupLogFile(",
                "          &defaultConf,",
                "          GetTempDirectory() + \"etjump-\" + username + \"-\" + id + \".log\",",
                "          maxlogsize);",
                "    LogHandler::setupLogFile(",
                "        &defaultConf,",
                "        GetTempDirectory() + \"etterminal-\" + username + \"-\" + id + \".log\",",
                "        maxlogsize);"
            ],
            "added_lines": [
                "        (\"l,logdir\", \"Base directory for log files.\",",
                "         cxxopts::value<std::string>()->default_value(GetTempDirectory()))  //",
                "        (\"logtostdout\", \"Write log to stdout\")                              //",
                "      LogHandler::setupLogFiles(&defaultConf, result[\"logdir\"].as<string>(),",
                "                                (\"etjump-\" + username + \"-\" + id),",
                "                                result.count(\"logtostdout\"), false);",
                "    LogHandler::setupLogFiles(&defaultConf, result[\"logdir\"].as<string>(),",
                "                              (\"etterminal-\" + username + \"-\" + id),",
                "                              result.count(\"logtostdout\"), false);",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2022-48257",
        "func_name": "MisterTea/EternalTerminal/main",
        "description": "In Eternal Terminal 6.2.1, etserver and etclient have predictable logfile names in /tmp.",
        "git_url": "https://github.com/MisterTea/EternalTerminal/commit/92c4c6ada445c1925a8b397f4171ca7735cbda16",
        "commit_title": "Logfile open mode and permission plus location configurability. (#556)",
        "commit_text": " * Unify logfile names and create with more secure open options and perms.\r \r Fixes #555 (Tribute to Colin McRae)\r \r * Logfile location configurability.\r \r Fixes #555",
        "func_before": "int main(int argc, char** argv) {\n  GOOGLE_PROTOBUF_VERIFY_VERSION;\n  srand(1);\n  // Parse command line arguments\n  cxxopts::Options options(\"htm\", \"Headless terminal multiplexer\");\n  options.allow_unrecognised_options();\n\n  options.add_options()       //\n      (\"help\", \"Print help\")  //\n      (\"x,kill-other-sessions\",\n       \"kill all old sessions belonging to the user\")  //\n      ;\n\n  auto result = options.parse(argc, argv);\n  if (result.count(\"help\")) {\n    CLOG(INFO, \"stdout\") << options.help({}) << endl;\n    exit(0);\n  }\n\n  setvbuf(stdin, NULL, _IONBF, 0);   // turn off buffering\n  setvbuf(stdout, NULL, _IONBF, 0);  // turn off buffering\n\n  // Turn on raw terminal mode\n  termios terminal_local;\n  tcgetattr(0, &terminal_local);\n  memcpy(&terminal_backup, &terminal_local, sizeof(struct termios));\n  cfmakeraw(&terminal_local);\n  tcsetattr(0, TCSANOW, &terminal_local);\n\n  // Catch sigterm and send exit control code\n  struct sigaction action;\n  memset(&action, 0, sizeof(struct sigaction));\n  action.sa_handler = term;\n  sigaction(SIGTERM, &action, NULL);\n\n  // Setup easylogging configurations\n  el::Configurations defaultConf = LogHandler::setupLogHandler(&argc, &argv);\n  defaultConf.setGlobally(el::ConfigurationType::ToStandardOutput, \"false\");\n  el::Loggers::setVerboseLevel(3);\n  // default max log file size is 20MB for etserver\n  string maxlogsize = \"20971520\";\n  LogHandler::setupLogFile(&defaultConf, GetTempDirectory() + \"htm.log\",\n                           maxlogsize);\n  // Redirect std streams to a file\n  LogHandler::stderrToFile(GetTempDirectory() + \"htm\");\n\n  // Reconfigure default logger to apply settings above\n  el::Loggers::reconfigureLogger(\"default\", defaultConf);\n\n  et::HandleTerminate();\n\n  // Override easylogging handler for sigint\n  ::signal(SIGINT, et::InterruptSignalHandler);\n\n  uid_t myuid = getuid();\n  if (result.count(\"x\")) {\n    LOG(INFO) << \"Killing previous htmd\";\n    // Kill previous htm daemon\n    string command =\n        string(\"pkill -x -U \") + to_string(myuid) + string(\" htmd\");\n    system(command.c_str());\n  }\n\n  // Check if daemon exists\n  string command = string(\"pgrep -x -U \") + to_string(myuid) + string(\" htmd\");\n  string pgrepOutput = SystemToStr(command.c_str());\n\n  if (pgrepOutput.length() == 0) {\n    // Fork to create the daemon\n    int result = DaemonCreator::create(false, \"\");\n    if (result == DaemonCreator::CHILD) {\n      // This means we are the daemon\n      exit(system(\"htmd\"));\n    }\n  }\n\n  // This means we are the client to the daemon\n  std::this_thread::sleep_for(std::chrono::microseconds(\n      10 * 1000));  // Sleep for 10ms to let the daemon come alive\n  shared_ptr<SocketHandler> socketHandler(new PipeSocketHandler());\n  SocketEndpoint pipeEndpoint;\n  pipeEndpoint.set_name(HtmServer::getPipeName());\n  HtmClient htmClient(socketHandler, pipeEndpoint);\n  htmClient.run();\n\n  char buf[] = {\n      0x1b, 0x5b, '$', '$', '$', 'q',\n  };\n  RawSocketUtils::writeAll(STDOUT_FILENO, buf, sizeof(buf));\n  fflush(stdout);\n  tcsetattr(0, TCSANOW, &terminal_backup);\n\n  return 0;\n}",
        "func": "int main(int argc, char** argv) {\n  GOOGLE_PROTOBUF_VERIFY_VERSION;\n  srand(1);\n  // Parse command line arguments\n  cxxopts::Options options(\"htm\", \"Headless terminal multiplexer\");\n  options.allow_unrecognised_options();\n\n  options.add_options()       //\n      (\"help\", \"Print help\")  //\n      (\"x,kill-other-sessions\",\n       \"kill all old sessions belonging to the user\")  //\n      ;\n\n  auto result = options.parse(argc, argv);\n  if (result.count(\"help\")) {\n    CLOG(INFO, \"stdout\") << options.help({}) << endl;\n    exit(0);\n  }\n\n  setvbuf(stdin, NULL, _IONBF, 0);   // turn off buffering\n  setvbuf(stdout, NULL, _IONBF, 0);  // turn off buffering\n\n  // Turn on raw terminal mode\n  termios terminal_local;\n  tcgetattr(0, &terminal_local);\n  memcpy(&terminal_backup, &terminal_local, sizeof(struct termios));\n  cfmakeraw(&terminal_local);\n  tcsetattr(0, TCSANOW, &terminal_local);\n\n  // Catch sigterm and send exit control code\n  struct sigaction action;\n  memset(&action, 0, sizeof(struct sigaction));\n  action.sa_handler = term;\n  sigaction(SIGTERM, &action, NULL);\n\n  // Setup easylogging configurations\n  el::Configurations defaultConf = LogHandler::setupLogHandler(&argc, &argv);\n  el::Loggers::setVerboseLevel(3);\n  LogHandler::setupLogFiles(&defaultConf, GetTempDirectory(), \"htm\", false,\n                            true);\n\n  // Reconfigure default logger to apply settings above\n  el::Loggers::reconfigureLogger(\"default\", defaultConf);\n\n  et::HandleTerminate();\n\n  // Override easylogging handler for sigint\n  ::signal(SIGINT, et::InterruptSignalHandler);\n\n  uid_t myuid = getuid();\n  if (result.count(\"x\")) {\n    LOG(INFO) << \"Killing previous htmd\";\n    // Kill previous htm daemon\n    string command =\n        string(\"pkill -x -U \") + to_string(myuid) + string(\" htmd\");\n    system(command.c_str());\n  }\n\n  // Check if daemon exists\n  string command = string(\"pgrep -x -U \") + to_string(myuid) + string(\" htmd\");\n  string pgrepOutput = SystemToStr(command.c_str());\n\n  if (pgrepOutput.length() == 0) {\n    // Fork to create the daemon\n    int result = DaemonCreator::create(false, \"\");\n    if (result == DaemonCreator::CHILD) {\n      // This means we are the daemon\n      exit(system(\"htmd\"));\n    }\n  }\n\n  // This means we are the client to the daemon\n  std::this_thread::sleep_for(std::chrono::microseconds(\n      10 * 1000));  // Sleep for 10ms to let the daemon come alive\n  shared_ptr<SocketHandler> socketHandler(new PipeSocketHandler());\n  SocketEndpoint pipeEndpoint;\n  pipeEndpoint.set_name(HtmServer::getPipeName());\n  HtmClient htmClient(socketHandler, pipeEndpoint);\n  htmClient.run();\n\n  char buf[] = {\n      0x1b, 0x5b, '$', '$', '$', 'q',\n  };\n  RawSocketUtils::writeAll(STDOUT_FILENO, buf, sizeof(buf));\n  fflush(stdout);\n  tcsetattr(0, TCSANOW, &terminal_backup);\n\n  return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -35,14 +35,9 @@\n \n   // Setup easylogging configurations\n   el::Configurations defaultConf = LogHandler::setupLogHandler(&argc, &argv);\n-  defaultConf.setGlobally(el::ConfigurationType::ToStandardOutput, \"false\");\n   el::Loggers::setVerboseLevel(3);\n-  // default max log file size is 20MB for etserver\n-  string maxlogsize = \"20971520\";\n-  LogHandler::setupLogFile(&defaultConf, GetTempDirectory() + \"htm.log\",\n-                           maxlogsize);\n-  // Redirect std streams to a file\n-  LogHandler::stderrToFile(GetTempDirectory() + \"htm\");\n+  LogHandler::setupLogFiles(&defaultConf, GetTempDirectory(), \"htm\", false,\n+                            true);\n \n   // Reconfigure default logger to apply settings above\n   el::Loggers::reconfigureLogger(\"default\", defaultConf);",
        "diff_line_info": {
            "deleted_lines": [
                "  defaultConf.setGlobally(el::ConfigurationType::ToStandardOutput, \"false\");",
                "  // default max log file size is 20MB for etserver",
                "  string maxlogsize = \"20971520\";",
                "  LogHandler::setupLogFile(&defaultConf, GetTempDirectory() + \"htm.log\",",
                "                           maxlogsize);",
                "  // Redirect std streams to a file",
                "  LogHandler::stderrToFile(GetTempDirectory() + \"htm\");"
            ],
            "added_lines": [
                "  LogHandler::setupLogFiles(&defaultConf, GetTempDirectory(), \"htm\", false,",
                "                            true);"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-48257",
        "func_name": "MisterTea/EternalTerminal/main",
        "description": "In Eternal Terminal 6.2.1, etserver and etclient have predictable logfile names in /tmp.",
        "git_url": "https://github.com/MisterTea/EternalTerminal/commit/92c4c6ada445c1925a8b397f4171ca7735cbda16",
        "commit_title": "Logfile open mode and permission plus location configurability. (#556)",
        "commit_text": " * Unify logfile names and create with more secure open options and perms.\r \r Fixes #555 (Tribute to Colin McRae)\r \r * Logfile location configurability.\r \r Fixes #555",
        "func_before": "int main(int argc, char **argv) {\n  // Setup easylogging configurations\n  el::Configurations defaultConf = LogHandler::setupLogHandler(&argc, &argv);\n  LogHandler::setupStdoutLogger();\n\n  et::HandleTerminate();\n\n  // Override easylogging handler for sigint\n  ::signal(SIGINT, et::InterruptSignalHandler);\n\n  cxxopts::Options options(\"etserver\",\n                           \"Remote shell for the busy and impatient\");\n  try {\n    // Parse command line arguments\n    options.allow_unrecognised_options();\n\n    options.add_options()             //\n        (\"h,help\", \"Print help\")      //\n        (\"version\", \"Print version\")  //\n        (\"port\", \"Port to listen on\",\n         cxxopts::value<int>()->default_value(\"0\"))  //\n        (\"bindip\", \"IP to listen on\",\n         cxxopts::value<string>()->default_value(\"\"))  //\n        (\"daemon\", \"Daemonize the server\")             //\n        (\"cfgfile\", \"Location of the config file\",\n         cxxopts::value<std::string>()->default_value(\"\"))  //\n        (\"logtostdout\", \"log to stdout\")                    //\n        (\"pidfile\", \"Location of the pid file\",\n         cxxopts::value<std::string>()->default_value(\n             \"/var/run/etserver.pid\"))  //\n        (\"v,verbose\", \"Enable verbose logging\",\n         cxxopts::value<int>()->default_value(\"0\"), \"LEVEL\")  //\n        (\"serverfifo\",\n         \"If set, listens on the matching fifo name\",       //\n         cxxopts::value<std::string>()->default_value(\"\"))  //\n        (\"telemetry\",\n         \"Allow et to anonymously send errors to guide future improvements\",\n         cxxopts::value<bool>())  //\n        ;\n\n    auto result = options.parse(argc, argv);\n\n    if (result.count(\"help\")) {\n      CLOG(INFO, \"stdout\") << options.help({}) << endl;\n      exit(0);\n    }\n    if (result.count(\"version\")) {\n      CLOG(INFO, \"stdout\") << \"et version \" << ET_VERSION << endl;\n      exit(0);\n    }\n\n    el::Loggers::setVerboseLevel(result[\"verbose\"].as<int>());\n\n    if (result.count(\"daemon\")) {\n      if (DaemonCreator::create(true, result[\"pidfile\"].as<string>()) == -1) {\n        STFATAL << \"Error creating daemon: \" << strerror(GetErrno());\n      }\n    }\n\n    if (result.count(\"logtostdout\")) {\n      defaultConf.setGlobally(el::ConfigurationType::ToStandardOutput, \"true\");\n    } else {\n      defaultConf.setGlobally(el::ConfigurationType::ToStandardOutput, \"false\");\n      // Redirect std streams to a file\n      LogHandler::stderrToFile(GetTempDirectory() + \"etserver\");\n    }\n\n    ServerFifoPath serverFifo;\n\n    // default max log file size is 20MB for etserver\n    string maxlogsize = \"20971520\";\n\n    int port = 0;\n    string bindIp = \"\";\n    bool telemetry = false;\n    if (result.count(\"cfgfile\")) {\n      // Load the config file\n      CSimpleIniA ini(true, false, false);\n      string cfgfilename = result[\"cfgfile\"].as<string>();\n      SI_Error rc = ini.LoadFile(cfgfilename.c_str());\n      if (rc == 0) {\n        if (!result.count(\"port\")) {\n          const char *portString = ini.GetValue(\"Networking\", \"port\", NULL);\n          if (portString) {\n            port = stoi(portString);\n          }\n        }\n\n        if (!result.count(\"bindip\")) {\n          const char *bindIpPtr = ini.GetValue(\"Networking\", \"bind_ip\", NULL);\n          if (bindIpPtr) {\n            bindIp = string(bindIpPtr);\n          }\n        }\n\n        telemetry = ini.GetBoolValue(\"Debug\", \"telemetry\", false);\n        // read verbose level (prioritize command line option over cfgfile)\n        const char *vlevel = ini.GetValue(\"Debug\", \"verbose\", NULL);\n        if (result.count(\"verbose\")) {\n          el::Loggers::setVerboseLevel(result[\"verbose\"].as<int>());\n        } else if (vlevel) {\n          el::Loggers::setVerboseLevel(atoi(vlevel));\n        }\n\n        const char *fifoName = ini.GetValue(\"Debug\", \"serverfifo\", NULL);\n        if (fifoName) {\n          const string fifoNameStr(fifoName);\n          if (!fifoNameStr.empty()) {\n            serverFifo.setPathOverride(fifoNameStr);\n          }\n        }\n\n        // read silent setting\n        const char *silent = ini.GetValue(\"Debug\", \"silent\", NULL);\n        if (silent && atoi(silent) != 0) {\n          defaultConf.setGlobally(el::ConfigurationType::Enabled, \"false\");\n        }\n        // read log file size limit\n        const char *logsize = ini.GetValue(\"Debug\", \"logsize\", NULL);\n        if (logsize && atoi(logsize) != 0) {\n          // make sure maxlogsize is a string of int value\n          maxlogsize = string(logsize);\n        }\n\n      } else {\n        STFATAL << \"Invalid config file: \" << cfgfilename;\n      }\n    }\n\n    if (result.count(\"serverfifo\") &&\n        !result[\"serverfifo\"].as<string>().empty()) {\n      serverFifo.setPathOverride(result[\"serverfifo\"].as<string>());\n    }\n\n    if (result.count(\"port\")) {\n      port = result[\"port\"].as<int>();\n    }\n\n    if (result.count(\"bindip\")) {\n      bindIp = result[\"bindip\"].as<string>();\n    }\n\n    if (result.count(\"telemetry\")) {\n      telemetry = result[\"telemetry\"].as<bool>();\n    }\n\n    GOOGLE_PROTOBUF_VERIFY_VERSION;\n    srand(1);\n\n    if (port == 0) {\n      port = 2022;\n    }\n\n    // Set log file for etserver process here.\n    LogHandler::setupLogFile(&defaultConf,\n                             GetTempDirectory() + \"etserver-%datetime.log\",\n                             maxlogsize);\n    // Reconfigure default logger to apply settings above\n    el::Loggers::reconfigureLogger(\"default\", defaultConf);\n    // set thread name\n    el::Helpers::setThreadName(\"etserver-main\");\n    // Install log rotation callback\n    el::Helpers::installPreRollOutCallback(LogHandler::rolloutHandler);\n\n    TelemetryService::create(\n        telemetry, GetTempDirectory() + \"/.sentry-native-etserver\", \"Server\");\n\n    serverFifo.createDirectoriesIfRequired();\n\n    std::shared_ptr<SocketHandler> tcpSocketHandler(new TcpSocketHandler());\n    std::shared_ptr<PipeSocketHandler> pipeSocketHandler(\n        new PipeSocketHandler());\n\n    LOG(INFO) << \"In child, about to start server.\";\n\n    SocketEndpoint serverEndpoint;\n    serverEndpoint.set_port(port);\n    if (bindIp.length()) {\n      serverEndpoint.set_name(bindIp);\n    }\n    SocketEndpoint routerFifo;\n    routerFifo.set_name(serverFifo.getPathForCreation());\n    TerminalServer terminalServer(tcpSocketHandler, serverEndpoint,\n                                  pipeSocketHandler, routerFifo);\n    terminalServer.run();\n\n  } catch (cxxopts::OptionException &oe) {\n    CLOG(INFO, \"stdout\") << \"Exception: \" << oe.what() << \"\\n\" << endl;\n    CLOG(INFO, \"stdout\") << options.help({}) << endl;\n    exit(1);\n  }\n\n  // Uninstall log rotation callback\n  el::Helpers::uninstallPreRollOutCallback();\n}",
        "func": "int main(int argc, char **argv) {\n  // Setup easylogging configurations\n  el::Configurations defaultConf = LogHandler::setupLogHandler(&argc, &argv);\n  LogHandler::setupStdoutLogger();\n\n  et::HandleTerminate();\n\n  // Override easylogging handler for sigint\n  ::signal(SIGINT, et::InterruptSignalHandler);\n\n  cxxopts::Options options(\"etserver\",\n                           \"Remote shell for the busy and impatient\");\n  try {\n    // Parse command line arguments\n    options.allow_unrecognised_options();\n\n    options.add_options()             //\n        (\"h,help\", \"Print help\")      //\n        (\"version\", \"Print version\")  //\n        (\"port\", \"Port to listen on\",\n         cxxopts::value<int>()->default_value(\"0\"))  //\n        (\"bindip\", \"IP to listen on\",\n         cxxopts::value<string>()->default_value(\"\"))  //\n        (\"daemon\", \"Daemonize the server\")             //\n        (\"cfgfile\", \"Location of the config file\",\n         cxxopts::value<std::string>()->default_value(\"\"))  //\n        (\"l,logdir\", \"Base directory for log files.\",\n         cxxopts::value<std::string>())   //\n        (\"logtostdout\", \"log to stdout\")  //\n        (\"pidfile\", \"Location of the pid file\",\n         cxxopts::value<std::string>()->default_value(\n             \"/var/run/etserver.pid\"))  //\n        (\"v,verbose\", \"Enable verbose logging\",\n         cxxopts::value<int>()->default_value(\"0\"), \"LEVEL\")  //\n        (\"serverfifo\",\n         \"If set, listens on the matching fifo name\",       //\n         cxxopts::value<std::string>()->default_value(\"\"))  //\n        (\"telemetry\",\n         \"Allow et to anonymously send errors to guide future improvements\",\n         cxxopts::value<bool>())  //\n        ;\n\n    auto result = options.parse(argc, argv);\n\n    if (result.count(\"help\")) {\n      CLOG(INFO, \"stdout\") << options.help({}) << endl;\n      exit(0);\n    }\n    if (result.count(\"version\")) {\n      CLOG(INFO, \"stdout\") << \"et version \" << ET_VERSION << endl;\n      exit(0);\n    }\n\n    el::Loggers::setVerboseLevel(result[\"verbose\"].as<int>());\n\n    if (result.count(\"daemon\")) {\n      if (DaemonCreator::create(true, result[\"pidfile\"].as<string>()) == -1) {\n        STFATAL << \"Error creating daemon: \" << strerror(GetErrno());\n      }\n    }\n\n    ServerFifoPath serverFifo;\n\n    // default max log file size is 20MB for etserver\n    string maxlogsize = \"20971520\";\n\n    int port = 0;\n    string bindIp = \"\";\n    bool telemetry = false;\n    string logDirectory = GetTempDirectory();\n    if (result.count(\"cfgfile\")) {\n      // Load the config file\n      CSimpleIniA ini(true, false, false);\n      string cfgfilename = result[\"cfgfile\"].as<string>();\n      SI_Error rc = ini.LoadFile(cfgfilename.c_str());\n      if (rc == 0) {\n        if (!result.count(\"port\")) {\n          const char *portString = ini.GetValue(\"Networking\", \"port\", NULL);\n          if (portString) {\n            port = stoi(portString);\n          }\n        }\n\n        if (!result.count(\"bindip\")) {\n          const char *bindIpPtr = ini.GetValue(\"Networking\", \"bind_ip\", NULL);\n          if (bindIpPtr) {\n            bindIp = string(bindIpPtr);\n          }\n        }\n\n        telemetry = ini.GetBoolValue(\"Debug\", \"telemetry\", false);\n        // read verbose level (prioritize command line option over cfgfile)\n        const char *vlevel = ini.GetValue(\"Debug\", \"verbose\", NULL);\n        if (result.count(\"verbose\")) {\n          el::Loggers::setVerboseLevel(result[\"verbose\"].as<int>());\n        } else if (vlevel) {\n          el::Loggers::setVerboseLevel(atoi(vlevel));\n        }\n\n        const char *fifoName = ini.GetValue(\"Debug\", \"serverfifo\", NULL);\n        if (fifoName) {\n          const string fifoNameStr(fifoName);\n          if (!fifoNameStr.empty()) {\n            serverFifo.setPathOverride(fifoNameStr);\n          }\n        }\n\n        // read silent setting\n        const char *silent = ini.GetValue(\"Debug\", \"silent\", NULL);\n        if (silent && atoi(silent) != 0) {\n          defaultConf.setGlobally(el::ConfigurationType::Enabled, \"false\");\n        }\n\n        // read log file size limit\n        const char *logsize = ini.GetValue(\"Debug\", \"logsize\", NULL);\n        if (logsize && atoi(logsize) != 0) {\n          // make sure maxlogsize is a string of int value\n          maxlogsize = string(logsize);\n        }\n\n        // log file directory (TODO path validation and trailing slash cleanup)\n        const char *logdir = ini.GetValue(\"Debug\", \"logdirectory\", NULL);\n        if (logdir) {\n          logDirectory = string(logdir);\n        }\n      } else {\n        STFATAL << \"Invalid config file: \" << cfgfilename;\n      }\n    }\n\n    if (result.count(\"serverfifo\") &&\n        !result[\"serverfifo\"].as<string>().empty()) {\n      serverFifo.setPathOverride(result[\"serverfifo\"].as<string>());\n    }\n\n    if (result.count(\"port\")) {\n      port = result[\"port\"].as<int>();\n    }\n\n    if (result.count(\"bindip\")) {\n      bindIp = result[\"bindip\"].as<string>();\n    }\n\n    if (result.count(\"telemetry\")) {\n      telemetry = result[\"telemetry\"].as<bool>();\n    }\n\n    if (result.count(\"logdir\")) {\n      logDirectory = result[\"logdir\"].as<string>();\n    }\n\n    GOOGLE_PROTOBUF_VERIFY_VERSION;\n    srand(1);\n\n    if (port == 0) {\n      port = 2022;\n    }\n\n    // Set log file for etserver process here.\n    LogHandler::setupLogFiles(\n        &defaultConf, logDirectory, \"etserver\", result.count(\"logtostdout\"),\n        !result.count(\"logtostdout\"), true /* appendPid */, maxlogsize);\n    // Reconfigure default logger to apply settings above\n    el::Loggers::reconfigureLogger(\"default\", defaultConf);\n    // set thread name\n    el::Helpers::setThreadName(\"etserver-main\");\n    // Install log rotation callback\n    el::Helpers::installPreRollOutCallback(LogHandler::rolloutHandler);\n\n    TelemetryService::create(\n        telemetry, GetTempDirectory() + \"/.sentry-native-etserver\", \"Server\");\n\n    serverFifo.createDirectoriesIfRequired();\n\n    std::shared_ptr<SocketHandler> tcpSocketHandler(new TcpSocketHandler());\n    std::shared_ptr<PipeSocketHandler> pipeSocketHandler(\n        new PipeSocketHandler());\n\n    LOG(INFO) << \"In child, about to start server.\";\n\n    SocketEndpoint serverEndpoint;\n    serverEndpoint.set_port(port);\n    if (bindIp.length()) {\n      serverEndpoint.set_name(bindIp);\n    }\n    SocketEndpoint routerFifo;\n    routerFifo.set_name(serverFifo.getPathForCreation());\n    TerminalServer terminalServer(tcpSocketHandler, serverEndpoint,\n                                  pipeSocketHandler, routerFifo);\n    terminalServer.run();\n\n  } catch (cxxopts::OptionException &oe) {\n    CLOG(INFO, \"stdout\") << \"Exception: \" << oe.what() << \"\\n\" << endl;\n    CLOG(INFO, \"stdout\") << options.help({}) << endl;\n    exit(1);\n  }\n\n  // Uninstall log rotation callback\n  el::Helpers::uninstallPreRollOutCallback();\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -24,7 +24,9 @@\n         (\"daemon\", \"Daemonize the server\")             //\n         (\"cfgfile\", \"Location of the config file\",\n          cxxopts::value<std::string>()->default_value(\"\"))  //\n-        (\"logtostdout\", \"log to stdout\")                    //\n+        (\"l,logdir\", \"Base directory for log files.\",\n+         cxxopts::value<std::string>())   //\n+        (\"logtostdout\", \"log to stdout\")  //\n         (\"pidfile\", \"Location of the pid file\",\n          cxxopts::value<std::string>()->default_value(\n              \"/var/run/etserver.pid\"))  //\n@@ -57,14 +59,6 @@\n       }\n     }\n \n-    if (result.count(\"logtostdout\")) {\n-      defaultConf.setGlobally(el::ConfigurationType::ToStandardOutput, \"true\");\n-    } else {\n-      defaultConf.setGlobally(el::ConfigurationType::ToStandardOutput, \"false\");\n-      // Redirect std streams to a file\n-      LogHandler::stderrToFile(GetTempDirectory() + \"etserver\");\n-    }\n-\n     ServerFifoPath serverFifo;\n \n     // default max log file size is 20MB for etserver\n@@ -73,6 +67,7 @@\n     int port = 0;\n     string bindIp = \"\";\n     bool telemetry = false;\n+    string logDirectory = GetTempDirectory();\n     if (result.count(\"cfgfile\")) {\n       // Load the config file\n       CSimpleIniA ini(true, false, false);\n@@ -115,6 +110,7 @@\n         if (silent && atoi(silent) != 0) {\n           defaultConf.setGlobally(el::ConfigurationType::Enabled, \"false\");\n         }\n+\n         // read log file size limit\n         const char *logsize = ini.GetValue(\"Debug\", \"logsize\", NULL);\n         if (logsize && atoi(logsize) != 0) {\n@@ -122,6 +118,11 @@\n           maxlogsize = string(logsize);\n         }\n \n+        // log file directory (TODO path validation and trailing slash cleanup)\n+        const char *logdir = ini.GetValue(\"Debug\", \"logdirectory\", NULL);\n+        if (logdir) {\n+          logDirectory = string(logdir);\n+        }\n       } else {\n         STFATAL << \"Invalid config file: \" << cfgfilename;\n       }\n@@ -144,6 +145,10 @@\n       telemetry = result[\"telemetry\"].as<bool>();\n     }\n \n+    if (result.count(\"logdir\")) {\n+      logDirectory = result[\"logdir\"].as<string>();\n+    }\n+\n     GOOGLE_PROTOBUF_VERIFY_VERSION;\n     srand(1);\n \n@@ -152,9 +157,9 @@\n     }\n \n     // Set log file for etserver process here.\n-    LogHandler::setupLogFile(&defaultConf,\n-                             GetTempDirectory() + \"etserver-%datetime.log\",\n-                             maxlogsize);\n+    LogHandler::setupLogFiles(\n+        &defaultConf, logDirectory, \"etserver\", result.count(\"logtostdout\"),\n+        !result.count(\"logtostdout\"), true /* appendPid */, maxlogsize);\n     // Reconfigure default logger to apply settings above\n     el::Loggers::reconfigureLogger(\"default\", defaultConf);\n     // set thread name",
        "diff_line_info": {
            "deleted_lines": [
                "        (\"logtostdout\", \"log to stdout\")                    //",
                "    if (result.count(\"logtostdout\")) {",
                "      defaultConf.setGlobally(el::ConfigurationType::ToStandardOutput, \"true\");",
                "    } else {",
                "      defaultConf.setGlobally(el::ConfigurationType::ToStandardOutput, \"false\");",
                "      // Redirect std streams to a file",
                "      LogHandler::stderrToFile(GetTempDirectory() + \"etserver\");",
                "    }",
                "",
                "    LogHandler::setupLogFile(&defaultConf,",
                "                             GetTempDirectory() + \"etserver-%datetime.log\",",
                "                             maxlogsize);"
            ],
            "added_lines": [
                "        (\"l,logdir\", \"Base directory for log files.\",",
                "         cxxopts::value<std::string>())   //",
                "        (\"logtostdout\", \"log to stdout\")  //",
                "    string logDirectory = GetTempDirectory();",
                "",
                "        // log file directory (TODO path validation and trailing slash cleanup)",
                "        const char *logdir = ini.GetValue(\"Debug\", \"logdirectory\", NULL);",
                "        if (logdir) {",
                "          logDirectory = string(logdir);",
                "        }",
                "    if (result.count(\"logdir\")) {",
                "      logDirectory = result[\"logdir\"].as<string>();",
                "    }",
                "",
                "    LogHandler::setupLogFiles(",
                "        &defaultConf, logDirectory, \"etserver\", result.count(\"logtostdout\"),",
                "        !result.count(\"logtostdout\"), true /* appendPid */, maxlogsize);"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-48257",
        "func_name": "MisterTea/EternalTerminal/main",
        "description": "In Eternal Terminal 6.2.1, etserver and etclient have predictable logfile names in /tmp.",
        "git_url": "https://github.com/MisterTea/EternalTerminal/commit/92c4c6ada445c1925a8b397f4171ca7735cbda16",
        "commit_title": "Logfile open mode and permission plus location configurability. (#556)",
        "commit_text": " * Unify logfile names and create with more secure open options and perms.\r \r Fixes #555 (Tribute to Colin McRae)\r \r * Logfile location configurability.\r \r Fixes #555",
        "func_before": "int main(int argc, char** argv) {\n  WinsockContext context;\n  string tmpDir = GetTempDirectory();\n\n  // Setup easylogging configurations\n  el::Configurations defaultConf = LogHandler::setupLogHandler(&argc, &argv);\n  LogHandler::setupStdoutLogger();\n\n  et::HandleTerminate();\n\n  // Override easylogging handler for sigint\n  ::signal(SIGINT, et::InterruptSignalHandler);\n\n  // Parse command line arguments\n  cxxopts::Options options(\"et\", \"Remote shell for the busy and impatient\");\n  try {\n    options.allow_unrecognised_options();\n    options.positional_help(\"\");\n    options.custom_help(\n        \"[OPTION...] [user@]host[:port]\\n\\n\"\n        \"  Note that 'host' can be a hostname or ipv4 address with or without \"\n        \"a port\\n  or an ipv6 address. If the ipv6 address is abbreviated with \"\n        \":: then it must\\n  be specfied without a port (use -p,--port).\");\n\n    options.add_options()             //\n        (\"h,help\", \"Print help\")      //\n        (\"version\", \"Print version\")  //\n        (\"u,username\", \"Username\")    //\n        (\"host\", \"Remote host name\",\n         cxxopts::value<std::string>())  //\n        (\"p,port\", \"Remote machine etserver port\",\n         cxxopts::value<int>()->default_value(\"2022\"))  //\n        (\"c,command\", \"Run command on connect\",\n         cxxopts::value<std::string>())  //\n        (\"terminal-path\",\n         \"Path to etterminal on server side. \"\n         \"Use if etterminal is not on the system path.\",\n         cxxopts::value<std::string>())  //\n        (\"t,tunnel\",\n         \"Tunnel: Array of source:destination ports or \"\n         \"srcStart-srcEnd:dstStart-dstEnd (inclusive) port ranges (e.g. \"\n         \"10080:80,10443:443, 10090-10092:8000-8002)\",\n         cxxopts::value<std::string>())  //\n        (\"r,reversetunnel\",\n         \"Reverse Tunnel: Array of source:destination ports or \"\n         \"srcStart-srcEnd:dstStart-dstEnd (inclusive) port ranges\",\n         cxxopts::value<std::string>())  //\n        (\"jumphost\", \"jumphost between localhost and destination\",\n         cxxopts::value<std::string>())  //\n        (\"jport\", \"Jumphost machine port\",\n         cxxopts::value<int>()->default_value(\"2022\"))  //\n        (\"x,kill-other-sessions\",\n         \"kill all old sessions belonging to the user\")  //\n        (\"macserver\",\n         \"Set when connecting to an macOS server.  Sets \"\n         \"--terminal-path=/usr/local/bin/etterminal\")  //\n        (\"v,verbose\", \"Enable verbose logging\",\n         cxxopts::value<int>()->default_value(\"0\"))  //\n        (\"k,keepalive\", \"Client keepalive duration in seconds\",\n         cxxopts::value<int>())                              //\n        (\"logtostdout\", \"Write log to stdout\")               //\n        (\"silent\", \"Disable logging\")                        //\n        (\"N,no-terminal\", \"Do not create a terminal\")        //\n        (\"f,forward-ssh-agent\", \"Forward ssh-agent socket\")  //\n        (\"ssh-socket\", \"The ssh-agent socket to forward\",\n         cxxopts::value<std::string>())  //\n        (\"telemetry\",\n         \"Allow et to anonymously send errors to guide future improvements\",\n         cxxopts::value<bool>()->default_value(\"true\"))  //\n        (\"serverfifo\",\n         \"If set, communicate to etserver on the matching fifo name\",\n         cxxopts::value<std::string>()->default_value(\"\"))  //\n        (\"ssh-option\", \"Options to pass down to `ssh -o`\",\n         cxxopts::value<std::vector<std::string>>());\n\n    options.parse_positional({\"host\"});\n    auto result = options.parse(argc, argv);\n\n    if (result.count(\"help\")) {\n      CLOG(INFO, \"stdout\") << options.help({}) << endl;\n      exit(0);\n    }\n\n    if (result.count(\"version\")) {\n      CLOG(INFO, \"stdout\") << \"et version \" << ET_VERSION << endl;\n      exit(0);\n    }\n\n    el::Loggers::setVerboseLevel(result[\"verbose\"].as<int>());\n\n    if (result.count(\"logtostdout\")) {\n      defaultConf.setGlobally(el::ConfigurationType::ToStandardOutput, \"true\");\n    } else {\n      defaultConf.setGlobally(el::ConfigurationType::ToStandardOutput, \"false\");\n      // Redirect std streams to a file\n      LogHandler::stderrToFile((tmpDir + \"/etclient\"));\n    }\n\n    // silent Flag, since etclient doesn't read /etc/et.cfg file\n    if (result.count(\"silent\")) {\n      defaultConf.setGlobally(el::ConfigurationType::Enabled, \"false\");\n    }\n\n    LogHandler::setupLogFile(\n        &defaultConf, (tmpDir + \"/etclient-%datetime{%Y-%M-%d_%H_%m_%s}.log\"));\n\n    el::Loggers::reconfigureLogger(\"default\", defaultConf);\n    // set thread name\n    el::Helpers::setThreadName(\"client-main\");\n\n    // Install log rotation callback\n    el::Helpers::installPreRollOutCallback(LogHandler::rolloutHandler);\n\n    GOOGLE_PROTOBUF_VERIFY_VERSION;\n    srand(1);\n\n    TelemetryService::create(result[\"telemetry\"].as<bool>(),\n                             tmpDir + \"/.sentry-native-et\", \"Client\");\n\n    string username = \"\";\n    if (result.count(\"username\")) {\n      username = result[\"username\"].as<string>();\n    }\n    int destinationPort = result[\"port\"].as<int>();\n    string destinationHost;\n\n    // Parse command-line argument\n    if (!result.count(\"host\")) {\n      CLOG(INFO, \"stdout\") << \"Missing host to connect to\" << endl;\n      CLOG(INFO, \"stdout\") << options.help({}) << endl;\n      exit(0);\n    }\n    string host_arg = result[\"host\"].as<std::string>();\n    if (host_arg.find('@') != string::npos) {\n      int i = host_arg.find('@');\n      username = host_arg.substr(0, i);\n      host_arg = host_arg.substr(i + 1);\n    }\n\n    if (host_arg.find(':') != string::npos) {\n      int colon_count = std::count(host_arg.begin(), host_arg.end(), ':');\n      if (colon_count == 1) {\n        // ipv4 or hostname with port specified\n        int port_colon_pos = host_arg.rfind(':');\n        destinationPort = stoi(host_arg.substr(port_colon_pos + 1));\n        host_arg = host_arg.substr(0, port_colon_pos);\n      } else {\n        // maybe ipv6 (colon_count >= 2)\n        if (host_arg.find(\"::\") != string::npos) {\n          // ipv6 with double colon zero abbreviation and no port\n          // leave host_arg as is\n        } else {\n          if (colon_count == 7) {\n            // ipv6, fully expanded, without port\n          } else if (colon_count == 8) {\n            // ipv6, fully expanded, with port\n            int port_colon_pos = host_arg.rfind(':');\n            destinationPort = stoi(host_arg.substr(port_colon_pos + 1));\n            host_arg = host_arg.substr(0, port_colon_pos);\n          } else {\n            CLOG(INFO, \"stdout\") << \"Invalid host positional arg: \"\n                                 << result[\"host\"].as<std::string>() << endl;\n            exit(1);\n          }\n        }\n      }\n    }\n    destinationHost = host_arg;\n    // host_alias is used for the initiating ssh call, if sshd runs on a port\n    // other than 22, either configure your .ssh/config with an alias with an\n    // overridden port or pass --ssh-option Port=<sshd_port>\n    string host_alias = destinationHost;\n\n    string jumphost =\n        result.count(\"jumphost\") ? result[\"jumphost\"].as<string>() : \"\";\n    int keepaliveDuration = result.count(\"keepalive\")\n                                ? result[\"keepalive\"].as<int>()\n                                : MAX_CLIENT_KEEP_ALIVE_DURATION;\n    if (keepaliveDuration < 1 ||\n        keepaliveDuration > MAX_CLIENT_KEEP_ALIVE_DURATION) {\n      CLOG(INFO, \"stdout\") << \"Keep-alive duration must between 1 and \"\n                           << MAX_CLIENT_KEEP_ALIVE_DURATION << \" seconds\"\n                           << endl;\n      CLOG(INFO, \"stdout\") << options.help({}) << endl;\n      exit(0);\n    }\n\n    Options sshConfigOptions = {\n        NULL,  // username\n        NULL,  // host\n        NULL,  // sshdir\n        NULL,  // knownhosts\n        NULL,  // ProxyCommand\n        NULL,  // ProxyJump\n        0,     // timeout\n        0,     // port\n        0,     // StrictHostKeyChecking\n        0,     // ssh2\n        0,     // ssh1\n        NULL,  // gss_server_identity\n        NULL,  // gss_client_identity\n        0,     // gss_delegate_creds\n        0,     // forward_agent\n        NULL   // identity_agent\n    };\n\n    char* home_dir = ssh_get_user_home_dir();\n    const char* host_from_command = destinationHost.c_str();\n    ssh_options_set(&sshConfigOptions, SSH_OPTIONS_HOST,\n                    destinationHost.c_str());\n    // First parse user-specific ssh config, then system-wide config.\n    parse_ssh_config_file(host_from_command, &sshConfigOptions,\n                          string(home_dir) + USER_SSH_CONFIG_PATH);\n    parse_ssh_config_file(host_from_command, &sshConfigOptions,\n                          SYSTEM_SSH_CONFIG_PATH);\n    LOG(INFO) << \"Parsed ssh config file, connecting to \"\n              << sshConfigOptions.host;\n    destinationHost = string(sshConfigOptions.host);\n\n    // Parse username: cmdline > sshconfig > localuser\n    if (username.empty()) {\n      if (sshConfigOptions.username) {\n        username = string(sshConfigOptions.username);\n      } else {\n        username = string(ssh_get_local_username());\n      }\n    }\n\n    // Parse jumphost: cmd > sshconfig\n    if (sshConfigOptions.ProxyJump && jumphost.length() == 0) {\n      string proxyjump = string(sshConfigOptions.ProxyJump);\n      size_t colonIndex = proxyjump.find(\":\");\n      if (colonIndex != string::npos) {\n        string userhostpair = proxyjump.substr(0, colonIndex);\n        size_t atIndex = userhostpair.find(\"@\");\n        if (atIndex != string::npos) {\n          jumphost = userhostpair.substr(atIndex + 1);\n        }\n      } else {\n        jumphost = proxyjump;\n      }\n      LOG(INFO) << \"ProxyJump found for dst in ssh config: \" << proxyjump;\n    }\n\n    bool is_jumphost = false;\n    SocketEndpoint socketEndpoint;\n    if (!jumphost.empty()) {\n      is_jumphost = true;\n      LOG(INFO) << \"Setting port to jumphost port\";\n      socketEndpoint.set_name(jumphost);\n      socketEndpoint.set_port(result[\"jport\"].as<int>());\n    } else {\n      socketEndpoint.set_name(destinationHost);\n      socketEndpoint.set_port(destinationPort);\n    }\n    shared_ptr<SocketHandler> clientSocket(new TcpSocketHandler());\n    shared_ptr<SocketHandler> clientPipeSocket(new PipeSocketHandler());\n\n    if (!ping(socketEndpoint, clientSocket)) {\n      CLOG(INFO, \"stdout\") << \"Could not reach the ET server: \"\n                           << socketEndpoint.name() << \":\"\n                           << socketEndpoint.port() << endl;\n      exit(1);\n    }\n\n    int jport = result[\"jport\"].as<int>();\n    string serverFifo = \"\";\n    if (result[\"serverfifo\"].as<string>() != \"\") {\n      serverFifo = result[\"serverfifo\"].as<string>();\n    }\n    std::vector<string> ssh_options;\n    if (result.count(\"ssh-option\")) {\n      ssh_options = result[\"ssh-option\"].as<std::vector<string>>();\n    }\n    string etterminal_path = \"\";\n    if (result.count(\"macserver\") > 0) {\n      etterminal_path = \"/usr/local/bin/etterminal\";\n    }\n    if (result.count(\"etterminal_path\")) {\n      etterminal_path = result[\"terminal-path\"].as<string>();\n    }\n    string idpasskeypair = SshSetupHandler::SetupSsh(\n        username, destinationHost, host_alias, destinationPort, jumphost, jport,\n        result.count(\"x\") > 0, result[\"verbose\"].as<int>(), etterminal_path,\n        serverFifo, ssh_options);\n\n    string id = \"\", passkey = \"\";\n    // Trim whitespace\n    idpasskeypair.erase(idpasskeypair.find_last_not_of(\" \\n\\r\\t\") + 1);\n    size_t slashIndex = idpasskeypair.find(\"/\");\n    if (slashIndex == string::npos) {\n      STFATAL << \"Invalid idPasskey id/key pair: \" << idpasskeypair;\n    } else {\n      id = idpasskeypair.substr(0, slashIndex);\n      passkey = idpasskeypair.substr(slashIndex + 1);\n    }\n    if (passkey.length() != 32) {\n      STFATAL << \"Invalid/missing passkey: \" << passkey << \" \"\n              << passkey.length();\n    }\n    shared_ptr<Console> console;\n    if (!result.count(\"N\")) {\n      console.reset(new PsuedoTerminalConsole());\n    }\n\n    bool forwardAgent = result.count(\"f\") > 0;\n    string sshSocket = \"\";\n#ifndef WIN32\n    if (sshConfigOptions.identity_agent) {\n      sshSocket = string(sshConfigOptions.identity_agent);\n    }\n    forwardAgent |= sshConfigOptions.forward_agent;\n#endif\n    if (result.count(\"ssh-socket\")) {\n      sshSocket = result[\"ssh-socket\"].as<string>();\n    }\n    TelemetryService::get()->logToDatadog(\"Session Started\", el::Level::Info,\n                                          __FILE__, __LINE__);\n    string tunnel_arg =\n        result.count(\"tunnel\") ? result[\"tunnel\"].as<string>() : \"\";\n    string r_tunnel_arg = result.count(\"reversetunnel\")\n                              ? result[\"reversetunnel\"].as<string>()\n                              : \"\";\n    TerminalClient terminalClient(clientSocket, clientPipeSocket,\n                                  socketEndpoint, id, passkey, console,\n                                  is_jumphost, tunnel_arg, r_tunnel_arg,\n                                  forwardAgent, sshSocket, keepaliveDuration);\n    terminalClient.run(result.count(\"command\") ? result[\"command\"].as<string>()\n                                               : \"\");\n  } catch (TunnelParseException& tpe) {\n    handleParseException(tpe, options);\n  } catch (cxxopts::OptionException& oe) {\n    handleParseException(oe, options);\n  }\n\n#ifdef WIN32\n  WSACleanup();\n#endif\n\n  TelemetryService::get()->shutdown();\n  TelemetryService::destroy();\n\n  // Uninstall log rotation callback\n  el::Helpers::uninstallPreRollOutCallback();\n\n  return 0;\n}",
        "func": "int main(int argc, char** argv) {\n  WinsockContext context;\n  string tmpDir = GetTempDirectory();\n\n  // Setup easylogging configurations\n  el::Configurations defaultConf = LogHandler::setupLogHandler(&argc, &argv);\n  LogHandler::setupStdoutLogger();\n\n  et::HandleTerminate();\n\n  // Override easylogging handler for sigint\n  ::signal(SIGINT, et::InterruptSignalHandler);\n\n  // Parse command line arguments\n  cxxopts::Options options(\"et\", \"Remote shell for the busy and impatient\");\n  try {\n    options.allow_unrecognised_options();\n    options.positional_help(\"\");\n    options.custom_help(\n        \"[OPTION...] [user@]host[:port]\\n\\n\"\n        \"  Note that 'host' can be a hostname or ipv4 address with or without \"\n        \"a port\\n  or an ipv6 address. If the ipv6 address is abbreviated with \"\n        \":: then it must\\n  be specfied without a port (use -p,--port).\");\n\n    options.add_options()             //\n        (\"h,help\", \"Print help\")      //\n        (\"version\", \"Print version\")  //\n        (\"u,username\", \"Username\")    //\n        (\"host\", \"Remote host name\",\n         cxxopts::value<std::string>())  //\n        (\"p,port\", \"Remote machine etserver port\",\n         cxxopts::value<int>()->default_value(\"2022\"))  //\n        (\"c,command\", \"Run command on connect\",\n         cxxopts::value<std::string>())  //\n        (\"terminal-path\",\n         \"Path to etterminal on server side. \"\n         \"Use if etterminal is not on the system path.\",\n         cxxopts::value<std::string>())  //\n        (\"t,tunnel\",\n         \"Tunnel: Array of source:destination ports or \"\n         \"srcStart-srcEnd:dstStart-dstEnd (inclusive) port ranges (e.g. \"\n         \"10080:80,10443:443, 10090-10092:8000-8002)\",\n         cxxopts::value<std::string>())  //\n        (\"r,reversetunnel\",\n         \"Reverse Tunnel: Array of source:destination ports or \"\n         \"srcStart-srcEnd:dstStart-dstEnd (inclusive) port ranges\",\n         cxxopts::value<std::string>())  //\n        (\"jumphost\", \"jumphost between localhost and destination\",\n         cxxopts::value<std::string>())  //\n        (\"jport\", \"Jumphost machine port\",\n         cxxopts::value<int>()->default_value(\"2022\"))  //\n        (\"x,kill-other-sessions\",\n         \"kill all old sessions belonging to the user\")  //\n        (\"macserver\",\n         \"Set when connecting to an macOS server.  Sets \"\n         \"--terminal-path=/usr/local/bin/etterminal\")  //\n        (\"v,verbose\", \"Enable verbose logging\",\n         cxxopts::value<int>()->default_value(\"0\"))  //\n        (\"k,keepalive\", \"Client keepalive duration in seconds\",\n         cxxopts::value<int>())  //\n        (\"l,logdir\", \"Base directory for log files.\",\n         cxxopts::value<std::string>()->default_value(tmpDir))  //\n        (\"logtostdout\", \"Write log to stdout\")                  //\n        (\"silent\", \"Disable logging\")                           //\n        (\"N,no-terminal\", \"Do not create a terminal\")           //\n        (\"f,forward-ssh-agent\", \"Forward ssh-agent socket\")     //\n        (\"ssh-socket\", \"The ssh-agent socket to forward\",\n         cxxopts::value<std::string>())  //\n        (\"telemetry\",\n         \"Allow et to anonymously send errors to guide future improvements\",\n         cxxopts::value<bool>()->default_value(\"true\"))  //\n        (\"serverfifo\",\n         \"If set, communicate to etserver on the matching fifo name\",\n         cxxopts::value<std::string>()->default_value(\"\"))  //\n        (\"ssh-option\", \"Options to pass down to `ssh -o`\",\n         cxxopts::value<std::vector<std::string>>());\n\n    options.parse_positional({\"host\"});\n    auto result = options.parse(argc, argv);\n\n    if (result.count(\"help\")) {\n      CLOG(INFO, \"stdout\") << options.help({}) << endl;\n      exit(0);\n    }\n\n    if (result.count(\"version\")) {\n      CLOG(INFO, \"stdout\") << \"et version \" << ET_VERSION << endl;\n      exit(0);\n    }\n\n    el::Loggers::setVerboseLevel(result[\"verbose\"].as<int>());\n\n    // silent Flag, since etclient doesn't read /etc/et.cfg file\n    if (result.count(\"silent\")) {\n      defaultConf.setGlobally(el::ConfigurationType::Enabled, \"false\");\n    }\n\n    LogHandler::setupLogFiles(&defaultConf, result[\"logdir\"].as<string>(),\n                              \"etclient\", result.count(\"logtostdout\"),\n                              !result.count(\"logtostdout\"));\n\n    el::Loggers::reconfigureLogger(\"default\", defaultConf);\n    // set thread name\n    el::Helpers::setThreadName(\"client-main\");\n\n    // Install log rotation callback\n    el::Helpers::installPreRollOutCallback(LogHandler::rolloutHandler);\n\n    GOOGLE_PROTOBUF_VERIFY_VERSION;\n    srand(1);\n\n    TelemetryService::create(result[\"telemetry\"].as<bool>(),\n                             tmpDir + \"/.sentry-native-et\", \"Client\");\n\n    string username = \"\";\n    if (result.count(\"username\")) {\n      username = result[\"username\"].as<string>();\n    }\n    int destinationPort = result[\"port\"].as<int>();\n    string destinationHost;\n\n    // Parse command-line argument\n    if (!result.count(\"host\")) {\n      CLOG(INFO, \"stdout\") << \"Missing host to connect to\" << endl;\n      CLOG(INFO, \"stdout\") << options.help({}) << endl;\n      exit(0);\n    }\n    string host_arg = result[\"host\"].as<std::string>();\n    if (host_arg.find('@') != string::npos) {\n      int i = host_arg.find('@');\n      username = host_arg.substr(0, i);\n      host_arg = host_arg.substr(i + 1);\n    }\n\n    if (host_arg.find(':') != string::npos) {\n      int colon_count = std::count(host_arg.begin(), host_arg.end(), ':');\n      if (colon_count == 1) {\n        // ipv4 or hostname with port specified\n        int port_colon_pos = host_arg.rfind(':');\n        destinationPort = stoi(host_arg.substr(port_colon_pos + 1));\n        host_arg = host_arg.substr(0, port_colon_pos);\n      } else {\n        // maybe ipv6 (colon_count >= 2)\n        if (host_arg.find(\"::\") != string::npos) {\n          // ipv6 with double colon zero abbreviation and no port\n          // leave host_arg as is\n        } else {\n          if (colon_count == 7) {\n            // ipv6, fully expanded, without port\n          } else if (colon_count == 8) {\n            // ipv6, fully expanded, with port\n            int port_colon_pos = host_arg.rfind(':');\n            destinationPort = stoi(host_arg.substr(port_colon_pos + 1));\n            host_arg = host_arg.substr(0, port_colon_pos);\n          } else {\n            CLOG(INFO, \"stdout\") << \"Invalid host positional arg: \"\n                                 << result[\"host\"].as<std::string>() << endl;\n            exit(1);\n          }\n        }\n      }\n    }\n    destinationHost = host_arg;\n    // host_alias is used for the initiating ssh call, if sshd runs on a port\n    // other than 22, either configure your .ssh/config with an alias with an\n    // overridden port or pass --ssh-option Port=<sshd_port>\n    string host_alias = destinationHost;\n\n    string jumphost =\n        result.count(\"jumphost\") ? result[\"jumphost\"].as<string>() : \"\";\n    int keepaliveDuration = result.count(\"keepalive\")\n                                ? result[\"keepalive\"].as<int>()\n                                : MAX_CLIENT_KEEP_ALIVE_DURATION;\n    if (keepaliveDuration < 1 ||\n        keepaliveDuration > MAX_CLIENT_KEEP_ALIVE_DURATION) {\n      CLOG(INFO, \"stdout\") << \"Keep-alive duration must between 1 and \"\n                           << MAX_CLIENT_KEEP_ALIVE_DURATION << \" seconds\"\n                           << endl;\n      CLOG(INFO, \"stdout\") << options.help({}) << endl;\n      exit(0);\n    }\n\n    Options sshConfigOptions = {\n        NULL,  // username\n        NULL,  // host\n        NULL,  // sshdir\n        NULL,  // knownhosts\n        NULL,  // ProxyCommand\n        NULL,  // ProxyJump\n        0,     // timeout\n        0,     // port\n        0,     // StrictHostKeyChecking\n        0,     // ssh2\n        0,     // ssh1\n        NULL,  // gss_server_identity\n        NULL,  // gss_client_identity\n        0,     // gss_delegate_creds\n        0,     // forward_agent\n        NULL   // identity_agent\n    };\n\n    char* home_dir = ssh_get_user_home_dir();\n    const char* host_from_command = destinationHost.c_str();\n    ssh_options_set(&sshConfigOptions, SSH_OPTIONS_HOST,\n                    destinationHost.c_str());\n    // First parse user-specific ssh config, then system-wide config.\n    parse_ssh_config_file(host_from_command, &sshConfigOptions,\n                          string(home_dir) + USER_SSH_CONFIG_PATH);\n    parse_ssh_config_file(host_from_command, &sshConfigOptions,\n                          SYSTEM_SSH_CONFIG_PATH);\n    LOG(INFO) << \"Parsed ssh config file, connecting to \"\n              << sshConfigOptions.host;\n    destinationHost = string(sshConfigOptions.host);\n\n    // Parse username: cmdline > sshconfig > localuser\n    if (username.empty()) {\n      if (sshConfigOptions.username) {\n        username = string(sshConfigOptions.username);\n      } else {\n        username = string(ssh_get_local_username());\n      }\n    }\n\n    // Parse jumphost: cmd > sshconfig\n    if (sshConfigOptions.ProxyJump && jumphost.length() == 0) {\n      string proxyjump = string(sshConfigOptions.ProxyJump);\n      size_t colonIndex = proxyjump.find(\":\");\n      if (colonIndex != string::npos) {\n        string userhostpair = proxyjump.substr(0, colonIndex);\n        size_t atIndex = userhostpair.find(\"@\");\n        if (atIndex != string::npos) {\n          jumphost = userhostpair.substr(atIndex + 1);\n        }\n      } else {\n        jumphost = proxyjump;\n      }\n      LOG(INFO) << \"ProxyJump found for dst in ssh config: \" << proxyjump;\n    }\n\n    bool is_jumphost = false;\n    SocketEndpoint socketEndpoint;\n    if (!jumphost.empty()) {\n      is_jumphost = true;\n      LOG(INFO) << \"Setting port to jumphost port\";\n      socketEndpoint.set_name(jumphost);\n      socketEndpoint.set_port(result[\"jport\"].as<int>());\n    } else {\n      socketEndpoint.set_name(destinationHost);\n      socketEndpoint.set_port(destinationPort);\n    }\n    shared_ptr<SocketHandler> clientSocket(new TcpSocketHandler());\n    shared_ptr<SocketHandler> clientPipeSocket(new PipeSocketHandler());\n\n    if (!ping(socketEndpoint, clientSocket)) {\n      CLOG(INFO, \"stdout\") << \"Could not reach the ET server: \"\n                           << socketEndpoint.name() << \":\"\n                           << socketEndpoint.port() << endl;\n      exit(1);\n    }\n\n    int jport = result[\"jport\"].as<int>();\n    string serverFifo = \"\";\n    if (result[\"serverfifo\"].as<string>() != \"\") {\n      serverFifo = result[\"serverfifo\"].as<string>();\n    }\n    std::vector<string> ssh_options;\n    if (result.count(\"ssh-option\")) {\n      ssh_options = result[\"ssh-option\"].as<std::vector<string>>();\n    }\n    string etterminal_path = \"\";\n    if (result.count(\"macserver\") > 0) {\n      etterminal_path = \"/usr/local/bin/etterminal\";\n    }\n    if (result.count(\"etterminal_path\")) {\n      etterminal_path = result[\"terminal-path\"].as<string>();\n    }\n    string idpasskeypair = SshSetupHandler::SetupSsh(\n        username, destinationHost, host_alias, destinationPort, jumphost, jport,\n        result.count(\"x\") > 0, result[\"verbose\"].as<int>(), etterminal_path,\n        serverFifo, ssh_options);\n\n    string id = \"\", passkey = \"\";\n    // Trim whitespace\n    idpasskeypair.erase(idpasskeypair.find_last_not_of(\" \\n\\r\\t\") + 1);\n    size_t slashIndex = idpasskeypair.find(\"/\");\n    if (slashIndex == string::npos) {\n      STFATAL << \"Invalid idPasskey id/key pair: \" << idpasskeypair;\n    } else {\n      id = idpasskeypair.substr(0, slashIndex);\n      passkey = idpasskeypair.substr(slashIndex + 1);\n    }\n    if (passkey.length() != 32) {\n      STFATAL << \"Invalid/missing passkey: \" << passkey << \" \"\n              << passkey.length();\n    }\n    shared_ptr<Console> console;\n    if (!result.count(\"N\")) {\n      console.reset(new PsuedoTerminalConsole());\n    }\n\n    bool forwardAgent = result.count(\"f\") > 0;\n    string sshSocket = \"\";\n#ifndef WIN32\n    if (sshConfigOptions.identity_agent) {\n      sshSocket = string(sshConfigOptions.identity_agent);\n    }\n    forwardAgent |= sshConfigOptions.forward_agent;\n#endif\n    if (result.count(\"ssh-socket\")) {\n      sshSocket = result[\"ssh-socket\"].as<string>();\n    }\n    TelemetryService::get()->logToDatadog(\"Session Started\", el::Level::Info,\n                                          __FILE__, __LINE__);\n    string tunnel_arg =\n        result.count(\"tunnel\") ? result[\"tunnel\"].as<string>() : \"\";\n    string r_tunnel_arg = result.count(\"reversetunnel\")\n                              ? result[\"reversetunnel\"].as<string>()\n                              : \"\";\n    TerminalClient terminalClient(clientSocket, clientPipeSocket,\n                                  socketEndpoint, id, passkey, console,\n                                  is_jumphost, tunnel_arg, r_tunnel_arg,\n                                  forwardAgent, sshSocket, keepaliveDuration);\n    terminalClient.run(result.count(\"command\") ? result[\"command\"].as<string>()\n                                               : \"\");\n  } catch (TunnelParseException& tpe) {\n    handleParseException(tpe, options);\n  } catch (cxxopts::OptionException& oe) {\n    handleParseException(oe, options);\n  }\n\n#ifdef WIN32\n  WSACleanup();\n#endif\n\n  TelemetryService::get()->shutdown();\n  TelemetryService::destroy();\n\n  // Uninstall log rotation callback\n  el::Helpers::uninstallPreRollOutCallback();\n\n  return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -57,11 +57,13 @@\n         (\"v,verbose\", \"Enable verbose logging\",\n          cxxopts::value<int>()->default_value(\"0\"))  //\n         (\"k,keepalive\", \"Client keepalive duration in seconds\",\n-         cxxopts::value<int>())                              //\n-        (\"logtostdout\", \"Write log to stdout\")               //\n-        (\"silent\", \"Disable logging\")                        //\n-        (\"N,no-terminal\", \"Do not create a terminal\")        //\n-        (\"f,forward-ssh-agent\", \"Forward ssh-agent socket\")  //\n+         cxxopts::value<int>())  //\n+        (\"l,logdir\", \"Base directory for log files.\",\n+         cxxopts::value<std::string>()->default_value(tmpDir))  //\n+        (\"logtostdout\", \"Write log to stdout\")                  //\n+        (\"silent\", \"Disable logging\")                           //\n+        (\"N,no-terminal\", \"Do not create a terminal\")           //\n+        (\"f,forward-ssh-agent\", \"Forward ssh-agent socket\")     //\n         (\"ssh-socket\", \"The ssh-agent socket to forward\",\n          cxxopts::value<std::string>())  //\n         (\"telemetry\",\n@@ -88,21 +90,14 @@\n \n     el::Loggers::setVerboseLevel(result[\"verbose\"].as<int>());\n \n-    if (result.count(\"logtostdout\")) {\n-      defaultConf.setGlobally(el::ConfigurationType::ToStandardOutput, \"true\");\n-    } else {\n-      defaultConf.setGlobally(el::ConfigurationType::ToStandardOutput, \"false\");\n-      // Redirect std streams to a file\n-      LogHandler::stderrToFile((tmpDir + \"/etclient\"));\n-    }\n-\n     // silent Flag, since etclient doesn't read /etc/et.cfg file\n     if (result.count(\"silent\")) {\n       defaultConf.setGlobally(el::ConfigurationType::Enabled, \"false\");\n     }\n \n-    LogHandler::setupLogFile(\n-        &defaultConf, (tmpDir + \"/etclient-%datetime{%Y-%M-%d_%H_%m_%s}.log\"));\n+    LogHandler::setupLogFiles(&defaultConf, result[\"logdir\"].as<string>(),\n+                              \"etclient\", result.count(\"logtostdout\"),\n+                              !result.count(\"logtostdout\"));\n \n     el::Loggers::reconfigureLogger(\"default\", defaultConf);\n     // set thread name",
        "diff_line_info": {
            "deleted_lines": [
                "         cxxopts::value<int>())                              //",
                "        (\"logtostdout\", \"Write log to stdout\")               //",
                "        (\"silent\", \"Disable logging\")                        //",
                "        (\"N,no-terminal\", \"Do not create a terminal\")        //",
                "        (\"f,forward-ssh-agent\", \"Forward ssh-agent socket\")  //",
                "    if (result.count(\"logtostdout\")) {",
                "      defaultConf.setGlobally(el::ConfigurationType::ToStandardOutput, \"true\");",
                "    } else {",
                "      defaultConf.setGlobally(el::ConfigurationType::ToStandardOutput, \"false\");",
                "      // Redirect std streams to a file",
                "      LogHandler::stderrToFile((tmpDir + \"/etclient\"));",
                "    }",
                "",
                "    LogHandler::setupLogFile(",
                "        &defaultConf, (tmpDir + \"/etclient-%datetime{%Y-%M-%d_%H_%m_%s}.log\"));"
            ],
            "added_lines": [
                "         cxxopts::value<int>())  //",
                "        (\"l,logdir\", \"Base directory for log files.\",",
                "         cxxopts::value<std::string>()->default_value(tmpDir))  //",
                "        (\"logtostdout\", \"Write log to stdout\")                  //",
                "        (\"silent\", \"Disable logging\")                           //",
                "        (\"N,no-terminal\", \"Do not create a terminal\")           //",
                "        (\"f,forward-ssh-agent\", \"Forward ssh-agent socket\")     //",
                "    LogHandler::setupLogFiles(&defaultConf, result[\"logdir\"].as<string>(),",
                "                              \"etclient\", result.count(\"logtostdout\"),",
                "                              !result.count(\"logtostdout\"));"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-48257",
        "func_name": "MisterTea/EternalTerminal/main",
        "description": "In Eternal Terminal 6.2.1, etserver and etclient have predictable logfile names in /tmp.",
        "git_url": "https://github.com/MisterTea/EternalTerminal/commit/92c4c6ada445c1925a8b397f4171ca7735cbda16",
        "commit_title": "Logfile open mode and permission plus location configurability. (#556)",
        "commit_text": " * Unify logfile names and create with more secure open options and perms.\r \r Fixes #555 (Tribute to Colin McRae)\r \r * Logfile location configurability.\r \r Fixes #555",
        "func_before": "int main(int argc, char **argv) {\n  // Version string need to be set before GFLAGS parse arguments\n  GOOGLE_PROTOBUF_VERIFY_VERSION;\n  srand(1);\n\n  // Setup easylogging configurations\n  el::Configurations defaultConf =\n      et::LogHandler::setupLogHandler(&argc, &argv);\n  defaultConf.setGlobally(el::ConfigurationType::ToStandardOutput, \"false\");\n  el::Loggers::setVerboseLevel(3);\n  // default max log file size is 20MB for etserver\n  string maxlogsize = \"20971520\";\n  LogHandler::setupLogFile(&defaultConf, GetTempDirectory() + \"htmd.log\",\n                           maxlogsize);\n  // Redirect std streams to a file\n  LogHandler::stderrToFile(GetTempDirectory() + \"htmd\");\n\n  // Reconfigure default logger to apply settings above\n  el::Loggers::reconfigureLogger(\"default\", defaultConf);\n\n  et::HandleTerminate();\n\n  // Override easylogging handler for sigint\n  ::signal(SIGINT, et::InterruptSignalHandler);\n\n  shared_ptr<SocketHandler> socketHandler(new PipeSocketHandler());\n  SocketEndpoint endpoint;\n  endpoint.set_name(HtmServer::getPipeName());\n  HtmServer htm(socketHandler, endpoint);\n  htm.run();\n  LOG(INFO) << \"Server is shutting down\";\n\n  return 0;\n}",
        "func": "int main(int argc, char **argv) {\n  // Version string need to be set before GFLAGS parse arguments\n  GOOGLE_PROTOBUF_VERIFY_VERSION;\n  srand(1);\n\n  // Setup easylogging configurations\n  el::Configurations defaultConf =\n      et::LogHandler::setupLogHandler(&argc, &argv);\n  el::Loggers::setVerboseLevel(3);\n  LogHandler::setupLogFiles(&defaultConf, GetTempDirectory(), \"htmd\", false,\n                            true);\n\n  // Reconfigure default logger to apply settings above\n  el::Loggers::reconfigureLogger(\"default\", defaultConf);\n\n  et::HandleTerminate();\n\n  // Override easylogging handler for sigint\n  ::signal(SIGINT, et::InterruptSignalHandler);\n\n  shared_ptr<SocketHandler> socketHandler(new PipeSocketHandler());\n  SocketEndpoint endpoint;\n  endpoint.set_name(HtmServer::getPipeName());\n  HtmServer htm(socketHandler, endpoint);\n  htm.run();\n  LOG(INFO) << \"Server is shutting down\";\n\n  return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,14 +6,9 @@\n   // Setup easylogging configurations\n   el::Configurations defaultConf =\n       et::LogHandler::setupLogHandler(&argc, &argv);\n-  defaultConf.setGlobally(el::ConfigurationType::ToStandardOutput, \"false\");\n   el::Loggers::setVerboseLevel(3);\n-  // default max log file size is 20MB for etserver\n-  string maxlogsize = \"20971520\";\n-  LogHandler::setupLogFile(&defaultConf, GetTempDirectory() + \"htmd.log\",\n-                           maxlogsize);\n-  // Redirect std streams to a file\n-  LogHandler::stderrToFile(GetTempDirectory() + \"htmd\");\n+  LogHandler::setupLogFiles(&defaultConf, GetTempDirectory(), \"htmd\", false,\n+                            true);\n \n   // Reconfigure default logger to apply settings above\n   el::Loggers::reconfigureLogger(\"default\", defaultConf);",
        "diff_line_info": {
            "deleted_lines": [
                "  defaultConf.setGlobally(el::ConfigurationType::ToStandardOutput, \"false\");",
                "  // default max log file size is 20MB for etserver",
                "  string maxlogsize = \"20971520\";",
                "  LogHandler::setupLogFile(&defaultConf, GetTempDirectory() + \"htmd.log\",",
                "                           maxlogsize);",
                "  // Redirect std streams to a file",
                "  LogHandler::stderrToFile(GetTempDirectory() + \"htmd\");"
            ],
            "added_lines": [
                "  LogHandler::setupLogFiles(&defaultConf, GetTempDirectory(), \"htmd\", false,",
                "                            true);"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-48257",
        "func_name": "MisterTea/EternalTerminal/main",
        "description": "In Eternal Terminal 6.2.1, etserver and etclient have predictable logfile names in /tmp.",
        "git_url": "https://github.com/MisterTea/EternalTerminal/commit/04e64d442adb780a126996aa910da84e6939185a",
        "commit_title": "Logfile location configurability.",
        "commit_text": " Fixes #555",
        "func_before": "int main(int argc, char** argv) {\n  // Setup easylogging configurations\n  el::Configurations defaultConf = LogHandler::setupLogHandler(&argc, &argv);\n  LogHandler::setupStdoutLogger();\n\n  et::HandleTerminate();\n\n  // Override easylogging handler for sigint\n  ::signal(SIGINT, et::InterruptSignalHandler);\n\n  // Parse command line arguments\n  cxxopts::Options options(\"etterminal\", \"User terminal for Eternal Terminal.\");\n\n  try {\n    options.allow_unrecognised_options();\n\n    options.add_options()         //\n        (\"h,help\", \"Print help\")  //\n        (\"idpasskey\",\n         \"If set, uses IPC to send a client id/key to the server daemon. \"\n         \"Alternatively, pass in via stdin.\",\n         cxxopts::value<std::string>()->default_value(\"\"))  //\n        (\"idpasskeyfile\",\n         \"If set, uses IPC to send a client id/key to the server daemon from a \"\n         \"file. Alternatively, pass in via stdin.\",\n         cxxopts::value<std::string>()->default_value(\"\"))  //\n        (\"jump\",\n         \"If set, forward all packets between client and dst terminal\")  //\n        (\"dsthost\", \"Must be set if jump is set to true\",\n         cxxopts::value<std::string>()->default_value(\"\"))  //\n        (\"dstport\", \"Must be set if jump is set to true\",\n         cxxopts::value<int>()->default_value(\"2022\"))  //\n        // Not used by etterminal but easylogging uses this flag under the hood\n        (\"v,verbose\", \"Enable verbose logging\",\n         cxxopts::value<int>()->default_value(\"0\"))  //\n        (\"logtostdout\", \"Write log to stdout\")       //\n        (\"serverfifo\",\n         \"If set, connects to the etserver instance listening on the matching \"\n         \"fifo name\",                                       //\n         cxxopts::value<std::string>()->default_value(\"\"))  //\n        ;\n\n    auto result = options.parse(argc, argv);\n    if (result.count(\"help\")) {\n      CLOG(INFO, \"stdout\") << options.help({}) << endl;\n      exit(0);\n    }\n\n    el::Loggers::setVerboseLevel(result[\"verbose\"].as<int>());\n\n    GOOGLE_PROTOBUF_VERIFY_VERSION;\n    srand(1);\n\n    ServerFifoPath serverFifo;\n    if (!result[\"serverfifo\"].as<string>().empty()) {\n      serverFifo.setPathOverride(result[\"serverfifo\"].as<string>());\n    }\n\n    shared_ptr<SocketHandler> ipcSocketHandler(new PipeSocketHandler());\n    shared_ptr<PsuedoUserTerminal> term(new PsuedoUserTerminal());\n\n    string idpasskey;\n    if (result.count(\"idpasskey\") == 0 && result.count(\"idpasskeyfile\") == 0) {\n      // Try to read from stdin\n      struct timeval timeout;\n      timeout.tv_sec = 1;\n      timeout.tv_usec = 0;\n      fd_set readfds;\n      FD_ZERO(&readfds);\n\n      FD_SET(STDIN_FILENO, &readfds);\n\n      int selectResult = 0;\n      do {\n        // Repeatedly calls when interrupted, up to the timeout.\n        selectResult = select(1, &readfds, NULL, NULL, &timeout);\n      } while (selectResult < 0 && errno == EINTR);\n\n      FATAL_FAIL(selectResult);\n      if (selectResult == 0) {\n        CLOG(INFO, \"stdout\")\n            << \"Call etterminal with --idpasskey or --idpasskeyfile, or feed \"\n               \"this information on stdin\\n\";\n        exit(1);\n      }\n\n      string stdinData;\n      if (!getline(cin, stdinData)) {\n        CLOG(INFO, \"stdout\")\n            << \"Call etterminal with --idpasskey or --idpasskeyfile, or feed \"\n               \"this information on stdin\\n\";\n        exit(1);\n      }\n      auto tokens = split(stdinData, '_');\n      if (tokens.size() == 2) {\n        idpasskey = tokens[0];\n        if (idpasskey.substr(0, 3) == std::string(\"XXX\")) {\n          // New client connecting to new server, throw away passkey and\n          // regenerate\n          string passkey = genRandomAlphaNum(32);\n          string id = genRandomAlphaNum(16);\n          idpasskey = id + string(\"/\") + passkey;\n        }\n\n        FATAL_FAIL(setenv(\"TERM\", tokens[1].c_str(), 1));\n      } else {\n        STFATAL << \"Invalid number of tokens: \" << tokens.size();\n      }\n    } else {\n      string idpasskey = result[\"idpasskey\"].as<string>();\n      if (result.count(\"idpasskeyfile\")) {\n        // Check for passkey file\n        std::ifstream t(result[\"idpasskeyfile\"].as<string>().c_str());\n        std::stringstream buffer;\n        buffer << t.rdbuf();\n        idpasskey = buffer.str();\n        // Trim whitespace\n        idpasskey.erase(idpasskey.find_last_not_of(\" \\n\\r\\t\") + 1);\n      }\n    }\n\n    string id = split(idpasskey, '/')[0];\n    string username = string(ssh_get_local_username());\n    if (result.count(\"jump\")) {\n      // etserver with --jump cannot write to the default log file(root)\n      LogHandler::setupLogFiles(&defaultConf, GetTempDirectory(),\n                                (\"etjump-\" + username + \"-\" + id),\n                                result.count(\"logtostdout\"), false);\n      // Reconfigure default logger to apply settings above\n      el::Loggers::reconfigureLogger(\"default\", defaultConf);\n      // set thread name\n      el::Helpers::setThreadName(\"jump-main\");\n      // Install log rotation callback\n      el::Helpers::installPreRollOutCallback(LogHandler::rolloutHandler);\n\n      CLOG(INFO, \"stdout\") << \"IDPASSKEY:\" << idpasskey << endl;\n      if (DaemonCreator::createSessionLeader() == -1) {\n        STFATAL << \"Error creating daemon: \" << strerror(GetErrno());\n      }\n      SocketEndpoint destinationEndpoint;\n      destinationEndpoint.set_name(result[\"dsthost\"].as<string>());\n      destinationEndpoint.set_port(result[\"dstport\"].as<int>());\n      shared_ptr<SocketHandler> jumpClientSocketHandler(new TcpSocketHandler());\n      UserJumphostHandler ujh(jumpClientSocketHandler, idpasskey,\n                              destinationEndpoint, ipcSocketHandler,\n                              serverFifo.getEndpointForConnect());\n      ujh.run();\n\n      // Uninstall log rotation callback\n      el::Helpers::uninstallPreRollOutCallback();\n      return 0;\n    }\n\n    // etserver with --idpasskey cannot write to the default log file(root)\n    LogHandler::setupLogFiles(&defaultConf, GetTempDirectory(),\n                              (\"etterminal-\" + username + \"-\" + id),\n                              result.count(\"logtostdout\"), false);\n\n    // Reconfigure default logger to apply settings above\n    el::Loggers::reconfigureLogger(\"default\", defaultConf);\n    // set thread name\n    el::Helpers::setThreadName(\"terminal-main\");\n    // Install log rotation callback\n    el::Helpers::installPreRollOutCallback(LogHandler::rolloutHandler);\n\n    UserTerminalHandler uth(ipcSocketHandler, term, true,\n                            serverFifo.getEndpointForConnect(), idpasskey);\n    CLOG(INFO, \"stdout\") << \"IDPASSKEY:\" << idpasskey << endl;\n    if (DaemonCreator::createSessionLeader() == -1) {\n      STFATAL << \"Error creating daemon: \" << strerror(GetErrno());\n    }\n    uth.run();\n\n  } catch (cxxopts::OptionException& oe) {\n    CLOG(INFO, \"stdout\") << \"Exception: \" << oe.what() << \"\\n\" << endl;\n    CLOG(INFO, \"stdout\") << options.help({}) << endl;\n    exit(1);\n  }\n\n  // Uninstall log rotation callback\n  el::Helpers::uninstallPreRollOutCallback();\n  return 0;\n}",
        "func": "int main(int argc, char** argv) {\n  // Setup easylogging configurations\n  el::Configurations defaultConf = LogHandler::setupLogHandler(&argc, &argv);\n  LogHandler::setupStdoutLogger();\n\n  et::HandleTerminate();\n\n  // Override easylogging handler for sigint\n  ::signal(SIGINT, et::InterruptSignalHandler);\n\n  // Parse command line arguments\n  cxxopts::Options options(\"etterminal\", \"User terminal for Eternal Terminal.\");\n\n  try {\n    options.allow_unrecognised_options();\n\n    options.add_options()         //\n        (\"h,help\", \"Print help\")  //\n        (\"idpasskey\",\n         \"If set, uses IPC to send a client id/key to the server daemon. \"\n         \"Alternatively, pass in via stdin.\",\n         cxxopts::value<std::string>()->default_value(\"\"))  //\n        (\"idpasskeyfile\",\n         \"If set, uses IPC to send a client id/key to the server daemon from a \"\n         \"file. Alternatively, pass in via stdin.\",\n         cxxopts::value<std::string>()->default_value(\"\"))  //\n        (\"jump\",\n         \"If set, forward all packets between client and dst terminal\")  //\n        (\"dsthost\", \"Must be set if jump is set to true\",\n         cxxopts::value<std::string>()->default_value(\"\"))  //\n        (\"dstport\", \"Must be set if jump is set to true\",\n         cxxopts::value<int>()->default_value(\"2022\"))  //\n        // Not used by etterminal but easylogging uses this flag under the hood\n        (\"v,verbose\", \"Enable verbose logging\",\n         cxxopts::value<int>()->default_value(\"0\"))  //\n        (\"l,logdir\", \"Base directory for log files.\",\n         cxxopts::value<std::string>()->default_value(GetTempDirectory()))  //\n        (\"logtostdout\", \"Write log to stdout\")                              //\n        (\"serverfifo\",\n         \"If set, connects to the etserver instance listening on the matching \"\n         \"fifo name\",                                       //\n         cxxopts::value<std::string>()->default_value(\"\"))  //\n        ;\n\n    auto result = options.parse(argc, argv);\n    if (result.count(\"help\")) {\n      CLOG(INFO, \"stdout\") << options.help({}) << endl;\n      exit(0);\n    }\n\n    el::Loggers::setVerboseLevel(result[\"verbose\"].as<int>());\n\n    GOOGLE_PROTOBUF_VERIFY_VERSION;\n    srand(1);\n\n    ServerFifoPath serverFifo;\n    if (!result[\"serverfifo\"].as<string>().empty()) {\n      serverFifo.setPathOverride(result[\"serverfifo\"].as<string>());\n    }\n\n    shared_ptr<SocketHandler> ipcSocketHandler(new PipeSocketHandler());\n    shared_ptr<PsuedoUserTerminal> term(new PsuedoUserTerminal());\n\n    string idpasskey;\n    if (result.count(\"idpasskey\") == 0 && result.count(\"idpasskeyfile\") == 0) {\n      // Try to read from stdin\n      struct timeval timeout;\n      timeout.tv_sec = 1;\n      timeout.tv_usec = 0;\n      fd_set readfds;\n      FD_ZERO(&readfds);\n\n      FD_SET(STDIN_FILENO, &readfds);\n\n      int selectResult = 0;\n      do {\n        // Repeatedly calls when interrupted, up to the timeout.\n        selectResult = select(1, &readfds, NULL, NULL, &timeout);\n      } while (selectResult < 0 && errno == EINTR);\n\n      FATAL_FAIL(selectResult);\n      if (selectResult == 0) {\n        CLOG(INFO, \"stdout\")\n            << \"Call etterminal with --idpasskey or --idpasskeyfile, or feed \"\n               \"this information on stdin\\n\";\n        exit(1);\n      }\n\n      string stdinData;\n      if (!getline(cin, stdinData)) {\n        CLOG(INFO, \"stdout\")\n            << \"Call etterminal with --idpasskey or --idpasskeyfile, or feed \"\n               \"this information on stdin\\n\";\n        exit(1);\n      }\n      auto tokens = split(stdinData, '_');\n      if (tokens.size() == 2) {\n        idpasskey = tokens[0];\n        if (idpasskey.substr(0, 3) == std::string(\"XXX\")) {\n          // New client connecting to new server, throw away passkey and\n          // regenerate\n          string passkey = genRandomAlphaNum(32);\n          string id = genRandomAlphaNum(16);\n          idpasskey = id + string(\"/\") + passkey;\n        }\n\n        FATAL_FAIL(setenv(\"TERM\", tokens[1].c_str(), 1));\n      } else {\n        STFATAL << \"Invalid number of tokens: \" << tokens.size();\n      }\n    } else {\n      string idpasskey = result[\"idpasskey\"].as<string>();\n      if (result.count(\"idpasskeyfile\")) {\n        // Check for passkey file\n        std::ifstream t(result[\"idpasskeyfile\"].as<string>().c_str());\n        std::stringstream buffer;\n        buffer << t.rdbuf();\n        idpasskey = buffer.str();\n        // Trim whitespace\n        idpasskey.erase(idpasskey.find_last_not_of(\" \\n\\r\\t\") + 1);\n      }\n    }\n\n    string id = split(idpasskey, '/')[0];\n    string username = string(ssh_get_local_username());\n    if (result.count(\"jump\")) {\n      // etserver with --jump cannot write to the default log file(root)\n      LogHandler::setupLogFiles(&defaultConf, result[\"logdir\"].as<string>(),\n                                (\"etjump-\" + username + \"-\" + id),\n                                result.count(\"logtostdout\"), false);\n      // Reconfigure default logger to apply settings above\n      el::Loggers::reconfigureLogger(\"default\", defaultConf);\n      // set thread name\n      el::Helpers::setThreadName(\"jump-main\");\n      // Install log rotation callback\n      el::Helpers::installPreRollOutCallback(LogHandler::rolloutHandler);\n\n      CLOG(INFO, \"stdout\") << \"IDPASSKEY:\" << idpasskey << endl;\n      if (DaemonCreator::createSessionLeader() == -1) {\n        STFATAL << \"Error creating daemon: \" << strerror(GetErrno());\n      }\n      SocketEndpoint destinationEndpoint;\n      destinationEndpoint.set_name(result[\"dsthost\"].as<string>());\n      destinationEndpoint.set_port(result[\"dstport\"].as<int>());\n      shared_ptr<SocketHandler> jumpClientSocketHandler(new TcpSocketHandler());\n      UserJumphostHandler ujh(jumpClientSocketHandler, idpasskey,\n                              destinationEndpoint, ipcSocketHandler,\n                              serverFifo.getEndpointForConnect());\n      ujh.run();\n\n      // Uninstall log rotation callback\n      el::Helpers::uninstallPreRollOutCallback();\n      return 0;\n    }\n\n    // etserver with --idpasskey cannot write to the default log file(root)\n    LogHandler::setupLogFiles(&defaultConf, result[\"logdir\"].as<string>(),\n                              (\"etterminal-\" + username + \"-\" + id),\n                              result.count(\"logtostdout\"), false);\n\n    // Reconfigure default logger to apply settings above\n    el::Loggers::reconfigureLogger(\"default\", defaultConf);\n    // set thread name\n    el::Helpers::setThreadName(\"terminal-main\");\n    // Install log rotation callback\n    el::Helpers::installPreRollOutCallback(LogHandler::rolloutHandler);\n\n    UserTerminalHandler uth(ipcSocketHandler, term, true,\n                            serverFifo.getEndpointForConnect(), idpasskey);\n    CLOG(INFO, \"stdout\") << \"IDPASSKEY:\" << idpasskey << endl;\n    if (DaemonCreator::createSessionLeader() == -1) {\n      STFATAL << \"Error creating daemon: \" << strerror(GetErrno());\n    }\n    uth.run();\n\n  } catch (cxxopts::OptionException& oe) {\n    CLOG(INFO, \"stdout\") << \"Exception: \" << oe.what() << \"\\n\" << endl;\n    CLOG(INFO, \"stdout\") << options.help({}) << endl;\n    exit(1);\n  }\n\n  // Uninstall log rotation callback\n  el::Helpers::uninstallPreRollOutCallback();\n  return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -33,7 +33,9 @@\n         // Not used by etterminal but easylogging uses this flag under the hood\n         (\"v,verbose\", \"Enable verbose logging\",\n          cxxopts::value<int>()->default_value(\"0\"))  //\n-        (\"logtostdout\", \"Write log to stdout\")       //\n+        (\"l,logdir\", \"Base directory for log files.\",\n+         cxxopts::value<std::string>()->default_value(GetTempDirectory()))  //\n+        (\"logtostdout\", \"Write log to stdout\")                              //\n         (\"serverfifo\",\n          \"If set, connects to the etserver instance listening on the matching \"\n          \"fifo name\",                                       //\n@@ -123,7 +125,7 @@\n     string username = string(ssh_get_local_username());\n     if (result.count(\"jump\")) {\n       // etserver with --jump cannot write to the default log file(root)\n-      LogHandler::setupLogFiles(&defaultConf, GetTempDirectory(),\n+      LogHandler::setupLogFiles(&defaultConf, result[\"logdir\"].as<string>(),\n                                 (\"etjump-\" + username + \"-\" + id),\n                                 result.count(\"logtostdout\"), false);\n       // Reconfigure default logger to apply settings above\n@@ -152,7 +154,7 @@\n     }\n \n     // etserver with --idpasskey cannot write to the default log file(root)\n-    LogHandler::setupLogFiles(&defaultConf, GetTempDirectory(),\n+    LogHandler::setupLogFiles(&defaultConf, result[\"logdir\"].as<string>(),\n                               (\"etterminal-\" + username + \"-\" + id),\n                               result.count(\"logtostdout\"), false);\n ",
        "diff_line_info": {
            "deleted_lines": [
                "        (\"logtostdout\", \"Write log to stdout\")       //",
                "      LogHandler::setupLogFiles(&defaultConf, GetTempDirectory(),",
                "    LogHandler::setupLogFiles(&defaultConf, GetTempDirectory(),"
            ],
            "added_lines": [
                "        (\"l,logdir\", \"Base directory for log files.\",",
                "         cxxopts::value<std::string>()->default_value(GetTempDirectory()))  //",
                "        (\"logtostdout\", \"Write log to stdout\")                              //",
                "      LogHandler::setupLogFiles(&defaultConf, result[\"logdir\"].as<string>(),",
                "    LogHandler::setupLogFiles(&defaultConf, result[\"logdir\"].as<string>(),"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-48257",
        "func_name": "MisterTea/EternalTerminal/main",
        "description": "In Eternal Terminal 6.2.1, etserver and etclient have predictable logfile names in /tmp.",
        "git_url": "https://github.com/MisterTea/EternalTerminal/commit/04e64d442adb780a126996aa910da84e6939185a",
        "commit_title": "Logfile location configurability.",
        "commit_text": " Fixes #555",
        "func_before": "int main(int argc, char **argv) {\n  // Setup easylogging configurations\n  el::Configurations defaultConf = LogHandler::setupLogHandler(&argc, &argv);\n  LogHandler::setupStdoutLogger();\n\n  et::HandleTerminate();\n\n  // Override easylogging handler for sigint\n  ::signal(SIGINT, et::InterruptSignalHandler);\n\n  cxxopts::Options options(\"etserver\",\n                           \"Remote shell for the busy and impatient\");\n  try {\n    // Parse command line arguments\n    options.allow_unrecognised_options();\n\n    options.add_options()             //\n        (\"h,help\", \"Print help\")      //\n        (\"version\", \"Print version\")  //\n        (\"port\", \"Port to listen on\",\n         cxxopts::value<int>()->default_value(\"0\"))  //\n        (\"bindip\", \"IP to listen on\",\n         cxxopts::value<string>()->default_value(\"\"))  //\n        (\"daemon\", \"Daemonize the server\")             //\n        (\"cfgfile\", \"Location of the config file\",\n         cxxopts::value<std::string>()->default_value(\"\"))  //\n        (\"logtostdout\", \"log to stdout\")                    //\n        (\"pidfile\", \"Location of the pid file\",\n         cxxopts::value<std::string>()->default_value(\n             \"/var/run/etserver.pid\"))  //\n        (\"v,verbose\", \"Enable verbose logging\",\n         cxxopts::value<int>()->default_value(\"0\"), \"LEVEL\")  //\n        (\"serverfifo\",\n         \"If set, listens on the matching fifo name\",       //\n         cxxopts::value<std::string>()->default_value(\"\"))  //\n        (\"telemetry\",\n         \"Allow et to anonymously send errors to guide future improvements\",\n         cxxopts::value<bool>())  //\n        ;\n\n    auto result = options.parse(argc, argv);\n\n    if (result.count(\"help\")) {\n      CLOG(INFO, \"stdout\") << options.help({}) << endl;\n      exit(0);\n    }\n    if (result.count(\"version\")) {\n      CLOG(INFO, \"stdout\") << \"et version \" << ET_VERSION << endl;\n      exit(0);\n    }\n\n    el::Loggers::setVerboseLevel(result[\"verbose\"].as<int>());\n\n    if (result.count(\"daemon\")) {\n      if (DaemonCreator::create(true, result[\"pidfile\"].as<string>()) == -1) {\n        STFATAL << \"Error creating daemon: \" << strerror(GetErrno());\n      }\n    }\n\n    ServerFifoPath serverFifo;\n\n    // default max log file size is 20MB for etserver\n    string maxlogsize = \"20971520\";\n\n    int port = 0;\n    string bindIp = \"\";\n    bool telemetry = false;\n    if (result.count(\"cfgfile\")) {\n      // Load the config file\n      CSimpleIniA ini(true, false, false);\n      string cfgfilename = result[\"cfgfile\"].as<string>();\n      SI_Error rc = ini.LoadFile(cfgfilename.c_str());\n      if (rc == 0) {\n        if (!result.count(\"port\")) {\n          const char *portString = ini.GetValue(\"Networking\", \"port\", NULL);\n          if (portString) {\n            port = stoi(portString);\n          }\n        }\n\n        if (!result.count(\"bindip\")) {\n          const char *bindIpPtr = ini.GetValue(\"Networking\", \"bind_ip\", NULL);\n          if (bindIpPtr) {\n            bindIp = string(bindIpPtr);\n          }\n        }\n\n        telemetry = ini.GetBoolValue(\"Debug\", \"telemetry\", false);\n        // read verbose level (prioritize command line option over cfgfile)\n        const char *vlevel = ini.GetValue(\"Debug\", \"verbose\", NULL);\n        if (result.count(\"verbose\")) {\n          el::Loggers::setVerboseLevel(result[\"verbose\"].as<int>());\n        } else if (vlevel) {\n          el::Loggers::setVerboseLevel(atoi(vlevel));\n        }\n\n        const char *fifoName = ini.GetValue(\"Debug\", \"serverfifo\", NULL);\n        if (fifoName) {\n          const string fifoNameStr(fifoName);\n          if (!fifoNameStr.empty()) {\n            serverFifo.setPathOverride(fifoNameStr);\n          }\n        }\n\n        // read silent setting\n        const char *silent = ini.GetValue(\"Debug\", \"silent\", NULL);\n        if (silent && atoi(silent) != 0) {\n          defaultConf.setGlobally(el::ConfigurationType::Enabled, \"false\");\n        }\n        // read log file size limit\n        const char *logsize = ini.GetValue(\"Debug\", \"logsize\", NULL);\n        if (logsize && atoi(logsize) != 0) {\n          // make sure maxlogsize is a string of int value\n          maxlogsize = string(logsize);\n        }\n\n      } else {\n        STFATAL << \"Invalid config file: \" << cfgfilename;\n      }\n    }\n\n    if (result.count(\"serverfifo\") &&\n        !result[\"serverfifo\"].as<string>().empty()) {\n      serverFifo.setPathOverride(result[\"serverfifo\"].as<string>());\n    }\n\n    if (result.count(\"port\")) {\n      port = result[\"port\"].as<int>();\n    }\n\n    if (result.count(\"bindip\")) {\n      bindIp = result[\"bindip\"].as<string>();\n    }\n\n    if (result.count(\"telemetry\")) {\n      telemetry = result[\"telemetry\"].as<bool>();\n    }\n\n    GOOGLE_PROTOBUF_VERIFY_VERSION;\n    srand(1);\n\n    if (port == 0) {\n      port = 2022;\n    }\n\n    // Set log file for etserver process here.\n    LogHandler::setupLogFiles(&defaultConf, GetTempDirectory(), \"etserver\",\n                              result.count(\"logtostdout\"),\n                              !result.count(\"logtostdout\"),\n                              true /* appendPid */, maxlogsize);\n    // Reconfigure default logger to apply settings above\n    el::Loggers::reconfigureLogger(\"default\", defaultConf);\n    // set thread name\n    el::Helpers::setThreadName(\"etserver-main\");\n    // Install log rotation callback\n    el::Helpers::installPreRollOutCallback(LogHandler::rolloutHandler);\n\n    TelemetryService::create(\n        telemetry, GetTempDirectory() + \"/.sentry-native-etserver\", \"Server\");\n\n    serverFifo.createDirectoriesIfRequired();\n\n    std::shared_ptr<SocketHandler> tcpSocketHandler(new TcpSocketHandler());\n    std::shared_ptr<PipeSocketHandler> pipeSocketHandler(\n        new PipeSocketHandler());\n\n    LOG(INFO) << \"In child, about to start server.\";\n\n    SocketEndpoint serverEndpoint;\n    serverEndpoint.set_port(port);\n    if (bindIp.length()) {\n      serverEndpoint.set_name(bindIp);\n    }\n    SocketEndpoint routerFifo;\n    routerFifo.set_name(serverFifo.getPathForCreation());\n    TerminalServer terminalServer(tcpSocketHandler, serverEndpoint,\n                                  pipeSocketHandler, routerFifo);\n    terminalServer.run();\n\n  } catch (cxxopts::OptionException &oe) {\n    CLOG(INFO, \"stdout\") << \"Exception: \" << oe.what() << \"\\n\" << endl;\n    CLOG(INFO, \"stdout\") << options.help({}) << endl;\n    exit(1);\n  }\n\n  // Uninstall log rotation callback\n  el::Helpers::uninstallPreRollOutCallback();\n}",
        "func": "int main(int argc, char **argv) {\n  // Setup easylogging configurations\n  el::Configurations defaultConf = LogHandler::setupLogHandler(&argc, &argv);\n  LogHandler::setupStdoutLogger();\n\n  et::HandleTerminate();\n\n  // Override easylogging handler for sigint\n  ::signal(SIGINT, et::InterruptSignalHandler);\n\n  cxxopts::Options options(\"etserver\",\n                           \"Remote shell for the busy and impatient\");\n  try {\n    // Parse command line arguments\n    options.allow_unrecognised_options();\n\n    options.add_options()             //\n        (\"h,help\", \"Print help\")      //\n        (\"version\", \"Print version\")  //\n        (\"port\", \"Port to listen on\",\n         cxxopts::value<int>()->default_value(\"0\"))  //\n        (\"bindip\", \"IP to listen on\",\n         cxxopts::value<string>()->default_value(\"\"))  //\n        (\"daemon\", \"Daemonize the server\")             //\n        (\"cfgfile\", \"Location of the config file\",\n         cxxopts::value<std::string>()->default_value(\"\"))  //\n        (\"l,logdir\", \"Base directory for log files.\",\n         cxxopts::value<std::string>())   //\n        (\"logtostdout\", \"log to stdout\")  //\n        (\"pidfile\", \"Location of the pid file\",\n         cxxopts::value<std::string>()->default_value(\n             \"/var/run/etserver.pid\"))  //\n        (\"v,verbose\", \"Enable verbose logging\",\n         cxxopts::value<int>()->default_value(\"0\"), \"LEVEL\")  //\n        (\"serverfifo\",\n         \"If set, listens on the matching fifo name\",       //\n         cxxopts::value<std::string>()->default_value(\"\"))  //\n        (\"telemetry\",\n         \"Allow et to anonymously send errors to guide future improvements\",\n         cxxopts::value<bool>())  //\n        ;\n\n    auto result = options.parse(argc, argv);\n\n    if (result.count(\"help\")) {\n      CLOG(INFO, \"stdout\") << options.help({}) << endl;\n      exit(0);\n    }\n    if (result.count(\"version\")) {\n      CLOG(INFO, \"stdout\") << \"et version \" << ET_VERSION << endl;\n      exit(0);\n    }\n\n    el::Loggers::setVerboseLevel(result[\"verbose\"].as<int>());\n\n    if (result.count(\"daemon\")) {\n      if (DaemonCreator::create(true, result[\"pidfile\"].as<string>()) == -1) {\n        STFATAL << \"Error creating daemon: \" << strerror(GetErrno());\n      }\n    }\n\n    ServerFifoPath serverFifo;\n\n    // default max log file size is 20MB for etserver\n    string maxlogsize = \"20971520\";\n\n    int port = 0;\n    string bindIp = \"\";\n    bool telemetry = false;\n    string logDirectory = GetTempDirectory();\n    if (result.count(\"cfgfile\")) {\n      // Load the config file\n      CSimpleIniA ini(true, false, false);\n      string cfgfilename = result[\"cfgfile\"].as<string>();\n      SI_Error rc = ini.LoadFile(cfgfilename.c_str());\n      if (rc == 0) {\n        if (!result.count(\"port\")) {\n          const char *portString = ini.GetValue(\"Networking\", \"port\", NULL);\n          if (portString) {\n            port = stoi(portString);\n          }\n        }\n\n        if (!result.count(\"bindip\")) {\n          const char *bindIpPtr = ini.GetValue(\"Networking\", \"bind_ip\", NULL);\n          if (bindIpPtr) {\n            bindIp = string(bindIpPtr);\n          }\n        }\n\n        telemetry = ini.GetBoolValue(\"Debug\", \"telemetry\", false);\n        // read verbose level (prioritize command line option over cfgfile)\n        const char *vlevel = ini.GetValue(\"Debug\", \"verbose\", NULL);\n        if (result.count(\"verbose\")) {\n          el::Loggers::setVerboseLevel(result[\"verbose\"].as<int>());\n        } else if (vlevel) {\n          el::Loggers::setVerboseLevel(atoi(vlevel));\n        }\n\n        const char *fifoName = ini.GetValue(\"Debug\", \"serverfifo\", NULL);\n        if (fifoName) {\n          const string fifoNameStr(fifoName);\n          if (!fifoNameStr.empty()) {\n            serverFifo.setPathOverride(fifoNameStr);\n          }\n        }\n\n        // read silent setting\n        const char *silent = ini.GetValue(\"Debug\", \"silent\", NULL);\n        if (silent && atoi(silent) != 0) {\n          defaultConf.setGlobally(el::ConfigurationType::Enabled, \"false\");\n        }\n\n        // read log file size limit\n        const char *logsize = ini.GetValue(\"Debug\", \"logsize\", NULL);\n        if (logsize && atoi(logsize) != 0) {\n          // make sure maxlogsize is a string of int value\n          maxlogsize = string(logsize);\n        }\n\n        // log file directory (TODO path validation and trailing slash cleanup)\n        const char *logdir = ini.GetValue(\"Debug\", \"logdirectory\", NULL);\n        if (logdir) {\n          logDirectory = string(logdir);\n        }\n      } else {\n        STFATAL << \"Invalid config file: \" << cfgfilename;\n      }\n    }\n\n    if (result.count(\"serverfifo\") &&\n        !result[\"serverfifo\"].as<string>().empty()) {\n      serverFifo.setPathOverride(result[\"serverfifo\"].as<string>());\n    }\n\n    if (result.count(\"port\")) {\n      port = result[\"port\"].as<int>();\n    }\n\n    if (result.count(\"bindip\")) {\n      bindIp = result[\"bindip\"].as<string>();\n    }\n\n    if (result.count(\"telemetry\")) {\n      telemetry = result[\"telemetry\"].as<bool>();\n    }\n\n    if (result.count(\"logdir\")) {\n      logDirectory = result[\"logdir\"].as<string>();\n    }\n\n    GOOGLE_PROTOBUF_VERIFY_VERSION;\n    srand(1);\n\n    if (port == 0) {\n      port = 2022;\n    }\n\n    // Set log file for etserver process here.\n    LogHandler::setupLogFiles(\n        &defaultConf, logDirectory, \"etserver\", result.count(\"logtostdout\"),\n        !result.count(\"logtostdout\"), true /* appendPid */, maxlogsize);\n    // Reconfigure default logger to apply settings above\n    el::Loggers::reconfigureLogger(\"default\", defaultConf);\n    // set thread name\n    el::Helpers::setThreadName(\"etserver-main\");\n    // Install log rotation callback\n    el::Helpers::installPreRollOutCallback(LogHandler::rolloutHandler);\n\n    TelemetryService::create(\n        telemetry, GetTempDirectory() + \"/.sentry-native-etserver\", \"Server\");\n\n    serverFifo.createDirectoriesIfRequired();\n\n    std::shared_ptr<SocketHandler> tcpSocketHandler(new TcpSocketHandler());\n    std::shared_ptr<PipeSocketHandler> pipeSocketHandler(\n        new PipeSocketHandler());\n\n    LOG(INFO) << \"In child, about to start server.\";\n\n    SocketEndpoint serverEndpoint;\n    serverEndpoint.set_port(port);\n    if (bindIp.length()) {\n      serverEndpoint.set_name(bindIp);\n    }\n    SocketEndpoint routerFifo;\n    routerFifo.set_name(serverFifo.getPathForCreation());\n    TerminalServer terminalServer(tcpSocketHandler, serverEndpoint,\n                                  pipeSocketHandler, routerFifo);\n    terminalServer.run();\n\n  } catch (cxxopts::OptionException &oe) {\n    CLOG(INFO, \"stdout\") << \"Exception: \" << oe.what() << \"\\n\" << endl;\n    CLOG(INFO, \"stdout\") << options.help({}) << endl;\n    exit(1);\n  }\n\n  // Uninstall log rotation callback\n  el::Helpers::uninstallPreRollOutCallback();\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -24,7 +24,9 @@\n         (\"daemon\", \"Daemonize the server\")             //\n         (\"cfgfile\", \"Location of the config file\",\n          cxxopts::value<std::string>()->default_value(\"\"))  //\n-        (\"logtostdout\", \"log to stdout\")                    //\n+        (\"l,logdir\", \"Base directory for log files.\",\n+         cxxopts::value<std::string>())   //\n+        (\"logtostdout\", \"log to stdout\")  //\n         (\"pidfile\", \"Location of the pid file\",\n          cxxopts::value<std::string>()->default_value(\n              \"/var/run/etserver.pid\"))  //\n@@ -65,6 +67,7 @@\n     int port = 0;\n     string bindIp = \"\";\n     bool telemetry = false;\n+    string logDirectory = GetTempDirectory();\n     if (result.count(\"cfgfile\")) {\n       // Load the config file\n       CSimpleIniA ini(true, false, false);\n@@ -107,6 +110,7 @@\n         if (silent && atoi(silent) != 0) {\n           defaultConf.setGlobally(el::ConfigurationType::Enabled, \"false\");\n         }\n+\n         // read log file size limit\n         const char *logsize = ini.GetValue(\"Debug\", \"logsize\", NULL);\n         if (logsize && atoi(logsize) != 0) {\n@@ -114,6 +118,11 @@\n           maxlogsize = string(logsize);\n         }\n \n+        // log file directory (TODO path validation and trailing slash cleanup)\n+        const char *logdir = ini.GetValue(\"Debug\", \"logdirectory\", NULL);\n+        if (logdir) {\n+          logDirectory = string(logdir);\n+        }\n       } else {\n         STFATAL << \"Invalid config file: \" << cfgfilename;\n       }\n@@ -136,6 +145,10 @@\n       telemetry = result[\"telemetry\"].as<bool>();\n     }\n \n+    if (result.count(\"logdir\")) {\n+      logDirectory = result[\"logdir\"].as<string>();\n+    }\n+\n     GOOGLE_PROTOBUF_VERIFY_VERSION;\n     srand(1);\n \n@@ -144,10 +157,9 @@\n     }\n \n     // Set log file for etserver process here.\n-    LogHandler::setupLogFiles(&defaultConf, GetTempDirectory(), \"etserver\",\n-                              result.count(\"logtostdout\"),\n-                              !result.count(\"logtostdout\"),\n-                              true /* appendPid */, maxlogsize);\n+    LogHandler::setupLogFiles(\n+        &defaultConf, logDirectory, \"etserver\", result.count(\"logtostdout\"),\n+        !result.count(\"logtostdout\"), true /* appendPid */, maxlogsize);\n     // Reconfigure default logger to apply settings above\n     el::Loggers::reconfigureLogger(\"default\", defaultConf);\n     // set thread name",
        "diff_line_info": {
            "deleted_lines": [
                "        (\"logtostdout\", \"log to stdout\")                    //",
                "    LogHandler::setupLogFiles(&defaultConf, GetTempDirectory(), \"etserver\",",
                "                              result.count(\"logtostdout\"),",
                "                              !result.count(\"logtostdout\"),",
                "                              true /* appendPid */, maxlogsize);"
            ],
            "added_lines": [
                "        (\"l,logdir\", \"Base directory for log files.\",",
                "         cxxopts::value<std::string>())   //",
                "        (\"logtostdout\", \"log to stdout\")  //",
                "    string logDirectory = GetTempDirectory();",
                "",
                "        // log file directory (TODO path validation and trailing slash cleanup)",
                "        const char *logdir = ini.GetValue(\"Debug\", \"logdirectory\", NULL);",
                "        if (logdir) {",
                "          logDirectory = string(logdir);",
                "        }",
                "    if (result.count(\"logdir\")) {",
                "      logDirectory = result[\"logdir\"].as<string>();",
                "    }",
                "",
                "    LogHandler::setupLogFiles(",
                "        &defaultConf, logDirectory, \"etserver\", result.count(\"logtostdout\"),",
                "        !result.count(\"logtostdout\"), true /* appendPid */, maxlogsize);"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-48257",
        "func_name": "MisterTea/EternalTerminal/main",
        "description": "In Eternal Terminal 6.2.1, etserver and etclient have predictable logfile names in /tmp.",
        "git_url": "https://github.com/MisterTea/EternalTerminal/commit/04e64d442adb780a126996aa910da84e6939185a",
        "commit_title": "Logfile location configurability.",
        "commit_text": " Fixes #555",
        "func_before": "int main(int argc, char** argv) {\n  WinsockContext context;\n  string tmpDir = GetTempDirectory();\n\n  // Setup easylogging configurations\n  el::Configurations defaultConf = LogHandler::setupLogHandler(&argc, &argv);\n  LogHandler::setupStdoutLogger();\n\n  et::HandleTerminate();\n\n  // Override easylogging handler for sigint\n  ::signal(SIGINT, et::InterruptSignalHandler);\n\n  // Parse command line arguments\n  cxxopts::Options options(\"et\", \"Remote shell for the busy and impatient\");\n  try {\n    options.allow_unrecognised_options();\n    options.positional_help(\"\");\n    options.custom_help(\n        \"[OPTION...] [user@]host[:port]\\n\\n\"\n        \"  Note that 'host' can be a hostname or ipv4 address with or without \"\n        \"a port\\n  or an ipv6 address. If the ipv6 address is abbreviated with \"\n        \":: then it must\\n  be specfied without a port (use -p,--port).\");\n\n    options.add_options()             //\n        (\"h,help\", \"Print help\")      //\n        (\"version\", \"Print version\")  //\n        (\"u,username\", \"Username\")    //\n        (\"host\", \"Remote host name\",\n         cxxopts::value<std::string>())  //\n        (\"p,port\", \"Remote machine etserver port\",\n         cxxopts::value<int>()->default_value(\"2022\"))  //\n        (\"c,command\", \"Run command on connect\",\n         cxxopts::value<std::string>())  //\n        (\"terminal-path\",\n         \"Path to etterminal on server side. \"\n         \"Use if etterminal is not on the system path.\",\n         cxxopts::value<std::string>())  //\n        (\"t,tunnel\",\n         \"Tunnel: Array of source:destination ports or \"\n         \"srcStart-srcEnd:dstStart-dstEnd (inclusive) port ranges (e.g. \"\n         \"10080:80,10443:443, 10090-10092:8000-8002)\",\n         cxxopts::value<std::string>())  //\n        (\"r,reversetunnel\",\n         \"Reverse Tunnel: Array of source:destination ports or \"\n         \"srcStart-srcEnd:dstStart-dstEnd (inclusive) port ranges\",\n         cxxopts::value<std::string>())  //\n        (\"jumphost\", \"jumphost between localhost and destination\",\n         cxxopts::value<std::string>())  //\n        (\"jport\", \"Jumphost machine port\",\n         cxxopts::value<int>()->default_value(\"2022\"))  //\n        (\"x,kill-other-sessions\",\n         \"kill all old sessions belonging to the user\")  //\n        (\"macserver\",\n         \"Set when connecting to an macOS server.  Sets \"\n         \"--terminal-path=/usr/local/bin/etterminal\")  //\n        (\"v,verbose\", \"Enable verbose logging\",\n         cxxopts::value<int>()->default_value(\"0\"))  //\n        (\"k,keepalive\", \"Client keepalive duration in seconds\",\n         cxxopts::value<int>())                              //\n        (\"logtostdout\", \"Write log to stdout\")               //\n        (\"silent\", \"Disable logging\")                        //\n        (\"N,no-terminal\", \"Do not create a terminal\")        //\n        (\"f,forward-ssh-agent\", \"Forward ssh-agent socket\")  //\n        (\"ssh-socket\", \"The ssh-agent socket to forward\",\n         cxxopts::value<std::string>())  //\n        (\"telemetry\",\n         \"Allow et to anonymously send errors to guide future improvements\",\n         cxxopts::value<bool>()->default_value(\"true\"))  //\n        (\"serverfifo\",\n         \"If set, communicate to etserver on the matching fifo name\",\n         cxxopts::value<std::string>()->default_value(\"\"))  //\n        (\"ssh-option\", \"Options to pass down to `ssh -o`\",\n         cxxopts::value<std::vector<std::string>>());\n\n    options.parse_positional({\"host\"});\n    auto result = options.parse(argc, argv);\n\n    if (result.count(\"help\")) {\n      CLOG(INFO, \"stdout\") << options.help({}) << endl;\n      exit(0);\n    }\n\n    if (result.count(\"version\")) {\n      CLOG(INFO, \"stdout\") << \"et version \" << ET_VERSION << endl;\n      exit(0);\n    }\n\n    el::Loggers::setVerboseLevel(result[\"verbose\"].as<int>());\n\n    // silent Flag, since etclient doesn't read /etc/et.cfg file\n    if (result.count(\"silent\")) {\n      defaultConf.setGlobally(el::ConfigurationType::Enabled, \"false\");\n    }\n\n    LogHandler::setupLogFiles(&defaultConf, tmpDir, \"etclient\",\n                              result.count(\"logtostdout\"),\n                              !result.count(\"logtostdout\"));\n\n    el::Loggers::reconfigureLogger(\"default\", defaultConf);\n    // set thread name\n    el::Helpers::setThreadName(\"client-main\");\n\n    // Install log rotation callback\n    el::Helpers::installPreRollOutCallback(LogHandler::rolloutHandler);\n\n    GOOGLE_PROTOBUF_VERIFY_VERSION;\n    srand(1);\n\n    TelemetryService::create(result[\"telemetry\"].as<bool>(),\n                             tmpDir + \"/.sentry-native-et\", \"Client\");\n\n    string username = \"\";\n    if (result.count(\"username\")) {\n      username = result[\"username\"].as<string>();\n    }\n    int destinationPort = result[\"port\"].as<int>();\n    string destinationHost;\n\n    // Parse command-line argument\n    if (!result.count(\"host\")) {\n      CLOG(INFO, \"stdout\") << \"Missing host to connect to\" << endl;\n      CLOG(INFO, \"stdout\") << options.help({}) << endl;\n      exit(0);\n    }\n    string host_arg = result[\"host\"].as<std::string>();\n    if (host_arg.find('@') != string::npos) {\n      int i = host_arg.find('@');\n      username = host_arg.substr(0, i);\n      host_arg = host_arg.substr(i + 1);\n    }\n\n    if (host_arg.find(':') != string::npos) {\n      int colon_count = std::count(host_arg.begin(), host_arg.end(), ':');\n      if (colon_count == 1) {\n        // ipv4 or hostname with port specified\n        int port_colon_pos = host_arg.rfind(':');\n        destinationPort = stoi(host_arg.substr(port_colon_pos + 1));\n        host_arg = host_arg.substr(0, port_colon_pos);\n      } else {\n        // maybe ipv6 (colon_count >= 2)\n        if (host_arg.find(\"::\") != string::npos) {\n          // ipv6 with double colon zero abbreviation and no port\n          // leave host_arg as is\n        } else {\n          if (colon_count == 7) {\n            // ipv6, fully expanded, without port\n          } else if (colon_count == 8) {\n            // ipv6, fully expanded, with port\n            int port_colon_pos = host_arg.rfind(':');\n            destinationPort = stoi(host_arg.substr(port_colon_pos + 1));\n            host_arg = host_arg.substr(0, port_colon_pos);\n          } else {\n            CLOG(INFO, \"stdout\") << \"Invalid host positional arg: \"\n                                 << result[\"host\"].as<std::string>() << endl;\n            exit(1);\n          }\n        }\n      }\n    }\n    destinationHost = host_arg;\n    // host_alias is used for the initiating ssh call, if sshd runs on a port\n    // other than 22, either configure your .ssh/config with an alias with an\n    // overridden port or pass --ssh-option Port=<sshd_port>\n    string host_alias = destinationHost;\n\n    string jumphost =\n        result.count(\"jumphost\") ? result[\"jumphost\"].as<string>() : \"\";\n    int keepaliveDuration = result.count(\"keepalive\")\n                                ? result[\"keepalive\"].as<int>()\n                                : MAX_CLIENT_KEEP_ALIVE_DURATION;\n    if (keepaliveDuration < 1 ||\n        keepaliveDuration > MAX_CLIENT_KEEP_ALIVE_DURATION) {\n      CLOG(INFO, \"stdout\") << \"Keep-alive duration must between 1 and \"\n                           << MAX_CLIENT_KEEP_ALIVE_DURATION << \" seconds\"\n                           << endl;\n      CLOG(INFO, \"stdout\") << options.help({}) << endl;\n      exit(0);\n    }\n\n    Options sshConfigOptions = {\n        NULL,  // username\n        NULL,  // host\n        NULL,  // sshdir\n        NULL,  // knownhosts\n        NULL,  // ProxyCommand\n        NULL,  // ProxyJump\n        0,     // timeout\n        0,     // port\n        0,     // StrictHostKeyChecking\n        0,     // ssh2\n        0,     // ssh1\n        NULL,  // gss_server_identity\n        NULL,  // gss_client_identity\n        0,     // gss_delegate_creds\n        0,     // forward_agent\n        NULL   // identity_agent\n    };\n\n    char* home_dir = ssh_get_user_home_dir();\n    const char* host_from_command = destinationHost.c_str();\n    ssh_options_set(&sshConfigOptions, SSH_OPTIONS_HOST,\n                    destinationHost.c_str());\n    // First parse user-specific ssh config, then system-wide config.\n    parse_ssh_config_file(host_from_command, &sshConfigOptions,\n                          string(home_dir) + USER_SSH_CONFIG_PATH);\n    parse_ssh_config_file(host_from_command, &sshConfigOptions,\n                          SYSTEM_SSH_CONFIG_PATH);\n    LOG(INFO) << \"Parsed ssh config file, connecting to \"\n              << sshConfigOptions.host;\n    destinationHost = string(sshConfigOptions.host);\n\n    // Parse username: cmdline > sshconfig > localuser\n    if (username.empty()) {\n      if (sshConfigOptions.username) {\n        username = string(sshConfigOptions.username);\n      } else {\n        username = string(ssh_get_local_username());\n      }\n    }\n\n    // Parse jumphost: cmd > sshconfig\n    if (sshConfigOptions.ProxyJump && jumphost.length() == 0) {\n      string proxyjump = string(sshConfigOptions.ProxyJump);\n      size_t colonIndex = proxyjump.find(\":\");\n      if (colonIndex != string::npos) {\n        string userhostpair = proxyjump.substr(0, colonIndex);\n        size_t atIndex = userhostpair.find(\"@\");\n        if (atIndex != string::npos) {\n          jumphost = userhostpair.substr(atIndex + 1);\n        }\n      } else {\n        jumphost = proxyjump;\n      }\n      LOG(INFO) << \"ProxyJump found for dst in ssh config: \" << proxyjump;\n    }\n\n    bool is_jumphost = false;\n    SocketEndpoint socketEndpoint;\n    if (!jumphost.empty()) {\n      is_jumphost = true;\n      LOG(INFO) << \"Setting port to jumphost port\";\n      socketEndpoint.set_name(jumphost);\n      socketEndpoint.set_port(result[\"jport\"].as<int>());\n    } else {\n      socketEndpoint.set_name(destinationHost);\n      socketEndpoint.set_port(destinationPort);\n    }\n    shared_ptr<SocketHandler> clientSocket(new TcpSocketHandler());\n    shared_ptr<SocketHandler> clientPipeSocket(new PipeSocketHandler());\n\n    if (!ping(socketEndpoint, clientSocket)) {\n      CLOG(INFO, \"stdout\") << \"Could not reach the ET server: \"\n                           << socketEndpoint.name() << \":\"\n                           << socketEndpoint.port() << endl;\n      exit(1);\n    }\n\n    int jport = result[\"jport\"].as<int>();\n    string serverFifo = \"\";\n    if (result[\"serverfifo\"].as<string>() != \"\") {\n      serverFifo = result[\"serverfifo\"].as<string>();\n    }\n    std::vector<string> ssh_options;\n    if (result.count(\"ssh-option\")) {\n      ssh_options = result[\"ssh-option\"].as<std::vector<string>>();\n    }\n    string etterminal_path = \"\";\n    if (result.count(\"macserver\") > 0) {\n      etterminal_path = \"/usr/local/bin/etterminal\";\n    }\n    if (result.count(\"etterminal_path\")) {\n      etterminal_path = result[\"terminal-path\"].as<string>();\n    }\n    string idpasskeypair = SshSetupHandler::SetupSsh(\n        username, destinationHost, host_alias, destinationPort, jumphost, jport,\n        result.count(\"x\") > 0, result[\"verbose\"].as<int>(), etterminal_path,\n        serverFifo, ssh_options);\n\n    string id = \"\", passkey = \"\";\n    // Trim whitespace\n    idpasskeypair.erase(idpasskeypair.find_last_not_of(\" \\n\\r\\t\") + 1);\n    size_t slashIndex = idpasskeypair.find(\"/\");\n    if (slashIndex == string::npos) {\n      STFATAL << \"Invalid idPasskey id/key pair: \" << idpasskeypair;\n    } else {\n      id = idpasskeypair.substr(0, slashIndex);\n      passkey = idpasskeypair.substr(slashIndex + 1);\n    }\n    if (passkey.length() != 32) {\n      STFATAL << \"Invalid/missing passkey: \" << passkey << \" \"\n              << passkey.length();\n    }\n    shared_ptr<Console> console;\n    if (!result.count(\"N\")) {\n      console.reset(new PsuedoTerminalConsole());\n    }\n\n    bool forwardAgent = result.count(\"f\") > 0;\n    string sshSocket = \"\";\n#ifndef WIN32\n    if (sshConfigOptions.identity_agent) {\n      sshSocket = string(sshConfigOptions.identity_agent);\n    }\n    forwardAgent |= sshConfigOptions.forward_agent;\n#endif\n    if (result.count(\"ssh-socket\")) {\n      sshSocket = result[\"ssh-socket\"].as<string>();\n    }\n    TelemetryService::get()->logToDatadog(\"Session Started\", el::Level::Info,\n                                          __FILE__, __LINE__);\n    string tunnel_arg =\n        result.count(\"tunnel\") ? result[\"tunnel\"].as<string>() : \"\";\n    string r_tunnel_arg = result.count(\"reversetunnel\")\n                              ? result[\"reversetunnel\"].as<string>()\n                              : \"\";\n    TerminalClient terminalClient(clientSocket, clientPipeSocket,\n                                  socketEndpoint, id, passkey, console,\n                                  is_jumphost, tunnel_arg, r_tunnel_arg,\n                                  forwardAgent, sshSocket, keepaliveDuration);\n    terminalClient.run(result.count(\"command\") ? result[\"command\"].as<string>()\n                                               : \"\");\n  } catch (TunnelParseException& tpe) {\n    handleParseException(tpe, options);\n  } catch (cxxopts::OptionException& oe) {\n    handleParseException(oe, options);\n  }\n\n#ifdef WIN32\n  WSACleanup();\n#endif\n\n  TelemetryService::get()->shutdown();\n  TelemetryService::destroy();\n\n  // Uninstall log rotation callback\n  el::Helpers::uninstallPreRollOutCallback();\n\n  return 0;\n}",
        "func": "int main(int argc, char** argv) {\n  WinsockContext context;\n  string tmpDir = GetTempDirectory();\n\n  // Setup easylogging configurations\n  el::Configurations defaultConf = LogHandler::setupLogHandler(&argc, &argv);\n  LogHandler::setupStdoutLogger();\n\n  et::HandleTerminate();\n\n  // Override easylogging handler for sigint\n  ::signal(SIGINT, et::InterruptSignalHandler);\n\n  // Parse command line arguments\n  cxxopts::Options options(\"et\", \"Remote shell for the busy and impatient\");\n  try {\n    options.allow_unrecognised_options();\n    options.positional_help(\"\");\n    options.custom_help(\n        \"[OPTION...] [user@]host[:port]\\n\\n\"\n        \"  Note that 'host' can be a hostname or ipv4 address with or without \"\n        \"a port\\n  or an ipv6 address. If the ipv6 address is abbreviated with \"\n        \":: then it must\\n  be specfied without a port (use -p,--port).\");\n\n    options.add_options()             //\n        (\"h,help\", \"Print help\")      //\n        (\"version\", \"Print version\")  //\n        (\"u,username\", \"Username\")    //\n        (\"host\", \"Remote host name\",\n         cxxopts::value<std::string>())  //\n        (\"p,port\", \"Remote machine etserver port\",\n         cxxopts::value<int>()->default_value(\"2022\"))  //\n        (\"c,command\", \"Run command on connect\",\n         cxxopts::value<std::string>())  //\n        (\"terminal-path\",\n         \"Path to etterminal on server side. \"\n         \"Use if etterminal is not on the system path.\",\n         cxxopts::value<std::string>())  //\n        (\"t,tunnel\",\n         \"Tunnel: Array of source:destination ports or \"\n         \"srcStart-srcEnd:dstStart-dstEnd (inclusive) port ranges (e.g. \"\n         \"10080:80,10443:443, 10090-10092:8000-8002)\",\n         cxxopts::value<std::string>())  //\n        (\"r,reversetunnel\",\n         \"Reverse Tunnel: Array of source:destination ports or \"\n         \"srcStart-srcEnd:dstStart-dstEnd (inclusive) port ranges\",\n         cxxopts::value<std::string>())  //\n        (\"jumphost\", \"jumphost between localhost and destination\",\n         cxxopts::value<std::string>())  //\n        (\"jport\", \"Jumphost machine port\",\n         cxxopts::value<int>()->default_value(\"2022\"))  //\n        (\"x,kill-other-sessions\",\n         \"kill all old sessions belonging to the user\")  //\n        (\"macserver\",\n         \"Set when connecting to an macOS server.  Sets \"\n         \"--terminal-path=/usr/local/bin/etterminal\")  //\n        (\"v,verbose\", \"Enable verbose logging\",\n         cxxopts::value<int>()->default_value(\"0\"))  //\n        (\"k,keepalive\", \"Client keepalive duration in seconds\",\n         cxxopts::value<int>())  //\n        (\"l,logdir\", \"Base directory for log files.\",\n         cxxopts::value<std::string>()->default_value(tmpDir))  //\n        (\"logtostdout\", \"Write log to stdout\")                  //\n        (\"silent\", \"Disable logging\")                           //\n        (\"N,no-terminal\", \"Do not create a terminal\")           //\n        (\"f,forward-ssh-agent\", \"Forward ssh-agent socket\")     //\n        (\"ssh-socket\", \"The ssh-agent socket to forward\",\n         cxxopts::value<std::string>())  //\n        (\"telemetry\",\n         \"Allow et to anonymously send errors to guide future improvements\",\n         cxxopts::value<bool>()->default_value(\"true\"))  //\n        (\"serverfifo\",\n         \"If set, communicate to etserver on the matching fifo name\",\n         cxxopts::value<std::string>()->default_value(\"\"))  //\n        (\"ssh-option\", \"Options to pass down to `ssh -o`\",\n         cxxopts::value<std::vector<std::string>>());\n\n    options.parse_positional({\"host\"});\n    auto result = options.parse(argc, argv);\n\n    if (result.count(\"help\")) {\n      CLOG(INFO, \"stdout\") << options.help({}) << endl;\n      exit(0);\n    }\n\n    if (result.count(\"version\")) {\n      CLOG(INFO, \"stdout\") << \"et version \" << ET_VERSION << endl;\n      exit(0);\n    }\n\n    el::Loggers::setVerboseLevel(result[\"verbose\"].as<int>());\n\n    // silent Flag, since etclient doesn't read /etc/et.cfg file\n    if (result.count(\"silent\")) {\n      defaultConf.setGlobally(el::ConfigurationType::Enabled, \"false\");\n    }\n\n    LogHandler::setupLogFiles(&defaultConf, result[\"logdir\"].as<string>(),\n                              \"etclient\", result.count(\"logtostdout\"),\n                              !result.count(\"logtostdout\"));\n\n    el::Loggers::reconfigureLogger(\"default\", defaultConf);\n    // set thread name\n    el::Helpers::setThreadName(\"client-main\");\n\n    // Install log rotation callback\n    el::Helpers::installPreRollOutCallback(LogHandler::rolloutHandler);\n\n    GOOGLE_PROTOBUF_VERIFY_VERSION;\n    srand(1);\n\n    TelemetryService::create(result[\"telemetry\"].as<bool>(),\n                             tmpDir + \"/.sentry-native-et\", \"Client\");\n\n    string username = \"\";\n    if (result.count(\"username\")) {\n      username = result[\"username\"].as<string>();\n    }\n    int destinationPort = result[\"port\"].as<int>();\n    string destinationHost;\n\n    // Parse command-line argument\n    if (!result.count(\"host\")) {\n      CLOG(INFO, \"stdout\") << \"Missing host to connect to\" << endl;\n      CLOG(INFO, \"stdout\") << options.help({}) << endl;\n      exit(0);\n    }\n    string host_arg = result[\"host\"].as<std::string>();\n    if (host_arg.find('@') != string::npos) {\n      int i = host_arg.find('@');\n      username = host_arg.substr(0, i);\n      host_arg = host_arg.substr(i + 1);\n    }\n\n    if (host_arg.find(':') != string::npos) {\n      int colon_count = std::count(host_arg.begin(), host_arg.end(), ':');\n      if (colon_count == 1) {\n        // ipv4 or hostname with port specified\n        int port_colon_pos = host_arg.rfind(':');\n        destinationPort = stoi(host_arg.substr(port_colon_pos + 1));\n        host_arg = host_arg.substr(0, port_colon_pos);\n      } else {\n        // maybe ipv6 (colon_count >= 2)\n        if (host_arg.find(\"::\") != string::npos) {\n          // ipv6 with double colon zero abbreviation and no port\n          // leave host_arg as is\n        } else {\n          if (colon_count == 7) {\n            // ipv6, fully expanded, without port\n          } else if (colon_count == 8) {\n            // ipv6, fully expanded, with port\n            int port_colon_pos = host_arg.rfind(':');\n            destinationPort = stoi(host_arg.substr(port_colon_pos + 1));\n            host_arg = host_arg.substr(0, port_colon_pos);\n          } else {\n            CLOG(INFO, \"stdout\") << \"Invalid host positional arg: \"\n                                 << result[\"host\"].as<std::string>() << endl;\n            exit(1);\n          }\n        }\n      }\n    }\n    destinationHost = host_arg;\n    // host_alias is used for the initiating ssh call, if sshd runs on a port\n    // other than 22, either configure your .ssh/config with an alias with an\n    // overridden port or pass --ssh-option Port=<sshd_port>\n    string host_alias = destinationHost;\n\n    string jumphost =\n        result.count(\"jumphost\") ? result[\"jumphost\"].as<string>() : \"\";\n    int keepaliveDuration = result.count(\"keepalive\")\n                                ? result[\"keepalive\"].as<int>()\n                                : MAX_CLIENT_KEEP_ALIVE_DURATION;\n    if (keepaliveDuration < 1 ||\n        keepaliveDuration > MAX_CLIENT_KEEP_ALIVE_DURATION) {\n      CLOG(INFO, \"stdout\") << \"Keep-alive duration must between 1 and \"\n                           << MAX_CLIENT_KEEP_ALIVE_DURATION << \" seconds\"\n                           << endl;\n      CLOG(INFO, \"stdout\") << options.help({}) << endl;\n      exit(0);\n    }\n\n    Options sshConfigOptions = {\n        NULL,  // username\n        NULL,  // host\n        NULL,  // sshdir\n        NULL,  // knownhosts\n        NULL,  // ProxyCommand\n        NULL,  // ProxyJump\n        0,     // timeout\n        0,     // port\n        0,     // StrictHostKeyChecking\n        0,     // ssh2\n        0,     // ssh1\n        NULL,  // gss_server_identity\n        NULL,  // gss_client_identity\n        0,     // gss_delegate_creds\n        0,     // forward_agent\n        NULL   // identity_agent\n    };\n\n    char* home_dir = ssh_get_user_home_dir();\n    const char* host_from_command = destinationHost.c_str();\n    ssh_options_set(&sshConfigOptions, SSH_OPTIONS_HOST,\n                    destinationHost.c_str());\n    // First parse user-specific ssh config, then system-wide config.\n    parse_ssh_config_file(host_from_command, &sshConfigOptions,\n                          string(home_dir) + USER_SSH_CONFIG_PATH);\n    parse_ssh_config_file(host_from_command, &sshConfigOptions,\n                          SYSTEM_SSH_CONFIG_PATH);\n    LOG(INFO) << \"Parsed ssh config file, connecting to \"\n              << sshConfigOptions.host;\n    destinationHost = string(sshConfigOptions.host);\n\n    // Parse username: cmdline > sshconfig > localuser\n    if (username.empty()) {\n      if (sshConfigOptions.username) {\n        username = string(sshConfigOptions.username);\n      } else {\n        username = string(ssh_get_local_username());\n      }\n    }\n\n    // Parse jumphost: cmd > sshconfig\n    if (sshConfigOptions.ProxyJump && jumphost.length() == 0) {\n      string proxyjump = string(sshConfigOptions.ProxyJump);\n      size_t colonIndex = proxyjump.find(\":\");\n      if (colonIndex != string::npos) {\n        string userhostpair = proxyjump.substr(0, colonIndex);\n        size_t atIndex = userhostpair.find(\"@\");\n        if (atIndex != string::npos) {\n          jumphost = userhostpair.substr(atIndex + 1);\n        }\n      } else {\n        jumphost = proxyjump;\n      }\n      LOG(INFO) << \"ProxyJump found for dst in ssh config: \" << proxyjump;\n    }\n\n    bool is_jumphost = false;\n    SocketEndpoint socketEndpoint;\n    if (!jumphost.empty()) {\n      is_jumphost = true;\n      LOG(INFO) << \"Setting port to jumphost port\";\n      socketEndpoint.set_name(jumphost);\n      socketEndpoint.set_port(result[\"jport\"].as<int>());\n    } else {\n      socketEndpoint.set_name(destinationHost);\n      socketEndpoint.set_port(destinationPort);\n    }\n    shared_ptr<SocketHandler> clientSocket(new TcpSocketHandler());\n    shared_ptr<SocketHandler> clientPipeSocket(new PipeSocketHandler());\n\n    if (!ping(socketEndpoint, clientSocket)) {\n      CLOG(INFO, \"stdout\") << \"Could not reach the ET server: \"\n                           << socketEndpoint.name() << \":\"\n                           << socketEndpoint.port() << endl;\n      exit(1);\n    }\n\n    int jport = result[\"jport\"].as<int>();\n    string serverFifo = \"\";\n    if (result[\"serverfifo\"].as<string>() != \"\") {\n      serverFifo = result[\"serverfifo\"].as<string>();\n    }\n    std::vector<string> ssh_options;\n    if (result.count(\"ssh-option\")) {\n      ssh_options = result[\"ssh-option\"].as<std::vector<string>>();\n    }\n    string etterminal_path = \"\";\n    if (result.count(\"macserver\") > 0) {\n      etterminal_path = \"/usr/local/bin/etterminal\";\n    }\n    if (result.count(\"etterminal_path\")) {\n      etterminal_path = result[\"terminal-path\"].as<string>();\n    }\n    string idpasskeypair = SshSetupHandler::SetupSsh(\n        username, destinationHost, host_alias, destinationPort, jumphost, jport,\n        result.count(\"x\") > 0, result[\"verbose\"].as<int>(), etterminal_path,\n        serverFifo, ssh_options);\n\n    string id = \"\", passkey = \"\";\n    // Trim whitespace\n    idpasskeypair.erase(idpasskeypair.find_last_not_of(\" \\n\\r\\t\") + 1);\n    size_t slashIndex = idpasskeypair.find(\"/\");\n    if (slashIndex == string::npos) {\n      STFATAL << \"Invalid idPasskey id/key pair: \" << idpasskeypair;\n    } else {\n      id = idpasskeypair.substr(0, slashIndex);\n      passkey = idpasskeypair.substr(slashIndex + 1);\n    }\n    if (passkey.length() != 32) {\n      STFATAL << \"Invalid/missing passkey: \" << passkey << \" \"\n              << passkey.length();\n    }\n    shared_ptr<Console> console;\n    if (!result.count(\"N\")) {\n      console.reset(new PsuedoTerminalConsole());\n    }\n\n    bool forwardAgent = result.count(\"f\") > 0;\n    string sshSocket = \"\";\n#ifndef WIN32\n    if (sshConfigOptions.identity_agent) {\n      sshSocket = string(sshConfigOptions.identity_agent);\n    }\n    forwardAgent |= sshConfigOptions.forward_agent;\n#endif\n    if (result.count(\"ssh-socket\")) {\n      sshSocket = result[\"ssh-socket\"].as<string>();\n    }\n    TelemetryService::get()->logToDatadog(\"Session Started\", el::Level::Info,\n                                          __FILE__, __LINE__);\n    string tunnel_arg =\n        result.count(\"tunnel\") ? result[\"tunnel\"].as<string>() : \"\";\n    string r_tunnel_arg = result.count(\"reversetunnel\")\n                              ? result[\"reversetunnel\"].as<string>()\n                              : \"\";\n    TerminalClient terminalClient(clientSocket, clientPipeSocket,\n                                  socketEndpoint, id, passkey, console,\n                                  is_jumphost, tunnel_arg, r_tunnel_arg,\n                                  forwardAgent, sshSocket, keepaliveDuration);\n    terminalClient.run(result.count(\"command\") ? result[\"command\"].as<string>()\n                                               : \"\");\n  } catch (TunnelParseException& tpe) {\n    handleParseException(tpe, options);\n  } catch (cxxopts::OptionException& oe) {\n    handleParseException(oe, options);\n  }\n\n#ifdef WIN32\n  WSACleanup();\n#endif\n\n  TelemetryService::get()->shutdown();\n  TelemetryService::destroy();\n\n  // Uninstall log rotation callback\n  el::Helpers::uninstallPreRollOutCallback();\n\n  return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -57,11 +57,13 @@\n         (\"v,verbose\", \"Enable verbose logging\",\n          cxxopts::value<int>()->default_value(\"0\"))  //\n         (\"k,keepalive\", \"Client keepalive duration in seconds\",\n-         cxxopts::value<int>())                              //\n-        (\"logtostdout\", \"Write log to stdout\")               //\n-        (\"silent\", \"Disable logging\")                        //\n-        (\"N,no-terminal\", \"Do not create a terminal\")        //\n-        (\"f,forward-ssh-agent\", \"Forward ssh-agent socket\")  //\n+         cxxopts::value<int>())  //\n+        (\"l,logdir\", \"Base directory for log files.\",\n+         cxxopts::value<std::string>()->default_value(tmpDir))  //\n+        (\"logtostdout\", \"Write log to stdout\")                  //\n+        (\"silent\", \"Disable logging\")                           //\n+        (\"N,no-terminal\", \"Do not create a terminal\")           //\n+        (\"f,forward-ssh-agent\", \"Forward ssh-agent socket\")     //\n         (\"ssh-socket\", \"The ssh-agent socket to forward\",\n          cxxopts::value<std::string>())  //\n         (\"telemetry\",\n@@ -93,8 +95,8 @@\n       defaultConf.setGlobally(el::ConfigurationType::Enabled, \"false\");\n     }\n \n-    LogHandler::setupLogFiles(&defaultConf, tmpDir, \"etclient\",\n-                              result.count(\"logtostdout\"),\n+    LogHandler::setupLogFiles(&defaultConf, result[\"logdir\"].as<string>(),\n+                              \"etclient\", result.count(\"logtostdout\"),\n                               !result.count(\"logtostdout\"));\n \n     el::Loggers::reconfigureLogger(\"default\", defaultConf);",
        "diff_line_info": {
            "deleted_lines": [
                "         cxxopts::value<int>())                              //",
                "        (\"logtostdout\", \"Write log to stdout\")               //",
                "        (\"silent\", \"Disable logging\")                        //",
                "        (\"N,no-terminal\", \"Do not create a terminal\")        //",
                "        (\"f,forward-ssh-agent\", \"Forward ssh-agent socket\")  //",
                "    LogHandler::setupLogFiles(&defaultConf, tmpDir, \"etclient\",",
                "                              result.count(\"logtostdout\"),"
            ],
            "added_lines": [
                "         cxxopts::value<int>())  //",
                "        (\"l,logdir\", \"Base directory for log files.\",",
                "         cxxopts::value<std::string>()->default_value(tmpDir))  //",
                "        (\"logtostdout\", \"Write log to stdout\")                  //",
                "        (\"silent\", \"Disable logging\")                           //",
                "        (\"N,no-terminal\", \"Do not create a terminal\")           //",
                "        (\"f,forward-ssh-agent\", \"Forward ssh-agent socket\")     //",
                "    LogHandler::setupLogFiles(&defaultConf, result[\"logdir\"].as<string>(),",
                "                              \"etclient\", result.count(\"logtostdout\"),"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-25010",
        "func_name": "stepmania/ArchHooks::MountInitialFilesystems",
        "description": "The component /rootfs in RageFile of Stepmania v5.1b2 and below allows attackers access to the entire file system.",
        "git_url": "https://github.com/stepmania/stepmania/commit/8490d181c2d301ccca0dc6ee52f25bbadb567a9a",
        "commit_title": "Remove access to the root FS from lua",
        "commit_text": " On linux / is mounted to /rootfs in RageFile, which allows access to the _whole_ filesystem from lua. This means themes and mod files can re-write user data and extract files via USB profiles.  /rootfs was only added for internal use by the alsa, oss and memory card drivers, so it can be easily replaced with direct fstream file access.",
        "func_before": "void ArchHooks::MountInitialFilesystems( const RString &sDirOfExecutable )\n{\n#if defined(UNIX)\n\t/* Mount the root filesystem, so we can read files in /proc, /etc, and so on.\n\t * This is /rootfs, not /root, to avoid confusion with root's home directory. */\n\tFILEMAN->Mount( \"dir\", \"/\", \"/rootfs\" );\n\n\t/* Mount /proc, so Alsa9Buf::GetSoundCardDebugInfo() and others can access it.\n\t * (Deprecated; use rootfs.) */\n\tFILEMAN->Mount( \"dir\", \"/proc\", \"/proc\" );\n#endif\n\n\tRString Root;\n\tstruct stat st;\n\tif( !stat(sDirOfExecutable + \"/Packages\", &st) && st.st_mode&S_IFDIR )\n\t\tRoot = sDirOfExecutable;\n\telse if( !stat(sDirOfExecutable + \"/Songs\", &st) && st.st_mode&S_IFDIR )\n\t\tRoot = sDirOfExecutable;\n\telse if( !stat(RageFileManagerUtil::sInitialWorkingDirectory + \"/Songs\", &st) && st.st_mode&S_IFDIR )\n\t\tRoot = RageFileManagerUtil::sInitialWorkingDirectory;\n\telse\n\t\tRageException::Throw( \"%s\", COULDNT_FIND_SONGS.GetValue().c_str() );\n\n\tFILEMAN->Mount( \"dir\", Root, \"/\" );\n}",
        "func": "void ArchHooks::MountInitialFilesystems( const RString &sDirOfExecutable )\n{\n\tRString Root;\n\tstruct stat st;\n\tif( !stat(sDirOfExecutable + \"/Packages\", &st) && st.st_mode&S_IFDIR )\n\t\tRoot = sDirOfExecutable;\n\telse if( !stat(sDirOfExecutable + \"/Songs\", &st) && st.st_mode&S_IFDIR )\n\t\tRoot = sDirOfExecutable;\n\telse if( !stat(RageFileManagerUtil::sInitialWorkingDirectory + \"/Songs\", &st) && st.st_mode&S_IFDIR )\n\t\tRoot = RageFileManagerUtil::sInitialWorkingDirectory;\n\telse\n\t\tRageException::Throw( \"%s\", COULDNT_FIND_SONGS.GetValue().c_str() );\n\n\tFILEMAN->Mount( \"dir\", Root, \"/\" );\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,15 +1,5 @@\n void ArchHooks::MountInitialFilesystems( const RString &sDirOfExecutable )\n {\n-#if defined(UNIX)\n-\t/* Mount the root filesystem, so we can read files in /proc, /etc, and so on.\n-\t * This is /rootfs, not /root, to avoid confusion with root's home directory. */\n-\tFILEMAN->Mount( \"dir\", \"/\", \"/rootfs\" );\n-\n-\t/* Mount /proc, so Alsa9Buf::GetSoundCardDebugInfo() and others can access it.\n-\t * (Deprecated; use rootfs.) */\n-\tFILEMAN->Mount( \"dir\", \"/proc\", \"/proc\" );\n-#endif\n-\n \tRString Root;\n \tstruct stat st;\n \tif( !stat(sDirOfExecutable + \"/Packages\", &st) && st.st_mode&S_IFDIR )",
        "diff_line_info": {
            "deleted_lines": [
                "#if defined(UNIX)",
                "\t/* Mount the root filesystem, so we can read files in /proc, /etc, and so on.",
                "\t * This is /rootfs, not /root, to avoid confusion with root's home directory. */",
                "\tFILEMAN->Mount( \"dir\", \"/\", \"/rootfs\" );",
                "",
                "\t/* Mount /proc, so Alsa9Buf::GetSoundCardDebugInfo() and others can access it.",
                "\t * (Deprecated; use rootfs.) */",
                "\tFILEMAN->Mount( \"dir\", \"/proc\", \"/proc\" );",
                "#endif",
                ""
            ],
            "added_lines": []
        }
    },
    {
        "cve_id": "CVE-2022-25010",
        "func_name": "stepmania/MemoryCardDriverThreaded_Linux::GetUSBStorageDevices",
        "description": "The component /rootfs in RageFile of Stepmania v5.1b2 and below allows attackers access to the entire file system.",
        "git_url": "https://github.com/stepmania/stepmania/commit/8490d181c2d301ccca0dc6ee52f25bbadb567a9a",
        "commit_title": "Remove access to the root FS from lua",
        "commit_text": " On linux / is mounted to /rootfs in RageFile, which allows access to the _whole_ filesystem from lua. This means themes and mod files can re-write user data and extract files via USB profiles.  /rootfs was only added for internal use by the alsa, oss and memory card drivers, so it can be easily replaced with direct fstream file access.",
        "func_before": "void MemoryCardDriverThreaded_Linux::GetUSBStorageDevices( vector<UsbStorageDevice>& vDevicesOut )\n{\n\tLOG->Trace( \"GetUSBStorageDevices\" );\n\t\n\tvDevicesOut.clear();\n\n\t{\n\t\tvector<RString> asDevices;\n\t\tRString sBlockDevicePath = \"/sys/block/\";\n\t\tGetFileList( sBlockDevicePath, asDevices );\n\n\t\tfor( unsigned i = 0; i < asDevices.size(); ++i )\n\t\t{\n\t\t\tconst RString &sDevice = asDevices[i];\n\t\t\tif( sDevice == \".\" || sDevice == \"..\" )\n\t\t\t\tcontinue;\n\n\t\t\tUsbStorageDevice usbd;\n\n\t\t\tRString sPath = sBlockDevicePath + sDevice + \"/\";\n\t\t\tusbd.sSysPath = sPath;\n\n\t\t\t/* Ignore non-removable devices. */\n\t\t\tRString sBuf;\n\t\t\tif( !ReadFile( sPath + \"removable\", sBuf ) )\n\t\t\t\tcontinue; // already warned\n\t\t\tif( atoi(sBuf) != 1 )\n\t\t\t\tcontinue;\n\n\t\t\t/*\n\t\t\t * The kernel isn't exposing all of /sys atomically, so we end up missing\n\t\t\t * the partition due to it not being shown yet.  It won't show up until the\n\t\t\t * kernel has scanned the partition table, which can take a variable amount\n\t\t\t * of time, sometimes over a second.  Watch for the \"queue\" sysfs directory,\n\t\t\t * which is created after this, to tell when partition directories are created.\n\t\t\t */\n\t\t\tRageTimer WaitUntil;\n\t\t\tWaitUntil += 5;\n\t\t\tRString sQueueFilePath = usbd.sSysPath + \"queue\";\n\t\t\twhile(1)\n\t\t\t{\n\t\t\t\tif( WaitUntil.Ago() >= 0 )\n\t\t\t\t{\n\t\t\t\t\tLOG->Warn( \"Timed out waiting for %s\", sQueueFilePath.c_str() );\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif( access(usbd.sSysPath, F_OK) == -1 )\n\t\t\t\t{\n\t\t\t\t\tLOG->Warn( \"Block directory %s went away while we were waiting for %s\",\n\t\t\t\t\t\t\tusbd.sSysPath.c_str(), sQueueFilePath.c_str() );\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif( access(sQueueFilePath, F_OK) != -1 )\n\t\t\t\t\tbreak;\n\n\t\t\t\tusleep(10000);\n\t\t\t}\n\n\t\t\t/* Wait for udev to finish handling device node creation */\n\t\t\tExecuteCommand( \"udevadm settle\" );\n\n\t\t\t/* If the first partition device exists, eg. /sys/block/uba/uba1, use it. */\n\t\t\tif( access(usbd.sSysPath + sDevice + \"1\", F_OK) != -1 )\n\t\t\t{\n\t\t\t\tLOG->Trace(\"OK\");\n\t\t\t\tusbd.sDevice = \"/dev/\" + sDevice + \"1\";\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tLOG->Trace(\"error %s\", strerror(errno));\n\t\t\t\tusbd.sDevice = \"/dev/\" + sDevice;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * sPath/device should be a symlink to the actual device.  For USB\n\t\t\t * devices, it looks like this:\n\t\t\t *\n\t\t\t * device -> ../../devices/pci0000:00/0000:00:02.1/usb2/2-1/2-1:1.0\n\t\t\t *\n\t\t\t * \"2-1\" is \"bus-port\".\n\t\t\t */\n\t\t\tchar szLink[256];\n\t\t\tint iRet = readlink( sPath + \"device\", szLink, sizeof(szLink) );\n\t\t\tif( iRet == -1 )\n\t\t\t{\n\t\t\t\tLOG->Warn( \"readlink(\\\"%s\\\"): %s\", (sPath + \"device\").c_str(), strerror(errno) );\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * The full path looks like\n\t\t\t\t *\n\t\t\t\t *   ../../devices/pci0000:00/0000:00:02.1/usb2/2-2/2-2.1/2-2.1:1.0\n\t\t\t\t *\n\t\t\t\t * In newer kernels, it looks like:\n\t\t\t\t *\n\t\t\t\t * ../../../3-2.1:1.0\n\t\t\t\t *\n\t\t\t\t * Each path element refers to a new hop in the chain.\n\t\t\t\t *  \"usb2\" = second USB host\n\t\t\t\t *  2-            second USB host,\n\t\t\t\t *   -2           port 1 on the host,\n\t\t\t\t *     .1         port 1 on an attached hub\n\t\t\t\t *       .2       ... port 2 on the next hub ...\n\t\t\t\t * \n\t\t\t\t * We want the bus number and the port of the last hop.  The level is\n\t\t\t\t * the number of hops.\n\t\t\t\t */\n\t\t\t\tszLink[iRet] = 0;\n\t\t\t\tvector<RString> asBits;\n\t\t\t\tsplit( szLink, \"/\", asBits );\n\n\t\t\t\tRString sHostPort = asBits[asBits.size()-1];\n\t\t\t\tif( !sHostPort.empty() )\n\t\t\t\t{\n\t\t\t\t\t/* Strip off the endpoint information after the colon. */\n\t\t\t\t\tsize_t pos = sHostPort.find(':');\n\t\t\t\t\tif( pos != string::npos )\n\t\t\t\t\t\tsHostPort.erase( pos );\n\t\t\t\t\t\n\t\t\t\t\t/* sHostPort is eg. 2-2.1. */\n\t\t\t\t\tsHostPort.Replace( \"-\", \".\" );\n\t\t\t\t\tasBits.clear();\n\t\t\t\t\tsplit( sHostPort, \".\", asBits );\n\t\t\t\t\tif( asBits.size() > 1 )\n\t\t\t\t\t{\n\t\t\t\t\t\tusbd.iBus = atoi( asBits[0] );\n\t\t\t\t\t\tusbd.iPort = atoi( asBits[asBits.size()-1] );\n\t\t\t\t\t\tusbd.iLevel = asBits.size() - 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif( ReadFile( sPath + \"device/../idVendor\", sBuf ) )\n\t\t\t\tsscanf( sBuf, \"%x\", &usbd.idVendor );\n\n\t\t\tif( ReadFile( sPath + \"device/../idProduct\", sBuf ) )\n\t\t\t\tsscanf( sBuf, \"%x\", &usbd.idProduct );\n\n\t\t\tif( ReadFile( sPath + \"device/../serial\", sBuf ) )\n\t\t\t{\n\t\t\t\tusbd.sSerial = sBuf;\n\t\t\t\tTrimRight( usbd.sSerial );\n\t\t\t}\n\t\t\tif( ReadFile( sPath + \"device/../product\", sBuf ) )\n\t\t\t{\n\t\t\t\tusbd.sProduct = sBuf;\n\t\t\t\tTrimRight( usbd.sProduct );\n\t\t\t}\n\t\t\tif( ReadFile( sPath + \"device/../manufacturer\", sBuf ) )\n\t\t\t{\n\t\t\t\tusbd.sVendor = sBuf;\n\t\t\t\tTrimRight( usbd.sVendor );\n\t\t\t}\n\n\t\t\tvDevicesOut.push_back( usbd );\n\t\t}\n\t}\n\n\t{\n\t\t// Find where each device is mounted. Output looks like:\n\t\t\n\t\t// /dev/sda1               /mnt/flash1             auto    noauto,owner 0 0\n\t\t// /dev/sdb1               /mnt/flash2             auto    noauto,owner 0 0\n\t\t// /dev/sdc1               /mnt/flash3             auto    noauto,owner 0 0\n\t\t\n\t\tRString fn = \"/rootfs/etc/fstab\";\n\t\tRageFile f;\n\t\tif( !f.Open(fn) )\n\t\t{\n\t\t\tLOG->Warn( \"can't open '%s': %s\", fn.c_str(), f.GetError().c_str() );\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tRString sLine;\n\t\twhile( !f.AtEOF() )\n\t\t{\n\t\t\tswitch( f.GetLine(sLine) )\n\t\t\t{\n\t\t\tcase 0: continue; /* eof */\n\t\t\tcase -1:\n\t\t\t\tLOG->Warn( \"error reading '%s': %s\", fn.c_str(), f.GetError().c_str() );\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tchar szScsiDevice[1024];\n\t\t\tchar szMountPoint[1024];\n\t\t\tint iRet = sscanf( sLine, \"%s %s\", szScsiDevice, szMountPoint );\n\t\t\tif( iRet != 2 || szScsiDevice[0] == '#')\n\t\t\t\tcontinue;\t// don't process this line\n\n\t\t\t/* Get the real kernel device name, which should match\n\t\t\t * the name from /sys/block, by following symlinks in\n\t\t\t * /dev.  This allows us to specify persistent names in\n\t\t\t * /etc/fstab using things like /dev/device/by-path. */\n\t\t\tchar szUnderlyingDevice[PATH_MAX];\n\t\t\tif( realpath(szScsiDevice, szUnderlyingDevice) == nullptr )\n\t\t\t{\n\t\t\t\t// \"No such file or directory\" is understandable\n\t\t\t\tif (errno != ENOENT)\n\t\t\t\t\tLOG->Warn( \"realpath(\\\"%s\\\"): %s\", szScsiDevice, strerror(errno) );\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tRString sMountPoint = szMountPoint;\n\t\t\tTrimLeft( sMountPoint );\n\t\t\tTrimRight( sMountPoint );\n\n\t\t\t// search for the mountpoint corresponding to the device\n\t\t\tfor( unsigned i=0; i<vDevicesOut.size(); i++ )\n\t\t\t{\n\t\t\t\tUsbStorageDevice& usbd = vDevicesOut[i];\n\t\t\t\tif( usbd.sDevice == szUnderlyingDevice )\t// found our match\n\t\t\t\t{\n\t\t\t\t\t// Use the device entry from fstab so the mount command works\n\t\t\t\t\tusbd.sDevice = szScsiDevice;\n\t\t\t\t\tusbd.sOsMountDir = sMountPoint;\n\t\t\t\t\tbreak;\t// stop looking for a match\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor( unsigned i=0; i<vDevicesOut.size(); i++ )\n\t{\n\t\tUsbStorageDevice& usbd = vDevicesOut[i];\n\t\tLOG->Trace( \"    sDevice: %s, iBus: %d, iLevel: %d, iPort: %d, id: %04X:%04X, Vendor: '%s', Product: '%s', sSerial: \\\"%s\\\", sOsMountDir: %s\",\n\t\t\t\tusbd.sDevice.c_str(), usbd.iBus, usbd.iLevel, usbd.iPort, usbd.idVendor, usbd.idProduct, usbd.sVendor.c_str(),\n\t\t\t\tusbd.sProduct.c_str(), usbd.sSerial.c_str(), usbd.sOsMountDir.c_str() );\n\t}\n\t\n\t/* Remove any devices that we couldn't find a mountpoint for. */\n\tfor( unsigned i=0; i<vDevicesOut.size(); i++ )\n\t{\n\t\tUsbStorageDevice& usbd = vDevicesOut[i];\n\t\tif( usbd.sOsMountDir.empty() )\n\t\t{\n\t\t\tLOG->Trace( \"Ignoring %s (couldn't find in /etc/fstab)\", usbd.sDevice.c_str() );\n\t\t\t\n\t\t\tvDevicesOut.erase( vDevicesOut.begin()+i );\n\t\t\t--i;\n\t\t}\n\t}\n\t\n\tLOG->Trace( \"Done with GetUSBStorageDevices\" );\n}",
        "func": "void MemoryCardDriverThreaded_Linux::GetUSBStorageDevices( vector<UsbStorageDevice>& vDevicesOut )\n{\n\tLOG->Trace( \"GetUSBStorageDevices\" );\n\t\n\tvDevicesOut.clear();\n\n\t{\n\t\tvector<RString> asDevices;\n\t\tRString sBlockDevicePath = \"/sys/block/\";\n\t\tGetFileList( sBlockDevicePath, asDevices );\n\n\t\tfor( unsigned i = 0; i < asDevices.size(); ++i )\n\t\t{\n\t\t\tconst RString &sDevice = asDevices[i];\n\t\t\tif( sDevice == \".\" || sDevice == \"..\" )\n\t\t\t\tcontinue;\n\n\t\t\tUsbStorageDevice usbd;\n\n\t\t\tRString sPath = sBlockDevicePath + sDevice + \"/\";\n\t\t\tusbd.sSysPath = sPath;\n\n\t\t\t/* Ignore non-removable devices. */\n\t\t\tRString sBuf;\n\t\t\tif( !ReadFile( sPath + \"removable\", sBuf ) )\n\t\t\t\tcontinue; // already warned\n\t\t\tif( atoi(sBuf) != 1 )\n\t\t\t\tcontinue;\n\n\t\t\t/*\n\t\t\t * The kernel isn't exposing all of /sys atomically, so we end up missing\n\t\t\t * the partition due to it not being shown yet.  It won't show up until the\n\t\t\t * kernel has scanned the partition table, which can take a variable amount\n\t\t\t * of time, sometimes over a second.  Watch for the \"queue\" sysfs directory,\n\t\t\t * which is created after this, to tell when partition directories are created.\n\t\t\t */\n\t\t\tRageTimer WaitUntil;\n\t\t\tWaitUntil += 5;\n\t\t\tRString sQueueFilePath = usbd.sSysPath + \"queue\";\n\t\t\twhile(1)\n\t\t\t{\n\t\t\t\tif( WaitUntil.Ago() >= 0 )\n\t\t\t\t{\n\t\t\t\t\tLOG->Warn( \"Timed out waiting for %s\", sQueueFilePath.c_str() );\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif( access(usbd.sSysPath, F_OK) == -1 )\n\t\t\t\t{\n\t\t\t\t\tLOG->Warn( \"Block directory %s went away while we were waiting for %s\",\n\t\t\t\t\t\t\tusbd.sSysPath.c_str(), sQueueFilePath.c_str() );\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif( access(sQueueFilePath, F_OK) != -1 )\n\t\t\t\t\tbreak;\n\n\t\t\t\tusleep(10000);\n\t\t\t}\n\n\t\t\t/* Wait for udev to finish handling device node creation */\n\t\t\tExecuteCommand( \"udevadm settle\" );\n\n\t\t\t/* If the first partition device exists, eg. /sys/block/uba/uba1, use it. */\n\t\t\tif( access(usbd.sSysPath + sDevice + \"1\", F_OK) != -1 )\n\t\t\t{\n\t\t\t\tLOG->Trace(\"OK\");\n\t\t\t\tusbd.sDevice = \"/dev/\" + sDevice + \"1\";\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tLOG->Trace(\"error %s\", strerror(errno));\n\t\t\t\tusbd.sDevice = \"/dev/\" + sDevice;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * sPath/device should be a symlink to the actual device.  For USB\n\t\t\t * devices, it looks like this:\n\t\t\t *\n\t\t\t * device -> ../../devices/pci0000:00/0000:00:02.1/usb2/2-1/2-1:1.0\n\t\t\t *\n\t\t\t * \"2-1\" is \"bus-port\".\n\t\t\t */\n\t\t\tchar szLink[256];\n\t\t\tint iRet = readlink( sPath + \"device\", szLink, sizeof(szLink) );\n\t\t\tif( iRet == -1 )\n\t\t\t{\n\t\t\t\tLOG->Warn( \"readlink(\\\"%s\\\"): %s\", (sPath + \"device\").c_str(), strerror(errno) );\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\t * The full path looks like\n\t\t\t\t *\n\t\t\t\t *   ../../devices/pci0000:00/0000:00:02.1/usb2/2-2/2-2.1/2-2.1:1.0\n\t\t\t\t *\n\t\t\t\t * In newer kernels, it looks like:\n\t\t\t\t *\n\t\t\t\t * ../../../3-2.1:1.0\n\t\t\t\t *\n\t\t\t\t * Each path element refers to a new hop in the chain.\n\t\t\t\t *  \"usb2\" = second USB host\n\t\t\t\t *  2-            second USB host,\n\t\t\t\t *   -2           port 1 on the host,\n\t\t\t\t *     .1         port 1 on an attached hub\n\t\t\t\t *       .2       ... port 2 on the next hub ...\n\t\t\t\t * \n\t\t\t\t * We want the bus number and the port of the last hop.  The level is\n\t\t\t\t * the number of hops.\n\t\t\t\t */\n\t\t\t\tszLink[iRet] = 0;\n\t\t\t\tvector<RString> asBits;\n\t\t\t\tsplit( szLink, \"/\", asBits );\n\n\t\t\t\tRString sHostPort = asBits[asBits.size()-1];\n\t\t\t\tif( !sHostPort.empty() )\n\t\t\t\t{\n\t\t\t\t\t/* Strip off the endpoint information after the colon. */\n\t\t\t\t\tsize_t pos = sHostPort.find(':');\n\t\t\t\t\tif( pos != string::npos )\n\t\t\t\t\t\tsHostPort.erase( pos );\n\t\t\t\t\t\n\t\t\t\t\t/* sHostPort is eg. 2-2.1. */\n\t\t\t\t\tsHostPort.Replace( \"-\", \".\" );\n\t\t\t\t\tasBits.clear();\n\t\t\t\t\tsplit( sHostPort, \".\", asBits );\n\t\t\t\t\tif( asBits.size() > 1 )\n\t\t\t\t\t{\n\t\t\t\t\t\tusbd.iBus = atoi( asBits[0] );\n\t\t\t\t\t\tusbd.iPort = atoi( asBits[asBits.size()-1] );\n\t\t\t\t\t\tusbd.iLevel = asBits.size() - 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif( ReadFile( sPath + \"device/../idVendor\", sBuf ) )\n\t\t\t\tsscanf( sBuf, \"%x\", &usbd.idVendor );\n\n\t\t\tif( ReadFile( sPath + \"device/../idProduct\", sBuf ) )\n\t\t\t\tsscanf( sBuf, \"%x\", &usbd.idProduct );\n\n\t\t\tif( ReadFile( sPath + \"device/../serial\", sBuf ) )\n\t\t\t{\n\t\t\t\tusbd.sSerial = sBuf;\n\t\t\t\tTrimRight( usbd.sSerial );\n\t\t\t}\n\t\t\tif( ReadFile( sPath + \"device/../product\", sBuf ) )\n\t\t\t{\n\t\t\t\tusbd.sProduct = sBuf;\n\t\t\t\tTrimRight( usbd.sProduct );\n\t\t\t}\n\t\t\tif( ReadFile( sPath + \"device/../manufacturer\", sBuf ) )\n\t\t\t{\n\t\t\t\tusbd.sVendor = sBuf;\n\t\t\t\tTrimRight( usbd.sVendor );\n\t\t\t}\n\n\t\t\tvDevicesOut.push_back( usbd );\n\t\t}\n\t}\n\n\t{\n\t\t// Find where each device is mounted. Output looks like:\n\t\t\n\t\t// /dev/sda1               /mnt/flash1             auto    noauto,owner 0 0\n\t\t// /dev/sdb1               /mnt/flash2             auto    noauto,owner 0 0\n\t\t// /dev/sdc1               /mnt/flash3             auto    noauto,owner 0 0\n\n\t\tstd::ifstream f(\"/etc/fstab\");\n\t\tif (f.fail())\n\t\t{\n\t\t\tLOG->Warn( \"can't open '/etc/fstab': %s\", strerror(errno) );\n\t\t\treturn;\n\t\t}\n\n\t\tstd::string line;\n\t\twhile( !f.eof() )\n\t\t{\n\t\t\tstd::getline(f, line);\n\t\t\tif (f.eof())\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse if (f.fail())\n\t\t\t{\n\t\t\t\tLOG->Warn( \"error reading '/etc/fstab': %s\", strerror(errno) );\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tchar szScsiDevice[1024];\n\t\t\tchar szMountPoint[1024];\n\t\t\tint iRet = sscanf( line.c_str(), \"%s %s\", szScsiDevice, szMountPoint );\n\t\t\tif( iRet != 2 || szScsiDevice[0] == '#')\n\t\t\t\tcontinue;\t// don't process this line\n\n\t\t\t/* Get the real kernel device name, which should match\n\t\t\t * the name from /sys/block, by following symlinks in\n\t\t\t * /dev.  This allows us to specify persistent names in\n\t\t\t * /etc/fstab using things like /dev/device/by-path. */\n\t\t\tchar szUnderlyingDevice[PATH_MAX];\n\t\t\tif( realpath(szScsiDevice, szUnderlyingDevice) == nullptr )\n\t\t\t{\n\t\t\t\t// \"No such file or directory\" is understandable\n\t\t\t\tif (errno != ENOENT)\n\t\t\t\t\tLOG->Warn( \"realpath(\\\"%s\\\"): %s\", szScsiDevice, strerror(errno) );\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tRString sMountPoint = szMountPoint;\n\t\t\tTrimLeft( sMountPoint );\n\t\t\tTrimRight( sMountPoint );\n\n\t\t\t// search for the mountpoint corresponding to the device\n\t\t\tfor( unsigned i=0; i<vDevicesOut.size(); i++ )\n\t\t\t{\n\t\t\t\tUsbStorageDevice& usbd = vDevicesOut[i];\n\t\t\t\tif( usbd.sDevice == szUnderlyingDevice )\t// found our match\n\t\t\t\t{\n\t\t\t\t\t// Use the device entry from fstab so the mount command works\n\t\t\t\t\tusbd.sDevice = szScsiDevice;\n\t\t\t\t\tusbd.sOsMountDir = sMountPoint;\n\t\t\t\t\tbreak;\t// stop looking for a match\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor( unsigned i=0; i<vDevicesOut.size(); i++ )\n\t{\n\t\tUsbStorageDevice& usbd = vDevicesOut[i];\n\t\tLOG->Trace( \"    sDevice: %s, iBus: %d, iLevel: %d, iPort: %d, id: %04X:%04X, Vendor: '%s', Product: '%s', sSerial: \\\"%s\\\", sOsMountDir: %s\",\n\t\t\t\tusbd.sDevice.c_str(), usbd.iBus, usbd.iLevel, usbd.iPort, usbd.idVendor, usbd.idProduct, usbd.sVendor.c_str(),\n\t\t\t\tusbd.sProduct.c_str(), usbd.sSerial.c_str(), usbd.sOsMountDir.c_str() );\n\t}\n\t\n\t/* Remove any devices that we couldn't find a mountpoint for. */\n\tfor( unsigned i=0; i<vDevicesOut.size(); i++ )\n\t{\n\t\tUsbStorageDevice& usbd = vDevicesOut[i];\n\t\tif( usbd.sOsMountDir.empty() )\n\t\t{\n\t\t\tLOG->Trace( \"Ignoring %s (couldn't find in /etc/fstab)\", usbd.sDevice.c_str() );\n\t\t\t\n\t\t\tvDevicesOut.erase( vDevicesOut.begin()+i );\n\t\t\t--i;\n\t\t}\n\t}\n\t\n\tLOG->Trace( \"Done with GetUSBStorageDevices\" );\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -165,29 +165,31 @@\n \t\t// /dev/sda1               /mnt/flash1             auto    noauto,owner 0 0\n \t\t// /dev/sdb1               /mnt/flash2             auto    noauto,owner 0 0\n \t\t// /dev/sdc1               /mnt/flash3             auto    noauto,owner 0 0\n-\t\t\n-\t\tRString fn = \"/rootfs/etc/fstab\";\n-\t\tRageFile f;\n-\t\tif( !f.Open(fn) )\n-\t\t{\n-\t\t\tLOG->Warn( \"can't open '%s': %s\", fn.c_str(), f.GetError().c_str() );\n+\n+\t\tstd::ifstream f(\"/etc/fstab\");\n+\t\tif (f.fail())\n+\t\t{\n+\t\t\tLOG->Warn( \"can't open '/etc/fstab': %s\", strerror(errno) );\n \t\t\treturn;\n \t\t}\n-\t\t\n-\t\tRString sLine;\n-\t\twhile( !f.AtEOF() )\n-\t\t{\n-\t\t\tswitch( f.GetLine(sLine) )\n-\t\t\t{\n-\t\t\tcase 0: continue; /* eof */\n-\t\t\tcase -1:\n-\t\t\t\tLOG->Warn( \"error reading '%s': %s\", fn.c_str(), f.GetError().c_str() );\n+\n+\t\tstd::string line;\n+\t\twhile( !f.eof() )\n+\t\t{\n+\t\t\tstd::getline(f, line);\n+\t\t\tif (f.eof())\n+\t\t\t{\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\telse if (f.fail())\n+\t\t\t{\n+\t\t\t\tLOG->Warn( \"error reading '/etc/fstab': %s\", strerror(errno) );\n \t\t\t\treturn;\n \t\t\t}\n \n \t\t\tchar szScsiDevice[1024];\n \t\t\tchar szMountPoint[1024];\n-\t\t\tint iRet = sscanf( sLine, \"%s %s\", szScsiDevice, szMountPoint );\n+\t\t\tint iRet = sscanf( line.c_str(), \"%s %s\", szScsiDevice, szMountPoint );\n \t\t\tif( iRet != 2 || szScsiDevice[0] == '#')\n \t\t\t\tcontinue;\t// don't process this line\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t",
                "\t\tRString fn = \"/rootfs/etc/fstab\";",
                "\t\tRageFile f;",
                "\t\tif( !f.Open(fn) )",
                "\t\t{",
                "\t\t\tLOG->Warn( \"can't open '%s': %s\", fn.c_str(), f.GetError().c_str() );",
                "\t\t",
                "\t\tRString sLine;",
                "\t\twhile( !f.AtEOF() )",
                "\t\t{",
                "\t\t\tswitch( f.GetLine(sLine) )",
                "\t\t\t{",
                "\t\t\tcase 0: continue; /* eof */",
                "\t\t\tcase -1:",
                "\t\t\t\tLOG->Warn( \"error reading '%s': %s\", fn.c_str(), f.GetError().c_str() );",
                "\t\t\tint iRet = sscanf( sLine, \"%s %s\", szScsiDevice, szMountPoint );"
            ],
            "added_lines": [
                "",
                "\t\tstd::ifstream f(\"/etc/fstab\");",
                "\t\tif (f.fail())",
                "\t\t{",
                "\t\t\tLOG->Warn( \"can't open '/etc/fstab': %s\", strerror(errno) );",
                "",
                "\t\tstd::string line;",
                "\t\twhile( !f.eof() )",
                "\t\t{",
                "\t\t\tstd::getline(f, line);",
                "\t\t\tif (f.eof())",
                "\t\t\t{",
                "\t\t\t\tcontinue;",
                "\t\t\t}",
                "\t\t\telse if (f.fail())",
                "\t\t\t{",
                "\t\t\t\tLOG->Warn( \"error reading '/etc/fstab': %s\", strerror(errno) );",
                "\t\t\tint iRet = sscanf( line.c_str(), \"%s %s\", szScsiDevice, szMountPoint );"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-25010",
        "func_name": "stepmania/LoadALSA",
        "description": "The component /rootfs in RageFile of Stepmania v5.1b2 and below allows attackers access to the entire file system.",
        "git_url": "https://github.com/stepmania/stepmania/commit/8490d181c2d301ccca0dc6ee52f25bbadb567a9a",
        "commit_title": "Remove access to the root FS from lua",
        "commit_text": " On linux / is mounted to /rootfs in RageFile, which allows access to the _whole_ filesystem from lua. This means themes and mod files can re-write user data and extract files via USB profiles.  /rootfs was only added for internal use by the alsa, oss and memory card drivers, so it can be easily replaced with direct fstream file access.",
        "func_before": "RString LoadALSA()\n{\n\t/* If /proc/asound/ doesn't exist, chances are we're on an OSS system.  We shouldn't\n\t * touch ALSA at all, since many OSS systems have old, broken versions of ALSA lying\n\t * around; we're likely to crash if we go near it.  Do this first, before loading\n\t * the ALSA library, since making any ALSA calls may load ALSA core modules.\n\t *\n\t * It's vaguely possible that a module autoloader would load the entire ALSA module set\n\t * on use, and this would prevent that from happening.  I don't know if anyone actually\n\t * does that, though: they're often configured to load snd (the core module) if ALSA\n\t * devices are accessed, but hardware drivers are typically loaded on boot. */\n\tif( !IsADirectory(\"/rootfs/proc/asound/\") )\n\t\treturn \"/proc/asound/ does not exist\";\n\n\tASSERT( Handle == nullptr );\n\n\tHandle = dlopen( lib, RTLD_NOW );\n\tif( Handle == nullptr )\n\t\treturn ssprintf(\"dlopen(%s): %s\", lib.c_str(), dlerror());\n\n\tRString error;\n\t/* Eww.  The \"new\" HW and SW API functions are really prefixed by __,\n\t * eg. __snd_pcm_hw_params_set_rate_near. */\n#define FUNC(ret, name, proto) \\\n\td##name = (name##_f) dlsym(Handle, \"__\" #name); \\\n\tif( !d##name ) { \\\n\t\td##name = (name##_f) dlsym(Handle, #name); \\\n\t\tif( !d##name ) { \\\n\t\t\terror=\"Couldn't load symbol \" #name; \\\n\t\t\tgoto error; \\\n\t\t} \\\n\t}\n#include \"ALSA9Functions.h\"\n#undef FUNC\n\n\treturn \"\";\nerror:\n\tUnloadALSA();\n\treturn error;\n}",
        "func": "RString LoadALSA()\n{\n\t/* If /proc/asound/ doesn't exist, chances are we're on an OSS system.  We shouldn't\n\t * touch ALSA at all, since many OSS systems have old, broken versions of ALSA lying\n\t * around; we're likely to crash if we go near it.  Do this first, before loading\n\t * the ALSA library, since making any ALSA calls may load ALSA core modules.\n\t *\n\t * It's vaguely possible that a module autoloader would load the entire ALSA module set\n\t * on use, and this would prevent that from happening.  I don't know if anyone actually\n\t * does that, though: they're often configured to load snd (the core module) if ALSA\n\t * devices are accessed, but hardware drivers are typically loaded on boot. */\n\tstruct stat st;\n\tif (stat(\"/proc/asound/\", &st) == -1 || !(st.st_mode & S_IFDIR))\n\t\treturn \"/proc/asound/ does not exist\";\n\n\tASSERT( Handle == nullptr );\n\n\tHandle = dlopen( lib, RTLD_NOW );\n\tif( Handle == nullptr )\n\t\treturn ssprintf(\"dlopen(%s): %s\", lib.c_str(), dlerror());\n\n\tRString error;\n\t/* Eww.  The \"new\" HW and SW API functions are really prefixed by __,\n\t * eg. __snd_pcm_hw_params_set_rate_near. */\n#define FUNC(ret, name, proto) \\\n\td##name = (name##_f) dlsym(Handle, \"__\" #name); \\\n\tif( !d##name ) { \\\n\t\td##name = (name##_f) dlsym(Handle, #name); \\\n\t\tif( !d##name ) { \\\n\t\t\terror=\"Couldn't load symbol \" #name; \\\n\t\t\tgoto error; \\\n\t\t} \\\n\t}\n#include \"ALSA9Functions.h\"\n#undef FUNC\n\n\treturn \"\";\nerror:\n\tUnloadALSA();\n\treturn error;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -9,7 +9,8 @@\n \t * on use, and this would prevent that from happening.  I don't know if anyone actually\n \t * does that, though: they're often configured to load snd (the core module) if ALSA\n \t * devices are accessed, but hardware drivers are typically loaded on boot. */\n-\tif( !IsADirectory(\"/rootfs/proc/asound/\") )\n+\tstruct stat st;\n+\tif (stat(\"/proc/asound/\", &st) == -1 || !(st.st_mode & S_IFDIR))\n \t\treturn \"/proc/asound/ does not exist\";\n \n \tASSERT( Handle == nullptr );",
        "diff_line_info": {
            "deleted_lines": [
                "\tif( !IsADirectory(\"/rootfs/proc/asound/\") )"
            ],
            "added_lines": [
                "\tstruct stat st;",
                "\tif (stat(\"/proc/asound/\", &st) == -1 || !(st.st_mode & S_IFDIR))"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-25010",
        "func_name": "stepmania/Alsa9Buf::GetSoundCardDebugInfo",
        "description": "The component /rootfs in RageFile of Stepmania v5.1b2 and below allows attackers access to the entire file system.",
        "git_url": "https://github.com/stepmania/stepmania/commit/8490d181c2d301ccca0dc6ee52f25bbadb567a9a",
        "commit_title": "Remove access to the root FS from lua",
        "commit_text": " On linux / is mounted to /rootfs in RageFile, which allows access to the _whole_ filesystem from lua. This means themes and mod files can re-write user data and extract files via USB profiles.  /rootfs was only added for internal use by the alsa, oss and memory card drivers, so it can be easily replaced with direct fstream file access.",
        "func_before": "void Alsa9Buf::GetSoundCardDebugInfo()\n{\n\tstatic bool done = false;\t\n\tif( done )\n\t\treturn;\n\tdone = true;\n\n\tif( DoesFileExist(\"/rootfs/proc/asound/version\") )\n\t{\n\t\tRString sVersion;\n\t\tGetFileContents( \"/rootfs/proc/asound/version\", sVersion, true );\n\t\tLOG->Info( \"ALSA: %s\", sVersion.c_str() );\n\t}\n\n\tInitializeErrorHandler();\n\n\tint card = -1;\n\twhile( dsnd_card_next( &card ) >= 0 && card >= 0 )\n\t{\n\t\tconst RString id = ssprintf( \"hw:%d\", card );\n\t\tsnd_ctl_t *handle;\n\t\tint err;\n\t\terr = dsnd_ctl_open( &handle, id, 0 );\n\t\tif ( err < 0 )\n\t\t{\n\t\t\tLOG->Info( \"Couldn't open card #%i (\\\"%s\\\") to probe: %s\", card, id.c_str(), dsnd_strerror(err) );\n\t\t\tcontinue;\n\t\t}\n\n\t\tsnd_ctl_card_info_t *info;\n\t\tdsnd_ctl_card_info_alloca(&info);\n\t\terr = dsnd_ctl_card_info( handle, info );\n\t\tif ( err < 0 )\n\t\t{\n\t\t\tLOG->Info( \"Couldn't get card info for card #%i (\\\"%s\\\"): %s\", card, id.c_str(), dsnd_strerror(err) );\n\t\t\tdsnd_ctl_close( handle );\n\t\t\tcontinue;\n\t\t}\n\n\t\tint dev = -1;\n\t\twhile ( dsnd_ctl_pcm_next_device( handle, &dev ) >= 0 && dev >= 0 )\n\t\t{\n\t\t\tsnd_pcm_info_t *pcminfo;\n\t\t\tdsnd_pcm_info_alloca(&pcminfo);\n\t\t\tdsnd_pcm_info_set_device(pcminfo, dev);\n\t\t\tdsnd_pcm_info_set_stream(pcminfo, SND_PCM_STREAM_PLAYBACK);\n\n\t\t\terr = dsnd_ctl_pcm_info(handle, pcminfo);\n\t\t\tif ( err < 0 )\n\t\t\t{\n\t\t\t\tif (err != -ENOENT)\n\t\t\t\t\tLOG->Info(\"dsnd_ctl_pcm_info(%i) (%s) failed: %s\", card, id.c_str(), dsnd_strerror(err));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tLOG->Info( \"ALSA Driver: %i: %s [%s], device %i: %s [%s], %i/%i subdevices avail\",\n\t\t\t\t\tcard, dsnd_ctl_card_info_get_name(info), dsnd_ctl_card_info_get_id(info), dev,\n\t\t\t\t\tdsnd_pcm_info_get_id(pcminfo), dsnd_pcm_info_get_name(pcminfo),\n\t\t\t\t\tdsnd_pcm_info_get_subdevices_avail(pcminfo),\n\t\t\t\t\tdsnd_pcm_info_get_subdevices_count(pcminfo) );\n\n\t\t}\n\t\tdsnd_ctl_close(handle);\n\t}\n\n\tif( card == 0 )\n\t\tLOG->Info( \"No ALSA sound cards were found.\");\n\t\n\tif( !PREFSMAN->m_iSoundDevice.Get().empty() )\n\t\tLOG->Info( \"ALSA device overridden to \\\"%s\\\"\", PREFSMAN->m_iSoundDevice.Get().c_str() );\n}",
        "func": "void Alsa9Buf::GetSoundCardDebugInfo()\n{\n\tstatic bool done = false;\t\n\tif( done )\n\t\treturn;\n\tdone = true;\n\n\tstd::ifstream f(\"/proc/asound/version\");\n\tif (f.good())\n\t{\n\t\tstd::string version;\n\t\tstd::getline(f, version);\n\t\tLOG->Info( \"ALSA: %s\", version.c_str() );\n\t}\n\n\tInitializeErrorHandler();\n\n\tint card = -1;\n\twhile( dsnd_card_next( &card ) >= 0 && card >= 0 )\n\t{\n\t\tconst RString id = ssprintf( \"hw:%d\", card );\n\t\tsnd_ctl_t *handle;\n\t\tint err;\n\t\terr = dsnd_ctl_open( &handle, id, 0 );\n\t\tif ( err < 0 )\n\t\t{\n\t\t\tLOG->Info( \"Couldn't open card #%i (\\\"%s\\\") to probe: %s\", card, id.c_str(), dsnd_strerror(err) );\n\t\t\tcontinue;\n\t\t}\n\n\t\tsnd_ctl_card_info_t *info;\n\t\tdsnd_ctl_card_info_alloca(&info);\n\t\terr = dsnd_ctl_card_info( handle, info );\n\t\tif ( err < 0 )\n\t\t{\n\t\t\tLOG->Info( \"Couldn't get card info for card #%i (\\\"%s\\\"): %s\", card, id.c_str(), dsnd_strerror(err) );\n\t\t\tdsnd_ctl_close( handle );\n\t\t\tcontinue;\n\t\t}\n\n\t\tint dev = -1;\n\t\twhile ( dsnd_ctl_pcm_next_device( handle, &dev ) >= 0 && dev >= 0 )\n\t\t{\n\t\t\tsnd_pcm_info_t *pcminfo;\n\t\t\tdsnd_pcm_info_alloca(&pcminfo);\n\t\t\tdsnd_pcm_info_set_device(pcminfo, dev);\n\t\t\tdsnd_pcm_info_set_stream(pcminfo, SND_PCM_STREAM_PLAYBACK);\n\n\t\t\terr = dsnd_ctl_pcm_info(handle, pcminfo);\n\t\t\tif ( err < 0 )\n\t\t\t{\n\t\t\t\tif (err != -ENOENT)\n\t\t\t\t\tLOG->Info(\"dsnd_ctl_pcm_info(%i) (%s) failed: %s\", card, id.c_str(), dsnd_strerror(err));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tLOG->Info( \"ALSA Driver: %i: %s [%s], device %i: %s [%s], %i/%i subdevices avail\",\n\t\t\t\t\tcard, dsnd_ctl_card_info_get_name(info), dsnd_ctl_card_info_get_id(info), dev,\n\t\t\t\t\tdsnd_pcm_info_get_id(pcminfo), dsnd_pcm_info_get_name(pcminfo),\n\t\t\t\t\tdsnd_pcm_info_get_subdevices_avail(pcminfo),\n\t\t\t\t\tdsnd_pcm_info_get_subdevices_count(pcminfo) );\n\n\t\t}\n\t\tdsnd_ctl_close(handle);\n\t}\n\n\tif( card == 0 )\n\t\tLOG->Info( \"No ALSA sound cards were found.\");\n\t\n\tif( !PREFSMAN->m_iSoundDevice.Get().empty() )\n\t\tLOG->Info( \"ALSA device overridden to \\\"%s\\\"\", PREFSMAN->m_iSoundDevice.Get().c_str() );\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -5,11 +5,12 @@\n \t\treturn;\n \tdone = true;\n \n-\tif( DoesFileExist(\"/rootfs/proc/asound/version\") )\n+\tstd::ifstream f(\"/proc/asound/version\");\n+\tif (f.good())\n \t{\n-\t\tRString sVersion;\n-\t\tGetFileContents( \"/rootfs/proc/asound/version\", sVersion, true );\n-\t\tLOG->Info( \"ALSA: %s\", sVersion.c_str() );\n+\t\tstd::string version;\n+\t\tstd::getline(f, version);\n+\t\tLOG->Info( \"ALSA: %s\", version.c_str() );\n \t}\n \n \tInitializeErrorHandler();",
        "diff_line_info": {
            "deleted_lines": [
                "\tif( DoesFileExist(\"/rootfs/proc/asound/version\") )",
                "\t\tRString sVersion;",
                "\t\tGetFileContents( \"/rootfs/proc/asound/version\", sVersion, true );",
                "\t\tLOG->Info( \"ALSA: %s\", sVersion.c_str() );"
            ],
            "added_lines": [
                "\tstd::ifstream f(\"/proc/asound/version\");",
                "\tif (f.good())",
                "\t\tstd::string version;",
                "\t\tstd::getline(f, version);",
                "\t\tLOG->Info( \"ALSA: %s\", version.c_str() );"
            ]
        }
    },
    {
        "cve_id": "CVE-2022-25010",
        "func_name": "stepmania/RageSoundDriver_OSS::CheckOSSVersion",
        "description": "The component /rootfs in RageFile of Stepmania v5.1b2 and below allows attackers access to the entire file system.",
        "git_url": "https://github.com/stepmania/stepmania/commit/8490d181c2d301ccca0dc6ee52f25bbadb567a9a",
        "commit_title": "Remove access to the root FS from lua",
        "commit_text": " On linux / is mounted to /rootfs in RageFile, which allows access to the _whole_ filesystem from lua. This means themes and mod files can re-write user data and extract files via USB profiles.  /rootfs was only added for internal use by the alsa, oss and memory card drivers, so it can be easily replaced with direct fstream file access.",
        "func_before": "RString RageSoundDriver_OSS::CheckOSSVersion( int fd )\n{\n\tint version = 0;\n\n#if defined(HAVE_OSS_GETVERSION)\n\tif( ioctl(fd, OSS_GETVERSION, &version) != 0 )\n\t{\n\t\tLOG->Warn( \"OSS_GETVERSION failed: %s\", strerror(errno) );\n\t\tversion = 0;\n\t}\n#endif\n\n\t/*\n\t * Find out if /dev/dsp is really ALSA emulating it.  ALSA's OSS emulation has\n\t * been buggy.  If we got here, we probably failed to init ALSA.  The only case\n\t * I've seen of this so far was not having access to /dev/snd devices.\n\t */\n\t/* Reliable but only too recently available:\n\tif (ioctl(fd, OSS_ALSAEMULVER, &ver) == 0 && ver ) */\n\n\t/*\n\t * Ack.  We can't just check for /proc/asound, since a few systems have ALSA\n\t * loaded but actually use OSS.  ALSA returns a specific version; check that,\n\t * too.  It looks like that version is potentially a valid OSS version, so\n\t * check both.\n\t */\n#ifndef FORCE_OSS\n#define ALSA_SNDRV_OSS_VERSION         ((3<<16)|(8<<8)|(1<<4)|(0))\n\tif( version == ALSA_SNDRV_OSS_VERSION && IsADirectory(\"/rootfs/proc/asound\") )\n\t\treturn \"RageSoundDriver_OSS: ALSA detected.  ALSA OSS emulation is buggy; use ALSA natively.\";\n#endif\n\tif( version )\n\t{\n\t\tint major, minor, rev;\n\t\tif( version < 361 )\n\t\t{\n\t\t\tmajor = (version/100)%10;\n\t\t\tminor = (version/10) %10;\n\t\t\trev =   (version/1)  %10;\n\t\t} else {\n\t\t\tmajor = (version/0x10000) % 0x100;\n\t\t\tminor = (version/0x00100) % 0x100;\n\t\t\trev =   (version/0x00001) % 0x100;\n\t\t}\n\n\t\tLOG->Info(\"OSS: %i.%i.%i\", major, minor, rev );\n\t}\n\n\treturn \"\";\n}",
        "func": "RString RageSoundDriver_OSS::CheckOSSVersion( int fd )\n{\n\tint version = 0;\n\n#if defined(HAVE_OSS_GETVERSION)\n\tif( ioctl(fd, OSS_GETVERSION, &version) != 0 )\n\t{\n\t\tLOG->Warn( \"OSS_GETVERSION failed: %s\", strerror(errno) );\n\t\tversion = 0;\n\t}\n#endif\n\n\t/*\n\t * Find out if /dev/dsp is really ALSA emulating it.  ALSA's OSS emulation has\n\t * been buggy.  If we got here, we probably failed to init ALSA.  The only case\n\t * I've seen of this so far was not having access to /dev/snd devices.\n\t */\n\t/* Reliable but only too recently available:\n\tif (ioctl(fd, OSS_ALSAEMULVER, &ver) == 0 && ver ) */\n\n\t/*\n\t * Ack.  We can't just check for /proc/asound, since a few systems have ALSA\n\t * loaded but actually use OSS.  ALSA returns a specific version; check that,\n\t * too.  It looks like that version is potentially a valid OSS version, so\n\t * check both.\n\t */\n#ifndef FORCE_OSS\n#define ALSA_SNDRV_OSS_VERSION         ((3<<16)|(8<<8)|(1<<4)|(0))\n\tstruct stat st;\n\tif( version == ALSA_SNDRV_OSS_VERSION && stat(\"/proc/asound\", &st) && (st.st_mode & S_IFDIR) )\n\t\treturn \"RageSoundDriver_OSS: ALSA detected.  ALSA OSS emulation is buggy; use ALSA natively.\";\n#endif\n\tif( version )\n\t{\n\t\tint major, minor, rev;\n\t\tif( version < 361 )\n\t\t{\n\t\t\tmajor = (version/100)%10;\n\t\t\tminor = (version/10) %10;\n\t\t\trev =   (version/1)  %10;\n\t\t} else {\n\t\t\tmajor = (version/0x10000) % 0x100;\n\t\t\tminor = (version/0x00100) % 0x100;\n\t\t\trev =   (version/0x00001) % 0x100;\n\t\t}\n\n\t\tLOG->Info(\"OSS: %i.%i.%i\", major, minor, rev );\n\t}\n\n\treturn \"\";\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -26,7 +26,8 @@\n \t */\n #ifndef FORCE_OSS\n #define ALSA_SNDRV_OSS_VERSION         ((3<<16)|(8<<8)|(1<<4)|(0))\n-\tif( version == ALSA_SNDRV_OSS_VERSION && IsADirectory(\"/rootfs/proc/asound\") )\n+\tstruct stat st;\n+\tif( version == ALSA_SNDRV_OSS_VERSION && stat(\"/proc/asound\", &st) && (st.st_mode & S_IFDIR) )\n \t\treturn \"RageSoundDriver_OSS: ALSA detected.  ALSA OSS emulation is buggy; use ALSA natively.\";\n #endif\n \tif( version )",
        "diff_line_info": {
            "deleted_lines": [
                "\tif( version == ALSA_SNDRV_OSS_VERSION && IsADirectory(\"/rootfs/proc/asound\") )"
            ],
            "added_lines": [
                "\tstruct stat st;",
                "\tif( version == ALSA_SNDRV_OSS_VERSION && stat(\"/proc/asound\", &st) && (st.st_mode & S_IFDIR) )"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-3631",
        "func_name": "libvirt/virSecuritySELinuxMCSFind",
        "description": "A flaw was found in libvirt while it generates SELinux MCS category pairs for VMs' dynamic labels. This flaw allows one exploited guest to access files labeled for another guest, resulting in the breaking out of sVirt confinement. The highest threat from this vulnerability is to confidentiality and integrity.",
        "git_url": "https://gitlab.com/libvirt/libvirt/-/commit/15073504dbb624d3f6c911e85557019d3620fdb2",
        "commit_title": "security: fix SELinux label generation logic",
        "commit_text": " A process can access a file if the set of MCS categories for the file is equal-to *or* a subset-of, the set of MCS categories for the process.  If there are two VMs:    a) svirt_t:s0:c117   b) svirt_t:s0:c117,c720  Then VM (b) is able to access files labelled for VM (a).  IOW, we must discard case where the categories are equal because that is a subset of many other valid category pairs.  CVE-2021-3631 ",
        "func_before": "static char *\nvirSecuritySELinuxMCSFind(virSecurityManager *mgr,\n                          const char *sens,\n                          int catMin,\n                          int catMax)\n{\n    virSecuritySELinuxData *data = virSecurityManagerGetPrivateData(mgr);\n    int catRange;\n    char *mcs = NULL;\n\n    /* +1 since virRandomInt range is exclusive of the upper bound */\n    catRange = (catMax - catMin) + 1;\n\n    if (catRange < 8) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Category range c%d-c%d too small\"),\n                       catMin, catMax);\n        return NULL;\n    }\n\n    VIR_DEBUG(\"Using sensitivity level '%s' cat min %d max %d range %d\",\n              sens, catMin, catMax, catRange);\n\n    for (;;) {\n        int c1 = virRandomInt(catRange);\n        int c2 = virRandomInt(catRange);\n\n        VIR_DEBUG(\"Try cat %s:c%d,c%d\", sens, c1 + catMin, c2 + catMin);\n\n        if (c1 == c2) {\n            mcs = g_strdup_printf(\"%s:c%d\", sens, catMin + c1);\n        } else {\n            if (c1 > c2) {\n                int t = c1;\n                c1 = c2;\n                c2 = t;\n            }\n            mcs = g_strdup_printf(\"%s:c%d,c%d\", sens, catMin + c1, catMin + c2);\n        }\n\n        if (virHashLookup(data->mcs, mcs) == NULL)\n            break;\n\n        VIR_FREE(mcs);\n    }\n\n    return mcs;\n}",
        "func": "static char *\nvirSecuritySELinuxMCSFind(virSecurityManager *mgr,\n                          const char *sens,\n                          int catMin,\n                          int catMax)\n{\n    virSecuritySELinuxData *data = virSecurityManagerGetPrivateData(mgr);\n    int catRange;\n    char *mcs = NULL;\n\n    /* +1 since virRandomInt range is exclusive of the upper bound */\n    catRange = (catMax - catMin) + 1;\n\n    if (catRange < 8) {\n        virReportError(VIR_ERR_INTERNAL_ERROR,\n                       _(\"Category range c%d-c%d too small\"),\n                       catMin, catMax);\n        return NULL;\n    }\n\n    VIR_DEBUG(\"Using sensitivity level '%s' cat min %d max %d range %d\",\n              sens, catMin, catMax, catRange);\n\n    for (;;) {\n        int c1 = virRandomInt(catRange);\n        int c2 = virRandomInt(catRange);\n\n        VIR_DEBUG(\"Try cat %s:c%d,c%d\", sens, c1 + catMin, c2 + catMin);\n\n        if (c1 == c2) {\n            /*\n             * A process can access a file if the set of MCS categories\n             * for the file is equal-to *or* a subset-of, the set of\n             * MCS categories for the process.\n             *\n             * IOW, we must discard case where the categories are equal\n             * because that is a subset of other category pairs.\n             */\n            continue;\n        } else {\n            if (c1 > c2) {\n                int t = c1;\n                c1 = c2;\n                c2 = t;\n            }\n            mcs = g_strdup_printf(\"%s:c%d,c%d\", sens, catMin + c1, catMin + c2);\n        }\n\n        if (virHashLookup(data->mcs, mcs) == NULL)\n            break;\n\n        VIR_FREE(mcs);\n    }\n\n    return mcs;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -28,7 +28,15 @@\n         VIR_DEBUG(\"Try cat %s:c%d,c%d\", sens, c1 + catMin, c2 + catMin);\n \n         if (c1 == c2) {\n-            mcs = g_strdup_printf(\"%s:c%d\", sens, catMin + c1);\n+            /*\n+             * A process can access a file if the set of MCS categories\n+             * for the file is equal-to *or* a subset-of, the set of\n+             * MCS categories for the process.\n+             *\n+             * IOW, we must discard case where the categories are equal\n+             * because that is a subset of other category pairs.\n+             */\n+            continue;\n         } else {\n             if (c1 > c2) {\n                 int t = c1;",
        "diff_line_info": {
            "deleted_lines": [
                "            mcs = g_strdup_printf(\"%s:c%d\", sens, catMin + c1);"
            ],
            "added_lines": [
                "            /*",
                "             * A process can access a file if the set of MCS categories",
                "             * for the file is equal-to *or* a subset-of, the set of",
                "             * MCS categories for the process.",
                "             *",
                "             * IOW, we must discard case where the categories are equal",
                "             * because that is a subset of other category pairs.",
                "             */",
                "            continue;"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-7889",
        "func_name": "torvalds/linux/read_mem",
        "description": "The mm subsystem in the Linux kernel through 3.2 does not properly enforce the CONFIG_STRICT_DEVMEM protection mechanism, which allows local users to read or write to kernel memory locations in the first megabyte (and bypass slab-allocation access restrictions) via an application that opens the /dev/mem file, related to arch/x86/mm/init.c and drivers/char/mem.c.",
        "git_url": "https://github.com/torvalds/linux/commit/a4866aa812518ed1a37d8ea0c881dc946409de94",
        "commit_title": "mm: Tighten x86 /dev/mem with zeroing reads",
        "commit_text": " Under CONFIG_STRICT_DEVMEM, reading System RAM through /dev/mem is disallowed. However, on x86, the first 1MB was always allowed for BIOS and similar things, regardless of it actually being System RAM. It was possible for heap to end up getting allocated in low 1MB RAM, and then read by things like x86info or dd, which would trip hardened usercopy:  usercopy: kernel memory exposure attempt detected from ffff880000090000 (dma-kmalloc-256) (4096 bytes)  This changes the x86 exception for the low 1MB by reading back zeros for System RAM areas instead of blindly allowing them. More work is needed to extend this to mmap, but currently mmap doesn't go through usercopy, so hardened usercopy won't Oops the kernel. ",
        "func_before": "static ssize_t read_mem(struct file *file, char __user *buf,\n\t\t\tsize_t count, loff_t *ppos)\n{\n\tphys_addr_t p = *ppos;\n\tssize_t read, sz;\n\tvoid *ptr;\n\n\tif (p != *ppos)\n\t\treturn 0;\n\n\tif (!valid_phys_addr_range(p, count))\n\t\treturn -EFAULT;\n\tread = 0;\n#ifdef __ARCH_HAS_NO_PAGE_ZERO_MAPPED\n\t/* we don't have page 0 mapped on sparc and m68k.. */\n\tif (p < PAGE_SIZE) {\n\t\tsz = size_inside_page(p, count);\n\t\tif (sz > 0) {\n\t\t\tif (clear_user(buf, sz))\n\t\t\t\treturn -EFAULT;\n\t\t\tbuf += sz;\n\t\t\tp += sz;\n\t\t\tcount -= sz;\n\t\t\tread += sz;\n\t\t}\n\t}\n#endif\n\n\twhile (count > 0) {\n\t\tunsigned long remaining;\n\n\t\tsz = size_inside_page(p, count);\n\n\t\tif (!range_is_allowed(p >> PAGE_SHIFT, count))\n\t\t\treturn -EPERM;\n\n\t\t/*\n\t\t * On ia64 if a page has been mapped somewhere as uncached, then\n\t\t * it must also be accessed uncached by the kernel or data\n\t\t * corruption may occur.\n\t\t */\n\t\tptr = xlate_dev_mem_ptr(p);\n\t\tif (!ptr)\n\t\t\treturn -EFAULT;\n\n\t\tremaining = copy_to_user(buf, ptr, sz);\n\t\tunxlate_dev_mem_ptr(p, ptr);\n\t\tif (remaining)\n\t\t\treturn -EFAULT;\n\n\t\tbuf += sz;\n\t\tp += sz;\n\t\tcount -= sz;\n\t\tread += sz;\n\t}\n\n\t*ppos += read;\n\treturn read;\n}",
        "func": "static ssize_t read_mem(struct file *file, char __user *buf,\n\t\t\tsize_t count, loff_t *ppos)\n{\n\tphys_addr_t p = *ppos;\n\tssize_t read, sz;\n\tvoid *ptr;\n\n\tif (p != *ppos)\n\t\treturn 0;\n\n\tif (!valid_phys_addr_range(p, count))\n\t\treturn -EFAULT;\n\tread = 0;\n#ifdef __ARCH_HAS_NO_PAGE_ZERO_MAPPED\n\t/* we don't have page 0 mapped on sparc and m68k.. */\n\tif (p < PAGE_SIZE) {\n\t\tsz = size_inside_page(p, count);\n\t\tif (sz > 0) {\n\t\t\tif (clear_user(buf, sz))\n\t\t\t\treturn -EFAULT;\n\t\t\tbuf += sz;\n\t\t\tp += sz;\n\t\t\tcount -= sz;\n\t\t\tread += sz;\n\t\t}\n\t}\n#endif\n\n\twhile (count > 0) {\n\t\tunsigned long remaining;\n\t\tint allowed;\n\n\t\tsz = size_inside_page(p, count);\n\n\t\tallowed = page_is_allowed(p >> PAGE_SHIFT);\n\t\tif (!allowed)\n\t\t\treturn -EPERM;\n\t\tif (allowed == 2) {\n\t\t\t/* Show zeros for restricted memory. */\n\t\t\tremaining = clear_user(buf, sz);\n\t\t} else {\n\t\t\t/*\n\t\t\t * On ia64 if a page has been mapped somewhere as\n\t\t\t * uncached, then it must also be accessed uncached\n\t\t\t * by the kernel or data corruption may occur.\n\t\t\t */\n\t\t\tptr = xlate_dev_mem_ptr(p);\n\t\t\tif (!ptr)\n\t\t\t\treturn -EFAULT;\n\n\t\t\tremaining = copy_to_user(buf, ptr, sz);\n\n\t\t\tunxlate_dev_mem_ptr(p, ptr);\n\t\t}\n\n\t\tif (remaining)\n\t\t\treturn -EFAULT;\n\n\t\tbuf += sz;\n\t\tp += sz;\n\t\tcount -= sz;\n\t\tread += sz;\n\t}\n\n\t*ppos += read;\n\treturn read;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -28,23 +28,31 @@\n \n \twhile (count > 0) {\n \t\tunsigned long remaining;\n+\t\tint allowed;\n \n \t\tsz = size_inside_page(p, count);\n \n-\t\tif (!range_is_allowed(p >> PAGE_SHIFT, count))\n+\t\tallowed = page_is_allowed(p >> PAGE_SHIFT);\n+\t\tif (!allowed)\n \t\t\treturn -EPERM;\n+\t\tif (allowed == 2) {\n+\t\t\t/* Show zeros for restricted memory. */\n+\t\t\tremaining = clear_user(buf, sz);\n+\t\t} else {\n+\t\t\t/*\n+\t\t\t * On ia64 if a page has been mapped somewhere as\n+\t\t\t * uncached, then it must also be accessed uncached\n+\t\t\t * by the kernel or data corruption may occur.\n+\t\t\t */\n+\t\t\tptr = xlate_dev_mem_ptr(p);\n+\t\t\tif (!ptr)\n+\t\t\t\treturn -EFAULT;\n \n-\t\t/*\n-\t\t * On ia64 if a page has been mapped somewhere as uncached, then\n-\t\t * it must also be accessed uncached by the kernel or data\n-\t\t * corruption may occur.\n-\t\t */\n-\t\tptr = xlate_dev_mem_ptr(p);\n-\t\tif (!ptr)\n-\t\t\treturn -EFAULT;\n+\t\t\tremaining = copy_to_user(buf, ptr, sz);\n \n-\t\tremaining = copy_to_user(buf, ptr, sz);\n-\t\tunxlate_dev_mem_ptr(p, ptr);\n+\t\t\tunxlate_dev_mem_ptr(p, ptr);\n+\t\t}\n+\n \t\tif (remaining)\n \t\t\treturn -EFAULT;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tif (!range_is_allowed(p >> PAGE_SHIFT, count))",
                "\t\t/*",
                "\t\t * On ia64 if a page has been mapped somewhere as uncached, then",
                "\t\t * it must also be accessed uncached by the kernel or data",
                "\t\t * corruption may occur.",
                "\t\t */",
                "\t\tptr = xlate_dev_mem_ptr(p);",
                "\t\tif (!ptr)",
                "\t\t\treturn -EFAULT;",
                "\t\tremaining = copy_to_user(buf, ptr, sz);",
                "\t\tunxlate_dev_mem_ptr(p, ptr);"
            ],
            "added_lines": [
                "\t\tint allowed;",
                "\t\tallowed = page_is_allowed(p >> PAGE_SHIFT);",
                "\t\tif (!allowed)",
                "\t\tif (allowed == 2) {",
                "\t\t\t/* Show zeros for restricted memory. */",
                "\t\t\tremaining = clear_user(buf, sz);",
                "\t\t} else {",
                "\t\t\t/*",
                "\t\t\t * On ia64 if a page has been mapped somewhere as",
                "\t\t\t * uncached, then it must also be accessed uncached",
                "\t\t\t * by the kernel or data corruption may occur.",
                "\t\t\t */",
                "\t\t\tptr = xlate_dev_mem_ptr(p);",
                "\t\t\tif (!ptr)",
                "\t\t\t\treturn -EFAULT;",
                "\t\t\tremaining = copy_to_user(buf, ptr, sz);",
                "\t\t\tunxlate_dev_mem_ptr(p, ptr);",
                "\t\t}",
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2017-7889",
        "func_name": "torvalds/linux/write_mem",
        "description": "The mm subsystem in the Linux kernel through 3.2 does not properly enforce the CONFIG_STRICT_DEVMEM protection mechanism, which allows local users to read or write to kernel memory locations in the first megabyte (and bypass slab-allocation access restrictions) via an application that opens the /dev/mem file, related to arch/x86/mm/init.c and drivers/char/mem.c.",
        "git_url": "https://github.com/torvalds/linux/commit/a4866aa812518ed1a37d8ea0c881dc946409de94",
        "commit_title": "mm: Tighten x86 /dev/mem with zeroing reads",
        "commit_text": " Under CONFIG_STRICT_DEVMEM, reading System RAM through /dev/mem is disallowed. However, on x86, the first 1MB was always allowed for BIOS and similar things, regardless of it actually being System RAM. It was possible for heap to end up getting allocated in low 1MB RAM, and then read by things like x86info or dd, which would trip hardened usercopy:  usercopy: kernel memory exposure attempt detected from ffff880000090000 (dma-kmalloc-256) (4096 bytes)  This changes the x86 exception for the low 1MB by reading back zeros for System RAM areas instead of blindly allowing them. More work is needed to extend this to mmap, but currently mmap doesn't go through usercopy, so hardened usercopy won't Oops the kernel. ",
        "func_before": "static ssize_t write_mem(struct file *file, const char __user *buf,\n\t\t\t size_t count, loff_t *ppos)\n{\n\tphys_addr_t p = *ppos;\n\tssize_t written, sz;\n\tunsigned long copied;\n\tvoid *ptr;\n\n\tif (p != *ppos)\n\t\treturn -EFBIG;\n\n\tif (!valid_phys_addr_range(p, count))\n\t\treturn -EFAULT;\n\n\twritten = 0;\n\n#ifdef __ARCH_HAS_NO_PAGE_ZERO_MAPPED\n\t/* we don't have page 0 mapped on sparc and m68k.. */\n\tif (p < PAGE_SIZE) {\n\t\tsz = size_inside_page(p, count);\n\t\t/* Hmm. Do something? */\n\t\tbuf += sz;\n\t\tp += sz;\n\t\tcount -= sz;\n\t\twritten += sz;\n\t}\n#endif\n\n\twhile (count > 0) {\n\t\tsz = size_inside_page(p, count);\n\n\t\tif (!range_is_allowed(p >> PAGE_SHIFT, sz))\n\t\t\treturn -EPERM;\n\n\t\t/*\n\t\t * On ia64 if a page has been mapped somewhere as uncached, then\n\t\t * it must also be accessed uncached by the kernel or data\n\t\t * corruption may occur.\n\t\t */\n\t\tptr = xlate_dev_mem_ptr(p);\n\t\tif (!ptr) {\n\t\t\tif (written)\n\t\t\t\tbreak;\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tcopied = copy_from_user(ptr, buf, sz);\n\t\tunxlate_dev_mem_ptr(p, ptr);\n\t\tif (copied) {\n\t\t\twritten += sz - copied;\n\t\t\tif (written)\n\t\t\t\tbreak;\n\t\t\treturn -EFAULT;\n\t\t}\n\n\t\tbuf += sz;\n\t\tp += sz;\n\t\tcount -= sz;\n\t\twritten += sz;\n\t}\n\n\t*ppos += written;\n\treturn written;\n}",
        "func": "static ssize_t write_mem(struct file *file, const char __user *buf,\n\t\t\t size_t count, loff_t *ppos)\n{\n\tphys_addr_t p = *ppos;\n\tssize_t written, sz;\n\tunsigned long copied;\n\tvoid *ptr;\n\n\tif (p != *ppos)\n\t\treturn -EFBIG;\n\n\tif (!valid_phys_addr_range(p, count))\n\t\treturn -EFAULT;\n\n\twritten = 0;\n\n#ifdef __ARCH_HAS_NO_PAGE_ZERO_MAPPED\n\t/* we don't have page 0 mapped on sparc and m68k.. */\n\tif (p < PAGE_SIZE) {\n\t\tsz = size_inside_page(p, count);\n\t\t/* Hmm. Do something? */\n\t\tbuf += sz;\n\t\tp += sz;\n\t\tcount -= sz;\n\t\twritten += sz;\n\t}\n#endif\n\n\twhile (count > 0) {\n\t\tint allowed;\n\n\t\tsz = size_inside_page(p, count);\n\n\t\tallowed = page_is_allowed(p >> PAGE_SHIFT);\n\t\tif (!allowed)\n\t\t\treturn -EPERM;\n\n\t\t/* Skip actual writing when a page is marked as restricted. */\n\t\tif (allowed == 1) {\n\t\t\t/*\n\t\t\t * On ia64 if a page has been mapped somewhere as\n\t\t\t * uncached, then it must also be accessed uncached\n\t\t\t * by the kernel or data corruption may occur.\n\t\t\t */\n\t\t\tptr = xlate_dev_mem_ptr(p);\n\t\t\tif (!ptr) {\n\t\t\t\tif (written)\n\t\t\t\t\tbreak;\n\t\t\t\treturn -EFAULT;\n\t\t\t}\n\n\t\t\tcopied = copy_from_user(ptr, buf, sz);\n\t\t\tunxlate_dev_mem_ptr(p, ptr);\n\t\t\tif (copied) {\n\t\t\t\twritten += sz - copied;\n\t\t\t\tif (written)\n\t\t\t\t\tbreak;\n\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t}\n\n\t\tbuf += sz;\n\t\tp += sz;\n\t\tcount -= sz;\n\t\twritten += sz;\n\t}\n\n\t*ppos += written;\n\treturn written;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -27,30 +27,36 @@\n #endif\n \n \twhile (count > 0) {\n+\t\tint allowed;\n+\n \t\tsz = size_inside_page(p, count);\n \n-\t\tif (!range_is_allowed(p >> PAGE_SHIFT, sz))\n+\t\tallowed = page_is_allowed(p >> PAGE_SHIFT);\n+\t\tif (!allowed)\n \t\t\treturn -EPERM;\n \n-\t\t/*\n-\t\t * On ia64 if a page has been mapped somewhere as uncached, then\n-\t\t * it must also be accessed uncached by the kernel or data\n-\t\t * corruption may occur.\n-\t\t */\n-\t\tptr = xlate_dev_mem_ptr(p);\n-\t\tif (!ptr) {\n-\t\t\tif (written)\n-\t\t\t\tbreak;\n-\t\t\treturn -EFAULT;\n-\t\t}\n+\t\t/* Skip actual writing when a page is marked as restricted. */\n+\t\tif (allowed == 1) {\n+\t\t\t/*\n+\t\t\t * On ia64 if a page has been mapped somewhere as\n+\t\t\t * uncached, then it must also be accessed uncached\n+\t\t\t * by the kernel or data corruption may occur.\n+\t\t\t */\n+\t\t\tptr = xlate_dev_mem_ptr(p);\n+\t\t\tif (!ptr) {\n+\t\t\t\tif (written)\n+\t\t\t\t\tbreak;\n+\t\t\t\treturn -EFAULT;\n+\t\t\t}\n \n-\t\tcopied = copy_from_user(ptr, buf, sz);\n-\t\tunxlate_dev_mem_ptr(p, ptr);\n-\t\tif (copied) {\n-\t\t\twritten += sz - copied;\n-\t\t\tif (written)\n-\t\t\t\tbreak;\n-\t\t\treturn -EFAULT;\n+\t\t\tcopied = copy_from_user(ptr, buf, sz);\n+\t\t\tunxlate_dev_mem_ptr(p, ptr);\n+\t\t\tif (copied) {\n+\t\t\t\twritten += sz - copied;\n+\t\t\t\tif (written)\n+\t\t\t\t\tbreak;\n+\t\t\t\treturn -EFAULT;\n+\t\t\t}\n \t\t}\n \n \t\tbuf += sz;",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tif (!range_is_allowed(p >> PAGE_SHIFT, sz))",
                "\t\t/*",
                "\t\t * On ia64 if a page has been mapped somewhere as uncached, then",
                "\t\t * it must also be accessed uncached by the kernel or data",
                "\t\t * corruption may occur.",
                "\t\t */",
                "\t\tptr = xlate_dev_mem_ptr(p);",
                "\t\tif (!ptr) {",
                "\t\t\tif (written)",
                "\t\t\t\tbreak;",
                "\t\t\treturn -EFAULT;",
                "\t\t}",
                "\t\tcopied = copy_from_user(ptr, buf, sz);",
                "\t\tunxlate_dev_mem_ptr(p, ptr);",
                "\t\tif (copied) {",
                "\t\t\twritten += sz - copied;",
                "\t\t\tif (written)",
                "\t\t\t\tbreak;",
                "\t\t\treturn -EFAULT;"
            ],
            "added_lines": [
                "\t\tint allowed;",
                "",
                "\t\tallowed = page_is_allowed(p >> PAGE_SHIFT);",
                "\t\tif (!allowed)",
                "\t\t/* Skip actual writing when a page is marked as restricted. */",
                "\t\tif (allowed == 1) {",
                "\t\t\t/*",
                "\t\t\t * On ia64 if a page has been mapped somewhere as",
                "\t\t\t * uncached, then it must also be accessed uncached",
                "\t\t\t * by the kernel or data corruption may occur.",
                "\t\t\t */",
                "\t\t\tptr = xlate_dev_mem_ptr(p);",
                "\t\t\tif (!ptr) {",
                "\t\t\t\tif (written)",
                "\t\t\t\t\tbreak;",
                "\t\t\t\treturn -EFAULT;",
                "\t\t\t}",
                "\t\t\tcopied = copy_from_user(ptr, buf, sz);",
                "\t\t\tunxlate_dev_mem_ptr(p, ptr);",
                "\t\t\tif (copied) {",
                "\t\t\t\twritten += sz - copied;",
                "\t\t\t\tif (written)",
                "\t\t\t\t\tbreak;",
                "\t\t\t\treturn -EFAULT;",
                "\t\t\t}"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-7889",
        "func_name": "torvalds/linux/devmem_is_allowed",
        "description": "The mm subsystem in the Linux kernel through 3.2 does not properly enforce the CONFIG_STRICT_DEVMEM protection mechanism, which allows local users to read or write to kernel memory locations in the first megabyte (and bypass slab-allocation access restrictions) via an application that opens the /dev/mem file, related to arch/x86/mm/init.c and drivers/char/mem.c.",
        "git_url": "https://github.com/torvalds/linux/commit/a4866aa812518ed1a37d8ea0c881dc946409de94",
        "commit_title": "mm: Tighten x86 /dev/mem with zeroing reads",
        "commit_text": " Under CONFIG_STRICT_DEVMEM, reading System RAM through /dev/mem is disallowed. However, on x86, the first 1MB was always allowed for BIOS and similar things, regardless of it actually being System RAM. It was possible for heap to end up getting allocated in low 1MB RAM, and then read by things like x86info or dd, which would trip hardened usercopy:  usercopy: kernel memory exposure attempt detected from ffff880000090000 (dma-kmalloc-256) (4096 bytes)  This changes the x86 exception for the low 1MB by reading back zeros for System RAM areas instead of blindly allowing them. More work is needed to extend this to mmap, but currently mmap doesn't go through usercopy, so hardened usercopy won't Oops the kernel. ",
        "func_before": "int devmem_is_allowed(unsigned long pagenr)\n{\n\tif (pagenr < 256)\n\t\treturn 1;\n\tif (iomem_is_exclusive(pagenr << PAGE_SHIFT))\n\t\treturn 0;\n\tif (!page_is_ram(pagenr))\n\t\treturn 1;\n\treturn 0;\n}",
        "func": "int devmem_is_allowed(unsigned long pagenr)\n{\n\tif (page_is_ram(pagenr)) {\n\t\t/*\n\t\t * For disallowed memory regions in the low 1MB range,\n\t\t * request that the page be shown as all zeros.\n\t\t */\n\t\tif (pagenr < 256)\n\t\t\treturn 2;\n\n\t\treturn 0;\n\t}\n\n\t/*\n\t * This must follow RAM test, since System RAM is considered a\n\t * restricted resource under CONFIG_STRICT_IOMEM.\n\t */\n\tif (iomem_is_exclusive(pagenr << PAGE_SHIFT)) {\n\t\t/* Low 1MB bypasses iomem restrictions. */\n\t\tif (pagenr < 256)\n\t\t\treturn 1;\n\n\t\treturn 0;\n\t}\n\n\treturn 1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,10 +1,27 @@\n int devmem_is_allowed(unsigned long pagenr)\n {\n-\tif (pagenr < 256)\n-\t\treturn 1;\n-\tif (iomem_is_exclusive(pagenr << PAGE_SHIFT))\n+\tif (page_is_ram(pagenr)) {\n+\t\t/*\n+\t\t * For disallowed memory regions in the low 1MB range,\n+\t\t * request that the page be shown as all zeros.\n+\t\t */\n+\t\tif (pagenr < 256)\n+\t\t\treturn 2;\n+\n \t\treturn 0;\n-\tif (!page_is_ram(pagenr))\n-\t\treturn 1;\n-\treturn 0;\n+\t}\n+\n+\t/*\n+\t * This must follow RAM test, since System RAM is considered a\n+\t * restricted resource under CONFIG_STRICT_IOMEM.\n+\t */\n+\tif (iomem_is_exclusive(pagenr << PAGE_SHIFT)) {\n+\t\t/* Low 1MB bypasses iomem restrictions. */\n+\t\tif (pagenr < 256)\n+\t\t\treturn 1;\n+\n+\t\treturn 0;\n+\t}\n+\n+\treturn 1;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "\tif (pagenr < 256)",
                "\t\treturn 1;",
                "\tif (iomem_is_exclusive(pagenr << PAGE_SHIFT))",
                "\tif (!page_is_ram(pagenr))",
                "\t\treturn 1;",
                "\treturn 0;"
            ],
            "added_lines": [
                "\tif (page_is_ram(pagenr)) {",
                "\t\t/*",
                "\t\t * For disallowed memory regions in the low 1MB range,",
                "\t\t * request that the page be shown as all zeros.",
                "\t\t */",
                "\t\tif (pagenr < 256)",
                "\t\t\treturn 2;",
                "",
                "\t}",
                "",
                "\t/*",
                "\t * This must follow RAM test, since System RAM is considered a",
                "\t * restricted resource under CONFIG_STRICT_IOMEM.",
                "\t */",
                "\tif (iomem_is_exclusive(pagenr << PAGE_SHIFT)) {",
                "\t\t/* Low 1MB bypasses iomem restrictions. */",
                "\t\tif (pagenr < 256)",
                "\t\t\treturn 1;",
                "",
                "\t\treturn 0;",
                "\t}",
                "",
                "\treturn 1;"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-9780",
        "func_name": "flatpak/repo_pull_one_dir",
        "description": "In Flatpak before 0.8.7, a third-party app repository could include malicious apps that contain files with inappropriate permissions, for example setuid or world-writable. The files are deployed with those permissions, which would let a local attacker run the setuid executable or write to the world-writable location. In the case of the \"system helper\" component, files deployed as part of the app are owned by root, so in the worst case they could be setuid root.",
        "git_url": "https://github.com/flatpak/flatpak/commit/aed5d0919830c02e490f669fc36bd9af42e632d6",
        "commit_title": "Use new libostree APIs to reject world-writable/suid content",
        "commit_text": " This uses the new libostree APIs that landed recently to ensure that we reject any files with mode outside of `0775` for system helper pulls, and we also mask directory modes during checkout.  However, this does *not* fix up any already downloaded content. For that, one could uninstall/reinstall; or a future patch could do a one-time fixup pass.  Note that I am not aware of a way for flatpak applications to escalate their privileges directly with this flaw; the bubblewrap `PR_SET_NO_NEW_PRIVS` turns of setuid. However, in combination with code execution on the host via another mechanism (e.g. unsandboxed app), a setuid app injected could be used to gain full host privileges.  At this time we're not aware of any flatpak content exploiting this issue.  Closes: https://github.com/flatpak/flatpak/issues/845",
        "func_before": "static gboolean\nrepo_pull_one_dir (OstreeRepo          *self,\n                   const char          *remote_name,\n                   const char         **dirs_to_pull,\n                   const char          *ref_to_fetch,\n                   const char          *rev_to_fetch,\n                   FlatpakPullFlags     flatpak_flags,\n                   OstreeRepoPullFlags  flags,\n                   OstreeAsyncProgress *progress,\n                   GCancellable        *cancellable,\n                   GError             **error)\n{\n  GVariantBuilder builder;\n  gboolean force_disable_deltas = (flatpak_flags & FLATPAK_PULL_FLAGS_NO_STATIC_DELTAS) != 0;\n  g_autofree char *remote_and_branch = NULL;\n  g_autofree char *current_checksum = NULL;\n  g_autoptr(GVariant) options = NULL;\n  g_autoptr(GVariant) old_commit = NULL;\n  g_autoptr(GVariant) new_commit = NULL;\n  const char *refs_to_fetch[2];\n  const char *revs_to_fetch[2];\n  guint32 update_freq = 0;\n\n  g_variant_builder_init (&builder, G_VARIANT_TYPE (\"a{sv}\"));\n\n  if (dirs_to_pull)\n    {\n      g_variant_builder_add (&builder, \"{s@v}\", \"subdirs\",\n                             g_variant_new_variant (g_variant_new_strv ((const char * const *)dirs_to_pull, -1)));\n      force_disable_deltas = TRUE;\n    }\n\n  if (force_disable_deltas)\n    g_variant_builder_add (&builder, \"{s@v}\", \"disable-static-deltas\",\n                           g_variant_new_variant (g_variant_new_boolean (TRUE)));\n\n  g_variant_builder_add (&builder, \"{s@v}\", \"inherit-transaction\",\n                         g_variant_new_variant (g_variant_new_boolean (TRUE)));\n\n  g_variant_builder_add (&builder, \"{s@v}\", \"flags\",\n                         g_variant_new_variant (g_variant_new_int32 (flags)));\n\n  refs_to_fetch[0] = ref_to_fetch;\n  refs_to_fetch[1] = NULL;\n  g_variant_builder_add (&builder, \"{s@v}\", \"refs\",\n                         g_variant_new_variant (g_variant_new_strv ((const char * const *) refs_to_fetch, -1)));\n\n  revs_to_fetch[0] = rev_to_fetch;\n  revs_to_fetch[1] = NULL;\n  g_variant_builder_add (&builder, \"{s@v}\", \"override-commit-ids\",\n                         g_variant_new_variant (g_variant_new_strv ((const char * const *) revs_to_fetch, -1)));\n\n  if (progress != NULL)\n    update_freq = GPOINTER_TO_UINT (g_object_get_data (G_OBJECT (progress), \"update-frequency\"));\n  if (update_freq == 0)\n    update_freq = FLATPAK_DEFAULT_UPDATE_FREQUENCY;\n\n  g_variant_builder_add (&builder, \"{s@v}\", \"update-frequency\",\n                         g_variant_new_variant (g_variant_new_uint32 (update_freq)));\n\n  options = g_variant_ref_sink (g_variant_builder_end (&builder));\n\n  remote_and_branch = g_strdup_printf (\"%s:%s\", remote_name, ref_to_fetch);\n  if (!ostree_repo_resolve_rev (self, remote_and_branch, TRUE, &current_checksum, error))\n    return FALSE;\n  if (current_checksum != NULL &&\n      !ostree_repo_load_commit (self, current_checksum, &old_commit, NULL, error))\n    return FALSE;\n\n  if (!ostree_repo_pull_with_options (self, remote_name, options,\n                                      progress, cancellable, error))\n    return FALSE;\n\n  if (old_commit &&\n      (flatpak_flags & FLATPAK_PULL_FLAGS_ALLOW_DOWNGRADE) == 0)\n    {\n      guint64 old_timestamp;\n      guint64 new_timestamp;\n\n      if (!ostree_repo_load_commit (self, rev_to_fetch, &new_commit, NULL, error))\n        return FALSE;\n\n      old_timestamp = ostree_commit_get_timestamp (old_commit);\n      new_timestamp = ostree_commit_get_timestamp (new_commit);\n\n      if (new_timestamp < old_timestamp)\n        return flatpak_fail (error, \"Update is older then current version\");\n    }\n\n  return TRUE;\n}",
        "func": "static gboolean\nrepo_pull_one_dir (OstreeRepo          *self,\n                   const char          *remote_name,\n                   const char         **dirs_to_pull,\n                   const char          *ref_to_fetch,\n                   const char          *rev_to_fetch,\n                   FlatpakPullFlags     flatpak_flags,\n                   OstreeRepoPullFlags  flags,\n                   OstreeAsyncProgress *progress,\n                   GCancellable        *cancellable,\n                   GError             **error)\n{\n  GVariantBuilder builder;\n  gboolean force_disable_deltas = (flatpak_flags & FLATPAK_PULL_FLAGS_NO_STATIC_DELTAS) != 0;\n  g_autofree char *remote_and_branch = NULL;\n  g_autofree char *current_checksum = NULL;\n  g_autoptr(GVariant) options = NULL;\n  g_autoptr(GVariant) old_commit = NULL;\n  g_autoptr(GVariant) new_commit = NULL;\n  const char *refs_to_fetch[2];\n  const char *revs_to_fetch[2];\n  guint32 update_freq = 0;\n\n  /* We always want this on for every type of pull */\n  flags |= OSTREE_REPO_PULL_FLAGS_BAREUSERONLY_FILES;\n\n  g_variant_builder_init (&builder, G_VARIANT_TYPE (\"a{sv}\"));\n\n  if (dirs_to_pull)\n    {\n      g_variant_builder_add (&builder, \"{s@v}\", \"subdirs\",\n                             g_variant_new_variant (g_variant_new_strv ((const char * const *)dirs_to_pull, -1)));\n      force_disable_deltas = TRUE;\n    }\n\n  if (force_disable_deltas)\n    g_variant_builder_add (&builder, \"{s@v}\", \"disable-static-deltas\",\n                           g_variant_new_variant (g_variant_new_boolean (TRUE)));\n\n  g_variant_builder_add (&builder, \"{s@v}\", \"inherit-transaction\",\n                         g_variant_new_variant (g_variant_new_boolean (TRUE)));\n\n  g_variant_builder_add (&builder, \"{s@v}\", \"flags\",\n                         g_variant_new_variant (g_variant_new_int32 (flags)));\n\n  refs_to_fetch[0] = ref_to_fetch;\n  refs_to_fetch[1] = NULL;\n  g_variant_builder_add (&builder, \"{s@v}\", \"refs\",\n                         g_variant_new_variant (g_variant_new_strv ((const char * const *) refs_to_fetch, -1)));\n\n  revs_to_fetch[0] = rev_to_fetch;\n  revs_to_fetch[1] = NULL;\n  g_variant_builder_add (&builder, \"{s@v}\", \"override-commit-ids\",\n                         g_variant_new_variant (g_variant_new_strv ((const char * const *) revs_to_fetch, -1)));\n\n  if (progress != NULL)\n    update_freq = GPOINTER_TO_UINT (g_object_get_data (G_OBJECT (progress), \"update-frequency\"));\n  if (update_freq == 0)\n    update_freq = FLATPAK_DEFAULT_UPDATE_FREQUENCY;\n\n  g_variant_builder_add (&builder, \"{s@v}\", \"update-frequency\",\n                         g_variant_new_variant (g_variant_new_uint32 (update_freq)));\n\n  options = g_variant_ref_sink (g_variant_builder_end (&builder));\n\n  remote_and_branch = g_strdup_printf (\"%s:%s\", remote_name, ref_to_fetch);\n  if (!ostree_repo_resolve_rev (self, remote_and_branch, TRUE, &current_checksum, error))\n    return FALSE;\n  if (current_checksum != NULL &&\n      !ostree_repo_load_commit (self, current_checksum, &old_commit, NULL, error))\n    return FALSE;\n\n  if (!ostree_repo_pull_with_options (self, remote_name, options,\n                                      progress, cancellable, error))\n    return FALSE;\n\n  if (old_commit &&\n      (flatpak_flags & FLATPAK_PULL_FLAGS_ALLOW_DOWNGRADE) == 0)\n    {\n      guint64 old_timestamp;\n      guint64 new_timestamp;\n\n      if (!ostree_repo_load_commit (self, rev_to_fetch, &new_commit, NULL, error))\n        return FALSE;\n\n      old_timestamp = ostree_commit_get_timestamp (old_commit);\n      new_timestamp = ostree_commit_get_timestamp (new_commit);\n\n      if (new_timestamp < old_timestamp)\n        return flatpak_fail (error, \"Update is older then current version\");\n    }\n\n  return TRUE;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -20,6 +20,9 @@\n   const char *refs_to_fetch[2];\n   const char *revs_to_fetch[2];\n   guint32 update_freq = 0;\n+\n+  /* We always want this on for every type of pull */\n+  flags |= OSTREE_REPO_PULL_FLAGS_BAREUSERONLY_FILES;\n \n   g_variant_builder_init (&builder, G_VARIANT_TYPE (\"a{sv}\"));\n ",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "",
                "  /* We always want this on for every type of pull */",
                "  flags |= OSTREE_REPO_PULL_FLAGS_BAREUSERONLY_FILES;"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-9780",
        "func_name": "flatpak/flatpak_dir_deploy_appstream",
        "description": "In Flatpak before 0.8.7, a third-party app repository could include malicious apps that contain files with inappropriate permissions, for example setuid or world-writable. The files are deployed with those permissions, which would let a local attacker run the setuid executable or write to the world-writable location. In the case of the \"system helper\" component, files deployed as part of the app are owned by root, so in the worst case they could be setuid root.",
        "git_url": "https://github.com/flatpak/flatpak/commit/aed5d0919830c02e490f669fc36bd9af42e632d6",
        "commit_title": "Use new libostree APIs to reject world-writable/suid content",
        "commit_text": " This uses the new libostree APIs that landed recently to ensure that we reject any files with mode outside of `0775` for system helper pulls, and we also mask directory modes during checkout.  However, this does *not* fix up any already downloaded content. For that, one could uninstall/reinstall; or a future patch could do a one-time fixup pass.  Note that I am not aware of a way for flatpak applications to escalate their privileges directly with this flaw; the bubblewrap `PR_SET_NO_NEW_PRIVS` turns of setuid. However, in combination with code execution on the host via another mechanism (e.g. unsandboxed app), a setuid app injected could be used to gain full host privileges.  At this time we're not aware of any flatpak content exploiting this issue.  Closes: https://github.com/flatpak/flatpak/issues/845",
        "func_before": "gboolean\nflatpak_dir_deploy_appstream (FlatpakDir          *self,\n                              const char          *remote,\n                              const char          *arch,\n                              gboolean            *out_changed,\n                              GCancellable        *cancellable,\n                              GError             **error)\n{\n  g_autoptr(GFile) appstream_dir = NULL;\n  g_autoptr(GFile) remote_dir = NULL;\n  g_autoptr(GFile) arch_dir = NULL;\n  g_autoptr(GFile) checkout_dir = NULL;\n  g_autoptr(GFile) real_checkout_dir = NULL;\n  g_autoptr(GFile) timestamp_file = NULL;\n  g_autofree char *arch_path = NULL;\n  gboolean checkout_exists;\n  g_autofree char *remote_and_branch = NULL;\n  const char *old_checksum = NULL;\n  g_autofree char *new_checksum = NULL;\n  g_autoptr(GFile) active_link = NULL;\n  g_autofree char *branch = NULL;\n  g_autoptr(GFile) old_checkout_dir = NULL;\n  g_autoptr(GFile) active_tmp_link = NULL;\n  g_autoptr(GError) tmp_error = NULL;\n  g_autofree char *checkout_dir_path = NULL;\n  OstreeRepoCheckoutAtOptions options = { 0, };\n  glnx_fd_close int dfd = -1;\n  g_autoptr(GFileInfo) file_info = NULL;\n  g_autofree char *tmpname = g_strdup (\".active-XXXXXX\");\n\n  appstream_dir = g_file_get_child (flatpak_dir_get_path (self), \"appstream\");\n  remote_dir = g_file_get_child (appstream_dir, remote);\n  arch_dir = g_file_get_child (remote_dir, arch);\n  active_link = g_file_get_child (arch_dir, \"active\");\n  timestamp_file = g_file_get_child (arch_dir, \".timestamp\");\n\n  arch_path = g_file_get_path (arch_dir);\n  if (g_mkdir_with_parents (arch_path, 0755) != 0)\n    {\n      glnx_set_error_from_errno (error);\n      return FALSE;\n    }\n\n  if (!glnx_opendirat (AT_FDCWD, arch_path, TRUE, &dfd, error))\n    return FALSE;\n\n  old_checksum = NULL;\n  file_info = g_file_query_info (active_link, OSTREE_GIO_FAST_QUERYINFO,\n                                 G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                                 cancellable, NULL);\n  if (file_info != NULL)\n    old_checksum =  g_file_info_get_symlink_target (file_info);\n\n  branch = g_strdup_printf (\"appstream/%s\", arch);\n  remote_and_branch = g_strdup_printf (\"%s:%s\", remote, branch);\n  if (!ostree_repo_resolve_rev (self->repo, remote_and_branch, TRUE, &new_checksum, error))\n    return FALSE;\n\n  real_checkout_dir = g_file_get_child (arch_dir, new_checksum);\n  checkout_exists = g_file_query_exists (real_checkout_dir, NULL);\n\n  if (old_checksum != NULL && new_checksum != NULL &&\n      strcmp (old_checksum, new_checksum) == 0 &&\n      checkout_exists)\n    {\n      if (!g_file_replace_contents (timestamp_file, \"\", 0, NULL, FALSE,\n                                    G_FILE_CREATE_REPLACE_DESTINATION, NULL, NULL, error))\n        return FALSE;\n\n      if (out_changed)\n        *out_changed = FALSE;\n\n      return TRUE; /* No changes, don't checkout */\n    }\n\n  {\n    g_autofree char *template = g_strdup_printf (\".%s-XXXXXX\", new_checksum);\n    g_autoptr(GFile) tmp_dir_template = g_file_get_child (arch_dir, template);\n    checkout_dir_path = g_file_get_path (tmp_dir_template);\n    if (g_mkdtemp_full (checkout_dir_path, 0755) == NULL)\n      {\n        g_set_error (error, G_IO_ERROR, G_IO_ERROR_FAILED,\n                     _(\"Can't create deploy directory\"));\n        return FALSE;\n      }\n  }\n  checkout_dir = g_file_new_for_path (checkout_dir_path);\n\n  options.mode = OSTREE_REPO_CHECKOUT_MODE_USER;\n  options.overwrite_mode = OSTREE_REPO_CHECKOUT_OVERWRITE_UNION_FILES;\n  options.enable_fsync = FALSE; /* We checkout to a temp dir and sync before moving it in place */\n\n  if (!ostree_repo_checkout_at (self->repo, &options,\n                                AT_FDCWD, checkout_dir_path, new_checksum,\n                                cancellable, error))\n    return FALSE;\n\n  glnx_gen_temp_name (tmpname);\n  active_tmp_link = g_file_get_child (arch_dir, tmpname);\n\n  if (!g_file_make_symbolic_link (active_tmp_link, new_checksum, cancellable, error))\n    return FALSE;\n\n  if (syncfs (dfd) != 0)\n    {\n      glnx_set_error_from_errno (error);\n      return FALSE;\n    }\n\n  /* By now the checkout to the temporary directory is on disk, as is the temporary\n     symlink pointing to the final target. */\n\n  if (!g_file_move (checkout_dir, real_checkout_dir, G_FILE_COPY_NO_FALLBACK_FOR_MOVE,\n                    cancellable, NULL, NULL, error))\n    return FALSE;\n\n  if (syncfs (dfd) != 0)\n    {\n      glnx_set_error_from_errno (error);\n      return FALSE;\n    }\n\n  if (!flatpak_file_rename (active_tmp_link,\n                            active_link,\n                            cancellable, error))\n    return FALSE;\n\n  if (old_checksum != NULL &&\n      g_strcmp0 (old_checksum, new_checksum) != 0)\n    {\n      old_checkout_dir = g_file_get_child (arch_dir, old_checksum);\n      if (!flatpak_rm_rf (old_checkout_dir, cancellable, &tmp_error))\n        g_warning (\"Unable to remove old appstream checkout: %s\\n\", tmp_error->message);\n    }\n\n  if (!g_file_replace_contents (timestamp_file, \"\", 0, NULL, FALSE,\n                                G_FILE_CREATE_REPLACE_DESTINATION, NULL, NULL, error))\n    return FALSE;\n\n  /* If we added a new checkout, touch the toplevel dir to tell people that they need\n     to re-scan */\n  if (!checkout_exists)\n    {\n      g_autofree char *appstream_dir_path = g_file_get_path (appstream_dir);\n      utime (appstream_dir_path, NULL);\n    }\n\n  if (out_changed)\n    *out_changed = TRUE;\n\n  return TRUE;\n}",
        "func": "gboolean\nflatpak_dir_deploy_appstream (FlatpakDir          *self,\n                              const char          *remote,\n                              const char          *arch,\n                              gboolean            *out_changed,\n                              GCancellable        *cancellable,\n                              GError             **error)\n{\n  g_autoptr(GFile) appstream_dir = NULL;\n  g_autoptr(GFile) remote_dir = NULL;\n  g_autoptr(GFile) arch_dir = NULL;\n  g_autoptr(GFile) checkout_dir = NULL;\n  g_autoptr(GFile) real_checkout_dir = NULL;\n  g_autoptr(GFile) timestamp_file = NULL;\n  g_autofree char *arch_path = NULL;\n  gboolean checkout_exists;\n  g_autofree char *remote_and_branch = NULL;\n  const char *old_checksum = NULL;\n  g_autofree char *new_checksum = NULL;\n  g_autoptr(GFile) active_link = NULL;\n  g_autofree char *branch = NULL;\n  g_autoptr(GFile) old_checkout_dir = NULL;\n  g_autoptr(GFile) active_tmp_link = NULL;\n  g_autoptr(GError) tmp_error = NULL;\n  g_autofree char *checkout_dir_path = NULL;\n  OstreeRepoCheckoutAtOptions options = { 0, };\n  glnx_fd_close int dfd = -1;\n  g_autoptr(GFileInfo) file_info = NULL;\n  g_autofree char *tmpname = g_strdup (\".active-XXXXXX\");\n\n  appstream_dir = g_file_get_child (flatpak_dir_get_path (self), \"appstream\");\n  remote_dir = g_file_get_child (appstream_dir, remote);\n  arch_dir = g_file_get_child (remote_dir, arch);\n  active_link = g_file_get_child (arch_dir, \"active\");\n  timestamp_file = g_file_get_child (arch_dir, \".timestamp\");\n\n  arch_path = g_file_get_path (arch_dir);\n  if (g_mkdir_with_parents (arch_path, 0755) != 0)\n    {\n      glnx_set_error_from_errno (error);\n      return FALSE;\n    }\n\n  if (!glnx_opendirat (AT_FDCWD, arch_path, TRUE, &dfd, error))\n    return FALSE;\n\n  old_checksum = NULL;\n  file_info = g_file_query_info (active_link, OSTREE_GIO_FAST_QUERYINFO,\n                                 G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                                 cancellable, NULL);\n  if (file_info != NULL)\n    old_checksum =  g_file_info_get_symlink_target (file_info);\n\n  branch = g_strdup_printf (\"appstream/%s\", arch);\n  remote_and_branch = g_strdup_printf (\"%s:%s\", remote, branch);\n  if (!ostree_repo_resolve_rev (self->repo, remote_and_branch, TRUE, &new_checksum, error))\n    return FALSE;\n\n  real_checkout_dir = g_file_get_child (arch_dir, new_checksum);\n  checkout_exists = g_file_query_exists (real_checkout_dir, NULL);\n\n  if (old_checksum != NULL && new_checksum != NULL &&\n      strcmp (old_checksum, new_checksum) == 0 &&\n      checkout_exists)\n    {\n      if (!g_file_replace_contents (timestamp_file, \"\", 0, NULL, FALSE,\n                                    G_FILE_CREATE_REPLACE_DESTINATION, NULL, NULL, error))\n        return FALSE;\n\n      if (out_changed)\n        *out_changed = FALSE;\n\n      return TRUE; /* No changes, don't checkout */\n    }\n\n  {\n    g_autofree char *template = g_strdup_printf (\".%s-XXXXXX\", new_checksum);\n    g_autoptr(GFile) tmp_dir_template = g_file_get_child (arch_dir, template);\n    checkout_dir_path = g_file_get_path (tmp_dir_template);\n    if (g_mkdtemp_full (checkout_dir_path, 0755) == NULL)\n      {\n        g_set_error (error, G_IO_ERROR, G_IO_ERROR_FAILED,\n                     _(\"Can't create deploy directory\"));\n        return FALSE;\n      }\n  }\n  checkout_dir = g_file_new_for_path (checkout_dir_path);\n\n  options.mode = OSTREE_REPO_CHECKOUT_MODE_USER;\n  options.overwrite_mode = OSTREE_REPO_CHECKOUT_OVERWRITE_UNION_FILES;\n  options.enable_fsync = FALSE; /* We checkout to a temp dir and sync before moving it in place */\n  options.bareuseronly_dirs = TRUE; /* https://github.com/ostreedev/ostree/pull/927 */\n\n  if (!ostree_repo_checkout_at (self->repo, &options,\n                                AT_FDCWD, checkout_dir_path, new_checksum,\n                                cancellable, error))\n    return FALSE;\n\n  glnx_gen_temp_name (tmpname);\n  active_tmp_link = g_file_get_child (arch_dir, tmpname);\n\n  if (!g_file_make_symbolic_link (active_tmp_link, new_checksum, cancellable, error))\n    return FALSE;\n\n  if (syncfs (dfd) != 0)\n    {\n      glnx_set_error_from_errno (error);\n      return FALSE;\n    }\n\n  /* By now the checkout to the temporary directory is on disk, as is the temporary\n     symlink pointing to the final target. */\n\n  if (!g_file_move (checkout_dir, real_checkout_dir, G_FILE_COPY_NO_FALLBACK_FOR_MOVE,\n                    cancellable, NULL, NULL, error))\n    return FALSE;\n\n  if (syncfs (dfd) != 0)\n    {\n      glnx_set_error_from_errno (error);\n      return FALSE;\n    }\n\n  if (!flatpak_file_rename (active_tmp_link,\n                            active_link,\n                            cancellable, error))\n    return FALSE;\n\n  if (old_checksum != NULL &&\n      g_strcmp0 (old_checksum, new_checksum) != 0)\n    {\n      old_checkout_dir = g_file_get_child (arch_dir, old_checksum);\n      if (!flatpak_rm_rf (old_checkout_dir, cancellable, &tmp_error))\n        g_warning (\"Unable to remove old appstream checkout: %s\\n\", tmp_error->message);\n    }\n\n  if (!g_file_replace_contents (timestamp_file, \"\", 0, NULL, FALSE,\n                                G_FILE_CREATE_REPLACE_DESTINATION, NULL, NULL, error))\n    return FALSE;\n\n  /* If we added a new checkout, touch the toplevel dir to tell people that they need\n     to re-scan */\n  if (!checkout_exists)\n    {\n      g_autofree char *appstream_dir_path = g_file_get_path (appstream_dir);\n      utime (appstream_dir_path, NULL);\n    }\n\n  if (out_changed)\n    *out_changed = TRUE;\n\n  return TRUE;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -89,6 +89,7 @@\n   options.mode = OSTREE_REPO_CHECKOUT_MODE_USER;\n   options.overwrite_mode = OSTREE_REPO_CHECKOUT_OVERWRITE_UNION_FILES;\n   options.enable_fsync = FALSE; /* We checkout to a temp dir and sync before moving it in place */\n+  options.bareuseronly_dirs = TRUE; /* https://github.com/ostreedev/ostree/pull/927 */\n \n   if (!ostree_repo_checkout_at (self->repo, &options,\n                                 AT_FDCWD, checkout_dir_path, new_checksum,",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "  options.bareuseronly_dirs = TRUE; /* https://github.com/ostreedev/ostree/pull/927 */"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-9780",
        "func_name": "flatpak/repo_pull_one_untrusted",
        "description": "In Flatpak before 0.8.7, a third-party app repository could include malicious apps that contain files with inappropriate permissions, for example setuid or world-writable. The files are deployed with those permissions, which would let a local attacker run the setuid executable or write to the world-writable location. In the case of the \"system helper\" component, files deployed as part of the app are owned by root, so in the worst case they could be setuid root.",
        "git_url": "https://github.com/flatpak/flatpak/commit/aed5d0919830c02e490f669fc36bd9af42e632d6",
        "commit_title": "Use new libostree APIs to reject world-writable/suid content",
        "commit_text": " This uses the new libostree APIs that landed recently to ensure that we reject any files with mode outside of `0775` for system helper pulls, and we also mask directory modes during checkout.  However, this does *not* fix up any already downloaded content. For that, one could uninstall/reinstall; or a future patch could do a one-time fixup pass.  Note that I am not aware of a way for flatpak applications to escalate their privileges directly with this flaw; the bubblewrap `PR_SET_NO_NEW_PRIVS` turns of setuid. However, in combination with code execution on the host via another mechanism (e.g. unsandboxed app), a setuid app injected could be used to gain full host privileges.  At this time we're not aware of any flatpak content exploiting this issue.  Closes: https://github.com/flatpak/flatpak/issues/845",
        "func_before": "static gboolean\nrepo_pull_one_untrusted (OstreeRepo          *self,\n                         const char          *remote_name,\n                         const char          *url,\n                         const char         **dirs_to_pull,\n                         const char          *ref,\n                         const char          *checksum,\n                         OstreeAsyncProgress *progress,\n                         GCancellable        *cancellable,\n                         GError             **error)\n{\n  OstreeRepoPullFlags flags = OSTREE_REPO_PULL_FLAGS_UNTRUSTED;\n  GVariantBuilder builder;\n  g_auto(GLnxConsoleRef) console = { 0, };\n  g_autoptr(OstreeAsyncProgress) console_progress = NULL;\n  gboolean res;\n  g_variant_builder_init (&builder, G_VARIANT_TYPE (\"a{sv}\"));\n  const char *refs[2] = { NULL, NULL };\n  const char *commits[2] = { NULL, NULL };\n\n  if (progress == NULL)\n    {\n      glnx_console_lock (&console);\n      if (console.is_tty)\n        {\n          console_progress = ostree_async_progress_new_and_connect (default_progress_changed, &console);\n          progress = console_progress;\n        }\n    }\n\n  refs[0] = ref;\n  commits[0] = checksum;\n\n  g_variant_builder_add (&builder, \"{s@v}\", \"flags\",\n                         g_variant_new_variant (g_variant_new_int32 (flags)));\n  g_variant_builder_add (&builder, \"{s@v}\", \"refs\",\n                         g_variant_new_variant (g_variant_new_strv ((const char * const *) refs, -1)));\n  g_variant_builder_add (&builder, \"{s@v}\", \"override-commit-ids\",\n                         g_variant_new_variant (g_variant_new_strv ((const char * const *) commits, -1)));\n  g_variant_builder_add (&builder, \"{s@v}\", \"override-remote-name\",\n                         g_variant_new_variant (g_variant_new_string (remote_name)));\n  g_variant_builder_add (&builder, \"{s@v}\", \"gpg-verify\",\n                         g_variant_new_variant (g_variant_new_boolean (TRUE)));\n  g_variant_builder_add (&builder, \"{s@v}\", \"gpg-verify-summary\",\n                         g_variant_new_variant (g_variant_new_boolean (TRUE)));\n  g_variant_builder_add (&builder, \"{s@v}\", \"inherit-transaction\",\n                         g_variant_new_variant (g_variant_new_boolean (TRUE)));\n  g_variant_builder_add (&builder, \"{s@v}\", \"update-frequency\",\n                         g_variant_new_variant (g_variant_new_uint32 (FLATPAK_DEFAULT_UPDATE_FREQUENCY)));\n\n  if (dirs_to_pull)\n    {\n      g_variant_builder_add (&builder, \"{s@v}\", \"subdirs\",\n                             g_variant_new_variant (g_variant_new_strv ((const char * const *)dirs_to_pull, -1)));\n      g_variant_builder_add (&builder, \"{s@v}\", \"disable-static-deltas\",\n                             g_variant_new_variant (g_variant_new_boolean (TRUE)));\n    }\n\n  res = ostree_repo_pull_with_options (self, url, g_variant_builder_end (&builder),\n                                       progress, cancellable, error);\n\n  if (progress)\n    ostree_async_progress_finish (progress);\n\n  return res;\n}",
        "func": "static gboolean\nrepo_pull_one_untrusted (OstreeRepo          *self,\n                         const char          *remote_name,\n                         const char          *url,\n                         const char         **dirs_to_pull,\n                         const char          *ref,\n                         const char          *checksum,\n                         OstreeAsyncProgress *progress,\n                         GCancellable        *cancellable,\n                         GError             **error)\n{\n  /* The latter flag was introduced in https://github.com/ostreedev/ostree/pull/926 */\n  const OstreeRepoPullFlags flags = OSTREE_REPO_PULL_FLAGS_UNTRUSTED |OSTREE_REPO_PULL_FLAGS_BAREUSERONLY_FILES;\n  GVariantBuilder builder;\n  g_auto(GLnxConsoleRef) console = { 0, };\n  g_autoptr(OstreeAsyncProgress) console_progress = NULL;\n  gboolean res;\n  g_variant_builder_init (&builder, G_VARIANT_TYPE (\"a{sv}\"));\n  const char *refs[2] = { NULL, NULL };\n  const char *commits[2] = { NULL, NULL };\n\n  if (progress == NULL)\n    {\n      glnx_console_lock (&console);\n      if (console.is_tty)\n        {\n          console_progress = ostree_async_progress_new_and_connect (default_progress_changed, &console);\n          progress = console_progress;\n        }\n    }\n\n  refs[0] = ref;\n  commits[0] = checksum;\n\n  g_variant_builder_add (&builder, \"{s@v}\", \"flags\",\n                         g_variant_new_variant (g_variant_new_int32 (flags)));\n  g_variant_builder_add (&builder, \"{s@v}\", \"refs\",\n                         g_variant_new_variant (g_variant_new_strv ((const char * const *) refs, -1)));\n  g_variant_builder_add (&builder, \"{s@v}\", \"override-commit-ids\",\n                         g_variant_new_variant (g_variant_new_strv ((const char * const *) commits, -1)));\n  g_variant_builder_add (&builder, \"{s@v}\", \"override-remote-name\",\n                         g_variant_new_variant (g_variant_new_string (remote_name)));\n  g_variant_builder_add (&builder, \"{s@v}\", \"gpg-verify\",\n                         g_variant_new_variant (g_variant_new_boolean (TRUE)));\n  g_variant_builder_add (&builder, \"{s@v}\", \"gpg-verify-summary\",\n                         g_variant_new_variant (g_variant_new_boolean (TRUE)));\n  g_variant_builder_add (&builder, \"{s@v}\", \"inherit-transaction\",\n                         g_variant_new_variant (g_variant_new_boolean (TRUE)));\n  g_variant_builder_add (&builder, \"{s@v}\", \"update-frequency\",\n                         g_variant_new_variant (g_variant_new_uint32 (FLATPAK_DEFAULT_UPDATE_FREQUENCY)));\n\n  if (dirs_to_pull)\n    {\n      g_variant_builder_add (&builder, \"{s@v}\", \"subdirs\",\n                             g_variant_new_variant (g_variant_new_strv ((const char * const *)dirs_to_pull, -1)));\n      g_variant_builder_add (&builder, \"{s@v}\", \"disable-static-deltas\",\n                             g_variant_new_variant (g_variant_new_boolean (TRUE)));\n    }\n\n  res = ostree_repo_pull_with_options (self, url, g_variant_builder_end (&builder),\n                                       progress, cancellable, error);\n\n  if (progress)\n    ostree_async_progress_finish (progress);\n\n  return res;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -9,7 +9,8 @@\n                          GCancellable        *cancellable,\n                          GError             **error)\n {\n-  OstreeRepoPullFlags flags = OSTREE_REPO_PULL_FLAGS_UNTRUSTED;\n+  /* The latter flag was introduced in https://github.com/ostreedev/ostree/pull/926 */\n+  const OstreeRepoPullFlags flags = OSTREE_REPO_PULL_FLAGS_UNTRUSTED |OSTREE_REPO_PULL_FLAGS_BAREUSERONLY_FILES;\n   GVariantBuilder builder;\n   g_auto(GLnxConsoleRef) console = { 0, };\n   g_autoptr(OstreeAsyncProgress) console_progress = NULL;",
        "diff_line_info": {
            "deleted_lines": [
                "  OstreeRepoPullFlags flags = OSTREE_REPO_PULL_FLAGS_UNTRUSTED;"
            ],
            "added_lines": [
                "  /* The latter flag was introduced in https://github.com/ostreedev/ostree/pull/926 */",
                "  const OstreeRepoPullFlags flags = OSTREE_REPO_PULL_FLAGS_UNTRUSTED |OSTREE_REPO_PULL_FLAGS_BAREUSERONLY_FILES;"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-9780",
        "func_name": "flatpak/flatpak_dir_deploy",
        "description": "In Flatpak before 0.8.7, a third-party app repository could include malicious apps that contain files with inappropriate permissions, for example setuid or world-writable. The files are deployed with those permissions, which would let a local attacker run the setuid executable or write to the world-writable location. In the case of the \"system helper\" component, files deployed as part of the app are owned by root, so in the worst case they could be setuid root.",
        "git_url": "https://github.com/flatpak/flatpak/commit/aed5d0919830c02e490f669fc36bd9af42e632d6",
        "commit_title": "Use new libostree APIs to reject world-writable/suid content",
        "commit_text": " This uses the new libostree APIs that landed recently to ensure that we reject any files with mode outside of `0775` for system helper pulls, and we also mask directory modes during checkout.  However, this does *not* fix up any already downloaded content. For that, one could uninstall/reinstall; or a future patch could do a one-time fixup pass.  Note that I am not aware of a way for flatpak applications to escalate their privileges directly with this flaw; the bubblewrap `PR_SET_NO_NEW_PRIVS` turns of setuid. However, in combination with code execution on the host via another mechanism (e.g. unsandboxed app), a setuid app injected could be used to gain full host privileges.  At this time we're not aware of any flatpak content exploiting this issue.  Closes: https://github.com/flatpak/flatpak/issues/845",
        "func_before": "gboolean\nflatpak_dir_deploy (FlatpakDir          *self,\n                    const char          *origin,\n                    const char          *ref,\n                    const char          *checksum_or_latest,\n                    const char * const * subpaths,\n                    GVariant            *old_deploy_data,\n                    GCancellable        *cancellable,\n                    GError             **error)\n{\n  g_autofree char *resolved_ref = NULL;\n\n  g_autoptr(GFile) root = NULL;\n  g_autoptr(GFile) deploy_base = NULL;\n  g_autoptr(GFile) checkoutdir = NULL;\n  g_autofree char *checkoutdirpath = NULL;\n  g_autoptr(GFile) real_checkoutdir = NULL;\n  g_autoptr(GFile) dotref = NULL;\n  g_autoptr(GFile) files_etc = NULL;\n  g_autoptr(GFile) metadata = NULL;\n  g_autoptr(GFile) deploy_data_file = NULL;\n  g_autoptr(GVariant) deploy_data = NULL;\n  g_autoptr(GFile) export = NULL;\n  g_autoptr(GFile) extradir = NULL;\n  g_autoptr(GKeyFile) keyfile = NULL;\n  guint64 installed_size = 0;\n  OstreeRepoCheckoutAtOptions options = { 0, };\n  const char *checksum;\n  glnx_fd_close int checkoutdir_dfd = -1;\n  g_autoptr(GFile) tmp_dir_template = NULL;\n  g_autoptr(GVariant) commit_data = NULL;\n  g_autofree char *tmp_dir_path = NULL;\n  g_autofree char *alt_id = NULL;\n  const char *xa_metadata = NULL;\n  const char *xa_ref = NULL;\n  g_autofree char *checkout_basename = NULL;\n  gboolean created_extra_data = FALSE;\n  g_autoptr(GVariant) commit_metadata = NULL;\n  GVariantBuilder metadata_builder;\n\n  if (!flatpak_dir_ensure_repo (self, cancellable, error))\n    return FALSE;\n\n  deploy_base = flatpak_dir_get_deploy_dir (self, ref);\n\n  if (checksum_or_latest == NULL)\n    {\n      g_debug (\"No checksum specified, getting tip of %s\", ref);\n\n      resolved_ref = flatpak_dir_read_latest (self, origin, ref, NULL, cancellable, error);\n      if (resolved_ref == NULL)\n        {\n          g_prefix_error (error, _(\"While trying to resolve ref %s: \"), ref);\n          return FALSE;\n        }\n\n      checksum = resolved_ref;\n      g_debug (\"tip resolved to: %s\", checksum);\n    }\n  else\n    {\n      g_autoptr(GFile) root = NULL;\n      g_autofree char *commit = NULL;\n\n      checksum = checksum_or_latest;\n      g_debug (\"Looking for checksum %s in local repo\", checksum);\n      if (!ostree_repo_read_commit (self->repo, checksum, &root, &commit, cancellable, NULL))\n        return flatpak_fail (error, _(\"%s is not available\"), ref);\n    }\n\n  if (!ostree_repo_load_commit (self->repo, checksum, &commit_data, NULL, error))\n    return FALSE;\n\n  commit_metadata = g_variant_get_child_value (commit_data, 0);\n  g_variant_lookup (commit_metadata, \"xa.alt-id\", \"s\", &alt_id);\n\n  if (subpaths == NULL || *subpaths == NULL)\n    checkout_basename = g_strdup (checksum);\n  else\n    {\n      GString *str = g_string_new (checksum);\n      int i;\n      for (i = 0; subpaths[i] != NULL; i++)\n        {\n          const char *s = subpaths[i];\n          g_string_append_c (str, '-');\n          while (*s)\n            {\n              if (*s != '/')\n                g_string_append_c (str, *s);\n              s++;\n            }\n        }\n      checkout_basename = g_string_free (str, FALSE);\n    }\n\n  real_checkoutdir = g_file_get_child (deploy_base, checkout_basename);\n  if (g_file_query_exists (real_checkoutdir, cancellable))\n    {\n      g_set_error (error, FLATPAK_ERROR, FLATPAK_ERROR_ALREADY_INSTALLED,\n                   _(\"%s branch %s already installed\"), ref, checksum);\n      return FALSE;\n    }\n\n  g_autofree char *template = g_strdup_printf (\".%s-XXXXXX\", checkout_basename);\n  tmp_dir_template = g_file_get_child (deploy_base, template);\n  tmp_dir_path = g_file_get_path (tmp_dir_template);\n\n  if (g_mkdtemp_full (tmp_dir_path, 0755) == NULL)\n    {\n      g_set_error_literal (error, G_IO_ERROR, G_IO_ERROR_FAILED,\n                           _(\"Can't create deploy directory\"));\n      return FALSE;\n    }\n\n  checkoutdir = g_file_new_for_path (tmp_dir_path);\n\n  if (!ostree_repo_read_commit (self->repo, checksum, &root, NULL, cancellable, error))\n    {\n      g_prefix_error (error, _(\"Failed to read commit %s: \"), checksum);\n      return FALSE;\n    }\n\n  if (!flatpak_repo_collect_sizes (self->repo, root, &installed_size, NULL, cancellable, error))\n    return FALSE;\n\n  options.mode = OSTREE_REPO_CHECKOUT_MODE_USER;\n  options.overwrite_mode = OSTREE_REPO_CHECKOUT_OVERWRITE_UNION_FILES;\n  options.enable_fsync = FALSE; /* We checkout to a temp dir and sync before moving it in place */\n  checkoutdirpath = g_file_get_path (checkoutdir);\n\n  if (subpaths == NULL || *subpaths == NULL)\n    {\n      if (!ostree_repo_checkout_at (self->repo, &options,\n                                    AT_FDCWD, checkoutdirpath,\n                                    checksum,\n                                    cancellable, error))\n        {\n          g_prefix_error (error, _(\"While trying to checkout %s into %s: \"), checksum, checkoutdirpath);\n          return FALSE;\n        }\n    }\n  else\n    {\n      g_autofree char *checkoutdirpath = g_file_get_path (checkoutdir);\n      g_autoptr(GFile) files = g_file_get_child (checkoutdir, \"files\");\n      g_autoptr(GFile) root = NULL;\n      g_autofree char *commit = NULL;\n      int i;\n\n      if (!g_file_make_directory_with_parents (files, cancellable, error))\n        return FALSE;\n\n      options.subpath = \"/metadata\";\n\n      if (!ostree_repo_read_commit (self->repo, checksum, &root,  &commit, cancellable, error))\n        return FALSE;\n\n      if (!ostree_repo_checkout_at (self->repo, &options,\n                                    AT_FDCWD, checkoutdirpath,\n                                    checksum,\n                                    cancellable, error))\n        {\n          g_prefix_error (error, _(\"While trying to checkout metadata subpath: \"));\n          return FALSE;\n        }\n\n      for (i = 0; subpaths[i] != NULL; i++)\n        {\n          g_autofree char *subpath = g_build_filename (\"/files\", subpaths[i], NULL);\n          g_autofree char *dstpath = g_build_filename (checkoutdirpath, \"/files\", subpaths[i], NULL);\n          g_autofree char *dstpath_parent = g_path_get_dirname (dstpath);\n          g_autoptr(GFile) child = NULL;\n\n          child = g_file_resolve_relative_path (root, subpath);\n\n          if (!g_file_query_exists (child, cancellable))\n            {\n              g_debug (\"subpath %s not in tree\", subpaths[i]);\n              continue;\n            }\n\n          if (g_mkdir_with_parents (dstpath_parent, 0755))\n            {\n              glnx_set_error_from_errno (error);\n              return FALSE;\n            }\n\n          options.subpath = subpath;\n          if (!ostree_repo_checkout_at (self->repo, &options,\n                                        AT_FDCWD, dstpath,\n                                        checksum,\n                                        cancellable, error))\n            {\n              g_prefix_error (error, _(\"While trying to checkout metadata subpath: \"));\n              return FALSE;\n            }\n        }\n    }\n\n  /* Extract any extra data */\n  extradir = g_file_resolve_relative_path (checkoutdir, \"files/extra\");\n  if (!flatpak_rm_rf (extradir, cancellable, error))\n    {\n      g_prefix_error (error, _(\"While trying to remove existing extra dir: \"));\n      return FALSE;\n    }\n\n  if (!extract_extra_data (self, checksum, extradir, &created_extra_data, cancellable, error))\n    return FALSE;\n\n  if (created_extra_data)\n    {\n      if (!apply_extra_data (self, checkoutdir, cancellable, error))\n        {\n          g_prefix_error (error, _(\"While trying to apply extra data: \"));\n          return FALSE;\n        }\n    }\n\n  g_variant_lookup (commit_metadata, \"xa.ref\", \"s\", &xa_ref);\n  if (xa_ref != NULL)\n    {\n      if (strcmp (ref, xa_ref) != 0)\n        {\n          g_set_error (error, G_IO_ERROR, G_IO_ERROR_PERMISSION_DENIED,\n                       _(\"Deployed ref %s does not match commit (%s)\"), ref, xa_ref);\n          return FALSE;\n        }\n    }\n\n  /* Check the metadata in the commit to make sure it matches the actual\n     deployed metadata, in case we relied on the one in the commit for\n     a decision */\n  g_variant_lookup (commit_metadata, \"xa.metadata\", \"s\", &xa_metadata);\n  if (xa_metadata != NULL)\n    {\n      g_autoptr(GFile) metadata_file = g_file_resolve_relative_path (checkoutdir, \"metadata\");\n      char *metadata_contents;\n\n      if (!g_file_load_contents (metadata_file, NULL,\n                                 &metadata_contents, NULL, NULL, NULL) ||\n          strcmp (metadata_contents, xa_metadata) != 0)\n        {\n          g_set_error (error, G_IO_ERROR, G_IO_ERROR_PERMISSION_DENIED,\n                       _(\"Deployed metadata does not match commit\"));\n          return FALSE;\n        }\n    }\n\n  dotref = g_file_resolve_relative_path (checkoutdir, \"files/.ref\");\n  if (!g_file_replace_contents (dotref, \"\", 0, NULL, FALSE,\n                                G_FILE_CREATE_REPLACE_DESTINATION, NULL, cancellable, error))\n    return TRUE;\n\n  /* Ensure that various files exists as regular files in /usr/etc, as we\n     want to bind-mount over them */\n  files_etc = g_file_resolve_relative_path (checkoutdir, \"files/etc\");\n  if (g_file_query_exists (files_etc, cancellable))\n    {\n      char *etcfiles[] = {\"passwd\", \"group\", \"machine-id\" };\n      g_autoptr(GFile) etc_resolve_conf = g_file_get_child (files_etc, \"resolv.conf\");\n      int i;\n      for (i = 0; i < G_N_ELEMENTS (etcfiles); i++)\n        {\n          g_autoptr(GFile) etc_file = g_file_get_child (files_etc, etcfiles[i]);\n          GFileType type;\n\n          type = g_file_query_file_type (etc_file, G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                                         cancellable);\n          if (type == G_FILE_TYPE_REGULAR)\n            continue;\n\n          if (type != G_FILE_TYPE_UNKNOWN)\n            {\n              /* Already exists, but not regular, probably symlink. Remove it */\n              if (!g_file_delete (etc_file, cancellable, error))\n                return FALSE;\n            }\n\n          if (!g_file_replace_contents (etc_file, \"\", 0, NULL, FALSE,\n                                        G_FILE_CREATE_REPLACE_DESTINATION,\n                                        NULL, cancellable, error))\n            return FALSE;\n        }\n\n      if (g_file_query_exists (etc_resolve_conf, cancellable) &&\n          !g_file_delete (etc_resolve_conf, cancellable, error))\n        return TRUE;\n\n      if (!g_file_make_symbolic_link (etc_resolve_conf,\n                                      \"/run/host/monitor/resolv.conf\",\n                                      cancellable, error))\n        return FALSE;\n    }\n\n  keyfile = g_key_file_new ();\n  metadata = g_file_get_child (checkoutdir, \"metadata\");\n  if (g_file_query_exists (metadata, cancellable))\n    {\n      g_autofree char *path = g_file_get_path (metadata);\n\n      if (!g_key_file_load_from_file (keyfile, path, G_KEY_FILE_NONE, error))\n        return FALSE;\n    }\n\n  export = g_file_get_child (checkoutdir, \"export\");\n  if (g_file_query_exists (export, cancellable))\n    {\n      g_auto(GStrv) ref_parts = NULL;\n\n      ref_parts = g_strsplit (ref, \"/\", -1);\n\n      if (!flatpak_rewrite_export_dir (ref_parts[1], ref_parts[3], ref_parts[2],\n                                       keyfile, export,\n                                       cancellable,\n                                       error))\n        return FALSE;\n    }\n\n  g_variant_builder_init (&metadata_builder, G_VARIANT_TYPE (\"a{sv}\"));\n  if (alt_id)\n    g_variant_builder_add (&metadata_builder, \"{s@v}\", \"alt-id\",\n                           g_variant_new_variant (g_variant_new_string (alt_id)));\n\n  deploy_data = flatpak_dir_new_deploy_data (origin,\n                                             checksum,\n                                             (char **) subpaths,\n                                             installed_size,\n                                             g_variant_builder_end (&metadata_builder));\n\n  deploy_data_file = g_file_get_child (checkoutdir, \"deploy\");\n  if (!flatpak_variant_save (deploy_data_file, deploy_data, cancellable, error))\n    return FALSE;\n\n  if (!glnx_opendirat (AT_FDCWD, checkoutdirpath, TRUE, &checkoutdir_dfd, error))\n    return FALSE;\n\n  if (syncfs (checkoutdir_dfd) != 0)\n    {\n      glnx_set_error_from_errno (error);\n      return FALSE;\n    }\n\n  if (!g_file_move (checkoutdir, real_checkoutdir, G_FILE_COPY_NO_FALLBACK_FOR_MOVE,\n                    cancellable, NULL, NULL, error))\n    return FALSE;\n\n  if (!flatpak_dir_set_active (self, ref, checkout_basename, cancellable, error))\n    return FALSE;\n\n  return TRUE;\n}",
        "func": "gboolean\nflatpak_dir_deploy (FlatpakDir          *self,\n                    const char          *origin,\n                    const char          *ref,\n                    const char          *checksum_or_latest,\n                    const char * const * subpaths,\n                    GVariant            *old_deploy_data,\n                    GCancellable        *cancellable,\n                    GError             **error)\n{\n  g_autofree char *resolved_ref = NULL;\n\n  g_autoptr(GFile) root = NULL;\n  g_autoptr(GFile) deploy_base = NULL;\n  g_autoptr(GFile) checkoutdir = NULL;\n  g_autofree char *checkoutdirpath = NULL;\n  g_autoptr(GFile) real_checkoutdir = NULL;\n  g_autoptr(GFile) dotref = NULL;\n  g_autoptr(GFile) files_etc = NULL;\n  g_autoptr(GFile) metadata = NULL;\n  g_autoptr(GFile) deploy_data_file = NULL;\n  g_autoptr(GVariant) deploy_data = NULL;\n  g_autoptr(GFile) export = NULL;\n  g_autoptr(GFile) extradir = NULL;\n  g_autoptr(GKeyFile) keyfile = NULL;\n  guint64 installed_size = 0;\n  OstreeRepoCheckoutAtOptions options = { 0, };\n  const char *checksum;\n  glnx_fd_close int checkoutdir_dfd = -1;\n  g_autoptr(GFile) tmp_dir_template = NULL;\n  g_autoptr(GVariant) commit_data = NULL;\n  g_autofree char *tmp_dir_path = NULL;\n  g_autofree char *alt_id = NULL;\n  const char *xa_metadata = NULL;\n  const char *xa_ref = NULL;\n  g_autofree char *checkout_basename = NULL;\n  gboolean created_extra_data = FALSE;\n  g_autoptr(GVariant) commit_metadata = NULL;\n  GVariantBuilder metadata_builder;\n\n  if (!flatpak_dir_ensure_repo (self, cancellable, error))\n    return FALSE;\n\n  deploy_base = flatpak_dir_get_deploy_dir (self, ref);\n\n  if (checksum_or_latest == NULL)\n    {\n      g_debug (\"No checksum specified, getting tip of %s\", ref);\n\n      resolved_ref = flatpak_dir_read_latest (self, origin, ref, NULL, cancellable, error);\n      if (resolved_ref == NULL)\n        {\n          g_prefix_error (error, _(\"While trying to resolve ref %s: \"), ref);\n          return FALSE;\n        }\n\n      checksum = resolved_ref;\n      g_debug (\"tip resolved to: %s\", checksum);\n    }\n  else\n    {\n      g_autoptr(GFile) root = NULL;\n      g_autofree char *commit = NULL;\n\n      checksum = checksum_or_latest;\n      g_debug (\"Looking for checksum %s in local repo\", checksum);\n      if (!ostree_repo_read_commit (self->repo, checksum, &root, &commit, cancellable, NULL))\n        return flatpak_fail (error, _(\"%s is not available\"), ref);\n    }\n\n  if (!ostree_repo_load_commit (self->repo, checksum, &commit_data, NULL, error))\n    return FALSE;\n\n  commit_metadata = g_variant_get_child_value (commit_data, 0);\n  g_variant_lookup (commit_metadata, \"xa.alt-id\", \"s\", &alt_id);\n\n  if (subpaths == NULL || *subpaths == NULL)\n    checkout_basename = g_strdup (checksum);\n  else\n    {\n      GString *str = g_string_new (checksum);\n      int i;\n      for (i = 0; subpaths[i] != NULL; i++)\n        {\n          const char *s = subpaths[i];\n          g_string_append_c (str, '-');\n          while (*s)\n            {\n              if (*s != '/')\n                g_string_append_c (str, *s);\n              s++;\n            }\n        }\n      checkout_basename = g_string_free (str, FALSE);\n    }\n\n  real_checkoutdir = g_file_get_child (deploy_base, checkout_basename);\n  if (g_file_query_exists (real_checkoutdir, cancellable))\n    {\n      g_set_error (error, FLATPAK_ERROR, FLATPAK_ERROR_ALREADY_INSTALLED,\n                   _(\"%s branch %s already installed\"), ref, checksum);\n      return FALSE;\n    }\n\n  g_autofree char *template = g_strdup_printf (\".%s-XXXXXX\", checkout_basename);\n  tmp_dir_template = g_file_get_child (deploy_base, template);\n  tmp_dir_path = g_file_get_path (tmp_dir_template);\n\n  if (g_mkdtemp_full (tmp_dir_path, 0755) == NULL)\n    {\n      g_set_error_literal (error, G_IO_ERROR, G_IO_ERROR_FAILED,\n                           _(\"Can't create deploy directory\"));\n      return FALSE;\n    }\n\n  checkoutdir = g_file_new_for_path (tmp_dir_path);\n\n  if (!ostree_repo_read_commit (self->repo, checksum, &root, NULL, cancellable, error))\n    {\n      g_prefix_error (error, _(\"Failed to read commit %s: \"), checksum);\n      return FALSE;\n    }\n\n  if (!flatpak_repo_collect_sizes (self->repo, root, &installed_size, NULL, cancellable, error))\n    return FALSE;\n\n  options.mode = OSTREE_REPO_CHECKOUT_MODE_USER;\n  options.overwrite_mode = OSTREE_REPO_CHECKOUT_OVERWRITE_UNION_FILES;\n  options.enable_fsync = FALSE; /* We checkout to a temp dir and sync before moving it in place */\n  options.bareuseronly_dirs = TRUE; /* https://github.com/ostreedev/ostree/pull/927 */\n  checkoutdirpath = g_file_get_path (checkoutdir);\n\n  if (subpaths == NULL || *subpaths == NULL)\n    {\n      if (!ostree_repo_checkout_at (self->repo, &options,\n                                    AT_FDCWD, checkoutdirpath,\n                                    checksum,\n                                    cancellable, error))\n        {\n          g_prefix_error (error, _(\"While trying to checkout %s into %s: \"), checksum, checkoutdirpath);\n          return FALSE;\n        }\n    }\n  else\n    {\n      g_autofree char *checkoutdirpath = g_file_get_path (checkoutdir);\n      g_autoptr(GFile) files = g_file_get_child (checkoutdir, \"files\");\n      g_autoptr(GFile) root = NULL;\n      g_autofree char *commit = NULL;\n      int i;\n\n      if (!g_file_make_directory_with_parents (files, cancellable, error))\n        return FALSE;\n\n      options.subpath = \"/metadata\";\n\n      if (!ostree_repo_read_commit (self->repo, checksum, &root,  &commit, cancellable, error))\n        return FALSE;\n\n      if (!ostree_repo_checkout_at (self->repo, &options,\n                                    AT_FDCWD, checkoutdirpath,\n                                    checksum,\n                                    cancellable, error))\n        {\n          g_prefix_error (error, _(\"While trying to checkout metadata subpath: \"));\n          return FALSE;\n        }\n\n      for (i = 0; subpaths[i] != NULL; i++)\n        {\n          g_autofree char *subpath = g_build_filename (\"/files\", subpaths[i], NULL);\n          g_autofree char *dstpath = g_build_filename (checkoutdirpath, \"/files\", subpaths[i], NULL);\n          g_autofree char *dstpath_parent = g_path_get_dirname (dstpath);\n          g_autoptr(GFile) child = NULL;\n\n          child = g_file_resolve_relative_path (root, subpath);\n\n          if (!g_file_query_exists (child, cancellable))\n            {\n              g_debug (\"subpath %s not in tree\", subpaths[i]);\n              continue;\n            }\n\n          if (g_mkdir_with_parents (dstpath_parent, 0755))\n            {\n              glnx_set_error_from_errno (error);\n              return FALSE;\n            }\n\n          options.subpath = subpath;\n          if (!ostree_repo_checkout_at (self->repo, &options,\n                                        AT_FDCWD, dstpath,\n                                        checksum,\n                                        cancellable, error))\n            {\n              g_prefix_error (error, _(\"While trying to checkout metadata subpath: \"));\n              return FALSE;\n            }\n        }\n    }\n\n  /* Extract any extra data */\n  extradir = g_file_resolve_relative_path (checkoutdir, \"files/extra\");\n  if (!flatpak_rm_rf (extradir, cancellable, error))\n    {\n      g_prefix_error (error, _(\"While trying to remove existing extra dir: \"));\n      return FALSE;\n    }\n\n  if (!extract_extra_data (self, checksum, extradir, &created_extra_data, cancellable, error))\n    return FALSE;\n\n  if (created_extra_data)\n    {\n      if (!apply_extra_data (self, checkoutdir, cancellable, error))\n        {\n          g_prefix_error (error, _(\"While trying to apply extra data: \"));\n          return FALSE;\n        }\n    }\n\n  g_variant_lookup (commit_metadata, \"xa.ref\", \"s\", &xa_ref);\n  if (xa_ref != NULL)\n    {\n      if (strcmp (ref, xa_ref) != 0)\n        {\n          g_set_error (error, G_IO_ERROR, G_IO_ERROR_PERMISSION_DENIED,\n                       _(\"Deployed ref %s does not match commit (%s)\"), ref, xa_ref);\n          return FALSE;\n        }\n    }\n\n  /* Check the metadata in the commit to make sure it matches the actual\n     deployed metadata, in case we relied on the one in the commit for\n     a decision */\n  g_variant_lookup (commit_metadata, \"xa.metadata\", \"s\", &xa_metadata);\n  if (xa_metadata != NULL)\n    {\n      g_autoptr(GFile) metadata_file = g_file_resolve_relative_path (checkoutdir, \"metadata\");\n      char *metadata_contents;\n\n      if (!g_file_load_contents (metadata_file, NULL,\n                                 &metadata_contents, NULL, NULL, NULL) ||\n          strcmp (metadata_contents, xa_metadata) != 0)\n        {\n          g_set_error (error, G_IO_ERROR, G_IO_ERROR_PERMISSION_DENIED,\n                       _(\"Deployed metadata does not match commit\"));\n          return FALSE;\n        }\n    }\n\n  dotref = g_file_resolve_relative_path (checkoutdir, \"files/.ref\");\n  if (!g_file_replace_contents (dotref, \"\", 0, NULL, FALSE,\n                                G_FILE_CREATE_REPLACE_DESTINATION, NULL, cancellable, error))\n    return TRUE;\n\n  /* Ensure that various files exists as regular files in /usr/etc, as we\n     want to bind-mount over them */\n  files_etc = g_file_resolve_relative_path (checkoutdir, \"files/etc\");\n  if (g_file_query_exists (files_etc, cancellable))\n    {\n      char *etcfiles[] = {\"passwd\", \"group\", \"machine-id\" };\n      g_autoptr(GFile) etc_resolve_conf = g_file_get_child (files_etc, \"resolv.conf\");\n      int i;\n      for (i = 0; i < G_N_ELEMENTS (etcfiles); i++)\n        {\n          g_autoptr(GFile) etc_file = g_file_get_child (files_etc, etcfiles[i]);\n          GFileType type;\n\n          type = g_file_query_file_type (etc_file, G_FILE_QUERY_INFO_NOFOLLOW_SYMLINKS,\n                                         cancellable);\n          if (type == G_FILE_TYPE_REGULAR)\n            continue;\n\n          if (type != G_FILE_TYPE_UNKNOWN)\n            {\n              /* Already exists, but not regular, probably symlink. Remove it */\n              if (!g_file_delete (etc_file, cancellable, error))\n                return FALSE;\n            }\n\n          if (!g_file_replace_contents (etc_file, \"\", 0, NULL, FALSE,\n                                        G_FILE_CREATE_REPLACE_DESTINATION,\n                                        NULL, cancellable, error))\n            return FALSE;\n        }\n\n      if (g_file_query_exists (etc_resolve_conf, cancellable) &&\n          !g_file_delete (etc_resolve_conf, cancellable, error))\n        return TRUE;\n\n      if (!g_file_make_symbolic_link (etc_resolve_conf,\n                                      \"/run/host/monitor/resolv.conf\",\n                                      cancellable, error))\n        return FALSE;\n    }\n\n  keyfile = g_key_file_new ();\n  metadata = g_file_get_child (checkoutdir, \"metadata\");\n  if (g_file_query_exists (metadata, cancellable))\n    {\n      g_autofree char *path = g_file_get_path (metadata);\n\n      if (!g_key_file_load_from_file (keyfile, path, G_KEY_FILE_NONE, error))\n        return FALSE;\n    }\n\n  export = g_file_get_child (checkoutdir, \"export\");\n  if (g_file_query_exists (export, cancellable))\n    {\n      g_auto(GStrv) ref_parts = NULL;\n\n      ref_parts = g_strsplit (ref, \"/\", -1);\n\n      if (!flatpak_rewrite_export_dir (ref_parts[1], ref_parts[3], ref_parts[2],\n                                       keyfile, export,\n                                       cancellable,\n                                       error))\n        return FALSE;\n    }\n\n  g_variant_builder_init (&metadata_builder, G_VARIANT_TYPE (\"a{sv}\"));\n  if (alt_id)\n    g_variant_builder_add (&metadata_builder, \"{s@v}\", \"alt-id\",\n                           g_variant_new_variant (g_variant_new_string (alt_id)));\n\n  deploy_data = flatpak_dir_new_deploy_data (origin,\n                                             checksum,\n                                             (char **) subpaths,\n                                             installed_size,\n                                             g_variant_builder_end (&metadata_builder));\n\n  deploy_data_file = g_file_get_child (checkoutdir, \"deploy\");\n  if (!flatpak_variant_save (deploy_data_file, deploy_data, cancellable, error))\n    return FALSE;\n\n  if (!glnx_opendirat (AT_FDCWD, checkoutdirpath, TRUE, &checkoutdir_dfd, error))\n    return FALSE;\n\n  if (syncfs (checkoutdir_dfd) != 0)\n    {\n      glnx_set_error_from_errno (error);\n      return FALSE;\n    }\n\n  if (!g_file_move (checkoutdir, real_checkoutdir, G_FILE_COPY_NO_FALLBACK_FOR_MOVE,\n                    cancellable, NULL, NULL, error))\n    return FALSE;\n\n  if (!flatpak_dir_set_active (self, ref, checkout_basename, cancellable, error))\n    return FALSE;\n\n  return TRUE;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -127,6 +127,7 @@\n   options.mode = OSTREE_REPO_CHECKOUT_MODE_USER;\n   options.overwrite_mode = OSTREE_REPO_CHECKOUT_OVERWRITE_UNION_FILES;\n   options.enable_fsync = FALSE; /* We checkout to a temp dir and sync before moving it in place */\n+  options.bareuseronly_dirs = TRUE; /* https://github.com/ostreedev/ostree/pull/927 */\n   checkoutdirpath = g_file_get_path (checkoutdir);\n \n   if (subpaths == NULL || *subpaths == NULL)",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "  options.bareuseronly_dirs = TRUE; /* https://github.com/ostreedev/ostree/pull/927 */"
            ]
        }
    },
    {
        "cve_id": "CVE-2017-7471",
        "func_name": "qemu/local_name_to_path",
        "description": "Quick Emulator (Qemu) built with the VirtFS, host directory sharing via Plan 9 File System (9pfs) support, is vulnerable to an improper access control issue. It could occur while accessing files on a shared host directory. A privileged user inside guest could use this flaw to access host file system beyond the shared folder and potentially escalating their privileges on a host.",
        "git_url": "https://github.com/qemu/qemu/commit/9c6b899f7a46893ab3b671e341a2234e9c0c060e",
        "commit_title": "9pfs: local: set the path of the export root to \".\"",
        "commit_text": " The local backend was recently converted to using \"at*()\" syscalls in order to ensure all accesses happen below the shared directory. This requires that we only pass relative paths, otherwise the dirfd argument to the \"at*()\" syscalls is ignored and the path is treated as an absolute path in the host. This is actually the case for paths in all fids, with the notable exception of the root fid, whose path is \"/\". This causes the following backend ops to act on the \"/\" directory of the host instead of the virtfs shared directory when the export root is involved: - lstat - chmod - chown - utimensat  ie, chmod /9p_mount_point in the guest will be converted to chmod / in the host for example. This could cause security issues with a privileged QEMU.  All \"*at()\" syscalls are being passed an open file descriptor. In the case of the export root, this file descriptor points to the path in the host that was passed to -fsdev.  The fix is thus as simple as changing the path of the export root fid to be \".\" instead of \"/\".  This is CVE-2017-7471.  Cc: qemu-stable@nongnu.org",
        "func_before": "static int local_name_to_path(FsContext *ctx, V9fsPath *dir_path,\n                              const char *name, V9fsPath *target)\n{\n    if (dir_path) {\n        v9fs_path_sprintf(target, \"%s/%s\", dir_path->data, name);\n    } else {\n        v9fs_path_sprintf(target, \"%s\", name);\n    }\n    return 0;\n}",
        "func": "static int local_name_to_path(FsContext *ctx, V9fsPath *dir_path,\n                              const char *name, V9fsPath *target)\n{\n    if (dir_path) {\n        v9fs_path_sprintf(target, \"%s/%s\", dir_path->data, name);\n    } else if (strcmp(name, \"/\")) {\n        v9fs_path_sprintf(target, \"%s\", name);\n    } else {\n        /* We want the path of the export root to be relative, otherwise\n         * \"*at()\" syscalls would treat it as \"/\" in the host.\n         */\n        v9fs_path_sprintf(target, \"%s\", \".\");\n    }\n    return 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,8 +3,13 @@\n {\n     if (dir_path) {\n         v9fs_path_sprintf(target, \"%s/%s\", dir_path->data, name);\n+    } else if (strcmp(name, \"/\")) {\n+        v9fs_path_sprintf(target, \"%s\", name);\n     } else {\n-        v9fs_path_sprintf(target, \"%s\", name);\n+        /* We want the path of the export root to be relative, otherwise\n+         * \"*at()\" syscalls would treat it as \"/\" in the host.\n+         */\n+        v9fs_path_sprintf(target, \"%s\", \".\");\n     }\n     return 0;\n }",
        "diff_line_info": {
            "deleted_lines": [
                "        v9fs_path_sprintf(target, \"%s\", name);"
            ],
            "added_lines": [
                "    } else if (strcmp(name, \"/\")) {",
                "        v9fs_path_sprintf(target, \"%s\", name);",
                "        /* We want the path of the export root to be relative, otherwise",
                "         * \"*at()\" syscalls would treat it as \"/\" in the host.",
                "         */",
                "        v9fs_path_sprintf(target, \"%s\", \".\");"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-14043",
        "func_name": "Monetra/mstdlib/M_fs_path_tmpdir",
        "description": "mstdlib (aka the M Standard Library for C) 1.2.0 has incorrect file access control in situations where M_fs_perms_can_access attempts to delete an existing file (that lacks public read/write access) during a copy operation, related to fs/m_fs.c and fs/m_fs_path.c. An attacker could create the file and then would have access to the data.",
        "git_url": "https://github.com/Monetra/mstdlib/commit/db124b8f607dd0a40a9aef2d4d468fad433522a7",
        "commit_title": "fs: Don't try to delete the file when copying. It could cause a security issue if the file exists and doesn't allow other's to read/write. delete could allow someone to create the file and have access to the data.",
        "commit_text": "",
        "func_before": "char *M_fs_path_tmpdir(M_fs_system_t sys_type)\n{\n\tchar         *d   = NULL;\n\tchar         *out = NULL;\n\tM_fs_error_t  res;\n\n#ifdef _WIN32\n\tsize_t len = M_fs_path_get_path_max(M_FS_SYSTEM_WINDOWS)+1;\n\td = M_malloc_zero(len);\n\t/* Return is length without NULL. */\n\tif (GetTempPath((DWORD)len, d) >= len) {\n\t\tM_free(d);\n\t\td = NULL;\n\t}\n#elif defined(__APPLE__)\n\td = M_fs_path_mac_tmpdir();\n#else\n\tconst char *const_temp;\n\t/* Try Unix env var. */\n#  ifdef HAVE_SECURE_GETENV\n\tconst_temp = secure_getenv(\"TMPDIR\");\n#  else\n\tconst_temp = getenv(\"TMPDIR\");\n#  endif\n\tif (!M_str_isempty(const_temp) && M_fs_perms_can_access(const_temp, M_FS_FILE_MODE_READ|M_FS_FILE_MODE_WRITE) == M_FS_ERROR_SUCCESS) {\n\t\td = M_strdup(const_temp);\n\t}\n\t/* Fallback to some \"standard\" system paths. */\n\tif (d == NULL) {\n\t\tconst_temp = \"/tmp\";\n\t\tif (!M_str_isempty(const_temp) && M_fs_perms_can_access(const_temp, M_FS_FILE_MODE_READ|M_FS_FILE_MODE_WRITE) == M_FS_ERROR_SUCCESS) {\n\t\t\td = M_strdup(const_temp);\n\t\t}\n\t}\n\tif (d == NULL) {\n\t\tconst_temp = \"/var/tmp\";\n\t\tif (!M_str_isempty(const_temp) && M_fs_perms_can_access(const_temp, M_FS_FILE_MODE_READ|M_FS_FILE_MODE_WRITE) == M_FS_ERROR_SUCCESS) {\n\t\t\td = M_strdup(const_temp);\n\t\t}\n\t}\n#endif\n\n\tif (d != NULL) {\n\t\tres = M_fs_path_norm(&out, d, M_FS_PATH_NORM_ABSOLUTE, sys_type);\n\t\tif (res != M_FS_ERROR_SUCCESS) {\n\t\t\tout = NULL;\n\t\t}\n\t}\n\tM_free(d);\n\n\treturn out;\n}",
        "func": "char *M_fs_path_tmpdir(M_fs_system_t sys_type)\n{\n\tchar         *d   = NULL;\n\tchar         *out = NULL;\n\tM_fs_error_t  res;\n\n#ifdef _WIN32\n\tsize_t len = M_fs_path_get_path_max(M_FS_SYSTEM_WINDOWS)+1;\n\td = M_malloc_zero(len);\n\t/* Return is length without NULL. */\n\tif (GetTempPath((DWORD)len, d) >= len) {\n\t\tM_free(d);\n\t\td = NULL;\n\t}\n#elif defined(__APPLE__)\n\td = M_fs_path_mac_tmpdir();\n#else\n\tconst char *const_temp;\n\t/* Unix doens't have a fancy function to get the standard\n\t * temporary directory an application can use. Instead there\n\t * is a convoluted set of possible paths that could be used.\n\t *\n\t * We're going to go though each one in a priority order and\n\t * verify if we can read and write the directory. If so then\n\t * that's the one that will be used. We are fine using access\n\t * here because it doesn't matter if the path ends up being\n\t * changed out from underneath us later on. When it's used\n\t * at that time it will fail. Right now we just want to get\n\t * a path that can be tried. */\n\n\t/* Try Unix env vars.\n\t *\n\t * This is not ideal but a valid way to set the temporary directory\n\t * for a user. Per Single Unix Specification 4 and probably other things.\n\t */\n#  ifdef HAVE_SECURE_GETENV\n\tconst_temp = secure_getenv(\"TMPDIR\");\n#  else\n\tconst_temp = getenv(\"TMPDIR\");\n#  endif\n\tif (!M_str_isempty(const_temp) && M_fs_perms_can_access(const_temp, M_FS_FILE_MODE_READ|M_FS_FILE_MODE_WRITE) == M_FS_ERROR_SUCCESS) {\n\t\td = M_strdup(const_temp);\n\t}\n\t/* Fallback to some \"standard\" system paths. */\n\tif (d == NULL) {\n\t\tconst_temp = \"/tmp\";\n\t\tif (!M_str_isempty(const_temp) && M_fs_perms_can_access(const_temp, M_FS_FILE_MODE_READ|M_FS_FILE_MODE_WRITE) == M_FS_ERROR_SUCCESS) {\n\t\t\td = M_strdup(const_temp);\n\t\t}\n\t}\n\tif (d == NULL) {\n\t\tconst_temp = \"/var/tmp\";\n\t\tif (!M_str_isempty(const_temp) && M_fs_perms_can_access(const_temp, M_FS_FILE_MODE_READ|M_FS_FILE_MODE_WRITE) == M_FS_ERROR_SUCCESS) {\n\t\t\td = M_strdup(const_temp);\n\t\t}\n\t}\n#endif\n\n\tif (d != NULL) {\n\t\tres = M_fs_path_norm(&out, d, M_FS_PATH_NORM_ABSOLUTE, sys_type);\n\t\tif (res != M_FS_ERROR_SUCCESS) {\n\t\t\tout = NULL;\n\t\t}\n\t}\n\tM_free(d);\n\n\treturn out;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -16,7 +16,23 @@\n \td = M_fs_path_mac_tmpdir();\n #else\n \tconst char *const_temp;\n-\t/* Try Unix env var. */\n+\t/* Unix doens't have a fancy function to get the standard\n+\t * temporary directory an application can use. Instead there\n+\t * is a convoluted set of possible paths that could be used.\n+\t *\n+\t * We're going to go though each one in a priority order and\n+\t * verify if we can read and write the directory. If so then\n+\t * that's the one that will be used. We are fine using access\n+\t * here because it doesn't matter if the path ends up being\n+\t * changed out from underneath us later on. When it's used\n+\t * at that time it will fail. Right now we just want to get\n+\t * a path that can be tried. */\n+\n+\t/* Try Unix env vars.\n+\t *\n+\t * This is not ideal but a valid way to set the temporary directory\n+\t * for a user. Per Single Unix Specification 4 and probably other things.\n+\t */\n #  ifdef HAVE_SECURE_GETENV\n \tconst_temp = secure_getenv(\"TMPDIR\");\n #  else",
        "diff_line_info": {
            "deleted_lines": [
                "\t/* Try Unix env var. */"
            ],
            "added_lines": [
                "\t/* Unix doens't have a fancy function to get the standard",
                "\t * temporary directory an application can use. Instead there",
                "\t * is a convoluted set of possible paths that could be used.",
                "\t *",
                "\t * We're going to go though each one in a priority order and",
                "\t * verify if we can read and write the directory. If so then",
                "\t * that's the one that will be used. We are fine using access",
                "\t * here because it doesn't matter if the path ends up being",
                "\t * changed out from underneath us later on. When it's used",
                "\t * at that time it will fail. Right now we just want to get",
                "\t * a path that can be tried. */",
                "",
                "\t/* Try Unix env vars.",
                "\t *",
                "\t * This is not ideal but a valid way to set the temporary directory",
                "\t * for a user. Per Single Unix Specification 4 and probably other things.",
                "\t */"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-14043",
        "func_name": "Monetra/mstdlib/M_fs_path_join_parts",
        "description": "mstdlib (aka the M Standard Library for C) 1.2.0 has incorrect file access control in situations where M_fs_perms_can_access attempts to delete an existing file (that lacks public read/write access) during a copy operation, related to fs/m_fs.c and fs/m_fs_path.c. An attacker could create the file and then would have access to the data.",
        "git_url": "https://github.com/Monetra/mstdlib/commit/db124b8f607dd0a40a9aef2d4d468fad433522a7",
        "commit_title": "fs: Don't try to delete the file when copying. It could cause a security issue if the file exists and doesn't allow other's to read/write. delete could allow someone to create the file and have access to the data.",
        "commit_text": "",
        "func_before": "char *M_fs_path_join_parts(const M_list_str_t *path, M_fs_system_t sys_type)\n{\n\tM_list_str_t *parts;\n\tconst char   *part;\n\tchar         *out;\n\tsize_t        len;\n\tsize_t        i;\n\tsize_t        count;\n\n\tif (path == NULL) {\n\t\treturn NULL;\n\t}\n\tlen = M_list_str_len(path);\n\tif (len == 0) {\n\t\treturn NULL;\n\t}\n\n\tsys_type = M_fs_path_get_system_type(sys_type);\n\n\t/* Remove any empty parts (except for the first part which denotes an abs path on Unix\n \t * or a UNC path on Windows). */\n\tparts = M_list_str_duplicate(path);\n\tfor (i=len-1; i>0; i--) {\n\t\tpart = M_list_str_at(parts, i);\n\t\tif (part == NULL || *part == '\\0') {\n\t\t\tM_list_str_remove_at(parts, i);\n\t\t}\n\t}\n\n\tlen = M_list_str_len(parts);\n\n\t/* Join puts the sep between items. If there are no items then the sep\n\t * won't be written. */\n\tpart = M_list_str_at(parts, 0);\n\tif (len == 1 && (part == NULL || *part == '\\0')) {\n\t\tM_list_str_destroy(parts);\n\t\tif (sys_type == M_FS_SYSTEM_WINDOWS) {\n\t\t\treturn M_strdup(\"\\\\\\\\\");\n\t\t}\n\t\treturn M_strdup(\"/\");\n\t}\n\n\t/* Handle windows abs path because they need two separators. */\n\tif (sys_type == M_FS_SYSTEM_WINDOWS && len > 0) {\n\t\tpart  = M_list_str_at(parts, 0);\n\t\t/* If we have 1 item we need to add two empties so we get the second separator. */\n\t\tcount = (len == 1) ? 2 : 1;\n\t\t/* If we're dealing with a unc path add the second sep so we get two separators for the UNC base. */\n\t\tif (part != NULL && *part == '\\0') {\n\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\tM_list_str_insert_at(parts, \"\", 0);\n\t\t\t}\n\t\t} else if (M_fs_path_isabs(part, sys_type) && len == 1) {\n\t\t\t/* We need to add an empty so we get a separator after the drive. */\n\t\t\tM_list_str_insert_at(parts, \"\", 1);\n\t\t}\n\t}\n\n\tout = M_list_str_join(parts, (unsigned char)M_fs_path_get_system_sep(sys_type));\n\tM_list_str_destroy(parts);\n\treturn out;\n}",
        "func": "char *M_fs_path_join_parts(const M_list_str_t *path, M_fs_system_t sys_type)\n{\n\tM_list_str_t *parts;\n\tconst char   *part;\n\tchar         *out;\n\tsize_t        len;\n\tsize_t        i;\n\tsize_t        count;\n\n\tif (path == NULL) {\n\t\treturn NULL;\n\t}\n\tlen = M_list_str_len(path);\n\tif (len == 0) {\n\t\treturn NULL;\n\t}\n\n\tsys_type = M_fs_path_get_system_type(sys_type);\n\n\t/* Remove any empty parts (except for the first part which denotes an abs path on Unix\n\t * or a UNC path on Windows). */\n\tparts = M_list_str_duplicate(path);\n\tfor (i=len-1; i>0; i--) {\n\t\tpart = M_list_str_at(parts, i);\n\t\tif (part == NULL || *part == '\\0') {\n\t\t\tM_list_str_remove_at(parts, i);\n\t\t}\n\t}\n\n\tlen = M_list_str_len(parts);\n\n\t/* Join puts the sep between items. If there are no items then the sep\n\t * won't be written. */\n\tpart = M_list_str_at(parts, 0);\n\tif (len == 1 && (part == NULL || *part == '\\0')) {\n\t\tM_list_str_destroy(parts);\n\t\tif (sys_type == M_FS_SYSTEM_WINDOWS) {\n\t\t\treturn M_strdup(\"\\\\\\\\\");\n\t\t}\n\t\treturn M_strdup(\"/\");\n\t}\n\n\t/* Handle windows abs path because they need two separators. */\n\tif (sys_type == M_FS_SYSTEM_WINDOWS && len > 0) {\n\t\tpart  = M_list_str_at(parts, 0);\n\t\t/* If we have 1 item we need to add two empties so we get the second separator. */\n\t\tcount = (len == 1) ? 2 : 1;\n\t\t/* If we're dealing with a unc path add the second sep so we get two separators for the UNC base. */\n\t\tif (part != NULL && *part == '\\0') {\n\t\t\tfor (i=0; i<count; i++) {\n\t\t\t\tM_list_str_insert_at(parts, \"\", 0);\n\t\t\t}\n\t\t} else if (M_fs_path_isabs(part, sys_type) && len == 1) {\n\t\t\t/* We need to add an empty so we get a separator after the drive. */\n\t\t\tM_list_str_insert_at(parts, \"\", 1);\n\t\t}\n\t}\n\n\tout = M_list_str_join(parts, (unsigned char)M_fs_path_get_system_sep(sys_type));\n\tM_list_str_destroy(parts);\n\treturn out;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -18,7 +18,7 @@\n \tsys_type = M_fs_path_get_system_type(sys_type);\n \n \t/* Remove any empty parts (except for the first part which denotes an abs path on Unix\n- \t * or a UNC path on Windows). */\n+\t * or a UNC path on Windows). */\n \tparts = M_list_str_duplicate(path);\n \tfor (i=len-1; i>0; i--) {\n \t\tpart = M_list_str_at(parts, i);",
        "diff_line_info": {
            "deleted_lines": [
                " \t * or a UNC path on Windows). */"
            ],
            "added_lines": [
                "\t * or a UNC path on Windows). */"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-14043",
        "func_name": "Monetra/mstdlib/M_fs_delete",
        "description": "mstdlib (aka the M Standard Library for C) 1.2.0 has incorrect file access control in situations where M_fs_perms_can_access attempts to delete an existing file (that lacks public read/write access) during a copy operation, related to fs/m_fs.c and fs/m_fs_path.c. An attacker could create the file and then would have access to the data.",
        "git_url": "https://github.com/Monetra/mstdlib/commit/db124b8f607dd0a40a9aef2d4d468fad433522a7",
        "commit_title": "fs: Don't try to delete the file when copying. It could cause a security issue if the file exists and doesn't allow other's to read/write. delete could allow someone to create the file and have access to the data.",
        "commit_text": "",
        "func_before": "M_fs_error_t M_fs_delete(const char *path, M_bool remove_children, M_fs_progress_cb_t cb, M_uint32 progress_flags)\n{\n\tchar                   *norm_path;\n\tchar                   *join_path;\n\tM_fs_dir_entries_t     *entries;\n\tconst M_fs_dir_entry_t *entry;\n\tM_fs_info_t            *info;\n\tM_fs_progress_t        *progress            = NULL;\n\tM_fs_dir_walk_filter_t  filter              = M_FS_DIR_WALK_FILTER_ALL|M_FS_DIR_WALK_FILTER_RECURSE;\n\tM_fs_type_t             type;\n\t/* The result that will be returned by this function. */\n\tM_fs_error_t            res;\n\t/* The result of the delete itself. */\n\tM_fs_error_t            res2;\n\tsize_t                  len;\n\tsize_t                  i;\n\tM_uint64                total_size          = 0;\n\tM_uint64                total_size_progress = 0;\n\tM_uint64                entry_size;\n\n\t/* Normalize the path we are going to delete so we have a valid path to pass around. */\n\tres = M_fs_path_norm(&norm_path, path, M_FS_PATH_NORM_HOME, M_FS_SYSTEM_AUTO);\n\tif (res != M_FS_ERROR_SUCCESS) {\n\t\tM_free(norm_path);\n\t\treturn res;\n\t}\n\n\t/* We need the info to determine if the path is valid and because we need the type. */\n\tres = M_fs_info(&info, norm_path, M_FS_PATH_INFO_FLAGS_BASIC);\n\tif (res != M_FS_ERROR_SUCCESS) {\n\t\tM_free(norm_path);\n\t\treturn res;\n\t}\n\n\t/* We must know the type because there are different functions for deleting a file and deleting a directory. */\n\ttype = M_fs_info_get_type(info);\n\tif (type == M_FS_TYPE_UNKNOWN) {\n\t\tM_fs_info_destroy(info);\n\t\tM_free(norm_path);\n\t\treturn M_FS_ERROR_GENERIC;\n\t}\n\n\t/* Create a list of entries to store all the places we need to delete. */\n\tentries = M_fs_dir_entries_create();\n\n\t/* Recursive directory deletion isn't intuitive. We have to generate a list of files and delete the list.\n \t * We cannot delete as walk because not all file systems support that operation. The walk; delete; behavior\n\t * is undefined in Posix and HFS is known to skip files if the directory contents is modifies as the\n\t * directory is being walked. */\n\tif (type == M_FS_TYPE_DIR && remove_children) {\n\t\t/* We need to read the basic info if the we need to report the size totals to the cb. */\n\t\tif (cb && progress_flags & (M_FS_PROGRESS_SIZE_TOTAL|M_FS_PROGRESS_SIZE_CUR)) {\n\t\t\tfilter |= M_FS_DIR_WALK_FILTER_READ_INFO_BASIC;\n\t\t}\n\t\tM_fs_dir_entries_merge(&entries, M_fs_dir_walk_entries(norm_path, NULL, filter));\n\t}\n\n\t/* Add the original path to the list of entries. This may be the only entry in the list. We need to add\n \t * it after a potential walk because we can't delete a directory that isn't empty.\n\t * Note: \n\t *   - The info will be owned by the entry and destroyed when it is destroyed. \n\t *   - The basic info param doesn't get the info in this case. it's set so the info is stored in the entry. */\n\tM_fs_dir_entries_insert(entries, M_fs_dir_walk_fill_entry(norm_path, NULL, type, info, M_FS_DIR_WALK_FILTER_READ_INFO_BASIC));\n\n\tlen = M_fs_dir_entries_len(entries);\n\tif (cb) {\n\t\t/* Create the progress. The same progress will be used for the entire operation. It will be updated with\n \t\t * new info as necessary. */\n\t\tprogress = M_fs_progress_create();\n\n\t\t/* Get the total size of all files to be deleted if using the progress cb and size totals is set. */\n\t\tif (progress_flags & M_FS_PROGRESS_SIZE_TOTAL) {\n\t\t\tfor (i=0; i<len; i++) {\n\t\t\t\tentry       = M_fs_dir_entries_at(entries, i);\n\t\t\t\tentry_size  = M_fs_info_get_size(M_fs_dir_entry_get_info(entry));\n\t\t\t\ttotal_size += entry_size;\n\t\t\t}\n\t\t\t/* Change the progress total size to reflect all entries. */\n\t\t\tM_fs_progress_set_size_total(progress, total_size);\n\t\t}\n\t\t/* Change the progress count to reflect the count. */\n\t\tif (progress_flags & M_FS_PROGRESS_COUNT) {\n\t\t\tM_fs_progress_set_count_total(progress, len);\n\t\t}\n\t}\n\n\t/* Assume success. Set error if there is an error. */\n\tres = M_FS_ERROR_SUCCESS;\n\t/* Loop though all entries and delete. */\n\tfor (i=0; i<len; i++) {\n\t\tentry     = M_fs_dir_entries_at(entries, i);\n\t\tjoin_path = M_fs_path_join(norm_path, M_fs_dir_entry_get_name(entry), M_FS_SYSTEM_AUTO);\n\t\t/* Call the appropriate delete function. */\n\t\tif (M_fs_dir_entry_get_type(entry) == M_FS_TYPE_DIR) {\n\t\t\tres2 = M_fs_delete_dir(join_path);\n\t\t} else {\n\t\t\tres2 = M_fs_delete_file(join_path);\n\t\t}\n\t\t/* Set the return result to denote there was an error. The real error will be sent via the\n\t\t * progress callback for the entry. */\n\t\tif (res2 != M_FS_ERROR_SUCCESS) {\n\t\t\tres = M_FS_ERROR_GENERIC;\n\t\t}\n\t\t/* Set the progress data for the entry. */\n\t\tif (cb) {\n\t\t\tentry_size           = M_fs_info_get_size(M_fs_dir_entry_get_info(entry));\n\t\t\ttotal_size_progress += entry_size;\n\n\t\t\tM_fs_progress_set_path(progress, join_path);\n\t\t\tM_fs_progress_set_type(progress, M_fs_dir_entry_get_type(entry));\n\t\t\tM_fs_progress_set_result(progress, res2);\n\t\t\tif (progress_flags & M_FS_PROGRESS_COUNT) {\n\t\t\t\tM_fs_progress_set_count(progress, i+1);\n\t\t\t}\n\t\t\tif (progress_flags & M_FS_PROGRESS_SIZE_TOTAL) {\n\t\t\t\tM_fs_progress_set_size_total_progess(progress, total_size_progress);\n\t\t\t}\n\t\t\tif (progress_flags & M_FS_PROGRESS_SIZE_CUR) {\n\t\t\t\tM_fs_progress_set_size_current(progress, entry_size);\n\t\t\t\tM_fs_progress_set_size_current_progress(progress, entry_size);\n\t\t\t}\n\t\t}\n\t\tM_free(join_path);\n\t\t/* Call the callback and stop processing if requested. */\n\t\tif (cb && !cb(progress)) {\n\t\t\tres = M_FS_ERROR_CANCELED;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tM_fs_dir_entries_destroy(entries);\n\tM_fs_progress_destroy(progress);\n\tM_free(norm_path);\n\treturn res;\n}",
        "func": "M_fs_error_t M_fs_delete(const char *path, M_bool remove_children, M_fs_progress_cb_t cb, M_uint32 progress_flags)\n{\n\tchar                   *norm_path;\n\tchar                   *join_path;\n\tM_fs_dir_entries_t     *entries;\n\tconst M_fs_dir_entry_t *entry;\n\tM_fs_info_t            *info;\n\tM_fs_progress_t        *progress            = NULL;\n\tM_fs_dir_walk_filter_t  filter              = M_FS_DIR_WALK_FILTER_ALL|M_FS_DIR_WALK_FILTER_RECURSE;\n\tM_fs_type_t             type;\n\t/* The result that will be returned by this function. */\n\tM_fs_error_t            res;\n\t/* The result of the delete itself. */\n\tM_fs_error_t            res2;\n\tsize_t                  len;\n\tsize_t                  i;\n\tM_uint64                total_size          = 0;\n\tM_uint64                total_size_progress = 0;\n\tM_uint64                entry_size;\n\n\t/* Normalize the path we are going to delete so we have a valid path to pass around. */\n\tres = M_fs_path_norm(&norm_path, path, M_FS_PATH_NORM_HOME, M_FS_SYSTEM_AUTO);\n\tif (res != M_FS_ERROR_SUCCESS) {\n\t\tM_free(norm_path);\n\t\treturn res;\n\t}\n\n\t/* We need the info to determine if the path is valid and because we need the type. */\n\tres = M_fs_info(&info, norm_path, M_FS_PATH_INFO_FLAGS_BASIC);\n\tif (res != M_FS_ERROR_SUCCESS) {\n\t\tM_free(norm_path);\n\t\treturn res;\n\t}\n\n\t/* We must know the type because there are different functions for deleting a file and deleting a directory. */\n\ttype = M_fs_info_get_type(info);\n\tif (type == M_FS_TYPE_UNKNOWN) {\n\t\tM_fs_info_destroy(info);\n\t\tM_free(norm_path);\n\t\treturn M_FS_ERROR_GENERIC;\n\t}\n\n\t/* Create a list of entries to store all the places we need to delete. */\n\tentries = M_fs_dir_entries_create();\n\n\t/* Recursive directory deletion isn't intuitive. We have to generate a list of files and delete the list.\n\t * We cannot delete as walk because not all file systems support that operation. The walk; delete; behavior\n\t * is undefined in Posix and HFS is known to skip files if the directory contents is modifies as the\n\t * directory is being walked. */\n\tif (type == M_FS_TYPE_DIR && remove_children) {\n\t\t/* We need to read the basic info if the we need to report the size totals to the cb. */\n\t\tif (cb && progress_flags & (M_FS_PROGRESS_SIZE_TOTAL|M_FS_PROGRESS_SIZE_CUR)) {\n\t\t\tfilter |= M_FS_DIR_WALK_FILTER_READ_INFO_BASIC;\n\t\t}\n\t\tM_fs_dir_entries_merge(&entries, M_fs_dir_walk_entries(norm_path, NULL, filter));\n\t}\n\n\t/* Add the original path to the list of entries. This may be the only entry in the list. We need to add\n\t * it after a potential walk because we can't delete a directory that isn't empty.\n\t * Note: \n\t *   - The info will be owned by the entry and destroyed when it is destroyed. \n\t *   - The basic info param doesn't get the info in this case. it's set so the info is stored in the entry. */\n\tM_fs_dir_entries_insert(entries, M_fs_dir_walk_fill_entry(norm_path, NULL, type, info, M_FS_DIR_WALK_FILTER_READ_INFO_BASIC));\n\n\tlen = M_fs_dir_entries_len(entries);\n\tif (cb) {\n\t\t/* Create the progress. The same progress will be used for the entire operation. It will be updated with\n\t\t * new info as necessary. */\n\t\tprogress = M_fs_progress_create();\n\n\t\t/* Get the total size of all files to be deleted if using the progress cb and size totals is set. */\n\t\tif (progress_flags & M_FS_PROGRESS_SIZE_TOTAL) {\n\t\t\tfor (i=0; i<len; i++) {\n\t\t\t\tentry       = M_fs_dir_entries_at(entries, i);\n\t\t\t\tentry_size  = M_fs_info_get_size(M_fs_dir_entry_get_info(entry));\n\t\t\t\ttotal_size += entry_size;\n\t\t\t}\n\t\t\t/* Change the progress total size to reflect all entries. */\n\t\t\tM_fs_progress_set_size_total(progress, total_size);\n\t\t}\n\t\t/* Change the progress count to reflect the count. */\n\t\tif (progress_flags & M_FS_PROGRESS_COUNT) {\n\t\t\tM_fs_progress_set_count_total(progress, len);\n\t\t}\n\t}\n\n\t/* Assume success. Set error if there is an error. */\n\tres = M_FS_ERROR_SUCCESS;\n\t/* Loop though all entries and delete. */\n\tfor (i=0; i<len; i++) {\n\t\tentry     = M_fs_dir_entries_at(entries, i);\n\t\tjoin_path = M_fs_path_join(norm_path, M_fs_dir_entry_get_name(entry), M_FS_SYSTEM_AUTO);\n\t\t/* Call the appropriate delete function. */\n\t\tif (M_fs_dir_entry_get_type(entry) == M_FS_TYPE_DIR) {\n\t\t\tres2 = M_fs_delete_dir(join_path);\n\t\t} else {\n\t\t\tres2 = M_fs_delete_file(join_path);\n\t\t}\n\t\t/* Set the return result to denote there was an error. The real error will be sent via the\n\t\t * progress callback for the entry. */\n\t\tif (res2 != M_FS_ERROR_SUCCESS) {\n\t\t\tres = M_FS_ERROR_GENERIC;\n\t\t}\n\t\t/* Set the progress data for the entry. */\n\t\tif (cb) {\n\t\t\tentry_size           = M_fs_info_get_size(M_fs_dir_entry_get_info(entry));\n\t\t\ttotal_size_progress += entry_size;\n\n\t\t\tM_fs_progress_set_path(progress, join_path);\n\t\t\tM_fs_progress_set_type(progress, M_fs_dir_entry_get_type(entry));\n\t\t\tM_fs_progress_set_result(progress, res2);\n\t\t\tif (progress_flags & M_FS_PROGRESS_COUNT) {\n\t\t\t\tM_fs_progress_set_count(progress, i+1);\n\t\t\t}\n\t\t\tif (progress_flags & M_FS_PROGRESS_SIZE_TOTAL) {\n\t\t\t\tM_fs_progress_set_size_total_progess(progress, total_size_progress);\n\t\t\t}\n\t\t\tif (progress_flags & M_FS_PROGRESS_SIZE_CUR) {\n\t\t\t\tM_fs_progress_set_size_current(progress, entry_size);\n\t\t\t\tM_fs_progress_set_size_current_progress(progress, entry_size);\n\t\t\t}\n\t\t}\n\t\tM_free(join_path);\n\t\t/* Call the callback and stop processing if requested. */\n\t\tif (cb && !cb(progress)) {\n\t\t\tres = M_FS_ERROR_CANCELED;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tM_fs_dir_entries_destroy(entries);\n\tM_fs_progress_destroy(progress);\n\tM_free(norm_path);\n\treturn res;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -44,7 +44,7 @@\n \tentries = M_fs_dir_entries_create();\n \n \t/* Recursive directory deletion isn't intuitive. We have to generate a list of files and delete the list.\n- \t * We cannot delete as walk because not all file systems support that operation. The walk; delete; behavior\n+\t * We cannot delete as walk because not all file systems support that operation. The walk; delete; behavior\n \t * is undefined in Posix and HFS is known to skip files if the directory contents is modifies as the\n \t * directory is being walked. */\n \tif (type == M_FS_TYPE_DIR && remove_children) {\n@@ -56,7 +56,7 @@\n \t}\n \n \t/* Add the original path to the list of entries. This may be the only entry in the list. We need to add\n- \t * it after a potential walk because we can't delete a directory that isn't empty.\n+\t * it after a potential walk because we can't delete a directory that isn't empty.\n \t * Note: \n \t *   - The info will be owned by the entry and destroyed when it is destroyed. \n \t *   - The basic info param doesn't get the info in this case. it's set so the info is stored in the entry. */\n@@ -65,7 +65,7 @@\n \tlen = M_fs_dir_entries_len(entries);\n \tif (cb) {\n \t\t/* Create the progress. The same progress will be used for the entire operation. It will be updated with\n- \t\t * new info as necessary. */\n+\t\t * new info as necessary. */\n \t\tprogress = M_fs_progress_create();\n \n \t\t/* Get the total size of all files to be deleted if using the progress cb and size totals is set. */",
        "diff_line_info": {
            "deleted_lines": [
                " \t * We cannot delete as walk because not all file systems support that operation. The walk; delete; behavior",
                " \t * it after a potential walk because we can't delete a directory that isn't empty.",
                " \t\t * new info as necessary. */"
            ],
            "added_lines": [
                "\t * We cannot delete as walk because not all file systems support that operation. The walk; delete; behavior",
                "\t * it after a potential walk because we can't delete a directory that isn't empty.",
                "\t\t * new info as necessary. */"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-14043",
        "func_name": "Monetra/mstdlib/M_fs_move",
        "description": "mstdlib (aka the M Standard Library for C) 1.2.0 has incorrect file access control in situations where M_fs_perms_can_access attempts to delete an existing file (that lacks public read/write access) during a copy operation, related to fs/m_fs.c and fs/m_fs_path.c. An attacker could create the file and then would have access to the data.",
        "git_url": "https://github.com/Monetra/mstdlib/commit/db124b8f607dd0a40a9aef2d4d468fad433522a7",
        "commit_title": "fs: Don't try to delete the file when copying. It could cause a security issue if the file exists and doesn't allow other's to read/write. delete could allow someone to create the file and have access to the data.",
        "commit_text": "",
        "func_before": "M_fs_error_t M_fs_move(const char *path_old, const char *path_new, M_uint32 mode, M_fs_progress_cb_t cb, M_uint32 progress_flags)\n{\n\tchar            *norm_path_old;\n\tchar            *norm_path_new;\n\tchar            *resolve_path;\n\tM_fs_info_t     *info;\n\tM_fs_progress_t *progress      = NULL;\n\tM_uint64         entry_size;\n\tM_fs_error_t     res;\n\n\tif (path_old == NULL || *path_old == '\\0' || path_new == NULL || *path_new == '\\0') {\n\t\treturn M_FS_ERROR_INVALID;\n\t}\n\n\t/* It's okay if new path doesn't exist. */\n\tres = M_fs_path_norm(&norm_path_new, path_new, M_FS_PATH_NORM_RESDIR, M_FS_SYSTEM_AUTO);\n\tif (res != M_FS_ERROR_SUCCESS) {\n\t\tM_free(norm_path_new);\n\t\treturn res;\n\t}\n\n\t/* If a path is a file and the destination is a directory the file should be moved \n\t * into the directory. E.g. /file.txt -> /dir = /dir/file.txt */\n\tif (M_fs_isfileintodir(path_old, path_new, &norm_path_old)) {\n\t\tM_free(norm_path_new);\n\t\tres = M_fs_move(path_old, norm_path_old, mode, cb, progress_flags);\n\t\tM_free(norm_path_old);\n\t\treturn res;\n\t}\n\n\t/* Normalize the old path and do basic checks that it exists. We'll leave really checking that the old path\n \t * existing to rename because any check we perform may not be true when rename is called. */\n\tres = M_fs_path_norm(&norm_path_old, path_old, M_FS_PATH_NORM_RESALL, M_FS_SYSTEM_AUTO);\n\tif (res != M_FS_ERROR_SUCCESS) {\n\t\tM_free(norm_path_new);\n\t\tM_free(norm_path_old);\n\t\treturn res;\n\t}\n\n\tprogress = M_fs_progress_create();\n\n\tres = M_fs_info(&info, path_old, (mode & M_FS_FILE_MODE_PRESERVE_PERMS)?M_FS_PATH_INFO_FLAGS_NONE:M_FS_PATH_INFO_FLAGS_BASIC);\n\tif (res != M_FS_ERROR_SUCCESS) {\n\t\tM_fs_progress_destroy(progress);\n\t\tM_free(norm_path_new);\n\t\tM_free(norm_path_old);\n\t\treturn res;\n\t}\n\n \t/* There is a race condition where the path could not exist but be created between the exists check and calling\n\t * rename to move the file but there isn't much we can do in this case. copy will delete and the file so this\n\t * situation won't cause an error. */\n\tif (!M_fs_check_overwrite_allowed(norm_path_old, norm_path_new, mode)) {\n\t\tM_fs_progress_destroy(progress);\n\t\tM_free(norm_path_new);\n\t\tM_free(norm_path_old);\n\t\treturn M_FS_ERROR_FILE_EXISTS;\n\t}\n\n\tif (cb) {\n\t\tentry_size = M_fs_info_get_size(info);\n\n\t\tM_fs_progress_set_path(progress, norm_path_new);\n\t\tM_fs_progress_set_type(progress, M_fs_info_get_type(info));\n\t\tif (progress_flags & M_FS_PROGRESS_SIZE_TOTAL) {\n\t\t\tM_fs_progress_set_size_total(progress, entry_size);\n\t\t\tM_fs_progress_set_size_total_progess(progress, entry_size);\n\t\t}\n\t\tif (progress_flags & M_FS_PROGRESS_SIZE_CUR) {\n\t\t\tM_fs_progress_set_size_current(progress, entry_size);\n\t\t\tM_fs_progress_set_size_current_progress(progress, entry_size);\n\t\t}\n\t\t/* Change the progress count to reflect the count. */\n\t\tif (progress_flags & M_FS_PROGRESS_COUNT) {\n\t\t\tM_fs_progress_set_count_total(progress, 1);\n\t\t\tM_fs_progress_set_count(progress, 1);\n\t\t}\n\t}\n\n\t/* Move the file. */\n\tif (M_fs_info_get_type(info) == M_FS_TYPE_SYMLINK) {\n\t\tres = M_fs_path_readlink(&resolve_path, norm_path_old);\n\t\tif (res == M_FS_ERROR_SUCCESS) {\n\t\t\tres = M_fs_symlink(norm_path_new, resolve_path);\n\t\t}\n\t\tM_free(resolve_path);\n\t} else {\n\t\tres = M_fs_move_file(norm_path_old, norm_path_new);\n\t}\n\t/* Failure was because we're crossing mount points. */\n\tif (res == M_FS_ERROR_NOT_SAMEDEV) {\n\t\t/* Can't rename so copy and delete. */\n\t\tif (M_fs_copy(norm_path_old, norm_path_new, mode, cb, progress_flags) == M_FS_ERROR_SUCCESS) {\n\t\t\t/* Success - Delete the original files since this is a move. */\n\t\t\tres = M_fs_delete(norm_path_old, M_TRUE, NULL, M_FS_PROGRESS_NOEXTRA);\n\t\t} else {\n\t\t\t/* Failure - Delete the new files that were copied but only if we are not overwriting. We don't\n \t\t\t * want to remove any existing files (especially if the dest is a dir). */\n\t\t\tif (!(mode & M_FS_FILE_MODE_OVERWRITE)) {\n\t\t\t\tM_fs_delete(norm_path_new, M_TRUE, NULL, M_FS_PROGRESS_NOEXTRA);\n\t\t\t}\n\t\t\tres = M_FS_ERROR_GENERIC;\n\t\t}\n\t} else {\n\t\t/* Call the cb with the result of the move whether it was a success for fail. We call the cb only if the\n \t\t * result of the move is not M_FS_ERROR_NOT_SAMEDEV because the copy operation will call the cb for us. */\n\t\tif (cb) {\n\t\t\tM_fs_progress_set_result(progress, res);\n\t\t\tif (!cb(progress)) {\n\t\t\t\tres = M_FS_ERROR_CANCELED;\n\t\t\t}\n\t\t}\n\t}\n\n\tM_fs_info_destroy(info);\n\tM_fs_progress_destroy(progress);\n\tM_free(norm_path_new);\n\tM_free(norm_path_old);\n\n\treturn res;\n}",
        "func": "M_fs_error_t M_fs_move(const char *path_old, const char *path_new, M_uint32 mode, M_fs_progress_cb_t cb, M_uint32 progress_flags)\n{\n\tchar            *norm_path_old;\n\tchar            *norm_path_new;\n\tchar            *resolve_path;\n\tM_fs_info_t     *info;\n\tM_fs_progress_t *progress      = NULL;\n\tM_uint64         entry_size;\n\tM_fs_error_t     res;\n\n\tif (path_old == NULL || *path_old == '\\0' || path_new == NULL || *path_new == '\\0') {\n\t\treturn M_FS_ERROR_INVALID;\n\t}\n\n\t/* It's okay if new path doesn't exist. */\n\tres = M_fs_path_norm(&norm_path_new, path_new, M_FS_PATH_NORM_RESDIR, M_FS_SYSTEM_AUTO);\n\tif (res != M_FS_ERROR_SUCCESS) {\n\t\tM_free(norm_path_new);\n\t\treturn res;\n\t}\n\n\t/* If a path is a file and the destination is a directory the file should be moved \n\t * into the directory. E.g. /file.txt -> /dir = /dir/file.txt */\n\tif (M_fs_isfileintodir(path_old, path_new, &norm_path_old)) {\n\t\tM_free(norm_path_new);\n\t\tres = M_fs_move(path_old, norm_path_old, mode, cb, progress_flags);\n\t\tM_free(norm_path_old);\n\t\treturn res;\n\t}\n\n\t/* Normalize the old path and do basic checks that it exists. We'll leave really checking that the old path\n\t * existing to rename because any check we perform may not be true when rename is called. */\n\tres = M_fs_path_norm(&norm_path_old, path_old, M_FS_PATH_NORM_RESALL, M_FS_SYSTEM_AUTO);\n\tif (res != M_FS_ERROR_SUCCESS) {\n\t\tM_free(norm_path_new);\n\t\tM_free(norm_path_old);\n\t\treturn res;\n\t}\n\n\tprogress = M_fs_progress_create();\n\n\tres = M_fs_info(&info, path_old, (mode & M_FS_FILE_MODE_PRESERVE_PERMS)?M_FS_PATH_INFO_FLAGS_NONE:M_FS_PATH_INFO_FLAGS_BASIC);\n\tif (res != M_FS_ERROR_SUCCESS) {\n\t\tM_fs_progress_destroy(progress);\n\t\tM_free(norm_path_new);\n\t\tM_free(norm_path_old);\n\t\treturn res;\n\t}\n\n\t/* There is a race condition where the path could not exist but be created between the exists check and calling\n\t * rename to move the file but there isn't much we can do in this case. copy will delete and the file so this\n\t * situation won't cause an error. */\n\tif (!M_fs_check_overwrite_allowed(norm_path_old, norm_path_new, mode)) {\n\t\tM_fs_progress_destroy(progress);\n\t\tM_free(norm_path_new);\n\t\tM_free(norm_path_old);\n\t\treturn M_FS_ERROR_FILE_EXISTS;\n\t}\n\n\tif (cb) {\n\t\tentry_size = M_fs_info_get_size(info);\n\n\t\tM_fs_progress_set_path(progress, norm_path_new);\n\t\tM_fs_progress_set_type(progress, M_fs_info_get_type(info));\n\t\tif (progress_flags & M_FS_PROGRESS_SIZE_TOTAL) {\n\t\t\tM_fs_progress_set_size_total(progress, entry_size);\n\t\t\tM_fs_progress_set_size_total_progess(progress, entry_size);\n\t\t}\n\t\tif (progress_flags & M_FS_PROGRESS_SIZE_CUR) {\n\t\t\tM_fs_progress_set_size_current(progress, entry_size);\n\t\t\tM_fs_progress_set_size_current_progress(progress, entry_size);\n\t\t}\n\t\t/* Change the progress count to reflect the count. */\n\t\tif (progress_flags & M_FS_PROGRESS_COUNT) {\n\t\t\tM_fs_progress_set_count_total(progress, 1);\n\t\t\tM_fs_progress_set_count(progress, 1);\n\t\t}\n\t}\n\n\t/* Move the file. */\n\tif (M_fs_info_get_type(info) == M_FS_TYPE_SYMLINK) {\n\t\tres = M_fs_path_readlink(&resolve_path, norm_path_old);\n\t\tif (res == M_FS_ERROR_SUCCESS) {\n\t\t\tres = M_fs_symlink(norm_path_new, resolve_path);\n\t\t}\n\t\tM_free(resolve_path);\n\t} else {\n\t\tres = M_fs_move_file(norm_path_old, norm_path_new);\n\t}\n\t/* Failure was because we're crossing mount points. */\n\tif (res == M_FS_ERROR_NOT_SAMEDEV) {\n\t\t/* Can't rename so copy and delete. */\n\t\tif (M_fs_copy(norm_path_old, norm_path_new, mode, cb, progress_flags) == M_FS_ERROR_SUCCESS) {\n\t\t\t/* Success - Delete the original files since this is a move. */\n\t\t\tres = M_fs_delete(norm_path_old, M_TRUE, NULL, M_FS_PROGRESS_NOEXTRA);\n\t\t} else {\n\t\t\t/* Failure - Delete the new files that were copied but only if we are not overwriting. We don't\n\t\t\t * want to remove any existing files (especially if the dest is a dir). */\n\t\t\tif (!(mode & M_FS_FILE_MODE_OVERWRITE)) {\n\t\t\t\tM_fs_delete(norm_path_new, M_TRUE, NULL, M_FS_PROGRESS_NOEXTRA);\n\t\t\t}\n\t\t\tres = M_FS_ERROR_GENERIC;\n\t\t}\n\t} else {\n\t\t/* Call the cb with the result of the move whether it was a success for fail. We call the cb only if the\n\t\t * result of the move is not M_FS_ERROR_NOT_SAMEDEV because the copy operation will call the cb for us. */\n\t\tif (cb) {\n\t\t\tM_fs_progress_set_result(progress, res);\n\t\t\tif (!cb(progress)) {\n\t\t\t\tres = M_FS_ERROR_CANCELED;\n\t\t\t}\n\t\t}\n\t}\n\n\tM_fs_info_destroy(info);\n\tM_fs_progress_destroy(progress);\n\tM_free(norm_path_new);\n\tM_free(norm_path_old);\n\n\treturn res;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -29,7 +29,7 @@\n \t}\n \n \t/* Normalize the old path and do basic checks that it exists. We'll leave really checking that the old path\n- \t * existing to rename because any check we perform may not be true when rename is called. */\n+\t * existing to rename because any check we perform may not be true when rename is called. */\n \tres = M_fs_path_norm(&norm_path_old, path_old, M_FS_PATH_NORM_RESALL, M_FS_SYSTEM_AUTO);\n \tif (res != M_FS_ERROR_SUCCESS) {\n \t\tM_free(norm_path_new);\n@@ -47,7 +47,7 @@\n \t\treturn res;\n \t}\n \n- \t/* There is a race condition where the path could not exist but be created between the exists check and calling\n+\t/* There is a race condition where the path could not exist but be created between the exists check and calling\n \t * rename to move the file but there isn't much we can do in this case. copy will delete and the file so this\n \t * situation won't cause an error. */\n \tif (!M_fs_check_overwrite_allowed(norm_path_old, norm_path_new, mode)) {\n@@ -95,7 +95,7 @@\n \t\t\tres = M_fs_delete(norm_path_old, M_TRUE, NULL, M_FS_PROGRESS_NOEXTRA);\n \t\t} else {\n \t\t\t/* Failure - Delete the new files that were copied but only if we are not overwriting. We don't\n- \t\t\t * want to remove any existing files (especially if the dest is a dir). */\n+\t\t\t * want to remove any existing files (especially if the dest is a dir). */\n \t\t\tif (!(mode & M_FS_FILE_MODE_OVERWRITE)) {\n \t\t\t\tM_fs_delete(norm_path_new, M_TRUE, NULL, M_FS_PROGRESS_NOEXTRA);\n \t\t\t}\n@@ -103,7 +103,7 @@\n \t\t}\n \t} else {\n \t\t/* Call the cb with the result of the move whether it was a success for fail. We call the cb only if the\n- \t\t * result of the move is not M_FS_ERROR_NOT_SAMEDEV because the copy operation will call the cb for us. */\n+\t\t * result of the move is not M_FS_ERROR_NOT_SAMEDEV because the copy operation will call the cb for us. */\n \t\tif (cb) {\n \t\t\tM_fs_progress_set_result(progress, res);\n \t\t\tif (!cb(progress)) {",
        "diff_line_info": {
            "deleted_lines": [
                " \t * existing to rename because any check we perform may not be true when rename is called. */",
                " \t/* There is a race condition where the path could not exist but be created between the exists check and calling",
                " \t\t\t * want to remove any existing files (especially if the dest is a dir). */",
                " \t\t * result of the move is not M_FS_ERROR_NOT_SAMEDEV because the copy operation will call the cb for us. */"
            ],
            "added_lines": [
                "\t * existing to rename because any check we perform may not be true when rename is called. */",
                "\t/* There is a race condition where the path could not exist but be created between the exists check and calling",
                "\t\t\t * want to remove any existing files (especially if the dest is a dir). */",
                "\t\t * result of the move is not M_FS_ERROR_NOT_SAMEDEV because the copy operation will call the cb for us. */"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-14043",
        "func_name": "Monetra/mstdlib/M_fs_copy",
        "description": "mstdlib (aka the M Standard Library for C) 1.2.0 has incorrect file access control in situations where M_fs_perms_can_access attempts to delete an existing file (that lacks public read/write access) during a copy operation, related to fs/m_fs.c and fs/m_fs_path.c. An attacker could create the file and then would have access to the data.",
        "git_url": "https://github.com/Monetra/mstdlib/commit/db124b8f607dd0a40a9aef2d4d468fad433522a7",
        "commit_title": "fs: Don't try to delete the file when copying. It could cause a security issue if the file exists and doesn't allow other's to read/write. delete could allow someone to create the file and have access to the data.",
        "commit_text": "",
        "func_before": "M_fs_error_t M_fs_copy(const char *path_old, const char *path_new, M_uint32 mode, M_fs_progress_cb_t cb, M_uint32 progress_flags)\n{\n\tchar                   *norm_path_old;\n\tchar                   *norm_path_new;\n\tchar                   *join_path_old;\n\tchar                   *join_path_new;\n\tM_fs_dir_entries_t     *entries;\n\tconst M_fs_dir_entry_t *entry;\n\tM_fs_info_t            *info;\n\tM_fs_progress_t        *progress            = NULL;\n\tM_fs_dir_walk_filter_t  filter              = M_FS_DIR_WALK_FILTER_ALL|M_FS_DIR_WALK_FILTER_RECURSE;\n\tM_fs_type_t             type;\n\tsize_t                  len;\n\tsize_t                  i;\n\tM_uint64                total_count         = 0;\n\tM_uint64                total_size          = 0;\n\tM_uint64                total_size_progress = 0;\n\tM_uint64                entry_size;\n\tM_fs_error_t            res;\n\n\tif (path_old == NULL || *path_old == '\\0' || path_new == NULL || *path_new == '\\0') {\n\t\treturn M_FS_ERROR_INVALID;\n\t}\n\n\t/* It's okay if new path doesn't exist. */\n\tres = M_fs_path_norm(&norm_path_new, path_new, M_FS_PATH_NORM_RESDIR, M_FS_SYSTEM_AUTO);\n\tif (res != M_FS_ERROR_SUCCESS) {\n\t\tM_free(norm_path_new);\n\t\treturn res;\n\t}\n\n\t/* If a path is a file and the destination is a directory the file should be copied\n\t * into the directory. E.g. /file.txt -> /dir = /dir/file.txt */\n\tif (M_fs_isfileintodir(path_old, path_new, &norm_path_old)) {\n\t\tM_free(norm_path_new);\n\t\tres = M_fs_copy(path_old, norm_path_old, mode, cb, progress_flags);\n\t\tM_free(norm_path_old);\n\t\treturn res;\n\t}\n\n\t/* Normalize the old path and do basic checks that it exists. We'll leave really checking that the old path\n \t * existing to rename because any check we perform may not be true when rename is called. */\n\tres = M_fs_path_norm(&norm_path_old, path_old, M_FS_PATH_NORM_RESALL, M_FS_SYSTEM_AUTO);\n\tif (res != M_FS_ERROR_SUCCESS) {\n\t\tM_free(norm_path_new);\n\t\tM_free(norm_path_old);\n\t\treturn res;\n\t}\n\n\tprogress = M_fs_progress_create();\n\n\tres = M_fs_info(&info, path_old, (mode & M_FS_FILE_MODE_PRESERVE_PERMS)?M_FS_PATH_INFO_FLAGS_NONE:M_FS_PATH_INFO_FLAGS_BASIC);\n\tif (res != M_FS_ERROR_SUCCESS) {\n\t\tM_fs_progress_destroy(progress);\n\t\tM_free(norm_path_new);\n\t\tM_free(norm_path_old);\n\t\treturn res;\n\t}\n\n\ttype = M_fs_info_get_type(info);\n\n \t/* There is a race condition where the path could not exist but be created between the exists check and calling\n\t * rename to move the file but there isn't much we can do in this case. copy will delete and the file so this\n\t * situation won't cause an error. */\n\tif (!M_fs_check_overwrite_allowed(norm_path_old, norm_path_new, mode)) {\n\t\tM_fs_progress_destroy(progress);\n\t\tM_free(norm_path_new);\n\t\tM_free(norm_path_old);\n\t\treturn M_FS_ERROR_FILE_EXISTS;\n\t}\n\n\tentries = M_fs_dir_entries_create();\n\t/* No need to destroy info  because it's now owned by entries and will be destroyed when entries is destroyed.\n \t * M_FS_DIR_WALK_FILTER_READ_INFO_BASIC doesn't actually get the perms it's just there to ensure the info is\n\t * stored in the entry. */\n\tM_fs_dir_entries_insert(entries, M_fs_dir_walk_fill_entry(norm_path_new, NULL, type, info, M_FS_DIR_WALK_FILTER_READ_INFO_BASIC));\n\tif (type == M_FS_TYPE_DIR) {\n\t\tif (mode & M_FS_FILE_MODE_PRESERVE_PERMS) {\n\t\t\tfilter |= M_FS_DIR_WALK_FILTER_READ_INFO_FULL;\n\t\t} else if (cb && progress_flags & (M_FS_PROGRESS_SIZE_TOTAL|M_FS_PROGRESS_SIZE_CUR)) {\n\t\t\tfilter |= M_FS_DIR_WALK_FILTER_READ_INFO_BASIC;\n\t\t}\n\t\t/* Get all the files under the dir. */\n\t\tM_fs_dir_entries_merge(&entries, M_fs_dir_walk_entries(norm_path_old, NULL, filter));\n\t}\n\n\t/* Put all dirs first. We need to ensure the dir(s) exist before we can copy files. */\n\tM_fs_dir_entries_sort(entries, M_FS_DIR_SORT_ISDIR, M_TRUE, M_FS_DIR_SORT_NAME_CASECMP, M_TRUE);\n\n\tlen = M_fs_dir_entries_len(entries);\n\tif (cb) {\n\t\ttotal_size = 0;\n\t\tfor (i=0; i<len; i++) {\n\t\t\tentry       = M_fs_dir_entries_at(entries, i);\n\t\t\tentry_size  = M_fs_info_get_size(M_fs_dir_entry_get_info(entry));\n\t\t\ttotal_size += entry_size;\n\n\t\t\ttype = M_fs_dir_entry_get_type(entry);\n\t\t\t/* The total isn't the total number of files but the total number of operations. \n \t\t\t * Making dirs and symlinks is one operation and copying a file will be split into\n\t\t\t * multiple operations. Copying uses the M_FS_BUF_SIZE to read and write in\n\t\t\t * chunks. We determine how many chunks will be needed to read the entire file and\n\t\t\t * use that for the number of operations for the file. */\n\t\t\tif (type == M_FS_TYPE_DIR || type == M_FS_TYPE_SYMLINK) {\n\t\t\t\ttotal_count++;\n\t\t\t} else {\n\t\t\t\ttotal_count += (entry_size + M_FS_BUF_SIZE - 1) / M_FS_BUF_SIZE;\n\t\t\t}\n\t\t}\n\t\t/* Change the progress total size to reflect all entries. */\n\t\tif (progress_flags & M_FS_PROGRESS_SIZE_TOTAL) {\n\t\t\tM_fs_progress_set_size_total(progress, total_size);\n\t\t}\n\t\t/* Change the progress count to reflect the count. */\n\t\tif (progress_flags & M_FS_PROGRESS_COUNT) {\n\t\t\tM_fs_progress_set_count_total(progress, total_count);\n\t\t}\n\t}\n\tfor (i=0; i<len; i++) {\n\t\tentry         = M_fs_dir_entries_at(entries, i);\n\t\ttype          = M_fs_dir_entry_get_type(entry);\n\t\tjoin_path_old = M_fs_path_join(norm_path_old, M_fs_dir_entry_get_name(entry), M_FS_SYSTEM_AUTO);\n\t\tjoin_path_new = M_fs_path_join(norm_path_new, M_fs_dir_entry_get_name(entry), M_FS_SYSTEM_AUTO);\n\n\t\tentry_size           = M_fs_info_get_size(M_fs_dir_entry_get_info(entry));\n\t\ttotal_size_progress += entry_size;\n\n\t\tif (cb) {\n\t\t\tM_fs_progress_set_path(progress, join_path_new);\n\t\t\tif (progress_flags & M_FS_PROGRESS_SIZE_CUR) {\n\t\t\t\tM_fs_progress_set_size_current(progress, entry_size);\n\t\t\t}\n\t\t}\n\n\t\t/* op */\n\t\tif (type == M_FS_TYPE_DIR || type == M_FS_TYPE_SYMLINK) {\n\t\t\tif (type == M_FS_TYPE_DIR) {\n\t\t\t\tres = M_fs_dir_mkdir(join_path_new, M_FALSE, NULL);\n\t\t\t} else if (type == M_FS_TYPE_SYMLINK) {\n\t\t\t\tres = M_fs_symlink(join_path_new, M_fs_dir_entry_get_resolved_name(entry));\n\t\t\t} \n\t\t\tif (res == M_FS_ERROR_SUCCESS && (mode & M_FS_FILE_MODE_PRESERVE_PERMS)) {\n\t\t\t\tres = M_fs_perms_set_perms(M_fs_info_get_perms(M_fs_dir_entry_get_info(entry)), join_path_new);\n\t\t\t}\n\t\t} else {\n\t\t\tres = M_fs_copy_file(join_path_old, join_path_new, mode, cb, progress_flags, progress, M_fs_info_get_perms(M_fs_dir_entry_get_info(entry)));\n\t\t}\n\n\t\tM_free(join_path_old);\n\t\tM_free(join_path_new);\n\n\t\t/* Call the callback and stop processing if requested. */\n\t\tif ((type == M_FS_TYPE_DIR || type == M_FS_TYPE_SYMLINK) && cb) {\n\t\t\tM_fs_progress_set_type(progress, M_fs_dir_entry_get_type(entry));\n\t\t\tM_fs_progress_set_result(progress, res);\n\n\t\t\tif (progress_flags & M_FS_PROGRESS_SIZE_TOTAL) {\n\t\t\t\tM_fs_progress_set_size_total_progess(progress, total_size_progress);\n\t\t\t}\n\t\t\tif (progress_flags & M_FS_PROGRESS_SIZE_CUR) {\n\t\t\t\tM_fs_progress_set_size_current_progress(progress, entry_size);\n\t\t\t}\n\t\t\tif (progress_flags & M_FS_PROGRESS_COUNT) {\n\t\t\t\tM_fs_progress_set_count(progress, M_fs_progress_get_count(progress)+1);\n\t\t\t}\n\n\t\t\tif (!cb(progress)) {\n\t\t\t\tres = M_FS_ERROR_CANCELED;\n\t\t\t}\n\t\t}\n\t\tif (res != M_FS_ERROR_SUCCESS) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Delete the file(s) if it could not be copied properly, but only if we are not overwriting.\n \t * If we're overwriting then there could be other files in that location (especially if it's a dir). */\n\tif (res != M_FS_ERROR_SUCCESS && !(mode & M_FS_FILE_MODE_OVERWRITE)) {\n\t\tM_fs_delete(path_new, M_TRUE, NULL, M_FS_PROGRESS_NOEXTRA);\n\t}\n\n\tM_fs_dir_entries_destroy(entries);\n\tM_fs_progress_destroy(progress);\n\tM_free(norm_path_new);\n\tM_free(norm_path_old);\n\n\treturn res;\n}",
        "func": "M_fs_error_t M_fs_copy(const char *path_old, const char *path_new, M_uint32 mode, M_fs_progress_cb_t cb, M_uint32 progress_flags)\n{\n\tchar                   *norm_path_old;\n\tchar                   *norm_path_new;\n\tchar                   *join_path_old;\n\tchar                   *join_path_new;\n\tM_fs_dir_entries_t     *entries;\n\tconst M_fs_dir_entry_t *entry;\n\tM_fs_info_t            *info;\n\tM_fs_progress_t        *progress            = NULL;\n\tM_fs_dir_walk_filter_t  filter              = M_FS_DIR_WALK_FILTER_ALL|M_FS_DIR_WALK_FILTER_RECURSE;\n\tM_fs_type_t             type;\n\tsize_t                  len;\n\tsize_t                  i;\n\tM_uint64                total_count         = 0;\n\tM_uint64                total_size          = 0;\n\tM_uint64                total_size_progress = 0;\n\tM_uint64                entry_size;\n\tM_fs_error_t            res;\n\n\tif (path_old == NULL || *path_old == '\\0' || path_new == NULL || *path_new == '\\0') {\n\t\treturn M_FS_ERROR_INVALID;\n\t}\n\n\t/* It's okay if new path doesn't exist. */\n\tres = M_fs_path_norm(&norm_path_new, path_new, M_FS_PATH_NORM_RESDIR, M_FS_SYSTEM_AUTO);\n\tif (res != M_FS_ERROR_SUCCESS) {\n\t\tM_free(norm_path_new);\n\t\treturn res;\n\t}\n\n\t/* If a path is a file and the destination is a directory the file should be copied\n\t * into the directory. E.g. /file.txt -> /dir = /dir/file.txt */\n\tif (M_fs_isfileintodir(path_old, path_new, &norm_path_old)) {\n\t\tM_free(norm_path_new);\n\t\tres = M_fs_copy(path_old, norm_path_old, mode, cb, progress_flags);\n\t\tM_free(norm_path_old);\n\t\treturn res;\n\t}\n\n\t/* Normalize the old path and do basic checks that it exists. We'll leave really checking that the old path\n\t * existing to rename because any check we perform may not be true when rename is called. */\n\tres = M_fs_path_norm(&norm_path_old, path_old, M_FS_PATH_NORM_RESALL, M_FS_SYSTEM_AUTO);\n\tif (res != M_FS_ERROR_SUCCESS) {\n\t\tM_free(norm_path_new);\n\t\tM_free(norm_path_old);\n\t\treturn res;\n\t}\n\n\tprogress = M_fs_progress_create();\n\n\tres = M_fs_info(&info, path_old, (mode & M_FS_FILE_MODE_PRESERVE_PERMS)?M_FS_PATH_INFO_FLAGS_NONE:M_FS_PATH_INFO_FLAGS_BASIC);\n\tif (res != M_FS_ERROR_SUCCESS) {\n\t\tM_fs_progress_destroy(progress);\n\t\tM_free(norm_path_new);\n\t\tM_free(norm_path_old);\n\t\treturn res;\n\t}\n\n\ttype = M_fs_info_get_type(info);\n\n\t/* There is a race condition where the path could not exist but be created between the exists check and calling\n\t * rename to move the file but there isn't much we can do in this case. copy will delete and the file so this\n\t * situation won't cause an error. */\n\tif (!M_fs_check_overwrite_allowed(norm_path_old, norm_path_new, mode)) {\n\t\tM_fs_progress_destroy(progress);\n\t\tM_free(norm_path_new);\n\t\tM_free(norm_path_old);\n\t\treturn M_FS_ERROR_FILE_EXISTS;\n\t}\n\n\tentries = M_fs_dir_entries_create();\n\t/* No need to destroy info  because it's now owned by entries and will be destroyed when entries is destroyed.\n\t * M_FS_DIR_WALK_FILTER_READ_INFO_BASIC doesn't actually get the perms it's just there to ensure the info is\n\t * stored in the entry. */\n\tM_fs_dir_entries_insert(entries, M_fs_dir_walk_fill_entry(norm_path_new, NULL, type, info, M_FS_DIR_WALK_FILTER_READ_INFO_BASIC));\n\tif (type == M_FS_TYPE_DIR) {\n\t\tif (mode & M_FS_FILE_MODE_PRESERVE_PERMS) {\n\t\t\tfilter |= M_FS_DIR_WALK_FILTER_READ_INFO_FULL;\n\t\t} else if (cb && progress_flags & (M_FS_PROGRESS_SIZE_TOTAL|M_FS_PROGRESS_SIZE_CUR)) {\n\t\t\tfilter |= M_FS_DIR_WALK_FILTER_READ_INFO_BASIC;\n\t\t}\n\t\t/* Get all the files under the dir. */\n\t\tM_fs_dir_entries_merge(&entries, M_fs_dir_walk_entries(norm_path_old, NULL, filter));\n\t}\n\n\t/* Put all dirs first. We need to ensure the dir(s) exist before we can copy files. */\n\tM_fs_dir_entries_sort(entries, M_FS_DIR_SORT_ISDIR, M_TRUE, M_FS_DIR_SORT_NAME_CASECMP, M_TRUE);\n\n\tlen = M_fs_dir_entries_len(entries);\n\tif (cb) {\n\t\ttotal_size = 0;\n\t\tfor (i=0; i<len; i++) {\n\t\t\tentry       = M_fs_dir_entries_at(entries, i);\n\t\t\tentry_size  = M_fs_info_get_size(M_fs_dir_entry_get_info(entry));\n\t\t\ttotal_size += entry_size;\n\n\t\t\ttype = M_fs_dir_entry_get_type(entry);\n\t\t\t/* The total isn't the total number of files but the total number of operations. \n\t\t\t * Making dirs and symlinks is one operation and copying a file will be split into\n\t\t\t * multiple operations. Copying uses the M_FS_BUF_SIZE to read and write in\n\t\t\t * chunks. We determine how many chunks will be needed to read the entire file and\n\t\t\t * use that for the number of operations for the file. */\n\t\t\tif (type == M_FS_TYPE_DIR || type == M_FS_TYPE_SYMLINK) {\n\t\t\t\ttotal_count++;\n\t\t\t} else {\n\t\t\t\ttotal_count += (entry_size + M_FS_BUF_SIZE - 1) / M_FS_BUF_SIZE;\n\t\t\t}\n\t\t}\n\t\t/* Change the progress total size to reflect all entries. */\n\t\tif (progress_flags & M_FS_PROGRESS_SIZE_TOTAL) {\n\t\t\tM_fs_progress_set_size_total(progress, total_size);\n\t\t}\n\t\t/* Change the progress count to reflect the count. */\n\t\tif (progress_flags & M_FS_PROGRESS_COUNT) {\n\t\t\tM_fs_progress_set_count_total(progress, total_count);\n\t\t}\n\t}\n\tfor (i=0; i<len; i++) {\n\t\tentry         = M_fs_dir_entries_at(entries, i);\n\t\ttype          = M_fs_dir_entry_get_type(entry);\n\t\tjoin_path_old = M_fs_path_join(norm_path_old, M_fs_dir_entry_get_name(entry), M_FS_SYSTEM_AUTO);\n\t\tjoin_path_new = M_fs_path_join(norm_path_new, M_fs_dir_entry_get_name(entry), M_FS_SYSTEM_AUTO);\n\n\t\tentry_size           = M_fs_info_get_size(M_fs_dir_entry_get_info(entry));\n\t\ttotal_size_progress += entry_size;\n\n\t\tif (cb) {\n\t\t\tM_fs_progress_set_path(progress, join_path_new);\n\t\t\tif (progress_flags & M_FS_PROGRESS_SIZE_CUR) {\n\t\t\t\tM_fs_progress_set_size_current(progress, entry_size);\n\t\t\t}\n\t\t}\n\n\t\t/* op */\n\t\tif (type == M_FS_TYPE_DIR || type == M_FS_TYPE_SYMLINK) {\n\t\t\tif (type == M_FS_TYPE_DIR) {\n\t\t\t\tres = M_fs_dir_mkdir(join_path_new, M_FALSE, NULL);\n\t\t\t} else if (type == M_FS_TYPE_SYMLINK) {\n\t\t\t\tres = M_fs_symlink(join_path_new, M_fs_dir_entry_get_resolved_name(entry));\n\t\t\t} \n\t\t\tif (res == M_FS_ERROR_SUCCESS && (mode & M_FS_FILE_MODE_PRESERVE_PERMS)) {\n\t\t\t\tres = M_fs_perms_set_perms(M_fs_info_get_perms(M_fs_dir_entry_get_info(entry)), join_path_new);\n\t\t\t}\n\t\t} else {\n\t\t\tres = M_fs_copy_file(join_path_old, join_path_new, mode, cb, progress_flags, progress, M_fs_info_get_perms(M_fs_dir_entry_get_info(entry)));\n\t\t}\n\n\t\tM_free(join_path_old);\n\t\tM_free(join_path_new);\n\n\t\t/* Call the callback and stop processing if requested. */\n\t\tif ((type == M_FS_TYPE_DIR || type == M_FS_TYPE_SYMLINK) && cb) {\n\t\t\tM_fs_progress_set_type(progress, M_fs_dir_entry_get_type(entry));\n\t\t\tM_fs_progress_set_result(progress, res);\n\n\t\t\tif (progress_flags & M_FS_PROGRESS_SIZE_TOTAL) {\n\t\t\t\tM_fs_progress_set_size_total_progess(progress, total_size_progress);\n\t\t\t}\n\t\t\tif (progress_flags & M_FS_PROGRESS_SIZE_CUR) {\n\t\t\t\tM_fs_progress_set_size_current_progress(progress, entry_size);\n\t\t\t}\n\t\t\tif (progress_flags & M_FS_PROGRESS_COUNT) {\n\t\t\t\tM_fs_progress_set_count(progress, M_fs_progress_get_count(progress)+1);\n\t\t\t}\n\n\t\t\tif (!cb(progress)) {\n\t\t\t\tres = M_FS_ERROR_CANCELED;\n\t\t\t}\n\t\t}\n\t\tif (res != M_FS_ERROR_SUCCESS) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Delete the file(s) if it could not be copied properly, but only if we are not overwriting.\n\t * If we're overwriting then there could be other files in that location (especially if it's a dir). */\n\tif (res != M_FS_ERROR_SUCCESS && !(mode & M_FS_FILE_MODE_OVERWRITE)) {\n\t\tM_fs_delete(path_new, M_TRUE, NULL, M_FS_PROGRESS_NOEXTRA);\n\t}\n\n\tM_fs_dir_entries_destroy(entries);\n\tM_fs_progress_destroy(progress);\n\tM_free(norm_path_new);\n\tM_free(norm_path_old);\n\n\treturn res;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -39,7 +39,7 @@\n \t}\n \n \t/* Normalize the old path and do basic checks that it exists. We'll leave really checking that the old path\n- \t * existing to rename because any check we perform may not be true when rename is called. */\n+\t * existing to rename because any check we perform may not be true when rename is called. */\n \tres = M_fs_path_norm(&norm_path_old, path_old, M_FS_PATH_NORM_RESALL, M_FS_SYSTEM_AUTO);\n \tif (res != M_FS_ERROR_SUCCESS) {\n \t\tM_free(norm_path_new);\n@@ -59,7 +59,7 @@\n \n \ttype = M_fs_info_get_type(info);\n \n- \t/* There is a race condition where the path could not exist but be created between the exists check and calling\n+\t/* There is a race condition where the path could not exist but be created between the exists check and calling\n \t * rename to move the file but there isn't much we can do in this case. copy will delete and the file so this\n \t * situation won't cause an error. */\n \tif (!M_fs_check_overwrite_allowed(norm_path_old, norm_path_new, mode)) {\n@@ -71,7 +71,7 @@\n \n \tentries = M_fs_dir_entries_create();\n \t/* No need to destroy info  because it's now owned by entries and will be destroyed when entries is destroyed.\n- \t * M_FS_DIR_WALK_FILTER_READ_INFO_BASIC doesn't actually get the perms it's just there to ensure the info is\n+\t * M_FS_DIR_WALK_FILTER_READ_INFO_BASIC doesn't actually get the perms it's just there to ensure the info is\n \t * stored in the entry. */\n \tM_fs_dir_entries_insert(entries, M_fs_dir_walk_fill_entry(norm_path_new, NULL, type, info, M_FS_DIR_WALK_FILTER_READ_INFO_BASIC));\n \tif (type == M_FS_TYPE_DIR) {\n@@ -97,7 +97,7 @@\n \n \t\t\ttype = M_fs_dir_entry_get_type(entry);\n \t\t\t/* The total isn't the total number of files but the total number of operations. \n- \t\t\t * Making dirs and symlinks is one operation and copying a file will be split into\n+\t\t\t * Making dirs and symlinks is one operation and copying a file will be split into\n \t\t\t * multiple operations. Copying uses the M_FS_BUF_SIZE to read and write in\n \t\t\t * chunks. We determine how many chunks will be needed to read the entire file and\n \t\t\t * use that for the number of operations for the file. */\n@@ -174,7 +174,7 @@\n \t}\n \n \t/* Delete the file(s) if it could not be copied properly, but only if we are not overwriting.\n- \t * If we're overwriting then there could be other files in that location (especially if it's a dir). */\n+\t * If we're overwriting then there could be other files in that location (especially if it's a dir). */\n \tif (res != M_FS_ERROR_SUCCESS && !(mode & M_FS_FILE_MODE_OVERWRITE)) {\n \t\tM_fs_delete(path_new, M_TRUE, NULL, M_FS_PROGRESS_NOEXTRA);\n \t}",
        "diff_line_info": {
            "deleted_lines": [
                " \t * existing to rename because any check we perform may not be true when rename is called. */",
                " \t/* There is a race condition where the path could not exist but be created between the exists check and calling",
                " \t * M_FS_DIR_WALK_FILTER_READ_INFO_BASIC doesn't actually get the perms it's just there to ensure the info is",
                " \t\t\t * Making dirs and symlinks is one operation and copying a file will be split into",
                " \t * If we're overwriting then there could be other files in that location (especially if it's a dir). */"
            ],
            "added_lines": [
                "\t * existing to rename because any check we perform may not be true when rename is called. */",
                "\t/* There is a race condition where the path could not exist but be created between the exists check and calling",
                "\t * M_FS_DIR_WALK_FILTER_READ_INFO_BASIC doesn't actually get the perms it's just there to ensure the info is",
                "\t\t\t * Making dirs and symlinks is one operation and copying a file will be split into",
                "\t * If we're overwriting then there could be other files in that location (especially if it's a dir). */"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-14043",
        "func_name": "Monetra/mstdlib/M_fs_check_overwrite_allowed",
        "description": "mstdlib (aka the M Standard Library for C) 1.2.0 has incorrect file access control in situations where M_fs_perms_can_access attempts to delete an existing file (that lacks public read/write access) during a copy operation, related to fs/m_fs.c and fs/m_fs_path.c. An attacker could create the file and then would have access to the data.",
        "git_url": "https://github.com/Monetra/mstdlib/commit/db124b8f607dd0a40a9aef2d4d468fad433522a7",
        "commit_title": "fs: Don't try to delete the file when copying. It could cause a security issue if the file exists and doesn't allow other's to read/write. delete could allow someone to create the file and have access to the data.",
        "commit_text": "",
        "func_before": "static M_bool M_fs_check_overwrite_allowed(const char *p1, const char *p2, M_uint32 mode)\n{\n\tM_fs_info_t  *info = NULL;\n\tchar         *pold = NULL;\n\tchar         *pnew = NULL;\n\tM_fs_type_t   type;\n\tM_bool        ret  = M_TRUE;\n\n\tif (mode & M_FS_FILE_MODE_OVERWRITE)\n\t\treturn M_TRUE;\n\n\t/* If we're not overwriting we need to verify existance.\n \t *\n \t * For files we need to check if the file name exists in the\n\t * directory it's being copied to.\n\t *\n\t * For directories we need to check if the directory name\n\t * exists in the directory it's being copied to.\n\t */\n\n\tif (M_fs_info(&info, p1, M_FS_PATH_INFO_FLAGS_BASIC) != M_FS_ERROR_SUCCESS)\n\t\treturn M_FALSE;\n\n\ttype = M_fs_info_get_type(info);\n\tM_fs_info_destroy(info);\n\n\tif (type != M_FS_TYPE_DIR) {\n\t\t/* File exists at path. */\n\t\tif (M_fs_perms_can_access(p2, M_FS_PERMS_MODE_NONE) == M_FS_ERROR_SUCCESS)\n\t\t{\n\t\t\tret = M_FALSE;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\t/* Is dir */\n\tpold = M_fs_path_basename(p1, M_FS_SYSTEM_AUTO);\n\tpnew = M_fs_path_join(p2, pnew, M_FS_SYSTEM_AUTO);\n\tif (M_fs_perms_can_access(pnew, M_FS_PERMS_MODE_NONE) == M_FS_ERROR_SUCCESS) {\n\t\tret = M_FALSE;\n\t\tgoto done;\n\t}\n\ndone:\n\tM_free(pnew);\n\tM_free(pold);\n\treturn ret;\n}",
        "func": "static M_bool M_fs_check_overwrite_allowed(const char *p1, const char *p2, M_uint32 mode)\n{\n\tM_fs_info_t  *info = NULL;\n\tchar         *pold = NULL;\n\tchar         *pnew = NULL;\n\tM_fs_type_t   type;\n\tM_bool        ret  = M_TRUE;\n\n\tif (mode & M_FS_FILE_MODE_OVERWRITE)\n\t\treturn M_TRUE;\n\n\t/* If we're not overwriting we need to verify existance.\n \t *\n \t * For files we need to check if the file name exists in the\n\t * directory it's being copied to.\n\t *\n\t * For directories we need to check if the directory name\n\t * exists in the directory it's being copied to.\n\t */\n\n\tif (M_fs_info(&info, p1, M_FS_PATH_INFO_FLAGS_BASIC) != M_FS_ERROR_SUCCESS)\n\t\treturn M_FALSE;\n\n\ttype = M_fs_info_get_type(info);\n\tM_fs_info_destroy(info);\n\n\tif (type != M_FS_TYPE_DIR) {\n\t\t/* File exists at path. */\n\t\tif (M_fs_perms_can_access(p2, M_FS_PERMS_MODE_NONE) == M_FS_ERROR_SUCCESS) {\n\t\t\tret = M_FALSE;\n\t\t\tgoto done;\n\t\t}\n\t}\n\n\t/* Is dir */\n\tpold = M_fs_path_basename(p1, M_FS_SYSTEM_AUTO);\n\tpnew = M_fs_path_join(p2, pnew, M_FS_SYSTEM_AUTO);\n\tif (M_fs_perms_can_access(pnew, M_FS_PERMS_MODE_NONE) == M_FS_ERROR_SUCCESS) {\n\t\tret = M_FALSE;\n\t\tgoto done;\n\t}\n\ndone:\n\tM_free(pnew);\n\tM_free(pold);\n\treturn ret;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -26,8 +26,7 @@\n \n \tif (type != M_FS_TYPE_DIR) {\n \t\t/* File exists at path. */\n-\t\tif (M_fs_perms_can_access(p2, M_FS_PERMS_MODE_NONE) == M_FS_ERROR_SUCCESS)\n-\t\t{\n+\t\tif (M_fs_perms_can_access(p2, M_FS_PERMS_MODE_NONE) == M_FS_ERROR_SUCCESS) {\n \t\t\tret = M_FALSE;\n \t\t\tgoto done;\n \t\t}",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tif (M_fs_perms_can_access(p2, M_FS_PERMS_MODE_NONE) == M_FS_ERROR_SUCCESS)",
                "\t\t{"
            ],
            "added_lines": [
                "\t\tif (M_fs_perms_can_access(p2, M_FS_PERMS_MODE_NONE) == M_FS_ERROR_SUCCESS) {"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-14043",
        "func_name": "Monetra/mstdlib/M_fs_copy_file",
        "description": "mstdlib (aka the M Standard Library for C) 1.2.0 has incorrect file access control in situations where M_fs_perms_can_access attempts to delete an existing file (that lacks public read/write access) during a copy operation, related to fs/m_fs.c and fs/m_fs_path.c. An attacker could create the file and then would have access to the data.",
        "git_url": "https://github.com/Monetra/mstdlib/commit/db124b8f607dd0a40a9aef2d4d468fad433522a7",
        "commit_title": "fs: Don't try to delete the file when copying. It could cause a security issue if the file exists and doesn't allow other's to read/write. delete could allow someone to create the file and have access to the data.",
        "commit_text": "",
        "func_before": "static M_fs_error_t M_fs_copy_file(const char *path_old, const char *path_new, M_fs_file_mode_t mode, M_fs_progress_cb_t cb, M_fs_progress_flags_t progress_flags, M_fs_progress_t *progress, const M_fs_perms_t *perms)\n{\n\tM_fs_file_t   *fd_old;\n\tM_fs_file_t   *fd_new;\n\tM_fs_info_t   *info         = NULL;\n\tunsigned char  temp[M_FS_BUF_SIZE];\n\tsize_t         read_len;\n\tsize_t         wrote_len;\n\tsize_t         wrote_total  = 0;\n\tsize_t         offset;\n\tM_fs_error_t   res;\n\n\t/* We're going to create/open/truncate the new file, then as we read the contents from the old file we'll write it\n \t * to new file. */\n\tif (M_fs_perms_can_access(path_new, M_FS_PERMS_MODE_NONE) == M_FS_ERROR_SUCCESS) {\n\t\t/* Try to delete the file since we'll be overwrite it. This is so when we create the file we create it without\n \t\t * any permissions and to ensure that anything that has the file already open won't be able to read the new\n\t\t * contents we're writing to the file or be able to change the perms. There is an unavoidable race condition\n\t\t * between deleting and creating the file where someone could create the file and have access. However,\n\t\t * depending on the OS they may have access even if the file is created with no perms... */\n\t\tres = M_fs_delete(path_new, M_FALSE, NULL, M_FS_PROGRESS_NOEXTRA);\n\t\tif (res != M_FS_ERROR_SUCCESS) {\n\t\t\treturn res;\n\t\t}\n\t}\n\t/* Open the old file */\n\tres = M_fs_file_open(&fd_old, path_old, M_FS_BUF_SIZE, M_FS_FILE_MODE_READ|M_FS_FILE_MODE_NOCREATE, NULL);\n\tif (res != M_FS_ERROR_SUCCESS) {\n\t\treturn res;\n\t}\n\n\tif (perms == NULL && mode & M_FS_FILE_MODE_PRESERVE_PERMS) {\n\t\tres = M_fs_info_file(&info, fd_old, M_FS_PATH_INFO_FLAGS_NONE);\n\t\tif (res != M_FS_ERROR_SUCCESS) {\n\t\t\tM_fs_file_close(fd_old);\n\t\t\treturn res;\n\t\t}\n\t\tperms = M_fs_info_get_perms(info);\n\t}\n\tres = M_fs_file_open(&fd_new, path_new, M_FS_BUF_SIZE, M_FS_FILE_MODE_WRITE|M_FS_FILE_MODE_OVERWRITE, perms);\n\tM_fs_info_destroy(info);\n\tif (res != M_FS_ERROR_SUCCESS) {\n\t\tM_fs_file_close(fd_old);\n\t\treturn res;\n\t}\n\n\t/* Copy the contents of old into new. */\n\twhile ((res = M_fs_file_read(fd_old, temp, sizeof(temp), &read_len, M_FS_FILE_RW_NORMAL)) == M_FS_ERROR_SUCCESS && read_len != 0) {\n\t\toffset = 0;\n\t\twhile (offset < read_len) {\n\t\t\tres          = M_fs_file_write(fd_new, temp+offset, read_len-offset, &wrote_len, M_FS_FILE_RW_NORMAL);\n\t\t\toffset      += wrote_len;\n\t\t\twrote_total += wrote_len;\n\n\t\t\tif (cb) {\n\t\t\t\tM_fs_progress_set_result(progress, res);\n\t\t\t\tif (progress_flags & M_FS_PROGRESS_SIZE_TOTAL) {\n\t\t\t\t\tM_fs_progress_set_size_total_progess(progress, M_fs_progress_get_size_total_progess(progress)+wrote_len);\n\t\t\t\t}\n\t\t\t\tif (progress_flags & M_FS_PROGRESS_SIZE_CUR) {\n\t\t\t\t\tM_fs_progress_set_size_current_progress(progress, wrote_total);\n\t\t\t\t}\n\t\t\t\tif (progress_flags & M_FS_PROGRESS_COUNT) {\n\t\t\t\t\tM_fs_progress_set_count(progress, M_fs_progress_get_count(progress)+1);\n\t\t\t\t}\n\t\t\t\tif (!cb(progress)) {\n\t\t\t\t\tres = M_FS_ERROR_CANCELED;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (res != M_FS_ERROR_SUCCESS) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (res != M_FS_ERROR_SUCCESS) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tM_fs_file_close(fd_old);\n\tM_fs_file_close(fd_new);\n\tif (res != M_FS_ERROR_SUCCESS) {\n\t\treturn res;\n\t}\n\n\treturn M_FS_ERROR_SUCCESS;\n}",
        "func": "static M_fs_error_t M_fs_copy_file(const char *path_old, const char *path_new, M_fs_file_mode_t mode, M_fs_progress_cb_t cb, M_fs_progress_flags_t progress_flags, M_fs_progress_t *progress, const M_fs_perms_t *perms)\n{\n\tM_fs_file_t   *fd_old;\n\tM_fs_file_t   *fd_new;\n\tM_fs_info_t   *info         = NULL;\n\tunsigned char  temp[M_FS_BUF_SIZE];\n\tsize_t         read_len;\n\tsize_t         wrote_len;\n\tsize_t         wrote_total  = 0;\n\tsize_t         offset;\n\tM_fs_error_t   res;\n\n\t/* Open the old file */\n\tres = M_fs_file_open(&fd_old, path_old, M_FS_BUF_SIZE, M_FS_FILE_MODE_READ|M_FS_FILE_MODE_NOCREATE, NULL);\n\tif (res != M_FS_ERROR_SUCCESS) {\n\t\treturn res;\n\t}\n\n\tif (perms == NULL && mode & M_FS_FILE_MODE_PRESERVE_PERMS) {\n\t\tres = M_fs_info_file(&info, fd_old, M_FS_PATH_INFO_FLAGS_NONE);\n\t\tif (res != M_FS_ERROR_SUCCESS) {\n\t\t\tM_fs_file_close(fd_old);\n\t\t\treturn res;\n\t\t}\n\t\tperms = M_fs_info_get_perms(info);\n\t}\n\n\t/* We're going to create/open/truncate the new file, then as we read the contents from the old file we'll write it\n\t * to new file. */\n\tres = M_fs_file_open(&fd_new, path_new, M_FS_BUF_SIZE, M_FS_FILE_MODE_WRITE|M_FS_FILE_MODE_OVERWRITE, perms);\n\tM_fs_info_destroy(info);\n\tif (res != M_FS_ERROR_SUCCESS) {\n\t\tM_fs_file_close(fd_old);\n\t\treturn res;\n\t}\n\n\t/* Copy the contents of old into new. */\n\twhile ((res = M_fs_file_read(fd_old, temp, sizeof(temp), &read_len, M_FS_FILE_RW_NORMAL)) == M_FS_ERROR_SUCCESS && read_len != 0) {\n\t\toffset = 0;\n\t\twhile (offset < read_len) {\n\t\t\tres          = M_fs_file_write(fd_new, temp+offset, read_len-offset, &wrote_len, M_FS_FILE_RW_NORMAL);\n\t\t\toffset      += wrote_len;\n\t\t\twrote_total += wrote_len;\n\n\t\t\tif (cb) {\n\t\t\t\tM_fs_progress_set_result(progress, res);\n\t\t\t\tif (progress_flags & M_FS_PROGRESS_SIZE_TOTAL) {\n\t\t\t\t\tM_fs_progress_set_size_total_progess(progress, M_fs_progress_get_size_total_progess(progress)+wrote_len);\n\t\t\t\t}\n\t\t\t\tif (progress_flags & M_FS_PROGRESS_SIZE_CUR) {\n\t\t\t\t\tM_fs_progress_set_size_current_progress(progress, wrote_total);\n\t\t\t\t}\n\t\t\t\tif (progress_flags & M_FS_PROGRESS_COUNT) {\n\t\t\t\t\tM_fs_progress_set_count(progress, M_fs_progress_get_count(progress)+1);\n\t\t\t\t}\n\t\t\t\tif (!cb(progress)) {\n\t\t\t\t\tres = M_FS_ERROR_CANCELED;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (res != M_FS_ERROR_SUCCESS) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (res != M_FS_ERROR_SUCCESS) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tM_fs_file_close(fd_old);\n\tM_fs_file_close(fd_new);\n\tif (res != M_FS_ERROR_SUCCESS) {\n\t\treturn res;\n\t}\n\n\treturn M_FS_ERROR_SUCCESS;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -10,19 +10,6 @@\n \tsize_t         offset;\n \tM_fs_error_t   res;\n \n-\t/* We're going to create/open/truncate the new file, then as we read the contents from the old file we'll write it\n- \t * to new file. */\n-\tif (M_fs_perms_can_access(path_new, M_FS_PERMS_MODE_NONE) == M_FS_ERROR_SUCCESS) {\n-\t\t/* Try to delete the file since we'll be overwrite it. This is so when we create the file we create it without\n- \t\t * any permissions and to ensure that anything that has the file already open won't be able to read the new\n-\t\t * contents we're writing to the file or be able to change the perms. There is an unavoidable race condition\n-\t\t * between deleting and creating the file where someone could create the file and have access. However,\n-\t\t * depending on the OS they may have access even if the file is created with no perms... */\n-\t\tres = M_fs_delete(path_new, M_FALSE, NULL, M_FS_PROGRESS_NOEXTRA);\n-\t\tif (res != M_FS_ERROR_SUCCESS) {\n-\t\t\treturn res;\n-\t\t}\n-\t}\n \t/* Open the old file */\n \tres = M_fs_file_open(&fd_old, path_old, M_FS_BUF_SIZE, M_FS_FILE_MODE_READ|M_FS_FILE_MODE_NOCREATE, NULL);\n \tif (res != M_FS_ERROR_SUCCESS) {\n@@ -37,6 +24,9 @@\n \t\t}\n \t\tperms = M_fs_info_get_perms(info);\n \t}\n+\n+\t/* We're going to create/open/truncate the new file, then as we read the contents from the old file we'll write it\n+\t * to new file. */\n \tres = M_fs_file_open(&fd_new, path_new, M_FS_BUF_SIZE, M_FS_FILE_MODE_WRITE|M_FS_FILE_MODE_OVERWRITE, perms);\n \tM_fs_info_destroy(info);\n \tif (res != M_FS_ERROR_SUCCESS) {",
        "diff_line_info": {
            "deleted_lines": [
                "\t/* We're going to create/open/truncate the new file, then as we read the contents from the old file we'll write it",
                " \t * to new file. */",
                "\tif (M_fs_perms_can_access(path_new, M_FS_PERMS_MODE_NONE) == M_FS_ERROR_SUCCESS) {",
                "\t\t/* Try to delete the file since we'll be overwrite it. This is so when we create the file we create it without",
                " \t\t * any permissions and to ensure that anything that has the file already open won't be able to read the new",
                "\t\t * contents we're writing to the file or be able to change the perms. There is an unavoidable race condition",
                "\t\t * between deleting and creating the file where someone could create the file and have access. However,",
                "\t\t * depending on the OS they may have access even if the file is created with no perms... */",
                "\t\tres = M_fs_delete(path_new, M_FALSE, NULL, M_FS_PROGRESS_NOEXTRA);",
                "\t\tif (res != M_FS_ERROR_SUCCESS) {",
                "\t\t\treturn res;",
                "\t\t}",
                "\t}"
            ],
            "added_lines": [
                "",
                "\t/* We're going to create/open/truncate the new file, then as we read the contents from the old file we'll write it",
                "\t * to new file. */"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-20145",
        "func_name": "eclipse/mosquitto/config__parse_args",
        "description": "Eclipse Mosquitto 1.5.x before 1.5.5 allows ACL bypass: if the option per_listener_settings was set to true, and the default listener was in use, and the default listener specified an acl_file, then the acl file was being ignored.",
        "git_url": "https://github.com/eclipse/mosquitto/commit/9097577b49b7fdcf45d30975976dd93808ccc0c4",
        "commit_title": "Fix acl_file being ignore for default listener if with per_listener_settings",
        "commit_text": " Close #1073. Thanks to Jef Driesen.  Bug: https://github.com/eclipse/mosquitto/issues/1073",
        "func_before": "int config__parse_args(struct mosquitto_db *db, struct mosquitto__config *config, int argc, char *argv[])\n{\n\tint i;\n\tint port_tmp;\n\n\tfor(i=1; i<argc; i++){\n\t\tif(!strcmp(argv[i], \"-c\") || !strcmp(argv[i], \"--config-file\")){\n\t\t\tif(i<argc-1){\n\t\t\t\tdb->config_file = argv[i+1];\n\n\t\t\t\tif(config__read(db, config, false)){\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Unable to open configuration file.\");\n\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: -c argument given, but no config file specified.\");\n\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t}\n\t\t\ti++;\n\t\t}else if(!strcmp(argv[i], \"-d\") || !strcmp(argv[i], \"--daemon\")){\n\t\t\tconfig->daemon = true;\n\t\t}else if(!strcmp(argv[i], \"-h\") || !strcmp(argv[i], \"--help\")){\n\t\t\tprint_usage();\n\t\t\treturn MOSQ_ERR_INVAL;\n\t\t}else if(!strcmp(argv[i], \"-p\") || !strcmp(argv[i], \"--port\")){\n\t\t\tif(i<argc-1){\n\t\t\t\tport_tmp = atoi(argv[i+1]);\n\t\t\t\tif(port_tmp<1 || port_tmp>65535){\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid port specified (%d).\", port_tmp);\n\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t}else{\n\t\t\t\t\tif(config->default_listener.port){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Warning: Default listener port specified multiple times. Only the latest will be used.\");\n\t\t\t\t\t}\n\t\t\t\t\tconfig->default_listener.port = port_tmp;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: -p argument given, but no port specified.\");\n\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t}\n\t\t\ti++;\n\t\t}else if(!strcmp(argv[i], \"-v\") || !strcmp(argv[i], \"--verbose\")){\n\t\t\tdb->verbose = true;\n\t\t}else{\n\t\t\tfprintf(stderr, \"Error: Unknown option '%s'.\\n\",argv[i]);\n\t\t\tprint_usage();\n\t\t\treturn MOSQ_ERR_INVAL;\n\t\t}\n\t}\n\n\tif(config->listener_count == 0\n#ifdef WITH_TLS\n\t\t\t|| config->default_listener.cafile\n\t\t\t|| config->default_listener.capath\n\t\t\t|| config->default_listener.certfile\n\t\t\t|| config->default_listener.keyfile\n\t\t\t|| config->default_listener.ciphers\n\t\t\t|| config->default_listener.psk_hint\n\t\t\t|| config->default_listener.require_certificate\n\t\t\t|| config->default_listener.crlfile\n\t\t\t|| config->default_listener.use_identity_as_username\n\t\t\t|| config->default_listener.use_subject_as_username\n#endif\n\t\t\t|| config->default_listener.use_username_as_clientid\n\t\t\t|| config->default_listener.host\n\t\t\t|| config->default_listener.port\n\t\t\t|| config->default_listener.max_connections != -1\n\t\t\t|| config->default_listener.mount_point\n\t\t\t|| config->default_listener.protocol != mp_mqtt\n\t\t\t|| config->default_listener.socket_domain\n\t\t\t|| config->default_listener.security_options.password_file\n\t\t\t|| config->default_listener.security_options.psk_file\n\t\t\t|| config->default_listener.security_options.auth_plugin_config_count\n\t\t\t|| config->default_listener.security_options.allow_anonymous != -1\n\t\t\t){\n\n\t\tconfig->listener_count++;\n\t\tconfig->listeners = mosquitto__realloc(config->listeners, sizeof(struct mosquitto__listener)*config->listener_count);\n\t\tif(!config->listeners){\n\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Out of memory.\");\n\t\t\treturn MOSQ_ERR_NOMEM;\n\t\t}\n\t\tmemset(&config->listeners[config->listener_count-1], 0, sizeof(struct mosquitto__listener));\n\t\tif(config->default_listener.port){\n\t\t\tconfig->listeners[config->listener_count-1].port = config->default_listener.port;\n\t\t}else{\n\t\t\tconfig->listeners[config->listener_count-1].port = 1883;\n\t\t}\n\t\tif(config->default_listener.host){\n\t\t\tconfig->listeners[config->listener_count-1].host = config->default_listener.host;\n\t\t}else{\n\t\t\tconfig->listeners[config->listener_count-1].host = NULL;\n\t\t}\n\t\tif(config->default_listener.mount_point){\n\t\t\tconfig->listeners[config->listener_count-1].mount_point = config->default_listener.mount_point;\n\t\t}else{\n\t\t\tconfig->listeners[config->listener_count-1].mount_point = NULL;\n\t\t}\n\t\tconfig->listeners[config->listener_count-1].max_connections = config->default_listener.max_connections;\n\t\tconfig->listeners[config->listener_count-1].protocol = config->default_listener.protocol;\n\t\tconfig->listeners[config->listener_count-1].socket_domain = config->default_listener.socket_domain;\n\t\tconfig->listeners[config->listener_count-1].client_count = 0;\n\t\tconfig->listeners[config->listener_count-1].socks = NULL;\n\t\tconfig->listeners[config->listener_count-1].sock_count = 0;\n\t\tconfig->listeners[config->listener_count-1].client_count = 0;\n\t\tconfig->listeners[config->listener_count-1].use_username_as_clientid = config->default_listener.use_username_as_clientid;\n#ifdef WITH_TLS\n\t\tconfig->listeners[config->listener_count-1].tls_version = config->default_listener.tls_version;\n\t\tconfig->listeners[config->listener_count-1].cafile = config->default_listener.cafile;\n\t\tconfig->listeners[config->listener_count-1].capath = config->default_listener.capath;\n\t\tconfig->listeners[config->listener_count-1].certfile = config->default_listener.certfile;\n\t\tconfig->listeners[config->listener_count-1].keyfile = config->default_listener.keyfile;\n\t\tconfig->listeners[config->listener_count-1].ciphers = config->default_listener.ciphers;\n\t\tconfig->listeners[config->listener_count-1].psk_hint = config->default_listener.psk_hint;\n\t\tconfig->listeners[config->listener_count-1].require_certificate = config->default_listener.require_certificate;\n\t\tconfig->listeners[config->listener_count-1].ssl_ctx = NULL;\n\t\tconfig->listeners[config->listener_count-1].crlfile = config->default_listener.crlfile;\n\t\tconfig->listeners[config->listener_count-1].use_identity_as_username = config->default_listener.use_identity_as_username;\n\t\tconfig->listeners[config->listener_count-1].use_subject_as_username = config->default_listener.use_subject_as_username;\n#endif\n\t\tconfig->listeners[config->listener_count-1].security_options.password_file = config->default_listener.security_options.password_file;\n\t\tconfig->listeners[config->listener_count-1].security_options.psk_file = config->default_listener.security_options.psk_file;\n\t\tconfig->listeners[config->listener_count-1].security_options.auth_plugin_configs = config->default_listener.security_options.auth_plugin_configs;\n\t\tconfig->listeners[config->listener_count-1].security_options.auth_plugin_config_count = config->default_listener.security_options.auth_plugin_config_count;\n\t\tconfig->listeners[config->listener_count-1].security_options.allow_anonymous = config->default_listener.security_options.allow_anonymous;\n\t}\n\n\t/* Default to drop to mosquitto user if we are privileged and no user specified. */\n\tif(!config->user){\n\t\tconfig->user = \"mosquitto\";\n\t}\n\tif(db->verbose){\n\t\tconfig->log_type = INT_MAX;\n\t}\n\treturn config__check(config);\n}",
        "func": "int config__parse_args(struct mosquitto_db *db, struct mosquitto__config *config, int argc, char *argv[])\n{\n\tint i;\n\tint port_tmp;\n\n\tfor(i=1; i<argc; i++){\n\t\tif(!strcmp(argv[i], \"-c\") || !strcmp(argv[i], \"--config-file\")){\n\t\t\tif(i<argc-1){\n\t\t\t\tdb->config_file = argv[i+1];\n\n\t\t\t\tif(config__read(db, config, false)){\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Unable to open configuration file.\");\n\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: -c argument given, but no config file specified.\");\n\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t}\n\t\t\ti++;\n\t\t}else if(!strcmp(argv[i], \"-d\") || !strcmp(argv[i], \"--daemon\")){\n\t\t\tconfig->daemon = true;\n\t\t}else if(!strcmp(argv[i], \"-h\") || !strcmp(argv[i], \"--help\")){\n\t\t\tprint_usage();\n\t\t\treturn MOSQ_ERR_INVAL;\n\t\t}else if(!strcmp(argv[i], \"-p\") || !strcmp(argv[i], \"--port\")){\n\t\t\tif(i<argc-1){\n\t\t\t\tport_tmp = atoi(argv[i+1]);\n\t\t\t\tif(port_tmp<1 || port_tmp>65535){\n\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Invalid port specified (%d).\", port_tmp);\n\t\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t\t}else{\n\t\t\t\t\tif(config->default_listener.port){\n\t\t\t\t\t\tlog__printf(NULL, MOSQ_LOG_WARNING, \"Warning: Default listener port specified multiple times. Only the latest will be used.\");\n\t\t\t\t\t}\n\t\t\t\t\tconfig->default_listener.port = port_tmp;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: -p argument given, but no port specified.\");\n\t\t\t\treturn MOSQ_ERR_INVAL;\n\t\t\t}\n\t\t\ti++;\n\t\t}else if(!strcmp(argv[i], \"-v\") || !strcmp(argv[i], \"--verbose\")){\n\t\t\tdb->verbose = true;\n\t\t}else{\n\t\t\tfprintf(stderr, \"Error: Unknown option '%s'.\\n\",argv[i]);\n\t\t\tprint_usage();\n\t\t\treturn MOSQ_ERR_INVAL;\n\t\t}\n\t}\n\n\tif(config->listener_count == 0\n#ifdef WITH_TLS\n\t\t\t|| config->default_listener.cafile\n\t\t\t|| config->default_listener.capath\n\t\t\t|| config->default_listener.certfile\n\t\t\t|| config->default_listener.keyfile\n\t\t\t|| config->default_listener.ciphers\n\t\t\t|| config->default_listener.psk_hint\n\t\t\t|| config->default_listener.require_certificate\n\t\t\t|| config->default_listener.crlfile\n\t\t\t|| config->default_listener.use_identity_as_username\n\t\t\t|| config->default_listener.use_subject_as_username\n#endif\n\t\t\t|| config->default_listener.use_username_as_clientid\n\t\t\t|| config->default_listener.host\n\t\t\t|| config->default_listener.port\n\t\t\t|| config->default_listener.max_connections != -1\n\t\t\t|| config->default_listener.mount_point\n\t\t\t|| config->default_listener.protocol != mp_mqtt\n\t\t\t|| config->default_listener.socket_domain\n\t\t\t|| config->default_listener.security_options.password_file\n\t\t\t|| config->default_listener.security_options.psk_file\n\t\t\t|| config->default_listener.security_options.auth_plugin_config_count\n\t\t\t|| config->default_listener.security_options.allow_anonymous != -1\n\t\t\t){\n\n\t\tconfig->listener_count++;\n\t\tconfig->listeners = mosquitto__realloc(config->listeners, sizeof(struct mosquitto__listener)*config->listener_count);\n\t\tif(!config->listeners){\n\t\t\tlog__printf(NULL, MOSQ_LOG_ERR, \"Error: Out of memory.\");\n\t\t\treturn MOSQ_ERR_NOMEM;\n\t\t}\n\t\tmemset(&config->listeners[config->listener_count-1], 0, sizeof(struct mosquitto__listener));\n\t\tif(config->default_listener.port){\n\t\t\tconfig->listeners[config->listener_count-1].port = config->default_listener.port;\n\t\t}else{\n\t\t\tconfig->listeners[config->listener_count-1].port = 1883;\n\t\t}\n\t\tif(config->default_listener.host){\n\t\t\tconfig->listeners[config->listener_count-1].host = config->default_listener.host;\n\t\t}else{\n\t\t\tconfig->listeners[config->listener_count-1].host = NULL;\n\t\t}\n\t\tif(config->default_listener.mount_point){\n\t\t\tconfig->listeners[config->listener_count-1].mount_point = config->default_listener.mount_point;\n\t\t}else{\n\t\t\tconfig->listeners[config->listener_count-1].mount_point = NULL;\n\t\t}\n\t\tconfig->listeners[config->listener_count-1].max_connections = config->default_listener.max_connections;\n\t\tconfig->listeners[config->listener_count-1].protocol = config->default_listener.protocol;\n\t\tconfig->listeners[config->listener_count-1].socket_domain = config->default_listener.socket_domain;\n\t\tconfig->listeners[config->listener_count-1].client_count = 0;\n\t\tconfig->listeners[config->listener_count-1].socks = NULL;\n\t\tconfig->listeners[config->listener_count-1].sock_count = 0;\n\t\tconfig->listeners[config->listener_count-1].client_count = 0;\n\t\tconfig->listeners[config->listener_count-1].use_username_as_clientid = config->default_listener.use_username_as_clientid;\n#ifdef WITH_TLS\n\t\tconfig->listeners[config->listener_count-1].tls_version = config->default_listener.tls_version;\n\t\tconfig->listeners[config->listener_count-1].cafile = config->default_listener.cafile;\n\t\tconfig->listeners[config->listener_count-1].capath = config->default_listener.capath;\n\t\tconfig->listeners[config->listener_count-1].certfile = config->default_listener.certfile;\n\t\tconfig->listeners[config->listener_count-1].keyfile = config->default_listener.keyfile;\n\t\tconfig->listeners[config->listener_count-1].ciphers = config->default_listener.ciphers;\n\t\tconfig->listeners[config->listener_count-1].psk_hint = config->default_listener.psk_hint;\n\t\tconfig->listeners[config->listener_count-1].require_certificate = config->default_listener.require_certificate;\n\t\tconfig->listeners[config->listener_count-1].ssl_ctx = NULL;\n\t\tconfig->listeners[config->listener_count-1].crlfile = config->default_listener.crlfile;\n\t\tconfig->listeners[config->listener_count-1].use_identity_as_username = config->default_listener.use_identity_as_username;\n\t\tconfig->listeners[config->listener_count-1].use_subject_as_username = config->default_listener.use_subject_as_username;\n#endif\n\t\tconfig->listeners[config->listener_count-1].security_options.acl_file = config->default_listener.security_options.acl_file;\n\t\tconfig->listeners[config->listener_count-1].security_options.password_file = config->default_listener.security_options.password_file;\n\t\tconfig->listeners[config->listener_count-1].security_options.psk_file = config->default_listener.security_options.psk_file;\n\t\tconfig->listeners[config->listener_count-1].security_options.auth_plugin_configs = config->default_listener.security_options.auth_plugin_configs;\n\t\tconfig->listeners[config->listener_count-1].security_options.auth_plugin_config_count = config->default_listener.security_options.auth_plugin_config_count;\n\t\tconfig->listeners[config->listener_count-1].security_options.allow_anonymous = config->default_listener.security_options.allow_anonymous;\n\t}\n\n\t/* Default to drop to mosquitto user if we are privileged and no user specified. */\n\tif(!config->user){\n\t\tconfig->user = \"mosquitto\";\n\t}\n\tif(db->verbose){\n\t\tconfig->log_type = INT_MAX;\n\t}\n\treturn config__check(config);\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -118,6 +118,7 @@\n \t\tconfig->listeners[config->listener_count-1].use_identity_as_username = config->default_listener.use_identity_as_username;\n \t\tconfig->listeners[config->listener_count-1].use_subject_as_username = config->default_listener.use_subject_as_username;\n #endif\n+\t\tconfig->listeners[config->listener_count-1].security_options.acl_file = config->default_listener.security_options.acl_file;\n \t\tconfig->listeners[config->listener_count-1].security_options.password_file = config->default_listener.security_options.password_file;\n \t\tconfig->listeners[config->listener_count-1].security_options.psk_file = config->default_listener.security_options.psk_file;\n \t\tconfig->listeners[config->listener_count-1].security_options.auth_plugin_configs = config->default_listener.security_options.auth_plugin_configs;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\tconfig->listeners[config->listener_count-1].security_options.acl_file = config->default_listener.security_options.acl_file;"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-33586",
        "func_name": "inspircd/Pong",
        "description": "InspIRCd 3.8.0 through 3.9.x before 3.10.0 allows any user (able to connect to the server) to access recently deallocated memory, aka the \"malformed PONG\" issue.",
        "git_url": "https://github.com/inspircd/inspircd/commit/4350a11c663b0d75f8119743bffb7736d87abd4d",
        "commit_title": "Fix sending malformed pong messages in some cases.",
        "commit_text": "",
        "func_before": "Pong(const std::string& cookie, const std::string& server = \"\")\n\t\t: ClientProtocol::Message(\"PONG\", ServerInstance->Config->GetServerName())\n\t{\n\t\tPushParamRef(ServerInstance->Config->GetServerName());\n\t\tif (!server.empty())\n\t\t\tPushParamRef(server);\n\t\tPushParamRef(cookie);\n\t}",
        "func": "Pong(const std::string& cookie, const std::string& server = \"\")\n\t\t: ClientProtocol::Message(\"PONG\", ServerInstance->Config->GetServerName())\n\t{\n\t\tif (server.empty())\n\t\t\tPushParamRef(ServerInstance->Config->GetServerName());\n\t\telse\n\t\t\tPushParam(server);\n\t\tPushParamRef(cookie);\n\t}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -1,8 +1,9 @@\n Pong(const std::string& cookie, const std::string& server = \"\")\n \t\t: ClientProtocol::Message(\"PONG\", ServerInstance->Config->GetServerName())\n \t{\n-\t\tPushParamRef(ServerInstance->Config->GetServerName());\n-\t\tif (!server.empty())\n-\t\t\tPushParamRef(server);\n+\t\tif (server.empty())\n+\t\t\tPushParamRef(ServerInstance->Config->GetServerName());\n+\t\telse\n+\t\t\tPushParam(server);\n \t\tPushParamRef(cookie);\n \t}",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tPushParamRef(ServerInstance->Config->GetServerName());",
                "\t\tif (!server.empty())",
                "\t\t\tPushParamRef(server);"
            ],
            "added_lines": [
                "\t\tif (server.empty())",
                "\t\t\tPushParamRef(ServerInstance->Config->GetServerName());",
                "\t\telse",
                "\t\t\tPushParam(server);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-33586",
        "func_name": "inspircd/HandleLocal",
        "description": "InspIRCd 3.8.0 through 3.9.x before 3.10.0 allows any user (able to connect to the server) to access recently deallocated memory, aka the \"malformed PONG\" issue.",
        "git_url": "https://github.com/inspircd/inspircd/commit/4350a11c663b0d75f8119743bffb7736d87abd4d",
        "commit_title": "Fix sending malformed pong messages in some cases.",
        "commit_text": "",
        "func_before": "CmdResult HandleLocal(LocalUser* user, const Params& parameters) CXX11_OVERRIDE\n\t{\n\t\tsize_t origin = parameters.size() > 1 ? 1 : 0;\n\t\tif (parameters[origin].empty())\n\t\t{\n\t\t\tuser->WriteNumeric(ERR_NOORIGIN, \"No origin specified\");\n\t\t\treturn CMD_FAILURE;\n\t\t}\n\n\t\tClientProtocol::Messages::Pong pong(parameters[0], origin ? parameters[1] : \"\");\n\t\tuser->Send(ServerInstance->GetRFCEvents().pong, pong);\n\t\treturn CMD_SUCCESS;\n\t}",
        "func": "CmdResult HandleLocal(LocalUser* user, const Params& parameters) CXX11_OVERRIDE\n\t{\n\t\tsize_t origin = parameters.size() > 1 ? 1 : 0;\n\t\tif (parameters[origin].empty())\n\t\t{\n\t\t\tuser->WriteNumeric(ERR_NOORIGIN, \"No origin specified\");\n\t\t\treturn CMD_FAILURE;\n\t\t}\n\n\t\tClientProtocol::Messages::Pong pong(parameters[0], origin ? parameters[1] : ServerInstance->Config->GetServerName());\n\t\tuser->Send(ServerInstance->GetRFCEvents().pong, pong);\n\t\treturn CMD_SUCCESS;\n\t}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -7,7 +7,7 @@\n \t\t\treturn CMD_FAILURE;\n \t\t}\n \n-\t\tClientProtocol::Messages::Pong pong(parameters[0], origin ? parameters[1] : \"\");\n+\t\tClientProtocol::Messages::Pong pong(parameters[0], origin ? parameters[1] : ServerInstance->Config->GetServerName());\n \t\tuser->Send(ServerInstance->GetRFCEvents().pong, pong);\n \t\treturn CMD_SUCCESS;\n \t}",
        "diff_line_info": {
            "deleted_lines": [
                "\t\tClientProtocol::Messages::Pong pong(parameters[0], origin ? parameters[1] : \"\");"
            ],
            "added_lines": [
                "\t\tClientProtocol::Messages::Pong pong(parameters[0], origin ? parameters[1] : ServerInstance->Config->GetServerName());"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-5068",
        "func_name": "mesa/alloc_shm",
        "description": "An exploitable shared memory permissions vulnerability exists in the functionality of X11 Mesa 3D Graphics Library 19.1.2. An attacker can access the shared memory without any specific permissions to trigger this vulnerability.",
        "git_url": "https://cgit.freedesktop.org/mesa/mesa/commit/?id=02c3dad0f3b4d26e0faa5cc51d06bc50d693dcdc",
        "commit_title": "A security advisory (TALOS-2019-0857/CVE-2019-5068) found that",
        "commit_text": "creating shared memory regions with permission mode 0777 could allow any user to access that memory.  Several Mesa drivers use shared- memory XImages to implement back buffers for improved performance.  This path changes the shmget() calls to use 0600 (user r/w).  Tested with legacy Xlib driver and llvmpipe.  Cc: mesa-stable@lists.freedesktop.org ",
        "func_before": "static char *\nalloc_shm(struct dri_sw_displaytarget *dri_sw_dt, unsigned size)\n{\n   char *addr;\n\n   dri_sw_dt->shmid = shmget(IPC_PRIVATE, size, IPC_CREAT|0777);\n   if (dri_sw_dt->shmid < 0)\n      return NULL;\n\n   addr = (char *) shmat(dri_sw_dt->shmid, 0, 0);\n   /* mark the segment immediately for deletion to avoid leaks */\n   shmctl(dri_sw_dt->shmid, IPC_RMID, 0);\n\n   if (addr == (char *) -1)\n      return NULL;\n\n   return addr;\n}",
        "func": "static char *\nalloc_shm(struct dri_sw_displaytarget *dri_sw_dt, unsigned size)\n{\n   char *addr;\n\n   /* 0600 = user read+write */\n   dri_sw_dt->shmid = shmget(IPC_PRIVATE, size, IPC_CREAT | 0600);\n   if (dri_sw_dt->shmid < 0)\n      return NULL;\n\n   addr = (char *) shmat(dri_sw_dt->shmid, 0, 0);\n   /* mark the segment immediately for deletion to avoid leaks */\n   shmctl(dri_sw_dt->shmid, IPC_RMID, 0);\n\n   if (addr == (char *) -1)\n      return NULL;\n\n   return addr;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -3,7 +3,8 @@\n {\n    char *addr;\n \n-   dri_sw_dt->shmid = shmget(IPC_PRIVATE, size, IPC_CREAT|0777);\n+   /* 0600 = user read+write */\n+   dri_sw_dt->shmid = shmget(IPC_PRIVATE, size, IPC_CREAT | 0600);\n    if (dri_sw_dt->shmid < 0)\n       return NULL;\n ",
        "diff_line_info": {
            "deleted_lines": [
                "   dri_sw_dt->shmid = shmget(IPC_PRIVATE, size, IPC_CREAT|0777);"
            ],
            "added_lines": [
                "   /* 0600 = user read+write */",
                "   dri_sw_dt->shmid = shmget(IPC_PRIVATE, size, IPC_CREAT | 0600);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-5068",
        "func_name": "mesa/alloc_shm",
        "description": "An exploitable shared memory permissions vulnerability exists in the functionality of X11 Mesa 3D Graphics Library 19.1.2. An attacker can access the shared memory without any specific permissions to trigger this vulnerability.",
        "git_url": "https://cgit.freedesktop.org/mesa/mesa/commit/?id=02c3dad0f3b4d26e0faa5cc51d06bc50d693dcdc",
        "commit_title": "A security advisory (TALOS-2019-0857/CVE-2019-5068) found that",
        "commit_text": "creating shared memory regions with permission mode 0777 could allow any user to access that memory.  Several Mesa drivers use shared- memory XImages to implement back buffers for improved performance.  This path changes the shmget() calls to use 0600 (user r/w).  Tested with legacy Xlib driver and llvmpipe.  Cc: mesa-stable@lists.freedesktop.org ",
        "func_before": "static char *\nalloc_shm(struct xlib_displaytarget *buf, unsigned size)\n{\n   XShmSegmentInfo *const shminfo = & buf->shminfo;\n\n   shminfo->shmid = -1;\n   shminfo->shmaddr = (char *) -1;\n\n   shminfo->shmid = shmget(IPC_PRIVATE, size, IPC_CREAT|0777);\n   if (shminfo->shmid < 0) {\n      return NULL;\n   }\n\n   shminfo->shmaddr = (char *) shmat(shminfo->shmid, 0, 0);\n   if (shminfo->shmaddr == (char *) -1) {\n      shmctl(shminfo->shmid, IPC_RMID, 0);\n      return NULL;\n   }\n\n   shminfo->readOnly = False;\n   return shminfo->shmaddr;\n}",
        "func": "static char *\nalloc_shm(struct xlib_displaytarget *buf, unsigned size)\n{\n   XShmSegmentInfo *const shminfo = & buf->shminfo;\n\n   shminfo->shmid = -1;\n   shminfo->shmaddr = (char *) -1;\n\n   /* 0600 = user read+write */\n   shminfo->shmid = shmget(IPC_PRIVATE, size, IPC_CREAT | 0600);\n   if (shminfo->shmid < 0) {\n      return NULL;\n   }\n\n   shminfo->shmaddr = (char *) shmat(shminfo->shmid, 0, 0);\n   if (shminfo->shmaddr == (char *) -1) {\n      shmctl(shminfo->shmid, IPC_RMID, 0);\n      return NULL;\n   }\n\n   shminfo->readOnly = False;\n   return shminfo->shmaddr;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -6,7 +6,8 @@\n    shminfo->shmid = -1;\n    shminfo->shmaddr = (char *) -1;\n \n-   shminfo->shmid = shmget(IPC_PRIVATE, size, IPC_CREAT|0777);\n+   /* 0600 = user read+write */\n+   shminfo->shmid = shmget(IPC_PRIVATE, size, IPC_CREAT | 0600);\n    if (shminfo->shmid < 0) {\n       return NULL;\n    }",
        "diff_line_info": {
            "deleted_lines": [
                "   shminfo->shmid = shmget(IPC_PRIVATE, size, IPC_CREAT|0777);"
            ],
            "added_lines": [
                "   /* 0600 = user read+write */",
                "   shminfo->shmid = shmget(IPC_PRIVATE, size, IPC_CREAT | 0600);"
            ]
        }
    },
    {
        "cve_id": "CVE-2019-5068",
        "func_name": "mesa/alloc_back_shm_ximage",
        "description": "An exploitable shared memory permissions vulnerability exists in the functionality of X11 Mesa 3D Graphics Library 19.1.2. An attacker can access the shared memory without any specific permissions to trigger this vulnerability.",
        "git_url": "https://cgit.freedesktop.org/mesa/mesa/commit/?id=02c3dad0f3b4d26e0faa5cc51d06bc50d693dcdc",
        "commit_title": "A security advisory (TALOS-2019-0857/CVE-2019-5068) found that",
        "commit_text": "creating shared memory regions with permission mode 0777 could allow any user to access that memory.  Several Mesa drivers use shared- memory XImages to implement back buffers for improved performance.  This path changes the shmget() calls to use 0600 (user r/w).  Tested with legacy Xlib driver and llvmpipe.  Cc: mesa-stable@lists.freedesktop.org ",
        "func_before": "static GLboolean\nalloc_back_shm_ximage(XMesaBuffer b, GLuint width, GLuint height)\n{\n   /*\n    * We have to do a _lot_ of error checking here to be sure we can\n    * really use the XSHM extension.  It seems different servers trigger\n    * errors at different points if the extension won't work.  Therefore\n    * we have to be very careful...\n    */\n   GC gc;\n   int (*old_handler)(XMesaDisplay *, XErrorEvent *);\n\n   if (width == 0 || height == 0) {\n      /* this will be true the first time we're called on 'b' */\n      return GL_FALSE;\n   }\n\n   b->backxrb->ximage = XShmCreateImage(b->xm_visual->display,\n                                        b->xm_visual->visinfo->visual,\n                                        b->xm_visual->visinfo->depth,\n                                        ZPixmap, NULL, &b->shminfo,\n                                        width, height);\n   if (b->backxrb->ximage == NULL) {\n      _mesa_warning(NULL, \"alloc_back_buffer: Shared memory error (XShmCreateImage), disabling.\\n\");\n      b->shm = 0;\n      return GL_FALSE;\n   }\n\n   b->shminfo.shmid = shmget(IPC_PRIVATE, b->backxrb->ximage->bytes_per_line\n\t\t\t     * b->backxrb->ximage->height, IPC_CREAT|0777);\n   if (b->shminfo.shmid < 0) {\n      _mesa_warning(NULL, \"shmget failed while allocating back buffer.\\n\");\n      XDestroyImage(b->backxrb->ximage);\n      b->backxrb->ximage = NULL;\n      _mesa_warning(NULL, \"alloc_back_buffer: Shared memory error (shmget), disabling.\\n\");\n      b->shm = 0;\n      return GL_FALSE;\n   }\n\n   b->shminfo.shmaddr = b->backxrb->ximage->data\n                      = (char*)shmat(b->shminfo.shmid, 0, 0);\n   if (b->shminfo.shmaddr == (char *) -1) {\n      _mesa_warning(NULL, \"shmat() failed while allocating back buffer.\\n\");\n      XDestroyImage(b->backxrb->ximage);\n      shmctl(b->shminfo.shmid, IPC_RMID, 0);\n      b->backxrb->ximage = NULL;\n      _mesa_warning(NULL, \"alloc_back_buffer: Shared memory error (shmat), disabling.\\n\");\n      b->shm = 0;\n      return GL_FALSE;\n   }\n\n   b->shminfo.readOnly = False;\n   mesaXErrorFlag = 0;\n   old_handler = XSetErrorHandler(mesaHandleXError);\n   /* This may trigger the X protocol error we're ready to catch: */\n   XShmAttach(b->xm_visual->display, &b->shminfo);\n   XSync(b->xm_visual->display, False);\n\n   if (mesaXErrorFlag) {\n      /* we are on a remote display, this error is normal, don't print it */\n      XFlush(b->xm_visual->display);\n      mesaXErrorFlag = 0;\n      XDestroyImage(b->backxrb->ximage);\n      shmdt(b->shminfo.shmaddr);\n      shmctl(b->shminfo.shmid, IPC_RMID, 0);\n      b->backxrb->ximage = NULL;\n      b->shm = 0;\n      (void) XSetErrorHandler(old_handler);\n      return GL_FALSE;\n   }\n\n   shmctl(b->shminfo.shmid, IPC_RMID, 0); /* nobody else needs it */\n\n   /* Finally, try an XShmPutImage to be really sure the extension works */\n   gc = XCreateGC(b->xm_visual->display, b->frontxrb->drawable, 0, NULL);\n   XShmPutImage(b->xm_visual->display, b->frontxrb->drawable, gc,\n\t\t b->backxrb->ximage, 0, 0, 0, 0, 1, 1 /*one pixel*/, False);\n   XSync(b->xm_visual->display, False);\n   XFreeGC(b->xm_visual->display, gc);\n   (void) XSetErrorHandler(old_handler);\n   if (mesaXErrorFlag) {\n      XFlush(b->xm_visual->display);\n      mesaXErrorFlag = 0;\n      XDestroyImage(b->backxrb->ximage);\n      shmdt(b->shminfo.shmaddr);\n      shmctl(b->shminfo.shmid, IPC_RMID, 0);\n      b->backxrb->ximage = NULL;\n      b->shm = 0;\n      return GL_FALSE;\n   }\n\n   return GL_TRUE;\n}",
        "func": "static GLboolean\nalloc_back_shm_ximage(XMesaBuffer b, GLuint width, GLuint height)\n{\n   /*\n    * We have to do a _lot_ of error checking here to be sure we can\n    * really use the XSHM extension.  It seems different servers trigger\n    * errors at different points if the extension won't work.  Therefore\n    * we have to be very careful...\n    */\n   GC gc;\n   int (*old_handler)(XMesaDisplay *, XErrorEvent *);\n\n   if (width == 0 || height == 0) {\n      /* this will be true the first time we're called on 'b' */\n      return GL_FALSE;\n   }\n\n   b->backxrb->ximage = XShmCreateImage(b->xm_visual->display,\n                                        b->xm_visual->visinfo->visual,\n                                        b->xm_visual->visinfo->depth,\n                                        ZPixmap, NULL, &b->shminfo,\n                                        width, height);\n   if (b->backxrb->ximage == NULL) {\n      _mesa_warning(NULL, \"alloc_back_buffer: Shared memory error (XShmCreateImage), disabling.\\n\");\n      b->shm = 0;\n      return GL_FALSE;\n   }\n\n   /* 0600 = user read+write */\n   b->shminfo.shmid = shmget(IPC_PRIVATE, b->backxrb->ximage->bytes_per_line\n                             * b->backxrb->ximage->height, IPC_CREAT | 0600);\n   if (b->shminfo.shmid < 0) {\n      _mesa_warning(NULL, \"shmget failed while allocating back buffer.\\n\");\n      XDestroyImage(b->backxrb->ximage);\n      b->backxrb->ximage = NULL;\n      _mesa_warning(NULL, \"alloc_back_buffer: Shared memory error (shmget), disabling.\\n\");\n      b->shm = 0;\n      return GL_FALSE;\n   }\n\n   b->shminfo.shmaddr = b->backxrb->ximage->data\n                      = (char*)shmat(b->shminfo.shmid, 0, 0);\n   if (b->shminfo.shmaddr == (char *) -1) {\n      _mesa_warning(NULL, \"shmat() failed while allocating back buffer.\\n\");\n      XDestroyImage(b->backxrb->ximage);\n      shmctl(b->shminfo.shmid, IPC_RMID, 0);\n      b->backxrb->ximage = NULL;\n      _mesa_warning(NULL, \"alloc_back_buffer: Shared memory error (shmat), disabling.\\n\");\n      b->shm = 0;\n      return GL_FALSE;\n   }\n\n   b->shminfo.readOnly = False;\n   mesaXErrorFlag = 0;\n   old_handler = XSetErrorHandler(mesaHandleXError);\n   /* This may trigger the X protocol error we're ready to catch: */\n   XShmAttach(b->xm_visual->display, &b->shminfo);\n   XSync(b->xm_visual->display, False);\n\n   if (mesaXErrorFlag) {\n      /* we are on a remote display, this error is normal, don't print it */\n      XFlush(b->xm_visual->display);\n      mesaXErrorFlag = 0;\n      XDestroyImage(b->backxrb->ximage);\n      shmdt(b->shminfo.shmaddr);\n      shmctl(b->shminfo.shmid, IPC_RMID, 0);\n      b->backxrb->ximage = NULL;\n      b->shm = 0;\n      (void) XSetErrorHandler(old_handler);\n      return GL_FALSE;\n   }\n\n   shmctl(b->shminfo.shmid, IPC_RMID, 0); /* nobody else needs it */\n\n   /* Finally, try an XShmPutImage to be really sure the extension works */\n   gc = XCreateGC(b->xm_visual->display, b->frontxrb->drawable, 0, NULL);\n   XShmPutImage(b->xm_visual->display, b->frontxrb->drawable, gc,\n\t\t b->backxrb->ximage, 0, 0, 0, 0, 1, 1 /*one pixel*/, False);\n   XSync(b->xm_visual->display, False);\n   XFreeGC(b->xm_visual->display, gc);\n   (void) XSetErrorHandler(old_handler);\n   if (mesaXErrorFlag) {\n      XFlush(b->xm_visual->display);\n      mesaXErrorFlag = 0;\n      XDestroyImage(b->backxrb->ximage);\n      shmdt(b->shminfo.shmaddr);\n      shmctl(b->shminfo.shmid, IPC_RMID, 0);\n      b->backxrb->ximage = NULL;\n      b->shm = 0;\n      return GL_FALSE;\n   }\n\n   return GL_TRUE;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -26,8 +26,9 @@\n       return GL_FALSE;\n    }\n \n+   /* 0600 = user read+write */\n    b->shminfo.shmid = shmget(IPC_PRIVATE, b->backxrb->ximage->bytes_per_line\n-\t\t\t     * b->backxrb->ximage->height, IPC_CREAT|0777);\n+                             * b->backxrb->ximage->height, IPC_CREAT | 0600);\n    if (b->shminfo.shmid < 0) {\n       _mesa_warning(NULL, \"shmget failed while allocating back buffer.\\n\");\n       XDestroyImage(b->backxrb->ximage);",
        "diff_line_info": {
            "deleted_lines": [
                "\t\t\t     * b->backxrb->ximage->height, IPC_CREAT|0777);"
            ],
            "added_lines": [
                "   /* 0600 = user read+write */",
                "                             * b->backxrb->ximage->height, IPC_CREAT | 0600);"
            ]
        }
    },
    {
        "cve_id": "CVE-2021-44512",
        "func_name": "tmate-io/tmate-ssh-server/main",
        "description": "World-writable permissions on the /tmp/tmate/sessions directory in tmate-ssh-server 2.3.0 allow a local attacker to compromise the integrity of session handling, or obtain the read-write session ID from a read-only session symlink in this directory.",
        "git_url": "https://github.com/tmate-io/tmate-ssh-server/commit/1c020d1f5ca462f5b150b46a027aaa1bbe3c9596",
        "commit_title": "Harden /tmp/tmate directory",
        "commit_text": " Suggested by Matthias Gerstner",
        "func_before": "int main(int argc, char **argv, char **envp)\n{\n\tint opt;\n\n\twhile ((opt = getopt(argc, argv, \"b:h:k:p:q:w:z:xv\")) != -1) {\n\t\tswitch (opt) {\n\t\tcase 'b':\n\t\t\ttmate_settings->bind_addr = xstrdup(optarg);\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\ttmate_settings->tmate_host = xstrdup(optarg);\n\t\t\tbreak;\n\t\tcase 'k':\n\t\t\ttmate_settings->keys_dir = xstrdup(optarg);\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\ttmate_settings->ssh_port = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'q':\n\t\t\ttmate_settings->ssh_port_advertized = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\ttmate_settings->websocket_hostname = xstrdup(optarg);\n\t\t\tbreak;\n\t\tcase 'z':\n\t\t\ttmate_settings->websocket_port = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'x':\n\t\t\ttmate_settings->use_proxy_protocol = true;\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\ttmate_settings->log_level++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage();\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tinit_logging(tmate_settings->log_level);\n\n\tsetup_locale();\n\n\tif (!tmate_settings->tmate_host)\n\t\ttmate_settings->tmate_host = get_full_hostname();\n\n\tcmdline = *argv;\n\tcmdline_end = *envp;\n\n\ttmate_preload_trace_lib();\n\ttmate_catch_sigsegv();\n\ttmate_init_rand();\n\n\tif ((mkdir(TMATE_WORKDIR, 0701)             < 0 && errno != EEXIST) ||\n\t    (mkdir(TMATE_WORKDIR \"/sessions\", 0703) < 0 && errno != EEXIST) ||\n\t    (mkdir(TMATE_WORKDIR \"/jail\", 0700)     < 0 && errno != EEXIST))\n\t\ttmate_fatal(\"Cannot prepare session in \" TMATE_WORKDIR);\n\n\t/* The websocket server needs to access the /session dir to rename sockets */\n\tif ((chmod(TMATE_WORKDIR, 0701)             < 0) ||\n\t    (chmod(TMATE_WORKDIR \"/sessions\", 0703) < 0) ||\n\t    (chmod(TMATE_WORKDIR \"/jail\", 0700)     < 0))\n\t\ttmate_fatal(\"Cannot prepare session in \" TMATE_WORKDIR);\n\n\ttmate_ssh_server_main(tmate_session,\n\t\t\t      tmate_settings->keys_dir, tmate_settings->bind_addr, tmate_settings->ssh_port);\n\treturn 0;\n}",
        "func": "int main(int argc, char **argv, char **envp)\n{\n\tint opt;\n\n\twhile ((opt = getopt(argc, argv, \"b:h:k:p:q:w:z:xv\")) != -1) {\n\t\tswitch (opt) {\n\t\tcase 'b':\n\t\t\ttmate_settings->bind_addr = xstrdup(optarg);\n\t\t\tbreak;\n\t\tcase 'h':\n\t\t\ttmate_settings->tmate_host = xstrdup(optarg);\n\t\t\tbreak;\n\t\tcase 'k':\n\t\t\ttmate_settings->keys_dir = xstrdup(optarg);\n\t\t\tbreak;\n\t\tcase 'p':\n\t\t\ttmate_settings->ssh_port = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'q':\n\t\t\ttmate_settings->ssh_port_advertized = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'w':\n\t\t\ttmate_settings->websocket_hostname = xstrdup(optarg);\n\t\t\tbreak;\n\t\tcase 'z':\n\t\t\ttmate_settings->websocket_port = atoi(optarg);\n\t\t\tbreak;\n\t\tcase 'x':\n\t\t\ttmate_settings->use_proxy_protocol = true;\n\t\t\tbreak;\n\t\tcase 'v':\n\t\t\ttmate_settings->log_level++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage();\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tinit_logging(tmate_settings->log_level);\n\n\tsetup_locale();\n\n\tif (!tmate_settings->tmate_host)\n\t\ttmate_settings->tmate_host = get_full_hostname();\n\n\tcmdline = *argv;\n\tcmdline_end = *envp;\n\n\ttmate_preload_trace_lib();\n\ttmate_catch_sigsegv();\n\ttmate_init_rand();\n\n\tif ((mkdir(TMATE_WORKDIR, 0700)             < 0 && errno != EEXIST) ||\n\t    (mkdir(TMATE_WORKDIR \"/sessions\", 0700) < 0 && errno != EEXIST) ||\n\t    (mkdir(TMATE_WORKDIR \"/jail\", 0700)     < 0 && errno != EEXIST))\n\t\ttmate_fatal(\"Cannot prepare session in \" TMATE_WORKDIR);\n\n\tif ((chmod(TMATE_WORKDIR, 0700)             < 0) ||\n\t    (chmod(TMATE_WORKDIR \"/sessions\", 0700) < 0) ||\n\t    (chmod(TMATE_WORKDIR \"/jail\", 0700)     < 0))\n\t\ttmate_fatal(\"Cannot prepare session in \" TMATE_WORKDIR);\n\n\tif (check_owned_directory_mode(TMATE_WORKDIR, 0700) ||\n\t    check_owned_directory_mode(TMATE_WORKDIR \"/sessions\", 0700) ||\n\t    check_owned_directory_mode(TMATE_WORKDIR \"/jail\", 0700))\n\t\ttmate_fatal(TMATE_WORKDIR \" and subdirectories has incorrect ownership/mode. \"\n\t\t\t    \"Try deleting \" TMATE_WORKDIR \" and try again\");\n\n\ttmate_ssh_server_main(tmate_session,\n\t\t\t      tmate_settings->keys_dir, tmate_settings->bind_addr, tmate_settings->ssh_port);\n\treturn 0;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -51,16 +51,21 @@\n \ttmate_catch_sigsegv();\n \ttmate_init_rand();\n \n-\tif ((mkdir(TMATE_WORKDIR, 0701)             < 0 && errno != EEXIST) ||\n-\t    (mkdir(TMATE_WORKDIR \"/sessions\", 0703) < 0 && errno != EEXIST) ||\n+\tif ((mkdir(TMATE_WORKDIR, 0700)             < 0 && errno != EEXIST) ||\n+\t    (mkdir(TMATE_WORKDIR \"/sessions\", 0700) < 0 && errno != EEXIST) ||\n \t    (mkdir(TMATE_WORKDIR \"/jail\", 0700)     < 0 && errno != EEXIST))\n \t\ttmate_fatal(\"Cannot prepare session in \" TMATE_WORKDIR);\n \n-\t/* The websocket server needs to access the /session dir to rename sockets */\n-\tif ((chmod(TMATE_WORKDIR, 0701)             < 0) ||\n-\t    (chmod(TMATE_WORKDIR \"/sessions\", 0703) < 0) ||\n+\tif ((chmod(TMATE_WORKDIR, 0700)             < 0) ||\n+\t    (chmod(TMATE_WORKDIR \"/sessions\", 0700) < 0) ||\n \t    (chmod(TMATE_WORKDIR \"/jail\", 0700)     < 0))\n \t\ttmate_fatal(\"Cannot prepare session in \" TMATE_WORKDIR);\n+\n+\tif (check_owned_directory_mode(TMATE_WORKDIR, 0700) ||\n+\t    check_owned_directory_mode(TMATE_WORKDIR \"/sessions\", 0700) ||\n+\t    check_owned_directory_mode(TMATE_WORKDIR \"/jail\", 0700))\n+\t\ttmate_fatal(TMATE_WORKDIR \" and subdirectories has incorrect ownership/mode. \"\n+\t\t\t    \"Try deleting \" TMATE_WORKDIR \" and try again\");\n \n \ttmate_ssh_server_main(tmate_session,\n \t\t\t      tmate_settings->keys_dir, tmate_settings->bind_addr, tmate_settings->ssh_port);",
        "diff_line_info": {
            "deleted_lines": [
                "\tif ((mkdir(TMATE_WORKDIR, 0701)             < 0 && errno != EEXIST) ||",
                "\t    (mkdir(TMATE_WORKDIR \"/sessions\", 0703) < 0 && errno != EEXIST) ||",
                "\t/* The websocket server needs to access the /session dir to rename sockets */",
                "\tif ((chmod(TMATE_WORKDIR, 0701)             < 0) ||",
                "\t    (chmod(TMATE_WORKDIR \"/sessions\", 0703) < 0) ||"
            ],
            "added_lines": [
                "\tif ((mkdir(TMATE_WORKDIR, 0700)             < 0 && errno != EEXIST) ||",
                "\t    (mkdir(TMATE_WORKDIR \"/sessions\", 0700) < 0 && errno != EEXIST) ||",
                "\tif ((chmod(TMATE_WORKDIR, 0700)             < 0) ||",
                "\t    (chmod(TMATE_WORKDIR \"/sessions\", 0700) < 0) ||",
                "",
                "\tif (check_owned_directory_mode(TMATE_WORKDIR, 0700) ||",
                "\t    check_owned_directory_mode(TMATE_WORKDIR \"/sessions\", 0700) ||",
                "\t    check_owned_directory_mode(TMATE_WORKDIR \"/jail\", 0700))",
                "\t\ttmate_fatal(TMATE_WORKDIR \" and subdirectories has incorrect ownership/mode. \"",
                "\t\t\t    \"Try deleting \" TMATE_WORKDIR \" and try again\");"
            ]
        }
    },
    {
        "cve_id": "CVE-2023-50446",
        "func_name": "mullvad/mullvadvpn-app/MigrateCacheServiceUser",
        "description": "An issue was discovered in Mullvad VPN Windows app before 2023.6-beta1. Insufficient permissions on a directory allow any local unprivileged user to escalate privileges to SYSTEM.",
        "git_url": "https://github.com/mullvad/mullvadvpn-app/commit/59126cfb4dcf278565fadf84f36ff39e89d5f9ae",
        "commit_title": "Stronger permissions for mullvad directories",
        "commit_text": " Set read-only permissions for authenticated users and full-access for admins for relevant mullvad directories on creation.",
        "func_before": "void MigrateCacheServiceUser()\n{\n\tconst auto newCacheDir = GetSystemCacheDirectory();\n\tcommon::fs::Mkdir(newCacheDir);\n\n\tconst auto localAppData = GetSystemUserLocalAppData();\n\tconst auto oldCacheDir = std::filesystem::path(localAppData).append(L\"Mullvad VPN\");\n\n\tcommon::fs::ScopedNativeFileSystem nativeFileSystem;\n\n\tcommon::security::AddAdminToObjectDacl(oldCacheDir, SE_FILE_OBJECT);\n\n\t{\n\t\tcommon::fs::FileEnumerator files(oldCacheDir);\n\n\t\tauto notNamedSet = std::make_unique<common::fs::FilterNotNamedSet>();\n\n\t\tnotNamedSet->addObject(L\"account-history.json\");\n\t\tnotNamedSet->addObject(L\"settings.json\");\n\t\tnotNamedSet->addObject(L\"device.json\");\n\n\t\tfiles.addFilter(std::move(notNamedSet));\n\t\tfiles.addFilter(std::make_unique<common::fs::FilterFiles>());\n\n\t\tWIN32_FIND_DATAW file;\n\n\t\twhile (files.next(file))\n\t\t{\n\t\t\tconst auto source = std::filesystem::path(files.getDirectory()).append(file.cFileName);\n\t\t\tconst auto target = std::filesystem::path(newCacheDir).append(file.cFileName);\n\t\t\tstd::filesystem::rename(source, target);\n\t\t}\n\t}\n\n\t//\n\t// This fails unless the directory is empty. Settings remain in this directory.\n\t//\n\tRemoveDirectoryW(std::wstring(L\"\\\\\\\\?\\\\\").append(oldCacheDir).c_str());\n}",
        "func": "void MigrateCacheServiceUser()\n{\n\tconst auto newCacheDir = GetSystemCacheDirectory();\n\tcommon::fs::Mkdir(newCacheDir);\n\n\tconst auto localAppData = GetSystemUserLocalAppData();\n\n\tconst auto oldCacheDir = std::filesystem::path(localAppData).append(L\"Mullvad VPN\");\n\n\tcommon::fs::ScopedNativeFileSystem nativeFileSystem;\n\n\tcommon::security::AddAdminToObjectDacl(oldCacheDir, SE_FILE_OBJECT);\n\n\t{\n\t\tcommon::fs::FileEnumerator files(oldCacheDir);\n\n\t\tauto notNamedSet = std::make_unique<common::fs::FilterNotNamedSet>();\n\n\t\tnotNamedSet->addObject(L\"account-history.json\");\n\t\tnotNamedSet->addObject(L\"settings.json\");\n\t\tnotNamedSet->addObject(L\"device.json\");\n\n\t\tfiles.addFilter(std::move(notNamedSet));\n\t\tfiles.addFilter(std::make_unique<common::fs::FilterFiles>());\n\n\t\tWIN32_FIND_DATAW file;\n\n\t\twhile (files.next(file))\n\t\t{\n\t\t\tconst auto source = std::filesystem::path(files.getDirectory()).append(file.cFileName);\n\t\t\tconst auto target = std::filesystem::path(newCacheDir).append(file.cFileName);\n\t\t\tstd::filesystem::rename(source, target);\n\t\t}\n\t}\n\n\t//\n\t// This fails unless the directory is empty. Settings remain in this directory.\n\t//\n\tRemoveDirectoryW(std::wstring(L\"\\\\\\\\?\\\\\").append(oldCacheDir).c_str());\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -4,6 +4,7 @@\n \tcommon::fs::Mkdir(newCacheDir);\n \n \tconst auto localAppData = GetSystemUserLocalAppData();\n+\n \tconst auto oldCacheDir = std::filesystem::path(localAppData).append(L\"Mullvad VPN\");\n \n \tcommon::fs::ScopedNativeFileSystem nativeFileSystem;",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                ""
            ]
        }
    },
    {
        "cve_id": "CVE-2020-29074",
        "func_name": "LibVNC/x11vnc/shm_create",
        "description": "scan.c in x11vnc 0.9.16 uses IPC_CREAT|0777 in shmget calls, which allows access by actors other than the current user.",
        "git_url": "https://github.com/LibVNC/x11vnc/commit/69eeb9f7baa14ca03b16c9de821f9876def7a36a",
        "commit_title": "scan: limit access to shared memory segments to current user",
        "commit_text": "",
        "func_before": "static int shm_create(XShmSegmentInfo *shm, XImage **ximg_ptr, int w, int h,\n    char *name) {\n\n\tXImage *xim;\n\tstatic int reported_flip = 0;\n\tint db = 0;\n\n\tshm->shmid = -1;\n\tshm->shmaddr = (char *) -1;\n\t*ximg_ptr = NULL;\n\n\tif (nofb) {\n\t\treturn 1;\n\t}\n\n\tX_LOCK;\n\n\tif (! using_shm || xform24to32 || raw_fb) {\n\t\t/* we only need the XImage created */\n\t\txim = XCreateImage_wr(dpy, default_visual, depth, ZPixmap,\n\t\t    0, NULL, w, h, raw_fb ? 32 : BitmapPad(dpy), 0);\n\n\t\tX_UNLOCK;\n\n\t\tif (xim == NULL) {\n\t\t\trfbErr(\"XCreateImage(%s) failed.\\n\", name);\n\t\t\tif (quiet) {\n\t\t\t\tfprintf(stderr, \"XCreateImage(%s) failed.\\n\",\n\t\t\t\t    name);\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tif (db) fprintf(stderr, \"shm_create simple %d %d\\t%p %s\\n\", w, h, (void *)xim, name);\n\t\txim->data = (char *) malloc(xim->bytes_per_line * xim->height);\n\t\tif (xim->data == NULL) {\n\t\t\trfbErr(\"XCreateImage(%s) data malloc failed.\\n\", name);\n\t\t\tif (quiet) {\n\t\t\t\tfprintf(stderr, \"XCreateImage(%s) data malloc\"\n\t\t\t\t    \" failed.\\n\", name);\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tif (flip_byte_order) {\n\t\t\tchar *order = flip_ximage_byte_order(xim);\n\t\t\tif (! reported_flip && ! quiet) {\n\t\t\t\trfbLog(\"Changing XImage byte order\"\n\t\t\t\t    \" to %s\\n\", order);\n\t\t\t\treported_flip = 1;\n\t\t\t}\n\t\t}\n\n\t\t*ximg_ptr = xim;\n\t\treturn 1;\n\t}\n\n\tif (! dpy) {\n\t\tX_UNLOCK;\n\t\treturn 0;\n\t}\n\n\txim = XShmCreateImage_wr(dpy, default_visual, depth, ZPixmap, NULL,\n\t    shm, w, h);\n\n\tif (xim == NULL) {\n\t\trfbErr(\"XShmCreateImage(%s) failed.\\n\", name);\n\t\tif (quiet) {\n\t\t\tfprintf(stderr, \"XShmCreateImage(%s) failed.\\n\", name);\n\t\t}\n\t\tX_UNLOCK;\n\t\treturn 0;\n\t}\n\n\t*ximg_ptr = xim;\n\n#if HAVE_XSHM\n\tshm->shmid = shmget(IPC_PRIVATE,\n\t    xim->bytes_per_line * xim->height, IPC_CREAT | 0777);\n\n\tif (shm->shmid == -1) {\n\t\trfbErr(\"shmget(%s) failed.\\n\", name);\n\t\trfbLogPerror(\"shmget\");\n\n\t\tXDestroyImage(xim);\n\t\t*ximg_ptr = NULL;\n\n\t\tX_UNLOCK;\n\t\treturn 0;\n\t}\n\n\tshm->shmaddr = xim->data = (char *) shmat(shm->shmid, 0, 0);\n\n\tif (shm->shmaddr == (char *)-1) {\n\t\trfbErr(\"shmat(%s) failed.\\n\", name);\n\t\trfbLogPerror(\"shmat\");\n\n\t\tXDestroyImage(xim);\n\t\t*ximg_ptr = NULL;\n\n\t\tshmctl(shm->shmid, IPC_RMID, 0);\n\t\tshm->shmid = -1;\n\n\t\tX_UNLOCK;\n\t\treturn 0;\n\t}\n\n\tshm->readOnly = False;\n\n\tif (! XShmAttach_wr(dpy, shm)) {\n\t\trfbErr(\"XShmAttach(%s) failed.\\n\", name);\n\t\tXDestroyImage(xim);\n\t\t*ximg_ptr = NULL;\n\n\t\tshmdt(shm->shmaddr);\n\t\tshm->shmaddr = (char *) -1;\n\n\t\tshmctl(shm->shmid, IPC_RMID, 0);\n\t\tshm->shmid = -1;\n\n\t\tX_UNLOCK;\n\t\treturn 0;\n\t}\n#endif\n\n\tX_UNLOCK;\n\treturn 1;\n}",
        "func": "static int shm_create(XShmSegmentInfo *shm, XImage **ximg_ptr, int w, int h,\n    char *name) {\n\n\tXImage *xim;\n\tstatic int reported_flip = 0;\n\tint db = 0;\n\n\tshm->shmid = -1;\n\tshm->shmaddr = (char *) -1;\n\t*ximg_ptr = NULL;\n\n\tif (nofb) {\n\t\treturn 1;\n\t}\n\n\tX_LOCK;\n\n\tif (! using_shm || xform24to32 || raw_fb) {\n\t\t/* we only need the XImage created */\n\t\txim = XCreateImage_wr(dpy, default_visual, depth, ZPixmap,\n\t\t    0, NULL, w, h, raw_fb ? 32 : BitmapPad(dpy), 0);\n\n\t\tX_UNLOCK;\n\n\t\tif (xim == NULL) {\n\t\t\trfbErr(\"XCreateImage(%s) failed.\\n\", name);\n\t\t\tif (quiet) {\n\t\t\t\tfprintf(stderr, \"XCreateImage(%s) failed.\\n\",\n\t\t\t\t    name);\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tif (db) fprintf(stderr, \"shm_create simple %d %d\\t%p %s\\n\", w, h, (void *)xim, name);\n\t\txim->data = (char *) malloc(xim->bytes_per_line * xim->height);\n\t\tif (xim->data == NULL) {\n\t\t\trfbErr(\"XCreateImage(%s) data malloc failed.\\n\", name);\n\t\t\tif (quiet) {\n\t\t\t\tfprintf(stderr, \"XCreateImage(%s) data malloc\"\n\t\t\t\t    \" failed.\\n\", name);\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tif (flip_byte_order) {\n\t\t\tchar *order = flip_ximage_byte_order(xim);\n\t\t\tif (! reported_flip && ! quiet) {\n\t\t\t\trfbLog(\"Changing XImage byte order\"\n\t\t\t\t    \" to %s\\n\", order);\n\t\t\t\treported_flip = 1;\n\t\t\t}\n\t\t}\n\n\t\t*ximg_ptr = xim;\n\t\treturn 1;\n\t}\n\n\tif (! dpy) {\n\t\tX_UNLOCK;\n\t\treturn 0;\n\t}\n\n\txim = XShmCreateImage_wr(dpy, default_visual, depth, ZPixmap, NULL,\n\t    shm, w, h);\n\n\tif (xim == NULL) {\n\t\trfbErr(\"XShmCreateImage(%s) failed.\\n\", name);\n\t\tif (quiet) {\n\t\t\tfprintf(stderr, \"XShmCreateImage(%s) failed.\\n\", name);\n\t\t}\n\t\tX_UNLOCK;\n\t\treturn 0;\n\t}\n\n\t*ximg_ptr = xim;\n\n#if HAVE_XSHM\n\tshm->shmid = shmget(IPC_PRIVATE,\n\t    xim->bytes_per_line * xim->height, IPC_CREAT | 0600);\n\n\tif (shm->shmid == -1) {\n\t\trfbErr(\"shmget(%s) failed.\\n\", name);\n\t\trfbLogPerror(\"shmget\");\n\n\t\tXDestroyImage(xim);\n\t\t*ximg_ptr = NULL;\n\n\t\tX_UNLOCK;\n\t\treturn 0;\n\t}\n\n\tshm->shmaddr = xim->data = (char *) shmat(shm->shmid, 0, 0);\n\n\tif (shm->shmaddr == (char *)-1) {\n\t\trfbErr(\"shmat(%s) failed.\\n\", name);\n\t\trfbLogPerror(\"shmat\");\n\n\t\tXDestroyImage(xim);\n\t\t*ximg_ptr = NULL;\n\n\t\tshmctl(shm->shmid, IPC_RMID, 0);\n\t\tshm->shmid = -1;\n\n\t\tX_UNLOCK;\n\t\treturn 0;\n\t}\n\n\tshm->readOnly = False;\n\n\tif (! XShmAttach_wr(dpy, shm)) {\n\t\trfbErr(\"XShmAttach(%s) failed.\\n\", name);\n\t\tXDestroyImage(xim);\n\t\t*ximg_ptr = NULL;\n\n\t\tshmdt(shm->shmaddr);\n\t\tshm->shmaddr = (char *) -1;\n\n\t\tshmctl(shm->shmid, IPC_RMID, 0);\n\t\tshm->shmid = -1;\n\n\t\tX_UNLOCK;\n\t\treturn 0;\n\t}\n#endif\n\n\tX_UNLOCK;\n\treturn 1;\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -74,7 +74,7 @@\n \n #if HAVE_XSHM\n \tshm->shmid = shmget(IPC_PRIVATE,\n-\t    xim->bytes_per_line * xim->height, IPC_CREAT | 0777);\n+\t    xim->bytes_per_line * xim->height, IPC_CREAT | 0600);\n \n \tif (shm->shmid == -1) {\n \t\trfbErr(\"shmget(%s) failed.\\n\", name);",
        "diff_line_info": {
            "deleted_lines": [
                "\t    xim->bytes_per_line * xim->height, IPC_CREAT | 0777);"
            ],
            "added_lines": [
                "\t    xim->bytes_per_line * xim->height, IPC_CREAT | 0600);"
            ]
        }
    },
    {
        "cve_id": "CVE-2018-12615",
        "func_name": "phusion/passenger/switchGroup",
        "description": "An issue was discovered in switchGroup() in agent/ExecHelper/ExecHelperMain.cpp in Phusion Passenger before 5.3.2. The set of groups (gidset) is not set correctly, leaving it up to randomness (i.e., uninitialized memory) which supplementary groups are actually being set while lowering privileges.",
        "git_url": "https://github.com/phusion/passenger/commit/4e97fdb86d0a0141ec9a052c6e691fcd07bb45c8",
        "commit_title": "ExecHelperMain: fix privilege lowering code",
        "commit_text": "",
        "func_before": "static void\nswitchGroup(uid_t uid, const struct passwd *userInfo, gid_t gid) {\n\tif (userInfo != NULL) {\n\t\tbool setgroupsCalled = false;\n\n\t\t#if defined(__linux__) || defined(__APPLE__) || defined(__FreeBSD__)\n\t\t\t#ifdef __APPLE__\n\t\t\t\tint groups[1024];\n\t\t\t\tint ngroups = sizeof(groups) / sizeof(int);\n\t\t\t#else\n\t\t\t\tgid_t groups[1024];\n\t\t\t\tint ngroups = sizeof(groups) / sizeof(gid_t);\n\t\t\t#endif\n\t\t\tboost::scoped_array<gid_t> gidset;\n\n\t\t\tint ret = getgrouplist(userInfo->pw_name, gid,\n\t\t\t\tgroups, &ngroups);\n\t\t\tif (ret == -1) {\n\t\t\t\tint e = errno;\n\t\t\t\tfprintf(stderr, \"ERROR: getgrouplist(%s, %d) failed: %s (errno=%d)\\n\",\n\t\t\t\t\tuserInfo->pw_name, (int) gid, strerror(e), e);\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tif (ngroups <= NGROUPS_MAX) {\n\t\t\t\tsetgroupsCalled = true;\n\t\t\t\tgidset.reset(new gid_t[ngroups]);\n\t\t\t\tif (setgroups(ngroups, gidset.get()) == -1) {\n\t\t\t\t\tint e = errno;\n\t\t\t\t\tfprintf(stderr, \"ERROR: setgroups(%d, ...) failed: %s (errno=%d)\\n\",\n\t\t\t\t\t\tngroups, strerror(e), e);\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t}\n\t\t#endif\n\n\t\tif (!setgroupsCalled && initgroups(userInfo->pw_name, gid) == -1) {\n\t\t\tint e = errno;\n\t\t\tfprintf(stderr, \"ERROR: initgroups(%s, %d) failed: %s (errno=%d)\\n\",\n\t\t\t\tuserInfo->pw_name, (int) gid, strerror(e), e);\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tif (setgid(gid) == -1) {\n\t\tint e = errno;\n\t\tfprintf(stderr, \"ERROR: setgid(%d) failed: %s (errno=%d)\\n\",\n\t\t\t(int) gid, strerror(e), e);\n\t\texit(1);\n\t}\n}",
        "func": "static void\nswitchGroup(uid_t uid, const struct passwd *userInfo, gid_t gid) {\n\tif (userInfo != NULL) {\n\t\tbool setgroupsCalled = false;\n\n\t\t#if defined(__linux__) || defined(__APPLE__) || defined(__FreeBSD__)\n\t\t\t#ifdef __APPLE__\n\t\t\t\tint groups[1024];\n\t\t\t\tint ngroups = sizeof(groups) / sizeof(int);\n\t\t\t#else\n\t\t\t\tgid_t groups[1024];\n\t\t\t\tint ngroups = sizeof(groups) / sizeof(gid_t);\n\t\t\t#endif\n\t\t\tboost::scoped_array<gid_t> gidset;\n\n\t\t\tint ret = getgrouplist(userInfo->pw_name, gid,\n\t\t\t\tgroups, &ngroups);\n\t\t\tif (ret == -1) {\n\t\t\t\tint e = errno;\n\t\t\t\tfprintf(stderr, \"ERROR: getgrouplist(%s, %d) failed: %s (errno=%d)\\n\",\n\t\t\t\t\tuserInfo->pw_name, (int) gid, strerror(e), e);\n\t\t\t\texit(1);\n\t\t\t}\n\n\t\t\tif (ngroups <= NGROUPS_MAX) {\n\t\t\t\tsetgroupsCalled = true;\n\t\t\t\tgidset.reset(new gid_t[ngroups]);\n\t\t\t\tfor (int i = 0; i < ngroups; i++) {\n\t\t\t\t\tgidset[i] = groups[i];\n\t\t\t\t}\n\t\t\t\tif (setgroups(ngroups, gidset.get()) == -1) {\n\t\t\t\t\tint e = errno;\n\t\t\t\t\tfprintf(stderr, \"ERROR: setgroups(%d, ...) failed: %s (errno=%d)\\n\",\n\t\t\t\t\t\tngroups, strerror(e), e);\n\t\t\t\t\texit(1);\n\t\t\t\t}\n\t\t\t}\n\t\t#endif\n\n\t\tif (!setgroupsCalled && initgroups(userInfo->pw_name, gid) == -1) {\n\t\t\tint e = errno;\n\t\t\tfprintf(stderr, \"ERROR: initgroups(%s, %d) failed: %s (errno=%d)\\n\",\n\t\t\t\tuserInfo->pw_name, (int) gid, strerror(e), e);\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tif (setgid(gid) == -1) {\n\t\tint e = errno;\n\t\tfprintf(stderr, \"ERROR: setgid(%d) failed: %s (errno=%d)\\n\",\n\t\t\t(int) gid, strerror(e), e);\n\t\texit(1);\n\t}\n}",
        "diff_func": "--- func_before\n+++ func_after\n@@ -25,6 +25,9 @@\n \t\t\tif (ngroups <= NGROUPS_MAX) {\n \t\t\t\tsetgroupsCalled = true;\n \t\t\t\tgidset.reset(new gid_t[ngroups]);\n+\t\t\t\tfor (int i = 0; i < ngroups; i++) {\n+\t\t\t\t\tgidset[i] = groups[i];\n+\t\t\t\t}\n \t\t\t\tif (setgroups(ngroups, gidset.get()) == -1) {\n \t\t\t\t\tint e = errno;\n \t\t\t\t\tfprintf(stderr, \"ERROR: setgroups(%d, ...) failed: %s (errno=%d)\\n\",",
        "diff_line_info": {
            "deleted_lines": [],
            "added_lines": [
                "\t\t\t\tfor (int i = 0; i < ngroups; i++) {",
                "\t\t\t\t\tgidset[i] = groups[i];",
                "\t\t\t\t}"
            ]
        }
    }
]